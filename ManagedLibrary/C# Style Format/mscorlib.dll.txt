internal AssemblyRef : object {
internal string SystemConfiguration
internal string System
public string EcmaPublicKey
public string FrameworkPublicKeyFull
public string FrameworkPublicKeyFull2
public string MicrosoftPublicKey
public string MicrosoftJScript
public string MicrosoftVSDesigner
public string SystemData
public string SystemDesign
public string SystemDrawing
public string SystemWeb
public string SystemWebExtensions
public string SystemWindowsForms
}
internal Consts : object {
public string MonoVersion
public string MonoCompany
public string MonoProduct
public string MonoCopyright
public int MonoCorlibVersion
public string FxVersion
public string FxFileVersion
public string EnvironmentVersion
public string VsVersion
public string VsFileVersion
private string PublicKeyToken
public string AssemblyI18N
public string AssemblyMicrosoft_JScript
public string AssemblyMicrosoft_VisualStudio
public string AssemblyMicrosoft_VisualStudio_Web
public string AssemblyMicrosoft_VSDesigner
public string AssemblyMono_Http
public string AssemblyMono_Posix
public string AssemblyMono_Security
public string AssemblyMono_Messaging_RabbitMQ
public string AssemblyCorlib
public string AssemblySystem
public string AssemblySystem_Data
public string AssemblySystem_Design
public string AssemblySystem_DirectoryServices
public string AssemblySystem_Drawing
public string AssemblySystem_Drawing_Design
public string AssemblySystem_Messaging
public string AssemblySystem_Security
public string AssemblySystem_ServiceProcess
public string AssemblySystem_Web
public string AssemblySystem_Windows_Forms
public string AssemblySystem_2_0
public string AssemblySystemCore_3_5
public string AssemblySystem_Core
public string WindowsBase_3_0
public string AssemblyWindowsBase
public string AssemblyPresentationCore_3_5
public string AssemblyPresentationCore_4_0
public string AssemblyPresentationFramework_3_5
public string AssemblySystemServiceModel_3_0
}
internal Internal.Runtime.Augments.EnvironmentAugments : object {
public string StackTrace
}
internal Internal.Runtime.Augments.RuntimeThread : object {
public void InitializeThreadPoolThread()
}
internal Internal.Runtime.CompilerServices.RelocatedTypeAttribute : Attribute {
public void .ctor(string originalAssemblySimpleName)
}
internal Locale : object {
public string GetText(string msg)
public string GetText(string fmt, Object[] args)
}
internal Microsoft.Win32.ExpandString : object {
private string value
public void .ctor(string s)
public string ToString()
public string Expand()
}
internal Microsoft.Win32.IRegistryApi {
public RegistryKey CreateSubKey(RegistryKey rkey, string keyname)
public RegistryKey OpenRemoteBaseKey(RegistryHive hKey, string machineName)
public RegistryKey OpenSubKey(RegistryKey rkey, string keyname, bool writtable)
public void Flush(RegistryKey rkey)
public void Close(RegistryKey rkey)
public object GetValue(RegistryKey rkey, string name, object default_value, RegistryValueOptions options)
public RegistryValueKind GetValueKind(RegistryKey rkey, string name)
public void SetValue(RegistryKey rkey, string name, object value)
public int SubKeyCount(RegistryKey rkey)
public int ValueCount(RegistryKey rkey)
public void DeleteValue(RegistryKey rkey, string value, bool throw_if_missing)
public void DeleteKey(RegistryKey rkey, string keyName, bool throw_if_missing)
public String[] GetSubKeyNames(RegistryKey rkey)
public String[] GetValueNames(RegistryKey rkey)
public string ToString(RegistryKey rkey)
public void SetValue(RegistryKey rkey, string name, object value, RegistryValueKind valueKind)
public RegistryKey CreateSubKey(RegistryKey rkey, string keyname, RegistryOptions options)
public RegistryKey FromHandle(SafeRegistryHandle handle)
public IntPtr GetHandle(RegistryKey key)
}
internal Microsoft.Win32.KeyHandler : object {
private Hashtable key_to_handler
private Hashtable dir_to_handler
private string VolatileDirectoryName
public string Dir
private string ActualDir
public bool IsVolatile
private Hashtable values
private string file
private bool dirty
private string user_store
private string machine_store
public int ValueCount
public bool IsMarkedForDeletion
private string UserStore
private string MachineStore
private void .ctor(RegistryKey rkey, string basedir)
private void .ctor(RegistryKey rkey, string basedir, bool is_volatile)
public void Load()
private void LoadKey(SecurityElement se)
public RegistryKey Ensure(RegistryKey rkey, string extra, bool writable)
public RegistryKey Ensure(RegistryKey rkey, string extra, bool writable, bool is_volatile)
public RegistryKey Probe(RegistryKey rkey, string extra, bool writable)
private string CombineName(RegistryKey rkey, string extra)
private long GetSystemBootTime()
private long GetRegisteredBootTime(string path)
private void SaveRegisteredBootTime(string path, long btime)
private void CleanVolatileKeys()
public bool VolatileKeyExists(string dir)
public string GetVolatileDir(string dir)
public KeyHandler Lookup(RegistryKey rkey, bool createNonExisting)
private string GetRootFromDir(string dir)
public void Drop(RegistryKey rkey)
public void Drop(string dir)
public bool Delete(string dir)
public RegistryValueKind GetValueKind(string name)
public object GetValue(string name, RegistryValueOptions options)
public void SetValue(string name, object value)
public String[] GetValueNames()
public int GetSubKeyCount()
public String[] GetSubKeyNames()
public void SetValue(string name, object value, RegistryValueKind valueKind)
private void SetDirty()
public void DirtyTimeout(object state)
public void Flush()
public bool ValueExists(string name)
public int get_ValueCount()
public bool get_IsMarkedForDeletion()
public void RemoveValue(string name)
protected void Finalize()
private void Save()
private void AssertNotMarkedForDeletion()
private string get_UserStore()
private string get_MachineStore()
}
internal Microsoft.Win32.NativeMethods : object {
public int GetCurrentProcessId()
}
public Microsoft.Win32.Registry : object {
public RegistryKey ClassesRoot
public RegistryKey CurrentConfig
public RegistryKey CurrentUser
public RegistryKey DynData
public RegistryKey LocalMachine
public RegistryKey PerformanceData
public RegistryKey Users
private RegistryKey ToKey(string keyName, bool setting)
public void SetValue(string keyName, string valueName, object value)
public void SetValue(string keyName, string valueName, object value, RegistryValueKind valueKind)
public object GetValue(string keyName, string valueName, object defaultValue)
}
public Microsoft.Win32.RegistryHive : Enum {
public int value__
public RegistryHive ClassesRoot
public RegistryHive CurrentConfig
public RegistryHive CurrentUser
public RegistryHive DynData
public RegistryHive LocalMachine
public RegistryHive PerformanceData
public RegistryHive Users
}
public Microsoft.Win32.RegistryKey : MarshalByRefObject {
private object handle
private SafeRegistryHandle safe_handle
private object hive
private string qname
private bool isRemoteRoot
private bool isWritable
private IRegistryApi RegistryApi
public string Name
public int SubKeyCount
public int ValueCount
public SafeRegistryHandle Handle
public RegistryView View
internal bool IsRoot
private bool IsWritable
internal RegistryHive Hive
internal object InternalHandle
internal void .ctor(RegistryHive hiveId)
internal void .ctor(RegistryHive hiveId, IntPtr keyHandle, bool remoteRoot)
internal void .ctor(object data, string keyName, bool writable)
internal bool IsEquals(RegistryKey a, RegistryKey b)
public void Dispose()
public string get_Name()
public void Flush()
public void Close()
public int get_SubKeyCount()
public int get_ValueCount()
public SafeRegistryHandle get_Handle()
public RegistryView get_View()
public void SetValue(string name, object value)
public void SetValue(string name, object value, RegistryValueKind valueKind)
public RegistryKey OpenSubKey(string name)
public RegistryKey OpenSubKey(string name, bool writable)
public object GetValue(string name)
public object GetValue(string name, object defaultValue)
public object GetValue(string name, object defaultValue, RegistryValueOptions options)
public RegistryValueKind GetValueKind(string name)
public RegistryKey CreateSubKey(string subkey)
public RegistryKey CreateSubKey(string subkey, RegistryKeyPermissionCheck permissionCheck)
public RegistryKey CreateSubKey(string subkey, RegistryKeyPermissionCheck permissionCheck, RegistrySecurity registrySecurity)
public RegistryKey CreateSubKey(string subkey, RegistryKeyPermissionCheck permissionCheck, RegistryOptions options)
public RegistryKey CreateSubKey(string subkey, RegistryKeyPermissionCheck permissionCheck, RegistryOptions registryOptions, RegistrySecurity registrySecurity)
public RegistryKey CreateSubKey(string subkey, bool writable)
public RegistryKey CreateSubKey(string subkey, bool writable, RegistryOptions options)
public void DeleteSubKey(string subkey)
public void DeleteSubKey(string subkey, bool throwOnMissingSubKey)
public void DeleteSubKeyTree(string subkey)
public void DeleteSubKeyTree(string subkey, bool throwOnMissingSubKey)
public void DeleteValue(string name)
public void DeleteValue(string name, bool throwOnMissingValue)
public RegistrySecurity GetAccessControl()
public RegistrySecurity GetAccessControl(AccessControlSections includeSections)
public String[] GetSubKeyNames()
public String[] GetValueNames()
public RegistryKey FromHandle(SafeRegistryHandle handle)
public RegistryKey FromHandle(SafeRegistryHandle handle, RegistryView view)
public RegistryKey OpenRemoteBaseKey(RegistryHive hKey, string machineName)
public RegistryKey OpenRemoteBaseKey(RegistryHive hKey, string machineName, RegistryView view)
public RegistryKey OpenBaseKey(RegistryHive hKey, RegistryView view)
public RegistryKey OpenSubKey(string name, RegistryKeyPermissionCheck permissionCheck)
public RegistryKey OpenSubKey(string name, RegistryRights rights)
public RegistryKey OpenSubKey(string name, RegistryKeyPermissionCheck permissionCheck, RegistryRights rights)
public void SetAccessControl(RegistrySecurity registrySecurity)
public string ToString()
internal bool get_IsRoot()
private bool get_IsWritable()
internal RegistryHive get_Hive()
internal object get_InternalHandle()
private void AssertKeyStillValid()
private void AssertKeyNameNotNull(string subKeyName)
private void AssertKeyNameLength(string name)
private void DeleteChildKeysAndValues()
internal string DecodeString(Byte[] data)
internal IOException CreateMarkedForDeletionException()
private string GetHiveName(RegistryHive hive)
}
internal Microsoft.Win32.RegistryKeyComparer : object {
public bool Equals(object x, object y)
public int GetHashCode(object obj)
}
public Microsoft.Win32.RegistryKeyPermissionCheck : Enum {
public int value__
public RegistryKeyPermissionCheck Default
public RegistryKeyPermissionCheck ReadSubTree
public RegistryKeyPermissionCheck ReadWriteSubTree
}
public Microsoft.Win32.RegistryOptions : Enum {
public int value__
public RegistryOptions None
public RegistryOptions Volatile
}
public Microsoft.Win32.RegistryValueKind : Enum {
public int value__
public RegistryValueKind Unknown
public RegistryValueKind String
public RegistryValueKind ExpandString
public RegistryValueKind Binary
public RegistryValueKind DWord
public RegistryValueKind MultiString
public RegistryValueKind QWord
public RegistryValueKind None
}
public Microsoft.Win32.RegistryValueOptions : Enum {
public int value__
public RegistryValueOptions None
public RegistryValueOptions DoNotExpandEnvironmentNames
}
public Microsoft.Win32.RegistryView : Enum {
public int value__
public RegistryView Default
public RegistryView Registry64
public RegistryView Registry32
}
public Microsoft.Win32.SafeHandles.CriticalHandleMinusOneIsInvalid : CriticalHandle {
public bool IsInvalid
public bool get_IsInvalid()
}
public Microsoft.Win32.SafeHandles.CriticalHandleZeroOrMinusOneIsInvalid : CriticalHandle {
public bool IsInvalid
public bool get_IsInvalid()
}
public Microsoft.Win32.SafeHandles.SafeAccessTokenHandle : SafeHandle {
public SafeAccessTokenHandle InvalidHandle
public bool IsInvalid
public void .ctor(IntPtr handle)
public SafeAccessTokenHandle get_InvalidHandle()
public bool get_IsInvalid()
protected bool ReleaseHandle()
}
public Microsoft.Win32.SafeHandles.SafeFileHandle : SafeHandleZeroOrMinusOneIsInvalid {
public void .ctor(IntPtr preexistingHandle, bool ownsHandle)
protected bool ReleaseHandle()
}
internal Microsoft.Win32.SafeHandles.SafeFindHandle : SafeHandleZeroOrMinusOneIsInvalid {
internal void .ctor(IntPtr preexistingHandle)
protected bool ReleaseHandle()
}
public Microsoft.Win32.SafeHandles.SafeHandleMinusOneIsInvalid : SafeHandle {
public bool IsInvalid
protected void .ctor(bool ownsHandle)
public bool get_IsInvalid()
}
public Microsoft.Win32.SafeHandles.SafeHandleZeroOrMinusOneIsInvalid : SafeHandle {
public bool IsInvalid
protected void .ctor(bool ownsHandle)
public bool get_IsInvalid()
}
public Microsoft.Win32.SafeHandles.SafeRegistryHandle : SafeHandleZeroOrMinusOneIsInvalid {
public void .ctor(IntPtr preexistingHandle, bool ownsHandle)
protected bool ReleaseHandle()
internal int RegCloseKey(IntPtr hKey)
}
public Microsoft.Win32.SafeHandles.SafeWaitHandle : SafeHandleZeroOrMinusOneIsInvalid {
public void .ctor(IntPtr existingHandle, bool ownsHandle)
protected bool ReleaseHandle()
}
internal Microsoft.Win32.UnixRegistryApi : object {
private string ToUnix(string keyname)
private bool IsWellKnownKey(string parentKeyName, string keyname)
public RegistryKey CreateSubKey(RegistryKey rkey, string keyname)
public RegistryKey CreateSubKey(RegistryKey rkey, string keyname, RegistryOptions options)
public RegistryKey OpenRemoteBaseKey(RegistryHive hKey, string machineName)
public RegistryKey OpenSubKey(RegistryKey rkey, string keyname, bool writable)
public RegistryKey FromHandle(SafeRegistryHandle handle)
public void Flush(RegistryKey rkey)
public void Close(RegistryKey rkey)
public object GetValue(RegistryKey rkey, string name, object default_value, RegistryValueOptions options)
public void SetValue(RegistryKey rkey, string name, object value)
public void SetValue(RegistryKey rkey, string name, object value, RegistryValueKind valueKind)
public int SubKeyCount(RegistryKey rkey)
public int ValueCount(RegistryKey rkey)
public void DeleteValue(RegistryKey rkey, string name, bool throw_if_missing)
public void DeleteKey(RegistryKey rkey, string keyname, bool throw_if_missing)
public String[] GetSubKeyNames(RegistryKey rkey)
public String[] GetValueNames(RegistryKey rkey)
public string ToString(RegistryKey rkey)
private RegistryKey CreateSubKey(RegistryKey rkey, string keyname, bool writable)
private RegistryKey CreateSubKey(RegistryKey rkey, string keyname, bool writable, bool is_volatile)
public RegistryValueKind GetValueKind(RegistryKey rkey, string name)
public IntPtr GetHandle(RegistryKey key)
}
internal Microsoft.Win32.Win32Native : object {
internal string ADVAPI32
internal int ERROR_SUCCESS
internal int ERROR_INVALID_FUNCTION
internal int ERROR_FILE_NOT_FOUND
internal int ERROR_PATH_NOT_FOUND
internal int ERROR_ACCESS_DENIED
internal int ERROR_INVALID_HANDLE
internal int ERROR_NOT_ENOUGH_MEMORY
internal int ERROR_INVALID_DATA
internal int ERROR_INVALID_DRIVE
internal int ERROR_NO_MORE_FILES
internal int ERROR_NOT_READY
internal int ERROR_BAD_LENGTH
internal int ERROR_SHARING_VIOLATION
internal int ERROR_NOT_SUPPORTED
internal int ERROR_FILE_EXISTS
internal int ERROR_INVALID_PARAMETER
internal int ERROR_BROKEN_PIPE
internal int ERROR_CALL_NOT_IMPLEMENTED
internal int ERROR_INSUFFICIENT_BUFFER
internal int ERROR_INVALID_NAME
internal int ERROR_BAD_PATHNAME
internal int ERROR_ALREADY_EXISTS
internal int ERROR_ENVVAR_NOT_FOUND
internal int ERROR_FILENAME_EXCED_RANGE
internal int ERROR_NO_DATA
internal int ERROR_PIPE_NOT_CONNECTED
internal int ERROR_MORE_DATA
internal int ERROR_DIRECTORY
internal int ERROR_OPERATION_ABORTED
internal int ERROR_NOT_FOUND
internal int ERROR_NO_TOKEN
internal int ERROR_DLL_INIT_FAILED
internal int ERROR_NON_ACCOUNT_SID
internal int ERROR_NOT_ALL_ASSIGNED
internal int ERROR_UNKNOWN_REVISION
internal int ERROR_INVALID_OWNER
internal int ERROR_INVALID_PRIMARY_GROUP
internal int ERROR_NO_SUCH_PRIVILEGE
internal int ERROR_PRIVILEGE_NOT_HELD
internal int ERROR_NONE_MAPPED
internal int ERROR_INVALID_ACL
internal int ERROR_INVALID_SID
internal int ERROR_INVALID_SECURITY_DESCR
internal int ERROR_BAD_IMPERSONATION_LEVEL
internal int ERROR_CANT_OPEN_ANONYMOUS
internal int ERROR_NO_SECURITY_ON_OBJECT
internal int ERROR_TRUSTED_RELATIONSHIP_FAILURE
internal FileAttributes FILE_ATTRIBUTE_DIRECTORY
public string GetMessage(int hr)
public int MakeHRFromErrorCode(int errorCode)
}
internal Microsoft.Win32.Win32RegistryApi : object {
private int OpenRegKeyRead
private int OpenRegKeyWrite
private int Int32ByteSize
private int Int64ByteSize
private int NativeBytesPerCharacter
private int RegOptionsNonVolatile
private int RegOptionsVolatile
private int MaxKeyLength
private int MaxValueLength
private int RegCreateKeyEx(IntPtr keyBase, string keyName, int reserved, IntPtr lpClass, int options, int access, IntPtr securityAttrs, IntPtr& keyHandle, Int32& disposition)
private int RegCloseKey(IntPtr keyHandle)
private int RegConnectRegistry(string machineName, IntPtr hKey, IntPtr& keyHandle)
private int RegFlushKey(IntPtr keyHandle)
private int RegOpenKeyEx(IntPtr keyBase, string keyName, IntPtr reserved, int access, IntPtr& keyHandle)
private int RegDeleteKey(IntPtr keyHandle, string valueName)
private int RegDeleteValue(IntPtr keyHandle, string valueName)
internal int RegEnumKeyEx(IntPtr keyHandle, int dwIndex, Char* lpName, Int32& lpcbName, Int32[] lpReserved, StringBuilder lpClass, Int32[] lpcbClass, Int64[] lpftLastWriteTime)
internal int RegEnumValue(IntPtr hKey, int dwIndex, Char* lpValueName, Int32& lpcbValueName, IntPtr lpReserved_MustBeZero, Int32[] lpType, Byte[] lpData, Int32[] lpcbData)
private int RegSetValueEx(IntPtr keyBase, string valueName, IntPtr reserved, RegistryValueKind type, string data, int rawDataLength)
private int RegSetValueEx(IntPtr keyBase, string valueName, IntPtr reserved, RegistryValueKind type, Byte[] rawData, int rawDataLength)
private int RegSetValueEx(IntPtr keyBase, string valueName, IntPtr reserved, RegistryValueKind type, Int32& data, int rawDataLength)
private int RegSetValueEx(IntPtr keyBase, string valueName, IntPtr reserved, RegistryValueKind type, Int64& data, int rawDataLength)
private int RegQueryValueEx(IntPtr keyBase, string valueName, IntPtr reserved, RegistryValueKind& type, IntPtr zero, Int32& dataSize)
private int RegQueryValueEx(IntPtr keyBase, string valueName, IntPtr reserved, RegistryValueKind& type, Byte[] data, Int32& dataSize)
private int RegQueryValueEx(IntPtr keyBase, string valueName, IntPtr reserved, RegistryValueKind& type, Int32& data, Int32& dataSize)
private int RegQueryValueEx(IntPtr keyBase, string valueName, IntPtr reserved, RegistryValueKind& type, Int64& data, Int32& dataSize)
internal int RegQueryInfoKey(IntPtr hKey, StringBuilder lpClass, Int32[] lpcbClass, IntPtr lpReserved_MustBeZero, Int32& lpcSubKeys, Int32[] lpcbMaxSubKeyLen, Int32[] lpcbMaxClassLen, Int32& lpcValues, Int32[] lpcbMaxValueNameLen, Int32[] lpcbMaxValueLen, Int32[] lpcbSecurityDescriptor, Int32[] lpftLastWriteTime)
public IntPtr GetHandle(RegistryKey key)
private bool IsHandleValid(RegistryKey key)
public RegistryValueKind GetValueKind(RegistryKey rkey, string name)
public object GetValue(RegistryKey rkey, string name, object defaultValue, RegistryValueOptions options)
public void SetValue(RegistryKey rkey, string name, object value, RegistryValueKind valueKind)
public void SetValue(RegistryKey rkey, string name, object value)
private int GetBinaryValue(RegistryKey rkey, string name, RegistryValueKind type, Byte[]& data, int size)
public int SubKeyCount(RegistryKey rkey)
public int ValueCount(RegistryKey rkey)
public RegistryKey OpenRemoteBaseKey(RegistryHive hKey, string machineName)
public RegistryKey OpenSubKey(RegistryKey rkey, string keyName, bool writable)
public void Flush(RegistryKey rkey)
public void Close(RegistryKey rkey)
public RegistryKey FromHandle(SafeRegistryHandle handle)
public RegistryKey CreateSubKey(RegistryKey rkey, string keyName)
public RegistryKey CreateSubKey(RegistryKey rkey, string keyName, RegistryOptions options)
public void DeleteKey(RegistryKey rkey, string keyName, bool shouldThrowWhenKeyMissing)
public void DeleteValue(RegistryKey rkey, string value, bool shouldThrowWhenKeyMissing)
public String[] GetSubKeyNames(RegistryKey rkey)
public String[] GetValueNames(RegistryKey rkey)
private void CheckResult(int result)
private void GenerateException(int errorCode)
public string ToString(RegistryKey rkey)
internal string CombineName(RegistryKey rkey, string localName)
}
internal Microsoft.Win32.Win32ResultCode : object {
public int Success
public int FileNotFound
public int AccessDenied
public int InvalidHandle
public int InvalidParameter
public int MoreData
public int NetworkPathNotFound
public int NoMoreEntries
public int MarkedForDeletion
public int ChildMustBeVolatile
}
internal Mono.DataConverter : object {
private DataConverter SwapConv
private DataConverter CopyConv
public bool IsLittleEndian
public DataConverter LittleEndian
public DataConverter BigEndian
public DataConverter Native
public double GetDouble(Byte[] data, int index)
public float GetFloat(Byte[] data, int index)
public long GetInt64(Byte[] data, int index)
public int GetInt32(Byte[] data, int index)
public short GetInt16(Byte[] data, int index)
public UInt32 GetUInt32(Byte[] data, int index)
public ushort GetUInt16(Byte[] data, int index)
public ulong GetUInt64(Byte[] data, int index)
public void PutBytes(Byte[] dest, int destIdx, double value)
public void PutBytes(Byte[] dest, int destIdx, float value)
public void PutBytes(Byte[] dest, int destIdx, int value)
public void PutBytes(Byte[] dest, int destIdx, long value)
public void PutBytes(Byte[] dest, int destIdx, short value)
public void PutBytes(Byte[] dest, int destIdx, ushort value)
public void PutBytes(Byte[] dest, int destIdx, UInt32 value)
public void PutBytes(Byte[] dest, int destIdx, ulong value)
public Byte[] GetBytes(double value)
public Byte[] GetBytes(float value)
public Byte[] GetBytes(int value)
public Byte[] GetBytes(long value)
public Byte[] GetBytes(short value)
public Byte[] GetBytes(ushort value)
public Byte[] GetBytes(UInt32 value)
public Byte[] GetBytes(ulong value)
public DataConverter get_LittleEndian()
public DataConverter get_BigEndian()
public DataConverter get_Native()
private int Align(int current, int align)
public Byte[] Pack(string description, Object[] args)
public Byte[] PackEnumerable(string description, IEnumerable args)
private bool PackOne(PackContext b, object oarg)
private bool Prepare(Byte[] buffer, Int32& idx, int size, Boolean& align)
public IList Unpack(string description, Byte[] buffer, int startIndex)
internal void Check(Byte[] dest, int destIdx, int size)
}
internal Mono.Globalization.Unicode.CodePointIndexer : object {
private TableRange[] ranges
public int TotalCount
private int defaultIndex
private int defaultCP
public Array CompressArray(Array source, Type type, CodePointIndexer indexer)
public void .ctor(Int32[] starts, Int32[] ends, int defaultIndex, int defaultCP)
public int ToIndex(int cp)
public int ToCodePoint(int i)
}
internal Mono.Globalization.Unicode.Contraction : object {
public int Index
public Char[] Source
public string Replacement
public Byte[] SortKey
public void .ctor(int index, Char[] source, string replacement, Byte[] sortkey)
}
internal Mono.Globalization.Unicode.ContractionComparer : object {
public ContractionComparer Instance
public int Compare(Contraction c1, Contraction c2)
}
internal Mono.Globalization.Unicode.Level2Map : object {
public byte Source
public byte Replace
public void .ctor(byte source, byte replace)
}
internal Mono.Globalization.Unicode.MSCompatUnicodeTable : object {
public int MaxExpansionLength
private Byte* ignorableFlags
private Byte* categories
private Byte* level1
private Byte* level2
private Byte* level3
private Byte* cjkCHScategory
private Byte* cjkCHTcategory
private Byte* cjkJAcategory
private Byte* cjkKOcategory
private Byte* cjkCHSlv1
private Byte* cjkCHTlv1
private Byte* cjkJAlv1
private Byte* cjkKOlv1
private Byte* cjkKOlv2
private int ResourceVersionSize
private Char[] tailoringArr
private TailoringInfo[] tailoringInfos
private object forLock
public bool isReady
public bool IsReady
public TailoringInfo GetTailoringInfo(int lcid)
public void BuildTailoringTables(CultureInfo culture, TailoringInfo t, Contraction[]& contractions, Level2Map[]& diacriticals)
private void SetCJKReferences(string name, CodePointIndexer& cjkIndexer, Byte*& catTable, Byte*& lv1Table, CodePointIndexer& lv2Indexer, Byte*& lv2Table)
public byte Category(int cp)
public byte Level1(int cp)
public byte Level2(int cp)
public byte Level3(int cp)
public bool IsSortable(string s)
public bool IsSortable(int cp)
public bool IsIgnorable(int cp)
public bool IsIgnorable(int cp, byte flag)
public bool IsIgnorableSymbol(int cp)
public bool IsIgnorableNonSpacing(int cp)
public int ToKanaTypeInsensitive(int i)
public int ToWidthCompat(int i)
public bool HasSpecialWeight(char c)
public byte GetJapaneseDashType(char c)
public bool IsHalfWidthKana(char c)
public bool IsHiragana(char c)
public bool IsJapaneseSmallLetter(char c)
public bool get_IsReady()
private IntPtr GetResource(string name)
private UInt32 UInt32FromBytePtr(Byte* raw, UInt32 idx)
public void FillCJK(string culture, CodePointIndexer& cjkIndexer, Byte*& catTable, Byte*& lv1Table, CodePointIndexer& lv2Indexer, Byte*& lv2Table)
private void FillCJKCore(string culture, CodePointIndexer& cjkIndexer, Byte*& catTable, Byte*& lv1Table, CodePointIndexer& cjkLv2Indexer, Byte*& lv2Table)
}
internal Mono.Globalization.Unicode.MSCompatUnicodeTableUtil : object {
public byte ResourceVersion
public CodePointIndexer Ignorable
public CodePointIndexer Category
public CodePointIndexer Level1
public CodePointIndexer Level2
public CodePointIndexer Level3
public CodePointIndexer CjkCHS
public CodePointIndexer Cjk
}
internal Mono.Globalization.Unicode.NormalizationTableUtil : object {
public CodePointIndexer Prop
public CodePointIndexer Map
public CodePointIndexer Combining
public CodePointIndexer Composite
public CodePointIndexer Helper
public int PropCount
public int MapCount
public int PropIdx(int cp)
public int PropCP(int index)
public int get_PropCount()
public int MapIdx(int cp)
public int MapCP(int index)
public int CbIdx(int cp)
public int CbCP(int index)
public int get_MapCount()
}
internal Mono.Globalization.Unicode.SimpleCollator : object {
private bool QuickCheckDisabled
private SimpleCollator invariant
private TextInfo textInfo
private CodePointIndexer cjkIndexer
private Contraction[] contractions
private Level2Map[] level2Maps
private Byte[] unsafeFlags
private Byte* cjkCatTable
private Byte* cjkLv1Table
private Byte* cjkLv2Table
private CodePointIndexer cjkLv2Indexer
private int lcid
private bool frenchSort
private int UnsafeFlagLength
public void .ctor(CultureInfo culture)
private void SetCJKTable(CultureInfo culture, CodePointIndexer& cjkIndexer, Byte*& catTable, Byte*& lv1Table, CodePointIndexer& lv2Indexer, Byte*& lv2Table)
private CultureInfo GetNeutralCulture(CultureInfo info)
private byte Category(int cp)
private byte Level1(int cp)
private byte Level2(int cp, ExtenderType ext)
private bool IsHalfKana(int cp, CompareOptions opt)
private Contraction GetContraction(string s, int start, int end)
private Contraction GetContraction(string s, int start, int end, Contraction[] clist)
private Contraction GetTailContraction(string s, int start, int end)
private Contraction GetTailContraction(string s, int start, int end, Contraction[] clist)
private Contraction GetContraction(char c)
private Contraction GetContraction(char c, Contraction[] clist)
private int FilterOptions(int i, CompareOptions opt)
private ExtenderType GetExtenderType(int i)
private byte ToDashTypeValue(ExtenderType ext, CompareOptions opt)
private int FilterExtender(int i, ExtenderType ext, CompareOptions opt)
private bool IsIgnorable(int i, CompareOptions opt)
private bool IsSafe(int i)
public SortKey GetSortKey(string s)
public SortKey GetSortKey(string s, CompareOptions options)
public SortKey GetSortKey(string s, int start, int length, CompareOptions options)
private void GetSortKey(string s, int start, int end, SortKeyBuffer buf, CompareOptions opt)
private void FillSortKeyRaw(int i, ExtenderType ext, SortKeyBuffer buf, CompareOptions opt)
private void FillSurrogateSortKeyRaw(int i, SortKeyBuffer buf)
public int Compare(string s1, string s2)
internal int Compare(string s1, int idx1, int len1, string s2, int idx2, int len2, CompareOptions options)
private void ClearBuffer(Byte* buffer, int size)
private int CompareInternal(string s1, int idx1, int len1, string s2, int idx2, int len2, Boolean& targetConsumed, Boolean& sourceConsumed, bool skipHeadingExtenders, bool immediateBreakup, Context& ctx)
private int CompareFlagPair(bool b1, bool b2)
public bool IsPrefix(string src, string target, CompareOptions opt)
public bool IsPrefix(string s, string target, int start, int length, CompareOptions opt)
private bool IsPrefix(string s, string target, int start, int length, bool skipHeadingExtenders, Context& ctx)
public bool IsSuffix(string src, string target, CompareOptions opt)
public bool IsSuffix(string s, string target, int start, int length, CompareOptions opt)
public int IndexOf(string s, string target, CompareOptions opt)
private int QuickIndexOf(string s, string target, int start, int length, Boolean& testWasUnable)
public int IndexOf(string s, string target, int start, int length, CompareOptions opt)
private int IndexOfOrdinal(string s, string target, int start, int length)
public int IndexOf(string s, char target, CompareOptions opt)
public int IndexOf(string s, char target, int start, int length, CompareOptions opt)
private int IndexOfOrdinal(string s, char target, int start, int length)
private int IndexOfSortKey(string s, int start, int length, Byte* sortkey, char target, int ti, bool noLv4, Context& ctx)
private int IndexOf(string s, string target, int start, int length, Byte* targetSortKey, Context& ctx)
public int LastIndexOf(string s, string target, CompareOptions opt)
public int LastIndexOf(string s, string target, int start, int length, CompareOptions opt)
private int LastIndexOfOrdinal(string s, string target, int start, int length)
public int LastIndexOf(string s, char target, CompareOptions opt)
public int LastIndexOf(string s, char target, int start, int length, CompareOptions opt)
private int LastIndexOfSortKey(string s, int start, int orgStart, int length, Byte* sortkey, int ti, bool noLv4, Context& ctx)
private int LastIndexOf(string s, string target, int start, int length, Byte* targetSortKey, Context& ctx)
private bool MatchesForward(string s, Int32& idx, int end, int ti, Byte* sortkey, bool noLv4, Context& ctx)
private bool MatchesForwardCore(string s, Int32& idx, int end, int ti, Byte* sortkey, bool noLv4, ExtenderType ext, Contraction& ct, Context& ctx)
private bool MatchesPrimitive(CompareOptions opt, Byte* source, int si, ExtenderType ext, Byte* target, int ti, bool noLv4)
private bool MatchesBackward(string s, Int32& idx, int end, int orgStart, int ti, Byte* sortkey, bool noLv4, Context& ctx)
private bool MatchesBackwardCore(string s, Int32& idx, int end, int orgStart, int ti, Byte* sortkey, bool noLv4, ExtenderType ext, Contraction& ct, Context& ctx)
}
internal Mono.Globalization.Unicode.SortKeyBuffer : object {
private Byte[] l1b
private Byte[] l2b
private Byte[] l3b
private Byte[] l4sb
private Byte[] l4tb
private Byte[] l4kb
private Byte[] l4wb
private Byte[] l5b
private string source
private int l1
private int l2
private int l3
private int l4s
private int l4t
private int l4k
private int l4w
private int l5
private int lcid
private CompareOptions options
private bool processLevel2
private bool frenchSort
private bool frenchSorted
public void .ctor(int lcid)
public void Reset()
internal void ClearBuffer()
internal void Initialize(CompareOptions options, int lcid, string s, bool frenchSort)
internal void AppendCJKExtension(byte lv1msb, byte lv1lsb)
internal void AppendKana(byte category, byte lv1, byte lv2, byte lv3, bool isSmallKana, byte markType, bool isKatakana, bool isHalfWidth)
internal void AppendNormal(byte category, byte lv1, byte lv2, byte lv3)
private void AppendLevel5(byte category, byte lv1)
private void AppendBufferPrimitive(byte value, Byte[]& buf, Int32& bidx)
public SortKey GetResultAndReset()
private int GetOptimizedLength(Byte[] data, int len, byte defaultValue)
public SortKey GetResult()
}
internal Mono.Globalization.Unicode.TailoringInfo : object {
public int LCID
public int TailoringIndex
public int TailoringCount
public bool FrenchSort
public void .ctor(int lcid, int tailoringIndex, int tailoringCount, bool frenchSort)
}
internal Mono.Interop.ComInteropProxy : RealProxy {
private __ComObject com_object
private int ref_count
private string type_name
public string TypeName
private void AddProxy(IntPtr pItf, ComInteropProxy proxy)
internal ComInteropProxy FindProxy(IntPtr pItf)
private void .ctor(Type t)
private void CacheProxy()
private void .ctor(IntPtr pUnk)
internal void .ctor(IntPtr pUnk, Type t)
internal ComInteropProxy GetProxy(IntPtr pItf, Type t)
internal ComInteropProxy CreateProxy(Type t)
public IMessage Invoke(IMessage msg)
public string get_TypeName()
public void set_TypeName(string value)
public bool CanCastTo(Type fromType, object o)
}
internal Mono.Math.BigInteger : object {
private UInt32 length
private UInt32[] data
private UInt32 DEFAULT_LEN
internal UInt32[] smallPrimes
private string WouldReturnNegVal
private RandomNumberGenerator rng
private RandomNumberGenerator Rng
public void .ctor(Sign sign, UInt32 len)
public void .ctor(BigInteger bi)
public void .ctor(BigInteger bi, UInt32 len)
public void .ctor(Byte[] inData)
public void .ctor(UInt32[] inData)
public void .ctor(UInt32 ui)
public void .ctor(ulong ul)
public BigInteger op_Implicit(UInt32 value)
public BigInteger op_Implicit(int value)
public BigInteger op_Implicit(ulong value)
public BigInteger Parse(string number)
public BigInteger op_Addition(BigInteger bi1, BigInteger bi2)
public BigInteger op_Subtraction(BigInteger bi1, BigInteger bi2)
public int op_Modulus(BigInteger bi, int i)
public UInt32 op_Modulus(BigInteger bi, UInt32 ui)
public BigInteger op_Modulus(BigInteger bi1, BigInteger bi2)
public BigInteger op_Division(BigInteger bi, int i)
public BigInteger op_Division(BigInteger bi1, BigInteger bi2)
public BigInteger op_Multiply(BigInteger bi1, BigInteger bi2)
public BigInteger op_Multiply(BigInteger bi, int i)
public BigInteger op_LeftShift(BigInteger bi1, int shiftVal)
public BigInteger op_RightShift(BigInteger bi1, int shiftVal)
public BigInteger Add(BigInteger bi1, BigInteger bi2)
public BigInteger Subtract(BigInteger bi1, BigInteger bi2)
public int Modulus(BigInteger bi, int i)
public UInt32 Modulus(BigInteger bi, UInt32 ui)
public BigInteger Modulus(BigInteger bi1, BigInteger bi2)
public BigInteger Divid(BigInteger bi, int i)
public BigInteger Divid(BigInteger bi1, BigInteger bi2)
public BigInteger Multiply(BigInteger bi1, BigInteger bi2)
public BigInteger Multiply(BigInteger bi, int i)
private RandomNumberGenerator get_Rng()
public BigInteger GenerateRandom(int bits, RandomNumberGenerator rng)
public BigInteger GenerateRandom(int bits)
public void Randomize(RandomNumberGenerator rng)
public void Randomize()
public int BitCount()
public bool TestBit(UInt32 bitNum)
public bool TestBit(int bitNum)
public void SetBit(UInt32 bitNum)
public void ClearBit(UInt32 bitNum)
public void SetBit(UInt32 bitNum, bool value)
public int LowestSetBit()
public Byte[] GetBytes()
public bool op_Equality(BigInteger bi1, UInt32 ui)
public bool op_Inequality(BigInteger bi1, UInt32 ui)
public bool op_Equality(BigInteger bi1, BigInteger bi2)
public bool op_Inequality(BigInteger bi1, BigInteger bi2)
public bool op_GreaterThan(BigInteger bi1, BigInteger bi2)
public bool op_LessThan(BigInteger bi1, BigInteger bi2)
public bool op_GreaterThanOrEqual(BigInteger bi1, BigInteger bi2)
public bool op_LessThanOrEqual(BigInteger bi1, BigInteger bi2)
public Sign Compare(BigInteger bi)
public string ToString(UInt32 radix)
public string ToString(UInt32 radix, string characterSet)
private void Normalize()
public void Clear()
public int GetHashCode()
public string ToString()
public bool Equals(object o)
public BigInteger GCD(BigInteger bi)
public BigInteger ModInverse(BigInteger modulus)
public BigInteger ModPow(BigInteger exp, BigInteger n)
public bool IsProbablePrime()
public BigInteger NextHighestPrime(BigInteger bi)
public BigInteger GeneratePseudoPrime(int bits)
public void Incr2()
}
internal Mono.Math.Prime.ConfidenceFactor : Enum {
public int value__
public ConfidenceFactor ExtraLow
public ConfidenceFactor Low
public ConfidenceFactor Medium
public ConfidenceFactor High
public ConfidenceFactor ExtraHigh
public ConfidenceFactor Provable
}
internal Mono.Math.Prime.Generator.NextPrimeFinder : SequentialSearchPrimeGeneratorBase {
protected BigInteger GenerateSearchBase(int bits, object Context)
}
internal Mono.Math.Prime.Generator.PrimeGeneratorBase : object {
public ConfidenceFactor Confidence
public PrimalityTest PrimalityTest
public int TrialDivisionBounds
public ConfidenceFactor get_Confidence()
public PrimalityTest get_PrimalityTest()
public int get_TrialDivisionBounds()
protected bool PostTrialDivisionTests(BigInteger bi)
public BigInteger GenerateNewPrime(int bits)
}
internal Mono.Math.Prime.Generator.SequentialSearchPrimeGeneratorBase : PrimeGeneratorBase {
protected BigInteger GenerateSearchBase(int bits, object context)
public BigInteger GenerateNewPrime(int bits)
public BigInteger GenerateNewPrime(int bits, object context)
protected bool IsPrimeAcceptable(BigInteger bi, object context)
}
internal Mono.Math.Prime.PrimalityTest : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public bool Invoke(BigInteger bi, ConfidenceFactor confidence)
public IAsyncResult BeginInvoke(BigInteger bi, ConfidenceFactor confidence, AsyncCallback callback, object object)
public bool EndInvoke(IAsyncResult result)
}
internal Mono.Math.Prime.PrimalityTests : object {
private int GetSPPRounds(BigInteger bi, ConfidenceFactor confidence)
public bool Test(BigInteger n, ConfidenceFactor confidence)
public bool RabinMillerTest(BigInteger n, ConfidenceFactor confidence)
public bool SmallPrimeSppTest(BigInteger bi, ConfidenceFactor confidence)
}
internal Mono.MonoAssemblyName : ValueType {
private int MONO_PUBLIC_KEY_TOKEN_LENGTH
internal IntPtr name
internal IntPtr culture
internal IntPtr hash_value
internal IntPtr public_key
internal <public_key_token>e__FixedBuffer public_key_token
internal UInt32 hash_alg
internal UInt32 hash_len
internal UInt32 flags
internal ushort major
internal ushort minor
internal ushort build
internal ushort revision
internal ushort arch
}
internal Mono.Runtime : object {
private void mono_runtime_install_handlers()
internal void InstallSignalHandlers()
internal string GetDisplayName()
private string GetNativeStackTrace(Exception exception)
public bool SetGCAllowSynchronousMajor(bool flag)
}
internal Mono.RuntimeClassHandle : ValueType {
private MonoClass* value
internal MonoClass* Value
internal void .ctor(MonoClass* value)
internal void .ctor(IntPtr ptr)
internal MonoClass* get_Value()
public bool Equals(object obj)
public int GetHashCode()
public bool Equals(RuntimeClassHandle handle)
public bool op_Equality(RuntimeClassHandle left, object right)
public bool op_Inequality(RuntimeClassHandle left, object right)
public bool op_Equality(object left, RuntimeClassHandle right)
public bool op_Inequality(object left, RuntimeClassHandle right)
internal IntPtr GetTypeFromClass(MonoClass* klass)
internal RuntimeTypeHandle GetTypeHandle()
}
internal Mono.RuntimeEventHandle : ValueType {
private IntPtr value
public IntPtr Value
internal void .ctor(IntPtr v)
public IntPtr get_Value()
public bool Equals(object obj)
public bool Equals(RuntimeEventHandle handle)
public int GetHashCode()
public bool op_Equality(RuntimeEventHandle left, RuntimeEventHandle right)
public bool op_Inequality(RuntimeEventHandle left, RuntimeEventHandle right)
}
internal Mono.RuntimeGenericParamInfoHandle : ValueType {
private GenericParamInfo* value
internal Type[] Constraints
internal GenericParameterAttributes Attributes
internal void .ctor(GenericParamInfo* value)
internal void .ctor(IntPtr ptr)
internal Type[] get_Constraints()
internal GenericParameterAttributes get_Attributes()
private Type[] GetConstraints()
private int GetConstraintsCount()
}
internal Mono.RuntimeGPtrArrayHandle : ValueType {
private GPtrArray* value
internal int Length
internal IntPtr Item
internal void .ctor(GPtrArray* value)
internal void .ctor(IntPtr ptr)
internal int get_Length()
internal IntPtr get_Item(int i)
internal IntPtr Lookup(int i)
private void GPtrArrayFree(GPtrArray* value)
internal void DestroyAndFree(RuntimeGPtrArrayHandle& h)
}
internal Mono.RuntimeMarshal : object {
internal string PtrToUtf8String(IntPtr ptr)
internal SafeStringMarshal MarshalString(string str)
private int DecodeBlobSize(IntPtr in_ptr, IntPtr& out_ptr)
internal Byte[] DecodeBlobArray(IntPtr ptr)
internal int AsciHexDigitValue(int c)
internal void FreeAssemblyName(MonoAssemblyName& name, bool freeStruct)
}
internal Mono.RuntimePropertyHandle : ValueType {
private IntPtr value
public IntPtr Value
internal void .ctor(IntPtr v)
public IntPtr get_Value()
public bool Equals(object obj)
public bool Equals(RuntimePropertyHandle handle)
public int GetHashCode()
public bool op_Equality(RuntimePropertyHandle left, RuntimePropertyHandle right)
public bool op_Inequality(RuntimePropertyHandle left, RuntimePropertyHandle right)
}
internal Mono.RuntimeRemoteClassHandle : ValueType {
private RemoteClass* value
internal RuntimeClassHandle ProxyClass
internal void .ctor(RemoteClass* value)
internal RuntimeClassHandle get_ProxyClass()
}
internal Mono.SafeGPtrArrayHandle : ValueType {
private RuntimeGPtrArrayHandle handle
internal int Length
internal IntPtr Item
internal void .ctor(IntPtr ptr)
public void Dispose()
internal int get_Length()
internal IntPtr get_Item(int i)
}
internal Mono.SafeStringMarshal : ValueType {
private string str
private IntPtr marshaled_string
public IntPtr Value
public IntPtr StringToUtf8(string str)
public void GFree(IntPtr ptr)
public void .ctor(string str)
public IntPtr get_Value()
public void Dispose()
}
internal Mono.Security.ASN1 : object {
private byte m_nTag
private Byte[] m_aValue
private ArrayList elist
public int Count
public byte Tag
public int Length
public Byte[] Value
public ASN1 Item
public void .ctor(byte tag)
public void .ctor(byte tag, Byte[] data)
public void .ctor(Byte[] data)
public int get_Count()
public byte get_Tag()
public int get_Length()
public Byte[] get_Value()
public void set_Value(Byte[] value)
private bool CompareArray(Byte[] array1, Byte[] array2)
public bool Equals(Byte[] asn1)
public bool CompareValue(Byte[] value)
public ASN1 Add(ASN1 asn1)
public Byte[] GetBytes()
protected void Decode(Byte[] asn1, Int32& anPos, int anLength)
protected void DecodeTLV(Byte[] asn1, Int32& pos, Byte& tag, Int32& length, Byte[]& content)
public ASN1 get_Item(int index)
public ASN1 Element(int index, byte anTag)
public string ToString()
public void SaveToFile(string filename)
}
internal Mono.Security.ASN1Convert : object {
public ASN1 FromDateTime(DateTime dt)
public ASN1 FromInt32(int value)
public ASN1 FromOid(string oid)
public ASN1 FromUnsignedBigInteger(Byte[] big)
public int ToInt32(ASN1 asn1)
public string ToOid(ASN1 asn1)
public DateTime ToDateTime(ASN1 time)
}
internal Mono.Security.Authenticode.AuthenticodeBase : object {
public string spcIndirectDataContext
private Byte[] fileblock
private FileStream fs
private int blockNo
private int blockLength
private int peOffset
private int dirSecurityOffset
private int dirSecuritySize
private int coffSymbolTableOffset
internal int PEOffset
internal int CoffSymbolTableOffset
internal int SecurityOffset
internal int get_PEOffset()
internal int get_CoffSymbolTableOffset()
internal int get_SecurityOffset()
internal void Open(string filename)
internal void Close()
internal void ReadFirstBlock()
internal int ProcessFirstBlock()
internal Byte[] GetSecurityEntry()
internal Byte[] GetHash(HashAlgorithm hash)
protected Byte[] HashFile(string fileName, string hashName)
}
internal Mono.Security.Authenticode.AuthenticodeDeformatter : AuthenticodeBase {
private string filename
private Byte[] hash
private X509CertificateCollection coll
private ASN1 signedHash
private DateTime timestamp
private X509Certificate signingCertificate
private int reason
private bool trustedRoot
private bool trustedTimestampRoot
private Byte[] entry
private X509Chain signerChain
private X509Chain timestampChain
public string FileName
public Byte[] Hash
public int Reason
public Byte[] Signature
public DateTime Timestamp
public X509CertificateCollection Certificates
public X509Certificate SigningCertificate
public void .ctor(string fileName)
public string get_FileName()
public void set_FileName(string value)
public Byte[] get_Hash()
public int get_Reason()
public bool IsTrusted()
public Byte[] get_Signature()
public DateTime get_Timestamp()
public X509CertificateCollection get_Certificates()
public X509Certificate get_SigningCertificate()
private bool CheckSignature(string fileName)
private bool CompareIssuerSerial(string issuer, Byte[] serial, X509Certificate x509)
private bool VerifySignature(SignedData sd, Byte[] calculatedMessageDigest, HashAlgorithm ha)
private bool VerifyCounterSignature(SignerInfo cs, Byte[] signature)
private void Reset()
}
internal Mono.Security.Authenticode.Authority : Enum {
public int value__
public Authority Individual
public Authority Commercial
public Authority Maximum
}
internal Mono.Security.BitConverterLE : object {
private Byte[] GetUShortBytes(Byte* bytes)
private Byte[] GetUIntBytes(Byte* bytes)
private Byte[] GetULongBytes(Byte* bytes)
internal Byte[] GetBytes(bool value)
internal Byte[] GetBytes(char value)
internal Byte[] GetBytes(short value)
internal Byte[] GetBytes(int value)
internal Byte[] GetBytes(long value)
internal Byte[] GetBytes(ushort value)
internal Byte[] GetBytes(UInt32 value)
internal Byte[] GetBytes(ulong value)
internal Byte[] GetBytes(float value)
internal Byte[] GetBytes(double value)
private void UShortFromBytes(Byte* dst, Byte[] src, int startIndex)
private void UIntFromBytes(Byte* dst, Byte[] src, int startIndex)
private void ULongFromBytes(Byte* dst, Byte[] src, int startIndex)
internal bool ToBoolean(Byte[] value, int startIndex)
internal char ToChar(Byte[] value, int startIndex)
internal short ToInt16(Byte[] value, int startIndex)
internal int ToInt32(Byte[] value, int startIndex)
internal long ToInt64(Byte[] value, int startIndex)
internal ushort ToUInt16(Byte[] value, int startIndex)
internal UInt32 ToUInt32(Byte[] value, int startIndex)
internal ulong ToUInt64(Byte[] value, int startIndex)
internal float ToSingle(Byte[] value, int startIndex)
internal double ToDouble(Byte[] value, int startIndex)
}
internal Mono.Security.Cryptography.ARC4Managed : RC4 {
private Byte[] key
private Byte[] state
private byte x
private byte y
private bool m_disposed
public Byte[] Key
public bool CanReuseTransform
public bool CanTransformMultipleBlocks
public int InputBlockSize
public int OutputBlockSize
protected void Finalize()
protected void Dispose(bool disposing)
public Byte[] get_Key()
public void set_Key(Byte[] value)
public bool get_CanReuseTransform()
public ICryptoTransform CreateEncryptor(Byte[] rgbKey, Byte[] rgvIV)
public ICryptoTransform CreateDecryptor(Byte[] rgbKey, Byte[] rgvIV)
public void GenerateIV()
public void GenerateKey()
public bool get_CanTransformMultipleBlocks()
public int get_InputBlockSize()
public int get_OutputBlockSize()
private void KeySetup(Byte[] key)
private void CheckInput(Byte[] inputBuffer, int inputOffset, int inputCount)
public int TransformBlock(Byte[] inputBuffer, int inputOffset, int inputCount, Byte[] outputBuffer, int outputOffset)
private int InternalTransformBlock(Byte[] inputBuffer, int inputOffset, int inputCount, Byte[] outputBuffer, int outputOffset)
public Byte[] TransformFinalBlock(Byte[] inputBuffer, int inputOffset, int inputCount)
}
internal Mono.Security.Cryptography.BlockProcessor : object {
private ICryptoTransform transform
private Byte[] block
private int blockSize
private int blockCount
public void .ctor(ICryptoTransform transform)
public void .ctor(ICryptoTransform transform, int blockSize)
protected void Finalize()
public void Initialize()
public void Core(Byte[] rgb)
public void Core(Byte[] rgb, int ib, int cb)
public Byte[] Final()
}
internal Mono.Security.Cryptography.CryptoConvert : object {
private int ToInt32LE(Byte[] bytes, int offset)
private UInt32 ToUInt32LE(Byte[] bytes, int offset)
private Byte[] GetBytesLE(int val)
private Byte[] Trim(Byte[] array)
public RSA FromCapiPrivateKeyBlob(Byte[] blob)
public RSA FromCapiPrivateKeyBlob(Byte[] blob, int offset)
public DSA FromCapiPrivateKeyBlobDSA(Byte[] blob)
public DSA FromCapiPrivateKeyBlobDSA(Byte[] blob, int offset)
public Byte[] ToCapiPrivateKeyBlob(RSA rsa)
public Byte[] ToCapiPrivateKeyBlob(DSA dsa)
public RSA FromCapiPublicKeyBlob(Byte[] blob)
public RSA FromCapiPublicKeyBlob(Byte[] blob, int offset)
public DSA FromCapiPublicKeyBlobDSA(Byte[] blob)
public DSA FromCapiPublicKeyBlobDSA(Byte[] blob, int offset)
public Byte[] ToCapiPublicKeyBlob(RSA rsa)
public Byte[] ToCapiPublicKeyBlob(DSA dsa)
public RSA FromCapiKeyBlob(Byte[] blob)
public RSA FromCapiKeyBlob(Byte[] blob, int offset)
public DSA FromCapiKeyBlobDSA(Byte[] blob)
public DSA FromCapiKeyBlobDSA(Byte[] blob, int offset)
public Byte[] ToCapiKeyBlob(AsymmetricAlgorithm keypair, bool includePrivateKey)
public Byte[] ToCapiKeyBlob(RSA rsa, bool includePrivateKey)
public Byte[] ToCapiKeyBlob(DSA dsa, bool includePrivateKey)
public string ToHex(Byte[] input)
private byte FromHexChar(char c)
public Byte[] FromHex(string hex)
}
internal Mono.Security.Cryptography.DSAManaged : DSA {
private int defaultKeySize
private bool keypairGenerated
private bool m_disposed
private BigInteger p
private BigInteger q
private BigInteger g
private BigInteger x
private BigInteger y
private BigInteger j
private BigInteger seed
private int counter
private bool j_missing
private RandomNumberGenerator rng
private KeyGeneratedEventHandler KeyGenerated
private RandomNumberGenerator Random
public int KeySize
public string KeyExchangeAlgorithm
public bool PublicOnly
public string SignatureAlgorithm
public void .ctor(int dwKeySize)
protected void Finalize()
private void Generate()
private void GenerateKeyPair()
private void add(Byte[] a, Byte[] b, int value)
private void GenerateParams(int keyLength)
private RandomNumberGenerator get_Random()
public int get_KeySize()
public string get_KeyExchangeAlgorithm()
public bool get_PublicOnly()
public string get_SignatureAlgorithm()
private Byte[] NormalizeArray(Byte[] array)
public DSAParameters ExportParameters(bool includePrivateParameters)
public void ImportParameters(DSAParameters parameters)
public Byte[] CreateSignature(Byte[] rgbHash)
public bool VerifySignature(Byte[] rgbHash, Byte[] rgbSignature)
protected void Dispose(bool disposing)
public void add_KeyGenerated(KeyGeneratedEventHandler value)
public void remove_KeyGenerated(KeyGeneratedEventHandler value)
}
internal Mono.Security.Cryptography.HMACAlgorithm : object {
private Byte[] key
private Byte[] hash
private HashAlgorithm algo
private string hashName
private BlockProcessor block
public HashAlgorithm Algo
public string HashName
public Byte[] Key
public void .ctor(string algoName)
protected void Finalize()
private void CreateHash(string algoName)
public void Dispose()
public HashAlgorithm get_Algo()
public string get_HashName()
public void set_HashName(string value)
public Byte[] get_Key()
public void set_Key(Byte[] value)
public void Initialize()
private Byte[] KeySetup(Byte[] key, byte padding)
public void Core(Byte[] rgb, int ib, int cb)
public Byte[] Final()
}
internal Mono.Security.Cryptography.KeyBuilder : object {
private RandomNumberGenerator rng
private RandomNumberGenerator Rng
private RandomNumberGenerator get_Rng()
public Byte[] Key(int size)
public Byte[] IV(int size)
}
internal Mono.Security.Cryptography.KeyPairPersistence : object {
private bool _userPathExists
private string _userPath
private bool _machinePathExists
private string _machinePath
private CspParameters _params
private string _keyvalue
private string _filename
private string _container
private object lockobj
public string Filename
public string KeyValue
public CspParameters Parameters
private string UserPath
private string MachinePath
private bool CanChange
private bool UseDefaultKeyContainer
private bool UseMachineKeyStore
private string ContainerName
public void .ctor(CspParameters parameters)
public void .ctor(CspParameters parameters, string keyPair)
public string get_Filename()
public string get_KeyValue()
public void set_KeyValue(string value)
public CspParameters get_Parameters()
public bool Load()
public void Save()
public void Remove()
private string get_UserPath()
private string get_MachinePath()
internal bool _CanSecure(string root)
internal bool _ProtectUser(string path)
internal bool _ProtectMachine(string path)
internal bool _IsUserProtected(string path)
internal bool _IsMachineProtected(string path)
private bool CanSecure(string path)
private bool ProtectUser(string path)
private bool ProtectMachine(string path)
private bool IsUserProtected(string path)
private bool IsMachineProtected(string path)
private bool get_CanChange()
private bool get_UseDefaultKeyContainer()
private bool get_UseMachineKeyStore()
private string get_ContainerName()
private CspParameters Copy(CspParameters p)
private void FromXml(string xml)
private string ToXml()
}
internal Mono.Security.Cryptography.MACAlgorithm : object {
private SymmetricAlgorithm algo
private ICryptoTransform enc
private Byte[] block
private int blockSize
private int blockCount
public void .ctor(SymmetricAlgorithm algorithm)
public void Initialize(Byte[] key)
public void Core(Byte[] rgb, int ib, int cb)
public Byte[] Final()
}
internal Mono.Security.Cryptography.MD2 : HashAlgorithm {
public MD2 Create()
public MD2 Create(string hashName)
}
internal Mono.Security.Cryptography.MD2Managed : MD2 {
private Byte[] state
private Byte[] checksum
private Byte[] buffer
private int count
private Byte[] x
private Byte[] PI_SUBST
private Byte[] Padding(int nLength)
public void Initialize()
protected void HashCore(Byte[] array, int ibStart, int cbSize)
protected Byte[] HashFinal()
private void MD2Transform(Byte[] state, Byte[] checksum, Byte[] block, int index)
}
internal Mono.Security.Cryptography.MD4 : HashAlgorithm {
public MD4 Create()
public MD4 Create(string hashName)
}
internal Mono.Security.Cryptography.MD4Managed : MD4 {
private UInt32[] state
private Byte[] buffer
private UInt32[] count
private UInt32[] x
private int S11
private int S12
private int S13
private int S14
private int S21
private int S22
private int S23
private int S24
private int S31
private int S32
private int S33
private int S34
private Byte[] digest
public void Initialize()
protected void HashCore(Byte[] array, int ibStart, int cbSize)
protected Byte[] HashFinal()
private Byte[] Padding(int nLength)
private UInt32 F(UInt32 x, UInt32 y, UInt32 z)
private UInt32 G(UInt32 x, UInt32 y, UInt32 z)
private UInt32 H(UInt32 x, UInt32 y, UInt32 z)
private UInt32 ROL(UInt32 x, byte n)
private void FF(UInt32& a, UInt32 b, UInt32 c, UInt32 d, UInt32 x, byte s)
private void GG(UInt32& a, UInt32 b, UInt32 c, UInt32 d, UInt32 x, byte s)
private void HH(UInt32& a, UInt32 b, UInt32 c, UInt32 d, UInt32 x, byte s)
private void Encode(Byte[] output, UInt32[] input)
private void Decode(UInt32[] output, Byte[] input, int index)
private void MD4Transform(UInt32[] state, Byte[] block, int index)
}
internal Mono.Security.Cryptography.PKCS1 : object {
private Byte[] emptySHA1
private Byte[] emptySHA256
private Byte[] emptySHA384
private Byte[] emptySHA512
private bool Compare(Byte[] array1, Byte[] array2)
private Byte[] xor(Byte[] array1, Byte[] array2)
private Byte[] GetEmptyHash(HashAlgorithm hash)
public Byte[] I2OSP(int x, int size)
public Byte[] I2OSP(Byte[] x, int size)
public Byte[] OS2IP(Byte[] x)
public Byte[] RSAEP(RSA rsa, Byte[] m)
public Byte[] RSADP(RSA rsa, Byte[] c)
public Byte[] RSASP1(RSA rsa, Byte[] m)
public Byte[] RSAVP1(RSA rsa, Byte[] s)
public Byte[] Encrypt_OAEP(RSA rsa, HashAlgorithm hash, RandomNumberGenerator rng, Byte[] M)
public Byte[] Decrypt_OAEP(RSA rsa, HashAlgorithm hash, Byte[] C)
public Byte[] Encrypt_v15(RSA rsa, RandomNumberGenerator rng, Byte[] M)
public Byte[] Decrypt_v15(RSA rsa, Byte[] C)
public Byte[] Sign_v15(RSA rsa, HashAlgorithm hash, Byte[] hashValue)
internal Byte[] Sign_v15(RSA rsa, string hashName, Byte[] hashValue)
public bool Verify_v15(RSA rsa, HashAlgorithm hash, Byte[] hashValue, Byte[] signature)
internal bool Verify_v15(RSA rsa, string hashName, Byte[] hashValue, Byte[] signature)
public bool Verify_v15(RSA rsa, HashAlgorithm hash, Byte[] hashValue, Byte[] signature, bool tryNonStandardEncoding)
public Byte[] Encode_v15(HashAlgorithm hash, Byte[] hashValue, int emLength)
public Byte[] MGF1(HashAlgorithm hash, Byte[] mgfSeed, int maskLen)
internal string HashNameFromOid(string oid, bool throwOnError)
internal HashAlgorithm CreateFromOid(string oid)
internal HashAlgorithm CreateFromName(string name)
}
internal Mono.Security.Cryptography.PKCS8 : object {
public KeyInfo GetType(Byte[] data)
}
internal Mono.Security.Cryptography.RC4 : SymmetricAlgorithm {
private KeySizes[] s_legalBlockSizes
private KeySizes[] s_legalKeySizes
public Byte[] IV
public Byte[] get_IV()
public void set_IV(Byte[] value)
public RC4 Create()
public RC4 Create(string algName)
}
internal Mono.Security.Cryptography.RSAManaged : RSA {
private int defaultKeySize
private bool isCRTpossible
private bool keyBlinding
private bool keypairGenerated
private bool m_disposed
private BigInteger d
private BigInteger p
private BigInteger q
private BigInteger dp
private BigInteger dq
private BigInteger qInv
private BigInteger n
private BigInteger e
private KeyGeneratedEventHandler KeyGenerated
public int KeySize
public string KeyExchangeAlgorithm
public bool PublicOnly
public string SignatureAlgorithm
public bool UseKeyBlinding
public bool IsCrtPossible
public void .ctor(int keySize)
protected void Finalize()
private void GenerateKeyPair()
public int get_KeySize()
public string get_KeyExchangeAlgorithm()
public bool get_PublicOnly()
public string get_SignatureAlgorithm()
public Byte[] DecryptValue(Byte[] rgb)
public Byte[] EncryptValue(Byte[] rgb)
public RSAParameters ExportParameters(bool includePrivateParameters)
public void ImportParameters(RSAParameters parameters)
protected void Dispose(bool disposing)
public void add_KeyGenerated(KeyGeneratedEventHandler value)
public void remove_KeyGenerated(KeyGeneratedEventHandler value)
public string ToXmlString(bool includePrivateParameters)
public bool get_UseKeyBlinding()
public void set_UseKeyBlinding(bool value)
public bool get_IsCrtPossible()
private Byte[] GetPaddedValue(BigInteger value, int length)
}
internal Mono.Security.Cryptography.SymmetricTransform : object {
protected SymmetricAlgorithm algo
protected bool encrypt
protected int BlockSizeByte
protected Byte[] temp
protected Byte[] temp2
private Byte[] workBuff
private Byte[] workout
protected PaddingMode padmode
protected int FeedBackByte
private bool m_disposed
protected bool lastBlock
private RandomNumberGenerator _rng
public bool CanTransformMultipleBlocks
public bool CanReuseTransform
public int InputBlockSize
public int OutputBlockSize
private bool KeepLastBlock
public void .ctor(SymmetricAlgorithm symmAlgo, bool encryption, Byte[] rgbIV)
protected void Finalize()
private void System.IDisposable.Dispose()
protected void Dispose(bool disposing)
public bool get_CanTransformMultipleBlocks()
public bool get_CanReuseTransform()
public int get_InputBlockSize()
public int get_OutputBlockSize()
protected void Transform(Byte[] input, Byte[] output)
protected void ECB(Byte[] input, Byte[] output)
protected void CBC(Byte[] input, Byte[] output)
protected void CFB(Byte[] input, Byte[] output)
protected void OFB(Byte[] input, Byte[] output)
protected void CTS(Byte[] input, Byte[] output)
private void CheckInput(Byte[] inputBuffer, int inputOffset, int inputCount)
public int TransformBlock(Byte[] inputBuffer, int inputOffset, int inputCount, Byte[] outputBuffer, int outputOffset)
private bool get_KeepLastBlock()
private int InternalTransformBlock(Byte[] inputBuffer, int inputOffset, int inputCount, Byte[] outputBuffer, int outputOffset)
private void Random(Byte[] buffer, int start, int length)
private void ThrowBadPaddingException(PaddingMode padding, int length, int position)
protected Byte[] FinalEncrypt(Byte[] inputBuffer, int inputOffset, int inputCount)
protected Byte[] FinalDecrypt(Byte[] inputBuffer, int inputOffset, int inputCount)
public Byte[] TransformFinalBlock(Byte[] inputBuffer, int inputOffset, int inputCount)
}
internal Mono.Security.PKCS7 : object {
public ASN1 Attribute(string oid, ASN1 value)
public ASN1 AlgorithmIdentifier(string oid)
public ASN1 AlgorithmIdentifier(string oid, ASN1 parameters)
public ASN1 IssuerAndSerialNumber(X509Certificate x509)
}
internal Mono.Security.StrongName : object {
private RSA rsa
private Byte[] publicKey
private Byte[] keyToken
private string tokenAlgorithm
private object lockObject
private bool initialized
public bool CanSign
public RSA RSA
public Byte[] PublicKey
public Byte[] PublicKeyToken
public string TokenAlgorithm
public void .ctor(int keySize)
public void .ctor(Byte[] data)
public void .ctor(RSA rsa)
private void InvalidateCache()
public bool get_CanSign()
public RSA get_RSA()
public void set_RSA(RSA value)
public Byte[] get_PublicKey()
public Byte[] get_PublicKeyToken()
public string get_TokenAlgorithm()
public void set_TokenAlgorithm(string value)
public Byte[] GetBytes()
private UInt32 RVAtoPosition(UInt32 r, int sections, Byte[] headers)
internal StrongNameSignature StrongHash(Stream stream, StrongNameOptions options)
public Byte[] Hash(string fileName)
public bool Sign(string fileName)
public bool Verify(string fileName)
public bool Verify(Stream stream)
public bool IsAssemblyStrongnamed(string assemblyName)
public bool VerifySignature(Byte[] publicKey, int algorithm, Byte[] hash, Byte[] signature)
private bool Verify(RSA rsa, AssemblyHashAlgorithm algorithm, Byte[] hash, Byte[] signature)
}
internal Mono.Security.StrongNameManager : object {
private Hashtable mappings
private Hashtable tokens
public void LoadConfig(string filename)
private void LoadMapping(SecurityElement mapping)
private void LoadVerificationSettings(SecurityElement settings)
public Byte[] GetMappedPublicKey(Byte[] token)
public bool MustVerify(AssemblyName an)
public string ToString()
}
internal Mono.Security.Uri : object {
private bool isUnixFilePath
private string source
private string scheme
private string host
private int port
private string path
private string query
private string fragment
private string userinfo
private bool isUnc
private bool isOpaquePart
private String[] segments
private bool userEscaped
private string cachedAbsoluteUri
private string cachedToString
private string cachedLocalPath
private int cachedHashCode
private bool reduce
private string hexUpperChars
public string SchemeDelimiter
public string UriSchemeFile
public string UriSchemeFtp
public string UriSchemeGopher
public string UriSchemeHttp
public string UriSchemeHttps
public string UriSchemeMailto
public string UriSchemeNews
public string UriSchemeNntp
private UriScheme[] schemes
public string AbsolutePath
public string AbsoluteUri
public string Authority
public string Fragment
public string Host
public bool IsDefaultPort
public bool IsFile
public bool IsLoopback
public bool IsUnc
public string LocalPath
public string PathAndQuery
public int Port
public string Query
public string Scheme
public String[] Segments
public bool UserEscaped
public string UserInfo
public void .ctor(string uriString)
public void .ctor(string uriString, bool dontEscape)
public void .ctor(string uriString, bool dontEscape, bool reduce)
public void .ctor(Uri baseUri, string relativeUri)
public void .ctor(Uri baseUri, string relativeUri, bool dontEscape)
public string get_AbsolutePath()
public string get_AbsoluteUri()
public string get_Authority()
public string get_Fragment()
public string get_Host()
public bool get_IsDefaultPort()
public bool get_IsFile()
public bool get_IsLoopback()
public bool get_IsUnc()
public string get_LocalPath()
public string get_PathAndQuery()
public int get_Port()
public string get_Query()
public string get_Scheme()
public String[] get_Segments()
public bool get_UserEscaped()
public string get_UserInfo()
internal bool IsIPv4Address(string name)
internal bool IsDomainAddress(string name)
public bool CheckSchemeName(string schemeName)
public bool Equals(object comparant)
public int GetHashCode()
public string GetLeftPart(UriPartial part)
public int FromHex(char digit)
public string HexEscape(char character)
public char HexUnescape(string pattern, Int32& index)
public bool IsHexDigit(char digit)
public bool IsHexEncoding(string pattern, int index)
public string MakeRelative(Uri toUri)
public string ToString()
protected void Escape()
protected string EscapeString(string str)
internal string EscapeString(string str, bool escapeReserved, bool escapeHex, bool escapeBrackets)
protected void Parse()
protected string Unescape(string str)
internal string Unescape(string str, bool excludeSharp)
private void ParseAsWindowsUNC(string uriString)
private void ParseAsWindowsAbsoluteFilePath(string uriString)
private void ParseAsUnixAbsoluteFilePath(string uriString)
private void Parse(string uriString)
private string Reduce(string path)
internal string GetSchemeDelimiter(string scheme)
internal int GetDefaultPort(string scheme)
private string GetOpaqueWiseSchemeDelimiter()
protected bool IsBadFileSystemCharacter(char ch)
protected bool IsExcludedCharacter(char ch)
private bool IsPredefinedScheme(string scheme)
protected bool IsReservedCharacter(char ch)
}
internal Mono.Security.UriPartial : Enum {
public int value__
public UriPartial Scheme
public UriPartial Authority
public UriPartial Path
}
internal Mono.Security.X509.Extensions.BasicConstraintsExtension : X509Extension {
public int NoPathLengthConstraint
private bool cA
private int pathLenConstraint
public bool CertificateAuthority
public string Name
public int PathLenConstraint
public void .ctor(ASN1 asn1)
public void .ctor(X509Extension extension)
protected void Decode()
protected void Encode()
public bool get_CertificateAuthority()
public void set_CertificateAuthority(bool value)
public string get_Name()
public int get_PathLenConstraint()
public void set_PathLenConstraint(int value)
public string ToString()
}
internal Mono.Security.X509.Extensions.KeyUsageExtension : X509Extension {
private int kubits
public KeyUsages KeyUsage
public string Name
public void .ctor(ASN1 asn1)
public void .ctor(X509Extension extension)
protected void Decode()
protected void Encode()
public KeyUsages get_KeyUsage()
public void set_KeyUsage(KeyUsages value)
public string get_Name()
public bool Support(KeyUsages usage)
public string ToString()
}
internal Mono.Security.X509.Extensions.KeyUsages : Enum {
public int value__
public KeyUsages digitalSignature
public KeyUsages nonRepudiation
public KeyUsages keyEncipherment
public KeyUsages dataEncipherment
public KeyUsages keyAgreement
public KeyUsages keyCertSign
public KeyUsages cRLSign
public KeyUsages encipherOnly
public KeyUsages decipherOnly
public KeyUsages none
}
internal Mono.Security.X509.Extensions.SubjectKeyIdentifierExtension : X509Extension {
private Byte[] ski
public string Name
public Byte[] Identifier
public void .ctor(ASN1 asn1)
public void .ctor(X509Extension extension)
protected void Decode()
protected void Encode()
public string get_Name()
public Byte[] get_Identifier()
public void set_Identifier(Byte[] value)
public string ToString()
}
internal Mono.Security.X509.PKCS12 : object {
public string pbeWithSHAAnd128BitRC4
public string pbeWithSHAAnd40BitRC4
public string pbeWithSHAAnd3KeyTripleDESCBC
public string pbeWithSHAAnd2KeyTripleDESCBC
public string pbeWithSHAAnd128BitRC2CBC
public string pbeWithSHAAnd40BitRC2CBC
public string keyBag
public string pkcs8ShroudedKeyBag
public string certBag
public string crlBag
public string secretBag
public string safeContentsBag
public string x509Certificate
public string sdsiCertificate
public string x509Crl
private int recommendedIterationCount
private Byte[] _password
private ArrayList _keyBags
private ArrayList _secretBags
private X509CertificateCollection _certs
private bool _keyBagsChanged
private bool _secretBagsChanged
private bool _certsChanged
private int _iterations
private ArrayList _safeBags
private RandomNumberGenerator _rng
public int CryptoApiPasswordLimit
private int password_max_length
public string Password
public int IterationCount
public ArrayList Keys
public ArrayList Secrets
public X509CertificateCollection Certificates
internal RandomNumberGenerator RNG
public int MaximumPasswordLength
public void .ctor(Byte[] data)
public void .ctor(Byte[] data, string password)
public void .ctor(Byte[] data, Byte[] password)
private void Decode(Byte[] data)
protected void Finalize()
public void set_Password(string value)
public int get_IterationCount()
public void set_IterationCount(int value)
public ArrayList get_Keys()
public ArrayList get_Secrets()
public X509CertificateCollection get_Certificates()
internal RandomNumberGenerator get_RNG()
private bool Compare(Byte[] expected, Byte[] actual)
private SymmetricAlgorithm GetSymmetricAlgorithm(string algorithmOid, Byte[] salt, int iterationCount)
public Byte[] Decrypt(string algorithmOid, Byte[] salt, int iterationCount, Byte[] encryptedData)
public Byte[] Decrypt(EncryptedData ed)
public Byte[] Encrypt(string algorithmOid, Byte[] salt, int iterationCount, Byte[] data)
private DSAParameters GetExistingParameters(Boolean& found)
private void AddPrivateKey(PrivateKeyInfo pki)
private void ReadSafeBag(ASN1 safeBag)
private ASN1 Pkcs8ShroudedKeyBagSafeBag(AsymmetricAlgorithm aa, IDictionary attributes)
private ASN1 KeyBagSafeBag(AsymmetricAlgorithm aa, IDictionary attributes)
private ASN1 SecretBagSafeBag(Byte[] secret, IDictionary attributes)
private ASN1 CertificateSafeBag(X509Certificate x509, IDictionary attributes)
private Byte[] MAC(Byte[] password, Byte[] salt, int iterations, Byte[] data)
public Byte[] GetBytes()
private ContentInfo EncryptedContentInfo(ASN1 safeBags, string algorithmOid)
public void AddCertificate(X509Certificate cert)
public void AddCertificate(X509Certificate cert, IDictionary attributes)
public void RemoveCertificate(X509Certificate cert)
public void RemoveCertificate(X509Certificate cert, IDictionary attrs)
private bool CompareAsymmetricAlgorithm(AsymmetricAlgorithm a1, AsymmetricAlgorithm a2)
public void AddPkcs8ShroudedKeyBag(AsymmetricAlgorithm aa)
public void AddPkcs8ShroudedKeyBag(AsymmetricAlgorithm aa, IDictionary attributes)
public void RemovePkcs8ShroudedKeyBag(AsymmetricAlgorithm aa)
public void AddKeyBag(AsymmetricAlgorithm aa)
public void AddKeyBag(AsymmetricAlgorithm aa, IDictionary attributes)
public void RemoveKeyBag(AsymmetricAlgorithm aa)
public void AddSecretBag(Byte[] secret)
public void AddSecretBag(Byte[] secret, IDictionary attributes)
public void RemoveSecretBag(Byte[] secret)
public AsymmetricAlgorithm GetAsymmetricAlgorithm(IDictionary attrs)
public Byte[] GetSecret(IDictionary attrs)
public X509Certificate GetCertificate(IDictionary attrs)
public IDictionary GetAttributes(AsymmetricAlgorithm aa)
public IDictionary GetAttributes(X509Certificate cert)
public void SaveToFile(string filename)
public object Clone()
public int get_MaximumPasswordLength()
public void set_MaximumPasswordLength(int value)
private Byte[] LoadFile(string filename)
public PKCS12 LoadFromFile(string filename)
public PKCS12 LoadFromFile(string filename, string password)
}
internal Mono.Security.X509.PKCS5 : object {
public string pbeWithMD2AndDESCBC
public string pbeWithMD5AndDESCBC
public string pbeWithMD2AndRC2CBC
public string pbeWithMD5AndRC2CBC
public string pbeWithSHA1AndDESCBC
public string pbeWithSHA1AndRC2CBC
}
internal Mono.Security.X509.PKCS9 : object {
public string friendlyName
public string localKeyId
}
internal Mono.Security.X509.SafeBag : object {
private string _bagOID
private ASN1 _asn1
public string BagOID
public ASN1 ASN1
public void .ctor(string bagOID, ASN1 asn1)
public string get_BagOID()
public ASN1 get_ASN1()
}
internal Mono.Security.X509.X501 : object {
private Byte[] countryName
private Byte[] organizationName
private Byte[] organizationalUnitName
private Byte[] commonName
private Byte[] localityName
private Byte[] stateOrProvinceName
private Byte[] streetAddress
private Byte[] domainComponent
private Byte[] userid
private Byte[] email
private Byte[] dnQualifier
private Byte[] title
private Byte[] surname
private Byte[] givenName
private Byte[] initial
public string ToString(ASN1 seq)
public string ToString(ASN1 seq, bool reversed, string separator, bool quotes)
private void AppendEntry(StringBuilder sb, ASN1 entry, bool quotes)
private AttributeTypeAndValue GetAttributeFromOid(string attributeType)
private bool IsOid(string oid)
private AttributeTypeAndValue ReadAttribute(string value, Int32& pos)
private bool IsHex(char c)
private string ReadHex(string value, Int32& pos)
private int ReadEscaped(StringBuilder sb, string value, int pos)
private int ReadQuoted(StringBuilder sb, string value, int pos)
private string ReadValue(string value, Int32& pos)
public ASN1 FromString(string rdn)
}
internal Mono.Security.X509.X509Certificate : object {
private ASN1 decoder
private Byte[] m_encodedcert
private DateTime m_from
private DateTime m_until
private ASN1 issuer
private string m_issuername
private string m_keyalgo
private Byte[] m_keyalgoparams
private ASN1 subject
private string m_subject
private Byte[] m_publickey
private Byte[] signature
private string m_signaturealgo
private Byte[] m_signaturealgoparams
private Byte[] certhash
private RSA _rsa
private DSA _dsa
private string OID_DSA
private string OID_RSA
private int version
private Byte[] serialnumber
private Byte[] issuerUniqueID
private Byte[] subjectUniqueID
private X509ExtensionCollection extensions
private string encoding_error
public DSA DSA
public X509ExtensionCollection Extensions
public Byte[] Hash
public string IssuerName
public string KeyAlgorithm
public Byte[] KeyAlgorithmParameters
public Byte[] PublicKey
public RSA RSA
public Byte[] RawData
public Byte[] SerialNumber
public Byte[] Signature
public string SignatureAlgorithm
public Byte[] SignatureAlgorithmParameters
public string SubjectName
public DateTime ValidFrom
public DateTime ValidUntil
public int Version
public bool IsCurrent
public Byte[] IssuerUniqueIdentifier
public Byte[] SubjectUniqueIdentifier
public bool IsSelfSigned
private void Parse(Byte[] data)
public void .ctor(Byte[] data)
private Byte[] GetUnsignedBigInteger(Byte[] integer)
public DSA get_DSA()
public void set_DSA(DSA value)
public X509ExtensionCollection get_Extensions()
public Byte[] get_Hash()
public string get_IssuerName()
public string get_KeyAlgorithm()
public Byte[] get_KeyAlgorithmParameters()
public void set_KeyAlgorithmParameters(Byte[] value)
public Byte[] get_PublicKey()
public RSA get_RSA()
public void set_RSA(RSA value)
public Byte[] get_RawData()
public Byte[] get_SerialNumber()
public Byte[] get_Signature()
public string get_SignatureAlgorithm()
public Byte[] get_SignatureAlgorithmParameters()
public string get_SubjectName()
public DateTime get_ValidFrom()
public DateTime get_ValidUntil()
public int get_Version()
public bool get_IsCurrent()
public bool WasCurrent(DateTime instant)
public Byte[] get_IssuerUniqueIdentifier()
public Byte[] get_SubjectUniqueIdentifier()
internal bool VerifySignature(DSA dsa)
internal bool VerifySignature(RSA rsa)
public bool VerifySignature(AsymmetricAlgorithm aa)
public bool CheckSignature(Byte[] hash, string hashAlgorithm, Byte[] signature)
public bool get_IsSelfSigned()
public ASN1 GetIssuerName()
public ASN1 GetSubjectName()
protected void .ctor(SerializationInfo info, StreamingContext context)
public void GetObjectData(SerializationInfo info, StreamingContext context)
private Byte[] PEM(string type, Byte[] data)
}
internal Mono.Security.X509.X509CertificateCollection : CollectionBase {
public X509Certificate Item
public void .ctor(X509Certificate[] value)
public void .ctor(X509CertificateCollection value)
public X509Certificate get_Item(int index)
public void set_Item(int index, X509Certificate value)
public int Add(X509Certificate value)
public void AddRange(X509Certificate[] value)
public void AddRange(X509CertificateCollection value)
public bool Contains(X509Certificate value)
public void CopyTo(X509Certificate[] array, int index)
public X509CertificateEnumerator GetEnumerator()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
public int GetHashCode()
public int IndexOf(X509Certificate value)
public void Insert(int index, X509Certificate value)
public void Remove(X509Certificate value)
private bool Compare(Byte[] array1, Byte[] array2)
}
internal Mono.Security.X509.X509Chain : object {
private X509CertificateCollection roots
private X509CertificateCollection certs
private X509Certificate _root
private X509CertificateCollection _chain
private X509ChainStatusFlags _status
public X509CertificateCollection Chain
public X509Certificate Root
public X509ChainStatusFlags Status
public X509CertificateCollection TrustAnchors
public void .ctor(X509CertificateCollection chain)
public X509CertificateCollection get_Chain()
public X509Certificate get_Root()
public X509ChainStatusFlags get_Status()
public X509CertificateCollection get_TrustAnchors()
public void set_TrustAnchors(X509CertificateCollection value)
public void LoadCertificate(X509Certificate x509)
public void LoadCertificates(X509CertificateCollection collection)
public X509Certificate FindByIssuerName(string issuerName)
public bool Build(X509Certificate leaf)
public void Reset()
private bool IsValid(X509Certificate cert)
private X509Certificate FindCertificateParent(X509Certificate child)
private X509Certificate FindCertificateRoot(X509Certificate potentialRoot)
private bool IsTrusted(X509Certificate potentialTrusted)
private bool IsParent(X509Certificate child, X509Certificate parent)
}
internal Mono.Security.X509.X509ChainStatusFlags : Enum {
public int value__
public X509ChainStatusFlags InvalidBasicConstraints
public X509ChainStatusFlags NoError
public X509ChainStatusFlags NotSignatureValid
public X509ChainStatusFlags NotTimeNested
public X509ChainStatusFlags NotTimeValid
public X509ChainStatusFlags PartialChain
public X509ChainStatusFlags UntrustedRoot
}
internal Mono.Security.X509.X509Crl : object {
private string issuer
private byte version
private DateTime thisUpdate
private DateTime nextUpdate
private ArrayList entries
private string signatureOID
private Byte[] signature
private X509ExtensionCollection extensions
private Byte[] encoded
private Byte[] hash_value
public ArrayList Entries
public X509CrlEntry Item
public X509CrlEntry Item
public X509ExtensionCollection Extensions
public Byte[] Hash
public string IssuerName
public DateTime NextUpdate
public DateTime ThisUpdate
public string SignatureAlgorithm
public Byte[] Signature
public Byte[] RawData
public byte Version
public bool IsCurrent
public void .ctor(Byte[] crl)
private void Parse(Byte[] crl)
public ArrayList get_Entries()
public X509CrlEntry get_Item(int index)
public X509CrlEntry get_Item(Byte[] serialNumber)
public X509ExtensionCollection get_Extensions()
public Byte[] get_Hash()
public string get_IssuerName()
public DateTime get_NextUpdate()
public DateTime get_ThisUpdate()
public string get_SignatureAlgorithm()
public Byte[] get_Signature()
public Byte[] get_RawData()
public byte get_Version()
public bool get_IsCurrent()
public bool WasCurrent(DateTime instant)
public Byte[] GetBytes()
private bool Compare(Byte[] array1, Byte[] array2)
public X509CrlEntry GetCrlEntry(X509Certificate x509)
public X509CrlEntry GetCrlEntry(Byte[] serialNumber)
public bool VerifySignature(X509Certificate x509)
internal bool VerifySignature(DSA dsa)
internal bool VerifySignature(RSA rsa)
public bool VerifySignature(AsymmetricAlgorithm aa)
public X509Crl CreateFromFile(string filename)
}
internal Mono.Security.X509.X509Extension : object {
protected string extnOid
protected bool extnCritical
protected ASN1 extnValue
public ASN1 ASN1
public string Oid
public bool Critical
public string Name
public ASN1 Value
public void .ctor(ASN1 asn1)
public void .ctor(X509Extension extension)
protected void Decode()
protected void Encode()
public ASN1 get_ASN1()
public string get_Oid()
public bool get_Critical()
public void set_Critical(bool value)
public string get_Name()
public ASN1 get_Value()
public bool Equals(object obj)
public Byte[] GetBytes()
public int GetHashCode()
private void WriteLine(StringBuilder sb, int n, int pos)
public string ToString()
}
internal Mono.Security.X509.X509ExtensionCollection : CollectionBase {
private bool readOnly
public X509Extension Item
public X509Extension Item
public void .ctor(ASN1 asn1)
public int Add(X509Extension extension)
public void AddRange(X509Extension[] extension)
public void AddRange(X509ExtensionCollection collection)
public bool Contains(X509Extension extension)
public bool Contains(string oid)
public void CopyTo(X509Extension[] extensions, int index)
public int IndexOf(X509Extension extension)
public int IndexOf(string oid)
public void Insert(int index, X509Extension extension)
public void Remove(X509Extension extension)
public void Remove(string oid)
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
public X509Extension get_Item(int index)
public X509Extension get_Item(string oid)
public Byte[] GetBytes()
}
internal Mono.Security.X509.X509Store : object {
private string _storePath
private X509CertificateCollection _certificates
private ArrayList _crls
private bool _crl
private bool _newFormat
private string _name
public X509CertificateCollection Certificates
public ArrayList Crls
public string Name
internal void .ctor(string path, bool crl, bool newFormat)
public X509CertificateCollection get_Certificates()
public ArrayList get_Crls()
public string get_Name()
public void Clear()
private void ClearCertificates()
private void ClearCrls()
public void Import(X509Certificate certificate)
public void Import(X509Crl crl)
public void Remove(X509Certificate certificate)
public void Remove(X509Crl crl)
private void ImportNewFormat(X509Certificate certificate)
private void RemoveNewFormat(X509Certificate certificate)
private string GetUniqueNameWithSerial(X509Certificate certificate)
private string GetUniqueName(X509Certificate certificate, Byte[] serial)
private string GetUniqueName(X509Crl crl)
private Byte[] GetUniqueName(X509ExtensionCollection extensions, Byte[] serial)
private string GetUniqueName(string method, Byte[] name, string fileExtension)
private Byte[] Load(string filename)
private X509Certificate LoadCertificate(string filename)
private X509Crl LoadCrl(string filename)
private bool CheckStore(string path, bool throwException)
private X509CertificateCollection BuildCertificatesCollection(string storeName)
private ArrayList BuildCrlsCollection(string storeName)
private void ImportPrivateKey(X509Certificate certificate, CspParameters cspParams)
}
internal Mono.Security.X509.X509StoreManager : object {
private string _userPath
private string _localMachinePath
private string _newUserPath
private string _newLocalMachinePath
private X509Stores _userStore
private X509Stores _machineStore
private X509Stores _newUserStore
private X509Stores _newMachineStore
internal string CurrentUserPath
internal string LocalMachinePath
internal string NewCurrentUserPath
internal string NewLocalMachinePath
public X509Stores CurrentUser
public X509Stores LocalMachine
public X509Stores NewCurrentUser
public X509Stores NewLocalMachine
public X509CertificateCollection IntermediateCACertificates
public ArrayList IntermediateCACrls
public X509CertificateCollection TrustedRootCertificates
public ArrayList TrustedRootCACrls
public X509CertificateCollection UntrustedCertificates
internal string get_CurrentUserPath()
internal string get_LocalMachinePath()
internal string get_NewCurrentUserPath()
internal string get_NewLocalMachinePath()
public X509Stores get_CurrentUser()
public X509Stores get_LocalMachine()
public X509Stores get_NewCurrentUser()
public X509Stores get_NewLocalMachine()
public X509CertificateCollection get_IntermediateCACertificates()
public ArrayList get_IntermediateCACrls()
public X509CertificateCollection get_TrustedRootCertificates()
public ArrayList get_TrustedRootCACrls()
public X509CertificateCollection get_UntrustedCertificates()
}
internal Mono.Security.X509.X509Stores : object {
private string _storePath
private bool _newFormat
private X509Store _personal
private X509Store _other
private X509Store _intermediate
private X509Store _trusted
private X509Store _untrusted
public X509Store Personal
public X509Store OtherPeople
public X509Store IntermediateCA
public X509Store TrustedRoot
public X509Store Untrusted
internal void .ctor(string path, bool newFormat)
public X509Store get_Personal()
public X509Store get_OtherPeople()
public X509Store get_IntermediateCA()
public X509Store get_TrustedRoot()
public X509Store get_Untrusted()
public void Clear()
public X509Store Open(string storeName, bool create)
}
internal Mono.Xml.DefaultHandler : object {
public void OnStartParsing(SmallXmlParser parser)
public void OnEndParsing(SmallXmlParser parser)
public void OnStartElement(string name, IAttrList attrs)
public void OnEndElement(string name)
public void OnChars(string s)
public void OnIgnorableWhitespace(string s)
public void OnProcessingInstruction(string name, string text)
}
internal Mono.Xml.SecurityParser : SmallXmlParser {
private SecurityElement root
private SecurityElement current
private Stack stack
public void LoadXml(string xml)
public SecurityElement ToXml()
public void OnStartParsing(SmallXmlParser parser)
public void OnProcessingInstruction(string name, string text)
public void OnIgnorableWhitespace(string s)
public void OnStartElement(string name, IAttrList attrs)
public void OnEndElement(string name)
public void OnChars(string ch)
public void OnEndParsing(SmallXmlParser parser)
}
internal Mono.Xml.SmallXmlParser : object {
private IContentHandler handler
private TextReader reader
private Stack elementNames
private Stack xmlSpaces
private string xmlSpace
private StringBuilder buffer
private Char[] nameBuffer
private bool isWhitespace
private AttrListImpl attributes
private int line
private int column
private bool resetColumn
private Exception Error(string msg)
private Exception UnexpectedEndError()
private bool IsNameChar(char c, bool start)
private bool IsWhitespace(int c)
public void SkipWhitespaces()
private void HandleWhitespaces()
public void SkipWhitespaces(bool expected)
private int Peek()
private int Read()
public void Expect(int c)
private string ReadUntil(char until, bool handleReferences)
public string ReadName()
public void Parse(TextReader input, IContentHandler handler)
private void Cleanup()
public void ReadContent()
private void HandleBufferedContent()
private void ReadCharacters()
private void ReadReference()
private int ReadCharacterReference()
private void ReadAttribute(AttrListImpl a)
private void ReadCDATASection()
private void ReadComment()
}
internal Mono.Xml.SmallXmlParserException : SystemException {
private int line
private int column
public int Line
public int Column
public void .ctor(string msg, int line, int column)
public int get_Line()
public int get_Column()
}
internal SR : object {
public string Arg_AccessException
public string Arg_AccessViolationException
public string Arg_ApplicationException
public string Arg_ArgumentException
public string Arg_ArgumentOutOfRangeException
public string Arg_ArithmeticException
public string Arg_ArrayPlusOffTooSmall
public string Arg_ArrayTypeMismatchException
public string Arg_ArrayZeroError
public string Arg_BadImageFormatException
public string Arg_BogusIComparer
public string Arg_CannotBeNaN
public string Arg_CannotHaveNegativeValue
public string Arg_CopyNonBlittableArray
public string Arg_CopyOutOfRange
public string Arg_CryptographyException
public string Arg_DataMisalignedException
public string Arg_DateTimeRange
public string Arg_DirectoryNotFoundException
public string Arg_DecBitCtor
public string Arg_DivideByZero
public string Arg_DlgtNullInst
public string Arg_DlgtTypeMis
public string Arg_DuplicateWaitObjectException
public string Arg_EnumAndObjectMustBeSameType
public string Arg_EntryPointNotFoundException
public string Arg_EntryPointNotFoundExceptionParameterized
public string Arg_EnumIllegalVal
public string Arg_ExecutionEngineException
public string Arg_ExternalException
public string Arg_FieldAccessException
public string Arg_FormatException
public string Arg_GuidArrayCtor
public string Arg_HexStyleNotSupported
public string Arg_HTCapacityOverflow
public string Arg_IndexOutOfRangeException
public string Arg_InsufficientExecutionStackException
public string Arg_InvalidBase
public string Arg_InvalidCastException
public string Arg_InvalidHexStyle
public string Arg_InvalidOperationException
public string Arg_OleAutDateInvalid
public string Arg_OleAutDateScale
public string Arg_InvalidRuntimeTypeHandle
public string Arg_IOException
public string Arg_KeyNotFound
public string Arg_LongerThanSrcString
public string Arg_LowerBoundsMustMatch
public string Arg_MissingFieldException
public string Arg_MethodAccessException
public string Arg_MissingMemberException
public string Arg_MissingMethodException
public string Arg_MulticastNotSupportedException
public string Arg_MustBeBoolean
public string Arg_MustBeByte
public string Arg_MustBeChar
public string Arg_MustBeDateTime
public string Arg_MustBeDateTimeOffset
public string Arg_MustBeDecimal
public string Arg_MustBeDouble
public string Arg_MustBeEnum
public string Arg_MustBeGuid
public string Arg_MustBeInt16
public string Arg_MustBeInt32
public string Arg_MustBeInt64
public string Arg_MustBePrimArray
public string Arg_MustBeSByte
public string Arg_MustBeSingle
public string Arg_MustBeStatic
public string Arg_MustBeString
public string Arg_MustBeStringPtrNotAtom
public string Arg_MustBeTimeSpan
public string Arg_MustBeUInt16
public string Arg_MustBeUInt32
public string Arg_MustBeUInt64
public string Arg_MustBeVersion
public string Arg_NeedAtLeast1Rank
public string Arg_Need2DArray
public string Arg_Need3DArray
public string Arg_NegativeArgCount
public string Arg_NotFiniteNumberException
public string Arg_NonZeroLowerBound
public string Arg_NotGenericParameter
public string Arg_NotImplementedException
public string Arg_NotSupportedException
public string Arg_NotSupportedNonZeroLowerBound
public string Arg_NullReferenceException
public string Arg_ObjObjEx
public string Arg_OverflowException
public string Arg_OutOfMemoryException
public string Arg_PlatformNotSupported
public string Arg_ParamName_Name
public string Arg_PathIllegal
public string Arg_PathIllegalUNC
public string Arg_RankException
public string Arg_RankIndices
public string Arg_RankMultiDimNotSupported
public string Arg_RanksAndBounds
public string Arg_RegGetOverflowBug
public string Arg_RegKeyNotFound
public string Arg_SecurityException
public string Arg_StackOverflowException
public string Arg_SynchronizationLockException
public string Arg_SystemException
public string Arg_TargetInvocationException
public string Arg_TargetParameterCountException
public string Arg_DefaultValueMissingException
public string Arg_ThreadStartException
public string Arg_ThreadStateException
public string Arg_TimeoutException
public string Arg_TypeAccessException
public string Arg_TypeLoadException
public string Arg_UnauthorizedAccessException
public string Arg_VersionString
public string Arg_WrongType
public string Argument_AbsolutePathRequired
public string Argument_AddingDuplicate
public string Argument_AddingDuplicate__
public string Argument_AdjustmentRulesNoNulls
public string Argument_AdjustmentRulesOutOfOrder
public string Argument_BadFormatSpecifier
public string Argument_CodepageNotSupported
public string Argument_CompareOptionOrdinal
public string Argument_ConflictingDateTimeRoundtripStyles
public string Argument_ConflictingDateTimeStyles
public string Argument_ConversionOverflow
public string Argument_ConvertMismatch
public string Argument_CultureInvalidIdentifier
public string Argument_CultureIetfNotSupported
public string Argument_CultureIsNeutral
public string Argument_CultureNotSupported
public string Argument_CustomCultureCannotBePassedByNumber
public string Argument_DateTimeBadBinaryData
public string Argument_DateTimeHasTicks
public string Argument_DateTimeHasTimeOfDay
public string Argument_DateTimeIsInvalid
public string Argument_DateTimeIsNotAmbiguous
public string Argument_DateTimeKindMustBeUnspecified
public string Argument_DateTimeOffsetInvalidDateTimeStyles
public string Argument_DateTimeOffsetIsNotAmbiguous
public string Argument_EmptyDecString
public string Argument_EmptyName
public string Argument_EmptyWaithandleArray
public string Argument_EncoderFallbackNotEmpty
public string Argument_EncodingConversionOverflowBytes
public string Argument_EncodingConversionOverflowChars
public string Argument_EncodingNotSupported
public string Argument_EnumTypeDoesNotMatch
public string Argument_FallbackBufferNotEmpty
public string Argument_IdnBadLabelSize
public string Argument_IdnBadPunycode
public string Argument_IdnIllegalName
public string Argument_ImplementIComparable
public string Argument_InvalidArgumentForComparison
public string Argument_InvalidArrayLength
public string Argument_InvalidArrayType
public string Argument_InvalidCalendar
public string Argument_InvalidCharSequence
public string Argument_InvalidCharSequenceNoIndex
public string Argument_InvalidCodePageBytesIndex
public string Argument_InvalidCodePageConversionIndex
public string Argument_InvalidCultureName
public string Argument_InvalidDateTimeKind
public string Argument_InvalidDateTimeStyles
public string Argument_InvalidDigitSubstitution
public string Argument_InvalidEnumValue
public string Argument_InvalidFlag
public string Argument_InvalidGroupSize
public string Argument_InvalidHighSurrogate
public string Argument_InvalidId
public string Argument_InvalidLowSurrogate
public string Argument_InvalidNativeDigitCount
public string Argument_InvalidNativeDigitValue
public string Argument_InvalidNeutralRegionName
public string Argument_InvalidNormalizationForm
public string Argument_InvalidNumberStyles
public string Argument_InvalidOffLen
public string Argument_InvalidPathChars
public string Argument_InvalidREG_TZI_FORMAT
public string Argument_InvalidResourceCultureName
public string Argument_InvalidSerializedString
public string Argument_InvalidTimeSpanStyles
public string Argument_MustBeFalse
public string Argument_NoEra
public string Argument_NoRegionInvariantCulture
public string Argument_NotIsomorphic
public string Argument_OffsetLocalMismatch
public string Argument_OffsetPrecision
public string Argument_OffsetOutOfRange
public string Argument_OffsetUtcMismatch
public string Argument_OneOfCulturesNotSupported
public string Argument_OnlyMscorlib
public string Argument_OutOfOrderDateTimes
public string ArgumentOutOfRange_HugeArrayNotSupported
public string ArgumentOutOfRange_Index
public string ArgumentOutOfRange_Length
public string ArgumentOutOfRange_LengthTooLarge
public string ArgumentOutOfRange_NeedNonNegNum
public string ArgumentOutOfRange_NeedNonNegNumRequired
public string Argument_PathFormatNotSupported
public string Argument_RecursiveFallback
public string Argument_RecursiveFallbackBytes
public string Argument_ResultCalendarRange
public string Argument_SemaphoreInitialMaximum
public string Argument_TimeSpanHasSeconds
public string Argument_TimeZoneNotFound
public string Argument_TimeZoneInfoBadTZif
public string Argument_TimeZoneInfoInvalidTZif
public string Argument_ToExclusiveLessThanFromExclusive
public string Argument_TransitionTimesAreIdentical
public string Argument_UTCOutOfRange
public string Argument_WaitHandleNameTooLong
public string ArgumentException_OtherNotArrayOfCorrectLength
public string ArgumentException_TupleIncorrectType
public string ArgumentException_TupleLastArgumentNotATuple
public string ArgumentException_ValueTupleIncorrectType
public string ArgumentException_ValueTupleLastArgumentNotAValueTuple
public string ArgumentNull_Array
public string ArgumentNull_ArrayElement
public string ArgumentNull_ArrayValue
public string ArgumentNull_Generic
public string ArgumentNull_Key
public string ArgumentNull_Obj
public string ArgumentNull_String
public string ArgumentNull_Type
public string ArgumentNull_Waithandles
public string ArgumentNull_WithParamName
public string ArgumentOutOfRange_AddValue
public string ArgumentOutOfRange_ActualValue
public string ArgumentOutOfRange_BadYearMonthDay
public string ArgumentOutOfRange_BadHourMinuteSecond
public string ArgumentOutOfRange_BiggerThanCollection
public string ArgumentOutOfRange_Bounds_Lower_Upper
public string ArgumentOutOfRange_CalendarRange
public string ArgumentOutOfRange_Capacity
public string ArgumentOutOfRange_Count
public string ArgumentOutOfRange_DateArithmetic
public string ArgumentOutOfRange_DateTimeBadMonths
public string ArgumentOutOfRange_DateTimeBadTicks
public string ArgumentOutOfRange_DateTimeBadYears
public string ArgumentOutOfRange_Day
public string ArgumentOutOfRange_DayOfWeek
public string ArgumentOutOfRange_DayParam
public string ArgumentOutOfRange_DecimalRound
public string ArgumentOutOfRange_DecimalScale
public string ArgumentOutOfRange_EndIndexStartIndex
public string ArgumentOutOfRange_Enum
public string ArgumentOutOfRange_Era
public string ArgumentOutOfRange_FileTimeInvalid
public string ArgumentOutOfRange_GenericPositive
public string ArgumentOutOfRange_GetByteCountOverflow
public string ArgumentOutOfRange_GetCharCountOverflow
public string ArgumentOutOfRange_IndexCount
public string ArgumentOutOfRange_IndexCountBuffer
public string ArgumentOutOfRange_IndexLength
public string ArgumentOutOfRange_IndexString
public string ArgumentOutOfRange_InvalidEraValue
public string ArgumentOutOfRange_InvalidHighSurrogate
public string ArgumentOutOfRange_InvalidLowSurrogate
public string ArgumentOutOfRange_InvalidUTF32
public string ArgumentOutOfRange_LengthGreaterThanCapacity
public string ArgumentOutOfRange_ListInsert
public string ArgumentOutOfRange_ListItem
public string ArgumentOutOfRange_ListRemoveAt
public string ArgumentOutOfRange_Month
public string ArgumentOutOfRange_MonthParam
public string ArgumentOutOfRange_MustBeNonNegInt32
public string ArgumentOutOfRange_MustBeNonNegNum
public string ArgumentOutOfRange_MustBePositive
public string ArgumentOutOfRange_NeedNonNegOrNegative1
public string ArgumentOutOfRange_NeedPosNum
public string ArgumentOutOfRange_NegativeCapacity
public string ArgumentOutOfRange_NegativeCount
public string ArgumentOutOfRange_NegativeLength
public string ArgumentOutOfRange_OffsetLength
public string ArgumentOutOfRange_OffsetOut
public string ArgumentOutOfRange_PartialWCHAR
public string ArgumentOutOfRange_Range
public string ArgumentOutOfRange_RoundingDigits
public string ArgumentOutOfRange_SmallCapacity
public string ArgumentOutOfRange_SmallMaxCapacity
public string ArgumentOutOfRange_StartIndex
public string ArgumentOutOfRange_StartIndexLargerThanLength
public string ArgumentOutOfRange_StartIndexLessThanLength
public string ArgumentOutOfRange_UtcOffset
public string ArgumentOutOfRange_UtcOffsetAndDaylightDelta
public string ArgumentOutOfRange_Version
public string ArgumentOutOfRange_Week
public string ArgumentOutOfRange_Year
public string Arithmetic_NaN
public string ArrayTypeMismatch_CantAssignType
public string BadImageFormatException_CouldNotLoadFileOrAssembly
public string CollectionCorrupted
public string Exception_EndOfInnerExceptionStack
public string Exception_WasThrown
public string Format_BadBase64Char
public string Format_BadBase64CharArrayLength
public string Format_BadBoolean
public string Format_BadFormatSpecifier
public string Format_BadQuote
public string Format_EmptyInputString
public string Format_GuidHexPrefix
public string Format_GuidInvLen
public string Format_GuidInvalidChar
public string Format_GuidBrace
public string Format_GuidComma
public string Format_GuidBraceAfterLastNumber
public string Format_GuidDashes
public string Format_GuidEndBrace
public string Format_ExtraJunkAtEnd
public string Format_GuidUnrecognized
public string Format_IndexOutOfRange
public string Format_InvalidGuidFormatSpecification
public string Format_InvalidString
public string Format_NeedSingleChar
public string Format_NoParsibleDigits
public string Format_BadTimeSpan
public string InsufficientMemory_MemFailPoint
public string InsufficientMemory_MemFailPoint_TooBig
public string InsufficientMemory_MemFailPoint_VAFrag
public string InvalidCast_CannotCastNullToValueType
public string InvalidCast_DownCastArrayElement
public string InvalidCast_FromTo
public string InvalidCast_IConvertible
public string InvalidCast_StoreArrayElement
public string InvalidOperation_Calling
public string InvalidOperation_DateTimeParsing
public string InvalidOperation_EnumEnded
public string InvalidOperation_EnumFailedVersion
public string InvalidOperation_EnumNotStarted
public string InvalidOperation_EnumOpCantHappen
public string InvalidOperation_HandleIsNotInitialized
public string InvalidOperation_IComparerFailed
public string InvalidOperation_NoValue
public string InvalidOperation_NullArray
public string InvalidOperation_Overlapped_Pack
public string InvalidOperation_ReadOnly
public string InvalidOperation_ThreadWrongThreadStart
public string InvalidOperation_UnknownEnumType
public string InvalidOperation_WriteOnce
public string InvalidOperation_ArrayCreateInstance_NotARuntimeType
public string InvalidOperation_TooEarly
public string InvalidOperation_NullContext
public string InvalidOperation_CannotUseAFCOtherThread
public string InvalidOperation_CannotRestoreUnsupressedFlow
public string InvalidOperation_CannotSupressFlowMultipleTimes
public string InvalidOperation_CannotUseAFCMultiple
public string InvalidOperation_AsyncFlowCtrlCtxMismatch
public string InvalidProgram_Default
public string InvalidProgram_Specific
public string InvalidProgram_Vararg
public string InvalidProgram_CallVirtFinalize
public string InvalidTimeZone_InvalidRegistryData
public string IO_FileExists_Name
public string IO_FileName_Name
public string IO_FileNotFound
public string IO_FileNotFound_FileName
public string IO_FileLoad
public string IO_FileLoad_FileName
public string IO_PathNotFound_NoPathName
public string IO_PathNotFound_Path
public string IO_PathTooLong
public string IO_SharingViolation_File
public string IO_SharingViolation_NoFileName
public string IO_AlreadyExists_Name
public string UnauthorizedAccess_IODenied_NoPathName
public string UnauthorizedAccess_IODenied_Path
public string Lazy_CreateValue_NoParameterlessCtorForT
public string Lazy_ctor_ModeInvalid
public string Lazy_StaticInit_InvalidOperation
public string Lazy_ToString_ValueNotCreated
public string Lazy_Value_RecursiveCallsToValue
public string MissingConstructor_Name
public string MustUseCCRewrite
public string NotSupported_FixedSizeCollection
public string NotSupported_MaxWaitHandles
public string NotSupported_NoCodepageData
public string NotSupported_ReadOnlyCollection
public string NotSupported_StringComparison
public string NotSupported_VoidArray
public string NotSupported_ByRefLike
public string NotSupported_Type
public string NotSupported_WaitAllSTAThread
public string ObjectDisposed_Generic
public string ObjectDisposed_ObjectName_Name
public string Overflow_Byte
public string Overflow_Char
public string Overflow_Decimal
public string Overflow_Double
public string Overflow_TimeSpanElementTooLarge
public string Overflow_Duration
public string Overflow_Int16
public string Overflow_Int32
public string Overflow_Int64
public string Overflow_NegateTwosCompNum
public string Overflow_NegativeUnsigned
public string Overflow_SByte
public string Overflow_Single
public string Overflow_TimeSpanTooLong
public string Overflow_UInt16
public string Overflow_UInt32
public string Overflow_UInt64
public string Rank_MultiDimNotSupported
public string RuntimeWrappedException
public string SpinWait_SpinUntil_ArgumentNull
public string Serialization_CorruptField
public string Serialization_InvalidData
public string Serialization_InvalidEscapeSequence
public string Serialization_InvalidType
public string SpinWait_SpinUntil_TimeoutWrong
public string Threading_AbandonedMutexException
public string Threading_SemaphoreFullException
public string Threading_ThreadInterrupted
public string Threading_WaitHandleCannotBeOpenedException
public string Threading_WaitHandleCannotBeOpenedException_InvalidHandle
public string TimeZoneNotFound_MissingRegistryData
public string TypeInitialization_Default
public string TypeInitialization_Type
public string TypeInitialization_Type_NoTypeAvailable
public string Verification_Exception
public string Arg_EnumFormatUnderlyingTypeAndObjectMustBeSameType
public string Format_InvalidEnumFormatSpecification
public string Arg_MustBeEnumBaseTypeOrEnum
public string Arg_EnumUnderlyingTypeAndObjectMustBeSameType
public string Arg_MustBeType
public string Arg_MustContainEnumInfo
public string Arg_EnumValueNotFound
public string Argument_StringZeroLength
public string Argument_StringFirstCharIsZero
public string Argument_LongEnvVarValue
public string Argument_IllegalEnvVarName
public string AssumptionFailed
public string AssumptionFailed_Cnd
public string AssertionFailed
public string AssertionFailed_Cnd
public string PreconditionFailed
public string PreconditionFailed_Cnd
public string PostconditionFailed
public string PostconditionFailed_Cnd
public string PostconditionOnExceptionFailed
public string PostconditionOnExceptionFailed_Cnd
public string InvariantFailed
public string InvariantFailed_Cnd
public string MissingEncodingNameResource
public string Globalization_cp_1200
public string Globalization_cp_1201
public string Globalization_cp_12000
public string Globalization_cp_12001
public string Globalization_cp_20127
public string Globalization_cp_28591
public string Globalization_cp_65000
public string Globalization_cp_65001
public string DebugAssertBanner
public string DebugAssertLongMessage
public string DebugAssertShortMessage
public string InvalidCast_Empty
public string Arg_UnknownTypeCode
public string Format_BadDatePattern
public string Format_BadDateTime
public string Format_BadDateTimeCalendar
public string Format_BadDayOfWeek
public string Format_DateOutOfRange
public string Format_MissingIncompleteDate
public string Format_OffsetOutOfRange
public string Format_RepeatDateTimePattern
public string Format_UnknowDateTimeWord
public string Format_UTCOutOfRange
public string RFLCT_Ambiguous
public string AggregateException_ctor_DefaultMessage
public string AggregateException_ctor_InnerExceptionNull
public string AggregateException_DeserializationFailure
public string AggregateException_InnerException
public string ArgumentOutOfRange_TimeoutTooLarge
public string ArgumentOutOfRange_PeriodTooLarge
public string TaskScheduler_FromCurrentSynchronizationContext_NoCurrent
public string TaskScheduler_ExecuteTask_WrongTaskScheduler
public string TaskScheduler_InconsistentStateAfterTryExecuteTaskInline
public string TaskSchedulerException_ctor_DefaultMessage
public string Task_MultiTaskContinuation_FireOptions
public string Task_ContinueWith_ESandLR
public string Task_MultiTaskContinuation_EmptyTaskList
public string Task_MultiTaskContinuation_NullTask
public string Task_FromAsync_PreferFairness
public string Task_FromAsync_LongRunning
public string AsyncMethodBuilder_InstanceNotInitialized
public string TaskT_TransitionToFinal_AlreadyCompleted
public string TaskT_DebuggerNoResult
public string OperationCanceled
public string CancellationToken_CreateLinkedToken_TokensIsEmpty
public string CancellationTokenSource_Disposed
public string CancellationToken_SourceDisposed
public string TaskExceptionHolder_UnknownExceptionType
public string TaskExceptionHolder_UnhandledException
public string Task_Delay_InvalidMillisecondsDelay
public string Task_Delay_InvalidDelay
public string Task_Dispose_NotCompleted
public string Task_WaitMulti_NullTask
public string Task_ContinueWith_NotOnAnything
public string Task_RunSynchronously_AlreadyStarted
public string Task_ThrowIfDisposed
public string Task_RunSynchronously_TaskCompleted
public string Task_RunSynchronously_Promise
public string Task_RunSynchronously_Continuation
public string Task_Start_AlreadyStarted
public string Task_Start_ContinuationTask
public string Task_Start_Promise
public string Task_Start_TaskCompleted
public string TaskCanceledException_ctor_DefaultMessage
public string TaskCompletionSourceT_TrySetException_NoExceptions
public string TaskCompletionSourceT_TrySetException_NullException
public string Argument_MinMaxValue
public string ExecutionContext_ExceptionInAsyncLocalNotification
public string InvalidOperation_WrongAsyncResultOrEndCalledMultiple
public string SpinLock_IsHeldByCurrentThread
public string SpinLock_TryEnter_LockRecursionException
public string SpinLock_Exit_SynchronizationLockException
public string SpinLock_TryReliableEnter_ArgumentException
public string SpinLock_TryEnter_ArgumentOutOfRange
public string ManualResetEventSlim_Disposed
public string ManualResetEventSlim_ctor_SpinCountOutOfRange
public string ManualResetEventSlim_ctor_TooManyWaiters
public string InvalidOperation_SendNotSupportedOnWindowsRTSynchronizationContext
public string InvalidOperation_SetData_OnlyOnce
public string SemaphoreSlim_Disposed
public string SemaphoreSlim_Release_CountWrong
public string SemaphoreSlim_Wait_TimeoutWrong
public string SemaphoreSlim_ctor_MaxCountWrong
public string SemaphoreSlim_ctor_InitialCountWrong
public string ThreadLocal_ValuesNotAvailable
public string ThreadLocal_Value_RecursiveCallsToValue
public string ThreadLocal_Disposed
public string LockRecursionException_WriteAfterReadNotAllowed
public string LockRecursionException_RecursiveWriteNotAllowed
public string LockRecursionException_ReadAfterWriteNotAllowed
public string LockRecursionException_RecursiveUpgradeNotAllowed
public string LockRecursionException_RecursiveReadNotAllowed
public string SynchronizationLockException_IncorrectDispose
public string SynchronizationLockException_MisMatchedWrite
public string LockRecursionException_UpgradeAfterReadNotAllowed
public string LockRecursionException_UpgradeAfterWriteNotAllowed
public string SynchronizationLockException_MisMatchedUpgrade
public string SynchronizationLockException_MisMatchedRead
public string InvalidOperation_TimeoutsNotSupported
public string NotSupported_UnreadableStream
public string NotSupported_UnwritableStream
public string ObjectDisposed_StreamClosed
public string NotSupported_SubclassOverride
public string InvalidOperation_NoPublicRemoveMethod
public string InvalidOperation_NoPublicAddMethod
public string SerializationException
public string Serialization_NotFound
public string Serialization_OptionalFieldVersionValue
public string Serialization_SameNameTwice
public string NotSupported_AbstractNonCLS
public string NotSupported_NoTypeInfo
public string Arg_CustomAttributeFormatException
public string Argument_InvalidMemberForNamedArgument
public string Arg_InvalidFilterCriteriaException
public string Arg_ParmArraySize
public string Arg_MustBePointer
public string Arg_InvalidHandle
public string Argument_InvalidEnum
public string Argument_MustHaveAttributeBaseClass
public string InvalidFilterCriteriaException_CritString
public string InvalidFilterCriteriaException_CritInt
public string InvalidOperation_NotSupportedOnWinRTEvent
public string PlatformNotSupported_ReflectionOnly
public string PlatformNotSupported_OSXFileLocking
public string MissingMember_Name
public string MissingMethod_Name
public string MissingField_Name
public string Format_StringZeroLength
public string Security_CannotReadRegistryData
public string Security_InvalidAssemblyPublicKey
public string Security_RegistryPermission
public string ClassLoad_General
public string ClassLoad_RankTooLarge
public string ClassLoad_ExplicitGeneric
public string ClassLoad_BadFormat
public string ClassLoad_ValueClassTooLarge
public string ClassLoad_ExplicitLayout
public string EE_MissingMethod
public string EE_MissingField
public string UnauthorizedAccess_RegistryKeyGeneric_Key
public string UnknownError_Num
public string Argument_NeedStructWithNoRefs
public string ArgumentNull_Buffer
public string ArgumentOutOfRange_AddressSpace
public string ArgumentOutOfRange_UIntPtrMaxMinusOne
public string Arg_BufferTooSmall
public string InvalidOperation_MustCallInitialize
public string ArgumentException_BufferNotFromPool
public string Argument_InvalidSafeBufferOffLen
public string Argument_InvalidSeekOrigin
public string Argument_NotEnoughBytesToRead
public string Argument_NotEnoughBytesToWrite
public string Argument_OffsetAndCapacityOutOfBounds
public string ArgumentOutOfRange_UnmanagedMemStreamLength
public string Argument_UnmanagedMemAccessorWrapAround
public string ArgumentOutOfRange_StreamLength
public string ArgumentOutOfRange_UnmanagedMemStreamWrapAround
public string InvalidOperation_CalledTwice
public string IO_FixedCapacity
public string IO_SeekBeforeBegin
public string IO_StreamTooLong
public string Arg_BadDecimal
public string NotSupported_Reading
public string NotSupported_UmsSafeBuffer
public string NotSupported_Writing
public string NotSupported_UnseekableStream
public string IndexOutOfRange_UMSPosition
public string ObjectDisposed_StreamIsClosed
public string ObjectDisposed_ViewAccessorClosed
public string ArgumentOutOfRange_PositionLessThanCapacityRequired
public string IO_EOF_ReadBeyondEOF
public string Arg_EndOfStreamException
public string ObjectDisposed_FileClosed
public string Arg_InvalidSearchPattern
public string ArgumentOutOfRange_FileLengthTooBig
public string Argument_InvalidHandle
public string Argument_AlreadyBoundOrSyncHandle
public string Argument_PreAllocatedAlreadyAllocated
public string Argument_NativeOverlappedAlreadyFree
public string Argument_NativeOverlappedWrongBoundHandle
public string Arg_HandleNotAsync
public string ArgumentNull_Path
public string Argument_EmptyPath
public string Argument_InvalidFileModeAndAccessCombo
public string Argument_InvalidAppendMode
public string IO_UnknownFileName
public string IO_FileStreamHandlePosition
public string NotSupported_FileStreamOnNonFiles
public string IO_BindHandleFailed
public string Arg_HandleNotSync
public string IO_SetLengthAppendTruncate
public string IO_SeekAppendOverwrite
public string IO_FileTooLongOrHandleNotSync
public string IndexOutOfRange_IORaceCondition
public string Arg_ResourceFileUnsupportedVersion
public string Resources_StreamNotValid
public string BadImageFormat_ResourcesHeaderCorrupted
public string Argument_StreamNotReadable
public string BadImageFormat_NegativeStringLength
public string BadImageFormat_ResourcesNameInvalidOffset
public string BadImageFormat_TypeMismatch
public string BadImageFormat_ResourceNameCorrupted_NameIndex
public string BadImageFormat_ResourcesDataInvalidOffset
public string Format_Bad7BitInt32
public string BadImageFormat_InvalidType
public string ResourceReaderIsClosed
public string Arg_MissingManifestResourceException
public string Serialization_MissingKeys
public string Serialization_NullKey
public string NotSupported_KeyCollectionSet
public string NotSupported_ValueCollectionSet
public string IO_IO_StreamTooLong
public string UnauthorizedAccess_MemStreamBuffer
public string NotSupported_MemStreamNotExpandable
public string IO_IO_SeekBeforeBegin
public string ArgumentNull_Stream
public string IO_IO_InvalidStringLen_Len
public string ArgumentOutOfRange_BinaryReaderFillBuffer
public string Serialization_InsufficientDeserializationState
public string NotSupported_UnitySerHolder
public string Serialization_UnableToFindModule
public string Argument_InvalidUnity
public string InvalidOperation_InvalidHandle
public string PlatformNotSupported_NamedSynchronizationPrimitives
public string InvalidOperation_EmptyQueue
public string Overflow_MutexReacquireCount
public string Serialization_InsufficientState
public string Serialization_UnknownMember
public string Serialization_NullSignature
public string Serialization_MemberTypeNotRecognized
public string Serialization_BadParameterInfo
public string Serialization_NoParameterInfo
public string ArgumentNull_Assembly
public string Arg_InvalidNeutralResourcesLanguage_Asm_Culture
public string Arg_InvalidNeutralResourcesLanguage_FallbackLoc
public string Arg_InvalidSatelliteContract_Asm_Ver
public string Arg_ResMgrNotResSet
public string BadImageFormat_ResourceNameCorrupted
public string BadImageFormat_ResourcesNameTooLong
public string InvalidOperation_ResMgrBadResSet_Type
public string InvalidOperation_ResourceNotStream_Name
public string MissingManifestResource_MultipleBlobs
public string MissingManifestResource_NoNeutralAsm
public string MissingManifestResource_NoNeutralDisk
public string MissingManifestResource_NoPRIresources
public string MissingManifestResource_ResWFileNotLoaded
public string MissingSatelliteAssembly_Culture_Name
public string MissingSatelliteAssembly_Default
public string NotSupported_ObsoleteResourcesFile
public string NotSupported_ResourceObjectSerialization
public string ObjectDisposed_ResourceSet
public string Arg_ResourceNameNotExist
public string BadImageFormat_ResourceDataLengthInvalid
public string BadImageFormat_ResourcesIndexTooLong
public string InvalidOperation_ResourceNotString_Name
public string InvalidOperation_ResourceNotString_Type
public string NotSupported_WrongResourceReader_Type
public string Arg_MustBeDelegate
public string NotSupported_GlobalMethodSerialization
public string NotSupported_DelegateSerHolderSerial
public string DelegateSer_InsufficientMetadata
public string Argument_NoUninitializedStrings
public string ArgumentOutOfRangeException_NoGCRegionSizeTooLarge
public string InvalidOperationException_AlreadyInNoGCRegion
public string InvalidOperationException_NoGCRegionAllocationExceeded
public string InvalidOperationException_NoGCRegionInduced
public string InvalidOperationException_NoGCRegionNotInProgress
public string InvalidOperationException_SetLatencyModeNoGC
public string InvalidOperation_NotWithConcurrentGC
public string ThreadState_AlreadyStarted
public string ThreadState_Dead_Priority
public string ThreadState_Dead_State
public string ThreadState_NotStarted
public string ThreadState_SetPriorityFailed
public string Serialization_InvalidFieldState
public string Acc_CreateAbst
public string Acc_CreateGeneric
public string Argument_InvalidValue
public string NotSupported_ManagedActivation
public string PlatformNotSupported_ResourceManager_ResWFileUnsupportedMethod
public string PlatformNotSupported_ResourceManager_ResWFileUnsupportedProperty
public string Serialization_NonSerType
public string InvalidCast_DBNull
public string NotSupported_NYI
public string Delegate_GarbageCollected
public string Arg_AmbiguousMatchException
public string NotSupported_ChangeType
public string Arg_EmptyArray
public string MissingMember
public string MissingField
public string InvalidCast_FromDBNull
public string NotSupported_DBNullSerial
public string Serialization_StringBuilderCapacity
public string Serialization_StringBuilderMaxCapacity
public string PlatformNotSupported_Remoting
public string PlatformNotSupported_StrongNameSigning
public string Serialization_MissingDateTimeData
public string Serialization_DateTimeTicksOutOfRange
public string Arg_InvalidANSIString
public string Arg_ExpectedNulTermination
public string PlatformNotSupported_ArgIterator
public string Arg_TypeUnloadedException
public string Overflow_Currency
public string PlatformNotSupported_SecureBinarySerialization
public string Serialization_InvalidPtrValue
public string EventSource_ListenerNotFound
public string EventSource_ToString
public string EventSource_ImplementGetMetadata
public string EventSource_NeedGuid
public string EventSource_NeedName
public string EventSource_NeedDescriptors
public string EventSource_NeedManifest
public string EventSource_EventSourceGuidInUse
public string EventSource_ListenerWriteFailure
public string EventSource_NoManifest
public string Argument_StreamNotWritable
public string Arg_SurrogatesNotAllowedAsSingleChar
public string CustomAttributeFormat_InvalidFieldFail
public string CustomAttributeFormat_InvalidPropertyFail
public string NotSupported_CannotCallEqualsOnSpan
public string NotSupported_CannotCallGetHashCodeOnSpan
public string Argument_DestinationTooShort
public string Argument_InvalidTypeWithPointersNotSupported
public string ArrayTypeMismatch_ConstrainedCopy
public string Arg_DllNotFoundException
public string Arg_DllNotFoundExceptionParameterized
public string WrongSizeArrayInNStruct
public string Arg_InteropMarshalUnmappableChar
public string Arg_MarshalDirectiveException
public string BlockingCollection_Add_ConcurrentCompleteAdd
public string BlockingCollection_Add_Failed
public string BlockingCollection_CantAddAnyWhenCompleted
public string BlockingCollection_CantTakeAnyWhenAllDone
public string BlockingCollection_CantTakeWhenDone
public string BlockingCollection_Completed
public string BlockingCollection_CopyTo_IncorrectType
public string BlockingCollection_CopyTo_MultiDim
public string BlockingCollection_CopyTo_NonNegative
public string Collection_CopyTo_TooManyElems
public string BlockingCollection_ctor_BoundedCapacityRange
public string BlockingCollection_ctor_CountMoreThanCapacity
public string BlockingCollection_Disposed
public string BlockingCollection_Take_CollectionModified
public string BlockingCollection_TimeoutInvalid
public string BlockingCollection_ValidateCollectionsArray_DispElems
public string BlockingCollection_ValidateCollectionsArray_LargeSize
public string BlockingCollection_ValidateCollectionsArray_NullElems
public string BlockingCollection_ValidateCollectionsArray_ZeroSize
public string Common_OperationCanceled
public string ConcurrentBag_Ctor_ArgumentNullException
public string ConcurrentBag_CopyTo_ArgumentNullException
public string Collection_CopyTo_ArgumentOutOfRangeException
public string ConcurrentCollection_SyncRoot_NotSupported
public string ConcurrentDictionary_ArrayIncorrectType
public string ConcurrentDictionary_SourceContainsDuplicateKeys
public string ConcurrentDictionary_ConcurrencyLevelMustBePositive
public string ConcurrentDictionary_CapacityMustNotBeNegative
public string ConcurrentDictionary_IndexIsNegative
public string ConcurrentDictionary_ArrayNotLargeEnough
public string ConcurrentDictionary_KeyAlreadyExisted
public string ConcurrentDictionary_ItemKeyIsNull
public string ConcurrentDictionary_TypeOfKeyIncorrect
public string ConcurrentDictionary_TypeOfValueIncorrect
public string ConcurrentStack_PushPopRange_CountOutOfRange
public string ConcurrentStack_PushPopRange_InvalidCount
public string ConcurrentStack_PushPopRange_StartOutOfRange
public string Partitioner_DynamicPartitionsNotSupported
public string PartitionerStatic_CanNotCallGetEnumeratorAfterSourceHasBeenDisposed
public string PartitionerStatic_CurrentCalledBeforeMoveNext
public string ConcurrentBag_Enumerator_EnumerationNotStartedOrAlreadyFinished
public string ArrayTypeMustBeExactMatch
public string CannotCallEqualsOnSpan
public string CannotCallGetHashCodeOnSpan
public string Argument_EmptyValue
public string PlatformNotSupported_RuntimeInformation
public string MemoryDisposed
public string OutstandingReferences
internal string GetString(string name, Object[] args)
internal string GetString(CultureInfo culture, string name, Object[] args)
internal string GetString(string name)
internal string GetString(CultureInfo culture, string name)
internal string Format(string resourceFormat, Object[] args)
internal string Format(string resourceFormat, object p1)
internal string Format(string resourceFormat, object p1, object p2)
internal string Format(string resourceFormat, object p1, object p2, object p3)
}
internal System.__ComObject : MarshalByRefObject {
private IntPtr iunknown
private IntPtr hash_table
private SynchronizationContext synchronization_context
private ComInteropProxy proxy
internal IntPtr IUnknown
internal IntPtr IDispatch
internal Guid IID_IUnknown
internal Guid IID_IDispatch
internal __ComObject CreateRCW(Type t)
private void ReleaseInterfaces()
protected void Finalize()
internal void .ctor(Type t)
internal void .ctor(IntPtr pItf, ComInteropProxy p)
internal void Initialize(IntPtr pUnk, ComInteropProxy p)
internal void Initialize(Type t)
internal IntPtr CreateIUnknown(Type t)
private void InitializeApartmentDetails()
private Guid GetCLSID(Type t)
internal IntPtr GetInterfaceInternal(Type t, bool throwException)
internal IntPtr GetInterface(Type t, bool throwException)
internal IntPtr GetInterface(Type t)
private void CheckIUnknown()
internal IntPtr get_IUnknown()
internal IntPtr get_IDispatch()
internal Guid get_IID_IUnknown()
internal Guid get_IID_IDispatch()
public bool Equals(object obj)
public int GetHashCode()
private int CoCreateInstance(Guid rclsid, IntPtr pUnkOuter, UInt32 dwClsContext, Guid riid, IntPtr& pUnk)
private void <Finalize>b__6_0(object state)
}
internal System.__DTString : ValueType {
internal string Value
internal int Index
internal int len
internal char m_current
private CompareInfo m_info
private bool m_checkDigitToken
private Char[] WhiteSpaceChecks
internal CompareInfo CompareInfo
internal void .ctor(string str, DateTimeFormatInfo dtfi, bool checkDigitToken)
internal void .ctor(string str, DateTimeFormatInfo dtfi)
internal CompareInfo get_CompareInfo()
internal bool GetNext()
internal bool AtEnd()
internal bool Advance(int count)
internal void GetRegularToken(TokenType& tokenType, Int32& tokenValue, DateTimeFormatInfo dtfi)
internal TokenType GetSeparatorToken(DateTimeFormatInfo dtfi, Int32& indexBeforeSeparator, Char& charBeforeSeparator)
internal bool MatchSpecifiedWord(string target)
internal bool MatchSpecifiedWord(string target, int endIndex)
internal bool MatchSpecifiedWords(string target, bool checkWordBoundary, Int32& matchLength)
internal bool Match(string str)
internal bool Match(char ch)
internal int MatchLongestWords(String[] words, Int32& maxMatchStrLen)
internal int GetRepeatCount()
internal bool GetNextDigit()
internal char GetChar()
internal int GetDigit()
internal void SkipWhiteSpaces()
internal bool SkipWhiteSpaceCurrent()
internal void TrimTail()
internal void RemoveTrailingInQuoteSpaces()
internal void RemoveLeadingInQuoteSpaces()
internal DTSubString GetSubString()
internal void ConsumeSubString(DTSubString sub)
}
internal System.__Filters : object {
internal __Filters Instance
internal bool FilterAttribute(MemberInfo m, object filterCriteria)
internal bool FilterName(MemberInfo m, object filterCriteria)
internal bool FilterIgnoreCase(MemberInfo m, object filterCriteria)
}
internal System.__HResults : object {
internal int RO_E_CLOSED
internal int E_BOUNDS
internal int E_CHANGED_STATE
internal int E_FAIL
internal int E_POINTER
internal int E_NOTIMPL
internal int REGDB_E_CLASSNOTREG
internal int COR_E_AMBIGUOUSMATCH
internal int COR_E_APPDOMAINUNLOADED
internal int COR_E_APPLICATION
internal int COR_E_ARGUMENT
internal int COR_E_ARGUMENTOUTOFRANGE
internal int COR_E_ARITHMETIC
internal int COR_E_ARRAYTYPEMISMATCH
internal int COR_E_BADIMAGEFORMAT
internal int COR_E_TYPEUNLOADED
internal int COR_E_CANNOTUNLOADAPPDOMAIN
internal int COR_E_COMEMULATE
internal int COR_E_CONTEXTMARSHAL
internal int COR_E_DATAMISALIGNED
internal int COR_E_TIMEOUT
internal int COR_E_CUSTOMATTRIBUTEFORMAT
internal int COR_E_DIVIDEBYZERO
internal int COR_E_DUPLICATEWAITOBJECT
internal int COR_E_EXCEPTION
internal int COR_E_EXECUTIONENGINE
internal int COR_E_FIELDACCESS
internal int COR_E_FORMAT
internal int COR_E_INDEXOUTOFRANGE
internal int COR_E_INSUFFICIENTMEMORY
internal int COR_E_INSUFFICIENTEXECUTIONSTACK
internal int COR_E_INVALIDCAST
internal int COR_E_INVALIDCOMOBJECT
internal int COR_E_INVALIDFILTERCRITERIA
internal int COR_E_INVALIDOLEVARIANTTYPE
internal int COR_E_INVALIDOPERATION
internal int COR_E_INVALIDPROGRAM
internal int COR_E_KEYNOTFOUND
internal int COR_E_MARSHALDIRECTIVE
internal int COR_E_MEMBERACCESS
internal int COR_E_METHODACCESS
internal int COR_E_MISSINGFIELD
internal int COR_E_MISSINGMANIFESTRESOURCE
internal int COR_E_MISSINGMEMBER
internal int COR_E_MISSINGMETHOD
internal int COR_E_MISSINGSATELLITEASSEMBLY
internal int COR_E_MULTICASTNOTSUPPORTED
internal int COR_E_NOTFINITENUMBER
internal int COR_E_PLATFORMNOTSUPPORTED
internal int COR_E_NOTSUPPORTED
internal int COR_E_NULLREFERENCE
internal int COR_E_OBJECTDISPOSED
internal int COR_E_OPERATIONCANCELED
internal int COR_E_OUTOFMEMORY
internal int COR_E_OVERFLOW
internal int COR_E_RANK
internal int COR_E_REFLECTIONTYPELOAD
internal int COR_E_RUNTIMEWRAPPED
internal int COR_E_SAFEARRAYRANKMISMATCH
internal int COR_E_SAFEARRAYTYPEMISMATCH
internal int COR_E_SAFEHANDLEMISSINGATTRIBUTE
internal int COR_E_SECURITY
internal int COR_E_SERIALIZATION
internal int COR_E_SEMAPHOREFULL
internal int COR_E_WAITHANDLECANNOTBEOPENED
internal int COR_E_ABANDONEDMUTEX
internal int COR_E_STACKOVERFLOW
internal int COR_E_SYNCHRONIZATIONLOCK
internal int COR_E_SYSTEM
internal int COR_E_TARGET
internal int COR_E_TARGETINVOCATION
internal int COR_E_TARGETPARAMCOUNT
internal int COR_E_THREADABORTED
internal int COR_E_THREADINTERRUPTED
internal int COR_E_THREADSTATE
internal int COR_E_THREADSTOP
internal int COR_E_THREADSTART
internal int COR_E_TYPEACCESS
internal int COR_E_TYPEINITIALIZATION
internal int COR_E_TYPELOAD
internal int COR_E_ENTRYPOINTNOTFOUND
internal int COR_E_DLLNOTFOUND
internal int COR_E_UNAUTHORIZEDACCESS
internal int COR_E_UNSUPPORTEDFORMAT
internal int COR_E_VERIFICATION
internal int COR_E_HOSTPROTECTION
internal int CORSEC_E_MIN_GRANT_FAIL
internal int CORSEC_E_NO_EXEC_PERM
internal int CORSEC_E_POLICY_EXCEPTION
internal int CORSEC_E_XMLSYNTAX
internal int NTE_FAIL
internal int CORSEC_E_CRYPTO
internal int CORSEC_E_CRYPTO_UNEX_OPER
internal int DISP_E_OVERFLOW
internal int FUSION_E_REF_DEF_MISMATCH
internal int FUSION_E_INVALID_NAME
internal int TYPE_E_TYPEMISMATCH
}
public System._AppDomain {
public string FriendlyName
public string BaseDirectory
public string RelativeSearchPath
public bool ShadowCopyFiles
public string DynamicDirectory
public Evidence Evidence
public void GetTypeInfoCount(UInt32& pcTInfo)
public void GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo)
public void GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId)
public void Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr)
public string ToString()
public bool Equals(object other)
public int GetHashCode()
public Type GetType()
public object InitializeLifetimeService()
public object GetLifetimeService()
public void add_DomainUnload(EventHandler value)
public void remove_DomainUnload(EventHandler value)
public void add_AssemblyLoad(AssemblyLoadEventHandler value)
public void remove_AssemblyLoad(AssemblyLoadEventHandler value)
public void add_ProcessExit(EventHandler value)
public void remove_ProcessExit(EventHandler value)
public void add_TypeResolve(ResolveEventHandler value)
public void remove_TypeResolve(ResolveEventHandler value)
public void add_ResourceResolve(ResolveEventHandler value)
public void remove_ResourceResolve(ResolveEventHandler value)
public void add_AssemblyResolve(ResolveEventHandler value)
public void remove_AssemblyResolve(ResolveEventHandler value)
public void add_UnhandledException(UnhandledExceptionEventHandler value)
public void remove_UnhandledException(UnhandledExceptionEventHandler value)
public AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access)
public AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access, string dir)
public AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access, Evidence evidence)
public AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access, PermissionSet requiredPermissions, PermissionSet optionalPermissions, PermissionSet refusedPermissions)
public AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access, string dir, Evidence evidence)
public AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access, string dir, PermissionSet requiredPermissions, PermissionSet optionalPermissions, PermissionSet refusedPermissions)
public AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access, Evidence evidence, PermissionSet requiredPermissions, PermissionSet optionalPermissions, PermissionSet refusedPermissions)
public AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access, string dir, Evidence evidence, PermissionSet requiredPermissions, PermissionSet optionalPermissions, PermissionSet refusedPermissions)
public AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access, string dir, Evidence evidence, PermissionSet requiredPermissions, PermissionSet optionalPermissions, PermissionSet refusedPermissions, bool isSynchronized)
public ObjectHandle CreateInstance(string assemblyName, string typeName)
public ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName)
public ObjectHandle CreateInstance(string assemblyName, string typeName, Object[] activationAttributes)
public ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, Object[] activationAttributes)
public ObjectHandle CreateInstance(string assemblyName, string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes, Evidence securityAttributes)
public ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes, Evidence securityAttributes)
public Assembly Load(AssemblyName assemblyRef)
public Assembly Load(string assemblyString)
public Assembly Load(Byte[] rawAssembly)
public Assembly Load(Byte[] rawAssembly, Byte[] rawSymbolStore)
public Assembly Load(Byte[] rawAssembly, Byte[] rawSymbolStore, Evidence securityEvidence)
public Assembly Load(AssemblyName assemblyRef, Evidence assemblySecurity)
public Assembly Load(string assemblyString, Evidence assemblySecurity)
public int ExecuteAssembly(string assemblyFile, Evidence assemblySecurity)
public int ExecuteAssembly(string assemblyFile)
public int ExecuteAssembly(string assemblyFile, Evidence assemblySecurity, String[] args)
public string get_FriendlyName()
public string get_BaseDirectory()
public string get_RelativeSearchPath()
public bool get_ShadowCopyFiles()
public Assembly[] GetAssemblies()
public void AppendPrivatePath(string path)
public void ClearPrivatePath()
public void SetShadowCopyPath(string s)
public void ClearShadowCopyPath()
public void SetCachePath(string s)
public void SetData(string name, object data)
public object GetData(string name)
public void DoCallBack(CrossAppDomainDelegate theDelegate)
public string get_DynamicDirectory()
public Evidence get_Evidence()
public void SetAppDomainPolicy(PolicyLevel domainPolicy)
public void SetPrincipalPolicy(PrincipalPolicy policy)
public void SetThreadPrincipal(IPrincipal principal)
}
public System.AccessViolationException : SystemException {
private IntPtr _ip
private IntPtr _target
private int _accessType
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
protected void .ctor(SerializationInfo info, StreamingContext context)
}
public System.Action : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke()
public IAsyncResult BeginInvoke(AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.Action`1 : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(T obj)
public IAsyncResult BeginInvoke(T obj, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.Action`2 : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(T1 arg1, T2 arg2)
public IAsyncResult BeginInvoke(T1 arg1, T2 arg2, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.Action`3 : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(T1 arg1, T2 arg2, T3 arg3)
public IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.Action`4 : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4)
public IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.Action`5 : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5)
public IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.Action`6 : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6)
public IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.Action`7 : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7)
public IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.Action`8 : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8)
public IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.ActivationContext : object {
private ApplicationIdentity _appid
private ContextForm _form
private bool _disposed
public ContextForm Form
public ApplicationIdentity Identity
public Byte[] ApplicationManifestBytes
public Byte[] DeploymentManifestBytes
private void .ctor(ApplicationIdentity identity)
protected void Finalize()
public ContextForm get_Form()
public ApplicationIdentity get_Identity()
public ActivationContext CreatePartialActivationContext(ApplicationIdentity identity)
public ActivationContext CreatePartialActivationContext(ApplicationIdentity identity, String[] manifestPaths)
public void Dispose()
private void Dispose(bool disposing)
private void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context)
public Byte[] get_ApplicationManifestBytes()
public Byte[] get_DeploymentManifestBytes()
}
public System.Activator : object {
internal int LookupMask
internal BindingFlags ConLookup
internal BindingFlags ConstructorDefault
public object CreateInstance(Type type, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture)
public object CreateInstance(Type type, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes)
public object CreateInstance(Type type, Object[] args)
public object CreateInstance(Type type, Object[] args, Object[] activationAttributes)
public object CreateInstance(Type type)
public ObjectHandle CreateInstance(string assemblyName, string typeName)
public ObjectHandle CreateInstance(string assemblyName, string typeName, Object[] activationAttributes)
public object CreateInstance(Type type, bool nonPublic)
public T CreateInstance()
public ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName)
public ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, Object[] activationAttributes)
public ObjectHandle CreateInstance(string assemblyName, string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes, Evidence securityInfo)
public ObjectHandle CreateInstance(string assemblyName, string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes)
internal ObjectHandle CreateInstance(string assemblyString, string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes, Evidence securityInfo, StackCrawlMark& stackMark)
public ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes, Evidence securityInfo)
public ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes)
private ObjectHandle CreateInstanceFromInternal(string assemblyFile, string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes, Evidence securityInfo)
public ObjectHandle CreateInstance(AppDomain domain, string assemblyName, string typeName)
public ObjectHandle CreateInstance(AppDomain domain, string assemblyName, string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes, Evidence securityAttributes)
public ObjectHandle CreateInstance(AppDomain domain, string assemblyName, string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes)
public ObjectHandle CreateInstanceFrom(AppDomain domain, string assemblyFile, string typeName)
public ObjectHandle CreateInstanceFrom(AppDomain domain, string assemblyFile, string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes, Evidence securityAttributes)
public ObjectHandle CreateInstanceFrom(AppDomain domain, string assemblyFile, string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes)
public ObjectHandle CreateComInstanceFrom(string assemblyName, string typeName)
public ObjectHandle CreateComInstanceFrom(string assemblyName, string typeName, Byte[] hashValue, AssemblyHashAlgorithm hashAlgorithm)
public object GetObject(Type type, string url)
public object GetObject(Type type, string url, object state)
private void Log(bool test, string title, string success, string failure)
private void System.Runtime.InteropServices._Activator.GetTypeInfoCount(UInt32& pcTInfo)
private void System.Runtime.InteropServices._Activator.GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo)
private void System.Runtime.InteropServices._Activator.GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId)
private void System.Runtime.InteropServices._Activator.Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr)
}
public System.AggregateException : Exception {
private ReadOnlyCollection`1<Exception> m_innerExceptions
public ReadOnlyCollection`1<Exception> InnerExceptions
private int InnerExceptionCount
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
public void .ctor(IEnumerable`1<Exception> innerExceptions)
public void .ctor(Exception[] innerExceptions)
public void .ctor(string message, IEnumerable`1<Exception> innerExceptions)
public void .ctor(string message, Exception[] innerExceptions)
private void .ctor(string message, IList`1<Exception> innerExceptions)
internal void .ctor(IEnumerable`1<ExceptionDispatchInfo> innerExceptionInfos)
internal void .ctor(string message, IEnumerable`1<ExceptionDispatchInfo> innerExceptionInfos)
private void .ctor(string message, IList`1<ExceptionDispatchInfo> innerExceptionInfos)
protected void .ctor(SerializationInfo info, StreamingContext context)
public void GetObjectData(SerializationInfo info, StreamingContext context)
public Exception GetBaseException()
public ReadOnlyCollection`1<Exception> get_InnerExceptions()
public void Handle(Func`2<Exception, bool> predicate)
public AggregateException Flatten()
public string ToString()
private int get_InnerExceptionCount()
}
public System.AppContext : object {
private Dictionary`2<string, SwitchValueState> s_switchMap
private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) s_defaultsInitialized
public string BaseDirectory
public string TargetFrameworkName
public string get_BaseDirectory()
public string get_TargetFrameworkName()
public object GetData(string name)
private void InitializeDefaultSwitchValues()
public bool TryGetSwitch(string switchName, Boolean& isEnabled)
public void SetSwitch(string switchName, bool isEnabled)
internal void DefineSwitchDefault(string switchName, bool isEnabled)
internal void DefineSwitchOverride(string switchName, bool isEnabled)
}
internal System.AppContextDefaultValues : object {
internal string SwitchNoAsyncCurrentCulture
internal string SwitchThrowExceptionIfDisposedCancellationTokenSource
internal string SwitchPreserveEventListnerObjectIdentity
internal string SwitchUseLegacyPathHandling
internal string SwitchBlockLongPaths
internal string SwitchDoNotAddrOfCspParentWindowHandle
internal string SwitchSetActorAsReferenceWhenCopyingClaimsIdentity
public void PopulateDefaultValues()
public bool TryGetSwitchOverride(string switchName, Boolean& overrideValue)
}
internal System.AppContextSwitches : object {
private int _noAsyncCurrentCulture
private int _throwExceptionIfDisposedCancellationTokenSource
private int _preserveEventListnerObjectIdentity
private int _useLegacyPathHandling
private int _blockLongPaths
private int _cloneActor
private int _doNotAddrOfCspParentWindowHandle
private bool <DisableCaching>k__BackingField
public bool NoAsyncCurrentCulture
public bool ThrowExceptionIfDisposedCancellationTokenSource
public bool PreserveEventListnerObjectIdentity
public bool UseLegacyPathHandling
public bool BlockLongPaths
public bool SetActorAsReferenceWhenCopyingClaimsIdentity
public bool DoNotAddrOfCspParentWindowHandle
private bool DisableCaching
public bool get_NoAsyncCurrentCulture()
public bool get_ThrowExceptionIfDisposedCancellationTokenSource()
public bool get_PreserveEventListnerObjectIdentity()
public bool get_UseLegacyPathHandling()
public bool get_BlockLongPaths()
public bool get_SetActorAsReferenceWhenCopyingClaimsIdentity()
public bool get_DoNotAddrOfCspParentWindowHandle()
private bool get_DisableCaching()
private void set_DisableCaching(bool value)
internal bool GetCachedSwitchValue(string switchName, Int32& switchValue)
private bool GetCachedSwitchValueInternal(string switchName, Int32& switchValue)
}
public System.AppDomain : MarshalByRefObject {
private IntPtr _mono_app_domain
private string _process_guid
private Dictionary`2<string, object> type_resolve_in_progress
private Dictionary`2<string, object> assembly_resolve_in_progress
private Dictionary`2<string, object> assembly_resolve_in_progress_refonly
private Evidence _evidence
private PermissionSet _granted
private PrincipalPolicy _principalPolicy
private IPrincipal _principal
private AppDomain default_domain
private AssemblyLoadEventHandler AssemblyLoad
private ResolveEventHandler AssemblyResolve
private EventHandler DomainUnload
private EventHandler ProcessExit
private ResolveEventHandler ResourceResolve
private ResolveEventHandler TypeResolve
private UnhandledExceptionEventHandler UnhandledException
private EventHandler`1<FirstChanceExceptionEventArgs> FirstChanceException
private AppDomainManager _domain_manager
private ResolveEventHandler ReflectionOnlyAssemblyResolve
private ActivationContext _activation
private ApplicationIdentity _applicationIdentity
private List`1<string> compatibility_switch
private AppDomainSetup SetupInformationNoCopy
public AppDomainSetup SetupInformation
public ApplicationTrust ApplicationTrust
public string BaseDirectory
public string RelativeSearchPath
public string DynamicDirectory
public bool ShadowCopyFiles
public string FriendlyName
public Evidence Evidence
internal IPrincipal DefaultPrincipal
internal PermissionSet GrantedPermissionSet
public PermissionSet PermissionSet
public AppDomain CurrentDomain
internal AppDomain DefaultDomain
public bool IsHomogenous
public bool IsFullyTrusted
public AppDomainManager DomainManager
public ActivationContext ActivationContext
public ApplicationIdentity ApplicationIdentity
public int Id
public bool MonitoringIsEnabled
public long MonitoringSurvivedMemorySize
public long MonitoringSurvivedProcessMemorySize
public long MonitoringTotalAllocatedMemorySize
public TimeSpan MonitoringTotalProcessorTime
internal bool IsAppXModel()
internal bool IsAppXDesignMode()
internal void CheckReflectionOnlyLoadSupported()
internal void CheckLoadFromSupported()
private AppDomainSetup getSetup()
private AppDomainSetup get_SetupInformationNoCopy()
public AppDomainSetup get_SetupInformation()
public ApplicationTrust get_ApplicationTrust()
public string get_BaseDirectory()
public string get_RelativeSearchPath()
public string get_DynamicDirectory()
public bool get_ShadowCopyFiles()
private string getFriendlyName()
public string get_FriendlyName()
public Evidence get_Evidence()
internal IPrincipal get_DefaultPrincipal()
internal PermissionSet get_GrantedPermissionSet()
public PermissionSet get_PermissionSet()
private AppDomain getCurDomain()
public AppDomain get_CurrentDomain()
private AppDomain getRootDomain()
internal AppDomain get_DefaultDomain()
public void AppendPrivatePath(string path)
public void ClearPrivatePath()
public void ClearShadowCopyPath()
public ObjectHandle CreateComInstanceFrom(string assemblyName, string typeName)
public ObjectHandle CreateComInstanceFrom(string assemblyFile, string typeName, Byte[] hashValue, AssemblyHashAlgorithm hashAlgorithm)
internal ObjectHandle InternalCreateInstanceWithNoSecurity(string assemblyName, string typeName)
internal ObjectHandle InternalCreateInstanceWithNoSecurity(string assemblyName, string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes, Evidence securityAttributes)
internal ObjectHandle InternalCreateInstanceFromWithNoSecurity(string assemblyName, string typeName)
internal ObjectHandle InternalCreateInstanceFromWithNoSecurity(string assemblyName, string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes, Evidence securityAttributes)
public ObjectHandle CreateInstance(string assemblyName, string typeName)
public ObjectHandle CreateInstance(string assemblyName, string typeName, Object[] activationAttributes)
public ObjectHandle CreateInstance(string assemblyName, string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes, Evidence securityAttributes)
public object CreateInstanceAndUnwrap(string assemblyName, string typeName)
public object CreateInstanceAndUnwrap(string assemblyName, string typeName, Object[] activationAttributes)
public object CreateInstanceAndUnwrap(string assemblyName, string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes, Evidence securityAttributes)
public ObjectHandle CreateInstance(string assemblyName, string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes)
public object CreateInstanceAndUnwrap(string assemblyName, string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes)
public ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes)
public object CreateInstanceFromAndUnwrap(string assemblyFile, string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes)
public ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName)
public ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, Object[] activationAttributes)
public ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes, Evidence securityAttributes)
public object CreateInstanceFromAndUnwrap(string assemblyName, string typeName)
public object CreateInstanceFromAndUnwrap(string assemblyName, string typeName, Object[] activationAttributes)
public object CreateInstanceFromAndUnwrap(string assemblyName, string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes, Evidence securityAttributes)
public AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access)
public AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access, Evidence evidence)
public AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access, string dir)
public AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access, string dir, Evidence evidence)
public AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access, PermissionSet requiredPermissions, PermissionSet optionalPermissions, PermissionSet refusedPermissions)
public AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access, Evidence evidence, PermissionSet requiredPermissions, PermissionSet optionalPermissions, PermissionSet refusedPermissions)
public AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access, string dir, PermissionSet requiredPermissions, PermissionSet optionalPermissions, PermissionSet refusedPermissions)
public AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access, string dir, Evidence evidence, PermissionSet requiredPermissions, PermissionSet optionalPermissions, PermissionSet refusedPermissions)
public AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access, string dir, Evidence evidence, PermissionSet requiredPermissions, PermissionSet optionalPermissions, PermissionSet refusedPermissions, bool isSynchronized)
public AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access, string dir, Evidence evidence, PermissionSet requiredPermissions, PermissionSet optionalPermissions, PermissionSet refusedPermissions, bool isSynchronized, IEnumerable`1<CustomAttributeBuilder> assemblyAttributes)
public AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access, IEnumerable`1<CustomAttributeBuilder> assemblyAttributes)
public AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access, string dir, bool isSynchronized, IEnumerable`1<CustomAttributeBuilder> assemblyAttributes)
public AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access, IEnumerable`1<CustomAttributeBuilder> assemblyAttributes, SecurityContextSource securityContextSource)
internal AssemblyBuilder DefineInternalDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access)
public void DoCallBack(CrossAppDomainDelegate callBackDelegate)
public int ExecuteAssembly(string assemblyFile)
public int ExecuteAssembly(string assemblyFile, Evidence assemblySecurity)
public int ExecuteAssembly(string assemblyFile, Evidence assemblySecurity, String[] args)
public int ExecuteAssembly(string assemblyFile, Evidence assemblySecurity, String[] args, Byte[] hashValue, AssemblyHashAlgorithm hashAlgorithm)
public int ExecuteAssembly(string assemblyFile, String[] args)
public int ExecuteAssembly(string assemblyFile, String[] args, Byte[] hashValue, AssemblyHashAlgorithm hashAlgorithm)
private int ExecuteAssemblyInternal(Assembly a, String[] args)
private int ExecuteAssembly(Assembly a, String[] args)
private Assembly[] GetAssemblies(bool refOnly)
public Assembly[] GetAssemblies()
public object GetData(string name)
public Type GetType()
public object InitializeLifetimeService()
internal Assembly LoadAssembly(string assemblyRef, Evidence securityEvidence, bool refOnly)
public Assembly Load(AssemblyName assemblyRef)
internal Assembly LoadSatellite(AssemblyName assemblyRef, bool throwOnError)
public Assembly Load(AssemblyName assemblyRef, Evidence assemblySecurity)
public Assembly Load(string assemblyString)
public Assembly Load(string assemblyString, Evidence assemblySecurity)
internal Assembly Load(string assemblyString, Evidence assemblySecurity, bool refonly)
public Assembly Load(Byte[] rawAssembly)
public Assembly Load(Byte[] rawAssembly, Byte[] rawSymbolStore)
internal Assembly LoadAssemblyRaw(Byte[] rawAssembly, Byte[] rawSymbolStore, Evidence securityEvidence, bool refonly)
public Assembly Load(Byte[] rawAssembly, Byte[] rawSymbolStore, Evidence securityEvidence)
internal Assembly Load(Byte[] rawAssembly, Byte[] rawSymbolStore, Evidence securityEvidence, bool refonly)
public void SetAppDomainPolicy(PolicyLevel domainPolicy)
public void SetCachePath(string path)
public void SetPrincipalPolicy(PrincipalPolicy policy)
public void SetShadowCopyFiles()
public void SetShadowCopyPath(string path)
public void SetThreadPrincipal(IPrincipal principal)
private AppDomain InternalSetDomainByID(int domain_id)
private AppDomain InternalSetDomain(AppDomain context)
internal void InternalPushDomainRef(AppDomain domain)
internal void InternalPushDomainRefByID(int domain_id)
internal void InternalPopDomainRef()
internal Context InternalSetContext(Context context)
internal Context InternalGetContext()
internal Context InternalGetDefaultContext()
internal string InternalGetProcessGuid(string newguid)
internal object InvokeInDomain(AppDomain domain, MethodInfo method, object obj, Object[] args)
internal object InvokeInDomainByID(int domain_id, MethodInfo method, object obj, Object[] args)
internal string GetProcessGuid()
public AppDomain CreateDomain(string friendlyName)
public AppDomain CreateDomain(string friendlyName, Evidence securityInfo)
private AppDomain createDomain(string friendlyName, AppDomainSetup info)
public AppDomain CreateDomain(string friendlyName, Evidence securityInfo, AppDomainSetup info)
public AppDomain CreateDomain(string friendlyName, Evidence securityInfo, string appBasePath, string appRelativeSearchPath, bool shadowCopyFiles)
public AppDomain CreateDomain(string friendlyName, Evidence securityInfo, AppDomainSetup info, PermissionSet grantSet, StrongName[] fullTrustAssemblies)
private AppDomainSetup CreateDomainSetup(string appBasePath, string appRelativeSearchPath, bool shadowCopyFiles)
private bool InternalIsFinalizingForUnload(int domain_id)
public bool IsFinalizingForUnload()
private void InternalUnload(int domain_id)
private int getDomainID()
public void Unload(AppDomain domain)
public void SetData(string name, object data)
public void SetData(string name, object data, IPermission permission)
public void SetDynamicBase(string path)
public int GetCurrentThreadId()
public string ToString()
private void ValidateAssemblyName(string name)
private void DoAssemblyLoad(Assembly assembly)
private Assembly DoAssemblyResolve(string name, Assembly requestingAssembly, bool refonly)
internal Assembly DoTypeResolve(object name_or_tb)
internal Assembly DoResourceResolve(string name, Assembly requesting)
private void DoDomainUnload()
internal void DoUnhandledException(Exception e)
internal void DoUnhandledException(UnhandledExceptionEventArgs args)
internal Byte[] GetMarshalledDomainObjRef()
internal void ProcessMessageInDomain(Byte[] arrRequest, CADMethodCallMessage cadMsg, Byte[]& arrResponse, CADMethodReturnMessage& cadMrm)
public void add_AssemblyLoad(AssemblyLoadEventHandler value)
public void remove_AssemblyLoad(AssemblyLoadEventHandler value)
public void add_AssemblyResolve(ResolveEventHandler value)
public void remove_AssemblyResolve(ResolveEventHandler value)
public void add_DomainUnload(EventHandler value)
public void remove_DomainUnload(EventHandler value)
public void add_ProcessExit(EventHandler value)
public void remove_ProcessExit(EventHandler value)
public void add_ResourceResolve(ResolveEventHandler value)
public void remove_ResourceResolve(ResolveEventHandler value)
public void add_TypeResolve(ResolveEventHandler value)
public void remove_TypeResolve(ResolveEventHandler value)
public void add_UnhandledException(UnhandledExceptionEventHandler value)
public void remove_UnhandledException(UnhandledExceptionEventHandler value)
public void add_FirstChanceException(EventHandler`1<FirstChanceExceptionEventArgs> value)
public void remove_FirstChanceException(EventHandler`1<FirstChanceExceptionEventArgs> value)
public bool get_IsHomogenous()
public bool get_IsFullyTrusted()
public AppDomainManager get_DomainManager()
public void add_ReflectionOnlyAssemblyResolve(ResolveEventHandler value)
public void remove_ReflectionOnlyAssemblyResolve(ResolveEventHandler value)
public ActivationContext get_ActivationContext()
public ApplicationIdentity get_ApplicationIdentity()
public int get_Id()
public string ApplyPolicy(string assemblyName)
public AppDomain CreateDomain(string friendlyName, Evidence securityInfo, string appBasePath, string appRelativeSearchPath, bool shadowCopyFiles, AppDomainInitializer adInit, String[] adInitArgs)
public int ExecuteAssemblyByName(string assemblyName)
public int ExecuteAssemblyByName(string assemblyName, Evidence assemblySecurity)
public int ExecuteAssemblyByName(string assemblyName, Evidence assemblySecurity, String[] args)
public int ExecuteAssemblyByName(AssemblyName assemblyName, Evidence assemblySecurity, String[] args)
public int ExecuteAssemblyByName(string assemblyName, String[] args)
public int ExecuteAssemblyByName(AssemblyName assemblyName, String[] args)
public bool IsDefaultAppDomain()
public Assembly[] ReflectionOnlyGetAssemblies()
private void System._AppDomain.GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId)
private void System._AppDomain.GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo)
private void System._AppDomain.GetTypeInfoCount(UInt32& pcTInfo)
private void System._AppDomain.Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr)
public Nullable`1<bool> IsCompatibilitySwitchSet(string value)
internal void SetCompatibilitySwitch(string value)
public bool get_MonitoringIsEnabled()
public void set_MonitoringIsEnabled(bool value)
public long get_MonitoringSurvivedMemorySize()
public long get_MonitoringSurvivedProcessMemorySize()
public long get_MonitoringTotalAllocatedMemorySize()
public TimeSpan get_MonitoringTotalProcessorTime()
}
public System.AppDomainInitializer : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(String[] args)
public IAsyncResult BeginInvoke(String[] args, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.AppDomainManager : MarshalByRefObject {
private ApplicationActivator _activator
private AppDomainManagerInitializationOptions _flags
public ApplicationActivator ApplicationActivator
public Assembly EntryAssembly
public HostExecutionContextManager HostExecutionContextManager
public HostSecurityManager HostSecurityManager
public AppDomainManagerInitializationOptions InitializationFlags
public ApplicationActivator get_ApplicationActivator()
public Assembly get_EntryAssembly()
public HostExecutionContextManager get_HostExecutionContextManager()
public HostSecurityManager get_HostSecurityManager()
public AppDomainManagerInitializationOptions get_InitializationFlags()
public void set_InitializationFlags(AppDomainManagerInitializationOptions value)
public AppDomain CreateDomain(string friendlyName, Evidence securityInfo, AppDomainSetup appDomainInfo)
public void InitializeNewDomain(AppDomainSetup appDomainInfo)
public bool CheckSecuritySettings(SecurityState state)
protected AppDomain CreateDomainHelper(string friendlyName, Evidence securityInfo, AppDomainSetup appDomainInfo)
}
public System.AppDomainManagerInitializationOptions : Enum {
public int value__
public AppDomainManagerInitializationOptions None
public AppDomainManagerInitializationOptions RegisterWithHost
}
public System.AppDomainSetup : object {
private string application_base
private string application_name
private string cache_path
private string configuration_file
private string dynamic_base
private string license_file
private string private_bin_path
private string private_bin_path_probe
private string shadow_copy_directories
private string shadow_copy_files
private bool publisher_policy
private bool path_changed
private LoaderOptimization loader_optimization
private bool disallow_binding_redirects
private bool disallow_code_downloads
private ActivationArguments _activationArguments
private AppDomainInitializer domain_initializer
private ApplicationTrust application_trust
private String[] domain_initializer_args
private bool disallow_appbase_probe
private Byte[] configuration_bytes
private Byte[] serialized_non_primitives
private string <TargetFrameworkName>k__BackingField
public string ApplicationBase
public string ApplicationName
public string CachePath
public string ConfigurationFile
public bool DisallowPublisherPolicy
public string DynamicBase
public string LicenseFile
public LoaderOptimization LoaderOptimization
public string PrivateBinPath
public string PrivateBinPathProbe
public string ShadowCopyDirectories
public string ShadowCopyFiles
public bool DisallowBindingRedirects
public bool DisallowCodeDownload
public string TargetFrameworkName
public ActivationArguments ActivationArguments
public AppDomainInitializer AppDomainInitializer
public String[] AppDomainInitializerArguments
public ApplicationTrust ApplicationTrust
public bool DisallowApplicationBaseProbing
public string AppDomainManagerAssembly
public string AppDomainManagerType
public String[] PartialTrustVisibleAssemblies
public bool SandboxInterop
internal void .ctor(AppDomainSetup setup)
public void .ctor(ActivationArguments activationArguments)
public void .ctor(ActivationContext activationContext)
private string GetAppBase(string appBase)
public string get_ApplicationBase()
public void set_ApplicationBase(string value)
public string get_ApplicationName()
public void set_ApplicationName(string value)
public string get_CachePath()
public void set_CachePath(string value)
public string get_ConfigurationFile()
public void set_ConfigurationFile(string value)
public bool get_DisallowPublisherPolicy()
public void set_DisallowPublisherPolicy(bool value)
public string get_DynamicBase()
public void set_DynamicBase(string value)
public string get_LicenseFile()
public void set_LicenseFile(string value)
public LoaderOptimization get_LoaderOptimization()
public void set_LoaderOptimization(LoaderOptimization value)
public string get_PrivateBinPath()
public void set_PrivateBinPath(string value)
public string get_PrivateBinPathProbe()
public void set_PrivateBinPathProbe(string value)
public string get_ShadowCopyDirectories()
public void set_ShadowCopyDirectories(string value)
public string get_ShadowCopyFiles()
public void set_ShadowCopyFiles(string value)
public bool get_DisallowBindingRedirects()
public void set_DisallowBindingRedirects(bool value)
public bool get_DisallowCodeDownload()
public void set_DisallowCodeDownload(bool value)
public string get_TargetFrameworkName()
public void set_TargetFrameworkName(string value)
public ActivationArguments get_ActivationArguments()
public void set_ActivationArguments(ActivationArguments value)
public AppDomainInitializer get_AppDomainInitializer()
public void set_AppDomainInitializer(AppDomainInitializer value)
public String[] get_AppDomainInitializerArguments()
public void set_AppDomainInitializerArguments(String[] value)
public ApplicationTrust get_ApplicationTrust()
public void set_ApplicationTrust(ApplicationTrust value)
public bool get_DisallowApplicationBaseProbing()
public void set_DisallowApplicationBaseProbing(bool value)
public Byte[] GetConfigurationBytes()
public void SetConfigurationBytes(Byte[] value)
private void DeserializeNonPrimitives()
internal void SerializeNonPrimitives()
public void SetCompatibilitySwitches(IEnumerable`1<string> switches)
public string get_AppDomainManagerAssembly()
public void set_AppDomainManagerAssembly(string value)
public string get_AppDomainManagerType()
public void set_AppDomainManagerType(string value)
public String[] get_PartialTrustVisibleAssemblies()
public void set_PartialTrustVisibleAssemblies(String[] value)
public bool get_SandboxInterop()
public void set_SandboxInterop(bool value)
public void SetNativeFunction(string functionName, int functionVersion, IntPtr functionPointer)
}
public System.AppDomainUnloadedException : SystemException {
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
protected void .ctor(SerializationInfo info, StreamingContext context)
}
public System.ApplicationException : Exception {
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
protected void .ctor(SerializationInfo info, StreamingContext context)
}
public System.ApplicationId : object {
private string m_name
private Version m_version
private string m_processorArchitecture
private string m_culture
internal Byte[] m_publicKeyToken
public Byte[] PublicKeyToken
public string Name
public Version Version
public string ProcessorArchitecture
public string Culture
public void .ctor(Byte[] publicKeyToken, string name, Version version, string processorArchitecture, string culture)
public Byte[] get_PublicKeyToken()
public string get_Name()
public Version get_Version()
public string get_ProcessorArchitecture()
public string get_Culture()
public ApplicationId Copy()
public string ToString()
public bool Equals(object o)
public int GetHashCode()
}
public System.ApplicationIdentity : object {
private string _fullName
private string _codeBase
public string CodeBase
public string FullName
public void .ctor(string applicationIdentityFullName)
public string get_CodeBase()
public string get_FullName()
public string ToString()
private void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context)
}
public System.ArgIterator : ValueType {
private IntPtr sig
private IntPtr args
private int next_arg
private int num_args
private void Setup(IntPtr argsp, IntPtr start)
public void .ctor(RuntimeArgumentHandle arglist)
public void .ctor(RuntimeArgumentHandle arglist, Void* ptr)
public void End()
public bool Equals(object o)
public int GetHashCode()
public TypedReference GetNextArg()
private TypedReference IntGetNextArg()
public TypedReference GetNextArg(RuntimeTypeHandle rth)
private TypedReference IntGetNextArg(IntPtr rth)
public RuntimeTypeHandle GetNextArgType()
private IntPtr IntGetNextArgType()
public int GetRemainingCount()
}
public System.ArgumentException : SystemException {
private string m_paramName
public string Message
public string ParamName
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
public void .ctor(string message, string paramName, Exception innerException)
public void .ctor(string message, string paramName)
protected void .ctor(SerializationInfo info, StreamingContext context)
public string get_Message()
public string get_ParamName()
public void GetObjectData(SerializationInfo info, StreamingContext context)
}
public System.ArgumentNullException : ArgumentException {
public void .ctor(string paramName)
public void .ctor(string message, Exception innerException)
public void .ctor(string paramName, string message)
protected void .ctor(SerializationInfo info, StreamingContext context)
}
public System.ArgumentOutOfRangeException : ArgumentException {
private String modreq(System.Runtime.CompilerServices.IsVolatile) _rangeMessage
private object m_actualValue
private string RangeMessage
public string Message
public object ActualValue
private string get_RangeMessage()
public void .ctor(string paramName)
public void .ctor(string paramName, string message)
public void .ctor(string message, Exception innerException)
public void .ctor(string paramName, object actualValue, string message)
public string get_Message()
public object get_ActualValue()
public void GetObjectData(SerializationInfo info, StreamingContext context)
protected void .ctor(SerializationInfo info, StreamingContext context)
}
public System.ArithmeticException : SystemException {
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
protected void .ctor(SerializationInfo info, StreamingContext context)
}
public System.Array : object {
private int System.Collections.ICollection.Count
private bool System.Collections.IList.IsReadOnly
private object System.Collections.IList.Item
public long LongLength
public bool IsFixedSize
public bool IsReadOnly
public bool IsSynchronized
public object SyncRoot
public int Length
public int Rank
public Array CreateInstance(Type elementType, Int64[] lengths)
public ReadOnlyCollection`1<T> AsReadOnly(T[] array)
public void Resize(T[]& array, int newSize)
private int System.Collections.ICollection.get_Count()
private bool System.Collections.IList.get_IsReadOnly()
private object System.Collections.IList.get_Item(int index)
private void System.Collections.IList.set_Item(int index, object value)
private int System.Collections.IList.Add(object value)
private bool System.Collections.IList.Contains(object value)
private void System.Collections.IList.Clear()
private int System.Collections.IList.IndexOf(object value)
private void System.Collections.IList.Insert(int index, object value)
private void System.Collections.IList.Remove(object value)
private void System.Collections.IList.RemoveAt(int index)
public void CopyTo(Array array, int index)
public object Clone()
private int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer)
private bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer)
internal int CombineHashCodes(int h1, int h2)
private int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer)
public int BinarySearch(Array array, object value)
public TOutput[] ConvertAll(TInput[] array, Converter`2<TInput, TOutput> converter)
public void Copy(Array sourceArray, Array destinationArray, long length)
public void Copy(Array sourceArray, long sourceIndex, Array destinationArray, long destinationIndex, long length)
public void CopyTo(Array array, long index)
public void ForEach(T[] array, Action`1<T> action)
public long get_LongLength()
public long GetLongLength(int dimension)
public object GetValue(long index)
public object GetValue(long index1, long index2)
public object GetValue(long index1, long index2, long index3)
public object GetValue(Int64[] indices)
public bool get_IsFixedSize()
public bool get_IsReadOnly()
public bool get_IsSynchronized()
public object get_SyncRoot()
public int BinarySearch(Array array, int index, int length, object value)
public int BinarySearch(Array array, object value, IComparer comparer)
public int BinarySearch(Array array, int index, int length, object value, IComparer comparer)
private int GetMedian(int low, int hi)
public int BinarySearch(T[] array, T value)
public int BinarySearch(T[] array, T value, IComparer`1<T> comparer)
public int BinarySearch(T[] array, int index, int length, T value)
public int BinarySearch(T[] array, int index, int length, T value, IComparer`1<T> comparer)
public int IndexOf(Array array, object value)
public int IndexOf(Array array, object value, int startIndex)
public int IndexOf(Array array, object value, int startIndex, int count)
public int IndexOf(T[] array, T value)
public int IndexOf(T[] array, T value, int startIndex)
public int IndexOf(T[] array, T value, int startIndex, int count)
public int LastIndexOf(Array array, object value)
public int LastIndexOf(Array array, object value, int startIndex)
public int LastIndexOf(Array array, object value, int startIndex, int count)
public int LastIndexOf(T[] array, T value)
public int LastIndexOf(T[] array, T value, int startIndex)
public int LastIndexOf(T[] array, T value, int startIndex, int count)
public void Reverse(Array array)
public void Reverse(Array array, int index, int length)
public void Reverse(T[] array)
public void Reverse(T[] array, int index, int length)
public void SetValue(object value, long index)
public void SetValue(object value, long index1, long index2)
public void SetValue(object value, long index1, long index2, long index3)
public void SetValue(object value, Int64[] indices)
public void Sort(Array array)
public void Sort(Array array, int index, int length)
public void Sort(Array array, IComparer comparer)
public void Sort(Array array, int index, int length, IComparer comparer)
public void Sort(Array keys, Array items)
public void Sort(Array keys, Array items, IComparer comparer)
public void Sort(Array keys, Array items, int index, int length)
public void Sort(Array keys, Array items, int index, int length, IComparer comparer)
public void Sort(T[] array)
public void Sort(T[] array, int index, int length)
public void Sort(T[] array, IComparer`1<T> comparer)
public void Sort(T[] array, int index, int length, IComparer`1<T> comparer)
public void Sort(T[] array, Comparison`1<T> comparison)
public void Sort(TKey[] keys, TValue[] items)
public void Sort(TKey[] keys, TValue[] items, int index, int length)
public void Sort(TKey[] keys, TValue[] items, IComparer`1<TKey> comparer)
public void Sort(TKey[] keys, TValue[] items, int index, int length, IComparer`1<TKey> comparer)
public bool Exists(T[] array, Predicate`1<T> match)
public void Fill(T[] array, T value)
public void Fill(T[] array, T value, int startIndex, int count)
public T Find(T[] array, Predicate`1<T> match)
public T[] FindAll(T[] array, Predicate`1<T> match)
public int FindIndex(T[] array, Predicate`1<T> match)
public int FindIndex(T[] array, int startIndex, Predicate`1<T> match)
public int FindIndex(T[] array, int startIndex, int count, Predicate`1<T> match)
public T FindLast(T[] array, Predicate`1<T> match)
public int FindLastIndex(T[] array, Predicate`1<T> match)
public int FindLastIndex(T[] array, int startIndex, Predicate`1<T> match)
public int FindLastIndex(T[] array, int startIndex, int count, Predicate`1<T> match)
public bool TrueForAll(T[] array, Predicate`1<T> match)
public IEnumerator GetEnumerator()
internal int InternalArray__ICollection_get_Count()
internal bool InternalArray__ICollection_get_IsReadOnly()
internal IEnumerator`1<T> InternalArray__IEnumerable_GetEnumerator()
internal void InternalArray__ICollection_Clear()
internal void InternalArray__ICollection_Add(T item)
internal bool InternalArray__ICollection_Remove(T item)
internal bool InternalArray__ICollection_Contains(T item)
internal void InternalArray__ICollection_CopyTo(T[] array, int arrayIndex)
internal T InternalArray__IReadOnlyList_get_Item(int index)
internal int InternalArray__IReadOnlyCollection_get_Count()
internal void InternalArray__Insert(int index, T item)
internal void InternalArray__RemoveAt(int index)
internal int InternalArray__IndexOf(T item)
internal T InternalArray__get_Item(int index)
internal void InternalArray__set_Item(int index, T item)
internal void GetGenericValueImpl(int pos, T& value)
internal void SetGenericValueImpl(int pos, T& value)
public int get_Length()
public int get_Rank()
private int GetRank()
public int GetLength(int dimension)
public int GetLowerBound(int dimension)
public object GetValue(Int32[] indices)
public void SetValue(object value, Int32[] indices)
internal object GetValueImpl(int pos)
internal void SetValueImpl(object value, int pos)
internal bool FastCopy(Array source, int source_idx, Array dest, int dest_idx, int length)
internal Array CreateInstanceImpl(Type elementType, Int32[] lengths, Int32[] bounds)
public int GetUpperBound(int dimension)
public object GetValue(int index)
public object GetValue(int index1, int index2)
public object GetValue(int index1, int index2, int index3)
public void SetValue(object value, int index)
public void SetValue(object value, int index1, int index2)
public void SetValue(object value, int index1, int index2, int index3)
internal Array UnsafeCreateInstance(Type elementType, Int32[] lengths, Int32[] lowerBounds)
internal Array UnsafeCreateInstance(Type elementType, int length1, int length2)
internal Array UnsafeCreateInstance(Type elementType, Int32[] lengths)
public Array CreateInstance(Type elementType, int length)
public Array CreateInstance(Type elementType, int length1, int length2)
public Array CreateInstance(Type elementType, int length1, int length2, int length3)
public Array CreateInstance(Type elementType, Int32[] lengths)
public Array CreateInstance(Type elementType, Int32[] lengths, Int32[] lowerBounds)
public void Clear(Array array, int index, int length)
private void ClearInternal(Array a, int index, int count)
public void Copy(Array sourceArray, Array destinationArray, int length)
public void Copy(Array sourceArray, int sourceIndex, Array destinationArray, int destinationIndex, int length)
private Exception CreateArrayTypeMismatchException()
private bool CanAssignArrayElement(Type source, Type target)
public void ConstrainedCopy(Array sourceArray, int sourceIndex, Array destinationArray, int destinationIndex, int length)
public T[] Empty()
public void Initialize()
private int IndexOfImpl(T[] array, T value, int startIndex, int count)
private int LastIndexOfImpl(T[] array, T value, int startIndex, int count)
private void SortImpl(Array keys, Array items, int index, int length, IComparer comparer)
internal T UnsafeLoad(T[] array, int index)
internal void UnsafeStore(T[] array, int index, T value)
internal R UnsafeMov(S instance)
}
internal System.Array_ReferenceSources : object {
internal int MaxArrayLength
internal int MaxByteArrayLength
}
public System.ArraySegment`1 : ValueType {
private T[] _array
private int _offset
private int _count
public T[] Array
public int Offset
public int Count
private T System.Collections.Generic.IList<T>.Item
private T System.Collections.Generic.IReadOnlyList<T>.Item
private bool System.Collections.Generic.ICollection<T>.IsReadOnly
public void .ctor(T[] array)
public void .ctor(T[] array, int offset, int count)
public T[] get_Array()
public int get_Offset()
public int get_Count()
public int GetHashCode()
public bool Equals(object obj)
public bool Equals(ArraySegment`1<T> obj)
public bool op_Equality(ArraySegment`1<T> a, ArraySegment`1<T> b)
public bool op_Inequality(ArraySegment`1<T> a, ArraySegment`1<T> b)
private T System.Collections.Generic.IList<T>.get_Item(int index)
private void System.Collections.Generic.IList<T>.set_Item(int index, T value)
private int System.Collections.Generic.IList<T>.IndexOf(T item)
private void System.Collections.Generic.IList<T>.Insert(int index, T item)
private void System.Collections.Generic.IList<T>.RemoveAt(int index)
private T System.Collections.Generic.IReadOnlyList<T>.get_Item(int index)
private bool System.Collections.Generic.ICollection<T>.get_IsReadOnly()
private void System.Collections.Generic.ICollection<T>.Add(T item)
private void System.Collections.Generic.ICollection<T>.Clear()
private bool System.Collections.Generic.ICollection<T>.Contains(T item)
private void System.Collections.Generic.ICollection<T>.CopyTo(T[] array, int arrayIndex)
private bool System.Collections.Generic.ICollection<T>.Remove(T item)
private IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
}
internal System.ArraySpec : object {
private int dimensions
private bool bound
public int Rank
public bool IsBound
internal void .ctor(int dimensions, bool bound)
public Type Resolve(Type type)
public StringBuilder Append(StringBuilder sb)
public string ToString()
public int get_Rank()
public bool get_IsBound()
}
public System.ArrayTypeMismatchException : SystemException {
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
protected void .ctor(SerializationInfo info, StreamingContext context)
}
public System.AssemblyLoadEventArgs : EventArgs {
private Assembly m_loadedAssembly
public Assembly LoadedAssembly
public void .ctor(Assembly loadedAssembly)
public Assembly get_LoadedAssembly()
}
public System.AssemblyLoadEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, AssemblyLoadEventArgs args)
public IAsyncResult BeginInvoke(object sender, AssemblyLoadEventArgs args, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.AsyncCallback : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(IAsyncResult ar)
public IAsyncResult BeginInvoke(IAsyncResult ar, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.Attribute : object {
public object TypeId
private Attribute[] InternalGetCustomAttributes(PropertyInfo element, Type type, bool inherit)
private Attribute[] InternalGetCustomAttributes(EventInfo element, Type type, bool inherit)
private Attribute[] InternalParamGetCustomAttributes(ParameterInfo parameter, Type attributeType, bool inherit)
private bool InternalIsDefined(PropertyInfo element, Type attributeType, bool inherit)
private bool InternalIsDefined(EventInfo element, Type attributeType, bool inherit)
private bool InternalParamIsDefined(ParameterInfo parameter, Type attributeType, bool inherit)
public Attribute[] GetCustomAttributes(MemberInfo element, Type type)
public Attribute[] GetCustomAttributes(MemberInfo element, Type type, bool inherit)
public Attribute[] GetCustomAttributes(MemberInfo element)
public Attribute[] GetCustomAttributes(MemberInfo element, bool inherit)
public bool IsDefined(MemberInfo element, Type attributeType)
public bool IsDefined(MemberInfo element, Type attributeType, bool inherit)
public Attribute GetCustomAttribute(MemberInfo element, Type attributeType)
public Attribute GetCustomAttribute(MemberInfo element, Type attributeType, bool inherit)
public Attribute[] GetCustomAttributes(ParameterInfo element)
public Attribute[] GetCustomAttributes(ParameterInfo element, Type attributeType)
public Attribute[] GetCustomAttributes(ParameterInfo element, Type attributeType, bool inherit)
public Attribute[] GetCustomAttributes(ParameterInfo element, bool inherit)
public bool IsDefined(ParameterInfo element, Type attributeType)
public bool IsDefined(ParameterInfo element, Type attributeType, bool inherit)
public Attribute GetCustomAttribute(ParameterInfo element, Type attributeType)
public Attribute GetCustomAttribute(ParameterInfo element, Type attributeType, bool inherit)
public Attribute[] GetCustomAttributes(Module element, Type attributeType)
public Attribute[] GetCustomAttributes(Module element)
public Attribute[] GetCustomAttributes(Module element, bool inherit)
public Attribute[] GetCustomAttributes(Module element, Type attributeType, bool inherit)
public bool IsDefined(Module element, Type attributeType)
public bool IsDefined(Module element, Type attributeType, bool inherit)
public Attribute GetCustomAttribute(Module element, Type attributeType)
public Attribute GetCustomAttribute(Module element, Type attributeType, bool inherit)
public Attribute[] GetCustomAttributes(Assembly element, Type attributeType)
public Attribute[] GetCustomAttributes(Assembly element, Type attributeType, bool inherit)
public Attribute[] GetCustomAttributes(Assembly element)
public Attribute[] GetCustomAttributes(Assembly element, bool inherit)
public bool IsDefined(Assembly element, Type attributeType)
public bool IsDefined(Assembly element, Type attributeType, bool inherit)
public Attribute GetCustomAttribute(Assembly element, Type attributeType)
public Attribute GetCustomAttribute(Assembly element, Type attributeType, bool inherit)
public bool Equals(object obj)
private bool AreFieldValuesEqual(object thisValue, object thatValue)
public int GetHashCode()
public object get_TypeId()
public bool Match(object obj)
public bool IsDefaultAttribute()
private void System.Runtime.InteropServices._Attribute.GetTypeInfoCount(UInt32& pcTInfo)
private void System.Runtime.InteropServices._Attribute.GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo)
private void System.Runtime.InteropServices._Attribute.GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId)
private void System.Runtime.InteropServices._Attribute.Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr)
}
public System.AttributeTargets : Enum {
public int value__
public AttributeTargets Assembly
public AttributeTargets Module
public AttributeTargets Class
public AttributeTargets Struct
public AttributeTargets Enum
public AttributeTargets Constructor
public AttributeTargets Method
public AttributeTargets Property
public AttributeTargets Field
public AttributeTargets Event
public AttributeTargets Interface
public AttributeTargets Parameter
public AttributeTargets Delegate
public AttributeTargets ReturnValue
public AttributeTargets GenericParameter
public AttributeTargets All
}
public System.AttributeUsageAttribute : Attribute {
internal AttributeTargets m_attributeTarget
internal bool m_allowMultiple
internal bool m_inherited
internal AttributeUsageAttribute Default
public AttributeTargets ValidOn
public bool AllowMultiple
public bool Inherited
public void .ctor(AttributeTargets validOn)
internal void .ctor(AttributeTargets validOn, bool allowMultiple, bool inherited)
public AttributeTargets get_ValidOn()
public bool get_AllowMultiple()
public void set_AllowMultiple(bool value)
public bool get_Inherited()
public void set_Inherited(bool value)
}
public System.BadImageFormatException : SystemException {
private string _fileName
private string _fusionLog
public string Message
public string FileName
public string FusionLog
public void .ctor(string message)
public void .ctor(string message, Exception inner)
public void .ctor(string message, string fileName)
public void .ctor(string message, string fileName, Exception inner)
public string get_Message()
private void SetMessageField()
public string get_FileName()
public string ToString()
protected void .ctor(SerializationInfo info, StreamingContext context)
private void .ctor(string fileName, string fusionLog, int hResult)
public string get_FusionLog()
public void GetObjectData(SerializationInfo info, StreamingContext context)
}
public System.Base64FormattingOptions : Enum {
public int value__
public Base64FormattingOptions None
public Base64FormattingOptions InsertLineBreaks
}
internal System.BCLDebug : object {
public void Assert(bool condition, string message)
internal void Correctness(bool expr, string msg)
public void Log(string message)
public void Log(string switchName, string message)
public void Log(string switchName, LogLevel level, Object[] messages)
internal void Perf(bool expr, string msg)
public void Trace(string switchName, Object[] messages)
internal bool CheckEnabled(string switchName)
}
public System.BitConverter : object {
public bool IsLittleEndian
private bool AmILittleEndian()
public Byte[] GetBytes(bool value)
public Byte[] GetBytes(char value)
public Byte[] GetBytes(short value)
public Byte[] GetBytes(int value)
public Byte[] GetBytes(long value)
public Byte[] GetBytes(ushort value)
public Byte[] GetBytes(UInt32 value)
public Byte[] GetBytes(ulong value)
public Byte[] GetBytes(float value)
public Byte[] GetBytes(double value)
public char ToChar(Byte[] value, int startIndex)
public short ToInt16(Byte[] value, int startIndex)
public int ToInt32(Byte[] value, int startIndex)
public long ToInt64(Byte[] value, int startIndex)
public ushort ToUInt16(Byte[] value, int startIndex)
public UInt32 ToUInt32(Byte[] value, int startIndex)
public ulong ToUInt64(Byte[] value, int startIndex)
public float ToSingle(Byte[] value, int startIndex)
public double ToDouble(Byte[] value, int startIndex)
private char GetHexValue(int i)
public string ToString(Byte[] value, int startIndex, int length)
public string ToString(Byte[] value)
public string ToString(Byte[] value, int startIndex)
public bool ToBoolean(Byte[] value, int startIndex)
public long DoubleToInt64Bits(double value)
public double Int64BitsToDouble(long value)
}
public System.Boolean : ValueType {
private bool m_value
internal int True
internal int False
internal string TrueLiteral
internal string FalseLiteral
public string TrueString
public string FalseString
public int GetHashCode()
public string ToString()
public string ToString(IFormatProvider provider)
public bool Equals(object obj)
public bool Equals(bool obj)
public int CompareTo(object obj)
public int CompareTo(bool value)
public bool Parse(string value)
public bool TryParse(string value, Boolean& result)
private string TrimWhiteSpaceAndNull(string value)
public TypeCode GetTypeCode()
private bool System.IConvertible.ToBoolean(IFormatProvider provider)
private char System.IConvertible.ToChar(IFormatProvider provider)
private sbyte System.IConvertible.ToSByte(IFormatProvider provider)
private byte System.IConvertible.ToByte(IFormatProvider provider)
private short System.IConvertible.ToInt16(IFormatProvider provider)
private ushort System.IConvertible.ToUInt16(IFormatProvider provider)
private int System.IConvertible.ToInt32(IFormatProvider provider)
private UInt32 System.IConvertible.ToUInt32(IFormatProvider provider)
private long System.IConvertible.ToInt64(IFormatProvider provider)
private ulong System.IConvertible.ToUInt64(IFormatProvider provider)
private float System.IConvertible.ToSingle(IFormatProvider provider)
private double System.IConvertible.ToDouble(IFormatProvider provider)
private decimal System.IConvertible.ToDecimal(IFormatProvider provider)
private DateTime System.IConvertible.ToDateTime(IFormatProvider provider)
private object System.IConvertible.ToType(Type type, IFormatProvider provider)
}
internal System.BRECORD : ValueType {
private IntPtr pvRecord
private IntPtr pRecInfo
}
public System.Buffer : object {
internal bool InternalBlockCopy(Array src, int srcOffsetBytes, Array dst, int dstOffsetBytes, int byteCount)
internal int IndexOfByte(Byte* src, byte value, int index, int count)
private byte _GetByte(Array array, int index)
private void _SetByte(Array array, int index, byte value)
private int _ByteLength(Array array)
internal void ZeroMemory(Byte* src, long len)
internal void Memcpy(Byte[] dest, int destIndex, Byte* src, int srcIndex, int len)
internal void Memcpy(Byte* pDest, int destIndex, Byte[] src, int srcIndex, int len)
public int ByteLength(Array array)
public byte GetByte(Array array, int index)
public void SetByte(Array array, int index, byte value)
public void BlockCopy(Array src, int srcOffset, Array dst, int dstOffset, int count)
public void MemoryCopy(Void* source, Void* destination, long destinationSizeInBytes, long sourceBytesToCopy)
public void MemoryCopy(Void* source, Void* destination, ulong destinationSizeInBytes, ulong sourceBytesToCopy)
internal void memcpy4(Byte* dest, Byte* src, int size)
internal void memcpy2(Byte* dest, Byte* src, int size)
private void memcpy1(Byte* dest, Byte* src, int size)
internal void Memcpy(Byte* dest, Byte* src, int size)
}
public System.Buffers.Binary.BinaryPrimitives : object {
public sbyte ReverseEndianness(sbyte value)
public short ReverseEndianness(short value)
public int ReverseEndianness(int value)
public long ReverseEndianness(long value)
public byte ReverseEndianness(byte value)
public ushort ReverseEndianness(ushort value)
public UInt32 ReverseEndianness(UInt32 value)
public ulong ReverseEndianness(ulong value)
public T ReadMachineEndian(ReadOnlySpan`1<byte> buffer)
public bool TryReadMachineEndian(ReadOnlySpan`1<byte> buffer, T& value)
public short ReadInt16BigEndian(ReadOnlySpan`1<byte> buffer)
public int ReadInt32BigEndian(ReadOnlySpan`1<byte> buffer)
public long ReadInt64BigEndian(ReadOnlySpan`1<byte> buffer)
public ushort ReadUInt16BigEndian(ReadOnlySpan`1<byte> buffer)
public UInt32 ReadUInt32BigEndian(ReadOnlySpan`1<byte> buffer)
public ulong ReadUInt64BigEndian(ReadOnlySpan`1<byte> buffer)
public bool TryReadInt16BigEndian(ReadOnlySpan`1<byte> buffer, Int16& value)
public bool TryReadInt32BigEndian(ReadOnlySpan`1<byte> buffer, Int32& value)
public bool TryReadInt64BigEndian(ReadOnlySpan`1<byte> buffer, Int64& value)
public bool TryReadUInt16BigEndian(ReadOnlySpan`1<byte> buffer, UInt16& value)
public bool TryReadUInt32BigEndian(ReadOnlySpan`1<byte> buffer, UInt32& value)
public bool TryReadUInt64BigEndian(ReadOnlySpan`1<byte> buffer, UInt64& value)
public short ReadInt16LittleEndian(ReadOnlySpan`1<byte> buffer)
public int ReadInt32LittleEndian(ReadOnlySpan`1<byte> buffer)
public long ReadInt64LittleEndian(ReadOnlySpan`1<byte> buffer)
public ushort ReadUInt16LittleEndian(ReadOnlySpan`1<byte> buffer)
public UInt32 ReadUInt32LittleEndian(ReadOnlySpan`1<byte> buffer)
public ulong ReadUInt64LittleEndian(ReadOnlySpan`1<byte> buffer)
public bool TryReadInt16LittleEndian(ReadOnlySpan`1<byte> buffer, Int16& value)
public bool TryReadInt32LittleEndian(ReadOnlySpan`1<byte> buffer, Int32& value)
public bool TryReadInt64LittleEndian(ReadOnlySpan`1<byte> buffer, Int64& value)
public bool TryReadUInt16LittleEndian(ReadOnlySpan`1<byte> buffer, UInt16& value)
public bool TryReadUInt32LittleEndian(ReadOnlySpan`1<byte> buffer, UInt32& value)
public bool TryReadUInt64LittleEndian(ReadOnlySpan`1<byte> buffer, UInt64& value)
public void WriteMachineEndian(Span`1<byte> buffer, T& value)
public bool TryWriteMachineEndian(Span`1<byte> buffer, T& value)
public void WriteInt16BigEndian(Span`1<byte> buffer, short value)
public void WriteInt32BigEndian(Span`1<byte> buffer, int value)
public void WriteInt64BigEndian(Span`1<byte> buffer, long value)
public void WriteUInt16BigEndian(Span`1<byte> buffer, ushort value)
public void WriteUInt32BigEndian(Span`1<byte> buffer, UInt32 value)
public void WriteUInt64BigEndian(Span`1<byte> buffer, ulong value)
public bool TryWriteInt16BigEndian(Span`1<byte> buffer, short value)
public bool TryWriteInt32BigEndian(Span`1<byte> buffer, int value)
public bool TryWriteInt64BigEndian(Span`1<byte> buffer, long value)
public bool TryWriteUInt16BigEndian(Span`1<byte> buffer, ushort value)
public bool TryWriteUInt32BigEndian(Span`1<byte> buffer, UInt32 value)
public bool TryWriteUInt64BigEndian(Span`1<byte> buffer, ulong value)
public void WriteInt16LittleEndian(Span`1<byte> buffer, short value)
public void WriteInt32LittleEndian(Span`1<byte> buffer, int value)
public void WriteInt64LittleEndian(Span`1<byte> buffer, long value)
public void WriteUInt16LittleEndian(Span`1<byte> buffer, ushort value)
public void WriteUInt32LittleEndian(Span`1<byte> buffer, UInt32 value)
public void WriteUInt64LittleEndian(Span`1<byte> buffer, ulong value)
public bool TryWriteInt16LittleEndian(Span`1<byte> buffer, short value)
public bool TryWriteInt32LittleEndian(Span`1<byte> buffer, int value)
public bool TryWriteInt64LittleEndian(Span`1<byte> buffer, long value)
public bool TryWriteUInt16LittleEndian(Span`1<byte> buffer, ushort value)
public bool TryWriteUInt32LittleEndian(Span`1<byte> buffer, UInt32 value)
public bool TryWriteUInt64LittleEndian(Span`1<byte> buffer, ulong value)
}
public System.Buffers.IRetainable {
public void Retain()
public bool Release()
}
public System.Buffers.MemoryHandle : ValueType {
private IRetainable _retainable
private Void* _pointer
private GCHandle _handle
public Void* PinnedPointer
public void .ctor(IRetainable retainable, Void* pinnedPointer, GCHandle handle)
public Void* get_PinnedPointer()
internal void AddOffset(int offset)
public void Dispose()
}
public System.Buffers.OwnedMemory`1 : object {
public int Length
public Span`1<T> Span
public Memory`1<T> Memory
protected bool IsRetained
public bool IsDisposed
public int get_Length()
public Span`1<T> get_Span()
public Memory`1<T> get_Memory()
public MemoryHandle Pin()
protected internal bool TryGetArray(ArraySegment`1& arraySegment)
public void Dispose()
protected void Dispose(bool disposing)
protected bool get_IsRetained()
public bool get_IsDisposed()
public void Retain()
public bool Release()
}
public System.Byte : ValueType {
private byte m_value
public byte MaxValue
public byte MinValue
public int CompareTo(object value)
public int CompareTo(byte value)
public bool Equals(object obj)
public bool Equals(byte obj)
public int GetHashCode()
public byte Parse(string s)
public byte Parse(string s, NumberStyles style)
public byte Parse(string s, IFormatProvider provider)
public byte Parse(string s, NumberStyles style, IFormatProvider provider)
private byte Parse(string s, NumberStyles style, NumberFormatInfo info)
public bool TryParse(string s, Byte& result)
public bool TryParse(string s, NumberStyles style, IFormatProvider provider, Byte& result)
private bool TryParse(string s, NumberStyles style, NumberFormatInfo info, Byte& result)
public string ToString()
public string ToString(string format)
public string ToString(IFormatProvider provider)
public string ToString(string format, IFormatProvider provider)
public TypeCode GetTypeCode()
private bool System.IConvertible.ToBoolean(IFormatProvider provider)
private char System.IConvertible.ToChar(IFormatProvider provider)
private sbyte System.IConvertible.ToSByte(IFormatProvider provider)
private byte System.IConvertible.ToByte(IFormatProvider provider)
private short System.IConvertible.ToInt16(IFormatProvider provider)
private ushort System.IConvertible.ToUInt16(IFormatProvider provider)
private int System.IConvertible.ToInt32(IFormatProvider provider)
private UInt32 System.IConvertible.ToUInt32(IFormatProvider provider)
private long System.IConvertible.ToInt64(IFormatProvider provider)
private ulong System.IConvertible.ToUInt64(IFormatProvider provider)
private float System.IConvertible.ToSingle(IFormatProvider provider)
private double System.IConvertible.ToDouble(IFormatProvider provider)
private decimal System.IConvertible.ToDecimal(IFormatProvider provider)
private DateTime System.IConvertible.ToDateTime(IFormatProvider provider)
private object System.IConvertible.ToType(Type type, IFormatProvider provider)
}
internal System.ByteMatcher : object {
private Hashtable map
private Hashtable starts
public void AddMapping(TermInfoStrings key, Byte[] val)
public void Sort()
public bool StartsWith(int c)
public TermInfoStrings Match(Char[] buffer, int offset, int length, Int32& used)
}
public System.CannotUnloadAppDomainException : SystemException {
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
protected void .ctor(SerializationInfo info, StreamingContext context)
}
public System.Char : ValueType {
internal char m_value
public char MaxValue
public char MinValue
private Byte[] categoryForLatin1
internal int UNICODE_PLANE00_END
internal int UNICODE_PLANE01_START
internal int UNICODE_PLANE16_END
internal int HIGH_SURROGATE_START
internal int LOW_SURROGATE_END
private bool IsLatin1(char ch)
private bool IsAscii(char ch)
private UnicodeCategory GetLatin1UnicodeCategory(char ch)
public int GetHashCode()
public bool Equals(object obj)
public bool Equals(char obj)
public int CompareTo(object value)
public int CompareTo(char value)
public string ToString()
public string ToString(IFormatProvider provider)
public string ToString(char c)
public char Parse(string s)
public bool TryParse(string s, Char& result)
public bool IsDigit(char c)
internal bool CheckLetter(UnicodeCategory uc)
public bool IsLetter(char c)
private bool IsWhiteSpaceLatin1(char c)
public bool IsWhiteSpace(char c)
public bool IsUpper(char c)
public bool IsLower(char c)
internal bool CheckPunctuation(UnicodeCategory uc)
public bool IsPunctuation(char c)
internal bool CheckLetterOrDigit(UnicodeCategory uc)
public bool IsLetterOrDigit(char c)
public char ToUpper(char c, CultureInfo culture)
public char ToUpper(char c)
public char ToUpperInvariant(char c)
public char ToLower(char c, CultureInfo culture)
public char ToLower(char c)
public char ToLowerInvariant(char c)
public TypeCode GetTypeCode()
private bool System.IConvertible.ToBoolean(IFormatProvider provider)
private char System.IConvertible.ToChar(IFormatProvider provider)
private sbyte System.IConvertible.ToSByte(IFormatProvider provider)
private byte System.IConvertible.ToByte(IFormatProvider provider)
private short System.IConvertible.ToInt16(IFormatProvider provider)
private ushort System.IConvertible.ToUInt16(IFormatProvider provider)
private int System.IConvertible.ToInt32(IFormatProvider provider)
private UInt32 System.IConvertible.ToUInt32(IFormatProvider provider)
private long System.IConvertible.ToInt64(IFormatProvider provider)
private ulong System.IConvertible.ToUInt64(IFormatProvider provider)
private float System.IConvertible.ToSingle(IFormatProvider provider)
private double System.IConvertible.ToDouble(IFormatProvider provider)
private decimal System.IConvertible.ToDecimal(IFormatProvider provider)
private DateTime System.IConvertible.ToDateTime(IFormatProvider provider)
private object System.IConvertible.ToType(Type type, IFormatProvider provider)
public bool IsControl(char c)
public bool IsControl(string s, int index)
public bool IsDigit(string s, int index)
public bool IsLetter(string s, int index)
public bool IsLetterOrDigit(string s, int index)
public bool IsLower(string s, int index)
internal bool CheckNumber(UnicodeCategory uc)
public bool IsNumber(char c)
public bool IsNumber(string s, int index)
public bool IsPunctuation(string s, int index)
internal bool CheckSeparator(UnicodeCategory uc)
private bool IsSeparatorLatin1(char c)
public bool IsSeparator(char c)
public bool IsSeparator(string s, int index)
public bool IsSurrogate(char c)
public bool IsSurrogate(string s, int index)
internal bool CheckSymbol(UnicodeCategory uc)
public bool IsSymbol(char c)
public bool IsSymbol(string s, int index)
public bool IsUpper(string s, int index)
public bool IsWhiteSpace(string s, int index)
public UnicodeCategory GetUnicodeCategory(char c)
public UnicodeCategory GetUnicodeCategory(string s, int index)
public double GetNumericValue(char c)
public double GetNumericValue(string s, int index)
public bool IsHighSurrogate(char c)
public bool IsHighSurrogate(string s, int index)
public bool IsLowSurrogate(char c)
public bool IsLowSurrogate(string s, int index)
public bool IsSurrogatePair(string s, int index)
public bool IsSurrogatePair(char highSurrogate, char lowSurrogate)
public string ConvertFromUtf32(int utf32)
public int ConvertToUtf32(char highSurrogate, char lowSurrogate)
public int ConvertToUtf32(string s, int index)
}
public System.CharEnumerator : object {
private string str
private int index
private char currentElement
private object System.Collections.IEnumerator.Current
public char Current
internal void .ctor(string str)
public object Clone()
public bool MoveNext()
public void Dispose()
private object System.Collections.IEnumerator.get_Current()
public char get_Current()
public void Reset()
}
internal System.CharInfo : ValueType {
public char Character
public short Attributes
}
internal System.CLRConfig : object {
internal bool CheckLegacyManagedDeflateStream()
internal bool CheckThrowUnobservedTaskExceptions()
}
public System.CLSCompliantAttribute : Attribute {
private bool m_compliant
public bool IsCompliant
public void .ctor(bool isCompliant)
public bool get_IsCompliant()
}
public System.Collections.ArrayList : object {
private Object[] _items
private int _size
private int _version
private object _syncRoot
private int _defaultCapacity
private Object[] emptyArray
public int Capacity
public int Count
public bool IsFixedSize
public bool IsReadOnly
public bool IsSynchronized
public object SyncRoot
public object Item
internal void .ctor(bool trash)
public void .ctor(int capacity)
public void .ctor(ICollection c)
public int get_Capacity()
public void set_Capacity(int value)
public int get_Count()
public bool get_IsFixedSize()
public bool get_IsReadOnly()
public bool get_IsSynchronized()
public object get_SyncRoot()
public object get_Item(int index)
public void set_Item(int index, object value)
public ArrayList Adapter(IList list)
public int Add(object value)
public void AddRange(ICollection c)
public int BinarySearch(int index, int count, object value, IComparer comparer)
public int BinarySearch(object value)
public int BinarySearch(object value, IComparer comparer)
public void Clear()
public object Clone()
public bool Contains(object item)
public void CopyTo(Array array)
public void CopyTo(Array array, int arrayIndex)
public void CopyTo(int index, Array array, int arrayIndex, int count)
private void EnsureCapacity(int min)
public IList FixedSize(IList list)
public ArrayList FixedSize(ArrayList list)
public IEnumerator GetEnumerator()
public IEnumerator GetEnumerator(int index, int count)
public int IndexOf(object value)
public int IndexOf(object value, int startIndex)
public int IndexOf(object value, int startIndex, int count)
public void Insert(int index, object value)
public void InsertRange(int index, ICollection c)
public int LastIndexOf(object value)
public int LastIndexOf(object value, int startIndex)
public int LastIndexOf(object value, int startIndex, int count)
public IList ReadOnly(IList list)
public ArrayList ReadOnly(ArrayList list)
public void Remove(object obj)
public void RemoveAt(int index)
public void RemoveRange(int index, int count)
public ArrayList Repeat(object value, int count)
public void Reverse()
public void Reverse(int index, int count)
public void SetRange(int index, ICollection c)
public ArrayList GetRange(int index, int count)
public void Sort()
public void Sort(IComparer comparer)
public void Sort(int index, int count, IComparer comparer)
public IList Synchronized(IList list)
public ArrayList Synchronized(ArrayList list)
public Object[] ToArray()
public Array ToArray(Type type)
public void TrimToSize()
}
public System.Collections.BitArray : object {
private int BitsPerInt32
private int BytesPerInt32
private int BitsPerByte
private Int32[] m_array
private int m_length
private int _version
private object _syncRoot
private int _ShrinkThreshold
public bool Item
public int Length
public int Count
public object SyncRoot
public bool IsReadOnly
public bool IsSynchronized
public void .ctor(int length)
public void .ctor(int length, bool defaultValue)
public void .ctor(Byte[] bytes)
public void .ctor(Boolean[] values)
public void .ctor(Int32[] values)
public void .ctor(BitArray bits)
public bool get_Item(int index)
public void set_Item(int index, bool value)
public bool Get(int index)
public void Set(int index, bool value)
public void SetAll(bool value)
public BitArray And(BitArray value)
public BitArray Or(BitArray value)
public BitArray Xor(BitArray value)
public BitArray Not()
public int get_Length()
public void set_Length(int value)
public void CopyTo(Array array, int index)
public int get_Count()
public object Clone()
public object get_SyncRoot()
public bool get_IsReadOnly()
public bool get_IsSynchronized()
public IEnumerator GetEnumerator()
private int GetArrayLength(int n, int div)
}
public System.Collections.CaseInsensitiveComparer : object {
private CompareInfo m_compareInfo
private CaseInsensitiveComparer modreq(System.Runtime.CompilerServices.IsVolatile) m_InvariantCaseInsensitiveComparer
public CaseInsensitiveComparer Default
public CaseInsensitiveComparer DefaultInvariant
public void .ctor(CultureInfo culture)
public CaseInsensitiveComparer get_Default()
public CaseInsensitiveComparer get_DefaultInvariant()
public int Compare(object a, object b)
}
public System.Collections.CaseInsensitiveHashCodeProvider : object {
private TextInfo m_text
private CaseInsensitiveHashCodeProvider modreq(System.Runtime.CompilerServices.IsVolatile) m_InvariantCaseInsensitiveHashCodeProvider
public CaseInsensitiveHashCodeProvider Default
public CaseInsensitiveHashCodeProvider DefaultInvariant
public void .ctor(CultureInfo culture)
public CaseInsensitiveHashCodeProvider get_Default()
public CaseInsensitiveHashCodeProvider get_DefaultInvariant()
public int GetHashCode(object obj)
}
public System.Collections.CollectionBase : object {
private ArrayList list
protected ArrayList InnerList
protected IList List
public int Capacity
public int Count
private bool System.Collections.IList.IsReadOnly
private bool System.Collections.IList.IsFixedSize
private bool System.Collections.ICollection.IsSynchronized
private object System.Collections.ICollection.SyncRoot
private object System.Collections.IList.Item
protected void .ctor(int capacity)
protected ArrayList get_InnerList()
protected IList get_List()
public int get_Capacity()
public void set_Capacity(int value)
public int get_Count()
public void Clear()
public void RemoveAt(int index)
private bool System.Collections.IList.get_IsReadOnly()
private bool System.Collections.IList.get_IsFixedSize()
private bool System.Collections.ICollection.get_IsSynchronized()
private object System.Collections.ICollection.get_SyncRoot()
private void System.Collections.ICollection.CopyTo(Array array, int index)
private object System.Collections.IList.get_Item(int index)
private void System.Collections.IList.set_Item(int index, object value)
private bool System.Collections.IList.Contains(object value)
private int System.Collections.IList.Add(object value)
private void System.Collections.IList.Remove(object value)
private int System.Collections.IList.IndexOf(object value)
private void System.Collections.IList.Insert(int index, object value)
public IEnumerator GetEnumerator()
protected void OnSet(int index, object oldValue, object newValue)
protected void OnInsert(int index, object value)
protected void OnClear()
protected void OnRemove(int index, object value)
protected void OnValidate(object value)
protected void OnSetComplete(int index, object oldValue, object newValue)
protected void OnInsertComplete(int index, object value)
protected void OnClearComplete()
protected void OnRemoveComplete(int index, object value)
}
public System.Collections.Comparer : object {
private CompareInfo m_compareInfo
public Comparer Default
public Comparer DefaultInvariant
private string CompareInfoName
public void .ctor(CultureInfo culture)
private void .ctor(SerializationInfo info, StreamingContext context)
public int Compare(object a, object b)
public void GetObjectData(SerializationInfo info, StreamingContext context)
}
internal System.Collections.CompatibleComparer : object {
private IComparer _comparer
private IHashCodeProvider _hcp
internal IComparer Comparer
internal IHashCodeProvider HashCodeProvider
internal void .ctor(IComparer comparer, IHashCodeProvider hashCodeProvider)
public int Compare(object a, object b)
public bool Equals(object a, object b)
public int GetHashCode(object obj)
internal IComparer get_Comparer()
internal IHashCodeProvider get_HashCodeProvider()
}
internal System.Collections.Concurrent.CDSCollectionETWBCLProvider : EventSource {
public CDSCollectionETWBCLProvider Log
private EventKeywords ALL_KEYWORDS
private int CONCURRENTSTACK_FASTPUSHFAILED_ID
private int CONCURRENTSTACK_FASTPOPFAILED_ID
private int CONCURRENTDICTIONARY_ACQUIRINGALLLOCKS_ID
private int CONCURRENTBAG_TRYTAKESTEALS_ID
private int CONCURRENTBAG_TRYPEEKSTEALS_ID
public void ConcurrentStack_FastPushFailed(int spinCount)
public void ConcurrentStack_FastPopFailed(int spinCount)
public void ConcurrentDictionary_AcquiringAllLocks(int numOfBuckets)
public void ConcurrentBag_TryTakeSteals()
public void ConcurrentBag_TryPeekSteals()
}
public System.Collections.Concurrent.ConcurrentDictionary`2 : object {
private Tables modreq(System.Runtime.CompilerServices.IsVolatile) _tables
private IEqualityComparer`1<TKey> _comparer
private bool _growLockArray
private int _budget
private int DefaultCapacity
private int MaxLockNumber
private bool s_isValueWriteAtomic
public TValue Item
public int Count
public bool IsEmpty
public ICollection`1<TKey> Keys
private IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Keys
public ICollection`1<TValue> Values
private IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Values
private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.IsReadOnly
private bool System.Collections.IDictionary.IsFixedSize
private bool System.Collections.IDictionary.IsReadOnly
private ICollection System.Collections.IDictionary.Keys
private ICollection System.Collections.IDictionary.Values
private object System.Collections.IDictionary.Item
private bool System.Collections.ICollection.IsSynchronized
private object System.Collections.ICollection.SyncRoot
private int DefaultConcurrencyLevel
private bool IsValueWriteAtomic()
public void .ctor(int concurrencyLevel, int capacity)
public void .ctor(IEnumerable`1<KeyValuePair`2<TKey, TValue>> collection)
public void .ctor(IEqualityComparer`1<TKey> comparer)
public void .ctor(IEnumerable`1<KeyValuePair`2<TKey, TValue>> collection, IEqualityComparer`1<TKey> comparer)
public void .ctor(int concurrencyLevel, IEnumerable`1<KeyValuePair`2<TKey, TValue>> collection, IEqualityComparer`1<TKey> comparer)
private void InitializeFromCollection(IEnumerable`1<KeyValuePair`2<TKey, TValue>> collection)
public void .ctor(int concurrencyLevel, int capacity, IEqualityComparer`1<TKey> comparer)
internal void .ctor(int concurrencyLevel, int capacity, bool growLockArray, IEqualityComparer`1<TKey> comparer)
public bool TryAdd(TKey key, TValue value)
public bool ContainsKey(TKey key)
public bool TryRemove(TKey key, TValue& value)
private bool TryRemoveInternal(TKey key, TValue& value, bool matchValue, TValue oldValue)
public bool TryGetValue(TKey key, TValue& value)
private bool TryGetValueInternal(TKey key, int hashcode, TValue& value)
public bool TryUpdate(TKey key, TValue newValue, TValue comparisonValue)
private bool TryUpdateInternal(TKey key, int hashcode, TValue newValue, TValue comparisonValue)
public void Clear()
private void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.CopyTo(KeyValuePair`2[] array, int index)
public KeyValuePair`2[] ToArray()
private void CopyToPairs(KeyValuePair`2[] array, int index)
private void CopyToEntries(DictionaryEntry[] array, int index)
private void CopyToObjects(Object[] array, int index)
public IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator()
private bool TryAddInternal(TKey key, int hashcode, TValue value, bool updateIfExists, bool acquireLock, TValue& resultingValue)
public TValue get_Item(TKey key)
public void set_Item(TKey key, TValue value)
private void ThrowKeyNotFoundException()
private void ThrowKeyNullException()
public int get_Count()
private int GetCountInternal()
public TValue GetOrAdd(TKey key, Func`2<TKey, TValue> valueFactory)
public TValue GetOrAdd(TKey key, Func`3<TKey, TArg, TValue> valueFactory, TArg factoryArgument)
public TValue GetOrAdd(TKey key, TValue value)
public TValue AddOrUpdate(TKey key, Func`3<TKey, TArg, TValue> addValueFactory, Func`4<TKey, TValue, TArg, TValue> updateValueFactory, TArg factoryArgument)
public TValue AddOrUpdate(TKey key, Func`2<TKey, TValue> addValueFactory, Func`3<TKey, TValue, TValue> updateValueFactory)
public TValue AddOrUpdate(TKey key, TValue addValue, Func`3<TKey, TValue, TValue> updateValueFactory)
public bool get_IsEmpty()
private void System.Collections.Generic.IDictionary<TKey,TValue>.Add(TKey key, TValue value)
private bool System.Collections.Generic.IDictionary<TKey,TValue>.Remove(TKey key)
public ICollection`1<TKey> get_Keys()
private IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Keys()
public ICollection`1<TValue> get_Values()
private IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Values()
private void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Add(KeyValuePair`2<TKey, TValue> keyValuePair)
private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Contains(KeyValuePair`2<TKey, TValue> keyValuePair)
private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.get_IsReadOnly()
private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Remove(KeyValuePair`2<TKey, TValue> keyValuePair)
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
private void System.Collections.IDictionary.Add(object key, object value)
private bool System.Collections.IDictionary.Contains(object key)
private IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator()
private bool System.Collections.IDictionary.get_IsFixedSize()
private bool System.Collections.IDictionary.get_IsReadOnly()
private ICollection System.Collections.IDictionary.get_Keys()
private void System.Collections.IDictionary.Remove(object key)
private ICollection System.Collections.IDictionary.get_Values()
private object System.Collections.IDictionary.get_Item(object key)
private void System.Collections.IDictionary.set_Item(object key, object value)
private void System.Collections.ICollection.CopyTo(Array array, int index)
private bool System.Collections.ICollection.get_IsSynchronized()
private object System.Collections.ICollection.get_SyncRoot()
private void GrowTable(Tables<TKey, TValue> tables)
private int GetBucket(int hashcode, int bucketCount)
private void GetBucketAndLockNo(int hashcode, Int32& bucketNo, Int32& lockNo, int bucketCount, int lockCount)
private int get_DefaultConcurrencyLevel()
private void AcquireAllLocks(Int32& locksAcquired)
private void AcquireLocks(int fromInclusive, int toExclusive, Int32& locksAcquired)
private void ReleaseLocks(int fromInclusive, int toExclusive)
private ReadOnlyCollection`1<TKey> GetKeys()
private ReadOnlyCollection`1<TValue> GetValues()
}
public System.Collections.Concurrent.ConcurrentQueue`1 : object {
private int InitialSegmentLength
private int MaxSegmentLength
private object _crossSegmentLock
private Segment modreq(System.Runtime.CompilerServices.IsVolatile) _tail
private Segment modreq(System.Runtime.CompilerServices.IsVolatile) _head
private bool System.Collections.ICollection.IsSynchronized
private object System.Collections.ICollection.SyncRoot
public bool IsEmpty
public int Count
private void InitializeFromCollection(IEnumerable`1<T> collection)
public void .ctor(IEnumerable`1<T> collection)
private void System.Collections.ICollection.CopyTo(Array array, int index)
private bool System.Collections.ICollection.get_IsSynchronized()
private object System.Collections.ICollection.get_SyncRoot()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
private bool System.Collections.Concurrent.IProducerConsumerCollection<T>.TryAdd(T item)
private bool System.Collections.Concurrent.IProducerConsumerCollection<T>.TryTake(T& item)
public bool get_IsEmpty()
public T[] ToArray()
public int get_Count()
private int GetCount(Segment<T> s, int head, int tail)
private long GetCount(Segment<T> head, int headHead, Segment<T> tail, int tailTail)
public void CopyTo(T[] array, int index)
public IEnumerator`1<T> GetEnumerator()
private void SnapForObservation(Segment& head, Int32& headHead, Segment& tail, Int32& tailTail)
private T GetItemWhenAvailable(Segment<T> segment, int i)
private IEnumerator`1<T> Enumerate(Segment<T> head, int headHead, Segment<T> tail, int tailTail)
private int RoundUpToPowerOf2(int i)
public void Enqueue(T item)
private void EnqueueSlow(T item)
public bool TryDequeue(T& result)
private bool TryDequeueSlow(T& item)
public bool TryPeek(T& result)
private bool TryPeek(T& result, bool resultUsed)
public void Clear()
}
public System.Collections.Concurrent.ConcurrentStack`1 : object {
private Node modreq(System.Runtime.CompilerServices.IsVolatile) _head
private int BACKOFF_MAX_YIELDS
public bool IsEmpty
public int Count
private bool System.Collections.ICollection.IsSynchronized
private object System.Collections.ICollection.SyncRoot
public void .ctor(IEnumerable`1<T> collection)
private void InitializeFromCollection(IEnumerable`1<T> collection)
public bool get_IsEmpty()
public int get_Count()
private bool System.Collections.ICollection.get_IsSynchronized()
private object System.Collections.ICollection.get_SyncRoot()
public void Clear()
private void System.Collections.ICollection.CopyTo(Array array, int index)
public void CopyTo(T[] array, int index)
public void Push(T item)
public void PushRange(T[] items)
public void PushRange(T[] items, int startIndex, int count)
private void PushCore(Node<T> head, Node<T> tail)
private void ValidatePushPopRangeInput(T[] items, int startIndex, int count)
private bool System.Collections.Concurrent.IProducerConsumerCollection<T>.TryAdd(T item)
public bool TryPeek(T& result)
public bool TryPop(T& result)
public int TryPopRange(T[] items)
public int TryPopRange(T[] items, int startIndex, int count)
private bool TryPopCore(T& result)
private int TryPopCore(int count, Node& poppedHead)
private void CopyRemovedItems(Node<T> head, T[] collection, int startIndex, int nodesCount)
private bool System.Collections.Concurrent.IProducerConsumerCollection<T>.TryTake(T& item)
public T[] ToArray()
private List`1<T> ToList()
private List`1<T> ToList(Node<T> curr)
public IEnumerator`1<T> GetEnumerator()
private IEnumerator`1<T> GetEnumerator(Node<T> head)
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
}
public System.Collections.Concurrent.EnumerablePartitionerOptions : Enum {
public int value__
public EnumerablePartitionerOptions None
public EnumerablePartitionerOptions NoBuffering
}
internal System.Collections.Concurrent.IDictionaryDebugView`2 : object {
private IDictionary`2<K, V> _dictionary
public KeyValuePair`2[] Items
public void .ctor(IDictionary`2<K, V> dictionary)
public KeyValuePair`2[] get_Items()
}
public System.Collections.Concurrent.IProducerConsumerCollection`1 {
public void CopyTo(T[] array, int index)
public bool TryAdd(T item)
public bool TryTake(T& item)
public T[] ToArray()
}
internal System.Collections.Concurrent.IProducerConsumerCollectionDebugView`1 : object {
private IProducerConsumerCollection`1<T> _collection
public T[] Items
public void .ctor(IProducerConsumerCollection`1<T> collection)
public T[] get_Items()
}
public System.Collections.Concurrent.OrderablePartitioner`1 : Partitioner`1<TSource> {
private bool <KeysOrderedInEachPartition>k__BackingField
private bool <KeysOrderedAcrossPartitions>k__BackingField
private bool <KeysNormalized>k__BackingField
public bool KeysOrderedInEachPartition
public bool KeysOrderedAcrossPartitions
public bool KeysNormalized
protected void .ctor(bool keysOrderedInEachPartition, bool keysOrderedAcrossPartitions, bool keysNormalized)
public IList`1<IEnumerator`1<KeyValuePair`2<long, TSource>>> GetOrderablePartitions(int partitionCount)
public IEnumerable`1<KeyValuePair`2<long, TSource>> GetOrderableDynamicPartitions()
public bool get_KeysOrderedInEachPartition()
private void set_KeysOrderedInEachPartition(bool value)
public bool get_KeysOrderedAcrossPartitions()
private void set_KeysOrderedAcrossPartitions(bool value)
public bool get_KeysNormalized()
private void set_KeysNormalized(bool value)
public IList`1<IEnumerator`1<TSource>> GetPartitions(int partitionCount)
public IEnumerable`1<TSource> GetDynamicPartitions()
}
internal System.Collections.Concurrent.PaddedHeadAndTail : ValueType {
public int Head
public int Tail
}
public System.Collections.Concurrent.Partitioner : object {
private int DEFAULT_BYTES_PER_UNIT
private int DEFAULT_BYTES_PER_CHUNK
public OrderablePartitioner`1<TSource> Create(IList`1<TSource> list, bool loadBalance)
public OrderablePartitioner`1<TSource> Create(TSource[] array, bool loadBalance)
public OrderablePartitioner`1<TSource> Create(IEnumerable`1<TSource> source)
public OrderablePartitioner`1<TSource> Create(IEnumerable`1<TSource> source, EnumerablePartitionerOptions partitionerOptions)
public OrderablePartitioner`1<Tuple`2<long, long>> Create(long fromInclusive, long toExclusive)
public OrderablePartitioner`1<Tuple`2<long, long>> Create(long fromInclusive, long toExclusive, long rangeSize)
private IEnumerable`1<Tuple`2<long, long>> CreateRanges(long fromInclusive, long toExclusive, long rangeSize)
public OrderablePartitioner`1<Tuple`2<int, int>> Create(int fromInclusive, int toExclusive)
public OrderablePartitioner`1<Tuple`2<int, int>> Create(int fromInclusive, int toExclusive, int rangeSize)
private IEnumerable`1<Tuple`2<int, int>> CreateRanges(int fromInclusive, int toExclusive, int rangeSize)
private int GetDefaultChunkSize()
}
public System.Collections.Concurrent.Partitioner`1 : object {
public bool SupportsDynamicPartitions
public IList`1<IEnumerator`1<TSource>> GetPartitions(int partitionCount)
public bool get_SupportsDynamicPartitions()
public IEnumerable`1<TSource> GetDynamicPartitions()
}
public System.Collections.DictionaryBase : object {
private Hashtable hashtable
protected Hashtable InnerHashtable
protected IDictionary Dictionary
public int Count
private bool System.Collections.IDictionary.IsReadOnly
private bool System.Collections.IDictionary.IsFixedSize
private bool System.Collections.ICollection.IsSynchronized
private ICollection System.Collections.IDictionary.Keys
private object System.Collections.ICollection.SyncRoot
private ICollection System.Collections.IDictionary.Values
private object System.Collections.IDictionary.Item
protected Hashtable get_InnerHashtable()
protected IDictionary get_Dictionary()
public int get_Count()
private bool System.Collections.IDictionary.get_IsReadOnly()
private bool System.Collections.IDictionary.get_IsFixedSize()
private bool System.Collections.ICollection.get_IsSynchronized()
private ICollection System.Collections.IDictionary.get_Keys()
private object System.Collections.ICollection.get_SyncRoot()
private ICollection System.Collections.IDictionary.get_Values()
public void CopyTo(Array array, int index)
private object System.Collections.IDictionary.get_Item(object key)
private void System.Collections.IDictionary.set_Item(object key, object value)
private bool System.Collections.IDictionary.Contains(object key)
private void System.Collections.IDictionary.Add(object key, object value)
public void Clear()
private void System.Collections.IDictionary.Remove(object key)
public IDictionaryEnumerator GetEnumerator()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
protected object OnGet(object key, object currentValue)
protected void OnSet(object key, object oldValue, object newValue)
protected void OnInsert(object key, object value)
protected void OnClear()
protected void OnRemove(object key, object value)
protected void OnValidate(object key, object value)
protected void OnSetComplete(object key, object oldValue, object newValue)
protected void OnInsertComplete(object key, object value)
protected void OnClearComplete()
protected void OnRemoveComplete(object key, object value)
}
public System.Collections.DictionaryEntry : ValueType {
private object _key
private object _value
public object Key
public object Value
public void .ctor(object key, object value)
public object get_Key()
public void set_Key(object value)
public object get_Value()
public void set_Value(object value)
public void Deconstruct(Object& key, Object& value)
}
internal System.Collections.EmptyReadOnlyDictionaryInternal : object {
public int Count
public object SyncRoot
public bool IsSynchronized
public object Item
public ICollection Keys
public ICollection Values
public bool IsReadOnly
public bool IsFixedSize
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
public void CopyTo(Array array, int index)
public int get_Count()
public object get_SyncRoot()
public bool get_IsSynchronized()
public object get_Item(object key)
public void set_Item(object key, object value)
public ICollection get_Keys()
public ICollection get_Values()
public bool Contains(object key)
public void Add(object key, object value)
public void Clear()
public bool get_IsReadOnly()
public bool get_IsFixedSize()
public IDictionaryEnumerator GetEnumerator()
public void Remove(object key)
}
internal System.Collections.Generic.ArraySortHelper`1 : object {
public void Sort(T[] keys, int index, int length, IComparer`1<T> comparer)
public int BinarySearch(T[] array, int index, int length, T value, IComparer`1<T> comparer)
internal void Sort(T[] keys, int index, int length, Comparison`1<T> comparer)
internal int InternalBinarySearch(T[] array, int index, int length, T value, IComparer`1<T> comparer)
private void SwapIfGreater(T[] keys, Comparison`1<T> comparer, int a, int b)
private void Swap(T[] a, int i, int j)
internal void IntrospectiveSort(T[] keys, int left, int length, Comparison`1<T> comparer)
private void IntroSort(T[] keys, int lo, int hi, int depthLimit, Comparison`1<T> comparer)
private int PickPivotAndPartition(T[] keys, int lo, int hi, Comparison`1<T> comparer)
private void Heapsort(T[] keys, int lo, int hi, Comparison`1<T> comparer)
private void DownHeap(T[] keys, int i, int n, int lo, Comparison`1<T> comparer)
private void InsertionSort(T[] keys, int lo, int hi, Comparison`1<T> comparer)
}
internal System.Collections.Generic.ArraySortHelper`2 : object {
private ArraySortHelper`2 modreq(System.Runtime.CompilerServices.IsVolatile) s_defaultArraySortHelper
public ArraySortHelper`2<TKey, TValue> Default
public ArraySortHelper`2<TKey, TValue> get_Default()
private ArraySortHelper`2<TKey, TValue> CreateArraySortHelper()
public void Sort(TKey[] keys, TValue[] values, int index, int length, IComparer`1<TKey> comparer)
private void SwapIfGreaterWithItems(TKey[] keys, TValue[] values, IComparer`1<TKey> comparer, int a, int b)
private void Swap(TKey[] keys, TValue[] values, int i, int j)
internal void IntrospectiveSort(TKey[] keys, TValue[] values, int left, int length, IComparer`1<TKey> comparer)
private void IntroSort(TKey[] keys, TValue[] values, int lo, int hi, int depthLimit, IComparer`1<TKey> comparer)
private int PickPivotAndPartition(TKey[] keys, TValue[] values, int lo, int hi, IComparer`1<TKey> comparer)
private void Heapsort(TKey[] keys, TValue[] values, int lo, int hi, IComparer`1<TKey> comparer)
private void DownHeap(TKey[] keys, TValue[] values, int i, int n, int lo, IComparer`1<TKey> comparer)
private void InsertionSort(TKey[] keys, TValue[] values, int lo, int hi, IComparer`1<TKey> comparer)
}
internal System.Collections.Generic.ByteEqualityComparer : EqualityComparer`1<byte> {
public bool Equals(byte x, byte y)
public int GetHashCode(byte b)
internal int IndexOf(Byte[] array, byte value, int startIndex, int count)
internal int LastIndexOf(Byte[] array, byte value, int startIndex, int count)
public bool Equals(object obj)
public int GetHashCode()
}
public System.Collections.Generic.CollectionExtensions : object {
public TValue GetValueOrDefault(IReadOnlyDictionary`2<TKey, TValue> dictionary, TKey key)
public TValue GetValueOrDefault(IReadOnlyDictionary`2<TKey, TValue> dictionary, TKey key, TValue defaultValue)
public bool TryAdd(IDictionary`2<TKey, TValue> dictionary, TKey key, TValue value)
public bool Remove(IDictionary`2<TKey, TValue> dictionary, TKey key, TValue& value)
}
public System.Collections.Generic.Comparer`1 : object {
private Comparer`1 modreq(System.Runtime.CompilerServices.IsVolatile) defaultComparer
public Comparer`1<T> Default
public Comparer`1<T> get_Default()
public Comparer`1<T> Create(Comparison`1<T> comparison)
private Comparer`1<T> CreateComparer()
public int Compare(T x, T y)
private int System.Collections.IComparer.Compare(object x, object y)
}
internal System.Collections.Generic.ComparisonComparer`1 : Comparer`1<T> {
private Comparison`1<T> _comparison
public void .ctor(Comparison`1<T> comparison)
public int Compare(T x, T y)
}
public System.Collections.Generic.Dictionary`2 : object {
private Int32[] buckets
private Entry[] entries
private int count
private int version
private int freeList
private int freeCount
private IEqualityComparer`1<TKey> comparer
private KeyCollection<TKey, TValue> keys
private ValueCollection<TKey, TValue> values
private object _syncRoot
private string VersionName
private string HashSizeName
private string KeyValuePairsName
private string ComparerName
public IEqualityComparer`1<TKey> Comparer
public int Count
public KeyCollection<TKey, TValue> Keys
private ICollection`1<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.Keys
private IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Keys
public ValueCollection<TKey, TValue> Values
private ICollection`1<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.Values
private IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Values
public TValue Item
private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.IsReadOnly
private bool System.Collections.ICollection.IsSynchronized
private object System.Collections.ICollection.SyncRoot
private bool System.Collections.IDictionary.IsFixedSize
private bool System.Collections.IDictionary.IsReadOnly
private ICollection System.Collections.IDictionary.Keys
private ICollection System.Collections.IDictionary.Values
private object System.Collections.IDictionary.Item
public void .ctor(int capacity)
public void .ctor(IEqualityComparer`1<TKey> comparer)
public void .ctor(int capacity, IEqualityComparer`1<TKey> comparer)
public void .ctor(IDictionary`2<TKey, TValue> dictionary)
public void .ctor(IDictionary`2<TKey, TValue> dictionary, IEqualityComparer`1<TKey> comparer)
public void .ctor(IEnumerable`1<KeyValuePair`2<TKey, TValue>> collection)
public void .ctor(IEnumerable`1<KeyValuePair`2<TKey, TValue>> collection, IEqualityComparer`1<TKey> comparer)
protected void .ctor(SerializationInfo info, StreamingContext context)
public IEqualityComparer`1<TKey> get_Comparer()
public int get_Count()
public KeyCollection<TKey, TValue> get_Keys()
private ICollection`1<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.get_Keys()
private IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Keys()
public ValueCollection<TKey, TValue> get_Values()
private ICollection`1<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.get_Values()
private IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Values()
public TValue get_Item(TKey key)
public void set_Item(TKey key, TValue value)
public void Add(TKey key, TValue value)
private void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Add(KeyValuePair`2<TKey, TValue> keyValuePair)
private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Contains(KeyValuePair`2<TKey, TValue> keyValuePair)
private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Remove(KeyValuePair`2<TKey, TValue> keyValuePair)
public void Clear()
public bool ContainsKey(TKey key)
public bool ContainsValue(TValue value)
private void CopyTo(KeyValuePair`2[] array, int index)
public Enumerator<TKey, TValue> GetEnumerator()
private IEnumerator`1<KeyValuePair`2<TKey, TValue>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey,TValue>>.GetEnumerator()
public void GetObjectData(SerializationInfo info, StreamingContext context)
private int FindEntry(TKey key)
private void Initialize(int capacity)
private bool TryInsert(TKey key, TValue value, InsertionBehavior behavior)
public void OnDeserialization(object sender)
private void Resize()
private void Resize(int newSize, bool forceNewHashCodes)
public bool Remove(TKey key)
public bool Remove(TKey key, TValue& value)
public bool TryGetValue(TKey key, TValue& value)
public bool TryAdd(TKey key, TValue value)
private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.get_IsReadOnly()
private void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.CopyTo(KeyValuePair`2[] array, int index)
private void System.Collections.ICollection.CopyTo(Array array, int index)
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
private bool System.Collections.ICollection.get_IsSynchronized()
private object System.Collections.ICollection.get_SyncRoot()
private bool System.Collections.IDictionary.get_IsFixedSize()
private bool System.Collections.IDictionary.get_IsReadOnly()
private ICollection System.Collections.IDictionary.get_Keys()
private ICollection System.Collections.IDictionary.get_Values()
private object System.Collections.IDictionary.get_Item(object key)
private void System.Collections.IDictionary.set_Item(object key, object value)
private bool IsCompatibleKey(object key)
private void System.Collections.IDictionary.Add(object key, object value)
private bool System.Collections.IDictionary.Contains(object key)
private IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator()
private void System.Collections.IDictionary.Remove(object key)
}
internal System.Collections.Generic.DictionaryHashHelpers : object {
private ConditionalWeakTable`2<object, SerializationInfo> <SerializationInfoTable>k__BackingField
internal ConditionalWeakTable`2<object, SerializationInfo> SerializationInfoTable
internal ConditionalWeakTable`2<object, SerializationInfo> get_SerializationInfoTable()
}
internal System.Collections.Generic.DictionaryKeyCollectionDebugView`2 : object {
private ICollection`1<TKey> _collection
public TKey[] Items
public void .ctor(ICollection`1<TKey> collection)
public TKey[] get_Items()
}
internal System.Collections.Generic.DictionaryValueCollectionDebugView`2 : object {
private ICollection`1<TValue> _collection
public TValue[] Items
public void .ctor(ICollection`1<TValue> collection)
public TValue[] get_Items()
}
internal System.Collections.Generic.EnumEqualityComparer`1 : EqualityComparer`1<T> {
public bool Equals(T x, T y)
public int GetHashCode(T obj)
protected void .ctor(SerializationInfo information, StreamingContext context)
public void GetObjectData(SerializationInfo info, StreamingContext context)
public bool Equals(object obj)
public int GetHashCode()
}
public System.Collections.Generic.EqualityComparer`1 : object {
private EqualityComparer`1 modreq(System.Runtime.CompilerServices.IsVolatile) defaultComparer
public EqualityComparer`1<T> Default
public EqualityComparer`1<T> get_Default()
private EqualityComparer`1<T> CreateComparer()
public bool Equals(T x, T y)
public int GetHashCode(T obj)
internal int IndexOf(T[] array, T value, int startIndex, int count)
internal int LastIndexOf(T[] array, T value, int startIndex, int count)
private int System.Collections.IEqualityComparer.GetHashCode(object obj)
private bool System.Collections.IEqualityComparer.Equals(object x, object y)
}
internal System.Collections.Generic.GenericComparer`1 : Comparer`1<T> {
public int Compare(T x, T y)
public bool Equals(object obj)
public int GetHashCode()
}
internal System.Collections.Generic.GenericEqualityComparer`1 : EqualityComparer`1<T> {
public bool Equals(T x, T y)
public int GetHashCode(T obj)
internal int IndexOf(T[] array, T value, int startIndex, int count)
internal int LastIndexOf(T[] array, T value, int startIndex, int count)
public bool Equals(object obj)
public int GetHashCode()
}
public System.Collections.Generic.ICollection`1 {
public int Count
public bool IsReadOnly
public int get_Count()
public bool get_IsReadOnly()
public void Add(T item)
public void Clear()
public bool Contains(T item)
public void CopyTo(T[] array, int arrayIndex)
public bool Remove(T item)
}
public System.Collections.Generic.IComparer`1 {
public int Compare(T x, T y)
}
public System.Collections.Generic.IDictionary`2 {
public TValue Item
public ICollection`1<TKey> Keys
public ICollection`1<TValue> Values
public TValue get_Item(TKey key)
public void set_Item(TKey key, TValue value)
public ICollection`1<TKey> get_Keys()
public ICollection`1<TValue> get_Values()
public bool ContainsKey(TKey key)
public void Add(TKey key, TValue value)
public bool Remove(TKey key)
public bool TryGetValue(TKey key, TValue& value)
}
internal System.Collections.Generic.IDictionaryDebugView`2 : object {
private IDictionary`2<K, V> _dict
public KeyValuePair`2[] Items
public void .ctor(IDictionary`2<K, V> dictionary)
public KeyValuePair`2[] get_Items()
}
public System.Collections.Generic.IEnumerable`1 {
public IEnumerator`1<T> GetEnumerator()
}
public System.Collections.Generic.IEnumerator`1 {
public T Current
public T get_Current()
}
public System.Collections.Generic.IEqualityComparer`1 {
public bool Equals(T x, T y)
public int GetHashCode(T obj)
}
public System.Collections.Generic.IList`1 {
public T Item
public T get_Item(int index)
public void set_Item(int index, T value)
public int IndexOf(T item)
public void Insert(int index, T item)
public void RemoveAt(int index)
}
internal System.Collections.Generic.InsertionBehavior : Enum {
public byte value__
public InsertionBehavior None
public InsertionBehavior OverwriteExisting
public InsertionBehavior ThrowOnExisting
}
internal System.Collections.Generic.InternalStringComparer : EqualityComparer`1<string> {
public int GetHashCode(string obj)
public bool Equals(string x, string y)
internal int IndexOf(String[] array, string value, int startIndex, int count)
}
internal System.Collections.Generic.IntrospectiveSortUtilities : object {
internal int IntrosortSizeThreshold
internal int FloorLog2(int n)
internal void ThrowOrIgnoreBadComparer(object comparer)
}
public System.Collections.Generic.IReadOnlyCollection`1 {
public int Count
public int get_Count()
}
public System.Collections.Generic.IReadOnlyDictionary`2 {
public TValue Item
public IEnumerable`1<TKey> Keys
public IEnumerable`1<TValue> Values
public bool ContainsKey(TKey key)
public bool TryGetValue(TKey key, TValue& value)
public TValue get_Item(TKey key)
public IEnumerable`1<TKey> get_Keys()
public IEnumerable`1<TValue> get_Values()
}
public System.Collections.Generic.IReadOnlyList`1 {
public T Item
public T get_Item(int index)
}
public System.Collections.Generic.KeyNotFoundException : SystemException {
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
protected void .ctor(SerializationInfo info, StreamingContext context)
}
public System.Collections.Generic.KeyValuePair : object {
public KeyValuePair`2<TKey, TValue> Create(TKey key, TValue value)
internal string PairToString(object key, object value)
}
public System.Collections.Generic.KeyValuePair`2 : ValueType {
private TKey key
private TValue value
public TKey Key
public TValue Value
public void .ctor(TKey key, TValue value)
public TKey get_Key()
public TValue get_Value()
public string ToString()
public void Deconstruct(TKey& key, TValue& value)
}
public System.Collections.Generic.List`1 : object {
private int _defaultCapacity
private T[] _items
private int _size
private int _version
private object _syncRoot
private T[] _emptyArray
public int Capacity
public int Count
private bool System.Collections.IList.IsFixedSize
private bool System.Collections.Generic.ICollection<T>.IsReadOnly
private bool System.Collections.IList.IsReadOnly
private bool System.Collections.ICollection.IsSynchronized
private object System.Collections.ICollection.SyncRoot
public T Item
private object System.Collections.IList.Item
public void .ctor(int capacity)
public void .ctor(IEnumerable`1<T> collection)
public int get_Capacity()
public void set_Capacity(int value)
public int get_Count()
private bool System.Collections.IList.get_IsFixedSize()
private bool System.Collections.Generic.ICollection<T>.get_IsReadOnly()
private bool System.Collections.IList.get_IsReadOnly()
private bool System.Collections.ICollection.get_IsSynchronized()
private object System.Collections.ICollection.get_SyncRoot()
public T get_Item(int index)
public void set_Item(int index, T value)
private bool IsCompatibleObject(object value)
private object System.Collections.IList.get_Item(int index)
private void System.Collections.IList.set_Item(int index, object value)
public void Add(T item)
private int System.Collections.IList.Add(object item)
public void AddRange(IEnumerable`1<T> collection)
public ReadOnlyCollection`1<T> AsReadOnly()
public int BinarySearch(int index, int count, T item, IComparer`1<T> comparer)
public int BinarySearch(T item)
public int BinarySearch(T item, IComparer`1<T> comparer)
public void Clear()
public bool Contains(T item)
private bool System.Collections.IList.Contains(object item)
public List`1<TOutput> ConvertAll(Converter`2<T, TOutput> converter)
public void CopyTo(T[] array)
private void System.Collections.ICollection.CopyTo(Array array, int arrayIndex)
public void CopyTo(int index, T[] array, int arrayIndex, int count)
public void CopyTo(T[] array, int arrayIndex)
private void EnsureCapacity(int min)
public bool Exists(Predicate`1<T> match)
public T Find(Predicate`1<T> match)
public List`1<T> FindAll(Predicate`1<T> match)
public int FindIndex(Predicate`1<T> match)
public int FindIndex(int startIndex, Predicate`1<T> match)
public int FindIndex(int startIndex, int count, Predicate`1<T> match)
public T FindLast(Predicate`1<T> match)
public int FindLastIndex(Predicate`1<T> match)
public int FindLastIndex(int startIndex, Predicate`1<T> match)
public int FindLastIndex(int startIndex, int count, Predicate`1<T> match)
public void ForEach(Action`1<T> action)
public Enumerator<T> GetEnumerator()
private IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
public List`1<T> GetRange(int index, int count)
public int IndexOf(T item)
private int System.Collections.IList.IndexOf(object item)
public int IndexOf(T item, int index)
public int IndexOf(T item, int index, int count)
public void Insert(int index, T item)
private void System.Collections.IList.Insert(int index, object item)
public void InsertRange(int index, IEnumerable`1<T> collection)
public int LastIndexOf(T item)
public int LastIndexOf(T item, int index)
public int LastIndexOf(T item, int index, int count)
public bool Remove(T item)
private void System.Collections.IList.Remove(object item)
public int RemoveAll(Predicate`1<T> match)
public void RemoveAt(int index)
public void RemoveRange(int index, int count)
public void Reverse()
public void Reverse(int index, int count)
public void Sort()
public void Sort(IComparer`1<T> comparer)
public void Sort(int index, int count, IComparer`1<T> comparer)
public void Sort(Comparison`1<T> comparison)
public T[] ToArray()
public void TrimExcess()
public bool TrueForAll(Predicate`1<T> match)
internal IList`1<T> Synchronized(List`1<T> list)
}
internal System.Collections.Generic.LongEnumEqualityComparer`1 : EqualityComparer`1<T> {
public bool Equals(T x, T y)
public int GetHashCode(T obj)
public bool Equals(object obj)
public int GetHashCode()
public void .ctor(SerializationInfo information, StreamingContext context)
public void GetObjectData(SerializationInfo info, StreamingContext context)
}
internal System.Collections.Generic.Mscorlib_CollectionDebugView`1 : object {
private ICollection`1<T> collection
public T[] Items
public void .ctor(ICollection`1<T> collection)
public T[] get_Items()
}
internal System.Collections.Generic.Mscorlib_DictionaryDebugView`2 : object {
private IDictionary`2<K, V> dict
public KeyValuePair`2[] Items
public void .ctor(IDictionary`2<K, V> dictionary)
public KeyValuePair`2[] get_Items()
}
internal System.Collections.Generic.Mscorlib_DictionaryKeyCollectionDebugView`2 : object {
private ICollection`1<TKey> collection
public TKey[] Items
public void .ctor(ICollection`1<TKey> collection)
public TKey[] get_Items()
}
internal System.Collections.Generic.Mscorlib_DictionaryValueCollectionDebugView`2 : object {
private ICollection`1<TValue> collection
public TValue[] Items
public void .ctor(ICollection`1<TValue> collection)
public TValue[] get_Items()
}
internal System.Collections.Generic.Mscorlib_KeyedCollectionDebugView`2 : object {
private KeyedCollection`2<K, T> kc
public T[] Items
public void .ctor(KeyedCollection`2<K, T> keyedCollection)
public T[] get_Items()
}
internal System.Collections.Generic.NonRandomizedStringEqualityComparer : EqualityComparer`1<string> {
private IEqualityComparer`1 modreq(System.Runtime.CompilerServices.IsVolatile) s_nonRandomizedComparer
internal IEqualityComparer`1<string> Default
internal IEqualityComparer`1<string> get_Default()
public bool Equals(string x, string y)
public int GetHashCode(string obj)
}
internal System.Collections.Generic.NullableComparer`1 : Comparer`1<Nullable`1<T>> {
public int Compare(Nullable`1<T> x, Nullable`1<T> y)
public bool Equals(object obj)
public int GetHashCode()
}
internal System.Collections.Generic.NullableEqualityComparer`1 : EqualityComparer`1<Nullable`1<T>> {
public bool Equals(Nullable`1<T> x, Nullable`1<T> y)
public int GetHashCode(Nullable`1<T> obj)
internal int IndexOf(Nullable`1[] array, Nullable`1<T> value, int startIndex, int count)
internal int LastIndexOf(Nullable`1[] array, Nullable`1<T> value, int startIndex, int count)
public bool Equals(object obj)
public int GetHashCode()
}
internal System.Collections.Generic.ObjectComparer`1 : Comparer`1<T> {
public int Compare(T x, T y)
public bool Equals(object obj)
public int GetHashCode()
}
internal System.Collections.Generic.ObjectEqualityComparer : object {
internal ObjectEqualityComparer Default
private int System.Collections.IEqualityComparer.GetHashCode(object obj)
private bool System.Collections.IEqualityComparer.Equals(object x, object y)
}
internal System.Collections.Generic.ObjectEqualityComparer`1 : EqualityComparer`1<T> {
public bool Equals(T x, T y)
public int GetHashCode(T obj)
internal int IndexOf(T[] array, T value, int startIndex, int count)
internal int LastIndexOf(T[] array, T value, int startIndex, int count)
public bool Equals(object obj)
public int GetHashCode()
}
internal System.Collections.Generic.ReferenceEqualityComparer`1 : object {
internal ReferenceEqualityComparer`1<T> Instance
public bool Equals(T x, T y)
public int GetHashCode(T obj)
}
internal System.Collections.Generic.SByteEnumEqualityComparer`1 : EnumEqualityComparer`1<T> {
public void .ctor(SerializationInfo information, StreamingContext context)
public int GetHashCode(T obj)
}
internal System.Collections.Generic.ShortEnumEqualityComparer`1 : EnumEqualityComparer`1<T> {
public void .ctor(SerializationInfo information, StreamingContext context)
public int GetHashCode(T obj)
}
internal System.Collections.HashHelpers : object {
public int HashCollisionThreshold
public Int32[] primes
private ConditionalWeakTable`2<object, SerializationInfo> s_SerializationInfoTable
public int MaxPrimeArrayLength
internal ConditionalWeakTable`2<object, SerializationInfo> SerializationInfoTable
internal ConditionalWeakTable`2<object, SerializationInfo> get_SerializationInfoTable()
public bool IsPrime(int candidate)
public int GetPrime(int min)
public int GetMinPrime()
public int ExpandPrime(int oldSize)
}
public System.Collections.Hashtable : object {
internal int HashPrime
private int InitialSize
private string LoadFactorName
private string VersionName
private string ComparerName
private string HashCodeProviderName
private string HashSizeName
private string KeysName
private string ValuesName
private string KeyComparerName
private bucket[] buckets
private int count
private int occupancy
private int loadsize
private float loadFactor
private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) version
private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) isWriterInProgress
private ICollection keys
private ICollection values
private IEqualityComparer _keycomparer
private object _syncRoot
protected IHashCodeProvider hcp
protected IComparer comparer
protected IEqualityComparer EqualityComparer
public object Item
public bool IsReadOnly
public bool IsFixedSize
public bool IsSynchronized
public ICollection Keys
public ICollection Values
public object SyncRoot
public int Count
protected IHashCodeProvider get_hcp()
protected void set_hcp(IHashCodeProvider value)
protected IComparer get_comparer()
protected void set_comparer(IComparer value)
protected IEqualityComparer get_EqualityComparer()
internal void .ctor(bool trash)
public void .ctor(int capacity)
public void .ctor(int capacity, float loadFactor)
public void .ctor(int capacity, float loadFactor, IHashCodeProvider hcp, IComparer comparer)
public void .ctor(int capacity, float loadFactor, IEqualityComparer equalityComparer)
public void .ctor(IHashCodeProvider hcp, IComparer comparer)
public void .ctor(IEqualityComparer equalityComparer)
public void .ctor(int capacity, IHashCodeProvider hcp, IComparer comparer)
public void .ctor(int capacity, IEqualityComparer equalityComparer)
public void .ctor(IDictionary d)
public void .ctor(IDictionary d, float loadFactor)
public void .ctor(IDictionary d, IHashCodeProvider hcp, IComparer comparer)
public void .ctor(IDictionary d, IEqualityComparer equalityComparer)
public void .ctor(IDictionary d, float loadFactor, IHashCodeProvider hcp, IComparer comparer)
public void .ctor(IDictionary d, float loadFactor, IEqualityComparer equalityComparer)
protected void .ctor(SerializationInfo info, StreamingContext context)
private UInt32 InitHash(object key, int hashsize, UInt32& seed, UInt32& incr)
public void Add(object key, object value)
public void Clear()
public object Clone()
public bool Contains(object key)
public bool ContainsKey(object key)
public bool ContainsValue(object value)
private void CopyKeys(Array array, int arrayIndex)
private void CopyEntries(Array array, int arrayIndex)
public void CopyTo(Array array, int arrayIndex)
internal KeyValuePairs[] ToKeyValuePairsArray()
private void CopyValues(Array array, int arrayIndex)
public object get_Item(object key)
public void set_Item(object key, object value)
private void expand()
private void rehash()
private void UpdateVersion()
private void rehash(int newsize, bool forceNewHashCode)
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
public IDictionaryEnumerator GetEnumerator()
protected int GetHash(object key)
public bool get_IsReadOnly()
public bool get_IsFixedSize()
public bool get_IsSynchronized()
protected bool KeyEquals(object item, object key)
public ICollection get_Keys()
public ICollection get_Values()
private void Insert(object key, object nvalue, bool add)
private void putEntry(bucket[] newBuckets, object key, object nvalue, int hashcode)
public void Remove(object key)
public object get_SyncRoot()
public int get_Count()
public Hashtable Synchronized(Hashtable table)
public void GetObjectData(SerializationInfo info, StreamingContext context)
public void OnDeserialization(object sender)
}
public System.Collections.ICollection {
public int Count
public object SyncRoot
public bool IsSynchronized
public void CopyTo(Array array, int index)
public int get_Count()
public object get_SyncRoot()
public bool get_IsSynchronized()
}
public System.Collections.IComparer {
public int Compare(object x, object y)
}
public System.Collections.IDictionary {
public object Item
public ICollection Keys
public ICollection Values
public bool IsReadOnly
public bool IsFixedSize
public object get_Item(object key)
public void set_Item(object key, object value)
public ICollection get_Keys()
public ICollection get_Values()
public bool Contains(object key)
public void Add(object key, object value)
public void Clear()
public bool get_IsReadOnly()
public bool get_IsFixedSize()
public IDictionaryEnumerator GetEnumerator()
public void Remove(object key)
}
public System.Collections.IDictionaryEnumerator {
public object Key
public object Value
public DictionaryEntry Entry
public object get_Key()
public object get_Value()
public DictionaryEntry get_Entry()
}
public System.Collections.IEnumerable {
public IEnumerator GetEnumerator()
}
public System.Collections.IEnumerator {
public object Current
public bool MoveNext()
public object get_Current()
public void Reset()
}
public System.Collections.IEqualityComparer {
public bool Equals(object x, object y)
public int GetHashCode(object obj)
}
public System.Collections.IHashCodeProvider {
public int GetHashCode(object obj)
}
public System.Collections.IList {
public object Item
public bool IsReadOnly
public bool IsFixedSize
public object get_Item(int index)
public void set_Item(int index, object value)
public int Add(object value)
public bool Contains(object value)
public void Clear()
public bool get_IsReadOnly()
public bool get_IsFixedSize()
public int IndexOf(object value)
public void Insert(int index, object value)
public void Remove(object value)
public void RemoveAt(int index)
}
public System.Collections.IStructuralComparable {
public int CompareTo(object other, IComparer comparer)
}
public System.Collections.IStructuralEquatable {
public bool Equals(object other, IEqualityComparer comparer)
public int GetHashCode(IEqualityComparer comparer)
}
internal System.Collections.KeyValuePairs : object {
private object key
private object value
public object Key
public object Value
public void .ctor(object key, object value)
public object get_Key()
public object get_Value()
}
internal System.Collections.ListDictionaryInternal : object {
private DictionaryNode head
private int version
private int count
private object _syncRoot
public object Item
public int Count
public ICollection Keys
public bool IsReadOnly
public bool IsFixedSize
public bool IsSynchronized
public object SyncRoot
public ICollection Values
public object get_Item(object key)
public void set_Item(object key, object value)
public int get_Count()
public ICollection get_Keys()
public bool get_IsReadOnly()
public bool get_IsFixedSize()
public bool get_IsSynchronized()
public object get_SyncRoot()
public ICollection get_Values()
public void Add(object key, object value)
public void Clear()
public bool Contains(object key)
public void CopyTo(Array array, int index)
public IDictionaryEnumerator GetEnumerator()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
public void Remove(object key)
}
internal System.Collections.LowLevelComparer : object {
internal LowLevelComparer Default
public int Compare(object a, object b)
}
public System.Collections.ObjectModel.Collection`1 : object {
private IList`1<T> items
private object _syncRoot
public int Count
protected IList`1<T> Items
public T Item
private bool System.Collections.Generic.ICollection<T>.IsReadOnly
private bool System.Collections.ICollection.IsSynchronized
private object System.Collections.ICollection.SyncRoot
private object System.Collections.IList.Item
private bool System.Collections.IList.IsReadOnly
private bool System.Collections.IList.IsFixedSize
public void .ctor(IList`1<T> list)
public int get_Count()
protected IList`1<T> get_Items()
public T get_Item(int index)
public void set_Item(int index, T value)
public void Add(T item)
public void Clear()
public void CopyTo(T[] array, int index)
public bool Contains(T item)
public IEnumerator`1<T> GetEnumerator()
public int IndexOf(T item)
public void Insert(int index, T item)
public bool Remove(T item)
public void RemoveAt(int index)
protected void ClearItems()
protected void InsertItem(int index, T item)
protected void RemoveItem(int index)
protected void SetItem(int index, T item)
private bool System.Collections.Generic.ICollection<T>.get_IsReadOnly()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
private bool System.Collections.ICollection.get_IsSynchronized()
private object System.Collections.ICollection.get_SyncRoot()
private void System.Collections.ICollection.CopyTo(Array array, int index)
private object System.Collections.IList.get_Item(int index)
private void System.Collections.IList.set_Item(int index, object value)
private bool System.Collections.IList.get_IsReadOnly()
private bool System.Collections.IList.get_IsFixedSize()
private int System.Collections.IList.Add(object value)
private bool System.Collections.IList.Contains(object value)
private int System.Collections.IList.IndexOf(object value)
private void System.Collections.IList.Insert(int index, object value)
private void System.Collections.IList.Remove(object value)
private bool IsCompatibleObject(object value)
}
public System.Collections.ObjectModel.KeyedCollection`2 : Collection`1<TItem> {
private int defaultThreshold
private IEqualityComparer`1<TKey> comparer
private Dictionary`2<TKey, TItem> dict
private int keyCount
private int threshold
public IEqualityComparer`1<TKey> Comparer
public TItem Item
protected IDictionary`2<TKey, TItem> Dictionary
protected void .ctor(IEqualityComparer`1<TKey> comparer)
protected void .ctor(IEqualityComparer`1<TKey> comparer, int dictionaryCreationThreshold)
public IEqualityComparer`1<TKey> get_Comparer()
public TItem get_Item(TKey key)
public bool Contains(TKey key)
private bool ContainsItem(TItem item)
public bool Remove(TKey key)
protected IDictionary`2<TKey, TItem> get_Dictionary()
protected void ChangeItemKey(TItem item, TKey newKey)
protected void ClearItems()
protected TKey GetKeyForItem(TItem item)
protected void InsertItem(int index, TItem item)
protected void RemoveItem(int index)
protected void SetItem(int index, TItem item)
private void AddKey(TKey key, TItem item)
private void CreateDictionary()
private void RemoveKey(TKey key)
}
public System.Collections.ObjectModel.ReadOnlyCollection`1 : object {
private IList`1<T> list
private object _syncRoot
public int Count
public T Item
protected IList`1<T> Items
private bool System.Collections.Generic.ICollection<T>.IsReadOnly
private T System.Collections.Generic.IList<T>.Item
private bool System.Collections.ICollection.IsSynchronized
private object System.Collections.ICollection.SyncRoot
private bool System.Collections.IList.IsFixedSize
private bool System.Collections.IList.IsReadOnly
private object System.Collections.IList.Item
public void .ctor(IList`1<T> list)
public int get_Count()
public T get_Item(int index)
public bool Contains(T value)
public void CopyTo(T[] array, int index)
public IEnumerator`1<T> GetEnumerator()
public int IndexOf(T value)
protected IList`1<T> get_Items()
private bool System.Collections.Generic.ICollection<T>.get_IsReadOnly()
private T System.Collections.Generic.IList<T>.get_Item(int index)
private void System.Collections.Generic.IList<T>.set_Item(int index, T value)
private void System.Collections.Generic.ICollection<T>.Add(T value)
private void System.Collections.Generic.ICollection<T>.Clear()
private void System.Collections.Generic.IList<T>.Insert(int index, T value)
private bool System.Collections.Generic.ICollection<T>.Remove(T value)
private void System.Collections.Generic.IList<T>.RemoveAt(int index)
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
private bool System.Collections.ICollection.get_IsSynchronized()
private object System.Collections.ICollection.get_SyncRoot()
private void System.Collections.ICollection.CopyTo(Array array, int index)
private bool System.Collections.IList.get_IsFixedSize()
private bool System.Collections.IList.get_IsReadOnly()
private object System.Collections.IList.get_Item(int index)
private void System.Collections.IList.set_Item(int index, object value)
private int System.Collections.IList.Add(object value)
private void System.Collections.IList.Clear()
private bool IsCompatibleObject(object value)
private bool System.Collections.IList.Contains(object value)
private int System.Collections.IList.IndexOf(object value)
private void System.Collections.IList.Insert(int index, object value)
private void System.Collections.IList.Remove(object value)
private void System.Collections.IList.RemoveAt(int index)
}
public System.Collections.ObjectModel.ReadOnlyDictionary`2 : object {
private IDictionary`2<TKey, TValue> m_dictionary
private object m_syncRoot
private KeyCollection<TKey, TValue> m_keys
private ValueCollection<TKey, TValue> m_values
protected IDictionary`2<TKey, TValue> Dictionary
public KeyCollection<TKey, TValue> Keys
public ValueCollection<TKey, TValue> Values
private ICollection`1<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.Keys
private ICollection`1<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.Values
public TValue Item
private TValue System.Collections.Generic.IDictionary<TKey,TValue>.Item
public int Count
private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.IsReadOnly
private bool System.Collections.IDictionary.IsFixedSize
private bool System.Collections.IDictionary.IsReadOnly
private ICollection System.Collections.IDictionary.Keys
private ICollection System.Collections.IDictionary.Values
private object System.Collections.IDictionary.Item
private bool System.Collections.ICollection.IsSynchronized
private object System.Collections.ICollection.SyncRoot
private IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Keys
private IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Values
public void .ctor(IDictionary`2<TKey, TValue> dictionary)
protected IDictionary`2<TKey, TValue> get_Dictionary()
public KeyCollection<TKey, TValue> get_Keys()
public ValueCollection<TKey, TValue> get_Values()
public bool ContainsKey(TKey key)
private ICollection`1<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.get_Keys()
public bool TryGetValue(TKey key, TValue& value)
private ICollection`1<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.get_Values()
public TValue get_Item(TKey key)
private void System.Collections.Generic.IDictionary<TKey,TValue>.Add(TKey key, TValue value)
private bool System.Collections.Generic.IDictionary<TKey,TValue>.Remove(TKey key)
private TValue System.Collections.Generic.IDictionary<TKey,TValue>.get_Item(TKey key)
private void System.Collections.Generic.IDictionary<TKey,TValue>.set_Item(TKey key, TValue value)
public int get_Count()
private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Contains(KeyValuePair`2<TKey, TValue> item)
private void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.CopyTo(KeyValuePair`2[] array, int arrayIndex)
private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.get_IsReadOnly()
private void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Add(KeyValuePair`2<TKey, TValue> item)
private void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Clear()
private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Remove(KeyValuePair`2<TKey, TValue> item)
public IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
private bool IsCompatibleKey(object key)
private void System.Collections.IDictionary.Add(object key, object value)
private void System.Collections.IDictionary.Clear()
private bool System.Collections.IDictionary.Contains(object key)
private IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator()
private bool System.Collections.IDictionary.get_IsFixedSize()
private bool System.Collections.IDictionary.get_IsReadOnly()
private ICollection System.Collections.IDictionary.get_Keys()
private void System.Collections.IDictionary.Remove(object key)
private ICollection System.Collections.IDictionary.get_Values()
private object System.Collections.IDictionary.get_Item(object key)
private void System.Collections.IDictionary.set_Item(object key, object value)
private void System.Collections.ICollection.CopyTo(Array array, int index)
private bool System.Collections.ICollection.get_IsSynchronized()
private object System.Collections.ICollection.get_SyncRoot()
private IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Keys()
private IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Values()
}
internal System.Collections.ObjectModel.ReadOnlyDictionaryHelpers : object {
internal void CopyToNonGenericICollectionHelper(ICollection`1<T> collection, Array array, int index)
}
public System.Collections.Queue : object {
private Object[] _array
private int _head
private int _tail
private int _size
private int _growFactor
private int _version
private object _syncRoot
private int _MinimumGrow
private int _ShrinkThreshold
public int Count
public bool IsSynchronized
public object SyncRoot
public void .ctor(int capacity)
public void .ctor(int capacity, float growFactor)
public void .ctor(ICollection col)
public int get_Count()
public object Clone()
public bool get_IsSynchronized()
public object get_SyncRoot()
public void Clear()
public void CopyTo(Array array, int index)
public void Enqueue(object obj)
public IEnumerator GetEnumerator()
public object Dequeue()
public object Peek()
public Queue Synchronized(Queue queue)
public bool Contains(object obj)
internal object GetElement(int i)
public Object[] ToArray()
private void SetCapacity(int capacity)
public void TrimToSize()
}
public System.Collections.ReadOnlyCollectionBase : object {
private ArrayList list
protected ArrayList InnerList
public int Count
private bool System.Collections.ICollection.IsSynchronized
private object System.Collections.ICollection.SyncRoot
protected ArrayList get_InnerList()
public int get_Count()
private bool System.Collections.ICollection.get_IsSynchronized()
private object System.Collections.ICollection.get_SyncRoot()
private void System.Collections.ICollection.CopyTo(Array array, int index)
public IEnumerator GetEnumerator()
}
public System.Collections.SortedList : object {
private Object[] keys
private Object[] values
private int _size
private int version
private IComparer comparer
private KeyList keyList
private ValueList valueList
private object _syncRoot
private int _defaultCapacity
private Object[] emptyArray
public int Capacity
public int Count
public ICollection Keys
public ICollection Values
public bool IsReadOnly
public bool IsFixedSize
public bool IsSynchronized
public object SyncRoot
public object Item
private void Init()
public void .ctor(int initialCapacity)
public void .ctor(IComparer comparer)
public void .ctor(IComparer comparer, int capacity)
public void .ctor(IDictionary d)
public void .ctor(IDictionary d, IComparer comparer)
public void Add(object key, object value)
public int get_Capacity()
public void set_Capacity(int value)
public int get_Count()
public ICollection get_Keys()
public ICollection get_Values()
public bool get_IsReadOnly()
public bool get_IsFixedSize()
public bool get_IsSynchronized()
public object get_SyncRoot()
public void Clear()
public object Clone()
public bool Contains(object key)
public bool ContainsKey(object key)
public bool ContainsValue(object value)
public void CopyTo(Array array, int arrayIndex)
internal KeyValuePairs[] ToKeyValuePairsArray()
private void EnsureCapacity(int min)
public object GetByIndex(int index)
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
public IDictionaryEnumerator GetEnumerator()
public object GetKey(int index)
public IList GetKeyList()
public IList GetValueList()
public object get_Item(object key)
public void set_Item(object key, object value)
public int IndexOfKey(object key)
public int IndexOfValue(object value)
private void Insert(int index, object key, object value)
public void RemoveAt(int index)
public void Remove(object key)
public void SetByIndex(int index, object value)
public SortedList Synchronized(SortedList list)
public void TrimToSize()
}
public System.Collections.Stack : object {
private Object[] _array
private int _size
private int _version
private object _syncRoot
private int _defaultCapacity
public int Count
public bool IsSynchronized
public object SyncRoot
public void .ctor(int initialCapacity)
public void .ctor(ICollection col)
public int get_Count()
public bool get_IsSynchronized()
public object get_SyncRoot()
public void Clear()
public object Clone()
public bool Contains(object obj)
public void CopyTo(Array array, int index)
public IEnumerator GetEnumerator()
public object Peek()
public object Pop()
public void Push(object obj)
public Stack Synchronized(Stack stack)
public Object[] ToArray()
}
internal System.Collections.StructuralComparer : object {
public int Compare(object x, object y)
}
public System.Collections.StructuralComparisons : object {
private IComparer modreq(System.Runtime.CompilerServices.IsVolatile) s_StructuralComparer
private IEqualityComparer modreq(System.Runtime.CompilerServices.IsVolatile) s_StructuralEqualityComparer
public IComparer StructuralComparer
public IEqualityComparer StructuralEqualityComparer
public IComparer get_StructuralComparer()
public IEqualityComparer get_StructuralEqualityComparer()
}
internal System.Collections.StructuralEqualityComparer : object {
public bool Equals(object x, object y)
public int GetHashCode(object obj)
}
public System.Comparison`1 : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public int Invoke(T x, T y)
public IAsyncResult BeginInvoke(T x, T y, AsyncCallback callback, object object)
public int EndInvoke(IAsyncResult result)
}
internal System.CompatibilitySwitches : object {
public bool IsAppEarlierThanSilverlight4
public bool IsAppEarlierThanWindowsPhone8
}
public System.Configuration.Assemblies.AssemblyHash : ValueType {
private AssemblyHashAlgorithm _algorithm
private Byte[] _value
public AssemblyHash Empty
public AssemblyHashAlgorithm Algorithm
public AssemblyHashAlgorithm get_Algorithm()
public void set_Algorithm(AssemblyHashAlgorithm value)
public void .ctor(AssemblyHashAlgorithm algorithm, Byte[] value)
public void .ctor(Byte[] value)
public object Clone()
public Byte[] GetValue()
public void SetValue(Byte[] value)
}
public System.Configuration.Assemblies.AssemblyHashAlgorithm : Enum {
public int value__
public AssemblyHashAlgorithm None
public AssemblyHashAlgorithm MD5
public AssemblyHashAlgorithm SHA1
public AssemblyHashAlgorithm SHA256
public AssemblyHashAlgorithm SHA384
public AssemblyHashAlgorithm SHA512
}
public System.Configuration.Assemblies.AssemblyVersionCompatibility : Enum {
public int value__
public AssemblyVersionCompatibility SameMachine
public AssemblyVersionCompatibility SameProcess
public AssemblyVersionCompatibility SameDomain
}
public System.Console : object {
internal TextWriter stdout
private TextWriter stderr
private TextReader stdin
private Encoding inputEncoding
private Encoding outputEncoding
private ConsoleCancelEventHandler cancel_event
private InternalCancelHandler cancel_handler
public TextWriter Error
public TextWriter Out
public TextReader In
public Encoding InputEncoding
public Encoding OutputEncoding
public ConsoleColor BackgroundColor
public int BufferHeight
public int BufferWidth
public bool CapsLock
public int CursorLeft
public int CursorTop
public int CursorSize
public bool CursorVisible
public ConsoleColor ForegroundColor
public bool KeyAvailable
public int LargestWindowHeight
public int LargestWindowWidth
public bool NumberLock
public string Title
public bool TreatControlCAsInput
public int WindowHeight
public int WindowLeft
public int WindowTop
public int WindowWidth
public bool IsErrorRedirected
public bool IsOutputRedirected
public bool IsInputRedirected
private void SetupStreams(Encoding inputEncoding, Encoding outputEncoding)
public TextWriter get_Error()
public TextWriter get_Out()
public TextReader get_In()
private Stream Open(IntPtr handle, FileAccess access, int bufferSize)
public Stream OpenStandardError()
public Stream OpenStandardError(int bufferSize)
public Stream OpenStandardInput()
public Stream OpenStandardInput(int bufferSize)
public Stream OpenStandardOutput()
public Stream OpenStandardOutput(int bufferSize)
public void SetError(TextWriter newError)
public void SetIn(TextReader newIn)
public void SetOut(TextWriter newOut)
public void Write(bool value)
public void Write(char value)
public void Write(Char[] buffer)
public void Write(decimal value)
public void Write(double value)
public void Write(int value)
public void Write(long value)
public void Write(object value)
public void Write(float value)
public void Write(string value)
public void Write(UInt32 value)
public void Write(ulong value)
public void Write(string format, object arg0)
public void Write(string format, Object[] arg)
public void Write(Char[] buffer, int index, int count)
public void Write(string format, object arg0, object arg1)
public void Write(string format, object arg0, object arg1, object arg2)
public void Write(string format, object arg0, object arg1, object arg2, object arg3)
public void WriteLine()
public void WriteLine(bool value)
public void WriteLine(char value)
public void WriteLine(Char[] buffer)
public void WriteLine(decimal value)
public void WriteLine(double value)
public void WriteLine(int value)
public void WriteLine(long value)
public void WriteLine(object value)
public void WriteLine(float value)
public void WriteLine(string value)
public void WriteLine(UInt32 value)
public void WriteLine(ulong value)
public void WriteLine(string format, object arg0)
public void WriteLine(string format, Object[] arg)
public void WriteLine(Char[] buffer, int index, int count)
public void WriteLine(string format, object arg0, object arg1)
public void WriteLine(string format, object arg0, object arg1, object arg2)
public void WriteLine(string format, object arg0, object arg1, object arg2, object arg3)
public int Read()
public string ReadLine()
public Encoding get_InputEncoding()
public void set_InputEncoding(Encoding value)
public Encoding get_OutputEncoding()
public void set_OutputEncoding(Encoding value)
public ConsoleColor get_BackgroundColor()
public void set_BackgroundColor(ConsoleColor value)
public int get_BufferHeight()
public void set_BufferHeight(int value)
public int get_BufferWidth()
public void set_BufferWidth(int value)
public bool get_CapsLock()
public int get_CursorLeft()
public void set_CursorLeft(int value)
public int get_CursorTop()
public void set_CursorTop(int value)
public int get_CursorSize()
public void set_CursorSize(int value)
public bool get_CursorVisible()
public void set_CursorVisible(bool value)
public ConsoleColor get_ForegroundColor()
public void set_ForegroundColor(ConsoleColor value)
public bool get_KeyAvailable()
public int get_LargestWindowHeight()
public int get_LargestWindowWidth()
public bool get_NumberLock()
public string get_Title()
public void set_Title(string value)
public bool get_TreatControlCAsInput()
public void set_TreatControlCAsInput(bool value)
public int get_WindowHeight()
public void set_WindowHeight(int value)
public int get_WindowLeft()
public void set_WindowLeft(int value)
public int get_WindowTop()
public void set_WindowTop(int value)
public int get_WindowWidth()
public void set_WindowWidth(int value)
public bool get_IsErrorRedirected()
public bool get_IsOutputRedirected()
public bool get_IsInputRedirected()
public void Beep()
public void Beep(int frequency, int duration)
public void Clear()
public void MoveBufferArea(int sourceLeft, int sourceTop, int sourceWidth, int sourceHeight, int targetLeft, int targetTop)
public void MoveBufferArea(int sourceLeft, int sourceTop, int sourceWidth, int sourceHeight, int targetLeft, int targetTop, char sourceChar, ConsoleColor sourceForeColor, ConsoleColor sourceBackColor)
public ConsoleKeyInfo ReadKey()
public ConsoleKeyInfo ReadKey(bool intercept)
public void ResetColor()
public void SetBufferSize(int width, int height)
public void SetCursorPosition(int left, int top)
public void SetWindowPosition(int left, int top)
public void SetWindowSize(int width, int height)
public void add_CancelKeyPress(ConsoleCancelEventHandler value)
public void remove_CancelKeyPress(ConsoleCancelEventHandler value)
internal void DoConsoleCancelEvent()
}
public System.ConsoleCancelEventArgs : EventArgs {
private ConsoleSpecialKey _type
private bool _cancel
public bool Cancel
public ConsoleSpecialKey SpecialKey
internal void .ctor(ConsoleSpecialKey type)
public bool get_Cancel()
public void set_Cancel(bool value)
public ConsoleSpecialKey get_SpecialKey()
}
public System.ConsoleCancelEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, ConsoleCancelEventArgs e)
public IAsyncResult BeginInvoke(object sender, ConsoleCancelEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.ConsoleColor : Enum {
public int value__
public ConsoleColor Black
public ConsoleColor DarkBlue
public ConsoleColor DarkGreen
public ConsoleColor DarkCyan
public ConsoleColor DarkRed
public ConsoleColor DarkMagenta
public ConsoleColor DarkYellow
public ConsoleColor Gray
public ConsoleColor DarkGray
public ConsoleColor Blue
public ConsoleColor Green
public ConsoleColor Cyan
public ConsoleColor Red
public ConsoleColor Magenta
public ConsoleColor Yellow
public ConsoleColor White
}
internal System.ConsoleCursorInfo : ValueType {
public int Size
public bool Visible
}
internal System.ConsoleDriver : object {
internal IConsoleDriver driver
private bool is_console
private bool called_isatty
public bool Initialized
public ConsoleColor BackgroundColor
public int BufferHeight
public int BufferWidth
public bool CapsLock
public int CursorLeft
public int CursorSize
public int CursorTop
public bool CursorVisible
public bool KeyAvailable
public ConsoleColor ForegroundColor
public int LargestWindowHeight
public int LargestWindowWidth
public bool NumberLock
public string Title
public bool TreatControlCAsInput
public int WindowHeight
public int WindowLeft
public int WindowTop
public int WindowWidth
public bool IsErrorRedirected
public bool IsOutputRedirected
public bool IsInputRedirected
public bool IsConsole
private IConsoleDriver CreateNullConsoleDriver()
private IConsoleDriver CreateWindowsConsoleDriver()
private IConsoleDriver CreateTermInfoDriver(string term)
public bool get_Initialized()
public ConsoleColor get_BackgroundColor()
public void set_BackgroundColor(ConsoleColor value)
public int get_BufferHeight()
public void set_BufferHeight(int value)
public int get_BufferWidth()
public void set_BufferWidth(int value)
public bool get_CapsLock()
public int get_CursorLeft()
public void set_CursorLeft(int value)
public int get_CursorSize()
public void set_CursorSize(int value)
public int get_CursorTop()
public void set_CursorTop(int value)
public bool get_CursorVisible()
public void set_CursorVisible(bool value)
public bool get_KeyAvailable()
public ConsoleColor get_ForegroundColor()
public void set_ForegroundColor(ConsoleColor value)
public int get_LargestWindowHeight()
public int get_LargestWindowWidth()
public bool get_NumberLock()
public string get_Title()
public void set_Title(string value)
public bool get_TreatControlCAsInput()
public void set_TreatControlCAsInput(bool value)
public int get_WindowHeight()
public void set_WindowHeight(int value)
public int get_WindowLeft()
public void set_WindowLeft(int value)
public int get_WindowTop()
public void set_WindowTop(int value)
public int get_WindowWidth()
public void set_WindowWidth(int value)
public bool get_IsErrorRedirected()
public bool get_IsOutputRedirected()
public bool get_IsInputRedirected()
public void Beep(int frequency, int duration)
public void Clear()
public void MoveBufferArea(int sourceLeft, int sourceTop, int sourceWidth, int sourceHeight, int targetLeft, int targetTop)
public void MoveBufferArea(int sourceLeft, int sourceTop, int sourceWidth, int sourceHeight, int targetLeft, int targetTop, char sourceChar, ConsoleColor sourceForeColor, ConsoleColor sourceBackColor)
public void Init()
public int Read()
public string ReadLine()
public ConsoleKeyInfo ReadKey(bool intercept)
public void ResetColor()
public void SetBufferSize(int width, int height)
public void SetCursorPosition(int left, int top)
public void SetWindowPosition(int left, int top)
public void SetWindowSize(int width, int height)
public bool get_IsConsole()
private bool Isatty(IntPtr handle)
internal int InternalKeyAvailable(int ms_timeout)
internal bool TtySetup(string keypadXmit, string teardown, Byte[]& control_characters, Int32*& address)
internal bool SetEcho(bool wantEcho)
internal bool SetBreak(bool wantBreak)
}
public System.ConsoleKey : Enum {
public int value__
public ConsoleKey Backspace
public ConsoleKey Tab
public ConsoleKey Clear
public ConsoleKey Enter
public ConsoleKey Pause
public ConsoleKey Escape
public ConsoleKey Spacebar
public ConsoleKey PageUp
public ConsoleKey PageDown
public ConsoleKey End
public ConsoleKey Home
public ConsoleKey LeftArrow
public ConsoleKey UpArrow
public ConsoleKey RightArrow
public ConsoleKey DownArrow
public ConsoleKey Select
public ConsoleKey Print
public ConsoleKey Execute
public ConsoleKey PrintScreen
public ConsoleKey Insert
public ConsoleKey Delete
public ConsoleKey Help
public ConsoleKey D0
public ConsoleKey D1
public ConsoleKey D2
public ConsoleKey D3
public ConsoleKey D4
public ConsoleKey D5
public ConsoleKey D6
public ConsoleKey D7
public ConsoleKey D8
public ConsoleKey D9
public ConsoleKey A
public ConsoleKey B
public ConsoleKey C
public ConsoleKey D
public ConsoleKey E
public ConsoleKey F
public ConsoleKey G
public ConsoleKey H
public ConsoleKey I
public ConsoleKey J
public ConsoleKey K
public ConsoleKey L
public ConsoleKey M
public ConsoleKey N
public ConsoleKey O
public ConsoleKey P
public ConsoleKey Q
public ConsoleKey R
public ConsoleKey S
public ConsoleKey T
public ConsoleKey U
public ConsoleKey V
public ConsoleKey W
public ConsoleKey X
public ConsoleKey Y
public ConsoleKey Z
public ConsoleKey LeftWindows
public ConsoleKey RightWindows
public ConsoleKey Applications
public ConsoleKey Sleep
public ConsoleKey NumPad0
public ConsoleKey NumPad1
public ConsoleKey NumPad2
public ConsoleKey NumPad3
public ConsoleKey NumPad4
public ConsoleKey NumPad5
public ConsoleKey NumPad6
public ConsoleKey NumPad7
public ConsoleKey NumPad8
public ConsoleKey NumPad9
public ConsoleKey Multiply
public ConsoleKey Add
public ConsoleKey Separator
public ConsoleKey Subtract
public ConsoleKey Decimal
public ConsoleKey Divide
public ConsoleKey F1
public ConsoleKey F2
public ConsoleKey F3
public ConsoleKey F4
public ConsoleKey F5
public ConsoleKey F6
public ConsoleKey F7
public ConsoleKey F8
public ConsoleKey F9
public ConsoleKey F10
public ConsoleKey F11
public ConsoleKey F12
public ConsoleKey F13
public ConsoleKey F14
public ConsoleKey F15
public ConsoleKey F16
public ConsoleKey F17
public ConsoleKey F18
public ConsoleKey F19
public ConsoleKey F20
public ConsoleKey F21
public ConsoleKey F22
public ConsoleKey F23
public ConsoleKey F24
public ConsoleKey BrowserBack
public ConsoleKey BrowserForward
public ConsoleKey BrowserRefresh
public ConsoleKey BrowserStop
public ConsoleKey BrowserSearch
public ConsoleKey BrowserFavorites
public ConsoleKey BrowserHome
public ConsoleKey VolumeMute
public ConsoleKey VolumeDown
public ConsoleKey VolumeUp
public ConsoleKey MediaNext
public ConsoleKey MediaPrevious
public ConsoleKey MediaStop
public ConsoleKey MediaPlay
public ConsoleKey LaunchMail
public ConsoleKey LaunchMediaSelect
public ConsoleKey LaunchApp1
public ConsoleKey LaunchApp2
public ConsoleKey Oem1
public ConsoleKey OemPlus
public ConsoleKey OemComma
public ConsoleKey OemMinus
public ConsoleKey OemPeriod
public ConsoleKey Oem2
public ConsoleKey Oem3
public ConsoleKey Oem4
public ConsoleKey Oem5
public ConsoleKey Oem6
public ConsoleKey Oem7
public ConsoleKey Oem8
public ConsoleKey Oem102
public ConsoleKey Process
public ConsoleKey Packet
public ConsoleKey Attention
public ConsoleKey CrSel
public ConsoleKey ExSel
public ConsoleKey EraseEndOfFile
public ConsoleKey Play
public ConsoleKey Zoom
public ConsoleKey NoName
public ConsoleKey Pa1
public ConsoleKey OemClear
}
public System.ConsoleKeyInfo : ValueType {
private char _keyChar
private ConsoleKey _key
private ConsoleModifiers _mods
public char KeyChar
public ConsoleKey Key
public ConsoleModifiers Modifiers
public void .ctor(char keyChar, ConsoleKey key, bool shift, bool alt, bool control)
public char get_KeyChar()
public ConsoleKey get_Key()
public ConsoleModifiers get_Modifiers()
public bool Equals(object value)
public bool Equals(ConsoleKeyInfo obj)
public bool op_Equality(ConsoleKeyInfo a, ConsoleKeyInfo b)
public bool op_Inequality(ConsoleKeyInfo a, ConsoleKeyInfo b)
public int GetHashCode()
}
public System.ConsoleModifiers : Enum {
public int value__
public ConsoleModifiers Alt
public ConsoleModifiers Shift
public ConsoleModifiers Control
}
internal System.ConsoleScreenBufferInfo : ValueType {
public Coord Size
public Coord CursorPosition
public short Attribute
public SmallRect Window
public Coord MaxWindowSize
}
public System.ConsoleSpecialKey : Enum {
public int value__
public ConsoleSpecialKey ControlC
public ConsoleSpecialKey ControlBreak
}
public System.ContextMarshalException : SystemException {
public void .ctor(string message)
public void .ctor(string message, Exception inner)
protected void .ctor(SerializationInfo info, StreamingContext context)
}
internal System.ControlCharacters : object {
public int Intr
public int Quit
public int Erase
public int Kill
public int EOF
public int Time
public int Min
public int SWTC
public int Start
public int Stop
public int Susp
public int EOL
public int Reprint
public int Discard
public int WErase
public int LNext
public int EOL2
}
public System.Convert : object {
internal RuntimeType[] ConvertTypes
private RuntimeType EnumType
internal Char[] base64Table
private int base64LineBreakPosition
public object DBNull
public TypeCode GetTypeCode(object value)
public bool IsDBNull(object value)
public object ChangeType(object value, TypeCode typeCode)
public object ChangeType(object value, TypeCode typeCode, IFormatProvider provider)
internal object DefaultToType(IConvertible value, Type targetType, IFormatProvider provider)
public object ChangeType(object value, Type conversionType)
public object ChangeType(object value, Type conversionType, IFormatProvider provider)
public bool ToBoolean(object value)
public bool ToBoolean(object value, IFormatProvider provider)
public bool ToBoolean(bool value)
public bool ToBoolean(sbyte value)
public bool ToBoolean(char value)
public bool ToBoolean(byte value)
public bool ToBoolean(short value)
public bool ToBoolean(ushort value)
public bool ToBoolean(int value)
public bool ToBoolean(UInt32 value)
public bool ToBoolean(long value)
public bool ToBoolean(ulong value)
public bool ToBoolean(string value)
public bool ToBoolean(string value, IFormatProvider provider)
public bool ToBoolean(float value)
public bool ToBoolean(double value)
public bool ToBoolean(decimal value)
public bool ToBoolean(DateTime value)
public char ToChar(object value)
public char ToChar(object value, IFormatProvider provider)
public char ToChar(bool value)
public char ToChar(char value)
public char ToChar(sbyte value)
public char ToChar(byte value)
public char ToChar(short value)
public char ToChar(ushort value)
public char ToChar(int value)
public char ToChar(UInt32 value)
public char ToChar(long value)
public char ToChar(ulong value)
public char ToChar(string value)
public char ToChar(string value, IFormatProvider provider)
public char ToChar(float value)
public char ToChar(double value)
public char ToChar(decimal value)
public char ToChar(DateTime value)
public sbyte ToSByte(object value)
public sbyte ToSByte(object value, IFormatProvider provider)
public sbyte ToSByte(bool value)
public sbyte ToSByte(sbyte value)
public sbyte ToSByte(char value)
public sbyte ToSByte(byte value)
public sbyte ToSByte(short value)
public sbyte ToSByte(ushort value)
public sbyte ToSByte(int value)
public sbyte ToSByte(UInt32 value)
public sbyte ToSByte(long value)
public sbyte ToSByte(ulong value)
public sbyte ToSByte(float value)
public sbyte ToSByte(double value)
public sbyte ToSByte(decimal value)
public sbyte ToSByte(string value)
public sbyte ToSByte(string value, IFormatProvider provider)
public sbyte ToSByte(DateTime value)
public byte ToByte(object value)
public byte ToByte(object value, IFormatProvider provider)
public byte ToByte(bool value)
public byte ToByte(byte value)
public byte ToByte(char value)
public byte ToByte(sbyte value)
public byte ToByte(short value)
public byte ToByte(ushort value)
public byte ToByte(int value)
public byte ToByte(UInt32 value)
public byte ToByte(long value)
public byte ToByte(ulong value)
public byte ToByte(float value)
public byte ToByte(double value)
public byte ToByte(decimal value)
public byte ToByte(string value)
public byte ToByte(string value, IFormatProvider provider)
public byte ToByte(DateTime value)
public short ToInt16(object value)
public short ToInt16(object value, IFormatProvider provider)
public short ToInt16(bool value)
public short ToInt16(char value)
public short ToInt16(sbyte value)
public short ToInt16(byte value)
public short ToInt16(ushort value)
public short ToInt16(int value)
public short ToInt16(UInt32 value)
public short ToInt16(short value)
public short ToInt16(long value)
public short ToInt16(ulong value)
public short ToInt16(float value)
public short ToInt16(double value)
public short ToInt16(decimal value)
public short ToInt16(string value)
public short ToInt16(string value, IFormatProvider provider)
public short ToInt16(DateTime value)
public ushort ToUInt16(object value)
public ushort ToUInt16(object value, IFormatProvider provider)
public ushort ToUInt16(bool value)
public ushort ToUInt16(char value)
public ushort ToUInt16(sbyte value)
public ushort ToUInt16(byte value)
public ushort ToUInt16(short value)
public ushort ToUInt16(int value)
public ushort ToUInt16(ushort value)
public ushort ToUInt16(UInt32 value)
public ushort ToUInt16(long value)
public ushort ToUInt16(ulong value)
public ushort ToUInt16(float value)
public ushort ToUInt16(double value)
public ushort ToUInt16(decimal value)
public ushort ToUInt16(string value)
public ushort ToUInt16(string value, IFormatProvider provider)
public ushort ToUInt16(DateTime value)
public int ToInt32(object value)
public int ToInt32(object value, IFormatProvider provider)
public int ToInt32(bool value)
public int ToInt32(char value)
public int ToInt32(sbyte value)
public int ToInt32(byte value)
public int ToInt32(short value)
public int ToInt32(ushort value)
public int ToInt32(UInt32 value)
public int ToInt32(int value)
public int ToInt32(long value)
public int ToInt32(ulong value)
public int ToInt32(float value)
public int ToInt32(double value)
public int ToInt32(decimal value)
public int ToInt32(string value)
public int ToInt32(string value, IFormatProvider provider)
public int ToInt32(DateTime value)
public UInt32 ToUInt32(object value)
public UInt32 ToUInt32(object value, IFormatProvider provider)
public UInt32 ToUInt32(bool value)
public UInt32 ToUInt32(char value)
public UInt32 ToUInt32(sbyte value)
public UInt32 ToUInt32(byte value)
public UInt32 ToUInt32(short value)
public UInt32 ToUInt32(ushort value)
public UInt32 ToUInt32(int value)
public UInt32 ToUInt32(UInt32 value)
public UInt32 ToUInt32(long value)
public UInt32 ToUInt32(ulong value)
public UInt32 ToUInt32(float value)
public UInt32 ToUInt32(double value)
public UInt32 ToUInt32(decimal value)
public UInt32 ToUInt32(string value)
public UInt32 ToUInt32(string value, IFormatProvider provider)
public UInt32 ToUInt32(DateTime value)
public long ToInt64(object value)
public long ToInt64(object value, IFormatProvider provider)
public long ToInt64(bool value)
public long ToInt64(char value)
public long ToInt64(sbyte value)
public long ToInt64(byte value)
public long ToInt64(short value)
public long ToInt64(ushort value)
public long ToInt64(int value)
public long ToInt64(UInt32 value)
public long ToInt64(ulong value)
public long ToInt64(long value)
public long ToInt64(float value)
public long ToInt64(double value)
public long ToInt64(decimal value)
public long ToInt64(string value)
public long ToInt64(string value, IFormatProvider provider)
public long ToInt64(DateTime value)
public ulong ToUInt64(object value)
public ulong ToUInt64(object value, IFormatProvider provider)
public ulong ToUInt64(bool value)
public ulong ToUInt64(char value)
public ulong ToUInt64(sbyte value)
public ulong ToUInt64(byte value)
public ulong ToUInt64(short value)
public ulong ToUInt64(ushort value)
public ulong ToUInt64(int value)
public ulong ToUInt64(UInt32 value)
public ulong ToUInt64(long value)
public ulong ToUInt64(ulong value)
public ulong ToUInt64(float value)
public ulong ToUInt64(double value)
public ulong ToUInt64(decimal value)
public ulong ToUInt64(string value)
public ulong ToUInt64(string value, IFormatProvider provider)
public ulong ToUInt64(DateTime value)
public float ToSingle(object value)
public float ToSingle(object value, IFormatProvider provider)
public float ToSingle(sbyte value)
public float ToSingle(byte value)
public float ToSingle(char value)
public float ToSingle(short value)
public float ToSingle(ushort value)
public float ToSingle(int value)
public float ToSingle(UInt32 value)
public float ToSingle(long value)
public float ToSingle(ulong value)
public float ToSingle(float value)
public float ToSingle(double value)
public float ToSingle(decimal value)
public float ToSingle(string value)
public float ToSingle(string value, IFormatProvider provider)
public float ToSingle(bool value)
public float ToSingle(DateTime value)
public double ToDouble(object value)
public double ToDouble(object value, IFormatProvider provider)
public double ToDouble(sbyte value)
public double ToDouble(byte value)
public double ToDouble(short value)
public double ToDouble(char value)
public double ToDouble(ushort value)
public double ToDouble(int value)
public double ToDouble(UInt32 value)
public double ToDouble(long value)
public double ToDouble(ulong value)
public double ToDouble(float value)
public double ToDouble(double value)
public double ToDouble(decimal value)
public double ToDouble(string value)
public double ToDouble(string value, IFormatProvider provider)
public double ToDouble(bool value)
public double ToDouble(DateTime value)
public decimal ToDecimal(object value)
public decimal ToDecimal(object value, IFormatProvider provider)
public decimal ToDecimal(sbyte value)
public decimal ToDecimal(byte value)
public decimal ToDecimal(char value)
public decimal ToDecimal(short value)
public decimal ToDecimal(ushort value)
public decimal ToDecimal(int value)
public decimal ToDecimal(UInt32 value)
public decimal ToDecimal(long value)
public decimal ToDecimal(ulong value)
public decimal ToDecimal(float value)
public decimal ToDecimal(double value)
public decimal ToDecimal(string value)
public decimal ToDecimal(string value, IFormatProvider provider)
public decimal ToDecimal(decimal value)
public decimal ToDecimal(bool value)
public decimal ToDecimal(DateTime value)
public DateTime ToDateTime(DateTime value)
public DateTime ToDateTime(object value)
public DateTime ToDateTime(object value, IFormatProvider provider)
public DateTime ToDateTime(string value)
public DateTime ToDateTime(string value, IFormatProvider provider)
public DateTime ToDateTime(sbyte value)
public DateTime ToDateTime(byte value)
public DateTime ToDateTime(short value)
public DateTime ToDateTime(ushort value)
public DateTime ToDateTime(int value)
public DateTime ToDateTime(UInt32 value)
public DateTime ToDateTime(long value)
public DateTime ToDateTime(ulong value)
public DateTime ToDateTime(bool value)
public DateTime ToDateTime(char value)
public DateTime ToDateTime(float value)
public DateTime ToDateTime(double value)
public DateTime ToDateTime(decimal value)
public string ToString(object value)
public string ToString(object value, IFormatProvider provider)
public string ToString(bool value)
public string ToString(bool value, IFormatProvider provider)
public string ToString(char value)
public string ToString(char value, IFormatProvider provider)
public string ToString(sbyte value)
public string ToString(sbyte value, IFormatProvider provider)
public string ToString(byte value)
public string ToString(byte value, IFormatProvider provider)
public string ToString(short value)
public string ToString(short value, IFormatProvider provider)
public string ToString(ushort value)
public string ToString(ushort value, IFormatProvider provider)
public string ToString(int value)
public string ToString(int value, IFormatProvider provider)
public string ToString(UInt32 value)
public string ToString(UInt32 value, IFormatProvider provider)
public string ToString(long value)
public string ToString(long value, IFormatProvider provider)
public string ToString(ulong value)
public string ToString(ulong value, IFormatProvider provider)
public string ToString(float value)
public string ToString(float value, IFormatProvider provider)
public string ToString(double value)
public string ToString(double value, IFormatProvider provider)
public string ToString(decimal value)
public string ToString(decimal value, IFormatProvider provider)
public string ToString(DateTime value)
public string ToString(DateTime value, IFormatProvider provider)
public string ToString(string value)
public string ToString(string value, IFormatProvider provider)
public byte ToByte(string value, int fromBase)
public sbyte ToSByte(string value, int fromBase)
public short ToInt16(string value, int fromBase)
public ushort ToUInt16(string value, int fromBase)
public int ToInt32(string value, int fromBase)
public UInt32 ToUInt32(string value, int fromBase)
public long ToInt64(string value, int fromBase)
public ulong ToUInt64(string value, int fromBase)
public string ToString(byte value, int toBase)
public string ToString(short value, int toBase)
public string ToString(int value, int toBase)
public string ToString(long value, int toBase)
public string ToBase64String(Byte[] inArray)
public string ToBase64String(Byte[] inArray, Base64FormattingOptions options)
public string ToBase64String(Byte[] inArray, int offset, int length)
public string ToBase64String(Byte[] inArray, int offset, int length, Base64FormattingOptions options)
public int ToBase64CharArray(Byte[] inArray, int offsetIn, int length, Char[] outArray, int offsetOut)
public int ToBase64CharArray(Byte[] inArray, int offsetIn, int length, Char[] outArray, int offsetOut, Base64FormattingOptions options)
private int ConvertToBase64Array(Char* outChars, Byte* inData, int offset, int length, bool insertLineBreaks)
private int ToBase64_CalculateAndValidateOutputLength(int inputLength, bool insertLineBreaks)
public Byte[] FromBase64String(string s)
public Byte[] FromBase64CharArray(Char[] inArray, int offset, int length)
private Byte[] FromBase64CharPtr(Char* inputPtr, int inputLength)
private int FromBase64_Decode(Char* startInputPtr, int inputLength, Byte* startDestPtr, int destLength)
private int FromBase64_ComputeResultLength(Char* inputPtr, int inputLength)
}
public System.Converter`2 : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public TOutput Invoke(TInput input)
public IAsyncResult BeginInvoke(TInput input, AsyncCallback callback, object object)
public TOutput EndInvoke(IAsyncResult result)
}
internal System.Coord : ValueType {
public short X
public short Y
public void .ctor(int x, int y)
}
public System.CrossAppDomainDelegate : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke()
public IAsyncResult BeginInvoke(AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
internal System.CtorDelegate : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object instance)
public IAsyncResult BeginInvoke(object instance, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
internal System.CultureAwareComparer : StringComparer {
private CompareInfo _compareInfo
private bool _ignoreCase
private CompareOptions _options
internal void .ctor(CultureInfo culture, bool ignoreCase)
internal void .ctor(CompareInfo compareInfo, bool ignoreCase)
internal void .ctor(CompareInfo compareInfo, CompareOptions options)
public int Compare(string x, string y)
public bool Equals(string x, string y)
public int GetHashCode(string obj)
public bool Equals(object obj)
public int GetHashCode()
}
internal System.CurrentSystemTimeZone : TimeZone {
private TimeZoneInfo LocalTimeZone
public string DaylightName
public string StandardName
public string get_DaylightName()
public string get_StandardName()
public DaylightTime GetDaylightChanges(int year)
public TimeSpan GetUtcOffset(DateTime dateTime)
public bool IsDaylightSavingTime(DateTime dateTime)
public bool GetTimeZoneData(int year, Int64[]& data, String[]& names, Boolean& daylight_inverted)
}
public System.DataMisalignedException : SystemException {
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
internal void .ctor(SerializationInfo info, StreamingContext context)
}
public System.DateTime : ValueType {
private long TicksPerMillisecond
private long TicksPerSecond
private long TicksPerMinute
private long TicksPerHour
private long TicksPerDay
private int MillisPerSecond
private int MillisPerMinute
private int MillisPerHour
private int MillisPerDay
private int DaysPerYear
private int DaysPer4Years
private int DaysPer100Years
private int DaysPer400Years
private int DaysTo1601
private int DaysTo1899
internal int DaysTo1970
private int DaysTo10000
internal long MinTicks
internal long MaxTicks
private long MaxMillis
private long FileTimeOffset
private long DoubleDateOffset
private long OADateMinAsTicks
private double OADateMinAsDouble
private double OADateMaxAsDouble
private int DatePartYear
private int DatePartDayOfYear
private int DatePartMonth
private int DatePartDay
private Int32[] DaysToMonth365
private Int32[] DaysToMonth366
public DateTime MinValue
public DateTime MaxValue
private ulong TicksMask
private ulong FlagsMask
private ulong LocalMask
private long TicksCeiling
private ulong KindUnspecified
private ulong KindUtc
private ulong KindLocal
private ulong KindLocalAmbiguousDst
private int KindShift
private string TicksField
private string DateDataField
private ulong dateData
internal long InternalTicks
private ulong InternalKind
public DateTime Date
public int Day
public DayOfWeek DayOfWeek
public int DayOfYear
public int Hour
public DateTimeKind Kind
public int Millisecond
public int Minute
public int Month
public DateTime Now
public DateTime UtcNow
public int Second
public long Ticks
public TimeSpan TimeOfDay
public DateTime Today
public int Year
public void .ctor(long ticks)
private void .ctor(ulong dateData)
public void .ctor(long ticks, DateTimeKind kind)
internal void .ctor(long ticks, DateTimeKind kind, bool isAmbiguousDst)
public void .ctor(int year, int month, int day)
public void .ctor(int year, int month, int day, Calendar calendar)
public void .ctor(int year, int month, int day, int hour, int minute, int second)
public void .ctor(int year, int month, int day, int hour, int minute, int second, DateTimeKind kind)
public void .ctor(int year, int month, int day, int hour, int minute, int second, Calendar calendar)
public void .ctor(int year, int month, int day, int hour, int minute, int second, int millisecond)
public void .ctor(int year, int month, int day, int hour, int minute, int second, int millisecond, DateTimeKind kind)
public void .ctor(int year, int month, int day, int hour, int minute, int second, int millisecond, Calendar calendar)
public void .ctor(int year, int month, int day, int hour, int minute, int second, int millisecond, Calendar calendar, DateTimeKind kind)
private void .ctor(SerializationInfo info, StreamingContext context)
internal long get_InternalTicks()
private ulong get_InternalKind()
public DateTime Add(TimeSpan value)
private DateTime Add(double value, int scale)
public DateTime AddDays(double value)
public DateTime AddHours(double value)
public DateTime AddMilliseconds(double value)
public DateTime AddMinutes(double value)
public DateTime AddMonths(int months)
public DateTime AddSeconds(double value)
public DateTime AddTicks(long value)
public DateTime AddYears(int value)
public int Compare(DateTime t1, DateTime t2)
public int CompareTo(object value)
public int CompareTo(DateTime value)
private long DateToTicks(int year, int month, int day)
private long TimeToTicks(int hour, int minute, int second)
public int DaysInMonth(int year, int month)
internal long DoubleDateToTicks(double value)
public bool Equals(object value)
public bool Equals(DateTime value)
public bool Equals(DateTime t1, DateTime t2)
public DateTime FromBinary(long dateData)
internal DateTime FromBinaryRaw(long dateData)
public DateTime FromFileTime(long fileTime)
public DateTime FromFileTimeUtc(long fileTime)
public DateTime FromOADate(double d)
private void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context)
public bool IsDaylightSavingTime()
public DateTime SpecifyKind(DateTime value, DateTimeKind kind)
public long ToBinary()
internal long ToBinaryRaw()
public DateTime get_Date()
private int GetDatePart(int part)
public int get_Day()
public DayOfWeek get_DayOfWeek()
public int get_DayOfYear()
public int GetHashCode()
public int get_Hour()
internal bool IsAmbiguousDaylightSavingTime()
public DateTimeKind get_Kind()
public int get_Millisecond()
public int get_Minute()
public int get_Month()
public DateTime get_Now()
public DateTime get_UtcNow()
internal long GetSystemTimeAsFileTime()
public int get_Second()
public long get_Ticks()
public TimeSpan get_TimeOfDay()
public DateTime get_Today()
public int get_Year()
public bool IsLeapYear(int year)
public DateTime Parse(string s)
public DateTime Parse(string s, IFormatProvider provider)
public DateTime Parse(string s, IFormatProvider provider, DateTimeStyles styles)
public DateTime ParseExact(string s, string format, IFormatProvider provider)
public DateTime ParseExact(string s, string format, IFormatProvider provider, DateTimeStyles style)
public DateTime ParseExact(string s, String[] formats, IFormatProvider provider, DateTimeStyles style)
public TimeSpan Subtract(DateTime value)
public DateTime Subtract(TimeSpan value)
private double TicksToOADate(long value)
public double ToOADate()
public long ToFileTime()
public long ToFileTimeUtc()
public DateTime ToLocalTime()
internal DateTime ToLocalTime(bool throwOnOverflow)
public string ToLongDateString()
public string ToLongTimeString()
public string ToShortDateString()
public string ToShortTimeString()
public string ToString()
public string ToString(string format)
public string ToString(IFormatProvider provider)
public string ToString(string format, IFormatProvider provider)
public DateTime ToUniversalTime()
public bool TryParse(string s, DateTime& result)
public bool TryParse(string s, IFormatProvider provider, DateTimeStyles styles, DateTime& result)
public bool TryParseExact(string s, string format, IFormatProvider provider, DateTimeStyles style, DateTime& result)
public bool TryParseExact(string s, String[] formats, IFormatProvider provider, DateTimeStyles style, DateTime& result)
public DateTime op_Addition(DateTime d, TimeSpan t)
public DateTime op_Subtraction(DateTime d, TimeSpan t)
public TimeSpan op_Subtraction(DateTime d1, DateTime d2)
public bool op_Equality(DateTime d1, DateTime d2)
public bool op_Inequality(DateTime d1, DateTime d2)
public bool op_LessThan(DateTime t1, DateTime t2)
public bool op_LessThanOrEqual(DateTime t1, DateTime t2)
public bool op_GreaterThan(DateTime t1, DateTime t2)
public bool op_GreaterThanOrEqual(DateTime t1, DateTime t2)
public String[] GetDateTimeFormats()
public String[] GetDateTimeFormats(IFormatProvider provider)
public String[] GetDateTimeFormats(char format)
public String[] GetDateTimeFormats(char format, IFormatProvider provider)
public TypeCode GetTypeCode()
private bool System.IConvertible.ToBoolean(IFormatProvider provider)
private char System.IConvertible.ToChar(IFormatProvider provider)
private sbyte System.IConvertible.ToSByte(IFormatProvider provider)
private byte System.IConvertible.ToByte(IFormatProvider provider)
private short System.IConvertible.ToInt16(IFormatProvider provider)
private ushort System.IConvertible.ToUInt16(IFormatProvider provider)
private int System.IConvertible.ToInt32(IFormatProvider provider)
private UInt32 System.IConvertible.ToUInt32(IFormatProvider provider)
private long System.IConvertible.ToInt64(IFormatProvider provider)
private ulong System.IConvertible.ToUInt64(IFormatProvider provider)
private float System.IConvertible.ToSingle(IFormatProvider provider)
private double System.IConvertible.ToDouble(IFormatProvider provider)
private decimal System.IConvertible.ToDecimal(IFormatProvider provider)
private DateTime System.IConvertible.ToDateTime(IFormatProvider provider)
private object System.IConvertible.ToType(Type type, IFormatProvider provider)
internal bool TryCreate(int year, int month, int day, int hour, int minute, int second, int millisecond, DateTime& result)
}
internal System.DateTimeFormat : object {
internal int MaxSecondsFractionDigits
internal TimeSpan NullOffset
internal Char[] allStandardFormats
internal string RoundtripFormat
internal string RoundtripDateTimeUnfixed
private int DEFAULT_ALL_DATETIMES_SIZE
internal String[] fixedNumberFormats
internal void FormatDigits(StringBuilder outputBuffer, int value, int len)
internal void FormatDigits(StringBuilder outputBuffer, int value, int len, bool overrideLengthLimit)
private void HebrewFormatDigits(StringBuilder outputBuffer, int digits)
internal int ParseRepeatPattern(string format, int pos, char patternChar)
private string FormatDayOfWeek(int dayOfWeek, int repeat, DateTimeFormatInfo dtfi)
private string FormatMonth(int month, int repeatCount, DateTimeFormatInfo dtfi)
private string FormatHebrewMonthName(DateTime time, int month, int repeatCount, DateTimeFormatInfo dtfi)
internal int ParseQuoteString(string format, int pos, StringBuilder result)
internal int ParseNextChar(string format, int pos)
private bool IsUseGenitiveForm(string format, int index, int tokenLen, char patternToMatch)
private string FormatCustomized(DateTime dateTime, string format, DateTimeFormatInfo dtfi, TimeSpan offset)
private void FormatCustomizedTimeZone(DateTime dateTime, TimeSpan offset, string format, int tokenLen, bool timeOnly, StringBuilder result)
private void FormatCustomizedRoundripTimeZone(DateTime dateTime, TimeSpan offset, StringBuilder result)
internal string GetRealFormat(string format, DateTimeFormatInfo dtfi)
private string ExpandPredefinedFormat(string format, DateTime& dateTime, DateTimeFormatInfo& dtfi, TimeSpan& offset)
internal string Format(DateTime dateTime, string format, DateTimeFormatInfo dtfi)
internal string Format(DateTime dateTime, string format, DateTimeFormatInfo dtfi, TimeSpan offset)
internal String[] GetAllDateTimes(DateTime dateTime, char format, DateTimeFormatInfo dtfi)
internal String[] GetAllDateTimes(DateTime dateTime, DateTimeFormatInfo dtfi)
internal void InvalidFormatForLocal(string format, DateTime dateTime)
internal void InvalidFormatForUtc(string format, DateTime dateTime)
}
public System.DateTimeKind : Enum {
public int value__
public DateTimeKind Unspecified
public DateTimeKind Utc
public DateTimeKind Local
}
public System.DateTimeOffset : ValueType {
internal long MaxOffset
internal long MinOffset
private long UnixEpochTicks
private long UnixEpochSeconds
private long UnixEpochMilliseconds
public DateTimeOffset MinValue
public DateTimeOffset MaxValue
private DateTime m_dateTime
private short m_offsetMinutes
public DateTimeOffset Now
public DateTimeOffset UtcNow
public DateTime DateTime
public DateTime UtcDateTime
public DateTime LocalDateTime
private DateTime ClockDateTime
public DateTime Date
public int Day
public DayOfWeek DayOfWeek
public int DayOfYear
public int Hour
public int Millisecond
public int Minute
public int Month
public TimeSpan Offset
public int Second
public long Ticks
public long UtcTicks
public TimeSpan TimeOfDay
public int Year
public void .ctor(long ticks, TimeSpan offset)
public void .ctor(DateTime dateTime)
public void .ctor(DateTime dateTime, TimeSpan offset)
public void .ctor(int year, int month, int day, int hour, int minute, int second, TimeSpan offset)
public void .ctor(int year, int month, int day, int hour, int minute, int second, int millisecond, TimeSpan offset)
public void .ctor(int year, int month, int day, int hour, int minute, int second, int millisecond, Calendar calendar, TimeSpan offset)
public DateTimeOffset get_Now()
public DateTimeOffset get_UtcNow()
public DateTime get_DateTime()
public DateTime get_UtcDateTime()
public DateTime get_LocalDateTime()
public DateTimeOffset ToOffset(TimeSpan offset)
private DateTime get_ClockDateTime()
public DateTime get_Date()
public int get_Day()
public DayOfWeek get_DayOfWeek()
public int get_DayOfYear()
public int get_Hour()
public int get_Millisecond()
public int get_Minute()
public int get_Month()
public TimeSpan get_Offset()
public int get_Second()
public long get_Ticks()
public long get_UtcTicks()
public TimeSpan get_TimeOfDay()
public int get_Year()
public DateTimeOffset Add(TimeSpan timeSpan)
public DateTimeOffset AddDays(double days)
public DateTimeOffset AddHours(double hours)
public DateTimeOffset AddMilliseconds(double milliseconds)
public DateTimeOffset AddMinutes(double minutes)
public DateTimeOffset AddMonths(int months)
public DateTimeOffset AddSeconds(double seconds)
public DateTimeOffset AddTicks(long ticks)
public DateTimeOffset AddYears(int years)
public int Compare(DateTimeOffset first, DateTimeOffset second)
private int System.IComparable.CompareTo(object obj)
public int CompareTo(DateTimeOffset other)
public bool Equals(object obj)
public bool Equals(DateTimeOffset other)
public bool EqualsExact(DateTimeOffset other)
public bool Equals(DateTimeOffset first, DateTimeOffset second)
public DateTimeOffset FromFileTime(long fileTime)
public DateTimeOffset FromUnixTimeSeconds(long seconds)
public DateTimeOffset FromUnixTimeMilliseconds(long milliseconds)
private void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender)
private void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context)
private void .ctor(SerializationInfo info, StreamingContext context)
public int GetHashCode()
public DateTimeOffset Parse(string input)
public DateTimeOffset Parse(string input, IFormatProvider formatProvider)
public DateTimeOffset Parse(string input, IFormatProvider formatProvider, DateTimeStyles styles)
public DateTimeOffset ParseExact(string input, string format, IFormatProvider formatProvider)
public DateTimeOffset ParseExact(string input, string format, IFormatProvider formatProvider, DateTimeStyles styles)
public DateTimeOffset ParseExact(string input, String[] formats, IFormatProvider formatProvider, DateTimeStyles styles)
public TimeSpan Subtract(DateTimeOffset value)
public DateTimeOffset Subtract(TimeSpan value)
public long ToFileTime()
public long ToUnixTimeSeconds()
public long ToUnixTimeMilliseconds()
public DateTimeOffset ToLocalTime()
internal DateTimeOffset ToLocalTime(bool throwOnOverflow)
public string ToString()
public string ToString(string format)
public string ToString(IFormatProvider formatProvider)
public string ToString(string format, IFormatProvider formatProvider)
public DateTimeOffset ToUniversalTime()
public bool TryParse(string input, DateTimeOffset& result)
public bool TryParse(string input, IFormatProvider formatProvider, DateTimeStyles styles, DateTimeOffset& result)
public bool TryParseExact(string input, string format, IFormatProvider formatProvider, DateTimeStyles styles, DateTimeOffset& result)
public bool TryParseExact(string input, String[] formats, IFormatProvider formatProvider, DateTimeStyles styles, DateTimeOffset& result)
private short ValidateOffset(TimeSpan offset)
private DateTime ValidateDate(DateTime dateTime, TimeSpan offset)
private DateTimeStyles ValidateStyles(DateTimeStyles style, string parameterName)
public DateTimeOffset op_Implicit(DateTime dateTime)
public DateTimeOffset op_Addition(DateTimeOffset dateTimeOffset, TimeSpan timeSpan)
public DateTimeOffset op_Subtraction(DateTimeOffset dateTimeOffset, TimeSpan timeSpan)
public TimeSpan op_Subtraction(DateTimeOffset left, DateTimeOffset right)
public bool op_Equality(DateTimeOffset left, DateTimeOffset right)
public bool op_Inequality(DateTimeOffset left, DateTimeOffset right)
public bool op_LessThan(DateTimeOffset left, DateTimeOffset right)
public bool op_LessThanOrEqual(DateTimeOffset left, DateTimeOffset right)
public bool op_GreaterThan(DateTimeOffset left, DateTimeOffset right)
public bool op_GreaterThanOrEqual(DateTimeOffset left, DateTimeOffset right)
}
internal System.DateTimeParse : object {
internal int MaxDateTimeNumberDigits
internal MatchNumberDelegate m_hebrewNumberParser
private DS[][] dateParsingStates
internal string GMTName
internal string ZuluName
private int ORDER_YMD
private int ORDER_MDY
private int ORDER_DMY
private int ORDER_YDM
private int ORDER_YM
private int ORDER_MY
private int ORDER_MD
private int ORDER_DM
internal DateTime ParseExact(string s, string format, DateTimeFormatInfo dtfi, DateTimeStyles style)
internal DateTime ParseExact(string s, string format, DateTimeFormatInfo dtfi, DateTimeStyles style, TimeSpan& offset)
internal bool TryParseExact(string s, string format, DateTimeFormatInfo dtfi, DateTimeStyles style, DateTime& result)
internal bool TryParseExact(string s, string format, DateTimeFormatInfo dtfi, DateTimeStyles style, DateTime& result, TimeSpan& offset)
internal bool TryParseExact(string s, string format, DateTimeFormatInfo dtfi, DateTimeStyles style, DateTimeResult& result)
internal DateTime ParseExactMultiple(string s, String[] formats, DateTimeFormatInfo dtfi, DateTimeStyles style)
internal DateTime ParseExactMultiple(string s, String[] formats, DateTimeFormatInfo dtfi, DateTimeStyles style, TimeSpan& offset)
internal bool TryParseExactMultiple(string s, String[] formats, DateTimeFormatInfo dtfi, DateTimeStyles style, DateTime& result, TimeSpan& offset)
internal bool TryParseExactMultiple(string s, String[] formats, DateTimeFormatInfo dtfi, DateTimeStyles style, DateTime& result)
internal bool TryParseExactMultiple(string s, String[] formats, DateTimeFormatInfo dtfi, DateTimeStyles style, DateTimeResult& result)
private bool MatchWord(__DTString& str, string target)
private bool GetTimeZoneName(__DTString& str)
internal bool IsDigit(char ch)
private bool ParseFraction(__DTString& str, Double& result)
private bool ParseTimeZone(__DTString& str, TimeSpan& result)
private bool HandleTimeZone(__DTString& str, DateTimeResult& result)
private bool Lex(DS dps, __DTString& str, DateTimeToken& dtok, DateTimeRawInfo& raw, DateTimeResult& result, DateTimeFormatInfo& dtfi, DateTimeStyles styles)
private bool VerifyValidPunctuation(__DTString& str)
private bool GetYearMonthDayOrder(string datePattern, DateTimeFormatInfo dtfi, Int32& order)
private bool GetYearMonthOrder(string pattern, DateTimeFormatInfo dtfi, Int32& order)
private bool GetMonthDayOrder(string pattern, DateTimeFormatInfo dtfi, Int32& order)
private bool TryAdjustYear(DateTimeResult& result, int year, Int32& adjustedYear)
private bool SetDateYMD(DateTimeResult& result, int year, int month, int day)
private bool SetDateMDY(DateTimeResult& result, int month, int day, int year)
private bool SetDateDMY(DateTimeResult& result, int day, int month, int year)
private bool SetDateYDM(DateTimeResult& result, int year, int day, int month)
private void GetDefaultYear(DateTimeResult& result, DateTimeStyles& styles)
private bool GetDayOfNN(DateTimeResult& result, DateTimeStyles& styles, DateTimeRawInfo& raw, DateTimeFormatInfo dtfi)
private bool GetDayOfNNN(DateTimeResult& result, DateTimeRawInfo& raw, DateTimeFormatInfo dtfi)
private bool GetDayOfMN(DateTimeResult& result, DateTimeStyles& styles, DateTimeRawInfo& raw, DateTimeFormatInfo dtfi)
private bool GetHebrewDayOfNM(DateTimeResult& result, DateTimeRawInfo& raw, DateTimeFormatInfo dtfi)
private bool GetDayOfNM(DateTimeResult& result, DateTimeStyles& styles, DateTimeRawInfo& raw, DateTimeFormatInfo dtfi)
private bool GetDayOfMNN(DateTimeResult& result, DateTimeRawInfo& raw, DateTimeFormatInfo dtfi)
private bool GetDayOfYNN(DateTimeResult& result, DateTimeRawInfo& raw, DateTimeFormatInfo dtfi)
private bool GetDayOfNNY(DateTimeResult& result, DateTimeRawInfo& raw, DateTimeFormatInfo dtfi)
private bool GetDayOfYMN(DateTimeResult& result, DateTimeRawInfo& raw, DateTimeFormatInfo dtfi)
private bool GetDayOfYN(DateTimeResult& result, DateTimeRawInfo& raw, DateTimeFormatInfo dtfi)
private bool GetDayOfYM(DateTimeResult& result, DateTimeRawInfo& raw, DateTimeFormatInfo dtfi)
private void AdjustTimeMark(DateTimeFormatInfo dtfi, DateTimeRawInfo& raw)
private bool AdjustHour(Int32& hour, TM timeMark)
private bool GetTimeOfN(DateTimeFormatInfo dtfi, DateTimeResult& result, DateTimeRawInfo& raw)
private bool GetTimeOfNN(DateTimeFormatInfo dtfi, DateTimeResult& result, DateTimeRawInfo& raw)
private bool GetTimeOfNNN(DateTimeFormatInfo dtfi, DateTimeResult& result, DateTimeRawInfo& raw)
private bool GetDateOfDSN(DateTimeResult& result, DateTimeRawInfo& raw)
private bool GetDateOfNDS(DateTimeResult& result, DateTimeRawInfo& raw)
private bool GetDateOfNNDS(DateTimeResult& result, DateTimeRawInfo& raw, DateTimeFormatInfo dtfi)
private bool ProcessDateTimeSuffix(DateTimeResult& result, DateTimeRawInfo& raw, DateTimeToken& dtok)
internal bool ProcessHebrewTerminalState(DS dps, DateTimeResult& result, DateTimeStyles& styles, DateTimeRawInfo& raw, DateTimeFormatInfo dtfi)
internal bool ProcessTerminaltState(DS dps, DateTimeResult& result, DateTimeStyles& styles, DateTimeRawInfo& raw, DateTimeFormatInfo dtfi)
internal DateTime Parse(string s, DateTimeFormatInfo dtfi, DateTimeStyles styles)
internal DateTime Parse(string s, DateTimeFormatInfo dtfi, DateTimeStyles styles, TimeSpan& offset)
internal bool TryParse(string s, DateTimeFormatInfo dtfi, DateTimeStyles styles, DateTime& result)
internal bool TryParse(string s, DateTimeFormatInfo dtfi, DateTimeStyles styles, DateTime& result, TimeSpan& offset)
internal bool TryParse(string s, DateTimeFormatInfo dtfi, DateTimeStyles styles, DateTimeResult& result)
private bool DetermineTimeZoneAdjustments(DateTimeResult& result, DateTimeStyles styles, bool bTimeOnly)
private bool DateTimeOffsetTimeZonePostProcessing(DateTimeResult& result, DateTimeStyles styles)
private bool AdjustTimeZoneToUniversal(DateTimeResult& result)
private bool AdjustTimeZoneToLocal(DateTimeResult& result, bool bTimeOnly)
private bool ParseISO8601(DateTimeRawInfo& raw, __DTString& str, DateTimeStyles styles, DateTimeResult& result)
internal bool MatchHebrewDigits(__DTString& str, int digitLen, Int32& number)
internal bool ParseDigits(__DTString& str, int digitLen, Int32& result)
internal bool ParseDigits(__DTString& str, int minDigitLen, int maxDigitLen, Int32& result)
private bool ParseFractionExact(__DTString& str, int maxDigitLen, Double& result)
private bool ParseSign(__DTString& str, Boolean& result)
private bool ParseTimeZoneOffset(__DTString& str, int len, TimeSpan& result)
private bool MatchAbbreviatedMonthName(__DTString& str, DateTimeFormatInfo dtfi, Int32& result)
private bool MatchMonthName(__DTString& str, DateTimeFormatInfo dtfi, Int32& result)
private bool MatchAbbreviatedDayName(__DTString& str, DateTimeFormatInfo dtfi, Int32& result)
private bool MatchDayName(__DTString& str, DateTimeFormatInfo dtfi, Int32& result)
private bool MatchEraName(__DTString& str, DateTimeFormatInfo dtfi, Int32& result)
private bool MatchTimeMark(__DTString& str, DateTimeFormatInfo dtfi, TM& result)
private bool MatchAbbreviatedTimeMark(__DTString& str, DateTimeFormatInfo dtfi, TM& result)
private bool CheckNewValue(Int32& currentValue, int newValue, char patternChar, DateTimeResult& result)
private DateTime GetDateTimeNow(DateTimeResult& result, DateTimeStyles& styles)
private bool CheckDefaultDateTime(DateTimeResult& result, Calendar& cal, DateTimeStyles styles)
private string ExpandPredefinedFormat(string format, DateTimeFormatInfo& dtfi, ParsingInfo& parseInfo, DateTimeResult& result)
private bool ParseByFormat(__DTString& str, __DTString& format, ParsingInfo& parseInfo, DateTimeFormatInfo dtfi, DateTimeResult& result)
internal bool TryParseQuoteString(string format, int pos, StringBuilder result, Int32& returnValue)
private bool DoStrictParse(string s, string formatParam, DateTimeStyles styles, DateTimeFormatInfo dtfi, DateTimeResult& result)
private Exception GetDateTimeParseException(DateTimeResult& result)
internal void LexTraceExit(string message, DS dps)
internal void PTSTraceExit(DS dps, bool passed)
internal void TPTraceExit(string message, DS dps)
internal void DTFITrace(DateTimeFormatInfo dtfi)
}
internal System.DateTimeRawInfo : ValueType {
private Int32* num
internal int numCount
internal int month
internal int year
internal int dayOfWeek
internal int era
internal TM timeMark
internal double fraction
internal bool hasSameDateAndTimeSeparators
internal bool timeZone
internal void Init(Int32* numberBuffer)
internal void AddNumber(int value)
internal int GetNumber(int index)
}
internal System.DateTimeResult : ValueType {
internal int Year
internal int Month
internal int Day
internal int Hour
internal int Minute
internal int Second
internal double fraction
internal int era
internal ParseFlags flags
internal TimeSpan timeZoneOffset
internal Calendar calendar
internal DateTime parsedDate
internal ParseFailureKind failure
internal string failureMessageID
internal object failureMessageFormatArgument
internal string failureArgumentName
internal void Init()
internal void SetDate(int year, int month, int day)
internal void SetFailure(ParseFailureKind failure, string failureMessageID, object failureMessageFormatArgument)
internal void SetFailure(ParseFailureKind failure, string failureMessageID, object failureMessageFormatArgument, string failureArgumentName)
}
internal System.DateTimeToken : ValueType {
internal DTT dtt
internal TokenType suffix
internal int num
}
public System.DayOfWeek : Enum {
public int value__
public DayOfWeek Sunday
public DayOfWeek Monday
public DayOfWeek Tuesday
public DayOfWeek Wednesday
public DayOfWeek Thursday
public DayOfWeek Friday
public DayOfWeek Saturday
}
public System.DBNull : object {
public DBNull Value
private void .ctor(SerializationInfo info, StreamingContext context)
public void GetObjectData(SerializationInfo info, StreamingContext context)
public string ToString()
public string ToString(IFormatProvider provider)
public TypeCode GetTypeCode()
private bool System.IConvertible.ToBoolean(IFormatProvider provider)
private char System.IConvertible.ToChar(IFormatProvider provider)
private sbyte System.IConvertible.ToSByte(IFormatProvider provider)
private byte System.IConvertible.ToByte(IFormatProvider provider)
private short System.IConvertible.ToInt16(IFormatProvider provider)
private ushort System.IConvertible.ToUInt16(IFormatProvider provider)
private int System.IConvertible.ToInt32(IFormatProvider provider)
private UInt32 System.IConvertible.ToUInt32(IFormatProvider provider)
private long System.IConvertible.ToInt64(IFormatProvider provider)
private ulong System.IConvertible.ToUInt64(IFormatProvider provider)
private float System.IConvertible.ToSingle(IFormatProvider provider)
private double System.IConvertible.ToDouble(IFormatProvider provider)
private decimal System.IConvertible.ToDecimal(IFormatProvider provider)
private DateTime System.IConvertible.ToDateTime(IFormatProvider provider)
private object System.IConvertible.ToType(Type type, IFormatProvider provider)
}
public System.Decimal : ValueType {
private int SignMask
private byte DECIMAL_NEG
private byte DECIMAL_ADD
private int ScaleMask
private int ScaleShift
private int MaxInt32Scale
private UInt32[] Powers10
public decimal Zero
public decimal One
public decimal MinusOne
public decimal MaxValue
public decimal MinValue
private decimal NearNegativeZero
private decimal NearPositiveZero
private int flags
private int hi
private int lo
private int mid
public void .ctor(int value)
public void .ctor(UInt32 value)
public void .ctor(long value)
public void .ctor(ulong value)
public void .ctor(float value)
public void .ctor(double value)
public long ToOACurrency(decimal value)
public decimal FromOACurrency(long cy)
public void .ctor(Int32[] bits)
private void SetBits(Int32[] bits)
public void .ctor(int lo, int mid, int hi, bool isNegative, byte scale)
private void OnSerializing(StreamingContext ctx)
private void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender)
private void .ctor(int lo, int mid, int hi, int flags)
internal decimal Abs(decimal d)
public decimal Add(decimal d1, decimal d2)
private void FCallAddSub(Decimal& d1, Decimal& d2, byte bSign)
public decimal Ceiling(decimal d)
public int Compare(decimal d1, decimal d2)
private int FCallCompare(Decimal& d1, Decimal& d2)
public int CompareTo(object value)
public int CompareTo(decimal value)
public decimal Divide(decimal d1, decimal d2)
private void FCallDivide(Decimal& d1, Decimal& d2)
public bool Equals(object value)
public bool Equals(decimal value)
public int GetHashCode()
public bool Equals(decimal d1, decimal d2)
public decimal Floor(decimal d)
private void FCallFloor(Decimal& d)
public string ToString()
public string ToString(string format)
public string ToString(IFormatProvider provider)
public string ToString(string format, IFormatProvider provider)
public decimal Parse(string s)
public decimal Parse(string s, NumberStyles style)
public decimal Parse(string s, IFormatProvider provider)
public decimal Parse(string s, NumberStyles style, IFormatProvider provider)
public bool TryParse(string s, Decimal& result)
public bool TryParse(string s, NumberStyles style, IFormatProvider provider, Decimal& result)
public Int32[] GetBits(decimal d)
internal void GetBytes(decimal d, Byte[] buffer)
internal decimal ToDecimal(Byte[] buffer)
private void InternalAddUInt32RawUnchecked(Decimal& value, UInt32 i)
private UInt32 InternalDivRemUInt32(Decimal& value, UInt32 divisor)
private void InternalRoundFromZero(Decimal& d, int decimalCount)
internal decimal Max(decimal d1, decimal d2)
internal decimal Min(decimal d1, decimal d2)
public decimal Remainder(decimal d1, decimal d2)
public decimal Multiply(decimal d1, decimal d2)
private void FCallMultiply(Decimal& d1, Decimal& d2)
public decimal Negate(decimal d)
public decimal Round(decimal d)
public decimal Round(decimal d, int decimals)
public decimal Round(decimal d, MidpointRounding mode)
public decimal Round(decimal d, int decimals, MidpointRounding mode)
private void FCallRound(Decimal& d, int decimals)
public decimal Subtract(decimal d1, decimal d2)
public byte ToByte(decimal value)
public sbyte ToSByte(decimal value)
public short ToInt16(decimal value)
public double ToDouble(decimal d)
internal int FCallToInt32(decimal d)
public int ToInt32(decimal d)
public long ToInt64(decimal d)
public ushort ToUInt16(decimal value)
public UInt32 ToUInt32(decimal d)
public ulong ToUInt64(decimal d)
public float ToSingle(decimal d)
public decimal Truncate(decimal d)
private void FCallTruncate(Decimal& d)
public decimal op_Implicit(byte value)
public decimal op_Implicit(sbyte value)
public decimal op_Implicit(short value)
public decimal op_Implicit(ushort value)
public decimal op_Implicit(char value)
public decimal op_Implicit(int value)
public decimal op_Implicit(UInt32 value)
public decimal op_Implicit(long value)
public decimal op_Implicit(ulong value)
public decimal op_Explicit(float value)
public decimal op_Explicit(double value)
public byte op_Explicit(decimal value)
public sbyte op_Explicit(decimal value)
public char op_Explicit(decimal value)
public short op_Explicit(decimal value)
public ushort op_Explicit(decimal value)
public int op_Explicit(decimal value)
public UInt32 op_Explicit(decimal value)
public long op_Explicit(decimal value)
public ulong op_Explicit(decimal value)
public float op_Explicit(decimal value)
public double op_Explicit(decimal value)
public decimal op_UnaryPlus(decimal d)
public decimal op_UnaryNegation(decimal d)
public decimal op_Increment(decimal d)
public decimal op_Decrement(decimal d)
public decimal op_Addition(decimal d1, decimal d2)
public decimal op_Subtraction(decimal d1, decimal d2)
public decimal op_Multiply(decimal d1, decimal d2)
public decimal op_Division(decimal d1, decimal d2)
public decimal op_Modulus(decimal d1, decimal d2)
public bool op_Equality(decimal d1, decimal d2)
public bool op_Inequality(decimal d1, decimal d2)
public bool op_LessThan(decimal d1, decimal d2)
public bool op_LessThanOrEqual(decimal d1, decimal d2)
public bool op_GreaterThan(decimal d1, decimal d2)
public bool op_GreaterThanOrEqual(decimal d1, decimal d2)
public TypeCode GetTypeCode()
private bool System.IConvertible.ToBoolean(IFormatProvider provider)
private char System.IConvertible.ToChar(IFormatProvider provider)
private sbyte System.IConvertible.ToSByte(IFormatProvider provider)
private byte System.IConvertible.ToByte(IFormatProvider provider)
private short System.IConvertible.ToInt16(IFormatProvider provider)
private ushort System.IConvertible.ToUInt16(IFormatProvider provider)
private int System.IConvertible.ToInt32(IFormatProvider provider)
private UInt32 System.IConvertible.ToUInt32(IFormatProvider provider)
private long System.IConvertible.ToInt64(IFormatProvider provider)
private ulong System.IConvertible.ToUInt64(IFormatProvider provider)
private float System.IConvertible.ToSingle(IFormatProvider provider)
private double System.IConvertible.ToDouble(IFormatProvider provider)
private decimal System.IConvertible.ToDecimal(IFormatProvider provider)
private DateTime System.IConvertible.ToDateTime(IFormatProvider provider)
private object System.IConvertible.ToType(Type type, IFormatProvider provider)
}
internal System.DefaultBinder : Binder {
public MethodBase BindToMethod(BindingFlags bindingAttr, MethodBase[] match, Object[]& args, ParameterModifier[] modifiers, CultureInfo cultureInfo, String[] names, Object& state)
public FieldInfo BindToField(BindingFlags bindingAttr, FieldInfo[] match, object value, CultureInfo cultureInfo)
public MethodBase SelectMethod(BindingFlags bindingAttr, MethodBase[] match, Type[] types, ParameterModifier[] modifiers)
public PropertyInfo SelectProperty(BindingFlags bindingAttr, PropertyInfo[] match, Type returnType, Type[] indexes, ParameterModifier[] modifiers)
public object ChangeType(object value, Type type, CultureInfo cultureInfo)
public void ReorderArgumentArray(Object[]& args, object state)
public MethodBase ExactBinding(MethodBase[] match, Type[] types, ParameterModifier[] modifiers)
public PropertyInfo ExactPropertyBinding(PropertyInfo[] match, Type returnType, Type[] types, ParameterModifier[] modifiers)
private int FindMostSpecific(ParameterInfo[] p1, Int32[] paramOrder1, Type paramArrayType1, ParameterInfo[] p2, Int32[] paramOrder2, Type paramArrayType2, Type[] types, Object[] args)
private int FindMostSpecificType(Type c1, Type c2, Type t)
private int FindMostSpecificMethod(MethodBase m1, Int32[] paramOrder1, Type paramArrayType1, MethodBase m2, Int32[] paramOrder2, Type paramArrayType2, Type[] types, Object[] args)
private int FindMostSpecificField(FieldInfo cur1, FieldInfo cur2)
private int FindMostSpecificProperty(PropertyInfo cur1, PropertyInfo cur2)
internal bool CompareMethodSigAndName(MethodBase m1, MethodBase m2)
internal int GetHierarchyDepth(Type t)
internal MethodBase FindMostDerivedNewSlotMeth(MethodBase[] match, int cMatches)
private void ReorderParams(Int32[] paramOrder, Object[] vars)
private bool CreateParamOrder(Int32[] paramOrder, ParameterInfo[] pars, String[] names)
private bool CanConvertPrimitive(RuntimeType source, RuntimeType target)
private bool CanConvertPrimitiveObjectToType(object source, RuntimeType type)
}
public System.Delegate : object {
private IntPtr method_ptr
private IntPtr invoke_impl
private object m_target
private IntPtr method
private IntPtr delegate_trampoline
private IntPtr extra_arg
private IntPtr method_code
private MethodInfo method_info
private MethodInfo original_method_info
private DelegateData data
private bool method_is_virtual
public MethodInfo Method
public object Target
protected void .ctor(object target, string method)
protected void .ctor(Type target, string method)
public MethodInfo get_Method()
private MethodInfo GetVirtualMethod_internal()
public object get_Target()
internal Delegate CreateDelegate_internal(Type type, object target, MethodInfo info, bool throwOnBindFailure)
private bool arg_type_match(Type delArgType, Type argType)
private bool arg_type_match_this(Type delArgType, Type argType, bool boxedThis)
private bool return_type_match(Type delReturnType, Type returnType)
public Delegate CreateDelegate(Type type, object firstArgument, MethodInfo method, bool throwOnBindFailure)
private Delegate CreateDelegate(Type type, object firstArgument, MethodInfo method, bool throwOnBindFailure, bool allowClosed)
public Delegate CreateDelegate(Type type, object firstArgument, MethodInfo method)
public Delegate CreateDelegate(Type type, MethodInfo method, bool throwOnBindFailure)
public Delegate CreateDelegate(Type type, MethodInfo method)
public Delegate CreateDelegate(Type type, object target, string method)
private MethodInfo GetCandidateMethod(Type type, Type target, string method, BindingFlags bflags, bool ignoreCase, bool throwOnBindFailure)
public Delegate CreateDelegate(Type type, Type target, string method, bool ignoreCase, bool throwOnBindFailure)
public Delegate CreateDelegate(Type type, Type target, string method)
public Delegate CreateDelegate(Type type, Type target, string method, bool ignoreCase)
public Delegate CreateDelegate(Type type, object target, string method, bool ignoreCase, bool throwOnBindFailure)
public Delegate CreateDelegate(Type type, object target, string method, bool ignoreCase)
public object DynamicInvoke(Object[] args)
private void InitializeDelegateData()
protected object DynamicInvokeImpl(Object[] args)
public object Clone()
public bool Equals(object obj)
public int GetHashCode()
protected MethodInfo GetMethodImpl()
public void GetObjectData(SerializationInfo info, StreamingContext context)
public Delegate[] GetInvocationList()
public Delegate Combine(Delegate a, Delegate b)
public Delegate Combine(Delegate[] delegates)
protected Delegate CombineImpl(Delegate d)
public Delegate Remove(Delegate source, Delegate value)
protected Delegate RemoveImpl(Delegate d)
public Delegate RemoveAll(Delegate source, Delegate value)
public bool op_Equality(Delegate d1, Delegate d2)
public bool op_Inequality(Delegate d1, Delegate d2)
internal bool IsTransparentProxy()
internal Delegate CreateDelegateNoSecurityCheck(RuntimeType type, object firstArgument, MethodInfo method)
internal MulticastDelegate AllocDelegateLike_internal(Delegate d)
}
internal System.DelegateData : object {
public Type target_type
public string method_name
public bool curried_first_arg
}
internal System.DelegateSerializationHolder : object {
private Delegate _delegate
private void .ctor(SerializationInfo info, StreamingContext ctx)
public void GetDelegateData(Delegate instance, SerializationInfo info, StreamingContext ctx)
public void GetObjectData(SerializationInfo info, StreamingContext context)
public object GetRealObject(StreamingContext context)
}
public System.Deployment.Internal.InternalActivationContextHelper : object {
public object GetActivationContextData(ActivationContext appInfo)
public object GetApplicationComponentManifest(ActivationContext appInfo)
public Byte[] GetApplicationManifestBytes(ActivationContext appInfo)
public object GetDeploymentComponentManifest(ActivationContext appInfo)
public Byte[] GetDeploymentManifestBytes(ActivationContext appInfo)
public bool IsFirstRun(ActivationContext appInfo)
public void PrepareForExecution(ActivationContext appInfo)
}
public System.Deployment.Internal.InternalApplicationIdentityHelper : object {
public object GetInternalAppId(ApplicationIdentity id)
}
internal System.Diagnostics.Assert : object {
internal int COR_E_FAILFAST
private AssertFilter Filter
internal void Check(bool condition, string conditionString, string message)
internal void Check(bool condition, string conditionString, string message, int exitCode)
internal void Fail(string conditionString, string message)
internal void Fail(string conditionString, string message, string windowTitle, int exitCode)
internal void Fail(string conditionString, string message, int exitCode, TraceFormat stackTraceFormat)
internal void Fail(string conditionString, string message, string windowTitle, int exitCode, TraceFormat stackTraceFormat, int numStackFramesToSkip)
internal int ShowDefaultAssertDialog(string conditionString, string message, string stackTrace, string windowTitle)
}
internal System.Diagnostics.AssertFilter : object {
public AssertFilters AssertFailure(string condition, string message, StackTrace location, TraceFormat stackTraceFormat, string windowTitle)
}
internal System.Diagnostics.AssertFilters : Enum {
public int value__
public AssertFilters FailDebug
public AssertFilters FailIgnore
public AssertFilters FailTerminate
public AssertFilters FailContinueFilter
}
public System.Diagnostics.CodeAnalysis.SuppressMessageAttribute : Attribute {
private string category
private string justification
private string checkId
private string scope
private string target
private string messageId
public string Category
public string CheckId
public string Scope
public string Target
public string MessageId
public string Justification
public void .ctor(string category, string checkId)
public string get_Category()
public string get_CheckId()
public string get_Scope()
public void set_Scope(string value)
public string get_Target()
public void set_Target(string value)
public string get_MessageId()
public void set_MessageId(string value)
public string get_Justification()
public void set_Justification(string value)
}
public System.Diagnostics.ConditionalAttribute : Attribute {
private string m_conditionString
public string ConditionString
public void .ctor(string conditionString)
public string get_ConditionString()
}
public System.Diagnostics.Contracts.Contract : object {
private bool _assertingMustUseRewriter
public void Assume(bool condition)
public void Assume(bool condition, string userMessage)
public void Assert(bool condition)
public void Assert(bool condition, string userMessage)
public void Requires(bool condition)
public void Requires(bool condition, string userMessage)
public void Requires(bool condition)
public void Requires(bool condition, string userMessage)
public void Ensures(bool condition)
public void Ensures(bool condition, string userMessage)
public void EnsuresOnThrow(bool condition)
public void EnsuresOnThrow(bool condition, string userMessage)
public T Result()
public T ValueAtReturn(T& value)
public T OldValue(T value)
public void Invariant(bool condition)
public void Invariant(bool condition, string userMessage)
public bool ForAll(int fromInclusive, int toExclusive, Predicate`1<int> predicate)
public bool ForAll(IEnumerable`1<T> collection, Predicate`1<T> predicate)
public bool Exists(int fromInclusive, int toExclusive, Predicate`1<int> predicate)
public bool Exists(IEnumerable`1<T> collection, Predicate`1<T> predicate)
public void EndContractBlock()
private void ReportFailure(ContractFailureKind failureKind, string userMessage, string conditionText, Exception innerException)
private void AssertMustUseRewriter(ContractFailureKind kind, string contractKind)
public void add_ContractFailed(EventHandler`1<ContractFailedEventArgs> value)
public void remove_ContractFailed(EventHandler`1<ContractFailedEventArgs> value)
}
public System.Diagnostics.Contracts.ContractClassAttribute : Attribute {
private Type _typeWithContracts
public Type TypeContainingContracts
public void .ctor(Type typeContainingContracts)
public Type get_TypeContainingContracts()
}
public System.Diagnostics.Contracts.ContractClassForAttribute : Attribute {
private Type _typeIAmAContractFor
public Type TypeContractsAreFor
public void .ctor(Type typeContractsAreFor)
public Type get_TypeContractsAreFor()
}
internal System.Diagnostics.Contracts.ContractException : Exception {
private ContractFailureKind _Kind
private string _UserMessage
private string _Condition
public ContractFailureKind Kind
public string Failure
public string UserMessage
public string Condition
public ContractFailureKind get_Kind()
public string get_Failure()
public string get_UserMessage()
public string get_Condition()
public void .ctor(ContractFailureKind kind, string failure, string userMessage, string condition, Exception innerException)
private void .ctor(SerializationInfo info, StreamingContext context)
public void GetObjectData(SerializationInfo info, StreamingContext context)
}
public System.Diagnostics.Contracts.ContractFailedEventArgs : EventArgs {
private ContractFailureKind _failureKind
private string _message
private string _condition
private Exception _originalException
private bool _handled
private bool _unwind
internal Exception thrownDuringHandler
public string Message
public string Condition
public ContractFailureKind FailureKind
public Exception OriginalException
public bool Handled
public bool Unwind
public void .ctor(ContractFailureKind failureKind, string message, string condition, Exception originalException)
public string get_Message()
public string get_Condition()
public ContractFailureKind get_FailureKind()
public Exception get_OriginalException()
public bool get_Handled()
public void SetHandled()
public bool get_Unwind()
public void SetUnwind()
}
public System.Diagnostics.Contracts.ContractFailureKind : Enum {
public int value__
public ContractFailureKind Precondition
public ContractFailureKind Postcondition
public ContractFailureKind PostconditionOnException
public ContractFailureKind Invariant
public ContractFailureKind Assert
public ContractFailureKind Assume
}
public System.Diagnostics.Contracts.ContractOptionAttribute : Attribute {
private string _category
private string _setting
private bool _enabled
private string _value
public string Category
public string Setting
public bool Enabled
public string Value
public void .ctor(string category, string setting, bool enabled)
public void .ctor(string category, string setting, string value)
public string get_Category()
public string get_Setting()
public bool get_Enabled()
public string get_Value()
}
public System.Diagnostics.Contracts.ContractPublicPropertyNameAttribute : Attribute {
private string _publicName
public string Name
public void .ctor(string name)
public string get_Name()
}
public System.Diagnostics.Contracts.ContractVerificationAttribute : Attribute {
private bool _value
public bool Value
public void .ctor(bool value)
public bool get_Value()
}
public System.Diagnostics.Contracts.Internal.ContractHelper : object {
public string RaiseContractFailedEvent(ContractFailureKind failureKind, string userMessage, string conditionText, Exception innerException)
public void TriggerFailure(ContractFailureKind kind, string displayMessage, string userMessage, string conditionText, Exception innerException)
}
public System.Diagnostics.DebuggableAttribute : Attribute {
private DebuggingModes m_debuggingModes
public bool IsJITTrackingEnabled
public bool IsJITOptimizerDisabled
public DebuggingModes DebuggingFlags
public void .ctor(bool isJITTrackingEnabled, bool isJITOptimizerDisabled)
public void .ctor(DebuggingModes modes)
public bool get_IsJITTrackingEnabled()
public bool get_IsJITOptimizerDisabled()
public DebuggingModes get_DebuggingFlags()
}
public System.Diagnostics.Debugger : object {
public string DefaultCategory
public bool IsAttached
public bool get_IsAttached()
private bool IsAttached_internal()
public void Break()
public bool IsLogging()
public bool Launch()
public void Log(int level, string category, string message)
public void NotifyOfCrossThreadDependency()
}
public System.Diagnostics.DebuggerBrowsableAttribute : Attribute {
private DebuggerBrowsableState state
public DebuggerBrowsableState State
public void .ctor(DebuggerBrowsableState state)
public DebuggerBrowsableState get_State()
}
public System.Diagnostics.DebuggerBrowsableState : Enum {
public int value__
public DebuggerBrowsableState Never
public DebuggerBrowsableState Collapsed
public DebuggerBrowsableState RootHidden
}
public System.Diagnostics.DebuggerDisplayAttribute : Attribute {
private string name
private string value
private string type
private string targetName
private Type target
public string Value
public string Name
public string Type
public Type Target
public string TargetTypeName
public void .ctor(string value)
public string get_Value()
public string get_Name()
public void set_Name(string value)
public string get_Type()
public void set_Type(string value)
public void set_Target(Type value)
public Type get_Target()
public string get_TargetTypeName()
public void set_TargetTypeName(string value)
}
public System.Diagnostics.DebuggerTypeProxyAttribute : Attribute {
private string typeName
private string targetName
private Type target
public string ProxyTypeName
public Type Target
public string TargetTypeName
public void .ctor(Type type)
public void .ctor(string typeName)
public string get_ProxyTypeName()
public void set_Target(Type value)
public Type get_Target()
public string get_TargetTypeName()
public void set_TargetTypeName(string value)
}
public System.Diagnostics.DebuggerVisualizerAttribute : Attribute {
private string visualizerObjectSourceName
private string visualizerName
private string description
private string targetName
private Type target
public string VisualizerObjectSourceTypeName
public string VisualizerTypeName
public string Description
public Type Target
public string TargetTypeName
public void .ctor(string visualizerTypeName)
public void .ctor(string visualizerTypeName, string visualizerObjectSourceTypeName)
public void .ctor(string visualizerTypeName, Type visualizerObjectSource)
public void .ctor(Type visualizer)
public void .ctor(Type visualizer, Type visualizerObjectSource)
public void .ctor(Type visualizer, string visualizerObjectSourceTypeName)
public string get_VisualizerObjectSourceTypeName()
public string get_VisualizerTypeName()
public string get_Description()
public void set_Description(string value)
public void set_Target(Type value)
public Type get_Target()
public void set_TargetTypeName(string value)
public string get_TargetTypeName()
}
internal System.Diagnostics.DefaultFilter : AssertFilter {
public AssertFilters AssertFailure(string condition, string message, StackTrace location, TraceFormat stackTraceFormat, string windowTitle)
}
internal System.Diagnostics.Private.Debug : object {
private object s_lock
private int s_indentLevel
private int s_indentSize
private bool s_needIndent
private string s_indentString
internal Action`3<string, string, string> s_ShowAssertDialog
internal Action`1<string> s_WriteCore
public bool AutoFlush
public int IndentLevel
public int IndentSize
public bool get_AutoFlush()
public void set_AutoFlush(bool value)
public int get_IndentLevel()
public void set_IndentLevel(int value)
public int get_IndentSize()
public void set_IndentSize(int value)
public void Close()
public void Flush()
public void Indent()
public void Unindent()
public void Print(string message)
public void Print(string format, Object[] args)
public void Assert(bool condition)
public void Assert(bool condition, string message)
public void Assert(bool condition, string message, string detailMessage)
public void Fail(string message)
public void Fail(string message, string detailMessage)
private string FormatAssert(string stackTrace, string message, string detailMessage)
public void Assert(bool condition, string message, string detailMessageFormat, Object[] args)
public void WriteLine(string message)
public void Write(string message)
public void WriteLine(object value)
public void WriteLine(object value, string category)
public void WriteLine(string format, Object[] args)
public void WriteLine(string message, string category)
public void Write(object value)
public void Write(string message, string category)
public void Write(object value, string category)
public void WriteIf(bool condition, string message)
public void WriteIf(bool condition, object value)
public void WriteIf(bool condition, string message, string category)
public void WriteIf(bool condition, object value, string category)
public void WriteLineIf(bool condition, object value)
public void WriteLineIf(bool condition, object value, string category)
public void WriteLineIf(bool condition, string message)
public void WriteLineIf(bool condition, string message, string category)
private string GetIndentString()
private void ShowAssertDialog(string stackTrace, string message, string detailMessage)
private void WriteCore(string message)
}
public System.Diagnostics.StackFrame : object {
public int OFFSET_UNKNOWN
private int ilOffset
private int nativeOffset
private long methodAddress
private UInt32 methodIndex
private MethodBase methodBase
private string fileName
private int lineNumber
private int columnNumber
private string internalMethodName
private bool get_frame_info(int skip, bool needFileInfo, MethodBase& method, Int32& iloffset, Int32& native_offset, String& file, Int32& line, Int32& column)
public void .ctor(bool fNeedFileInfo)
public void .ctor(int skipFrames)
public void .ctor(int skipFrames, bool fNeedFileInfo)
public void .ctor(string fileName, int lineNumber)
public void .ctor(string fileName, int lineNumber, int colNumber)
public int GetFileLineNumber()
public int GetFileColumnNumber()
public string GetFileName()
internal string GetSecureFileName()
public int GetILOffset()
public MethodBase GetMethod()
public int GetNativeOffset()
internal long GetMethodAddress()
internal UInt32 GetMethodIndex()
internal string GetInternalMethodName()
public string ToString()
}
public System.Diagnostics.StackTrace : object {
public int METHODS_TO_SKIP
private StackFrame[] frames
private StackTrace[] captured_traces
private bool debug_info
private bool isAotidSet
private string aotid
public int FrameCount
public void .ctor(bool fNeedFileInfo)
public void .ctor(int skipFrames)
public void .ctor(int skipFrames, bool fNeedFileInfo)
private void init_frames(int skipFrames, bool fNeedFileInfo)
private StackFrame[] get_trace(Exception e, int skipFrames, bool fNeedFileInfo)
public void .ctor(Exception e)
public void .ctor(Exception e, bool fNeedFileInfo)
public void .ctor(Exception e, int skipFrames)
public void .ctor(Exception e, int skipFrames, bool fNeedFileInfo)
public void .ctor(StackFrame frame)
public void .ctor(Thread targetThread, bool needFileInfo)
internal void .ctor(StackFrame[] frames)
public int get_FrameCount()
public StackFrame GetFrame(int index)
public StackFrame[] GetFrames()
private string GetAotId()
private bool AddFrames(StringBuilder sb)
internal void GetFullNameForStackTrace(StringBuilder sb, MethodBase mi)
public string ToString()
internal string ToString(TraceFormat traceFormat)
}
public System.Diagnostics.SymbolStore.ISymbolBinder {
public ISymbolReader GetReader(int importer, string filename, string searchPath)
}
public System.Diagnostics.SymbolStore.ISymbolBinder1 {
public ISymbolReader GetReader(IntPtr importer, string filename, string searchPath)
}
public System.Diagnostics.SymbolStore.ISymbolDocument {
public Guid CheckSumAlgorithmId
public Guid DocumentType
public bool HasEmbeddedSource
public Guid Language
public Guid LanguageVendor
public int SourceLength
public string URL
public Guid get_CheckSumAlgorithmId()
public Guid get_DocumentType()
public bool get_HasEmbeddedSource()
public Guid get_Language()
public Guid get_LanguageVendor()
public int get_SourceLength()
public string get_URL()
public int FindClosestLine(int line)
public Byte[] GetCheckSum()
public Byte[] GetSourceRange(int startLine, int startColumn, int endLine, int endColumn)
}
public System.Diagnostics.SymbolStore.ISymbolDocumentWriter {
public void SetCheckSum(Guid algorithmId, Byte[] checkSum)
public void SetSource(Byte[] source)
}
public System.Diagnostics.SymbolStore.ISymbolMethod {
public ISymbolScope RootScope
public int SequencePointCount
public SymbolToken Token
public ISymbolScope get_RootScope()
public int get_SequencePointCount()
public SymbolToken get_Token()
public ISymbolNamespace GetNamespace()
public int GetOffset(ISymbolDocument document, int line, int column)
public ISymbolVariable[] GetParameters()
public Int32[] GetRanges(ISymbolDocument document, int line, int column)
public ISymbolScope GetScope(int offset)
public void GetSequencePoints(Int32[] offsets, ISymbolDocument[] documents, Int32[] lines, Int32[] columns, Int32[] endLines, Int32[] endColumns)
public bool GetSourceStartEnd(ISymbolDocument[] docs, Int32[] lines, Int32[] columns)
}
public System.Diagnostics.SymbolStore.ISymbolNamespace {
public string Name
public string get_Name()
public ISymbolNamespace[] GetNamespaces()
public ISymbolVariable[] GetVariables()
}
public System.Diagnostics.SymbolStore.ISymbolReader {
public SymbolToken UserEntryPoint
public SymbolToken get_UserEntryPoint()
public ISymbolDocument GetDocument(string url, Guid language, Guid languageVendor, Guid documentType)
public ISymbolDocument[] GetDocuments()
public ISymbolVariable[] GetGlobalVariables()
public ISymbolMethod GetMethod(SymbolToken method)
public ISymbolMethod GetMethod(SymbolToken method, int version)
public ISymbolMethod GetMethodFromDocumentPosition(ISymbolDocument document, int line, int column)
public ISymbolNamespace[] GetNamespaces()
public Byte[] GetSymAttribute(SymbolToken parent, string name)
public ISymbolVariable[] GetVariables(SymbolToken parent)
}
public System.Diagnostics.SymbolStore.ISymbolScope {
public int EndOffset
public ISymbolMethod Method
public ISymbolScope Parent
public int StartOffset
public int get_EndOffset()
public ISymbolMethod get_Method()
public ISymbolScope get_Parent()
public int get_StartOffset()
public ISymbolScope[] GetChildren()
public ISymbolVariable[] GetLocals()
public ISymbolNamespace[] GetNamespaces()
}
public System.Diagnostics.SymbolStore.ISymbolVariable {
public int AddressField1
public int AddressField2
public int AddressField3
public SymAddressKind AddressKind
public object Attributes
public int EndOffset
public string Name
public int StartOffset
public int get_AddressField1()
public int get_AddressField2()
public int get_AddressField3()
public SymAddressKind get_AddressKind()
public object get_Attributes()
public int get_EndOffset()
public string get_Name()
public int get_StartOffset()
public Byte[] GetSignature()
}
public System.Diagnostics.SymbolStore.ISymbolWriter {
public void Close()
public void CloseMethod()
public void CloseNamespace()
public void CloseScope(int endOffset)
public ISymbolDocumentWriter DefineDocument(string url, Guid language, Guid languageVendor, Guid documentType)
public void DefineField(SymbolToken parent, string name, FieldAttributes attributes, Byte[] signature, SymAddressKind addrKind, int addr1, int addr2, int addr3)
public void DefineGlobalVariable(string name, FieldAttributes attributes, Byte[] signature, SymAddressKind addrKind, int addr1, int addr2, int addr3)
public void DefineLocalVariable(string name, FieldAttributes attributes, Byte[] signature, SymAddressKind addrKind, int addr1, int addr2, int addr3, int startOffset, int endOffset)
public void DefineParameter(string name, ParameterAttributes attributes, int sequence, SymAddressKind addrKind, int addr1, int addr2, int addr3)
public void DefineSequencePoints(ISymbolDocumentWriter document, Int32[] offsets, Int32[] lines, Int32[] columns, Int32[] endLines, Int32[] endColumns)
public void Initialize(IntPtr emitter, string filename, bool fFullBuild)
public void OpenMethod(SymbolToken method)
public void OpenNamespace(string name)
public int OpenScope(int startOffset)
public void SetMethodSourceRange(ISymbolDocumentWriter startDoc, int startLine, int startColumn, ISymbolDocumentWriter endDoc, int endLine, int endColumn)
public void SetScopeRange(int scopeID, int startOffset, int endOffset)
public void SetSymAttribute(SymbolToken parent, string name, Byte[] data)
public void SetUnderlyingWriter(IntPtr underlyingWriter)
public void SetUserEntryPoint(SymbolToken entryMethod)
public void UsingNamespace(string fullName)
}
public System.Diagnostics.SymbolStore.SymAddressKind : Enum {
public int value__
public SymAddressKind ILOffset
public SymAddressKind NativeRVA
public SymAddressKind NativeRegister
public SymAddressKind NativeRegisterRelative
public SymAddressKind NativeOffset
public SymAddressKind NativeRegisterRegister
public SymAddressKind NativeRegisterStack
public SymAddressKind NativeStackRegister
public SymAddressKind BitField
public SymAddressKind NativeSectionOffset
}
public System.Diagnostics.SymbolStore.SymbolToken : ValueType {
private int _val
public void .ctor(int val)
public bool Equals(object obj)
public bool Equals(SymbolToken obj)
public bool op_Equality(SymbolToken a, SymbolToken b)
public bool op_Inequality(SymbolToken a, SymbolToken b)
public int GetHashCode()
public int GetToken()
}
public System.Diagnostics.SymbolStore.SymDocumentType : object {
public Guid Text
}
public System.Diagnostics.SymbolStore.SymLanguageType : object {
public Guid Basic
public Guid C
public Guid Cobol
public Guid CPlusPlus
public Guid CSharp
public Guid ILAssembly
public Guid Java
public Guid JScript
public Guid MCPlusPlus
public Guid Pascal
public Guid SMC
}
public System.Diagnostics.SymbolStore.SymLanguageVendor : object {
public Guid Microsoft
}
public System.Diagnostics.Tracing.EventActivityOptions : Enum {
public int value__
public EventActivityOptions None
public EventActivityOptions Disable
public EventActivityOptions Recursive
public EventActivityOptions Detachable
}
public System.Diagnostics.Tracing.EventAttribute : Attribute {
private int <EventId>k__BackingField
private EventActivityOptions <ActivityOptions>k__BackingField
private EventLevel <Level>k__BackingField
private EventKeywords <Keywords>k__BackingField
private EventOpcode <Opcode>k__BackingField
private EventChannel <Channel>k__BackingField
private string <Message>k__BackingField
private EventTask <Task>k__BackingField
private EventTags <Tags>k__BackingField
private byte <Version>k__BackingField
public int EventId
public EventActivityOptions ActivityOptions
public EventLevel Level
public EventKeywords Keywords
public EventOpcode Opcode
public EventChannel Channel
public string Message
public EventTask Task
public EventTags Tags
public byte Version
public void .ctor(int eventId)
public int get_EventId()
private void set_EventId(int value)
public EventActivityOptions get_ActivityOptions()
public void set_ActivityOptions(EventActivityOptions value)
public EventLevel get_Level()
public void set_Level(EventLevel value)
public EventKeywords get_Keywords()
public void set_Keywords(EventKeywords value)
public EventOpcode get_Opcode()
public void set_Opcode(EventOpcode value)
public EventChannel get_Channel()
public void set_Channel(EventChannel value)
public string get_Message()
public void set_Message(string value)
public EventTask get_Task()
public void set_Task(EventTask value)
public EventTags get_Tags()
public void set_Tags(EventTags value)
public byte get_Version()
public void set_Version(byte value)
}
public System.Diagnostics.Tracing.EventChannel : Enum {
public byte value__
public EventChannel None
public EventChannel Admin
public EventChannel Operational
public EventChannel Analytic
public EventChannel Debug
}
public System.Diagnostics.Tracing.EventCommand : Enum {
public int value__
public EventCommand Update
public EventCommand SendManifest
public EventCommand Enable
public EventCommand Disable
}
public System.Diagnostics.Tracing.EventCommandEventArgs : EventArgs {
public IDictionary`2<string, string> Arguments
public EventCommand Command
public IDictionary`2<string, string> get_Arguments()
public EventCommand get_Command()
public bool DisableEvent(int eventId)
public bool EnableEvent(int eventId)
}
public System.Diagnostics.Tracing.EventCounter : object {
public void .ctor(string name, EventSource eventSource)
public void WriteMetric(float value)
}
public System.Diagnostics.Tracing.EventDataAttribute : Attribute {
public string Name
public string get_Name()
public void set_Name(string value)
}
public System.Diagnostics.Tracing.EventFieldAttribute : Attribute {
public EventFieldFormat Format
public EventFieldTags Tags
public EventFieldFormat get_Format()
public void set_Format(EventFieldFormat value)
public EventFieldTags get_Tags()
public void set_Tags(EventFieldTags value)
}
public System.Diagnostics.Tracing.EventFieldFormat : Enum {
public int value__
public EventFieldFormat Boolean
public EventFieldFormat Default
public EventFieldFormat Hexadecimal
public EventFieldFormat HResult
public EventFieldFormat Json
public EventFieldFormat String
public EventFieldFormat Xml
}
public System.Diagnostics.Tracing.EventFieldTags : Enum {
public int value__
public EventFieldTags None
}
public System.Diagnostics.Tracing.EventKeywords : Enum {
public long value__
public EventKeywords None
public EventKeywords All
public EventKeywords MicrosoftTelemetry
public EventKeywords WdiContext
public EventKeywords WdiDiagnostic
public EventKeywords Sqm
public EventKeywords AuditFailure
public EventKeywords AuditSuccess
public EventKeywords CorrelationHint
public EventKeywords EventLogClassic
}
public System.Diagnostics.Tracing.EventLevel : Enum {
public int value__
public EventLevel LogAlways
public EventLevel Critical
public EventLevel Error
public EventLevel Warning
public EventLevel Informational
public EventLevel Verbose
}
public System.Diagnostics.Tracing.EventListener : object {
public int EventSourceIndex(EventSource eventSource)
public void EnableEvents(EventSource eventSource, EventLevel level)
public void EnableEvents(EventSource eventSource, EventLevel level, EventKeywords matchAnyKeyword)
public void EnableEvents(EventSource eventSource, EventLevel level, EventKeywords matchAnyKeyword, IDictionary`2<string, string> arguments)
public void DisableEvents(EventSource eventSource)
protected internal void OnEventSourceCreated(EventSource eventSource)
protected internal void OnEventWritten(EventWrittenEventArgs eventData)
public void Dispose()
public void add_EventSourceCreated(EventHandler`1<EventSourceCreatedEventArgs> value)
public void remove_EventSourceCreated(EventHandler`1<EventSourceCreatedEventArgs> value)
public void add_EventWritten(EventHandler`1<EventWrittenEventArgs> value)
public void remove_EventWritten(EventHandler`1<EventWrittenEventArgs> value)
}
public System.Diagnostics.Tracing.EventManifestOptions : Enum {
public int value__
public EventManifestOptions AllCultures
public EventManifestOptions AllowEventSourceOverride
public EventManifestOptions None
public EventManifestOptions OnlyIfNeededForRegistration
public EventManifestOptions Strict
}
public System.Diagnostics.Tracing.EventOpcode : Enum {
public int value__
public EventOpcode Info
public EventOpcode Start
public EventOpcode Stop
public EventOpcode DataCollectionStart
public EventOpcode DataCollectionStop
public EventOpcode Extension
public EventOpcode Reply
public EventOpcode Resume
public EventOpcode Suspend
public EventOpcode Send
public EventOpcode Receive
}
public System.Diagnostics.Tracing.EventSource : object {
private string <Name>k__BackingField
private EventSourceSettings <Settings>k__BackingField
public Exception ConstructionException
public Guid CurrentThreadActivityId
public Guid Guid
public string Name
public EventSourceSettings Settings
protected void .ctor(bool throwOnEventWriteErrors)
protected void .ctor(EventSourceSettings settings)
protected void .ctor(EventSourceSettings settings, String[] traits)
public void .ctor(string eventSourceName)
public void .ctor(string eventSourceName, EventSourceSettings config)
public void .ctor(string eventSourceName, EventSourceSettings config, String[] traits)
protected void Finalize()
public Exception get_ConstructionException()
public Guid get_CurrentThreadActivityId()
public Guid get_Guid()
public string get_Name()
private void set_Name(string value)
public EventSourceSettings get_Settings()
private void set_Settings(EventSourceSettings value)
public bool IsEnabled()
public bool IsEnabled(EventLevel level, EventKeywords keywords)
public bool IsEnabled(EventLevel level, EventKeywords keywords, EventChannel channel)
public void Dispose()
public string GetTrait(string key)
public void Write(string eventName)
public void Write(string eventName, EventSourceOptions options)
public void Write(string eventName, T data)
public void Write(string eventName, EventSourceOptions options, T data)
public void Write(string eventName, EventSourceOptions& options, T& data)
public void Write(string eventName, EventSourceOptions& options, Guid& activityId, Guid& relatedActivityId, T& data)
protected void Dispose(bool disposing)
protected void OnEventCommand(EventCommandEventArgs command)
protected void WriteEvent(int eventId)
protected void WriteEvent(int eventId, Byte[] arg1)
protected void WriteEvent(int eventId, int arg1)
protected void WriteEvent(int eventId, string arg1)
protected void WriteEvent(int eventId, int arg1, int arg2)
protected void WriteEvent(int eventId, int arg1, int arg2, int arg3)
protected void WriteEvent(int eventId, int arg1, string arg2)
protected void WriteEvent(int eventId, long arg1)
protected void WriteEvent(int eventId, long arg1, Byte[] arg2)
protected void WriteEvent(int eventId, long arg1, long arg2)
protected void WriteEvent(int eventId, long arg1, long arg2, long arg3)
protected void WriteEvent(int eventId, long arg1, string arg2)
protected void WriteEvent(int eventId, Object[] args)
protected void WriteEvent(int eventId, string arg1, int arg2)
protected void WriteEvent(int eventId, string arg1, int arg2, int arg3)
protected void WriteEvent(int eventId, string arg1, long arg2)
protected void WriteEvent(int eventId, string arg1, string arg2)
protected void WriteEvent(int eventId, string arg1, string arg2, string arg3)
protected void WriteEventCore(int eventId, int eventDataCount, EventData* data)
protected void WriteEventWithRelatedActivityId(int eventId, Guid relatedActivityId, Object[] args)
protected void WriteEventWithRelatedActivityIdCore(int eventId, Guid* relatedActivityId, int eventDataCount, EventData* data)
public void add_EventCommandExecuted(EventHandler`1<EventCommandEventArgs> value)
public void remove_EventCommandExecuted(EventHandler`1<EventCommandEventArgs> value)
public string GenerateManifest(Type eventSourceType, string assemblyPathToIncludeInManifest)
public string GenerateManifest(Type eventSourceType, string assemblyPathToIncludeInManifest, EventManifestOptions flags)
public Guid GetGuid(Type eventSourceType)
public string GetName(Type eventSourceType)
public IEnumerable`1<EventSource> GetSources()
public void SendCommand(EventSource eventSource, EventCommand command, IDictionary`2<string, string> commandArguments)
public void SetCurrentThreadActivityId(Guid activityId)
public void SetCurrentThreadActivityId(Guid activityId, Guid& oldActivityThatWillContinue)
}
public System.Diagnostics.Tracing.EventSourceAttribute : Attribute {
private string <Guid>k__BackingField
private string <LocalizationResources>k__BackingField
private string <Name>k__BackingField
public string Guid
public string LocalizationResources
public string Name
public string get_Guid()
public void set_Guid(string value)
public string get_LocalizationResources()
public void set_LocalizationResources(string value)
public string get_Name()
public void set_Name(string value)
}
public System.Diagnostics.Tracing.EventSourceCreatedEventArgs : EventArgs {
public EventSource EventSource
public EventSource get_EventSource()
}
public System.Diagnostics.Tracing.EventSourceException : Exception {
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
protected void .ctor(SerializationInfo info, StreamingContext context)
internal void .ctor(Exception innerException)
}
public System.Diagnostics.Tracing.EventSourceOptions : ValueType {
internal EventKeywords keywords
internal EventTags tags
internal EventActivityOptions activityOptions
internal byte level
internal byte opcode
internal byte valuesSet
internal byte keywordsSet
internal byte tagsSet
internal byte levelSet
internal byte opcodeSet
internal byte activityOptionsSet
public EventLevel Level
public EventOpcode Opcode
internal bool IsOpcodeSet
public EventKeywords Keywords
public EventTags Tags
public EventActivityOptions ActivityOptions
public EventLevel get_Level()
public void set_Level(EventLevel value)
public EventOpcode get_Opcode()
public void set_Opcode(EventOpcode value)
internal bool get_IsOpcodeSet()
public EventKeywords get_Keywords()
public void set_Keywords(EventKeywords value)
public EventTags get_Tags()
public void set_Tags(EventTags value)
public EventActivityOptions get_ActivityOptions()
public void set_ActivityOptions(EventActivityOptions value)
}
public System.Diagnostics.Tracing.EventSourceSettings : Enum {
public int value__
public EventSourceSettings Default
public EventSourceSettings ThrowOnEventWriteErrors
public EventSourceSettings EtwManifestEventFormat
public EventSourceSettings EtwSelfDescribingEventFormat
}
public System.Diagnostics.Tracing.EventTags : Enum {
public int value__
public EventTags None
}
public System.Diagnostics.Tracing.EventTask : Enum {
public int value__
public EventTask None
}
public System.Diagnostics.Tracing.EventWrittenEventArgs : EventArgs {
private int <EventId>k__BackingField
private string <EventName>k__BackingField
private EventSource <EventSource>k__BackingField
private string <Message>k__BackingField
private ReadOnlyCollection`1<object> <Payload>k__BackingField
private ReadOnlyCollection`1<string> <PayloadNames>k__BackingField
private Guid <RelatedActivityId>k__BackingField
public Guid ActivityId
public EventChannel Channel
public int EventId
public string EventName
public EventSource EventSource
public EventKeywords Keywords
public EventLevel Level
public string Message
public EventOpcode Opcode
public ReadOnlyCollection`1<object> Payload
public ReadOnlyCollection`1<string> PayloadNames
public Guid RelatedActivityId
public EventTags Tags
public EventTask Task
public byte Version
internal void .ctor(EventSource eventSource)
public Guid get_ActivityId()
public EventChannel get_Channel()
public int get_EventId()
internal void set_EventId(int value)
public string get_EventName()
internal void set_EventName(string value)
public EventSource get_EventSource()
private void set_EventSource(EventSource value)
public EventKeywords get_Keywords()
public EventLevel get_Level()
public string get_Message()
internal void set_Message(string value)
public EventOpcode get_Opcode()
public ReadOnlyCollection`1<object> get_Payload()
internal void set_Payload(ReadOnlyCollection`1<object> value)
public ReadOnlyCollection`1<string> get_PayloadNames()
internal void set_PayloadNames(ReadOnlyCollection`1<string> value)
public Guid get_RelatedActivityId()
internal void set_RelatedActivityId(Guid value)
public EventTags get_Tags()
public EventTask get_Task()
public byte get_Version()
}
public System.DivideByZeroException : ArithmeticException {
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
protected void .ctor(SerializationInfo info, StreamingContext context)
}
public System.DllNotFoundException : TypeLoadException {
public void .ctor(string message)
public void .ctor(string message, Exception inner)
protected void .ctor(SerializationInfo info, StreamingContext context)
}
public System.Double : ValueType {
internal double m_value
public double MinValue
public double MaxValue
public double Epsilon
public double NegativeInfinity
public double PositiveInfinity
public double NaN
internal double NegativeZero
public bool IsInfinity(double d)
public bool IsPositiveInfinity(double d)
public bool IsNegativeInfinity(double d)
internal bool IsNegative(double d)
public bool IsNaN(double d)
public bool IsFinite(double d)
public int CompareTo(object value)
public int CompareTo(double value)
public bool Equals(object obj)
public bool op_Equality(double left, double right)
public bool op_Inequality(double left, double right)
public bool op_LessThan(double left, double right)
public bool op_GreaterThan(double left, double right)
public bool op_LessThanOrEqual(double left, double right)
public bool op_GreaterThanOrEqual(double left, double right)
public bool Equals(double obj)
public int GetHashCode()
public string ToString()
public string ToString(string format)
public string ToString(IFormatProvider provider)
public string ToString(string format, IFormatProvider provider)
public double Parse(string s)
public double Parse(string s, NumberStyles style)
public double Parse(string s, IFormatProvider provider)
public double Parse(string s, NumberStyles style, IFormatProvider provider)
private double Parse(string s, NumberStyles style, NumberFormatInfo info)
public bool TryParse(string s, Double& result)
public bool TryParse(string s, NumberStyles style, IFormatProvider provider, Double& result)
private bool TryParse(string s, NumberStyles style, NumberFormatInfo info, Double& result)
public TypeCode GetTypeCode()
private bool System.IConvertible.ToBoolean(IFormatProvider provider)
private char System.IConvertible.ToChar(IFormatProvider provider)
private sbyte System.IConvertible.ToSByte(IFormatProvider provider)
private byte System.IConvertible.ToByte(IFormatProvider provider)
private short System.IConvertible.ToInt16(IFormatProvider provider)
private ushort System.IConvertible.ToUInt16(IFormatProvider provider)
private int System.IConvertible.ToInt32(IFormatProvider provider)
private UInt32 System.IConvertible.ToUInt32(IFormatProvider provider)
private long System.IConvertible.ToInt64(IFormatProvider provider)
private ulong System.IConvertible.ToUInt64(IFormatProvider provider)
private float System.IConvertible.ToSingle(IFormatProvider provider)
private double System.IConvertible.ToDouble(IFormatProvider provider)
private decimal System.IConvertible.ToDecimal(IFormatProvider provider)
private DateTime System.IConvertible.ToDateTime(IFormatProvider provider)
private object System.IConvertible.ToType(Type type, IFormatProvider provider)
}
internal System.DTSubString : ValueType {
internal string s
internal int index
internal int length
internal DTSubStringType type
internal int value
internal char Item
internal char get_Item(int relativeIndex)
}
internal System.DTSubStringType : Enum {
public int value__
public DTSubStringType Unknown
public DTSubStringType Invalid
public DTSubStringType Number
public DTSubStringType End
public DTSubStringType Other
}
public System.DuplicateWaitObjectException : ArgumentException {
private String modreq(System.Runtime.CompilerServices.IsVolatile) _duplicateWaitObjectMessage
private string DuplicateWaitObjectMessage
private string get_DuplicateWaitObjectMessage()
public void .ctor(string parameterName)
public void .ctor(string parameterName, string message)
public void .ctor(string message, Exception innerException)
protected void .ctor(SerializationInfo info, StreamingContext context)
}
internal System.Empty : object {
public Empty Value
public string ToString()
public void GetObjectData(SerializationInfo info, StreamingContext context)
}
internal System.EmptyArray`1 : object {
public T[] Value
}
public System.EntryPointNotFoundException : TypeLoadException {
public void .ctor(string message)
public void .ctor(string message, Exception inner)
protected void .ctor(SerializationInfo info, StreamingContext context)
}
public System.Enum : ValueType {
private Char[] enumSeperatorCharArray
private string enumSeperator
private ValuesAndNames GetCachedValuesAndNames(RuntimeType enumType, bool getNames)
private string InternalFormattedHexString(object value)
private string InternalFormat(RuntimeType eT, object value)
private string InternalFlagsFormat(RuntimeType eT, object value)
internal ulong ToUInt64(object value)
private int InternalCompareTo(object o1, object o2)
internal RuntimeType InternalGetUnderlyingType(RuntimeType enumType)
private bool GetEnumValuesAndNames(RuntimeType enumType, UInt64[]& values, String[]& names)
private object InternalBoxEnum(RuntimeType enumType, long value)
public bool TryParse(string value, TEnum& result)
public bool TryParse(string value, bool ignoreCase, TEnum& result)
public object Parse(Type enumType, string value)
public object Parse(Type enumType, string value, bool ignoreCase)
private bool TryParseEnum(Type enumType, string value, bool ignoreCase, EnumResult& parseResult)
public Type GetUnderlyingType(Type enumType)
public Array GetValues(Type enumType)
internal UInt64[] InternalGetValues(RuntimeType enumType)
public string GetName(Type enumType, object value)
public String[] GetNames(Type enumType)
internal String[] InternalGetNames(RuntimeType enumType)
public object ToObject(Type enumType, object value)
public bool IsDefined(Type enumType, object value)
public string Format(Type enumType, object value, string format)
private object get_value()
internal object GetValue()
private bool InternalHasFlag(Enum flags)
private int get_hashcode()
public bool Equals(object obj)
public int GetHashCode()
public string ToString()
public string ToString(string format, IFormatProvider provider)
public int CompareTo(object target)
public string ToString(string format)
public string ToString(IFormatProvider provider)
public bool HasFlag(Enum flag)
public TypeCode GetTypeCode()
private bool System.IConvertible.ToBoolean(IFormatProvider provider)
private char System.IConvertible.ToChar(IFormatProvider provider)
private sbyte System.IConvertible.ToSByte(IFormatProvider provider)
private byte System.IConvertible.ToByte(IFormatProvider provider)
private short System.IConvertible.ToInt16(IFormatProvider provider)
private ushort System.IConvertible.ToUInt16(IFormatProvider provider)
private int System.IConvertible.ToInt32(IFormatProvider provider)
private UInt32 System.IConvertible.ToUInt32(IFormatProvider provider)
private long System.IConvertible.ToInt64(IFormatProvider provider)
private ulong System.IConvertible.ToUInt64(IFormatProvider provider)
private float System.IConvertible.ToSingle(IFormatProvider provider)
private double System.IConvertible.ToDouble(IFormatProvider provider)
private decimal System.IConvertible.ToDecimal(IFormatProvider provider)
private DateTime System.IConvertible.ToDateTime(IFormatProvider provider)
private object System.IConvertible.ToType(Type type, IFormatProvider provider)
public object ToObject(Type enumType, sbyte value)
public object ToObject(Type enumType, short value)
public object ToObject(Type enumType, int value)
public object ToObject(Type enumType, byte value)
public object ToObject(Type enumType, ushort value)
public object ToObject(Type enumType, UInt32 value)
public object ToObject(Type enumType, long value)
public object ToObject(Type enumType, ulong value)
private object ToObject(Type enumType, char value)
private object ToObject(Type enumType, bool value)
}
public System.Environment : object {
private int mono_corlib_version
private string nl
private OperatingSystem os
internal bool IsWindows8OrAbove
public string CommandLine
public string CurrentDirectory
public int CurrentManagedThreadId
public int ExitCode
public bool HasShutdownStarted
public string MachineName
public string NewLine
private PlatformID Platform
public OperatingSystem OSVersion
public string StackTrace
public string SystemDirectory
public int TickCount
public string UserDomainName
public bool UserInteractive
public string UserName
public Version Version
public long WorkingSet
public bool Is64BitOperatingSystem
public int SystemPageSize
public bool Is64BitProcess
public int ProcessorCount
internal bool IsRunningOnWindows
private string GacPath
internal bool IsUnix
internal bool IsMacOS
internal bool IsCLRHosted
internal bool IsWinRTSupported
internal string GetResourceString(string key)
internal string GetResourceString(string key, CultureInfo culture)
internal string GetResourceString(string key, Object[] values)
internal string GetRuntimeResourceString(string key)
internal string GetRuntimeResourceString(string key, Object[] values)
internal string GetResourceStringEncodingName(int codePage)
internal bool get_IsWindows8OrAbove()
public string get_CommandLine()
public string get_CurrentDirectory()
public void set_CurrentDirectory(string value)
public int get_CurrentManagedThreadId()
public int get_ExitCode()
public void set_ExitCode(int value)
public bool get_HasShutdownStarted()
public string get_MachineName()
private string GetNewLine()
public string get_NewLine()
private PlatformID get_Platform()
internal string GetOSVersionString()
public OperatingSystem get_OSVersion()
internal Version CreateVersionFromString(string info)
public string get_StackTrace()
public string get_SystemDirectory()
public int get_TickCount()
public string get_UserDomainName()
public bool get_UserInteractive()
public string get_UserName()
public Version get_Version()
public long get_WorkingSet()
public void Exit(int exitCode)
internal void _Exit(int exitCode)
public string ExpandEnvironmentVariables(string name)
public String[] GetCommandLineArgs()
internal string internalGetEnvironmentVariable_native(IntPtr variable)
internal string internalGetEnvironmentVariable(string variable)
public string GetEnvironmentVariable(string variable)
private Hashtable GetEnvironmentVariablesNoCase()
public IDictionary GetEnvironmentVariables()
public string GetFolderPath(SpecialFolder folder)
private string GetWindowsFolderPath(int folder)
public string GetFolderPath(SpecialFolder folder, SpecialFolderOption option)
private string ReadXdgUserDir(string config_dir, string home_dir, string key, string fallback)
internal string UnixGetFolderPath(SpecialFolder folder, SpecialFolderOption option)
public String[] GetLogicalDrives()
private void internalBroadcastSettingChange()
public string GetEnvironmentVariable(string variable, EnvironmentVariableTarget target)
public IDictionary GetEnvironmentVariables(EnvironmentVariableTarget target)
public void SetEnvironmentVariable(string variable, string value)
public void SetEnvironmentVariable(string variable, string value, EnvironmentVariableTarget target)
internal void InternalSetEnvironmentVariable(string variable, string value)
public void FailFast(string message)
internal void FailFast(string message, UInt32 exitCode)
public void FailFast(string message, Exception exception)
private bool GetIs64BitOperatingSystem()
public bool get_Is64BitOperatingSystem()
public int get_SystemPageSize()
public bool get_Is64BitProcess()
public int get_ProcessorCount()
internal bool get_IsRunningOnWindows()
private string get_GacPath()
internal string internalGetGacPath()
private String[] GetLogicalDrivesInternal()
private String[] GetEnvironmentVariableNames()
internal string GetMachineConfigPath()
internal string internalGetHome()
internal int GetPageSize()
private string get_bundled_machine_config()
internal string GetBundledMachineConfig()
internal bool get_IsUnix()
internal bool get_IsMacOS()
internal bool get_IsCLRHosted()
internal void TriggerCodeContractFailure(ContractFailureKind failureKind, string message, string condition, string exceptionAsString)
internal string GetStackTrace(Exception e, bool needFileInfo)
internal bool get_IsWinRTSupported()
}
public System.EnvironmentVariableTarget : Enum {
public int value__
public EnvironmentVariableTarget Process
public EnvironmentVariableTarget User
public EnvironmentVariableTarget Machine
}
public System.EventArgs : object {
public EventArgs Empty
}
public System.EventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, EventArgs e)
public IAsyncResult BeginInvoke(object sender, EventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.EventHandler`1 : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, TEventArgs e)
public IAsyncResult BeginInvoke(object sender, TEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.Exception : object {
private object s_EDILock
private string _className
internal string _message
private IDictionary _data
private Exception _innerException
private string _helpURL
private object _stackTrace
private string _stackTraceString
private string _remoteStackTraceString
private int _remoteStackIndex
private object _dynamicMethods
internal int _HResult
private string _source
private SafeSerializationManager _safeSerializationManager
internal StackTrace[] captured_traces
private IntPtr[] native_trace_ips
private int _COMPlusExceptionCode
public string Message
public IDictionary Data
public Exception InnerException
public MethodBase TargetSite
public string StackTrace
public string HelpLink
public string Source
internal string RemoteStackTrace
public int HResult
internal bool IsTransient
private void Init()
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
protected void .ctor(SerializationInfo info, StreamingContext context)
public string get_Message()
public IDictionary get_Data()
private bool IsImmutableAgileException(Exception e)
internal void AddExceptionDataForRestrictedErrorInfo(string restrictedError, string restrictedErrorReference, string restrictedCapabilitySid, object restrictedErrorObject, bool hasrestrictedLanguageErrorObject)
internal bool TryGetRestrictedLanguageErrorObject(Object& restrictedErrorObject)
private string GetClassName()
public Exception GetBaseException()
public Exception get_InnerException()
private IRuntimeMethodInfo GetMethodFromStackTrace(object stackTrace)
public MethodBase get_TargetSite()
public string get_StackTrace()
private string GetStackTrace(bool needFileInfo)
internal void SetErrorCode(int hr)
public string get_HelpLink()
public void set_HelpLink(string value)
public string get_Source()
public void set_Source(string value)
public string ToString()
private string ToString(bool needFileLineInfo, bool needMessage)
protected void add_SerializeObjectState(EventHandler`1<SafeSerializationEventArgs> value)
protected void remove_SerializeObjectState(EventHandler`1<SafeSerializationEventArgs> value)
public void GetObjectData(SerializationInfo info, StreamingContext context)
internal Exception PrepForRemoting()
private void OnDeserialized(StreamingContext context)
internal void InternalPreserveStackTrace()
internal string get_RemoteStackTrace()
private string StripFileInfo(string stackTrace, bool isRemoteStackTrace)
internal void RestoreExceptionDispatchInfo(ExceptionDispatchInfo exceptionDispatchInfo)
public int get_HResult()
protected void set_HResult(int value)
internal string InternalToString()
public Type GetType()
internal bool get_IsTransient()
private bool nIsTransient(int hr)
internal string GetMessageFromNativeResources(ExceptionMessageKind kind)
internal void SetMessage(string s)
internal void SetStackTrace(string s)
internal Exception FixRemotingException()
}
internal System.ExceptionArgument : Enum {
public int value__
public ExceptionArgument obj
public ExceptionArgument dictionary
public ExceptionArgument dictionaryCreationThreshold
public ExceptionArgument array
public ExceptionArgument info
public ExceptionArgument key
public ExceptionArgument collection
public ExceptionArgument list
public ExceptionArgument match
public ExceptionArgument converter
public ExceptionArgument queue
public ExceptionArgument stack
public ExceptionArgument capacity
public ExceptionArgument index
public ExceptionArgument startIndex
public ExceptionArgument value
public ExceptionArgument count
public ExceptionArgument arrayIndex
public ExceptionArgument name
public ExceptionArgument mode
public ExceptionArgument item
public ExceptionArgument options
public ExceptionArgument view
public ExceptionArgument sourceBytesToCopy
public ExceptionArgument start
public ExceptionArgument pointer
public ExceptionArgument ownedMemory
public ExceptionArgument text
}
internal System.ExceptionResource : Enum {
public int value__
public ExceptionResource Argument_ImplementIComparable
public ExceptionResource Argument_InvalidType
public ExceptionResource Argument_InvalidArgumentForComparison
public ExceptionResource Argument_InvalidRegistryKeyPermissionCheck
public ExceptionResource ArgumentOutOfRange_NeedNonNegNum
public ExceptionResource Arg_ArrayPlusOffTooSmall
public ExceptionResource Arg_NonZeroLowerBound
public ExceptionResource Arg_RankMultiDimNotSupported
public ExceptionResource Arg_RegKeyDelHive
public ExceptionResource Arg_RegKeyStrLenBug
public ExceptionResource Arg_RegSetStrArrNull
public ExceptionResource Arg_RegSetMismatchedKind
public ExceptionResource Arg_RegSubKeyAbsent
public ExceptionResource Arg_RegSubKeyValueAbsent
public ExceptionResource Argument_AddingDuplicate
public ExceptionResource Serialization_InvalidOnDeser
public ExceptionResource Serialization_MissingKeys
public ExceptionResource Serialization_NullKey
public ExceptionResource Argument_InvalidArrayType
public ExceptionResource NotSupported_KeyCollectionSet
public ExceptionResource NotSupported_ValueCollectionSet
public ExceptionResource ArgumentOutOfRange_SmallCapacity
public ExceptionResource ArgumentOutOfRange_Index
public ExceptionResource Argument_InvalidOffLen
public ExceptionResource Argument_ItemNotExist
public ExceptionResource ArgumentOutOfRange_Count
public ExceptionResource ArgumentOutOfRange_InvalidThreshold
public ExceptionResource ArgumentOutOfRange_ListInsert
public ExceptionResource NotSupported_ReadOnlyCollection
public ExceptionResource InvalidOperation_CannotRemoveFromStackOrQueue
public ExceptionResource InvalidOperation_EmptyQueue
public ExceptionResource InvalidOperation_EnumOpCantHappen
public ExceptionResource InvalidOperation_EnumFailedVersion
public ExceptionResource InvalidOperation_EmptyStack
public ExceptionResource ArgumentOutOfRange_BiggerThanCollection
public ExceptionResource InvalidOperation_EnumNotStarted
public ExceptionResource InvalidOperation_EnumEnded
public ExceptionResource NotSupported_SortedListNestedWrite
public ExceptionResource InvalidOperation_NoValue
public ExceptionResource InvalidOperation_RegRemoveSubKey
public ExceptionResource Security_RegistryPermission
public ExceptionResource UnauthorizedAccess_RegistryNoWrite
public ExceptionResource ObjectDisposed_RegKeyClosed
public ExceptionResource NotSupported_InComparableType
public ExceptionResource Argument_InvalidRegistryOptionsCheck
public ExceptionResource Argument_InvalidRegistryViewCheck
}
public System.ExecutionEngineException : SystemException {
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
internal void .ctor(SerializationInfo info, StreamingContext context)
}
public System.FieldAccessException : MemberAccessException {
public void .ctor(string message)
public void .ctor(string message, Exception inner)
protected void .ctor(SerializationInfo info, StreamingContext context)
}
public System.FormatException : SystemException {
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
protected void .ctor(SerializationInfo info, StreamingContext context)
}
public System.FormattableString : object {
public string Format
public int ArgumentCount
public string get_Format()
public Object[] GetArguments()
public int get_ArgumentCount()
public object GetArgument(int index)
public string ToString(IFormatProvider formatProvider)
private string System.IFormattable.ToString(string ignored, IFormatProvider formatProvider)
public string Invariant(FormattableString formattable)
public string ToString()
}
public System.Func`1 : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public TResult Invoke()
public IAsyncResult BeginInvoke(AsyncCallback callback, object object)
public TResult EndInvoke(IAsyncResult result)
}
public System.Func`2 : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public TResult Invoke(T arg)
public IAsyncResult BeginInvoke(T arg, AsyncCallback callback, object object)
public TResult EndInvoke(IAsyncResult result)
}
public System.Func`3 : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public TResult Invoke(T1 arg1, T2 arg2)
public IAsyncResult BeginInvoke(T1 arg1, T2 arg2, AsyncCallback callback, object object)
public TResult EndInvoke(IAsyncResult result)
}
public System.Func`4 : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public TResult Invoke(T1 arg1, T2 arg2, T3 arg3)
public IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, AsyncCallback callback, object object)
public TResult EndInvoke(IAsyncResult result)
}
public System.Func`5 : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4)
public IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, AsyncCallback callback, object object)
public TResult EndInvoke(IAsyncResult result)
}
public System.Func`6 : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5)
public IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, AsyncCallback callback, object object)
public TResult EndInvoke(IAsyncResult result)
}
public System.Func`7 : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6)
public IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, AsyncCallback callback, object object)
public TResult EndInvoke(IAsyncResult result)
}
public System.Func`8 : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7)
public IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, AsyncCallback callback, object object)
public TResult EndInvoke(IAsyncResult result)
}
public System.Func`9 : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8)
public IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, AsyncCallback callback, object object)
public TResult EndInvoke(IAsyncResult result)
}
public System.GC : object {
internal object EPHEMERON_TOMBSTONE
public int MaxGeneration
private int GetCollectionCount(int generation)
private int GetMaxGeneration()
private void InternalCollect(int generation)
private void RecordPressure(long bytesAllocated)
internal void register_ephemeron_array(Ephemeron[] array)
private object get_ephemeron_tombstone()
public void AddMemoryPressure(long bytesAllocated)
public void RemoveMemoryPressure(long bytesAllocated)
public int GetGeneration(object obj)
public void Collect(int generation)
public void Collect()
public void Collect(int generation, GCCollectionMode mode)
public void Collect(int generation, GCCollectionMode mode, bool blocking)
public void Collect(int generation, GCCollectionMode mode, bool blocking, bool compacting)
public int CollectionCount(int generation)
public void KeepAlive(object obj)
public int GetGeneration(WeakReference wo)
public int get_MaxGeneration()
public void WaitForPendingFinalizers()
private void _SuppressFinalize(object o)
public void SuppressFinalize(object obj)
private void _ReRegisterForFinalize(object o)
public void ReRegisterForFinalize(object obj)
public long GetTotalMemory(bool forceFullCollection)
private bool _RegisterForFullGCNotification(int maxGenerationPercentage, int largeObjectHeapPercentage)
private bool _CancelFullGCNotification()
private int _WaitForFullGCApproach(int millisecondsTimeout)
private int _WaitForFullGCComplete(int millisecondsTimeout)
public void RegisterForFullGCNotification(int maxGenerationThreshold, int largeObjectHeapThreshold)
public void CancelFullGCNotification()
public GCNotificationStatus WaitForFullGCApproach()
public GCNotificationStatus WaitForFullGCApproach(int millisecondsTimeout)
public GCNotificationStatus WaitForFullGCComplete()
public GCNotificationStatus WaitForFullGCComplete(int millisecondsTimeout)
private bool StartNoGCRegionWorker(long totalSize, bool hasLohSize, long lohSize, bool disallowFullBlockingGC)
public bool TryStartNoGCRegion(long totalSize)
public bool TryStartNoGCRegion(long totalSize, long lohSize)
public bool TryStartNoGCRegion(long totalSize, bool disallowFullBlockingGC)
public bool TryStartNoGCRegion(long totalSize, long lohSize, bool disallowFullBlockingGC)
private EndNoGCRegionStatus EndNoGCRegionWorker()
public void EndNoGCRegion()
}
public System.GCCollectionMode : Enum {
public int value__
public GCCollectionMode Default
public GCCollectionMode Forced
public GCCollectionMode Optimized
}
public System.GCNotificationStatus : Enum {
public int value__
public GCNotificationStatus Succeeded
public GCNotificationStatus Failed
public GCNotificationStatus Canceled
public GCNotificationStatus Timeout
public GCNotificationStatus NotApplicable
}
internal System.Globalization.BidiCategory : Enum {
public int value__
public BidiCategory LeftToRight
public BidiCategory LeftToRightEmbedding
public BidiCategory LeftToRightOverride
public BidiCategory RightToLeft
public BidiCategory RightToLeftArabic
public BidiCategory RightToLeftEmbedding
public BidiCategory RightToLeftOverride
public BidiCategory PopDirectionalFormat
public BidiCategory EuropeanNumber
public BidiCategory EuropeanNumberSeparator
public BidiCategory EuropeanNumberTerminator
public BidiCategory ArabicNumber
public BidiCategory CommonNumberSeparator
public BidiCategory NonSpacingMark
public BidiCategory BoundaryNeutral
public BidiCategory ParagraphSeparator
public BidiCategory SegmentSeparator
public BidiCategory Whitespace
public BidiCategory OtherNeutrals
public BidiCategory LeftToRightIsolate
public BidiCategory RightToLeftIsolate
public BidiCategory FirstStrongIsolate
public BidiCategory PopDirectionIsolate
}
internal System.Globalization.Bootstring : object {
private char delimiter
private int base_num
private int tmin
private int tmax
private int skew
private int damp
private int initial_bias
private int initial_n
public void .ctor(char delimiter, int baseNum, int tmin, int tmax, int skew, int damp, int initialBias, int initialN)
public string Encode(string s, int offset)
private char EncodeDigit(int d)
private int DecodeDigit(char c)
private int Adapt(int delta, int numPoints, bool firstTime)
public string Decode(string s, int offset)
}
public System.Globalization.Calendar : object {
internal long TicksPerMillisecond
internal long TicksPerSecond
internal long TicksPerMinute
internal long TicksPerHour
internal long TicksPerDay
internal int MillisPerSecond
internal int MillisPerMinute
internal int MillisPerHour
internal int MillisPerDay
internal int DaysPerYear
internal int DaysPer4Years
internal int DaysPer100Years
internal int DaysPer400Years
internal int DaysTo10000
internal long MaxMillis
internal int CAL_GREGORIAN
internal int CAL_GREGORIAN_US
internal int CAL_JAPAN
internal int CAL_TAIWAN
internal int CAL_KOREA
internal int CAL_HIJRI
internal int CAL_THAI
internal int CAL_HEBREW
internal int CAL_GREGORIAN_ME_FRENCH
internal int CAL_GREGORIAN_ARABIC
internal int CAL_GREGORIAN_XLIT_ENGLISH
internal int CAL_GREGORIAN_XLIT_FRENCH
internal int CAL_JULIAN
internal int CAL_JAPANESELUNISOLAR
internal int CAL_CHINESELUNISOLAR
internal int CAL_SAKA
internal int CAL_LUNAR_ETO_CHN
internal int CAL_LUNAR_ETO_KOR
internal int CAL_LUNAR_ETO_ROKUYOU
internal int CAL_KOREANLUNISOLAR
internal int CAL_TAIWANLUNISOLAR
internal int CAL_PERSIAN
internal int CAL_UMALQURA
internal int m_currentEraValue
private bool m_isReadOnly
public int CurrentEra
internal int twoDigitYearMax
public DateTime MinSupportedDateTime
public DateTime MaxSupportedDateTime
internal int ID
internal int BaseCalendarID
public CalendarAlgorithmType AlgorithmType
public bool IsReadOnly
internal int CurrentEraValue
public Int32[] Eras
protected int DaysInYearBeforeMinSupportedYear
public int TwoDigitYearMax
public DateTime get_MinSupportedDateTime()
public DateTime get_MaxSupportedDateTime()
internal int get_ID()
internal int get_BaseCalendarID()
public CalendarAlgorithmType get_AlgorithmType()
public bool get_IsReadOnly()
public object Clone()
public Calendar ReadOnly(Calendar calendar)
internal void VerifyWritable()
internal void SetReadOnlyState(bool readOnly)
internal int get_CurrentEraValue()
internal void CheckAddResult(long ticks, DateTime minValue, DateTime maxValue)
internal DateTime Add(DateTime time, double value, int scale)
public DateTime AddMilliseconds(DateTime time, double milliseconds)
public DateTime AddDays(DateTime time, int days)
public DateTime AddHours(DateTime time, int hours)
public DateTime AddMinutes(DateTime time, int minutes)
public DateTime AddMonths(DateTime time, int months)
public DateTime AddSeconds(DateTime time, int seconds)
public DateTime AddWeeks(DateTime time, int weeks)
public DateTime AddYears(DateTime time, int years)
public int GetDayOfMonth(DateTime time)
public DayOfWeek GetDayOfWeek(DateTime time)
public int GetDayOfYear(DateTime time)
public int GetDaysInMonth(int year, int month)
public int GetDaysInMonth(int year, int month, int era)
public int GetDaysInYear(int year)
public int GetDaysInYear(int year, int era)
public int GetEra(DateTime time)
public Int32[] get_Eras()
public int GetHour(DateTime time)
public double GetMilliseconds(DateTime time)
public int GetMinute(DateTime time)
public int GetMonth(DateTime time)
public int GetMonthsInYear(int year)
public int GetMonthsInYear(int year, int era)
public int GetSecond(DateTime time)
internal int GetFirstDayWeekOfYear(DateTime time, int firstDayOfWeek)
private int GetWeekOfYearFullDays(DateTime time, int firstDayOfWeek, int fullDays)
private int GetWeekOfYearOfMinSupportedDateTime(int firstDayOfWeek, int minimumDaysInFirstWeek)
protected int get_DaysInYearBeforeMinSupportedYear()
public int GetWeekOfYear(DateTime time, CalendarWeekRule rule, DayOfWeek firstDayOfWeek)
public int GetYear(DateTime time)
public bool IsLeapDay(int year, int month, int day)
public bool IsLeapDay(int year, int month, int day, int era)
public bool IsLeapMonth(int year, int month)
public bool IsLeapMonth(int year, int month, int era)
public int GetLeapMonth(int year)
public int GetLeapMonth(int year, int era)
public bool IsLeapYear(int year)
public bool IsLeapYear(int year, int era)
public DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond)
public DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era)
internal bool TryToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era, DateTime& result)
internal bool IsValidYear(int year, int era)
internal bool IsValidMonth(int year, int month, int era)
internal bool IsValidDay(int year, int month, int day, int era)
public int get_TwoDigitYearMax()
public void set_TwoDigitYearMax(int value)
public int ToFourDigitYear(int year)
internal long TimeToTicks(int hour, int minute, int second, int millisecond)
internal int GetSystemTwoDigitYearSetting(int CalID, int defaultYearValue)
}
public System.Globalization.CalendarAlgorithmType : Enum {
public int value__
public CalendarAlgorithmType Unknown
public CalendarAlgorithmType SolarCalendar
public CalendarAlgorithmType LunarCalendar
public CalendarAlgorithmType LunisolarCalendar
}
internal System.Globalization.CalendarData : object {
internal int MAX_CALENDARS
internal string sNativeName
internal String[] saShortDates
internal String[] saYearMonths
internal String[] saLongDates
internal string sMonthDay
internal String[] saEraNames
internal String[] saAbbrevEraNames
internal String[] saAbbrevEnglishEraNames
internal String[] saDayNames
internal String[] saAbbrevDayNames
internal String[] saSuperShortDayNames
internal String[] saMonthNames
internal String[] saAbbrevMonthNames
internal String[] saMonthGenitiveNames
internal String[] saAbbrevMonthGenitiveNames
internal String[] saLeapYearMonthNames
internal int iTwoDigitYearMax
internal int iCurrentEra
internal bool bUseUserOverrides
internal CalendarData Invariant
internal void .ctor(string localeName, int calendarId, bool bUseUserOverrides)
private void InitializeEraNames(string localeName, int calendarId)
private void InitializeAbbreviatedEraNames(string localeName, int calendarId)
internal CalendarData GetCalendarData(int calendarId)
private string CalendarIdToCultureName(int calendarId)
public int nativeGetTwoDigitYearMax(int calID)
private bool nativeGetCalendarData(CalendarData data, string localeName, int calendarId)
private bool fill_calendar_data(string localeName, int datetimeIndex)
}
internal System.Globalization.CalendarId : Enum {
public ushort value__
public CalendarId GREGORIAN
public CalendarId GREGORIAN_US
public CalendarId JAPAN
public CalendarId TAIWAN
public CalendarId KOREA
public CalendarId HIJRI
public CalendarId THAI
public CalendarId HEBREW
public CalendarId GREGORIAN_ME_FRENCH
public CalendarId GREGORIAN_ARABIC
public CalendarId GREGORIAN_XLIT_ENGLISH
public CalendarId GREGORIAN_XLIT_FRENCH
public CalendarId JULIAN
public CalendarId JAPANESELUNISOLAR
public CalendarId CHINESELUNISOLAR
public CalendarId SAKA
public CalendarId LUNAR_ETO_CHN
public CalendarId LUNAR_ETO_KOR
public CalendarId LUNAR_ETO_ROKUYOU
public CalendarId KOREANLUNISOLAR
public CalendarId TAIWANLUNISOLAR
public CalendarId PERSIAN
public CalendarId UMALQURA
public CalendarId LAST_CALENDAR
}
public System.Globalization.CalendarWeekRule : Enum {
public int value__
public CalendarWeekRule FirstDay
public CalendarWeekRule FirstFullWeek
public CalendarWeekRule FirstFourDayWeek
}
internal System.Globalization.CalendricalCalculationsHelper : object {
private double FullCircleOfArc
private int HalfCircleOfArc
private double TwelveHours
private double Noon2000Jan01
internal double MeanTropicalYearInDays
private double MeanSpeedOfSun
private double LongitudeSpring
private double TwoDegreesAfterSpring
private int SecondsPerDay
private int DaysInUniformLengthCentury
private int SecondsPerMinute
private int MinutesPerDegree
private long StartOf1810
private long StartOf1900Century
private Double[] Coefficients1900to1987
private Double[] Coefficients1800to1899
private Double[] Coefficients1700to1799
private Double[] Coefficients1620to1699
private Double[] LambdaCoefficients
private Double[] AnomalyCoefficients
private Double[] EccentricityCoefficients
private Double[] Coefficients
private Double[] CoefficientsA
private Double[] CoefficientsB
private EphemerisCorrectionAlgorithmMap[] EphemerisCorrectionTable
private double RadiansFromDegrees(double degree)
private double SinOfDegree(double degree)
private double CosOfDegree(double degree)
private double TanOfDegree(double degree)
public double Angle(int degrees, int minutes, double seconds)
private double Obliquity(double julianCenturies)
internal long GetNumberOfDays(DateTime date)
private int GetGregorianYear(double numberOfDays)
private double Reminder(double divisor, double dividend)
private double NormalizeLongitude(double longitude)
public double AsDayFraction(double longitude)
private double PolynomialSum(Double[] coefficients, double indeterminate)
private double CenturiesFrom1900(int gregorianYear)
private double DefaultEphemerisCorrection(int gregorianYear)
private double EphemerisCorrection1988to2019(int gregorianYear)
private double EphemerisCorrection1900to1987(int gregorianYear)
private double EphemerisCorrection1800to1899(int gregorianYear)
private double EphemerisCorrection1700to1799(int gregorianYear)
private double EphemerisCorrection1620to1699(int gregorianYear)
private double EphemerisCorrection(double time)
public double JulianCenturies(double moment)
private bool IsNegative(double value)
private double CopySign(double value, double sign)
private double EquationOfTime(double time)
private double AsLocalTime(double apparentMidday, double longitude)
public double Midday(double date, double longitude)
private double InitLongitude(double longitude)
public double MiddayAtPersianObservationSite(double date)
private double PeriodicTerm(double julianCenturies, int x, double y, double z)
private double SumLongSequenceOfPeriodicTerms(double julianCenturies)
private double Aberration(double julianCenturies)
private double Nutation(double julianCenturies)
public double Compute(double time)
public double AsSeason(double longitude)
private double EstimatePrior(double longitude, double time)
internal long PersianNewYearOnOrBefore(long numberOfDays)
}
public System.Globalization.CharUnicodeInfo : object {
internal char HIGH_SURROGATE_START
internal char HIGH_SURROGATE_END
internal char LOW_SURROGATE_START
internal char LOW_SURROGATE_END
internal int UNICODE_CATEGORY_OFFSET
internal int BIDI_CATEGORY_OFFSET
internal int UNICODE_PLANE01_START
private UInt16[] s_pCategoryLevel1Index
private Byte[] s_pCategoriesValue
private UInt16[] s_pNumericLevel1Index
private Byte[] s_pNumericValues
private UInt16[] s_pDigitValues
internal int InternalConvertToUtf32(string s, int index)
internal int InternalConvertToUtf32(string s, int index, Int32& charLength)
internal bool IsWhiteSpace(string s, int index)
internal bool IsWhiteSpace(char c)
internal double InternalGetNumericValue(int ch)
internal ushort InternalGetDigitValues(int ch)
public double GetNumericValue(char ch)
public double GetNumericValue(string s, int index)
public int GetDecimalDigitValue(char ch)
public int GetDecimalDigitValue(string s, int index)
public int GetDigitValue(char ch)
public int GetDigitValue(string s, int index)
public UnicodeCategory GetUnicodeCategory(char ch)
public UnicodeCategory GetUnicodeCategory(string s, int index)
internal UnicodeCategory InternalGetUnicodeCategory(int ch)
internal byte InternalGetCategoryValue(int ch, int offset)
internal UnicodeCategory InternalGetUnicodeCategory(string value, int index)
internal UnicodeCategory InternalGetUnicodeCategory(string str, int index, Int32& charLength)
internal bool IsCombiningCategory(UnicodeCategory uc)
}
public System.Globalization.ChineseLunisolarCalendar : EastAsianLunisolarCalendar {
public int ChineseEra
internal int MIN_LUNISOLAR_YEAR
internal int MAX_LUNISOLAR_YEAR
internal int MIN_GREGORIAN_YEAR
internal int MIN_GREGORIAN_MONTH
internal int MIN_GREGORIAN_DAY
internal int MAX_GREGORIAN_YEAR
internal int MAX_GREGORIAN_MONTH
internal int MAX_GREGORIAN_DAY
internal DateTime minDate
internal DateTime maxDate
private Int32[0...,0...] yinfo
public DateTime MinSupportedDateTime
public DateTime MaxSupportedDateTime
protected int DaysInYearBeforeMinSupportedYear
internal int MinCalendarYear
internal int MaxCalendarYear
internal DateTime MinDate
internal DateTime MaxDate
internal EraInfo[] CalEraInfo
internal int ID
internal int BaseCalendarID
public Int32[] Eras
public DateTime get_MinSupportedDateTime()
public DateTime get_MaxSupportedDateTime()
protected int get_DaysInYearBeforeMinSupportedYear()
internal int get_MinCalendarYear()
internal int get_MaxCalendarYear()
internal DateTime get_MinDate()
internal DateTime get_MaxDate()
internal EraInfo[] get_CalEraInfo()
internal int GetYearInfo(int LunarYear, int Index)
internal int GetYear(int year, DateTime time)
internal int GetGregorianYear(int year, int era)
public int GetEra(DateTime time)
internal int get_ID()
internal int get_BaseCalendarID()
public Int32[] get_Eras()
}
internal System.Globalization.CodePageDataItem : object {
internal int m_dataIndex
internal int m_uiFamilyCodePage
internal string m_webName
internal string m_headerName
internal string m_bodyName
internal UInt32 m_flags
private Char[] sep
public string WebName
public int UIFamilyCodePage
public string HeaderName
public string BodyName
public UInt32 Flags
internal void .ctor(int dataIndex)
internal string CreateString(string pStrings, UInt32 index)
public string get_WebName()
public int get_UIFamilyCodePage()
public string get_HeaderName()
public string get_BodyName()
public UInt32 get_Flags()
}
public System.Globalization.CompareInfo : object {
private CompareOptions ValidIndexMaskOffFlags
private CompareOptions ValidCompareMaskOffFlags
private CompareOptions ValidHashCodeOfStringMaskOffFlags
private string m_name
private string m_sortName
private int win32LCID
private int culture
private int LINGUISTIC_IGNORECASE
private int NORM_IGNORECASE
private int NORM_IGNOREKANATYPE
private int LINGUISTIC_IGNOREDIACRITIC
private int NORM_IGNORENONSPACE
private int NORM_IGNORESYMBOLS
private int NORM_IGNOREWIDTH
private int SORT_STRINGSORT
private int COMPARE_OPTIONS_ORDINAL
internal int NORM_LINGUISTIC_CASING
private int RESERVED_FIND_ASCII_STRING
private int SORT_VERSION_WHIDBEY
private int SORT_VERSION_V4
private SortVersion m_SortVersion
private SimpleCollator collator
private Dictionary`2<string, SimpleCollator> collators
private bool managedCollation
private bool managedCollationChecked
public string Name
public int LCID
internal bool IsLegacy20SortingBehaviorRequested
private UInt32 InternalSortVersion
public SortVersion Version
private bool UseManagedCollation
internal void .ctor(CultureInfo culture)
public CompareInfo GetCompareInfo(int culture, Assembly assembly)
public CompareInfo GetCompareInfo(string name, Assembly assembly)
public CompareInfo GetCompareInfo(int culture)
public CompareInfo GetCompareInfo(string name)
public bool IsSortable(char ch)
public bool IsSortable(string text)
private void OnDeserializing(StreamingContext ctx)
private void OnDeserialized()
private void OnDeserialized(StreamingContext ctx)
private void OnSerializing(StreamingContext ctx)
private void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender)
public string get_Name()
internal int GetNativeCompareFlags(CompareOptions options)
public int Compare(string string1, string string2)
public int Compare(string string1, string string2, CompareOptions options)
public int Compare(string string1, int offset1, int length1, string string2, int offset2, int length2)
public int Compare(string string1, int offset1, string string2, int offset2, CompareOptions options)
public int Compare(string string1, int offset1, string string2, int offset2)
public int Compare(string string1, int offset1, int length1, string string2, int offset2, int length2, CompareOptions options)
private int CompareOrdinal(string string1, int offset1, int length1, string string2, int offset2, int length2)
public bool IsPrefix(string source, string prefix, CompareOptions options)
public bool IsPrefix(string source, string prefix)
public bool IsSuffix(string source, string suffix, CompareOptions options)
public bool IsSuffix(string source, string suffix)
public int IndexOf(string source, char value)
public int IndexOf(string source, string value)
public int IndexOf(string source, char value, CompareOptions options)
public int IndexOf(string source, string value, CompareOptions options)
public int IndexOf(string source, char value, int startIndex)
public int IndexOf(string source, string value, int startIndex)
public int IndexOf(string source, char value, int startIndex, CompareOptions options)
public int IndexOf(string source, string value, int startIndex, CompareOptions options)
public int IndexOf(string source, char value, int startIndex, int count)
public int IndexOf(string source, string value, int startIndex, int count)
public int IndexOf(string source, char value, int startIndex, int count, CompareOptions options)
public int IndexOf(string source, string value, int startIndex, int count, CompareOptions options)
public int LastIndexOf(string source, char value)
public int LastIndexOf(string source, string value)
public int LastIndexOf(string source, char value, CompareOptions options)
public int LastIndexOf(string source, string value, CompareOptions options)
public int LastIndexOf(string source, char value, int startIndex)
public int LastIndexOf(string source, string value, int startIndex)
public int LastIndexOf(string source, char value, int startIndex, CompareOptions options)
public int LastIndexOf(string source, string value, int startIndex, CompareOptions options)
public int LastIndexOf(string source, char value, int startIndex, int count)
public int LastIndexOf(string source, string value, int startIndex, int count)
public int LastIndexOf(string source, char value, int startIndex, int count, CompareOptions options)
public int LastIndexOf(string source, string value, int startIndex, int count, CompareOptions options)
public SortKey GetSortKey(string source, CompareOptions options)
public SortKey GetSortKey(string source)
private SortKey CreateSortKey(string source, CompareOptions options)
public bool Equals(object value)
public int GetHashCode()
public int GetHashCode(string source, CompareOptions options)
internal int GetHashCodeOfString(string source, CompareOptions options)
internal int GetHashCodeOfString(string source, CompareOptions options, bool forceRandomizedHashing, long additionalEntropy)
public string ToString()
public int get_LCID()
internal bool get_IsLegacy20SortingBehaviorRequested()
private UInt32 get_InternalSortVersion()
public SortVersion get_Version()
private bool get_UseManagedCollation()
private SimpleCollator GetCollator()
private SortKey CreateSortKeyCore(string source, CompareOptions options)
private int internal_index_switch(string s, int sindex, int count, char c, CompareOptions opt, bool first)
private int internal_index_switch(string s1, int sindex, int count, string s2, CompareOptions opt, bool first)
private int internal_compare_switch(string str1, int offset1, int length1, string str2, int offset2, int length2, CompareOptions options)
private int internal_compare_managed(string str1, int offset1, int length1, string str2, int offset2, int length2, CompareOptions options)
private int internal_index_managed(string s, int sindex, int count, char c, CompareOptions opt, bool first)
private int internal_index_managed(string s1, int sindex, int count, string s2, CompareOptions opt, bool first)
private void assign_sortkey(object key, string source, CompareOptions options)
private int internal_compare(string str1, int offset1, int length1, string str2, int offset2, int length2, CompareOptions options)
private int internal_index(string source, int sindex, int count, char value, CompareOptions options, bool first)
private int internal_index(string source, int sindex, int count, string value, CompareOptions options, bool first)
}
public System.Globalization.CompareOptions : Enum {
public int value__
public CompareOptions None
public CompareOptions IgnoreCase
public CompareOptions IgnoreNonSpace
public CompareOptions IgnoreSymbols
public CompareOptions IgnoreKanaType
public CompareOptions IgnoreWidth
public CompareOptions OrdinalIgnoreCase
public CompareOptions StringSort
public CompareOptions Ordinal
}
internal System.Globalization.CultureData : object {
private string sAM1159
private string sPM2359
private string sTimeSeparator
private String[] modreq(System.Runtime.CompilerServices.IsVolatile) saLongTimes
private String[] modreq(System.Runtime.CompilerServices.IsVolatile) saShortTimes
private int iFirstDayOfWeek
private int iFirstWeekOfYear
private Int32[] modreq(System.Runtime.CompilerServices.IsVolatile) waCalendars
private CalendarData[] calendars
private string sISO639Language
private string sRealName
private bool bUseOverrides
private int calendarId
private int numberIndex
private int iDefaultAnsiCodePage
private int iDefaultOemCodePage
private int iDefaultMacCodePage
private int iDefaultEbcdicCodePage
private bool isRightToLeft
private string sListSeparator
private CultureData s_Invariant
public CultureData Invariant
internal String[] LongTimes
internal String[] ShortTimes
internal string SISO639LANGNAME
internal int IFIRSTDAYOFWEEK
internal int IFIRSTWEEKOFYEAR
internal string SAM1159
internal string SPM2359
internal string TimeSeparator
internal Int32[] CalendarIds
internal bool IsInvariantCulture
internal string CultureName
internal string SCOMPAREINFO
internal string STEXTINFO
internal int ILANGUAGE
internal int IDEFAULTANSICODEPAGE
internal int IDEFAULTOEMCODEPAGE
internal int IDEFAULTMACCODEPAGE
internal int IDEFAULTEBCDICCODEPAGE
internal bool IsRightToLeft
internal string SLIST
internal bool UseUserOverride
private void .ctor(string name)
public CultureData get_Invariant()
public CultureData GetCultureData(string cultureName, bool useUserOverride)
public CultureData GetCultureData(string cultureName, bool useUserOverride, int datetimeIndex, int calendarId, int numberIndex, string iso2lang, int ansiCodePage, int oemCodePage, int macCodePage, int ebcdicCodePage, bool rightToLeft, string listSeparator)
internal CultureData GetCultureData(int culture, bool bUseUserOverride)
private void fill_culture_data(int datetimeIndex)
public CalendarData GetCalendar(int calendarId)
internal String[] get_LongTimes()
internal String[] get_ShortTimes()
internal string get_SISO639LANGNAME()
internal int get_IFIRSTDAYOFWEEK()
internal int get_IFIRSTWEEKOFYEAR()
internal string get_SAM1159()
internal string get_SPM2359()
internal string get_TimeSeparator()
internal Int32[] get_CalendarIds()
internal bool get_IsInvariantCulture()
internal string get_CultureName()
internal string get_SCOMPAREINFO()
internal string get_STEXTINFO()
internal int get_ILANGUAGE()
internal int get_IDEFAULTANSICODEPAGE()
internal int get_IDEFAULTOEMCODEPAGE()
internal int get_IDEFAULTMACCODEPAGE()
internal int get_IDEFAULTEBCDICCODEPAGE()
internal bool get_IsRightToLeft()
internal string get_SLIST()
internal bool get_UseUserOverride()
internal string CalendarName(int calendarId)
internal String[] EraNames(int calendarId)
internal String[] AbbrevEraNames(int calendarId)
internal String[] AbbreviatedEnglishEraNames(int calendarId)
internal String[] ShortDates(int calendarId)
internal String[] LongDates(int calendarId)
internal String[] YearMonths(int calendarId)
internal String[] DayNames(int calendarId)
internal String[] AbbreviatedDayNames(int calendarId)
internal String[] SuperShortDayNames(int calendarId)
internal String[] MonthNames(int calendarId)
internal String[] GenitiveMonthNames(int calendarId)
internal String[] AbbreviatedMonthNames(int calendarId)
internal String[] AbbreviatedGenitiveMonthNames(int calendarId)
internal String[] LeapYearMonthNames(int calendarId)
internal string MonthDay(int calendarId)
internal string DateSeparator(int calendarId)
private string GetDateSeparator(string format)
private string GetSeparator(string format, string timeParts)
private int IndexOfTimePart(string format, int startIndex, string timeParts)
private string UnescapeNlsString(string str, int start, int end)
internal String[] ReescapeWin32Strings(String[] array)
internal string ReescapeWin32String(string str)
internal bool IsCustomCultureId(int cultureId)
internal void GetNFIValues(NumberFormatInfo nfi)
private void fill_number_data(NumberFormatInfo nfi, int numberIndex)
}
public System.Globalization.CultureInfo : object {
private CultureInfo modreq(System.Runtime.CompilerServices.IsVolatile) invariant_culture_info
private object shared_table_lock
private CultureInfo default_current_culture
private bool m_isReadOnly
private int cultureID
private int parent_lcid
private int datetime_index
private int number_index
private int default_calendar_type
private bool m_useUserOverride
internal NumberFormatInfo modreq(System.Runtime.CompilerServices.IsVolatile) numInfo
internal DateTimeFormatInfo modreq(System.Runtime.CompilerServices.IsVolatile) dateTimeInfo
private TextInfo modreq(System.Runtime.CompilerServices.IsVolatile) textInfo
internal string m_name
private string englishname
private string nativename
private string iso3lang
private string iso2lang
private string win3lang
private string territory
private String[] native_calendar_names
private CompareInfo modreq(System.Runtime.CompilerServices.IsVolatile) compareInfo
private Void* textinfo_data
private int m_dataItem
private Calendar calendar
private CultureInfo parent_culture
private bool constructed
internal Byte[] cached_serialized_form
internal CultureData m_cultureData
internal bool m_isInherited
internal int InvariantCultureId
private int CalendarTypeBits
private string MSG_READONLY
private CultureInfo modreq(System.Runtime.CompilerServices.IsVolatile) s_DefaultThreadCurrentUICulture
private CultureInfo modreq(System.Runtime.CompilerServices.IsVolatile) s_DefaultThreadCurrentCulture
private Dictionary`2<int, CultureInfo> shared_by_number
private Dictionary`2<string, CultureInfo> shared_by_name
internal bool IsTaiwanSku
public CultureInfo InvariantCulture
public CultureInfo CurrentCulture
public CultureInfo CurrentUICulture
internal string Territory
public CultureTypes CultureTypes
public string IetfLanguageTag
public int KeyboardLayoutId
public int LCID
public string Name
public string NativeName
internal string NativeCalendarName
public Calendar Calendar
public Calendar[] OptionalCalendars
public CultureInfo Parent
public TextInfo TextInfo
public string ThreeLetterISOLanguageName
public string ThreeLetterWindowsLanguageName
public string TwoLetterISOLanguageName
public bool UseUserOverride
public CompareInfo CompareInfo
public bool IsNeutralCulture
public NumberFormatInfo NumberFormat
public DateTimeFormatInfo DateTimeFormat
public string DisplayName
public string EnglishName
public CultureInfo InstalledUICulture
public bool IsReadOnly
internal int CalendarType
public CultureInfo DefaultThreadCurrentCulture
public CultureInfo DefaultThreadCurrentUICulture
internal string SortName
internal CultureInfo UserDefaultUICulture
internal CultureInfo UserDefaultCulture
internal bool HasInvariantCultureName
public CultureInfo get_InvariantCulture()
public CultureInfo get_CurrentCulture()
public void set_CurrentCulture(CultureInfo value)
public CultureInfo get_CurrentUICulture()
public void set_CurrentUICulture(CultureInfo value)
internal CultureInfo ConstructCurrentCulture()
internal CultureInfo ConstructCurrentUICulture()
internal string get_Territory()
public CultureTypes get_CultureTypes()
public CultureInfo GetConsoleFallbackUICulture()
public string get_IetfLanguageTag()
public int get_KeyboardLayoutId()
public int get_LCID()
public string get_Name()
public string get_NativeName()
internal string get_NativeCalendarName()
public Calendar get_Calendar()
public Calendar[] get_OptionalCalendars()
public CultureInfo get_Parent()
public TextInfo get_TextInfo()
public string get_ThreeLetterISOLanguageName()
public string get_ThreeLetterWindowsLanguageName()
public string get_TwoLetterISOLanguageName()
public bool get_UseUserOverride()
public void ClearCachedData()
public object Clone()
public bool Equals(object value)
public CultureInfo[] GetCultures(CultureTypes types)
private Data GetTextInfoData()
public int GetHashCode()
public CultureInfo ReadOnly(CultureInfo ci)
public string ToString()
public CompareInfo get_CompareInfo()
public bool get_IsNeutralCulture()
private void CheckNeutral()
public NumberFormatInfo get_NumberFormat()
public void set_NumberFormat(NumberFormatInfo value)
public DateTimeFormatInfo get_DateTimeFormat()
public void set_DateTimeFormat(DateTimeFormatInfo value)
public string get_DisplayName()
public string get_EnglishName()
public CultureInfo get_InstalledUICulture()
public bool get_IsReadOnly()
public object GetFormat(Type formatType)
private void Construct()
private bool construct_internal_locale_from_lcid(int lcid)
private bool construct_internal_locale_from_name(string name)
private string get_current_locale_name()
private CultureInfo[] internal_get_cultures(bool neutral, bool specific, bool installed)
private void ConstructInvariant(bool read_only)
private TextInfo CreateTextInfo(bool readOnly)
public void .ctor(int culture)
public void .ctor(int culture, bool useUserOverride)
private void .ctor(int culture, bool useUserOverride, bool read_only)
public void .ctor(string name)
public void .ctor(string name, bool useUserOverride)
private void .ctor(string name, bool useUserOverride, bool read_only)
private void insert_into_shared_tables(CultureInfo c)
public CultureInfo GetCultureInfo(int culture)
public CultureInfo GetCultureInfo(string name)
public CultureInfo GetCultureInfo(string name, string altName)
public CultureInfo GetCultureInfoByIetfLanguageTag(string name)
internal CultureInfo CreateCulture(string name, bool reference)
public CultureInfo CreateSpecificCulture(string name)
private CultureInfo CreateSpecificCultureFromNeutral(string name)
internal int get_CalendarType()
private Calendar CreateCalendar(int calendarType)
private Exception CreateNotFoundException(string name)
public CultureInfo get_DefaultThreadCurrentCulture()
public void set_DefaultThreadCurrentCulture(CultureInfo value)
public CultureInfo get_DefaultThreadCurrentUICulture()
public void set_DefaultThreadCurrentUICulture(CultureInfo value)
internal string get_SortName()
internal CultureInfo get_UserDefaultUICulture()
internal CultureInfo get_UserDefaultCulture()
internal void CheckDomainSafetyObject(object obj, object container)
internal bool get_HasInvariantCultureName()
internal bool VerifyCultureName(string cultureName, bool throwException)
internal bool VerifyCultureName(CultureInfo culture, bool throwException)
}
public System.Globalization.CultureNotFoundException : ArgumentException {
private string m_invalidCultureName
private Nullable`1<int> m_invalidCultureId
public Nullable`1<int> InvalidCultureId
public string InvalidCultureName
private string DefaultMessage
private string FormatedInvalidCultureId
public string Message
public void .ctor(string message)
public void .ctor(string paramName, string message)
public void .ctor(string message, Exception innerException)
public void .ctor(string paramName, int invalidCultureId, string message)
public void .ctor(string message, int invalidCultureId, Exception innerException)
public void .ctor(string paramName, string invalidCultureName, string message)
public void .ctor(string message, string invalidCultureName, Exception innerException)
protected void .ctor(SerializationInfo info, StreamingContext context)
public void GetObjectData(SerializationInfo info, StreamingContext context)
public Nullable`1<int> get_InvalidCultureId()
public string get_InvalidCultureName()
private string get_DefaultMessage()
private string get_FormatedInvalidCultureId()
public string get_Message()
}
public System.Globalization.CultureTypes : Enum {
public int value__
public CultureTypes NeutralCultures
public CultureTypes SpecificCultures
public CultureTypes InstalledWin32Cultures
public CultureTypes AllCultures
public CultureTypes UserCustomCulture
public CultureTypes ReplacementCultures
public CultureTypes WindowsOnlyCultures
public CultureTypes FrameworkCultures
}
internal System.Globalization.DateTimeFormatFlags : Enum {
public int value__
public DateTimeFormatFlags None
public DateTimeFormatFlags UseGenitiveMonth
public DateTimeFormatFlags UseLeapYearMonth
public DateTimeFormatFlags UseSpacesInMonthNames
public DateTimeFormatFlags UseHebrewRule
public DateTimeFormatFlags UseSpacesInDayNames
public DateTimeFormatFlags UseDigitPrefixInTokens
public DateTimeFormatFlags NotInitialized
}
public System.Globalization.DateTimeFormatInfo : object {
private DateTimeFormatInfo modreq(System.Runtime.CompilerServices.IsVolatile) invariantInfo
private CultureData m_cultureData
internal string m_name
private string m_langName
private CompareInfo m_compareInfo
private CultureInfo m_cultureInfo
internal string amDesignator
internal string pmDesignator
internal string dateSeparator
internal string generalShortTimePattern
internal string generalLongTimePattern
internal string timeSeparator
internal string monthDayPattern
internal string dateTimeOffsetPattern
internal string rfc1123Pattern
internal string sortableDateTimePattern
internal string universalSortableDateTimePattern
internal Calendar calendar
internal int firstDayOfWeek
internal int calendarWeekRule
internal string fullDateTimePattern
internal String[] abbreviatedDayNames
internal String[] m_superShortDayNames
internal String[] dayNames
internal String[] abbreviatedMonthNames
internal String[] monthNames
internal String[] genitiveMonthNames
internal String[] m_genitiveAbbreviatedMonthNames
internal String[] leapYearMonthNames
internal string longDatePattern
internal string shortDatePattern
internal string yearMonthPattern
internal string longTimePattern
internal string shortTimePattern
private String[] allYearMonthPatterns
internal String[] allShortDatePatterns
internal String[] allLongDatePatterns
internal String[] allShortTimePatterns
internal String[] allLongTimePatterns
internal String[] m_eraNames
internal String[] m_abbrevEraNames
internal String[] m_abbrevEnglishEraNames
internal Int32[] optionalCalendars
private int DEFAULT_ALL_DATETIMES_SIZE
internal bool m_isReadOnly
internal DateTimeFormatFlags formatFlags
internal bool preferExistingTokens
private int CultureID
private bool m_useUserOverride
private bool bUseCalendarInfo
private int nDataItem
internal bool m_isDefaultCalendar
private Hashtable modreq(System.Runtime.CompilerServices.IsVolatile) s_calendarNativeNames
internal String[] m_dateWords
private string m_fullTimeSpanPositivePattern
private string m_fullTimeSpanNegativePattern
internal DateTimeStyles InvalidDateTimeStyles
private TokenHashValue[] m_dtfiTokenHash
private int TOKEN_HASH_SIZE
private int SECOND_PRIME
private string dateSeparatorOrTimeZoneOffset
private string invariantDateSeparator
private string invariantTimeSeparator
internal string IgnorablePeriod
internal string IgnorableComma
internal string CJKYearSuff
internal string CJKMonthSuff
internal string CJKDaySuff
internal string KoreanYearSuff
internal string KoreanMonthSuff
internal string KoreanDaySuff
internal string KoreanHourSuff
internal string KoreanMinuteSuff
internal string KoreanSecondSuff
internal string CJKHourSuff
internal string ChineseHourSuff
internal string CJKMinuteSuff
internal string CJKSecondSuff
internal string LocalTimeMark
internal string KoreanLangName
internal string JapaneseLangName
internal string EnglishLangName
private DateTimeFormatInfo modreq(System.Runtime.CompilerServices.IsVolatile) s_jajpDTFI
private DateTimeFormatInfo modreq(System.Runtime.CompilerServices.IsVolatile) s_zhtwDTFI
private string CultureName
private CultureInfo Culture
private string LanguageName
public DateTimeFormatInfo InvariantInfo
public DateTimeFormatInfo CurrentInfo
public string AMDesignator
public Calendar Calendar
private Int32[] OptionalCalendars
internal String[] EraNames
internal String[] AbbreviatedEraNames
internal String[] AbbreviatedEnglishEraNames
public string DateSeparator
public DayOfWeek FirstDayOfWeek
public CalendarWeekRule CalendarWeekRule
public string FullDateTimePattern
public string LongDatePattern
public string LongTimePattern
public string MonthDayPattern
public string PMDesignator
public string RFC1123Pattern
public string ShortDatePattern
public string ShortTimePattern
public string SortableDateTimePattern
internal string GeneralShortTimePattern
internal string GeneralLongTimePattern
internal string DateTimeOffsetPattern
public string TimeSeparator
public string UniversalSortableDateTimePattern
public string YearMonthPattern
public String[] AbbreviatedDayNames
public String[] ShortestDayNames
public String[] DayNames
public String[] AbbreviatedMonthNames
public String[] MonthNames
internal bool HasSpacesInMonthNames
internal bool HasSpacesInDayNames
private String[] AllYearMonthPatterns
private String[] AllShortDatePatterns
private String[] AllShortTimePatterns
private String[] AllLongDatePatterns
private String[] AllLongTimePatterns
private String[] UnclonedYearMonthPatterns
private String[] UnclonedShortDatePatterns
private String[] UnclonedLongDatePatterns
private String[] UnclonedShortTimePatterns
private String[] UnclonedLongTimePatterns
public bool IsReadOnly
public string NativeCalendarName
public String[] AbbreviatedMonthGenitiveNames
public String[] MonthGenitiveNames
internal string FullTimeSpanPositivePattern
internal string FullTimeSpanNegativePattern
internal CompareInfo CompareInfo
internal DateTimeFormatFlags FormatFlags
internal bool HasForceTwoDigitYears
internal bool HasYearMonthAdjustment
private bool InitPreferExistingTokens()
private string get_CultureName()
private CultureInfo get_Culture()
private string get_LanguageName()
private String[] internalGetAbbreviatedDayOfWeekNames()
private String[] internalGetSuperShortDayNames()
private String[] internalGetDayOfWeekNames()
private String[] internalGetAbbreviatedMonthNames()
private String[] internalGetMonthNames()
internal void .ctor(CultureData cultureData, Calendar cal)
private void InitializeOverridableProperties(CultureData cultureData, int calendarID)
private void OnDeserialized(StreamingContext ctx)
private void OnSerializing(StreamingContext ctx)
public DateTimeFormatInfo get_InvariantInfo()
public DateTimeFormatInfo get_CurrentInfo()
public DateTimeFormatInfo GetInstance(IFormatProvider provider)
public object GetFormat(Type formatType)
public object Clone()
public string get_AMDesignator()
public void set_AMDesignator(string value)
public Calendar get_Calendar()
public void set_Calendar(Calendar value)
private Int32[] get_OptionalCalendars()
public int GetEra(string eraName)
internal String[] get_EraNames()
public string GetEraName(int era)
internal String[] get_AbbreviatedEraNames()
public string GetAbbreviatedEraName(int era)
internal String[] get_AbbreviatedEnglishEraNames()
public string get_DateSeparator()
public void set_DateSeparator(string value)
public DayOfWeek get_FirstDayOfWeek()
public void set_FirstDayOfWeek(DayOfWeek value)
public CalendarWeekRule get_CalendarWeekRule()
public void set_CalendarWeekRule(CalendarWeekRule value)
public string get_FullDateTimePattern()
public void set_FullDateTimePattern(string value)
public string get_LongDatePattern()
public void set_LongDatePattern(string value)
public string get_LongTimePattern()
public void set_LongTimePattern(string value)
public string get_MonthDayPattern()
public void set_MonthDayPattern(string value)
public string get_PMDesignator()
public void set_PMDesignator(string value)
public string get_RFC1123Pattern()
public string get_ShortDatePattern()
public void set_ShortDatePattern(string value)
public string get_ShortTimePattern()
public void set_ShortTimePattern(string value)
public string get_SortableDateTimePattern()
internal string get_GeneralShortTimePattern()
internal string get_GeneralLongTimePattern()
internal string get_DateTimeOffsetPattern()
public string get_TimeSeparator()
public void set_TimeSeparator(string value)
public string get_UniversalSortableDateTimePattern()
public string get_YearMonthPattern()
public void set_YearMonthPattern(string value)
private void CheckNullValue(String[] values, int length)
public String[] get_AbbreviatedDayNames()
public void set_AbbreviatedDayNames(String[] value)
public String[] get_ShortestDayNames()
public void set_ShortestDayNames(String[] value)
public String[] get_DayNames()
public void set_DayNames(String[] value)
public String[] get_AbbreviatedMonthNames()
public void set_AbbreviatedMonthNames(String[] value)
public String[] get_MonthNames()
public void set_MonthNames(String[] value)
internal bool get_HasSpacesInMonthNames()
internal bool get_HasSpacesInDayNames()
internal string internalGetMonthName(int month, MonthNameStyles style, bool abbreviated)
private String[] internalGetGenitiveMonthNames(bool abbreviated)
internal String[] internalGetLeapYearMonthNames()
public string GetAbbreviatedDayName(DayOfWeek dayofweek)
public string GetShortestDayName(DayOfWeek dayOfWeek)
private String[] GetCombinedPatterns(String[] patterns1, String[] patterns2, string connectString)
public String[] GetAllDateTimePatterns()
public String[] GetAllDateTimePatterns(char format)
public string GetDayName(DayOfWeek dayofweek)
public string GetAbbreviatedMonthName(int month)
public string GetMonthName(int month)
private String[] GetMergedPatterns(String[] patterns, string defaultPattern)
private String[] get_AllYearMonthPatterns()
private String[] get_AllShortDatePatterns()
private String[] get_AllShortTimePatterns()
private String[] get_AllLongDatePatterns()
private String[] get_AllLongTimePatterns()
private String[] get_UnclonedYearMonthPatterns()
private String[] get_UnclonedShortDatePatterns()
private String[] get_UnclonedLongDatePatterns()
private String[] get_UnclonedShortTimePatterns()
private String[] get_UnclonedLongTimePatterns()
public DateTimeFormatInfo ReadOnly(DateTimeFormatInfo dtfi)
public bool get_IsReadOnly()
public string get_NativeCalendarName()
public void SetAllDateTimePatterns(String[] patterns, char format)
public String[] get_AbbreviatedMonthGenitiveNames()
public void set_AbbreviatedMonthGenitiveNames(String[] value)
public String[] get_MonthGenitiveNames()
public void set_MonthGenitiveNames(String[] value)
internal string get_FullTimeSpanPositivePattern()
internal string get_FullTimeSpanNegativePattern()
internal CompareInfo get_CompareInfo()
internal void ValidateStyles(DateTimeStyles style, string parameterName)
internal DateTimeFormatFlags get_FormatFlags()
internal bool get_HasForceTwoDigitYears()
internal bool get_HasYearMonthAdjustment()
internal bool YearMonthAdjustment(Int32& year, Int32& month, bool parsedMonthName)
internal DateTimeFormatInfo GetJapaneseCalendarDTFI()
internal DateTimeFormatInfo GetTaiwanCalendarDTFI()
private void ClearTokenHashTable()
internal TokenHashValue[] CreateTokenHashTable()
private void AddMonthNames(TokenHashValue[] temp, string monthPostfix)
private bool TryParseHebrewNumber(__DTString& str, Boolean& badFormat, Int32& number)
private bool IsHebrewChar(char ch)
internal bool Tokenize(TokenType TokenMask, TokenType& tokenType, Int32& tokenValue, __DTString& str)
private void InsertAtCurrentHashNode(TokenHashValue[] hashTable, string str, char ch, TokenType tokenType, int tokenValue, int pos, int hashcode, int hashProbe)
private void InsertHash(TokenHashValue[] hashTable, string str, TokenType tokenType, int tokenValue)
}
internal System.Globalization.DateTimeFormatInfoScanner : object {
internal char MonthPostfixChar
internal char IgnorableSymbolChar
internal string CJKYearSuff
internal string CJKMonthSuff
internal string CJKDaySuff
internal string KoreanYearSuff
internal string KoreanMonthSuff
internal string KoreanDaySuff
internal string KoreanHourSuff
internal string KoreanMinuteSuff
internal string KoreanSecondSuff
internal string CJKHourSuff
internal string ChineseHourSuff
internal string CJKMinuteSuff
internal string CJKSecondSuff
internal List`1<string> m_dateWords
private Dictionary`2 modreq(System.Runtime.CompilerServices.IsVolatile) s_knownWords
private FoundDatePattern m_ymdFlags
private Dictionary`2<string, string> KnownWords
private Dictionary`2<string, string> get_KnownWords()
internal int SkipWhiteSpacesAndNonLetter(string pattern, int currentIndex)
internal void AddDateWordOrPostfix(string formatPostfix, string str)
internal int AddDateWords(string pattern, int index, string formatPostfix)
internal int ScanRepeatChar(string pattern, char ch, int index, Int32& count)
internal void AddIgnorableSymbols(string text)
internal void ScanDateWord(string pattern)
internal String[] GetDateWordsOfDTFI(DateTimeFormatInfo dtfi)
internal FORMATFLAGS GetFormatFlagGenitiveMonth(String[] monthNames, String[] genitveMonthNames, String[] abbrevMonthNames, String[] genetiveAbbrevMonthNames)
internal FORMATFLAGS GetFormatFlagUseSpaceInMonthNames(String[] monthNames, String[] genitveMonthNames, String[] abbrevMonthNames, String[] genetiveAbbrevMonthNames)
internal FORMATFLAGS GetFormatFlagUseSpaceInDayNames(String[] dayNames, String[] abbrevDayNames)
internal FORMATFLAGS GetFormatFlagUseHebrewCalendar(int calID)
private bool EqualStringArrays(String[] array1, String[] array2)
private bool ArrayElementsHaveSpace(String[] array)
private bool ArrayElementsBeginWithDigit(String[] array)
}
public System.Globalization.DateTimeStyles : Enum {
public int value__
public DateTimeStyles None
public DateTimeStyles AllowLeadingWhite
public DateTimeStyles AllowTrailingWhite
public DateTimeStyles AllowInnerWhite
public DateTimeStyles AllowWhiteSpaces
public DateTimeStyles NoCurrentDateDefault
public DateTimeStyles AdjustToUniversal
public DateTimeStyles AssumeLocal
public DateTimeStyles AssumeUniversal
public DateTimeStyles RoundtripKind
}
public System.Globalization.DaylightTime : object {
internal DateTime m_start
internal DateTime m_end
internal TimeSpan m_delta
public DateTime Start
public DateTime End
public TimeSpan Delta
public void .ctor(DateTime start, DateTime end, TimeSpan delta)
public DateTime get_Start()
public DateTime get_End()
public TimeSpan get_Delta()
}
public System.Globalization.DigitShapes : Enum {
public int value__
public DigitShapes Context
public DigitShapes None
public DigitShapes NativeNational
}
public System.Globalization.EastAsianLunisolarCalendar : Calendar {
internal int LeapMonth
internal int Jan1Month
internal int Jan1Date
internal int nDaysPerMonth
internal Int32[] DaysToMonth365
internal Int32[] DaysToMonth366
internal int DatePartYear
internal int DatePartDayOfYear
internal int DatePartMonth
internal int DatePartDay
internal int MaxCalendarMonth
internal int MaxCalendarDay
private int DEFAULT_GREGORIAN_TWO_DIGIT_YEAR_MAX
public CalendarAlgorithmType AlgorithmType
internal int MinCalendarYear
internal int MaxCalendarYear
internal EraInfo[] CalEraInfo
internal DateTime MinDate
internal DateTime MaxDate
public int TwoDigitYearMax
public CalendarAlgorithmType get_AlgorithmType()
public int GetSexagenaryYear(DateTime time)
public int GetCelestialStem(int sexagenaryYear)
public int GetTerrestrialBranch(int sexagenaryYear)
internal int GetYearInfo(int LunarYear, int Index)
internal int GetYear(int year, DateTime time)
internal int GetGregorianYear(int year, int era)
internal int get_MinCalendarYear()
internal int get_MaxCalendarYear()
internal EraInfo[] get_CalEraInfo()
internal DateTime get_MinDate()
internal DateTime get_MaxDate()
internal int MinEraCalendarYear(int era)
internal int MaxEraCalendarYear(int era)
internal void CheckTicksRange(long ticks)
internal void CheckEraRange(int era)
internal int CheckYearRange(int year, int era)
internal int CheckYearMonthRange(int year, int month, int era)
internal int InternalGetDaysInMonth(int year, int month)
public int GetDaysInMonth(int year, int month, int era)
private int GregorianIsLeapYear(int y)
public DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era)
internal void GregorianToLunar(int nSYear, int nSMonth, int nSDate, Int32& nLYear, Int32& nLMonth, Int32& nLDate)
internal bool LunarToGregorian(int nLYear, int nLMonth, int nLDate, Int32& nSolarYear, Int32& nSolarMonth, Int32& nSolarDay)
internal DateTime LunarToTime(DateTime time, int year, int month, int day)
internal void TimeToLunar(DateTime time, Int32& year, Int32& month, Int32& day)
public DateTime AddMonths(DateTime time, int months)
public DateTime AddYears(DateTime time, int years)
public int GetDayOfYear(DateTime time)
public int GetDayOfMonth(DateTime time)
public int GetDaysInYear(int year, int era)
public int GetMonth(DateTime time)
public int GetYear(DateTime time)
public DayOfWeek GetDayOfWeek(DateTime time)
public int GetMonthsInYear(int year, int era)
public bool IsLeapDay(int year, int month, int day, int era)
public bool IsLeapMonth(int year, int month, int era)
public int GetLeapMonth(int year, int era)
internal bool InternalIsLeapYear(int year)
public bool IsLeapYear(int year, int era)
public int get_TwoDigitYearMax()
public void set_TwoDigitYearMax(int value)
public int ToFourDigitYear(int year)
}
internal System.Globalization.EncodingTable : object {
internal InternalEncodingDataItem[] encodingDataPtr
internal InternalCodePageDataItem[] codePageDataPtr
private int MIMECONTF_MAILNEWS
private int MIMECONTF_BROWSER
private int MIMECONTF_MINIMAL
private int MIMECONTF_IMPORT
private int MIMECONTF_SAVABLE_MAILNEWS
private int MIMECONTF_SAVABLE_BROWSER
private int MIMECONTF_EXPORT
private int MIMECONTF_PRIVCONVERTER
private int MIMECONTF_VALID
private int MIMECONTF_VALID_NLS
private int MIMECONTF_MIME_IE4
private int MIMECONTF_MIME_LATEST
private int MIMECONTF_MIME_REGISTRY
private int lastEncodingItem
private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) lastCodePageItem
private Hashtable hashByName
private Hashtable hashByCodePage
private int GetNumEncodingItems()
private InternalEncodingDataItem ENC(string name, ushort cp)
private InternalCodePageDataItem MapCodePageDataItem(ushort cp, ushort fcp, string names, UInt32 flags)
private int internalGetCodePageFromName(string name)
internal EncodingInfo[] GetEncodings()
internal int GetCodePageFromName(string name)
internal CodePageDataItem GetCodePageDataItem(int codepage)
}
internal System.Globalization.EraInfo : object {
internal int era
internal long ticks
internal int yearOffset
internal int minEraYear
internal int maxEraYear
internal string eraName
internal string abbrevEraName
internal string englishEraName
internal void .ctor(int era, int startYear, int startMonth, int startDay, int yearOffset, int minEraYear, int maxEraYear)
internal void .ctor(int era, int startYear, int startMonth, int startDay, int yearOffset, int minEraYear, int maxEraYear, string eraName, string abbrevEraName, string englishEraName)
}
internal System.Globalization.FORMATFLAGS : Enum {
public int value__
public FORMATFLAGS None
public FORMATFLAGS UseGenitiveMonth
public FORMATFLAGS UseLeapYearMonth
public FORMATFLAGS UseSpacesInMonthNames
public FORMATFLAGS UseHebrewParsing
public FORMATFLAGS UseSpacesInDayNames
public FORMATFLAGS UseDigitPrefixInTokens
}
internal System.Globalization.GlobalizationAssembly : object {
internal Byte* GetGlobalizationResourceBytePtr(Assembly assembly, string tableName)
}
public System.Globalization.GlobalizationExtensions : object {
public StringComparer GetStringComparer(CompareInfo compareInfo, CompareOptions options)
}
public System.Globalization.GregorianCalendar : Calendar {
public int ADEra
internal int DatePartYear
internal int DatePartDayOfYear
internal int DatePartMonth
internal int DatePartDay
internal int MaxYear
internal GregorianCalendarTypes m_type
internal Int32[] DaysToMonth365
internal Int32[] DaysToMonth366
private Calendar modreq(System.Runtime.CompilerServices.IsVolatile) s_defaultInstance
private int DEFAULT_TWO_DIGIT_YEAR_MAX
public DateTime MinSupportedDateTime
public DateTime MaxSupportedDateTime
public CalendarAlgorithmType AlgorithmType
public GregorianCalendarTypes CalendarType
internal int ID
public Int32[] Eras
public int TwoDigitYearMax
private void OnDeserialized(StreamingContext ctx)
public DateTime get_MinSupportedDateTime()
public DateTime get_MaxSupportedDateTime()
public CalendarAlgorithmType get_AlgorithmType()
internal Calendar GetDefaultInstance()
public void .ctor(GregorianCalendarTypes type)
public GregorianCalendarTypes get_CalendarType()
public void set_CalendarType(GregorianCalendarTypes value)
internal int get_ID()
internal int GetDatePart(long ticks, int part)
internal long GetAbsoluteDate(int year, int month, int day)
internal long DateToTicks(int year, int month, int day)
public DateTime AddMonths(DateTime time, int months)
public DateTime AddYears(DateTime time, int years)
public int GetDayOfMonth(DateTime time)
public DayOfWeek GetDayOfWeek(DateTime time)
public int GetDayOfYear(DateTime time)
public int GetDaysInMonth(int year, int month, int era)
public int GetDaysInYear(int year, int era)
public int GetEra(DateTime time)
public Int32[] get_Eras()
public int GetMonth(DateTime time)
public int GetMonthsInYear(int year, int era)
public int GetYear(DateTime time)
public bool IsLeapDay(int year, int month, int day, int era)
public int GetLeapMonth(int year, int era)
public bool IsLeapMonth(int year, int month, int era)
public bool IsLeapYear(int year, int era)
public DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era)
internal bool TryToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era, DateTime& result)
public int get_TwoDigitYearMax()
public void set_TwoDigitYearMax(int value)
public int ToFourDigitYear(int year)
}
internal System.Globalization.GregorianCalendarHelper : object {
internal long TicksPerMillisecond
internal long TicksPerSecond
internal long TicksPerMinute
internal long TicksPerHour
internal long TicksPerDay
internal int MillisPerSecond
internal int MillisPerMinute
internal int MillisPerHour
internal int MillisPerDay
internal int DaysPerYear
internal int DaysPer4Years
internal int DaysPer100Years
internal int DaysPer400Years
internal int DaysTo10000
internal long MaxMillis
internal int DatePartYear
internal int DatePartDayOfYear
internal int DatePartMonth
internal int DatePartDay
internal Int32[] DaysToMonth365
internal Int32[] DaysToMonth366
internal int m_maxYear
internal int m_minYear
internal Calendar m_Cal
internal EraInfo[] m_EraInfo
internal Int32[] m_eras
internal DateTime m_minDate
internal int MaxYear
public Int32[] Eras
internal int get_MaxYear()
internal void .ctor(Calendar cal, EraInfo[] eraInfo)
internal int GetGregorianYear(int year, int era)
internal bool IsValidYear(int year, int era)
internal int GetDatePart(long ticks, int part)
internal long GetAbsoluteDate(int year, int month, int day)
internal long DateToTicks(int year, int month, int day)
internal long TimeToTicks(int hour, int minute, int second, int millisecond)
internal void CheckTicksRange(long ticks)
public DateTime AddMonths(DateTime time, int months)
public DateTime AddYears(DateTime time, int years)
public int GetDayOfMonth(DateTime time)
public DayOfWeek GetDayOfWeek(DateTime time)
public int GetDayOfYear(DateTime time)
public int GetDaysInMonth(int year, int month, int era)
public int GetDaysInYear(int year, int era)
public int GetEra(DateTime time)
public Int32[] get_Eras()
public int GetMonth(DateTime time)
public int GetMonthsInYear(int year, int era)
public int GetYear(DateTime time)
public int GetYear(int year, DateTime time)
public bool IsLeapDay(int year, int month, int day, int era)
public int GetLeapMonth(int year, int era)
public bool IsLeapMonth(int year, int month, int era)
public bool IsLeapYear(int year, int era)
public DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era)
public int GetWeekOfYear(DateTime time, CalendarWeekRule rule, DayOfWeek firstDayOfWeek)
public int ToFourDigitYear(int year, int twoDigitYearMax)
}
public System.Globalization.GregorianCalendarTypes : Enum {
public int value__
public GregorianCalendarTypes Localized
public GregorianCalendarTypes USEnglish
public GregorianCalendarTypes MiddleEastFrench
public GregorianCalendarTypes Arabic
public GregorianCalendarTypes TransliteratedEnglish
public GregorianCalendarTypes TransliteratedFrench
}
public System.Globalization.HebrewCalendar : Calendar {
public int HebrewEra
internal int DatePartYear
internal int DatePartDayOfYear
internal int DatePartMonth
internal int DatePartDay
internal int DatePartDayOfWeek
private int HebrewYearOf1AD
private int FirstGregorianTableYear
private int LastGregorianTableYear
private int TABLESIZE
private int MinHebrewYear
private int MaxHebrewYear
private Int32[] HebrewTable
private Int32[0...,0...] LunarMonthLen
internal DateTime calendarMinValue
internal DateTime calendarMaxValue
private int DEFAULT_TWO_DIGIT_YEAR_MAX
public DateTime MinSupportedDateTime
public DateTime MaxSupportedDateTime
public CalendarAlgorithmType AlgorithmType
internal int ID
public Int32[] Eras
public int TwoDigitYearMax
public DateTime get_MinSupportedDateTime()
public DateTime get_MaxSupportedDateTime()
public CalendarAlgorithmType get_AlgorithmType()
internal int get_ID()
private void CheckHebrewYearValue(int y, int era, string varName)
private void CheckHebrewMonthValue(int year, int month, int era)
private void CheckHebrewDayValue(int year, int month, int day, int era)
internal void CheckEraRange(int era)
private void CheckTicksRange(long ticks)
internal int GetResult(__DateBuffer result, int part)
internal int GetLunarMonthDay(int gregorianYear, __DateBuffer lunarDate)
internal int GetDatePart(long ticks, int part)
public DateTime AddMonths(DateTime time, int months)
public DateTime AddYears(DateTime time, int years)
public int GetDayOfMonth(DateTime time)
public DayOfWeek GetDayOfWeek(DateTime time)
internal int GetHebrewYearType(int year, int era)
public int GetDayOfYear(DateTime time)
public int GetDaysInMonth(int year, int month, int era)
public int GetDaysInYear(int year, int era)
public int GetEra(DateTime time)
public Int32[] get_Eras()
public int GetMonth(DateTime time)
public int GetMonthsInYear(int year, int era)
public int GetYear(DateTime time)
public bool IsLeapDay(int year, int month, int day, int era)
public int GetLeapMonth(int year, int era)
public bool IsLeapMonth(int year, int month, int era)
public bool IsLeapYear(int year, int era)
private int GetDayDifference(int lunarYearType, int month1, int day1, int month2, int day2)
private DateTime HebrewToGregorian(int hebrewYear, int hebrewMonth, int hebrewDay, int hour, int minute, int second, int millisecond)
public DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era)
public int get_TwoDigitYearMax()
public void set_TwoDigitYearMax(int value)
public int ToFourDigitYear(int year)
}
internal System.Globalization.HebrewNumber : object {
private HebrewValue[] HebrewValues
private int minHebrewNumberCh
private char maxHebrewNumberCh
private HS[][] NumberPasingState
internal string ToString(int Number)
internal HebrewNumberParsingState ParseByChar(char ch, HebrewNumberParsingContext& context)
internal bool IsDigit(char ch)
}
internal System.Globalization.HebrewNumberParsingContext : ValueType {
internal HS state
internal int result
public void .ctor(int result)
}
internal System.Globalization.HebrewNumberParsingState : Enum {
public int value__
public HebrewNumberParsingState InvalidHebrewNumber
public HebrewNumberParsingState NotHebrewDigit
public HebrewNumberParsingState FoundEndOfHebrewNumber
public HebrewNumberParsingState ContinueParsing
}
public System.Globalization.HijriCalendar : Calendar {
public int HijriEra
internal int DatePartYear
internal int DatePartDayOfYear
internal int DatePartMonth
internal int DatePartDay
internal int MinAdvancedHijri
internal int MaxAdvancedHijri
internal Int32[] HijriMonthDays
private string HijriAdvanceRegKeyEntry
private int m_HijriAdvance
internal int MaxCalendarYear
internal int MaxCalendarMonth
internal int MaxCalendarDay
internal DateTime calendarMinValue
internal DateTime calendarMaxValue
private int DEFAULT_TWO_DIGIT_YEAR_MAX
public DateTime MinSupportedDateTime
public DateTime MaxSupportedDateTime
public CalendarAlgorithmType AlgorithmType
internal int ID
protected int DaysInYearBeforeMinSupportedYear
public int HijriAdjustment
public Int32[] Eras
public int TwoDigitYearMax
public DateTime get_MinSupportedDateTime()
public DateTime get_MaxSupportedDateTime()
public CalendarAlgorithmType get_AlgorithmType()
internal int get_ID()
protected int get_DaysInYearBeforeMinSupportedYear()
private long GetAbsoluteDateHijri(int y, int m, int d)
private long DaysUpToHijriYear(int HijriYear)
public int get_HijriAdjustment()
public void set_HijriAdjustment(int value)
private int GetAdvanceHijriDate()
internal void CheckTicksRange(long ticks)
internal void CheckEraRange(int era)
internal void CheckYearRange(int year, int era)
internal void CheckYearMonthRange(int year, int month, int era)
internal int GetDatePart(long ticks, int part)
public DateTime AddMonths(DateTime time, int months)
public DateTime AddYears(DateTime time, int years)
public int GetDayOfMonth(DateTime time)
public DayOfWeek GetDayOfWeek(DateTime time)
public int GetDayOfYear(DateTime time)
public int GetDaysInMonth(int year, int month, int era)
public int GetDaysInYear(int year, int era)
public int GetEra(DateTime time)
public Int32[] get_Eras()
public int GetMonth(DateTime time)
public int GetMonthsInYear(int year, int era)
public int GetYear(DateTime time)
public bool IsLeapDay(int year, int month, int day, int era)
public int GetLeapMonth(int year, int era)
public bool IsLeapMonth(int year, int month, int era)
public bool IsLeapYear(int year, int era)
public DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era)
public int get_TwoDigitYearMax()
public void set_TwoDigitYearMax(int value)
public int ToFourDigitYear(int year)
}
public System.Globalization.IdnMapping : object {
private bool allow_unassigned
private bool use_std3
private Punycode puny
public bool AllowUnassigned
public bool UseStd3AsciiRules
public bool get_AllowUnassigned()
public void set_AllowUnassigned(bool value)
public bool get_UseStd3AsciiRules()
public void set_UseStd3AsciiRules(bool value)
public bool Equals(object obj)
public int GetHashCode()
public string GetAscii(string unicode)
public string GetAscii(string unicode, int index)
public string GetAscii(string unicode, int index, int count)
private string Convert(string input, int index, int count, bool toAscii)
private string ToAscii(string s, int offset)
private void VerifyLength(string s, int offset)
private string NamePrep(string s, int offset)
private void VerifyProhibitedCharacters(string s, int offset)
private void VerifyStd3AsciiRules(string s, int offset)
public string GetUnicode(string ascii)
public string GetUnicode(string ascii, int index)
public string GetUnicode(string ascii, int index, int count)
private string ToUnicode(string s, int offset)
}
internal System.Globalization.InternalCodePageDataItem : ValueType {
internal ushort codePage
internal ushort uiFamilyCodePage
internal UInt32 flags
internal string Names
}
internal System.Globalization.InternalEncodingDataItem : ValueType {
internal string webName
internal ushort codePage
}
public System.Globalization.JapaneseCalendar : Calendar {
internal DateTime calendarMinValue
internal EraInfo[] modreq(System.Runtime.CompilerServices.IsVolatile) japaneseEraInfo
private string c_japaneseErasHive
private string c_japaneseErasHivePermissionList
internal Calendar modreq(System.Runtime.CompilerServices.IsVolatile) s_defaultInstance
internal GregorianCalendarHelper helper
private int DEFAULT_TWO_DIGIT_YEAR_MAX
public DateTime MinSupportedDateTime
public DateTime MaxSupportedDateTime
public CalendarAlgorithmType AlgorithmType
internal int ID
public Int32[] Eras
public int TwoDigitYearMax
public DateTime get_MinSupportedDateTime()
public DateTime get_MaxSupportedDateTime()
public CalendarAlgorithmType get_AlgorithmType()
internal EraInfo[] GetEraInfo()
private EraInfo[] GetErasFromRegistry()
private int CompareEraRanges(EraInfo a, EraInfo b)
private EraInfo GetEraFromValue(string value, string data)
internal Calendar GetDefaultInstance()
internal int get_ID()
public DateTime AddMonths(DateTime time, int months)
public DateTime AddYears(DateTime time, int years)
public int GetDaysInMonth(int year, int month, int era)
public int GetDaysInYear(int year, int era)
public int GetDayOfMonth(DateTime time)
public DayOfWeek GetDayOfWeek(DateTime time)
public int GetDayOfYear(DateTime time)
public int GetMonthsInYear(int year, int era)
public int GetWeekOfYear(DateTime time, CalendarWeekRule rule, DayOfWeek firstDayOfWeek)
public int GetEra(DateTime time)
public int GetMonth(DateTime time)
public int GetYear(DateTime time)
public bool IsLeapDay(int year, int month, int day, int era)
public bool IsLeapYear(int year, int era)
public int GetLeapMonth(int year, int era)
public bool IsLeapMonth(int year, int month, int era)
public DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era)
public int ToFourDigitYear(int year)
public Int32[] get_Eras()
internal String[] EraNames()
internal String[] AbbrevEraNames()
internal String[] EnglishEraNames()
internal bool IsValidYear(int year, int era)
public int get_TwoDigitYearMax()
public void set_TwoDigitYearMax(int value)
}
public System.Globalization.JapaneseLunisolarCalendar : EastAsianLunisolarCalendar {
public int JapaneseEra
internal GregorianCalendarHelper helper
internal int MIN_LUNISOLAR_YEAR
internal int MAX_LUNISOLAR_YEAR
internal int MIN_GREGORIAN_YEAR
internal int MIN_GREGORIAN_MONTH
internal int MIN_GREGORIAN_DAY
internal int MAX_GREGORIAN_YEAR
internal int MAX_GREGORIAN_MONTH
internal int MAX_GREGORIAN_DAY
internal DateTime minDate
internal DateTime maxDate
private Int32[0...,0...] yinfo
public DateTime MinSupportedDateTime
public DateTime MaxSupportedDateTime
protected int DaysInYearBeforeMinSupportedYear
internal int MinCalendarYear
internal int MaxCalendarYear
internal DateTime MinDate
internal DateTime MaxDate
internal EraInfo[] CalEraInfo
internal int BaseCalendarID
internal int ID
public Int32[] Eras
public DateTime get_MinSupportedDateTime()
public DateTime get_MaxSupportedDateTime()
protected int get_DaysInYearBeforeMinSupportedYear()
internal int get_MinCalendarYear()
internal int get_MaxCalendarYear()
internal DateTime get_MinDate()
internal DateTime get_MaxDate()
internal EraInfo[] get_CalEraInfo()
internal int GetYearInfo(int LunarYear, int Index)
internal int GetYear(int year, DateTime time)
internal int GetGregorianYear(int year, int era)
private EraInfo[] TrimEras(EraInfo[] baseEras)
public int GetEra(DateTime time)
internal int get_BaseCalendarID()
internal int get_ID()
public Int32[] get_Eras()
}
public System.Globalization.JulianCalendar : Calendar {
public int JulianEra
private int DatePartYear
private int DatePartDayOfYear
private int DatePartMonth
private int DatePartDay
private int JulianDaysPerYear
private int JulianDaysPer4Years
private Int32[] DaysToMonth365
private Int32[] DaysToMonth366
internal int MaxYear
public DateTime MinSupportedDateTime
public DateTime MaxSupportedDateTime
public CalendarAlgorithmType AlgorithmType
internal int ID
public Int32[] Eras
public int TwoDigitYearMax
public DateTime get_MinSupportedDateTime()
public DateTime get_MaxSupportedDateTime()
public CalendarAlgorithmType get_AlgorithmType()
internal int get_ID()
internal void CheckEraRange(int era)
internal void CheckYearEraRange(int year, int era)
internal void CheckMonthRange(int month)
internal void CheckDayRange(int year, int month, int day)
internal int GetDatePart(long ticks, int part)
internal long DateToTicks(int year, int month, int day)
public DateTime AddMonths(DateTime time, int months)
public DateTime AddYears(DateTime time, int years)
public int GetDayOfMonth(DateTime time)
public DayOfWeek GetDayOfWeek(DateTime time)
public int GetDayOfYear(DateTime time)
public int GetDaysInMonth(int year, int month, int era)
public int GetDaysInYear(int year, int era)
public int GetEra(DateTime time)
public int GetMonth(DateTime time)
public Int32[] get_Eras()
public int GetMonthsInYear(int year, int era)
public int GetYear(DateTime time)
public bool IsLeapDay(int year, int month, int day, int era)
public int GetLeapMonth(int year, int era)
public bool IsLeapMonth(int year, int month, int era)
public bool IsLeapYear(int year, int era)
public DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era)
public int get_TwoDigitYearMax()
public void set_TwoDigitYearMax(int value)
public int ToFourDigitYear(int year)
}
public System.Globalization.KoreanCalendar : Calendar {
public int KoreanEra
internal EraInfo[] koreanEraInfo
internal GregorianCalendarHelper helper
private int DEFAULT_TWO_DIGIT_YEAR_MAX
public DateTime MinSupportedDateTime
public DateTime MaxSupportedDateTime
public CalendarAlgorithmType AlgorithmType
internal int ID
public Int32[] Eras
public int TwoDigitYearMax
public DateTime get_MinSupportedDateTime()
public DateTime get_MaxSupportedDateTime()
public CalendarAlgorithmType get_AlgorithmType()
internal int get_ID()
public DateTime AddMonths(DateTime time, int months)
public DateTime AddYears(DateTime time, int years)
public int GetDaysInMonth(int year, int month, int era)
public int GetDaysInYear(int year, int era)
public int GetDayOfMonth(DateTime time)
public DayOfWeek GetDayOfWeek(DateTime time)
public int GetDayOfYear(DateTime time)
public int GetMonthsInYear(int year, int era)
public int GetWeekOfYear(DateTime time, CalendarWeekRule rule, DayOfWeek firstDayOfWeek)
public int GetEra(DateTime time)
public int GetMonth(DateTime time)
public int GetYear(DateTime time)
public bool IsLeapDay(int year, int month, int day, int era)
public bool IsLeapYear(int year, int era)
public int GetLeapMonth(int year, int era)
public bool IsLeapMonth(int year, int month, int era)
public DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era)
public Int32[] get_Eras()
public int get_TwoDigitYearMax()
public void set_TwoDigitYearMax(int value)
public int ToFourDigitYear(int year)
}
public System.Globalization.KoreanLunisolarCalendar : EastAsianLunisolarCalendar {
public int GregorianEra
internal int MIN_LUNISOLAR_YEAR
internal int MAX_LUNISOLAR_YEAR
internal int MIN_GREGORIAN_YEAR
internal int MIN_GREGORIAN_MONTH
internal int MIN_GREGORIAN_DAY
internal int MAX_GREGORIAN_YEAR
internal int MAX_GREGORIAN_MONTH
internal int MAX_GREGORIAN_DAY
internal DateTime minDate
internal DateTime maxDate
private Int32[0...,0...] yinfo
public DateTime MinSupportedDateTime
public DateTime MaxSupportedDateTime
protected int DaysInYearBeforeMinSupportedYear
internal int MinCalendarYear
internal int MaxCalendarYear
internal DateTime MinDate
internal DateTime MaxDate
internal EraInfo[] CalEraInfo
internal int BaseCalendarID
internal int ID
public Int32[] Eras
public DateTime get_MinSupportedDateTime()
public DateTime get_MaxSupportedDateTime()
protected int get_DaysInYearBeforeMinSupportedYear()
internal int get_MinCalendarYear()
internal int get_MaxCalendarYear()
internal DateTime get_MinDate()
internal DateTime get_MaxDate()
internal EraInfo[] get_CalEraInfo()
internal int GetYearInfo(int LunarYear, int Index)
internal int GetYear(int year, DateTime time)
internal int GetGregorianYear(int year, int era)
public int GetEra(DateTime time)
internal int get_BaseCalendarID()
internal int get_ID()
public Int32[] get_Eras()
}
internal System.Globalization.MonthNameStyles : Enum {
public int value__
public MonthNameStyles Regular
public MonthNameStyles Genitive
public MonthNameStyles LeapYear
}
public System.Globalization.NumberFormatInfo : object {
private NumberFormatInfo modreq(System.Runtime.CompilerServices.IsVolatile) invariantInfo
internal Int32[] numberGroupSizes
internal Int32[] currencyGroupSizes
internal Int32[] percentGroupSizes
internal string positiveSign
internal string negativeSign
internal string numberDecimalSeparator
internal string numberGroupSeparator
internal string currencyGroupSeparator
internal string currencyDecimalSeparator
internal string currencySymbol
internal string ansiCurrencySymbol
internal string nanSymbol
internal string positiveInfinitySymbol
internal string negativeInfinitySymbol
internal string percentDecimalSeparator
internal string percentGroupSeparator
internal string percentSymbol
internal string perMilleSymbol
internal String[] nativeDigits
internal int m_dataItem
internal int numberDecimalDigits
internal int currencyDecimalDigits
internal int currencyPositivePattern
internal int currencyNegativePattern
internal int numberNegativePattern
internal int percentPositivePattern
internal int percentNegativePattern
internal int percentDecimalDigits
internal int digitSubstitution
internal bool isReadOnly
internal bool m_useUserOverride
internal bool m_isInvariant
internal bool validForParseAsNumber
internal bool validForParseAsCurrency
private NumberStyles InvalidNumberStyles
public NumberFormatInfo InvariantInfo
public int CurrencyDecimalDigits
public string CurrencyDecimalSeparator
public bool IsReadOnly
public Int32[] CurrencyGroupSizes
public Int32[] NumberGroupSizes
public Int32[] PercentGroupSizes
public string CurrencyGroupSeparator
public string CurrencySymbol
public NumberFormatInfo CurrentInfo
public string NaNSymbol
public int CurrencyNegativePattern
public int NumberNegativePattern
public int PercentPositivePattern
public int PercentNegativePattern
public string NegativeInfinitySymbol
public string NegativeSign
public int NumberDecimalDigits
public string NumberDecimalSeparator
public string NumberGroupSeparator
public int CurrencyPositivePattern
public string PositiveInfinitySymbol
public string PositiveSign
public int PercentDecimalDigits
public string PercentDecimalSeparator
public string PercentGroupSeparator
public string PercentSymbol
public string PerMilleSymbol
public String[] NativeDigits
public DigitShapes DigitSubstitution
private void OnSerializing(StreamingContext ctx)
private void OnDeserializing(StreamingContext ctx)
private void OnDeserialized(StreamingContext ctx)
private void VerifyDecimalSeparator(string decSep, string propertyName)
private void VerifyGroupSeparator(string groupSep, string propertyName)
private void VerifyNativeDigits(String[] nativeDig, string propertyName)
private void VerifyDigitSubstitution(DigitShapes digitSub, string propertyName)
internal void .ctor(CultureData cultureData)
private void VerifyWritable()
public NumberFormatInfo get_InvariantInfo()
public NumberFormatInfo GetInstance(IFormatProvider formatProvider)
public object Clone()
public int get_CurrencyDecimalDigits()
public void set_CurrencyDecimalDigits(int value)
public string get_CurrencyDecimalSeparator()
public void set_CurrencyDecimalSeparator(string value)
public bool get_IsReadOnly()
internal void CheckGroupSize(string propName, Int32[] groupSize)
public Int32[] get_CurrencyGroupSizes()
public void set_CurrencyGroupSizes(Int32[] value)
public Int32[] get_NumberGroupSizes()
public void set_NumberGroupSizes(Int32[] value)
public Int32[] get_PercentGroupSizes()
public void set_PercentGroupSizes(Int32[] value)
public string get_CurrencyGroupSeparator()
public void set_CurrencyGroupSeparator(string value)
public string get_CurrencySymbol()
public void set_CurrencySymbol(string value)
public NumberFormatInfo get_CurrentInfo()
public string get_NaNSymbol()
public void set_NaNSymbol(string value)
public int get_CurrencyNegativePattern()
public void set_CurrencyNegativePattern(int value)
public int get_NumberNegativePattern()
public void set_NumberNegativePattern(int value)
public int get_PercentPositivePattern()
public void set_PercentPositivePattern(int value)
public int get_PercentNegativePattern()
public void set_PercentNegativePattern(int value)
public string get_NegativeInfinitySymbol()
public void set_NegativeInfinitySymbol(string value)
public string get_NegativeSign()
public void set_NegativeSign(string value)
public int get_NumberDecimalDigits()
public void set_NumberDecimalDigits(int value)
public string get_NumberDecimalSeparator()
public void set_NumberDecimalSeparator(string value)
public string get_NumberGroupSeparator()
public void set_NumberGroupSeparator(string value)
public int get_CurrencyPositivePattern()
public void set_CurrencyPositivePattern(int value)
public string get_PositiveInfinitySymbol()
public void set_PositiveInfinitySymbol(string value)
public string get_PositiveSign()
public void set_PositiveSign(string value)
public int get_PercentDecimalDigits()
public void set_PercentDecimalDigits(int value)
public string get_PercentDecimalSeparator()
public void set_PercentDecimalSeparator(string value)
public string get_PercentGroupSeparator()
public void set_PercentGroupSeparator(string value)
public string get_PercentSymbol()
public void set_PercentSymbol(string value)
public string get_PerMilleSymbol()
public void set_PerMilleSymbol(string value)
public String[] get_NativeDigits()
public void set_NativeDigits(String[] value)
public DigitShapes get_DigitSubstitution()
public void set_DigitSubstitution(DigitShapes value)
public object GetFormat(Type formatType)
public NumberFormatInfo ReadOnly(NumberFormatInfo nfi)
internal void ValidateParseStyleInteger(NumberStyles style)
internal void ValidateParseStyleFloatingPoint(NumberStyles style)
}
public System.Globalization.NumberStyles : Enum {
public int value__
public NumberStyles None
public NumberStyles AllowLeadingWhite
public NumberStyles AllowTrailingWhite
public NumberStyles AllowLeadingSign
public NumberStyles AllowTrailingSign
public NumberStyles AllowParentheses
public NumberStyles AllowDecimalPoint
public NumberStyles AllowThousands
public NumberStyles AllowExponent
public NumberStyles AllowCurrencySymbol
public NumberStyles AllowHexSpecifier
public NumberStyles Integer
public NumberStyles HexNumber
public NumberStyles Number
public NumberStyles Float
public NumberStyles Currency
public NumberStyles Any
}
public System.Globalization.PersianCalendar : Calendar {
public int PersianEra
internal long PersianEpoch
private int ApproximateHalfYear
internal int DatePartYear
internal int DatePartDayOfYear
internal int DatePartMonth
internal int DatePartDay
internal int MonthsPerYear
internal Int32[] DaysToMonth
internal int MaxCalendarYear
internal int MaxCalendarMonth
internal int MaxCalendarDay
internal DateTime minDate
internal DateTime maxDate
private int DEFAULT_TWO_DIGIT_YEAR_MAX
public DateTime MinSupportedDateTime
public DateTime MaxSupportedDateTime
public CalendarAlgorithmType AlgorithmType
internal int BaseCalendarID
internal int ID
public Int32[] Eras
public int TwoDigitYearMax
public DateTime get_MinSupportedDateTime()
public DateTime get_MaxSupportedDateTime()
public CalendarAlgorithmType get_AlgorithmType()
internal int get_BaseCalendarID()
internal int get_ID()
private long GetAbsoluteDatePersian(int year, int month, int day)
internal void CheckTicksRange(long ticks)
internal void CheckEraRange(int era)
internal void CheckYearRange(int year, int era)
internal void CheckYearMonthRange(int year, int month, int era)
private int MonthFromOrdinalDay(int ordinalDay)
private int DaysInPreviousMonths(int month)
internal int GetDatePart(long ticks, int part)
public DateTime AddMonths(DateTime time, int months)
public DateTime AddYears(DateTime time, int years)
public int GetDayOfMonth(DateTime time)
public DayOfWeek GetDayOfWeek(DateTime time)
public int GetDayOfYear(DateTime time)
public int GetDaysInMonth(int year, int month, int era)
public int GetDaysInYear(int year, int era)
public int GetEra(DateTime time)
public Int32[] get_Eras()
public int GetMonth(DateTime time)
public int GetMonthsInYear(int year, int era)
public int GetYear(DateTime time)
public bool IsLeapDay(int year, int month, int day, int era)
public int GetLeapMonth(int year, int era)
public bool IsLeapMonth(int year, int month, int era)
public bool IsLeapYear(int year, int era)
public DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era)
public int get_TwoDigitYearMax()
public void set_TwoDigitYearMax(int value)
public int ToFourDigitYear(int year)
}
public System.Globalization.RegionInfo : object {
private RegionInfo currentRegion
private int regionId
private string iso2Name
private string iso3Name
private string win3Name
private string englishName
private string nativeName
private string currencySymbol
private string isoCurrencySymbol
private string currencyEnglishName
private string currencyNativeName
public RegionInfo CurrentRegion
public string CurrencyEnglishName
public string CurrencySymbol
public string DisplayName
public string EnglishName
public int GeoId
public bool IsMetric
public string ISOCurrencySymbol
public string NativeName
public string CurrencyNativeName
public string Name
public string ThreeLetterISORegionName
public string ThreeLetterWindowsRegionName
public string TwoLetterISORegionName
public RegionInfo get_CurrentRegion()
public void .ctor(int culture)
public void .ctor(string name)
private void .ctor(CultureInfo ci)
private bool GetByTerritory(CultureInfo ci)
private bool construct_internal_region_from_name(string name)
public string get_CurrencyEnglishName()
public string get_CurrencySymbol()
public string get_DisplayName()
public string get_EnglishName()
public int get_GeoId()
public bool get_IsMetric()
public string get_ISOCurrencySymbol()
public string get_NativeName()
public string get_CurrencyNativeName()
public string get_Name()
public string get_ThreeLetterISORegionName()
public string get_ThreeLetterWindowsRegionName()
public string get_TwoLetterISORegionName()
public bool Equals(object value)
public int GetHashCode()
public string ToString()
internal void ClearCachedData()
}
public System.Globalization.SortKey : object {
private string source
private Byte[] key
private CompareOptions options
private int lcid
public string OriginalString
public Byte[] KeyData
public int Compare(SortKey sortkey1, SortKey sortkey2)
internal void .ctor(int lcid, string source, CompareOptions opt)
internal void .ctor(int lcid, string source, Byte[] buffer, CompareOptions opt, int lv1Length, int lv2Length, int lv3Length, int kanaSmallLength, int markTypeLength, int katakanaLength, int kanaWidthLength, int identLength)
public string get_OriginalString()
public Byte[] get_KeyData()
public bool Equals(object value)
public int GetHashCode()
public string ToString()
}
public System.Globalization.SortVersion : object {
private int m_NlsVersion
private Guid m_SortId
public int FullVersion
public Guid SortId
public int get_FullVersion()
public Guid get_SortId()
public void .ctor(int fullVersion, Guid sortId)
internal void .ctor(int nlsVersion, int effectiveId, Guid customVersion)
public bool Equals(object obj)
public bool Equals(SortVersion other)
public int GetHashCode()
public bool op_Equality(SortVersion left, SortVersion right)
public bool op_Inequality(SortVersion left, SortVersion right)
}
public System.Globalization.StringInfo : object {
private string m_str
private Int32[] m_indexes
private Int32[] Indexes
public string String
public int LengthInTextElements
public void .ctor(string value)
private void OnDeserializing(StreamingContext ctx)
private void OnDeserialized(StreamingContext ctx)
public bool Equals(object value)
public int GetHashCode()
private Int32[] get_Indexes()
public string get_String()
public void set_String(string value)
public int get_LengthInTextElements()
public string SubstringByTextElements(int startingTextElement)
public string SubstringByTextElements(int startingTextElement, int lengthInTextElements)
public string GetNextTextElement(string str)
internal int GetCurrentTextElementLen(string str, int index, int len, UnicodeCategory& ucCurrent, Int32& currentCharCount)
public string GetNextTextElement(string str, int index)
public TextElementEnumerator GetTextElementEnumerator(string str)
public TextElementEnumerator GetTextElementEnumerator(string str, int index)
public Int32[] ParseCombiningCharacters(string str)
}
public System.Globalization.TaiwanCalendar : Calendar {
internal EraInfo[] taiwanEraInfo
internal Calendar modreq(System.Runtime.CompilerServices.IsVolatile) s_defaultInstance
internal GregorianCalendarHelper helper
internal DateTime calendarMinValue
private int DEFAULT_TWO_DIGIT_YEAR_MAX
public DateTime MinSupportedDateTime
public DateTime MaxSupportedDateTime
public CalendarAlgorithmType AlgorithmType
internal int ID
public Int32[] Eras
public int TwoDigitYearMax
internal Calendar GetDefaultInstance()
public DateTime get_MinSupportedDateTime()
public DateTime get_MaxSupportedDateTime()
public CalendarAlgorithmType get_AlgorithmType()
internal int get_ID()
public DateTime AddMonths(DateTime time, int months)
public DateTime AddYears(DateTime time, int years)
public int GetDaysInMonth(int year, int month, int era)
public int GetDaysInYear(int year, int era)
public int GetDayOfMonth(DateTime time)
public DayOfWeek GetDayOfWeek(DateTime time)
public int GetDayOfYear(DateTime time)
public int GetMonthsInYear(int year, int era)
public int GetWeekOfYear(DateTime time, CalendarWeekRule rule, DayOfWeek firstDayOfWeek)
public int GetEra(DateTime time)
public int GetMonth(DateTime time)
public int GetYear(DateTime time)
public bool IsLeapDay(int year, int month, int day, int era)
public bool IsLeapYear(int year, int era)
public int GetLeapMonth(int year, int era)
public bool IsLeapMonth(int year, int month, int era)
public DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era)
public Int32[] get_Eras()
public int get_TwoDigitYearMax()
public void set_TwoDigitYearMax(int value)
public int ToFourDigitYear(int year)
}
public System.Globalization.TaiwanLunisolarCalendar : EastAsianLunisolarCalendar {
internal EraInfo[] taiwanLunisolarEraInfo
internal GregorianCalendarHelper helper
internal int MIN_LUNISOLAR_YEAR
internal int MAX_LUNISOLAR_YEAR
internal int MIN_GREGORIAN_YEAR
internal int MIN_GREGORIAN_MONTH
internal int MIN_GREGORIAN_DAY
internal int MAX_GREGORIAN_YEAR
internal int MAX_GREGORIAN_MONTH
internal int MAX_GREGORIAN_DAY
internal DateTime minDate
internal DateTime maxDate
private Int32[0...,0...] yinfo
public DateTime MinSupportedDateTime
public DateTime MaxSupportedDateTime
protected int DaysInYearBeforeMinSupportedYear
internal int MinCalendarYear
internal int MaxCalendarYear
internal DateTime MinDate
internal DateTime MaxDate
internal EraInfo[] CalEraInfo
internal int BaseCalendarID
internal int ID
public Int32[] Eras
public DateTime get_MinSupportedDateTime()
public DateTime get_MaxSupportedDateTime()
protected int get_DaysInYearBeforeMinSupportedYear()
internal int get_MinCalendarYear()
internal int get_MaxCalendarYear()
internal DateTime get_MinDate()
internal DateTime get_MaxDate()
internal EraInfo[] get_CalEraInfo()
internal int GetYearInfo(int LunarYear, int Index)
internal int GetYear(int year, DateTime time)
internal int GetGregorianYear(int year, int era)
public int GetEra(DateTime time)
internal int get_BaseCalendarID()
internal int get_ID()
public Int32[] get_Eras()
}
public System.Globalization.TextElementEnumerator : object {
private string str
private int index
private int startIndex
private int strLen
private int currTextElementLen
private UnicodeCategory uc
private int charLen
private int endIndex
private int nextTextElementLen
public object Current
public int ElementIndex
internal void .ctor(string str, int startIndex, int strLen)
private void OnDeserializing(StreamingContext ctx)
private void OnDeserialized(StreamingContext ctx)
private void OnSerializing(StreamingContext ctx)
public bool MoveNext()
public object get_Current()
public string GetTextElement()
public int get_ElementIndex()
public void Reset()
}
public System.Globalization.TextInfo : object {
private string m_listSeparator
private bool m_isReadOnly
private string m_cultureName
private CultureData m_cultureData
private string m_textInfoName
private Nullable`1<bool> m_IsAsciiCasingSameAsInvariant
internal TextInfo modreq(System.Runtime.CompilerServices.IsVolatile) s_Invariant
private string customCultureName
internal int m_nDataItem
internal bool m_useUserOverride
internal int m_win32LangID
private int wordSeparatorMask
internal TextInfo Invariant
public int ANSICodePage
public int OEMCodePage
public int MacCodePage
public int EBCDICCodePage
public int LCID
public string CultureName
public bool IsReadOnly
public string ListSeparator
private bool IsAsciiCasingSameAsInvariant
public bool IsRightToLeft
internal TextInfo get_Invariant()
internal void .ctor(CultureData cultureData)
private void OnDeserializing(StreamingContext ctx)
private void OnDeserialized()
private void OnDeserialized(StreamingContext ctx)
private void OnSerializing(StreamingContext ctx)
internal int GetHashCodeOrdinalIgnoreCase(string s)
internal int GetHashCodeOrdinalIgnoreCase(string s, bool forceRandomizedHashing, long additionalEntropy)
internal int CompareOrdinalIgnoreCase(string str1, string str2)
internal int CompareOrdinalIgnoreCaseEx(string strA, int indexA, string strB, int indexB, int lengthA, int lengthB)
internal int IndexOfStringOrdinalIgnoreCase(string source, string value, int startIndex, int count)
internal int LastIndexOfStringOrdinalIgnoreCase(string source, string value, int startIndex, int count)
public int get_ANSICodePage()
public int get_OEMCodePage()
public int get_MacCodePage()
public int get_EBCDICCodePage()
public int get_LCID()
public string get_CultureName()
public bool get_IsReadOnly()
public object Clone()
public TextInfo ReadOnly(TextInfo textInfo)
private void VerifyWritable()
internal void SetReadOnlyState(bool readOnly)
public string get_ListSeparator()
public void set_ListSeparator(string value)
public char ToLower(char c)
public string ToLower(string str)
private char ToLowerAsciiInvariant(char c)
public char ToUpper(char c)
public string ToUpper(string str)
private char ToUpperAsciiInvariant(char c)
private bool IsAscii(char c)
private bool get_IsAsciiCasingSameAsInvariant()
public bool Equals(object obj)
public int GetHashCode()
public string ToString()
public string ToTitleCase(string str)
private int AddNonLetter(StringBuilder& result, String& input, int inputIndex, int charLen)
private int AddTitlecaseLetter(StringBuilder& result, String& input, int inputIndex, int charLen)
private bool IsWordSeparator(UnicodeCategory category)
private bool IsLetterCategory(UnicodeCategory uc)
public bool get_IsRightToLeft()
private void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender)
internal int GetCaseInsensitiveHashCode(string str)
internal int GetCaseInsensitiveHashCode(string str, bool forceRandomizedHashing, long additionalEntropy)
private int GetInvariantCaseInsensitiveHashCode(string str)
private string ToUpperInternal(string str)
private string ToLowerInternal(string str)
private char ToUpperInternal(char c)
private char ToLowerInternal(char c)
private int InternalCompareStringOrdinalIgnoreCase(string strA, int indexA, string strB, int indexB, int lenA, int lenB)
}
internal System.Globalization.TextInfoToLowerData : object {
public Char[] range_00c0_0556
public Char[] range_10a0_10c5
public Char[] range_1e00_1ffc
public Char[] range_2160_216f
public Char[] range_24b6_24cf
public Char[] range_2c00_2c2e
public Char[] range_2c60_2ce2
public Char[] range_a640_a696
public Char[] range_a722_a78b
}
internal System.Globalization.TextInfoToUpperData : object {
public Char[] range_00e0_0586
public Char[] range_1e01_1ff3
public Char[] range_2170_2184
public Char[] range_24d0_24e9
public Char[] range_2c30_2ce3
public Char[] range_2d00_2d25
public Char[] range_a641_a697
public Char[] range_a723_a78c
}
public System.Globalization.ThaiBuddhistCalendar : Calendar {
internal EraInfo[] thaiBuddhistEraInfo
public int ThaiBuddhistEra
internal GregorianCalendarHelper helper
private int DEFAULT_TWO_DIGIT_YEAR_MAX
public DateTime MinSupportedDateTime
public DateTime MaxSupportedDateTime
public CalendarAlgorithmType AlgorithmType
internal int ID
public Int32[] Eras
public int TwoDigitYearMax
public DateTime get_MinSupportedDateTime()
public DateTime get_MaxSupportedDateTime()
public CalendarAlgorithmType get_AlgorithmType()
internal int get_ID()
public DateTime AddMonths(DateTime time, int months)
public DateTime AddYears(DateTime time, int years)
public int GetDaysInMonth(int year, int month, int era)
public int GetDaysInYear(int year, int era)
public int GetDayOfMonth(DateTime time)
public DayOfWeek GetDayOfWeek(DateTime time)
public int GetDayOfYear(DateTime time)
public int GetMonthsInYear(int year, int era)
public int GetWeekOfYear(DateTime time, CalendarWeekRule rule, DayOfWeek firstDayOfWeek)
public int GetEra(DateTime time)
public int GetMonth(DateTime time)
public int GetYear(DateTime time)
public bool IsLeapDay(int year, int month, int day, int era)
public bool IsLeapYear(int year, int era)
public int GetLeapMonth(int year, int era)
public bool IsLeapMonth(int year, int month, int era)
public DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era)
public Int32[] get_Eras()
public int get_TwoDigitYearMax()
public void set_TwoDigitYearMax(int value)
public int ToFourDigitYear(int year)
}
internal System.Globalization.TimeSpanFormat : object {
internal FormatLiterals PositiveInvariantFormatLiterals
internal FormatLiterals NegativeInvariantFormatLiterals
private string IntToString(int n, int digits)
internal string Format(TimeSpan value, string format, IFormatProvider formatProvider)
private string FormatStandard(TimeSpan value, bool isInvariant, string format, Pattern pattern)
internal string FormatCustomized(TimeSpan value, string format, DateTimeFormatInfo dtfi)
}
internal System.Globalization.TimeSpanParse : object {
internal int unlimitedDigits
internal int maxFractionDigits
internal int maxDays
internal int maxHours
internal int maxMinutes
internal int maxSeconds
internal int maxFraction
private TimeSpanToken zero
internal void ValidateStyles(TimeSpanStyles style, string parameterName)
private bool TryTimeToTicks(bool positive, TimeSpanToken days, TimeSpanToken hours, TimeSpanToken minutes, TimeSpanToken seconds, TimeSpanToken fraction, Int64& result)
internal TimeSpan Parse(string input, IFormatProvider formatProvider)
internal bool TryParse(string input, IFormatProvider formatProvider, TimeSpan& result)
internal TimeSpan ParseExact(string input, string format, IFormatProvider formatProvider, TimeSpanStyles styles)
internal bool TryParseExact(string input, string format, IFormatProvider formatProvider, TimeSpanStyles styles, TimeSpan& result)
internal TimeSpan ParseExactMultiple(string input, String[] formats, IFormatProvider formatProvider, TimeSpanStyles styles)
internal bool TryParseExactMultiple(string input, String[] formats, IFormatProvider formatProvider, TimeSpanStyles styles, TimeSpan& result)
private bool TryParseTimeSpan(string input, TimeSpanStandardStyles style, IFormatProvider formatProvider, TimeSpanResult& result)
private bool ProcessTerminalState(TimeSpanRawInfo& raw, TimeSpanStandardStyles style, TimeSpanResult& result)
private bool ProcessTerminal_DHMSF(TimeSpanRawInfo& raw, TimeSpanStandardStyles style, TimeSpanResult& result)
private bool ProcessTerminal_HMS_F_D(TimeSpanRawInfo& raw, TimeSpanStandardStyles style, TimeSpanResult& result)
private bool ProcessTerminal_HM_S_D(TimeSpanRawInfo& raw, TimeSpanStandardStyles style, TimeSpanResult& result)
private bool ProcessTerminal_HM(TimeSpanRawInfo& raw, TimeSpanStandardStyles style, TimeSpanResult& result)
private bool ProcessTerminal_D(TimeSpanRawInfo& raw, TimeSpanStandardStyles style, TimeSpanResult& result)
private bool TryParseExactTimeSpan(string input, string format, IFormatProvider formatProvider, TimeSpanStyles styles, TimeSpanResult& result)
private bool TryParseByFormat(string input, string format, TimeSpanStyles styles, TimeSpanResult& result)
private bool ParseExactDigits(TimeSpanTokenizer& tokenizer, int minDigitLength, Int32& result)
private bool ParseExactDigits(TimeSpanTokenizer& tokenizer, int minDigitLength, int maxDigitLength, Int32& zeroes, Int32& result)
private bool ParseExactLiteral(TimeSpanTokenizer& tokenizer, StringBuilder enquotedString)
private bool TryParseTimeSpanConstant(string input, TimeSpanResult& result)
private bool TryParseExactMultipleTimeSpan(string input, String[] formats, IFormatProvider formatProvider, TimeSpanStyles styles, TimeSpanResult& result)
}
public System.Globalization.TimeSpanStyles : Enum {
public int value__
public TimeSpanStyles None
public TimeSpanStyles AssumeNegative
}
internal System.Globalization.TokenHashValue : object {
internal string tokenString
internal TokenType tokenType
internal int tokenValue
internal void .ctor(string tokenString, TokenType tokenType, int tokenValue)
}
public System.Globalization.UmAlQuraCalendar : Calendar {
internal int MinCalendarYear
internal int MaxCalendarYear
private DateMapping[] HijriYearInfo
public int UmAlQuraEra
internal int DateCycle
internal int DatePartYear
internal int DatePartDayOfYear
internal int DatePartMonth
internal int DatePartDay
internal DateTime minDate
internal DateTime maxDate
private int DEFAULT_TWO_DIGIT_YEAR_MAX
public DateTime MinSupportedDateTime
public DateTime MaxSupportedDateTime
public CalendarAlgorithmType AlgorithmType
internal int BaseCalendarID
internal int ID
protected int DaysInYearBeforeMinSupportedYear
public Int32[] Eras
public int TwoDigitYearMax
private DateMapping[] InitDateMapping()
public DateTime get_MinSupportedDateTime()
public DateTime get_MaxSupportedDateTime()
public CalendarAlgorithmType get_AlgorithmType()
internal int get_BaseCalendarID()
internal int get_ID()
protected int get_DaysInYearBeforeMinSupportedYear()
private void ConvertHijriToGregorian(int HijriYear, int HijriMonth, int HijriDay, Int32& yg, Int32& mg, Int32& dg)
private long GetAbsoluteDateUmAlQura(int year, int month, int day)
internal void CheckTicksRange(long ticks)
internal void CheckEraRange(int era)
internal void CheckYearRange(int year, int era)
internal void CheckYearMonthRange(int year, int month, int era)
private void ConvertGregorianToHijri(DateTime time, Int32& HijriYear, Int32& HijriMonth, Int32& HijriDay)
internal int GetDatePart(DateTime time, int part)
public DateTime AddMonths(DateTime time, int months)
public DateTime AddYears(DateTime time, int years)
public int GetDayOfMonth(DateTime time)
public DayOfWeek GetDayOfWeek(DateTime time)
public int GetDayOfYear(DateTime time)
public int GetDaysInMonth(int year, int month, int era)
internal int RealGetDaysInYear(int year)
public int GetDaysInYear(int year, int era)
public int GetEra(DateTime time)
public Int32[] get_Eras()
public int GetMonth(DateTime time)
public int GetMonthsInYear(int year, int era)
public int GetYear(DateTime time)
public bool IsLeapDay(int year, int month, int day, int era)
public int GetLeapMonth(int year, int era)
public bool IsLeapMonth(int year, int month, int era)
public bool IsLeapYear(int year, int era)
public DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era)
public int get_TwoDigitYearMax()
public void set_TwoDigitYearMax(int value)
public int ToFourDigitYear(int year)
}
public System.Globalization.UnicodeCategory : Enum {
public int value__
public UnicodeCategory UppercaseLetter
public UnicodeCategory LowercaseLetter
public UnicodeCategory TitlecaseLetter
public UnicodeCategory ModifierLetter
public UnicodeCategory OtherLetter
public UnicodeCategory NonSpacingMark
public UnicodeCategory SpacingCombiningMark
public UnicodeCategory EnclosingMark
public UnicodeCategory DecimalDigitNumber
public UnicodeCategory LetterNumber
public UnicodeCategory OtherNumber
public UnicodeCategory SpaceSeparator
public UnicodeCategory LineSeparator
public UnicodeCategory ParagraphSeparator
public UnicodeCategory Control
public UnicodeCategory Format
public UnicodeCategory Surrogate
public UnicodeCategory PrivateUse
public UnicodeCategory ConnectorPunctuation
public UnicodeCategory DashPunctuation
public UnicodeCategory OpenPunctuation
public UnicodeCategory ClosePunctuation
public UnicodeCategory InitialQuotePunctuation
public UnicodeCategory FinalQuotePunctuation
public UnicodeCategory OtherPunctuation
public UnicodeCategory MathSymbol
public UnicodeCategory CurrencySymbol
public UnicodeCategory ModifierSymbol
public UnicodeCategory OtherSymbol
public UnicodeCategory OtherNotAssigned
}
public System.Guid : ValueType {
public Guid Empty
private int _a
private short _b
private short _c
private byte _d
private byte _e
private byte _f
private byte _g
private byte _h
private byte _i
private byte _j
private byte _k
private object _rngAccess
private RandomNumberGenerator _rng
private RandomNumberGenerator _fastRng
public void .ctor(Byte[] b)
public void .ctor(UInt32 a, ushort b, ushort c, byte d, byte e, byte f, byte g, byte h, byte i, byte j, byte k)
public void .ctor(int a, short b, short c, Byte[] d)
public void .ctor(int a, short b, short c, byte d, byte e, byte f, byte g, byte h, byte i, byte j, byte k)
public void .ctor(string g)
public Guid Parse(string input)
public bool TryParse(string input, Guid& result)
public Guid ParseExact(string input, string format)
public bool TryParseExact(string input, string format, Guid& result)
private bool TryParseGuid(string g, GuidStyles flags, GuidResult& result)
private bool TryParseGuidWithHexPrefix(string guidString, GuidResult& result)
private bool TryParseGuidWithNoStyle(string guidString, GuidResult& result)
private bool TryParseGuidWithDashes(string guidString, GuidResult& result)
private bool StringToShort(string str, int requiredLength, int flags, Int16& result, GuidResult& parseResult)
private bool StringToShort(string str, Int32& parsePos, int requiredLength, int flags, Int16& result, GuidResult& parseResult)
private bool StringToShort(string str, Int32* parsePos, int requiredLength, int flags, Int16& result, GuidResult& parseResult)
private bool StringToInt(string str, int requiredLength, int flags, Int32& result, GuidResult& parseResult)
private bool StringToInt(string str, Int32& parsePos, int requiredLength, int flags, Int32& result, GuidResult& parseResult)
private bool StringToInt(string str, Int32* parsePos, int requiredLength, int flags, Int32& result, GuidResult& parseResult)
private bool StringToLong(string str, int flags, Int64& result, GuidResult& parseResult)
private bool StringToLong(string str, Int32& parsePos, int flags, Int64& result, GuidResult& parseResult)
private bool StringToLong(string str, Int32* parsePos, int flags, Int64& result, GuidResult& parseResult)
private string EatAllWhitespace(string str)
private bool IsHexPrefix(string str, int i)
public Byte[] ToByteArray()
public string ToString()
public int GetHashCode()
public bool Equals(object o)
public bool Equals(Guid g)
private int GetResult(UInt32 me, UInt32 them)
public int CompareTo(object value)
public int CompareTo(Guid value)
public bool op_Equality(Guid a, Guid b)
public bool op_Inequality(Guid a, Guid b)
public string ToString(string format)
private char HexToChar(int a)
private int HexsToChars(Char* guidChars, int offset, int a, int b)
private int HexsToChars(Char* guidChars, int offset, int a, int b, bool hex)
public string ToString(string format, IFormatProvider provider)
public Guid NewGuid()
internal Byte[] FastNewGuidArray()
}
internal System.Handles : Enum {
public int value__
public Handles STD_INPUT
public Handles STD_OUTPUT
public Handles STD_ERROR
}
public System.IAppDomainSetup {
public string ApplicationBase
public string ApplicationName
public string CachePath
public string ConfigurationFile
public string DynamicBase
public string LicenseFile
public string PrivateBinPath
public string PrivateBinPathProbe
public string ShadowCopyDirectories
public string ShadowCopyFiles
public string get_ApplicationBase()
public void set_ApplicationBase(string value)
public string get_ApplicationName()
public void set_ApplicationName(string value)
public string get_CachePath()
public void set_CachePath(string value)
public string get_ConfigurationFile()
public void set_ConfigurationFile(string value)
public string get_DynamicBase()
public void set_DynamicBase(string value)
public string get_LicenseFile()
public void set_LicenseFile(string value)
public string get_PrivateBinPath()
public void set_PrivateBinPath(string value)
public string get_PrivateBinPathProbe()
public void set_PrivateBinPathProbe(string value)
public string get_ShadowCopyDirectories()
public void set_ShadowCopyDirectories(string value)
public string get_ShadowCopyFiles()
public void set_ShadowCopyFiles(string value)
}
public System.IAsyncResult {
public bool IsCompleted
public WaitHandle AsyncWaitHandle
public object AsyncState
public bool CompletedSynchronously
public bool get_IsCompleted()
public WaitHandle get_AsyncWaitHandle()
public object get_AsyncState()
public bool get_CompletedSynchronously()
}
public System.ICloneable {
public object Clone()
}
public System.IComparable {
public int CompareTo(object obj)
}
public System.IComparable`1 {
public int CompareTo(T other)
}
internal System.IConsoleDriver {
public ConsoleColor BackgroundColor
public int BufferHeight
public int BufferWidth
public bool CapsLock
public int CursorLeft
public int CursorSize
public int CursorTop
public bool CursorVisible
public ConsoleColor ForegroundColor
public bool KeyAvailable
public bool Initialized
public int LargestWindowHeight
public int LargestWindowWidth
public bool NumberLock
public string Title
public bool TreatControlCAsInput
public int WindowHeight
public int WindowLeft
public int WindowTop
public int WindowWidth
public ConsoleColor get_BackgroundColor()
public void set_BackgroundColor(ConsoleColor value)
public int get_BufferHeight()
public void set_BufferHeight(int value)
public int get_BufferWidth()
public void set_BufferWidth(int value)
public bool get_CapsLock()
public int get_CursorLeft()
public void set_CursorLeft(int value)
public int get_CursorSize()
public void set_CursorSize(int value)
public int get_CursorTop()
public void set_CursorTop(int value)
public bool get_CursorVisible()
public void set_CursorVisible(bool value)
public ConsoleColor get_ForegroundColor()
public void set_ForegroundColor(ConsoleColor value)
public bool get_KeyAvailable()
public bool get_Initialized()
public int get_LargestWindowHeight()
public int get_LargestWindowWidth()
public bool get_NumberLock()
public string get_Title()
public void set_Title(string value)
public bool get_TreatControlCAsInput()
public void set_TreatControlCAsInput(bool value)
public int get_WindowHeight()
public void set_WindowHeight(int value)
public int get_WindowLeft()
public void set_WindowLeft(int value)
public int get_WindowTop()
public void set_WindowTop(int value)
public int get_WindowWidth()
public void set_WindowWidth(int value)
public void Init()
public void Beep(int frequency, int duration)
public void Clear()
public void MoveBufferArea(int sourceLeft, int sourceTop, int sourceWidth, int sourceHeight, int targetLeft, int targetTop, char sourceChar, ConsoleColor sourceForeColor, ConsoleColor sourceBackColor)
public ConsoleKeyInfo ReadKey(bool intercept)
public void ResetColor()
public void SetBufferSize(int width, int height)
public void SetCursorPosition(int left, int top)
public void SetWindowPosition(int left, int top)
public void SetWindowSize(int width, int height)
public string ReadLine()
}
public System.IConvertible {
public TypeCode GetTypeCode()
public bool ToBoolean(IFormatProvider provider)
public char ToChar(IFormatProvider provider)
public sbyte ToSByte(IFormatProvider provider)
public byte ToByte(IFormatProvider provider)
public short ToInt16(IFormatProvider provider)
public ushort ToUInt16(IFormatProvider provider)
public int ToInt32(IFormatProvider provider)
public UInt32 ToUInt32(IFormatProvider provider)
public long ToInt64(IFormatProvider provider)
public ulong ToUInt64(IFormatProvider provider)
public float ToSingle(IFormatProvider provider)
public double ToDouble(IFormatProvider provider)
public decimal ToDecimal(IFormatProvider provider)
public DateTime ToDateTime(IFormatProvider provider)
public string ToString(IFormatProvider provider)
public object ToType(Type conversionType, IFormatProvider provider)
}
public System.ICustomFormatter {
public string Format(string format, object arg, IFormatProvider formatProvider)
}
public System.IDisposable {
public void Dispose()
}
public System.IEquatable`1 {
public bool Equals(T other)
}
public System.IFormatProvider {
public object GetFormat(Type formatType)
}
public System.IFormattable {
public string ToString(string format, IFormatProvider formatProvider)
}
public System.IndexOutOfRangeException : SystemException {
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
internal void .ctor(SerializationInfo info, StreamingContext context)
}
internal System.InputRecord : ValueType {
public short EventType
public bool KeyDown
public short RepeatCount
public short VirtualKeyCode
public short VirtualScanCode
public char Character
public int ControlKeyState
private int pad1
private bool pad2
}
public System.InsufficientExecutionStackException : SystemException {
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
private void .ctor(SerializationInfo info, StreamingContext context)
}
public System.InsufficientMemoryException : OutOfMemoryException {
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
private void .ctor(SerializationInfo info, StreamingContext context)
}
public System.Int16 : ValueType {
internal short m_value
public short MaxValue
public short MinValue
public int CompareTo(object value)
public int CompareTo(short value)
public bool Equals(object obj)
public bool Equals(short obj)
public int GetHashCode()
public string ToString()
public string ToString(IFormatProvider provider)
public string ToString(string format)
public string ToString(string format, IFormatProvider provider)
private string ToString(string format, NumberFormatInfo info)
public short Parse(string s)
public short Parse(string s, NumberStyles style)
public short Parse(string s, IFormatProvider provider)
public short Parse(string s, NumberStyles style, IFormatProvider provider)
private short Parse(string s, NumberStyles style, NumberFormatInfo info)
public bool TryParse(string s, Int16& result)
public bool TryParse(string s, NumberStyles style, IFormatProvider provider, Int16& result)
private bool TryParse(string s, NumberStyles style, NumberFormatInfo info, Int16& result)
public TypeCode GetTypeCode()
private bool System.IConvertible.ToBoolean(IFormatProvider provider)
private char System.IConvertible.ToChar(IFormatProvider provider)
private sbyte System.IConvertible.ToSByte(IFormatProvider provider)
private byte System.IConvertible.ToByte(IFormatProvider provider)
private short System.IConvertible.ToInt16(IFormatProvider provider)
private ushort System.IConvertible.ToUInt16(IFormatProvider provider)
private int System.IConvertible.ToInt32(IFormatProvider provider)
private UInt32 System.IConvertible.ToUInt32(IFormatProvider provider)
private long System.IConvertible.ToInt64(IFormatProvider provider)
private ulong System.IConvertible.ToUInt64(IFormatProvider provider)
private float System.IConvertible.ToSingle(IFormatProvider provider)
private double System.IConvertible.ToDouble(IFormatProvider provider)
private decimal System.IConvertible.ToDecimal(IFormatProvider provider)
private DateTime System.IConvertible.ToDateTime(IFormatProvider provider)
private object System.IConvertible.ToType(Type type, IFormatProvider provider)
}
public System.Int32 : ValueType {
internal int m_value
public int MaxValue
public int MinValue
public int CompareTo(object value)
public int CompareTo(int value)
public bool Equals(object obj)
public bool Equals(int obj)
public int GetHashCode()
public string ToString()
public string ToString(string format)
public string ToString(IFormatProvider provider)
public string ToString(string format, IFormatProvider provider)
public int Parse(string s)
public int Parse(string s, NumberStyles style)
public int Parse(string s, IFormatProvider provider)
public int Parse(string s, NumberStyles style, IFormatProvider provider)
public bool TryParse(string s, Int32& result)
public bool TryParse(string s, NumberStyles style, IFormatProvider provider, Int32& result)
public TypeCode GetTypeCode()
private bool System.IConvertible.ToBoolean(IFormatProvider provider)
private char System.IConvertible.ToChar(IFormatProvider provider)
private sbyte System.IConvertible.ToSByte(IFormatProvider provider)
private byte System.IConvertible.ToByte(IFormatProvider provider)
private short System.IConvertible.ToInt16(IFormatProvider provider)
private ushort System.IConvertible.ToUInt16(IFormatProvider provider)
private int System.IConvertible.ToInt32(IFormatProvider provider)
private UInt32 System.IConvertible.ToUInt32(IFormatProvider provider)
private long System.IConvertible.ToInt64(IFormatProvider provider)
private ulong System.IConvertible.ToUInt64(IFormatProvider provider)
private float System.IConvertible.ToSingle(IFormatProvider provider)
private double System.IConvertible.ToDouble(IFormatProvider provider)
private decimal System.IConvertible.ToDecimal(IFormatProvider provider)
private DateTime System.IConvertible.ToDateTime(IFormatProvider provider)
private object System.IConvertible.ToType(Type type, IFormatProvider provider)
}
public System.Int64 : ValueType {
internal long m_value
public long MaxValue
public long MinValue
public int CompareTo(object value)
public int CompareTo(long value)
public bool Equals(object obj)
public bool Equals(long obj)
public int GetHashCode()
public string ToString()
public string ToString(IFormatProvider provider)
public string ToString(string format)
public string ToString(string format, IFormatProvider provider)
public long Parse(string s)
public long Parse(string s, NumberStyles style)
public long Parse(string s, IFormatProvider provider)
public long Parse(string s, NumberStyles style, IFormatProvider provider)
public bool TryParse(string s, Int64& result)
public bool TryParse(string s, NumberStyles style, IFormatProvider provider, Int64& result)
public TypeCode GetTypeCode()
private bool System.IConvertible.ToBoolean(IFormatProvider provider)
private char System.IConvertible.ToChar(IFormatProvider provider)
private sbyte System.IConvertible.ToSByte(IFormatProvider provider)
private byte System.IConvertible.ToByte(IFormatProvider provider)
private short System.IConvertible.ToInt16(IFormatProvider provider)
private ushort System.IConvertible.ToUInt16(IFormatProvider provider)
private int System.IConvertible.ToInt32(IFormatProvider provider)
private UInt32 System.IConvertible.ToUInt32(IFormatProvider provider)
private long System.IConvertible.ToInt64(IFormatProvider provider)
private ulong System.IConvertible.ToUInt64(IFormatProvider provider)
private float System.IConvertible.ToSingle(IFormatProvider provider)
private double System.IConvertible.ToDouble(IFormatProvider provider)
private decimal System.IConvertible.ToDecimal(IFormatProvider provider)
private DateTime System.IConvertible.ToDateTime(IFormatProvider provider)
private object System.IConvertible.ToType(Type type, IFormatProvider provider)
}
internal System.InternalGCCollectionMode : Enum {
public int value__
public InternalGCCollectionMode NonBlocking
public InternalGCCollectionMode Blocking
public InternalGCCollectionMode Optimized
public InternalGCCollectionMode Compacting
}
public System.IntPtr : ValueType {
private Void* m_value
public IntPtr Zero
public int Size
public void .ctor(int value)
public void .ctor(long value)
public void .ctor(Void* value)
private void .ctor(SerializationInfo info, StreamingContext context)
public int get_Size()
private void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context)
public bool Equals(object obj)
public int GetHashCode()
public int ToInt32()
public long ToInt64()
public Void* ToPointer()
public string ToString()
public string ToString(string format)
public bool op_Equality(IntPtr value1, IntPtr value2)
public bool op_Inequality(IntPtr value1, IntPtr value2)
public IntPtr op_Explicit(int value)
public IntPtr op_Explicit(long value)
public IntPtr op_Explicit(Void* value)
public int op_Explicit(IntPtr value)
public long op_Explicit(IntPtr value)
public Void* op_Explicit(IntPtr value)
public IntPtr Add(IntPtr pointer, int offset)
public IntPtr Subtract(IntPtr pointer, int offset)
public IntPtr op_Addition(IntPtr pointer, int offset)
public IntPtr op_Subtraction(IntPtr pointer, int offset)
internal bool IsNull()
}
public System.InvalidCastException : SystemException {
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
protected void .ctor(SerializationInfo info, StreamingContext context)
public void .ctor(string message, int errorCode)
}
public System.InvalidOperationException : SystemException {
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
protected void .ctor(SerializationInfo info, StreamingContext context)
}
public System.InvalidProgramException : SystemException {
public void .ctor(string message)
public void .ctor(string message, Exception inner)
internal void .ctor(SerializationInfo info, StreamingContext context)
}
public System.InvalidTimeZoneException : Exception {
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
protected void .ctor(SerializationInfo info, StreamingContext context)
}
internal System.IO.__Error : object {
internal void EndOfFile()
internal void FileNotOpen()
internal void StreamIsClosed()
internal void MemoryStreamNotExpandable()
internal void ReaderClosed()
internal void ReadNotSupported()
internal void SeekNotSupported()
internal void WrongAsyncResult()
internal void EndReadCalledTwice()
internal void EndWriteCalledTwice()
internal string GetDisplayablePath(string path, bool isInvalidPath)
internal void WinIOError(int errorCode, string maybeFullPath)
internal void WriteNotSupported()
internal void WriterClosed()
}
internal System.IO.__HResults : object {
public int COR_E_ENDOFSTREAM
public int COR_E_FILELOAD
public int COR_E_FILENOTFOUND
public int COR_E_DIRECTORYNOTFOUND
public int COR_E_PATHTOOLONG
public int COR_E_IO
}
public System.IO.BinaryReader : object {
private int MaxCharBytesSize
private Stream m_stream
private Byte[] m_buffer
private Decoder m_decoder
private Byte[] m_charBytes
private Char[] m_singleChar
private Char[] m_charBuffer
private int m_maxCharsSize
private bool m_2BytesPerChar
private bool m_isMemoryStream
private bool m_leaveOpen
public Stream BaseStream
public void .ctor(Stream input)
public void .ctor(Stream input, Encoding encoding)
public void .ctor(Stream input, Encoding encoding, bool leaveOpen)
public Stream get_BaseStream()
public void Close()
protected void Dispose(bool disposing)
public void Dispose()
public int PeekChar()
public int Read()
public bool ReadBoolean()
public byte ReadByte()
public sbyte ReadSByte()
public char ReadChar()
public short ReadInt16()
public ushort ReadUInt16()
public int ReadInt32()
public UInt32 ReadUInt32()
public long ReadInt64()
public ulong ReadUInt64()
public float ReadSingle()
public double ReadDouble()
public decimal ReadDecimal()
public string ReadString()
public int Read(Char[] buffer, int index, int count)
private int InternalReadChars(Char[] buffer, int index, int count)
private int InternalReadOneChar()
public Char[] ReadChars(int count)
public int Read(Byte[] buffer, int index, int count)
public Byte[] ReadBytes(int count)
protected void FillBuffer(int numBytes)
protected internal int Read7BitEncodedInt()
}
public System.IO.BinaryWriter : object {
public BinaryWriter Null
protected Stream OutStream
private Byte[] _buffer
private Encoding _encoding
private Encoder _encoder
private bool _leaveOpen
private Char[] _tmpOneCharBuffer
private Byte[] _largeByteBuffer
private int _maxChars
private int LargeByteBufferSize
public Stream BaseStream
public void .ctor(Stream output)
public void .ctor(Stream output, Encoding encoding)
public void .ctor(Stream output, Encoding encoding, bool leaveOpen)
public void Close()
protected void Dispose(bool disposing)
public void Dispose()
public Stream get_BaseStream()
public void Flush()
public long Seek(int offset, SeekOrigin origin)
public void Write(bool value)
public void Write(byte value)
public void Write(sbyte value)
public void Write(Byte[] buffer)
public void Write(Byte[] buffer, int index, int count)
public void Write(char ch)
public void Write(Char[] chars)
public void Write(Char[] chars, int index, int count)
public void Write(double value)
public void Write(decimal value)
public void Write(short value)
public void Write(ushort value)
public void Write(int value)
public void Write(UInt32 value)
public void Write(long value)
public void Write(ulong value)
public void Write(float value)
public void Write(string value)
protected void Write7BitEncodedInt(int value)
}
public System.IO.BufferedStream : Stream {
private int _DefaultBufferSize
private Stream _stream
private Byte[] _buffer
private int _bufferSize
private int _readPos
private int _readLen
private int _writePos
private BeginEndAwaitableAdapter _beginEndAwaitable
private Task`1<int> _lastSyncCompletedReadTask
private int MaxShadowBufferSize
internal Stream UnderlyingStream
internal int BufferSize
public bool CanRead
public bool CanWrite
public bool CanSeek
public long Length
public long Position
public void .ctor(Stream stream)
public void .ctor(Stream stream, int bufferSize)
private void EnsureNotClosed()
private void EnsureCanSeek()
private void EnsureCanRead()
private void EnsureCanWrite()
private void EnsureBeginEndAwaitableAllocated()
private void EnsureShadowBufferAllocated()
private void EnsureBufferAllocated()
internal Stream get_UnderlyingStream()
internal int get_BufferSize()
public bool get_CanRead()
public bool get_CanWrite()
public bool get_CanSeek()
public long get_Length()
public long get_Position()
public void set_Position(long value)
protected void Dispose(bool disposing)
public void Flush()
public Task FlushAsync(CancellationToken cancellationToken)
private Task FlushAsyncInternal(CancellationToken cancellationToken, BufferedStream _this, Stream stream, int writePos, int readPos, int readLen)
private void FlushRead()
private void ClearReadBufferBeforeWrite()
private void FlushWrite()
private Task FlushWriteAsync(CancellationToken cancellationToken)
private int ReadFromBuffer(Byte[] array, int offset, int count)
private int ReadFromBuffer(Byte[] array, int offset, int count, Exception& error)
public int Read(Byte[] array, int offset, int count)
public IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state)
private IAsyncResult BeginReadFromUnderlyingStream(Byte[] buffer, int offset, int count, AsyncCallback callback, object state, int bytesAlreadySatisfied, Task semaphoreLockTask)
public int EndRead(IAsyncResult asyncResult)
private Task`1<int> LastSyncCompletedReadTask(int val)
public Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken)
private Task`1<int> ReadFromUnderlyingStreamAsync(Byte[] array, int offset, int count, CancellationToken cancellationToken, int bytesAlreadySatisfied, Task semaphoreLockTask, bool useApmPattern)
public int ReadByte()
private void WriteToBuffer(Byte[] array, Int32& offset, Int32& count)
private void WriteToBuffer(Byte[] array, Int32& offset, Int32& count, Exception& error)
public void Write(Byte[] array, int offset, int count)
public IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state)
private IAsyncResult BeginWriteToUnderlyingStream(Byte[] buffer, int offset, int count, AsyncCallback callback, object state, Task semaphoreLockTask)
public void EndWrite(IAsyncResult asyncResult)
public Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken)
private Task WriteToUnderlyingStreamAsync(Byte[] array, int offset, int count, CancellationToken cancellationToken, Task semaphoreLockTask, bool useApmPattern)
public void WriteByte(byte value)
public long Seek(long offset, SeekOrigin origin)
public void SetLength(long value)
}
internal System.IO.CStreamReader : StreamReader {
private TermInfoDriver driver
public void .ctor(Stream stream, Encoding encoding)
public int Peek()
public int Read()
public int Read(Char[] dest, int index, int count)
public string ReadLine()
public string ReadToEnd()
}
internal System.IO.CStreamWriter : StreamWriter {
private TermInfoDriver driver
public void .ctor(Stream stream, Encoding encoding, bool leaveOpen)
public void Write(Char[] buffer, int index, int count)
public void Write(char val)
public void InternalWriteString(string val)
public void InternalWriteChar(char val)
public void InternalWriteChars(Char[] buffer, int n)
public void Write(Char[] val)
public void Write(string val)
}
public System.IO.Directory : object {
public String[] GetFiles(string path)
public String[] GetFiles(string path, string searchPattern)
public String[] GetFiles(string path, string searchPattern, SearchOption searchOption)
private String[] InternalGetFiles(string path, string searchPattern, SearchOption searchOption)
internal String[] UnsafeGetFiles(string path, string searchPattern, SearchOption searchOption)
public String[] GetDirectories(string path)
public String[] GetDirectories(string path, string searchPattern)
public String[] GetDirectories(string path, string searchPattern, SearchOption searchOption)
private String[] InternalGetDirectories(string path, string searchPattern, SearchOption searchOption)
internal String[] UnsafeGetDirectories(string path, string searchPattern, SearchOption searchOption)
public String[] GetFileSystemEntries(string path)
public String[] GetFileSystemEntries(string path, string searchPattern)
public String[] GetFileSystemEntries(string path, string searchPattern, SearchOption searchOption)
private String[] InternalGetFileSystemEntries(string path, string searchPattern, SearchOption searchOption)
internal String[] InternalGetFileDirectoryNames(string path, string userPathOriginal, string searchPattern, bool includeFiles, bool includeDirs, SearchOption searchOption, bool checkHost)
public IEnumerable`1<string> EnumerateDirectories(string path)
public IEnumerable`1<string> EnumerateDirectories(string path, string searchPattern)
public IEnumerable`1<string> EnumerateDirectories(string path, string searchPattern, SearchOption searchOption)
private IEnumerable`1<string> InternalEnumerateDirectories(string path, string searchPattern, SearchOption searchOption)
public IEnumerable`1<string> EnumerateFiles(string path)
public IEnumerable`1<string> EnumerateFiles(string path, string searchPattern)
public IEnumerable`1<string> EnumerateFiles(string path, string searchPattern, SearchOption searchOption)
private IEnumerable`1<string> InternalEnumerateFiles(string path, string searchPattern, SearchOption searchOption)
public IEnumerable`1<string> EnumerateFileSystemEntries(string path)
public IEnumerable`1<string> EnumerateFileSystemEntries(string path, string searchPattern)
public IEnumerable`1<string> EnumerateFileSystemEntries(string path, string searchPattern, SearchOption searchOption)
private IEnumerable`1<string> InternalEnumerateFileSystemEntries(string path, string searchPattern, SearchOption searchOption)
private IEnumerable`1<string> EnumerateFileSystemNames(string path, string searchPattern, SearchOption searchOption, bool includeFiles, bool includeDirs)
public string GetDirectoryRoot(string path)
public DirectoryInfo CreateDirectory(string path)
public DirectoryInfo CreateDirectory(string path, DirectorySecurity directorySecurity)
private DirectoryInfo CreateDirectoriesInternal(string path)
public void Delete(string path)
private void RecursiveDelete(string path)
public void Delete(string path, bool recursive)
public bool Exists(string path)
public DateTime GetLastAccessTime(string path)
public DateTime GetLastAccessTimeUtc(string path)
public DateTime GetLastWriteTime(string path)
public DateTime GetLastWriteTimeUtc(string path)
public DateTime GetCreationTime(string path)
public DateTime GetCreationTimeUtc(string path)
public string GetCurrentDirectory()
internal string InsecureGetCurrentDirectory()
public String[] GetLogicalDrives()
private bool IsRootDirectory(string path)
public DirectoryInfo GetParent(string path)
public void Move(string sourceDirName, string destDirName)
public void SetAccessControl(string path, DirectorySecurity directorySecurity)
public void SetCreationTime(string path, DateTime creationTime)
public void SetCreationTimeUtc(string path, DateTime creationTimeUtc)
public void SetCurrentDirectory(string path)
public void SetLastAccessTime(string path, DateTime lastAccessTime)
public void SetLastAccessTimeUtc(string path, DateTime lastAccessTimeUtc)
public void SetLastWriteTime(string path, DateTime lastWriteTime)
public void SetLastWriteTimeUtc(string path, DateTime lastWriteTimeUtc)
public DirectorySecurity GetAccessControl(string path, AccessControlSections includeSections)
public DirectorySecurity GetAccessControl(string path)
internal string GetDemandDir(string fullPath, bool thisDirOnly)
}
public System.IO.DirectoryInfo : FileSystemInfo {
private string current
private string parent
public bool Exists
public string Name
public DirectoryInfo Parent
public DirectoryInfo Root
public void .ctor(string path)
internal void .ctor(string path, bool simpleOriginalPath)
private void .ctor(SerializationInfo info, StreamingContext context)
private void Initialize()
public bool get_Exists()
public string get_Name()
public DirectoryInfo get_Parent()
public DirectoryInfo get_Root()
public void Create()
public DirectoryInfo CreateSubdirectory(string path)
public FileInfo[] GetFiles()
public FileInfo[] GetFiles(string searchPattern)
public DirectoryInfo[] GetDirectories()
public DirectoryInfo[] GetDirectories(string searchPattern)
public FileSystemInfo[] GetFileSystemInfos()
public FileSystemInfo[] GetFileSystemInfos(string searchPattern)
public FileSystemInfo[] GetFileSystemInfos(string searchPattern, SearchOption searchOption)
private void InternalGetFileSystemInfos(string searchPattern, SearchOption searchOption, List`1<FileSystemInfo> infos)
public void Delete()
public void Delete(bool recursive)
public void MoveTo(string destDirName)
public string ToString()
public DirectoryInfo[] GetDirectories(string searchPattern, SearchOption searchOption)
internal int GetFilesSubdirs(ArrayList l, string pattern)
public FileInfo[] GetFiles(string searchPattern, SearchOption searchOption)
public void Create(DirectorySecurity directorySecurity)
public DirectoryInfo CreateSubdirectory(string path, DirectorySecurity directorySecurity)
public DirectorySecurity GetAccessControl()
public DirectorySecurity GetAccessControl(AccessControlSections includeSections)
public void SetAccessControl(DirectorySecurity directorySecurity)
public IEnumerable`1<DirectoryInfo> EnumerateDirectories()
public IEnumerable`1<DirectoryInfo> EnumerateDirectories(string searchPattern)
public IEnumerable`1<DirectoryInfo> EnumerateDirectories(string searchPattern, SearchOption searchOption)
private IEnumerable`1<DirectoryInfo> CreateEnumerateDirectoriesIterator(string searchPattern, SearchOption searchOption)
public IEnumerable`1<FileInfo> EnumerateFiles()
public IEnumerable`1<FileInfo> EnumerateFiles(string searchPattern)
public IEnumerable`1<FileInfo> EnumerateFiles(string searchPattern, SearchOption searchOption)
private IEnumerable`1<FileInfo> CreateEnumerateFilesIterator(string searchPattern, SearchOption searchOption)
public IEnumerable`1<FileSystemInfo> EnumerateFileSystemInfos()
public IEnumerable`1<FileSystemInfo> EnumerateFileSystemInfos(string searchPattern)
public IEnumerable`1<FileSystemInfo> EnumerateFileSystemInfos(string searchPattern, SearchOption searchOption)
internal IEnumerable`1<FileSystemInfo> EnumerateFileSystemInfos(string basePath, string searchPattern, SearchOption searchOption)
internal void CheckPath(string path)
}
internal System.IO.DirectoryInfoResultHandler : SearchResultHandler`1<DirectoryInfo> {
internal bool IsResultIncluded(SearchResult result)
internal DirectoryInfo CreateObject(SearchResult result)
}
public System.IO.DirectoryNotFoundException : IOException {
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
protected void .ctor(SerializationInfo info, StreamingContext context)
}
public System.IO.DriveInfo : object {
private string drive_format
private string path
public long AvailableFreeSpace
public long TotalFreeSpace
public long TotalSize
public string VolumeLabel
public string DriveFormat
public DriveType DriveType
public string Name
public DirectoryInfo RootDirectory
public bool IsReady
private void .ctor(string path, string fstype)
public void .ctor(string driveName)
private void GetDiskFreeSpace(string path, UInt64& availableFreeSpace, UInt64& totalSize, UInt64& totalFreeSpace)
public long get_AvailableFreeSpace()
public long get_TotalFreeSpace()
public long get_TotalSize()
public string get_VolumeLabel()
public void set_VolumeLabel(string value)
public string get_DriveFormat()
public DriveType get_DriveType()
public string get_Name()
public DirectoryInfo get_RootDirectory()
public bool get_IsReady()
public DriveInfo[] GetDrives()
private void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context)
public string ToString()
private bool GetDiskFreeSpaceInternal(string pathName, UInt64& freeBytesAvail, UInt64& totalNumberOfBytes, UInt64& totalNumberOfFreeBytes, MonoIOError& error)
private UInt32 GetDriveTypeInternal(string rootPathName)
private string GetDriveFormat(string rootPathName)
}
public System.IO.DriveNotFoundException : IOException {
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
protected void .ctor(SerializationInfo info, StreamingContext context)
}
public System.IO.DriveType : Enum {
public int value__
public DriveType CDRom
public DriveType Fixed
public DriveType Network
public DriveType NoRootDirectory
public DriveType Ram
public DriveType Removable
public DriveType Unknown
}
public System.IO.EndOfStreamException : IOException {
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
protected void .ctor(SerializationInfo info, StreamingContext context)
}
public System.IO.File : object {
private Nullable`1<DateTime> defaultLocalFileTime
private DateTime DefaultLocalFileTime
public void AppendAllText(string path, string contents)
public void AppendAllText(string path, string contents, Encoding encoding)
public StreamWriter AppendText(string path)
public void Copy(string sourceFileName, string destFileName)
public void Copy(string sourceFileName, string destFileName, bool overwrite)
internal string InternalCopy(string sourceFileName, string destFileName, bool overwrite, bool checkHost)
public FileStream Create(string path)
public FileStream Create(string path, int bufferSize)
public FileStream Create(string path, int bufferSize, FileOptions options)
public FileStream Create(string path, int bufferSize, FileOptions options, FileSecurity fileSecurity)
public StreamWriter CreateText(string path)
public void Delete(string path)
public bool Exists(string path)
public FileSecurity GetAccessControl(string path)
public FileSecurity GetAccessControl(string path, AccessControlSections includeSections)
public FileAttributes GetAttributes(string path)
public DateTime GetCreationTime(string path)
public DateTime GetCreationTimeUtc(string path)
public DateTime GetLastAccessTime(string path)
public DateTime GetLastAccessTimeUtc(string path)
public DateTime GetLastWriteTime(string path)
public DateTime GetLastWriteTimeUtc(string path)
public void Move(string sourceFileName, string destFileName)
public FileStream Open(string path, FileMode mode)
public FileStream Open(string path, FileMode mode, FileAccess access)
public FileStream Open(string path, FileMode mode, FileAccess access, FileShare share)
public FileStream OpenRead(string path)
public StreamReader OpenText(string path)
public FileStream OpenWrite(string path)
public void Replace(string sourceFileName, string destinationFileName, string destinationBackupFileName)
public void Replace(string sourceFileName, string destinationFileName, string destinationBackupFileName, bool ignoreMetadataErrors)
public void SetAccessControl(string path, FileSecurity fileSecurity)
public void SetAttributes(string path, FileAttributes fileAttributes)
public void SetCreationTime(string path, DateTime creationTime)
public void SetCreationTimeUtc(string path, DateTime creationTimeUtc)
public void SetLastAccessTime(string path, DateTime lastAccessTime)
public void SetLastAccessTimeUtc(string path, DateTime lastAccessTimeUtc)
public void SetLastWriteTime(string path, DateTime lastWriteTime)
public void SetLastWriteTimeUtc(string path, DateTime lastWriteTimeUtc)
public Byte[] ReadAllBytes(string path)
public String[] ReadAllLines(string path)
public String[] ReadAllLines(string path, Encoding encoding)
private String[] ReadAllLines(StreamReader reader)
public string ReadAllText(string path)
public string ReadAllText(string path, Encoding encoding)
public void WriteAllBytes(string path, Byte[] bytes)
public void WriteAllLines(string path, String[] contents)
public void WriteAllLines(string path, String[] contents, Encoding encoding)
private void WriteAllLines(StreamWriter writer, String[] contents)
public void WriteAllText(string path, string contents)
public void WriteAllText(string path, string contents, Encoding encoding)
private DateTime get_DefaultLocalFileTime()
public void Encrypt(string path)
public void Decrypt(string path)
public IEnumerable`1<string> ReadLines(string path)
public IEnumerable`1<string> ReadLines(string path, Encoding encoding)
private IEnumerable`1<string> ReadLines(StreamReader reader)
public void AppendAllLines(string path, IEnumerable`1<string> contents)
public void AppendAllLines(string path, IEnumerable`1<string> contents, Encoding encoding)
public void WriteAllLines(string path, IEnumerable`1<string> contents)
public void WriteAllLines(string path, IEnumerable`1<string> contents, Encoding encoding)
internal int FillAttributeInfo(string path, MonoIOStat& data, bool tryagain, bool returnErrorOnNotFound)
}
public System.IO.FileAccess : Enum {
public int value__
public FileAccess Read
public FileAccess Write
public FileAccess ReadWrite
}
public System.IO.FileAttributes : Enum {
public int value__
public FileAttributes Archive
public FileAttributes Compressed
public FileAttributes Device
public FileAttributes Directory
public FileAttributes Encrypted
public FileAttributes Hidden
public FileAttributes Normal
public FileAttributes NotContentIndexed
public FileAttributes Offline
public FileAttributes ReadOnly
public FileAttributes ReparsePoint
public FileAttributes SparseFile
public FileAttributes System
public FileAttributes Temporary
public FileAttributes IntegrityStream
public FileAttributes NoScrubData
}
public System.IO.FileInfo : FileSystemInfo {
private string _name
public string Name
public long Length
public string DirectoryName
public DirectoryInfo Directory
public bool IsReadOnly
public bool Exists
public void .ctor(string fileName)
private void Init(string fileName, bool checkHost)
private string GetDisplayPath(string originalPath)
private void .ctor(SerializationInfo info, StreamingContext context)
internal void .ctor(string fullPath, bool ignoreThis)
public string get_Name()
public long get_Length()
public string get_DirectoryName()
public DirectoryInfo get_Directory()
public bool get_IsReadOnly()
public void set_IsReadOnly(bool value)
public FileSecurity GetAccessControl()
public FileSecurity GetAccessControl(AccessControlSections includeSections)
public void SetAccessControl(FileSecurity fileSecurity)
public StreamReader OpenText()
public StreamWriter CreateText()
public StreamWriter AppendText()
public FileInfo CopyTo(string destFileName)
public FileInfo CopyTo(string destFileName, bool overwrite)
public FileStream Create()
public void Delete()
public void Decrypt()
public void Encrypt()
public bool get_Exists()
public FileStream Open(FileMode mode)
public FileStream Open(FileMode mode, FileAccess access)
public FileStream Open(FileMode mode, FileAccess access, FileShare share)
public FileStream OpenRead()
public FileStream OpenWrite()
public void MoveTo(string destFileName)
public FileInfo Replace(string destinationFileName, string destinationBackupFileName)
public FileInfo Replace(string destinationFileName, string destinationBackupFileName, bool ignoreMetadataErrors)
public string ToString()
}
internal System.IO.FileInfoResultHandler : SearchResultHandler`1<FileInfo> {
internal bool IsResultIncluded(SearchResult result)
internal FileInfo CreateObject(SearchResult result)
}
public System.IO.FileLoadException : IOException {
private string _fileName
private string _fusionLog
public string Message
public string FileName
public string FusionLog
public void .ctor(string message)
public void .ctor(string message, Exception inner)
public void .ctor(string message, string fileName)
public void .ctor(string message, string fileName, Exception inner)
public string get_Message()
private void SetMessageField()
public string get_FileName()
public string ToString()
protected void .ctor(SerializationInfo info, StreamingContext context)
private void .ctor(string fileName, string fusionLog, int hResult)
public string get_FusionLog()
public void GetObjectData(SerializationInfo info, StreamingContext context)
internal string FormatFileLoadExceptionMessage(string fileName, int hResult)
}
public System.IO.FileMode : Enum {
public int value__
public FileMode CreateNew
public FileMode Create
public FileMode Open
public FileMode OpenOrCreate
public FileMode Truncate
public FileMode Append
}
public System.IO.FileNotFoundException : IOException {
private string _fileName
private string _fusionLog
public string Message
public string FileName
public string FusionLog
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
public void .ctor(string message, string fileName)
public void .ctor(string message, string fileName, Exception innerException)
public string get_Message()
private void SetMessageField()
public string get_FileName()
public string ToString()
protected void .ctor(SerializationInfo info, StreamingContext context)
private void .ctor(string fileName, string fusionLog, int hResult)
public string get_FusionLog()
public void GetObjectData(SerializationInfo info, StreamingContext context)
}
public System.IO.FileOptions : Enum {
public int value__
public FileOptions None
public FileOptions Encrypted
public FileOptions DeleteOnClose
public FileOptions SequentialScan
public FileOptions RandomAccess
public FileOptions Asynchronous
public FileOptions WriteThrough
}
public System.IO.FileShare : Enum {
public int value__
public FileShare None
public FileShare Read
public FileShare Write
public FileShare ReadWrite
public FileShare Delete
public FileShare Inheritable
}
public System.IO.FileStream : Stream {
internal int DefaultBufferSize
private Byte[] buf_recycle
private object buf_recycle_lock
private Byte[] buf
private string name
private SafeFileHandle safeHandle
private bool isExposed
private long append_startpos
private FileAccess access
private bool owner
private bool async
private bool canseek
private bool anonymous
private bool buf_dirty
private int buf_size
private int buf_length
private int buf_offset
private long buf_start
public bool CanRead
public bool CanWrite
public bool CanSeek
public bool IsAsync
public string Name
public long Length
public long Position
public IntPtr Handle
public SafeFileHandle SafeFileHandle
public void .ctor(IntPtr handle, FileAccess access)
public void .ctor(IntPtr handle, FileAccess access, bool ownsHandle)
public void .ctor(IntPtr handle, FileAccess access, bool ownsHandle, int bufferSize)
public void .ctor(IntPtr handle, FileAccess access, bool ownsHandle, int bufferSize, bool isAsync)
internal void .ctor(IntPtr handle, FileAccess access, bool ownsHandle, int bufferSize, bool isAsync, bool isConsoleWrapper)
public void .ctor(string path, FileMode mode)
public void .ctor(string path, FileMode mode, FileAccess access)
public void .ctor(string path, FileMode mode, FileAccess access, FileShare share)
public void .ctor(string path, FileMode mode, FileAccess access, FileShare share, int bufferSize)
public void .ctor(string path, FileMode mode, FileAccess access, FileShare share, int bufferSize, bool useAsync)
public void .ctor(string path, FileMode mode, FileAccess access, FileShare share, int bufferSize, FileOptions options)
public void .ctor(SafeFileHandle handle, FileAccess access)
public void .ctor(SafeFileHandle handle, FileAccess access, int bufferSize)
public void .ctor(SafeFileHandle handle, FileAccess access, int bufferSize, bool isAsync)
public void .ctor(string path, FileMode mode, FileSystemRights rights, FileShare share, int bufferSize, FileOptions options)
public void .ctor(string path, FileMode mode, FileSystemRights rights, FileShare share, int bufferSize, FileOptions options, FileSecurity fileSecurity)
internal void .ctor(string path, FileMode mode, FileAccess access, FileShare share, int bufferSize, FileOptions options, string msgPath, bool bFromProxy, bool useLongPath, bool checkHost)
internal void .ctor(string path, FileMode mode, FileAccess access, FileShare share, int bufferSize, bool isAsync, bool anonymous)
internal void .ctor(string path, FileMode mode, FileAccess access, FileShare share, int bufferSize, bool anonymous, FileOptions options)
private void Init(SafeFileHandle safeHandle, FileAccess access, bool ownsHandle, int bufferSize, bool isAsync, bool isConsoleWrapper)
public bool get_CanRead()
public bool get_CanWrite()
public bool get_CanSeek()
public bool get_IsAsync()
public string get_Name()
public long get_Length()
public long get_Position()
public void set_Position(long value)
public IntPtr get_Handle()
public SafeFileHandle get_SafeFileHandle()
private void ExposeHandle()
public int ReadByte()
public void WriteByte(byte value)
public int Read(Byte[] array, int offset, int count)
private int ReadInternal(Byte[] dest, int offset, int count)
public IAsyncResult BeginRead(Byte[] array, int offset, int numBytes, AsyncCallback userCallback, object stateObject)
public int EndRead(IAsyncResult asyncResult)
public void Write(Byte[] array, int offset, int count)
private void WriteInternal(Byte[] src, int offset, int count)
public IAsyncResult BeginWrite(Byte[] array, int offset, int numBytes, AsyncCallback userCallback, object stateObject)
public void EndWrite(IAsyncResult asyncResult)
public long Seek(long offset, SeekOrigin origin)
public void SetLength(long value)
public void Flush()
public void Flush(bool flushToDisk)
public void Lock(long position, long length)
public void Unlock(long position, long length)
protected void Finalize()
protected void Dispose(bool disposing)
public FileSecurity GetAccessControl()
public void SetAccessControl(FileSecurity fileSecurity)
public Task FlushAsync(CancellationToken cancellationToken)
public Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken)
public Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken)
private int ReadSegment(Byte[] dest, int dest_offset, int count)
private int WriteSegment(Byte[] src, int src_offset, int count)
private void FlushBuffer()
private void FlushBufferIfDirty()
private void RefillBuffer()
private int ReadData(SafeHandle safeHandle, Byte[] buf, int offset, int count)
private void InitBuffer(int size, bool isZeroSize)
private string GetSecureFileName(string filename)
private string GetSecureFileName(string filename, bool full)
}
internal System.IO.FileStreamAsyncResult : object {
private object state
private bool completed
private bool done
private Exception exc
private ManualResetEvent wh
private AsyncCallback cb
private bool completedSynch
public Byte[] Buffer
public int Offset
public int Count
public int OriginalCount
public int BytesRead
private AsyncCallback realcb
public object AsyncState
public bool CompletedSynchronously
public WaitHandle AsyncWaitHandle
public bool IsCompleted
public Exception Exception
public bool Done
public void .ctor(AsyncCallback cb, object state)
private void CBWrapper(IAsyncResult ares)
public void SetComplete(Exception e)
public void SetComplete(Exception e, int nbytes)
public void SetComplete(Exception e, int nbytes, bool synch)
public object get_AsyncState()
public bool get_CompletedSynchronously()
public WaitHandle get_AsyncWaitHandle()
public bool get_IsCompleted()
public Exception get_Exception()
public bool get_Done()
public void set_Done(bool value)
}
internal System.IO.FileSystemEnumerableFactory : object {
internal IEnumerable`1<string> CreateFileNameIterator(string path, string originalUserPath, string searchPattern, bool includeFiles, bool includeDirs, SearchOption searchOption, bool checkHost)
internal IEnumerable`1<FileInfo> CreateFileInfoIterator(string path, string originalUserPath, string searchPattern, SearchOption searchOption)
internal IEnumerable`1<DirectoryInfo> CreateDirectoryInfoIterator(string path, string originalUserPath, string searchPattern, SearchOption searchOption)
internal IEnumerable`1<FileSystemInfo> CreateFileSystemInfoIterator(string path, string originalUserPath, string searchPattern, SearchOption searchOption)
}
internal System.IO.FileSystemEnumerableHelpers : object {
internal bool IsDir(WIN32_FIND_DATA data)
internal bool IsFile(WIN32_FIND_DATA data)
}
internal System.IO.FileSystemEnumerableIterator`1 : Iterator`1<TSource> {
private int STATE_INIT
private int STATE_SEARCH_NEXT_DIR
private int STATE_FIND_NEXT_FILE
private int STATE_FINISH
private SearchResultHandler`1<TSource> _resultHandler
private List`1<SearchData> searchStack
private SearchData searchData
private string searchCriteria
private SafeFindHandle _hnd
private bool needsParentPathDiscoveryDemand
private bool empty
private string userPath
private SearchOption searchOption
private string fullPath
private string normalizedSearchPath
private bool _checkHost
internal void .ctor(string path, string originalUserPath, string searchPattern, SearchOption searchOption, SearchResultHandler`1<TSource> resultHandler, bool checkHost)
private void CommonInit()
private void .ctor(string fullPath, string normalizedSearchPath, string searchCriteria, string userPath, SearchOption searchOption, SearchResultHandler`1<TSource> resultHandler, bool checkHost)
protected Iterator`1<TSource> Clone()
protected void Dispose(bool disposing)
public bool MoveNext()
private SearchResult CreateSearchResult(SearchData localSearchData, WIN32_FIND_DATA findData)
private void HandleError(int hr, string path)
private void AddSearchableDirsToStack(SearchData localSearchData)
internal void DoDemand(string fullPathToDemand)
private string NormalizeSearchPattern(string searchPattern)
private string GetNormalizedSearchCriteria(string fullSearchString, string fullPathMod)
private string GetFullSearchString(string fullPath, string searchPattern)
}
public System.IO.FileSystemInfo : MarshalByRefObject {
internal MonoIOStat _data
internal int _dataInitialised
private int ERROR_INVALID_PARAMETER
internal int ERROR_ACCESS_DENIED
protected string FullPath
protected string OriginalPath
private string _displayPath
public string FullName
internal string UnsafeGetFullName
public string Extension
public string Name
public bool Exists
public DateTime CreationTime
public DateTime CreationTimeUtc
public DateTime LastAccessTime
public DateTime LastAccessTimeUtc
public DateTime LastWriteTime
public DateTime LastWriteTimeUtc
public FileAttributes Attributes
internal string DisplayPath
protected void .ctor(SerializationInfo info, StreamingContext context)
internal void InitializeFrom(WIN32_FIND_DATA findData)
public string get_FullName()
internal string get_UnsafeGetFullName()
public string get_Extension()
public string get_Name()
public bool get_Exists()
public void Delete()
public DateTime get_CreationTime()
public void set_CreationTime(DateTime value)
public DateTime get_CreationTimeUtc()
public void set_CreationTimeUtc(DateTime value)
public DateTime get_LastAccessTime()
public void set_LastAccessTime(DateTime value)
public DateTime get_LastAccessTimeUtc()
public void set_LastAccessTimeUtc(DateTime value)
public DateTime get_LastWriteTime()
public void set_LastWriteTime(DateTime value)
public DateTime get_LastWriteTimeUtc()
public void set_LastWriteTimeUtc(DateTime value)
public void Refresh()
public FileAttributes get_Attributes()
public void set_Attributes(FileAttributes value)
public void GetObjectData(SerializationInfo info, StreamingContext context)
internal string get_DisplayPath()
internal void set_DisplayPath(string value)
}
internal System.IO.FileSystemInfoResultHandler : SearchResultHandler`1<FileSystemInfo> {
internal bool IsResultIncluded(SearchResult result)
internal FileSystemInfo CreateObject(SearchResult result)
}
internal System.IO.HGlobalUnmanagedMemoryStream : UnmanagedMemoryStream {
private IntPtr ptr
public void .ctor(Byte* pointer, long length, IntPtr ptr)
protected void Dispose(bool disposing)
}
public System.IO.IOException : SystemException {
private string _maybeFullPath
public void .ctor(string message)
public void .ctor(string message, int hresult)
internal void .ctor(string message, int hresult, string maybeFullPath)
public void .ctor(string message, Exception innerException)
protected void .ctor(SerializationInfo info, StreamingContext context)
}
public System.IO.IsolatedStorage.INormalizeForIsolatedStorage {
public object Normalize()
}
public System.IO.IsolatedStorage.IsolatedStorage : MarshalByRefObject {
internal IsolatedStorageScope storage_scope
internal object _assemblyIdentity
internal object _domainIdentity
internal object _applicationIdentity
public object ApplicationIdentity
public object AssemblyIdentity
public ulong CurrentSize
public object DomainIdentity
public ulong MaximumSize
public IsolatedStorageScope Scope
public long AvailableFreeSpace
public long Quota
public long UsedSize
protected char SeparatorExternal
protected char SeparatorInternal
public object get_ApplicationIdentity()
public object get_AssemblyIdentity()
public ulong get_CurrentSize()
public object get_DomainIdentity()
public ulong get_MaximumSize()
public IsolatedStorageScope get_Scope()
public long get_AvailableFreeSpace()
public long get_Quota()
public long get_UsedSize()
protected char get_SeparatorExternal()
protected char get_SeparatorInternal()
protected IsolatedStoragePermission GetPermission(PermissionSet ps)
protected void InitStore(IsolatedStorageScope scope, Type domainEvidenceType, Type assemblyEvidenceType)
protected void InitStore(IsolatedStorageScope scope, Type appEvidenceType)
public void Remove()
public bool IncreaseQuotaTo(long newQuotaSize)
}
public System.IO.IsolatedStorage.IsolatedStorageException : Exception {
public void .ctor(string message)
public void .ctor(string message, Exception inner)
protected void .ctor(SerializationInfo info, StreamingContext context)
}
public System.IO.IsolatedStorage.IsolatedStorageFile : IsolatedStorage {
private bool _resolved
private ulong _maxSize
private Evidence _fullEvidences
private Mutex mutex
private bool closed
private bool disposed
private DirectoryInfo directory
public ulong CurrentSize
public ulong MaximumSize
internal string Root
public long AvailableFreeSpace
public long Quota
public long UsedSize
public bool IsEnabled
internal bool IsClosed
internal bool IsDisposed
public IEnumerator GetEnumerator(IsolatedStorageScope scope)
public IsolatedStorageFile GetStore(IsolatedStorageScope scope, Evidence domainEvidence, Type domainEvidenceType, Evidence assemblyEvidence, Type assemblyEvidenceType)
public IsolatedStorageFile GetStore(IsolatedStorageScope scope, object domainIdentity, object assemblyIdentity)
public IsolatedStorageFile GetStore(IsolatedStorageScope scope, Type domainEvidenceType, Type assemblyEvidenceType)
public IsolatedStorageFile GetStore(IsolatedStorageScope scope, object applicationIdentity)
public IsolatedStorageFile GetStore(IsolatedStorageScope scope, Type applicationEvidenceType)
public IsolatedStorageFile GetMachineStoreForApplication()
public IsolatedStorageFile GetMachineStoreForAssembly()
public IsolatedStorageFile GetMachineStoreForDomain()
public IsolatedStorageFile GetUserStoreForApplication()
public IsolatedStorageFile GetUserStoreForAssembly()
public IsolatedStorageFile GetUserStoreForDomain()
public IsolatedStorageFile GetUserStoreForSite()
public void Remove(IsolatedStorageScope scope)
internal string GetIsolatedStorageRoot(IsolatedStorageScope scope)
private void Demand(IsolatedStorageScope scope)
private IsolatedStorageContainment ScopeToContainment(IsolatedStorageScope scope)
internal ulong GetDirectorySize(DirectoryInfo di)
private void .ctor(IsolatedStorageScope scope)
internal void .ctor(IsolatedStorageScope scope, string location)
protected void Finalize()
private void PostInit()
public ulong get_CurrentSize()
public ulong get_MaximumSize()
internal string get_Root()
public long get_AvailableFreeSpace()
public long get_Quota()
public long get_UsedSize()
public bool get_IsEnabled()
internal bool get_IsClosed()
internal bool get_IsDisposed()
public void Close()
public void CreateDirectory(string dir)
public void CopyFile(string sourceFileName, string destinationFileName)
public void CopyFile(string sourceFileName, string destinationFileName, bool overwrite)
public IsolatedStorageFileStream CreateFile(string path)
public void DeleteDirectory(string dir)
public void DeleteFile(string file)
public void Dispose()
public bool DirectoryExists(string path)
public bool FileExists(string path)
public DateTimeOffset GetCreationTime(string path)
public DateTimeOffset GetLastAccessTime(string path)
public DateTimeOffset GetLastWriteTime(string path)
public String[] GetDirectoryNames(string searchPattern)
public String[] GetDirectoryNames()
private String[] GetNames(FileSystemInfo[] afsi)
public String[] GetFileNames(string searchPattern)
public String[] GetFileNames()
public bool IncreaseQuotaTo(long newQuotaSize)
public void MoveDirectory(string sourceDirectoryName, string destinationDirectoryName)
public void MoveFile(string sourceFileName, string destinationFileName)
public IsolatedStorageFileStream OpenFile(string path, FileMode mode)
public IsolatedStorageFileStream OpenFile(string path, FileMode mode, FileAccess access)
public IsolatedStorageFileStream OpenFile(string path, FileMode mode, FileAccess access, FileShare share)
public void Remove()
protected IsolatedStoragePermission GetPermission(PermissionSet ps)
private void CheckOpen()
private void CheckOpen(bool checkDirExists)
private bool IsPathInStorage(string path)
private string GetNameFromIdentity(object identity)
private object GetTypeFromEvidence(Evidence e, Type t)
internal object GetAssemblyIdentityFromEvidence(Evidence e)
internal object GetDomainIdentityFromEvidence(Evidence e)
private void SaveIdentities(string root)
}
internal System.IO.IsolatedStorage.IsolatedStorageFileEnumerator : object {
private IsolatedStorageScope _scope
private String[] _storages
private int _pos
public object Current
public void .ctor(IsolatedStorageScope scope, string root)
public object get_Current()
public bool MoveNext()
public void Reset()
}
public System.IO.IsolatedStorage.IsolatedStorageFileStream : FileStream {
public bool CanRead
public bool CanSeek
public bool CanWrite
public SafeFileHandle SafeFileHandle
public IntPtr Handle
public bool IsAsync
public long Length
public long Position
private string CreateIsolatedPath(IsolatedStorageFile isf, string path, FileMode mode)
public void .ctor(string path, FileMode mode)
public void .ctor(string path, FileMode mode, FileAccess access)
public void .ctor(string path, FileMode mode, FileAccess access, FileShare share)
public void .ctor(string path, FileMode mode, FileAccess access, FileShare share, int bufferSize)
public void .ctor(string path, FileMode mode, FileAccess access, FileShare share, int bufferSize, IsolatedStorageFile isf)
public void .ctor(string path, FileMode mode, FileAccess access, FileShare share, IsolatedStorageFile isf)
public void .ctor(string path, FileMode mode, FileAccess access, IsolatedStorageFile isf)
public void .ctor(string path, FileMode mode, IsolatedStorageFile isf)
public bool get_CanRead()
public bool get_CanSeek()
public bool get_CanWrite()
public SafeFileHandle get_SafeFileHandle()
public IntPtr get_Handle()
public bool get_IsAsync()
public long get_Length()
public long get_Position()
public void set_Position(long value)
public IAsyncResult BeginRead(Byte[] buffer, int offset, int numBytes, AsyncCallback userCallback, object stateObject)
public IAsyncResult BeginWrite(Byte[] buffer, int offset, int numBytes, AsyncCallback userCallback, object stateObject)
public int EndRead(IAsyncResult asyncResult)
public void EndWrite(IAsyncResult asyncResult)
public void Flush()
public void Flush(bool flushToDisk)
public int Read(Byte[] buffer, int offset, int count)
public int ReadByte()
public long Seek(long offset, SeekOrigin origin)
public void SetLength(long value)
public void Write(Byte[] buffer, int offset, int count)
public void WriteByte(byte value)
protected void Dispose(bool disposing)
}
public System.IO.IsolatedStorage.IsolatedStorageScope : Enum {
public int value__
public IsolatedStorageScope None
public IsolatedStorageScope User
public IsolatedStorageScope Domain
public IsolatedStorageScope Assembly
public IsolatedStorageScope Roaming
public IsolatedStorageScope Machine
public IsolatedStorageScope Application
}
public System.IO.IsolatedStorage.IsolatedStorageSecurityOptions : Enum {
public int value__
public IsolatedStorageSecurityOptions IncreaseQuotaForApplication
}
public System.IO.IsolatedStorage.IsolatedStorageSecurityState : SecurityState {
public IsolatedStorageSecurityOptions Options
public long Quota
public long UsedSize
public IsolatedStorageSecurityOptions get_Options()
public long get_Quota()
public void set_Quota(long value)
public long get_UsedSize()
public void EnsureState()
}
internal System.IO.Iterator`1 : object {
private int threadId
internal int state
internal TSource current
public TSource Current
private object System.Collections.IEnumerator.Current
public TSource get_Current()
protected Iterator`1<TSource> Clone()
public void Dispose()
protected void Dispose(bool disposing)
public IEnumerator`1<TSource> GetEnumerator()
public bool MoveNext()
private object System.Collections.IEnumerator.get_Current()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
private void System.Collections.IEnumerator.Reset()
}
public System.IO.MemoryStream : Stream {
private Byte[] _buffer
private int _origin
private int _position
private int _length
private int _capacity
private bool _expandable
private bool _writable
private bool _exposable
private bool _isOpen
private Task`1<int> _lastReadTask
private int MemStreamMaxLength
public bool CanRead
public bool CanSeek
public bool CanWrite
public int Capacity
public long Length
public long Position
public void .ctor(int capacity)
public void .ctor(Byte[] buffer)
public void .ctor(Byte[] buffer, bool writable)
public void .ctor(Byte[] buffer, int index, int count)
public void .ctor(Byte[] buffer, int index, int count, bool writable)
public void .ctor(Byte[] buffer, int index, int count, bool writable, bool publiclyVisible)
public bool get_CanRead()
public bool get_CanSeek()
public bool get_CanWrite()
private void EnsureWriteable()
protected void Dispose(bool disposing)
private bool EnsureCapacity(int value)
public void Flush()
public Task FlushAsync(CancellationToken cancellationToken)
public Byte[] GetBuffer()
public bool TryGetBuffer(ArraySegment`1& buffer)
internal Byte[] InternalGetBuffer()
internal void InternalGetOriginAndLength(Int32& origin, Int32& length)
internal int InternalGetPosition()
internal int InternalReadInt32()
internal int InternalEmulateRead(int count)
public int get_Capacity()
public void set_Capacity(int value)
public long get_Length()
public long get_Position()
public void set_Position(long value)
public int Read(Byte[] buffer, int offset, int count)
public Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken)
public int ReadByte()
public Task CopyToAsync(Stream destination, int bufferSize, CancellationToken cancellationToken)
public long Seek(long offset, SeekOrigin loc)
public void SetLength(long value)
public Byte[] ToArray()
public void Write(Byte[] buffer, int offset, int count)
public Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken)
public void WriteByte(byte value)
public void WriteTo(Stream stream)
}
internal System.IO.MonoFileType : Enum {
public int value__
public MonoFileType Unknown
public MonoFileType Disk
public MonoFileType Char
public MonoFileType Pipe
public MonoFileType Remote
}
internal System.IO.MonoIO : object {
public int FileAlreadyExistsHResult
public FileAttributes InvalidFileAttributes
public IntPtr InvalidHandle
private bool dump_handles
public IntPtr ConsoleOutput
public IntPtr ConsoleInput
public IntPtr ConsoleError
public char VolumeSeparatorChar
public char DirectorySeparatorChar
public char AltDirectorySeparatorChar
public char PathSeparator
public Exception GetException(MonoIOError error)
public Exception GetException(string path, MonoIOError error)
private bool CreateDirectory(Char* path, MonoIOError& error)
public bool CreateDirectory(string path, MonoIOError& error)
private bool RemoveDirectory(Char* path, MonoIOError& error)
public bool RemoveDirectory(string path, MonoIOError& error)
public string GetCurrentDirectory(MonoIOError& error)
private bool SetCurrentDirectory(Char* path, MonoIOError& error)
public bool SetCurrentDirectory(string path, MonoIOError& error)
private bool MoveFile(Char* path, Char* dest, MonoIOError& error)
public bool MoveFile(string path, string dest, MonoIOError& error)
private bool CopyFile(Char* path, Char* dest, bool overwrite, MonoIOError& error)
public bool CopyFile(string path, string dest, bool overwrite, MonoIOError& error)
private bool DeleteFile(Char* path, MonoIOError& error)
public bool DeleteFile(string path, MonoIOError& error)
private bool ReplaceFile(Char* sourceFileName, Char* destinationFileName, Char* destinationBackupFileName, bool ignoreMetadataErrors, MonoIOError& error)
public bool ReplaceFile(string sourceFileName, string destinationFileName, string destinationBackupFileName, bool ignoreMetadataErrors, MonoIOError& error)
private FileAttributes GetFileAttributes(Char* path, MonoIOError& error)
public FileAttributes GetFileAttributes(string path, MonoIOError& error)
private bool SetFileAttributes(Char* path, FileAttributes attrs, MonoIOError& error)
public bool SetFileAttributes(string path, FileAttributes attrs, MonoIOError& error)
private MonoFileType GetFileType(IntPtr handle, MonoIOError& error)
public MonoFileType GetFileType(SafeHandle safeHandle, MonoIOError& error)
private IntPtr FindFirstFile(Char* pathWithPattern, String& fileName, Int32& fileAttr, Int32& error)
public IntPtr FindFirstFile(string pathWithPattern, String& fileName, Int32& fileAttr, Int32& error)
public bool FindNextFile(IntPtr hnd, String& fileName, Int32& fileAttr, Int32& error)
public bool FindCloseFile(IntPtr hnd)
public bool Exists(string path, MonoIOError& error)
public bool ExistsFile(string path, MonoIOError& error)
public bool ExistsDirectory(string path, MonoIOError& error)
public bool ExistsSymlink(string path, MonoIOError& error)
private bool GetFileStat(Char* path, MonoIOStat& stat, MonoIOError& error)
public bool GetFileStat(string path, MonoIOStat& stat, MonoIOError& error)
private IntPtr Open(Char* filename, FileMode mode, FileAccess access, FileShare share, FileOptions options, MonoIOError& error)
public IntPtr Open(string filename, FileMode mode, FileAccess access, FileShare share, FileOptions options, MonoIOError& error)
public bool Close(IntPtr handle, MonoIOError& error)
private int Read(IntPtr handle, Byte[] dest, int dest_offset, int count, MonoIOError& error)
public int Read(SafeHandle safeHandle, Byte[] dest, int dest_offset, int count, MonoIOError& error)
private int Write(IntPtr handle, Byte[] src, int src_offset, int count, MonoIOError& error)
public int Write(SafeHandle safeHandle, Byte[] src, int src_offset, int count, MonoIOError& error)
private long Seek(IntPtr handle, long offset, SeekOrigin origin, MonoIOError& error)
public long Seek(SafeHandle safeHandle, long offset, SeekOrigin origin, MonoIOError& error)
private bool Flush(IntPtr handle, MonoIOError& error)
public bool Flush(SafeHandle safeHandle, MonoIOError& error)
private long GetLength(IntPtr handle, MonoIOError& error)
public long GetLength(SafeHandle safeHandle, MonoIOError& error)
private bool SetLength(IntPtr handle, long length, MonoIOError& error)
public bool SetLength(SafeHandle safeHandle, long length, MonoIOError& error)
private bool SetFileTime(IntPtr handle, long creation_time, long last_access_time, long last_write_time, MonoIOError& error)
public bool SetFileTime(SafeHandle safeHandle, long creation_time, long last_access_time, long last_write_time, MonoIOError& error)
public bool SetFileTime(string path, long creation_time, long last_access_time, long last_write_time, MonoIOError& error)
public bool SetCreationTime(string path, DateTime dateTime, MonoIOError& error)
public bool SetLastAccessTime(string path, DateTime dateTime, MonoIOError& error)
public bool SetLastWriteTime(string path, DateTime dateTime, MonoIOError& error)
public bool SetFileTime(string path, int type, long creation_time, long last_access_time, long last_write_time, DateTime dateTime, MonoIOError& error)
private void Lock(IntPtr handle, long position, long length, MonoIOError& error)
public void Lock(SafeHandle safeHandle, long position, long length, MonoIOError& error)
private void Unlock(IntPtr handle, long position, long length, MonoIOError& error)
public void Unlock(SafeHandle safeHandle, long position, long length, MonoIOError& error)
public IntPtr get_ConsoleOutput()
public IntPtr get_ConsoleInput()
public IntPtr get_ConsoleError()
public bool CreatePipe(IntPtr& read_handle, IntPtr& write_handle, MonoIOError& error)
public bool DuplicateHandle(IntPtr source_process_handle, IntPtr source_handle, IntPtr target_process_handle, IntPtr& target_handle, int access, int inherit, int options, MonoIOError& error)
public char get_VolumeSeparatorChar()
public char get_DirectorySeparatorChar()
public char get_AltDirectorySeparatorChar()
public char get_PathSeparator()
private void DumpHandles()
public bool RemapPath(string path, String& newPath)
}
internal System.IO.MonoIOError : Enum {
public int value__
public MonoIOError ERROR_SUCCESS
public MonoIOError ERROR_FILE_NOT_FOUND
public MonoIOError ERROR_PATH_NOT_FOUND
public MonoIOError ERROR_TOO_MANY_OPEN_FILES
public MonoIOError ERROR_ACCESS_DENIED
public MonoIOError ERROR_INVALID_HANDLE
public MonoIOError ERROR_INVALID_DRIVE
public MonoIOError ERROR_NOT_SAME_DEVICE
public MonoIOError ERROR_NO_MORE_FILES
public MonoIOError ERROR_NOT_READY
public MonoIOError ERROR_WRITE_FAULT
public MonoIOError ERROR_READ_FAULT
public MonoIOError ERROR_GEN_FAILURE
public MonoIOError ERROR_SHARING_VIOLATION
public MonoIOError ERROR_LOCK_VIOLATION
public MonoIOError ERROR_HANDLE_DISK_FULL
public MonoIOError ERROR_FILE_EXISTS
public MonoIOError ERROR_CANNOT_MAKE
public MonoIOError ERROR_INVALID_PARAMETER
public MonoIOError ERROR_BROKEN_PIPE
public MonoIOError ERROR_INVALID_NAME
public MonoIOError ERROR_DIR_NOT_EMPTY
public MonoIOError ERROR_ALREADY_EXISTS
public MonoIOError ERROR_FILENAME_EXCED_RANGE
public MonoIOError ERROR_DIRECTORY
public MonoIOError ERROR_ENCRYPTION_FAILED
}
internal System.IO.MonoIOStat : ValueType {
public FileAttributes fileAttributes
public long Length
public long CreationTime
public long LastAccessTime
public long LastWriteTime
}
public System.IO.Path : object {
public Char[] InvalidPathChars
public char AltDirectorySeparatorChar
public char DirectorySeparatorChar
public char PathSeparator
internal string DirectorySeparatorStr
public char VolumeSeparatorChar
internal Char[] PathSeparatorChars
private bool dirEqualsVolume
internal int MAX_PATH
internal Char[] trimEndCharsWindows
internal Char[] trimEndCharsUnix
internal string DirectorySeparatorCharAsString
internal Char[] TrimEndChars
public string ChangeExtension(string path, string extension)
public string Combine(string path1, string path2)
internal string CleanPath(string s)
public string GetDirectoryName(string path)
public string GetExtension(string path)
public string GetFileName(string path)
public string GetFileNameWithoutExtension(string path)
public string GetFullPath(string path)
internal string GetFullPathInternal(string path)
private int GetFullPathName(string path, int numBufferChars, StringBuilder buffer, IntPtr& lpFilePartOrNull)
internal string GetFullPathName(string path)
internal string WindowsDriveAdjustment(string path)
internal string InsecureGetFullPath(string path)
internal bool IsDirectorySeparator(char c)
public string GetPathRoot(string path)
public string GetTempFileName()
public string GetTempPath()
private string get_temp_path()
public bool HasExtension(string path)
public bool IsPathRooted(string path)
public Char[] GetInvalidFileNameChars()
public Char[] GetInvalidPathChars()
public string GetRandomFileName()
private int findExtension(string path)
private string GetServerAndShare(string path)
private bool SameRoot(string root, string path)
private string CanonicalizePath(string path)
internal bool IsPathSubsetOf(string subset, string path)
public string Combine(String[] paths)
public string Combine(string path1, string path2, string path3)
public string Combine(string path1, string path2, string path3, string path4)
internal void Validate(string path)
internal void Validate(string path, string parameterName)
internal string get_DirectorySeparatorCharAsString()
internal Char[] get_TrimEndChars()
internal void CheckSearchPattern(string searchPattern)
internal void CheckInvalidPathChars(string path, bool checkAdditional)
internal string InternalCombine(string path1, string path2)
}
internal System.IO.PathInternal : object {
public bool IsPartiallyQualified(string path)
public bool HasIllegalCharacters(string path, bool checkAdditional)
}
public System.IO.PathTooLongException : IOException {
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
protected void .ctor(SerializationInfo info, StreamingContext context)
}
internal System.IO.PinnedBufferMemoryStream : UnmanagedMemoryStream {
private Byte[] _array
private GCHandle _pinningHandle
internal void .ctor(Byte[] array)
protected void Finalize()
protected void Dispose(bool disposing)
}
public System.IO.SearchOption : Enum {
public int value__
public SearchOption TopDirectoryOnly
public SearchOption AllDirectories
}
internal System.IO.SearchPattern : object {
internal Char[] WildcardChars
}
internal System.IO.SearchResult : object {
private string fullPath
private string userPath
private WIN32_FIND_DATA findData
internal string FullPath
internal string UserPath
internal WIN32_FIND_DATA FindData
internal void .ctor(string fullPath, string userPath, WIN32_FIND_DATA findData)
internal string get_FullPath()
internal string get_UserPath()
internal WIN32_FIND_DATA get_FindData()
}
internal System.IO.SearchResultHandler`1 : object {
internal bool IsResultIncluded(SearchResult result)
internal TSource CreateObject(SearchResult result)
}
public System.IO.SeekOrigin : Enum {
public int value__
public SeekOrigin Begin
public SeekOrigin Current
public SeekOrigin End
}
public System.IO.Stream : MarshalByRefObject {
public Stream Null
private int _DefaultCopyBufferSize
private ReadWriteTask _activeReadWriteTask
private SemaphoreSlim _asyncActiveSemaphore
public bool CanRead
public bool CanSeek
public bool CanTimeout
public bool CanWrite
public long Length
public long Position
public int ReadTimeout
public int WriteTimeout
internal SemaphoreSlim EnsureAsyncActiveSemaphoreInitialized()
public bool get_CanRead()
public bool get_CanSeek()
public bool get_CanTimeout()
public bool get_CanWrite()
public long get_Length()
public long get_Position()
public void set_Position(long value)
public int get_ReadTimeout()
public void set_ReadTimeout(int value)
public int get_WriteTimeout()
public void set_WriteTimeout(int value)
public Task CopyToAsync(Stream destination)
public Task CopyToAsync(Stream destination, int bufferSize)
public Task CopyToAsync(Stream destination, int bufferSize, CancellationToken cancellationToken)
private Task CopyToAsyncInternal(Stream destination, int bufferSize, CancellationToken cancellationToken)
public void CopyTo(Stream destination)
public void CopyTo(Stream destination, int bufferSize)
private void InternalCopyTo(Stream destination, int bufferSize)
public void Close()
public void Dispose()
protected void Dispose(bool disposing)
public void Flush()
public Task FlushAsync()
public Task FlushAsync(CancellationToken cancellationToken)
protected WaitHandle CreateWaitHandle()
public IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state)
internal IAsyncResult BeginReadInternal(Byte[] buffer, int offset, int count, AsyncCallback callback, object state, bool serializeAsynchronously)
public int EndRead(IAsyncResult asyncResult)
public Task`1<int> ReadAsync(Byte[] buffer, int offset, int count)
public Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken)
private Task`1<int> BeginEndReadAsync(Byte[] buffer, int offset, int count)
public IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state)
internal IAsyncResult BeginWriteInternal(Byte[] buffer, int offset, int count, AsyncCallback callback, object state, bool serializeAsynchronously)
private void RunReadWriteTaskWhenReady(Task asyncWaiter, ReadWriteTask readWriteTask)
private void RunReadWriteTask(ReadWriteTask readWriteTask)
public void EndWrite(IAsyncResult asyncResult)
public Task WriteAsync(Byte[] buffer, int offset, int count)
public Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken)
private Task BeginEndWriteAsync(Byte[] buffer, int offset, int count)
public long Seek(long offset, SeekOrigin origin)
public void SetLength(long value)
public int Read(Byte[] buffer, int offset, int count)
public int ReadByte()
public void Write(Byte[] buffer, int offset, int count)
public void WriteByte(byte value)
public Stream Synchronized(Stream stream)
protected void ObjectInvariant()
internal IAsyncResult BlockingBeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state)
internal int BlockingEndRead(IAsyncResult asyncResult)
internal IAsyncResult BlockingBeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state)
internal void BlockingEndWrite(IAsyncResult asyncResult)
public int Read(Span`1<byte> destination)
public void Write(ReadOnlySpan`1<byte> source)
public ValueTask`1<int> ReadAsync(Memory`1<byte> destination, CancellationToken cancellationToken)
public Task WriteAsync(ReadOnlyMemory`1<byte> source, CancellationToken cancellationToken)
}
public System.IO.StreamReader : TextReader {
public StreamReader Null
private int DefaultFileStreamBufferSize
private int MinBufferSize
private Stream stream
private Encoding encoding
private Decoder decoder
private Byte[] byteBuffer
private Char[] charBuffer
private Byte[] _preamble
private int charPos
private int charLen
private int byteLen
private int bytePos
private int _maxCharsPerBuffer
private bool _detectEncoding
private bool _checkPreamble
private bool _isBlocked
private bool _closable
private Task modreq(System.Runtime.CompilerServices.IsVolatile) _asyncReadTask
internal int DefaultBufferSize
public Encoding CurrentEncoding
public Stream BaseStream
internal bool LeaveOpen
public bool EndOfStream
private int CharLen_Prop
private int CharPos_Prop
private int ByteLen_Prop
private int BytePos_Prop
private Byte[] Preamble_Prop
private bool CheckPreamble_Prop
private Decoder Decoder_Prop
private bool DetectEncoding_Prop
private Char[] CharBuffer_Prop
private Byte[] ByteBuffer_Prop
private bool IsBlocked_Prop
private Stream Stream_Prop
private int MaxCharsPerBuffer_Prop
internal int get_DefaultBufferSize()
private void CheckAsyncTaskInProgress()
public void .ctor(Stream stream)
public void .ctor(Stream stream, bool detectEncodingFromByteOrderMarks)
public void .ctor(Stream stream, Encoding encoding)
public void .ctor(Stream stream, Encoding encoding, bool detectEncodingFromByteOrderMarks)
public void .ctor(Stream stream, Encoding encoding, bool detectEncodingFromByteOrderMarks, int bufferSize)
public void .ctor(Stream stream, Encoding encoding, bool detectEncodingFromByteOrderMarks, int bufferSize, bool leaveOpen)
public void .ctor(string path)
public void .ctor(string path, bool detectEncodingFromByteOrderMarks)
public void .ctor(string path, Encoding encoding)
public void .ctor(string path, Encoding encoding, bool detectEncodingFromByteOrderMarks)
public void .ctor(string path, Encoding encoding, bool detectEncodingFromByteOrderMarks, int bufferSize)
internal void .ctor(string path, Encoding encoding, bool detectEncodingFromByteOrderMarks, int bufferSize, bool checkHost)
private void Init(Stream stream, Encoding encoding, bool detectEncodingFromByteOrderMarks, int bufferSize, bool leaveOpen)
internal void Init(Stream stream)
public void Close()
protected void Dispose(bool disposing)
public Encoding get_CurrentEncoding()
public Stream get_BaseStream()
internal bool get_LeaveOpen()
public void DiscardBufferedData()
public bool get_EndOfStream()
public int Peek()
internal bool DataAvailable()
public int Read()
public int Read(Char[] buffer, int index, int count)
public string ReadToEnd()
public int ReadBlock(Char[] buffer, int index, int count)
private void CompressBuffer(int n)
private void DetectEncoding()
private bool IsPreamble()
internal int ReadBuffer()
private int ReadBuffer(Char[] userBuffer, int userOffset, int desiredChars, Boolean& readToUserBuffer)
public string ReadLine()
public Task`1<string> ReadLineAsync()
private Task`1<string> ReadLineAsyncInternal()
public Task`1<string> ReadToEndAsync()
private Task`1<string> ReadToEndAsyncInternal()
public Task`1<int> ReadAsync(Char[] buffer, int index, int count)
internal Task`1<int> ReadAsyncInternal(Char[] buffer, int index, int count)
public Task`1<int> ReadBlockAsync(Char[] buffer, int index, int count)
private int get_CharLen_Prop()
private void set_CharLen_Prop(int value)
private int get_CharPos_Prop()
private void set_CharPos_Prop(int value)
private int get_ByteLen_Prop()
private void set_ByteLen_Prop(int value)
private int get_BytePos_Prop()
private void set_BytePos_Prop(int value)
private Byte[] get_Preamble_Prop()
private bool get_CheckPreamble_Prop()
private Decoder get_Decoder_Prop()
private bool get_DetectEncoding_Prop()
private Char[] get_CharBuffer_Prop()
private Byte[] get_ByteBuffer_Prop()
private bool get_IsBlocked_Prop()
private void set_IsBlocked_Prop(bool value)
private Stream get_Stream_Prop()
private int get_MaxCharsPerBuffer_Prop()
private Task`1<int> ReadBufferAsync()
}
public System.IO.StreamWriter : TextWriter {
internal int DefaultBufferSize
private int DefaultFileStreamBufferSize
private int MinBufferSize
private int DontCopyOnWriteLineThreshold
public StreamWriter Null
private Stream stream
private Encoding encoding
private Encoder encoder
private Byte[] byteBuffer
private Char[] charBuffer
private int charPos
private int charLen
private bool autoFlush
private bool haveWrittenPreamble
private bool closable
private Task modreq(System.Runtime.CompilerServices.IsVolatile) _asyncWriteTask
private Encoding modreq(System.Runtime.CompilerServices.IsVolatile) _UTF8NoBOM
internal Encoding UTF8NoBOM
public bool AutoFlush
public Stream BaseStream
internal bool LeaveOpen
internal bool HaveWrittenPreamble
public Encoding Encoding
private int CharPos_Prop
private bool HaveWrittenPreamble_Prop
private void CheckAsyncTaskInProgress()
internal Encoding get_UTF8NoBOM()
public void .ctor(Stream stream)
public void .ctor(Stream stream, Encoding encoding)
public void .ctor(Stream stream, Encoding encoding, int bufferSize)
public void .ctor(Stream stream, Encoding encoding, int bufferSize, bool leaveOpen)
public void .ctor(string path)
public void .ctor(string path, bool append)
public void .ctor(string path, bool append, Encoding encoding)
public void .ctor(string path, bool append, Encoding encoding, int bufferSize)
internal void .ctor(string path, bool append, Encoding encoding, int bufferSize, bool checkHost)
private void Init(Stream streamArg, Encoding encodingArg, int bufferSize, bool shouldLeaveOpen)
private Stream CreateFile(string path, bool append, bool checkHost)
public void Close()
protected void Dispose(bool disposing)
public void Flush()
private void Flush(bool flushStream, bool flushEncoder)
public bool get_AutoFlush()
public void set_AutoFlush(bool value)
public Stream get_BaseStream()
internal bool get_LeaveOpen()
internal void set_HaveWrittenPreamble(bool value)
public Encoding get_Encoding()
public void Write(char value)
public void Write(Char[] buffer)
public void Write(Char[] buffer, int index, int count)
public void Write(string value)
public Task WriteAsync(char value)
private Task WriteAsyncInternal(StreamWriter _this, char value, Char[] charBuffer, int charPos, int charLen, Char[] coreNewLine, bool autoFlush, bool appendNewLine)
public Task WriteAsync(string value)
private Task WriteAsyncInternal(StreamWriter _this, string value, Char[] charBuffer, int charPos, int charLen, Char[] coreNewLine, bool autoFlush, bool appendNewLine)
public Task WriteAsync(Char[] buffer, int index, int count)
private Task WriteAsyncInternal(StreamWriter _this, Char[] buffer, int index, int count, Char[] charBuffer, int charPos, int charLen, Char[] coreNewLine, bool autoFlush, bool appendNewLine)
public Task WriteLineAsync()
public Task WriteLineAsync(char value)
public Task WriteLineAsync(string value)
public Task WriteLineAsync(Char[] buffer, int index, int count)
public Task FlushAsync()
private void set_CharPos_Prop(int value)
private void set_HaveWrittenPreamble_Prop(bool value)
private Task FlushAsyncInternal(bool flushStream, bool flushEncoder, Char[] sCharBuffer, int sCharPos)
private Task FlushAsyncInternal(StreamWriter _this, bool flushStream, bool flushEncoder, Char[] charBuffer, int charPos, bool haveWrittenPreamble, Encoding encoding, Encoder encoder, Byte[] byteBuffer, Stream stream)
}
public System.IO.StringReader : TextReader {
private string _s
private int _pos
private int _length
public void .ctor(string s)
public void Close()
protected void Dispose(bool disposing)
public int Peek()
public int Read()
public int Read(Char[] buffer, int index, int count)
public string ReadToEnd()
public string ReadLine()
public Task`1<string> ReadLineAsync()
public Task`1<string> ReadToEndAsync()
public Task`1<int> ReadBlockAsync(Char[] buffer, int index, int count)
public Task`1<int> ReadAsync(Char[] buffer, int index, int count)
}
internal System.IO.StringResultHandler : SearchResultHandler`1<string> {
private bool _includeFiles
private bool _includeDirs
internal void .ctor(bool includeFiles, bool includeDirs)
internal bool IsResultIncluded(SearchResult result)
internal string CreateObject(SearchResult result)
}
public System.IO.StringWriter : TextWriter {
private UnicodeEncoding modreq(System.Runtime.CompilerServices.IsVolatile) m_encoding
private StringBuilder _sb
private bool _isOpen
public Encoding Encoding
public void .ctor(IFormatProvider formatProvider)
public void .ctor(StringBuilder sb)
public void .ctor(StringBuilder sb, IFormatProvider formatProvider)
public void Close()
protected void Dispose(bool disposing)
public Encoding get_Encoding()
public StringBuilder GetStringBuilder()
public void Write(char value)
public void Write(Char[] buffer, int index, int count)
public void Write(string value)
public Task WriteAsync(char value)
public Task WriteAsync(string value)
public Task WriteAsync(Char[] buffer, int index, int count)
public Task WriteLineAsync(char value)
public Task WriteLineAsync(string value)
public Task WriteLineAsync(Char[] buffer, int index, int count)
public Task FlushAsync()
public string ToString()
}
public System.IO.TextReader : MarshalByRefObject {
private Func`2<object, string> _ReadLineDelegate
private Func`2<object, int> _ReadDelegate
public TextReader Null
public void Close()
public void Dispose()
protected void Dispose(bool disposing)
public int Peek()
public int Read()
public int Read(Char[] buffer, int index, int count)
public string ReadToEnd()
public int ReadBlock(Char[] buffer, int index, int count)
public string ReadLine()
public Task`1<string> ReadLineAsync()
public Task`1<string> ReadToEndAsync()
public Task`1<int> ReadAsync(Char[] buffer, int index, int count)
internal Task`1<int> ReadAsyncInternal(Char[] buffer, int index, int count)
public Task`1<int> ReadBlockAsync(Char[] buffer, int index, int count)
private Task`1<int> ReadBlockAsyncInternal(Char[] buffer, int index, int count)
public TextReader Synchronized(TextReader reader)
}
public System.IO.TextWriter : MarshalByRefObject {
public TextWriter Null
private Action`1<object> _WriteCharDelegate
private Action`1<object> _WriteStringDelegate
private Action`1<object> _WriteCharArrayRangeDelegate
private Action`1<object> _WriteLineCharDelegate
private Action`1<object> _WriteLineStringDelegate
private Action`1<object> _WriteLineCharArrayRangeDelegate
private Action`1<object> _FlushDelegate
protected Char[] CoreNewLine
private IFormatProvider InternalFormatProvider
private string InitialNewLine
public IFormatProvider FormatProvider
public Encoding Encoding
public string NewLine
private string get_InitialNewLine()
protected void .ctor(IFormatProvider formatProvider)
public IFormatProvider get_FormatProvider()
public void Close()
protected void Dispose(bool disposing)
public void Dispose()
public void Flush()
public Encoding get_Encoding()
public string get_NewLine()
public void set_NewLine(string value)
public TextWriter Synchronized(TextWriter writer)
public void Write(char value)
public void Write(Char[] buffer)
public void Write(Char[] buffer, int index, int count)
public void Write(bool value)
public void Write(int value)
public void Write(UInt32 value)
public void Write(long value)
public void Write(ulong value)
public void Write(float value)
public void Write(double value)
public void Write(decimal value)
public void Write(string value)
public void Write(object value)
public void Write(string format, object arg0)
public void Write(string format, object arg0, object arg1)
public void Write(string format, object arg0, object arg1, object arg2)
public void Write(string format, Object[] arg)
public void WriteLine()
public void WriteLine(char value)
public void WriteLine(Char[] buffer)
public void WriteLine(Char[] buffer, int index, int count)
public void WriteLine(bool value)
public void WriteLine(int value)
public void WriteLine(UInt32 value)
public void WriteLine(long value)
public void WriteLine(ulong value)
public void WriteLine(float value)
public void WriteLine(double value)
public void WriteLine(decimal value)
public void WriteLine(string value)
public void WriteLine(object value)
public void WriteLine(string format, object arg0)
public void WriteLine(string format, object arg0, object arg1)
public void WriteLine(string format, object arg0, object arg1, object arg2)
public void WriteLine(string format, Object[] arg)
public Task WriteAsync(char value)
public Task WriteAsync(string value)
public Task WriteAsync(Char[] buffer)
public Task WriteAsync(Char[] buffer, int index, int count)
public Task WriteLineAsync(char value)
public Task WriteLineAsync(string value)
public Task WriteLineAsync(Char[] buffer)
public Task WriteLineAsync(Char[] buffer, int index, int count)
public Task WriteLineAsync()
public Task FlushAsync()
}
internal System.IO.UnexceptionalStreamReader : StreamReader {
private Boolean[] newline
private char newlineChar
public void .ctor(Stream stream, Encoding encoding)
public int Peek()
public int Read()
public int Read(Char[] dest_buffer, int index, int count)
private bool CheckEOL(char current)
public string ReadLine()
public string ReadToEnd()
}
internal System.IO.UnexceptionalStreamWriter : StreamWriter {
public void .ctor(Stream stream, Encoding encoding)
public void Flush()
public void Write(Char[] buffer, int index, int count)
public void Write(char value)
public void Write(Char[] value)
public void Write(string value)
}
public System.IO.UnmanagedMemoryAccessor : object {
private SafeBuffer _buffer
private long _offset
private long _capacity
private FileAccess _access
private bool _isOpen
private bool _canRead
private bool _canWrite
public long Capacity
public bool CanRead
public bool CanWrite
protected bool IsOpen
public void .ctor(SafeBuffer buffer, long offset, long capacity)
public void .ctor(SafeBuffer buffer, long offset, long capacity, FileAccess access)
protected void Initialize(SafeBuffer buffer, long offset, long capacity, FileAccess access)
public long get_Capacity()
public bool get_CanRead()
public bool get_CanWrite()
protected void Dispose(bool disposing)
public void Dispose()
protected bool get_IsOpen()
public bool ReadBoolean(long position)
public byte ReadByte(long position)
public char ReadChar(long position)
public short ReadInt16(long position)
public int ReadInt32(long position)
public long ReadInt64(long position)
public decimal ReadDecimal(long position)
public float ReadSingle(long position)
public double ReadDouble(long position)
public sbyte ReadSByte(long position)
public ushort ReadUInt16(long position)
public UInt32 ReadUInt32(long position)
public ulong ReadUInt64(long position)
public void Read(long position, T& structure)
public int ReadArray(long position, T[] array, int offset, int count)
public void Write(long position, bool value)
public void Write(long position, byte value)
public void Write(long position, char value)
public void Write(long position, short value)
public void Write(long position, int value)
public void Write(long position, long value)
public void Write(long position, decimal value)
public void Write(long position, float value)
public void Write(long position, double value)
public void Write(long position, sbyte value)
public void Write(long position, ushort value)
public void Write(long position, UInt32 value)
public void Write(long position, ulong value)
public void Write(long position, T& structure)
public void WriteArray(long position, T[] array, int offset, int count)
private byte InternalReadByte(long position)
private void InternalWrite(long position, byte value)
private void EnsureSafeToRead(long position, int sizeOfType)
private void EnsureSafeToWrite(long position, int sizeOfType)
}
public System.IO.UnmanagedMemoryStream : Stream {
private long UnmanagedMemStreamMaxLength
private SafeBuffer _buffer
private Byte* _mem
private long _length
private long _capacity
private long _position
private long _offset
private FileAccess _access
internal bool _isOpen
private Task`1<int> _lastReadTask
public bool CanRead
public bool CanSeek
public bool CanWrite
public long Length
public long Capacity
public long Position
public Byte* PositionPointer
internal Byte* Pointer
public void .ctor(SafeBuffer buffer, long offset, long length)
public void .ctor(SafeBuffer buffer, long offset, long length, FileAccess access)
internal void .ctor(SafeBuffer buffer, long offset, long length, FileAccess access, bool skipSecurityCheck)
protected void Initialize(SafeBuffer buffer, long offset, long length, FileAccess access)
internal void Initialize(SafeBuffer buffer, long offset, long length, FileAccess access, bool skipSecurityCheck)
public void .ctor(Byte* pointer, long length)
public void .ctor(Byte* pointer, long length, long capacity, FileAccess access)
internal void .ctor(Byte* pointer, long length, long capacity, FileAccess access, bool skipSecurityCheck)
protected void Initialize(Byte* pointer, long length, long capacity, FileAccess access)
internal void Initialize(Byte* pointer, long length, long capacity, FileAccess access, bool skipSecurityCheck)
public bool get_CanRead()
public bool get_CanSeek()
public bool get_CanWrite()
protected void Dispose(bool disposing)
public void Flush()
public Task FlushAsync(CancellationToken cancellationToken)
public long get_Length()
public long get_Capacity()
public long get_Position()
public void set_Position(long value)
public Byte* get_PositionPointer()
public void set_PositionPointer(Byte* value)
internal Byte* get_Pointer()
public int Read(Byte[] buffer, int offset, int count)
public Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken)
public int ReadByte()
public long Seek(long offset, SeekOrigin loc)
public void SetLength(long value)
public void Write(Byte[] buffer, int offset, int count)
public Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken)
public void WriteByte(byte value)
}
internal System.IO.UnmanagedMemoryStreamWrapper : MemoryStream {
private UnmanagedMemoryStream _unmanagedStream
public bool CanRead
public bool CanSeek
public bool CanWrite
public int Capacity
public long Length
public long Position
internal void .ctor(UnmanagedMemoryStream stream)
public bool get_CanRead()
public bool get_CanSeek()
public bool get_CanWrite()
protected void Dispose(bool disposing)
public void Flush()
public Byte[] GetBuffer()
public bool TryGetBuffer(ArraySegment`1& buffer)
public int get_Capacity()
public void set_Capacity(int value)
public long get_Length()
public long get_Position()
public void set_Position(long value)
public int Read(Byte[] buffer, int offset, int count)
public int ReadByte()
public long Seek(long offset, SeekOrigin loc)
public Byte[] ToArray()
public void Write(Byte[] buffer, int offset, int count)
public void WriteByte(byte value)
public void WriteTo(Stream stream)
public void SetLength(long value)
public Task CopyToAsync(Stream destination, int bufferSize, CancellationToken cancellationToken)
public Task FlushAsync(CancellationToken cancellationToken)
public Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken)
public Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken)
}
public System.IObservable`1 {
public IDisposable Subscribe(IObserver`1<T> observer)
}
public System.IObserver`1 {
public void OnNext(T value)
public void OnError(Exception error)
public void OnCompleted()
}
public System.IProgress`1 {
public void Report(T value)
}
internal System.IRuntimeMethodInfo {
public RuntimeMethodHandleInternal Value
public RuntimeMethodHandleInternal get_Value()
}
public System.IServiceProvider {
public object GetService(Type serviceType)
}
internal System.ITupleInternal {
public string ToString(StringBuilder sb)
public int GetHashCode(IEqualityComparer comparer)
}
internal System.IValueTupleInternal {
public int GetHashCode(IEqualityComparer comparer)
public string ToStringEnd()
}
internal System.KnownTerminals : object {
public Byte[] linux
public Byte[] xterm
public Byte[] ansi
public Byte[] get_linux()
public Byte[] get_xterm()
public Byte[] get_ansi()
}
public System.Lazy`1 : object {
private Func`1<T> ALREADY_INVOKED_SENTINEL
private object m_boxed
private Func`1<T> m_valueFactory
private object m_threadSafeObj
internal T ValueForDebugDisplay
internal LazyThreadSafetyMode Mode
internal bool IsValueFaulted
public bool IsValueCreated
public T Value
public void .ctor(Func`1<T> valueFactory)
public void .ctor(bool isThreadSafe)
public void .ctor(LazyThreadSafetyMode mode)
public void .ctor(Func`1<T> valueFactory, bool isThreadSafe)
public void .ctor(Func`1<T> valueFactory, LazyThreadSafetyMode mode)
private object GetObjectFromMode(LazyThreadSafetyMode mode)
private void OnSerializing(StreamingContext context)
public string ToString()
internal T get_ValueForDebugDisplay()
internal LazyThreadSafetyMode get_Mode()
internal bool get_IsValueFaulted()
public bool get_IsValueCreated()
public T get_Value()
private T LazyInitValue()
private Boxed<T> CreateValue()
}
internal System.LazyHelpers : object {
internal object PUBLICATION_ONLY_SENTINEL
}
public System.LoaderOptimization : Enum {
public int value__
public LoaderOptimization NotSpecified
public LoaderOptimization SingleDomain
public LoaderOptimization MultiDomain
public LoaderOptimization MultiDomainHost
public LoaderOptimization DomainMask
public LoaderOptimization DisallowBindings
}
public System.LoaderOptimizationAttribute : Attribute {
internal byte _val
public LoaderOptimization Value
public void .ctor(byte value)
public void .ctor(LoaderOptimization value)
public LoaderOptimization get_Value()
}
internal System.LocalDataStore : object {
private LocalDataStoreElement[] m_DataTable
private LocalDataStoreMgr m_Manager
public void .ctor(LocalDataStoreMgr mgr, int InitialCapacity)
internal void Dispose()
public object GetData(LocalDataStoreSlot slot)
public void SetData(LocalDataStoreSlot slot, object data)
internal void FreeData(int slot, long cookie)
private LocalDataStoreElement PopulateElement(LocalDataStoreSlot slot)
}
internal System.LocalDataStoreElement : object {
private object m_value
private long m_cookie
public object Value
public long Cookie
public void .ctor(long cookie)
public object get_Value()
public void set_Value(object value)
public long get_Cookie()
}
internal System.LocalDataStoreHolder : object {
private LocalDataStore m_Store
public LocalDataStore Store
public void .ctor(LocalDataStore store)
protected void Finalize()
public LocalDataStore get_Store()
}
internal System.LocalDataStoreMgr : object {
private int InitialSlotTableSize
private int SlotTableDoubleThreshold
private int LargeSlotTableSizeIncrease
private Boolean[] m_SlotInfoTable
private int m_FirstAvailableSlot
private List`1<LocalDataStore> m_ManagedLocalDataStores
private Dictionary`2<string, LocalDataStoreSlot> m_KeyToSlotMap
private long m_CookieGenerator
public LocalDataStoreHolder CreateLocalDataStore()
public void DeleteLocalDataStore(LocalDataStore store)
public LocalDataStoreSlot AllocateDataSlot()
public LocalDataStoreSlot AllocateNamedDataSlot(string name)
public LocalDataStoreSlot GetNamedDataSlot(string name)
public void FreeNamedDataSlot(string name)
internal void FreeDataSlot(int slot, long cookie)
public void ValidateSlot(LocalDataStoreSlot slot)
internal int GetSlotTableLength()
}
public System.LocalDataStoreSlot : object {
private LocalDataStoreMgr m_mgr
private int m_slot
private long m_cookie
internal LocalDataStoreMgr Manager
internal int Slot
internal long Cookie
internal void .ctor(LocalDataStoreMgr mgr, int slot, long cookie)
internal LocalDataStoreMgr get_Manager()
internal int get_Slot()
internal long get_Cookie()
protected void Finalize()
}
internal System.LogLevel : Enum {
public int value__
public LogLevel Trace
public LogLevel Status
public LogLevel Warning
public LogLevel Error
public LogLevel Panic
}
public System.MarshalByRefObject : object {
private ServerIdentity _identity
internal ServerIdentity ObjectIdentity
internal Identity GetObjectIdentity(MarshalByRefObject obj, Boolean& IsClient)
internal ServerIdentity get_ObjectIdentity()
internal void set_ObjectIdentity(ServerIdentity value)
public ObjRef CreateObjRef(Type requestedType)
public object GetLifetimeService()
public object InitializeLifetimeService()
protected MarshalByRefObject MemberwiseClone(bool cloneIdentity)
}
public System.Math : object {
private double doubleRoundLimit
private int maxRoundingDigits
private Double[] roundPower10Double
public double PI
public double E
public double Acos(double d)
public double Asin(double d)
public double Atan(double d)
public double Atan2(double y, double x)
public decimal Ceiling(decimal d)
public double Ceiling(double a)
public double Cos(double d)
public double Cosh(double value)
public decimal Floor(decimal d)
public double Floor(double d)
private double InternalRound(double value, int digits, MidpointRounding mode)
private double InternalTruncate(double d)
public double Sin(double a)
public double Tan(double a)
public double Sinh(double value)
public double Tanh(double value)
public double Round(double a)
public double Round(double value, int digits)
public double Round(double value, MidpointRounding mode)
public double Round(double value, int digits, MidpointRounding mode)
public decimal Round(decimal d)
public decimal Round(decimal d, int decimals)
public decimal Round(decimal d, MidpointRounding mode)
public decimal Round(decimal d, int decimals, MidpointRounding mode)
private double SplitFractionDouble(Double* value)
public decimal Truncate(decimal d)
public double Truncate(double d)
public double Sqrt(double d)
public double Log(double d)
public double Log10(double d)
public double Exp(double d)
public double Pow(double x, double y)
public double IEEERemainder(double x, double y)
public sbyte Abs(sbyte value)
private sbyte AbsHelper(sbyte value)
public short Abs(short value)
private short AbsHelper(short value)
public int Abs(int value)
private int AbsHelper(int value)
public long Abs(long value)
private long AbsHelper(long value)
public float Abs(float value)
public double Abs(double value)
public decimal Abs(decimal value)
public sbyte Max(sbyte val1, sbyte val2)
public byte Max(byte val1, byte val2)
public short Max(short val1, short val2)
public ushort Max(ushort val1, ushort val2)
public int Max(int val1, int val2)
public UInt32 Max(UInt32 val1, UInt32 val2)
public long Max(long val1, long val2)
public ulong Max(ulong val1, ulong val2)
public float Max(float val1, float val2)
public double Max(double val1, double val2)
public decimal Max(decimal val1, decimal val2)
public sbyte Min(sbyte val1, sbyte val2)
public byte Min(byte val1, byte val2)
public short Min(short val1, short val2)
public ushort Min(ushort val1, ushort val2)
public int Min(int val1, int val2)
public UInt32 Min(UInt32 val1, UInt32 val2)
public long Min(long val1, long val2)
public ulong Min(ulong val1, ulong val2)
public float Min(float val1, float val2)
public double Min(double val1, double val2)
public decimal Min(decimal val1, decimal val2)
public double Log(double a, double newBase)
public int Sign(sbyte value)
public int Sign(short value)
public int Sign(int value)
public int Sign(long value)
public int Sign(float value)
public int Sign(double value)
public int Sign(decimal value)
public long BigMul(int a, int b)
public int DivRem(int a, int b, Int32& result)
public long DivRem(long a, long b, Int64& result)
}
public System.MemberAccessException : SystemException {
public void .ctor(string message)
public void .ctor(string message, Exception inner)
protected void .ctor(SerializationInfo info, StreamingContext context)
}
public System.Memory`1 : ValueType {
private object _arrayOrOwnedMemory
private int _index
private int _length
private int RemoveOwnedFlagBitMask
private Memory`1<T> <Empty>k__BackingField
private string DebuggerDisplay
public Memory`1<T> Empty
public int Length
public bool IsEmpty
public Span`1<T> Span
public void .ctor(T[] array)
public void .ctor(T[] array, int start, int length)
internal void .ctor(OwnedMemory`1<T> owner, int index, int length)
private string get_DebuggerDisplay()
public Memory`1<T> op_Implicit(T[] array)
public Memory`1<T> op_Implicit(ArraySegment`1<T> arraySegment)
public ReadOnlyMemory`1<T> op_Implicit(Memory`1<T> memory)
public Memory`1<T> get_Empty()
public int get_Length()
public bool get_IsEmpty()
public Memory`1<T> Slice(int start)
public Memory`1<T> Slice(int start, int length)
public Span`1<T> get_Span()
public MemoryHandle Retain(bool pin)
public bool TryGetArray(ArraySegment`1& arraySegment)
public T[] ToArray()
public bool Equals(object obj)
public bool Equals(Memory`1<T> other)
public int GetHashCode()
private int CombineHashCodes(int left, int right)
private int CombineHashCodes(int h1, int h2, int h3)
}
internal System.MemoryDebugView`1 : object {
private ReadOnlyMemory`1<T> _memory
public T[] Items
public void .ctor(Memory`1<T> memory)
public void .ctor(ReadOnlyMemory`1<T> memory)
public T[] get_Items()
}
public System.MethodAccessException : MemberAccessException {
public void .ctor(string message)
public void .ctor(string message, Exception inner)
protected void .ctor(SerializationInfo info, StreamingContext context)
}
public System.MidpointRounding : Enum {
public int value__
public MidpointRounding ToEven
public MidpointRounding AwayFromZero
}
public System.MissingFieldException : MissingMemberException {
public string Message
public void .ctor(string message)
public void .ctor(string message, Exception inner)
protected void .ctor(SerializationInfo info, StreamingContext context)
public string get_Message()
private void .ctor(string className, string fieldName, Byte[] signature)
public void .ctor(string className, string fieldName)
}
public System.MissingMemberException : MemberAccessException {
protected string ClassName
protected string MemberName
protected Byte[] Signature
public string Message
public void .ctor(string message)
public void .ctor(string message, Exception inner)
protected void .ctor(SerializationInfo info, StreamingContext context)
public string get_Message()
internal string FormatSignature(Byte[] signature)
private void .ctor(string className, string memberName, Byte[] signature)
public void .ctor(string className, string memberName)
public void GetObjectData(SerializationInfo info, StreamingContext context)
}
public System.MissingMethodException : MissingMemberException {
private string signature
public string Message
public void .ctor(string message)
public void .ctor(string message, Exception inner)
protected void .ctor(SerializationInfo info, StreamingContext context)
public string get_Message()
private void .ctor(string className, string methodName, Byte[] signature)
public void .ctor(string className, string methodName)
private void .ctor(string className, string methodName, string signature, string message)
}
internal System.ModifierSpec {
public Type Resolve(Type type)
public StringBuilder Append(StringBuilder sb)
}
public System.ModuleHandle : ValueType {
private IntPtr value
public ModuleHandle EmptyHandle
internal IntPtr Value
public int MDStreamVersion
internal void .ctor(IntPtr v)
internal IntPtr get_Value()
public int get_MDStreamVersion()
internal void GetPEKind(PortableExecutableKinds& peKind, ImageFileMachine& machine)
public RuntimeFieldHandle ResolveFieldHandle(int fieldToken)
public RuntimeMethodHandle ResolveMethodHandle(int methodToken)
public RuntimeTypeHandle ResolveTypeHandle(int typeToken)
private IntPtr[] ptrs_from_handles(RuntimeTypeHandle[] handles)
public RuntimeTypeHandle ResolveTypeHandle(int typeToken, RuntimeTypeHandle[] typeInstantiationContext, RuntimeTypeHandle[] methodInstantiationContext)
public RuntimeMethodHandle ResolveMethodHandle(int methodToken, RuntimeTypeHandle[] typeInstantiationContext, RuntimeTypeHandle[] methodInstantiationContext)
public RuntimeFieldHandle ResolveFieldHandle(int fieldToken, RuntimeTypeHandle[] typeInstantiationContext, RuntimeTypeHandle[] methodInstantiationContext)
public RuntimeFieldHandle GetRuntimeFieldHandleFromMetadataToken(int fieldToken)
public RuntimeMethodHandle GetRuntimeMethodHandleFromMetadataToken(int methodToken)
public RuntimeTypeHandle GetRuntimeTypeHandleFromMetadataToken(int typeToken)
public bool Equals(object obj)
public bool Equals(ModuleHandle handle)
public int GetHashCode()
public bool op_Equality(ModuleHandle left, ModuleHandle right)
public bool op_Inequality(ModuleHandle left, ModuleHandle right)
}
internal System.MonoAsyncCall : object {
private object msg
private IntPtr cb_method
private object cb_target
private object state
private object res
private object out_args
}
internal System.MonoCQItem : object {
private Object[] array
private Byte[] array_state
private int head
private int tail
}
internal System.MonoCustomAttrs : object {
private Assembly corlib
private Dictionary`2<Type, AttributeUsageAttribute> usage_cache
private AttributeUsageAttribute DefaultAttributeUsage
private bool IsUserCattrProvider(object obj)
internal Object[] GetCustomAttributesInternal(ICustomAttributeProvider obj, Type attributeType, bool pseudoAttrs)
internal Object[] GetPseudoCustomAttributes(ICustomAttributeProvider obj, Type attributeType)
private Object[] GetPseudoCustomAttributes(Type type)
internal Object[] GetCustomAttributesBase(ICustomAttributeProvider obj, Type attributeType, bool inheritedOnly)
internal Object[] GetCustomAttributes(ICustomAttributeProvider obj, Type attributeType, bool inherit)
internal Object[] GetCustomAttributes(ICustomAttributeProvider obj, bool inherit)
private CustomAttributeData[] GetCustomAttributesDataInternal(ICustomAttributeProvider obj)
internal IList`1<CustomAttributeData> GetCustomAttributesData(ICustomAttributeProvider obj)
internal bool IsDefined(ICustomAttributeProvider obj, Type attributeType, bool inherit)
internal bool IsDefinedInternal(ICustomAttributeProvider obj, Type AttributeType)
private PropertyInfo GetBasePropertyDefinition(MonoProperty property)
private EventInfo GetBaseEventDefinition(MonoEvent evt)
private ICustomAttributeProvider GetBase(ICustomAttributeProvider obj)
private AttributeUsageAttribute RetrieveAttributeUsageNoCache(Type attributeType)
private AttributeUsageAttribute RetrieveAttributeUsage(Type attributeType)
}
internal System.MonoDocumentationNoteAttribute : MonoTODOAttribute {
public void .ctor(string comment)
}
internal System.MonoExtensionAttribute : MonoTODOAttribute {
public void .ctor(string comment)
}
internal System.MonoInternalNoteAttribute : MonoTODOAttribute {
public void .ctor(string comment)
}
internal System.MonoLimitationAttribute : MonoTODOAttribute {
public void .ctor(string comment)
}
internal System.MonoListItem : object {
private MonoListItem next
private object data
}
internal System.MonoNotSupportedAttribute : MonoTODOAttribute {
public void .ctor(string comment)
}
internal System.MonoTODOAttribute : Attribute {
private string comment
public string Comment
public void .ctor(string comment)
public string get_Comment()
}
internal System.MonoTypeInfo : object {
public string full_name
public MonoCMethod default_ctor
}
public System.MulticastDelegate : Delegate {
private Delegate[] delegates
internal bool HasSingleTarget
protected void .ctor(object target, string method)
protected void .ctor(Type target, string method)
public void GetObjectData(SerializationInfo info, StreamingContext context)
protected object DynamicInvokeImpl(Object[] args)
internal bool get_HasSingleTarget()
public bool Equals(object obj)
public int GetHashCode()
protected MethodInfo GetMethodImpl()
public Delegate[] GetInvocationList()
protected Delegate CombineImpl(Delegate follow)
private int LastIndexOf(Delegate[] haystack, Delegate[] needle)
protected Delegate RemoveImpl(Delegate value)
public bool op_Equality(MulticastDelegate d1, MulticastDelegate d2)
public bool op_Inequality(MulticastDelegate d1, MulticastDelegate d2)
}
public System.MulticastNotSupportedException : SystemException {
public void .ctor(string message)
public void .ctor(string message, Exception inner)
internal void .ctor(SerializationInfo info, StreamingContext context)
}
public System.NonSerializedAttribute : Attribute {
internal Attribute GetCustomAttribute(RuntimeFieldInfo field)
internal bool IsDefined(RuntimeFieldInfo field)
}
public System.NotFiniteNumberException : ArithmeticException {
private double _offendingNumber
public double OffendingNumber
public void .ctor(double offendingNumber)
public void .ctor(string message)
public void .ctor(string message, double offendingNumber)
public void .ctor(string message, Exception innerException)
public void .ctor(string message, double offendingNumber, Exception innerException)
protected void .ctor(SerializationInfo info, StreamingContext context)
public double get_OffendingNumber()
public void GetObjectData(SerializationInfo info, StreamingContext context)
}
public System.NotImplementedException : SystemException {
public void .ctor(string message)
public void .ctor(string message, Exception inner)
protected void .ctor(SerializationInfo info, StreamingContext context)
}
public System.NotSupportedException : SystemException {
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
protected void .ctor(SerializationInfo info, StreamingContext context)
}
public System.Nullable : object {
public int Compare(Nullable`1<T> n1, Nullable`1<T> n2)
public bool Equals(Nullable`1<T> n1, Nullable`1<T> n2)
public Type GetUnderlyingType(Type nullableType)
}
public System.Nullable`1 : ValueType {
internal T value
internal bool has_value
public bool HasValue
public T Value
public void .ctor(T value)
public bool get_HasValue()
public T get_Value()
public bool Equals(object other)
private bool Equals(Nullable`1<T> other)
public int GetHashCode()
public T GetValueOrDefault()
public T GetValueOrDefault(T defaultValue)
public string ToString()
public Nullable`1<T> op_Implicit(T value)
public T op_Explicit(Nullable`1<T> value)
private object Box(Nullable`1<T> o)
private Nullable`1<T> Unbox(object o)
}
internal System.NullConsoleDriver : object {
private ConsoleKeyInfo EmptyConsoleKeyInfo
public ConsoleColor BackgroundColor
public int BufferHeight
public int BufferWidth
public bool CapsLock
public int CursorLeft
public int CursorSize
public int CursorTop
public bool CursorVisible
public ConsoleColor ForegroundColor
public bool KeyAvailable
public bool Initialized
public int LargestWindowHeight
public int LargestWindowWidth
public bool NumberLock
public string Title
public bool TreatControlCAsInput
public int WindowHeight
public int WindowLeft
public int WindowTop
public int WindowWidth
public ConsoleColor get_BackgroundColor()
public void set_BackgroundColor(ConsoleColor value)
public int get_BufferHeight()
public void set_BufferHeight(int value)
public int get_BufferWidth()
public void set_BufferWidth(int value)
public bool get_CapsLock()
public int get_CursorLeft()
public void set_CursorLeft(int value)
public int get_CursorSize()
public void set_CursorSize(int value)
public int get_CursorTop()
public void set_CursorTop(int value)
public bool get_CursorVisible()
public void set_CursorVisible(bool value)
public ConsoleColor get_ForegroundColor()
public void set_ForegroundColor(ConsoleColor value)
public bool get_KeyAvailable()
public bool get_Initialized()
public int get_LargestWindowHeight()
public int get_LargestWindowWidth()
public bool get_NumberLock()
public string get_Title()
public void set_Title(string value)
public bool get_TreatControlCAsInput()
public void set_TreatControlCAsInput(bool value)
public int get_WindowHeight()
public void set_WindowHeight(int value)
public int get_WindowLeft()
public void set_WindowLeft(int value)
public int get_WindowTop()
public void set_WindowTop(int value)
public int get_WindowWidth()
public void set_WindowWidth(int value)
public void Beep(int frequency, int duration)
public void Clear()
public void MoveBufferArea(int sourceLeft, int sourceTop, int sourceWidth, int sourceHeight, int targetLeft, int targetTop, char sourceChar, ConsoleColor sourceForeColor, ConsoleColor sourceBackColor)
public void Init()
public string ReadLine()
public ConsoleKeyInfo ReadKey(bool intercept)
public void ResetColor()
public void SetBufferSize(int width, int height)
public void SetCursorPosition(int left, int top)
public void SetWindowPosition(int left, int top)
public void SetWindowSize(int width, int height)
}
public System.NullReferenceException : SystemException {
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
protected void .ctor(SerializationInfo info, StreamingContext context)
}
internal System.Number : object {
private int NumberMaxDigits
private int Int32Precision
private int UInt32Precision
private int Int64Precision
private int UInt64Precision
public bool NumberBufferToDecimal(Byte* number, Decimal& value)
internal bool NumberBufferToDouble(Byte* number, Double& value)
public string FormatDecimal(decimal value, string format, NumberFormatInfo info)
public string FormatDouble(double value, string format, NumberFormatInfo info)
public string FormatInt32(int value, string format, NumberFormatInfo info)
public string FormatUInt32(UInt32 value, string format, NumberFormatInfo info)
public string FormatInt64(long value, string format, NumberFormatInfo info)
public string FormatUInt64(ulong value, string format, NumberFormatInfo info)
public string FormatSingle(float value, string format, NumberFormatInfo info)
internal string FormatNumberBuffer(Byte* number, string format, NumberFormatInfo info, Char* allDigits)
private bool HexNumberToInt32(NumberBuffer& number, Int32& value)
private bool HexNumberToInt64(NumberBuffer& number, Int64& value)
private bool HexNumberToUInt32(NumberBuffer& number, UInt32& value)
private bool HexNumberToUInt64(NumberBuffer& number, UInt64& value)
private bool IsWhite(char ch)
private bool NumberToInt32(NumberBuffer& number, Int32& value)
private bool NumberToInt64(NumberBuffer& number, Int64& value)
private bool NumberToUInt32(NumberBuffer& number, UInt32& value)
private bool NumberToUInt64(NumberBuffer& number, UInt64& value)
private Char* MatchChars(Char* p, string str)
private Char* MatchChars(Char* p, Char* str)
internal decimal ParseDecimal(string value, NumberStyles options, NumberFormatInfo numfmt)
internal double ParseDouble(string value, NumberStyles options, NumberFormatInfo numfmt)
internal int ParseInt32(string s, NumberStyles style, NumberFormatInfo info)
internal long ParseInt64(string value, NumberStyles options, NumberFormatInfo numfmt)
private bool ParseNumber(Char*& str, NumberStyles options, NumberBuffer& number, StringBuilder sb, NumberFormatInfo numfmt, bool parseDecimal)
internal float ParseSingle(string value, NumberStyles options, NumberFormatInfo numfmt)
internal UInt32 ParseUInt32(string value, NumberStyles options, NumberFormatInfo numfmt)
internal ulong ParseUInt64(string value, NumberStyles options, NumberFormatInfo numfmt)
private void StringToNumber(string str, NumberStyles options, NumberBuffer& number, NumberFormatInfo info, bool parseDecimal)
private bool TrailingZeros(string s, int index)
internal bool TryParseDecimal(string value, NumberStyles options, NumberFormatInfo numfmt, Decimal& result)
internal bool TryParseDouble(string value, NumberStyles options, NumberFormatInfo numfmt, Double& result)
internal bool TryParseInt32(string s, NumberStyles style, NumberFormatInfo info, Int32& result)
internal bool TryParseInt64(string s, NumberStyles style, NumberFormatInfo info, Int64& result)
internal bool TryParseSingle(string value, NumberStyles options, NumberFormatInfo numfmt, Single& result)
internal bool TryParseUInt32(string s, NumberStyles style, NumberFormatInfo info, UInt32& result)
internal bool TryParseUInt64(string s, NumberStyles style, NumberFormatInfo info, UInt64& result)
internal bool TryStringToNumber(string str, NumberStyles options, NumberBuffer& number, NumberFormatInfo numfmt, bool parseDecimal)
internal bool TryStringToNumber(string str, NumberStyles options, NumberBuffer& number, StringBuilder sb, NumberFormatInfo numfmt, bool parseDecimal)
}
internal System.NumberFormatter : object {
private int DefaultExpPrecision
private int HundredMillion
private long SeventeenDigitsThreshold
private ulong ULongDivHundredMillion
private ulong ULongModHundredMillion
private int DoubleBitsExponentShift
private int DoubleBitsExponentMask
private long DoubleBitsMantissaMask
private int DecimalBitsScaleMask
private int SingleDefPrecision
private int DoubleDefPrecision
private int Int32DefPrecision
private int UInt32DefPrecision
private int Int64DefPrecision
private int UInt64DefPrecision
private int DecimalDefPrecision
private int TenPowersListLength
private double MinRoundtripVal
private double MaxRoundtripVal
private UInt64* MantissaBitsTable
private Int32* TensExponentTable
private Char* DigitLowerTable
private Char* DigitUpperTable
private Int64* TenPowersList
private Int32* DecHexDigits
private NumberFormatInfo _nfi
private Char[] _cbuf
private bool _NaN
private bool _infinity
private bool _isCustomFormat
private bool _specifierIsUpper
private bool _positive
private char _specifier
private int _precision
private int _defPrecision
private int _digitsLen
private int _offset
private int _decPointPos
private UInt32 _val1
private UInt32 _val2
private UInt32 _val3
private UInt32 _val4
private int _ind
private NumberFormatter threadNumberFormatter
private NumberFormatter userFormatProvider
private CultureInfo CurrentCulture
private int IntegerDigits
private int DecimalDigits
private bool IsFloatingSource
private bool IsZero
private bool IsZeroInteger
private void GetFormatterTables(UInt64*& MantissaBitsTable, Int32*& TensExponentTable, Char*& DigitLowerTable, Char*& DigitUpperTable, Int64*& TenPowersList, Int32*& DecHexDigits)
private long GetTenPowerOf(int i)
private void InitDecHexDigits(UInt32 value)
private void InitDecHexDigits(ulong value)
private void InitDecHexDigits(UInt32 hi, ulong lo)
private UInt32 FastToDecHex(int val)
private UInt32 ToDecHex(int val)
private int FastDecHexLen(int val)
private int DecHexLen(UInt32 val)
private int DecHexLen()
private int ScaleOrder(long hi)
private int InitialFloatingPrecision()
private int ParsePrecision(string format)
private void .ctor(Thread current)
private void Init(string format)
private void InitHex(ulong value)
private void Init(string format, int value, int defPrecision)
private void Init(string format, UInt32 value, int defPrecision)
private void Init(string format, long value)
private void Init(string format, ulong value)
private void Init(string format, double value, int defPrecision)
private void Init(string format, decimal value)
private void ResetCharBuf(int size)
private void Resize(int len)
private void Append(char c)
private void Append(char c, int cnt)
private void Append(string s)
private NumberFormatInfo GetNumberFormatInstance(IFormatProvider fp)
private void set_CurrentCulture(CultureInfo value)
private int get_IntegerDigits()
private int get_DecimalDigits()
private bool get_IsFloatingSource()
private bool get_IsZero()
private bool get_IsZeroInteger()
private void RoundPos(int pos)
private bool RoundDecimal(int decimals)
private bool RoundBits(int shift)
private void RemoveTrailingZeros()
private void AddOneToDecHex()
private UInt32 AddOneToDecHex(UInt32 val)
private int CountTrailingZeros()
private int CountTrailingZeros(UInt32 val)
private NumberFormatter GetInstance(IFormatProvider fp)
private void Release()
public string NumberToString(string format, UInt32 value, IFormatProvider fp)
public string NumberToString(string format, int value, IFormatProvider fp)
public string NumberToString(string format, ulong value, IFormatProvider fp)
public string NumberToString(string format, long value, IFormatProvider fp)
public string NumberToString(string format, float value, IFormatProvider fp)
public string NumberToString(string format, double value, IFormatProvider fp)
public string NumberToString(string format, decimal value, IFormatProvider fp)
private string IntegerToString(string format, IFormatProvider fp)
private string NumberToString(string format, NumberFormatInfo nfi)
private string FormatCurrency(int precision, NumberFormatInfo nfi)
private string FormatDecimal(int precision, NumberFormatInfo nfi)
private string FormatHexadecimal(int precision)
private string FormatFixedPoint(int precision, NumberFormatInfo nfi)
private string FormatRoundtrip(double origval, NumberFormatInfo nfi)
private string FormatRoundtrip(float origval, NumberFormatInfo nfi)
private string FormatGeneral(int precision, NumberFormatInfo nfi)
private string FormatNumber(int precision, NumberFormatInfo nfi)
private string FormatPercent(int precision, NumberFormatInfo nfi)
private string FormatExponential(int precision, NumberFormatInfo nfi)
private string FormatExponential(int precision, NumberFormatInfo nfi, int expDigits)
private string FormatCustom(string format, NumberFormatInfo nfi)
private void ZeroTrimEnd(StringBuilder sb, bool canEmpty)
private bool IsZeroOnly(StringBuilder sb)
private void AppendNonNegativeNumber(StringBuilder sb, int v)
private void AppendIntegerString(int minLength, StringBuilder sb)
private void AppendIntegerString(int minLength)
private void AppendDecimalString(int precision, StringBuilder sb)
private void AppendDecimalString(int precision)
private void AppendIntegerStringWithGroupSeparator(Int32[] groups, string groupSeparator)
private void AppendExponent(NumberFormatInfo nfi, int exponent, int minDigits)
private void AppendOneDigit(int start)
private void AppendDigits(int start, int end)
private void AppendDigits(int start, int end, StringBuilder sb)
private void Multiply10(int count)
private void Divide10(int count)
private NumberFormatter GetClone()
}
internal System.Numerics.Hashing.HashHelpers : object {
public int RandomSeed
public int Combine(int h1, int h2)
}
public System.Object {
public bool Equals(object obj)
public bool Equals(object objA, object objB)
protected void Finalize()
public int GetHashCode()
public Type GetType()
protected object MemberwiseClone()
public string ToString()
public bool ReferenceEquals(object objA, object objB)
internal int InternalGetHashCode(object o)
private void FieldGetter(string typeName, string fieldName, Object& val)
private void FieldSetter(string typeName, string fieldName, object val)
}
public System.ObjectDisposedException : InvalidOperationException {
private string objectName
public string Message
public string ObjectName
public void .ctor(string objectName)
public void .ctor(string objectName, string message)
public void .ctor(string message, Exception innerException)
public string get_Message()
public string get_ObjectName()
protected void .ctor(SerializationInfo info, StreamingContext context)
public void GetObjectData(SerializationInfo info, StreamingContext context)
}
public System.ObsoleteAttribute : Attribute {
private string _message
private bool _error
public string Message
public bool IsError
public void .ctor(string message)
public void .ctor(string message, bool error)
public string get_Message()
public bool get_IsError()
}
public System.OperatingSystem : object {
private PlatformID _platform
private Version _version
private string _servicePack
public PlatformID Platform
public Version Version
public string ServicePack
public string VersionString
public void .ctor(PlatformID platform, Version version)
private void .ctor(SerializationInfo information, StreamingContext context)
public PlatformID get_Platform()
public Version get_Version()
public string get_ServicePack()
public string get_VersionString()
public object Clone()
public void GetObjectData(SerializationInfo info, StreamingContext context)
public string ToString()
}
public System.OperationCanceledException : SystemException {
private CancellationToken _cancellationToken
public CancellationToken CancellationToken
public CancellationToken get_CancellationToken()
private void set_CancellationToken(CancellationToken value)
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
public void .ctor(CancellationToken token)
public void .ctor(string message, CancellationToken token)
public void .ctor(string message, Exception innerException, CancellationToken token)
protected void .ctor(SerializationInfo info, StreamingContext context)
}
internal System.OrdinalComparer : StringComparer {
private bool _ignoreCase
internal void .ctor(bool ignoreCase)
public int Compare(string x, string y)
public bool Equals(string x, string y)
public int GetHashCode(string obj)
public bool Equals(object obj)
public int GetHashCode()
}
public System.OutOfMemoryException : SystemException {
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
protected void .ctor(SerializationInfo info, StreamingContext context)
}
public System.OverflowException : ArithmeticException {
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
protected void .ctor(SerializationInfo info, StreamingContext context)
}
internal System.ParameterizedStrings : object {
private LowLevelStack _cachedStack
public string Evaluate(string format, FormatParam[] args)
private string EvaluateInternal(string format, Int32& pos, FormatParam[] args, LowLevelStack stack, FormatParam[]& dynamicVars, FormatParam[]& staticVars)
private bool AsBool(int i)
private int AsInt(bool b)
private string StringFromAsciiBytes(Byte[] buffer, int offset, int length)
private int snprintf(Byte* str, IntPtr size, string format, string arg1)
private int snprintf(Byte* str, IntPtr size, string format, int arg1)
private string FormatPrintF(string format, object arg)
private FormatParam[] GetDynamicOrStaticVariables(char c, FormatParam[]& dynamicVars, FormatParam[]& staticVars, Int32& index)
}
internal System.ParamsArray : ValueType {
private Object[] oneArgArray
private Object[] twoArgArray
private Object[] threeArgArray
private object arg0
private object arg1
private object arg2
private Object[] args
public int Length
public object Item
public void .ctor(object arg0)
public void .ctor(object arg0, object arg1)
public void .ctor(object arg0, object arg1, object arg2)
public void .ctor(Object[] args)
public int get_Length()
public object get_Item(int index)
private object GetAtSlow(int index)
}
internal System.ParseFailureKind : Enum {
public int value__
public ParseFailureKind None
public ParseFailureKind ArgumentNull
public ParseFailureKind Format
public ParseFailureKind FormatWithParameter
public ParseFailureKind FormatBadDateTimeCalendar
}
internal System.ParseFlags : Enum {
public int value__
public ParseFlags HaveYear
public ParseFlags HaveMonth
public ParseFlags HaveDay
public ParseFlags HaveHour
public ParseFlags HaveMinute
public ParseFlags HaveSecond
public ParseFlags HaveTime
public ParseFlags HaveDate
public ParseFlags TimeZoneUsed
public ParseFlags TimeZoneUtc
public ParseFlags ParsedMonthName
public ParseFlags CaptureOffset
public ParseFlags YearDefault
public ParseFlags Rfc1123Pattern
public ParseFlags UtcSortPattern
}
internal System.ParseNumbers : object {
internal int PrintAsI1
internal int PrintAsI2
internal int TreatAsUnsigned
internal int TreatAsI1
internal int TreatAsI2
internal int IsTight
internal int NoSpace
private ulong base16MaxOverflowFreeValue
private ulong longMinValue
public int StringToInt(string value, int fromBase, int flags)
public int StringToInt(string value, int fromBase, int flags, Int32* parsePos)
public string LongToString(long value, int toBase, int width, char paddingChar, int flags)
public long StringToLong(string value, int fromBase, int flags)
public long StringToLong(string value, int fromBase, int flags, Int32* parsePos)
public string IntToString(int value, int toBase, int width, char paddingChar, int flags)
private void EndianSwap(Byte[]& value)
private StringBuilder ConvertToBase2(Byte[] value)
private StringBuilder ConvertToBase8(Byte[] value)
private StringBuilder ConvertToBase16(Byte[] value)
}
internal System.ParsingInfo : ValueType {
internal Calendar calendar
internal int dayOfWeek
internal TM timeMark
internal bool fUseHour12
internal bool fUseTwoDigitYear
internal bool fAllowInnerWhite
internal bool fAllowTrailingWhite
internal bool fCustomNumberParser
internal MatchNumberDelegate parseNumberDelegate
internal void Init()
}
internal System.Pinnable`1 : object {
public T Data
}
public System.PlatformID : Enum {
public int value__
public PlatformID Win32S
public PlatformID Win32Windows
public PlatformID Win32NT
public PlatformID WinCE
public PlatformID Unix
public PlatformID Xbox
public PlatformID MacOSX
}
public System.PlatformNotSupportedException : NotSupportedException {
public void .ctor(string message)
public void .ctor(string message, Exception inner)
protected void .ctor(SerializationInfo info, StreamingContext context)
}
internal System.PointerSpec : object {
private int pointer_level
internal void .ctor(int pointer_level)
public Type Resolve(Type type)
public StringBuilder Append(StringBuilder sb)
public string ToString()
}
public System.Predicate`1 : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public bool Invoke(T obj)
public IAsyncResult BeginInvoke(T obj, AsyncCallback callback, object object)
public bool EndInvoke(IAsyncResult result)
}
public System.Progress`1 : object {
private SynchronizationContext m_synchronizationContext
private Action`1<T> m_handler
private SendOrPostCallback m_invokeHandlers
private EventHandler`1<T> ProgressChanged
public void .ctor(Action`1<T> handler)
public void add_ProgressChanged(EventHandler`1<T> value)
public void remove_ProgressChanged(EventHandler`1<T> value)
protected void OnReport(T value)
private void System.IProgress<T>.Report(T value)
private void InvokeHandlers(object state)
}
internal System.ProgressStatics : object {
internal SynchronizationContext DefaultContext
}
public System.Random : object {
private int MBIG
private int MSEED
private int MZ
private int inext
private int inextp
private Int32[] SeedArray
public void .ctor(int Seed)
protected double Sample()
private int InternalSample()
public int Next()
private double GetSampleForLargeRange()
public int Next(int minValue, int maxValue)
public int Next(int maxValue)
public double NextDouble()
public void NextBytes(Byte[] buffer)
}
public System.RankException : SystemException {
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
protected void .ctor(SerializationInfo info, StreamingContext context)
}
public System.ReadOnlyMemory`1 : ValueType {
private object _arrayOrOwnedMemory
private int _index
private int _length
private int RemoveOwnedFlagBitMask
private ReadOnlyMemory`1<T> <Empty>k__BackingField
private string DebuggerDisplay
public ReadOnlyMemory`1<T> Empty
public int Length
public bool IsEmpty
public ReadOnlySpan`1<T> Span
public void .ctor(T[] array)
public void .ctor(T[] array, int start, int length)
internal void .ctor(OwnedMemory`1<T> owner, int index, int length)
private string get_DebuggerDisplay()
public ReadOnlyMemory`1<T> op_Implicit(T[] array)
public ReadOnlyMemory`1<T> op_Implicit(ArraySegment`1<T> arraySegment)
public ReadOnlyMemory`1<T> get_Empty()
public int get_Length()
public bool get_IsEmpty()
public ReadOnlyMemory`1<T> Slice(int start)
public ReadOnlyMemory`1<T> Slice(int start, int length)
public ReadOnlySpan`1<T> get_Span()
public MemoryHandle Retain(bool pin)
public bool DangerousTryGetArray(ArraySegment`1& arraySegment)
public T[] ToArray()
public bool Equals(object obj)
public bool Equals(ReadOnlyMemory`1<T> other)
public int GetHashCode()
private int CombineHashCodes(int left, int right)
private int CombineHashCodes(int h1, int h2, int h3)
}
public System.ReadOnlySpan`1 : ValueType {
private Pinnable`1<T> _pinnable
private IntPtr _byteOffset
private int _length
private string DebuggerDisplay
public int Length
public bool IsEmpty
public T Item
public ReadOnlySpan`1<T> Empty
internal Pinnable`1<T> Pinnable
internal IntPtr ByteOffset
public void .ctor(T[] array)
public void .ctor(T[] array, int start, int length)
public void .ctor(Void* pointer, int length)
public ReadOnlySpan`1<T> DangerousCreate(object obj, T& objectData, int length)
internal void .ctor(Pinnable`1<T> pinnable, IntPtr byteOffset, int length)
private string get_DebuggerDisplay()
public int get_Length()
public bool get_IsEmpty()
public T get_Item(int index)
public void CopyTo(Span`1<T> destination)
public bool TryCopyTo(Span`1<T> destination)
public bool op_Equality(ReadOnlySpan`1<T> left, ReadOnlySpan`1<T> right)
public bool op_Inequality(ReadOnlySpan`1<T> left, ReadOnlySpan`1<T> right)
public bool Equals(object obj)
public int GetHashCode()
public ReadOnlySpan`1<T> op_Implicit(T[] array)
public ReadOnlySpan`1<T> op_Implicit(ArraySegment`1<T> arraySegment)
public ReadOnlySpan`1<T> Slice(int start)
public ReadOnlySpan`1<T> Slice(int start, int length)
public T[] ToArray()
public ReadOnlySpan`1<T> get_Empty()
public T& DangerousGetPinnableReference()
internal Pinnable`1<T> get_Pinnable()
internal IntPtr get_ByteOffset()
}
public System.Reflection.AmbiguousMatchException : SystemException {
public void .ctor(string message)
public void .ctor(string message, Exception inner)
internal void .ctor(SerializationInfo info, StreamingContext context)
}
public System.Reflection.Assembly : object {
internal IntPtr _mono_assembly
private ResolveEventHolder resolve_event_holder
private Evidence _evidence
internal PermissionSet _minimum
internal PermissionSet _optional
internal PermissionSet _refuse
private PermissionSet _granted
private PermissionSet _denied
private bool fromByteArray
private string assemblyName
public string CodeBase
public string EscapedCodeBase
public string FullName
public MethodInfo EntryPoint
public Evidence Evidence
internal bool FromByteArray
public string Location
public string ImageRuntimeVersion
public long HostContext
public bool ReflectionOnly
internal PermissionSet GrantedPermissionSet
internal PermissionSet DeniedPermissionSet
public PermissionSet PermissionSet
public SecurityRuleSet SecurityRuleSet
public bool IsFullyTrusted
public Module ManifestModule
public bool GlobalAssemblyCache
public bool IsDynamic
public IEnumerable`1<TypeInfo> DefinedTypes
public IEnumerable`1<Type> ExportedTypes
public IEnumerable`1<Module> Modules
public IEnumerable`1<CustomAttributeData> CustomAttributes
public void add_ModuleResolve(ModuleResolveEventHandler value)
public void remove_ModuleResolve(ModuleResolveEventHandler value)
private string get_code_base(bool escaped)
private string get_fullname()
private string get_location()
private string InternalImageRuntimeVersion()
internal string GetAotId()
private string GetCodeBase(bool escaped)
public string get_CodeBase()
public string get_EscapedCodeBase()
public string get_FullName()
public MethodInfo get_EntryPoint()
public Evidence get_Evidence()
internal Evidence UnprotectedGetEvidence()
internal bool get_global_assembly_cache()
internal void set_FromByteArray(bool value)
public string get_Location()
public string get_ImageRuntimeVersion()
public void GetObjectData(SerializationInfo info, StreamingContext context)
public bool IsDefined(Type attributeType, bool inherit)
public Object[] GetCustomAttributes(bool inherit)
public Object[] GetCustomAttributes(Type attributeType, bool inherit)
private object GetFilesInternal(string name, bool getResourceModules)
public FileStream[] GetFiles()
public FileStream[] GetFiles(bool getResourceModules)
public FileStream GetFile(string name)
internal IntPtr GetManifestResourceInternal(string name, Int32& size, Module& module)
public Stream GetManifestResourceStream(string name)
public Stream GetManifestResourceStream(Type type, string name)
internal Stream GetManifestResourceStream(Type type, string name, bool skipSecurityCheck, StackCrawlMark& stackMark)
internal Stream GetManifestResourceStream(string name, StackCrawlMark& stackMark, bool skipSecurityCheck)
internal string GetSimpleName()
internal Byte[] GetPublicKey()
internal Version GetVersion()
private AssemblyNameFlags GetFlags()
internal Type[] GetTypes(bool exportedOnly)
public Type[] GetTypes()
public Type[] GetExportedTypes()
public Type GetType(string name, bool throwOnError)
public Type GetType(string name)
internal Type InternalGetType(Module module, string name, bool throwOnError, bool ignoreCase)
internal void InternalGetAssemblyName(string assemblyFile, MonoAssemblyName& aname, String& codebase)
public AssemblyName GetName(bool copiedName)
public AssemblyName GetName()
public string ToString()
public string CreateQualifiedName(string assemblyName, string typeName)
public Assembly GetAssembly(Type type)
public Assembly GetEntryAssembly()
internal Assembly GetSatelliteAssembly(CultureInfo culture, Version version, bool throwOnError)
internal RuntimeAssembly InternalGetSatelliteAssembly(string name, CultureInfo culture, Version version, bool throwOnFileNotFound, StackCrawlMark& stackMark)
private Type System.Runtime.InteropServices._Assembly.GetType()
private Assembly LoadFrom(string assemblyFile, bool refonly)
public Assembly LoadFrom(string assemblyFile)
public Assembly LoadFrom(string assemblyFile, Evidence securityEvidence)
public Assembly LoadFrom(string assemblyFile, Evidence securityEvidence, Byte[] hashValue, AssemblyHashAlgorithm hashAlgorithm)
public Assembly LoadFrom(string assemblyFile, Byte[] hashValue, AssemblyHashAlgorithm hashAlgorithm)
public Assembly UnsafeLoadFrom(string assemblyFile)
public Assembly LoadFile(string path, Evidence securityEvidence)
public Assembly LoadFile(string path)
public Assembly Load(string assemblyString)
public Assembly Load(string assemblyString, Evidence assemblySecurity)
public Assembly Load(AssemblyName assemblyRef)
public Assembly Load(AssemblyName assemblyRef, Evidence assemblySecurity)
public Assembly Load(Byte[] rawAssembly)
public Assembly Load(Byte[] rawAssembly, Byte[] rawSymbolStore)
public Assembly Load(Byte[] rawAssembly, Byte[] rawSymbolStore, Evidence securityEvidence)
public Assembly Load(Byte[] rawAssembly, Byte[] rawSymbolStore, SecurityContextSource securityContextSource)
public Assembly ReflectionOnlyLoad(Byte[] rawAssembly)
public Assembly ReflectionOnlyLoad(string assemblyString)
public Assembly ReflectionOnlyLoadFrom(string assemblyFile)
public Assembly LoadWithPartialName(string partialName)
public Module LoadModule(string moduleName, Byte[] rawModule)
public Module LoadModule(string moduleName, Byte[] rawModule, Byte[] rawSymbolStore)
private Assembly load_with_partial_name(string name, Evidence e)
public Assembly LoadWithPartialName(string partialName, Evidence securityEvidence)
internal Assembly LoadWithPartialName(string partialName, Evidence securityEvidence, bool oldBehavior)
public object CreateInstance(string typeName)
public object CreateInstance(string typeName, bool ignoreCase)
public object CreateInstance(string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes)
public Module[] GetLoadedModules()
public Module[] GetModules()
internal Module[] GetModulesInternal()
public String[] GetManifestResourceNames()
public Assembly GetExecutingAssembly()
public Assembly GetCallingAssembly()
internal IntPtr InternalGetReferencedAssemblies(Assembly module)
internal AssemblyName[] GetReferencedAssemblies(Assembly module)
private bool GetManifestResourceInfoInternal(string name, ManifestResourceInfo info)
public ManifestResourceInfo GetManifestResourceInfo(string resourceName)
public long get_HostContext()
internal Module GetManifestModule()
internal Module GetManifestModuleInternal()
public bool get_ReflectionOnly()
public int GetHashCode()
public bool Equals(object o)
internal void Resolve()
internal PermissionSet get_GrantedPermissionSet()
internal PermissionSet get_DeniedPermissionSet()
internal bool LoadPermissions(Assembly a, IntPtr& minimum, Int32& minLength, IntPtr& optional, Int32& optLength, IntPtr& refused, Int32& refLength)
private void LoadAssemblyPermissions()
public PermissionSet get_PermissionSet()
public SecurityRuleSet get_SecurityRuleSet()
private Exception CreateNIE()
public IList`1<CustomAttributeData> GetCustomAttributesData()
public bool get_IsFullyTrusted()
public Type GetType(string name, bool throwOnError, bool ignoreCase)
public Module GetModule(string name)
public AssemblyName[] GetReferencedAssemblies()
public Module[] GetModules(bool getResourceModules)
public Module[] GetLoadedModules(bool getResourceModules)
public Assembly GetSatelliteAssembly(CultureInfo culture)
public Assembly GetSatelliteAssembly(CultureInfo culture, Version version)
public Module get_ManifestModule()
public bool get_GlobalAssemblyCache()
public bool get_IsDynamic()
public bool op_Equality(Assembly left, Assembly right)
public bool op_Inequality(Assembly left, Assembly right)
public IEnumerable`1<TypeInfo> get_DefinedTypes()
public IEnumerable`1<Type> get_ExportedTypes()
public IEnumerable`1<Module> get_Modules()
public IEnumerable`1<CustomAttributeData> get_CustomAttributes()
}
public System.Reflection.AssemblyAlgorithmIdAttribute : Attribute {
private UInt32 m_algId
public UInt32 AlgorithmId
public void .ctor(AssemblyHashAlgorithm algorithmId)
public void .ctor(UInt32 algorithmId)
public UInt32 get_AlgorithmId()
}
public System.Reflection.AssemblyCompanyAttribute : Attribute {
private string m_company
public string Company
public void .ctor(string company)
public string get_Company()
}
public System.Reflection.AssemblyConfigurationAttribute : Attribute {
private string m_configuration
public string Configuration
public void .ctor(string configuration)
public string get_Configuration()
}
public System.Reflection.AssemblyContentType : Enum {
public int value__
public AssemblyContentType Default
public AssemblyContentType WindowsRuntime
}
public System.Reflection.AssemblyCopyrightAttribute : Attribute {
private string m_copyright
public string Copyright
public void .ctor(string copyright)
public string get_Copyright()
}
public System.Reflection.AssemblyCultureAttribute : Attribute {
private string m_culture
public string Culture
public void .ctor(string culture)
public string get_Culture()
}
public System.Reflection.AssemblyDefaultAliasAttribute : Attribute {
private string m_defaultAlias
public string DefaultAlias
public void .ctor(string defaultAlias)
public string get_DefaultAlias()
}
public System.Reflection.AssemblyDelaySignAttribute : Attribute {
private bool m_delaySign
public bool DelaySign
public void .ctor(bool delaySign)
public bool get_DelaySign()
}
public System.Reflection.AssemblyDescriptionAttribute : Attribute {
private string m_description
public string Description
public void .ctor(string description)
public string get_Description()
}
public System.Reflection.AssemblyFileVersionAttribute : Attribute {
private string _version
public string Version
public void .ctor(string version)
public string get_Version()
}
public System.Reflection.AssemblyFlagsAttribute : Attribute {
private AssemblyNameFlags m_flags
public UInt32 Flags
public int AssemblyFlags
public void .ctor(UInt32 flags)
public UInt32 get_Flags()
public int get_AssemblyFlags()
public void .ctor(int assemblyFlags)
public void .ctor(AssemblyNameFlags assemblyFlags)
}
public System.Reflection.AssemblyInformationalVersionAttribute : Attribute {
private string m_informationalVersion
public string InformationalVersion
public void .ctor(string informationalVersion)
public string get_InformationalVersion()
}
public System.Reflection.AssemblyKeyFileAttribute : Attribute {
private string m_keyFile
public string KeyFile
public void .ctor(string keyFile)
public string get_KeyFile()
}
public System.Reflection.AssemblyKeyNameAttribute : Attribute {
private string m_keyName
public string KeyName
public void .ctor(string keyName)
public string get_KeyName()
}
public System.Reflection.AssemblyMetadataAttribute : Attribute {
private string m_key
private string m_value
public string Key
public string Value
public void .ctor(string key, string value)
public string get_Key()
public string get_Value()
}
public System.Reflection.AssemblyName : object {
private string name
private string codebase
private int major
private int minor
private int build
private int revision
private CultureInfo cultureinfo
private AssemblyNameFlags flags
private AssemblyHashAlgorithm hashalg
private StrongNameKeyPair keypair
private Byte[] publicKey
private Byte[] keyToken
private AssemblyVersionCompatibility versioncompat
private Version version
private ProcessorArchitecture processor_architecture
private AssemblyContentType contentType
public ProcessorArchitecture ProcessorArchitecture
public string Name
public string CodeBase
public string EscapedCodeBase
public CultureInfo CultureInfo
public AssemblyNameFlags Flags
public string FullName
public AssemblyHashAlgorithm HashAlgorithm
public StrongNameKeyPair KeyPair
public Version Version
public AssemblyVersionCompatibility VersionCompatibility
private bool IsPublicKeyValid
public string CultureName
public AssemblyContentType ContentType
private bool ParseAssemblyName(IntPtr name, MonoAssemblyName& aname, Boolean& is_version_definited, Boolean& is_token_defined)
public void .ctor(string assemblyName)
public ProcessorArchitecture get_ProcessorArchitecture()
public void set_ProcessorArchitecture(ProcessorArchitecture value)
internal void .ctor(SerializationInfo si, StreamingContext sc)
public string get_Name()
public void set_Name(string value)
public string get_CodeBase()
public void set_CodeBase(string value)
public string get_EscapedCodeBase()
public CultureInfo get_CultureInfo()
public void set_CultureInfo(CultureInfo value)
public AssemblyNameFlags get_Flags()
public void set_Flags(AssemblyNameFlags value)
public string get_FullName()
public AssemblyHashAlgorithm get_HashAlgorithm()
public void set_HashAlgorithm(AssemblyHashAlgorithm value)
public StrongNameKeyPair get_KeyPair()
public void set_KeyPair(StrongNameKeyPair value)
public Version get_Version()
public void set_Version(Version value)
public AssemblyVersionCompatibility get_VersionCompatibility()
public void set_VersionCompatibility(AssemblyVersionCompatibility value)
public string ToString()
public Byte[] GetPublicKey()
public Byte[] GetPublicKeyToken()
private bool get_IsPublicKeyValid()
private Byte[] InternalGetPublicKeyToken()
private void get_public_token(Byte* token, Byte* pubkey, int len)
private Byte[] ComputePublicKeyToken()
public bool ReferenceMatchesDefinition(AssemblyName reference, AssemblyName definition)
public void SetPublicKey(Byte[] publicKey)
public void SetPublicKeyToken(Byte[] publicKeyToken)
public void GetObjectData(SerializationInfo info, StreamingContext context)
public object Clone()
public void OnDeserialization(object sender)
public AssemblyName GetAssemblyName(string assemblyFile)
private void System.Runtime.InteropServices._AssemblyName.GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId)
private void System.Runtime.InteropServices._AssemblyName.GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo)
private void System.Runtime.InteropServices._AssemblyName.GetTypeInfoCount(UInt32& pcTInfo)
private void System.Runtime.InteropServices._AssemblyName.Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr)
public string get_CultureName()
public void set_CultureName(string value)
public AssemblyContentType get_ContentType()
public void set_ContentType(AssemblyContentType value)
private MonoAssemblyName* GetNativeName(IntPtr assembly_ptr)
internal void FillName(MonoAssemblyName* native, string codeBase, bool addVersion, bool addPublickey, bool defaultToken, bool assemblyRef)
internal AssemblyName Create(Assembly assembly, bool fillCodebase)
}
public System.Reflection.AssemblyNameFlags : Enum {
public int value__
public AssemblyNameFlags None
public AssemblyNameFlags PublicKey
public AssemblyNameFlags EnableJITcompileOptimizer
public AssemblyNameFlags EnableJITcompileTracking
public AssemblyNameFlags Retargetable
}
public System.Reflection.AssemblyNameProxy : MarshalByRefObject {
public AssemblyName GetAssemblyName(string assemblyFile)
}
public System.Reflection.AssemblyProductAttribute : Attribute {
private string m_product
public string Product
public void .ctor(string product)
public string get_Product()
}
public System.Reflection.AssemblySignatureKeyAttribute : Attribute {
private string _publicKey
private string _countersignature
public string PublicKey
public string Countersignature
public void .ctor(string publicKey, string countersignature)
public string get_PublicKey()
public string get_Countersignature()
}
public System.Reflection.AssemblyTitleAttribute : Attribute {
private string m_title
public string Title
public void .ctor(string title)
public string get_Title()
}
public System.Reflection.AssemblyTrademarkAttribute : Attribute {
private string m_trademark
public string Trademark
public void .ctor(string trademark)
public string get_Trademark()
}
public System.Reflection.AssemblyVersionAttribute : Attribute {
private string m_version
public string Version
public void .ctor(string version)
public string get_Version()
}
public System.Reflection.Binder : object {
public MethodBase BindToMethod(BindingFlags bindingAttr, MethodBase[] match, Object[]& args, ParameterModifier[] modifiers, CultureInfo culture, String[] names, Object& state)
public FieldInfo BindToField(BindingFlags bindingAttr, FieldInfo[] match, object value, CultureInfo culture)
public MethodBase SelectMethod(BindingFlags bindingAttr, MethodBase[] match, Type[] types, ParameterModifier[] modifiers)
public PropertyInfo SelectProperty(BindingFlags bindingAttr, PropertyInfo[] match, Type returnType, Type[] indexes, ParameterModifier[] modifiers)
public object ChangeType(object value, Type type, CultureInfo culture)
public void ReorderArgumentArray(Object[]& args, object state)
}
public System.Reflection.BindingFlags : Enum {
public int value__
public BindingFlags Default
public BindingFlags IgnoreCase
public BindingFlags DeclaredOnly
public BindingFlags Instance
public BindingFlags Static
public BindingFlags Public
public BindingFlags NonPublic
public BindingFlags FlattenHierarchy
public BindingFlags InvokeMethod
public BindingFlags CreateInstance
public BindingFlags GetField
public BindingFlags SetField
public BindingFlags GetProperty
public BindingFlags SetProperty
public BindingFlags PutDispProperty
public BindingFlags PutRefDispProperty
public BindingFlags ExactBinding
public BindingFlags SuppressChangeType
public BindingFlags OptionalParamBinding
public BindingFlags IgnoreReturn
}
public System.Reflection.CallingConventions : Enum {
public int value__
public CallingConventions Standard
public CallingConventions VarArgs
public CallingConventions Any
public CallingConventions HasThis
public CallingConventions ExplicitThis
}
public System.Reflection.ConstructorInfo : MethodBase {
public string ConstructorName
public string TypeConstructorName
public MemberTypes MemberType
public MemberTypes get_MemberType()
public object Invoke(Object[] parameters)
public object Invoke(BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture)
private void System.Runtime.InteropServices._ConstructorInfo.GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId)
private Type System.Runtime.InteropServices._ConstructorInfo.GetType()
private void System.Runtime.InteropServices._ConstructorInfo.GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo)
private void System.Runtime.InteropServices._ConstructorInfo.GetTypeInfoCount(UInt32& pcTInfo)
private void System.Runtime.InteropServices._ConstructorInfo.Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr)
private object System.Runtime.InteropServices._ConstructorInfo.Invoke_2(object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture)
private object System.Runtime.InteropServices._ConstructorInfo.Invoke_3(object obj, Object[] parameters)
private object System.Runtime.InteropServices._ConstructorInfo.Invoke_4(BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture)
private object System.Runtime.InteropServices._ConstructorInfo.Invoke_5(Object[] parameters)
public bool Equals(object obj)
public int GetHashCode()
public bool op_Equality(ConstructorInfo left, ConstructorInfo right)
public bool op_Inequality(ConstructorInfo left, ConstructorInfo right)
}
internal System.Reflection.CorElementType : Enum {
public byte value__
public CorElementType End
public CorElementType Void
public CorElementType Boolean
public CorElementType Char
public CorElementType I1
public CorElementType U1
public CorElementType I2
public CorElementType U2
public CorElementType I4
public CorElementType U4
public CorElementType I8
public CorElementType U8
public CorElementType R4
public CorElementType R8
public CorElementType String
public CorElementType Ptr
public CorElementType ByRef
public CorElementType ValueType
public CorElementType Class
public CorElementType Var
public CorElementType Array
public CorElementType GenericInst
public CorElementType TypedByRef
public CorElementType I
public CorElementType U
public CorElementType FnPtr
public CorElementType Object
public CorElementType SzArray
public CorElementType MVar
public CorElementType CModReqd
public CorElementType CModOpt
public CorElementType Internal
public CorElementType Max
public CorElementType Modifier
public CorElementType Sentinel
public CorElementType Pinned
}
public System.Reflection.CustomAttributeData : object {
private ConstructorInfo ctorInfo
private IList`1<CustomAttributeTypedArgument> ctorArgs
private IList`1<CustomAttributeNamedArgument> namedArgs
private LazyCAttrData lazyData
public ConstructorInfo Constructor
public IList`1<CustomAttributeTypedArgument> ConstructorArguments
public IList`1<CustomAttributeNamedArgument> NamedArguments
public Type AttributeType
internal void .ctor(ConstructorInfo ctorInfo, Assembly assembly, IntPtr data, UInt32 data_length)
private void ResolveArgumentsInternal(ConstructorInfo ctor, Assembly assembly, IntPtr data, UInt32 data_length, Object[]& ctorArgs, Object[]& namedArgs)
private void ResolveArguments()
public ConstructorInfo get_Constructor()
public IList`1<CustomAttributeTypedArgument> get_ConstructorArguments()
public IList`1<CustomAttributeNamedArgument> get_NamedArguments()
public IList`1<CustomAttributeData> GetCustomAttributes(Assembly target)
public IList`1<CustomAttributeData> GetCustomAttributes(MemberInfo target)
internal IList`1<CustomAttributeData> GetCustomAttributesInternal(RuntimeType target)
public IList`1<CustomAttributeData> GetCustomAttributes(Module target)
public IList`1<CustomAttributeData> GetCustomAttributes(ParameterInfo target)
public Type get_AttributeType()
public string ToString()
private T[] UnboxValues(Object[] values)
public bool Equals(object obj)
public int GetHashCode()
}
public System.Reflection.CustomAttributeExtensions : object {
public Attribute GetCustomAttribute(Assembly element, Type attributeType)
public Attribute GetCustomAttribute(Module element, Type attributeType)
public Attribute GetCustomAttribute(MemberInfo element, Type attributeType)
public Attribute GetCustomAttribute(ParameterInfo element, Type attributeType)
public T GetCustomAttribute(Assembly element)
public T GetCustomAttribute(Module element)
public T GetCustomAttribute(MemberInfo element)
public T GetCustomAttribute(ParameterInfo element)
public Attribute GetCustomAttribute(MemberInfo element, Type attributeType, bool inherit)
public Attribute GetCustomAttribute(ParameterInfo element, Type attributeType, bool inherit)
public T GetCustomAttribute(MemberInfo element, bool inherit)
public T GetCustomAttribute(ParameterInfo element, bool inherit)
public IEnumerable`1<Attribute> GetCustomAttributes(Assembly element)
public IEnumerable`1<Attribute> GetCustomAttributes(Module element)
public IEnumerable`1<Attribute> GetCustomAttributes(MemberInfo element)
public IEnumerable`1<Attribute> GetCustomAttributes(ParameterInfo element)
public IEnumerable`1<Attribute> GetCustomAttributes(MemberInfo element, bool inherit)
public IEnumerable`1<Attribute> GetCustomAttributes(ParameterInfo element, bool inherit)
public IEnumerable`1<Attribute> GetCustomAttributes(Assembly element, Type attributeType)
public IEnumerable`1<Attribute> GetCustomAttributes(Module element, Type attributeType)
public IEnumerable`1<Attribute> GetCustomAttributes(MemberInfo element, Type attributeType)
public IEnumerable`1<Attribute> GetCustomAttributes(ParameterInfo element, Type attributeType)
public IEnumerable`1<T> GetCustomAttributes(Assembly element)
public IEnumerable`1<T> GetCustomAttributes(Module element)
public IEnumerable`1<T> GetCustomAttributes(MemberInfo element)
public IEnumerable`1<T> GetCustomAttributes(ParameterInfo element)
public IEnumerable`1<Attribute> GetCustomAttributes(MemberInfo element, Type attributeType, bool inherit)
public IEnumerable`1<Attribute> GetCustomAttributes(ParameterInfo element, Type attributeType, bool inherit)
public IEnumerable`1<T> GetCustomAttributes(MemberInfo element, bool inherit)
public IEnumerable`1<T> GetCustomAttributes(ParameterInfo element, bool inherit)
public bool IsDefined(Assembly element, Type attributeType)
public bool IsDefined(Module element, Type attributeType)
public bool IsDefined(MemberInfo element, Type attributeType)
public bool IsDefined(ParameterInfo element, Type attributeType)
public bool IsDefined(MemberInfo element, Type attributeType, bool inherit)
public bool IsDefined(ParameterInfo element, Type attributeType, bool inherit)
}
public System.Reflection.CustomAttributeFormatException : FormatException {
public void .ctor(string message)
public void .ctor(string message, Exception inner)
protected void .ctor(SerializationInfo info, StreamingContext context)
}
public System.Reflection.CustomAttributeNamedArgument : ValueType {
private CustomAttributeTypedArgument typedArgument
private MemberInfo memberInfo
public MemberInfo MemberInfo
public CustomAttributeTypedArgument TypedValue
public bool IsField
public string MemberName
public void .ctor(MemberInfo memberInfo, object value)
public void .ctor(MemberInfo memberInfo, CustomAttributeTypedArgument typedArgument)
public MemberInfo get_MemberInfo()
public CustomAttributeTypedArgument get_TypedValue()
public bool get_IsField()
public string get_MemberName()
public string ToString()
public bool Equals(object obj)
public int GetHashCode()
public bool op_Equality(CustomAttributeNamedArgument left, CustomAttributeNamedArgument right)
public bool op_Inequality(CustomAttributeNamedArgument left, CustomAttributeNamedArgument right)
}
public System.Reflection.CustomAttributeTypedArgument : ValueType {
private Type argumentType
private object value
public Type ArgumentType
public object Value
public void .ctor(Type argumentType, object value)
public void .ctor(object value)
public Type get_ArgumentType()
public object get_Value()
public string ToString()
public bool Equals(object obj)
public int GetHashCode()
public bool op_Equality(CustomAttributeTypedArgument left, CustomAttributeTypedArgument right)
public bool op_Inequality(CustomAttributeTypedArgument left, CustomAttributeTypedArgument right)
}
public System.Reflection.DefaultMemberAttribute : Attribute {
private string m_memberName
public string MemberName
public void .ctor(string memberName)
public string get_MemberName()
}
internal System.Reflection.Emit.ArrayType : SymbolType {
private int rank
internal void .ctor(Type elementType, int rank)
internal int GetEffectiveRank()
internal Type InternalResolve()
internal Type RuntimeResolve()
protected bool IsArrayImpl()
public int GetArrayRank()
internal string FormatName(string elementName)
}
public System.Reflection.Emit.AssemblyBuilder : Assembly {
private UIntPtr dynamic_assembly
private MethodInfo entry_point
private ModuleBuilder[] modules
private string name
private string dir
private CustomAttributeBuilder[] cattrs
private MonoResource[] resources
private Byte[] public_key
private string version
private string culture
private UInt32 algid
private UInt32 flags
private PEFileKinds pekind
private bool delay_sign
private UInt32 access
private Module[] loaded_modules
private MonoWin32Resource[] win32_resources
private RefEmitPermissionSet[] permissions_minimum
private RefEmitPermissionSet[] permissions_optional
private RefEmitPermissionSet[] permissions_refused
private PortableExecutableKinds peKind
private ImageFileMachine machine
private bool corlib_internal
private Type[] type_forwarders
private Byte[] pktoken
internal Type corlib_object_type
internal Type corlib_value_type
internal Type corlib_enum_type
internal Type corlib_void_type
private ArrayList resource_writers
private Win32VersionResource version_res
private bool created
private bool is_module_only
private StrongName sn
private NativeResourceType native_resource
private string versioninfo_culture
private AssemblyBuilderAccess COMPILER_ACCESS
private ModuleBuilder manifest_module
public string CodeBase
public MethodInfo EntryPoint
public string Location
public string ImageRuntimeVersion
public bool ReflectionOnly
internal bool IsSave
internal bool IsRun
internal string AssemblyDir
internal bool IsModuleOnly
public Module ManifestModule
public bool GlobalAssemblyCache
public bool IsDynamic
public string FullName
private void basic_init(AssemblyBuilder ab)
private void UpdateNativeCustomAttributes(AssemblyBuilder ab)
internal void .ctor(AssemblyName n, string directory, AssemblyBuilderAccess access, bool corlib_internal)
public string get_CodeBase()
public MethodInfo get_EntryPoint()
public string get_Location()
public string get_ImageRuntimeVersion()
public bool get_ReflectionOnly()
public void AddResourceFile(string name, string fileName)
public void AddResourceFile(string name, string fileName, ResourceAttributes attribute)
private void AddResourceFile(string name, string fileName, ResourceAttributes attribute, bool fileNeedsToExists)
internal void AddPermissionRequests(PermissionSet required, PermissionSet optional, PermissionSet refused)
internal void EmbedResourceFile(string name, string fileName)
private void EmbedResourceFile(string name, string fileName, ResourceAttributes attribute)
public AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access)
public AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access, IEnumerable`1<CustomAttributeBuilder> assemblyAttributes)
public ModuleBuilder DefineDynamicModule(string name)
public ModuleBuilder DefineDynamicModule(string name, bool emitSymbolInfo)
public ModuleBuilder DefineDynamicModule(string name, string fileName)
public ModuleBuilder DefineDynamicModule(string name, string fileName, bool emitSymbolInfo)
private ModuleBuilder DefineDynamicModule(string name, string fileName, bool emitSymbolInfo, bool transient)
public IResourceWriter DefineResource(string name, string description, string fileName)
public IResourceWriter DefineResource(string name, string description, string fileName, ResourceAttributes attribute)
private void AddUnmanagedResource(Win32Resource res)
public void DefineUnmanagedResource(Byte[] resource)
public void DefineUnmanagedResource(string resourceFileName)
public void DefineVersionInfoResource()
public void DefineVersionInfoResource(string product, string productVersion, string company, string copyright, string trademark)
private void DefineVersionInfoResourceImpl(string fileName)
public ModuleBuilder GetDynamicModule(string name)
public Type[] GetExportedTypes()
public FileStream GetFile(string name)
public FileStream[] GetFiles(bool getResourceModules)
internal Module[] GetModulesInternal()
internal Type[] GetTypes(bool exportedOnly)
public ManifestResourceInfo GetManifestResourceInfo(string resourceName)
public String[] GetManifestResourceNames()
public Stream GetManifestResourceStream(string name)
public Stream GetManifestResourceStream(Type type, string name)
internal bool get_IsSave()
internal bool get_IsRun()
internal string get_AssemblyDir()
internal bool get_IsModuleOnly()
internal void set_IsModuleOnly(bool value)
internal Module GetManifestModule()
public void Save(string assemblyFileName, PortableExecutableKinds portableExecutableKind, ImageFileMachine imageFileMachine)
public void Save(string assemblyFileName)
public void SetEntryPoint(MethodInfo entryMethod)
public void SetEntryPoint(MethodInfo entryMethod, PEFileKinds fileKind)
public void SetCustomAttribute(CustomAttributeBuilder customBuilder)
public void SetCustomAttribute(ConstructorInfo con, Byte[] binaryAttribute)
private Exception not_supported()
private void check_name_and_filename(string name, string fileName, bool fileNeedsToExists)
private string create_assembly_version(string version)
private string GetCultureString(string str)
internal Type MakeGenericType(Type gtd, Type[] typeArguments)
private void System.Runtime.InteropServices._AssemblyBuilder.GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId)
private void System.Runtime.InteropServices._AssemblyBuilder.GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo)
private void System.Runtime.InteropServices._AssemblyBuilder.GetTypeInfoCount(UInt32& pcTInfo)
private void System.Runtime.InteropServices._AssemblyBuilder.Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr)
public Type GetType(string name, bool throwOnError, bool ignoreCase)
public Module GetModule(string name)
public Module[] GetModules(bool getResourceModules)
public AssemblyName GetName(bool copiedName)
public AssemblyName[] GetReferencedAssemblies()
public Module[] GetLoadedModules(bool getResourceModules)
public Assembly GetSatelliteAssembly(CultureInfo culture)
public Assembly GetSatelliteAssembly(CultureInfo culture, Version version)
public Module get_ManifestModule()
public bool get_GlobalAssemblyCache()
public bool get_IsDynamic()
public bool Equals(object obj)
public int GetHashCode()
public bool IsDefined(Type attributeType, bool inherit)
public Object[] GetCustomAttributes(bool inherit)
public Object[] GetCustomAttributes(Type attributeType, bool inherit)
public string get_FullName()
}
public System.Reflection.Emit.AssemblyBuilderAccess : Enum {
public int value__
public AssemblyBuilderAccess Run
public AssemblyBuilderAccess Save
public AssemblyBuilderAccess RunAndSave
public AssemblyBuilderAccess ReflectionOnly
public AssemblyBuilderAccess RunAndCollect
}
internal System.Reflection.Emit.ByRefType : SymbolType {
internal void .ctor(Type elementType)
internal Type InternalResolve()
protected bool IsByRefImpl()
internal string FormatName(string elementName)
public Type MakeArrayType()
public Type MakeArrayType(int rank)
public Type MakeByRefType()
public Type MakePointerType()
}
public System.Reflection.Emit.ConstructorBuilder : ConstructorInfo {
private RuntimeMethodHandle mhandle
private ILGenerator ilgen
internal Type[] parameters
private MethodAttributes attrs
private MethodImplAttributes iattrs
private int table_idx
private CallingConventions call_conv
private TypeBuilder type
internal ParameterBuilder[] pinfo
private CustomAttributeBuilder[] cattrs
private bool init_locals
private Type[][] paramModReq
private Type[][] paramModOpt
private RefEmitPermissionSet[] permissions
public CallingConventions CallingConvention
public bool InitLocals
internal TypeBuilder TypeBuilder
public RuntimeMethodHandle MethodHandle
public MethodAttributes Attributes
public Type ReflectedType
public Type DeclaringType
public Type ReturnType
public string Name
public string Signature
public Module Module
internal void .ctor(TypeBuilder tb, MethodAttributes attributes, CallingConventions callingConvention, Type[] parameterTypes, Type[][] paramModReq, Type[][] paramModOpt)
public CallingConventions get_CallingConvention()
public bool get_InitLocals()
public void set_InitLocals(bool value)
internal TypeBuilder get_TypeBuilder()
public MethodImplAttributes GetMethodImplementationFlags()
public ParameterInfo[] GetParameters()
internal ParameterInfo[] GetParametersInternal()
internal int GetParametersCount()
internal Type GetParameterType(int pos)
internal MethodBase RuntimeResolve()
public object Invoke(object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture)
public object Invoke(BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture)
public RuntimeMethodHandle get_MethodHandle()
public MethodAttributes get_Attributes()
public Type get_ReflectedType()
public Type get_DeclaringType()
public Type get_ReturnType()
public string get_Name()
public string get_Signature()
public void AddDeclarativeSecurity(SecurityAction action, PermissionSet pset)
public ParameterBuilder DefineParameter(int iSequence, ParameterAttributes attributes, string strParamName)
public bool IsDefined(Type attributeType, bool inherit)
public Object[] GetCustomAttributes(bool inherit)
public Object[] GetCustomAttributes(Type attributeType, bool inherit)
public ILGenerator GetILGenerator()
public ILGenerator GetILGenerator(int streamSize)
public void SetMethodBody(Byte[] il, int maxStack, Byte[] localSignature, IEnumerable`1<ExceptionHandler> exceptionHandlers, IEnumerable`1<int> tokenFixups)
public void SetCustomAttribute(CustomAttributeBuilder customBuilder)
public void SetCustomAttribute(ConstructorInfo con, Byte[] binaryAttribute)
public void SetImplementationFlags(MethodImplAttributes attributes)
public Module GetModule()
public MethodToken GetToken()
public void SetSymCustomAttribute(string name, Byte[] data)
public Module get_Module()
public string ToString()
internal void fixup()
internal void ResolveUserTypes()
internal void FixupTokens(Dictionary`2<int, int> token_map, Dictionary`2<int, MemberInfo> member_map)
internal void GenerateDebugInfo(ISymbolWriter symbolWriter)
internal int get_next_table_index(object obj, int table, bool inc)
private void RejectIfCreated()
private Exception not_supported()
private Exception not_after_created()
private Exception not_created()
private void System.Runtime.InteropServices._ConstructorBuilder.GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId)
private void System.Runtime.InteropServices._ConstructorBuilder.GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo)
private void System.Runtime.InteropServices._ConstructorBuilder.GetTypeInfoCount(UInt32& pcTInfo)
private void System.Runtime.InteropServices._ConstructorBuilder.Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr)
}
internal System.Reflection.Emit.ConstructorOnTypeBuilderInst : ConstructorInfo {
internal TypeBuilderInstantiation instantiation
internal ConstructorInfo cb
public Type DeclaringType
public string Name
public Type ReflectedType
public Module Module
public int MetadataToken
public RuntimeMethodHandle MethodHandle
public MethodAttributes Attributes
public CallingConventions CallingConvention
public bool ContainsGenericParameters
public bool IsGenericMethodDefinition
public bool IsGenericMethod
public void .ctor(TypeBuilderInstantiation instantiation, ConstructorInfo cb)
public Type get_DeclaringType()
public string get_Name()
public Type get_ReflectedType()
public Module get_Module()
public bool IsDefined(Type attributeType, bool inherit)
public Object[] GetCustomAttributes(bool inherit)
public Object[] GetCustomAttributes(Type attributeType, bool inherit)
public MethodImplAttributes GetMethodImplementationFlags()
public ParameterInfo[] GetParameters()
internal ParameterInfo[] GetParametersInternal()
internal Type[] GetParameterTypes()
internal ConstructorInfo RuntimeResolve()
public int get_MetadataToken()
internal int GetParametersCount()
public object Invoke(object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture)
public RuntimeMethodHandle get_MethodHandle()
public MethodAttributes get_Attributes()
public CallingConventions get_CallingConvention()
public Type[] GetGenericArguments()
public bool get_ContainsGenericParameters()
public bool get_IsGenericMethodDefinition()
public bool get_IsGenericMethod()
public object Invoke(BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture)
}
public System.Reflection.Emit.CustomAttributeBuilder : object {
private ConstructorInfo ctor
private Byte[] data
private Object[] args
private PropertyInfo[] namedProperties
private Object[] propertyValues
private FieldInfo[] namedFields
private Object[] fieldValues
internal ConstructorInfo Ctor
internal Byte[] Data
internal ConstructorInfo get_Ctor()
internal Byte[] get_Data()
private Byte[] GetBlob(Assembly asmb, ConstructorInfo con, Object[] constructorArgs, PropertyInfo[] namedProperties, Object[] propertyValues, FieldInfo[] namedFields, Object[] fieldValues)
internal object Invoke()
internal void .ctor(ConstructorInfo con, Byte[] binaryAttribute)
public void .ctor(ConstructorInfo con, Object[] constructorArgs)
public void .ctor(ConstructorInfo con, Object[] constructorArgs, FieldInfo[] namedFields, Object[] fieldValues)
public void .ctor(ConstructorInfo con, Object[] constructorArgs, PropertyInfo[] namedProperties, Object[] propertyValues)
public void .ctor(ConstructorInfo con, Object[] constructorArgs, PropertyInfo[] namedProperties, Object[] propertyValues, FieldInfo[] namedFields, Object[] fieldValues)
private bool IsValidType(Type t)
private bool IsValidParam(object o, Type paramType)
private bool IsValidValue(Type type, object value)
private void Initialize(ConstructorInfo con, Object[] constructorArgs, PropertyInfo[] namedProperties, Object[] propertyValues, FieldInfo[] namedFields, Object[] fieldValues)
internal int decode_len(Byte[] data, int pos, Int32& rpos)
internal string string_from_bytes(Byte[] data, int pos, int len)
internal string string_arg()
internal UnmanagedMarshal get_umarshal(CustomAttributeBuilder customBuilder, bool is_field)
private Type elementTypeToType(int elementType)
private object decode_cattr_value(Type t, Byte[] data, int pos, Int32& rpos)
internal CustomAttributeInfo decode_cattr(CustomAttributeBuilder customBuilder)
private void System.Runtime.InteropServices._CustomAttributeBuilder.GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId)
private void System.Runtime.InteropServices._CustomAttributeBuilder.GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo)
private void System.Runtime.InteropServices._CustomAttributeBuilder.GetTypeInfoCount(UInt32& pcTInfo)
private void System.Runtime.InteropServices._CustomAttributeBuilder.Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr)
private ParameterInfo[] GetParameters(ConstructorInfo ctor)
}
public System.Reflection.Emit.DynamicILInfo : object {
private DynamicMethod method
public DynamicMethod DynamicMethod
internal void .ctor(DynamicMethod method)
public DynamicMethod get_DynamicMethod()
public int GetTokenFor(Byte[] signature)
public int GetTokenFor(DynamicMethod method)
public int GetTokenFor(RuntimeFieldHandle field)
public int GetTokenFor(RuntimeMethodHandle method)
public int GetTokenFor(RuntimeTypeHandle type)
public int GetTokenFor(string literal)
public int GetTokenFor(RuntimeMethodHandle method, RuntimeTypeHandle contextType)
public int GetTokenFor(RuntimeFieldHandle field, RuntimeTypeHandle contextType)
public void SetCode(Byte[] code, int maxStackSize)
public void SetCode(Byte* code, int codeSize, int maxStackSize)
public void SetExceptions(Byte[] exceptions)
public void SetExceptions(Byte* exceptions, int exceptionsSize)
public void SetLocalSignature(Byte[] localSignature)
public void SetLocalSignature(Byte* localSignature, int signatureSize)
}
public System.Reflection.Emit.DynamicMethod : MethodInfo {
private RuntimeMethodHandle mhandle
private string name
private Type returnType
private Type[] parameters
private MethodAttributes attributes
private CallingConventions callingConvention
private Module module
private bool skipVisibility
private bool init_locals
private ILGenerator ilgen
private int nrefs
private Object[] refs
private IntPtr referenced_by
private Type owner
private Delegate deleg
private MonoMethod method
private ParameterBuilder[] pinfo
internal bool creating
private DynamicILInfo il_info
public MethodAttributes Attributes
public CallingConventions CallingConvention
public Type DeclaringType
public bool InitLocals
public RuntimeMethodHandle MethodHandle
public Module Module
public string Name
public Type ReflectedType
public ParameterInfo ReturnParameter
public Type ReturnType
public ICustomAttributeProvider ReturnTypeCustomAttributes
public void .ctor(string name, Type returnType, Type[] parameterTypes, Module m)
public void .ctor(string name, Type returnType, Type[] parameterTypes, Type owner)
public void .ctor(string name, Type returnType, Type[] parameterTypes, Module m, bool skipVisibility)
public void .ctor(string name, Type returnType, Type[] parameterTypes, Type owner, bool skipVisibility)
public void .ctor(string name, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] parameterTypes, Type owner, bool skipVisibility)
public void .ctor(string name, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] parameterTypes, Module m, bool skipVisibility)
public void .ctor(string name, Type returnType, Type[] parameterTypes)
public void .ctor(string name, Type returnType, Type[] parameterTypes, bool restrictedSkipVisibility)
private void .ctor(string name, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] parameterTypes, Type owner, Module m, bool skipVisibility, bool anonHosted)
private void create_dynamic_method(DynamicMethod m)
private void CreateDynMethod()
public Delegate CreateDelegate(Type delegateType)
public Delegate CreateDelegate(Type delegateType, object target)
public ParameterBuilder DefineParameter(int position, ParameterAttributes attributes, string parameterName)
public MethodInfo GetBaseDefinition()
public Object[] GetCustomAttributes(bool inherit)
public Object[] GetCustomAttributes(Type attributeType, bool inherit)
public DynamicILInfo GetDynamicILInfo()
public ILGenerator GetILGenerator()
public ILGenerator GetILGenerator(int streamSize)
public MethodImplAttributes GetMethodImplementationFlags()
public ParameterInfo[] GetParameters()
internal ParameterInfo[] GetParametersInternal()
internal int GetParametersCount()
internal Type GetParameterType(int pos)
public object Invoke(object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture)
public bool IsDefined(Type attributeType, bool inherit)
public string ToString()
public MethodAttributes get_Attributes()
public CallingConventions get_CallingConvention()
public Type get_DeclaringType()
public bool get_InitLocals()
public void set_InitLocals(bool value)
public RuntimeMethodHandle get_MethodHandle()
public Module get_Module()
public string get_Name()
public Type get_ReflectedType()
public ParameterInfo get_ReturnParameter()
public Type get_ReturnType()
public ICustomAttributeProvider get_ReturnTypeCustomAttributes()
private void RejectIfCreated()
internal int AddRef(object reference)
}
internal System.Reflection.Emit.DynamicMethodTokenGenerator : object {
private DynamicMethod m
public void .ctor(DynamicMethod m)
public int GetToken(string str)
public int GetToken(MethodBase method, Type[] opt_param_types)
public int GetToken(MemberInfo member, bool create_open_instance)
public int GetToken(SignatureHelper helper)
}
public System.Reflection.Emit.EnumBuilder : TypeInfo {
private TypeBuilder _tb
private FieldBuilder _underlyingField
private Type _underlyingType
public Assembly Assembly
public string AssemblyQualifiedName
public Type BaseType
public Type DeclaringType
public string FullName
public Guid GUID
public Module Module
public string Name
public string Namespace
public Type ReflectedType
public RuntimeTypeHandle TypeHandle
public TypeToken TypeToken
public FieldBuilder UnderlyingField
public Type UnderlyingSystemType
internal bool IsUserType
public bool IsConstructedGenericType
internal void .ctor(ModuleBuilder mb, string name, TypeAttributes visibility, Type underlyingType)
internal TypeBuilder GetTypeBuilder()
internal Type InternalResolve()
internal Type RuntimeResolve()
public Assembly get_Assembly()
public string get_AssemblyQualifiedName()
public Type get_BaseType()
public Type get_DeclaringType()
public string get_FullName()
public Guid get_GUID()
public Module get_Module()
public string get_Name()
public string get_Namespace()
public Type get_ReflectedType()
public RuntimeTypeHandle get_TypeHandle()
public TypeToken get_TypeToken()
public FieldBuilder get_UnderlyingField()
public Type get_UnderlyingSystemType()
public Type CreateType()
public TypeInfo CreateTypeInfo()
public Type GetEnumUnderlyingType()
private void setup_enum_type(Type t)
public FieldBuilder DefineLiteral(string literalName, object literalValue)
protected TypeAttributes GetAttributeFlagsImpl()
protected ConstructorInfo GetConstructorImpl(BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers)
public ConstructorInfo[] GetConstructors(BindingFlags bindingAttr)
public Object[] GetCustomAttributes(bool inherit)
public Object[] GetCustomAttributes(Type attributeType, bool inherit)
public Type GetElementType()
public EventInfo GetEvent(string name, BindingFlags bindingAttr)
public EventInfo[] GetEvents()
public EventInfo[] GetEvents(BindingFlags bindingAttr)
public FieldInfo GetField(string name, BindingFlags bindingAttr)
public FieldInfo[] GetFields(BindingFlags bindingAttr)
public Type GetInterface(string name, bool ignoreCase)
public InterfaceMapping GetInterfaceMap(Type interfaceType)
public Type[] GetInterfaces()
public MemberInfo[] GetMember(string name, MemberTypes type, BindingFlags bindingAttr)
public MemberInfo[] GetMembers(BindingFlags bindingAttr)
protected MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers)
public MethodInfo[] GetMethods(BindingFlags bindingAttr)
public Type GetNestedType(string name, BindingFlags bindingAttr)
public Type[] GetNestedTypes(BindingFlags bindingAttr)
public PropertyInfo[] GetProperties(BindingFlags bindingAttr)
protected PropertyInfo GetPropertyImpl(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers)
protected bool HasElementTypeImpl()
public object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, Object[] args, ParameterModifier[] modifiers, CultureInfo culture, String[] namedParameters)
protected bool IsArrayImpl()
protected bool IsByRefImpl()
protected bool IsCOMObjectImpl()
protected bool IsPointerImpl()
protected bool IsPrimitiveImpl()
protected bool IsValueTypeImpl()
public bool IsDefined(Type attributeType, bool inherit)
public Type MakeArrayType()
public Type MakeArrayType(int rank)
public Type MakeByRefType()
public Type MakePointerType()
public void SetCustomAttribute(CustomAttributeBuilder customBuilder)
public void SetCustomAttribute(ConstructorInfo con, Byte[] binaryAttribute)
private Exception CreateNotSupportedException()
private void System.Runtime.InteropServices._EnumBuilder.GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId)
private void System.Runtime.InteropServices._EnumBuilder.GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo)
private void System.Runtime.InteropServices._EnumBuilder.GetTypeInfoCount(UInt32& pcTInfo)
private void System.Runtime.InteropServices._EnumBuilder.Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr)
internal bool get_IsUserType()
public bool get_IsConstructedGenericType()
public bool IsAssignableFrom(TypeInfo typeInfo)
}
public System.Reflection.Emit.EventBuilder : object {
internal string name
private Type type
private TypeBuilder typeb
private CustomAttributeBuilder[] cattrs
internal MethodBuilder add_method
internal MethodBuilder remove_method
internal MethodBuilder raise_method
internal MethodBuilder[] other_methods
internal EventAttributes attrs
private int table_idx
internal void .ctor(TypeBuilder tb, string eventName, EventAttributes eventAttrs, Type eventType)
internal int get_next_table_index(object obj, int table, bool inc)
public void AddOtherMethod(MethodBuilder mdBuilder)
public EventToken GetEventToken()
public void SetAddOnMethod(MethodBuilder mdBuilder)
public void SetRaiseMethod(MethodBuilder mdBuilder)
public void SetRemoveOnMethod(MethodBuilder mdBuilder)
public void SetCustomAttribute(CustomAttributeBuilder customBuilder)
public void SetCustomAttribute(ConstructorInfo con, Byte[] binaryAttribute)
private void RejectIfCreated()
private void System.Runtime.InteropServices._EventBuilder.GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId)
private void System.Runtime.InteropServices._EventBuilder.GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo)
private void System.Runtime.InteropServices._EventBuilder.GetTypeInfoCount(UInt32& pcTInfo)
private void System.Runtime.InteropServices._EventBuilder.Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr)
}
internal System.Reflection.Emit.EventOnTypeBuilderInst : EventInfo {
private TypeBuilderInstantiation instantiation
private EventBuilder event_builder
private EventInfo event_info
public EventAttributes Attributes
public Type DeclaringType
public string Name
public Type ReflectedType
internal void .ctor(TypeBuilderInstantiation instantiation, EventBuilder evt)
internal void .ctor(TypeBuilderInstantiation instantiation, EventInfo evt)
public EventAttributes get_Attributes()
public MethodInfo GetAddMethod(bool nonPublic)
public MethodInfo GetRaiseMethod(bool nonPublic)
public MethodInfo GetRemoveMethod(bool nonPublic)
public MethodInfo[] GetOtherMethods(bool nonPublic)
public Type get_DeclaringType()
public string get_Name()
public Type get_ReflectedType()
public bool IsDefined(Type attributeType, bool inherit)
public Object[] GetCustomAttributes(bool inherit)
public Object[] GetCustomAttributes(Type attributeType, bool inherit)
}
public System.Reflection.Emit.EventToken : ValueType {
internal int tokValue
public EventToken Empty
public int Token
internal void .ctor(int val)
public bool Equals(object obj)
public bool Equals(EventToken obj)
public bool op_Equality(EventToken a, EventToken b)
public bool op_Inequality(EventToken a, EventToken b)
public int GetHashCode()
public int get_Token()
}
public System.Reflection.Emit.ExceptionHandler : ValueType {
internal int m_exceptionClass
internal int m_tryStartOffset
internal int m_tryEndOffset
internal int m_filterOffset
internal int m_handlerStartOffset
internal int m_handlerEndOffset
internal ExceptionHandlingClauseOptions m_kind
public int ExceptionTypeToken
public int TryOffset
public int TryLength
public int FilterOffset
public int HandlerOffset
public int HandlerLength
public ExceptionHandlingClauseOptions Kind
public int get_ExceptionTypeToken()
public int get_TryOffset()
public int get_TryLength()
public int get_FilterOffset()
public int get_HandlerOffset()
public int get_HandlerLength()
public ExceptionHandlingClauseOptions get_Kind()
public void .ctor(int tryOffset, int tryLength, int filterOffset, int handlerOffset, int handlerLength, ExceptionHandlingClauseOptions kind, int exceptionTypeToken)
internal void .ctor(int tryStartOffset, int tryEndOffset, int filterOffset, int handlerStartOffset, int handlerEndOffset, int kind, int exceptionTypeToken)
private bool IsValidKind(ExceptionHandlingClauseOptions kind)
public int GetHashCode()
public bool Equals(object obj)
public bool Equals(ExceptionHandler other)
public bool op_Equality(ExceptionHandler left, ExceptionHandler right)
public bool op_Inequality(ExceptionHandler left, ExceptionHandler right)
}
public System.Reflection.Emit.FieldBuilder : FieldInfo {
private FieldAttributes attrs
private Type type
private string name
private object def_value
private int offset
private int table_idx
internal TypeBuilder typeb
private Byte[] rva_data
private CustomAttributeBuilder[] cattrs
private UnmanagedMarshal marshal_info
private RuntimeFieldHandle handle
private Type[] modReq
private Type[] modOpt
public FieldAttributes Attributes
public Type DeclaringType
public RuntimeFieldHandle FieldHandle
public Type FieldType
public string Name
public Type ReflectedType
public Module Module
internal void .ctor(TypeBuilder tb, string fieldName, Type type, FieldAttributes attributes, Type[] modReq, Type[] modOpt)
public FieldAttributes get_Attributes()
public Type get_DeclaringType()
public RuntimeFieldHandle get_FieldHandle()
public Type get_FieldType()
public string get_Name()
public Type get_ReflectedType()
public Object[] GetCustomAttributes(bool inherit)
public Object[] GetCustomAttributes(Type attributeType, bool inherit)
public FieldToken GetToken()
public object GetValue(object obj)
public bool IsDefined(Type attributeType, bool inherit)
internal int GetFieldOffset()
internal void SetRVAData(Byte[] data)
public void SetConstant(object defaultValue)
public void SetCustomAttribute(CustomAttributeBuilder customBuilder)
public void SetCustomAttribute(ConstructorInfo con, Byte[] binaryAttribute)
public void SetMarshal(UnmanagedMarshal unmanagedMarshal)
public void SetOffset(int iOffset)
public void SetValue(object obj, object val, BindingFlags invokeAttr, Binder binder, CultureInfo culture)
private Exception CreateNotSupportedException()
private void RejectIfCreated()
internal void ResolveUserTypes()
internal FieldInfo RuntimeResolve()
public Module get_Module()
private void System.Runtime.InteropServices._FieldBuilder.GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId)
private void System.Runtime.InteropServices._FieldBuilder.GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo)
private void System.Runtime.InteropServices._FieldBuilder.GetTypeInfoCount(UInt32& pcTInfo)
private void System.Runtime.InteropServices._FieldBuilder.Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr)
}
internal System.Reflection.Emit.FieldOnTypeBuilderInst : FieldInfo {
internal TypeBuilderInstantiation instantiation
internal FieldInfo fb
public Type DeclaringType
public string Name
public Type ReflectedType
public FieldAttributes Attributes
public RuntimeFieldHandle FieldHandle
public int MetadataToken
public Type FieldType
public void .ctor(TypeBuilderInstantiation instantiation, FieldInfo fb)
public Type get_DeclaringType()
public string get_Name()
public Type get_ReflectedType()
public bool IsDefined(Type attributeType, bool inherit)
public Object[] GetCustomAttributes(bool inherit)
public Object[] GetCustomAttributes(Type attributeType, bool inherit)
public string ToString()
public FieldAttributes get_Attributes()
public RuntimeFieldHandle get_FieldHandle()
public int get_MetadataToken()
public Type get_FieldType()
public object GetValue(object obj)
public void SetValue(object obj, object value, BindingFlags invokeAttr, Binder binder, CultureInfo culture)
internal FieldInfo RuntimeResolve()
}
public System.Reflection.Emit.FieldToken : ValueType {
internal int tokValue
public FieldToken Empty
public int Token
internal void .ctor(int val)
public bool Equals(object obj)
public bool Equals(FieldToken obj)
public bool op_Equality(FieldToken a, FieldToken b)
public bool op_Inequality(FieldToken a, FieldToken b)
public int GetHashCode()
public int get_Token()
}
public System.Reflection.Emit.FlowControl : Enum {
public int value__
public FlowControl Branch
public FlowControl Break
public FlowControl Call
public FlowControl Cond_Branch
public FlowControl Meta
public FlowControl Next
public FlowControl Phi
public FlowControl Return
public FlowControl Throw
}
internal System.Reflection.Emit.GenericInstanceKey : object {
private Type gtd
internal Type[] args
private int hash_code
internal void .ctor(Type gtd, Type[] args)
private bool IsBoundedVector(Type type)
private bool TypeEquals(Type a, Type b)
public bool Equals(object obj)
public int GetHashCode()
}
public System.Reflection.Emit.GenericTypeParameterBuilder : TypeInfo {
private TypeBuilder tbuilder
private MethodBuilder mbuilder
private string name
private int index
private Type base_type
private Type[] iface_constraints
private CustomAttributeBuilder[] cattrs
private GenericParameterAttributes attrs
public Type UnderlyingSystemType
public Assembly Assembly
public string AssemblyQualifiedName
public Type BaseType
public string FullName
public Guid GUID
public string Name
public string Namespace
public Module Module
public Type DeclaringType
public Type ReflectedType
public RuntimeTypeHandle TypeHandle
public bool ContainsGenericParameters
public bool IsGenericParameter
public bool IsGenericType
public bool IsGenericTypeDefinition
public GenericParameterAttributes GenericParameterAttributes
public int GenericParameterPosition
public MethodBase DeclaringMethod
internal bool IsUserType
public void SetBaseTypeConstraint(Type baseTypeConstraint)
public void SetInterfaceConstraints(Type[] interfaceConstraints)
public void SetGenericParameterAttributes(GenericParameterAttributes genericParameterAttributes)
internal void .ctor(TypeBuilder tbuilder, MethodBuilder mbuilder, string name, int index)
internal Type InternalResolve()
internal Type RuntimeResolve()
public bool IsSubclassOf(Type c)
protected TypeAttributes GetAttributeFlagsImpl()
protected ConstructorInfo GetConstructorImpl(BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers)
public ConstructorInfo[] GetConstructors(BindingFlags bindingAttr)
public EventInfo GetEvent(string name, BindingFlags bindingAttr)
public EventInfo[] GetEvents()
public EventInfo[] GetEvents(BindingFlags bindingAttr)
public FieldInfo GetField(string name, BindingFlags bindingAttr)
public FieldInfo[] GetFields(BindingFlags bindingAttr)
public Type GetInterface(string name, bool ignoreCase)
public Type[] GetInterfaces()
public MemberInfo[] GetMembers(BindingFlags bindingAttr)
public MemberInfo[] GetMember(string name, MemberTypes type, BindingFlags bindingAttr)
public MethodInfo[] GetMethods(BindingFlags bindingAttr)
protected MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers)
public Type GetNestedType(string name, BindingFlags bindingAttr)
public Type[] GetNestedTypes(BindingFlags bindingAttr)
public PropertyInfo[] GetProperties(BindingFlags bindingAttr)
protected PropertyInfo GetPropertyImpl(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers)
protected bool HasElementTypeImpl()
public bool IsAssignableFrom(Type c)
public bool IsAssignableFrom(TypeInfo typeInfo)
public bool IsInstanceOfType(object o)
protected bool IsArrayImpl()
protected bool IsByRefImpl()
protected bool IsCOMObjectImpl()
protected bool IsPointerImpl()
protected bool IsPrimitiveImpl()
protected bool IsValueTypeImpl()
public object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, Object[] args, ParameterModifier[] modifiers, CultureInfo culture, String[] namedParameters)
public Type GetElementType()
public Type get_UnderlyingSystemType()
public Assembly get_Assembly()
public string get_AssemblyQualifiedName()
public Type get_BaseType()
public string get_FullName()
public Guid get_GUID()
public bool IsDefined(Type attributeType, bool inherit)
public Object[] GetCustomAttributes(bool inherit)
public Object[] GetCustomAttributes(Type attributeType, bool inherit)
public InterfaceMapping GetInterfaceMap(Type interfaceType)
public string get_Name()
public string get_Namespace()
public Module get_Module()
public Type get_DeclaringType()
public Type get_ReflectedType()
public RuntimeTypeHandle get_TypeHandle()
public Type[] GetGenericArguments()
public Type GetGenericTypeDefinition()
public bool get_ContainsGenericParameters()
public bool get_IsGenericParameter()
public bool get_IsGenericType()
public bool get_IsGenericTypeDefinition()
public GenericParameterAttributes get_GenericParameterAttributes()
public int get_GenericParameterPosition()
public Type[] GetGenericParameterConstraints()
public MethodBase get_DeclaringMethod()
public void SetCustomAttribute(CustomAttributeBuilder customBuilder)
public void SetCustomAttribute(ConstructorInfo con, Byte[] binaryAttribute)
private Exception not_supported()
public string ToString()
public bool Equals(object o)
public int GetHashCode()
public Type MakeArrayType()
public Type MakeArrayType(int rank)
public Type MakeByRefType()
public Type MakeGenericType(Type[] typeArguments)
public Type MakePointerType()
internal bool get_IsUserType()
}
internal System.Reflection.Emit.ILExceptionBlock : ValueType {
public int CATCH
public int FILTER
public int FINALLY
public int FAULT
public int FILTER_START
internal Type extype
internal int type
internal int start
internal int len
internal int filter_offset
internal void Debug()
}
internal System.Reflection.Emit.ILExceptionInfo : ValueType {
internal ILExceptionBlock[] handlers
internal int start
internal int len
internal Label end
internal int NumHandlers()
internal void AddCatch(Type extype, int offset)
internal void AddFinally(int offset)
internal void AddFault(int offset)
internal void AddFilter(int offset)
internal void End(int offset)
internal int LastClauseType()
internal void PatchFilterClause(int start)
internal void Debug(int b)
private void add_block(int offset)
}
public System.Reflection.Emit.ILGenerator : object {
private Byte[] code
private int code_len
private int max_stack
private int cur_stack
private LocalBuilder[] locals
private ILExceptionInfo[] ex_handlers
private int num_token_fixups
private ILTokenInfo[] token_fixups
private LabelData[] labels
private int num_labels
private LabelFixup[] fixups
private int num_fixups
internal Module module
private int cur_block
private Stack open_blocks
private TokenGenerator token_gen
private int defaultFixupSize
private int defaultLabelsSize
private int defaultExceptionStackSize
private ArrayList sequencePointLists
private SequencePointList currentSequence
internal bool HasDebugInfo
internal TokenGenerator TokenGenerator
public int ILOffset
internal void .ctor(Module m, TokenGenerator token_gen, int size)
private void add_token_fixup(MemberInfo mi)
private void make_room(int nbytes)
private void emit_int(int val)
private void ll_emit(OpCode opcode)
private int target_len(OpCode opcode)
private void InternalEndClause()
public void BeginCatchBlock(Type exceptionType)
public void BeginExceptFilterBlock()
public Label BeginExceptionBlock()
public void BeginFaultBlock()
public void BeginFinallyBlock()
public void BeginScope()
public LocalBuilder DeclareLocal(Type localType)
public LocalBuilder DeclareLocal(Type localType, bool pinned)
public Label DefineLabel()
public void Emit(OpCode opcode)
public void Emit(OpCode opcode, byte arg)
public void Emit(OpCode opcode, ConstructorInfo con)
public void Emit(OpCode opcode, double arg)
public void Emit(OpCode opcode, FieldInfo field)
public void Emit(OpCode opcode, short arg)
public void Emit(OpCode opcode, int arg)
public void Emit(OpCode opcode, long arg)
public void Emit(OpCode opcode, Label label)
public void Emit(OpCode opcode, Label[] labels)
public void Emit(OpCode opcode, LocalBuilder local)
public void Emit(OpCode opcode, MethodInfo meth)
private void Emit(OpCode opcode, MethodInfo method, int token)
public void Emit(OpCode opcode, sbyte arg)
public void Emit(OpCode opcode, SignatureHelper signature)
public void Emit(OpCode opcode, float arg)
public void Emit(OpCode opcode, string str)
public void Emit(OpCode opcode, Type cls)
public void EmitCall(OpCode opcode, MethodInfo methodInfo, Type[] optionalParameterTypes)
public void EmitCalli(OpCode opcode, CallingConvention unmanagedCallConv, Type returnType, Type[] parameterTypes)
public void EmitCalli(OpCode opcode, CallingConventions callingConvention, Type returnType, Type[] parameterTypes, Type[] optionalParameterTypes)
public void EmitWriteLine(FieldInfo fld)
public void EmitWriteLine(LocalBuilder localBuilder)
public void EmitWriteLine(string value)
public void EndExceptionBlock()
public void EndScope()
public void MarkLabel(Label loc)
public void MarkSequencePoint(ISymbolDocumentWriter document, int startLine, int startColumn, int endLine, int endColumn)
internal void GenerateDebugInfo(ISymbolWriter symbolWriter)
internal bool get_HasDebugInfo()
public void ThrowException(Type excType)
public void UsingNamespace(string usingNamespace)
internal void label_fixup(MethodBase mb)
internal void FixupTokens(Dictionary`2<int, int> token_map, Dictionary`2<int, MemberInfo> member_map)
internal void SetExceptionHandlers(ILExceptionInfo[] exHandlers)
internal void SetTokenFixups(ILTokenInfo[] tokenFixups)
internal void SetCode(Byte[] code, int max_stack)
internal void SetCode(Byte* code, int code_size, int max_stack)
internal void Init(Byte[] il, int maxStack, Byte[] localSignature, IEnumerable`1<ExceptionHandler> exceptionHandlers, IEnumerable`1<int> tokenFixups)
internal TokenGenerator get_TokenGenerator()
internal int Mono_GetCurrentOffset(ILGenerator ig)
public int get_ILOffset()
private void System.Runtime.InteropServices._ILGenerator.GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId)
private void System.Runtime.InteropServices._ILGenerator.GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo)
private void System.Runtime.InteropServices._ILGenerator.GetTypeInfoCount(UInt32& pcTInfo)
private void System.Runtime.InteropServices._ILGenerator.Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr)
}
internal System.Reflection.Emit.ILTokenInfo : ValueType {
public MemberInfo member
public int code_pos
}
public System.Reflection.Emit.Label : ValueType {
internal int label
internal void .ctor(int val)
public bool Equals(object obj)
public bool Equals(Label obj)
public bool op_Equality(Label a, Label b)
public bool op_Inequality(Label a, Label b)
public int GetHashCode()
}
public System.Reflection.Emit.LocalBuilder : LocalVariableInfo {
private string name
internal ILGenerator ilgen
private int startOffset
private int endOffset
public Type LocalType
public bool IsPinned
public int LocalIndex
internal string Name
internal int StartOffset
internal int EndOffset
internal void .ctor(Type t, ILGenerator ilgen)
public void SetLocalSymInfo(string name, int startOffset, int endOffset)
public void SetLocalSymInfo(string name)
public Type get_LocalType()
public bool get_IsPinned()
public int get_LocalIndex()
internal string get_Name()
internal int get_StartOffset()
internal int get_EndOffset()
private void System.Runtime.InteropServices._LocalBuilder.GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId)
private void System.Runtime.InteropServices._LocalBuilder.GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo)
private void System.Runtime.InteropServices._LocalBuilder.GetTypeInfoCount(UInt32& pcTInfo)
private void System.Runtime.InteropServices._LocalBuilder.Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr)
}
public System.Reflection.Emit.MethodBuilder : MethodInfo {
private RuntimeMethodHandle mhandle
private Type rtype
internal Type[] parameters
private MethodAttributes attrs
private MethodImplAttributes iattrs
private string name
private int table_idx
private Byte[] code
private ILGenerator ilgen
private TypeBuilder type
internal ParameterBuilder[] pinfo
private CustomAttributeBuilder[] cattrs
private MethodInfo[] override_methods
private string pi_dll
private string pi_entry
private CharSet charset
private UInt32 extra_flags
private CallingConvention native_cc
private CallingConventions call_conv
private bool init_locals
private IntPtr generic_container
internal GenericTypeParameterBuilder[] generic_params
private Type[] returnModReq
private Type[] returnModOpt
private Type[][] paramModReq
private Type[][] paramModOpt
private RefEmitPermissionSet[] permissions
public bool ContainsGenericParameters
public bool InitLocals
internal TypeBuilder TypeBuilder
public RuntimeMethodHandle MethodHandle
internal RuntimeMethodHandle MethodHandleInternal
public Type ReturnType
public Type ReflectedType
public Type DeclaringType
public string Name
public MethodAttributes Attributes
public ICustomAttributeProvider ReturnTypeCustomAttributes
public CallingConventions CallingConvention
public string Signature
internal bool BestFitMapping
internal bool ThrowOnUnmappableChar
internal bool ExactSpelling
internal bool SetLastError
public bool IsGenericMethodDefinition
public bool IsGenericMethod
public Module Module
public ParameterInfo ReturnParameter
internal void .ctor(TypeBuilder tb, string name, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] returnModReq, Type[] returnModOpt, Type[] parameterTypes, Type[][] paramModReq, Type[][] paramModOpt)
internal void .ctor(TypeBuilder tb, string name, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] returnModReq, Type[] returnModOpt, Type[] parameterTypes, Type[][] paramModReq, Type[][] paramModOpt, string dllName, string entryName, CallingConvention nativeCConv, CharSet nativeCharset)
public bool get_ContainsGenericParameters()
public bool get_InitLocals()
public void set_InitLocals(bool value)
internal TypeBuilder get_TypeBuilder()
public RuntimeMethodHandle get_MethodHandle()
internal RuntimeMethodHandle get_MethodHandleInternal()
public Type get_ReturnType()
public Type get_ReflectedType()
public Type get_DeclaringType()
public string get_Name()
public MethodAttributes get_Attributes()
public ICustomAttributeProvider get_ReturnTypeCustomAttributes()
public CallingConventions get_CallingConvention()
public string get_Signature()
internal void set_BestFitMapping(bool value)
internal void set_ThrowOnUnmappableChar(bool value)
internal void set_ExactSpelling(bool value)
internal void set_SetLastError(bool value)
public MethodToken GetToken()
public MethodInfo GetBaseDefinition()
public MethodImplAttributes GetMethodImplementationFlags()
public ParameterInfo[] GetParameters()
internal ParameterInfo[] GetParametersInternal()
internal int GetParametersCount()
internal Type GetParameterType(int pos)
internal MethodBase RuntimeResolve()
public Module GetModule()
public void CreateMethodBody(Byte[] il, int count)
public void SetMethodBody(Byte[] il, int maxStack, Byte[] localSignature, IEnumerable`1<ExceptionHandler> exceptionHandlers, IEnumerable`1<int> tokenFixups)
public object Invoke(object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture)
public bool IsDefined(Type attributeType, bool inherit)
public Object[] GetCustomAttributes(bool inherit)
public Object[] GetCustomAttributes(Type attributeType, bool inherit)
public ILGenerator GetILGenerator()
public ILGenerator GetILGenerator(int size)
public ParameterBuilder DefineParameter(int position, ParameterAttributes attributes, string strParamName)
internal void check_override()
internal void fixup()
internal void ResolveUserTypes()
internal void FixupTokens(Dictionary`2<int, int> token_map, Dictionary`2<int, MemberInfo> member_map)
internal void GenerateDebugInfo(ISymbolWriter symbolWriter)
public void SetCustomAttribute(CustomAttributeBuilder customBuilder)
public void SetCustomAttribute(ConstructorInfo con, Byte[] binaryAttribute)
public void SetImplementationFlags(MethodImplAttributes attributes)
public void AddDeclarativeSecurity(SecurityAction action, PermissionSet pset)
public void SetMarshal(UnmanagedMarshal unmanagedMarshal)
public void SetSymCustomAttribute(string name, Byte[] data)
public string ToString()
public bool Equals(object obj)
public int GetHashCode()
internal int get_next_table_index(object obj, int table, bool inc)
private void ExtendArray(T[]& array, T elem)
internal void set_override(MethodInfo mdecl)
private void RejectIfCreated()
private Exception NotSupported()
public MethodInfo MakeGenericMethod(Type[] typeArguments)
public bool get_IsGenericMethodDefinition()
public bool get_IsGenericMethod()
public MethodInfo GetGenericMethodDefinition()
public Type[] GetGenericArguments()
public GenericTypeParameterBuilder[] DefineGenericParameters(String[] names)
public void SetReturnType(Type returnType)
public void SetParameters(Type[] parameterTypes)
public void SetSignature(Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers)
public Module get_Module()
private void System.Runtime.InteropServices._MethodBuilder.GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId)
private void System.Runtime.InteropServices._MethodBuilder.GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo)
private void System.Runtime.InteropServices._MethodBuilder.GetTypeInfoCount(UInt32& pcTInfo)
private void System.Runtime.InteropServices._MethodBuilder.Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr)
public ParameterInfo get_ReturnParameter()
}
internal System.Reflection.Emit.MethodOnTypeBuilderInst : MethodInfo {
private Type instantiation
private MethodInfo base_method
private Type[] method_arguments
private MethodInfo generic_method_definition
public Type DeclaringType
public string Name
public Type ReflectedType
public Type ReturnType
public Module Module
public int MetadataToken
public RuntimeMethodHandle MethodHandle
public MethodAttributes Attributes
public CallingConventions CallingConvention
public bool ContainsGenericParameters
public bool IsGenericMethodDefinition
public bool IsGenericMethod
public ParameterInfo ReturnParameter
public ICustomAttributeProvider ReturnTypeCustomAttributes
public void .ctor(TypeBuilderInstantiation instantiation, MethodInfo base_method)
internal void .ctor(MethodOnTypeBuilderInst gmd, Type[] typeArguments)
internal void .ctor(MethodInfo method, Type[] typeArguments)
private MethodInfo ExtractBaseMethod(MethodInfo info)
internal Type[] GetTypeArgs()
internal MethodInfo RuntimeResolve()
public Type get_DeclaringType()
public string get_Name()
public Type get_ReflectedType()
public Type get_ReturnType()
public Module get_Module()
public bool IsDefined(Type attributeType, bool inherit)
public Object[] GetCustomAttributes(bool inherit)
public Object[] GetCustomAttributes(Type attributeType, bool inherit)
public string ToString()
public MethodImplAttributes GetMethodImplementationFlags()
public ParameterInfo[] GetParameters()
internal ParameterInfo[] GetParametersInternal()
public int get_MetadataToken()
internal int GetParametersCount()
public object Invoke(object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture)
public RuntimeMethodHandle get_MethodHandle()
public MethodAttributes get_Attributes()
public CallingConventions get_CallingConvention()
public MethodInfo MakeGenericMethod(Type[] methodInstantiation)
public Type[] GetGenericArguments()
public MethodInfo GetGenericMethodDefinition()
public bool get_ContainsGenericParameters()
public bool get_IsGenericMethodDefinition()
public bool get_IsGenericMethod()
public MethodInfo GetBaseDefinition()
public ParameterInfo get_ReturnParameter()
public ICustomAttributeProvider get_ReturnTypeCustomAttributes()
}
public System.Reflection.Emit.MethodRental : object {
public int JitImmediate
public int JitOnDemand
public void SwapMethodBody(Type cls, int methodtoken, IntPtr rgIL, int methodSize, int flags)
private void System.Runtime.InteropServices._MethodRental.GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId)
private void System.Runtime.InteropServices._MethodRental.GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo)
private void System.Runtime.InteropServices._MethodRental.GetTypeInfoCount(UInt32& pcTInfo)
private void System.Runtime.InteropServices._MethodRental.Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr)
}
public System.Reflection.Emit.MethodToken : ValueType {
internal int tokValue
public MethodToken Empty
public int Token
internal void .ctor(int val)
public bool Equals(object obj)
public bool Equals(MethodToken obj)
public bool op_Equality(MethodToken a, MethodToken b)
public bool op_Inequality(MethodToken a, MethodToken b)
public int GetHashCode()
public int get_Token()
}
public System.Reflection.Emit.ModuleBuilder : Module {
private UIntPtr dynamic_image
private int num_types
private TypeBuilder[] types
private CustomAttributeBuilder[] cattrs
private Byte[] guid
private int table_idx
internal AssemblyBuilder assemblyb
private MethodBuilder[] global_methods
private FieldBuilder[] global_fields
private bool is_main
private MonoResource[] resources
private IntPtr unparented_classes
private TypeBuilder global_type
private Type global_type_created
private Dictionary`2<TypeName, TypeBuilder> name_cache
private Dictionary`2<string, int> us_string_cache
private Int32[] table_indexes
private bool transient
private ModuleBuilderTokenGenerator token_gen
private Hashtable resource_writers
private ISymbolWriter symbolWriter
private bool has_warned_about_symbolWriter
private int typeref_tokengen
private int typedef_tokengen
private int typespec_tokengen
private int memberref_tokengen
private int methoddef_tokengen
private Dictionary`2<MemberInfo, int> inst_tokens
private Dictionary`2<MemberInfo, int> inst_tokens_open
public string FullyQualifiedName
internal string FileName
internal bool IsMain
public Assembly Assembly
public string Name
public string ScopeName
public Guid ModuleVersionId
public int MetadataToken
private void basic_init(ModuleBuilder ab)
private void set_wrappers_type(ModuleBuilder mb, Type ab)
internal void .ctor(AssemblyBuilder assb, string name, string fullyqname, bool emitSymbolInfo, bool transient)
private void WarnAboutSymbolWriter(string message)
public string get_FullyQualifiedName()
public bool IsTransient()
public void CreateGlobalFunctions()
public FieldBuilder DefineInitializedData(string name, Byte[] data, FieldAttributes attributes)
public FieldBuilder DefineUninitializedData(string name, int size, FieldAttributes attributes)
private FieldBuilder DefineDataImpl(string name, int size, FieldAttributes attributes)
private void addGlobalMethod(MethodBuilder mb)
public MethodBuilder DefineGlobalMethod(string name, MethodAttributes attributes, Type returnType, Type[] parameterTypes)
public MethodBuilder DefineGlobalMethod(string name, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] parameterTypes)
public MethodBuilder DefineGlobalMethod(string name, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] requiredReturnTypeCustomModifiers, Type[] optionalReturnTypeCustomModifiers, Type[] parameterTypes, Type[][] requiredParameterTypeCustomModifiers, Type[][] optionalParameterTypeCustomModifiers)
public MethodBuilder DefinePInvokeMethod(string name, string dllName, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] parameterTypes, CallingConvention nativeCallConv, CharSet nativeCharSet)
public MethodBuilder DefinePInvokeMethod(string name, string dllName, string entryName, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] parameterTypes, CallingConvention nativeCallConv, CharSet nativeCharSet)
public TypeBuilder DefineType(string name)
public TypeBuilder DefineType(string name, TypeAttributes attr)
public TypeBuilder DefineType(string name, TypeAttributes attr, Type parent)
private void AddType(TypeBuilder tb)
private TypeBuilder DefineType(string name, TypeAttributes attr, Type parent, Type[] interfaces, PackingSize packingSize, int typesize)
internal void RegisterTypeName(TypeBuilder tb, TypeName name)
internal TypeBuilder GetRegisteredType(TypeName name)
public TypeBuilder DefineType(string name, TypeAttributes attr, Type parent, Type[] interfaces)
public TypeBuilder DefineType(string name, TypeAttributes attr, Type parent, int typesize)
public TypeBuilder DefineType(string name, TypeAttributes attr, Type parent, PackingSize packsize)
public TypeBuilder DefineType(string name, TypeAttributes attr, Type parent, PackingSize packingSize, int typesize)
public MethodInfo GetArrayMethod(Type arrayClass, string methodName, CallingConventions callingConvention, Type returnType, Type[] parameterTypes)
public EnumBuilder DefineEnum(string name, TypeAttributes visibility, Type underlyingType)
public Type GetType(string className)
public Type GetType(string className, bool ignoreCase)
private TypeBuilder search_in_array(TypeBuilder[] arr, int validElementsInArray, TypeName className)
private TypeBuilder search_nested_in_array(TypeBuilder[] arr, int validElementsInArray, TypeName className)
private TypeBuilder GetMaybeNested(TypeBuilder t, IEnumerable`1<TypeName> nested)
public Type GetType(string className, bool throwOnError, bool ignoreCase)
internal int get_next_table_index(object obj, int table, bool inc)
public void SetCustomAttribute(CustomAttributeBuilder customBuilder)
public void SetCustomAttribute(ConstructorInfo con, Byte[] binaryAttribute)
public ISymbolWriter GetSymWriter()
public ISymbolDocumentWriter DefineDocument(string url, Guid language, Guid languageVendor, Guid documentType)
public Type[] GetTypes()
public IResourceWriter DefineResource(string name, string description, ResourceAttributes attribute)
public IResourceWriter DefineResource(string name, string description)
public void DefineUnmanagedResource(Byte[] resource)
public void DefineUnmanagedResource(string resourceFileName)
public void DefineManifestResource(string name, Stream stream, ResourceAttributes attribute)
public void SetSymCustomAttribute(string name, Byte[] data)
public void SetUserEntryPoint(MethodInfo entryPoint)
public MethodToken GetMethodToken(MethodInfo method)
public MethodToken GetMethodToken(MethodInfo method, IEnumerable`1<Type> optionalParameterTypes)
public MethodToken GetArrayMethodToken(Type arrayClass, string methodName, CallingConventions callingConvention, Type returnType, Type[] parameterTypes)
public MethodToken GetConstructorToken(ConstructorInfo con)
public MethodToken GetConstructorToken(ConstructorInfo constructor, IEnumerable`1<Type> optionalParameterTypes)
public FieldToken GetFieldToken(FieldInfo field)
public SignatureToken GetSignatureToken(Byte[] sigBytes, int sigLength)
public SignatureToken GetSignatureToken(SignatureHelper sigHelper)
public StringToken GetStringConstant(string str)
public TypeToken GetTypeToken(Type type)
public TypeToken GetTypeToken(string name)
private int getUSIndex(ModuleBuilder mb, string str)
private int getToken(ModuleBuilder mb, object obj, bool create_open_instance)
private int getMethodToken(ModuleBuilder mb, MethodBase method, Type[] opt_param_types)
internal int GetToken(string str)
private int GetPseudoToken(MemberInfo member, bool create_open_instance)
internal int GetToken(MemberInfo member)
internal int GetToken(MemberInfo member, bool create_open_instance)
internal int GetToken(MethodBase method, IEnumerable`1<Type> opt_param_types)
internal int GetToken(MethodBase method, Type[] opt_param_types)
internal int GetToken(SignatureHelper helper)
internal void RegisterToken(object obj, int token)
internal object GetRegisteredToken(int token)
internal TokenGenerator GetTokenGenerator()
internal object RuntimeResolve(object obj)
private void build_metadata(ModuleBuilder mb)
private void WriteToFile(IntPtr handle)
private void FixupTokens(Dictionary`2<int, int> token_map, Dictionary`2<int, MemberInfo> member_map, Dictionary`2<MemberInfo, int> inst_tokens, bool open)
private void FixupTokens()
internal void Save()
internal string get_FileName()
internal void set_IsMain(bool value)
internal void CreateGlobalType()
internal Guid GetModuleVersionId()
internal Guid Mono_GetGuid(ModuleBuilder mb)
private void System.Runtime.InteropServices._ModuleBuilder.GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId)
private void System.Runtime.InteropServices._ModuleBuilder.GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo)
private void System.Runtime.InteropServices._ModuleBuilder.GetTypeInfoCount(UInt32& pcTInfo)
private void System.Runtime.InteropServices._ModuleBuilder.Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr)
public Assembly get_Assembly()
public string get_Name()
public string get_ScopeName()
public Guid get_ModuleVersionId()
public bool IsResource()
protected MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers)
public FieldInfo ResolveField(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments)
public MemberInfo ResolveMember(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments)
internal MemberInfo ResolveOrGetRegisteredToken(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments)
public MethodBase ResolveMethod(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments)
public string ResolveString(int metadataToken)
public Byte[] ResolveSignature(int metadataToken)
public Type ResolveType(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments)
public bool Equals(object obj)
public int GetHashCode()
public bool IsDefined(Type attributeType, bool inherit)
public Object[] GetCustomAttributes(bool inherit)
public Object[] GetCustomAttributes(Type attributeType, bool inherit)
public FieldInfo GetField(string name, BindingFlags bindingAttr)
public FieldInfo[] GetFields(BindingFlags bindingFlags)
public MethodInfo[] GetMethods(BindingFlags bindingFlags)
public int get_MetadataToken()
}
internal System.Reflection.Emit.ModuleBuilderTokenGenerator : object {
private ModuleBuilder mb
public void .ctor(ModuleBuilder mb)
public int GetToken(string str)
public int GetToken(MemberInfo member, bool create_open_instance)
public int GetToken(MethodBase method, Type[] opt_param_types)
public int GetToken(SignatureHelper helper)
}
internal System.Reflection.Emit.MonoResource : ValueType {
public Byte[] data
public string name
public string filename
public ResourceAttributes attrs
public int offset
public Stream stream
}
internal System.Reflection.Emit.MonoWin32Resource : ValueType {
public int res_type
public int res_id
public int lang_id
public Byte[] data
public void .ctor(int res_type, int res_id, int lang_id, Byte[] data)
}
internal System.Reflection.Emit.NativeResourceType : Enum {
public int value__
public NativeResourceType None
public NativeResourceType Unmanaged
public NativeResourceType Assembly
public NativeResourceType Explicit
}
public System.Reflection.Emit.OpCode : ValueType {
internal byte op1
internal byte op2
private byte push
private byte pop
private byte size
private byte type
private byte args
private byte flow
public string Name
public int Size
public OpCodeType OpCodeType
public OperandType OperandType
public FlowControl FlowControl
public StackBehaviour StackBehaviourPop
public StackBehaviour StackBehaviourPush
public short Value
internal void .ctor(int p, int q)
public int GetHashCode()
public bool Equals(object obj)
public bool Equals(OpCode obj)
public string ToString()
public string get_Name()
public int get_Size()
public OpCodeType get_OpCodeType()
public OperandType get_OperandType()
public FlowControl get_FlowControl()
public StackBehaviour get_StackBehaviourPop()
public StackBehaviour get_StackBehaviourPush()
public short get_Value()
public bool op_Equality(OpCode a, OpCode b)
public bool op_Inequality(OpCode a, OpCode b)
}
internal System.Reflection.Emit.OpCodeNames : object {
internal String[] names
}
public System.Reflection.Emit.OpCodes : object {
public OpCode Nop
public OpCode Break
public OpCode Ldarg_0
public OpCode Ldarg_1
public OpCode Ldarg_2
public OpCode Ldarg_3
public OpCode Ldloc_0
public OpCode Ldloc_1
public OpCode Ldloc_2
public OpCode Ldloc_3
public OpCode Stloc_0
public OpCode Stloc_1
public OpCode Stloc_2
public OpCode Stloc_3
public OpCode Ldarg_S
public OpCode Ldarga_S
public OpCode Starg_S
public OpCode Ldloc_S
public OpCode Ldloca_S
public OpCode Stloc_S
public OpCode Ldnull
public OpCode Ldc_I4_M1
public OpCode Ldc_I4_0
public OpCode Ldc_I4_1
public OpCode Ldc_I4_2
public OpCode Ldc_I4_3
public OpCode Ldc_I4_4
public OpCode Ldc_I4_5
public OpCode Ldc_I4_6
public OpCode Ldc_I4_7
public OpCode Ldc_I4_8
public OpCode Ldc_I4_S
public OpCode Ldc_I4
public OpCode Ldc_I8
public OpCode Ldc_R4
public OpCode Ldc_R8
public OpCode Dup
public OpCode Pop
public OpCode Jmp
public OpCode Call
public OpCode Calli
public OpCode Ret
public OpCode Br_S
public OpCode Brfalse_S
public OpCode Brtrue_S
public OpCode Beq_S
public OpCode Bge_S
public OpCode Bgt_S
public OpCode Ble_S
public OpCode Blt_S
public OpCode Bne_Un_S
public OpCode Bge_Un_S
public OpCode Bgt_Un_S
public OpCode Ble_Un_S
public OpCode Blt_Un_S
public OpCode Br
public OpCode Brfalse
public OpCode Brtrue
public OpCode Beq
public OpCode Bge
public OpCode Bgt
public OpCode Ble
public OpCode Blt
public OpCode Bne_Un
public OpCode Bge_Un
public OpCode Bgt_Un
public OpCode Ble_Un
public OpCode Blt_Un
public OpCode Switch
public OpCode Ldind_I1
public OpCode Ldind_U1
public OpCode Ldind_I2
public OpCode Ldind_U2
public OpCode Ldind_I4
public OpCode Ldind_U4
public OpCode Ldind_I8
public OpCode Ldind_I
public OpCode Ldind_R4
public OpCode Ldind_R8
public OpCode Ldind_Ref
public OpCode Stind_Ref
public OpCode Stind_I1
public OpCode Stind_I2
public OpCode Stind_I4
public OpCode Stind_I8
public OpCode Stind_R4
public OpCode Stind_R8
public OpCode Add
public OpCode Sub
public OpCode Mul
public OpCode Div
public OpCode Div_Un
public OpCode Rem
public OpCode Rem_Un
public OpCode And
public OpCode Or
public OpCode Xor
public OpCode Shl
public OpCode Shr
public OpCode Shr_Un
public OpCode Neg
public OpCode Not
public OpCode Conv_I1
public OpCode Conv_I2
public OpCode Conv_I4
public OpCode Conv_I8
public OpCode Conv_R4
public OpCode Conv_R8
public OpCode Conv_U4
public OpCode Conv_U8
public OpCode Callvirt
public OpCode Cpobj
public OpCode Ldobj
public OpCode Ldstr
public OpCode Newobj
public OpCode Castclass
public OpCode Isinst
public OpCode Conv_R_Un
public OpCode Unbox
public OpCode Throw
public OpCode Ldfld
public OpCode Ldflda
public OpCode Stfld
public OpCode Ldsfld
public OpCode Ldsflda
public OpCode Stsfld
public OpCode Stobj
public OpCode Conv_Ovf_I1_Un
public OpCode Conv_Ovf_I2_Un
public OpCode Conv_Ovf_I4_Un
public OpCode Conv_Ovf_I8_Un
public OpCode Conv_Ovf_U1_Un
public OpCode Conv_Ovf_U2_Un
public OpCode Conv_Ovf_U4_Un
public OpCode Conv_Ovf_U8_Un
public OpCode Conv_Ovf_I_Un
public OpCode Conv_Ovf_U_Un
public OpCode Box
public OpCode Newarr
public OpCode Ldlen
public OpCode Ldelema
public OpCode Ldelem_I1
public OpCode Ldelem_U1
public OpCode Ldelem_I2
public OpCode Ldelem_U2
public OpCode Ldelem_I4
public OpCode Ldelem_U4
public OpCode Ldelem_I8
public OpCode Ldelem_I
public OpCode Ldelem_R4
public OpCode Ldelem_R8
public OpCode Ldelem_Ref
public OpCode Stelem_I
public OpCode Stelem_I1
public OpCode Stelem_I2
public OpCode Stelem_I4
public OpCode Stelem_I8
public OpCode Stelem_R4
public OpCode Stelem_R8
public OpCode Stelem_Ref
public OpCode Ldelem
public OpCode Stelem
public OpCode Unbox_Any
public OpCode Conv_Ovf_I1
public OpCode Conv_Ovf_U1
public OpCode Conv_Ovf_I2
public OpCode Conv_Ovf_U2
public OpCode Conv_Ovf_I4
public OpCode Conv_Ovf_U4
public OpCode Conv_Ovf_I8
public OpCode Conv_Ovf_U8
public OpCode Refanyval
public OpCode Ckfinite
public OpCode Mkrefany
public OpCode Ldtoken
public OpCode Conv_U2
public OpCode Conv_U1
public OpCode Conv_I
public OpCode Conv_Ovf_I
public OpCode Conv_Ovf_U
public OpCode Add_Ovf
public OpCode Add_Ovf_Un
public OpCode Mul_Ovf
public OpCode Mul_Ovf_Un
public OpCode Sub_Ovf
public OpCode Sub_Ovf_Un
public OpCode Endfinally
public OpCode Leave
public OpCode Leave_S
public OpCode Stind_I
public OpCode Conv_U
public OpCode Prefix7
public OpCode Prefix6
public OpCode Prefix5
public OpCode Prefix4
public OpCode Prefix3
public OpCode Prefix2
public OpCode Prefix1
public OpCode Prefixref
public OpCode Arglist
public OpCode Ceq
public OpCode Cgt
public OpCode Cgt_Un
public OpCode Clt
public OpCode Clt_Un
public OpCode Ldftn
public OpCode Ldvirtftn
public OpCode Ldarg
public OpCode Ldarga
public OpCode Starg
public OpCode Ldloc
public OpCode Ldloca
public OpCode Stloc
public OpCode Localloc
public OpCode Endfilter
public OpCode Unaligned
public OpCode Volatile
public OpCode Tailcall
public OpCode Initobj
public OpCode Constrained
public OpCode Cpblk
public OpCode Initblk
public OpCode Rethrow
public OpCode Sizeof
public OpCode Refanytype
public OpCode Readonly
public bool TakesSingleByteArgument(OpCode inst)
}
public System.Reflection.Emit.OpCodeType : Enum {
public int value__
public OpCodeType Annotation
public OpCodeType Macro
public OpCodeType Nternal
public OpCodeType Objmodel
public OpCodeType Prefix
public OpCodeType Primitive
}
public System.Reflection.Emit.OperandType : Enum {
public int value__
public OperandType InlineBrTarget
public OperandType InlineField
public OperandType InlineI
public OperandType InlineI8
public OperandType InlineMethod
public OperandType InlineNone
public OperandType InlinePhi
public OperandType InlineR
public OperandType InlineSig
public OperandType InlineString
public OperandType InlineSwitch
public OperandType InlineTok
public OperandType InlineType
public OperandType InlineVar
public OperandType ShortInlineBrTarget
public OperandType ShortInlineI
public OperandType ShortInlineR
public OperandType ShortInlineVar
}
public System.Reflection.Emit.PackingSize : Enum {
public int value__
public PackingSize Unspecified
public PackingSize Size1
public PackingSize Size2
public PackingSize Size4
public PackingSize Size8
public PackingSize Size16
public PackingSize Size32
public PackingSize Size64
public PackingSize Size128
}
public System.Reflection.Emit.ParameterBuilder : object {
private MethodBase methodb
private string name
private CustomAttributeBuilder[] cattrs
private UnmanagedMarshal marshal_info
private ParameterAttributes attrs
private int position
private int table_idx
private object def_value
public int Attributes
public bool IsIn
public bool IsOut
public bool IsOptional
public string Name
public int Position
internal void .ctor(MethodBase mb, int pos, ParameterAttributes attributes, string strParamName)
public int get_Attributes()
public bool get_IsIn()
public bool get_IsOut()
public bool get_IsOptional()
public string get_Name()
public int get_Position()
public ParameterToken GetToken()
public void SetConstant(object defaultValue)
public void SetCustomAttribute(CustomAttributeBuilder customBuilder)
public void SetCustomAttribute(ConstructorInfo con, Byte[] binaryAttribute)
public void SetMarshal(UnmanagedMarshal unmanagedMarshal)
private void System.Runtime.InteropServices._ParameterBuilder.GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId)
private void System.Runtime.InteropServices._ParameterBuilder.GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo)
private void System.Runtime.InteropServices._ParameterBuilder.GetTypeInfoCount(UInt32& pcTInfo)
private void System.Runtime.InteropServices._ParameterBuilder.Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr)
}
public System.Reflection.Emit.ParameterToken : ValueType {
internal int tokValue
public ParameterToken Empty
public int Token
internal void .ctor(int val)
public bool Equals(object obj)
public bool Equals(ParameterToken obj)
public bool op_Equality(ParameterToken a, ParameterToken b)
public bool op_Inequality(ParameterToken a, ParameterToken b)
public int GetHashCode()
public int get_Token()
}
public System.Reflection.Emit.PEFileKinds : Enum {
public int value__
public PEFileKinds Dll
public PEFileKinds ConsoleApplication
public PEFileKinds WindowApplication
}
internal System.Reflection.Emit.PointerType : SymbolType {
internal void .ctor(Type elementType)
internal Type InternalResolve()
protected bool IsPointerImpl()
internal string FormatName(string elementName)
}
public System.Reflection.Emit.PropertyBuilder : PropertyInfo {
private PropertyAttributes attrs
private string name
private Type type
private Type[] parameters
private CustomAttributeBuilder[] cattrs
private object def_value
private MethodBuilder set_method
private MethodBuilder get_method
private int table_idx
internal TypeBuilder typeb
private Type[] returnModReq
private Type[] returnModOpt
private Type[][] paramModReq
private Type[][] paramModOpt
private CallingConventions callingConvention
public PropertyAttributes Attributes
public bool CanRead
public bool CanWrite
public Type DeclaringType
public string Name
public PropertyToken PropertyToken
public Type PropertyType
public Type ReflectedType
public Module Module
internal void .ctor(TypeBuilder tb, string name, PropertyAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] returnModReq, Type[] returnModOpt, Type[] parameterTypes, Type[][] paramModReq, Type[][] paramModOpt)
public PropertyAttributes get_Attributes()
public bool get_CanRead()
public bool get_CanWrite()
public Type get_DeclaringType()
public string get_Name()
public PropertyToken get_PropertyToken()
public Type get_PropertyType()
public Type get_ReflectedType()
public void AddOtherMethod(MethodBuilder mdBuilder)
public MethodInfo[] GetAccessors(bool nonPublic)
public Object[] GetCustomAttributes(bool inherit)
public Object[] GetCustomAttributes(Type attributeType, bool inherit)
public MethodInfo GetGetMethod(bool nonPublic)
public ParameterInfo[] GetIndexParameters()
public MethodInfo GetSetMethod(bool nonPublic)
public object GetValue(object obj, Object[] index)
public object GetValue(object obj, BindingFlags invokeAttr, Binder binder, Object[] index, CultureInfo culture)
public bool IsDefined(Type attributeType, bool inherit)
public void SetConstant(object defaultValue)
public void SetCustomAttribute(CustomAttributeBuilder customBuilder)
public void SetCustomAttribute(ConstructorInfo con, Byte[] binaryAttribute)
public void SetGetMethod(MethodBuilder mdBuilder)
public void SetSetMethod(MethodBuilder mdBuilder)
public void SetValue(object obj, object value, Object[] index)
public void SetValue(object obj, object value, BindingFlags invokeAttr, Binder binder, Object[] index, CultureInfo culture)
public Module get_Module()
private void System.Runtime.InteropServices._PropertyBuilder.GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId)
private void System.Runtime.InteropServices._PropertyBuilder.GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo)
private void System.Runtime.InteropServices._PropertyBuilder.GetTypeInfoCount(UInt32& pcTInfo)
private void System.Runtime.InteropServices._PropertyBuilder.Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr)
private Exception not_supported()
}
internal System.Reflection.Emit.PropertyOnTypeBuilderInst : PropertyInfo {
private TypeBuilderInstantiation instantiation
private PropertyInfo prop
public PropertyAttributes Attributes
public bool CanRead
public bool CanWrite
public Type PropertyType
public Type DeclaringType
public Type ReflectedType
public string Name
internal void .ctor(TypeBuilderInstantiation instantiation, PropertyInfo prop)
public PropertyAttributes get_Attributes()
public bool get_CanRead()
public bool get_CanWrite()
public Type get_PropertyType()
public Type get_DeclaringType()
public Type get_ReflectedType()
public string get_Name()
public MethodInfo[] GetAccessors(bool nonPublic)
public MethodInfo GetGetMethod(bool nonPublic)
public ParameterInfo[] GetIndexParameters()
public MethodInfo GetSetMethod(bool nonPublic)
public string ToString()
public object GetValue(object obj, BindingFlags invokeAttr, Binder binder, Object[] index, CultureInfo culture)
public void SetValue(object obj, object value, BindingFlags invokeAttr, Binder binder, Object[] index, CultureInfo culture)
public bool IsDefined(Type attributeType, bool inherit)
public Object[] GetCustomAttributes(bool inherit)
public Object[] GetCustomAttributes(Type attributeType, bool inherit)
}
public System.Reflection.Emit.PropertyToken : ValueType {
internal int tokValue
public PropertyToken Empty
public int Token
internal void .ctor(int val)
public bool Equals(object obj)
public bool Equals(PropertyToken obj)
public bool op_Equality(PropertyToken a, PropertyToken b)
public bool op_Inequality(PropertyToken a, PropertyToken b)
public int GetHashCode()
public int get_Token()
}
internal System.Reflection.Emit.RefEmitPermissionSet : ValueType {
public SecurityAction action
public string pset
public void .ctor(SecurityAction action, string pset)
}
internal System.Reflection.Emit.SequencePoint : ValueType {
public int Offset
public int Line
public int Col
public int EndLine
public int EndCol
}
internal System.Reflection.Emit.SequencePointList : object {
private ISymbolDocumentWriter doc
private SequencePoint[] points
private int count
private int arrayGrow
public ISymbolDocumentWriter Document
public int StartLine
public int EndLine
public int StartColumn
public int EndColumn
public void .ctor(ISymbolDocumentWriter doc)
public ISymbolDocumentWriter get_Document()
public Int32[] GetOffsets()
public Int32[] GetLines()
public Int32[] GetColumns()
public Int32[] GetEndLines()
public Int32[] GetEndColumns()
public int get_StartLine()
public int get_EndLine()
public int get_StartColumn()
public int get_EndColumn()
public void AddSequencePoint(int offset, int line, int col, int endLine, int endCol)
}
public System.Reflection.Emit.SignatureHelper : object {
private ModuleBuilder module
private Type[] arguments
private SignatureHelperType type
private Type returnType
private CallingConventions callConv
private CallingConvention unmanagedCallConv
private Type[][] modreqs
private Type[][] modopts
internal void .ctor(ModuleBuilder module, SignatureHelperType type)
public SignatureHelper GetFieldSigHelper(Module mod)
public SignatureHelper GetLocalVarSigHelper(Module mod)
public SignatureHelper GetLocalVarSigHelper()
public SignatureHelper GetMethodSigHelper(CallingConventions callingConvention, Type returnType)
public SignatureHelper GetMethodSigHelper(CallingConvention unmanagedCallingConvention, Type returnType)
public SignatureHelper GetMethodSigHelper(Module mod, CallingConventions callingConvention, Type returnType)
public SignatureHelper GetMethodSigHelper(Module mod, CallingConvention unmanagedCallConv, Type returnType)
public SignatureHelper GetMethodSigHelper(Module mod, Type returnType, Type[] parameterTypes)
public SignatureHelper GetPropertySigHelper(Module mod, Type returnType, Type[] parameterTypes)
public SignatureHelper GetPropertySigHelper(Module mod, Type returnType, Type[] requiredReturnTypeCustomModifiers, Type[] optionalReturnTypeCustomModifiers, Type[] parameterTypes, Type[][] requiredParameterTypeCustomModifiers, Type[][] optionalParameterTypeCustomModifiers)
public SignatureHelper GetPropertySigHelper(Module mod, CallingConventions callingConvention, Type returnType, Type[] requiredReturnTypeCustomModifiers, Type[] optionalReturnTypeCustomModifiers, Type[] parameterTypes, Type[][] requiredParameterTypeCustomModifiers, Type[][] optionalParameterTypeCustomModifiers)
private int AppendArray(Type[]& array, Type t)
private void AppendArrayAt(Type[][]& array, Type[] t, int pos)
private void ValidateParameterModifiers(string name, Type[] parameter_modifiers)
private void ValidateCustomModifier(int n, Type[][] custom_modifiers, string name)
private Exception MissingFeature()
public void AddArguments(Type[] arguments, Type[][] requiredCustomModifiers, Type[][] optionalCustomModifiers)
public void AddArgument(Type argument, bool pinned)
public void AddArgument(Type argument, Type[] requiredCustomModifiers, Type[] optionalCustomModifiers)
public void AddArgument(Type clsArgument)
public void AddSentinel()
private bool CompareOK(Type[][] one, Type[][] two)
public bool Equals(object obj)
public int GetHashCode()
internal Byte[] get_signature_local()
internal Byte[] get_signature_field()
public Byte[] GetSignature()
public string ToString()
internal SignatureHelper GetMethodSigHelper(Module mod, CallingConventions callingConvention, CallingConvention unmanagedCallingConvention, Type returnType, Type[] parameters)
private void System.Runtime.InteropServices._SignatureHelper.GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId)
private void System.Runtime.InteropServices._SignatureHelper.GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo)
private void System.Runtime.InteropServices._SignatureHelper.GetTypeInfoCount(UInt32& pcTInfo)
private void System.Runtime.InteropServices._SignatureHelper.Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr)
}
public System.Reflection.Emit.SignatureToken : ValueType {
internal int tokValue
public SignatureToken Empty
public int Token
internal void .ctor(int val)
public bool Equals(object obj)
public bool Equals(SignatureToken obj)
public bool op_Equality(SignatureToken a, SignatureToken b)
public bool op_Inequality(SignatureToken a, SignatureToken b)
public int GetHashCode()
public int get_Token()
}
public System.Reflection.Emit.StackBehaviour : Enum {
public int value__
public StackBehaviour Pop0
public StackBehaviour Pop1
public StackBehaviour Pop1_pop1
public StackBehaviour Popi
public StackBehaviour Popi_pop1
public StackBehaviour Popi_popi
public StackBehaviour Popi_popi8
public StackBehaviour Popi_popi_popi
public StackBehaviour Popi_popr4
public StackBehaviour Popi_popr8
public StackBehaviour Popref
public StackBehaviour Popref_pop1
public StackBehaviour Popref_popi
public StackBehaviour Popref_popi_popi
public StackBehaviour Popref_popi_popi8
public StackBehaviour Popref_popi_popr4
public StackBehaviour Popref_popi_popr8
public StackBehaviour Popref_popi_popref
public StackBehaviour Push0
public StackBehaviour Push1
public StackBehaviour Push1_push1
public StackBehaviour Pushi
public StackBehaviour Pushi8
public StackBehaviour Pushr4
public StackBehaviour Pushr8
public StackBehaviour Pushref
public StackBehaviour Varpop
public StackBehaviour Varpush
public StackBehaviour Popref_popi_pop1
}
public System.Reflection.Emit.StringToken : ValueType {
internal int tokValue
public int Token
internal void .ctor(int val)
public bool Equals(object obj)
public bool Equals(StringToken obj)
public bool op_Equality(StringToken a, StringToken b)
public bool op_Inequality(StringToken a, StringToken b)
public int GetHashCode()
public int get_Token()
}
internal System.Reflection.Emit.SymbolType : TypeInfo {
internal Type m_baseType
public Guid GUID
public Module Module
public Assembly Assembly
public RuntimeTypeHandle TypeHandle
public string Namespace
public Type BaseType
public bool IsConstructedGenericType
public string AssemblyQualifiedName
public string FullName
public string Name
public Type UnderlyingSystemType
internal bool IsUserType
public bool IsAssignableFrom(TypeInfo typeInfo)
public Guid get_GUID()
public object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, Object[] args, ParameterModifier[] modifiers, CultureInfo culture, String[] namedParameters)
public Module get_Module()
public Assembly get_Assembly()
public RuntimeTypeHandle get_TypeHandle()
public string get_Namespace()
public Type get_BaseType()
protected ConstructorInfo GetConstructorImpl(BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers)
public ConstructorInfo[] GetConstructors(BindingFlags bindingAttr)
protected MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers)
public MethodInfo[] GetMethods(BindingFlags bindingAttr)
public FieldInfo GetField(string name, BindingFlags bindingAttr)
public FieldInfo[] GetFields(BindingFlags bindingAttr)
public Type GetInterface(string name, bool ignoreCase)
public Type[] GetInterfaces()
public EventInfo GetEvent(string name, BindingFlags bindingAttr)
public EventInfo[] GetEvents()
protected PropertyInfo GetPropertyImpl(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers)
public PropertyInfo[] GetProperties(BindingFlags bindingAttr)
public Type[] GetNestedTypes(BindingFlags bindingAttr)
public Type GetNestedType(string name, BindingFlags bindingAttr)
public MemberInfo[] GetMember(string name, MemberTypes type, BindingFlags bindingAttr)
public MemberInfo[] GetMembers(BindingFlags bindingAttr)
public InterfaceMapping GetInterfaceMap(Type interfaceType)
public EventInfo[] GetEvents(BindingFlags bindingAttr)
protected TypeAttributes GetAttributeFlagsImpl()
protected bool IsPrimitiveImpl()
protected bool IsValueTypeImpl()
protected bool IsCOMObjectImpl()
public bool get_IsConstructedGenericType()
public Type GetElementType()
protected bool HasElementTypeImpl()
public Object[] GetCustomAttributes(bool inherit)
public Object[] GetCustomAttributes(Type attributeType, bool inherit)
public bool IsDefined(Type attributeType, bool inherit)
internal void .ctor(Type elementType)
internal string FormatName(string elementName)
protected bool IsArrayImpl()
protected bool IsByRefImpl()
protected bool IsPointerImpl()
public Type MakeArrayType()
public Type MakeArrayType(int rank)
public Type MakeByRefType()
public Type MakePointerType()
public string ToString()
public string get_AssemblyQualifiedName()
public string get_FullName()
public string get_Name()
public Type get_UnderlyingSystemType()
internal bool get_IsUserType()
internal Type RuntimeResolve()
}
internal System.Reflection.Emit.TokenGenerator {
public int GetToken(string str)
public int GetToken(MemberInfo member, bool create_open_instance)
public int GetToken(MethodBase method, Type[] opt_param_types)
public int GetToken(SignatureHelper helper)
}
public System.Reflection.Emit.TypeBuilder : TypeInfo {
private string tname
private string nspace
private Type parent
private Type nesting_type
internal Type[] interfaces
internal int num_methods
internal MethodBuilder[] methods
internal ConstructorBuilder[] ctors
internal PropertyBuilder[] properties
internal int num_fields
internal FieldBuilder[] fields
internal EventBuilder[] events
private CustomAttributeBuilder[] cattrs
internal TypeBuilder[] subtypes
internal TypeAttributes attrs
private int table_idx
private ModuleBuilder pmodule
private int class_size
private PackingSize packing_size
private IntPtr generic_container
private GenericTypeParameterBuilder[] generic_params
private RefEmitPermissionSet[] permissions
private TypeInfo created
private int state
private TypeName fullname
private bool createTypeCalled
private Type underlying_type
public int UnspecifiedTypeSize
public Assembly Assembly
public string AssemblyQualifiedName
public Type BaseType
public Type DeclaringType
public Type UnderlyingSystemType
public string FullName
public Guid GUID
public Module Module
public string Name
public string Namespace
public PackingSize PackingSize
public int Size
public Type ReflectedType
public RuntimeTypeHandle TypeHandle
public TypeToken TypeToken
internal bool is_created
public bool ContainsGenericParameters
public bool IsGenericParameter
public GenericParameterAttributes GenericParameterAttributes
public bool IsGenericTypeDefinition
public bool IsGenericType
public int GenericParameterPosition
public MethodBase DeclaringMethod
internal bool IsUserType
public bool IsConstructedGenericType
protected TypeAttributes GetAttributeFlagsImpl()
internal void .ctor(ModuleBuilder mb, TypeAttributes attr, int table_idx)
internal void .ctor(ModuleBuilder mb, string name, TypeAttributes attr, Type parent, Type[] interfaces, PackingSize packing_size, int type_size, Type nesting_type)
public Assembly get_Assembly()
public string get_AssemblyQualifiedName()
public Type get_BaseType()
public Type get_DeclaringType()
public bool IsSubclassOf(Type c)
public Type get_UnderlyingSystemType()
private TypeName GetFullName()
public string get_FullName()
public Guid get_GUID()
public Module get_Module()
public string get_Name()
public string get_Namespace()
public PackingSize get_PackingSize()
public int get_Size()
public Type get_ReflectedType()
public void AddDeclarativeSecurity(SecurityAction action, PermissionSet pset)
public void AddInterfaceImplementation(Type interfaceType)
protected ConstructorInfo GetConstructorImpl(BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers)
public bool IsDefined(Type attributeType, bool inherit)
public Object[] GetCustomAttributes(bool inherit)
public Object[] GetCustomAttributes(Type attributeType, bool inherit)
public TypeBuilder DefineNestedType(string name)
public TypeBuilder DefineNestedType(string name, TypeAttributes attr)
public TypeBuilder DefineNestedType(string name, TypeAttributes attr, Type parent)
private TypeBuilder DefineNestedType(string name, TypeAttributes attr, Type parent, Type[] interfaces, PackingSize packSize, int typeSize)
public TypeBuilder DefineNestedType(string name, TypeAttributes attr, Type parent, Type[] interfaces)
public TypeBuilder DefineNestedType(string name, TypeAttributes attr, Type parent, int typeSize)
public TypeBuilder DefineNestedType(string name, TypeAttributes attr, Type parent, PackingSize packSize)
public TypeBuilder DefineNestedType(string name, TypeAttributes attr, Type parent, PackingSize packSize, int typeSize)
public ConstructorBuilder DefineConstructor(MethodAttributes attributes, CallingConventions callingConvention, Type[] parameterTypes)
public ConstructorBuilder DefineConstructor(MethodAttributes attributes, CallingConventions callingConvention, Type[] parameterTypes, Type[][] requiredCustomModifiers, Type[][] optionalCustomModifiers)
public ConstructorBuilder DefineDefaultConstructor(MethodAttributes attributes)
private void append_method(MethodBuilder mb)
public MethodBuilder DefineMethod(string name, MethodAttributes attributes, Type returnType, Type[] parameterTypes)
public MethodBuilder DefineMethod(string name, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] parameterTypes)
public MethodBuilder DefineMethod(string name, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers)
public MethodBuilder DefinePInvokeMethod(string name, string dllName, string entryName, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] parameterTypes, CallingConvention nativeCallConv, CharSet nativeCharSet)
public MethodBuilder DefinePInvokeMethod(string name, string dllName, string entryName, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers, CallingConvention nativeCallConv, CharSet nativeCharSet)
public MethodBuilder DefinePInvokeMethod(string name, string dllName, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] parameterTypes, CallingConvention nativeCallConv, CharSet nativeCharSet)
public MethodBuilder DefineMethod(string name, MethodAttributes attributes)
public MethodBuilder DefineMethod(string name, MethodAttributes attributes, CallingConventions callingConvention)
public void DefineMethodOverride(MethodInfo methodInfoBody, MethodInfo methodInfoDeclaration)
public FieldBuilder DefineField(string fieldName, Type type, FieldAttributes attributes)
public FieldBuilder DefineField(string fieldName, Type type, Type[] requiredCustomModifiers, Type[] optionalCustomModifiers, FieldAttributes attributes)
public PropertyBuilder DefineProperty(string name, PropertyAttributes attributes, Type returnType, Type[] parameterTypes)
public PropertyBuilder DefineProperty(string name, PropertyAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] parameterTypes)
public PropertyBuilder DefineProperty(string name, PropertyAttributes attributes, Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers)
public PropertyBuilder DefineProperty(string name, PropertyAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers)
public ConstructorBuilder DefineTypeInitializer()
private TypeInfo create_runtime_class()
private bool is_nested_in(Type t)
private bool has_ctor_method()
public Type CreateType()
public TypeInfo CreateTypeInfo()
private void ResolveUserTypes()
internal void ResolveUserTypes(Type[] types)
internal Type ResolveUserType(Type t)
internal void FixupTokens(Dictionary`2<int, int> token_map, Dictionary`2<int, MemberInfo> member_map)
internal void GenerateDebugInfo(ISymbolWriter symbolWriter)
public ConstructorInfo[] GetConstructors(BindingFlags bindingAttr)
internal ConstructorInfo[] GetConstructorsInternal(BindingFlags bindingAttr)
public Type GetElementType()
public EventInfo GetEvent(string name, BindingFlags bindingAttr)
public EventInfo[] GetEvents()
public EventInfo[] GetEvents(BindingFlags bindingAttr)
public FieldInfo GetField(string name, BindingFlags bindingAttr)
public FieldInfo[] GetFields(BindingFlags bindingAttr)
public Type GetInterface(string name, bool ignoreCase)
public Type[] GetInterfaces()
public MemberInfo[] GetMember(string name, MemberTypes type, BindingFlags bindingAttr)
public MemberInfo[] GetMembers(BindingFlags bindingAttr)
private MethodInfo[] GetMethodsByName(string name, BindingFlags bindingAttr, bool ignoreCase, Type reflected_type)
public MethodInfo[] GetMethods(BindingFlags bindingAttr)
protected MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers)
public Type GetNestedType(string name, BindingFlags bindingAttr)
public Type[] GetNestedTypes(BindingFlags bindingAttr)
public PropertyInfo[] GetProperties(BindingFlags bindingAttr)
protected PropertyInfo GetPropertyImpl(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers)
protected bool HasElementTypeImpl()
public object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, Object[] args, ParameterModifier[] modifiers, CultureInfo culture, String[] namedParameters)
protected bool IsArrayImpl()
protected bool IsByRefImpl()
protected bool IsCOMObjectImpl()
protected bool IsPointerImpl()
protected bool IsPrimitiveImpl()
protected bool IsValueTypeImpl()
public Type MakeArrayType()
public Type MakeArrayType(int rank)
public Type MakeByRefType()
public Type MakeGenericType(Type[] typeArguments)
public Type MakePointerType()
public RuntimeTypeHandle get_TypeHandle()
public void SetCustomAttribute(CustomAttributeBuilder customBuilder)
public void SetCustomAttribute(ConstructorInfo con, Byte[] binaryAttribute)
public EventBuilder DefineEvent(string name, EventAttributes attributes, Type eventtype)
public FieldBuilder DefineInitializedData(string name, Byte[] data, FieldAttributes attributes)
public FieldBuilder DefineUninitializedData(string name, int size, FieldAttributes attributes)
public TypeToken get_TypeToken()
public void SetParent(Type parent)
internal int get_next_table_index(object obj, int table, bool inc)
public InterfaceMapping GetInterfaceMap(Type interfaceType)
internal Type InternalResolve()
internal Type RuntimeResolve()
internal bool get_is_created()
private Exception not_supported()
private void check_not_created()
private void check_created()
private void check_name(string argName, string name)
public string ToString()
public bool IsAssignableFrom(Type c)
internal bool IsAssignableTo(Type c)
public bool IsCreated()
public Type[] GetGenericArguments()
public Type GetGenericTypeDefinition()
public bool get_ContainsGenericParameters()
public bool get_IsGenericParameter()
public GenericParameterAttributes get_GenericParameterAttributes()
public bool get_IsGenericTypeDefinition()
public bool get_IsGenericType()
public int get_GenericParameterPosition()
public MethodBase get_DeclaringMethod()
public GenericTypeParameterBuilder[] DefineGenericParameters(String[] names)
public ConstructorInfo GetConstructor(Type type, ConstructorInfo constructor)
private bool IsValidGetMethodType(Type type)
public MethodInfo GetMethod(Type type, MethodInfo method)
public FieldInfo GetField(Type type, FieldInfo field)
private void System.Runtime.InteropServices._TypeBuilder.GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId)
private void System.Runtime.InteropServices._TypeBuilder.GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo)
private void System.Runtime.InteropServices._TypeBuilder.GetTypeInfoCount(UInt32& pcTInfo)
private void System.Runtime.InteropServices._TypeBuilder.Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr)
internal bool get_IsUserType()
public bool get_IsConstructedGenericType()
public bool IsAssignableFrom(TypeInfo typeInfo)
}
internal System.Reflection.Emit.TypeBuilderInstantiation : TypeInfo {
internal Type generic_type
private Type[] type_arguments
private Hashtable fields
private Hashtable ctors
private Hashtable methods
private BindingFlags flags
internal bool IsCreated
public Type BaseType
public Type UnderlyingSystemType
public Assembly Assembly
public Module Module
public string Name
public string Namespace
public string FullName
public string AssemblyQualifiedName
public Guid GUID
public bool ContainsGenericParameters
public bool IsGenericTypeDefinition
public bool IsGenericType
public Type DeclaringType
public RuntimeTypeHandle TypeHandle
internal bool IsUserType
internal void .ctor(Type tb, Type[] args)
internal Type InternalResolve()
internal Type RuntimeResolve()
internal bool get_IsCreated()
private Type GetParentType()
internal Type InflateType(Type type)
internal Type InflateType(Type type, Type[] method_args)
internal Type InflateType(Type type, Type[] type_args, Type[] method_args)
public Type get_BaseType()
public Type[] GetInterfaces()
protected bool IsValueTypeImpl()
internal MethodInfo GetMethod(MethodInfo fromNoninstanciated)
internal ConstructorInfo GetConstructor(ConstructorInfo fromNoninstanciated)
internal FieldInfo GetField(FieldInfo fromNoninstanciated)
public MethodInfo[] GetMethods(BindingFlags bf)
public ConstructorInfo[] GetConstructors(BindingFlags bf)
public FieldInfo[] GetFields(BindingFlags bf)
public PropertyInfo[] GetProperties(BindingFlags bf)
public EventInfo[] GetEvents(BindingFlags bf)
public Type[] GetNestedTypes(BindingFlags bf)
public bool IsAssignableFrom(Type c)
public Type get_UnderlyingSystemType()
public Assembly get_Assembly()
public Module get_Module()
public string get_Name()
public string get_Namespace()
public string get_FullName()
public string get_AssemblyQualifiedName()
public Guid get_GUID()
private string format_name(bool full_name, bool assembly_qualified)
public string ToString()
public Type GetGenericTypeDefinition()
public Type[] GetGenericArguments()
public bool get_ContainsGenericParameters()
public bool get_IsGenericTypeDefinition()
public bool get_IsGenericType()
public Type get_DeclaringType()
public RuntimeTypeHandle get_TypeHandle()
public Type MakeArrayType()
public Type MakeArrayType(int rank)
public Type MakeByRefType()
public Type MakePointerType()
public Type GetElementType()
protected bool HasElementTypeImpl()
protected bool IsCOMObjectImpl()
protected bool IsPrimitiveImpl()
protected bool IsArrayImpl()
protected bool IsByRefImpl()
protected bool IsPointerImpl()
protected TypeAttributes GetAttributeFlagsImpl()
public Type GetInterface(string name, bool ignoreCase)
public EventInfo GetEvent(string name, BindingFlags bindingAttr)
public FieldInfo GetField(string name, BindingFlags bindingAttr)
public MemberInfo[] GetMembers(BindingFlags bindingAttr)
public Type GetNestedType(string name, BindingFlags bindingAttr)
public object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, Object[] args, ParameterModifier[] modifiers, CultureInfo culture, String[] namedParameters)
protected MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers)
protected PropertyInfo GetPropertyImpl(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers)
protected ConstructorInfo GetConstructorImpl(BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers)
public bool IsDefined(Type attributeType, bool inherit)
public Object[] GetCustomAttributes(bool inherit)
public Object[] GetCustomAttributes(Type attributeType, bool inherit)
internal bool get_IsUserType()
internal Type MakeGenericType(Type type, Type[] typeArguments)
}
internal System.Reflection.Emit.TypeKind : Enum {
public int value__
public TypeKind IsArray
public TypeKind IsPointer
public TypeKind IsByRef
}
public System.Reflection.Emit.TypeToken : ValueType {
internal int tokValue
public TypeToken Empty
public int Token
internal void .ctor(int val)
public bool Equals(object obj)
public bool Equals(TypeToken obj)
public bool op_Equality(TypeToken a, TypeToken b)
public bool op_Inequality(TypeToken a, TypeToken b)
public int GetHashCode()
public int get_Token()
}
public System.Reflection.Emit.UnmanagedMarshal : object {
private int count
private UnmanagedType t
private UnmanagedType tbase
private string guid
private string mcookie
private string marshaltype
internal Type marshaltyperef
private int param_num
private bool has_size
public UnmanagedType BaseType
public int ElementCount
public UnmanagedType GetUnmanagedType
public Guid IIDGuid
private void .ctor(UnmanagedType maint, int cnt)
private void .ctor(UnmanagedType maint, UnmanagedType elemt)
public UnmanagedType get_BaseType()
public int get_ElementCount()
public UnmanagedType get_GetUnmanagedType()
public Guid get_IIDGuid()
public UnmanagedMarshal DefineByValArray(int elemCount)
public UnmanagedMarshal DefineByValTStr(int elemCount)
public UnmanagedMarshal DefineLPArray(UnmanagedType elemType)
public UnmanagedMarshal DefineSafeArray(UnmanagedType elemType)
public UnmanagedMarshal DefineUnmanagedMarshal(UnmanagedType unmanagedType)
internal UnmanagedMarshal DefineCustom(Type typeref, string cookie, string mtype, Guid id)
internal UnmanagedMarshal DefineLPArrayInternal(UnmanagedType elemType, int sizeConst, int sizeParamIndex)
}
public System.Reflection.EventAttributes : Enum {
public int value__
public EventAttributes None
public EventAttributes SpecialName
public EventAttributes ReservedMask
public EventAttributes RTSpecialName
}
public System.Reflection.EventInfo : MemberInfo {
private AddEventAdapter cached_add_event
public EventAttributes Attributes
public Type EventHandlerType
public bool IsMulticast
public bool IsSpecialName
public MemberTypes MemberType
public MethodInfo AddMethod
public MethodInfo RaiseMethod
public MethodInfo RemoveMethod
public EventAttributes get_Attributes()
public Type get_EventHandlerType()
public bool get_IsMulticast()
public bool get_IsSpecialName()
public MemberTypes get_MemberType()
public void AddEventHandler(object target, Delegate handler)
public MethodInfo GetAddMethod()
public MethodInfo GetAddMethod(bool nonPublic)
public MethodInfo GetRaiseMethod()
public MethodInfo GetRaiseMethod(bool nonPublic)
public MethodInfo GetRemoveMethod()
public MethodInfo GetRemoveMethod(bool nonPublic)
public MethodInfo[] GetOtherMethods(bool nonPublic)
public MethodInfo[] GetOtherMethods()
public void RemoveEventHandler(object target, Delegate handler)
public bool Equals(object obj)
public int GetHashCode()
public bool op_Equality(EventInfo left, EventInfo right)
public bool op_Inequality(EventInfo left, EventInfo right)
private void System.Runtime.InteropServices._EventInfo.GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId)
private Type System.Runtime.InteropServices._EventInfo.GetType()
private void System.Runtime.InteropServices._EventInfo.GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo)
private void System.Runtime.InteropServices._EventInfo.GetTypeInfoCount(UInt32& pcTInfo)
private void System.Runtime.InteropServices._EventInfo.Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr)
private void AddEventFrame(AddEvent`2<T, D> addEvent, object obj, object dele)
private void StaticAddEventAdapterFrame(StaticAddEvent`1<D> addEvent, object obj, object dele)
private AddEventAdapter CreateAddEventDelegate(MethodInfo method)
public MethodInfo get_AddMethod()
public MethodInfo get_RaiseMethod()
public MethodInfo get_RemoveMethod()
private EventInfo internal_from_handle_type(IntPtr event_handle, IntPtr type_handle)
internal EventInfo GetEventFromHandle(RuntimeEventHandle handle)
internal EventInfo GetEventFromHandle(RuntimeEventHandle handle, RuntimeTypeHandle reflectedType)
}
public System.Reflection.ExceptionHandlingClause : object {
internal Type catch_type
internal int filter_offset
internal ExceptionHandlingClauseOptions flags
internal int try_offset
internal int try_length
internal int handler_offset
internal int handler_length
public Type CatchType
public int FilterOffset
public ExceptionHandlingClauseOptions Flags
public int HandlerLength
public int HandlerOffset
public int TryLength
public int TryOffset
public Type get_CatchType()
public int get_FilterOffset()
public ExceptionHandlingClauseOptions get_Flags()
public int get_HandlerLength()
public int get_HandlerOffset()
public int get_TryLength()
public int get_TryOffset()
public string ToString()
}
public System.Reflection.ExceptionHandlingClauseOptions : Enum {
public int value__
public ExceptionHandlingClauseOptions Clause
public ExceptionHandlingClauseOptions Filter
public ExceptionHandlingClauseOptions Finally
public ExceptionHandlingClauseOptions Fault
}
public System.Reflection.FieldAttributes : Enum {
public int value__
public FieldAttributes FieldAccessMask
public FieldAttributes PrivateScope
public FieldAttributes Private
public FieldAttributes FamANDAssem
public FieldAttributes Assembly
public FieldAttributes Family
public FieldAttributes FamORAssem
public FieldAttributes Public
public FieldAttributes Static
public FieldAttributes InitOnly
public FieldAttributes Literal
public FieldAttributes NotSerialized
public FieldAttributes SpecialName
public FieldAttributes PinvokeImpl
public FieldAttributes ReservedMask
public FieldAttributes RTSpecialName
public FieldAttributes HasFieldMarshal
public FieldAttributes HasDefault
public FieldAttributes HasFieldRVA
}
public System.Reflection.FieldInfo : MemberInfo {
public FieldAttributes Attributes
public RuntimeFieldHandle FieldHandle
public Type FieldType
public MemberTypes MemberType
public bool IsLiteral
public bool IsStatic
public bool IsInitOnly
public bool IsPublic
public bool IsPrivate
public bool IsFamily
public bool IsAssembly
public bool IsFamilyAndAssembly
public bool IsFamilyOrAssembly
public bool IsPinvokeImpl
public bool IsSpecialName
public bool IsNotSerialized
public bool IsSecurityCritical
public bool IsSecuritySafeCritical
public bool IsSecurityTransparent
public FieldAttributes get_Attributes()
public RuntimeFieldHandle get_FieldHandle()
public Type get_FieldType()
public object GetValue(object obj)
public MemberTypes get_MemberType()
public bool get_IsLiteral()
public bool get_IsStatic()
public bool get_IsInitOnly()
public bool get_IsPublic()
public bool get_IsPrivate()
public bool get_IsFamily()
public bool get_IsAssembly()
public bool get_IsFamilyAndAssembly()
public bool get_IsFamilyOrAssembly()
public bool get_IsPinvokeImpl()
public bool get_IsSpecialName()
public bool get_IsNotSerialized()
public void SetValue(object obj, object value, BindingFlags invokeAttr, Binder binder, CultureInfo culture)
public void SetValue(object obj, object value)
private FieldInfo internal_from_handle_type(IntPtr field_handle, IntPtr type_handle)
public FieldInfo GetFieldFromHandle(RuntimeFieldHandle handle)
public FieldInfo GetFieldFromHandle(RuntimeFieldHandle handle, RuntimeTypeHandle declaringType)
internal int GetFieldOffset()
public object GetValueDirect(TypedReference obj)
public void SetValueDirect(TypedReference obj, object value)
private MarshalAsAttribute get_marshal_info()
internal Object[] GetPseudoCustomAttributes()
private Type[] GetTypeModifiers(bool optional)
public Type[] GetOptionalCustomModifiers()
public Type[] GetRequiredCustomModifiers()
public object GetRawConstantValue()
public bool Equals(object obj)
public int GetHashCode()
public bool op_Equality(FieldInfo left, FieldInfo right)
public bool op_Inequality(FieldInfo left, FieldInfo right)
public bool get_IsSecurityCritical()
public bool get_IsSecuritySafeCritical()
public bool get_IsSecurityTransparent()
private void System.Runtime.InteropServices._FieldInfo.GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId)
private Type System.Runtime.InteropServices._FieldInfo.GetType()
private void System.Runtime.InteropServices._FieldInfo.GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo)
private void System.Runtime.InteropServices._FieldInfo.GetTypeInfoCount(UInt32& pcTInfo)
private void System.Runtime.InteropServices._FieldInfo.Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr)
}
public System.Reflection.GenericParameterAttributes : Enum {
public int value__
public GenericParameterAttributes None
public GenericParameterAttributes VarianceMask
public GenericParameterAttributes Covariant
public GenericParameterAttributes Contravariant
public GenericParameterAttributes SpecialConstraintMask
public GenericParameterAttributes ReferenceTypeConstraint
public GenericParameterAttributes NotNullableValueTypeConstraint
public GenericParameterAttributes DefaultConstructorConstraint
}
internal System.Reflection.Getter`2 : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public R Invoke(T _this)
public IAsyncResult BeginInvoke(T _this, AsyncCallback callback, object object)
public R EndInvoke(IAsyncResult result)
}
internal System.Reflection.GetterAdapter : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public object Invoke(object _this)
public IAsyncResult BeginInvoke(object _this, AsyncCallback callback, object object)
public object EndInvoke(IAsyncResult result)
}
public System.Reflection.ICustomAttributeProvider {
public Object[] GetCustomAttributes(Type attributeType, bool inherit)
public Object[] GetCustomAttributes(bool inherit)
public bool IsDefined(Type attributeType, bool inherit)
}
public System.Reflection.ImageFileMachine : Enum {
public int value__
public ImageFileMachine I386
public ImageFileMachine IA64
public ImageFileMachine AMD64
public ImageFileMachine ARM
}
public System.Reflection.InterfaceMapping : ValueType {
public Type TargetType
public Type InterfaceType
public MethodInfo[] TargetMethods
public MethodInfo[] InterfaceMethods
}
public System.Reflection.IntrospectionExtensions : object {
public TypeInfo GetTypeInfo(Type type)
}
public System.Reflection.InvalidFilterCriteriaException : ApplicationException {
public void .ctor(string message)
public void .ctor(string message, Exception inner)
protected void .ctor(SerializationInfo info, StreamingContext context)
}
internal System.Reflection.INVOCATION_FLAGS : Enum {
public UInt32 value__
public INVOCATION_FLAGS INVOCATION_FLAGS_UNKNOWN
public INVOCATION_FLAGS INVOCATION_FLAGS_INITIALIZED
public INVOCATION_FLAGS INVOCATION_FLAGS_NO_INVOKE
public INVOCATION_FLAGS INVOCATION_FLAGS_NEED_SECURITY
public INVOCATION_FLAGS INVOCATION_FLAGS_NO_CTOR_INVOKE
public INVOCATION_FLAGS INVOCATION_FLAGS_IS_CTOR
public INVOCATION_FLAGS INVOCATION_FLAGS_RISKY_METHOD
public INVOCATION_FLAGS INVOCATION_FLAGS_NON_W8P_FX_API
public INVOCATION_FLAGS INVOCATION_FLAGS_IS_DELEGATE_CTOR
public INVOCATION_FLAGS INVOCATION_FLAGS_CONTAINS_STACK_POINTERS
public INVOCATION_FLAGS INVOCATION_FLAGS_SPECIAL_FIELD
public INVOCATION_FLAGS INVOCATION_FLAGS_FIELD_SPECIAL_CAST
public INVOCATION_FLAGS INVOCATION_FLAGS_CONSTRUCTOR_INVOKE
}
public System.Reflection.IReflect {
public Type UnderlyingSystemType
public MethodInfo GetMethod(string name, BindingFlags bindingAttr, Binder binder, Type[] types, ParameterModifier[] modifiers)
public MethodInfo GetMethod(string name, BindingFlags bindingAttr)
public MethodInfo[] GetMethods(BindingFlags bindingAttr)
public FieldInfo GetField(string name, BindingFlags bindingAttr)
public FieldInfo[] GetFields(BindingFlags bindingAttr)
public PropertyInfo GetProperty(string name, BindingFlags bindingAttr)
public PropertyInfo GetProperty(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers)
public PropertyInfo[] GetProperties(BindingFlags bindingAttr)
public MemberInfo[] GetMember(string name, BindingFlags bindingAttr)
public MemberInfo[] GetMembers(BindingFlags bindingAttr)
public object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, Object[] args, ParameterModifier[] modifiers, CultureInfo culture, String[] namedParameters)
public Type get_UnderlyingSystemType()
}
public System.Reflection.IReflectableType {
public TypeInfo GetTypeInfo()
}
public System.Reflection.LocalVariableInfo : object {
internal Type type
internal bool is_pinned
internal ushort position
public bool IsPinned
public int LocalIndex
public Type LocalType
public bool get_IsPinned()
public int get_LocalIndex()
public Type get_LocalType()
public string ToString()
}
public System.Reflection.ManifestResourceInfo : object {
private Assembly _containingAssembly
private string _containingFileName
private ResourceLocation _resourceLocation
public Assembly ReferencedAssembly
public string FileName
public ResourceLocation ResourceLocation
public void .ctor(Assembly containingAssembly, string containingFileName, ResourceLocation resourceLocation)
public Assembly get_ReferencedAssembly()
public string get_FileName()
public ResourceLocation get_ResourceLocation()
}
internal System.Reflection.MdSigCallingConvention : Enum {
public byte value__
public MdSigCallingConvention CallConvMask
public MdSigCallingConvention Default
public MdSigCallingConvention C
public MdSigCallingConvention StdCall
public MdSigCallingConvention ThisCall
public MdSigCallingConvention FastCall
public MdSigCallingConvention Vararg
public MdSigCallingConvention Field
public MdSigCallingConvention LocalSig
public MdSigCallingConvention Property
public MdSigCallingConvention Unmgd
public MdSigCallingConvention GenericInst
public MdSigCallingConvention Generic
public MdSigCallingConvention HasThis
public MdSigCallingConvention ExplicitThis
}
public System.Reflection.MemberFilter : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public bool Invoke(MemberInfo m, object filterCriteria)
public IAsyncResult BeginInvoke(MemberInfo m, object filterCriteria, AsyncCallback callback, object object)
public bool EndInvoke(IAsyncResult result)
}
public System.Reflection.MemberInfo : object {
public MemberTypes MemberType
public string Name
public Type DeclaringType
public Type ReflectedType
public IEnumerable`1<CustomAttributeData> CustomAttributes
public int MetadataToken
public Module Module
internal bool CacheEquals(object o)
public MemberTypes get_MemberType()
public string get_Name()
public Type get_DeclaringType()
public Type get_ReflectedType()
public IEnumerable`1<CustomAttributeData> get_CustomAttributes()
public Object[] GetCustomAttributes(bool inherit)
public Object[] GetCustomAttributes(Type attributeType, bool inherit)
public bool IsDefined(Type attributeType, bool inherit)
public IList`1<CustomAttributeData> GetCustomAttributesData()
public int get_MetadataToken()
public Module get_Module()
public bool op_Equality(MemberInfo left, MemberInfo right)
public bool op_Inequality(MemberInfo left, MemberInfo right)
public bool Equals(object obj)
public int GetHashCode()
private Type System.Runtime.InteropServices._MemberInfo.GetType()
private void System.Runtime.InteropServices._MemberInfo.GetTypeInfoCount(UInt32& pcTInfo)
private void System.Runtime.InteropServices._MemberInfo.GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo)
private void System.Runtime.InteropServices._MemberInfo.GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId)
private void System.Runtime.InteropServices._MemberInfo.Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr)
}
internal System.Reflection.MemberInfoSerializationHolder : object {
private string m_memberName
private RuntimeType m_reflectedType
private string m_signature
private string m_signature2
private MemberTypes m_memberType
private SerializationInfo m_info
public void GetSerializationInfo(SerializationInfo info, string name, RuntimeType reflectedClass, string signature, MemberTypes type)
public void GetSerializationInfo(SerializationInfo info, string name, RuntimeType reflectedClass, string signature, string signature2, MemberTypes type, Type[] genericArguments)
internal void .ctor(SerializationInfo info, StreamingContext context)
public void GetObjectData(SerializationInfo info, StreamingContext context)
public object GetRealObject(StreamingContext context)
}
public System.Reflection.MemberTypes : Enum {
public int value__
public MemberTypes Constructor
public MemberTypes Event
public MemberTypes Field
public MemberTypes Method
public MemberTypes Property
public MemberTypes TypeInfo
public MemberTypes Custom
public MemberTypes NestedType
public MemberTypes All
}
public System.Reflection.Metadata.AssemblyExtensions : object {
public bool TryGetRawMetadata(Assembly assembly, Byte*& blob, Int32& length)
}
internal System.Reflection.MetadataTokenType : Enum {
public int value__
public MetadataTokenType Module
public MetadataTokenType TypeRef
public MetadataTokenType TypeDef
public MetadataTokenType FieldDef
public MetadataTokenType MethodDef
public MetadataTokenType ParamDef
public MetadataTokenType InterfaceImpl
public MetadataTokenType MemberRef
public MetadataTokenType CustomAttribute
public MetadataTokenType Permission
public MetadataTokenType Signature
public MetadataTokenType Event
public MetadataTokenType Property
public MetadataTokenType ModuleRef
public MetadataTokenType TypeSpec
public MetadataTokenType Assembly
public MetadataTokenType AssemblyRef
public MetadataTokenType File
public MetadataTokenType ExportedType
public MetadataTokenType ManifestResource
public MetadataTokenType GenericPar
public MetadataTokenType MethodSpec
public MetadataTokenType String
public MetadataTokenType Name
public MetadataTokenType BaseType
public MetadataTokenType Invalid
}
public System.Reflection.MethodAttributes : Enum {
public int value__
public MethodAttributes MemberAccessMask
public MethodAttributes PrivateScope
public MethodAttributes Private
public MethodAttributes FamANDAssem
public MethodAttributes Assembly
public MethodAttributes Family
public MethodAttributes FamORAssem
public MethodAttributes Public
public MethodAttributes Static
public MethodAttributes Final
public MethodAttributes Virtual
public MethodAttributes HideBySig
public MethodAttributes CheckAccessOnOverride
public MethodAttributes VtableLayoutMask
public MethodAttributes ReuseSlot
public MethodAttributes NewSlot
public MethodAttributes Abstract
public MethodAttributes SpecialName
public MethodAttributes PinvokeImpl
public MethodAttributes UnmanagedExport
public MethodAttributes RTSpecialName
public MethodAttributes ReservedMask
public MethodAttributes HasSecurity
public MethodAttributes RequireSecObject
}
public System.Reflection.MethodBase : MemberInfo {
public MethodImplAttributes MethodImplementationFlags
public RuntimeMethodHandle MethodHandle
public MethodAttributes Attributes
public CallingConventions CallingConvention
public bool IsGenericMethodDefinition
public bool ContainsGenericParameters
public bool IsGenericMethod
public bool IsSecurityCritical
public bool IsSecuritySafeCritical
public bool IsSecurityTransparent
public bool IsPublic
public bool IsPrivate
public bool IsFamily
public bool IsAssembly
public bool IsFamilyAndAssembly
public bool IsFamilyOrAssembly
public bool IsStatic
public bool IsFinal
public bool IsVirtual
public bool IsHideBySig
public bool IsAbstract
public bool IsSpecialName
public bool IsConstructor
internal string FullName
private bool System.Runtime.InteropServices._MethodBase.IsPublic
private bool System.Runtime.InteropServices._MethodBase.IsPrivate
private bool System.Runtime.InteropServices._MethodBase.IsFamily
private bool System.Runtime.InteropServices._MethodBase.IsAssembly
private bool System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly
private bool System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly
private bool System.Runtime.InteropServices._MethodBase.IsStatic
private bool System.Runtime.InteropServices._MethodBase.IsFinal
private bool System.Runtime.InteropServices._MethodBase.IsVirtual
private bool System.Runtime.InteropServices._MethodBase.IsHideBySig
private bool System.Runtime.InteropServices._MethodBase.IsAbstract
private bool System.Runtime.InteropServices._MethodBase.IsSpecialName
private bool System.Runtime.InteropServices._MethodBase.IsConstructor
public MethodBase GetMethodFromHandle(RuntimeMethodHandle handle)
public MethodBase GetMethodFromHandle(RuntimeMethodHandle handle, RuntimeTypeHandle declaringType)
public MethodBase GetCurrentMethod()
public bool op_Equality(MethodBase left, MethodBase right)
public bool op_Inequality(MethodBase left, MethodBase right)
public bool Equals(object obj)
public int GetHashCode()
private IntPtr GetMethodDesc()
internal ParameterInfo[] GetParametersNoCopy()
public ParameterInfo[] GetParameters()
public MethodImplAttributes get_MethodImplementationFlags()
public MethodImplAttributes GetMethodImplementationFlags()
public RuntimeMethodHandle get_MethodHandle()
public MethodAttributes get_Attributes()
public object Invoke(object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture)
public CallingConventions get_CallingConvention()
public Type[] GetGenericArguments()
public bool get_IsGenericMethodDefinition()
public bool get_ContainsGenericParameters()
public bool get_IsGenericMethod()
public bool get_IsSecurityCritical()
public bool get_IsSecuritySafeCritical()
public bool get_IsSecurityTransparent()
public object Invoke(object obj, Object[] parameters)
public bool get_IsPublic()
public bool get_IsPrivate()
public bool get_IsFamily()
public bool get_IsAssembly()
public bool get_IsFamilyAndAssembly()
public bool get_IsFamilyOrAssembly()
public bool get_IsStatic()
public bool get_IsFinal()
public bool get_IsVirtual()
public bool get_IsHideBySig()
public bool get_IsAbstract()
public bool get_IsSpecialName()
public bool get_IsConstructor()
public MethodBody GetMethodBody()
internal string ConstructParameters(Type[] parameterTypes, CallingConventions callingConvention, bool serialization)
internal string get_FullName()
internal string FormatNameAndSig()
internal string FormatNameAndSig(bool serialization)
internal Type[] GetParameterTypes()
private Type System.Runtime.InteropServices._MethodBase.GetType()
private bool System.Runtime.InteropServices._MethodBase.get_IsPublic()
private bool System.Runtime.InteropServices._MethodBase.get_IsPrivate()
private bool System.Runtime.InteropServices._MethodBase.get_IsFamily()
private bool System.Runtime.InteropServices._MethodBase.get_IsAssembly()
private bool System.Runtime.InteropServices._MethodBase.get_IsFamilyAndAssembly()
private bool System.Runtime.InteropServices._MethodBase.get_IsFamilyOrAssembly()
private bool System.Runtime.InteropServices._MethodBase.get_IsStatic()
private bool System.Runtime.InteropServices._MethodBase.get_IsFinal()
private bool System.Runtime.InteropServices._MethodBase.get_IsVirtual()
private bool System.Runtime.InteropServices._MethodBase.get_IsHideBySig()
private bool System.Runtime.InteropServices._MethodBase.get_IsAbstract()
private bool System.Runtime.InteropServices._MethodBase.get_IsSpecialName()
private bool System.Runtime.InteropServices._MethodBase.get_IsConstructor()
private void System.Runtime.InteropServices._MethodBase.GetTypeInfoCount(UInt32& pcTInfo)
private void System.Runtime.InteropServices._MethodBase.GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo)
private void System.Runtime.InteropServices._MethodBase.GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId)
private void System.Runtime.InteropServices._MethodBase.Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr)
internal ParameterInfo[] GetParametersInternal()
internal int GetParametersCount()
internal Type GetParameterType(int pos)
internal int get_next_table_index(object obj, int table, bool inc)
internal MethodBase GetMethodFromHandleNoGenericCheck(RuntimeMethodHandle handle)
internal MethodBase GetMethodFromHandleNoGenericCheck(RuntimeMethodHandle handle, RuntimeTypeHandle reflectedType)
internal MethodBody GetMethodBodyInternal(IntPtr handle)
internal MethodBody GetMethodBody(IntPtr handle)
private MethodBase GetMethodFromHandleInternalType(IntPtr method_handle, IntPtr type_handle)
internal MethodBase GetMethodFromHandleInternalType_native(IntPtr method_handle, IntPtr type_handle, bool genericCheck)
}
public System.Reflection.MethodBody : object {
private ExceptionHandlingClause[] clauses
private LocalVariableInfo[] locals
private Byte[] il
private bool init_locals
private int sig_token
private int max_stack
public IList`1<ExceptionHandlingClause> ExceptionHandlingClauses
public IList`1<LocalVariableInfo> LocalVariables
public bool InitLocals
public int LocalSignatureMetadataToken
public int MaxStackSize
public IList`1<ExceptionHandlingClause> get_ExceptionHandlingClauses()
public IList`1<LocalVariableInfo> get_LocalVariables()
public bool get_InitLocals()
public int get_LocalSignatureMetadataToken()
public int get_MaxStackSize()
public Byte[] GetILAsByteArray()
}
public System.Reflection.MethodImplAttributes : Enum {
public int value__
public MethodImplAttributes CodeTypeMask
public MethodImplAttributes IL
public MethodImplAttributes Native
public MethodImplAttributes OPTIL
public MethodImplAttributes Runtime
public MethodImplAttributes ManagedMask
public MethodImplAttributes Unmanaged
public MethodImplAttributes Managed
public MethodImplAttributes ForwardRef
public MethodImplAttributes PreserveSig
public MethodImplAttributes InternalCall
public MethodImplAttributes Synchronized
public MethodImplAttributes NoInlining
public MethodImplAttributes AggressiveInlining
public MethodImplAttributes NoOptimization
public MethodImplAttributes MaxMethodImplVal
}
public System.Reflection.MethodInfo : MethodBase {
public MemberTypes MemberType
public Type ReturnType
public ParameterInfo ReturnParameter
public ICustomAttributeProvider ReturnTypeCustomAttributes
public bool op_Equality(MethodInfo left, MethodInfo right)
public bool op_Inequality(MethodInfo left, MethodInfo right)
public bool Equals(object obj)
public int GetHashCode()
public MemberTypes get_MemberType()
public Type get_ReturnType()
public ParameterInfo get_ReturnParameter()
public ICustomAttributeProvider get_ReturnTypeCustomAttributes()
public MethodInfo GetBaseDefinition()
public Type[] GetGenericArguments()
public MethodInfo GetGenericMethodDefinition()
public MethodInfo MakeGenericMethod(Type[] typeArguments)
public Delegate CreateDelegate(Type delegateType)
public Delegate CreateDelegate(Type delegateType, object target)
private Type System.Runtime.InteropServices._MethodInfo.GetType()
private void System.Runtime.InteropServices._MethodInfo.GetTypeInfoCount(UInt32& pcTInfo)
private void System.Runtime.InteropServices._MethodInfo.GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo)
private void System.Runtime.InteropServices._MethodInfo.GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId)
private void System.Runtime.InteropServices._MethodInfo.Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr)
internal MethodInfo GetBaseMethod()
}
internal System.Reflection.MethodSemanticsAttributes : Enum {
public int value__
public MethodSemanticsAttributes Setter
public MethodSemanticsAttributes Getter
public MethodSemanticsAttributes Other
public MethodSemanticsAttributes AddOn
public MethodSemanticsAttributes RemoveOn
public MethodSemanticsAttributes Fire
}
public System.Reflection.Missing : object {
public Missing Value
private void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context)
}
public System.Reflection.Module : object {
public TypeFilter FilterTypeName
public TypeFilter FilterTypeNameIgnoreCase
internal IntPtr _impl
internal Assembly assembly
internal string fqname
internal string name
internal string scopename
internal bool is_resource
internal int token
private BindingFlags defaultBindingFlags
public ModuleHandle ModuleHandle
internal Guid MvId
public Assembly Assembly
public string Name
public string ScopeName
public int MDStreamVersion
public Guid ModuleVersionId
public string FullyQualifiedName
public int MetadataToken
public IEnumerable`1<CustomAttributeData> CustomAttributes
public ModuleHandle get_ModuleHandle()
internal int get_MetadataToken(Module module)
internal int GetMDStreamVersion(IntPtr module_handle)
public FieldInfo GetField(string name)
public FieldInfo[] GetFields()
public MethodInfo GetMethod(string name)
public MethodInfo GetMethod(string name, Type[] types)
public MethodInfo GetMethod(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers)
public MethodInfo[] GetMethods()
public void GetObjectData(SerializationInfo info, StreamingContext context)
public Type GetType(string className)
public Type GetType(string className, bool ignoreCase)
internal Type[] InternalGetTypes()
public string ToString()
internal Guid get_MvId()
internal Exception resolve_token_exception(int metadataToken, ResolveTokenError error, string tokenType)
internal IntPtr[] ptrs_from_types(Type[] types)
public FieldInfo ResolveField(int metadataToken)
public MemberInfo ResolveMember(int metadataToken)
public MethodBase ResolveMethod(int metadataToken)
public Type ResolveType(int metadataToken)
internal Type MonoDebugger_ResolveType(Module module, int token)
internal Guid Mono_GetGuid(Module module)
internal Guid GetModuleVersionId()
private bool filter_by_type_name(Type m, object filterCriteria)
private bool filter_by_type_name_ignore_case(Type m, object filterCriteria)
internal IntPtr GetHINSTANCE()
private string GetGuidInternal()
internal Type GetGlobalType()
internal IntPtr ResolveTypeToken(IntPtr module, int token, IntPtr[] type_args, IntPtr[] method_args, ResolveTokenError& error)
internal IntPtr ResolveMethodToken(IntPtr module, int token, IntPtr[] type_args, IntPtr[] method_args, ResolveTokenError& error)
internal IntPtr ResolveFieldToken(IntPtr module, int token, IntPtr[] type_args, IntPtr[] method_args, ResolveTokenError& error)
internal string ResolveStringToken(IntPtr module, int token, ResolveTokenError& error)
internal MemberInfo ResolveMemberToken(IntPtr module, int token, IntPtr[] type_args, IntPtr[] method_args, ResolveTokenError& error)
internal Byte[] ResolveSignature(IntPtr module, int metadataToken, ResolveTokenError& error)
internal void GetPEKind(IntPtr module, PortableExecutableKinds& peKind, ImageFileMachine& machine)
private void System.Runtime.InteropServices._Module.GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId)
private void System.Runtime.InteropServices._Module.GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo)
private void System.Runtime.InteropServices._Module.GetTypeInfoCount(UInt32& pcTInfo)
private void System.Runtime.InteropServices._Module.Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr)
public bool Equals(object o)
public int GetHashCode()
public bool op_Equality(Module left, Module right)
public bool op_Inequality(Module left, Module right)
public Assembly get_Assembly()
public string get_Name()
public string get_ScopeName()
public int get_MDStreamVersion()
public Guid get_ModuleVersionId()
public string get_FullyQualifiedName()
public int get_MetadataToken()
private Exception CreateNIE()
public bool IsResource()
public Type[] FindTypes(TypeFilter filter, object filterCriteria)
public Object[] GetCustomAttributes(bool inherit)
public Object[] GetCustomAttributes(Type attributeType, bool inherit)
public IList`1<CustomAttributeData> GetCustomAttributesData()
public FieldInfo GetField(string name, BindingFlags bindingAttr)
public FieldInfo[] GetFields(BindingFlags bindingFlags)
protected MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers)
public MethodInfo[] GetMethods(BindingFlags bindingFlags)
public void GetPEKind(PortableExecutableKinds& peKind, ImageFileMachine& machine)
public Type GetType(string className, bool throwOnError, bool ignoreCase)
public bool IsDefined(Type attributeType, bool inherit)
public FieldInfo ResolveField(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments)
public MemberInfo ResolveMember(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments)
public MethodBase ResolveMethod(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments)
public Byte[] ResolveSignature(int metadataToken)
public string ResolveString(int metadataToken)
public Type ResolveType(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments)
public X509Certificate GetSignerCertificate()
public Type[] GetTypes()
public IEnumerable`1<CustomAttributeData> get_CustomAttributes()
}
public System.Reflection.ModuleResolveEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public Module Invoke(object sender, ResolveEventArgs e)
public IAsyncResult BeginInvoke(object sender, ResolveEventArgs e, AsyncCallback callback, object object)
public Module EndInvoke(IAsyncResult result)
}
internal System.Reflection.MonoArrayMethod : MethodInfo {
internal RuntimeMethodHandle mhandle
internal Type parent
internal Type ret
internal Type[] parameters
internal string name
internal int table_idx
internal CallingConventions call_conv
public Type ReturnType
public ICustomAttributeProvider ReturnTypeCustomAttributes
public RuntimeMethodHandle MethodHandle
public MethodAttributes Attributes
public Type ReflectedType
public Type DeclaringType
public string Name
internal void .ctor(Type arrayClass, string methodName, CallingConventions callingConvention, Type returnType, Type[] parameterTypes)
public MethodInfo GetBaseDefinition()
public Type get_ReturnType()
public ICustomAttributeProvider get_ReturnTypeCustomAttributes()
public MethodImplAttributes GetMethodImplementationFlags()
public ParameterInfo[] GetParameters()
internal ParameterInfo[] GetParametersInternal()
internal int GetParametersCount()
public object Invoke(object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture)
public RuntimeMethodHandle get_MethodHandle()
public MethodAttributes get_Attributes()
public Type get_ReflectedType()
public Type get_DeclaringType()
public string get_Name()
public bool IsDefined(Type attributeType, bool inherit)
public Object[] GetCustomAttributes(bool inherit)
public Object[] GetCustomAttributes(Type attributeType, bool inherit)
public string ToString()
}
internal System.Reflection.MonoAssembly : RuntimeAssembly {
public Module ManifestModule
public bool GlobalAssemblyCache
public Type GetType(string name, bool throwOnError, bool ignoreCase)
public Module GetModule(string name)
public AssemblyName[] GetReferencedAssemblies()
public Module[] GetModules(bool getResourceModules)
public Module[] GetLoadedModules(bool getResourceModules)
public Assembly GetSatelliteAssembly(CultureInfo culture)
public Assembly GetSatelliteAssembly(CultureInfo culture, Version version)
public Module get_ManifestModule()
public bool get_GlobalAssemblyCache()
}
internal System.Reflection.MonoCMethod : RuntimeConstructorInfo {
internal IntPtr mhandle
private string name
private Type reftype
public RuntimeMethodHandle MethodHandle
public MethodAttributes Attributes
public CallingConventions CallingConvention
public bool ContainsGenericParameters
public Type ReflectedType
public Type DeclaringType
public string Name
public bool IsSecurityTransparent
public bool IsSecurityCritical
public bool IsSecuritySafeCritical
public MethodImplAttributes GetMethodImplementationFlags()
public ParameterInfo[] GetParameters()
internal ParameterInfo[] GetParametersInternal()
internal int GetParametersCount()
internal object InternalInvoke(object obj, Object[] parameters, Exception& exc)
public object Invoke(object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture)
private object DoInvoke(object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture)
public object InternalInvoke(object obj, Object[] parameters)
public object Invoke(BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture)
public RuntimeMethodHandle get_MethodHandle()
public MethodAttributes get_Attributes()
public CallingConventions get_CallingConvention()
public bool get_ContainsGenericParameters()
public Type get_ReflectedType()
public Type get_DeclaringType()
public string get_Name()
public bool IsDefined(Type attributeType, bool inherit)
public Object[] GetCustomAttributes(bool inherit)
public Object[] GetCustomAttributes(Type attributeType, bool inherit)
public MethodBody GetMethodBody()
public string ToString()
public IList`1<CustomAttributeData> GetCustomAttributesData()
public int get_core_clr_security_level()
public bool get_IsSecurityTransparent()
public bool get_IsSecurityCritical()
public bool get_IsSecuritySafeCritical()
}
internal System.Reflection.MonoEvent : RuntimeEventInfo {
private IntPtr klass
private IntPtr handle
public EventAttributes Attributes
public Type DeclaringType
public Type ReflectedType
public string Name
public EventAttributes get_Attributes()
public MethodInfo GetAddMethod(bool nonPublic)
public MethodInfo GetRaiseMethod(bool nonPublic)
public MethodInfo GetRemoveMethod(bool nonPublic)
public MethodInfo[] GetOtherMethods(bool nonPublic)
public Type get_DeclaringType()
public Type get_ReflectedType()
public string get_Name()
public string ToString()
public bool IsDefined(Type attributeType, bool inherit)
public Object[] GetCustomAttributes(bool inherit)
public Object[] GetCustomAttributes(Type attributeType, bool inherit)
public IList`1<CustomAttributeData> GetCustomAttributesData()
}
internal System.Reflection.MonoEventInfo : ValueType {
public Type declaring_type
public Type reflected_type
public string name
public MethodInfo add_method
public MethodInfo remove_method
public MethodInfo raise_method
public EventAttributes attrs
public MethodInfo[] other_methods
private void get_event_info(MonoEvent ev, MonoEventInfo& info)
internal MonoEventInfo GetEventInfo(MonoEvent ev)
}
internal System.Reflection.MonoField : RtFieldInfo {
internal IntPtr klass
internal RuntimeFieldHandle fhandle
private string name
private Type type
private FieldAttributes attrs
public FieldAttributes Attributes
public RuntimeFieldHandle FieldHandle
public Type FieldType
public Type ReflectedType
public Type DeclaringType
public string Name
public bool IsSecurityTransparent
public bool IsSecurityCritical
public bool IsSecuritySafeCritical
public FieldAttributes get_Attributes()
public RuntimeFieldHandle get_FieldHandle()
private Type ResolveType()
public Type get_FieldType()
private Type GetParentType(bool declaring)
public Type get_ReflectedType()
public Type get_DeclaringType()
public string get_Name()
public bool IsDefined(Type attributeType, bool inherit)
public Object[] GetCustomAttributes(bool inherit)
public Object[] GetCustomAttributes(Type attributeType, bool inherit)
internal int GetFieldOffset()
private object GetValueInternal(object obj)
public object GetValue(object obj)
public string ToString()
private void SetValueInternal(FieldInfo fi, object obj, object value)
public void SetValue(object obj, object val, BindingFlags invokeAttr, Binder binder, CultureInfo culture)
internal MonoField Clone(string newName)
public object GetRawConstantValue()
public IList`1<CustomAttributeData> GetCustomAttributesData()
private void CheckGeneric()
public int get_core_clr_security_level()
public bool get_IsSecurityTransparent()
public bool get_IsSecurityCritical()
public bool get_IsSecuritySafeCritical()
}
internal System.Reflection.MonoMethod : RuntimeMethodInfo {
internal IntPtr mhandle
private string name
private Type reftype
public ParameterInfo ReturnParameter
public Type ReturnType
public ICustomAttributeProvider ReturnTypeCustomAttributes
public RuntimeMethodHandle MethodHandle
public MethodAttributes Attributes
public CallingConventions CallingConvention
public Type ReflectedType
public Type DeclaringType
public string Name
public bool IsGenericMethodDefinition
public bool IsGenericMethod
public bool ContainsGenericParameters
public bool IsSecurityTransparent
public bool IsSecurityCritical
public bool IsSecuritySafeCritical
internal void .ctor(RuntimeMethodHandle mhandle)
internal string get_name(MethodBase method)
internal MonoMethod get_base_method(MonoMethod method, bool definition)
public MethodInfo GetBaseDefinition()
internal MethodInfo GetBaseMethod()
public ParameterInfo get_ReturnParameter()
public Type get_ReturnType()
public ICustomAttributeProvider get_ReturnTypeCustomAttributes()
public MethodImplAttributes GetMethodImplementationFlags()
public ParameterInfo[] GetParameters()
internal ParameterInfo[] GetParametersInternal()
internal int GetParametersCount()
internal object InternalInvoke(object obj, Object[] parameters, Exception& exc)
public object Invoke(object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture)
internal void ConvertValues(Binder binder, Object[] args, ParameterInfo[] pinfo, CultureInfo culture, BindingFlags invokeAttr)
public RuntimeMethodHandle get_MethodHandle()
public MethodAttributes get_Attributes()
public CallingConventions get_CallingConvention()
public Type get_ReflectedType()
public Type get_DeclaringType()
public string get_Name()
public bool IsDefined(Type attributeType, bool inherit)
public Object[] GetCustomAttributes(bool inherit)
public Object[] GetCustomAttributes(Type attributeType, bool inherit)
internal void GetPInvoke(PInvokeAttributes& flags, String& entryPoint, String& dllName)
internal Object[] GetPseudoCustomAttributes()
public MethodInfo MakeGenericMethod(Type[] methodInstantiation)
private MethodInfo MakeGenericMethod_impl(Type[] types)
public Type[] GetGenericArguments()
private MethodInfo GetGenericMethodDefinition_impl()
public MethodInfo GetGenericMethodDefinition()
public bool get_IsGenericMethodDefinition()
public bool get_IsGenericMethod()
public bool get_ContainsGenericParameters()
public MethodBody GetMethodBody()
public IList`1<CustomAttributeData> GetCustomAttributesData()
public int get_core_clr_security_level()
public bool get_IsSecurityTransparent()
public bool get_IsSecurityCritical()
public bool get_IsSecuritySafeCritical()
}
internal System.Reflection.MonoMethodInfo : ValueType {
private Type parent
private Type ret
internal MethodAttributes attrs
internal MethodImplAttributes iattrs
private CallingConventions callconv
private void get_method_info(IntPtr handle, MonoMethodInfo& info)
private int get_method_attributes(IntPtr handle)
internal MonoMethodInfo GetMethodInfo(IntPtr handle)
internal Type GetDeclaringType(IntPtr handle)
internal Type GetReturnType(IntPtr handle)
internal MethodAttributes GetAttributes(IntPtr handle)
internal CallingConventions GetCallingConvention(IntPtr handle)
internal MethodImplAttributes GetMethodImplementationFlags(IntPtr handle)
private ParameterInfo[] get_parameter_info(IntPtr handle, MemberInfo member)
internal ParameterInfo[] GetParametersInfo(IntPtr handle, MemberInfo member)
private MarshalAsAttribute get_retval_marshal(IntPtr handle)
internal ParameterInfo GetReturnParameterInfo(MonoMethod method)
}
internal System.Reflection.MonoModule : RuntimeModule {
public Assembly Assembly
public string Name
public string ScopeName
public int MDStreamVersion
public Guid ModuleVersionId
public string FullyQualifiedName
public int MetadataToken
public Assembly get_Assembly()
public string get_Name()
public string get_ScopeName()
public int get_MDStreamVersion()
public Guid get_ModuleVersionId()
public string get_FullyQualifiedName()
public bool IsResource()
public Type[] FindTypes(TypeFilter filter, object filterCriteria)
public Object[] GetCustomAttributes(bool inherit)
public Object[] GetCustomAttributes(Type attributeType, bool inherit)
public FieldInfo GetField(string name, BindingFlags bindingAttr)
public FieldInfo[] GetFields(BindingFlags bindingFlags)
public int get_MetadataToken()
protected MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers)
public MethodInfo[] GetMethods(BindingFlags bindingFlags)
public void GetPEKind(PortableExecutableKinds& peKind, ImageFileMachine& machine)
public Type GetType(string className, bool throwOnError, bool ignoreCase)
public bool IsDefined(Type attributeType, bool inherit)
public FieldInfo ResolveField(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments)
public MemberInfo ResolveMember(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments)
public MethodBase ResolveMethod(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments)
public string ResolveString(int metadataToken)
public Type ResolveType(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments)
public Byte[] ResolveSignature(int metadataToken)
public void GetObjectData(SerializationInfo info, StreamingContext context)
public X509Certificate GetSignerCertificate()
public Type[] GetTypes()
public IList`1<CustomAttributeData> GetCustomAttributesData()
internal RuntimeAssembly GetRuntimeAssembly()
}
internal System.Reflection.MonoParameterInfo : RuntimeParameterInfo {
public object DefaultValue
public object RawDefaultValue
public int MetadataToken
public bool HasDefaultValue
internal void .ctor(ParameterBuilder pb, Type type, MemberInfo member, int position)
internal void .ctor(ParameterInfo pinfo, Type type, MemberInfo member, int position)
internal void .ctor(ParameterInfo pinfo, MemberInfo member)
internal void .ctor(Type type, MemberInfo member, MarshalAsAttribute marshalAs)
public object get_DefaultValue()
public object get_RawDefaultValue()
public int get_MetadataToken()
public Object[] GetCustomAttributes(bool inherit)
public Object[] GetCustomAttributes(Type attributeType, bool inherit)
public bool IsDefined(Type attributeType, bool inherit)
public IList`1<CustomAttributeData> GetCustomAttributesData()
public Type[] GetOptionalCustomModifiers()
public Type[] GetRequiredCustomModifiers()
public bool get_HasDefaultValue()
}
internal System.Reflection.MonoProperty : RuntimePropertyInfo {
internal IntPtr klass
internal IntPtr prop
private MonoPropertyInfo info
private PInfo cached
private GetterAdapter cached_getter
public PropertyAttributes Attributes
public bool CanRead
public bool CanWrite
public Type PropertyType
public Type ReflectedType
public Type DeclaringType
public string Name
private void CachePropertyInfo(PInfo flags)
public PropertyAttributes get_Attributes()
public bool get_CanRead()
public bool get_CanWrite()
public Type get_PropertyType()
public Type get_ReflectedType()
public Type get_DeclaringType()
public string get_Name()
public MethodInfo[] GetAccessors(bool nonPublic)
public MethodInfo GetGetMethod(bool nonPublic)
public ParameterInfo[] GetIndexParameters()
public MethodInfo GetSetMethod(bool nonPublic)
public object GetConstantValue()
public object GetRawConstantValue()
public bool IsDefined(Type attributeType, bool inherit)
public Object[] GetCustomAttributes(bool inherit)
public Object[] GetCustomAttributes(Type attributeType, bool inherit)
private object GetterAdapterFrame(Getter`2<T, R> getter, object obj)
private object StaticGetterAdapterFrame(StaticGetter`1<R> getter, object obj)
private GetterAdapter CreateGetterDelegate(MethodInfo method)
public object GetValue(object obj, Object[] index)
public object GetValue(object obj, BindingFlags invokeAttr, Binder binder, Object[] index, CultureInfo culture)
public void SetValue(object obj, object value, BindingFlags invokeAttr, Binder binder, Object[] index, CultureInfo culture)
public Type[] GetOptionalCustomModifiers()
public Type[] GetRequiredCustomModifiers()
public IList`1<CustomAttributeData> GetCustomAttributesData()
}
internal System.Reflection.MonoPropertyInfo : ValueType {
public Type parent
public Type declaring_type
public string name
public MethodInfo get_method
public MethodInfo set_method
public PropertyAttributes attrs
internal void get_property_info(MonoProperty prop, MonoPropertyInfo& info, PInfo req_info)
internal Type[] GetTypeModifiers(MonoProperty prop, bool optional)
internal object get_default_value(MonoProperty prop)
}
public System.Reflection.ObfuscateAssemblyAttribute : Attribute {
private bool m_assemblyIsPrivate
private bool m_strip
public bool AssemblyIsPrivate
public bool StripAfterObfuscation
public void .ctor(bool assemblyIsPrivate)
public bool get_AssemblyIsPrivate()
public bool get_StripAfterObfuscation()
public void set_StripAfterObfuscation(bool value)
}
public System.Reflection.ObfuscationAttribute : Attribute {
private bool m_strip
private bool m_exclude
private bool m_applyToMembers
private string m_feature
public bool StripAfterObfuscation
public bool Exclude
public bool ApplyToMembers
public string Feature
public bool get_StripAfterObfuscation()
public void set_StripAfterObfuscation(bool value)
public bool get_Exclude()
public void set_Exclude(bool value)
public bool get_ApplyToMembers()
public void set_ApplyToMembers(bool value)
public string get_Feature()
public void set_Feature(string value)
}
public System.Reflection.ParameterAttributes : Enum {
public int value__
public ParameterAttributes None
public ParameterAttributes In
public ParameterAttributes Out
public ParameterAttributes Lcid
public ParameterAttributes Retval
public ParameterAttributes Optional
public ParameterAttributes ReservedMask
public ParameterAttributes HasDefault
public ParameterAttributes HasFieldMarshal
public ParameterAttributes Reserved3
public ParameterAttributes Reserved4
}
public System.Reflection.ParameterInfo : object {
protected Type ClassImpl
protected object DefaultValueImpl
protected MemberInfo MemberImpl
protected string NameImpl
protected int PositionImpl
protected ParameterAttributes AttrsImpl
internal MarshalAsAttribute marshalAs
public Type ParameterType
public ParameterAttributes Attributes
public bool IsIn
public bool IsLcid
public bool IsOptional
public bool IsOut
public bool IsRetval
public MemberInfo Member
public string Name
public int Position
public IEnumerable`1<CustomAttributeData> CustomAttributes
public bool HasDefaultValue
public object DefaultValue
public object RawDefaultValue
public int MetadataToken
public string ToString()
internal void FormatParameters(StringBuilder sb, ParameterInfo[] p, CallingConventions callingConvention, bool serialization)
public Type get_ParameterType()
public ParameterAttributes get_Attributes()
public bool get_IsIn()
public bool get_IsLcid()
public bool get_IsOptional()
public bool get_IsOut()
public bool get_IsRetval()
public MemberInfo get_Member()
public string get_Name()
public int get_Position()
internal int GetMetadataToken()
internal Object[] GetPseudoCustomAttributes()
internal Type[] GetTypeModifiers(bool optional)
internal object GetDefaultValueImpl()
public IEnumerable`1<CustomAttributeData> get_CustomAttributes()
public bool get_HasDefaultValue()
private void System.Runtime.InteropServices._ParameterInfo.GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId)
private void System.Runtime.InteropServices._ParameterInfo.GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo)
private void System.Runtime.InteropServices._ParameterInfo.GetTypeInfoCount(UInt32& pcTInfo)
private void System.Runtime.InteropServices._ParameterInfo.Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr)
public object get_DefaultValue()
public object get_RawDefaultValue()
public int get_MetadataToken()
public Object[] GetCustomAttributes(bool inherit)
public Object[] GetCustomAttributes(Type attributeType, bool inherit)
public object GetRealObject(StreamingContext context)
public bool IsDefined(Type attributeType, bool inherit)
public Type[] GetRequiredCustomModifiers()
public Type[] GetOptionalCustomModifiers()
public IList`1<CustomAttributeData> GetCustomAttributesData()
internal ParameterInfo New(ParameterBuilder pb, Type type, MemberInfo member, int position)
internal ParameterInfo New(ParameterInfo pinfo, Type type, MemberInfo member, int position)
internal ParameterInfo New(ParameterInfo pinfo, MemberInfo member)
internal ParameterInfo New(Type type, MemberInfo member, MarshalAsAttribute marshalAs)
}
public System.Reflection.ParameterModifier : ValueType {
private Boolean[] _byRef
internal Boolean[] IsByRefArray
public bool Item
public void .ctor(int parameterCount)
internal Boolean[] get_IsByRefArray()
public bool get_Item(int index)
public void set_Item(int index, bool value)
}
internal System.Reflection.PInfo : Enum {
public int value__
public PInfo Attributes
public PInfo GetMethod
public PInfo SetMethod
public PInfo ReflectedType
public PInfo DeclaringType
public PInfo Name
}
internal System.Reflection.PInvokeAttributes : Enum {
public int value__
public PInvokeAttributes NoMangle
public PInvokeAttributes CharSetMask
public PInvokeAttributes CharSetNotSpec
public PInvokeAttributes CharSetAnsi
public PInvokeAttributes CharSetUnicode
public PInvokeAttributes CharSetAuto
public PInvokeAttributes BestFitUseAssem
public PInvokeAttributes BestFitEnabled
public PInvokeAttributes BestFitDisabled
public PInvokeAttributes BestFitMask
public PInvokeAttributes ThrowOnUnmappableCharUseAssem
public PInvokeAttributes ThrowOnUnmappableCharEnabled
public PInvokeAttributes ThrowOnUnmappableCharDisabled
public PInvokeAttributes ThrowOnUnmappableCharMask
public PInvokeAttributes SupportsLastError
public PInvokeAttributes CallConvMask
public PInvokeAttributes CallConvWinapi
public PInvokeAttributes CallConvCdecl
public PInvokeAttributes CallConvStdcall
public PInvokeAttributes CallConvThiscall
public PInvokeAttributes CallConvFastcall
public PInvokeAttributes MaxValue
}
public System.Reflection.Pointer : object {
private Void* _ptr
private RuntimeType _ptrType
private void .ctor(SerializationInfo info, StreamingContext context)
public object Box(Void* ptr, Type type)
public Void* Unbox(object ptr)
internal RuntimeType GetPointerType()
internal object GetPointerValue()
private void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context)
}
public System.Reflection.PortableExecutableKinds : Enum {
public int value__
public PortableExecutableKinds NotAPortableExecutableImage
public PortableExecutableKinds ILOnly
public PortableExecutableKinds Required32Bit
public PortableExecutableKinds PE32Plus
public PortableExecutableKinds Unmanaged32Bit
public PortableExecutableKinds Preferred32Bit
}
public System.Reflection.ProcessorArchitecture : Enum {
public int value__
public ProcessorArchitecture None
public ProcessorArchitecture MSIL
public ProcessorArchitecture X86
public ProcessorArchitecture IA64
public ProcessorArchitecture Amd64
public ProcessorArchitecture Arm
}
public System.Reflection.PropertyAttributes : Enum {
public int value__
public PropertyAttributes None
public PropertyAttributes SpecialName
public PropertyAttributes ReservedMask
public PropertyAttributes RTSpecialName
public PropertyAttributes HasDefault
public PropertyAttributes Reserved2
public PropertyAttributes Reserved3
public PropertyAttributes Reserved4
}
public System.Reflection.PropertyInfo : MemberInfo {
public PropertyAttributes Attributes
public bool CanRead
public bool CanWrite
public MethodInfo GetMethod
public MethodInfo SetMethod
public bool IsSpecialName
public MemberTypes MemberType
public Type PropertyType
public PropertyAttributes get_Attributes()
public bool get_CanRead()
public bool get_CanWrite()
public MethodInfo get_GetMethod()
public MethodInfo get_SetMethod()
public bool get_IsSpecialName()
public MemberTypes get_MemberType()
public Type get_PropertyType()
public MethodInfo[] GetAccessors()
public MethodInfo[] GetAccessors(bool nonPublic)
public MethodInfo GetGetMethod()
public MethodInfo GetGetMethod(bool nonPublic)
public ParameterInfo[] GetIndexParameters()
public MethodInfo GetSetMethod()
public MethodInfo GetSetMethod(bool nonPublic)
public object GetValue(object obj, Object[] index)
public object GetValue(object obj)
public object GetValue(object obj, BindingFlags invokeAttr, Binder binder, Object[] index, CultureInfo culture)
public void SetValue(object obj, object value, Object[] index)
public void SetValue(object obj, object value)
public void SetValue(object obj, object value, BindingFlags invokeAttr, Binder binder, Object[] index, CultureInfo culture)
public Type[] GetOptionalCustomModifiers()
public Type[] GetRequiredCustomModifiers()
private NotImplementedException CreateNIE()
public object GetConstantValue()
public object GetRawConstantValue()
public bool Equals(object obj)
public int GetHashCode()
public bool op_Equality(PropertyInfo left, PropertyInfo right)
public bool op_Inequality(PropertyInfo left, PropertyInfo right)
private void System.Runtime.InteropServices._PropertyInfo.GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId)
private Type System.Runtime.InteropServices._PropertyInfo.GetType()
private void System.Runtime.InteropServices._PropertyInfo.GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo)
private void System.Runtime.InteropServices._PropertyInfo.GetTypeInfoCount(UInt32& pcTInfo)
private void System.Runtime.InteropServices._PropertyInfo.Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr)
private PropertyInfo internal_from_handle_type(IntPtr event_handle, IntPtr type_handle)
internal PropertyInfo GetPropertyFromHandle(RuntimePropertyHandle handle, RuntimeTypeHandle reflectedType)
}
public System.Reflection.ReflectionContext : object {
public Assembly MapAssembly(Assembly assembly)
public TypeInfo MapType(TypeInfo type)
public TypeInfo GetTypeForObject(object value)
}
public System.Reflection.ReflectionTypeLoadException : SystemException {
private Type[] _classes
private Exception[] _exceptions
public Type[] Types
public Exception[] LoaderExceptions
private void .ctor(string message)
public void .ctor(Type[] classes, Exception[] exceptions)
public void .ctor(Type[] classes, Exception[] exceptions, string message)
internal void .ctor(SerializationInfo info, StreamingContext context)
public Type[] get_Types()
public Exception[] get_LoaderExceptions()
public void GetObjectData(SerializationInfo info, StreamingContext context)
}
internal System.Reflection.ResolveTokenError : Enum {
public int value__
public ResolveTokenError OutOfRange
public ResolveTokenError BadTable
public ResolveTokenError Other
}
public System.Reflection.ResourceAttributes : Enum {
public int value__
public ResourceAttributes Public
public ResourceAttributes Private
}
public System.Reflection.ResourceLocation : Enum {
public int value__
public ResourceLocation Embedded
public ResourceLocation ContainedInAnotherAssembly
public ResourceLocation ContainedInManifestFile
}
internal System.Reflection.RtFieldInfo : RuntimeFieldInfo {
internal object UnsafeGetValue(object obj)
internal void CheckConsistency(object target)
internal void UnsafeSetValue(object obj, object value, BindingFlags invokeAttr, Binder binder, CultureInfo culture)
public void SetValueDirect(TypedReference obj, object value)
public object GetValueDirect(TypedReference obj)
}
internal System.Reflection.RuntimeAssembly : Assembly {
public void GetObjectData(SerializationInfo info, StreamingContext context)
internal RuntimeAssembly GetExecutingAssembly(StackCrawlMark& stackMark)
internal AssemblyName CreateAssemblyName(string assemblyString, bool forIntrospection, RuntimeAssembly& assemblyFromResolveEvent)
internal RuntimeAssembly InternalLoadAssemblyName(AssemblyName assemblyRef, Evidence assemblySecurity, RuntimeAssembly reqAssembly, StackCrawlMark& stackMark, bool throwOnFileNotFound, bool forIntrospection, bool suppressSecurityChecks)
internal RuntimeAssembly LoadWithPartialNameInternal(string partialName, Evidence securityEvidence, StackCrawlMark& stackMark)
internal RuntimeAssembly LoadWithPartialNameInternal(AssemblyName an, Evidence securityEvidence, StackCrawlMark& stackMark)
public AssemblyName GetName(bool copiedName)
}
internal System.Reflection.RuntimeConstructorInfo : ConstructorInfo {
public Module Module
internal BindingFlags BindingFlags
private RuntimeType ReflectedTypeInternal
public Module get_Module()
internal RuntimeModule GetRuntimeModule()
internal BindingFlags get_BindingFlags()
private RuntimeType get_ReflectedTypeInternal()
public void GetObjectData(SerializationInfo info, StreamingContext context)
internal string SerializationToString()
internal void SerializationInvoke(object target, SerializationInfo info, StreamingContext context)
}
internal System.Reflection.RuntimeEventInfo : EventInfo {
internal BindingFlags BindingFlags
public Module Module
private RuntimeType ReflectedTypeInternal
internal BindingFlags get_BindingFlags()
public Module get_Module()
internal RuntimeType GetDeclaringTypeInternal()
private RuntimeType get_ReflectedTypeInternal()
internal RuntimeModule GetRuntimeModule()
public void GetObjectData(SerializationInfo info, StreamingContext context)
}
internal System.Reflection.RuntimeFieldInfo : FieldInfo {
internal BindingFlags BindingFlags
public Module Module
private RuntimeType ReflectedTypeInternal
internal BindingFlags get_BindingFlags()
public Module get_Module()
internal RuntimeType GetDeclaringTypeInternal()
private RuntimeType get_ReflectedTypeInternal()
internal RuntimeModule GetRuntimeModule()
public void GetObjectData(SerializationInfo info, StreamingContext context)
}
internal System.Reflection.RuntimeMethodInfo : MethodInfo {
internal BindingFlags BindingFlags
public Module Module
private RuntimeType ReflectedTypeInternal
internal BindingFlags get_BindingFlags()
public Module get_Module()
private RuntimeType get_ReflectedTypeInternal()
internal string FormatNameAndSig(bool serialization)
public Delegate CreateDelegate(Type delegateType)
public Delegate CreateDelegate(Type delegateType, object target)
public string ToString()
internal RuntimeModule GetRuntimeModule()
public void GetObjectData(SerializationInfo info, StreamingContext context)
internal string SerializationToString()
}
internal System.Reflection.RuntimePropertyInfo : PropertyInfo {
internal BindingFlags BindingFlags
public Module Module
private RuntimeType ReflectedTypeInternal
internal BindingFlags get_BindingFlags()
public Module get_Module()
internal RuntimeType GetDeclaringTypeInternal()
private RuntimeType get_ReflectedTypeInternal()
internal RuntimeModule GetRuntimeModule()
public string ToString()
private string FormatNameAndSig(bool serialization)
public void GetObjectData(SerializationInfo info, StreamingContext context)
internal string SerializationToString()
}
public System.Reflection.RuntimeReflectionExtensions : object {
private BindingFlags everything
private void CheckAndThrow(Type t)
private void CheckAndThrow(MethodInfo m)
public IEnumerable`1<PropertyInfo> GetRuntimeProperties(Type type)
public IEnumerable`1<EventInfo> GetRuntimeEvents(Type type)
public IEnumerable`1<MethodInfo> GetRuntimeMethods(Type type)
public IEnumerable`1<FieldInfo> GetRuntimeFields(Type type)
public PropertyInfo GetRuntimeProperty(Type type, string name)
public EventInfo GetRuntimeEvent(Type type, string name)
public MethodInfo GetRuntimeMethod(Type type, string name, Type[] parameters)
public FieldInfo GetRuntimeField(Type type, string name)
public MethodInfo GetRuntimeBaseDefinition(MethodInfo method)
public InterfaceMapping GetRuntimeInterfaceMap(TypeInfo typeInfo, Type interfaceType)
public MethodInfo GetMethodInfo(Delegate del)
}
public System.Reflection.StrongNameKeyPair : object {
private Byte[] _publicKey
private string _keyPairContainer
private bool _keyPairExported
private Byte[] _keyPairArray
private RSA _rsa
public Byte[] PublicKey
public void .ctor(Byte[] keyPairArray)
public void .ctor(FileStream keyPairFile)
public void .ctor(string keyPairContainer)
protected void .ctor(SerializationInfo info, StreamingContext context)
private void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context)
private void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender)
private RSA GetRSA()
private void LoadKey(Byte[] key)
public Byte[] get_PublicKey()
internal StrongName StrongName()
}
public System.Reflection.TargetException : ApplicationException {
public void .ctor(string message)
public void .ctor(string message, Exception inner)
protected void .ctor(SerializationInfo info, StreamingContext context)
}
public System.Reflection.TargetInvocationException : ApplicationException {
private void .ctor(string message)
public void .ctor(Exception inner)
public void .ctor(string message, Exception inner)
internal void .ctor(SerializationInfo info, StreamingContext context)
}
public System.Reflection.TargetParameterCountException : ApplicationException {
public void .ctor(string message)
public void .ctor(string message, Exception inner)
internal void .ctor(SerializationInfo info, StreamingContext context)
}
public System.Reflection.TypeAttributes : Enum {
public int value__
public TypeAttributes VisibilityMask
public TypeAttributes NotPublic
public TypeAttributes Public
public TypeAttributes NestedPublic
public TypeAttributes NestedPrivate
public TypeAttributes NestedFamily
public TypeAttributes NestedAssembly
public TypeAttributes NestedFamANDAssem
public TypeAttributes NestedFamORAssem
public TypeAttributes LayoutMask
public TypeAttributes AutoLayout
public TypeAttributes SequentialLayout
public TypeAttributes ExplicitLayout
public TypeAttributes ClassSemanticsMask
public TypeAttributes Class
public TypeAttributes Interface
public TypeAttributes Abstract
public TypeAttributes Sealed
public TypeAttributes SpecialName
public TypeAttributes Import
public TypeAttributes Serializable
public TypeAttributes WindowsRuntime
public TypeAttributes StringFormatMask
public TypeAttributes AnsiClass
public TypeAttributes UnicodeClass
public TypeAttributes AutoClass
public TypeAttributes CustomFormatClass
public TypeAttributes CustomFormatMask
public TypeAttributes BeforeFieldInit
public TypeAttributes ReservedMask
public TypeAttributes RTSpecialName
public TypeAttributes HasSecurity
}
public System.Reflection.TypeDelegator : TypeInfo {
protected Type typeImpl
public Guid GUID
public int MetadataToken
public Module Module
public Assembly Assembly
public RuntimeTypeHandle TypeHandle
public string Name
public string FullName
public string Namespace
public string AssemblyQualifiedName
public Type BaseType
public bool IsConstructedGenericType
public Type UnderlyingSystemType
public bool IsSZArray
public bool IsAssignableFrom(TypeInfo typeInfo)
public void .ctor(Type delegatingType)
public Guid get_GUID()
public int get_MetadataToken()
public object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, Object[] args, ParameterModifier[] modifiers, CultureInfo culture, String[] namedParameters)
public Module get_Module()
public Assembly get_Assembly()
public RuntimeTypeHandle get_TypeHandle()
public string get_Name()
public string get_FullName()
public string get_Namespace()
public string get_AssemblyQualifiedName()
public Type get_BaseType()
protected ConstructorInfo GetConstructorImpl(BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers)
public ConstructorInfo[] GetConstructors(BindingFlags bindingAttr)
protected MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers)
public MethodInfo[] GetMethods(BindingFlags bindingAttr)
public FieldInfo GetField(string name, BindingFlags bindingAttr)
public FieldInfo[] GetFields(BindingFlags bindingAttr)
public Type GetInterface(string name, bool ignoreCase)
public Type[] GetInterfaces()
public EventInfo GetEvent(string name, BindingFlags bindingAttr)
public EventInfo[] GetEvents()
protected PropertyInfo GetPropertyImpl(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers)
public PropertyInfo[] GetProperties(BindingFlags bindingAttr)
public EventInfo[] GetEvents(BindingFlags bindingAttr)
public Type[] GetNestedTypes(BindingFlags bindingAttr)
public Type GetNestedType(string name, BindingFlags bindingAttr)
public MemberInfo[] GetMember(string name, MemberTypes type, BindingFlags bindingAttr)
public MemberInfo[] GetMembers(BindingFlags bindingAttr)
protected TypeAttributes GetAttributeFlagsImpl()
protected bool IsArrayImpl()
protected bool IsPrimitiveImpl()
protected bool IsByRefImpl()
protected bool IsPointerImpl()
protected bool IsValueTypeImpl()
protected bool IsCOMObjectImpl()
public bool get_IsConstructedGenericType()
public Type GetElementType()
protected bool HasElementTypeImpl()
public Type get_UnderlyingSystemType()
public Object[] GetCustomAttributes(bool inherit)
public Object[] GetCustomAttributes(Type attributeType, bool inherit)
public bool IsDefined(Type attributeType, bool inherit)
public InterfaceMapping GetInterfaceMap(Type interfaceType)
public bool get_IsSZArray()
}
public System.Reflection.TypeFilter : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public bool Invoke(Type m, object filterCriteria)
public IAsyncResult BeginInvoke(Type m, object filterCriteria, AsyncCallback callback, object object)
public bool EndInvoke(IAsyncResult result)
}
public System.Reflection.TypeInfo : Type {
public Type[] GenericTypeParameters
public IEnumerable`1<ConstructorInfo> DeclaredConstructors
public IEnumerable`1<EventInfo> DeclaredEvents
public IEnumerable`1<FieldInfo> DeclaredFields
public IEnumerable`1<MemberInfo> DeclaredMembers
public IEnumerable`1<MethodInfo> DeclaredMethods
public IEnumerable`1<TypeInfo> DeclaredNestedTypes
public IEnumerable`1<PropertyInfo> DeclaredProperties
public IEnumerable`1<Type> ImplementedInterfaces
private TypeInfo System.Reflection.IReflectableType.GetTypeInfo()
public Type AsType()
public Type[] get_GenericTypeParameters()
public bool IsAssignableFrom(TypeInfo typeInfo)
public EventInfo GetDeclaredEvent(string name)
public FieldInfo GetDeclaredField(string name)
public MethodInfo GetDeclaredMethod(string name)
public IEnumerable`1<MethodInfo> GetDeclaredMethods(string name)
public TypeInfo GetDeclaredNestedType(string name)
public PropertyInfo GetDeclaredProperty(string name)
public IEnumerable`1<ConstructorInfo> get_DeclaredConstructors()
public IEnumerable`1<EventInfo> get_DeclaredEvents()
public IEnumerable`1<FieldInfo> get_DeclaredFields()
public IEnumerable`1<MemberInfo> get_DeclaredMembers()
public IEnumerable`1<MethodInfo> get_DeclaredMethods()
public IEnumerable`1<TypeInfo> get_DeclaredNestedTypes()
public IEnumerable`1<PropertyInfo> get_DeclaredProperties()
public IEnumerable`1<Type> get_ImplementedInterfaces()
}
internal System.ReflectionOnlyType : RuntimeType {
public RuntimeTypeHandle TypeHandle
public RuntimeTypeHandle get_TypeHandle()
}
internal System.ResId : object {
internal string Arg_ArrayLengthsDiffer
internal string Argument_InvalidNumberOfMembers
internal string Argument_UnequalMembers
internal string Argument_SpecifyValueSize
internal string Argument_UnmatchingSymScope
internal string Argument_NotInExceptionBlock
internal string Argument_NotExceptionType
internal string Argument_InvalidLabel
internal string Argument_UnclosedExceptionBlock
internal string Argument_MissingDefaultConstructor
internal string Argument_TooManyFinallyClause
internal string Argument_NotInTheSameModuleBuilder
internal string Argument_BadCurrentLocalVariable
internal string Argument_DuplicateModuleName
internal string Argument_BadPersistableModuleInTransientAssembly
internal string Argument_HasToBeArrayClass
internal string Argument_InvalidDirectory
internal string MissingType
internal string MissingModule
internal string ArgumentOutOfRange_Index
internal string ArgumentOutOfRange_Range
internal string ExecutionEngine_YoureHosed
internal string Format_NeedSingleChar
internal string Format_StringZeroLength
internal string InvalidOperation_EnumEnded
internal string InvalidOperation_EnumFailedVersion
internal string InvalidOperation_EnumNotStarted
internal string InvalidOperation_EnumOpCantHappen
internal string InvalidOperation_InternalState
internal string InvalidOperation_ModifyRONumFmtInfo
internal string InvalidOperation_MethodBaked
internal string InvalidOperation_NotADebugModule
internal string InvalidOperation_MethodHasBody
internal string InvalidOperation_OpenLocalVariableScope
internal string InvalidOperation_TypeHasBeenCreated
internal string InvalidOperation_RefedAssemblyNotSaved
internal string InvalidOperation_AssemblyHasBeenSaved
internal string InvalidOperation_ModuleHasBeenSaved
internal string InvalidOperation_CannotAlterAssembly
internal string NotSupported_CannotSaveModuleIndividually
internal string NotSupported_Constructor
internal string NotSupported_Method
internal string NotSupported_NYI
internal string NotSupported_DynamicModule
internal string NotSupported_NotDynamicModule
internal string NotSupported_NotAllTypesAreBaked
internal string NotSupported_SortedListNestedWrite
internal string Serialization_ArrayInvalidLength
internal string Serialization_ArrayNoLength
internal string Serialization_CannotGetType
internal string Serialization_InsufficientState
internal string Serialization_InvalidID
internal string Serialization_MalformedArray
internal string Serialization_MultipleMembers
internal string Serialization_NoID
internal string Serialization_NoType
internal string Serialization_NoBaseType
internal string Serialization_NullSignature
internal string Serialization_UnknownMember
internal string Serialization_BadParameterInfo
internal string Serialization_NoParameterInfo
internal string WeakReference_NoLongerValid
internal string Loader_InvalidPath
}
public System.ResolveEventArgs : EventArgs {
private string m_Name
private Assembly m_Requesting
public string Name
public Assembly RequestingAssembly
public void .ctor(string name)
public void .ctor(string name, Assembly requestingAssembly)
public string get_Name()
public Assembly get_RequestingAssembly()
}
public System.ResolveEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public Assembly Invoke(object sender, ResolveEventArgs args)
public IAsyncResult BeginInvoke(object sender, ResolveEventArgs args, AsyncCallback callback, object object)
public Assembly EndInvoke(IAsyncResult result)
}
internal System.Resources.FastResourceComparer : object {
internal FastResourceComparer Default
public int GetHashCode(object key)
public int GetHashCode(string key)
internal int HashFunction(string key)
public int Compare(object a, object b)
public int Compare(string a, string b)
public bool Equals(string a, string b)
public bool Equals(object a, object b)
public int CompareOrdinal(string a, Byte[] bytes, int bCharLength)
public int CompareOrdinal(Byte[] bytes, int aCharLength, string b)
internal int CompareOrdinal(Byte* a, int byteLen, string b)
}
internal System.Resources.FileBasedResourceGroveler : object {
private ResourceManagerMediator _mediator
public void .ctor(ResourceManagerMediator mediator)
public ResourceSet GrovelForResourceSet(CultureInfo culture, Dictionary`2<string, ResourceSet> localResourceSets, bool tryParents, bool createIfNotExists, StackCrawlMark& stackMark)
public bool HasNeutralResources(CultureInfo culture, string defaultResName)
private string FindResourceFile(CultureInfo culture, string fileName)
private ResourceSet CreateResourceSet(string file)
}
internal System.Resources.ICONDIRENTRY : object {
public byte bWidth
public byte bHeight
public byte bColorCount
public byte bReserved
public short wPlanes
public short wBitCount
public int dwBytesInRes
public int dwImageOffset
public Byte[] image
public string ToString()
}
internal System.Resources.IResourceGroveler {
public ResourceSet GrovelForResourceSet(CultureInfo culture, Dictionary`2<string, ResourceSet> localResourceSets, bool tryParents, bool createIfNotExists, StackCrawlMark& stackMark)
public bool HasNeutralResources(CultureInfo culture, string defaultResName)
}
public System.Resources.IResourceReader {
public void Close()
public IDictionaryEnumerator GetEnumerator()
}
public System.Resources.IResourceWriter {
public void AddResource(string name, string value)
public void AddResource(string name, object value)
public void AddResource(string name, Byte[] value)
public void Close()
public void Generate()
}
internal System.Resources.ManifestBasedResourceGroveler : object {
private ResourceManagerMediator _mediator
public void .ctor(ResourceManagerMediator mediator)
public ResourceSet GrovelForResourceSet(CultureInfo culture, Dictionary`2<string, ResourceSet> localResourceSets, bool tryParents, bool createIfNotExists, StackCrawlMark& stackMark)
public bool HasNeutralResources(CultureInfo culture, string defaultResName)
private CultureInfo UltimateFallbackFixup(CultureInfo lookForCulture)
internal CultureInfo GetNeutralResourcesLanguage(Assembly a, UltimateResourceFallbackLocation& fallbackLocation)
internal ResourceSet CreateResourceSet(Stream store, Assembly assembly)
private Stream GetManifestResourceStream(RuntimeAssembly satellite, string fileName, StackCrawlMark& stackMark)
private Stream CaseInsensitiveManifestResourceStreamLookup(RuntimeAssembly satellite, string name)
private RuntimeAssembly GetSatelliteAssembly(CultureInfo lookForCulture, StackCrawlMark& stackMark)
private bool CanUseDefaultResourceClasses(string readerTypeName, string resSetTypeName)
private string GetSatelliteAssemblyName()
private void HandleSatelliteMissing()
private void HandleResourceStreamMissing(string fileName)
private bool GetNeutralResourcesLanguageAttribute(Assembly assembly, String& cultureName, Int16& fallbackLocation)
}
public System.Resources.MissingManifestResourceException : SystemException {
public void .ctor(string message)
public void .ctor(string message, Exception inner)
protected void .ctor(SerializationInfo info, StreamingContext context)
}
public System.Resources.MissingSatelliteAssemblyException : SystemException {
private string _cultureName
public string CultureName
public void .ctor(string message)
public void .ctor(string message, string cultureName)
public void .ctor(string message, Exception inner)
protected void .ctor(SerializationInfo info, StreamingContext context)
public string get_CultureName()
}
internal System.Resources.NameOrId : object {
private string name
private int id
public bool IsName
public string Name
public int Id
public void .ctor(string name)
public void .ctor(int id)
public bool get_IsName()
public string get_Name()
public int get_Id()
public string ToString()
}
public System.Resources.NeutralResourcesLanguageAttribute : Attribute {
private string _culture
private UltimateResourceFallbackLocation _fallbackLoc
public string CultureName
public UltimateResourceFallbackLocation Location
public void .ctor(string cultureName)
public void .ctor(string cultureName, UltimateResourceFallbackLocation location)
public string get_CultureName()
public UltimateResourceFallbackLocation get_Location()
}
internal System.Resources.ResourceFallbackManager : object {
private CultureInfo m_startingCulture
private CultureInfo m_neutralResourcesCulture
private bool m_useParents
internal void .ctor(CultureInfo startingCulture, CultureInfo neutralResourcesCulture, bool useParents)
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
public IEnumerator`1<CultureInfo> GetEnumerator()
}
internal System.Resources.ResourceLocator : ValueType {
internal object _value
internal int _dataPos
internal int DataPosition
internal object Value
internal void .ctor(int dataPos, object value)
internal int get_DataPosition()
internal object get_Value()
internal void set_Value(object value)
internal bool CanCache(ResourceTypeCode value)
}
public System.Resources.ResourceManager : object {
protected string BaseNameField
protected Hashtable ResourceSets
private Dictionary`2<string, ResourceSet> _resourceSets
private string moduleDir
protected Assembly MainAssembly
private Type _locationInfo
private Type _userResourceSet
private CultureInfo _neutralResourcesCulture
private CultureNameResourceSetPair _lastUsedResourceCache
private bool _ignoreCase
private bool UseManifest
private bool UseSatelliteAssem
private UltimateResourceFallbackLocation _fallbackLoc
private Version _satelliteContractVersion
private bool _lookedForSatelliteContractVersion
private Assembly _callingAssembly
private RuntimeAssembly m_callingAssembly
private IResourceGroveler resourceGroveler
public int MagicNumber
public int HeaderVersionNumber
private Type _minResourceSet
internal string ResReaderTypeName
internal string ResSetTypeName
internal string MscorlibName
internal string ResFileExtension
internal int ResFileExtensionLength
internal int DEBUG
public string BaseName
public bool IgnoreCase
public Type ResourceSetType
protected UltimateResourceFallbackLocation FallbackLocation
private void Init()
private void .ctor(string baseName, string resourceDir, Type usingResourceSet)
public void .ctor(string baseName, Assembly assembly)
public void .ctor(string baseName, Assembly assembly, Type usingResourceSet)
public void .ctor(Type resourceSource)
private void OnDeserializing(StreamingContext ctx)
private void OnDeserialized(StreamingContext ctx)
private void OnSerializing(StreamingContext ctx)
private void CommonAssemblyInit()
public string get_BaseName()
public bool get_IgnoreCase()
public void set_IgnoreCase(bool value)
public Type get_ResourceSetType()
protected UltimateResourceFallbackLocation get_FallbackLocation()
protected void set_FallbackLocation(UltimateResourceFallbackLocation value)
public void ReleaseAllResources()
public ResourceManager CreateFileBasedResourceManager(string baseName, string resourceDir, Type usingResourceSet)
protected string GetResourceFileName(CultureInfo culture)
internal ResourceSet GetFirstResourceSet(CultureInfo culture)
public ResourceSet GetResourceSet(CultureInfo culture, bool createIfNotExists, bool tryParents)
protected ResourceSet InternalGetResourceSet(CultureInfo culture, bool createIfNotExists, bool tryParents)
private ResourceSet InternalGetResourceSet(CultureInfo requestedCulture, bool createIfNotExists, bool tryParents, StackCrawlMark& stackMark)
private void AddResourceSet(Dictionary`2<string, ResourceSet> localResourceSets, string cultureName, ResourceSet& rs)
protected Version GetSatelliteContractVersion(Assembly a)
protected CultureInfo GetNeutralResourcesLanguage(Assembly a)
internal bool CompareNames(string asmTypeName1, string typeName2, AssemblyName asmName2)
private void SetAppXConfiguration()
public string GetString(string name)
public string GetString(string name, CultureInfo culture)
public object GetObject(string name)
public object GetObject(string name, CultureInfo culture)
private object GetObject(string name, CultureInfo culture, bool wrapUnmanagedMemStream)
public UnmanagedMemoryStream GetStream(string name)
public UnmanagedMemoryStream GetStream(string name, CultureInfo culture)
}
public System.Resources.ResourceReader : object {
private int DefaultFileStreamBufferSize
private BinaryReader _store
internal Dictionary`2<string, ResourceLocator> _resCache
private long _nameSectionOffset
private long _dataSectionOffset
private Int32[] _nameHashes
private Int32* _nameHashesPtr
private Int32[] _namePositions
private Int32* _namePositionsPtr
private RuntimeType[] _typeTable
private Int32[] _typeNamePositions
private BinaryFormatter _objFormatter
private int _numResources
private UnmanagedMemoryStream _ums
private int _version
public void .ctor(string fileName)
public void .ctor(Stream stream)
internal void .ctor(Stream stream, Dictionary`2<string, ResourceLocator> resCache)
public void Close()
public void Dispose()
private void Dispose(bool disposing)
internal int ReadUnalignedI4(Int32* p)
private void SkipInt32()
private void SkipString()
private int GetNameHash(int index)
private int GetNamePosition(int index)
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
public IDictionaryEnumerator GetEnumerator()
internal ResourceEnumerator GetEnumeratorInternal()
internal int FindPosForResource(string name)
private bool CompareStringEqualsName(string name)
private string AllocateStringForNameIndex(int index, Int32& dataOffset)
private object GetValueForNameIndex(int index)
internal string LoadString(int pos)
internal object LoadObject(int pos)
internal object LoadObject(int pos, ResourceTypeCode& typeCode)
internal object LoadObjectV1(int pos)
private object _LoadObjectV1(int pos)
internal object LoadObjectV2(int pos, ResourceTypeCode& typeCode)
private object _LoadObjectV2(int pos, ResourceTypeCode& typeCode)
private object DeserializeObject(int typeIndex)
private void ReadResources()
private void _ReadResources()
private RuntimeType FindType(int typeIndex)
public void GetResourceData(string resourceName, String& resourceType, Byte[]& resourceData)
private string TypeNameFromTypeCode(ResourceTypeCode typeCode)
}
public System.Resources.ResourceSet : object {
protected IResourceReader Reader
protected Hashtable Table
private Hashtable _caseInsensitiveTable
internal void .ctor(bool junk)
public void .ctor(string fileName)
public void .ctor(Stream stream)
public void .ctor(IResourceReader reader)
private void CommonInit()
public void Close()
protected void Dispose(bool disposing)
public void Dispose()
public Type GetDefaultReader()
public Type GetDefaultWriter()
public IDictionaryEnumerator GetEnumerator()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
private IDictionaryEnumerator GetEnumeratorHelper()
public string GetString(string name)
public string GetString(string name, bool ignoreCase)
public object GetObject(string name)
public object GetObject(string name, bool ignoreCase)
protected void ReadResources()
private object GetObjectInternal(string name)
private object GetCaseInsensitiveObjectInternal(string name)
}
internal System.Resources.ResourceTypeCode : Enum {
public int value__
public ResourceTypeCode Null
public ResourceTypeCode String
public ResourceTypeCode Boolean
public ResourceTypeCode Char
public ResourceTypeCode Byte
public ResourceTypeCode SByte
public ResourceTypeCode Int16
public ResourceTypeCode UInt16
public ResourceTypeCode Int32
public ResourceTypeCode UInt32
public ResourceTypeCode Int64
public ResourceTypeCode UInt64
public ResourceTypeCode Single
public ResourceTypeCode Double
public ResourceTypeCode Decimal
public ResourceTypeCode DateTime
public ResourceTypeCode TimeSpan
public ResourceTypeCode LastPrimitive
public ResourceTypeCode ByteArray
public ResourceTypeCode Stream
public ResourceTypeCode StartOfUserTypes
}
public System.Resources.ResourceWriter : object {
private Func`2<Type, string> typeConverter
private int _ExpectedNumberOfResources
private int AverageNameSize
private int AverageValueSize
private Dictionary`2<string, object> _resourceList
internal Stream _output
private Dictionary`2<string, object> _caseInsensitiveDups
private Dictionary`2<string, PrecannedResource> _preserializedData
private int _DefaultBufferSize
public Func`2<Type, string> TypeNameConverter
public Func`2<Type, string> get_TypeNameConverter()
public void set_TypeNameConverter(Func`2<Type, string> value)
public void .ctor(string fileName)
public void .ctor(Stream stream)
public void AddResource(string name, string value)
public void AddResource(string name, object value)
public void AddResource(string name, Stream value)
public void AddResource(string name, Stream value, bool closeAfterWrite)
private void AddResourceInternal(string name, Stream value, bool closeAfterWrite)
public void AddResource(string name, Byte[] value)
public void AddResourceData(string name, string typeName, Byte[] serializedData)
public void Close()
private void Dispose(bool disposing)
public void Dispose()
public void Generate()
private ResourceTypeCode FindTypeCode(object value, List`1<string> types)
private void WriteValue(ResourceTypeCode typeCode, object value, BinaryWriter writer, IFormatter objFormatter)
private void Write7BitEncodedInt(BinaryWriter store, int value)
}
internal System.Resources.RuntimeResourceSet : ResourceSet {
internal int Version
private Dictionary`2<string, ResourceLocator> _resCache
private ResourceReader _defaultReader
private Dictionary`2<string, ResourceLocator> _caseInsensitiveTable
private bool _haveReadFromReader
internal void .ctor(string fileName)
internal void .ctor(Stream stream)
protected void Dispose(bool disposing)
public IDictionaryEnumerator GetEnumerator()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
private IDictionaryEnumerator GetEnumeratorHelper()
public string GetString(string key)
public string GetString(string key, bool ignoreCase)
public object GetObject(string key)
public object GetObject(string key, bool ignoreCase)
private object GetObject(string key, bool ignoreCase, bool isString)
private object ResolveResourceLocator(ResourceLocator resLocation, string key, Dictionary`2<string, ResourceLocator> copyOfCache, bool keyInWrongCase)
}
public System.Resources.SatelliteContractVersionAttribute : Attribute {
private string _version
public string Version
public void .ctor(string version)
public string get_Version()
}
public System.Resources.UltimateResourceFallbackLocation : Enum {
public int value__
public UltimateResourceFallbackLocation MainAssembly
public UltimateResourceFallbackLocation Satellite
}
internal System.Resources.Win32EncodedResource : Win32Resource {
private Byte[] data
public Byte[] Data
internal void .ctor(NameOrId type, NameOrId name, int language, Byte[] data)
public Byte[] get_Data()
public void WriteTo(Stream s)
}
internal System.Resources.Win32GroupIconResource : Win32Resource {
private Win32IconResource[] icons
public void .ctor(int id, int language, Win32IconResource[] icons)
public void WriteTo(Stream s)
}
internal System.Resources.Win32IconFileReader : object {
private Stream iconFile
public void .ctor(Stream s)
public ICONDIRENTRY[] ReadIcons()
}
internal System.Resources.Win32IconResource : Win32Resource {
private ICONDIRENTRY icon
public ICONDIRENTRY Icon
public void .ctor(int id, int language, ICONDIRENTRY icon)
public ICONDIRENTRY get_Icon()
public void WriteTo(Stream s)
}
internal System.Resources.Win32ResFileReader : object {
private Stream res_file
public void .ctor(Stream s)
private int read_int16()
private int read_int32()
private bool read_padding()
private NameOrId read_ordinal()
public ICollection ReadResources()
}
internal System.Resources.Win32Resource : object {
private NameOrId type
private NameOrId name
private int language
public Win32ResourceType ResourceType
public NameOrId Name
public NameOrId Type
public int Language
internal void .ctor(NameOrId type, NameOrId name, int language)
internal void .ctor(Win32ResourceType type, int name, int language)
public Win32ResourceType get_ResourceType()
public NameOrId get_Name()
public NameOrId get_Type()
public int get_Language()
public void WriteTo(Stream s)
public string ToString()
}
internal System.Resources.Win32ResourceType : Enum {
public int value__
public Win32ResourceType RT_CURSOR
public Win32ResourceType RT_FONT
public Win32ResourceType RT_BITMAP
public Win32ResourceType RT_ICON
public Win32ResourceType RT_MENU
public Win32ResourceType RT_DIALOG
public Win32ResourceType RT_STRING
public Win32ResourceType RT_FONTDIR
public Win32ResourceType RT_ACCELERATOR
public Win32ResourceType RT_RCDATA
public Win32ResourceType RT_MESSAGETABLE
public Win32ResourceType RT_GROUP_CURSOR
public Win32ResourceType RT_GROUP_ICON
public Win32ResourceType RT_VERSION
public Win32ResourceType RT_DLGINCLUDE
public Win32ResourceType RT_PLUGPLAY
public Win32ResourceType RT_VXD
public Win32ResourceType RT_ANICURSOR
public Win32ResourceType RT_ANIICON
public Win32ResourceType RT_HTML
}
internal System.Resources.Win32VersionResource : Win32Resource {
public String[] WellKnownProperties
private long signature
private int struct_version
private long file_version
private long product_version
private int file_flags_mask
private int file_flags
private int file_os
private int file_type
private int file_subtype
private long file_date
private int file_lang
private int file_codepage
private Hashtable properties
public string Version
public string Item
public string Comments
public string CompanyName
public string LegalCopyright
public string LegalTrademarks
public string OriginalFilename
public string ProductName
public string ProductVersion
public string InternalName
public string FileDescription
public int FileLanguage
public string FileVersion
public void .ctor(int id, int language, bool compilercontext)
public string get_Version()
public void set_Version(string value)
public void set_Item(string key, string value)
public string get_Comments()
public void set_Comments(string value)
public string get_CompanyName()
public void set_CompanyName(string value)
public string get_LegalCopyright()
public void set_LegalCopyright(string value)
public string get_LegalTrademarks()
public void set_LegalTrademarks(string value)
public string get_OriginalFilename()
public void set_OriginalFilename(string value)
public string get_ProductName()
public void set_ProductName(string value)
public string get_ProductVersion()
public void set_ProductVersion(string value)
public string get_InternalName()
public void set_InternalName(string value)
public string get_FileDescription()
public void set_FileDescription(string value)
public int get_FileLanguage()
public void set_FileLanguage(int value)
public string get_FileVersion()
public void set_FileVersion(string value)
private void emit_padding(BinaryWriter w)
private void patch_length(BinaryWriter w, long len_pos)
public void WriteTo(Stream ms)
}
public System.Runtime.AssemblyTargetedPatchBandAttribute : Attribute {
private string m_targetedPatchBand
public string TargetedPatchBand
public void .ctor(string targetedPatchBand)
public string get_TargetedPatchBand()
}
public System.Runtime.CompilerServices.AccessedThroughPropertyAttribute : Attribute {
private string propertyName
public string PropertyName
public void .ctor(string propertyName)
public string get_PropertyName()
}
public System.Runtime.CompilerServices.AsyncMethodBuilderAttribute : Attribute {
private Type <BuilderType>k__BackingField
public Type BuilderType
public void .ctor(Type builderType)
public Type get_BuilderType()
}
internal System.Runtime.CompilerServices.AsyncMethodBuilderCore : ValueType {
internal IAsyncStateMachine m_stateMachine
internal Action m_defaultContextAction
public void SetStateMachine(IAsyncStateMachine stateMachine)
internal Action GetCompletionAction(Task taskForTracing, MoveNextRunner& runnerToInitialize)
private Action OutputAsyncCausalityEvents(Task innerTask, Action continuation)
internal void PostBoxInitialization(IAsyncStateMachine stateMachine, MoveNextRunner runner, Task builtTask)
internal void ThrowAsync(Exception exception, SynchronizationContext targetContext)
internal Action CreateContinuationWrapper(Action continuation, Action invokeAction, Task innerTask)
internal Action TryGetStateMachineForDebugger(Action action)
internal Task TryGetContinuationTask(Action action)
}
public System.Runtime.CompilerServices.AsyncStateMachineAttribute : StateMachineAttribute {
public void .ctor(Type stateMachineType)
}
internal System.Runtime.CompilerServices.AsyncTaskCache : object {
internal Task`1<bool> TrueTask
internal Task`1<bool> FalseTask
internal Task`1[] Int32Tasks
internal int INCLUSIVE_INT32_MIN
internal int EXCLUSIVE_INT32_MAX
private Task`1[] CreateInt32Tasks()
internal Task`1<TResult> CreateCacheableTask(TResult result)
}
public System.Runtime.CompilerServices.AsyncTaskMethodBuilder : ValueType {
private Task`1<VoidTaskResult> s_cachedCompleted
private AsyncTaskMethodBuilder`1<VoidTaskResult> m_builder
public Task Task
private object ObjectIdForDebugger
public AsyncTaskMethodBuilder Create()
public void Start(TStateMachine& stateMachine)
public void SetStateMachine(IAsyncStateMachine stateMachine)
public void AwaitOnCompleted(TAwaiter& awaiter, TStateMachine& stateMachine)
public void AwaitUnsafeOnCompleted(TAwaiter& awaiter, TStateMachine& stateMachine)
public Task get_Task()
public void SetResult()
public void SetException(Exception exception)
internal void SetNotificationForWaitCompletion(bool enabled)
private object get_ObjectIdForDebugger()
}
public System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1 : ValueType {
internal Task`1<TResult> s_defaultResultTask
private AsyncMethodBuilderCore m_coreState
private Task`1<TResult> m_task
public Task`1<TResult> Task
private object ObjectIdForDebugger
public AsyncTaskMethodBuilder`1<TResult> Create()
public void Start(TStateMachine& stateMachine)
public void SetStateMachine(IAsyncStateMachine stateMachine)
public void AwaitOnCompleted(TAwaiter& awaiter, TStateMachine& stateMachine)
public void AwaitUnsafeOnCompleted(TAwaiter& awaiter, TStateMachine& stateMachine)
public Task`1<TResult> get_Task()
public void SetResult(TResult result)
internal void SetResult(Task`1<TResult> completedTask)
public void SetException(Exception exception)
internal void SetNotificationForWaitCompletion(bool enabled)
private object get_ObjectIdForDebugger()
private Task`1<TResult> GetTaskForResult(TResult result)
}
public System.Runtime.CompilerServices.AsyncValueTaskMethodBuilder`1 : ValueType {
private AsyncTaskMethodBuilder`1<TResult> _methodBuilder
private TResult _result
private bool _haveResult
private bool _useBuilder
public ValueTask`1<TResult> Task
public AsyncValueTaskMethodBuilder`1<TResult> Create()
public void Start(TStateMachine& stateMachine)
public void SetStateMachine(IAsyncStateMachine stateMachine)
public void SetResult(TResult result)
public void SetException(Exception exception)
public ValueTask`1<TResult> get_Task()
public void AwaitOnCompleted(TAwaiter& awaiter, TStateMachine& stateMachine)
public void AwaitUnsafeOnCompleted(TAwaiter& awaiter, TStateMachine& stateMachine)
}
public System.Runtime.CompilerServices.AsyncVoidMethodBuilder : ValueType {
private SynchronizationContext m_synchronizationContext
private AsyncMethodBuilderCore m_coreState
private Task m_task
private Task Task
private object ObjectIdForDebugger
public AsyncVoidMethodBuilder Create()
public void Start(TStateMachine& stateMachine)
public void SetStateMachine(IAsyncStateMachine stateMachine)
public void AwaitOnCompleted(TAwaiter& awaiter, TStateMachine& stateMachine)
public void AwaitUnsafeOnCompleted(TAwaiter& awaiter, TStateMachine& stateMachine)
public void SetResult()
public void SetException(Exception exception)
private void NotifySynchronizationContextOfCompletion()
private Task get_Task()
private object get_ObjectIdForDebugger()
}
public System.Runtime.CompilerServices.CompilationRelaxations : Enum {
public int value__
public CompilationRelaxations NoStringInterning
}
public System.Runtime.CompilerServices.CompilationRelaxationsAttribute : Attribute {
private int m_relaxations
public int CompilationRelaxations
public void .ctor(int relaxations)
public void .ctor(CompilationRelaxations relaxations)
public int get_CompilationRelaxations()
}
public System.Runtime.CompilerServices.ConditionalWeakTable`2 : object {
private int INITIAL_SIZE
private float LOAD_FACTOR
private float COMPACT_FACTOR
private float EXPAND_FACTOR
private Ephemeron[] data
private object _lock
private int size
internal ICollection`1<TKey> Keys
internal ICollection`1<TValue> Values
protected void Finalize()
private void RehashWithoutResize()
private void RecomputeSize()
private void Rehash()
public void Add(TKey key, TValue value)
public bool Remove(TKey key)
public bool TryGetValue(TKey key, TValue& value)
public TValue GetOrCreateValue(TKey key)
public TValue GetValue(TKey key, CreateValueCallback<TKey, TValue> createValueCallback)
internal TKey FindEquivalentKeyUnsafe(TKey key, TValue& value)
internal void Clear()
internal ICollection`1<TKey> get_Keys()
internal ICollection`1<TValue> get_Values()
}
public System.Runtime.CompilerServices.ConfiguredTaskAwaitable : ValueType {
private ConfiguredTaskAwaiter m_configuredTaskAwaiter
internal void .ctor(Task task, bool continueOnCapturedContext)
public ConfiguredTaskAwaiter GetAwaiter()
}
public System.Runtime.CompilerServices.ConfiguredTaskAwaitable`1 : ValueType {
private ConfiguredTaskAwaiter<TResult> m_configuredTaskAwaiter
internal void .ctor(Task`1<TResult> task, bool continueOnCapturedContext)
public ConfiguredTaskAwaiter<TResult> GetAwaiter()
}
public System.Runtime.CompilerServices.ConfiguredValueTaskAwaitable`1 : ValueType {
private ValueTask`1<TResult> _value
private bool _continueOnCapturedContext
internal void .ctor(ValueTask`1<TResult> value, bool continueOnCapturedContext)
public ConfiguredValueTaskAwaiter<TResult> GetAwaiter()
}
public System.Runtime.CompilerServices.ContractHelper : object {
private EventHandler`1 modreq(System.Runtime.CompilerServices.IsVolatile) contractFailedEvent
private object lockObject
internal int COR_E_CODECONTRACTFAILED
public string RaiseContractFailedEvent(ContractFailureKind failureKind, string userMessage, string conditionText, Exception innerException)
public void TriggerFailure(ContractFailureKind kind, string displayMessage, string userMessage, string conditionText, Exception innerException)
private void RaiseContractFailedEventImplementation(ContractFailureKind failureKind, string userMessage, string conditionText, Exception innerException, String& resultFailureMessage)
private void TriggerFailureImplementation(ContractFailureKind kind, string displayMessage, string userMessage, string conditionText, Exception innerException)
internal void add_InternalContractFailed(EventHandler`1<ContractFailedEventArgs> value)
internal void remove_InternalContractFailed(EventHandler`1<ContractFailedEventArgs> value)
private string GetResourceNameForFailure(ContractFailureKind failureKind, bool withCondition)
private string GetDisplayMessage(ContractFailureKind failureKind, string userMessage, string conditionText)
private void TriggerCodeContractEscalationPolicy(ContractFailureKind failureKind, string message, string conditionText, Exception innerException)
}
public System.Runtime.CompilerServices.CustomConstantAttribute : Attribute {
public object Value
public object get_Value()
internal object GetRawConstant(CustomAttributeData attr)
}
public System.Runtime.CompilerServices.DateTimeConstantAttribute : CustomConstantAttribute {
private DateTime date
public object Value
public void .ctor(long ticks)
public object get_Value()
internal DateTime GetRawDateTimeConstant(CustomAttributeData attr)
}
public System.Runtime.CompilerServices.DecimalConstantAttribute : Attribute {
private decimal dec
public decimal Value
public void .ctor(byte scale, byte sign, UInt32 hi, UInt32 mid, UInt32 low)
public void .ctor(byte scale, byte sign, int hi, int mid, int low)
public decimal get_Value()
internal decimal GetRawDecimalConstant(CustomAttributeData attr)
}
internal System.Runtime.CompilerServices.DecoratedNameAttribute : Attribute {
public void .ctor(string decoratedName)
}
public System.Runtime.CompilerServices.DefaultDependencyAttribute : Attribute {
private LoadHint loadHint
public LoadHint LoadHint
public void .ctor(LoadHint loadHintArgument)
public LoadHint get_LoadHint()
}
public System.Runtime.CompilerServices.DependencyAttribute : Attribute {
private string dependentAssembly
private LoadHint loadHint
public string DependentAssembly
public LoadHint LoadHint
public void .ctor(string dependentAssemblyArgument, LoadHint loadHintArgument)
public string get_DependentAssembly()
public LoadHint get_LoadHint()
}
internal System.Runtime.CompilerServices.Ephemeron : ValueType {
internal object key
internal object value
}
public System.Runtime.CompilerServices.FixedBufferAttribute : Attribute {
private Type elementType
private int length
public Type ElementType
public int Length
public void .ctor(Type elementType, int length)
public Type get_ElementType()
public int get_Length()
}
public System.Runtime.CompilerServices.FormattableStringFactory : object {
public FormattableString Create(string format, Object[] arguments)
}
public System.Runtime.CompilerServices.IAsyncStateMachine {
public void MoveNext()
public void SetStateMachine(IAsyncStateMachine stateMachine)
}
public System.Runtime.CompilerServices.ICriticalNotifyCompletion {
public void UnsafeOnCompleted(Action continuation)
}
public System.Runtime.CompilerServices.IDispatchConstantAttribute : CustomConstantAttribute {
public object Value
public object get_Value()
}
public System.Runtime.CompilerServices.IndexerNameAttribute : Attribute {
public void .ctor(string indexerName)
}
public System.Runtime.CompilerServices.INotifyCompletion {
public void OnCompleted(Action continuation)
}
public System.Runtime.CompilerServices.InternalsVisibleToAttribute : Attribute {
private string _assemblyName
private bool _allInternalsVisible
public string AssemblyName
public bool AllInternalsVisible
public void .ctor(string assemblyName)
public string get_AssemblyName()
public bool get_AllInternalsVisible()
public void set_AllInternalsVisible(bool value)
}
public System.Runtime.CompilerServices.IteratorStateMachineAttribute : StateMachineAttribute {
public void .ctor(Type stateMachineType)
}
public System.Runtime.CompilerServices.ITuple {
public int Length
public object Item
public int get_Length()
public object get_Item(int index)
}
public System.Runtime.CompilerServices.IUnknownConstantAttribute : CustomConstantAttribute {
public object Value
public object get_Value()
}
internal System.Runtime.CompilerServices.JitHelpers : object {
internal T UnsafeCast(object o)
internal int UnsafeEnumCast(T val)
internal long UnsafeEnumCastLong(T val)
}
public System.Runtime.CompilerServices.LoadHint : Enum {
public int value__
public LoadHint Default
public LoadHint Always
public LoadHint Sometimes
}
public System.Runtime.CompilerServices.MethodCodeType : Enum {
public int value__
public MethodCodeType IL
public MethodCodeType Native
public MethodCodeType OPTIL
public MethodCodeType Runtime
}
public System.Runtime.CompilerServices.MethodImplAttribute : Attribute {
internal MethodImplOptions _val
public MethodCodeType MethodCodeType
public MethodImplOptions Value
internal void .ctor(MethodImplAttributes methodImplAttributes)
public void .ctor(MethodImplOptions methodImplOptions)
public void .ctor(short value)
public MethodImplOptions get_Value()
}
public System.Runtime.CompilerServices.MethodImplOptions : Enum {
public int value__
public MethodImplOptions Unmanaged
public MethodImplOptions ForwardRef
public MethodImplOptions PreserveSig
public MethodImplOptions InternalCall
public MethodImplOptions Synchronized
public MethodImplOptions NoInlining
public MethodImplOptions AggressiveInlining
public MethodImplOptions NoOptimization
}
public System.Runtime.CompilerServices.ReferenceAssemblyAttribute : Attribute {
private string _description
public string Description
public void .ctor(string description)
public string get_Description()
}
public System.Runtime.CompilerServices.RequiredAttributeAttribute : Attribute {
private Type requiredContract
public Type RequiredContract
public void .ctor(Type requiredContract)
public Type get_RequiredContract()
}
public System.Runtime.CompilerServices.RuntimeCompatibilityAttribute : Attribute {
private bool m_wrapNonExceptionThrows
public bool WrapNonExceptionThrows
public bool get_WrapNonExceptionThrows()
public void set_WrapNonExceptionThrows(bool value)
}
public System.Runtime.CompilerServices.RuntimeFeature : object {
public string PortablePdb
public bool IsSupported(string feature)
}
public System.Runtime.CompilerServices.RuntimeHelpers : object {
public int OffsetToStringData
private void InitializeArray(Array array, IntPtr fldHandle)
public void InitializeArray(Array array, RuntimeFieldHandle fldHandle)
public int get_OffsetToStringData()
public int GetHashCode(object o)
public bool Equals(object o1, object o2)
public object GetObjectValue(object obj)
private void RunClassConstructor(IntPtr type)
public void RunClassConstructor(RuntimeTypeHandle type)
private bool SufficientExecutionStack()
public void EnsureSufficientExecutionStack()
public bool TryEnsureSufficientExecutionStack()
public void ExecuteCodeWithGuaranteedCleanup(TryCode code, CleanupCode backoutCode, object userData)
public void PrepareConstrainedRegions()
public void PrepareConstrainedRegionsNoOP()
public void ProbeForSufficientStack()
public void PrepareDelegate(Delegate d)
public void PrepareContractedDelegate(Delegate d)
public void PrepareMethod(RuntimeMethodHandle method)
public void PrepareMethod(RuntimeMethodHandle method, RuntimeTypeHandle[] instantiation)
public void RunModuleConstructor(ModuleHandle module)
private void RunModuleConstructor(IntPtr module)
public bool IsReferenceOrContainsReferences()
}
public System.Runtime.CompilerServices.RuntimeWrappedException : Exception {
private object m_wrappedException
public object WrappedException
private void .ctor(object thrownObject)
public object get_WrappedException()
public void GetObjectData(SerializationInfo info, StreamingContext context)
internal void .ctor(SerializationInfo info, StreamingContext context)
}
public System.Runtime.CompilerServices.StateMachineAttribute : Attribute {
private Type <StateMachineType>k__BackingField
public Type StateMachineType
public Type get_StateMachineType()
private void set_StateMachineType(Type value)
public void .ctor(Type stateMachineType)
}
public System.Runtime.CompilerServices.TaskAwaiter : ValueType {
private Task m_task
public bool IsCompleted
internal void .ctor(Task task)
public bool get_IsCompleted()
public void OnCompleted(Action continuation)
public void UnsafeOnCompleted(Action continuation)
public void GetResult()
internal void ValidateEnd(Task task)
private void HandleNonSuccessAndDebuggerNotification(Task task)
private void ThrowForNonSuccess(Task task)
internal void OnCompletedInternal(Task task, Action continuation, bool continueOnCapturedContext, bool flowExecutionContext)
private Action OutputWaitEtwEvents(Task task, Action continuation)
}
public System.Runtime.CompilerServices.TaskAwaiter`1 : ValueType {
private Task`1<TResult> m_task
public bool IsCompleted
internal void .ctor(Task`1<TResult> task)
public bool get_IsCompleted()
public void OnCompleted(Action continuation)
public void UnsafeOnCompleted(Action continuation)
public TResult GetResult()
}
public System.Runtime.CompilerServices.TupleElementNamesAttribute : Attribute {
private String[] _transformNames
public IList`1<string> TransformNames
public void .ctor(String[] transformNames)
public IList`1<string> get_TransformNames()
}
internal System.Runtime.CompilerServices.TypeDependencyAttribute : Attribute {
private string typeName
public void .ctor(string typeName)
}
public System.Runtime.CompilerServices.TypeForwardedFromAttribute : Attribute {
private string assemblyFullName
public string AssemblyFullName
public void .ctor(string assemblyFullName)
public string get_AssemblyFullName()
}
public System.Runtime.CompilerServices.TypeForwardedToAttribute : Attribute {
private Type _destination
public Type Destination
public void .ctor(Type destination)
public Type get_Destination()
}
internal System.Runtime.CompilerServices.Unsafe : object {
public T& Add(T& source, int elementOffset)
public T& Add(T& source, IntPtr elementOffset)
public Void* Add(Void* source, int elementOffset)
public T& AddByteOffset(T& source, IntPtr byteOffset)
public bool AreSame(T& left, T& right)
public T As(object o)
public TTo& As(TFrom& source)
public T& AsRef(Void* source)
public IntPtr ByteOffset(T& origin, T& target)
public void CopyBlock(Byte& destination, Byte& source, UInt32 byteCount)
public void InitBlockUnaligned(Byte& startAddress, byte value, UInt32 byteCount)
public void InitBlockUnaligned(Void* startAddress, byte value, UInt32 byteCount)
public T Read(Void* source)
public T ReadUnaligned(Byte& source)
public int SizeOf()
public T& Subtract(T& source, int elementOffset)
public void WriteUnaligned(Byte& destination, T value)
}
public System.Runtime.CompilerServices.ValueTaskAwaiter`1 : ValueType {
private ValueTask`1<TResult> _value
public bool IsCompleted
internal void .ctor(ValueTask`1<TResult> value)
public bool get_IsCompleted()
public TResult GetResult()
public void OnCompleted(Action continuation)
public void UnsafeOnCompleted(Action continuation)
}
public System.Runtime.CompilerServices.YieldAwaitable : ValueType {
public YieldAwaiter GetAwaiter()
}
public System.Runtime.ConstrainedExecution.Cer : Enum {
public int value__
public Cer None
public Cer MayFail
public Cer Success
}
public System.Runtime.ConstrainedExecution.Consistency : Enum {
public int value__
public Consistency MayCorruptProcess
public Consistency MayCorruptAppDomain
public Consistency MayCorruptInstance
public Consistency WillNotCorruptState
}
public System.Runtime.ConstrainedExecution.CriticalFinalizerObject : object {
protected void Finalize()
}
public System.Runtime.ConstrainedExecution.ReliabilityContractAttribute : Attribute {
private Consistency _consistency
private Cer _cer
public Consistency ConsistencyGuarantee
public Cer Cer
public void .ctor(Consistency consistencyGuarantee, Cer cer)
public Consistency get_ConsistencyGuarantee()
public Cer get_Cer()
}
public System.Runtime.DesignerServices.WindowsRuntimeDesignerContext : object {
public string Name
public void .ctor(IEnumerable`1<string> paths, string name)
public string get_Name()
public Assembly GetAssembly(string assemblyName)
public Type GetType(string typeName)
public void InitializeSharedContext(IEnumerable`1<string> paths)
public void SetIterationContext(WindowsRuntimeDesignerContext context)
}
public System.Runtime.ExceptionServices.ExceptionDispatchInfo : object {
private Exception m_Exception
private object m_stackTrace
internal object BinaryStackTraceArray
public Exception SourceException
private void .ctor(Exception exception)
internal object get_BinaryStackTraceArray()
public ExceptionDispatchInfo Capture(Exception source)
public Exception get_SourceException()
public void Throw()
public void Throw(Exception source)
}
public System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs : EventArgs {
private Exception m_Exception
public Exception Exception
public void .ctor(Exception exception)
public Exception get_Exception()
}
public System.Runtime.GCLargeObjectHeapCompactionMode : Enum {
public int value__
public GCLargeObjectHeapCompactionMode Default
public GCLargeObjectHeapCompactionMode CompactOnce
}
public System.Runtime.GCLatencyMode : Enum {
public int value__
public GCLatencyMode Batch
public GCLatencyMode Interactive
public GCLatencyMode LowLatency
public GCLatencyMode SustainedLowLatency
public GCLatencyMode NoGCRegion
}
public System.Runtime.GCSettings : object {
private GCLargeObjectHeapCompactionMode <LargeObjectHeapCompactionMode>k__BackingField
public bool IsServerGC
public GCLatencyMode LatencyMode
public GCLargeObjectHeapCompactionMode LargeObjectHeapCompactionMode
public bool get_IsServerGC()
public GCLatencyMode get_LatencyMode()
public void set_LatencyMode(GCLatencyMode value)
public GCLargeObjectHeapCompactionMode get_LargeObjectHeapCompactionMode()
public void set_LargeObjectHeapCompactionMode(GCLargeObjectHeapCompactionMode value)
}
public System.Runtime.Hosting.ActivationArguments : EvidenceBase {
private ActivationContext _context
private ApplicationIdentity _identity
private String[] _data
public ActivationContext ActivationContext
public String[] ActivationData
public ApplicationIdentity ApplicationIdentity
public void .ctor(ActivationContext activationData)
public void .ctor(ApplicationIdentity applicationIdentity)
public void .ctor(ActivationContext activationContext, String[] activationData)
public void .ctor(ApplicationIdentity applicationIdentity, String[] activationData)
public ActivationContext get_ActivationContext()
public String[] get_ActivationData()
public ApplicationIdentity get_ApplicationIdentity()
}
public System.Runtime.Hosting.ApplicationActivator : object {
public ObjectHandle CreateInstance(ActivationContext activationContext)
public ObjectHandle CreateInstance(ActivationContext activationContext, String[] activationCustomData)
protected ObjectHandle CreateInstanceHelper(AppDomainSetup adSetup)
}
public System.Runtime.InteropServices._Activator {
public void GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId)
public void GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo)
public void GetTypeInfoCount(UInt32& pcTInfo)
public void Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr)
}
public System.Runtime.InteropServices._Assembly {
public string CodeBase
public string EscapedCodeBase
public string FullName
public MethodInfo EntryPoint
public string Location
public Evidence Evidence
public bool GlobalAssemblyCache
public string ToString()
public bool Equals(object other)
public int GetHashCode()
public Type GetType()
public string get_CodeBase()
public string get_EscapedCodeBase()
public AssemblyName GetName()
public AssemblyName GetName(bool copiedName)
public string get_FullName()
public MethodInfo get_EntryPoint()
public Type GetType(string name)
public Type GetType(string name, bool throwOnError)
public Type[] GetExportedTypes()
public Type[] GetTypes()
public Stream GetManifestResourceStream(Type type, string name)
public Stream GetManifestResourceStream(string name)
public FileStream GetFile(string name)
public FileStream[] GetFiles()
public FileStream[] GetFiles(bool getResourceModules)
public String[] GetManifestResourceNames()
public ManifestResourceInfo GetManifestResourceInfo(string resourceName)
public string get_Location()
public Evidence get_Evidence()
public Object[] GetCustomAttributes(Type attributeType, bool inherit)
public Object[] GetCustomAttributes(bool inherit)
public bool IsDefined(Type attributeType, bool inherit)
public void GetObjectData(SerializationInfo info, StreamingContext context)
public Type GetType(string name, bool throwOnError, bool ignoreCase)
public Assembly GetSatelliteAssembly(CultureInfo culture)
public Assembly GetSatelliteAssembly(CultureInfo culture, Version version)
public Module LoadModule(string moduleName, Byte[] rawModule)
public Module LoadModule(string moduleName, Byte[] rawModule, Byte[] rawSymbolStore)
public object CreateInstance(string typeName)
public object CreateInstance(string typeName, bool ignoreCase)
public object CreateInstance(string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes)
public Module[] GetLoadedModules()
public Module[] GetLoadedModules(bool getResourceModules)
public Module[] GetModules()
public Module[] GetModules(bool getResourceModules)
public Module GetModule(string name)
public AssemblyName[] GetReferencedAssemblies()
public bool get_GlobalAssemblyCache()
public void add_ModuleResolve(ModuleResolveEventHandler value)
public void remove_ModuleResolve(ModuleResolveEventHandler value)
}
public System.Runtime.InteropServices._AssemblyBuilder {
public void GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId)
public void GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo)
public void GetTypeInfoCount(UInt32& pcTInfo)
public void Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr)
}
public System.Runtime.InteropServices._AssemblyName {
public void GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId)
public void GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo)
public void GetTypeInfoCount(UInt32& pcTInfo)
public void Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr)
}
public System.Runtime.InteropServices._Attribute {
public void GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId)
public void GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo)
public void GetTypeInfoCount(UInt32& pcTInfo)
public void Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr)
}
public System.Runtime.InteropServices._ConstructorBuilder {
public void GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId)
public void GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo)
public void GetTypeInfoCount(UInt32& pcTInfo)
public void Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr)
}
public System.Runtime.InteropServices._ConstructorInfo {
public MethodAttributes Attributes
public CallingConventions CallingConvention
public Type DeclaringType
public bool IsAbstract
public bool IsAssembly
public bool IsConstructor
public bool IsFamily
public bool IsFamilyAndAssembly
public bool IsFamilyOrAssembly
public bool IsFinal
public bool IsHideBySig
public bool IsPrivate
public bool IsPublic
public bool IsSpecialName
public bool IsStatic
public bool IsVirtual
public MemberTypes MemberType
public RuntimeMethodHandle MethodHandle
public string Name
public Type ReflectedType
public bool Equals(object other)
public Object[] GetCustomAttributes(bool inherit)
public Object[] GetCustomAttributes(Type attributeType, bool inherit)
public int GetHashCode()
public MethodImplAttributes GetMethodImplementationFlags()
public ParameterInfo[] GetParameters()
public void GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId)
public void GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo)
public void GetTypeInfoCount(UInt32& pcTInfo)
public void Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr)
public Type GetType()
public object Invoke_5(Object[] parameters)
public object Invoke_3(object obj, Object[] parameters)
public object Invoke_4(BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture)
public object Invoke_2(object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture)
public bool IsDefined(Type attributeType, bool inherit)
public string ToString()
public MethodAttributes get_Attributes()
public CallingConventions get_CallingConvention()
public Type get_DeclaringType()
public bool get_IsAbstract()
public bool get_IsAssembly()
public bool get_IsConstructor()
public bool get_IsFamily()
public bool get_IsFamilyAndAssembly()
public bool get_IsFamilyOrAssembly()
public bool get_IsFinal()
public bool get_IsHideBySig()
public bool get_IsPrivate()
public bool get_IsPublic()
public bool get_IsSpecialName()
public bool get_IsStatic()
public bool get_IsVirtual()
public MemberTypes get_MemberType()
public RuntimeMethodHandle get_MethodHandle()
public string get_Name()
public Type get_ReflectedType()
}
public System.Runtime.InteropServices._CustomAttributeBuilder {
public void GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId)
public void GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo)
public void GetTypeInfoCount(UInt32& pcTInfo)
public void Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr)
}
public System.Runtime.InteropServices._EnumBuilder {
public void GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId)
public void GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo)
public void GetTypeInfoCount(UInt32& pcTInfo)
public void Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr)
}
public System.Runtime.InteropServices._EventBuilder {
public void GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId)
public void GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo)
public void GetTypeInfoCount(UInt32& pcTInfo)
public void Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr)
}
public System.Runtime.InteropServices._EventInfo {
public EventAttributes Attributes
public Type DeclaringType
public Type EventHandlerType
public bool IsMulticast
public bool IsSpecialName
public MemberTypes MemberType
public string Name
public Type ReflectedType
public void AddEventHandler(object target, Delegate handler)
public bool Equals(object other)
public MethodInfo GetAddMethod()
public MethodInfo GetAddMethod(bool nonPublic)
public Object[] GetCustomAttributes(bool inherit)
public Object[] GetCustomAttributes(Type attributeType, bool inherit)
public int GetHashCode()
public void GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId)
public void GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo)
public void GetTypeInfoCount(UInt32& pcTInfo)
public void Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr)
public MethodInfo GetRaiseMethod()
public MethodInfo GetRaiseMethod(bool nonPublic)
public MethodInfo GetRemoveMethod()
public MethodInfo GetRemoveMethod(bool nonPublic)
public Type GetType()
public bool IsDefined(Type attributeType, bool inherit)
public void RemoveEventHandler(object target, Delegate handler)
public string ToString()
public EventAttributes get_Attributes()
public Type get_DeclaringType()
public Type get_EventHandlerType()
public bool get_IsMulticast()
public bool get_IsSpecialName()
public MemberTypes get_MemberType()
public string get_Name()
public Type get_ReflectedType()
}
public System.Runtime.InteropServices._Exception {
public string HelpLink
public Exception InnerException
public string Message
public string Source
public string StackTrace
public MethodBase TargetSite
public string get_HelpLink()
public void set_HelpLink(string value)
public Exception get_InnerException()
public string get_Message()
public string get_Source()
public void set_Source(string value)
public string get_StackTrace()
public MethodBase get_TargetSite()
public bool Equals(object obj)
public Exception GetBaseException()
public int GetHashCode()
public void GetObjectData(SerializationInfo info, StreamingContext context)
public Type GetType()
public string ToString()
}
public System.Runtime.InteropServices._FieldBuilder {
public void GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId)
public void GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo)
public void GetTypeInfoCount(UInt32& pcTInfo)
public void Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr)
}
public System.Runtime.InteropServices._FieldInfo {
public FieldAttributes Attributes
public Type DeclaringType
public RuntimeFieldHandle FieldHandle
public Type FieldType
public bool IsAssembly
public bool IsFamily
public bool IsFamilyAndAssembly
public bool IsFamilyOrAssembly
public bool IsInitOnly
public bool IsLiteral
public bool IsNotSerialized
public bool IsPinvokeImpl
public bool IsPrivate
public bool IsPublic
public bool IsSpecialName
public bool IsStatic
public MemberTypes MemberType
public string Name
public Type ReflectedType
public bool Equals(object other)
public Object[] GetCustomAttributes(bool inherit)
public Object[] GetCustomAttributes(Type attributeType, bool inherit)
public int GetHashCode()
public Type GetType()
public void GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId)
public void GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo)
public void GetTypeInfoCount(UInt32& pcTInfo)
public void Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr)
public object GetValue(object obj)
public object GetValueDirect(TypedReference obj)
public bool IsDefined(Type attributeType, bool inherit)
public void SetValue(object obj, object value)
public void SetValue(object obj, object value, BindingFlags invokeAttr, Binder binder, CultureInfo culture)
public void SetValueDirect(TypedReference obj, object value)
public string ToString()
public FieldAttributes get_Attributes()
public Type get_DeclaringType()
public RuntimeFieldHandle get_FieldHandle()
public Type get_FieldType()
public bool get_IsAssembly()
public bool get_IsFamily()
public bool get_IsFamilyAndAssembly()
public bool get_IsFamilyOrAssembly()
public bool get_IsInitOnly()
public bool get_IsLiteral()
public bool get_IsNotSerialized()
public bool get_IsPinvokeImpl()
public bool get_IsPrivate()
public bool get_IsPublic()
public bool get_IsSpecialName()
public bool get_IsStatic()
public MemberTypes get_MemberType()
public string get_Name()
public Type get_ReflectedType()
}
public System.Runtime.InteropServices._ILGenerator {
public void GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId)
public void GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo)
public void GetTypeInfoCount(UInt32& pcTInfo)
public void Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr)
}
public System.Runtime.InteropServices._LocalBuilder {
public void GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId)
public void GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo)
public void GetTypeInfoCount(UInt32& pcTInfo)
public void Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr)
}
public System.Runtime.InteropServices._MemberInfo {
public Type DeclaringType
public MemberTypes MemberType
public string Name
public Type ReflectedType
public bool Equals(object other)
public Object[] GetCustomAttributes(bool inherit)
public Object[] GetCustomAttributes(Type attributeType, bool inherit)
public int GetHashCode()
public Type GetType()
public bool IsDefined(Type attributeType, bool inherit)
public string ToString()
public Type get_DeclaringType()
public MemberTypes get_MemberType()
public string get_Name()
public Type get_ReflectedType()
public void GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId)
public void GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo)
public void GetTypeInfoCount(UInt32& pcTInfo)
public void Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr)
}
public System.Runtime.InteropServices._MethodBase {
public MethodAttributes Attributes
public CallingConventions CallingConvention
public Type DeclaringType
public bool IsAbstract
public bool IsAssembly
public bool IsConstructor
public bool IsFamily
public bool IsFamilyAndAssembly
public bool IsFamilyOrAssembly
public bool IsFinal
public bool IsHideBySig
public bool IsPrivate
public bool IsPublic
public bool IsSpecialName
public bool IsStatic
public bool IsVirtual
public MemberTypes MemberType
public RuntimeMethodHandle MethodHandle
public string Name
public Type ReflectedType
public bool Equals(object other)
public Object[] GetCustomAttributes(bool inherit)
public Object[] GetCustomAttributes(Type attributeType, bool inherit)
public int GetHashCode()
public MethodImplAttributes GetMethodImplementationFlags()
public ParameterInfo[] GetParameters()
public void GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId)
public void GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo)
public void GetTypeInfoCount(UInt32& pcTInfo)
public void Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr)
public Type GetType()
public object Invoke(object obj, Object[] parameters)
public object Invoke(object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture)
public bool IsDefined(Type attributeType, bool inherit)
public string ToString()
public MethodAttributes get_Attributes()
public CallingConventions get_CallingConvention()
public Type get_DeclaringType()
public bool get_IsAbstract()
public bool get_IsAssembly()
public bool get_IsConstructor()
public bool get_IsFamily()
public bool get_IsFamilyAndAssembly()
public bool get_IsFamilyOrAssembly()
public bool get_IsFinal()
public bool get_IsHideBySig()
public bool get_IsPrivate()
public bool get_IsPublic()
public bool get_IsSpecialName()
public bool get_IsStatic()
public bool get_IsVirtual()
public MemberTypes get_MemberType()
public RuntimeMethodHandle get_MethodHandle()
public string get_Name()
public Type get_ReflectedType()
}
public System.Runtime.InteropServices._MethodBuilder {
public void GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId)
public void GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo)
public void GetTypeInfoCount(UInt32& pcTInfo)
public void Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr)
}
public System.Runtime.InteropServices._MethodInfo {
public MethodAttributes Attributes
public CallingConventions CallingConvention
public Type DeclaringType
public bool IsAbstract
public bool IsAssembly
public bool IsConstructor
public bool IsFamily
public bool IsFamilyAndAssembly
public bool IsFamilyOrAssembly
public bool IsFinal
public bool IsHideBySig
public bool IsPrivate
public bool IsPublic
public bool IsSpecialName
public bool IsStatic
public bool IsVirtual
public MemberTypes MemberType
public RuntimeMethodHandle MethodHandle
public string Name
public Type ReflectedType
public Type ReturnType
public ICustomAttributeProvider ReturnTypeCustomAttributes
public bool Equals(object other)
public MethodInfo GetBaseDefinition()
public Object[] GetCustomAttributes(bool inherit)
public Object[] GetCustomAttributes(Type attributeType, bool inherit)
public int GetHashCode()
public MethodImplAttributes GetMethodImplementationFlags()
public ParameterInfo[] GetParameters()
public void GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId)
public void GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo)
public void GetTypeInfoCount(UInt32& pcTInfo)
public void Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr)
public Type GetType()
public object Invoke(object obj, Object[] parameters)
public object Invoke(object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture)
public bool IsDefined(Type attributeType, bool inherit)
public string ToString()
public MethodAttributes get_Attributes()
public CallingConventions get_CallingConvention()
public Type get_DeclaringType()
public bool get_IsAbstract()
public bool get_IsAssembly()
public bool get_IsConstructor()
public bool get_IsFamily()
public bool get_IsFamilyAndAssembly()
public bool get_IsFamilyOrAssembly()
public bool get_IsFinal()
public bool get_IsHideBySig()
public bool get_IsPrivate()
public bool get_IsPublic()
public bool get_IsSpecialName()
public bool get_IsStatic()
public bool get_IsVirtual()
public MemberTypes get_MemberType()
public RuntimeMethodHandle get_MethodHandle()
public string get_Name()
public Type get_ReflectedType()
public Type get_ReturnType()
public ICustomAttributeProvider get_ReturnTypeCustomAttributes()
}
public System.Runtime.InteropServices._MethodRental {
public void GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId)
public void GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo)
public void GetTypeInfoCount(UInt32& pcTInfo)
public void Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr)
}
public System.Runtime.InteropServices._Module {
public void GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId)
public void GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo)
public void GetTypeInfoCount(UInt32& pcTInfo)
public void Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr)
}
public System.Runtime.InteropServices._ModuleBuilder {
public void GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId)
public void GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo)
public void GetTypeInfoCount(UInt32& pcTInfo)
public void Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr)
}
public System.Runtime.InteropServices._ParameterBuilder {
public void GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId)
public void GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo)
public void GetTypeInfoCount(UInt32& pcTInfo)
public void Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr)
}
public System.Runtime.InteropServices._ParameterInfo {
public void GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId)
public void GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo)
public void GetTypeInfoCount(UInt32& pcTInfo)
public void Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr)
}
public System.Runtime.InteropServices._PropertyBuilder {
public void GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId)
public void GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo)
public void GetTypeInfoCount(UInt32& pcTInfo)
public void Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr)
}
public System.Runtime.InteropServices._PropertyInfo {
public PropertyAttributes Attributes
public bool CanRead
public bool CanWrite
public Type DeclaringType
public bool IsSpecialName
public MemberTypes MemberType
public string Name
public Type PropertyType
public Type ReflectedType
public bool Equals(object other)
public MethodInfo[] GetAccessors()
public MethodInfo[] GetAccessors(bool nonPublic)
public Object[] GetCustomAttributes(bool inherit)
public Object[] GetCustomAttributes(Type attributeType, bool inherit)
public MethodInfo GetGetMethod()
public MethodInfo GetGetMethod(bool nonPublic)
public int GetHashCode()
public ParameterInfo[] GetIndexParameters()
public MethodInfo GetSetMethod()
public MethodInfo GetSetMethod(bool nonPublic)
public void GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId)
public void GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo)
public void GetTypeInfoCount(UInt32& pcTInfo)
public void Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr)
public Type GetType()
public object GetValue(object obj, Object[] index)
public object GetValue(object obj, BindingFlags invokeAttr, Binder binder, Object[] index, CultureInfo culture)
public bool IsDefined(Type attributeType, bool inherit)
public void SetValue(object obj, object value, Object[] index)
public void SetValue(object obj, object value, BindingFlags invokeAttr, Binder binder, Object[] index, CultureInfo culture)
public string ToString()
public PropertyAttributes get_Attributes()
public bool get_CanRead()
public bool get_CanWrite()
public Type get_DeclaringType()
public bool get_IsSpecialName()
public MemberTypes get_MemberType()
public string get_Name()
public Type get_PropertyType()
public Type get_ReflectedType()
}
public System.Runtime.InteropServices._SignatureHelper {
public void GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId)
public void GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo)
public void GetTypeInfoCount(UInt32& pcTInfo)
public void Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr)
}
public System.Runtime.InteropServices._Thread {
public void GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId)
public void GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo)
public void GetTypeInfoCount(UInt32& pcTInfo)
public void Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr)
}
public System.Runtime.InteropServices._Type {
public Assembly Assembly
public string AssemblyQualifiedName
public TypeAttributes Attributes
public Type BaseType
public Type DeclaringType
public string FullName
public Guid GUID
public bool HasElementType
public bool IsAbstract
public bool IsAnsiClass
public bool IsArray
public bool IsAutoClass
public bool IsAutoLayout
public bool IsByRef
public bool IsClass
public bool IsCOMObject
public bool IsContextful
public bool IsEnum
public bool IsExplicitLayout
public bool IsImport
public bool IsInterface
public bool IsLayoutSequential
public bool IsMarshalByRef
public bool IsNestedAssembly
public bool IsNestedFamANDAssem
public bool IsNestedFamily
public bool IsNestedFamORAssem
public bool IsNestedPrivate
public bool IsNestedPublic
public bool IsNotPublic
public bool IsPointer
public bool IsPrimitive
public bool IsPublic
public bool IsSealed
public bool IsSerializable
public bool IsSpecialName
public bool IsUnicodeClass
public bool IsValueType
public MemberTypes MemberType
public Module Module
public string Name
public string Namespace
public Type ReflectedType
public RuntimeTypeHandle TypeHandle
public ConstructorInfo TypeInitializer
public Type UnderlyingSystemType
public bool Equals(object other)
public bool Equals(Type o)
public Type[] FindInterfaces(TypeFilter filter, object filterCriteria)
public MemberInfo[] FindMembers(MemberTypes memberType, BindingFlags bindingAttr, MemberFilter filter, object filterCriteria)
public int GetArrayRank()
public ConstructorInfo GetConstructor(Type[] types)
public ConstructorInfo GetConstructor(BindingFlags bindingAttr, Binder binder, Type[] types, ParameterModifier[] modifiers)
public ConstructorInfo GetConstructor(BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers)
public ConstructorInfo[] GetConstructors()
public ConstructorInfo[] GetConstructors(BindingFlags bindingAttr)
public Object[] GetCustomAttributes(bool inherit)
public Object[] GetCustomAttributes(Type attributeType, bool inherit)
public MemberInfo[] GetDefaultMembers()
public Type GetElementType()
public EventInfo GetEvent(string name)
public EventInfo GetEvent(string name, BindingFlags bindingAttr)
public EventInfo[] GetEvents()
public EventInfo[] GetEvents(BindingFlags bindingAttr)
public FieldInfo GetField(string name)
public FieldInfo GetField(string name, BindingFlags bindingAttr)
public FieldInfo[] GetFields()
public FieldInfo[] GetFields(BindingFlags bindingAttr)
public int GetHashCode()
public void GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId)
public void GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo)
public void GetTypeInfoCount(UInt32& pcTInfo)
public void Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr)
public Type GetInterface(string name)
public Type GetInterface(string name, bool ignoreCase)
public InterfaceMapping GetInterfaceMap(Type interfaceType)
public Type[] GetInterfaces()
public MemberInfo[] GetMember(string name)
public MemberInfo[] GetMember(string name, MemberTypes type, BindingFlags bindingAttr)
public MemberInfo[] GetMember(string name, BindingFlags bindingAttr)
public MemberInfo[] GetMembers()
public MemberInfo[] GetMembers(BindingFlags bindingAttr)
public MethodInfo GetMethod(string name)
public MethodInfo GetMethod(string name, BindingFlags bindingAttr)
public MethodInfo GetMethod(string name, Type[] types)
public MethodInfo GetMethod(string name, Type[] types, ParameterModifier[] modifiers)
public MethodInfo GetMethod(string name, BindingFlags bindingAttr, Binder binder, Type[] types, ParameterModifier[] modifiers)
public MethodInfo GetMethod(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers)
public MethodInfo[] GetMethods()
public MethodInfo[] GetMethods(BindingFlags bindingAttr)
public Type GetNestedType(string name)
public Type GetNestedType(string name, BindingFlags bindingAttr)
public Type[] GetNestedTypes()
public Type[] GetNestedTypes(BindingFlags bindingAttr)
public PropertyInfo[] GetProperties()
public PropertyInfo[] GetProperties(BindingFlags bindingAttr)
public PropertyInfo GetProperty(string name)
public PropertyInfo GetProperty(string name, BindingFlags bindingAttr)
public PropertyInfo GetProperty(string name, Type returnType)
public PropertyInfo GetProperty(string name, Type[] types)
public PropertyInfo GetProperty(string name, Type returnType, Type[] types)
public PropertyInfo GetProperty(string name, Type returnType, Type[] types, ParameterModifier[] modifiers)
public PropertyInfo GetProperty(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers)
public Type GetType()
public object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, Object[] args)
public object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, Object[] args, CultureInfo culture)
public object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, Object[] args, ParameterModifier[] modifiers, CultureInfo culture, String[] namedParameters)
public bool IsAssignableFrom(Type c)
public bool IsDefined(Type attributeType, bool inherit)
public bool IsInstanceOfType(object o)
public bool IsSubclassOf(Type c)
public string ToString()
public Assembly get_Assembly()
public string get_AssemblyQualifiedName()
public TypeAttributes get_Attributes()
public Type get_BaseType()
public Type get_DeclaringType()
public string get_FullName()
public Guid get_GUID()
public bool get_HasElementType()
public bool get_IsAbstract()
public bool get_IsAnsiClass()
public bool get_IsArray()
public bool get_IsAutoClass()
public bool get_IsAutoLayout()
public bool get_IsByRef()
public bool get_IsClass()
public bool get_IsCOMObject()
public bool get_IsContextful()
public bool get_IsEnum()
public bool get_IsExplicitLayout()
public bool get_IsImport()
public bool get_IsInterface()
public bool get_IsLayoutSequential()
public bool get_IsMarshalByRef()
public bool get_IsNestedAssembly()
public bool get_IsNestedFamANDAssem()
public bool get_IsNestedFamily()
public bool get_IsNestedFamORAssem()
public bool get_IsNestedPrivate()
public bool get_IsNestedPublic()
public bool get_IsNotPublic()
public bool get_IsPointer()
public bool get_IsPrimitive()
public bool get_IsPublic()
public bool get_IsSealed()
public bool get_IsSerializable()
public bool get_IsSpecialName()
public bool get_IsUnicodeClass()
public bool get_IsValueType()
public MemberTypes get_MemberType()
public Module get_Module()
public string get_Name()
public string get_Namespace()
public Type get_ReflectedType()
public RuntimeTypeHandle get_TypeHandle()
public ConstructorInfo get_TypeInitializer()
public Type get_UnderlyingSystemType()
}
public System.Runtime.InteropServices._TypeBuilder {
public void GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId)
public void GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo)
public void GetTypeInfoCount(UInt32& pcTInfo)
public void Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr)
}
internal System.Runtime.InteropServices.AddrofIntrinsics : object {
internal IntPtr AddrOf(T ftn)
}
public System.Runtime.InteropServices.Architecture : Enum {
public int value__
public Architecture X86
public Architecture X64
public Architecture Arm
public Architecture Arm64
}
public System.Runtime.InteropServices.ArrayWithOffset : ValueType {
private object m_array
private int m_offset
private int m_count
public void .ctor(object array, int offset)
public object GetArray()
public int GetOffset()
public int GetHashCode()
public bool Equals(object obj)
public bool Equals(ArrayWithOffset obj)
public bool op_Equality(ArrayWithOffset a, ArrayWithOffset b)
public bool op_Inequality(ArrayWithOffset a, ArrayWithOffset b)
private int CalculateCount()
}
public System.Runtime.InteropServices.AssemblyRegistrationFlags : Enum {
public int value__
public AssemblyRegistrationFlags None
public AssemblyRegistrationFlags SetCodeBase
}
public System.Runtime.InteropServices.AutomationProxyAttribute : Attribute {
internal bool _val
public bool Value
public void .ctor(bool val)
public bool get_Value()
}
public System.Runtime.InteropServices.BestFitMappingAttribute : Attribute {
internal bool _bestFitMapping
public bool ThrowOnUnmappableChar
public bool BestFitMapping
public void .ctor(bool BestFitMapping)
public bool get_BestFitMapping()
}
public System.Runtime.InteropServices.BIND_OPTS : ValueType {
public int cbStruct
public int grfFlags
public int grfMode
public int dwTickCountDeadline
}
public System.Runtime.InteropServices.BINDPTR : ValueType {
public IntPtr lpfuncdesc
public IntPtr lptcomp
public IntPtr lpvardesc
}
public System.Runtime.InteropServices.BStrWrapper : object {
private string m_WrappedObject
public string WrappedObject
public void .ctor(string value)
public void .ctor(object value)
public string get_WrappedObject()
}
public System.Runtime.InteropServices.CALLCONV : Enum {
public int value__
public CALLCONV CC_CDECL
public CALLCONV CC_MSCPASCAL
public CALLCONV CC_PASCAL
public CALLCONV CC_MACPASCAL
public CALLCONV CC_STDCALL
public CALLCONV CC_RESERVED
public CALLCONV CC_SYSCALL
public CALLCONV CC_MPWCDECL
public CALLCONV CC_MPWPASCAL
public CALLCONV CC_MAX
}
public System.Runtime.InteropServices.CallingConvention : Enum {
public int value__
public CallingConvention Winapi
public CallingConvention Cdecl
public CallingConvention StdCall
public CallingConvention ThisCall
public CallingConvention FastCall
}
public System.Runtime.InteropServices.CharSet : Enum {
public int value__
public CharSet None
public CharSet Ansi
public CharSet Unicode
public CharSet Auto
}
public System.Runtime.InteropServices.ClassInterfaceAttribute : Attribute {
internal ClassInterfaceType _val
public ClassInterfaceType Value
public void .ctor(ClassInterfaceType classInterfaceType)
public void .ctor(short classInterfaceType)
public ClassInterfaceType get_Value()
}
public System.Runtime.InteropServices.ClassInterfaceType : Enum {
public int value__
public ClassInterfaceType None
public ClassInterfaceType AutoDispatch
public ClassInterfaceType AutoDual
}
public System.Runtime.InteropServices.CoClassAttribute : Attribute {
internal Type _CoClass
public Type CoClass
public void .ctor(Type coClass)
public Type get_CoClass()
}
public System.Runtime.InteropServices.ComAliasNameAttribute : Attribute {
internal string _val
public string Value
public void .ctor(string alias)
public string get_Value()
}
public System.Runtime.InteropServices.ComCompatibleVersionAttribute : Attribute {
internal int _major
internal int _minor
internal int _build
internal int _revision
public int MajorVersion
public int MinorVersion
public int BuildNumber
public int RevisionNumber
public void .ctor(int major, int minor, int build, int revision)
public int get_MajorVersion()
public int get_MinorVersion()
public int get_BuildNumber()
public int get_RevisionNumber()
}
public System.Runtime.InteropServices.ComDefaultInterfaceAttribute : Attribute {
internal Type _val
public Type Value
public void .ctor(Type defaultInterface)
public Type get_Value()
}
public System.Runtime.InteropServices.ComEventInterfaceAttribute : Attribute {
internal Type _SourceInterface
internal Type _EventProvider
public Type SourceInterface
public Type EventProvider
public void .ctor(Type SourceInterface, Type EventProvider)
public Type get_SourceInterface()
public Type get_EventProvider()
}
public System.Runtime.InteropServices.ComEventsHelper : object {
public void Combine(object rcw, Guid iid, int dispid, Delegate d)
public Delegate Remove(object rcw, Guid iid, int dispid, Delegate d)
}
public System.Runtime.InteropServices.COMException : ExternalException {
public void .ctor(string message)
public void .ctor(string message, Exception inner)
public void .ctor(string message, int errorCode)
internal void .ctor(int hresult)
internal void .ctor(string message, int hresult, Exception inner)
protected void .ctor(SerializationInfo info, StreamingContext context)
public string ToString()
}
public System.Runtime.InteropServices.ComImportAttribute : Attribute {
internal Attribute GetCustomAttribute(RuntimeType type)
internal bool IsDefined(RuntimeType type)
}
public System.Runtime.InteropServices.ComInterfaceType : Enum {
public int value__
public ComInterfaceType InterfaceIsDual
public ComInterfaceType InterfaceIsIUnknown
public ComInterfaceType InterfaceIsIDispatch
public ComInterfaceType InterfaceIsIInspectable
}
public System.Runtime.InteropServices.ComMemberType : Enum {
public int value__
public ComMemberType Method
public ComMemberType PropGet
public ComMemberType PropSet
}
public System.Runtime.InteropServices.ComSourceInterfacesAttribute : Attribute {
internal string _val
public string Value
public void .ctor(string sourceInterfaces)
public void .ctor(Type sourceInterface)
public void .ctor(Type sourceInterface1, Type sourceInterface2)
public void .ctor(Type sourceInterface1, Type sourceInterface2, Type sourceInterface3)
public void .ctor(Type sourceInterface1, Type sourceInterface2, Type sourceInterface3, Type sourceInterface4)
public string get_Value()
}
public System.Runtime.InteropServices.ComTypes.BIND_OPTS : ValueType {
public int cbStruct
public int grfFlags
public int grfMode
public int dwTickCountDeadline
}
public System.Runtime.InteropServices.ComTypes.BINDPTR : ValueType {
public IntPtr lpfuncdesc
public IntPtr lpvardesc
public IntPtr lptcomp
}
public System.Runtime.InteropServices.ComTypes.CALLCONV : Enum {
public int value__
public CALLCONV CC_CDECL
public CALLCONV CC_MSCPASCAL
public CALLCONV CC_PASCAL
public CALLCONV CC_MACPASCAL
public CALLCONV CC_STDCALL
public CALLCONV CC_RESERVED
public CALLCONV CC_SYSCALL
public CALLCONV CC_MPWCDECL
public CALLCONV CC_MPWPASCAL
public CALLCONV CC_MAX
}
public System.Runtime.InteropServices.ComTypes.CONNECTDATA : ValueType {
public object pUnk
public int dwCookie
}
public System.Runtime.InteropServices.ComTypes.DESCKIND : Enum {
public int value__
public DESCKIND DESCKIND_NONE
public DESCKIND DESCKIND_FUNCDESC
public DESCKIND DESCKIND_VARDESC
public DESCKIND DESCKIND_TYPECOMP
public DESCKIND DESCKIND_IMPLICITAPPOBJ
public DESCKIND DESCKIND_MAX
}
public System.Runtime.InteropServices.ComTypes.DISPPARAMS : ValueType {
public IntPtr rgvarg
public IntPtr rgdispidNamedArgs
public int cArgs
public int cNamedArgs
}
public System.Runtime.InteropServices.ComTypes.ELEMDESC : ValueType {
public TYPEDESC tdesc
public DESCUNION desc
}
public System.Runtime.InteropServices.ComTypes.EXCEPINFO : ValueType {
public short wCode
public short wReserved
public string bstrSource
public string bstrDescription
public string bstrHelpFile
public int dwHelpContext
public IntPtr pvReserved
public IntPtr pfnDeferredFillIn
public int scode
}
public System.Runtime.InteropServices.ComTypes.FILETIME : ValueType {
public int dwLowDateTime
public int dwHighDateTime
}
public System.Runtime.InteropServices.ComTypes.FUNCDESC : ValueType {
public int memid
public IntPtr lprgscode
public IntPtr lprgelemdescParam
public FUNCKIND funckind
public INVOKEKIND invkind
public CALLCONV callconv
public short cParams
public short cParamsOpt
public short oVft
public short cScodes
public ELEMDESC elemdescFunc
public short wFuncFlags
}
public System.Runtime.InteropServices.ComTypes.FUNCFLAGS : Enum {
public short value__
public FUNCFLAGS FUNCFLAG_FRESTRICTED
public FUNCFLAGS FUNCFLAG_FSOURCE
public FUNCFLAGS FUNCFLAG_FBINDABLE
public FUNCFLAGS FUNCFLAG_FREQUESTEDIT
public FUNCFLAGS FUNCFLAG_FDISPLAYBIND
public FUNCFLAGS FUNCFLAG_FDEFAULTBIND
public FUNCFLAGS FUNCFLAG_FHIDDEN
public FUNCFLAGS FUNCFLAG_FUSESGETLASTERROR
public FUNCFLAGS FUNCFLAG_FDEFAULTCOLLELEM
public FUNCFLAGS FUNCFLAG_FUIDEFAULT
public FUNCFLAGS FUNCFLAG_FNONBROWSABLE
public FUNCFLAGS FUNCFLAG_FREPLACEABLE
public FUNCFLAGS FUNCFLAG_FIMMEDIATEBIND
}
public System.Runtime.InteropServices.ComTypes.FUNCKIND : Enum {
public int value__
public FUNCKIND FUNC_VIRTUAL
public FUNCKIND FUNC_PUREVIRTUAL
public FUNCKIND FUNC_NONVIRTUAL
public FUNCKIND FUNC_STATIC
public FUNCKIND FUNC_DISPATCH
}
public System.Runtime.InteropServices.ComTypes.IBindCtx {
public void RegisterObjectBound(object punk)
public void RevokeObjectBound(object punk)
public void ReleaseBoundObjects()
public void SetBindOptions(BIND_OPTS& pbindopts)
public void GetBindOptions(BIND_OPTS& pbindopts)
public void GetRunningObjectTable(IRunningObjectTable& pprot)
public void RegisterObjectParam(string pszKey, object punk)
public void GetObjectParam(string pszKey, Object& ppunk)
public void EnumObjectParam(IEnumString& ppenum)
public int RevokeObjectParam(string pszKey)
}
public System.Runtime.InteropServices.ComTypes.IConnectionPoint {
public void GetConnectionInterface(Guid& pIID)
public void GetConnectionPointContainer(IConnectionPointContainer& ppCPC)
public void Advise(object pUnkSink, Int32& pdwCookie)
public void Unadvise(int dwCookie)
public void EnumConnections(IEnumConnections& ppEnum)
}
public System.Runtime.InteropServices.ComTypes.IConnectionPointContainer {
public void EnumConnectionPoints(IEnumConnectionPoints& ppEnum)
public void FindConnectionPoint(Guid& riid, IConnectionPoint& ppCP)
}
public System.Runtime.InteropServices.ComTypes.IDLDESC : ValueType {
public IntPtr dwReserved
public IDLFLAG wIDLFlags
}
public System.Runtime.InteropServices.ComTypes.IDLFLAG : Enum {
public short value__
public IDLFLAG IDLFLAG_NONE
public IDLFLAG IDLFLAG_FIN
public IDLFLAG IDLFLAG_FOUT
public IDLFLAG IDLFLAG_FLCID
public IDLFLAG IDLFLAG_FRETVAL
}
public System.Runtime.InteropServices.ComTypes.IEnumConnectionPoints {
public int Next(int celt, IConnectionPoint[] rgelt, IntPtr pceltFetched)
public int Skip(int celt)
public void Reset()
public void Clone(IEnumConnectionPoints& ppenum)
}
public System.Runtime.InteropServices.ComTypes.IEnumConnections {
public int Next(int celt, CONNECTDATA[] rgelt, IntPtr pceltFetched)
public int Skip(int celt)
public void Reset()
public void Clone(IEnumConnections& ppenum)
}
internal System.Runtime.InteropServices.ComTypes.IEnumerable {
public IEnumerator GetEnumerator()
}
internal System.Runtime.InteropServices.ComTypes.IEnumerator {
public object Current
public bool MoveNext()
public object get_Current()
public void Reset()
}
public System.Runtime.InteropServices.ComTypes.IEnumMoniker {
public int Next(int celt, IMoniker[] rgelt, IntPtr pceltFetched)
public int Skip(int celt)
public void Reset()
public void Clone(IEnumMoniker& ppenum)
}
public System.Runtime.InteropServices.ComTypes.IEnumString {
public int Next(int celt, String[] rgelt, IntPtr pceltFetched)
public int Skip(int celt)
public void Reset()
public void Clone(IEnumString& ppenum)
}
public System.Runtime.InteropServices.ComTypes.IEnumVARIANT {
public int Next(int celt, Object[] rgVar, IntPtr pceltFetched)
public int Skip(int celt)
public int Reset()
public IEnumVARIANT Clone()
}
internal System.Runtime.InteropServices.ComTypes.IExpando {
public FieldInfo AddField(string name)
public PropertyInfo AddProperty(string name)
public MethodInfo AddMethod(string name, Delegate method)
public void RemoveMember(MemberInfo m)
}
public System.Runtime.InteropServices.ComTypes.IMoniker {
public void GetClassID(Guid& pClassID)
public int IsDirty()
public void Load(IStream pStm)
public void Save(IStream pStm, bool fClearDirty)
public void GetSizeMax(Int64& pcbSize)
public void BindToObject(IBindCtx pbc, IMoniker pmkToLeft, Guid& riidResult, Object& ppvResult)
public void BindToStorage(IBindCtx pbc, IMoniker pmkToLeft, Guid& riid, Object& ppvObj)
public void Reduce(IBindCtx pbc, int dwReduceHowFar, IMoniker& ppmkToLeft, IMoniker& ppmkReduced)
public void ComposeWith(IMoniker pmkRight, bool fOnlyIfNotGeneric, IMoniker& ppmkComposite)
public void Enum(bool fForward, IEnumMoniker& ppenumMoniker)
public int IsEqual(IMoniker pmkOtherMoniker)
public void Hash(Int32& pdwHash)
public int IsRunning(IBindCtx pbc, IMoniker pmkToLeft, IMoniker pmkNewlyRunning)
public void GetTimeOfLastChange(IBindCtx pbc, IMoniker pmkToLeft, FILETIME& pFileTime)
public void Inverse(IMoniker& ppmk)
public void CommonPrefixWith(IMoniker pmkOther, IMoniker& ppmkPrefix)
public void RelativePathTo(IMoniker pmkOther, IMoniker& ppmkRelPath)
public void GetDisplayName(IBindCtx pbc, IMoniker pmkToLeft, String& ppszDisplayName)
public void ParseDisplayName(IBindCtx pbc, IMoniker pmkToLeft, string pszDisplayName, Int32& pchEaten, IMoniker& ppmkOut)
public int IsSystemMoniker(Int32& pdwMksys)
}
public System.Runtime.InteropServices.ComTypes.IMPLTYPEFLAGS : Enum {
public int value__
public IMPLTYPEFLAGS IMPLTYPEFLAG_FDEFAULT
public IMPLTYPEFLAGS IMPLTYPEFLAG_FSOURCE
public IMPLTYPEFLAGS IMPLTYPEFLAG_FRESTRICTED
public IMPLTYPEFLAGS IMPLTYPEFLAG_FDEFAULTVTABLE
}
public System.Runtime.InteropServices.ComTypes.INVOKEKIND : Enum {
public int value__
public INVOKEKIND INVOKE_FUNC
public INVOKEKIND INVOKE_PROPERTYGET
public INVOKEKIND INVOKE_PROPERTYPUT
public INVOKEKIND INVOKE_PROPERTYPUTREF
}
public System.Runtime.InteropServices.ComTypes.IPersistFile {
public void GetClassID(Guid& pClassID)
public int IsDirty()
public void Load(string pszFileName, int dwMode)
public void Save(string pszFileName, bool fRemember)
public void SaveCompleted(string pszFileName)
public void GetCurFile(String& ppszFileName)
}
internal System.Runtime.InteropServices.ComTypes.IReflect {
public Type UnderlyingSystemType
public MethodInfo GetMethod(string name, BindingFlags bindingAttr, Binder binder, Type[] types, ParameterModifier[] modifiers)
public MethodInfo GetMethod(string name, BindingFlags bindingAttr)
public MethodInfo[] GetMethods(BindingFlags bindingAttr)
public FieldInfo GetField(string name, BindingFlags bindingAttr)
public FieldInfo[] GetFields(BindingFlags bindingAttr)
public PropertyInfo GetProperty(string name, BindingFlags bindingAttr)
public PropertyInfo GetProperty(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers)
public PropertyInfo[] GetProperties(BindingFlags bindingAttr)
public MemberInfo[] GetMember(string name, BindingFlags bindingAttr)
public MemberInfo[] GetMembers(BindingFlags bindingAttr)
public object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, Object[] args, ParameterModifier[] modifiers, CultureInfo culture, String[] namedParameters)
public Type get_UnderlyingSystemType()
}
public System.Runtime.InteropServices.ComTypes.IRunningObjectTable {
public int Register(int grfFlags, object punkObject, IMoniker pmkObjectName)
public void Revoke(int dwRegister)
public int IsRunning(IMoniker pmkObjectName)
public int GetObject(IMoniker pmkObjectName, Object& ppunkObject)
public void NoteChangeTime(int dwRegister, FILETIME& pfiletime)
public int GetTimeOfLastChange(IMoniker pmkObjectName, FILETIME& pfiletime)
public void EnumRunning(IEnumMoniker& ppenumMoniker)
}
public System.Runtime.InteropServices.ComTypes.IStream {
public void Read(Byte[] pv, int cb, IntPtr pcbRead)
public void Write(Byte[] pv, int cb, IntPtr pcbWritten)
public void Seek(long dlibMove, int dwOrigin, IntPtr plibNewPosition)
public void SetSize(long libNewSize)
public void CopyTo(IStream pstm, long cb, IntPtr pcbRead, IntPtr pcbWritten)
public void Commit(int grfCommitFlags)
public void Revert()
public void LockRegion(long libOffset, long cb, int dwLockType)
public void UnlockRegion(long libOffset, long cb, int dwLockType)
public void Stat(STATSTG& pstatstg, int grfStatFlag)
public void Clone(IStream& ppstm)
}
public System.Runtime.InteropServices.ComTypes.ITypeComp {
public void Bind(string szName, int lHashVal, short wFlags, ITypeInfo& ppTInfo, DESCKIND& pDescKind, BINDPTR& pBindPtr)
public void BindType(string szName, int lHashVal, ITypeInfo& ppTInfo, ITypeComp& ppTComp)
}
public System.Runtime.InteropServices.ComTypes.ITypeInfo {
public void GetTypeAttr(IntPtr& ppTypeAttr)
public void GetTypeComp(ITypeComp& ppTComp)
public void GetFuncDesc(int index, IntPtr& ppFuncDesc)
public void GetVarDesc(int index, IntPtr& ppVarDesc)
public void GetNames(int memid, String[] rgBstrNames, int cMaxNames, Int32& pcNames)
public void GetRefTypeOfImplType(int index, Int32& href)
public void GetImplTypeFlags(int index, IMPLTYPEFLAGS& pImplTypeFlags)
public void GetIDsOfNames(String[] rgszNames, int cNames, Int32[] pMemId)
public void Invoke(object pvInstance, int memid, short wFlags, DISPPARAMS& pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, Int32& puArgErr)
public void GetDocumentation(int index, String& strName, String& strDocString, Int32& dwHelpContext, String& strHelpFile)
public void GetDllEntry(int memid, INVOKEKIND invKind, IntPtr pBstrDllName, IntPtr pBstrName, IntPtr pwOrdinal)
public void GetRefTypeInfo(int hRef, ITypeInfo& ppTI)
public void AddressOfMember(int memid, INVOKEKIND invKind, IntPtr& ppv)
public void CreateInstance(object pUnkOuter, Guid& riid, Object& ppvObj)
public void GetMops(int memid, String& pBstrMops)
public void GetContainingTypeLib(ITypeLib& ppTLB, Int32& pIndex)
public void ReleaseTypeAttr(IntPtr pTypeAttr)
public void ReleaseFuncDesc(IntPtr pFuncDesc)
public void ReleaseVarDesc(IntPtr pVarDesc)
}
public System.Runtime.InteropServices.ComTypes.ITypeInfo2 {
public void GetTypeAttr(IntPtr& ppTypeAttr)
public void GetTypeComp(ITypeComp& ppTComp)
public void GetFuncDesc(int index, IntPtr& ppFuncDesc)
public void GetVarDesc(int index, IntPtr& ppVarDesc)
public void GetNames(int memid, String[] rgBstrNames, int cMaxNames, Int32& pcNames)
public void GetRefTypeOfImplType(int index, Int32& href)
public void GetImplTypeFlags(int index, IMPLTYPEFLAGS& pImplTypeFlags)
public void GetIDsOfNames(String[] rgszNames, int cNames, Int32[] pMemId)
public void Invoke(object pvInstance, int memid, short wFlags, DISPPARAMS& pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, Int32& puArgErr)
public void GetDocumentation(int index, String& strName, String& strDocString, Int32& dwHelpContext, String& strHelpFile)
public void GetDllEntry(int memid, INVOKEKIND invKind, IntPtr pBstrDllName, IntPtr pBstrName, IntPtr pwOrdinal)
public void GetRefTypeInfo(int hRef, ITypeInfo& ppTI)
public void AddressOfMember(int memid, INVOKEKIND invKind, IntPtr& ppv)
public void CreateInstance(object pUnkOuter, Guid& riid, Object& ppvObj)
public void GetMops(int memid, String& pBstrMops)
public void GetContainingTypeLib(ITypeLib& ppTLB, Int32& pIndex)
public void ReleaseTypeAttr(IntPtr pTypeAttr)
public void ReleaseFuncDesc(IntPtr pFuncDesc)
public void ReleaseVarDesc(IntPtr pVarDesc)
public void GetTypeKind(TYPEKIND& pTypeKind)
public void GetTypeFlags(Int32& pTypeFlags)
public void GetFuncIndexOfMemId(int memid, INVOKEKIND invKind, Int32& pFuncIndex)
public void GetVarIndexOfMemId(int memid, Int32& pVarIndex)
public void GetCustData(Guid& guid, Object& pVarVal)
public void GetFuncCustData(int index, Guid& guid, Object& pVarVal)
public void GetParamCustData(int indexFunc, int indexParam, Guid& guid, Object& pVarVal)
public void GetVarCustData(int index, Guid& guid, Object& pVarVal)
public void GetImplTypeCustData(int index, Guid& guid, Object& pVarVal)
public void GetDocumentation2(int memid, String& pbstrHelpString, Int32& pdwHelpStringContext, String& pbstrHelpStringDll)
public void GetAllCustData(IntPtr pCustData)
public void GetAllFuncCustData(int index, IntPtr pCustData)
public void GetAllParamCustData(int indexFunc, int indexParam, IntPtr pCustData)
public void GetAllVarCustData(int index, IntPtr pCustData)
public void GetAllImplTypeCustData(int index, IntPtr pCustData)
}
public System.Runtime.InteropServices.ComTypes.ITypeLib {
public int GetTypeInfoCount()
public void GetTypeInfo(int index, ITypeInfo& ppTI)
public void GetTypeInfoType(int index, TYPEKIND& pTKind)
public void GetTypeInfoOfGuid(Guid& guid, ITypeInfo& ppTInfo)
public void GetLibAttr(IntPtr& ppTLibAttr)
public void GetTypeComp(ITypeComp& ppTComp)
public void GetDocumentation(int index, String& strName, String& strDocString, Int32& dwHelpContext, String& strHelpFile)
public bool IsName(string szNameBuf, int lHashVal)
public void FindName(string szNameBuf, int lHashVal, ITypeInfo[] ppTInfo, Int32[] rgMemId, Int16& pcFound)
public void ReleaseTLibAttr(IntPtr pTLibAttr)
}
public System.Runtime.InteropServices.ComTypes.ITypeLib2 {
public int GetTypeInfoCount()
public void GetTypeInfo(int index, ITypeInfo& ppTI)
public void GetTypeInfoType(int index, TYPEKIND& pTKind)
public void GetTypeInfoOfGuid(Guid& guid, ITypeInfo& ppTInfo)
public void GetLibAttr(IntPtr& ppTLibAttr)
public void GetTypeComp(ITypeComp& ppTComp)
public void GetDocumentation(int index, String& strName, String& strDocString, Int32& dwHelpContext, String& strHelpFile)
public bool IsName(string szNameBuf, int lHashVal)
public void FindName(string szNameBuf, int lHashVal, ITypeInfo[] ppTInfo, Int32[] rgMemId, Int16& pcFound)
public void ReleaseTLibAttr(IntPtr pTLibAttr)
public void GetCustData(Guid& guid, Object& pVarVal)
public void GetDocumentation2(int index, String& pbstrHelpString, Int32& pdwHelpStringContext, String& pbstrHelpStringDll)
public void GetLibStatistics(IntPtr pcUniqueNames, Int32& pcchUniqueNames)
public void GetAllCustData(IntPtr pCustData)
}
public System.Runtime.InteropServices.ComTypes.LIBFLAGS : Enum {
public short value__
public LIBFLAGS LIBFLAG_FRESTRICTED
public LIBFLAGS LIBFLAG_FCONTROL
public LIBFLAGS LIBFLAG_FHIDDEN
public LIBFLAGS LIBFLAG_FHASDISKIMAGE
}
public System.Runtime.InteropServices.ComTypes.PARAMDESC : ValueType {
public IntPtr lpVarValue
public PARAMFLAG wParamFlags
}
public System.Runtime.InteropServices.ComTypes.PARAMFLAG : Enum {
public short value__
public PARAMFLAG PARAMFLAG_NONE
public PARAMFLAG PARAMFLAG_FIN
public PARAMFLAG PARAMFLAG_FOUT
public PARAMFLAG PARAMFLAG_FLCID
public PARAMFLAG PARAMFLAG_FRETVAL
public PARAMFLAG PARAMFLAG_FOPT
public PARAMFLAG PARAMFLAG_FHASDEFAULT
public PARAMFLAG PARAMFLAG_FHASCUSTDATA
}
public System.Runtime.InteropServices.ComTypes.STATSTG : ValueType {
public string pwcsName
public int type
public long cbSize
public FILETIME mtime
public FILETIME ctime
public FILETIME atime
public int grfMode
public int grfLocksSupported
public Guid clsid
public int grfStateBits
public int reserved
}
public System.Runtime.InteropServices.ComTypes.SYSKIND : Enum {
public int value__
public SYSKIND SYS_WIN16
public SYSKIND SYS_WIN32
public SYSKIND SYS_MAC
public SYSKIND SYS_WIN64
}
public System.Runtime.InteropServices.ComTypes.TYPEATTR : ValueType {
public int MEMBER_ID_NIL
public Guid guid
public int lcid
public int dwReserved
public int memidConstructor
public int memidDestructor
public IntPtr lpstrSchema
public int cbSizeInstance
public TYPEKIND typekind
public short cFuncs
public short cVars
public short cImplTypes
public short cbSizeVft
public short cbAlignment
public TYPEFLAGS wTypeFlags
public short wMajorVerNum
public short wMinorVerNum
public TYPEDESC tdescAlias
public IDLDESC idldescType
}
public System.Runtime.InteropServices.ComTypes.TYPEDESC : ValueType {
public IntPtr lpValue
public short vt
}
public System.Runtime.InteropServices.ComTypes.TYPEFLAGS : Enum {
public short value__
public TYPEFLAGS TYPEFLAG_FAPPOBJECT
public TYPEFLAGS TYPEFLAG_FCANCREATE
public TYPEFLAGS TYPEFLAG_FLICENSED
public TYPEFLAGS TYPEFLAG_FPREDECLID
public TYPEFLAGS TYPEFLAG_FHIDDEN
public TYPEFLAGS TYPEFLAG_FCONTROL
public TYPEFLAGS TYPEFLAG_FDUAL
public TYPEFLAGS TYPEFLAG_FNONEXTENSIBLE
public TYPEFLAGS TYPEFLAG_FOLEAUTOMATION
public TYPEFLAGS TYPEFLAG_FRESTRICTED
public TYPEFLAGS TYPEFLAG_FAGGREGATABLE
public TYPEFLAGS TYPEFLAG_FREPLACEABLE
public TYPEFLAGS TYPEFLAG_FDISPATCHABLE
public TYPEFLAGS TYPEFLAG_FREVERSEBIND
public TYPEFLAGS TYPEFLAG_FPROXY
}
public System.Runtime.InteropServices.ComTypes.TYPEKIND : Enum {
public int value__
public TYPEKIND TKIND_ENUM
public TYPEKIND TKIND_RECORD
public TYPEKIND TKIND_MODULE
public TYPEKIND TKIND_INTERFACE
public TYPEKIND TKIND_DISPATCH
public TYPEKIND TKIND_COCLASS
public TYPEKIND TKIND_ALIAS
public TYPEKIND TKIND_UNION
public TYPEKIND TKIND_MAX
}
public System.Runtime.InteropServices.ComTypes.TYPELIBATTR : ValueType {
public Guid guid
public int lcid
public SYSKIND syskind
public short wMajorVerNum
public short wMinorVerNum
public LIBFLAGS wLibFlags
}
public System.Runtime.InteropServices.ComTypes.VARDESC : ValueType {
public int memid
public string lpstrSchema
public DESCUNION desc
public ELEMDESC elemdescVar
public short wVarFlags
public VARKIND varkind
}
public System.Runtime.InteropServices.ComTypes.VARFLAGS : Enum {
public short value__
public VARFLAGS VARFLAG_FREADONLY
public VARFLAGS VARFLAG_FSOURCE
public VARFLAGS VARFLAG_FBINDABLE
public VARFLAGS VARFLAG_FREQUESTEDIT
public VARFLAGS VARFLAG_FDISPLAYBIND
public VARFLAGS VARFLAG_FDEFAULTBIND
public VARFLAGS VARFLAG_FHIDDEN
public VARFLAGS VARFLAG_FRESTRICTED
public VARFLAGS VARFLAG_FDEFAULTCOLLELEM
public VARFLAGS VARFLAG_FUIDEFAULT
public VARFLAGS VARFLAG_FNONBROWSABLE
public VARFLAGS VARFLAG_FREPLACEABLE
public VARFLAGS VARFLAG_FIMMEDIATEBIND
}
public System.Runtime.InteropServices.ComTypes.VARKIND : Enum {
public int value__
public VARKIND VAR_PERINSTANCE
public VARKIND VAR_STATIC
public VARKIND VAR_CONST
public VARKIND VAR_DISPATCH
}
public System.Runtime.InteropServices.ComVisibleAttribute : Attribute {
internal bool _val
public bool Value
public void .ctor(bool visibility)
public bool get_Value()
}
public System.Runtime.InteropServices.CONNECTDATA : ValueType {
public object pUnk
public int dwCookie
}
public System.Runtime.InteropServices.CriticalHandle : CriticalFinalizerObject {
protected IntPtr handle
private bool _isClosed
public bool IsClosed
public bool IsInvalid
protected void .ctor(IntPtr invalidHandleValue)
protected void Finalize()
private void Cleanup()
private void FireCustomerDebugProbe()
protected void SetHandle(IntPtr handle)
public bool get_IsClosed()
public bool get_IsInvalid()
public void Close()
public void Dispose()
protected void Dispose(bool disposing)
public void SetHandleAsInvalid()
protected bool ReleaseHandle()
}
public System.Runtime.InteropServices.CurrencyWrapper : object {
private decimal m_WrappedObject
public decimal WrappedObject
public void .ctor(decimal obj)
public void .ctor(object obj)
public decimal get_WrappedObject()
}
public System.Runtime.InteropServices.CustomQueryInterfaceMode : Enum {
public int value__
public CustomQueryInterfaceMode Allow
public CustomQueryInterfaceMode Ignore
}
public System.Runtime.InteropServices.CustomQueryInterfaceResult : Enum {
public int value__
public CustomQueryInterfaceResult Handled
public CustomQueryInterfaceResult NotHandled
public CustomQueryInterfaceResult Failed
}
public System.Runtime.InteropServices.DefaultCharSetAttribute : Attribute {
internal CharSet _CharSet
public CharSet CharSet
public void .ctor(CharSet charSet)
public CharSet get_CharSet()
}
public System.Runtime.InteropServices.DefaultDllImportSearchPathsAttribute : Attribute {
internal DllImportSearchPath _paths
public DllImportSearchPath Paths
public void .ctor(DllImportSearchPath paths)
public DllImportSearchPath get_Paths()
}
public System.Runtime.InteropServices.DESCKIND : Enum {
public int value__
public DESCKIND DESCKIND_NONE
public DESCKIND DESCKIND_FUNCDESC
public DESCKIND DESCKIND_VARDESC
public DESCKIND DESCKIND_TYPECOMP
public DESCKIND DESCKIND_IMPLICITAPPOBJ
public DESCKIND DESCKIND_MAX
}
public System.Runtime.InteropServices.DispatchWrapper : object {
private object m_WrappedObject
public object WrappedObject
public void .ctor(object obj)
public object get_WrappedObject()
}
public System.Runtime.InteropServices.DispIdAttribute : Attribute {
internal int _val
public int Value
public void .ctor(int dispId)
public int get_Value()
}
public System.Runtime.InteropServices.DISPPARAMS : ValueType {
public IntPtr rgvarg
public IntPtr rgdispidNamedArgs
public int cArgs
public int cNamedArgs
}
public System.Runtime.InteropServices.DllImportAttribute : Attribute {
internal string _val
public string EntryPoint
public CharSet CharSet
public bool SetLastError
public bool ExactSpelling
public bool PreserveSig
public CallingConvention CallingConvention
public bool BestFitMapping
public bool ThrowOnUnmappableChar
public string Value
internal Attribute GetCustomAttribute(RuntimeMethodInfo method)
internal bool IsDefined(RuntimeMethodInfo method)
internal void .ctor(string dllName, string entryPoint, CharSet charSet, bool exactSpelling, bool setLastError, bool preserveSig, CallingConvention callingConvention, bool bestFitMapping, bool throwOnUnmappableChar)
public void .ctor(string dllName)
public string get_Value()
}
public System.Runtime.InteropServices.DllImportSearchPath : Enum {
public int value__
public DllImportSearchPath UseDllDirectoryForDependencies
public DllImportSearchPath ApplicationDirectory
public DllImportSearchPath UserDirectories
public DllImportSearchPath System32
public DllImportSearchPath SafeDirectories
public DllImportSearchPath AssemblyDirectory
public DllImportSearchPath LegacyBehavior
}
public System.Runtime.InteropServices.ELEMDESC : ValueType {
public TYPEDESC tdesc
public DESCUNION desc
}
public System.Runtime.InteropServices.ErrorWrapper : object {
private int m_ErrorCode
public int ErrorCode
public void .ctor(int errorCode)
public void .ctor(object errorCode)
public void .ctor(Exception e)
public int get_ErrorCode()
}
public System.Runtime.InteropServices.EXCEPINFO : ValueType {
public short wCode
public short wReserved
public string bstrSource
public string bstrDescription
public string bstrHelpFile
public int dwHelpContext
public IntPtr pvReserved
public IntPtr pfnDeferredFillIn
}
public System.Runtime.InteropServices.Expando.IExpando {
public FieldInfo AddField(string name)
public PropertyInfo AddProperty(string name)
public MethodInfo AddMethod(string name, Delegate method)
public void RemoveMember(MemberInfo m)
}
public System.Runtime.InteropServices.ExporterEventKind : Enum {
public int value__
public ExporterEventKind NOTIF_TYPECONVERTED
public ExporterEventKind NOTIF_CONVERTWARNING
public ExporterEventKind ERROR_REFTOINVALIDASSEMBLY
}
public System.Runtime.InteropServices.ExtensibleClassFactory : object {
private Hashtable hashtable
internal ObjectCreationDelegate GetObjectCreationCallback(Type t)
public void RegisterObjectCreationCallback(ObjectCreationDelegate callback)
}
public System.Runtime.InteropServices.ExternalException : SystemException {
public int ErrorCode
public void .ctor(string message)
public void .ctor(string message, Exception inner)
public void .ctor(string message, int errorCode)
protected void .ctor(SerializationInfo info, StreamingContext context)
public int get_ErrorCode()
public string ToString()
}
public System.Runtime.InteropServices.FieldOffsetAttribute : Attribute {
internal int _val
public int Value
internal Attribute GetCustomAttribute(RuntimeFieldInfo field)
internal bool IsDefined(RuntimeFieldInfo field)
public void .ctor(int offset)
public int get_Value()
}
public System.Runtime.InteropServices.FILETIME : ValueType {
public int dwLowDateTime
public int dwHighDateTime
}
public System.Runtime.InteropServices.FUNCDESC : ValueType {
public int memid
public IntPtr lprgscode
public IntPtr lprgelemdescParam
public FUNCKIND funckind
public INVOKEKIND invkind
public CALLCONV callconv
public short cParams
public short cParamsOpt
public short oVft
public short cScodes
public ELEMDESC elemdescFunc
public short wFuncFlags
}
public System.Runtime.InteropServices.FUNCFLAGS : Enum {
public short value__
public FUNCFLAGS FUNCFLAG_FRESTRICTED
public FUNCFLAGS FUNCFLAG_FSOURCE
public FUNCFLAGS FUNCFLAG_FBINDABLE
public FUNCFLAGS FUNCFLAG_FREQUESTEDIT
public FUNCFLAGS FUNCFLAG_FDISPLAYBIND
public FUNCFLAGS FUNCFLAG_FDEFAULTBIND
public FUNCFLAGS FUNCFLAG_FHIDDEN
public FUNCFLAGS FUNCFLAG_FUSESGETLASTERROR
public FUNCFLAGS FUNCFLAG_FDEFAULTCOLLELEM
public FUNCFLAGS FUNCFLAG_FUIDEFAULT
public FUNCFLAGS FUNCFLAG_FNONBROWSABLE
public FUNCFLAGS FUNCFLAG_FREPLACEABLE
public FUNCFLAGS FUNCFLAG_FIMMEDIATEBIND
}
public System.Runtime.InteropServices.FUNCKIND : Enum {
public int value__
public FUNCKIND FUNC_VIRTUAL
public FUNCKIND FUNC_PUREVIRTUAL
public FUNCKIND FUNC_NONVIRTUAL
public FUNCKIND FUNC_STATIC
public FUNCKIND FUNC_DISPATCH
}
public System.Runtime.InteropServices.GCHandle : ValueType {
private int handle
public bool IsAllocated
public object Target
private void .ctor(IntPtr h)
private void .ctor(object obj)
internal void .ctor(object value, GCHandleType type)
public bool get_IsAllocated()
public object get_Target()
public void set_Target(object value)
public IntPtr AddrOfPinnedObject()
public GCHandle Alloc(object value)
public GCHandle Alloc(object value, GCHandleType type)
public void Free()
public IntPtr op_Explicit(GCHandle value)
public GCHandle op_Explicit(IntPtr value)
private bool CheckCurrentDomain(int handle)
private object GetTarget(int handle)
private int GetTargetHandle(object obj, int handle, GCHandleType type)
private void FreeHandle(int handle)
private IntPtr GetAddrOfPinnedObject(int handle)
public bool op_Equality(GCHandle a, GCHandle b)
public bool op_Inequality(GCHandle a, GCHandle b)
public bool Equals(object o)
public int GetHashCode()
public GCHandle FromIntPtr(IntPtr value)
public IntPtr ToIntPtr(GCHandle value)
}
public System.Runtime.InteropServices.GCHandleType : Enum {
public int value__
public GCHandleType Weak
public GCHandleType WeakTrackResurrection
public GCHandleType Normal
public GCHandleType Pinned
}
public System.Runtime.InteropServices.GuidAttribute : Attribute {
internal string _val
public string Value
public void .ctor(string guid)
public string get_Value()
}
public System.Runtime.InteropServices.HandleRef : ValueType {
internal object m_wrapper
internal IntPtr m_handle
public object Wrapper
public IntPtr Handle
public void .ctor(object wrapper, IntPtr handle)
public object get_Wrapper()
public IntPtr get_Handle()
public IntPtr op_Explicit(HandleRef value)
public IntPtr ToIntPtr(HandleRef value)
}
public System.Runtime.InteropServices.ICustomAdapter {
public object GetUnderlyingObject()
}
public System.Runtime.InteropServices.ICustomFactory {
public MarshalByRefObject CreateInstance(Type serverType)
}
public System.Runtime.InteropServices.ICustomMarshaler {
public object MarshalNativeToManaged(IntPtr pNativeData)
public IntPtr MarshalManagedToNative(object ManagedObj)
public void CleanUpNativeData(IntPtr pNativeData)
public void CleanUpManagedData(object ManagedObj)
public int GetNativeDataSize()
}
public System.Runtime.InteropServices.ICustomQueryInterface {
public CustomQueryInterfaceResult GetInterface(Guid& iid, IntPtr& ppv)
}
public System.Runtime.InteropServices.IDispatchImplAttribute : Attribute {
internal IDispatchImplType _val
public IDispatchImplType Value
public void .ctor(IDispatchImplType implType)
public void .ctor(short implType)
public IDispatchImplType get_Value()
}
public System.Runtime.InteropServices.IDispatchImplType : Enum {
public int value__
public IDispatchImplType SystemDefinedImpl
public IDispatchImplType InternalImpl
public IDispatchImplType CompatibleImpl
}
public System.Runtime.InteropServices.IDLDESC : ValueType {
public int dwReserved
public IDLFLAG wIDLFlags
}
public System.Runtime.InteropServices.IDLFLAG : Enum {
public short value__
public IDLFLAG IDLFLAG_NONE
public IDLFLAG IDLFLAG_FIN
public IDLFLAG IDLFLAG_FOUT
public IDLFLAG IDLFLAG_FLCID
public IDLFLAG IDLFLAG_FRETVAL
}
internal System.Runtime.InteropServices.IErrorInfo {
public int GetGUID(Guid& pGuid)
public int GetSource(String& pBstrSource)
public int GetDescription(String& pbstrDescription)
public int GetHelpFile(String& pBstrHelpFile)
public int GetHelpContext(UInt32& pdwHelpContext)
}
public System.Runtime.InteropServices.IMPLTYPEFLAGS : Enum {
public int value__
public IMPLTYPEFLAGS IMPLTYPEFLAG_FDEFAULT
public IMPLTYPEFLAGS IMPLTYPEFLAG_FSOURCE
public IMPLTYPEFLAGS IMPLTYPEFLAG_FRESTRICTED
public IMPLTYPEFLAGS IMPLTYPEFLAG_FDEFAULTVTABLE
}
public System.Runtime.InteropServices.ImportedFromTypeLibAttribute : Attribute {
internal string _val
public string Value
public void .ctor(string tlbFile)
public string get_Value()
}
public System.Runtime.InteropServices.ImporterEventKind : Enum {
public int value__
public ImporterEventKind NOTIF_TYPECONVERTED
public ImporterEventKind NOTIF_CONVERTWARNING
public ImporterEventKind ERROR_REFTOINVALIDTYPELIB
}
public System.Runtime.InteropServices.InAttribute : Attribute {
internal Attribute GetCustomAttribute(RuntimeParameterInfo parameter)
internal bool IsDefined(RuntimeParameterInfo parameter)
}
public System.Runtime.InteropServices.InterfaceTypeAttribute : Attribute {
internal ComInterfaceType _val
public ComInterfaceType Value
public void .ctor(ComInterfaceType interfaceType)
public void .ctor(short interfaceType)
public ComInterfaceType get_Value()
}
public System.Runtime.InteropServices.InvalidComObjectException : SystemException {
public void .ctor(string message)
public void .ctor(string message, Exception inner)
protected void .ctor(SerializationInfo info, StreamingContext context)
}
public System.Runtime.InteropServices.InvalidOleVariantTypeException : SystemException {
public void .ctor(string message)
public void .ctor(string message, Exception inner)
protected void .ctor(SerializationInfo info, StreamingContext context)
}
public System.Runtime.InteropServices.INVOKEKIND : Enum {
public int value__
public INVOKEKIND INVOKE_FUNC
public INVOKEKIND INVOKE_PROPERTYGET
public INVOKEKIND INVOKE_PROPERTYPUT
public INVOKEKIND INVOKE_PROPERTYPUTREF
}
public System.Runtime.InteropServices.IRegistrationServices {
public bool RegisterAssembly(Assembly assembly, AssemblyRegistrationFlags flags)
public bool UnregisterAssembly(Assembly assembly)
public Type[] GetRegistrableTypesInAssembly(Assembly assembly)
public string GetProgIdForType(Type type)
public void RegisterTypeForComClients(Type type, Guid& g)
public Guid GetManagedCategoryGuid()
public bool TypeRequiresRegistration(Type type)
public bool TypeRepresentsComType(Type type)
}
public System.Runtime.InteropServices.ITypeLibConverter {
public object ConvertAssemblyToTypeLib(Assembly assembly, string typeLibName, TypeLibExporterFlags flags, ITypeLibExporterNotifySink notifySink)
public AssemblyBuilder ConvertTypeLibToAssembly(object typeLib, string asmFileName, int flags, ITypeLibImporterNotifySink notifySink, Byte[] publicKey, StrongNameKeyPair keyPair, bool unsafeInterfaces)
public AssemblyBuilder ConvertTypeLibToAssembly(object typeLib, string asmFileName, TypeLibImporterFlags flags, ITypeLibImporterNotifySink notifySink, Byte[] publicKey, StrongNameKeyPair keyPair, string asmNamespace, Version asmVersion)
public bool GetPrimaryInteropAssembly(Guid g, int major, int minor, int lcid, String& asmName, String& asmCodeBase)
}
public System.Runtime.InteropServices.ITypeLibExporterNameProvider {
public String[] GetNames()
}
public System.Runtime.InteropServices.ITypeLibExporterNotifySink {
public void ReportEvent(ExporterEventKind eventKind, int eventCode, string eventMsg)
public object ResolveRef(Assembly assembly)
}
public System.Runtime.InteropServices.ITypeLibImporterNotifySink {
public void ReportEvent(ImporterEventKind eventKind, int eventCode, string eventMsg)
public Assembly ResolveRef(object typeLib)
}
public System.Runtime.InteropServices.LayoutKind : Enum {
public int value__
public LayoutKind Sequential
public LayoutKind Explicit
public LayoutKind Auto
}
public System.Runtime.InteropServices.LCIDConversionAttribute : Attribute {
internal int _val
public int Value
public void .ctor(int lcid)
public int get_Value()
}
public System.Runtime.InteropServices.LIBFLAGS : Enum {
public short value__
public LIBFLAGS LIBFLAG_FRESTRICTED
public LIBFLAGS LIBFLAG_FCONTROL
public LIBFLAGS LIBFLAG_FHIDDEN
public LIBFLAGS LIBFLAG_FHASDISKIMAGE
}
internal System.Runtime.InteropServices.ManagedErrorInfo : object {
private Exception m_Exception
public Exception Exception
public void .ctor(Exception e)
public Exception get_Exception()
public int GetGUID(Guid& guid)
public int GetSource(String& source)
public int GetDescription(String& description)
public int GetHelpFile(String& helpFile)
public int GetHelpContext(UInt32& helpContext)
}
public System.Runtime.InteropServices.ManagedToNativeComInteropStubAttribute : Attribute {
internal Type _classType
internal string _methodName
public Type ClassType
public string MethodName
public void .ctor(Type classType, string methodName)
public Type get_ClassType()
public string get_MethodName()
}
public System.Runtime.InteropServices.Marshal : object {
public int SystemMaxDBCSCharSize
public int SystemDefaultCharSize
private bool SetErrorInfoNotAvailable
private bool GetErrorInfoNotAvailable
private int AddRefInternal(IntPtr pUnk)
public int AddRef(IntPtr pUnk)
public bool AreComObjectsAvailableForCleanup()
public void CleanupUnusedObjectsInCurrentContext()
public IntPtr AllocCoTaskMem(int cb)
internal IntPtr AllocCoTaskMemSize(UIntPtr sizet)
public IntPtr AllocHGlobal(IntPtr cb)
public IntPtr AllocHGlobal(int cb)
public object BindToMoniker(string monikerName)
public void ChangeWrapperHandleStrength(object otp, bool fIsWeak)
internal void copy_to_unmanaged(Array source, int startIndex, IntPtr destination, int length)
internal void copy_from_unmanaged(IntPtr source, int startIndex, Array destination, int length)
public void Copy(Byte[] source, int startIndex, IntPtr destination, int length)
public void Copy(Char[] source, int startIndex, IntPtr destination, int length)
public void Copy(Int16[] source, int startIndex, IntPtr destination, int length)
public void Copy(Int32[] source, int startIndex, IntPtr destination, int length)
public void Copy(Int64[] source, int startIndex, IntPtr destination, int length)
public void Copy(Single[] source, int startIndex, IntPtr destination, int length)
public void Copy(Double[] source, int startIndex, IntPtr destination, int length)
public void Copy(IntPtr[] source, int startIndex, IntPtr destination, int length)
public void Copy(IntPtr source, Byte[] destination, int startIndex, int length)
public void Copy(IntPtr source, Char[] destination, int startIndex, int length)
public void Copy(IntPtr source, Int16[] destination, int startIndex, int length)
public void Copy(IntPtr source, Int32[] destination, int startIndex, int length)
public void Copy(IntPtr source, Int64[] destination, int startIndex, int length)
public void Copy(IntPtr source, Single[] destination, int startIndex, int length)
public void Copy(IntPtr source, Double[] destination, int startIndex, int length)
public void Copy(IntPtr source, IntPtr[] destination, int startIndex, int length)
public IntPtr CreateAggregatedObject(IntPtr pOuter, object o)
public IntPtr CreateAggregatedObject(IntPtr pOuter, T o)
public object CreateWrapperOfType(object o, Type t)
public TWrapper CreateWrapperOfType(T o)
public void DestroyStructure(IntPtr ptr, Type structuretype)
public void DestroyStructure(IntPtr ptr)
public void FreeBSTR(IntPtr ptr)
public void FreeCoTaskMem(IntPtr ptr)
public void FreeHGlobal(IntPtr hglobal)
private void ClearBSTR(IntPtr ptr)
public void ZeroFreeBSTR(IntPtr s)
private void ClearAnsi(IntPtr ptr)
private void ClearUnicode(IntPtr ptr)
public void ZeroFreeCoTaskMemAnsi(IntPtr s)
public void ZeroFreeCoTaskMemUnicode(IntPtr s)
public void ZeroFreeCoTaskMemUTF8(IntPtr s)
public void ZeroFreeGlobalAllocAnsi(IntPtr s)
public void ZeroFreeGlobalAllocUnicode(IntPtr s)
public Guid GenerateGuidForType(Type type)
public string GenerateProgIdForType(Type type)
public object GetActiveObject(string progID)
private IntPtr GetCCW(object o, Type T)
private IntPtr GetComInterfaceForObjectInternal(object o, Type T)
public IntPtr GetComInterfaceForObject(object o, Type T)
public IntPtr GetComInterfaceForObject(object o, Type T, CustomQueryInterfaceMode mode)
public IntPtr GetComInterfaceForObject(T o)
public IntPtr GetComInterfaceForObjectInContext(object o, Type t)
public object GetComObjectData(object obj, object key)
private int GetComSlotForMethodInfoInternal(MemberInfo m)
public int GetComSlotForMethodInfo(MemberInfo m)
public int GetEndComSlot(Type t)
public IntPtr GetExceptionPointers()
public IntPtr GetHINSTANCE(Module m)
public int GetExceptionCode()
public int GetHRForException(Exception e)
public int GetHRForLastWin32Error()
private IntPtr GetIDispatchForObjectInternal(object o)
public IntPtr GetIDispatchForObject(object o)
public IntPtr GetIDispatchForObjectInContext(object o)
public IntPtr GetITypeInfoForType(Type t)
public IntPtr GetIUnknownForObjectInContext(object o)
public IntPtr GetManagedThunkForUnmanagedMethodPtr(IntPtr pfnMethodToWrap, IntPtr pbSignature, int cbSignature)
public MemberInfo GetMethodInfoForComSlot(Type t, int slot, ComMemberType& memberType)
private IntPtr GetIUnknownForObjectInternal(object o)
public IntPtr GetIUnknownForObject(object o)
public void GetNativeVariantForObject(object obj, IntPtr pDstNativeVariant)
public void GetNativeVariantForObject(T obj, IntPtr pDstNativeVariant)
private object GetObjectForCCW(IntPtr pUnk)
public object GetObjectForIUnknown(IntPtr pUnk)
public object GetObjectForNativeVariant(IntPtr pSrcNativeVariant)
public T GetObjectForNativeVariant(IntPtr pSrcNativeVariant)
public Object[] GetObjectsForNativeVariants(IntPtr aSrcNativeVariant, int cVars)
public T[] GetObjectsForNativeVariants(IntPtr aSrcNativeVariant, int cVars)
public int GetStartComSlot(Type t)
public Thread GetThreadFromFiberCookie(int cookie)
public object GetTypedObjectForIUnknown(IntPtr pUnk, Type t)
public Type GetTypeForITypeInfo(IntPtr piTypeInfo)
public string GetTypeInfoName(UCOMITypeInfo pTI)
public Guid GetTypeLibGuid(UCOMITypeLib pTLB)
public Guid GetTypeLibGuid(ITypeLib typelib)
public Guid GetTypeLibGuidForAssembly(Assembly asm)
public int GetTypeLibLcid(UCOMITypeLib pTLB)
public int GetTypeLibLcid(ITypeLib typelib)
public string GetTypeLibName(UCOMITypeLib pTLB)
public string GetTypeLibName(ITypeLib typelib)
public void GetTypeLibVersionForAssembly(Assembly inputAssembly, Int32& majorVersion, Int32& minorVersion)
public IntPtr GetUnmanagedThunkForManagedMethodPtr(IntPtr pfnMethodToWrap, IntPtr pbSignature, int cbSignature)
public bool IsTypeVisibleFromCom(Type t)
public int NumParamBytes(MethodInfo m)
public Type GetTypeFromCLSID(Guid clsid)
public string GetTypeInfoName(ITypeInfo typeInfo)
public object GetUniqueObjectForIUnknown(IntPtr unknown)
public bool IsComObject(object o)
public int GetLastWin32Error()
public IntPtr OffsetOf(Type t, string fieldName)
public IntPtr OffsetOf(string fieldName)
public void Prelink(MethodInfo m)
public void PrelinkAll(Type c)
public string PtrToStringAnsi(IntPtr ptr)
public string PtrToStringAnsi(IntPtr ptr, int len)
public string PtrToStringUTF8(IntPtr ptr)
public string PtrToStringUTF8(IntPtr ptr, int byteLen)
public string PtrToStringAuto(IntPtr ptr)
public string PtrToStringAuto(IntPtr ptr, int len)
public string PtrToStringUni(IntPtr ptr)
public string PtrToStringUni(IntPtr ptr, int len)
public string PtrToStringBSTR(IntPtr ptr)
public void PtrToStructure(IntPtr ptr, object structure)
public object PtrToStructure(IntPtr ptr, Type structureType)
public void PtrToStructure(IntPtr ptr, T structure)
public T PtrToStructure(IntPtr ptr)
private int QueryInterfaceInternal(IntPtr pUnk, Guid& iid, IntPtr& ppv)
public int QueryInterface(IntPtr pUnk, Guid& iid, IntPtr& ppv)
public byte ReadByte(IntPtr ptr)
public byte ReadByte(IntPtr ptr, int ofs)
public byte ReadByte(object ptr, int ofs)
public short ReadInt16(IntPtr ptr)
public short ReadInt16(IntPtr ptr, int ofs)
public short ReadInt16(object ptr, int ofs)
public int ReadInt32(IntPtr ptr)
public int ReadInt32(IntPtr ptr, int ofs)
public int ReadInt32(object ptr, int ofs)
public long ReadInt64(IntPtr ptr)
public long ReadInt64(IntPtr ptr, int ofs)
public long ReadInt64(object ptr, int ofs)
public IntPtr ReadIntPtr(IntPtr ptr)
public IntPtr ReadIntPtr(IntPtr ptr, int ofs)
public IntPtr ReadIntPtr(object ptr, int ofs)
public IntPtr ReAllocCoTaskMem(IntPtr pv, int cb)
public IntPtr ReAllocHGlobal(IntPtr pv, IntPtr cb)
private int ReleaseInternal(IntPtr pUnk)
public int Release(IntPtr pUnk)
private int ReleaseComObjectInternal(object co)
public int ReleaseComObject(object o)
public void ReleaseThreadCache()
public bool SetComObjectData(object obj, object key, object data)
public int SizeOf(object structure)
public int SizeOf(Type t)
public int SizeOf()
public int SizeOf(T structure)
internal UInt32 SizeOfType(Type type)
internal UInt32 AlignedSizeOf()
public IntPtr StringToBSTR(string s)
public IntPtr StringToCoTaskMemAnsi(string s)
public IntPtr StringToCoTaskMemAuto(string s)
public IntPtr StringToCoTaskMemUni(string s)
public IntPtr StringToHGlobalAnsi(string s)
public IntPtr StringToAllocatedMemoryUTF8(string s)
public IntPtr StringToHGlobalAuto(string s)
public IntPtr StringToHGlobalUni(string s)
public IntPtr SecureStringToBSTR(SecureString s)
public IntPtr SecureStringToCoTaskMemAnsi(SecureString s)
public IntPtr SecureStringToCoTaskMemUnicode(SecureString s)
public IntPtr SecureStringToGlobalAllocAnsi(SecureString s)
public IntPtr SecureStringToGlobalAllocUnicode(SecureString s)
public void StructureToPtr(object structure, IntPtr ptr, bool fDeleteOld)
public void StructureToPtr(T structure, IntPtr ptr, bool fDeleteOld)
public void ThrowExceptionForHR(int errorCode)
public void ThrowExceptionForHR(int errorCode, IntPtr errorInfo)
private IntPtr BufferToBSTR(Array ptr, int slen)
public IntPtr UnsafeAddrOfPinnedArrayElement(Array arr, int index)
public IntPtr UnsafeAddrOfPinnedArrayElement(T[] arr, int index)
public void WriteByte(IntPtr ptr, byte val)
public void WriteByte(IntPtr ptr, int ofs, byte val)
public void WriteByte(object ptr, int ofs, byte val)
public void WriteInt16(IntPtr ptr, short val)
public void WriteInt16(IntPtr ptr, int ofs, short val)
public void WriteInt16(object ptr, int ofs, short val)
public void WriteInt16(IntPtr ptr, char val)
public void WriteInt16(IntPtr ptr, int ofs, char val)
public void WriteInt16(object ptr, int ofs, char val)
public void WriteInt32(IntPtr ptr, int val)
public void WriteInt32(IntPtr ptr, int ofs, int val)
public void WriteInt32(object ptr, int ofs, int val)
public void WriteInt64(IntPtr ptr, long val)
public void WriteInt64(IntPtr ptr, int ofs, long val)
public void WriteInt64(object ptr, int ofs, long val)
public void WriteIntPtr(IntPtr ptr, IntPtr val)
public void WriteIntPtr(IntPtr ptr, int ofs, IntPtr val)
public void WriteIntPtr(object ptr, int ofs, IntPtr val)
private Exception ConvertHrToException(int errorCode)
private int _SetErrorInfo(int dwReserved, IErrorInfo pIErrorInfo)
private int _GetErrorInfo(int dwReserved, IErrorInfo& ppIErrorInfo)
internal int SetErrorInfo(int dwReserved, IErrorInfo errorInfo)
internal int GetErrorInfo(int dwReserved, IErrorInfo& errorInfo)
public Exception GetExceptionForHR(int errorCode)
public Exception GetExceptionForHR(int errorCode, IntPtr errorInfo)
public int FinalReleaseComObject(object o)
private Delegate GetDelegateForFunctionPointerInternal(IntPtr ptr, Type t)
public Delegate GetDelegateForFunctionPointer(IntPtr ptr, Type t)
public TDelegate GetDelegateForFunctionPointer(IntPtr ptr)
private IntPtr GetFunctionPointerForDelegateInternal(Delegate d)
public IntPtr GetFunctionPointerForDelegate(Delegate d)
public IntPtr GetFunctionPointerForDelegate(TDelegate d)
internal void SetLastWin32Error(int error)
internal IntPtr GetRawIUnknownForComObjectNoAddRef(object o)
internal int GetHRForException_WinRT(Exception e)
internal object GetNativeActivationFactory(Type type)
}
public System.Runtime.InteropServices.MarshalAsAttribute : Attribute {
public string MarshalCookie
public string MarshalType
public Type MarshalTypeRef
public Type SafeArrayUserDefinedSubType
private UnmanagedType utype
public UnmanagedType ArraySubType
public VarEnum SafeArraySubType
public int SizeConst
public int IidParameterIndex
public short SizeParamIndex
public UnmanagedType Value
public void .ctor(short unmanagedType)
public void .ctor(UnmanagedType unmanagedType)
public UnmanagedType get_Value()
internal MarshalAsAttribute Copy()
}
public System.Runtime.InteropServices.MarshalDirectiveException : SystemException {
public void .ctor(string message)
public void .ctor(string message, Exception inner)
protected void .ctor(SerializationInfo info, StreamingContext context)
}
internal System.Runtime.InteropServices.NativeCallableAttribute : Attribute {
public string EntryPoint
public CallingConvention CallingConvention
}
public System.Runtime.InteropServices.ObjectCreationDelegate : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public IntPtr Invoke(IntPtr aggregator)
public IAsyncResult BeginInvoke(IntPtr aggregator, AsyncCallback callback, object object)
public IntPtr EndInvoke(IAsyncResult result)
}
public System.Runtime.InteropServices.OptionalAttribute : Attribute {
internal Attribute GetCustomAttribute(RuntimeParameterInfo parameter)
internal bool IsDefined(RuntimeParameterInfo parameter)
}
public System.Runtime.InteropServices.OSPlatform : ValueType {
private string _osPlatform
private OSPlatform <Linux>k__BackingField
private OSPlatform <OSX>k__BackingField
private OSPlatform <Windows>k__BackingField
public OSPlatform Linux
public OSPlatform OSX
public OSPlatform Windows
public OSPlatform get_Linux()
public OSPlatform get_OSX()
public OSPlatform get_Windows()
private void .ctor(string osPlatform)
public OSPlatform Create(string osPlatform)
public bool Equals(OSPlatform other)
internal bool Equals(string other)
public bool Equals(object obj)
public int GetHashCode()
public string ToString()
public bool op_Equality(OSPlatform left, OSPlatform right)
public bool op_Inequality(OSPlatform left, OSPlatform right)
}
public System.Runtime.InteropServices.OutAttribute : Attribute {
internal Attribute GetCustomAttribute(RuntimeParameterInfo parameter)
internal bool IsDefined(RuntimeParameterInfo parameter)
}
public System.Runtime.InteropServices.PARAMDESC : ValueType {
public IntPtr lpVarValue
public PARAMFLAG wParamFlags
}
public System.Runtime.InteropServices.PARAMFLAG : Enum {
public short value__
public PARAMFLAG PARAMFLAG_NONE
public PARAMFLAG PARAMFLAG_FIN
public PARAMFLAG PARAMFLAG_FOUT
public PARAMFLAG PARAMFLAG_FLCID
public PARAMFLAG PARAMFLAG_FRETVAL
public PARAMFLAG PARAMFLAG_FOPT
public PARAMFLAG PARAMFLAG_FHASDEFAULT
public PARAMFLAG PARAMFLAG_FHASCUSTDATA
}
public System.Runtime.InteropServices.PreserveSigAttribute : Attribute {
internal Attribute GetCustomAttribute(RuntimeMethodInfo method)
internal bool IsDefined(RuntimeMethodInfo method)
}
public System.Runtime.InteropServices.PrimaryInteropAssemblyAttribute : Attribute {
internal int _major
internal int _minor
public int MajorVersion
public int MinorVersion
public void .ctor(int major, int minor)
public int get_MajorVersion()
public int get_MinorVersion()
}
public System.Runtime.InteropServices.ProgIdAttribute : Attribute {
internal string _val
public string Value
public void .ctor(string progId)
public string get_Value()
}
public System.Runtime.InteropServices.RegistrationClassContext : Enum {
public int value__
public RegistrationClassContext DisableActivateAsActivator
public RegistrationClassContext EnableActivateAsActivator
public RegistrationClassContext EnableCodeDownload
public RegistrationClassContext FromDefaultContext
public RegistrationClassContext InProcessHandler
public RegistrationClassContext InProcessHandler16
public RegistrationClassContext InProcessServer
public RegistrationClassContext InProcessServer16
public RegistrationClassContext LocalServer
public RegistrationClassContext NoCodeDownload
public RegistrationClassContext NoCustomMarshal
public RegistrationClassContext NoFailureLog
public RegistrationClassContext RemoteServer
public RegistrationClassContext Reserved1
public RegistrationClassContext Reserved2
public RegistrationClassContext Reserved3
public RegistrationClassContext Reserved4
public RegistrationClassContext Reserved5
}
public System.Runtime.InteropServices.RegistrationConnectionType : Enum {
public int value__
public RegistrationConnectionType MultipleUse
public RegistrationConnectionType MultiSeparate
public RegistrationConnectionType SingleUse
public RegistrationConnectionType Suspended
public RegistrationConnectionType Surrogate
}
public System.Runtime.InteropServices.RegistrationServices : object {
private Guid guidManagedCategory
public Guid GetManagedCategoryGuid()
public string GetProgIdForType(Type type)
public Type[] GetRegistrableTypesInAssembly(Assembly assembly)
public bool RegisterAssembly(Assembly assembly, AssemblyRegistrationFlags flags)
public void RegisterTypeForComClients(Type type, Guid& g)
public bool TypeRepresentsComType(Type type)
public bool TypeRequiresRegistration(Type type)
public bool UnregisterAssembly(Assembly assembly)
public int RegisterTypeForComClients(Type type, RegistrationClassContext classContext, RegistrationConnectionType flags)
public void UnregisterTypeForComClients(int cookie)
}
public System.Runtime.InteropServices.RuntimeEnvironment : object {
public string SystemConfigurationFile
public bool FromGlobalAccessCache(Assembly a)
public string GetSystemVersion()
public string GetRuntimeDirectory()
private string GetRuntimeDirectoryImpl()
public string get_SystemConfigurationFile()
private IntPtr GetRuntimeInterfaceImpl(Guid clsid, Guid riid)
public IntPtr GetRuntimeInterfaceAsIntPtr(Guid clsid, Guid riid)
public object GetRuntimeInterfaceAsObject(Guid clsid, Guid riid)
}
public System.Runtime.InteropServices.RuntimeInformation : object {
public string FrameworkDescription
public string OSDescription
public Architecture OSArchitecture
public Architecture ProcessArchitecture
public string get_FrameworkDescription()
public bool IsOSPlatform(OSPlatform osPlatform)
public string get_OSDescription()
public Architecture get_OSArchitecture()
public Architecture get_ProcessArchitecture()
}
public System.Runtime.InteropServices.SafeArrayRankMismatchException : SystemException {
public void .ctor(string message)
public void .ctor(string message, Exception inner)
protected void .ctor(SerializationInfo info, StreamingContext context)
}
public System.Runtime.InteropServices.SafeArrayTypeMismatchException : SystemException {
public void .ctor(string message)
public void .ctor(string message, Exception inner)
protected void .ctor(SerializationInfo info, StreamingContext context)
}
public System.Runtime.InteropServices.SafeBuffer : SafeHandleZeroOrMinusOneIsInvalid {
private ulong byte_length
private Byte* last_byte
private bool inited
public ulong ByteLength
protected void .ctor(bool ownsHandle)
public void Initialize(ulong numBytes)
public void Initialize(UInt32 numElements, UInt32 sizeOfEachElement)
public void Initialize(UInt32 numElements)
public void AcquirePointer(Byte*& pointer)
public void ReleasePointer()
public ulong get_ByteLength()
public T Read(ulong byteOffset)
public void ReadArray(ulong byteOffset, T[] array, int index, int count)
public void Write(ulong byteOffset, T value)
public void WriteArray(ulong byteOffset, T[] array, int index, int count)
}
public System.Runtime.InteropServices.SafeHandle : CriticalFinalizerObject {
protected IntPtr handle
private int _state
private bool _ownsHandle
private bool _fullyInitialized
private int RefCount_Mask
private int RefCount_One
public bool IsClosed
public bool IsInvalid
protected void .ctor(IntPtr invalidHandleValue, bool ownsHandle)
protected void Finalize()
protected void SetHandle(IntPtr handle)
public IntPtr DangerousGetHandle()
public bool get_IsClosed()
public bool get_IsInvalid()
public void Close()
public void Dispose()
protected void Dispose(bool disposing)
protected bool ReleaseHandle()
public void SetHandleAsInvalid()
public void DangerousAddRef(Boolean& success)
public void DangerousRelease()
private void InternalDispose()
private void InternalFinalize()
private void DangerousReleaseInternal(bool dispose)
}
public System.Runtime.InteropServices.SEHException : ExternalException {
public void .ctor(string message)
public void .ctor(string message, Exception inner)
protected void .ctor(SerializationInfo info, StreamingContext context)
public bool CanResume()
}
public System.Runtime.InteropServices.STATSTG : ValueType {
public string pwcsName
public int type
public long cbSize
public FILETIME mtime
public FILETIME ctime
public FILETIME atime
public int grfMode
public int grfLocksSupported
public Guid clsid
public int grfStateBits
public int reserved
}
public System.Runtime.InteropServices.StructLayoutAttribute : Attribute {
private int DEFAULT_PACKING_SIZE
internal LayoutKind _val
public int Pack
public int Size
public CharSet CharSet
public LayoutKind Value
internal StructLayoutAttribute GetCustomAttribute(RuntimeType type)
internal bool IsDefined(RuntimeType type)
internal void .ctor(LayoutKind layoutKind, int pack, int size, CharSet charSet)
public void .ctor(LayoutKind layoutKind)
public void .ctor(short layoutKind)
public LayoutKind get_Value()
}
public System.Runtime.InteropServices.SYSKIND : Enum {
public int value__
public SYSKIND SYS_WIN16
public SYSKIND SYS_WIN32
public SYSKIND SYS_MAC
}
public System.Runtime.InteropServices.TYPEATTR : ValueType {
public int MEMBER_ID_NIL
public Guid guid
public int lcid
public int dwReserved
public int memidConstructor
public int memidDestructor
public IntPtr lpstrSchema
public int cbSizeInstance
public TYPEKIND typekind
public short cFuncs
public short cVars
public short cImplTypes
public short cbSizeVft
public short cbAlignment
public TYPEFLAGS wTypeFlags
public short wMajorVerNum
public short wMinorVerNum
public TYPEDESC tdescAlias
public IDLDESC idldescType
}
public System.Runtime.InteropServices.TYPEDESC : ValueType {
public IntPtr lpValue
public short vt
}
public System.Runtime.InteropServices.TYPEFLAGS : Enum {
public short value__
public TYPEFLAGS TYPEFLAG_FAPPOBJECT
public TYPEFLAGS TYPEFLAG_FCANCREATE
public TYPEFLAGS TYPEFLAG_FLICENSED
public TYPEFLAGS TYPEFLAG_FPREDECLID
public TYPEFLAGS TYPEFLAG_FHIDDEN
public TYPEFLAGS TYPEFLAG_FCONTROL
public TYPEFLAGS TYPEFLAG_FDUAL
public TYPEFLAGS TYPEFLAG_FNONEXTENSIBLE
public TYPEFLAGS TYPEFLAG_FOLEAUTOMATION
public TYPEFLAGS TYPEFLAG_FRESTRICTED
public TYPEFLAGS TYPEFLAG_FAGGREGATABLE
public TYPEFLAGS TYPEFLAG_FREPLACEABLE
public TYPEFLAGS TYPEFLAG_FDISPATCHABLE
public TYPEFLAGS TYPEFLAG_FREVERSEBIND
public TYPEFLAGS TYPEFLAG_FPROXY
}
public System.Runtime.InteropServices.TypeIdentifierAttribute : Attribute {
internal string Scope_
internal string Identifier_
public string Scope
public string Identifier
public void .ctor(string scope, string identifier)
public string get_Scope()
public string get_Identifier()
}
public System.Runtime.InteropServices.TYPEKIND : Enum {
public int value__
public TYPEKIND TKIND_ENUM
public TYPEKIND TKIND_RECORD
public TYPEKIND TKIND_MODULE
public TYPEKIND TKIND_INTERFACE
public TYPEKIND TKIND_DISPATCH
public TYPEKIND TKIND_COCLASS
public TYPEKIND TKIND_ALIAS
public TYPEKIND TKIND_UNION
public TYPEKIND TKIND_MAX
}
public System.Runtime.InteropServices.TYPELIBATTR : ValueType {
public Guid guid
public int lcid
public SYSKIND syskind
public short wMajorVerNum
public short wMinorVerNum
public LIBFLAGS wLibFlags
}
public System.Runtime.InteropServices.TypeLibConverter : object {
public object ConvertAssemblyToTypeLib(Assembly assembly, string strTypeLibName, TypeLibExporterFlags flags, ITypeLibExporterNotifySink notifySink)
public AssemblyBuilder ConvertTypeLibToAssembly(object typeLib, string asmFileName, int flags, ITypeLibImporterNotifySink notifySink, Byte[] publicKey, StrongNameKeyPair keyPair, bool unsafeInterfaces)
public AssemblyBuilder ConvertTypeLibToAssembly(object typeLib, string asmFileName, TypeLibImporterFlags flags, ITypeLibImporterNotifySink notifySink, Byte[] publicKey, StrongNameKeyPair keyPair, string asmNamespace, Version asmVersion)
public bool GetPrimaryInteropAssembly(Guid g, int major, int minor, int lcid, String& asmName, String& asmCodeBase)
}
public System.Runtime.InteropServices.TypeLibExporterFlags : Enum {
public int value__
public TypeLibExporterFlags OnlyReferenceRegistered
public TypeLibExporterFlags None
public TypeLibExporterFlags CallerResolvedReferences
public TypeLibExporterFlags OldNames
public TypeLibExporterFlags ExportAs32Bit
public TypeLibExporterFlags ExportAs64Bit
}
public System.Runtime.InteropServices.TypeLibFuncAttribute : Attribute {
internal TypeLibFuncFlags _val
public TypeLibFuncFlags Value
public void .ctor(TypeLibFuncFlags flags)
public void .ctor(short flags)
public TypeLibFuncFlags get_Value()
}
public System.Runtime.InteropServices.TypeLibFuncFlags : Enum {
public int value__
public TypeLibFuncFlags FRestricted
public TypeLibFuncFlags FSource
public TypeLibFuncFlags FBindable
public TypeLibFuncFlags FRequestEdit
public TypeLibFuncFlags FDisplayBind
public TypeLibFuncFlags FDefaultBind
public TypeLibFuncFlags FHidden
public TypeLibFuncFlags FUsesGetLastError
public TypeLibFuncFlags FDefaultCollelem
public TypeLibFuncFlags FUiDefault
public TypeLibFuncFlags FNonBrowsable
public TypeLibFuncFlags FReplaceable
public TypeLibFuncFlags FImmediateBind
}
public System.Runtime.InteropServices.TypeLibImportClassAttribute : Attribute {
internal string _importClassName
public string Value
public void .ctor(Type importClass)
public string get_Value()
}
public System.Runtime.InteropServices.TypeLibImporterFlags : Enum {
public int value__
public TypeLibImporterFlags PrimaryInteropAssembly
public TypeLibImporterFlags UnsafeInterfaces
public TypeLibImporterFlags SafeArrayAsSystemArray
public TypeLibImporterFlags TransformDispRetVals
public TypeLibImporterFlags None
public TypeLibImporterFlags PreventClassMembers
public TypeLibImporterFlags ImportAsAgnostic
public TypeLibImporterFlags ImportAsItanium
public TypeLibImporterFlags ImportAsX64
public TypeLibImporterFlags ImportAsX86
public TypeLibImporterFlags ReflectionOnlyLoading
public TypeLibImporterFlags SerializableValueClasses
public TypeLibImporterFlags NoDefineVersionResource
public TypeLibImporterFlags ImportAsArm
}
public System.Runtime.InteropServices.TypeLibTypeAttribute : Attribute {
internal TypeLibTypeFlags _val
public TypeLibTypeFlags Value
public void .ctor(TypeLibTypeFlags flags)
public void .ctor(short flags)
public TypeLibTypeFlags get_Value()
}
public System.Runtime.InteropServices.TypeLibTypeFlags : Enum {
public int value__
public TypeLibTypeFlags FAppObject
public TypeLibTypeFlags FCanCreate
public TypeLibTypeFlags FLicensed
public TypeLibTypeFlags FPreDeclId
public TypeLibTypeFlags FHidden
public TypeLibTypeFlags FControl
public TypeLibTypeFlags FDual
public TypeLibTypeFlags FNonExtensible
public TypeLibTypeFlags FOleAutomation
public TypeLibTypeFlags FRestricted
public TypeLibTypeFlags FAggregatable
public TypeLibTypeFlags FReplaceable
public TypeLibTypeFlags FDispatchable
public TypeLibTypeFlags FReverseBind
}
public System.Runtime.InteropServices.TypeLibVarAttribute : Attribute {
internal TypeLibVarFlags _val
public TypeLibVarFlags Value
public void .ctor(TypeLibVarFlags flags)
public void .ctor(short flags)
public TypeLibVarFlags get_Value()
}
public System.Runtime.InteropServices.TypeLibVarFlags : Enum {
public int value__
public TypeLibVarFlags FReadOnly
public TypeLibVarFlags FSource
public TypeLibVarFlags FBindable
public TypeLibVarFlags FRequestEdit
public TypeLibVarFlags FDisplayBind
public TypeLibVarFlags FDefaultBind
public TypeLibVarFlags FHidden
public TypeLibVarFlags FRestricted
public TypeLibVarFlags FDefaultCollelem
public TypeLibVarFlags FUiDefault
public TypeLibVarFlags FNonBrowsable
public TypeLibVarFlags FReplaceable
public TypeLibVarFlags FImmediateBind
}
public System.Runtime.InteropServices.TypeLibVersionAttribute : Attribute {
internal int _major
internal int _minor
public int MajorVersion
public int MinorVersion
public void .ctor(int major, int minor)
public int get_MajorVersion()
public int get_MinorVersion()
}
public System.Runtime.InteropServices.UCOMIBindCtx {
public void RegisterObjectBound(object punk)
public void RevokeObjectBound(object punk)
public void ReleaseBoundObjects()
public void SetBindOptions(BIND_OPTS& pbindopts)
public void GetBindOptions(BIND_OPTS& pbindopts)
public void GetRunningObjectTable(UCOMIRunningObjectTable& pprot)
public void RegisterObjectParam(string pszKey, object punk)
public void GetObjectParam(string pszKey, Object& ppunk)
public void EnumObjectParam(UCOMIEnumString& ppenum)
public void RevokeObjectParam(string pszKey)
}
public System.Runtime.InteropServices.UCOMIConnectionPoint {
public void GetConnectionInterface(Guid& pIID)
public void GetConnectionPointContainer(UCOMIConnectionPointContainer& ppCPC)
public void Advise(object pUnkSink, Int32& pdwCookie)
public void Unadvise(int dwCookie)
public void EnumConnections(UCOMIEnumConnections& ppEnum)
}
public System.Runtime.InteropServices.UCOMIConnectionPointContainer {
public void EnumConnectionPoints(UCOMIEnumConnectionPoints& ppEnum)
public void FindConnectionPoint(Guid& riid, UCOMIConnectionPoint& ppCP)
}
public System.Runtime.InteropServices.UCOMIEnumConnectionPoints {
public int Next(int celt, UCOMIConnectionPoint[] rgelt, Int32& pceltFetched)
public int Skip(int celt)
public int Reset()
public void Clone(UCOMIEnumConnectionPoints& ppenum)
}
public System.Runtime.InteropServices.UCOMIEnumConnections {
public int Next(int celt, CONNECTDATA[] rgelt, Int32& pceltFetched)
public int Skip(int celt)
public void Reset()
public void Clone(UCOMIEnumConnections& ppenum)
}
public System.Runtime.InteropServices.UCOMIEnumMoniker {
public int Next(int celt, UCOMIMoniker[] rgelt, Int32& pceltFetched)
public int Skip(int celt)
public int Reset()
public void Clone(UCOMIEnumMoniker& ppenum)
}
public System.Runtime.InteropServices.UCOMIEnumString {
public int Next(int celt, String[] rgelt, Int32& pceltFetched)
public int Skip(int celt)
public int Reset()
public void Clone(UCOMIEnumString& ppenum)
}
public System.Runtime.InteropServices.UCOMIEnumVARIANT {
public int Next(int celt, int rgvar, int pceltFetched)
public int Skip(int celt)
public int Reset()
public void Clone(int ppenum)
}
public System.Runtime.InteropServices.UCOMIMoniker {
public void GetClassID(Guid& pClassID)
public int IsDirty()
public void Load(UCOMIStream pStm)
public void Save(UCOMIStream pStm, bool fClearDirty)
public void GetSizeMax(Int64& pcbSize)
public void BindToObject(UCOMIBindCtx pbc, UCOMIMoniker pmkToLeft, Guid& riidResult, Object& ppvResult)
public void BindToStorage(UCOMIBindCtx pbc, UCOMIMoniker pmkToLeft, Guid& riid, Object& ppvObj)
public void Reduce(UCOMIBindCtx pbc, int dwReduceHowFar, UCOMIMoniker& ppmkToLeft, UCOMIMoniker& ppmkReduced)
public void ComposeWith(UCOMIMoniker pmkRight, bool fOnlyIfNotGeneric, UCOMIMoniker& ppmkComposite)
public void Enum(bool fForward, UCOMIEnumMoniker& ppenumMoniker)
public void IsEqual(UCOMIMoniker pmkOtherMoniker)
public void Hash(Int32& pdwHash)
public void IsRunning(UCOMIBindCtx pbc, UCOMIMoniker pmkToLeft, UCOMIMoniker pmkNewlyRunning)
public void GetTimeOfLastChange(UCOMIBindCtx pbc, UCOMIMoniker pmkToLeft, FILETIME& pFileTime)
public void Inverse(UCOMIMoniker& ppmk)
public void CommonPrefixWith(UCOMIMoniker pmkOther, UCOMIMoniker& ppmkPrefix)
public void RelativePathTo(UCOMIMoniker pmkOther, UCOMIMoniker& ppmkRelPath)
public void GetDisplayName(UCOMIBindCtx pbc, UCOMIMoniker pmkToLeft, String& ppszDisplayName)
public void ParseDisplayName(UCOMIBindCtx pbc, UCOMIMoniker pmkToLeft, string pszDisplayName, Int32& pchEaten, UCOMIMoniker& ppmkOut)
public void IsSystemMoniker(Int32& pdwMksys)
}
public System.Runtime.InteropServices.UCOMIPersistFile {
public void GetClassID(Guid& pClassID)
public int IsDirty()
public void Load(string pszFileName, int dwMode)
public void Save(string pszFileName, bool fRemember)
public void SaveCompleted(string pszFileName)
public void GetCurFile(String& ppszFileName)
}
public System.Runtime.InteropServices.UCOMIRunningObjectTable {
public void Register(int grfFlags, object punkObject, UCOMIMoniker pmkObjectName, Int32& pdwRegister)
public void Revoke(int dwRegister)
public void IsRunning(UCOMIMoniker pmkObjectName)
public void GetObject(UCOMIMoniker pmkObjectName, Object& ppunkObject)
public void NoteChangeTime(int dwRegister, FILETIME& pfiletime)
public void GetTimeOfLastChange(UCOMIMoniker pmkObjectName, FILETIME& pfiletime)
public void EnumRunning(UCOMIEnumMoniker& ppenumMoniker)
}
public System.Runtime.InteropServices.UCOMIStream {
public void Read(Byte[] pv, int cb, IntPtr pcbRead)
public void Write(Byte[] pv, int cb, IntPtr pcbWritten)
public void Seek(long dlibMove, int dwOrigin, IntPtr plibNewPosition)
public void SetSize(long libNewSize)
public void CopyTo(UCOMIStream pstm, long cb, IntPtr pcbRead, IntPtr pcbWritten)
public void Commit(int grfCommitFlags)
public void Revert()
public void LockRegion(long libOffset, long cb, int dwLockType)
public void UnlockRegion(long libOffset, long cb, int dwLockType)
public void Stat(STATSTG& pstatstg, int grfStatFlag)
public void Clone(UCOMIStream& ppstm)
}
public System.Runtime.InteropServices.UCOMITypeComp {
public void Bind(string szName, int lHashVal, short wFlags, UCOMITypeInfo& ppTInfo, DESCKIND& pDescKind, BINDPTR& pBindPtr)
public void BindType(string szName, int lHashVal, UCOMITypeInfo& ppTInfo, UCOMITypeComp& ppTComp)
}
public System.Runtime.InteropServices.UCOMITypeInfo {
public void GetTypeAttr(IntPtr& ppTypeAttr)
public void GetTypeComp(UCOMITypeComp& ppTComp)
public void GetFuncDesc(int index, IntPtr& ppFuncDesc)
public void GetVarDesc(int index, IntPtr& ppVarDesc)
public void GetNames(int memid, String[] rgBstrNames, int cMaxNames, Int32& pcNames)
public void GetRefTypeOfImplType(int index, Int32& href)
public void GetImplTypeFlags(int index, Int32& pImplTypeFlags)
public void GetIDsOfNames(String[] rgszNames, int cNames, Int32[] pMemId)
public void Invoke(object pvInstance, int memid, short wFlags, DISPPARAMS& pDispParams, Object& pVarResult, EXCEPINFO& pExcepInfo, Int32& puArgErr)
public void GetDocumentation(int index, String& strName, String& strDocString, Int32& dwHelpContext, String& strHelpFile)
public void GetDllEntry(int memid, INVOKEKIND invKind, String& pBstrDllName, String& pBstrName, Int16& pwOrdinal)
public void GetRefTypeInfo(int hRef, UCOMITypeInfo& ppTI)
public void AddressOfMember(int memid, INVOKEKIND invKind, IntPtr& ppv)
public void CreateInstance(object pUnkOuter, Guid& riid, Object& ppvObj)
public void GetMops(int memid, String& pBstrMops)
public void GetContainingTypeLib(UCOMITypeLib& ppTLB, Int32& pIndex)
public void ReleaseTypeAttr(IntPtr pTypeAttr)
public void ReleaseFuncDesc(IntPtr pFuncDesc)
public void ReleaseVarDesc(IntPtr pVarDesc)
}
public System.Runtime.InteropServices.UCOMITypeLib {
public int GetTypeInfoCount()
public void GetTypeInfo(int index, UCOMITypeInfo& ppTI)
public void GetTypeInfoType(int index, TYPEKIND& pTKind)
public void GetTypeInfoOfGuid(Guid& guid, UCOMITypeInfo& ppTInfo)
public void GetLibAttr(IntPtr& ppTLibAttr)
public void GetTypeComp(UCOMITypeComp& ppTComp)
public void GetDocumentation(int index, String& strName, String& strDocString, Int32& dwHelpContext, String& strHelpFile)
public bool IsName(string szNameBuf, int lHashVal)
public void FindName(string szNameBuf, int lHashVal, UCOMITypeInfo[] ppTInfo, Int32[] rgMemId, Int16& pcFound)
public void ReleaseTLibAttr(IntPtr pTLibAttr)
}
public System.Runtime.InteropServices.UnknownWrapper : object {
private object m_WrappedObject
public object WrappedObject
public void .ctor(object obj)
public object get_WrappedObject()
}
public System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute : Attribute {
private CallingConvention m_callingConvention
public CharSet CharSet
public bool BestFitMapping
public bool ThrowOnUnmappableChar
public bool SetLastError
public CallingConvention CallingConvention
public void .ctor(CallingConvention callingConvention)
public CallingConvention get_CallingConvention()
}
public System.Runtime.InteropServices.UnmanagedType : Enum {
public int value__
public UnmanagedType Bool
public UnmanagedType I1
public UnmanagedType U1
public UnmanagedType I2
public UnmanagedType U2
public UnmanagedType I4
public UnmanagedType U4
public UnmanagedType I8
public UnmanagedType U8
public UnmanagedType R4
public UnmanagedType R8
public UnmanagedType Currency
public UnmanagedType BStr
public UnmanagedType LPStr
public UnmanagedType LPWStr
public UnmanagedType LPTStr
public UnmanagedType ByValTStr
public UnmanagedType IUnknown
public UnmanagedType IDispatch
public UnmanagedType Struct
public UnmanagedType Interface
public UnmanagedType SafeArray
public UnmanagedType ByValArray
public UnmanagedType SysInt
public UnmanagedType SysUInt
public UnmanagedType VBByRefStr
public UnmanagedType AnsiBStr
public UnmanagedType TBStr
public UnmanagedType VariantBool
public UnmanagedType FunctionPtr
public UnmanagedType AsAny
public UnmanagedType LPArray
public UnmanagedType LPStruct
public UnmanagedType CustomMarshaler
public UnmanagedType Error
public UnmanagedType IInspectable
public UnmanagedType HString
public UnmanagedType LPUTF8Str
}
public System.Runtime.InteropServices.VARDESC : ValueType {
public int memid
public string lpstrSchema
public ELEMDESC elemdescVar
public short wVarFlags
public VarEnum varkind
}
public System.Runtime.InteropServices.VarEnum : Enum {
public int value__
public VarEnum VT_EMPTY
public VarEnum VT_NULL
public VarEnum VT_I2
public VarEnum VT_I4
public VarEnum VT_R4
public VarEnum VT_R8
public VarEnum VT_CY
public VarEnum VT_DATE
public VarEnum VT_BSTR
public VarEnum VT_DISPATCH
public VarEnum VT_ERROR
public VarEnum VT_BOOL
public VarEnum VT_VARIANT
public VarEnum VT_UNKNOWN
public VarEnum VT_DECIMAL
public VarEnum VT_I1
public VarEnum VT_UI1
public VarEnum VT_UI2
public VarEnum VT_UI4
public VarEnum VT_I8
public VarEnum VT_UI8
public VarEnum VT_INT
public VarEnum VT_UINT
public VarEnum VT_VOID
public VarEnum VT_HRESULT
public VarEnum VT_PTR
public VarEnum VT_SAFEARRAY
public VarEnum VT_CARRAY
public VarEnum VT_USERDEFINED
public VarEnum VT_LPSTR
public VarEnum VT_LPWSTR
public VarEnum VT_RECORD
public VarEnum VT_FILETIME
public VarEnum VT_BLOB
public VarEnum VT_STREAM
public VarEnum VT_STORAGE
public VarEnum VT_STREAMED_OBJECT
public VarEnum VT_STORED_OBJECT
public VarEnum VT_BLOB_OBJECT
public VarEnum VT_CF
public VarEnum VT_CLSID
public VarEnum VT_VECTOR
public VarEnum VT_ARRAY
public VarEnum VT_BYREF
}
public System.Runtime.InteropServices.VARFLAGS : Enum {
public short value__
public VARFLAGS VARFLAG_FREADONLY
public VARFLAGS VARFLAG_FSOURCE
public VARFLAGS VARFLAG_FBINDABLE
public VARFLAGS VARFLAG_FREQUESTEDIT
public VARFLAGS VARFLAG_FDISPLAYBIND
public VARFLAGS VARFLAG_FDEFAULTBIND
public VARFLAGS VARFLAG_FHIDDEN
public VARFLAGS VARFLAG_FRESTRICTED
public VARFLAGS VARFLAG_FDEFAULTCOLLELEM
public VARFLAGS VARFLAG_FUIDEFAULT
public VARFLAGS VARFLAG_FNONBROWSABLE
public VARFLAGS VARFLAG_FREPLACEABLE
public VARFLAGS VARFLAG_FIMMEDIATEBIND
}
public System.Runtime.InteropServices.VariantWrapper : object {
private object m_WrappedObject
public object WrappedObject
public void .ctor(object obj)
public object get_WrappedObject()
}
public System.Runtime.InteropServices.WindowsRuntime.DefaultInterfaceAttribute : Attribute {
private Type m_defaultInterface
public Type DefaultInterface
public void .ctor(Type defaultInterface)
public Type get_DefaultInterface()
}
public System.Runtime.InteropServices.WindowsRuntime.DesignerNamespaceResolveEventArgs : EventArgs {
private string <NamespaceName>k__BackingField
private Collection`1<string> <ResolvedAssemblyFiles>k__BackingField
public string NamespaceName
public Collection`1<string> ResolvedAssemblyFiles
public void .ctor(string namespaceName)
public string get_NamespaceName()
private void set_NamespaceName(string value)
public Collection`1<string> get_ResolvedAssemblyFiles()
private void set_ResolvedAssemblyFiles(Collection`1<string> value)
}
public System.Runtime.InteropServices.WindowsRuntime.EventRegistrationToken : ValueType {
internal ulong m_value
internal ulong Value
internal void .ctor(ulong value)
internal ulong get_Value()
public bool op_Equality(EventRegistrationToken left, EventRegistrationToken right)
public bool op_Inequality(EventRegistrationToken left, EventRegistrationToken right)
public bool Equals(object obj)
public int GetHashCode()
}
public System.Runtime.InteropServices.WindowsRuntime.EventRegistrationTokenTable`1 : object {
private Dictionary`2<EventRegistrationToken, T> m_tokens
private T modreq(System.Runtime.CompilerServices.IsVolatile) m_invokeList
public T InvocationList
public T get_InvocationList()
public void set_InvocationList(T value)
public EventRegistrationToken AddEventHandler(T handler)
private EventRegistrationToken AddEventHandlerNoLock(T handler)
internal T ExtractHandler(EventRegistrationToken token)
private EventRegistrationToken GetPreferredToken(T handler)
public void RemoveEventHandler(EventRegistrationToken token)
public void RemoveEventHandler(T handler)
private void RemoveEventHandlerNoLock(EventRegistrationToken token)
public EventRegistrationTokenTable`1<T> GetOrCreateEventRegistrationTokenTable(EventRegistrationTokenTable`1& refEventTable)
}
public System.Runtime.InteropServices.WindowsRuntime.IActivationFactory {
public object ActivateInstance()
}
public System.Runtime.InteropServices.WindowsRuntime.InterfaceImplementedInVersionAttribute : Attribute {
private Type m_interfaceType
private byte m_majorVersion
private byte m_minorVersion
private byte m_buildVersion
private byte m_revisionVersion
public Type InterfaceType
public byte MajorVersion
public byte MinorVersion
public byte BuildVersion
public byte RevisionVersion
public void .ctor(Type interfaceType, byte majorVersion, byte minorVersion, byte buildVersion, byte revisionVersion)
public Type get_InterfaceType()
public byte get_MajorVersion()
public byte get_MinorVersion()
public byte get_BuildVersion()
public byte get_RevisionVersion()
}
internal System.Runtime.InteropServices.WindowsRuntime.IRestrictedErrorInfo {
public void GetErrorDetails(String& description, Int32& error, String& restrictedDescription, String& capabilitySid)
public void GetReference(String& reference)
}
public System.Runtime.InteropServices.WindowsRuntime.NamespaceResolveEventArgs : EventArgs {
private string <NamespaceName>k__BackingField
private Assembly <RequestingAssembly>k__BackingField
private Collection`1<Assembly> <ResolvedAssemblies>k__BackingField
public string NamespaceName
public Assembly RequestingAssembly
public Collection`1<Assembly> ResolvedAssemblies
public void .ctor(string namespaceName, Assembly requestingAssembly)
public string get_NamespaceName()
private void set_NamespaceName(string value)
public Assembly get_RequestingAssembly()
private void set_RequestingAssembly(Assembly value)
public Collection`1<Assembly> get_ResolvedAssemblies()
private void set_ResolvedAssemblies(Collection`1<Assembly> value)
}
public System.Runtime.InteropServices.WindowsRuntime.ReturnValueNameAttribute : Attribute {
private string m_Name
public string Name
public void .ctor(string name)
public string get_Name()
}
internal System.Runtime.InteropServices.WindowsRuntime.UnsafeNativeMethods : object {
public int WindowsCreateString(string sourceString, int length, IntPtr* hstring)
public int WindowsDeleteString(IntPtr hstring)
public Char* WindowsGetStringRawBuffer(IntPtr hstring, UInt32* length)
public bool RoOriginateLanguageException(int error, string message, IntPtr languageException)
public void RoReportUnhandledError(IRestrictedErrorInfo error)
public IRestrictedErrorInfo GetRestrictedErrorInfo()
}
public System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeMarshal : object {
private bool s_haveBlueErrorApis
private Guid s_iidIErrorInfo
public void AddEventHandler(Func`2<T, EventRegistrationToken> addMethod, Action`1<EventRegistrationToken> removeMethod, T handler)
public void RemoveEventHandler(Action`1<EventRegistrationToken> removeMethod, T handler)
public void RemoveAllEventHandlers(Action`1<EventRegistrationToken> removeMethod)
internal int GetRegistrationTokenCacheSize()
internal void CallRemoveMethods(Action`1<EventRegistrationToken> removeMethod, List`1<EventRegistrationToken> tokensToRemove)
internal string HStringToString(IntPtr hstring)
internal Exception GetExceptionForHR(int hresult, Exception innerException, string messageResource)
internal Exception GetExceptionForHR(int hresult, Exception innerException)
private bool RoOriginateLanguageException(int error, string message, IntPtr languageException)
private void RoReportUnhandledError(IRestrictedErrorInfo error)
internal bool ReportUnhandledError(Exception e)
public IActivationFactory GetActivationFactory(Type type)
public IntPtr StringToHString(string s)
public string PtrToStringHString(IntPtr ptr)
public void FreeHString(IntPtr ptr)
}
public System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeMetadata : object {
private EventHandler`1<DesignerNamespaceResolveEventArgs> DesignerNamespaceResolve
private EventHandler`1<NamespaceResolveEventArgs> ReflectionOnlyNamespaceResolve
public IEnumerable`1<string> ResolveNamespace(string namespaceName, IEnumerable`1<string> packageGraphFilePaths)
public IEnumerable`1<string> ResolveNamespace(string namespaceName, string windowsSdkFilePath, IEnumerable`1<string> packageGraphFilePaths)
public void add_DesignerNamespaceResolve(EventHandler`1<DesignerNamespaceResolveEventArgs> value)
public void remove_DesignerNamespaceResolve(EventHandler`1<DesignerNamespaceResolveEventArgs> value)
public void add_ReflectionOnlyNamespaceResolve(EventHandler`1<NamespaceResolveEventArgs> value)
public void remove_ReflectionOnlyNamespaceResolve(EventHandler`1<NamespaceResolveEventArgs> value)
}
public System.Runtime.MemoryFailPoint : CriticalFinalizerObject {
public void .ctor(int sizeInMegabytes)
protected void Finalize()
public void Dispose()
}
public System.Runtime.ProfileOptimization : object {
public void SetProfileRoot(string directoryPath)
public void StartProfile(string profile)
}
public System.Runtime.Remoting.ActivatedClientTypeEntry : TypeEntry {
private string applicationUrl
private Type obj_type
public string ApplicationUrl
public IContextAttribute[] ContextAttributes
public Type ObjectType
public void .ctor(Type type, string appUrl)
public void .ctor(string typeName, string assemblyName, string appUrl)
public string get_ApplicationUrl()
public IContextAttribute[] get_ContextAttributes()
public void set_ContextAttributes(IContextAttribute[] value)
public Type get_ObjectType()
public string ToString()
}
public System.Runtime.Remoting.ActivatedServiceTypeEntry : TypeEntry {
private Type obj_type
public IContextAttribute[] ContextAttributes
public Type ObjectType
public void .ctor(Type type)
public void .ctor(string typeName, string assemblyName)
public IContextAttribute[] get_ContextAttributes()
public void set_ContextAttributes(IContextAttribute[] value)
public Type get_ObjectType()
public string ToString()
}
internal System.Runtime.Remoting.Activation.ActivationServices : object {
private IActivator _constructionActivator
private IActivator ConstructionActivator
private IActivator get_ConstructionActivator()
public IMessage Activate(RemotingProxy proxy, ConstructionCall ctorCall)
public IMessage RemoteActivate(IConstructionCallMessage ctorCall)
public object CreateProxyFromAttributes(Type type, Object[] activationAttributes)
public ConstructionCall CreateConstructionCall(Type type, string activationUrl, Object[] activationAttributes)
public IMessage CreateInstanceFromMessage(IConstructionCallMessage ctorCall)
public object CreateProxyForType(Type type)
internal void PushActivationAttributes(Type serverType, Object[] attributes)
internal void PopActivationAttributes(Type serverType)
public object AllocateUninitializedClassInstance(Type type)
public void EnableProxyActivation(Type type, bool enable)
}
public System.Runtime.Remoting.Activation.ActivatorLevel : Enum {
public int value__
public ActivatorLevel Construction
public ActivatorLevel Context
public ActivatorLevel AppDomain
public ActivatorLevel Process
public ActivatorLevel Machine
}
internal System.Runtime.Remoting.Activation.AppDomainLevelActivator : object {
private string _activationUrl
private IActivator _next
public ActivatorLevel Level
public IActivator NextActivator
public void .ctor(string activationUrl, IActivator next)
public ActivatorLevel get_Level()
public IActivator get_NextActivator()
public void set_NextActivator(IActivator value)
public IConstructionReturnMessage Activate(IConstructionCallMessage ctorCall)
}
internal System.Runtime.Remoting.Activation.ConstructionLevelActivator : object {
public ActivatorLevel Level
public IActivator NextActivator
public ActivatorLevel get_Level()
public IActivator get_NextActivator()
public void set_NextActivator(IActivator value)
public IConstructionReturnMessage Activate(IConstructionCallMessage msg)
}
internal System.Runtime.Remoting.Activation.ContextLevelActivator : object {
private IActivator m_NextActivator
public ActivatorLevel Level
public IActivator NextActivator
public void .ctor(IActivator next)
public ActivatorLevel get_Level()
public IActivator get_NextActivator()
public void set_NextActivator(IActivator value)
public IConstructionReturnMessage Activate(IConstructionCallMessage ctorCall)
}
public System.Runtime.Remoting.Activation.IActivator {
public ActivatorLevel Level
public IActivator NextActivator
public ActivatorLevel get_Level()
public IActivator get_NextActivator()
public void set_NextActivator(IActivator value)
public IConstructionReturnMessage Activate(IConstructionCallMessage msg)
}
public System.Runtime.Remoting.Activation.IConstructionCallMessage {
public Type ActivationType
public string ActivationTypeName
public IActivator Activator
public Object[] CallSiteActivationAttributes
public IList ContextProperties
public Type get_ActivationType()
public string get_ActivationTypeName()
public IActivator get_Activator()
public void set_Activator(IActivator value)
public Object[] get_CallSiteActivationAttributes()
public IList get_ContextProperties()
}
internal System.Runtime.Remoting.Activation.RemoteActivationAttribute : Attribute {
private IList _contextProperties
public void .ctor(IList contextProperties)
public bool IsContextOK(Context ctx, IConstructionCallMessage ctor)
public void GetPropertiesForNewContext(IConstructionCallMessage ctor)
}
internal System.Runtime.Remoting.Activation.RemoteActivator : MarshalByRefObject {
public ActivatorLevel Level
public IActivator NextActivator
public IConstructionReturnMessage Activate(IConstructionCallMessage msg)
public object InitializeLifetimeService()
public ActivatorLevel get_Level()
public IActivator get_NextActivator()
public void set_NextActivator(IActivator value)
}
public System.Runtime.Remoting.Activation.UrlAttribute : ContextAttribute {
private string url
public string UrlValue
public void .ctor(string callsiteURL)
public string get_UrlValue()
public bool Equals(object o)
public int GetHashCode()
public void GetPropertiesForNewContext(IConstructionCallMessage ctorMsg)
public bool IsContextOK(Context ctx, IConstructionCallMessage msg)
}
internal System.Runtime.Remoting.ChannelData : object {
internal string Ref
internal string Type
internal string Id
internal string DelayLoadAsClientChannel
private ArrayList _serverProviders
private ArrayList _clientProviders
private Hashtable _customProperties
internal ArrayList ServerProviders
public ArrayList ClientProviders
public Hashtable CustomProperties
internal ArrayList get_ServerProviders()
public ArrayList get_ClientProviders()
public Hashtable get_CustomProperties()
public void CopyFrom(ChannelData other)
}
internal System.Runtime.Remoting.ChannelInfo : object {
private Object[] channelData
public Object[] ChannelData
public void .ctor(object remoteChannelData)
public Object[] get_ChannelData()
public void set_ChannelData(Object[] value)
}
internal System.Runtime.Remoting.Channels.AggregateDictionary : object {
private IDictionary[] dictionaries
private ArrayList _values
private ArrayList _keys
public bool IsFixedSize
public bool IsReadOnly
public object Item
public ICollection Keys
public ICollection Values
public int Count
public bool IsSynchronized
public object SyncRoot
public void .ctor(IDictionary[] dics)
public bool get_IsFixedSize()
public bool get_IsReadOnly()
public object get_Item(object key)
public void set_Item(object key, object value)
public ICollection get_Keys()
public ICollection get_Values()
public void Add(object key, object value)
public void Clear()
public bool Contains(object ob)
public IDictionaryEnumerator GetEnumerator()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
public void Remove(object ob)
public void CopyTo(Array array, int index)
public int get_Count()
public bool get_IsSynchronized()
public object get_SyncRoot()
}
internal System.Runtime.Remoting.Channels.AggregateEnumerator : object {
private IDictionary[] dictionaries
private int pos
private IDictionaryEnumerator currente
public DictionaryEntry Entry
public object Key
public object Value
public object Current
public void .ctor(IDictionary[] dics)
public DictionaryEntry get_Entry()
public object get_Key()
public object get_Value()
public object get_Current()
public bool MoveNext()
public void Reset()
}
internal System.Runtime.Remoting.Channels.AsyncRequest : object {
internal IMessageSink ReplySink
internal IMessage MsgRequest
public void .ctor(IMessage msgRequest, IMessageSink replySink)
}
public System.Runtime.Remoting.Channels.BaseChannelObjectWithProperties : object {
private Hashtable table
public int Count
public bool IsFixedSize
public bool IsReadOnly
public bool IsSynchronized
public object Item
public ICollection Keys
public IDictionary Properties
public object SyncRoot
public ICollection Values
public int get_Count()
public bool get_IsFixedSize()
public bool get_IsReadOnly()
public bool get_IsSynchronized()
public object get_Item(object key)
public void set_Item(object key, object value)
public ICollection get_Keys()
public IDictionary get_Properties()
public object get_SyncRoot()
public ICollection get_Values()
public void Add(object key, object value)
public void Clear()
public bool Contains(object key)
public void CopyTo(Array array, int index)
public IDictionaryEnumerator GetEnumerator()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
public void Remove(object key)
}
public System.Runtime.Remoting.Channels.BaseChannelWithProperties : BaseChannelObjectWithProperties {
protected IChannelSinkBase SinksWithProperties
public IDictionary Properties
public IDictionary get_Properties()
}
internal System.Runtime.Remoting.Channels.CADSerializer : object {
internal IMessage DeserializeMessage(MemoryStream mem, IMethodCallMessage msg)
internal MemoryStream SerializeMessage(IMessage msg)
internal object DeserializeObjectSafe(Byte[] mem)
internal MemoryStream SerializeObject(object obj)
internal object DeserializeObject(MemoryStream mem)
}
internal System.Runtime.Remoting.Channels.ChanelSinkStackEntry : object {
public IChannelSinkBase Sink
public object State
public ChanelSinkStackEntry Next
public void .ctor(IChannelSinkBase sink, object state, ChanelSinkStackEntry next)
}
public System.Runtime.Remoting.Channels.ChannelDataStore : object {
private String[] _channelURIs
private DictionaryEntry[] _extraData
public String[] ChannelUris
public object Item
public void .ctor(String[] channelURIs)
public String[] get_ChannelUris()
public void set_ChannelUris(String[] value)
public object get_Item(object key)
public void set_Item(object key, object value)
}
public System.Runtime.Remoting.Channels.ChannelServices : object {
private ArrayList registeredChannels
private ArrayList delayedClientChannels
private CrossContextChannel _crossContextSink
internal string CrossContextUrl
private IList oldStartModeTypes
internal CrossContextChannel CrossContextChannel
public IChannel[] RegisteredChannels
internal CrossContextChannel get_CrossContextChannel()
internal IMessageSink CreateClientChannelSinkChain(string url, object remoteChannelData, String& objectUri)
internal IMessageSink CreateClientChannelSinkChain(IChannelSender sender, string url, Object[] channelDataArray, String& objectUri)
public IChannel[] get_RegisteredChannels()
public IServerChannelSink CreateServerChannelSinkChain(IServerChannelSinkProvider provider, IChannelReceiver channel)
public ServerProcessing DispatchMessage(IServerChannelSinkStack sinkStack, IMessage msg, IMessage& replyMsg)
public IChannel GetChannel(string name)
public IDictionary GetChannelSinkProperties(object obj)
public String[] GetUrlsForObject(MarshalByRefObject obj)
public void RegisterChannel(IChannel chnl)
public void RegisterChannel(IChannel chnl, bool ensureSecurity)
internal void RegisterChannelConfig(ChannelData channel)
private object CreateProvider(ProviderData prov)
public IMessage SyncDispatchMessage(IMessage msg)
public IMessageCtrl AsyncDispatchMessage(IMessage msg, IMessageSink replySink)
private ReturnMessage CheckIncomingMessage(IMessage msg)
internal IMessage CheckReturnMessage(IMessage callMsg, IMessage retMsg)
private bool IsLocalCall(IMessage callMsg)
public void UnregisterChannel(IChannel chnl)
internal Object[] GetCurrentChannelInfo()
}
public System.Runtime.Remoting.Channels.ClientChannelSinkStack : object {
private IMessageSink _replySink
private ChanelSinkStackEntry _sinkStack
public void .ctor(IMessageSink replySink)
public void AsyncProcessResponse(ITransportHeaders headers, Stream stream)
public void DispatchException(Exception e)
public void DispatchReplyMessage(IMessage msg)
public object Pop(IClientChannelSink sink)
public void Push(IClientChannelSink sink, object state)
}
internal System.Runtime.Remoting.Channels.CrossAppDomainChannel : object {
private string _strName
private object s_lock
public string ChannelName
public int ChannelPriority
public object ChannelData
internal void RegisterCrossAppDomainChannel()
public string get_ChannelName()
public int get_ChannelPriority()
public string Parse(string url, String& objectURI)
public object get_ChannelData()
public String[] GetUrlsForUri(string objectURI)
public void StartListening(object data)
public void StopListening(object data)
public IMessageSink CreateMessageSink(string url, object data, String& uri)
}
internal System.Runtime.Remoting.Channels.CrossAppDomainData : object {
private object _ContextID
private int _DomainID
private string _processGuid
internal int DomainID
internal string ProcessID
internal void .ctor(int domainId)
internal int get_DomainID()
internal string get_ProcessID()
}
internal System.Runtime.Remoting.Channels.CrossAppDomainSink : object {
private Hashtable s_sinks
private MethodInfo processMessageMethod
private int _domainID
internal int TargetDomainId
public IMessageSink NextSink
internal void .ctor(int domainID)
internal CrossAppDomainSink GetSink(int domainID)
internal int get_TargetDomainId()
private ProcessMessageRes ProcessMessageInDomain(Byte[] arrRequest, CADMethodCallMessage cadMsg)
public IMessage SyncProcessMessage(IMessage msgRequest)
public IMessageCtrl AsyncProcessMessage(IMessage reqMsg, IMessageSink replySink)
public void SendAsyncMessage(object data)
public IMessageSink get_NextSink()
private void <AsyncProcessMessage>b__10_0(object data)
}
internal System.Runtime.Remoting.Channels.ExceptionFilterSink : object {
private IMessageSink _next
private IMessage _call
public IMessageSink NextSink
public void .ctor(IMessage call, IMessageSink next)
public IMessage SyncProcessMessage(IMessage msg)
public IMessageCtrl AsyncProcessMessage(IMessage msg, IMessageSink replySink)
public IMessageSink get_NextSink()
}
public System.Runtime.Remoting.Channels.IChannel {
public string ChannelName
public int ChannelPriority
public string get_ChannelName()
public int get_ChannelPriority()
public string Parse(string url, String& objectURI)
}
public System.Runtime.Remoting.Channels.IChannelDataStore {
public String[] ChannelUris
public object Item
public String[] get_ChannelUris()
public object get_Item(object key)
public void set_Item(object key, object value)
}
public System.Runtime.Remoting.Channels.IChannelReceiver {
public object ChannelData
public object get_ChannelData()
public String[] GetUrlsForUri(string objectURI)
public void StartListening(object data)
public void StopListening(object data)
}
public System.Runtime.Remoting.Channels.IChannelReceiverHook {
public string ChannelScheme
public IServerChannelSink ChannelSinkChain
public bool WantsToListen
public string get_ChannelScheme()
public IServerChannelSink get_ChannelSinkChain()
public bool get_WantsToListen()
public void AddHookChannelUri(string channelUri)
}
public System.Runtime.Remoting.Channels.IChannelSender {
public IMessageSink CreateMessageSink(string url, object remoteChannelData, String& objectURI)
}
public System.Runtime.Remoting.Channels.IChannelSinkBase {
public IDictionary Properties
public IDictionary get_Properties()
}
public System.Runtime.Remoting.Channels.IClientChannelSink {
public IClientChannelSink NextChannelSink
public IClientChannelSink get_NextChannelSink()
public void AsyncProcessRequest(IClientChannelSinkStack sinkStack, IMessage msg, ITransportHeaders headers, Stream stream)
public void AsyncProcessResponse(IClientResponseChannelSinkStack sinkStack, object state, ITransportHeaders headers, Stream stream)
public Stream GetRequestStream(IMessage msg, ITransportHeaders headers)
public void ProcessMessage(IMessage msg, ITransportHeaders requestHeaders, Stream requestStream, ITransportHeaders& responseHeaders, Stream& responseStream)
}
public System.Runtime.Remoting.Channels.IClientChannelSinkProvider {
public IClientChannelSinkProvider Next
public IClientChannelSinkProvider get_Next()
public void set_Next(IClientChannelSinkProvider value)
public IClientChannelSink CreateSink(IChannelSender channel, string url, object remoteChannelData)
}
public System.Runtime.Remoting.Channels.IClientChannelSinkStack {
public object Pop(IClientChannelSink sink)
public void Push(IClientChannelSink sink, object state)
}
public System.Runtime.Remoting.Channels.IClientResponseChannelSinkStack {
public void AsyncProcessResponse(ITransportHeaders headers, Stream stream)
public void DispatchException(Exception e)
public void DispatchReplyMessage(IMessage msg)
}
public System.Runtime.Remoting.Channels.ISecurableChannel {
public bool IsSecured
public bool get_IsSecured()
public void set_IsSecured(bool value)
}
public System.Runtime.Remoting.Channels.IServerChannelSink {
public IServerChannelSink NextChannelSink
public IServerChannelSink get_NextChannelSink()
public void AsyncProcessResponse(IServerResponseChannelSinkStack sinkStack, object state, IMessage msg, ITransportHeaders headers, Stream stream)
public Stream GetResponseStream(IServerResponseChannelSinkStack sinkStack, object state, IMessage msg, ITransportHeaders headers)
public ServerProcessing ProcessMessage(IServerChannelSinkStack sinkStack, IMessage requestMsg, ITransportHeaders requestHeaders, Stream requestStream, IMessage& responseMsg, ITransportHeaders& responseHeaders, Stream& responseStream)
}
public System.Runtime.Remoting.Channels.IServerChannelSinkProvider {
public IServerChannelSinkProvider Next
public IServerChannelSinkProvider get_Next()
public void set_Next(IServerChannelSinkProvider value)
public IServerChannelSink CreateSink(IChannelReceiver channel)
public void GetChannelData(IChannelDataStore channelData)
}
public System.Runtime.Remoting.Channels.IServerChannelSinkStack {
public object Pop(IServerChannelSink sink)
public void Push(IServerChannelSink sink, object state)
public void ServerCallback(IAsyncResult ar)
public void Store(IServerChannelSink sink, object state)
public void StoreAndDispatch(IServerChannelSink sink, object state)
}
public System.Runtime.Remoting.Channels.IServerResponseChannelSinkStack {
public void AsyncProcessResponse(IMessage msg, ITransportHeaders headers, Stream stream)
public Stream GetResponseStream(IMessage msg, ITransportHeaders headers)
}
public System.Runtime.Remoting.Channels.ITransportHeaders {
public object Item
public object get_Item(object key)
public void set_Item(object key, object value)
public IEnumerator GetEnumerator()
}
public System.Runtime.Remoting.Channels.ServerChannelSinkStack : object {
private ChanelSinkStackEntry _sinkStack
public Stream GetResponseStream(IMessage msg, ITransportHeaders headers)
public object Pop(IServerChannelSink sink)
public void Push(IServerChannelSink sink, object state)
public void ServerCallback(IAsyncResult ar)
public void Store(IServerChannelSink sink, object state)
public void StoreAndDispatch(IServerChannelSink sink, object state)
public void AsyncProcessResponse(IMessage msg, ITransportHeaders headers, Stream stream)
}
internal System.Runtime.Remoting.Channels.ServerDispatchSink : object {
public IServerChannelSink NextChannelSink
public IDictionary Properties
public IServerChannelSink get_NextChannelSink()
public IDictionary get_Properties()
public void AsyncProcessResponse(IServerResponseChannelSinkStack sinkStack, object state, IMessage msg, ITransportHeaders headers, Stream stream)
public Stream GetResponseStream(IServerResponseChannelSinkStack sinkStack, object state, IMessage msg, ITransportHeaders headers)
public ServerProcessing ProcessMessage(IServerChannelSinkStack sinkStack, IMessage requestMsg, ITransportHeaders requestHeaders, Stream requestStream, IMessage& responseMsg, ITransportHeaders& responseHeaders, Stream& responseStream)
}
internal System.Runtime.Remoting.Channels.ServerDispatchSinkProvider : object {
public IServerChannelSinkProvider Next
public void .ctor(IDictionary properties, ICollection providerData)
public IServerChannelSinkProvider get_Next()
public void set_Next(IServerChannelSinkProvider value)
public IServerChannelSink CreateSink(IChannelReceiver channel)
public void GetChannelData(IChannelDataStore channelData)
}
public System.Runtime.Remoting.Channels.ServerProcessing : Enum {
public int value__
public ServerProcessing Complete
public ServerProcessing OneWay
public ServerProcessing Async
}
public System.Runtime.Remoting.Channels.SinkProviderData : object {
private string sinkName
private ArrayList children
private Hashtable properties
public IList Children
public string Name
public IDictionary Properties
public void .ctor(string name)
public IList get_Children()
public string get_Name()
public IDictionary get_Properties()
}
public System.Runtime.Remoting.Channels.TransportHeaders : object {
private Hashtable hash_table
public object Item
public object get_Item(object key)
public void set_Item(object key, object value)
public IEnumerator GetEnumerator()
}
internal System.Runtime.Remoting.ClientActivatedIdentity : ServerIdentity {
private MarshalByRefObject _targetThis
public void .ctor(string objectUri, Type objectType)
public MarshalByRefObject GetServerObject()
public MarshalByRefObject GetClientProxy()
public void SetClientProxy(MarshalByRefObject obj)
public void OnLifetimeExpired()
public IMessage SyncObjectProcessMessage(IMessage msg)
public IMessageCtrl AsyncObjectProcessMessage(IMessage msg, IMessageSink replySink)
}
internal System.Runtime.Remoting.ClientIdentity : Identity {
private WeakReference _proxyReference
public MarshalByRefObject ClientProxy
public string TargetUri
public void .ctor(string objectUri, ObjRef objRef)
public MarshalByRefObject get_ClientProxy()
public void set_ClientProxy(MarshalByRefObject value)
public ObjRef CreateObjRef(Type requestedType)
public string get_TargetUri()
}
internal System.Runtime.Remoting.ConfigHandler : object {
private ArrayList typeEntries
private ArrayList channelInstances
private ChannelData currentChannel
private Stack currentProviderData
private string currentClientUrl
private string appName
private string currentXmlPath
private bool onlyDelayedChannels
public void .ctor(bool onlyDelayedChannels)
private void ValidatePath(string element, String[] paths)
private bool CheckPath(string path)
public void OnStartParsing(SmallXmlParser parser)
public void OnProcessingInstruction(string name, string text)
public void OnIgnorableWhitespace(string s)
public void OnStartElement(string name, IAttrList attrs)
public void ParseElement(string name, IAttrList attrs)
public void OnEndElement(string name)
private void ReadCustomProviderData(string name, IAttrList attrs)
private void ReadLifetine(IAttrList attrs)
private TimeSpan ParseTime(string s)
private void ReadChannel(IAttrList attrs, bool isTemplate)
private ProviderData ReadProvider(string name, IAttrList attrs, bool isTemplate)
private void ReadClientActivated(IAttrList attrs)
private void ReadServiceActivated(IAttrList attrs)
private void ReadClientWellKnown(IAttrList attrs)
private void ReadServiceWellKnown(IAttrList attrs)
private void ReadInteropXml(IAttrList attrs, bool isElement)
private void ReadPreload(IAttrList attrs)
private string GetNotNull(IAttrList attrs, string name)
private string ExtractAssembly(String& type)
public void OnChars(string ch)
public void OnEndParsing(SmallXmlParser parser)
}
public System.Runtime.Remoting.Contexts.Context : object {
private int domain_id
private int context_id
private UIntPtr static_data
private UIntPtr data
private Object[] local_slots
private IMessageSink default_server_context_sink
private IMessageSink server_context_sink_chain
private IMessageSink client_context_sink_chain
private List`1<IContextProperty> context_properties
private int global_count
private LocalDataStoreHolder modreq(System.Runtime.CompilerServices.IsVolatile) _localDataStore
private LocalDataStoreMgr _localDataStoreMgr
private DynamicPropertyCollection global_dynamic_properties
private DynamicPropertyCollection context_dynamic_properties
private ContextCallbackObject callback_object
public Context DefaultContext
public int ContextID
public IContextProperty[] ContextProperties
internal bool IsDefaultContext
internal bool NeedsContextSink
internal bool HasGlobalDynamicSinks
internal bool HasDynamicSinks
internal bool HasExitSinks
private LocalDataStore MyLocalStore
private void RegisterContext(Context ctx)
private void ReleaseContext(Context ctx)
protected void Finalize()
public Context get_DefaultContext()
public int get_ContextID()
public IContextProperty[] get_ContextProperties()
internal bool get_IsDefaultContext()
internal bool get_NeedsContextSink()
public bool RegisterDynamicProperty(IDynamicProperty prop, ContextBoundObject obj, Context ctx)
public bool UnregisterDynamicProperty(string name, ContextBoundObject obj, Context ctx)
private DynamicPropertyCollection GetDynamicPropertyCollection(ContextBoundObject obj, Context ctx)
internal void NotifyGlobalDynamicSinks(bool start, IMessage req_msg, bool client_site, bool async)
internal bool get_HasGlobalDynamicSinks()
internal void NotifyDynamicSinks(bool start, IMessage req_msg, bool client_site, bool async)
internal bool get_HasDynamicSinks()
internal bool get_HasExitSinks()
public IContextProperty GetProperty(string name)
public void SetProperty(IContextProperty prop)
public void Freeze()
public string ToString()
internal IMessageSink GetServerContextSinkChain()
internal IMessageSink GetClientContextSinkChain()
internal IMessageSink CreateServerObjectSinkChain(MarshalByRefObject obj, bool forceInternalExecute)
internal IMessageSink CreateEnvoySink(MarshalByRefObject serverObject)
internal Context SwitchToContext(Context newContext)
internal Context CreateNewContext(IConstructionCallMessage msg)
public void DoCallBack(CrossContextDelegate deleg)
private LocalDataStore get_MyLocalStore()
public LocalDataStoreSlot AllocateDataSlot()
public LocalDataStoreSlot AllocateNamedDataSlot(string name)
public void FreeNamedDataSlot(string name)
public LocalDataStoreSlot GetNamedDataSlot(string name)
public object GetData(LocalDataStoreSlot slot)
public void SetData(LocalDataStoreSlot slot, object data)
}
public System.Runtime.Remoting.Contexts.ContextAttribute : Attribute {
protected string AttributeName
public string Name
public void .ctor(string name)
public string get_Name()
public bool Equals(object o)
public void Freeze(Context newContext)
public int GetHashCode()
public void GetPropertiesForNewContext(IConstructionCallMessage ctorMsg)
public bool IsContextOK(Context ctx, IConstructionCallMessage ctorMsg)
public bool IsNewContextOK(Context newCtx)
}
internal System.Runtime.Remoting.Contexts.ContextCallbackObject : ContextBoundObject {
public void DoCallBack(CrossContextDelegate deleg)
}
public System.Runtime.Remoting.Contexts.ContextProperty : object {
private string name
private object prop
public string Name
public object Property
private void .ctor(string name, object prop)
public string get_Name()
public object get_Property()
}
internal System.Runtime.Remoting.Contexts.CrossContextChannel : object {
public IMessageSink NextSink
public IMessage SyncProcessMessage(IMessage msg)
public IMessageCtrl AsyncProcessMessage(IMessage msg, IMessageSink replySink)
public IMessageSink get_NextSink()
}
public System.Runtime.Remoting.Contexts.CrossContextDelegate : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke()
public IAsyncResult BeginInvoke(AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
internal System.Runtime.Remoting.Contexts.DynamicPropertyCollection : object {
private ArrayList _properties
public bool HasProperties
public bool get_HasProperties()
public bool RegisterDynamicProperty(IDynamicProperty prop)
public bool UnregisterDynamicProperty(string name)
public void NotifyMessage(bool start, IMessage msg, bool client_site, bool async)
private int FindProperty(string name)
}
public System.Runtime.Remoting.Contexts.IContextAttribute {
public void GetPropertiesForNewContext(IConstructionCallMessage msg)
public bool IsContextOK(Context ctx, IConstructionCallMessage msg)
}
public System.Runtime.Remoting.Contexts.IContextProperty {
public string Name
public string get_Name()
public void Freeze(Context newContext)
public bool IsNewContextOK(Context newCtx)
}
public System.Runtime.Remoting.Contexts.IContextPropertyActivator {
public void CollectFromClientContext(IConstructionCallMessage msg)
public void CollectFromServerContext(IConstructionReturnMessage msg)
public bool DeliverClientContextToServerContext(IConstructionCallMessage msg)
public bool DeliverServerContextToClientContext(IConstructionReturnMessage msg)
public bool IsOKToActivate(IConstructionCallMessage msg)
}
public System.Runtime.Remoting.Contexts.IContributeClientContextSink {
public IMessageSink GetClientContextSink(IMessageSink nextSink)
}
public System.Runtime.Remoting.Contexts.IContributeDynamicSink {
public IDynamicMessageSink GetDynamicSink()
}
public System.Runtime.Remoting.Contexts.IContributeEnvoySink {
public IMessageSink GetEnvoySink(MarshalByRefObject obj, IMessageSink nextSink)
}
public System.Runtime.Remoting.Contexts.IContributeObjectSink {
public IMessageSink GetObjectSink(MarshalByRefObject obj, IMessageSink nextSink)
}
public System.Runtime.Remoting.Contexts.IContributeServerContextSink {
public IMessageSink GetServerContextSink(IMessageSink nextSink)
}
public System.Runtime.Remoting.Contexts.IDynamicMessageSink {
public void ProcessMessageFinish(IMessage replyMsg, bool bCliSide, bool bAsync)
public void ProcessMessageStart(IMessage reqMsg, bool bCliSide, bool bAsync)
}
public System.Runtime.Remoting.Contexts.IDynamicProperty {
public string Name
public string get_Name()
}
public System.Runtime.Remoting.Contexts.SynchronizationAttribute : ContextAttribute {
public int NOT_SUPPORTED
public int SUPPORTED
public int REQUIRED
public int REQUIRES_NEW
private bool _bReEntrant
private int _flavor
private int _lockCount
private Mutex _mutex
private Thread _ownerThread
public bool IsReEntrant
public bool Locked
public void .ctor(bool reEntrant)
public void .ctor(int flag)
public void .ctor(int flag, bool reEntrant)
public bool get_IsReEntrant()
public bool get_Locked()
public void set_Locked(bool value)
internal void AcquireLock()
internal void ReleaseLock()
public void GetPropertiesForNewContext(IConstructionCallMessage ctorMsg)
public IMessageSink GetClientContextSink(IMessageSink nextSink)
public IMessageSink GetServerContextSink(IMessageSink nextSink)
public bool IsContextOK(Context ctx, IConstructionCallMessage msg)
internal void ExitContext()
internal void EnterContext()
}
internal System.Runtime.Remoting.Contexts.SynchronizedClientContextSink : object {
private IMessageSink _next
private SynchronizationAttribute _att
public IMessageSink NextSink
public void .ctor(IMessageSink next, SynchronizationAttribute att)
public IMessageSink get_NextSink()
public IMessageCtrl AsyncProcessMessage(IMessage msg, IMessageSink replySink)
public IMessage SyncProcessMessage(IMessage msg)
}
internal System.Runtime.Remoting.Contexts.SynchronizedContextReplySink : object {
private IMessageSink _next
private bool _newLock
private SynchronizationAttribute _att
public IMessageSink NextSink
public void .ctor(IMessageSink next, SynchronizationAttribute att, bool newLock)
public IMessageSink get_NextSink()
public IMessageCtrl AsyncProcessMessage(IMessage msg, IMessageSink replySink)
public IMessage SyncProcessMessage(IMessage msg)
}
internal System.Runtime.Remoting.Contexts.SynchronizedServerContextSink : object {
private IMessageSink _next
private SynchronizationAttribute _att
public IMessageSink NextSink
public void .ctor(IMessageSink next, SynchronizationAttribute att)
public IMessageSink get_NextSink()
public IMessageCtrl AsyncProcessMessage(IMessage msg, IMessageSink replySink)
public IMessage SyncProcessMessage(IMessage msg)
}
public System.Runtime.Remoting.CustomErrorsModes : Enum {
public int value__
public CustomErrorsModes On
public CustomErrorsModes Off
public CustomErrorsModes RemoteOnly
}
internal System.Runtime.Remoting.DisposerReplySink : object {
private IMessageSink _next
private IDisposable _disposable
public IMessageSink NextSink
public void .ctor(IMessageSink next, IDisposable disposable)
public IMessage SyncProcessMessage(IMessage msg)
public IMessageCtrl AsyncProcessMessage(IMessage msg, IMessageSink replySink)
public IMessageSink get_NextSink()
}
internal System.Runtime.Remoting.EnvoyInfo : object {
private IMessageSink envoySinks
public IMessageSink EnvoySinks
public void .ctor(IMessageSink sinks)
public IMessageSink get_EnvoySinks()
public void set_EnvoySinks(IMessageSink value)
}
public System.Runtime.Remoting.IChannelInfo {
public Object[] ChannelData
public Object[] get_ChannelData()
public void set_ChannelData(Object[] value)
}
internal System.Runtime.Remoting.Identity : object {
protected string _objectUri
protected IMessageSink _channelSink
protected IMessageSink _envoySink
private DynamicPropertyCollection _clientDynamicProperties
private DynamicPropertyCollection _serverDynamicProperties
protected ObjRef _objRef
private bool _disposed
public bool IsFromThisAppDomain
public IMessageSink ChannelSink
public IMessageSink EnvoySink
public string ObjectUri
public bool IsConnected
public bool Disposed
public DynamicPropertyCollection ClientDynamicProperties
public DynamicPropertyCollection ServerDynamicProperties
public bool HasClientDynamicSinks
public bool HasServerDynamicSinks
public void .ctor(string objectUri)
public ObjRef CreateObjRef(Type requestedType)
public bool get_IsFromThisAppDomain()
public IMessageSink get_ChannelSink()
public void set_ChannelSink(IMessageSink value)
public IMessageSink get_EnvoySink()
public string get_ObjectUri()
public void set_ObjectUri(string value)
public bool get_IsConnected()
public bool get_Disposed()
public void set_Disposed(bool value)
public DynamicPropertyCollection get_ClientDynamicProperties()
public DynamicPropertyCollection get_ServerDynamicProperties()
public bool get_HasClientDynamicSinks()
public bool get_HasServerDynamicSinks()
public void NotifyClientDynamicSinks(bool start, IMessage req_msg, bool client_site, bool async)
public void NotifyServerDynamicSinks(bool start, IMessage req_msg, bool client_site, bool async)
}
public System.Runtime.Remoting.IEnvoyInfo {
public IMessageSink EnvoySinks
public IMessageSink get_EnvoySinks()
public void set_EnvoySinks(IMessageSink value)
}
public System.Runtime.Remoting.InternalRemotingServices : object {
private Hashtable _soapAttributes
public void DebugOutChnl(string s)
public SoapAttribute GetCachedSoapAttribute(object reflectionObject)
public void RemotingAssert(bool condition, string message)
public void RemotingTrace(Object[] messages)
public void SetServerIdentity(MethodCall m, object srvID)
}
public System.Runtime.Remoting.IObjectHandle {
public object Unwrap()
}
public System.Runtime.Remoting.IRemotingTypeInfo {
public string TypeName
public string get_TypeName()
public void set_TypeName(string value)
public bool CanCastTo(Type fromType, object o)
}
public System.Runtime.Remoting.Lifetime.ClientSponsor : MarshalByRefObject {
private TimeSpan renewal_time
private Hashtable registered_objects
public TimeSpan RenewalTime
public void .ctor(TimeSpan renewalTime)
public TimeSpan get_RenewalTime()
public void set_RenewalTime(TimeSpan value)
public void Close()
protected void Finalize()
public object InitializeLifetimeService()
public bool Register(MarshalByRefObject obj)
public TimeSpan Renewal(ILease lease)
public void Unregister(MarshalByRefObject obj)
}
public System.Runtime.Remoting.Lifetime.ILease {
public TimeSpan CurrentLeaseTime
public LeaseState CurrentState
public TimeSpan InitialLeaseTime
public TimeSpan RenewOnCallTime
public TimeSpan SponsorshipTimeout
public TimeSpan get_CurrentLeaseTime()
public LeaseState get_CurrentState()
public TimeSpan get_InitialLeaseTime()
public void set_InitialLeaseTime(TimeSpan value)
public TimeSpan get_RenewOnCallTime()
public void set_RenewOnCallTime(TimeSpan value)
public TimeSpan get_SponsorshipTimeout()
public void set_SponsorshipTimeout(TimeSpan value)
public void Register(ISponsor obj)
public void Register(ISponsor obj, TimeSpan renewalTime)
public TimeSpan Renew(TimeSpan renewalTime)
public void Unregister(ISponsor obj)
}
public System.Runtime.Remoting.Lifetime.ISponsor {
public TimeSpan Renewal(ILease lease)
}
internal System.Runtime.Remoting.Lifetime.Lease : MarshalByRefObject {
private DateTime _leaseExpireTime
private LeaseState _currentState
private TimeSpan _initialLeaseTime
private TimeSpan _renewOnCallTime
private TimeSpan _sponsorshipTimeout
private ArrayList _sponsors
private Queue _renewingSponsors
private RenewalDelegate _renewalDelegate
public TimeSpan CurrentLeaseTime
public LeaseState CurrentState
public TimeSpan InitialLeaseTime
public TimeSpan RenewOnCallTime
public TimeSpan SponsorshipTimeout
public TimeSpan get_CurrentLeaseTime()
public LeaseState get_CurrentState()
public void Activate()
public TimeSpan get_InitialLeaseTime()
public void set_InitialLeaseTime(TimeSpan value)
public TimeSpan get_RenewOnCallTime()
public void set_RenewOnCallTime(TimeSpan value)
public TimeSpan get_SponsorshipTimeout()
public void set_SponsorshipTimeout(TimeSpan value)
public void Register(ISponsor obj)
public void Register(ISponsor obj, TimeSpan renewalTime)
public TimeSpan Renew(TimeSpan renewalTime)
public void Unregister(ISponsor obj)
internal void UpdateState()
private void CheckNextSponsor()
private void ProcessSponsorResponse(object state, bool timedOut)
}
internal System.Runtime.Remoting.Lifetime.LeaseManager : object {
private ArrayList _objects
private Timer _timer
public void SetPollTime(TimeSpan timeSpan)
public void TrackLifetime(ServerIdentity identity)
public void StopTrackingLifetime(ServerIdentity identity)
public void StartManager()
public void StopManager()
public void ManageLeases(object state)
}
internal System.Runtime.Remoting.Lifetime.LeaseSink : object {
private IMessageSink _nextSink
public IMessageSink NextSink
public void .ctor(IMessageSink nextSink)
public IMessage SyncProcessMessage(IMessage msg)
public IMessageCtrl AsyncProcessMessage(IMessage msg, IMessageSink replySink)
private void RenewLease(IMessage msg)
public IMessageSink get_NextSink()
}
public System.Runtime.Remoting.Lifetime.LeaseState : Enum {
public int value__
public LeaseState Null
public LeaseState Initial
public LeaseState Active
public LeaseState Renewing
public LeaseState Expired
}
public System.Runtime.Remoting.Lifetime.LifetimeServices : object {
private TimeSpan _leaseManagerPollTime
private TimeSpan _leaseTime
private TimeSpan _renewOnCallTime
private TimeSpan _sponsorshipTimeout
private LeaseManager _leaseManager
public TimeSpan LeaseManagerPollTime
public TimeSpan LeaseTime
public TimeSpan RenewOnCallTime
public TimeSpan SponsorshipTimeout
public TimeSpan get_LeaseManagerPollTime()
public void set_LeaseManagerPollTime(TimeSpan value)
public TimeSpan get_LeaseTime()
public void set_LeaseTime(TimeSpan value)
public TimeSpan get_RenewOnCallTime()
public void set_RenewOnCallTime(TimeSpan value)
public TimeSpan get_SponsorshipTimeout()
public void set_SponsorshipTimeout(TimeSpan value)
internal void TrackLifetime(ServerIdentity identity)
internal void StopTrackingLifetime(ServerIdentity identity)
}
internal System.Runtime.Remoting.Messaging.ArgInfo : object {
private Int32[] _paramMap
private int _inoutArgCount
private MethodBase _method
public void .ctor(MethodBase method, ArgInfoType type)
public int GetInOutArgIndex(int inoutArgNum)
public string GetInOutArgName(int index)
public int GetInOutArgCount()
public Object[] GetInOutArgs(Object[] args)
}
internal System.Runtime.Remoting.Messaging.ArgInfoType : Enum {
public byte value__
public ArgInfoType In
public ArgInfoType Out
}
public System.Runtime.Remoting.Messaging.AsyncResult : object {
private object async_state
private WaitHandle handle
private object async_delegate
private IntPtr data
private object object_data
private bool sync_completed
private bool completed
private bool endinvoke_called
private object async_callback
private ExecutionContext current
private ExecutionContext original
private long add_time
private MonoMethodMessage call_message
private IMessageCtrl message_ctrl
private IMessage reply_message
private WaitCallback orig_cb
internal ContextCallback ccb
public object AsyncState
public WaitHandle AsyncWaitHandle
public bool CompletedSynchronously
public bool IsCompleted
public bool EndInvokeCalled
public object AsyncDelegate
public IMessageSink NextSink
internal MonoMethodMessage CallMessage
internal void .ctor(WaitCallback cb, object state, bool capture_context)
private void WaitCallback_Context(object state)
public object get_AsyncState()
public WaitHandle get_AsyncWaitHandle()
public bool get_CompletedSynchronously()
public bool get_IsCompleted()
public bool get_EndInvokeCalled()
public void set_EndInvokeCalled(bool value)
public object get_AsyncDelegate()
public IMessageSink get_NextSink()
public IMessageCtrl AsyncProcessMessage(IMessage msg, IMessageSink replySink)
public IMessage GetReplyMessage()
public void SetMessageCtrl(IMessageCtrl mc)
internal void SetCompletedSynchronously(bool completed)
internal IMessage EndInvoke()
public IMessage SyncProcessMessage(IMessage msg)
internal MonoMethodMessage get_CallMessage()
internal void set_CallMessage(MonoMethodMessage value)
private void System.Threading.IThreadPoolWorkItem.ExecuteWorkItem()
private void System.Threading.IThreadPoolWorkItem.MarkAborted(ThreadAbortException tae)
internal object Invoke()
private void <.ctor>b__17_0(object <p0>)
}
internal System.Runtime.Remoting.Messaging.CADArgHolder : object {
public int index
public void .ctor(int i)
}
internal System.Runtime.Remoting.Messaging.CADMessageBase : object {
protected Object[] _args
protected Byte[] _serializedArgs
protected int _propertyCount
protected CADArgHolder _callContext
internal Byte[] serializedMethod
public void .ctor(IMethodMessage msg)
internal MethodBase GetMethod()
protected Type[] GetSignature(MethodBase methodBase, bool load)
internal int MarshalProperties(IDictionary dict, ArrayList& args)
internal void UnmarshalProperties(IDictionary dict, int count, ArrayList args)
private bool IsPossibleToIgnoreMarshal(object obj)
protected object MarshalArgument(object arg, ArrayList& args)
protected object UnmarshalArgument(object arg, ArrayList args)
internal Object[] MarshalArguments(Object[] arguments, ArrayList& args)
internal Object[] UnmarshalArguments(Object[] arguments, ArrayList args)
protected void SaveLogicalCallContext(IMethodMessage msg, ArrayList& serializeList)
internal LogicalCallContext GetLogicalCallContext(ArrayList args)
}
internal System.Runtime.Remoting.Messaging.CADMethodCallMessage : CADMessageBase {
private string _uri
internal string Uri
internal int PropertiesCount
internal string get_Uri()
internal CADMethodCallMessage Create(IMessage callMsg)
internal void .ctor(IMethodCallMessage callMsg)
internal ArrayList GetArguments()
internal Object[] GetArgs(ArrayList args)
internal int get_PropertiesCount()
}
internal System.Runtime.Remoting.Messaging.CADMethodRef : object {
private bool ctor
private string typeName
private string methodName
private String[] param_names
private String[] generic_arg_names
private Type[] GetTypes(String[] typeArray)
public MethodBase Resolve()
public void .ctor(IMethodMessage msg)
}
internal System.Runtime.Remoting.Messaging.CADMethodReturnMessage : CADMessageBase {
private object _returnValue
private CADArgHolder _exception
private Type[] _sig
internal int PropertiesCount
internal CADMethodReturnMessage Create(IMessage callMsg)
internal void .ctor(IMethodReturnMessage retMsg)
internal ArrayList GetArguments()
internal Object[] GetArgs(ArrayList args)
internal object GetReturnValue(ArrayList args)
internal Exception GetException(ArrayList args)
internal int get_PropertiesCount()
}
internal System.Runtime.Remoting.Messaging.CADObjRef : object {
internal ObjRef objref
internal int SourceDomain
internal Byte[] TypeInfo
public string TypeName
public string URI
public void .ctor(ObjRef o, int sourceDomain)
public string get_TypeName()
public string get_URI()
}
public System.Runtime.Remoting.Messaging.CallContext : object {
internal IPrincipal Principal
public object HostContext
internal object SetCurrentCallContext(LogicalCallContext ctx)
internal LogicalCallContext SetLogicalCallContext(LogicalCallContext callCtx)
public void FreeNamedDataSlot(string name)
public object LogicalGetData(string name)
private object IllogicalGetData(string name)
internal IPrincipal get_Principal()
internal void set_Principal(IPrincipal value)
public object get_HostContext()
public void set_HostContext(object value)
public object GetData(string name)
public void SetData(string name, object data)
public void LogicalSetData(string name, object data)
public Header[] GetHeaders()
public void SetHeaders(Header[] headers)
}
internal System.Runtime.Remoting.Messaging.CallContextRemotingData : object {
private string _logicalCallID
internal string LogicalCallID
internal bool HasInfo
internal string get_LogicalCallID()
internal void set_LogicalCallID(string value)
internal bool get_HasInfo()
public object Clone()
}
internal System.Runtime.Remoting.Messaging.CallContextSecurityData : object {
private IPrincipal _principal
internal IPrincipal Principal
internal bool HasInfo
internal IPrincipal get_Principal()
internal void set_Principal(IPrincipal value)
internal bool get_HasInfo()
public object Clone()
}
internal System.Runtime.Remoting.Messaging.CallType : Enum {
public int value__
public CallType Sync
public CallType BeginInvoke
public CallType EndInvoke
public CallType OneWay
}
internal System.Runtime.Remoting.Messaging.ClientContextReplySink : object {
private IMessageSink _replySink
private Context _context
public IMessageSink NextSink
public void .ctor(Context ctx, IMessageSink replySink)
public IMessage SyncProcessMessage(IMessage msg)
public IMessageCtrl AsyncProcessMessage(IMessage msg, IMessageSink replySink)
public IMessageSink get_NextSink()
}
internal System.Runtime.Remoting.Messaging.ClientContextTerminatorSink : object {
private Context _context
public IMessageSink NextSink
public void .ctor(Context ctx)
public IMessage SyncProcessMessage(IMessage msg)
public IMessageCtrl AsyncProcessMessage(IMessage msg, IMessageSink replySink)
public IMessageSink get_NextSink()
}
public System.Runtime.Remoting.Messaging.ConstructionCall : MethodCall {
private IActivator _activator
private Object[] _activationAttributes
private IList _contextProperties
private Type _activationType
private string _activationTypeName
private bool _isContextOk
private RemotingProxy _sourceProxy
internal bool IsContextOk
public Type ActivationType
public string ActivationTypeName
public IActivator Activator
public Object[] CallSiteActivationAttributes
public IList ContextProperties
public IDictionary Properties
internal RemotingProxy SourceProxy
public void .ctor(IMessage m)
internal void .ctor(Type type)
public void .ctor(Header[] headers)
internal void .ctor(SerializationInfo info, StreamingContext context)
internal void InitDictionary()
internal bool get_IsContextOk()
internal void set_IsContextOk(bool value)
public Type get_ActivationType()
public string get_ActivationTypeName()
public IActivator get_Activator()
public void set_Activator(IActivator value)
public Object[] get_CallSiteActivationAttributes()
internal void SetActivationAttributes(Object[] attributes)
public IList get_ContextProperties()
internal void InitMethodProperty(string key, object value)
public void GetObjectData(SerializationInfo info, StreamingContext context)
public IDictionary get_Properties()
internal RemotingProxy get_SourceProxy()
internal void set_SourceProxy(RemotingProxy value)
}
internal System.Runtime.Remoting.Messaging.ConstructionCallDictionary : MessageDictionary {
public String[] InternalKeys
public void .ctor(IConstructionCallMessage message)
protected object GetMethodProperty(string key)
protected void SetMethodProperty(string key, object value)
}
public System.Runtime.Remoting.Messaging.ConstructionResponse : MethodResponse {
public IDictionary Properties
public void .ctor(Header[] h, IMethodCallMessage mcm)
internal void .ctor(object resultObject, LogicalCallContext callCtx, IMethodCallMessage msg)
internal void .ctor(Exception e, IMethodCallMessage msg)
internal void .ctor(SerializationInfo info, StreamingContext context)
public IDictionary get_Properties()
}
internal System.Runtime.Remoting.Messaging.EnvoyTerminatorSink : object {
public EnvoyTerminatorSink Instance
public IMessageSink NextSink
public IMessage SyncProcessMessage(IMessage msg)
public IMessageCtrl AsyncProcessMessage(IMessage msg, IMessageSink replySink)
public IMessageSink get_NextSink()
}
internal System.Runtime.Remoting.Messaging.ErrorMessage : object {
private string _uri
public int ArgCount
public Object[] Args
public bool HasVarArgs
public MethodBase MethodBase
public string MethodName
public object MethodSignature
public IDictionary Properties
public string TypeName
public string Uri
public int InArgCount
public Object[] InArgs
public LogicalCallContext LogicalCallContext
public int get_ArgCount()
public Object[] get_Args()
public bool get_HasVarArgs()
public MethodBase get_MethodBase()
public string get_MethodName()
public object get_MethodSignature()
public IDictionary get_Properties()
public string get_TypeName()
public string get_Uri()
public void set_Uri(string value)
public object GetArg(int arg_num)
public string GetArgName(int arg_num)
public int get_InArgCount()
public string GetInArgName(int index)
public object GetInArg(int argNum)
public Object[] get_InArgs()
public LogicalCallContext get_LogicalCallContext()
}
public System.Runtime.Remoting.Messaging.Header : object {
public string HeaderNamespace
public bool MustUnderstand
public string Name
public object Value
public void .ctor(string _Name, object _Value)
public void .ctor(string _Name, object _Value, bool _MustUnderstand)
public void .ctor(string _Name, object _Value, bool _MustUnderstand, string _HeaderNamespace)
}
public System.Runtime.Remoting.Messaging.HeaderHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public object Invoke(Header[] headers)
public IAsyncResult BeginInvoke(Header[] headers, AsyncCallback callback, object object)
public object EndInvoke(IAsyncResult result)
}
internal System.Runtime.Remoting.Messaging.IInternalMessage {
public Identity TargetIdentity
public string Uri
public Identity get_TargetIdentity()
public void set_TargetIdentity(Identity value)
public string get_Uri()
public void set_Uri(string value)
public bool HasProperties()
}
internal System.Runtime.Remoting.Messaging.IllogicalCallContext : object {
private Hashtable m_Datastore
private object m_HostContext
private Hashtable Datastore
internal object HostContext
internal bool HasUserData
private Hashtable get_Datastore()
internal object get_HostContext()
internal void set_HostContext(object value)
internal bool get_HasUserData()
public void FreeNamedDataSlot(string name)
public object GetData(string name)
public void SetData(string name, object data)
public IllogicalCallContext CreateCopy()
}
public System.Runtime.Remoting.Messaging.IMessage {
public IDictionary Properties
public IDictionary get_Properties()
}
public System.Runtime.Remoting.Messaging.IMessageCtrl {
public void Cancel(int msToCancel)
}
public System.Runtime.Remoting.Messaging.IMessageSink {
public IMessageSink NextSink
public IMessage SyncProcessMessage(IMessage msg)
public IMessageCtrl AsyncProcessMessage(IMessage msg, IMessageSink replySink)
public IMessageSink get_NextSink()
}
public System.Runtime.Remoting.Messaging.IMethodCallMessage {
public int InArgCount
public Object[] InArgs
public int get_InArgCount()
public Object[] get_InArgs()
public object GetInArg(int argNum)
public string GetInArgName(int index)
}
public System.Runtime.Remoting.Messaging.IMethodMessage {
public int ArgCount
public Object[] Args
public bool HasVarArgs
public LogicalCallContext LogicalCallContext
public MethodBase MethodBase
public string MethodName
public object MethodSignature
public string TypeName
public string Uri
public int get_ArgCount()
public Object[] get_Args()
public bool get_HasVarArgs()
public LogicalCallContext get_LogicalCallContext()
public MethodBase get_MethodBase()
public string get_MethodName()
public object get_MethodSignature()
public string get_TypeName()
public string get_Uri()
public object GetArg(int argNum)
public string GetArgName(int index)
}
public System.Runtime.Remoting.Messaging.IMethodReturnMessage {
public Exception Exception
public int OutArgCount
public Object[] OutArgs
public object ReturnValue
public Exception get_Exception()
public int get_OutArgCount()
public Object[] get_OutArgs()
public object get_ReturnValue()
public object GetOutArg(int argNum)
public string GetOutArgName(int index)
}
public System.Runtime.Remoting.Messaging.InternalMessageWrapper : object {
protected IMessage WrappedMessage
public void .ctor(IMessage msg)
}
public System.Runtime.Remoting.Messaging.IRemotingFormatter {
public object Deserialize(Stream serializationStream, HeaderHandler handler)
public void Serialize(Stream serializationStream, object graph, Header[] headers)
}
internal System.Runtime.Remoting.Messaging.ISerializationRootObject {
public void RootSetObjectData(SerializationInfo info, StreamingContext context)
}
public System.Runtime.Remoting.Messaging.LogicalCallContext : object {
private Type s_callContextType
private string s_CorrelationMgrSlotName
private Hashtable m_Datastore
private CallContextRemotingData m_RemotingData
private CallContextSecurityData m_SecurityData
private object m_HostContext
private bool m_IsCorrelationMgr
private Header[] _sendHeaders
private Header[] _recvHeaders
public bool HasInfo
private bool HasUserData
internal CallContextRemotingData RemotingData
internal CallContextSecurityData SecurityData
internal object HostContext
private Hashtable Datastore
internal IPrincipal Principal
internal void .ctor(SerializationInfo info, StreamingContext context)
public void GetObjectData(SerializationInfo info, StreamingContext context)
public object Clone()
internal void Merge(LogicalCallContext lc)
public bool get_HasInfo()
private bool get_HasUserData()
internal CallContextRemotingData get_RemotingData()
internal CallContextSecurityData get_SecurityData()
internal object get_HostContext()
internal void set_HostContext(object value)
private Hashtable get_Datastore()
internal IPrincipal get_Principal()
internal void set_Principal(IPrincipal value)
public void FreeNamedDataSlot(string name)
public object GetData(string name)
public void SetData(string name, object data)
private Header[] InternalGetOutgoingHeaders()
internal void InternalSetHeaders(Header[] headers)
internal Header[] InternalGetHeaders()
internal IPrincipal RemovePrincipalIfNotSerializable()
internal void PropagateOutgoingHeadersToMessage(IMessage msg)
internal string GetPropertyKeyForHeader(Header header)
internal void PropagateIncomingHeadersToCallContext(IMessage msg)
}
internal System.Runtime.Remoting.Messaging.MCMDictionary : MessageDictionary {
public String[] InternalKeys
public void .ctor(IMethodMessage message)
}
internal System.Runtime.Remoting.Messaging.MessageDictionary : object {
private IDictionary _internalProperties
protected IMethodMessage _message
private String[] _methodKeys
private bool _ownProperties
internal IDictionary InternalDictionary
public String[] MethodKeys
public bool IsFixedSize
public bool IsReadOnly
public object Item
public ICollection Keys
public ICollection Values
public int Count
public bool IsSynchronized
public object SyncRoot
public void .ctor(IMethodMessage message)
internal bool HasUserData()
internal IDictionary get_InternalDictionary()
public String[] get_MethodKeys()
public void set_MethodKeys(String[] value)
protected IDictionary AllocInternalProperties()
public IDictionary GetInternalProperties()
private bool IsOverridenKey(string key)
public void .ctor(String[] keys)
public bool get_IsFixedSize()
public bool get_IsReadOnly()
public object get_Item(object key)
public void set_Item(object key, object value)
protected object GetMethodProperty(string key)
protected void SetMethodProperty(string key, object value)
public ICollection get_Keys()
public ICollection get_Values()
public void Add(object key, object value)
public void Clear()
public bool Contains(object key)
public void Remove(object key)
public int get_Count()
public bool get_IsSynchronized()
public object get_SyncRoot()
public void CopyTo(Array array, int index)
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
public IDictionaryEnumerator GetEnumerator()
}
public System.Runtime.Remoting.Messaging.MessageSurrogateFilter : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public bool Invoke(string key, object value)
public IAsyncResult BeginInvoke(string key, object value, AsyncCallback callback, object object)
public bool EndInvoke(IAsyncResult result)
}
public System.Runtime.Remoting.Messaging.MethodCall : object {
private string _uri
private string _typeName
private string _methodName
private Object[] _args
private Type[] _methodSignature
private MethodBase _methodBase
private LogicalCallContext _callContext
private ArgInfo _inArgInfo
private Identity _targetIdentity
private Type[] _genericArguments
protected IDictionary ExternalProperties
protected IDictionary InternalProperties
public int ArgCount
public Object[] Args
public bool HasVarArgs
public int InArgCount
public Object[] InArgs
public LogicalCallContext LogicalCallContext
public MethodBase MethodBase
public string MethodName
public object MethodSignature
public IDictionary Properties
public string TypeName
public string Uri
private string System.Runtime.Remoting.Messaging.IInternalMessage.Uri
private Identity System.Runtime.Remoting.Messaging.IInternalMessage.TargetIdentity
private Type[] GenericArguments
public void .ctor(Header[] h1)
internal void .ctor(SerializationInfo info, StreamingContext context)
internal void .ctor(CADMethodCallMessage msg)
public void .ctor(IMessage msg)
internal void .ctor(string uri, string typeName, string methodName, Object[] args)
internal void .ctor(object handlerObject, BinaryMethodCallMessage smuggledMsg)
internal void CopyFrom(IMethodMessage call)
internal void InitMethodProperty(string key, object value)
public void GetObjectData(SerializationInfo info, StreamingContext context)
public int get_ArgCount()
public Object[] get_Args()
public bool get_HasVarArgs()
public int get_InArgCount()
public Object[] get_InArgs()
public LogicalCallContext get_LogicalCallContext()
public MethodBase get_MethodBase()
public string get_MethodName()
public object get_MethodSignature()
public IDictionary get_Properties()
internal void InitDictionary()
public string get_TypeName()
public string get_Uri()
public void set_Uri(string value)
private string System.Runtime.Remoting.Messaging.IInternalMessage.get_Uri()
private void System.Runtime.Remoting.Messaging.IInternalMessage.set_Uri(string value)
public object GetArg(int argNum)
public string GetArgName(int index)
public object GetInArg(int argNum)
public string GetInArgName(int index)
public object HeaderHandler(Header[] h)
public void Init()
public void ResolveMethod()
private Type CastTo(string clientType, Type serverType)
private string GetTypeNameFromAssemblyQualifiedName(string aqname)
public void RootSetObjectData(SerializationInfo info, StreamingContext ctx)
private Identity System.Runtime.Remoting.Messaging.IInternalMessage.get_TargetIdentity()
private void System.Runtime.Remoting.Messaging.IInternalMessage.set_TargetIdentity(Identity value)
private bool System.Runtime.Remoting.Messaging.IInternalMessage.HasProperties()
private Type[] get_GenericArguments()
}
public System.Runtime.Remoting.Messaging.MethodCallMessageWrapper : InternalMessageWrapper {
private Object[] _args
private ArgInfo _inArgInfo
private DictionaryWrapper _properties
public int ArgCount
public Object[] Args
public bool HasVarArgs
public int InArgCount
public Object[] InArgs
public LogicalCallContext LogicalCallContext
public MethodBase MethodBase
public string MethodName
public object MethodSignature
public IDictionary Properties
public string TypeName
public string Uri
public void .ctor(IMethodCallMessage msg)
public int get_ArgCount()
public Object[] get_Args()
public void set_Args(Object[] value)
public bool get_HasVarArgs()
public int get_InArgCount()
public Object[] get_InArgs()
public LogicalCallContext get_LogicalCallContext()
public MethodBase get_MethodBase()
public string get_MethodName()
public object get_MethodSignature()
public IDictionary get_Properties()
public string get_TypeName()
public string get_Uri()
public void set_Uri(string value)
public object GetArg(int argNum)
public string GetArgName(int index)
public object GetInArg(int argNum)
public string GetInArgName(int index)
}
public System.Runtime.Remoting.Messaging.MethodResponse : object {
private string _methodName
private string _uri
private string _typeName
private MethodBase _methodBase
private object _returnValue
private Exception _exception
private Type[] _methodSignature
private ArgInfo _inArgInfo
private Object[] _args
private Object[] _outArgs
private IMethodCallMessage _callMsg
private LogicalCallContext _callContext
private Identity _targetIdentity
protected IDictionary ExternalProperties
protected IDictionary InternalProperties
public int ArgCount
public Object[] Args
public Exception Exception
public bool HasVarArgs
public LogicalCallContext LogicalCallContext
public MethodBase MethodBase
public string MethodName
public object MethodSignature
public int OutArgCount
public Object[] OutArgs
public IDictionary Properties
public object ReturnValue
public string TypeName
public string Uri
private string System.Runtime.Remoting.Messaging.IInternalMessage.Uri
private Identity System.Runtime.Remoting.Messaging.IInternalMessage.TargetIdentity
public void .ctor(Header[] h1, IMethodCallMessage mcm)
internal void .ctor(Exception e, IMethodCallMessage msg)
internal void .ctor(object returnValue, Object[] outArgs, LogicalCallContext callCtx, IMethodCallMessage msg)
internal void .ctor(IMethodCallMessage msg, CADMethodReturnMessage retmsg)
internal void .ctor(IMethodCallMessage msg, object handlerObject, BinaryMethodReturnMessage smuggledMrm)
internal void .ctor(SerializationInfo info, StreamingContext context)
internal void InitMethodProperty(string key, object value)
public int get_ArgCount()
public Object[] get_Args()
public Exception get_Exception()
public bool get_HasVarArgs()
public LogicalCallContext get_LogicalCallContext()
public MethodBase get_MethodBase()
public string get_MethodName()
public object get_MethodSignature()
public int get_OutArgCount()
public Object[] get_OutArgs()
public IDictionary get_Properties()
public object get_ReturnValue()
public string get_TypeName()
public string get_Uri()
public void set_Uri(string value)
private string System.Runtime.Remoting.Messaging.IInternalMessage.get_Uri()
private void System.Runtime.Remoting.Messaging.IInternalMessage.set_Uri(string value)
public object GetArg(int argNum)
public string GetArgName(int index)
public void GetObjectData(SerializationInfo info, StreamingContext context)
public object GetOutArg(int argNum)
public string GetOutArgName(int index)
public object HeaderHandler(Header[] h)
public void RootSetObjectData(SerializationInfo info, StreamingContext ctx)
private Identity System.Runtime.Remoting.Messaging.IInternalMessage.get_TargetIdentity()
private void System.Runtime.Remoting.Messaging.IInternalMessage.set_TargetIdentity(Identity value)
private bool System.Runtime.Remoting.Messaging.IInternalMessage.HasProperties()
}
internal System.Runtime.Remoting.Messaging.MethodReturnDictionary : MessageDictionary {
public String[] InternalReturnKeys
public String[] InternalExceptionKeys
public void .ctor(IMethodReturnMessage message)
}
public System.Runtime.Remoting.Messaging.MethodReturnMessageWrapper : InternalMessageWrapper {
private Object[] _args
private ArgInfo _outArgInfo
private DictionaryWrapper _properties
private Exception _exception
private object _return
public int ArgCount
public Object[] Args
public Exception Exception
public bool HasVarArgs
public LogicalCallContext LogicalCallContext
public MethodBase MethodBase
public string MethodName
public object MethodSignature
public int OutArgCount
public Object[] OutArgs
public IDictionary Properties
public object ReturnValue
public string TypeName
public string Uri
public void .ctor(IMethodReturnMessage msg)
public int get_ArgCount()
public Object[] get_Args()
public void set_Args(Object[] value)
public Exception get_Exception()
public void set_Exception(Exception value)
public bool get_HasVarArgs()
public LogicalCallContext get_LogicalCallContext()
public MethodBase get_MethodBase()
public string get_MethodName()
public object get_MethodSignature()
public int get_OutArgCount()
public Object[] get_OutArgs()
public IDictionary get_Properties()
public object get_ReturnValue()
public void set_ReturnValue(object value)
public string get_TypeName()
public string get_Uri()
public void set_Uri(string value)
public object GetArg(int argNum)
public string GetArgName(int index)
public object GetOutArg(int argNum)
public string GetOutArgName(int index)
}
internal System.Runtime.Remoting.Messaging.MonoMethodMessage : object {
private MonoMethod method
private Object[] args
private String[] names
private Byte[] arg_types
public LogicalCallContext ctx
public object rval
public Exception exc
private AsyncResult asyncResult
private CallType call_type
private string uri
private MCMDictionary properties
private Type[] methodSignature
private Identity identity
internal string CallContextKey
internal string UriKey
public IDictionary Properties
public int ArgCount
public Object[] Args
public bool HasVarArgs
public LogicalCallContext LogicalCallContext
public MethodBase MethodBase
public string MethodName
public object MethodSignature
public string TypeName
public string Uri
public int InArgCount
public Object[] InArgs
public Exception Exception
public int OutArgCount
public Object[] OutArgs
public object ReturnValue
private Identity System.Runtime.Remoting.Messaging.IInternalMessage.TargetIdentity
public bool IsAsync
public AsyncResult AsyncResult
internal CallType CallType
internal void InitMessage(MonoMethod method, Object[] out_args)
public void .ctor(MethodBase method, Object[] out_args)
internal void .ctor(MethodInfo minfo, Object[] in_args, Object[] out_args)
private MethodInfo GetMethodInfo(Type type, string methodName)
public void .ctor(Type type, string methodName, Object[] in_args)
public IDictionary get_Properties()
public int get_ArgCount()
public Object[] get_Args()
public bool get_HasVarArgs()
public LogicalCallContext get_LogicalCallContext()
public void set_LogicalCallContext(LogicalCallContext value)
public MethodBase get_MethodBase()
public string get_MethodName()
public object get_MethodSignature()
public string get_TypeName()
public string get_Uri()
public void set_Uri(string value)
public object GetArg(int arg_num)
public string GetArgName(int arg_num)
public int get_InArgCount()
public Object[] get_InArgs()
public object GetInArg(int arg_num)
public string GetInArgName(int arg_num)
public Exception get_Exception()
public int get_OutArgCount()
public Object[] get_OutArgs()
public object get_ReturnValue()
public object GetOutArg(int arg_num)
public string GetOutArgName(int arg_num)
private Identity System.Runtime.Remoting.Messaging.IInternalMessage.get_TargetIdentity()
private void System.Runtime.Remoting.Messaging.IInternalMessage.set_TargetIdentity(Identity value)
private bool System.Runtime.Remoting.Messaging.IInternalMessage.HasProperties()
public bool get_IsAsync()
public AsyncResult get_AsyncResult()
internal CallType get_CallType()
public bool NeedsOutProcessing(Int32& outCount)
}
internal System.Runtime.Remoting.Messaging.ObjRefSurrogate : object {
public void GetObjectData(object obj, SerializationInfo si, StreamingContext sc)
public object SetObjectData(object obj, SerializationInfo si, StreamingContext sc, ISurrogateSelector selector)
}
internal System.Runtime.Remoting.Messaging.RemotingSurrogate : object {
public void GetObjectData(object obj, SerializationInfo si, StreamingContext sc)
public object SetObjectData(object obj, SerializationInfo si, StreamingContext sc, ISurrogateSelector selector)
}
public System.Runtime.Remoting.Messaging.RemotingSurrogateSelector : object {
private Type s_cachedTypeObjRef
private ObjRefSurrogate _objRefSurrogate
private RemotingSurrogate _objRemotingSurrogate
private object _rootObj
private MessageSurrogateFilter _filter
private ISurrogateSelector _next
public MessageSurrogateFilter Filter
public MessageSurrogateFilter get_Filter()
public void set_Filter(MessageSurrogateFilter value)
public void ChainSelector(ISurrogateSelector selector)
public ISurrogateSelector GetNextSelector()
public object GetRootObject()
public ISerializationSurrogate GetSurrogate(Type type, StreamingContext context, ISurrogateSelector& ssout)
public void SetRootObject(object obj)
public void UseSoapFormat()
}
public System.Runtime.Remoting.Messaging.ReturnMessage : object {
private Object[] _outArgs
private Object[] _args
private LogicalCallContext _callCtx
private object _returnValue
private string _uri
private Exception _exception
private MethodBase _methodBase
private string _methodName
private Type[] _methodSignature
private string _typeName
private MethodReturnDictionary _properties
private Identity _targetIdentity
private ArgInfo _inArgInfo
public int ArgCount
public Object[] Args
public bool HasVarArgs
public LogicalCallContext LogicalCallContext
public MethodBase MethodBase
public string MethodName
public object MethodSignature
public IDictionary Properties
public string TypeName
public string Uri
private string System.Runtime.Remoting.Messaging.IInternalMessage.Uri
public Exception Exception
public int OutArgCount
public Object[] OutArgs
public object ReturnValue
private Identity System.Runtime.Remoting.Messaging.IInternalMessage.TargetIdentity
public void .ctor(object ret, Object[] outArgs, int outArgsCount, LogicalCallContext callCtx, IMethodCallMessage mcm)
public void .ctor(Exception e, IMethodCallMessage mcm)
public int get_ArgCount()
public Object[] get_Args()
public bool get_HasVarArgs()
public LogicalCallContext get_LogicalCallContext()
public MethodBase get_MethodBase()
public string get_MethodName()
public object get_MethodSignature()
public IDictionary get_Properties()
public string get_TypeName()
public string get_Uri()
public void set_Uri(string value)
private string System.Runtime.Remoting.Messaging.IInternalMessage.get_Uri()
private void System.Runtime.Remoting.Messaging.IInternalMessage.set_Uri(string value)
public object GetArg(int argNum)
public string GetArgName(int index)
public Exception get_Exception()
public int get_OutArgCount()
public Object[] get_OutArgs()
public object get_ReturnValue()
public object GetOutArg(int argNum)
public string GetOutArgName(int index)
private Identity System.Runtime.Remoting.Messaging.IInternalMessage.get_TargetIdentity()
private void System.Runtime.Remoting.Messaging.IInternalMessage.set_TargetIdentity(Identity value)
private bool System.Runtime.Remoting.Messaging.IInternalMessage.HasProperties()
internal bool HasProperties()
}
internal System.Runtime.Remoting.Messaging.ServerContextTerminatorSink : object {
public IMessageSink NextSink
public IMessage SyncProcessMessage(IMessage msg)
public IMessageCtrl AsyncProcessMessage(IMessage msg, IMessageSink replySink)
public IMessageSink get_NextSink()
}
internal System.Runtime.Remoting.Messaging.ServerObjectReplySink : object {
private IMessageSink _replySink
private ServerIdentity _identity
public IMessageSink NextSink
public void .ctor(ServerIdentity identity, IMessageSink replySink)
public IMessage SyncProcessMessage(IMessage msg)
public IMessageCtrl AsyncProcessMessage(IMessage msg, IMessageSink replySink)
public IMessageSink get_NextSink()
}
internal System.Runtime.Remoting.Messaging.ServerObjectTerminatorSink : object {
private IMessageSink _nextSink
public IMessageSink NextSink
public void .ctor(IMessageSink nextSink)
public IMessage SyncProcessMessage(IMessage msg)
public IMessageCtrl AsyncProcessMessage(IMessage msg, IMessageSink replySink)
public IMessageSink get_NextSink()
}
internal System.Runtime.Remoting.Messaging.StackBuilderSink : object {
private MarshalByRefObject _target
private RealProxy _rp
public IMessageSink NextSink
public void .ctor(MarshalByRefObject obj, bool forceInternalExecute)
public IMessage SyncProcessMessage(IMessage msg)
public IMessageCtrl AsyncProcessMessage(IMessage msg, IMessageSink replySink)
private void ExecuteAsyncMessage(object ob)
public IMessageSink get_NextSink()
private void CheckParameters(IMessage msg)
private void <AsyncProcessMessage>b__4_0(object data)
}
internal System.Runtime.Remoting.Metadata.RemotingFieldCachedData : object {
internal void .ctor(RuntimeFieldInfo ri)
internal void .ctor(SerializationFieldInfo ri)
}
public System.Runtime.Remoting.Metadata.SoapAttribute : Attribute {
private bool _nested
private bool _useAttribute
protected string ProtXmlNamespace
protected object ReflectInfo
public bool Embedded
public bool UseAttribute
public string XmlNamespace
public bool get_Embedded()
public void set_Embedded(bool value)
public bool get_UseAttribute()
public void set_UseAttribute(bool value)
public string get_XmlNamespace()
public void set_XmlNamespace(string value)
internal void SetReflectionObject(object reflectionObject)
}
public System.Runtime.Remoting.Metadata.SoapFieldAttribute : SoapAttribute {
private int _order
private string _elementName
private bool _isElement
public int Order
public string XmlElementName
public int get_Order()
public void set_Order(int value)
public string get_XmlElementName()
public void set_XmlElementName(string value)
public bool IsInteropXmlElement()
internal void SetReflectionObject(object reflectionObject)
}
public System.Runtime.Remoting.Metadata.SoapMethodAttribute : SoapAttribute {
private string _responseElement
private string _responseNamespace
private string _returnElement
private string _soapAction
private bool _useAttribute
private string _namespace
public string ResponseXmlElementName
public string ResponseXmlNamespace
public string ReturnXmlElementName
public string SoapAction
public bool UseAttribute
public string XmlNamespace
public string get_ResponseXmlElementName()
public void set_ResponseXmlElementName(string value)
public string get_ResponseXmlNamespace()
public void set_ResponseXmlNamespace(string value)
public string get_ReturnXmlElementName()
public void set_ReturnXmlElementName(string value)
public string get_SoapAction()
public void set_SoapAction(string value)
public bool get_UseAttribute()
public void set_UseAttribute(bool value)
public string get_XmlNamespace()
public void set_XmlNamespace(string value)
internal void SetReflectionObject(object reflectionObject)
}
public System.Runtime.Remoting.Metadata.SoapOption : Enum {
public int value__
public SoapOption None
public SoapOption AlwaysIncludeTypes
public SoapOption XsdString
public SoapOption EmbedAll
public SoapOption Option1
public SoapOption Option2
}
public System.Runtime.Remoting.Metadata.SoapTypeAttribute : SoapAttribute {
private SoapOption _soapOption
private bool _useAttribute
private string _xmlElementName
private XmlFieldOrderOption _xmlFieldOrder
private string _xmlNamespace
private string _xmlTypeName
private string _xmlTypeNamespace
private bool _isType
private bool _isElement
public SoapOption SoapOptions
public bool UseAttribute
public string XmlElementName
public XmlFieldOrderOption XmlFieldOrder
public string XmlNamespace
public string XmlTypeName
public string XmlTypeNamespace
internal bool IsInteropXmlElement
internal bool IsInteropXmlType
public SoapOption get_SoapOptions()
public void set_SoapOptions(SoapOption value)
public bool get_UseAttribute()
public void set_UseAttribute(bool value)
public string get_XmlElementName()
public void set_XmlElementName(string value)
public XmlFieldOrderOption get_XmlFieldOrder()
public void set_XmlFieldOrder(XmlFieldOrderOption value)
public string get_XmlNamespace()
public void set_XmlNamespace(string value)
public string get_XmlTypeName()
public void set_XmlTypeName(string value)
public string get_XmlTypeNamespace()
public void set_XmlTypeNamespace(string value)
internal bool get_IsInteropXmlElement()
internal bool get_IsInteropXmlType()
internal void SetReflectionObject(object reflectionObject)
}
public System.Runtime.Remoting.Metadata.W3cXsd2001.ISoapXsd {
public string GetXsdType()
}
public System.Runtime.Remoting.Metadata.W3cXsd2001.SoapAnyUri : object {
private string _value
public string Value
public string XsdType
public void .ctor(string value)
public string get_Value()
public void set_Value(string value)
public string get_XsdType()
public string GetXsdType()
public SoapAnyUri Parse(string value)
public string ToString()
}
public System.Runtime.Remoting.Metadata.W3cXsd2001.SoapBase64Binary : object {
private Byte[] _value
public Byte[] Value
public string XsdType
public void .ctor(Byte[] value)
public Byte[] get_Value()
public void set_Value(Byte[] value)
public string get_XsdType()
public string GetXsdType()
public SoapBase64Binary Parse(string value)
public string ToString()
}
public System.Runtime.Remoting.Metadata.W3cXsd2001.SoapDate : object {
private String[] _datetimeFormats
private int _sign
private DateTime _value
public int Sign
public DateTime Value
public string XsdType
public void .ctor(DateTime value)
public void .ctor(DateTime value, int sign)
public int get_Sign()
public void set_Sign(int value)
public DateTime get_Value()
public void set_Value(DateTime value)
public string get_XsdType()
public string GetXsdType()
public SoapDate Parse(string value)
public string ToString()
}
public System.Runtime.Remoting.Metadata.W3cXsd2001.SoapDateTime : object {
private String[] _datetimeFormats
public string XsdType
public string get_XsdType()
public DateTime Parse(string value)
public string ToString(DateTime value)
}
public System.Runtime.Remoting.Metadata.W3cXsd2001.SoapDay : object {
private String[] _datetimeFormats
private DateTime _value
public DateTime Value
public string XsdType
public void .ctor(DateTime value)
public DateTime get_Value()
public void set_Value(DateTime value)
public string get_XsdType()
public string GetXsdType()
public SoapDay Parse(string value)
public string ToString()
}
public System.Runtime.Remoting.Metadata.W3cXsd2001.SoapDuration : object {
public string XsdType
public string get_XsdType()
public TimeSpan Parse(string value)
public string ToString(TimeSpan timeSpan)
}
public System.Runtime.Remoting.Metadata.W3cXsd2001.SoapEntities : object {
private string _value
public string Value
public string XsdType
public void .ctor(string value)
public string get_Value()
public void set_Value(string value)
public string get_XsdType()
public string GetXsdType()
public SoapEntities Parse(string value)
public string ToString()
}
public System.Runtime.Remoting.Metadata.W3cXsd2001.SoapEntity : object {
private string _value
public string Value
public string XsdType
public void .ctor(string value)
public string get_Value()
public void set_Value(string value)
public string get_XsdType()
public string GetXsdType()
public SoapEntity Parse(string value)
public string ToString()
}
internal System.Runtime.Remoting.Metadata.W3cXsd2001.SoapHelper : object {
public Exception GetException(ISoapXsd type, string msg)
public string Normalize(string s)
}
public System.Runtime.Remoting.Metadata.W3cXsd2001.SoapHexBinary : object {
private Byte[] _value
private StringBuilder sb
public Byte[] Value
public string XsdType
public void .ctor(Byte[] value)
public Byte[] get_Value()
public void set_Value(Byte[] value)
public string get_XsdType()
public string GetXsdType()
public SoapHexBinary Parse(string value)
internal Byte[] FromBinHexString(string value)
private byte FromHex(char hexDigit, string value)
private Exception CreateInvalidValueException(string value)
public string ToString()
}
public System.Runtime.Remoting.Metadata.W3cXsd2001.SoapId : object {
private string _value
public string Value
public string XsdType
public void .ctor(string value)
public string get_Value()
public void set_Value(string value)
public string get_XsdType()
public string GetXsdType()
public SoapId Parse(string value)
public string ToString()
}
public System.Runtime.Remoting.Metadata.W3cXsd2001.SoapIdref : object {
private string _value
public string Value
public string XsdType
public void .ctor(string value)
public string get_Value()
public void set_Value(string value)
public string get_XsdType()
public string GetXsdType()
public SoapIdref Parse(string value)
public string ToString()
}
public System.Runtime.Remoting.Metadata.W3cXsd2001.SoapIdrefs : object {
private string _value
public string Value
public string XsdType
public void .ctor(string value)
public string get_Value()
public void set_Value(string value)
public string get_XsdType()
public string GetXsdType()
public SoapIdrefs Parse(string value)
public string ToString()
}
public System.Runtime.Remoting.Metadata.W3cXsd2001.SoapInteger : object {
private decimal _value
public decimal Value
public string XsdType
public void .ctor(decimal value)
public decimal get_Value()
public void set_Value(decimal value)
public string get_XsdType()
public string GetXsdType()
public SoapInteger Parse(string value)
public string ToString()
}
public System.Runtime.Remoting.Metadata.W3cXsd2001.SoapLanguage : object {
private string _value
public string Value
public string XsdType
public void .ctor(string value)
public string get_Value()
public void set_Value(string value)
public string get_XsdType()
public string GetXsdType()
public SoapLanguage Parse(string value)
public string ToString()
}
public System.Runtime.Remoting.Metadata.W3cXsd2001.SoapMonth : object {
private String[] _datetimeFormats
private DateTime _value
public DateTime Value
public string XsdType
public void .ctor(DateTime value)
public DateTime get_Value()
public void set_Value(DateTime value)
public string get_XsdType()
public string GetXsdType()
public SoapMonth Parse(string value)
public string ToString()
}
public System.Runtime.Remoting.Metadata.W3cXsd2001.SoapMonthDay : object {
private String[] _datetimeFormats
private DateTime _value
public DateTime Value
public string XsdType
public void .ctor(DateTime value)
public DateTime get_Value()
public void set_Value(DateTime value)
public string get_XsdType()
public string GetXsdType()
public SoapMonthDay Parse(string value)
public string ToString()
}
public System.Runtime.Remoting.Metadata.W3cXsd2001.SoapName : object {
private string _value
public string Value
public string XsdType
public void .ctor(string value)
public string get_Value()
public void set_Value(string value)
public string get_XsdType()
public string GetXsdType()
public SoapName Parse(string value)
public string ToString()
}
public System.Runtime.Remoting.Metadata.W3cXsd2001.SoapNcName : object {
private string _value
public string Value
public string XsdType
public void .ctor(string value)
public string get_Value()
public void set_Value(string value)
public string get_XsdType()
public string GetXsdType()
public SoapNcName Parse(string value)
public string ToString()
}
public System.Runtime.Remoting.Metadata.W3cXsd2001.SoapNegativeInteger : object {
private decimal _value
public decimal Value
public string XsdType
public void .ctor(decimal value)
public decimal get_Value()
public void set_Value(decimal value)
public string get_XsdType()
public string GetXsdType()
public SoapNegativeInteger Parse(string value)
public string ToString()
}
public System.Runtime.Remoting.Metadata.W3cXsd2001.SoapNmtoken : object {
private string _value
public string Value
public string XsdType
public void .ctor(string value)
public string get_Value()
public void set_Value(string value)
public string get_XsdType()
public string GetXsdType()
public SoapNmtoken Parse(string value)
public string ToString()
}
public System.Runtime.Remoting.Metadata.W3cXsd2001.SoapNmtokens : object {
private string _value
public string Value
public string XsdType
public void .ctor(string value)
public string get_Value()
public void set_Value(string value)
public string get_XsdType()
public string GetXsdType()
public SoapNmtokens Parse(string value)
public string ToString()
}
public System.Runtime.Remoting.Metadata.W3cXsd2001.SoapNonNegativeInteger : object {
private decimal _value
public decimal Value
public string XsdType
public void .ctor(decimal value)
public decimal get_Value()
public void set_Value(decimal value)
public string get_XsdType()
public string GetXsdType()
public SoapNonNegativeInteger Parse(string value)
public string ToString()
}
public System.Runtime.Remoting.Metadata.W3cXsd2001.SoapNonPositiveInteger : object {
private decimal _value
public decimal Value
public string XsdType
public void .ctor(decimal value)
public decimal get_Value()
public void set_Value(decimal value)
public string get_XsdType()
public string GetXsdType()
public SoapNonPositiveInteger Parse(string value)
public string ToString()
}
public System.Runtime.Remoting.Metadata.W3cXsd2001.SoapNormalizedString : object {
private string _value
public string Value
public string XsdType
public void .ctor(string value)
public string get_Value()
public void set_Value(string value)
public string get_XsdType()
public string GetXsdType()
public SoapNormalizedString Parse(string value)
public string ToString()
}
public System.Runtime.Remoting.Metadata.W3cXsd2001.SoapNotation : object {
private string _value
public string Value
public string XsdType
public void .ctor(string value)
public string get_Value()
public void set_Value(string value)
public string get_XsdType()
public string GetXsdType()
public SoapNotation Parse(string value)
public string ToString()
}
public System.Runtime.Remoting.Metadata.W3cXsd2001.SoapPositiveInteger : object {
private decimal _value
public decimal Value
public string XsdType
public void .ctor(decimal value)
public decimal get_Value()
public void set_Value(decimal value)
public string get_XsdType()
public string GetXsdType()
public SoapPositiveInteger Parse(string value)
public string ToString()
}
public System.Runtime.Remoting.Metadata.W3cXsd2001.SoapQName : object {
private string _name
private string _key
private string _namespace
public string Key
public string Name
public string Namespace
public string XsdType
public void .ctor(string value)
public void .ctor(string key, string name)
public void .ctor(string key, string name, string namespaceValue)
public string get_Key()
public void set_Key(string value)
public string get_Name()
public void set_Name(string value)
public string get_Namespace()
public void set_Namespace(string value)
public string get_XsdType()
public string GetXsdType()
public SoapQName Parse(string value)
public string ToString()
}
public System.Runtime.Remoting.Metadata.W3cXsd2001.SoapTime : object {
private String[] _datetimeFormats
private DateTime _value
public DateTime Value
public string XsdType
public void .ctor(DateTime value)
public DateTime get_Value()
public void set_Value(DateTime value)
public string get_XsdType()
public string GetXsdType()
public SoapTime Parse(string value)
public string ToString()
}
public System.Runtime.Remoting.Metadata.W3cXsd2001.SoapToken : object {
private string _value
public string Value
public string XsdType
public void .ctor(string value)
public string get_Value()
public void set_Value(string value)
public string get_XsdType()
public string GetXsdType()
public SoapToken Parse(string value)
public string ToString()
}
public System.Runtime.Remoting.Metadata.W3cXsd2001.SoapYear : object {
private String[] _datetimeFormats
private int _sign
private DateTime _value
public int Sign
public DateTime Value
public string XsdType
public void .ctor(DateTime value)
public void .ctor(DateTime value, int sign)
public int get_Sign()
public void set_Sign(int value)
public DateTime get_Value()
public void set_Value(DateTime value)
public string get_XsdType()
public string GetXsdType()
public SoapYear Parse(string value)
public string ToString()
}
public System.Runtime.Remoting.Metadata.W3cXsd2001.SoapYearMonth : object {
private String[] _datetimeFormats
private int _sign
private DateTime _value
public int Sign
public DateTime Value
public string XsdType
public void .ctor(DateTime value)
public void .ctor(DateTime value, int sign)
public int get_Sign()
public void set_Sign(int value)
public DateTime get_Value()
public void set_Value(DateTime value)
public string get_XsdType()
public string GetXsdType()
public SoapYearMonth Parse(string value)
public string ToString()
}
public System.Runtime.Remoting.Metadata.XmlFieldOrderOption : Enum {
public int value__
public XmlFieldOrderOption All
public XmlFieldOrderOption Sequence
public XmlFieldOrderOption Choice
}
public System.Runtime.Remoting.ObjectHandle : MarshalByRefObject {
private object _wrapped
public void .ctor(object o)
public object InitializeLifetimeService()
public object Unwrap()
}
public System.Runtime.Remoting.ObjRef : object {
private IChannelInfo channel_info
private string uri
private IRemotingTypeInfo typeInfo
private IEnvoyInfo envoyInfo
private int flags
private Type _serverType
private int MarshalledObjectRef
private int WellKnowObjectRef
internal bool IsReferenceToWellKnow
public IChannelInfo ChannelInfo
public IEnvoyInfo EnvoyInfo
public IRemotingTypeInfo TypeInfo
public string URI
internal Type ServerType
internal void .ctor(string uri, IChannelInfo cinfo)
internal ObjRef DeserializeInTheCurrentDomain(int domainId, Byte[] tInfo)
internal Byte[] SerializeType()
internal void .ctor(ObjRef o, bool unmarshalAsProxy)
public void .ctor(MarshalByRefObject o, Type requestedType)
internal void .ctor(Type type, string url, object remoteChannelData)
protected void .ctor(SerializationInfo info, StreamingContext context)
internal bool IsPossibleToCAD()
internal bool get_IsReferenceToWellKnow()
public IChannelInfo get_ChannelInfo()
public void set_ChannelInfo(IChannelInfo value)
public IEnvoyInfo get_EnvoyInfo()
public void set_EnvoyInfo(IEnvoyInfo value)
public IRemotingTypeInfo get_TypeInfo()
public void set_TypeInfo(IRemotingTypeInfo value)
public string get_URI()
public void set_URI(string value)
public void GetObjectData(SerializationInfo info, StreamingContext context)
public object GetRealObject(StreamingContext context)
public bool IsFromThisAppDomain()
public bool IsFromThisProcess()
internal void UpdateChannelInfo()
internal Type get_ServerType()
internal void SetDomainID(int id)
}
internal System.Runtime.Remoting.ProviderData : object {
internal string Ref
internal string Type
internal string Id
internal Hashtable CustomProperties
internal IList CustomData
public void CopyFrom(ProviderData other)
}
public System.Runtime.Remoting.Proxies.ProxyAttribute : Attribute {
public MarshalByRefObject CreateInstance(Type serverType)
public RealProxy CreateProxy(ObjRef objRef, Type serverType, object serverObject, Context serverContext)
public void GetPropertiesForNewContext(IConstructionCallMessage msg)
public bool IsContextOK(Context ctx, IConstructionCallMessage msg)
}
public System.Runtime.Remoting.Proxies.RealProxy : object {
private Type class_to_proxy
internal Context _targetContext
internal MarshalByRefObject _server
private int _targetDomainId
internal string _targetUri
internal Identity _objectIdentity
private object _objTP
private object _stubData
internal Identity ObjectIdentity
protected void .ctor(Type classToProxy)
internal void .ctor(Type classToProxy, ClientIdentity identity)
protected void .ctor(Type classToProxy, IntPtr stub, object stubData)
private Type InternalGetProxyType(object transparentProxy)
public Type GetProxiedType()
public ObjRef CreateObjRef(Type requestedType)
public void GetObjectData(SerializationInfo info, StreamingContext context)
internal Identity get_ObjectIdentity()
internal void set_ObjectIdentity(Identity value)
public IntPtr GetCOMIUnknown(bool fIsMarshalled)
public void SetCOMIUnknown(IntPtr i)
public IntPtr SupportsInterface(Guid& iid)
public object GetStubData(RealProxy rp)
public void SetStubData(RealProxy rp, object stubData)
public IMessage Invoke(IMessage msg)
internal object PrivateInvoke(RealProxy rp, IMessage msg, Exception& exc, Object[]& out_args)
internal object InternalGetTransparentProxy(string className)
public object GetTransparentProxy()
public IConstructionReturnMessage InitializeServerObject(IConstructionCallMessage ctorMsg)
protected void AttachServer(MarshalByRefObject s)
protected MarshalByRefObject DetachServer()
protected MarshalByRefObject GetUnwrappedServer()
internal void SetTargetDomain(int domainId)
internal object GetAppDomainTarget()
private Object[] ProcessResponse(IMethodReturnMessage mrm, MonoMethodMessage call)
}
internal System.Runtime.Remoting.Proxies.RemotingProxy : RealProxy {
private MethodInfo _cache_GetTypeMethod
private MethodInfo _cache_GetHashCodeMethod
private IMessageSink _sink
private bool _hasEnvoySink
private ConstructionCall _ctorCall
public string TypeName
internal void .ctor(Type type, ClientIdentity identity)
internal void .ctor(Type type, string activationUrl, Object[] activationAttributes)
public IMessage Invoke(IMessage request)
internal void AttachIdentity(Identity identity)
internal IMessage ActivateRemoteObject(IMethodMessage request)
public string get_TypeName()
public void set_TypeName(string value)
public bool CanCastTo(Type fromType, object o)
protected void Finalize()
}
internal System.Runtime.Remoting.Proxies.TransparentProxy : object {
public RealProxy _rp
private RuntimeRemoteClassHandle _class
private bool _custom_type_info
private bool IsContextBoundObject
private Context TargetContext
internal RuntimeType GetProxyType()
private bool get_IsContextBoundObject()
private Context get_TargetContext()
private bool InCurrentContext()
internal object LoadRemoteFieldNew(IntPtr classPtr, IntPtr fieldPtr)
internal void StoreRemoteField(IntPtr classPtr, IntPtr fieldPtr, object arg)
}
public System.Runtime.Remoting.RemotingConfiguration : object {
private string applicationID
private string applicationName
private string processGuid
private bool defaultConfigRead
private bool defaultDelayedConfigRead
private string _errorMode
private Hashtable wellKnownClientEntries
private Hashtable activatedClientEntries
private Hashtable wellKnownServiceEntries
private Hashtable activatedServiceEntries
private Hashtable channelTemplates
private Hashtable clientProviderTemplates
private Hashtable serverProviderTemplates
public string ApplicationId
public string ApplicationName
public CustomErrorsModes CustomErrorsMode
public string ProcessId
public string get_ApplicationId()
public string get_ApplicationName()
public void set_ApplicationName(string value)
public CustomErrorsModes get_CustomErrorsMode()
public void set_CustomErrorsMode(CustomErrorsModes value)
public string get_ProcessId()
public void Configure(string filename, bool ensureSecurity)
public void Configure(string filename)
private void ReadConfigString(string filename)
private void ReadConfigFile(string filename)
internal void LoadDefaultDelayedChannels()
public ActivatedClientTypeEntry[] GetRegisteredActivatedClientTypes()
public ActivatedServiceTypeEntry[] GetRegisteredActivatedServiceTypes()
public WellKnownClientTypeEntry[] GetRegisteredWellKnownClientTypes()
public WellKnownServiceTypeEntry[] GetRegisteredWellKnownServiceTypes()
public bool IsActivationAllowed(Type svrType)
public ActivatedClientTypeEntry IsRemotelyActivatedClientType(Type svrType)
public ActivatedClientTypeEntry IsRemotelyActivatedClientType(string typeName, string assemblyName)
public WellKnownClientTypeEntry IsWellKnownClientType(Type svrType)
public WellKnownClientTypeEntry IsWellKnownClientType(string typeName, string assemblyName)
public void RegisterActivatedClientType(ActivatedClientTypeEntry entry)
public void RegisterActivatedClientType(Type type, string appUrl)
public void RegisterActivatedServiceType(ActivatedServiceTypeEntry entry)
public void RegisterActivatedServiceType(Type type)
public void RegisterWellKnownClientType(Type type, string objectUrl)
public void RegisterWellKnownClientType(WellKnownClientTypeEntry entry)
public void RegisterWellKnownServiceType(Type type, string objectUri, WellKnownObjectMode mode)
public void RegisterWellKnownServiceType(WellKnownServiceTypeEntry entry)
internal void RegisterChannelTemplate(ChannelData channel)
internal void RegisterClientProviderTemplate(ProviderData prov)
internal void RegisterServerProviderTemplate(ProviderData prov)
internal void RegisterChannels(ArrayList channels, bool onlyDelayed)
internal void RegisterTypes(ArrayList types)
public bool CustomErrorsEnabled(bool isLocalRequest)
internal void SetCustomErrorsMode(string mode)
}
public System.Runtime.Remoting.RemotingException : SystemException {
public void .ctor(string message)
protected void .ctor(SerializationInfo info, StreamingContext context)
public void .ctor(string message, Exception InnerException)
}
public System.Runtime.Remoting.RemotingServices : object {
private Hashtable uri_hash
private BinaryFormatter _serializationFormatter
private BinaryFormatter _deserializationFormatter
private string app_id
private object app_id_lock
private int next_id
private BindingFlags methodBindings
private MethodInfo FieldSetterMethod
private MethodInfo FieldGetterMethod
internal object InternalExecute(MethodBase method, object obj, Object[] parameters, Object[]& out_args)
internal MethodBase GetVirtualMethod(Type type, MethodBase method)
public bool IsTransparentProxy(object proxy)
internal bool ProxyCheckCast(RealProxy rp, RuntimeType castType)
internal IMethodReturnMessage InternalExecuteMessage(MarshalByRefObject target, IMethodCallMessage reqMsg)
public IMethodReturnMessage ExecuteMessage(MarshalByRefObject target, IMethodCallMessage reqMsg)
public object Connect(Type classToProxy, string url)
public object Connect(Type classToProxy, string url, object data)
public bool Disconnect(MarshalByRefObject obj)
public Type GetServerTypeForUri(string URI)
public string GetObjectUri(MarshalByRefObject obj)
public object Unmarshal(ObjRef objectRef)
public object Unmarshal(ObjRef objectRef, bool fRefine)
public ObjRef Marshal(MarshalByRefObject Obj)
public ObjRef Marshal(MarshalByRefObject Obj, string URI)
public ObjRef Marshal(MarshalByRefObject Obj, string ObjURI, Type RequestedType)
private string NewUri()
public RealProxy GetRealProxy(object proxy)
public MethodBase GetMethodBaseFromMethodMessage(IMethodMessage msg)
internal MethodBase GetMethodBaseFromName(Type type, string methodName, Type[] signature)
private MethodBase FindInterfaceMethod(Type type, string methodName, Type[] signature)
public void GetObjectData(object obj, SerializationInfo info, StreamingContext context)
public ObjRef GetObjRefForProxy(MarshalByRefObject obj)
public object GetLifetimeService(MarshalByRefObject obj)
public IMessageSink GetEnvoyChainForProxy(MarshalByRefObject obj)
public void LogRemotingStage(int stage)
public string GetSessionIdForMethodMessage(IMethodMessage msg)
public bool IsMethodOverloaded(IMethodMessage msg)
public bool IsObjectOutOfAppDomain(object tp)
public bool IsObjectOutOfContext(object tp)
public bool IsOneWay(MethodBase method)
internal bool IsAsyncMessage(IMessage msg)
public void SetObjectUriForMarshal(MarshalByRefObject obj, string uri)
internal object CreateClientProxy(ActivatedClientTypeEntry entry, Object[] activationAttributes)
internal object CreateClientProxy(Type objectType, string url, Object[] activationAttributes)
internal object CreateClientProxy(WellKnownClientTypeEntry entry)
internal object CreateClientProxyForContextBound(Type type, Object[] activationAttributes)
internal object CreateClientProxyForComInterop(Type type)
internal Identity GetIdentityForUri(string uri)
private string RemoveAppNameFromUri(string uri)
internal Identity GetObjectIdentity(MarshalByRefObject obj)
internal ClientIdentity GetOrCreateClientIdentity(ObjRef objRef, Type proxyType, Object& clientProxy)
private IMessageSink GetClientChannelSinkChain(string url, object channelData, String& objectUri)
internal ClientActivatedIdentity CreateContextBoundObjectIdentity(Type objectType)
internal ClientActivatedIdentity CreateClientActivatedServerIdentity(MarshalByRefObject realObject, Type objectType, string objectUri)
internal ServerIdentity CreateWellKnownServerIdentity(Type objectType, string objectUri, WellKnownObjectMode mode)
private void RegisterServerIdentity(ServerIdentity identity)
internal object GetProxyForRemoteObject(ObjRef objref, Type classToProxy)
internal object GetRemoteObject(ObjRef objRef, Type proxyType)
internal object GetServerObject(string uri)
internal Byte[] SerializeCallData(object obj)
internal object DeserializeCallData(Byte[] array)
internal Byte[] SerializeExceptionData(Exception ex)
internal object GetDomainProxy(AppDomain domain)
private void RegisterInternalChannels()
internal void DisposeIdentity(Identity ident)
internal Identity GetMessageTargetIdentity(IMessage msg)
internal void SetMessageTargetIdentity(IMessage msg, Identity ident)
internal bool UpdateOutArgObject(ParameterInfo pi, object local, object remote)
private string GetNormalizedUri(string uri)
}
public System.Runtime.Remoting.RemotingTimeoutException : RemotingException {
public void .ctor(string message)
public void .ctor(string message, Exception InnerException)
internal void .ctor(SerializationInfo info, StreamingContext context)
}
public System.Runtime.Remoting.ServerException : SystemException {
public void .ctor(string message)
public void .ctor(string message, Exception InnerException)
internal void .ctor(SerializationInfo info, StreamingContext context)
}
internal System.Runtime.Remoting.ServerIdentity : Identity {
protected Type _objectType
protected MarshalByRefObject _serverObject
protected IMessageSink _serverSink
protected Context _context
protected Lease _lease
public Type ObjectType
public Lease Lease
public Context Context
public void .ctor(string objectUri, Context context, Type objectType)
public Type get_ObjectType()
public void StartTrackingLifetime(ILease lease)
public void OnLifetimeExpired()
public ObjRef CreateObjRef(Type requestedType)
public void AttachServerObject(MarshalByRefObject serverObject, Context context)
public Lease get_Lease()
public Context get_Context()
public void set_Context(Context value)
public IMessage SyncObjectProcessMessage(IMessage msg)
public IMessageCtrl AsyncObjectProcessMessage(IMessage msg, IMessageSink replySink)
protected void DisposeServerObject()
}
public System.Runtime.Remoting.Services.EnterpriseServicesHelper : object {
public IConstructionReturnMessage CreateConstructionReturnMessage(IConstructionCallMessage ctorMsg, MarshalByRefObject retObj)
public void SwitchWrappers(RealProxy oldcp, RealProxy newcp)
public object WrapIUnknownWithComObject(IntPtr punk)
}
public System.Runtime.Remoting.Services.ITrackingHandler {
public void DisconnectedObject(object obj)
public void MarshaledObject(object obj, ObjRef or)
public void UnmarshaledObject(object obj, ObjRef or)
}
public System.Runtime.Remoting.Services.TrackingServices : object {
private ArrayList _handlers
public ITrackingHandler[] RegisteredHandlers
public void RegisterTrackingHandler(ITrackingHandler handler)
public void UnregisterTrackingHandler(ITrackingHandler handler)
public ITrackingHandler[] get_RegisteredHandlers()
internal void NotifyMarshaledObject(object obj, ObjRef or)
internal void NotifyUnmarshaledObject(object obj, ObjRef or)
internal void NotifyDisconnectedObject(object obj)
}
internal System.Runtime.Remoting.SingleCallIdentity : ServerIdentity {
public void .ctor(string objectUri, Context context, Type objectType)
public IMessage SyncObjectProcessMessage(IMessage msg)
public IMessageCtrl AsyncObjectProcessMessage(IMessage msg, IMessageSink replySink)
}
internal System.Runtime.Remoting.SingletonIdentity : ServerIdentity {
public void .ctor(string objectUri, Context context, Type objectType)
public MarshalByRefObject GetServerObject()
public IMessage SyncObjectProcessMessage(IMessage msg)
public IMessageCtrl AsyncObjectProcessMessage(IMessage msg, IMessageSink replySink)
}
public System.Runtime.Remoting.SoapServices : object {
private Hashtable _xmlTypes
private Hashtable _xmlElements
private Hashtable _soapActions
private Hashtable _soapActionsMethods
private Hashtable _typeInfos
public string XmlNsForClrType
public string XmlNsForClrTypeWithAssembly
public string XmlNsForClrTypeWithNs
public string XmlNsForClrTypeWithNsAndAssembly
public string get_XmlNsForClrType()
public string get_XmlNsForClrTypeWithAssembly()
public string get_XmlNsForClrTypeWithNs()
public string get_XmlNsForClrTypeWithNsAndAssembly()
public string CodeXmlNamespaceForClrTypeNamespace(string typeNamespace, string assemblyName)
public bool DecodeXmlNamespaceForClrTypeNamespace(string inNamespace, String& typeNamespace, String& assemblyName)
public void GetInteropFieldTypeAndNameFromXmlAttribute(Type containingType, string xmlAttribute, string xmlNamespace, Type& type, String& name)
public void GetInteropFieldTypeAndNameFromXmlElement(Type containingType, string xmlElement, string xmlNamespace, Type& type, String& name)
private void GetInteropFieldInfo(Hashtable fields, string xmlName, string xmlNamespace, Type& type, String& name)
private string GetNameKey(string name, string namspace)
public Type GetInteropTypeFromXmlElement(string xmlElement, string xmlNamespace)
public Type GetInteropTypeFromXmlType(string xmlType, string xmlTypeNamespace)
private string GetAssemblyName(MethodBase mb)
public string GetSoapActionFromMethodBase(MethodBase mb)
public bool GetTypeAndMethodNameFromSoapAction(string soapAction, String& typeName, String& methodName)
public bool GetXmlElementForInteropType(Type type, String& xmlElement, String& xmlNamespace)
public string GetXmlNamespaceForMethodCall(MethodBase mb)
public string GetXmlNamespaceForMethodResponse(MethodBase mb)
public bool GetXmlTypeForInteropType(Type type, String& xmlType, String& xmlTypeNamespace)
public bool IsClrTypeNamespace(string namespaceString)
public bool IsSoapActionValidForMethodBase(string soapAction, MethodBase mb)
public void PreLoad(Assembly assembly)
public void PreLoad(Type type)
public void RegisterInteropXmlElement(string xmlElement, string xmlNamespace, Type type)
public void RegisterInteropXmlType(string xmlType, string xmlTypeNamespace, Type type)
public void RegisterSoapActionForMethodBase(MethodBase mb)
private string InternalGetSoapAction(MethodBase mb)
public void RegisterSoapActionForMethodBase(MethodBase mb, string soapAction)
private string EncodeNs(string ns)
private string DecodeNs(string ns)
}
public System.Runtime.Remoting.TypeEntry : object {
private string assembly_name
private string type_name
public string AssemblyName
public string TypeName
public string get_AssemblyName()
public void set_AssemblyName(string value)
public string get_TypeName()
public void set_TypeName(string value)
}
internal System.Runtime.Remoting.TypeInfo : object {
private string serverType
private String[] serverHierarchy
private String[] interfacesImplemented
public string TypeName
public void .ctor(Type type)
public string get_TypeName()
public void set_TypeName(string value)
public bool CanCastTo(Type fromType, object o)
}
public System.Runtime.Remoting.WellKnownClientTypeEntry : TypeEntry {
private Type obj_type
private string obj_url
private string app_url
public string ApplicationUrl
public Type ObjectType
public string ObjectUrl
public void .ctor(Type type, string objectUrl)
public void .ctor(string typeName, string assemblyName, string objectUrl)
public string get_ApplicationUrl()
public void set_ApplicationUrl(string value)
public Type get_ObjectType()
public string get_ObjectUrl()
public string ToString()
}
public System.Runtime.Remoting.WellKnownObjectMode : Enum {
public int value__
public WellKnownObjectMode Singleton
public WellKnownObjectMode SingleCall
}
public System.Runtime.Remoting.WellKnownServiceTypeEntry : TypeEntry {
private Type obj_type
private string obj_uri
private WellKnownObjectMode obj_mode
public IContextAttribute[] ContextAttributes
public WellKnownObjectMode Mode
public Type ObjectType
public string ObjectUri
public void .ctor(Type type, string objectUri, WellKnownObjectMode mode)
public void .ctor(string typeName, string assemblyName, string objectUri, WellKnownObjectMode mode)
public IContextAttribute[] get_ContextAttributes()
public void set_ContextAttributes(IContextAttribute[] value)
public WellKnownObjectMode get_Mode()
public Type get_ObjectType()
public string get_ObjectUri()
public string ToString()
}
internal System.Runtime.Serialization.DeserializationEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender)
public IAsyncResult BeginInvoke(object sender, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
internal System.Runtime.Serialization.FixupHolder : object {
internal int ArrayFixup
internal int MemberFixup
internal int DelayedFixup
internal long m_id
internal object m_fixupInfo
internal int m_fixupType
internal void .ctor(long id, object fixupInfo, int fixupType)
}
internal System.Runtime.Serialization.FixupHolderList : object {
internal int InitialSize
internal FixupHolder[] m_values
internal int m_count
internal void .ctor(int startingSize)
internal void Add(long id, object fixupInfo)
internal void Add(FixupHolder fixup)
private void EnlargeArray()
}
public System.Runtime.Serialization.Formatter : object {
protected ObjectIDGenerator m_idGenerator
protected Queue m_objectQueue
public ISurrogateSelector SurrogateSelector
public SerializationBinder Binder
public StreamingContext Context
public object Deserialize(Stream serializationStream)
protected object GetNext(Int64& objID)
protected long Schedule(object obj)
public void Serialize(Stream serializationStream, object graph)
protected void WriteArray(object obj, string name, Type memberType)
protected void WriteBoolean(bool val, string name)
protected void WriteByte(byte val, string name)
protected void WriteChar(char val, string name)
protected void WriteDateTime(DateTime val, string name)
protected void WriteDecimal(decimal val, string name)
protected void WriteDouble(double val, string name)
protected void WriteInt16(short val, string name)
protected void WriteInt32(int val, string name)
protected void WriteInt64(long val, string name)
protected void WriteObjectRef(object obj, string name, Type memberType)
protected void WriteMember(string memberName, object data)
protected void WriteSByte(sbyte val, string name)
protected void WriteSingle(float val, string name)
protected void WriteTimeSpan(TimeSpan val, string name)
protected void WriteUInt16(ushort val, string name)
protected void WriteUInt32(UInt32 val, string name)
protected void WriteUInt64(ulong val, string name)
protected void WriteValueType(object obj, string name, Type memberType)
public ISurrogateSelector get_SurrogateSelector()
public void set_SurrogateSelector(ISurrogateSelector value)
public SerializationBinder get_Binder()
public void set_Binder(SerializationBinder value)
public StreamingContext get_Context()
public void set_Context(StreamingContext value)
}
public System.Runtime.Serialization.FormatterConverter : object {
public object Convert(object value, Type type)
public object Convert(object value, TypeCode typeCode)
public bool ToBoolean(object value)
public char ToChar(object value)
public sbyte ToSByte(object value)
public byte ToByte(object value)
public short ToInt16(object value)
public ushort ToUInt16(object value)
public int ToInt32(object value)
public UInt32 ToUInt32(object value)
public long ToInt64(object value)
public ulong ToUInt64(object value)
public float ToSingle(object value)
public double ToDouble(object value)
public decimal ToDecimal(object value)
public DateTime ToDateTime(object value)
public string ToString(object value)
}
internal System.Runtime.Serialization.Formatters.Binary.__BinaryParser : object {
internal ObjectReader objectReader
internal Stream input
internal long topId
internal long headerId
internal SizedArray objectMapIdTable
internal SizedArray assemIdToAssemblyTable
internal SerStack stack
internal BinaryTypeEnum expectedType
internal object expectedTypeInformation
internal ParseRecord PRS
private BinaryAssemblyInfo systemAssemblyInfo
private BinaryReader dataReader
private Encoding encoding
private SerStack opPool
private BinaryObject binaryObject
private BinaryObjectWithMap bowm
private BinaryObjectWithMapTyped bowmt
internal BinaryObjectString objectString
internal BinaryCrossAppDomainString crossAppDomainString
internal MemberPrimitiveTyped memberPrimitiveTyped
private Byte[] byteBuffer
private int chunkSize
internal MemberPrimitiveUnTyped memberPrimitiveUnTyped
internal MemberReference memberReference
internal ObjectNull objectNull
internal MessageEnd modreq(System.Runtime.CompilerServices.IsVolatile) messageEnd
internal BinaryAssemblyInfo SystemAssemblyInfo
internal SizedArray ObjectMapIdTable
internal SizedArray AssemIdToAssemblyTable
internal ParseRecord prs
internal void .ctor(Stream stream, ObjectReader objectReader)
internal BinaryAssemblyInfo get_SystemAssemblyInfo()
internal SizedArray get_ObjectMapIdTable()
internal SizedArray get_AssemIdToAssemblyTable()
internal ParseRecord get_prs()
internal void Run()
internal void ReadBegin()
internal void ReadEnd()
internal bool ReadBoolean()
internal byte ReadByte()
internal Byte[] ReadBytes(int length)
internal void ReadBytes(Byte[] byteA, int offset, int size)
internal char ReadChar()
internal Char[] ReadChars(int length)
internal decimal ReadDecimal()
internal float ReadSingle()
internal double ReadDouble()
internal short ReadInt16()
internal int ReadInt32()
internal long ReadInt64()
internal sbyte ReadSByte()
internal string ReadString()
internal TimeSpan ReadTimeSpan()
internal DateTime ReadDateTime()
internal ushort ReadUInt16()
internal UInt32 ReadUInt32()
internal ulong ReadUInt64()
internal void ReadSerializationHeaderRecord()
internal void ReadAssembly(BinaryHeaderEnum binaryHeaderEnum)
internal void ReadMethodObject(BinaryHeaderEnum binaryHeaderEnum)
private void ReadObject()
internal void ReadCrossAppDomainMap()
internal void ReadObjectWithMap(BinaryHeaderEnum binaryHeaderEnum)
private void ReadObjectWithMap(BinaryObjectWithMap record)
internal void ReadObjectWithMapTyped(BinaryHeaderEnum binaryHeaderEnum)
private void ReadObjectWithMapTyped(BinaryObjectWithMapTyped record)
private void ReadObjectString(BinaryHeaderEnum binaryHeaderEnum)
private void ReadMemberPrimitiveTyped()
private void ReadArray(BinaryHeaderEnum binaryHeaderEnum)
private void ReadArrayAsBytes(ParseRecord pr)
private void ReadMemberPrimitiveUnTyped()
private void ReadMemberReference()
private void ReadObjectNull(BinaryHeaderEnum binaryHeaderEnum)
private void ReadMessageEnd()
internal object ReadValue(InternalPrimitiveTypeE code)
private ObjectProgress GetOp()
private void PutOp(ObjectProgress op)
}
internal System.Runtime.Serialization.Formatters.Binary.__BinaryWriter : object {
internal Stream sout
internal FormatterTypeStyle formatterTypeStyle
internal Hashtable objectMapTable
internal ObjectWriter objectWriter
internal BinaryWriter dataWriter
internal int m_nestedObjectCount
private int nullCount
internal BinaryMethodCall binaryMethodCall
internal BinaryMethodReturn binaryMethodReturn
internal BinaryObject binaryObject
internal BinaryObjectWithMap binaryObjectWithMap
internal BinaryObjectWithMapTyped binaryObjectWithMapTyped
internal BinaryObjectString binaryObjectString
internal BinaryArray binaryArray
private Byte[] byteBuffer
private int chunkSize
internal MemberPrimitiveUnTyped memberPrimitiveUnTyped
internal MemberPrimitiveTyped memberPrimitiveTyped
internal ObjectNull objectNull
internal MemberReference memberReference
internal BinaryAssembly binaryAssembly
internal void .ctor(Stream sout, ObjectWriter objectWriter, FormatterTypeStyle formatterTypeStyle)
internal void WriteBegin()
internal void WriteEnd()
internal void WriteBoolean(bool value)
internal void WriteByte(byte value)
private void WriteBytes(Byte[] value)
private void WriteBytes(Byte[] byteA, int offset, int size)
internal void WriteChar(char value)
internal void WriteChars(Char[] value)
internal void WriteDecimal(decimal value)
internal void WriteSingle(float value)
internal void WriteDouble(double value)
internal void WriteInt16(short value)
internal void WriteInt32(int value)
internal void WriteInt64(long value)
internal void WriteSByte(sbyte value)
internal void WriteString(string value)
internal void WriteTimeSpan(TimeSpan value)
internal void WriteDateTime(DateTime value)
internal void WriteUInt16(ushort value)
internal void WriteUInt32(UInt32 value)
internal void WriteUInt64(ulong value)
internal void WriteObjectEnd(NameInfo memberNameInfo, NameInfo typeNameInfo)
internal void WriteSerializationHeaderEnd()
internal void WriteSerializationHeader(int topId, int headerId, int minorVersion, int majorVersion)
internal void WriteMethodCall()
internal Object[] WriteCallArray(string uri, string methodName, string typeName, Type[] instArgs, Object[] args, object methodSignature, object callContext, Object[] properties)
internal void WriteMethodReturn()
internal Object[] WriteReturnArray(object returnValue, Object[] args, Exception exception, object callContext, Object[] properties)
internal void WriteObject(NameInfo nameInfo, NameInfo typeNameInfo, int numMembers, String[] memberNames, Type[] memberTypes, WriteObjectInfo[] memberObjectInfos)
internal void WriteObjectString(int objectId, string value)
internal void WriteSingleArray(NameInfo memberNameInfo, NameInfo arrayNameInfo, WriteObjectInfo objectInfo, NameInfo arrayElemTypeNameInfo, int length, int lowerBound, Array array)
private void WriteArrayAsBytes(Array array, int typeLength)
internal void WriteJaggedArray(NameInfo memberNameInfo, NameInfo arrayNameInfo, WriteObjectInfo objectInfo, NameInfo arrayElemTypeNameInfo, int length, int lowerBound)
internal void WriteRectangleArray(NameInfo memberNameInfo, NameInfo arrayNameInfo, WriteObjectInfo objectInfo, NameInfo arrayElemTypeNameInfo, int rank, Int32[] lengthA, Int32[] lowerBoundA)
internal void WriteObjectByteArray(NameInfo memberNameInfo, NameInfo arrayNameInfo, WriteObjectInfo objectInfo, NameInfo arrayElemTypeNameInfo, int length, int lowerBound, Byte[] byteA)
internal void WriteMember(NameInfo memberNameInfo, NameInfo typeNameInfo, object value)
internal void WriteNullMember(NameInfo memberNameInfo, NameInfo typeNameInfo)
internal void WriteMemberObjectRef(NameInfo memberNameInfo, int idRef)
internal void WriteMemberNested(NameInfo memberNameInfo)
internal void WriteMemberString(NameInfo memberNameInfo, NameInfo typeNameInfo, string value)
internal void WriteItem(NameInfo itemNameInfo, NameInfo typeNameInfo, object value)
internal void WriteNullItem(NameInfo itemNameInfo, NameInfo typeNameInfo)
internal void WriteDelayedNullItem()
internal void WriteItemEnd()
private void InternalWriteItemNull()
internal void WriteItemObjectRef(NameInfo nameInfo, int idRef)
internal void WriteAssembly(Type type, string assemblyString, int assemId, bool isNew)
internal void WriteValue(InternalPrimitiveTypeE code, object value)
}
internal System.Runtime.Serialization.Formatters.Binary.BinaryArray : object {
internal int objectId
internal int rank
internal Int32[] lengthA
internal Int32[] lowerBoundA
internal BinaryTypeEnum binaryTypeEnum
internal object typeInformation
internal int assemId
private BinaryHeaderEnum binaryHeaderEnum
internal BinaryArrayTypeEnum binaryArrayTypeEnum
internal void .ctor(BinaryHeaderEnum binaryHeaderEnum)
internal void Set(int objectId, int rank, Int32[] lengthA, Int32[] lowerBoundA, BinaryTypeEnum binaryTypeEnum, object typeInformation, BinaryArrayTypeEnum binaryArrayTypeEnum, int assemId)
public void Write(__BinaryWriter sout)
public void Read(__BinaryParser input)
}
internal System.Runtime.Serialization.Formatters.Binary.BinaryArrayTypeEnum : Enum {
public int value__
public BinaryArrayTypeEnum Single
public BinaryArrayTypeEnum Jagged
public BinaryArrayTypeEnum Rectangular
public BinaryArrayTypeEnum SingleOffset
public BinaryArrayTypeEnum JaggedOffset
public BinaryArrayTypeEnum RectangularOffset
}
internal System.Runtime.Serialization.Formatters.Binary.BinaryAssembly : object {
internal int assemId
internal string assemblyString
internal void Set(int assemId, string assemblyString)
public void Write(__BinaryWriter sout)
public void Read(__BinaryParser input)
public void Dump()
private void DumpInternal()
}
internal System.Runtime.Serialization.Formatters.Binary.BinaryAssemblyInfo : object {
internal string assemblyString
private Assembly assembly
internal void .ctor(string assemblyString)
internal void .ctor(string assemblyString, Assembly assembly)
internal Assembly GetAssembly()
}
internal System.Runtime.Serialization.Formatters.Binary.BinaryConverter : object {
internal BinaryTypeEnum GetBinaryTypeInfo(Type type, WriteObjectInfo objectInfo, string typeName, ObjectWriter objectWriter, Object& typeInformation, Int32& assemId)
internal BinaryTypeEnum GetParserBinaryTypeInfo(Type type, Object& typeInformation)
internal void WriteTypeInfo(BinaryTypeEnum binaryTypeEnum, object typeInformation, int assemId, __BinaryWriter sout)
internal object ReadTypeInfo(BinaryTypeEnum binaryTypeEnum, __BinaryParser input, Int32& assemId)
internal void TypeFromInfo(BinaryTypeEnum binaryTypeEnum, object typeInformation, ObjectReader objectReader, BinaryAssemblyInfo assemblyInfo, InternalPrimitiveTypeE& primitiveTypeEnum, String& typeString, Type& type, Boolean& isVariant)
}
internal System.Runtime.Serialization.Formatters.Binary.BinaryCrossAppDomainAssembly : object {
internal int assemId
internal int assemblyIndex
public void Write(__BinaryWriter sout)
public void Read(__BinaryParser input)
public void Dump()
private void DumpInternal()
}
internal System.Runtime.Serialization.Formatters.Binary.BinaryCrossAppDomainMap : object {
internal int crossAppDomainArrayIndex
public void Write(__BinaryWriter sout)
public void Read(__BinaryParser input)
public void Dump()
private void DumpInternal()
}
internal System.Runtime.Serialization.Formatters.Binary.BinaryCrossAppDomainString : object {
internal int objectId
internal int value
public void Write(__BinaryWriter sout)
public void Read(__BinaryParser input)
public void Dump()
private void DumpInternal()
}
public System.Runtime.Serialization.Formatters.Binary.BinaryFormatter : object {
internal ISurrogateSelector m_surrogates
internal StreamingContext m_context
internal SerializationBinder m_binder
internal FormatterTypeStyle m_typeFormat
internal FormatterAssemblyStyle m_assemblyFormat
internal TypeFilterLevel m_securityLevel
internal Object[] m_crossAppDomainArray
private Dictionary`2<Type, TypeInformation> typeNameCache
public FormatterTypeStyle TypeFormat
public FormatterAssemblyStyle AssemblyFormat
public TypeFilterLevel FilterLevel
public ISurrogateSelector SurrogateSelector
public SerializationBinder Binder
public StreamingContext Context
public FormatterTypeStyle get_TypeFormat()
public void set_TypeFormat(FormatterTypeStyle value)
public FormatterAssemblyStyle get_AssemblyFormat()
public void set_AssemblyFormat(FormatterAssemblyStyle value)
public TypeFilterLevel get_FilterLevel()
public void set_FilterLevel(TypeFilterLevel value)
public ISurrogateSelector get_SurrogateSelector()
public void set_SurrogateSelector(ISurrogateSelector value)
public SerializationBinder get_Binder()
public void set_Binder(SerializationBinder value)
public StreamingContext get_Context()
public void set_Context(StreamingContext value)
public void .ctor(ISurrogateSelector selector, StreamingContext context)
public object Deserialize(Stream serializationStream)
internal object Deserialize(Stream serializationStream, HeaderHandler handler, bool fCheck)
public object Deserialize(Stream serializationStream, HeaderHandler handler)
public object DeserializeMethodResponse(Stream serializationStream, HeaderHandler handler, IMethodCallMessage methodCallMessage)
public object UnsafeDeserialize(Stream serializationStream, HeaderHandler handler)
public object UnsafeDeserializeMethodResponse(Stream serializationStream, HeaderHandler handler, IMethodCallMessage methodCallMessage)
internal object Deserialize(Stream serializationStream, HeaderHandler handler, bool fCheck, IMethodCallMessage methodCallMessage)
internal object Deserialize(Stream serializationStream, HeaderHandler handler, bool fCheck, bool isCrossAppDomain, IMethodCallMessage methodCallMessage)
public void Serialize(Stream serializationStream, object graph)
public void Serialize(Stream serializationStream, object graph, Header[] headers)
internal void Serialize(Stream serializationStream, object graph, Header[] headers, bool fCheck)
internal TypeInformation GetTypeInformation(Type type)
}
internal System.Runtime.Serialization.Formatters.Binary.BinaryHeaderEnum : Enum {
public int value__
public BinaryHeaderEnum SerializedStreamHeader
public BinaryHeaderEnum Object
public BinaryHeaderEnum ObjectWithMap
public BinaryHeaderEnum ObjectWithMapAssemId
public BinaryHeaderEnum ObjectWithMapTyped
public BinaryHeaderEnum ObjectWithMapTypedAssemId
public BinaryHeaderEnum ObjectString
public BinaryHeaderEnum Array
public BinaryHeaderEnum MemberPrimitiveTyped
public BinaryHeaderEnum MemberReference
public BinaryHeaderEnum ObjectNull
public BinaryHeaderEnum MessageEnd
public BinaryHeaderEnum Assembly
public BinaryHeaderEnum ObjectNullMultiple256
public BinaryHeaderEnum ObjectNullMultiple
public BinaryHeaderEnum ArraySinglePrimitive
public BinaryHeaderEnum ArraySingleObject
public BinaryHeaderEnum ArraySingleString
public BinaryHeaderEnum CrossAppDomainMap
public BinaryHeaderEnum CrossAppDomainString
public BinaryHeaderEnum CrossAppDomainAssembly
public BinaryHeaderEnum MethodCall
public BinaryHeaderEnum MethodReturn
}
internal System.Runtime.Serialization.Formatters.Binary.BinaryMethodCall : object {
private string uri
private string methodName
private string typeName
private Type[] instArgs
private Object[] args
private object methodSignature
private object callContext
private string scallContext
private object properties
private Type[] argTypes
private bool bArgsPrimitive
private MessageEnum messageEnum
private Object[] callA
internal Object[] WriteArray(string uri, string methodName, string typeName, Type[] instArgs, Object[] args, object methodSignature, object callContext, Object[] properties)
internal void Write(__BinaryWriter sout)
internal void Read(__BinaryParser input)
internal IMethodCallMessage ReadArray(Object[] callA, object handlerObject)
internal void Dump()
private void DumpInternal()
}
internal System.Runtime.Serialization.Formatters.Binary.BinaryMethodCallMessage : object {
private Object[] _inargs
private string _methodName
private string _typeName
private object _methodSignature
private Type[] _instArgs
private Object[] _args
private LogicalCallContext _logicalCallContext
private Object[] _properties
public string MethodName
public string TypeName
public Type[] InstantiationArgs
public object MethodSignature
public Object[] Args
public LogicalCallContext LogicalCallContext
public bool HasProperties
internal void .ctor(string uri, string methodName, string typeName, Type[] instArgs, Object[] args, object methodSignature, LogicalCallContext callContext, Object[] properties)
public string get_MethodName()
public string get_TypeName()
public Type[] get_InstantiationArgs()
public object get_MethodSignature()
public Object[] get_Args()
public LogicalCallContext get_LogicalCallContext()
public bool get_HasProperties()
internal void PopulateMessageProperties(IDictionary dict)
}
internal System.Runtime.Serialization.Formatters.Binary.BinaryMethodReturn : object {
private object returnValue
private Object[] args
private Exception exception
private object callContext
private string scallContext
private object properties
private Type[] argTypes
private bool bArgsPrimitive
private MessageEnum messageEnum
private Object[] callA
private Type returnType
private object instanceOfVoid
internal Object[] WriteArray(object returnValue, Object[] args, Exception exception, object callContext, Object[] properties)
public void Write(__BinaryWriter sout)
public void Read(__BinaryParser input)
internal IMethodReturnMessage ReadArray(Object[] returnA, IMethodCallMessage methodCallMessage, object handlerObject)
public void Dump()
private void DumpInternal()
}
internal System.Runtime.Serialization.Formatters.Binary.BinaryMethodReturnMessage : object {
private Object[] _outargs
private Exception _exception
private object _returnValue
private Object[] _args
private LogicalCallContext _logicalCallContext
private Object[] _properties
public Exception Exception
public object ReturnValue
public Object[] Args
public LogicalCallContext LogicalCallContext
public bool HasProperties
internal void .ctor(object returnValue, Object[] args, Exception e, LogicalCallContext callContext, Object[] properties)
public Exception get_Exception()
public object get_ReturnValue()
public Object[] get_Args()
public LogicalCallContext get_LogicalCallContext()
public bool get_HasProperties()
internal void PopulateMessageProperties(IDictionary dict)
}
internal System.Runtime.Serialization.Formatters.Binary.BinaryObject : object {
internal int objectId
internal int mapId
internal void Set(int objectId, int mapId)
public void Write(__BinaryWriter sout)
public void Read(__BinaryParser input)
public void Dump()
private void DumpInternal()
}
internal System.Runtime.Serialization.Formatters.Binary.BinaryObjectString : object {
internal int objectId
internal string value
internal void Set(int objectId, string value)
public void Write(__BinaryWriter sout)
public void Read(__BinaryParser input)
public void Dump()
private void DumpInternal()
}
internal System.Runtime.Serialization.Formatters.Binary.BinaryObjectWithMap : object {
internal BinaryHeaderEnum binaryHeaderEnum
internal int objectId
internal string name
internal int numMembers
internal String[] memberNames
internal int assemId
internal void .ctor(BinaryHeaderEnum binaryHeaderEnum)
internal void Set(int objectId, string name, int numMembers, String[] memberNames, int assemId)
public void Write(__BinaryWriter sout)
public void Read(__BinaryParser input)
public void Dump()
private void DumpInternal()
}
internal System.Runtime.Serialization.Formatters.Binary.BinaryObjectWithMapTyped : object {
internal BinaryHeaderEnum binaryHeaderEnum
internal int objectId
internal string name
internal int numMembers
internal String[] memberNames
internal BinaryTypeEnum[] binaryTypeEnumA
internal Object[] typeInformationA
internal Int32[] memberAssemIds
internal int assemId
internal void .ctor(BinaryHeaderEnum binaryHeaderEnum)
internal void Set(int objectId, string name, int numMembers, String[] memberNames, BinaryTypeEnum[] binaryTypeEnumA, Object[] typeInformationA, Int32[] memberAssemIds, int assemId)
public void Write(__BinaryWriter sout)
public void Read(__BinaryParser input)
}
internal System.Runtime.Serialization.Formatters.Binary.BinaryTypeEnum : Enum {
public int value__
public BinaryTypeEnum Primitive
public BinaryTypeEnum String
public BinaryTypeEnum Object
public BinaryTypeEnum ObjectUrt
public BinaryTypeEnum ObjectUser
public BinaryTypeEnum ObjectArray
public BinaryTypeEnum StringArray
public BinaryTypeEnum PrimitiveArray
}
internal System.Runtime.Serialization.Formatters.Binary.BinaryUtil : object {
public void NVTraceI(string name, string value)
public void NVTraceI(string name, object value)
}
internal System.Runtime.Serialization.Formatters.Binary.Converter : object {
private int primitiveTypeEnumLength
private Type[] modreq(System.Runtime.CompilerServices.IsVolatile) typeA
private Type[] modreq(System.Runtime.CompilerServices.IsVolatile) arrayTypeA
private String[] modreq(System.Runtime.CompilerServices.IsVolatile) valueA
private TypeCode[] modreq(System.Runtime.CompilerServices.IsVolatile) typeCodeA
private InternalPrimitiveTypeE[] modreq(System.Runtime.CompilerServices.IsVolatile) codeA
internal Type typeofISerializable
internal Type typeofString
internal Type typeofConverter
internal Type typeofBoolean
internal Type typeofByte
internal Type typeofChar
internal Type typeofDecimal
internal Type typeofDouble
internal Type typeofInt16
internal Type typeofInt32
internal Type typeofInt64
internal Type typeofSByte
internal Type typeofSingle
internal Type typeofTimeSpan
internal Type typeofDateTime
internal Type typeofUInt16
internal Type typeofUInt32
internal Type typeofUInt64
internal Type typeofObject
internal Type typeofSystemVoid
internal Assembly urtAssembly
internal string urtAssemblyString
internal Type typeofTypeArray
internal Type typeofObjectArray
internal Type typeofStringArray
internal Type typeofBooleanArray
internal Type typeofByteArray
internal Type typeofCharArray
internal Type typeofDecimalArray
internal Type typeofDoubleArray
internal Type typeofInt16Array
internal Type typeofInt32Array
internal Type typeofInt64Array
internal Type typeofSByteArray
internal Type typeofSingleArray
internal Type typeofTimeSpanArray
internal Type typeofDateTimeArray
internal Type typeofUInt16Array
internal Type typeofUInt32Array
internal Type typeofUInt64Array
internal Type typeofMarshalByRefObject
internal InternalPrimitiveTypeE ToCode(Type type)
internal bool IsWriteAsByteArray(InternalPrimitiveTypeE code)
internal int TypeLength(InternalPrimitiveTypeE code)
internal InternalNameSpaceE GetNameSpaceEnum(InternalPrimitiveTypeE code, Type type, WriteObjectInfo objectInfo, String& typeName)
internal Type ToArrayType(InternalPrimitiveTypeE code)
private void InitTypeA()
private void InitArrayTypeA()
internal Type ToType(InternalPrimitiveTypeE code)
internal Array CreatePrimitiveArray(InternalPrimitiveTypeE code, int length)
internal bool IsPrimitiveArray(Type type, Object& typeInformation)
private void InitValueA()
internal string ToComType(InternalPrimitiveTypeE code)
private void InitTypeCodeA()
internal TypeCode ToTypeCode(InternalPrimitiveTypeE code)
private void InitCodeA()
internal InternalPrimitiveTypeE ToPrimitiveTypeEnum(TypeCode typeCode)
internal object FromString(string value, InternalPrimitiveTypeE code)
}
internal System.Runtime.Serialization.Formatters.Binary.InternalArrayTypeE : Enum {
public int value__
public InternalArrayTypeE Empty
public InternalArrayTypeE Single
public InternalArrayTypeE Jagged
public InternalArrayTypeE Rectangular
public InternalArrayTypeE Base64
}
internal System.Runtime.Serialization.Formatters.Binary.InternalElementTypeE : Enum {
public int value__
public InternalElementTypeE ObjectBegin
public InternalElementTypeE ObjectEnd
public InternalElementTypeE Member
}
internal System.Runtime.Serialization.Formatters.Binary.InternalFE : object {
internal FormatterTypeStyle FEtypeFormat
internal FormatterAssemblyStyle FEassemblyFormat
internal TypeFilterLevel FEsecurityLevel
internal InternalSerializerTypeE FEserializerTypeEnum
}
internal System.Runtime.Serialization.Formatters.Binary.InternalMemberTypeE : Enum {
public int value__
public InternalMemberTypeE Empty
public InternalMemberTypeE Header
public InternalMemberTypeE Field
public InternalMemberTypeE Item
}
internal System.Runtime.Serialization.Formatters.Binary.InternalMemberValueE : Enum {
public int value__
public InternalMemberValueE Empty
public InternalMemberValueE InlineValue
public InternalMemberValueE Nested
public InternalMemberValueE Reference
public InternalMemberValueE Null
}
internal System.Runtime.Serialization.Formatters.Binary.InternalNameSpaceE : Enum {
public int value__
public InternalNameSpaceE None
public InternalNameSpaceE Soap
public InternalNameSpaceE XdrPrimitive
public InternalNameSpaceE XdrString
public InternalNameSpaceE UrtSystem
public InternalNameSpaceE UrtUser
public InternalNameSpaceE UserNameSpace
public InternalNameSpaceE MemberName
public InternalNameSpaceE Interop
public InternalNameSpaceE CallElement
}
internal System.Runtime.Serialization.Formatters.Binary.InternalObjectPositionE : Enum {
public int value__
public InternalObjectPositionE Empty
public InternalObjectPositionE Top
public InternalObjectPositionE Child
public InternalObjectPositionE Headers
}
internal System.Runtime.Serialization.Formatters.Binary.InternalObjectTypeE : Enum {
public int value__
public InternalObjectTypeE Empty
public InternalObjectTypeE Object
public InternalObjectTypeE Array
}
internal System.Runtime.Serialization.Formatters.Binary.InternalParseStateE : Enum {
public int value__
public InternalParseStateE Initial
public InternalParseStateE Object
public InternalParseStateE Member
public InternalParseStateE MemberChild
}
internal System.Runtime.Serialization.Formatters.Binary.InternalParseTypeE : Enum {
public int value__
public InternalParseTypeE Empty
public InternalParseTypeE SerializedStreamHeader
public InternalParseTypeE Object
public InternalParseTypeE Member
public InternalParseTypeE ObjectEnd
public InternalParseTypeE MemberEnd
public InternalParseTypeE Headers
public InternalParseTypeE HeadersEnd
public InternalParseTypeE SerializedStreamHeaderEnd
public InternalParseTypeE Envelope
public InternalParseTypeE EnvelopeEnd
public InternalParseTypeE Body
public InternalParseTypeE BodyEnd
}
internal System.Runtime.Serialization.Formatters.Binary.InternalPrimitiveTypeE : Enum {
public int value__
public InternalPrimitiveTypeE Invalid
public InternalPrimitiveTypeE Boolean
public InternalPrimitiveTypeE Byte
public InternalPrimitiveTypeE Char
public InternalPrimitiveTypeE Currency
public InternalPrimitiveTypeE Decimal
public InternalPrimitiveTypeE Double
public InternalPrimitiveTypeE Int16
public InternalPrimitiveTypeE Int32
public InternalPrimitiveTypeE Int64
public InternalPrimitiveTypeE SByte
public InternalPrimitiveTypeE Single
public InternalPrimitiveTypeE TimeSpan
public InternalPrimitiveTypeE DateTime
public InternalPrimitiveTypeE UInt16
public InternalPrimitiveTypeE UInt32
public InternalPrimitiveTypeE UInt64
public InternalPrimitiveTypeE Null
public InternalPrimitiveTypeE String
}
internal System.Runtime.Serialization.Formatters.Binary.InternalSerializerTypeE : Enum {
public int value__
public InternalSerializerTypeE Soap
public InternalSerializerTypeE Binary
}
internal System.Runtime.Serialization.Formatters.Binary.IntSizedArray : object {
internal Int32[] objects
internal Int32[] negObjects
internal int Item
private void .ctor(IntSizedArray sizedArray)
public object Clone()
internal int get_Item(int index)
internal void set_Item(int index, int value)
internal void IncreaseCapacity(int index)
}
internal System.Runtime.Serialization.Formatters.Binary.IOUtil : object {
internal bool FlagTest(MessageEnum flag, MessageEnum target)
internal void WriteStringWithCode(string value, __BinaryWriter sout)
internal void WriteWithCode(Type type, object value, __BinaryWriter sout)
internal object ReadWithCode(__BinaryParser input)
internal Object[] ReadArgs(__BinaryParser input)
}
internal System.Runtime.Serialization.Formatters.Binary.IStreamable {
public void Read(__BinaryParser input)
public void Write(__BinaryWriter sout)
}
internal System.Runtime.Serialization.Formatters.Binary.MemberPrimitiveTyped : object {
internal InternalPrimitiveTypeE primitiveTypeEnum
internal object value
internal void Set(InternalPrimitiveTypeE primitiveTypeEnum, object value)
public void Write(__BinaryWriter sout)
public void Read(__BinaryParser input)
public void Dump()
private void DumpInternal()
}
internal System.Runtime.Serialization.Formatters.Binary.MemberPrimitiveUnTyped : object {
internal InternalPrimitiveTypeE typeInformation
internal object value
internal void Set(InternalPrimitiveTypeE typeInformation, object value)
internal void Set(InternalPrimitiveTypeE typeInformation)
public void Write(__BinaryWriter sout)
public void Read(__BinaryParser input)
public void Dump()
private void DumpInternal()
}
internal System.Runtime.Serialization.Formatters.Binary.MemberReference : object {
internal int idRef
internal void Set(int idRef)
public void Write(__BinaryWriter sout)
public void Read(__BinaryParser input)
public void Dump()
private void DumpInternal()
}
internal System.Runtime.Serialization.Formatters.Binary.MessageEnd : object {
public void Write(__BinaryWriter sout)
public void Read(__BinaryParser input)
public void Dump()
public void Dump(Stream sout)
private void DumpInternal(Stream sout)
}
internal System.Runtime.Serialization.Formatters.Binary.MessageEnum : Enum {
public int value__
public MessageEnum NoArgs
public MessageEnum ArgsInline
public MessageEnum ArgsIsArray
public MessageEnum ArgsInArray
public MessageEnum NoContext
public MessageEnum ContextInline
public MessageEnum ContextInArray
public MessageEnum MethodSignatureInArray
public MessageEnum PropertyInArray
public MessageEnum NoReturnValue
public MessageEnum ReturnValueVoid
public MessageEnum ReturnValueInline
public MessageEnum ReturnValueInArray
public MessageEnum ExceptionInArray
public MessageEnum GenericMethod
}
internal System.Runtime.Serialization.Formatters.Binary.NameCache : object {
private ConcurrentDictionary`2<string, object> ht
private string name
internal object GetCachedValue(string name)
internal void SetCachedValue(object value)
}
internal System.Runtime.Serialization.Formatters.Binary.NameInfo : object {
internal string NIFullName
internal long NIobjectId
internal long NIassemId
internal InternalPrimitiveTypeE NIprimitiveTypeEnum
internal Type NItype
internal bool NIisSealed
internal bool NIisArray
internal bool NIisArrayItem
internal bool NItransmitTypeOnObject
internal bool NItransmitTypeOnMember
internal bool NIisParentTypeOnObject
internal InternalArrayTypeE NIarrayEnum
private bool NIsealedStatusChecked
public bool IsSealed
public string NIname
internal void Init()
public bool get_IsSealed()
public string get_NIname()
public void set_NIname(string value)
}
internal System.Runtime.Serialization.Formatters.Binary.ObjectMap : object {
internal string objectName
internal Type objectType
internal BinaryTypeEnum[] binaryTypeEnumA
internal Object[] typeInformationA
internal Type[] memberTypes
internal String[] memberNames
internal ReadObjectInfo objectInfo
internal bool isInitObjectInfo
internal ObjectReader objectReader
internal int objectId
internal BinaryAssemblyInfo assemblyInfo
internal void .ctor(string objectName, Type objectType, String[] memberNames, ObjectReader objectReader, int objectId, BinaryAssemblyInfo assemblyInfo)
internal void .ctor(string objectName, String[] memberNames, BinaryTypeEnum[] binaryTypeEnumA, Object[] typeInformationA, Int32[] memberAssemIds, ObjectReader objectReader, int objectId, BinaryAssemblyInfo assemblyInfo, SizedArray assemIdToAssemblyTable)
internal ReadObjectInfo CreateObjectInfo(SerializationInfo& si, Object[]& memberData)
internal ObjectMap Create(string name, Type objectType, String[] memberNames, ObjectReader objectReader, int objectId, BinaryAssemblyInfo assemblyInfo)
internal ObjectMap Create(string name, String[] memberNames, BinaryTypeEnum[] binaryTypeEnumA, Object[] typeInformationA, Int32[] memberAssemIds, ObjectReader objectReader, int objectId, BinaryAssemblyInfo assemblyInfo, SizedArray assemIdToAssemblyTable)
}
internal System.Runtime.Serialization.Formatters.Binary.ObjectMapInfo : object {
internal int objectId
private int numMembers
private String[] memberNames
private Type[] memberTypes
internal void .ctor(int objectId, int numMembers, String[] memberNames, Type[] memberTypes)
internal bool isCompatible(int numMembers, String[] memberNames, Type[] memberTypes)
}
internal System.Runtime.Serialization.Formatters.Binary.ObjectNull : object {
internal int nullCount
internal void SetNullCount(int nullCount)
public void Write(__BinaryWriter sout)
public void Read(__BinaryParser input)
public void Read(__BinaryParser input, BinaryHeaderEnum binaryHeaderEnum)
public void Dump()
private void DumpInternal()
}
internal System.Runtime.Serialization.Formatters.Binary.ObjectProgress : object {
internal int opRecordIdCount
internal int opRecordId
internal bool isInitial
internal int count
internal BinaryTypeEnum expectedType
internal object expectedTypeInformation
internal string name
internal InternalObjectTypeE objectTypeEnum
internal InternalMemberTypeE memberTypeEnum
internal InternalMemberValueE memberValueEnum
internal Type dtType
internal int numItems
internal BinaryTypeEnum binaryTypeEnum
internal object typeInformation
internal int nullCount
internal int memberLength
internal BinaryTypeEnum[] binaryTypeEnumA
internal Object[] typeInformationA
internal String[] memberNames
internal Type[] memberTypes
internal ParseRecord pr
private void Counter()
internal void Init()
internal void ArrayCountIncrement(int value)
internal bool GetNext(BinaryTypeEnum& outBinaryTypeEnum, Object& outTypeInformation)
}
internal System.Runtime.Serialization.Formatters.Binary.ObjectReader : object {
internal Stream m_stream
internal ISurrogateSelector m_surrogates
internal StreamingContext m_context
internal ObjectManager m_objectManager
internal InternalFE formatterEnums
internal SerializationBinder m_binder
internal long topId
internal bool bSimpleAssembly
internal object handlerObject
internal object m_topObject
internal Header[] headers
internal HeaderHandler handler
internal SerObjectInfoInit serObjectInfoInit
internal IFormatterConverter m_formatterConverter
internal SerStack stack
private SerStack valueFixupStack
internal Object[] crossAppDomainArray
private bool bFullDeserialization
private bool bMethodCall
private bool bMethodReturn
private BinaryMethodCall binaryMethodCall
private BinaryMethodReturn binaryMethodReturn
private bool bIsCrossAppDomain
private int THRESHOLD_FOR_VALUETYPE_IDS
private bool bOldFormatDetected
private IntSizedArray valTypeObjectIdTable
private NameCache typeCache
private string previousAssemblyString
private string previousName
private Type previousType
private SerStack ValueFixupStack
internal object TopObject
private bool IsRemoting
private SerStack get_ValueFixupStack()
internal object get_TopObject()
internal void set_TopObject(object value)
internal void SetMethodCall(BinaryMethodCall binaryMethodCall)
internal void SetMethodReturn(BinaryMethodReturn binaryMethodReturn)
internal void .ctor(Stream stream, ISurrogateSelector selector, StreamingContext context, InternalFE formatterEnums, SerializationBinder binder)
internal object Deserialize(HeaderHandler handler, __BinaryParser serParser, bool fCheck, bool isCrossAppDomain, IMethodCallMessage methodCallMessage)
private bool HasSurrogate(Type t)
private void CheckSerializable(Type t)
private void InitFullDeserialization()
internal object CrossAppDomainArray(int index)
internal ReadObjectInfo CreateReadObjectInfo(Type objectType)
internal ReadObjectInfo CreateReadObjectInfo(Type objectType, String[] memberNames, Type[] memberTypes)
internal void Parse(ParseRecord pr)
private void ParseError(ParseRecord processing, ParseRecord onStack)
private void ParseSerializedStreamHeader(ParseRecord pr)
private void ParseSerializedStreamHeaderEnd(ParseRecord pr)
private bool get_IsRemoting()
internal void CheckSecurity(ParseRecord pr)
private void ParseObject(ParseRecord pr)
private void ParseObjectEnd(ParseRecord pr)
private void ParseArray(ParseRecord pr)
private void NextRectangleMap(ParseRecord pr)
private void ParseArrayMember(ParseRecord pr)
private void ParseArrayMemberEnd(ParseRecord pr)
private void ParseMember(ParseRecord pr)
private void ParseMemberEnd(ParseRecord pr)
private void ParseString(ParseRecord pr, ParseRecord parentPr)
private void RegisterObject(object obj, ParseRecord pr, ParseRecord objectPr)
private void RegisterObject(object obj, ParseRecord pr, ParseRecord objectPr, bool bIsString)
internal long GetId(long objectId)
private void IndexTraceMessage(string message, Int32[] index)
internal Type Bind(string assemblyString, string typeString)
internal Type FastBindToType(string assemblyName, string typeName)
private Assembly ResolveSimpleAssemblyName(AssemblyName assemblyName)
private void GetSimplyNamedTypeFromAssembly(Assembly assm, string typeName, Type& type)
internal Type GetType(BinaryAssemblyInfo assemblyInfo, string name)
private void CheckTypeForwardedTo(Assembly sourceAssembly, Assembly destAssembly, Type resolvedType)
}
internal System.Runtime.Serialization.Formatters.Binary.ObjectWriter : object {
private Queue m_objectQueue
private ObjectIDGenerator m_idGenerator
private int m_currentId
private ISurrogateSelector m_surrogates
private StreamingContext m_context
private __BinaryWriter serWriter
private SerializationObjectManager m_objectManager
private long topId
private string topName
private Header[] headers
private InternalFE formatterEnums
private SerializationBinder m_binder
private SerObjectInfoInit serObjectInfoInit
private IFormatterConverter m_formatterConverter
internal Object[] crossAppDomainArray
internal ArrayList internalCrossAppDomainArray
private object previousObj
private long previousId
private Type previousType
private InternalPrimitiveTypeE previousCode
private Hashtable assemblyToIdTable
private SerStack niPool
internal SerializationObjectManager ObjectManager
internal void .ctor(ISurrogateSelector selector, StreamingContext context, InternalFE formatterEnums, SerializationBinder binder)
internal void Serialize(object graph, Header[] inHeaders, __BinaryWriter serWriter, bool fCheck)
private Object[] WriteMethodCall(IMethodCallMessage mcm)
private Object[] WriteMethodReturn(IMethodReturnMessage mrm)
private Object[] StoreUserPropertiesForMethodMessage(IMethodMessage msg)
internal SerializationObjectManager get_ObjectManager()
private void Write(WriteObjectInfo objectInfo, NameInfo memberNameInfo, NameInfo typeNameInfo)
private void Write(WriteObjectInfo objectInfo, NameInfo memberNameInfo, NameInfo typeNameInfo, String[] memberNames, Type[] memberTypes, Object[] memberData, WriteObjectInfo[] memberObjectInfos)
private void WriteMemberSetup(WriteObjectInfo objectInfo, NameInfo memberNameInfo, NameInfo typeNameInfo, string memberName, Type memberType, object memberData, WriteObjectInfo memberObjectInfo)
private void WriteMembers(NameInfo memberNameInfo, NameInfo memberTypeNameInfo, object memberData, WriteObjectInfo objectInfo, NameInfo typeNameInfo, WriteObjectInfo memberObjectInfo)
private void WriteArray(WriteObjectInfo objectInfo, NameInfo memberNameInfo, WriteObjectInfo memberObjectInfo)
private void WriteArrayMember(WriteObjectInfo objectInfo, NameInfo arrayElemTypeNameInfo, object data)
private void WriteRectangle(WriteObjectInfo objectInfo, int rank, Int32[] maxA, Array array, NameInfo arrayElemNameTypeInfo, Int32[] lowerBoundA)
private void IndexTraceMessage(string message, Int32[] index)
private object GetNext(Int64& objID)
private long InternalGetId(object obj, bool assignUniqueIdToValueType, Type type, Boolean& isNew)
private long Schedule(object obj, bool assignUniqueIdToValueType, Type type)
private long Schedule(object obj, bool assignUniqueIdToValueType, Type type, WriteObjectInfo objectInfo)
private bool WriteKnownValueClass(NameInfo memberNameInfo, NameInfo typeNameInfo, object data)
private void WriteObjectRef(NameInfo nameInfo, long objectId)
private void WriteString(NameInfo memberNameInfo, NameInfo typeNameInfo, object stringObject)
private bool CheckForNull(WriteObjectInfo objectInfo, NameInfo memberNameInfo, NameInfo typeNameInfo, object data)
private void WriteSerializedStreamHeader(long topId, long headerId)
private NameInfo TypeToNameInfo(Type type, WriteObjectInfo objectInfo, InternalPrimitiveTypeE code, NameInfo nameInfo)
private NameInfo TypeToNameInfo(Type type)
private NameInfo TypeToNameInfo(WriteObjectInfo objectInfo)
private NameInfo TypeToNameInfo(WriteObjectInfo objectInfo, NameInfo nameInfo)
private void TypeToNameInfo(Type type, NameInfo nameInfo)
private NameInfo MemberToNameInfo(string name)
internal InternalPrimitiveTypeE ToCode(Type type)
private long GetAssemblyId(WriteObjectInfo objectInfo)
private Type GetType(object obj)
private NameInfo GetNameInfo()
private bool CheckTypeFormat(FormatterTypeStyle test, FormatterTypeStyle want)
private void PutNameInfo(NameInfo nameInfo)
}
internal System.Runtime.Serialization.Formatters.Binary.ParseRecord : object {
internal int parseRecordIdCount
internal int PRparseRecordId
internal InternalParseTypeE PRparseTypeEnum
internal InternalObjectTypeE PRobjectTypeEnum
internal InternalArrayTypeE PRarrayTypeEnum
internal InternalMemberTypeE PRmemberTypeEnum
internal InternalMemberValueE PRmemberValueEnum
internal InternalObjectPositionE PRobjectPositionEnum
internal string PRname
internal string PRvalue
internal object PRvarValue
internal string PRkeyDt
internal Type PRdtType
internal InternalPrimitiveTypeE PRdtTypeCode
internal bool PRisVariant
internal bool PRisEnum
internal long PRobjectId
internal long PRidRef
internal string PRarrayElementTypeString
internal Type PRarrayElementType
internal bool PRisArrayVariant
internal InternalPrimitiveTypeE PRarrayElementTypeCode
internal int PRrank
internal Int32[] PRlengthA
internal Int32[] PRpositionA
internal Int32[] PRlowerBoundA
internal Int32[] PRupperBoundA
internal Int32[] PRindexMap
internal int PRmemberIndex
internal int PRlinearlength
internal Int32[] PRrectangularMap
internal bool PRisLowerBound
internal long PRtopId
internal long PRheaderId
internal ReadObjectInfo PRobjectInfo
internal bool PRisValueTypeFixup
internal object PRnewObj
internal Object[] PRobjectA
internal PrimitiveArray PRprimitiveArray
internal bool PRisRegistered
internal Object[] PRmemberData
internal SerializationInfo PRsi
internal int PRnullCount
internal void Init()
}
internal System.Runtime.Serialization.Formatters.Binary.PrimitiveArray : object {
private InternalPrimitiveTypeE code
private Boolean[] booleanA
private Char[] charA
private Double[] doubleA
private Int16[] int16A
private Int32[] int32A
private Int64[] int64A
private SByte[] sbyteA
private Single[] singleA
private UInt16[] uint16A
private UInt32[] uint32A
private UInt64[] uint64A
internal void .ctor(InternalPrimitiveTypeE code, Array array)
internal void Init(InternalPrimitiveTypeE code, Array array)
internal void SetValue(string value, int index)
}
internal System.Runtime.Serialization.Formatters.Binary.ReadObjectInfo : object {
internal int objectInfoId
internal int readObjectInfoCounter
internal Type objectType
internal ObjectManager objectManager
internal int count
internal bool isSi
internal bool isNamed
internal bool isTyped
internal bool bSimpleAssembly
internal SerObjectInfoCache cache
internal String[] wireMemberNames
internal Type[] wireMemberTypes
private int lastPosition
internal ISurrogateSelector surrogateSelector
internal ISerializationSurrogate serializationSurrogate
internal StreamingContext context
internal List`1<Type> memberTypesList
internal SerObjectInfoInit serObjectInfoInit
internal IFormatterConverter formatterConverter
internal void ObjectEnd()
internal void PrepareForReuse()
internal ReadObjectInfo Create(Type objectType, ISurrogateSelector surrogateSelector, StreamingContext context, ObjectManager objectManager, SerObjectInfoInit serObjectInfoInit, IFormatterConverter converter, bool bSimpleAssembly)
internal void Init(Type objectType, ISurrogateSelector surrogateSelector, StreamingContext context, ObjectManager objectManager, SerObjectInfoInit serObjectInfoInit, IFormatterConverter converter, bool bSimpleAssembly)
internal ReadObjectInfo Create(Type objectType, String[] memberNames, Type[] memberTypes, ISurrogateSelector surrogateSelector, StreamingContext context, ObjectManager objectManager, SerObjectInfoInit serObjectInfoInit, IFormatterConverter converter, bool bSimpleAssembly)
internal void Init(Type objectType, String[] memberNames, Type[] memberTypes, ISurrogateSelector surrogateSelector, StreamingContext context, ObjectManager objectManager, SerObjectInfoInit serObjectInfoInit, IFormatterConverter converter, bool bSimpleAssembly)
private void InitReadConstructor(Type objectType, ISurrogateSelector surrogateSelector, StreamingContext context)
private void InitSiRead()
private void InitNoMembers()
private void InitMemberInfo()
internal MemberInfo GetMemberInfo(string name)
internal Type GetType(string name)
internal void AddValue(string name, object value, SerializationInfo& si, Object[]& memberData)
internal void InitDataStore(SerializationInfo& si, Object[]& memberData)
internal void RecordFixup(long objectId, string name, long idRef)
internal void PopulateObjectMembers(object obj, Object[] memberData)
private void DumpPopulate(MemberInfo[] memberInfos, Object[] memberData)
private void DumpPopulateSi()
private int Position(string name)
internal Type[] GetMemberTypes(String[] inMemberNames, Type objectType)
internal Type GetMemberType(MemberInfo objMember)
private ReadObjectInfo GetObjectInfo(SerObjectInfoInit serObjectInfoInit)
}
internal System.Runtime.Serialization.Formatters.Binary.SerializationHeaderRecord : object {
internal int binaryFormatterMajorVersion
internal int binaryFormatterMinorVersion
internal BinaryHeaderEnum binaryHeaderEnum
internal int topId
internal int headerId
internal int majorVersion
internal int minorVersion
internal void .ctor(BinaryHeaderEnum binaryHeaderEnum, int topId, int headerId, int majorVersion, int minorVersion)
public void Write(__BinaryWriter sout)
private int GetInt32(Byte[] buffer, int index)
public void Read(__BinaryParser input)
public void Dump()
private void DumpInternal()
}
internal System.Runtime.Serialization.Formatters.Binary.SerObjectInfoCache : object {
internal string fullTypeName
internal string assemblyString
internal bool hasTypeForwardedFrom
internal MemberInfo[] memberInfos
internal String[] memberNames
internal Type[] memberTypes
internal void .ctor(string typeName, string assemblyName, bool hasTypeForwardedFrom)
internal void .ctor(Type type)
}
internal System.Runtime.Serialization.Formatters.Binary.SerObjectInfoInit : object {
internal Hashtable seenBeforeTable
internal int objectInfoIdCount
internal SerStack oiPool
}
internal System.Runtime.Serialization.Formatters.Binary.SerStack : object {
internal Object[] objects
internal string stackId
internal int top
internal int next
internal void .ctor(string stackId)
internal void Push(object obj)
internal object Pop()
internal void IncreaseCapacity()
internal object Peek()
internal object PeekPeek()
internal int Count()
internal bool IsEmpty()
internal void Dump()
}
internal System.Runtime.Serialization.Formatters.Binary.SizedArray : object {
internal Object[] objects
internal Object[] negObjects
internal object Item
internal void .ctor(int length)
private void .ctor(SizedArray sizedArray)
public object Clone()
internal object get_Item(int index)
internal void set_Item(int index, object value)
internal void IncreaseCapacity(int index)
}
internal System.Runtime.Serialization.Formatters.Binary.SoapAttributeType : Enum {
public int value__
public SoapAttributeType None
public SoapAttributeType SchemaType
public SoapAttributeType Embedded
public SoapAttributeType XmlElement
public SoapAttributeType XmlAttribute
}
internal System.Runtime.Serialization.Formatters.Binary.TypeInformation : object {
private string fullTypeName
private string assemblyString
private bool hasTypeForwardedFrom
internal string FullTypeName
internal string AssemblyString
internal bool HasTypeForwardedFrom
internal string get_FullTypeName()
internal string get_AssemblyString()
internal bool get_HasTypeForwardedFrom()
internal void .ctor(string fullTypeName, string assemblyString, bool hasTypeForwardedFrom)
}
internal System.Runtime.Serialization.Formatters.Binary.ValueFixup : object {
internal ValueFixupEnum valueFixupEnum
internal Array arrayObj
internal Int32[] indexMap
internal object header
internal object memberObject
internal MemberInfo modreq(System.Runtime.CompilerServices.IsVolatile) valueInfo
internal ReadObjectInfo objectInfo
internal string memberName
internal void .ctor(Array arrayObj, Int32[] indexMap)
internal void .ctor(object memberObject, string memberName, ReadObjectInfo objectInfo)
internal void Fixup(ParseRecord record, ParseRecord parent)
}
internal System.Runtime.Serialization.Formatters.Binary.ValueFixupEnum : Enum {
public int value__
public ValueFixupEnum Empty
public ValueFixupEnum Array
public ValueFixupEnum Header
public ValueFixupEnum Member
}
internal System.Runtime.Serialization.Formatters.Binary.WriteObjectInfo : object {
internal int objectInfoId
internal object obj
internal Type objectType
internal bool isSi
internal bool isNamed
internal bool isTyped
internal bool isArray
internal SerializationInfo si
internal SerObjectInfoCache cache
internal Object[] memberData
internal ISerializationSurrogate serializationSurrogate
internal StreamingContext context
internal SerObjectInfoInit serObjectInfoInit
internal long objectId
internal long assemId
private string binderTypeName
private string binderAssemblyString
internal void ObjectEnd()
private void InternalInit()
internal WriteObjectInfo Serialize(object obj, ISurrogateSelector surrogateSelector, StreamingContext context, SerObjectInfoInit serObjectInfoInit, IFormatterConverter converter, ObjectWriter objectWriter, SerializationBinder binder)
internal void InitSerialize(object obj, ISurrogateSelector surrogateSelector, StreamingContext context, SerObjectInfoInit serObjectInfoInit, IFormatterConverter converter, ObjectWriter objectWriter, SerializationBinder binder)
private void DumpMemberInfo()
internal WriteObjectInfo Serialize(Type objectType, ISurrogateSelector surrogateSelector, StreamingContext context, SerObjectInfoInit serObjectInfoInit, IFormatterConverter converter, SerializationBinder binder)
internal void InitSerialize(Type objectType, ISurrogateSelector surrogateSelector, StreamingContext context, SerObjectInfoInit serObjectInfoInit, IFormatterConverter converter, SerializationBinder binder)
private void InitSiWrite()
private void CheckTypeForwardedFrom(SerObjectInfoCache cache, Type objectType, string binderAssemblyString)
private void InitNoMembers()
private void InitMemberInfo()
internal string GetTypeFullName()
internal string GetAssemblyString()
private void InvokeSerializationBinder(SerializationBinder binder)
internal Type GetMemberType(MemberInfo objMember)
internal void GetMemberInfo(String[]& outMemberNames, Type[]& outMemberTypes, Object[]& outMemberData)
private WriteObjectInfo GetObjectInfo(SerObjectInfoInit serObjectInfoInit)
private void PutObjectInfo(SerObjectInfoInit serObjectInfoInit, WriteObjectInfo objectInfo)
}
public System.Runtime.Serialization.Formatters.FormatterAssemblyStyle : Enum {
public int value__
public FormatterAssemblyStyle Simple
public FormatterAssemblyStyle Full
}
public System.Runtime.Serialization.Formatters.FormatterTypeStyle : Enum {
public int value__
public FormatterTypeStyle TypesWhenNeeded
public FormatterTypeStyle TypesAlways
public FormatterTypeStyle XsdString
}
public System.Runtime.Serialization.Formatters.IFieldInfo {
public String[] FieldNames
public Type[] FieldTypes
public String[] get_FieldNames()
public void set_FieldNames(String[] value)
public Type[] get_FieldTypes()
public void set_FieldTypes(Type[] value)
}
public System.Runtime.Serialization.Formatters.InternalRM : object {
public void InfoSoap(Object[] messages)
public bool SoapCheckEnabled()
}
public System.Runtime.Serialization.Formatters.InternalST : object {
public void InfoSoap(Object[] messages)
public bool SoapCheckEnabled()
public void Soap(Object[] messages)
public void SoapAssert(bool condition, string message)
public void SerializationSetValue(FieldInfo fi, object target, object value)
public Assembly LoadAssemblyFromString(string assemblyString)
}
public System.Runtime.Serialization.Formatters.ISoapMessage {
public String[] ParamNames
public Object[] ParamValues
public Type[] ParamTypes
public string MethodName
public string XmlNameSpace
public Header[] Headers
public String[] get_ParamNames()
public void set_ParamNames(String[] value)
public Object[] get_ParamValues()
public void set_ParamValues(Object[] value)
public Type[] get_ParamTypes()
public void set_ParamTypes(Type[] value)
public string get_MethodName()
public void set_MethodName(string value)
public string get_XmlNameSpace()
public void set_XmlNameSpace(string value)
public Header[] get_Headers()
public void set_Headers(Header[] value)
}
internal System.Runtime.Serialization.Formatters.SerTrace : object {
internal void InfoLog(Object[] messages)
internal void Log(Object[] messages)
}
public System.Runtime.Serialization.Formatters.ServerFault : object {
private string exceptionType
private string message
private string stackTrace
private Exception exception
public string ExceptionType
public string ExceptionMessage
public string StackTrace
internal Exception Exception
internal void .ctor(Exception exception)
public void .ctor(string exceptionType, string message, string stackTrace)
public string get_ExceptionType()
public void set_ExceptionType(string value)
public string get_ExceptionMessage()
public void set_ExceptionMessage(string value)
public string get_StackTrace()
public void set_StackTrace(string value)
internal Exception get_Exception()
}
public System.Runtime.Serialization.Formatters.SoapFault : object {
private string faultCode
private string faultString
private string faultActor
private object detail
public string FaultCode
public string FaultString
public string FaultActor
public object Detail
public void .ctor(string faultCode, string faultString, string faultActor, ServerFault serverFault)
internal void .ctor(SerializationInfo info, StreamingContext context)
public void GetObjectData(SerializationInfo info, StreamingContext context)
public string get_FaultCode()
public void set_FaultCode(string value)
public string get_FaultString()
public void set_FaultString(string value)
public string get_FaultActor()
public void set_FaultActor(string value)
public object get_Detail()
public void set_Detail(object value)
}
public System.Runtime.Serialization.Formatters.SoapMessage : object {
internal String[] paramNames
internal Object[] paramValues
internal Type[] paramTypes
internal string methodName
internal string xmlNameSpace
internal Header[] headers
public String[] ParamNames
public Object[] ParamValues
public Type[] ParamTypes
public string MethodName
public string XmlNameSpace
public Header[] Headers
public String[] get_ParamNames()
public void set_ParamNames(String[] value)
public Object[] get_ParamValues()
public void set_ParamValues(Object[] value)
public Type[] get_ParamTypes()
public void set_ParamTypes(Type[] value)
public string get_MethodName()
public void set_MethodName(string value)
public string get_XmlNameSpace()
public void set_XmlNameSpace(string value)
public Header[] get_Headers()
public void set_Headers(Header[] value)
}
public System.Runtime.Serialization.Formatters.TypeFilterLevel : Enum {
public int value__
public TypeFilterLevel Low
public TypeFilterLevel Full
}
public System.Runtime.Serialization.FormatterServices : object {
internal ConcurrentDictionary`2<MemberHolder, MemberInfo[]> m_MemberInfoTable
private bool unsafeTypeForwardersIsEnabled
private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) unsafeTypeForwardersIsEnabledInitialized
private Type[] advancedTypes
private Binder s_binder
private MemberInfo[] GetSerializableMembers(RuntimeType type)
private bool CheckSerializable(RuntimeType type)
private MemberInfo[] InternalGetSerializableMembers(RuntimeType type)
private bool GetParentTypes(RuntimeType parentType, RuntimeType[]& parentTypes, Int32& parentTypeCount)
public MemberInfo[] GetSerializableMembers(Type type)
public MemberInfo[] GetSerializableMembers(Type type, StreamingContext context)
public void CheckTypeSecurity(Type t, TypeFilterLevel securityLevel)
public object GetUninitializedObject(Type type)
public object GetSafeUninitializedObject(Type type)
private object nativeGetUninitializedObject(RuntimeType type)
private object nativeGetSafeUninitializedObject(RuntimeType type)
private bool GetEnableUnsafeTypeForwarders()
internal bool UnsafeTypeForwardersIsEnabled()
internal void SerializationSetValue(MemberInfo fi, object target, object value)
public object PopulateObjectMembers(object obj, MemberInfo[] members, Object[] data)
public Object[] GetObjectData(object obj, MemberInfo[] members)
public ISerializationSurrogate GetSurrogateForCyclicalReference(ISerializationSurrogate innerSurrogate)
public Type GetTypeFromAssembly(Assembly assem, string name)
internal Assembly LoadAssemblyFromString(string assemblyName)
internal Assembly LoadAssemblyFromStringNoThrow(string assemblyName)
internal string GetClrAssemblyName(Type type, Boolean& hasTypeForwardedFrom)
internal string GetClrTypeFullName(Type type)
private string GetClrTypeFullNameForArray(Type type)
private string GetClrTypeFullNameForNonArrayTypes(Type type)
}
public System.Runtime.Serialization.IDeserializationCallback {
public void OnDeserialization(object sender)
}
public System.Runtime.Serialization.IFormatter {
public ISurrogateSelector SurrogateSelector
public SerializationBinder Binder
public StreamingContext Context
public object Deserialize(Stream serializationStream)
public void Serialize(Stream serializationStream, object graph)
public ISurrogateSelector get_SurrogateSelector()
public void set_SurrogateSelector(ISurrogateSelector value)
public SerializationBinder get_Binder()
public void set_Binder(SerializationBinder value)
public StreamingContext get_Context()
public void set_Context(StreamingContext value)
}
public System.Runtime.Serialization.IFormatterConverter {
public object Convert(object value, Type type)
public object Convert(object value, TypeCode typeCode)
public bool ToBoolean(object value)
public char ToChar(object value)
public sbyte ToSByte(object value)
public byte ToByte(object value)
public short ToInt16(object value)
public ushort ToUInt16(object value)
public int ToInt32(object value)
public UInt32 ToUInt32(object value)
public long ToInt64(object value)
public ulong ToUInt64(object value)
public float ToSingle(object value)
public double ToDouble(object value)
public decimal ToDecimal(object value)
public DateTime ToDateTime(object value)
public string ToString(object value)
}
public System.Runtime.Serialization.IObjectReference {
public object GetRealObject(StreamingContext context)
}
public System.Runtime.Serialization.ISafeSerializationData {
public void CompleteDeserialization(object deserialized)
}
public System.Runtime.Serialization.ISerializable {
public void GetObjectData(SerializationInfo info, StreamingContext context)
}
public System.Runtime.Serialization.ISerializationSurrogate {
public void GetObjectData(object obj, SerializationInfo info, StreamingContext context)
public object SetObjectData(object obj, SerializationInfo info, StreamingContext context, ISurrogateSelector selector)
}
public System.Runtime.Serialization.ISurrogateSelector {
public void ChainSelector(ISurrogateSelector selector)
public ISerializationSurrogate GetSurrogate(Type type, StreamingContext context, ISurrogateSelector& selector)
public ISurrogateSelector GetNextSelector()
}
internal System.Runtime.Serialization.LongList : object {
private int InitialSize
private Int64[] m_values
private int m_count
private int m_totalItems
private int m_currentItem
internal int Count
internal long Current
internal void .ctor(int startingSize)
internal void Add(long value)
internal int get_Count()
internal void StartEnumeration()
internal bool MoveNext()
internal long get_Current()
internal bool RemoveElement(long value)
private void EnlargeArray()
}
internal System.Runtime.Serialization.MemberHolder : object {
internal MemberInfo[] members
internal Type memberType
internal StreamingContext context
internal void .ctor(Type type, StreamingContext ctx)
public int GetHashCode()
public bool Equals(object obj)
}
internal System.Runtime.Serialization.ObjectCloneHelper : object {
private IFormatterConverter s_converter
private StreamingContext s_cloneContext
private ISerializationSurrogate s_RemotingSurrogate
private ISerializationSurrogate s_ObjRefRemotingSurrogate
internal object GetObjectData(object serObj, String& typeName, String& assemName, String[]& fieldNames, Object[]& fieldValues)
internal SerializationInfo PrepareConstructorArgs(object serObj, String[] fieldNames, Object[] fieldValues, StreamingContext& context)
}
internal System.Runtime.Serialization.ObjectHolder : object {
internal int INCOMPLETE_OBJECT_REFERENCE
internal int HAS_ISERIALIZABLE
internal int HAS_SURROGATE
internal int REQUIRES_VALUETYPE_FIXUP
internal int REQUIRES_DELAYED_FIXUP
internal int SER_INFO_FIXED
internal int VALUETYPE_FIXUP_PERFORMED
private object m_object
internal long m_id
private int m_missingElementsRemaining
private int m_missingDecendents
internal SerializationInfo m_serInfo
internal ISerializationSurrogate m_surrogate
internal FixupHolderList m_missingElements
internal LongList m_dependentObjects
internal ObjectHolder m_next
internal int m_flags
private bool m_markForFixupWhenAvailable
private ValueTypeFixupInfo m_valueFixup
private TypeLoadExceptionHolder m_typeLoad
private bool m_reachable
internal bool IsIncompleteObjectReference
internal bool RequiresDelayedFixup
internal bool RequiresValueTypeFixup
internal bool ValueTypeFixupPerformed
internal bool HasISerializable
internal bool HasSurrogate
internal bool CanSurrogatedObjectValueChange
internal bool CanObjectValueChange
internal int DirectlyDependentObjects
internal int TotalDependentObjects
internal bool Reachable
internal bool TypeLoadExceptionReachable
internal TypeLoadExceptionHolder TypeLoadException
internal object ObjectValue
internal SerializationInfo SerializationInfo
internal ISerializationSurrogate Surrogate
internal LongList DependentObjects
internal bool RequiresSerInfoFixup
internal ValueTypeFixupInfo ValueFixup
internal bool CompletelyFixed
internal long ContainerID
internal void .ctor(long objID)
internal void .ctor(object obj, long objID, SerializationInfo info, ISerializationSurrogate surrogate, long idOfContainingObj, FieldInfo field, Int32[] arrayIndex)
internal void .ctor(string obj, long objID, SerializationInfo info, ISerializationSurrogate surrogate, long idOfContainingObj, FieldInfo field, Int32[] arrayIndex)
private void IncrementDescendentFixups(int amount)
internal void DecrementFixupsRemaining(ObjectManager manager)
internal void RemoveDependency(long id)
internal void AddFixup(FixupHolder fixup, ObjectManager manager)
private void UpdateDescendentDependencyChain(int amount, ObjectManager manager)
internal void AddDependency(long dependentObject)
internal void UpdateData(object obj, SerializationInfo info, ISerializationSurrogate surrogate, long idOfContainer, FieldInfo field, Int32[] arrayIndex, ObjectManager manager)
internal void MarkForCompletionWhenAvailable()
internal void SetFlags()
internal bool get_IsIncompleteObjectReference()
internal void set_IsIncompleteObjectReference(bool value)
internal bool get_RequiresDelayedFixup()
internal bool get_RequiresValueTypeFixup()
internal bool get_ValueTypeFixupPerformed()
internal void set_ValueTypeFixupPerformed(bool value)
internal bool get_HasISerializable()
internal bool get_HasSurrogate()
internal bool get_CanSurrogatedObjectValueChange()
internal bool get_CanObjectValueChange()
internal int get_DirectlyDependentObjects()
internal int get_TotalDependentObjects()
internal bool get_Reachable()
internal void set_Reachable(bool value)
internal bool get_TypeLoadExceptionReachable()
internal TypeLoadExceptionHolder get_TypeLoadException()
internal void set_TypeLoadException(TypeLoadExceptionHolder value)
internal object get_ObjectValue()
internal void SetObjectValue(object obj, ObjectManager manager)
internal SerializationInfo get_SerializationInfo()
internal void set_SerializationInfo(SerializationInfo value)
internal ISerializationSurrogate get_Surrogate()
internal LongList get_DependentObjects()
internal void set_DependentObjects(LongList value)
internal bool get_RequiresSerInfoFixup()
internal void set_RequiresSerInfoFixup(bool value)
internal ValueTypeFixupInfo get_ValueFixup()
internal bool get_CompletelyFixed()
internal long get_ContainerID()
}
internal System.Runtime.Serialization.ObjectHolderList : object {
internal int DefaultInitialSize
internal ObjectHolder[] m_values
internal int m_count
internal int Version
internal int Count
internal void .ctor(int startingSize)
internal void Add(ObjectHolder value)
internal ObjectHolderListEnumerator GetFixupEnumerator()
private void EnlargeArray()
internal int get_Version()
internal int get_Count()
}
internal System.Runtime.Serialization.ObjectHolderListEnumerator : object {
private bool m_isFixupEnumerator
private ObjectHolderList m_list
private int m_startingVersion
private int m_currPos
internal ObjectHolder Current
internal void .ctor(ObjectHolderList list, bool isFixupEnumerator)
internal bool MoveNext()
internal ObjectHolder get_Current()
}
public System.Runtime.Serialization.ObjectIDGenerator : object {
private int numbins
internal int m_currentCount
internal int m_currentSize
internal Int64[] m_ids
internal Object[] m_objs
private Int32[] sizes
private int FindElement(object obj, Boolean& found)
public long GetId(object obj, Boolean& firstTime)
public long HasId(object obj, Boolean& firstTime)
private void Rehash()
}
public System.Runtime.Serialization.ObjectManager : object {
private int DefaultInitialSize
private int MaxArraySize
private int ArrayMask
private int MaxReferenceDepth
private DeserializationEventHandler m_onDeserializationHandler
private SerializationEventHandler m_onDeserializedHandler
internal ObjectHolder[] m_objects
internal object m_topObject
internal ObjectHolderList m_specialFixupObjects
internal long m_fixupCount
internal ISurrogateSelector m_selector
internal StreamingContext m_context
internal object TopObject
internal ObjectHolderList SpecialFixupObjects
public void .ctor(ISurrogateSelector selector, StreamingContext context)
internal void .ctor(ISurrogateSelector selector, StreamingContext context, bool checkSecurity, bool isCrossAppDomain)
private bool CanCallGetType(object obj)
internal void set_TopObject(object value)
internal object get_TopObject()
internal ObjectHolderList get_SpecialFixupObjects()
internal ObjectHolder FindObjectHolder(long objectID)
internal ObjectHolder FindOrCreateObjectHolder(long objectID)
private void AddObjectHolder(ObjectHolder holder)
private bool GetCompletionInfo(FixupHolder fixup, ObjectHolder& holder, Object& member, bool bThrowIfMissing)
private void FixupSpecialObject(ObjectHolder holder)
private bool ResolveObjectReference(ObjectHolder holder)
private bool DoValueTypeFixup(FieldInfo memberToFix, ObjectHolder holder, object value)
private void DumpValueTypeFixup(object obj, FieldInfo[] intermediateFields, FieldInfo memberToFix, object value)
internal void CompleteObject(ObjectHolder holder, bool bObjectFullyComplete)
private void DoNewlyRegisteredObjectFixups(ObjectHolder holder)
public object GetObject(long objectID)
public void RegisterObject(object obj, long objectID)
public void RegisterObject(object obj, long objectID, SerializationInfo info)
public void RegisterObject(object obj, long objectID, SerializationInfo info, long idOfContainingObj, MemberInfo member)
internal void RegisterString(string obj, long objectID, SerializationInfo info, long idOfContainingObj, MemberInfo member)
public void RegisterObject(object obj, long objectID, SerializationInfo info, long idOfContainingObj, MemberInfo member, Int32[] arrayIndex)
internal void CompleteISerializableObject(object obj, SerializationInfo info, StreamingContext context)
internal RuntimeConstructorInfo GetConstructor(RuntimeType t)
public void DoFixups()
private void RegisterFixup(FixupHolder fixup, long objectToBeFixed, long objectRequired)
public void RecordFixup(long objectToBeFixed, MemberInfo member, long objectRequired)
public void RecordDelayedFixup(long objectToBeFixed, string memberName, long objectRequired)
public void RecordArrayElementFixup(long arrayToBeFixed, int index, long objectRequired)
public void RecordArrayElementFixup(long arrayToBeFixed, Int32[] indices, long objectRequired)
public void RaiseDeserializationEvent()
internal void AddOnDeserialization(DeserializationEventHandler handler)
internal void RemoveOnDeserialization(DeserializationEventHandler handler)
internal void AddOnDeserialized(object obj)
internal void RaiseOnDeserializedEvent(object obj)
public void RaiseOnDeserializingEvent(object obj)
}
public System.Runtime.Serialization.OptionalFieldAttribute : Attribute {
private int versionAdded
public int VersionAdded
public int get_VersionAdded()
public void set_VersionAdded(int value)
}
public System.Runtime.Serialization.SafeSerializationEventArgs : EventArgs {
private StreamingContext m_streamingContext
private List`1<object> m_serializedStates
internal IList`1<object> SerializedStates
public StreamingContext StreamingContext
internal void .ctor(StreamingContext streamingContext)
public void AddSerializedState(ISafeSerializationData serializedState)
internal IList`1<object> get_SerializedStates()
public StreamingContext get_StreamingContext()
}
internal System.Runtime.Serialization.SafeSerializationManager : object {
private IList`1<object> m_serializedStates
private SerializationInfo m_savedSerializationInfo
private object m_realObject
private RuntimeType m_realType
private EventHandler`1<SafeSerializationEventArgs> SerializeObjectState
private string RealTypeSerializationName
internal bool IsActive
internal void add_SerializeObjectState(EventHandler`1<SafeSerializationEventArgs> value)
internal void remove_SerializeObjectState(EventHandler`1<SafeSerializationEventArgs> value)
private void .ctor(SerializationInfo info, StreamingContext context)
internal bool get_IsActive()
internal void CompleteSerialization(object serializedObject, SerializationInfo info, StreamingContext context)
internal void CompleteDeserialization(object deserializedObject)
private void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context)
private object System.Runtime.Serialization.IObjectReference.GetRealObject(StreamingContext context)
private void OnDeserialized(StreamingContext context)
}
public System.Runtime.Serialization.SerializationBinder : object {
public void BindToName(Type serializedType, String& assemblyName, String& typeName)
public Type BindToType(string assemblyName, string typeName)
}
public System.Runtime.Serialization.SerializationEntry : ValueType {
private Type m_type
private object m_value
private string m_name
public object Value
public string Name
public Type ObjectType
public object get_Value()
public string get_Name()
public Type get_ObjectType()
internal void .ctor(string entryName, object entryValue, Type entryType)
}
internal System.Runtime.Serialization.SerializationEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(StreamingContext context)
public IAsyncResult BeginInvoke(StreamingContext context, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
internal System.Runtime.Serialization.SerializationEvents : object {
private List`1<MethodInfo> m_OnSerializingMethods
private List`1<MethodInfo> m_OnSerializedMethods
private List`1<MethodInfo> m_OnDeserializingMethods
private List`1<MethodInfo> m_OnDeserializedMethods
internal bool HasOnSerializingEvents
private List`1<MethodInfo> GetMethodsWithAttribute(Type attribute, Type t)
internal void .ctor(Type t)
internal bool get_HasOnSerializingEvents()
internal void InvokeOnSerializing(object obj, StreamingContext context)
internal void InvokeOnDeserializing(object obj, StreamingContext context)
internal void InvokeOnDeserialized(object obj, StreamingContext context)
internal SerializationEventHandler AddOnSerialized(object obj, SerializationEventHandler handler)
internal SerializationEventHandler AddOnDeserialized(object obj, SerializationEventHandler handler)
}
internal System.Runtime.Serialization.SerializationEventsCache : object {
private Hashtable cache
internal SerializationEvents GetSerializationEventsForType(Type t)
}
public System.Runtime.Serialization.SerializationException : SystemException {
private string _nullMessage
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
protected void .ctor(SerializationInfo info, StreamingContext context)
}
internal System.Runtime.Serialization.SerializationFieldInfo : FieldInfo {
internal string FakeNameSeparatorString
private RuntimeFieldInfo m_field
private string m_serializationName
private RemotingFieldCachedData m_cachedData
public Module Module
public int MetadataToken
public string Name
public Type DeclaringType
public Type ReflectedType
public Type FieldType
internal RuntimeFieldInfo FieldInfo
public RuntimeFieldHandle FieldHandle
public FieldAttributes Attributes
internal RemotingFieldCachedData RemotingCache
public Module get_Module()
public int get_MetadataToken()
internal void .ctor(RuntimeFieldInfo field, string namePrefix)
public string get_Name()
public Type get_DeclaringType()
public Type get_ReflectedType()
public Object[] GetCustomAttributes(bool inherit)
public Object[] GetCustomAttributes(Type attributeType, bool inherit)
public bool IsDefined(Type attributeType, bool inherit)
public Type get_FieldType()
public object GetValue(object obj)
internal object InternalGetValue(object obj)
public void SetValue(object obj, object value, BindingFlags invokeAttr, Binder binder, CultureInfo culture)
internal void InternalSetValue(object obj, object value, BindingFlags invokeAttr, Binder binder, CultureInfo culture)
internal RuntimeFieldInfo get_FieldInfo()
public RuntimeFieldHandle get_FieldHandle()
public FieldAttributes get_Attributes()
internal RemotingFieldCachedData get_RemotingCache()
}
public System.Runtime.Serialization.SerializationInfo : object {
private int defaultSize
private string s_mscorlibAssemblySimpleName
private string s_mscorlibFileName
internal String[] m_members
internal Object[] m_data
internal Type[] m_types
private Dictionary`2<string, int> m_nameToIndex
internal int m_currMember
internal IFormatterConverter m_converter
private string m_fullTypeName
private string m_assemName
private Type objectType
private bool isFullTypeNameSetExplicit
private bool isAssemblyNameSetExplicit
private bool requireSameTokenInPartialTrust
public string FullTypeName
public string AssemblyName
public int MemberCount
public Type ObjectType
public bool IsFullTypeNameSetExplicit
public bool IsAssemblyNameSetExplicit
internal String[] MemberNames
internal Object[] MemberValues
public void .ctor(Type type, IFormatterConverter converter)
public void .ctor(Type type, IFormatterConverter converter, bool requireSameTokenInPartialTrust)
public string get_FullTypeName()
public void set_FullTypeName(string value)
public string get_AssemblyName()
public void set_AssemblyName(string value)
public void SetType(Type type)
private bool Compare(Byte[] a, Byte[] b)
internal void DemandForUnsafeAssemblyNameAssignments(string originalAssemblyName, string newAssemblyName)
internal bool IsAssemblyNameAssignmentSafe(string originalAssemblyName, string newAssemblyName)
public int get_MemberCount()
public Type get_ObjectType()
public bool get_IsFullTypeNameSetExplicit()
public bool get_IsAssemblyNameSetExplicit()
public SerializationInfoEnumerator GetEnumerator()
private void ExpandArrays()
public void AddValue(string name, object value, Type type)
public void AddValue(string name, object value)
public void AddValue(string name, bool value)
public void AddValue(string name, char value)
public void AddValue(string name, sbyte value)
public void AddValue(string name, byte value)
public void AddValue(string name, short value)
public void AddValue(string name, ushort value)
public void AddValue(string name, int value)
public void AddValue(string name, UInt32 value)
public void AddValue(string name, long value)
public void AddValue(string name, ulong value)
public void AddValue(string name, float value)
public void AddValue(string name, double value)
public void AddValue(string name, decimal value)
public void AddValue(string name, DateTime value)
internal void AddValueInternal(string name, object value, Type type)
internal void UpdateValue(string name, object value, Type type)
private int FindElement(string name)
private object GetElement(string name, Type& foundType)
private object GetElementNoThrow(string name, Type& foundType)
public object GetValue(string name, Type type)
internal object GetValueNoThrow(string name, Type type)
public bool GetBoolean(string name)
public char GetChar(string name)
public sbyte GetSByte(string name)
public byte GetByte(string name)
public short GetInt16(string name)
public ushort GetUInt16(string name)
public int GetInt32(string name)
public UInt32 GetUInt32(string name)
public long GetInt64(string name)
public ulong GetUInt64(string name)
public float GetSingle(string name)
public double GetDouble(string name)
public decimal GetDecimal(string name)
public DateTime GetDateTime(string name)
public string GetString(string name)
internal String[] get_MemberNames()
internal Object[] get_MemberValues()
}
public System.Runtime.Serialization.SerializationInfoEnumerator : object {
private String[] m_members
private Object[] m_data
private Type[] m_types
private int m_numItems
private int m_currItem
private bool m_current
private object System.Collections.IEnumerator.Current
public SerializationEntry Current
public string Name
public object Value
public Type ObjectType
internal void .ctor(String[] members, Object[] info, Type[] types, int numItems)
public bool MoveNext()
private object System.Collections.IEnumerator.get_Current()
public SerializationEntry get_Current()
public void Reset()
public string get_Name()
public object get_Value()
public Type get_ObjectType()
}
public System.Runtime.Serialization.SerializationObjectManager : object {
private Hashtable m_objectSeenTable
private SerializationEventHandler m_onSerializedHandler
private StreamingContext m_context
public void .ctor(StreamingContext context)
public void RegisterObject(object obj)
public void RaiseOnSerializedEvent()
private void AddOnSerialized(object obj)
}
public System.Runtime.Serialization.StreamingContext : ValueType {
internal object m_additionalContext
internal StreamingContextStates m_state
public object Context
public StreamingContextStates State
public void .ctor(StreamingContextStates state)
public void .ctor(StreamingContextStates state, object additional)
public object get_Context()
public bool Equals(object obj)
public int GetHashCode()
public StreamingContextStates get_State()
}
public System.Runtime.Serialization.StreamingContextStates : Enum {
public int value__
public StreamingContextStates CrossProcess
public StreamingContextStates CrossMachine
public StreamingContextStates File
public StreamingContextStates Persistence
public StreamingContextStates Remoting
public StreamingContextStates Other
public StreamingContextStates Clone
public StreamingContextStates CrossAppDomain
public StreamingContextStates All
}
internal System.Runtime.Serialization.SurrogateForCyclicalReference : object {
private ISerializationSurrogate innerSurrogate
internal void .ctor(ISerializationSurrogate innerSurrogate)
public void GetObjectData(object obj, SerializationInfo info, StreamingContext context)
public object SetObjectData(object obj, SerializationInfo info, StreamingContext context, ISurrogateSelector selector)
}
internal System.Runtime.Serialization.SurrogateHashtable : Hashtable {
internal void .ctor(int size)
protected bool KeyEquals(object key, object item)
}
internal System.Runtime.Serialization.SurrogateKey : object {
internal Type m_type
internal StreamingContext m_context
internal void .ctor(Type type, StreamingContext context)
public int GetHashCode()
}
public System.Runtime.Serialization.SurrogateSelector : object {
internal SurrogateHashtable m_surrogates
internal ISurrogateSelector m_nextSelector
public void AddSurrogate(Type type, StreamingContext context, ISerializationSurrogate surrogate)
private bool HasCycle(ISurrogateSelector selector)
public void ChainSelector(ISurrogateSelector selector)
public ISurrogateSelector GetNextSelector()
public ISerializationSurrogate GetSurrogate(Type type, StreamingContext context, ISurrogateSelector& selector)
public void RemoveSurrogate(Type type, StreamingContext context)
}
internal System.Runtime.Serialization.TypeLoadExceptionHolder : object {
private string m_typeName
internal string TypeName
internal void .ctor(string typeName)
internal string get_TypeName()
}
internal System.Runtime.Serialization.ValueTypeFixupInfo : object {
private long m_containerID
private FieldInfo m_parentField
private Int32[] m_parentIndex
public long ContainerID
public FieldInfo ParentField
public Int32[] ParentIndex
public void .ctor(long containerID, FieldInfo member, Int32[] parentIndex)
public long get_ContainerID()
public FieldInfo get_ParentField()
public Int32[] get_ParentIndex()
}
public System.Runtime.TargetedPatchingOptOutAttribute : Attribute {
private string m_reason
public string Reason
public void .ctor(string reason)
public string get_Reason()
}
internal System.Runtime.Versioning.BinaryCompatibility : object {
public bool TargetsAtLeast_Desktop_V4_5
public bool TargetsAtLeast_Desktop_V4_5_1
public bool TargetsAtLeast_Desktop_V4_5_2
public bool get_TargetsAtLeast_Desktop_V4_5_2()
}
public System.Runtime.Versioning.CompatibilitySwitch : object {
public bool IsEnabled(string compatibilitySwitchName)
public string GetValue(string compatibilitySwitchName)
internal string GetValueInternal(string compatibilitySwitchName)
}
public System.Runtime.Versioning.ComponentGuaranteesAttribute : Attribute {
private ComponentGuaranteesOptions _guarantees
public ComponentGuaranteesOptions Guarantees
public void .ctor(ComponentGuaranteesOptions guarantees)
public ComponentGuaranteesOptions get_Guarantees()
}
public System.Runtime.Versioning.ComponentGuaranteesOptions : Enum {
public int value__
public ComponentGuaranteesOptions None
public ComponentGuaranteesOptions Exchange
public ComponentGuaranteesOptions Stable
public ComponentGuaranteesOptions SideBySide
}
internal System.Runtime.Versioning.MultitargetingHelpers : object {
private Func`2<Type, string> defaultConverter
internal string GetAssemblyQualifiedName(Type type, Func`2<Type, string> converter)
private bool IsCriticalException(Exception ex)
private bool IsSecurityOrCriticalException(Exception ex)
}
public System.Runtime.Versioning.ResourceConsumptionAttribute : Attribute {
private ResourceScope _consumptionScope
private ResourceScope _resourceScope
public ResourceScope ResourceScope
public ResourceScope ConsumptionScope
public void .ctor(ResourceScope resourceScope)
public void .ctor(ResourceScope resourceScope, ResourceScope consumptionScope)
public ResourceScope get_ResourceScope()
public ResourceScope get_ConsumptionScope()
}
public System.Runtime.Versioning.ResourceExposureAttribute : Attribute {
private ResourceScope _resourceExposureLevel
public ResourceScope ResourceExposureLevel
public void .ctor(ResourceScope exposureLevel)
public ResourceScope get_ResourceExposureLevel()
}
public System.Runtime.Versioning.ResourceScope : Enum {
public int value__
public ResourceScope None
public ResourceScope Machine
public ResourceScope Process
public ResourceScope AppDomain
public ResourceScope Library
public ResourceScope Private
public ResourceScope Assembly
}
internal System.Runtime.Versioning.SxSRequirements : Enum {
public int value__
public SxSRequirements None
public SxSRequirements AppDomainID
public SxSRequirements ProcessID
public SxSRequirements CLRInstanceID
public SxSRequirements AssemblyName
public SxSRequirements TypeName
}
public System.Runtime.Versioning.TargetFrameworkAttribute : Attribute {
private string _frameworkName
private string _frameworkDisplayName
public string FrameworkName
public string FrameworkDisplayName
public void .ctor(string frameworkName)
public string get_FrameworkName()
public string get_FrameworkDisplayName()
public void set_FrameworkDisplayName(string value)
}
internal System.Runtime.Versioning.TargetFrameworkId : Enum {
public int value__
public TargetFrameworkId NotYetChecked
public TargetFrameworkId Unrecognized
public TargetFrameworkId Unspecified
public TargetFrameworkId NetFramework
public TargetFrameworkId Portable
public TargetFrameworkId NetCore
public TargetFrameworkId Silverlight
public TargetFrameworkId Phone
}
public System.Runtime.Versioning.VersioningHelper : object {
private ResourceScope ResTypeMask
private ResourceScope VisibilityMask
private int GetRuntimeId()
public string MakeVersionSafeName(string name, ResourceScope from, ResourceScope to)
public string MakeVersionSafeName(string name, ResourceScope from, ResourceScope to, Type type)
private string GetCLRInstanceString()
private SxSRequirements GetRequirements(ResourceScope consumeAsScope, ResourceScope calleeScope)
}
public System.RuntimeArgumentHandle : ValueType {
internal IntPtr args
}
public System.RuntimeFieldHandle : ValueType {
private IntPtr value
public IntPtr Value
internal void .ctor(IntPtr v)
private void .ctor(SerializationInfo info, StreamingContext context)
public IntPtr get_Value()
public void GetObjectData(SerializationInfo info, StreamingContext context)
public bool Equals(object obj)
public bool Equals(RuntimeFieldHandle handle)
public int GetHashCode()
public bool op_Equality(RuntimeFieldHandle left, RuntimeFieldHandle right)
public bool op_Inequality(RuntimeFieldHandle left, RuntimeFieldHandle right)
private void SetValueInternal(FieldInfo fi, object obj, object value)
internal void SetValue(RtFieldInfo field, object obj, object value, RuntimeType fieldType, FieldAttributes fieldAttr, RuntimeType declaringType, Boolean& domainInitialized)
internal object GetValueDirect(RtFieldInfo field, RuntimeType fieldType, Void* pTypedRef, RuntimeType contextType)
internal void SetValueDirect(RtFieldInfo field, RuntimeType fieldType, Void* pTypedRef, object value, RuntimeType contextType)
}
public System.RuntimeMethodHandle : ValueType {
private IntPtr value
public IntPtr Value
internal void .ctor(IntPtr v)
private void .ctor(SerializationInfo info, StreamingContext context)
public IntPtr get_Value()
public void GetObjectData(SerializationInfo info, StreamingContext context)
private IntPtr GetFunctionPointer(IntPtr m)
public IntPtr GetFunctionPointer()
public bool Equals(object obj)
public bool Equals(RuntimeMethodHandle handle)
public int GetHashCode()
public bool op_Equality(RuntimeMethodHandle left, RuntimeMethodHandle right)
public bool op_Inequality(RuntimeMethodHandle left, RuntimeMethodHandle right)
internal string ConstructInstantiation(RuntimeMethodInfo method, TypeNameFormatFlags format)
internal bool IsNullHandle()
}
internal System.RuntimeMethodHandleInternal : ValueType {
internal IntPtr m_handle
internal RuntimeMethodHandleInternal EmptyHandle
internal IntPtr Value
internal RuntimeMethodHandleInternal get_EmptyHandle()
internal bool IsNullHandle()
internal IntPtr get_Value()
internal void .ctor(IntPtr value)
}
internal System.RuntimeType : TypeInfo {
internal RuntimeType ValueType
internal RuntimeType EnumType
private RuntimeType ObjectType
private RuntimeType StringType
private RuntimeType DelegateType
private Type[] s_SICtorParamTypes
private BindingFlags MemberBindingMask
private BindingFlags InvocationMask
private BindingFlags BinderNonCreateInstance
private BindingFlags BinderGetSetProperty
private BindingFlags BinderSetInvokeProperty
private BindingFlags BinderGetSetField
private BindingFlags BinderSetInvokeField
private BindingFlags BinderNonFieldGetSet
private BindingFlags ClassicBindingMask
private RuntimeType s_typedRef
private MonoTypeInfo type_info
internal object GenericCache
private RuntimeConstructorInfo m_serializationCtor
private Dictionary`2<Guid, Type> clsid_types
private AssemblyBuilder clsid_assemblybuilder
public Module Module
public Assembly Assembly
public RuntimeTypeHandle TypeHandle
public Type BaseType
public Type UnderlyingSystemType
public bool IsEnum
public GenericParameterAttributes GenericParameterAttributes
internal bool IsSzArray
public bool IsGenericTypeDefinition
public bool IsGenericParameter
public int GenericParameterPosition
public bool IsGenericType
public bool IsConstructedGenericType
public MemberTypes MemberType
public Type ReflectedType
public int MetadataToken
public StructLayoutAttribute StructLayoutAttribute
public bool ContainsGenericParameters
public Guid GUID
public MethodBase DeclaringMethod
public string AssemblyQualifiedName
public Type DeclaringType
public string Name
public string Namespace
public bool IsSecurityTransparent
public bool IsSecurityCritical
public bool IsSecuritySafeCritical
public string FullName
public bool IsSZArray
internal bool IsUserType
private void ThrowIfTypeNeverValidGenericArgument(RuntimeType type)
internal void SanityCheckGenericArguments(RuntimeType[] genericArguments, RuntimeType[] genericParamters)
private void SplitName(string fullname, String& name, String& ns)
internal BindingFlags FilterPreCalculate(bool isPublic, bool isInherited, bool isStatic)
private void FilterHelper(BindingFlags bindingFlags, String& name, bool allowPrefixLookup, Boolean& prefixLookup, Boolean& ignoreCase, MemberListType& listType)
private void FilterHelper(BindingFlags bindingFlags, String& name, Boolean& ignoreCase, MemberListType& listType)
private bool FilterApplyPrefixLookup(MemberInfo memberInfo, string name, bool ignoreCase)
private bool FilterApplyBase(MemberInfo memberInfo, BindingFlags bindingFlags, bool isPublic, bool isNonProtectedInternal, bool isStatic, string name, bool prefixLookup)
private bool FilterApplyType(Type type, BindingFlags bindingFlags, string name, bool prefixLookup, string ns)
private bool FilterApplyMethodInfo(RuntimeMethodInfo method, BindingFlags bindingFlags, CallingConventions callConv, Type[] argumentTypes)
private bool FilterApplyConstructorInfo(RuntimeConstructorInfo constructor, BindingFlags bindingFlags, CallingConventions callConv, Type[] argumentTypes)
private bool FilterApplyMethodBase(MethodBase methodBase, BindingFlags methodFlags, BindingFlags bindingFlags, CallingConventions callConv, Type[] argumentTypes)
internal bool IsSpecialSerializableType()
private ListBuilder`1<MethodInfo> GetMethodCandidates(string name, BindingFlags bindingAttr, CallingConventions callConv, Type[] types, bool allowPrefixLookup)
private ListBuilder`1<ConstructorInfo> GetConstructorCandidates(string name, BindingFlags bindingAttr, CallingConventions callConv, Type[] types, bool allowPrefixLookup)
private ListBuilder`1<PropertyInfo> GetPropertyCandidates(string name, BindingFlags bindingAttr, Type[] types, bool allowPrefixLookup)
private ListBuilder`1<EventInfo> GetEventCandidates(string name, BindingFlags bindingAttr, bool allowPrefixLookup)
private ListBuilder`1<FieldInfo> GetFieldCandidates(string name, BindingFlags bindingAttr, bool allowPrefixLookup)
private ListBuilder`1<Type> GetNestedTypeCandidates(string fullname, BindingFlags bindingAttr, bool allowPrefixLookup)
public MethodInfo[] GetMethods(BindingFlags bindingAttr)
public ConstructorInfo[] GetConstructors(BindingFlags bindingAttr)
public PropertyInfo[] GetProperties(BindingFlags bindingAttr)
public EventInfo[] GetEvents(BindingFlags bindingAttr)
public FieldInfo[] GetFields(BindingFlags bindingAttr)
public Type[] GetNestedTypes(BindingFlags bindingAttr)
public MemberInfo[] GetMembers(BindingFlags bindingAttr)
protected MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConv, Type[] types, ParameterModifier[] modifiers)
protected ConstructorInfo GetConstructorImpl(BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers)
protected PropertyInfo GetPropertyImpl(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers)
public EventInfo GetEvent(string name, BindingFlags bindingAttr)
public FieldInfo GetField(string name, BindingFlags bindingAttr)
public Type GetInterface(string fullname, bool ignoreCase)
public Type GetNestedType(string fullname, BindingFlags bindingAttr)
public MemberInfo[] GetMember(string name, MemberTypes type, BindingFlags bindingAttr)
public Module get_Module()
internal RuntimeModule GetRuntimeModule()
public Assembly get_Assembly()
internal RuntimeAssembly GetRuntimeAssembly()
public RuntimeTypeHandle get_TypeHandle()
internal RuntimeTypeHandle GetTypeHandleInternal()
public bool IsInstanceOfType(object o)
public bool IsSubclassOf(Type type)
public bool IsAssignableFrom(TypeInfo typeInfo)
public bool IsAssignableFrom(Type c)
public bool IsEquivalentTo(Type other)
public Type get_BaseType()
private RuntimeType GetBaseType()
public Type get_UnderlyingSystemType()
protected TypeAttributes GetAttributeFlagsImpl()
protected bool IsContextfulImpl()
protected bool IsByRefImpl()
protected bool IsPrimitiveImpl()
protected bool IsPointerImpl()
protected bool IsCOMObjectImpl()
internal bool IsWindowsRuntimeObjectImpl()
internal bool IsExportedToWindowsRuntimeImpl()
private bool IsWindowsRuntimeObjectType(RuntimeType type)
private bool IsTypeExportedToWindowsRuntime(RuntimeType type)
internal bool HasProxyAttributeImpl()
internal bool IsDelegate()
protected bool IsValueTypeImpl()
public bool get_IsEnum()
protected bool HasElementTypeImpl()
public GenericParameterAttributes get_GenericParameterAttributes()
internal bool get_IsSzArray()
protected bool IsArrayImpl()
public int GetArrayRank()
public Type GetElementType()
public String[] GetEnumNames()
public Array GetEnumValues()
public Type GetEnumUnderlyingType()
public bool IsEnumDefined(object value)
public string GetEnumName(object value)
internal RuntimeType[] GetGenericArgumentsInternal()
public Type[] GetGenericArguments()
public Type MakeGenericType(Type[] instantiation)
public bool get_IsGenericTypeDefinition()
public bool get_IsGenericParameter()
public int get_GenericParameterPosition()
public Type GetGenericTypeDefinition()
public bool get_IsGenericType()
public bool get_IsConstructedGenericType()
public MemberInfo[] GetDefaultMembers()
public object InvokeMember(string name, BindingFlags bindingFlags, Binder binder, object target, Object[] providedArgs, ParameterModifier[] modifiers, CultureInfo culture, String[] namedParams)
public bool Equals(object obj)
public bool op_Equality(RuntimeType left, RuntimeType right)
public bool op_Inequality(RuntimeType left, RuntimeType right)
public object Clone()
public void GetObjectData(SerializationInfo info, StreamingContext context)
public Object[] GetCustomAttributes(bool inherit)
public Object[] GetCustomAttributes(Type attributeType, bool inherit)
public bool IsDefined(Type attributeType, bool inherit)
public IList`1<CustomAttributeData> GetCustomAttributesData()
internal string FormatTypeName(bool serialization)
public MemberTypes get_MemberType()
public Type get_ReflectedType()
public int get_MetadataToken()
private void CreateInstanceCheckThis()
internal object CreateInstanceImpl(BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes, StackCrawlMark& stackMark)
private object ActivationCreateInstance(MethodBase invokeMethod, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes)
internal object CreateInstanceDefaultCtor(bool publicOnly, bool skipCheckThis, bool fillCache, StackCrawlMark& stackMark)
internal void .ctor(object obj)
internal MonoCMethod GetDefaultConstructor()
private MethodInfo GetCorrespondingInflatedMethod(MethodInfo generic)
private ConstructorInfo GetCorrespondingInflatedConstructor(ConstructorInfo generic)
internal MethodInfo GetMethod(MethodInfo fromNoninstanciated)
internal ConstructorInfo GetConstructor(ConstructorInfo fromNoninstanciated)
internal FieldInfo GetField(FieldInfo fromNoninstanciated)
private string GetDefaultMemberName()
internal RuntimeConstructorInfo GetSerializationCtor()
internal object CreateInstanceSlow(bool publicOnly, bool skipCheckThis, bool fillCache, StackCrawlMark& stackMark)
private object CreateInstanceMono(bool nonPublic)
internal object CheckValue(object value, Binder binder, CultureInfo culture, BindingFlags invokeAttr)
private object TryConvertToType(object value, Boolean& failed)
private object IsConvertibleToPrimitiveType(object value, Type targetType)
private string GetCachedName(TypeNameKind kind)
private Type make_array_type(int rank)
public Type MakeArrayType()
public Type MakeArrayType(int rank)
private Type make_byref_type()
public Type MakeByRefType()
private Type MakePointerType(Type type)
public Type MakePointerType()
public StructLayoutAttribute get_StructLayoutAttribute()
public bool get_ContainsGenericParameters()
public Type[] GetGenericParameterConstraints()
internal object CreateInstanceForAnotherGenericParameter(Type genericType, RuntimeType genericArgument)
private Type MakeGenericType(Type gt, Type[] types)
internal IntPtr GetMethodsByName_native(IntPtr namePtr, BindingFlags bindingAttr, bool ignoreCase)
internal RuntimeMethodInfo[] GetMethodsByName(string name, BindingFlags bindingAttr, bool ignoreCase, RuntimeType reflectedType)
private IntPtr GetPropertiesByName_native(IntPtr name, BindingFlags bindingAttr, bool icase)
private IntPtr GetConstructors_native(BindingFlags bindingAttr)
private RuntimeConstructorInfo[] GetConstructors_internal(BindingFlags bindingAttr, RuntimeType reflectedType)
private RuntimePropertyInfo[] GetPropertiesByName(string name, BindingFlags bindingAttr, bool icase, RuntimeType reflectedType)
public InterfaceMapping GetInterfaceMap(Type ifaceType)
private void GetInterfaceMapData(Type t, Type iface, MethodInfo[]& targets, MethodInfo[]& methods)
public Guid get_GUID()
internal void GetPacking(Int32& packing, Int32& size)
internal Type GetTypeFromCLSIDImpl(Guid clsid, string server, bool throwOnError)
protected TypeCode GetTypeCodeImpl()
private TypeCode GetTypeCodeImplInternal(Type type)
internal Type GetTypeFromProgIDImpl(string progID, string server, bool throwOnError)
public string ToString()
private bool IsGenericCOMObjectImpl()
private object CreateInstanceInternal(Type type)
public MethodBase get_DeclaringMethod()
internal string getFullName(bool full_name, bool assembly_qualified)
private Type[] GetGenericArgumentsInternal(bool runtimeArray)
private GenericParameterAttributes GetGenericParameterAttributes()
private int GetGenericParameterPosition()
private IntPtr GetEvents_native(IntPtr name, BindingFlags bindingAttr)
private IntPtr GetFields_native(IntPtr name, BindingFlags bindingAttr)
private RuntimeFieldInfo[] GetFields_internal(string name, BindingFlags bindingAttr, RuntimeType reflectedType)
private RuntimeEventInfo[] GetEvents_internal(string name, BindingFlags bindingAttr, RuntimeType reflectedType)
public Type[] GetInterfaces()
private IntPtr GetNestedTypes_native(IntPtr name, BindingFlags bindingAttr)
private RuntimeType[] GetNestedTypes_internal(string displayName, BindingFlags bindingAttr)
public string get_AssemblyQualifiedName()
public Type get_DeclaringType()
public string get_Name()
public string get_Namespace()
public int get_core_clr_security_level()
public bool get_IsSecurityTransparent()
public bool get_IsSecurityCritical()
public bool get_IsSecuritySafeCritical()
public int GetHashCode()
public string get_FullName()
public bool get_IsSZArray()
internal bool get_IsUserType()
}
public System.RuntimeTypeHandle : ValueType {
private IntPtr value
public IntPtr Value
internal void .ctor(IntPtr val)
internal void .ctor(RuntimeType type)
private void .ctor(SerializationInfo info, StreamingContext context)
public IntPtr get_Value()
public void GetObjectData(SerializationInfo info, StreamingContext context)
public bool Equals(object obj)
public bool Equals(RuntimeTypeHandle handle)
public int GetHashCode()
public bool op_Equality(RuntimeTypeHandle left, object right)
public bool op_Inequality(RuntimeTypeHandle left, object right)
public bool op_Equality(object left, RuntimeTypeHandle right)
public bool op_Inequality(object left, RuntimeTypeHandle right)
internal TypeAttributes GetAttributes(RuntimeType type)
public ModuleHandle GetModuleHandle()
private int GetMetadataToken(RuntimeType type)
internal int GetToken(RuntimeType type)
private Type GetGenericTypeDefinition_impl(RuntimeType type)
internal Type GetGenericTypeDefinition(RuntimeType type)
internal bool HasElementType(RuntimeType type)
internal bool HasProxyAttribute(RuntimeType type)
internal bool HasInstantiation(RuntimeType type)
internal bool IsArray(RuntimeType type)
internal bool IsByRef(RuntimeType type)
internal bool IsComObject(RuntimeType type)
internal bool IsInstanceOfType(RuntimeType type, object o)
internal bool IsPointer(RuntimeType type)
internal bool IsPrimitive(RuntimeType type)
internal bool HasReferences(RuntimeType type)
internal bool IsComObject(RuntimeType type, bool isGenericCOM)
internal bool IsContextful(RuntimeType type)
internal bool IsEquivalentTo(RuntimeType rtType1, RuntimeType rtType2)
internal bool IsSzArray(RuntimeType type)
internal bool IsInterface(RuntimeType type)
internal int GetArrayRank(RuntimeType type)
internal RuntimeAssembly GetAssembly(RuntimeType type)
internal RuntimeType GetElementType(RuntimeType type)
internal RuntimeModule GetModule(RuntimeType type)
internal bool IsGenericVariable(RuntimeType type)
internal RuntimeType GetBaseType(RuntimeType type)
internal bool CanCastTo(RuntimeType type, RuntimeType target)
private bool type_is_assignable_from(Type a, Type b)
internal bool IsGenericTypeDefinition(RuntimeType type)
internal IntPtr GetGenericParameterInfo(RuntimeType type)
}
public System.SByte : ValueType {
private sbyte m_value
public sbyte MaxValue
public sbyte MinValue
public int CompareTo(object obj)
public int CompareTo(sbyte value)
public bool Equals(object obj)
public bool Equals(sbyte obj)
public int GetHashCode()
public string ToString()
public string ToString(IFormatProvider provider)
public string ToString(string format)
public string ToString(string format, IFormatProvider provider)
private string ToString(string format, NumberFormatInfo info)
public sbyte Parse(string s)
public sbyte Parse(string s, NumberStyles style)
public sbyte Parse(string s, IFormatProvider provider)
public sbyte Parse(string s, NumberStyles style, IFormatProvider provider)
private sbyte Parse(string s, NumberStyles style, NumberFormatInfo info)
public bool TryParse(string s, SByte& result)
public bool TryParse(string s, NumberStyles style, IFormatProvider provider, SByte& result)
private bool TryParse(string s, NumberStyles style, NumberFormatInfo info, SByte& result)
public TypeCode GetTypeCode()
private bool System.IConvertible.ToBoolean(IFormatProvider provider)
private char System.IConvertible.ToChar(IFormatProvider provider)
private sbyte System.IConvertible.ToSByte(IFormatProvider provider)
private byte System.IConvertible.ToByte(IFormatProvider provider)
private short System.IConvertible.ToInt16(IFormatProvider provider)
private ushort System.IConvertible.ToUInt16(IFormatProvider provider)
private int System.IConvertible.ToInt32(IFormatProvider provider)
private UInt32 System.IConvertible.ToUInt32(IFormatProvider provider)
private long System.IConvertible.ToInt64(IFormatProvider provider)
private ulong System.IConvertible.ToUInt64(IFormatProvider provider)
private float System.IConvertible.ToSingle(IFormatProvider provider)
private double System.IConvertible.ToDouble(IFormatProvider provider)
private decimal System.IConvertible.ToDecimal(IFormatProvider provider)
private DateTime System.IConvertible.ToDateTime(IFormatProvider provider)
private object System.IConvertible.ToType(Type type, IFormatProvider provider)
}
public System.Security.AccessControl.AccessControlActions : Enum {
public int value__
public AccessControlActions None
public AccessControlActions View
public AccessControlActions Change
}
public System.Security.AccessControl.AccessControlModification : Enum {
public int value__
public AccessControlModification Add
public AccessControlModification Set
public AccessControlModification Reset
public AccessControlModification Remove
public AccessControlModification RemoveAll
public AccessControlModification RemoveSpecific
}
public System.Security.AccessControl.AccessControlSections : Enum {
public int value__
public AccessControlSections None
public AccessControlSections Audit
public AccessControlSections Access
public AccessControlSections Owner
public AccessControlSections Group
public AccessControlSections All
}
public System.Security.AccessControl.AccessControlType : Enum {
public int value__
public AccessControlType Allow
public AccessControlType Deny
}
public System.Security.AccessControl.AccessRule : AuthorizationRule {
private AccessControlType type
public AccessControlType AccessControlType
protected void .ctor(IdentityReference identity, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AccessControlType type)
public AccessControlType get_AccessControlType()
}
public System.Security.AccessControl.AccessRule`1 : AccessRule {
public T Rights
public void .ctor(string identity, T rights, AccessControlType type)
public void .ctor(IdentityReference identity, T rights, AccessControlType type)
public void .ctor(string identity, T rights, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AccessControlType type)
public void .ctor(IdentityReference identity, T rights, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AccessControlType type)
internal void .ctor(IdentityReference identity, int rights, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AccessControlType type)
public T get_Rights()
}
public System.Security.AccessControl.AceEnumerator : object {
private GenericAcl owner
private int current
public GenericAce Current
private object System.Collections.IEnumerator.Current
internal void .ctor(GenericAcl owner)
public GenericAce get_Current()
private object System.Collections.IEnumerator.get_Current()
public bool MoveNext()
public void Reset()
}
public System.Security.AccessControl.AceFlags : Enum {
public byte value__
public AceFlags None
public AceFlags ObjectInherit
public AceFlags ContainerInherit
public AceFlags NoPropagateInherit
public AceFlags InheritOnly
public AceFlags InheritanceFlags
public AceFlags Inherited
public AceFlags SuccessfulAccess
public AceFlags FailedAccess
public AceFlags AuditFlags
}
public System.Security.AccessControl.AceQualifier : Enum {
public int value__
public AceQualifier AccessAllowed
public AceQualifier AccessDenied
public AceQualifier SystemAudit
public AceQualifier SystemAlarm
}
public System.Security.AccessControl.AceType : Enum {
public byte value__
public AceType AccessAllowed
public AceType AccessDenied
public AceType SystemAudit
public AceType SystemAlarm
public AceType AccessAllowedCompound
public AceType AccessAllowedObject
public AceType AccessDeniedObject
public AceType SystemAuditObject
public AceType SystemAlarmObject
public AceType AccessAllowedCallback
public AceType AccessDeniedCallback
public AceType AccessAllowedCallbackObject
public AceType AccessDeniedCallbackObject
public AceType SystemAuditCallback
public AceType SystemAlarmCallback
public AceType SystemAuditCallbackObject
public AceType SystemAlarmCallbackObject
public AceType MaxDefinedAceType
}
public System.Security.AccessControl.AuditFlags : Enum {
public int value__
public AuditFlags None
public AuditFlags Success
public AuditFlags Failure
}
public System.Security.AccessControl.AuditRule : AuthorizationRule {
private AuditFlags auditFlags
public AuditFlags AuditFlags
protected void .ctor(IdentityReference identity, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags auditFlags)
public AuditFlags get_AuditFlags()
}
public System.Security.AccessControl.AuditRule`1 : AuditRule {
public T Rights
public void .ctor(string identity, T rights, AuditFlags flags)
public void .ctor(IdentityReference identity, T rights, AuditFlags flags)
public void .ctor(string identity, T rights, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags flags)
public void .ctor(IdentityReference identity, T rights, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags flags)
internal void .ctor(IdentityReference identity, int rights, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags flags)
public T get_Rights()
}
public System.Security.AccessControl.AuthorizationRule : object {
private IdentityReference identity
private int accessMask
private bool isInherited
private InheritanceFlags inheritanceFlags
private PropagationFlags propagationFlags
public IdentityReference IdentityReference
public InheritanceFlags InheritanceFlags
public bool IsInherited
public PropagationFlags PropagationFlags
protected internal int AccessMask
protected internal void .ctor(IdentityReference identity, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags)
public IdentityReference get_IdentityReference()
public InheritanceFlags get_InheritanceFlags()
public bool get_IsInherited()
public PropagationFlags get_PropagationFlags()
protected internal int get_AccessMask()
}
public System.Security.AccessControl.AuthorizationRuleCollection : ReadOnlyCollectionBase {
public AuthorizationRule Item
internal void .ctor(AuthorizationRule[] rules)
public void AddRule(AuthorizationRule rule)
public AuthorizationRule get_Item(int index)
public void CopyTo(AuthorizationRule[] rules, int index)
}
public System.Security.AccessControl.CommonAce : QualifiedAce {
public int BinaryLength
public void .ctor(AceFlags flags, AceQualifier qualifier, int accessMask, SecurityIdentifier sid, bool isCallback, Byte[] opaque)
internal void .ctor(AceType type, AceFlags flags, int accessMask, SecurityIdentifier sid, Byte[] opaque)
internal void .ctor(Byte[] binaryForm, int offset)
public int get_BinaryLength()
public void GetBinaryForm(Byte[] binaryForm, int offset)
public int MaxOpaqueLength(bool isCallback)
internal string GetSddlForm()
private AceType ConvertType(AceQualifier qualifier, bool isCallback)
}
public System.Security.AccessControl.CommonAcl : GenericAcl {
private int default_capacity
private bool is_aefa
private bool is_canonical
private bool is_container
private bool is_ds
internal RawAcl raw_acl
public int BinaryLength
public int Count
public bool IsCanonical
public bool IsContainer
public bool IsDS
internal bool IsAefa
public byte Revision
public GenericAce Item
internal void .ctor(bool isContainer, bool isDS, RawAcl rawAcl)
internal void .ctor(bool isContainer, bool isDS, byte revision, int capacity)
internal void .ctor(bool isContainer, bool isDS, int capacity)
private void Init(bool isContainer, bool isDS, RawAcl rawAcl)
public int get_BinaryLength()
public int get_Count()
public bool get_IsCanonical()
public bool get_IsContainer()
public bool get_IsDS()
internal bool get_IsAefa()
internal void set_IsAefa(bool value)
public byte get_Revision()
public GenericAce get_Item(int index)
public void set_Item(int index, GenericAce value)
public void GetBinaryForm(Byte[] binaryForm, int offset)
public void Purge(SecurityIdentifier sid)
public void RemoveInheritedAces()
internal void RequireCanonicity()
internal void CanonicalizeAndClearAefa()
internal bool IsAceMeaningless(GenericAce ace)
private bool TestCanonicity()
internal int GetCanonicalExplicitDenyAceCount()
internal int GetCanonicalExplicitAceCount()
private void MergeExplicitAces()
private GenericAce MergeExplicitAcePair(GenericAce ace1, GenericAce ace2)
private void GetObjectAceTypeGuids(ObjectAce ace, Guid& type, Guid& inheritedType)
internal void ApplyCanonicalSortToExplicitAces()
internal void ApplyCanonicalSortToExplicitAces(int start, int count)
internal string GetSddlForm(ControlFlags sdFlags, bool isDacl)
internal void RemoveAces(RemoveAcesCallback`1<T> callback)
internal void AddAce(AceQualifier aceQualifier, SecurityIdentifier sid, int accessMask, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags auditFlags)
internal void AddAce(AceQualifier aceQualifier, SecurityIdentifier sid, int accessMask, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags auditFlags, ObjectAceFlags objectFlags, Guid objectType, Guid inheritedObjectType)
private QualifiedAce AddAceGetQualifiedAce(AceQualifier aceQualifier, SecurityIdentifier sid, int accessMask, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags auditFlags, ObjectAceFlags objectFlags, Guid objectType, Guid inheritedObjectType)
private QualifiedAce AddAceGetQualifiedAce(AceQualifier aceQualifier, SecurityIdentifier sid, int accessMask, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags auditFlags)
private void AddAce(QualifiedAce newAce)
private GenericAce CopyAce(GenericAce ace)
internal int GetAceInsertPosition(AceQualifier aceQualifier)
private AceFlags GetAceFlags(InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags auditFlags)
internal void RemoveAceSpecific(AceQualifier aceQualifier, SecurityIdentifier sid, int accessMask, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags auditFlags)
internal void RemoveAceSpecific(AceQualifier aceQualifier, SecurityIdentifier sid, int accessMask, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags auditFlags, ObjectAceFlags objectFlags, Guid objectType, Guid inheritedObjectType)
internal void SetAce(AceQualifier aceQualifier, SecurityIdentifier sid, int accessMask, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags auditFlags)
internal void SetAce(AceQualifier aceQualifier, SecurityIdentifier sid, int accessMask, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags auditFlags, ObjectAceFlags objectFlags, Guid objectType, Guid inheritedObjectType)
private void SetAce(QualifiedAce newAce)
}
public System.Security.AccessControl.CommonObjectSecurity : ObjectSecurity {
protected void .ctor(bool isContainer)
internal void .ctor(CommonSecurityDescriptor securityDescriptor)
public AuthorizationRuleCollection GetAccessRules(bool includeExplicit, bool includeInherited, Type targetType)
public AuthorizationRuleCollection GetAuditRules(bool includeExplicit, bool includeInherited, Type targetType)
protected void AddAccessRule(AccessRule rule)
protected bool RemoveAccessRule(AccessRule rule)
protected void RemoveAccessRuleAll(AccessRule rule)
protected void RemoveAccessRuleSpecific(AccessRule rule)
protected void ResetAccessRule(AccessRule rule)
protected void SetAccessRule(AccessRule rule)
protected bool ModifyAccess(AccessControlModification modification, AccessRule rule, Boolean& modified)
protected void AddAuditRule(AuditRule rule)
protected bool RemoveAuditRule(AuditRule rule)
protected void RemoveAuditRuleAll(AuditRule rule)
protected void RemoveAuditRuleSpecific(AuditRule rule)
protected void SetAuditRule(AuditRule rule)
protected bool ModifyAudit(AccessControlModification modification, AuditRule rule, Boolean& modified)
}
public System.Security.AccessControl.CommonSecurityDescriptor : GenericSecurityDescriptor {
private bool is_container
private bool is_ds
private ControlFlags flags
private SecurityIdentifier owner
private SecurityIdentifier group
private SystemAcl system_acl
private DiscretionaryAcl discretionary_acl
public ControlFlags ControlFlags
public DiscretionaryAcl DiscretionaryAcl
internal GenericAcl InternalDacl
public SecurityIdentifier Group
public bool IsContainer
public bool IsDiscretionaryAclCanonical
public bool IsDS
public bool IsSystemAclCanonical
public SecurityIdentifier Owner
public SystemAcl SystemAcl
internal GenericAcl InternalSacl
internal bool DaclIsUnmodifiedAefa
public void .ctor(bool isContainer, bool isDS, RawSecurityDescriptor rawSecurityDescriptor)
public void .ctor(bool isContainer, bool isDS, string sddlForm)
public void .ctor(bool isContainer, bool isDS, Byte[] binaryForm, int offset)
public void .ctor(bool isContainer, bool isDS, ControlFlags flags, SecurityIdentifier owner, SecurityIdentifier group, SystemAcl systemAcl, DiscretionaryAcl discretionaryAcl)
private void Init(bool isContainer, bool isDS, RawSecurityDescriptor rawSecurityDescriptor)
private void Init(bool isContainer, bool isDS, ControlFlags flags, SecurityIdentifier owner, SecurityIdentifier group, SystemAcl systemAcl, DiscretionaryAcl discretionaryAcl)
public ControlFlags get_ControlFlags()
public DiscretionaryAcl get_DiscretionaryAcl()
public void set_DiscretionaryAcl(DiscretionaryAcl value)
internal GenericAcl get_InternalDacl()
public SecurityIdentifier get_Group()
public void set_Group(SecurityIdentifier value)
public bool get_IsContainer()
public bool get_IsDiscretionaryAclCanonical()
public bool get_IsDS()
public bool get_IsSystemAclCanonical()
public SecurityIdentifier get_Owner()
public void set_Owner(SecurityIdentifier value)
public SystemAcl get_SystemAcl()
public void set_SystemAcl(SystemAcl value)
internal GenericAcl get_InternalSacl()
public void PurgeAccessControl(SecurityIdentifier sid)
public void PurgeAudit(SecurityIdentifier sid)
public void SetDiscretionaryAclProtection(bool isProtected, bool preserveInheritance)
public void SetSystemAclProtection(bool isProtected, bool preserveInheritance)
public void AddDiscretionaryAcl(byte revision, int trusted)
public void AddSystemAcl(byte revision, int trusted)
private void CheckAclConsistency(CommonAcl acl)
internal bool get_DaclIsUnmodifiedAefa()
}
public System.Security.AccessControl.CompoundAce : KnownAce {
private CompoundAceType compound_ace_type
public int BinaryLength
public CompoundAceType CompoundAceType
public void .ctor(AceFlags flags, int accessMask, CompoundAceType compoundAceType, SecurityIdentifier sid)
public int get_BinaryLength()
public CompoundAceType get_CompoundAceType()
public void set_CompoundAceType(CompoundAceType value)
public void GetBinaryForm(Byte[] binaryForm, int offset)
internal string GetSddlForm()
}
public System.Security.AccessControl.CompoundAceType : Enum {
public int value__
public CompoundAceType Impersonation
}
public System.Security.AccessControl.ControlFlags : Enum {
public int value__
public ControlFlags None
public ControlFlags OwnerDefaulted
public ControlFlags GroupDefaulted
public ControlFlags DiscretionaryAclPresent
public ControlFlags DiscretionaryAclDefaulted
public ControlFlags SystemAclPresent
public ControlFlags SystemAclDefaulted
public ControlFlags DiscretionaryAclUntrusted
public ControlFlags ServerSecurity
public ControlFlags DiscretionaryAclAutoInheritRequired
public ControlFlags SystemAclAutoInheritRequired
public ControlFlags DiscretionaryAclAutoInherited
public ControlFlags SystemAclAutoInherited
public ControlFlags DiscretionaryAclProtected
public ControlFlags SystemAclProtected
public ControlFlags RMControlValid
public ControlFlags SelfRelative
}
public System.Security.AccessControl.CryptoKeyAccessRule : AccessRule {
public CryptoKeyRights CryptoKeyRights
public void .ctor(IdentityReference identity, CryptoKeyRights cryptoKeyRights, AccessControlType type)
public void .ctor(string identity, CryptoKeyRights cryptoKeyRights, AccessControlType type)
public CryptoKeyRights get_CryptoKeyRights()
}
public System.Security.AccessControl.CryptoKeyAuditRule : AuditRule {
public CryptoKeyRights CryptoKeyRights
public void .ctor(IdentityReference identity, CryptoKeyRights cryptoKeyRights, AuditFlags flags)
public void .ctor(string identity, CryptoKeyRights cryptoKeyRights, AuditFlags flags)
public CryptoKeyRights get_CryptoKeyRights()
}
public System.Security.AccessControl.CryptoKeyRights : Enum {
public int value__
public CryptoKeyRights ReadData
public CryptoKeyRights WriteData
public CryptoKeyRights ReadExtendedAttributes
public CryptoKeyRights WriteExtendedAttributes
public CryptoKeyRights ReadAttributes
public CryptoKeyRights WriteAttributes
public CryptoKeyRights Delete
public CryptoKeyRights ReadPermissions
public CryptoKeyRights ChangePermissions
public CryptoKeyRights TakeOwnership
public CryptoKeyRights Synchronize
public CryptoKeyRights FullControl
public CryptoKeyRights GenericAll
public CryptoKeyRights GenericExecute
public CryptoKeyRights GenericWrite
public CryptoKeyRights GenericRead
}
public System.Security.AccessControl.CryptoKeySecurity : NativeObjectSecurity {
public Type AccessRightType
public Type AccessRuleType
public Type AuditRuleType
public void .ctor(CommonSecurityDescriptor securityDescriptor)
public Type get_AccessRightType()
public Type get_AccessRuleType()
public Type get_AuditRuleType()
public AccessRule AccessRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AccessControlType type)
public void AddAccessRule(CryptoKeyAccessRule rule)
public bool RemoveAccessRule(CryptoKeyAccessRule rule)
public void RemoveAccessRuleAll(CryptoKeyAccessRule rule)
public void RemoveAccessRuleSpecific(CryptoKeyAccessRule rule)
public void ResetAccessRule(CryptoKeyAccessRule rule)
public void SetAccessRule(CryptoKeyAccessRule rule)
public AuditRule AuditRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags flags)
public void AddAuditRule(CryptoKeyAuditRule rule)
public bool RemoveAuditRule(CryptoKeyAuditRule rule)
public void RemoveAuditRuleAll(CryptoKeyAuditRule rule)
public void RemoveAuditRuleSpecific(CryptoKeyAuditRule rule)
public void SetAuditRule(CryptoKeyAuditRule rule)
}
public System.Security.AccessControl.CustomAce : GenericAce {
private Byte[] opaque
public int MaxOpaqueLength
public int BinaryLength
public int OpaqueLength
public void .ctor(AceType type, AceFlags flags, Byte[] opaque)
public int get_BinaryLength()
public int get_OpaqueLength()
public void GetBinaryForm(Byte[] binaryForm, int offset)
public Byte[] GetOpaque()
public void SetOpaque(Byte[] opaque)
internal string GetSddlForm()
}
public System.Security.AccessControl.DirectoryObjectSecurity : ObjectSecurity {
protected void .ctor(CommonSecurityDescriptor securityDescriptor)
private Exception GetNotImplementedException()
public AccessRule AccessRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AccessControlType type, Guid objectType, Guid inheritedObjectType)
internal AccessRule InternalAccessRuleFactory(QualifiedAce ace, Type targetType, AccessControlType type)
public AuditRule AuditRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags flags, Guid objectType, Guid inheritedObjectType)
internal AuditRule InternalAuditRuleFactory(QualifiedAce ace, Type targetType)
public AuthorizationRuleCollection GetAccessRules(bool includeExplicit, bool includeInherited, Type targetType)
public AuthorizationRuleCollection GetAuditRules(bool includeExplicit, bool includeInherited, Type targetType)
protected void AddAccessRule(ObjectAccessRule rule)
protected bool RemoveAccessRule(ObjectAccessRule rule)
protected void RemoveAccessRuleAll(ObjectAccessRule rule)
protected void RemoveAccessRuleSpecific(ObjectAccessRule rule)
protected void ResetAccessRule(ObjectAccessRule rule)
protected void SetAccessRule(ObjectAccessRule rule)
protected bool ModifyAccess(AccessControlModification modification, AccessRule rule, Boolean& modified)
protected void AddAuditRule(ObjectAuditRule rule)
protected bool RemoveAuditRule(ObjectAuditRule rule)
protected void RemoveAuditRuleAll(ObjectAuditRule rule)
protected void RemoveAuditRuleSpecific(ObjectAuditRule rule)
protected void SetAuditRule(ObjectAuditRule rule)
protected bool ModifyAudit(AccessControlModification modification, AuditRule rule, Boolean& modified)
}
public System.Security.AccessControl.DirectorySecurity : FileSystemSecurity {
public void .ctor(string name, AccessControlSections includeSections)
}
public System.Security.AccessControl.DiscretionaryAcl : CommonAcl {
public void .ctor(bool isContainer, bool isDS, int capacity)
public void .ctor(bool isContainer, bool isDS, RawAcl rawAcl)
public void .ctor(bool isContainer, bool isDS, byte revision, int capacity)
public void AddAccess(AccessControlType accessType, SecurityIdentifier sid, int accessMask, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags)
public void AddAccess(AccessControlType accessType, SecurityIdentifier sid, int accessMask, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, ObjectAceFlags objectFlags, Guid objectType, Guid inheritedObjectType)
public void AddAccess(AccessControlType accessType, SecurityIdentifier sid, ObjectAccessRule rule)
public bool RemoveAccess(AccessControlType accessType, SecurityIdentifier sid, int accessMask, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags)
public bool RemoveAccess(AccessControlType accessType, SecurityIdentifier sid, int accessMask, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, ObjectAceFlags objectFlags, Guid objectType, Guid inheritedObjectType)
public bool RemoveAccess(AccessControlType accessType, SecurityIdentifier sid, ObjectAccessRule rule)
public void RemoveAccessSpecific(AccessControlType accessType, SecurityIdentifier sid, int accessMask, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags)
public void RemoveAccessSpecific(AccessControlType accessType, SecurityIdentifier sid, int accessMask, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, ObjectAceFlags objectFlags, Guid objectType, Guid inheritedObjectType)
public void RemoveAccessSpecific(AccessControlType accessType, SecurityIdentifier sid, ObjectAccessRule rule)
public void SetAccess(AccessControlType accessType, SecurityIdentifier sid, int accessMask, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags)
public void SetAccess(AccessControlType accessType, SecurityIdentifier sid, int accessMask, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, ObjectAceFlags objectFlags, Guid objectType, Guid inheritedObjectType)
public void SetAccess(AccessControlType accessType, SecurityIdentifier sid, ObjectAccessRule rule)
internal void ApplyCanonicalSortToExplicitAces()
internal int GetAceInsertPosition(AceQualifier aceQualifier)
private AceQualifier GetAceQualifier(AccessControlType accessType)
internal bool IsAceMeaningless(GenericAce ace)
}
public System.Security.AccessControl.EventWaitHandleAccessRule : AccessRule {
public EventWaitHandleRights EventWaitHandleRights
public void .ctor(IdentityReference identity, EventWaitHandleRights eventRights, AccessControlType type)
public void .ctor(string identity, EventWaitHandleRights eventRights, AccessControlType type)
public EventWaitHandleRights get_EventWaitHandleRights()
}
public System.Security.AccessControl.EventWaitHandleAuditRule : AuditRule {
public EventWaitHandleRights EventWaitHandleRights
public void .ctor(IdentityReference identity, EventWaitHandleRights eventRights, AuditFlags flags)
public EventWaitHandleRights get_EventWaitHandleRights()
}
public System.Security.AccessControl.EventWaitHandleRights : Enum {
public int value__
public EventWaitHandleRights Modify
public EventWaitHandleRights Delete
public EventWaitHandleRights ReadPermissions
public EventWaitHandleRights ChangePermissions
public EventWaitHandleRights TakeOwnership
public EventWaitHandleRights Synchronize
public EventWaitHandleRights FullControl
}
public System.Security.AccessControl.EventWaitHandleSecurity : NativeObjectSecurity {
public Type AccessRightType
public Type AccessRuleType
public Type AuditRuleType
internal void .ctor(SafeHandle handle, AccessControlSections includeSections)
public Type get_AccessRightType()
public Type get_AccessRuleType()
public Type get_AuditRuleType()
public AccessRule AccessRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AccessControlType type)
public void AddAccessRule(EventWaitHandleAccessRule rule)
public bool RemoveAccessRule(EventWaitHandleAccessRule rule)
public void RemoveAccessRuleAll(EventWaitHandleAccessRule rule)
public void RemoveAccessRuleSpecific(EventWaitHandleAccessRule rule)
public void ResetAccessRule(EventWaitHandleAccessRule rule)
public void SetAccessRule(EventWaitHandleAccessRule rule)
public AuditRule AuditRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags flags)
public void AddAuditRule(EventWaitHandleAuditRule rule)
public bool RemoveAuditRule(EventWaitHandleAuditRule rule)
public void RemoveAuditRuleAll(EventWaitHandleAuditRule rule)
public void RemoveAuditRuleSpecific(EventWaitHandleAuditRule rule)
public void SetAuditRule(EventWaitHandleAuditRule rule)
internal void Persist(SafeHandle handle)
}
public System.Security.AccessControl.FileSecurity : FileSystemSecurity {
public void .ctor(string fileName, AccessControlSections includeSections)
internal void .ctor(SafeHandle handle, AccessControlSections includeSections)
}
public System.Security.AccessControl.FileSystemAccessRule : AccessRule {
public FileSystemRights FileSystemRights
public void .ctor(IdentityReference identity, FileSystemRights fileSystemRights, AccessControlType type)
public void .ctor(string identity, FileSystemRights fileSystemRights, AccessControlType type)
public void .ctor(IdentityReference identity, FileSystemRights fileSystemRights, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AccessControlType type)
internal void .ctor(IdentityReference identity, FileSystemRights fileSystemRights, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AccessControlType type)
public void .ctor(string identity, FileSystemRights fileSystemRights, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AccessControlType type)
public FileSystemRights get_FileSystemRights()
}
public System.Security.AccessControl.FileSystemAuditRule : AuditRule {
public FileSystemRights FileSystemRights
public void .ctor(IdentityReference identity, FileSystemRights fileSystemRights, AuditFlags flags)
public void .ctor(string identity, FileSystemRights fileSystemRights, AuditFlags flags)
public void .ctor(IdentityReference identity, FileSystemRights fileSystemRights, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags flags)
internal void .ctor(IdentityReference identity, FileSystemRights fileSystemRights, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags flags)
public void .ctor(string identity, FileSystemRights fileSystemRights, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags flags)
public FileSystemRights get_FileSystemRights()
}
public System.Security.AccessControl.FileSystemRights : Enum {
public int value__
public FileSystemRights ListDirectory
public FileSystemRights ReadData
public FileSystemRights CreateFiles
public FileSystemRights WriteData
public FileSystemRights AppendData
public FileSystemRights CreateDirectories
public FileSystemRights ReadExtendedAttributes
public FileSystemRights WriteExtendedAttributes
public FileSystemRights ExecuteFile
public FileSystemRights Traverse
public FileSystemRights DeleteSubdirectoriesAndFiles
public FileSystemRights ReadAttributes
public FileSystemRights WriteAttributes
public FileSystemRights Write
public FileSystemRights Delete
public FileSystemRights ReadPermissions
public FileSystemRights Read
public FileSystemRights ReadAndExecute
public FileSystemRights Modify
public FileSystemRights ChangePermissions
public FileSystemRights TakeOwnership
public FileSystemRights Synchronize
public FileSystemRights FullControl
}
public System.Security.AccessControl.FileSystemSecurity : NativeObjectSecurity {
public Type AccessRightType
public Type AccessRuleType
public Type AuditRuleType
internal void .ctor(bool isContainer)
internal void .ctor(bool isContainer, string name, AccessControlSections includeSections)
internal void .ctor(bool isContainer, SafeHandle handle, AccessControlSections includeSections)
public Type get_AccessRightType()
public Type get_AccessRuleType()
public Type get_AuditRuleType()
public AccessRule AccessRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AccessControlType type)
public void AddAccessRule(FileSystemAccessRule rule)
public bool RemoveAccessRule(FileSystemAccessRule rule)
public void RemoveAccessRuleAll(FileSystemAccessRule rule)
public void RemoveAccessRuleSpecific(FileSystemAccessRule rule)
public void ResetAccessRule(FileSystemAccessRule rule)
public void SetAccessRule(FileSystemAccessRule rule)
public AuditRule AuditRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags flags)
public void AddAuditRule(FileSystemAuditRule rule)
public bool RemoveAuditRule(FileSystemAuditRule rule)
public void RemoveAuditRuleAll(FileSystemAuditRule rule)
public void RemoveAuditRuleSpecific(FileSystemAuditRule rule)
public void SetAuditRule(FileSystemAuditRule rule)
}
public System.Security.AccessControl.GenericAce : object {
private AceFlags ace_flags
private AceType ace_type
public AceFlags AceFlags
public AceType AceType
public AuditFlags AuditFlags
public int BinaryLength
public InheritanceFlags InheritanceFlags
public bool IsInherited
public PropagationFlags PropagationFlags
internal void .ctor(AceType type, AceFlags flags)
internal void .ctor(Byte[] binaryForm, int offset)
public AceFlags get_AceFlags()
public void set_AceFlags(AceFlags value)
public AceType get_AceType()
public AuditFlags get_AuditFlags()
public int get_BinaryLength()
public InheritanceFlags get_InheritanceFlags()
public bool get_IsInherited()
public PropagationFlags get_PropagationFlags()
public GenericAce Copy()
public GenericAce CreateFromBinaryForm(Byte[] binaryForm, int offset)
public bool Equals(object o)
public void GetBinaryForm(Byte[] binaryForm, int offset)
public int GetHashCode()
public bool op_Equality(GenericAce left, GenericAce right)
public bool op_Inequality(GenericAce left, GenericAce right)
internal string GetSddlForm()
internal GenericAce CreateFromSddlForm(string sddlForm, Int32& pos)
private bool IsObjectType(AceType type)
internal string GetSddlAceType(AceType type)
private AceType ParseSddlAceType(string type)
internal string GetSddlAceFlags(AceFlags flags)
private AceFlags ParseSddlAceFlags(string flags)
private int ParseSddlAccessRights(string accessMask)
private int ParseSddlAliasRights(string accessMask)
internal ushort ReadUShort(Byte[] buffer, int offset)
internal int ReadInt(Byte[] buffer, int offset)
internal void WriteInt(int val, Byte[] buffer, int offset)
internal void WriteUShort(ushort val, Byte[] buffer, int offset)
}
public System.Security.AccessControl.GenericAcl : object {
public byte AclRevision
public byte AclRevisionDS
public int MaxBinaryLength
public int BinaryLength
public int Count
public bool IsSynchronized
public GenericAce Item
public byte Revision
public object SyncRoot
public int get_BinaryLength()
public int get_Count()
public bool get_IsSynchronized()
public GenericAce get_Item(int index)
public void set_Item(int index, GenericAce value)
public byte get_Revision()
public object get_SyncRoot()
public void CopyTo(GenericAce[] array, int index)
private void System.Collections.ICollection.CopyTo(Array array, int index)
public void GetBinaryForm(Byte[] binaryForm, int offset)
public AceEnumerator GetEnumerator()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
internal string GetSddlForm(ControlFlags sdFlags, bool isDacl)
}
public System.Security.AccessControl.GenericSecurityDescriptor : object {
public int BinaryLength
public ControlFlags ControlFlags
public SecurityIdentifier Group
public SecurityIdentifier Owner
public byte Revision
internal GenericAcl InternalDacl
internal GenericAcl InternalSacl
internal byte InternalReservedField
internal bool DaclIsUnmodifiedAefa
private bool DaclPresent
private bool SaclPresent
public int get_BinaryLength()
public ControlFlags get_ControlFlags()
public SecurityIdentifier get_Group()
public void set_Group(SecurityIdentifier value)
public SecurityIdentifier get_Owner()
public void set_Owner(SecurityIdentifier value)
public byte get_Revision()
internal GenericAcl get_InternalDacl()
internal GenericAcl get_InternalSacl()
internal byte get_InternalReservedField()
public void GetBinaryForm(Byte[] binaryForm, int offset)
public string GetSddlForm(AccessControlSections includeSections)
public bool IsSddlConversionSupported()
internal bool get_DaclIsUnmodifiedAefa()
private bool get_DaclPresent()
private bool get_SaclPresent()
private void WriteUShort(ushort val, Byte[] buffer, int offset)
private void WriteInt(int val, Byte[] buffer, int offset)
}
public System.Security.AccessControl.InheritanceFlags : Enum {
public int value__
public InheritanceFlags None
public InheritanceFlags ContainerInherit
public InheritanceFlags ObjectInherit
}
public System.Security.AccessControl.KnownAce : GenericAce {
private int access_mask
private SecurityIdentifier identifier
public int AccessMask
public SecurityIdentifier SecurityIdentifier
internal void .ctor(AceType type, AceFlags flags)
internal void .ctor(Byte[] binaryForm, int offset)
public int get_AccessMask()
public void set_AccessMask(int value)
public SecurityIdentifier get_SecurityIdentifier()
public void set_SecurityIdentifier(SecurityIdentifier value)
internal string GetSddlAccessRights(int accessMask)
private string GetSddlAliasRights(int accessMask)
}
public System.Security.AccessControl.MutexAccessRule : AccessRule {
public MutexRights MutexRights
public void .ctor(IdentityReference identity, MutexRights eventRights, AccessControlType type)
public void .ctor(string identity, MutexRights eventRights, AccessControlType type)
public MutexRights get_MutexRights()
}
public System.Security.AccessControl.MutexAuditRule : AuditRule {
public MutexRights MutexRights
public void .ctor(IdentityReference identity, MutexRights eventRights, AuditFlags flags)
public MutexRights get_MutexRights()
}
public System.Security.AccessControl.MutexRights : Enum {
public int value__
public MutexRights Modify
public MutexRights Delete
public MutexRights ReadPermissions
public MutexRights ChangePermissions
public MutexRights TakeOwnership
public MutexRights Synchronize
public MutexRights FullControl
}
public System.Security.AccessControl.MutexSecurity : NativeObjectSecurity {
public Type AccessRightType
public Type AccessRuleType
public Type AuditRuleType
public void .ctor(string name, AccessControlSections includeSections)
internal void .ctor(SafeHandle handle, AccessControlSections includeSections)
public Type get_AccessRightType()
public Type get_AccessRuleType()
public Type get_AuditRuleType()
public AccessRule AccessRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AccessControlType type)
public void AddAccessRule(MutexAccessRule rule)
public bool RemoveAccessRule(MutexAccessRule rule)
public void RemoveAccessRuleAll(MutexAccessRule rule)
public void RemoveAccessRuleSpecific(MutexAccessRule rule)
public void ResetAccessRule(MutexAccessRule rule)
public void SetAccessRule(MutexAccessRule rule)
public AuditRule AuditRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags flags)
public void AddAuditRule(MutexAuditRule rule)
public bool RemoveAuditRule(MutexAuditRule rule)
public void RemoveAuditRuleAll(MutexAuditRule rule)
public void RemoveAuditRuleSpecific(MutexAuditRule rule)
public void SetAuditRule(MutexAuditRule rule)
private Exception MutexExceptionFromErrorCode(int errorCode, string name, SafeHandle handle, object context)
}
public System.Security.AccessControl.NativeObjectSecurity : CommonObjectSecurity {
private ExceptionFromErrorCode exception_from_error_code
private ResourceType resource_type
internal ResourceType ResourceType
internal void .ctor(CommonSecurityDescriptor securityDescriptor, ResourceType resourceType)
protected void .ctor(bool isContainer, ResourceType resourceType)
protected void .ctor(bool isContainer, ResourceType resourceType, ExceptionFromErrorCode exceptionFromErrorCode, object exceptionContext)
protected void .ctor(bool isContainer, ResourceType resourceType, SafeHandle handle, AccessControlSections includeSections)
protected void .ctor(bool isContainer, ResourceType resourceType, string name, AccessControlSections includeSections)
protected void .ctor(bool isContainer, ResourceType resourceType, SafeHandle handle, AccessControlSections includeSections, ExceptionFromErrorCode exceptionFromErrorCode, object exceptionContext)
protected void .ctor(bool isContainer, ResourceType resourceType, string name, AccessControlSections includeSections, ExceptionFromErrorCode exceptionFromErrorCode, object exceptionContext)
private void ClearAccessControlSectionsModified()
protected void Persist(SafeHandle handle, AccessControlSections includeSections)
protected void Persist(string name, AccessControlSections includeSections)
internal void PersistModifications(SafeHandle handle)
protected void Persist(SafeHandle handle, AccessControlSections includeSections, object exceptionContext)
internal void PersistModifications(string name)
protected void Persist(string name, AccessControlSections includeSections, object exceptionContext)
internal Exception DefaultExceptionFromErrorCode(int errorCode, string name, SafeHandle handle, object context)
private void RaiseExceptionOnFailure(int errorCode, string name, SafeHandle handle, object context)
internal int InternalGet(SafeHandle handle, AccessControlSections includeSections)
internal int InternalGet(string name, AccessControlSections includeSections)
internal int InternalSet(SafeHandle handle, AccessControlSections includeSections)
internal int InternalSet(string name, AccessControlSections includeSections)
internal ResourceType get_ResourceType()
private int Win32GetHelper(GetSecurityInfoNativeCall nativeCall, AccessControlSections includeSections)
private int Win32SetHelper(SetSecurityInfoNativeCall nativeCall, AccessControlSections includeSections)
private string Win32FixName(string name)
private int GetSecurityInfo(SafeHandle handle, ResourceType resourceType, SecurityInfos securityInfos, IntPtr& owner, IntPtr& group, IntPtr& dacl, IntPtr& sacl, IntPtr& descriptor)
private int GetNamedSecurityInfo(string name, ResourceType resourceType, SecurityInfos securityInfos, IntPtr& owner, IntPtr& group, IntPtr& dacl, IntPtr& sacl, IntPtr& descriptor)
private IntPtr LocalFree(IntPtr handle)
private int SetSecurityInfo(SafeHandle handle, ResourceType resourceType, SecurityInfos securityInfos, Byte[] owner, Byte[] group, Byte[] dacl, Byte[] sacl)
private int SetNamedSecurityInfo(string name, ResourceType resourceType, SecurityInfos securityInfos, Byte[] owner, Byte[] group, Byte[] dacl, Byte[] sacl)
private int GetSecurityDescriptorLength(IntPtr descriptor)
private bool IsValidSecurityDescriptor(IntPtr descriptor)
}
public System.Security.AccessControl.ObjectAccessRule : AccessRule {
private Guid object_type
private Guid inherited_object_type
public Guid InheritedObjectType
public ObjectAceFlags ObjectFlags
public Guid ObjectType
protected void .ctor(IdentityReference identity, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, Guid objectType, Guid inheritedObjectType, AccessControlType type)
public Guid get_InheritedObjectType()
public ObjectAceFlags get_ObjectFlags()
public Guid get_ObjectType()
}
public System.Security.AccessControl.ObjectAce : QualifiedAce {
private Guid object_ace_type
private Guid inherited_object_type
private ObjectAceFlags object_ace_flags
public int BinaryLength
public Guid InheritedObjectAceType
private bool InheritedObjectAceTypePresent
public ObjectAceFlags ObjectAceFlags
public Guid ObjectAceType
private bool ObjectAceTypePresent
public void .ctor(AceFlags aceFlags, AceQualifier qualifier, int accessMask, SecurityIdentifier sid, ObjectAceFlags flags, Guid type, Guid inheritedType, bool isCallback, Byte[] opaque)
internal void .ctor(AceType type, AceFlags flags, int accessMask, SecurityIdentifier sid, ObjectAceFlags objFlags, Guid objType, Guid inheritedType, Byte[] opaque)
internal void .ctor(Byte[] binaryForm, int offset)
public int get_BinaryLength()
public Guid get_InheritedObjectAceType()
public void set_InheritedObjectAceType(Guid value)
private bool get_InheritedObjectAceTypePresent()
public ObjectAceFlags get_ObjectAceFlags()
public void set_ObjectAceFlags(ObjectAceFlags value)
public Guid get_ObjectAceType()
public void set_ObjectAceType(Guid value)
private bool get_ObjectAceTypePresent()
public void GetBinaryForm(Byte[] binaryForm, int offset)
public int MaxOpaqueLength(bool isCallback)
internal string GetSddlForm()
private AceType ConvertType(AceQualifier qualifier, bool isCallback)
private void WriteGuid(Guid val, Byte[] buffer, int offset)
private Guid ReadGuid(Byte[] buffer, int offset)
}
public System.Security.AccessControl.ObjectAceFlags : Enum {
public int value__
public ObjectAceFlags None
public ObjectAceFlags ObjectAceTypePresent
public ObjectAceFlags InheritedObjectAceTypePresent
}
public System.Security.AccessControl.ObjectAuditRule : AuditRule {
private Guid inherited_object_type
private Guid object_type
public Guid InheritedObjectType
public ObjectAceFlags ObjectFlags
public Guid ObjectType
protected void .ctor(IdentityReference identity, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, Guid objectType, Guid inheritedObjectType, AuditFlags auditFlags)
public Guid get_InheritedObjectType()
public ObjectAceFlags get_ObjectFlags()
public Guid get_ObjectType()
}
public System.Security.AccessControl.ObjectSecurity : object {
internal CommonSecurityDescriptor descriptor
private AccessControlSections sections_modified
private ReaderWriterLock rw_lock
public Type AccessRightType
public Type AccessRuleType
public Type AuditRuleType
public bool AreAccessRulesCanonical
public bool AreAccessRulesProtected
public bool AreAuditRulesCanonical
public bool AreAuditRulesProtected
internal AccessControlSections AccessControlSectionsModified
protected bool AccessRulesModified
protected bool AuditRulesModified
protected bool GroupModified
protected bool IsContainer
protected bool IsDS
protected bool OwnerModified
protected void .ctor(CommonSecurityDescriptor securityDescriptor)
protected void .ctor(bool isContainer, bool isDS)
public Type get_AccessRightType()
public Type get_AccessRuleType()
public Type get_AuditRuleType()
public bool get_AreAccessRulesCanonical()
public bool get_AreAccessRulesProtected()
public bool get_AreAuditRulesCanonical()
public bool get_AreAuditRulesProtected()
internal AccessControlSections get_AccessControlSectionsModified()
internal void set_AccessControlSectionsModified(AccessControlSections value)
protected bool get_AccessRulesModified()
protected void set_AccessRulesModified(bool value)
protected bool get_AuditRulesModified()
protected void set_AuditRulesModified(bool value)
protected bool get_GroupModified()
protected void set_GroupModified(bool value)
protected bool get_IsContainer()
protected bool get_IsDS()
protected bool get_OwnerModified()
protected void set_OwnerModified(bool value)
public AccessRule AccessRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AccessControlType type)
public AuditRule AuditRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags flags)
public IdentityReference GetGroup(Type targetType)
public IdentityReference GetOwner(Type targetType)
public Byte[] GetSecurityDescriptorBinaryForm()
public string GetSecurityDescriptorSddlForm(AccessControlSections includeSections)
public bool IsSddlConversionSupported()
public bool ModifyAccessRule(AccessControlModification modification, AccessRule rule, Boolean& modified)
public bool ModifyAuditRule(AccessControlModification modification, AuditRule rule, Boolean& modified)
public void PurgeAccessRules(IdentityReference identity)
public void PurgeAuditRules(IdentityReference identity)
public void SetAccessRuleProtection(bool isProtected, bool preserveInheritance)
public void SetAuditRuleProtection(bool isProtected, bool preserveInheritance)
public void SetGroup(IdentityReference identity)
public void SetOwner(IdentityReference identity)
public void SetSecurityDescriptorBinaryForm(Byte[] binaryForm)
public void SetSecurityDescriptorBinaryForm(Byte[] binaryForm, AccessControlSections includeSections)
public void SetSecurityDescriptorSddlForm(string sddlForm)
public void SetSecurityDescriptorSddlForm(string sddlForm, AccessControlSections includeSections)
private void CopySddlForm(CommonSecurityDescriptor sourceDescriptor, AccessControlSections includeSections)
protected bool ModifyAccess(AccessControlModification modification, AccessRule rule, Boolean& modified)
protected bool ModifyAudit(AccessControlModification modification, AuditRule rule, Boolean& modified)
private Exception GetNotImplementedException()
protected void Persist(SafeHandle handle, AccessControlSections includeSections)
protected void Persist(string name, AccessControlSections includeSections)
protected void Persist(bool enableOwnershipPrivilege, string name, AccessControlSections includeSections)
private void Reading()
protected void ReadLock()
protected void ReadUnlock()
private void Writing()
protected void WriteLock()
protected void WriteUnlock()
internal AuthorizationRuleCollection InternalGetAccessRules(bool includeExplicit, bool includeInherited, Type targetType)
internal AccessRule InternalAccessRuleFactory(QualifiedAce ace, Type targetType, AccessControlType type)
internal AuthorizationRuleCollection InternalGetAuditRules(bool includeExplicit, bool includeInherited, Type targetType)
internal AuditRule InternalAuditRuleFactory(QualifiedAce ace, Type targetType)
internal SecurityIdentifier SidFromIR(IdentityReference identity)
private bool AreAccessControlSectionsModified(AccessControlSections mask)
private void SetAccessControlSectionsModified(AccessControlSections mask, bool modified)
}
public System.Security.AccessControl.ObjectSecurity`1 : NativeObjectSecurity {
public Type AccessRightType
public Type AccessRuleType
public Type AuditRuleType
protected void .ctor(bool isContainer, ResourceType resourceType)
protected void .ctor(bool isContainer, ResourceType resourceType, SafeHandle safeHandle, AccessControlSections includeSections)
protected void .ctor(bool isContainer, ResourceType resourceType, string name, AccessControlSections includeSections)
protected void .ctor(bool isContainer, ResourceType resourceType, SafeHandle safeHandle, AccessControlSections includeSections, ExceptionFromErrorCode exceptionFromErrorCode, object exceptionContext)
protected void .ctor(bool isContainer, ResourceType resourceType, string name, AccessControlSections includeSections, ExceptionFromErrorCode exceptionFromErrorCode, object exceptionContext)
public Type get_AccessRightType()
public Type get_AccessRuleType()
public Type get_AuditRuleType()
public AccessRule AccessRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AccessControlType type)
public void AddAccessRule(AccessRule`1<T> rule)
public bool RemoveAccessRule(AccessRule`1<T> rule)
public void RemoveAccessRuleAll(AccessRule`1<T> rule)
public void RemoveAccessRuleSpecific(AccessRule`1<T> rule)
public void ResetAccessRule(AccessRule`1<T> rule)
public void SetAccessRule(AccessRule`1<T> rule)
public AuditRule AuditRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags flags)
public void AddAuditRule(AuditRule`1<T> rule)
public bool RemoveAuditRule(AuditRule`1<T> rule)
public void RemoveAuditRuleAll(AuditRule`1<T> rule)
public void RemoveAuditRuleSpecific(AuditRule`1<T> rule)
public void SetAuditRule(AuditRule`1<T> rule)
protected void Persist(SafeHandle handle)
protected void Persist(string name)
}
public System.Security.AccessControl.PrivilegeNotHeldException : UnauthorizedAccessException {
public string PrivilegeName
public void .ctor(string privilege)
public void .ctor(string privilege, Exception inner)
public string get_PrivilegeName()
public void GetObjectData(SerializationInfo info, StreamingContext context)
}
public System.Security.AccessControl.PropagationFlags : Enum {
public int value__
public PropagationFlags None
public PropagationFlags NoPropagateInherit
public PropagationFlags InheritOnly
}
public System.Security.AccessControl.QualifiedAce : KnownAce {
private Byte[] opaque
public AceQualifier AceQualifier
public bool IsCallback
public int OpaqueLength
internal void .ctor(AceType type, AceFlags flags, Byte[] opaque)
internal void .ctor(Byte[] binaryForm, int offset)
public AceQualifier get_AceQualifier()
public bool get_IsCallback()
public int get_OpaqueLength()
public Byte[] GetOpaque()
public void SetOpaque(Byte[] opaque)
}
public System.Security.AccessControl.RawAcl : GenericAcl {
private byte revision
private List`1<GenericAce> list
public int BinaryLength
public int Count
public GenericAce Item
public byte Revision
public void .ctor(byte revision, int capacity)
public void .ctor(Byte[] binaryForm, int offset)
internal void .ctor(byte revision, List`1<GenericAce> aces)
public int get_BinaryLength()
public int get_Count()
public GenericAce get_Item(int index)
public void set_Item(int index, GenericAce value)
public byte get_Revision()
public void GetBinaryForm(Byte[] binaryForm, int offset)
public void InsertAce(int index, GenericAce ace)
public void RemoveAce(int index)
internal string GetSddlForm(ControlFlags sdFlags, bool isDacl)
internal RawAcl ParseSddlForm(string sddlForm, bool isDacl, ControlFlags& sdFlags, Int32& pos)
private void ParseFlags(string sddlForm, bool isDacl, ControlFlags& sdFlags, Int32& pos)
private void WriteUShort(ushort val, Byte[] buffer, int offset)
private ushort ReadUShort(Byte[] buffer, int offset)
}
public System.Security.AccessControl.RawSecurityDescriptor : GenericSecurityDescriptor {
private ControlFlags control_flags
private SecurityIdentifier owner_sid
private SecurityIdentifier group_sid
private RawAcl system_acl
private RawAcl discretionary_acl
private byte resourcemgr_control
public ControlFlags ControlFlags
public RawAcl DiscretionaryAcl
public SecurityIdentifier Group
public SecurityIdentifier Owner
public byte ResourceManagerControl
public RawAcl SystemAcl
internal GenericAcl InternalDacl
internal GenericAcl InternalSacl
internal byte InternalReservedField
public void .ctor(string sddlForm)
public void .ctor(Byte[] binaryForm, int offset)
public void .ctor(ControlFlags flags, SecurityIdentifier owner, SecurityIdentifier group, RawAcl systemAcl, RawAcl discretionaryAcl)
public ControlFlags get_ControlFlags()
public RawAcl get_DiscretionaryAcl()
public void set_DiscretionaryAcl(RawAcl value)
public SecurityIdentifier get_Group()
public void set_Group(SecurityIdentifier value)
public SecurityIdentifier get_Owner()
public void set_Owner(SecurityIdentifier value)
public byte get_ResourceManagerControl()
public void set_ResourceManagerControl(byte value)
public RawAcl get_SystemAcl()
public void set_SystemAcl(RawAcl value)
public void SetFlags(ControlFlags flags)
internal GenericAcl get_InternalDacl()
internal GenericAcl get_InternalSacl()
internal byte get_InternalReservedField()
private void ParseSddl(string sddlForm)
private ushort ReadUShort(Byte[] buffer, int offset)
private int ReadInt(Byte[] buffer, int offset)
}
public System.Security.AccessControl.RegistryAccessRule : AccessRule {
public RegistryRights RegistryRights
public void .ctor(IdentityReference identity, RegistryRights registryRights, AccessControlType type)
public void .ctor(string identity, RegistryRights registryRights, AccessControlType type)
public void .ctor(IdentityReference identity, RegistryRights registryRights, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AccessControlType type)
internal void .ctor(IdentityReference identity, RegistryRights registryRights, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AccessControlType type)
public void .ctor(string identity, RegistryRights registryRights, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AccessControlType type)
public RegistryRights get_RegistryRights()
}
public System.Security.AccessControl.RegistryAuditRule : AuditRule {
public RegistryRights RegistryRights
public void .ctor(IdentityReference identity, RegistryRights registryRights, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags flags)
internal void .ctor(IdentityReference identity, RegistryRights registryRights, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags flags)
public void .ctor(string identity, RegistryRights registryRights, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags flags)
public RegistryRights get_RegistryRights()
}
public System.Security.AccessControl.RegistryRights : Enum {
public int value__
public RegistryRights QueryValues
public RegistryRights SetValue
public RegistryRights CreateSubKey
public RegistryRights EnumerateSubKeys
public RegistryRights Notify
public RegistryRights CreateLink
public RegistryRights Delete
public RegistryRights ReadPermissions
public RegistryRights WriteKey
public RegistryRights ReadKey
public RegistryRights ExecuteKey
public RegistryRights ChangePermissions
public RegistryRights TakeOwnership
public RegistryRights FullControl
}
public System.Security.AccessControl.RegistrySecurity : NativeObjectSecurity {
public Type AccessRightType
public Type AccessRuleType
public Type AuditRuleType
internal void .ctor(string name, AccessControlSections includeSections)
public Type get_AccessRightType()
public Type get_AccessRuleType()
public Type get_AuditRuleType()
public AccessRule AccessRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AccessControlType type)
public void AddAccessRule(RegistryAccessRule rule)
public bool RemoveAccessRule(RegistryAccessRule rule)
public void RemoveAccessRuleAll(RegistryAccessRule rule)
public void RemoveAccessRuleSpecific(RegistryAccessRule rule)
public void ResetAccessRule(RegistryAccessRule rule)
public void SetAccessRule(RegistryAccessRule rule)
public AuditRule AuditRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags flags)
public void AddAuditRule(RegistryAuditRule rule)
public bool RemoveAuditRule(RegistryAuditRule rule)
public void RemoveAuditRuleAll(RegistryAuditRule rule)
public void RemoveAuditRuleSpecific(RegistryAuditRule rule)
public void SetAuditRule(RegistryAuditRule rule)
}
public System.Security.AccessControl.ResourceType : Enum {
public int value__
public ResourceType Unknown
public ResourceType FileObject
public ResourceType Service
public ResourceType Printer
public ResourceType RegistryKey
public ResourceType LMShare
public ResourceType KernelObject
public ResourceType WindowObject
public ResourceType DSObject
public ResourceType DSObjectAll
public ResourceType ProviderDefined
public ResourceType WmiGuidObject
public ResourceType RegistryWow6432Key
}
internal System.Security.AccessControl.SddlAccessRight : object {
private string <Name>k__BackingField
private int <Value>k__BackingField
private int <ObjectType>k__BackingField
private SddlAccessRight[] rights
public string Name
public int Value
public int ObjectType
public string get_Name()
public void set_Name(string value)
public int get_Value()
public void set_Value(int value)
public int get_ObjectType()
public void set_ObjectType(int value)
public SddlAccessRight LookupByName(string s)
public SddlAccessRight[] Decompose(int mask)
}
public System.Security.AccessControl.SecurityInfos : Enum {
public int value__
public SecurityInfos Owner
public SecurityInfos Group
public SecurityInfos DiscretionaryAcl
public SecurityInfos SystemAcl
}
public System.Security.AccessControl.SystemAcl : CommonAcl {
public void .ctor(bool isContainer, bool isDS, int capacity)
public void .ctor(bool isContainer, bool isDS, RawAcl rawAcl)
public void .ctor(bool isContainer, bool isDS, byte revision, int capacity)
public void AddAudit(AuditFlags auditFlags, SecurityIdentifier sid, int accessMask, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags)
public void AddAudit(AuditFlags auditFlags, SecurityIdentifier sid, int accessMask, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, ObjectAceFlags objectFlags, Guid objectType, Guid inheritedObjectType)
public void AddAudit(SecurityIdentifier sid, ObjectAuditRule rule)
public bool RemoveAudit(AuditFlags auditFlags, SecurityIdentifier sid, int accessMask, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags)
public bool RemoveAudit(AuditFlags auditFlags, SecurityIdentifier sid, int accessMask, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, ObjectAceFlags objectFlags, Guid objectType, Guid inheritedObjectType)
public bool RemoveAudit(SecurityIdentifier sid, ObjectAuditRule rule)
public void RemoveAuditSpecific(AuditFlags auditFlags, SecurityIdentifier sid, int accessMask, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags)
public void RemoveAuditSpecific(AuditFlags auditFlags, SecurityIdentifier sid, int accessMask, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, ObjectAceFlags objectFlags, Guid objectType, Guid inheritedObjectType)
public void RemoveAuditSpecific(SecurityIdentifier sid, ObjectAuditRule rule)
public void SetAudit(AuditFlags auditFlags, SecurityIdentifier sid, int accessMask, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags)
public void SetAudit(AuditFlags auditFlags, SecurityIdentifier sid, int accessMask, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, ObjectAceFlags objectFlags, Guid objectType, Guid inheritedObjectType)
public void SetAudit(SecurityIdentifier sid, ObjectAuditRule rule)
internal void ApplyCanonicalSortToExplicitAces()
internal int GetAceInsertPosition(AceQualifier aceQualifier)
internal bool IsAceMeaningless(GenericAce ace)
private bool IsValidAuditFlags(AuditFlags auditFlags)
}
public System.Security.AllowPartiallyTrustedCallersAttribute : Attribute {
private PartialTrustVisibilityLevel _visibilityLevel
public PartialTrustVisibilityLevel PartialTrustVisibilityLevel
public PartialTrustVisibilityLevel get_PartialTrustVisibilityLevel()
public void set_PartialTrustVisibilityLevel(PartialTrustVisibilityLevel value)
}
public System.Security.Claims.Claim : object {
private string m_issuer
private string m_originalIssuer
private string m_type
private string m_value
private string m_valueType
private Byte[] m_userSerializationData
private Dictionary`2<string, string> m_properties
private object m_propertyLock
private ClaimsIdentity m_subject
protected Byte[] CustomSerializationData
public string Issuer
public string OriginalIssuer
public IDictionary`2<string, string> Properties
public ClaimsIdentity Subject
public string Type
public string Value
public string ValueType
public void .ctor(BinaryReader reader)
public void .ctor(BinaryReader reader, ClaimsIdentity subject)
public void .ctor(string type, string value)
public void .ctor(string type, string value, string valueType)
public void .ctor(string type, string value, string valueType, string issuer)
public void .ctor(string type, string value, string valueType, string issuer, string originalIssuer)
public void .ctor(string type, string value, string valueType, string issuer, string originalIssuer, ClaimsIdentity subject)
internal void .ctor(string type, string value, string valueType, string issuer, string originalIssuer, ClaimsIdentity subject, string propertyKey, string propertyValue)
protected void .ctor(Claim other)
protected void .ctor(Claim other, ClaimsIdentity subject)
protected Byte[] get_CustomSerializationData()
public string get_Issuer()
private void OnDeserializedMethod(StreamingContext context)
public string get_OriginalIssuer()
public IDictionary`2<string, string> get_Properties()
public ClaimsIdentity get_Subject()
internal void set_Subject(ClaimsIdentity value)
public string get_Type()
public string get_Value()
public string get_ValueType()
public Claim Clone()
public Claim Clone(ClaimsIdentity identity)
private void Initialize(BinaryReader reader, ClaimsIdentity subject)
public void WriteTo(BinaryWriter writer)
protected void WriteTo(BinaryWriter writer, Byte[] userData)
public string ToString()
}
public System.Security.Claims.ClaimsIdentity : object {
private Byte[] m_userSerializationData
private string PreFix
private string ActorKey
private string AuthenticationTypeKey
private string BootstrapContextKey
private string ClaimsKey
private string LabelKey
private string NameClaimTypeKey
private string RoleClaimTypeKey
private string VersionKey
public string DefaultIssuer
public string DefaultNameClaimType
public string DefaultRoleClaimType
private List`1<Claim> m_instanceClaims
private Collection`1<IEnumerable`1<Claim>> m_externalClaims
private string m_nameType
private string m_roleType
private string m_version
private ClaimsIdentity m_actor
private string m_authenticationType
private object m_bootstrapContext
private string m_label
private string m_serializedNameType
private string m_serializedRoleType
private string m_serializedClaims
public string AuthenticationType
public bool IsAuthenticated
public ClaimsIdentity Actor
public object BootstrapContext
public IEnumerable`1<Claim> Claims
protected Byte[] CustomSerializationData
internal Collection`1<IEnumerable`1<Claim>> ExternalClaims
public string Label
public string Name
public string NameClaimType
public string RoleClaimType
public void .ctor(IIdentity identity)
public void .ctor(IEnumerable`1<Claim> claims)
public void .ctor(string authenticationType)
public void .ctor(IEnumerable`1<Claim> claims, string authenticationType)
public void .ctor(IIdentity identity, IEnumerable`1<Claim> claims)
public void .ctor(string authenticationType, string nameType, string roleType)
public void .ctor(IEnumerable`1<Claim> claims, string authenticationType, string nameType, string roleType)
public void .ctor(IIdentity identity, IEnumerable`1<Claim> claims, string authenticationType, string nameType, string roleType)
internal void .ctor(IIdentity identity, IEnumerable`1<Claim> claims, string authenticationType, string nameType, string roleType, bool checkAuthType)
public void .ctor(BinaryReader reader)
protected void .ctor(ClaimsIdentity other)
protected void .ctor(SerializationInfo info, StreamingContext context)
protected void .ctor(SerializationInfo info)
public string get_AuthenticationType()
public bool get_IsAuthenticated()
public ClaimsIdentity get_Actor()
public void set_Actor(ClaimsIdentity value)
public object get_BootstrapContext()
public void set_BootstrapContext(object value)
public IEnumerable`1<Claim> get_Claims()
protected Byte[] get_CustomSerializationData()
internal Collection`1<IEnumerable`1<Claim>> get_ExternalClaims()
public string get_Label()
public void set_Label(string value)
public string get_Name()
public string get_NameClaimType()
public string get_RoleClaimType()
public ClaimsIdentity Clone()
public void AddClaim(Claim claim)
public void AddClaims(IEnumerable`1<Claim> claims)
public bool TryRemoveClaim(Claim claim)
public void RemoveClaim(Claim claim)
private void SafeAddClaims(IEnumerable`1<Claim> claims)
private void SafeAddClaim(Claim claim)
public IEnumerable`1<Claim> FindAll(Predicate`1<Claim> match)
public IEnumerable`1<Claim> FindAll(string type)
public bool HasClaim(Predicate`1<Claim> match)
public bool HasClaim(string type, string value)
public Claim FindFirst(Predicate`1<Claim> match)
public Claim FindFirst(string type)
private void OnSerializingMethod(StreamingContext context)
private void OnDeserializedMethod(StreamingContext context)
private void OnDeserializingMethod(StreamingContext context)
protected void GetObjectData(SerializationInfo info, StreamingContext context)
private void DeserializeClaims(string serializedClaims)
private string SerializeClaims()
private bool IsCircular(ClaimsIdentity subject)
private void Initialize(BinaryReader reader)
protected Claim CreateClaim(BinaryReader reader)
public void WriteTo(BinaryWriter writer)
protected void WriteTo(BinaryWriter writer, Byte[] userData)
private void Deserialize(SerializationInfo info, StreamingContext context, bool useContext)
}
public System.Security.Claims.ClaimsPrincipal : object {
private Byte[] m_userSerializationData
private string PreFix
private string IdentitiesKey
private string VersionKey
private string m_version
private string m_serializedClaimsIdentities
private List`1<ClaimsIdentity> m_identities
private Func`2<IEnumerable`1<ClaimsIdentity>, ClaimsIdentity> s_identitySelector
private Func`1<ClaimsPrincipal> s_principalSelector
public Func`2<IEnumerable`1<ClaimsIdentity>, ClaimsIdentity> PrimaryIdentitySelector
public Func`1<ClaimsPrincipal> ClaimsPrincipalSelector
protected Byte[] CustomSerializationData
public IEnumerable`1<Claim> Claims
public ClaimsPrincipal Current
public IEnumerable`1<ClaimsIdentity> Identities
public IIdentity Identity
private ClaimsIdentity SelectPrimaryIdentity(IEnumerable`1<ClaimsIdentity> identities)
private ClaimsPrincipal SelectClaimsPrincipal()
public Func`2<IEnumerable`1<ClaimsIdentity>, ClaimsIdentity> get_PrimaryIdentitySelector()
public void set_PrimaryIdentitySelector(Func`2<IEnumerable`1<ClaimsIdentity>, ClaimsIdentity> value)
public Func`1<ClaimsPrincipal> get_ClaimsPrincipalSelector()
public void set_ClaimsPrincipalSelector(Func`1<ClaimsPrincipal> value)
public void .ctor(IEnumerable`1<ClaimsIdentity> identities)
public void .ctor(IIdentity identity)
public void .ctor(IPrincipal principal)
public void .ctor(BinaryReader reader)
protected void .ctor(SerializationInfo info, StreamingContext context)
protected Byte[] get_CustomSerializationData()
public ClaimsPrincipal Clone()
protected ClaimsIdentity CreateClaimsIdentity(BinaryReader reader)
private void OnSerializingMethod(StreamingContext context)
private void OnDeserializedMethod(StreamingContext context)
protected void GetObjectData(SerializationInfo info, StreamingContext context)
private void Deserialize(SerializationInfo info, StreamingContext context)
private void DeserializeIdentities(string identities)
private string SerializeIdentities()
public void AddIdentity(ClaimsIdentity identity)
public void AddIdentities(IEnumerable`1<ClaimsIdentity> identities)
public IEnumerable`1<Claim> get_Claims()
public ClaimsPrincipal get_Current()
public IEnumerable`1<Claim> FindAll(Predicate`1<Claim> match)
public IEnumerable`1<Claim> FindAll(string type)
public Claim FindFirst(Predicate`1<Claim> match)
public Claim FindFirst(string type)
public bool HasClaim(Predicate`1<Claim> match)
public bool HasClaim(string type, string value)
public IEnumerable`1<ClaimsIdentity> get_Identities()
public IIdentity get_Identity()
public bool IsInRole(string role)
private void Initialize(BinaryReader reader)
public void WriteTo(BinaryWriter writer)
protected void WriteTo(BinaryWriter writer, Byte[] userData)
}
public System.Security.Claims.ClaimTypes : object {
internal string ClaimTypeNamespace
public string AuthenticationInstant
public string AuthenticationMethod
public string CookiePath
public string DenyOnlyPrimarySid
public string DenyOnlyPrimaryGroupSid
public string DenyOnlyWindowsDeviceGroup
public string Dsa
public string Expiration
public string Expired
public string GroupSid
public string IsPersistent
public string PrimaryGroupSid
public string PrimarySid
public string Role
public string SerialNumber
public string UserData
public string Version
public string WindowsAccountName
public string WindowsDeviceClaim
public string WindowsDeviceGroup
public string WindowsUserClaim
public string WindowsFqbnVersion
public string WindowsSubAuthority
internal string ClaimType2005Namespace
public string Anonymous
public string Authentication
public string AuthorizationDecision
public string Country
public string DateOfBirth
public string Dns
public string DenyOnlySid
public string Email
public string Gender
public string GivenName
public string Hash
public string HomePhone
public string Locality
public string MobilePhone
public string Name
public string NameIdentifier
public string OtherPhone
public string PostalCode
public string Rsa
public string Sid
public string Spn
public string StateOrProvince
public string StreetAddress
public string Surname
public string System
public string Thumbprint
public string Upn
public string Uri
public string Webpage
public string X500DistinguishedName
internal string ClaimType2009Namespace
public string Actor
}
public System.Security.Claims.ClaimValueTypes : object {
private string XmlSchemaNamespace
public string Base64Binary
public string Base64Octet
public string Boolean
public string Date
public string DateTime
public string Double
public string Fqbn
public string HexBinary
public string Integer
public string Integer32
public string Integer64
public string Sid
public string String
public string Time
public string UInteger32
public string UInteger64
private string SoapSchemaNamespace
public string DnsName
public string Email
public string Rsa
public string UpnName
private string XmlSignatureConstantsNamespace
public string DsaKeyValue
public string KeyInfo
public string RsaKeyValue
private string XQueryOperatorsNameSpace
public string DaytimeDuration
public string YearMonthDuration
private string Xacml10Namespace
public string Rfc822Name
public string X500Name
}
internal System.Security.Claims.RoleClaimProvider : object {
private string m_issuer
private String[] m_roles
private ClaimsIdentity m_subject
public IEnumerable`1<Claim> Claims
public void .ctor(string issuer, String[] roles, ClaimsIdentity subject)
public IEnumerable`1<Claim> get_Claims()
}
public System.Security.CodeAccessPermission : object {
public void Assert()
public IPermission Copy()
public void Demand()
public void Deny()
public bool Equals(object obj)
public void FromXml(SecurityElement elem)
public int GetHashCode()
public IPermission Intersect(IPermission target)
public bool IsSubsetOf(IPermission target)
public string ToString()
public SecurityElement ToXml()
public IPermission Union(IPermission other)
public void PermitOnly()
public void RevertAll()
public void RevertAssert()
public void RevertDeny()
public void RevertPermitOnly()
internal SecurityElement Element(int version)
internal PermissionState CheckPermissionState(PermissionState state, bool allowUnrestricted)
internal int CheckSecurityElement(SecurityElement se, string parameterName, int minimumVersion, int maximumVersion)
internal bool IsUnrestricted(SecurityElement se)
internal void ThrowInvalidPermission(IPermission target, Type expected)
}
public System.Security.Cryptography.Aes : SymmetricAlgorithm {
private KeySizes[] s_legalBlockSizes
private KeySizes[] s_legalKeySizes
public Aes Create()
public Aes Create(string algorithmName)
}
public System.Security.Cryptography.AsymmetricAlgorithm : object {
protected int KeySizeValue
protected KeySizes[] LegalKeySizesValue
public int KeySize
public KeySizes[] LegalKeySizes
public string SignatureAlgorithm
public string KeyExchangeAlgorithm
public void Dispose()
public void Clear()
protected void Dispose(bool disposing)
public int get_KeySize()
public void set_KeySize(int value)
public KeySizes[] get_LegalKeySizes()
public string get_SignatureAlgorithm()
public string get_KeyExchangeAlgorithm()
public AsymmetricAlgorithm Create()
public AsymmetricAlgorithm Create(string algName)
public void FromXmlString(string xmlString)
public string ToXmlString(bool includePrivateParameters)
}
public System.Security.Cryptography.AsymmetricKeyExchangeDeformatter : object {
public string Parameters
public string get_Parameters()
public void set_Parameters(string value)
public void SetKey(AsymmetricAlgorithm key)
public Byte[] DecryptKeyExchange(Byte[] rgb)
}
public System.Security.Cryptography.AsymmetricKeyExchangeFormatter : object {
public string Parameters
public string get_Parameters()
public void SetKey(AsymmetricAlgorithm key)
public Byte[] CreateKeyExchange(Byte[] data)
public Byte[] CreateKeyExchange(Byte[] data, Type symAlgType)
}
public System.Security.Cryptography.AsymmetricSignatureDeformatter : object {
public void SetKey(AsymmetricAlgorithm key)
public void SetHashAlgorithm(string strName)
public bool VerifySignature(HashAlgorithm hash, Byte[] rgbSignature)
public bool VerifySignature(Byte[] rgbHash, Byte[] rgbSignature)
}
public System.Security.Cryptography.AsymmetricSignatureFormatter : object {
public void SetKey(AsymmetricAlgorithm key)
public void SetHashAlgorithm(string strName)
public Byte[] CreateSignature(HashAlgorithm hash)
public Byte[] CreateSignature(Byte[] rgbHash)
}
public System.Security.Cryptography.CipherMode : Enum {
public int value__
public CipherMode CBC
public CipherMode ECB
public CipherMode OFB
public CipherMode CFB
public CipherMode CTS
}
internal System.Security.Cryptography.Constants : object {
internal int S_OK
internal int NTE_FILENOTFOUND
internal int NTE_NO_KEY
internal int NTE_BAD_KEYSET
internal int NTE_KEYSET_NOT_DEF
internal int KP_IV
internal int KP_MODE
internal int KP_MODE_BITS
internal int KP_EFFECTIVE_KEYLEN
internal int ALG_CLASS_SIGNATURE
internal int ALG_CLASS_DATA_ENCRYPT
internal int ALG_CLASS_HASH
internal int ALG_CLASS_KEY_EXCHANGE
internal int ALG_TYPE_DSS
internal int ALG_TYPE_RSA
internal int ALG_TYPE_BLOCK
internal int ALG_TYPE_STREAM
internal int ALG_TYPE_ANY
internal int CALG_MD5
internal int CALG_SHA1
internal int CALG_SHA_256
internal int CALG_SHA_384
internal int CALG_SHA_512
internal int CALG_RSA_KEYX
internal int CALG_RSA_SIGN
internal int CALG_DSS_SIGN
internal int CALG_DES
internal int CALG_RC2
internal int CALG_3DES
internal int CALG_3DES_112
internal int CALG_AES_128
internal int CALG_AES_192
internal int CALG_AES_256
internal int CALG_RC4
internal int PROV_RSA_FULL
internal int PROV_DSS_DH
internal int PROV_RSA_AES
internal int AT_KEYEXCHANGE
internal int AT_SIGNATURE
internal int PUBLICKEYBLOB
internal int PRIVATEKEYBLOB
internal int CRYPT_OAEP
internal UInt32 CRYPT_VERIFYCONTEXT
internal UInt32 CRYPT_NEWKEYSET
internal UInt32 CRYPT_DELETEKEYSET
internal UInt32 CRYPT_MACHINE_KEYSET
internal UInt32 CRYPT_SILENT
internal UInt32 CRYPT_EXPORTABLE
internal UInt32 CLR_KEYLEN
internal UInt32 CLR_PUBLICKEYONLY
internal UInt32 CLR_EXPORTABLE
internal UInt32 CLR_REMOVABLE
internal UInt32 CLR_HARDWARE
internal UInt32 CLR_ACCESSIBLE
internal UInt32 CLR_PROTECTED
internal UInt32 CLR_UNIQUE_CONTAINER
internal UInt32 CLR_ALGID
internal UInt32 CLR_PP_CLIENT_HWND
internal UInt32 CLR_PP_PIN
internal string OID_RSA_SMIMEalgCMS3DESwrap
internal string OID_RSA_MD5
internal string OID_RSA_RC2CBC
internal string OID_RSA_DES_EDE3_CBC
internal string OID_OIWSEC_desCBC
internal string OID_OIWSEC_SHA1
internal string OID_OIWSEC_SHA256
internal string OID_OIWSEC_SHA384
internal string OID_OIWSEC_SHA512
internal string OID_OIWSEC_RIPEMD160
}
public System.Security.Cryptography.CryptoAPITransform : object {
private bool m_disposed
public bool CanReuseTransform
public bool CanTransformMultipleBlocks
public int InputBlockSize
public IntPtr KeyHandle
public int OutputBlockSize
public bool get_CanReuseTransform()
public bool get_CanTransformMultipleBlocks()
public int get_InputBlockSize()
public IntPtr get_KeyHandle()
public int get_OutputBlockSize()
public void Dispose()
public void Clear()
private void Dispose(bool disposing)
public int TransformBlock(Byte[] inputBuffer, int inputOffset, int inputCount, Byte[] outputBuffer, int outputOffset)
public Byte[] TransformFinalBlock(Byte[] inputBuffer, int inputOffset, int inputCount)
public void Reset()
}
public System.Security.Cryptography.CryptoConfig : object {
private object lockObject
private Dictionary`2<string, Type> algorithms
private Dictionary`2<string, string> unresolved_algorithms
private Dictionary`2<string, string> oids
private string defaultNamespace
private Type defaultSHA1
private Type defaultMD5
private Type defaultSHA256
private Type defaultSHA384
private Type defaultSHA512
private Type defaultRSA
private Type defaultDSA
private Type defaultDES
private Type default3DES
private Type defaultRC2
private Type defaultAES
private Type defaultRNG
private Type defaultHMAC
private Type defaultMAC3DES
private Type defaultDSASigDesc
private Type defaultRSAPKCS1SHA1SigDesc
private Type defaultRSAPKCS1SHA256SigDesc
private Type defaultRSAPKCS1SHA384SigDesc
private Type defaultRSAPKCS1SHA512SigDesc
private Type defaultRIPEMD160
private Type defaultHMACMD5
private Type defaultHMACRIPEMD160
private Type defaultHMACSHA256
private Type defaultHMACSHA384
private Type defaultHMACSHA512
private string defaultC14N
private string defaultC14NWithComments
private string defaultBase64
private string defaultXPath
private string defaultXslt
private string defaultEnveloped
private string defaultXmlDecryption
private string defaultExcC14N
private string defaultExcC14NWithComments
private string defaultX509Data
private string defaultKeyName
private string defaultKeyValueDSA
private string defaultKeyValueRSA
private string defaultRetrievalMethod
private string managedSHA1
private string oidSHA1
private string oidMD5
private string oidSHA256
private string oidSHA384
private string oidSHA512
private string oidRIPEMD160
private string oidDES
private string oid3DES
private string oidRC2
private string oid3DESKeyWrap
private string nameSHA1
private string nameSHA1a
private string nameSHA1b
private string nameSHA1c
private string nameSHA1d
private string nameMD5
private string nameMD5a
private string nameMD5b
private string nameSHA256
private string nameSHA256a
private string nameSHA256b
private string nameSHA256c
private string nameSHA384
private string nameSHA384a
private string nameSHA384b
private string nameSHA384c
private string nameSHA512
private string nameSHA512a
private string nameSHA512b
private string nameSHA512c
private string nameRSAa
private string nameRSAb
private string nameRSAc
private string nameDSAa
private string nameDSAb
private string nameDESa
private string nameDESb
private string name3DESa
private string name3DESb
private string name3DESc
private string name3DESd
private string nameRC2a
private string nameRC2b
private string nameAESa
private string nameAESb
private string nameAESc
private string nameRNGa
private string nameRNGb
private string nameKeyHasha
private string nameHMACSHA1a
private string nameHMACSHA1b
private string nameMAC3DESa
private string nameMAC3DESb
private string name3DESKeyWrap
private string nameRIPEMD160
private string nameRIPEMD160a
private string nameRIPEMD160b
private string nameRIPEMD160c
private string nameHMACb
private string nameHMACMD5a
private string nameHMACMD5b
private string nameHMACRIPEMD160a
private string nameHMACRIPEMD160b
private string nameHMACSHA256a
private string nameHMACSHA256b
private string nameHMACSHA384a
private string nameHMACSHA384b
private string nameHMACSHA512a
private string nameHMACSHA512b
private string urlXmlDsig
private string urlDSASHA1
private string urlRSASHA1
private string urlRSASHA256
private string urlRSASHA384
private string urlRSASHA512
private string urlSHA1
private string urlC14N
private string urlC14NWithComments
private string urlBase64
private string urlXPath
private string urlXslt
private string urlEnveloped
private string urlXmlDecryption
private string urlExcC14NWithComments
private string urlExcC14N
private string urlSHA256
private string urlSHA384
private string urlSHA512
private string urlHMACSHA256
private string urlHMACSHA384
private string urlHMACSHA512
private string urlHMACRIPEMD160
private string urlX509Data
private string urlKeyName
private string urlKeyValueDSA
private string urlKeyValueRSA
private string urlRetrievalMethod
private string oidX509SubjectKeyIdentifier
private string oidX509KeyUsage
private string oidX509BasicConstraints
private string oidX509EnhancedKeyUsage
private string nameX509SubjectKeyIdentifier
private string nameX509KeyUsage
private string nameX509BasicConstraints
private string nameX509EnhancedKeyUsage
private string nameX509Chain
private string defaultX509Chain
private string system_core_assembly
private string nameAES_1
private string nameAES_2
private string defaultAES_1
private string nameAESManaged_1
private string nameAESManaged_2
private string defaultAESManaged
private string nameECDiffieHellman_1
private string nameECDiffieHellman_2
private string nameECDiffieHellman_3
private string nameECDiffieHellman_4
private string defaultECDiffieHellman
private string nameECDsa_1
private string nameECDsa_2
private string nameECDsa_3
private string defaultECDsa
private string nameSHA1Cng
private string defaultSHA1Cng
private string nameSHA256Cng
private string defaultSHA256Cng
private string nameSHA256Provider
private string defaultSHA256Provider
private string nameSHA384Cng
private string defaultSHA384Cng
private string nameSHA384Provider
private string defaultSHA384Provider
private string nameSHA512Cng
private string defaultSHA512Cng
private string nameSHA512Provider
private string defaultSHA512Provider
public bool AllowOnlyFipsAlgorithms
public Byte[] EncodeOID(string str)
private Byte[] EncodeLongNumber(long x)
public bool get_AllowOnlyFipsAlgorithms()
private void Initialize()
private void LoadConfig(string filename, IDictionary`2<string, Type> algorithms, IDictionary`2<string, string> oid)
public object CreateFromName(string name)
public object CreateFromName(string name, Object[] args)
internal string MapNameToOID(string name, OidGroup oidGroup)
public string MapNameToOID(string name)
public void AddAlgorithm(Type algorithm, String[] names)
public void AddOID(string oid, String[] names)
}
public System.Security.Cryptography.CryptographicException : SystemException {
private int FORMAT_MESSAGE_IGNORE_INSERTS
private int FORMAT_MESSAGE_FROM_SYSTEM
private int FORMAT_MESSAGE_ARGUMENT_ARRAY
public void .ctor(string message)
public void .ctor(string format, string insert)
public void .ctor(string message, Exception inner)
public void .ctor(int hr)
protected void .ctor(SerializationInfo info, StreamingContext context)
private void ThrowCryptographicException(int hr)
}
public System.Security.Cryptography.CryptographicUnexpectedOperationException : CryptographicException {
public void .ctor(string message)
public void .ctor(string format, string insert)
public void .ctor(string message, Exception inner)
protected void .ctor(SerializationInfo info, StreamingContext context)
}
public System.Security.Cryptography.CryptoStream : Stream {
private Stream _stream
private ICryptoTransform _Transform
private Byte[] _InputBuffer
private int _InputBufferIndex
private int _InputBlockSize
private Byte[] _OutputBuffer
private int _OutputBufferIndex
private int _OutputBlockSize
private CryptoStreamMode _transformMode
private bool _canRead
private bool _canWrite
private bool _finalBlockTransformed
public bool CanRead
public bool CanSeek
public bool CanWrite
public long Length
public long Position
public bool HasFlushedFinalBlock
public void .ctor(Stream stream, ICryptoTransform transform, CryptoStreamMode mode)
public bool get_CanRead()
public bool get_CanSeek()
public bool get_CanWrite()
public long get_Length()
public long get_Position()
public void set_Position(long value)
public bool get_HasFlushedFinalBlock()
public void FlushFinalBlock()
public void Flush()
public Task FlushAsync(CancellationToken cancellationToken)
public long Seek(long offset, SeekOrigin origin)
public void SetLength(long value)
public int Read(Byte[] buffer, int offset, int count)
public Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken)
private Task`1<int> ReadAsyncInternal(Byte[] buffer, int offset, int count, CancellationToken cancellationToken)
public void Write(Byte[] buffer, int offset, int count)
public Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken)
private Task WriteAsyncInternal(Byte[] buffer, int offset, int count, CancellationToken cancellationToken)
public void Clear()
protected void Dispose(bool disposing)
private void InitializeBuffer()
}
public System.Security.Cryptography.CryptoStreamMode : Enum {
public int value__
public CryptoStreamMode Read
public CryptoStreamMode Write
}
internal System.Security.Cryptography.CspAlgorithmType : Enum {
public int value__
public CspAlgorithmType Rsa
public CspAlgorithmType Dss
}
public System.Security.Cryptography.CspKeyContainerInfo : object {
private CspParameters _params
internal bool _random
public bool Accessible
public CryptoKeySecurity CryptoKeySecurity
public bool Exportable
public bool HardwareDevice
public string KeyContainerName
public KeyNumber KeyNumber
public bool MachineKeyStore
public bool Protected
public string ProviderName
public int ProviderType
public bool RandomlyGenerated
public bool Removable
public string UniqueKeyContainerName
public void .ctor(CspParameters parameters)
public bool get_Accessible()
public CryptoKeySecurity get_CryptoKeySecurity()
public bool get_Exportable()
public bool get_HardwareDevice()
public string get_KeyContainerName()
public KeyNumber get_KeyNumber()
public bool get_MachineKeyStore()
public bool get_Protected()
public string get_ProviderName()
public int get_ProviderType()
public bool get_RandomlyGenerated()
public bool get_Removable()
public string get_UniqueKeyContainerName()
}
public System.Security.Cryptography.CspParameters : object {
public int ProviderType
public string ProviderName
public string KeyContainerName
public int KeyNumber
private int m_flags
private CryptoKeySecurity m_cryptoKeySecurity
private SecureString m_keyPassword
private IntPtr m_parentWindowHandle
public CspProviderFlags Flags
public CryptoKeySecurity CryptoKeySecurity
public SecureString KeyPassword
public IntPtr ParentWindowHandle
public CspProviderFlags get_Flags()
public void set_Flags(CspProviderFlags value)
public CryptoKeySecurity get_CryptoKeySecurity()
public void set_CryptoKeySecurity(CryptoKeySecurity value)
public SecureString get_KeyPassword()
public void set_KeyPassword(SecureString value)
public IntPtr get_ParentWindowHandle()
public void set_ParentWindowHandle(IntPtr value)
public void .ctor(int dwTypeIn)
public void .ctor(int dwTypeIn, string strProviderNameIn)
public void .ctor(int dwTypeIn, string strProviderNameIn, string strContainerNameIn)
public void .ctor(int providerType, string providerName, string keyContainerName, CryptoKeySecurity cryptoKeySecurity, SecureString keyPassword)
public void .ctor(int providerType, string providerName, string keyContainerName, CryptoKeySecurity cryptoKeySecurity, IntPtr parentWindowHandle)
internal void .ctor(int providerType, string providerName, string keyContainerName, CspProviderFlags flags)
internal void .ctor(CspParameters parameters)
}
public System.Security.Cryptography.CspProviderFlags : Enum {
public int value__
public CspProviderFlags NoFlags
public CspProviderFlags UseMachineKeyStore
public CspProviderFlags UseDefaultKeyContainer
public CspProviderFlags UseNonExportableKey
public CspProviderFlags UseExistingKey
public CspProviderFlags UseArchivableKey
public CspProviderFlags UseUserProtectedKey
public CspProviderFlags NoPrompt
public CspProviderFlags CreateEphemeralKey
}
public System.Security.Cryptography.DeriveBytes : object {
public Byte[] GetBytes(int cb)
public void Reset()
public void Dispose()
protected void Dispose(bool disposing)
}
public System.Security.Cryptography.DES : SymmetricAlgorithm {
private KeySizes[] s_legalBlockSizes
private KeySizes[] s_legalKeySizes
public Byte[] Key
public Byte[] get_Key()
public void set_Key(Byte[] value)
public DES Create()
public DES Create(string algName)
public bool IsWeakKey(Byte[] rgbKey)
public bool IsSemiWeakKey(Byte[] rgbKey)
private bool IsLegalKeySize(Byte[] rgbKey)
private ulong QuadWordFromBigEndian(Byte[] block)
}
public System.Security.Cryptography.DESCryptoServiceProvider : DES {
public ICryptoTransform CreateEncryptor(Byte[] rgbKey, Byte[] rgbIV)
public ICryptoTransform CreateDecryptor(Byte[] rgbKey, Byte[] rgbIV)
public void GenerateKey()
public void GenerateIV()
}
internal System.Security.Cryptography.DESTransform : SymmetricTransform {
internal int KEY_BIT_SIZE
internal int KEY_BYTE_SIZE
internal int BLOCK_BIT_SIZE
internal int BLOCK_BYTE_SIZE
private Byte[] keySchedule
private Byte[] byteBuff
private UInt32[] dwordBuff
private UInt32[] spBoxes
private Byte[] PC1
private Byte[] leftRotTotal
private Byte[] PC2
internal UInt32[] ipTab
internal UInt32[] fpTab
internal void .ctor(SymmetricAlgorithm symmAlgo, bool encryption, Byte[] key, Byte[] iv)
private UInt32 CipherFunct(UInt32 r, int n)
internal void Permutation(Byte[] input, Byte[] output, UInt32[] permTab, bool preSwap)
private void BSwap(Byte[] byteBuff)
internal void SetKey(Byte[] key)
public void ProcessBlock(Byte[] input, Byte[] output)
protected void ECB(Byte[] input, Byte[] output)
internal Byte[] GetStrongKey()
}
public System.Security.Cryptography.DSA : AsymmetricAlgorithm {
public DSA Create()
public DSA Create(string algName)
public Byte[] CreateSignature(Byte[] rgbHash)
public bool VerifySignature(Byte[] rgbHash, Byte[] rgbSignature)
protected Byte[] HashData(Byte[] data, int offset, int count, HashAlgorithmName hashAlgorithm)
protected Byte[] HashData(Stream data, HashAlgorithmName hashAlgorithm)
public Byte[] SignData(Byte[] data, HashAlgorithmName hashAlgorithm)
public Byte[] SignData(Byte[] data, int offset, int count, HashAlgorithmName hashAlgorithm)
public Byte[] SignData(Stream data, HashAlgorithmName hashAlgorithm)
public bool VerifyData(Byte[] data, Byte[] signature, HashAlgorithmName hashAlgorithm)
public bool VerifyData(Byte[] data, int offset, int count, Byte[] signature, HashAlgorithmName hashAlgorithm)
public bool VerifyData(Stream data, Byte[] signature, HashAlgorithmName hashAlgorithm)
public void FromXmlString(string xmlString)
public string ToXmlString(bool includePrivateParameters)
public DSAParameters ExportParameters(bool includePrivateParameters)
public void ImportParameters(DSAParameters parameters)
private Exception DerivedClassMustOverride()
internal Exception HashAlgorithmNameNullOrEmpty()
}
public System.Security.Cryptography.DSACryptoServiceProvider : DSA {
private int PROV_DSS_DH
private KeyPairPersistence store
private bool persistKey
private bool persisted
private bool privateKeyExportable
private bool m_disposed
private DSAManaged dsa
private bool useMachineKeyStore
public string KeyExchangeAlgorithm
public int KeySize
public bool PersistKeyInCsp
public bool PublicOnly
public string SignatureAlgorithm
public bool UseMachineKeyStore
public CspKeyContainerInfo CspKeyContainerInfo
public void .ctor(CspParameters parameters)
public void .ctor(int dwKeySize)
public void .ctor(int dwKeySize, CspParameters parameters)
private void Common(int dwKeySize, bool parameters)
private void Common(CspParameters parameters)
protected void Finalize()
public string get_KeyExchangeAlgorithm()
public int get_KeySize()
public bool get_PersistKeyInCsp()
public void set_PersistKeyInCsp(bool value)
public bool get_PublicOnly()
public string get_SignatureAlgorithm()
public bool get_UseMachineKeyStore()
public void set_UseMachineKeyStore(bool value)
public DSAParameters ExportParameters(bool includePrivateParameters)
public void ImportParameters(DSAParameters parameters)
public Byte[] CreateSignature(Byte[] rgbHash)
public Byte[] SignData(Byte[] buffer)
public Byte[] SignData(Byte[] buffer, int offset, int count)
public Byte[] SignData(Stream inputStream)
public Byte[] SignHash(Byte[] rgbHash, string str)
public bool VerifyData(Byte[] rgbData, Byte[] rgbSignature)
public bool VerifyHash(Byte[] rgbHash, string str, Byte[] rgbSignature)
public bool VerifySignature(Byte[] rgbHash, Byte[] rgbSignature)
protected Byte[] HashData(Byte[] data, int offset, int count, HashAlgorithmName hashAlgorithm)
protected Byte[] HashData(Stream data, HashAlgorithmName hashAlgorithm)
protected void Dispose(bool disposing)
private void OnKeyGenerated(object sender, EventArgs e)
public CspKeyContainerInfo get_CspKeyContainerInfo()
public Byte[] ExportCspBlob(bool includePrivateParameters)
public void ImportCspBlob(Byte[] keyBlob)
}
public System.Security.Cryptography.DSAParameters : ValueType {
public Byte[] P
public Byte[] Q
public Byte[] G
public Byte[] Y
public Byte[] J
public Byte[] X
public Byte[] Seed
public int Counter
}
public System.Security.Cryptography.DSASignatureDeformatter : AsymmetricSignatureDeformatter {
private DSA _dsaKey
private string _oid
public void .ctor(AsymmetricAlgorithm key)
public void SetKey(AsymmetricAlgorithm key)
public void SetHashAlgorithm(string strName)
public bool VerifySignature(Byte[] rgbHash, Byte[] rgbSignature)
}
public System.Security.Cryptography.DSASignatureFormatter : AsymmetricSignatureFormatter {
private DSA _dsaKey
private string _oid
public void .ctor(AsymmetricAlgorithm key)
public void SetKey(AsymmetricAlgorithm key)
public void SetHashAlgorithm(string strName)
public Byte[] CreateSignature(Byte[] rgbHash)
}
public System.Security.Cryptography.FromBase64Transform : object {
private Byte[] _inputBuffer
private int _inputIndex
private FromBase64TransformMode _whitespaces
public int InputBlockSize
public int OutputBlockSize
public bool CanTransformMultipleBlocks
public bool CanReuseTransform
public void .ctor(FromBase64TransformMode whitespaces)
public int get_InputBlockSize()
public int get_OutputBlockSize()
public bool get_CanTransformMultipleBlocks()
public bool get_CanReuseTransform()
public int TransformBlock(Byte[] inputBuffer, int inputOffset, int inputCount, Byte[] outputBuffer, int outputOffset)
public Byte[] TransformFinalBlock(Byte[] inputBuffer, int inputOffset, int inputCount)
private Byte[] DiscardWhiteSpaces(Byte[] inputBuffer, int inputOffset, int inputCount)
public void Dispose()
private void Reset()
public void Clear()
protected void Dispose(bool disposing)
protected void Finalize()
}
public System.Security.Cryptography.FromBase64TransformMode : Enum {
public int value__
public FromBase64TransformMode IgnoreWhiteSpaces
public FromBase64TransformMode DoNotIgnoreWhiteSpaces
}
public System.Security.Cryptography.HashAlgorithm : object {
protected int HashSizeValue
protected internal Byte[] HashValue
protected int State
private bool m_bDisposed
public int HashSize
public Byte[] Hash
public int InputBlockSize
public int OutputBlockSize
public bool CanTransformMultipleBlocks
public bool CanReuseTransform
public int get_HashSize()
public Byte[] get_Hash()
public HashAlgorithm Create()
public HashAlgorithm Create(string hashName)
public Byte[] ComputeHash(Stream inputStream)
public Byte[] ComputeHash(Byte[] buffer)
public Byte[] ComputeHash(Byte[] buffer, int offset, int count)
public int get_InputBlockSize()
public int get_OutputBlockSize()
public bool get_CanTransformMultipleBlocks()
public bool get_CanReuseTransform()
public int TransformBlock(Byte[] inputBuffer, int inputOffset, int inputCount, Byte[] outputBuffer, int outputOffset)
public Byte[] TransformFinalBlock(Byte[] inputBuffer, int inputOffset, int inputCount)
public void Dispose()
public void Clear()
protected void Dispose(bool disposing)
public void Initialize()
protected void HashCore(Byte[] array, int ibStart, int cbSize)
protected Byte[] HashFinal()
}
public System.Security.Cryptography.HashAlgorithmName : ValueType {
private string _name
public HashAlgorithmName MD5
public HashAlgorithmName SHA1
public HashAlgorithmName SHA256
public HashAlgorithmName SHA384
public HashAlgorithmName SHA512
public string Name
public HashAlgorithmName get_MD5()
public HashAlgorithmName get_SHA1()
public HashAlgorithmName get_SHA256()
public HashAlgorithmName get_SHA384()
public HashAlgorithmName get_SHA512()
public void .ctor(string name)
public string get_Name()
public string ToString()
public bool Equals(object obj)
public bool Equals(HashAlgorithmName other)
public int GetHashCode()
public bool op_Equality(HashAlgorithmName left, HashAlgorithmName right)
public bool op_Inequality(HashAlgorithmName left, HashAlgorithmName right)
}
public System.Security.Cryptography.HMAC : KeyedHashAlgorithm {
private int blockSizeValue
internal string m_hashName
internal HashAlgorithm m_hash1
internal HashAlgorithm m_hash2
private Byte[] m_inner
private Byte[] m_outer
private bool m_hashing
protected int BlockSizeValue
public Byte[] Key
public string HashName
protected int get_BlockSizeValue()
protected void set_BlockSizeValue(int value)
private void UpdateIOPadBuffers()
internal void InitializeKey(Byte[] key)
public Byte[] get_Key()
public void set_Key(Byte[] value)
public string get_HashName()
public void set_HashName(string value)
public HMAC Create()
public HMAC Create(string algorithmName)
public void Initialize()
protected void HashCore(Byte[] rgb, int ib, int cb)
protected Byte[] HashFinal()
protected void Dispose(bool disposing)
internal HashAlgorithm GetHashAlgorithmWithFipsFallback(Func`1<HashAlgorithm> createStandardHashAlgorithmCallback, Func`1<HashAlgorithm> createFipsHashAlgorithmCallback)
}
public System.Security.Cryptography.HMACMD5 : HMAC {
public void .ctor(Byte[] key)
}
public System.Security.Cryptography.HMACRIPEMD160 : HMAC {
public void .ctor(Byte[] key)
}
public System.Security.Cryptography.HMACSHA1 : HMAC {
public void .ctor(Byte[] key)
public void .ctor(Byte[] key, bool useManagedSha1)
}
public System.Security.Cryptography.HMACSHA256 : HMAC {
public void .ctor(Byte[] key)
}
public System.Security.Cryptography.HMACSHA384 : HMAC {
private bool m_useLegacyBlockSize
private int BlockSize
public bool ProduceLegacyHmacValues
public void .ctor(Byte[] key)
private int get_BlockSize()
public bool get_ProduceLegacyHmacValues()
public void set_ProduceLegacyHmacValues(bool value)
}
public System.Security.Cryptography.HMACSHA512 : HMAC {
private bool m_useLegacyBlockSize
private int BlockSize
public bool ProduceLegacyHmacValues
public void .ctor(Byte[] key)
private int get_BlockSize()
public bool get_ProduceLegacyHmacValues()
public void set_ProduceLegacyHmacValues(bool value)
}
public System.Security.Cryptography.ICryptoTransform {
public int InputBlockSize
public int OutputBlockSize
public bool CanTransformMultipleBlocks
public bool CanReuseTransform
public int get_InputBlockSize()
public int get_OutputBlockSize()
public bool get_CanTransformMultipleBlocks()
public bool get_CanReuseTransform()
public int TransformBlock(Byte[] inputBuffer, int inputOffset, int inputCount, Byte[] outputBuffer, int outputOffset)
public Byte[] TransformFinalBlock(Byte[] inputBuffer, int inputOffset, int inputCount)
}
public System.Security.Cryptography.ICspAsymmetricAlgorithm {
public CspKeyContainerInfo CspKeyContainerInfo
public Byte[] ExportCspBlob(bool includePrivateParameters)
public void ImportCspBlob(Byte[] rawData)
public CspKeyContainerInfo get_CspKeyContainerInfo()
}
public System.Security.Cryptography.KeyedHashAlgorithm : HashAlgorithm {
protected Byte[] KeyValue
public Byte[] Key
protected void Dispose(bool disposing)
public Byte[] get_Key()
public void set_Key(Byte[] value)
public KeyedHashAlgorithm Create()
public KeyedHashAlgorithm Create(string algName)
}
public System.Security.Cryptography.KeyNumber : Enum {
public int value__
public KeyNumber Exchange
public KeyNumber Signature
}
public System.Security.Cryptography.KeySizes : object {
private int m_minSize
private int m_maxSize
private int m_skipSize
public int MinSize
public int MaxSize
public int SkipSize
public int get_MinSize()
public int get_MaxSize()
public int get_SkipSize()
public void .ctor(int minSize, int maxSize, int skipSize)
internal bool IsLegal(int keySize)
internal bool IsLegalKeySize(KeySizes[] legalKeys, int size)
}
public System.Security.Cryptography.MACTripleDES : KeyedHashAlgorithm {
private ICryptoTransform m_encryptor
private CryptoStream _cs
private TailStream _ts
private int m_bitsPerByte
private int m_bytesPerBlock
private TripleDES des
public PaddingMode Padding
public void .ctor(Byte[] rgbKey)
public void .ctor(string strTripleDES, Byte[] rgbKey)
public void Initialize()
public PaddingMode get_Padding()
public void set_Padding(PaddingMode value)
protected void HashCore(Byte[] rgbData, int ibStart, int cbSize)
protected Byte[] HashFinal()
protected void Dispose(bool disposing)
}
public System.Security.Cryptography.MaskGenerationMethod : object {
public Byte[] GenerateMask(Byte[] rgbSeed, int cbReturn)
}
public System.Security.Cryptography.MD5 : HashAlgorithm {
public MD5 Create()
public MD5 Create(string algName)
}
public System.Security.Cryptography.MD5CryptoServiceProvider : MD5 {
private int BLOCK_SIZE_BYTES
private UInt32[] _H
private UInt32[] buff
private ulong count
private Byte[] _ProcessingBuffer
private int _ProcessingBufferCount
private UInt32[] K
protected void Finalize()
protected void Dispose(bool disposing)
protected void HashCore(Byte[] rgb, int ibStart, int cbSize)
protected Byte[] HashFinal()
public void Initialize()
private void ProcessBlock(Byte[] inputBuffer, int inputOffset)
private void ProcessFinalBlock(Byte[] inputBuffer, int inputOffset, int inputCount)
internal void AddLength(ulong length, Byte[] buffer, int position)
}
public System.Security.Cryptography.PaddingMode : Enum {
public int value__
public PaddingMode None
public PaddingMode PKCS7
public PaddingMode Zeros
public PaddingMode ANSIX923
public PaddingMode ISO10126
}
public System.Security.Cryptography.PasswordDeriveBytes : DeriveBytes {
private int _extraCount
private int _prefix
private int _iterations
private Byte[] _baseValue
private Byte[] _extra
private Byte[] _salt
private string _hashName
private Byte[] _password
private HashAlgorithm _hash
public string HashName
public int IterationCount
public Byte[] Salt
public void .ctor(string strPassword, Byte[] rgbSalt)
public void .ctor(Byte[] password, Byte[] salt)
public void .ctor(string strPassword, Byte[] rgbSalt, string strHashName, int iterations)
public void .ctor(Byte[] password, Byte[] salt, string hashName, int iterations)
public void .ctor(string strPassword, Byte[] rgbSalt, CspParameters cspParams)
public void .ctor(Byte[] password, Byte[] salt, CspParameters cspParams)
public void .ctor(string strPassword, Byte[] rgbSalt, string strHashName, int iterations, CspParameters cspParams)
public void .ctor(Byte[] password, Byte[] salt, string hashName, int iterations, CspParameters cspParams)
public string get_HashName()
public void set_HashName(string value)
public int get_IterationCount()
public void set_IterationCount(int value)
public Byte[] get_Salt()
public void set_Salt(Byte[] value)
public Byte[] GetBytes(int cb)
public void Reset()
protected void Dispose(bool disposing)
public Byte[] CryptDeriveKey(string algname, string alghashname, int keySize, Byte[] rgbIV)
private Byte[] ComputeBaseValue()
private Byte[] ComputeBytes(int cb)
private void HashPrefix(CryptoStream cs)
}
public System.Security.Cryptography.PKCS1MaskGenerationMethod : MaskGenerationMethod {
private string HashNameValue
public string HashName
public string get_HashName()
public void set_HashName(string value)
public Byte[] GenerateMask(Byte[] rgbSeed, int cbReturn)
}
public System.Security.Cryptography.RandomNumberGenerator : object {
public RandomNumberGenerator Create()
public RandomNumberGenerator Create(string rngName)
public void Dispose()
protected void Dispose(bool disposing)
public void GetBytes(Byte[] data)
public void GetBytes(Byte[] data, int offset, int count)
public void GetNonZeroBytes(Byte[] data)
}
public System.Security.Cryptography.RC2 : SymmetricAlgorithm {
protected int EffectiveKeySizeValue
private KeySizes[] s_legalBlockSizes
private KeySizes[] s_legalKeySizes
public int EffectiveKeySize
public int KeySize
public int get_EffectiveKeySize()
public void set_EffectiveKeySize(int value)
public int get_KeySize()
public void set_KeySize(int value)
public RC2 Create()
public RC2 Create(string AlgName)
}
public System.Security.Cryptography.RC2CryptoServiceProvider : RC2 {
private bool m_use40bitSalt
private KeySizes[] s_legalKeySizes
public int EffectiveKeySize
public bool UseSalt
public int get_EffectiveKeySize()
public void set_EffectiveKeySize(int value)
public bool get_UseSalt()
public void set_UseSalt(bool value)
public ICryptoTransform CreateEncryptor(Byte[] rgbKey, Byte[] rgbIV)
public ICryptoTransform CreateDecryptor(Byte[] rgbKey, Byte[] rgbIV)
public void GenerateKey()
public void GenerateIV()
}
internal System.Security.Cryptography.RC2Transform : SymmetricTransform {
private ushort R0
private ushort R1
private ushort R2
private ushort R3
private UInt16[] K
private int j
private Byte[] pitable
public void .ctor(RC2 rc2Algo, bool encryption, Byte[] key, Byte[] iv)
protected void ECB(Byte[] input, Byte[] output)
}
public System.Security.Cryptography.Rfc2898DeriveBytes : DeriveBytes {
private Byte[] m_buffer
private Byte[] m_salt
private HMACSHA1 m_hmacsha1
private Byte[] m_password
private UInt32 m_iterations
private UInt32 m_block
private int m_startIndex
private int m_endIndex
private int BlockSize
public int IterationCount
public Byte[] Salt
public void .ctor(string password, int saltSize)
public void .ctor(string password, int saltSize, int iterations)
public void .ctor(string password, Byte[] salt)
public void .ctor(string password, Byte[] salt, int iterations)
public void .ctor(Byte[] password, Byte[] salt, int iterations)
public int get_IterationCount()
public void set_IterationCount(int value)
public Byte[] get_Salt()
public void set_Salt(Byte[] value)
public Byte[] GetBytes(int cb)
public void Reset()
protected void Dispose(bool disposing)
private void Initialize()
private Byte[] Func()
public Byte[] CryptDeriveKey(string algname, string alghashname, int keySize, Byte[] rgbIV)
}
public System.Security.Cryptography.Rijndael : SymmetricAlgorithm {
private KeySizes[] s_legalBlockSizes
private KeySizes[] s_legalKeySizes
public Rijndael Create()
public Rijndael Create(string algName)
}
public System.Security.Cryptography.RijndaelManaged : Rijndael {
public ICryptoTransform CreateEncryptor(Byte[] rgbKey, Byte[] rgbIV)
public ICryptoTransform CreateDecryptor(Byte[] rgbKey, Byte[] rgbIV)
public void GenerateKey()
public void GenerateIV()
private ICryptoTransform NewEncryptor(Byte[] rgbKey, CipherMode mode, Byte[] rgbIV, int feedbackSize, RijndaelManagedTransformMode encryptMode)
}
public System.Security.Cryptography.RijndaelManagedTransform : object {
private CipherMode m_cipherMode
private PaddingMode m_paddingValue
private RijndaelManagedTransformMode m_transformMode
private int m_blockSizeBits
private int m_blockSizeBytes
private int m_inputBlockSize
private int m_outputBlockSize
private Int32[] m_encryptKeyExpansion
private Int32[] m_decryptKeyExpansion
private int m_Nr
private int m_Nb
private int m_Nk
private Int32[] m_encryptindex
private Int32[] m_decryptindex
private Int32[] m_IV
private Int32[] m_lastBlockBuffer
private Byte[] m_depadBuffer
private Byte[] m_shiftRegister
private Byte[] s_Sbox
private Int32[] s_Rcon
private Int32[] s_T
private Int32[] s_TF
private Int32[] s_iT
private Int32[] s_iTF
public int BlockSizeValue
public int InputBlockSize
public int OutputBlockSize
public bool CanTransformMultipleBlocks
public bool CanReuseTransform
internal void .ctor(Byte[] rgbKey, CipherMode mode, Byte[] rgbIV, int blockSize, int feedbackSize, PaddingMode PaddingValue, RijndaelManagedTransformMode transformMode)
public void Dispose()
public void Clear()
private void Dispose(bool disposing)
public int get_BlockSizeValue()
public int get_InputBlockSize()
public int get_OutputBlockSize()
public bool get_CanTransformMultipleBlocks()
public bool get_CanReuseTransform()
public int TransformBlock(Byte[] inputBuffer, int inputOffset, int inputCount, Byte[] outputBuffer, int outputOffset)
public Byte[] TransformFinalBlock(Byte[] inputBuffer, int inputOffset, int inputCount)
public void Reset()
private int EncryptData(Byte[] inputBuffer, int inputOffset, int inputCount, Byte[]& outputBuffer, int outputOffset, PaddingMode paddingMode, bool fLast)
private int DecryptData(Byte[] inputBuffer, int inputOffset, int inputCount, Byte[]& outputBuffer, int outputOffset, PaddingMode paddingMode, bool fLast)
private void Enc(Int32* encryptindex, Int32* encryptKeyExpansion, Int32* T, Int32* TF, Int32* work, Int32* temp)
private void Dec(Int32* decryptindex, Int32* decryptKeyExpansion, Int32* iT, Int32* iTF, Int32* work, Int32* temp)
private void GenerateKeyExpansion(Byte[] rgbKey)
private int rot1(int val)
private int rot2(int val)
private int rot3(int val)
private int SubWord(int a)
private int MulX(int x)
}
internal System.Security.Cryptography.RijndaelManagedTransformMode : Enum {
public int value__
public RijndaelManagedTransformMode Encrypt
public RijndaelManagedTransformMode Decrypt
}
public System.Security.Cryptography.RIPEMD160 : HashAlgorithm {
public RIPEMD160 Create()
public RIPEMD160 Create(string hashName)
}
public System.Security.Cryptography.RIPEMD160Managed : RIPEMD160 {
private Byte[] _buffer
private long _count
private UInt32[] _stateMD160
private UInt32[] _blockDWords
public void Initialize()
protected void HashCore(Byte[] rgb, int ibStart, int cbSize)
protected Byte[] HashFinal()
private void InitializeState()
private void _HashData(Byte[] partIn, int ibStart, int cbSize)
private Byte[] _EndHash()
private void MDTransform(UInt32* blockDWords, UInt32* state, Byte* block)
private UInt32 F(UInt32 x, UInt32 y, UInt32 z)
private UInt32 G(UInt32 x, UInt32 y, UInt32 z)
private UInt32 H(UInt32 x, UInt32 y, UInt32 z)
private UInt32 I(UInt32 x, UInt32 y, UInt32 z)
private UInt32 J(UInt32 x, UInt32 y, UInt32 z)
}
public System.Security.Cryptography.RNGCryptoServiceProvider : RandomNumberGenerator {
private object _lock
private IntPtr _handle
public void .ctor(Byte[] rgb)
public void .ctor(CspParameters cspParams)
public void .ctor(string str)
private void Check()
private bool RngOpen()
private IntPtr RngInitialize(Byte[] seed)
private IntPtr RngGetBytes(IntPtr handle, Byte[] data)
private void RngClose(IntPtr handle)
public void GetBytes(Byte[] data)
public void GetNonZeroBytes(Byte[] data)
protected void Finalize()
protected void Dispose(bool disposing)
}
public System.Security.Cryptography.RSA : AsymmetricAlgorithm {
public string KeyExchangeAlgorithm
public string SignatureAlgorithm
public RSA Create()
public RSA Create(string algName)
public Byte[] Encrypt(Byte[] data, RSAEncryptionPadding padding)
public Byte[] Decrypt(Byte[] data, RSAEncryptionPadding padding)
public Byte[] SignHash(Byte[] hash, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding)
public bool VerifyHash(Byte[] hash, Byte[] signature, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding)
protected Byte[] HashData(Byte[] data, int offset, int count, HashAlgorithmName hashAlgorithm)
protected Byte[] HashData(Stream data, HashAlgorithmName hashAlgorithm)
public Byte[] SignData(Byte[] data, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding)
public Byte[] SignData(Byte[] data, int offset, int count, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding)
public Byte[] SignData(Stream data, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding)
public bool VerifyData(Byte[] data, Byte[] signature, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding)
public bool VerifyData(Byte[] data, int offset, int count, Byte[] signature, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding)
public bool VerifyData(Stream data, Byte[] signature, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding)
private Exception DerivedClassMustOverride()
internal Exception HashAlgorithmNameNullOrEmpty()
public Byte[] DecryptValue(Byte[] rgb)
public Byte[] EncryptValue(Byte[] rgb)
public string get_KeyExchangeAlgorithm()
public string get_SignatureAlgorithm()
public void FromXmlString(string xmlString)
public string ToXmlString(bool includePrivateParameters)
public RSAParameters ExportParameters(bool includePrivateParameters)
public void ImportParameters(RSAParameters parameters)
}
public System.Security.Cryptography.RSACryptoServiceProvider : RSA {
private CspProviderFlags modreq(System.Runtime.CompilerServices.IsVolatile) s_UseMachineKeyStore
private int PROV_RSA_FULL
private int AT_KEYEXCHANGE
private int AT_SIGNATURE
private KeyPairPersistence store
private bool persistKey
private bool persisted
private bool privateKeyExportable
private bool m_disposed
private RSAManaged rsa
public string SignatureAlgorithm
public bool UseMachineKeyStore
public string KeyExchangeAlgorithm
public int KeySize
public bool PersistKeyInCsp
public bool PublicOnly
public CspKeyContainerInfo CspKeyContainerInfo
public string get_SignatureAlgorithm()
public bool get_UseMachineKeyStore()
public void set_UseMachineKeyStore(bool value)
protected Byte[] HashData(Byte[] data, int offset, int count, HashAlgorithmName hashAlgorithm)
protected Byte[] HashData(Stream data, HashAlgorithmName hashAlgorithm)
private int GetAlgorithmId(HashAlgorithmName hashAlgorithm)
public Byte[] Encrypt(Byte[] data, RSAEncryptionPadding padding)
public Byte[] Decrypt(Byte[] data, RSAEncryptionPadding padding)
public Byte[] SignHash(Byte[] hash, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding)
public bool VerifyHash(Byte[] hash, Byte[] signature, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding)
private Exception PaddingModeNotSupported()
public void .ctor(CspParameters parameters)
public void .ctor(int dwKeySize)
public void .ctor(int dwKeySize, CspParameters parameters)
private void Common(int dwKeySize, bool parameters)
private void Common(CspParameters p)
protected void Finalize()
public string get_KeyExchangeAlgorithm()
public int get_KeySize()
public bool get_PersistKeyInCsp()
public void set_PersistKeyInCsp(bool value)
public bool get_PublicOnly()
public Byte[] Decrypt(Byte[] rgb, bool fOAEP)
public Byte[] DecryptValue(Byte[] rgb)
public Byte[] Encrypt(Byte[] rgb, bool fOAEP)
public Byte[] EncryptValue(Byte[] rgb)
public RSAParameters ExportParameters(bool includePrivateParameters)
public void ImportParameters(RSAParameters parameters)
private HashAlgorithm GetHash(object halg)
private HashAlgorithm GetHashFromString(string name)
public Byte[] SignData(Byte[] buffer, object halg)
public Byte[] SignData(Stream inputStream, object halg)
public Byte[] SignData(Byte[] buffer, int offset, int count, object halg)
private string GetHashNameFromOID(string oid)
public Byte[] SignHash(Byte[] rgbHash, string str)
private Byte[] SignHash(Byte[] rgbHash, int calgHash)
private HashAlgorithm InternalHashToHashAlgorithm(int calgHash)
public bool VerifyData(Byte[] buffer, object halg, Byte[] signature)
public bool VerifyHash(Byte[] rgbHash, string str, Byte[] rgbSignature)
private bool VerifyHash(Byte[] rgbHash, int calgHash, Byte[] rgbSignature)
protected void Dispose(bool disposing)
private void OnKeyGenerated(object sender, EventArgs e)
public CspKeyContainerInfo get_CspKeyContainerInfo()
public Byte[] ExportCspBlob(bool includePrivateParameters)
public void ImportCspBlob(Byte[] keyBlob)
}
public System.Security.Cryptography.RSAEncryptionPadding : object {
private RSAEncryptionPadding s_pkcs1
private RSAEncryptionPadding s_oaepSHA1
private RSAEncryptionPadding s_oaepSHA256
private RSAEncryptionPadding s_oaepSHA384
private RSAEncryptionPadding s_oaepSHA512
private RSAEncryptionPaddingMode _mode
private HashAlgorithmName _oaepHashAlgorithm
public RSAEncryptionPadding Pkcs1
public RSAEncryptionPadding OaepSHA1
public RSAEncryptionPadding OaepSHA256
public RSAEncryptionPadding OaepSHA384
public RSAEncryptionPadding OaepSHA512
public RSAEncryptionPaddingMode Mode
public HashAlgorithmName OaepHashAlgorithm
public RSAEncryptionPadding get_Pkcs1()
public RSAEncryptionPadding get_OaepSHA1()
public RSAEncryptionPadding get_OaepSHA256()
public RSAEncryptionPadding get_OaepSHA384()
public RSAEncryptionPadding get_OaepSHA512()
private void .ctor(RSAEncryptionPaddingMode mode, HashAlgorithmName oaepHashAlgorithm)
public RSAEncryptionPadding CreateOaep(HashAlgorithmName hashAlgorithm)
public RSAEncryptionPaddingMode get_Mode()
public HashAlgorithmName get_OaepHashAlgorithm()
public int GetHashCode()
private int CombineHashCodes(int h1, int h2)
public bool Equals(object obj)
public bool Equals(RSAEncryptionPadding other)
public bool op_Equality(RSAEncryptionPadding left, RSAEncryptionPadding right)
public bool op_Inequality(RSAEncryptionPadding left, RSAEncryptionPadding right)
public string ToString()
}
public System.Security.Cryptography.RSAEncryptionPaddingMode : Enum {
public int value__
public RSAEncryptionPaddingMode Pkcs1
public RSAEncryptionPaddingMode Oaep
}
public System.Security.Cryptography.RSAOAEPKeyExchangeDeformatter : AsymmetricKeyExchangeDeformatter {
private RSA _rsaKey
private Nullable`1<bool> _rsaOverridesDecrypt
public string Parameters
private bool OverridesDecrypt
public void .ctor(AsymmetricAlgorithm key)
public string get_Parameters()
public void set_Parameters(string value)
public Byte[] DecryptKeyExchange(Byte[] rgbData)
public void SetKey(AsymmetricAlgorithm key)
private bool get_OverridesDecrypt()
}
public System.Security.Cryptography.RSAOAEPKeyExchangeFormatter : AsymmetricKeyExchangeFormatter {
private Byte[] ParameterValue
private RSA _rsaKey
private Nullable`1<bool> _rsaOverridesEncrypt
private RandomNumberGenerator RngValue
public Byte[] Parameter
public string Parameters
public RandomNumberGenerator Rng
private bool OverridesEncrypt
public void .ctor(AsymmetricAlgorithm key)
public Byte[] get_Parameter()
public void set_Parameter(Byte[] value)
public string get_Parameters()
public RandomNumberGenerator get_Rng()
public void set_Rng(RandomNumberGenerator value)
public void SetKey(AsymmetricAlgorithm key)
public Byte[] CreateKeyExchange(Byte[] rgbData)
public Byte[] CreateKeyExchange(Byte[] rgbData, Type symAlgType)
private bool get_OverridesEncrypt()
}
public System.Security.Cryptography.RSAParameters : ValueType {
public Byte[] Exponent
public Byte[] Modulus
public Byte[] P
public Byte[] Q
public Byte[] DP
public Byte[] DQ
public Byte[] InverseQ
public Byte[] D
}
public System.Security.Cryptography.RSAPKCS1KeyExchangeDeformatter : AsymmetricKeyExchangeDeformatter {
private RSA _rsaKey
private Nullable`1<bool> _rsaOverridesDecrypt
private RandomNumberGenerator RngValue
public RandomNumberGenerator RNG
public string Parameters
private bool OverridesDecrypt
public void .ctor(AsymmetricAlgorithm key)
public RandomNumberGenerator get_RNG()
public void set_RNG(RandomNumberGenerator value)
public string get_Parameters()
public void set_Parameters(string value)
public Byte[] DecryptKeyExchange(Byte[] rgbIn)
public void SetKey(AsymmetricAlgorithm key)
private bool get_OverridesDecrypt()
}
public System.Security.Cryptography.RSAPKCS1KeyExchangeFormatter : AsymmetricKeyExchangeFormatter {
private RandomNumberGenerator RngValue
private RSA _rsaKey
private Nullable`1<bool> _rsaOverridesEncrypt
public string Parameters
public RandomNumberGenerator Rng
private bool OverridesEncrypt
public void .ctor(AsymmetricAlgorithm key)
public string get_Parameters()
public RandomNumberGenerator get_Rng()
public void set_Rng(RandomNumberGenerator value)
public void SetKey(AsymmetricAlgorithm key)
public Byte[] CreateKeyExchange(Byte[] rgbData)
public Byte[] CreateKeyExchange(Byte[] rgbData, Type symAlgType)
private bool get_OverridesEncrypt()
}
public System.Security.Cryptography.RSAPKCS1SignatureDeformatter : AsymmetricSignatureDeformatter {
private RSA rsa
private string hashName
public void .ctor(AsymmetricAlgorithm key)
public void SetHashAlgorithm(string strName)
public void SetKey(AsymmetricAlgorithm key)
public bool VerifySignature(Byte[] rgbHash, Byte[] rgbSignature)
}
internal System.Security.Cryptography.RSAPKCS1SignatureDescription : SignatureDescription {
private string _hashAlgorithm
protected void .ctor(string hashAlgorithm, string digestAlgorithm)
public AsymmetricSignatureDeformatter CreateDeformatter(AsymmetricAlgorithm key)
public AsymmetricSignatureFormatter CreateFormatter(AsymmetricAlgorithm key)
}
public System.Security.Cryptography.RSAPKCS1SignatureFormatter : AsymmetricSignatureFormatter {
private RSA rsa
private string hash
public void .ctor(AsymmetricAlgorithm key)
public Byte[] CreateSignature(Byte[] rgbHash)
public void SetHashAlgorithm(string strName)
public void SetKey(AsymmetricAlgorithm key)
}
public System.Security.Cryptography.RSASignaturePadding : object {
private RSASignaturePadding s_pkcs1
private RSASignaturePadding s_pss
private RSASignaturePaddingMode _mode
public RSASignaturePadding Pkcs1
public RSASignaturePadding Pss
public RSASignaturePaddingMode Mode
private void .ctor(RSASignaturePaddingMode mode)
public RSASignaturePadding get_Pkcs1()
public RSASignaturePadding get_Pss()
public RSASignaturePaddingMode get_Mode()
public int GetHashCode()
public bool Equals(object obj)
public bool Equals(RSASignaturePadding other)
public bool op_Equality(RSASignaturePadding left, RSASignaturePadding right)
public bool op_Inequality(RSASignaturePadding left, RSASignaturePadding right)
public string ToString()
}
public System.Security.Cryptography.RSASignaturePaddingMode : Enum {
public int value__
public RSASignaturePaddingMode Pkcs1
public RSASignaturePaddingMode Pss
}
public System.Security.Cryptography.SHA1 : HashAlgorithm {
public SHA1 Create()
public SHA1 Create(string hashName)
}
public System.Security.Cryptography.SHA1CryptoServiceProvider : SHA1 {
private SHA1Internal sha
protected void Finalize()
protected void Dispose(bool disposing)
protected void HashCore(Byte[] rgb, int ibStart, int cbSize)
protected Byte[] HashFinal()
public void Initialize()
}
internal System.Security.Cryptography.SHA1Internal : object {
private int BLOCK_SIZE_BYTES
private UInt32[] _H
private ulong count
private Byte[] _ProcessingBuffer
private int _ProcessingBufferCount
private UInt32[] buff
public void HashCore(Byte[] rgb, int ibStart, int cbSize)
public Byte[] HashFinal()
public void Initialize()
private void ProcessBlock(Byte[] inputBuffer, UInt32 inputOffset)
private void InitialiseBuff(UInt32[] buff, Byte[] input, UInt32 inputOffset)
private void FillBuff(UInt32[] buff)
private void ProcessFinalBlock(Byte[] inputBuffer, int inputOffset, int inputCount)
internal void AddLength(ulong length, Byte[] buffer, int position)
}
public System.Security.Cryptography.SHA1Managed : SHA1 {
private Byte[] _buffer
private long _count
private UInt32[] _stateSHA1
private UInt32[] _expandedBuffer
public void Initialize()
protected void HashCore(Byte[] rgb, int ibStart, int cbSize)
protected Byte[] HashFinal()
private void InitializeState()
private void _HashData(Byte[] partIn, int ibStart, int cbSize)
private Byte[] _EndHash()
private void SHATransform(UInt32* expandedBuffer, UInt32* state, Byte* block)
private void SHAExpand(UInt32* x)
}
public System.Security.Cryptography.SHA256 : HashAlgorithm {
public SHA256 Create()
public SHA256 Create(string hashName)
}
public System.Security.Cryptography.SHA256Managed : SHA256 {
private Byte[] _buffer
private long _count
private UInt32[] _stateSHA256
private UInt32[] _W
private UInt32[] _K
public void Initialize()
protected void HashCore(Byte[] rgb, int ibStart, int cbSize)
protected Byte[] HashFinal()
private void InitializeState()
private void _HashData(Byte[] partIn, int ibStart, int cbSize)
private Byte[] _EndHash()
private void SHATransform(UInt32* expandedBuffer, UInt32* state, Byte* block)
private UInt32 RotateRight(UInt32 x, int n)
private UInt32 Ch(UInt32 x, UInt32 y, UInt32 z)
private UInt32 Maj(UInt32 x, UInt32 y, UInt32 z)
private UInt32 sigma_0(UInt32 x)
private UInt32 sigma_1(UInt32 x)
private UInt32 Sigma_0(UInt32 x)
private UInt32 Sigma_1(UInt32 x)
private void SHA256Expand(UInt32* x)
}
public System.Security.Cryptography.SHA384 : HashAlgorithm {
public SHA384 Create()
public SHA384 Create(string hashName)
}
public System.Security.Cryptography.SHA384Managed : SHA384 {
private Byte[] _buffer
private ulong _count
private UInt64[] _stateSHA384
private UInt64[] _W
private UInt64[] _K
public void Initialize()
protected void HashCore(Byte[] rgb, int ibStart, int cbSize)
protected Byte[] HashFinal()
private void InitializeState()
private void _HashData(Byte[] partIn, int ibStart, int cbSize)
private Byte[] _EndHash()
private void SHATransform(UInt64* expandedBuffer, UInt64* state, Byte* block)
private ulong RotateRight(ulong x, int n)
private ulong Ch(ulong x, ulong y, ulong z)
private ulong Maj(ulong x, ulong y, ulong z)
private ulong Sigma_0(ulong x)
private ulong Sigma_1(ulong x)
private ulong sigma_0(ulong x)
private ulong sigma_1(ulong x)
private void SHA384Expand(UInt64* x)
}
public System.Security.Cryptography.SHA512 : HashAlgorithm {
public SHA512 Create()
public SHA512 Create(string hashName)
}
public System.Security.Cryptography.SHA512Managed : SHA512 {
private Byte[] _buffer
private ulong _count
private UInt64[] _stateSHA512
private UInt64[] _W
private UInt64[] _K
public void Initialize()
protected void HashCore(Byte[] rgb, int ibStart, int cbSize)
protected Byte[] HashFinal()
private void InitializeState()
private void _HashData(Byte[] partIn, int ibStart, int cbSize)
private Byte[] _EndHash()
private void SHATransform(UInt64* expandedBuffer, UInt64* state, Byte* block)
private ulong RotateRight(ulong x, int n)
private ulong Ch(ulong x, ulong y, ulong z)
private ulong Maj(ulong x, ulong y, ulong z)
private ulong Sigma_0(ulong x)
private ulong Sigma_1(ulong x)
private ulong sigma_0(ulong x)
private ulong sigma_1(ulong x)
private void SHA512Expand(UInt64* x)
}
public System.Security.Cryptography.SignatureDescription : object {
private string _strKey
private string _strDigest
private string _strFormatter
private string _strDeformatter
public string KeyAlgorithm
public string DigestAlgorithm
public string FormatterAlgorithm
public string DeformatterAlgorithm
public void .ctor(SecurityElement el)
public string get_KeyAlgorithm()
public void set_KeyAlgorithm(string value)
public string get_DigestAlgorithm()
public void set_DigestAlgorithm(string value)
public string get_FormatterAlgorithm()
public void set_FormatterAlgorithm(string value)
public string get_DeformatterAlgorithm()
public void set_DeformatterAlgorithm(string value)
public AsymmetricSignatureDeformatter CreateDeformatter(AsymmetricAlgorithm key)
public AsymmetricSignatureFormatter CreateFormatter(AsymmetricAlgorithm key)
public HashAlgorithm CreateDigest()
}
public System.Security.Cryptography.SymmetricAlgorithm : object {
protected int BlockSizeValue
protected int FeedbackSizeValue
protected Byte[] IVValue
protected Byte[] KeyValue
protected KeySizes[] LegalBlockSizesValue
protected KeySizes[] LegalKeySizesValue
protected int KeySizeValue
protected CipherMode ModeValue
protected PaddingMode PaddingValue
public int BlockSize
public int FeedbackSize
public Byte[] IV
public Byte[] Key
public KeySizes[] LegalBlockSizes
public KeySizes[] LegalKeySizes
public int KeySize
public CipherMode Mode
public PaddingMode Padding
public void Dispose()
public void Clear()
protected void Dispose(bool disposing)
public int get_BlockSize()
public void set_BlockSize(int value)
public int get_FeedbackSize()
public void set_FeedbackSize(int value)
public Byte[] get_IV()
public void set_IV(Byte[] value)
public Byte[] get_Key()
public void set_Key(Byte[] value)
public KeySizes[] get_LegalBlockSizes()
public KeySizes[] get_LegalKeySizes()
public int get_KeySize()
public void set_KeySize(int value)
public CipherMode get_Mode()
public void set_Mode(CipherMode value)
public PaddingMode get_Padding()
public void set_Padding(PaddingMode value)
public bool ValidKeySize(int bitLength)
public SymmetricAlgorithm Create()
public SymmetricAlgorithm Create(string algName)
public ICryptoTransform CreateEncryptor()
public ICryptoTransform CreateEncryptor(Byte[] rgbKey, Byte[] rgbIV)
public ICryptoTransform CreateDecryptor()
public ICryptoTransform CreateDecryptor(Byte[] rgbKey, Byte[] rgbIV)
public void GenerateKey()
public void GenerateIV()
}
internal System.Security.Cryptography.TailStream : Stream {
private Byte[] _Buffer
private int _BufferSize
private int _BufferIndex
private bool _BufferFull
public Byte[] Buffer
public bool CanRead
public bool CanSeek
public bool CanWrite
public long Length
public long Position
public void .ctor(int bufferSize)
public void Clear()
protected void Dispose(bool disposing)
public Byte[] get_Buffer()
public bool get_CanRead()
public bool get_CanSeek()
public bool get_CanWrite()
public long get_Length()
public long get_Position()
public void set_Position(long value)
public void Flush()
public long Seek(long offset, SeekOrigin origin)
public void SetLength(long value)
public int Read(Byte[] buffer, int offset, int count)
public void Write(Byte[] buffer, int offset, int count)
}
public System.Security.Cryptography.ToBase64Transform : object {
public int InputBlockSize
public int OutputBlockSize
public bool CanTransformMultipleBlocks
public bool CanReuseTransform
public int get_InputBlockSize()
public int get_OutputBlockSize()
public bool get_CanTransformMultipleBlocks()
public bool get_CanReuseTransform()
public int TransformBlock(Byte[] inputBuffer, int inputOffset, int inputCount, Byte[] outputBuffer, int outputOffset)
public Byte[] TransformFinalBlock(Byte[] inputBuffer, int inputOffset, int inputCount)
public void Dispose()
public void Clear()
protected void Dispose(bool disposing)
protected void Finalize()
}
public System.Security.Cryptography.TripleDES : SymmetricAlgorithm {
private KeySizes[] s_legalBlockSizes
private KeySizes[] s_legalKeySizes
public Byte[] Key
public Byte[] get_Key()
public void set_Key(Byte[] value)
public TripleDES Create()
public TripleDES Create(string str)
public bool IsWeakKey(Byte[] rgbKey)
private bool EqualBytes(Byte[] rgbKey, int start1, int start2, int count)
private bool IsLegalKeySize(Byte[] rgbKey)
}
public System.Security.Cryptography.TripleDESCryptoServiceProvider : TripleDES {
public ICryptoTransform CreateEncryptor(Byte[] rgbKey, Byte[] rgbIV)
public ICryptoTransform CreateDecryptor(Byte[] rgbKey, Byte[] rgbIV)
public void GenerateKey()
public void GenerateIV()
}
internal System.Security.Cryptography.TripleDESTransform : SymmetricTransform {
private DESTransform E1
private DESTransform D2
private DESTransform E3
private DESTransform D1
private DESTransform E2
private DESTransform D3
public void .ctor(TripleDES algo, bool encryption, Byte[] key, Byte[] iv)
protected void ECB(Byte[] input, Byte[] output)
internal Byte[] GetStrongKey()
}
internal System.Security.Cryptography.Utils : object {
internal int DefaultRsaProviderType
private RNGCryptoServiceProvider modreq(System.Runtime.CompilerServices.IsVolatile) _rng
internal RNGCryptoServiceProvider StaticRandomNumberGenerator
internal RNGCryptoServiceProvider get_StaticRandomNumberGenerator()
internal Byte[] GenerateRandom(int keySize)
internal bool HasAlgorithm(int dwCalg, int dwKeySize)
internal string DiscardWhiteSpaces(string inputBuffer)
internal string DiscardWhiteSpaces(string inputBuffer, int inputOffset, int inputCount)
internal int ConvertByteArrayToInt(Byte[] input)
internal Byte[] ConvertIntToByteArray(int dwInput)
internal void ConvertIntToByteArray(UInt32 dwInput, Byte[]& counter)
internal Byte[] FixupKeyParity(Byte[] key)
internal void DWORDFromLittleEndian(UInt32* x, int digits, Byte* block)
internal void DWORDToLittleEndian(Byte[] block, UInt32[] x, int digits)
internal void DWORDFromBigEndian(UInt32* x, int digits, Byte* block)
internal void DWORDToBigEndian(Byte[] block, UInt32[] x, int digits)
internal void QuadWordFromBigEndian(UInt64* x, int digits, Byte* block)
internal void QuadWordToBigEndian(Byte[] block, UInt64[] x, int digits)
internal Byte[] Int(UInt32 i)
internal Byte[] RsaOaepEncrypt(RSA rsa, HashAlgorithm hash, PKCS1MaskGenerationMethod mgf, RandomNumberGenerator rng, Byte[] data)
internal Byte[] RsaOaepDecrypt(RSA rsa, HashAlgorithm hash, PKCS1MaskGenerationMethod mgf, Byte[] encryptedData)
internal Byte[] RsaPkcs1Padding(RSA rsa, Byte[] oid, Byte[] hash)
internal bool CompareBigIntArrays(Byte[] lhs, Byte[] rhs)
internal HashAlgorithmName OidToHashAlgorithmName(string oid)
internal bool DoesRsaKeyOverride(RSA rsaKey, string methodName, Type[] parameterTypes)
private bool DoesRsaKeyOverrideSlowPath(Type t, string methodName, Type[] parameterTypes)
internal bool _ProduceLegacyHmacValues()
}
internal System.Security.Cryptography.X509Certificates.INativeCertificateHelper {
public X509CertificateImpl Import(Byte[] data, string password, X509KeyStorageFlags flags)
public X509CertificateImpl Import(X509Certificate cert)
}
internal System.Security.Cryptography.X509Certificates.OidGroup : Enum {
public int value__
public OidGroup AllGroups
public OidGroup HashAlgorithm
public OidGroup EncryptionAlgorithm
public OidGroup PublicKeyAlgorithm
public OidGroup SignatureAlgorithm
public OidGroup Attribute
public OidGroup ExtensionOrAttribute
public OidGroup EnhancedKeyUsage
public OidGroup Policy
public OidGroup Template
public OidGroup KeyDerivationFunction
public OidGroup DisableSearchDS
}
internal System.Security.Cryptography.X509Certificates.OidKeyType : Enum {
public int value__
public OidKeyType Oid
public OidKeyType Name
public OidKeyType AlgorithmID
public OidKeyType SignatureID
public OidKeyType CngAlgorithmID
public OidKeyType CngSignatureID
}
public System.Security.Cryptography.X509Certificates.X509Certificate : object {
private X509CertificateImpl impl
private bool hideDates
private string issuer_name
private string subject_name
internal X509CertificateImpl Impl
internal bool IsValid
public string Issuer
public string Subject
public IntPtr Handle
public X509Certificate CreateFromCertFile(string filename)
public X509Certificate CreateFromSignedFile(string filename)
internal void .ctor(Byte[] data, bool dates)
public void .ctor(Byte[] data)
public void .ctor(IntPtr handle)
internal void .ctor(X509CertificateImpl impl)
public void .ctor(X509Certificate cert)
internal void ImportHandle(X509CertificateImpl impl)
internal X509CertificateImpl get_Impl()
internal bool get_IsValid()
internal void ThrowIfContextInvalid()
public bool Equals(X509Certificate other)
public Byte[] GetCertHash()
public string GetCertHashString()
public string GetEffectiveDateString()
public string GetExpirationDateString()
public string GetFormat()
public int GetHashCode()
public string GetIssuerName()
public string GetKeyAlgorithm()
public Byte[] GetKeyAlgorithmParameters()
public string GetKeyAlgorithmParametersString()
public string GetName()
public Byte[] GetPublicKey()
public string GetPublicKeyString()
public Byte[] GetRawCertData()
public string GetRawCertDataString()
public Byte[] GetSerialNumber()
public string GetSerialNumberString()
public string ToString()
public string ToString(bool fVerbose)
protected string FormatDate(DateTime date)
public void .ctor(Byte[] rawData, string password)
public void .ctor(Byte[] rawData, SecureString password)
public void .ctor(Byte[] rawData, string password, X509KeyStorageFlags keyStorageFlags)
public void .ctor(Byte[] rawData, SecureString password, X509KeyStorageFlags keyStorageFlags)
public void .ctor(string fileName)
public void .ctor(string fileName, string password)
public void .ctor(string fileName, SecureString password)
public void .ctor(string fileName, string password, X509KeyStorageFlags keyStorageFlags)
public void .ctor(string fileName, SecureString password, X509KeyStorageFlags keyStorageFlags)
public void .ctor(SerializationInfo info, StreamingContext context)
public string get_Issuer()
public string get_Subject()
public IntPtr get_Handle()
public bool Equals(object obj)
public Byte[] Export(X509ContentType contentType)
public Byte[] Export(X509ContentType contentType, string password)
public Byte[] Export(X509ContentType contentType, SecureString password)
internal Byte[] Export(X509ContentType contentType, Byte[] password)
public void Import(Byte[] rawData)
public void Import(Byte[] rawData, string password, X509KeyStorageFlags keyStorageFlags)
public void Import(Byte[] rawData, SecureString password, X509KeyStorageFlags keyStorageFlags)
public void Import(string fileName)
public void Import(string fileName, string password, X509KeyStorageFlags keyStorageFlags)
public void Import(string fileName, SecureString password, X509KeyStorageFlags keyStorageFlags)
private void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender)
private void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context)
public void Dispose()
protected void Dispose(bool disposing)
public void Reset()
}
internal System.Security.Cryptography.X509Certificates.X509CertificateImpl : object {
private Byte[] cachedCertificateHash
public bool IsValid
public IntPtr Handle
public bool get_IsValid()
public IntPtr get_Handle()
public IntPtr GetNativeAppleCertificate()
protected void ThrowIfContextInvalid()
public X509CertificateImpl Clone()
public string GetIssuerName(bool legacyV1Mode)
public string GetSubjectName(bool legacyV1Mode)
public Byte[] GetRawCertData()
public DateTime GetValidFrom()
public DateTime GetValidUntil()
public Byte[] GetCertHash()
protected Byte[] GetCertHash(bool lazy)
public int GetHashCode()
public bool Equals(X509CertificateImpl other, Boolean& result)
public string GetKeyAlgorithm()
public Byte[] GetKeyAlgorithmParameters()
public Byte[] GetPublicKey()
public Byte[] GetSerialNumber()
public Byte[] Export(X509ContentType contentType, Byte[] password)
public string ToString(bool full)
public bool Equals(object obj)
public void Dispose()
protected void Dispose(bool disposing)
protected void Finalize()
}
internal System.Security.Cryptography.X509Certificates.X509CertificateImplApple : X509CertificateImpl {
private IntPtr handle
private X509CertificateImpl fallback
public bool IsValid
public IntPtr Handle
public X509CertificateImpl FallbackImpl
public void .ctor(IntPtr handle, bool owns)
public bool get_IsValid()
public IntPtr get_Handle()
public IntPtr GetNativeAppleCertificate()
public X509CertificateImpl Clone()
private IntPtr SecCertificateCopySubjectSummary(IntPtr cert)
private IntPtr SecCertificateCopyData(IntPtr cert)
public Byte[] GetRawCertData()
public string GetSubjectSummary()
protected Byte[] GetCertHash(bool lazy)
public bool Equals(X509CertificateImpl other, Boolean& result)
private void MustFallback()
public X509CertificateImpl get_FallbackImpl()
public string GetSubjectName(bool legacyV1Mode)
public string GetIssuerName(bool legacyV1Mode)
public DateTime GetValidFrom()
public DateTime GetValidUntil()
public string GetKeyAlgorithm()
public Byte[] GetKeyAlgorithmParameters()
public Byte[] GetPublicKey()
public Byte[] GetSerialNumber()
public Byte[] Export(X509ContentType contentType, Byte[] password)
public string ToString(bool full)
protected void Dispose(bool disposing)
}
internal System.Security.Cryptography.X509Certificates.X509CertificateImplMono : X509CertificateImpl {
private X509Certificate x509
public bool IsValid
public IntPtr Handle
public void .ctor(X509Certificate x509)
public bool get_IsValid()
public IntPtr get_Handle()
public IntPtr GetNativeAppleCertificate()
public X509CertificateImpl Clone()
public string GetIssuerName(bool legacyV1Mode)
public string GetSubjectName(bool legacyV1Mode)
public Byte[] GetRawCertData()
protected Byte[] GetCertHash(bool lazy)
public DateTime GetValidFrom()
public DateTime GetValidUntil()
public bool Equals(X509CertificateImpl other, Boolean& result)
public string GetKeyAlgorithm()
public Byte[] GetKeyAlgorithmParameters()
public Byte[] GetPublicKey()
public Byte[] GetSerialNumber()
public Byte[] Export(X509ContentType contentType, Byte[] password)
public string ToString(bool full)
protected void Dispose(bool disposing)
}
internal System.Security.Cryptography.X509Certificates.X509Constants : object {
internal UInt32 CRYPT_EXPORTABLE
internal UInt32 CRYPT_USER_PROTECTED
internal UInt32 CRYPT_MACHINE_KEYSET
internal UInt32 CRYPT_USER_KEYSET
internal UInt32 CERT_QUERY_CONTENT_CERT
internal UInt32 CERT_QUERY_CONTENT_CTL
internal UInt32 CERT_QUERY_CONTENT_CRL
internal UInt32 CERT_QUERY_CONTENT_SERIALIZED_STORE
internal UInt32 CERT_QUERY_CONTENT_SERIALIZED_CERT
internal UInt32 CERT_QUERY_CONTENT_SERIALIZED_CTL
internal UInt32 CERT_QUERY_CONTENT_SERIALIZED_CRL
internal UInt32 CERT_QUERY_CONTENT_PKCS7_SIGNED
internal UInt32 CERT_QUERY_CONTENT_PKCS7_UNSIGNED
internal UInt32 CERT_QUERY_CONTENT_PKCS7_SIGNED_EMBED
internal UInt32 CERT_QUERY_CONTENT_PKCS10
internal UInt32 CERT_QUERY_CONTENT_PFX
internal UInt32 CERT_QUERY_CONTENT_CERT_PAIR
internal UInt32 CERT_STORE_PROV_MEMORY
internal UInt32 CERT_STORE_PROV_SYSTEM
internal UInt32 CERT_STORE_NO_CRYPT_RELEASE_FLAG
internal UInt32 CERT_STORE_SET_LOCALIZED_NAME_FLAG
internal UInt32 CERT_STORE_DEFER_CLOSE_UNTIL_LAST_FREE_FLAG
internal UInt32 CERT_STORE_DELETE_FLAG
internal UInt32 CERT_STORE_SHARE_STORE_FLAG
internal UInt32 CERT_STORE_SHARE_CONTEXT_FLAG
internal UInt32 CERT_STORE_MANIFOLD_FLAG
internal UInt32 CERT_STORE_ENUM_ARCHIVED_FLAG
internal UInt32 CERT_STORE_UPDATE_KEYID_FLAG
internal UInt32 CERT_STORE_BACKUP_RESTORE_FLAG
internal UInt32 CERT_STORE_READONLY_FLAG
internal UInt32 CERT_STORE_OPEN_EXISTING_FLAG
internal UInt32 CERT_STORE_CREATE_NEW_FLAG
internal UInt32 CERT_STORE_MAXIMUM_ALLOWED_FLAG
internal UInt32 CERT_NAME_EMAIL_TYPE
internal UInt32 CERT_NAME_RDN_TYPE
internal UInt32 CERT_NAME_SIMPLE_DISPLAY_TYPE
internal UInt32 CERT_NAME_FRIENDLY_DISPLAY_TYPE
internal UInt32 CERT_NAME_DNS_TYPE
internal UInt32 CERT_NAME_URL_TYPE
internal UInt32 CERT_NAME_UPN_TYPE
}
public System.Security.Cryptography.X509Certificates.X509ContentType : Enum {
public int value__
public X509ContentType Unknown
public X509ContentType Cert
public X509ContentType SerializedCert
public X509ContentType Pfx
public X509ContentType Pkcs12
public X509ContentType SerializedStore
public X509ContentType Pkcs7
public X509ContentType Authenticode
}
internal System.Security.Cryptography.X509Certificates.X509Helper : object {
private INativeCertificateHelper nativeHelper
private bool ShouldUseAppleTls
public X509CertificateImpl InitFromHandleApple(IntPtr handle)
private X509CertificateImpl ImportApple(Byte[] rawData)
internal void InstallNativeHelper(INativeCertificateHelper helper)
private bool get_ShouldUseAppleTls()
public X509CertificateImpl InitFromHandle(IntPtr handle)
private X509CertificateImpl Import(Byte[] rawData)
public X509CertificateImpl InitFromHandleCore(IntPtr handle)
public X509CertificateImpl InitFromCertificate(X509Certificate cert)
public X509CertificateImpl InitFromCertificate(X509CertificateImpl impl)
public bool IsValid(X509CertificateImpl impl)
internal void ThrowIfContextInvalid(X509CertificateImpl impl)
internal Exception GetInvalidContextException()
internal X509Certificate ImportPkcs12(Byte[] rawData, string password)
private Byte[] PEM(string type, Byte[] data)
private Byte[] ConvertData(Byte[] data)
private X509CertificateImpl ImportCore(Byte[] rawData)
public X509CertificateImpl Import(Byte[] rawData, string password, X509KeyStorageFlags keyStorageFlags)
public Byte[] Export(X509CertificateImpl impl, X509ContentType contentType, Byte[] password)
public bool Equals(X509CertificateImpl first, X509CertificateImpl second)
public string ToHexString(Byte[] data)
}
public System.Security.Cryptography.X509Certificates.X509KeyStorageFlags : Enum {
public int value__
public X509KeyStorageFlags DefaultKeySet
public X509KeyStorageFlags UserKeySet
public X509KeyStorageFlags MachineKeySet
public X509KeyStorageFlags Exportable
public X509KeyStorageFlags UserProtected
public X509KeyStorageFlags PersistKeySet
public X509KeyStorageFlags EphemeralKeySet
}
public System.Security.HostProtectionException : SystemException {
private HostProtectionResource _protected
private HostProtectionResource _demanded
public HostProtectionResource DemandedResources
public HostProtectionResource ProtectedResources
public void .ctor(string message)
public void .ctor(string message, Exception e)
public void .ctor(string message, HostProtectionResource protectedResources, HostProtectionResource demandedResources)
protected void .ctor(SerializationInfo info, StreamingContext context)
public HostProtectionResource get_DemandedResources()
public HostProtectionResource get_ProtectedResources()
public void GetObjectData(SerializationInfo info, StreamingContext context)
public string ToString()
}
public System.Security.HostSecurityManager : object {
public PolicyLevel DomainPolicy
public HostSecurityManagerOptions Flags
public PolicyLevel get_DomainPolicy()
public HostSecurityManagerOptions get_Flags()
public ApplicationTrust DetermineApplicationTrust(Evidence applicationEvidence, Evidence activatorEvidence, TrustManagerContext context)
public Evidence ProvideAppDomainEvidence(Evidence inputEvidence)
public Evidence ProvideAssemblyEvidence(Assembly loadedAssembly, Evidence inputEvidence)
public PermissionSet ResolvePolicy(Evidence evidence)
public EvidenceBase GenerateAppDomainEvidence(Type evidenceType)
public EvidenceBase GenerateAssemblyEvidence(Type evidenceType, Assembly assembly)
public Type[] GetHostSuppliedAppDomainEvidenceTypes()
public Type[] GetHostSuppliedAssemblyEvidenceTypes(Assembly assembly)
}
public System.Security.HostSecurityManagerOptions : Enum {
public int value__
public HostSecurityManagerOptions None
public HostSecurityManagerOptions HostAppDomainEvidence
public HostSecurityManagerOptions HostPolicyLevel
public HostSecurityManagerOptions HostAssemblyEvidence
public HostSecurityManagerOptions HostDetermineApplicationTrust
public HostSecurityManagerOptions HostResolvePolicy
public HostSecurityManagerOptions AllFlags
}
public System.Security.IEvidenceFactory {
public Evidence Evidence
public Evidence get_Evidence()
}
public System.Security.IPermission {
public IPermission Copy()
public void Demand()
public IPermission Intersect(IPermission target)
public bool IsSubsetOf(IPermission target)
public IPermission Union(IPermission target)
}
public System.Security.ISecurityEncodable {
public void FromXml(SecurityElement e)
public SecurityElement ToXml()
}
public System.Security.ISecurityPolicyEncodable {
public void FromXml(SecurityElement e, PolicyLevel level)
public SecurityElement ToXml(PolicyLevel level)
}
public System.Security.IStackWalk {
public void Assert()
public void Demand()
public void Deny()
public void PermitOnly()
}
public System.Security.NamedPermissionSet : PermissionSet {
private string name
private string description
public string Description
public string Name
public void .ctor(string name, PermissionSet permSet)
public void .ctor(string name, PermissionState state)
public void .ctor(NamedPermissionSet permSet)
public void .ctor(string name)
public string get_Description()
public void set_Description(string value)
public string get_Name()
public void set_Name(string value)
public PermissionSet Copy()
public NamedPermissionSet Copy(string name)
public void FromXml(SecurityElement et)
public SecurityElement ToXml()
public bool Equals(object obj)
public int GetHashCode()
}
public System.Security.PartialTrustVisibilityLevel : Enum {
public int value__
public PartialTrustVisibilityLevel VisibleToAllHosts
public PartialTrustVisibilityLevel NotVisibleByDefault
}
internal System.Security.PermissionBuilder : object {
private Object[] psNone
public IPermission Create(string fullname, PermissionState state)
public IPermission Create(SecurityElement se)
public IPermission Create(string fullname, SecurityElement se)
public IPermission Create(Type type)
internal IPermission CreatePermission(string fullname, SecurityElement se)
}
internal System.Security.Permissions.BuiltInToken : Enum {
public int value__
public BuiltInToken Environment
public BuiltInToken FileDialog
public BuiltInToken FileIO
public BuiltInToken IsolatedStorageFile
public BuiltInToken Reflection
public BuiltInToken Registry
public BuiltInToken Security
public BuiltInToken UI
public BuiltInToken Principal
public BuiltInToken HostProtection
public BuiltInToken PublisherIdentity
public BuiltInToken SiteIdentity
public BuiltInToken StrongNameIdentity
public BuiltInToken UrlIdentity
public BuiltInToken ZoneIdentity
public BuiltInToken GacIdentity
public BuiltInToken KeyContainer
}
public System.Security.Permissions.CodeAccessSecurityAttribute : SecurityAttribute {
protected void .ctor(SecurityAction action)
}
public System.Security.Permissions.EnvironmentPermission : CodeAccessPermission {
private int version
private PermissionState _state
private ArrayList readList
private ArrayList writeList
public void .ctor(PermissionState state)
public void .ctor(EnvironmentPermissionAccess flag, string pathList)
public void AddPathList(EnvironmentPermissionAccess flag, string pathList)
public IPermission Copy()
public void FromXml(SecurityElement esd)
public string GetPathList(EnvironmentPermissionAccess flag)
public IPermission Intersect(IPermission target)
public bool IsSubsetOf(IPermission target)
public bool IsUnrestricted()
public void SetPathList(EnvironmentPermissionAccess flag, string pathList)
public SecurityElement ToXml()
public IPermission Union(IPermission other)
private int System.Security.Permissions.IBuiltInPermission.GetTokenIndex()
private bool IsEmpty()
private EnvironmentPermission Cast(IPermission target)
internal void ThrowInvalidFlag(EnvironmentPermissionAccess flag, bool context)
private string GetPathList(ArrayList list)
}
public System.Security.Permissions.EnvironmentPermissionAccess : Enum {
public int value__
public EnvironmentPermissionAccess NoAccess
public EnvironmentPermissionAccess Read
public EnvironmentPermissionAccess Write
public EnvironmentPermissionAccess AllAccess
}
public System.Security.Permissions.EnvironmentPermissionAttribute : CodeAccessSecurityAttribute {
private string read
private string write
public string All
public string Read
public string Write
public void .ctor(SecurityAction action)
public string get_All()
public void set_All(string value)
public string get_Read()
public void set_Read(string value)
public string get_Write()
public void set_Write(string value)
public IPermission CreatePermission()
}
public System.Security.Permissions.FileDialogPermission : CodeAccessPermission {
private int version
private FileDialogPermissionAccess _access
public FileDialogPermissionAccess Access
public void .ctor(PermissionState state)
public void .ctor(FileDialogPermissionAccess access)
public FileDialogPermissionAccess get_Access()
public void set_Access(FileDialogPermissionAccess value)
public IPermission Copy()
public void FromXml(SecurityElement esd)
public IPermission Intersect(IPermission target)
public bool IsSubsetOf(IPermission target)
public bool IsUnrestricted()
public SecurityElement ToXml()
public IPermission Union(IPermission target)
private int System.Security.Permissions.IBuiltInPermission.GetTokenIndex()
private FileDialogPermission Cast(IPermission target)
}
public System.Security.Permissions.FileDialogPermissionAccess : Enum {
public int value__
public FileDialogPermissionAccess None
public FileDialogPermissionAccess Open
public FileDialogPermissionAccess Save
public FileDialogPermissionAccess OpenSave
}
public System.Security.Permissions.FileDialogPermissionAttribute : CodeAccessSecurityAttribute {
private bool canOpen
private bool canSave
public bool Open
public bool Save
public void .ctor(SecurityAction action)
public bool get_Open()
public void set_Open(bool value)
public bool get_Save()
public void set_Save(bool value)
public IPermission CreatePermission()
}
public System.Security.Permissions.FileIOPermission : CodeAccessPermission {
private int version
private Char[] BadPathNameCharacters
private Char[] BadFileNameCharacters
private bool m_Unrestricted
private FileIOPermissionAccess m_AllFilesAccess
private FileIOPermissionAccess m_AllLocalFilesAccess
private ArrayList readList
private ArrayList writeList
private ArrayList appendList
private ArrayList pathList
public FileIOPermissionAccess AllFiles
public FileIOPermissionAccess AllLocalFiles
public void .ctor(PermissionState state)
public void .ctor(FileIOPermissionAccess access, string path)
public void .ctor(FileIOPermissionAccess access, String[] pathList)
internal void CreateLists()
public void .ctor(FileIOPermissionAccess access, AccessControlActions control, string path)
public void .ctor(FileIOPermissionAccess access, AccessControlActions control, String[] pathList)
internal void .ctor(FileIOPermissionAccess access, String[] pathList, bool checkForDuplicates, bool needFullPath)
public FileIOPermissionAccess get_AllFiles()
public void set_AllFiles(FileIOPermissionAccess value)
public FileIOPermissionAccess get_AllLocalFiles()
public void set_AllLocalFiles(FileIOPermissionAccess value)
public void AddPathList(FileIOPermissionAccess access, string path)
public void AddPathList(FileIOPermissionAccess access, String[] pathList)
internal void AddPathInternal(FileIOPermissionAccess access, string path)
public IPermission Copy()
public void FromXml(SecurityElement esd)
public String[] GetPathList(FileIOPermissionAccess access)
public IPermission Intersect(IPermission target)
public bool IsSubsetOf(IPermission target)
public bool IsUnrestricted()
public void SetPathList(FileIOPermissionAccess access, string path)
public void SetPathList(FileIOPermissionAccess access, String[] pathList)
public SecurityElement ToXml()
public IPermission Union(IPermission other)
public bool Equals(object obj)
public int GetHashCode()
private int System.Security.Permissions.IBuiltInPermission.GetTokenIndex()
private bool IsEmpty()
private FileIOPermission Cast(IPermission target)
internal void ThrowInvalidFlag(FileIOPermissionAccess access, bool context)
internal void ThrowIfInvalidPath(string path)
internal void ThrowIfInvalidPath(String[] paths)
internal void Clear(FileIOPermissionAccess access)
internal bool KeyIsSubsetOf(IList local, IList target)
internal void UnionKeys(IList list, String[] paths)
internal void IntersectKeys(IList local, IList target, IList result)
}
public System.Security.Permissions.FileIOPermissionAccess : Enum {
public int value__
public FileIOPermissionAccess NoAccess
public FileIOPermissionAccess Read
public FileIOPermissionAccess Write
public FileIOPermissionAccess Append
public FileIOPermissionAccess PathDiscovery
public FileIOPermissionAccess AllAccess
}
public System.Security.Permissions.FileIOPermissionAttribute : CodeAccessSecurityAttribute {
private string append
private string path
private string read
private string write
private FileIOPermissionAccess allFiles
private FileIOPermissionAccess allLocalFiles
private string changeAccessControl
private string viewAccessControl
public string All
public string Append
public string PathDiscovery
public string Read
public string Write
public FileIOPermissionAccess AllFiles
public FileIOPermissionAccess AllLocalFiles
public string ChangeAccessControl
public string ViewAccessControl
public string ViewAndModify
public void .ctor(SecurityAction action)
public string get_All()
public void set_All(string value)
public string get_Append()
public void set_Append(string value)
public string get_PathDiscovery()
public void set_PathDiscovery(string value)
public string get_Read()
public void set_Read(string value)
public string get_Write()
public void set_Write(string value)
public FileIOPermissionAccess get_AllFiles()
public void set_AllFiles(FileIOPermissionAccess value)
public FileIOPermissionAccess get_AllLocalFiles()
public void set_AllLocalFiles(FileIOPermissionAccess value)
public string get_ChangeAccessControl()
public void set_ChangeAccessControl(string value)
public string get_ViewAccessControl()
public void set_ViewAccessControl(string value)
public string get_ViewAndModify()
public void set_ViewAndModify(string value)
public IPermission CreatePermission()
}
public System.Security.Permissions.GacIdentityPermission : CodeAccessPermission {
private int version
public void .ctor(PermissionState state)
public IPermission Copy()
public IPermission Intersect(IPermission target)
public bool IsSubsetOf(IPermission target)
public IPermission Union(IPermission target)
public void FromXml(SecurityElement securityElement)
public SecurityElement ToXml()
private int System.Security.Permissions.IBuiltInPermission.GetTokenIndex()
private GacIdentityPermission Cast(IPermission target)
}
public System.Security.Permissions.GacIdentityPermissionAttribute : CodeAccessSecurityAttribute {
public void .ctor(SecurityAction action)
public IPermission CreatePermission()
}
public System.Security.Permissions.HostProtectionAttribute : CodeAccessSecurityAttribute {
private HostProtectionResource _resources
public bool ExternalProcessMgmt
public bool ExternalThreading
public bool MayLeakOnAbort
public bool SecurityInfrastructure
public bool SelfAffectingProcessMgmt
public bool SelfAffectingThreading
public bool SharedState
public bool Synchronization
public bool UI
public HostProtectionResource Resources
public void .ctor(SecurityAction action)
public bool get_ExternalProcessMgmt()
public void set_ExternalProcessMgmt(bool value)
public bool get_ExternalThreading()
public void set_ExternalThreading(bool value)
public bool get_MayLeakOnAbort()
public void set_MayLeakOnAbort(bool value)
public bool get_SecurityInfrastructure()
public void set_SecurityInfrastructure(bool value)
public bool get_SelfAffectingProcessMgmt()
public void set_SelfAffectingProcessMgmt(bool value)
public bool get_SelfAffectingThreading()
public void set_SelfAffectingThreading(bool value)
public bool get_SharedState()
public void set_SharedState(bool value)
public bool get_Synchronization()
public void set_Synchronization(bool value)
public bool get_UI()
public void set_UI(bool value)
public HostProtectionResource get_Resources()
public void set_Resources(HostProtectionResource value)
public IPermission CreatePermission()
}
internal System.Security.Permissions.HostProtectionPermission : CodeAccessPermission {
private int version
private HostProtectionResource _resources
public HostProtectionResource Resources
public void .ctor(PermissionState state)
public void .ctor(HostProtectionResource resources)
public HostProtectionResource get_Resources()
public void set_Resources(HostProtectionResource value)
public IPermission Copy()
public IPermission Intersect(IPermission target)
public IPermission Union(IPermission target)
public bool IsSubsetOf(IPermission target)
public void FromXml(SecurityElement e)
public SecurityElement ToXml()
public bool IsUnrestricted()
private int System.Security.Permissions.IBuiltInPermission.GetTokenIndex()
private HostProtectionPermission Cast(IPermission target)
}
public System.Security.Permissions.HostProtectionResource : Enum {
public int value__
public HostProtectionResource None
public HostProtectionResource Synchronization
public HostProtectionResource SharedState
public HostProtectionResource ExternalProcessMgmt
public HostProtectionResource SelfAffectingProcessMgmt
public HostProtectionResource ExternalThreading
public HostProtectionResource SelfAffectingThreading
public HostProtectionResource SecurityInfrastructure
public HostProtectionResource UI
public HostProtectionResource MayLeakOnAbort
public HostProtectionResource All
}
internal System.Security.Permissions.IBuiltInPermission {
public int GetTokenIndex()
}
public System.Security.Permissions.IsolatedStorageContainment : Enum {
public int value__
public IsolatedStorageContainment None
public IsolatedStorageContainment DomainIsolationByUser
public IsolatedStorageContainment AssemblyIsolationByUser
public IsolatedStorageContainment DomainIsolationByRoamingUser
public IsolatedStorageContainment AssemblyIsolationByRoamingUser
public IsolatedStorageContainment AdministerIsolatedStorageByUser
public IsolatedStorageContainment UnrestrictedIsolatedStorage
public IsolatedStorageContainment ApplicationIsolationByUser
public IsolatedStorageContainment DomainIsolationByMachine
public IsolatedStorageContainment AssemblyIsolationByMachine
public IsolatedStorageContainment ApplicationIsolationByMachine
public IsolatedStorageContainment ApplicationIsolationByRoamingUser
}
public System.Security.Permissions.IsolatedStorageFilePermission : IsolatedStoragePermission {
public void .ctor(PermissionState state)
public IPermission Copy()
public IPermission Intersect(IPermission target)
public bool IsSubsetOf(IPermission target)
public IPermission Union(IPermission target)
public SecurityElement ToXml()
private int System.Security.Permissions.IBuiltInPermission.GetTokenIndex()
private IsolatedStorageFilePermission Cast(IPermission target)
}
public System.Security.Permissions.IsolatedStorageFilePermissionAttribute : IsolatedStoragePermissionAttribute {
public void .ctor(SecurityAction action)
public IPermission CreatePermission()
}
public System.Security.Permissions.IsolatedStoragePermission : CodeAccessPermission {
private int version
internal long m_userQuota
internal long m_machineQuota
internal long m_expirationDays
internal bool m_permanentData
internal IsolatedStorageContainment m_allowed
public long UserQuota
public IsolatedStorageContainment UsageAllowed
protected void .ctor(PermissionState state)
public long get_UserQuota()
public void set_UserQuota(long value)
public IsolatedStorageContainment get_UsageAllowed()
public void set_UsageAllowed(IsolatedStorageContainment value)
public bool IsUnrestricted()
public SecurityElement ToXml()
public void FromXml(SecurityElement esd)
internal bool IsEmpty()
}
public System.Security.Permissions.IsolatedStoragePermissionAttribute : CodeAccessSecurityAttribute {
private IsolatedStorageContainment usage_allowed
private long user_quota
public IsolatedStorageContainment UsageAllowed
public long UserQuota
protected void .ctor(SecurityAction action)
public IsolatedStorageContainment get_UsageAllowed()
public void set_UsageAllowed(IsolatedStorageContainment value)
public long get_UserQuota()
public void set_UserQuota(long value)
}
public System.Security.Permissions.IUnrestrictedPermission {
public bool IsUnrestricted()
}
public System.Security.Permissions.KeyContainerPermission : CodeAccessPermission {
private KeyContainerPermissionAccessEntryCollection _accessEntries
private KeyContainerPermissionFlags _flags
private int version
public KeyContainerPermissionAccessEntryCollection AccessEntries
public KeyContainerPermissionFlags Flags
public void .ctor(PermissionState state)
public void .ctor(KeyContainerPermissionFlags flags)
public void .ctor(KeyContainerPermissionFlags flags, KeyContainerPermissionAccessEntry[] accessList)
public KeyContainerPermissionAccessEntryCollection get_AccessEntries()
public KeyContainerPermissionFlags get_Flags()
public IPermission Copy()
public void FromXml(SecurityElement securityElement)
public IPermission Intersect(IPermission target)
public bool IsSubsetOf(IPermission target)
public bool IsUnrestricted()
public SecurityElement ToXml()
public IPermission Union(IPermission target)
private int System.Security.Permissions.IBuiltInPermission.GetTokenIndex()
private void SetFlags(KeyContainerPermissionFlags flags)
private KeyContainerPermission Cast(IPermission target)
}
public System.Security.Permissions.KeyContainerPermissionAccessEntry : object {
private KeyContainerPermissionFlags _flags
private string _containerName
private int _spec
private string _store
private string _providerName
private int _type
public KeyContainerPermissionFlags Flags
public string KeyContainerName
public int KeySpec
public string KeyStore
public string ProviderName
public int ProviderType
public void .ctor(CspParameters parameters, KeyContainerPermissionFlags flags)
public void .ctor(string keyContainerName, KeyContainerPermissionFlags flags)
public void .ctor(string keyStore, string providerName, int providerType, string keyContainerName, int keySpec, KeyContainerPermissionFlags flags)
public KeyContainerPermissionFlags get_Flags()
public void set_Flags(KeyContainerPermissionFlags value)
public string get_KeyContainerName()
public void set_KeyContainerName(string value)
public int get_KeySpec()
public void set_KeySpec(int value)
public string get_KeyStore()
public void set_KeyStore(string value)
public string get_ProviderName()
public void set_ProviderName(string value)
public int get_ProviderType()
public void set_ProviderType(int value)
public bool Equals(object o)
public int GetHashCode()
}
public System.Security.Permissions.KeyContainerPermissionAccessEntryCollection : object {
private ArrayList _list
public int Count
public bool IsSynchronized
public KeyContainerPermissionAccessEntry Item
public object SyncRoot
internal void .ctor(KeyContainerPermissionAccessEntry[] entries)
public int get_Count()
public bool get_IsSynchronized()
public KeyContainerPermissionAccessEntry get_Item(int index)
public object get_SyncRoot()
public int Add(KeyContainerPermissionAccessEntry accessEntry)
public void Clear()
public void CopyTo(KeyContainerPermissionAccessEntry[] array, int index)
private void System.Collections.ICollection.CopyTo(Array array, int index)
public KeyContainerPermissionAccessEntryEnumerator GetEnumerator()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
public int IndexOf(KeyContainerPermissionAccessEntry accessEntry)
public void Remove(KeyContainerPermissionAccessEntry accessEntry)
}
public System.Security.Permissions.KeyContainerPermissionAccessEntryEnumerator : object {
private IEnumerator e
public KeyContainerPermissionAccessEntry Current
private object System.Collections.IEnumerator.Current
internal void .ctor(ArrayList list)
public KeyContainerPermissionAccessEntry get_Current()
private object System.Collections.IEnumerator.get_Current()
public bool MoveNext()
public void Reset()
}
public System.Security.Permissions.KeyContainerPermissionAttribute : CodeAccessSecurityAttribute {
private KeyContainerPermissionFlags _flags
private string _containerName
private int _spec
private string _store
private string _providerName
private int _type
public KeyContainerPermissionFlags Flags
public string KeyContainerName
public int KeySpec
public string KeyStore
public string ProviderName
public int ProviderType
public void .ctor(SecurityAction action)
public KeyContainerPermissionFlags get_Flags()
public void set_Flags(KeyContainerPermissionFlags value)
public string get_KeyContainerName()
public void set_KeyContainerName(string value)
public int get_KeySpec()
public void set_KeySpec(int value)
public string get_KeyStore()
public void set_KeyStore(string value)
public string get_ProviderName()
public void set_ProviderName(string value)
public int get_ProviderType()
public void set_ProviderType(int value)
public IPermission CreatePermission()
private bool EmptyEntry()
}
public System.Security.Permissions.KeyContainerPermissionFlags : Enum {
public int value__
public KeyContainerPermissionFlags NoFlags
public KeyContainerPermissionFlags Create
public KeyContainerPermissionFlags Open
public KeyContainerPermissionFlags Delete
public KeyContainerPermissionFlags Import
public KeyContainerPermissionFlags Export
public KeyContainerPermissionFlags Sign
public KeyContainerPermissionFlags Decrypt
public KeyContainerPermissionFlags ViewAcl
public KeyContainerPermissionFlags ChangeAcl
public KeyContainerPermissionFlags AllFlags
}
public System.Security.Permissions.PermissionSetAttribute : CodeAccessSecurityAttribute {
private string file
private string name
private bool isUnicodeEncoded
private string xml
private string hex
public string File
public string Hex
public string Name
public bool UnicodeEncoded
public string XML
public void .ctor(SecurityAction action)
public string get_File()
public void set_File(string value)
public string get_Hex()
public void set_Hex(string value)
public string get_Name()
public void set_Name(string value)
public bool get_UnicodeEncoded()
public void set_UnicodeEncoded(bool value)
public string get_XML()
public void set_XML(string value)
public IPermission CreatePermission()
private PermissionSet CreateFromXml(string xml)
public PermissionSet CreatePermissionSet()
}
public System.Security.Permissions.PermissionState : Enum {
public int value__
public PermissionState Unrestricted
public PermissionState None
}
public System.Security.Permissions.PrincipalPermission : object {
private int version
private ArrayList principals
public void .ctor(PermissionState state)
public void .ctor(string name, string role)
public void .ctor(string name, string role, bool isAuthenticated)
internal void .ctor(ArrayList principals)
public IPermission Copy()
public void Demand()
public void FromXml(SecurityElement elem)
public IPermission Intersect(IPermission target)
public bool IsSubsetOf(IPermission target)
public bool IsUnrestricted()
public string ToString()
public SecurityElement ToXml()
public IPermission Union(IPermission other)
public bool Equals(object obj)
public int GetHashCode()
private int System.Security.Permissions.IBuiltInPermission.GetTokenIndex()
private PrincipalPermission Cast(IPermission target)
private bool IsEmpty()
internal int CheckSecurityElement(SecurityElement se, string parameterName, int minimumVersion, int maximumVersion)
}
public System.Security.Permissions.PrincipalPermissionAttribute : CodeAccessSecurityAttribute {
private bool authenticated
private string name
private string role
public bool Authenticated
public string Name
public string Role
public void .ctor(SecurityAction action)
public bool get_Authenticated()
public void set_Authenticated(bool value)
public string get_Name()
public void set_Name(string value)
public string get_Role()
public void set_Role(string value)
public IPermission CreatePermission()
}
public System.Security.Permissions.PublisherIdentityPermission : CodeAccessPermission {
private int version
private X509Certificate x509
public X509Certificate Certificate
public void .ctor(PermissionState state)
public void .ctor(X509Certificate certificate)
public X509Certificate get_Certificate()
public void set_Certificate(X509Certificate value)
public IPermission Copy()
public void FromXml(SecurityElement esd)
public IPermission Intersect(IPermission target)
public bool IsSubsetOf(IPermission target)
public SecurityElement ToXml()
public IPermission Union(IPermission target)
private int System.Security.Permissions.IBuiltInPermission.GetTokenIndex()
private PublisherIdentityPermission Cast(IPermission target)
}
public System.Security.Permissions.PublisherIdentityPermissionAttribute : CodeAccessSecurityAttribute {
private string certFile
private string signedFile
private string x509data
public string CertFile
public string SignedFile
public string X509Certificate
public void .ctor(SecurityAction action)
public string get_CertFile()
public void set_CertFile(string value)
public string get_SignedFile()
public void set_SignedFile(string value)
public string get_X509Certificate()
public void set_X509Certificate(string value)
public IPermission CreatePermission()
}
public System.Security.Permissions.ReflectionPermission : CodeAccessPermission {
private int version
private ReflectionPermissionFlag flags
public ReflectionPermissionFlag Flags
public void .ctor(PermissionState state)
public void .ctor(ReflectionPermissionFlag flag)
public ReflectionPermissionFlag get_Flags()
public void set_Flags(ReflectionPermissionFlag value)
public IPermission Copy()
public void FromXml(SecurityElement esd)
public IPermission Intersect(IPermission target)
public bool IsSubsetOf(IPermission target)
public bool IsUnrestricted()
public SecurityElement ToXml()
public IPermission Union(IPermission other)
private int System.Security.Permissions.IBuiltInPermission.GetTokenIndex()
private ReflectionPermission Cast(IPermission target)
}
public System.Security.Permissions.ReflectionPermissionAttribute : CodeAccessSecurityAttribute {
private ReflectionPermissionFlag flags
private bool memberAccess
private bool reflectionEmit
private bool typeInfo
public ReflectionPermissionFlag Flags
public bool MemberAccess
public bool ReflectionEmit
public bool RestrictedMemberAccess
public bool TypeInformation
public void .ctor(SecurityAction action)
public ReflectionPermissionFlag get_Flags()
public void set_Flags(ReflectionPermissionFlag value)
public bool get_MemberAccess()
public void set_MemberAccess(bool value)
public bool get_ReflectionEmit()
public void set_ReflectionEmit(bool value)
public bool get_RestrictedMemberAccess()
public void set_RestrictedMemberAccess(bool value)
public bool get_TypeInformation()
public void set_TypeInformation(bool value)
public IPermission CreatePermission()
}
public System.Security.Permissions.ReflectionPermissionFlag : Enum {
public int value__
public ReflectionPermissionFlag NoFlags
public ReflectionPermissionFlag TypeInformation
public ReflectionPermissionFlag MemberAccess
public ReflectionPermissionFlag ReflectionEmit
public ReflectionPermissionFlag AllFlags
public ReflectionPermissionFlag RestrictedMemberAccess
}
public System.Security.Permissions.RegistryPermission : CodeAccessPermission {
private int version
private PermissionState _state
private ArrayList createList
private ArrayList readList
private ArrayList writeList
public void .ctor(PermissionState state)
public void .ctor(RegistryPermissionAccess access, string pathList)
public void .ctor(RegistryPermissionAccess access, AccessControlActions control, string pathList)
public void AddPathList(RegistryPermissionAccess access, string pathList)
public void AddPathList(RegistryPermissionAccess access, AccessControlActions control, string pathList)
public string GetPathList(RegistryPermissionAccess access)
public void SetPathList(RegistryPermissionAccess access, string pathList)
public IPermission Copy()
public void FromXml(SecurityElement esd)
public IPermission Intersect(IPermission target)
public bool IsSubsetOf(IPermission target)
public bool IsUnrestricted()
public SecurityElement ToXml()
public IPermission Union(IPermission other)
private int System.Security.Permissions.IBuiltInPermission.GetTokenIndex()
private bool IsEmpty()
private RegistryPermission Cast(IPermission target)
internal void ThrowInvalidFlag(RegistryPermissionAccess flag, bool context)
private string GetPathList(ArrayList list)
internal bool KeyIsSubsetOf(IList local, IList target)
internal void AddWithUnionKey(IList list, string pathList)
internal void IntersectKeys(IList local, IList target, IList result)
}
public System.Security.Permissions.RegistryPermissionAccess : Enum {
public int value__
public RegistryPermissionAccess NoAccess
public RegistryPermissionAccess Read
public RegistryPermissionAccess Write
public RegistryPermissionAccess Create
public RegistryPermissionAccess AllAccess
}
public System.Security.Permissions.RegistryPermissionAttribute : CodeAccessSecurityAttribute {
private string create
private string read
private string write
private string changeAccessControl
private string viewAccessControl
public string All
public string Create
public string Read
public string Write
public string ChangeAccessControl
public string ViewAccessControl
public string ViewAndModify
public void .ctor(SecurityAction action)
public string get_All()
public void set_All(string value)
public string get_Create()
public void set_Create(string value)
public string get_Read()
public void set_Read(string value)
public string get_Write()
public void set_Write(string value)
public string get_ChangeAccessControl()
public void set_ChangeAccessControl(string value)
public string get_ViewAccessControl()
public void set_ViewAccessControl(string value)
public string get_ViewAndModify()
public void set_ViewAndModify(string value)
public IPermission CreatePermission()
}
public System.Security.Permissions.SecurityAction : Enum {
public int value__
public SecurityAction Demand
public SecurityAction Assert
public SecurityAction Deny
public SecurityAction PermitOnly
public SecurityAction LinkDemand
public SecurityAction InheritanceDemand
public SecurityAction RequestMinimum
public SecurityAction RequestOptional
public SecurityAction RequestRefuse
}
public System.Security.Permissions.SecurityAttribute : Attribute {
private SecurityAction m_Action
private bool m_Unrestricted
public bool Unrestricted
public SecurityAction Action
protected void .ctor(SecurityAction action)
public IPermission CreatePermission()
public bool get_Unrestricted()
public void set_Unrestricted(bool value)
public SecurityAction get_Action()
public void set_Action(SecurityAction value)
}
public System.Security.Permissions.SecurityPermission : CodeAccessPermission {
private int version
private SecurityPermissionFlag flags
public SecurityPermissionFlag Flags
public void .ctor(PermissionState state)
public void .ctor(SecurityPermissionFlag flag)
public SecurityPermissionFlag get_Flags()
public void set_Flags(SecurityPermissionFlag value)
public bool IsUnrestricted()
public IPermission Copy()
public IPermission Intersect(IPermission target)
public IPermission Union(IPermission target)
public bool IsSubsetOf(IPermission target)
public void FromXml(SecurityElement esd)
public SecurityElement ToXml()
private int System.Security.Permissions.IBuiltInPermission.GetTokenIndex()
private bool IsEmpty()
private SecurityPermission Cast(IPermission target)
}
public System.Security.Permissions.SecurityPermissionAttribute : CodeAccessSecurityAttribute {
private SecurityPermissionFlag m_Flags
public bool Assertion
public bool BindingRedirects
public bool ControlAppDomain
public bool ControlDomainPolicy
public bool ControlEvidence
public bool ControlPolicy
public bool ControlPrincipal
public bool ControlThread
public bool Execution
public bool Infrastructure
public bool RemotingConfiguration
public bool SerializationFormatter
public bool SkipVerification
public bool UnmanagedCode
public SecurityPermissionFlag Flags
public void .ctor(SecurityAction action)
public bool get_Assertion()
public void set_Assertion(bool value)
public bool get_BindingRedirects()
public void set_BindingRedirects(bool value)
public bool get_ControlAppDomain()
public void set_ControlAppDomain(bool value)
public bool get_ControlDomainPolicy()
public void set_ControlDomainPolicy(bool value)
public bool get_ControlEvidence()
public void set_ControlEvidence(bool value)
public bool get_ControlPolicy()
public void set_ControlPolicy(bool value)
public bool get_ControlPrincipal()
public void set_ControlPrincipal(bool value)
public bool get_ControlThread()
public void set_ControlThread(bool value)
public bool get_Execution()
public void set_Execution(bool value)
public bool get_Infrastructure()
public void set_Infrastructure(bool value)
public bool get_RemotingConfiguration()
public void set_RemotingConfiguration(bool value)
public bool get_SerializationFormatter()
public void set_SerializationFormatter(bool value)
public bool get_SkipVerification()
public void set_SkipVerification(bool value)
public bool get_UnmanagedCode()
public void set_UnmanagedCode(bool value)
public IPermission CreatePermission()
public SecurityPermissionFlag get_Flags()
public void set_Flags(SecurityPermissionFlag value)
}
public System.Security.Permissions.SecurityPermissionFlag : Enum {
public int value__
public SecurityPermissionFlag NoFlags
public SecurityPermissionFlag Assertion
public SecurityPermissionFlag UnmanagedCode
public SecurityPermissionFlag SkipVerification
public SecurityPermissionFlag Execution
public SecurityPermissionFlag ControlThread
public SecurityPermissionFlag ControlEvidence
public SecurityPermissionFlag ControlPolicy
public SecurityPermissionFlag SerializationFormatter
public SecurityPermissionFlag ControlDomainPolicy
public SecurityPermissionFlag ControlPrincipal
public SecurityPermissionFlag ControlAppDomain
public SecurityPermissionFlag RemotingConfiguration
public SecurityPermissionFlag Infrastructure
public SecurityPermissionFlag BindingRedirects
public SecurityPermissionFlag AllFlags
}
public System.Security.Permissions.SiteIdentityPermission : CodeAccessPermission {
private int version
private string _site
private Boolean[] valid
public string Site
public void .ctor(PermissionState state)
public void .ctor(string site)
public string get_Site()
public void set_Site(string value)
public IPermission Copy()
public void FromXml(SecurityElement esd)
public IPermission Intersect(IPermission target)
public bool IsSubsetOf(IPermission target)
public SecurityElement ToXml()
public IPermission Union(IPermission target)
private int System.Security.Permissions.IBuiltInPermission.GetTokenIndex()
private bool IsEmpty()
private SiteIdentityPermission Cast(IPermission target)
private bool IsValid(string s)
private bool Match(string target)
}
public System.Security.Permissions.SiteIdentityPermissionAttribute : CodeAccessSecurityAttribute {
private string site
public string Site
public void .ctor(SecurityAction action)
public string get_Site()
public void set_Site(string value)
public IPermission CreatePermission()
}
public System.Security.Permissions.StrongNameIdentityPermission : CodeAccessPermission {
private int version
private Version defaultVersion
private PermissionState _state
private ArrayList _list
public string Name
public StrongNamePublicKeyBlob PublicKey
public Version Version
public void .ctor(PermissionState state)
public void .ctor(StrongNamePublicKeyBlob blob, string name, Version version)
internal void .ctor(StrongNameIdentityPermission snip)
public string get_Name()
public void set_Name(string value)
public StrongNamePublicKeyBlob get_PublicKey()
public void set_PublicKey(StrongNamePublicKeyBlob value)
public Version get_Version()
public void set_Version(Version value)
internal void ResetToDefault()
public IPermission Copy()
public void FromXml(SecurityElement e)
private SNIP FromSecurityElement(SecurityElement se)
public IPermission Intersect(IPermission target)
public bool IsSubsetOf(IPermission target)
public SecurityElement ToXml()
private void ToSecurityElement(SecurityElement se, SNIP snip)
public IPermission Union(IPermission target)
private int System.Security.Permissions.IBuiltInPermission.GetTokenIndex()
private bool IsUnrestricted()
private bool Contains(SNIP snip)
private bool IsEmpty(SNIP snip)
private bool IsEmpty()
private StrongNameIdentityPermission Cast(IPermission target)
private bool Match(string target)
}
public System.Security.Permissions.StrongNameIdentityPermissionAttribute : CodeAccessSecurityAttribute {
private string name
private string key
private string version
public string Name
public string PublicKey
public string Version
public void .ctor(SecurityAction action)
public string get_Name()
public void set_Name(string value)
public string get_PublicKey()
public void set_PublicKey(string value)
public string get_Version()
public void set_Version(string value)
public IPermission CreatePermission()
}
public System.Security.Permissions.StrongNamePublicKeyBlob : object {
internal Byte[] pubkey
public void .ctor(Byte[] publicKey)
internal StrongNamePublicKeyBlob FromString(string s)
private byte CharToByte(char c)
public bool Equals(object obj)
public int GetHashCode()
public string ToString()
}
public System.Security.Permissions.UIPermission : CodeAccessPermission {
private UIPermissionWindow _window
private UIPermissionClipboard _clipboard
private int version
public UIPermissionClipboard Clipboard
public UIPermissionWindow Window
public void .ctor(PermissionState state)
public void .ctor(UIPermissionClipboard clipboardFlag)
public void .ctor(UIPermissionWindow windowFlag)
public void .ctor(UIPermissionWindow windowFlag, UIPermissionClipboard clipboardFlag)
public UIPermissionClipboard get_Clipboard()
public void set_Clipboard(UIPermissionClipboard value)
public UIPermissionWindow get_Window()
public void set_Window(UIPermissionWindow value)
public IPermission Copy()
public void FromXml(SecurityElement esd)
public IPermission Intersect(IPermission target)
public bool IsSubsetOf(IPermission target)
public bool IsUnrestricted()
public SecurityElement ToXml()
public IPermission Union(IPermission target)
private int System.Security.Permissions.IBuiltInPermission.GetTokenIndex()
private bool IsEmpty(UIPermissionWindow w, UIPermissionClipboard c)
private UIPermission Cast(IPermission target)
}
public System.Security.Permissions.UIPermissionAttribute : CodeAccessSecurityAttribute {
private UIPermissionClipboard clipboard
private UIPermissionWindow window
public UIPermissionClipboard Clipboard
public UIPermissionWindow Window
public void .ctor(SecurityAction action)
public UIPermissionClipboard get_Clipboard()
public void set_Clipboard(UIPermissionClipboard value)
public UIPermissionWindow get_Window()
public void set_Window(UIPermissionWindow value)
public IPermission CreatePermission()
}
public System.Security.Permissions.UIPermissionClipboard : Enum {
public int value__
public UIPermissionClipboard NoClipboard
public UIPermissionClipboard OwnClipboard
public UIPermissionClipboard AllClipboard
}
public System.Security.Permissions.UIPermissionWindow : Enum {
public int value__
public UIPermissionWindow NoWindows
public UIPermissionWindow SafeSubWindows
public UIPermissionWindow SafeTopLevelWindows
public UIPermissionWindow AllWindows
}
public System.Security.Permissions.UrlIdentityPermission : CodeAccessPermission {
private int version
private string url
public string Url
public void .ctor(PermissionState state)
public void .ctor(string site)
public string get_Url()
public void set_Url(string value)
public IPermission Copy()
public void FromXml(SecurityElement esd)
public IPermission Intersect(IPermission target)
public bool IsSubsetOf(IPermission target)
public SecurityElement ToXml()
public IPermission Union(IPermission target)
private int System.Security.Permissions.IBuiltInPermission.GetTokenIndex()
private bool IsEmpty()
private UrlIdentityPermission Cast(IPermission target)
private bool Match(string target)
}
public System.Security.Permissions.UrlIdentityPermissionAttribute : CodeAccessSecurityAttribute {
private string url
public string Url
public void .ctor(SecurityAction action)
public string get_Url()
public void set_Url(string value)
public IPermission CreatePermission()
}
public System.Security.Permissions.ZoneIdentityPermission : CodeAccessPermission {
private int version
private SecurityZone zone
public SecurityZone SecurityZone
public void .ctor(PermissionState state)
public void .ctor(SecurityZone zone)
public IPermission Copy()
public bool IsSubsetOf(IPermission target)
public IPermission Union(IPermission target)
public IPermission Intersect(IPermission target)
public void FromXml(SecurityElement esd)
public SecurityElement ToXml()
public SecurityZone get_SecurityZone()
public void set_SecurityZone(SecurityZone value)
private int System.Security.Permissions.IBuiltInPermission.GetTokenIndex()
private ZoneIdentityPermission Cast(IPermission target)
}
public System.Security.Permissions.ZoneIdentityPermissionAttribute : CodeAccessSecurityAttribute {
private SecurityZone zone
public SecurityZone Zone
public void .ctor(SecurityAction action)
public SecurityZone get_Zone()
public void set_Zone(SecurityZone value)
public IPermission CreatePermission()
}
public System.Security.PermissionSet : object {
private string tagName
private int version
private Object[] psUnrestricted
private PermissionState state
private ArrayList list
private PolicyLevel _policyLevel
private bool _declsec
private bool _readOnly
private Boolean[] _ignored
private Object[] action
public int Count
public bool IsSynchronized
public bool IsReadOnly
public object SyncRoot
internal bool DeclarativeSecurity
internal PolicyLevel Resolver
public void .ctor(PermissionState state)
public void .ctor(PermissionSet permSet)
internal void .ctor(string xml)
internal void .ctor(IPermission perm)
public IPermission AddPermission(IPermission perm)
public void Assert()
internal void Clear()
public PermissionSet Copy()
public void CopyTo(Array array, int index)
public void Demand()
internal void CasOnlyDemand(int skip)
public void Deny()
public void FromXml(SecurityElement et)
public IEnumerator GetEnumerator()
public bool IsSubsetOf(PermissionSet target)
public void PermitOnly()
public bool ContainsNonCodeAccessPermissions()
public Byte[] ConvertPermissionSet(string inFormat, Byte[] inData, string outFormat)
public IPermission GetPermission(Type permClass)
public PermissionSet Intersect(PermissionSet other)
internal void InternalIntersect(PermissionSet intersect, PermissionSet a, PermissionSet b, bool unrestricted)
public bool IsEmpty()
public bool IsUnrestricted()
public IPermission RemovePermission(Type permClass)
public IPermission SetPermission(IPermission perm)
public string ToString()
public SecurityElement ToXml()
public PermissionSet Union(PermissionSet other)
public int get_Count()
public bool get_IsSynchronized()
public bool get_IsReadOnly()
public object get_SyncRoot()
internal bool get_DeclarativeSecurity()
internal void set_DeclarativeSecurity(bool value)
private void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender)
public bool Equals(object obj)
public int GetHashCode()
public void RevertAssert()
internal PolicyLevel get_Resolver()
internal void set_Resolver(PolicyLevel value)
internal void SetReadOnly(bool value)
private bool AllIgnored()
internal PermissionSet CreateFromBinaryFormat(Byte[] data)
internal int ReadEncodedInt(Byte[] data, Int32& position)
internal IPermission ProcessAttribute(Byte[] data, Int32& position)
}
public System.Security.Policy.AllMembershipCondition : object {
private int version
public bool Check(Evidence evidence)
public IMembershipCondition Copy()
public bool Equals(object o)
public void FromXml(SecurityElement e)
public void FromXml(SecurityElement e, PolicyLevel level)
public int GetHashCode()
public string ToString()
public SecurityElement ToXml()
public SecurityElement ToXml(PolicyLevel level)
}
public System.Security.Policy.ApplicationDirectory : EvidenceBase {
private string directory
public string Directory
public void .ctor(string name)
public string get_Directory()
public object Copy()
public bool Equals(object o)
public int GetHashCode()
public string ToString()
private int System.Security.Policy.IBuiltInEvidence.GetRequiredSize(bool verbose)
private int System.Security.Policy.IBuiltInEvidence.InitFromBuffer(Char[] buffer, int position)
private int System.Security.Policy.IBuiltInEvidence.OutputToBuffer(Char[] buffer, int position, bool verbose)
private void ThrowOnInvalid(string appdir)
}
public System.Security.Policy.ApplicationDirectoryMembershipCondition : object {
private int version
public bool Check(Evidence evidence)
public IMembershipCondition Copy()
public bool Equals(object o)
public void FromXml(SecurityElement e)
public void FromXml(SecurityElement e, PolicyLevel level)
public int GetHashCode()
public string ToString()
public SecurityElement ToXml()
public SecurityElement ToXml(PolicyLevel level)
}
public System.Security.Policy.ApplicationSecurityInfo : object {
private Evidence _evidence
private ApplicationId _appid
private PermissionSet _defaultSet
private ApplicationId _deployid
public Evidence ApplicationEvidence
public ApplicationId ApplicationId
public PermissionSet DefaultRequestSet
public ApplicationId DeploymentId
public void .ctor(ActivationContext activationContext)
public Evidence get_ApplicationEvidence()
public void set_ApplicationEvidence(Evidence value)
public ApplicationId get_ApplicationId()
public void set_ApplicationId(ApplicationId value)
public PermissionSet get_DefaultRequestSet()
public void set_DefaultRequestSet(PermissionSet value)
public ApplicationId get_DeploymentId()
public void set_DeploymentId(ApplicationId value)
}
public System.Security.Policy.ApplicationSecurityManager : object {
private IApplicationTrustManager _appTrustManager
private ApplicationTrustCollection _userAppTrusts
public IApplicationTrustManager ApplicationTrustManager
public ApplicationTrustCollection UserApplicationTrusts
public IApplicationTrustManager get_ApplicationTrustManager()
public ApplicationTrustCollection get_UserApplicationTrusts()
public bool DetermineApplicationTrust(ActivationContext activationContext, TrustManagerContext context)
}
public System.Security.Policy.ApplicationTrust : EvidenceBase {
private ApplicationIdentity _appid
private PolicyStatement _defaultPolicy
private object _xtranfo
private bool _trustrun
private bool _persist
private IList`1<StrongName> fullTrustAssemblies
public ApplicationIdentity ApplicationIdentity
public PolicyStatement DefaultGrantSet
public object ExtraInfo
public bool IsApplicationTrustedToRun
public bool Persist
public IList`1<StrongName> FullTrustAssemblies
public void .ctor(ApplicationIdentity applicationIdentity)
public void .ctor(PermissionSet defaultGrantSet, IEnumerable`1<StrongName> fullTrustAssemblies)
public ApplicationIdentity get_ApplicationIdentity()
public void set_ApplicationIdentity(ApplicationIdentity value)
public PolicyStatement get_DefaultGrantSet()
public void set_DefaultGrantSet(PolicyStatement value)
public object get_ExtraInfo()
public void set_ExtraInfo(object value)
public bool get_IsApplicationTrustedToRun()
public void set_IsApplicationTrustedToRun(bool value)
public bool get_Persist()
public void set_Persist(bool value)
public void FromXml(SecurityElement element)
public SecurityElement ToXml()
public IList`1<StrongName> get_FullTrustAssemblies()
private PolicyStatement GetDefaultGrantSet()
}
public System.Security.Policy.ApplicationTrustCollection : object {
private ArrayList _list
public int Count
public bool IsSynchronized
public object SyncRoot
public ApplicationTrust Item
public ApplicationTrust Item
public int get_Count()
public bool get_IsSynchronized()
public object get_SyncRoot()
public ApplicationTrust get_Item(int index)
public ApplicationTrust get_Item(string appFullName)
public int Add(ApplicationTrust trust)
public void AddRange(ApplicationTrust[] trusts)
public void AddRange(ApplicationTrustCollection trusts)
public void Clear()
public void CopyTo(ApplicationTrust[] array, int index)
private void System.Collections.ICollection.CopyTo(Array array, int index)
public ApplicationTrustCollection Find(ApplicationIdentity applicationIdentity, ApplicationVersionMatch versionMatch)
public ApplicationTrustEnumerator GetEnumerator()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
public void Remove(ApplicationTrust trust)
public void Remove(ApplicationIdentity applicationIdentity, ApplicationVersionMatch versionMatch)
public void RemoveRange(ApplicationTrust[] trusts)
public void RemoveRange(ApplicationTrustCollection trusts)
internal void RemoveAllInstances(ApplicationTrust trust)
}
public System.Security.Policy.ApplicationTrustEnumerator : object {
private IEnumerator e
public ApplicationTrust Current
private object System.Collections.IEnumerator.Current
internal void .ctor(ApplicationTrustCollection collection)
public ApplicationTrust get_Current()
private object System.Collections.IEnumerator.get_Current()
public bool MoveNext()
public void Reset()
}
public System.Security.Policy.ApplicationVersionMatch : Enum {
public int value__
public ApplicationVersionMatch MatchExactVersion
public ApplicationVersionMatch MatchAllVersions
}
public System.Security.Policy.CodeConnectAccess : object {
public string AnyScheme
public int DefaultPort
public int OriginPort
public string OriginScheme
private string _scheme
private int _port
public int Port
public string Scheme
public void .ctor(string allowScheme, int allowPort)
public int get_Port()
public string get_Scheme()
public bool Equals(object o)
public int GetHashCode()
public CodeConnectAccess CreateAnySchemeAccess(int allowPort)
public CodeConnectAccess CreateOriginSchemeAccess(int allowPort)
}
public System.Security.Policy.CodeGroup : object {
private PolicyStatement m_policy
private IMembershipCondition m_membershipCondition
private string m_description
private string m_name
private ArrayList m_children
public string MergeLogic
public PolicyStatement PolicyStatement
public string Description
public IMembershipCondition MembershipCondition
public string Name
public IList Children
public string AttributeString
public string PermissionSetName
protected void .ctor(IMembershipCondition membershipCondition, PolicyStatement policy)
internal void .ctor(SecurityElement e, PolicyLevel level)
public CodeGroup Copy()
public string get_MergeLogic()
public PolicyStatement Resolve(Evidence evidence)
public CodeGroup ResolveMatchingCodeGroups(Evidence evidence)
public PolicyStatement get_PolicyStatement()
public void set_PolicyStatement(PolicyStatement value)
public string get_Description()
public void set_Description(string value)
public IMembershipCondition get_MembershipCondition()
public void set_MembershipCondition(IMembershipCondition value)
public string get_Name()
public void set_Name(string value)
public IList get_Children()
public void set_Children(IList value)
public string get_AttributeString()
public string get_PermissionSetName()
public void AddChild(CodeGroup group)
public bool Equals(object o)
public bool Equals(CodeGroup cg, bool compareChildren)
public void RemoveChild(CodeGroup group)
public int GetHashCode()
public void FromXml(SecurityElement e)
public void FromXml(SecurityElement e, PolicyLevel level)
protected void ParseXml(SecurityElement e, PolicyLevel level)
public SecurityElement ToXml()
public SecurityElement ToXml(PolicyLevel level)
protected void CreateXml(SecurityElement element, PolicyLevel level)
internal CodeGroup CreateFromXml(SecurityElement se, PolicyLevel level)
}
internal System.Security.Policy.DefaultPolicies : object {
private string DnsPermissionClass
private string EventLogPermissionClass
private string PrintingPermissionClass
private string SocketPermissionClass
private string WebPermissionClass
private string PerformanceCounterPermissionClass
private string DirectoryServicesPermissionClass
private string MessageQueuePermissionClass
private string ServiceControllerPermissionClass
private string OleDbPermissionClass
private string SqlClientPermissionClass
private Version _fxVersion
private Byte[] _ecmaKey
private StrongNamePublicKeyBlob _ecma
private Byte[] _msFinalKey
private StrongNamePublicKeyBlob _msFinal
private NamedPermissionSet _fullTrust
private NamedPermissionSet _localIntranet
private NamedPermissionSet _internet
private NamedPermissionSet _skipVerification
private NamedPermissionSet _execution
private NamedPermissionSet _nothing
private NamedPermissionSet _everything
public PermissionSet FullTrust
public PermissionSet LocalIntranet
public PermissionSet Internet
public PermissionSet SkipVerification
public PermissionSet Execution
public PermissionSet Nothing
public PermissionSet Everything
public PermissionSet GetSpecialPermissionSet(string name)
public PermissionSet get_FullTrust()
public PermissionSet get_LocalIntranet()
public PermissionSet get_Internet()
public PermissionSet get_SkipVerification()
public PermissionSet get_Execution()
public PermissionSet get_Nothing()
public PermissionSet get_Everything()
public StrongNameMembershipCondition FullTrustMembership(string name, Key key)
private NamedPermissionSet BuildFullTrust()
private NamedPermissionSet BuildLocalIntranet()
private NamedPermissionSet BuildInternet()
private NamedPermissionSet BuildSkipVerification()
private NamedPermissionSet BuildExecution()
private NamedPermissionSet BuildNothing()
private NamedPermissionSet BuildEverything()
private SecurityElement PrintingPermission(string level)
}
public System.Security.Policy.Evidence : object {
private bool _locked
private ArrayList hostEvidenceList
private ArrayList assemblyEvidenceList
public int Count
public bool IsReadOnly
public bool IsSynchronized
public bool Locked
public object SyncRoot
internal ArrayList HostEvidenceList
internal ArrayList AssemblyEvidenceList
public void .ctor(Evidence evidence)
public void .ctor(Object[] hostEvidence, Object[] assemblyEvidence)
public int get_Count()
public bool get_IsReadOnly()
public bool get_IsSynchronized()
public bool get_Locked()
public void set_Locked(bool value)
public object get_SyncRoot()
internal ArrayList get_HostEvidenceList()
internal ArrayList get_AssemblyEvidenceList()
public void AddAssembly(object id)
public void AddHost(object id)
public void Clear()
public Evidence Clone()
public void CopyTo(Array array, int index)
public IEnumerator GetEnumerator()
public IEnumerator GetAssemblyEnumerator()
public IEnumerator GetHostEnumerator()
public void Merge(Evidence evidence)
public void RemoveType(Type t)
private bool IsAuthenticodePresent(Assembly a)
internal Evidence GetDefaultHostEvidence(Assembly a)
public void AddAssemblyEvidence(T evidence)
public void AddHostEvidence(T evidence)
public T GetAssemblyEvidence()
public T GetHostEvidence()
}
public System.Security.Policy.EvidenceBase : object {
public EvidenceBase Clone()
}
public System.Security.Policy.FileCodeGroup : CodeGroup {
private FileIOPermissionAccess m_access
public string MergeLogic
public string AttributeString
public string PermissionSetName
public void .ctor(IMembershipCondition membershipCondition, FileIOPermissionAccess access)
internal void .ctor(SecurityElement e, PolicyLevel level)
public CodeGroup Copy()
public string get_MergeLogic()
public PolicyStatement Resolve(Evidence evidence)
public CodeGroup ResolveMatchingCodeGroups(Evidence evidence)
public string get_AttributeString()
public string get_PermissionSetName()
public bool Equals(object o)
public int GetHashCode()
protected void ParseXml(SecurityElement e, PolicyLevel level)
protected void CreateXml(SecurityElement element, PolicyLevel level)
}
public System.Security.Policy.FirstMatchCodeGroup : CodeGroup {
public string MergeLogic
public void .ctor(IMembershipCondition membershipCondition, PolicyStatement policy)
internal void .ctor(SecurityElement e, PolicyLevel level)
public string get_MergeLogic()
public CodeGroup Copy()
public PolicyStatement Resolve(Evidence evidence)
public CodeGroup ResolveMatchingCodeGroups(Evidence evidence)
private FirstMatchCodeGroup CopyNoChildren()
}
public System.Security.Policy.GacInstalled : EvidenceBase {
public object Copy()
public IPermission CreateIdentityPermission(Evidence evidence)
public bool Equals(object o)
public int GetHashCode()
public string ToString()
private int System.Security.Policy.IBuiltInEvidence.GetRequiredSize(bool verbose)
private int System.Security.Policy.IBuiltInEvidence.InitFromBuffer(Char[] buffer, int position)
private int System.Security.Policy.IBuiltInEvidence.OutputToBuffer(Char[] buffer, int position, bool verbose)
}
public System.Security.Policy.GacMembershipCondition : object {
private int version
public bool Check(Evidence evidence)
public IMembershipCondition Copy()
public bool Equals(object o)
public void FromXml(SecurityElement e)
public void FromXml(SecurityElement e, PolicyLevel level)
public int GetHashCode()
public string ToString()
public SecurityElement ToXml()
public SecurityElement ToXml(PolicyLevel level)
}
public System.Security.Policy.Hash : EvidenceBase {
private Assembly assembly
private Byte[] data
internal Byte[] _md5
internal Byte[] _sha1
public Byte[] MD5
public Byte[] SHA1
public Byte[] SHA256
public void .ctor(Assembly assembly)
internal void .ctor(SerializationInfo info, StreamingContext context)
public Byte[] get_MD5()
public Byte[] get_SHA1()
public Byte[] GenerateHash(HashAlgorithm hashAlg)
public void GetObjectData(SerializationInfo info, StreamingContext context)
public string ToString()
private Byte[] GetData()
private int System.Security.Policy.IBuiltInEvidence.GetRequiredSize(bool verbose)
private int System.Security.Policy.IBuiltInEvidence.InitFromBuffer(Char[] buffer, int position)
private int System.Security.Policy.IBuiltInEvidence.OutputToBuffer(Char[] buffer, int position, bool verbose)
public Hash CreateMD5(Byte[] md5)
public Hash CreateSHA1(Byte[] sha1)
public Byte[] get_SHA256()
public Hash CreateSHA256(Byte[] sha256)
}
public System.Security.Policy.HashMembershipCondition : object {
private int version
private HashAlgorithm hash_algorithm
private Byte[] hash_value
public HashAlgorithm HashAlgorithm
public Byte[] HashValue
public void .ctor(HashAlgorithm hashAlg, Byte[] value)
public HashAlgorithm get_HashAlgorithm()
public void set_HashAlgorithm(HashAlgorithm value)
public Byte[] get_HashValue()
public void set_HashValue(Byte[] value)
public bool Check(Evidence evidence)
public IMembershipCondition Copy()
public bool Equals(object o)
public SecurityElement ToXml()
public SecurityElement ToXml(PolicyLevel level)
public void FromXml(SecurityElement e)
public void FromXml(SecurityElement e, PolicyLevel level)
public int GetHashCode()
public string ToString()
private bool Compare(Byte[] expected, Byte[] actual)
private void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender)
private void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context)
}
public System.Security.Policy.IApplicationTrustManager {
public ApplicationTrust DetermineApplicationTrust(ActivationContext activationContext, TrustManagerContext context)
}
internal System.Security.Policy.IBuiltInEvidence {
public int GetRequiredSize(bool verbose)
public int InitFromBuffer(Char[] buffer, int position)
public int OutputToBuffer(Char[] buffer, int position, bool verbose)
}
public System.Security.Policy.IIdentityPermissionFactory {
public IPermission CreateIdentityPermission(Evidence evidence)
}
public System.Security.Policy.IMembershipCondition {
public bool Check(Evidence evidence)
public IMembershipCondition Copy()
public bool Equals(object obj)
public string ToString()
}
internal System.Security.Policy.MembershipConditionHelper : object {
private string XmlTag
internal int CheckSecurityElement(SecurityElement se, string parameterName, int minimumVersion, int maximumVersion)
internal SecurityElement Element(Type type, int version)
}
internal System.Security.Policy.MonoTrustManager : object {
private string tag
public ApplicationTrust DetermineApplicationTrust(ActivationContext activationContext, TrustManagerContext context)
public void FromXml(SecurityElement e)
public SecurityElement ToXml()
}
public System.Security.Policy.NetCodeGroup : CodeGroup {
public string AbsentOriginScheme
public string AnyOtherOriginScheme
private Hashtable _rules
private int _hashcode
public string AttributeString
public string MergeLogic
public string PermissionSetName
public void .ctor(IMembershipCondition membershipCondition)
internal void .ctor(SecurityElement e, PolicyLevel level)
public string get_AttributeString()
public string get_MergeLogic()
public string get_PermissionSetName()
public void AddConnectAccess(string originScheme, CodeConnectAccess connectAccess)
public CodeGroup Copy()
private bool Equals(CodeConnectAccess[] rules1, CodeConnectAccess[] rules2)
public bool Equals(object o)
public DictionaryEntry[] GetConnectAccessRules()
public int GetHashCode()
public PolicyStatement Resolve(Evidence evidence)
public void ResetConnectAccess()
public CodeGroup ResolveMatchingCodeGroups(Evidence evidence)
protected void CreateXml(SecurityElement element, PolicyLevel level)
protected void ParseXml(SecurityElement e, PolicyLevel level)
}
public System.Security.Policy.PermissionRequestEvidence : EvidenceBase {
private PermissionSet requested
private PermissionSet optional
private PermissionSet denied
public PermissionSet DeniedPermissions
public PermissionSet OptionalPermissions
public PermissionSet RequestedPermissions
public void .ctor(PermissionSet request, PermissionSet optional, PermissionSet denied)
public PermissionSet get_DeniedPermissions()
public PermissionSet get_OptionalPermissions()
public PermissionSet get_RequestedPermissions()
public PermissionRequestEvidence Copy()
public string ToString()
private int System.Security.Policy.IBuiltInEvidence.GetRequiredSize(bool verbose)
private int System.Security.Policy.IBuiltInEvidence.InitFromBuffer(Char[] buffer, int position)
private int System.Security.Policy.IBuiltInEvidence.OutputToBuffer(Char[] buffer, int position, bool verbose)
}
public System.Security.Policy.PolicyException : SystemException {
public void .ctor(string message)
protected void .ctor(SerializationInfo info, StreamingContext context)
public void .ctor(string message, Exception exception)
}
public System.Security.Policy.PolicyLevel : object {
private string label
private CodeGroup root_code_group
private ArrayList full_trust_assemblies
private ArrayList named_permission_sets
private string _location
private PolicyLevelType _type
private Hashtable fullNames
private SecurityElement xml
public IList FullTrustAssemblies
public string Label
public IList NamedPermissionSets
public CodeGroup RootCodeGroup
public string StoreLocation
public PolicyLevelType Type
internal void .ctor(string label, PolicyLevelType type)
internal void LoadFromFile(string filename)
internal void LoadFromString(string xml)
private SecurityElement FromString(string xml)
public IList get_FullTrustAssemblies()
public string get_Label()
public IList get_NamedPermissionSets()
public CodeGroup get_RootCodeGroup()
public void set_RootCodeGroup(CodeGroup value)
public string get_StoreLocation()
public PolicyLevelType get_Type()
public void AddFullTrustAssembly(StrongName sn)
public void AddFullTrustAssembly(StrongNameMembershipCondition snMC)
public void AddNamedPermissionSet(NamedPermissionSet permSet)
public NamedPermissionSet ChangeNamedPermissionSet(string name, PermissionSet pSet)
public PolicyLevel CreateAppDomainLevel()
public void FromXml(SecurityElement e)
public NamedPermissionSet GetNamedPermissionSet(string name)
public void Recover()
public void RemoveFullTrustAssembly(StrongName sn)
public void RemoveFullTrustAssembly(StrongNameMembershipCondition snMC)
public NamedPermissionSet RemoveNamedPermissionSet(NamedPermissionSet permSet)
public NamedPermissionSet RemoveNamedPermissionSet(string name)
public void Reset()
public PolicyStatement Resolve(Evidence evidence)
public CodeGroup ResolveMatchingCodeGroups(Evidence evidence)
public SecurityElement ToXml()
internal void Save()
internal void CreateDefaultLevel(PolicyLevelType type)
internal void CreateDefaultFullTrustAssemblies()
internal void CreateDefaultNamedPermissionSets()
internal string ResolveClassName(string className)
internal bool IsFullTrustAssembly(Assembly a)
}
public System.Security.Policy.PolicyStatement : object {
private PermissionSet perms
private PolicyStatementAttribute attrs
public PermissionSet PermissionSet
public PolicyStatementAttribute Attributes
public string AttributeString
public void .ctor(PermissionSet permSet)
public void .ctor(PermissionSet permSet, PolicyStatementAttribute attributes)
public PermissionSet get_PermissionSet()
public void set_PermissionSet(PermissionSet value)
public PolicyStatementAttribute get_Attributes()
public void set_Attributes(PolicyStatementAttribute value)
public string get_AttributeString()
public PolicyStatement Copy()
public void FromXml(SecurityElement et)
public void FromXml(SecurityElement et, PolicyLevel level)
public SecurityElement ToXml()
public SecurityElement ToXml(PolicyLevel level)
public bool Equals(object obj)
public int GetHashCode()
internal PolicyStatement Empty()
}
public System.Security.Policy.PolicyStatementAttribute : Enum {
public int value__
public PolicyStatementAttribute Nothing
public PolicyStatementAttribute Exclusive
public PolicyStatementAttribute LevelFinal
public PolicyStatementAttribute All
}
public System.Security.Policy.Publisher : EvidenceBase {
private X509Certificate m_cert
public X509Certificate Certificate
public void .ctor(X509Certificate cert)
public X509Certificate get_Certificate()
public object Copy()
public IPermission CreateIdentityPermission(Evidence evidence)
public bool Equals(object o)
public int GetHashCode()
public string ToString()
private int System.Security.Policy.IBuiltInEvidence.GetRequiredSize(bool verbose)
private int System.Security.Policy.IBuiltInEvidence.InitFromBuffer(Char[] buffer, int position)
private int System.Security.Policy.IBuiltInEvidence.OutputToBuffer(Char[] buffer, int position, bool verbose)
}
public System.Security.Policy.PublisherMembershipCondition : object {
private int version
private X509Certificate x509
public X509Certificate Certificate
public void .ctor(X509Certificate certificate)
public X509Certificate get_Certificate()
public void set_Certificate(X509Certificate value)
public bool Check(Evidence evidence)
public IMembershipCondition Copy()
public bool Equals(object o)
public void FromXml(SecurityElement e)
public void FromXml(SecurityElement e, PolicyLevel level)
public int GetHashCode()
public string ToString()
public SecurityElement ToXml()
public SecurityElement ToXml(PolicyLevel level)
}
public System.Security.Policy.Site : EvidenceBase {
internal string origin_site
public string Name
public void .ctor(string name)
public Site CreateFromUrl(string url)
public object Copy()
public IPermission CreateIdentityPermission(Evidence evidence)
public bool Equals(object o)
public int GetHashCode()
public string ToString()
public string get_Name()
private int System.Security.Policy.IBuiltInEvidence.GetRequiredSize(bool verbose)
private int System.Security.Policy.IBuiltInEvidence.InitFromBuffer(Char[] buffer, int position)
private int System.Security.Policy.IBuiltInEvidence.OutputToBuffer(Char[] buffer, int position, bool verbose)
internal bool IsValid(string name)
internal string UrlToSite(string url)
}
public System.Security.Policy.SiteMembershipCondition : object {
private int version
private string _site
public string Site
public void .ctor(string site)
public string get_Site()
public void set_Site(string value)
public bool Check(Evidence evidence)
public IMembershipCondition Copy()
public bool Equals(object o)
public void FromXml(SecurityElement e)
public void FromXml(SecurityElement e, PolicyLevel level)
public int GetHashCode()
public string ToString()
public SecurityElement ToXml()
public SecurityElement ToXml(PolicyLevel level)
}
public System.Security.Policy.StrongName : EvidenceBase {
private StrongNamePublicKeyBlob publickey
private string name
private Version version
public string Name
public StrongNamePublicKeyBlob PublicKey
public Version Version
public void .ctor(StrongNamePublicKeyBlob blob, string name, Version version)
public string get_Name()
public StrongNamePublicKeyBlob get_PublicKey()
public Version get_Version()
public object Copy()
public IPermission CreateIdentityPermission(Evidence evidence)
public bool Equals(object o)
public int GetHashCode()
public string ToString()
private int System.Security.Policy.IBuiltInEvidence.GetRequiredSize(bool verbose)
private int System.Security.Policy.IBuiltInEvidence.InitFromBuffer(Char[] buffer, int position)
private int System.Security.Policy.IBuiltInEvidence.OutputToBuffer(Char[] buffer, int position, bool verbose)
}
public System.Security.Policy.StrongNameMembershipCondition : object {
private int version
private StrongNamePublicKeyBlob blob
private string name
private Version assemblyVersion
public string Name
public Version Version
public StrongNamePublicKeyBlob PublicKey
public void .ctor(StrongNamePublicKeyBlob blob, string name, Version version)
internal void .ctor(SecurityElement e)
public string get_Name()
public void set_Name(string value)
public Version get_Version()
public void set_Version(Version value)
public StrongNamePublicKeyBlob get_PublicKey()
public void set_PublicKey(StrongNamePublicKeyBlob value)
public bool Check(Evidence evidence)
public IMembershipCondition Copy()
public bool Equals(object o)
public int GetHashCode()
public void FromXml(SecurityElement e)
public void FromXml(SecurityElement e, PolicyLevel level)
public string ToString()
public SecurityElement ToXml()
public SecurityElement ToXml(PolicyLevel level)
}
public System.Security.Policy.TrustManagerContext : object {
private bool _ignorePersistedDecision
private bool _noPrompt
private bool _keepAlive
private bool _persist
private ApplicationIdentity _previousId
private TrustManagerUIContext _ui
public bool IgnorePersistedDecision
public bool KeepAlive
public bool NoPrompt
public bool Persist
public ApplicationIdentity PreviousApplicationIdentity
public TrustManagerUIContext UIContext
public void .ctor(TrustManagerUIContext uiContext)
public bool get_IgnorePersistedDecision()
public void set_IgnorePersistedDecision(bool value)
public bool get_KeepAlive()
public void set_KeepAlive(bool value)
public bool get_NoPrompt()
public void set_NoPrompt(bool value)
public bool get_Persist()
public void set_Persist(bool value)
public ApplicationIdentity get_PreviousApplicationIdentity()
public void set_PreviousApplicationIdentity(ApplicationIdentity value)
public TrustManagerUIContext get_UIContext()
public void set_UIContext(TrustManagerUIContext value)
}
public System.Security.Policy.TrustManagerUIContext : Enum {
public int value__
public TrustManagerUIContext Install
public TrustManagerUIContext Upgrade
public TrustManagerUIContext Run
}
public System.Security.Policy.UnionCodeGroup : CodeGroup {
public string MergeLogic
public void .ctor(IMembershipCondition membershipCondition, PolicyStatement policy)
internal void .ctor(SecurityElement e, PolicyLevel level)
public CodeGroup Copy()
internal CodeGroup Copy(bool childs)
public PolicyStatement Resolve(Evidence evidence)
public CodeGroup ResolveMatchingCodeGroups(Evidence evidence)
public string get_MergeLogic()
}
public System.Security.Policy.Url : EvidenceBase {
private string origin_url
public string Value
public void .ctor(string name)
internal void .ctor(string name, bool validated)
public object Copy()
public IPermission CreateIdentityPermission(Evidence evidence)
public bool Equals(object o)
public int GetHashCode()
public string ToString()
public string get_Value()
private int System.Security.Policy.IBuiltInEvidence.GetRequiredSize(bool verbose)
private int System.Security.Policy.IBuiltInEvidence.InitFromBuffer(Char[] buffer, int position)
private int System.Security.Policy.IBuiltInEvidence.OutputToBuffer(Char[] buffer, int position, bool verbose)
private string Prepare(string url)
}
public System.Security.Policy.UrlMembershipCondition : object {
private int version
private Url url
private string userUrl
public string Url
public void .ctor(string url)
internal void .ctor(Url url, string userUrl)
public string get_Url()
public void set_Url(string value)
public bool Check(Evidence evidence)
public IMembershipCondition Copy()
public bool Equals(object o)
public void FromXml(SecurityElement e)
public void FromXml(SecurityElement e, PolicyLevel level)
public int GetHashCode()
public string ToString()
public SecurityElement ToXml()
public SecurityElement ToXml(PolicyLevel level)
internal void CheckUrl(string url)
}
public System.Security.Policy.Zone : EvidenceBase {
private SecurityZone zone
public SecurityZone SecurityZone
public void .ctor(SecurityZone zone)
public SecurityZone get_SecurityZone()
public object Copy()
public IPermission CreateIdentityPermission(Evidence evidence)
public Zone CreateFromUrl(string url)
public bool Equals(object o)
public int GetHashCode()
public string ToString()
private int System.Security.Policy.IBuiltInEvidence.GetRequiredSize(bool verbose)
private int System.Security.Policy.IBuiltInEvidence.InitFromBuffer(Char[] buffer, int position)
private int System.Security.Policy.IBuiltInEvidence.OutputToBuffer(Char[] buffer, int position, bool verbose)
}
public System.Security.Policy.ZoneMembershipCondition : object {
private int version
private SecurityZone zone
public SecurityZone SecurityZone
public void .ctor(SecurityZone zone)
public SecurityZone get_SecurityZone()
public void set_SecurityZone(SecurityZone value)
public bool Check(Evidence evidence)
public IMembershipCondition Copy()
public bool Equals(object o)
public void FromXml(SecurityElement e)
public void FromXml(SecurityElement e, PolicyLevel level)
public int GetHashCode()
public string ToString()
public SecurityElement ToXml()
public SecurityElement ToXml(PolicyLevel level)
}
public System.Security.PolicyLevelType : Enum {
public int value__
public PolicyLevelType User
public PolicyLevelType Machine
public PolicyLevelType Enterprise
public PolicyLevelType AppDomain
}
public System.Security.Principal.GenericIdentity : ClaimsIdentity {
private string m_name
private string m_type
public IEnumerable`1<Claim> Claims
public string Name
public string AuthenticationType
public bool IsAuthenticated
public void .ctor(string name)
public void .ctor(string name, string type)
protected void .ctor(GenericIdentity identity)
public ClaimsIdentity Clone()
public IEnumerable`1<Claim> get_Claims()
public string get_Name()
public string get_AuthenticationType()
public bool get_IsAuthenticated()
private void OnDeserializedMethod(StreamingContext context)
private void AddNameClaim()
}
public System.Security.Principal.GenericPrincipal : ClaimsPrincipal {
private IIdentity m_identity
private String[] m_roles
internal String[] Roles
public IIdentity Identity
public void .ctor(IIdentity identity, String[] roles)
internal String[] get_Roles()
public IIdentity get_Identity()
public bool IsInRole(string role)
}
public System.Security.Principal.IdentityNotMappedException : SystemException {
private IdentityReferenceCollection _coll
public IdentityReferenceCollection UnmappedIdentities
public void .ctor(string message)
public void .ctor(string message, Exception inner)
public IdentityReferenceCollection get_UnmappedIdentities()
public void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext)
}
public System.Security.Principal.IdentityReference : object {
public string Value
public string get_Value()
public bool Equals(object o)
public int GetHashCode()
public bool IsValidTargetType(Type targetType)
public string ToString()
public IdentityReference Translate(Type targetType)
public bool op_Equality(IdentityReference left, IdentityReference right)
public bool op_Inequality(IdentityReference left, IdentityReference right)
}
public System.Security.Principal.IdentityReferenceCollection : object {
private ArrayList _list
public int Count
public bool IsReadOnly
public IdentityReference Item
public void .ctor(int capacity)
public int get_Count()
public bool get_IsReadOnly()
public IdentityReference get_Item(int index)
public void set_Item(int index, IdentityReference value)
public void Add(IdentityReference identity)
public void Clear()
public bool Contains(IdentityReference identity)
public void CopyTo(IdentityReference[] array, int offset)
public IEnumerator`1<IdentityReference> GetEnumerator()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
public bool Remove(IdentityReference identity)
public IdentityReferenceCollection Translate(Type targetType)
public IdentityReferenceCollection Translate(Type targetType, bool forceSuccess)
}
public System.Security.Principal.IIdentity {
public string AuthenticationType
public bool IsAuthenticated
public string Name
public string get_AuthenticationType()
public bool get_IsAuthenticated()
public string get_Name()
}
public System.Security.Principal.IPrincipal {
public IIdentity Identity
public IIdentity get_Identity()
public bool IsInRole(string role)
}
public System.Security.Principal.NTAccount : IdentityReference {
private string _value
public string Value
public void .ctor(string name)
public void .ctor(string domainName, string accountName)
public string get_Value()
public bool Equals(object o)
public int GetHashCode()
public bool IsValidTargetType(Type targetType)
public string ToString()
public IdentityReference Translate(Type targetType)
public bool op_Equality(NTAccount left, NTAccount right)
public bool op_Inequality(NTAccount left, NTAccount right)
}
public System.Security.Principal.PrincipalPolicy : Enum {
public int value__
public PrincipalPolicy UnauthenticatedPrincipal
public PrincipalPolicy NoPrincipal
public PrincipalPolicy WindowsPrincipal
}
public System.Security.Principal.SecurityIdentifier : IdentityReference {
private Byte[] buffer
public int MaxBinaryLength
public int MinBinaryLength
public SecurityIdentifier AccountDomainSid
public int BinaryLength
public string Value
public void .ctor(string sddlForm)
public void .ctor(Byte[] binaryForm, int offset)
public void .ctor(IntPtr binaryForm)
private void CreateFromBinaryForm(IntPtr binaryForm, int length)
public void .ctor(WellKnownSidType sidType, SecurityIdentifier domainSid)
public SecurityIdentifier get_AccountDomainSid()
public int get_BinaryLength()
public string get_Value()
private ulong GetSidAuthority()
private byte GetSidSubAuthorityCount()
private UInt32 GetSidSubAuthority(byte index)
public int CompareTo(SecurityIdentifier sid)
public bool Equals(object o)
public bool Equals(SecurityIdentifier sid)
public void GetBinaryForm(Byte[] binaryForm, int offset)
public int GetHashCode()
public bool IsAccountSid()
public bool IsEqualDomainSid(SecurityIdentifier sid)
public bool IsValidTargetType(Type targetType)
public bool IsWellKnown(WellKnownSidType type)
public string ToString()
public IdentityReference Translate(Type targetType)
public bool op_Equality(SecurityIdentifier left, SecurityIdentifier right)
public bool op_Inequality(SecurityIdentifier left, SecurityIdentifier right)
internal string GetSddlForm()
internal SecurityIdentifier ParseSddlForm(string sddlForm, Int32& pos)
private Byte[] ParseSddlForm(string sddlForm)
private bool TryParseAuthority(string s, UInt64& result)
private bool TryParseSubAuthority(string s, UInt32& result)
}
public System.Security.Principal.TokenAccessLevels : Enum {
public int value__
public TokenAccessLevels AssignPrimary
public TokenAccessLevels Duplicate
public TokenAccessLevels Impersonate
public TokenAccessLevels Query
public TokenAccessLevels QuerySource
public TokenAccessLevels AdjustPrivileges
public TokenAccessLevels AdjustGroups
public TokenAccessLevels AdjustDefault
public TokenAccessLevels AdjustSessionId
public TokenAccessLevels Read
public TokenAccessLevels Write
public TokenAccessLevels AllAccess
public TokenAccessLevels MaximumAllowed
}
public System.Security.Principal.TokenImpersonationLevel : Enum {
public int value__
public TokenImpersonationLevel Anonymous
public TokenImpersonationLevel Delegation
public TokenImpersonationLevel Identification
public TokenImpersonationLevel Impersonation
public TokenImpersonationLevel None
}
internal System.Security.Principal.WellKnownAccount : object {
private WellKnownSidType <WellKnownValue>k__BackingField
private bool <IsAbsolute>k__BackingField
private string <Sid>k__BackingField
private string <Rid>k__BackingField
private string <Name>k__BackingField
private string <SddlForm>k__BackingField
private WellKnownAccount[] accounts
public WellKnownSidType WellKnownValue
public bool IsAbsolute
public string Sid
public string Rid
public string Name
public string SddlForm
public WellKnownSidType get_WellKnownValue()
public void set_WellKnownValue(WellKnownSidType value)
public bool get_IsAbsolute()
public void set_IsAbsolute(bool value)
public string get_Sid()
public void set_Sid(string value)
public string get_Rid()
public void set_Rid(string value)
public string get_Name()
public void set_Name(string value)
public string get_SddlForm()
public void set_SddlForm(string value)
public WellKnownAccount LookupByType(WellKnownSidType sidType)
public WellKnownAccount LookupBySid(string s)
public WellKnownAccount LookupByName(string s)
public WellKnownAccount LookupBySddlForm(string s)
}
public System.Security.Principal.WellKnownSidType : Enum {
public int value__
public WellKnownSidType NullSid
public WellKnownSidType WorldSid
public WellKnownSidType LocalSid
public WellKnownSidType CreatorOwnerSid
public WellKnownSidType CreatorGroupSid
public WellKnownSidType CreatorOwnerServerSid
public WellKnownSidType CreatorGroupServerSid
public WellKnownSidType NTAuthoritySid
public WellKnownSidType DialupSid
public WellKnownSidType NetworkSid
public WellKnownSidType BatchSid
public WellKnownSidType InteractiveSid
public WellKnownSidType ServiceSid
public WellKnownSidType AnonymousSid
public WellKnownSidType ProxySid
public WellKnownSidType EnterpriseControllersSid
public WellKnownSidType SelfSid
public WellKnownSidType AuthenticatedUserSid
public WellKnownSidType RestrictedCodeSid
public WellKnownSidType TerminalServerSid
public WellKnownSidType RemoteLogonIdSid
public WellKnownSidType LogonIdsSid
public WellKnownSidType LocalSystemSid
public WellKnownSidType LocalServiceSid
public WellKnownSidType NetworkServiceSid
public WellKnownSidType BuiltinDomainSid
public WellKnownSidType BuiltinAdministratorsSid
public WellKnownSidType BuiltinUsersSid
public WellKnownSidType BuiltinGuestsSid
public WellKnownSidType BuiltinPowerUsersSid
public WellKnownSidType BuiltinAccountOperatorsSid
public WellKnownSidType BuiltinSystemOperatorsSid
public WellKnownSidType BuiltinPrintOperatorsSid
public WellKnownSidType BuiltinBackupOperatorsSid
public WellKnownSidType BuiltinReplicatorSid
public WellKnownSidType BuiltinPreWindows2000CompatibleAccessSid
public WellKnownSidType BuiltinRemoteDesktopUsersSid
public WellKnownSidType BuiltinNetworkConfigurationOperatorsSid
public WellKnownSidType AccountAdministratorSid
public WellKnownSidType AccountGuestSid
public WellKnownSidType AccountKrbtgtSid
public WellKnownSidType AccountDomainAdminsSid
public WellKnownSidType AccountDomainUsersSid
public WellKnownSidType AccountDomainGuestsSid
public WellKnownSidType AccountComputersSid
public WellKnownSidType AccountControllersSid
public WellKnownSidType AccountCertAdminsSid
public WellKnownSidType AccountSchemaAdminsSid
public WellKnownSidType AccountEnterpriseAdminsSid
public WellKnownSidType AccountPolicyAdminsSid
public WellKnownSidType AccountRasAndIasServersSid
public WellKnownSidType NtlmAuthenticationSid
public WellKnownSidType DigestAuthenticationSid
public WellKnownSidType SChannelAuthenticationSid
public WellKnownSidType ThisOrganizationSid
public WellKnownSidType OtherOrganizationSid
public WellKnownSidType BuiltinIncomingForestTrustBuildersSid
public WellKnownSidType BuiltinPerformanceMonitoringUsersSid
public WellKnownSidType BuiltinPerformanceLoggingUsersSid
public WellKnownSidType BuiltinAuthorizationAccessSid
public WellKnownSidType WinBuiltinTerminalServerLicenseServersSid
public WellKnownSidType MaxDefined
public WellKnownSidType WinBuiltinDCOMUsersSid
public WellKnownSidType WinBuiltinIUsersSid
public WellKnownSidType WinIUserSid
public WellKnownSidType WinBuiltinCryptoOperatorsSid
public WellKnownSidType WinUntrustedLabelSid
public WellKnownSidType WinLowLabelSid
public WellKnownSidType WinMediumLabelSid
public WellKnownSidType WinHighLabelSid
public WellKnownSidType WinSystemLabelSid
public WellKnownSidType WinWriteRestrictedCodeSid
public WellKnownSidType WinCreatorOwnerRightsSid
public WellKnownSidType WinCacheablePrincipalsGroupSid
public WellKnownSidType WinNonCacheablePrincipalsGroupSid
public WellKnownSidType WinEnterpriseReadonlyControllersSid
public WellKnownSidType WinAccountReadonlyControllersSid
public WellKnownSidType WinBuiltinEventLogReadersGroup
public WellKnownSidType WinNewEnterpriseReadonlyControllersSid
public WellKnownSidType WinBuiltinCertSvcDComAccessGroup
public WellKnownSidType WinMediumPlusLabelSid
public WellKnownSidType WinLocalLogonSid
public WellKnownSidType WinConsoleLogonSid
public WellKnownSidType WinThisOrganizationCertificateSid
public WellKnownSidType WinApplicationPackageAuthoritySid
public WellKnownSidType WinBuiltinAnyPackageSid
public WellKnownSidType WinCapabilityInternetClientSid
public WellKnownSidType WinCapabilityInternetClientServerSid
public WellKnownSidType WinCapabilityPrivateNetworkClientServerSid
public WellKnownSidType WinCapabilityPicturesLibrarySid
public WellKnownSidType WinCapabilityVideosLibrarySid
public WellKnownSidType WinCapabilityMusicLibrarySid
public WellKnownSidType WinCapabilityDocumentsLibrarySid
public WellKnownSidType WinCapabilitySharedUserCertificatesSid
public WellKnownSidType WinCapabilityEnterpriseAuthenticationSid
public WellKnownSidType WinCapabilityRemovableStorageSid
}
public System.Security.Principal.WindowsAccountType : Enum {
public int value__
public WindowsAccountType Normal
public WindowsAccountType Guest
public WindowsAccountType System
public WindowsAccountType Anonymous
}
public System.Security.Principal.WindowsBuiltInRole : Enum {
public int value__
public WindowsBuiltInRole Administrator
public WindowsBuiltInRole User
public WindowsBuiltInRole Guest
public WindowsBuiltInRole PowerUser
public WindowsBuiltInRole AccountOperator
public WindowsBuiltInRole SystemOperator
public WindowsBuiltInRole PrintOperator
public WindowsBuiltInRole BackupOperator
public WindowsBuiltInRole Replicator
}
public System.Security.Principal.WindowsIdentity : ClaimsIdentity {
private IntPtr _token
private string _type
private WindowsAccountType _account
private bool _authenticated
private string _name
private SerializationInfo _info
private IntPtr invalidWindows
public string DefaultIssuer
public string AuthenticationType
public bool IsAnonymous
public bool IsAuthenticated
public bool IsGuest
public bool IsSystem
public string Name
public IntPtr Token
public IdentityReferenceCollection Groups
public TokenImpersonationLevel ImpersonationLevel
public SecurityIdentifier Owner
public SecurityIdentifier User
public SafeAccessTokenHandle AccessToken
public IEnumerable`1<Claim> DeviceClaims
public IEnumerable`1<Claim> UserClaims
public void .ctor(IntPtr userToken)
public void .ctor(IntPtr userToken, string type)
public void .ctor(IntPtr userToken, string type, WindowsAccountType acctType)
public void .ctor(IntPtr userToken, string type, WindowsAccountType acctType, bool isAuthenticated)
public void .ctor(string sUserPrincipalName)
public void .ctor(string sUserPrincipalName, string type)
public void .ctor(SerializationInfo info, StreamingContext context)
internal void .ctor(ClaimsIdentity claimsIdentity, IntPtr userToken)
public void Dispose()
protected void Dispose(bool disposing)
public WindowsIdentity GetAnonymous()
public WindowsIdentity GetCurrent()
public WindowsIdentity GetCurrent(bool ifImpersonating)
public WindowsIdentity GetCurrent(TokenAccessLevels desiredAccess)
public WindowsImpersonationContext Impersonate()
public WindowsImpersonationContext Impersonate(IntPtr userToken)
public void RunImpersonated(SafeAccessTokenHandle safeAccessTokenHandle, Action action)
public T RunImpersonated(SafeAccessTokenHandle safeAccessTokenHandle, Func`1<T> func)
public string get_AuthenticationType()
public bool get_IsAnonymous()
public bool get_IsAuthenticated()
public bool get_IsGuest()
public bool get_IsSystem()
public string get_Name()
public IntPtr get_Token()
public IdentityReferenceCollection get_Groups()
public TokenImpersonationLevel get_ImpersonationLevel()
public SecurityIdentifier get_Owner()
public SecurityIdentifier get_User()
private void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender)
private void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context)
internal ClaimsIdentity CloneAsBase()
internal IntPtr GetTokenInternal()
private void SetToken(IntPtr token)
public SafeAccessTokenHandle get_AccessToken()
internal String[] _GetRoles(IntPtr token)
internal IntPtr GetCurrentToken()
private string GetTokenName(IntPtr token)
private IntPtr GetUserToken(string username)
public IEnumerable`1<Claim> get_DeviceClaims()
public IEnumerable`1<Claim> get_UserClaims()
}
public System.Security.Principal.WindowsImpersonationContext : object {
private IntPtr _token
private bool undo
internal void .ctor(IntPtr token)
public void Dispose()
protected void Dispose(bool disposing)
public void Undo()
private bool CloseToken(IntPtr token)
private IntPtr DuplicateToken(IntPtr token)
private bool SetCurrentToken(IntPtr token)
private bool RevertToSelf()
}
public System.Security.Principal.WindowsPrincipal : ClaimsPrincipal {
private WindowsIdentity _identity
private String[] m_roles
public IIdentity Identity
private IntPtr Token
public IEnumerable`1<Claim> DeviceClaims
public IEnumerable`1<Claim> UserClaims
public void .ctor(WindowsIdentity ntIdentity)
public IIdentity get_Identity()
public bool IsInRole(int rid)
public bool IsInRole(string role)
public bool IsInRole(WindowsBuiltInRole role)
public bool IsInRole(SecurityIdentifier sid)
private IntPtr get_Token()
private bool IsMemberOfGroupId(IntPtr user, IntPtr group)
private bool IsMemberOfGroupName(IntPtr user, string group)
public IEnumerable`1<Claim> get_DeviceClaims()
public IEnumerable`1<Claim> get_UserClaims()
}
public System.Security.ReadOnlyPermissionSet : PermissionSet {
public void .ctor(SecurityElement permissionSetXml)
protected IPermission AddPermissionImpl(IPermission perm)
protected IEnumerator GetEnumeratorImpl()
protected IPermission GetPermissionImpl(Type permClass)
protected IPermission RemovePermissionImpl(Type permClass)
protected IPermission SetPermissionImpl(IPermission perm)
}
internal System.Security.RuntimeDeclSecurityActions : ValueType {
public RuntimeDeclSecurityEntry cas
public RuntimeDeclSecurityEntry noncas
public RuntimeDeclSecurityEntry choice
}
internal System.Security.RuntimeDeclSecurityEntry : ValueType {
public IntPtr blob
public int size
public int index
}
public System.Security.SecureString : object {
private int BlockSize
private int MaxSize
private int length
private bool disposed
private bool read_only
private Byte[] data
public int Length
public void .ctor(Char* value, int length)
public int get_Length()
public void AppendChar(char c)
public void Clear()
public SecureString Copy()
public void Dispose()
public void InsertAt(int index, char c)
public bool IsReadOnly()
public void MakeReadOnly()
public void RemoveAt(int index)
public void SetAt(int index, char c)
private void Encrypt()
private void Decrypt()
private void Alloc(int length, bool realloc)
internal Byte[] GetBuffer()
}
public System.Security.SecurityContext : object {
public SecurityContext CreateCopy()
public SecurityContext Capture()
public void Dispose()
public bool IsFlowSuppressed()
public bool IsWindowsIdentityFlowSuppressed()
public void RestoreFlow()
public void Run(SecurityContext securityContext, ContextCallback callback, object state)
public AsyncFlowControl SuppressFlow()
public AsyncFlowControl SuppressFlowWindowsIdentity()
}
internal System.Security.SecurityContextDisableFlow : Enum {
public int value__
public SecurityContextDisableFlow Nothing
public SecurityContextDisableFlow WI
public SecurityContextDisableFlow All
}
public System.Security.SecurityContextSource : Enum {
public int value__
public SecurityContextSource CurrentAppDomain
public SecurityContextSource CurrentAssembly
}
public System.Security.SecurityCriticalAttribute : Attribute {
private SecurityCriticalScope _val
public SecurityCriticalScope Scope
public void .ctor(SecurityCriticalScope scope)
public SecurityCriticalScope get_Scope()
}
public System.Security.SecurityCriticalScope : Enum {
public int value__
public SecurityCriticalScope Explicit
public SecurityCriticalScope Everything
}
internal System.Security.SecurityDocument : object {
internal Byte[] m_data
internal byte c_element
internal byte c_attribute
internal byte c_text
internal byte c_children
internal int c_growthSize
public void .ctor(int numData)
public void .ctor(Byte[] data)
public void .ctor(SecurityElement elRoot)
public void GuaranteeSize(int size)
public void AddString(string str, Int32& position)
public void AppendString(string str, Int32& position)
public int EncodedStringSize(string str)
public string GetString(Int32& position)
public string GetString(Int32& position, bool bCreate)
public void AddToken(byte b, Int32& position)
public void ConvertElement(SecurityElement elCurrent, Int32& position)
public SecurityElement GetRootElement()
public SecurityElement GetElement(int position, bool bCreate)
internal SecurityElement InternalGetElement(Int32& position, bool bCreate)
public string GetTagForElement(int position)
public ArrayList GetChildrenPositionForElement(int position)
public string GetAttributeForElement(int position, string attributeName)
}
public System.Security.SecurityElement : object {
private string text
private string tag
private ArrayList attributes
private ArrayList children
private Char[] invalid_tag_chars
private Char[] invalid_text_chars
private Char[] invalid_attr_name_chars
private Char[] invalid_attr_value_chars
private Char[] invalid_chars
public Hashtable Attributes
public ArrayList Children
public string Tag
public string Text
internal string m_strTag
internal string m_strText
internal ArrayList m_lAttributes
internal ArrayList InternalChildren
public void .ctor(string tag)
public void .ctor(string tag, string text)
internal void .ctor(SecurityElement se)
public Hashtable get_Attributes()
public void set_Attributes(Hashtable value)
public ArrayList get_Children()
public void set_Children(ArrayList value)
public string get_Tag()
public void set_Tag(string value)
public string get_Text()
public void set_Text(string value)
public void AddAttribute(string name, string value)
public void AddChild(SecurityElement child)
public string Attribute(string name)
public SecurityElement Copy()
public bool Equal(SecurityElement other)
public string Escape(string str)
private string Unescape(string str)
public SecurityElement FromString(string xml)
public bool IsValidAttributeName(string name)
public bool IsValidAttributeValue(string value)
public bool IsValidTag(string tag)
public bool IsValidText(string text)
public SecurityElement SearchForChildByTag(string tag)
public string SearchForTextOfTag(string tag)
public string ToString()
private void ToXml(StringBuilder& s, int level)
internal SecurityAttribute GetAttribute(string name)
internal string get_m_strTag()
internal string get_m_strText()
internal void set_m_strText(string value)
internal ArrayList get_m_lAttributes()
internal ArrayList get_InternalChildren()
internal string SearchForTextOfLocalName(string strLocalName)
}
internal System.Security.SecurityElementType : Enum {
public int value__
public SecurityElementType Regular
public SecurityElementType Format
public SecurityElementType Comment
}
public System.Security.SecurityException : SystemException {
private string permissionState
private Type permissionType
private string _granted
private string _refused
private object _demanded
private IPermission _firstperm
private MethodInfo _method
private Evidence _evidence
private SecurityAction _action
private object _denyset
private object _permitset
private AssemblyName _assembly
private string _url
private SecurityZone _zone
public SecurityAction Action
public object DenySetInstance
public AssemblyName FailedAssemblyInfo
public MethodInfo Method
public object PermitOnlySetInstance
public string Url
public SecurityZone Zone
public object Demanded
public IPermission FirstPermissionThatFailed
public string PermissionState
public Type PermissionType
public string GrantedSet
public string RefusedSet
public SecurityAction get_Action()
public void set_Action(SecurityAction value)
public object get_DenySetInstance()
public void set_DenySetInstance(object value)
public AssemblyName get_FailedAssemblyInfo()
public void set_FailedAssemblyInfo(AssemblyName value)
public MethodInfo get_Method()
public void set_Method(MethodInfo value)
public object get_PermitOnlySetInstance()
public void set_PermitOnlySetInstance(object value)
public string get_Url()
public void set_Url(string value)
public SecurityZone get_Zone()
public void set_Zone(SecurityZone value)
public object get_Demanded()
public void set_Demanded(object value)
public IPermission get_FirstPermissionThatFailed()
public void set_FirstPermissionThatFailed(IPermission value)
public string get_PermissionState()
public void set_PermissionState(string value)
public Type get_PermissionType()
public void set_PermissionType(Type value)
public string get_GrantedSet()
public void set_GrantedSet(string value)
public string get_RefusedSet()
public void set_RefusedSet(string value)
public void .ctor(string message)
protected void .ctor(SerializationInfo info, StreamingContext context)
public void .ctor(string message, Exception inner)
public void .ctor(string message, Type type)
public void .ctor(string message, Type type, string state)
internal void .ctor(string message, PermissionSet granted, PermissionSet refused)
public void .ctor(string message, object deny, object permitOnly, MethodInfo method, object demanded, IPermission permThatFailed)
public void .ctor(string message, AssemblyName assemblyName, PermissionSet grant, PermissionSet refused, MethodInfo method, SecurityAction action, object demanded, IPermission permThatFailed, Evidence evidence)
public void GetObjectData(SerializationInfo info, StreamingContext context)
public string ToString()
}
public System.Security.SecurityManager : object {
private object _lockObject
private ArrayList _hierarchy
private IPermission _unmanagedCode
private Hashtable _declsecCache
private PolicyLevel _level
private SecurityPermission _execution
public bool CheckExecutionRights
public bool SecurityEnabled
private IEnumerator Hierarchy
internal PolicyLevel ResolvingPolicyLevel
private IPermission UnmanagedCode
public bool get_CheckExecutionRights()
public void set_CheckExecutionRights(bool value)
public bool get_SecurityEnabled()
public void set_SecurityEnabled(bool value)
internal bool CheckElevatedPermissions()
internal void EnsureElevatedPermissions()
public void GetZoneAndOrigin(ArrayList& zone, ArrayList& origin)
public bool IsGranted(IPermission perm)
internal bool IsGranted(Assembly a, IPermission perm)
public PolicyLevel LoadPolicyLevelFromFile(string path, PolicyLevelType type)
public PolicyLevel LoadPolicyLevelFromString(string str, PolicyLevelType type)
public IEnumerator PolicyHierarchy()
public PermissionSet ResolvePolicy(Evidence evidence)
public PermissionSet ResolvePolicy(Evidence[] evidences)
public PermissionSet ResolveSystemPolicy(Evidence evidence)
public PermissionSet ResolvePolicy(Evidence evidence, PermissionSet reqdPset, PermissionSet optPset, PermissionSet denyPset, PermissionSet& denied)
public IEnumerator ResolvePolicyGroups(Evidence evidence)
public void SavePolicy()
public void SavePolicyLevel(PolicyLevel level)
private IEnumerator get_Hierarchy()
private void InitializePolicyHierarchy()
internal bool ResolvePolicyLevel(PermissionSet& ps, PolicyLevel pl, Evidence evidence)
internal void ResolveIdentityPermissions(PermissionSet ps, Evidence evidence)
internal PolicyLevel get_ResolvingPolicyLevel()
internal void set_ResolvingPolicyLevel(PolicyLevel value)
internal PermissionSet Decode(IntPtr permissions, int length)
internal PermissionSet Decode(Byte[] encodedPermissions)
private IPermission get_UnmanagedCode()
private void ThrowException(Exception ex)
public PermissionSet GetStandardSandbox(Evidence evidence)
public bool CurrentThreadRequiresSecurityContextCapture()
}
public System.Security.SecurityRulesAttribute : Attribute {
private SecurityRuleSet m_ruleSet
private bool m_skipVerificationInFullTrust
public bool SkipVerificationInFullTrust
public SecurityRuleSet RuleSet
public void .ctor(SecurityRuleSet ruleSet)
public bool get_SkipVerificationInFullTrust()
public void set_SkipVerificationInFullTrust(bool value)
public SecurityRuleSet get_RuleSet()
}
public System.Security.SecurityRuleSet : Enum {
public byte value__
public SecurityRuleSet None
public SecurityRuleSet Level1
public SecurityRuleSet Level2
}
public System.Security.SecurityState : object {
public void EnsureState()
public bool IsStateAvailable()
}
public System.Security.SecurityZone : Enum {
public int value__
public SecurityZone MyComputer
public SecurityZone Intranet
public SecurityZone Trusted
public SecurityZone Internet
public SecurityZone Untrusted
public SecurityZone NoZone
}
internal System.Security.Util.Hex : object {
private char HexDigit(int num)
public string EncodeHexString(Byte[] sArray)
internal string EncodeHexStringFromInt(Byte[] sArray)
public int ConvertHexDigit(char val)
public Byte[] DecodeHexString(string hexString)
}
internal System.Security.Util.Parser : object {
private SecurityDocument _doc
private Tokenizer _t
private short c_flag
private short c_elementtag
private short c_attributetag
private short c_texttag
private short c_additionaltexttag
private short c_childrentag
private short c_wastedstringtag
internal SecurityElement GetTopElement()
private void GetRequiredSizes(TokenizerStream stream, Int32& index)
private int DetermineFormat(TokenizerStream stream)
private void ParseContents()
private void .ctor(Tokenizer t)
internal void .ctor(string input)
internal void .ctor(string input, String[] searchStrings, String[] replaceStrings)
internal void .ctor(Byte[] array, ByteTokenEncoding encoding)
internal void .ctor(Byte[] array, ByteTokenEncoding encoding, int startIndex)
internal void .ctor(StreamReader input)
internal void .ctor(Char[] array)
}
internal System.Security.Util.Tokenizer : object {
internal byte bra
internal byte ket
internal byte slash
internal byte cstr
internal byte equals
internal byte quest
internal byte bang
internal byte dash
internal int intOpenBracket
internal int intCloseBracket
internal int intSlash
internal int intEquals
internal int intQuote
internal int intQuest
internal int intBang
internal int intDash
internal int intTab
internal int intCR
internal int intLF
internal int intSpace
public int LineNo
private int _inProcessingTag
private Byte[] _inBytes
private Char[] _inChars
private string _inString
private int _inIndex
private int _inSize
private int _inSavedCharacter
private TokenSource _inTokenSource
private ITokenReader _inTokenReader
private StringMaker _maker
private String[] _searchStrings
private String[] _replaceStrings
private int _inNestedIndex
private int _inNestedSize
private string _inNestedString
internal void BasicInitialization()
public void Recycle()
internal void .ctor(string input)
internal void .ctor(string input, String[] searchStrings, String[] replaceStrings)
internal void .ctor(Byte[] array, ByteTokenEncoding encoding, int startIndex)
internal void .ctor(Char[] array)
internal void .ctor(StreamReader input)
internal void ChangeFormat(Encoding encoding)
internal void GetTokens(TokenizerStream stream, int maxNum, bool endAfterKet)
private string GetStringToken()
}
internal System.Security.Util.TokenizerShortBlock : object {
internal Int16[] m_block
internal TokenizerShortBlock m_next
}
internal System.Security.Util.TokenizerStream : object {
private int m_countTokens
private TokenizerShortBlock m_headTokens
private TokenizerShortBlock m_lastTokens
private TokenizerShortBlock m_currentTokens
private int m_indexTokens
private TokenizerStringBlock m_headStrings
private TokenizerStringBlock m_currentStrings
private int m_indexStrings
internal void AddToken(short token)
internal void AddString(string str)
internal void Reset()
internal short GetNextFullToken()
internal short GetNextToken()
internal string GetNextString()
internal void ThrowAwayNextString()
internal void TagLastToken(short tag)
internal int GetTokenCount()
internal void GoToPosition(int position)
}
internal System.Security.Util.TokenizerStringBlock : object {
internal String[] m_block
internal TokenizerStringBlock m_next
}
public System.Security.VerificationException : SystemException {
public void .ctor(string message)
protected void .ctor(SerializationInfo info, StreamingContext context)
public void .ctor(string message, Exception innerException)
}
public System.Security.XmlSyntaxException : SystemException {
public void .ctor(int lineNumber)
public void .ctor(int lineNumber, string message)
public void .ctor(string message)
public void .ctor(string message, Exception inner)
internal void .ctor(SerializationInfo info, StreamingContext context)
}
public System.SerializableAttribute : Attribute {
internal Attribute GetCustomAttribute(RuntimeType type)
internal bool IsDefined(RuntimeType type)
}
internal System.SharedStatics : object {
private SharedStatics _sharedStatics
private String modreq(System.Runtime.CompilerServices.IsVolatile) _Remoting_Identity_IDGuid
private StringMaker _maker
private int _Remoting_Identity_IDSeqNum
private long _memFailPointReservedMemory
public string Remoting_Identity_IDGuid
internal ulong MemoryFailPointReservedMemory
public string get_Remoting_Identity_IDGuid()
public StringMaker GetSharedStringMaker()
public void ReleaseSharedStringMaker(StringMaker& maker)
internal int Remoting_Identity_GetNextSeqNum()
internal long AddMemoryFailPointReservation(long size)
internal ulong get_MemoryFailPointReservedMemory()
}
public System.Single : ValueType {
internal float m_value
public float MinValue
public float Epsilon
public float MaxValue
public float PositiveInfinity
public float NegativeInfinity
public float NaN
public bool IsInfinity(float f)
public bool IsPositiveInfinity(float f)
public bool IsNegativeInfinity(float f)
public bool IsNaN(float f)
public bool IsFinite(float f)
public int CompareTo(object value)
public int CompareTo(float value)
public bool op_Equality(float left, float right)
public bool op_Inequality(float left, float right)
public bool op_LessThan(float left, float right)
public bool op_GreaterThan(float left, float right)
public bool op_LessThanOrEqual(float left, float right)
public bool op_GreaterThanOrEqual(float left, float right)
public bool Equals(object obj)
public bool Equals(float obj)
public int GetHashCode()
public string ToString()
public string ToString(IFormatProvider provider)
public string ToString(string format)
public string ToString(string format, IFormatProvider provider)
public float Parse(string s)
public float Parse(string s, NumberStyles style)
public float Parse(string s, IFormatProvider provider)
public float Parse(string s, NumberStyles style, IFormatProvider provider)
private float Parse(string s, NumberStyles style, NumberFormatInfo info)
public bool TryParse(string s, Single& result)
public bool TryParse(string s, NumberStyles style, IFormatProvider provider, Single& result)
private bool TryParse(string s, NumberStyles style, NumberFormatInfo info, Single& result)
public TypeCode GetTypeCode()
private bool System.IConvertible.ToBoolean(IFormatProvider provider)
private char System.IConvertible.ToChar(IFormatProvider provider)
private sbyte System.IConvertible.ToSByte(IFormatProvider provider)
private byte System.IConvertible.ToByte(IFormatProvider provider)
private short System.IConvertible.ToInt16(IFormatProvider provider)
private ushort System.IConvertible.ToUInt16(IFormatProvider provider)
private int System.IConvertible.ToInt32(IFormatProvider provider)
private UInt32 System.IConvertible.ToUInt32(IFormatProvider provider)
private long System.IConvertible.ToInt64(IFormatProvider provider)
private ulong System.IConvertible.ToUInt64(IFormatProvider provider)
private float System.IConvertible.ToSingle(IFormatProvider provider)
private double System.IConvertible.ToDouble(IFormatProvider provider)
private decimal System.IConvertible.ToDecimal(IFormatProvider provider)
private DateTime System.IConvertible.ToDateTime(IFormatProvider provider)
private object System.IConvertible.ToType(Type type, IFormatProvider provider)
}
internal System.SizedReference : object {
internal IntPtr modreq(System.Runtime.CompilerServices.IsVolatile) _handle
public object Target
public long ApproximateSize
private IntPtr CreateSizedRef(object o)
private void FreeSizedRef(IntPtr h)
private object GetTargetOfSizedRef(IntPtr h)
private long GetApproximateSizeOfSizedRef(IntPtr h)
private void Free()
public void .ctor(object target)
protected void Finalize()
public object get_Target()
public long get_ApproximateSize()
public void Dispose()
}
internal System.SmallRect : ValueType {
public short Left
public short Top
public short Right
public short Bottom
public void .ctor(int left, int top, int right, int bottom)
}
public System.Span`1 : ValueType {
private Pinnable`1<T> _pinnable
private IntPtr _byteOffset
private int _length
private string DebuggerDisplay
public int Length
public bool IsEmpty
public T& Item
public Span`1<T> Empty
internal Pinnable`1<T> Pinnable
internal IntPtr ByteOffset
public void .ctor(T[] array)
public void .ctor(T[] array, int start, int length)
public void .ctor(Void* pointer, int length)
public Span`1<T> DangerousCreate(object obj, T& objectData, int length)
internal void .ctor(Pinnable`1<T> pinnable, IntPtr byteOffset, int length)
private string get_DebuggerDisplay()
public int get_Length()
public bool get_IsEmpty()
public T& get_Item(int index)
public void Clear()
public void Fill(T value)
public void CopyTo(Span`1<T> destination)
public bool TryCopyTo(Span`1<T> destination)
public bool op_Equality(Span`1<T> left, Span`1<T> right)
public bool op_Inequality(Span`1<T> left, Span`1<T> right)
public bool Equals(object obj)
public int GetHashCode()
public Span`1<T> op_Implicit(T[] array)
public Span`1<T> op_Implicit(ArraySegment`1<T> arraySegment)
public ReadOnlySpan`1<T> op_Implicit(Span`1<T> span)
public Span`1<T> Slice(int start)
public Span`1<T> Slice(int start, int length)
public T[] ToArray()
public Span`1<T> get_Empty()
public T& DangerousGetPinnableReference()
internal Pinnable`1<T> get_Pinnable()
internal IntPtr get_ByteOffset()
}
internal System.SpanDebugView`1 : object {
private T[] _pinnable
private IntPtr _byteOffset
private int _length
public T[] Items
public void .ctor(Span`1<T> collection)
public void .ctor(ReadOnlySpan`1<T> collection)
public T[] get_Items()
}
public System.SpanExtensions : object {
private IntPtr StringAdjustment
public Span`1<byte> AsBytes(Span`1<T> source)
public ReadOnlySpan`1<byte> AsBytes(ReadOnlySpan`1<T> source)
public ReadOnlySpan`1<char> AsReadOnlySpan(string text)
public Span`1<TTo> NonPortableCast(Span`1<TFrom> source)
public ReadOnlySpan`1<TTo> NonPortableCast(ReadOnlySpan`1<TFrom> source)
private IntPtr MeasureStringAdjustment()
public int IndexOf(Span`1<T> span, T value)
public int IndexOf(Span`1<byte> span, byte value)
public int IndexOf(Span`1<T> span, ReadOnlySpan`1<T> value)
public int IndexOf(Span`1<byte> span, ReadOnlySpan`1<byte> value)
public bool SequenceEqual(Span`1<T> first, ReadOnlySpan`1<T> second)
public bool SequenceEqual(Span`1<byte> first, ReadOnlySpan`1<byte> second)
public int IndexOf(ReadOnlySpan`1<T> span, T value)
public int IndexOf(ReadOnlySpan`1<byte> span, byte value)
public int IndexOf(ReadOnlySpan`1<T> span, ReadOnlySpan`1<T> value)
public int IndexOf(ReadOnlySpan`1<byte> span, ReadOnlySpan`1<byte> value)
public int IndexOfAny(Span`1<byte> span, byte value0, byte value1)
public int IndexOfAny(Span`1<byte> span, byte value0, byte value1, byte value2)
public int IndexOfAny(Span`1<byte> span, ReadOnlySpan`1<byte> values)
public int IndexOfAny(ReadOnlySpan`1<byte> span, byte value0, byte value1)
public int IndexOfAny(ReadOnlySpan`1<byte> span, byte value0, byte value1, byte value2)
public int IndexOfAny(ReadOnlySpan`1<byte> span, ReadOnlySpan`1<byte> values)
public bool SequenceEqual(ReadOnlySpan`1<T> first, ReadOnlySpan`1<T> second)
public bool SequenceEqual(ReadOnlySpan`1<byte> first, ReadOnlySpan`1<byte> second)
public bool StartsWith(Span`1<byte> span, ReadOnlySpan`1<byte> value)
public bool StartsWith(Span`1<T> span, ReadOnlySpan`1<T> value)
public bool StartsWith(ReadOnlySpan`1<byte> span, ReadOnlySpan`1<byte> value)
public bool StartsWith(ReadOnlySpan`1<T> span, ReadOnlySpan`1<T> value)
public Span`1<T> AsSpan(T[] array)
public Span`1<T> AsSpan(ArraySegment`1<T> arraySegment)
public ReadOnlySpan`1<T> AsReadOnlySpan(T[] array)
public ReadOnlySpan`1<T> AsReadOnlySpan(ArraySegment`1<T> arraySegment)
public void CopyTo(T[] array, Span`1<T> destination)
}
internal System.SpanHelpers : object {
public void ClearLessThanPointerSized(Byte* ptr, UIntPtr byteLength)
public void ClearLessThanPointerSized(Byte& b, UIntPtr byteLength)
public void ClearPointerSizedWithoutReferences(Byte& b, UIntPtr byteLength)
public void ClearPointerSizedWithReferences(IntPtr& ip, UIntPtr pointerSizeLength)
private bool LessThanEqual(IntPtr index, UIntPtr length)
public int IndexOf(T& searchSpace, int searchSpaceLength, T& value, int valueLength)
public int IndexOf(T& searchSpace, T value, int length)
public bool SequenceEqual(T& first, T& second, int length)
public int IndexOf(Byte& searchSpace, int searchSpaceLength, Byte& value, int valueLength)
public int IndexOfAny(Byte& searchSpace, int searchSpaceLength, Byte& value, int valueLength)
public int IndexOf(Byte& searchSpace, byte value, int length)
public int IndexOfAny(Byte& searchSpace, byte value0, byte value1, int length)
public int IndexOfAny(Byte& searchSpace, byte value0, byte value1, byte value2, int length)
public bool SequenceEqual(Byte& first, Byte& second, int length)
public void CopyTo(T& dst, int dstLength, T& src, int srcLength)
public IntPtr Add(IntPtr start, int index)
public bool IsReferenceOrContainsReferences()
private bool IsReferenceOrContainsReferencesCore(Type type)
}
public System.StackOverflowException : SystemException {
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
internal void .ctor(SerializationInfo info, StreamingContext context)
}
public System.String : object {
private int m_stringLength
private char m_firstChar
private int TrimHead
private int TrimTail
private int TrimBoth
public string Empty
private int charPtrAlignConst
private int alignConst
internal char FirstChar
public char Chars
public int Length
public string Join(string separator, String[] value)
public string Join(string separator, Object[] values)
public string Join(string separator, IEnumerable`1<T> values)
public string Join(string separator, IEnumerable`1<string> values)
internal char get_FirstChar()
public string Join(string separator, String[] value, int startIndex, int count)
private int CompareOrdinalIgnoreCaseHelper(string strA, string strB)
internal string SmallCharToUpper(string strIn)
private bool EqualsHelper(string strA, string strB)
private int CompareOrdinalHelper(string strA, string strB)
public bool Equals(object obj)
public bool Equals(string value)
public bool Equals(string value, StringComparison comparisonType)
public bool Equals(string a, string b)
public bool Equals(string a, string b, StringComparison comparisonType)
public bool op_Equality(string a, string b)
public bool op_Inequality(string a, string b)
public char get_Chars(int index)
public void CopyTo(int sourceIndex, Char[] destination, int destinationIndex, int count)
public Char[] ToCharArray()
public Char[] ToCharArray(int startIndex, int length)
public bool IsNullOrEmpty(string value)
public bool IsNullOrWhiteSpace(string value)
public int GetHashCode()
internal int GetLegacyNonRandomizedHashCode()
public String[] Split(Char[] separator)
public String[] Split(Char[] separator, int count)
public String[] Split(Char[] separator, StringSplitOptions options)
public String[] Split(Char[] separator, int count, StringSplitOptions options)
internal String[] SplitInternal(Char[] separator, int count, StringSplitOptions options)
public String[] Split(String[] separator, StringSplitOptions options)
public String[] Split(String[] separator, int count, StringSplitOptions options)
private String[] InternalSplitKeepEmptyEntries(Int32[] sepList, Int32[] lengthList, int numReplaces, int count)
private String[] InternalSplitOmitEmptyEntries(Int32[] sepList, Int32[] lengthList, int numReplaces, int count)
private int MakeSeparatorList(Char[] separator, Int32[]& sepList)
private int MakeSeparatorList(String[] separators, Int32[]& sepList, Int32[]& lengthList)
public string Substring(int startIndex)
public string Substring(int startIndex, int length)
private string InternalSubString(int startIndex, int length)
public string Trim(Char[] trimChars)
public string TrimStart(Char[] trimChars)
public string TrimEnd(Char[] trimChars)
public void .ctor(Char* value)
public void .ctor(Char* value, int startIndex, int length)
public void .ctor(SByte* value)
public void .ctor(SByte* value, int startIndex, int length)
public void .ctor(SByte* value, int startIndex, int length, Encoding enc)
internal string CreateStringFromEncoding(Byte* bytes, int byteLength, Encoding encoding)
internal int GetBytesFromEncoding(Byte* pbNativeBuffer, int cbNativeBuffer, Encoding encoding)
public bool IsNormalized()
public bool IsNormalized(NormalizationForm normalizationForm)
public string Normalize()
public string Normalize(NormalizationForm normalizationForm)
internal string FastAllocateString(int length)
private void FillStringChecked(string dest, int destPos, string src)
public void .ctor(Char[] value, int startIndex, int length)
public void .ctor(Char[] value)
internal void wstrcpy(Char* dmem, Char* smem, int charCount)
private string CtorCharArray(Char[] value)
private string CtorCharArrayStartLength(Char[] value, int startIndex, int length)
private string CtorCharCount(char c, int count)
private int wcslen(Char* ptr)
private string CtorCharPtr(Char* ptr)
private string CtorCharPtrStartLength(Char* ptr, int startIndex, int length)
public void .ctor(char c, int count)
public int Compare(string strA, string strB)
public int Compare(string strA, string strB, bool ignoreCase)
public int Compare(string strA, string strB, StringComparison comparisonType)
public int Compare(string strA, string strB, CultureInfo culture, CompareOptions options)
public int Compare(string strA, string strB, bool ignoreCase, CultureInfo culture)
public int Compare(string strA, int indexA, string strB, int indexB, int length)
public int Compare(string strA, int indexA, string strB, int indexB, int length, bool ignoreCase)
public int Compare(string strA, int indexA, string strB, int indexB, int length, bool ignoreCase, CultureInfo culture)
public int Compare(string strA, int indexA, string strB, int indexB, int length, CultureInfo culture, CompareOptions options)
public int Compare(string strA, int indexA, string strB, int indexB, int length, StringComparison comparisonType)
public int CompareTo(object value)
public int CompareTo(string strB)
public int CompareOrdinal(string strA, string strB)
public int CompareOrdinal(string strA, int indexA, string strB, int indexB, int length)
public bool Contains(string value)
public bool EndsWith(string value)
public bool EndsWith(string value, StringComparison comparisonType)
public bool EndsWith(string value, bool ignoreCase, CultureInfo culture)
internal bool EndsWith(char value)
public int IndexOf(char value)
public int IndexOf(char value, int startIndex)
public int IndexOfAny(Char[] anyOf)
public int IndexOfAny(Char[] anyOf, int startIndex)
public int IndexOf(string value)
public int IndexOf(string value, int startIndex)
public int IndexOf(string value, int startIndex, int count)
public int IndexOf(string value, StringComparison comparisonType)
public int IndexOf(string value, int startIndex, StringComparison comparisonType)
public int IndexOf(string value, int startIndex, int count, StringComparison comparisonType)
public int LastIndexOf(char value)
public int LastIndexOf(char value, int startIndex)
public int LastIndexOfAny(Char[] anyOf)
public int LastIndexOfAny(Char[] anyOf, int startIndex)
public int LastIndexOf(string value)
public int LastIndexOf(string value, int startIndex)
public int LastIndexOf(string value, int startIndex, int count)
public int LastIndexOf(string value, StringComparison comparisonType)
public int LastIndexOf(string value, int startIndex, StringComparison comparisonType)
public int LastIndexOf(string value, int startIndex, int count, StringComparison comparisonType)
public string PadLeft(int totalWidth)
public string PadLeft(int totalWidth, char paddingChar)
public string PadRight(int totalWidth)
public string PadRight(int totalWidth, char paddingChar)
public bool StartsWith(string value)
public bool StartsWith(string value, StringComparison comparisonType)
public bool StartsWith(string value, bool ignoreCase, CultureInfo culture)
public string ToLower()
public string ToLower(CultureInfo culture)
public string ToLowerInvariant()
public string ToUpper()
public string ToUpper(CultureInfo culture)
public string ToUpperInvariant()
public string ToString()
public string ToString(IFormatProvider provider)
public object Clone()
private bool IsBOMWhitespace(char c)
public string Trim()
private string TrimHelper(int trimType)
private string TrimHelper(Char[] trimChars, int trimType)
private string CreateTrimmedString(int start, int end)
public string Insert(int startIndex, string value)
public string Replace(char oldChar, char newChar)
public string Replace(string oldValue, string newValue)
public string Remove(int startIndex, int count)
public string Remove(int startIndex)
public string Format(string format, object arg0)
public string Format(string format, object arg0, object arg1)
public string Format(string format, object arg0, object arg1, object arg2)
public string Format(string format, Object[] args)
public string Format(IFormatProvider provider, string format, object arg0)
public string Format(IFormatProvider provider, string format, object arg0, object arg1)
public string Format(IFormatProvider provider, string format, object arg0, object arg1, object arg2)
public string Format(IFormatProvider provider, string format, Object[] args)
private string FormatHelper(IFormatProvider provider, string format, ParamsArray args)
public string Copy(string str)
public string Concat(object arg0)
public string Concat(object arg0, object arg1)
public string Concat(object arg0, object arg1, object arg2)
public string Concat(object arg0, object arg1, object arg2, object arg3)
public string Concat(Object[] args)
public string Concat(IEnumerable`1<T> values)
public string Concat(IEnumerable`1<string> values)
public string Concat(string str0, string str1)
public string Concat(string str0, string str1, string str2)
public string Concat(string str0, string str1, string str2, string str3)
private string ConcatArray(String[] values, int totalLength)
public string Concat(String[] values)
public string Intern(string str)
public string IsInterned(string str)
public TypeCode GetTypeCode()
private bool System.IConvertible.ToBoolean(IFormatProvider provider)
private char System.IConvertible.ToChar(IFormatProvider provider)
private sbyte System.IConvertible.ToSByte(IFormatProvider provider)
private byte System.IConvertible.ToByte(IFormatProvider provider)
private short System.IConvertible.ToInt16(IFormatProvider provider)
private ushort System.IConvertible.ToUInt16(IFormatProvider provider)
private int System.IConvertible.ToInt32(IFormatProvider provider)
private UInt32 System.IConvertible.ToUInt32(IFormatProvider provider)
private long System.IConvertible.ToInt64(IFormatProvider provider)
private ulong System.IConvertible.ToUInt64(IFormatProvider provider)
private float System.IConvertible.ToSingle(IFormatProvider provider)
private double System.IConvertible.ToDouble(IFormatProvider provider)
private decimal System.IConvertible.ToDecimal(IFormatProvider provider)
private DateTime System.IConvertible.ToDateTime(IFormatProvider provider)
private object System.IConvertible.ToType(Type type, IFormatProvider provider)
public CharEnumerator GetEnumerator()
private IEnumerator`1<char> System.Collections.Generic.IEnumerable<System.Char>.GetEnumerator()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
internal void InternalCopy(string src, IntPtr dest, int len)
public int get_Length()
internal int CompareOrdinalUnchecked(string strA, int indexA, int lenA, string strB, int indexB, int lenB)
public int IndexOf(char value, int startIndex, int count)
internal int IndexOfUnchecked(char value, int startIndex, int count)
internal int IndexOfUnchecked(string value, int startIndex, int count)
public int IndexOfAny(Char[] anyOf, int startIndex, int count)
private int IndexOfAnyUnchecked(Char[] anyOf, int startIndex, int count)
public int LastIndexOf(char value, int startIndex, int count)
internal int LastIndexOfUnchecked(char value, int startIndex, int count)
public int LastIndexOfAny(Char[] anyOf, int startIndex, int count)
private int LastIndexOfAnyUnchecked(Char[] anyOf, int startIndex, int count)
internal int nativeCompareOrdinalEx(string strA, int indexA, string strB, int indexB, int count)
private string ReplaceInternal(char oldChar, char newChar)
internal string ReplaceInternal(string oldValue, string newValue)
private string ReplaceUnchecked(string oldValue, string newValue)
private string ReplaceFallback(string oldValue, string newValue, int testedCount)
private string PadHelper(int totalWidth, char paddingChar, bool isRightPadded)
internal bool StartsWithOrdinalUnchecked(string value)
internal bool IsAscii()
internal bool IsFastSort()
private string InternalIsInterned(string str)
private string InternalIntern(string str)
internal void CharCopy(Char* dest, Char* src, int count)
private void memset(Byte* dest, int val, int len)
private void memcpy(Byte* dest, Byte* src, int size)
internal void bzero(Byte* dest, int len)
internal void bzero_aligned_1(Byte* dest, int len)
internal void bzero_aligned_2(Byte* dest, int len)
internal void bzero_aligned_4(Byte* dest, int len)
internal void bzero_aligned_8(Byte* dest, int len)
internal void memcpy_aligned_1(Byte* dest, Byte* src, int size)
internal void memcpy_aligned_2(Byte* dest, Byte* src, int size)
internal void memcpy_aligned_4(Byte* dest, Byte* src, int size)
internal void memcpy_aligned_8(Byte* dest, Byte* src, int size)
private string CreateString(SByte* value)
private string CreateString(SByte* value, int startIndex, int length)
private string CreateString(Char* value)
private string CreateString(Char* value, int startIndex, int length)
private string CreateString(Char[] val, int startIndex, int length)
private string CreateString(Char[] val)
private string CreateString(char c, int count)
private string CreateString(SByte* value, int startIndex, int length, Encoding enc)
}
public System.StringComparer : object {
private StringComparer _invariantCulture
private StringComparer _invariantCultureIgnoreCase
private StringComparer _ordinal
private StringComparer _ordinalIgnoreCase
public StringComparer InvariantCulture
public StringComparer InvariantCultureIgnoreCase
public StringComparer CurrentCulture
public StringComparer CurrentCultureIgnoreCase
public StringComparer Ordinal
public StringComparer OrdinalIgnoreCase
public StringComparer get_InvariantCulture()
public StringComparer get_InvariantCultureIgnoreCase()
public StringComparer get_CurrentCulture()
public StringComparer get_CurrentCultureIgnoreCase()
public StringComparer get_Ordinal()
public StringComparer get_OrdinalIgnoreCase()
public StringComparer Create(CultureInfo culture, bool ignoreCase)
public int Compare(object x, object y)
public bool Equals(object x, object y)
public int GetHashCode(object obj)
public int Compare(string x, string y)
public bool Equals(string x, string y)
public int GetHashCode(string obj)
}
public System.StringComparison : Enum {
public int value__
public StringComparison CurrentCulture
public StringComparison CurrentCultureIgnoreCase
public StringComparison InvariantCulture
public StringComparison InvariantCultureIgnoreCase
public StringComparison Ordinal
public StringComparison OrdinalIgnoreCase
}
public System.StringSplitOptions : Enum {
public int value__
public StringSplitOptions None
public StringSplitOptions RemoveEmptyEntries
}
internal System.System_LazyDebugView`1 : object {
private Lazy`1<T> m_lazy
public bool IsValueCreated
public T Value
public LazyThreadSafetyMode Mode
public bool IsValueFaulted
public void .ctor(Lazy`1<T> lazy)
public bool get_IsValueCreated()
public T get_Value()
public LazyThreadSafetyMode get_Mode()
public bool get_IsValueFaulted()
}
public System.SystemException : Exception {
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
protected void .ctor(SerializationInfo info, StreamingContext context)
}
internal System.TermInfoBooleans : Enum {
public int value__
public TermInfoBooleans AutoLeftMargin
public TermInfoBooleans AutoRightMargin
public TermInfoBooleans NoEscCtlc
public TermInfoBooleans CeolStandoutGlitch
public TermInfoBooleans EatNewlineGlitch
public TermInfoBooleans EraseOverstrike
public TermInfoBooleans GenericType
public TermInfoBooleans HardCopy
public TermInfoBooleans HasMetaKey
public TermInfoBooleans HasStatusLine
public TermInfoBooleans InsertNullGlitch
public TermInfoBooleans MemoryAbove
public TermInfoBooleans MemoryBelow
public TermInfoBooleans MoveInsertMode
public TermInfoBooleans MoveStandoutMode
public TermInfoBooleans OverStrike
public TermInfoBooleans StatusLineEscOk
public TermInfoBooleans DestTabsMagicSmso
public TermInfoBooleans TildeGlitch
public TermInfoBooleans TransparentUnderline
public TermInfoBooleans XonXoff
public TermInfoBooleans NeedsXonXoff
public TermInfoBooleans PrtrSilent
public TermInfoBooleans HardCursor
public TermInfoBooleans NonRevRmcup
public TermInfoBooleans NoPadChar
public TermInfoBooleans NonDestScrollRegion
public TermInfoBooleans CanChange
public TermInfoBooleans BackColorErase
public TermInfoBooleans HueLightnessSaturation
public TermInfoBooleans ColAddrGlitch
public TermInfoBooleans CrCancelsMicroMode
public TermInfoBooleans HasPrintWheel
public TermInfoBooleans RowAddrGlitch
public TermInfoBooleans SemiAutoRightMargin
public TermInfoBooleans CpiChangesRes
public TermInfoBooleans LpiChangesRes
public TermInfoBooleans Last
}
internal System.TermInfoDriver : object {
private Int32* native_terminal_size
private int terminal_size
private String[] locations
private TermInfoReader reader
private int cursorLeft
private int cursorTop
private string title
private string titleFormat
private bool cursorVisible
private string csrVisible
private string csrInvisible
private string clear
private string bell
private string term
private StreamReader stdin
private CStreamWriter stdout
private int windowWidth
private int windowHeight
private int bufferHeight
private int bufferWidth
private Char[] buffer
private int readpos
private int writepos
private string keypadXmit
private string keypadLocal
private bool controlCAsInput
private bool inited
private object initLock
private bool initKeys
private string origPair
private string origColors
private string cursorAddress
private ConsoleColor fgcolor
private ConsoleColor bgcolor
private string setfgcolor
private string setbgcolor
private int maxColors
private bool noGetPosition
private Hashtable keymap
private ByteMatcher rootmap
private int rl_startx
private int rl_starty
private Byte[] control_characters
private Int32[] _consoleColorToAnsiCode
private Char[] echobuf
private int echon
public bool Initialized
public ConsoleColor BackgroundColor
public ConsoleColor ForegroundColor
public int BufferHeight
public int BufferWidth
public bool CapsLock
public int CursorLeft
public int CursorTop
public bool CursorVisible
public int CursorSize
public bool KeyAvailable
public int LargestWindowHeight
public int LargestWindowWidth
public bool NumberLock
public string Title
public bool TreatControlCAsInput
public int WindowHeight
public int WindowLeft
public int WindowTop
public int WindowWidth
private string TryTermInfoDir(string dir, string term)
private string SearchTerminfo(string term)
private void WriteConsole(string str)
public void .ctor(string term)
public bool get_Initialized()
public void Init()
private void IncrementX()
public void WriteSpecialKey(ConsoleKeyInfo key)
public void WriteSpecialKey(char c)
public bool IsSpecialKey(ConsoleKeyInfo key)
public bool IsSpecialKey(char c)
private void ChangeColor(string format, ConsoleColor color)
public ConsoleColor get_BackgroundColor()
public void set_BackgroundColor(ConsoleColor value)
public ConsoleColor get_ForegroundColor()
public void set_ForegroundColor(ConsoleColor value)
private void GetCursorPosition()
public int get_BufferHeight()
public void set_BufferHeight(int value)
public int get_BufferWidth()
public void set_BufferWidth(int value)
public bool get_CapsLock()
public int get_CursorLeft()
public void set_CursorLeft(int value)
public int get_CursorTop()
public void set_CursorTop(int value)
public bool get_CursorVisible()
public void set_CursorVisible(bool value)
public int get_CursorSize()
public void set_CursorSize(int value)
public bool get_KeyAvailable()
public int get_LargestWindowHeight()
public int get_LargestWindowWidth()
public bool get_NumberLock()
public string get_Title()
public void set_Title(string value)
public bool get_TreatControlCAsInput()
public void set_TreatControlCAsInput(bool value)
private void CheckWindowDimensions()
public int get_WindowHeight()
public void set_WindowHeight(int value)
public int get_WindowLeft()
public void set_WindowLeft(int value)
public int get_WindowTop()
public void set_WindowTop(int value)
public int get_WindowWidth()
public void set_WindowWidth(int value)
public void Clear()
public void Beep(int frequency, int duration)
public void MoveBufferArea(int sourceLeft, int sourceTop, int sourceWidth, int sourceHeight, int targetLeft, int targetTop, char sourceChar, ConsoleColor sourceForeColor, ConsoleColor sourceBackColor)
private void AddToBuffer(int b)
private void AdjustBuffer()
private ConsoleKeyInfo CreateKeyInfoFromInt(int n, bool alt)
private object GetKeyFromBuffer(bool cooked)
private ConsoleKeyInfo ReadKeyInternal(Boolean& fresh)
private bool InputPending()
private void QueueEcho(char c)
private void Echo(ConsoleKeyInfo key)
private void EchoFlush()
public int Read(Char[] dest, int index, int count)
public ConsoleKeyInfo ReadKey(bool intercept)
public string ReadLine()
public string ReadToEnd()
private string ReadUntilConditionInternal(bool haltOnNewLine)
public void ResetColor()
public void SetBufferSize(int width, int height)
public void SetCursorPosition(int left, int top)
public void SetWindowPosition(int left, int top)
public void SetWindowSize(int width, int height)
private void CreateKeyMap()
private void InitKeys()
private void AddStringMapping(TermInfoStrings s)
}
internal System.TermInfoNumbers : Enum {
public int value__
public TermInfoNumbers Columns
public TermInfoNumbers InitTabs
public TermInfoNumbers Lines
public TermInfoNumbers LinesOfMemory
public TermInfoNumbers MagicCookieGlitch
public TermInfoNumbers PaddingBaudRate
public TermInfoNumbers VirtualTerminal
public TermInfoNumbers WidthStatusLine
public TermInfoNumbers NumLabels
public TermInfoNumbers LabelHeight
public TermInfoNumbers LabelWidth
public TermInfoNumbers MaxAttributes
public TermInfoNumbers MaximumWindows
public TermInfoNumbers MaxColors
public TermInfoNumbers MaxPairs
public TermInfoNumbers NoColorVideo
public TermInfoNumbers BufferCapacity
public TermInfoNumbers DotVertSpacing
public TermInfoNumbers DotHorzSpacing
public TermInfoNumbers MaxMicroAddress
public TermInfoNumbers MaxMicroJump
public TermInfoNumbers MicroColSize
public TermInfoNumbers MicroLineSize
public TermInfoNumbers NumberOfPins
public TermInfoNumbers OutputResChar
public TermInfoNumbers OutputResLine
public TermInfoNumbers OutputResHorzInch
public TermInfoNumbers OutputResVertInch
public TermInfoNumbers PrintRate
public TermInfoNumbers WideCharSize
public TermInfoNumbers Buttons
public TermInfoNumbers BitImageEntwining
public TermInfoNumbers BitImageType
public TermInfoNumbers Last
}
internal System.TermInfoReader : object {
private short boolSize
private short numSize
private short strOffsets
private Byte[] buffer
private int booleansOffset
public void .ctor(string term, string filename)
public void .ctor(string term, Byte[] buffer)
private void ReadHeader(Byte[] buffer, Int32& position)
private void ReadNames(Byte[] buffer, Int32& position)
public bool Get(TermInfoBooleans boolean)
public int Get(TermInfoNumbers number)
public string Get(TermInfoStrings tstr)
public Byte[] GetStringBytes(TermInfoStrings tstr)
private short GetInt16(Byte[] buffer, int offset)
private string GetString(Byte[] buffer, int offset)
private Byte[] GetStringBytes(Byte[] buffer, int offset)
internal string Escape(string s)
}
internal System.TermInfoStrings : Enum {
public int value__
public TermInfoStrings BackTab
public TermInfoStrings Bell
public TermInfoStrings CarriageReturn
public TermInfoStrings ChangeScrollRegion
public TermInfoStrings ClearAllTabs
public TermInfoStrings ClearScreen
public TermInfoStrings ClrEol
public TermInfoStrings ClrEos
public TermInfoStrings ColumnAddress
public TermInfoStrings CommandCharacter
public TermInfoStrings CursorAddress
public TermInfoStrings CursorDown
public TermInfoStrings CursorHome
public TermInfoStrings CursorInvisible
public TermInfoStrings CursorLeft
public TermInfoStrings CursorMemAddress
public TermInfoStrings CursorNormal
public TermInfoStrings CursorRight
public TermInfoStrings CursorToLl
public TermInfoStrings CursorUp
public TermInfoStrings CursorVisible
public TermInfoStrings DeleteCharacter
public TermInfoStrings DeleteLine
public TermInfoStrings DisStatusLine
public TermInfoStrings DownHalfLine
public TermInfoStrings EnterAltCharsetMode
public TermInfoStrings EnterBlinkMode
public TermInfoStrings EnterBoldMode
public TermInfoStrings EnterCaMode
public TermInfoStrings EnterDeleteMode
public TermInfoStrings EnterDimMode
public TermInfoStrings EnterInsertMode
public TermInfoStrings EnterSecureMode
public TermInfoStrings EnterProtectedMode
public TermInfoStrings EnterReverseMode
public TermInfoStrings EnterStandoutMode
public TermInfoStrings EnterUnderlineMode
public TermInfoStrings EraseChars
public TermInfoStrings ExitAltCharsetMode
public TermInfoStrings ExitAttributeMode
public TermInfoStrings ExitCaMode
public TermInfoStrings ExitDeleteMode
public TermInfoStrings ExitInsertMode
public TermInfoStrings ExitStandoutMode
public TermInfoStrings ExitUnderlineMode
public TermInfoStrings FlashScreen
public TermInfoStrings FormFeed
public TermInfoStrings FromStatusLine
public TermInfoStrings Init1string
public TermInfoStrings Init2string
public TermInfoStrings Init3string
public TermInfoStrings InitFile
public TermInfoStrings InsertCharacter
public TermInfoStrings InsertLine
public TermInfoStrings InsertPadding
public TermInfoStrings KeyBackspace
public TermInfoStrings KeyCatab
public TermInfoStrings KeyClear
public TermInfoStrings KeyCtab
public TermInfoStrings KeyDc
public TermInfoStrings KeyDl
public TermInfoStrings KeyDown
public TermInfoStrings KeyEic
public TermInfoStrings KeyEol
public TermInfoStrings KeyEos
public TermInfoStrings KeyF0
public TermInfoStrings KeyF1
public TermInfoStrings KeyF10
public TermInfoStrings KeyF2
public TermInfoStrings KeyF3
public TermInfoStrings KeyF4
public TermInfoStrings KeyF5
public TermInfoStrings KeyF6
public TermInfoStrings KeyF7
public TermInfoStrings KeyF8
public TermInfoStrings KeyF9
public TermInfoStrings KeyHome
public TermInfoStrings KeyIc
public TermInfoStrings KeyIl
public TermInfoStrings KeyLeft
public TermInfoStrings KeyLl
public TermInfoStrings KeyNpage
public TermInfoStrings KeyPpage
public TermInfoStrings KeyRight
public TermInfoStrings KeySf
public TermInfoStrings KeySr
public TermInfoStrings KeyStab
public TermInfoStrings KeyUp
public TermInfoStrings KeypadLocal
public TermInfoStrings KeypadXmit
public TermInfoStrings LabF0
public TermInfoStrings LabF1
public TermInfoStrings LabF10
public TermInfoStrings LabF2
public TermInfoStrings LabF3
public TermInfoStrings LabF4
public TermInfoStrings LabF5
public TermInfoStrings LabF6
public TermInfoStrings LabF7
public TermInfoStrings LabF8
public TermInfoStrings LabF9
public TermInfoStrings MetaOff
public TermInfoStrings MetaOn
public TermInfoStrings Newline
public TermInfoStrings PadChar
public TermInfoStrings ParmDch
public TermInfoStrings ParmDeleteLine
public TermInfoStrings ParmDownCursor
public TermInfoStrings ParmIch
public TermInfoStrings ParmIndex
public TermInfoStrings ParmInsertLine
public TermInfoStrings ParmLeftCursor
public TermInfoStrings ParmRightCursor
public TermInfoStrings ParmRindex
public TermInfoStrings ParmUpCursor
public TermInfoStrings PkeyKey
public TermInfoStrings PkeyLocal
public TermInfoStrings PkeyXmit
public TermInfoStrings PrintScreen
public TermInfoStrings PrtrOff
public TermInfoStrings PrtrOn
public TermInfoStrings RepeatChar
public TermInfoStrings Reset1string
public TermInfoStrings Reset2string
public TermInfoStrings Reset3string
public TermInfoStrings ResetFile
public TermInfoStrings RestoreCursor
public TermInfoStrings RowAddress
public TermInfoStrings SaveCursor
public TermInfoStrings ScrollForward
public TermInfoStrings ScrollReverse
public TermInfoStrings SetAttributes
public TermInfoStrings SetTab
public TermInfoStrings SetWindow
public TermInfoStrings Tab
public TermInfoStrings ToStatusLine
public TermInfoStrings UnderlineChar
public TermInfoStrings UpHalfLine
public TermInfoStrings InitProg
public TermInfoStrings KeyA1
public TermInfoStrings KeyA3
public TermInfoStrings KeyB2
public TermInfoStrings KeyC1
public TermInfoStrings KeyC3
public TermInfoStrings PrtrNon
public TermInfoStrings CharPadding
public TermInfoStrings AcsChars
public TermInfoStrings PlabNorm
public TermInfoStrings KeyBtab
public TermInfoStrings EnterXonMode
public TermInfoStrings ExitXonMode
public TermInfoStrings EnterAmMode
public TermInfoStrings ExitAmMode
public TermInfoStrings XonCharacter
public TermInfoStrings XoffCharacter
public TermInfoStrings EnaAcs
public TermInfoStrings LabelOn
public TermInfoStrings LabelOff
public TermInfoStrings KeyBeg
public TermInfoStrings KeyCancel
public TermInfoStrings KeyClose
public TermInfoStrings KeyCommand
public TermInfoStrings KeyCopy
public TermInfoStrings KeyCreate
public TermInfoStrings KeyEnd
public TermInfoStrings KeyEnter
public TermInfoStrings KeyExit
public TermInfoStrings KeyFind
public TermInfoStrings KeyHelp
public TermInfoStrings KeyMark
public TermInfoStrings KeyMessage
public TermInfoStrings KeyMove
public TermInfoStrings KeyNext
public TermInfoStrings KeyOpen
public TermInfoStrings KeyOptions
public TermInfoStrings KeyPrevious
public TermInfoStrings KeyPrint
public TermInfoStrings KeyRedo
public TermInfoStrings KeyReference
public TermInfoStrings KeyRefresh
public TermInfoStrings KeyReplace
public TermInfoStrings KeyRestart
public TermInfoStrings KeyResume
public TermInfoStrings KeySave
public TermInfoStrings KeySuspend
public TermInfoStrings KeyUndo
public TermInfoStrings KeySbeg
public TermInfoStrings KeyScancel
public TermInfoStrings KeyScommand
public TermInfoStrings KeyScopy
public TermInfoStrings KeyScreate
public TermInfoStrings KeySdc
public TermInfoStrings KeySdl
public TermInfoStrings KeySelect
public TermInfoStrings KeySend
public TermInfoStrings KeySeol
public TermInfoStrings KeySexit
public TermInfoStrings KeySfind
public TermInfoStrings KeyShelp
public TermInfoStrings KeyShome
public TermInfoStrings KeySic
public TermInfoStrings KeySleft
public TermInfoStrings KeySmessage
public TermInfoStrings KeySmove
public TermInfoStrings KeySnext
public TermInfoStrings KeySoptions
public TermInfoStrings KeySprevious
public TermInfoStrings KeySprint
public TermInfoStrings KeySredo
public TermInfoStrings KeySreplace
public TermInfoStrings KeySright
public TermInfoStrings KeySrsume
public TermInfoStrings KeySsave
public TermInfoStrings KeySsuspend
public TermInfoStrings KeySundo
public TermInfoStrings ReqForInput
public TermInfoStrings KeyF11
public TermInfoStrings KeyF12
public TermInfoStrings KeyF13
public TermInfoStrings KeyF14
public TermInfoStrings KeyF15
public TermInfoStrings KeyF16
public TermInfoStrings KeyF17
public TermInfoStrings KeyF18
public TermInfoStrings KeyF19
public TermInfoStrings KeyF20
public TermInfoStrings KeyF21
public TermInfoStrings KeyF22
public TermInfoStrings KeyF23
public TermInfoStrings KeyF24
public TermInfoStrings KeyF25
public TermInfoStrings KeyF26
public TermInfoStrings KeyF27
public TermInfoStrings KeyF28
public TermInfoStrings KeyF29
public TermInfoStrings KeyF30
public TermInfoStrings KeyF31
public TermInfoStrings KeyF32
public TermInfoStrings KeyF33
public TermInfoStrings KeyF34
public TermInfoStrings KeyF35
public TermInfoStrings KeyF36
public TermInfoStrings KeyF37
public TermInfoStrings KeyF38
public TermInfoStrings KeyF39
public TermInfoStrings KeyF40
public TermInfoStrings KeyF41
public TermInfoStrings KeyF42
public TermInfoStrings KeyF43
public TermInfoStrings KeyF44
public TermInfoStrings KeyF45
public TermInfoStrings KeyF46
public TermInfoStrings KeyF47
public TermInfoStrings KeyF48
public TermInfoStrings KeyF49
public TermInfoStrings KeyF50
public TermInfoStrings KeyF51
public TermInfoStrings KeyF52
public TermInfoStrings KeyF53
public TermInfoStrings KeyF54
public TermInfoStrings KeyF55
public TermInfoStrings KeyF56
public TermInfoStrings KeyF57
public TermInfoStrings KeyF58
public TermInfoStrings KeyF59
public TermInfoStrings KeyF60
public TermInfoStrings KeyF61
public TermInfoStrings KeyF62
public TermInfoStrings KeyF63
public TermInfoStrings ClrBol
public TermInfoStrings ClearMargins
public TermInfoStrings SetLeftMargin
public TermInfoStrings SetRightMargin
public TermInfoStrings LabelFormat
public TermInfoStrings SetClock
public TermInfoStrings DisplayClock
public TermInfoStrings RemoveClock
public TermInfoStrings CreateWindow
public TermInfoStrings GotoWindow
public TermInfoStrings Hangup
public TermInfoStrings DialPhone
public TermInfoStrings QuickDial
public TermInfoStrings Tone
public TermInfoStrings Pulse
public TermInfoStrings FlashHook
public TermInfoStrings FixedPause
public TermInfoStrings WaitTone
public TermInfoStrings User0
public TermInfoStrings User1
public TermInfoStrings User2
public TermInfoStrings User3
public TermInfoStrings User4
public TermInfoStrings User5
public TermInfoStrings User6
public TermInfoStrings User7
public TermInfoStrings User8
public TermInfoStrings User9
public TermInfoStrings OrigPair
public TermInfoStrings OrigColors
public TermInfoStrings InitializeColor
public TermInfoStrings InitializePair
public TermInfoStrings SetColorPair
public TermInfoStrings SetForeground
public TermInfoStrings SetBackground
public TermInfoStrings ChangeCharPitch
public TermInfoStrings ChangeLinePitch
public TermInfoStrings ChangeResHorz
public TermInfoStrings ChangeResVert
public TermInfoStrings DefineChar
public TermInfoStrings EnterDoublewideMode
public TermInfoStrings EnterDraftQuality
public TermInfoStrings EnterItalicsMode
public TermInfoStrings EnterLeftwardMode
public TermInfoStrings EnterMicroMode
public TermInfoStrings EnterNearLetterQuality
public TermInfoStrings EnterNormalQuality
public TermInfoStrings EnterShadowMode
public TermInfoStrings EnterSubscriptMode
public TermInfoStrings EnterSuperscriptMode
public TermInfoStrings EnterUpwardMode
public TermInfoStrings ExitDoublewideMode
public TermInfoStrings ExitItalicsMode
public TermInfoStrings ExitLeftwardMode
public TermInfoStrings ExitMicroMode
public TermInfoStrings ExitShadowMode
public TermInfoStrings ExitSubscriptMode
public TermInfoStrings ExitSuperscriptMode
public TermInfoStrings ExitUpwardMode
public TermInfoStrings MicroColumnAddress
public TermInfoStrings MicroDown
public TermInfoStrings MicroLeft
public TermInfoStrings MicroRight
public TermInfoStrings MicroRowAddress
public TermInfoStrings MicroUp
public TermInfoStrings OrderOfPins
public TermInfoStrings ParmDownMicro
public TermInfoStrings ParmLeftMicro
public TermInfoStrings ParmRightMicro
public TermInfoStrings ParmUpMicro
public TermInfoStrings SelectCharSet
public TermInfoStrings SetBottomMargin
public TermInfoStrings SetBottomMarginParm
public TermInfoStrings SetLeftMarginParm
public TermInfoStrings SetRightMarginParm
public TermInfoStrings SetTopMargin
public TermInfoStrings SetTopMarginParm
public TermInfoStrings StartBitImage
public TermInfoStrings StartCharSetDef
public TermInfoStrings StopBitImage
public TermInfoStrings StopCharSetDef
public TermInfoStrings SubscriptCharacters
public TermInfoStrings SuperscriptCharacters
public TermInfoStrings TheseCauseCr
public TermInfoStrings ZeroMotion
public TermInfoStrings CharSetNames
public TermInfoStrings KeyMouse
public TermInfoStrings MouseInfo
public TermInfoStrings ReqMousePos
public TermInfoStrings GetMouse
public TermInfoStrings SetAForeground
public TermInfoStrings SetABackground
public TermInfoStrings PkeyPlab
public TermInfoStrings DeviceType
public TermInfoStrings CodeSetInit
public TermInfoStrings Set0DesSeq
public TermInfoStrings Set1DesSeq
public TermInfoStrings Set2DesSeq
public TermInfoStrings Set3DesSeq
public TermInfoStrings SetLrMargin
public TermInfoStrings SetTbMargin
public TermInfoStrings BitImageRepeat
public TermInfoStrings BitImageNewline
public TermInfoStrings BitImageCarriageReturn
public TermInfoStrings ColorNames
public TermInfoStrings DefineBitImageRegion
public TermInfoStrings EndBitImageRegion
public TermInfoStrings SetColorBand
public TermInfoStrings SetPageLength
public TermInfoStrings DisplayPcChar
public TermInfoStrings EnterPcCharsetMode
public TermInfoStrings ExitPcCharsetMode
public TermInfoStrings EnterScancodeMode
public TermInfoStrings ExitScancodeMode
public TermInfoStrings PcTermOptions
public TermInfoStrings ScancodeEscape
public TermInfoStrings AltScancodeEsc
public TermInfoStrings EnterHorizontalHlMode
public TermInfoStrings EnterLeftHlMode
public TermInfoStrings EnterLowHlMode
public TermInfoStrings EnterRightHlMode
public TermInfoStrings EnterTopHlMode
public TermInfoStrings EnterVerticalHlMode
public TermInfoStrings SetAAttributes
public TermInfoStrings SetPglenInch
public TermInfoStrings Last
}
public System.Text.ASCIIEncoding : Encoding {
public bool IsSingleByte
internal void SetDefaultFallbacks()
public int GetByteCount(Char[] chars, int index, int count)
public int GetByteCount(string chars)
public int GetByteCount(Char* chars, int count)
public int GetBytes(string chars, int charIndex, int charCount, Byte[] bytes, int byteIndex)
public int GetBytes(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex)
public int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount)
public int GetCharCount(Byte[] bytes, int index, int count)
public int GetCharCount(Byte* bytes, int count)
public int GetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex)
public int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount)
public string GetString(Byte[] bytes, int byteIndex, int byteCount)
internal int GetByteCount(Char* chars, int charCount, EncoderNLS encoder)
internal int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount, EncoderNLS encoder)
internal int GetCharCount(Byte* bytes, int count, DecoderNLS decoder)
internal int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount, DecoderNLS decoder)
public int GetMaxByteCount(int charCount)
public int GetMaxCharCount(int byteCount)
public bool get_IsSingleByte()
public Decoder GetDecoder()
public Encoder GetEncoder()
}
internal System.Text.CodePageEncoding : object {
private int m_codePage
private bool m_isReadOnly
private bool m_deserializedFromEverett
private EncoderFallback encoderFallback
private DecoderFallback decoderFallback
private Encoding realEncoding
internal void .ctor(SerializationInfo info, StreamingContext context)
public object GetRealObject(StreamingContext context)
private void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context)
}
public System.Text.Decoder : object {
internal DecoderFallback m_fallback
internal DecoderFallbackBuffer m_fallbackBuffer
public DecoderFallback Fallback
public DecoderFallbackBuffer FallbackBuffer
internal bool InternalHasFallbackBuffer
internal void SerializeDecoder(SerializationInfo info)
public DecoderFallback get_Fallback()
public void set_Fallback(DecoderFallback value)
public DecoderFallbackBuffer get_FallbackBuffer()
internal bool get_InternalHasFallbackBuffer()
public void Reset()
public int GetCharCount(Byte[] bytes, int index, int count)
public int GetCharCount(Byte[] bytes, int index, int count, bool flush)
public int GetCharCount(Byte* bytes, int count, bool flush)
public int GetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex)
public int GetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex, bool flush)
public int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount, bool flush)
public void Convert(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex, int charCount, bool flush, Int32& bytesUsed, Int32& charsUsed, Boolean& completed)
public void Convert(Byte* bytes, int byteCount, Char* chars, int charCount, bool flush, Int32& bytesUsed, Int32& charsUsed, Boolean& completed)
}
public System.Text.DecoderExceptionFallback : DecoderFallback {
public int MaxCharCount
public DecoderFallbackBuffer CreateFallbackBuffer()
public int get_MaxCharCount()
public bool Equals(object value)
public int GetHashCode()
}
public System.Text.DecoderExceptionFallbackBuffer : DecoderFallbackBuffer {
public int Remaining
public bool Fallback(Byte[] bytesUnknown, int index)
public char GetNextChar()
public bool MovePrevious()
public int get_Remaining()
private void Throw(Byte[] bytesUnknown, int index)
}
public System.Text.DecoderFallback : object {
internal bool bIsMicrosoftBestFitFallback
private DecoderFallback modreq(System.Runtime.CompilerServices.IsVolatile) replacementFallback
private DecoderFallback modreq(System.Runtime.CompilerServices.IsVolatile) exceptionFallback
private object s_InternalSyncObject
private object InternalSyncObject
public DecoderFallback ReplacementFallback
public DecoderFallback ExceptionFallback
public int MaxCharCount
internal bool IsMicrosoftBestFitFallback
private object get_InternalSyncObject()
public DecoderFallback get_ReplacementFallback()
public DecoderFallback get_ExceptionFallback()
public DecoderFallbackBuffer CreateFallbackBuffer()
public int get_MaxCharCount()
internal bool get_IsMicrosoftBestFitFallback()
}
public System.Text.DecoderFallbackBuffer : object {
internal Byte* byteStart
internal Char* charEnd
public int Remaining
public bool Fallback(Byte[] bytesUnknown, int index)
public char GetNextChar()
public bool MovePrevious()
public int get_Remaining()
public void Reset()
internal void InternalReset()
internal void InternalInitialize(Byte* byteStart, Char* charEnd)
internal bool InternalFallback(Byte[] bytes, Byte* pBytes, Char*& chars)
internal int InternalFallback(Byte[] bytes, Byte* pBytes)
internal void ThrowLastBytesRecursive(Byte[] bytesUnknown)
}
public System.Text.DecoderFallbackException : ArgumentException {
private Byte[] bytesUnknown
private int index
public Byte[] BytesUnknown
public int Index
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
internal void .ctor(SerializationInfo info, StreamingContext context)
public void .ctor(string message, Byte[] bytesUnknown, int index)
public Byte[] get_BytesUnknown()
public int get_Index()
}
internal System.Text.DecoderNLS : Decoder {
protected Encoding m_encoding
protected bool m_mustFlush
internal bool m_throwOnOverflow
internal int m_bytesUsed
public bool MustFlush
internal bool HasState
internal void .ctor(SerializationInfo info, StreamingContext context)
private void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context)
internal void .ctor(Encoding encoding)
public void Reset()
public int GetCharCount(Byte[] bytes, int index, int count)
public int GetCharCount(Byte[] bytes, int index, int count, bool flush)
public int GetCharCount(Byte* bytes, int count, bool flush)
public int GetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex)
public int GetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex, bool flush)
public int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount, bool flush)
public void Convert(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex, int charCount, bool flush, Int32& bytesUsed, Int32& charsUsed, Boolean& completed)
public void Convert(Byte* bytes, int byteCount, Char* chars, int charCount, bool flush, Int32& bytesUsed, Int32& charsUsed, Boolean& completed)
public bool get_MustFlush()
internal bool get_HasState()
internal void ClearMustFlush()
}
public System.Text.DecoderReplacementFallback : DecoderFallback {
private string strDefault
public string DefaultString
public int MaxCharCount
public void .ctor(string replacement)
public string get_DefaultString()
public DecoderFallbackBuffer CreateFallbackBuffer()
public int get_MaxCharCount()
public bool Equals(object value)
public int GetHashCode()
}
public System.Text.DecoderReplacementFallbackBuffer : DecoderFallbackBuffer {
private string strDefault
private int fallbackCount
private int fallbackIndex
public int Remaining
public void .ctor(DecoderReplacementFallback fallback)
public bool Fallback(Byte[] bytesUnknown, int index)
public char GetNextChar()
public bool MovePrevious()
public int get_Remaining()
public void Reset()
internal int InternalFallback(Byte[] bytes, Byte* pBytes)
}
public System.Text.Encoder : object {
internal EncoderFallback m_fallback
internal EncoderFallbackBuffer m_fallbackBuffer
public EncoderFallback Fallback
public EncoderFallbackBuffer FallbackBuffer
internal bool InternalHasFallbackBuffer
internal void SerializeEncoder(SerializationInfo info)
public EncoderFallback get_Fallback()
public void set_Fallback(EncoderFallback value)
public EncoderFallbackBuffer get_FallbackBuffer()
internal bool get_InternalHasFallbackBuffer()
public void Reset()
public int GetByteCount(Char[] chars, int index, int count, bool flush)
public int GetByteCount(Char* chars, int count, bool flush)
public int GetBytes(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex, bool flush)
public int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount, bool flush)
public void Convert(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex, int byteCount, bool flush, Int32& charsUsed, Int32& bytesUsed, Boolean& completed)
public void Convert(Char* chars, int charCount, Byte* bytes, int byteCount, bool flush, Int32& charsUsed, Int32& bytesUsed, Boolean& completed)
}
public System.Text.EncoderExceptionFallback : EncoderFallback {
public int MaxCharCount
public EncoderFallbackBuffer CreateFallbackBuffer()
public int get_MaxCharCount()
public bool Equals(object value)
public int GetHashCode()
}
public System.Text.EncoderExceptionFallbackBuffer : EncoderFallbackBuffer {
public int Remaining
public bool Fallback(char charUnknown, int index)
public bool Fallback(char charUnknownHigh, char charUnknownLow, int index)
public char GetNextChar()
public bool MovePrevious()
public int get_Remaining()
}
public System.Text.EncoderFallback : object {
internal bool bIsMicrosoftBestFitFallback
private EncoderFallback modreq(System.Runtime.CompilerServices.IsVolatile) replacementFallback
private EncoderFallback modreq(System.Runtime.CompilerServices.IsVolatile) exceptionFallback
private object s_InternalSyncObject
private object InternalSyncObject
public EncoderFallback ReplacementFallback
public EncoderFallback ExceptionFallback
public int MaxCharCount
private object get_InternalSyncObject()
public EncoderFallback get_ReplacementFallback()
public EncoderFallback get_ExceptionFallback()
public EncoderFallbackBuffer CreateFallbackBuffer()
public int get_MaxCharCount()
}
public System.Text.EncoderFallbackBuffer : object {
internal Char* charStart
internal Char* charEnd
internal EncoderNLS encoder
internal bool setEncoder
internal bool bUsedEncoder
internal bool bFallingBack
internal int iRecursionCount
private int iMaxRecursion
public int Remaining
public bool Fallback(char charUnknown, int index)
public bool Fallback(char charUnknownHigh, char charUnknownLow, int index)
public char GetNextChar()
public bool MovePrevious()
public int get_Remaining()
public void Reset()
internal void InternalReset()
internal void InternalInitialize(Char* charStart, Char* charEnd, EncoderNLS encoder, bool setEncoder)
internal char InternalGetNextChar()
internal bool InternalFallback(char ch, Char*& chars)
internal void ThrowLastCharRecursive(int charRecursive)
}
public System.Text.EncoderFallbackException : ArgumentException {
private char charUnknown
private char charUnknownHigh
private char charUnknownLow
private int index
public char CharUnknown
public char CharUnknownHigh
public char CharUnknownLow
public int Index
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
internal void .ctor(SerializationInfo info, StreamingContext context)
internal void .ctor(string message, char charUnknown, int index)
internal void .ctor(string message, char charUnknownHigh, char charUnknownLow, int index)
public char get_CharUnknown()
public char get_CharUnknownHigh()
public char get_CharUnknownLow()
public int get_Index()
public bool IsUnknownSurrogate()
}
internal System.Text.EncoderNLS : Encoder {
internal char charLeftOver
protected Encoding m_encoding
protected bool m_mustFlush
internal bool m_throwOnOverflow
internal int m_charsUsed
public Encoding Encoding
public bool MustFlush
internal bool HasState
internal void .ctor(SerializationInfo info, StreamingContext context)
private void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context)
internal void .ctor(Encoding encoding)
public void Reset()
public int GetByteCount(Char[] chars, int index, int count, bool flush)
public int GetByteCount(Char* chars, int count, bool flush)
public int GetBytes(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex, bool flush)
public int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount, bool flush)
public void Convert(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex, int byteCount, bool flush, Int32& charsUsed, Int32& bytesUsed, Boolean& completed)
public void Convert(Char* chars, int charCount, Byte* bytes, int byteCount, bool flush, Int32& charsUsed, Int32& bytesUsed, Boolean& completed)
public Encoding get_Encoding()
public bool get_MustFlush()
internal bool get_HasState()
internal void ClearMustFlush()
}
public System.Text.EncoderReplacementFallback : EncoderFallback {
private string strDefault
public string DefaultString
public int MaxCharCount
public void .ctor(string replacement)
public string get_DefaultString()
public EncoderFallbackBuffer CreateFallbackBuffer()
public int get_MaxCharCount()
public bool Equals(object value)
public int GetHashCode()
}
public System.Text.EncoderReplacementFallbackBuffer : EncoderFallbackBuffer {
private string strDefault
private int fallbackCount
private int fallbackIndex
public int Remaining
public void .ctor(EncoderReplacementFallback fallback)
public bool Fallback(char charUnknown, int index)
public bool Fallback(char charUnknownHigh, char charUnknownLow, int index)
public char GetNextChar()
public bool MovePrevious()
public int get_Remaining()
public void Reset()
}
public System.Text.Encoding : object {
private Encoding modreq(System.Runtime.CompilerServices.IsVolatile) defaultEncoding
private Encoding modreq(System.Runtime.CompilerServices.IsVolatile) unicodeEncoding
private Encoding modreq(System.Runtime.CompilerServices.IsVolatile) bigEndianUnicode
private Encoding modreq(System.Runtime.CompilerServices.IsVolatile) utf7Encoding
private Encoding modreq(System.Runtime.CompilerServices.IsVolatile) utf8Encoding
private Encoding modreq(System.Runtime.CompilerServices.IsVolatile) utf32Encoding
private Encoding modreq(System.Runtime.CompilerServices.IsVolatile) asciiEncoding
private Encoding modreq(System.Runtime.CompilerServices.IsVolatile) latin1Encoding
private Hashtable modreq(System.Runtime.CompilerServices.IsVolatile) encodings
private int MIMECONTF_MAILNEWS
private int MIMECONTF_BROWSER
private int MIMECONTF_SAVABLE_MAILNEWS
private int MIMECONTF_SAVABLE_BROWSER
private int CodePageDefault
private int CodePageNoOEM
private int CodePageNoMac
private int CodePageNoThread
private int CodePageNoSymbol
private int CodePageUnicode
private int CodePageBigEndian
private int CodePageWindows1252
private int CodePageMacGB2312
private int CodePageGB2312
private int CodePageMacKorean
private int CodePageDLLKorean
private int ISO2022JP
private int ISO2022JPESC
private int ISO2022JPSISO
private int ISOKorean
private int ISOSimplifiedCN
private int EUCJP
private int ChineseHZ
private int DuplicateEUCCN
private int EUCCN
private int EUCKR
internal int CodePageASCII
internal int ISO_8859_1
private int ISCIIAssemese
private int ISCIIBengali
private int ISCIIDevanagari
private int ISCIIGujarathi
private int ISCIIKannada
private int ISCIIMalayalam
private int ISCIIOriya
private int ISCIIPanjabi
private int ISCIITamil
private int ISCIITelugu
private int GB18030
private int ISO_8859_8I
private int ISO_8859_8_Visual
private int ENC50229
private int CodePageUTF7
private int CodePageUTF8
private int CodePageUTF32
private int CodePageUTF32BE
internal int m_codePage
internal CodePageDataItem dataItem
internal bool m_deserializedFromEverett
private bool m_isReadOnly
internal EncoderFallback encoderFallback
internal DecoderFallback decoderFallback
private object s_InternalSyncObject
private object InternalSyncObject
public string BodyName
public string EncodingName
public string HeaderName
public string WebName
public int WindowsCodePage
public bool IsBrowserDisplay
public bool IsBrowserSave
public bool IsMailNewsDisplay
public bool IsMailNewsSave
public bool IsSingleByte
public EncoderFallback EncoderFallback
public DecoderFallback DecoderFallback
public bool IsReadOnly
public Encoding ASCII
private Encoding Latin1
public int CodePage
public Encoding Default
public Encoding Unicode
public Encoding BigEndianUnicode
public Encoding UTF7
public Encoding UTF8
public Encoding UTF32
protected void .ctor(int codePage)
protected void .ctor(int codePage, EncoderFallback encoderFallback, DecoderFallback decoderFallback)
internal void SetDefaultFallbacks()
internal void OnDeserializing()
internal void OnDeserialized()
private void OnDeserializing(StreamingContext ctx)
private void OnDeserialized(StreamingContext ctx)
private void OnSerializing(StreamingContext ctx)
internal void DeserializeEncoding(SerializationInfo info, StreamingContext context)
internal void SerializeEncoding(SerializationInfo info, StreamingContext context)
public Byte[] Convert(Encoding srcEncoding, Encoding dstEncoding, Byte[] bytes)
public Byte[] Convert(Encoding srcEncoding, Encoding dstEncoding, Byte[] bytes, int index, int count)
private object get_InternalSyncObject()
public void RegisterProvider(EncodingProvider provider)
public Encoding GetEncoding(int codepage)
public Encoding GetEncoding(int codepage, EncoderFallback encoderFallback, DecoderFallback decoderFallback)
public Encoding GetEncoding(string name)
public Encoding GetEncoding(string name, EncoderFallback encoderFallback, DecoderFallback decoderFallback)
public EncodingInfo[] GetEncodings()
public Byte[] GetPreamble()
private void GetDataItem()
public string get_BodyName()
public string get_EncodingName()
public string get_HeaderName()
public string get_WebName()
public int get_WindowsCodePage()
public bool get_IsBrowserDisplay()
public bool get_IsBrowserSave()
public bool get_IsMailNewsDisplay()
public bool get_IsMailNewsSave()
public bool get_IsSingleByte()
public EncoderFallback get_EncoderFallback()
public void set_EncoderFallback(EncoderFallback value)
public DecoderFallback get_DecoderFallback()
public void set_DecoderFallback(DecoderFallback value)
public object Clone()
public bool get_IsReadOnly()
public Encoding get_ASCII()
private Encoding get_Latin1()
public int GetByteCount(Char[] chars)
public int GetByteCount(string s)
public int GetByteCount(Char[] chars, int index, int count)
public int GetByteCount(Char* chars, int count)
internal int GetByteCount(Char* chars, int count, EncoderNLS encoder)
public Byte[] GetBytes(Char[] chars)
public Byte[] GetBytes(Char[] chars, int index, int count)
public int GetBytes(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex)
public Byte[] GetBytes(string s)
public int GetBytes(string s, int charIndex, int charCount, Byte[] bytes, int byteIndex)
internal int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount, EncoderNLS encoder)
public int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount)
public int GetCharCount(Byte[] bytes)
public int GetCharCount(Byte[] bytes, int index, int count)
public int GetCharCount(Byte* bytes, int count)
internal int GetCharCount(Byte* bytes, int count, DecoderNLS decoder)
public Char[] GetChars(Byte[] bytes)
public Char[] GetChars(Byte[] bytes, int index, int count)
public int GetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex)
public int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount)
internal int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount, DecoderNLS decoder)
public string GetString(Byte* bytes, int byteCount)
public int get_CodePage()
public bool IsAlwaysNormalized()
public bool IsAlwaysNormalized(NormalizationForm form)
public Decoder GetDecoder()
private Encoding CreateDefaultEncoding()
internal void setReadOnly(bool value)
public Encoding get_Default()
public Encoder GetEncoder()
public int GetMaxByteCount(int charCount)
public int GetMaxCharCount(int byteCount)
public string GetString(Byte[] bytes)
public string GetString(Byte[] bytes, int index, int count)
public Encoding get_Unicode()
public Encoding get_BigEndianUnicode()
public Encoding get_UTF7()
public Encoding get_UTF8()
public Encoding get_UTF32()
public bool Equals(object value)
public int GetHashCode()
internal Char[] GetBestFitUnicodeToBytesData()
internal Char[] GetBestFitBytesToUnicodeData()
internal void ThrowBytesOverflow()
internal void ThrowBytesOverflow(EncoderNLS encoder, bool nothingEncoded)
internal void ThrowCharsOverflow()
internal void ThrowCharsOverflow(DecoderNLS decoder, bool nothingDecoded)
}
internal System.Text.EncodingHelper : object {
private Encoding modreq(System.Runtime.CompilerServices.IsVolatile) utf8EncodingWithoutMarkers
private Encoding modreq(System.Runtime.CompilerServices.IsVolatile) utf8EncodingUnsafe
private Encoding modreq(System.Runtime.CompilerServices.IsVolatile) bigEndianUTF32Encoding
private object lockobj
private Assembly i18nAssembly
private bool i18nDisabled
internal Encoding UTF8Unmarked
internal Encoding UTF8UnmarkedUnsafe
internal Encoding BigEndianUTF32
internal Encoding get_UTF8Unmarked()
internal Encoding get_UTF8UnmarkedUnsafe()
internal Encoding get_BigEndianUTF32()
internal string InternalCodePage(Int32& code_page)
internal Encoding GetDefaultEncoding()
internal object InvokeI18N(string name, Object[] args)
}
public System.Text.EncodingInfo : object {
private int iCodePage
private string strEncodingName
private string strDisplayName
public int CodePage
public string Name
public string DisplayName
internal void .ctor(int codePage, string name, string displayName)
public int get_CodePage()
public string get_Name()
public string get_DisplayName()
public Encoding GetEncoding()
public bool Equals(object value)
public int GetHashCode()
}
internal System.Text.EncodingNLS : Encoding {
protected void .ctor(int codePage)
public int GetByteCount(Char[] chars, int index, int count)
public int GetByteCount(string s)
public int GetByteCount(Char* chars, int count)
public int GetBytes(string s, int charIndex, int charCount, Byte[] bytes, int byteIndex)
public int GetBytes(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex)
public int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount)
public int GetCharCount(Byte[] bytes, int index, int count)
public int GetCharCount(Byte* bytes, int count)
public int GetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex)
public int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount)
public string GetString(Byte[] bytes, int index, int count)
public Decoder GetDecoder()
public Encoder GetEncoder()
}
public System.Text.EncodingProvider : object {
private object s_InternalSyncObject
private EncodingProvider[] modreq(System.Runtime.CompilerServices.IsVolatile) s_providers
public Encoding GetEncoding(string name)
public Encoding GetEncoding(int codepage)
public Encoding GetEncoding(string name, EncoderFallback encoderFallback, DecoderFallback decoderFallback)
public Encoding GetEncoding(int codepage, EncoderFallback encoderFallback, DecoderFallback decoderFallback)
internal void AddProvider(EncodingProvider provider)
internal Encoding GetEncodingFromProvider(int codepage)
internal Encoding GetEncodingFromProvider(string encodingName)
internal Encoding GetEncodingFromProvider(int codepage, EncoderFallback enc, DecoderFallback dec)
internal Encoding GetEncodingFromProvider(string encodingName, EncoderFallback enc, DecoderFallback dec)
}
internal System.Text.InternalDecoderBestFitFallback : DecoderFallback {
internal Encoding encoding
internal Char[] arrayBestFit
internal char cReplacement
public int MaxCharCount
internal void .ctor(Encoding encoding)
public DecoderFallbackBuffer CreateFallbackBuffer()
public int get_MaxCharCount()
public bool Equals(object value)
public int GetHashCode()
}
internal System.Text.InternalDecoderBestFitFallbackBuffer : DecoderFallbackBuffer {
internal char cBestFit
internal int iCount
internal int iSize
private InternalDecoderBestFitFallback oFallback
private object s_InternalSyncObject
private object InternalSyncObject
public int Remaining
private object get_InternalSyncObject()
public void .ctor(InternalDecoderBestFitFallback fallback)
public bool Fallback(Byte[] bytesUnknown, int index)
public char GetNextChar()
public bool MovePrevious()
public int get_Remaining()
public void Reset()
internal int InternalFallback(Byte[] bytes, Byte* pBytes)
private char TryBestFit(Byte[] bytesCheck)
}
internal System.Text.InternalEncoderBestFitFallback : EncoderFallback {
internal Encoding encoding
internal Char[] arrayBestFit
public int MaxCharCount
internal void .ctor(Encoding encoding)
public EncoderFallbackBuffer CreateFallbackBuffer()
public int get_MaxCharCount()
public bool Equals(object value)
public int GetHashCode()
}
internal System.Text.InternalEncoderBestFitFallbackBuffer : EncoderFallbackBuffer {
private char cBestFit
private InternalEncoderBestFitFallback oFallback
private int iCount
private int iSize
private object s_InternalSyncObject
private object InternalSyncObject
public int Remaining
private object get_InternalSyncObject()
public void .ctor(InternalEncoderBestFitFallback fallback)
public bool Fallback(char charUnknown, int index)
public bool Fallback(char charUnknownHigh, char charUnknownLow, int index)
public char GetNextChar()
public bool MovePrevious()
public int get_Remaining()
public void Reset()
private char TryBestFit(char cUnknown)
}
internal System.Text.Latin1Encoding : EncodingNLS {
private Char[] arrayCharBestFit
public bool IsSingleByte
internal void .ctor(SerializationInfo info, StreamingContext context)
private void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context)
internal int GetByteCount(Char* chars, int charCount, EncoderNLS encoder)
internal int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount, EncoderNLS encoder)
internal int GetCharCount(Byte* bytes, int count, DecoderNLS decoder)
internal int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount, DecoderNLS decoder)
public int GetMaxByteCount(int charCount)
public int GetMaxCharCount(int byteCount)
public bool get_IsSingleByte()
public bool IsAlwaysNormalized(NormalizationForm form)
internal Char[] GetBestFitUnicodeToBytesData()
}
internal System.Text.MLangCodePageEncoding : object {
private int m_codePage
private bool m_isReadOnly
private bool m_deserializedFromEverett
private EncoderFallback encoderFallback
private DecoderFallback decoderFallback
private Encoding realEncoding
internal void .ctor(SerializationInfo info, StreamingContext context)
public object GetRealObject(StreamingContext context)
private void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context)
}
internal System.Text.Normalization : object {
public int NoNfd
public int NoNfkd
public int NoNfc
public int MaybeNfc
public int NoNfkc
public int MaybeNfkc
public int FullCompositionExclusion
public int IsUnsafe
private int HangulSBase
private int HangulLBase
private int HangulVBase
private int HangulTBase
private int HangulLCount
private int HangulVCount
private int HangulTCount
private int HangulNCount
private int HangulSCount
private Byte* props
private Int32* mappedChars
private Int16* charMapIndex
private Int16* helperIndex
private UInt16* mapIdxToComposite
private Byte* combiningClass
private object forLock
public bool isReady
public bool IsReady
private UInt32 PropValue(int cp)
private int CharMapIdx(int cp)
private byte GetCombiningClass(int c)
private int GetPrimaryCompositeFromMapIndex(int src)
private int GetPrimaryCompositeHelperIndex(int cp)
private string Compose(string source, int checkType)
private StringBuilder Combine(string source, int start, int checkType)
private void Combine(StringBuilder sb, int i, int checkType)
private int CombineHangul(StringBuilder sb, string s, int current)
private int Fetch(StringBuilder sb, string s, int i)
private int TryComposeWithPreviousStarter(StringBuilder sb, string s, int current)
private int TryCompose(int i, int starter, int candidate)
private string Decompose(string source, int checkType)
private void Decompose(string source, StringBuilder& sb, int checkType)
private void ReorderCanonical(string src, StringBuilder& sb, int start)
private void DecomposeChar(StringBuilder& sb, Int32[]& buf, string s, int i, int checkType, Int32& start)
public NormalizationCheck QuickCheck(char c, int type)
private int GetCanonicalHangul(int s, Int32[] buf, int bufIdx)
private int GetCanonical(int c, Int32[] buf, int bufIdx, int checkType)
public bool IsNormalized(string source, NormalizationForm normalizationForm)
public bool IsNormalized(string source, int type)
public string Normalize(string source, NormalizationForm normalizationForm)
public string Normalize(string source, int type)
public bool get_IsReady()
private void load_normalization_resource(IntPtr& props, IntPtr& mappedChars, IntPtr& charMapIndex, IntPtr& helperIndex, IntPtr& mapIdxToComposite, IntPtr& combiningClass)
}
internal System.Text.NormalizationCheck : Enum {
public int value__
public NormalizationCheck Yes
public NormalizationCheck No
public NormalizationCheck Maybe
}
public System.Text.NormalizationForm : Enum {
public int value__
public NormalizationForm FormC
public NormalizationForm FormD
public NormalizationForm FormKC
public NormalizationForm FormKD
}
public System.Text.StringBuilder : object {
internal Char[] m_ChunkChars
internal StringBuilder m_ChunkPrevious
internal int m_ChunkLength
internal int m_ChunkOffset
internal int m_MaxCapacity
internal int DefaultCapacity
private string CapacityField
private string MaxCapacityField
private string StringValueField
private string ThreadIDField
internal int MaxChunkSize
public int Capacity
public int MaxCapacity
public int Length
public char Chars
public void .ctor(int capacity)
public void .ctor(string value)
public void .ctor(string value, int capacity)
public void .ctor(string value, int startIndex, int length, int capacity)
public void .ctor(int capacity, int maxCapacity)
private void .ctor(SerializationInfo info, StreamingContext context)
private void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context)
private void VerifyClassInvariant()
public int get_Capacity()
public void set_Capacity(int value)
public int get_MaxCapacity()
public int EnsureCapacity(int capacity)
public string ToString()
public string ToString(int startIndex, int length)
public StringBuilder Clear()
public int get_Length()
public void set_Length(int value)
public char get_Chars(int index)
public void set_Chars(int index, char value)
public StringBuilder Append(char value, int repeatCount)
public StringBuilder Append(Char[] value, int startIndex, int charCount)
public StringBuilder Append(string value)
private void AppendHelper(string value)
public StringBuilder Append(string value, int startIndex, int count)
public StringBuilder AppendLine()
public StringBuilder AppendLine(string value)
public void CopyTo(int sourceIndex, Char[] destination, int destinationIndex, int count)
public StringBuilder Insert(int index, string value, int count)
public StringBuilder Remove(int startIndex, int length)
public StringBuilder Append(bool value)
public StringBuilder Append(sbyte value)
public StringBuilder Append(byte value)
public StringBuilder Append(char value)
public StringBuilder Append(short value)
public StringBuilder Append(int value)
public StringBuilder Append(long value)
public StringBuilder Append(float value)
public StringBuilder Append(double value)
public StringBuilder Append(decimal value)
public StringBuilder Append(ushort value)
public StringBuilder Append(UInt32 value)
public StringBuilder Append(ulong value)
public StringBuilder Append(object value)
public StringBuilder Append(Char[] value)
public StringBuilder Insert(int index, string value)
public StringBuilder Insert(int index, bool value)
public StringBuilder Insert(int index, sbyte value)
public StringBuilder Insert(int index, byte value)
public StringBuilder Insert(int index, short value)
public StringBuilder Insert(int index, char value)
public StringBuilder Insert(int index, Char[] value)
public StringBuilder Insert(int index, Char[] value, int startIndex, int charCount)
public StringBuilder Insert(int index, int value)
public StringBuilder Insert(int index, long value)
public StringBuilder Insert(int index, float value)
public StringBuilder Insert(int index, double value)
public StringBuilder Insert(int index, decimal value)
public StringBuilder Insert(int index, ushort value)
public StringBuilder Insert(int index, UInt32 value)
public StringBuilder Insert(int index, ulong value)
public StringBuilder Insert(int index, object value)
public StringBuilder AppendFormat(string format, object arg0)
public StringBuilder AppendFormat(string format, object arg0, object arg1)
public StringBuilder AppendFormat(string format, object arg0, object arg1, object arg2)
public StringBuilder AppendFormat(string format, Object[] args)
public StringBuilder AppendFormat(IFormatProvider provider, string format, object arg0)
public StringBuilder AppendFormat(IFormatProvider provider, string format, object arg0, object arg1)
public StringBuilder AppendFormat(IFormatProvider provider, string format, object arg0, object arg1, object arg2)
public StringBuilder AppendFormat(IFormatProvider provider, string format, Object[] args)
private void FormatError()
internal StringBuilder AppendFormatHelper(IFormatProvider provider, string format, ParamsArray args)
public StringBuilder Replace(string oldValue, string newValue)
public bool Equals(StringBuilder sb)
public StringBuilder Replace(string oldValue, string newValue, int startIndex, int count)
public StringBuilder Replace(char oldChar, char newChar)
public StringBuilder Replace(char oldChar, char newChar, int startIndex, int count)
public StringBuilder Append(Char* value, int valueCount)
private void Insert(int index, Char* value, int valueCount)
private void ReplaceAllInChunk(Int32[] replacements, int replacementsCount, StringBuilder sourceChunk, int removeCount, string value)
private bool StartsWith(StringBuilder chunk, int indexInChunk, int count, string value)
private void ReplaceInPlaceAtChunk(StringBuilder& chunk, Int32& indexInChunk, Char* value, int count)
private void ThreadSafeCopy(Char* sourcePtr, Char[] destination, int destinationIndex, int count)
private void ThreadSafeCopy(Char[] source, int sourceIndex, Char[] destination, int destinationIndex, int count)
private StringBuilder FindChunkForIndex(int index)
private StringBuilder FindChunkForByte(int byteIndex)
private StringBuilder Next(StringBuilder chunk)
private void ExpandByABlock(int minBlockCharCount)
private void .ctor(StringBuilder from)
private void MakeRoom(int index, int count, StringBuilder& chunk, Int32& indexInChunk, bool doneMoveFollowingChars)
private void .ctor(int size, int maxCapacity, StringBuilder previousBlock)
private void Remove(int startIndex, int count, StringBuilder& chunk, Int32& indexInChunk)
}
internal System.Text.StringBuilderCache : object {
private int MAX_BUILDER_SIZE
private StringBuilder CachedInstance
public StringBuilder Acquire(int capacity)
public void Release(StringBuilder sb)
public string GetStringAndRelease(StringBuilder sb)
}
internal System.Text.SurrogateEncoder : object {
private Encoding realEncoding
internal void .ctor(SerializationInfo info, StreamingContext context)
public object GetRealObject(StreamingContext context)
private void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context)
}
public System.Text.UnicodeEncoding : Encoding {
internal bool isThrowException
internal bool bigEndian
internal bool byteOrderMark
public int CharSize
private ulong highLowPatternMask
public void .ctor(bool bigEndian, bool byteOrderMark)
public void .ctor(bool bigEndian, bool byteOrderMark, bool throwOnInvalidBytes)
private void OnDeserializing(StreamingContext ctx)
internal void SetDefaultFallbacks()
public int GetByteCount(Char[] chars, int index, int count)
public int GetByteCount(string s)
public int GetByteCount(Char* chars, int count)
public int GetBytes(string s, int charIndex, int charCount, Byte[] bytes, int byteIndex)
public int GetBytes(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex)
public int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount)
public int GetCharCount(Byte[] bytes, int index, int count)
public int GetCharCount(Byte* bytes, int count)
public int GetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex)
public int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount)
public string GetString(Byte[] bytes, int index, int count)
internal int GetByteCount(Char* chars, int count, EncoderNLS encoder)
internal int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount, EncoderNLS encoder)
internal int GetCharCount(Byte* bytes, int count, DecoderNLS baseDecoder)
internal int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount, DecoderNLS baseDecoder)
public Encoder GetEncoder()
public Decoder GetDecoder()
public Byte[] GetPreamble()
public int GetMaxByteCount(int charCount)
public int GetMaxCharCount(int byteCount)
public bool Equals(object value)
public int GetHashCode()
}
public System.Text.UTF32Encoding : Encoding {
private bool emitUTF32ByteOrderMark
private bool isThrowException
private bool bigEndian
public void .ctor(bool bigEndian, bool byteOrderMark)
public void .ctor(bool bigEndian, bool byteOrderMark, bool throwOnInvalidCharacters)
internal void SetDefaultFallbacks()
public int GetByteCount(Char[] chars, int index, int count)
public int GetByteCount(string s)
public int GetByteCount(Char* chars, int count)
public int GetBytes(string s, int charIndex, int charCount, Byte[] bytes, int byteIndex)
public int GetBytes(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex)
public int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount)
public int GetCharCount(Byte[] bytes, int index, int count)
public int GetCharCount(Byte* bytes, int count)
public int GetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex)
public int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount)
public string GetString(Byte[] bytes, int index, int count)
internal int GetByteCount(Char* chars, int count, EncoderNLS encoder)
internal int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount, EncoderNLS encoder)
internal int GetCharCount(Byte* bytes, int count, DecoderNLS baseDecoder)
internal int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount, DecoderNLS baseDecoder)
private UInt32 GetSurrogate(char cHigh, char cLow)
private char GetHighSurrogate(UInt32 iChar)
private char GetLowSurrogate(UInt32 iChar)
public Decoder GetDecoder()
public Encoder GetEncoder()
public int GetMaxByteCount(int charCount)
public int GetMaxCharCount(int byteCount)
public Byte[] GetPreamble()
public bool Equals(object value)
public int GetHashCode()
}
public System.Text.UTF7Encoding : Encoding {
private string base64Chars
private string directChars
private string optionalChars
private Byte[] base64Bytes
private SByte[] base64Values
private Boolean[] directEncode
private bool m_allowOptionals
private int UTF7_CODEPAGE
public void .ctor(bool allowOptionals)
private void MakeTables()
internal void SetDefaultFallbacks()
private void OnDeserializing(StreamingContext ctx)
private void OnDeserialized(StreamingContext ctx)
public bool Equals(object value)
public int GetHashCode()
public int GetByteCount(Char[] chars, int index, int count)
public int GetByteCount(string s)
public int GetByteCount(Char* chars, int count)
public int GetBytes(string s, int charIndex, int charCount, Byte[] bytes, int byteIndex)
public int GetBytes(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex)
public int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount)
public int GetCharCount(Byte[] bytes, int index, int count)
public int GetCharCount(Byte* bytes, int count)
public int GetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex)
public int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount)
public string GetString(Byte[] bytes, int index, int count)
internal int GetByteCount(Char* chars, int count, EncoderNLS baseEncoder)
internal int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount, EncoderNLS baseEncoder)
internal int GetCharCount(Byte* bytes, int count, DecoderNLS baseDecoder)
internal int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount, DecoderNLS baseDecoder)
public Decoder GetDecoder()
public Encoder GetEncoder()
public int GetMaxByteCount(int charCount)
public int GetMaxCharCount(int byteCount)
}
public System.Text.UTF8Encoding : Encoding {
private int UTF8_CODEPAGE
private bool emitUTF8Identifier
private bool isThrowException
private int FinalByte
private int SupplimentarySeq
private int ThreeByteSeq
public void .ctor(bool encoderShouldEmitUTF8Identifier)
public void .ctor(bool encoderShouldEmitUTF8Identifier, bool throwOnInvalidBytes)
internal void SetDefaultFallbacks()
public int GetByteCount(Char[] chars, int index, int count)
public int GetByteCount(string chars)
public int GetByteCount(Char* chars, int count)
public int GetBytes(string s, int charIndex, int charCount, Byte[] bytes, int byteIndex)
public int GetBytes(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex)
public int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount)
public int GetCharCount(Byte[] bytes, int index, int count)
public int GetCharCount(Byte* bytes, int count)
public int GetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex)
public int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount)
public string GetString(Byte[] bytes, int index, int count)
internal int GetByteCount(Char* chars, int count, EncoderNLS baseEncoder)
private int PtrDiff(Char* a, Char* b)
private int PtrDiff(Byte* a, Byte* b)
private bool InRange(int ch, int start, int end)
internal int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount, EncoderNLS baseEncoder)
internal int GetCharCount(Byte* bytes, int count, DecoderNLS baseDecoder)
internal int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount, DecoderNLS baseDecoder)
private bool FallbackInvalidByteSequence(Byte*& pSrc, int ch, DecoderFallbackBuffer fallback, Char*& pTarget)
private int FallbackInvalidByteSequence(Byte* pSrc, int ch, DecoderFallbackBuffer fallback)
private Byte[] GetBytesUnknown(Byte*& pSrc, int ch)
public Decoder GetDecoder()
public Encoder GetEncoder()
public int GetMaxByteCount(int charCount)
public int GetMaxCharCount(int byteCount)
public Byte[] GetPreamble()
public bool Equals(object value)
public int GetHashCode()
}
internal System.Threading._ThreadPoolWaitCallback : object {
internal bool PerformWaitCallback()
}
internal System.Threading._ThreadPoolWaitOrTimerCallback : object {
private WaitOrTimerCallback _waitOrTimerCallback
private ExecutionContext _executionContext
private object _state
private ContextCallback _ccbt
private ContextCallback _ccbf
internal void .ctor(WaitOrTimerCallback waitOrTimerCallback, object state, bool compressStack, StackCrawlMark& stackMark)
private void WaitOrTimerCallback_Context_t(object state)
private void WaitOrTimerCallback_Context_f(object state)
private void WaitOrTimerCallback_Context(object state, bool timedOut)
internal void PerformWaitOrTimerCallback(object state, bool timedOut)
}
public System.Threading.AbandonedMutexException : SystemException {
private int m_MutexIndex
private Mutex m_Mutex
public Mutex Mutex
public int MutexIndex
public void .ctor(string message)
public void .ctor(string message, Exception inner)
public void .ctor(int location, WaitHandle handle)
public void .ctor(string message, int location, WaitHandle handle)
public void .ctor(string message, Exception inner, int location, WaitHandle handle)
private void SetupException(int location, WaitHandle handle)
protected void .ctor(SerializationInfo info, StreamingContext context)
public Mutex get_Mutex()
public int get_MutexIndex()
}
public System.Threading.ApartmentState : Enum {
public int value__
public ApartmentState STA
public ApartmentState MTA
public ApartmentState Unknown
}
public System.Threading.AsyncFlowControl : ValueType {
private bool useEC
private ExecutionContext _ec
private Thread _thread
internal void Setup()
public void Dispose()
public void Undo()
public int GetHashCode()
public bool Equals(object obj)
public bool Equals(AsyncFlowControl obj)
public bool op_Equality(AsyncFlowControl a, AsyncFlowControl b)
public bool op_Inequality(AsyncFlowControl a, AsyncFlowControl b)
}
public System.Threading.AsyncLocal`1 : object {
private Action`1<AsyncLocalValueChangedArgs`1<T>> m_valueChangedHandler
public T Value
public void .ctor(Action`1<AsyncLocalValueChangedArgs`1<T>> valueChangedHandler)
public T get_Value()
public void set_Value(T value)
private void System.Threading.IAsyncLocal.OnValueChanged(object previousValueObj, object currentValueObj, bool contextChanged)
}
public System.Threading.AsyncLocalValueChangedArgs`1 : ValueType {
private T <PreviousValue>k__BackingField
private T <CurrentValue>k__BackingField
private bool <ThreadContextChanged>k__BackingField
public T PreviousValue
public T CurrentValue
public bool ThreadContextChanged
public T get_PreviousValue()
private void set_PreviousValue(T value)
public T get_CurrentValue()
private void set_CurrentValue(T value)
public bool get_ThreadContextChanged()
private void set_ThreadContextChanged(bool value)
internal void .ctor(T previousValue, T currentValue, bool contextChanged)
}
internal System.Threading.AtomicBoolean : object {
private int flag
private int UnSet
private int Set
public bool Value
public bool CompareAndExchange(bool expected, bool newVal)
public AtomicBoolean FromValue(bool value)
public bool TrySet()
public bool TryRelaxedSet()
public bool Exchange(bool newVal)
public bool get_Value()
public void set_Value(bool value)
public bool Equals(AtomicBoolean rhs)
public bool Equals(object rhs)
public int GetHashCode()
public bool op_Explicit(AtomicBoolean rhs)
public AtomicBoolean op_Implicit(bool rhs)
}
internal System.Threading.AtomicBooleanValue : ValueType {
private int flag
private int UnSet
private int Set
public bool Value
public bool CompareAndExchange(bool expected, bool newVal)
public AtomicBooleanValue FromValue(bool value)
public bool TrySet()
public bool TryRelaxedSet()
public bool Exchange(bool newVal)
public bool get_Value()
public void set_Value(bool value)
public bool Equals(AtomicBooleanValue rhs)
public bool Equals(object rhs)
public int GetHashCode()
public bool op_Explicit(AtomicBooleanValue rhs)
public AtomicBooleanValue op_Implicit(bool rhs)
}
public System.Threading.AutoResetEvent : EventWaitHandle {
public void .ctor(bool initialState)
}
internal System.Threading.CancellationCallbackCoreWorkArguments : ValueType {
internal SparselyPopulatedArrayFragment`1<CancellationCallbackInfo> m_currArrayFragment
internal int m_currArrayIndex
public void .ctor(SparselyPopulatedArrayFragment`1<CancellationCallbackInfo> currArrayFragment, int currArrayIndex)
}
internal System.Threading.CancellationCallbackInfo : object {
internal Action`1<object> Callback
internal object StateForCallback
internal SynchronizationContext TargetSyncContext
internal ExecutionContext TargetExecutionContext
internal CancellationTokenSource CancellationTokenSource
private ContextCallback s_executionContextCallback
internal void .ctor(Action`1<object> callback, object stateForCallback, SynchronizationContext targetSyncContext, ExecutionContext targetExecutionContext, CancellationTokenSource cancellationTokenSource)
internal void ExecuteCallback()
private void ExecutionContextCallback(object obj)
}
public System.Threading.CancellationToken : ValueType {
private CancellationTokenSource m_source
private Action`1<object> s_ActionToActionObjShunt
public CancellationToken None
public bool IsCancellationRequested
public bool CanBeCanceled
public WaitHandle WaitHandle
public CancellationToken get_None()
public bool get_IsCancellationRequested()
public bool get_CanBeCanceled()
public WaitHandle get_WaitHandle()
internal void .ctor(CancellationTokenSource source)
public void .ctor(bool canceled)
private void ActionToActionObjShunt(object obj)
public CancellationTokenRegistration Register(Action callback)
public CancellationTokenRegistration Register(Action callback, bool useSynchronizationContext)
public CancellationTokenRegistration Register(Action`1<object> callback, object state)
public CancellationTokenRegistration Register(Action`1<object> callback, object state, bool useSynchronizationContext)
internal CancellationTokenRegistration InternalRegisterWithoutEC(Action`1<object> callback, object state)
private CancellationTokenRegistration Register(Action`1<object> callback, object state, bool useSynchronizationContext, bool useExecutionContext)
public bool Equals(CancellationToken other)
public bool Equals(object other)
public int GetHashCode()
public bool op_Equality(CancellationToken left, CancellationToken right)
public bool op_Inequality(CancellationToken left, CancellationToken right)
public void ThrowIfCancellationRequested()
internal void ThrowIfSourceDisposed()
private void ThrowOperationCanceledException()
private void ThrowObjectDisposedException()
private void InitializeDefaultSource()
}
public System.Threading.CancellationTokenRegistration : ValueType {
private CancellationCallbackInfo m_callbackInfo
private SparselyPopulatedArrayAddInfo`1<CancellationCallbackInfo> m_registrationInfo
internal void .ctor(CancellationCallbackInfo callbackInfo, SparselyPopulatedArrayAddInfo`1<CancellationCallbackInfo> registrationInfo)
internal bool TryDeregister()
public void Dispose()
public bool op_Equality(CancellationTokenRegistration left, CancellationTokenRegistration right)
public bool op_Inequality(CancellationTokenRegistration left, CancellationTokenRegistration right)
public bool Equals(object obj)
public bool Equals(CancellationTokenRegistration other)
public int GetHashCode()
}
public System.Threading.CancellationTokenSource : object {
private CancellationTokenSource _staticSource_Set
private CancellationTokenSource _staticSource_NotCancelable
private int s_nLists
private ManualResetEvent modreq(System.Runtime.CompilerServices.IsVolatile) m_kernelEvent
private SparselyPopulatedArray`1[] modreq(System.Runtime.CompilerServices.IsVolatile) m_registeredCallbacksLists
private int CANNOT_BE_CANCELED
private int NOT_CANCELED
private int NOTIFYING
private int NOTIFYINGCOMPLETE
private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) m_state
private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) m_threadIDExecutingCallbacks
private bool m_disposed
private CancellationTokenRegistration[] m_linkingRegistrations
private Action`1<object> s_LinkedTokenCancelDelegate
private CancellationCallbackInfo modreq(System.Runtime.CompilerServices.IsVolatile) m_executingCallback
private Timer modreq(System.Runtime.CompilerServices.IsVolatile) m_timer
private TimerCallback s_timerCallback
public bool IsCancellationRequested
internal bool IsCancellationCompleted
internal bool IsDisposed
internal int ThreadIDExecutingCallbacks
public CancellationToken Token
internal bool CanBeCanceled
internal WaitHandle WaitHandle
internal CancellationCallbackInfo ExecutingCallback
private void LinkedTokenCancelDelegate(object source)
public bool get_IsCancellationRequested()
internal bool get_IsCancellationCompleted()
internal bool get_IsDisposed()
internal void set_ThreadIDExecutingCallbacks(int value)
internal int get_ThreadIDExecutingCallbacks()
public CancellationToken get_Token()
internal bool get_CanBeCanceled()
internal WaitHandle get_WaitHandle()
internal CancellationCallbackInfo get_ExecutingCallback()
private void .ctor(bool set)
public void .ctor(TimeSpan delay)
public void .ctor(int millisecondsDelay)
private void InitializeWithTimer(int millisecondsDelay)
public void Cancel()
public void Cancel(bool throwOnFirstException)
public void CancelAfter(TimeSpan delay)
public void CancelAfter(int millisecondsDelay)
private void TimerCallbackLogic(object obj)
public void Dispose()
protected void Dispose(bool disposing)
internal void ThrowIfDisposed()
private void ThrowObjectDisposedException()
internal CancellationTokenSource InternalGetStaticSource(bool set)
internal CancellationTokenRegistration InternalRegister(Action`1<object> callback, object stateForCallback, SynchronizationContext targetSyncContext, ExecutionContext executionContext)
private void NotifyCancellation(bool throwOnFirstException)
private void ExecuteCallbackHandlers(bool throwOnFirstException)
private void CancellationCallbackCoreWork_OnSyncContext(object obj)
private void CancellationCallbackCoreWork(CancellationCallbackCoreWorkArguments args)
public CancellationTokenSource CreateLinkedTokenSource(CancellationToken token1, CancellationToken token2)
public CancellationTokenSource CreateLinkedTokenSource(CancellationToken[] tokens)
internal void WaitForCallbackToComplete(CancellationCallbackInfo callbackInfo)
}
public System.Threading.CompressedStack : object {
private ArrayList _list
internal IList List
internal void .ctor(int length)
internal void .ctor(CompressedStack cs)
public CompressedStack CreateCopy()
public CompressedStack Capture()
public CompressedStack GetCompressedStack()
public void GetObjectData(SerializationInfo info, StreamingContext context)
public void Run(CompressedStack compressedStack, ContextCallback callback, object state)
internal bool Equals(CompressedStack cs)
internal bool IsEmpty()
internal IList get_List()
}
public System.Threading.ContextCallback : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object state)
public IAsyncResult BeginInvoke(object state, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.Threading.CountdownEvent : object {
private int m_initialCount
private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) m_currentCount
private ManualResetEventSlim m_event
private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) m_disposed
public int CurrentCount
public int InitialCount
public bool IsSet
public WaitHandle WaitHandle
public void .ctor(int initialCount)
public int get_CurrentCount()
public int get_InitialCount()
public bool get_IsSet()
public WaitHandle get_WaitHandle()
public void Dispose()
protected void Dispose(bool disposing)
public bool Signal()
public bool Signal(int signalCount)
public void AddCount()
public bool TryAddCount()
public void AddCount(int signalCount)
public bool TryAddCount(int signalCount)
public void Reset()
public void Reset(int count)
public void Wait()
public void Wait(CancellationToken cancellationToken)
public bool Wait(TimeSpan timeout)
public bool Wait(TimeSpan timeout, CancellationToken cancellationToken)
public bool Wait(int millisecondsTimeout)
public bool Wait(int millisecondsTimeout, CancellationToken cancellationToken)
private void ThrowIfDisposed()
}
internal System.Threading.DeferredDisposableLifetime`1 : ValueType {
private int _count
public bool AddRef(T obj)
public void Release(T obj)
public void Dispose(T obj)
}
public System.Threading.EventResetMode : Enum {
public int value__
public EventResetMode AutoReset
public EventResetMode ManualReset
}
public System.Threading.EventWaitHandle : WaitHandle {
public void .ctor(bool initialState, EventResetMode mode)
public void .ctor(bool initialState, EventResetMode mode, string name)
public void .ctor(bool initialState, EventResetMode mode, string name, Boolean& createdNew)
public void .ctor(bool initialState, EventResetMode mode, string name, Boolean& createdNew, EventWaitHandleSecurity eventSecurity)
private void .ctor(SafeWaitHandle handle)
public EventWaitHandle OpenExisting(string name)
public EventWaitHandle OpenExisting(string name, EventWaitHandleRights rights)
public bool TryOpenExisting(string name, EventWaitHandle& result)
public bool TryOpenExisting(string name, EventWaitHandleRights rights, EventWaitHandle& result)
private OpenExistingResult OpenExistingWorker(string name, EventWaitHandleRights rights, EventWaitHandle& result)
public bool Reset()
public bool Set()
public EventWaitHandleSecurity GetAccessControl()
public void SetAccessControl(EventWaitHandleSecurity eventSecurity)
}
public System.Threading.ExecutionContext : object {
private SynchronizationContext _syncContext
private SynchronizationContext _syncContextNoFlow
private LogicalCallContext _logicalCallContext
private IllogicalCallContext _illogicalCallContext
private Flags _flags
private Dictionary`2<IAsyncLocal, object> _localValues
private List`1<IAsyncLocal> _localChangeNotifications
private ExecutionContext s_dummyDefaultEC
internal bool isNewCapture
internal bool isFlowSuppressed
internal ExecutionContext PreAllocatedDefault
internal bool IsPreAllocatedDefault
internal LogicalCallContext LogicalCallContext
internal IllogicalCallContext IllogicalCallContext
internal SynchronizationContext SynchronizationContext
internal SynchronizationContext SynchronizationContextNoFlow
internal bool get_isNewCapture()
internal void set_isNewCapture(bool value)
internal bool get_isFlowSuppressed()
internal void set_isFlowSuppressed(bool value)
internal ExecutionContext get_PreAllocatedDefault()
internal bool get_IsPreAllocatedDefault()
internal void .ctor(bool isPreAllocatedDefault)
internal object GetLocalValue(IAsyncLocal local)
internal void SetLocalValue(IAsyncLocal local, object newValue, bool needChangeNotifications)
internal void OnAsyncLocalContextChanged(ExecutionContext previous, ExecutionContext current)
internal LogicalCallContext get_LogicalCallContext()
internal void set_LogicalCallContext(LogicalCallContext value)
internal IllogicalCallContext get_IllogicalCallContext()
internal void set_IllogicalCallContext(IllogicalCallContext value)
internal SynchronizationContext get_SynchronizationContext()
internal void set_SynchronizationContext(SynchronizationContext value)
internal SynchronizationContext get_SynchronizationContextNoFlow()
internal void set_SynchronizationContextNoFlow(SynchronizationContext value)
public void Dispose()
public void Run(ExecutionContext executionContext, ContextCallback callback, object state)
internal void Run(ExecutionContext executionContext, ContextCallback callback, object state, bool preserveSyncCtx)
internal void RunInternal(ExecutionContext executionContext, ContextCallback callback, object state, bool preserveSyncCtx)
internal void EstablishCopyOnWriteScope(ExecutionContextSwitcher& ecsw)
private void EstablishCopyOnWriteScope(Thread currentThread, bool knownNullWindowsIdentity, ExecutionContextSwitcher& ecsw)
internal ExecutionContextSwitcher SetExecutionContext(ExecutionContext executionContext, bool preserveSyncCtx)
public ExecutionContext CreateCopy()
internal ExecutionContext CreateMutableCopy()
public AsyncFlowControl SuppressFlow()
public void RestoreFlow()
public bool IsFlowSuppressed()
public ExecutionContext Capture()
internal ExecutionContext FastCapture()
internal ExecutionContext Capture(StackCrawlMark& stackMark, CaptureOptions options)
public void GetObjectData(SerializationInfo info, StreamingContext context)
private void .ctor(SerializationInfo info, StreamingContext context)
internal bool IsDefaultFTContext(bool ignoreSyncCtx)
}
internal System.Threading.ExecutionContextSwitcher : ValueType {
internal Reader outerEC
internal bool outerECBelongsToScope
internal object hecsw
internal Thread thread
internal bool UndoNoThrow()
internal void Undo()
}
public System.Threading.HostExecutionContext : object {
private object _state
protected internal object State
public void .ctor(object state)
public HostExecutionContext CreateCopy()
protected internal object get_State()
protected internal void set_State(object value)
public void Dispose()
public void Dispose(bool disposing)
}
public System.Threading.HostExecutionContextManager : object {
public HostExecutionContext Capture()
public void Revert(object previousState)
public object SetHostExecutionContext(HostExecutionContext hostExecutionContext)
}
internal System.Threading.IAsyncLocal {
public void OnValueChanged(object previousValue, object currentValue, bool contextChanged)
}
internal System.Threading.IDeferredDisposable {
public void OnFinalRelease(bool disposed)
}
public System.Threading.Interlocked : object {
public int CompareExchange(Int32& location1, int value, int comparand)
internal int CompareExchange(Int32& location1, int value, int comparand, Boolean& succeeded)
public object CompareExchange(Object& location1, object value, object comparand)
public float CompareExchange(Single& location1, float value, float comparand)
public int Decrement(Int32& location)
public long Decrement(Int64& location)
public int Increment(Int32& location)
public long Increment(Int64& location)
public int Exchange(Int32& location1, int value)
public object Exchange(Object& location1, object value)
public float Exchange(Single& location1, float value)
public long CompareExchange(Int64& location1, long value, long comparand)
public IntPtr CompareExchange(IntPtr& location1, IntPtr value, IntPtr comparand)
public double CompareExchange(Double& location1, double value, double comparand)
public T CompareExchange(T& location1, T value, T comparand)
public long Exchange(Int64& location1, long value)
public IntPtr Exchange(IntPtr& location1, IntPtr value)
public double Exchange(Double& location1, double value)
public T Exchange(T& location1, T value)
public long Read(Int64& location)
public int Add(Int32& location1, int value)
public long Add(Int64& location1, long value)
public void MemoryBarrier()
}
internal System.Threading.InternalCrossContextDelegate : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public object Invoke(Object[] args)
public IAsyncResult BeginInvoke(Object[] args, AsyncCallback callback, object object)
public object EndInvoke(IAsyncResult result)
}
internal System.Threading.InternalThread : CriticalFinalizerObject {
private int lock_thread_id
private IntPtr handle
private IntPtr native_handle
private IntPtr unused3
private IntPtr name
private int name_len
private ThreadState state
private object abort_exc
private int abort_state_handle
internal long thread_id
private IntPtr debugger_thread
private UIntPtr static_data
private IntPtr runtime_thread_info
private object current_appcontext
private object root_domain_thread
internal Byte[] _serialized_principal
internal int _serialized_principal_version
private IntPtr appdomain_refs
private int interruption_requested
private IntPtr synch_cs
internal bool threadpool_thread
private bool thread_interrupt_requested
internal int stack_size
internal byte apartment_state
internal Int32 modreq(System.Runtime.CompilerServices.IsVolatile) critical_region_level
internal int managed_id
private int small_id
private IntPtr manage_callback
private IntPtr unused4
private IntPtr flags
private IntPtr thread_pinning_ref
private IntPtr abort_protected_block_count
private int priority
private IntPtr owned_mutex
private IntPtr suspended_event
private int self_suspended
private IntPtr unused1
private IntPtr unused2
private IntPtr last
private void Thread_free_internal()
protected void Finalize()
}
public System.Threading.IOCompletionCallback : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(UInt32 errorCode, UInt32 numBytes, NativeOverlapped* pOVERLAP)
public IAsyncResult BeginInvoke(UInt32 errorCode, UInt32 numBytes, NativeOverlapped* pOVERLAP, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
internal System.Threading.IThreadPoolWorkItem {
public void ExecuteWorkItem()
public void MarkAborted(ThreadAbortException tae)
}
internal System.Threading.LazyHelpers`1 : object {
internal Func`1<T> s_activatorFactorySelector
private T ActivatorFactorySelector()
}
public System.Threading.LazyInitializer : object {
public T EnsureInitialized(T& target)
public T EnsureInitialized(T& target, Func`1<T> valueFactory)
private T EnsureInitializedCore(T& target, Func`1<T> valueFactory)
public T EnsureInitialized(T& target, Boolean& initialized, Object& syncLock)
public T EnsureInitialized(T& target, Boolean& initialized, Object& syncLock, Func`1<T> valueFactory)
private T EnsureInitializedCore(T& target, Boolean& initialized, Object& syncLock, Func`1<T> valueFactory)
}
public System.Threading.LazyThreadSafetyMode : Enum {
public int value__
public LazyThreadSafetyMode None
public LazyThreadSafetyMode PublicationOnly
public LazyThreadSafetyMode ExecutionAndPublication
}
public System.Threading.LockCookie : ValueType {
internal int ThreadId
internal int ReaderLocks
internal int WriterLocks
internal void .ctor(int thread_id)
internal void .ctor(int thread_id, int reader_locks, int writer_locks)
public int GetHashCode()
public bool Equals(LockCookie obj)
public bool Equals(object obj)
public bool op_Equality(LockCookie a, LockCookie b)
public bool op_Inequality(LockCookie a, LockCookie b)
}
internal System.Threading.LockQueue : object {
private ReaderWriterLock rwlock
private int lockCount
public bool IsEmpty
public void .ctor(ReaderWriterLock rwlock)
public bool Wait(int timeout)
public bool get_IsEmpty()
public void Pulse()
}
public System.Threading.LockRecursionException : Exception {
public void .ctor(string message)
protected void .ctor(SerializationInfo info, StreamingContext context)
public void .ctor(string message, Exception innerException)
}
public System.Threading.ManualResetEvent : EventWaitHandle {
public void .ctor(bool initialState)
}
public System.Threading.ManualResetEventSlim : object {
private int DEFAULT_SPIN_SP
private int DEFAULT_SPIN_MP
private Object modreq(System.Runtime.CompilerServices.IsVolatile) m_lock
private ManualResetEvent modreq(System.Runtime.CompilerServices.IsVolatile) m_eventObj
private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) m_combinedState
private int SignalledState_BitMask
private int SignalledState_ShiftCount
private int Dispose_BitMask
private int SpinCountState_BitMask
private int SpinCountState_ShiftCount
private int SpinCountState_MaxValue
private int NumWaitersState_BitMask
private int NumWaitersState_ShiftCount
private int NumWaitersState_MaxValue
private Action`1<object> s_cancellationTokenCallback
public WaitHandle WaitHandle
public bool IsSet
public int SpinCount
private int Waiters
public WaitHandle get_WaitHandle()
public bool get_IsSet()
private void set_IsSet(bool value)
public int get_SpinCount()
private void set_SpinCount(int value)
private int get_Waiters()
private void set_Waiters(int value)
public void .ctor(bool initialState)
public void .ctor(bool initialState, int spinCount)
private void Initialize(bool initialState, int spinCount)
private void EnsureLockObjectCreated()
private bool LazyInitializeEvent()
public void Set()
private void Set(bool duringCancellation)
public void Reset()
public void Wait()
public void Wait(CancellationToken cancellationToken)
public bool Wait(TimeSpan timeout)
public bool Wait(TimeSpan timeout, CancellationToken cancellationToken)
public bool Wait(int millisecondsTimeout)
public bool Wait(int millisecondsTimeout, CancellationToken cancellationToken)
public void Dispose()
protected void Dispose(bool disposing)
private void ThrowIfDisposed()
private void CancellationTokenCallback(object obj)
private void UpdateStateAtomically(int newBits, int updateBitsMask)
private int ExtractStatePortionAndShiftRight(int state, int mask, int rightBitShiftCount)
private int ExtractStatePortion(int state, int mask)
}
public System.Threading.Monitor : object {
public void Enter(object obj)
public void Enter(object obj, Boolean& lockTaken)
private void ThrowLockTakenException()
public void Exit(object obj)
public bool TryEnter(object obj)
public void TryEnter(object obj, Boolean& lockTaken)
public bool TryEnter(object obj, int millisecondsTimeout)
private int MillisecondsTimeoutFromTimeSpan(TimeSpan timeout)
public bool TryEnter(object obj, TimeSpan timeout)
public void TryEnter(object obj, int millisecondsTimeout, Boolean& lockTaken)
public void TryEnter(object obj, TimeSpan timeout, Boolean& lockTaken)
public bool IsEntered(object obj)
public bool Wait(object obj, int millisecondsTimeout, bool exitContext)
public bool Wait(object obj, TimeSpan timeout, bool exitContext)
public bool Wait(object obj, int millisecondsTimeout)
public bool Wait(object obj, TimeSpan timeout)
public bool Wait(object obj)
public void Pulse(object obj)
public void PulseAll(object obj)
private bool Monitor_test_synchronised(object obj)
private void Monitor_pulse(object obj)
private void ObjPulse(object obj)
private void Monitor_pulse_all(object obj)
private void ObjPulseAll(object obj)
private bool Monitor_wait(object obj, int ms)
private bool ObjWait(bool exitContext, int millisecondsTimeout, object obj)
private void try_enter_with_atomic_var(object obj, int millisecondsTimeout, Boolean& lockTaken)
private void ReliableEnterTimeout(object obj, int timeout, Boolean& lockTaken)
private void ReliableEnter(object obj, Boolean& lockTaken)
private bool Monitor_test_owner(object obj)
private bool IsEnteredNative(object obj)
}
public System.Threading.Mutex : WaitHandle {
private bool ReleaseMutex_internal(IntPtr handle)
private IntPtr CreateMutex_internal(bool initiallyOwned, string name, Boolean& created)
private IntPtr OpenMutex_internal(string name, MutexRights rights, MonoIOError& error)
private void .ctor(IntPtr handle)
public void .ctor(bool initiallyOwned)
public void .ctor(bool initiallyOwned, string name)
public void .ctor(bool initiallyOwned, string name, Boolean& createdNew)
public void .ctor(bool initiallyOwned, string name, Boolean& createdNew, MutexSecurity mutexSecurity)
public MutexSecurity GetAccessControl()
public Mutex OpenExisting(string name)
public Mutex OpenExisting(string name, MutexRights rights)
public bool TryOpenExisting(string name, Mutex& result)
public bool TryOpenExisting(string name, MutexRights rights, Mutex& result)
public void ReleaseMutex()
public void SetAccessControl(MutexSecurity mutexSecurity)
}
internal System.Threading.NativeEventCalls : object {
public IntPtr CreateEvent_internal(bool manual, bool initial, string name, Int32& errorCode)
public bool SetEvent(SafeWaitHandle handle)
private bool SetEvent_internal(IntPtr handle)
public bool ResetEvent(SafeWaitHandle handle)
private bool ResetEvent_internal(IntPtr handle)
public void CloseEvent_internal(IntPtr handle)
public IntPtr OpenEvent_internal(string name, EventWaitHandleRights rights, Int32& errorCode)
}
public System.Threading.NativeOverlapped : ValueType {
public IntPtr InternalLow
public IntPtr InternalHigh
public int OffsetLow
public int OffsetHigh
public IntPtr EventHandle
}
public System.Threading.Overlapped : object {
private IAsyncResult ares
private int offsetL
private int offsetH
private int evt
private IntPtr evt_ptr
public IAsyncResult AsyncResult
public int EventHandle
public IntPtr EventHandleIntPtr
public int OffsetHigh
public int OffsetLow
public void .ctor(int offsetLo, int offsetHi, int hEvent, IAsyncResult ar)
public void .ctor(int offsetLo, int offsetHi, IntPtr hEvent, IAsyncResult ar)
public void Free(NativeOverlapped* nativeOverlappedPtr)
public Overlapped Unpack(NativeOverlapped* nativeOverlappedPtr)
public NativeOverlapped* Pack(IOCompletionCallback iocb)
public NativeOverlapped* Pack(IOCompletionCallback iocb, object userData)
public NativeOverlapped* UnsafePack(IOCompletionCallback iocb)
public NativeOverlapped* UnsafePack(IOCompletionCallback iocb, object userData)
public IAsyncResult get_AsyncResult()
public void set_AsyncResult(IAsyncResult value)
public int get_EventHandle()
public void set_EventHandle(int value)
public IntPtr get_EventHandleIntPtr()
public void set_EventHandleIntPtr(IntPtr value)
public int get_OffsetHigh()
public void set_OffsetHigh(int value)
public int get_OffsetLow()
public void set_OffsetLow(int value)
}
public System.Threading.ParameterizedThreadStart : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object obj)
public IAsyncResult BeginInvoke(object obj, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
internal System.Threading.PlatformHelper : object {
private int PROCESSOR_COUNT_REFRESH_INTERVAL_MS
private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) s_processorCount
private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) s_lastProcessorCountRefreshTicks
internal int ProcessorCount
internal bool IsSingleProcessor
internal int get_ProcessorCount()
internal bool get_IsSingleProcessor()
}
public System.Threading.PreAllocatedOverlapped : object {
public void .ctor(IOCompletionCallback callback, object state, object pinData)
public void Dispose()
}
internal System.Threading.QueueUserWorkItemCallback : object {
private WaitCallback callback
private ExecutionContext context
private object state
internal ContextCallback ccb
internal void .ctor(WaitCallback waitCallback, object stateObj, bool compressStack, StackCrawlMark& stackMark)
internal void .ctor(WaitCallback waitCallback, object stateObj, ExecutionContext ec)
private void System.Threading.IThreadPoolWorkItem.ExecuteWorkItem()
private void System.Threading.IThreadPoolWorkItem.MarkAborted(ThreadAbortException tae)
private void WaitCallback_Context(object state)
}
public System.Threading.ReaderWriterLock : CriticalFinalizerObject {
private int seq_num
private int state
private int readers
private int writer_lock_owner
private LockQueue writer_queue
private Hashtable reader_locks
public bool IsReaderLockHeld
public bool IsWriterLockHeld
public int WriterSeqNum
protected void Finalize()
public bool get_IsReaderLockHeld()
public bool get_IsWriterLockHeld()
public int get_WriterSeqNum()
public void AcquireReaderLock(int millisecondsTimeout)
private void AcquireReaderLock(int millisecondsTimeout, int initialLockCount)
public void AcquireReaderLock(TimeSpan timeout)
public void AcquireWriterLock(int millisecondsTimeout)
private void AcquireWriterLock(int millisecondsTimeout, int initialLockCount)
public void AcquireWriterLock(TimeSpan timeout)
public bool AnyWritersSince(int seqNum)
public void DowngradeFromWriterLock(LockCookie& lockCookie)
public LockCookie ReleaseLock()
public void ReleaseReaderLock()
private void ReleaseReaderLock(int currentCount, int releaseCount)
public void ReleaseWriterLock()
private void ReleaseWriterLock(int releaseCount)
public void RestoreLock(LockCookie& lockCookie)
public LockCookie UpgradeToWriterLock(int millisecondsTimeout)
public LockCookie UpgradeToWriterLock(TimeSpan timeout)
private LockCookie GetLockCookie()
private bool HasWriterLock()
private int CheckTimeout(TimeSpan timeout)
}
public System.Threading.RegisteredWaitHandle : MarshalByRefObject {
private WaitHandle _waitObject
private WaitOrTimerCallback _callback
private object _state
private WaitHandle _finalEvent
private ManualResetEvent _cancelEvent
private TimeSpan _timeout
private int _callsInProcess
private bool _executeOnlyOnce
private bool _unregistered
internal void .ctor(WaitHandle waitObject, WaitOrTimerCallback callback, object state, TimeSpan timeout, bool executeOnlyOnce)
internal void Wait(object state)
private void DoCallBack(object timedOut)
public bool Unregister(WaitHandle waitObject)
}
public System.Threading.SemaphoreFullException : SystemException {
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
protected void .ctor(SerializationInfo info, StreamingContext context)
}
public System.Threading.SemaphoreSlim : object {
private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) m_currentCount
private int m_maxCount
private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) m_waitCount
private object m_lockObj
private ManualResetEvent modreq(System.Runtime.CompilerServices.IsVolatile) m_waitHandle
private TaskNode m_asyncHead
private TaskNode m_asyncTail
private Task`1<bool> s_trueTask
private int NO_MAXIMUM
private Action`1<object> s_cancellationTokenCanceledEventHandler
public int CurrentCount
public WaitHandle AvailableWaitHandle
public int get_CurrentCount()
public WaitHandle get_AvailableWaitHandle()
public void .ctor(int initialCount)
public void .ctor(int initialCount, int maxCount)
public void Wait()
public void Wait(CancellationToken cancellationToken)
public bool Wait(TimeSpan timeout)
public bool Wait(TimeSpan timeout, CancellationToken cancellationToken)
public bool Wait(int millisecondsTimeout)
public bool Wait(int millisecondsTimeout, CancellationToken cancellationToken)
private bool WaitUntilCountOrTimeout(int millisecondsTimeout, UInt32 startTime, CancellationToken cancellationToken)
public Task WaitAsync()
public Task WaitAsync(CancellationToken cancellationToken)
public Task`1<bool> WaitAsync(int millisecondsTimeout)
public Task`1<bool> WaitAsync(TimeSpan timeout)
public Task`1<bool> WaitAsync(TimeSpan timeout, CancellationToken cancellationToken)
public Task`1<bool> WaitAsync(int millisecondsTimeout, CancellationToken cancellationToken)
private TaskNode CreateAndAddAsyncWaiter()
private bool RemoveAsyncWaiter(TaskNode task)
private Task`1<bool> WaitUntilCountOrTimeoutAsync(TaskNode asyncWaiter, int millisecondsTimeout, CancellationToken cancellationToken)
public int Release()
public int Release(int releaseCount)
private void QueueWaiterTask(TaskNode waiterTask)
public void Dispose()
protected void Dispose(bool disposing)
private void CancellationTokenCanceledEventHandler(object obj)
private void CheckDispose()
private string GetResourceString(string str)
}
public System.Threading.SendOrPostCallback : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object state)
public IAsyncResult BeginInvoke(object state, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
internal System.Threading.SparselyPopulatedArray`1 : object {
private SparselyPopulatedArrayFragment`1 modreq(System.Runtime.CompilerServices.IsVolatile) m_tail
internal SparselyPopulatedArrayFragment`1<T> Tail
internal void .ctor(int initialSize)
internal SparselyPopulatedArrayFragment`1<T> get_Tail()
internal SparselyPopulatedArrayAddInfo`1<T> Add(T element)
}
internal System.Threading.SparselyPopulatedArrayAddInfo`1 : ValueType {
private SparselyPopulatedArrayFragment`1<T> m_source
private int m_index
internal SparselyPopulatedArrayFragment`1<T> Source
internal int Index
internal void .ctor(SparselyPopulatedArrayFragment`1<T> source, int index)
internal SparselyPopulatedArrayFragment`1<T> get_Source()
internal int get_Index()
}
internal System.Threading.SparselyPopulatedArrayFragment`1 : object {
internal T[] m_elements
internal Int32 modreq(System.Runtime.CompilerServices.IsVolatile) m_freeCount
internal SparselyPopulatedArrayFragment`1 modreq(System.Runtime.CompilerServices.IsVolatile) m_next
internal SparselyPopulatedArrayFragment`1 modreq(System.Runtime.CompilerServices.IsVolatile) m_prev
internal T Item
internal int Length
internal SparselyPopulatedArrayFragment`1<T> Prev
internal void .ctor(int size)
internal void .ctor(int size, SparselyPopulatedArrayFragment`1<T> prev)
internal T get_Item(int index)
internal int get_Length()
internal SparselyPopulatedArrayFragment`1<T> get_Prev()
internal T SafeAtomicRemove(int index, T expectedElement)
}
public System.Threading.SpinLock : ValueType {
private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) m_owner
private int SPINNING_FACTOR
private int SLEEP_ONE_FREQUENCY
private int SLEEP_ZERO_FREQUENCY
private int TIMEOUT_CHECK_FREQUENCY
private int LOCK_ID_DISABLE_MASK
private int LOCK_ANONYMOUS_OWNED
private int WAITERS_MASK
private int ID_DISABLED_AND_ANONYMOUS_OWNED
private int LOCK_UNOWNED
private int MAXIMUM_WAITERS
public bool IsHeld
public bool IsHeldByCurrentThread
public bool IsThreadOwnerTrackingEnabled
public void .ctor(bool enableThreadOwnerTracking)
public void Enter(Boolean& lockTaken)
public void TryEnter(Boolean& lockTaken)
public void TryEnter(TimeSpan timeout, Boolean& lockTaken)
public void TryEnter(int millisecondsTimeout, Boolean& lockTaken)
private void ContinueTryEnter(int millisecondsTimeout, Boolean& lockTaken)
private void DecrementWaiters()
private void ContinueTryEnterWithThreadTracking(int millisecondsTimeout, UInt32 startTime, Boolean& lockTaken)
public void Exit()
public void Exit(bool useMemoryBarrier)
private void ExitSlowPath(bool useMemoryBarrier)
public bool get_IsHeld()
public bool get_IsHeldByCurrentThread()
public bool get_IsThreadOwnerTrackingEnabled()
}
public System.Threading.SpinWait : ValueType {
internal int YIELD_THRESHOLD
internal int SLEEP_0_EVERY_HOW_MANY_TIMES
internal int SLEEP_1_EVERY_HOW_MANY_TIMES
private int m_count
public int Count
public bool NextSpinWillYield
public int get_Count()
public bool get_NextSpinWillYield()
public void SpinOnce()
public void Reset()
public void SpinUntil(Func`1<bool> condition)
public bool SpinUntil(Func`1<bool> condition, TimeSpan timeout)
public bool SpinUntil(Func`1<bool> condition, int millisecondsTimeout)
}
internal System.Threading.StackCrawlMark : Enum {
public int value__
public StackCrawlMark LookForMe
public StackCrawlMark LookForMyCaller
public StackCrawlMark LookForMyCallersCaller
public StackCrawlMark LookForThread
}
public System.Threading.SynchronizationContext : object {
private SynchronizationContextProperties _props
private Type s_cachedPreparedType1
private Type s_cachedPreparedType2
private Type s_cachedPreparedType3
private Type s_cachedPreparedType4
private Type s_cachedPreparedType5
public SynchronizationContext Current
internal SynchronizationContext CurrentNoFlow
protected void SetWaitNotificationRequired()
public bool IsWaitNotificationRequired()
public void Send(SendOrPostCallback d, object state)
public void Post(SendOrPostCallback d, object state)
public void OperationStarted()
public void OperationCompleted()
public int Wait(IntPtr[] waitHandles, bool waitAll, int millisecondsTimeout)
protected int WaitHelper(IntPtr[] waitHandles, bool waitAll, int millisecondsTimeout)
public void SetSynchronizationContext(SynchronizationContext syncContext)
public SynchronizationContext get_Current()
internal SynchronizationContext get_CurrentNoFlow()
private SynchronizationContext GetThreadLocalContext()
public SynchronizationContext CreateCopy()
private int InvokeWaitMethodHelper(SynchronizationContext syncContext, IntPtr[] waitHandles, bool waitAll, int millisecondsTimeout)
}
internal System.Threading.SynchronizationContextProperties : Enum {
public int value__
public SynchronizationContextProperties None
public SynchronizationContextProperties RequireWaitNotification
}
public System.Threading.SynchronizationLockException : SystemException {
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
protected void .ctor(SerializationInfo info, StreamingContext context)
}
internal System.Threading.SystemThreading_ThreadLocalDebugView`1 : object {
private ThreadLocal`1<T> m_tlocal
public bool IsValueCreated
public T Value
public List`1<T> Values
public void .ctor(ThreadLocal`1<T> tlocal)
public bool get_IsValueCreated()
public T get_Value()
public List`1<T> get_Values()
}
internal System.Threading.Tasks.AsyncCausalityStatus : Enum {
public int value__
public AsyncCausalityStatus Started
public AsyncCausalityStatus Completed
public AsyncCausalityStatus Canceled
public AsyncCausalityStatus Error
}
internal System.Threading.Tasks.AsyncCausalityTracer : object {
internal bool LoggingOn
internal void EnableToETW(bool enabled)
internal bool get_LoggingOn()
internal void TraceOperationCreation(CausalityTraceLevel traceLevel, int taskId, string operationName, ulong relatedContext)
internal void TraceOperationCompletion(CausalityTraceLevel traceLevel, int taskId, AsyncCausalityStatus status)
internal void TraceOperationRelation(CausalityTraceLevel traceLevel, int taskId, CausalityRelation relation)
internal void TraceSynchronousWorkStart(CausalityTraceLevel traceLevel, int taskId, CausalitySynchronousWork work)
internal void TraceSynchronousWorkCompletion(CausalityTraceLevel traceLevel, CausalitySynchronousWork work)
private ulong GetOperationId(UInt32 taskId)
}
internal System.Threading.Tasks.AwaitTaskContinuation : TaskContinuation {
private ExecutionContext m_capturedContext
protected Action m_action
private ContextCallback s_invokeActionCallback
internal bool IsValidLocationForInlining
internal void .ctor(Action action, bool flowExecutionContext, StackCrawlMark& stackMark)
internal void .ctor(Action action, bool flowExecutionContext)
protected Task CreateTask(Action`1<object> action, object state, TaskScheduler scheduler)
internal void Run(Task task, bool canInlineContinuationTask)
internal bool get_IsValidLocationForInlining()
private void ExecuteWorkItemHelper()
private void System.Threading.IThreadPoolWorkItem.ExecuteWorkItem()
private void System.Threading.IThreadPoolWorkItem.MarkAborted(ThreadAbortException tae)
private void InvokeAction(object state)
protected ContextCallback GetInvokeActionCallback()
protected void RunCallback(ContextCallback callback, object state, Task& currentTask)
internal void RunOrScheduleAction(Action action, bool allowInlining, Task& currentTask)
internal void UnsafeScheduleAction(Action action, Task task)
protected void ThrowAsyncIfNecessary(Exception exc)
internal Delegate[] GetDelegateContinuationsForDebugger()
}
internal System.Threading.Tasks.BeginEndAwaitableAdapter : object {
private Action CALLBACK_RAN
private IAsyncResult _asyncResult
private Action _continuation
public AsyncCallback Callback
public bool IsCompleted
public BeginEndAwaitableAdapter GetAwaiter()
public bool get_IsCompleted()
public void UnsafeOnCompleted(Action continuation)
public void OnCompleted(Action continuation)
public IAsyncResult GetResult()
}
internal System.Threading.Tasks.CausalityRelation : Enum {
public int value__
public CausalityRelation AssignDelegate
public CausalityRelation Join
public CausalityRelation Choice
public CausalityRelation Cancel
public CausalityRelation Error
}
internal System.Threading.Tasks.CausalitySynchronousWork : Enum {
public int value__
public CausalitySynchronousWork CompletionNotification
public CausalitySynchronousWork ProgressNotification
public CausalitySynchronousWork Execution
}
internal System.Threading.Tasks.CausalityTraceLevel : Enum {
public int value__
public CausalityTraceLevel Required
public CausalityTraceLevel Important
public CausalityTraceLevel Verbose
}
internal System.Threading.Tasks.CompletionActionInvoker : object {
private ITaskCompletionAction m_action
private Task m_completingTask
internal void .ctor(ITaskCompletionAction action, Task completingTask)
public void ExecuteWorkItem()
public void MarkAborted(ThreadAbortException tae)
}
public System.Threading.Tasks.ConcurrentExclusiveSchedulerPair : object {
private ConcurrentDictionary`2<int, ProcessingMode> m_threadProcessingMapping
private ConcurrentExclusiveTaskScheduler m_concurrentTaskScheduler
private ConcurrentExclusiveTaskScheduler m_exclusiveTaskScheduler
private TaskScheduler m_underlyingTaskScheduler
private int m_maxConcurrencyLevel
private int m_maxItemsPerTask
private int m_processingCount
private CompletionState m_completionState
private int UNLIMITED_PROCESSING
private int EXCLUSIVE_PROCESSING_SENTINEL
private int DEFAULT_MAXITEMSPERTASK
private int DefaultMaxConcurrencyLevel
private object ValueLock
public Task Completion
private bool CompletionRequested
private bool ReadyToComplete
public TaskScheduler ConcurrentScheduler
public TaskScheduler ExclusiveScheduler
private int ConcurrentTaskCountForDebugger
private int ExclusiveTaskCountForDebugger
private ProcessingMode ModeForDebugger
private int get_DefaultMaxConcurrencyLevel()
private object get_ValueLock()
public void .ctor(TaskScheduler taskScheduler)
public void .ctor(TaskScheduler taskScheduler, int maxConcurrencyLevel)
public void .ctor(TaskScheduler taskScheduler, int maxConcurrencyLevel, int maxItemsPerTask)
public void Complete()
public Task get_Completion()
private CompletionState EnsureCompletionStateInitialized()
private bool get_CompletionRequested()
private void RequestCompletion()
private void CleanupStateIfCompletingAndQuiesced()
private bool get_ReadyToComplete()
private void CompleteTaskAsync()
private void FaultWithTask(Task faultedTask)
public TaskScheduler get_ConcurrentScheduler()
public TaskScheduler get_ExclusiveScheduler()
private int get_ConcurrentTaskCountForDebugger()
private int get_ExclusiveTaskCountForDebugger()
private void ProcessAsyncIfNecessary(bool fairly)
private void ProcessExclusiveTasks()
private void ProcessConcurrentTasks()
private ProcessingMode get_ModeForDebugger()
internal void ContractAssertMonitorStatus(object syncObj, bool held)
internal TaskCreationOptions GetCreationOptionsForTask(bool isReplacementReplica)
}
internal System.Threading.Tasks.ContinuationResultTaskFromResultTask`2 : Task`1<TResult> {
private Task`1<TAntecedentResult> m_antecedent
public void .ctor(Task`1<TAntecedentResult> antecedent, Delegate function, object state, TaskCreationOptions creationOptions, InternalTaskOptions internalOptions, StackCrawlMark& stackMark)
internal void InnerInvoke()
}
internal System.Threading.Tasks.ContinuationResultTaskFromTask`1 : Task`1<TResult> {
private Task m_antecedent
public void .ctor(Task antecedent, Delegate function, object state, TaskCreationOptions creationOptions, InternalTaskOptions internalOptions, StackCrawlMark& stackMark)
internal void InnerInvoke()
}
internal System.Threading.Tasks.ContinuationTaskFromResultTask`1 : Task {
private Task`1<TAntecedentResult> m_antecedent
public void .ctor(Task`1<TAntecedentResult> antecedent, Delegate action, object state, TaskCreationOptions creationOptions, InternalTaskOptions internalOptions, StackCrawlMark& stackMark)
internal void InnerInvoke()
}
internal System.Threading.Tasks.ContinuationTaskFromTask : Task {
private Task m_antecedent
public void .ctor(Task antecedent, Delegate action, object state, TaskCreationOptions creationOptions, InternalTaskOptions internalOptions, StackCrawlMark& stackMark)
internal void InnerInvoke()
}
internal System.Threading.Tasks.DecoupledTask : object {
private Task <Task>k__BackingField
public bool IsCompleted
public Task Task
public void .ctor(Task task)
public bool get_IsCompleted()
public Task get_Task()
private void set_Task(Task value)
}
internal System.Threading.Tasks.DecoupledTask`1 : object {
private Task`1<T> <Task>k__BackingField
public bool IsCompleted
public Task`1<T> Task
public void .ctor(Task`1<T> task)
public bool get_IsCompleted()
public Task`1<T> get_Task()
private void set_Task(Task`1<T> value)
}
internal System.Threading.Tasks.GenericDelegateCache`2 : object {
internal Func`3<Task`1<Task>, object, TResult> CWAnyFuncDelegate
internal Func`3<Task`1<Task>, object, TResult> CWAnyActionDelegate
internal Func`3<Task`1<Task`1[]>, object, TResult> CWAllFuncDelegate
internal Func`3<Task`1<Task`1[]>, object, TResult> CWAllActionDelegate
}
internal System.Threading.Tasks.IDecoupledTask {
public bool IsCompleted
public bool get_IsCompleted()
}
internal System.Threading.Tasks.IndexRange : ValueType {
internal long m_nFromInclusive
internal long m_nToExclusive
internal Shared`1 modreq(System.Runtime.CompilerServices.IsVolatile) m_nSharedCurrentIndexOffset
internal int m_bRangeFinished
}
internal System.Threading.Tasks.InternalTaskOptions : Enum {
public int value__
public InternalTaskOptions None
public InternalTaskOptions InternalOptionsMask
public InternalTaskOptions ChildReplica
public InternalTaskOptions ContinuationTask
public InternalTaskOptions PromiseTask
public InternalTaskOptions SelfReplicating
public InternalTaskOptions LazyCancellation
public InternalTaskOptions QueuedByRuntime
public InternalTaskOptions DoNotDispose
}
internal System.Threading.Tasks.IProducerConsumerQueue`1 {
public bool IsEmpty
public int Count
public void Enqueue(T item)
public bool TryDequeue(T& result)
public bool get_IsEmpty()
public int get_Count()
public int GetCountSafe(object syncObj)
}
internal System.Threading.Tasks.ITaskCompletionAction {
public void Invoke(Task completingTask)
}
internal System.Threading.Tasks.MultiProducerMultiConsumerQueue`1 : ConcurrentQueue`1<T> {
private bool System.Threading.Tasks.IProducerConsumerQueue<T>.IsEmpty
private int System.Threading.Tasks.IProducerConsumerQueue<T>.Count
private void System.Threading.Tasks.IProducerConsumerQueue<T>.Enqueue(T item)
private bool System.Threading.Tasks.IProducerConsumerQueue<T>.TryDequeue(T& result)
private bool System.Threading.Tasks.IProducerConsumerQueue<T>.get_IsEmpty()
private int System.Threading.Tasks.IProducerConsumerQueue<T>.get_Count()
private int System.Threading.Tasks.IProducerConsumerQueue<T>.GetCountSafe(object syncObj)
}
internal System.Threading.Tasks.PaddingHelpers : object {
internal int CACHE_LINE_SIZE
}
public System.Threading.Tasks.Parallel : object {
internal int s_forkJoinContextID
internal int DEFAULT_LOOP_STRIDE
internal ParallelOptions s_defaultParallelOptions
public void Invoke(Action[] actions)
public void Invoke(ParallelOptions parallelOptions, Action[] actions)
public ParallelLoopResult For(int fromInclusive, int toExclusive, Action`1<int> body)
public ParallelLoopResult For(long fromInclusive, long toExclusive, Action`1<long> body)
public ParallelLoopResult For(int fromInclusive, int toExclusive, ParallelOptions parallelOptions, Action`1<int> body)
public ParallelLoopResult For(long fromInclusive, long toExclusive, ParallelOptions parallelOptions, Action`1<long> body)
public ParallelLoopResult For(int fromInclusive, int toExclusive, Action`2<int, ParallelLoopState> body)
public ParallelLoopResult For(long fromInclusive, long toExclusive, Action`2<long, ParallelLoopState> body)
public ParallelLoopResult For(int fromInclusive, int toExclusive, ParallelOptions parallelOptions, Action`2<int, ParallelLoopState> body)
public ParallelLoopResult For(long fromInclusive, long toExclusive, ParallelOptions parallelOptions, Action`2<long, ParallelLoopState> body)
public ParallelLoopResult For(int fromInclusive, int toExclusive, Func`1<TLocal> localInit, Func`4<int, ParallelLoopState, TLocal, TLocal> body, Action`1<TLocal> localFinally)
public ParallelLoopResult For(long fromInclusive, long toExclusive, Func`1<TLocal> localInit, Func`4<long, ParallelLoopState, TLocal, TLocal> body, Action`1<TLocal> localFinally)
public ParallelLoopResult For(int fromInclusive, int toExclusive, ParallelOptions parallelOptions, Func`1<TLocal> localInit, Func`4<int, ParallelLoopState, TLocal, TLocal> body, Action`1<TLocal> localFinally)
public ParallelLoopResult For(long fromInclusive, long toExclusive, ParallelOptions parallelOptions, Func`1<TLocal> localInit, Func`4<long, ParallelLoopState, TLocal, TLocal> body, Action`1<TLocal> localFinally)
private ParallelLoopResult ForWorker(int fromInclusive, int toExclusive, ParallelOptions parallelOptions, Action`1<int> body, Action`2<int, ParallelLoopState> bodyWithState, Func`4<int, ParallelLoopState, TLocal, TLocal> bodyWithLocal, Func`1<TLocal> localInit, Action`1<TLocal> localFinally)
private ParallelLoopResult ForWorker64(long fromInclusive, long toExclusive, ParallelOptions parallelOptions, Action`1<long> body, Action`2<long, ParallelLoopState> bodyWithState, Func`4<long, ParallelLoopState, TLocal, TLocal> bodyWithLocal, Func`1<TLocal> localInit, Action`1<TLocal> localFinally)
public ParallelLoopResult ForEach(IEnumerable`1<TSource> source, Action`1<TSource> body)
public ParallelLoopResult ForEach(IEnumerable`1<TSource> source, ParallelOptions parallelOptions, Action`1<TSource> body)
public ParallelLoopResult ForEach(IEnumerable`1<TSource> source, Action`2<TSource, ParallelLoopState> body)
public ParallelLoopResult ForEach(IEnumerable`1<TSource> source, ParallelOptions parallelOptions, Action`2<TSource, ParallelLoopState> body)
public ParallelLoopResult ForEach(IEnumerable`1<TSource> source, Action`3<TSource, ParallelLoopState, long> body)
public ParallelLoopResult ForEach(IEnumerable`1<TSource> source, ParallelOptions parallelOptions, Action`3<TSource, ParallelLoopState, long> body)
public ParallelLoopResult ForEach(IEnumerable`1<TSource> source, Func`1<TLocal> localInit, Func`4<TSource, ParallelLoopState, TLocal, TLocal> body, Action`1<TLocal> localFinally)
public ParallelLoopResult ForEach(IEnumerable`1<TSource> source, ParallelOptions parallelOptions, Func`1<TLocal> localInit, Func`4<TSource, ParallelLoopState, TLocal, TLocal> body, Action`1<TLocal> localFinally)
public ParallelLoopResult ForEach(IEnumerable`1<TSource> source, Func`1<TLocal> localInit, Func`5<TSource, ParallelLoopState, long, TLocal, TLocal> body, Action`1<TLocal> localFinally)
public ParallelLoopResult ForEach(IEnumerable`1<TSource> source, ParallelOptions parallelOptions, Func`1<TLocal> localInit, Func`5<TSource, ParallelLoopState, long, TLocal, TLocal> body, Action`1<TLocal> localFinally)
private ParallelLoopResult ForEachWorker(IEnumerable`1<TSource> source, ParallelOptions parallelOptions, Action`1<TSource> body, Action`2<TSource, ParallelLoopState> bodyWithState, Action`3<TSource, ParallelLoopState, long> bodyWithStateAndIndex, Func`4<TSource, ParallelLoopState, TLocal, TLocal> bodyWithStateAndLocal, Func`5<TSource, ParallelLoopState, long, TLocal, TLocal> bodyWithEverything, Func`1<TLocal> localInit, Action`1<TLocal> localFinally)
private ParallelLoopResult ForEachWorker(TSource[] array, ParallelOptions parallelOptions, Action`1<TSource> body, Action`2<TSource, ParallelLoopState> bodyWithState, Action`3<TSource, ParallelLoopState, long> bodyWithStateAndIndex, Func`4<TSource, ParallelLoopState, TLocal, TLocal> bodyWithStateAndLocal, Func`5<TSource, ParallelLoopState, long, TLocal, TLocal> bodyWithEverything, Func`1<TLocal> localInit, Action`1<TLocal> localFinally)
private ParallelLoopResult ForEachWorker(IList`1<TSource> list, ParallelOptions parallelOptions, Action`1<TSource> body, Action`2<TSource, ParallelLoopState> bodyWithState, Action`3<TSource, ParallelLoopState, long> bodyWithStateAndIndex, Func`4<TSource, ParallelLoopState, TLocal, TLocal> bodyWithStateAndLocal, Func`5<TSource, ParallelLoopState, long, TLocal, TLocal> bodyWithEverything, Func`1<TLocal> localInit, Action`1<TLocal> localFinally)
public ParallelLoopResult ForEach(Partitioner`1<TSource> source, Action`1<TSource> body)
public ParallelLoopResult ForEach(Partitioner`1<TSource> source, Action`2<TSource, ParallelLoopState> body)
public ParallelLoopResult ForEach(OrderablePartitioner`1<TSource> source, Action`3<TSource, ParallelLoopState, long> body)
public ParallelLoopResult ForEach(Partitioner`1<TSource> source, Func`1<TLocal> localInit, Func`4<TSource, ParallelLoopState, TLocal, TLocal> body, Action`1<TLocal> localFinally)
public ParallelLoopResult ForEach(OrderablePartitioner`1<TSource> source, Func`1<TLocal> localInit, Func`5<TSource, ParallelLoopState, long, TLocal, TLocal> body, Action`1<TLocal> localFinally)
public ParallelLoopResult ForEach(Partitioner`1<TSource> source, ParallelOptions parallelOptions, Action`1<TSource> body)
public ParallelLoopResult ForEach(Partitioner`1<TSource> source, ParallelOptions parallelOptions, Action`2<TSource, ParallelLoopState> body)
public ParallelLoopResult ForEach(OrderablePartitioner`1<TSource> source, ParallelOptions parallelOptions, Action`3<TSource, ParallelLoopState, long> body)
public ParallelLoopResult ForEach(Partitioner`1<TSource> source, ParallelOptions parallelOptions, Func`1<TLocal> localInit, Func`4<TSource, ParallelLoopState, TLocal, TLocal> body, Action`1<TLocal> localFinally)
public ParallelLoopResult ForEach(OrderablePartitioner`1<TSource> source, ParallelOptions parallelOptions, Func`1<TLocal> localInit, Func`5<TSource, ParallelLoopState, long, TLocal, TLocal> body, Action`1<TLocal> localFinally)
private ParallelLoopResult PartitionerForEachWorker(Partitioner`1<TSource> source, ParallelOptions parallelOptions, Action`1<TSource> simpleBody, Action`2<TSource, ParallelLoopState> bodyWithState, Action`3<TSource, ParallelLoopState, long> bodyWithStateAndIndex, Func`4<TSource, ParallelLoopState, TLocal, TLocal> bodyWithStateAndLocal, Func`5<TSource, ParallelLoopState, long, TLocal, TLocal> bodyWithEverything, Func`1<TLocal> localInit, Action`1<TLocal> localFinally)
internal void ThrowIfReducableToSingleOCE(IEnumerable`1<Exception> excCollection, CancellationToken ct)
}
internal System.Threading.Tasks.ParallelForReplicaTask : Task {
internal object m_stateForNextReplica
internal object m_stateFromPreviousReplica
internal Task m_handedOverChildReplica
internal object SavedStateForNextReplica
internal object SavedStateFromPreviousReplica
internal Task HandedOverChildReplica
internal void .ctor(Action`1<object> taskReplicaDelegate, object stateObject, Task parentTask, TaskScheduler taskScheduler, TaskCreationOptions creationOptionsForReplica, InternalTaskOptions internalOptionsForReplica)
internal object get_SavedStateForNextReplica()
internal void set_SavedStateForNextReplica(object value)
internal object get_SavedStateFromPreviousReplica()
internal void set_SavedStateFromPreviousReplica(object value)
internal Task get_HandedOverChildReplica()
internal void set_HandedOverChildReplica(Task value)
}
internal System.Threading.Tasks.ParallelForReplicatingTask : Task {
private int m_replicationDownCount
internal void .ctor(ParallelOptions parallelOptions, Action action, TaskCreationOptions creationOptions, InternalTaskOptions internalOptions)
internal bool ShouldReplicate()
internal Task CreateReplicaTask(Action`1<object> taskReplicaDelegate, object stateObject, Task parentTask, TaskScheduler taskScheduler, TaskCreationOptions creationOptionsForReplica, InternalTaskOptions internalOptionsForReplica)
}
public System.Threading.Tasks.ParallelLoopResult : ValueType {
internal bool m_completed
internal Nullable`1<long> m_lowestBreakIteration
public bool IsCompleted
public Nullable`1<long> LowestBreakIteration
public bool get_IsCompleted()
public Nullable`1<long> get_LowestBreakIteration()
}
public System.Threading.Tasks.ParallelLoopState : object {
private ParallelLoopStateFlags m_flagsBase
internal bool InternalShouldExitCurrentIteration
public bool ShouldExitCurrentIteration
public bool IsStopped
public bool IsExceptional
internal Nullable`1<long> InternalLowestBreakIteration
public Nullable`1<long> LowestBreakIteration
internal void .ctor(ParallelLoopStateFlags fbase)
internal bool get_InternalShouldExitCurrentIteration()
public bool get_ShouldExitCurrentIteration()
public bool get_IsStopped()
public bool get_IsExceptional()
internal Nullable`1<long> get_InternalLowestBreakIteration()
public Nullable`1<long> get_LowestBreakIteration()
public void Stop()
internal void InternalBreak()
public void Break()
internal void Break(int iteration, ParallelLoopStateFlags32 pflags)
internal void Break(long iteration, ParallelLoopStateFlags64 pflags)
}
internal System.Threading.Tasks.ParallelLoopState32 : ParallelLoopState {
private ParallelLoopStateFlags32 m_sharedParallelStateFlags
private int m_currentIteration
internal int CurrentIteration
internal bool InternalShouldExitCurrentIteration
internal Nullable`1<long> InternalLowestBreakIteration
internal void .ctor(ParallelLoopStateFlags32 sharedParallelStateFlags)
internal int get_CurrentIteration()
internal void set_CurrentIteration(int value)
internal bool get_InternalShouldExitCurrentIteration()
internal Nullable`1<long> get_InternalLowestBreakIteration()
internal void InternalBreak()
}
internal System.Threading.Tasks.ParallelLoopState64 : ParallelLoopState {
private ParallelLoopStateFlags64 m_sharedParallelStateFlags
private long m_currentIteration
internal long CurrentIteration
internal bool InternalShouldExitCurrentIteration
internal Nullable`1<long> InternalLowestBreakIteration
internal void .ctor(ParallelLoopStateFlags64 sharedParallelStateFlags)
internal long get_CurrentIteration()
internal void set_CurrentIteration(long value)
internal bool get_InternalShouldExitCurrentIteration()
internal Nullable`1<long> get_InternalLowestBreakIteration()
internal void InternalBreak()
}
internal System.Threading.Tasks.ParallelLoopStateFlags : object {
internal int PLS_NONE
internal int PLS_EXCEPTIONAL
internal int PLS_BROKEN
internal int PLS_STOPPED
internal int PLS_CANCELED
private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) m_LoopStateFlags
internal int LoopStateFlags
internal int get_LoopStateFlags()
internal bool AtomicLoopStateUpdate(int newState, int illegalStates)
internal bool AtomicLoopStateUpdate(int newState, int illegalStates, Int32& oldState)
internal void SetExceptional()
internal void Stop()
internal bool Cancel()
}
internal System.Threading.Tasks.ParallelLoopStateFlags32 : ParallelLoopStateFlags {
internal Int32 modreq(System.Runtime.CompilerServices.IsVolatile) m_lowestBreakIteration
internal int LowestBreakIteration
internal Nullable`1<long> NullableLowestBreakIteration
internal int get_LowestBreakIteration()
internal Nullable`1<long> get_NullableLowestBreakIteration()
internal bool ShouldExitLoop(int CallerIteration)
internal bool ShouldExitLoop()
}
internal System.Threading.Tasks.ParallelLoopStateFlags64 : ParallelLoopStateFlags {
internal long m_lowestBreakIteration
internal long LowestBreakIteration
internal Nullable`1<long> NullableLowestBreakIteration
internal long get_LowestBreakIteration()
internal Nullable`1<long> get_NullableLowestBreakIteration()
internal bool ShouldExitLoop(long CallerIteration)
internal bool ShouldExitLoop()
}
public System.Threading.Tasks.ParallelOptions : object {
private TaskScheduler m_scheduler
private int m_maxDegreeOfParallelism
private CancellationToken m_cancellationToken
public TaskScheduler TaskScheduler
internal TaskScheduler EffectiveTaskScheduler
public int MaxDegreeOfParallelism
public CancellationToken CancellationToken
internal int EffectiveMaxConcurrencyLevel
public TaskScheduler get_TaskScheduler()
public void set_TaskScheduler(TaskScheduler value)
internal TaskScheduler get_EffectiveTaskScheduler()
public int get_MaxDegreeOfParallelism()
public void set_MaxDegreeOfParallelism(int value)
public CancellationToken get_CancellationToken()
public void set_CancellationToken(CancellationToken value)
internal int get_EffectiveMaxConcurrencyLevel()
}
internal System.Threading.Tasks.RangeManager : object {
internal IndexRange[] m_indexRanges
internal bool _use32BitCurrentIndex
internal int m_nCurrentIndexRangeToAssign
internal long m_nStep
internal void .ctor(long nFromInclusive, long nToExclusive, long nStep, int nNumExpectedWorkers)
internal RangeWorker RegisterNewWorker()
}
internal System.Threading.Tasks.RangeWorker : ValueType {
internal IndexRange[] m_indexRanges
internal int m_nCurrentIndexRange
internal long m_nStep
internal long m_nIncrementValue
internal long m_nMaxIncrementValue
internal bool _use32BitCurrentIndex
internal void .ctor(IndexRange[] ranges, int nInitialRange, long nStep, bool use32BitCurrentIndex)
internal bool FindNewWork(Int64& nFromInclusiveLocal, Int64& nToExclusiveLocal)
internal bool FindNewWork32(Int32& nFromInclusiveLocal32, Int32& nToExclusiveLocal32)
}
internal System.Threading.Tasks.Shared`1 : object {
internal T Value
internal void .ctor(T value)
}
internal System.Threading.Tasks.SingleProducerSingleConsumerQueue`1 : object {
private int INIT_SEGMENT_SIZE
private int MAX_SEGMENT_SIZE
private Segment modreq(System.Runtime.CompilerServices.IsVolatile) m_head
private Segment modreq(System.Runtime.CompilerServices.IsVolatile) m_tail
public bool IsEmpty
public int Count
public void Enqueue(T item)
private void EnqueueSlow(T item, Segment& segment)
public bool TryDequeue(T& result)
private bool TryDequeueSlow(Segment& segment, T[]& array, T& result)
public bool TryPeek(T& result)
private bool TryPeekSlow(Segment& segment, T[]& array, T& result)
public bool TryDequeueIf(Predicate`1<T> predicate, T& result)
private bool TryDequeueIfSlow(Predicate`1<T> predicate, Segment& segment, T[]& array, T& result)
public void Clear()
public bool get_IsEmpty()
public IEnumerator`1<T> GetEnumerator()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
public int get_Count()
private int System.Threading.Tasks.IProducerConsumerQueue<T>.GetCountSafe(object syncObj)
}
internal System.Threading.Tasks.StackGuard : object {
private int m_inliningDepth
private int MAX_UNCHECKED_INLINING_DEPTH
internal bool TryBeginInliningScope()
internal void EndInliningScope()
private bool CheckForSufficientStack()
}
internal System.Threading.Tasks.StandardTaskContinuation : TaskContinuation {
internal Task m_task
internal TaskContinuationOptions m_options
private TaskScheduler m_taskScheduler
internal void .ctor(Task task, TaskContinuationOptions options, TaskScheduler scheduler)
internal void Run(Task completedTask, bool bCanInlineContinuationTask)
internal Delegate[] GetDelegateContinuationsForDebugger()
}
internal System.Threading.Tasks.SynchronizationContextAwaitTaskContinuation : AwaitTaskContinuation {
private SendOrPostCallback s_postCallback
private ContextCallback s_postActionCallback
private SynchronizationContext m_syncContext
internal void .ctor(SynchronizationContext context, Action action, bool flowExecutionContext, StackCrawlMark& stackMark)
internal void Run(Task task, bool canInlineContinuationTask)
private void PostAction(object state)
private ContextCallback GetPostActionCallback()
}
internal System.Threading.Tasks.SynchronizationContextTaskScheduler : TaskScheduler {
private SynchronizationContext m_synchronizationContext
private SendOrPostCallback s_postCallback
public int MaximumConcurrencyLevel
protected internal void QueueTask(Task task)
protected bool TryExecuteTaskInline(Task task, bool taskWasPreviouslyQueued)
protected IEnumerable`1<Task> GetScheduledTasks()
public int get_MaximumConcurrencyLevel()
private void PostCallback(object obj)
}
internal System.Threading.Tasks.SystemThreadingTasks_FutureDebugView`1 : object {
private Task`1<TResult> m_task
public TResult Result
public object AsyncState
public TaskCreationOptions CreationOptions
public Exception Exception
public int Id
public bool CancellationPending
public TaskStatus Status
public void .ctor(Task`1<TResult> task)
public TResult get_Result()
public object get_AsyncState()
public TaskCreationOptions get_CreationOptions()
public Exception get_Exception()
public int get_Id()
public bool get_CancellationPending()
public TaskStatus get_Status()
}
internal System.Threading.Tasks.SystemThreadingTasks_TaskDebugView : object {
private Task m_task
public object AsyncState
public TaskCreationOptions CreationOptions
public Exception Exception
public int Id
public bool CancellationPending
public TaskStatus Status
public void .ctor(Task task)
public object get_AsyncState()
public TaskCreationOptions get_CreationOptions()
public Exception get_Exception()
public int get_Id()
public bool get_CancellationPending()
public TaskStatus get_Status()
}
public System.Threading.Tasks.Task : object {
internal Task t_currentTask
private StackGuard t_stackGuard
internal int s_taskIdCounter
private TaskFactory s_factory
private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) m_taskId
internal object m_action
internal object m_stateObject
internal TaskScheduler m_taskScheduler
internal Task m_parent
internal Int32 modreq(System.Runtime.CompilerServices.IsVolatile) m_stateFlags
private int OptionsMask
internal int TASK_STATE_STARTED
internal int TASK_STATE_DELEGATE_INVOKED
internal int TASK_STATE_DISPOSED
internal int TASK_STATE_EXCEPTIONOBSERVEDBYPARENT
internal int TASK_STATE_CANCELLATIONACKNOWLEDGED
internal int TASK_STATE_FAULTED
internal int TASK_STATE_CANCELED
internal int TASK_STATE_WAITING_ON_CHILDREN
internal int TASK_STATE_RAN_TO_COMPLETION
internal int TASK_STATE_WAITINGFORACTIVATION
internal int TASK_STATE_COMPLETION_RESERVED
internal int TASK_STATE_THREAD_WAS_ABORTED
internal int TASK_STATE_WAIT_COMPLETION_NOTIFICATION
internal int TASK_STATE_EXECUTIONCONTEXT_IS_NULL
internal int TASK_STATE_TASKSCHEDULED_WAS_FIRED
private int TASK_STATE_COMPLETED_MASK
private int CANCELLATION_REQUESTED
private Object modreq(System.Runtime.CompilerServices.IsVolatile) m_continuationObject
private object s_taskCompletionSentinel
internal bool s_asyncDebuggingEnabled
private Dictionary`2<int, Task> s_currentActiveTasks
private object s_activeTasksLock
internal ContingentProperties modreq(System.Runtime.CompilerServices.IsVolatile) m_contingentProperties
private Action`1<object> s_taskCancelCallback
private Func`1<ContingentProperties> s_createContingentProperties
private Task s_completedTask
private Predicate`1<Task> s_IsExceptionObservedByParentPredicate
private ContextCallback s_ecCallback
private Predicate`1<object> s_IsTaskContinuationNullPredicate
private string DebuggerDisplayMethodDescription
internal TaskCreationOptions Options
internal bool IsWaitNotificationEnabledOrNotRanToCompletion
internal bool ShouldNotifyDebuggerOfWaitCompletion
internal bool IsWaitNotificationEnabled
public int Id
public Nullable`1<int> CurrentId
internal Task InternalCurrent
internal StackGuard CurrentStackGuard
public AggregateException Exception
public TaskStatus Status
public bool IsCanceled
internal bool IsCancellationRequested
internal CancellationToken CancellationToken
internal bool IsCancellationAcknowledged
public bool IsCompleted
public bool IsCompletedSuccessfully
internal bool IsRanToCompletion
public TaskCreationOptions CreationOptions
private WaitHandle System.IAsyncResult.AsyncWaitHandle
public object AsyncState
private bool System.IAsyncResult.CompletedSynchronously
internal TaskScheduler ExecutingTaskScheduler
public TaskFactory Factory
public Task CompletedTask
internal ManualResetEventSlim CompletedEvent
internal bool IsSelfReplicatingRoot
internal bool IsChildReplica
internal int ActiveChildCount
internal bool ExceptionRecorded
public bool IsFaulted
internal ExecutionContext CapturedContext
internal bool IsExceptionObservedByParent
internal bool IsDelegateInvoked
internal object SavedStateForNextReplica
internal object SavedStateFromPreviousReplica
internal Task HandedOverChildReplica
internal bool AddToActiveTasks(Task task)
internal void RemoveFromActiveTasks(int taskId)
internal void .ctor(bool canceled, TaskCreationOptions creationOptions, CancellationToken ct)
internal void .ctor(object state, TaskCreationOptions creationOptions, bool promiseStyle)
public void .ctor(Action action)
public void .ctor(Action action, CancellationToken cancellationToken)
public void .ctor(Action action, TaskCreationOptions creationOptions)
public void .ctor(Action action, CancellationToken cancellationToken, TaskCreationOptions creationOptions)
public void .ctor(Action`1<object> action, object state)
public void .ctor(Action`1<object> action, object state, CancellationToken cancellationToken)
public void .ctor(Action`1<object> action, object state, TaskCreationOptions creationOptions)
public void .ctor(Action`1<object> action, object state, CancellationToken cancellationToken, TaskCreationOptions creationOptions)
internal void .ctor(Action`1<object> action, object state, Task parent, CancellationToken cancellationToken, TaskCreationOptions creationOptions, InternalTaskOptions internalOptions, TaskScheduler scheduler, StackCrawlMark& stackMark)
internal void .ctor(Delegate action, object state, Task parent, CancellationToken cancellationToken, TaskCreationOptions creationOptions, InternalTaskOptions internalOptions, TaskScheduler scheduler)
internal void TaskConstructorCore(object action, object state, CancellationToken cancellationToken, TaskCreationOptions creationOptions, InternalTaskOptions internalOptions, TaskScheduler scheduler)
private void AssignCancellationToken(CancellationToken cancellationToken, Task antecedent, TaskContinuation continuation)
private void TaskCancelCallback(object o)
private string get_DebuggerDisplayMethodDescription()
internal void PossiblyCaptureContext(StackCrawlMark& stackMark)
internal TaskCreationOptions get_Options()
internal TaskCreationOptions OptionsMethod(int flags)
internal bool AtomicStateUpdate(int newBits, int illegalBits)
internal bool AtomicStateUpdate(int newBits, int illegalBits, Int32& oldFlags)
internal void SetNotificationForWaitCompletion(bool enabled)
internal bool NotifyDebuggerOfWaitCompletionIfNecessary()
internal bool AnyTaskRequiresNotifyDebuggerOfWaitCompletion(Task[] tasks)
internal bool get_IsWaitNotificationEnabledOrNotRanToCompletion()
internal bool get_ShouldNotifyDebuggerOfWaitCompletion()
internal bool get_IsWaitNotificationEnabled()
private void NotifyDebuggerOfWaitCompletion()
internal bool MarkStarted()
internal bool FireTaskScheduledIfNeeded(TaskScheduler ts)
internal void AddNewChild()
internal void DisregardChild()
public void Start()
public void Start(TaskScheduler scheduler)
public void RunSynchronously()
public void RunSynchronously(TaskScheduler scheduler)
internal void InternalRunSynchronously(TaskScheduler scheduler, bool waitForCompletion)
internal Task InternalStartNew(Task creatingTask, Delegate action, object state, CancellationToken cancellationToken, TaskScheduler scheduler, TaskCreationOptions options, InternalTaskOptions internalOptions, StackCrawlMark& stackMark)
internal int NewId()
public int get_Id()
public Nullable`1<int> get_CurrentId()
internal Task get_InternalCurrent()
internal Task InternalCurrentIfAttached(TaskCreationOptions creationOptions)
internal StackGuard get_CurrentStackGuard()
public AggregateException get_Exception()
public TaskStatus get_Status()
public bool get_IsCanceled()
internal bool get_IsCancellationRequested()
internal ContingentProperties EnsureContingentPropertiesInitialized(bool needsProtection)
private ContingentProperties EnsureContingentPropertiesInitializedCore(bool needsProtection)
internal CancellationToken get_CancellationToken()
internal bool get_IsCancellationAcknowledged()
public bool get_IsCompleted()
private bool IsCompletedMethod(int flags)
public bool get_IsCompletedSuccessfully()
internal bool get_IsRanToCompletion()
public TaskCreationOptions get_CreationOptions()
private WaitHandle System.IAsyncResult.get_AsyncWaitHandle()
public object get_AsyncState()
private bool System.IAsyncResult.get_CompletedSynchronously()
internal TaskScheduler get_ExecutingTaskScheduler()
public TaskFactory get_Factory()
public Task get_CompletedTask()
internal ManualResetEventSlim get_CompletedEvent()
internal bool get_IsSelfReplicatingRoot()
internal bool get_IsChildReplica()
internal int get_ActiveChildCount()
internal bool get_ExceptionRecorded()
public bool get_IsFaulted()
internal ExecutionContext get_CapturedContext()
internal void set_CapturedContext(ExecutionContext value)
private ExecutionContext CopyExecutionContext(ExecutionContext capturedContext)
public void Dispose()
protected void Dispose(bool disposing)
internal void ScheduleAndStart(bool needsProtection)
internal void AddException(object exceptionObject)
internal void AddException(object exceptionObject, bool representsCancellation)
private AggregateException GetExceptions(bool includeTaskCanceledExceptions)
internal ReadOnlyCollection`1<ExceptionDispatchInfo> GetExceptionDispatchInfos()
internal ExceptionDispatchInfo GetCancellationExceptionDispatchInfo()
internal void ThrowIfExceptional(bool includeTaskCanceledExceptions)
internal void UpdateExceptionObservedStatus()
internal bool get_IsExceptionObservedByParent()
internal bool get_IsDelegateInvoked()
internal void Finish(bool bUserDelegateExecuted)
internal void FinishStageTwo()
internal void FinishStageThree()
internal void ProcessChildCompletion(Task childTask)
internal void AddExceptionsFromChildren()
internal void FinishThreadAbortedTask(bool bTAEAddedToExceptionHolder, bool delegateRan)
private void Execute()
internal bool ShouldReplicate()
internal Task CreateReplicaTask(Action`1<object> taskReplicaDelegate, object stateObject, Task parentTask, TaskScheduler taskScheduler, TaskCreationOptions creationOptionsForReplica, InternalTaskOptions internalOptionsForReplica)
internal object get_SavedStateForNextReplica()
internal void set_SavedStateForNextReplica(object value)
internal object get_SavedStateFromPreviousReplica()
internal void set_SavedStateFromPreviousReplica(object value)
internal Task get_HandedOverChildReplica()
internal void set_HandedOverChildReplica(Task value)
private void ExecuteSelfReplicating(Task root)
private void System.Threading.IThreadPoolWorkItem.ExecuteWorkItem()
private void System.Threading.IThreadPoolWorkItem.MarkAborted(ThreadAbortException tae)
internal bool ExecuteEntry(bool bPreventDoubleExecution)
private void ExecuteWithThreadLocal(Task& currentTaskSlot)
private void ExecutionContextCallback(object obj)
internal void InnerInvoke()
internal void InnerInvokeWithArg(Task childTask)
private void HandleException(Exception unhandledException)
public TaskAwaiter GetAwaiter()
public ConfiguredTaskAwaitable ConfigureAwait(bool continueOnCapturedContext)
internal void SetContinuationForAwait(Action continuationAction, bool continueOnCapturedContext, bool flowExecutionContext, StackCrawlMark& stackMark)
public YieldAwaitable Yield()
public void Wait()
public bool Wait(TimeSpan timeout)
public void Wait(CancellationToken cancellationToken)
public bool Wait(int millisecondsTimeout)
public bool Wait(int millisecondsTimeout, CancellationToken cancellationToken)
private bool WrappedTryRunInline()
internal bool InternalWait(int millisecondsTimeout, CancellationToken cancellationToken)
private bool SpinThenBlockingWait(int millisecondsTimeout, CancellationToken cancellationToken)
private bool SpinWait(int millisecondsTimeout)
internal bool InternalCancel(bool bCancelNonExecutingOnly)
internal void RecordInternalCancellationRequest()
internal void RecordInternalCancellationRequest(CancellationToken tokenToRecord)
internal void RecordInternalCancellationRequest(CancellationToken tokenToRecord, object cancellationException)
internal void CancellationCleanupLogic()
private void SetCancellationAcknowledged()
internal void FinishContinuations()
private void LogFinishCompletionNotification()
public Task ContinueWith(Action`1<Task> continuationAction)
public Task ContinueWith(Action`1<Task> continuationAction, CancellationToken cancellationToken)
public Task ContinueWith(Action`1<Task> continuationAction, TaskScheduler scheduler)
public Task ContinueWith(Action`1<Task> continuationAction, TaskContinuationOptions continuationOptions)
public Task ContinueWith(Action`1<Task> continuationAction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler)
private Task ContinueWith(Action`1<Task> continuationAction, TaskScheduler scheduler, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, StackCrawlMark& stackMark)
public Task ContinueWith(Action`2<Task, object> continuationAction, object state)
public Task ContinueWith(Action`2<Task, object> continuationAction, object state, CancellationToken cancellationToken)
public Task ContinueWith(Action`2<Task, object> continuationAction, object state, TaskScheduler scheduler)
public Task ContinueWith(Action`2<Task, object> continuationAction, object state, TaskContinuationOptions continuationOptions)
public Task ContinueWith(Action`2<Task, object> continuationAction, object state, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler)
private Task ContinueWith(Action`2<Task, object> continuationAction, object state, TaskScheduler scheduler, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, StackCrawlMark& stackMark)
public Task`1<TResult> ContinueWith(Func`2<Task, TResult> continuationFunction)
public Task`1<TResult> ContinueWith(Func`2<Task, TResult> continuationFunction, CancellationToken cancellationToken)
public Task`1<TResult> ContinueWith(Func`2<Task, TResult> continuationFunction, TaskScheduler scheduler)
public Task`1<TResult> ContinueWith(Func`2<Task, TResult> continuationFunction, TaskContinuationOptions continuationOptions)
public Task`1<TResult> ContinueWith(Func`2<Task, TResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler)
private Task`1<TResult> ContinueWith(Func`2<Task, TResult> continuationFunction, TaskScheduler scheduler, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, StackCrawlMark& stackMark)
public Task`1<TResult> ContinueWith(Func`3<Task, object, TResult> continuationFunction, object state)
public Task`1<TResult> ContinueWith(Func`3<Task, object, TResult> continuationFunction, object state, CancellationToken cancellationToken)
public Task`1<TResult> ContinueWith(Func`3<Task, object, TResult> continuationFunction, object state, TaskScheduler scheduler)
public Task`1<TResult> ContinueWith(Func`3<Task, object, TResult> continuationFunction, object state, TaskContinuationOptions continuationOptions)
public Task`1<TResult> ContinueWith(Func`3<Task, object, TResult> continuationFunction, object state, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler)
private Task`1<TResult> ContinueWith(Func`3<Task, object, TResult> continuationFunction, object state, TaskScheduler scheduler, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, StackCrawlMark& stackMark)
internal void CreationOptionsFromContinuationOptions(TaskContinuationOptions continuationOptions, TaskCreationOptions& creationOptions, InternalTaskOptions& internalOptions)
internal void ContinueWithCore(Task continuationTask, TaskScheduler scheduler, CancellationToken cancellationToken, TaskContinuationOptions options)
internal void AddCompletionAction(ITaskCompletionAction action)
private void AddCompletionAction(ITaskCompletionAction action, bool addBeforeOthers)
private bool AddTaskContinuationComplex(object tc, bool addBeforeOthers)
private bool AddTaskContinuation(object tc, bool addBeforeOthers)
internal void RemoveContinuation(object continuationObject)
public void WaitAll(Task[] tasks)
public bool WaitAll(Task[] tasks, TimeSpan timeout)
public bool WaitAll(Task[] tasks, int millisecondsTimeout)
public void WaitAll(Task[] tasks, CancellationToken cancellationToken)
public bool WaitAll(Task[] tasks, int millisecondsTimeout, CancellationToken cancellationToken)
private void AddToList(T item, List`1& list, int initSize)
private bool WaitAllBlockingCore(List`1<Task> tasks, int millisecondsTimeout, CancellationToken cancellationToken)
internal void FastWaitAll(Task[] tasks)
internal void AddExceptionsForCompletedTask(List`1& exceptions, Task t)
public int WaitAny(Task[] tasks)
public int WaitAny(Task[] tasks, TimeSpan timeout)
public int WaitAny(Task[] tasks, CancellationToken cancellationToken)
public int WaitAny(Task[] tasks, int millisecondsTimeout)
public int WaitAny(Task[] tasks, int millisecondsTimeout, CancellationToken cancellationToken)
public Task`1<TResult> FromResult(TResult result)
public Task FromException(Exception exception)
public Task`1<TResult> FromException(Exception exception)
internal Task FromCancellation(CancellationToken cancellationToken)
public Task FromCanceled(CancellationToken cancellationToken)
internal Task`1<TResult> FromCancellation(CancellationToken cancellationToken)
public Task`1<TResult> FromCanceled(CancellationToken cancellationToken)
internal Task`1<TResult> FromCancellation(OperationCanceledException exception)
public Task Run(Action action)
public Task Run(Action action, CancellationToken cancellationToken)
public Task`1<TResult> Run(Func`1<TResult> function)
public Task`1<TResult> Run(Func`1<TResult> function, CancellationToken cancellationToken)
public Task Run(Func`1<Task> function)
public Task Run(Func`1<Task> function, CancellationToken cancellationToken)
public Task`1<TResult> Run(Func`1<Task`1<TResult>> function)
public Task`1<TResult> Run(Func`1<Task`1<TResult>> function, CancellationToken cancellationToken)
public Task Delay(TimeSpan delay)
public Task Delay(TimeSpan delay, CancellationToken cancellationToken)
public Task Delay(int millisecondsDelay)
public Task Delay(int millisecondsDelay, CancellationToken cancellationToken)
public Task WhenAll(IEnumerable`1<Task> tasks)
public Task WhenAll(Task[] tasks)
private Task InternalWhenAll(Task[] tasks)
public Task`1<TResult[]> WhenAll(IEnumerable`1<Task`1<TResult>> tasks)
public Task`1<TResult[]> WhenAll(Task`1[] tasks)
private Task`1<TResult[]> InternalWhenAll(Task`1[] tasks)
public Task`1<Task> WhenAny(Task[] tasks)
public Task`1<Task> WhenAny(IEnumerable`1<Task> tasks)
public Task`1<Task`1<TResult>> WhenAny(Task`1[] tasks)
public Task`1<Task`1<TResult>> WhenAny(IEnumerable`1<Task`1<TResult>> tasks)
internal Task`1<TResult> CreateUnwrapPromise(Task outerTask, bool lookForOce)
internal Delegate[] GetDelegateContinuationsForDebugger()
internal Delegate[] GetDelegatesFromContinuationObject(object continuationObject)
private Task GetActiveTaskFromId(int taskId)
private Task[] GetActiveTasks()
}
public System.Threading.Tasks.Task`1 : Task {
internal TResult m_result
private TaskFactory`1<TResult> s_Factory
internal Func`2<Task`1<Task>, Task`1<TResult>> TaskWhenAnyCast
private string DebuggerDisplayResultDescription
private string DebuggerDisplayMethodDescription
public TResult Result
internal TResult ResultOnSuccess
public TaskFactory`1<TResult> Factory
internal void .ctor(object state, TaskCreationOptions options)
internal void .ctor(TResult result)
internal void .ctor(bool canceled, TResult result, TaskCreationOptions creationOptions, CancellationToken ct)
public void .ctor(Func`1<TResult> function)
public void .ctor(Func`1<TResult> function, CancellationToken cancellationToken)
public void .ctor(Func`1<TResult> function, TaskCreationOptions creationOptions)
public void .ctor(Func`1<TResult> function, CancellationToken cancellationToken, TaskCreationOptions creationOptions)
public void .ctor(Func`2<object, TResult> function, object state)
public void .ctor(Func`2<object, TResult> function, object state, CancellationToken cancellationToken)
public void .ctor(Func`2<object, TResult> function, object state, TaskCreationOptions creationOptions)
public void .ctor(Func`2<object, TResult> function, object state, CancellationToken cancellationToken, TaskCreationOptions creationOptions)
internal void .ctor(Func`1<TResult> valueSelector, Task parent, CancellationToken cancellationToken, TaskCreationOptions creationOptions, InternalTaskOptions internalOptions, TaskScheduler scheduler, StackCrawlMark& stackMark)
internal void .ctor(Func`1<TResult> valueSelector, Task parent, CancellationToken cancellationToken, TaskCreationOptions creationOptions, InternalTaskOptions internalOptions, TaskScheduler scheduler)
internal void .ctor(Func`2<object, TResult> valueSelector, object state, Task parent, CancellationToken cancellationToken, TaskCreationOptions creationOptions, InternalTaskOptions internalOptions, TaskScheduler scheduler, StackCrawlMark& stackMark)
internal void .ctor(Delegate valueSelector, object state, Task parent, CancellationToken cancellationToken, TaskCreationOptions creationOptions, InternalTaskOptions internalOptions, TaskScheduler scheduler)
internal Task`1<TResult> StartNew(Task parent, Func`1<TResult> function, CancellationToken cancellationToken, TaskCreationOptions creationOptions, InternalTaskOptions internalOptions, TaskScheduler scheduler, StackCrawlMark& stackMark)
internal Task`1<TResult> StartNew(Task parent, Func`2<object, TResult> function, object state, CancellationToken cancellationToken, TaskCreationOptions creationOptions, InternalTaskOptions internalOptions, TaskScheduler scheduler, StackCrawlMark& stackMark)
private string get_DebuggerDisplayResultDescription()
private string get_DebuggerDisplayMethodDescription()
internal bool TrySetResult(TResult result)
internal void DangerousSetResult(TResult result)
public TResult get_Result()
internal TResult get_ResultOnSuccess()
internal TResult GetResultCore(bool waitCompletionNotification)
internal bool TrySetException(object exceptionObject)
internal bool TrySetCanceled(CancellationToken tokenToRecord)
internal bool TrySetCanceled(CancellationToken tokenToRecord, object cancellationException)
public TaskFactory`1<TResult> get_Factory()
internal void InnerInvoke()
public TaskAwaiter`1<TResult> GetAwaiter()
public ConfiguredTaskAwaitable`1<TResult> ConfigureAwait(bool continueOnCapturedContext)
public Task ContinueWith(Action`1<Task`1<TResult>> continuationAction)
public Task ContinueWith(Action`1<Task`1<TResult>> continuationAction, CancellationToken cancellationToken)
public Task ContinueWith(Action`1<Task`1<TResult>> continuationAction, TaskScheduler scheduler)
public Task ContinueWith(Action`1<Task`1<TResult>> continuationAction, TaskContinuationOptions continuationOptions)
public Task ContinueWith(Action`1<Task`1<TResult>> continuationAction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler)
internal Task ContinueWith(Action`1<Task`1<TResult>> continuationAction, TaskScheduler scheduler, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, StackCrawlMark& stackMark)
public Task ContinueWith(Action`2<Task`1<TResult>, object> continuationAction, object state)
public Task ContinueWith(Action`2<Task`1<TResult>, object> continuationAction, object state, CancellationToken cancellationToken)
public Task ContinueWith(Action`2<Task`1<TResult>, object> continuationAction, object state, TaskScheduler scheduler)
public Task ContinueWith(Action`2<Task`1<TResult>, object> continuationAction, object state, TaskContinuationOptions continuationOptions)
public Task ContinueWith(Action`2<Task`1<TResult>, object> continuationAction, object state, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler)
internal Task ContinueWith(Action`2<Task`1<TResult>, object> continuationAction, object state, TaskScheduler scheduler, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, StackCrawlMark& stackMark)
public Task`1<TNewResult> ContinueWith(Func`2<Task`1<TResult>, TNewResult> continuationFunction)
public Task`1<TNewResult> ContinueWith(Func`2<Task`1<TResult>, TNewResult> continuationFunction, CancellationToken cancellationToken)
public Task`1<TNewResult> ContinueWith(Func`2<Task`1<TResult>, TNewResult> continuationFunction, TaskScheduler scheduler)
public Task`1<TNewResult> ContinueWith(Func`2<Task`1<TResult>, TNewResult> continuationFunction, TaskContinuationOptions continuationOptions)
public Task`1<TNewResult> ContinueWith(Func`2<Task`1<TResult>, TNewResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler)
internal Task`1<TNewResult> ContinueWith(Func`2<Task`1<TResult>, TNewResult> continuationFunction, TaskScheduler scheduler, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, StackCrawlMark& stackMark)
public Task`1<TNewResult> ContinueWith(Func`3<Task`1<TResult>, object, TNewResult> continuationFunction, object state)
public Task`1<TNewResult> ContinueWith(Func`3<Task`1<TResult>, object, TNewResult> continuationFunction, object state, CancellationToken cancellationToken)
public Task`1<TNewResult> ContinueWith(Func`3<Task`1<TResult>, object, TNewResult> continuationFunction, object state, TaskScheduler scheduler)
public Task`1<TNewResult> ContinueWith(Func`3<Task`1<TResult>, object, TNewResult> continuationFunction, object state, TaskContinuationOptions continuationOptions)
public Task`1<TNewResult> ContinueWith(Func`3<Task`1<TResult>, object, TNewResult> continuationFunction, object state, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler)
internal Task`1<TNewResult> ContinueWith(Func`3<Task`1<TResult>, object, TNewResult> continuationFunction, object state, TaskScheduler scheduler, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, StackCrawlMark& stackMark)
}
public System.Threading.Tasks.TaskCanceledException : OperationCanceledException {
private Task m_canceledTask
public Task Task
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
public void .ctor(Task task)
protected void .ctor(SerializationInfo info, StreamingContext context)
public Task get_Task()
}
public System.Threading.Tasks.TaskCompletionSource`1 : object {
private Task`1<TResult> m_task
public Task`1<TResult> Task
public void .ctor(TaskCreationOptions creationOptions)
public void .ctor(object state)
public void .ctor(object state, TaskCreationOptions creationOptions)
public Task`1<TResult> get_Task()
private void SpinUntilCompleted()
public bool TrySetException(Exception exception)
public bool TrySetException(IEnumerable`1<Exception> exceptions)
internal bool TrySetException(IEnumerable`1<ExceptionDispatchInfo> exceptions)
public void SetException(Exception exception)
public void SetException(IEnumerable`1<Exception> exceptions)
public bool TrySetResult(TResult result)
public void SetResult(TResult result)
public bool TrySetCanceled()
public bool TrySetCanceled(CancellationToken cancellationToken)
public void SetCanceled()
}
internal System.Threading.Tasks.TaskContinuation : object {
internal void Run(Task completedTask, bool bCanInlineContinuationTask)
protected void InlineIfPossibleOrElseQueue(Task task, bool needsProtection)
internal Delegate[] GetDelegateContinuationsForDebugger()
}
public System.Threading.Tasks.TaskContinuationOptions : Enum {
public int value__
public TaskContinuationOptions None
public TaskContinuationOptions PreferFairness
public TaskContinuationOptions LongRunning
public TaskContinuationOptions AttachedToParent
public TaskContinuationOptions DenyChildAttach
public TaskContinuationOptions HideScheduler
public TaskContinuationOptions LazyCancellation
public TaskContinuationOptions RunContinuationsAsynchronously
public TaskContinuationOptions NotOnRanToCompletion
public TaskContinuationOptions NotOnFaulted
public TaskContinuationOptions NotOnCanceled
public TaskContinuationOptions OnlyOnRanToCompletion
public TaskContinuationOptions OnlyOnFaulted
public TaskContinuationOptions OnlyOnCanceled
public TaskContinuationOptions ExecuteSynchronously
}
public System.Threading.Tasks.TaskCreationOptions : Enum {
public int value__
public TaskCreationOptions None
public TaskCreationOptions PreferFairness
public TaskCreationOptions LongRunning
public TaskCreationOptions AttachedToParent
public TaskCreationOptions DenyChildAttach
public TaskCreationOptions HideScheduler
public TaskCreationOptions RunContinuationsAsynchronously
}
internal System.Threading.Tasks.TaskExceptionHolder : object {
private bool s_failFastOnUnobservedException
private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) s_domainUnloadStarted
private EventHandler modreq(System.Runtime.CompilerServices.IsVolatile) s_adUnloadEventHandler
private Task m_task
private List`1 modreq(System.Runtime.CompilerServices.IsVolatile) m_faultExceptions
private ExceptionDispatchInfo m_cancellationException
private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) m_isHandled
internal bool ContainsFaultList
internal void .ctor(Task task)
private bool ShouldFailFastOnUnobservedException()
private void EnsureADUnloadCallbackRegistered()
private void AppDomainUnloadCallback(object sender, EventArgs e)
protected void Finalize()
internal bool get_ContainsFaultList()
internal void Add(object exceptionObject)
internal void Add(object exceptionObject, bool representsCancellation)
private void SetCancellationException(object exceptionObject)
private void AddFaultException(object exceptionObject)
private void MarkAsUnhandled()
internal void MarkAsHandled(bool calledFromFinalizer)
internal AggregateException CreateExceptionObject(bool calledFromFinalizer, Exception includeThisException)
internal ReadOnlyCollection`1<ExceptionDispatchInfo> GetExceptionDispatchInfos()
internal ExceptionDispatchInfo GetCancellationExceptionDispatchInfo()
}
public System.Threading.Tasks.TaskFactory : object {
private CancellationToken m_defaultCancellationToken
private TaskScheduler m_defaultScheduler
private TaskCreationOptions m_defaultCreationOptions
private TaskContinuationOptions m_defaultContinuationOptions
private TaskScheduler DefaultScheduler
public CancellationToken CancellationToken
public TaskScheduler Scheduler
public TaskCreationOptions CreationOptions
public TaskContinuationOptions ContinuationOptions
private TaskScheduler get_DefaultScheduler()
private TaskScheduler GetDefaultScheduler(Task currTask)
public void .ctor(CancellationToken cancellationToken)
public void .ctor(TaskScheduler scheduler)
public void .ctor(TaskCreationOptions creationOptions, TaskContinuationOptions continuationOptions)
public void .ctor(CancellationToken cancellationToken, TaskCreationOptions creationOptions, TaskContinuationOptions continuationOptions, TaskScheduler scheduler)
internal void CheckCreationOptions(TaskCreationOptions creationOptions)
public CancellationToken get_CancellationToken()
public TaskScheduler get_Scheduler()
public TaskCreationOptions get_CreationOptions()
public TaskContinuationOptions get_ContinuationOptions()
public Task StartNew(Action action)
public Task StartNew(Action action, CancellationToken cancellationToken)
public Task StartNew(Action action, TaskCreationOptions creationOptions)
public Task StartNew(Action action, CancellationToken cancellationToken, TaskCreationOptions creationOptions, TaskScheduler scheduler)
internal Task StartNew(Action action, CancellationToken cancellationToken, TaskCreationOptions creationOptions, InternalTaskOptions internalOptions, TaskScheduler scheduler)
public Task StartNew(Action`1<object> action, object state)
public Task StartNew(Action`1<object> action, object state, CancellationToken cancellationToken)
public Task StartNew(Action`1<object> action, object state, TaskCreationOptions creationOptions)
public Task StartNew(Action`1<object> action, object state, CancellationToken cancellationToken, TaskCreationOptions creationOptions, TaskScheduler scheduler)
public Task`1<TResult> StartNew(Func`1<TResult> function)
public Task`1<TResult> StartNew(Func`1<TResult> function, CancellationToken cancellationToken)
public Task`1<TResult> StartNew(Func`1<TResult> function, TaskCreationOptions creationOptions)
public Task`1<TResult> StartNew(Func`1<TResult> function, CancellationToken cancellationToken, TaskCreationOptions creationOptions, TaskScheduler scheduler)
public Task`1<TResult> StartNew(Func`2<object, TResult> function, object state)
public Task`1<TResult> StartNew(Func`2<object, TResult> function, object state, CancellationToken cancellationToken)
public Task`1<TResult> StartNew(Func`2<object, TResult> function, object state, TaskCreationOptions creationOptions)
public Task`1<TResult> StartNew(Func`2<object, TResult> function, object state, CancellationToken cancellationToken, TaskCreationOptions creationOptions, TaskScheduler scheduler)
public Task FromAsync(IAsyncResult asyncResult, Action`1<IAsyncResult> endMethod)
public Task FromAsync(IAsyncResult asyncResult, Action`1<IAsyncResult> endMethod, TaskCreationOptions creationOptions)
public Task FromAsync(IAsyncResult asyncResult, Action`1<IAsyncResult> endMethod, TaskCreationOptions creationOptions, TaskScheduler scheduler)
private Task FromAsync(IAsyncResult asyncResult, Action`1<IAsyncResult> endMethod, TaskCreationOptions creationOptions, TaskScheduler scheduler, StackCrawlMark& stackMark)
public Task FromAsync(Func`3<AsyncCallback, object, IAsyncResult> beginMethod, Action`1<IAsyncResult> endMethod, object state)
public Task FromAsync(Func`3<AsyncCallback, object, IAsyncResult> beginMethod, Action`1<IAsyncResult> endMethod, object state, TaskCreationOptions creationOptions)
public Task FromAsync(Func`4<TArg1, AsyncCallback, object, IAsyncResult> beginMethod, Action`1<IAsyncResult> endMethod, TArg1 arg1, object state)
public Task FromAsync(Func`4<TArg1, AsyncCallback, object, IAsyncResult> beginMethod, Action`1<IAsyncResult> endMethod, TArg1 arg1, object state, TaskCreationOptions creationOptions)
public Task FromAsync(Func`5<TArg1, TArg2, AsyncCallback, object, IAsyncResult> beginMethod, Action`1<IAsyncResult> endMethod, TArg1 arg1, TArg2 arg2, object state)
public Task FromAsync(Func`5<TArg1, TArg2, AsyncCallback, object, IAsyncResult> beginMethod, Action`1<IAsyncResult> endMethod, TArg1 arg1, TArg2 arg2, object state, TaskCreationOptions creationOptions)
public Task FromAsync(Func`6<TArg1, TArg2, TArg3, AsyncCallback, object, IAsyncResult> beginMethod, Action`1<IAsyncResult> endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state)
public Task FromAsync(Func`6<TArg1, TArg2, TArg3, AsyncCallback, object, IAsyncResult> beginMethod, Action`1<IAsyncResult> endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state, TaskCreationOptions creationOptions)
public Task`1<TResult> FromAsync(IAsyncResult asyncResult, Func`2<IAsyncResult, TResult> endMethod)
public Task`1<TResult> FromAsync(IAsyncResult asyncResult, Func`2<IAsyncResult, TResult> endMethod, TaskCreationOptions creationOptions)
public Task`1<TResult> FromAsync(IAsyncResult asyncResult, Func`2<IAsyncResult, TResult> endMethod, TaskCreationOptions creationOptions, TaskScheduler scheduler)
public Task`1<TResult> FromAsync(Func`3<AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, object state)
public Task`1<TResult> FromAsync(Func`3<AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, object state, TaskCreationOptions creationOptions)
public Task`1<TResult> FromAsync(Func`4<TArg1, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, object state)
public Task`1<TResult> FromAsync(Func`4<TArg1, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, object state, TaskCreationOptions creationOptions)
public Task`1<TResult> FromAsync(Func`5<TArg1, TArg2, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, TArg2 arg2, object state)
public Task`1<TResult> FromAsync(Func`5<TArg1, TArg2, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, TArg2 arg2, object state, TaskCreationOptions creationOptions)
public Task`1<TResult> FromAsync(Func`6<TArg1, TArg2, TArg3, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state)
public Task`1<TResult> FromAsync(Func`6<TArg1, TArg2, TArg3, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state, TaskCreationOptions creationOptions)
internal void CheckFromAsyncOptions(TaskCreationOptions creationOptions, bool hasBeginMethod)
internal Task`1<Task[]> CommonCWAllLogic(Task[] tasksCopy)
internal Task`1<Task`1[]> CommonCWAllLogic(Task`1[] tasksCopy)
public Task ContinueWhenAll(Task[] tasks, Action`1<Task[]> continuationAction)
public Task ContinueWhenAll(Task[] tasks, Action`1<Task[]> continuationAction, CancellationToken cancellationToken)
public Task ContinueWhenAll(Task[] tasks, Action`1<Task[]> continuationAction, TaskContinuationOptions continuationOptions)
public Task ContinueWhenAll(Task[] tasks, Action`1<Task[]> continuationAction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler)
public Task ContinueWhenAll(Task`1[] tasks, Action`1<Task`1[]> continuationAction)
public Task ContinueWhenAll(Task`1[] tasks, Action`1<Task`1[]> continuationAction, CancellationToken cancellationToken)
public Task ContinueWhenAll(Task`1[] tasks, Action`1<Task`1[]> continuationAction, TaskContinuationOptions continuationOptions)
public Task ContinueWhenAll(Task`1[] tasks, Action`1<Task`1[]> continuationAction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler)
public Task`1<TResult> ContinueWhenAll(Task[] tasks, Func`2<Task[], TResult> continuationFunction)
public Task`1<TResult> ContinueWhenAll(Task[] tasks, Func`2<Task[], TResult> continuationFunction, CancellationToken cancellationToken)
public Task`1<TResult> ContinueWhenAll(Task[] tasks, Func`2<Task[], TResult> continuationFunction, TaskContinuationOptions continuationOptions)
public Task`1<TResult> ContinueWhenAll(Task[] tasks, Func`2<Task[], TResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler)
public Task`1<TResult> ContinueWhenAll(Task`1[] tasks, Func`2<Task`1[], TResult> continuationFunction)
public Task`1<TResult> ContinueWhenAll(Task`1[] tasks, Func`2<Task`1[], TResult> continuationFunction, CancellationToken cancellationToken)
public Task`1<TResult> ContinueWhenAll(Task`1[] tasks, Func`2<Task`1[], TResult> continuationFunction, TaskContinuationOptions continuationOptions)
public Task`1<TResult> ContinueWhenAll(Task`1[] tasks, Func`2<Task`1[], TResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler)
internal Task`1<Task> CommonCWAnyLogic(IList`1<Task> tasks)
public Task ContinueWhenAny(Task[] tasks, Action`1<Task> continuationAction)
public Task ContinueWhenAny(Task[] tasks, Action`1<Task> continuationAction, CancellationToken cancellationToken)
public Task ContinueWhenAny(Task[] tasks, Action`1<Task> continuationAction, TaskContinuationOptions continuationOptions)
public Task ContinueWhenAny(Task[] tasks, Action`1<Task> continuationAction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler)
public Task`1<TResult> ContinueWhenAny(Task[] tasks, Func`2<Task, TResult> continuationFunction)
public Task`1<TResult> ContinueWhenAny(Task[] tasks, Func`2<Task, TResult> continuationFunction, CancellationToken cancellationToken)
public Task`1<TResult> ContinueWhenAny(Task[] tasks, Func`2<Task, TResult> continuationFunction, TaskContinuationOptions continuationOptions)
public Task`1<TResult> ContinueWhenAny(Task[] tasks, Func`2<Task, TResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler)
public Task`1<TResult> ContinueWhenAny(Task`1[] tasks, Func`2<Task`1<TAntecedentResult>, TResult> continuationFunction)
public Task`1<TResult> ContinueWhenAny(Task`1[] tasks, Func`2<Task`1<TAntecedentResult>, TResult> continuationFunction, CancellationToken cancellationToken)
public Task`1<TResult> ContinueWhenAny(Task`1[] tasks, Func`2<Task`1<TAntecedentResult>, TResult> continuationFunction, TaskContinuationOptions continuationOptions)
public Task`1<TResult> ContinueWhenAny(Task`1[] tasks, Func`2<Task`1<TAntecedentResult>, TResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler)
public Task ContinueWhenAny(Task`1[] tasks, Action`1<Task`1<TAntecedentResult>> continuationAction)
public Task ContinueWhenAny(Task`1[] tasks, Action`1<Task`1<TAntecedentResult>> continuationAction, CancellationToken cancellationToken)
public Task ContinueWhenAny(Task`1[] tasks, Action`1<Task`1<TAntecedentResult>> continuationAction, TaskContinuationOptions continuationOptions)
public Task ContinueWhenAny(Task`1[] tasks, Action`1<Task`1<TAntecedentResult>> continuationAction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler)
internal Task[] CheckMultiContinuationTasksAndCopy(Task[] tasks)
internal Task`1[] CheckMultiContinuationTasksAndCopy(Task`1[] tasks)
internal void CheckMultiTaskContinuationOptions(TaskContinuationOptions continuationOptions)
}
public System.Threading.Tasks.TaskFactory`1 : object {
private CancellationToken m_defaultCancellationToken
private TaskScheduler m_defaultScheduler
private TaskCreationOptions m_defaultCreationOptions
private TaskContinuationOptions m_defaultContinuationOptions
private TaskScheduler DefaultScheduler
public CancellationToken CancellationToken
public TaskScheduler Scheduler
public TaskCreationOptions CreationOptions
public TaskContinuationOptions ContinuationOptions
private TaskScheduler get_DefaultScheduler()
private TaskScheduler GetDefaultScheduler(Task currTask)
public void .ctor(CancellationToken cancellationToken)
public void .ctor(TaskScheduler scheduler)
public void .ctor(TaskCreationOptions creationOptions, TaskContinuationOptions continuationOptions)
public void .ctor(CancellationToken cancellationToken, TaskCreationOptions creationOptions, TaskContinuationOptions continuationOptions, TaskScheduler scheduler)
public CancellationToken get_CancellationToken()
public TaskScheduler get_Scheduler()
public TaskCreationOptions get_CreationOptions()
public TaskContinuationOptions get_ContinuationOptions()
public Task`1<TResult> StartNew(Func`1<TResult> function)
public Task`1<TResult> StartNew(Func`1<TResult> function, CancellationToken cancellationToken)
public Task`1<TResult> StartNew(Func`1<TResult> function, TaskCreationOptions creationOptions)
public Task`1<TResult> StartNew(Func`1<TResult> function, CancellationToken cancellationToken, TaskCreationOptions creationOptions, TaskScheduler scheduler)
public Task`1<TResult> StartNew(Func`2<object, TResult> function, object state)
public Task`1<TResult> StartNew(Func`2<object, TResult> function, object state, CancellationToken cancellationToken)
public Task`1<TResult> StartNew(Func`2<object, TResult> function, object state, TaskCreationOptions creationOptions)
public Task`1<TResult> StartNew(Func`2<object, TResult> function, object state, CancellationToken cancellationToken, TaskCreationOptions creationOptions, TaskScheduler scheduler)
private void FromAsyncCoreLogic(IAsyncResult iar, Func`2<IAsyncResult, TResult> endFunction, Action`1<IAsyncResult> endAction, Task`1<TResult> promise, bool requiresSynchronization)
public Task`1<TResult> FromAsync(IAsyncResult asyncResult, Func`2<IAsyncResult, TResult> endMethod)
public Task`1<TResult> FromAsync(IAsyncResult asyncResult, Func`2<IAsyncResult, TResult> endMethod, TaskCreationOptions creationOptions)
public Task`1<TResult> FromAsync(IAsyncResult asyncResult, Func`2<IAsyncResult, TResult> endMethod, TaskCreationOptions creationOptions, TaskScheduler scheduler)
internal Task`1<TResult> FromAsyncImpl(IAsyncResult asyncResult, Func`2<IAsyncResult, TResult> endFunction, Action`1<IAsyncResult> endAction, TaskCreationOptions creationOptions, TaskScheduler scheduler, StackCrawlMark& stackMark)
public Task`1<TResult> FromAsync(Func`3<AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, object state)
public Task`1<TResult> FromAsync(Func`3<AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, object state, TaskCreationOptions creationOptions)
internal Task`1<TResult> FromAsyncImpl(Func`3<AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endFunction, Action`1<IAsyncResult> endAction, object state, TaskCreationOptions creationOptions)
public Task`1<TResult> FromAsync(Func`4<TArg1, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, object state)
public Task`1<TResult> FromAsync(Func`4<TArg1, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, object state, TaskCreationOptions creationOptions)
internal Task`1<TResult> FromAsyncImpl(Func`4<TArg1, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endFunction, Action`1<IAsyncResult> endAction, TArg1 arg1, object state, TaskCreationOptions creationOptions)
public Task`1<TResult> FromAsync(Func`5<TArg1, TArg2, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, TArg2 arg2, object state)
public Task`1<TResult> FromAsync(Func`5<TArg1, TArg2, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, TArg2 arg2, object state, TaskCreationOptions creationOptions)
internal Task`1<TResult> FromAsyncImpl(Func`5<TArg1, TArg2, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endFunction, Action`1<IAsyncResult> endAction, TArg1 arg1, TArg2 arg2, object state, TaskCreationOptions creationOptions)
public Task`1<TResult> FromAsync(Func`6<TArg1, TArg2, TArg3, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state)
public Task`1<TResult> FromAsync(Func`6<TArg1, TArg2, TArg3, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state, TaskCreationOptions creationOptions)
internal Task`1<TResult> FromAsyncImpl(Func`6<TArg1, TArg2, TArg3, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endFunction, Action`1<IAsyncResult> endAction, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state, TaskCreationOptions creationOptions)
internal Task`1<TResult> FromAsyncTrim(TInstance thisRef, TArgs args, Func`5<TInstance, TArgs, AsyncCallback, object, IAsyncResult> beginMethod, Func`3<TInstance, IAsyncResult, TResult> endMethod)
private Task`1<TResult> CreateCanceledTask(TaskContinuationOptions continuationOptions, CancellationToken ct)
public Task`1<TResult> ContinueWhenAll(Task[] tasks, Func`2<Task[], TResult> continuationFunction)
public Task`1<TResult> ContinueWhenAll(Task[] tasks, Func`2<Task[], TResult> continuationFunction, CancellationToken cancellationToken)
public Task`1<TResult> ContinueWhenAll(Task[] tasks, Func`2<Task[], TResult> continuationFunction, TaskContinuationOptions continuationOptions)
public Task`1<TResult> ContinueWhenAll(Task[] tasks, Func`2<Task[], TResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler)
public Task`1<TResult> ContinueWhenAll(Task`1[] tasks, Func`2<Task`1[], TResult> continuationFunction)
public Task`1<TResult> ContinueWhenAll(Task`1[] tasks, Func`2<Task`1[], TResult> continuationFunction, CancellationToken cancellationToken)
public Task`1<TResult> ContinueWhenAll(Task`1[] tasks, Func`2<Task`1[], TResult> continuationFunction, TaskContinuationOptions continuationOptions)
public Task`1<TResult> ContinueWhenAll(Task`1[] tasks, Func`2<Task`1[], TResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler)
internal Task`1<TResult> ContinueWhenAllImpl(Task`1[] tasks, Func`2<Task`1[], TResult> continuationFunction, Action`1<Task`1[]> continuationAction, TaskContinuationOptions continuationOptions, CancellationToken cancellationToken, TaskScheduler scheduler, StackCrawlMark& stackMark)
internal Task`1<TResult> ContinueWhenAllImpl(Task[] tasks, Func`2<Task[], TResult> continuationFunction, Action`1<Task[]> continuationAction, TaskContinuationOptions continuationOptions, CancellationToken cancellationToken, TaskScheduler scheduler, StackCrawlMark& stackMark)
public Task`1<TResult> ContinueWhenAny(Task[] tasks, Func`2<Task, TResult> continuationFunction)
public Task`1<TResult> ContinueWhenAny(Task[] tasks, Func`2<Task, TResult> continuationFunction, CancellationToken cancellationToken)
public Task`1<TResult> ContinueWhenAny(Task[] tasks, Func`2<Task, TResult> continuationFunction, TaskContinuationOptions continuationOptions)
public Task`1<TResult> ContinueWhenAny(Task[] tasks, Func`2<Task, TResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler)
public Task`1<TResult> ContinueWhenAny(Task`1[] tasks, Func`2<Task`1<TAntecedentResult>, TResult> continuationFunction)
public Task`1<TResult> ContinueWhenAny(Task`1[] tasks, Func`2<Task`1<TAntecedentResult>, TResult> continuationFunction, CancellationToken cancellationToken)
public Task`1<TResult> ContinueWhenAny(Task`1[] tasks, Func`2<Task`1<TAntecedentResult>, TResult> continuationFunction, TaskContinuationOptions continuationOptions)
public Task`1<TResult> ContinueWhenAny(Task`1[] tasks, Func`2<Task`1<TAntecedentResult>, TResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler)
internal Task`1<TResult> ContinueWhenAnyImpl(Task[] tasks, Func`2<Task, TResult> continuationFunction, Action`1<Task> continuationAction, TaskContinuationOptions continuationOptions, CancellationToken cancellationToken, TaskScheduler scheduler, StackCrawlMark& stackMark)
internal Task`1<TResult> ContinueWhenAnyImpl(Task`1[] tasks, Func`2<Task`1<TAntecedentResult>, TResult> continuationFunction, Action`1<Task`1<TAntecedentResult>> continuationAction, TaskContinuationOptions continuationOptions, CancellationToken cancellationToken, TaskScheduler scheduler, StackCrawlMark& stackMark)
}
public System.Threading.Tasks.TaskScheduler : object {
private ConditionalWeakTable`2<TaskScheduler, object> s_activeTaskSchedulers
private TaskScheduler s_defaultTaskScheduler
internal int s_taskSchedulerIdCounter
private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) m_taskSchedulerId
private EventHandler`1<UnobservedTaskExceptionEventArgs> _unobservedTaskException
private object _unobservedTaskExceptionLockObject
public int MaximumConcurrencyLevel
internal bool RequiresAtomicStartTransition
public TaskScheduler Default
public TaskScheduler Current
internal bool IsDefault
internal TaskScheduler InternalCurrent
public int Id
protected internal void QueueTask(Task task)
protected bool TryExecuteTaskInline(Task task, bool taskWasPreviouslyQueued)
protected IEnumerable`1<Task> GetScheduledTasks()
public int get_MaximumConcurrencyLevel()
internal bool TryRunInline(Task task, bool taskWasPreviouslyQueued)
protected internal bool TryDequeue(Task task)
internal void NotifyWorkItemProgress()
internal bool get_RequiresAtomicStartTransition()
internal void InternalQueueTask(Task task)
private void AddToActiveTaskSchedulers()
public TaskScheduler get_Default()
public TaskScheduler get_Current()
internal bool get_IsDefault()
internal TaskScheduler get_InternalCurrent()
public TaskScheduler FromCurrentSynchronizationContext()
public int get_Id()
protected bool TryExecuteTask(Task task)
public void add_UnobservedTaskException(EventHandler`1<UnobservedTaskExceptionEventArgs> value)
public void remove_UnobservedTaskException(EventHandler`1<UnobservedTaskExceptionEventArgs> value)
internal void PublishUnobservedTaskException(object sender, UnobservedTaskExceptionEventArgs ueea)
internal Task[] GetScheduledTasksForDebugger()
internal TaskScheduler[] GetTaskSchedulersForDebugger()
}
internal System.Threading.Tasks.TaskSchedulerAwaitTaskContinuation : AwaitTaskContinuation {
private TaskScheduler m_scheduler
internal void .ctor(TaskScheduler scheduler, Action action, bool flowExecutionContext, StackCrawlMark& stackMark)
internal void Run(Task ignored, bool canInlineContinuationTask)
}
public System.Threading.Tasks.TaskSchedulerException : Exception {
public void .ctor(string message)
public void .ctor(Exception innerException)
public void .ctor(string message, Exception innerException)
protected void .ctor(SerializationInfo info, StreamingContext context)
}
public System.Threading.Tasks.TaskStatus : Enum {
public int value__
public TaskStatus Created
public TaskStatus WaitingForActivation
public TaskStatus WaitingToRun
public TaskStatus Running
public TaskStatus WaitingForChildrenToComplete
public TaskStatus RanToCompletion
public TaskStatus Canceled
public TaskStatus Faulted
}
internal System.Threading.Tasks.TaskToApm : object {
public IAsyncResult Begin(Task task, AsyncCallback callback, object state)
public void End(IAsyncResult asyncResult)
public TResult End(IAsyncResult asyncResult)
private void InvokeCallbackWhenTaskCompletes(Task antecedent, AsyncCallback callback, IAsyncResult asyncResult)
}
internal System.Threading.Tasks.ThreadPoolTaskScheduler : TaskScheduler {
private ParameterizedThreadStart s_longRunningThreadWork
internal bool RequiresAtomicStartTransition
private void LongRunningThreadWork(object obj)
protected internal void QueueTask(Task task)
protected bool TryExecuteTaskInline(Task task, bool taskWasPreviouslyQueued)
protected internal bool TryDequeue(Task task)
protected IEnumerable`1<Task> GetScheduledTasks()
private IEnumerable`1<Task> FilterTasksFromWorkItems(IEnumerable`1<IThreadPoolWorkItem> tpwItems)
internal void NotifyWorkItemProgress()
internal bool get_RequiresAtomicStartTransition()
}
public System.Threading.Tasks.UnobservedTaskExceptionEventArgs : EventArgs {
private AggregateException m_exception
internal bool m_observed
public bool Observed
public AggregateException Exception
public void .ctor(AggregateException exception)
public void SetObserved()
public bool get_Observed()
public AggregateException get_Exception()
}
internal System.Threading.Tasks.UnwrapPromise`1 : Task`1<TResult> {
private byte STATE_WAITING_ON_OUTER_TASK
private byte STATE_WAITING_ON_INNER_TASK
private byte STATE_DONE
private byte _state
private bool _lookForOce
public void .ctor(Task outerTask, bool lookForOce)
public void Invoke(Task completingTask)
private void InvokeCore(Task completingTask)
private void InvokeCoreAsync(Task completingTask)
private void ProcessCompletedOuterTask(Task task)
private bool TrySetFromTask(Task task, bool lookForOce)
private void ProcessInnerTask(Task task)
}
public System.Threading.Tasks.ValueTask`1 : ValueType {
internal Task`1<TResult> _task
internal TResult _result
public bool IsCompleted
public bool IsCompletedSuccessfully
public bool IsFaulted
public bool IsCanceled
public TResult Result
public void .ctor(TResult result)
public void .ctor(Task`1<TResult> task)
public int GetHashCode()
public bool Equals(object obj)
public bool Equals(ValueTask`1<TResult> other)
public bool op_Equality(ValueTask`1<TResult> left, ValueTask`1<TResult> right)
public bool op_Inequality(ValueTask`1<TResult> left, ValueTask`1<TResult> right)
public Task`1<TResult> AsTask()
public bool get_IsCompleted()
public bool get_IsCompletedSuccessfully()
public bool get_IsFaulted()
public bool get_IsCanceled()
public TResult get_Result()
public ValueTaskAwaiter`1<TResult> GetAwaiter()
public ConfiguredValueTaskAwaitable`1<TResult> ConfigureAwait(bool continueOnCapturedContext)
public string ToString()
public AsyncValueTaskMethodBuilder`1<TResult> CreateAsyncMethodBuilder()
}
public System.Threading.Thread : CriticalFinalizerObject {
private LocalDataStoreMgr s_LocalDataStoreMgr
private LocalDataStoreHolder s_LocalDataStore
internal CultureInfo m_CurrentCulture
internal CultureInfo m_CurrentUICulture
private AsyncLocal`1<CultureInfo> s_asyncLocalCurrentCulture
private AsyncLocal`1<CultureInfo> s_asyncLocalCurrentUICulture
private InternalThread internal_thread
private object m_ThreadStartArg
private object pending_exception
private IPrincipal principal
private int principal_version
private Thread current_thread
private MulticastDelegate m_Delegate
private ExecutionContext m_ExecutionContext
private bool m_ExecutionContextBelongsToOuterScope
internal bool ExecutionContextBelongsToCurrentScope
public ExecutionContext ExecutionContext
public ThreadPriority Priority
public CultureInfo CurrentUICulture
public CultureInfo CurrentCulture
private LocalDataStoreMgr LocalDataStoreManager
private InternalThread Internal
public Context CurrentContext
public IPrincipal CurrentPrincipal
public Thread CurrentThread
internal int CurrentThreadId
public ApartmentState ApartmentState
public bool IsThreadPoolThread
internal bool IsThreadPoolThreadInternal
public bool IsAlive
public bool IsBackground
public string Name
public ThreadState ThreadState
internal object AbortReason
public int ManagedThreadId
private void AsyncLocalSetCurrentCulture(AsyncLocalValueChangedArgs`1<CultureInfo> args)
private void AsyncLocalSetCurrentUICulture(AsyncLocalValueChangedArgs`1<CultureInfo> args)
public void .ctor(ThreadStart start)
public void .ctor(ThreadStart start, int maxStackSize)
public void .ctor(ParameterizedThreadStart start)
public void .ctor(ParameterizedThreadStart start, int maxStackSize)
public void Start()
public void Start(object parameter)
private void Start(StackCrawlMark& stackMark)
internal Reader GetExecutionContextReader()
internal bool get_ExecutionContextBelongsToCurrentScope()
internal void set_ExecutionContextBelongsToCurrentScope(bool value)
public ExecutionContext get_ExecutionContext()
internal ExecutionContext GetMutableExecutionContext()
internal void SetExecutionContext(ExecutionContext value, bool belongsToCurrentScope)
internal void SetExecutionContext(Reader value, bool belongsToCurrentScope)
public void SetCompressedStack(CompressedStack stack)
public CompressedStack GetCompressedStack()
public void ResetAbort()
private void ResetAbortNative()
public void Suspend()
private void SuspendInternal()
public void Resume()
private void ResumeInternal()
public void Interrupt()
private void InterruptInternal()
public ThreadPriority get_Priority()
public void set_Priority(ThreadPriority value)
private int GetPriorityNative()
private void SetPriorityNative(int priority)
private bool JoinInternal(int millisecondsTimeout)
public void Join()
public bool Join(int millisecondsTimeout)
public bool Join(TimeSpan timeout)
private void SleepInternal(int millisecondsTimeout)
public void Sleep(int millisecondsTimeout)
public void Sleep(TimeSpan timeout)
private bool YieldInternal()
public bool Yield()
private void SetStartHelper(Delegate start, int maxStackSize)
public LocalDataStoreSlot AllocateDataSlot()
public LocalDataStoreSlot AllocateNamedDataSlot(string name)
public LocalDataStoreSlot GetNamedDataSlot(string name)
public void FreeNamedDataSlot(string name)
public object GetData(LocalDataStoreSlot slot)
public void SetData(LocalDataStoreSlot slot, object data)
public CultureInfo get_CurrentUICulture()
public void set_CurrentUICulture(CultureInfo value)
internal CultureInfo GetCurrentUICultureNoAppX()
public CultureInfo get_CurrentCulture()
public void set_CurrentCulture(CultureInfo value)
private CultureInfo GetCurrentCultureNoAppX()
private void nativeInitCultureAccessors()
public void MemoryBarrier()
private LocalDataStoreMgr get_LocalDataStoreManager()
private void System.Runtime.InteropServices._Thread.GetTypeInfoCount(UInt32& pcTInfo)
private void System.Runtime.InteropServices._Thread.GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo)
private void System.Runtime.InteropServices._Thread.GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId)
private void System.Runtime.InteropServices._Thread.Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr)
private void ConstructInternalThread()
private InternalThread get_Internal()
public Context get_CurrentContext()
private Byte[] ByteArrayToRootDomain(Byte[] arr)
private Byte[] ByteArrayToCurrentDomain(Byte[] arr)
private void DeserializePrincipal(Thread th)
private void SerializePrincipal(Thread th, IPrincipal value)
public IPrincipal get_CurrentPrincipal()
public void set_CurrentPrincipal(IPrincipal value)
private Thread GetCurrentThread()
public Thread get_CurrentThread()
internal int get_CurrentThreadId()
public AppDomain GetDomain()
public int GetDomainID()
private IntPtr Thread_internal(MulticastDelegate start)
private void .ctor(InternalThread it)
protected void Finalize()
public ApartmentState get_ApartmentState()
public void set_ApartmentState(ApartmentState value)
public bool get_IsThreadPoolThread()
internal bool get_IsThreadPoolThreadInternal()
internal void set_IsThreadPoolThreadInternal(bool value)
public bool get_IsAlive()
public bool get_IsBackground()
public void set_IsBackground(bool value)
private string GetName_internal(InternalThread thread)
private void SetName_internal(InternalThread thread, string name)
public string get_Name()
public void set_Name(string value)
public ThreadState get_ThreadState()
private void Abort_internal(InternalThread thread, object stateInfo)
public void Abort()
public void Abort(object stateInfo)
private object GetAbortExceptionState()
internal object get_AbortReason()
private void ClearAbortReason()
private void SpinWait_nop()
public void SpinWait(int iterations)
private void StartInternal(IPrincipal principal, StackCrawlMark& stackMark)
private void SetState(InternalThread thread, ThreadState set)
private void ClrState(InternalThread thread, ThreadState clr)
private ThreadState GetState(InternalThread thread)
public byte VolatileRead(Byte& address)
public double VolatileRead(Double& address)
public short VolatileRead(Int16& address)
public int VolatileRead(Int32& address)
public long VolatileRead(Int64& address)
public IntPtr VolatileRead(IntPtr& address)
public object VolatileRead(Object& address)
public sbyte VolatileRead(SByte& address)
public float VolatileRead(Single& address)
public ushort VolatileRead(UInt16& address)
public UInt32 VolatileRead(UInt32& address)
public ulong VolatileRead(UInt64& address)
public UIntPtr VolatileRead(UIntPtr& address)
public void VolatileWrite(Byte& address, byte value)
public void VolatileWrite(Double& address, double value)
public void VolatileWrite(Int16& address, short value)
public void VolatileWrite(Int32& address, int value)
public void VolatileWrite(Int64& address, long value)
public void VolatileWrite(IntPtr& address, IntPtr value)
public void VolatileWrite(Object& address, object value)
public void VolatileWrite(SByte& address, sbyte value)
public void VolatileWrite(Single& address, float value)
public void VolatileWrite(UInt16& address, ushort value)
public void VolatileWrite(UInt32& address, UInt32 value)
public void VolatileWrite(UInt64& address, ulong value)
public void VolatileWrite(UIntPtr& address, UIntPtr value)
private int SystemMaxStackStize()
private int GetProcessDefaultStackSize(int maxStackSize)
private void SetStart(MulticastDelegate start, int maxStackSize)
public int get_ManagedThreadId()
public void BeginCriticalRegion()
public void EndCriticalRegion()
public void BeginThreadAffinity()
public void EndThreadAffinity()
public ApartmentState GetApartmentState()
public void SetApartmentState(ApartmentState state)
public bool TrySetApartmentState(ApartmentState state)
public int GetHashCode()
internal void GetStackTraces(Thread[]& threads, Object[]& stack_frames)
internal Dictionary`2<Thread, StackTrace> Mono_GetStackTraces()
public void DisableComObjectEagerCleanup()
private ThreadState ValidateThreadState()
}
public System.Threading.ThreadAbortException : SystemException {
public object ExceptionState
internal void .ctor(SerializationInfo info, StreamingContext context)
public object get_ExceptionState()
}
internal System.Threading.ThreadHelper : object {
private Delegate _start
private object _startArg
private ExecutionContext _executionContext
internal ContextCallback _ccb
internal void .ctor(Delegate start)
internal void SetExecutionContextHelper(ExecutionContext ec)
private void ThreadStart_Context(object state)
internal void ThreadStart(object obj)
internal void ThreadStart()
}
public System.Threading.ThreadInterruptedException : SystemException {
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
protected void .ctor(SerializationInfo info, StreamingContext context)
}
public System.Threading.ThreadLocal`1 : object {
private Func`1<T> m_valueFactory
private LinkedSlotVolatile[] ts_slotArray
private FinalizationHelper<T> ts_finalizationHelper
private int m_idComplement
private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) m_initialized
private IdManager<T> s_idManager
private LinkedSlot<T> m_linkedSlot
private bool m_trackAllValues
public T Value
public IList`1<T> Values
private int ValuesCountForDebugDisplay
public bool IsValueCreated
internal T ValueForDebugDisplay
internal List`1<T> ValuesForDebugDisplay
public void .ctor(bool trackAllValues)
public void .ctor(Func`1<T> valueFactory)
public void .ctor(Func`1<T> valueFactory, bool trackAllValues)
private void Initialize(Func`1<T> valueFactory, bool trackAllValues)
protected void Finalize()
public void Dispose()
protected void Dispose(bool disposing)
public string ToString()
public T get_Value()
public void set_Value(T value)
private T GetValueSlow()
private void SetValueSlow(T value, LinkedSlotVolatile[] slotArray)
private void CreateLinkedSlot(LinkedSlotVolatile[] slotArray, int id, T value)
public IList`1<T> get_Values()
private List`1<T> GetValuesAsList()
private int get_ValuesCountForDebugDisplay()
public bool get_IsValueCreated()
internal T get_ValueForDebugDisplay()
internal List`1<T> get_ValuesForDebugDisplay()
private void GrowTable(LinkedSlotVolatile[]& table, int minLength)
private int GetNewTableSize(int minSize)
}
public System.Threading.ThreadPool : object {
public bool SetMaxThreads(int workerThreads, int completionPortThreads)
public void GetMaxThreads(Int32& workerThreads, Int32& completionPortThreads)
public bool SetMinThreads(int workerThreads, int completionPortThreads)
public void GetMinThreads(Int32& workerThreads, Int32& completionPortThreads)
public void GetAvailableThreads(Int32& workerThreads, Int32& completionPortThreads)
public RegisteredWaitHandle RegisterWaitForSingleObject(WaitHandle waitObject, WaitOrTimerCallback callBack, object state, UInt32 millisecondsTimeOutInterval, bool executeOnlyOnce)
public RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(WaitHandle waitObject, WaitOrTimerCallback callBack, object state, UInt32 millisecondsTimeOutInterval, bool executeOnlyOnce)
private RegisteredWaitHandle RegisterWaitForSingleObject(WaitHandle waitObject, WaitOrTimerCallback callBack, object state, UInt32 millisecondsTimeOutInterval, bool executeOnlyOnce, StackCrawlMark& stackMark, bool compressStack)
public RegisteredWaitHandle RegisterWaitForSingleObject(WaitHandle waitObject, WaitOrTimerCallback callBack, object state, int millisecondsTimeOutInterval, bool executeOnlyOnce)
public RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(WaitHandle waitObject, WaitOrTimerCallback callBack, object state, int millisecondsTimeOutInterval, bool executeOnlyOnce)
public RegisteredWaitHandle RegisterWaitForSingleObject(WaitHandle waitObject, WaitOrTimerCallback callBack, object state, long millisecondsTimeOutInterval, bool executeOnlyOnce)
public RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(WaitHandle waitObject, WaitOrTimerCallback callBack, object state, long millisecondsTimeOutInterval, bool executeOnlyOnce)
public RegisteredWaitHandle RegisterWaitForSingleObject(WaitHandle waitObject, WaitOrTimerCallback callBack, object state, TimeSpan timeout, bool executeOnlyOnce)
public RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(WaitHandle waitObject, WaitOrTimerCallback callBack, object state, TimeSpan timeout, bool executeOnlyOnce)
public bool QueueUserWorkItem(WaitCallback callBack, object state)
public bool QueueUserWorkItem(WaitCallback callBack)
public bool UnsafeQueueUserWorkItem(WaitCallback callBack, object state)
private bool QueueUserWorkItemHelper(WaitCallback callBack, object state, StackCrawlMark& stackMark, bool compressStack)
internal void UnsafeQueueCustomWorkItem(IThreadPoolWorkItem workItem, bool forceGlobal)
internal bool TryPopCustomWorkItem(IThreadPoolWorkItem workItem)
internal IEnumerable`1<IThreadPoolWorkItem> GetQueuedWorkItems()
internal IEnumerable`1<IThreadPoolWorkItem> EnumerateQueuedWorkItems(WorkStealingQueue[] wsQueues, QueueSegment globalQueueTail)
internal IEnumerable`1<IThreadPoolWorkItem> GetLocallyQueuedWorkItems()
internal IEnumerable`1<IThreadPoolWorkItem> GetGloballyQueuedWorkItems()
private Object[] ToObjectArray(IEnumerable`1<IThreadPoolWorkItem> workitems)
internal Object[] GetQueuedWorkItemsForDebugger()
internal Object[] GetGloballyQueuedWorkItemsForDebugger()
internal Object[] GetLocallyQueuedWorkItemsForDebugger()
internal bool RequestWorkerThread()
private bool PostQueuedCompletionStatus(NativeOverlapped* overlapped)
public bool UnsafeQueueNativeOverlapped(NativeOverlapped* overlapped)
private void EnsureVMInitialized()
private bool SetMinThreadsNative(int workerThreads, int completionPortThreads)
private bool SetMaxThreadsNative(int workerThreads, int completionPortThreads)
private void GetMinThreadsNative(Int32& workerThreads, Int32& completionPortThreads)
private void GetMaxThreadsNative(Int32& workerThreads, Int32& completionPortThreads)
private void GetAvailableThreadsNative(Int32& workerThreads, Int32& completionPortThreads)
internal bool NotifyWorkItemComplete()
internal void ReportThreadStatus(bool isWorking)
internal void NotifyWorkItemProgress()
internal void NotifyWorkItemProgressNative()
internal bool IsThreadPoolHosted()
private void InitializeVMTp(Boolean& enableWorkerTracking)
public bool BindHandle(IntPtr osHandle)
public bool BindHandle(SafeHandle osHandle)
private bool BindIOCompletionCallbackNative(IntPtr fileHandle)
}
public System.Threading.ThreadPoolBoundHandle : object {
public SafeHandle Handle
public SafeHandle get_Handle()
public NativeOverlapped* AllocateNativeOverlapped(IOCompletionCallback callback, object state, object pinData)
public NativeOverlapped* AllocateNativeOverlapped(PreAllocatedOverlapped preAllocated)
public ThreadPoolBoundHandle BindHandle(SafeHandle handle)
public void Dispose()
public void FreeNativeOverlapped(NativeOverlapped* overlapped)
public object GetNativeOverlappedState(NativeOverlapped* overlapped)
}
internal System.Threading.ThreadPoolGlobals : object {
public UInt32 tpQuantum
public int processorCount
public bool tpHosted
public Boolean modreq(System.Runtime.CompilerServices.IsVolatile) vmTpInitialized
public bool enableWorkerTracking
public ThreadPoolWorkQueue workQueue
}
internal System.Threading.ThreadPoolWorkQueue : object {
internal QueueSegment modreq(System.Runtime.CompilerServices.IsVolatile) queueHead
internal QueueSegment modreq(System.Runtime.CompilerServices.IsVolatile) queueTail
internal SparseArray`1<WorkStealingQueue> allThreadQueues
private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) numOutstandingThreadRequests
public ThreadPoolWorkQueueThreadLocals EnsureCurrentThreadHasQueue()
internal void EnsureThreadRequested()
internal void MarkThreadRequestSatisfied()
public void Enqueue(IThreadPoolWorkItem callback, bool forceGlobal)
internal bool LocalFindAndPop(IThreadPoolWorkItem callback)
public void Dequeue(ThreadPoolWorkQueueThreadLocals tl, IThreadPoolWorkItem& callback, Boolean& missedSteal)
internal bool Dispatch()
}
internal System.Threading.ThreadPoolWorkQueueThreadLocals : object {
public ThreadPoolWorkQueueThreadLocals threadLocals
public ThreadPoolWorkQueue workQueue
public WorkStealingQueue workStealingQueue
public Random random
public void .ctor(ThreadPoolWorkQueue tpq)
private void CleanUp()
protected void Finalize()
}
public System.Threading.ThreadPriority : Enum {
public int value__
public ThreadPriority Lowest
public ThreadPriority BelowNormal
public ThreadPriority Normal
public ThreadPriority AboveNormal
public ThreadPriority Highest
}
public System.Threading.ThreadStart : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke()
public IAsyncResult BeginInvoke(AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.Threading.ThreadStartException : SystemException {
private void .ctor(Exception reason)
internal void .ctor(SerializationInfo info, StreamingContext context)
}
public System.Threading.ThreadState : Enum {
public int value__
public ThreadState Running
public ThreadState StopRequested
public ThreadState SuspendRequested
public ThreadState Background
public ThreadState Unstarted
public ThreadState Stopped
public ThreadState WaitSleepJoin
public ThreadState Suspended
public ThreadState AbortRequested
public ThreadState Aborted
}
public System.Threading.ThreadStateException : SystemException {
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
protected void .ctor(SerializationInfo info, StreamingContext context)
}
public System.Threading.Timeout : object {
public TimeSpan InfiniteTimeSpan
public int Infinite
internal UInt32 UnsignedInfinite
}
internal System.Threading.TimeoutHelper : object {
public UInt32 GetTime()
public int UpdateTimeOut(UInt32 startTime, int originalWaitMillisecondsTimeout)
}
public System.Threading.Timer : MarshalByRefObject {
private Scheduler scheduler
private TimerCallback callback
private object state
private long due_time_ms
private long period_ms
private long next_run
private bool disposed
private long MaxValue
public void .ctor(TimerCallback callback, object state, int dueTime, int period)
public void .ctor(TimerCallback callback, object state, long dueTime, long period)
public void .ctor(TimerCallback callback, object state, TimeSpan dueTime, TimeSpan period)
public void .ctor(TimerCallback callback, object state, UInt32 dueTime, UInt32 period)
public void .ctor(TimerCallback callback)
private void Init(TimerCallback callback, object state, long dueTime, long period)
public bool Change(int dueTime, int period)
public bool Change(TimeSpan dueTime, TimeSpan period)
public bool Change(UInt32 dueTime, UInt32 period)
public void Dispose()
public bool Change(long dueTime, long period)
private bool Change(long dueTime, long period, bool first)
public bool Dispose(WaitHandle notifyObject)
internal void KeepRootedWhileScheduled()
private long GetTimeMonotonic()
}
public System.Threading.TimerCallback : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object state)
public IAsyncResult BeginInvoke(object state, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.Threading.Volatile : object {
public bool Read(Boolean& location)
public byte Read(Byte& location)
public sbyte Read(SByte& location)
public short Read(Int16& location)
public ushort Read(UInt16& location)
public int Read(Int32& location)
public UInt32 Read(UInt32& location)
public long Read(Int64& location)
public ulong Read(UInt64& location)
public IntPtr Read(IntPtr& location)
public UIntPtr Read(UIntPtr& location)
public double Read(Double& location)
public float Read(Single& location)
public T Read(T& location)
public void Write(Boolean& location, bool value)
public void Write(Byte& location, byte value)
public void Write(SByte& location, sbyte value)
public void Write(Int16& location, short value)
public void Write(UInt16& location, ushort value)
public void Write(Int32& location, int value)
public void Write(UInt32& location, UInt32 value)
public void Write(Int64& location, long value)
public void Write(UInt64& location, ulong value)
public void Write(IntPtr& location, IntPtr value)
public void Write(UIntPtr& location, UIntPtr value)
public void Write(Double& location, double value)
public void Write(Single& location, float value)
public void Write(T& location, T value)
}
public System.Threading.WaitCallback : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object state)
public IAsyncResult BeginInvoke(object state, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.Threading.WaitHandle : MarshalByRefObject {
public int WaitTimeout
private int MAX_WAITHANDLES
private IntPtr waitHandle
internal SafeWaitHandle modreq(System.Runtime.CompilerServices.IsVolatile) safeWaitHandle
internal bool hasThreadAffinity
private int WAIT_OBJECT_0
private int WAIT_ABANDONED
private int WAIT_FAILED
private int ERROR_TOO_MANY_POSTS
protected IntPtr InvalidHandle
internal int MaxWaitHandles
public IntPtr Handle
public SafeWaitHandle SafeWaitHandle
private void Init()
public IntPtr get_Handle()
public void set_Handle(IntPtr value)
public SafeWaitHandle get_SafeWaitHandle()
public void set_SafeWaitHandle(SafeWaitHandle value)
internal void SetHandleInternal(SafeWaitHandle handle)
public bool WaitOne(int millisecondsTimeout, bool exitContext)
public bool WaitOne(TimeSpan timeout, bool exitContext)
public bool WaitOne()
public bool WaitOne(int millisecondsTimeout)
public bool WaitOne(TimeSpan timeout)
private bool WaitOne(long timeout, bool exitContext)
internal bool InternalWaitOne(SafeHandle waitableSafeHandle, long millisecondsTimeout, bool hasThreadAffinity, bool exitContext)
internal bool WaitOneWithoutFAS()
public bool WaitAll(WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext)
public bool WaitAll(WaitHandle[] waitHandles, TimeSpan timeout, bool exitContext)
public bool WaitAll(WaitHandle[] waitHandles)
public bool WaitAll(WaitHandle[] waitHandles, int millisecondsTimeout)
public bool WaitAll(WaitHandle[] waitHandles, TimeSpan timeout)
public int WaitAny(WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext)
public int WaitAny(WaitHandle[] waitHandles, TimeSpan timeout, bool exitContext)
public int WaitAny(WaitHandle[] waitHandles, TimeSpan timeout)
public int WaitAny(WaitHandle[] waitHandles)
public int WaitAny(WaitHandle[] waitHandles, int millisecondsTimeout)
public bool SignalAndWait(WaitHandle toSignal, WaitHandle toWaitOn)
public bool SignalAndWait(WaitHandle toSignal, WaitHandle toWaitOn, TimeSpan timeout, bool exitContext)
public bool SignalAndWait(WaitHandle toSignal, WaitHandle toWaitOn, int millisecondsTimeout, bool exitContext)
private void ThrowAbandonedMutexException()
private void ThrowAbandonedMutexException(int location, WaitHandle handle)
public void Close()
protected void Dispose(bool explicitDisposing)
public void Dispose()
private int WaitMultiple(WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext, bool WaitAll)
private int WaitOneNative(SafeHandle waitableSafeHandle, UInt32 millisecondsTimeout, bool hasThreadAffinity, bool exitContext)
private int Wait_internal(IntPtr* handles, int numHandles, bool waitAll, int ms)
private int SignalAndWaitOne(SafeWaitHandle waitHandleToSignal, SafeWaitHandle waitHandleToWaitOn, int millisecondsTimeout, bool hasThreadAffinity, bool exitContext)
private int SignalAndWait_Internal(IntPtr toSignal, IntPtr toWaitOn, int ms)
}
public System.Threading.WaitHandleCannotBeOpenedException : ApplicationException {
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
protected void .ctor(SerializationInfo info, StreamingContext context)
}
public System.Threading.WaitHandleExtensions : object {
public SafeWaitHandle GetSafeWaitHandle(WaitHandle waitHandle)
public void SetSafeWaitHandle(WaitHandle waitHandle, SafeWaitHandle value)
}
public System.Threading.WaitOrTimerCallback : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object state, bool timedOut)
public IAsyncResult BeginInvoke(object state, bool timedOut, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
internal System.ThrowHelper : object {
internal void ThrowArgumentNullException(ExceptionArgument argument)
private Exception CreateArgumentNullException(ExceptionArgument argument)
internal void ThrowArrayTypeMismatchException_ArrayTypeMustBeExactMatch(Type type)
private Exception CreateArrayTypeMismatchException_ArrayTypeMustBeExactMatch(Type type)
internal void ThrowArgumentException_InvalidTypeWithPointersNotSupported(Type type)
private Exception CreateArgumentException_InvalidTypeWithPointersNotSupported(Type type)
internal void ThrowArgumentException_DestinationTooShort()
private Exception CreateArgumentException_DestinationTooShort()
internal void ThrowIndexOutOfRangeException()
private Exception CreateIndexOutOfRangeException()
internal void ThrowArgumentOutOfRangeException(ExceptionArgument argument)
private Exception CreateArgumentOutOfRangeException(ExceptionArgument argument)
internal void ThrowInvalidOperationException_OutstandingReferences()
private Exception CreateInvalidOperationException_OutstandingReferences()
internal void ThrowObjectDisposedException_MemoryDisposed(string objectName)
private Exception CreateObjectDisposedException_MemoryDisposed(string objectName)
internal void ThrowArgumentOutOfRangeException()
internal void ThrowWrongKeyTypeArgumentException(object key, Type targetType)
internal void ThrowWrongValueTypeArgumentException(object value, Type targetType)
internal void ThrowKeyNotFoundException()
internal void ThrowArgumentException(ExceptionResource resource)
internal void ThrowArgumentException(ExceptionResource resource, ExceptionArgument argument)
internal void ThrowArgumentOutOfRangeException(ExceptionArgument argument, ExceptionResource resource)
internal void ThrowInvalidOperationException(ExceptionResource resource)
internal void ThrowSerializationException(ExceptionResource resource)
internal void ThrowSecurityException(ExceptionResource resource)
internal void ThrowNotSupportedException(ExceptionResource resource)
internal void ThrowUnauthorizedAccessException(ExceptionResource resource)
internal void ThrowObjectDisposedException(string objectName, ExceptionResource resource)
internal void IfNullAndNullsAreIllegalThenThrow(object value, ExceptionArgument argName)
internal string GetArgumentName(ExceptionArgument argument)
internal string GetResourceName(ExceptionResource resource)
}
public System.TimeoutException : SystemException {
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
protected void .ctor(SerializationInfo info, StreamingContext context)
}
public System.TimeSpan : ValueType {
public long TicksPerMillisecond
private double MillisecondsPerTick
public long TicksPerSecond
private double SecondsPerTick
public long TicksPerMinute
private double MinutesPerTick
public long TicksPerHour
private double HoursPerTick
public long TicksPerDay
private double DaysPerTick
private int MillisPerSecond
private int MillisPerMinute
private int MillisPerHour
private int MillisPerDay
internal long MaxSeconds
internal long MinSeconds
internal long MaxMilliSeconds
internal long MinMilliSeconds
internal long TicksPerTenthSecond
public TimeSpan Zero
public TimeSpan MaxValue
public TimeSpan MinValue
internal long _ticks
private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _legacyConfigChecked
private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _legacyMode
public long Ticks
public int Days
public int Hours
public int Milliseconds
public int Minutes
public int Seconds
public double TotalDays
public double TotalHours
public double TotalMilliseconds
public double TotalMinutes
public double TotalSeconds
private bool LegacyMode
public void .ctor(long ticks)
public void .ctor(int hours, int minutes, int seconds)
public void .ctor(int days, int hours, int minutes, int seconds)
public void .ctor(int days, int hours, int minutes, int seconds, int milliseconds)
public long get_Ticks()
public int get_Days()
public int get_Hours()
public int get_Milliseconds()
public int get_Minutes()
public int get_Seconds()
public double get_TotalDays()
public double get_TotalHours()
public double get_TotalMilliseconds()
public double get_TotalMinutes()
public double get_TotalSeconds()
public TimeSpan Add(TimeSpan ts)
public int Compare(TimeSpan t1, TimeSpan t2)
public int CompareTo(object value)
public int CompareTo(TimeSpan value)
public TimeSpan FromDays(double value)
public TimeSpan Duration()
public bool Equals(object value)
public bool Equals(TimeSpan obj)
public bool Equals(TimeSpan t1, TimeSpan t2)
public int GetHashCode()
public TimeSpan FromHours(double value)
private TimeSpan Interval(double value, int scale)
public TimeSpan FromMilliseconds(double value)
public TimeSpan FromMinutes(double value)
public TimeSpan Negate()
public TimeSpan FromSeconds(double value)
public TimeSpan Subtract(TimeSpan ts)
public TimeSpan FromTicks(long value)
internal long TimeToTicks(int hour, int minute, int second)
public TimeSpan Parse(string s)
public TimeSpan Parse(string input, IFormatProvider formatProvider)
public TimeSpan ParseExact(string input, string format, IFormatProvider formatProvider)
public TimeSpan ParseExact(string input, String[] formats, IFormatProvider formatProvider)
public TimeSpan ParseExact(string input, string format, IFormatProvider formatProvider, TimeSpanStyles styles)
public TimeSpan ParseExact(string input, String[] formats, IFormatProvider formatProvider, TimeSpanStyles styles)
public bool TryParse(string s, TimeSpan& result)
public bool TryParse(string input, IFormatProvider formatProvider, TimeSpan& result)
public bool TryParseExact(string input, string format, IFormatProvider formatProvider, TimeSpan& result)
public bool TryParseExact(string input, String[] formats, IFormatProvider formatProvider, TimeSpan& result)
public bool TryParseExact(string input, string format, IFormatProvider formatProvider, TimeSpanStyles styles, TimeSpan& result)
public bool TryParseExact(string input, String[] formats, IFormatProvider formatProvider, TimeSpanStyles styles, TimeSpan& result)
public string ToString()
public string ToString(string format)
public string ToString(string format, IFormatProvider formatProvider)
public TimeSpan op_UnaryNegation(TimeSpan t)
public TimeSpan op_Subtraction(TimeSpan t1, TimeSpan t2)
public TimeSpan op_UnaryPlus(TimeSpan t)
public TimeSpan op_Addition(TimeSpan t1, TimeSpan t2)
public bool op_Equality(TimeSpan t1, TimeSpan t2)
public bool op_Inequality(TimeSpan t1, TimeSpan t2)
public bool op_LessThan(TimeSpan t1, TimeSpan t2)
public bool op_LessThanOrEqual(TimeSpan t1, TimeSpan t2)
public bool op_GreaterThan(TimeSpan t1, TimeSpan t2)
public bool op_GreaterThanOrEqual(TimeSpan t1, TimeSpan t2)
private bool LegacyFormatMode()
private bool GetLegacyFormatMode()
private bool get_LegacyMode()
}
internal System.TimeType : object {
public int Offset
public bool IsDst
public string Name
public void .ctor(int offset, bool is_dst, string abbrev)
public string ToString()
}
public System.TimeZone : object {
private TimeZone currentTimeZone
private object tz_lock
private long timezone_check
public TimeZone CurrentTimeZone
public string DaylightName
public string StandardName
public TimeZone get_CurrentTimeZone()
public string get_DaylightName()
public string get_StandardName()
public DaylightTime GetDaylightChanges(int year)
public TimeSpan GetUtcOffset(DateTime time)
public bool IsDaylightSavingTime(DateTime time)
public bool IsDaylightSavingTime(DateTime time, DaylightTime daylightTimes)
public DateTime ToLocalTime(DateTime time)
public DateTime ToUniversalTime(DateTime time)
internal void ClearCachedData()
}
public System.TimeZoneInfo : object {
internal UInt32 TIME_ZONE_ID_INVALID
internal UInt32 ERROR_NO_MORE_ITEMS
private TimeSpan baseUtcOffset
private string daylightDisplayName
private string displayName
private string id
private TimeZoneInfo local
private List`1<KeyValuePair`2<DateTime, TimeType>> transitions
private bool readlinkNotFound
private string standardDisplayName
private bool supportsDaylightSavingTime
private TimeZoneInfo utc
private string timeZoneDirectory
private AdjustmentRule[] adjustmentRules
private RegistryKey timeZoneKey
private RegistryKey localZoneKey
private ReadOnlyCollection`1<TimeZoneInfo> systemTimeZones
private int BUFFER_SIZE
public TimeSpan BaseUtcOffset
public string DaylightName
public string DisplayName
public string Id
public TimeZoneInfo Local
public string StandardName
public bool SupportsDaylightSavingTime
public TimeZoneInfo Utc
private string TimeZoneDirectory
private bool IsWindows
private RegistryKey TimeZoneKey
private RegistryKey LocalZoneKey
internal bool UtcOffsetOutOfRange(TimeSpan offset)
private void ValidateTimeZoneInfo(string id, TimeSpan baseUtcOffset, AdjustmentRule[] adjustmentRules, Boolean& adjustmentRulesSupportDst)
public TimeZoneInfo FromSerializedString(string source)
public string ToSerializedString()
private AdjustmentRule DeserializeAdjustmentRule(StringBuilder& input)
private TransitionTime DeserializeTransitionTime(StringBuilder& input)
private string DeserializeString(StringBuilder& input)
private int DeserializeInt(StringBuilder& input)
private DateTime DeserializeDate(StringBuilder& input)
private DateTime DeserializeTime(StringBuilder& input)
private string EscapeForSerialization(string unescaped)
private string SerializeTransitionTime(TransitionTime transition)
private List`1<AdjustmentRule> CreateAdjustmentRule(int year, Int64[]& data, String[]& names, string standardNameCurrentYear, string daylightNameCurrentYear)
private TimeZoneInfo CreateLocalUnity()
internal UInt32 EnumDynamicTimeZoneInformation(UInt32 dwIndex, DYNAMIC_TIME_ZONE_INFORMATION& lpTimeZoneInformation)
internal UInt32 GetDynamicTimeZoneInformation(DYNAMIC_TIME_ZONE_INFORMATION& pTimeZoneInformation)
internal UInt32 GetDynamicTimeZoneInformationEffectiveYears(DYNAMIC_TIME_ZONE_INFORMATION& lpTimeZoneInformation, UInt32& FirstYear, UInt32& LastYear)
internal bool GetTimeZoneInformationForYear(ushort wYear, DYNAMIC_TIME_ZONE_INFORMATION& pdtzi, TIME_ZONE_INFORMATION& ptzi)
internal AdjustmentRule CreateAdjustmentRuleFromTimeZoneInformation(DYNAMIC_TIME_ZONE_INFORMATION& timeZoneInformation, DateTime startDate, DateTime endDate, int defaultBaseUtcOffset)
private bool TransitionTimeFromTimeZoneInformation(DYNAMIC_TIME_ZONE_INFORMATION timeZoneInformation, TransitionTime& transitionTime, bool readStartDate)
internal TimeZoneInfo TryCreateTimeZone(DYNAMIC_TIME_ZONE_INFORMATION timeZoneInformation)
internal TimeZoneInfo GetLocalTimeZoneInfoWinRTFallback()
internal TimeZoneInfo FindSystemTimeZoneByIdWinRTFallback(string id)
internal List`1<TimeZoneInfo> GetSystemTimeZonesWinRTFallback()
public TimeSpan get_BaseUtcOffset()
public string get_DaylightName()
public string get_DisplayName()
public string get_Id()
public TimeZoneInfo get_Local()
private int readlink(string path, Byte[] buffer, int buflen)
private string readlink(string path)
private bool TryGetNameFromPath(string path, String& name)
private TimeZoneInfo CreateLocal()
private TimeZoneInfo FindSystemTimeZoneByIdCore(string id)
private void GetSystemTimeZonesCore(List`1<TimeZoneInfo> systemTimeZones)
public string get_StandardName()
public bool get_SupportsDaylightSavingTime()
public TimeZoneInfo get_Utc()
private string get_TimeZoneDirectory()
private void set_TimeZoneDirectory(string value)
private bool get_IsWindows()
private string TrimSpecial(string str)
private RegistryKey get_TimeZoneKey()
private RegistryKey get_LocalZoneKey()
private bool TryAddTicks(DateTime date, long ticks, DateTime& result, DateTimeKind kind)
public void ClearCachedData()
public DateTime ConvertTime(DateTime dateTime, TimeZoneInfo destinationTimeZone)
public DateTime ConvertTime(DateTime dateTime, TimeZoneInfo sourceTimeZone, TimeZoneInfo destinationTimeZone)
public DateTimeOffset ConvertTime(DateTimeOffset dateTimeOffset, TimeZoneInfo destinationTimeZone)
public DateTime ConvertTimeBySystemTimeZoneId(DateTime dateTime, string destinationTimeZoneId)
public DateTime ConvertTimeBySystemTimeZoneId(DateTime dateTime, string sourceTimeZoneId, string destinationTimeZoneId)
public DateTimeOffset ConvertTimeBySystemTimeZoneId(DateTimeOffset dateTimeOffset, string destinationTimeZoneId)
private DateTime ConvertTimeFromUtc(DateTime dateTime)
public DateTime ConvertTimeFromUtc(DateTime dateTime, TimeZoneInfo destinationTimeZone)
public DateTime ConvertTimeToUtc(DateTime dateTime)
internal DateTime ConvertTimeToUtc(DateTime dateTime, TimeZoneInfoOptions flags)
public DateTime ConvertTimeToUtc(DateTime dateTime, TimeZoneInfo sourceTimeZone)
private DateTime ConvertTimeToUtc(DateTime dateTime, TimeZoneInfo sourceTimeZone, TimeZoneInfoOptions flags)
internal TimeSpan GetDateTimeNowUtcOffsetFromUtc(DateTime time, Boolean& isAmbiguousLocalDst)
public TimeZoneInfo CreateCustomTimeZone(string id, TimeSpan baseUtcOffset, string displayName, string standardDisplayName)
public TimeZoneInfo CreateCustomTimeZone(string id, TimeSpan baseUtcOffset, string displayName, string standardDisplayName, string daylightDisplayName, AdjustmentRule[] adjustmentRules)
public TimeZoneInfo CreateCustomTimeZone(string id, TimeSpan baseUtcOffset, string displayName, string standardDisplayName, string daylightDisplayName, AdjustmentRule[] adjustmentRules, bool disableDaylightSavingTime)
public bool Equals(object obj)
public bool Equals(TimeZoneInfo other)
public TimeZoneInfo FindSystemTimeZoneById(string id)
private TimeZoneInfo FindSystemTimeZoneByFileName(string id, string filepath)
private TimeZoneInfo FromRegistryKey(string id, RegistryKey key)
private void ParseRegTzi(List`1<AdjustmentRule> adjustmentRules, int start_year, int end_year, Byte[] buffer)
public AdjustmentRule[] GetAdjustmentRules()
public TimeSpan[] GetAmbiguousTimeOffsets(DateTime dateTime)
public TimeSpan[] GetAmbiguousTimeOffsets(DateTimeOffset dateTimeOffset)
public int GetHashCode()
private void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context)
public ReadOnlyCollection`1<TimeZoneInfo> GetSystemTimeZones()
public TimeSpan GetUtcOffset(DateTime dateTime)
public TimeSpan GetUtcOffset(DateTimeOffset dateTimeOffset)
private TimeSpan GetUtcOffset(DateTime dateTime, Boolean& isDST)
private TimeSpan GetUtcOffsetHelper(DateTime dateTime, TimeZoneInfo tz, Boolean& isDST)
public bool HasSameRules(TimeZoneInfo other)
public bool IsAmbiguousTime(DateTime dateTime)
public bool IsAmbiguousTime(DateTimeOffset dateTimeOffset)
private bool IsInDST(AdjustmentRule rule, DateTime dateTime)
private bool IsInDSTForYear(AdjustmentRule rule, DateTime dateTime, int year)
public bool IsDaylightSavingTime(DateTime dateTime)
internal bool IsDaylightSavingTime(DateTime dateTime, TimeZoneInfoOptions flags)
public bool IsDaylightSavingTime(DateTimeOffset dateTimeOffset)
internal DaylightTime GetDaylightChanges(int year)
public bool IsInvalidTime(DateTime dateTime)
private void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender)
private void Validate(string id, TimeSpan baseUtcOffset, AdjustmentRule[] adjustmentRules)
public string ToString()
private void .ctor(SerializationInfo info, StreamingContext context)
private void .ctor(string id, TimeSpan baseUtcOffset, string displayName, string standardDisplayName, string daylightDisplayName, AdjustmentRule[] adjustmentRules, bool disableDaylightSavingTime)
private AdjustmentRule GetApplicableRule(DateTime dateTime)
private bool TryGetTransitionOffset(DateTime dateTime, TimeSpan& offset, Boolean& isDst)
private DateTime TransitionPoint(TransitionTime transition, int year)
private AdjustmentRule[] ValidateRules(List`1<AdjustmentRule> adjustmentRules)
private TimeZoneInfo BuildFromStream(string id, Stream stream)
private bool ValidTZFile(Byte[] buffer, int length)
private int SwapInt32(int i)
private int ReadBigEndianInt32(Byte[] buffer, int start)
private TimeZoneInfo ParseTZBuffer(string id, Byte[] buffer, int length)
private Dictionary`2<int, string> ParseAbbreviations(Byte[] buffer, int index, int count)
private Dictionary`2<int, TimeType> ParseTimesTypes(Byte[] buffer, int index, int count, Dictionary`2<int, string> abbreviations)
private List`1<KeyValuePair`2<DateTime, TimeType>> ParseTransitions(Byte[] buffer, int index, int count, Dictionary`2<int, TimeType> time_types)
private DateTime DateTimeFromUnixTime(long unix_time)
internal TimeSpan GetLocalUtcOffset(DateTime dateTime, TimeZoneInfoOptions flags)
internal TimeSpan GetUtcOffset(DateTime dateTime, TimeZoneInfoOptions flags)
internal TimeSpan GetUtcOffsetFromUtc(DateTime time, TimeZoneInfo zone, Boolean& isDaylightSavings, Boolean& isAmbiguousLocalDst)
}
internal System.TimeZoneInfoOptions : Enum {
public int value__
public TimeZoneInfoOptions None
public TimeZoneInfoOptions NoThrowOnInvalidTime
}
public System.TimeZoneNotFoundException : Exception {
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
protected void .ctor(SerializationInfo info, StreamingContext context)
}
internal System.TokenType : Enum {
public int value__
public TokenType NumberToken
public TokenType YearNumberToken
public TokenType Am
public TokenType Pm
public TokenType MonthToken
public TokenType EndOfString
public TokenType DayOfWeekToken
public TokenType TimeZoneToken
public TokenType EraToken
public TokenType DateWordToken
public TokenType UnknownToken
public TokenType HebrewNumber
public TokenType JapaneseEraToken
public TokenType TEraToken
public TokenType IgnorableSymbol
public TokenType SEP_Unk
public TokenType SEP_End
public TokenType SEP_Space
public TokenType SEP_Am
public TokenType SEP_Pm
public TokenType SEP_Date
public TokenType SEP_Time
public TokenType SEP_YearSuff
public TokenType SEP_MonthSuff
public TokenType SEP_DaySuff
public TokenType SEP_HourSuff
public TokenType SEP_MinuteSuff
public TokenType SEP_SecondSuff
public TokenType SEP_LocalTimeMark
public TokenType SEP_DateOrOffset
public TokenType RegularTokenMask
public TokenType SeparatorTokenMask
}
public System.Tuple : object {
public Tuple`1<T1> Create(T1 item1)
public Tuple`2<T1, T2> Create(T1 item1, T2 item2)
public Tuple`3<T1, T2, T3> Create(T1 item1, T2 item2, T3 item3)
public Tuple`4<T1, T2, T3, T4> Create(T1 item1, T2 item2, T3 item3, T4 item4)
public Tuple`5<T1, T2, T3, T4, T5> Create(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5)
public Tuple`6<T1, T2, T3, T4, T5, T6> Create(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6)
public Tuple`7<T1, T2, T3, T4, T5, T6, T7> Create(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7)
public Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`1<T8>> Create(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7, T8 item8)
internal int CombineHashCodes(int h1, int h2)
internal int CombineHashCodes(int h1, int h2, int h3)
internal int CombineHashCodes(int h1, int h2, int h3, int h4)
internal int CombineHashCodes(int h1, int h2, int h3, int h4, int h5)
internal int CombineHashCodes(int h1, int h2, int h3, int h4, int h5, int h6)
internal int CombineHashCodes(int h1, int h2, int h3, int h4, int h5, int h6, int h7)
internal int CombineHashCodes(int h1, int h2, int h3, int h4, int h5, int h6, int h7, int h8)
}
public System.Tuple`1 : object {
private T1 m_Item1
public T1 Item1
private int System.Runtime.CompilerServices.ITuple.Length
private object System.Runtime.CompilerServices.ITuple.Item
public T1 get_Item1()
public void .ctor(T1 item1)
public bool Equals(object obj)
private bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer)
private int System.IComparable.CompareTo(object obj)
private int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer)
public int GetHashCode()
private int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer)
private int System.ITupleInternal.GetHashCode(IEqualityComparer comparer)
public string ToString()
private string System.ITupleInternal.ToString(StringBuilder sb)
private int System.Runtime.CompilerServices.ITuple.get_Length()
private object System.Runtime.CompilerServices.ITuple.get_Item(int index)
}
public System.Tuple`2 : object {
private T1 m_Item1
private T2 m_Item2
public T1 Item1
public T2 Item2
private int System.Runtime.CompilerServices.ITuple.Length
private object System.Runtime.CompilerServices.ITuple.Item
public T1 get_Item1()
public T2 get_Item2()
public void .ctor(T1 item1, T2 item2)
public bool Equals(object obj)
private bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer)
private int System.IComparable.CompareTo(object obj)
private int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer)
public int GetHashCode()
private int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer)
private int System.ITupleInternal.GetHashCode(IEqualityComparer comparer)
public string ToString()
private string System.ITupleInternal.ToString(StringBuilder sb)
private int System.Runtime.CompilerServices.ITuple.get_Length()
private object System.Runtime.CompilerServices.ITuple.get_Item(int index)
}
public System.Tuple`3 : object {
private T1 m_Item1
private T2 m_Item2
private T3 m_Item3
public T1 Item1
public T2 Item2
public T3 Item3
private int System.Runtime.CompilerServices.ITuple.Length
private object System.Runtime.CompilerServices.ITuple.Item
public T1 get_Item1()
public T2 get_Item2()
public T3 get_Item3()
public void .ctor(T1 item1, T2 item2, T3 item3)
public bool Equals(object obj)
private bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer)
private int System.IComparable.CompareTo(object obj)
private int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer)
public int GetHashCode()
private int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer)
private int System.ITupleInternal.GetHashCode(IEqualityComparer comparer)
public string ToString()
private string System.ITupleInternal.ToString(StringBuilder sb)
private int System.Runtime.CompilerServices.ITuple.get_Length()
private object System.Runtime.CompilerServices.ITuple.get_Item(int index)
}
public System.Tuple`4 : object {
private T1 m_Item1
private T2 m_Item2
private T3 m_Item3
private T4 m_Item4
public T1 Item1
public T2 Item2
public T3 Item3
public T4 Item4
private int System.Runtime.CompilerServices.ITuple.Length
private object System.Runtime.CompilerServices.ITuple.Item
public T1 get_Item1()
public T2 get_Item2()
public T3 get_Item3()
public T4 get_Item4()
public void .ctor(T1 item1, T2 item2, T3 item3, T4 item4)
public bool Equals(object obj)
private bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer)
private int System.IComparable.CompareTo(object obj)
private int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer)
public int GetHashCode()
private int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer)
private int System.ITupleInternal.GetHashCode(IEqualityComparer comparer)
public string ToString()
private string System.ITupleInternal.ToString(StringBuilder sb)
private int System.Runtime.CompilerServices.ITuple.get_Length()
private object System.Runtime.CompilerServices.ITuple.get_Item(int index)
}
public System.Tuple`5 : object {
private T1 m_Item1
private T2 m_Item2
private T3 m_Item3
private T4 m_Item4
private T5 m_Item5
public T1 Item1
public T2 Item2
public T3 Item3
public T4 Item4
public T5 Item5
private int System.Runtime.CompilerServices.ITuple.Length
private object System.Runtime.CompilerServices.ITuple.Item
public T1 get_Item1()
public T2 get_Item2()
public T3 get_Item3()
public T4 get_Item4()
public T5 get_Item5()
public void .ctor(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5)
public bool Equals(object obj)
private bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer)
private int System.IComparable.CompareTo(object obj)
private int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer)
public int GetHashCode()
private int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer)
private int System.ITupleInternal.GetHashCode(IEqualityComparer comparer)
public string ToString()
private string System.ITupleInternal.ToString(StringBuilder sb)
private int System.Runtime.CompilerServices.ITuple.get_Length()
private object System.Runtime.CompilerServices.ITuple.get_Item(int index)
}
public System.Tuple`6 : object {
private T1 m_Item1
private T2 m_Item2
private T3 m_Item3
private T4 m_Item4
private T5 m_Item5
private T6 m_Item6
public T1 Item1
public T2 Item2
public T3 Item3
public T4 Item4
public T5 Item5
public T6 Item6
private int System.Runtime.CompilerServices.ITuple.Length
private object System.Runtime.CompilerServices.ITuple.Item
public T1 get_Item1()
public T2 get_Item2()
public T3 get_Item3()
public T4 get_Item4()
public T5 get_Item5()
public T6 get_Item6()
public void .ctor(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6)
public bool Equals(object obj)
private bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer)
private int System.IComparable.CompareTo(object obj)
private int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer)
public int GetHashCode()
private int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer)
private int System.ITupleInternal.GetHashCode(IEqualityComparer comparer)
public string ToString()
private string System.ITupleInternal.ToString(StringBuilder sb)
private int System.Runtime.CompilerServices.ITuple.get_Length()
private object System.Runtime.CompilerServices.ITuple.get_Item(int index)
}
public System.Tuple`7 : object {
private T1 m_Item1
private T2 m_Item2
private T3 m_Item3
private T4 m_Item4
private T5 m_Item5
private T6 m_Item6
private T7 m_Item7
public T1 Item1
public T2 Item2
public T3 Item3
public T4 Item4
public T5 Item5
public T6 Item6
public T7 Item7
private int System.Runtime.CompilerServices.ITuple.Length
private object System.Runtime.CompilerServices.ITuple.Item
public T1 get_Item1()
public T2 get_Item2()
public T3 get_Item3()
public T4 get_Item4()
public T5 get_Item5()
public T6 get_Item6()
public T7 get_Item7()
public void .ctor(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7)
public bool Equals(object obj)
private bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer)
private int System.IComparable.CompareTo(object obj)
private int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer)
public int GetHashCode()
private int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer)
private int System.ITupleInternal.GetHashCode(IEqualityComparer comparer)
public string ToString()
private string System.ITupleInternal.ToString(StringBuilder sb)
private int System.Runtime.CompilerServices.ITuple.get_Length()
private object System.Runtime.CompilerServices.ITuple.get_Item(int index)
}
public System.Tuple`8 : object {
private T1 m_Item1
private T2 m_Item2
private T3 m_Item3
private T4 m_Item4
private T5 m_Item5
private T6 m_Item6
private T7 m_Item7
private TRest m_Rest
public T1 Item1
public T2 Item2
public T3 Item3
public T4 Item4
public T5 Item5
public T6 Item6
public T7 Item7
public TRest Rest
private int System.Runtime.CompilerServices.ITuple.Length
private object System.Runtime.CompilerServices.ITuple.Item
public T1 get_Item1()
public T2 get_Item2()
public T3 get_Item3()
public T4 get_Item4()
public T5 get_Item5()
public T6 get_Item6()
public T7 get_Item7()
public TRest get_Rest()
public void .ctor(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7, TRest rest)
public bool Equals(object obj)
private bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer)
private int System.IComparable.CompareTo(object obj)
private int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer)
public int GetHashCode()
private int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer)
private int System.ITupleInternal.GetHashCode(IEqualityComparer comparer)
public string ToString()
private string System.ITupleInternal.ToString(StringBuilder sb)
private int System.Runtime.CompilerServices.ITuple.get_Length()
private object System.Runtime.CompilerServices.ITuple.get_Item(int index)
}
public System.TupleExtensions : object {
public void Deconstruct(Tuple`1<T1> value, T1& item1)
public void Deconstruct(Tuple`2<T1, T2> value, T1& item1, T2& item2)
public void Deconstruct(Tuple`3<T1, T2, T3> value, T1& item1, T2& item2, T3& item3)
public void Deconstruct(Tuple`4<T1, T2, T3, T4> value, T1& item1, T2& item2, T3& item3, T4& item4)
public void Deconstruct(Tuple`5<T1, T2, T3, T4, T5> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5)
public void Deconstruct(Tuple`6<T1, T2, T3, T4, T5, T6> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6)
public void Deconstruct(Tuple`7<T1, T2, T3, T4, T5, T6, T7> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7)
public void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`1<T8>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8)
public void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`2<T8, T9>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8, T9& item9)
public void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`3<T8, T9, T10>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8, T9& item9, T10& item10)
public void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`4<T8, T9, T10, T11>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8, T9& item9, T10& item10, T11& item11)
public void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`5<T8, T9, T10, T11, T12>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8, T9& item9, T10& item10, T11& item11, T12& item12)
public void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`6<T8, T9, T10, T11, T12, T13>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8, T9& item9, T10& item10, T11& item11, T12& item12, T13& item13)
public void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`7<T8, T9, T10, T11, T12, T13, T14>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8, T9& item9, T10& item10, T11& item11, T12& item12, T13& item13, T14& item14)
public void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`1<T15>>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8, T9& item9, T10& item10, T11& item11, T12& item12, T13& item13, T14& item14, T15& item15)
public void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`2<T15, T16>>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8, T9& item9, T10& item10, T11& item11, T12& item12, T13& item13, T14& item14, T15& item15, T16& item16)
public void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`3<T15, T16, T17>>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8, T9& item9, T10& item10, T11& item11, T12& item12, T13& item13, T14& item14, T15& item15, T16& item16, T17& item17)
public void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`4<T15, T16, T17, T18>>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8, T9& item9, T10& item10, T11& item11, T12& item12, T13& item13, T14& item14, T15& item15, T16& item16, T17& item17, T18& item18)
public void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`5<T15, T16, T17, T18, T19>>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8, T9& item9, T10& item10, T11& item11, T12& item12, T13& item13, T14& item14, T15& item15, T16& item16, T17& item17, T18& item18, T19& item19)
public void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`6<T15, T16, T17, T18, T19, T20>>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8, T9& item9, T10& item10, T11& item11, T12& item12, T13& item13, T14& item14, T15& item15, T16& item16, T17& item17, T18& item18, T19& item19, T20& item20)
public void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`7<T15, T16, T17, T18, T19, T20, T21>>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8, T9& item9, T10& item10, T11& item11, T12& item12, T13& item13, T14& item14, T15& item15, T16& item16, T17& item17, T18& item18, T19& item19, T20& item20, T21& item21)
public ValueTuple`1<T1> ToValueTuple(Tuple`1<T1> value)
public ValueTuple`2<T1, T2> ToValueTuple(Tuple`2<T1, T2> value)
public ValueTuple`3<T1, T2, T3> ToValueTuple(Tuple`3<T1, T2, T3> value)
public ValueTuple`4<T1, T2, T3, T4> ToValueTuple(Tuple`4<T1, T2, T3, T4> value)
public ValueTuple`5<T1, T2, T3, T4, T5> ToValueTuple(Tuple`5<T1, T2, T3, T4, T5> value)
public ValueTuple`6<T1, T2, T3, T4, T5, T6> ToValueTuple(Tuple`6<T1, T2, T3, T4, T5, T6> value)
public ValueTuple`7<T1, T2, T3, T4, T5, T6, T7> ToValueTuple(Tuple`7<T1, T2, T3, T4, T5, T6, T7> value)
public ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`1<T8>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`1<T8>> value)
public ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`2<T8, T9>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`2<T8, T9>> value)
public ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`3<T8, T9, T10>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`3<T8, T9, T10>> value)
public ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`4<T8, T9, T10, T11>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`4<T8, T9, T10, T11>> value)
public ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`5<T8, T9, T10, T11, T12>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`5<T8, T9, T10, T11, T12>> value)
public ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`6<T8, T9, T10, T11, T12, T13>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`6<T8, T9, T10, T11, T12, T13>> value)
public ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`7<T8, T9, T10, T11, T12, T13, T14>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`7<T8, T9, T10, T11, T12, T13, T14>> value)
public ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`1<T15>>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`1<T15>>> value)
public ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`2<T15, T16>>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`2<T15, T16>>> value)
public ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`3<T15, T16, T17>>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`3<T15, T16, T17>>> value)
public ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`4<T15, T16, T17, T18>>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`4<T15, T16, T17, T18>>> value)
public ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`5<T15, T16, T17, T18, T19>>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`5<T15, T16, T17, T18, T19>>> value)
public ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`6<T15, T16, T17, T18, T19, T20>>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`6<T15, T16, T17, T18, T19, T20>>> value)
public ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`7<T15, T16, T17, T18, T19, T20, T21>>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`7<T15, T16, T17, T18, T19, T20, T21>>> value)
public Tuple`1<T1> ToTuple(ValueTuple`1<T1> value)
public Tuple`2<T1, T2> ToTuple(ValueTuple`2<T1, T2> value)
public Tuple`3<T1, T2, T3> ToTuple(ValueTuple`3<T1, T2, T3> value)
public Tuple`4<T1, T2, T3, T4> ToTuple(ValueTuple`4<T1, T2, T3, T4> value)
public Tuple`5<T1, T2, T3, T4, T5> ToTuple(ValueTuple`5<T1, T2, T3, T4, T5> value)
public Tuple`6<T1, T2, T3, T4, T5, T6> ToTuple(ValueTuple`6<T1, T2, T3, T4, T5, T6> value)
public Tuple`7<T1, T2, T3, T4, T5, T6, T7> ToTuple(ValueTuple`7<T1, T2, T3, T4, T5, T6, T7> value)
public Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`1<T8>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`1<T8>> value)
public Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`2<T8, T9>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`2<T8, T9>> value)
public Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`3<T8, T9, T10>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`3<T8, T9, T10>> value)
public Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`4<T8, T9, T10, T11>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`4<T8, T9, T10, T11>> value)
public Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`5<T8, T9, T10, T11, T12>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`5<T8, T9, T10, T11, T12>> value)
public Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`6<T8, T9, T10, T11, T12, T13>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`6<T8, T9, T10, T11, T12, T13>> value)
public Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`7<T8, T9, T10, T11, T12, T13, T14>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`7<T8, T9, T10, T11, T12, T13, T14>> value)
public Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`1<T15>>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`1<T15>>> value)
public Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`2<T15, T16>>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`2<T15, T16>>> value)
public Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`3<T15, T16, T17>>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`3<T15, T16, T17>>> value)
public Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`4<T15, T16, T17, T18>>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`4<T15, T16, T17, T18>>> value)
public Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`5<T15, T16, T17, T18, T19>>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`5<T15, T16, T17, T18, T19>>> value)
public Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`6<T15, T16, T17, T18, T19, T20>>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`6<T15, T16, T17, T18, T19, T20>>> value)
public Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`7<T15, T16, T17, T18, T19, T20, T21>>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`7<T15, T16, T17, T18, T19, T20, T21>>> value)
private ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, TRest> CreateLong(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7, TRest rest)
private Tuple`8<T1, T2, T3, T4, T5, T6, T7, TRest> CreateLongRef(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7, TRest rest)
}
public System.Type : MemberInfo {
public MemberFilter FilterAttribute
public MemberFilter FilterName
public MemberFilter FilterNameIgnoreCase
public object Missing
public char Delimiter
public Type[] EmptyTypes
private Binder defaultBinder
private BindingFlags DefaultLookup
internal BindingFlags DeclaredOnlyLookup
internal RuntimeTypeHandle _impl
public MemberTypes MemberType
public Type DeclaringType
public MethodBase DeclaringMethod
public Type ReflectedType
public StructLayoutAttribute StructLayoutAttribute
public Guid GUID
public Binder DefaultBinder
public Module Module
public Assembly Assembly
public RuntimeTypeHandle TypeHandle
public string FullName
public string Namespace
public string AssemblyQualifiedName
public Type BaseType
public ConstructorInfo TypeInitializer
public bool IsNested
public TypeAttributes Attributes
public GenericParameterAttributes GenericParameterAttributes
public bool IsVisible
public bool IsNotPublic
public bool IsPublic
public bool IsNestedPublic
public bool IsNestedPrivate
public bool IsNestedFamily
public bool IsNestedAssembly
public bool IsNestedFamANDAssem
public bool IsNestedFamORAssem
public bool IsAutoLayout
public bool IsLayoutSequential
public bool IsExplicitLayout
public bool IsClass
public bool IsInterface
public bool IsValueType
public bool IsAbstract
public bool IsSealed
public bool IsEnum
public bool IsSpecialName
public bool IsImport
public bool IsSerializable
public bool IsAnsiClass
public bool IsUnicodeClass
public bool IsAutoClass
public bool IsArray
internal bool IsSzArray
public bool IsGenericType
public bool IsGenericTypeDefinition
public bool IsConstructedGenericType
public bool IsGenericParameter
public int GenericParameterPosition
public bool ContainsGenericParameters
public bool IsByRef
public bool IsPointer
public bool IsPrimitive
public bool IsCOMObject
internal bool IsWindowsRuntimeObject
internal bool IsExportedToWindowsRuntime
public bool HasElementType
public bool IsContextful
public bool IsMarshalByRef
internal bool HasProxyAttribute
public Type[] GenericTypeArguments
public bool IsSecurityCritical
public bool IsSecuritySafeCritical
public bool IsSecurityTransparent
internal bool NeedsReflectionSecurityCheck
public Type UnderlyingSystemType
public bool IsSZArray
internal bool IsUserType
public MemberTypes get_MemberType()
public Type get_DeclaringType()
public MethodBase get_DeclaringMethod()
public Type get_ReflectedType()
public Type GetType(string typeName, Func`2<AssemblyName, Assembly> assemblyResolver, Func`4<Assembly, string, bool, Type> typeResolver)
public Type GetType(string typeName, Func`2<AssemblyName, Assembly> assemblyResolver, Func`4<Assembly, string, bool, Type> typeResolver, bool throwOnError)
public Type GetType(string typeName, Func`2<AssemblyName, Assembly> assemblyResolver, Func`4<Assembly, string, bool, Type> typeResolver, bool throwOnError, bool ignoreCase)
public Type MakePointerType()
public StructLayoutAttribute get_StructLayoutAttribute()
public Type MakeByRefType()
public Type MakeArrayType()
public Type MakeArrayType(int rank)
public Type GetTypeFromProgID(string progID)
public Type GetTypeFromProgID(string progID, bool throwOnError)
public Type GetTypeFromProgID(string progID, string server)
public Type GetTypeFromProgID(string progID, string server, bool throwOnError)
public Type GetTypeFromCLSID(Guid clsid)
public Type GetTypeFromCLSID(Guid clsid, bool throwOnError)
public Type GetTypeFromCLSID(Guid clsid, string server)
public Type GetTypeFromCLSID(Guid clsid, string server, bool throwOnError)
public TypeCode GetTypeCode(Type type)
protected TypeCode GetTypeCodeImpl()
public Guid get_GUID()
public Binder get_DefaultBinder()
private void CreateBinder()
public object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, Object[] args, ParameterModifier[] modifiers, CultureInfo culture, String[] namedParameters)
public object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, Object[] args, CultureInfo culture)
public object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, Object[] args)
public Module get_Module()
public Assembly get_Assembly()
public RuntimeTypeHandle get_TypeHandle()
internal RuntimeTypeHandle GetTypeHandleInternal()
public RuntimeTypeHandle GetTypeHandle(object o)
public string get_FullName()
public string get_Namespace()
public string get_AssemblyQualifiedName()
public int GetArrayRank()
public Type get_BaseType()
public ConstructorInfo GetConstructor(BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers)
public ConstructorInfo GetConstructor(BindingFlags bindingAttr, Binder binder, Type[] types, ParameterModifier[] modifiers)
public ConstructorInfo GetConstructor(Type[] types)
protected ConstructorInfo GetConstructorImpl(BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers)
public ConstructorInfo[] GetConstructors()
public ConstructorInfo[] GetConstructors(BindingFlags bindingAttr)
public ConstructorInfo get_TypeInitializer()
public MethodInfo GetMethod(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers)
public MethodInfo GetMethod(string name, BindingFlags bindingAttr, Binder binder, Type[] types, ParameterModifier[] modifiers)
public MethodInfo GetMethod(string name, Type[] types, ParameterModifier[] modifiers)
public MethodInfo GetMethod(string name, Type[] types)
public MethodInfo GetMethod(string name, BindingFlags bindingAttr)
public MethodInfo GetMethod(string name)
protected MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers)
public MethodInfo[] GetMethods()
public MethodInfo[] GetMethods(BindingFlags bindingAttr)
public FieldInfo GetField(string name, BindingFlags bindingAttr)
public FieldInfo GetField(string name)
public FieldInfo[] GetFields()
public FieldInfo[] GetFields(BindingFlags bindingAttr)
public Type GetInterface(string name)
public Type GetInterface(string name, bool ignoreCase)
public Type[] GetInterfaces()
public Type[] FindInterfaces(TypeFilter filter, object filterCriteria)
public EventInfo GetEvent(string name)
public EventInfo GetEvent(string name, BindingFlags bindingAttr)
public EventInfo[] GetEvents()
public EventInfo[] GetEvents(BindingFlags bindingAttr)
public PropertyInfo GetProperty(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers)
public PropertyInfo GetProperty(string name, Type returnType, Type[] types, ParameterModifier[] modifiers)
public PropertyInfo GetProperty(string name, BindingFlags bindingAttr)
public PropertyInfo GetProperty(string name, Type returnType, Type[] types)
public PropertyInfo GetProperty(string name, Type[] types)
public PropertyInfo GetProperty(string name, Type returnType)
internal PropertyInfo GetProperty(string name, BindingFlags bindingAttr, Type returnType)
public PropertyInfo GetProperty(string name)
protected PropertyInfo GetPropertyImpl(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers)
public PropertyInfo[] GetProperties(BindingFlags bindingAttr)
public PropertyInfo[] GetProperties()
public Type[] GetNestedTypes()
public Type[] GetNestedTypes(BindingFlags bindingAttr)
public Type GetNestedType(string name)
public Type GetNestedType(string name, BindingFlags bindingAttr)
public MemberInfo[] GetMember(string name)
public MemberInfo[] GetMember(string name, BindingFlags bindingAttr)
public MemberInfo[] GetMember(string name, MemberTypes type, BindingFlags bindingAttr)
public MemberInfo[] GetMembers()
public MemberInfo[] GetMembers(BindingFlags bindingAttr)
public MemberInfo[] GetDefaultMembers()
public MemberInfo[] FindMembers(MemberTypes memberType, BindingFlags bindingAttr, MemberFilter filter, object filterCriteria)
public bool get_IsNested()
public TypeAttributes get_Attributes()
public GenericParameterAttributes get_GenericParameterAttributes()
public bool get_IsVisible()
public bool get_IsNotPublic()
public bool get_IsPublic()
public bool get_IsNestedPublic()
public bool get_IsNestedPrivate()
public bool get_IsNestedFamily()
public bool get_IsNestedAssembly()
public bool get_IsNestedFamANDAssem()
public bool get_IsNestedFamORAssem()
public bool get_IsAutoLayout()
public bool get_IsLayoutSequential()
public bool get_IsExplicitLayout()
public bool get_IsClass()
public bool get_IsInterface()
public bool get_IsValueType()
public bool get_IsAbstract()
public bool get_IsSealed()
public bool get_IsEnum()
public bool get_IsSpecialName()
public bool get_IsImport()
public bool get_IsSerializable()
public bool get_IsAnsiClass()
public bool get_IsUnicodeClass()
public bool get_IsAutoClass()
public bool get_IsArray()
internal bool get_IsSzArray()
public bool get_IsGenericType()
public bool get_IsGenericTypeDefinition()
public bool get_IsConstructedGenericType()
public bool get_IsGenericParameter()
public int get_GenericParameterPosition()
public bool get_ContainsGenericParameters()
public Type[] GetGenericParameterConstraints()
public bool get_IsByRef()
public bool get_IsPointer()
public bool get_IsPrimitive()
public bool get_IsCOMObject()
internal bool get_IsWindowsRuntimeObject()
internal bool get_IsExportedToWindowsRuntime()
public bool get_HasElementType()
public bool get_IsContextful()
public bool get_IsMarshalByRef()
internal bool get_HasProxyAttribute()
protected bool IsValueTypeImpl()
protected TypeAttributes GetAttributeFlagsImpl()
protected bool IsArrayImpl()
protected bool IsByRefImpl()
protected bool IsPointerImpl()
protected bool IsPrimitiveImpl()
protected bool IsCOMObjectImpl()
internal bool IsWindowsRuntimeObjectImpl()
internal bool IsExportedToWindowsRuntimeImpl()
public Type MakeGenericType(Type[] typeArguments)
protected bool IsContextfulImpl()
protected bool IsMarshalByRefImpl()
internal bool HasProxyAttributeImpl()
public Type GetElementType()
public Type[] GetGenericArguments()
public Type[] get_GenericTypeArguments()
public Type GetGenericTypeDefinition()
protected bool HasElementTypeImpl()
internal Type GetRootElementType()
public String[] GetEnumNames()
public Array GetEnumValues()
private Array GetEnumRawConstantValues()
private void GetEnumData(String[]& enumNames, Array& enumValues)
public Type GetEnumUnderlyingType()
public bool IsEnumDefined(object value)
public string GetEnumName(object value)
private int BinarySearch(Array array, object value)
internal bool IsIntegerType(Type t)
public bool get_IsSecurityCritical()
public bool get_IsSecuritySafeCritical()
public bool get_IsSecurityTransparent()
internal bool get_NeedsReflectionSecurityCheck()
public Type get_UnderlyingSystemType()
public bool IsSubclassOf(Type c)
public bool IsInstanceOfType(object o)
public bool IsAssignableFrom(Type c)
public bool IsEquivalentTo(Type other)
internal bool ImplementInterface(Type ifaceType)
internal string FormatTypeName()
internal string FormatTypeName(bool serialization)
public string ToString()
public Type[] GetTypeArray(Object[] args)
public bool Equals(object o)
public bool Equals(Type o)
public bool op_Equality(Type left, Type right)
public bool op_Inequality(Type left, Type right)
public int GetHashCode()
public InterfaceMapping GetInterfaceMap(Type interfaceType)
public Type GetType()
private void System.Runtime.InteropServices._Type.GetTypeInfoCount(UInt32& pcTInfo)
private void System.Runtime.InteropServices._Type.GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo)
private void System.Runtime.InteropServices._Type.GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId)
private void System.Runtime.InteropServices._Type.Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr)
public bool get_IsSZArray()
private Type internal_from_name(string name, bool throwOnError, bool ignoreCase)
public Type GetType(string typeName)
public Type GetType(string typeName, bool throwOnError)
public Type GetType(string typeName, bool throwOnError, bool ignoreCase)
public Type ReflectionOnlyGetType(string typeName, bool throwIfNotFound, bool ignoreCase)
internal Type InternalResolve()
internal Type RuntimeResolve()
internal bool get_IsUserType()
internal MethodInfo GetMethod(MethodInfo fromNoninstanciated)
internal ConstructorInfo GetConstructor(ConstructorInfo fromNoninstanciated)
internal FieldInfo GetField(FieldInfo fromNoninstanciated)
public Type GetTypeFromHandle(RuntimeTypeHandle handle)
private Type internal_from_handle(IntPtr handle)
}
public System.TypeAccessException : TypeLoadException {
public void .ctor(string message)
public void .ctor(string message, Exception inner)
protected void .ctor(SerializationInfo info, StreamingContext context)
}
public System.TypeCode : Enum {
public int value__
public TypeCode Empty
public TypeCode Object
public TypeCode DBNull
public TypeCode Boolean
public TypeCode Char
public TypeCode SByte
public TypeCode Byte
public TypeCode Int16
public TypeCode UInt16
public TypeCode Int32
public TypeCode UInt32
public TypeCode Int64
public TypeCode UInt64
public TypeCode Single
public TypeCode Double
public TypeCode Decimal
public TypeCode DateTime
public TypeCode String
}
public System.TypedReference : ValueType {
private RuntimeTypeHandle type
private IntPtr Value
private IntPtr Type
internal bool IsNull
public TypedReference MakeTypedReference(object target, FieldInfo[] flds)
private TypedReference MakeTypedReferenceInternal(object target, FieldInfo[] fields)
public int GetHashCode()
public bool Equals(object o)
public object ToObject(TypedReference value)
internal object InternalToObject(Void* value)
internal bool get_IsNull()
public Type GetTargetType(TypedReference value)
public RuntimeTypeHandle TargetTypeToken(TypedReference value)
public void SetTypedReference(TypedReference target, object value)
}
internal System.TypeIdentifier {
public string InternalName
public string get_InternalName()
}
internal System.TypeIdentifiers : object {
internal TypeIdentifier FromDisplay(string displayName)
internal TypeIdentifier FromInternal(string internalName)
internal TypeIdentifier FromInternal(string internalNameSpace, TypeIdentifier typeName)
internal TypeIdentifier WithoutEscape(string simpleName)
}
public System.TypeInitializationException : SystemException {
private string _typeName
public string TypeName
private void .ctor(string message)
public void .ctor(string fullTypeName, Exception innerException)
internal void .ctor(SerializationInfo info, StreamingContext context)
public string get_TypeName()
public void GetObjectData(SerializationInfo info, StreamingContext context)
}
public System.TypeLoadException : SystemException {
private string ClassName
private string AssemblyName
private string MessageArg
internal int ResourceId
public string Message
public string TypeName
public void .ctor(string message)
public void .ctor(string message, Exception inner)
public string get_Message()
private void SetMessageField()
public string get_TypeName()
private void .ctor(string className, string assemblyName)
private void .ctor(string className, string assemblyName, string messageArg, int resourceId)
protected void .ctor(SerializationInfo info, StreamingContext context)
public void GetObjectData(SerializationInfo info, StreamingContext context)
}
internal System.TypeName {
public string DisplayName
public string get_DisplayName()
public TypeName NestedName(TypeIdentifier innerName)
}
internal System.TypeNameFormatFlags : Enum {
public int value__
public TypeNameFormatFlags FormatBasic
public TypeNameFormatFlags FormatNamespace
public TypeNameFormatFlags FormatFullInst
public TypeNameFormatFlags FormatAssembly
public TypeNameFormatFlags FormatSignature
public TypeNameFormatFlags FormatNoVersion
public TypeNameFormatFlags FormatAngleBrackets
public TypeNameFormatFlags FormatStubInfo
public TypeNameFormatFlags FormatGenericParam
public TypeNameFormatFlags FormatSerialization
}
internal System.TypeNameKind : Enum {
public int value__
public TypeNameKind Name
public TypeNameKind ToString
public TypeNameKind SerializationName
public TypeNameKind FullName
}
internal System.TypeNameParser : object {
internal Type GetType(string typeName, Func`2<AssemblyName, Assembly> assemblyResolver, Func`4<Assembly, string, bool, Type> typeResolver, bool throwOnError, bool ignoreCase, StackCrawlMark& stackMark)
}
internal System.TypeNames : object {
internal TypeName FromDisplay(string displayName)
}
internal System.TypeSpec : object {
private TypeIdentifier name
private string assembly_name
private List`1<TypeIdentifier> nested
private List`1<TypeSpec> generic_params
private List`1<ModifierSpec> modifier_spec
private bool is_byref
private string display_fullname
internal bool HasModifiers
internal bool IsNested
internal bool IsByRef
internal TypeName Name
internal IEnumerable`1<TypeName> Nested
internal IEnumerable`1<ModifierSpec> Modifiers
internal string DisplayFullName
internal TypeName TypeName
internal bool get_HasModifiers()
internal bool get_IsNested()
internal bool get_IsByRef()
internal TypeName get_Name()
internal IEnumerable`1<TypeName> get_Nested()
internal IEnumerable`1<ModifierSpec> get_Modifiers()
private string GetDisplayFullName(DisplayNameFormat flags)
internal string ModifierString()
private StringBuilder GetModifierString(StringBuilder sb)
internal string get_DisplayFullName()
internal TypeSpec Parse(string typeName)
internal string EscapeDisplayName(string internalName)
internal string UnescapeInternalName(string displayName)
internal bool NeedsEscaping(string internalName)
internal Type Resolve(Func`2<AssemblyName, Assembly> assemblyResolver, Func`4<Assembly, string, bool, Type> typeResolver, bool throwOnError, bool ignoreCase)
private void AddName(string type_name)
private void AddModifier(ModifierSpec md)
private void SkipSpace(string name, Int32& pos)
private void BoundCheck(int idx, string s)
private TypeIdentifier ParsedTypeIdentifier(string displayName)
private TypeSpec Parse(string name, Int32& p, bool is_recurse, bool allow_aqn)
internal TypeName TypeNameWithoutModifiers()
internal TypeName get_TypeName()
}
public System.TypeUnloadedException : SystemException {
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
protected void .ctor(SerializationInfo info, StreamingContext context)
}
public System.UInt16 : ValueType {
private ushort m_value
public ushort MaxValue
public ushort MinValue
public int CompareTo(object value)
public int CompareTo(ushort value)
public bool Equals(object obj)
public bool Equals(ushort obj)
public int GetHashCode()
public string ToString()
public string ToString(IFormatProvider provider)
public string ToString(string format)
public string ToString(string format, IFormatProvider provider)
public ushort Parse(string s)
public ushort Parse(string s, NumberStyles style)
public ushort Parse(string s, IFormatProvider provider)
public ushort Parse(string s, NumberStyles style, IFormatProvider provider)
private ushort Parse(string s, NumberStyles style, NumberFormatInfo info)
public bool TryParse(string s, UInt16& result)
public bool TryParse(string s, NumberStyles style, IFormatProvider provider, UInt16& result)
private bool TryParse(string s, NumberStyles style, NumberFormatInfo info, UInt16& result)
public TypeCode GetTypeCode()
private bool System.IConvertible.ToBoolean(IFormatProvider provider)
private char System.IConvertible.ToChar(IFormatProvider provider)
private sbyte System.IConvertible.ToSByte(IFormatProvider provider)
private byte System.IConvertible.ToByte(IFormatProvider provider)
private short System.IConvertible.ToInt16(IFormatProvider provider)
private ushort System.IConvertible.ToUInt16(IFormatProvider provider)
private int System.IConvertible.ToInt32(IFormatProvider provider)
private UInt32 System.IConvertible.ToUInt32(IFormatProvider provider)
private long System.IConvertible.ToInt64(IFormatProvider provider)
private ulong System.IConvertible.ToUInt64(IFormatProvider provider)
private float System.IConvertible.ToSingle(IFormatProvider provider)
private double System.IConvertible.ToDouble(IFormatProvider provider)
private decimal System.IConvertible.ToDecimal(IFormatProvider provider)
private DateTime System.IConvertible.ToDateTime(IFormatProvider provider)
private object System.IConvertible.ToType(Type type, IFormatProvider provider)
}
public System.UInt32 : ValueType {
private UInt32 m_value
public UInt32 MaxValue
public UInt32 MinValue
public int CompareTo(object value)
public int CompareTo(UInt32 value)
public bool Equals(object obj)
public bool Equals(UInt32 obj)
public int GetHashCode()
public string ToString()
public string ToString(IFormatProvider provider)
public string ToString(string format)
public string ToString(string format, IFormatProvider provider)
public UInt32 Parse(string s)
public UInt32 Parse(string s, NumberStyles style)
public UInt32 Parse(string s, IFormatProvider provider)
public UInt32 Parse(string s, NumberStyles style, IFormatProvider provider)
public bool TryParse(string s, UInt32& result)
public bool TryParse(string s, NumberStyles style, IFormatProvider provider, UInt32& result)
public TypeCode GetTypeCode()
private bool System.IConvertible.ToBoolean(IFormatProvider provider)
private char System.IConvertible.ToChar(IFormatProvider provider)
private sbyte System.IConvertible.ToSByte(IFormatProvider provider)
private byte System.IConvertible.ToByte(IFormatProvider provider)
private short System.IConvertible.ToInt16(IFormatProvider provider)
private ushort System.IConvertible.ToUInt16(IFormatProvider provider)
private int System.IConvertible.ToInt32(IFormatProvider provider)
private UInt32 System.IConvertible.ToUInt32(IFormatProvider provider)
private long System.IConvertible.ToInt64(IFormatProvider provider)
private ulong System.IConvertible.ToUInt64(IFormatProvider provider)
private float System.IConvertible.ToSingle(IFormatProvider provider)
private double System.IConvertible.ToDouble(IFormatProvider provider)
private decimal System.IConvertible.ToDecimal(IFormatProvider provider)
private DateTime System.IConvertible.ToDateTime(IFormatProvider provider)
private object System.IConvertible.ToType(Type type, IFormatProvider provider)
}
public System.UInt64 : ValueType {
private ulong m_value
public ulong MaxValue
public ulong MinValue
public int CompareTo(object value)
public int CompareTo(ulong value)
public bool Equals(object obj)
public bool Equals(ulong obj)
public int GetHashCode()
public string ToString()
public string ToString(IFormatProvider provider)
public string ToString(string format)
public string ToString(string format, IFormatProvider provider)
public ulong Parse(string s)
public ulong Parse(string s, NumberStyles style)
public ulong Parse(string s, IFormatProvider provider)
public ulong Parse(string s, NumberStyles style, IFormatProvider provider)
public bool TryParse(string s, UInt64& result)
public bool TryParse(string s, NumberStyles style, IFormatProvider provider, UInt64& result)
public TypeCode GetTypeCode()
private bool System.IConvertible.ToBoolean(IFormatProvider provider)
private char System.IConvertible.ToChar(IFormatProvider provider)
private sbyte System.IConvertible.ToSByte(IFormatProvider provider)
private byte System.IConvertible.ToByte(IFormatProvider provider)
private short System.IConvertible.ToInt16(IFormatProvider provider)
private ushort System.IConvertible.ToUInt16(IFormatProvider provider)
private int System.IConvertible.ToInt32(IFormatProvider provider)
private UInt32 System.IConvertible.ToUInt32(IFormatProvider provider)
private long System.IConvertible.ToInt64(IFormatProvider provider)
private ulong System.IConvertible.ToUInt64(IFormatProvider provider)
private float System.IConvertible.ToSingle(IFormatProvider provider)
private double System.IConvertible.ToDouble(IFormatProvider provider)
private decimal System.IConvertible.ToDecimal(IFormatProvider provider)
private DateTime System.IConvertible.ToDateTime(IFormatProvider provider)
private object System.IConvertible.ToType(Type type, IFormatProvider provider)
}
public System.UIntPtr : ValueType {
public UIntPtr Zero
private Void* _pointer
public int Size
public void .ctor(ulong value)
public void .ctor(UInt32 value)
public void .ctor(Void* value)
public bool Equals(object obj)
public int GetHashCode()
public UInt32 ToUInt32()
public ulong ToUInt64()
public Void* ToPointer()
public string ToString()
private void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context)
public bool op_Equality(UIntPtr value1, UIntPtr value2)
public bool op_Inequality(UIntPtr value1, UIntPtr value2)
public ulong op_Explicit(UIntPtr value)
public UInt32 op_Explicit(UIntPtr value)
public UIntPtr op_Explicit(ulong value)
public UIntPtr op_Explicit(Void* value)
public Void* op_Explicit(UIntPtr value)
public UIntPtr op_Explicit(UInt32 value)
public int get_Size()
public UIntPtr Add(UIntPtr pointer, int offset)
public UIntPtr Subtract(UIntPtr pointer, int offset)
public UIntPtr op_Addition(UIntPtr pointer, int offset)
public UIntPtr op_Subtraction(UIntPtr pointer, int offset)
}
public System.UnauthorizedAccessException : SystemException {
public void .ctor(string message)
public void .ctor(string message, Exception inner)
protected void .ctor(SerializationInfo info, StreamingContext context)
}
public System.UnhandledExceptionEventArgs : EventArgs {
private object _Exception
private bool _IsTerminating
public object ExceptionObject
public bool IsTerminating
public void .ctor(object exception, bool isTerminating)
public object get_ExceptionObject()
public bool get_IsTerminating()
}
public System.UnhandledExceptionEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, UnhandledExceptionEventArgs e)
public IAsyncResult BeginInvoke(object sender, UnhandledExceptionEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
internal System.UnitySerializationHolder : object {
internal int EmptyUnity
internal int NullUnity
internal int MissingUnity
internal int RuntimeTypeUnity
internal int ModuleUnity
internal int AssemblyUnity
internal int GenericParameterTypeUnity
internal int PartialInstantiationTypeUnity
internal int Pointer
internal int Array
internal int SzArray
internal int ByRef
private Type[] m_instantiation
private Int32[] m_elementTypes
private int m_genericParameterPosition
private Type m_declaringType
private MethodBase m_declaringMethod
private string m_data
private string m_assemblyName
private int m_unityType
internal void GetUnitySerializationInfo(SerializationInfo info, Missing missing)
internal RuntimeType AddElementTypes(SerializationInfo info, RuntimeType type)
internal Type MakeElementTypes(Type type)
internal void GetUnitySerializationInfo(SerializationInfo info, RuntimeType type)
internal void GetUnitySerializationInfo(SerializationInfo info, int unityType, string data, RuntimeAssembly assembly)
internal void .ctor(SerializationInfo info, StreamingContext context)
private void ThrowInsufficientInformation(string field)
public void GetObjectData(SerializationInfo info, StreamingContext context)
public object GetRealObject(StreamingContext context)
}
internal System.UnSafeCharBuffer : ValueType {
private Char* m_buffer
private int m_totalSize
private int m_length
public int Length
public void .ctor(Char* buffer, int bufferSize)
public void AppendString(string stringToAppend)
public int get_Length()
}
public System.ValueTuple : ValueType {
private int System.Runtime.CompilerServices.ITuple.Length
private object System.Runtime.CompilerServices.ITuple.Item
public bool Equals(object obj)
public bool Equals(ValueTuple other)
private bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer)
private int System.IComparable.CompareTo(object other)
public int CompareTo(ValueTuple other)
private int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer)
public int GetHashCode()
private int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer)
private int System.IValueTupleInternal.GetHashCode(IEqualityComparer comparer)
public string ToString()
private string System.IValueTupleInternal.ToStringEnd()
private int System.Runtime.CompilerServices.ITuple.get_Length()
private object System.Runtime.CompilerServices.ITuple.get_Item(int index)
public ValueTuple Create()
public ValueTuple`1<T1> Create(T1 item1)
public ValueTuple`2<T1, T2> Create(T1 item1, T2 item2)
public ValueTuple`3<T1, T2, T3> Create(T1 item1, T2 item2, T3 item3)
public ValueTuple`4<T1, T2, T3, T4> Create(T1 item1, T2 item2, T3 item3, T4 item4)
public ValueTuple`5<T1, T2, T3, T4, T5> Create(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5)
public ValueTuple`6<T1, T2, T3, T4, T5, T6> Create(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6)
public ValueTuple`7<T1, T2, T3, T4, T5, T6, T7> Create(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7)
public ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`1<T8>> Create(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7, T8 item8)
internal int CombineHashCodes(int h1, int h2)
internal int CombineHashCodes(int h1, int h2, int h3)
internal int CombineHashCodes(int h1, int h2, int h3, int h4)
internal int CombineHashCodes(int h1, int h2, int h3, int h4, int h5)
internal int CombineHashCodes(int h1, int h2, int h3, int h4, int h5, int h6)
internal int CombineHashCodes(int h1, int h2, int h3, int h4, int h5, int h6, int h7)
internal int CombineHashCodes(int h1, int h2, int h3, int h4, int h5, int h6, int h7, int h8)
}
public System.ValueTuple`1 : ValueType {
public T1 Item1
private int System.Runtime.CompilerServices.ITuple.Length
private object System.Runtime.CompilerServices.ITuple.Item
public void .ctor(T1 item1)
public bool Equals(object obj)
public bool Equals(ValueTuple`1<T1> other)
private bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer)
private int System.IComparable.CompareTo(object other)
public int CompareTo(ValueTuple`1<T1> other)
private int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer)
public int GetHashCode()
private int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer)
private int System.IValueTupleInternal.GetHashCode(IEqualityComparer comparer)
public string ToString()
private string System.IValueTupleInternal.ToStringEnd()
private int System.Runtime.CompilerServices.ITuple.get_Length()
private object System.Runtime.CompilerServices.ITuple.get_Item(int index)
}
public System.ValueTuple`2 : ValueType {
public T1 Item1
public T2 Item2
private int System.Runtime.CompilerServices.ITuple.Length
private object System.Runtime.CompilerServices.ITuple.Item
public void .ctor(T1 item1, T2 item2)
public bool Equals(object obj)
public bool Equals(ValueTuple`2<T1, T2> other)
private bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer)
private int System.IComparable.CompareTo(object other)
public int CompareTo(ValueTuple`2<T1, T2> other)
private int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer)
public int GetHashCode()
private int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer)
private int GetHashCodeCore(IEqualityComparer comparer)
private int System.IValueTupleInternal.GetHashCode(IEqualityComparer comparer)
public string ToString()
private string System.IValueTupleInternal.ToStringEnd()
private int System.Runtime.CompilerServices.ITuple.get_Length()
private object System.Runtime.CompilerServices.ITuple.get_Item(int index)
}
public System.ValueTuple`3 : ValueType {
public T1 Item1
public T2 Item2
public T3 Item3
private int System.Runtime.CompilerServices.ITuple.Length
private object System.Runtime.CompilerServices.ITuple.Item
public void .ctor(T1 item1, T2 item2, T3 item3)
public bool Equals(object obj)
public bool Equals(ValueTuple`3<T1, T2, T3> other)
private bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer)
private int System.IComparable.CompareTo(object other)
public int CompareTo(ValueTuple`3<T1, T2, T3> other)
private int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer)
public int GetHashCode()
private int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer)
private int GetHashCodeCore(IEqualityComparer comparer)
private int System.IValueTupleInternal.GetHashCode(IEqualityComparer comparer)
public string ToString()
private string System.IValueTupleInternal.ToStringEnd()
private int System.Runtime.CompilerServices.ITuple.get_Length()
private object System.Runtime.CompilerServices.ITuple.get_Item(int index)
}
public System.ValueTuple`4 : ValueType {
public T1 Item1
public T2 Item2
public T3 Item3
public T4 Item4
private int System.Runtime.CompilerServices.ITuple.Length
private object System.Runtime.CompilerServices.ITuple.Item
public void .ctor(T1 item1, T2 item2, T3 item3, T4 item4)
public bool Equals(object obj)
public bool Equals(ValueTuple`4<T1, T2, T3, T4> other)
private bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer)
private int System.IComparable.CompareTo(object other)
public int CompareTo(ValueTuple`4<T1, T2, T3, T4> other)
private int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer)
public int GetHashCode()
private int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer)
private int GetHashCodeCore(IEqualityComparer comparer)
private int System.IValueTupleInternal.GetHashCode(IEqualityComparer comparer)
public string ToString()
private string System.IValueTupleInternal.ToStringEnd()
private int System.Runtime.CompilerServices.ITuple.get_Length()
private object System.Runtime.CompilerServices.ITuple.get_Item(int index)
}
public System.ValueTuple`5 : ValueType {
public T1 Item1
public T2 Item2
public T3 Item3
public T4 Item4
public T5 Item5
private int System.Runtime.CompilerServices.ITuple.Length
private object System.Runtime.CompilerServices.ITuple.Item
public void .ctor(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5)
public bool Equals(object obj)
public bool Equals(ValueTuple`5<T1, T2, T3, T4, T5> other)
private bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer)
private int System.IComparable.CompareTo(object other)
public int CompareTo(ValueTuple`5<T1, T2, T3, T4, T5> other)
private int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer)
public int GetHashCode()
private int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer)
private int GetHashCodeCore(IEqualityComparer comparer)
private int System.IValueTupleInternal.GetHashCode(IEqualityComparer comparer)
public string ToString()
private string System.IValueTupleInternal.ToStringEnd()
private int System.Runtime.CompilerServices.ITuple.get_Length()
private object System.Runtime.CompilerServices.ITuple.get_Item(int index)
}
public System.ValueTuple`6 : ValueType {
public T1 Item1
public T2 Item2
public T3 Item3
public T4 Item4
public T5 Item5
public T6 Item6
private int System.Runtime.CompilerServices.ITuple.Length
private object System.Runtime.CompilerServices.ITuple.Item
public void .ctor(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6)
public bool Equals(object obj)
public bool Equals(ValueTuple`6<T1, T2, T3, T4, T5, T6> other)
private bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer)
private int System.IComparable.CompareTo(object other)
public int CompareTo(ValueTuple`6<T1, T2, T3, T4, T5, T6> other)
private int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer)
public int GetHashCode()
private int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer)
private int GetHashCodeCore(IEqualityComparer comparer)
private int System.IValueTupleInternal.GetHashCode(IEqualityComparer comparer)
public string ToString()
private string System.IValueTupleInternal.ToStringEnd()
private int System.Runtime.CompilerServices.ITuple.get_Length()
private object System.Runtime.CompilerServices.ITuple.get_Item(int index)
}
public System.ValueTuple`7 : ValueType {
public T1 Item1
public T2 Item2
public T3 Item3
public T4 Item4
public T5 Item5
public T6 Item6
public T7 Item7
private int System.Runtime.CompilerServices.ITuple.Length
private object System.Runtime.CompilerServices.ITuple.Item
public void .ctor(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7)
public bool Equals(object obj)
public bool Equals(ValueTuple`7<T1, T2, T3, T4, T5, T6, T7> other)
private bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer)
private int System.IComparable.CompareTo(object other)
public int CompareTo(ValueTuple`7<T1, T2, T3, T4, T5, T6, T7> other)
private int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer)
public int GetHashCode()
private int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer)
private int GetHashCodeCore(IEqualityComparer comparer)
private int System.IValueTupleInternal.GetHashCode(IEqualityComparer comparer)
public string ToString()
private string System.IValueTupleInternal.ToStringEnd()
private int System.Runtime.CompilerServices.ITuple.get_Length()
private object System.Runtime.CompilerServices.ITuple.get_Item(int index)
}
public System.ValueTuple`8 : ValueType {
public T1 Item1
public T2 Item2
public T3 Item3
public T4 Item4
public T5 Item5
public T6 Item6
public T7 Item7
public TRest Rest
private int System.Runtime.CompilerServices.ITuple.Length
private object System.Runtime.CompilerServices.ITuple.Item
public void .ctor(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7, TRest rest)
public bool Equals(object obj)
public bool Equals(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, TRest> other)
private bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer)
private int System.IComparable.CompareTo(object other)
public int CompareTo(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, TRest> other)
private int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer)
public int GetHashCode()
private int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer)
private int GetHashCodeCore(IEqualityComparer comparer)
private int System.IValueTupleInternal.GetHashCode(IEqualityComparer comparer)
public string ToString()
private string System.IValueTupleInternal.ToStringEnd()
private int System.Runtime.CompilerServices.ITuple.get_Length()
private object System.Runtime.CompilerServices.ITuple.get_Item(int index)
}
public System.ValueType : object {
private bool InternalEquals(object o1, object o2, Object[]& fields)
internal bool DefaultEquals(object o1, object o2)
public bool Equals(object obj)
internal int InternalGetHashCode(object o, Object[]& fields)
public int GetHashCode()
internal int GetHashCodeOfPtr(IntPtr ptr)
public string ToString()
}
internal System.Variant : ValueType {
public short vt
public ushort wReserved1
public ushort wReserved2
public ushort wReserved3
public long llVal
public int lVal
public byte bVal
public short iVal
public float fltVal
public double dblVal
public short boolVal
public IntPtr bstrVal
public sbyte cVal
public ushort uiVal
public UInt32 ulVal
public ulong ullVal
public int intVal
public UInt32 uintVal
public IntPtr pdispVal
public BRECORD bRecord
public void SetValue(object obj)
public object GetValueAt(int vt, IntPtr addr)
public object GetValue()
public void Clear()
}
public System.Version : object {
private int _Major
private int _Minor
private int _Build
private int _Revision
private Char[] SeparatorsArray
private int ZERO_CHAR_VALUE
public int Major
public int Minor
public int Build
public int Revision
public short MajorRevision
public short MinorRevision
public void .ctor(int major, int minor, int build, int revision)
public void .ctor(int major, int minor, int build)
public void .ctor(int major, int minor)
public void .ctor(string version)
public int get_Major()
public int get_Minor()
public int get_Build()
public int get_Revision()
public short get_MajorRevision()
public short get_MinorRevision()
public object Clone()
public int CompareTo(object version)
public int CompareTo(Version value)
public bool Equals(object obj)
public bool Equals(Version obj)
public int GetHashCode()
public string ToString()
public string ToString(int fieldCount)
private void AppendPositiveNumber(int num, StringBuilder sb)
public Version Parse(string input)
public bool TryParse(string input, Version& result)
private bool TryParseVersion(string version, VersionResult& result)
private bool TryParseComponent(string component, string componentName, VersionResult& result, Int32& parsedComponent)
public bool op_Equality(Version v1, Version v2)
public bool op_Inequality(Version v1, Version v2)
public bool op_LessThan(Version v1, Version v2)
public bool op_LessThanOrEqual(Version v1, Version v2)
public bool op_GreaterThan(Version v1, Version v2)
public bool op_GreaterThanOrEqual(Version v1, Version v2)
}
public System.WeakReference : object {
private bool isLongReference
private GCHandle gcHandle
public bool IsAlive
public object Target
public bool TrackResurrection
private void AllocateHandle(object target)
public void .ctor(object target)
public void .ctor(object target, bool trackResurrection)
protected void .ctor(SerializationInfo info, StreamingContext context)
public bool get_IsAlive()
public object get_Target()
public void set_Target(object value)
public bool get_TrackResurrection()
protected void Finalize()
public void GetObjectData(SerializationInfo info, StreamingContext context)
}
public System.WeakReference`1 : object {
private GCHandle handle
private bool trackResurrection
public void .ctor(T target)
public void .ctor(T target, bool trackResurrection)
private void .ctor(SerializationInfo info, StreamingContext context)
public void GetObjectData(SerializationInfo info, StreamingContext context)
public void SetTarget(T target)
public bool TryGetTarget(T& target)
protected void Finalize()
}
internal System.WindowsConsoleDriver : object {
private IntPtr inputHandle
private IntPtr outputHandle
private short defaultAttribute
public ConsoleColor BackgroundColor
public int BufferHeight
public int BufferWidth
public bool CapsLock
public int CursorLeft
public int CursorSize
public int CursorTop
public bool CursorVisible
public ConsoleColor ForegroundColor
public bool KeyAvailable
public bool Initialized
public int LargestWindowHeight
public int LargestWindowWidth
public bool NumberLock
public string Title
public bool TreatControlCAsInput
public int WindowHeight
public int WindowLeft
public int WindowTop
public int WindowWidth
private ConsoleColor GetForeground(short attr)
private ConsoleColor GetBackground(short attr)
private short GetAttrForeground(int attr, ConsoleColor color)
private short GetAttrBackground(int attr, ConsoleColor color)
public ConsoleColor get_BackgroundColor()
public void set_BackgroundColor(ConsoleColor value)
public int get_BufferHeight()
public void set_BufferHeight(int value)
public int get_BufferWidth()
public void set_BufferWidth(int value)
public bool get_CapsLock()
public int get_CursorLeft()
public void set_CursorLeft(int value)
public int get_CursorSize()
public void set_CursorSize(int value)
public int get_CursorTop()
public void set_CursorTop(int value)
public bool get_CursorVisible()
public void set_CursorVisible(bool value)
public ConsoleColor get_ForegroundColor()
public void set_ForegroundColor(ConsoleColor value)
public bool get_KeyAvailable()
public bool get_Initialized()
public int get_LargestWindowHeight()
public int get_LargestWindowWidth()
public bool get_NumberLock()
public string get_Title()
public void set_Title(string value)
public bool get_TreatControlCAsInput()
public void set_TreatControlCAsInput(bool value)
public int get_WindowHeight()
public void set_WindowHeight(int value)
public int get_WindowLeft()
public void set_WindowLeft(int value)
public int get_WindowTop()
public void set_WindowTop(int value)
public int get_WindowWidth()
public void set_WindowWidth(int value)
public void Beep(int frequency, int duration)
public void Clear()
public void MoveBufferArea(int sourceLeft, int sourceTop, int sourceWidth, int sourceHeight, int targetLeft, int targetTop, char sourceChar, ConsoleColor sourceForeColor, ConsoleColor sourceBackColor)
public void Init()
public string ReadLine()
public ConsoleKeyInfo ReadKey(bool intercept)
public void ResetColor()
public void SetBufferSize(int width, int height)
public void SetCursorPosition(int left, int top)
public void SetWindowPosition(int left, int top)
public void SetWindowSize(int width, int height)
private bool IsModifierKey(short virtualKeyCode)
private IntPtr GetStdHandle(Handles handle)
private void _Beep(int frequency, int duration)
private bool GetConsoleScreenBufferInfo(IntPtr handle, ConsoleScreenBufferInfo& info)
private bool FillConsoleOutputCharacter(IntPtr handle, char c, int size, Coord coord, Int32& written)
private bool FillConsoleOutputAttribute(IntPtr handle, short c, int size, Coord coord, Int32& written)
private bool SetConsoleCursorPosition(IntPtr handle, Coord coord)
private bool SetConsoleTextAttribute(IntPtr handle, short attribute)
private bool SetConsoleScreenBufferSize(IntPtr handle, Coord newSize)
private bool SetConsoleWindowInfo(IntPtr handle, bool absolute, SmallRect& rect)
private int GetConsoleTitle(StringBuilder sb, int size)
private bool SetConsoleTitle(string title)
private bool GetConsoleCursorInfo(IntPtr handle, ConsoleCursorInfo& info)
private bool SetConsoleCursorInfo(IntPtr handle, ConsoleCursorInfo& info)
private short GetKeyState(int virtKey)
private bool GetConsoleMode(IntPtr handle, Int32& mode)
private bool SetConsoleMode(IntPtr handle, int mode)
private bool PeekConsoleInput(IntPtr handle, InputRecord& record, int length, Int32& eventsRead)
private bool ReadConsoleInput(IntPtr handle, InputRecord& record, int length, Int32& nread)
private Coord GetLargestConsoleWindowSize(IntPtr handle)
private bool ReadConsoleOutput(IntPtr handle, Void* buffer, Coord bsize, Coord bpos, SmallRect& region)
private bool WriteConsoleOutput(IntPtr handle, CharInfo[] buffer, Coord bsize, Coord bpos, SmallRect& region)
}
internal Unity.ThrowStub : ObjectDisposedException {
public void ThrowNotSupportedException()
}
internal XamMac.CoreFoundation.CFHelpers : object {
internal string CoreFoundationLibrary
internal string SecurityLibrary
internal void CFRelease(IntPtr obj)
internal IntPtr CFRetain(IntPtr obj)
private IntPtr CFStringCreateWithCharacters(IntPtr allocator, string str, IntPtr count)
private IntPtr CFStringGetLength(IntPtr handle)
private IntPtr CFStringGetCharactersPtr(IntPtr handle)
private IntPtr CFStringGetCharacters(IntPtr handle, CFRange range, IntPtr buffer)
internal string FetchString(IntPtr handle)
private IntPtr CFDataGetLength(IntPtr handle)
private IntPtr CFDataGetBytePtr(IntPtr handle)
internal Byte[] FetchDataBuffer(IntPtr handle)
private IntPtr CFDataCreateWithBytesNoCopy(IntPtr allocator, IntPtr bytes, IntPtr length, IntPtr bytesDeallocator)
private IntPtr CFDataCreate(IntPtr allocator, IntPtr bytes, IntPtr length)
private IntPtr SecCertificateCreateWithData(IntPtr allocator, IntPtr cfData)
internal IntPtr CreateCertificateFromData(Byte[] data)
}
