internal Consts : object {
public string MonoVersion
public string MonoCompany
public string MonoProduct
public string MonoCopyright
public int MonoCorlibVersion
public string FxVersion
public string FxFileVersion
public string EnvironmentVersion
public string VsVersion
public string VsFileVersion
private string PublicKeyToken
public string AssemblyI18N
public string AssemblyMicrosoft_JScript
public string AssemblyMicrosoft_VisualStudio
public string AssemblyMicrosoft_VisualStudio_Web
public string AssemblyMicrosoft_VSDesigner
public string AssemblyMono_Http
public string AssemblyMono_Posix
public string AssemblyMono_Security
public string AssemblyMono_Messaging_RabbitMQ
public string AssemblyCorlib
public string AssemblySystem
public string AssemblySystem_Data
public string AssemblySystem_Design
public string AssemblySystem_DirectoryServices
public string AssemblySystem_Drawing
public string AssemblySystem_Drawing_Design
public string AssemblySystem_Messaging
public string AssemblySystem_Security
public string AssemblySystem_ServiceProcess
public string AssemblySystem_Web
public string AssemblySystem_Windows_Forms
public string AssemblySystem_2_0
public string AssemblySystemCore_3_5
public string AssemblySystem_Core
public string WindowsBase_3_0
public string AssemblyWindowsBase
public string AssemblyPresentationCore_3_5
public string AssemblyPresentationCore_4_0
public string AssemblyPresentationFramework_3_5
public string AssemblySystemServiceModel_3_0
}
internal SR : object {
public string IO_DirectoryNameWithData
public string IO_ExtractingResultsInOutside
public string ArgumentException_BufferNotFromPool
}
internal System.Buffers.ArrayPool`1 : object {
private ArrayPool`1<T> s_sharedInstance
public ArrayPool`1<T> Shared
public ArrayPool`1<T> get_Shared()
private ArrayPool`1<T> EnsureSharedCreated()
public ArrayPool`1<T> Create()
public ArrayPool`1<T> Create(int maxArrayLength, int maxArraysPerBucket)
public T[] Rent(int minimumLength)
public void Return(T[] array, bool clearArray)
}
internal System.Buffers.ArrayPoolEventSource : EventSource {
internal ArrayPoolEventSource Log
internal void BufferRented(int bufferId, int bufferSize, int poolId, int bucketId)
internal void BufferAllocated(int bufferId, int bufferSize, int poolId, int bucketId, BufferAllocatedReason reason)
internal void BufferReturned(int bufferId, int bufferSize, int poolId)
}
internal System.Buffers.DefaultArrayPool`1 : ArrayPool`1<T> {
private int DefaultMaxArrayLength
private int DefaultMaxNumberOfArraysPerBucket
private T[] s_emptyArray
private Bucket[] _buckets
private int Id
internal void .ctor(int maxArrayLength, int maxArraysPerBucket)
private int get_Id()
public T[] Rent(int minimumLength)
public void Return(T[] array, bool clearArray)
}
internal System.Buffers.Utilities : object {
internal int SelectBucketIndex(int bufferSize)
internal int GetMaxSizeForBucket(int binIndex)
}
public System.IO.Compression.ZipFile : object {
private char PathSeparator
public ZipArchive OpenRead(string archiveFileName)
public ZipArchive Open(string archiveFileName, ZipArchiveMode mode)
public ZipArchive Open(string archiveFileName, ZipArchiveMode mode, Encoding entryNameEncoding)
public void CreateFromDirectory(string sourceDirectoryName, string destinationArchiveFileName)
public void CreateFromDirectory(string sourceDirectoryName, string destinationArchiveFileName, CompressionLevel compressionLevel, bool includeBaseDirectory)
public void CreateFromDirectory(string sourceDirectoryName, string destinationArchiveFileName, CompressionLevel compressionLevel, bool includeBaseDirectory, Encoding entryNameEncoding)
public void ExtractToDirectory(string sourceArchiveFileName, string destinationDirectoryName)
public void ExtractToDirectory(string sourceArchiveFileName, string destinationDirectoryName, bool overwrite)
public void ExtractToDirectory(string sourceArchiveFileName, string destinationDirectoryName, Encoding entryNameEncoding)
public void ExtractToDirectory(string sourceArchiveFileName, string destinationDirectoryName, Encoding entryNameEncoding, bool overwrite)
private void DoCreateFromDirectory(string sourceDirectoryName, string destinationArchiveFileName, Nullable`1<CompressionLevel> compressionLevel, bool includeBaseDirectory, Encoding entryNameEncoding)
private string EntryFromPath(string entry, int offset, int length, Char[]& buffer, bool appendPathSeparator)
private void EnsureCapacity(Char[]& buffer, int min)
private bool IsDirEmpty(DirectoryInfo possiblyEmptyDir)
}
public System.IO.Compression.ZipFileExtensions : object {
public ZipArchiveEntry CreateEntryFromFile(ZipArchive destination, string sourceFileName, string entryName)
public ZipArchiveEntry CreateEntryFromFile(ZipArchive destination, string sourceFileName, string entryName, CompressionLevel compressionLevel)
public void ExtractToDirectory(ZipArchive source, string destinationDirectoryName)
public void ExtractToDirectory(ZipArchive source, string destinationDirectoryName, bool overwrite)
internal ZipArchiveEntry DoCreateEntryFromFile(ZipArchive destination, string sourceFileName, string entryName, Nullable`1<CompressionLevel> compressionLevel)
public void ExtractToFile(ZipArchiveEntry source, string destinationFileName)
public void ExtractToFile(ZipArchiveEntry source, string destinationFileName, bool overwrite)
}
internal System.IO.PathInternal : object {
private bool s_isCaseSensitive
internal StringComparison StringComparison
internal bool IsCaseSensitive
internal StringComparison get_StringComparison()
internal bool get_IsCaseSensitive()
private bool GetIsCaseSensitive()
}
