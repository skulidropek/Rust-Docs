public System.Diagnostics.Activity : object {
private IEnumerable`1<KeyValuePair`2<string, string>> s_emptyBaggageTags
private IEnumerable`1<KeyValuePair`2<string, object>> s_emptyTagObjects
private IEnumerable`1<ActivityLink> s_emptyLinks
private IEnumerable`1<ActivityEvent> s_emptyEvents
private ActivitySource s_defaultSource
private byte ActivityTraceFlagsIsSet
private int RequestIdMaxLength
private string s_uniqSuffix
private long s_currentRootId
private ActivityIdFormat s_defaultIdFormat
private bool <ForceDefaultIdFormat>k__BackingField
private string _traceState
private State _state
private int _currentChildId
private string _id
private string _rootId
private string _parentId
private string _parentSpanId
private string _traceId
private string _spanId
private byte _w3CIdFlags
private byte _parentTraceFlags
private TagsLinkedList _tags
private BaggageLinkedList _baggage
private DiagLinkedList`1<ActivityLink> _links
private DiagLinkedList`1<ActivityEvent> _events
private Dictionary`2<string, object> _customProperties
private string _displayName
private ActivityStatusCode _statusCode
private string _statusDescription
private Activity _previousActiveActivity
private ActivityKind <Kind>k__BackingField
private string <OperationName>k__BackingField
private ActivitySource <Source>k__BackingField
private Activity <Parent>k__BackingField
private TimeSpan <Duration>k__BackingField
private DateTime <StartTimeUtc>k__BackingField
private bool <IsAllDataRequested>k__BackingField
private Func`1<ActivityTraceId> <TraceIdGenerator>k__BackingField
private AsyncLocal`1<Activity> s_current
public bool ForceDefaultIdFormat
public ActivityStatusCode Status
public string StatusDescription
public ActivityKind Kind
public string OperationName
public string DisplayName
public ActivitySource Source
public Activity Parent
public TimeSpan Duration
public DateTime StartTimeUtc
public string Id
public string ParentId
public string RootId
public IEnumerable`1<KeyValuePair`2<string, string>> Tags
public IEnumerable`1<KeyValuePair`2<string, object>> TagObjects
public IEnumerable`1<ActivityEvent> Events
public IEnumerable`1<ActivityLink> Links
public IEnumerable`1<KeyValuePair`2<string, string>> Baggage
public ActivityContext Context
public string TraceStateString
public ActivitySpanId SpanId
public ActivityTraceId TraceId
public bool Recorded
public bool IsAllDataRequested
public ActivityTraceFlags ActivityTraceFlags
public ActivitySpanId ParentSpanId
public Func`1<ActivityTraceId> TraceIdGenerator
public ActivityIdFormat DefaultIdFormat
private bool W3CIdFlagsSet
private bool IsFinished
public ActivityIdFormat IdFormat
public Activity Current
public bool get_ForceDefaultIdFormat()
public void set_ForceDefaultIdFormat(bool value)
public ActivityStatusCode get_Status()
public string get_StatusDescription()
public Activity SetStatus(ActivityStatusCode code, string description)
public ActivityKind get_Kind()
private void set_Kind(ActivityKind value)
public string get_OperationName()
public string get_DisplayName()
public void set_DisplayName(string value)
public ActivitySource get_Source()
private void set_Source(ActivitySource value)
public Activity get_Parent()
private void set_Parent(Activity value)
public TimeSpan get_Duration()
private void set_Duration(TimeSpan value)
public DateTime get_StartTimeUtc()
private void set_StartTimeUtc(DateTime value)
public string get_Id()
public string get_ParentId()
public string get_RootId()
public IEnumerable`1<KeyValuePair`2<string, string>> get_Tags()
public IEnumerable`1<KeyValuePair`2<string, object>> get_TagObjects()
public IEnumerable`1<ActivityEvent> get_Events()
public IEnumerable`1<ActivityLink> get_Links()
public IEnumerable`1<KeyValuePair`2<string, string>> get_Baggage()
public string GetBaggageItem(string key)
public object GetTagItem(string key)
public void .ctor(string operationName)
public Activity AddTag(string key, string value)
public Activity AddTag(string key, object value)
public Activity SetTag(string key, object value)
public Activity AddEvent(ActivityEvent e)
public Activity AddBaggage(string key, string value)
public Activity SetBaggage(string key, string value)
public Activity SetParentId(string parentId)
public Activity SetParentId(ActivityTraceId traceId, ActivitySpanId spanId, ActivityTraceFlags activityTraceFlags)
public Activity SetStartTime(DateTime startTimeUtc)
public Activity SetEndTime(DateTime endTimeUtc)
public ActivityContext get_Context()
public Activity Start()
public void Stop()
public string get_TraceStateString()
public void set_TraceStateString(string value)
public ActivitySpanId get_SpanId()
public ActivityTraceId get_TraceId()
public bool get_Recorded()
public bool get_IsAllDataRequested()
public void set_IsAllDataRequested(bool value)
public ActivityTraceFlags get_ActivityTraceFlags()
public void set_ActivityTraceFlags(ActivityTraceFlags value)
public ActivitySpanId get_ParentSpanId()
public Func`1<ActivityTraceId> get_TraceIdGenerator()
public void set_TraceIdGenerator(Func`1<ActivityTraceId> value)
public ActivityIdFormat get_DefaultIdFormat()
public void set_DefaultIdFormat(ActivityIdFormat value)
public Activity SetIdFormat(ActivityIdFormat format)
private bool IsW3CId(string id)
internal bool TryConvertIdToContext(string traceParent, string traceState, ActivityContext& context)
public void Dispose()
protected void Dispose(bool disposing)
public void SetCustomProperty(string propertyName, object propertyValue)
public object GetCustomProperty(string propertyName)
internal Activity Create(ActivitySource source, string name, ActivityKind kind, string parentId, ActivityContext parentContext, IEnumerable`1<KeyValuePair`2<string, object>> tags, IEnumerable`1<ActivityLink> links, DateTimeOffset startTime, ActivityTagsCollection samplerTags, ActivitySamplingResult request, bool startIt, ActivityIdFormat idFormat)
private void GenerateW3CId()
private void NotifyError(Exception exception)
private string GenerateHierarchicalId()
private string GetRootId(string id)
private string AppendSuffix(string parentId, string suffix, char delimiter)
private long GetRandomNumber()
private bool ValidateSetCurrent(Activity activity)
private bool TrySetTraceIdFromParent()
private void TrySetTraceFlagsFromParent()
private bool get_W3CIdFlagsSet()
private bool get_IsFinished()
private void set_IsFinished(bool value)
public ActivityIdFormat get_IdFormat()
private void set_IdFormat(ActivityIdFormat value)
public Activity get_Current()
public void set_Current(Activity value)
private void SetCurrent(Activity activity)
internal DateTime GetUtcNow()
private string GenerateRootId()
internal IEnumerable`1<KeyValuePair`2<string, string>> <get_Baggage>g__Iterate|80_0(Activity activity)
}
public System.Diagnostics.ActivityContext : ValueType {
private ActivityTraceId <TraceId>k__BackingField
private ActivitySpanId <SpanId>k__BackingField
private ActivityTraceFlags <TraceFlags>k__BackingField
private string <TraceState>k__BackingField
private bool <IsRemote>k__BackingField
public ActivityTraceId TraceId
public ActivitySpanId SpanId
public ActivityTraceFlags TraceFlags
public string TraceState
public bool IsRemote
public void .ctor(ActivityTraceId traceId, ActivitySpanId spanId, ActivityTraceFlags traceFlags, string traceState, bool isRemote)
public ActivityTraceId get_TraceId()
public ActivitySpanId get_SpanId()
public ActivityTraceFlags get_TraceFlags()
public string get_TraceState()
public bool get_IsRemote()
public bool TryParse(string traceParent, string traceState, ActivityContext& context)
public ActivityContext Parse(string traceParent, string traceState)
public bool Equals(ActivityContext value)
public bool Equals(object obj)
public bool op_Equality(ActivityContext left, ActivityContext right)
public bool op_Inequality(ActivityContext left, ActivityContext right)
public int GetHashCode()
}
public System.Diagnostics.ActivityCreationOptions`1 : ValueType {
private ActivityTagsCollection _samplerTags
private ActivityContext _context
private ActivitySource <Source>k__BackingField
private string <Name>k__BackingField
private ActivityKind <Kind>k__BackingField
private T <Parent>k__BackingField
private IEnumerable`1<KeyValuePair`2<string, object>> <Tags>k__BackingField
private IEnumerable`1<ActivityLink> <Links>k__BackingField
private ActivityIdFormat <IdFormat>k__BackingField
public ActivitySource Source
public string Name
public ActivityKind Kind
public T Parent
public IEnumerable`1<KeyValuePair`2<string, object>> Tags
public IEnumerable`1<ActivityLink> Links
public ActivityTagsCollection SamplingTags
public ActivityTraceId TraceId
internal ActivityIdFormat IdFormat
internal void .ctor(ActivitySource source, string name, T parent, ActivityKind kind, IEnumerable`1<KeyValuePair`2<string, object>> tags, IEnumerable`1<ActivityLink> links, ActivityIdFormat idFormat)
public ActivitySource get_Source()
public string get_Name()
public ActivityKind get_Kind()
public T get_Parent()
public IEnumerable`1<KeyValuePair`2<string, object>> get_Tags()
public IEnumerable`1<ActivityLink> get_Links()
public ActivityTagsCollection get_SamplingTags()
public ActivityTraceId get_TraceId()
internal ActivityIdFormat get_IdFormat()
internal ActivityTagsCollection GetSamplingTags()
internal ActivityContext GetContext()
}
public System.Diagnostics.ActivityEvent : ValueType {
private ActivityTagsCollection s_emptyTags
private string <Name>k__BackingField
private DateTimeOffset <Timestamp>k__BackingField
private IEnumerable`1<KeyValuePair`2<string, object>> <Tags>k__BackingField
public string Name
public DateTimeOffset Timestamp
public IEnumerable`1<KeyValuePair`2<string, object>> Tags
public void .ctor(string name)
public void .ctor(string name, DateTimeOffset timestamp, ActivityTagsCollection tags)
public string get_Name()
public DateTimeOffset get_Timestamp()
public IEnumerable`1<KeyValuePair`2<string, object>> get_Tags()
}
public System.Diagnostics.ActivityIdFormat : Enum {
public int value__
public ActivityIdFormat Unknown
public ActivityIdFormat Hierarchical
public ActivityIdFormat W3C
}
public System.Diagnostics.ActivityKind : Enum {
public int value__
public ActivityKind Internal
public ActivityKind Server
public ActivityKind Client
public ActivityKind Producer
public ActivityKind Consumer
}
public System.Diagnostics.ActivityLink : ValueType {
private ActivityContext <Context>k__BackingField
private IEnumerable`1<KeyValuePair`2<string, object>> <Tags>k__BackingField
public ActivityContext Context
public IEnumerable`1<KeyValuePair`2<string, object>> Tags
public void .ctor(ActivityContext context, ActivityTagsCollection tags)
public ActivityContext get_Context()
public IEnumerable`1<KeyValuePair`2<string, object>> get_Tags()
public bool Equals(object obj)
public bool Equals(ActivityLink value)
public bool op_Equality(ActivityLink left, ActivityLink right)
public bool op_Inequality(ActivityLink left, ActivityLink right)
public int GetHashCode()
}
public System.Diagnostics.ActivityListener : object {
private Action`1<Activity> <ActivityStarted>k__BackingField
private Action`1<Activity> <ActivityStopped>k__BackingField
private Func`2<ActivitySource, bool> <ShouldListenTo>k__BackingField
private SampleActivity`1<string> <SampleUsingParentId>k__BackingField
private SampleActivity`1<ActivityContext> <Sample>k__BackingField
public Action`1<Activity> ActivityStarted
public Action`1<Activity> ActivityStopped
public Func`2<ActivitySource, bool> ShouldListenTo
public SampleActivity`1<string> SampleUsingParentId
public SampleActivity`1<ActivityContext> Sample
public Action`1<Activity> get_ActivityStarted()
public void set_ActivityStarted(Action`1<Activity> value)
public Action`1<Activity> get_ActivityStopped()
public void set_ActivityStopped(Action`1<Activity> value)
public Func`2<ActivitySource, bool> get_ShouldListenTo()
public void set_ShouldListenTo(Func`2<ActivitySource, bool> value)
public SampleActivity`1<string> get_SampleUsingParentId()
public void set_SampleUsingParentId(SampleActivity`1<string> value)
public SampleActivity`1<ActivityContext> get_Sample()
public void set_Sample(SampleActivity`1<ActivityContext> value)
public void Dispose()
}
public System.Diagnostics.ActivitySamplingResult : Enum {
public int value__
public ActivitySamplingResult None
public ActivitySamplingResult PropagationData
public ActivitySamplingResult AllData
public ActivitySamplingResult AllDataAndRecorded
}
public System.Diagnostics.ActivitySource : object {
private SynchronizedList`1<ActivitySource> s_activeSources
private SynchronizedList`1<ActivityListener> s_allListeners
private SynchronizedList`1<ActivityListener> _listeners
private string <Name>k__BackingField
private string <Version>k__BackingField
public string Name
public string Version
public void .ctor(string name, string version)
public string get_Name()
public string get_Version()
public bool HasListeners()
public Activity CreateActivity(string name, ActivityKind kind)
public Activity CreateActivity(string name, ActivityKind kind, ActivityContext parentContext, IEnumerable`1<KeyValuePair`2<string, object>> tags, IEnumerable`1<ActivityLink> links, ActivityIdFormat idFormat)
public Activity CreateActivity(string name, ActivityKind kind, string parentId, IEnumerable`1<KeyValuePair`2<string, object>> tags, IEnumerable`1<ActivityLink> links, ActivityIdFormat idFormat)
public Activity StartActivity(string name, ActivityKind kind)
public Activity StartActivity(string name, ActivityKind kind, ActivityContext parentContext, IEnumerable`1<KeyValuePair`2<string, object>> tags, IEnumerable`1<ActivityLink> links, DateTimeOffset startTime)
public Activity StartActivity(string name, ActivityKind kind, string parentId, IEnumerable`1<KeyValuePair`2<string, object>> tags, IEnumerable`1<ActivityLink> links, DateTimeOffset startTime)
public Activity StartActivity(ActivityKind kind, ActivityContext parentContext, IEnumerable`1<KeyValuePair`2<string, object>> tags, IEnumerable`1<ActivityLink> links, DateTimeOffset startTime, string name)
private Activity CreateActivity(string name, ActivityKind kind, ActivityContext context, string parentId, IEnumerable`1<KeyValuePair`2<string, object>> tags, IEnumerable`1<ActivityLink> links, DateTimeOffset startTime, bool startIt, ActivityIdFormat idFormat)
public void Dispose()
public void AddActivityListener(ActivityListener listener)
internal void AddListener(ActivityListener listener)
internal void DetachListener(ActivityListener listener)
internal void NotifyActivityStart(Activity activity)
internal void NotifyActivityStop(Activity activity)
}
public System.Diagnostics.ActivitySpanId : ValueType {
private string _hexString
internal void .ctor(string hexString)
public ActivitySpanId CreateRandom()
public ActivitySpanId CreateFromBytes(ReadOnlySpan`1<byte> idData)
public ActivitySpanId CreateFromUtf8String(ReadOnlySpan`1<byte> idData)
public ActivitySpanId CreateFromString(ReadOnlySpan`1<char> idData)
public string ToHexString()
public string ToString()
public bool op_Equality(ActivitySpanId spanId1, ActivitySpanId spandId2)
public bool op_Inequality(ActivitySpanId spanId1, ActivitySpanId spandId2)
public bool Equals(ActivitySpanId spanId)
public bool Equals(object obj)
public int GetHashCode()
private void .ctor(ReadOnlySpan`1<byte> idData)
public void CopyTo(Span`1<byte> destination)
}
public System.Diagnostics.ActivityStatusCode : Enum {
public int value__
public ActivityStatusCode Unset
public ActivityStatusCode Ok
public ActivityStatusCode Error
}
public System.Diagnostics.ActivityTagsCollection : object {
private List`1<KeyValuePair`2<string, object>> _list
public object Item
public ICollection`1<string> Keys
public ICollection`1<object> Values
public bool IsReadOnly
public int Count
public void .ctor(IEnumerable`1<KeyValuePair`2<string, object>> list)
public object get_Item(string key)
public void set_Item(string key, object value)
public ICollection`1<string> get_Keys()
public ICollection`1<object> get_Values()
public bool get_IsReadOnly()
public int get_Count()
public void Add(string key, object value)
public void Add(KeyValuePair`2<string, object> item)
public void Clear()
public bool Contains(KeyValuePair`2<string, object> item)
public bool ContainsKey(string key)
public void CopyTo(KeyValuePair`2[] array, int arrayIndex)
private IEnumerator`1<KeyValuePair`2<string, object>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.GetEnumerator()
public Enumerator GetEnumerator()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
public bool Remove(string key)
public bool Remove(KeyValuePair`2<string, object> item)
public bool TryGetValue(string key, Object& value)
private int FindIndex(string key)
}
public System.Diagnostics.ActivityTraceFlags : Enum {
public int value__
public ActivityTraceFlags None
public ActivityTraceFlags Recorded
}
public System.Diagnostics.ActivityTraceId : ValueType {
private string _hexString
internal void .ctor(string hexString)
public ActivityTraceId CreateRandom()
public ActivityTraceId CreateFromBytes(ReadOnlySpan`1<byte> idData)
public ActivityTraceId CreateFromUtf8String(ReadOnlySpan`1<byte> idData)
public ActivityTraceId CreateFromString(ReadOnlySpan`1<char> idData)
public string ToHexString()
public string ToString()
public bool op_Equality(ActivityTraceId traceId1, ActivityTraceId traceId2)
public bool op_Inequality(ActivityTraceId traceId1, ActivityTraceId traceId2)
public bool Equals(ActivityTraceId traceId)
public bool Equals(object obj)
public int GetHashCode()
private void .ctor(ReadOnlySpan`1<byte> idData)
public void CopyTo(Span`1<byte> destination)
internal void SetToRandomBytes(Span`1<byte> outBytes)
internal void SetSpanFromHexChars(ReadOnlySpan`1<char> charData, Span`1<byte> outBytes)
internal byte HexByteFromChars(char char1, char char2)
internal bool IsLowerCaseHexAndNotAllZeros(ReadOnlySpan`1<char> idData)
}
internal System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute : Attribute {
private bool <ParameterValue>k__BackingField
public bool ParameterValue
public void .ctor(bool parameterValue)
public bool get_ParameterValue()
}
internal System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes : Enum {
public int value__
public DynamicallyAccessedMemberTypes None
public DynamicallyAccessedMemberTypes PublicParameterlessConstructor
public DynamicallyAccessedMemberTypes PublicConstructors
public DynamicallyAccessedMemberTypes NonPublicConstructors
public DynamicallyAccessedMemberTypes PublicMethods
public DynamicallyAccessedMemberTypes NonPublicMethods
public DynamicallyAccessedMemberTypes PublicFields
public DynamicallyAccessedMemberTypes NonPublicFields
public DynamicallyAccessedMemberTypes PublicNestedTypes
public DynamicallyAccessedMemberTypes NonPublicNestedTypes
public DynamicallyAccessedMemberTypes PublicProperties
public DynamicallyAccessedMemberTypes NonPublicProperties
public DynamicallyAccessedMemberTypes PublicEvents
public DynamicallyAccessedMemberTypes NonPublicEvents
public DynamicallyAccessedMemberTypes Interfaces
public DynamicallyAccessedMemberTypes All
}
internal System.Diagnostics.CodeAnalysis.DynamicDependencyAttribute : Attribute {
private string <MemberSignature>k__BackingField
private DynamicallyAccessedMemberTypes <MemberTypes>k__BackingField
private Type <Type>k__BackingField
private string <TypeName>k__BackingField
private string <AssemblyName>k__BackingField
private string <Condition>k__BackingField
public string MemberSignature
public DynamicallyAccessedMemberTypes MemberTypes
public Type Type
public string TypeName
public string AssemblyName
public string Condition
public void .ctor(string memberSignature)
public void .ctor(string memberSignature, Type type)
public void .ctor(string memberSignature, string typeName, string assemblyName)
public void .ctor(DynamicallyAccessedMemberTypes memberTypes, Type type)
public void .ctor(DynamicallyAccessedMemberTypes memberTypes, string typeName, string assemblyName)
public string get_MemberSignature()
public DynamicallyAccessedMemberTypes get_MemberTypes()
public Type get_Type()
public string get_TypeName()
public string get_AssemblyName()
public string get_Condition()
public void set_Condition(string value)
}
internal System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute : Attribute {
private bool <ReturnValue>k__BackingField
public bool ReturnValue
public void .ctor(bool returnValue)
public bool get_ReturnValue()
}
internal System.Diagnostics.CodeAnalysis.MemberNotNullAttribute : Attribute {
private String[] <Members>k__BackingField
public String[] Members
public void .ctor(string member)
public void .ctor(String[] members)
public String[] get_Members()
}
internal System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute : Attribute {
private bool <ReturnValue>k__BackingField
private String[] <Members>k__BackingField
public bool ReturnValue
public String[] Members
public void .ctor(bool returnValue, string member)
public void .ctor(bool returnValue, String[] members)
public bool get_ReturnValue()
public String[] get_Members()
}
internal System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute : Attribute {
private string <ParameterName>k__BackingField
public string ParameterName
public void .ctor(string parameterName)
public string get_ParameterName()
}
internal System.Diagnostics.CodeAnalysis.NotNullWhenAttribute : Attribute {
private bool <ReturnValue>k__BackingField
public bool ReturnValue
public void .ctor(bool returnValue)
public bool get_ReturnValue()
}
internal System.Diagnostics.CodeAnalysis.RequiresUnreferencedCodeAttribute : Attribute {
private string <Message>k__BackingField
private string <Url>k__BackingField
public string Message
public string Url
public void .ctor(string message)
public string get_Message()
public string get_Url()
public void set_Url(string value)
}
internal System.Diagnostics.CodeAnalysis.UnconditionalSuppressMessageAttribute : Attribute {
private string <Category>k__BackingField
private string <CheckId>k__BackingField
private string <Scope>k__BackingField
private string <Target>k__BackingField
private string <MessageId>k__BackingField
private string <Justification>k__BackingField
public string Category
public string CheckId
public string Scope
public string Target
public string MessageId
public string Justification
public void .ctor(string category, string checkId)
public string get_Category()
public string get_CheckId()
public string get_Scope()
public void set_Scope(string value)
public string get_Target()
public void set_Target(string value)
public string get_MessageId()
public void set_MessageId(string value)
public string get_Justification()
public void set_Justification(string value)
}
internal System.Diagnostics.DiagLinkedList`1 : object {
private DiagNode`1<T> _first
private DiagNode`1<T> _last
public DiagNode`1<T> First
public void .ctor(T firstValue)
public void .ctor(IEnumerator`1<T> e)
public DiagNode`1<T> get_First()
public void Clear()
private void UnsafeAdd(DiagNode`1<T> newNode)
public void Add(T value)
public bool AddIfNotExist(T value, Func`3<T, T, bool> compare)
public T Remove(T value, Func`3<T, T, bool> compare)
public void AddFront(T value)
public Enumerator`1<T> GetEnumerator()
private IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
}
internal System.Diagnostics.DiagNode`1 : object {
public T Value
public DiagNode`1<T> Next
public void .ctor(T value)
}
public System.Diagnostics.DiagnosticListener : DiagnosticSource {
private string <Name>k__BackingField
private DiagnosticSubscription modreq(System.Runtime.CompilerServices.IsVolatile) _subscriptions
private DiagnosticListener _next
private bool _disposed
private DiagnosticListener s_allListeners
private AllListenerObservable modreq(System.Runtime.CompilerServices.IsVolatile) s_allListenerObservable
private object s_allListenersLock
public IObservable`1<DiagnosticListener> AllListeners
public string Name
public IObservable`1<DiagnosticListener> get_AllListeners()
public IDisposable Subscribe(IObserver`1<KeyValuePair`2<string, object>> observer, Predicate`1<string> isEnabled)
public IDisposable Subscribe(IObserver`1<KeyValuePair`2<string, object>> observer, Func`4<string, object, object, bool> isEnabled)
public IDisposable Subscribe(IObserver`1<KeyValuePair`2<string, object>> observer)
public void .ctor(string name)
public void Dispose()
public string get_Name()
private void set_Name(string value)
public string ToString()
public bool IsEnabled()
public bool IsEnabled(string name)
public bool IsEnabled(string name, object arg1, object arg2)
public void Write(string name, object value)
private IDisposable SubscribeInternal(IObserver`1<KeyValuePair`2<string, object>> observer, Predicate`1<string> isEnabled1Arg, Func`4<string, object, object, bool> isEnabled3Arg, Action`2<Activity, object> onActivityImport, Action`2<Activity, object> onActivityExport)
public void OnActivityImport(Activity activity, object payload)
public void OnActivityExport(Activity activity, object payload)
public IDisposable Subscribe(IObserver`1<KeyValuePair`2<string, object>> observer, Func`4<string, object, object, bool> isEnabled, Action`2<Activity, object> onActivityImport, Action`2<Activity, object> onActivityExport)
private bool <Subscribe>b__3_0(string name)
private bool <Subscribe>b__27_0(string name)
}
public System.Diagnostics.DiagnosticSource : object {
internal string WriteRequiresUnreferencedCode
public void Write(string name, object value)
public bool IsEnabled(string name)
public bool IsEnabled(string name, object arg1, object arg2)
public Activity StartActivity(Activity activity, object args)
public void StopActivity(Activity activity, object args)
public void OnActivityImport(Activity activity, object payload)
public void OnActivityExport(Activity activity, object payload)
}
internal System.Diagnostics.DiagnosticSourceEventSource : EventSource {
public DiagnosticSourceEventSource Log
private string AspNetCoreHostingKeywordValue
private string EntityFrameworkCoreCommandsKeywordValue
private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _false
private FilterAndTransform _specs
private FilterAndTransform _activitySourceSpecs
private ActivityListener _activityListener
public void Message(string Message)
private void Event(string SourceName, string EventName, IEnumerable`1<KeyValuePair`2<string, string>> Arguments)
private void EventJson(string SourceName, string EventName, string ArgmentsJson)
private void Activity1Start(string SourceName, string EventName, IEnumerable`1<KeyValuePair`2<string, string>> Arguments)
private void Activity1Stop(string SourceName, string EventName, IEnumerable`1<KeyValuePair`2<string, string>> Arguments)
private void Activity2Start(string SourceName, string EventName, IEnumerable`1<KeyValuePair`2<string, string>> Arguments)
private void Activity2Stop(string SourceName, string EventName, IEnumerable`1<KeyValuePair`2<string, string>> Arguments)
private void RecursiveActivity1Start(string SourceName, string EventName, IEnumerable`1<KeyValuePair`2<string, string>> Arguments)
private void RecursiveActivity1Stop(string SourceName, string EventName, IEnumerable`1<KeyValuePair`2<string, string>> Arguments)
private void NewDiagnosticListener(string SourceName)
private void ActivityStart(string SourceName, string ActivityName, IEnumerable`1<KeyValuePair`2<string, string>> Arguments)
private void ActivityStop(string SourceName, string ActivityName, IEnumerable`1<KeyValuePair`2<string, string>> Arguments)
protected void OnEventCommand(EventCommandEventArgs command)
private string NewLineSeparate(string str1, string str2)
private void BreakPointWithDebuggerFuncEval()
}
public System.Diagnostics.DistributedContextPropagator : object {
private DistributedContextPropagator s_current
internal string TraceParent
internal string RequestId
internal string TraceState
internal string Baggage
internal string CorrelationContext
internal char Space
internal char Tab
internal char Comma
internal char Semicolon
internal string CommaWithSpace
internal Char[] s_trimmingSpaceCharacters
public IReadOnlyCollection`1<string> Fields
public DistributedContextPropagator Current
public IReadOnlyCollection`1<string> get_Fields()
public void Inject(Activity activity, object carrier, PropagatorSetterCallback setter)
public void ExtractTraceIdAndState(object carrier, PropagatorGetterCallback getter, String& traceId, String& traceState)
public IEnumerable`1<KeyValuePair`2<string, string>> ExtractBaggage(object carrier, PropagatorGetterCallback getter)
public DistributedContextPropagator get_Current()
public void set_Current(DistributedContextPropagator value)
public DistributedContextPropagator CreateDefaultPropagator()
public DistributedContextPropagator CreatePassThroughPropagator()
public DistributedContextPropagator CreateNoOutputPropagator()
internal void InjectBaggage(object carrier, IEnumerable`1<KeyValuePair`2<string, string>> baggage, PropagatorSetterCallback setter)
}
internal System.Diagnostics.Enumerator`1 : ValueType {
private DiagNode`1<T> _nextNode
private T _currentItem
public T Current
private object System.Collections.IEnumerator.Current
public void .ctor(DiagNode`1<T> head)
public T get_Current()
private object System.Collections.IEnumerator.get_Current()
public bool MoveNext()
public void Reset()
public void Dispose()
}
internal System.Diagnostics.LegacyPropagator : DistributedContextPropagator {
private DistributedContextPropagator <Instance>k__BackingField
private IReadOnlyCollection`1<string> <Fields>k__BackingField
internal DistributedContextPropagator Instance
public IReadOnlyCollection`1<string> Fields
internal DistributedContextPropagator get_Instance()
public IReadOnlyCollection`1<string> get_Fields()
public void Inject(Activity activity, object carrier, PropagatorSetterCallback setter)
public void ExtractTraceIdAndState(object carrier, PropagatorGetterCallback getter, String& traceId, String& traceState)
public IEnumerable`1<KeyValuePair`2<string, string>> ExtractBaggage(object carrier, PropagatorGetterCallback getter)
internal bool TryExtractBaggage(string baggageString, IEnumerable`1& baggage)
}
internal System.Diagnostics.Metrics.AggregationManager : object {
public double MinCollectionTimeSecs
private QuantileAggregation s_defaultHistogramConfig
private List`1<Predicate`1<Instrument>> _instrumentConfigFuncs
private TimeSpan _collectionPeriod
private ConcurrentDictionary`2<Instrument, InstrumentState> _instrumentStates
private CancellationTokenSource _cts
private Thread _collectThread
private MeterListener _listener
private int _currentTimeSeries
private int _currentHistograms
private int _maxTimeSeries
private int _maxHistograms
private Action`2<Instrument, LabeledAggregationStatistics> _collectMeasurement
private Action`2<DateTime, DateTime> _beginCollection
private Action`2<DateTime, DateTime> _endCollection
private Action`1<Instrument> _beginInstrumentMeasurements
private Action`1<Instrument> _endInstrumentMeasurements
private Action`1<Instrument> _instrumentPublished
private Action _initialInstrumentEnumerationComplete
private Action`1<Exception> _collectionError
private Action _timeSeriesLimitReached
private Action _histogramLimitReached
private Action`1<Exception> _observableInstrumentCallbackError
public void .ctor(int maxTimeSeries, int maxHistograms, Action`2<Instrument, LabeledAggregationStatistics> collectMeasurement, Action`2<DateTime, DateTime> beginCollection, Action`2<DateTime, DateTime> endCollection, Action`1<Instrument> beginInstrumentMeasurements, Action`1<Instrument> endInstrumentMeasurements, Action`1<Instrument> instrumentPublished, Action initialInstrumentEnumerationComplete, Action`1<Exception> collectionError, Action timeSeriesLimitReached, Action histogramLimitReached, Action`1<Exception> observableInstrumentCallbackError)
public void Include(string meterName)
public void Include(string meterName, string instrumentName)
private void Include(Predicate`1<Instrument> instrumentFilter)
public AggregationManager SetCollectionPeriod(TimeSpan collectionPeriod)
public void Start()
private void CollectWorker(CancellationToken cancelToken)
public void Dispose()
private void RemoveInstrumentState(Instrument instrument, InstrumentState state)
private InstrumentState GetInstrumentState(Instrument instrument)
internal InstrumentState BuildInstrumentState(Instrument instrument)
private Func`1<Aggregator> GetAggregatorFactory(Instrument instrument)
private bool CheckTimeSeriesAllowed()
private bool CheckHistogramAllowed()
internal void Collect()
private void <.ctor>b__23_7(Instrument instrument, MeterListener listener)
private void <.ctor>b__23_8(Instrument instrument, object cookie)
private void <Start>b__28_0()
private Aggregator <GetAggregatorFactory>b__34_0()
private Aggregator <GetAggregatorFactory>b__34_1()
private Aggregator <GetAggregatorFactory>b__34_2()
private Aggregator <GetAggregatorFactory>b__34_3()
}
internal System.Diagnostics.Metrics.Aggregator : object {
public void Update(double measurement)
public IAggregationStatistics Collect()
}
internal System.Diagnostics.Metrics.AggregatorLookupFunc`1 : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public bool Invoke(ReadOnlySpan`1<KeyValuePair`2<string, object>> labels, TAggregator& aggregator)
public IAsyncResult BeginInvoke(ReadOnlySpan`1<KeyValuePair`2<string, object>> labels, TAggregator& aggregator, AsyncCallback callback, object object)
public bool EndInvoke(TAggregator& aggregator, IAsyncResult result)
}
internal System.Diagnostics.Metrics.AggregatorStore`1 : ValueType {
private Object modreq(System.Runtime.CompilerServices.IsVolatile) _stateUnion
private AggregatorLookupFunc`1 modreq(System.Runtime.CompilerServices.IsVolatile) _cachedLookupFunc
private Func`1<TAggregator> _createAggregatorFunc
public void .ctor(Func`1<TAggregator> createAggregator)
public TAggregator GetAggregator(ReadOnlySpan`1<KeyValuePair`2<string, object>> labels)
private TAggregator GetAggregatorSlow(ReadOnlySpan`1<KeyValuePair`2<string, object>> labels)
public void Collect(Action`1<LabeledAggregationStatistics> visitFunc)
public TAggregator GetAggregator()
public ConcurrentDictionary`2<TObjectSequence, TAggregator> GetLabelValuesDictionary(TStringSequence& names)
}
public System.Diagnostics.Metrics.Counter`1 : Instrument`1<T> {
internal void .ctor(Meter meter, string name, string unit, string description)
public void Add(T delta)
public void Add(T delta, KeyValuePair`2<string, object> tag)
public void Add(T delta, KeyValuePair`2<string, object> tag1, KeyValuePair`2<string, object> tag2)
public void Add(T delta, KeyValuePair`2<string, object> tag1, KeyValuePair`2<string, object> tag2, KeyValuePair`2<string, object> tag3)
public void Add(T delta, ReadOnlySpan`1<KeyValuePair`2<string, object>> tags)
public void Add(T delta, KeyValuePair`2[] tags)
public void Add(T delta, TagList& tagList)
}
internal System.Diagnostics.Metrics.ExponentialHistogramAggregator : Aggregator {
private int ExponentArraySize
private int ExponentShift
private double MinRelativeError
private QuantileAggregation _config
private Int32[][] _counters
private int _count
private int _mantissaMax
private int _mantissaMask
private int _mantissaShift
public void .ctor(QuantileAggregation config)
public IAggregationStatistics Collect()
private int GetInvalidCount(Int32[][] counters)
private IEnumerable`1<Bucket> IterateBuckets(Int32[][] counters)
public void Update(double measurement)
private int QuantileToRank(double quantile, int count)
private double GetBucketCanonicalValue(int exponent, int mantissa)
}
internal System.Diagnostics.Metrics.FixedSizeLabelNameDictionary`3 : ConcurrentDictionary`2<TStringSequence, ConcurrentDictionary`2<TObjectSequence, TAggregator>> {
public void Collect(Action`1<LabeledAggregationStatistics> visitFunc)
public ConcurrentDictionary`2<TObjectSequence, TAggregator> GetValuesDictionary(TStringSequence& names)
}
public System.Diagnostics.Metrics.Histogram`1 : Instrument`1<T> {
internal void .ctor(Meter meter, string name, string unit, string description)
public void Record(T value)
public void Record(T value, KeyValuePair`2<string, object> tag)
public void Record(T value, KeyValuePair`2<string, object> tag1, KeyValuePair`2<string, object> tag2)
public void Record(T value, KeyValuePair`2<string, object> tag1, KeyValuePair`2<string, object> tag2, KeyValuePair`2<string, object> tag3)
public void Record(T value, ReadOnlySpan`1<KeyValuePair`2<string, object>> tags)
public void Record(T value, KeyValuePair`2[] tags)
public void Record(T value, TagList& tagList)
}
internal System.Diagnostics.Metrics.HistogramStatistics : object {
private QuantileValue[] <Quantiles>k__BackingField
public QuantileValue[] Quantiles
internal void .ctor(QuantileValue[] quantiles)
public QuantileValue[] get_Quantiles()
}
public System.Diagnostics.Metrics.Instrument : object {
private object <SyncObject>k__BackingField
internal DiagLinkedList`1<ListenerSubscription> _subscriptions
private Meter <Meter>k__BackingField
private string <Name>k__BackingField
private string <Description>k__BackingField
private string <Unit>k__BackingField
internal KeyValuePair`2[] EmptyTags
internal object SyncObject
public Meter Meter
public string Name
public string Description
public string Unit
public bool Enabled
public bool IsObservable
internal KeyValuePair`2[] get_EmptyTags()
internal object get_SyncObject()
protected void .ctor(Meter meter, string name, string unit, string description)
protected void Publish()
public Meter get_Meter()
public string get_Name()
public string get_Description()
public string get_Unit()
public bool get_Enabled()
public bool get_IsObservable()
internal void NotifyForUnpublishedInstrument()
internal void ValidateTypeParameter()
internal object EnableMeasurement(ListenerSubscription subscription, Boolean& oldStateStored)
internal object DisableMeasurements(MeterListener listener)
internal void Observe(MeterListener listener)
internal object GetSubscriptionState(MeterListener listener)
}
public System.Diagnostics.Metrics.Instrument`1 : Instrument {
private KeyValuePair`2[] ts_tags
private int MaxTagsCount
protected void .ctor(Meter meter, string name, string unit, string description)
protected void RecordMeasurement(T measurement)
protected void RecordMeasurement(T measurement, ReadOnlySpan`1<KeyValuePair`2<string, object>> tags)
protected void RecordMeasurement(T measurement, KeyValuePair`2<string, object> tag)
protected void RecordMeasurement(T measurement, KeyValuePair`2<string, object> tag1, KeyValuePair`2<string, object> tag2)
protected void RecordMeasurement(T measurement, KeyValuePair`2<string, object> tag1, KeyValuePair`2<string, object> tag2, KeyValuePair`2<string, object> tag3)
protected void RecordMeasurement(T measurement, TagList& tagList)
}
internal System.Diagnostics.Metrics.InstrumentState : object {
public void Update(double measurement, ReadOnlySpan`1<KeyValuePair`2<string, object>> labels)
public void Collect(Instrument instrument, Action`1<LabeledAggregationStatistics> aggregationVisitFunc)
}
internal System.Diagnostics.Metrics.InstrumentState`1 : InstrumentState {
private AggregatorStore`1<TAggregator> _aggregatorStore
public void .ctor(Func`1<TAggregator> createAggregatorFunc)
public void Collect(Instrument instrument, Action`1<LabeledAggregationStatistics> aggregationVisitFunc)
public void Update(double measurement, ReadOnlySpan`1<KeyValuePair`2<string, object>> labels)
}
internal System.Diagnostics.Metrics.IObjectSequence {
public object Item
public object get_Item(int i)
public void set_Item(int i, object value)
}
internal System.Diagnostics.Metrics.IStringSequence {
public string Item
public int Length
public string get_Item(int i)
public void set_Item(int i, string value)
public int get_Length()
}
internal System.Diagnostics.Metrics.LabeledAggregationStatistics : object {
private KeyValuePair`2[] <Labels>k__BackingField
private IAggregationStatistics <AggregationStatistics>k__BackingField
public KeyValuePair`2[] Labels
public IAggregationStatistics AggregationStatistics
public void .ctor(IAggregationStatistics stats, KeyValuePair`2[] labels)
public KeyValuePair`2[] get_Labels()
public IAggregationStatistics get_AggregationStatistics()
}
internal System.Diagnostics.Metrics.LabelInstruction : ValueType {
private int <SourceIndex>k__BackingField
private string <LabelName>k__BackingField
public int SourceIndex
public string LabelName
public void .ctor(int sourceIndex, string labelName)
public int get_SourceIndex()
public string get_LabelName()
}
internal System.Diagnostics.Metrics.LabelInstructionCompiler : object {
public AggregatorLookupFunc`1<TAggregator> Create(AggregatorStore`1& aggregatorStore, Func`1<TAggregator> createAggregatorFunc, ReadOnlySpan`1<KeyValuePair`2<string, object>> labels)
private LabelInstruction[] Compile(ReadOnlySpan`1<KeyValuePair`2<string, object>> labels)
}
internal System.Diagnostics.Metrics.LabelInstructionInterpretter`2 : object {
private int _expectedLabelCount
private LabelInstruction[] _instructions
private ConcurrentDictionary`2<TObjectSequence, TAggregator> _valuesDict
private Func`2<TObjectSequence, TAggregator> _createAggregator
public void .ctor(int expectedLabelCount, LabelInstruction[] instructions, ConcurrentDictionary`2<TObjectSequence, TAggregator> valuesDict, Func`1<TAggregator> createAggregator)
public bool GetAggregator(ReadOnlySpan`1<KeyValuePair`2<string, object>> labels, TAggregator& aggregator)
}
internal System.Diagnostics.Metrics.LastValue : Aggregator {
private Nullable`1<double> _lastValue
public void Update(double value)
public IAggregationStatistics Collect()
}
internal System.Diagnostics.Metrics.LastValueStatistics : object {
private Nullable`1<double> <LastValue>k__BackingField
public Nullable`1<double> LastValue
internal void .ctor(Nullable`1<double> lastValue)
public Nullable`1<double> get_LastValue()
}
internal System.Diagnostics.Metrics.ListenerSubscription : ValueType {
private MeterListener <Listener>k__BackingField
private object <State>k__BackingField
internal MeterListener Listener
internal object State
internal void .ctor(MeterListener listener, object state)
internal MeterListener get_Listener()
internal object get_State()
}
public System.Diagnostics.Metrics.Measurement`1 : ValueType {
private KeyValuePair`2[] _tags
private T <Value>k__BackingField
public ReadOnlySpan`1<KeyValuePair`2<string, object>> Tags
public T Value
public void .ctor(T value)
public void .ctor(T value, IEnumerable`1<KeyValuePair`2<string, object>> tags)
public void .ctor(T value, KeyValuePair`2[] tags)
public void .ctor(T value, ReadOnlySpan`1<KeyValuePair`2<string, object>> tags)
public ReadOnlySpan`1<KeyValuePair`2<string, object>> get_Tags()
public T get_Value()
private KeyValuePair`2[] ToArray(IEnumerable`1<KeyValuePair`2<string, object>> tags)
}
public System.Diagnostics.Metrics.MeasurementCallback`1 : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(Instrument instrument, T measurement, ReadOnlySpan`1<KeyValuePair`2<string, object>> tags, object state)
public IAsyncResult BeginInvoke(Instrument instrument, T measurement, ReadOnlySpan`1<KeyValuePair`2<string, object>> tags, object state, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.Diagnostics.Metrics.Meter : object {
private List`1<Meter> s_allMeters
private List`1<Instrument> _instruments
private bool <Disposed>k__BackingField
private string <Name>k__BackingField
private string <Version>k__BackingField
internal bool Disposed
public string Name
public string Version
internal bool get_Disposed()
private void set_Disposed(bool value)
public void .ctor(string name)
public void .ctor(string name, string version)
public string get_Name()
public string get_Version()
public Counter`1<T> CreateCounter(string name, string unit, string description)
public Histogram`1<T> CreateHistogram(string name, string unit, string description)
public ObservableCounter`1<T> CreateObservableCounter(string name, Func`1<T> observeValue, string unit, string description)
public ObservableCounter`1<T> CreateObservableCounter(string name, Func`1<Measurement`1<T>> observeValue, string unit, string description)
public ObservableCounter`1<T> CreateObservableCounter(string name, Func`1<IEnumerable`1<Measurement`1<T>>> observeValues, string unit, string description)
public ObservableGauge`1<T> CreateObservableGauge(string name, Func`1<T> observeValue, string unit, string description)
public ObservableGauge`1<T> CreateObservableGauge(string name, Func`1<Measurement`1<T>> observeValue, string unit, string description)
public ObservableGauge`1<T> CreateObservableGauge(string name, Func`1<IEnumerable`1<Measurement`1<T>>> observeValues, string unit, string description)
public void Dispose()
internal bool AddInstrument(Instrument instrument)
internal List`1<Instrument> GetPublishedInstruments()
}
public System.Diagnostics.Metrics.MeterListener : object {
private List`1<MeterListener> s_allStartedListeners
private DiagLinkedList`1<Instrument> _enabledMeasurementInstruments
private bool _disposed
private MeasurementCallback`1<byte> _byteMeasurementCallback
private MeasurementCallback`1<short> _shortMeasurementCallback
private MeasurementCallback`1<int> _intMeasurementCallback
private MeasurementCallback`1<long> _longMeasurementCallback
private MeasurementCallback`1<float> _floatMeasurementCallback
private MeasurementCallback`1<double> _doubleMeasurementCallback
private MeasurementCallback`1<decimal> _decimalMeasurementCallback
private Action`2<Instrument, MeterListener> <InstrumentPublished>k__BackingField
private Action`2<Instrument, object> <MeasurementsCompleted>k__BackingField
public Action`2<Instrument, MeterListener> InstrumentPublished
public Action`2<Instrument, object> MeasurementsCompleted
public Action`2<Instrument, MeterListener> get_InstrumentPublished()
public void set_InstrumentPublished(Action`2<Instrument, MeterListener> value)
public Action`2<Instrument, object> get_MeasurementsCompleted()
public void set_MeasurementsCompleted(Action`2<Instrument, object> value)
public void EnableMeasurementEvents(Instrument instrument, object state)
public object DisableMeasurementEvents(Instrument instrument)
public void SetMeasurementEventCallback(MeasurementCallback`1<T> measurementCallback)
public void Start()
public void RecordObservableInstruments()
public void Dispose()
internal List`1<MeterListener> GetAllListeners()
internal void NotifyMeasurement(Instrument instrument, T measurement, ReadOnlySpan`1<KeyValuePair`2<string, object>> tags, object state)
}
internal System.Diagnostics.Metrics.MetricsEventSource : EventSource {
public MetricsEventSource Log
private CommandHandler _handler
private CommandHandler Handler
private CommandHandler get_Handler()
public void Message(string Message)
public void CollectionStart(string sessionId, DateTime intervalStartTime, DateTime intervalEndTime)
public void CollectionStop(string sessionId, DateTime intervalStartTime, DateTime intervalEndTime)
public void CounterRateValuePublished(string sessionId, string meterName, string meterVersion, string instrumentName, string unit, string tags, string rate)
public void GaugeValuePublished(string sessionId, string meterName, string meterVersion, string instrumentName, string unit, string tags, string lastValue)
public void HistogramValuePublished(string sessionId, string meterName, string meterVersion, string instrumentName, string unit, string tags, string quantiles)
public void BeginInstrumentReporting(string sessionId, string meterName, string meterVersion, string instrumentName, string instrumentType, string unit, string description)
public void EndInstrumentReporting(string sessionId, string meterName, string meterVersion, string instrumentName, string instrumentType, string unit, string description)
public void Error(string sessionId, string errorMessage)
public void InitialInstrumentEnumerationComplete(string sessionId)
public void InstrumentPublished(string sessionId, string meterName, string meterVersion, string instrumentName, string instrumentType, string unit, string description)
public void TimeSeriesLimitReached(string sessionId)
public void HistogramLimitReached(string sessionId)
public void ObservableInstrumentCallbackError(string sessionId, string errorMessage)
public void MultipleSessionsNotSupportedError(string runningSessionId)
protected void OnEventCommand(EventCommandEventArgs command)
}
internal System.Diagnostics.Metrics.MultiSizeLabelNameDictionary`1 : object {
private TAggregator NoLabelAggregator
private FixedSizeLabelNameDictionary`3<StringSequence1, ObjectSequence1, TAggregator> Label1
private FixedSizeLabelNameDictionary`3<StringSequence2, ObjectSequence2, TAggregator> Label2
private FixedSizeLabelNameDictionary`3<StringSequence3, ObjectSequence3, TAggregator> Label3
private FixedSizeLabelNameDictionary`3<StringSequenceMany, ObjectSequenceMany, TAggregator> LabelMany
public void .ctor(object initialLabelNameDict)
public TAggregator GetNoLabelAggregator(Func`1<TAggregator> createFunc)
public FixedSizeLabelNameDictionary`3<TStringSequence, TObjectSequence, TAggregator> GetFixedSizeLabelNameDictionary()
public void Collect(Action`1<LabeledAggregationStatistics> visitFunc)
}
internal System.Diagnostics.Metrics.ObjectSequence1 : ValueType {
public object Value1
public object Item
public void .ctor(object value1)
public int GetHashCode()
public bool Equals(ObjectSequence1 other)
public bool Equals(object obj)
public object get_Item(int i)
public void set_Item(int i, object value)
}
internal System.Diagnostics.Metrics.ObjectSequence2 : ValueType {
public object Value1
public object Value2
public object Item
public void .ctor(object value1, object value2)
public bool Equals(ObjectSequence2 other)
public bool Equals(object obj)
public object get_Item(int i)
public void set_Item(int i, object value)
public int GetHashCode()
}
internal System.Diagnostics.Metrics.ObjectSequence3 : ValueType {
public object Value1
public object Value2
public object Value3
public object Item
public void .ctor(object value1, object value2, object value3)
public bool Equals(ObjectSequence3 other)
public bool Equals(object obj)
public object get_Item(int i)
public void set_Item(int i, object value)
public int GetHashCode()
}
internal System.Diagnostics.Metrics.ObjectSequenceMany : ValueType {
private Object[] _values
public object Item
public void .ctor(Object[] values)
public bool Equals(ObjectSequenceMany other)
public bool Equals(object obj)
public object get_Item(int i)
public void set_Item(int i, object value)
public int GetHashCode()
}
public System.Diagnostics.Metrics.ObservableCounter`1 : ObservableInstrument`1<T> {
private object _callback
internal void .ctor(Meter meter, string name, Func`1<T> observeValue, string unit, string description)
internal void .ctor(Meter meter, string name, Func`1<Measurement`1<T>> observeValue, string unit, string description)
internal void .ctor(Meter meter, string name, Func`1<IEnumerable`1<Measurement`1<T>>> observeValues, string unit, string description)
protected IEnumerable`1<Measurement`1<T>> Observe()
}
public System.Diagnostics.Metrics.ObservableGauge`1 : ObservableInstrument`1<T> {
private object _callback
internal void .ctor(Meter meter, string name, Func`1<T> observeValue, string unit, string description)
internal void .ctor(Meter meter, string name, Func`1<Measurement`1<T>> observeValue, string unit, string description)
internal void .ctor(Meter meter, string name, Func`1<IEnumerable`1<Measurement`1<T>>> observeValues, string unit, string description)
protected IEnumerable`1<Measurement`1<T>> Observe()
}
public System.Diagnostics.Metrics.ObservableInstrument`1 : Instrument {
public bool IsObservable
protected void .ctor(Meter meter, string name, string unit, string description)
protected IEnumerable`1<Measurement`1<T>> Observe()
public bool get_IsObservable()
internal void Observe(MeterListener listener)
internal IEnumerable`1<Measurement`1<T>> Observe(object callback)
}
internal System.Diagnostics.Metrics.QuantileAggregation : object {
private Double[] <Quantiles>k__BackingField
private double <MaxRelativeError>k__BackingField
public Double[] Quantiles
public double MaxRelativeError
public void .ctor(Double[] quantiles)
public Double[] get_Quantiles()
public void set_Quantiles(Double[] value)
public double get_MaxRelativeError()
public void set_MaxRelativeError(double value)
}
internal System.Diagnostics.Metrics.QuantileValue : ValueType {
private double <Quantile>k__BackingField
private double <Value>k__BackingField
public double Quantile
public double Value
public void .ctor(double quantile, double value)
public double get_Quantile()
public double get_Value()
}
internal System.Diagnostics.Metrics.RateAggregator : Aggregator {
private Nullable`1<double> _prevValue
private double _value
public void Update(double value)
public IAggregationStatistics Collect()
}
internal System.Diagnostics.Metrics.RateStatistics : object {
private Nullable`1<double> <Delta>k__BackingField
public Nullable`1<double> Delta
public void .ctor(Nullable`1<double> delta)
public Nullable`1<double> get_Delta()
}
internal System.Diagnostics.Metrics.RateSumAggregator : Aggregator {
private double _sum
public void Update(double value)
public IAggregationStatistics Collect()
}
internal System.Diagnostics.Metrics.StringSequence1 : ValueType {
public string Value1
public string Item
public int Length
public void .ctor(string value1)
public int GetHashCode()
public bool Equals(StringSequence1 other)
public bool Equals(object obj)
public string get_Item(int i)
public void set_Item(int i, string value)
public int get_Length()
}
internal System.Diagnostics.Metrics.StringSequence2 : ValueType {
public string Value1
public string Value2
public string Item
public int Length
public void .ctor(string value1, string value2)
public bool Equals(StringSequence2 other)
public bool Equals(object obj)
public string get_Item(int i)
public void set_Item(int i, string value)
public int get_Length()
public int GetHashCode()
}
internal System.Diagnostics.Metrics.StringSequence3 : ValueType {
public string Value1
public string Value2
public string Value3
public string Item
public int Length
public void .ctor(string value1, string value2, string value3)
public bool Equals(StringSequence3 other)
public bool Equals(object obj)
public string get_Item(int i)
public void set_Item(int i, string value)
public int get_Length()
public int GetHashCode()
}
internal System.Diagnostics.Metrics.StringSequenceMany : ValueType {
private String[] _values
public string Item
public int Length
public void .ctor(String[] values)
public Span`1<string> AsSpan()
public bool Equals(StringSequenceMany other)
public bool Equals(object obj)
public string get_Item(int i)
public void set_Item(int i, string value)
public int get_Length()
public int GetHashCode()
}
internal System.Diagnostics.NoOutputPropagator : DistributedContextPropagator {
private DistributedContextPropagator <Instance>k__BackingField
private IReadOnlyCollection`1<string> <Fields>k__BackingField
internal DistributedContextPropagator Instance
public IReadOnlyCollection`1<string> Fields
internal DistributedContextPropagator get_Instance()
public IReadOnlyCollection`1<string> get_Fields()
public void Inject(Activity activity, object carrier, PropagatorSetterCallback setter)
public void ExtractTraceIdAndState(object carrier, PropagatorGetterCallback getter, String& traceId, String& traceState)
public IEnumerable`1<KeyValuePair`2<string, string>> ExtractBaggage(object carrier, PropagatorGetterCallback getter)
}
internal System.Diagnostics.PassThroughPropagator : DistributedContextPropagator {
private DistributedContextPropagator <Instance>k__BackingField
private IReadOnlyCollection`1<string> <Fields>k__BackingField
internal DistributedContextPropagator Instance
public IReadOnlyCollection`1<string> Fields
internal DistributedContextPropagator get_Instance()
public IReadOnlyCollection`1<string> get_Fields()
public void Inject(Activity activity, object carrier, PropagatorSetterCallback setter)
public void ExtractTraceIdAndState(object carrier, PropagatorGetterCallback getter, String& traceId, String& traceState)
public IEnumerable`1<KeyValuePair`2<string, string>> ExtractBaggage(object carrier, PropagatorGetterCallback getter)
private void GetRootId(String& parentId, String& traceState, Boolean& isW3c, IEnumerable`1& baggage)
}
internal System.Diagnostics.RandomNumberGenerator : object {
private RandomNumberGenerator t_random
private ulong _s0
private ulong _s1
private ulong _s2
private ulong _s3
public RandomNumberGenerator Current
public RandomNumberGenerator get_Current()
private ulong Rol64(ulong x, int k)
public long Next()
}
public System.Diagnostics.SampleActivity`1 : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public ActivitySamplingResult Invoke(ActivityCreationOptions`1& options)
public IAsyncResult BeginInvoke(ActivityCreationOptions`1& options, AsyncCallback callback, object object)
public ActivitySamplingResult EndInvoke(ActivityCreationOptions`1& options, IAsyncResult result)
}
internal System.Diagnostics.SynchronizedList`1 : object {
private List`1<T> _list
private UInt32 _version
public int Count
public void Add(T item)
public bool AddIfNotExist(T item)
public bool Remove(T item)
public int get_Count()
public void EnumWithFunc(Function`2<T, TParent> func, ActivityCreationOptions`1& data, ActivitySamplingResult& samplingResult, ActivityCreationOptions`1& dataWithContext)
public void EnumWithAction(Action`2<T, object> action, object arg)
}
public System.Diagnostics.TagList : ValueType {
internal KeyValuePair`2<string, object> Tag1
internal KeyValuePair`2<string, object> Tag2
internal KeyValuePair`2<string, object> Tag3
internal KeyValuePair`2<string, object> Tag4
internal KeyValuePair`2<string, object> Tag5
internal KeyValuePair`2<string, object> Tag6
internal KeyValuePair`2<string, object> Tag7
internal KeyValuePair`2<string, object> Tag8
private int _tagsCount
private KeyValuePair`2[] _overflowTags
private int OverflowAdditionalCapacity
public int Count
public bool IsReadOnly
public KeyValuePair`2<string, object> Item
internal KeyValuePair`2[] Tags
public void .ctor(ReadOnlySpan`1<KeyValuePair`2<string, object>> tagList)
public int get_Count()
public bool get_IsReadOnly()
public KeyValuePair`2<string, object> get_Item(int index)
public void set_Item(int index, KeyValuePair`2<string, object> value)
public void Add(string key, object value)
public void Add(KeyValuePair`2<string, object> tag)
public void CopyTo(Span`1<KeyValuePair`2<string, object>> tags)
public void CopyTo(KeyValuePair`2[] array, int arrayIndex)
public void Insert(int index, KeyValuePair`2<string, object> item)
public void RemoveAt(int index)
public void Clear()
public bool Contains(KeyValuePair`2<string, object> item)
public bool Remove(KeyValuePair`2<string, object> item)
public IEnumerator`1<KeyValuePair`2<string, object>> GetEnumerator()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
public int IndexOf(KeyValuePair`2<string, object> item)
internal KeyValuePair`2[] get_Tags()
private bool TagsEqual(KeyValuePair`2<string, object> tag1, KeyValuePair`2<string, object> tag2)
private void MoveTagsToTheArray()
}
internal System.HexConverter : object {
public ReadOnlySpan`1<byte> CharToHexLookup
public void ToBytesBuffer(byte value, Span`1<byte> buffer, int startingIndex, Casing casing)
public void ToCharsBuffer(byte value, Span`1<char> buffer, int startingIndex, Casing casing)
public void EncodeToUtf16(ReadOnlySpan`1<byte> bytes, Span`1<char> chars, Casing casing)
public string ToString(ReadOnlySpan`1<byte> bytes, Casing casing)
public char ToCharUpper(int value)
public char ToCharLower(int value)
public bool TryDecodeFromUtf16(ReadOnlySpan`1<char> chars, Span`1<byte> bytes)
public bool TryDecodeFromUtf16(ReadOnlySpan`1<char> chars, Span`1<byte> bytes, Int32& charsProcessed)
public int FromChar(int c)
public int FromUpperChar(int c)
public int FromLowerChar(int c)
public bool IsHexChar(int c)
public bool IsHexUpperChar(int c)
public bool IsHexLowerChar(int c)
public ReadOnlySpan`1<byte> get_CharToHexLookup()
}
internal System.Runtime.CompilerServices.NullableAttribute : Attribute {
public Byte[] NullableFlags
public void .ctor(byte )
public void .ctor(Byte[] )
}
internal System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
public byte Flag
public void .ctor(byte )
}
internal System.Runtime.CompilerServices.NullablePublicOnlyAttribute : Attribute {
public bool IncludesInternals
public void .ctor(bool )
}
internal System.Runtime.Versioning.OSPlatformAttribute : Attribute {
private string <PlatformName>k__BackingField
public string PlatformName
private protected void .ctor(string platformName)
public string get_PlatformName()
}
internal System.Runtime.Versioning.SupportedOSPlatformAttribute : OSPlatformAttribute {
public void .ctor(string platformName)
}
internal System.Runtime.Versioning.SupportedOSPlatformGuardAttribute : OSPlatformAttribute {
public void .ctor(string platformName)
}
internal System.Runtime.Versioning.TargetPlatformAttribute : OSPlatformAttribute {
public void .ctor(string platformName)
}
internal System.Runtime.Versioning.UnsupportedOSPlatformAttribute : OSPlatformAttribute {
public void .ctor(string platformName)
}
internal System.Runtime.Versioning.UnsupportedOSPlatformGuardAttribute : OSPlatformAttribute {
public void .ctor(string platformName)
}
internal System.SR : object {
private bool s_usingResourceKeys
private ResourceManager s_resourceManager
internal ResourceManager ResourceManager
internal string ActivityIdFormatInvalid
internal string ActivityNotRunning
internal string ActivityNotStarted
internal string ActivityStartAlreadyStarted
internal string EndTimeNotUtc
internal string OperationNameInvalid
internal string ParentIdAlreadySet
internal string ParentIdInvalid
internal string SetFormatOnStartedActivity
internal string SetLinkInvalid
internal string SetParentIdOnActivityWithParent
internal string StartTimeNotUtc
internal string KeyAlreadyExist
internal string InvalidTraceParent
internal string UnableAccessServicePointTable
internal string UnableToInitialize
internal string UnsupportedType
internal string Arg_BufferTooSmall
private bool UsingResourceKeys()
internal string GetResourceString(string resourceKey)
internal string GetResourceString(string resourceKey, string defaultString)
internal string Format(string resourceFormat, object p1)
internal string Format(string resourceFormat, object p1, object p2)
internal string Format(string resourceFormat, object p1, object p2, object p3)
internal string Format(string resourceFormat, Object[] args)
internal string Format(IFormatProvider provider, string resourceFormat, object p1)
internal string Format(IFormatProvider provider, string resourceFormat, object p1, object p2)
internal string Format(IFormatProvider provider, string resourceFormat, object p1, object p2, object p3)
internal string Format(IFormatProvider provider, string resourceFormat, Object[] args)
internal ResourceManager get_ResourceManager()
internal string get_ActivityIdFormatInvalid()
internal string get_ActivityNotRunning()
internal string get_ActivityNotStarted()
internal string get_ActivityStartAlreadyStarted()
internal string get_EndTimeNotUtc()
internal string get_OperationNameInvalid()
internal string get_ParentIdAlreadySet()
internal string get_ParentIdInvalid()
internal string get_SetFormatOnStartedActivity()
internal string get_SetLinkInvalid()
internal string get_SetParentIdOnActivityWithParent()
internal string get_StartTimeNotUtc()
internal string get_KeyAlreadyExist()
internal string get_InvalidTraceParent()
internal string get_UnableAccessServicePointTable()
internal string get_UnableToInitialize()
internal string get_UnsupportedType()
internal string get_Arg_BufferTooSmall()
}
