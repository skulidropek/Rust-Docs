public UnityEngine.Timeline.ActivationControlPlayable : PlayableBehaviour {
public GameObject gameObject
public PostPlaybackState postPlayback
private InitialState m_InitialState
public ScriptPlayable`1<ActivationControlPlayable> Create(PlayableGraph graph, GameObject gameObject, PostPlaybackState postPlaybackState)
public void OnBehaviourPlay(Playable playable, FrameData info)
public void OnBehaviourPause(Playable playable, FrameData info)
public void ProcessFrame(Playable playable, FrameData info, object userData)
public void OnGraphStart(Playable playable)
public void OnPlayableDestroy(Playable playable)
}
internal UnityEngine.Timeline.ActivationMixerPlayable : PlayableBehaviour {
private PostPlaybackState m_PostPlaybackState
private bool m_BoundGameObjectInitialStateIsActive
private GameObject m_BoundGameObject
public PostPlaybackState postPlaybackState
public ScriptPlayable`1<ActivationMixerPlayable> Create(PlayableGraph graph, int inputCount)
public PostPlaybackState get_postPlaybackState()
public void set_postPlaybackState(PostPlaybackState value)
public void OnPlayableDestroy(Playable playable)
public void ProcessFrame(Playable playable, FrameData info, object playerData)
}
internal UnityEngine.Timeline.ActivationPlayableAsset : PlayableAsset {
public ClipCaps clipCaps
public ClipCaps get_clipCaps()
public Playable CreatePlayable(PlayableGraph graph, GameObject go)
}
public UnityEngine.Timeline.ActivationTrack : TrackAsset {
private PostPlaybackState m_PostPlaybackState
private ActivationMixerPlayable m_ActivationMixer
public PostPlaybackState postPlaybackState
internal bool CanCompileClips()
public PostPlaybackState get_postPlaybackState()
public void set_postPlaybackState(PostPlaybackState value)
public Playable CreateTrackMixer(PlayableGraph graph, GameObject go, int inputCount)
internal void UpdateTrackMode()
public void GatherProperties(PlayableDirector director, IPropertyCollector driver)
protected void OnCreateClip(TimelineClip clip)
}
internal UnityEngine.Timeline.AnimationOutputWeightProcessor : object {
private AnimationPlayableOutput m_Output
private AnimationMotionXToDeltaPlayable m_MotionXPlayable
private List`1<WeightInfo> m_Mixers
public void .ctor(AnimationPlayableOutput output)
private void FindMixers()
private void FindMixers(Playable parent, int port, Playable node)
public void Evaluate()
}
public UnityEngine.Timeline.AnimationPlayableAsset : PlayableAsset {
private AnimationClip m_Clip
private Vector3 m_Position
private Vector3 m_EulerAngles
private bool m_UseTrackMatchFields
private MatchTargetFields m_MatchTargetFields
private bool m_RemoveStartOffset
private bool m_ApplyFootIK
private LoopMode m_Loop
private AppliedOffsetMode <appliedOffsetMode>k__BackingField
private int k_LatestVersion
private int m_Version
private Quaternion m_Rotation
public Vector3 position
public Quaternion rotation
public Vector3 eulerAngles
public bool useTrackMatchFields
public MatchTargetFields matchTargetFields
public bool removeStartOffset
public bool applyFootIK
public LoopMode loop
internal bool hasRootTransforms
internal AppliedOffsetMode appliedOffsetMode
public AnimationClip clip
public double duration
public IEnumerable`1<PlayableBinding> outputs
public ClipCaps clipCaps
public Vector3 get_position()
public void set_position(Vector3 value)
public Quaternion get_rotation()
public void set_rotation(Quaternion value)
public Vector3 get_eulerAngles()
public void set_eulerAngles(Vector3 value)
public bool get_useTrackMatchFields()
public void set_useTrackMatchFields(bool value)
public MatchTargetFields get_matchTargetFields()
public void set_matchTargetFields(MatchTargetFields value)
public bool get_removeStartOffset()
public void set_removeStartOffset(bool value)
public bool get_applyFootIK()
public void set_applyFootIK(bool value)
public LoopMode get_loop()
public void set_loop(LoopMode value)
internal bool get_hasRootTransforms()
internal AppliedOffsetMode get_appliedOffsetMode()
internal void set_appliedOffsetMode(AppliedOffsetMode value)
public AnimationClip get_clip()
public void set_clip(AnimationClip value)
public double get_duration()
public IEnumerable`1<PlayableBinding> get_outputs()
public Playable CreatePlayable(PlayableGraph graph, GameObject go)
internal Playable CreatePlayable(PlayableGraph graph, AnimationClip clip, Vector3 positionOffset, Vector3 eulerOffset, bool removeStartOffset, AppliedOffsetMode mode, bool applyFootIK, LoopMode loop)
private bool ShouldApplyOffset(AppliedOffsetMode mode, AnimationClip clip)
private bool ShouldApplyScaleRemove(AppliedOffsetMode mode)
public ClipCaps get_clipCaps()
public void ResetOffsets()
public void GatherProperties(PlayableDirector director, IPropertyCollector driver)
internal bool HasRootTransforms(AnimationClip clip)
private void UnityEngine.ISerializationCallbackReceiver.OnBeforeSerialize()
private void UnityEngine.ISerializationCallbackReceiver.OnAfterDeserialize()
private void OnUpgradeFromVersion(int oldVersion)
}
internal UnityEngine.Timeline.AnimationPreviewUpdateCallback : object {
private AnimationPlayableOutput m_Output
private PlayableGraph m_Graph
private List`1<IAnimationWindowPreview> m_PreviewComponents
public void .ctor(AnimationPlayableOutput output)
public void Evaluate()
private void FetchPreviewComponents()
}
public UnityEngine.Timeline.AnimationTrack : TrackAsset {
private string k_DefaultInfiniteClipName
private string k_DefaultRecordableClipName
private ClipExtrapolation m_InfiniteClipPreExtrapolation
private ClipExtrapolation m_InfiniteClipPostExtrapolation
private Vector3 m_InfiniteClipOffsetPosition
private Vector3 m_InfiniteClipOffsetEulerAngles
private double m_InfiniteClipTimeOffset
private bool m_InfiniteClipRemoveOffset
private bool m_InfiniteClipApplyFootIK
private LoopMode mInfiniteClipLoop
private MatchTargetFields m_MatchTargetFields
private Vector3 m_Position
private Vector3 m_EulerAngles
private AvatarMask m_AvatarMask
private bool m_ApplyAvatarMask
private TrackOffset m_TrackOffset
private AnimationClip m_InfiniteClip
private Queue`1<Transform> s_CachedQueue
private Quaternion m_OpenClipOffsetRotation
private Quaternion m_Rotation
private bool m_ApplyOffsets
public Vector3 position
public Quaternion rotation
public Vector3 eulerAngles
public bool applyOffsets
public TrackOffset trackOffset
public MatchTargetFields matchTargetFields
public AnimationClip infiniteClip
internal bool infiniteClipRemoveOffset
public AvatarMask avatarMask
public bool applyAvatarMask
public IEnumerable`1<PlayableBinding> outputs
public bool inClipMode
public Vector3 infiniteClipOffsetPosition
public Quaternion infiniteClipOffsetRotation
public Vector3 infiniteClipOffsetEulerAngles
internal bool infiniteClipApplyFootIK
internal double infiniteClipTimeOffset
public ClipExtrapolation infiniteClipPreExtrapolation
public ClipExtrapolation infiniteClipPostExtrapolation
internal LoopMode infiniteClipLoop
public Vector3 openClipOffsetPosition
public Quaternion openClipOffsetRotation
public Vector3 openClipOffsetEulerAngles
public ClipExtrapolation openClipPreExtrapolation
public ClipExtrapolation openClipPostExtrapolation
public Vector3 get_position()
public void set_position(Vector3 value)
public Quaternion get_rotation()
public void set_rotation(Quaternion value)
public Vector3 get_eulerAngles()
public void set_eulerAngles(Vector3 value)
public bool get_applyOffsets()
public void set_applyOffsets(bool value)
public TrackOffset get_trackOffset()
public void set_trackOffset(TrackOffset value)
public MatchTargetFields get_matchTargetFields()
public void set_matchTargetFields(MatchTargetFields value)
public AnimationClip get_infiniteClip()
internal void set_infiniteClip(AnimationClip value)
internal bool get_infiniteClipRemoveOffset()
internal void set_infiniteClipRemoveOffset(bool value)
public AvatarMask get_avatarMask()
public void set_avatarMask(AvatarMask value)
public bool get_applyAvatarMask()
public void set_applyAvatarMask(bool value)
internal bool CanCompileClips()
public IEnumerable`1<PlayableBinding> get_outputs()
public bool get_inClipMode()
public Vector3 get_infiniteClipOffsetPosition()
public void set_infiniteClipOffsetPosition(Vector3 value)
public Quaternion get_infiniteClipOffsetRotation()
public void set_infiniteClipOffsetRotation(Quaternion value)
public Vector3 get_infiniteClipOffsetEulerAngles()
public void set_infiniteClipOffsetEulerAngles(Vector3 value)
internal bool get_infiniteClipApplyFootIK()
internal void set_infiniteClipApplyFootIK(bool value)
internal double get_infiniteClipTimeOffset()
internal void set_infiniteClipTimeOffset(double value)
public ClipExtrapolation get_infiniteClipPreExtrapolation()
public void set_infiniteClipPreExtrapolation(ClipExtrapolation value)
public ClipExtrapolation get_infiniteClipPostExtrapolation()
public void set_infiniteClipPostExtrapolation(ClipExtrapolation value)
internal LoopMode get_infiniteClipLoop()
internal void set_infiniteClipLoop(LoopMode value)
private void ResetOffsets()
public TimelineClip CreateClip(AnimationClip clip)
public void CreateInfiniteClip(string infiniteClipName)
public TimelineClip CreateRecordableClip(string animClipName)
protected void OnCreateClip(TimelineClip clip)
protected internal int CalculateItemsHash()
internal void UpdateClipOffsets()
private Playable CompileTrackPlayable(PlayableGraph graph, AnimationTrack track, GameObject go, IntervalTree`1<RuntimeElement> tree, AppliedOffsetMode mode)
private Playable UnityEngine.Timeline.ILayerable.CreateLayerMixer(PlayableGraph graph, GameObject go, int inputCount)
internal Playable CreateMixerPlayableGraph(PlayableGraph graph, GameObject go, IntervalTree`1<RuntimeElement> tree)
private int GetDefaultBlendCount()
private void AttachDefaultBlend(PlayableGraph graph, AnimationLayerMixerPlayable mixer, bool requireOffset)
private Playable AttachOffsetPlayable(PlayableGraph graph, Playable playable, Vector3 pos, Quaternion rot)
private bool RequiresMotionXPlayable(AppliedOffsetMode mode, GameObject gameObject)
private bool UsesAbsoluteMotion(AppliedOffsetMode mode)
private bool HasController(GameObject gameObject)
internal Animator GetBinding(PlayableDirector director)
private AnimationLayerMixerPlayable CreateGroupMixer(PlayableGraph graph, GameObject go, int inputCount)
private Playable CreateInfiniteTrackPlayable(PlayableGraph graph, GameObject go, IntervalTree`1<RuntimeElement> tree, AppliedOffsetMode mode)
private Playable ApplyTrackOffset(PlayableGraph graph, Playable root, GameObject go, AppliedOffsetMode mode)
internal void GetEvaluationTime(Double& outStart, Double& outDuration)
internal void GetSequenceTime(Double& outStart, Double& outDuration)
private void AssignAnimationClip(TimelineClip clip, AnimationClip animClip)
public void GatherProperties(PlayableDirector director, IPropertyCollector driver)
private void GetAnimationClips(List`1<AnimationClip> animClips)
private AppliedOffsetMode GetOffsetMode(GameObject go, bool animatesRootTransform)
private bool IsRootTransformDisabledByMask(GameObject gameObject, Transform genericRootNode)
private Transform GetGenericRootNode(GameObject gameObject)
internal bool AnimatesRootTransform()
private Transform FindInHierarchyBreadthFirst(Transform t, string name)
public Vector3 get_openClipOffsetPosition()
public void set_openClipOffsetPosition(Vector3 value)
public Quaternion get_openClipOffsetRotation()
public void set_openClipOffsetRotation(Quaternion value)
public Vector3 get_openClipOffsetEulerAngles()
public void set_openClipOffsetEulerAngles(Vector3 value)
public ClipExtrapolation get_openClipPreExtrapolation()
public void set_openClipPreExtrapolation(ClipExtrapolation value)
public ClipExtrapolation get_openClipPostExtrapolation()
public void set_openClipPostExtrapolation(ClipExtrapolation value)
internal void OnUpgradeFromVersion(int oldVersion)
}
internal UnityEngine.Timeline.AppliedOffsetMode : Enum {
public int value__
public AppliedOffsetMode NoRootTransform
public AppliedOffsetMode TransformOffset
public AppliedOffsetMode SceneOffset
public AppliedOffsetMode TransformOffsetLegacy
public AppliedOffsetMode SceneOffsetLegacy
public AppliedOffsetMode SceneOffsetEditor
public AppliedOffsetMode SceneOffsetLegacyEditor
}
internal UnityEngine.Timeline.AudioClipProperties : PlayableBehaviour {
public float volume
}
internal UnityEngine.Timeline.AudioMixerProperties : PlayableBehaviour {
public float volume
public float stereoPan
public float spatialBlend
public void PrepareFrame(Playable playable, FrameData info)
}
public UnityEngine.Timeline.AudioPlayableAsset : PlayableAsset {
private AudioClip m_Clip
private bool m_Loop
private float m_bufferingTime
private AudioClipProperties m_ClipProperties
internal float bufferingTime
public AudioClip clip
public bool loop
public double duration
public IEnumerable`1<PlayableBinding> outputs
public ClipCaps clipCaps
internal float get_bufferingTime()
internal void set_bufferingTime(float value)
public AudioClip get_clip()
public void set_clip(AudioClip value)
public bool get_loop()
public void set_loop(bool value)
public double get_duration()
public IEnumerable`1<PlayableBinding> get_outputs()
public Playable CreatePlayable(PlayableGraph graph, GameObject go)
public ClipCaps get_clipCaps()
}
public UnityEngine.Timeline.AudioTrack : TrackAsset {
private AudioMixerProperties m_TrackProperties
public IEnumerable`1<PlayableBinding> outputs
public TimelineClip CreateClip(AudioClip clip)
internal Playable CompileClips(PlayableGraph graph, GameObject go, IList`1<TimelineClip> timelineClips, IntervalTree`1<RuntimeElement> tree)
public IEnumerable`1<PlayableBinding> get_outputs()
private void OnValidate()
}
public UnityEngine.Timeline.BasicPlayableBehaviour : ScriptableObject {
public double duration
public IEnumerable`1<PlayableBinding> outputs
public double get_duration()
public IEnumerable`1<PlayableBinding> get_outputs()
public void OnGraphStart(Playable playable)
public void OnGraphStop(Playable playable)
public void OnPlayableCreate(Playable playable)
public void OnPlayableDestroy(Playable playable)
public void OnBehaviourPlay(Playable playable, FrameData info)
public void OnBehaviourPause(Playable playable, FrameData info)
public void PrepareFrame(Playable playable, FrameData info)
public void ProcessFrame(Playable playable, FrameData info, object playerData)
public Playable CreatePlayable(PlayableGraph graph, GameObject owner)
}
public UnityEngine.Timeline.ClipCaps : Enum {
public int value__
public ClipCaps None
public ClipCaps Looping
public ClipCaps Extrapolation
public ClipCaps ClipIn
public ClipCaps SpeedMultiplier
public ClipCaps Blending
public ClipCaps AutoScale
public ClipCaps All
}
public UnityEngine.Timeline.ControlPlayableAsset : PlayableAsset {
private int k_MaxRandInt
private List`1<PlayableDirector> k_EmptyDirectorsList
private List`1<ParticleSystem> k_EmptyParticlesList
private HashSet`1<ParticleSystem> s_SubEmitterCollector
public ExposedReference`1<GameObject> sourceGameObject
public GameObject prefabGameObject
public bool updateParticle
public UInt32 particleRandomSeed
public bool updateDirector
public bool updateITimeControl
public bool searchHierarchy
public bool active
public PostPlaybackState postPlayback
private PlayableAsset m_ControlDirectorAsset
private double m_Duration
private bool m_SupportLoop
private HashSet`1<PlayableDirector> s_ProcessedDirectors
private HashSet`1<GameObject> s_CreatedPrefabs
private bool <controllingDirectors>k__BackingField
private bool <controllingParticles>k__BackingField
internal bool controllingDirectors
internal bool controllingParticles
public double duration
public ClipCaps clipCaps
internal bool get_controllingDirectors()
private void set_controllingDirectors(bool value)
internal bool get_controllingParticles()
private void set_controllingParticles(bool value)
public void OnEnable()
public double get_duration()
public ClipCaps get_clipCaps()
public Playable CreatePlayable(PlayableGraph graph, GameObject go)
private Playable ConnectPlayablesToMixer(PlayableGraph graph, List`1<Playable> playables)
private void CreateActivationPlayable(GameObject root, PlayableGraph graph, List`1<Playable> outplayables)
private void SearchHierarchyAndConnectParticleSystem(IEnumerable`1<ParticleSystem> particleSystems, PlayableGraph graph, List`1<Playable> outplayables)
private void SearchHierarchyAndConnectDirector(IEnumerable`1<PlayableDirector> directors, PlayableGraph graph, List`1<Playable> outplayables, bool disableSelfReferences)
private void SearchHierarchyAndConnectControlableScripts(IEnumerable`1<MonoBehaviour> controlableScripts, PlayableGraph graph, List`1<Playable> outplayables)
private void ConnectMixerAndPlayable(PlayableGraph graph, Playable mixer, Playable playable, int portIndex)
internal IList`1<T> GetComponent(GameObject gameObject)
internal IEnumerable`1<MonoBehaviour> GetControlableScripts(GameObject root)
internal void UpdateDurationAndLoopFlag(IList`1<PlayableDirector> directors, IList`1<ParticleSystem> particleSystems)
private IList`1<ParticleSystem> GetControllableParticleSystems(GameObject go)
private void GetControllableParticleSystems(Transform t, ICollection`1<ParticleSystem> roots, HashSet`1<ParticleSystem> subEmitters)
private void CacheSubEmitters(ParticleSystem ps, HashSet`1<ParticleSystem> subEmitters)
public void GatherProperties(PlayableDirector director, IPropertyCollector driver)
internal void PreviewParticles(IPropertyCollector driver, IEnumerable`1<ParticleSystem> particles)
internal void PreviewActivation(IPropertyCollector driver, IEnumerable`1<GameObject> objects)
internal void PreviewTimeControl(IPropertyCollector driver, PlayableDirector director, IEnumerable`1<MonoBehaviour> scripts)
internal void PreviewDirectors(IPropertyCollector driver, IEnumerable`1<PlayableDirector> directors)
}
public UnityEngine.Timeline.CustomStyleAttribute : Attribute {
public string ussStyle
public void .ctor(string ussStyle)
}
public UnityEngine.Timeline.DirectorControlPlayable : PlayableBehaviour {
public PlayableDirector director
private bool m_SyncTime
private double m_AssetDuration
public ScriptPlayable`1<DirectorControlPlayable> Create(PlayableGraph graph, PlayableDirector director)
public void OnPlayableDestroy(Playable playable)
public void PrepareFrame(Playable playable, FrameData info)
public void OnBehaviourPlay(Playable playable, FrameData info)
public void OnBehaviourPause(Playable playable, FrameData info)
public void ProcessFrame(Playable playable, FrameData info, object playerData)
private void SyncSpeed(double speed)
private void SyncPlayState(PlayableGraph graph, double playableTime)
private bool DetectDiscontinuity(Playable playable, FrameData info)
private bool DetectOutOfSync(Playable playable)
private void UpdateTime(Playable playable)
}
internal UnityEngine.Timeline.DiscreteTime : ValueType {
private double k_Tick
public DiscreteTime kMaxTime
private long m_DiscreteTime
public double tickValue
public double get_tickValue()
public void .ctor(DiscreteTime time)
private void .ctor(long time)
public void .ctor(double time)
public void .ctor(float time)
public void .ctor(int time)
public void .ctor(int frame, double fps)
public DiscreteTime OneTickBefore()
public DiscreteTime OneTickAfter()
public long GetTick()
public DiscreteTime FromTicks(long ticks)
public int CompareTo(object obj)
public bool Equals(DiscreteTime other)
public bool Equals(object obj)
private long DoubleToDiscreteTime(double time)
private long FloatToDiscreteTime(float time)
private long IntToDiscreteTime(int time)
private double ToDouble(long time)
private float ToFloat(long time)
public double op_Explicit(DiscreteTime b)
public float op_Explicit(DiscreteTime b)
public long op_Explicit(DiscreteTime b)
public DiscreteTime op_Explicit(double time)
public DiscreteTime op_Explicit(float time)
public DiscreteTime op_Implicit(int time)
public DiscreteTime op_Explicit(long time)
public bool op_Equality(DiscreteTime lhs, DiscreteTime rhs)
public bool op_Inequality(DiscreteTime lhs, DiscreteTime rhs)
public bool op_GreaterThan(DiscreteTime lhs, DiscreteTime rhs)
public bool op_LessThan(DiscreteTime lhs, DiscreteTime rhs)
public bool op_LessThanOrEqual(DiscreteTime lhs, DiscreteTime rhs)
public bool op_GreaterThanOrEqual(DiscreteTime lhs, DiscreteTime rhs)
public DiscreteTime op_Addition(DiscreteTime lhs, DiscreteTime rhs)
public DiscreteTime op_Subtraction(DiscreteTime lhs, DiscreteTime rhs)
public string ToString()
public int GetHashCode()
public DiscreteTime Min(DiscreteTime lhs, DiscreteTime rhs)
public DiscreteTime Max(DiscreteTime lhs, DiscreteTime rhs)
public double SnapToNearestTick(double time)
public float SnapToNearestTick(float time)
public long GetNearestTick(double time)
}
internal UnityEngine.Timeline.Extrapolation : object {
internal double kMinExtrapolationTime
internal void CalculateExtrapolationTimes(TrackAsset asset)
private TimelineClip[] SortClipsByStartTime(TimelineClip[] clips)
}
internal UnityEngine.Timeline.FrameRate : ValueType {
public double rate
public FrameRate k_23_976Fps
public FrameRate k_24Fps
public FrameRate k_25Fps
public FrameRate k_30Fps
public FrameRate k_29_97Fps
public FrameRate k_50Fps
public FrameRate k_59_94Fps
public FrameRate k_60Fps
private void .ctor(double framerate)
public bool IsValid()
public bool Equals(FrameRate other)
public bool Equals(object obj)
public int GetHashCode()
public bool op_Equality(FrameRate a, FrameRate b)
public bool op_Inequality(FrameRate a, FrameRate b)
public FrameRate DoubleToFrameRate(double rate)
}
public UnityEngine.Timeline.GroupTrack : TrackAsset {
public IEnumerable`1<PlayableBinding> outputs
internal bool CanCompileClips()
public IEnumerable`1<PlayableBinding> get_outputs()
}
internal UnityEngine.Timeline.HashUtility : object {
public int CombineHash(int h1, int h2)
public int CombineHash(int h1, int h2, int h3)
public int CombineHash(int h1, int h2, int h3, int h4)
public int CombineHash(int h1, int h2, int h3, int h4, int h5)
public int CombineHash(int h1, int h2, int h3, int h4, int h5, int h6)
public int CombineHash(int h1, int h2, int h3, int h4, int h5, int h6, int h7)
public int CombineHash(Int32[] hashes)
}
internal UnityEngine.Timeline.ICurvesOwner {
public AnimationClip curves
public bool hasCurves
public double duration
public string defaultCurvesName
public Object asset
public Object assetOwner
public TrackAsset targetTrack
public AnimationClip get_curves()
public bool get_hasCurves()
public double get_duration()
public void CreateCurves(string curvesClipName)
public string get_defaultCurvesName()
public Object get_asset()
public Object get_assetOwner()
public TrackAsset get_targetTrack()
}
internal UnityEngine.Timeline.IInterval {
public long intervalStart
public long intervalEnd
public long get_intervalStart()
public long get_intervalEnd()
}
public UnityEngine.Timeline.ILayerable {
public Playable CreateLayerMixer(PlayableGraph graph, GameObject go, int inputCount)
}
public UnityEngine.Timeline.IMarker {
public double time
public TrackAsset parent
public double get_time()
public void set_time(double value)
public TrackAsset get_parent()
public void Initialize(TrackAsset parent)
}
internal UnityEngine.Timeline.InfiniteRuntimeClip : RuntimeElement {
private Playable m_Playable
private long kIntervalEnd
public long intervalStart
public long intervalEnd
public bool enable
public void .ctor(Playable playable)
public long get_intervalStart()
public long get_intervalEnd()
public void set_enable(bool value)
public void EvaluateAt(double localTime, FrameData frameData)
public void DisableAt(double localTime, double rootDuration, FrameData frameData)
}
public UnityEngine.Timeline.INotificationOptionProvider {
public NotificationFlags flags
public NotificationFlags get_flags()
}
internal UnityEngine.Timeline.IntervalTree`1 : object {
private int kMinNodeSize
private int kInvalidNode
private long kCenterUnknown
private List`1<Entry<T>> m_Entries
private List`1<IntervalTreeNode> m_Nodes
private bool <dirty>k__BackingField
public bool dirty
public bool get_dirty()
internal void set_dirty(bool value)
public void Add(T item)
public void IntersectsWith(long value, List`1<T> results)
public void IntersectsWithRange(long start, long end, List`1<T> results)
public void UpdateIntervals()
private void Query(IntervalTreeNode intervalTreeNode, long value, List`1<T> results)
private void QueryRange(IntervalTreeNode intervalTreeNode, long start, long end, List`1<T> results)
private void Rebuild()
private int Rebuild(int start, int end)
public void Clear()
}
internal UnityEngine.Timeline.IntervalTreeNode : ValueType {
public long center
public int first
public int last
public int left
public int right
}
public UnityEngine.Timeline.IPropertyCollector {
public void PushActiveGameObject(GameObject gameObject)
public void PopActiveGameObject()
public void AddFromClip(AnimationClip clip)
public void AddFromClips(IEnumerable`1<AnimationClip> clips)
public void AddFromName(string name)
public void AddFromName(string name)
public void AddFromClip(GameObject obj, AnimationClip clip)
public void AddFromClips(GameObject obj, IEnumerable`1<AnimationClip> clips)
public void AddFromName(GameObject obj, string name)
public void AddFromName(GameObject obj, string name)
public void AddFromName(Component component, string name)
public void AddFromComponent(GameObject obj, Component component)
public void AddObjectProperties(Object obj, AnimationClip clip)
}
public UnityEngine.Timeline.IPropertyPreview {
public void GatherProperties(PlayableDirector director, IPropertyCollector driver)
}
public UnityEngine.Timeline.ITimeControl {
public void SetTime(double time)
public void OnControlTimeStart()
public void OnControlTimeStop()
}
public UnityEngine.Timeline.ITimelineClipAsset {
public ClipCaps clipCaps
public ClipCaps get_clipCaps()
}
internal UnityEngine.Timeline.ITimelineEvaluateCallback {
public void Evaluate()
}
public UnityEngine.Timeline.Marker : ScriptableObject {
private double m_Time
private TrackAsset <parent>k__BackingField
public TrackAsset parent
public double time
public TrackAsset get_parent()
private void set_parent(TrackAsset value)
public double get_time()
public void set_time(double value)
private void UnityEngine.Timeline.IMarker.Initialize(TrackAsset parentTrack)
public void OnInitialize(TrackAsset aPent)
}
internal UnityEngine.Timeline.MarkerList : ValueType {
private List`1<ScriptableObject> m_Objects
private List`1<IMarker> m_Cache
private bool m_CacheDirty
private bool m_HasNotifications
public List`1<IMarker> markers
public int Count
public IMarker Item
public List`1<IMarker> get_markers()
public void .ctor(int capacity)
public void Add(ScriptableObject item)
public bool Remove(IMarker item)
public bool Remove(ScriptableObject item, TimelineAsset timelineAsset, PlayableAsset thingToDirty)
public void Clear()
public bool Contains(ScriptableObject item)
public IEnumerable`1<IMarker> GetMarkers()
public int get_Count()
public IMarker get_Item(int idx)
public List`1<ScriptableObject> GetRawMarkerList()
public IMarker CreateMarker(Type type, double time, TrackAsset owner)
public bool HasNotifications()
private void UnityEngine.ISerializationCallbackReceiver.OnBeforeSerialize()
private void UnityEngine.ISerializationCallbackReceiver.OnAfterDeserialize()
private void BuildCache()
}
public UnityEngine.Timeline.MarkerTrack : TrackAsset {
public IEnumerable`1<PlayableBinding> outputs
public IEnumerable`1<PlayableBinding> get_outputs()
}
internal UnityEngine.Timeline.MatchTargetFieldConstants : object {
public MatchTargetFields All
public MatchTargetFields None
public MatchTargetFields Position
public MatchTargetFields Rotation
public bool HasAny(MatchTargetFields me, MatchTargetFields fields)
public MatchTargetFields Toggle(MatchTargetFields me, MatchTargetFields flag)
}
public UnityEngine.Timeline.MatchTargetFields : Enum {
public int value__
public MatchTargetFields PositionX
public MatchTargetFields PositionY
public MatchTargetFields PositionZ
public MatchTargetFields RotationX
public MatchTargetFields RotationY
public MatchTargetFields RotationZ
}
internal UnityEngine.Timeline.MenuCategoryAttribute : Attribute {
public string category
public void .ctor(string category)
}
public UnityEngine.Timeline.NotificationFlags : Enum {
public short value__
public NotificationFlags TriggerInEditMode
public NotificationFlags Retroactive
public NotificationFlags TriggerOnce
}
internal UnityEngine.Timeline.NotificationUtilities : object {
public ScriptPlayable`1<TimeNotificationBehaviour> CreateNotificationsPlayable(PlayableGraph graph, IEnumerable`1<IMarker> markers, GameObject go)
public bool TrackTypeSupportsNotifications(Type type)
}
public UnityEngine.Timeline.ParticleControlPlayable : PlayableBehaviour {
private float kUnsetTime
private float m_LastPlayableTime
private float m_LastParticleTime
private UInt32 m_RandomSeed
private ParticleSystem <particleSystem>k__BackingField
public ParticleSystem particleSystem
public ScriptPlayable`1<ParticleControlPlayable> Create(PlayableGraph graph, ParticleSystem component, UInt32 randomSeed)
public ParticleSystem get_particleSystem()
private void set_particleSystem(ParticleSystem value)
public void Initialize(ParticleSystem ps, UInt32 randomSeed)
private void SetRandomSeed(ParticleSystem particleSystem, UInt32 randomSeed)
public void PrepareFrame(Playable playable, FrameData data)
public void OnBehaviourPlay(Playable playable, FrameData info)
public void OnBehaviourPause(Playable playable, FrameData info)
private void Simulate(float time, bool restart)
}
public UnityEngine.Timeline.PlayableTrack : TrackAsset {
protected void OnCreateClip(TimelineClip clip)
}
public UnityEngine.Timeline.PrefabControlPlayable : PlayableBehaviour {
private GameObject m_Instance
public GameObject prefabInstance
public ScriptPlayable`1<PrefabControlPlayable> Create(PlayableGraph graph, GameObject prefabGameObject, Transform parentTransform)
public GameObject get_prefabInstance()
public GameObject Initialize(GameObject prefabGameObject, Transform parentTransform)
public void OnPlayableDestroy(Playable playable)
public void OnBehaviourPlay(Playable playable, FrameData info)
public void OnBehaviourPause(Playable playable, FrameData info)
private void SetHideFlagsRecursive(GameObject gameObject)
}
internal UnityEngine.Timeline.RuntimeClip : RuntimeClipBase {
private TimelineClip m_Clip
private Playable m_Playable
private Playable m_ParentMixer
public double start
public double duration
public TimelineClip clip
public Playable mixer
public Playable playable
public bool enable
public double get_start()
public double get_duration()
public void .ctor(TimelineClip clip, Playable clipPlayable, Playable parentMixer)
private void Create(TimelineClip clip, Playable clipPlayable, Playable parentMixer)
public TimelineClip get_clip()
public Playable get_mixer()
public Playable get_playable()
public void set_enable(bool value)
public void SetTime(double time)
public void SetDuration(double duration)
public void EvaluateAt(double localTime, FrameData frameData)
public void DisableAt(double localTime, double rootDuration, FrameData frameData)
}
internal UnityEngine.Timeline.RuntimeClipBase : RuntimeElement {
public double start
public double duration
public long intervalStart
public long intervalEnd
public double get_start()
public double get_duration()
public long get_intervalStart()
public long get_intervalEnd()
}
internal UnityEngine.Timeline.RuntimeElement : object {
private int <intervalBit>k__BackingField
public long intervalStart
public long intervalEnd
public int intervalBit
public bool enable
public long get_intervalStart()
public long get_intervalEnd()
public int get_intervalBit()
public void set_intervalBit(int value)
public void set_enable(bool value)
public void EvaluateAt(double localTime, FrameData frameData)
public void DisableAt(double localTime, double rootDuration, FrameData frameData)
}
internal UnityEngine.Timeline.ScheduleRuntimeClip : RuntimeClipBase {
private TimelineClip m_Clip
private Playable m_Playable
private Playable m_ParentMixer
private double m_StartDelay
private double m_FinishTail
private bool m_Started
public double start
public double duration
public TimelineClip clip
public Playable mixer
public Playable playable
public bool enable
public double get_start()
public double get_duration()
public void SetTime(double time)
public TimelineClip get_clip()
public Playable get_mixer()
public Playable get_playable()
public void .ctor(TimelineClip clip, Playable clipPlayable, Playable parentMixer, double startDelay, double finishTail)
private void Create(TimelineClip clip, Playable clipPlayable, Playable parentMixer, double startDelay, double finishTail)
public void set_enable(bool value)
public void EvaluateAt(double localTime, FrameData frameData)
public void DisableAt(double localTime, double rootDuration, FrameData frameData)
}
public UnityEngine.Timeline.SignalAsset : ScriptableObject {
private Action`1<SignalAsset> OnEnableCallback
internal void add_OnEnableCallback(Action`1<SignalAsset> value)
internal void remove_OnEnableCallback(Action`1<SignalAsset> value)
private void OnEnable()
}
public UnityEngine.Timeline.SignalEmitter : Marker {
private bool m_Retroactive
private bool m_EmitOnce
private SignalAsset m_Asset
public bool retroactive
public bool emitOnce
public SignalAsset asset
private PropertyName UnityEngine.Playables.INotification.id
private NotificationFlags UnityEngine.Timeline.INotificationOptionProvider.flags
public bool get_retroactive()
public void set_retroactive(bool value)
public bool get_emitOnce()
public void set_emitOnce(bool value)
public SignalAsset get_asset()
public void set_asset(SignalAsset value)
private PropertyName UnityEngine.Playables.INotification.get_id()
private NotificationFlags UnityEngine.Timeline.INotificationOptionProvider.get_flags()
}
public UnityEngine.Timeline.SignalReceiver : MonoBehaviour {
private EventKeyValue m_Events
public void OnNotify(Playable origin, INotification notification, object context)
public void AddReaction(SignalAsset asset, UnityEvent reaction)
public int AddEmptyReaction(UnityEvent reaction)
public void Remove(SignalAsset asset)
public IEnumerable`1<SignalAsset> GetRegisteredSignals()
public UnityEvent GetReaction(SignalAsset key)
public int Count()
public void ChangeSignalAtIndex(int idx, SignalAsset newKey)
public void RemoveAtIndex(int idx)
public void ChangeReactionAtIndex(int idx, UnityEvent reaction)
public UnityEvent GetReactionAtIndex(int idx)
public SignalAsset GetSignalAssetAtIndex(int idx)
private void OnEnable()
}
public UnityEngine.Timeline.StandardFrameRates : Enum {
public int value__
public StandardFrameRates Fps24
public StandardFrameRates Fps23_97
public StandardFrameRates Fps25
public StandardFrameRates Fps30
public StandardFrameRates Fps29_97
public StandardFrameRates Fps50
public StandardFrameRates Fps60
public StandardFrameRates Fps59_94
}
internal UnityEngine.Timeline.SupportsChildTracksAttribute : Attribute {
public Type childType
public int levels
public void .ctor(Type childType, int levels)
}
public UnityEngine.Timeline.TimeControlPlayable : PlayableBehaviour {
private ITimeControl m_timeControl
private bool m_started
public ScriptPlayable`1<TimeControlPlayable> Create(PlayableGraph graph, ITimeControl timeControl)
public void Initialize(ITimeControl timeControl)
public void PrepareFrame(Playable playable, FrameData info)
public void OnBehaviourPlay(Playable playable, FrameData info)
public void OnBehaviourPause(Playable playable, FrameData info)
}
internal UnityEngine.Timeline.TimeFieldAttribute : PropertyAttribute {
private UseEditMode <useEditMode>k__BackingField
public UseEditMode useEditMode
public UseEditMode get_useEditMode()
public void .ctor(UseEditMode useEditMode)
}
public UnityEngine.Timeline.TimelineAsset : PlayableAsset {
private int k_LatestVersion
private int m_Version
private List`1<ScriptableObject> m_Tracks
private double m_FixedDuration
private TrackAsset[] m_CacheOutputTracks
private List`1<TrackAsset> m_CacheRootTracks
private TrackAsset[] m_CacheFlattenedTracks
private EditorSettings m_EditorSettings
private DurationMode m_DurationMode
private MarkerTrack m_MarkerTrack
public EditorSettings editorSettings
public double duration
public double fixedDuration
public DurationMode durationMode
public IEnumerable`1<PlayableBinding> outputs
public ClipCaps clipCaps
public int outputTrackCount
public int rootTrackCount
internal TrackAsset[] flattenedTracks
public MarkerTrack markerTrack
internal List`1<ScriptableObject> trackObjects
private void UpgradeToLatestVersion()
public EditorSettings get_editorSettings()
public double get_duration()
public double get_fixedDuration()
public void set_fixedDuration(double value)
public DurationMode get_durationMode()
public void set_durationMode(DurationMode value)
public IEnumerable`1<PlayableBinding> get_outputs()
public ClipCaps get_clipCaps()
public int get_outputTrackCount()
public int get_rootTrackCount()
private void OnValidate()
public TrackAsset GetRootTrack(int index)
public IEnumerable`1<TrackAsset> GetRootTracks()
public TrackAsset GetOutputTrack(int index)
public IEnumerable`1<TrackAsset> GetOutputTracks()
private double GetValidFrameRate(double frameRate)
private void UpdateRootTrackCache()
private void UpdateOutputTrackCache()
internal TrackAsset[] get_flattenedTracks()
public MarkerTrack get_markerTrack()
internal List`1<ScriptableObject> get_trackObjects()
internal void AddTrackInternal(TrackAsset track)
internal void RemoveTrack(TrackAsset track)
public Playable CreatePlayable(PlayableGraph graph, GameObject go)
private void UnityEngine.ISerializationCallbackReceiver.OnBeforeSerialize()
private void UnityEngine.ISerializationCallbackReceiver.OnAfterDeserialize()
private void __internalAwake()
public void GatherProperties(PlayableDirector director, IPropertyCollector driver)
public void CreateMarkerTrack()
internal void Invalidate()
internal void UpdateFixedDurationWithItemsDuration()
private DiscreteTime CalculateItemsDuration()
private void AddSubTracksRecursive(TrackAsset track, List`1& allTracks)
public TrackAsset CreateTrack(Type type, TrackAsset parent, string name)
public T CreateTrack(TrackAsset parent, string trackName)
public T CreateTrack(string trackName)
public T CreateTrack()
public bool DeleteClip(TimelineClip clip)
public bool DeleteTrack(TrackAsset track)
internal void MoveLastTrackBefore(TrackAsset asset)
internal TrackAsset AllocateTrack(TrackAsset trackAssetParent, string trackName, Type trackType)
private void DeleteRecordedAnimation(TrackAsset track)
private void DeleteRecordedAnimation(TimelineClip clip)
}
public UnityEngine.Timeline.TimelineClip : object {
private int k_LatestVersion
private int m_Version
public ClipCaps kDefaultClipCaps
public float kDefaultClipDurationInSeconds
public double kTimeScaleMin
public double kTimeScaleMax
internal string kDefaultCurvesName
internal double kMinDuration
internal double kMaxTimeValue
private double m_Start
private double m_ClipIn
private Object m_Asset
private double m_Duration
private double m_TimeScale
private TrackAsset m_ParentTrack
private double m_EaseInDuration
private double m_EaseOutDuration
private double m_BlendInDuration
private double m_BlendOutDuration
private AnimationCurve m_MixInCurve
private AnimationCurve m_MixOutCurve
private BlendCurveMode m_BlendInCurveMode
private BlendCurveMode m_BlendOutCurveMode
private List`1<string> m_ExposedParameterNames
private AnimationClip m_AnimationCurves
private bool m_Recordable
private ClipExtrapolation m_PostExtrapolationMode
private ClipExtrapolation m_PreExtrapolationMode
private double m_PostExtrapolationTime
private double m_PreExtrapolationTime
private string m_DisplayName
public bool hasPreExtrapolation
public bool hasPostExtrapolation
public double timeScale
public double start
public double duration
public double end
public double clipIn
public string displayName
public double clipAssetDuration
public AnimationClip curves
private string UnityEngine.Timeline.ICurvesOwner.defaultCurvesName
public bool hasCurves
public Object asset
private Object UnityEngine.Timeline.ICurvesOwner.assetOwner
private TrackAsset UnityEngine.Timeline.ICurvesOwner.targetTrack
public Object underlyingAsset
public TrackAsset parentTrack
public double easeInDuration
public double easeOutDuration
public double eastOutTime
public double easeOutTime
public double blendInDuration
public double blendOutDuration
public BlendCurveMode blendInCurveMode
public BlendCurveMode blendOutCurveMode
public bool hasBlendIn
public bool hasBlendOut
public AnimationCurve mixInCurve
public float mixInPercentage
public double mixInDuration
public AnimationCurve mixOutCurve
public double mixOutTime
public double mixOutDuration
public float mixOutPercentage
public bool recordable
public List`1<string> exposedParameters
public ClipCaps clipCaps
public AnimationClip animationClip
public ClipExtrapolation postExtrapolationMode
public ClipExtrapolation preExtrapolationMode
public double extrapolatedStart
public double extrapolatedDuration
private void UpgradeToLatestVersion()
internal void .ctor(TrackAsset parent)
public bool get_hasPreExtrapolation()
public bool get_hasPostExtrapolation()
public double get_timeScale()
public void set_timeScale(double value)
public double get_start()
public void set_start(double value)
public double get_duration()
public void set_duration(double value)
public double get_end()
public double get_clipIn()
public void set_clipIn(double value)
public string get_displayName()
public void set_displayName(string value)
public double get_clipAssetDuration()
public AnimationClip get_curves()
internal void set_curves(AnimationClip value)
private string UnityEngine.Timeline.ICurvesOwner.get_defaultCurvesName()
public bool get_hasCurves()
public Object get_asset()
public void set_asset(Object value)
private Object UnityEngine.Timeline.ICurvesOwner.get_assetOwner()
private TrackAsset UnityEngine.Timeline.ICurvesOwner.get_targetTrack()
public Object get_underlyingAsset()
public void set_underlyingAsset(Object value)
public TrackAsset get_parentTrack()
public void set_parentTrack(TrackAsset value)
public TrackAsset GetParentTrack()
internal void SetParentTrack_Internal(TrackAsset newParentTrack)
public double get_easeInDuration()
public void set_easeInDuration(double value)
public double get_easeOutDuration()
public void set_easeOutDuration(double value)
public double get_eastOutTime()
public double get_easeOutTime()
public double get_blendInDuration()
public void set_blendInDuration(double value)
public double get_blendOutDuration()
public void set_blendOutDuration(double value)
public BlendCurveMode get_blendInCurveMode()
public void set_blendInCurveMode(BlendCurveMode value)
public BlendCurveMode get_blendOutCurveMode()
public void set_blendOutCurveMode(BlendCurveMode value)
public bool get_hasBlendIn()
public bool get_hasBlendOut()
public AnimationCurve get_mixInCurve()
public void set_mixInCurve(AnimationCurve value)
public float get_mixInPercentage()
public double get_mixInDuration()
public AnimationCurve get_mixOutCurve()
public void set_mixOutCurve(AnimationCurve value)
public double get_mixOutTime()
public double get_mixOutDuration()
public float get_mixOutPercentage()
public bool get_recordable()
internal void set_recordable(bool value)
public List`1<string> get_exposedParameters()
public ClipCaps get_clipCaps()
internal int Hash()
public float EvaluateMixOut(double time)
public float EvaluateMixIn(double time)
private AnimationCurve GetDefaultMixInCurve()
private AnimationCurve GetDefaultMixOutCurve()
public double ToLocalTime(double time)
public double ToLocalTimeUnbound(double time)
internal double FromLocalTimeUnbound(double time)
public AnimationClip get_animationClip()
private double SanitizeTimeValue(double value, double defaultValue)
public ClipExtrapolation get_postExtrapolationMode()
internal void set_postExtrapolationMode(ClipExtrapolation value)
public ClipExtrapolation get_preExtrapolationMode()
internal void set_preExtrapolationMode(ClipExtrapolation value)
internal void SetPostExtrapolationTime(double time)
internal void SetPreExtrapolationTime(double time)
public bool IsExtrapolatedTime(double sequenceTime)
public bool IsPreExtrapolatedTime(double sequenceTime)
public bool IsPostExtrapolatedTime(double sequenceTime)
public double get_extrapolatedStart()
public double get_extrapolatedDuration()
private double GetExtrapolatedTime(double time, ClipExtrapolation mode, double duration)
public void CreateCurves(string curvesClipName)
private void UnityEngine.ISerializationCallbackReceiver.OnBeforeSerialize()
private void UnityEngine.ISerializationCallbackReceiver.OnAfterDeserialize()
public string ToString()
public void ConformEaseValues()
private double CalculateEasingRatio(double easeIn, double easeOut)
private void UpdateDirty(double oldValue, double newValue)
}
internal UnityEngine.Timeline.TimelineClipCapsExtensions : object {
public bool SupportsLooping(TimelineClip clip)
public bool SupportsExtrapolation(TimelineClip clip)
public bool SupportsClipIn(TimelineClip clip)
public bool SupportsSpeedMultiplier(TimelineClip clip)
public bool SupportsBlending(TimelineClip clip)
public bool HasAll(ClipCaps caps, ClipCaps flags)
public bool HasAny(ClipCaps caps, ClipCaps flags)
}
public UnityEngine.Timeline.TimelineClipExtensions : object {
private string k_UndoSetParentTrackText
public void MoveToTrack(TimelineClip clip, TrackAsset destinationTrack)
public bool TryMoveToTrack(TimelineClip clip, TrackAsset destinationTrack)
private void MoveToTrack_Impl(TimelineClip clip, TrackAsset destinationTrack, Object asset, TrackAsset parentTrack)
}
internal UnityEngine.Timeline.TimelineCreateUtilities : object {
public string GenerateUniqueActorName(List`1<ScriptableObject> tracks, string name)
public void SaveAssetIntoObject(Object childAsset, Object masterAsset)
public void RemoveAssetFromObject(Object childAsset, Object masterAsset)
public AnimationClip CreateAnimationClipForTrack(string name, TrackAsset track, bool isLegacy)
public bool ValidateParentTrack(TrackAsset parent, Type childType)
}
internal UnityEngine.Timeline.TimelineHelpURLAttribute : Attribute {
public void .ctor(Type type)
}
public UnityEngine.Timeline.TimelinePlayable : PlayableBehaviour {
private IntervalTree`1<RuntimeElement> m_IntervalTree
private List`1<RuntimeElement> m_ActiveClips
private List`1<RuntimeElement> m_CurrentListOfActiveClips
private int m_ActiveBit
private List`1<ITimelineEvaluateCallback> m_EvaluateCallbacks
private Dictionary`2<TrackAsset, Playable> m_PlayableCache
internal bool muteAudioScrubbing
public ScriptPlayable`1<TimelinePlayable> Create(PlayableGraph graph, IEnumerable`1<TrackAsset> tracks, GameObject go, bool autoRebalance, bool createOutputs)
public void Compile(PlayableGraph graph, Playable timelinePlayable, IEnumerable`1<TrackAsset> tracks, GameObject go, bool autoRebalance, bool createOutputs)
private void CompileTrackList(PlayableGraph graph, Playable timelinePlayable, IEnumerable`1<TrackAsset> tracks, GameObject go, bool createOutputs)
private void CreateTrackOutput(PlayableGraph graph, TrackAsset track, GameObject go, Playable playable, int port)
private void EvaluateWeightsForAnimationPlayableOutput(TrackAsset track, AnimationPlayableOutput animOutput)
private void EvaluateAnimationPreviewUpdateCallback(TrackAsset track, AnimationPlayableOutput animOutput)
private Playable CreateTrackPlayable(PlayableGraph graph, Playable timelinePlayable, TrackAsset track, GameObject go, bool createOutputs)
public void PrepareFrame(Playable playable, FrameData info)
private void Evaluate(Playable playable, FrameData frameData)
private void CacheTrack(TrackAsset track, Playable playable, int port, Playable parent)
private void ForAOTCompilationOnly()
}
internal UnityEngine.Timeline.TimelineUndo : object {
public void PushDestroyUndo(TimelineAsset timeline, Object thingToDirty, Object objectToDestroy)
public void PushUndo(Object[] thingsToDirty, string operation)
public void PushUndo(Object thingToDirty, string operation)
public void RegisterCreatedObjectUndo(Object thingCreated, string operation)
private string UndoName(string name)
}
public UnityEngine.Timeline.TimeNotificationBehaviour : PlayableBehaviour {
private List`1<NotificationEntry> m_Notifications
private double m_PreviousTime
private bool m_NeedSortNotifications
private Playable m_TimeSource
public Playable timeSource
public void set_timeSource(Playable value)
public ScriptPlayable`1<TimeNotificationBehaviour> Create(PlayableGraph graph, double duration, DirectorWrapMode loopMode)
public void AddNotification(double time, INotification payload, NotificationFlags flags)
public void OnGraphStart(Playable playable)
public void OnBehaviourPause(Playable playable, FrameData info)
public void PrepareFrame(Playable playable, FrameData info)
private void SortNotifications()
private bool CanRestoreNotification(NotificationEntry e, FrameData info, double currentTime, double previousTime)
private void TriggerNotificationsInRange(double start, double end, FrameData info, Playable playable, bool checkState)
private void SyncDurationWithExternalSource(Playable playable)
private void Trigger_internal(Playable playable, PlayableOutput output, NotificationEntry& e)
private void Restore_internal(NotificationEntry& e)
}
internal UnityEngine.Timeline.TimeUtility : object {
public double kTimeEpsilon
public double kFrameRateEpsilon
public double k_MaxTimelineDurationInSeconds
public double kFrameRateRounding
private void ValidateFrameRate(double frameRate)
public int ToFrames(double time, double frameRate)
public double ToExactFrames(double time, double frameRate)
public double FromFrames(int frames, double frameRate)
public double FromFrames(double frames, double frameRate)
public bool OnFrameBoundary(double time, double frameRate)
public double GetEpsilon(double time, double frameRate)
public bool OnFrameBoundary(double time, double frameRate, double epsilon)
public double RoundToFrame(double time, double frameRate)
public string TimeAsFrames(double timeValue, double frameRate, string format)
public string TimeAsTimeCode(double timeValue, double frameRate, string format)
public double ParseTimeCode(string timeCode, double frameRate, double defaultValue)
public double ParseTimeSeconds(string timeCode, double frameRate, double defaultValue)
public double GetAnimationClipLength(AnimationClip clip)
private string RemoveChar(string str, Func`2<char, bool> charToRemoveFunc)
public FrameRate GetClosestFrameRate(double frameRate)
public FrameRate ToFrameRate(StandardFrameRates enumValue)
internal bool ToStandardFrameRate(FrameRate rate, StandardFrameRates& standard)
}
public UnityEngine.Timeline.TrackAsset : PlayableAsset {
private int k_LatestVersion
private int m_Version
internal AnimationClip m_AnimClip
private TransientBuildData s_BuildData
internal string kDefaultCurvesName
private Action`3<TimelineClip, GameObject, Playable> OnClipPlayableCreate
private Action`3<TrackAsset, GameObject, Playable> OnTrackAnimationPlayableCreate
private bool m_Locked
private bool m_Muted
private string m_CustomPlayableFullTypename
private AnimationClip m_Curves
private PlayableAsset m_Parent
private List`1<ScriptableObject> m_Children
private int m_ItemsHash
private TimelineClip[] m_ClipsCache
private DiscreteTime m_Start
private DiscreteTime m_End
private bool m_CacheSorted
private Nullable`1<bool> m_SupportsNotifications
private TrackAsset[] s_EmptyCache
private IEnumerable`1<TrackAsset> m_ChildTrackCache
private Dictionary`2<Type, TrackBindingTypeAttribute> s_TrackBindingTypeAttributeCache
protected internal List`1<TimelineClip> m_Clips
private MarkerList m_Markers
public double start
public double end
public double duration
public bool muted
public bool mutedInHierarchy
public TimelineAsset timelineAsset
public PlayableAsset parent
internal TimelineClip[] clips
public bool isEmpty
public bool hasClips
public bool hasCurves
public bool isSubTrack
public IEnumerable`1<PlayableBinding> outputs
internal string customPlayableTypename
public AnimationClip curves
private string UnityEngine.Timeline.ICurvesOwner.defaultCurvesName
private Object UnityEngine.Timeline.ICurvesOwner.asset
private Object UnityEngine.Timeline.ICurvesOwner.assetOwner
private TrackAsset UnityEngine.Timeline.ICurvesOwner.targetTrack
internal List`1<ScriptableObject> subTracksObjects
public bool locked
public bool lockedInHierarchy
public bool supportsNotifications
protected void OnBeforeTrackSerialize()
protected void OnAfterTrackDeserialize()
internal void OnUpgradeFromVersion(int oldVersion)
private void UnityEngine.ISerializationCallbackReceiver.OnBeforeSerialize()
private void UnityEngine.ISerializationCallbackReceiver.OnAfterDeserialize()
private void UpgradeToLatestVersion()
internal void add_OnClipPlayableCreate(Action`3<TimelineClip, GameObject, Playable> value)
internal void remove_OnClipPlayableCreate(Action`3<TimelineClip, GameObject, Playable> value)
internal void add_OnTrackAnimationPlayableCreate(Action`3<TrackAsset, GameObject, Playable> value)
internal void remove_OnTrackAnimationPlayableCreate(Action`3<TrackAsset, GameObject, Playable> value)
public double get_start()
public double get_end()
public double get_duration()
public bool get_muted()
public void set_muted(bool value)
public bool get_mutedInHierarchy()
public TimelineAsset get_timelineAsset()
public PlayableAsset get_parent()
internal void set_parent(PlayableAsset value)
public IEnumerable`1<TimelineClip> GetClips()
internal TimelineClip[] get_clips()
public bool get_isEmpty()
public bool get_hasClips()
public bool get_hasCurves()
public bool get_isSubTrack()
public IEnumerable`1<PlayableBinding> get_outputs()
public IEnumerable`1<TrackAsset> GetChildTracks()
internal string get_customPlayableTypename()
internal void set_customPlayableTypename(string value)
public AnimationClip get_curves()
internal void set_curves(AnimationClip value)
private string UnityEngine.Timeline.ICurvesOwner.get_defaultCurvesName()
private Object UnityEngine.Timeline.ICurvesOwner.get_asset()
private Object UnityEngine.Timeline.ICurvesOwner.get_assetOwner()
private TrackAsset UnityEngine.Timeline.ICurvesOwner.get_targetTrack()
internal List`1<ScriptableObject> get_subTracksObjects()
public bool get_locked()
public void set_locked(bool value)
public bool get_lockedInHierarchy()
public bool get_supportsNotifications()
private void __internalAwake()
public void CreateCurves(string curvesClipName)
public Playable CreateTrackMixer(PlayableGraph graph, GameObject go, int inputCount)
public Playable CreatePlayable(PlayableGraph graph, GameObject go)
public TimelineClip CreateDefaultClip()
public TimelineClip CreateClip()
public bool DeleteClip(TimelineClip clip)
public IMarker CreateMarker(Type type, double time)
public T CreateMarker(double time)
public bool DeleteMarker(IMarker marker)
public IEnumerable`1<IMarker> GetMarkers()
public int GetMarkerCount()
public IMarker GetMarker(int idx)
internal TimelineClip CreateClip(Type requestedType)
internal TimelineClip CreateAndAddNewClipOfType(Type requestedType)
internal TimelineClip CreateClipOfType(Type requestedType)
internal TimelineClip CreateClipFromPlayableAsset(IPlayableAsset asset)
private TimelineClip CreateClipFromAsset(ScriptableObject playableAsset)
internal IEnumerable`1<ScriptableObject> GetMarkersRaw()
internal void ClearMarkers()
internal void AddMarker(ScriptableObject e)
internal bool DeleteMarkerRaw(ScriptableObject marker)
private int GetTimeRangeHash()
internal void AddClip(TimelineClip newClip)
private Playable CreateNotificationsPlayable(PlayableGraph graph, Playable mixerPlayable, GameObject go, Playable timelinePlayable)
internal Playable CreatePlayableGraph(PlayableGraph graph, GameObject go, IntervalTree`1<RuntimeElement> tree, Playable timelinePlayable)
internal Playable CompileClips(PlayableGraph graph, GameObject go, IList`1<TimelineClip> timelineClips, IntervalTree`1<RuntimeElement> tree)
private void GatherCompilableTracks(IList`1<TrackAsset> tracks)
private void GatherNotifications(List`1<IMarker> markers)
internal Playable CreateMixerPlayableGraph(PlayableGraph graph, GameObject go, IntervalTree`1<RuntimeElement> tree)
internal void ConfigureTrackAnimation(IntervalTree`1<RuntimeElement> tree, GameObject go, Playable blend)
internal void SortClips()
internal void ClearClipsInternal()
internal void ClearSubTracksInternal()
internal void OnClipMove()
internal TimelineClip CreateNewClipContainerInternal()
internal void AddChild(TrackAsset child)
internal void MoveLastTrackBefore(TrackAsset asset)
internal bool RemoveSubTrack(TrackAsset child)
internal void RemoveClip(TimelineClip clip)
internal void GetEvaluationTime(Double& outStart, Double& outDuration)
internal void GetSequenceTime(Double& outStart, Double& outDuration)
public void GatherProperties(PlayableDirector director, IPropertyCollector driver)
internal GameObject GetGameObjectBinding(PlayableDirector director)
internal bool ValidateClipType(Type clipType)
protected void OnCreateClip(TimelineClip clip)
private void UpdateDuration()
protected internal int CalculateItemsHash()
protected Playable CreatePlayable(PlayableGraph graph, GameObject gameObject, TimelineClip clip)
internal void Invalidate()
internal double GetNotificationDuration()
internal bool CanCompileClips()
public bool CanCreateTrackMixer()
internal bool IsCompilable()
private void UpdateChildTrackCache()
internal int Hash()
private int GetClipsHash()
protected int GetAnimationClipHash(AnimationClip clip)
private bool HasNotifications()
private bool CanCompileNotifications()
private bool CanCreateMixerRecursive()
}
public UnityEngine.Timeline.TrackAssetExtensions : object {
public GroupTrack GetGroup(TrackAsset asset)
public void SetGroup(TrackAsset asset, GroupTrack group)
}
public UnityEngine.Timeline.TrackBindingFlags : Enum {
public int value__
public TrackBindingFlags None
public TrackBindingFlags AllowCreateComponent
public TrackBindingFlags All
}
public UnityEngine.Timeline.TrackBindingTypeAttribute : Attribute {
public Type type
public TrackBindingFlags flags
public void .ctor(Type type)
public void .ctor(Type type, TrackBindingFlags flags)
}
public UnityEngine.Timeline.TrackClipTypeAttribute : Attribute {
public Type inspectedType
public bool allowAutoCreate
public void .ctor(Type clipClass)
public void .ctor(Type clipClass, bool allowAutoCreate)
}
public UnityEngine.Timeline.TrackColorAttribute : Attribute {
private Color m_Color
public Color color
public Color get_color()
public void .ctor(float r, float g, float b)
}
public UnityEngine.Timeline.TrackMediaType : Attribute {
public MediaType m_MediaType
public void .ctor(MediaType mt)
}
public UnityEngine.Timeline.TrackOffset : Enum {
public int value__
public TrackOffset ApplyTransformOffsets
public TrackOffset ApplySceneOffsets
public TrackOffset Auto
}
internal UnityEngine.Timeline.WeightUtility : object {
public float NormalizeMixer(Playable mixer)
}
