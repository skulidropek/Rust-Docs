internal Newtonsoft.Json.Bson.BsonArray : BsonToken {
private List`1<BsonToken> _children
public BsonType Type
public void Add(BsonToken token)
public BsonType get_Type()
public IEnumerator`1<BsonToken> GetEnumerator()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
}
internal Newtonsoft.Json.Bson.BsonBinary : BsonValue {
private BsonBinaryType <BinaryType>k__BackingField
public BsonBinaryType BinaryType
public BsonBinaryType get_BinaryType()
public void set_BinaryType(BsonBinaryType value)
public void .ctor(Byte[] value, BsonBinaryType binaryType)
}
internal Newtonsoft.Json.Bson.BsonBinaryType : Enum {
public byte value__
public BsonBinaryType Binary
public BsonBinaryType Function
public BsonBinaryType BinaryOld
public BsonBinaryType UuidOld
public BsonBinaryType Uuid
public BsonBinaryType Md5
public BsonBinaryType UserDefined
}
internal Newtonsoft.Json.Bson.BsonBinaryWriter : object {
private Encoding Encoding
private BinaryWriter _writer
private Byte[] _largeByteBuffer
private DateTimeKind <DateTimeKindHandling>k__BackingField
public DateTimeKind DateTimeKindHandling
public DateTimeKind get_DateTimeKindHandling()
public void set_DateTimeKindHandling(DateTimeKind value)
public void .ctor(BinaryWriter writer)
public void Flush()
public void Close()
public void WriteToken(BsonToken t)
private void WriteTokenInternal(BsonToken t)
private void WriteString(string s, int byteCount, Nullable`1<int> calculatedlengthPrefix)
public void WriteUtf8Bytes(string s, int byteCount)
private int CalculateSize(int stringByteCount)
private int CalculateSizeWithLength(int stringByteCount, bool includeSize)
private int CalculateSize(BsonToken t)
}
internal Newtonsoft.Json.Bson.BsonObject : BsonToken {
private List`1<BsonProperty> _children
public BsonType Type
public void Add(string name, BsonToken token)
public BsonType get_Type()
public IEnumerator`1<BsonProperty> GetEnumerator()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
}
public Newtonsoft.Json.Bson.BsonObjectId : object {
private Byte[] <Value>k__BackingField
public Byte[] Value
public Byte[] get_Value()
private void set_Value(Byte[] value)
public void .ctor(Byte[] value)
}
internal Newtonsoft.Json.Bson.BsonProperty : object {
private BsonString <Name>k__BackingField
private BsonToken <Value>k__BackingField
public BsonString Name
public BsonToken Value
public BsonString get_Name()
public void set_Name(BsonString value)
public BsonToken get_Value()
public void set_Value(BsonToken value)
}
public Newtonsoft.Json.Bson.BsonReader : JsonReader {
private int MaxCharBytesSize
private Byte[] SeqRange1
private Byte[] SeqRange2
private Byte[] SeqRange3
private Byte[] SeqRange4
private BinaryReader _reader
private List`1<ContainerContext> _stack
private Byte[] _byteBuffer
private Char[] _charBuffer
private BsonType _currentElementType
private BsonReaderState _bsonReaderState
private ContainerContext _currentContext
private bool _readRootValueAsArray
private bool _jsonNet35BinaryCompatibility
private DateTimeKind _dateTimeKindHandling
public bool JsonNet35BinaryCompatibility
public bool ReadRootValueAsArray
public DateTimeKind DateTimeKindHandling
public bool get_JsonNet35BinaryCompatibility()
public void set_JsonNet35BinaryCompatibility(bool value)
public bool get_ReadRootValueAsArray()
public void set_ReadRootValueAsArray(bool value)
public DateTimeKind get_DateTimeKindHandling()
public void set_DateTimeKindHandling(DateTimeKind value)
public void .ctor(Stream stream)
public void .ctor(BinaryReader reader)
public void .ctor(Stream stream, bool readRootValueAsArray, DateTimeKind dateTimeKindHandling)
public void .ctor(BinaryReader reader, bool readRootValueAsArray, DateTimeKind dateTimeKindHandling)
private string ReadElement()
public bool Read()
public void Close()
private bool ReadCodeWScope()
private bool ReadReference()
private bool ReadNormal()
private void PopContext()
private void PushContext(ContainerContext newContext)
private byte ReadByte()
private void ReadType(BsonType type)
private Byte[] ReadBinary(BsonBinaryType& binaryType)
private string ReadString()
private string ReadLengthString()
private string GetString(int length)
private int GetLastFullCharStop(int start)
private int BytesInSequence(byte b)
private void EnsureBuffers()
private double ReadDouble()
private int ReadInt32()
private long ReadInt64()
private BsonType ReadType()
private void MovePosition(int count)
private Byte[] ReadBytes(int count)
}
internal Newtonsoft.Json.Bson.BsonRegex : BsonToken {
private BsonString <Pattern>k__BackingField
private BsonString <Options>k__BackingField
public BsonString Pattern
public BsonString Options
public BsonType Type
public BsonString get_Pattern()
public void set_Pattern(BsonString value)
public BsonString get_Options()
public void set_Options(BsonString value)
public void .ctor(string pattern, string options)
public BsonType get_Type()
}
internal Newtonsoft.Json.Bson.BsonString : BsonValue {
private int <ByteCount>k__BackingField
private bool <IncludeLength>k__BackingField
public int ByteCount
public bool IncludeLength
public int get_ByteCount()
public void set_ByteCount(int value)
public bool get_IncludeLength()
public void set_IncludeLength(bool value)
public void .ctor(object value, bool includeLength)
}
internal Newtonsoft.Json.Bson.BsonToken : object {
private BsonToken <Parent>k__BackingField
private int <CalculatedSize>k__BackingField
public BsonType Type
public BsonToken Parent
public int CalculatedSize
public BsonType get_Type()
public BsonToken get_Parent()
public void set_Parent(BsonToken value)
public int get_CalculatedSize()
public void set_CalculatedSize(int value)
}
internal Newtonsoft.Json.Bson.BsonType : Enum {
public sbyte value__
public BsonType Number
public BsonType String
public BsonType Object
public BsonType Array
public BsonType Binary
public BsonType Undefined
public BsonType Oid
public BsonType Boolean
public BsonType Date
public BsonType Null
public BsonType Regex
public BsonType Reference
public BsonType Code
public BsonType Symbol
public BsonType CodeWScope
public BsonType Integer
public BsonType TimeStamp
public BsonType Long
public BsonType MinKey
public BsonType MaxKey
}
internal Newtonsoft.Json.Bson.BsonValue : BsonToken {
private object _value
private BsonType _type
public object Value
public BsonType Type
public void .ctor(object value, BsonType type)
public object get_Value()
public BsonType get_Type()
}
public Newtonsoft.Json.Bson.BsonWriter : JsonWriter {
private BsonBinaryWriter _writer
private BsonToken _root
private BsonToken _parent
private string _propertyName
public DateTimeKind DateTimeKindHandling
public DateTimeKind get_DateTimeKindHandling()
public void set_DateTimeKindHandling(DateTimeKind value)
public void .ctor(Stream stream)
public void .ctor(BinaryWriter writer)
public void Flush()
protected void WriteEnd(JsonToken token)
public void WriteComment(string text)
public void WriteStartConstructor(string name)
public void WriteRaw(string json)
public void WriteRawValue(string json)
public void WriteStartArray()
public void WriteStartObject()
public void WritePropertyName(string name)
public void Close()
private void AddParent(BsonToken container)
private void RemoveParent()
private void AddValue(object value, BsonType type)
internal void AddToken(BsonToken token)
public void WriteValue(object value)
public void WriteNull()
public void WriteUndefined()
public void WriteValue(string value)
public void WriteValue(int value)
public void WriteValue(UInt32 value)
public void WriteValue(long value)
public void WriteValue(ulong value)
public void WriteValue(float value)
public void WriteValue(double value)
public void WriteValue(bool value)
public void WriteValue(short value)
public void WriteValue(ushort value)
public void WriteValue(char value)
public void WriteValue(byte value)
public void WriteValue(sbyte value)
public void WriteValue(decimal value)
public void WriteValue(DateTime value)
public void WriteValue(DateTimeOffset value)
public void WriteValue(Byte[] value)
public void WriteValue(Guid value)
public void WriteValue(TimeSpan value)
public void WriteValue(Uri value)
public void WriteObjectId(Byte[] value)
public void WriteRegex(string pattern, string options)
}
public Newtonsoft.Json.ConstructorHandling : Enum {
public int value__
public ConstructorHandling Default
public ConstructorHandling AllowNonPublicDefaultConstructor
}
public Newtonsoft.Json.Converters.BinaryConverter : JsonConverter {
private string BinaryTypeName
private string BinaryToArrayName
private ReflectionObject _reflectionObject
public void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
private Byte[] GetByteArray(object value)
private void EnsureReflectionObject(Type t)
public object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
private Byte[] ReadByteArray(JsonReader reader)
public bool CanConvert(Type objectType)
}
public Newtonsoft.Json.Converters.BsonObjectIdConverter : JsonConverter {
public void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
public object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
public bool CanConvert(Type objectType)
}
public Newtonsoft.Json.Converters.ColorConverter : JsonConverter {
public bool CanRead
public void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
public bool CanConvert(Type objectType)
public object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
public bool get_CanRead()
}
public Newtonsoft.Json.Converters.CustomCreationConverter`1 : JsonConverter {
public bool CanWrite
public void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
public object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
public T Create(Type objectType)
public bool CanConvert(Type objectType)
public bool get_CanWrite()
}
public Newtonsoft.Json.Converters.DateTimeConverterBase : JsonConverter {
public bool CanConvert(Type objectType)
}
public Newtonsoft.Json.Converters.EnumerableVectorConverter`1 : JsonConverter {
private VectorConverter VectorConverter
public bool CanRead
public void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
public bool CanConvert(Type objectType)
public object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
public bool get_CanRead()
}
public Newtonsoft.Json.Converters.HashSetConverter : JsonConverter {
public bool CanWrite
public void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
public object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
public bool CanConvert(Type objectType)
public bool get_CanWrite()
}
public Newtonsoft.Json.Converters.IsoDateTimeConverter : DateTimeConverterBase {
private string DefaultDateTimeFormat
private DateTimeStyles _dateTimeStyles
private string _dateTimeFormat
private CultureInfo _culture
public DateTimeStyles DateTimeStyles
public string DateTimeFormat
public CultureInfo Culture
public DateTimeStyles get_DateTimeStyles()
public void set_DateTimeStyles(DateTimeStyles value)
public string get_DateTimeFormat()
public void set_DateTimeFormat(string value)
public CultureInfo get_Culture()
public void set_Culture(CultureInfo value)
public void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
public object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
}
internal Newtonsoft.Json.Converters.IXmlDeclaration {
public string Version
public string Encoding
public string Standalone
public string get_Version()
public string get_Encoding()
public void set_Encoding(string value)
public string get_Standalone()
public void set_Standalone(string value)
}
internal Newtonsoft.Json.Converters.IXmlDocument {
public IXmlElement DocumentElement
public IXmlNode CreateComment(string text)
public IXmlNode CreateTextNode(string text)
public IXmlNode CreateCDataSection(string data)
public IXmlNode CreateWhitespace(string text)
public IXmlNode CreateSignificantWhitespace(string text)
public IXmlNode CreateXmlDeclaration(string version, string encoding, string standalone)
public IXmlNode CreateXmlDocumentType(string name, string publicId, string systemId, string internalSubset)
public IXmlNode CreateProcessingInstruction(string target, string data)
public IXmlElement CreateElement(string elementName)
public IXmlElement CreateElement(string qualifiedName, string namespaceUri)
public IXmlNode CreateAttribute(string name, string value)
public IXmlNode CreateAttribute(string qualifiedName, string namespaceUri, string value)
public IXmlElement get_DocumentElement()
}
internal Newtonsoft.Json.Converters.IXmlDocumentType {
public string Name
public string System
public string Public
public string InternalSubset
public string get_Name()
public string get_System()
public string get_Public()
public string get_InternalSubset()
}
internal Newtonsoft.Json.Converters.IXmlElement {
public bool IsEmpty
public void SetAttributeNode(IXmlNode attribute)
public string GetPrefixOfNamespace(string namespaceUri)
public bool get_IsEmpty()
}
internal Newtonsoft.Json.Converters.IXmlNode {
public XmlNodeType NodeType
public string LocalName
public List`1<IXmlNode> ChildNodes
public List`1<IXmlNode> Attributes
public IXmlNode ParentNode
public string Value
public string NamespaceUri
public object WrappedNode
public XmlNodeType get_NodeType()
public string get_LocalName()
public List`1<IXmlNode> get_ChildNodes()
public List`1<IXmlNode> get_Attributes()
public IXmlNode get_ParentNode()
public string get_Value()
public void set_Value(string value)
public IXmlNode AppendChild(IXmlNode newChild)
public string get_NamespaceUri()
public object get_WrappedNode()
}
public Newtonsoft.Json.Converters.JavaScriptDateTimeConverter : DateTimeConverterBase {
public void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
public object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
}
public Newtonsoft.Json.Converters.KeyValuePairConverter : JsonConverter {
private string KeyName
private string ValueName
private ThreadSafeStore`2<Type, ReflectionObject> ReflectionObjectPerType
private ReflectionObject InitializeReflectionObject(Type t)
public void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
public object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
public bool CanConvert(Type objectType)
}
public Newtonsoft.Json.Converters.Matrix4x4Converter : JsonConverter {
public bool CanRead
public void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
public object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
public bool get_CanRead()
public bool CanConvert(Type objectType)
}
public Newtonsoft.Json.Converters.QuaternionConverter : JsonConverter {
public bool CanRead
public void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
public bool CanConvert(Type objectType)
public object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
public bool get_CanRead()
}
public Newtonsoft.Json.Converters.RegexConverter : JsonConverter {
private string PatternName
private string OptionsName
public void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
private bool HasFlag(RegexOptions options, RegexOptions flag)
private void WriteBson(BsonWriter writer, Regex regex)
private void WriteJson(JsonWriter writer, Regex regex, JsonSerializer serializer)
public object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
private object ReadRegexString(JsonReader reader)
private Regex ReadRegexObject(JsonReader reader, JsonSerializer serializer)
public bool CanConvert(Type objectType)
}
public Newtonsoft.Json.Converters.ResolutionConverter : JsonConverter {
public bool CanRead
public void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
public bool CanConvert(Type objectType)
public object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
public bool get_CanRead()
}
public Newtonsoft.Json.Converters.StringEnumConverter : JsonConverter {
private bool <CamelCaseText>k__BackingField
private bool <AllowIntegerValues>k__BackingField
public bool CamelCaseText
public bool AllowIntegerValues
public bool get_CamelCaseText()
public void set_CamelCaseText(bool value)
public bool get_AllowIntegerValues()
public void set_AllowIntegerValues(bool value)
public void .ctor(bool camelCaseText)
public void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
public object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
public bool CanConvert(Type objectType)
}
public Newtonsoft.Json.Converters.UriConverter : JsonConverter {
public bool CanConvert(Type objectType)
public object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
public void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
}
public Newtonsoft.Json.Converters.VectorConverter : JsonConverter {
private Type V2
private Type V3
private Type V4
private bool <EnableVector2>k__BackingField
private bool <EnableVector3>k__BackingField
private bool <EnableVector4>k__BackingField
public bool EnableVector2
public bool EnableVector3
public bool EnableVector4
public bool get_EnableVector2()
public void set_EnableVector2(bool value)
public bool get_EnableVector3()
public void set_EnableVector3(bool value)
public bool get_EnableVector4()
public void set_EnableVector4(bool value)
public void .ctor(bool enableVector2, bool enableVector3, bool enableVector4)
public void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
private void WriteVector(JsonWriter writer, float x, float y, Nullable`1<float> z, Nullable`1<float> w)
public object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
public bool CanConvert(Type objectType)
private Vector2 PopulateVector2(JsonReader reader)
private Vector3 PopulateVector3(JsonReader reader)
private Vector4 PopulateVector4(JsonReader reader)
}
public Newtonsoft.Json.Converters.VersionConverter : JsonConverter {
public void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
public object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
public bool CanConvert(Type objectType)
}
internal Newtonsoft.Json.Converters.XAttributeWrapper : XObjectWrapper {
private XAttribute Attribute
public string Value
public string LocalName
public string NamespaceUri
public IXmlNode ParentNode
private XAttribute get_Attribute()
public void .ctor(XAttribute attribute)
public string get_Value()
public void set_Value(string value)
public string get_LocalName()
public string get_NamespaceUri()
public IXmlNode get_ParentNode()
}
internal Newtonsoft.Json.Converters.XCommentWrapper : XObjectWrapper {
private XComment Text
public string Value
public IXmlNode ParentNode
private XComment get_Text()
public void .ctor(XComment text)
public string get_Value()
public void set_Value(string value)
public IXmlNode get_ParentNode()
}
internal Newtonsoft.Json.Converters.XContainerWrapper : XObjectWrapper {
private List`1<IXmlNode> _childNodes
private XContainer Container
public List`1<IXmlNode> ChildNodes
public IXmlNode ParentNode
private XContainer get_Container()
public void .ctor(XContainer container)
public List`1<IXmlNode> get_ChildNodes()
public IXmlNode get_ParentNode()
internal IXmlNode WrapNode(XObject node)
public IXmlNode AppendChild(IXmlNode newChild)
}
internal Newtonsoft.Json.Converters.XDeclarationWrapper : XObjectWrapper {
private XDeclaration <Declaration>k__BackingField
internal XDeclaration Declaration
public XmlNodeType NodeType
public string Version
public string Encoding
public string Standalone
internal XDeclaration get_Declaration()
private void set_Declaration(XDeclaration value)
public void .ctor(XDeclaration declaration)
public XmlNodeType get_NodeType()
public string get_Version()
public string get_Encoding()
public void set_Encoding(string value)
public string get_Standalone()
public void set_Standalone(string value)
}
internal Newtonsoft.Json.Converters.XDocumentTypeWrapper : XObjectWrapper {
private XDocumentType _documentType
public string Name
public string System
public string Public
public string InternalSubset
public string LocalName
public void .ctor(XDocumentType documentType)
public string get_Name()
public string get_System()
public string get_Public()
public string get_InternalSubset()
public string get_LocalName()
}
internal Newtonsoft.Json.Converters.XDocumentWrapper : XContainerWrapper {
private XDocument Document
public List`1<IXmlNode> ChildNodes
public IXmlElement DocumentElement
private XDocument get_Document()
public void .ctor(XDocument document)
public List`1<IXmlNode> get_ChildNodes()
public IXmlNode CreateComment(string text)
public IXmlNode CreateTextNode(string text)
public IXmlNode CreateCDataSection(string data)
public IXmlNode CreateWhitespace(string text)
public IXmlNode CreateSignificantWhitespace(string text)
public IXmlNode CreateXmlDeclaration(string version, string encoding, string standalone)
public IXmlNode CreateXmlDocumentType(string name, string publicId, string systemId, string internalSubset)
public IXmlNode CreateProcessingInstruction(string target, string data)
public IXmlElement CreateElement(string elementName)
public IXmlElement CreateElement(string qualifiedName, string namespaceUri)
public IXmlNode CreateAttribute(string name, string value)
public IXmlNode CreateAttribute(string qualifiedName, string namespaceUri, string value)
public IXmlElement get_DocumentElement()
public IXmlNode AppendChild(IXmlNode newChild)
}
internal Newtonsoft.Json.Converters.XElementWrapper : XContainerWrapper {
private List`1<IXmlNode> _attributes
private XElement Element
public List`1<IXmlNode> Attributes
public string Value
public string LocalName
public string NamespaceUri
public bool IsEmpty
private XElement get_Element()
public void .ctor(XElement element)
public void SetAttributeNode(IXmlNode attribute)
public List`1<IXmlNode> get_Attributes()
public IXmlNode AppendChild(IXmlNode newChild)
public string get_Value()
public void set_Value(string value)
public string get_LocalName()
public string get_NamespaceUri()
public string GetPrefixOfNamespace(string namespaceUri)
public bool get_IsEmpty()
}
internal Newtonsoft.Json.Converters.XmlDeclarationWrapper : XmlNodeWrapper {
private XmlDeclaration _declaration
public string Version
public string Encoding
public string Standalone
public void .ctor(XmlDeclaration declaration)
public string get_Version()
public string get_Encoding()
public void set_Encoding(string value)
public string get_Standalone()
public void set_Standalone(string value)
}
internal Newtonsoft.Json.Converters.XmlDocumentTypeWrapper : XmlNodeWrapper {
private XmlDocumentType _documentType
public string Name
public string System
public string Public
public string InternalSubset
public string LocalName
public void .ctor(XmlDocumentType documentType)
public string get_Name()
public string get_System()
public string get_Public()
public string get_InternalSubset()
public string get_LocalName()
}
internal Newtonsoft.Json.Converters.XmlDocumentWrapper : XmlNodeWrapper {
private XmlDocument _document
public IXmlElement DocumentElement
public void .ctor(XmlDocument document)
public IXmlNode CreateComment(string data)
public IXmlNode CreateTextNode(string text)
public IXmlNode CreateCDataSection(string data)
public IXmlNode CreateWhitespace(string text)
public IXmlNode CreateSignificantWhitespace(string text)
public IXmlNode CreateXmlDeclaration(string version, string encoding, string standalone)
public IXmlNode CreateXmlDocumentType(string name, string publicId, string systemId, string internalSubset)
public IXmlNode CreateProcessingInstruction(string target, string data)
public IXmlElement CreateElement(string elementName)
public IXmlElement CreateElement(string qualifiedName, string namespaceUri)
public IXmlNode CreateAttribute(string name, string value)
public IXmlNode CreateAttribute(string qualifiedName, string namespaceUri, string value)
public IXmlElement get_DocumentElement()
}
internal Newtonsoft.Json.Converters.XmlElementWrapper : XmlNodeWrapper {
private XmlElement _element
public bool IsEmpty
public void .ctor(XmlElement element)
public void SetAttributeNode(IXmlNode attribute)
public string GetPrefixOfNamespace(string namespaceUri)
public bool get_IsEmpty()
}
public Newtonsoft.Json.Converters.XmlNodeConverter : JsonConverter {
private string TextName
private string CommentName
private string CDataName
private string WhitespaceName
private string SignificantWhitespaceName
private string DeclarationName
private string JsonNamespaceUri
private string <DeserializeRootElementName>k__BackingField
private bool <WriteArrayAttribute>k__BackingField
private bool <OmitRootObject>k__BackingField
public string DeserializeRootElementName
public bool WriteArrayAttribute
public bool OmitRootObject
public string get_DeserializeRootElementName()
public void set_DeserializeRootElementName(string value)
public bool get_WriteArrayAttribute()
public void set_WriteArrayAttribute(bool value)
public bool get_OmitRootObject()
public void set_OmitRootObject(bool value)
public void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
private IXmlNode WrapXml(object value)
private void PushParentNamespaces(IXmlNode node, XmlNamespaceManager manager)
private string ResolveFullName(IXmlNode node, XmlNamespaceManager manager)
private string GetPropertyName(IXmlNode node, XmlNamespaceManager manager)
private bool IsArray(IXmlNode node)
private void SerializeGroupedNodes(JsonWriter writer, IXmlNode node, XmlNamespaceManager manager, bool writePropertyName)
private void SerializeNode(JsonWriter writer, IXmlNode node, XmlNamespaceManager manager, bool writePropertyName)
private bool AllSameName(IXmlNode node)
public object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
private void DeserializeValue(JsonReader reader, IXmlDocument document, XmlNamespaceManager manager, string propertyName, IXmlNode currentNode)
private void ReadElement(JsonReader reader, IXmlDocument document, IXmlNode currentNode, string propertyName, XmlNamespaceManager manager)
private void CreateElement(JsonReader reader, IXmlDocument document, IXmlNode currentNode, string elementName, XmlNamespaceManager manager, string elementPrefix, Dictionary`2<string, string> attributeNameValues)
private void AddAttribute(JsonReader reader, IXmlDocument document, IXmlNode currentNode, string attributeName, XmlNamespaceManager manager, string attributePrefix)
private string ConvertTokenToXmlValue(JsonReader reader)
private void ReadArrayElements(JsonReader reader, IXmlDocument document, string propertyName, IXmlNode currentNode, XmlNamespaceManager manager)
private void AddJsonArrayAttribute(IXmlElement element, IXmlDocument document)
private Dictionary`2<string, string> ReadAttributeElements(JsonReader reader, XmlNamespaceManager manager)
private void CreateInstruction(JsonReader reader, IXmlDocument document, IXmlNode currentNode, string propertyName)
private void CreateDocumentType(JsonReader reader, IXmlDocument document, IXmlNode currentNode)
private IXmlElement CreateElement(string elementName, IXmlDocument document, string elementPrefix, XmlNamespaceManager manager)
private void DeserializeNode(JsonReader reader, IXmlDocument document, XmlNamespaceManager manager, IXmlNode currentNode)
private bool IsNamespaceAttribute(string attributeName, String& prefix)
private bool ValueAttributes(List`1<IXmlNode> c)
public bool CanConvert(Type valueType)
}
internal Newtonsoft.Json.Converters.XmlNodeWrapper : object {
private XmlNode _node
private List`1<IXmlNode> _childNodes
private List`1<IXmlNode> _attributes
public object WrappedNode
public XmlNodeType NodeType
public string LocalName
public List`1<IXmlNode> ChildNodes
public List`1<IXmlNode> Attributes
public IXmlNode ParentNode
public string Value
public string NamespaceUri
public void .ctor(XmlNode node)
public object get_WrappedNode()
public XmlNodeType get_NodeType()
public string get_LocalName()
public List`1<IXmlNode> get_ChildNodes()
internal IXmlNode WrapNode(XmlNode node)
public List`1<IXmlNode> get_Attributes()
public IXmlNode get_ParentNode()
public string get_Value()
public void set_Value(string value)
public IXmlNode AppendChild(IXmlNode newChild)
public string get_NamespaceUri()
}
internal Newtonsoft.Json.Converters.XObjectWrapper : object {
private List`1<IXmlNode> EmptyChildNodes
private XObject _xmlObject
public object WrappedNode
public XmlNodeType NodeType
public string LocalName
public List`1<IXmlNode> ChildNodes
public List`1<IXmlNode> Attributes
public IXmlNode ParentNode
public string Value
public string NamespaceUri
public void .ctor(XObject xmlObject)
public object get_WrappedNode()
public XmlNodeType get_NodeType()
public string get_LocalName()
public List`1<IXmlNode> get_ChildNodes()
public List`1<IXmlNode> get_Attributes()
public IXmlNode get_ParentNode()
public string get_Value()
public void set_Value(string value)
public IXmlNode AppendChild(IXmlNode newChild)
public string get_NamespaceUri()
}
internal Newtonsoft.Json.Converters.XProcessingInstructionWrapper : XObjectWrapper {
private XProcessingInstruction ProcessingInstruction
public string LocalName
public string Value
private XProcessingInstruction get_ProcessingInstruction()
public void .ctor(XProcessingInstruction processingInstruction)
public string get_LocalName()
public string get_Value()
public void set_Value(string value)
}
internal Newtonsoft.Json.Converters.XTextWrapper : XObjectWrapper {
private XText Text
public string Value
public IXmlNode ParentNode
private XText get_Text()
public void .ctor(XText text)
public string get_Value()
public void set_Value(string value)
public IXmlNode get_ParentNode()
}
public Newtonsoft.Json.DateFormatHandling : Enum {
public int value__
public DateFormatHandling IsoDateFormat
public DateFormatHandling MicrosoftDateFormat
}
public Newtonsoft.Json.DateParseHandling : Enum {
public int value__
public DateParseHandling None
public DateParseHandling DateTime
public DateParseHandling DateTimeOffset
}
public Newtonsoft.Json.DateTimeZoneHandling : Enum {
public int value__
public DateTimeZoneHandling Local
public DateTimeZoneHandling Utc
public DateTimeZoneHandling Unspecified
public DateTimeZoneHandling RoundtripKind
}
public Newtonsoft.Json.DefaultValueHandling : Enum {
public int value__
public DefaultValueHandling Include
public DefaultValueHandling Ignore
public DefaultValueHandling Populate
public DefaultValueHandling IgnoreAndPopulate
}
public Newtonsoft.Json.FloatFormatHandling : Enum {
public int value__
public FloatFormatHandling String
public FloatFormatHandling Symbol
public FloatFormatHandling DefaultValue
}
public Newtonsoft.Json.FloatParseHandling : Enum {
public int value__
public FloatParseHandling Double
public FloatParseHandling Decimal
}
public Newtonsoft.Json.Formatting : Enum {
public int value__
public Formatting None
public Formatting Indented
}
public Newtonsoft.Json.IArrayPool`1 {
public T[] Rent(int minimumLength)
public void Return(T[] array)
}
public Newtonsoft.Json.IJsonLineInfo {
public int LineNumber
public int LinePosition
public bool HasLineInfo()
public int get_LineNumber()
public int get_LinePosition()
}
public Newtonsoft.Json.JsonArrayAttribute : JsonContainerAttribute {
private bool _allowNullItems
public bool AllowNullItems
public bool get_AllowNullItems()
public void set_AllowNullItems(bool value)
public void .ctor(bool allowNullItems)
public void .ctor(string id)
}
public Newtonsoft.Json.JsonContainerAttribute : Attribute {
private string <Id>k__BackingField
private string <Title>k__BackingField
private string <Description>k__BackingField
private Type <ItemConverterType>k__BackingField
private Object[] <ItemConverterParameters>k__BackingField
internal Nullable`1<bool> _isReference
internal Nullable`1<bool> _itemIsReference
internal Nullable`1<ReferenceLoopHandling> _itemReferenceLoopHandling
internal Nullable`1<TypeNameHandling> _itemTypeNameHandling
public string Id
public string Title
public string Description
public Type ItemConverterType
public Object[] ItemConverterParameters
public bool IsReference
public bool ItemIsReference
public ReferenceLoopHandling ItemReferenceLoopHandling
public TypeNameHandling ItemTypeNameHandling
public string get_Id()
public void set_Id(string value)
public string get_Title()
public void set_Title(string value)
public string get_Description()
public void set_Description(string value)
public Type get_ItemConverterType()
public void set_ItemConverterType(Type value)
public Object[] get_ItemConverterParameters()
public void set_ItemConverterParameters(Object[] value)
public bool get_IsReference()
public void set_IsReference(bool value)
public bool get_ItemIsReference()
public void set_ItemIsReference(bool value)
public ReferenceLoopHandling get_ItemReferenceLoopHandling()
public void set_ItemReferenceLoopHandling(ReferenceLoopHandling value)
public TypeNameHandling get_ItemTypeNameHandling()
public void set_ItemTypeNameHandling(TypeNameHandling value)
protected void .ctor(string id)
}
internal Newtonsoft.Json.JsonContainerType : Enum {
public int value__
public JsonContainerType None
public JsonContainerType Object
public JsonContainerType Array
public JsonContainerType Constructor
}
public Newtonsoft.Json.JsonConvert : object {
private Func`1<JsonSerializerSettings> <DefaultSettings>k__BackingField
public string True
public string False
public string Null
public string Undefined
public string PositiveInfinity
public string NegativeInfinity
public string NaN
private JsonSerializerSettings InitialSerializerSettings
public Func`1<JsonSerializerSettings> DefaultSettings
public Func`1<JsonSerializerSettings> get_DefaultSettings()
public void set_DefaultSettings(Func`1<JsonSerializerSettings> value)
internal JsonSerializerSettings GetDefaultSettings()
public string ToString(DateTime value)
public string ToString(DateTime value, DateFormatHandling format, DateTimeZoneHandling timeZoneHandling)
public string ToString(DateTimeOffset value)
public string ToString(DateTimeOffset value, DateFormatHandling format)
public string ToString(bool value)
public string ToString(char value)
public string ToString(Enum value)
public string ToString(int value)
public string ToString(short value)
public string ToString(ushort value)
public string ToString(UInt32 value)
public string ToString(long value)
public string ToString(ulong value)
public string ToString(float value)
internal string ToString(float value, FloatFormatHandling floatFormatHandling, char quoteChar, bool nullable)
private string EnsureFloatFormat(double value, string text, FloatFormatHandling floatFormatHandling, char quoteChar, bool nullable)
public string ToString(double value)
internal string ToString(double value, FloatFormatHandling floatFormatHandling, char quoteChar, bool nullable)
private string EnsureDecimalPlace(double value, string text)
private string EnsureDecimalPlace(string text)
public string ToString(byte value)
public string ToString(sbyte value)
public string ToString(decimal value)
public string ToString(Guid value)
internal string ToString(Guid value, char quoteChar)
public string ToString(TimeSpan value)
internal string ToString(TimeSpan value, char quoteChar)
public string ToString(Uri value)
internal string ToString(Uri value, char quoteChar)
public string ToString(string value)
public string ToString(string value, char delimiter)
public string ToString(string value, char delimiter, StringEscapeHandling stringEscapeHandling)
public string ToString(object value)
public string SerializeObject(object value)
public string SerializeObject(object value, Formatting formatting)
public string SerializeObject(object value, JsonConverter[] converters)
public string SerializeObject(object value, Formatting formatting, JsonConverter[] converters)
public string SerializeObject(object value, JsonSerializerSettings settings)
public string SerializeObject(object value, Type type, JsonSerializerSettings settings)
public string SerializeObject(object value, Formatting formatting, JsonSerializerSettings settings)
public string SerializeObject(object value, Type type, Formatting formatting, JsonSerializerSettings settings)
private string SerializeObjectInternal(object value, Type type, JsonSerializer jsonSerializer)
public object DeserializeObject(string value)
public object DeserializeObject(string value, JsonSerializerSettings settings)
public object DeserializeObject(string value, Type type)
public T DeserializeObject(string value)
public T DeserializeAnonymousType(string value, T anonymousTypeObject)
public T DeserializeAnonymousType(string value, T anonymousTypeObject, JsonSerializerSettings settings)
public T DeserializeObject(string value, JsonConverter[] converters)
public T DeserializeObject(string value, JsonSerializerSettings settings)
public object DeserializeObject(string value, Type type, JsonConverter[] converters)
public object DeserializeObject(string value, Type type, JsonSerializerSettings settings)
public void PopulateObject(string value, object target)
public void PopulateObject(string value, object target, JsonSerializerSettings settings)
public string SerializeXmlNode(XmlNode node)
public string SerializeXmlNode(XmlNode node, Formatting formatting)
public string SerializeXmlNode(XmlNode node, Formatting formatting, bool omitRootObject)
public XmlDocument DeserializeXmlNode(string value)
public XmlDocument DeserializeXmlNode(string value, string deserializeRootElementName)
public XmlDocument DeserializeXmlNode(string value, string deserializeRootElementName, bool writeArrayAttribute)
public string SerializeXNode(XObject node)
public string SerializeXNode(XObject node, Formatting formatting)
public string SerializeXNode(XObject node, Formatting formatting, bool omitRootObject)
public XDocument DeserializeXNode(string value)
public XDocument DeserializeXNode(string value, string deserializeRootElementName)
public XDocument DeserializeXNode(string value, string deserializeRootElementName, bool writeArrayAttribute)
}
public Newtonsoft.Json.JsonConverter : object {
public bool CanRead
public bool CanWrite
public void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
public object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
public bool CanConvert(Type objectType)
public bool get_CanRead()
public bool get_CanWrite()
}
public Newtonsoft.Json.JsonConverterAttribute : Attribute {
private Type _converterType
private Object[] <ConverterParameters>k__BackingField
public Type ConverterType
public Object[] ConverterParameters
public Type get_ConverterType()
public Object[] get_ConverterParameters()
private void set_ConverterParameters(Object[] value)
public void .ctor(Type converterType)
public void .ctor(Type converterType, Object[] converterParameters)
}
public Newtonsoft.Json.JsonDictionaryAttribute : JsonContainerAttribute {
public void .ctor(string id)
}
public Newtonsoft.Json.JsonException : Exception {
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
public void .ctor(SerializationInfo info, StreamingContext context)
internal JsonException Create(IJsonLineInfo lineInfo, string path, string message)
}
public Newtonsoft.Json.JsonExtensionDataAttribute : Attribute {
private bool <WriteData>k__BackingField
private bool <ReadData>k__BackingField
public bool WriteData
public bool ReadData
public bool get_WriteData()
public void set_WriteData(bool value)
public bool get_ReadData()
public void set_ReadData(bool value)
}
public Newtonsoft.Json.JsonObjectAttribute : JsonContainerAttribute {
private MemberSerialization _memberSerialization
internal Nullable`1<Required> _itemRequired
public MemberSerialization MemberSerialization
public Required ItemRequired
public MemberSerialization get_MemberSerialization()
public void set_MemberSerialization(MemberSerialization value)
public Required get_ItemRequired()
public void set_ItemRequired(Required value)
public void .ctor(MemberSerialization memberSerialization)
public void .ctor(string id)
}
internal Newtonsoft.Json.JsonPosition : ValueType {
private Char[] SpecialCharacters
internal JsonContainerType Type
internal int Position
internal string PropertyName
internal bool HasIndex
public void .ctor(JsonContainerType type)
internal int CalculateLength()
internal void WriteTo(StringBuilder sb)
internal bool TypeHasIndex(JsonContainerType type)
internal string BuildPath(List`1<JsonPosition> positions, Nullable`1<JsonPosition> currentPosition)
internal string FormatMessage(IJsonLineInfo lineInfo, string path, string message)
}
public Newtonsoft.Json.JsonPropertyAttribute : Attribute {
internal Nullable`1<NullValueHandling> _nullValueHandling
internal Nullable`1<DefaultValueHandling> _defaultValueHandling
internal Nullable`1<ReferenceLoopHandling> _referenceLoopHandling
internal Nullable`1<ObjectCreationHandling> _objectCreationHandling
internal Nullable`1<TypeNameHandling> _typeNameHandling
internal Nullable`1<bool> _isReference
internal Nullable`1<int> _order
internal Nullable`1<Required> _required
internal Nullable`1<bool> _itemIsReference
internal Nullable`1<ReferenceLoopHandling> _itemReferenceLoopHandling
internal Nullable`1<TypeNameHandling> _itemTypeNameHandling
private Type <ItemConverterType>k__BackingField
private Object[] <ItemConverterParameters>k__BackingField
private string <PropertyName>k__BackingField
public Type ItemConverterType
public Object[] ItemConverterParameters
public NullValueHandling NullValueHandling
public DefaultValueHandling DefaultValueHandling
public ReferenceLoopHandling ReferenceLoopHandling
public ObjectCreationHandling ObjectCreationHandling
public TypeNameHandling TypeNameHandling
public bool IsReference
public int Order
public Required Required
public string PropertyName
public ReferenceLoopHandling ItemReferenceLoopHandling
public TypeNameHandling ItemTypeNameHandling
public bool ItemIsReference
public Type get_ItemConverterType()
public void set_ItemConverterType(Type value)
public Object[] get_ItemConverterParameters()
public void set_ItemConverterParameters(Object[] value)
public NullValueHandling get_NullValueHandling()
public void set_NullValueHandling(NullValueHandling value)
public DefaultValueHandling get_DefaultValueHandling()
public void set_DefaultValueHandling(DefaultValueHandling value)
public ReferenceLoopHandling get_ReferenceLoopHandling()
public void set_ReferenceLoopHandling(ReferenceLoopHandling value)
public ObjectCreationHandling get_ObjectCreationHandling()
public void set_ObjectCreationHandling(ObjectCreationHandling value)
public TypeNameHandling get_TypeNameHandling()
public void set_TypeNameHandling(TypeNameHandling value)
public bool get_IsReference()
public void set_IsReference(bool value)
public int get_Order()
public void set_Order(int value)
public Required get_Required()
public void set_Required(Required value)
public string get_PropertyName()
public void set_PropertyName(string value)
public ReferenceLoopHandling get_ItemReferenceLoopHandling()
public void set_ItemReferenceLoopHandling(ReferenceLoopHandling value)
public TypeNameHandling get_ItemTypeNameHandling()
public void set_ItemTypeNameHandling(TypeNameHandling value)
public bool get_ItemIsReference()
public void set_ItemIsReference(bool value)
public void .ctor(string propertyName)
}
public Newtonsoft.Json.JsonReader : object {
private JsonToken _tokenType
private object _value
internal char _quoteChar
internal State _currentState
private JsonPosition _currentPosition
private CultureInfo _culture
private DateTimeZoneHandling _dateTimeZoneHandling
private Nullable`1<int> _maxDepth
private bool _hasExceededMaxDepth
internal DateParseHandling _dateParseHandling
internal FloatParseHandling _floatParseHandling
private string _dateFormatString
private List`1<JsonPosition> _stack
private bool <CloseInput>k__BackingField
private bool <SupportMultipleContent>k__BackingField
protected State CurrentState
public bool CloseInput
public bool SupportMultipleContent
public char QuoteChar
public DateTimeZoneHandling DateTimeZoneHandling
public DateParseHandling DateParseHandling
public FloatParseHandling FloatParseHandling
public string DateFormatString
public Nullable`1<int> MaxDepth
public JsonToken TokenType
public object Value
public Type ValueType
public int Depth
public string Path
public CultureInfo Culture
protected State get_CurrentState()
public bool get_CloseInput()
public void set_CloseInput(bool value)
public bool get_SupportMultipleContent()
public void set_SupportMultipleContent(bool value)
public char get_QuoteChar()
protected internal void set_QuoteChar(char value)
public DateTimeZoneHandling get_DateTimeZoneHandling()
public void set_DateTimeZoneHandling(DateTimeZoneHandling value)
public DateParseHandling get_DateParseHandling()
public void set_DateParseHandling(DateParseHandling value)
public FloatParseHandling get_FloatParseHandling()
public void set_FloatParseHandling(FloatParseHandling value)
public string get_DateFormatString()
public void set_DateFormatString(string value)
public Nullable`1<int> get_MaxDepth()
public void set_MaxDepth(Nullable`1<int> value)
public JsonToken get_TokenType()
public object get_Value()
public Type get_ValueType()
public int get_Depth()
public string get_Path()
public CultureInfo get_Culture()
public void set_Culture(CultureInfo value)
internal JsonPosition GetPosition(int depth)
private void Push(JsonContainerType value)
private JsonContainerType Pop()
private JsonContainerType Peek()
public bool Read()
public Nullable`1<int> ReadAsInt32()
internal Nullable`1<int> ReadInt32String(string s)
public string ReadAsString()
public Byte[] ReadAsBytes()
internal Byte[] ReadArrayIntoByteArray()
public Nullable`1<double> ReadAsDouble()
internal Nullable`1<double> ReadDoubleString(string s)
public Nullable`1<bool> ReadAsBoolean()
internal Nullable`1<bool> ReadBooleanString(string s)
public Nullable`1<decimal> ReadAsDecimal()
internal Nullable`1<decimal> ReadDecimalString(string s)
public Nullable`1<DateTime> ReadAsDateTime()
internal Nullable`1<DateTime> ReadDateTimeString(string s)
public Nullable`1<DateTimeOffset> ReadAsDateTimeOffset()
internal Nullable`1<DateTimeOffset> ReadDateTimeOffsetString(string s)
internal void ReaderReadAndAssert()
internal JsonReaderException CreateUnexpectedEndException()
internal void ReadIntoWrappedTypeObject()
public void Skip()
protected void SetToken(JsonToken newToken)
protected void SetToken(JsonToken newToken, object value)
internal void SetToken(JsonToken newToken, object value, bool updateIndex)
internal void SetPostValueState(bool updateIndex)
private void UpdateScopeWithFinishedValue()
private void ValidateEnd(JsonToken endToken)
protected void SetStateBasedOnCurrent()
private void SetFinished()
private JsonContainerType GetTypeForCloseToken(JsonToken token)
private void System.IDisposable.Dispose()
protected void Dispose(bool disposing)
public void Close()
internal void ReadAndAssert()
internal bool ReadAndMoveToContent()
internal bool MoveToContent()
private JsonToken GetContentToken()
}
public Newtonsoft.Json.JsonReaderException : JsonException {
private int <LineNumber>k__BackingField
private int <LinePosition>k__BackingField
private string <Path>k__BackingField
public int LineNumber
public int LinePosition
public string Path
public int get_LineNumber()
private void set_LineNumber(int value)
public int get_LinePosition()
private void set_LinePosition(int value)
public string get_Path()
private void set_Path(string value)
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
public void .ctor(SerializationInfo info, StreamingContext context)
internal void .ctor(string message, Exception innerException, string path, int lineNumber, int linePosition)
internal JsonReaderException Create(JsonReader reader, string message)
internal JsonReaderException Create(JsonReader reader, string message, Exception ex)
internal JsonReaderException Create(IJsonLineInfo lineInfo, string path, string message, Exception ex)
}
public Newtonsoft.Json.JsonSerializationException : JsonException {
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
public void .ctor(SerializationInfo info, StreamingContext context)
internal JsonSerializationException Create(JsonReader reader, string message)
internal JsonSerializationException Create(JsonReader reader, string message, Exception ex)
internal JsonSerializationException Create(IJsonLineInfo lineInfo, string path, string message, Exception ex)
}
public Newtonsoft.Json.JsonSerializer : object {
internal TypeNameHandling _typeNameHandling
internal FormatterAssemblyStyle _typeNameAssemblyFormat
internal PreserveReferencesHandling _preserveReferencesHandling
internal ReferenceLoopHandling _referenceLoopHandling
internal MissingMemberHandling _missingMemberHandling
internal ObjectCreationHandling _objectCreationHandling
internal NullValueHandling _nullValueHandling
internal DefaultValueHandling _defaultValueHandling
internal ConstructorHandling _constructorHandling
internal MetadataPropertyHandling _metadataPropertyHandling
internal JsonConverterCollection _converters
internal IContractResolver _contractResolver
internal ITraceWriter _traceWriter
internal IEqualityComparer _equalityComparer
internal SerializationBinder _binder
internal StreamingContext _context
private IReferenceResolver _referenceResolver
private Nullable`1<Formatting> _formatting
private Nullable`1<DateFormatHandling> _dateFormatHandling
private Nullable`1<DateTimeZoneHandling> _dateTimeZoneHandling
private Nullable`1<DateParseHandling> _dateParseHandling
private Nullable`1<FloatFormatHandling> _floatFormatHandling
private Nullable`1<FloatParseHandling> _floatParseHandling
private Nullable`1<StringEscapeHandling> _stringEscapeHandling
private CultureInfo _culture
private Nullable`1<int> _maxDepth
private bool _maxDepthSet
private Nullable`1<bool> _checkAdditionalContent
private string _dateFormatString
private bool _dateFormatStringSet
private EventHandler`1<ErrorEventArgs> Error
public IReferenceResolver ReferenceResolver
public SerializationBinder Binder
public ITraceWriter TraceWriter
public IEqualityComparer EqualityComparer
public TypeNameHandling TypeNameHandling
public FormatterAssemblyStyle TypeNameAssemblyFormat
public PreserveReferencesHandling PreserveReferencesHandling
public ReferenceLoopHandling ReferenceLoopHandling
public MissingMemberHandling MissingMemberHandling
public NullValueHandling NullValueHandling
public DefaultValueHandling DefaultValueHandling
public ObjectCreationHandling ObjectCreationHandling
public ConstructorHandling ConstructorHandling
public MetadataPropertyHandling MetadataPropertyHandling
public JsonConverterCollection Converters
public IContractResolver ContractResolver
public StreamingContext Context
public Formatting Formatting
public DateFormatHandling DateFormatHandling
public DateTimeZoneHandling DateTimeZoneHandling
public DateParseHandling DateParseHandling
public FloatParseHandling FloatParseHandling
public FloatFormatHandling FloatFormatHandling
public StringEscapeHandling StringEscapeHandling
public string DateFormatString
public CultureInfo Culture
public Nullable`1<int> MaxDepth
public bool CheckAdditionalContent
public void add_Error(EventHandler`1<ErrorEventArgs> value)
public void remove_Error(EventHandler`1<ErrorEventArgs> value)
public IReferenceResolver get_ReferenceResolver()
public void set_ReferenceResolver(IReferenceResolver value)
public SerializationBinder get_Binder()
public void set_Binder(SerializationBinder value)
public ITraceWriter get_TraceWriter()
public void set_TraceWriter(ITraceWriter value)
public IEqualityComparer get_EqualityComparer()
public void set_EqualityComparer(IEqualityComparer value)
public TypeNameHandling get_TypeNameHandling()
public void set_TypeNameHandling(TypeNameHandling value)
public FormatterAssemblyStyle get_TypeNameAssemblyFormat()
public void set_TypeNameAssemblyFormat(FormatterAssemblyStyle value)
public PreserveReferencesHandling get_PreserveReferencesHandling()
public void set_PreserveReferencesHandling(PreserveReferencesHandling value)
public ReferenceLoopHandling get_ReferenceLoopHandling()
public void set_ReferenceLoopHandling(ReferenceLoopHandling value)
public MissingMemberHandling get_MissingMemberHandling()
public void set_MissingMemberHandling(MissingMemberHandling value)
public NullValueHandling get_NullValueHandling()
public void set_NullValueHandling(NullValueHandling value)
public DefaultValueHandling get_DefaultValueHandling()
public void set_DefaultValueHandling(DefaultValueHandling value)
public ObjectCreationHandling get_ObjectCreationHandling()
public void set_ObjectCreationHandling(ObjectCreationHandling value)
public ConstructorHandling get_ConstructorHandling()
public void set_ConstructorHandling(ConstructorHandling value)
public MetadataPropertyHandling get_MetadataPropertyHandling()
public void set_MetadataPropertyHandling(MetadataPropertyHandling value)
public JsonConverterCollection get_Converters()
public IContractResolver get_ContractResolver()
public void set_ContractResolver(IContractResolver value)
public StreamingContext get_Context()
public void set_Context(StreamingContext value)
public Formatting get_Formatting()
public void set_Formatting(Formatting value)
public DateFormatHandling get_DateFormatHandling()
public void set_DateFormatHandling(DateFormatHandling value)
public DateTimeZoneHandling get_DateTimeZoneHandling()
public void set_DateTimeZoneHandling(DateTimeZoneHandling value)
public DateParseHandling get_DateParseHandling()
public void set_DateParseHandling(DateParseHandling value)
public FloatParseHandling get_FloatParseHandling()
public void set_FloatParseHandling(FloatParseHandling value)
public FloatFormatHandling get_FloatFormatHandling()
public void set_FloatFormatHandling(FloatFormatHandling value)
public StringEscapeHandling get_StringEscapeHandling()
public void set_StringEscapeHandling(StringEscapeHandling value)
public string get_DateFormatString()
public void set_DateFormatString(string value)
public CultureInfo get_Culture()
public void set_Culture(CultureInfo value)
public Nullable`1<int> get_MaxDepth()
public void set_MaxDepth(Nullable`1<int> value)
public bool get_CheckAdditionalContent()
public void set_CheckAdditionalContent(bool value)
internal bool IsCheckAdditionalContentSet()
public JsonSerializer Create()
public JsonSerializer Create(JsonSerializerSettings settings)
public JsonSerializer CreateDefault()
public JsonSerializer CreateDefault(JsonSerializerSettings settings)
private void ApplySerializerSettings(JsonSerializer serializer, JsonSerializerSettings settings)
public void Populate(TextReader reader, object target)
public void Populate(JsonReader reader, object target)
internal void PopulateInternal(JsonReader reader, object target)
public object Deserialize(JsonReader reader)
public object Deserialize(TextReader reader, Type objectType)
public T Deserialize(JsonReader reader)
public object Deserialize(JsonReader reader, Type objectType)
internal object DeserializeInternal(JsonReader reader, Type objectType)
private void SetupReader(JsonReader reader, CultureInfo& previousCulture, Nullable`1& previousDateTimeZoneHandling, Nullable`1& previousDateParseHandling, Nullable`1& previousFloatParseHandling, Nullable`1& previousMaxDepth, String& previousDateFormatString)
private void ResetReader(JsonReader reader, CultureInfo previousCulture, Nullable`1<DateTimeZoneHandling> previousDateTimeZoneHandling, Nullable`1<DateParseHandling> previousDateParseHandling, Nullable`1<FloatParseHandling> previousFloatParseHandling, Nullable`1<int> previousMaxDepth, string previousDateFormatString)
public void Serialize(TextWriter textWriter, object value)
public void Serialize(JsonWriter jsonWriter, object value, Type objectType)
public void Serialize(TextWriter textWriter, object value, Type objectType)
public void Serialize(JsonWriter jsonWriter, object value)
internal void SerializeInternal(JsonWriter jsonWriter, object value, Type objectType)
internal IReferenceResolver GetReferenceResolver()
internal JsonConverter GetMatchingConverter(Type type)
internal JsonConverter GetMatchingConverter(IList`1<JsonConverter> converters, Type objectType)
internal void OnError(ErrorEventArgs e)
}
public Newtonsoft.Json.JsonSerializerSettings : object {
internal ReferenceLoopHandling DefaultReferenceLoopHandling
internal MissingMemberHandling DefaultMissingMemberHandling
internal NullValueHandling DefaultNullValueHandling
internal DefaultValueHandling DefaultDefaultValueHandling
internal ObjectCreationHandling DefaultObjectCreationHandling
internal PreserveReferencesHandling DefaultPreserveReferencesHandling
internal ConstructorHandling DefaultConstructorHandling
internal TypeNameHandling DefaultTypeNameHandling
internal MetadataPropertyHandling DefaultMetadataPropertyHandling
internal FormatterAssemblyStyle DefaultTypeNameAssemblyFormat
internal StreamingContext DefaultContext
internal Formatting DefaultFormatting
internal DateFormatHandling DefaultDateFormatHandling
internal DateTimeZoneHandling DefaultDateTimeZoneHandling
internal DateParseHandling DefaultDateParseHandling
internal FloatParseHandling DefaultFloatParseHandling
internal FloatFormatHandling DefaultFloatFormatHandling
internal StringEscapeHandling DefaultStringEscapeHandling
internal FormatterAssemblyStyle DefaultFormatterAssemblyStyle
internal CultureInfo DefaultCulture
internal bool DefaultCheckAdditionalContent
internal string DefaultDateFormatString
internal Nullable`1<Formatting> _formatting
internal Nullable`1<DateFormatHandling> _dateFormatHandling
internal Nullable`1<DateTimeZoneHandling> _dateTimeZoneHandling
internal Nullable`1<DateParseHandling> _dateParseHandling
internal Nullable`1<FloatFormatHandling> _floatFormatHandling
internal Nullable`1<FloatParseHandling> _floatParseHandling
internal Nullable`1<StringEscapeHandling> _stringEscapeHandling
internal CultureInfo _culture
internal Nullable`1<bool> _checkAdditionalContent
internal Nullable`1<int> _maxDepth
internal bool _maxDepthSet
internal string _dateFormatString
internal bool _dateFormatStringSet
internal Nullable`1<FormatterAssemblyStyle> _typeNameAssemblyFormat
internal Nullable`1<DefaultValueHandling> _defaultValueHandling
internal Nullable`1<PreserveReferencesHandling> _preserveReferencesHandling
internal Nullable`1<NullValueHandling> _nullValueHandling
internal Nullable`1<ObjectCreationHandling> _objectCreationHandling
internal Nullable`1<MissingMemberHandling> _missingMemberHandling
internal Nullable`1<ReferenceLoopHandling> _referenceLoopHandling
internal Nullable`1<StreamingContext> _context
internal Nullable`1<ConstructorHandling> _constructorHandling
internal Nullable`1<TypeNameHandling> _typeNameHandling
internal Nullable`1<MetadataPropertyHandling> _metadataPropertyHandling
private IList`1<JsonConverter> <Converters>k__BackingField
private IContractResolver <ContractResolver>k__BackingField
private IEqualityComparer <EqualityComparer>k__BackingField
private Func`1<IReferenceResolver> <ReferenceResolverProvider>k__BackingField
private ITraceWriter <TraceWriter>k__BackingField
private SerializationBinder <Binder>k__BackingField
private EventHandler`1<ErrorEventArgs> <Error>k__BackingField
public ReferenceLoopHandling ReferenceLoopHandling
public MissingMemberHandling MissingMemberHandling
public ObjectCreationHandling ObjectCreationHandling
public NullValueHandling NullValueHandling
public DefaultValueHandling DefaultValueHandling
public IList`1<JsonConverter> Converters
public PreserveReferencesHandling PreserveReferencesHandling
public TypeNameHandling TypeNameHandling
public MetadataPropertyHandling MetadataPropertyHandling
public FormatterAssemblyStyle TypeNameAssemblyFormat
public ConstructorHandling ConstructorHandling
public IContractResolver ContractResolver
public IEqualityComparer EqualityComparer
public IReferenceResolver ReferenceResolver
public Func`1<IReferenceResolver> ReferenceResolverProvider
public ITraceWriter TraceWriter
public SerializationBinder Binder
public EventHandler`1<ErrorEventArgs> Error
public StreamingContext Context
public string DateFormatString
public Nullable`1<int> MaxDepth
public Formatting Formatting
public DateFormatHandling DateFormatHandling
public DateTimeZoneHandling DateTimeZoneHandling
public DateParseHandling DateParseHandling
public FloatFormatHandling FloatFormatHandling
public FloatParseHandling FloatParseHandling
public StringEscapeHandling StringEscapeHandling
public CultureInfo Culture
public bool CheckAdditionalContent
public ReferenceLoopHandling get_ReferenceLoopHandling()
public void set_ReferenceLoopHandling(ReferenceLoopHandling value)
public MissingMemberHandling get_MissingMemberHandling()
public void set_MissingMemberHandling(MissingMemberHandling value)
public ObjectCreationHandling get_ObjectCreationHandling()
public void set_ObjectCreationHandling(ObjectCreationHandling value)
public NullValueHandling get_NullValueHandling()
public void set_NullValueHandling(NullValueHandling value)
public DefaultValueHandling get_DefaultValueHandling()
public void set_DefaultValueHandling(DefaultValueHandling value)
public IList`1<JsonConverter> get_Converters()
public void set_Converters(IList`1<JsonConverter> value)
public PreserveReferencesHandling get_PreserveReferencesHandling()
public void set_PreserveReferencesHandling(PreserveReferencesHandling value)
public TypeNameHandling get_TypeNameHandling()
public void set_TypeNameHandling(TypeNameHandling value)
public MetadataPropertyHandling get_MetadataPropertyHandling()
public void set_MetadataPropertyHandling(MetadataPropertyHandling value)
public FormatterAssemblyStyle get_TypeNameAssemblyFormat()
public void set_TypeNameAssemblyFormat(FormatterAssemblyStyle value)
public ConstructorHandling get_ConstructorHandling()
public void set_ConstructorHandling(ConstructorHandling value)
public IContractResolver get_ContractResolver()
public void set_ContractResolver(IContractResolver value)
public IEqualityComparer get_EqualityComparer()
public void set_EqualityComparer(IEqualityComparer value)
public IReferenceResolver get_ReferenceResolver()
public void set_ReferenceResolver(IReferenceResolver value)
public Func`1<IReferenceResolver> get_ReferenceResolverProvider()
public void set_ReferenceResolverProvider(Func`1<IReferenceResolver> value)
public ITraceWriter get_TraceWriter()
public void set_TraceWriter(ITraceWriter value)
public SerializationBinder get_Binder()
public void set_Binder(SerializationBinder value)
public EventHandler`1<ErrorEventArgs> get_Error()
public void set_Error(EventHandler`1<ErrorEventArgs> value)
public StreamingContext get_Context()
public void set_Context(StreamingContext value)
public string get_DateFormatString()
public void set_DateFormatString(string value)
public Nullable`1<int> get_MaxDepth()
public void set_MaxDepth(Nullable`1<int> value)
public Formatting get_Formatting()
public void set_Formatting(Formatting value)
public DateFormatHandling get_DateFormatHandling()
public void set_DateFormatHandling(DateFormatHandling value)
public DateTimeZoneHandling get_DateTimeZoneHandling()
public void set_DateTimeZoneHandling(DateTimeZoneHandling value)
public DateParseHandling get_DateParseHandling()
public void set_DateParseHandling(DateParseHandling value)
public FloatFormatHandling get_FloatFormatHandling()
public void set_FloatFormatHandling(FloatFormatHandling value)
public FloatParseHandling get_FloatParseHandling()
public void set_FloatParseHandling(FloatParseHandling value)
public StringEscapeHandling get_StringEscapeHandling()
public void set_StringEscapeHandling(StringEscapeHandling value)
public CultureInfo get_Culture()
public void set_Culture(CultureInfo value)
public bool get_CheckAdditionalContent()
public void set_CheckAdditionalContent(bool value)
}
public Newtonsoft.Json.JsonTextReader : JsonReader {
private char UnicodeReplacementChar
private int MaximumJavascriptIntegerCharacterLength
private TextReader _reader
private Char[] _chars
private int _charsUsed
private int _charPos
private int _lineStartPos
private int _lineNumber
private bool _isEndOfFile
private StringBuffer _stringBuffer
private StringReference _stringReference
private IArrayPool`1<char> _arrayPool
internal PropertyNameTable NameTable
public IArrayPool`1<char> ArrayPool
public int LineNumber
public int LinePosition
public void .ctor(TextReader reader)
public IArrayPool`1<char> get_ArrayPool()
public void set_ArrayPool(IArrayPool`1<char> value)
private void EnsureBufferNotEmpty()
private void OnNewLine(int pos)
private void ParseString(char quote, ReadType readType)
private void BlockCopyChars(Char[] src, int srcOffset, Char[] dst, int dstOffset, int count)
private void ShiftBufferIfNeeded()
private int ReadData(bool append)
private int ReadData(bool append, int charsRequired)
private bool EnsureChars(int relativePosition, bool append)
private bool ReadChars(int relativePosition, bool append)
public bool Read()
public Nullable`1<int> ReadAsInt32()
public Nullable`1<DateTime> ReadAsDateTime()
public string ReadAsString()
public Byte[] ReadAsBytes()
private object ReadStringValue(ReadType readType)
private JsonReaderException CreateUnexpectedCharacterException(char c)
public Nullable`1<bool> ReadAsBoolean()
private void ProcessValueComma()
private object ReadNumberValue(ReadType readType)
public Nullable`1<DateTimeOffset> ReadAsDateTimeOffset()
public Nullable`1<decimal> ReadAsDecimal()
public Nullable`1<double> ReadAsDouble()
private void HandleNull()
private void ReadFinished()
private bool ReadNullChar()
private void EnsureBuffer()
private void ReadStringIntoBuffer(char quote)
private void WriteCharToBuffer(char writeChar, int lastWritePosition, int writeToPosition)
private char ParseUnicode()
private void ReadNumberIntoBuffer()
private void ClearRecentString()
private bool ParsePostValue()
private bool ParseObject()
private bool ParseProperty()
private bool ValidIdentifierChar(char value)
private void ParseUnquotedProperty()
private bool ParseValue()
private void ProcessLineFeed()
private void ProcessCarriageReturn(bool append)
private bool EatWhitespace(bool oneOrMore)
private void ParseConstructor()
private void ParseNumber(ReadType readType)
private void ParseComment(bool setToken)
private void EndComment(bool setToken, int initialPosition, int endPosition)
private bool MatchValue(string value)
private bool MatchValueWithTrailingSeparator(string value)
private bool IsSeparator(char c)
private void ParseTrue()
private void ParseNull()
private void ParseUndefined()
private void ParseFalse()
private object ParseNumberNegativeInfinity(ReadType readType)
private object ParseNumberPositiveInfinity(ReadType readType)
private object ParseNumberNaN(ReadType readType)
public void Close()
public bool HasLineInfo()
public int get_LineNumber()
public int get_LinePosition()
}
public Newtonsoft.Json.JsonTextWriter : JsonWriter {
private TextWriter _writer
private Base64Encoder _base64Encoder
private char _indentChar
private int _indentation
private char _quoteChar
private bool _quoteName
private Boolean[] _charEscapeFlags
private Char[] _writeBuffer
private IArrayPool`1<char> _arrayPool
private Char[] _indentChars
private Base64Encoder Base64Encoder
public IArrayPool`1<char> ArrayPool
public int Indentation
public char QuoteChar
public char IndentChar
public bool QuoteName
private Base64Encoder get_Base64Encoder()
public IArrayPool`1<char> get_ArrayPool()
public void set_ArrayPool(IArrayPool`1<char> value)
public int get_Indentation()
public void set_Indentation(int value)
public char get_QuoteChar()
public void set_QuoteChar(char value)
public char get_IndentChar()
public void set_IndentChar(char value)
public bool get_QuoteName()
public void set_QuoteName(bool value)
public void .ctor(TextWriter textWriter)
public void Flush()
public void Close()
public void WriteStartObject()
public void WriteStartArray()
public void WriteStartConstructor(string name)
protected void WriteEnd(JsonToken token)
public void WritePropertyName(string name)
public void WritePropertyName(string name, bool escape)
internal void OnStringEscapeHandlingChanged()
private void UpdateCharEscapeFlags()
protected void WriteIndent()
protected void WriteValueDelimiter()
protected void WriteIndentSpace()
private void WriteValueInternal(string value, JsonToken token)
public void WriteValue(object value)
public void WriteNull()
public void WriteUndefined()
public void WriteRaw(string json)
public void WriteValue(string value)
private void WriteEscapedString(string value, bool quote)
public void WriteValue(int value)
public void WriteValue(UInt32 value)
public void WriteValue(long value)
public void WriteValue(ulong value)
public void WriteValue(float value)
public void WriteValue(Nullable`1<float> value)
public void WriteValue(double value)
public void WriteValue(Nullable`1<double> value)
public void WriteValue(bool value)
public void WriteValue(short value)
public void WriteValue(ushort value)
public void WriteValue(char value)
public void WriteValue(byte value)
public void WriteValue(sbyte value)
public void WriteValue(decimal value)
public void WriteValue(DateTime value)
public void WriteValue(Byte[] value)
public void WriteValue(DateTimeOffset value)
public void WriteValue(Guid value)
public void WriteValue(TimeSpan value)
public void WriteValue(Uri value)
public void WriteComment(string text)
public void WriteWhitespace(string ws)
private void EnsureWriteBuffer()
private void WriteIntegerValue(long value)
private void WriteIntegerValue(ulong uvalue)
}
public Newtonsoft.Json.JsonToken : Enum {
public int value__
public JsonToken None
public JsonToken StartObject
public JsonToken StartArray
public JsonToken StartConstructor
public JsonToken PropertyName
public JsonToken Comment
public JsonToken Raw
public JsonToken Integer
public JsonToken Float
public JsonToken String
public JsonToken Boolean
public JsonToken Null
public JsonToken Undefined
public JsonToken EndObject
public JsonToken EndArray
public JsonToken EndConstructor
public JsonToken Date
public JsonToken Bytes
}
public Newtonsoft.Json.JsonWriter : object {
private State[][] StateArray
internal State[][] StateArrayTempate
private List`1<JsonPosition> _stack
private JsonPosition _currentPosition
private State _currentState
private Formatting _formatting
private bool <CloseOutput>k__BackingField
private DateFormatHandling _dateFormatHandling
private DateTimeZoneHandling _dateTimeZoneHandling
private StringEscapeHandling _stringEscapeHandling
private FloatFormatHandling _floatFormatHandling
private string _dateFormatString
private CultureInfo _culture
public bool CloseOutput
protected internal int Top
public WriteState WriteState
internal string ContainerPath
public string Path
public Formatting Formatting
public DateFormatHandling DateFormatHandling
public DateTimeZoneHandling DateTimeZoneHandling
public StringEscapeHandling StringEscapeHandling
public FloatFormatHandling FloatFormatHandling
public string DateFormatString
public CultureInfo Culture
internal State[][] BuildStateArray()
public bool get_CloseOutput()
public void set_CloseOutput(bool value)
protected internal int get_Top()
public WriteState get_WriteState()
internal string get_ContainerPath()
public string get_Path()
public Formatting get_Formatting()
public void set_Formatting(Formatting value)
public DateFormatHandling get_DateFormatHandling()
public void set_DateFormatHandling(DateFormatHandling value)
public DateTimeZoneHandling get_DateTimeZoneHandling()
public void set_DateTimeZoneHandling(DateTimeZoneHandling value)
public StringEscapeHandling get_StringEscapeHandling()
public void set_StringEscapeHandling(StringEscapeHandling value)
internal void OnStringEscapeHandlingChanged()
public FloatFormatHandling get_FloatFormatHandling()
public void set_FloatFormatHandling(FloatFormatHandling value)
public string get_DateFormatString()
public void set_DateFormatString(string value)
public CultureInfo get_Culture()
public void set_Culture(CultureInfo value)
internal void UpdateScopeWithFinishedValue()
private void Push(JsonContainerType value)
private JsonContainerType Pop()
private JsonContainerType Peek()
public void Flush()
public void Close()
public void WriteStartObject()
public void WriteEndObject()
public void WriteStartArray()
public void WriteEndArray()
public void WriteStartConstructor(string name)
public void WriteEndConstructor()
public void WritePropertyName(string name)
public void WritePropertyName(string name, bool escape)
public void WriteEnd()
public void WriteToken(JsonReader reader)
public void WriteToken(JsonReader reader, bool writeChildren)
public void WriteToken(JsonToken token, object value)
public void WriteToken(JsonToken token)
internal void WriteToken(JsonReader reader, bool writeChildren, bool writeDateConstructorAsDate, bool writeComments)
private void WriteConstructorDate(JsonReader reader)
private void WriteEnd(JsonContainerType type)
private void AutoCompleteAll()
private JsonToken GetCloseTokenForType(JsonContainerType type)
private void AutoCompleteClose(JsonContainerType type)
protected void WriteEnd(JsonToken token)
protected void WriteIndent()
protected void WriteValueDelimiter()
protected void WriteIndentSpace()
internal void AutoComplete(JsonToken tokenBeingWritten)
public void WriteNull()
public void WriteUndefined()
public void WriteRaw(string json)
public void WriteRawValue(string json)
public void WriteValue(string value)
public void WriteValue(int value)
public void WriteValue(UInt32 value)
public void WriteValue(long value)
public void WriteValue(ulong value)
public void WriteValue(float value)
public void WriteValue(double value)
public void WriteValue(bool value)
public void WriteValue(short value)
public void WriteValue(ushort value)
public void WriteValue(char value)
public void WriteValue(byte value)
public void WriteValue(sbyte value)
public void WriteValue(decimal value)
public void WriteValue(DateTime value)
public void WriteValue(DateTimeOffset value)
public void WriteValue(Guid value)
public void WriteValue(TimeSpan value)
public void WriteValue(Nullable`1<int> value)
public void WriteValue(Nullable`1<UInt32> value)
public void WriteValue(Nullable`1<long> value)
public void WriteValue(Nullable`1<ulong> value)
public void WriteValue(Nullable`1<float> value)
public void WriteValue(Nullable`1<double> value)
public void WriteValue(Nullable`1<bool> value)
public void WriteValue(Nullable`1<short> value)
public void WriteValue(Nullable`1<ushort> value)
public void WriteValue(Nullable`1<char> value)
public void WriteValue(Nullable`1<byte> value)
public void WriteValue(Nullable`1<sbyte> value)
public void WriteValue(Nullable`1<decimal> value)
public void WriteValue(Nullable`1<DateTime> value)
public void WriteValue(Nullable`1<DateTimeOffset> value)
public void WriteValue(Nullable`1<Guid> value)
public void WriteValue(Nullable`1<TimeSpan> value)
public void WriteValue(Byte[] value)
public void WriteValue(Uri value)
public void WriteValue(object value)
public void WriteComment(string text)
public void WriteWhitespace(string ws)
private void System.IDisposable.Dispose()
protected void Dispose(bool disposing)
internal void WriteValue(JsonWriter writer, PrimitiveTypeCode typeCode, object value)
private JsonWriterException CreateUnsupportedTypeException(JsonWriter writer, object value)
protected void SetWriteState(JsonToken token, object value)
internal void InternalWriteEnd(JsonContainerType container)
internal void InternalWritePropertyName(string name)
internal void InternalWriteRaw()
internal void InternalWriteStart(JsonToken token, JsonContainerType container)
internal void InternalWriteValue(JsonToken token)
internal void InternalWriteWhitespace(string ws)
internal void InternalWriteComment()
}
public Newtonsoft.Json.JsonWriterException : JsonException {
private string <Path>k__BackingField
public string Path
public string get_Path()
private void set_Path(string value)
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
public void .ctor(SerializationInfo info, StreamingContext context)
internal void .ctor(string message, Exception innerException, string path)
internal JsonWriterException Create(JsonWriter writer, string message, Exception ex)
internal JsonWriterException Create(string path, string message, Exception ex)
}
public Newtonsoft.Json.Linq.CommentHandling : Enum {
public int value__
public CommentHandling Ignore
public CommentHandling Load
}
public Newtonsoft.Json.Linq.Extensions : object {
public IJEnumerable`1<JToken> Ancestors(IEnumerable`1<T> source)
public IJEnumerable`1<JToken> AncestorsAndSelf(IEnumerable`1<T> source)
public IJEnumerable`1<JToken> Descendants(IEnumerable`1<T> source)
public IJEnumerable`1<JToken> DescendantsAndSelf(IEnumerable`1<T> source)
public IJEnumerable`1<JProperty> Properties(IEnumerable`1<JObject> source)
public IJEnumerable`1<JToken> Values(IEnumerable`1<JToken> source, object key)
public IJEnumerable`1<JToken> Values(IEnumerable`1<JToken> source)
public IEnumerable`1<U> Values(IEnumerable`1<JToken> source, object key)
public IEnumerable`1<U> Values(IEnumerable`1<JToken> source)
public U Value(IEnumerable`1<JToken> value)
public U Value(IEnumerable`1<T> value)
internal IEnumerable`1<U> Values(IEnumerable`1<T> source, object key)
public IJEnumerable`1<JToken> Children(IEnumerable`1<T> source)
public IEnumerable`1<U> Children(IEnumerable`1<T> source)
internal IEnumerable`1<U> Convert(IEnumerable`1<T> source)
internal U Convert(T token)
public IJEnumerable`1<JToken> AsJEnumerable(IEnumerable`1<JToken> source)
public IJEnumerable`1<T> AsJEnumerable(IEnumerable`1<T> source)
}
public Newtonsoft.Json.Linq.IJEnumerable`1 {
public IJEnumerable`1<JToken> Item
public IJEnumerable`1<JToken> get_Item(object key)
}
public Newtonsoft.Json.Linq.JArray : JContainer {
private List`1<JToken> _values
protected IList`1<JToken> ChildrenTokens
public JTokenType Type
public JToken Item
public JToken Item
public bool IsReadOnly
protected IList`1<JToken> get_ChildrenTokens()
public JTokenType get_Type()
public void .ctor(JArray other)
public void .ctor(Object[] content)
public void .ctor(object content)
internal bool DeepEquals(JToken node)
internal JToken CloneToken()
public JArray Load(JsonReader reader)
public JArray Load(JsonReader reader, JsonLoadSettings settings)
public JArray Parse(string json)
public JArray Parse(string json, JsonLoadSettings settings)
public JArray FromObject(object o)
public JArray FromObject(object o, JsonSerializer jsonSerializer)
public void WriteTo(JsonWriter writer, JsonConverter[] converters)
public JToken get_Item(object key)
public void set_Item(object key, JToken value)
public JToken get_Item(int index)
public void set_Item(int index, JToken value)
internal int IndexOfItem(JToken item)
internal void MergeItem(object content, JsonMergeSettings settings)
public int IndexOf(JToken item)
public void Insert(int index, JToken item)
public void RemoveAt(int index)
public IEnumerator`1<JToken> GetEnumerator()
public void Add(JToken item)
public void Clear()
public bool Contains(JToken item)
public void CopyTo(JToken[] array, int arrayIndex)
public bool get_IsReadOnly()
public bool Remove(JToken item)
internal int GetDeepHashCode()
}
public Newtonsoft.Json.Linq.JConstructor : JContainer {
private string _name
private List`1<JToken> _values
protected IList`1<JToken> ChildrenTokens
public string Name
public JTokenType Type
public JToken Item
protected IList`1<JToken> get_ChildrenTokens()
internal int IndexOfItem(JToken item)
internal void MergeItem(object content, JsonMergeSettings settings)
public string get_Name()
public void set_Name(string value)
public JTokenType get_Type()
public void .ctor(JConstructor other)
public void .ctor(string name, Object[] content)
public void .ctor(string name, object content)
public void .ctor(string name)
internal bool DeepEquals(JToken node)
internal JToken CloneToken()
public void WriteTo(JsonWriter writer, JsonConverter[] converters)
public JToken get_Item(object key)
public void set_Item(object key, JToken value)
internal int GetDeepHashCode()
public JConstructor Load(JsonReader reader)
public JConstructor Load(JsonReader reader, JsonLoadSettings settings)
}
public Newtonsoft.Json.Linq.JContainer : JToken {
internal ListChangedEventHandler _listChanged
internal AddingNewEventHandler _addingNew
private object _syncRoot
private bool _busy
protected IList`1<JToken> ChildrenTokens
public bool HasValues
public JToken First
public JToken Last
private JToken System.Collections.Generic.IList<Newtonsoft.Json.Linq.JToken>.Item
private bool System.Collections.Generic.ICollection<Newtonsoft.Json.Linq.JToken>.IsReadOnly
private bool System.Collections.IList.IsFixedSize
private bool System.Collections.IList.IsReadOnly
private object System.Collections.IList.Item
public int Count
private bool System.Collections.ICollection.IsSynchronized
private object System.Collections.ICollection.SyncRoot
private bool System.ComponentModel.IBindingList.AllowEdit
private bool System.ComponentModel.IBindingList.AllowNew
private bool System.ComponentModel.IBindingList.AllowRemove
private bool System.ComponentModel.IBindingList.IsSorted
private ListSortDirection System.ComponentModel.IBindingList.SortDirection
private PropertyDescriptor System.ComponentModel.IBindingList.SortProperty
private bool System.ComponentModel.IBindingList.SupportsChangeNotification
private bool System.ComponentModel.IBindingList.SupportsSearching
private bool System.ComponentModel.IBindingList.SupportsSorting
public void add_ListChanged(ListChangedEventHandler value)
public void remove_ListChanged(ListChangedEventHandler value)
public void add_AddingNew(AddingNewEventHandler value)
public void remove_AddingNew(AddingNewEventHandler value)
protected IList`1<JToken> get_ChildrenTokens()
internal void .ctor(JContainer other)
internal void CheckReentrancy()
internal IList`1<JToken> CreateChildrenCollection()
protected void OnAddingNew(AddingNewEventArgs e)
protected void OnListChanged(ListChangedEventArgs e)
public bool get_HasValues()
internal bool ContentsEqual(JContainer container)
public JToken get_First()
public JToken get_Last()
public JEnumerable`1<JToken> Children()
public IEnumerable`1<T> Values()
public IEnumerable`1<JToken> Descendants()
public IEnumerable`1<JToken> DescendantsAndSelf()
internal IEnumerable`1<JToken> GetDescendants(bool self)
internal bool IsMultiContent(object content)
internal JToken EnsureParentToken(JToken item, bool skipParentCheck)
internal int IndexOfItem(JToken item)
internal void InsertItem(int index, JToken item, bool skipParentCheck)
internal void RemoveItemAt(int index)
internal bool RemoveItem(JToken item)
internal JToken GetItem(int index)
internal void SetItem(int index, JToken item)
internal void ClearItems()
internal void ReplaceItem(JToken existing, JToken replacement)
internal bool ContainsItem(JToken item)
internal void CopyItemsTo(Array array, int arrayIndex)
internal bool IsTokenUnchanged(JToken currentValue, JToken newValue)
internal void ValidateToken(JToken o, JToken existing)
public void Add(object content)
internal void AddAndSkipParentCheck(JToken token)
public void AddFirst(object content)
internal void AddInternal(int index, object content, bool skipParentCheck)
internal JToken CreateFromContent(object content)
public JsonWriter CreateWriter()
public void ReplaceAll(object content)
public void RemoveAll()
internal void MergeItem(object content, JsonMergeSettings settings)
public void Merge(object content)
public void Merge(object content, JsonMergeSettings settings)
internal void ReadTokenFrom(JsonReader reader, JsonLoadSettings options)
internal void ReadContentFrom(JsonReader r, JsonLoadSettings settings)
internal int ContentsHashCode()
private string System.ComponentModel.ITypedList.GetListName(PropertyDescriptor[] listAccessors)
private PropertyDescriptorCollection System.ComponentModel.ITypedList.GetItemProperties(PropertyDescriptor[] listAccessors)
private int System.Collections.Generic.IList<Newtonsoft.Json.Linq.JToken>.IndexOf(JToken item)
private void System.Collections.Generic.IList<Newtonsoft.Json.Linq.JToken>.Insert(int index, JToken item)
private void System.Collections.Generic.IList<Newtonsoft.Json.Linq.JToken>.RemoveAt(int index)
private JToken System.Collections.Generic.IList<Newtonsoft.Json.Linq.JToken>.get_Item(int index)
private void System.Collections.Generic.IList<Newtonsoft.Json.Linq.JToken>.set_Item(int index, JToken value)
private void System.Collections.Generic.ICollection<Newtonsoft.Json.Linq.JToken>.Add(JToken item)
private void System.Collections.Generic.ICollection<Newtonsoft.Json.Linq.JToken>.Clear()
private bool System.Collections.Generic.ICollection<Newtonsoft.Json.Linq.JToken>.Contains(JToken item)
private void System.Collections.Generic.ICollection<Newtonsoft.Json.Linq.JToken>.CopyTo(JToken[] array, int arrayIndex)
private bool System.Collections.Generic.ICollection<Newtonsoft.Json.Linq.JToken>.get_IsReadOnly()
private bool System.Collections.Generic.ICollection<Newtonsoft.Json.Linq.JToken>.Remove(JToken item)
private JToken EnsureValue(object value)
private int System.Collections.IList.Add(object value)
private void System.Collections.IList.Clear()
private bool System.Collections.IList.Contains(object value)
private int System.Collections.IList.IndexOf(object value)
private void System.Collections.IList.Insert(int index, object value)
private bool System.Collections.IList.get_IsFixedSize()
private bool System.Collections.IList.get_IsReadOnly()
private void System.Collections.IList.Remove(object value)
private void System.Collections.IList.RemoveAt(int index)
private object System.Collections.IList.get_Item(int index)
private void System.Collections.IList.set_Item(int index, object value)
private void System.Collections.ICollection.CopyTo(Array array, int index)
public int get_Count()
private bool System.Collections.ICollection.get_IsSynchronized()
private object System.Collections.ICollection.get_SyncRoot()
private void System.ComponentModel.IBindingList.AddIndex(PropertyDescriptor property)
private object System.ComponentModel.IBindingList.AddNew()
private bool System.ComponentModel.IBindingList.get_AllowEdit()
private bool System.ComponentModel.IBindingList.get_AllowNew()
private bool System.ComponentModel.IBindingList.get_AllowRemove()
private void System.ComponentModel.IBindingList.ApplySort(PropertyDescriptor property, ListSortDirection direction)
private int System.ComponentModel.IBindingList.Find(PropertyDescriptor property, object key)
private bool System.ComponentModel.IBindingList.get_IsSorted()
private void System.ComponentModel.IBindingList.RemoveIndex(PropertyDescriptor property)
private void System.ComponentModel.IBindingList.RemoveSort()
private ListSortDirection System.ComponentModel.IBindingList.get_SortDirection()
private PropertyDescriptor System.ComponentModel.IBindingList.get_SortProperty()
private bool System.ComponentModel.IBindingList.get_SupportsChangeNotification()
private bool System.ComponentModel.IBindingList.get_SupportsSearching()
private bool System.ComponentModel.IBindingList.get_SupportsSorting()
internal void MergeEnumerableContent(JContainer target, IEnumerable content, JsonMergeSettings settings)
}
public Newtonsoft.Json.Linq.JEnumerable`1 : ValueType {
public JEnumerable`1<T> Empty
private IEnumerable`1<T> _enumerable
public IJEnumerable`1<JToken> Item
public void .ctor(IEnumerable`1<T> enumerable)
public IEnumerator`1<T> GetEnumerator()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
public IJEnumerable`1<JToken> get_Item(object key)
public bool Equals(JEnumerable`1<T> other)
public bool Equals(object obj)
public int GetHashCode()
}
public Newtonsoft.Json.Linq.JObject : JContainer {
private JPropertyKeyedCollection _properties
private PropertyChangedEventHandler PropertyChanged
private PropertyChangingEventHandler PropertyChanging
protected IList`1<JToken> ChildrenTokens
public JTokenType Type
public JToken Item
public JToken Item
private ICollection`1<string> System.Collections.Generic.IDictionary<System.String,Newtonsoft.Json.Linq.JToken>.Keys
private ICollection`1<JToken> System.Collections.Generic.IDictionary<System.String,Newtonsoft.Json.Linq.JToken>.Values
private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,Newtonsoft.Json.Linq.JToken>>.IsReadOnly
protected IList`1<JToken> get_ChildrenTokens()
public void add_PropertyChanged(PropertyChangedEventHandler value)
public void remove_PropertyChanged(PropertyChangedEventHandler value)
public void add_PropertyChanging(PropertyChangingEventHandler value)
public void remove_PropertyChanging(PropertyChangingEventHandler value)
public void .ctor(JObject other)
public void .ctor(Object[] content)
public void .ctor(object content)
internal bool DeepEquals(JToken node)
internal int IndexOfItem(JToken item)
internal void InsertItem(int index, JToken item, bool skipParentCheck)
internal void ValidateToken(JToken o, JToken existing)
internal void MergeItem(object content, JsonMergeSettings settings)
internal void InternalPropertyChanged(JProperty childProperty)
internal void InternalPropertyChanging(JProperty childProperty)
internal JToken CloneToken()
public JTokenType get_Type()
public IEnumerable`1<JProperty> Properties()
public JProperty Property(string name)
public JEnumerable`1<JToken> PropertyValues()
public JToken get_Item(object key)
public void set_Item(object key, JToken value)
public JToken get_Item(string propertyName)
public void set_Item(string propertyName, JToken value)
public JObject Load(JsonReader reader)
public JObject Load(JsonReader reader, JsonLoadSettings settings)
public JObject Parse(string json)
public JObject Parse(string json, JsonLoadSettings settings)
public JObject FromObject(object o)
public JObject FromObject(object o, JsonSerializer jsonSerializer)
public void WriteTo(JsonWriter writer, JsonConverter[] converters)
public JToken GetValue(string propertyName)
public JToken GetValue(string propertyName, StringComparison comparison)
public bool TryGetValue(string propertyName, StringComparison comparison, JToken& value)
public void Add(string propertyName, JToken value)
private bool System.Collections.Generic.IDictionary<System.String,Newtonsoft.Json.Linq.JToken>.ContainsKey(string key)
private ICollection`1<string> System.Collections.Generic.IDictionary<System.String,Newtonsoft.Json.Linq.JToken>.get_Keys()
public bool Remove(string propertyName)
public bool TryGetValue(string propertyName, JToken& value)
private ICollection`1<JToken> System.Collections.Generic.IDictionary<System.String,Newtonsoft.Json.Linq.JToken>.get_Values()
private void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,Newtonsoft.Json.Linq.JToken>>.Add(KeyValuePair`2<string, JToken> item)
private void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,Newtonsoft.Json.Linq.JToken>>.Clear()
private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,Newtonsoft.Json.Linq.JToken>>.Contains(KeyValuePair`2<string, JToken> item)
private void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,Newtonsoft.Json.Linq.JToken>>.CopyTo(KeyValuePair`2[] array, int arrayIndex)
private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,Newtonsoft.Json.Linq.JToken>>.get_IsReadOnly()
private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,Newtonsoft.Json.Linq.JToken>>.Remove(KeyValuePair`2<string, JToken> item)
internal int GetDeepHashCode()
public IEnumerator`1<KeyValuePair`2<string, JToken>> GetEnumerator()
protected void OnPropertyChanged(string propertyName)
protected void OnPropertyChanging(string propertyName)
private PropertyDescriptorCollection System.ComponentModel.ICustomTypeDescriptor.GetProperties()
private PropertyDescriptorCollection System.ComponentModel.ICustomTypeDescriptor.GetProperties(Attribute[] attributes)
private AttributeCollection System.ComponentModel.ICustomTypeDescriptor.GetAttributes()
private string System.ComponentModel.ICustomTypeDescriptor.GetClassName()
private string System.ComponentModel.ICustomTypeDescriptor.GetComponentName()
private TypeConverter System.ComponentModel.ICustomTypeDescriptor.GetConverter()
private EventDescriptor System.ComponentModel.ICustomTypeDescriptor.GetDefaultEvent()
private PropertyDescriptor System.ComponentModel.ICustomTypeDescriptor.GetDefaultProperty()
private object System.ComponentModel.ICustomTypeDescriptor.GetEditor(Type editorBaseType)
private EventDescriptorCollection System.ComponentModel.ICustomTypeDescriptor.GetEvents(Attribute[] attributes)
private EventDescriptorCollection System.ComponentModel.ICustomTypeDescriptor.GetEvents()
private object System.ComponentModel.ICustomTypeDescriptor.GetPropertyOwner(PropertyDescriptor pd)
}
public Newtonsoft.Json.Linq.JProperty : JContainer {
private JPropertyList _content
private string _name
protected IList`1<JToken> ChildrenTokens
public string Name
public JToken Value
public JTokenType Type
protected IList`1<JToken> get_ChildrenTokens()
public string get_Name()
public JToken get_Value()
public void set_Value(JToken value)
public void .ctor(JProperty other)
internal JToken GetItem(int index)
internal void SetItem(int index, JToken item)
internal bool RemoveItem(JToken item)
internal void RemoveItemAt(int index)
internal int IndexOfItem(JToken item)
internal void InsertItem(int index, JToken item, bool skipParentCheck)
internal bool ContainsItem(JToken item)
internal void MergeItem(object content, JsonMergeSettings settings)
internal void ClearItems()
internal bool DeepEquals(JToken node)
internal JToken CloneToken()
public JTokenType get_Type()
internal void .ctor(string name)
public void .ctor(string name, Object[] content)
public void .ctor(string name, object content)
public void WriteTo(JsonWriter writer, JsonConverter[] converters)
internal int GetDeepHashCode()
public JProperty Load(JsonReader reader)
public JProperty Load(JsonReader reader, JsonLoadSettings settings)
}
public Newtonsoft.Json.Linq.JPropertyDescriptor : PropertyDescriptor {
public Type ComponentType
public bool IsReadOnly
public Type PropertyType
protected int NameHashCode
public void .ctor(string name)
private JObject CastInstance(object instance)
public bool CanResetValue(object component)
public object GetValue(object component)
public void ResetValue(object component)
public void SetValue(object component, object value)
public bool ShouldSerializeValue(object component)
public Type get_ComponentType()
public bool get_IsReadOnly()
public Type get_PropertyType()
protected int get_NameHashCode()
}
internal Newtonsoft.Json.Linq.JPropertyKeyedCollection : Collection`1<JToken> {
private IEqualityComparer`1<string> Comparer
private Dictionary`2<string, JToken> _dictionary
public JToken Item
public ICollection`1<string> Keys
public ICollection`1<JToken> Values
private void AddKey(string key, JToken item)
protected void ChangeItemKey(JToken item, string newKey)
protected void ClearItems()
public bool Contains(string key)
private bool ContainsItem(JToken item)
private void EnsureDictionary()
private string GetKeyForItem(JToken item)
protected void InsertItem(int index, JToken item)
public bool Remove(string key)
protected void RemoveItem(int index)
private void RemoveKey(string key)
protected void SetItem(int index, JToken item)
public JToken get_Item(string key)
public bool TryGetValue(string key, JToken& value)
public ICollection`1<string> get_Keys()
public ICollection`1<JToken> get_Values()
public int IndexOfReference(JToken t)
public bool Compare(JPropertyKeyedCollection other)
}
public Newtonsoft.Json.Linq.JRaw : JValue {
public void .ctor(JRaw other)
public void .ctor(object rawJson)
public JRaw Create(JsonReader reader)
internal JToken CloneToken()
}
public Newtonsoft.Json.Linq.JsonLoadSettings : object {
private CommentHandling _commentHandling
private LineInfoHandling _lineInfoHandling
public CommentHandling CommentHandling
public LineInfoHandling LineInfoHandling
public CommentHandling get_CommentHandling()
public void set_CommentHandling(CommentHandling value)
public LineInfoHandling get_LineInfoHandling()
public void set_LineInfoHandling(LineInfoHandling value)
}
public Newtonsoft.Json.Linq.JsonMergeSettings : object {
private MergeArrayHandling _mergeArrayHandling
private MergeNullValueHandling _mergeNullValueHandling
public MergeArrayHandling MergeArrayHandling
public MergeNullValueHandling MergeNullValueHandling
public MergeArrayHandling get_MergeArrayHandling()
public void set_MergeArrayHandling(MergeArrayHandling value)
public MergeNullValueHandling get_MergeNullValueHandling()
public void set_MergeNullValueHandling(MergeNullValueHandling value)
}
internal Newtonsoft.Json.Linq.JsonPath.ArrayIndexFilter : PathFilter {
private Nullable`1<int> <Index>k__BackingField
public Nullable`1<int> Index
public Nullable`1<int> get_Index()
public void set_Index(Nullable`1<int> value)
public IEnumerable`1<JToken> ExecuteFilter(IEnumerable`1<JToken> current, bool errorWhenNoMatch)
}
internal Newtonsoft.Json.Linq.JsonPath.ArrayMultipleIndexFilter : PathFilter {
private List`1<int> <Indexes>k__BackingField
public List`1<int> Indexes
public List`1<int> get_Indexes()
public void set_Indexes(List`1<int> value)
public IEnumerable`1<JToken> ExecuteFilter(IEnumerable`1<JToken> current, bool errorWhenNoMatch)
}
internal Newtonsoft.Json.Linq.JsonPath.ArraySliceFilter : PathFilter {
private Nullable`1<int> <Start>k__BackingField
private Nullable`1<int> <End>k__BackingField
private Nullable`1<int> <Step>k__BackingField
public Nullable`1<int> Start
public Nullable`1<int> End
public Nullable`1<int> Step
public Nullable`1<int> get_Start()
public void set_Start(Nullable`1<int> value)
public Nullable`1<int> get_End()
public void set_End(Nullable`1<int> value)
public Nullable`1<int> get_Step()
public void set_Step(Nullable`1<int> value)
public IEnumerable`1<JToken> ExecuteFilter(IEnumerable`1<JToken> current, bool errorWhenNoMatch)
private bool IsValid(int index, int stopIndex, bool positiveStep)
}
internal Newtonsoft.Json.Linq.JsonPath.BooleanQueryExpression : QueryExpression {
private List`1<PathFilter> <Path>k__BackingField
private JValue <Value>k__BackingField
public List`1<PathFilter> Path
public JValue Value
public List`1<PathFilter> get_Path()
public void set_Path(List`1<PathFilter> value)
public JValue get_Value()
public void set_Value(JValue value)
public bool IsMatch(JToken t)
private bool EqualsWithStringCoercion(JValue value, JValue queryValue)
}
internal Newtonsoft.Json.Linq.JsonPath.CompositeExpression : QueryExpression {
private List`1<QueryExpression> <Expressions>k__BackingField
public List`1<QueryExpression> Expressions
public List`1<QueryExpression> get_Expressions()
public void set_Expressions(List`1<QueryExpression> value)
public bool IsMatch(JToken t)
}
internal Newtonsoft.Json.Linq.JsonPath.FieldFilter : PathFilter {
private string <Name>k__BackingField
public string Name
public string get_Name()
public void set_Name(string value)
public IEnumerable`1<JToken> ExecuteFilter(IEnumerable`1<JToken> current, bool errorWhenNoMatch)
}
internal Newtonsoft.Json.Linq.JsonPath.FieldMultipleFilter : PathFilter {
private List`1<string> <Names>k__BackingField
public List`1<string> Names
public List`1<string> get_Names()
public void set_Names(List`1<string> value)
public IEnumerable`1<JToken> ExecuteFilter(IEnumerable`1<JToken> current, bool errorWhenNoMatch)
}
internal Newtonsoft.Json.Linq.JsonPath.JPath : object {
private string _expression
private List`1<PathFilter> <Filters>k__BackingField
private int _currentIndex
public List`1<PathFilter> Filters
public List`1<PathFilter> get_Filters()
private void set_Filters(List`1<PathFilter> value)
public void .ctor(string expression)
private void ParseMain()
private bool ParsePath(List`1<PathFilter> filters, int currentPartStartIndex, bool query)
private PathFilter ParseIndexer(char indexerOpenChar)
private PathFilter ParseArrayIndexer(char indexerCloseChar)
private void EatWhitespace()
private PathFilter ParseQuery(char indexerCloseChar)
private QueryExpression ParseExpression()
private object ParseValue()
private string ReadQuotedString()
private bool Match(string s)
private QueryOperator ParseOperator()
private PathFilter ParseQuotedField(char indexerCloseChar)
private void EnsureLength(string message)
internal IEnumerable`1<JToken> Evaluate(JToken t, bool errorWhenNoMatch)
internal IEnumerable`1<JToken> Evaluate(List`1<PathFilter> filters, JToken t, bool errorWhenNoMatch)
}
internal Newtonsoft.Json.Linq.JsonPath.PathFilter : object {
public IEnumerable`1<JToken> ExecuteFilter(IEnumerable`1<JToken> current, bool errorWhenNoMatch)
protected JToken GetTokenIndex(JToken t, bool errorWhenNoMatch, int index)
}
internal Newtonsoft.Json.Linq.JsonPath.QueryExpression : object {
private QueryOperator <Operator>k__BackingField
public QueryOperator Operator
public QueryOperator get_Operator()
public void set_Operator(QueryOperator value)
public bool IsMatch(JToken t)
}
internal Newtonsoft.Json.Linq.JsonPath.QueryFilter : PathFilter {
private QueryExpression <Expression>k__BackingField
public QueryExpression Expression
public QueryExpression get_Expression()
public void set_Expression(QueryExpression value)
public IEnumerable`1<JToken> ExecuteFilter(IEnumerable`1<JToken> current, bool errorWhenNoMatch)
}
internal Newtonsoft.Json.Linq.JsonPath.QueryOperator : Enum {
public int value__
public QueryOperator None
public QueryOperator Equals
public QueryOperator NotEquals
public QueryOperator Exists
public QueryOperator LessThan
public QueryOperator LessThanOrEquals
public QueryOperator GreaterThan
public QueryOperator GreaterThanOrEquals
public QueryOperator And
public QueryOperator Or
}
internal Newtonsoft.Json.Linq.JsonPath.ScanFilter : PathFilter {
private string <Name>k__BackingField
public string Name
public string get_Name()
public void set_Name(string value)
public IEnumerable`1<JToken> ExecuteFilter(IEnumerable`1<JToken> current, bool errorWhenNoMatch)
}
public Newtonsoft.Json.Linq.JToken : object {
private JTokenEqualityComparer _equalityComparer
private JContainer _parent
private JToken _previous
private JToken _next
private object _annotations
private JTokenType[] BooleanTypes
private JTokenType[] NumberTypes
private JTokenType[] StringTypes
private JTokenType[] GuidTypes
private JTokenType[] TimeSpanTypes
private JTokenType[] UriTypes
private JTokenType[] CharTypes
private JTokenType[] DateTimeTypes
private JTokenType[] BytesTypes
public JTokenEqualityComparer EqualityComparer
public JContainer Parent
public JToken Root
public JTokenType Type
public bool HasValues
public JToken Next
public JToken Previous
public string Path
public JToken Item
public JToken First
public JToken Last
private IJEnumerable`1<JToken> Newtonsoft.Json.Linq.IJEnumerable<Newtonsoft.Json.Linq.JToken>.Item
private int Newtonsoft.Json.IJsonLineInfo.LineNumber
private int Newtonsoft.Json.IJsonLineInfo.LinePosition
public JTokenEqualityComparer get_EqualityComparer()
public JContainer get_Parent()
internal void set_Parent(JContainer value)
public JToken get_Root()
internal JToken CloneToken()
internal bool DeepEquals(JToken node)
public JTokenType get_Type()
public bool get_HasValues()
public bool DeepEquals(JToken t1, JToken t2)
public JToken get_Next()
internal void set_Next(JToken value)
public JToken get_Previous()
internal void set_Previous(JToken value)
public string get_Path()
public void AddAfterSelf(object content)
public void AddBeforeSelf(object content)
public IEnumerable`1<JToken> Ancestors()
public IEnumerable`1<JToken> AncestorsAndSelf()
internal IEnumerable`1<JToken> GetAncestors(bool self)
public IEnumerable`1<JToken> AfterSelf()
public IEnumerable`1<JToken> BeforeSelf()
public JToken get_Item(object key)
public void set_Item(object key, JToken value)
public T Value(object key)
public JToken get_First()
public JToken get_Last()
public JEnumerable`1<JToken> Children()
public JEnumerable`1<T> Children()
public IEnumerable`1<T> Values()
public void Remove()
public void Replace(JToken value)
public void WriteTo(JsonWriter writer, JsonConverter[] converters)
public string ToString()
public string ToString(Formatting formatting, JsonConverter[] converters)
private JValue EnsureValue(JToken value)
private string GetType(JToken token)
private bool ValidateToken(JToken o, JTokenType[] validTypes, bool nullable)
public bool op_Explicit(JToken value)
public DateTimeOffset op_Explicit(JToken value)
public Nullable`1<bool> op_Explicit(JToken value)
public long op_Explicit(JToken value)
public Nullable`1<DateTime> op_Explicit(JToken value)
public Nullable`1<DateTimeOffset> op_Explicit(JToken value)
public Nullable`1<decimal> op_Explicit(JToken value)
public Nullable`1<double> op_Explicit(JToken value)
public Nullable`1<char> op_Explicit(JToken value)
public int op_Explicit(JToken value)
public short op_Explicit(JToken value)
public ushort op_Explicit(JToken value)
public char op_Explicit(JToken value)
public byte op_Explicit(JToken value)
public sbyte op_Explicit(JToken value)
public Nullable`1<int> op_Explicit(JToken value)
public Nullable`1<short> op_Explicit(JToken value)
public Nullable`1<ushort> op_Explicit(JToken value)
public Nullable`1<byte> op_Explicit(JToken value)
public Nullable`1<sbyte> op_Explicit(JToken value)
public DateTime op_Explicit(JToken value)
public Nullable`1<long> op_Explicit(JToken value)
public Nullable`1<float> op_Explicit(JToken value)
public decimal op_Explicit(JToken value)
public Nullable`1<UInt32> op_Explicit(JToken value)
public Nullable`1<ulong> op_Explicit(JToken value)
public double op_Explicit(JToken value)
public float op_Explicit(JToken value)
public string op_Explicit(JToken value)
public UInt32 op_Explicit(JToken value)
public ulong op_Explicit(JToken value)
public Byte[] op_Explicit(JToken value)
public Guid op_Explicit(JToken value)
public Nullable`1<Guid> op_Explicit(JToken value)
public TimeSpan op_Explicit(JToken value)
public Nullable`1<TimeSpan> op_Explicit(JToken value)
public Uri op_Explicit(JToken value)
public JToken op_Implicit(bool value)
public JToken op_Implicit(DateTimeOffset value)
public JToken op_Implicit(byte value)
public JToken op_Implicit(Nullable`1<byte> value)
public JToken op_Implicit(sbyte value)
public JToken op_Implicit(Nullable`1<sbyte> value)
public JToken op_Implicit(Nullable`1<bool> value)
public JToken op_Implicit(long value)
public JToken op_Implicit(Nullable`1<DateTime> value)
public JToken op_Implicit(Nullable`1<DateTimeOffset> value)
public JToken op_Implicit(Nullable`1<decimal> value)
public JToken op_Implicit(Nullable`1<double> value)
public JToken op_Implicit(short value)
public JToken op_Implicit(ushort value)
public JToken op_Implicit(int value)
public JToken op_Implicit(Nullable`1<int> value)
public JToken op_Implicit(DateTime value)
public JToken op_Implicit(Nullable`1<long> value)
public JToken op_Implicit(Nullable`1<float> value)
public JToken op_Implicit(decimal value)
public JToken op_Implicit(Nullable`1<short> value)
public JToken op_Implicit(Nullable`1<ushort> value)
public JToken op_Implicit(Nullable`1<UInt32> value)
public JToken op_Implicit(Nullable`1<ulong> value)
public JToken op_Implicit(double value)
public JToken op_Implicit(float value)
public JToken op_Implicit(string value)
public JToken op_Implicit(UInt32 value)
public JToken op_Implicit(ulong value)
public JToken op_Implicit(Byte[] value)
public JToken op_Implicit(Uri value)
public JToken op_Implicit(TimeSpan value)
public JToken op_Implicit(Nullable`1<TimeSpan> value)
public JToken op_Implicit(Guid value)
public JToken op_Implicit(Nullable`1<Guid> value)
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
private IEnumerator`1<JToken> System.Collections.Generic.IEnumerable<Newtonsoft.Json.Linq.JToken>.GetEnumerator()
internal int GetDeepHashCode()
private IJEnumerable`1<JToken> Newtonsoft.Json.Linq.IJEnumerable<Newtonsoft.Json.Linq.JToken>.get_Item(object key)
public JsonReader CreateReader()
internal JToken FromObjectInternal(object o, JsonSerializer jsonSerializer)
public JToken FromObject(object o)
public JToken FromObject(object o, JsonSerializer jsonSerializer)
public T ToObject()
public object ToObject(Type objectType)
public T ToObject(JsonSerializer jsonSerializer)
public object ToObject(Type objectType, JsonSerializer jsonSerializer)
public JToken ReadFrom(JsonReader reader)
public JToken ReadFrom(JsonReader reader, JsonLoadSettings settings)
public JToken Parse(string json)
public JToken Parse(string json, JsonLoadSettings settings)
public JToken Load(JsonReader reader, JsonLoadSettings settings)
public JToken Load(JsonReader reader)
internal void SetLineInfo(IJsonLineInfo lineInfo, JsonLoadSettings settings)
internal void SetLineInfo(int lineNumber, int linePosition)
private bool Newtonsoft.Json.IJsonLineInfo.HasLineInfo()
private int Newtonsoft.Json.IJsonLineInfo.get_LineNumber()
private int Newtonsoft.Json.IJsonLineInfo.get_LinePosition()
public JToken SelectToken(string path)
public JToken SelectToken(string path, bool errorWhenNoMatch)
public IEnumerable`1<JToken> SelectTokens(string path)
public IEnumerable`1<JToken> SelectTokens(string path, bool errorWhenNoMatch)
private object System.ICloneable.Clone()
public JToken DeepClone()
public void AddAnnotation(object annotation)
public T Annotation()
public object Annotation(Type type)
public IEnumerable`1<T> Annotations()
public IEnumerable`1<object> Annotations(Type type)
public void RemoveAnnotations()
public void RemoveAnnotations(Type type)
}
public Newtonsoft.Json.Linq.JTokenEqualityComparer : object {
public bool Equals(JToken x, JToken y)
public int GetHashCode(JToken obj)
}
public Newtonsoft.Json.Linq.JTokenReader : JsonReader {
private JToken _root
private string _initialPath
private JToken _parent
private JToken _current
public JToken CurrentToken
private int Newtonsoft.Json.IJsonLineInfo.LineNumber
private int Newtonsoft.Json.IJsonLineInfo.LinePosition
public string Path
public JToken get_CurrentToken()
public void .ctor(JToken token)
internal void .ctor(JToken token, string initialPath)
public bool Read()
private bool ReadOver(JToken t)
private bool ReadToEnd()
private Nullable`1<JsonToken> GetEndToken(JContainer c)
private bool ReadInto(JContainer c)
private bool SetEnd(JContainer c)
private void SetToken(JToken token)
private string SafeToString(object value)
private bool Newtonsoft.Json.IJsonLineInfo.HasLineInfo()
private int Newtonsoft.Json.IJsonLineInfo.get_LineNumber()
private int Newtonsoft.Json.IJsonLineInfo.get_LinePosition()
public string get_Path()
}
public Newtonsoft.Json.Linq.JTokenType : Enum {
public int value__
public JTokenType None
public JTokenType Object
public JTokenType Array
public JTokenType Constructor
public JTokenType Property
public JTokenType Comment
public JTokenType Integer
public JTokenType Float
public JTokenType String
public JTokenType Boolean
public JTokenType Null
public JTokenType Undefined
public JTokenType Date
public JTokenType Raw
public JTokenType Bytes
public JTokenType Guid
public JTokenType Uri
public JTokenType TimeSpan
}
public Newtonsoft.Json.Linq.JTokenWriter : JsonWriter {
private JContainer _token
private JContainer _parent
private JValue _value
private JToken _current
public JToken CurrentToken
public JToken Token
public JToken get_CurrentToken()
public JToken get_Token()
public void .ctor(JContainer container)
public void Flush()
public void Close()
public void WriteStartObject()
private void AddParent(JContainer container)
private void RemoveParent()
public void WriteStartArray()
public void WriteStartConstructor(string name)
protected void WriteEnd(JsonToken token)
public void WritePropertyName(string name)
private void AddValue(object value, JsonToken token)
internal void AddValue(JValue value, JsonToken token)
public void WriteValue(object value)
public void WriteNull()
public void WriteUndefined()
public void WriteRaw(string json)
public void WriteComment(string text)
public void WriteValue(string value)
public void WriteValue(int value)
public void WriteValue(UInt32 value)
public void WriteValue(long value)
public void WriteValue(ulong value)
public void WriteValue(float value)
public void WriteValue(double value)
public void WriteValue(bool value)
public void WriteValue(short value)
public void WriteValue(ushort value)
public void WriteValue(char value)
public void WriteValue(byte value)
public void WriteValue(sbyte value)
public void WriteValue(decimal value)
public void WriteValue(DateTime value)
public void WriteValue(DateTimeOffset value)
public void WriteValue(Byte[] value)
public void WriteValue(TimeSpan value)
public void WriteValue(Guid value)
public void WriteValue(Uri value)
internal void WriteToken(JsonReader reader, bool writeChildren, bool writeDateConstructorAsDate, bool writeComments)
}
public Newtonsoft.Json.Linq.JValue : JToken {
private JTokenType _valueType
private object _value
public bool HasValues
public JTokenType Type
public object Value
internal void .ctor(object value, JTokenType type)
public void .ctor(JValue other)
public void .ctor(long value)
public void .ctor(decimal value)
public void .ctor(char value)
public void .ctor(ulong value)
public void .ctor(double value)
public void .ctor(float value)
public void .ctor(DateTime value)
public void .ctor(DateTimeOffset value)
public void .ctor(bool value)
public void .ctor(string value)
public void .ctor(Guid value)
public void .ctor(Uri value)
public void .ctor(TimeSpan value)
public void .ctor(object value)
internal bool DeepEquals(JToken node)
public bool get_HasValues()
internal int Compare(JTokenType valueType, object objA, object objB)
private int CompareFloat(object objA, object objB)
internal JToken CloneToken()
public JValue CreateComment(string value)
public JValue CreateString(string value)
public JValue CreateNull()
public JValue CreateUndefined()
private JTokenType GetValueType(Nullable`1<JTokenType> current, object value)
private JTokenType GetStringValueType(Nullable`1<JTokenType> current)
public JTokenType get_Type()
public object get_Value()
public void set_Value(object value)
public void WriteTo(JsonWriter writer, JsonConverter[] converters)
internal int GetDeepHashCode()
private bool ValuesEquals(JValue v1, JValue v2)
public bool Equals(JValue other)
public bool Equals(object obj)
public int GetHashCode()
public string ToString()
public string ToString(string format)
public string ToString(IFormatProvider formatProvider)
public string ToString(string format, IFormatProvider formatProvider)
private int System.IComparable.CompareTo(object obj)
public int CompareTo(JValue obj)
private TypeCode System.IConvertible.GetTypeCode()
private bool System.IConvertible.ToBoolean(IFormatProvider provider)
private char System.IConvertible.ToChar(IFormatProvider provider)
private sbyte System.IConvertible.ToSByte(IFormatProvider provider)
private byte System.IConvertible.ToByte(IFormatProvider provider)
private short System.IConvertible.ToInt16(IFormatProvider provider)
private ushort System.IConvertible.ToUInt16(IFormatProvider provider)
private int System.IConvertible.ToInt32(IFormatProvider provider)
private UInt32 System.IConvertible.ToUInt32(IFormatProvider provider)
private long System.IConvertible.ToInt64(IFormatProvider provider)
private ulong System.IConvertible.ToUInt64(IFormatProvider provider)
private float System.IConvertible.ToSingle(IFormatProvider provider)
private double System.IConvertible.ToDouble(IFormatProvider provider)
private decimal System.IConvertible.ToDecimal(IFormatProvider provider)
private DateTime System.IConvertible.ToDateTime(IFormatProvider provider)
private object System.IConvertible.ToType(Type conversionType, IFormatProvider provider)
}
public Newtonsoft.Json.Linq.LineInfoHandling : Enum {
public int value__
public LineInfoHandling Ignore
public LineInfoHandling Load
}
public Newtonsoft.Json.Linq.MergeArrayHandling : Enum {
public int value__
public MergeArrayHandling Concat
public MergeArrayHandling Union
public MergeArrayHandling Replace
public MergeArrayHandling Merge
}
public Newtonsoft.Json.Linq.MergeNullValueHandling : Enum {
public int value__
public MergeNullValueHandling Ignore
public MergeNullValueHandling Merge
}
public Newtonsoft.Json.MemberSerialization : Enum {
public int value__
public MemberSerialization OptOut
public MemberSerialization OptIn
public MemberSerialization Fields
}
public Newtonsoft.Json.MetadataPropertyHandling : Enum {
public int value__
public MetadataPropertyHandling Default
public MetadataPropertyHandling ReadAhead
public MetadataPropertyHandling Ignore
}
public Newtonsoft.Json.MissingMemberHandling : Enum {
public int value__
public MissingMemberHandling Ignore
public MissingMemberHandling Error
}
public Newtonsoft.Json.NullValueHandling : Enum {
public int value__
public NullValueHandling Include
public NullValueHandling Ignore
}
public Newtonsoft.Json.ObjectCreationHandling : Enum {
public int value__
public ObjectCreationHandling Auto
public ObjectCreationHandling Reuse
public ObjectCreationHandling Replace
}
public Newtonsoft.Json.PreserveReferencesHandling : Enum {
public int value__
public PreserveReferencesHandling None
public PreserveReferencesHandling Objects
public PreserveReferencesHandling Arrays
public PreserveReferencesHandling All
}
internal Newtonsoft.Json.ReadType : Enum {
public int value__
public ReadType Read
public ReadType ReadAsInt32
public ReadType ReadAsBytes
public ReadType ReadAsString
public ReadType ReadAsDecimal
public ReadType ReadAsDateTime
public ReadType ReadAsDateTimeOffset
public ReadType ReadAsDouble
public ReadType ReadAsBoolean
}
public Newtonsoft.Json.ReferenceLoopHandling : Enum {
public int value__
public ReferenceLoopHandling Error
public ReferenceLoopHandling Ignore
public ReferenceLoopHandling Serialize
}
public Newtonsoft.Json.Required : Enum {
public int value__
public Required Default
public Required AllowNull
public Required Always
public Required DisallowNull
}
internal Newtonsoft.Json.Serialization.CachedAttributeGetter`1 : object {
private ThreadSafeStore`2<object, T> TypeAttributeCache
public T GetAttribute(object type)
}
public Newtonsoft.Json.Serialization.CamelCasePropertyNamesContractResolver : DefaultContractResolver {
protected string ResolvePropertyName(string propertyName)
}
public Newtonsoft.Json.Serialization.DefaultContractResolver : object {
private IContractResolver _instance
private JsonConverter[] BuiltInConverters
private object TypeContractCacheLock
private DefaultContractResolverState _sharedState
private DefaultContractResolverState _instanceState
private bool _sharedCache
private BindingFlags <DefaultMembersSearchFlags>k__BackingField
private bool <SerializeCompilerGeneratedMembers>k__BackingField
private bool <IgnoreSerializableInterface>k__BackingField
private bool <IgnoreSerializableAttribute>k__BackingField
internal IContractResolver Instance
public bool DynamicCodeGeneration
public BindingFlags DefaultMembersSearchFlags
public bool SerializeCompilerGeneratedMembers
public bool IgnoreSerializableInterface
public bool IgnoreSerializableAttribute
internal IContractResolver get_Instance()
public bool get_DynamicCodeGeneration()
public BindingFlags get_DefaultMembersSearchFlags()
public void set_DefaultMembersSearchFlags(BindingFlags value)
public bool get_SerializeCompilerGeneratedMembers()
public void set_SerializeCompilerGeneratedMembers(bool value)
public bool get_IgnoreSerializableInterface()
public void set_IgnoreSerializableInterface(bool value)
public bool get_IgnoreSerializableAttribute()
public void set_IgnoreSerializableAttribute(bool value)
public void .ctor(bool shareCache)
internal DefaultContractResolverState GetState()
public JsonContract ResolveContract(Type type)
protected List`1<MemberInfo> GetSerializableMembers(Type objectType)
private bool ShouldSerializeEntityMember(MemberInfo memberInfo)
protected JsonObjectContract CreateObjectContract(Type objectType)
private MemberInfo GetExtensionDataMemberForType(Type type)
private void SetExtensionDataDelegates(JsonObjectContract contract, MemberInfo member)
private ConstructorInfo GetAttributeConstructor(Type objectType)
private ConstructorInfo GetParameterizedConstructor(Type objectType)
protected IList`1<JsonProperty> CreateConstructorParameters(ConstructorInfo constructor, JsonPropertyCollection memberProperties)
protected JsonProperty CreatePropertyFromConstructorParameter(JsonProperty matchingMemberProperty, ParameterInfo parameterInfo)
protected JsonConverter ResolveContractConverter(Type objectType)
private Func`1<object> GetDefaultCreator(Type createdType)
private void InitializeContract(JsonContract contract)
private void ResolveCallbackMethods(JsonContract contract, Type t)
private void GetCallbackMethodsForType(Type type, List`1& onSerializing, List`1& onSerialized, List`1& onDeserializing, List`1& onDeserialized, List`1& onError)
private bool ShouldSkipDeserialized(Type t)
private bool ShouldSkipSerializing(Type t)
private List`1<Type> GetClassHierarchyForType(Type type)
protected JsonDictionaryContract CreateDictionaryContract(Type objectType)
protected JsonArrayContract CreateArrayContract(Type objectType)
protected JsonPrimitiveContract CreatePrimitiveContract(Type objectType)
protected JsonLinqContract CreateLinqContract(Type objectType)
protected JsonISerializableContract CreateISerializableContract(Type objectType)
protected JsonStringContract CreateStringContract(Type objectType)
protected JsonContract CreateContract(Type objectType)
internal bool IsJsonPrimitiveType(Type t)
internal bool IsIConvertible(Type t)
internal bool CanConvertToString(Type type)
private bool IsValidCallback(MethodInfo method, ParameterInfo[] parameters, Type attributeType, MethodInfo currentCallback, Type& prevAttributeType)
internal string GetClrTypeFullName(Type type)
protected IList`1<JsonProperty> CreateProperties(Type type, MemberSerialization memberSerialization)
protected IValueProvider CreateMemberValueProvider(MemberInfo member)
protected JsonProperty CreateProperty(MemberInfo member, MemberSerialization memberSerialization)
private void SetPropertySettingsFromAttributes(JsonProperty property, object attributeProvider, string name, Type declaringType, MemberSerialization memberSerialization, Boolean& allowNonPublicAccess)
private Predicate`1<object> CreateShouldSerializeTest(MemberInfo member)
private void SetIsSpecifiedActions(JsonProperty property, MemberInfo member, bool allowNonPublicAccess)
protected string ResolvePropertyName(string propertyName)
protected string ResolveDictionaryKey(string dictionaryKey)
public string GetResolvedPropertyName(string propertyName)
}
internal Newtonsoft.Json.Serialization.DefaultContractResolverState : object {
public Dictionary`2<ResolverContractKey, JsonContract> ContractCache
public PropertyNameTable NameTable
}
internal Newtonsoft.Json.Serialization.DefaultReferenceResolver : object {
private int _referenceCount
private BidirectionalDictionary`2<string, object> GetMappings(object context)
public object ResolveReference(object context, string reference)
public string GetReference(object context, object value)
public void AddReference(object context, string reference, object value)
public bool IsReferenced(object context, object value)
}
public Newtonsoft.Json.Serialization.DefaultSerializationBinder : SerializationBinder {
internal DefaultSerializationBinder Instance
private ThreadSafeStore`2<TypeNameKey, Type> _typeCache
private Type GetTypeFromTypeNameKey(TypeNameKey typeNameKey)
public Type BindToType(string assemblyName, string typeName)
}
public Newtonsoft.Json.Serialization.DiagnosticsTraceWriter : object {
private TraceLevel <LevelFilter>k__BackingField
public TraceLevel LevelFilter
public TraceLevel get_LevelFilter()
public void set_LevelFilter(TraceLevel value)
private TraceEventType GetTraceEventType(TraceLevel level)
public void Trace(TraceLevel level, string message, Exception ex)
}
public Newtonsoft.Json.Serialization.DynamicValueProvider : object {
private MemberInfo _memberInfo
private Func`2<object, object> _getter
private Action`2<object, object> _setter
public void .ctor(MemberInfo memberInfo)
public void SetValue(object target, object value)
public object GetValue(object target)
}
public Newtonsoft.Json.Serialization.ErrorContext : object {
private bool <Traced>k__BackingField
private Exception <Error>k__BackingField
private object <OriginalObject>k__BackingField
private object <Member>k__BackingField
private string <Path>k__BackingField
private bool <Handled>k__BackingField
internal bool Traced
public Exception Error
public object OriginalObject
public object Member
public string Path
public bool Handled
internal void .ctor(object originalObject, object member, string path, Exception error)
internal bool get_Traced()
internal void set_Traced(bool value)
public Exception get_Error()
private void set_Error(Exception value)
public object get_OriginalObject()
private void set_OriginalObject(object value)
public object get_Member()
private void set_Member(object value)
public string get_Path()
private void set_Path(string value)
public bool get_Handled()
public void set_Handled(bool value)
}
public Newtonsoft.Json.Serialization.ErrorEventArgs : EventArgs {
private object <CurrentObject>k__BackingField
private ErrorContext <ErrorContext>k__BackingField
public object CurrentObject
public ErrorContext ErrorContext
public object get_CurrentObject()
private void set_CurrentObject(object value)
public ErrorContext get_ErrorContext()
private void set_ErrorContext(ErrorContext value)
public void .ctor(object currentObject, ErrorContext errorContext)
}
public Newtonsoft.Json.Serialization.ExtensionDataGetter : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public IEnumerable`1<KeyValuePair`2<object, object>> Invoke(object o)
public IAsyncResult BeginInvoke(object o, AsyncCallback callback, object object)
public IEnumerable`1<KeyValuePair`2<object, object>> EndInvoke(IAsyncResult result)
}
public Newtonsoft.Json.Serialization.ExtensionDataSetter : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object o, string key, object value)
public IAsyncResult BeginInvoke(object o, string key, object value, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public Newtonsoft.Json.Serialization.IAttributeProvider {
public IList`1<Attribute> GetAttributes(bool inherit)
public IList`1<Attribute> GetAttributes(Type attributeType, bool inherit)
}
public Newtonsoft.Json.Serialization.IContractResolver {
public JsonContract ResolveContract(Type type)
}
public Newtonsoft.Json.Serialization.IReferenceResolver {
public object ResolveReference(object context, string reference)
public string GetReference(object context, object value)
public bool IsReferenced(object context, object value)
public void AddReference(object context, string reference, object value)
}
public Newtonsoft.Json.Serialization.ITraceWriter {
public TraceLevel LevelFilter
public TraceLevel get_LevelFilter()
public void Trace(TraceLevel level, string message, Exception ex)
}
public Newtonsoft.Json.Serialization.IValueProvider {
public void SetValue(object target, object value)
public object GetValue(object target)
}
public Newtonsoft.Json.Serialization.JsonArrayContract : JsonContainerContract {
private Type <CollectionItemType>k__BackingField
private bool <IsMultidimensionalArray>k__BackingField
private Type _genericCollectionDefinitionType
private Type _genericWrapperType
private ObjectConstructor`1<object> _genericWrapperCreator
private Func`1<object> _genericTemporaryCollectionCreator
private bool <IsArray>k__BackingField
private bool <ShouldCreateWrapper>k__BackingField
private bool <CanDeserialize>k__BackingField
private ConstructorInfo _parameterizedConstructor
private ObjectConstructor`1<object> _parameterizedCreator
private ObjectConstructor`1<object> _overrideCreator
private bool <HasParameterizedCreator>k__BackingField
public Type CollectionItemType
public bool IsMultidimensionalArray
internal bool IsArray
internal bool ShouldCreateWrapper
internal bool CanDeserialize
internal ObjectConstructor`1<object> ParameterizedCreator
public ObjectConstructor`1<object> OverrideCreator
public bool HasParameterizedCreator
internal bool HasParameterizedCreatorInternal
public Type get_CollectionItemType()
private void set_CollectionItemType(Type value)
public bool get_IsMultidimensionalArray()
private void set_IsMultidimensionalArray(bool value)
internal bool get_IsArray()
private void set_IsArray(bool value)
internal bool get_ShouldCreateWrapper()
private void set_ShouldCreateWrapper(bool value)
internal bool get_CanDeserialize()
private void set_CanDeserialize(bool value)
internal ObjectConstructor`1<object> get_ParameterizedCreator()
public ObjectConstructor`1<object> get_OverrideCreator()
public void set_OverrideCreator(ObjectConstructor`1<object> value)
public bool get_HasParameterizedCreator()
public void set_HasParameterizedCreator(bool value)
internal bool get_HasParameterizedCreatorInternal()
public void .ctor(Type underlyingType)
internal IWrappedCollection CreateWrapper(object list)
internal IList CreateTemporaryCollection()
}
public Newtonsoft.Json.Serialization.JsonContainerContract : JsonContract {
private JsonContract _itemContract
private JsonContract _finalItemContract
private JsonConverter <ItemConverter>k__BackingField
private Nullable`1<bool> <ItemIsReference>k__BackingField
private Nullable`1<ReferenceLoopHandling> <ItemReferenceLoopHandling>k__BackingField
private Nullable`1<TypeNameHandling> <ItemTypeNameHandling>k__BackingField
internal JsonContract ItemContract
internal JsonContract FinalItemContract
public JsonConverter ItemConverter
public Nullable`1<bool> ItemIsReference
public Nullable`1<ReferenceLoopHandling> ItemReferenceLoopHandling
public Nullable`1<TypeNameHandling> ItemTypeNameHandling
internal JsonContract get_ItemContract()
internal void set_ItemContract(JsonContract value)
internal JsonContract get_FinalItemContract()
public JsonConverter get_ItemConverter()
public void set_ItemConverter(JsonConverter value)
public Nullable`1<bool> get_ItemIsReference()
public void set_ItemIsReference(Nullable`1<bool> value)
public Nullable`1<ReferenceLoopHandling> get_ItemReferenceLoopHandling()
public void set_ItemReferenceLoopHandling(Nullable`1<ReferenceLoopHandling> value)
public Nullable`1<TypeNameHandling> get_ItemTypeNameHandling()
public void set_ItemTypeNameHandling(Nullable`1<TypeNameHandling> value)
internal void .ctor(Type underlyingType)
}
public Newtonsoft.Json.Serialization.JsonContract : object {
internal bool IsNullable
internal bool IsConvertable
internal bool IsEnum
internal Type NonNullableUnderlyingType
internal ReadType InternalReadType
internal JsonContractType ContractType
internal bool IsReadOnlyOrFixedSize
internal bool IsSealed
internal bool IsInstantiable
private List`1<SerializationCallback> _onDeserializedCallbacks
private IList`1<SerializationCallback> _onDeserializingCallbacks
private IList`1<SerializationCallback> _onSerializedCallbacks
private IList`1<SerializationCallback> _onSerializingCallbacks
private IList`1<SerializationErrorCallback> _onErrorCallbacks
private Type _createdType
private Type <UnderlyingType>k__BackingField
private Nullable`1<bool> <IsReference>k__BackingField
private JsonConverter <Converter>k__BackingField
private JsonConverter <InternalConverter>k__BackingField
private Func`1<object> <DefaultCreator>k__BackingField
private bool <DefaultCreatorNonPublic>k__BackingField
public Type UnderlyingType
public Type CreatedType
public Nullable`1<bool> IsReference
public JsonConverter Converter
internal JsonConverter InternalConverter
public IList`1<SerializationCallback> OnDeserializedCallbacks
public IList`1<SerializationCallback> OnDeserializingCallbacks
public IList`1<SerializationCallback> OnSerializedCallbacks
public IList`1<SerializationCallback> OnSerializingCallbacks
public IList`1<SerializationErrorCallback> OnErrorCallbacks
public MethodInfo OnDeserialized
public MethodInfo OnDeserializing
public MethodInfo OnSerialized
public MethodInfo OnSerializing
public MethodInfo OnError
public Func`1<object> DefaultCreator
public bool DefaultCreatorNonPublic
public Type get_UnderlyingType()
private void set_UnderlyingType(Type value)
public Type get_CreatedType()
public void set_CreatedType(Type value)
public Nullable`1<bool> get_IsReference()
public void set_IsReference(Nullable`1<bool> value)
public JsonConverter get_Converter()
public void set_Converter(JsonConverter value)
internal JsonConverter get_InternalConverter()
internal void set_InternalConverter(JsonConverter value)
public IList`1<SerializationCallback> get_OnDeserializedCallbacks()
public IList`1<SerializationCallback> get_OnDeserializingCallbacks()
public IList`1<SerializationCallback> get_OnSerializedCallbacks()
public IList`1<SerializationCallback> get_OnSerializingCallbacks()
public IList`1<SerializationErrorCallback> get_OnErrorCallbacks()
public MethodInfo get_OnDeserialized()
public void set_OnDeserialized(MethodInfo value)
public MethodInfo get_OnDeserializing()
public void set_OnDeserializing(MethodInfo value)
public MethodInfo get_OnSerialized()
public void set_OnSerialized(MethodInfo value)
public MethodInfo get_OnSerializing()
public void set_OnSerializing(MethodInfo value)
public MethodInfo get_OnError()
public void set_OnError(MethodInfo value)
public Func`1<object> get_DefaultCreator()
public void set_DefaultCreator(Func`1<object> value)
public bool get_DefaultCreatorNonPublic()
public void set_DefaultCreatorNonPublic(bool value)
internal void .ctor(Type underlyingType)
internal void InvokeOnSerializing(object o, StreamingContext context)
internal void InvokeOnSerialized(object o, StreamingContext context)
internal void InvokeOnDeserializing(object o, StreamingContext context)
internal void InvokeOnDeserialized(object o, StreamingContext context)
internal void InvokeOnError(object o, StreamingContext context, ErrorContext errorContext)
internal SerializationCallback CreateSerializationCallback(MethodInfo callbackMethodInfo)
internal SerializationErrorCallback CreateSerializationErrorCallback(MethodInfo callbackMethodInfo)
}
internal Newtonsoft.Json.Serialization.JsonContractType : Enum {
public int value__
public JsonContractType None
public JsonContractType Object
public JsonContractType Array
public JsonContractType Primitive
public JsonContractType String
public JsonContractType Dictionary
public JsonContractType Dynamic
public JsonContractType Serializable
public JsonContractType Linq
}
public Newtonsoft.Json.Serialization.JsonDictionaryContract : JsonContainerContract {
private Func`2<string, string> <DictionaryKeyResolver>k__BackingField
private Type <DictionaryKeyType>k__BackingField
private Type <DictionaryValueType>k__BackingField
private JsonContract <KeyContract>k__BackingField
private Type _genericCollectionDefinitionType
private Type _genericWrapperType
private ObjectConstructor`1<object> _genericWrapperCreator
private Func`1<object> _genericTemporaryDictionaryCreator
private bool <ShouldCreateWrapper>k__BackingField
private ConstructorInfo _parameterizedConstructor
private ObjectConstructor`1<object> _overrideCreator
private ObjectConstructor`1<object> _parameterizedCreator
private bool <HasParameterizedCreator>k__BackingField
public Func`2<string, string> PropertyNameResolver
public Func`2<string, string> DictionaryKeyResolver
public Type DictionaryKeyType
public Type DictionaryValueType
internal JsonContract KeyContract
internal bool ShouldCreateWrapper
internal ObjectConstructor`1<object> ParameterizedCreator
public ObjectConstructor`1<object> OverrideCreator
public bool HasParameterizedCreator
internal bool HasParameterizedCreatorInternal
public Func`2<string, string> get_PropertyNameResolver()
public void set_PropertyNameResolver(Func`2<string, string> value)
public Func`2<string, string> get_DictionaryKeyResolver()
public void set_DictionaryKeyResolver(Func`2<string, string> value)
public Type get_DictionaryKeyType()
private void set_DictionaryKeyType(Type value)
public Type get_DictionaryValueType()
private void set_DictionaryValueType(Type value)
internal JsonContract get_KeyContract()
internal void set_KeyContract(JsonContract value)
internal bool get_ShouldCreateWrapper()
private void set_ShouldCreateWrapper(bool value)
internal ObjectConstructor`1<object> get_ParameterizedCreator()
public ObjectConstructor`1<object> get_OverrideCreator()
public void set_OverrideCreator(ObjectConstructor`1<object> value)
public bool get_HasParameterizedCreator()
public void set_HasParameterizedCreator(bool value)
internal bool get_HasParameterizedCreatorInternal()
public void .ctor(Type underlyingType)
internal IWrappedDictionary CreateWrapper(object dictionary)
internal IDictionary CreateTemporaryDictionary()
}
internal Newtonsoft.Json.Serialization.JsonFormatterConverter : object {
private JsonSerializerInternalReader _reader
private JsonISerializableContract _contract
private JsonProperty _member
public void .ctor(JsonSerializerInternalReader reader, JsonISerializableContract contract, JsonProperty member)
private T GetTokenValue(object value)
public object Convert(object value, Type type)
public object Convert(object value, TypeCode typeCode)
public bool ToBoolean(object value)
public byte ToByte(object value)
public char ToChar(object value)
public DateTime ToDateTime(object value)
public decimal ToDecimal(object value)
public double ToDouble(object value)
public short ToInt16(object value)
public int ToInt32(object value)
public long ToInt64(object value)
public sbyte ToSByte(object value)
public float ToSingle(object value)
public string ToString(object value)
public ushort ToUInt16(object value)
public UInt32 ToUInt32(object value)
public ulong ToUInt64(object value)
}
public Newtonsoft.Json.Serialization.JsonISerializableContract : JsonContainerContract {
private ObjectConstructor`1<object> <ISerializableCreator>k__BackingField
public ObjectConstructor`1<object> ISerializableCreator
public ObjectConstructor`1<object> get_ISerializableCreator()
public void set_ISerializableCreator(ObjectConstructor`1<object> value)
public void .ctor(Type underlyingType)
}
public Newtonsoft.Json.Serialization.JsonLinqContract : JsonContract {
public void .ctor(Type underlyingType)
}
public Newtonsoft.Json.Serialization.JsonObjectContract : JsonContainerContract {
private MemberSerialization <MemberSerialization>k__BackingField
private Nullable`1<Required> <ItemRequired>k__BackingField
private JsonPropertyCollection <Properties>k__BackingField
private ExtensionDataSetter <ExtensionDataSetter>k__BackingField
private ExtensionDataGetter <ExtensionDataGetter>k__BackingField
internal bool ExtensionDataIsJToken
private Nullable`1<bool> _hasRequiredOrDefaultValueProperties
private ConstructorInfo _parametrizedConstructor
private ConstructorInfo _overrideConstructor
private ObjectConstructor`1<object> _overrideCreator
private ObjectConstructor`1<object> _parameterizedCreator
private JsonPropertyCollection _creatorParameters
private Type _extensionDataValueType
public MemberSerialization MemberSerialization
public Nullable`1<Required> ItemRequired
public JsonPropertyCollection Properties
public JsonPropertyCollection ConstructorParameters
public JsonPropertyCollection CreatorParameters
public ConstructorInfo OverrideConstructor
public ConstructorInfo ParametrizedConstructor
public ObjectConstructor`1<object> OverrideCreator
internal ObjectConstructor`1<object> ParameterizedCreator
public ExtensionDataSetter ExtensionDataSetter
public ExtensionDataGetter ExtensionDataGetter
public Type ExtensionDataValueType
internal bool HasRequiredOrDefaultValueProperties
public MemberSerialization get_MemberSerialization()
public void set_MemberSerialization(MemberSerialization value)
public Nullable`1<Required> get_ItemRequired()
public void set_ItemRequired(Nullable`1<Required> value)
public JsonPropertyCollection get_Properties()
private void set_Properties(JsonPropertyCollection value)
public JsonPropertyCollection get_ConstructorParameters()
public JsonPropertyCollection get_CreatorParameters()
public ConstructorInfo get_OverrideConstructor()
public void set_OverrideConstructor(ConstructorInfo value)
public ConstructorInfo get_ParametrizedConstructor()
public void set_ParametrizedConstructor(ConstructorInfo value)
public ObjectConstructor`1<object> get_OverrideCreator()
public void set_OverrideCreator(ObjectConstructor`1<object> value)
internal ObjectConstructor`1<object> get_ParameterizedCreator()
public ExtensionDataSetter get_ExtensionDataSetter()
public void set_ExtensionDataSetter(ExtensionDataSetter value)
public ExtensionDataGetter get_ExtensionDataGetter()
public void set_ExtensionDataGetter(ExtensionDataGetter value)
public Type get_ExtensionDataValueType()
public void set_ExtensionDataValueType(Type value)
internal bool get_HasRequiredOrDefaultValueProperties()
public void .ctor(Type underlyingType)
internal object GetUninitializedObject()
}
public Newtonsoft.Json.Serialization.JsonPrimitiveContract : JsonContract {
private PrimitiveTypeCode <TypeCode>k__BackingField
private Dictionary`2<Type, ReadType> ReadTypeMap
internal PrimitiveTypeCode TypeCode
internal PrimitiveTypeCode get_TypeCode()
internal void set_TypeCode(PrimitiveTypeCode value)
public void .ctor(Type underlyingType)
}
public Newtonsoft.Json.Serialization.JsonProperty : object {
internal Nullable`1<Required> _required
internal bool _hasExplicitDefaultValue
private object _defaultValue
private bool _hasGeneratedDefaultValue
private string _propertyName
internal bool _skipPropertyNameEscape
private Type _propertyType
private JsonContract <PropertyContract>k__BackingField
private Type <DeclaringType>k__BackingField
private Nullable`1<int> <Order>k__BackingField
private string <UnderlyingName>k__BackingField
private IValueProvider <ValueProvider>k__BackingField
private IAttributeProvider <AttributeProvider>k__BackingField
private JsonConverter <Converter>k__BackingField
private JsonConverter <MemberConverter>k__BackingField
private bool <Ignored>k__BackingField
private bool <Readable>k__BackingField
private bool <Writable>k__BackingField
private bool <HasMemberAttribute>k__BackingField
private Nullable`1<bool> <IsReference>k__BackingField
private Nullable`1<NullValueHandling> <NullValueHandling>k__BackingField
private Nullable`1<DefaultValueHandling> <DefaultValueHandling>k__BackingField
private Nullable`1<ReferenceLoopHandling> <ReferenceLoopHandling>k__BackingField
private Nullable`1<ObjectCreationHandling> <ObjectCreationHandling>k__BackingField
private Nullable`1<TypeNameHandling> <TypeNameHandling>k__BackingField
private Predicate`1<object> <ShouldSerialize>k__BackingField
private Predicate`1<object> <ShouldDeserialize>k__BackingField
private Predicate`1<object> <GetIsSpecified>k__BackingField
private Action`2<object, object> <SetIsSpecified>k__BackingField
private JsonConverter <ItemConverter>k__BackingField
private Nullable`1<bool> <ItemIsReference>k__BackingField
private Nullable`1<TypeNameHandling> <ItemTypeNameHandling>k__BackingField
private Nullable`1<ReferenceLoopHandling> <ItemReferenceLoopHandling>k__BackingField
internal JsonContract PropertyContract
public string PropertyName
public Type DeclaringType
public Nullable`1<int> Order
public string UnderlyingName
public IValueProvider ValueProvider
public IAttributeProvider AttributeProvider
public Type PropertyType
public JsonConverter Converter
public JsonConverter MemberConverter
public bool Ignored
public bool Readable
public bool Writable
public bool HasMemberAttribute
public object DefaultValue
public Required Required
public Nullable`1<bool> IsReference
public Nullable`1<NullValueHandling> NullValueHandling
public Nullable`1<DefaultValueHandling> DefaultValueHandling
public Nullable`1<ReferenceLoopHandling> ReferenceLoopHandling
public Nullable`1<ObjectCreationHandling> ObjectCreationHandling
public Nullable`1<TypeNameHandling> TypeNameHandling
public Predicate`1<object> ShouldSerialize
public Predicate`1<object> ShouldDeserialize
public Predicate`1<object> GetIsSpecified
public Action`2<object, object> SetIsSpecified
public JsonConverter ItemConverter
public Nullable`1<bool> ItemIsReference
public Nullable`1<TypeNameHandling> ItemTypeNameHandling
public Nullable`1<ReferenceLoopHandling> ItemReferenceLoopHandling
internal JsonContract get_PropertyContract()
internal void set_PropertyContract(JsonContract value)
public string get_PropertyName()
public void set_PropertyName(string value)
public Type get_DeclaringType()
public void set_DeclaringType(Type value)
public Nullable`1<int> get_Order()
public void set_Order(Nullable`1<int> value)
public string get_UnderlyingName()
public void set_UnderlyingName(string value)
public IValueProvider get_ValueProvider()
public void set_ValueProvider(IValueProvider value)
public IAttributeProvider get_AttributeProvider()
public void set_AttributeProvider(IAttributeProvider value)
public Type get_PropertyType()
public void set_PropertyType(Type value)
public JsonConverter get_Converter()
public void set_Converter(JsonConverter value)
public JsonConverter get_MemberConverter()
public void set_MemberConverter(JsonConverter value)
public bool get_Ignored()
public void set_Ignored(bool value)
public bool get_Readable()
public void set_Readable(bool value)
public bool get_Writable()
public void set_Writable(bool value)
public bool get_HasMemberAttribute()
public void set_HasMemberAttribute(bool value)
public object get_DefaultValue()
public void set_DefaultValue(object value)
internal object GetResolvedDefaultValue()
public Required get_Required()
public void set_Required(Required value)
public Nullable`1<bool> get_IsReference()
public void set_IsReference(Nullable`1<bool> value)
public Nullable`1<NullValueHandling> get_NullValueHandling()
public void set_NullValueHandling(Nullable`1<NullValueHandling> value)
public Nullable`1<DefaultValueHandling> get_DefaultValueHandling()
public void set_DefaultValueHandling(Nullable`1<DefaultValueHandling> value)
public Nullable`1<ReferenceLoopHandling> get_ReferenceLoopHandling()
public void set_ReferenceLoopHandling(Nullable`1<ReferenceLoopHandling> value)
public Nullable`1<ObjectCreationHandling> get_ObjectCreationHandling()
public void set_ObjectCreationHandling(Nullable`1<ObjectCreationHandling> value)
public Nullable`1<TypeNameHandling> get_TypeNameHandling()
public void set_TypeNameHandling(Nullable`1<TypeNameHandling> value)
public Predicate`1<object> get_ShouldSerialize()
public void set_ShouldSerialize(Predicate`1<object> value)
public Predicate`1<object> get_ShouldDeserialize()
public void set_ShouldDeserialize(Predicate`1<object> value)
public Predicate`1<object> get_GetIsSpecified()
public void set_GetIsSpecified(Predicate`1<object> value)
public Action`2<object, object> get_SetIsSpecified()
public void set_SetIsSpecified(Action`2<object, object> value)
public string ToString()
public JsonConverter get_ItemConverter()
public void set_ItemConverter(JsonConverter value)
public Nullable`1<bool> get_ItemIsReference()
public void set_ItemIsReference(Nullable`1<bool> value)
public Nullable`1<TypeNameHandling> get_ItemTypeNameHandling()
public void set_ItemTypeNameHandling(Nullable`1<TypeNameHandling> value)
public Nullable`1<ReferenceLoopHandling> get_ItemReferenceLoopHandling()
public void set_ItemReferenceLoopHandling(Nullable`1<ReferenceLoopHandling> value)
internal void WritePropertyName(JsonWriter writer)
}
public Newtonsoft.Json.Serialization.JsonPropertyCollection : KeyedCollection`2<string, JsonProperty> {
private Type _type
private List`1<JsonProperty> _list
public void .ctor(Type type)
protected string GetKeyForItem(JsonProperty item)
public void AddProperty(JsonProperty property)
public JsonProperty GetClosestMatchProperty(string propertyName)
private bool TryGetValue(string key, JsonProperty& item)
public JsonProperty GetProperty(string propertyName, StringComparison comparisonType)
}
internal Newtonsoft.Json.Serialization.JsonSerializerInternalBase : object {
private ErrorContext _currentErrorContext
private BidirectionalDictionary`2<string, object> _mappings
internal JsonSerializer Serializer
internal ITraceWriter TraceWriter
protected JsonSerializerProxy InternalSerializer
internal BidirectionalDictionary`2<string, object> DefaultReferenceMappings
protected void .ctor(JsonSerializer serializer)
internal BidirectionalDictionary`2<string, object> get_DefaultReferenceMappings()
private ErrorContext GetErrorContext(object currentObject, object member, string path, Exception error)
protected void ClearErrorContext()
protected bool IsErrorHandled(object currentObject, JsonContract contract, object keyValue, IJsonLineInfo lineInfo, string path, Exception ex)
}
internal Newtonsoft.Json.Serialization.JsonSerializerInternalReader : JsonSerializerInternalBase {
public void .ctor(JsonSerializer serializer)
public void Populate(JsonReader reader, object target)
private JsonContract GetContractSafe(Type type)
public object Deserialize(JsonReader reader, Type objectType, bool checkAdditionalContent)
private JsonSerializerProxy GetInternalSerializer()
private JToken CreateJToken(JsonReader reader, JsonContract contract)
private JToken CreateJObject(JsonReader reader)
private object CreateValueInternal(JsonReader reader, Type objectType, JsonContract contract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerMember, object existingValue)
private bool CoerceEmptyStringToNull(Type objectType, JsonContract contract, string s)
internal string GetExpectedDescription(JsonContract contract)
private JsonConverter GetConverter(JsonContract contract, JsonConverter memberConverter, JsonContainerContract containerContract, JsonProperty containerProperty)
private object CreateObject(JsonReader reader, Type objectType, JsonContract contract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerMember, object existingValue)
private bool ReadMetadataPropertiesToken(JTokenReader reader, Type& objectType, JsonContract& contract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerMember, object existingValue, Object& newValue, String& id)
private bool ReadMetadataProperties(JsonReader reader, Type& objectType, JsonContract& contract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerMember, object existingValue, Object& newValue, String& id)
private void ResolveTypeName(JsonReader reader, Type& objectType, JsonContract& contract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerMember, string qualifiedTypeName)
private JsonArrayContract EnsureArrayContract(JsonReader reader, Type objectType, JsonContract contract)
private object CreateList(JsonReader reader, Type objectType, JsonContract contract, JsonProperty member, object existingValue, string id)
private bool HasNoDefinedType(JsonContract contract)
private object EnsureType(JsonReader reader, object value, CultureInfo culture, JsonContract contract, Type targetType)
private bool SetPropertyValue(JsonProperty property, JsonConverter propertyConverter, JsonContainerContract containerContract, JsonProperty containerProperty, JsonReader reader, object target)
private bool CalculatePropertyDetails(JsonProperty property, JsonConverter& propertyConverter, JsonContainerContract containerContract, JsonProperty containerProperty, JsonReader reader, object target, Boolean& useExistingValue, Object& currentValue, JsonContract& propertyContract, Boolean& gottenCurrentValue)
private void AddReference(JsonReader reader, string id, object value)
private bool HasFlag(DefaultValueHandling value, DefaultValueHandling flag)
private bool ShouldSetPropertyValue(JsonProperty property, object value)
private IList CreateNewList(JsonReader reader, JsonArrayContract contract, Boolean& createdFromNonDefaultCreator)
private IDictionary CreateNewDictionary(JsonReader reader, JsonDictionaryContract contract, Boolean& createdFromNonDefaultCreator)
private void OnDeserializing(JsonReader reader, JsonContract contract, object value)
private void OnDeserialized(JsonReader reader, JsonContract contract, object value)
private object PopulateDictionary(IDictionary dictionary, JsonReader reader, JsonDictionaryContract contract, JsonProperty containerProperty, string id)
private object PopulateMultidimensionalArray(IList list, JsonReader reader, JsonArrayContract contract, JsonProperty containerProperty, string id)
private void ThrowUnexpectedEndException(JsonReader reader, JsonContract contract, object currentObject, string message)
private object PopulateList(IList list, JsonReader reader, JsonArrayContract contract, JsonProperty containerProperty, string id)
private object CreateISerializable(JsonReader reader, JsonISerializableContract contract, JsonProperty member, string id)
internal object CreateISerializableItem(JToken token, Type type, JsonISerializableContract contract, JsonProperty member)
private object CreateObjectUsingCreatorWithParameters(JsonReader reader, JsonObjectContract contract, JsonProperty containerProperty, ObjectConstructor`1<object> creator, string id)
private object DeserializeConvertable(JsonConverter converter, JsonReader reader, Type objectType, object existingValue)
private List`1<CreatorPropertyContext> ResolvePropertyAndCreatorValues(JsonObjectContract contract, JsonProperty containerProperty, JsonReader reader, Type objectType)
private bool ReadForType(JsonReader reader, JsonContract contract, bool hasConverter)
public object CreateNewObject(JsonReader reader, JsonObjectContract objectContract, JsonProperty containerMember, JsonProperty containerProperty, string id, Boolean& createdFromNonDefaultCreator)
private object PopulateObject(object newObject, JsonReader reader, JsonObjectContract contract, JsonProperty member, string id)
private bool ShouldDeserialize(JsonReader reader, JsonProperty property, object target)
private bool CheckPropertyName(JsonReader reader, string memberName)
private void SetExtensionData(JsonObjectContract contract, JsonProperty member, JsonReader reader, string memberName, object o)
private object ReadExtensionDataValue(JsonObjectContract contract, JsonProperty member, JsonReader reader)
private void EndProcessProperty(object newObject, JsonReader reader, JsonObjectContract contract, int initialDepth, JsonProperty property, PropertyPresence presence, bool setDefaultValue)
private void SetPropertyPresence(JsonReader reader, JsonProperty property, Dictionary`2<JsonProperty, PropertyPresence> requiredProperties)
private void HandleError(JsonReader reader, bool readPastError, int initialDepth)
}
internal Newtonsoft.Json.Serialization.JsonSerializerInternalWriter : JsonSerializerInternalBase {
private Type _rootType
private int _rootLevel
private List`1<object> _serializeStack
public void .ctor(JsonSerializer serializer)
public void Serialize(JsonWriter jsonWriter, object value, Type objectType)
private JsonSerializerProxy GetInternalSerializer()
private JsonContract GetContractSafe(object value)
private void SerializePrimitive(JsonWriter writer, object value, JsonPrimitiveContract contract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerProperty)
private void SerializeValue(JsonWriter writer, object value, JsonContract valueContract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerProperty)
private Nullable`1<bool> ResolveIsReference(JsonContract contract, JsonProperty property, JsonContainerContract collectionContract, JsonProperty containerProperty)
private bool ShouldWriteReference(object value, JsonProperty property, JsonContract valueContract, JsonContainerContract collectionContract, JsonProperty containerProperty)
private bool ShouldWriteProperty(object memberValue, JsonProperty property)
private bool CheckForCircularReference(JsonWriter writer, object value, JsonProperty property, JsonContract contract, JsonContainerContract containerContract, JsonProperty containerProperty)
private void WriteReference(JsonWriter writer, object value)
private string GetReference(JsonWriter writer, object value)
internal bool TryConvertToString(object value, Type type, String& s)
private void SerializeString(JsonWriter writer, object value, JsonStringContract contract)
private void OnSerializing(JsonWriter writer, JsonContract contract, object value)
private void OnSerialized(JsonWriter writer, JsonContract contract, object value)
private void SerializeObject(JsonWriter writer, object value, JsonObjectContract contract, JsonProperty member, JsonContainerContract collectionContract, JsonProperty containerProperty)
private bool CalculatePropertyValues(JsonWriter writer, object value, JsonContainerContract contract, JsonProperty member, JsonProperty property, JsonContract& memberContract, Object& memberValue)
private void WriteObjectStart(JsonWriter writer, object value, JsonContract contract, JsonProperty member, JsonContainerContract collectionContract, JsonProperty containerProperty)
private void WriteReferenceIdProperty(JsonWriter writer, Type type, object value)
private void WriteTypeProperty(JsonWriter writer, Type type)
private bool HasFlag(DefaultValueHandling value, DefaultValueHandling flag)
private bool HasFlag(PreserveReferencesHandling value, PreserveReferencesHandling flag)
private bool HasFlag(TypeNameHandling value, TypeNameHandling flag)
private void SerializeConvertable(JsonWriter writer, JsonConverter converter, object value, JsonContract contract, JsonContainerContract collectionContract, JsonProperty containerProperty)
private void SerializeList(JsonWriter writer, IEnumerable values, JsonArrayContract contract, JsonProperty member, JsonContainerContract collectionContract, JsonProperty containerProperty)
private void SerializeMultidimensionalArray(JsonWriter writer, Array values, JsonArrayContract contract, JsonProperty member, JsonContainerContract collectionContract, JsonProperty containerProperty)
private void SerializeMultidimensionalArray(JsonWriter writer, Array values, JsonArrayContract contract, JsonProperty member, int initialDepth, Int32[] indices)
private bool WriteStartArray(JsonWriter writer, object values, JsonArrayContract contract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerProperty)
private void SerializeISerializable(JsonWriter writer, ISerializable value, JsonISerializableContract contract, JsonProperty member, JsonContainerContract collectionContract, JsonProperty containerProperty)
private bool ShouldWriteDynamicProperty(object memberValue)
private bool ShouldWriteType(TypeNameHandling typeNameHandlingFlag, JsonContract contract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerProperty)
private void SerializeDictionary(JsonWriter writer, IDictionary values, JsonDictionaryContract contract, JsonProperty member, JsonContainerContract collectionContract, JsonProperty containerProperty)
private string GetPropertyName(JsonWriter writer, object name, JsonContract contract, Boolean& escape)
private void HandleError(JsonWriter writer, int initialDepth)
private bool ShouldSerialize(JsonWriter writer, JsonProperty property, object target)
private bool IsSpecified(JsonWriter writer, JsonProperty property, object target)
}
internal Newtonsoft.Json.Serialization.JsonSerializerProxy : JsonSerializer {
private JsonSerializerInternalReader _serializerReader
private JsonSerializerInternalWriter _serializerWriter
private JsonSerializer _serializer
public IReferenceResolver ReferenceResolver
public ITraceWriter TraceWriter
public IEqualityComparer EqualityComparer
public JsonConverterCollection Converters
public DefaultValueHandling DefaultValueHandling
public IContractResolver ContractResolver
public MissingMemberHandling MissingMemberHandling
public NullValueHandling NullValueHandling
public ObjectCreationHandling ObjectCreationHandling
public ReferenceLoopHandling ReferenceLoopHandling
public PreserveReferencesHandling PreserveReferencesHandling
public TypeNameHandling TypeNameHandling
public MetadataPropertyHandling MetadataPropertyHandling
public FormatterAssemblyStyle TypeNameAssemblyFormat
public ConstructorHandling ConstructorHandling
public SerializationBinder Binder
public StreamingContext Context
public Formatting Formatting
public DateFormatHandling DateFormatHandling
public DateTimeZoneHandling DateTimeZoneHandling
public DateParseHandling DateParseHandling
public FloatFormatHandling FloatFormatHandling
public FloatParseHandling FloatParseHandling
public StringEscapeHandling StringEscapeHandling
public string DateFormatString
public CultureInfo Culture
public Nullable`1<int> MaxDepth
public bool CheckAdditionalContent
public void add_Error(EventHandler`1<ErrorEventArgs> value)
public void remove_Error(EventHandler`1<ErrorEventArgs> value)
public IReferenceResolver get_ReferenceResolver()
public void set_ReferenceResolver(IReferenceResolver value)
public ITraceWriter get_TraceWriter()
public void set_TraceWriter(ITraceWriter value)
public IEqualityComparer get_EqualityComparer()
public void set_EqualityComparer(IEqualityComparer value)
public JsonConverterCollection get_Converters()
public DefaultValueHandling get_DefaultValueHandling()
public void set_DefaultValueHandling(DefaultValueHandling value)
public IContractResolver get_ContractResolver()
public void set_ContractResolver(IContractResolver value)
public MissingMemberHandling get_MissingMemberHandling()
public void set_MissingMemberHandling(MissingMemberHandling value)
public NullValueHandling get_NullValueHandling()
public void set_NullValueHandling(NullValueHandling value)
public ObjectCreationHandling get_ObjectCreationHandling()
public void set_ObjectCreationHandling(ObjectCreationHandling value)
public ReferenceLoopHandling get_ReferenceLoopHandling()
public void set_ReferenceLoopHandling(ReferenceLoopHandling value)
public PreserveReferencesHandling get_PreserveReferencesHandling()
public void set_PreserveReferencesHandling(PreserveReferencesHandling value)
public TypeNameHandling get_TypeNameHandling()
public void set_TypeNameHandling(TypeNameHandling value)
public MetadataPropertyHandling get_MetadataPropertyHandling()
public void set_MetadataPropertyHandling(MetadataPropertyHandling value)
public FormatterAssemblyStyle get_TypeNameAssemblyFormat()
public void set_TypeNameAssemblyFormat(FormatterAssemblyStyle value)
public ConstructorHandling get_ConstructorHandling()
public void set_ConstructorHandling(ConstructorHandling value)
public SerializationBinder get_Binder()
public void set_Binder(SerializationBinder value)
public StreamingContext get_Context()
public void set_Context(StreamingContext value)
public Formatting get_Formatting()
public void set_Formatting(Formatting value)
public DateFormatHandling get_DateFormatHandling()
public void set_DateFormatHandling(DateFormatHandling value)
public DateTimeZoneHandling get_DateTimeZoneHandling()
public void set_DateTimeZoneHandling(DateTimeZoneHandling value)
public DateParseHandling get_DateParseHandling()
public void set_DateParseHandling(DateParseHandling value)
public FloatFormatHandling get_FloatFormatHandling()
public void set_FloatFormatHandling(FloatFormatHandling value)
public FloatParseHandling get_FloatParseHandling()
public void set_FloatParseHandling(FloatParseHandling value)
public StringEscapeHandling get_StringEscapeHandling()
public void set_StringEscapeHandling(StringEscapeHandling value)
public string get_DateFormatString()
public void set_DateFormatString(string value)
public CultureInfo get_Culture()
public void set_Culture(CultureInfo value)
public Nullable`1<int> get_MaxDepth()
public void set_MaxDepth(Nullable`1<int> value)
public bool get_CheckAdditionalContent()
public void set_CheckAdditionalContent(bool value)
internal JsonSerializerInternalBase GetInternalSerializer()
public void .ctor(JsonSerializerInternalReader serializerReader)
public void .ctor(JsonSerializerInternalWriter serializerWriter)
internal object DeserializeInternal(JsonReader reader, Type objectType)
internal void PopulateInternal(JsonReader reader, object target)
internal void SerializeInternal(JsonWriter jsonWriter, object value, Type rootType)
}
public Newtonsoft.Json.Serialization.JsonStringContract : JsonPrimitiveContract {
public void .ctor(Type underlyingType)
}
internal Newtonsoft.Json.Serialization.JsonTypeReflector : object {
private Nullable`1<bool> _dynamicCodeGeneration
private Nullable`1<bool> _fullyTrusted
public string IdPropertyName
public string RefPropertyName
public string TypePropertyName
public string ValuePropertyName
public string ArrayValuesPropertyName
public string ShouldSerializePrefix
public string SpecifiedPostfix
private ThreadSafeStore`2<Type, Func`2<Object[], JsonConverter>> JsonConverterCreatorCache
private ThreadSafeStore`2<Type, Type> AssociatedMetadataTypesCache
private ReflectionObject _metadataTypeAttributeReflectionObject
public bool DynamicCodeGeneration
public bool FullyTrusted
public ReflectionDelegateFactory ReflectionDelegateFactory
public T GetCachedAttribute(object attributeProvider)
public DataContractAttribute GetDataContractAttribute(Type type)
public DataMemberAttribute GetDataMemberAttribute(MemberInfo memberInfo)
public MemberSerialization GetObjectMemberSerialization(Type objectType, bool ignoreSerializableAttribute)
public JsonConverter GetJsonConverter(object attributeProvider)
public JsonConverter CreateJsonConverterInstance(Type converterType, Object[] converterArgs)
private Func`2<Object[], JsonConverter> GetJsonConverterCreator(Type converterType)
public TypeConverter GetTypeConverter(Type type)
private Type GetAssociatedMetadataType(Type type)
private Type GetAssociateMetadataTypeFromAttribute(Type type)
private T GetAttribute(Type type)
private T GetAttribute(MemberInfo memberInfo)
public T GetAttribute(object provider)
public bool get_DynamicCodeGeneration()
public bool get_FullyTrusted()
public ReflectionDelegateFactory get_ReflectionDelegateFactory()
}
public Newtonsoft.Json.Serialization.MemoryTraceWriter : object {
private Queue`1<string> _traceMessages
private TraceLevel <LevelFilter>k__BackingField
public TraceLevel LevelFilter
public TraceLevel get_LevelFilter()
public void set_LevelFilter(TraceLevel value)
public void Trace(TraceLevel level, string message, Exception ex)
public IEnumerable`1<string> GetTraceMessages()
public string ToString()
}
public Newtonsoft.Json.Serialization.ObjectConstructor`1 : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public object Invoke(Object[] args)
public IAsyncResult BeginInvoke(Object[] args, AsyncCallback callback, object object)
public object EndInvoke(IAsyncResult result)
}
public Newtonsoft.Json.Serialization.ReflectionAttributeProvider : object {
private object _attributeProvider
public void .ctor(object attributeProvider)
public IList`1<Attribute> GetAttributes(bool inherit)
public IList`1<Attribute> GetAttributes(Type attributeType, bool inherit)
}
public Newtonsoft.Json.Serialization.ReflectionValueProvider : object {
private MemberInfo _memberInfo
public void .ctor(MemberInfo memberInfo)
public void SetValue(object target, object value)
public object GetValue(object target)
}
internal Newtonsoft.Json.Serialization.ResolverContractKey : ValueType {
private Type _resolverType
private Type _contractType
public void .ctor(Type resolverType, Type contractType)
public int GetHashCode()
public bool Equals(object obj)
public bool Equals(ResolverContractKey other)
}
public Newtonsoft.Json.Serialization.SerializationCallback : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object o, StreamingContext context)
public IAsyncResult BeginInvoke(object o, StreamingContext context, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public Newtonsoft.Json.Serialization.SerializationErrorCallback : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object o, StreamingContext context, ErrorContext errorContext)
public IAsyncResult BeginInvoke(object o, StreamingContext context, ErrorContext errorContext, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
internal Newtonsoft.Json.Serialization.TraceJsonReader : JsonReader {
private JsonReader _innerReader
private JsonTextWriter _textWriter
private StringWriter _sw
public int Depth
public string Path
public char QuoteChar
public JsonToken TokenType
public object Value
public Type ValueType
private int Newtonsoft.Json.IJsonLineInfo.LineNumber
private int Newtonsoft.Json.IJsonLineInfo.LinePosition
public void .ctor(JsonReader innerReader)
public string GetDeserializedJsonMessage()
public bool Read()
public Nullable`1<int> ReadAsInt32()
public string ReadAsString()
public Byte[] ReadAsBytes()
public Nullable`1<decimal> ReadAsDecimal()
public Nullable`1<double> ReadAsDouble()
public Nullable`1<bool> ReadAsBoolean()
public Nullable`1<DateTime> ReadAsDateTime()
public Nullable`1<DateTimeOffset> ReadAsDateTimeOffset()
public int get_Depth()
public string get_Path()
public char get_QuoteChar()
protected internal void set_QuoteChar(char value)
public JsonToken get_TokenType()
public object get_Value()
public Type get_ValueType()
public void Close()
private bool Newtonsoft.Json.IJsonLineInfo.HasLineInfo()
private int Newtonsoft.Json.IJsonLineInfo.get_LineNumber()
private int Newtonsoft.Json.IJsonLineInfo.get_LinePosition()
}
internal Newtonsoft.Json.Serialization.TraceJsonWriter : JsonWriter {
private JsonWriter _innerWriter
private JsonTextWriter _textWriter
private StringWriter _sw
public void .ctor(JsonWriter innerWriter)
public string GetSerializedJsonMessage()
public void WriteValue(decimal value)
public void WriteValue(bool value)
public void WriteValue(byte value)
public void WriteValue(Nullable`1<byte> value)
public void WriteValue(char value)
public void WriteValue(Byte[] value)
public void WriteValue(DateTime value)
public void WriteValue(DateTimeOffset value)
public void WriteValue(double value)
public void WriteUndefined()
public void WriteNull()
public void WriteValue(float value)
public void WriteValue(Guid value)
public void WriteValue(int value)
public void WriteValue(long value)
public void WriteValue(object value)
public void WriteValue(sbyte value)
public void WriteValue(short value)
public void WriteValue(string value)
public void WriteValue(TimeSpan value)
public void WriteValue(UInt32 value)
public void WriteValue(ulong value)
public void WriteValue(Uri value)
public void WriteValue(ushort value)
public void WriteWhitespace(string ws)
public void WriteComment(string text)
public void WriteStartArray()
public void WriteEndArray()
public void WriteStartConstructor(string name)
public void WriteEndConstructor()
public void WritePropertyName(string name)
public void WritePropertyName(string name, bool escape)
public void WriteStartObject()
public void WriteEndObject()
public void WriteRawValue(string json)
public void WriteRaw(string json)
public void Close()
public void Flush()
}
public Newtonsoft.Json.StringEscapeHandling : Enum {
public int value__
public StringEscapeHandling Default
public StringEscapeHandling EscapeNonAscii
public StringEscapeHandling EscapeHtml
}
public Newtonsoft.Json.TypeNameHandling : Enum {
public int value__
public TypeNameHandling None
public TypeNameHandling Objects
public TypeNameHandling Arrays
public TypeNameHandling All
public TypeNameHandling Auto
}
internal Newtonsoft.Json.Utilities.Base64Encoder : object {
private int Base64LineSize
private int LineSizeInBytes
private Char[] _charsLine
private TextWriter _writer
private Byte[] _leftOverBytes
private int _leftOverBytesCount
public void .ctor(TextWriter writer)
public void Encode(Byte[] buffer, int index, int count)
public void Flush()
private void WriteChars(Char[] chars, int index, int count)
}
internal Newtonsoft.Json.Utilities.BidirectionalDictionary`2 : object {
private IDictionary`2<TFirst, TSecond> _firstToSecond
private IDictionary`2<TSecond, TFirst> _secondToFirst
private string _duplicateFirstErrorMessage
private string _duplicateSecondErrorMessage
public void .ctor(IEqualityComparer`1<TFirst> firstEqualityComparer, IEqualityComparer`1<TSecond> secondEqualityComparer)
public void .ctor(IEqualityComparer`1<TFirst> firstEqualityComparer, IEqualityComparer`1<TSecond> secondEqualityComparer, string duplicateFirstErrorMessage, string duplicateSecondErrorMessage)
public void Set(TFirst first, TSecond second)
public bool TryGetByFirst(TFirst first, TSecond& second)
public bool TryGetBySecond(TSecond second, TFirst& first)
}
internal Newtonsoft.Json.Utilities.BufferUtils : object {
public Char[] RentBuffer(IArrayPool`1<char> bufferPool, int minSize)
public void ReturnBuffer(IArrayPool`1<char> bufferPool, Char[] buffer)
public Char[] EnsureBufferSize(IArrayPool`1<char> bufferPool, int size, Char[] buffer)
}
internal Newtonsoft.Json.Utilities.CollectionUtils : object {
public bool IsNullOrEmpty(ICollection`1<T> collection)
public void AddRange(IList`1<T> initial, IEnumerable`1<T> collection)
public void AddRange(IList`1<T> initial, IEnumerable collection)
public bool IsDictionaryType(Type type)
public ConstructorInfo ResolveEnumerableCollectionConstructor(Type collectionType, Type collectionItemType)
public ConstructorInfo ResolveEnumerableCollectionConstructor(Type collectionType, Type collectionItemType, Type constructorArgumentType)
public bool AddDistinct(IList`1<T> list, T value)
public bool AddDistinct(IList`1<T> list, T value, IEqualityComparer`1<T> comparer)
public bool ContainsValue(IEnumerable`1<TSource> source, TSource value, IEqualityComparer`1<TSource> comparer)
public bool AddRangeDistinct(IList`1<T> list, IEnumerable`1<T> values, IEqualityComparer`1<T> comparer)
public int IndexOf(IEnumerable`1<T> collection, Func`2<T, bool> predicate)
public bool Contains(List`1<T> list, T value, IEqualityComparer comparer)
public int IndexOfReference(List`1<T> list, T item)
private IList`1<int> GetDimensions(IList values, int dimensionsCount)
private void CopyFromJaggedToMultidimensionalArray(IList values, Array multidimensionalArray, Int32[] indices)
private object JaggedArrayGetValue(IList values, Int32[] indices)
public Array ToMultidimensionalArray(IList values, Type type, int rank)
}
internal Newtonsoft.Json.Utilities.CollectionWrapper`1 : object {
private IList _list
private ICollection`1<T> _genericCollection
private object _syncRoot
public int Count
public bool IsReadOnly
private bool System.Collections.IList.IsFixedSize
private object System.Collections.IList.Item
private bool System.Collections.ICollection.IsSynchronized
private object System.Collections.ICollection.SyncRoot
public object UnderlyingCollection
public void .ctor(IList list)
public void .ctor(ICollection`1<T> list)
public void Add(T item)
public void Clear()
public bool Contains(T item)
public void CopyTo(T[] array, int arrayIndex)
public int get_Count()
public bool get_IsReadOnly()
public bool Remove(T item)
public IEnumerator`1<T> GetEnumerator()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
private int System.Collections.IList.Add(object value)
private bool System.Collections.IList.Contains(object value)
private int System.Collections.IList.IndexOf(object value)
private void System.Collections.IList.RemoveAt(int index)
private void System.Collections.IList.Insert(int index, object value)
private bool System.Collections.IList.get_IsFixedSize()
private void System.Collections.IList.Remove(object value)
private object System.Collections.IList.get_Item(int index)
private void System.Collections.IList.set_Item(int index, object value)
private void System.Collections.ICollection.CopyTo(Array array, int arrayIndex)
private bool System.Collections.ICollection.get_IsSynchronized()
private object System.Collections.ICollection.get_SyncRoot()
private void VerifyValueType(object value)
private bool IsCompatibleObject(object value)
public object get_UnderlyingCollection()
}
internal Newtonsoft.Json.Utilities.ConvertUtils : object {
private Dictionary`2<Type, PrimitiveTypeCode> TypeCodeMap
private TypeInformation[] PrimitiveTypeCodes
private ThreadSafeStore`2<TypeConvertKey, Func`2<object, object>> CastConverters
public PrimitiveTypeCode GetTypeCode(Type t)
public PrimitiveTypeCode GetTypeCode(Type t, Boolean& isEnum)
public TypeInformation GetTypeInformation(IConvertible convertable)
public bool IsConvertible(Type t)
public TimeSpan ParseTimeSpan(string input)
private Func`2<object, object> CreateCastConverter(TypeConvertKey t)
public object Convert(object initialValue, CultureInfo culture, Type targetType)
private bool TryConvert(object initialValue, CultureInfo culture, Type targetType, Object& value)
private ConvertResult TryConvertInternal(object initialValue, CultureInfo culture, Type targetType, Object& value)
public object ConvertOrCast(object initialValue, CultureInfo culture, Type targetType)
private object EnsureTypeAssignable(object value, Type initialType, Type targetType)
internal TypeConverter GetConverter(Type t)
public bool VersionTryParse(string input, Version& result)
public bool IsInteger(object value)
public ParseResult Int32TryParse(Char[] chars, int start, int length, Int32& value)
public ParseResult Int64TryParse(Char[] chars, int start, int length, Int64& value)
public bool TryConvertGuid(string s, Guid& g)
public int HexTextToInt(Char[] text, int start, int end)
private int HexCharToInt(char ch)
}
internal Newtonsoft.Json.Utilities.Creator`1 : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public T Invoke()
public IAsyncResult BeginInvoke(AsyncCallback callback, object object)
public T EndInvoke(IAsyncResult result)
}
internal Newtonsoft.Json.Utilities.DateTimeParser : ValueType {
public int Year
public int Month
public int Day
public int Hour
public int Minute
public int Second
public int Fraction
public int ZoneHour
public int ZoneMinute
public ParserTimeZone Zone
private Char[] _text
private int _end
private Int32[] Power10
private int Lzyyyy
private int Lzyyyy_
private int Lzyyyy_MM
private int Lzyyyy_MM_
private int Lzyyyy_MM_dd
private int Lzyyyy_MM_ddT
private int LzHH
private int LzHH_
private int LzHH_mm
private int LzHH_mm_
private int LzHH_mm_ss
private int Lz_
private int Lz_zz
private short MaxFractionDigits
public bool Parse(Char[] text, int startIndex, int length)
private bool ParseDate(int start)
private bool ParseTimeAndZoneAndWhitespace(int start)
private bool ParseTime(Int32& start)
private bool ParseZone(int start)
private bool Parse4Digit(int start, Int32& num)
private bool Parse2Digit(int start, Int32& num)
private bool ParseChar(int start, char ch)
}
internal Newtonsoft.Json.Utilities.DateTimeUtils : object {
internal long InitialJavaScriptDateTicks
private string IsoDateFormat
private int DaysPer100Years
private int DaysPer400Years
private int DaysPer4Years
private int DaysPerYear
private long TicksPerDay
private Int32[] DaysToMonth365
private Int32[] DaysToMonth366
public TimeSpan GetUtcOffset(DateTime d)
public XmlDateTimeSerializationMode ToSerializationMode(DateTimeKind kind)
internal DateTime EnsureDateTime(DateTime value, DateTimeZoneHandling timeZone)
private DateTime SwitchToLocalTime(DateTime value)
private DateTime SwitchToUtcTime(DateTime value)
private long ToUniversalTicks(DateTime dateTime)
private long ToUniversalTicks(DateTime dateTime, TimeSpan offset)
internal long ConvertDateTimeToJavaScriptTicks(DateTime dateTime, TimeSpan offset)
internal long ConvertDateTimeToJavaScriptTicks(DateTime dateTime)
internal long ConvertDateTimeToJavaScriptTicks(DateTime dateTime, bool convertToUtc)
private long UniversialTicksToJavaScriptTicks(long universialTicks)
internal DateTime ConvertJavaScriptTicksToDateTime(long javaScriptTicks)
internal bool TryParseDateTimeIso(StringReference text, DateTimeZoneHandling dateTimeZoneHandling, DateTime& dt)
internal bool TryParseDateTimeOffsetIso(StringReference text, DateTimeOffset& dt)
private DateTime CreateDateTime(DateTimeParser dateTimeParser)
internal bool TryParseDateTime(StringReference s, DateTimeZoneHandling dateTimeZoneHandling, string dateFormatString, CultureInfo culture, DateTime& dt)
internal bool TryParseDateTime(string s, DateTimeZoneHandling dateTimeZoneHandling, string dateFormatString, CultureInfo culture, DateTime& dt)
internal bool TryParseDateTimeOffset(StringReference s, string dateFormatString, CultureInfo culture, DateTimeOffset& dt)
internal bool TryParseDateTimeOffset(string s, string dateFormatString, CultureInfo culture, DateTimeOffset& dt)
private bool TryParseMicrosoftDate(StringReference text, Int64& ticks, TimeSpan& offset, DateTimeKind& kind)
private bool TryParseDateTimeMicrosoft(StringReference text, DateTimeZoneHandling dateTimeZoneHandling, DateTime& dt)
private bool TryParseDateTimeExact(string text, DateTimeZoneHandling dateTimeZoneHandling, string dateFormatString, CultureInfo culture, DateTime& dt)
private bool TryParseDateTimeOffsetMicrosoft(StringReference text, DateTimeOffset& dt)
private bool TryParseDateTimeOffsetExact(string text, string dateFormatString, CultureInfo culture, DateTimeOffset& dt)
private bool TryReadOffset(StringReference offsetText, int startIndex, TimeSpan& offset)
internal void WriteDateTimeString(TextWriter writer, DateTime value, DateFormatHandling format, string formatString, CultureInfo culture)
internal int WriteDateTimeString(Char[] chars, int start, DateTime value, Nullable`1<TimeSpan> offset, DateTimeKind kind, DateFormatHandling format)
internal int WriteDefaultIsoDate(Char[] chars, int start, DateTime dt)
private void CopyIntToCharArray(Char[] chars, int start, int value, int digits)
internal int WriteDateTimeOffset(Char[] chars, int start, TimeSpan offset, DateFormatHandling format)
internal void WriteDateTimeOffsetString(TextWriter writer, DateTimeOffset value, DateFormatHandling format, string formatString, CultureInfo culture)
private void GetDateValues(DateTime td, Int32& year, Int32& month, Int32& day)
}
internal Newtonsoft.Json.Utilities.DictionaryWrapper`2 : object {
private IDictionary _dictionary
private IDictionary`2<TKey, TValue> _genericDictionary
private object _syncRoot
public ICollection`1<TKey> Keys
public ICollection`1<TValue> Values
public TValue Item
public int Count
public bool IsReadOnly
private object System.Collections.IDictionary.Item
private bool System.Collections.IDictionary.IsFixedSize
private ICollection System.Collections.IDictionary.Keys
private ICollection System.Collections.IDictionary.Values
private bool System.Collections.ICollection.IsSynchronized
private object System.Collections.ICollection.SyncRoot
public object UnderlyingDictionary
public void .ctor(IDictionary dictionary)
public void .ctor(IDictionary`2<TKey, TValue> dictionary)
public void Add(TKey key, TValue value)
public bool ContainsKey(TKey key)
public ICollection`1<TKey> get_Keys()
public bool Remove(TKey key)
public bool TryGetValue(TKey key, TValue& value)
public ICollection`1<TValue> get_Values()
public TValue get_Item(TKey key)
public void set_Item(TKey key, TValue value)
public void Add(KeyValuePair`2<TKey, TValue> item)
public void Clear()
public bool Contains(KeyValuePair`2<TKey, TValue> item)
public void CopyTo(KeyValuePair`2[] array, int arrayIndex)
public int get_Count()
public bool get_IsReadOnly()
public bool Remove(KeyValuePair`2<TKey, TValue> item)
public IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
private void System.Collections.IDictionary.Add(object key, object value)
private object System.Collections.IDictionary.get_Item(object key)
private void System.Collections.IDictionary.set_Item(object key, object value)
private IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator()
private bool System.Collections.IDictionary.Contains(object key)
private bool System.Collections.IDictionary.get_IsFixedSize()
private ICollection System.Collections.IDictionary.get_Keys()
public void Remove(object key)
private ICollection System.Collections.IDictionary.get_Values()
private void System.Collections.ICollection.CopyTo(Array array, int index)
private bool System.Collections.ICollection.get_IsSynchronized()
private object System.Collections.ICollection.get_SyncRoot()
public object get_UnderlyingDictionary()
}
internal Newtonsoft.Json.Utilities.DynamicReflectionDelegateFactory : ReflectionDelegateFactory {
public DynamicReflectionDelegateFactory Instance
private DynamicMethod CreateDynamicMethod(string name, Type returnType, Type[] parameterTypes, Type owner)
public ObjectConstructor`1<object> CreateParameterizedConstructor(MethodBase method)
public MethodCall`2<T, object> CreateMethodCall(MethodBase method)
private void GenerateCreateMethodCallIL(MethodBase method, ILGenerator generator, int argsIndex)
public Func`1<T> CreateDefaultConstructor(Type type)
private void GenerateCreateDefaultConstructorIL(Type type, ILGenerator generator)
public Func`2<T, object> CreateGet(PropertyInfo propertyInfo)
private void GenerateCreateGetPropertyIL(PropertyInfo propertyInfo, ILGenerator generator)
public Func`2<T, object> CreateGet(FieldInfo fieldInfo)
private void GenerateCreateGetFieldIL(FieldInfo fieldInfo, ILGenerator generator)
public Action`2<T, object> CreateSet(FieldInfo fieldInfo)
internal void GenerateCreateSetFieldIL(FieldInfo fieldInfo, ILGenerator generator)
public Action`2<T, object> CreateSet(PropertyInfo propertyInfo)
internal void GenerateCreateSetPropertyIL(PropertyInfo propertyInfo, ILGenerator generator)
}
internal Newtonsoft.Json.Utilities.EnumUtils : object {
private ThreadSafeStore`2<Type, BidirectionalDictionary`2<string, string>> EnumMemberNamesPerType
private BidirectionalDictionary`2<string, string> InitializeEnumType(Type type)
public IList`1<T> GetFlagsValues(T value)
public IList`1<EnumValue`1<ulong>> GetNamesAndValues()
public IList`1<EnumValue`1<TUnderlyingType>> GetNamesAndValues(Type enumType)
public IList`1<object> GetValues(Type enumType)
public IList`1<string> GetNames(Type enumType)
public object ParseEnumName(string enumText, bool isNullable, Type t)
public string ToEnumName(Type enumType, string enumText, bool camelCaseText)
private string ResolvedEnumName(BidirectionalDictionary`2<string, string> map, string enumText)
}
internal Newtonsoft.Json.Utilities.EnumValue`1 : object {
private string _name
private T _value
public string Name
public T Value
public string get_Name()
public T get_Value()
public void .ctor(string name, T value)
}
internal Newtonsoft.Json.Utilities.ILGeneratorExtensions : object {
public void PushInstance(ILGenerator generator, Type type)
public void PushArrayInstance(ILGenerator generator, int argsIndex, int arrayIndex)
public void BoxIfNeeded(ILGenerator generator, Type type)
public void UnboxIfNeeded(ILGenerator generator, Type type)
public void CallMethod(ILGenerator generator, MethodInfo methodInfo)
public void Return(ILGenerator generator)
}
internal Newtonsoft.Json.Utilities.IWrappedCollection {
public object UnderlyingCollection
public object get_UnderlyingCollection()
}
internal Newtonsoft.Json.Utilities.IWrappedDictionary {
public object UnderlyingDictionary
public object get_UnderlyingDictionary()
}
internal Newtonsoft.Json.Utilities.JavaScriptUtils : object {
internal Boolean[] SingleQuoteCharEscapeFlags
internal Boolean[] DoubleQuoteCharEscapeFlags
internal Boolean[] HtmlCharEscapeFlags
private int UnicodeTextLength
private string EscapedUnicodeText
public Boolean[] GetCharEscapeFlags(StringEscapeHandling stringEscapeHandling, char quoteChar)
public bool ShouldEscapeJavaScriptString(string s, Boolean[] charEscapeFlags)
public void WriteEscapedJavaScriptString(TextWriter writer, string s, char delimiter, bool appendDelimiters, Boolean[] charEscapeFlags, StringEscapeHandling stringEscapeHandling, IArrayPool`1<char> bufferPool, Char[]& writeBuffer)
public string ToEscapedJavaScriptString(string value, char delimiter, bool appendDelimiters, StringEscapeHandling stringEscapeHandling)
}
internal Newtonsoft.Json.Utilities.JsonTokenUtils : object {
internal bool IsEndToken(JsonToken token)
internal bool IsStartToken(JsonToken token)
internal bool IsPrimitiveToken(JsonToken token)
}
internal Newtonsoft.Json.Utilities.LateBoundReflectionDelegateFactory : ReflectionDelegateFactory {
private LateBoundReflectionDelegateFactory _instance
internal ReflectionDelegateFactory Instance
internal ReflectionDelegateFactory get_Instance()
public ObjectConstructor`1<object> CreateParameterizedConstructor(MethodBase method)
public MethodCall`2<T, object> CreateMethodCall(MethodBase method)
public Func`1<T> CreateDefaultConstructor(Type type)
public Func`2<T, object> CreateGet(PropertyInfo propertyInfo)
public Func`2<T, object> CreateGet(FieldInfo fieldInfo)
public Action`2<T, object> CreateSet(FieldInfo fieldInfo)
public Action`2<T, object> CreateSet(PropertyInfo propertyInfo)
}
internal Newtonsoft.Json.Utilities.MathUtils : object {
public int IntLength(ulong i)
public char IntToHex(int n)
public Nullable`1<int> Min(Nullable`1<int> val1, Nullable`1<int> val2)
public Nullable`1<int> Max(Nullable`1<int> val1, Nullable`1<int> val2)
public Nullable`1<double> Max(Nullable`1<double> val1, Nullable`1<double> val2)
public bool ApproxEquals(double d1, double d2)
}
internal Newtonsoft.Json.Utilities.MethodCall`2 : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public TResult Invoke(T target, Object[] args)
public IAsyncResult BeginInvoke(T target, Object[] args, AsyncCallback callback, object object)
public TResult EndInvoke(IAsyncResult result)
}
internal Newtonsoft.Json.Utilities.MiscellaneousUtils : object {
public bool ValueEquals(object objA, object objB)
public ArgumentOutOfRangeException CreateArgumentOutOfRangeException(string paramName, object actualValue, string message)
public string ToString(object value)
public int ByteArrayCompare(Byte[] a1, Byte[] a2)
public string GetPrefix(string qualifiedName)
public string GetLocalName(string qualifiedName)
public void GetQualifiedNameParts(string qualifiedName, String& prefix, String& localName)
internal string FormatValueForPrint(object value)
}
internal Newtonsoft.Json.Utilities.ParseResult : Enum {
public int value__
public ParseResult None
public ParseResult Success
public ParseResult Overflow
public ParseResult Invalid
}
internal Newtonsoft.Json.Utilities.ParserTimeZone : Enum {
public int value__
public ParserTimeZone Unspecified
public ParserTimeZone Utc
public ParserTimeZone LocalWestOfUtc
public ParserTimeZone LocalEastOfUtc
}
internal Newtonsoft.Json.Utilities.PrimitiveTypeCode : Enum {
public int value__
public PrimitiveTypeCode Empty
public PrimitiveTypeCode Object
public PrimitiveTypeCode Char
public PrimitiveTypeCode CharNullable
public PrimitiveTypeCode Boolean
public PrimitiveTypeCode BooleanNullable
public PrimitiveTypeCode SByte
public PrimitiveTypeCode SByteNullable
public PrimitiveTypeCode Int16
public PrimitiveTypeCode Int16Nullable
public PrimitiveTypeCode UInt16
public PrimitiveTypeCode UInt16Nullable
public PrimitiveTypeCode Int32
public PrimitiveTypeCode Int32Nullable
public PrimitiveTypeCode Byte
public PrimitiveTypeCode ByteNullable
public PrimitiveTypeCode UInt32
public PrimitiveTypeCode UInt32Nullable
public PrimitiveTypeCode Int64
public PrimitiveTypeCode Int64Nullable
public PrimitiveTypeCode UInt64
public PrimitiveTypeCode UInt64Nullable
public PrimitiveTypeCode Single
public PrimitiveTypeCode SingleNullable
public PrimitiveTypeCode Double
public PrimitiveTypeCode DoubleNullable
public PrimitiveTypeCode DateTime
public PrimitiveTypeCode DateTimeNullable
public PrimitiveTypeCode DateTimeOffset
public PrimitiveTypeCode DateTimeOffsetNullable
public PrimitiveTypeCode Decimal
public PrimitiveTypeCode DecimalNullable
public PrimitiveTypeCode Guid
public PrimitiveTypeCode GuidNullable
public PrimitiveTypeCode TimeSpan
public PrimitiveTypeCode TimeSpanNullable
public PrimitiveTypeCode BigInteger
public PrimitiveTypeCode BigIntegerNullable
public PrimitiveTypeCode Uri
public PrimitiveTypeCode String
public PrimitiveTypeCode Bytes
public PrimitiveTypeCode DBNull
}
internal Newtonsoft.Json.Utilities.PropertyNameTable : object {
private int HashCodeRandomizer
private int _count
private Entry[] _entries
private int _mask
public string Get(Char[] key, int start, int length)
public string Add(string key)
private string AddEntry(string str, int hashCode)
private void Grow()
private bool TextEquals(string str1, Char[] str2, int str2Start, int str2Length)
}
internal Newtonsoft.Json.Utilities.ReflectionDelegateFactory : object {
public Func`2<T, object> CreateGet(MemberInfo memberInfo)
public Action`2<T, object> CreateSet(MemberInfo memberInfo)
public MethodCall`2<T, object> CreateMethodCall(MethodBase method)
public ObjectConstructor`1<object> CreateParameterizedConstructor(MethodBase method)
public Func`1<T> CreateDefaultConstructor(Type type)
public Func`2<T, object> CreateGet(PropertyInfo propertyInfo)
public Func`2<T, object> CreateGet(FieldInfo fieldInfo)
public Action`2<T, object> CreateSet(FieldInfo fieldInfo)
public Action`2<T, object> CreateSet(PropertyInfo propertyInfo)
}
internal Newtonsoft.Json.Utilities.ReflectionMember : object {
private Type <MemberType>k__BackingField
private Func`2<object, object> <Getter>k__BackingField
private Action`2<object, object> <Setter>k__BackingField
public Type MemberType
public Func`2<object, object> Getter
public Action`2<object, object> Setter
public Type get_MemberType()
public void set_MemberType(Type value)
public Func`2<object, object> get_Getter()
public void set_Getter(Func`2<object, object> value)
public Action`2<object, object> get_Setter()
public void set_Setter(Action`2<object, object> value)
}
internal Newtonsoft.Json.Utilities.ReflectionObject : object {
private ObjectConstructor`1<object> <Creator>k__BackingField
private IDictionary`2<string, ReflectionMember> <Members>k__BackingField
public ObjectConstructor`1<object> Creator
public IDictionary`2<string, ReflectionMember> Members
public ObjectConstructor`1<object> get_Creator()
private void set_Creator(ObjectConstructor`1<object> value)
public IDictionary`2<string, ReflectionMember> get_Members()
private void set_Members(IDictionary`2<string, ReflectionMember> value)
public object GetValue(object target, string member)
public void SetValue(object target, string member, object value)
public Type GetType(string member)
public ReflectionObject Create(Type t, String[] memberNames)
public ReflectionObject Create(Type t, MethodBase creator, String[] memberNames)
}
internal Newtonsoft.Json.Utilities.ReflectionUtils : object {
public Type[] EmptyTypes
public bool IsVirtual(PropertyInfo propertyInfo)
public MethodInfo GetBaseDefinition(PropertyInfo propertyInfo)
public bool IsPublic(PropertyInfo property)
public Type GetObjectType(object v)
public string GetTypeName(Type t, FormatterAssemblyStyle assemblyFormat, SerializationBinder binder)
private string RemoveAssemblyDetails(string fullyQualifiedTypeName)
public bool HasDefaultConstructor(Type t, bool nonPublic)
public ConstructorInfo GetDefaultConstructor(Type t)
public ConstructorInfo GetDefaultConstructor(Type t, bool nonPublic)
public bool IsNullable(Type t)
public bool IsNullableType(Type t)
public Type EnsureNotNullableType(Type t)
public bool IsGenericDefinition(Type type, Type genericInterfaceDefinition)
public bool ImplementsGenericDefinition(Type type, Type genericInterfaceDefinition)
public bool ImplementsGenericDefinition(Type type, Type genericInterfaceDefinition, Type& implementingType)
public bool InheritsGenericDefinition(Type type, Type genericClassDefinition)
public bool InheritsGenericDefinition(Type type, Type genericClassDefinition, Type& implementingType)
private bool InheritsGenericDefinitionInternal(Type currentType, Type genericClassDefinition, Type& implementingType)
public Type GetCollectionItemType(Type type)
public void GetDictionaryKeyValueTypes(Type dictionaryType, Type& keyType, Type& valueType)
public Type GetMemberUnderlyingType(MemberInfo member)
public bool IsIndexedProperty(MemberInfo member)
public bool IsIndexedProperty(PropertyInfo property)
public object GetMemberValue(MemberInfo member, object target)
public void SetMemberValue(MemberInfo member, object target, object value)
public bool CanReadMemberValue(MemberInfo member, bool nonPublic)
public bool CanSetMemberValue(MemberInfo member, bool nonPublic, bool canSetReadOnly)
public List`1<MemberInfo> GetFieldsAndProperties(Type type, BindingFlags bindingAttr)
private bool IsOverridenGenericMember(MemberInfo memberInfo, BindingFlags bindingAttr)
public T GetAttribute(object attributeProvider)
public T GetAttribute(object attributeProvider, bool inherit)
public T[] GetAttributes(object attributeProvider, bool inherit)
public Attribute[] GetAttributes(object attributeProvider, Type attributeType, bool inherit)
public void SplitFullyQualifiedTypeName(string fullyQualifiedTypeName, String& typeName, String& assemblyName)
private Nullable`1<int> GetAssemblyDelimiterIndex(string fullyQualifiedTypeName)
public MemberInfo GetMemberInfoFromType(Type targetType, MemberInfo memberInfo)
public IEnumerable`1<FieldInfo> GetFields(Type targetType, BindingFlags bindingAttr)
private void GetChildPrivateFields(IList`1<MemberInfo> initialFields, Type targetType, BindingFlags bindingAttr)
public IEnumerable`1<PropertyInfo> GetProperties(Type targetType, BindingFlags bindingAttr)
public BindingFlags RemoveFlag(BindingFlags bindingAttr, BindingFlags flag)
private void GetChildPrivateProperties(IList`1<PropertyInfo> initialProperties, Type targetType, BindingFlags bindingAttr)
public bool IsMethodOverridden(Type currentType, Type methodDeclaringType, string method)
public object GetDefaultValue(Type type)
}
internal Newtonsoft.Json.Utilities.StringBuffer : ValueType {
private Char[] _buffer
private int _position
public int Position
public bool IsEmpty
public Char[] InternalBuffer
public int get_Position()
public void set_Position(int value)
public bool get_IsEmpty()
public void .ctor(IArrayPool`1<char> bufferPool, int initalSize)
private void .ctor(Char[] buffer)
public void Append(IArrayPool`1<char> bufferPool, char value)
public void Append(IArrayPool`1<char> bufferPool, Char[] buffer, int startIndex, int count)
public void Clear(IArrayPool`1<char> bufferPool)
private void EnsureSize(IArrayPool`1<char> bufferPool, int appendLength)
public string ToString()
public string ToString(int start, int length)
public Char[] get_InternalBuffer()
}
internal Newtonsoft.Json.Utilities.StringReference : ValueType {
private Char[] _chars
private int _startIndex
private int _length
public char Item
public Char[] Chars
public int StartIndex
public int Length
public char get_Item(int i)
public Char[] get_Chars()
public int get_StartIndex()
public int get_Length()
public void .ctor(Char[] chars, int startIndex, int length)
public string ToString()
}
internal Newtonsoft.Json.Utilities.StringReferenceExtensions : object {
public int IndexOf(StringReference s, char c, int startIndex, int length)
public bool StartsWith(StringReference s, string text)
public bool EndsWith(StringReference s, string text)
}
internal Newtonsoft.Json.Utilities.StringUtils : object {
public string CarriageReturnLineFeed
public string Empty
public char CarriageReturn
public char LineFeed
public char Tab
public string FormatWith(string format, IFormatProvider provider, object arg0)
public string FormatWith(string format, IFormatProvider provider, object arg0, object arg1)
public string FormatWith(string format, IFormatProvider provider, object arg0, object arg1, object arg2)
public string FormatWith(string format, IFormatProvider provider, object arg0, object arg1, object arg2, object arg3)
private string FormatWith(string format, IFormatProvider provider, Object[] args)
public bool IsWhiteSpace(string s)
public string NullEmptyString(string s)
public StringWriter CreateStringWriter(int capacity)
public Nullable`1<int> GetLength(string value)
public void ToCharAsUnicode(char c, Char[] buffer)
public TSource ForgivingCaseSensitiveFind(IEnumerable`1<TSource> source, Func`2<TSource, string> valueSelector, string testValue)
public string ToCamelCase(string s)
public bool IsHighSurrogate(char c)
public bool IsLowSurrogate(char c)
public bool StartsWith(string source, char value)
public bool EndsWith(string source, char value)
}
internal Newtonsoft.Json.Utilities.ThreadSafeStore`2 : object {
private object _lock
private Dictionary`2<TKey, TValue> _store
private Func`2<TKey, TValue> _creator
public void .ctor(Func`2<TKey, TValue> creator)
public TValue Get(TKey key)
private TValue AddValue(TKey key)
}
internal Newtonsoft.Json.Utilities.TypeExtensions : object {
public MethodInfo Method(Delegate d)
public MemberTypes MemberType(MemberInfo memberInfo)
public bool ContainsGenericParameters(Type type)
public bool IsInterface(Type type)
public bool IsGenericType(Type type)
public bool IsGenericTypeDefinition(Type type)
public Type BaseType(Type type)
public Assembly Assembly(Type type)
public bool IsEnum(Type type)
public bool IsClass(Type type)
public bool IsSealed(Type type)
public bool IsAbstract(Type type)
public bool IsVisible(Type type)
public bool IsValueType(Type type)
public bool AssignableToTypeName(Type type, string fullTypeName, Type& match)
public bool AssignableToTypeName(Type type, string fullTypeName)
public bool ImplementInterface(Type type, Type interfaceType)
}
internal Newtonsoft.Json.Utilities.TypeInformation : object {
private Type <Type>k__BackingField
private PrimitiveTypeCode <TypeCode>k__BackingField
public Type Type
public PrimitiveTypeCode TypeCode
public Type get_Type()
public void set_Type(Type value)
public PrimitiveTypeCode get_TypeCode()
public void set_TypeCode(PrimitiveTypeCode value)
}
internal Newtonsoft.Json.Utilities.ValidationUtils : object {
public void ArgumentNotNull(object value, string parameterName)
}
public Newtonsoft.Json.WriteState : Enum {
public int value__
public WriteState Error
public WriteState Closed
public WriteState Object
public WriteState Array
public WriteState Constructor
public WriteState Property
public WriteState Start
}
public System.ComponentModel.AddingNewEventArgs : object {
private object <NewObject>k__BackingField
public object NewObject
public object get_NewObject()
public void set_NewObject(object value)
public void .ctor(object newObject)
}
public System.ComponentModel.AddingNewEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, AddingNewEventArgs e)
public IAsyncResult BeginInvoke(object sender, AddingNewEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.ComponentModel.INotifyCollectionChanged {
public void add_CollectionChanged(NotifyCollectionChangedEventHandler value)
public void remove_CollectionChanged(NotifyCollectionChangedEventHandler value)
}
public System.ComponentModel.INotifyPropertyChanging {
public void add_PropertyChanging(PropertyChangingEventHandler value)
public void remove_PropertyChanging(PropertyChangingEventHandler value)
}
public System.ComponentModel.NotifyCollectionChangedAction : Enum {
public int value__
public NotifyCollectionChangedAction Add
public NotifyCollectionChangedAction Remove
public NotifyCollectionChangedAction Replace
public NotifyCollectionChangedAction Move
public NotifyCollectionChangedAction Reset
}
public System.ComponentModel.NotifyCollectionChangedEventArgs : object {
private NotifyCollectionChangedAction <Action>k__BackingField
private IList <NewItems>k__BackingField
private int <NewStartingIndex>k__BackingField
private IList <OldItems>k__BackingField
private int <OldStartingIndex>k__BackingField
internal NotifyCollectionChangedAction Action
internal IList NewItems
internal int NewStartingIndex
internal IList OldItems
internal int OldStartingIndex
internal NotifyCollectionChangedAction get_Action()
internal void set_Action(NotifyCollectionChangedAction value)
internal IList get_NewItems()
internal void set_NewItems(IList value)
internal int get_NewStartingIndex()
internal void set_NewStartingIndex(int value)
internal IList get_OldItems()
internal void set_OldItems(IList value)
internal int get_OldStartingIndex()
internal void set_OldStartingIndex(int value)
internal void .ctor(NotifyCollectionChangedAction action)
internal void .ctor(NotifyCollectionChangedAction action, IList changedItems)
internal void .ctor(NotifyCollectionChangedAction action, object changedItem)
internal void .ctor(NotifyCollectionChangedAction action, IList newItems, IList oldItems)
internal void .ctor(NotifyCollectionChangedAction action, IList changedItems, int startingIndex)
internal void .ctor(NotifyCollectionChangedAction action, object changedItem, int index)
internal void .ctor(NotifyCollectionChangedAction action, object newItem, object oldItem)
internal void .ctor(NotifyCollectionChangedAction action, IList newItems, IList oldItems, int startingIndex)
internal void .ctor(NotifyCollectionChangedAction action, IList changedItems, int index, int oldIndex)
internal void .ctor(NotifyCollectionChangedAction action, object changedItem, int index, int oldIndex)
internal void .ctor(NotifyCollectionChangedAction action, object newItem, object oldItem, int index)
}
public System.ComponentModel.NotifyCollectionChangedEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, NotifyCollectionChangedEventArgs e)
public IAsyncResult BeginInvoke(object sender, NotifyCollectionChangedEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.ComponentModel.PropertyChangingEventArgs : EventArgs {
private string <PropertyName>k__BackingField
public string PropertyName
public void .ctor(string propertyName)
public string get_PropertyName()
public void set_PropertyName(string value)
}
public System.ComponentModel.PropertyChangingEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, PropertyChangingEventArgs e)
public IAsyncResult BeginInvoke(object sender, PropertyChangingEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
