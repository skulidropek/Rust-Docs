internal System.Collections.Concurrent.PaddingHelpers : object {
internal int CACHE_LINE_SIZE
}
internal System.Collections.Concurrent.SingleProducerSingleConsumerQueue`1 : object {
private int InitialSegmentSize
private int MaxSegmentSize
private Segment modreq(System.Runtime.CompilerServices.IsVolatile) _head
private Segment modreq(System.Runtime.CompilerServices.IsVolatile) _tail
public bool IsEmpty
internal int Count
public void Enqueue(T item)
private void EnqueueSlow(T item, Segment& segment)
public bool TryDequeue(T& result)
private bool TryDequeueSlow(Segment& segment, T[]& array, T& result)
public bool get_IsEmpty()
public IEnumerator`1<T> GetEnumerator()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
internal int get_Count()
}
internal System.Collections.Generic.Dequeue`1 : object {
private T[] _array
private int _head
private int _tail
private int _size
public int Count
public bool IsEmpty
public int get_Count()
public bool get_IsEmpty()
public void EnqueueTail(T item)
public T DequeueHead()
public T DequeueTail()
public IEnumerator`1<T> GetEnumerator()
private void Grow()
}
internal System.SR : object {
private ResourceManager s_resourceManager
private Type <ResourceType>k__BackingField
private ResourceManager ResourceManager
internal Type ResourceType
internal string ChannelClosedException_DefaultMessage
internal string InvalidOperation_IncompleteAsyncOperation
internal string InvalidOperation_MultipleContinuations
internal string InvalidOperation_IncorrectToken
private ResourceManager get_ResourceManager()
private bool UsingResourceKeys()
internal string GetResourceString(string resourceKey, string defaultString)
internal string Format(string resourceFormat, Object[] args)
internal string Format(string resourceFormat, object p1)
internal string Format(string resourceFormat, object p1, object p2)
internal string Format(string resourceFormat, object p1, object p2, object p3)
internal Type get_ResourceType()
internal string get_ChannelClosedException_DefaultMessage()
internal string get_InvalidOperation_IncompleteAsyncOperation()
internal string get_InvalidOperation_MultipleContinuations()
internal string get_InvalidOperation_IncorrectToken()
}
internal System.Threading.Channels.AsyncOperation : object {
protected Action`1<object> s_availableSentinel
protected Action`1<object> s_completedSentinel
protected void ThrowIncompleteOperationException()
protected void ThrowMultipleContinuations()
protected void ThrowIncorrectCurrentIdException()
}
internal System.Threading.Channels.AsyncOperation`1 : AsyncOperation {
private CancellationTokenRegistration _registration
private bool _pooled
private bool _runContinuationsAsynchronously
private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) _completionReserved
private TResult _result
private ExceptionDispatchInfo _error
private Action`1<object> _continuation
private object _continuationState
private object _schedulingContext
private ExecutionContext _executionContext
private short _currentId
private AsyncOperation`1<TResult> <Next>k__BackingField
private CancellationToken <CancellationToken>k__BackingField
public AsyncOperation`1<TResult> Next
public CancellationToken CancellationToken
public ValueTask ValueTask
public ValueTask`1<TResult> ValueTaskOfT
internal bool IsCompleted
public void .ctor(bool runContinuationsAsynchronously, CancellationToken cancellationToken, bool pooled)
public AsyncOperation`1<TResult> get_Next()
public void set_Next(AsyncOperation`1<TResult> value)
public CancellationToken get_CancellationToken()
public ValueTask get_ValueTask()
public ValueTask`1<TResult> get_ValueTaskOfT()
public ValueTaskSourceStatus GetStatus(short token)
internal bool get_IsCompleted()
public TResult GetResult(short token)
private void System.Threading.Tasks.Sources.IValueTaskSource.GetResult(short token)
public bool TryOwnAndReset()
public void OnCompleted(Action`1<object> continuation, object state, short token, ValueTaskSourceOnCompletedFlags flags)
public void UnregisterCancellation()
public bool TrySetResult(TResult item)
public bool TrySetException(Exception exception)
public bool TrySetCanceled(CancellationToken cancellationToken)
private bool TryReserveCompletionIfCancelable()
private void SignalCompletion()
private void SignalCompletionCore()
private void SetCompletionAndInvokeContinuation()
}
internal System.Threading.Channels.BoundedChannel`1 : Channel`1<T> {
private BoundedChannelFullMode _mode
private TaskCompletionSource`1<VoidResult> _completion
private int _bufferedCapacity
private Dequeue`1<T> _items
private Dequeue`1<AsyncOperation`1<T>> _blockedReaders
private Dequeue`1<VoidAsyncOperationWithData`1<T>> _blockedWriters
private AsyncOperation`1<bool> _waitingReadersTail
private AsyncOperation`1<bool> _waitingWritersTail
private bool _runContinuationsAsynchronously
private Exception _doneWriting
private object SyncObj
private int ItemsCountForDebugger
private bool ChannelIsClosedForDebugger
private object get_SyncObj()
internal void .ctor(int bufferedCapacity, BoundedChannelFullMode mode, bool runContinuationsAsynchronously)
private void AssertInvariants()
private int get_ItemsCountForDebugger()
private bool get_ChannelIsClosedForDebugger()
private IEnumerator`1<T> System.Threading.Channels.IDebugEnumerable<T>.GetEnumerator()
}
public System.Threading.Channels.BoundedChannelFullMode : Enum {
public int value__
public BoundedChannelFullMode Wait
public BoundedChannelFullMode DropNewest
public BoundedChannelFullMode DropOldest
public BoundedChannelFullMode DropWrite
}
public System.Threading.Channels.BoundedChannelOptions : ChannelOptions {
private int _capacity
private BoundedChannelFullMode _mode
public int Capacity
public BoundedChannelFullMode FullMode
public void .ctor(int capacity)
public int get_Capacity()
public void set_Capacity(int value)
public BoundedChannelFullMode get_FullMode()
public void set_FullMode(BoundedChannelFullMode value)
}
public System.Threading.Channels.Channel : object {
public Channel`1<T> CreateUnbounded()
public Channel`1<T> CreateUnbounded(UnboundedChannelOptions options)
public Channel`1<T> CreateBounded(int capacity)
public Channel`1<T> CreateBounded(BoundedChannelOptions options)
}
public System.Threading.Channels.Channel`2 : object {
private ChannelReader`1<TRead> <Reader>k__BackingField
private ChannelWriter`1<TWrite> <Writer>k__BackingField
public ChannelReader`1<TRead> Reader
public ChannelWriter`1<TWrite> Writer
public ChannelReader`1<TRead> get_Reader()
protected void set_Reader(ChannelReader`1<TRead> value)
public ChannelWriter`1<TWrite> get_Writer()
protected void set_Writer(ChannelWriter`1<TWrite> value)
public ChannelReader`1<TRead> op_Implicit(Channel`2<TWrite, TRead> channel)
public ChannelWriter`1<TWrite> op_Implicit(Channel`2<TWrite, TRead> channel)
}
public System.Threading.Channels.ChannelClosedException : InvalidOperationException {
public void .ctor(string message)
public void .ctor(Exception innerException)
public void .ctor(string message, Exception innerException)
}
public System.Threading.Channels.ChannelOptions : object {
private bool <SingleWriter>k__BackingField
private bool <SingleReader>k__BackingField
private bool <AllowSynchronousContinuations>k__BackingField
public bool SingleWriter
public bool SingleReader
public bool AllowSynchronousContinuations
public bool get_SingleWriter()
public void set_SingleWriter(bool value)
public bool get_SingleReader()
public void set_SingleReader(bool value)
public bool get_AllowSynchronousContinuations()
public void set_AllowSynchronousContinuations(bool value)
}
public System.Threading.Channels.ChannelReader`1 : object {
public Task Completion
public Task get_Completion()
public bool TryRead(T& item)
public ValueTask`1<bool> WaitToReadAsync(CancellationToken cancellationToken)
public ValueTask`1<T> ReadAsync(CancellationToken cancellationToken)
private ValueTask`1<T> <ReadAsync>g__ReadAsyncCore|4_0(CancellationToken ct)
}
internal System.Threading.Channels.ChannelUtilities : object {
internal Exception s_doneWritingSentinel
internal Task`1<bool> s_trueTask
internal Task`1<bool> s_falseTask
internal Task s_neverCompletingTask
internal void Complete(TaskCompletionSource`1<VoidResult> tcs, Exception error)
internal ValueTask`1<T> GetInvalidCompletionValueTask(Exception error)
internal ValueTask`1<bool> QueueWaiter(AsyncOperation`1& tail, AsyncOperation`1<bool> waiter)
internal void WakeUpWaiters(AsyncOperation`1& listTail, bool result, Exception error)
internal void FailOperations(Dequeue`1<T> operations, Exception error)
internal Exception CreateInvalidCompletionException(Exception inner)
}
public System.Threading.Channels.ChannelWriter`1 : object {
public bool TryComplete(Exception error)
public bool TryWrite(T item)
public ValueTask`1<bool> WaitToWriteAsync(CancellationToken cancellationToken)
public ValueTask WriteAsync(T item, CancellationToken cancellationToken)
private Task WriteAsyncCore(T innerItem, CancellationToken ct)
public void Complete(Exception error)
}
internal System.Threading.Channels.DebugEnumeratorDebugView`1 : object {
private T[] <Items>k__BackingField
public T[] Items
public void .ctor(IDebugEnumerable`1<T> enumerable)
public T[] get_Items()
}
internal System.Threading.Channels.IDebugEnumerable`1 {
public IEnumerator`1<T> GetEnumerator()
}
internal System.Threading.Channels.SingleConsumerUnboundedChannel`1 : Channel`1<T> {
private TaskCompletionSource`1<VoidResult> _completion
private SingleProducerSingleConsumerQueue`1<T> _items
private bool _runContinuationsAsynchronously
private Exception modreq(System.Runtime.CompilerServices.IsVolatile) _doneWriting
private AsyncOperation`1<T> _blockedReader
private AsyncOperation`1<bool> _waitingReader
private object SyncObj
private int ItemsCountForDebugger
private bool ChannelIsClosedForDebugger
internal void .ctor(bool runContinuationsAsynchronously)
private object get_SyncObj()
private int get_ItemsCountForDebugger()
private bool get_ChannelIsClosedForDebugger()
private IEnumerator`1<T> System.Threading.Channels.IDebugEnumerable<T>.GetEnumerator()
}
internal System.Threading.Channels.UnboundedChannel`1 : Channel`1<T> {
private TaskCompletionSource`1<VoidResult> _completion
private ConcurrentQueue`1<T> _items
private Dequeue`1<AsyncOperation`1<T>> _blockedReaders
private bool _runContinuationsAsynchronously
private AsyncOperation`1<bool> _waitingReadersTail
private Exception _doneWriting
private object SyncObj
private int ItemsCountForDebugger
private bool ChannelIsClosedForDebugger
internal void .ctor(bool runContinuationsAsynchronously)
private object get_SyncObj()
private void AssertInvariants()
private int get_ItemsCountForDebugger()
private bool get_ChannelIsClosedForDebugger()
private IEnumerator`1<T> System.Threading.Channels.IDebugEnumerable<T>.GetEnumerator()
}
internal System.Threading.Channels.VoidAsyncOperationWithData`1 : AsyncOperation`1<VoidResult> {
private TData <Item>k__BackingField
public TData Item
public void .ctor(bool runContinuationsAsynchronously, CancellationToken cancellationToken, bool pooled)
public TData get_Item()
public void set_Item(TData value)
}
