internal System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute : Attribute {
private bool <ParameterValue>k__BackingField
public bool ParameterValue
public void .ctor(bool parameterValue)
public bool get_ParameterValue()
}
internal System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute : Attribute {
private bool <ReturnValue>k__BackingField
public bool ReturnValue
public void .ctor(bool returnValue)
public bool get_ReturnValue()
}
internal System.Diagnostics.CodeAnalysis.MemberNotNullAttribute : Attribute {
private String[] <Members>k__BackingField
public String[] Members
public void .ctor(string member)
public void .ctor(String[] members)
public String[] get_Members()
}
internal System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute : Attribute {
private bool <ReturnValue>k__BackingField
private String[] <Members>k__BackingField
public bool ReturnValue
public String[] Members
public void .ctor(bool returnValue, string member)
public void .ctor(bool returnValue, String[] members)
public bool get_ReturnValue()
public String[] get_Members()
}
internal System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute : Attribute {
private string <ParameterName>k__BackingField
public string ParameterName
public void .ctor(string parameterName)
public string get_ParameterName()
}
internal System.Diagnostics.CodeAnalysis.NotNullWhenAttribute : Attribute {
private bool <ReturnValue>k__BackingField
public bool ReturnValue
public void .ctor(bool returnValue)
public bool get_ReturnValue()
}
public System.IO.Hashing.Crc32 : NonCryptographicHashAlgorithm {
private UInt32 InitialState
private int Size
private UInt32 _crc
private UInt32[] s_crcLookup
public void Append(ReadOnlySpan`1<byte> source)
public void Reset()
protected void GetCurrentHashCore(Span`1<byte> destination)
protected void GetHashAndResetCore(Span`1<byte> destination)
public Byte[] Hash(Byte[] source)
public Byte[] Hash(ReadOnlySpan`1<byte> source)
public bool TryHash(ReadOnlySpan`1<byte> source, Span`1<byte> destination, Int32& bytesWritten)
public int Hash(ReadOnlySpan`1<byte> source, Span`1<byte> destination)
private int StaticHash(ReadOnlySpan`1<byte> source, Span`1<byte> destination)
private UInt32 Update(UInt32 crc, ReadOnlySpan`1<byte> source)
private UInt32[] GenerateReflectedTable(UInt32 reflectedPolynomial)
}
public System.IO.Hashing.Crc64 : NonCryptographicHashAlgorithm {
private ulong InitialState
private int Size
private ulong _crc
private UInt64[] s_crcLookup
public void Append(ReadOnlySpan`1<byte> source)
public void Reset()
protected void GetCurrentHashCore(Span`1<byte> destination)
protected void GetHashAndResetCore(Span`1<byte> destination)
public Byte[] Hash(Byte[] source)
public Byte[] Hash(ReadOnlySpan`1<byte> source)
public bool TryHash(ReadOnlySpan`1<byte> source, Span`1<byte> destination, Int32& bytesWritten)
public int Hash(ReadOnlySpan`1<byte> source, Span`1<byte> destination)
private int StaticHash(ReadOnlySpan`1<byte> source, Span`1<byte> destination)
private ulong Update(ulong crc, ReadOnlySpan`1<byte> source)
private UInt64[] GenerateTable(ulong polynomial)
}
public System.IO.Hashing.NonCryptographicHashAlgorithm : object {
private int <HashLengthInBytes>k__BackingField
public int HashLengthInBytes
public int get_HashLengthInBytes()
protected void .ctor(int hashLengthInBytes)
public void Append(ReadOnlySpan`1<byte> source)
public void Reset()
protected void GetCurrentHashCore(Span`1<byte> destination)
public void Append(Byte[] source)
public void Append(Stream stream)
public Task AppendAsync(Stream stream, CancellationToken cancellationToken)
private Task AppendAsyncCore(Stream stream, CancellationToken cancellationToken)
public Byte[] GetCurrentHash()
public bool TryGetCurrentHash(Span`1<byte> destination, Int32& bytesWritten)
public int GetCurrentHash(Span`1<byte> destination)
public Byte[] GetHashAndReset()
public bool TryGetHashAndReset(Span`1<byte> destination, Int32& bytesWritten)
public int GetHashAndReset(Span`1<byte> destination)
protected void GetHashAndResetCore(Span`1<byte> destination)
public int GetHashCode()
}
public System.IO.Hashing.XxHash32 : NonCryptographicHashAlgorithm {
private int HashSize
private int StripeSize
private UInt32 _seed
private State _state
private Byte[] _holdback
private int _length
public void .ctor(int seed)
public void Reset()
public void Append(ReadOnlySpan`1<byte> source)
protected void GetCurrentHashCore(Span`1<byte> destination)
public Byte[] Hash(Byte[] source)
public Byte[] Hash(Byte[] source, int seed)
public Byte[] Hash(ReadOnlySpan`1<byte> source, int seed)
public bool TryHash(ReadOnlySpan`1<byte> source, Span`1<byte> destination, Int32& bytesWritten, int seed)
public int Hash(ReadOnlySpan`1<byte> source, Span`1<byte> destination, int seed)
private int StaticHash(ReadOnlySpan`1<byte> source, Span`1<byte> destination, int seed)
}
public System.IO.Hashing.XxHash64 : NonCryptographicHashAlgorithm {
private int HashSize
private int StripeSize
private ulong _seed
private State _state
private Byte[] _holdback
private int _length
public void .ctor(long seed)
public void Reset()
public void Append(ReadOnlySpan`1<byte> source)
protected void GetCurrentHashCore(Span`1<byte> destination)
public Byte[] Hash(Byte[] source)
public Byte[] Hash(Byte[] source, long seed)
public Byte[] Hash(ReadOnlySpan`1<byte> source, long seed)
public bool TryHash(ReadOnlySpan`1<byte> source, Span`1<byte> destination, Int32& bytesWritten, long seed)
public int Hash(ReadOnlySpan`1<byte> source, Span`1<byte> destination, long seed)
private int StaticHash(ReadOnlySpan`1<byte> source, Span`1<byte> destination, long seed)
}
internal System.Numerics.BitOperations : object {
public UInt32 RotateLeft(UInt32 value, int offset)
public ulong RotateLeft(ulong value, int offset)
}
internal System.Runtime.CompilerServices.NullableAttribute : Attribute {
public Byte[] NullableFlags
public void .ctor(byte )
public void .ctor(Byte[] )
}
internal System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
public byte Flag
public void .ctor(byte )
}
internal System.Runtime.CompilerServices.NullablePublicOnlyAttribute : Attribute {
public bool IncludesInternals
public void .ctor(bool )
}
internal System.SR : object {
private bool s_usingResourceKeys
private ResourceManager s_resourceManager
internal ResourceManager ResourceManager
internal string Argument_DestinationTooShort
internal string NotSupported_GetHashCode
private bool UsingResourceKeys()
internal string GetResourceString(string resourceKey)
internal string GetResourceString(string resourceKey, string defaultString)
internal string Format(string resourceFormat, object p1)
internal string Format(string resourceFormat, object p1, object p2)
internal string Format(string resourceFormat, object p1, object p2, object p3)
internal string Format(string resourceFormat, Object[] args)
internal string Format(IFormatProvider provider, string resourceFormat, object p1)
internal string Format(IFormatProvider provider, string resourceFormat, object p1, object p2)
internal string Format(IFormatProvider provider, string resourceFormat, object p1, object p2, object p3)
internal string Format(IFormatProvider provider, string resourceFormat, Object[] args)
internal ResourceManager get_ResourceManager()
internal string get_Argument_DestinationTooShort()
internal string get_NotSupported_GetHashCode()
}
