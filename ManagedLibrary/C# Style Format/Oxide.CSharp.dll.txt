public ObjectStream.ConnectionExceptionEventHandler`2 : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(ObjectStreamConnection`2<TRead, TWrite> connection, Exception exception)
public IAsyncResult BeginInvoke(ObjectStreamConnection`2<TRead, TWrite> connection, Exception exception, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
internal ObjectStream.ConnectionFactory : object {
public ObjectStreamConnection`2<TRead, TWrite> CreateConnection(Stream inStream, Stream outStream)
}
public ObjectStream.ConnectionMessageEventHandler`2 : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(ObjectStreamConnection`2<TRead, TWrite> connection, TRead message)
public IAsyncResult BeginInvoke(ObjectStreamConnection`2<TRead, TWrite> connection, TRead message, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public ObjectStream.Data.CompilationResult : object {
private string <Name>k__BackingField
private Byte[] <Data>k__BackingField
private Byte[] <Symbols>k__BackingField
public string Name
public Byte[] Data
public Byte[] Symbols
public string get_Name()
public void set_Name(string value)
public Byte[] get_Data()
public void set_Data(Byte[] value)
public Byte[] get_Symbols()
public void set_Symbols(Byte[] value)
}
public ObjectStream.Data.CompilerData : object {
private bool <LoadDefaultReferences>k__BackingField
private string <OutputFile>k__BackingField
private CompilerPlatform <Platform>k__BackingField
private CompilerFile[] <ReferenceFiles>k__BackingField
private string <SdkVersion>k__BackingField
private CompilerFile[] <SourceFiles>k__BackingField
private bool <StdLib>k__BackingField
private CompilerTarget <Target>k__BackingField
private CompilerLanguageVersion <Version>k__BackingField
private string <Encoding>k__BackingField
private bool <Debug>k__BackingField
private String[] <Preprocessor>k__BackingField
public bool LoadDefaultReferences
public string OutputFile
public CompilerPlatform Platform
public CompilerFile[] ReferenceFiles
public string SdkVersion
public CompilerFile[] SourceFiles
public bool StdLib
public CompilerTarget Target
public CompilerLanguageVersion Version
public string Encoding
public bool Debug
public String[] Preprocessor
public bool get_LoadDefaultReferences()
public void set_LoadDefaultReferences(bool value)
public string get_OutputFile()
public void set_OutputFile(string value)
public CompilerPlatform get_Platform()
public void set_Platform(CompilerPlatform value)
public CompilerFile[] get_ReferenceFiles()
public void set_ReferenceFiles(CompilerFile[] value)
public string get_SdkVersion()
public void set_SdkVersion(string value)
public CompilerFile[] get_SourceFiles()
public void set_SourceFiles(CompilerFile[] value)
public bool get_StdLib()
public void set_StdLib(bool value)
public CompilerTarget get_Target()
public void set_Target(CompilerTarget value)
public CompilerLanguageVersion get_Version()
public void set_Version(CompilerLanguageVersion value)
public string get_Encoding()
public void set_Encoding(string value)
public bool get_Debug()
public void set_Debug(bool value)
public String[] get_Preprocessor()
public void set_Preprocessor(String[] value)
}
public ObjectStream.Data.CompilerFile : object {
internal Dictionary`2<string, CompilerFile> FileCache
private string <Name>k__BackingField
private Byte[] <Data>k__BackingField
internal DateTime LastRead
internal bool KeepCached
public string Name
public Byte[] Data
public CompilerFile CachedReadFile(string directory, string fileName, Byte[] data)
public string get_Name()
public void set_Name(string value)
public Byte[] get_Data()
public void set_Data(Byte[] value)
internal void .ctor(string name, Byte[] data)
internal void .ctor(string directory, string name)
internal void .ctor(string path)
}
public ObjectStream.Data.CompilerLanguageVersion : Enum {
public int value__
public CompilerLanguageVersion Latest
public CompilerLanguageVersion V16
public CompilerLanguageVersion V15
public CompilerLanguageVersion V14
public CompilerLanguageVersion V13
public CompilerLanguageVersion V12
public CompilerLanguageVersion V11
public CompilerLanguageVersion V10
public CompilerLanguageVersion V9
public CompilerLanguageVersion V8
public CompilerLanguageVersion V7
public CompilerLanguageVersion V6
public CompilerLanguageVersion V5
public CompilerLanguageVersion V4
public CompilerLanguageVersion V3
public CompilerLanguageVersion V2
public CompilerLanguageVersion V1
public CompilerLanguageVersion Preview
}
public ObjectStream.Data.CompilerMessage : object {
private object <Data>k__BackingField
private object <ExtraData>k__BackingField
private int <Id>k__BackingField
private CompilerMessageType <Type>k__BackingField
public object Data
public object ExtraData
public int Id
public CompilerMessageType Type
public object get_Data()
public void set_Data(object value)
public object get_ExtraData()
public void set_ExtraData(object value)
public int get_Id()
public void set_Id(int value)
public CompilerMessageType get_Type()
public void set_Type(CompilerMessageType value)
}
public ObjectStream.Data.CompilerMessageType : Enum {
public int value__
public CompilerMessageType Assembly
public CompilerMessageType Compile
public CompilerMessageType Error
public CompilerMessageType Exit
public CompilerMessageType Ready
}
public ObjectStream.Data.CompilerPlatform : Enum {
public int value__
public CompilerPlatform AnyCPU
public CompilerPlatform AnyCPU32Preferred
public CompilerPlatform Arm
public CompilerPlatform X86
public CompilerPlatform X64
public CompilerPlatform IA64
}
public ObjectStream.Data.CompilerTarget : Enum {
public int value__
public CompilerTarget Library
public CompilerTarget Exe
public CompilerTarget Module
public CompilerTarget WinExe
}
public ObjectStream.IO.BindChanger : SerializationBinder {
public Type BindToType(string assemblyName, string typeName)
}
public ObjectStream.IO.ObjectStreamWrapper`1 : ObjectStreamWrapper`2<TReadWrite, TReadWrite> {
public void .ctor(Stream inStream, Stream outStream)
}
public ObjectStream.IO.ObjectStreamWrapper`2 : object {
private BinaryFormatter _binaryFormatter
private Stream _inStream
private Stream _outStream
private bool _run
public bool CanRead
public bool CanWrite
public void .ctor(Stream inStream, Stream outStream)
public bool get_CanRead()
public bool get_CanWrite()
public void Close()
public TRead ReadObject()
private int ReadLength()
private TRead ReadObject(int len)
public void WriteObject(TWrite obj)
private Byte[] Serialize(TWrite obj)
private void WriteLength(int len)
private void WriteObject(Byte[] data)
private void Flush()
}
public ObjectStream.ObjectStreamClient`1 : ObjectStreamClient`2<TReadWrite, TReadWrite> {
public void .ctor(Stream inStream, Stream outStream)
}
public ObjectStream.ObjectStreamClient`2 : object {
private Stream _inStream
private Stream _outStream
private ObjectStreamConnection`2<TRead, TWrite> _connection
private ConnectionMessageEventHandler`2<TRead, TWrite> Message
private StreamExceptionEventHandler Error
public void .ctor(Stream inStream, Stream outStream)
public void add_Message(ConnectionMessageEventHandler`2<TRead, TWrite> value)
public void remove_Message(ConnectionMessageEventHandler`2<TRead, TWrite> value)
public void add_Error(StreamExceptionEventHandler value)
public void remove_Error(StreamExceptionEventHandler value)
public void Start()
public void PushMessage(TWrite message)
public void Stop()
private void ListenSync()
private void OnReceiveMessage(ObjectStreamConnection`2<TRead, TWrite> connection, TRead message)
private void ConnectionOnError(ObjectStreamConnection`2<TRead, TWrite> connection, Exception exception)
private void OnError(Exception exception)
}
internal ObjectStream.ObjectStreamClientFactory : object {
public ObjectStreamWrapper`2<TRead, TWrite> Connect(Stream inStream, Stream outStream)
}
public ObjectStream.ObjectStreamConnection`2 : object {
private ObjectStreamWrapper`2<TRead, TWrite> _streamWrapper
private Queue`1<TWrite> _writeQueue
private AutoResetEvent _writeSignal
private ConnectionMessageEventHandler`2<TRead, TWrite> ReceiveMessage
private ConnectionExceptionEventHandler`2<TRead, TWrite> Error
internal void .ctor(Stream inStream, Stream outStream)
public void add_ReceiveMessage(ConnectionMessageEventHandler`2<TRead, TWrite> value)
public void remove_ReceiveMessage(ConnectionMessageEventHandler`2<TRead, TWrite> value)
public void add_Error(ConnectionExceptionEventHandler`2<TRead, TWrite> value)
public void remove_Error(ConnectionExceptionEventHandler`2<TRead, TWrite> value)
public void Open()
public void PushMessage(TWrite message)
public void Close()
private void CloseImpl()
private void OnError(Exception exception)
private void ReadStream()
private void WriteStream()
}
public ObjectStream.StreamExceptionEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(Exception exception)
public IAsyncResult BeginInvoke(Exception exception, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
internal ObjectStream.Threading.Worker : object {
private WorkerExceptionEventHandler Error
public void add_Error(WorkerExceptionEventHandler value)
public void remove_Error(WorkerExceptionEventHandler value)
public void DoWork(Action action)
private void DoWorkImpl(object oAction)
private void Fail(Exception exception)
private void Callback(Action action)
}
internal ObjectStream.Threading.WorkerExceptionEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(Exception exception)
public IAsyncResult BeginInvoke(Exception exception, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
internal ObjectStream.Threading.WorkerSucceededEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke()
public IAsyncResult BeginInvoke(AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public Oxide.Core.CSharp.DirectCallMethod : object {
private ModuleDefinition module
private TypeDefinition type
private MethodDefinition method
private MethodBody body
private Instruction endInstruction
private Dictionary`2<Instruction, Node> jumpToEdgePlaceholderTargets
private List`1<Instruction> jumpToEndPlaceholders
private Dictionary`2<string, MethodDefinition> hookMethods
private MethodReference getLength
private MethodReference getChars
private MethodReference isNullOrEmpty
private MethodReference stringEquals
private string hook_attribute
public void .ctor(ModuleDefinition module, TypeDefinition type, ReaderParameters readerParameters)
private bool IsHookMethod(MethodDefinition method)
private void BuildNode(Node node, int edge_number)
private void CallMethod(MethodDefinition method)
private Instruction Return(bool value)
private void JumpToEdge(Node node)
private void JumpToEnd()
private Instruction AddInstruction(OpCode opcode)
private Instruction AddInstruction(OpCode opcode, Instruction instruction)
private Instruction AddInstruction(OpCode opcode, MethodReference method_reference)
private Instruction AddInstruction(OpCode opcode, TypeReference type_reference)
private Instruction AddInstruction(OpCode opcode, int value)
private Instruction AddInstruction(OpCode opcode, VariableDefinition value)
private Instruction AddInstruction(Instruction instruction)
public VariableDefinition AddVariable(TypeReference typeRef, string name)
private Instruction Ldc_I4_n(int n)
}
internal Oxide.CSharp.AssemblyResolver : DefaultAssemblyResolver {
internal AssemblyDefinition mscorlib
public AssemblyDefinition Resolve(AssemblyNameReference name, ReaderParameters parameters)
}
internal Oxide.CSharp.CompilerService : object {
private Regex SymbolEscapeRegex
private string baseUrl
private Hash`2<int, Compilation> compilations
private Queue`1<CompilerMessage> messageQueue
private Process process
private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) lastId
private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) ready
private TimerInstance idleTimer
private ObjectStreamClient`1<CompilerMessage> client
private string filePath
private string remoteName
private string compilerBasicArguments
private Regex fileErrorRegex
private float startTime
private String[] preprocessor
public bool Installed
public bool get_Installed()
public void .ctor(Extension extension)
private void ExpireFileCache()
internal bool Precheck()
private bool Start()
internal void Stop(bool synchronous, string reason)
private void OnMessage(ObjectStreamConnection`2<CompilerMessage, CompilerMessage> connection, CompilerMessage message)
private void OnError(Exception exception)
private void OnProcessExited(object sender, EventArgs eventArgs)
private void ResetIdleTimer()
internal void Compile(CompilablePlugin[] plugins, Action`1<Compilation> callback)
internal void OnCompileTimeout()
private void EnqueueCompilation(Compilation compilation)
private void OnCompilerFailed(string reason)
private bool SetFilePermissions(string filePath)
private bool DownloadFile(string url, string path, int retries)
private bool TryDownload(string url, int retries, Int32& current, Nullable`1<DateTime> lastModified, Byte[]& data, Int32& code, Boolean& newerFound, String& md5)
private void Log(LogType type, string message, Exception exception)
private string GetCompilerVersion()
private string GenerateFileHash(string file)
private string EscapeSymbolName(string name)
private void <OnMessage>b__22_0()
private void <OnProcessExited>b__24_0()
private void <ResetIdleTimer>b__25_0()
}
public Oxide.CSharp.Patching.IPatch {
public void Patch(PatchContext context)
}
public Oxide.CSharp.Patching.PatchContext : object {
private AssemblyDefinition <Assembly>k__BackingField
private List`1<PatchValidationAttribute> <PatchValidators>k__BackingField
private int <TotalPatches>k__BackingField
private int <ContextPatches>k__BackingField
public AssemblyDefinition Assembly
public List`1<PatchValidationAttribute> PatchValidators
public int TotalPatches
public int ContextPatches
public AssemblyDefinition get_Assembly()
public List`1<PatchValidationAttribute> get_PatchValidators()
internal void set_PatchValidators(List`1<PatchValidationAttribute> value)
public int get_TotalPatches()
internal void set_TotalPatches(int value)
public int get_ContextPatches()
internal void set_ContextPatches(int value)
public void .ctor(AssemblyDefinition assembly)
public void IncrementPatches()
}
public Oxide.CSharp.Patching.Patcher : object {
private Type <PatchType>k__BackingField
private Type <PatchValidationType>k__BackingField
private Dictionary`2<Type, List`1<PatchValidationAttribute>> Patches
private Type PatchType
private Type PatchValidationType
private Type get_PatchType()
private Type get_PatchValidationType()
private void GetPatches(Assembly module, Dictionary`2& patchTypes)
private void GetPatches(Assembly[] modules, Dictionary`2& patchTypes)
public bool Run(AssemblyDefinition module)
public Byte[] Run(Byte[] data, Boolean& patched)
public List`1<PatchValidationAttribute> GetValidationRules(Object[] attributes)
}
public Oxide.CSharp.Patching.Publicizer : TraversePatch {
protected bool OnMemberDefinition(IMemberDefinition member)
protected bool OnTypeDefinition(TypeDefinition type)
protected bool OnFieldDefinition(FieldDefinition field)
protected bool OnPropertyDefinition(PropertyDefinition property)
protected bool OnMethodDefinition(MethodDefinition method)
}
public Oxide.CSharp.Patching.TraversePatch : object {
private string <Name>k__BackingField
private IEnumerable`1<PatchValidationAttribute> <TypeValidators>k__BackingField
private IEnumerable`1<PatchValidationAttribute> <PropertyValidators>k__BackingField
private IEnumerable`1<PatchValidationAttribute> <FieldValidators>k__BackingField
private IEnumerable`1<PatchValidationAttribute> <MethodValidators>k__BackingField
private IEnumerable`1<PatchValidationAttribute> <EventValidators>k__BackingField
private IEnumerable`1<PatchValidationAttribute> <MemberValidators>k__BackingField
protected string Name
protected IEnumerable`1<PatchValidationAttribute> TypeValidators
protected IEnumerable`1<PatchValidationAttribute> PropertyValidators
protected IEnumerable`1<PatchValidationAttribute> FieldValidators
protected IEnumerable`1<PatchValidationAttribute> MethodValidators
protected IEnumerable`1<PatchValidationAttribute> EventValidators
protected IEnumerable`1<PatchValidationAttribute> MemberValidators
protected string get_Name()
protected IEnumerable`1<PatchValidationAttribute> get_TypeValidators()
protected IEnumerable`1<PatchValidationAttribute> get_PropertyValidators()
protected IEnumerable`1<PatchValidationAttribute> get_FieldValidators()
protected IEnumerable`1<PatchValidationAttribute> get_MethodValidators()
protected IEnumerable`1<PatchValidationAttribute> get_EventValidators()
protected IEnumerable`1<PatchValidationAttribute> get_MemberValidators()
public void Patch(PatchContext context)
private void RecurseType(TypeDefinition type, PatchContext context)
protected bool OnMemberDefinition(IMemberDefinition member)
protected bool OnTypeDefinition(TypeDefinition type)
protected bool OnPropertyDefinition(PropertyDefinition property)
protected bool OnFieldDefinition(FieldDefinition field)
protected bool OnMethodDefinition(MethodDefinition method)
protected bool OnEventDefinition(EventDefinition event)
protected bool RunValidation(IMemberDefinition member, IEnumerable`1<PatchValidationAttribute> validations)
protected void Log(string message, LogType logType, Exception e)
private IEnumerable`1<PatchValidationAttribute> GetValidationRules(string methodName, Type type)
}
public Oxide.CSharp.Patching.Validation.HasAttributeAttribute : HasNameAttribute {
public void .ctor(string rule, StringValidationType type, StringComparison comparison)
protected bool IsValid(object item)
private bool <IsValid>b__1_0(CustomAttribute a)
private bool <IsValid>b__1_1(CustomAttribute a)
private bool <IsValid>b__1_2(CustomAttribute a)
private bool <IsValid>b__1_3(CustomAttribute a)
}
public Oxide.CSharp.Patching.Validation.HasEnvironmentalVariableAttribute : PatchValidationAttribute {
private string <VariableName>k__BackingField
private string VariableName
private string get_VariableName()
public void .ctor(string rule)
protected bool IsValid(object item)
}
public Oxide.CSharp.Patching.Validation.HasNameAttribute : PatchValidationAttribute {
private string <ValidationRule>k__BackingField
private StringValidationType <ValidationType>k__BackingField
private StringComparison <ValidationComparison>k__BackingField
public string ValidationRule
public StringValidationType ValidationType
public StringComparison ValidationComparison
public string get_ValidationRule()
public StringValidationType get_ValidationType()
public StringComparison get_ValidationComparison()
public void .ctor(string rule, StringValidationType type, StringComparison comparison)
protected bool IsValid(object item)
}
public Oxide.CSharp.Patching.Validation.HasVisabilityAttribute : PatchValidationAttribute {
private bool <IsPublic>k__BackingField
private Nullable`1<bool> <IsStatic>k__BackingField
public bool IsPublic
public Nullable`1<bool> IsStatic
public bool get_IsPublic()
public Nullable`1<bool> get_IsStatic()
public void set_IsStatic(Nullable`1<bool> value)
public void .ctor(bool isPublic)
protected bool IsValid(object item)
}
public Oxide.CSharp.Patching.Validation.IsHideBySig : PatchValidationAttribute {
protected bool IsValid(object item)
}
public Oxide.CSharp.Patching.Validation.IsSpecialNameAttribute : PatchValidationAttribute {
protected bool IsValid(object item)
}
public Oxide.CSharp.Patching.Validation.PatchValidationAttribute : Attribute {
private bool <InverseCheck>k__BackingField
public bool InverseCheck
public bool get_InverseCheck()
public void set_InverseCheck(bool value)
protected bool IsValid(object item)
public bool Validate(object item)
protected T GetPropertyValue(object instance, string name, T defaultValue, BindingFlags flags)
}
public Oxide.CSharp.Patching.Validation.StringValidationType : Enum {
public int value__
public StringValidationType Equals
public StringValidationType Contains
public StringValidationType StartsWith
public StringValidationType EndsWith
public StringValidationType RegularExpression
}
public Oxide.CSharp.Patching.Validation.VersionCompareMethod : Enum {
public int value__
public VersionCompareMethod Equality
public VersionCompareMethod GreaterThan
public VersionCompareMethod LessThan
public VersionCompareMethod GreaterThanOrEqualTo
public VersionCompareMethod LessThanOrEqualTo
}
public Oxide.ExtensionMethods : object {
public void WriteDebug(Logger logger, LogType level, Nullable`1<LogEvent> event, string source, string message, Exception exception)
}
public Oxide.Logging.LogEvent : ValueType {
private int <Id>k__BackingField
private string <Name>k__BackingField
private LogEvent <Compile>k__BackingField
private LogEvent <HookCall>k__BackingField
private LogEvent <Patch>k__BackingField
public int Id
public string Name
public LogEvent Compile
public LogEvent HookCall
public LogEvent Patch
public int get_Id()
public string get_Name()
internal void .ctor(int id, string name)
public LogEvent get_Compile()
public LogEvent get_HookCall()
public LogEvent get_Patch()
}
public Oxide.Plugins.ChatCommandAttribute : Attribute {
private string <Command>k__BackingField
public string Command
public string get_Command()
private void set_Command(string value)
public void .ctor(string command)
}
public Oxide.Plugins.CommandAttribute : Attribute {
private String[] <Commands>k__BackingField
public String[] Commands
public String[] get_Commands()
public void .ctor(String[] commands)
}
public Oxide.Plugins.CompilableFile : object {
private Timer timer
private object compileLock
public CSharpExtension Extension
public CSharpPluginLoader Loader
public string Name
public string Directory
public string ScriptName
public string ScriptPath
public String[] ScriptLines
public Encoding ScriptEncoding
public HashSet`1<string> Requires
public HashSet`1<string> References
public HashSet`1<string> IncludePaths
public string CompilerErrors
public CompiledAssembly CompiledAssembly
public DateTime LastModifiedAt
public DateTime LastCachedScriptAt
public DateTime LastCompiledAt
public bool IsCompilationNeeded
protected Action`1<CSharpPlugin> LoadCallback
protected Action`1<bool> CompileCallback
protected float CompilationQueuedAt
private TimerInstance timeoutTimer
public Byte[] ScriptSource
public Byte[] get_ScriptSource()
public void .ctor(CSharpExtension extension, CSharpPluginLoader loader, string directory, string name)
internal void Compile(Action`1<bool> callback)
internal void OnCompilationStarted()
internal void OnCompilationSucceeded(CompiledAssembly compiledAssembly)
internal void OnCompilationFailed()
internal void OnCompilationTimeout()
internal bool HasBeenModified()
internal void CheckLastModificationTime()
internal DateTime GetLastModificationTime()
protected void OnLoadingStarted()
protected void OnCompilationRequested()
protected void InitFailed(string message)
private void <OnCompilationStarted>b__27_0()
}
public Oxide.Plugins.CompilablePlugin : CompilableFile {
private object compileLock
public CompiledAssembly LastGoodAssembly
public bool IsLoading
public void .ctor(CSharpExtension extension, CSharpPluginLoader loader, string directory, string name)
protected void OnLoadingStarted()
protected void OnCompilationRequested()
internal void LoadPlugin(Action`1<CSharpPlugin> callback)
internal void OnCompilationStarted()
protected void InitFailed(string message)
}
internal Oxide.Plugins.Compilation : object {
public Compilation Current
internal int id
internal string name
internal Action`1<Compilation> callback
internal ConcurrentHashSet`1<CompilablePlugin> queuedPlugins
internal HashSet`1<CompilablePlugin> plugins
internal float startedAt
internal float endedAt
internal Hash`2<string, CompilerFile> references
internal HashSet`1<string> referencedPlugins
internal CompiledAssembly compiledAssembly
private string includePath
private String[] extensionNames
internal float duration
internal float get_duration()
internal void .ctor(int id, Action`1<Compilation> callback, CompilablePlugin[] plugins)
internal void Started()
internal void Completed(Byte[] rawAssembly, Byte[] symbols)
internal void Add(CompilablePlugin plugin)
internal bool IncludesRequiredPlugin(string name)
internal void Prepare(Action callback)
private void PreparseScript(CompilablePlugin plugin)
private void ResolveReferences(CompilablePlugin plugin)
private void AddDependency(CompilablePlugin plugin)
private void AddReference(CompilablePlugin plugin, string assemblyName)
private void AddReference(CompilablePlugin plugin, AssemblyName reference)
private bool CacheScriptLines(CompilablePlugin plugin)
private void CacheModifiedScripts()
private void RemovePlugin(CompilablePlugin plugin)
private void <Completed>b__17_0()
}
public Oxide.Plugins.CompiledAssembly : object {
public CompilablePlugin[] CompilablePlugins
public String[] PluginNames
public string Name
public DateTime CompiledAt
public Byte[] RawAssembly
public Byte[] Symbols
public Byte[] PatchedAssembly
public float Duration
public Assembly LoadedAssembly
public bool IsLoading
private List`1<Action`1<bool>> loadCallbacks
private bool isPatching
private bool isLoaded
public bool IsBatch
public bool get_IsBatch()
public void .ctor(string name, CompilablePlugin[] plugins, Byte[] rawAssembly, float duration, Byte[] symbols)
public void LoadAssembly(Action`1<bool> callback)
private void ValidateAssembly(Action`1<Byte[]> callback)
public bool IsOutdated()
private void <LoadAssembly>b__16_0(Byte[] rawAssembly)
private bool <IsOutdated>b__18_0(CompilablePlugin pl)
}
public Oxide.Plugins.ConsoleCommandAttribute : Attribute {
private string <Command>k__BackingField
public string Command
public string get_Command()
private void set_Command(string value)
public void .ctor(string command)
}
public Oxide.Plugins.CovalencePlugin : CSharpPlugin {
private Covalence covalence
protected string game
protected IPlayerManager players
protected IServer server
protected void Log(string format, Object[] args)
protected void LogWarning(string format, Object[] args)
protected void LogError(string format, Object[] args)
public void HandleAddedToManager(PluginManager manager)
}
public Oxide.Plugins.CSharpExtension : Extension {
internal Assembly Assembly
internal AssemblyName AssemblyName
internal VersionNumber AssemblyVersion
internal string AssemblyAuthors
private FSWatcher <Watcher>k__BackingField
private CSharpPluginLoader loader
public bool IsCoreExtension
public string Name
public string Author
public VersionNumber Version
public FSWatcher Watcher
public bool get_IsCoreExtension()
public string get_Name()
public string get_Author()
public VersionNumber get_Version()
public FSWatcher get_Watcher()
private void set_Watcher(FSWatcher value)
public void .ctor(ExtensionManager manager)
public void Load()
public void LoadPluginWatchers(string pluginDirectory)
public void OnModLoad()
public void OnShutdown()
private void OnFrame(float delta)
}
public Oxide.Plugins.CSharpPlugin : CSPlugin {
public FSWatcher Watcher
protected Covalence covalence
protected Lang lang
protected Plugins plugins
protected Permission permission
protected WebRequests webrequest
protected PluginTimers timer
protected HashSet`1<PluginFieldInfo> onlinePlayerFields
private Dictionary`2<string, MemberInfo> pluginReferenceMembers
private bool hookDispatchFallback
private bool <HookedOnFrame>k__BackingField
private object _logFileLock
public bool HookedOnFrame
public bool get_HookedOnFrame()
private void set_HookedOnFrame(bool value)
public bool SetPluginInfo(string name, string path)
public void HandleAddedToManager(PluginManager manager)
public void HandleRemovedFromManager(PluginManager manager)
public bool DirectCallHook(string name, Object& ret, Object[] args)
protected object InvokeMethod(HookMethod method, Object[] args)
public void SetFailState(string reason)
private void OnPluginLoaded(Plugin plugin)
private void OnPluginUnloaded(Plugin plugin)
protected void Puts(string format, Object[] args)
protected void PrintWarning(string format, Object[] args)
protected void PrintError(string format, Object[] args)
protected void LogToFile(string filename, string text, Plugin plugin, bool datedFilename, bool timestampPrefix)
protected void NextFrame(Action callback)
protected void NextTick(Action callback)
protected void QueueWorkerThread(Action`1<object> callback)
}
public Oxide.Plugins.CSharpPluginLoader : PluginLoader {
public String[] DefaultReferences
public HashSet`1<string> PluginReferences
public CSharpPluginLoader Instance
private CSharpExtension extension
private Dictionary`2<string, CompilablePlugin> plugins
private String[] AssemblyBlacklist
private Timer <timer>k__BackingField
private List`1<CompilablePlugin> compilationQueue
private CompilerService compiler
private Timer timer
public string FileExtension
private Timer get_timer()
public CompilablePlugin GetCompilablePlugin(string directory, string name)
public string get_FileExtension()
public void .ctor(CSharpExtension extension)
public void OnModLoaded()
public IEnumerable`1<string> ScanDirectory(string directory)
public Plugin Load(string directory, string name)
public void Reload(string directory, string name)
public void Unloading(Plugin pluginBase)
public void Load(CompilablePlugin plugin)
public void CompilationRequested(CompilablePlugin plugin)
public void PluginLoadingStarted(CompilablePlugin plugin)
private void PluginLoadingCompleted(CompilablePlugin plugin)
private void CompileAssembly(CompilablePlugin[] plugins)
public void OnShutdown()
private IEnumerable`1<string> <>n__0(string directory)
private void <CompilationRequested>b__21_0()
private void <CompileAssembly>b__24_0(Compilation compilation)
}
public Oxide.Plugins.DescriptionAttribute : Attribute {
private string <Description>k__BackingField
public string Description
public string get_Description()
public void .ctor(string description)
}
public Oxide.Plugins.Hash`2 : object {
private IDictionary`2<TKey, TValue> dictionary
public TValue Item
public ICollection`1<TKey> Keys
public ICollection`1<TValue> Values
public int Count
public bool IsReadOnly
public void .ctor(IEqualityComparer`1<TKey> comparer)
public TValue get_Item(TKey key)
public void set_Item(TKey key, TValue value)
public ICollection`1<TKey> get_Keys()
public ICollection`1<TValue> get_Values()
public int get_Count()
public bool get_IsReadOnly()
public IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator()
public bool ContainsKey(TKey key)
public bool Contains(KeyValuePair`2<TKey, TValue> item)
public void CopyTo(KeyValuePair`2[] array, int index)
public bool TryGetValue(TKey key, TValue& value)
public void Add(TKey key, TValue value)
public void Add(KeyValuePair`2<TKey, TValue> item)
public bool Remove(TKey key)
public bool Remove(KeyValuePair`2<TKey, TValue> item)
public void Clear()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
}
public Oxide.Plugins.InfoAttribute : Attribute {
private string <Title>k__BackingField
private string <Author>k__BackingField
private VersionNumber <Version>k__BackingField
private int <ResourceId>k__BackingField
public string Title
public string Author
public VersionNumber Version
public int ResourceId
public string get_Title()
public string get_Author()
public VersionNumber get_Version()
private void set_Version(VersionNumber value)
public int get_ResourceId()
public void set_ResourceId(int value)
public void .ctor(string Title, string Author, string Version)
public void .ctor(string Title, string Author, double Version)
private void SetVersion(string version)
}
public Oxide.Plugins.PermissionAttribute : Attribute {
private String[] <Permission>k__BackingField
public String[] Permission
public String[] get_Permission()
public void .ctor(string permission)
}
public Oxide.Plugins.PluginLoadFailure : Exception {
public void .ctor(string reason)
}
public Oxide.Plugins.PluginReferenceAttribute : Attribute {
private string <Name>k__BackingField
public string Name
public string get_Name()
public void .ctor(string name)
}
public Oxide.Plugins.PluginTimers : object {
private Timer timer
private Plugin plugin
public void .ctor(Plugin plugin)
public Timer Once(float seconds, Action callback)
public Timer In(float seconds, Action callback)
public Timer Every(float interval, Action callback)
public Timer Repeat(float interval, int repeats, Action callback)
public void Destroy(Timer& timer)
}
public Oxide.Plugins.Timer : object {
private TimerInstance instance
public int Repetitions
public float Delay
public Action Callback
public bool Destroyed
public Plugin Owner
public void .ctor(TimerInstance instance)
public int get_Repetitions()
public float get_Delay()
public Action get_Callback()
public bool get_Destroyed()
public Plugin get_Owner()
public void Reset(float delay, int repetitions)
public void Destroy()
public void DestroyToPool()
}
