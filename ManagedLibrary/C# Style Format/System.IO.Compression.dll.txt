internal Consts : object {
public string MonoVersion
public string MonoCompany
public string MonoProduct
public string MonoCopyright
public int MonoCorlibVersion
public string FxVersion
public string FxFileVersion
public string EnvironmentVersion
public string VsVersion
public string VsFileVersion
private string PublicKeyToken
public string AssemblyI18N
public string AssemblyMicrosoft_JScript
public string AssemblyMicrosoft_VisualStudio
public string AssemblyMicrosoft_VisualStudio_Web
public string AssemblyMicrosoft_VSDesigner
public string AssemblyMono_Http
public string AssemblyMono_Posix
public string AssemblyMono_Security
public string AssemblyMono_Messaging_RabbitMQ
public string AssemblyCorlib
public string AssemblySystem
public string AssemblySystem_Data
public string AssemblySystem_Design
public string AssemblySystem_DirectoryServices
public string AssemblySystem_Drawing
public string AssemblySystem_Drawing_Design
public string AssemblySystem_Messaging
public string AssemblySystem_Security
public string AssemblySystem_ServiceProcess
public string AssemblySystem_Web
public string AssemblySystem_Windows_Forms
public string AssemblySystem_2_0
public string AssemblySystemCore_3_5
public string AssemblySystem_Core
public string WindowsBase_3_0
public string AssemblyWindowsBase
public string AssemblyPresentationCore_3_5
public string AssemblyPresentationCore_4_0
public string AssemblyPresentationFramework_3_5
public string AssemblySystemServiceModel_3_0
}
internal SR : object {
public string ArgumentOutOfRange_Enum
public string ArgumentOutOfRange_NeedPosNum
public string CannotReadFromDeflateStream
public string CannotWriteToDeflateStream
public string GenericInvalidData
public string InvalidArgumentOffsetCount
public string InvalidBeginCall
public string InvalidBlockLength
public string InvalidHuffmanData
public string NotSupported
public string NotSupported_UnreadableStream
public string NotSupported_UnwritableStream
public string ObjectDisposed_StreamClosed
public string UnknownBlockType
public string UnknownState
public string ZLibErrorDLLLoadError
public string ZLibErrorInconsistentStream
public string ZLibErrorIncorrectInitParameters
public string ZLibErrorNotEnoughMemory
public string ZLibErrorVersionMismatch
public string ZLibErrorUnexpected
public string CorruptedGZipHeader
public string UnknownCompressionMode
public string InvalidCRC
public string InvalidStreamSize
public string ArgumentNeedNonNegative
public string CannotBeEmpty
public string CDCorrupt
public string CentralDirectoryInvalid
public string CreateInReadMode
public string CreateModeCapabilities
public string CreateModeCreateEntryWhileOpen
public string CreateModeWriteOnceAndOneEntryAtATime
public string DateTimeOutOfRange
public string DeletedEntry
public string DeleteOnlyInUpdate
public string DeleteOpenEntry
public string EntriesInCreateMode
public string EntryNameEncodingNotSupported
public string EntryNamesTooLong
public string EntryTooLarge
public string EOCDNotFound
public string FieldTooBigCompressedSize
public string FieldTooBigLocalHeaderOffset
public string FieldTooBigNumEntries
public string FieldTooBigOffsetToCD
public string FieldTooBigOffsetToZip64EOCD
public string FieldTooBigStartDiskNumber
public string FieldTooBigUncompressedSize
public string FrozenAfterWrite
public string HiddenStreamName
public string LengthAfterWrite
public string LocalFileHeaderCorrupt
public string NumEntriesWrong
public string OffsetLengthInvalid
public string ReadingNotSupported
public string ReadModeCapabilities
public string ReadOnlyArchive
public string SeekingNotSupported
public string SetLengthRequiresSeekingAndWriting
public string SplitSpanned
public string UnexpectedEndOfStream
public string UnsupportedCompression
public string UnsupportedCompressionMethod
public string UpdateModeCapabilities
public string UpdateModeOneStream
public string WritingNotSupported
public string Zip64EOCDNotWhereExpected
public string Argument_InvalidPathChars
public string FileNameContainsInvalidCharacters
internal string GetString(string name, Object[] args)
internal string GetString(CultureInfo culture, string name, Object[] args)
internal string GetString(string name)
internal string GetString(CultureInfo culture, string name)
internal string Format(string resourceFormat, Object[] args)
internal string Format(string resourceFormat, object p1)
internal string Format(string resourceFormat, object p1, object p2)
internal string Format(string resourceFormat, object p1, object p2, object p3)
}
internal System.IO.Compression.BlockType : Enum {
public int value__
public BlockType Uncompressed
public BlockType Static
public BlockType Dynamic
}
internal System.IO.Compression.CheckSumAndSizeWriteStream : Stream {
private Stream _baseStream
private Stream _baseBaseStream
private long _position
private UInt32 _checksum
private bool _leaveOpenOnClose
private bool _canWrite
private bool _isDisposed
private bool _everWritten
private long _initialPosition
private ZipArchiveEntry _zipArchiveEntry
private EventHandler _onClose
private Action`6<long, long, UInt32, Stream, ZipArchiveEntry, EventHandler> _saveCrcAndSizes
public long Length
public long Position
public bool CanRead
public bool CanSeek
public bool CanWrite
public void .ctor(Stream baseStream, Stream baseBaseStream, bool leaveOpenOnClose, ZipArchiveEntry entry, EventHandler onClose, Action`6<long, long, UInt32, Stream, ZipArchiveEntry, EventHandler> saveCrcAndSizes)
public long get_Length()
public long get_Position()
public void set_Position(long value)
public bool get_CanRead()
public bool get_CanSeek()
public bool get_CanWrite()
private void ThrowIfDisposed()
public int Read(Byte[] buffer, int offset, int count)
public long Seek(long offset, SeekOrigin origin)
public void SetLength(long value)
public void Write(Byte[] buffer, int offset, int count)
public void Flush()
protected void Dispose(bool disposing)
}
internal System.IO.Compression.CopyEncoder : object {
private int PaddingSize
private int MaxUncompressedBlockSize
public void GetBlock(DeflateInput input, OutputBuffer output, bool isFinal)
private void WriteLenNLen(ushort len, OutputBuffer output)
}
internal System.IO.Compression.Crc32Helper : object {
private UInt32[] s_crcTable_0
private UInt32[] s_crcTable_1
private UInt32[] s_crcTable_2
private UInt32[] s_crcTable_3
private UInt32[] s_crcTable_4
private UInt32[] s_crcTable_5
private UInt32[] s_crcTable_6
private UInt32[] s_crcTable_7
public UInt32 UpdateCrc32(UInt32 crc32, Byte[] buffer, int offset, int length)
private UInt32 ManagedCrc32(UInt32 crc32, Byte[] buffer, int offset, int length)
}
internal System.IO.Compression.DeflateInput : object {
private Byte[] <Buffer>k__BackingField
private int <Count>k__BackingField
private int <StartIndex>k__BackingField
internal Byte[] Buffer
internal int Count
internal int StartIndex
internal Byte[] get_Buffer()
internal void set_Buffer(Byte[] value)
internal int get_Count()
internal void set_Count(int value)
internal int get_StartIndex()
internal void set_StartIndex(int value)
internal void ConsumeBytes(int n)
internal InputState DumpState()
internal void RestoreState(InputState state)
}
internal System.IO.Compression.DeflateManagedStream : Stream {
internal int DefaultBufferSize
private Stream _stream
private CompressionMode _mode
private bool _leaveOpen
private InflaterManaged _inflater
private DeflaterManaged _deflater
private Byte[] _buffer
private int _asyncOperations
private IFileFormatWriter _formatWriter
private bool _wroteHeader
private bool _wroteBytes
public bool CanRead
public bool CanWrite
public bool CanSeek
public long Length
public long Position
internal void .ctor(Stream stream, CompressionMethodValues method)
internal void InitializeInflater(Stream stream, bool leaveOpen, IFileFormatReader reader, CompressionMethodValues method)
internal void SetFileFormatWriter(IFileFormatWriter writer)
public bool get_CanRead()
public bool get_CanWrite()
public bool get_CanSeek()
public long get_Length()
public long get_Position()
public void set_Position(long value)
public void Flush()
public Task FlushAsync(CancellationToken cancellationToken)
public long Seek(long offset, SeekOrigin origin)
public void SetLength(long value)
public int Read(Byte[] array, int offset, int count)
private void ValidateParameters(Byte[] array, int offset, int count)
private void EnsureNotDisposed()
private void ThrowStreamClosedException()
private void EnsureDecompressionMode()
private void ThrowCannotReadFromDeflateManagedStreamException()
private void EnsureCompressionMode()
private void ThrowCannotWriteToDeflateManagedStreamException()
public IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback asyncCallback, object asyncState)
public int EndRead(IAsyncResult asyncResult)
public Task`1<int> ReadAsync(Byte[] array, int offset, int count, CancellationToken cancellationToken)
private Task`1<int> ReadAsyncCore(Task`1<int> readTask, Byte[] array, int offset, int count, CancellationToken cancellationToken)
public void Write(Byte[] array, int offset, int count)
private void WriteDeflaterOutput()
private void DoMaintenance(Byte[] array, int offset, int count)
private void PurgeBuffers(bool disposing)
protected void Dispose(bool disposing)
public Task WriteAsync(Byte[] array, int offset, int count, CancellationToken cancellationToken)
private Task WriteAsyncCore(Byte[] array, int offset, int count, CancellationToken cancellationToken)
public IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback asyncCallback, object asyncState)
public void EndWrite(IAsyncResult asyncResult)
private Task <>n__0(Byte[] buffer, int offset, int count, CancellationToken cancellationToken)
}
internal System.IO.Compression.DeflaterManaged : object {
private int MinBlockSize
private int MaxHeaderFooterGoo
private int CleanCopySize
private double BadCompressionThreshold
private FastEncoder _deflateEncoder
private CopyEncoder _copyEncoder
private DeflateInput _input
private OutputBuffer _output
private DeflaterState _processingState
private DeflateInput _inputFromHistory
internal bool NeedsInput()
internal void SetInput(Byte[] inputBuffer, int startIndex, int count)
internal int GetDeflateOutput(Byte[] outputBuffer)
internal bool Finish(Byte[] outputBuffer, Int32& bytesRead)
private bool UseCompressed(double ratio)
private void FlushInputWindows()
private void WriteFinal()
public void Dispose()
}
internal System.IO.Compression.FastEncoder : object {
private FastEncoderWindow _inputWindow
private Match _currentMatch
private double _lastCompressionRatio
internal int BytesInHistory
internal DeflateInput UnprocessedInput
internal double LastCompressionRatio
internal int get_BytesInHistory()
internal DeflateInput get_UnprocessedInput()
internal void FlushInput()
internal double get_LastCompressionRatio()
internal void GetBlock(DeflateInput input, OutputBuffer output, int maxBytesToCopy)
internal void GetCompressedData(DeflateInput input, OutputBuffer output)
internal void GetBlockHeader(OutputBuffer output)
internal void GetBlockFooter(OutputBuffer output)
private void GetCompressedOutput(DeflateInput input, OutputBuffer output, int maxBytesToCopy)
private void GetCompressedOutput(OutputBuffer output)
private bool InputAvailable(DeflateInput input)
private bool SafeToWriteTo(OutputBuffer output)
private void WriteEndOfBlock(OutputBuffer output)
internal void WriteMatch(int matchLen, int matchPos, OutputBuffer output)
internal void WriteChar(byte b, OutputBuffer output)
internal void WriteDeflatePreamble(OutputBuffer output)
}
internal System.IO.Compression.FastEncoderStatics : object {
internal Byte[] FastEncoderTreeStructureData
internal Byte[] BFinalFastEncoderTreeStructureData
internal UInt32[] FastEncoderLiteralCodeInfo
internal UInt32[] FastEncoderDistanceCodeInfo
internal UInt32[] BitMask
internal Byte[] ExtraLengthBits
internal Byte[] ExtraDistanceBits
internal int NumChars
internal int NumLengthBaseCodes
internal int NumDistBaseCodes
internal UInt32 FastEncoderPostTreeBitBuf
internal int FastEncoderPostTreeBitCount
internal UInt32 NoCompressionHeader
internal int NoCompressionHeaderBitCount
internal UInt32 BFinalNoCompressionHeader
internal int BFinalNoCompressionHeaderBitCount
internal int MaxCodeLen
private Byte[] s_distLookup
private Byte[] CreateDistanceLookup()
internal int GetSlot(int pos)
public UInt32 BitReverse(UInt32 code, int length)
}
internal System.IO.Compression.FastEncoderWindow : object {
private Byte[] _window
private int _bufPos
private int _bufEnd
private int FastEncoderHashShift
private int FastEncoderHashtableSize
private int FastEncoderHashMask
private int FastEncoderWindowSize
private int FastEncoderWindowMask
private int FastEncoderMatch3DistThreshold
internal int MaxMatch
internal int MinMatch
private int SearchDepth
private int GoodLength
private int NiceLength
private int LazyMatchThreshold
private UInt16[] _prev
private UInt16[] _lookup
public int BytesAvailable
public DeflateInput UnprocessedInput
public int FreeWindowSpace
public int get_BytesAvailable()
public DeflateInput get_UnprocessedInput()
public void FlushWindow()
private void ResetWindow()
public int get_FreeWindowSpace()
public void CopyBytes(Byte[] inputBuffer, int startIndex, int count)
public void MoveWindows()
private UInt32 HashValue(UInt32 hash, byte b)
private UInt32 InsertString(UInt32& hash)
private void InsertStrings(UInt32& hash, int matchLen)
internal bool GetNextSymbolOrMatch(Match match)
private int FindMatch(int search, Int32& matchPos, int searchDepth, int niceLength)
private void DebugAssertVerifyHashes()
private void DebugAssertRecalculatedHashesAreEqual(int position1, int position2, string message)
}
internal System.IO.Compression.HuffmanTree : object {
internal int MaxLiteralTreeElements
internal int MaxDistTreeElements
internal int EndOfBlockCode
internal int NumberOfCodeLengthTreeElements
private int _tableBits
private Int16[] _table
private Int16[] _left
private Int16[] _right
private Byte[] _codeLengthArray
private int _tableMask
private HuffmanTree <StaticLiteralLengthTree>k__BackingField
private HuffmanTree <StaticDistanceTree>k__BackingField
public HuffmanTree StaticLiteralLengthTree
public HuffmanTree StaticDistanceTree
public HuffmanTree get_StaticLiteralLengthTree()
public HuffmanTree get_StaticDistanceTree()
public void .ctor(Byte[] codeLengths)
private Byte[] GetStaticLiteralTreeLength()
private Byte[] GetStaticDistanceTreeLength()
private UInt32[] CalculateHuffmanCode()
private void CreateTable()
public int GetNextSymbol(InputBuffer input)
}
internal System.IO.Compression.IFileFormatReader {
public bool ReadHeader(InputBuffer input)
public bool ReadFooter(InputBuffer input)
public void UpdateWithBytesRead(Byte[] buffer, int offset, int bytesToCopy)
public void Validate()
}
internal System.IO.Compression.IFileFormatWriter {
public Byte[] GetHeader()
public void UpdateWithBytesRead(Byte[] buffer, int offset, int bytesToCopy)
public Byte[] GetFooter()
}
internal System.IO.Compression.InflaterManaged : object {
private Byte[] s_extraLengthBits
private Int32[] s_lengthBase
private Int32[] s_distanceBasePosition
private Byte[] s_codeOrder
private Byte[] s_staticDistanceTreeTable
private OutputWindow _output
private InputBuffer _input
private HuffmanTree _literalLengthTree
private HuffmanTree _distanceTree
private InflaterState _state
private bool _hasFormatReader
private int _bfinal
private BlockType _blockType
private Byte[] _blockLengthBuffer
private int _blockLength
private int _length
private int _distanceCode
private int _extraBits
private int _loopCounter
private int _literalLengthCodeCount
private int _distanceCodeCount
private int _codeLengthCodeCount
private int _codeArraySize
private int _lengthCode
private Byte[] _codeList
private Byte[] _codeLengthTreeCodeLength
private bool _deflate64
private HuffmanTree _codeLengthTree
private IFileFormatReader _formatReader
public int AvailableOutput
internal void .ctor(IFileFormatReader reader, bool deflate64)
private void Reset()
public void SetInput(Byte[] inputBytes, int offset, int length)
public bool Finished()
public int get_AvailableOutput()
public int Inflate(Byte[] bytes, int offset, int length)
private bool Decode()
private bool DecodeUncompressedBlock(Boolean& end_of_block)
private bool DecodeBlock(Boolean& end_of_block_code_seen)
private bool DecodeDynamicBlockHeader()
public void Dispose()
}
internal System.IO.Compression.InflaterState : Enum {
public int value__
public InflaterState ReadingHeader
public InflaterState ReadingBFinal
public InflaterState ReadingBType
public InflaterState ReadingNumLitCodes
public InflaterState ReadingNumDistCodes
public InflaterState ReadingNumCodeLengthCodes
public InflaterState ReadingCodeLengthCodes
public InflaterState ReadingTreeCodesBefore
public InflaterState ReadingTreeCodesAfter
public InflaterState DecodeTop
public InflaterState HaveInitialLength
public InflaterState HaveFullLength
public InflaterState HaveDistCode
public InflaterState UncompressedAligning
public InflaterState UncompressedByte1
public InflaterState UncompressedByte2
public InflaterState UncompressedByte3
public InflaterState UncompressedByte4
public InflaterState DecodingUncompressed
public InflaterState StartReadingFooter
public InflaterState ReadingFooter
public InflaterState VerifyingFooter
public InflaterState Done
}
internal System.IO.Compression.InputBuffer : object {
private Byte[] _buffer
private int _start
private int _end
private UInt32 _bitBuffer
private int _bitsInBuffer
public int AvailableBits
public int AvailableBytes
public int get_AvailableBits()
public int get_AvailableBytes()
public bool EnsureBitsAvailable(int count)
public UInt32 TryLoad16Bits()
private UInt32 GetBitMask(int count)
public int GetBits(int count)
public int CopyTo(Byte[] output, int offset, int length)
public bool NeedsInput()
public void SetInput(Byte[] buffer, int offset, int length)
public void SkipBits(int n)
public void SkipToByteBoundary()
}
internal System.IO.Compression.Match : object {
private MatchState <State>k__BackingField
private int <Position>k__BackingField
private int <Length>k__BackingField
private byte <Symbol>k__BackingField
internal MatchState State
internal int Position
internal int Length
internal byte Symbol
internal MatchState get_State()
internal void set_State(MatchState value)
internal int get_Position()
internal void set_Position(int value)
internal int get_Length()
internal void set_Length(int value)
internal byte get_Symbol()
internal void set_Symbol(byte value)
}
internal System.IO.Compression.MatchState : Enum {
public int value__
public MatchState HasSymbol
public MatchState HasMatch
public MatchState HasSymbolAndMatch
}
internal System.IO.Compression.OutputBuffer : object {
private Byte[] _byteBuffer
private int _pos
private UInt32 _bitBuf
private int _bitCount
internal int BytesWritten
internal int FreeBytes
internal int BitsInBuffer
internal void UpdateBuffer(Byte[] output)
internal int get_BytesWritten()
internal int get_FreeBytes()
internal void WriteUInt16(ushort value)
internal void WriteBits(int n, UInt32 bits)
internal void FlushBits()
internal void WriteBytes(Byte[] byteArray, int offset, int count)
private void WriteBytesUnaligned(Byte[] byteArray, int offset, int count)
private void WriteByteUnaligned(byte b)
internal int get_BitsInBuffer()
internal BufferState DumpState()
internal void RestoreState(BufferState state)
}
internal System.IO.Compression.OutputWindow : object {
private int WindowSize
private int WindowMask
private Byte[] _window
private int _end
private int _bytesUsed
public int FreeBytes
public int AvailableBytes
public void Write(byte b)
public void WriteLengthDistance(int length, int distance)
public int CopyFrom(InputBuffer input, int length)
public int get_FreeBytes()
public int get_AvailableBytes()
public int CopyTo(Byte[] output, int offset, int length)
}
internal System.IO.Compression.PositionPreservingWriteOnlyStreamWrapper : Stream {
private Stream _stream
private long _position
public bool CanRead
public bool CanSeek
public bool CanWrite
public long Position
public bool CanTimeout
public int ReadTimeout
public int WriteTimeout
public long Length
public void .ctor(Stream stream)
public bool get_CanRead()
public bool get_CanSeek()
public bool get_CanWrite()
public long get_Position()
public void set_Position(long value)
public void Write(Byte[] buffer, int offset, int count)
public IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state)
public void EndWrite(IAsyncResult asyncResult)
public void WriteByte(byte value)
public Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken)
public bool get_CanTimeout()
public int get_ReadTimeout()
public void set_ReadTimeout(int value)
public int get_WriteTimeout()
public void set_WriteTimeout(int value)
public void Flush()
public Task FlushAsync(CancellationToken cancellationToken)
public void Close()
protected void Dispose(bool disposing)
public long get_Length()
public long Seek(long offset, SeekOrigin origin)
public void SetLength(long value)
public int Read(Byte[] buffer, int offset, int count)
}
internal System.IO.Compression.SubReadStream : Stream {
private long _startInSuperStream
private long _positionInSuperStream
private long _endInSuperStream
private Stream _superStream
private bool _canRead
private bool _isDisposed
public long Length
public long Position
public bool CanRead
public bool CanSeek
public bool CanWrite
public void .ctor(Stream superStream, long startPosition, long maxLength)
public long get_Length()
public long get_Position()
public void set_Position(long value)
public bool get_CanRead()
public bool get_CanSeek()
public bool get_CanWrite()
private void ThrowIfDisposed()
private void ThrowIfCantRead()
public int Read(Byte[] buffer, int offset, int count)
public long Seek(long offset, SeekOrigin origin)
public void SetLength(long value)
public void Write(Byte[] buffer, int offset, int count)
public void Flush()
protected void Dispose(bool disposing)
}
internal System.IO.Compression.WrappedStream : Stream {
private Stream _baseStream
private bool _closeBaseStream
private Action`1<ZipArchiveEntry> _onClosed
private ZipArchiveEntry _zipArchiveEntry
private bool _isDisposed
public long Length
public long Position
public bool CanRead
public bool CanSeek
public bool CanWrite
internal void .ctor(Stream baseStream, bool closeBaseStream)
private void .ctor(Stream baseStream, bool closeBaseStream, ZipArchiveEntry entry, Action`1<ZipArchiveEntry> onClosed)
internal void .ctor(Stream baseStream, ZipArchiveEntry entry, Action`1<ZipArchiveEntry> onClosed)
public long get_Length()
public long get_Position()
public void set_Position(long value)
public bool get_CanRead()
public bool get_CanSeek()
public bool get_CanWrite()
private void ThrowIfDisposed()
private void ThrowIfCantRead()
private void ThrowIfCantWrite()
private void ThrowIfCantSeek()
public int Read(Byte[] buffer, int offset, int count)
public long Seek(long offset, SeekOrigin origin)
public void SetLength(long value)
public void Write(Byte[] buffer, int offset, int count)
public void Flush()
protected void Dispose(bool disposing)
}
internal System.IO.Compression.Zip64EndOfCentralDirectoryLocator : ValueType {
public UInt32 SignatureConstant
public int SizeOfBlockWithoutSignature
public UInt32 NumberOfDiskWithZip64EOCD
public ulong OffsetOfZip64EOCD
public UInt32 TotalNumberOfDisks
public bool TryReadBlock(BinaryReader reader, Zip64EndOfCentralDirectoryLocator& zip64EOCDLocator)
public void WriteBlock(Stream stream, long zip64EOCDRecordStart)
}
internal System.IO.Compression.Zip64EndOfCentralDirectoryRecord : ValueType {
private UInt32 SignatureConstant
private ulong NormalSize
public ulong SizeOfThisRecord
public ushort VersionMadeBy
public ushort VersionNeededToExtract
public UInt32 NumberOfThisDisk
public UInt32 NumberOfDiskWithStartOfCD
public ulong NumberOfEntriesOnThisDisk
public ulong NumberOfEntriesTotal
public ulong SizeOfCentralDirectory
public ulong OffsetOfCentralDirectory
public bool TryReadBlock(BinaryReader reader, Zip64EndOfCentralDirectoryRecord& zip64EOCDRecord)
public void WriteBlock(Stream stream, long numberOfEntries, long startOfCentralDirectory, long sizeOfCentralDirectory)
}
internal System.IO.Compression.Zip64ExtraField : ValueType {
public int OffsetToFirstField
private ushort TagConstant
private ushort _size
private Nullable`1<long> _uncompressedSize
private Nullable`1<long> _compressedSize
private Nullable`1<long> _localHeaderOffset
private Nullable`1<int> _startDiskNumber
public ushort TotalSize
public Nullable`1<long> UncompressedSize
public Nullable`1<long> CompressedSize
public Nullable`1<long> LocalHeaderOffset
public Nullable`1<int> StartDiskNumber
public ushort get_TotalSize()
public Nullable`1<long> get_UncompressedSize()
public void set_UncompressedSize(Nullable`1<long> value)
public Nullable`1<long> get_CompressedSize()
public void set_CompressedSize(Nullable`1<long> value)
public Nullable`1<long> get_LocalHeaderOffset()
public void set_LocalHeaderOffset(Nullable`1<long> value)
public Nullable`1<int> get_StartDiskNumber()
private void UpdateSize()
public Zip64ExtraField GetJustZip64Block(Stream extraFieldStream, bool readUncompressedSize, bool readCompressedSize, bool readLocalHeaderOffset, bool readStartDiskNumber)
private bool TryGetZip64BlockFromGenericExtraField(ZipGenericExtraField extraField, bool readUncompressedSize, bool readCompressedSize, bool readLocalHeaderOffset, bool readStartDiskNumber, Zip64ExtraField& zip64Block)
public Zip64ExtraField GetAndRemoveZip64Block(List`1<ZipGenericExtraField> extraFields, bool readUncompressedSize, bool readCompressedSize, bool readLocalHeaderOffset, bool readStartDiskNumber)
public void RemoveZip64Blocks(List`1<ZipGenericExtraField> extraFields)
public void WriteBlock(Stream stream)
}
public System.IO.Compression.ZipArchive : object {
private Stream _archiveStream
private ZipArchiveEntry _archiveStreamOwner
private BinaryReader _archiveReader
private ZipArchiveMode _mode
private List`1<ZipArchiveEntry> _entries
private ReadOnlyCollection`1<ZipArchiveEntry> _entriesCollection
private Dictionary`2<string, ZipArchiveEntry> _entriesDictionary
private bool _readEntries
private bool _leaveOpen
private long _centralDirectoryStart
private bool _isDisposed
private UInt32 _numberOfThisDisk
private long _expectedNumberOfEntries
private Stream _backingStream
private Byte[] _archiveComment
private Encoding _entryNameEncoding
public ReadOnlyCollection`1<ZipArchiveEntry> Entries
public ZipArchiveMode Mode
internal BinaryReader ArchiveReader
internal Stream ArchiveStream
internal UInt32 NumberOfThisDisk
internal Encoding EntryNameEncoding
public void .ctor(Stream stream)
public void .ctor(Stream stream, ZipArchiveMode mode)
public void .ctor(Stream stream, ZipArchiveMode mode, bool leaveOpen)
public void .ctor(Stream stream, ZipArchiveMode mode, bool leaveOpen, Encoding entryNameEncoding)
public ReadOnlyCollection`1<ZipArchiveEntry> get_Entries()
public ZipArchiveMode get_Mode()
public ZipArchiveEntry CreateEntry(string entryName)
public ZipArchiveEntry CreateEntry(string entryName, CompressionLevel compressionLevel)
protected void Dispose(bool disposing)
public void Dispose()
public ZipArchiveEntry GetEntry(string entryName)
internal BinaryReader get_ArchiveReader()
internal Stream get_ArchiveStream()
internal UInt32 get_NumberOfThisDisk()
internal Encoding get_EntryNameEncoding()
private void set_EntryNameEncoding(Encoding value)
private ZipArchiveEntry DoCreateEntry(string entryName, Nullable`1<CompressionLevel> compressionLevel)
internal void AcquireArchiveStream(ZipArchiveEntry entry)
private void AddEntry(ZipArchiveEntry entry)
internal void DebugAssertIsStillArchiveStreamOwner(ZipArchiveEntry entry)
internal void ReleaseArchiveStream(ZipArchiveEntry entry)
internal void RemoveEntry(ZipArchiveEntry entry)
internal void ThrowIfDisposed()
private void CloseStreams()
private void EnsureCentralDirectoryRead()
private void Init(Stream stream, ZipArchiveMode mode, bool leaveOpen)
private void ReadCentralDirectory()
private void ReadEndOfCentralDirectory()
private void WriteFile()
private void WriteArchiveEpilogue(long startOfCentralDirectory, long sizeOfCentralDirectory)
}
public System.IO.Compression.ZipArchiveEntry : object {
private ushort DefaultVersionToExtract
private int MaxSingleBufferSize
private ZipArchive _archive
private bool _originallyInArchive
private int _diskNumberStart
private ZipVersionMadeByPlatform _versionMadeByPlatform
private ZipVersionNeededValues _versionMadeBySpecification
private ZipVersionNeededValues _versionToExtract
private BitFlagValues _generalPurposeBitFlag
private CompressionMethodValues _storedCompressionMethod
private DateTimeOffset _lastModified
private long _compressedSize
private long _uncompressedSize
private long _offsetOfLocalHeader
private Nullable`1<long> _storedOffsetOfCompressedData
private UInt32 _crc32
private Byte[][] _compressedBytes
private MemoryStream _storedUncompressedData
private bool _currentlyOpenForWrite
private bool _everOpenedForWrite
private Stream _outstandingWriteStream
private UInt32 _externalFileAttr
private string _storedEntryName
private Byte[] _storedEntryNameBytes
private List`1<ZipGenericExtraField> _cdUnknownExtraFields
private List`1<ZipGenericExtraField> _lhUnknownExtraFields
private Byte[] _fileComment
private Nullable`1<CompressionLevel> _compressionLevel
private bool s_allowLargeZipArchiveEntriesInUpdateMode
internal ZipVersionMadeByPlatform CurrentZipPlatform
public ZipArchive Archive
public long CompressedLength
public int ExternalAttributes
public string FullName
public DateTimeOffset LastWriteTime
public long Length
public string Name
internal bool EverOpenedForWrite
private long OffsetOfCompressedData
private MemoryStream UncompressedData
private CompressionMethodValues CompressionMethod
internal void .ctor(ZipArchive archive, ZipCentralDirectoryFileHeader cd)
internal void .ctor(ZipArchive archive, string entryName, CompressionLevel compressionLevel)
internal void .ctor(ZipArchive archive, string entryName)
public ZipArchive get_Archive()
public long get_CompressedLength()
public int get_ExternalAttributes()
public void set_ExternalAttributes(int value)
public string get_FullName()
private void set_FullName(string value)
public DateTimeOffset get_LastWriteTime()
public void set_LastWriteTime(DateTimeOffset value)
public long get_Length()
public string get_Name()
public void Delete()
public Stream Open()
public string ToString()
internal bool get_EverOpenedForWrite()
private long get_OffsetOfCompressedData()
private MemoryStream get_UncompressedData()
private CompressionMethodValues get_CompressionMethod()
private void set_CompressionMethod(CompressionMethodValues value)
private string DecodeEntryName(Byte[] entryNameBytes)
private Byte[] EncodeEntryName(string entryName, Boolean& isUTF8)
internal void WriteAndFinishLocalEntry()
internal void WriteCentralDirectoryFileHeader()
internal bool LoadLocalHeaderExtraFieldAndCompressedBytesIfNeeded()
internal void ThrowIfNotOpenable(bool needToUncompress, bool needToLoadIntoMemory)
private CheckSumAndSizeWriteStream GetDataCompressor(Stream backingStream, bool leaveBackingStreamOpen, EventHandler onClose)
private Stream GetDataDecompressor(Stream compressedStreamToRead)
private Stream OpenInReadMode(bool checkOpenable)
private Stream OpenInWriteMode()
private Stream OpenInUpdateMode()
private bool IsOpenable(bool needToUncompress, bool needToLoadIntoMemory, String& message)
private bool SizesTooLarge()
private bool WriteLocalFileHeader(bool isEmptyFile)
private void WriteLocalFileHeaderAndDataIfNeeded()
private void WriteCrcAndSizesInLocalHeader(bool zip64HeaderUsed)
private void WriteDataDescriptor()
private void UnloadStreams()
private void CloseStreams()
private void VersionToExtractAtLeast(ZipVersionNeededValues value)
private void ThrowIfInvalidArchive()
private string GetFileName_Windows(string path)
private string GetFileName_Unix(string path)
internal string ParseFileName(string path, ZipVersionMadeByPlatform madeByPlatform)
}
public System.IO.Compression.ZipArchiveMode : Enum {
public int value__
public ZipArchiveMode Read
public ZipArchiveMode Create
public ZipArchiveMode Update
}
internal System.IO.Compression.ZipCentralDirectoryFileHeader : ValueType {
public UInt32 SignatureConstant
public byte VersionMadeByCompatibility
public byte VersionMadeBySpecification
public ushort VersionNeededToExtract
public ushort GeneralPurposeBitFlag
public ushort CompressionMethod
public UInt32 LastModified
public UInt32 Crc32
public long CompressedSize
public long UncompressedSize
public ushort FilenameLength
public ushort ExtraFieldLength
public ushort FileCommentLength
public int DiskNumberStart
public ushort InternalFileAttributes
public UInt32 ExternalFileAttributes
public long RelativeOffsetOfLocalHeader
public Byte[] Filename
public Byte[] FileComment
public List`1<ZipGenericExtraField> ExtraFields
public bool TryReadBlock(BinaryReader reader, bool saveExtraFieldsAndComments, ZipCentralDirectoryFileHeader& header)
}
internal System.IO.Compression.ZipEndOfCentralDirectoryBlock : ValueType {
public UInt32 SignatureConstant
public int SizeOfBlockWithoutSignature
public UInt32 Signature
public ushort NumberOfThisDisk
public ushort NumberOfTheDiskWithTheStartOfTheCentralDirectory
public ushort NumberOfEntriesInTheCentralDirectoryOnThisDisk
public ushort NumberOfEntriesInTheCentralDirectory
public UInt32 SizeOfCentralDirectory
public UInt32 OffsetOfStartOfCentralDirectoryWithRespectToTheStartingDiskNumber
public Byte[] ArchiveComment
public void WriteBlock(Stream stream, long numberOfEntries, long startOfCentralDirectory, long sizeOfCentralDirectory, Byte[] archiveComment)
public bool TryReadBlock(BinaryReader reader, ZipEndOfCentralDirectoryBlock& eocdBlock)
}
internal System.IO.Compression.ZipGenericExtraField : ValueType {
private int SizeOfHeader
private ushort _tag
private ushort _size
private Byte[] _data
public ushort Tag
public ushort Size
public Byte[] Data
public ushort get_Tag()
public ushort get_Size()
public Byte[] get_Data()
public void WriteBlock(Stream stream)
public bool TryReadBlock(BinaryReader reader, long endExtraField, ZipGenericExtraField& field)
public List`1<ZipGenericExtraField> ParseExtraField(Stream extraFieldData)
public int TotalSize(List`1<ZipGenericExtraField> fields)
public void WriteAllBlocks(List`1<ZipGenericExtraField> fields, Stream stream)
}
internal System.IO.Compression.ZipHelper : object {
internal UInt32 Mask32Bit
internal ushort Mask16Bit
private int BackwardsSeekingBufferSize
internal int ValidZipDate_YearMin
internal int ValidZipDate_YearMax
private DateTime s_invalidDateIndicator
internal bool RequiresUnicode(string test)
internal void ReadBytes(Stream stream, Byte[] buffer, int bytesToRead)
internal DateTime DosTimeToDateTime(UInt32 dateTime)
internal UInt32 DateTimeToDosTime(DateTime dateTime)
internal bool SeekBackwardsToSignature(Stream stream, UInt32 signatureToFind)
internal void AdvanceToPosition(Stream stream, long position)
private bool SeekBackwardsAndRead(Stream stream, Byte[] buffer, Int32& bufferPointer)
}
internal System.IO.Compression.ZipLocalFileHeader : ValueType {
public UInt32 DataDescriptorSignature
public UInt32 SignatureConstant
public int OffsetToCrcFromHeaderStart
public int OffsetToBitFlagFromHeaderStart
public int SizeOfLocalHeader
public List`1<ZipGenericExtraField> GetExtraFields(BinaryReader reader)
public bool TrySkipBlock(BinaryReader reader)
}
internal System.IO.Compression.ZipVersionMadeByPlatform : Enum {
public byte value__
public ZipVersionMadeByPlatform Windows
public ZipVersionMadeByPlatform Unix
}
internal System.IO.Compression.ZipVersionNeededValues : Enum {
public ushort value__
public ZipVersionNeededValues Default
public ZipVersionNeededValues ExplicitDirectory
public ZipVersionNeededValues Deflate
public ZipVersionNeededValues Deflate64
public ZipVersionNeededValues Zip64
}
internal System.Threading.Tasks.TaskToApm : object {
public IAsyncResult Begin(Task task, AsyncCallback callback, object state)
public void End(IAsyncResult asyncResult)
public TResult End(IAsyncResult asyncResult)
private void InvokeCallbackWhenTaskCompletes(Task antecedent, AsyncCallback callback, IAsyncResult asyncResult)
}
internal Unity.ThrowStub : ObjectDisposedException {
public void ThrowNotSupportedException()
}
