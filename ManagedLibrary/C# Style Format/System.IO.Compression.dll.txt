internal static class Consts : object {
    public static string MonoCorlibVersion;
    public static string MonoVersion;
    public static string MonoCompany;
    public static string MonoProduct;
    public static string MonoCopyright;
    public static string FxVersion;
    public static string FxFileVersion;
    public static string EnvironmentVersion;
    public static string VsVersion;
    public static string VsFileVersion;
    private static string PublicKeyToken;
    public static string AssemblyI18N;
    public static string AssemblyMicrosoft_JScript;
    public static string AssemblyMicrosoft_VisualStudio;
    public static string AssemblyMicrosoft_VisualStudio_Web;
    public static string AssemblyMicrosoft_VSDesigner;
    public static string AssemblyMono_Http;
    public static string AssemblyMono_Posix;
    public static string AssemblyMono_Security;
    public static string AssemblyMono_Messaging_RabbitMQ;
    public static string AssemblyCorlib;
    public static string AssemblySystem;
    public static string AssemblySystem_Data;
    public static string AssemblySystem_Design;
    public static string AssemblySystem_DirectoryServices;
    public static string AssemblySystem_Drawing;
    public static string AssemblySystem_Drawing_Design;
    public static string AssemblySystem_Messaging;
    public static string AssemblySystem_Security;
    public static string AssemblySystem_ServiceProcess;
    public static string AssemblySystem_Web;
    public static string AssemblySystem_Windows_Forms;
    public static string AssemblySystem_2_0;
    public static string AssemblySystemCore_3_5;
    public static string AssemblySystem_Core;
    public static string WindowsBase_3_0;
    public static string AssemblyWindowsBase;
    public static string AssemblyPresentationCore_3_5;
    public static string AssemblyPresentationCore_4_0;
    public static string AssemblyPresentationFramework_3_5;
    public static string AssemblySystemServiceModel_3_0;
}
internal static class Interop : object {
}
internal class Microsoft.Win32.SafeHandles.SafeBrotliDecoderHandle : SafeHandle {
    public bool IsInvalid { get; }
    protected virtual bool ReleaseHandle();
    public virtual bool get_IsInvalid();
}
internal class Microsoft.Win32.SafeHandles.SafeBrotliEncoderHandle : SafeHandle {
    public bool IsInvalid { get; }
    protected virtual bool ReleaseHandle();
    public virtual bool get_IsInvalid();
}
internal static class SR : object {
    public static string ArgumentOutOfRange_Enum;
    public static string ArgumentOutOfRange_NeedPosNum;
    public static string CannotReadFromDeflateStream;
    public static string CannotWriteToDeflateStream;
    public static string GenericInvalidData;
    public static string InvalidArgumentOffsetCount;
    public static string InvalidBeginCall;
    public static string InvalidBlockLength;
    public static string InvalidHuffmanData;
    public static string NotSupported;
    public static string NotSupported_UnreadableStream;
    public static string NotSupported_UnwritableStream;
    public static string ObjectDisposed_StreamClosed;
    public static string UnknownBlockType;
    public static string UnknownState;
    public static string ZLibErrorDLLLoadError;
    public static string ZLibErrorInconsistentStream;
    public static string ZLibErrorIncorrectInitParameters;
    public static string ZLibErrorNotEnoughMemory;
    public static string ZLibErrorVersionMismatch;
    public static string ZLibErrorUnexpected;
    public static string ArgumentNeedNonNegative;
    public static string CannotBeEmpty;
    public static string CDCorrupt;
    public static string CentralDirectoryInvalid;
    public static string CreateInReadMode;
    public static string CreateModeCapabilities;
    public static string CreateModeCreateEntryWhileOpen;
    public static string CreateModeWriteOnceAndOneEntryAtATime;
    public static string DateTimeOutOfRange;
    public static string DeletedEntry;
    public static string DeleteOnlyInUpdate;
    public static string DeleteOpenEntry;
    public static string EntriesInCreateMode;
    public static string EntryNameEncodingNotSupported;
    public static string EntryNamesTooLong;
    public static string EntryTooLarge;
    public static string EOCDNotFound;
    public static string FieldTooBigCompressedSize;
    public static string FieldTooBigLocalHeaderOffset;
    public static string FieldTooBigNumEntries;
    public static string FieldTooBigOffsetToCD;
    public static string FieldTooBigOffsetToZip64EOCD;
    public static string FieldTooBigStartDiskNumber;
    public static string FieldTooBigUncompressedSize;
    public static string FrozenAfterWrite;
    public static string HiddenStreamName;
    public static string LengthAfterWrite;
    public static string LocalFileHeaderCorrupt;
    public static string NumEntriesWrong;
    public static string OffsetLengthInvalid;
    public static string ReadingNotSupported;
    public static string ReadModeCapabilities;
    public static string ReadOnlyArchive;
    public static string SeekingNotSupported;
    public static string SetLengthRequiresSeekingAndWriting;
    public static string SplitSpanned;
    public static string UnexpectedEndOfStream;
    public static string UnsupportedCompression;
    public static string UnsupportedCompressionMethod;
    public static string UpdateModeCapabilities;
    public static string UpdateModeOneStream;
    public static string WritingNotSupported;
    public static string Zip64EOCDNotWhereExpected;
    public static string Argument_InvalidPathChars;
    public static string Stream_FalseCanRead;
    public static string Stream_FalseCanWrite;
    public static string BrotliEncoder_Create;
    public static string BrotliEncoder_Disposed;
    public static string BrotliEncoder_Quality;
    public static string BrotliEncoder_Window;
    public static string BrotliEncoder_InvalidSetParameter;
    public static string BrotliDecoder_Create;
    public static string BrotliDecoder_Error;
    public static string BrotliDecoder_Disposed;
    public static string BrotliStream_Compress_UnsupportedOperation;
    public static string BrotliStream_Compress_InvalidData;
    public static string BrotliStream_Decompress_UnsupportedOperation;
    public static string BrotliStream_Decompress_InvalidData;
    public static string BrotliStream_Decompress_InvalidStream;
    internal static string GetString(string name, Object[] args);
    internal static string GetString(CultureInfo culture, string name, Object[] args);
    internal static string GetString(string name);
    internal static string GetString(CultureInfo culture, string name);
    internal static string Format(string resourceFormat, Object[] args);
    internal static string Format(string resourceFormat, object p1);
    internal static string Format(string resourceFormat, object p1, object p2);
    internal static string Format(CultureInfo ci, string resourceFormat, object p1, object p2);
    internal static string Format(string resourceFormat, object p1, object p2, object p3);
    internal static string GetResourceString(string str);
}
internal enum System.IO.Compression.BlockType : Enum {
    public int value__;
    public static BlockType Uncompressed;
    public static BlockType Static;
    public static BlockType Dynamic;
}
public class System.IO.Compression.BrotliDecoder : ValueType {
    private SafeBrotliDecoderHandle _state;
    private bool _disposed;
    internal void InitializeDecoder();
    internal void EnsureInitialized();
    public sealed virtual void Dispose();
    private void EnsureNotDisposed();
    public OperationStatus Decompress(ReadOnlySpan`1<byte> source, Span`1<byte> destination, Int32& bytesConsumed, Int32& bytesWritten);
    public static bool TryDecompress(ReadOnlySpan`1<byte> source, Span`1<byte> destination, Int32& bytesWritten);
}
public class System.IO.Compression.BrotliEncoder : ValueType {
    internal SafeBrotliEncoderHandle _state;
    private bool _disposed;
    public BrotliEncoder(int quality, int window);
    internal void InitializeEncoder();
    internal void EnsureInitialized();
    public sealed virtual void Dispose();
    private void EnsureNotDisposed();
    internal void SetQuality(int quality);
    internal void SetWindow(int window);
    public static int GetMaxCompressedLength(int length);
    internal OperationStatus Flush(Memory`1<byte> destination, Int32& bytesWritten);
    public OperationStatus Flush(Span`1<byte> destination, Int32& bytesWritten);
    internal OperationStatus Compress(ReadOnlyMemory`1<byte> source, Memory`1<byte> destination, Int32& bytesConsumed, Int32& bytesWritten, bool isFinalBlock);
    public OperationStatus Compress(ReadOnlySpan`1<byte> source, Span`1<byte> destination, Int32& bytesConsumed, Int32& bytesWritten, bool isFinalBlock);
    internal OperationStatus Compress(ReadOnlySpan`1<byte> source, Span`1<byte> destination, Int32& bytesConsumed, Int32& bytesWritten, BrotliEncoderOperation operation);
    public static bool TryCompress(ReadOnlySpan`1<byte> source, Span`1<byte> destination, Int32& bytesWritten);
    public static bool TryCompress(ReadOnlySpan`1<byte> source, Span`1<byte> destination, Int32& bytesWritten, int quality, int window);
}
internal enum System.IO.Compression.BrotliEncoderOperation : Enum {
    public int value__;
    public static BrotliEncoderOperation Process;
    public static BrotliEncoderOperation Flush;
    public static BrotliEncoderOperation Finish;
    public static BrotliEncoderOperation EmitMetadata;
}
internal enum System.IO.Compression.BrotliEncoderParameter : Enum {
    public int value__;
    public static BrotliEncoderParameter Mode;
    public static BrotliEncoderParameter Quality;
    public static BrotliEncoderParameter LGWin;
    public static BrotliEncoderParameter LGBlock;
    public static BrotliEncoderParameter LCModeling;
    public static BrotliEncoderParameter SizeHint;
}
public class System.IO.Compression.BrotliStream : Stream {
    private static int DefaultInternalBufferSize;
    private Stream _stream;
    private Byte[] _buffer;
    private bool _leaveOpen;
    private CompressionMode _mode;
    private int _activeAsyncOperation;
    private BrotliDecoder _decoder;
    private int _bufferOffset;
    private int _bufferCount;
    private BrotliEncoder _encoder;
    public Stream BaseStream { get; }
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public bool CanSeek { get; }
    public long Length { get; }
    public long Position { get; public set; }
    private bool AsyncOperationIsActive { get; }
    public BrotliStream(Stream stream, CompressionMode mode);
    public BrotliStream(Stream stream, CompressionMode mode, bool leaveOpen);
    public BrotliStream(Stream stream, CompressionLevel compressionLevel);
    public BrotliStream(Stream stream, CompressionLevel compressionLevel, bool leaveOpen);
    private void EnsureNotDisposed();
    protected virtual void Dispose(bool disposing);
    private static void ValidateParameters(Byte[] array, int offset, int count);
    public Stream get_BaseStream();
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
    public virtual bool get_CanSeek();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void SetLength(long value);
    private bool get_AsyncOperationIsActive();
    private void EnsureNoActiveAsyncOperation();
    private void AsyncOperationStarting();
    private void AsyncOperationCompleting();
    private static void ThrowInvalidBeginCall();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int Read(Span`1<byte> buffer);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback asyncCallback, object asyncState);
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual ValueTask`1<int> ReadAsync(Memory`1<byte> buffer, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.IO.Compression.BrotliStream/<FinishReadAsyncMemory>d__41")]
private ValueTask`1<int> FinishReadAsyncMemory(Memory`1<byte> buffer, CancellationToken cancellationToken);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void Write(ReadOnlySpan`1<byte> buffer);
    internal void WriteCore(ReadOnlySpan`1<byte> buffer, bool isFinalBlock);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback asyncCallback, object asyncState);
    public virtual void EndWrite(IAsyncResult asyncResult);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual ValueTask WriteAsync(ReadOnlyMemory`1<byte> buffer, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.IO.Compression.BrotliStream/<WriteAsyncMemoryCore>d__52")]
private Task WriteAsyncMemoryCore(ReadOnlyMemory`1<byte> buffer, CancellationToken cancellationToken);
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.IO.Compression.BrotliStream/<FlushAsyncCore>d__55")]
private Task FlushAsyncCore(CancellationToken cancellationToken);
}
internal static class System.IO.Compression.BrotliUtils : object {
    public static int WindowBits_Min;
    public static int WindowBits_Default;
    public static int WindowBits_Max;
    public static int Quality_Min;
    public static int Quality_Default;
    public static int Quality_Max;
    public static int MaxInputSize;
    internal static int GetQualityFromCompressionLevel(CompressionLevel level);
}
internal class System.IO.Compression.CheckSumAndSizeWriteStream : Stream {
    private Stream _baseStream;
    private Stream _baseBaseStream;
    private long _position;
    private UInt32 _checksum;
    private bool _leaveOpenOnClose;
    private bool _canWrite;
    private bool _isDisposed;
    private bool _everWritten;
    private long _initialPosition;
    private ZipArchiveEntry _zipArchiveEntry;
    private EventHandler _onClose;
    private Action`6<long, long, UInt32, Stream, ZipArchiveEntry, EventHandler> _saveCrcAndSizes;
    public long Length { get; }
    public long Position { get; public set; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public CheckSumAndSizeWriteStream(Stream baseStream, Stream baseBaseStream, bool leaveOpenOnClose, ZipArchiveEntry entry, EventHandler onClose, Action`6<long, long, UInt32, Stream, ZipArchiveEntry, EventHandler> saveCrcAndSizes);
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    private void ThrowIfDisposed();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void Flush();
    protected virtual void Dispose(bool disposing);
}
internal class System.IO.Compression.CopyEncoder : object {
    private static int PaddingSize;
    private static int MaxUncompressedBlockSize;
    public void GetBlock(DeflateInput input, OutputBuffer output, bool isFinal);
    private void WriteLenNLen(ushort len, OutputBuffer output);
}
internal static class System.IO.Compression.Crc32Helper : object {
    private static UInt32[] s_crcTable_0;
    private static UInt32[] s_crcTable_1;
    private static UInt32[] s_crcTable_2;
    private static UInt32[] s_crcTable_3;
    private static UInt32[] s_crcTable_4;
    private static UInt32[] s_crcTable_5;
    private static UInt32[] s_crcTable_6;
    private static UInt32[] s_crcTable_7;
    private static Crc32Helper();
    public static UInt32 UpdateCrc32(UInt32 crc32, Byte[] buffer, int offset, int length);
    private static UInt32 ManagedCrc32(UInt32 crc32, Byte[] buffer, int offset, int length);
}
internal class System.IO.Compression.DeflateInput : object {
    [CompilerGeneratedAttribute]
private Byte[] <Buffer>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Count>k__BackingField;
    [CompilerGeneratedAttribute]
private int <StartIndex>k__BackingField;
    internal Byte[] Buffer { get; internal set; }
    internal int Count { get; internal set; }
    internal int StartIndex { get; internal set; }
    [CompilerGeneratedAttribute]
internal Byte[] get_Buffer();
    [CompilerGeneratedAttribute]
internal void set_Buffer(Byte[] value);
    [CompilerGeneratedAttribute]
internal int get_Count();
    [CompilerGeneratedAttribute]
internal void set_Count(int value);
    [CompilerGeneratedAttribute]
internal int get_StartIndex();
    [CompilerGeneratedAttribute]
internal void set_StartIndex(int value);
    internal void ConsumeBytes(int n);
    internal InputState DumpState();
    internal void RestoreState(InputState state);
}
internal class System.IO.Compression.DeflateManagedStream : Stream {
    internal static int DefaultBufferSize;
    private Stream _stream;
    private CompressionMode _mode;
    private bool _leaveOpen;
    private InflaterManaged _inflater;
    private DeflaterManaged _deflater;
    private Byte[] _buffer;
    private int _asyncOperations;
    private IFileFormatWriter _formatWriter;
    private bool _wroteHeader;
    private bool _wroteBytes;
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public bool CanSeek { get; }
    public long Length { get; }
    public long Position { get; public set; }
    internal DeflateManagedStream(Stream stream, CompressionMethodValues method);
    internal void InitializeInflater(Stream stream, bool leaveOpen, IFileFormatReader reader, CompressionMethodValues method);
    internal void SetFileFormatWriter(IFileFormatWriter writer);
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
    public virtual bool get_CanSeek();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual int Read(Byte[] array, int offset, int count);
    private void ValidateParameters(Byte[] array, int offset, int count);
    private void EnsureNotDisposed();
    private static void ThrowStreamClosedException();
    private void EnsureDecompressionMode();
    private static void ThrowCannotReadFromDeflateManagedStreamException();
    private void EnsureCompressionMode();
    private static void ThrowCannotWriteToDeflateManagedStreamException();
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback asyncCallback, object asyncState);
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual Task`1<int> ReadAsync(Byte[] array, int offset, int count, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.IO.Compression.DeflateManagedStream/<ReadAsyncCore>d__40")]
private Task`1<int> ReadAsyncCore(Task`1<int> readTask, Byte[] array, int offset, int count, CancellationToken cancellationToken);
    public virtual void Write(Byte[] array, int offset, int count);
    private void WriteDeflaterOutput();
    private void DoMaintenance(Byte[] array, int offset, int count);
    private void PurgeBuffers(bool disposing);
    protected virtual void Dispose(bool disposing);
    public virtual Task WriteAsync(Byte[] array, int offset, int count, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.IO.Compression.DeflateManagedStream/<WriteAsyncCore>d__47")]
private Task WriteAsyncCore(Byte[] array, int offset, int count, CancellationToken cancellationToken);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback asyncCallback, object asyncState);
    public virtual void EndWrite(IAsyncResult asyncResult);
    [DebuggerHiddenAttribute]
[CompilerGeneratedAttribute]
private Task <>n__0(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
}
internal class System.IO.Compression.DeflaterManaged : object {
    private static int MinBlockSize;
    private static int MaxHeaderFooterGoo;
    private static int CleanCopySize;
    private static double BadCompressionThreshold;
    private FastEncoder _deflateEncoder;
    private CopyEncoder _copyEncoder;
    private DeflateInput _input;
    private OutputBuffer _output;
    private DeflaterState _processingState;
    private DeflateInput _inputFromHistory;
    internal bool NeedsInput();
    internal void SetInput(Byte[] inputBuffer, int startIndex, int count);
    internal int GetDeflateOutput(Byte[] outputBuffer);
    internal bool Finish(Byte[] outputBuffer, Int32& bytesRead);
    private bool UseCompressed(double ratio);
    private void FlushInputWindows();
    private void WriteFinal();
    public sealed virtual void Dispose();
}
internal class System.IO.Compression.FastEncoder : object {
    private FastEncoderWindow _inputWindow;
    private Match _currentMatch;
    private double _lastCompressionRatio;
    internal int BytesInHistory { get; }
    internal DeflateInput UnprocessedInput { get; }
    internal double LastCompressionRatio { get; }
    internal int get_BytesInHistory();
    internal DeflateInput get_UnprocessedInput();
    internal void FlushInput();
    internal double get_LastCompressionRatio();
    internal void GetBlock(DeflateInput input, OutputBuffer output, int maxBytesToCopy);
    internal void GetCompressedData(DeflateInput input, OutputBuffer output);
    internal void GetBlockHeader(OutputBuffer output);
    internal void GetBlockFooter(OutputBuffer output);
    private void GetCompressedOutput(DeflateInput input, OutputBuffer output, int maxBytesToCopy);
    private void GetCompressedOutput(OutputBuffer output);
    private bool InputAvailable(DeflateInput input);
    private bool SafeToWriteTo(OutputBuffer output);
    private void WriteEndOfBlock(OutputBuffer output);
    internal static void WriteMatch(int matchLen, int matchPos, OutputBuffer output);
    internal static void WriteChar(byte b, OutputBuffer output);
    internal static void WriteDeflatePreamble(OutputBuffer output);
}
internal static class System.IO.Compression.FastEncoderStatics : object {
    internal static Byte[] FastEncoderTreeStructureData;
    internal static Byte[] BFinalFastEncoderTreeStructureData;
    internal static UInt32[] FastEncoderLiteralCodeInfo;
    internal static UInt32[] FastEncoderDistanceCodeInfo;
    internal static UInt32[] BitMask;
    internal static Byte[] ExtraLengthBits;
    internal static Byte[] ExtraDistanceBits;
    internal static int NumChars;
    internal static int NumLengthBaseCodes;
    internal static int NumDistBaseCodes;
    internal static UInt32 FastEncoderPostTreeBitBuf;
    internal static int FastEncoderPostTreeBitCount;
    internal static UInt32 NoCompressionHeader;
    internal static int NoCompressionHeaderBitCount;
    internal static UInt32 BFinalNoCompressionHeader;
    internal static int BFinalNoCompressionHeaderBitCount;
    internal static int MaxCodeLen;
    private static Byte[] s_distLookup;
    private static FastEncoderStatics();
    private static Byte[] CreateDistanceLookup();
    internal static int GetSlot(int pos);
    public static UInt32 BitReverse(UInt32 code, int length);
}
internal class System.IO.Compression.FastEncoderWindow : object {
    private Byte[] _window;
    private int _bufPos;
    private int _bufEnd;
    private static int FastEncoderHashShift;
    private static int FastEncoderHashtableSize;
    private static int FastEncoderHashMask;
    private static int FastEncoderWindowSize;
    private static int FastEncoderWindowMask;
    private static int FastEncoderMatch3DistThreshold;
    internal static int MaxMatch;
    internal static int MinMatch;
    private static int SearchDepth;
    private static int GoodLength;
    private static int NiceLength;
    private static int LazyMatchThreshold;
    private UInt16[] _prev;
    private UInt16[] _lookup;
    public int BytesAvailable { get; }
    public DeflateInput UnprocessedInput { get; }
    public int FreeWindowSpace { get; }
    public int get_BytesAvailable();
    public DeflateInput get_UnprocessedInput();
    public void FlushWindow();
    private void ResetWindow();
    public int get_FreeWindowSpace();
    public void CopyBytes(Byte[] inputBuffer, int startIndex, int count);
    public void MoveWindows();
    private UInt32 HashValue(UInt32 hash, byte b);
    private UInt32 InsertString(UInt32& hash);
    private void InsertStrings(UInt32& hash, int matchLen);
    internal bool GetNextSymbolOrMatch(Match match);
    private int FindMatch(int search, Int32& matchPos, int searchDepth, int niceLength);
    [ConditionalAttribute("DEBUG")]
private void DebugAssertVerifyHashes();
    [ConditionalAttribute("DEBUG")]
private void DebugAssertRecalculatedHashesAreEqual(int position1, int position2, string message);
}
internal class System.IO.Compression.HuffmanTree : object {
    internal static int MaxLiteralTreeElements;
    internal static int MaxDistTreeElements;
    internal static int EndOfBlockCode;
    internal static int NumberOfCodeLengthTreeElements;
    private int _tableBits;
    private Int16[] _table;
    private Int16[] _left;
    private Int16[] _right;
    private Byte[] _codeLengthArray;
    private int _tableMask;
    [CompilerGeneratedAttribute]
private static HuffmanTree <StaticLiteralLengthTree>k__BackingField;
    [CompilerGeneratedAttribute]
private static HuffmanTree <StaticDistanceTree>k__BackingField;
    public static HuffmanTree StaticLiteralLengthTree { get; }
    public static HuffmanTree StaticDistanceTree { get; }
    public HuffmanTree(Byte[] codeLengths);
    private static HuffmanTree();
    [CompilerGeneratedAttribute]
public static HuffmanTree get_StaticLiteralLengthTree();
    [CompilerGeneratedAttribute]
public static HuffmanTree get_StaticDistanceTree();
    private static Byte[] GetStaticLiteralTreeLength();
    private static Byte[] GetStaticDistanceTreeLength();
    private UInt32[] CalculateHuffmanCode();
    private void CreateTable();
    public int GetNextSymbol(InputBuffer input);
}
internal interface System.IO.Compression.IFileFormatReader {
    public abstract virtual bool ReadHeader(InputBuffer input);
    public abstract virtual bool ReadFooter(InputBuffer input);
    public abstract virtual void UpdateWithBytesRead(Byte[] buffer, int offset, int bytesToCopy);
    public abstract virtual void Validate();
}
internal interface System.IO.Compression.IFileFormatWriter {
    public abstract virtual Byte[] GetHeader();
    public abstract virtual void UpdateWithBytesRead(Byte[] buffer, int offset, int bytesToCopy);
    public abstract virtual Byte[] GetFooter();
}
internal class System.IO.Compression.InflaterManaged : object {
    private static Byte[] s_extraLengthBits;
    private static Int32[] s_lengthBase;
    private static Int32[] s_distanceBasePosition;
    private static Byte[] s_codeOrder;
    private static Byte[] s_staticDistanceTreeTable;
    private OutputWindow _output;
    private InputBuffer _input;
    private HuffmanTree _literalLengthTree;
    private HuffmanTree _distanceTree;
    private InflaterState _state;
    private bool _hasFormatReader;
    private int _bfinal;
    private BlockType _blockType;
    private Byte[] _blockLengthBuffer;
    private int _blockLength;
    private int _length;
    private int _distanceCode;
    private int _extraBits;
    private int _loopCounter;
    private int _literalLengthCodeCount;
    private int _distanceCodeCount;
    private int _codeLengthCodeCount;
    private int _codeArraySize;
    private int _lengthCode;
    private Byte[] _codeList;
    private Byte[] _codeLengthTreeCodeLength;
    private bool _deflate64;
    private HuffmanTree _codeLengthTree;
    private IFileFormatReader _formatReader;
    public int AvailableOutput { get; }
    internal InflaterManaged(IFileFormatReader reader, bool deflate64);
    private static InflaterManaged();
    private void Reset();
    public void SetInput(Byte[] inputBytes, int offset, int length);
    public bool Finished();
    public int get_AvailableOutput();
    public int Inflate(Byte[] bytes, int offset, int length);
    private bool Decode();
    private bool DecodeUncompressedBlock(Boolean& end_of_block);
    private bool DecodeBlock(Boolean& end_of_block_code_seen);
    private bool DecodeDynamicBlockHeader();
    public void Dispose();
}
internal enum System.IO.Compression.InflaterState : Enum {
    public int value__;
    public static InflaterState ReadingHeader;
    public static InflaterState ReadingBFinal;
    public static InflaterState ReadingBType;
    public static InflaterState ReadingNumLitCodes;
    public static InflaterState ReadingNumDistCodes;
    public static InflaterState ReadingNumCodeLengthCodes;
    public static InflaterState ReadingCodeLengthCodes;
    public static InflaterState ReadingTreeCodesBefore;
    public static InflaterState ReadingTreeCodesAfter;
    public static InflaterState DecodeTop;
    public static InflaterState HaveInitialLength;
    public static InflaterState HaveFullLength;
    public static InflaterState HaveDistCode;
    public static InflaterState UncompressedAligning;
    public static InflaterState UncompressedByte1;
    public static InflaterState UncompressedByte2;
    public static InflaterState UncompressedByte3;
    public static InflaterState UncompressedByte4;
    public static InflaterState DecodingUncompressed;
    public static InflaterState StartReadingFooter;
    public static InflaterState ReadingFooter;
    public static InflaterState VerifyingFooter;
    public static InflaterState Done;
}
internal class System.IO.Compression.InputBuffer : object {
    private Byte[] _buffer;
    private int _start;
    private int _end;
    private UInt32 _bitBuffer;
    private int _bitsInBuffer;
    public int AvailableBits { get; }
    public int AvailableBytes { get; }
    public int get_AvailableBits();
    public int get_AvailableBytes();
    public bool EnsureBitsAvailable(int count);
    public UInt32 TryLoad16Bits();
    private UInt32 GetBitMask(int count);
    public int GetBits(int count);
    public int CopyTo(Byte[] output, int offset, int length);
    public bool NeedsInput();
    public void SetInput(Byte[] buffer, int offset, int length);
    public void SkipBits(int n);
    public void SkipToByteBoundary();
}
internal class System.IO.Compression.Match : object {
    [CompilerGeneratedAttribute]
private MatchState <State>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Position>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Length>k__BackingField;
    [CompilerGeneratedAttribute]
private byte <Symbol>k__BackingField;
    internal MatchState State { get; internal set; }
    internal int Position { get; internal set; }
    internal int Length { get; internal set; }
    internal byte Symbol { get; internal set; }
    [CompilerGeneratedAttribute]
internal MatchState get_State();
    [CompilerGeneratedAttribute]
internal void set_State(MatchState value);
    [CompilerGeneratedAttribute]
internal int get_Position();
    [CompilerGeneratedAttribute]
internal void set_Position(int value);
    [CompilerGeneratedAttribute]
internal int get_Length();
    [CompilerGeneratedAttribute]
internal void set_Length(int value);
    [CompilerGeneratedAttribute]
internal byte get_Symbol();
    [CompilerGeneratedAttribute]
internal void set_Symbol(byte value);
}
internal enum System.IO.Compression.MatchState : Enum {
    public int value__;
    public static MatchState HasSymbol;
    public static MatchState HasMatch;
    public static MatchState HasSymbolAndMatch;
}
internal class System.IO.Compression.OutputBuffer : object {
    private Byte[] _byteBuffer;
    private int _pos;
    private UInt32 _bitBuf;
    private int _bitCount;
    internal int BytesWritten { get; }
    internal int FreeBytes { get; }
    internal int BitsInBuffer { get; }
    internal void UpdateBuffer(Byte[] output);
    internal int get_BytesWritten();
    internal int get_FreeBytes();
    internal void WriteUInt16(ushort value);
    internal void WriteBits(int n, UInt32 bits);
    internal void FlushBits();
    internal void WriteBytes(Byte[] byteArray, int offset, int count);
    private void WriteBytesUnaligned(Byte[] byteArray, int offset, int count);
    private void WriteByteUnaligned(byte b);
    internal int get_BitsInBuffer();
    internal BufferState DumpState();
    internal void RestoreState(BufferState state);
}
internal class System.IO.Compression.OutputWindow : object {
    private static int WindowSize;
    private static int WindowMask;
    private Byte[] _window;
    private int _end;
    private int _bytesUsed;
    public int FreeBytes { get; }
    public int AvailableBytes { get; }
    public void Write(byte b);
    public void WriteLengthDistance(int length, int distance);
    public int CopyFrom(InputBuffer input, int length);
    public int get_FreeBytes();
    public int get_AvailableBytes();
    public int CopyTo(Byte[] output, int offset, int length);
}
internal class System.IO.Compression.PositionPreservingWriteOnlyStreamWrapper : Stream {
    private Stream _stream;
    private long _position;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Position { get; public set; }
    public bool CanTimeout { get; }
    public int ReadTimeout { get; public set; }
    public int WriteTimeout { get; public set; }
    public long Length { get; }
    public PositionPreservingWriteOnlyStreamWrapper(Stream stream);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual void EndWrite(IAsyncResult asyncResult);
    public virtual void WriteByte(byte value);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual bool get_CanTimeout();
    public virtual int get_ReadTimeout();
    public virtual void set_ReadTimeout(int value);
    public virtual int get_WriteTimeout();
    public virtual void set_WriteTimeout(int value);
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual void Close();
    protected virtual void Dispose(bool disposing);
    public virtual long get_Length();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
}
internal class System.IO.Compression.SubReadStream : Stream {
    private long _startInSuperStream;
    private long _positionInSuperStream;
    private long _endInSuperStream;
    private Stream _superStream;
    private bool _canRead;
    private bool _isDisposed;
    public long Length { get; }
    public long Position { get; public set; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public SubReadStream(Stream superStream, long startPosition, long maxLength);
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    private void ThrowIfDisposed();
    private void ThrowIfCantRead();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void Flush();
    protected virtual void Dispose(bool disposing);
}
internal class System.IO.Compression.WrappedStream : Stream {
    private Stream _baseStream;
    private bool _closeBaseStream;
    private Action`1<ZipArchiveEntry> _onClosed;
    private ZipArchiveEntry _zipArchiveEntry;
    private bool _isDisposed;
    public long Length { get; }
    public long Position { get; public set; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    internal WrappedStream(Stream baseStream, bool closeBaseStream);
    private WrappedStream(Stream baseStream, bool closeBaseStream, ZipArchiveEntry entry, Action`1<ZipArchiveEntry> onClosed);
    internal WrappedStream(Stream baseStream, ZipArchiveEntry entry, Action`1<ZipArchiveEntry> onClosed);
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    private void ThrowIfDisposed();
    private void ThrowIfCantRead();
    private void ThrowIfCantWrite();
    private void ThrowIfCantSeek();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void Flush();
    protected virtual void Dispose(bool disposing);
}
internal class System.IO.Compression.Zip64EndOfCentralDirectoryLocator : ValueType {
    public static UInt32 SignatureConstant;
    public static int SizeOfBlockWithoutSignature;
    public UInt32 NumberOfDiskWithZip64EOCD;
    public ulong OffsetOfZip64EOCD;
    public UInt32 TotalNumberOfDisks;
    public static bool TryReadBlock(BinaryReader reader, Zip64EndOfCentralDirectoryLocator& zip64EOCDLocator);
    public static void WriteBlock(Stream stream, long zip64EOCDRecordStart);
}
internal class System.IO.Compression.Zip64EndOfCentralDirectoryRecord : ValueType {
    private static UInt32 SignatureConstant;
    private static ulong NormalSize;
    public ulong SizeOfThisRecord;
    public ushort VersionMadeBy;
    public ushort VersionNeededToExtract;
    public UInt32 NumberOfThisDisk;
    public UInt32 NumberOfDiskWithStartOfCD;
    public ulong NumberOfEntriesOnThisDisk;
    public ulong NumberOfEntriesTotal;
    public ulong SizeOfCentralDirectory;
    public ulong OffsetOfCentralDirectory;
    public static bool TryReadBlock(BinaryReader reader, Zip64EndOfCentralDirectoryRecord& zip64EOCDRecord);
    public static void WriteBlock(Stream stream, long numberOfEntries, long startOfCentralDirectory, long sizeOfCentralDirectory);
}
internal class System.IO.Compression.Zip64ExtraField : ValueType {
    public static int OffsetToFirstField;
    private static ushort TagConstant;
    private ushort _size;
    private Nullable`1<long> _uncompressedSize;
    private Nullable`1<long> _compressedSize;
    private Nullable`1<long> _localHeaderOffset;
    private Nullable`1<int> _startDiskNumber;
    public ushort TotalSize { get; }
    public Nullable`1<long> UncompressedSize { get; public set; }
    public Nullable`1<long> CompressedSize { get; public set; }
    public Nullable`1<long> LocalHeaderOffset { get; public set; }
    public Nullable`1<int> StartDiskNumber { get; }
    public ushort get_TotalSize();
    public Nullable`1<long> get_UncompressedSize();
    public void set_UncompressedSize(Nullable`1<long> value);
    public Nullable`1<long> get_CompressedSize();
    public void set_CompressedSize(Nullable`1<long> value);
    public Nullable`1<long> get_LocalHeaderOffset();
    public void set_LocalHeaderOffset(Nullable`1<long> value);
    public Nullable`1<int> get_StartDiskNumber();
    private void UpdateSize();
    public static Zip64ExtraField GetJustZip64Block(Stream extraFieldStream, bool readUncompressedSize, bool readCompressedSize, bool readLocalHeaderOffset, bool readStartDiskNumber);
    private static bool TryGetZip64BlockFromGenericExtraField(ZipGenericExtraField extraField, bool readUncompressedSize, bool readCompressedSize, bool readLocalHeaderOffset, bool readStartDiskNumber, Zip64ExtraField& zip64Block);
    public static Zip64ExtraField GetAndRemoveZip64Block(List`1<ZipGenericExtraField> extraFields, bool readUncompressedSize, bool readCompressedSize, bool readLocalHeaderOffset, bool readStartDiskNumber);
    public static void RemoveZip64Blocks(List`1<ZipGenericExtraField> extraFields);
    public void WriteBlock(Stream stream);
}
public class System.IO.Compression.ZipArchive : object {
    private Stream _archiveStream;
    private ZipArchiveEntry _archiveStreamOwner;
    private BinaryReader _archiveReader;
    private ZipArchiveMode _mode;
    private List`1<ZipArchiveEntry> _entries;
    private ReadOnlyCollection`1<ZipArchiveEntry> _entriesCollection;
    private Dictionary`2<string, ZipArchiveEntry> _entriesDictionary;
    private bool _readEntries;
    private bool _leaveOpen;
    private long _centralDirectoryStart;
    private bool _isDisposed;
    private UInt32 _numberOfThisDisk;
    private long _expectedNumberOfEntries;
    private Stream _backingStream;
    private Byte[] _archiveComment;
    private Encoding _entryNameEncoding;
    public ReadOnlyCollection`1<ZipArchiveEntry> Entries { get; }
    public ZipArchiveMode Mode { get; }
    internal BinaryReader ArchiveReader { get; }
    internal Stream ArchiveStream { get; }
    internal UInt32 NumberOfThisDisk { get; }
    internal Encoding EntryNameEncoding { get; private set; }
    public ZipArchive(Stream stream);
    public ZipArchive(Stream stream, ZipArchiveMode mode);
    public ZipArchive(Stream stream, ZipArchiveMode mode, bool leaveOpen);
    public ZipArchive(Stream stream, ZipArchiveMode mode, bool leaveOpen, Encoding entryNameEncoding);
    public ReadOnlyCollection`1<ZipArchiveEntry> get_Entries();
    public ZipArchiveMode get_Mode();
    public ZipArchiveEntry CreateEntry(string entryName);
    public ZipArchiveEntry CreateEntry(string entryName, CompressionLevel compressionLevel);
    protected virtual void Dispose(bool disposing);
    public sealed virtual void Dispose();
    public ZipArchiveEntry GetEntry(string entryName);
    internal BinaryReader get_ArchiveReader();
    internal Stream get_ArchiveStream();
    internal UInt32 get_NumberOfThisDisk();
    internal Encoding get_EntryNameEncoding();
    private void set_EntryNameEncoding(Encoding value);
    private ZipArchiveEntry DoCreateEntry(string entryName, Nullable`1<CompressionLevel> compressionLevel);
    internal void AcquireArchiveStream(ZipArchiveEntry entry);
    private void AddEntry(ZipArchiveEntry entry);
    [ConditionalAttribute("DEBUG")]
internal void DebugAssertIsStillArchiveStreamOwner(ZipArchiveEntry entry);
    internal void ReleaseArchiveStream(ZipArchiveEntry entry);
    internal void RemoveEntry(ZipArchiveEntry entry);
    internal void ThrowIfDisposed();
    private void CloseStreams();
    private void EnsureCentralDirectoryRead();
    private void Init(Stream stream, ZipArchiveMode mode, bool leaveOpen);
    private void ReadCentralDirectory();
    private void ReadEndOfCentralDirectory();
    private void WriteFile();
    private void WriteArchiveEpilogue(long startOfCentralDirectory, long sizeOfCentralDirectory);
}
public class System.IO.Compression.ZipArchiveEntry : object {
    private static ushort DefaultVersionToExtract;
    private static int MaxSingleBufferSize;
    private ZipArchive _archive;
    private bool _originallyInArchive;
    private int _diskNumberStart;
    private ZipVersionMadeByPlatform _versionMadeByPlatform;
    private ZipVersionNeededValues _versionMadeBySpecification;
    private ZipVersionNeededValues _versionToExtract;
    private BitFlagValues _generalPurposeBitFlag;
    private CompressionMethodValues _storedCompressionMethod;
    private DateTimeOffset _lastModified;
    private long _compressedSize;
    private long _uncompressedSize;
    private long _offsetOfLocalHeader;
    private Nullable`1<long> _storedOffsetOfCompressedData;
    private UInt32 _crc32;
    private Byte[][] _compressedBytes;
    private MemoryStream _storedUncompressedData;
    private bool _currentlyOpenForWrite;
    private bool _everOpenedForWrite;
    private Stream _outstandingWriteStream;
    private UInt32 _externalFileAttr;
    private string _storedEntryName;
    private Byte[] _storedEntryNameBytes;
    private List`1<ZipGenericExtraField> _cdUnknownExtraFields;
    private List`1<ZipGenericExtraField> _lhUnknownExtraFields;
    private Byte[] _fileComment;
    private Nullable`1<CompressionLevel> _compressionLevel;
    private static bool s_allowLargeZipArchiveEntriesInUpdateMode;
    internal static ZipVersionMadeByPlatform CurrentZipPlatform;
    public ZipArchive Archive { get; }
    [CLSCompliantAttribute("False")]
public UInt32 Crc32 { get; }
    public long CompressedLength { get; }
    public int ExternalAttributes { get; public set; }
    public string FullName { get; private set; }
    public DateTimeOffset LastWriteTime { get; public set; }
    public long Length { get; }
    public string Name { get; }
    internal bool EverOpenedForWrite { get; }
    private long OffsetOfCompressedData { get; }
    private MemoryStream UncompressedData { get; }
    private CompressionMethodValues CompressionMethod { get; private set; }
    internal ZipArchiveEntry(ZipArchive archive, ZipCentralDirectoryFileHeader cd);
    internal ZipArchiveEntry(ZipArchive archive, string entryName, CompressionLevel compressionLevel);
    internal ZipArchiveEntry(ZipArchive archive, string entryName);
    private static ZipArchiveEntry();
    public ZipArchive get_Archive();
    public UInt32 get_Crc32();
    public long get_CompressedLength();
    public int get_ExternalAttributes();
    public void set_ExternalAttributes(int value);
    public string get_FullName();
    private void set_FullName(string value);
    public DateTimeOffset get_LastWriteTime();
    public void set_LastWriteTime(DateTimeOffset value);
    public long get_Length();
    public string get_Name();
    public void Delete();
    public Stream Open();
    public virtual string ToString();
    internal bool get_EverOpenedForWrite();
    private long get_OffsetOfCompressedData();
    private MemoryStream get_UncompressedData();
    private CompressionMethodValues get_CompressionMethod();
    private void set_CompressionMethod(CompressionMethodValues value);
    private string DecodeEntryName(Byte[] entryNameBytes);
    private Byte[] EncodeEntryName(string entryName, Boolean& isUTF8);
    internal void WriteAndFinishLocalEntry();
    internal void WriteCentralDirectoryFileHeader();
    internal bool LoadLocalHeaderExtraFieldAndCompressedBytesIfNeeded();
    internal void ThrowIfNotOpenable(bool needToUncompress, bool needToLoadIntoMemory);
    private CheckSumAndSizeWriteStream GetDataCompressor(Stream backingStream, bool leaveBackingStreamOpen, EventHandler onClose);
    private Stream GetDataDecompressor(Stream compressedStreamToRead);
    private Stream OpenInReadMode(bool checkOpenable);
    private Stream OpenInWriteMode();
    private Stream OpenInUpdateMode();
    private bool IsOpenable(bool needToUncompress, bool needToLoadIntoMemory, String& message);
    private bool SizesTooLarge();
    private bool WriteLocalFileHeader(bool isEmptyFile);
    private void WriteLocalFileHeaderAndDataIfNeeded();
    private void WriteCrcAndSizesInLocalHeader(bool zip64HeaderUsed);
    private void WriteDataDescriptor();
    private void UnloadStreams();
    private void CloseStreams();
    private void VersionToExtractAtLeast(ZipVersionNeededValues value);
    private void ThrowIfInvalidArchive();
    private static string GetFileName_Windows(string path);
    private static string GetFileName_Unix(string path);
    internal static string ParseFileName(string path, ZipVersionMadeByPlatform madeByPlatform);
}
public enum System.IO.Compression.ZipArchiveMode : Enum {
    public int value__;
    public static ZipArchiveMode Read;
    public static ZipArchiveMode Create;
    public static ZipArchiveMode Update;
}
internal class System.IO.Compression.ZipCentralDirectoryFileHeader : ValueType {
    public static UInt32 SignatureConstant;
    public byte VersionMadeByCompatibility;
    public byte VersionMadeBySpecification;
    public ushort VersionNeededToExtract;
    public ushort GeneralPurposeBitFlag;
    public ushort CompressionMethod;
    public UInt32 LastModified;
    public UInt32 Crc32;
    public long CompressedSize;
    public long UncompressedSize;
    public ushort FilenameLength;
    public ushort ExtraFieldLength;
    public ushort FileCommentLength;
    public int DiskNumberStart;
    public ushort InternalFileAttributes;
    public UInt32 ExternalFileAttributes;
    public long RelativeOffsetOfLocalHeader;
    public Byte[] Filename;
    public Byte[] FileComment;
    public List`1<ZipGenericExtraField> ExtraFields;
    public static bool TryReadBlock(BinaryReader reader, bool saveExtraFieldsAndComments, ZipCentralDirectoryFileHeader& header);
}
internal class System.IO.Compression.ZipEndOfCentralDirectoryBlock : ValueType {
    public static UInt32 SignatureConstant;
    public static int SizeOfBlockWithoutSignature;
    public UInt32 Signature;
    public ushort NumberOfThisDisk;
    public ushort NumberOfTheDiskWithTheStartOfTheCentralDirectory;
    public ushort NumberOfEntriesInTheCentralDirectoryOnThisDisk;
    public ushort NumberOfEntriesInTheCentralDirectory;
    public UInt32 SizeOfCentralDirectory;
    public UInt32 OffsetOfStartOfCentralDirectoryWithRespectToTheStartingDiskNumber;
    public Byte[] ArchiveComment;
    public static void WriteBlock(Stream stream, long numberOfEntries, long startOfCentralDirectory, long sizeOfCentralDirectory, Byte[] archiveComment);
    public static bool TryReadBlock(BinaryReader reader, ZipEndOfCentralDirectoryBlock& eocdBlock);
}
internal class System.IO.Compression.ZipGenericExtraField : ValueType {
    private static int SizeOfHeader;
    private ushort _tag;
    private ushort _size;
    private Byte[] _data;
    public ushort Tag { get; }
    public ushort Size { get; }
    public Byte[] Data { get; }
    public ushort get_Tag();
    public ushort get_Size();
    public Byte[] get_Data();
    public void WriteBlock(Stream stream);
    public static bool TryReadBlock(BinaryReader reader, long endExtraField, ZipGenericExtraField& field);
    public static List`1<ZipGenericExtraField> ParseExtraField(Stream extraFieldData);
    public static int TotalSize(List`1<ZipGenericExtraField> fields);
    public static void WriteAllBlocks(List`1<ZipGenericExtraField> fields, Stream stream);
}
[ExtensionAttribute]
internal static class System.IO.Compression.ZipHelper : object {
    internal static UInt32 Mask32Bit;
    internal static ushort Mask16Bit;
    private static int BackwardsSeekingBufferSize;
    internal static int ValidZipDate_YearMin;
    internal static int ValidZipDate_YearMax;
    private static DateTime s_invalidDateIndicator;
    private static ZipHelper();
    internal static bool RequiresUnicode(string test);
    internal static void ReadBytes(Stream stream, Byte[] buffer, int bytesToRead);
    internal static DateTime DosTimeToDateTime(UInt32 dateTime);
    internal static UInt32 DateTimeToDosTime(DateTime dateTime);
    internal static bool SeekBackwardsToSignature(Stream stream, UInt32 signatureToFind);
    [ExtensionAttribute]
internal static void AdvanceToPosition(Stream stream, long position);
    private static bool SeekBackwardsAndRead(Stream stream, Byte[] buffer, Int32& bufferPointer);
}
[IsReadOnlyAttribute]
internal class System.IO.Compression.ZipLocalFileHeader : ValueType {
    public static UInt32 DataDescriptorSignature;
    public static UInt32 SignatureConstant;
    public static int OffsetToCrcFromHeaderStart;
    public static int OffsetToBitFlagFromHeaderStart;
    public static int SizeOfLocalHeader;
    public static List`1<ZipGenericExtraField> GetExtraFields(BinaryReader reader);
    public static bool TrySkipBlock(BinaryReader reader);
}
internal enum System.IO.Compression.ZipVersionMadeByPlatform : Enum {
    public byte value__;
    public static ZipVersionMadeByPlatform Windows;
    public static ZipVersionMadeByPlatform Unix;
}
internal enum System.IO.Compression.ZipVersionNeededValues : Enum {
    public ushort value__;
    public static ZipVersionNeededValues Default;
    public static ZipVersionNeededValues ExplicitDirectory;
    public static ZipVersionNeededValues Deflate;
    public static ZipVersionNeededValues Deflate64;
    public static ZipVersionNeededValues Zip64;
}
internal class System.Runtime.CompilerServices.FriendAccessAllowedAttribute : Attribute {
}
internal static class System.Threading.Tasks.TaskToApm : object {
    public static IAsyncResult Begin(Task task, AsyncCallback callback, object state);
    public static void End(IAsyncResult asyncResult);
    public static TResult End(IAsyncResult asyncResult);
    private static void InvokeCallbackWhenTaskCompletes(Task antecedent, AsyncCallback callback, IAsyncResult asyncResult);
}
internal class Unity.ThrowStub : ObjectDisposedException {
    public static void ThrowNotSupportedException();
}
