public Azure.AsyncPageable`1 : object {
private CancellationToken <CancellationToken>k__BackingField
protected CancellationToken CancellationToken
protected CancellationToken get_CancellationToken()
protected void .ctor(CancellationToken cancellationToken)
public IAsyncEnumerable`1<Page`1<T>> AsPages(string continuationToken, Nullable`1<int> pageSizeHint)
public IAsyncEnumerator`1<T> GetAsyncEnumerator(CancellationToken cancellationToken)
public AsyncPageable`1<T> FromPages(IEnumerable`1<Page`1<T>> pages)
public string ToString()
public bool Equals(object obj)
public int GetHashCode()
}
public Azure.AzureCoreExtensions : object {
public T ToObject(BinaryData data, ObjectSerializer serializer, CancellationToken cancellationToken)
public ValueTask`1<T> ToObjectAsync(BinaryData data, ObjectSerializer serializer, CancellationToken cancellationToken)
public object ToObjectFromJson(BinaryData data)
public object ToDynamicFromJson(BinaryData utf8Json)
public object ToDynamicFromJson(BinaryData utf8Json, JsonPropertyNames propertyNameFormat, string dateTimeFormat)
internal object ToDynamicFromJson(BinaryData utf8Json, DynamicDataOptions options)
private object GetObject(JsonElement& element)
}
public Azure.AzureKeyCredential : object {
private string _key
public string Key
public string get_Key()
private void set_Key(string value)
public void .ctor(string key)
public void Update(string key)
}
public Azure.AzureNamedKeyCredential : object {
private Tuple`2<string, string> _namedKey
public string Name
public string get_Name()
public void .ctor(string name, string key)
public void Update(string name, string key)
public void Deconstruct(String& name, String& key)
}
public Azure.AzureSasCredential : object {
private string _signature
public string Signature
public string get_Signature()
private void set_Signature(string value)
public void .ctor(string signature)
public void Update(string signature)
}
public Azure.Core.AccessToken : ValueType {
private string <Token>k__BackingField
private DateTimeOffset <ExpiresOn>k__BackingField
public string Token
public DateTimeOffset ExpiresOn
public void .ctor(string accessToken, DateTimeOffset expiresOn)
public string get_Token()
public DateTimeOffset get_ExpiresOn()
public bool Equals(object obj)
public int GetHashCode()
}
internal Azure.Core.AppContextSwitchHelper : object {
public bool GetConfigValue(string appContexSwitchName, string environmentVariableName)
}
internal Azure.Core.Argument : object {
public void AssertNotNull(T value, string name)
public void AssertNotNull(Nullable`1<T> value, string name)
public void AssertNotNullOrEmpty(IEnumerable`1<T> value, string name)
public void AssertNotNullOrEmpty(string value, string name)
public void AssertNotNullOrWhiteSpace(string value, string name)
public void AssertNotDefault(T& value, string name)
public void AssertInRange(T value, T minimum, T maximum, string name)
public void AssertEnumDefined(Type enumType, object value, string name)
public T CheckNotNull(T value, string name)
public string CheckNotNullOrEmpty(string value, string name)
public void AssertNull(T value, string name, string message)
}
internal Azure.Core.ArrayBackedPropertyBag`2 : ValueType {
private Kvp<TKey, TValue> _first
private Kvp<TKey, TValue> _second
private Kvp[] _rest
private int _count
public int Count
public bool IsEmpty
public int get_Count()
public bool get_IsEmpty()
public void GetAt(int index, TKey& key, TValue& value)
public bool TryGetValue(TKey key, TValue& value)
public bool TryAdd(TKey key, TValue value, TValue& existingValue)
public void Set(TKey key, TValue value)
public bool TryRemove(TKey key)
private bool IsFirst(TKey key)
private bool IsSecond(TKey key)
private void AddInternal(TKey key, TValue value)
private void SetAt(int index, Kvp<TKey, TValue> value)
private TValue GetAt(int index)
private int GetIndex(TKey key)
internal void Dispose()
private Kvp[] GetRest()
private void CheckDisposed()
}
internal Azure.Core.AsyncLockWithValue`1 : object {
private object _syncObj
private Queue`1<TaskCompletionSource`1<LockOrValue<T>>> _waiters
private bool _isLocked
private bool _hasValue
private long _index
private T _value
public bool HasValue
public bool get_HasValue()
public void .ctor(T value)
public bool TryGetValue(T& value)
public ValueTask`1<LockOrValue<T>> GetLockOrValueAsync(bool async, CancellationToken cancellationToken)
private void SetValue(T value, Int64& lockIndex)
private void Reset(Int64& lockIndex)
private void UnlockOrGetNextWaiter(Int64& lockIndex, TaskCompletionSource`1& nextWaiter)
}
internal Azure.Core.AuthorizationChallengeParser : object {
public string GetChallengeParameterFromResponse(Response response, string challengeScheme, string challengeParameter)
internal bool TryGetNextChallenge(ReadOnlySpan`1& headerValue, ReadOnlySpan`1& challengeKey)
internal bool TryGetNextParameter(ReadOnlySpan`1& headerValue, ReadOnlySpan`1& paramKey, ReadOnlySpan`1& paramValue, char separator)
}
internal Azure.Core.AzureKeyCredentialPolicy : HttpPipelineSynchronousPolicy {
private string _name
private AzureKeyCredential _credential
private string _prefix
public void .ctor(AzureKeyCredential credential, string name, string prefix)
public void OnSendingRequest(HttpMessage message)
}
public Azure.Core.AzureLocation : ValueType {
private char Space
private Dictionary`2<string, AzureLocation> <PublicCloudLocations>k__BackingField
private AzureLocation <EastAsia>k__BackingField
private AzureLocation <SoutheastAsia>k__BackingField
private AzureLocation <CentralUS>k__BackingField
private AzureLocation <EastUS>k__BackingField
private AzureLocation <EastUS2>k__BackingField
private AzureLocation <WestUS>k__BackingField
private AzureLocation <WestUS2>k__BackingField
private AzureLocation <WestUS3>k__BackingField
private AzureLocation <NorthCentralUS>k__BackingField
private AzureLocation <SouthCentralUS>k__BackingField
private AzureLocation <NorthEurope>k__BackingField
private AzureLocation <WestEurope>k__BackingField
private AzureLocation <JapanWest>k__BackingField
private AzureLocation <JapanEast>k__BackingField
private AzureLocation <BrazilSouth>k__BackingField
private AzureLocation <AustraliaEast>k__BackingField
private AzureLocation <AustraliaSoutheast>k__BackingField
private AzureLocation <SouthIndia>k__BackingField
private AzureLocation <CentralIndia>k__BackingField
private AzureLocation <WestIndia>k__BackingField
private AzureLocation <CanadaCentral>k__BackingField
private AzureLocation <CanadaEast>k__BackingField
private AzureLocation <UKSouth>k__BackingField
private AzureLocation <UKWest>k__BackingField
private AzureLocation <WestCentralUS>k__BackingField
private AzureLocation <KoreaCentral>k__BackingField
private AzureLocation <KoreaSouth>k__BackingField
private AzureLocation <FranceCentral>k__BackingField
private AzureLocation <FranceSouth>k__BackingField
private AzureLocation <AustraliaCentral>k__BackingField
private AzureLocation <AustraliaCentral2>k__BackingField
private AzureLocation <UAECentral>k__BackingField
private AzureLocation <UAENorth>k__BackingField
private AzureLocation <SouthAfricaNorth>k__BackingField
private AzureLocation <SouthAfricaWest>k__BackingField
private AzureLocation <SwedenCentral>k__BackingField
private AzureLocation <SwitzerlandNorth>k__BackingField
private AzureLocation <SwitzerlandWest>k__BackingField
private AzureLocation <GermanyNorth>k__BackingField
private AzureLocation <GermanyWestCentral>k__BackingField
private AzureLocation <GermanyCentral>k__BackingField
private AzureLocation <GermanyNorthEast>k__BackingField
private AzureLocation <NorwayWest>k__BackingField
private AzureLocation <NorwayEast>k__BackingField
private AzureLocation <BrazilSoutheast>k__BackingField
private AzureLocation <ChinaNorth>k__BackingField
private AzureLocation <ChinaEast>k__BackingField
private AzureLocation <ChinaNorth2>k__BackingField
private AzureLocation <ChinaEast2>k__BackingField
private AzureLocation <QatarCentral>k__BackingField
private AzureLocation <USDoDCentral>k__BackingField
private AzureLocation <USDoDEast>k__BackingField
private AzureLocation <USGovArizona>k__BackingField
private AzureLocation <USGovTexas>k__BackingField
private AzureLocation <USGovVirginia>k__BackingField
private AzureLocation <USGovIowa>k__BackingField
private string <Name>k__BackingField
private string <DisplayName>k__BackingField
private Dictionary`2<string, AzureLocation> PublicCloudLocations
public AzureLocation EastAsia
public AzureLocation SoutheastAsia
public AzureLocation CentralUS
public AzureLocation EastUS
public AzureLocation EastUS2
public AzureLocation WestUS
public AzureLocation WestUS2
public AzureLocation WestUS3
public AzureLocation NorthCentralUS
public AzureLocation SouthCentralUS
public AzureLocation NorthEurope
public AzureLocation WestEurope
public AzureLocation JapanWest
public AzureLocation JapanEast
public AzureLocation BrazilSouth
public AzureLocation AustraliaEast
public AzureLocation AustraliaSoutheast
public AzureLocation SouthIndia
public AzureLocation CentralIndia
public AzureLocation WestIndia
public AzureLocation CanadaCentral
public AzureLocation CanadaEast
public AzureLocation UKSouth
public AzureLocation UKWest
public AzureLocation WestCentralUS
public AzureLocation KoreaCentral
public AzureLocation KoreaSouth
public AzureLocation FranceCentral
public AzureLocation FranceSouth
public AzureLocation AustraliaCentral
public AzureLocation AustraliaCentral2
public AzureLocation UAECentral
public AzureLocation UAENorth
public AzureLocation SouthAfricaNorth
public AzureLocation SouthAfricaWest
public AzureLocation SwedenCentral
public AzureLocation SwitzerlandNorth
public AzureLocation SwitzerlandWest
public AzureLocation GermanyNorth
public AzureLocation GermanyWestCentral
public AzureLocation GermanyCentral
public AzureLocation GermanyNorthEast
public AzureLocation NorwayWest
public AzureLocation NorwayEast
public AzureLocation BrazilSoutheast
public AzureLocation ChinaNorth
public AzureLocation ChinaEast
public AzureLocation ChinaNorth2
public AzureLocation ChinaEast2
public AzureLocation QatarCentral
public AzureLocation USDoDCentral
public AzureLocation USDoDEast
public AzureLocation USGovArizona
public AzureLocation USGovTexas
public AzureLocation USGovVirginia
public AzureLocation USGovIowa
public string Name
public string DisplayName
private Dictionary`2<string, AzureLocation> get_PublicCloudLocations()
public AzureLocation get_EastAsia()
public AzureLocation get_SoutheastAsia()
public AzureLocation get_CentralUS()
public AzureLocation get_EastUS()
public AzureLocation get_EastUS2()
public AzureLocation get_WestUS()
public AzureLocation get_WestUS2()
public AzureLocation get_WestUS3()
public AzureLocation get_NorthCentralUS()
public AzureLocation get_SouthCentralUS()
public AzureLocation get_NorthEurope()
public AzureLocation get_WestEurope()
public AzureLocation get_JapanWest()
public AzureLocation get_JapanEast()
public AzureLocation get_BrazilSouth()
public AzureLocation get_AustraliaEast()
public AzureLocation get_AustraliaSoutheast()
public AzureLocation get_SouthIndia()
public AzureLocation get_CentralIndia()
public AzureLocation get_WestIndia()
public AzureLocation get_CanadaCentral()
public AzureLocation get_CanadaEast()
public AzureLocation get_UKSouth()
public AzureLocation get_UKWest()
public AzureLocation get_WestCentralUS()
public AzureLocation get_KoreaCentral()
public AzureLocation get_KoreaSouth()
public AzureLocation get_FranceCentral()
public AzureLocation get_FranceSouth()
public AzureLocation get_AustraliaCentral()
public AzureLocation get_AustraliaCentral2()
public AzureLocation get_UAECentral()
public AzureLocation get_UAENorth()
public AzureLocation get_SouthAfricaNorth()
public AzureLocation get_SouthAfricaWest()
public AzureLocation get_SwedenCentral()
public AzureLocation get_SwitzerlandNorth()
public AzureLocation get_SwitzerlandWest()
public AzureLocation get_GermanyNorth()
public AzureLocation get_GermanyWestCentral()
public AzureLocation get_GermanyCentral()
public AzureLocation get_GermanyNorthEast()
public AzureLocation get_NorwayWest()
public AzureLocation get_NorwayEast()
public AzureLocation get_BrazilSoutheast()
public AzureLocation get_ChinaNorth()
public AzureLocation get_ChinaEast()
public AzureLocation get_ChinaNorth2()
public AzureLocation get_ChinaEast2()
public AzureLocation get_QatarCentral()
public AzureLocation get_USDoDCentral()
public AzureLocation get_USDoDEast()
public AzureLocation get_USGovArizona()
public AzureLocation get_USGovTexas()
public AzureLocation get_USGovVirginia()
public AzureLocation get_USGovIowa()
public void .ctor(string location)
public void .ctor(string name, string displayName)
private string GetNameFromDisplayName(string name, Boolean& foundSpace)
public string get_Name()
public string get_DisplayName()
private AzureLocation CreateStaticReference(string name, string displayName)
public string ToString()
public AzureLocation op_Implicit(string location)
public bool Equals(AzureLocation other)
public string op_Implicit(AzureLocation location)
public bool Equals(object obj)
public int GetHashCode()
public bool op_Equality(AzureLocation left, AzureLocation right)
public bool op_Inequality(AzureLocation left, AzureLocation right)
}
internal Azure.Core.AzureSasCredentialSynchronousPolicy : HttpPipelineSynchronousPolicy {
private AzureSasCredential _credential
public void .ctor(AzureSasCredential credential)
public void OnSendingRequest(HttpMessage message)
}
internal Azure.Core.Base64Url : object {
public Byte[] Decode(string encoded)
public string Encode(Byte[] bytes)
internal string DecodeString(string encoded)
internal string EncodeString(string value)
}
internal Azure.Core.BufferedReadStream : Stream {
private byte CR
private byte LF
private Stream _inner
private Byte[] _buffer
private ArrayPool`1<byte> _bytePool
private int _bufferOffset
private int _bufferCount
private bool _disposed
public ArraySegment`1<byte> BufferedData
public bool CanRead
public bool CanSeek
public bool CanTimeout
public bool CanWrite
public long Length
public long Position
public void .ctor(Stream inner, int bufferSize)
public void .ctor(Stream inner, int bufferSize, ArrayPool`1<byte> bytePool)
public ArraySegment`1<byte> get_BufferedData()
public bool get_CanRead()
public bool get_CanSeek()
public bool get_CanTimeout()
public bool get_CanWrite()
public long get_Length()
public long get_Position()
public void set_Position(long value)
public long Seek(long offset, SeekOrigin origin)
public void SetLength(long value)
protected void Dispose(bool disposing)
public void Flush()
public Task FlushAsync(CancellationToken cancellationToken)
public void Write(Byte[] buffer, int offset, int count)
public Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken)
public int Read(Byte[] buffer, int offset, int count)
public Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken)
public bool EnsureBuffered()
public Task`1<bool> EnsureBufferedAsync(CancellationToken cancellationToken)
public bool EnsureBuffered(int minCount)
public Task`1<bool> EnsureBufferedAsync(int minCount, CancellationToken cancellationToken)
public string ReadLine(int lengthLimit)
public Task`1<string> ReadLineAsync(int lengthLimit, CancellationToken cancellationToken)
private void ProcessLineChar(MemoryStream builder, Boolean& foundCR, Boolean& foundCRLF, Boolean& foundLF)
private string DecodeLine(MemoryStream builder, bool foundCRLF, bool foundLF)
private void CheckDisposed()
private void ValidateBuffer(Byte[] buffer, int offset, int count)
}
internal Azure.Core.Buffers.AzureBaseBuffersExtensions : object {
public Task WriteAsync(Stream stream, ReadOnlyMemory`1<byte> buffer, CancellationToken cancellation)
public Task WriteAsync(Stream stream, ReadOnlySequence`1<byte> buffer, CancellationToken cancellation)
}
internal Azure.Core.CancellationHelper : object {
private string s_cancellationMessage
internal bool ShouldWrapInOperationCanceledException(Exception exception, CancellationToken cancellationToken)
internal Exception CreateOperationCanceledException(Exception innerException, CancellationToken cancellationToken, string message)
private void ThrowOperationCanceledException(Exception innerException, CancellationToken cancellationToken)
internal void ThrowIfCancellationRequested(CancellationToken cancellationToken)
}
internal Azure.Core.ChainingClassifier : ResponseClassifier {
private ResponseClassificationHandler[] _handlers
private ResponseClassifier _endOfChain
public void .ctor(ValueTuple`2[] statusCodes, ResponseClassificationHandler[] handlers, ResponseClassifier endOfChain)
public bool IsErrorResponse(HttpMessage message)
private void AddClassifiers(ReadOnlySpan`1<ResponseClassificationHandler> handlers)
}
public Azure.Core.ClientOptions : object {
private HttpPipelineTransport _transport
private bool <IsCustomTransportSet>k__BackingField
private ClientOptions <Default>k__BackingField
private DiagnosticsOptions <Diagnostics>k__BackingField
private RetryOptions <Retry>k__BackingField
private HttpPipelinePolicy <RetryPolicy>k__BackingField
private List`1<ValueTuple`2<HttpPipelinePosition, HttpPipelinePolicy>> <Policies>k__BackingField
internal bool IsCustomTransportSet
public ClientOptions Default
public HttpPipelineTransport Transport
public DiagnosticsOptions Diagnostics
public RetryOptions Retry
public HttpPipelinePolicy RetryPolicy
internal List`1<ValueTuple`2<HttpPipelinePosition, HttpPipelinePolicy>> Policies
internal bool get_IsCustomTransportSet()
private void set_IsCustomTransportSet(bool value)
public ClientOptions get_Default()
private void set_Default(ClientOptions value)
internal void ResetDefaultOptions()
protected void .ctor(DiagnosticsOptions diagnostics)
internal void .ctor(ClientOptions clientOptions, DiagnosticsOptions diagnostics)
public HttpPipelineTransport get_Transport()
public void set_Transport(HttpPipelineTransport value)
public DiagnosticsOptions get_Diagnostics()
public RetryOptions get_Retry()
public HttpPipelinePolicy get_RetryPolicy()
public void set_RetryPolicy(HttpPipelinePolicy value)
public void AddPolicy(HttpPipelinePolicy policy, HttpPipelinePosition position)
internal List`1<ValueTuple`2<HttpPipelinePosition, HttpPipelinePolicy>> get_Policies()
private void set_Policies(List`1<ValueTuple`2<HttpPipelinePosition, HttpPipelinePolicy>> value)
public bool Equals(object obj)
public int GetHashCode()
public string ToString()
}
public Azure.Core.ContentType : ValueType {
private string _contentType
private ContentType <ApplicationJson>k__BackingField
private ContentType <ApplicationOctetStream>k__BackingField
private ContentType <TextPlain>k__BackingField
public ContentType ApplicationJson
public ContentType ApplicationOctetStream
public ContentType TextPlain
public ContentType get_ApplicationJson()
public ContentType get_ApplicationOctetStream()
public ContentType get_TextPlain()
public void .ctor(string contentType)
public ContentType op_Implicit(string contentType)
public bool Equals(ContentType other)
public bool Equals(string other)
public bool Equals(object obj)
public int GetHashCode()
public bool op_Equality(ContentType left, ContentType right)
public bool op_Inequality(ContentType left, ContentType right)
public string ToString()
}
public Azure.Core.Cryptography.IKeyEncryptionKey {
public string KeyId
public string get_KeyId()
public Byte[] WrapKey(string algorithm, ReadOnlyMemory`1<byte> key, CancellationToken cancellationToken)
public Task`1<Byte[]> WrapKeyAsync(string algorithm, ReadOnlyMemory`1<byte> key, CancellationToken cancellationToken)
public Byte[] UnwrapKey(string algorithm, ReadOnlyMemory`1<byte> encryptedKey, CancellationToken cancellationToken)
public Task`1<Byte[]> UnwrapKeyAsync(string algorithm, ReadOnlyMemory`1<byte> encryptedKey, CancellationToken cancellationToken)
}
public Azure.Core.Cryptography.IKeyEncryptionKeyResolver {
public IKeyEncryptionKey Resolve(string keyId, CancellationToken cancellationToken)
public Task`1<IKeyEncryptionKey> ResolveAsync(string keyId, CancellationToken cancellationToken)
}
internal Azure.Core.DefaultClientOptions : ClientOptions {
private Nullable`1<bool> EnvironmentVariableToBool(string value)
}
public Azure.Core.DelayStrategy : object {
private Random _random
private double _minJitterFactor
private double _maxJitterFactor
private TimeSpan _maxDelay
protected void .ctor(Nullable`1<TimeSpan> maxDelay, double jitterFactor)
public DelayStrategy CreateExponentialDelayStrategy(Nullable`1<TimeSpan> initialDelay, Nullable`1<TimeSpan> maxDelay)
public DelayStrategy CreateFixedDelayStrategy(Nullable`1<TimeSpan> delay)
protected TimeSpan GetNextDelayCore(Response response, int retryNumber)
public TimeSpan GetNextDelay(Response response, int retryNumber)
private TimeSpan ApplyJitter(TimeSpan delay)
protected TimeSpan Max(TimeSpan val1, TimeSpan val2)
protected TimeSpan Min(TimeSpan val1, TimeSpan val2)
}
public Azure.Core.DelegatedTokenCredential : object {
public TokenCredential Create(Func`3<TokenRequestContext, CancellationToken, AccessToken> getToken, Func`3<TokenRequestContext, CancellationToken, ValueTask`1<AccessToken>> getTokenAsync)
public TokenCredential Create(Func`3<TokenRequestContext, CancellationToken, AccessToken> getToken)
}
internal Azure.Core.Diagnostics.AzureCoreEventSource : AzureEventSource {
private string EventSourceName
private int RequestEvent
private int RequestContentEvent
private int ResponseEvent
private int ResponseContentEvent
private int ResponseDelayEvent
private int ErrorResponseEvent
private int ErrorResponseContentEvent
private int RequestRetryingEvent
private int ResponseContentBlockEvent
private int ErrorResponseContentBlockEvent
private int ResponseContentTextEvent
private int ErrorResponseContentTextEvent
private int ResponseContentTextBlockEvent
private int ErrorResponseContentTextBlockEvent
private int RequestContentTextEvent
private int ExceptionResponseEvent
private int BackgroundRefreshFailedEvent
private int RequestRedirectEvent
private int RequestRedirectBlockedEvent
private int RequestRedirectCountExceededEvent
private int PipelineTransportOptionsNotAppliedEvent
private AzureCoreEventSource <Singleton>k__BackingField
public AzureCoreEventSource Singleton
public AzureCoreEventSource get_Singleton()
public void BackgroundRefreshFailed(string requestId, string exception)
public void Request(Request request, string assemblyName, HttpMessageSanitizer sanitizer)
public void Request(string requestId, string method, string uri, string headers, string clientAssembly)
public void RequestContent(string requestId, Byte[] content, Encoding textEncoding)
public void RequestContent(string requestId, Byte[] content)
public void RequestContentText(string requestId, string content)
public void Response(Response response, HttpMessageSanitizer sanitizer, double elapsed)
public void Response(string requestId, int status, string reasonPhrase, string headers, double seconds)
public void ResponseContent(string requestId, Byte[] content, Encoding textEncoding)
public void ResponseContent(string requestId, Byte[] content)
public void ResponseContentText(string requestId, string content)
public void ResponseContentBlock(string requestId, int blockNumber, Byte[] content, Encoding textEncoding)
public void ResponseContentBlock(string requestId, int blockNumber, Byte[] content)
public void ResponseContentTextBlock(string requestId, int blockNumber, string content)
public void ErrorResponse(Response response, HttpMessageSanitizer sanitizer, double elapsed)
public void ErrorResponse(string requestId, int status, string reasonPhrase, string headers, double seconds)
public void ErrorResponseContent(string requestId, Byte[] content, Encoding textEncoding)
public void ErrorResponseContent(string requestId, Byte[] content)
public void ErrorResponseContentText(string requestId, string content)
public void ErrorResponseContentBlock(string requestId, int blockNumber, Byte[] content, Encoding textEncoding)
public void ErrorResponseContentBlock(string requestId, int blockNumber, Byte[] content)
public void ErrorResponseContentTextBlock(string requestId, int blockNumber, string content)
public void RequestRetrying(string requestId, int retryNumber, double seconds)
public void ResponseDelay(string requestId, double seconds)
public void ExceptionResponse(string requestId, string exception)
public void RequestRedirect(Request request, Uri redirectUri, Response response)
public void RequestRedirect(string requestId, string from, string to, int status)
public void RequestRedirectBlocked(string requestId, string from, string to)
public void RequestRedirectCountExceeded(string requestId, string from, string to)
public void PipelineTransportOptionsNotApplied(Type optionsType)
public void PipelineTransportOptionsNotApplied(string optionsType)
private string FormatHeaders(IEnumerable`1<HttpHeader> headers, HttpMessageSanitizer sanitizer)
}
internal Azure.Core.Diagnostics.AzureEventSource : EventSource {
private string SharedDataKey
private HashSet`1<string> NamesInUse
private String[] MainEventSourceTraits
protected void .ctor(string eventSourceName)
private string DeduplicateName(string eventSourceName)
}
public Azure.Core.Diagnostics.AzureEventSourceListener : EventListener {
public string TraitName
public string TraitValue
private List`1<EventSource> _eventSources
private Action`2<EventWrittenEventArgs, string> _log
private EventLevel _level
public void .ctor(Action`2<EventWrittenEventArgs, string> log, EventLevel level)
protected void OnEventSourceCreated(EventSource eventSource)
protected void OnEventWritten(EventWrittenEventArgs eventData)
public AzureEventSourceListener CreateConsoleLogger(EventLevel level)
public AzureEventSourceListener CreateTraceLogger(EventLevel level)
}
public Azure.Core.DiagnosticsOptions : object {
private int MaxApplicationIdLength
private string _applicationId
private bool <IsLoggingEnabled>k__BackingField
private bool <IsDistributedTracingEnabled>k__BackingField
private bool <IsTelemetryEnabled>k__BackingField
private bool <IsLoggingContentEnabled>k__BackingField
private int <LoggedContentSizeLimit>k__BackingField
private IList`1<string> <LoggedHeaderNames>k__BackingField
private IList`1<string> <LoggedQueryParameters>k__BackingField
public bool IsLoggingEnabled
public bool IsDistributedTracingEnabled
public bool IsTelemetryEnabled
public bool IsLoggingContentEnabled
public int LoggedContentSizeLimit
public IList`1<string> LoggedHeaderNames
public IList`1<string> LoggedQueryParameters
public string ApplicationId
public string DefaultApplicationId
internal void .ctor(DiagnosticsOptions diagnosticsOptions)
public bool get_IsLoggingEnabled()
public void set_IsLoggingEnabled(bool value)
public bool get_IsDistributedTracingEnabled()
public void set_IsDistributedTracingEnabled(bool value)
public bool get_IsTelemetryEnabled()
public void set_IsTelemetryEnabled(bool value)
public bool get_IsLoggingContentEnabled()
public void set_IsLoggingContentEnabled(bool value)
public int get_LoggedContentSizeLimit()
public void set_LoggedContentSizeLimit(int value)
public IList`1<string> get_LoggedHeaderNames()
internal void set_LoggedHeaderNames(IList`1<string> value)
public IList`1<string> get_LoggedQueryParameters()
internal void set_LoggedQueryParameters(IList`1<string> value)
public string get_ApplicationId()
public void set_ApplicationId(string value)
public string get_DefaultApplicationId()
public void set_DefaultApplicationId(string value)
private Nullable`1<bool> EnvironmentVariableToBool(string value)
}
internal Azure.Core.DictionaryHeaders : object {
private Dictionary`2<string, object> _headers
public void AddHeader(string name, string value)
public bool TryGetHeader(string name, String& value)
public bool TryGetHeaderValues(string name, IEnumerable`1& values)
public bool ContainsHeader(string name)
public void SetHeader(string name, string value)
public bool RemoveHeader(string name)
public IEnumerable`1<HttpHeader> EnumerateHeaders()
private string JoinHeaderValue(IEnumerable`1<string> values)
}
internal Azure.Core.ExponentialDelayStrategy : DelayStrategy {
private TimeSpan _delay
public void .ctor(Nullable`1<TimeSpan> delay, Nullable`1<TimeSpan> maxDelay)
protected TimeSpan GetNextDelayCore(Response response, int retryNumber)
}
public Azure.Core.Extensions.IAzureClientFactoryBuilder {
public IAzureClientBuilder`2<TClient, TOptions> RegisterClientFactory(Func`2<TOptions, TClient> clientFactory)
}
public Azure.Core.Extensions.IAzureClientFactoryBuilderWithConfiguration`1 {
public IAzureClientBuilder`2<TClient, TOptions> RegisterClientFactory(TConfiguration configuration)
}
public Azure.Core.Extensions.IAzureClientFactoryBuilderWithCredential {
public IAzureClientBuilder`2<TClient, TOptions> RegisterClientFactory(Func`3<TOptions, TokenCredential, TClient> clientFactory, bool requiresCredential)
}
internal Azure.Core.FixedDelayStrategy : DelayStrategy {
private TimeSpan _delay
public void .ctor(TimeSpan delay)
protected TimeSpan GetNextDelayCore(Response response, int retryNumber)
}
internal Azure.Core.FixedDelayWithNoJitterStrategy : DelayStrategy {
private TimeSpan DefaultDelay
private TimeSpan _delay
public void .ctor(Nullable`1<TimeSpan> suggestedDelay)
protected TimeSpan GetNextDelayCore(Response response, int retryNumber)
}
public Azure.Core.GeoJson.GeoArray`1 : ValueType {
private object _container
public T Item
public int Count
internal void .ctor(object container)
public T get_Item(int index)
public int get_Count()
public Enumerator<T> GetEnumerator()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
private IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator()
}
public Azure.Core.GeoJson.GeoBoundingBox : object {
private double <West>k__BackingField
private double <South>k__BackingField
private double <East>k__BackingField
private double <North>k__BackingField
private Nullable`1<double> <MinAltitude>k__BackingField
private Nullable`1<double> <MaxAltitude>k__BackingField
public double West
public double South
public double East
public double North
public Nullable`1<double> MinAltitude
public Nullable`1<double> MaxAltitude
public double Item
public double get_West()
public double get_South()
public double get_East()
public double get_North()
public Nullable`1<double> get_MinAltitude()
public Nullable`1<double> get_MaxAltitude()
public void .ctor(double west, double south, double east, double north)
public void .ctor(double west, double south, double east, double north, Nullable`1<double> minAltitude, Nullable`1<double> maxAltitude)
public bool Equals(GeoBoundingBox other)
public bool Equals(object obj)
public int GetHashCode()
public double get_Item(int index)
public string ToString()
}
public Azure.Core.GeoJson.GeoCollection : GeoObject {
private IReadOnlyList`1<GeoObject> <Geometries>k__BackingField
private GeoObjectType <Type>k__BackingField
internal IReadOnlyList`1<GeoObject> Geometries
public int Count
public GeoObject Item
public GeoObjectType Type
public void .ctor(IEnumerable`1<GeoObject> geometries)
public void .ctor(IEnumerable`1<GeoObject> geometries, GeoBoundingBox boundingBox, IReadOnlyDictionary`2<string, object> customProperties)
internal IReadOnlyList`1<GeoObject> get_Geometries()
public IEnumerator`1<GeoObject> GetEnumerator()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
public int get_Count()
public GeoObject get_Item(int index)
public GeoObjectType get_Type()
}
internal Azure.Core.GeoJson.GeoJsonConverter : JsonConverter`1<GeoObject> {
private string PointType
private string LineStringType
private string MultiPointType
private string PolygonType
private string MultiLineStringType
private string MultiPolygonType
private string GeometryCollectionType
private string TypeProperty
private string GeometriesProperty
private string CoordinatesProperty
private string BBoxProperty
public bool CanConvert(Type typeToConvert)
public GeoObject Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options)
public void Write(Utf8JsonWriter writer, GeoObject value, JsonSerializerOptions options)
internal GeoObject Read(JsonElement element)
private GeoBoundingBox ReadBoundingBox(JsonElement& element)
private IReadOnlyDictionary`2<string, object> ReadAdditionalProperties(JsonElement& element, string knownProperty)
private object ReadAdditionalPropertyValue(JsonElement& element)
private IReadOnlyList`1<GeoPosition> ReadCoordinates(JsonElement coordinatesElement)
private GeoPosition ReadCoordinate(JsonElement coordinate)
internal void Write(Utf8JsonWriter writer, GeoObject value)
private void WriteAdditionalPropertyValue(Utf8JsonWriter writer, object value)
private JsonElement GetRequiredProperty(JsonElement element, string name)
internal void <Write>g__WritePositionValues|20_0(GeoPosition type, <>c__DisplayClass20_0& )
internal void <Write>g__WriteType|20_1(string type, <>c__DisplayClass20_0& )
internal void <Write>g__WritePosition|20_2(GeoPosition type, <>c__DisplayClass20_0& )
internal void <Write>g__WritePositions|20_3(GeoArray`1<GeoPosition> positions, <>c__DisplayClass20_0& )
}
public Azure.Core.GeoJson.GeoLinearRing : object {
private GeoArray`1<GeoPosition> <Coordinates>k__BackingField
public GeoArray`1<GeoPosition> Coordinates
public void .ctor(IEnumerable`1<GeoPosition> coordinates)
public GeoArray`1<GeoPosition> get_Coordinates()
}
public Azure.Core.GeoJson.GeoLineString : GeoObject {
private GeoArray`1<GeoPosition> <Coordinates>k__BackingField
private GeoObjectType <Type>k__BackingField
public GeoArray`1<GeoPosition> Coordinates
public GeoObjectType Type
public void .ctor(IEnumerable`1<GeoPosition> coordinates)
public void .ctor(IEnumerable`1<GeoPosition> coordinates, GeoBoundingBox boundingBox, IReadOnlyDictionary`2<string, object> customProperties)
public GeoArray`1<GeoPosition> get_Coordinates()
public GeoObjectType get_Type()
}
public Azure.Core.GeoJson.GeoLineStringCollection : GeoObject {
private IReadOnlyList`1<GeoLineString> <Lines>k__BackingField
private GeoObjectType <Type>k__BackingField
internal IReadOnlyList`1<GeoLineString> Lines
public int Count
public GeoLineString Item
public GeoArray`1<GeoArray`1<GeoPosition>> Coordinates
public GeoObjectType Type
public void .ctor(IEnumerable`1<GeoLineString> lines)
public void .ctor(IEnumerable`1<GeoLineString> lines, GeoBoundingBox boundingBox, IReadOnlyDictionary`2<string, object> customProperties)
internal IReadOnlyList`1<GeoLineString> get_Lines()
public IEnumerator`1<GeoLineString> GetEnumerator()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
public int get_Count()
public GeoLineString get_Item(int index)
public GeoArray`1<GeoArray`1<GeoPosition>> get_Coordinates()
public GeoObjectType get_Type()
}
public Azure.Core.GeoJson.GeoObject : object {
internal IReadOnlyDictionary`2<string, object> DefaultProperties
private IReadOnlyDictionary`2<string, object> <CustomProperties>k__BackingField
private GeoBoundingBox <BoundingBox>k__BackingField
internal IReadOnlyDictionary`2<string, object> CustomProperties
public GeoObjectType Type
public GeoBoundingBox BoundingBox
internal IReadOnlyDictionary`2<string, object> get_CustomProperties()
internal void .ctor(GeoBoundingBox boundingBox, IReadOnlyDictionary`2<string, object> customProperties)
public GeoObjectType get_Type()
public GeoBoundingBox get_BoundingBox()
public bool TryGetCustomProperty(string name, Object& value)
public string ToString()
public GeoObject Parse(string json)
}
public Azure.Core.GeoJson.GeoObjectType : Enum {
public int value__
public GeoObjectType Point
public GeoObjectType MultiPoint
public GeoObjectType Polygon
public GeoObjectType MultiPolygon
public GeoObjectType LineString
public GeoObjectType MultiLineString
public GeoObjectType GeometryCollection
}
public Azure.Core.GeoJson.GeoPoint : GeoObject {
private GeoPosition <Coordinates>k__BackingField
private GeoObjectType <Type>k__BackingField
public GeoPosition Coordinates
public GeoObjectType Type
public void .ctor(double longitude, double latitude)
public void .ctor(double longitude, double latitude, Nullable`1<double> altitude)
public void .ctor(GeoPosition position)
public void .ctor(GeoPosition position, GeoBoundingBox boundingBox, IReadOnlyDictionary`2<string, object> customProperties)
public GeoPosition get_Coordinates()
public GeoObjectType get_Type()
}
public Azure.Core.GeoJson.GeoPointCollection : GeoObject {
private IReadOnlyList`1<GeoPoint> <Points>k__BackingField
private GeoObjectType <Type>k__BackingField
internal IReadOnlyList`1<GeoPoint> Points
public int Count
public GeoPoint Item
public GeoArray`1<GeoPosition> Coordinates
public GeoObjectType Type
public void .ctor(IEnumerable`1<GeoPoint> points)
public void .ctor(IEnumerable`1<GeoPoint> points, GeoBoundingBox boundingBox, IReadOnlyDictionary`2<string, object> customProperties)
internal IReadOnlyList`1<GeoPoint> get_Points()
public IEnumerator`1<GeoPoint> GetEnumerator()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
public int get_Count()
public GeoPoint get_Item(int index)
public GeoArray`1<GeoPosition> get_Coordinates()
public GeoObjectType get_Type()
}
public Azure.Core.GeoJson.GeoPolygon : GeoObject {
private IReadOnlyList`1<GeoLinearRing> <Rings>k__BackingField
private GeoObjectType <Type>k__BackingField
public IReadOnlyList`1<GeoLinearRing> Rings
public GeoLinearRing OuterRing
public GeoArray`1<GeoArray`1<GeoPosition>> Coordinates
public GeoObjectType Type
public void .ctor(IEnumerable`1<GeoPosition> positions)
public void .ctor(IEnumerable`1<GeoLinearRing> rings)
public void .ctor(IEnumerable`1<GeoLinearRing> rings, GeoBoundingBox boundingBox, IReadOnlyDictionary`2<string, object> customProperties)
public IReadOnlyList`1<GeoLinearRing> get_Rings()
public GeoLinearRing get_OuterRing()
public GeoArray`1<GeoArray`1<GeoPosition>> get_Coordinates()
public GeoObjectType get_Type()
}
public Azure.Core.GeoJson.GeoPolygonCollection : GeoObject {
private IReadOnlyList`1<GeoPolygon> <Polygons>k__BackingField
private GeoObjectType <Type>k__BackingField
internal IReadOnlyList`1<GeoPolygon> Polygons
public int Count
public GeoPolygon Item
public GeoArray`1<GeoArray`1<GeoArray`1<GeoPosition>>> Coordinates
public GeoObjectType Type
public void .ctor(IEnumerable`1<GeoPolygon> polygons)
public void .ctor(IEnumerable`1<GeoPolygon> polygons, GeoBoundingBox boundingBox, IReadOnlyDictionary`2<string, object> customProperties)
internal IReadOnlyList`1<GeoPolygon> get_Polygons()
public IEnumerator`1<GeoPolygon> GetEnumerator()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
public int get_Count()
public GeoPolygon get_Item(int index)
public GeoArray`1<GeoArray`1<GeoArray`1<GeoPosition>>> get_Coordinates()
public GeoObjectType get_Type()
}
public Azure.Core.GeoJson.GeoPosition : ValueType {
private Nullable`1<double> <Altitude>k__BackingField
private double <Longitude>k__BackingField
private double <Latitude>k__BackingField
public Nullable`1<double> Altitude
public double Longitude
public double Latitude
public double Item
public int Count
public Nullable`1<double> get_Altitude()
public double get_Longitude()
public double get_Latitude()
public void .ctor(double longitude, double latitude)
public void .ctor(double longitude, double latitude, Nullable`1<double> altitude)
public bool Equals(GeoPosition other)
public bool Equals(object obj)
public int GetHashCode()
public bool op_Equality(GeoPosition left, GeoPosition right)
public bool op_Inequality(GeoPosition left, GeoPosition right)
public string ToString()
public double get_Item(int index)
public int get_Count()
}
internal Azure.Core.HashCodeBuilder : ValueType {
private UInt32 s_seed
private UInt32 Prime1
private UInt32 Prime2
private UInt32 Prime3
private UInt32 Prime4
private UInt32 Prime5
private UInt32 _v1
private UInt32 _v2
private UInt32 _v3
private UInt32 _v4
private UInt32 _queue1
private UInt32 _queue2
private UInt32 _queue3
private UInt32 _length
private UInt32 GenerateGlobalSeed()
public int Combine(T1 value1)
public int Combine(T1 value1, T2 value2)
public int Combine(T1 value1, T2 value2, T3 value3)
public int Combine(T1 value1, T2 value2, T3 value3, T4 value4)
public int Combine(T1 value1, T2 value2, T3 value3, T4 value4, T5 value5)
public int Combine(T1 value1, T2 value2, T3 value3, T4 value4, T5 value5, T6 value6)
public int Combine(T1 value1, T2 value2, T3 value3, T4 value4, T5 value5, T6 value6, T7 value7)
public int Combine(T1 value1, T2 value2, T3 value3, T4 value4, T5 value5, T6 value6, T7 value7, T8 value8)
private void Initialize(UInt32& v1, UInt32& v2, UInt32& v3, UInt32& v4)
private UInt32 Round(UInt32 hash, UInt32 input)
private UInt32 QueueRound(UInt32 hash, UInt32 queuedValue)
private UInt32 MixState(UInt32 v1, UInt32 v2, UInt32 v3, UInt32 v4)
public UInt32 RotateLeft(UInt32 value, int offset)
private UInt32 MixEmptyState()
private UInt32 MixFinal(UInt32 hash)
public void Add(T value)
public void Add(T value, IEqualityComparer`1<T> comparer)
private void Add(int value)
public int ToHashCode()
public int GetHashCode()
public bool Equals(object obj)
}
public Azure.Core.HttpHeader : ValueType {
private string <Name>k__BackingField
private string <Value>k__BackingField
public string Name
public string Value
public void .ctor(string name, string value)
public string get_Name()
public string get_Value()
public int GetHashCode()
public bool Equals(object obj)
public string ToString()
public bool Equals(HttpHeader other)
}
public Azure.Core.HttpMessage : object {
private ArrayBackedPropertyBag`2<ulong, object> _propertyBag
private Response _response
private Request <Request>k__BackingField
private CancellationToken <CancellationToken>k__BackingField
private ResponseClassifier <ResponseClassifier>k__BackingField
private bool <BufferResponse>k__BackingField
private Nullable`1<TimeSpan> <NetworkTimeout>k__BackingField
private int <RetryNumber>k__BackingField
private DateTimeOffset <ProcessingStartTime>k__BackingField
private List`1<ValueTuple`2<HttpPipelinePosition, HttpPipelinePolicy>> <Policies>k__BackingField
public Request Request
public Response Response
public bool HasResponse
public CancellationToken CancellationToken
public ResponseClassifier ResponseClassifier
public bool BufferResponse
public Nullable`1<TimeSpan> NetworkTimeout
internal int RetryNumber
internal DateTimeOffset ProcessingStartTime
public MessageProcessingContext ProcessingContext
internal List`1<ValueTuple`2<HttpPipelinePosition, HttpPipelinePolicy>> Policies
public void .ctor(Request request, ResponseClassifier responseClassifier)
public Request get_Request()
public Response get_Response()
public void set_Response(Response value)
public bool get_HasResponse()
internal void ClearResponse()
public CancellationToken get_CancellationToken()
internal void set_CancellationToken(CancellationToken value)
public ResponseClassifier get_ResponseClassifier()
public void set_ResponseClassifier(ResponseClassifier value)
public bool get_BufferResponse()
public void set_BufferResponse(bool value)
public Nullable`1<TimeSpan> get_NetworkTimeout()
public void set_NetworkTimeout(Nullable`1<TimeSpan> value)
internal int get_RetryNumber()
internal void set_RetryNumber(int value)
internal DateTimeOffset get_ProcessingStartTime()
internal void set_ProcessingStartTime(DateTimeOffset value)
public MessageProcessingContext get_ProcessingContext()
internal void ApplyRequestContext(RequestContext context, ResponseClassifier classifier)
internal List`1<ValueTuple`2<HttpPipelinePosition, HttpPipelinePolicy>> get_Policies()
internal void set_Policies(List`1<ValueTuple`2<HttpPipelinePosition, HttpPipelinePolicy>> value)
public bool TryGetProperty(string name, Object& value)
public void SetProperty(string name, object value)
public bool TryGetProperty(Type type, Object& value)
public void SetProperty(Type type, object value)
public Stream ExtractResponseContent()
public void Dispose()
}
internal Azure.Core.HttpMessageSanitizer : object {
private string LogAllValue
private bool _logAllHeaders
private bool _logFullQueries
private String[] _allowedQueryParameters
private string _redactedPlaceholder
private HashSet`1<string> _allowedHeaders
internal HttpMessageSanitizer Default
public void .ctor(String[] allowedQueryParameters, String[] allowedHeaders, string redactedPlaceholder)
public string SanitizeHeader(string name, string value)
public string SanitizeUrl(string url)
}
public Azure.Core.HttpPipelinePosition : Enum {
public int value__
public HttpPipelinePosition PerCall
public HttpPipelinePosition PerRetry
public HttpPipelinePosition BeforeTransport
}
internal Azure.Core.IOperation {
public ValueTask`1<OperationState> UpdateStateAsync(bool async, CancellationToken cancellationToken)
}
internal Azure.Core.IOperation`1 {
public ValueTask`1<OperationState`1<T>> UpdateStateAsync(bool async, CancellationToken cancellationToken)
}
internal Azure.Core.Json.MutableJsonChange : ValueType {
private string <Path>k__BackingField
private int <Index>k__BackingField
private object <Value>k__BackingField
private string <AddedPropertyName>k__BackingField
private MutableJsonChangeKind <ChangeKind>k__BackingField
public string Path
public int Index
public object Value
public string AddedPropertyName
public MutableJsonChangeKind ChangeKind
public JsonValueKind ValueKind
public void .ctor(string path, int index, object value, MutableJsonChangeKind changeKind, string addedPropertyName)
public string get_Path()
public int get_Index()
public object get_Value()
public string get_AddedPropertyName()
public MutableJsonChangeKind get_ChangeKind()
public JsonValueKind get_ValueKind()
internal void EnsureString()
internal void EnsureNumber()
internal void EnsureArray()
internal int GetArrayLength()
internal bool IsDescendant(string path)
internal bool IsDescendant(ReadOnlySpan`1<char> ancestorPath)
internal bool IsDescendant(ReadOnlySpan`1<char> ancestorPath, ReadOnlySpan`1<char> descendantPath)
internal bool IsDirectDescendant(string path)
internal bool IsLessThan(ReadOnlySpan`1<char> otherPath)
internal bool IsGreaterThan(ReadOnlySpan`1<char> otherPath)
internal string AsString()
public string ToString()
}
internal Azure.Core.Json.MutableJsonChangeKind : Enum {
public int value__
public MutableJsonChangeKind PropertyUpdate
public MutableJsonChangeKind PropertyAddition
public MutableJsonChangeKind PropertyRemoval
}
internal Azure.Core.Json.MutableJsonDocument : object {
private JsonSerializerOptions DefaultSerializerOptions
private ReadOnlyMemory`1<byte> _original
private JsonDocument _originalDocument
private JsonSerializerOptions _serializerOptions
internal string SerializationRequiresUnreferencedCodeClass
private ChangeTracker _changeTracker
internal JsonSerializerOptions SerializerOptions
internal ChangeTracker Changes
public MutableJsonElement RootElement
internal JsonSerializerOptions get_SerializerOptions()
internal ChangeTracker get_Changes()
public MutableJsonElement get_RootElement()
public void WriteTo(Stream stream, string format)
internal void AssertInvalidFormat(string format)
private void WriteJson(Stream stream)
private void WriteOriginal(Stream stream)
private void WritePatch(Stream stream)
public void WriteTo(Utf8JsonWriter writer)
private void Write(Stream stream, ReadOnlySpan`1<byte> buffer)
public MutableJsonDocument Parse(ReadOnlyMemory`1<byte> utf8Json, JsonSerializerOptions serializerOptions)
public MutableJsonDocument Parse(Utf8JsonReader& reader, JsonSerializerOptions serializerOptions)
public MutableJsonDocument Parse(BinaryData utf8Json, JsonSerializerOptions serializerOptions)
public MutableJsonDocument Parse(string json, JsonSerializerOptions serializerOptions)
public void Dispose()
private void .ctor(JsonDocument document, ReadOnlyMemory`1<byte> utf8Json, JsonSerializerOptions serializerOptions)
}
internal Azure.Core.Json.MutableJsonElement : ValueType {
internal int MaxStackLimit
private MutableJsonDocument _root
private JsonElement _element
private string _path
private int _highWaterMark
internal string SerializationRequiresUnreferencedCodeConstructor
internal string SerializationRequiresUnreferencedCodeMethod
private ChangeTracker Changes
public Nullable`1<JsonValueKind> ValueKind
internal string DebuggerDisplay
private ChangeTracker get_Changes()
internal void .ctor(MutableJsonDocument root, JsonElement element, string path, int highWaterMark)
public Nullable`1<JsonValueKind> get_ValueKind()
public MutableJsonElement GetProperty(string name)
public MutableJsonElement GetProperty(ReadOnlySpan`1<char> name)
public bool TryGetProperty(string name, MutableJsonElement& value)
public bool TryGetProperty(ReadOnlySpan`1<char> name, MutableJsonElement& value)
private string GetString(ReadOnlySpan`1<char> value, int start, int end)
public int GetArrayLength()
internal MutableJsonElement GetIndexElement(int index)
public bool TryGetDouble(Double& value)
public double GetDouble()
private string GetFormatExceptionText(string path, Type type)
public bool TryGetInt32(Int32& value)
public int GetInt32()
public bool TryGetInt64(Int64& value)
public long GetInt64()
public bool TryGetSingle(Single& value)
public float GetSingle()
public string GetString()
public bool GetBoolean()
public bool TryGetByte(Byte& value)
public byte GetByte()
public bool TryGetDateTime(DateTime& value)
public DateTime GetDateTime()
public bool TryGetDateTimeOffset(DateTimeOffset& value)
public DateTimeOffset GetDateTimeOffset()
public bool TryGetDecimal(Decimal& value)
public decimal GetDecimal()
public bool TryGetGuid(Guid& value)
public Guid GetGuid()
public bool TryGetInt16(Int16& value)
public short GetInt16()
public bool TryGetSByte(SByte& value)
public sbyte GetSByte()
public bool TryGetUInt16(UInt16& value)
public ushort GetUInt16()
public bool TryGetUInt32(UInt32& value)
public UInt32 GetUInt32()
public bool TryGetUInt64(UInt64& value)
public ulong GetUInt64()
public ArrayEnumerator EnumerateArray()
public ObjectEnumerator EnumerateObject()
public void RemoveProperty(string name)
public void Set(double value)
public MutableJsonElement SetProperty(string name, double value)
public void Set(int value)
public MutableJsonElement SetProperty(string name, int value)
public void Set(long value)
public MutableJsonElement SetProperty(string name, long value)
public void Set(float value)
public MutableJsonElement SetProperty(string name, float value)
public void Set(string value)
public MutableJsonElement SetProperty(string name, string value)
public void SetNull()
public MutableJsonElement SetPropertyNull(string name)
public void Set(bool value)
public MutableJsonElement SetProperty(string name, bool value)
public void Set(byte value)
public MutableJsonElement SetProperty(string name, byte value)
public void Set(sbyte value)
public MutableJsonElement SetProperty(string name, sbyte value)
public void Set(short value)
public MutableJsonElement SetProperty(string name, short value)
public void Set(ushort value)
public MutableJsonElement SetProperty(string name, ushort value)
public void Set(UInt32 value)
public MutableJsonElement SetProperty(string name, UInt32 value)
public void Set(ulong value)
public MutableJsonElement SetProperty(string name, ulong value)
public void Set(decimal value)
public MutableJsonElement SetProperty(string name, decimal value)
public void Set(Guid value)
public MutableJsonElement SetProperty(string name, Guid value)
public void Set(DateTime value)
public MutableJsonElement SetProperty(string name, DateTime value)
public void Set(DateTimeOffset value)
public MutableJsonElement SetProperty(string name, DateTimeOffset value)
public void Set(JsonElement value)
public MutableJsonElement SetProperty(string name, JsonElement value)
public string ToString()
internal JsonElement SerializeToJsonElement(object value, JsonSerializerOptions options)
private JsonElement ParseFromBytes(Byte[] bytes)
internal JsonElement GetJsonElement()
private Byte[] GetRawBytes()
internal Utf8JsonReader GetReaderForElement(JsonElement element)
internal void DisposeRoot()
private void EnsureObject()
private void EnsureArray()
private void EnsureValid()
internal string get_DebuggerDisplay()
internal void WriteTo(Utf8JsonWriter writer, string format)
internal void WriteTo(Utf8JsonWriter writer)
private void WriteElement(string path, int highWaterMark, JsonElement element, Utf8JsonWriter writer)
private void WriteObject(string path, int highWaterMark, JsonElement element, Utf8JsonWriter writer)
private void WriteArray(string path, int highWaterMark, JsonElement element, Utf8JsonWriter writer)
private void WritePrimitiveChange(MutableJsonChange change, Utf8JsonWriter writer)
internal void WritePatch(Utf8JsonWriter writer)
private ReadOnlySpan`1<char> GetFirstSegment(ReadOnlySpan`1<char> path)
private ReadOnlySpan`1<char> GetLastSegment(ReadOnlySpan`1<char> path)
private void CopyTo(Span`1<char> target, Int32& targetLength, ReadOnlySpan`1<char> value)
private void CloseOpenObjects(Utf8JsonWriter writer, ReadOnlySpan`1<char> changePath, Span`1<char> patchPath, Int32& patchPathLength, MutableJsonElement& patchElement)
private void OpenAncestorObjects(Utf8JsonWriter writer, ReadOnlySpan`1<char> path, Int32& changePathLength, Span`1<char> currentPath, Int32& currentPathLength, Span`1<char> patchPath, Int32& patchPathLength, MutableJsonElement& patchElement)
private void CloseFinalObjects(Utf8JsonWriter writer, ReadOnlySpan`1<char> patchPath)
private void WritePatchValue(Utf8JsonWriter writer, MutableJsonChange change, ReadOnlySpan`1<char> patchPath, MutableJsonElement patchElement)
private void WriteObjectUpdate(Utf8JsonWriter writer, ReadOnlySpan`1<char> path, MutableJsonElement patchElement)
private MutableJsonElement GetPropertyFromRoot(ReadOnlySpan`1<char> path)
private JsonElement GetOriginal(ReadOnlySpan`1<char> path)
}
internal Azure.Core.JsonPatch.JsonPatchOperation : ValueType {
private JsonPatchOperationKind <Kind>k__BackingField
private string <Path>k__BackingField
private string <From>k__BackingField
private string <RawJsonValue>k__BackingField
public JsonPatchOperationKind Kind
public string Path
public string From
public string RawJsonValue
public void .ctor(JsonPatchOperationKind kind, string path, string from, string rawJsonValue)
public JsonPatchOperationKind get_Kind()
public string get_Path()
public string get_From()
public string get_RawJsonValue()
}
internal Azure.Core.JsonPatch.JsonPatchOperationKind : ValueType {
private string _operation
private JsonPatchOperationKind <Add>k__BackingField
private JsonPatchOperationKind <Remove>k__BackingField
private JsonPatchOperationKind <Replace>k__BackingField
private JsonPatchOperationKind <Move>k__BackingField
private JsonPatchOperationKind <Copy>k__BackingField
private JsonPatchOperationKind <Test>k__BackingField
public JsonPatchOperationKind Add
public JsonPatchOperationKind Remove
public JsonPatchOperationKind Replace
public JsonPatchOperationKind Move
public JsonPatchOperationKind Copy
public JsonPatchOperationKind Test
private void .ctor(string operation)
public JsonPatchOperationKind get_Add()
public JsonPatchOperationKind get_Remove()
public JsonPatchOperationKind get_Replace()
public JsonPatchOperationKind get_Move()
public JsonPatchOperationKind get_Copy()
public JsonPatchOperationKind get_Test()
public string ToString()
}
internal Azure.Core.KeyValueAccumulator : ValueType {
private Dictionary`2<string, String[]> _accumulator
private Dictionary`2<string, List`1<string>> _expandingAccumulator
private int <ValueCount>k__BackingField
public bool HasValues
public int KeyCount
public int ValueCount
public void Append(string key, string value)
public bool get_HasValues()
public int get_KeyCount()
public int get_ValueCount()
private void set_ValueCount(int value)
public Dictionary`2<string, String[]> GetResults()
}
internal Azure.Core.MemoryResponse : Response {
private int NoStatusCode
private string XmsClientRequestIdName
private int _status
private string _reasonPhrase
private IDictionary`2<string, List`1<string>> _headers
private Stream <ContentStream>k__BackingField
public int Status
public string ReasonPhrase
public Stream ContentStream
public string ClientRequestId
public int get_Status()
public string get_ReasonPhrase()
public Stream get_ContentStream()
public void set_ContentStream(Stream value)
public string get_ClientRequestId()
public void set_ClientRequestId(string value)
public void SetStatus(int status)
public void SetReasonPhrase(string reasonPhrase)
public void SetContent(Byte[] content)
public void SetContent(string content)
public void Dispose()
public void SetHeader(string name, string value)
public void SetHeader(string name, IEnumerable`1<string> values)
public void AddHeader(string name, string value)
protected internal bool ContainsHeader(string name)
protected internal IEnumerable`1<HttpHeader> EnumerateHeaders()
protected internal bool TryGetHeader(string name, String& value)
protected internal bool TryGetHeaderValues(string name, IEnumerable`1& values)
private string JoinHeaderValues(IEnumerable`1<string> values)
}
public Azure.Core.MessageProcessingContext : ValueType {
private HttpMessage _message
public DateTimeOffset StartTime
public int RetryNumber
public DateTimeOffset get_StartTime()
internal void set_StartTime(DateTimeOffset value)
public int get_RetryNumber()
public void set_RetryNumber(int value)
internal void .ctor(HttpMessage message)
}
internal Azure.Core.MultipartBoundary : object {
private Int32[] _skipTable
private string _boundary
private bool _expectLeadingCrlf
private Byte[] <BoundaryBytes>k__BackingField
private int <FinalBoundaryLength>k__BackingField
public bool ExpectLeadingCrlf
public Byte[] BoundaryBytes
public int FinalBoundaryLength
public void .ctor(string boundary, bool expectLeadingCrlf)
private void Initialize(string boundary, bool expectLeadingCrlf)
public int GetSkipValue(byte input)
public bool get_ExpectLeadingCrlf()
public void set_ExpectLeadingCrlf(bool value)
public Byte[] get_BoundaryBytes()
private void set_BoundaryBytes(Byte[] value)
public int get_FinalBoundaryLength()
private void set_FinalBoundaryLength(int value)
}
internal Azure.Core.MultipartReader : object {
public int DefaultHeadersCountLimit
public int DefaultHeadersLengthLimit
private int DefaultBufferSize
private BufferedReadStream _stream
private MultipartBoundary _boundary
private MultipartReaderStream _currentStream
private int <HeadersCountLimit>k__BackingField
private int <HeadersLengthLimit>k__BackingField
private Nullable`1<long> <BodyLengthLimit>k__BackingField
private bool <ExpectBoundariesWithCRLF>k__BackingField
public int HeadersCountLimit
public int HeadersLengthLimit
public Nullable`1<long> BodyLengthLimit
public bool ExpectBoundariesWithCRLF
public void .ctor(string boundary, Stream stream)
public void .ctor(string boundary, Stream stream, int bufferSize)
public int get_HeadersCountLimit()
public void set_HeadersCountLimit(int value)
public int get_HeadersLengthLimit()
public void set_HeadersLengthLimit(int value)
public Nullable`1<long> get_BodyLengthLimit()
public void set_BodyLengthLimit(Nullable`1<long> value)
public bool get_ExpectBoundariesWithCRLF()
public void set_ExpectBoundariesWithCRLF(bool value)
public Task`1<MultipartSection> ReadNextSectionAsync(CancellationToken cancellationToken)
private Task`1<Dictionary`2<string, String[]>> ReadHeadersAsync(CancellationToken cancellationToken)
}
internal Azure.Core.MultipartReaderStream : Stream {
private MultipartBoundary _boundary
private BufferedReadStream _innerStream
private ArrayPool`1<byte> _bytePool
private long _innerOffset
private long _position
private long _observedLength
private bool _finished
private bool <FinalBoundaryFound>k__BackingField
private Nullable`1<long> <LengthLimit>k__BackingField
public bool FinalBoundaryFound
public Nullable`1<long> LengthLimit
public bool CanRead
public bool CanSeek
public bool CanWrite
public long Length
public long Position
public void .ctor(BufferedReadStream stream, MultipartBoundary boundary)
public void .ctor(BufferedReadStream stream, MultipartBoundary boundary, ArrayPool`1<byte> bytePool)
public bool get_FinalBoundaryFound()
private void set_FinalBoundaryFound(bool value)
public Nullable`1<long> get_LengthLimit()
public void set_LengthLimit(Nullable`1<long> value)
public bool get_CanRead()
public bool get_CanSeek()
public bool get_CanWrite()
public long get_Length()
public long get_Position()
public void set_Position(long value)
public long Seek(long offset, SeekOrigin origin)
public void SetLength(long value)
public void Write(Byte[] buffer, int offset, int count)
public Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken)
public void Flush()
private void PositionInnerStream()
private int UpdatePosition(int read)
public int Read(Byte[] buffer, int offset, int count)
public Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken)
private bool SubMatch(ArraySegment`1<byte> segment1, Byte[] matchBytes, Int32& matchOffset, Int32& matchCount)
private int CompareBuffers(Byte[] buffer1, int offset1, Byte[] buffer2, int offset2, int count)
}
public Azure.Core.MultipartResponse : object {
private int KB
private int ResponseLineSize
private string MultipartContentTypePrefix
private string ContentIdName
internal InvalidOperationException InvalidBatchContentType(string contentType)
internal InvalidOperationException InvalidHttpStatusLine(string statusLine)
internal InvalidOperationException InvalidHttpHeaderLine(string headerLine)
public Response[] Parse(Response response, bool expectCrLf, CancellationToken cancellationToken)
public Task`1<Response[]> ParseAsync(Response response, bool expectCrLf, CancellationToken cancellationToken)
internal Task`1<Response[]> ParseAsync(Response parentResponse, bool expectBoundariesWithCRLF, bool async, CancellationToken cancellationToken)
internal Task`1<string> ReadLineAsync(BufferedReadStream stream, bool async, CancellationToken cancellationToken)
internal Task`1<MultipartSection> GetNextSectionAsync(MultipartReader reader, bool async, CancellationToken cancellationToken)
private bool GetBoundary(string contentType, String& batchBoundary)
}
internal Azure.Core.MultipartSection : object {
private Dictionary`2<string, String[]> <Headers>k__BackingField
private Stream <Body>k__BackingField
private Nullable`1<long> <BaseStreamOffset>k__BackingField
public Dictionary`2<string, String[]> Headers
public Stream Body
public Nullable`1<long> BaseStreamOffset
public Dictionary`2<string, String[]> get_Headers()
public void set_Headers(Dictionary`2<string, String[]> value)
public Stream get_Body()
public void set_Body(Stream value)
public Nullable`1<long> get_BaseStreamOffset()
public void set_BaseStreamOffset(Nullable`1<long> value)
}
internal Azure.Core.OperationInternal : OperationInternalBase {
private OperationInternal`1<VoidValue> _internalOperation
public Response RawResponse
public bool HasCompleted
public OperationInternal Succeeded(Response rawResponse)
public OperationInternal Failed(Response rawResponse, RequestFailedException operationFailedException)
public void .ctor(IOperation operation, ClientDiagnostics clientDiagnostics, Response rawResponse, string operationTypeName, IEnumerable`1<KeyValuePair`2<string, string>> scopeAttributes, DelayStrategy fallbackStrategy)
private void .ctor(OperationState finalState)
public Response get_RawResponse()
public bool get_HasCompleted()
protected ValueTask`1<Response> UpdateStatusAsync(bool async, CancellationToken cancellationToken)
}
internal Azure.Core.OperationInternal`1 : OperationInternalBase {
private IOperation`1<T> _operation
private AsyncLockWithValue`1<OperationState`1<T>> _stateLock
private Response _rawResponse
public Response RawResponse
public bool HasCompleted
public bool HasValue
public T Value
public OperationInternal`1<T> Succeeded(Response rawResponse, T value)
public OperationInternal`1<T> Failed(Response rawResponse, RequestFailedException operationFailedException)
public void .ctor(IOperation`1<T> operation, ClientDiagnostics clientDiagnostics, Response rawResponse, string operationTypeName, IEnumerable`1<KeyValuePair`2<string, string>> scopeAttributes, DelayStrategy fallbackStrategy)
private void .ctor(OperationState`1<T> finalState)
public Response get_RawResponse()
public bool get_HasCompleted()
public bool get_HasValue()
public T get_Value()
public ValueTask`1<Response`1<T>> WaitForCompletionAsync(CancellationToken cancellationToken)
public ValueTask`1<Response`1<T>> WaitForCompletionAsync(TimeSpan pollingInterval, CancellationToken cancellationToken)
public Response`1<T> WaitForCompletion(CancellationToken cancellationToken)
public Response`1<T> WaitForCompletion(TimeSpan pollingInterval, CancellationToken cancellationToken)
private ValueTask`1<Response`1<T>> WaitForCompletionAsync(bool async, Nullable`1<TimeSpan> pollingInterval, CancellationToken cancellationToken)
protected ValueTask`1<Response> UpdateStatusAsync(bool async, CancellationToken cancellationToken)
private Response GetResponseFromState(OperationState`1<T> state)
}
internal Azure.Core.OperationInternalBase : object {
private ClientDiagnostics _diagnostics
private IReadOnlyDictionary`2<string, string> _scopeAttributes
private DelayStrategy _fallbackStrategy
private AsyncLockWithValue`1<Response> _responseLock
private string _waitForCompletionResponseScopeName
protected string _updateStatusScopeName
protected string _waitForCompletionScopeName
public Response RawResponse
public bool HasCompleted
protected void .ctor(Response rawResponse)
protected void .ctor(ClientDiagnostics clientDiagnostics, string operationTypeName, IEnumerable`1<KeyValuePair`2<string, string>> scopeAttributes, DelayStrategy fallbackStrategy)
public Response get_RawResponse()
public bool get_HasCompleted()
public ValueTask`1<Response> UpdateStatusAsync(CancellationToken cancellationToken)
public Response UpdateStatus(CancellationToken cancellationToken)
public ValueTask`1<Response> WaitForCompletionResponseAsync(CancellationToken cancellationToken)
public ValueTask`1<Response> WaitForCompletionResponseAsync(TimeSpan pollingInterval, CancellationToken cancellationToken)
public Response WaitForCompletionResponse(CancellationToken cancellationToken)
public Response WaitForCompletionResponse(TimeSpan pollingInterval, CancellationToken cancellationToken)
protected ValueTask`1<Response> WaitForCompletionResponseAsync(bool async, Nullable`1<TimeSpan> pollingInterval, string scopeName, CancellationToken cancellationToken)
protected ValueTask`1<Response> UpdateStatusAsync(bool async, CancellationToken cancellationToken)
protected DiagnosticScope CreateScope(string scopeName)
}
internal Azure.Core.OperationPoller : object {
private DelayStrategy _delayStrategy
public void .ctor(DelayStrategy strategy)
public ValueTask`1<Response> WaitForCompletionResponseAsync(Operation operation, Nullable`1<TimeSpan> delayHint, CancellationToken cancellationToken)
public Response WaitForCompletionResponse(Operation operation, Nullable`1<TimeSpan> delayHint, CancellationToken cancellationToken)
public ValueTask`1<Response> WaitForCompletionResponseAsync(OperationInternalBase operation, Nullable`1<TimeSpan> delayHint, CancellationToken cancellationToken)
public Response WaitForCompletionResponse(OperationInternalBase operation, Nullable`1<TimeSpan> delayHint, CancellationToken cancellationToken)
public ValueTask`1<Response`1<T>> WaitForCompletionAsync(Operation`1<T> operation, Nullable`1<TimeSpan> delayHint, CancellationToken cancellationToken)
public Response`1<T> WaitForCompletion(Operation`1<T> operation, Nullable`1<TimeSpan> delayHint, CancellationToken cancellationToken)
public ValueTask`1<Response`1<T>> WaitForCompletionAsync(OperationInternal`1<T> operation, Nullable`1<TimeSpan> delayHint, CancellationToken cancellationToken)
public Response`1<T> WaitForCompletion(OperationInternal`1<T> operation, Nullable`1<TimeSpan> delayHint, CancellationToken cancellationToken)
private ValueTask`1<Response> WaitForCompletionAsync(bool async, Operation operation, Nullable`1<TimeSpan> delayHint, CancellationToken cancellationToken)
private ValueTask`1<Response> WaitForCompletionAsync(bool async, OperationInternalBase operation, Nullable`1<TimeSpan> delayHint, CancellationToken cancellationToken)
private ValueTask Delay(bool async, TimeSpan delay, CancellationToken cancellationToken)
}
internal Azure.Core.OperationState : ValueType {
private Response <RawResponse>k__BackingField
private bool <HasCompleted>k__BackingField
private bool <HasSucceeded>k__BackingField
private RequestFailedException <OperationFailedException>k__BackingField
public Response RawResponse
public bool HasCompleted
public bool HasSucceeded
public RequestFailedException OperationFailedException
private void .ctor(Response rawResponse, bool hasCompleted, bool hasSucceeded, RequestFailedException operationFailedException)
public Response get_RawResponse()
public bool get_HasCompleted()
public bool get_HasSucceeded()
public RequestFailedException get_OperationFailedException()
public OperationState Success(Response rawResponse)
public OperationState Failure(Response rawResponse, RequestFailedException operationFailedException)
public OperationState Pending(Response rawResponse)
}
internal Azure.Core.OperationState`1 : ValueType {
private Response <RawResponse>k__BackingField
private bool <HasCompleted>k__BackingField
private bool <HasSucceeded>k__BackingField
private T <Value>k__BackingField
private RequestFailedException <OperationFailedException>k__BackingField
public Response RawResponse
public bool HasCompleted
public bool HasSucceeded
public T Value
public RequestFailedException OperationFailedException
private void .ctor(Response rawResponse, bool hasCompleted, bool hasSucceeded, T value, RequestFailedException operationFailedException)
public Response get_RawResponse()
public bool get_HasCompleted()
public bool get_HasSucceeded()
public T get_Value()
public RequestFailedException get_OperationFailedException()
public OperationState`1<T> Success(Response rawResponse, T value)
public OperationState`1<T> Failure(Response rawResponse, RequestFailedException operationFailedException)
public OperationState`1<T> Pending(Response rawResponse)
}
internal Azure.Core.Pipeline.ActivityExtensions : object {
private bool <SupportsActivitySource>k__BackingField
public bool SupportsActivitySource
public bool get_SupportsActivitySource()
private void set_SupportsActivitySource(bool value)
public void ResetFeatureSwitch()
}
public Azure.Core.Pipeline.BearerTokenAuthenticationPolicy : HttpPipelinePolicy {
private String[] _scopes
private AccessTokenCache _accessTokenCache
public void .ctor(TokenCredential credential, string scope)
public void .ctor(TokenCredential credential, IEnumerable`1<string> scopes)
internal void .ctor(TokenCredential credential, IEnumerable`1<string> scopes, TimeSpan tokenRefreshOffset, TimeSpan tokenRefreshRetryDelay)
public ValueTask ProcessAsync(HttpMessage message, ReadOnlyMemory`1<HttpPipelinePolicy> pipeline)
public void Process(HttpMessage message, ReadOnlyMemory`1<HttpPipelinePolicy> pipeline)
protected ValueTask AuthorizeRequestAsync(HttpMessage message)
protected void AuthorizeRequest(HttpMessage message)
protected ValueTask`1<bool> AuthorizeRequestOnChallengeAsync(HttpMessage message)
protected bool AuthorizeRequestOnChallenge(HttpMessage message)
private ValueTask ProcessAsync(HttpMessage message, ReadOnlyMemory`1<HttpPipelinePolicy> pipeline, bool async)
protected ValueTask AuthenticateAndAuthorizeRequestAsync(HttpMessage message, TokenRequestContext context)
protected void AuthenticateAndAuthorizeRequest(HttpMessage message, TokenRequestContext context)
}
internal Azure.Core.Pipeline.ClientDiagnostics : DiagnosticScopeFactory {
public void .ctor(ClientOptions options, Nullable`1<bool> suppressNestedClientActivities)
public void .ctor(string optionsNamespace, string providerNamespace, DiagnosticsOptions diagnosticsOptions, Nullable`1<bool> suppressNestedClientActivities)
internal HttpMessageSanitizer CreateMessageSanitizer(DiagnosticsOptions diagnostics)
internal string GetResourceProviderNamespace(Assembly assembly)
}
internal Azure.Core.Pipeline.ClientRequestIdPolicy : HttpPipelineSynchronousPolicy {
internal string ClientRequestIdHeader
internal string EchoClientRequestId
private ClientRequestIdPolicy <Shared>k__BackingField
public ClientRequestIdPolicy Shared
public ClientRequestIdPolicy get_Shared()
public void OnSendingRequest(HttpMessage message)
}
internal Azure.Core.Pipeline.ContentTypeUtilities : object {
public bool TryGetTextEncoding(string contentType, Encoding& encoding)
}
internal Azure.Core.Pipeline.DefaultRequestFailedDetailsParser : RequestFailedDetailsParser {
public bool TryParse(Response response, ResponseError& error, IDictionary`2& data)
}
internal Azure.Core.Pipeline.DiagnosticScope : ValueType {
private string AzureSdkScopeLabel
internal string OpenTelemetrySchemaAttribute
internal string OpenTelemetrySchemaVersion
private object AzureSdkScopeValue
private ActivityAdapter _activityAdapter
private bool _suppressNestedClientActivities
private bool <IsEnabled>k__BackingField
public bool IsEnabled
internal void .ctor(string scopeName, DiagnosticListener source, object diagnosticSourceArgs, ActivitySource activitySource, ActivityKind kind, bool suppressNestedClientActivities)
public bool get_IsEnabled()
public void AddAttribute(string name, string value)
public void AddIntegerAttribute(string name, int value)
public void AddAttribute(string name, T value, Func`2<T, string> format)
public void AddLink(string traceparent, string tracestate, IDictionary`2<string, string> attributes)
public void Start()
public void SetDisplayName(string displayName)
public void SetStartTime(DateTime dateTime)
public void SetTraceContext(string traceparent, string tracestate)
public void Dispose()
public void Failed(Exception exception)
public void Failed(string errorCode)
}
internal Azure.Core.Pipeline.DiagnosticScopeFactory : object {
private Dictionary`2<string, DiagnosticListener> _listeners
private string _resourceProviderNamespace
private DiagnosticListener _source
private bool _suppressNestedClientActivities
private bool _isStable
private ConcurrentDictionary`2<string, ActivitySource> ActivitySources
private bool <IsActivityEnabled>k__BackingField
public bool IsActivityEnabled
public void .ctor(string clientNamespace, string resourceProviderNamespace, bool isActivityEnabled, bool suppressNestedClientActivities, bool isStable)
public bool get_IsActivityEnabled()
public DiagnosticScope CreateScope(string name, ActivityKind kind)
private ActivitySource GetActivitySource(string ns, string name)
}
public Azure.Core.Pipeline.DisposableHttpPipeline : HttpPipeline {
private bool isTransportOwnedInternally
internal void .ctor(HttpPipelineTransport transport, int perCallIndex, int perRetryIndex, HttpPipelinePolicy[] policies, ResponseClassifier responseClassifier, bool isTransportOwnedInternally)
public void Dispose()
}
internal Azure.Core.Pipeline.GeoRedundantFallbackPolicy : HttpPipelineSynchronousPolicy {
private Fallback _writeFallback
private Fallback _readFallback
public void .ctor(String[] readFallbackHosts, String[] writeFallbackHosts, Nullable`1<TimeSpan> primaryCoolDown)
public void SetHostAffinity(HttpMessage message, bool hostAffinity)
private bool GetHostAffinity(HttpMessage message)
private void SetPrimaryHost(HttpMessage message)
private string GetPrimaryHost(HttpMessage message)
public void OnSendingRequest(HttpMessage message)
private void UpdateHostIfNeeded(HttpMessage message, Fallback fallback)
}
public Azure.Core.Pipeline.HttpClientTransport : HttpPipelineTransport {
internal string MessageForServerCertificateCallback
private HttpClient <Client>k__BackingField
public HttpClientTransport Shared
internal HttpClient Client
internal HttpClient get_Client()
internal void .ctor(HttpPipelineTransportOptions options)
public void .ctor(HttpMessageHandler messageHandler)
public void .ctor(HttpClient client)
public Request CreateRequest()
public void Process(HttpMessage message)
public ValueTask ProcessAsync(HttpMessage message)
private ValueTask ProcessAsync(HttpMessage message, bool async)
private HttpClient CreateDefaultClient(HttpPipelineTransportOptions options)
private HttpMessageHandler CreateDefaultHandler(HttpPipelineTransportOptions options)
private void SetProxySettings(HttpMessageHandler messageHandler)
private HttpRequestMessage BuildRequestMessage(HttpMessage message)
internal bool TryGetHeader(HttpHeaders headers, HttpContent content, string name, String& value)
internal bool TryGetHeader(HttpHeaders headers, HttpContent content, string name, IEnumerable`1& values)
internal IEnumerable`1<HttpHeader> GetHeaders(HttpHeaders headers, HttpContent content)
internal bool RemoveHeader(HttpHeaders headers, HttpContent content, string name)
internal bool ContainsHeader(HttpHeaders headers, HttpContent content, string name)
private string JoinHeaderValues(IEnumerable`1<string> values)
private HttpClientHandler ApplyOptionsToHandler(HttpClientHandler httpHandler, HttpPipelineTransportOptions options)
public void Dispose()
private void SetPropertiesOrOptions(HttpRequestMessage httpRequest, string name, T value)
private bool UseCookies()
}
internal Azure.Core.Pipeline.HttpEnvironmentProxy : object {
private string EnvAllProxyUC
private string EnvAllProxyLC
private string EnvHttpProxyLC
private string EnvHttpProxyUC
private string EnvHttpsProxyLC
private string EnvHttpsProxyUC
private string EnvNoProxyLC
private string EnvNoProxyUC
private string EnvCGI
private Uri _httpProxyUri
private Uri _httpsProxyUri
private String[] _bypass
private ICredentials _credentials
public ICredentials Credentials
public bool TryCreate(IWebProxy& proxy)
private void .ctor(Uri httpProxy, Uri httpsProxy, string bypassList)
private Uri GetUriFromString(string value)
private bool IsMatchInBypassList(Uri input)
public Uri GetProxy(Uri uri)
public bool IsBypassed(Uri uri)
public ICredentials get_Credentials()
public void set_Credentials(ICredentials value)
}
internal Azure.Core.Pipeline.HttpEnvironmentProxyCredentials : object {
private NetworkCredential _httpCred
private NetworkCredential _httpsCred
private Uri _httpProxy
private Uri _httpsProxy
public void .ctor(Uri httpProxy, NetworkCredential httpCred, Uri httpsProxy, NetworkCredential httpsCred)
public NetworkCredential GetCredential(Uri uri, string authType)
public HttpEnvironmentProxyCredentials TryCreate(Uri httpProxy, Uri httpsProxy)
private NetworkCredential GetCredentialsFromString(string value)
}
public Azure.Core.Pipeline.HttpPipeline : object {
private AsyncLocal`1<HttpMessagePropertiesScope> CurrentHttpMessagePropertiesScope
private protected HttpPipelineTransport _transport
private ReadOnlyMemory`1<HttpPipelinePolicy> _pipeline
private bool _internallyConstructed
private int _perCallIndex
private int _perRetryIndex
private ResponseClassifier <ResponseClassifier>k__BackingField
public ResponseClassifier ResponseClassifier
public void .ctor(HttpPipelineTransport transport, HttpPipelinePolicy[] policies, ResponseClassifier responseClassifier)
internal void .ctor(HttpPipelineTransport transport, int perCallIndex, int perRetryIndex, HttpPipelinePolicy[] pipeline, ResponseClassifier responseClassifier)
public Request CreateRequest()
public HttpMessage CreateMessage()
public HttpMessage CreateMessage(RequestContext context)
public HttpMessage CreateMessage(RequestContext context, ResponseClassifier classifier)
public ResponseClassifier get_ResponseClassifier()
public ValueTask SendAsync(HttpMessage message, CancellationToken cancellationToken)
private ValueTask SendAsync(HttpMessage message)
public void Send(HttpMessage message, CancellationToken cancellationToken)
public ValueTask`1<Response> SendRequestAsync(Request request, CancellationToken cancellationToken)
public Response SendRequest(Request request, CancellationToken cancellationToken)
public IDisposable CreateClientRequestIdScope(string clientRequestId)
public IDisposable CreateHttpMessagePropertiesScope(IDictionary`2<string, object> messageProperties)
private ReadOnlyMemory`1<HttpPipelinePolicy> CreateRequestPipeline(HttpPipelinePolicy[] policies, List`1<ValueTuple`2<HttpPipelinePosition, HttpPipelinePolicy>> customPolicies)
private int AddCustomPolicies(List`1<ValueTuple`2<HttpPipelinePosition, HttpPipelinePolicy>> source, HttpPipelinePolicy[] target, HttpPipelinePosition position, int start)
private void AddHttpMessageProperties(HttpMessage message)
}
public Azure.Core.Pipeline.HttpPipelineBuilder : object {
public HttpPipeline Build(ClientOptions options, HttpPipelinePolicy[] perRetryPolicies)
public HttpPipeline Build(ClientOptions options, HttpPipelinePolicy[] perCallPolicies, HttpPipelinePolicy[] perRetryPolicies, ResponseClassifier responseClassifier)
public DisposableHttpPipeline Build(ClientOptions options, HttpPipelinePolicy[] perCallPolicies, HttpPipelinePolicy[] perRetryPolicies, HttpPipelineTransportOptions transportOptions, ResponseClassifier responseClassifier)
public HttpPipeline Build(HttpPipelineOptions options)
public DisposableHttpPipeline Build(HttpPipelineOptions options, HttpPipelineTransportOptions transportOptions)
internal ValueTuple`6<ResponseClassifier, HttpPipelineTransport, int, int, HttpPipelinePolicy[], bool> BuildInternal(HttpPipelineOptions buildOptions, HttpPipelineTransportOptions defaultTransportOptions)
internal TelemetryPolicy CreateTelemetryPolicy(ClientOptions options)
internal void <BuildInternal>g__AddCustomerPolicies|5_0(HttpPipelinePosition position, <>c__DisplayClass5_0& )
internal void <BuildInternal>g__AddNonNullPolicies|5_1(HttpPipelinePolicy[] policiesToAdd, <>c__DisplayClass5_0& )
}
public Azure.Core.Pipeline.HttpPipelineOptions : object {
private ClientOptions <ClientOptions>k__BackingField
private IList`1<HttpPipelinePolicy> <PerCallPolicies>k__BackingField
private IList`1<HttpPipelinePolicy> <PerRetryPolicies>k__BackingField
private ResponseClassifier <ResponseClassifier>k__BackingField
private RequestFailedDetailsParser <RequestFailedDetailsParser>k__BackingField
public ClientOptions ClientOptions
public IList`1<HttpPipelinePolicy> PerCallPolicies
public IList`1<HttpPipelinePolicy> PerRetryPolicies
public ResponseClassifier ResponseClassifier
public RequestFailedDetailsParser RequestFailedDetailsParser
public void .ctor(ClientOptions options)
public ClientOptions get_ClientOptions()
public IList`1<HttpPipelinePolicy> get_PerCallPolicies()
public IList`1<HttpPipelinePolicy> get_PerRetryPolicies()
public ResponseClassifier get_ResponseClassifier()
public void set_ResponseClassifier(ResponseClassifier value)
public RequestFailedDetailsParser get_RequestFailedDetailsParser()
public void set_RequestFailedDetailsParser(RequestFailedDetailsParser value)
}
public Azure.Core.Pipeline.HttpPipelinePolicy : object {
public ValueTask ProcessAsync(HttpMessage message, ReadOnlyMemory`1<HttpPipelinePolicy> pipeline)
public void Process(HttpMessage message, ReadOnlyMemory`1<HttpPipelinePolicy> pipeline)
protected ValueTask ProcessNextAsync(HttpMessage message, ReadOnlyMemory`1<HttpPipelinePolicy> pipeline)
protected void ProcessNext(HttpMessage message, ReadOnlyMemory`1<HttpPipelinePolicy> pipeline)
}
public Azure.Core.Pipeline.HttpPipelineSynchronousPolicy : HttpPipelinePolicy {
private Type[] _onReceivedResponseParameters
private bool _hasOnReceivedResponse
public void Process(HttpMessage message, ReadOnlyMemory`1<HttpPipelinePolicy> pipeline)
public ValueTask ProcessAsync(HttpMessage message, ReadOnlyMemory`1<HttpPipelinePolicy> pipeline)
private ValueTask InnerProcessAsync(HttpMessage message, ReadOnlyMemory`1<HttpPipelinePolicy> pipeline)
public void OnSendingRequest(HttpMessage message)
public void OnReceivedResponse(HttpMessage message)
}
public Azure.Core.Pipeline.HttpPipelineTransport : object {
public void Process(HttpMessage message)
public ValueTask ProcessAsync(HttpMessage message)
public Request CreateRequest()
internal HttpPipelineTransport Create(HttpPipelineTransportOptions options)
}
public Azure.Core.Pipeline.HttpPipelineTransportOptions : object {
private Func`2<ServerCertificateCustomValidationArgs, bool> <ServerCertificateCustomValidationCallback>k__BackingField
private IList`1<X509Certificate2> <ClientCertificates>k__BackingField
private bool <IsClientRedirectEnabled>k__BackingField
public Func`2<ServerCertificateCustomValidationArgs, bool> ServerCertificateCustomValidationCallback
public IList`1<X509Certificate2> ClientCertificates
public bool IsClientRedirectEnabled
public Func`2<ServerCertificateCustomValidationArgs, bool> get_ServerCertificateCustomValidationCallback()
public void set_ServerCertificateCustomValidationCallback(Func`2<ServerCertificateCustomValidationArgs, bool> value)
public IList`1<X509Certificate2> get_ClientCertificates()
public bool get_IsClientRedirectEnabled()
public void set_IsClientRedirectEnabled(bool value)
}
internal Azure.Core.Pipeline.HttpPipelineTransportPolicy : HttpPipelinePolicy {
private HttpPipelineTransport _transport
private HttpMessageSanitizer _sanitizer
private RequestFailedDetailsParser _errorParser
public void .ctor(HttpPipelineTransport transport, HttpMessageSanitizer sanitizer, RequestFailedDetailsParser failureContentExtractor)
public ValueTask ProcessAsync(HttpMessage message, ReadOnlyMemory`1<HttpPipelinePolicy> pipeline)
public void Process(HttpMessage message, ReadOnlyMemory`1<HttpPipelinePolicy> pipeline)
}
internal Azure.Core.Pipeline.LoggingPolicy : HttpPipelinePolicy {
private double RequestTooLongTime
private AzureCoreEventSource s_eventSource
private bool _logContent
private int _maxLength
private HttpMessageSanitizer _sanitizer
private string _assemblyName
public void .ctor(bool logContent, int maxLength, HttpMessageSanitizer sanitizer, string assemblyName)
public void Process(HttpMessage message, ReadOnlyMemory`1<HttpPipelinePolicy> pipeline)
public ValueTask ProcessAsync(HttpMessage message, ReadOnlyMemory`1<HttpPipelinePolicy> pipeline)
private ValueTask ProcessAsync(HttpMessage message, ReadOnlyMemory`1<HttpPipelinePolicy> pipeline, bool async)
}
internal Azure.Core.Pipeline.ReadClientRequestIdPolicy : HttpPipelineSynchronousPolicy {
public string MessagePropertyKey
private ReadClientRequestIdPolicy <Shared>k__BackingField
public ReadClientRequestIdPolicy Shared
public ReadClientRequestIdPolicy get_Shared()
public void OnSendingRequest(HttpMessage message)
}
internal Azure.Core.Pipeline.ReadOnlyStream : Stream {
public bool CanWrite
public bool get_CanWrite()
public void Write(Byte[] buffer, int offset, int count)
public void SetLength(long value)
public void Flush()
}
internal Azure.Core.Pipeline.ReadTimeoutStream : ReadOnlyStream {
private Stream _stream
private TimeSpan _readTimeout
private CancellationTokenSource _cancellationTokenSource
public bool CanRead
public bool CanSeek
public long Length
public long Position
public int ReadTimeout
public void .ctor(Stream stream, TimeSpan readTimeout)
public int Read(Byte[] buffer, int offset, int count)
public Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken)
private CancellationTokenSource StartTimeout(CancellationToken additionalToken, Boolean& dispose)
private void InitializeTokenSource()
private void DisposeStream()
private void StopTimeout(CancellationTokenSource source, bool dispose)
public long Seek(long offset, SeekOrigin origin)
public bool get_CanRead()
public bool get_CanSeek()
public long get_Length()
public long get_Position()
public void set_Position(long value)
public int get_ReadTimeout()
public void set_ReadTimeout(int value)
private void UpdateReadTimeout()
public void Close()
protected void Dispose(bool disposing)
}
public Azure.Core.Pipeline.RedirectPolicy : HttpPipelinePolicy {
private int _maxAutomaticRedirections
private bool _allowAutoRedirects
private RedirectPolicy <Shared>k__BackingField
internal RedirectPolicy Shared
internal RedirectPolicy get_Shared()
internal void .ctor(bool allowAutoRedirect)
public void SetAllowAutoRedirect(HttpMessage message, bool allowAutoRedirect)
internal ValueTask ProcessAsync(HttpMessage message, ReadOnlyMemory`1<HttpPipelinePolicy> pipeline, bool async)
private Uri GetUriForRedirect(Request request, Response response)
private bool RequestRequiresForceGet(int statusCode, RequestMethod requestMethod)
internal bool IsSupportedSecureScheme(string scheme)
internal bool IsSecureWebSocketScheme(string scheme)
public ValueTask ProcessAsync(HttpMessage message, ReadOnlyMemory`1<HttpPipelinePolicy> pipeline)
public void Process(HttpMessage message, ReadOnlyMemory`1<HttpPipelinePolicy> pipeline)
private bool TryParseValue(string value, Uri& parsedValue)
private string DecodeUtf8FromString(string input)
private bool AllowAutoRedirect(HttpMessage message)
}
internal Azure.Core.Pipeline.RequestActivityPolicy : HttpPipelinePolicy {
private bool _isDistributedTracingEnabled
private string _resourceProviderNamespace
private HttpMessageSanitizer _sanitizer
private string TraceParentHeaderName
private string TraceStateHeaderName
private string RequestIdHeaderName
private DiagnosticListener s_diagnosticSource
private ActivitySource s_activitySource
private bool ShouldCreateActivity
private bool IsActivitySourceEnabled
public void .ctor(bool isDistributedTracingEnabled, string resourceProviderNamespace, HttpMessageSanitizer httpMessageSanitizer)
public ValueTask ProcessAsync(HttpMessage message, ReadOnlyMemory`1<HttpPipelinePolicy> pipeline)
public void Process(HttpMessage message, ReadOnlyMemory`1<HttpPipelinePolicy> pipeline)
private ValueTask ProcessAsync(HttpMessage message, ReadOnlyMemory`1<HttpPipelinePolicy> pipeline, bool async)
private DiagnosticScope CreateDiagnosticScope(T sourceArgs)
private ValueTask ProcessNextAsync(HttpMessage message, ReadOnlyMemory`1<HttpPipelinePolicy> pipeline, bool async)
private bool get_ShouldCreateActivity()
private bool get_IsActivitySourceEnabled()
private string <ProcessAsync>b__11_0(RequestUriBuilder u)
}
internal Azure.Core.Pipeline.ResponseBodyPolicy : HttpPipelinePolicy {
private int DefaultCopyBufferSize
private TimeSpan _networkTimeout
public void .ctor(TimeSpan networkTimeout)
public ValueTask ProcessAsync(HttpMessage message, ReadOnlyMemory`1<HttpPipelinePolicy> pipeline)
public void Process(HttpMessage message, ReadOnlyMemory`1<HttpPipelinePolicy> pipeline)
private ValueTask ProcessAsync(HttpMessage message, ReadOnlyMemory`1<HttpPipelinePolicy> pipeline, bool async)
private Task CopyToAsync(Stream source, Stream destination, CancellationTokenSource cancellationTokenSource)
private void CopyTo(Stream source, Stream destination, CancellationTokenSource cancellationTokenSource)
internal void ThrowIfCancellationRequestedOrTimeout(CancellationToken originalToken, CancellationToken timeoutToken, Exception inner, TimeSpan timeout)
}
public Azure.Core.Pipeline.RetryPolicy : HttpPipelinePolicy {
private int _maxRetries
private DelayStrategy _delayStrategy
public void .ctor(int maxRetries, DelayStrategy delayStrategy)
public ValueTask ProcessAsync(HttpMessage message, ReadOnlyMemory`1<HttpPipelinePolicy> pipeline)
public void Process(HttpMessage message, ReadOnlyMemory`1<HttpPipelinePolicy> pipeline)
private ValueTask ProcessAsync(HttpMessage message, ReadOnlyMemory`1<HttpPipelinePolicy> pipeline, bool async)
internal Task WaitAsync(TimeSpan time, CancellationToken cancellationToken)
internal void Wait(TimeSpan time, CancellationToken cancellationToken)
protected internal bool ShouldRetry(HttpMessage message, Exception exception)
protected internal ValueTask`1<bool> ShouldRetryAsync(HttpMessage message, Exception exception)
private bool ShouldRetryInternal(HttpMessage message, Exception exception)
internal TimeSpan GetNextDelay(HttpMessage message, Nullable`1<TimeSpan> retryAfter)
internal ValueTask`1<TimeSpan> GetNextDelayAsync(HttpMessage message, Nullable`1<TimeSpan> retryAfter)
protected internal void OnSendingRequest(HttpMessage message)
protected internal ValueTask OnSendingRequestAsync(HttpMessage message)
protected internal void OnRequestSent(HttpMessage message)
protected internal ValueTask OnRequestSentAsync(HttpMessage message)
private TimeSpan GetNextDelayInternal(HttpMessage message)
}
public Azure.Core.Pipeline.ServerCertificateCustomValidationArgs : object {
private X509Certificate2 <Certificate>k__BackingField
private X509Chain <CertificateAuthorityChain>k__BackingField
private SslPolicyErrors <SslPolicyErrors>k__BackingField
public X509Certificate2 Certificate
public X509Chain CertificateAuthorityChain
public SslPolicyErrors SslPolicyErrors
public X509Certificate2 get_Certificate()
public X509Chain get_CertificateAuthorityChain()
public SslPolicyErrors get_SslPolicyErrors()
public void .ctor(X509Certificate2 certificate, X509Chain certificateAuthorityChain, SslPolicyErrors sslPolicyErrors)
}
internal Azure.Core.Pipeline.ServicePointHelpers : object {
private int RuntimeDefaultConnectionLimit
private int IncreasedConnectionLimit
private int IncreasedConnectionLeaseTimeout
private TimeSpan DefaultConnectionLeaseTimeoutTimeSpan
private TimeSpan IncreasedConnectionLeaseTimeoutTimeSpan
public void SetLimits(HttpMessageHandler messageHandler)
}
internal Azure.Core.Pipeline.TaskExtensions : object {
public WithCancellationTaskAwaitable AwaitWithCancellation(Task task, CancellationToken cancellationToken)
public WithCancellationTaskAwaitable`1<T> AwaitWithCancellation(Task`1<T> task, CancellationToken cancellationToken)
public WithCancellationValueTaskAwaitable`1<T> AwaitWithCancellation(ValueTask`1<T> task, CancellationToken cancellationToken)
public T EnsureCompleted(Task`1<T> task)
public void EnsureCompleted(Task task)
public T EnsureCompleted(ValueTask`1<T> task)
public void EnsureCompleted(ValueTask task)
public Enumerable`1<T> EnsureSyncEnumerable(IAsyncEnumerable`1<T> asyncEnumerable)
public ConfiguredValueTaskAwaitable`1<T> EnsureCompleted(ConfiguredValueTaskAwaitable`1<T> awaitable, bool async)
public ConfiguredValueTaskAwaitable EnsureCompleted(ConfiguredValueTaskAwaitable awaitable, bool async)
private void VerifyTaskCompleted(bool isCompleted)
}
internal Azure.Core.Pipeline.TelemetryPolicy : HttpPipelineSynchronousPolicy {
private string _defaultHeader
public void .ctor(TelemetryDetails telemetryDetails)
public void OnSendingRequest(HttpMessage message)
}
internal Azure.Core.Pipeline.ThreadSafeRandom : Random {
private Random _random
public int Next()
public int Next(int minValue, int maxValue)
public int Next(int maxValue)
public double NextDouble()
public void NextBytes(Byte[] buffer)
}
public Azure.Core.Request : object {
private RequestUriBuilder _uri
private RequestMethod <Method>k__BackingField
private RequestContent <Content>k__BackingField
public RequestUriBuilder Uri
public RequestMethod Method
public RequestContent Content
public string ClientRequestId
public RequestHeaders Headers
public RequestUriBuilder get_Uri()
public void set_Uri(RequestUriBuilder value)
public RequestMethod get_Method()
public void set_Method(RequestMethod value)
public RequestContent get_Content()
public void set_Content(RequestContent value)
protected internal void AddHeader(string name, string value)
protected internal bool TryGetHeader(string name, String& value)
protected internal bool TryGetHeaderValues(string name, IEnumerable`1& values)
protected internal bool ContainsHeader(string name)
protected internal void SetHeader(string name, string value)
protected internal bool RemoveHeader(string name)
protected internal IEnumerable`1<HttpHeader> EnumerateHeaders()
public string get_ClientRequestId()
public void set_ClientRequestId(string value)
public RequestHeaders get_Headers()
public void Dispose()
}
public Azure.Core.RequestContent : object {
internal string SerializationRequiresUnreferencedCode
private Encoding s_UTF8NoBomEncoding
public RequestContent Create(Stream stream)
public RequestContent Create(Byte[] bytes)
public RequestContent Create(Byte[] bytes, int index, int length)
public RequestContent Create(ReadOnlyMemory`1<byte> bytes)
public RequestContent Create(ReadOnlySequence`1<byte> bytes)
public RequestContent Create(string content)
public RequestContent Create(BinaryData content)
public RequestContent Create(DynamicData content)
public RequestContent Create(object serializable)
public RequestContent Create(object serializable, ObjectSerializer serializer)
public RequestContent Create(object serializable, JsonPropertyNames propertyNameFormat, string dateTimeFormat)
public RequestContent op_Implicit(string content)
public RequestContent op_Implicit(BinaryData content)
public RequestContent op_Implicit(DynamicData content)
public Task WriteToAsync(Stream stream, CancellationToken cancellation)
public void WriteTo(Stream stream, CancellationToken cancellation)
public bool TryComputeLength(Int64& length)
public void Dispose()
}
public Azure.Core.RequestFailedDetailsParser : object {
public bool TryParse(Response response, ResponseError& error, IDictionary`2& data)
}
public Azure.Core.RequestHeaders : ValueType {
private Request _request
internal void .ctor(Request request)
public IEnumerator`1<HttpHeader> GetEnumerator()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
public void Add(HttpHeader header)
public void Add(string name, string value)
public bool TryGetValue(string name, String& value)
public bool TryGetValues(string name, IEnumerable`1& values)
public bool Contains(string name)
public void SetValue(string name, string value)
public bool Remove(string name)
}
public Azure.Core.RequestMethod : ValueType {
private string <Method>k__BackingField
private RequestMethod <Get>k__BackingField
private RequestMethod <Post>k__BackingField
private RequestMethod <Put>k__BackingField
private RequestMethod <Patch>k__BackingField
private RequestMethod <Delete>k__BackingField
private RequestMethod <Head>k__BackingField
private RequestMethod <Options>k__BackingField
private RequestMethod <Trace>k__BackingField
public string Method
public RequestMethod Get
public RequestMethod Post
public RequestMethod Put
public RequestMethod Patch
public RequestMethod Delete
public RequestMethod Head
public RequestMethod Options
public RequestMethod Trace
public string get_Method()
public RequestMethod get_Get()
public RequestMethod get_Post()
public RequestMethod get_Put()
public RequestMethod get_Patch()
public RequestMethod get_Delete()
public RequestMethod get_Head()
public RequestMethod get_Options()
public RequestMethod get_Trace()
public void .ctor(string method)
public RequestMethod Parse(string method)
public bool Equals(RequestMethod other)
public bool Equals(object obj)
public int GetHashCode()
public bool op_Equality(RequestMethod left, RequestMethod right)
public bool op_Inequality(RequestMethod left, RequestMethod right)
public string ToString()
}
public Azure.Core.RequestUriBuilder : object {
private char QuerySeparator
private char PathSeparator
private StringBuilder _pathAndQuery
private int _queryIndex
private Uri _uri
private int _port
private string _host
private string _scheme
public string Scheme
public string Host
public int Port
public string Query
public string Path
protected bool HasPath
protected bool HasQuery
private int PathLength
private int QueryLength
public string PathAndQuery
private bool HasDefaultPortForScheme
public string get_Scheme()
public void set_Scheme(string value)
public string get_Host()
public void set_Host(string value)
public int get_Port()
public void set_Port(int value)
public string get_Query()
public void set_Query(string value)
public string get_Path()
public void set_Path(string value)
protected bool get_HasPath()
protected bool get_HasQuery()
private int get_PathLength()
private int get_QueryLength()
public string get_PathAndQuery()
public void Reset(Uri value)
public Uri ToUri()
public void AppendQuery(string name, string value)
public void AppendQuery(string name, string value, bool escapeValue)
public void AppendQuery(ReadOnlySpan`1<char> name, ReadOnlySpan`1<char> value, bool escapeValue)
public void AppendPath(string value)
public void AppendPath(string value, bool escape)
public void AppendPath(ReadOnlySpan`1<char> value, bool escape)
public string ToString()
private bool get_HasDefaultPortForScheme()
private void ResetUri()
}
public Azure.Core.ResourceIdentifier : object {
internal char Separator
private string RootStringValue
private string ProvidersKey
private string SubscriptionsKey
private string LocationsKey
private string ResourceGroupKey
private string SubscriptionStart
private string ProviderStart
private bool _initialized
private string _stringValue
private ResourceType _resourceType
private string _name
private ResourceIdentifier _parent
private bool _isProviderResource
private string _subscriptionId
private string _provider
private Nullable`1<AzureLocation> _location
private string _resourceGroupName
public ResourceIdentifier Root
private string StringValue
public ResourceType ResourceType
public string Name
public ResourceIdentifier Parent
internal bool IsProviderResource
public string SubscriptionId
public string Provider
public Nullable`1<AzureLocation> Location
public string ResourceGroupName
public void .ctor(string resourceId)
private void .ctor(ResourceIdentifier parent, ResourceType resourceType, string resourceName, bool isProviderResource, SpecialType specialType)
private void Init(ResourceIdentifier parent, ResourceType resourceType, string resourceName, bool isProviderResource, SpecialType specialType)
private string Parse()
private string CheckSubscriptionFormat()
private T GetValue(T& value)
private ResourceType ChooseResourceType(ReadOnlySpan`1<char> resourceTypeName, ResourceIdentifier parent, SpecialType& specialType)
private string GetNextParts(ResourceIdentifier parent, ReadOnlySpan`1& remaining, ReadOnlySpan`1& nextWord, Nullable`1& parts)
private ReadOnlySpan`1<char> PopNextWord(ReadOnlySpan`1& remaining)
private string get_StringValue()
public ResourceType get_ResourceType()
public string get_Name()
public ResourceIdentifier get_Parent()
internal bool get_IsProviderResource()
public string get_SubscriptionId()
public string get_Provider()
public Nullable`1<AzureLocation> get_Location()
public string get_ResourceGroupName()
private string ToResourceString()
public string ToString()
public bool Equals(ResourceIdentifier other)
public int CompareTo(ResourceIdentifier other)
public bool Equals(object obj)
public int GetHashCode()
public string op_Implicit(ResourceIdentifier id)
public bool op_Equality(ResourceIdentifier left, ResourceIdentifier right)
public bool op_Inequality(ResourceIdentifier left, ResourceIdentifier right)
public bool op_LessThan(ResourceIdentifier left, ResourceIdentifier right)
public bool op_LessThanOrEqual(ResourceIdentifier left, ResourceIdentifier right)
public bool op_GreaterThan(ResourceIdentifier left, ResourceIdentifier right)
public bool op_GreaterThanOrEqual(ResourceIdentifier left, ResourceIdentifier right)
public ResourceIdentifier Parse(string input)
public bool TryParse(string input, ResourceIdentifier& result)
public ResourceIdentifier AppendProviderResource(string providerNamespace, string resourceType, string resourceName)
public ResourceIdentifier AppendChildResource(string childResourceType, string childResourceName)
private void ValidateProviderResourceParameters(string providerNamespace, string resourceType, string resourceName)
private void ValidateChildResourceParameters(string childResourceType, string childResourceName)
private void ValidatePathSegment(string segment, string parameterName)
}
public Azure.Core.ResourceType : ValueType {
internal ResourceType Tenant
internal ResourceType Subscription
internal ResourceType ResourceGroup
internal ResourceType Provider
internal string ResourceNamespace
private string _stringValue
private string <Namespace>k__BackingField
private string <Type>k__BackingField
public string Namespace
public string Type
public void .ctor(string resourceType)
internal void .ctor(string providerNamespace, string name)
private void .ctor(string providerNamespace, string name, string fullName)
internal ResourceType AppendChild(string childType)
public string GetLastType()
public string get_Namespace()
public string get_Type()
public ResourceType op_Implicit(string resourceType)
public string op_Implicit(ResourceType resourceType)
public bool op_Equality(ResourceType left, ResourceType right)
public bool op_Inequality(ResourceType left, ResourceType right)
public bool Equals(ResourceType other)
public string ToString()
public bool Equals(object other)
public int GetHashCode()
}
public Azure.Core.ResponseClassificationHandler : object {
public bool TryClassify(HttpMessage message, Boolean& isError)
}
public Azure.Core.ResponseClassifier : object {
private ResponseClassifier <Shared>k__BackingField
internal ResponseClassifier Shared
internal ResponseClassifier get_Shared()
public bool IsRetriableResponse(HttpMessage message)
public bool IsRetriableException(Exception exception)
public bool IsRetriable(HttpMessage message, Exception exception)
public bool IsErrorResponse(HttpMessage message)
}
public Azure.Core.ResponseHeaders : ValueType {
private string RetryAfterHeaderName
private string RetryAfterMsHeaderName
private string XRetryAfterMsHeaderName
private Response _response
public Nullable`1<DateTimeOffset> Date
public string ContentType
public Nullable`1<int> ContentLength
public Nullable`1<long> ContentLengthLong
public Nullable`1<ETag> ETag
public string RequestId
internal Nullable`1<TimeSpan> RetryAfter
internal void .ctor(Response response)
public Nullable`1<DateTimeOffset> get_Date()
public string get_ContentType()
public Nullable`1<int> get_ContentLength()
public Nullable`1<long> get_ContentLengthLong()
public Nullable`1<ETag> get_ETag()
public string get_RequestId()
internal Nullable`1<TimeSpan> get_RetryAfter()
public IEnumerator`1<HttpHeader> GetEnumerator()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
public bool TryGetValue(string name, String& value)
public bool TryGetValues(string name, IEnumerable`1& values)
public bool Contains(string name)
}
public Azure.Core.RetryMode : Enum {
public int value__
public RetryMode Fixed
public RetryMode Exponential
}
public Azure.Core.RetryOptions : object {
private int <MaxRetries>k__BackingField
private TimeSpan <Delay>k__BackingField
private TimeSpan <MaxDelay>k__BackingField
private RetryMode <Mode>k__BackingField
private TimeSpan <NetworkTimeout>k__BackingField
public int MaxRetries
public TimeSpan Delay
public TimeSpan MaxDelay
public RetryMode Mode
public TimeSpan NetworkTimeout
internal void .ctor(RetryOptions retryOptions)
public int get_MaxRetries()
public void set_MaxRetries(int value)
public TimeSpan get_Delay()
public void set_Delay(TimeSpan value)
public TimeSpan get_MaxDelay()
public void set_MaxDelay(TimeSpan value)
public RetryMode get_Mode()
public void set_Mode(RetryMode value)
public TimeSpan get_NetworkTimeout()
public void set_NetworkTimeout(TimeSpan value)
}
internal Azure.Core.RuntimeInformationWrapper : object {
public string FrameworkDescription
public string OSDescription
public Architecture OSArchitecture
public Architecture ProcessArchitecture
public string get_FrameworkDescription()
public string get_OSDescription()
public Architecture get_OSArchitecture()
public Architecture get_ProcessArchitecture()
public bool IsOSPlatform(OSPlatform osPlatform)
}
internal Azure.Core.SequentialDelayStrategy : DelayStrategy {
private TimeSpan[] _pollingSequence
private TimeSpan _maxDelay
protected TimeSpan GetNextDelayCore(Response response, int retryNumber)
}
public Azure.Core.Serialization.DynamicData : object {
internal string RoundTripFormat
internal string UnixFormat
private MethodInfo GetPropertyMethod
private MethodInfo SetPropertyMethod
private MethodInfo GetEnumerableMethod
private MethodInfo GetViaIndexerMethod
private MethodInfo SetViaIndexerMethod
private MutableJsonElement _element
private DynamicDataOptions _options
private JsonSerializerOptions _serializerOptions
internal string SerializationRequiresUnreferencedCodeClass
private Dictionary`2<Type, MethodInfo> CastFromOperators
private string DebuggerDisplay
internal void .ctor(MutableJsonElement element, DynamicDataOptions options)
internal void WriteTo(Stream stream)
private object GetProperty(string name)
private string FormatPropertyName(string value)
private object GetViaIndexer(object index)
private IEnumerable GetEnumerable()
private object SetProperty(string name, object value)
private bool HasTypeConverter(object value)
private JsonElement ConvertType(object value)
private object SetViaIndexer(object index, object value)
private void SetPropertyInternal(string name, object value)
private void SetInternal(MutableJsonElement& element, object value)
private T ConvertTo()
public string ToString()
public void Dispose()
public bool Equals(object obj)
internal bool Equals(DynamicData other)
private bool NumberEqual(DynamicData other)
public int GetHashCode()
private string get_DebuggerDisplay()
private DynamicMetaObject System.Dynamic.IDynamicMetaObjectProvider.GetMetaObject(Expression parameter)
public bool op_Implicit(DynamicData value)
public string op_Implicit(DynamicData value)
public byte op_Implicit(DynamicData value)
public sbyte op_Implicit(DynamicData value)
public short op_Implicit(DynamicData value)
public ushort op_Implicit(DynamicData value)
public int op_Implicit(DynamicData value)
public UInt32 op_Implicit(DynamicData value)
public long op_Implicit(DynamicData value)
public ulong op_Implicit(DynamicData value)
public float op_Implicit(DynamicData value)
public double op_Implicit(DynamicData value)
public decimal op_Implicit(DynamicData value)
public DateTime op_Explicit(DynamicData value)
public DateTimeOffset op_Explicit(DynamicData value)
public Guid op_Explicit(DynamicData value)
public bool op_Equality(DynamicData left, object right)
public bool op_Inequality(DynamicData left, object right)
private string GetInvalidKindExceptionText(Type target, MutableJsonElement element)
private string GetInvalidFormatExceptionText(Type target, MutableJsonElement element)
}
internal Azure.Core.Serialization.DynamicDataOptions : object {
private JsonPropertyNames <PropertyNameFormat>k__BackingField
private string <DateTimeFormat>k__BackingField
public JsonPropertyNames PropertyNameFormat
public string DateTimeFormat
public void .ctor(DynamicDataOptions options)
public JsonPropertyNames get_PropertyNameFormat()
public void set_PropertyNameFormat(JsonPropertyNames value)
public string get_DateTimeFormat()
public void set_DateTimeFormat(string value)
internal JsonSerializerOptions ToSerializerOptions(DynamicDataOptions options)
internal DynamicDataOptions FromSerializerOptions(JsonSerializerOptions options)
}
internal Azure.Core.Serialization.DynamicDataProperty : ValueType {
private string <Name>k__BackingField
private DynamicData <Value>k__BackingField
public string Name
public DynamicData Value
internal void .ctor(string name, DynamicData value)
public string get_Name()
public DynamicData get_Value()
private DynamicMetaObject System.Dynamic.IDynamicMetaObjectProvider.GetMetaObject(Expression parameter)
}
public Azure.Core.Serialization.IMemberNameConverter {
public string ConvertMemberName(MemberInfo member)
}
public Azure.Core.Serialization.JsonObjectSerializer : ObjectSerializer {
private int JsonIgnoreConditionAlways
private PropertyInfo s_jsonIgnoreAttributeCondition
private bool s_jsonIgnoreAttributeConditionInitialized
private ConcurrentDictionary`2<MemberInfo, string> _cache
private JsonSerializerOptions _options
private JsonObjectSerializer <Default>k__BackingField
public JsonObjectSerializer Default
public JsonObjectSerializer get_Default()
public void .ctor(JsonSerializerOptions options)
public void Serialize(Stream stream, object value, Type inputType, CancellationToken cancellationToken)
public ValueTask SerializeAsync(Stream stream, object value, Type inputType, CancellationToken cancellationToken)
public object Deserialize(Stream stream, Type returnType, CancellationToken cancellationToken)
public ValueTask`1<object> DeserializeAsync(Stream stream, Type returnType, CancellationToken cancellationToken)
public BinaryData Serialize(object value, Type inputType, CancellationToken cancellationToken)
public ValueTask`1<BinaryData> SerializeAsync(object value, Type inputType, CancellationToken cancellationToken)
private BinaryData SerializeToBinaryDataInternal(object value, Type inputType)
private string Azure.Core.Serialization.IMemberNameConverter.ConvertMemberName(MemberInfo member)
private int GetCondition(JsonIgnoreAttribute attribute)
private string GetPropertyName(MemberInfo memberInfo)
private string <Azure.Core.Serialization.IMemberNameConverter.ConvertMemberName>b__17_0(MemberInfo m)
}
public Azure.Core.Serialization.JsonPropertyNames : Enum {
public int value__
public JsonPropertyNames UseExact
public JsonPropertyNames CamelCase
}
public Azure.Core.Serialization.ObjectSerializer : object {
public void Serialize(Stream stream, object value, Type inputType, CancellationToken cancellationToken)
public ValueTask SerializeAsync(Stream stream, object value, Type inputType, CancellationToken cancellationToken)
public object Deserialize(Stream stream, Type returnType, CancellationToken cancellationToken)
public ValueTask`1<object> DeserializeAsync(Stream stream, Type returnType, CancellationToken cancellationToken)
public BinaryData Serialize(object value, Type inputType, CancellationToken cancellationToken)
public ValueTask`1<BinaryData> SerializeAsync(object value, Type inputType, CancellationToken cancellationToken)
private ValueTask`1<BinaryData> SerializeToBinaryDataInternalAsync(object value, Type inputType, bool async, CancellationToken cancellationToken)
}
internal Azure.Core.Shared.EventSourceEventFormatting : object {
public string Format(EventWrittenEventArgs eventData)
private void ProcessPayloadArray(Object[] payloadArray)
private object FormatValue(object o)
}
public Azure.Core.StatusCodeClassifier : ResponseClassifier {
private int Length
private UInt64[] _successCodes
private ResponseClassificationHandler[] <Handlers>k__BackingField
internal ResponseClassificationHandler[] Handlers
internal ResponseClassificationHandler[] get_Handlers()
internal void set_Handlers(ResponseClassificationHandler[] value)
public void .ctor(ReadOnlySpan`1<ushort> successStatusCodes)
private void .ctor(UInt64[] successCodes, ResponseClassificationHandler[] handlers)
public bool IsErrorResponse(HttpMessage message)
internal StatusCodeClassifier Clone()
internal void AddClassifier(int statusCode, bool isError)
private bool IsSuccessCode(int statusCode)
}
internal Azure.Core.StreamHelperExtensions : object {
private int _maxReadBufferSize
public Task DrainAsync(Stream stream, CancellationToken cancellationToken)
public Task DrainAsync(Stream stream, Nullable`1<long> limit, CancellationToken cancellationToken)
public Task DrainAsync(Stream stream, ArrayPool`1<byte> bytePool, Nullable`1<long> limit, CancellationToken cancellationToken)
}
internal Azure.Core.StringExtensions : object {
public int IndexOfOrdinal(string s, char c)
public int GetHashCodeOrdinal(string s)
}
public Azure.Core.SyncAsyncEventHandler`1 : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public Task Invoke(T e)
public IAsyncResult BeginInvoke(T e, AsyncCallback callback, object object)
public Task EndInvoke(IAsyncResult result)
}
public Azure.Core.TelemetryDetails : object {
private int MaxApplicationIdLength
private string _userAgent
private Assembly <Assembly>k__BackingField
private string <ApplicationId>k__BackingField
public Assembly Assembly
public string ApplicationId
public Assembly get_Assembly()
public string get_ApplicationId()
public void .ctor(Assembly assembly, string applicationId)
internal void .ctor(Assembly assembly, string applicationId, RuntimeInformationWrapper runtimeInformation)
public void Apply(HttpMessage message)
internal string GenerateUserAgentString(Assembly clientAssembly, string applicationId, RuntimeInformationWrapper runtimeInformation)
public string ToString()
private string EscapeProductInformation(string productInfo)
}
public Azure.Core.TokenCredential : object {
public ValueTask`1<AccessToken> GetTokenAsync(TokenRequestContext requestContext, CancellationToken cancellationToken)
public AccessToken GetToken(TokenRequestContext requestContext, CancellationToken cancellationToken)
}
public Azure.Core.TokenRequestContext : ValueType {
private String[] <Scopes>k__BackingField
private string <ParentRequestId>k__BackingField
private string <Claims>k__BackingField
private string <TenantId>k__BackingField
private bool <IsCaeEnabled>k__BackingField
public String[] Scopes
public string ParentRequestId
public string Claims
public string TenantId
public bool IsCaeEnabled
public void .ctor(String[] scopes, string parentRequestId)
public void .ctor(String[] scopes, string parentRequestId, string claims)
public void .ctor(String[] scopes, string parentRequestId, string claims, string tenantId)
public void .ctor(String[] scopes, string parentRequestId, string claims, string tenantId, bool isCaeEnabled)
public String[] get_Scopes()
public string get_ParentRequestId()
public string get_Claims()
public string get_TenantId()
public bool get_IsCaeEnabled()
}
internal Azure.Core.TypeReferenceTypeAttribute : Attribute {
private bool <IgnoreExtraProperties>k__BackingField
private String[] <InternalPropertiesToInclude>k__BackingField
public bool IgnoreExtraProperties
public String[] InternalPropertiesToInclude
public void .ctor(bool ignoreExtraProperties, String[] internalPropertiesToInclude)
public bool get_IgnoreExtraProperties()
public String[] get_InternalPropertiesToInclude()
}
public Azure.ErrorOptions : Enum {
public int value__
public ErrorOptions Default
public ErrorOptions NoThrow
}
public Azure.ETag : ValueType {
private char QuoteCharacter
private string QuoteString
private string WeakETagPrefix
private string DefaultFormat
private string HeaderFormat
private string _value
public ETag All
public void .ctor(string etag)
public bool op_Equality(ETag left, ETag right)
public bool op_Inequality(ETag left, ETag right)
public bool Equals(ETag other)
public bool Equals(string other)
public bool Equals(object obj)
public int GetHashCode()
public string ToString()
public string ToString(string format)
internal ETag Parse(string value)
private bool IsValidQuotedFormat(string value)
}
internal Azure.ETagConverter : JsonConverter`1<ETag> {
public ETag Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options)
public void Write(Utf8JsonWriter writer, ETag value, JsonSerializerOptions options)
}
public Azure.HttpAuthorization : object {
private string <Scheme>k__BackingField
private string <Parameter>k__BackingField
public string Scheme
public string Parameter
public string get_Scheme()
public string get_Parameter()
public void .ctor(string scheme, string parameter)
public string ToString()
}
public Azure.HttpRange : ValueType {
private string Unit
private long <Offset>k__BackingField
private Nullable`1<long> <Length>k__BackingField
public long Offset
public Nullable`1<long> Length
public long get_Offset()
public Nullable`1<long> get_Length()
public void .ctor(long offset, Nullable`1<long> length)
public string ToString()
public bool op_Equality(HttpRange left, HttpRange right)
public bool op_Inequality(HttpRange left, HttpRange right)
public bool Equals(HttpRange other)
public bool Equals(object obj)
public int GetHashCode()
}
public Azure.JsonPatchDocument : object {
private ReadOnlyMemory`1<byte> _rawDocument
private ObjectSerializer _serializer
private Collection`1<JsonPatchOperation> _operations
public void .ctor(ObjectSerializer serializer)
public void .ctor(ReadOnlyMemory`1<byte> rawDocument)
public void .ctor(ReadOnlyMemory`1<byte> rawDocument, ObjectSerializer serializer)
public void AppendAddRaw(string path, string rawJsonValue)
public void AppendAdd(string path, T value)
public void AppendReplaceRaw(string path, string rawJsonValue)
public void AppendReplace(string path, T value)
public void AppendCopy(string from, string path)
public void AppendMove(string from, string path)
public void AppendRemove(string path)
public void AppendTestRaw(string path, string rawJsonValue)
public void AppendTest(string path, T value)
public ReadOnlyMemory`1<byte> ToBytes()
public string ToString()
private void WriteTo(Utf8JsonWriter writer)
private string Serialize(T value)
}
public Azure.MatchConditions : object {
private Nullable`1<ETag> <IfMatch>k__BackingField
private Nullable`1<ETag> <IfNoneMatch>k__BackingField
public Nullable`1<ETag> IfMatch
public Nullable`1<ETag> IfNoneMatch
public Nullable`1<ETag> get_IfMatch()
public void set_IfMatch(Nullable`1<ETag> value)
public Nullable`1<ETag> get_IfNoneMatch()
public void set_IfNoneMatch(Nullable`1<ETag> value)
}
public Azure.Messaging.CloudEvent : object {
private BinaryData <Data>k__BackingField
private string _id
private CloudEventDataFormat <DataFormat>k__BackingField
private string _source
private string _type
private string <SpecVersion>k__BackingField
private Nullable`1<DateTimeOffset> <Time>k__BackingField
private string <DataSchema>k__BackingField
private string <DataContentType>k__BackingField
private Type <DataSerializationType>k__BackingField
private string <Subject>k__BackingField
private IDictionary`2<string, object> <ExtensionAttributes>k__BackingField
public BinaryData Data
public string Id
internal CloudEventDataFormat DataFormat
public string Source
public string Type
internal string SpecVersion
public Nullable`1<DateTimeOffset> Time
public string DataSchema
public string DataContentType
internal Type DataSerializationType
public string Subject
public IDictionary`2<string, object> ExtensionAttributes
public void .ctor(string source, string type, object jsonSerializableData, Type dataSerializationType)
public void .ctor(string source, string type, BinaryData data, string dataContentType, CloudEventDataFormat dataFormat)
public BinaryData get_Data()
public void set_Data(BinaryData value)
public string get_Id()
public void set_Id(string value)
internal CloudEventDataFormat get_DataFormat()
internal void set_DataFormat(CloudEventDataFormat value)
public string get_Source()
public void set_Source(string value)
public string get_Type()
public void set_Type(string value)
internal string get_SpecVersion()
internal void set_SpecVersion(string value)
public Nullable`1<DateTimeOffset> get_Time()
public void set_Time(Nullable`1<DateTimeOffset> value)
public string get_DataSchema()
public void set_DataSchema(string value)
public string get_DataContentType()
public void set_DataContentType(string value)
internal Type get_DataSerializationType()
public string get_Subject()
public void set_Subject(string value)
public IDictionary`2<string, object> get_ExtensionAttributes()
public CloudEvent[] ParseMany(BinaryData json, bool skipValidation)
public CloudEvent Parse(BinaryData json, bool skipValidation)
}
internal Azure.Messaging.CloudEventConstants : object {
public string SpecVersion
public string Id
public string Source
public string Type
public string DataContentType
public string DataSchema
public string Subject
public string Time
public string Data
public string DataBase64
public string ErrorSkipValidationSuggestion
}
internal Azure.Messaging.CloudEventConverter : JsonConverter`1<CloudEvent> {
public CloudEvent Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options)
internal CloudEvent DeserializeCloudEvent(JsonElement element, bool skipValidation)
public void Write(Utf8JsonWriter writer, CloudEvent value, JsonSerializerOptions options)
private void WriteObjectValue(Utf8JsonWriter writer, object value)
private object GetObject(JsonElement& element)
}
public Azure.Messaging.CloudEventDataFormat : Enum {
public int value__
public CloudEventDataFormat Binary
public CloudEventDataFormat Json
}
internal Azure.Messaging.CloudEventExtensionAttributes`2 : object {
private Dictionary`2<TKey, TValue> _backingDictionary
private HashSet`1<string> s_reservedAttributes
public TValue Item
public ICollection`1<TKey> Keys
public ICollection`1<TValue> Values
public int Count
public bool IsReadOnly
public TValue get_Item(TKey key)
public void set_Item(TKey key, TValue value)
public ICollection`1<TKey> get_Keys()
public ICollection`1<TValue> get_Values()
public int get_Count()
public bool get_IsReadOnly()
public void Add(TKey key, TValue value)
public void AddWithoutValidation(TKey key, TValue value)
public void Add(KeyValuePair`2<TKey, TValue> item)
public void Clear()
public bool Contains(KeyValuePair`2<TKey, TValue> item)
public bool ContainsKey(TKey key)
public void CopyTo(KeyValuePair`2[] array, int arrayIndex)
public IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator()
public bool Remove(TKey key)
public bool Remove(KeyValuePair`2<TKey, TValue> item)
public bool TryGetValue(TKey key, TValue& value)
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
private void ValidateAttribute(string name, object value)
}
public Azure.Messaging.MessageContent : object {
private BinaryData <Data>k__BackingField
private Nullable`1<ContentType> <ContentTypeCore>k__BackingField
private bool <IsReadOnly>k__BackingField
public BinaryData Data
public Nullable`1<ContentType> ContentType
protected Nullable`1<ContentType> ContentTypeCore
public bool IsReadOnly
public BinaryData get_Data()
public void set_Data(BinaryData value)
public Nullable`1<ContentType> get_ContentType()
public void set_ContentType(Nullable`1<ContentType> value)
protected Nullable`1<ContentType> get_ContentTypeCore()
protected void set_ContentTypeCore(Nullable`1<ContentType> value)
public bool get_IsReadOnly()
}
public Azure.NullableResponse`1 : object {
private string NoValue
public bool HasValue
public T Value
public bool get_HasValue()
public T get_Value()
public Response GetRawResponse()
public bool Equals(object obj)
public int GetHashCode()
public string ToString()
}
public Azure.Operation : object {
public string Id
public bool HasCompleted
public string get_Id()
public Response GetRawResponse()
public bool get_HasCompleted()
public ValueTask`1<Response> UpdateStatusAsync(CancellationToken cancellationToken)
public Response UpdateStatus(CancellationToken cancellationToken)
public ValueTask`1<Response> WaitForCompletionResponseAsync(CancellationToken cancellationToken)
public ValueTask`1<Response> WaitForCompletionResponseAsync(TimeSpan pollingInterval, CancellationToken cancellationToken)
public ValueTask`1<Response> WaitForCompletionResponseAsync(DelayStrategy delayStrategy, CancellationToken cancellationToken)
public Response WaitForCompletionResponse(CancellationToken cancellationToken)
public Response WaitForCompletionResponse(TimeSpan pollingInterval, CancellationToken cancellationToken)
public Response WaitForCompletionResponse(DelayStrategy delayStrategy, CancellationToken cancellationToken)
internal T GetValue(T& value)
internal T GetValue(Nullable`1& value)
public bool Equals(object obj)
public int GetHashCode()
public string ToString()
}
public Azure.Operation`1 : Operation {
public T Value
public bool HasValue
public T get_Value()
public bool get_HasValue()
public Response`1<T> WaitForCompletion(CancellationToken cancellationToken)
public Response`1<T> WaitForCompletion(TimeSpan pollingInterval, CancellationToken cancellationToken)
public ValueTask`1<Response`1<T>> WaitForCompletionAsync(CancellationToken cancellationToken)
public ValueTask`1<Response`1<T>> WaitForCompletionAsync(TimeSpan pollingInterval, CancellationToken cancellationToken)
public Response`1<T> WaitForCompletion(DelayStrategy delayStrategy, CancellationToken cancellationToken)
public ValueTask`1<Response`1<T>> WaitForCompletionAsync(DelayStrategy delayStrategy, CancellationToken cancellationToken)
public ValueTask`1<Response> WaitForCompletionResponseAsync(CancellationToken cancellationToken)
public ValueTask`1<Response> WaitForCompletionResponseAsync(TimeSpan pollingInterval, CancellationToken cancellationToken)
}
public Azure.Page`1 : object {
public IReadOnlyList`1<T> Values
public string ContinuationToken
public IReadOnlyList`1<T> get_Values()
public string get_ContinuationToken()
public Response GetRawResponse()
public Page`1<T> FromValues(IReadOnlyList`1<T> values, string continuationToken, Response response)
public string ToString()
public bool Equals(object obj)
public int GetHashCode()
}
public Azure.Pageable`1 : object {
private CancellationToken <CancellationToken>k__BackingField
protected CancellationToken CancellationToken
protected CancellationToken get_CancellationToken()
protected void .ctor(CancellationToken cancellationToken)
public IEnumerable`1<Page`1<T>> AsPages(string continuationToken, Nullable`1<int> pageSizeHint)
public string ToString()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
public IEnumerator`1<T> GetEnumerator()
public Pageable`1<T> FromPages(IEnumerable`1<Page`1<T>> pages)
public bool Equals(object obj)
public int GetHashCode()
}
public Azure.PageableOperation`1 : Operation`1<AsyncPageable`1<T>> {
public AsyncPageable`1<T> Value
public AsyncPageable`1<T> get_Value()
public AsyncPageable`1<T> GetValuesAsync(CancellationToken cancellationToken)
public Pageable`1<T> GetValues(CancellationToken cancellationToken)
}
public Azure.RequestConditions : MatchConditions {
private Nullable`1<DateTimeOffset> <IfModifiedSince>k__BackingField
private Nullable`1<DateTimeOffset> <IfUnmodifiedSince>k__BackingField
public Nullable`1<DateTimeOffset> IfModifiedSince
public Nullable`1<DateTimeOffset> IfUnmodifiedSince
public Nullable`1<DateTimeOffset> get_IfModifiedSince()
public void set_IfModifiedSince(Nullable`1<DateTimeOffset> value)
public Nullable`1<DateTimeOffset> get_IfUnmodifiedSince()
public void set_IfUnmodifiedSince(Nullable`1<DateTimeOffset> value)
}
public Azure.RequestContext : object {
private bool _frozen
private ValueTuple`2[] _statusCodes
private ResponseClassificationHandler[] _handlers
private List`1<ValueTuple`2<HttpPipelinePosition, HttpPipelinePolicy>> <Policies>k__BackingField
private ErrorOptions <ErrorOptions>k__BackingField
private CancellationToken <CancellationToken>k__BackingField
internal ValueTuple`2[] StatusCodes
internal ResponseClassificationHandler[] Handlers
internal List`1<ValueTuple`2<HttpPipelinePosition, HttpPipelinePolicy>> Policies
public ErrorOptions ErrorOptions
public CancellationToken CancellationToken
internal ValueTuple`2[] get_StatusCodes()
internal ResponseClassificationHandler[] get_Handlers()
internal List`1<ValueTuple`2<HttpPipelinePosition, HttpPipelinePolicy>> get_Policies()
private void set_Policies(List`1<ValueTuple`2<HttpPipelinePosition, HttpPipelinePolicy>> value)
public ErrorOptions get_ErrorOptions()
public void set_ErrorOptions(ErrorOptions value)
public CancellationToken get_CancellationToken()
public void set_CancellationToken(CancellationToken value)
public RequestContext op_Implicit(ErrorOptions options)
public void AddPolicy(HttpPipelinePolicy policy, HttpPipelinePosition position)
public void AddClassifier(int statusCode, bool isError)
public void AddClassifier(ResponseClassificationHandler classifier)
internal void Freeze()
internal ResponseClassifier Apply(ResponseClassifier classifier)
}
public Azure.RequestFailedException : Exception {
private string DefaultMessage
private int <Status>k__BackingField
private string <ErrorCode>k__BackingField
private Response _response
public int Status
public string ErrorCode
public int get_Status()
public string get_ErrorCode()
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
public void .ctor(int status, string message)
public void .ctor(int status, string message, Exception innerException)
public void .ctor(int status, string message, string errorCode, Exception innerException)
internal void .ctor(int status, ValueTuple`2<string, ResponseError> details)
internal void .ctor(int status, ValueTuple`3<string, string, IDictionary`2<string, string>> details, Exception innerException)
public void .ctor(Response response)
public void .ctor(Response response, Exception innerException)
public void .ctor(Response response, Exception innerException, RequestFailedDetailsParser detailsParser)
protected void .ctor(SerializationInfo info, StreamingContext context)
public void GetObjectData(SerializationInfo info, StreamingContext context)
public Response GetRawResponse()
internal ValueTuple`3<string, string, IDictionary`2<string, string>> GetRequestFailedExceptionContent(Response response, RequestFailedDetailsParser parser)
private void BufferResponseIfNeeded(Response response)
internal bool TryExtractErrorContent(Response response, ResponseError& error, IDictionary`2& data)
}
public Azure.Response : object {
private BinaryData s_EmptyBinaryData
private bool <IsError>k__BackingField
private HttpMessageSanitizer <Sanitizer>k__BackingField
private RequestFailedDetailsParser <RequestFailedDetailsParser>k__BackingField
public int Status
public string ReasonPhrase
public Stream ContentStream
public string ClientRequestId
public ResponseHeaders Headers
public BinaryData Content
public bool IsError
internal HttpMessageSanitizer Sanitizer
internal RequestFailedDetailsParser RequestFailedDetailsParser
public int get_Status()
public string get_ReasonPhrase()
public Stream get_ContentStream()
public void set_ContentStream(Stream value)
public string get_ClientRequestId()
public void set_ClientRequestId(string value)
public ResponseHeaders get_Headers()
public BinaryData get_Content()
public void Dispose()
public bool get_IsError()
internal void set_IsError(bool value)
internal HttpMessageSanitizer get_Sanitizer()
internal void set_Sanitizer(HttpMessageSanitizer value)
internal RequestFailedDetailsParser get_RequestFailedDetailsParser()
internal void set_RequestFailedDetailsParser(RequestFailedDetailsParser value)
protected internal bool TryGetHeader(string name, String& value)
protected internal bool TryGetHeaderValues(string name, IEnumerable`1& values)
protected internal bool ContainsHeader(string name)
protected internal IEnumerable`1<HttpHeader> EnumerateHeaders()
public Response`1<T> FromValue(T value, Response response)
public string ToString()
internal void DisposeStreamIfNotBuffered(Stream& stream)
}
public Azure.Response`1 : NullableResponse`1<T> {
public bool HasValue
public T Value
public bool get_HasValue()
public T get_Value()
public T op_Implicit(Response`1<T> response)
public bool Equals(object obj)
public int GetHashCode()
}
internal Azure.ResponseDebugView`1 : object {
private Response`1<T> _response
public Response GetRawResponse
public T Value
public void .ctor(Response`1<T> response)
public Response get_GetRawResponse()
public T get_Value()
}
public Azure.ResponseError : object {
private JsonElement _element
private string <Code>k__BackingField
private string <Message>k__BackingField
private ResponseInnerError <InnerError>k__BackingField
private string <Target>k__BackingField
private IReadOnlyList`1<ResponseError> <Details>k__BackingField
public string Code
public string Message
internal ResponseInnerError InnerError
internal string Target
internal IReadOnlyList`1<ResponseError> Details
public void .ctor(string code, string message)
internal void .ctor(string code, string message, string target, JsonElement element, ResponseInnerError innerError, IReadOnlyList`1<ResponseError> details)
public string get_Code()
public string get_Message()
internal ResponseInnerError get_InnerError()
internal string get_Target()
internal IReadOnlyList`1<ResponseError> get_Details()
public string ToString()
internal void Append(StringBuilder builder, bool includeRaw)
}
internal Azure.ResponseInnerError : object {
private JsonElement _innerErrorElement
private string <Code>k__BackingField
private ResponseInnerError <InnerError>k__BackingField
public string Code
public ResponseInnerError InnerError
internal void .ctor(string code, ResponseInnerError innerError, JsonElement innerErrorElement)
public string get_Code()
public ResponseInnerError get_InnerError()
public string ToString()
internal void Append(StringBuilder builder)
}
public Azure.SyncAsyncEventArgs : EventArgs {
private bool <IsRunningSynchronously>k__BackingField
private CancellationToken <CancellationToken>k__BackingField
public bool IsRunningSynchronously
public CancellationToken CancellationToken
public bool get_IsRunningSynchronously()
public CancellationToken get_CancellationToken()
public void .ctor(bool isRunningSynchronously, CancellationToken cancellationToken)
}
internal Azure.ValueResponse`1 : Response`1<T> {
private Response _response
private T <Value>k__BackingField
public T Value
public void .ctor(Response response, T value)
public T get_Value()
public Response GetRawResponse()
}
public Azure.WaitUntil : Enum {
public int value__
public WaitUntil Completed
public WaitUntil Started
}
internal System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute : Attribute {
private bool <ParameterValue>k__BackingField
public bool ParameterValue
public void .ctor(bool parameterValue)
public bool get_ParameterValue()
}
internal System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembersAttribute : Attribute {
private DynamicallyAccessedMemberTypes <MemberTypes>k__BackingField
public DynamicallyAccessedMemberTypes MemberTypes
public void .ctor(DynamicallyAccessedMemberTypes memberTypes)
public DynamicallyAccessedMemberTypes get_MemberTypes()
}
internal System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes : Enum {
public int value__
public DynamicallyAccessedMemberTypes None
public DynamicallyAccessedMemberTypes PublicParameterlessConstructor
public DynamicallyAccessedMemberTypes PublicConstructors
public DynamicallyAccessedMemberTypes NonPublicConstructors
public DynamicallyAccessedMemberTypes PublicMethods
public DynamicallyAccessedMemberTypes NonPublicMethods
public DynamicallyAccessedMemberTypes PublicFields
public DynamicallyAccessedMemberTypes NonPublicFields
public DynamicallyAccessedMemberTypes PublicNestedTypes
public DynamicallyAccessedMemberTypes NonPublicNestedTypes
public DynamicallyAccessedMemberTypes PublicProperties
public DynamicallyAccessedMemberTypes NonPublicProperties
public DynamicallyAccessedMemberTypes PublicEvents
public DynamicallyAccessedMemberTypes NonPublicEvents
public DynamicallyAccessedMemberTypes Interfaces
public DynamicallyAccessedMemberTypes All
}
internal System.Diagnostics.CodeAnalysis.DynamicDependencyAttribute : Attribute {
private string <MemberSignature>k__BackingField
private DynamicallyAccessedMemberTypes <MemberTypes>k__BackingField
private Type <Type>k__BackingField
private string <TypeName>k__BackingField
private string <AssemblyName>k__BackingField
private string <Condition>k__BackingField
public string MemberSignature
public DynamicallyAccessedMemberTypes MemberTypes
public Type Type
public string TypeName
public string AssemblyName
public string Condition
public void .ctor(string memberSignature)
public void .ctor(string memberSignature, Type type)
public void .ctor(string memberSignature, string typeName, string assemblyName)
public void .ctor(DynamicallyAccessedMemberTypes memberTypes, Type type)
public void .ctor(DynamicallyAccessedMemberTypes memberTypes, string typeName, string assemblyName)
public string get_MemberSignature()
public DynamicallyAccessedMemberTypes get_MemberTypes()
public Type get_Type()
public string get_TypeName()
public string get_AssemblyName()
public string get_Condition()
public void set_Condition(string value)
}
internal System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute : Attribute {
private bool <ReturnValue>k__BackingField
public bool ReturnValue
public void .ctor(bool returnValue)
public bool get_ReturnValue()
}
internal System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute : Attribute {
private string <ParameterName>k__BackingField
public string ParameterName
public void .ctor(string parameterName)
public string get_ParameterName()
}
internal System.Diagnostics.CodeAnalysis.NotNullWhenAttribute : Attribute {
private bool <ReturnValue>k__BackingField
public bool ReturnValue
public void .ctor(bool returnValue)
public bool get_ReturnValue()
}
internal System.Diagnostics.CodeAnalysis.RequiresDynamicCodeAttribute : Attribute {
private string <Message>k__BackingField
private string <Url>k__BackingField
public string Message
public string Url
public void .ctor(string message)
public string get_Message()
public string get_Url()
public void set_Url(string value)
}
internal System.Diagnostics.CodeAnalysis.RequiresUnreferencedCodeAttribute : Attribute {
private string <Message>k__BackingField
private string <Url>k__BackingField
public string Message
public string Url
public void .ctor(string message)
public string get_Message()
public string get_Url()
public void set_Url(string value)
}
internal System.Diagnostics.CodeAnalysis.UnconditionalSuppressMessageAttribute : Attribute {
private string <Category>k__BackingField
private string <CheckId>k__BackingField
private string <Scope>k__BackingField
private string <Target>k__BackingField
private string <MessageId>k__BackingField
private string <Justification>k__BackingField
public string Category
public string CheckId
public string Scope
public string Target
public string MessageId
public string Justification
public void .ctor(string category, string checkId)
public string get_Category()
public string get_CheckId()
public string get_Scope()
public void set_Scope(string value)
public string get_Target()
public void set_Target(string value)
public string get_MessageId()
public void set_MessageId(string value)
public string get_Justification()
public void set_Justification(string value)
}
internal System.Runtime.CompilerServices.NullableAttribute : Attribute {
public Byte[] NullableFlags
public void .ctor(byte )
public void .ctor(Byte[] )
}
internal System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
public byte Flag
public void .ctor(byte )
}
internal System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
public int Version
public void .ctor(int )
}
