public Apex.AI.CompareOperator : Enum {
public int value__
public CompareOperator None
public CompareOperator LessThan
public CompareOperator LessThanOrEquals
public CompareOperator Equals
public CompareOperator NotEquals
public CompareOperator GreaterThanOrEquals
public CompareOperator GreaterThan
}
public Apex.ApexComponentAttribute : Attribute {
private string <category>k__BackingField
public string category
public void .ctor(string category)
public string get_category()
private void set_category(string value)
}
public Apex.ApexComponentMaster : MonoBehaviour {
private Dictionary`2<int, ComponentInfo> _components
private Dictionary`2<string, ComponentCategory> _categories
private bool _firstTime
private int _hiddenComponents
private Func`2<string, string> CS$<>9__CachedAnonymousMethodDelegate1
private Comparison`1<ComponentInfo> CS$<>9__CachedAnonymousMethodDelegatec
private Func`2<ComponentInfo, bool> CS$<>9__CachedAnonymousMethodDelegate12
public IEnumerable`1<ComponentCategory> componentCategories
public IEnumerable`1<ComponentCategory> get_componentCategories()
public bool Init(IEnumerable`1<ComponentCandidate> candidates)
public void Toggle(ComponentInfo cinfo)
public void Toggle(string componentName, bool visible)
public void ToggleAll()
public void Cleanup()
private void AddHidden(ComponentInfo c)
private void RemoveHidden(ComponentInfo c)
private string <get_componentCategories>b__0(string s)
private int <Init>b__b(ComponentInfo a, ComponentInfo b)
private bool <ToggleAll>b__11(ComponentInfo c)
}
public Apex.ApexQuickStartComponent : MonoBehaviour {
public GameObject Apply(bool isPrefab)
}
public Apex.DataStructures.BinaryHeap`1 : BinaryHeapBase`1<T> {
public void .ctor(int capacity, IComparer`1<T> comparer)
public void Add(T item)
public T Remove()
}
public Apex.DataStructures.BinaryHeapBase`1 : object {
private int _used
private T[] _heap
private IComparer`1<T> _comparer
public int count
public int capacity
public bool hasNext
protected void .ctor(int capacity, IComparer`1<T> comparer)
public int get_count()
public int get_capacity()
public bool get_hasNext()
public T Peek()
public void Clear()
public T Remove(T item)
public T Remove(Func`2<T, bool> predicate)
public void ReheapifyUpFrom(T item)
public void ReheapifyDownFrom(T item)
public void ReheapifyDownFrom(int childIdx)
public void Resize()
protected void AddInternal(T item)
protected T RemoveInternal()
private T Remove(int idx)
private void ReheapifyUp(int childIdx)
private void ReheapifyDown(int currentIdx)
}
public Apex.DataStructures.DynamicArray`1 : object {
private T[] _empty
private T[] _items
private int _capacity
private int _used
public int count
public T Item
public void .ctor(int capacity)
public void .ctor(T[] source)
public void .ctor(IIndexable`1<T> source)
public void .ctor(IEnumerable`1<T> source)
public int get_count()
public T get_Item(int idx)
public void Add(T item)
public void AddRange(IIndexable`1<T> items)
public void AddRange(IEnumerable`1<T> items)
public bool Remove(T item)
public void RemoveAt(int index)
public void Reorder(int fromIdx, int toIdx)
public void Clear()
public void Sort()
public void Sort(IComparer`1<T> comparer)
public void Sort(int index, int length)
public void Sort(int index, int length, IComparer`1<T> comparer)
public void EnsureCapacity(int capacity)
public string ToString()
private void Resize(int newCapacity)
private IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
}
public Apex.DataStructures.FunctionComparer`1 : object {
private Comparison`1<T> _comparer
public void .ctor(Comparison`1<T> comparer)
public int Compare(T x, T y)
}
public Apex.DataStructures.IDynamicArray`1 {
public void Add(T item)
public bool Remove(T item)
public void RemoveAt(int index)
public void Clear()
public void EnsureCapacity(int capacity)
}
public Apex.DataStructures.IIndexable`1 {
public int count
public T Item
public int get_count()
public T get_Item(int idx)
}
public Apex.DataStructures.IndexableSet`1 : object {
private HashSet`1<T> _hashset
private DynamicArray`1<T> _array
public int count
public T Item
public void .ctor(int capacity)
public void .ctor(T[] items)
public void .ctor(IEnumerable`1<T> items)
public int get_count()
public T get_Item(int idx)
public void Add(T obj)
public void AddRange(T[] objects)
public void AddRange(IEnumerable`1<T> objects)
public void AddRange(IIndexable`1<T> objects)
public bool Remove(T obj)
public void RemoveAt(int index)
public bool Contains(T obj)
public void Sort()
public void Sort(IComparer`1<T> comparer)
public void Sort(int index, int length)
public void Sort(int index, int length, IComparer`1<T> comparer)
public void Clear()
public void EnsureCapacity(int capacity)
private IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
}
public Apex.DataStructures.ISortable`1 {
public void Sort()
public void Sort(IComparer`1<T> comparer)
public void Sort(int index, int length)
public void Sort(int index, int length, IComparer`1<T> comparer)
}
public Apex.DataStructures.Matrix`1 : object {
private T[0...,0...] _matrix
private int _columns
private int _rows
public int columns
public int rows
public T[0...,0...] rawMatrix
public IEnumerable`1<T> items
public T Item
public void .ctor(T[0...,0...] matrix)
public void .ctor(int columns, int rows)
public int get_columns()
public int get_rows()
public T[0...,0...] get_rawMatrix()
public IEnumerable`1<T> get_items()
public T get_Item(int column, int row)
public void GetConcentricNeighbours(int column, int row, int cellDistance, DynamicArray`1<T> neighbours)
public IEnumerable`1<T> GetConcentricNeighbours(int column, int row, int cellDistance)
public IEnumerable`1<T> GetRange(MatrixBounds bounds)
public IEnumerable`1<T> GetRange(int fromColumn, int toColumn, int fromRow, int toRow)
public void GetRange(MatrixBounds bounds, ICollection`1<T> result)
public void GetRange(MatrixBounds bounds, Func`2<T, bool> predicate, ICollection`1<T> result)
public void GetRange(int fromColumn, int toColumn, int fromRow, int toRow, ICollection`1<T> result)
public void GetRange(int fromColumn, int toColumn, int fromRow, int toRow, Func`2<T, bool> predicate, ICollection`1<T> result)
public void Apply(MatrixBounds bounds, Action`1<T> act)
public void Apply(int fromColumn, int toColumn, int fromRow, int toRow, Action`1<T> act)
protected bool InBounds(int x, int z)
protected int AdjustColumnToBounds(int x)
protected int AdjustRowToBounds(int z)
}
public Apex.DataStructures.MatrixBounds : ValueType {
public MatrixBounds nullBounds
public int minColumn
public int maxColumn
public int minRow
public int maxRow
public bool isEmpty
public int columns
public int rows
public void .ctor(int minColumn, int minRow, int maxColumn, int maxRow)
public bool get_isEmpty()
public int get_columns()
public int get_rows()
public MatrixBounds Combine(MatrixBounds first, MatrixBounds second)
public int AdjustColumnToBounds(int column)
public int AdjustRowToBounds(int row)
public bool Contains(int column, int row)
public bool Contains(MatrixBounds other)
public int IndexOf(int column, int row)
public string ToString()
}
public Apex.DataStructures.PolygonXZ : object {
public PolygonXZ empty
private Vector3[] _points
public int count
public Vector3 Item
public void .ctor(Vector3[] points)
public void .ctor(int capacity)
public int get_count()
public Vector3 get_Item(int idx)
public void set_Item(int idx, Vector3 value)
public bool Contains(Vector3 test)
public Bounds CalculateBounds()
}
public Apex.DataStructures.PriorityQueue`1 : BinaryHeapBase`1<QueueItem<T>> {
public void .ctor(int capacity, QueueType type)
public void Enqueue(T item, int priority)
public T Dequeue()
}
public Apex.DataStructures.PriorityQueueFifo`1 : BinaryHeapBase`1<QueueItemFifo<T>> {
private int _entryIdx
public void .ctor(int capacity, QueueType type)
public void Enqueue(T item, int priority)
public T Dequeue()
}
public Apex.DataStructures.PriorityQueueLifo`1 : BinaryHeapBase`1<QueueItemLifo<T>> {
private int _entryIdx
public void .ctor(int capacity, QueueType type)
public void Enqueue(T item, int priority)
public T Dequeue()
}
public Apex.DataStructures.QueueOnce`1 : object {
private HashSet`1<T> _set
private Queue`1<T> _q
public int count
public int get_count()
public bool Enqueue(T item)
public void Enqueue(IEnumerable`1<T> items)
public T Dequeue()
public void Clear()
public bool HasQueued(T item)
}
public Apex.DataStructures.QueueType : Enum {
public int value__
public QueueType Min
public QueueType Max
}
public Apex.DataStructures.RectangleXZ : ValueType {
private float _minX
private float _minZ
private float _maxX
private float _maxZ
public float width
public float depth
public Vector3 center
public Vector3 size
public void .ctor(Vector3 center, float width, float depth)
public void .ctor(float minX, float minZ, float width, float depth)
public float get_width()
public float get_depth()
public Vector3 get_center()
public Vector3 get_size()
public RectangleXZ MinMaxRect(float minX, float minZ, float maxX, float maxZ)
public bool Contains(Vector3 point)
public bool Contains(RectangleXZ other)
public bool Overlaps(RectangleXZ other)
public bool Overlaps(Bounds b)
}
public Apex.DataStructures.SimpleQueue`1 : object {
private T[] _array
private int _used
private int _head
public int count
public T Item
public void .ctor(int capacity)
public int get_count()
public T get_Item(int idx)
public void Clear()
public T Peek()
public T Last()
public T Dequeue()
public void Enqueue(T item)
public T[] ToArray()
private IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
}
public Apex.DataStructures.Vector3EqualityComparer : object {
private float _equalityThreshold
public void .ctor(float equalityThreshold)
public bool Equals(Vector3 x, Vector3 y)
public int GetHashCode(Vector3 obj)
}
public Apex.DataStructures.VectorXZ : ValueType {
public int x
public int z
public void .ctor(int x, int z)
public bool op_Equality(VectorXZ lhs, VectorXZ rhs)
public bool op_Inequality(VectorXZ lhs, VectorXZ rhs)
public VectorXZ op_Addition(VectorXZ a, VectorXZ b)
public VectorXZ op_Subtraction(VectorXZ a, VectorXZ b)
public int GetHashCode()
public bool Equals(object other)
}
public Apex.Debugging.LoadBalancerPerformanceVisualizer : MonoBehaviour {
private PerformanceData[] _data
public PerformanceData[] data
public PerformanceData[] get_data()
private void Awake()
private void Update()
}
public Apex.ExtendedMonoBehaviour : MonoBehaviour {
private bool _hasStarted
protected void Start()
protected void OnEnable()
protected void OnStartAndEnable()
}
public Apex.IGameObjectComponent {
public GameObject gameObject
public GameObject get_gameObject()
}
public Apex.ISupportRuntimeStateChange {
public void ReevaluateState()
}
public Apex.LoadBalancing.ILoadBalanced {
public bool repeat
public bool get_repeat()
public Nullable`1<float> ExecuteUpdate(float deltaTime, float nextInterval)
}
public Apex.LoadBalancing.ILoadBalancedHandle {
public ILoadBalanced item
public bool isDisposed
public ILoadBalanced get_item()
public bool get_isDisposed()
public void Stop()
public void Pause()
public void Resume()
}
public Apex.LoadBalancing.ILoadBalancer {
public float defaultUpdateInterval
public float get_defaultUpdateInterval()
public ILoadBalancedHandle Add(ILoadBalanced item)
public ILoadBalancedHandle Add(ILoadBalanced item, bool delayFirstUpdate)
public ILoadBalancedHandle Add(ILoadBalanced item, float interval)
public ILoadBalancedHandle Add(ILoadBalanced item, float interval, bool delayFirstUpdate)
public ILoadBalancedHandle Add(ILoadBalanced item, float interval, float delayFirstUpdateBy)
public void Remove(ILoadBalanced item)
}
public Apex.LoadBalancing.IMarshaller {
public void ExecuteOnMainThread(Action a)
}
public Apex.LoadBalancing.LoadBalancedActionPool : object {
private Queue`1<RecycledOneTimeAction> _oneTimeActions
private Queue`1<RecycledLongRunningAction> _longActions
private Queue`1<RecycledAction> _actions
public void ExecuteOnce(ILoadBalancer lb, Action action, float delay)
public ILoadBalancedHandle Execute(ILoadBalancer lb, Func`2<float, bool> action, bool delayFirstUpdate)
public ILoadBalancedHandle Execute(ILoadBalancer lb, Func`2<float, bool> action, float interval, bool delayFirstUpdate)
public ILoadBalancedHandle Execute(ILoadBalancer lb, Func`2<float, bool> action, float interval, float delayFirstUpdateBy)
public ILoadBalancedHandle Execute(ILoadBalancer lb, IEnumerator longRunningAction, int maxMillisecondsUsedPerFrame)
private RecycledAction GetAction(Func`2<float, bool> action)
private void Return(RecycledOneTimeAction action)
private void Return(RecycledAction action)
private void Return(RecycledLongRunningAction action)
}
public Apex.LoadBalancing.LoadBalancedQueue : object {
private BinaryHeap`1<LoadBalancerItem> _queue
private Stopwatch _watch
private float <defaultUpdateInterval>k__BackingField
private int <maxUpdatesPerInterval>k__BackingField
private int <maxUpdateTimeInMillisecondsPerUpdate>k__BackingField
private bool <autoAdjust>k__BackingField
private float <updatesOverdueByTotal>k__BackingField
private long <updateMillisecondsUsed>k__BackingField
private int <updatedItemsCount>k__BackingField
public float defaultUpdateInterval
public int maxUpdatesPerInterval
public int maxUpdateTimeInMillisecondsPerUpdate
public bool autoAdjust
public float updatesOverdueByTotal
public long updateMillisecondsUsed
public int updatedItemsCount
public int itemCount
public void .ctor(int capacity)
public void .ctor(int capacity, float defaultUpdateInterval, bool autoAdjust)
public void .ctor(int capacity, float defaultUpdateInterval, int maxUpdatesPerInterval, int maxUpdateTimeInMillisecondsPerUpdate)
private void .ctor(int capacity, float defaultUpdateInterval, int maxUpdatesPerInterval, int maxUpdateTimeInMillisecondsPerUpdate, bool autoAdjust)
public float get_defaultUpdateInterval()
public void set_defaultUpdateInterval(float value)
public int get_maxUpdatesPerInterval()
public void set_maxUpdatesPerInterval(int value)
public int get_maxUpdateTimeInMillisecondsPerUpdate()
public void set_maxUpdateTimeInMillisecondsPerUpdate(int value)
public bool get_autoAdjust()
public void set_autoAdjust(bool value)
public float get_updatesOverdueByTotal()
private void set_updatesOverdueByTotal(float value)
public long get_updateMillisecondsUsed()
private void set_updateMillisecondsUsed(long value)
public int get_updatedItemsCount()
private void set_updatedItemsCount(int value)
public int get_itemCount()
public ILoadBalancedHandle Add(ILoadBalanced item)
public ILoadBalancedHandle Add(ILoadBalanced item, bool delayFirstUpdate)
public ILoadBalancedHandle Add(ILoadBalanced item, float interval)
public ILoadBalancedHandle Add(ILoadBalanced item, float interval, bool delayFirstUpdate)
public ILoadBalancedHandle Add(ILoadBalanced item, float interval, float delayFirstUpdateBy)
public void Remove(ILoadBalanced item)
public void Update()
private void Remove(LoadBalancerItem item)
}
public Apex.LoadBalancing.LoadBalancer : object {
public ILoadBalancer defaultBalancer
private IMarshaller <marshaller>k__BackingField
public IMarshaller marshaller
public IMarshaller get_marshaller()
internal void set_marshaller(IMarshaller value)
}
public Apex.LoadBalancing.LoadBalancerComponent : SingleInstanceComponent`1<LoadBalancerComponent> {
private LoadBalancerConfig[] _configurations
private int _mashallerMaxMillisecondPerFrame
private LoadBalancedQueue[] _loadBalancers
private Marshaller _marshaller
private Func`2<Assembly, IEnumerable`1<Type>> CS$<>9__CachedAnonymousMethodDelegate11
private Func`3<Assembly, Type, <>f__AnonymousType0`2<Assembly, Type>> CS$<>9__CachedAnonymousMethodDelegate12
private Func`2<<>f__AnonymousType0`2<Assembly, Type>, Type> CS$<>9__CachedAnonymousMethodDelegate13
private Func`2<Type, IEnumerable`1<PropertyInfo>> CS$<>9__CachedAnonymousMethodDelegate14
private Func`3<Type, PropertyInfo, <>f__AnonymousType1`2<Type, PropertyInfo>> CS$<>9__CachedAnonymousMethodDelegate15
private Func`2<<>f__AnonymousType1`2<Type, PropertyInfo>, PropertyInfo> CS$<>9__CachedAnonymousMethodDelegate16
private Func`2<Type, IEnumerable`1<FieldInfo>> CS$<>9__CachedAnonymousMethodDelegate17
private Func`3<Type, FieldInfo, <>f__AnonymousType2`2<Type, FieldInfo>> CS$<>9__CachedAnonymousMethodDelegate18
private Func`2<<>f__AnonymousType2`2<Type, FieldInfo>, FieldInfo> CS$<>9__CachedAnonymousMethodDelegate19
private Func`2<LoadBalancerConfig, bool> CS$<>9__CachedAnonymousMethodDelegate1a
private Func`2<LoadBalancerConfig, string> CS$<>9__CachedAnonymousMethodDelegate1b
public LoadBalancerConfig[] configurations
public IEnumerable`1<LoadBalancedQueue> loadBalancers
public LoadBalancerConfig[] get_configurations()
public IEnumerable`1<LoadBalancedQueue> get_loadBalancers()
protected void OnAwake()
private void Update()
private void ResolveLoadBalancers()
private IEnumerable`1<Type> <ResolveLoadBalancers>b__3(Assembly asm)
private <>f__AnonymousType0`2<Assembly, Type> <ResolveLoadBalancers>b__4(Assembly asm, Type t)
private Type <ResolveLoadBalancers>b__6(<>f__AnonymousType0`2<Assembly, Type> <>h__TransparentIdentifier0)
private IEnumerable`1<PropertyInfo> <ResolveLoadBalancers>b__7(Type t)
private <>f__AnonymousType1`2<Type, PropertyInfo> <ResolveLoadBalancers>b__8(Type t, PropertyInfo p)
private PropertyInfo <ResolveLoadBalancers>b__a(<>f__AnonymousType1`2<Type, PropertyInfo> <>h__TransparentIdentifier1)
private IEnumerable`1<FieldInfo> <ResolveLoadBalancers>b__b(Type t)
private <>f__AnonymousType2`2<Type, FieldInfo> <ResolveLoadBalancers>b__c(Type t, FieldInfo f)
private FieldInfo <ResolveLoadBalancers>b__e(<>f__AnonymousType2`2<Type, FieldInfo> <>h__TransparentIdentifier2)
private bool <ResolveLoadBalancers>b__f(LoadBalancerConfig c)
private string <ResolveLoadBalancers>b__10(LoadBalancerConfig c)
}
public Apex.LoadBalancing.LoadBalancerConfig : object {
public float updateInterval
public int maxUpdatesPerFrame
public int maxUpdateTimeInMillisecondsPerUpdate
public bool autoAdjust
public string targetLoadBalancer
private LoadBalancedQueue <associatedLoadBalancer>k__BackingField
public LoadBalancedQueue associatedLoadBalancer
public LoadBalancedQueue get_associatedLoadBalancer()
private void set_associatedLoadBalancer(LoadBalancedQueue value)
internal LoadBalancerConfig From(string name, LoadBalancedQueue q)
internal void ApplyTo(LoadBalancedQueue q)
}
public Apex.LoadBalancing.LongRunningAction : object {
private Func`1<IEnumerator> _action
private Action _callback
private int _maxMillisecondUsedPerFrame
private IEnumerator _iter
private Stopwatch _watch
private bool <repeat>k__BackingField
public bool repeat
public void .ctor(Func`1<IEnumerator> action, int maxMillisecondUsedPerFrame)
public void .ctor(Func`1<IEnumerator> action, int maxMillisecondUsedPerFrame, Action callback)
public void .ctor(IEnumerator action, int maxMillisecondUsedPerFrame)
public void .ctor(IEnumerator action, int maxMillisecondUsedPerFrame, Action callback)
public bool get_repeat()
private void set_repeat(bool value)
public Nullable`1<float> ExecuteUpdate(float deltaTime, float nextInterval)
}
public Apex.LoadBalancing.Marshaller : object {
private Stopwatch _watch
private SimpleQueue`1<Action> _queue
private int _maxMillisecondsPerFrame
internal void .ctor(int maxMillisecondsPerFrame)
public void ExecuteOnMainThread(Action a)
internal void ProcessPending()
}
public Apex.LoadBalancing.OneTimeAction : object {
private Action`1<float> _action
public bool repeat
public void .ctor(Action`1<float> action)
public bool get_repeat()
public Nullable`1<float> ExecuteUpdate(float deltaTime, float nextInterval)
}
public Apex.LoadBalancing.RepeatableAction : object {
private Func`2<float, bool> _action
private int _repetitions
private int _repetitionCount
private bool <repeat>k__BackingField
public bool repeat
public void .ctor(Func`2<float, bool> action)
public void .ctor(Func`2<float, bool> action, int repetitions)
public bool get_repeat()
private void set_repeat(bool value)
public Nullable`1<float> ExecuteUpdate(float deltaTime, float nextInterval)
}
public Apex.MaskMatch : Enum {
public int value__
public MaskMatch NoMatch
public MaskMatch Partial
public MaskMatch Strict
public MaskMatch Equals
}
public Apex.SharedExtensions : object {
public void Apply(IEnumerable`1<T> list, Action`1<T> action)
public void Apply(IList`1<T> list, Action`1<T> action)
public void Apply(IIndexable`1<T> list, Action`1<T> action)
public T[] ToArray(IIndexable`1<T> list)
public void AddRange(ICollection`1<T> list, IEnumerable`1<T> items)
public bool AddUnique(IList`1<T> list, T item)
public void AddRangeUnique(IList`1<T> list, IEnumerable`1<T> items)
public void Reorder(IList list, int fromIdx, int toIdx)
public void ReorderList(IList`1<T> list, int fromIdx, int toIdx)
public void EnsureCapacity(List`1<T> list, int capacity)
public T GetAttribute(ICustomAttributeProvider inf, bool inherit)
public IEnumerable`1<T> GetAttributes(ICustomAttributeProvider inf, bool inherit)
public bool IsDefined(ICustomAttributeProvider inf, bool inherit)
public T Value(Dictionary`2<TKey, T> dict, TKey key)
public string ExpandFromPascal(string pascalString)
public string PrettyName(Type t)
public T[] Fuse(T[] arrOne, T[] arrTwo)
public int IndexOf(T[] array, T value)
public string SafeTrim(string s)
}
public Apex.SharedUnityExtensions : object {
private Plane _xzPlane
public Collider GetColliderAtPosition(Camera cam, Vector3 screenPos, LayerMask layerMask, float maxDistance)
public bool ScreenToLayerHit(Camera cam, Vector3 screenPos, LayerMask layerMask, float maxDistance, RaycastHit& hit)
public Vector3 ScreenToGroundPoint(Camera cam, Vector3 screenPos)
public Vector3 ScreenToGroundPoint(Camera cam, Vector3 screenPos, float groundHeight)
public bool Approximately(Vector3 me, Vector3 other, float allowedDifference)
public Vector3 DirToXZ(Vector3 from, Vector3 to)
public Vector3 OnlyXZ(Vector3 v)
public T As(Component c, bool searchParent, bool required)
public T As(IGameObjectComponent c, bool searchParent, bool required)
public T As(GameObject go, bool searchParent, bool required)
public void WarnIfMultipleInstances(MonoBehaviour component)
public void WarnIfMultipleInstances(MonoBehaviour component)
public bool Overlaps(Bounds a, Bounds b)
public Bounds Translate(Bounds b, Vector3 translation)
public Bounds Translate(Bounds b, float x, float y, float z)
public Bounds DeltaSize(Bounds b, Vector3 delta)
public Bounds DeltaSize(Bounds b, float dx, float dy, float dz)
public Bounds Merge(Bounds b, Bounds other)
public Bounds Intersection(Bounds a, Bounds b)
public bool Contains(Rect rect, Rect other)
public Rect Round(Rect rect)
public Vector2 Round(Vector2 v)
public Vector3 Round(Vector3 v)
public bool AddIfMissing(GameObject target, bool entireScene, T& component)
public bool AddIfMissing(GameObject target, bool entireScene)
public bool AddIfMissing(GameObject target, T& component)
public bool AddIfMissing(GameObject target)
public T AddComponentSafe(GameObject target, Action`1<T> configurator)
public bool NukeSingle(GameObject go)
public void SelfAndDescendants(GameObject root, List`1<GameObject> collector)
}
public Apex.SingleInstanceComponent`1 : MonoBehaviour {
private int _instanceMark
private void Awake()
protected void OnDestroy()
protected void OnAwake()
}
public Apex.Utilities.ApexReflection : object {
private Func`2<Assembly, bool> CS$<>9__CachedAnonymousMethodDelegate4
private Func`2<Assembly, IEnumerable`1<Type>> CS$<>9__CachedAnonymousMethodDelegate5
private Func`3<Assembly, Type, Type> CS$<>9__CachedAnonymousMethodDelegate6
public IEnumerable`1<Type> GetRelevantTypes()
public string ProperName(Type t, bool fullName)
private void ProperName(Type t, bool fullName, StringBuilder b)
private bool <GetRelevantTypes>b__1(Assembly a)
private IEnumerable`1<Type> <GetRelevantTypes>b__2(Assembly a)
private Type <GetRelevantTypes>b__3(Assembly a, Type t)
}
public Apex.Utilities.ComponentHelper : object {
public T FindFirstComponentInScene()
public IEnumerable`1<T> FindAllComponentsInScene()
}
public Apex.Utilities.DebugTimer : object {
private Stack`1<Stopwatch> _watches
private Stopwatch _avgWatch
private float _iterations
private int _count
private float _avg
public void Start()
public void EndTicks(string label)
public void EndMilliseconds(string label)
public void StartAverage(int iterations)
public void EndAverageTicks(string label)
public void EndAverageMilliseconds(string label)
}
public Apex.Utilities.Empty`1 : object {
public T[] array
}
public Apex.Utilities.Ensure : object {
public void ArgumentNotNullOrEmpty(string value, string variableName)
public void ArgumentNotNull(object value, string variableName)
public void ArgumentInRange(Func`1<bool> check, string variableName, object value, string message)
}
public Apex.Utilities.LabelAttribute : PropertyAttribute {
private string <label>k__BackingField
private string <tooltip>k__BackingField
public string label
public string tooltip
public void .ctor(string label)
public void .ctor(string label, string tooltip)
public string get_label()
private void set_label(string value)
public string get_tooltip()
private void set_tooltip(string value)
}
public Apex.Utilities.ListBufferPool : object {
private Dictionary`2<Type, Queue`1<IList>> _pool
public List`1<T> GetBuffer(int capacityHint)
public void ReturnBuffer(List`1<T> buffer)
public void PreAllocate(int capacity, int number)
}
public Apex.Utilities.MaxCheckAttribute : PropertyAttribute {
private float <max>k__BackingField
private string <label>k__BackingField
private string <tooltip>k__BackingField
public float max
public string label
public string tooltip
public void .ctor(float max)
public void .ctor(int max)
public float get_max()
private void set_max(float value)
public string get_label()
public void set_label(string value)
public string get_tooltip()
public void set_tooltip(string value)
}
public Apex.Utilities.MinCheckAttribute : PropertyAttribute {
private float <min>k__BackingField
private string <label>k__BackingField
private string <tooltip>k__BackingField
public float min
public string label
public string tooltip
public void .ctor(float min)
public void .ctor(int min)
public float get_min()
private void set_min(float value)
public string get_label()
public void set_label(string value)
public string get_tooltip()
public void set_tooltip(string value)
}
public Apex.Utilities.RangeXAttribute : PropertyAttribute {
public float min
public float max
private string <label>k__BackingField
private string <tooltip>k__BackingField
public string label
public string tooltip
public void .ctor(float min, float max)
public string get_label()
public void set_label(string value)
public string get_tooltip()
public void set_tooltip(string value)
}
