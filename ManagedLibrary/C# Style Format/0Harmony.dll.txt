internal Consts : object {
public string AssemblyName
public string PublicKey
}
internal HarmonyLib.AccessCache : object {
private BindingFlags BasicFlags
private Dictionary`2<MemberType, BindingFlags> declaredOnlyBindingFlags
private Dictionary`2<Type, Dictionary`2<string, FieldInfo>> declaredFields
private Dictionary`2<Type, Dictionary`2<string, PropertyInfo>> declaredProperties
private Dictionary`2<Type, Dictionary`2<string, Dictionary`2<int, MethodBase>>> declaredMethods
private Dictionary`2<Type, Dictionary`2<string, FieldInfo>> inheritedFields
private Dictionary`2<Type, Dictionary`2<string, PropertyInfo>> inheritedProperties
private Dictionary`2<Type, Dictionary`2<string, Dictionary`2<int, MethodBase>>> inheritedMethods
private T Get(Dictionary`2<Type, Dictionary`2<string, T>> dict, Type type, string name, Func`1<T> fetcher)
private T Get(Dictionary`2<Type, Dictionary`2<string, Dictionary`2<int, T>>> dict, Type type, string name, Type[] arguments, Func`1<T> fetcher)
internal FieldInfo GetFieldInfo(Type type, string name, MemberType memberType, bool declaredOnly)
internal PropertyInfo GetPropertyInfo(Type type, string name, MemberType memberType, bool declaredOnly)
internal MethodBase GetMethodInfo(Type type, string name, Type[] arguments, MemberType memberType, bool declaredOnly)
}
public HarmonyLib.AccessTools : object {
public BindingFlags all
public BindingFlags allDeclared
private bool <IsMonoRuntime>k__BackingField
private bool <IsNetFrameworkRuntime>k__BackingField
private bool <IsNetCoreRuntime>k__BackingField
private Dictionary`2<Type, FastInvokeHandler> addHandlerCache
private ReaderWriterLockSlim addHandlerCacheLock
public bool IsMonoRuntime
public bool IsNetFrameworkRuntime
public bool IsNetCoreRuntime
public IEnumerable`1<Assembly> AllAssemblies()
public Type TypeByName(string name)
public Type[] GetTypesFromAssembly(Assembly assembly)
public IEnumerable`1<Type> AllTypes()
public IEnumerable`1<Type> InnerTypes(Type type)
public T FindIncludingBaseTypes(Type type, Func`2<Type, T> func)
public T FindIncludingInnerTypes(Type type, Func`2<Type, T> func)
public FieldInfo DeclaredField(Type type, string name)
public FieldInfo DeclaredField(string typeColonName)
public FieldInfo Field(Type type, string name)
public FieldInfo Field(string typeColonName)
public FieldInfo DeclaredField(Type type, int idx)
public PropertyInfo DeclaredProperty(Type type, string name)
public PropertyInfo DeclaredProperty(string typeColonName)
public PropertyInfo DeclaredIndexer(Type type, Type[] parameters)
public MethodInfo DeclaredPropertyGetter(Type type, string name)
public MethodInfo DeclaredPropertyGetter(string typeColonName)
public MethodInfo DeclaredIndexerGetter(Type type, Type[] parameters)
public MethodInfo DeclaredPropertySetter(Type type, string name)
public MethodInfo DeclaredPropertySetter(string typeColonName)
public MethodInfo DeclaredIndexerSetter(Type type, Type[] parameters)
public PropertyInfo Property(Type type, string name)
public PropertyInfo Property(string typeColonName)
public PropertyInfo Indexer(Type type, Type[] parameters)
public MethodInfo PropertyGetter(Type type, string name)
public MethodInfo PropertyGetter(string typeColonName)
public MethodInfo IndexerGetter(Type type, Type[] parameters)
public MethodInfo PropertySetter(Type type, string name)
public MethodInfo PropertySetter(string typeColonName)
public MethodInfo IndexerSetter(Type type, Type[] parameters)
public MethodInfo DeclaredMethod(Type type, string name, Type[] parameters, Type[] generics)
public MethodInfo DeclaredMethod(string typeColonName, Type[] parameters, Type[] generics)
public MethodInfo Method(Type type, string name, Type[] parameters, Type[] generics)
public MethodInfo Method(string typeColonName, Type[] parameters, Type[] generics)
public MethodInfo EnumeratorMoveNext(MethodBase method)
public MethodInfo AsyncMoveNext(MethodBase method)
public List`1<string> GetMethodNames(Type type)
public List`1<string> GetMethodNames(object instance)
public List`1<string> GetFieldNames(Type type)
public List`1<string> GetFieldNames(object instance)
public List`1<string> GetPropertyNames(Type type)
public List`1<string> GetPropertyNames(object instance)
public Type GetUnderlyingType(MemberInfo member)
public bool IsDeclaredMember(T member)
public T GetDeclaredMember(T member)
public ConstructorInfo DeclaredConstructor(Type type, Type[] parameters, bool searchForStatic)
public ConstructorInfo Constructor(Type type, Type[] parameters, bool searchForStatic)
public List`1<ConstructorInfo> GetDeclaredConstructors(Type type, Nullable`1<bool> searchForStatic)
public List`1<MethodInfo> GetDeclaredMethods(Type type)
public List`1<PropertyInfo> GetDeclaredProperties(Type type)
public List`1<FieldInfo> GetDeclaredFields(Type type)
public Type GetReturnedType(MethodBase methodOrConstructor)
public Type Inner(Type type, string name)
public Type FirstInner(Type type, Func`2<Type, bool> predicate)
public MethodInfo FirstMethod(Type type, Func`2<MethodInfo, bool> predicate)
public ConstructorInfo FirstConstructor(Type type, Func`2<ConstructorInfo, bool> predicate)
public PropertyInfo FirstProperty(Type type, Func`2<PropertyInfo, bool> predicate)
public Type[] GetTypes(Object[] parameters)
public Object[] ActualParameters(MethodBase method, Object[] inputs)
public FieldRef`2<T, F> FieldRefAccess(string fieldName)
public F& FieldRefAccess(T instance, string fieldName)
public FieldRef`2<object, F> FieldRefAccess(Type type, string fieldName)
public FieldRef`2<object, F> FieldRefAccess(string typeColonName)
public FieldRef`2<T, F> FieldRefAccess(FieldInfo fieldInfo)
public F& FieldRefAccess(T instance, FieldInfo fieldInfo)
public StructFieldRef`2<T, F> StructFieldRefAccess(string fieldName)
public F& StructFieldRefAccess(T& instance, string fieldName)
public StructFieldRef`2<T, F> StructFieldRefAccess(FieldInfo fieldInfo)
public F& StructFieldRefAccess(T& instance, FieldInfo fieldInfo)
public F& StaticFieldRefAccess(string fieldName)
public F& StaticFieldRefAccess(Type type, string fieldName)
public F& StaticFieldRefAccess(string typeColonName)
public F& StaticFieldRefAccess(FieldInfo fieldInfo)
public FieldRef`1<F> StaticFieldRefAccess(FieldInfo fieldInfo)
public DelegateType MethodDelegate(MethodInfo method, object instance, bool virtualCall)
public DelegateType MethodDelegate(string typeColonName, object instance, bool virtualCall)
public DelegateType HarmonyDelegate(object instance)
public MethodBase GetOutsideCaller()
public void RethrowException(Exception exception)
public bool get_IsMonoRuntime()
public bool get_IsNetFrameworkRuntime()
public bool get_IsNetCoreRuntime()
public void ThrowMissingMemberException(Type type, String[] names)
public object GetDefaultValue(Type type)
public object CreateInstance(Type type)
public T CreateInstance()
public T MakeDeepCopy(object source)
public void MakeDeepCopy(object source, T& result, Func`4<string, Traverse, Traverse, object> processor, string pathRoot)
public object MakeDeepCopy(object source, Type resultType, Func`4<string, Traverse, Traverse, object> processor, string pathRoot)
public bool IsStruct(Type type)
public bool IsClass(Type type)
public bool IsValue(Type type)
public bool IsInteger(Type type)
public bool IsFloatingPoint(Type type)
public bool IsNumber(Type type)
public bool IsVoid(Type type)
public bool IsOfNullableType(T instance)
public bool IsStatic(MemberInfo member)
public bool IsStatic(Type type)
public bool IsStatic(PropertyInfo propertyInfo)
public bool IsStatic(EventInfo eventInfo)
public int CombinedHashCode(IEnumerable`1<object> objects)
}
public HarmonyLib.AccessToolsExtensions : object {
public IEnumerable`1<Type> InnerTypes(Type type)
public T FindIncludingBaseTypes(Type type, Func`2<Type, T> func)
public T FindIncludingInnerTypes(Type type, Func`2<Type, T> func)
public FieldInfo DeclaredField(Type type, string name)
public FieldInfo Field(Type type, string name)
public FieldInfo DeclaredField(Type type, int idx)
public PropertyInfo DeclaredProperty(Type type, string name)
public PropertyInfo DeclaredIndexer(Type type, Type[] parameters)
public MethodInfo DeclaredPropertyGetter(Type type, string name)
public MethodInfo DeclaredIndexerGetter(Type type, Type[] parameters)
public MethodInfo DeclaredPropertySetter(Type type, string name)
public MethodInfo DeclaredIndexerSetter(Type type, Type[] parameters)
public PropertyInfo Property(Type type, string name)
public PropertyInfo Indexer(Type type, Type[] parameters)
public MethodInfo PropertyGetter(Type type, string name)
public MethodInfo IndexerGetter(Type type, Type[] parameters)
public MethodInfo PropertySetter(Type type, string name)
public MethodInfo IndexerSetter(Type type, Type[] parameters)
public MethodInfo DeclaredMethod(Type type, string name, Type[] parameters, Type[] generics)
public MethodInfo Method(Type type, string name, Type[] parameters, Type[] generics)
public List`1<string> GetMethodNames(Type type)
public List`1<string> GetFieldNames(Type type)
public List`1<string> GetPropertyNames(Type type)
public ConstructorInfo DeclaredConstructor(Type type, Type[] parameters, bool searchForStatic)
public ConstructorInfo Constructor(Type type, Type[] parameters, bool searchForStatic)
public List`1<ConstructorInfo> GetDeclaredConstructors(Type type, Nullable`1<bool> searchForStatic)
public List`1<MethodInfo> GetDeclaredMethods(Type type)
public List`1<PropertyInfo> GetDeclaredProperties(Type type)
public List`1<FieldInfo> GetDeclaredFields(Type type)
public Type Inner(Type type, string name)
public Type FirstInner(Type type, Func`2<Type, bool> predicate)
public MethodInfo FirstMethod(Type type, Func`2<MethodInfo, bool> predicate)
public ConstructorInfo FirstConstructor(Type type, Func`2<ConstructorInfo, bool> predicate)
public PropertyInfo FirstProperty(Type type, Func`2<PropertyInfo, bool> predicate)
public FieldRef`2<object, F> FieldRefAccess(Type type, string fieldName)
public F& StaticFieldRefAccess(Type type, string fieldName)
public void ThrowMissingMemberException(Type type, String[] names)
public object GetDefaultValue(Type type)
public object CreateInstance(Type type)
public bool IsStruct(Type type)
public bool IsClass(Type type)
public bool IsValue(Type type)
public bool IsInteger(Type type)
public bool IsFloatingPoint(Type type)
public bool IsNumber(Type type)
public bool IsVoid(Type type)
public bool IsStatic(Type type)
}
public HarmonyLib.ArgumentType : Enum {
public int value__
public ArgumentType Normal
public ArgumentType Ref
public ArgumentType Out
public ArgumentType Pointer
}
internal HarmonyLib.AttributePatch : object {
private HarmonyPatchType[] allPatchTypes
internal HarmonyMethod info
internal Nullable`1<HarmonyPatchType> type
internal AttributePatch Create(MethodInfo patch)
private Nullable`1<HarmonyPatchType> GetPatchType(string methodName, Object[] allAttributes)
}
internal HarmonyLib.ByteBuffer : object {
internal Byte[] buffer
internal int position
internal void .ctor(Byte[] buffer)
internal byte ReadByte()
internal Byte[] ReadBytes(int length)
internal short ReadInt16()
internal int ReadInt32()
internal long ReadInt64()
internal float ReadSingle()
internal double ReadDouble()
private void CheckCanRead(int count)
}
public HarmonyLib.Code : object {
public Operand_ Operand
public Nop_ Nop
public Break_ Break
public Ldarg_0_ Ldarg_0
public Ldarg_1_ Ldarg_1
public Ldarg_2_ Ldarg_2
public Ldarg_3_ Ldarg_3
public Ldloc_0_ Ldloc_0
public Ldloc_1_ Ldloc_1
public Ldloc_2_ Ldloc_2
public Ldloc_3_ Ldloc_3
public Stloc_0_ Stloc_0
public Stloc_1_ Stloc_1
public Stloc_2_ Stloc_2
public Stloc_3_ Stloc_3
public Ldarg_S_ Ldarg_S
public Ldarga_S_ Ldarga_S
public Starg_S_ Starg_S
public Ldloc_S_ Ldloc_S
public Ldloca_S_ Ldloca_S
public Stloc_S_ Stloc_S
public Ldnull_ Ldnull
public Ldc_I4_M1_ Ldc_I4_M1
public Ldc_I4_0_ Ldc_I4_0
public Ldc_I4_1_ Ldc_I4_1
public Ldc_I4_2_ Ldc_I4_2
public Ldc_I4_3_ Ldc_I4_3
public Ldc_I4_4_ Ldc_I4_4
public Ldc_I4_5_ Ldc_I4_5
public Ldc_I4_6_ Ldc_I4_6
public Ldc_I4_7_ Ldc_I4_7
public Ldc_I4_8_ Ldc_I4_8
public Ldc_I4_S_ Ldc_I4_S
public Ldc_I4_ Ldc_I4
public Ldc_I8_ Ldc_I8
public Ldc_R4_ Ldc_R4
public Ldc_R8_ Ldc_R8
public Dup_ Dup
public Pop_ Pop
public Jmp_ Jmp
public Call_ Call
public Calli_ Calli
public Ret_ Ret
public Br_S_ Br_S
public Brfalse_S_ Brfalse_S
public Brtrue_S_ Brtrue_S
public Beq_S_ Beq_S
public Bge_S_ Bge_S
public Bgt_S_ Bgt_S
public Ble_S_ Ble_S
public Blt_S_ Blt_S
public Bne_Un_S_ Bne_Un_S
public Bge_Un_S_ Bge_Un_S
public Bgt_Un_S_ Bgt_Un_S
public Ble_Un_S_ Ble_Un_S
public Blt_Un_S_ Blt_Un_S
public Br_ Br
public Brfalse_ Brfalse
public Brtrue_ Brtrue
public Beq_ Beq
public Bge_ Bge
public Bgt_ Bgt
public Ble_ Ble
public Blt_ Blt
public Bne_Un_ Bne_Un
public Bge_Un_ Bge_Un
public Bgt_Un_ Bgt_Un
public Ble_Un_ Ble_Un
public Blt_Un_ Blt_Un
public Switch_ Switch
public Ldind_I1_ Ldind_I1
public Ldind_U1_ Ldind_U1
public Ldind_I2_ Ldind_I2
public Ldind_U2_ Ldind_U2
public Ldind_I4_ Ldind_I4
public Ldind_U4_ Ldind_U4
public Ldind_I8_ Ldind_I8
public Ldind_I_ Ldind_I
public Ldind_R4_ Ldind_R4
public Ldind_R8_ Ldind_R8
public Ldind_Ref_ Ldind_Ref
public Stind_Ref_ Stind_Ref
public Stind_I1_ Stind_I1
public Stind_I2_ Stind_I2
public Stind_I4_ Stind_I4
public Stind_I8_ Stind_I8
public Stind_R4_ Stind_R4
public Stind_R8_ Stind_R8
public Add_ Add
public Sub_ Sub
public Mul_ Mul
public Div_ Div
public Div_Un_ Div_Un
public Rem_ Rem
public Rem_Un_ Rem_Un
public And_ And
public Or_ Or
public Xor_ Xor
public Shl_ Shl
public Shr_ Shr
public Shr_Un_ Shr_Un
public Neg_ Neg
public Not_ Not
public Conv_I1_ Conv_I1
public Conv_I2_ Conv_I2
public Conv_I4_ Conv_I4
public Conv_I8_ Conv_I8
public Conv_R4_ Conv_R4
public Conv_R8_ Conv_R8
public Conv_U4_ Conv_U4
public Conv_U8_ Conv_U8
public Callvirt_ Callvirt
public Cpobj_ Cpobj
public Ldobj_ Ldobj
public Ldstr_ Ldstr
public Newobj_ Newobj
public Castclass_ Castclass
public Isinst_ Isinst
public Conv_R_Un_ Conv_R_Un
public Unbox_ Unbox
public Throw_ Throw
public Ldfld_ Ldfld
public Ldflda_ Ldflda
public Stfld_ Stfld
public Ldsfld_ Ldsfld
public Ldsflda_ Ldsflda
public Stsfld_ Stsfld
public Stobj_ Stobj
public Conv_Ovf_I1_Un_ Conv_Ovf_I1_Un
public Conv_Ovf_I2_Un_ Conv_Ovf_I2_Un
public Conv_Ovf_I4_Un_ Conv_Ovf_I4_Un
public Conv_Ovf_I8_Un_ Conv_Ovf_I8_Un
public Conv_Ovf_U1_Un_ Conv_Ovf_U1_Un
public Conv_Ovf_U2_Un_ Conv_Ovf_U2_Un
public Conv_Ovf_U4_Un_ Conv_Ovf_U4_Un
public Conv_Ovf_U8_Un_ Conv_Ovf_U8_Un
public Conv_Ovf_I_Un_ Conv_Ovf_I_Un
public Conv_Ovf_U_Un_ Conv_Ovf_U_Un
public Box_ Box
public Newarr_ Newarr
public Ldlen_ Ldlen
public Ldelema_ Ldelema
public Ldelem_I1_ Ldelem_I1
public Ldelem_U1_ Ldelem_U1
public Ldelem_I2_ Ldelem_I2
public Ldelem_U2_ Ldelem_U2
public Ldelem_I4_ Ldelem_I4
public Ldelem_U4_ Ldelem_U4
public Ldelem_I8_ Ldelem_I8
public Ldelem_I_ Ldelem_I
public Ldelem_R4_ Ldelem_R4
public Ldelem_R8_ Ldelem_R8
public Ldelem_Ref_ Ldelem_Ref
public Stelem_I_ Stelem_I
public Stelem_I1_ Stelem_I1
public Stelem_I2_ Stelem_I2
public Stelem_I4_ Stelem_I4
public Stelem_I8_ Stelem_I8
public Stelem_R4_ Stelem_R4
public Stelem_R8_ Stelem_R8
public Stelem_Ref_ Stelem_Ref
public Ldelem_ Ldelem
public Stelem_ Stelem
public Unbox_Any_ Unbox_Any
public Conv_Ovf_I1_ Conv_Ovf_I1
public Conv_Ovf_U1_ Conv_Ovf_U1
public Conv_Ovf_I2_ Conv_Ovf_I2
public Conv_Ovf_U2_ Conv_Ovf_U2
public Conv_Ovf_I4_ Conv_Ovf_I4
public Conv_Ovf_U4_ Conv_Ovf_U4
public Conv_Ovf_I8_ Conv_Ovf_I8
public Conv_Ovf_U8_ Conv_Ovf_U8
public Refanyval_ Refanyval
public Ckfinite_ Ckfinite
public Mkrefany_ Mkrefany
public Ldtoken_ Ldtoken
public Conv_U2_ Conv_U2
public Conv_U1_ Conv_U1
public Conv_I_ Conv_I
public Conv_Ovf_I_ Conv_Ovf_I
public Conv_Ovf_U_ Conv_Ovf_U
public Add_Ovf_ Add_Ovf
public Add_Ovf_Un_ Add_Ovf_Un
public Mul_Ovf_ Mul_Ovf
public Mul_Ovf_Un_ Mul_Ovf_Un
public Sub_Ovf_ Sub_Ovf
public Sub_Ovf_Un_ Sub_Ovf_Un
public Endfinally_ Endfinally
public Leave_ Leave
public Leave_S_ Leave_S
public Stind_I_ Stind_I
public Conv_U_ Conv_U
public Prefix7_ Prefix7
public Prefix6_ Prefix6
public Prefix5_ Prefix5
public Prefix4_ Prefix4
public Prefix3_ Prefix3
public Prefix2_ Prefix2
public Prefix1_ Prefix1
public Prefixref_ Prefixref
public Arglist_ Arglist
public Ceq_ Ceq
public Cgt_ Cgt
public Cgt_Un_ Cgt_Un
public Clt_ Clt
public Clt_Un_ Clt_Un
public Ldftn_ Ldftn
public Ldvirtftn_ Ldvirtftn
public Ldarg_ Ldarg
public Ldarga_ Ldarga
public Starg_ Starg
public Ldloc_ Ldloc
public Ldloca_ Ldloca
public Stloc_ Stloc
public Localloc_ Localloc
public Endfilter_ Endfilter
public Unaligned_ Unaligned
public Volatile_ Volatile
public Tailcall_ Tailcall
public Initobj_ Initobj
public Constrained_ Constrained
public Cpblk_ Cpblk
public Initblk_ Initblk
public Rethrow_ Rethrow
public Sizeof_ Sizeof
public Refanytype_ Refanytype
public Readonly_ Readonly
public Operand_ get_Operand()
public Nop_ get_Nop()
public Break_ get_Break()
public Ldarg_0_ get_Ldarg_0()
public Ldarg_1_ get_Ldarg_1()
public Ldarg_2_ get_Ldarg_2()
public Ldarg_3_ get_Ldarg_3()
public Ldloc_0_ get_Ldloc_0()
public Ldloc_1_ get_Ldloc_1()
public Ldloc_2_ get_Ldloc_2()
public Ldloc_3_ get_Ldloc_3()
public Stloc_0_ get_Stloc_0()
public Stloc_1_ get_Stloc_1()
public Stloc_2_ get_Stloc_2()
public Stloc_3_ get_Stloc_3()
public Ldarg_S_ get_Ldarg_S()
public Ldarga_S_ get_Ldarga_S()
public Starg_S_ get_Starg_S()
public Ldloc_S_ get_Ldloc_S()
public Ldloca_S_ get_Ldloca_S()
public Stloc_S_ get_Stloc_S()
public Ldnull_ get_Ldnull()
public Ldc_I4_M1_ get_Ldc_I4_M1()
public Ldc_I4_0_ get_Ldc_I4_0()
public Ldc_I4_1_ get_Ldc_I4_1()
public Ldc_I4_2_ get_Ldc_I4_2()
public Ldc_I4_3_ get_Ldc_I4_3()
public Ldc_I4_4_ get_Ldc_I4_4()
public Ldc_I4_5_ get_Ldc_I4_5()
public Ldc_I4_6_ get_Ldc_I4_6()
public Ldc_I4_7_ get_Ldc_I4_7()
public Ldc_I4_8_ get_Ldc_I4_8()
public Ldc_I4_S_ get_Ldc_I4_S()
public Ldc_I4_ get_Ldc_I4()
public Ldc_I8_ get_Ldc_I8()
public Ldc_R4_ get_Ldc_R4()
public Ldc_R8_ get_Ldc_R8()
public Dup_ get_Dup()
public Pop_ get_Pop()
public Jmp_ get_Jmp()
public Call_ get_Call()
public Calli_ get_Calli()
public Ret_ get_Ret()
public Br_S_ get_Br_S()
public Brfalse_S_ get_Brfalse_S()
public Brtrue_S_ get_Brtrue_S()
public Beq_S_ get_Beq_S()
public Bge_S_ get_Bge_S()
public Bgt_S_ get_Bgt_S()
public Ble_S_ get_Ble_S()
public Blt_S_ get_Blt_S()
public Bne_Un_S_ get_Bne_Un_S()
public Bge_Un_S_ get_Bge_Un_S()
public Bgt_Un_S_ get_Bgt_Un_S()
public Ble_Un_S_ get_Ble_Un_S()
public Blt_Un_S_ get_Blt_Un_S()
public Br_ get_Br()
public Brfalse_ get_Brfalse()
public Brtrue_ get_Brtrue()
public Beq_ get_Beq()
public Bge_ get_Bge()
public Bgt_ get_Bgt()
public Ble_ get_Ble()
public Blt_ get_Blt()
public Bne_Un_ get_Bne_Un()
public Bge_Un_ get_Bge_Un()
public Bgt_Un_ get_Bgt_Un()
public Ble_Un_ get_Ble_Un()
public Blt_Un_ get_Blt_Un()
public Switch_ get_Switch()
public Ldind_I1_ get_Ldind_I1()
public Ldind_U1_ get_Ldind_U1()
public Ldind_I2_ get_Ldind_I2()
public Ldind_U2_ get_Ldind_U2()
public Ldind_I4_ get_Ldind_I4()
public Ldind_U4_ get_Ldind_U4()
public Ldind_I8_ get_Ldind_I8()
public Ldind_I_ get_Ldind_I()
public Ldind_R4_ get_Ldind_R4()
public Ldind_R8_ get_Ldind_R8()
public Ldind_Ref_ get_Ldind_Ref()
public Stind_Ref_ get_Stind_Ref()
public Stind_I1_ get_Stind_I1()
public Stind_I2_ get_Stind_I2()
public Stind_I4_ get_Stind_I4()
public Stind_I8_ get_Stind_I8()
public Stind_R4_ get_Stind_R4()
public Stind_R8_ get_Stind_R8()
public Add_ get_Add()
public Sub_ get_Sub()
public Mul_ get_Mul()
public Div_ get_Div()
public Div_Un_ get_Div_Un()
public Rem_ get_Rem()
public Rem_Un_ get_Rem_Un()
public And_ get_And()
public Or_ get_Or()
public Xor_ get_Xor()
public Shl_ get_Shl()
public Shr_ get_Shr()
public Shr_Un_ get_Shr_Un()
public Neg_ get_Neg()
public Not_ get_Not()
public Conv_I1_ get_Conv_I1()
public Conv_I2_ get_Conv_I2()
public Conv_I4_ get_Conv_I4()
public Conv_I8_ get_Conv_I8()
public Conv_R4_ get_Conv_R4()
public Conv_R8_ get_Conv_R8()
public Conv_U4_ get_Conv_U4()
public Conv_U8_ get_Conv_U8()
public Callvirt_ get_Callvirt()
public Cpobj_ get_Cpobj()
public Ldobj_ get_Ldobj()
public Ldstr_ get_Ldstr()
public Newobj_ get_Newobj()
public Castclass_ get_Castclass()
public Isinst_ get_Isinst()
public Conv_R_Un_ get_Conv_R_Un()
public Unbox_ get_Unbox()
public Throw_ get_Throw()
public Ldfld_ get_Ldfld()
public Ldflda_ get_Ldflda()
public Stfld_ get_Stfld()
public Ldsfld_ get_Ldsfld()
public Ldsflda_ get_Ldsflda()
public Stsfld_ get_Stsfld()
public Stobj_ get_Stobj()
public Conv_Ovf_I1_Un_ get_Conv_Ovf_I1_Un()
public Conv_Ovf_I2_Un_ get_Conv_Ovf_I2_Un()
public Conv_Ovf_I4_Un_ get_Conv_Ovf_I4_Un()
public Conv_Ovf_I8_Un_ get_Conv_Ovf_I8_Un()
public Conv_Ovf_U1_Un_ get_Conv_Ovf_U1_Un()
public Conv_Ovf_U2_Un_ get_Conv_Ovf_U2_Un()
public Conv_Ovf_U4_Un_ get_Conv_Ovf_U4_Un()
public Conv_Ovf_U8_Un_ get_Conv_Ovf_U8_Un()
public Conv_Ovf_I_Un_ get_Conv_Ovf_I_Un()
public Conv_Ovf_U_Un_ get_Conv_Ovf_U_Un()
public Box_ get_Box()
public Newarr_ get_Newarr()
public Ldlen_ get_Ldlen()
public Ldelema_ get_Ldelema()
public Ldelem_I1_ get_Ldelem_I1()
public Ldelem_U1_ get_Ldelem_U1()
public Ldelem_I2_ get_Ldelem_I2()
public Ldelem_U2_ get_Ldelem_U2()
public Ldelem_I4_ get_Ldelem_I4()
public Ldelem_U4_ get_Ldelem_U4()
public Ldelem_I8_ get_Ldelem_I8()
public Ldelem_I_ get_Ldelem_I()
public Ldelem_R4_ get_Ldelem_R4()
public Ldelem_R8_ get_Ldelem_R8()
public Ldelem_Ref_ get_Ldelem_Ref()
public Stelem_I_ get_Stelem_I()
public Stelem_I1_ get_Stelem_I1()
public Stelem_I2_ get_Stelem_I2()
public Stelem_I4_ get_Stelem_I4()
public Stelem_I8_ get_Stelem_I8()
public Stelem_R4_ get_Stelem_R4()
public Stelem_R8_ get_Stelem_R8()
public Stelem_Ref_ get_Stelem_Ref()
public Ldelem_ get_Ldelem()
public Stelem_ get_Stelem()
public Unbox_Any_ get_Unbox_Any()
public Conv_Ovf_I1_ get_Conv_Ovf_I1()
public Conv_Ovf_U1_ get_Conv_Ovf_U1()
public Conv_Ovf_I2_ get_Conv_Ovf_I2()
public Conv_Ovf_U2_ get_Conv_Ovf_U2()
public Conv_Ovf_I4_ get_Conv_Ovf_I4()
public Conv_Ovf_U4_ get_Conv_Ovf_U4()
public Conv_Ovf_I8_ get_Conv_Ovf_I8()
public Conv_Ovf_U8_ get_Conv_Ovf_U8()
public Refanyval_ get_Refanyval()
public Ckfinite_ get_Ckfinite()
public Mkrefany_ get_Mkrefany()
public Ldtoken_ get_Ldtoken()
public Conv_U2_ get_Conv_U2()
public Conv_U1_ get_Conv_U1()
public Conv_I_ get_Conv_I()
public Conv_Ovf_I_ get_Conv_Ovf_I()
public Conv_Ovf_U_ get_Conv_Ovf_U()
public Add_Ovf_ get_Add_Ovf()
public Add_Ovf_Un_ get_Add_Ovf_Un()
public Mul_Ovf_ get_Mul_Ovf()
public Mul_Ovf_Un_ get_Mul_Ovf_Un()
public Sub_Ovf_ get_Sub_Ovf()
public Sub_Ovf_Un_ get_Sub_Ovf_Un()
public Endfinally_ get_Endfinally()
public Leave_ get_Leave()
public Leave_S_ get_Leave_S()
public Stind_I_ get_Stind_I()
public Conv_U_ get_Conv_U()
public Prefix7_ get_Prefix7()
public Prefix6_ get_Prefix6()
public Prefix5_ get_Prefix5()
public Prefix4_ get_Prefix4()
public Prefix3_ get_Prefix3()
public Prefix2_ get_Prefix2()
public Prefix1_ get_Prefix1()
public Prefixref_ get_Prefixref()
public Arglist_ get_Arglist()
public Ceq_ get_Ceq()
public Cgt_ get_Cgt()
public Cgt_Un_ get_Cgt_Un()
public Clt_ get_Clt()
public Clt_Un_ get_Clt_Un()
public Ldftn_ get_Ldftn()
public Ldvirtftn_ get_Ldvirtftn()
public Ldarg_ get_Ldarg()
public Ldarga_ get_Ldarga()
public Starg_ get_Starg()
public Ldloc_ get_Ldloc()
public Ldloca_ get_Ldloca()
public Stloc_ get_Stloc()
public Localloc_ get_Localloc()
public Endfilter_ get_Endfilter()
public Unaligned_ get_Unaligned()
public Volatile_ get_Volatile()
public Tailcall_ get_Tailcall()
public Initobj_ get_Initobj()
public Constrained_ get_Constrained()
public Cpblk_ get_Cpblk()
public Initblk_ get_Initblk()
public Rethrow_ get_Rethrow()
public Sizeof_ get_Sizeof()
public Refanytype_ get_Refanytype()
public Readonly_ get_Readonly()
}
public HarmonyLib.CodeInstruction : object {
public OpCode opcode
public object operand
public List`1<Label> labels
public List`1<ExceptionBlock> blocks
public void .ctor(OpCode opcode, object operand)
public void .ctor(CodeInstruction instruction)
public CodeInstruction Clone()
public CodeInstruction Clone(OpCode opcode)
public CodeInstruction Clone(object operand)
public CodeInstruction Call(Type type, string name, Type[] parameters, Type[] generics)
public CodeInstruction Call(string typeColonMethodname, Type[] parameters, Type[] generics)
public CodeInstruction Call(Expression`1<Action> expression)
public CodeInstruction Call(Expression`1<Action`1<T>> expression)
public CodeInstruction Call(Expression`1<Func`2<T, TResult>> expression)
public CodeInstruction Call(LambdaExpression expression)
public CodeInstruction CallClosure(T closure)
public CodeInstruction LoadField(Type type, string name, bool useAddress)
public CodeInstruction StoreField(Type type, string name)
public CodeInstruction LoadLocal(int index, bool useAddress)
public CodeInstruction StoreLocal(int index)
public CodeInstruction LoadArgument(int index, bool useAddress)
public CodeInstruction StoreArgument(int index)
public string ToString()
}
public HarmonyLib.CodeInstructionExtensions : object {
internal HashSet`1<OpCode> opcodesCalling
internal HashSet`1<OpCode> opcodesLoadingLocalByAddress
internal HashSet`1<OpCode> opcodesLoadingLocalNormal
internal HashSet`1<OpCode> opcodesStoringLocal
internal HashSet`1<OpCode> opcodesLoadingArgumentByAddress
internal HashSet`1<OpCode> opcodesLoadingArgumentNormal
internal HashSet`1<OpCode> opcodesStoringArgument
internal HashSet`1<OpCode> opcodesBranching
private HashSet`1<OpCode> constantLoadingCodes
public bool IsValid(OpCode code)
public bool OperandIs(CodeInstruction code, object value)
public bool OperandIs(CodeInstruction code, MemberInfo value)
public bool Is(CodeInstruction code, OpCode opcode, object operand)
public bool Is(CodeInstruction code, OpCode opcode, MemberInfo operand)
public bool IsLdarg(CodeInstruction code, Nullable`1<int> n)
public bool IsLdarga(CodeInstruction code, Nullable`1<int> n)
public bool IsStarg(CodeInstruction code, Nullable`1<int> n)
public bool IsLdloc(CodeInstruction code, LocalBuilder variable)
public bool IsStloc(CodeInstruction code, LocalBuilder variable)
public bool Branches(CodeInstruction code, Nullable`1& label)
public bool Calls(CodeInstruction code, MethodInfo method)
public bool LoadsConstant(CodeInstruction code)
public bool LoadsConstant(CodeInstruction code, long number)
public bool LoadsConstant(CodeInstruction code, double number)
public bool LoadsConstant(CodeInstruction code, Enum e)
public bool LoadsConstant(CodeInstruction code, string str)
public bool LoadsField(CodeInstruction code, FieldInfo field, bool byAddress)
public bool StoresField(CodeInstruction code, FieldInfo field)
public int LocalIndex(CodeInstruction code)
public int ArgumentIndex(CodeInstruction code)
public CodeInstruction WithLabels(CodeInstruction code, Label[] labels)
public CodeInstruction WithLabels(CodeInstruction code, IEnumerable`1<Label> labels)
public List`1<Label> ExtractLabels(CodeInstruction code)
public CodeInstruction MoveLabelsTo(CodeInstruction code, CodeInstruction other)
public CodeInstruction MoveLabelsFrom(CodeInstruction code, CodeInstruction other)
public CodeInstruction WithBlocks(CodeInstruction code, ExceptionBlock[] blocks)
public CodeInstruction WithBlocks(CodeInstruction code, IEnumerable`1<ExceptionBlock> blocks)
public List`1<ExceptionBlock> ExtractBlocks(CodeInstruction code)
public CodeInstruction MoveBlocksTo(CodeInstruction code, CodeInstruction other)
public CodeInstruction MoveBlocksFrom(CodeInstruction code, CodeInstruction other)
}
public HarmonyLib.CodeInstructionsExtensions : object {
public bool Matches(IEnumerable`1<CodeInstruction> instructions, CodeMatch[] matches)
}
public HarmonyLib.CodeMatch : CodeInstruction {
public string name
public HashSet`1<OpCode> opcodeSet
public List`1<object> operands
public List`1<int> jumpsFrom
public List`1<int> jumpsTo
public Func`2<CodeInstruction, bool> predicate
public List`1<OpCode> opcodes
public List`1<OpCode> get_opcodes()
public void set_opcodes(List`1<OpCode> value)
internal CodeMatch Set(object operand, string name)
internal CodeMatch Set(OpCode opcode, object operand, string name)
public void .ctor(Nullable`1<OpCode> opcode, object operand, string name)
public CodeMatch WithOpcodes(HashSet`1<OpCode> opcodes, object operand, string name)
public void .ctor(Expression`1<Action> expression, string name)
public void .ctor(LambdaExpression expression, string name)
public void .ctor(CodeInstruction instruction, string name)
public void .ctor(Func`2<CodeInstruction, bool> predicate, string name)
internal bool Matches(List`1<CodeInstruction> codes, CodeInstruction instruction)
public CodeMatch IsLdarg(Nullable`1<int> n)
public CodeMatch IsLdarga(Nullable`1<int> n)
public CodeMatch IsStarg(Nullable`1<int> n)
public CodeMatch IsLdloc(LocalBuilder variable)
public CodeMatch IsStloc(LocalBuilder variable)
public CodeMatch Calls(MethodInfo method)
public CodeMatch LoadsConstant()
public CodeMatch LoadsConstant(long number)
public CodeMatch LoadsConstant(double number)
public CodeMatch LoadsConstant(Enum e)
public CodeMatch LoadsConstant(string str)
public CodeMatch LoadsField(FieldInfo field, bool byAddress)
public CodeMatch StoresField(FieldInfo field)
public CodeMatch Calls(Expression`1<Action> expression)
public CodeMatch Calls(LambdaExpression expression)
public CodeMatch LoadsLocal(bool useAddress, string name)
public CodeMatch StoresLocal(string name)
public CodeMatch LoadsArgument(bool useAddress, string name)
public CodeMatch StoresArgument(string name)
public CodeMatch Branches(string name)
public string ToString()
}
public HarmonyLib.CodeMatcher : object {
private ILGenerator generator
private List`1<CodeInstruction> codes
private int <Pos>k__BackingField
private Dictionary`2<string, CodeInstruction> lastMatches
private string lastError
private MatchDelegate lastMatchCall
public int Pos
public int Length
public bool IsValid
public bool IsInvalid
public int Remaining
public OpCode& Opcode
public Object& Operand
public List`1& Labels
public List`1& Blocks
public CodeInstruction Instruction
public int get_Pos()
private void set_Pos(int value)
private void FixStart()
private void SetOutOfBounds(int direction)
public int get_Length()
public bool get_IsValid()
public bool get_IsInvalid()
public int get_Remaining()
public OpCode& get_Opcode()
public Object& get_Operand()
public List`1& get_Labels()
public List`1& get_Blocks()
public void .ctor(IEnumerable`1<CodeInstruction> instructions, ILGenerator generator)
public CodeMatcher Clone()
public CodeInstruction get_Instruction()
public CodeInstruction InstructionAt(int offset)
public List`1<CodeInstruction> Instructions()
public IEnumerable`1<CodeInstruction> InstructionEnumeration()
public List`1<CodeInstruction> Instructions(int count)
public List`1<CodeInstruction> InstructionsInRange(int start, int end)
public List`1<CodeInstruction> InstructionsWithOffsets(int startOffset, int endOffset)
public List`1<Label> DistinctLabels(IEnumerable`1<CodeInstruction> instructions)
public bool ReportFailure(MethodBase method, Action`1<string> logger)
public CodeMatcher ThrowIfInvalid(string explanation)
public CodeMatcher ThrowIfNotMatch(string explanation, CodeMatch[] matches)
private void ThrowIfNotMatch(string explanation, int direction, CodeMatch[] matches)
public CodeMatcher ThrowIfNotMatchForward(string explanation, CodeMatch[] matches)
public CodeMatcher ThrowIfNotMatchBack(string explanation, CodeMatch[] matches)
public CodeMatcher ThrowIfFalse(string explanation, Func`2<CodeMatcher, bool> stateCheckFunc)
public CodeMatcher SetInstruction(CodeInstruction instruction)
public CodeMatcher SetInstructionAndAdvance(CodeInstruction instruction)
public CodeMatcher Set(OpCode opcode, object operand)
public CodeMatcher SetAndAdvance(OpCode opcode, object operand)
public CodeMatcher SetOpcodeAndAdvance(OpCode opcode)
public CodeMatcher SetOperandAndAdvance(object operand)
public CodeMatcher DeclareLocal(Type variableType, LocalBuilder& localVariable)
public CodeMatcher DefineLabel(Label& label)
public CodeMatcher CreateLabel(Label& label)
public CodeMatcher CreateLabelAt(int position, Label& label)
public CodeMatcher CreateLabelWithOffsets(int offset, Label& label)
public CodeMatcher AddLabels(IEnumerable`1<Label> labels)
public CodeMatcher AddLabelsAt(int position, IEnumerable`1<Label> labels)
public CodeMatcher SetJumpTo(OpCode opcode, int destination, Label& label)
public CodeMatcher Insert(CodeInstruction[] instructions)
public CodeMatcher Insert(IEnumerable`1<CodeInstruction> instructions)
public CodeMatcher InsertBranch(OpCode opcode, int destination)
public CodeMatcher InsertAndAdvance(CodeInstruction[] instructions)
public CodeMatcher InsertAndAdvance(IEnumerable`1<CodeInstruction> instructions)
public CodeMatcher InsertBranchAndAdvance(OpCode opcode, int destination)
public CodeMatcher RemoveInstruction()
public CodeMatcher RemoveInstructions(int count)
public CodeMatcher RemoveInstructionsInRange(int start, int end)
public CodeMatcher RemoveInstructionsWithOffsets(int startOffset, int endOffset)
public CodeMatcher Advance(int offset)
public CodeMatcher Start()
public CodeMatcher End()
public CodeMatcher SearchForward(Func`2<CodeInstruction, bool> predicate)
public CodeMatcher SearchBackwards(Func`2<CodeInstruction, bool> predicate)
private CodeMatcher Search(Func`2<CodeInstruction, bool> predicate, int direction)
public CodeMatcher MatchStartForward(CodeMatch[] matches)
public CodeMatcher MatchEndForward(CodeMatch[] matches)
public CodeMatcher MatchStartBackwards(CodeMatch[] matches)
public CodeMatcher MatchEndBackwards(CodeMatch[] matches)
private CodeMatcher Match(CodeMatch[] matches, int direction, bool useEnd)
public CodeMatcher Repeat(Action`1<CodeMatcher> matchAction, Action`1<string> notFoundAction)
public CodeInstruction NamedMatch(string name)
private bool MatchSequence(int start, CodeMatch[] matches)
}
internal HarmonyLib.CodeTranspiler : object {
private IEnumerable`1<CodeInstruction> codeInstructions
private List`1<MethodInfo> transpilers
private Dictionary`2<OpCode, OpCode> allJumpCodes
internal void .ctor(List`1<ILInstruction> ilInstructions)
internal void Add(MethodInfo transpiler)
internal object ConvertInstruction(Type type, object instruction, Dictionary`2& unassigned)
internal bool ShouldAddExceptionInfo(object op, int opIndex, List`1<object> originalInstructions, List`1<object> newInstructions, Dictionary`2<object, Dictionary`2<string, object>> unassignedValues)
internal IEnumerable ConvertInstructionsAndUnassignedValues(Type type, IEnumerable enumerable, Dictionary`2& unassignedValues)
internal IEnumerable ConvertToOurInstructions(IEnumerable instructions, Type codeInstructionType, List`1<object> originalInstructions, Dictionary`2<object, Dictionary`2<string, object>> unassignedValues)
private bool IsCodeInstructionsParameter(Type type)
internal IEnumerable ConvertToGeneralInstructions(MethodInfo transpiler, IEnumerable enumerable, Dictionary`2& unassignedValues)
internal List`1<object> GetTranspilerCallParameters(ILGenerator generator, MethodInfo transpiler, MethodBase method, IEnumerable instructions)
internal List`1<CodeInstruction> GetResult(ILGenerator generator, MethodBase method)
private OpCode ReplaceShortJumps(OpCode opcode)
}
public HarmonyLib.CollectionExtensions : object {
public void Do(IEnumerable`1<T> sequence, Action`1<T> action)
public void DoIf(IEnumerable`1<T> sequence, Func`2<T, bool> condition, Action`1<T> action)
public IEnumerable`1<T> AddItem(IEnumerable`1<T> sequence, T item)
public T[] AddToArray(T[] sequence, T item)
public T[] AddRangeToArray(T[] sequence, T[] items)
internal Dictionary`2<K, V> Merge(IEnumerable`1<KeyValuePair`2<K, V>> firstDict, IEnumerable`1[] otherDicts)
internal Dictionary`2<K, V> TransformKeys(Dictionary`2<K, V> origDict, Func`2<K, K> transform)
}
public HarmonyLib.DelegateTypeFactory : object {
private ModuleBuilder module
private int counter
public Type CreateDelegateType(MethodInfo method)
}
internal HarmonyLib.Emitter : object {
private CecilILGenerator il
private Dictionary`2<int, CodeInstruction> instructions
private bool debug
internal void .ctor(ILGenerator il, bool debug)
internal Dictionary`2<int, CodeInstruction> GetInstructions()
internal void AddInstruction(OpCode opcode, object operand)
internal int CurrentPos()
internal string CodePos(int offset)
internal string CodePos()
internal void LogComment(string comment)
internal void LogIL(OpCode opcode)
internal void LogIL(OpCode opcode, object arg, string extra)
internal void LogAllLocalVariables()
internal string FormatArgument(object argument, string extra)
internal void MarkLabel(Label label)
internal void MarkBlockBefore(ExceptionBlock block, Nullable`1& label)
internal void MarkBlockAfter(ExceptionBlock block)
internal void Emit(OpCode opcode)
internal void Emit(OpCode opcode, LocalBuilder local)
internal void Emit(OpCode opcode, FieldInfo field)
internal void Emit(OpCode opcode, Label[] labels)
internal void Emit(OpCode opcode, Label label)
internal void Emit(OpCode opcode, string str)
internal void Emit(OpCode opcode, float arg)
internal void Emit(OpCode opcode, byte arg)
internal void Emit(OpCode opcode, sbyte arg)
internal void Emit(OpCode opcode, double arg)
internal void Emit(OpCode opcode, int arg)
internal void Emit(OpCode opcode, MethodInfo meth)
internal void Emit(OpCode opcode, short arg)
internal void Emit(OpCode opcode, SignatureHelper signature)
internal void Emit(OpCode opcode, ConstructorInfo con)
internal void Emit(OpCode opcode, Type cls)
internal void Emit(OpCode opcode, long arg)
internal void EmitCall(OpCode opcode, MethodInfo methodInfo, Type[] optionalParameterTypes)
internal void EmitCalli(OpCode opcode, CallingConvention unmanagedCallConv, Type returnType, Type[] parameterTypes)
internal void EmitCalli(OpCode opcode, CallingConventions callingConvention, Type returnType, Type[] parameterTypes, Type[] optionalParameterTypes)
}
public HarmonyLib.ExceptionBlock : object {
public ExceptionBlockType blockType
public Type catchType
public void .ctor(ExceptionBlockType blockType, Type catchType)
}
public HarmonyLib.ExceptionBlockType : Enum {
public int value__
public ExceptionBlockType BeginExceptionBlock
public ExceptionBlockType BeginCatchBlock
public ExceptionBlockType BeginExceptFilterBlock
public ExceptionBlockType BeginFaultBlock
public ExceptionBlockType BeginFinallyBlock
public ExceptionBlockType EndExceptionBlock
}
public HarmonyLib.FastAccess : object {
public InstantiationHandler`1<T> CreateInstantiationHandler()
public GetterHandler`2<T, S> CreateGetterHandler(PropertyInfo propertyInfo)
public GetterHandler`2<T, S> CreateGetterHandler(FieldInfo fieldInfo)
public GetterHandler`2<T, S> CreateFieldGetter(String[] names)
public SetterHandler`2<T, S> CreateSetterHandler(PropertyInfo propertyInfo)
public SetterHandler`2<T, S> CreateSetterHandler(FieldInfo fieldInfo)
private DynamicMethodDefinition CreateGetDynamicMethod(Type type)
private DynamicMethodDefinition CreateSetDynamicMethod(Type type)
}
public HarmonyLib.FastInvokeHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public object Invoke(object target, Object[] parameters)
public IAsyncResult BeginInvoke(object target, Object[] parameters, AsyncCallback callback, object object)
public object EndInvoke(IAsyncResult result)
}
public HarmonyLib.FileLog : object {
private object fileLock
private bool _logPathInited
private string _logPath
private StreamWriter <LogWriter>k__BackingField
public char indentChar
public int indentLevel
private List`1<string> buffer
public StreamWriter LogWriter
public string LogPath
public StreamWriter get_LogWriter()
public void set_LogWriter(StreamWriter value)
public string get_LogPath()
private string IndentString()
public void ChangeIndent(int delta)
public void LogBuffered(string str)
public void LogBuffered(List`1<string> strings)
public List`1<string> GetBuffer(bool clear)
public void SetBuffer(List`1<string> buffer)
public void FlushBuffer()
public void Log(string str)
public void Debug(string str)
public void Reset()
public void LogBytes(long ptr, int len)
}
public HarmonyLib.GeneralExtensions : object {
public string Join(IEnumerable`1<T> enumeration, Func`2<T, string> converter, string delimiter)
public string Description(Type[] parameters)
public string FullDescription(Type type)
public string FullDescription(MethodBase member)
public Type[] Types(ParameterInfo[] pinfo)
public T GetValueSafe(Dictionary`2<S, T> dictionary, S key)
public T GetTypedValue(Dictionary`2<string, object> dictionary, string key)
public string ToLiteral(string input, string quoteChar)
}
public HarmonyLib.GetterHandler`2 : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public S Invoke(T source)
public IAsyncResult BeginInvoke(T source, AsyncCallback callback, object object)
public S EndInvoke(IAsyncResult result)
}
public HarmonyLib.Harmony : object {
private string <Id>k__BackingField
public bool DEBUG
public string Id
public string get_Id()
private void set_Id(string value)
public void .ctor(string id)
public void PatchAll()
public PatchProcessor CreateProcessor(MethodBase original)
public PatchClassProcessor CreateClassProcessor(Type type)
public ReversePatcher CreateReversePatcher(MethodBase original, HarmonyMethod standin)
public void PatchAll(Assembly assembly)
public void PatchAllUncategorized()
public void PatchAllUncategorized(Assembly assembly)
public void PatchCategory(string category)
public void PatchCategory(Assembly assembly, string category)
public MethodInfo Patch(MethodBase original, HarmonyMethod prefix, HarmonyMethod postfix, HarmonyMethod transpiler, HarmonyMethod finalizer)
public MethodInfo ReversePatch(MethodBase original, HarmonyMethod standin, MethodInfo transpiler)
public void UnpatchAll(string harmonyID)
public void Unpatch(MethodBase original, HarmonyPatchType type, string harmonyID)
public void Unpatch(MethodBase original, MethodInfo patch)
public bool HasAnyPatches(string harmonyID)
public Patches GetPatchInfo(MethodBase method)
public IEnumerable`1<MethodBase> GetPatchedMethods()
public IEnumerable`1<MethodBase> GetAllPatchedMethods()
public MethodBase GetOriginalMethod(MethodInfo replacement)
public MethodBase GetMethodFromStackframe(StackFrame frame)
public MethodBase GetOriginalMethodFromStackframe(StackFrame frame)
public Dictionary`2<string, Version> VersionInfo(Version& currentVersion)
private void <PatchAll>b__10_0(Type type)
private bool <GetPatchedMethods>b__22_0(MethodBase original)
}
public HarmonyLib.HarmonyAfter : HarmonyAttribute {
public void .ctor(String[] after)
}
public HarmonyLib.HarmonyArgument : Attribute {
private string <OriginalName>k__BackingField
private int <Index>k__BackingField
private string <NewName>k__BackingField
public string OriginalName
public int Index
public string NewName
public string get_OriginalName()
private void set_OriginalName(string value)
public int get_Index()
private void set_Index(int value)
public string get_NewName()
private void set_NewName(string value)
public void .ctor(string originalName)
public void .ctor(int index)
public void .ctor(string originalName, string newName)
public void .ctor(int index, string name)
}
public HarmonyLib.HarmonyAttribute : Attribute {
public HarmonyMethod info
}
public HarmonyLib.HarmonyBefore : HarmonyAttribute {
public void .ctor(String[] before)
}
public HarmonyLib.HarmonyDelegate : HarmonyPatch {
public void .ctor(Type declaringType)
public void .ctor(Type declaringType, Type[] argumentTypes)
public void .ctor(Type declaringType, string methodName)
public void .ctor(Type declaringType, string methodName, Type[] argumentTypes)
public void .ctor(Type declaringType, string methodName, Type[] argumentTypes, ArgumentType[] argumentVariations)
public void .ctor(Type declaringType, MethodDispatchType methodDispatchType)
public void .ctor(Type declaringType, MethodDispatchType methodDispatchType, Type[] argumentTypes)
public void .ctor(Type declaringType, MethodDispatchType methodDispatchType, Type[] argumentTypes, ArgumentType[] argumentVariations)
public void .ctor(Type declaringType, string methodName, MethodDispatchType methodDispatchType)
public void .ctor(string methodName)
public void .ctor(string methodName, Type[] argumentTypes)
public void .ctor(string methodName, Type[] argumentTypes, ArgumentType[] argumentVariations)
public void .ctor(string methodName, MethodDispatchType methodDispatchType)
public void .ctor(MethodDispatchType methodDispatchType)
public void .ctor(MethodDispatchType methodDispatchType, Type[] argumentTypes)
public void .ctor(MethodDispatchType methodDispatchType, Type[] argumentTypes, ArgumentType[] argumentVariations)
public void .ctor(Type[] argumentTypes)
public void .ctor(Type[] argumentTypes, ArgumentType[] argumentVariations)
}
public HarmonyLib.HarmonyException : Exception {
private Dictionary`2<int, CodeInstruction> instructions
private int errorOffset
internal void .ctor(string message)
internal void .ctor(string message, Exception innerException)
protected void .ctor(SerializationInfo serializationInfo, StreamingContext streamingContext)
internal void .ctor(Exception innerException, Dictionary`2<int, CodeInstruction> instructions, int errorOffset)
internal Exception Create(Exception ex, Dictionary`2<int, CodeInstruction> finalInstructions)
public List`1<KeyValuePair`2<int, CodeInstruction>> GetInstructionsWithOffsets()
public List`1<CodeInstruction> GetInstructions()
public int GetErrorOffset()
public int GetErrorIndex()
}
public HarmonyLib.HarmonyMethod : object {
public MethodInfo method
public string category
public Type declaringType
public string methodName
public Nullable`1<MethodType> methodType
public Type[] argumentTypes
public int priority
public String[] before
public String[] after
public Nullable`1<HarmonyReversePatchType> reversePatchType
public Nullable`1<bool> debug
public bool nonVirtualDelegate
private void ImportMethod(MethodInfo theMethod)
public void .ctor(MethodInfo method)
public void .ctor(Delegate delegate)
public void .ctor(MethodInfo method, int priority, String[] before, String[] after, Nullable`1<bool> debug)
public void .ctor(Delegate delegate, int priority, String[] before, String[] after, Nullable`1<bool> debug)
public void .ctor(Type methodType, string methodName, Type[] argumentTypes)
public List`1<string> HarmonyFields()
public HarmonyMethod Merge(List`1<HarmonyMethod> attributes)
public string ToString()
internal string Description()
public HarmonyMethod op_Implicit(MethodInfo method)
public HarmonyMethod op_Implicit(Delegate delegate)
}
public HarmonyLib.HarmonyMethodExtensions : object {
internal void SetValue(Traverse trv, string name, object val)
public void CopyTo(HarmonyMethod from, HarmonyMethod to)
public HarmonyMethod Clone(HarmonyMethod original)
public HarmonyMethod Merge(HarmonyMethod master, HarmonyMethod detail)
private HarmonyMethod GetHarmonyMethodInfo(object attribute)
public List`1<HarmonyMethod> GetFromType(Type type)
public HarmonyMethod GetMergedFromType(Type type)
public List`1<HarmonyMethod> GetFromMethod(MethodBase method)
public HarmonyMethod GetMergedFromMethod(MethodBase method)
}
public HarmonyLib.HarmonyPatch : HarmonyAttribute {
public void .ctor(Type declaringType)
public void .ctor(Type declaringType, Type[] argumentTypes)
public void .ctor(Type declaringType, string methodName)
public void .ctor(Type declaringType, string methodName, Type[] argumentTypes)
public void .ctor(Type declaringType, string methodName, Type[] argumentTypes, ArgumentType[] argumentVariations)
public void .ctor(Type declaringType, MethodType methodType)
public void .ctor(Type declaringType, MethodType methodType, Type[] argumentTypes)
public void .ctor(Type declaringType, MethodType methodType, Type[] argumentTypes, ArgumentType[] argumentVariations)
public void .ctor(Type declaringType, string methodName, MethodType methodType)
public void .ctor(string methodName)
public void .ctor(string methodName, Type[] argumentTypes)
public void .ctor(string methodName, Type[] argumentTypes, ArgumentType[] argumentVariations)
public void .ctor(string methodName, MethodType methodType)
public void .ctor(MethodType methodType)
public void .ctor(MethodType methodType, Type[] argumentTypes)
public void .ctor(MethodType methodType, Type[] argumentTypes, ArgumentType[] argumentVariations)
public void .ctor(Type[] argumentTypes)
public void .ctor(Type[] argumentTypes, ArgumentType[] argumentVariations)
public void .ctor(string typeName, string methodName, MethodType methodType)
private void ParseSpecialArguments(Type[] argumentTypes, ArgumentType[] argumentVariations)
}
public HarmonyLib.HarmonyPatchCategory : HarmonyAttribute {
public void .ctor(string category)
}
public HarmonyLib.HarmonyPatchType : Enum {
public int value__
public HarmonyPatchType All
public HarmonyPatchType Prefix
public HarmonyPatchType Postfix
public HarmonyPatchType Transpiler
public HarmonyPatchType Finalizer
public HarmonyPatchType ReversePatch
}
public HarmonyLib.HarmonyPriority : HarmonyAttribute {
public void .ctor(int priority)
}
public HarmonyLib.HarmonyReversePatch : HarmonyAttribute {
public void .ctor(HarmonyReversePatchType type)
}
public HarmonyLib.HarmonyReversePatchType : Enum {
public int value__
public HarmonyReversePatchType Original
public HarmonyReversePatchType Snapshot
}
internal HarmonyLib.HarmonySharedState : object {
private string name
internal int internalVersion
private Dictionary`2<MethodBase, Byte[]> state
private Dictionary`2<MethodInfo, MethodBase> originals
internal int actualVersion
private Type GetOrCreateSharedStateType()
internal PatchInfo GetPatchInfo(MethodBase method)
internal IEnumerable`1<MethodBase> GetPatchedMethods()
internal void UpdatePatchInfo(MethodBase original, MethodInfo replacement, PatchInfo patchInfo)
internal MethodBase GetOriginal(MethodInfo replacement)
internal MethodBase FindReplacement(StackFrame frame)
}
internal HarmonyLib.ILInstruction : object {
internal int offset
internal OpCode opcode
internal object operand
internal object argument
internal List`1<Label> labels
internal List`1<ExceptionBlock> blocks
internal void .ctor(OpCode opcode, object operand)
internal CodeInstruction GetCodeInstruction()
internal int GetSize()
public string ToString()
private void AppendLabel(String& str, object argument)
}
internal HarmonyLib.InlineSignature : object {
private bool <HasThis>k__BackingField
private bool <ExplicitThis>k__BackingField
private CallingConvention <CallingConvention>k__BackingField
private List`1<object> <Parameters>k__BackingField
private object <ReturnType>k__BackingField
public bool HasThis
public bool ExplicitThis
public CallingConvention CallingConvention
public List`1<object> Parameters
public object ReturnType
public bool get_HasThis()
public void set_HasThis(bool value)
public bool get_ExplicitThis()
public void set_ExplicitThis(bool value)
public CallingConvention get_CallingConvention()
public void set_CallingConvention(CallingConvention value)
public List`1<object> get_Parameters()
public void set_Parameters(List`1<object> value)
public object get_ReturnType()
public void set_ReturnType(object value)
public string ToString()
internal TypeReference GetTypeReference(ModuleDefinition module, object param)
private CallSite MonoMod.Utils.ICallSiteGenerator.ToCallSite(ModuleDefinition module)
private FunctionPointerType ToFunctionPointer(ModuleDefinition module)
}
internal HarmonyLib.InlineSignatureParser : object {
internal InlineSignature ImportCallSite(Module moduleFrom, Byte[] data)
}
public HarmonyLib.InstantiationHandler`1 : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public T Invoke()
public IAsyncResult BeginInvoke(AsyncCallback callback, object object)
public T EndInvoke(IAsyncResult result)
}
internal HarmonyLib.LeaveTry : object {
public string ToString()
}
public HarmonyLib.MethodBaseExtensions : object {
public bool HasMethodBody(MethodBase member)
}
internal HarmonyLib.MethodBodyReader : object {
private ILGenerator generator
private MethodBase method
private bool debug
private Module module
private Type[] typeArguments
private Type[] methodArguments
private ByteBuffer ilBytes
private ParameterInfo this_parameter
private ParameterInfo[] parameters
private IList`1<ExceptionHandlingClause> exceptions
private List`1<ILInstruction> ilInstructions
private List`1<LocalVariableInfo> localVariables
private LocalBuilder[] variables
private Dictionary`2<OpCode, OpCode> shortJumps
private OpCode[] one_byte_opcodes
private OpCode[] two_bytes_opcodes
internal List`1<ILInstruction> GetInstructions(ILGenerator generator, MethodBase method)
internal void .ctor(MethodBase method, ILGenerator generator)
internal void SetDebugging(bool debug)
internal void GenerateInstructions()
internal void HandleNativeMethod()
internal void DeclareVariables(LocalBuilder[] existingVariables)
private void ResolveBranches()
private void ParseExceptions()
private bool EndsInDeadCode(List`1<CodeInstruction> list)
internal List`1<CodeInstruction> FinalizeILCodes(Emitter emitter, List`1<MethodInfo> transpilers, List`1<Label> endLabels, Boolean& hasReturnCode, Boolean& methodEndsInDeadCode)
private void GetMemberInfoValue(MemberInfo info, Object& result)
private void ReadOperand(ILInstruction instruction)
private ILInstruction GetInstruction(int offset, bool isEndOfInstruction)
private bool TargetsLocalVariable(OpCode opcode)
private LocalVariableInfo GetLocalVariable(int index)
private ParameterInfo GetParameter(int index)
private OpCode ReadOpCode()
private LocalBuilder <DeclareVariables>b__18_0(LocalVariableInfo lvi)
}
internal HarmonyLib.MethodCopier : object {
private MethodBodyReader reader
private List`1<MethodInfo> transpilers
internal void .ctor(MethodBase fromMethod, ILGenerator toILGenerator, LocalBuilder[] existingVariables)
internal void SetDebugging(bool debug)
internal void AddTranspiler(MethodInfo transpiler)
internal List`1<CodeInstruction> Finalize(Emitter emitter, List`1<Label> endLabels, Boolean& hasReturnCode, Boolean& methodEndsInDeadCode)
internal List`1<CodeInstruction> GetInstructions(ILGenerator generator, MethodBase method, int maxTranspilers)
}
public HarmonyLib.MethodDispatchType : Enum {
public int value__
public MethodDispatchType VirtualCall
public MethodDispatchType Call
}
public HarmonyLib.MethodInvoker : object {
public FastInvokeHandler GetHandler(MethodInfo methodInfo, bool directBoxValueAccess)
internal void Emit(ILGenerator il, OpCode opcode)
internal void Emit(ILGenerator il, OpCode opcode, Type type)
internal void EmitCall(ILGenerator il, OpCode opcode, MethodInfo methodInfo)
private void EmitUnboxIfNeeded(ILGenerator il, Type type)
private void EmitBoxIfNeeded(ILGenerator il, Type type)
internal void EmitFastInt(ILGenerator il, int value)
}
internal HarmonyLib.MethodPatcher : object {
private string INSTANCE_PARAM
private string ORIGINAL_METHOD_PARAM
private string ARGS_ARRAY_VAR
private string RESULT_VAR
private string RESULT_REF_VAR
private string STATE_VAR
private string EXCEPTION_VAR
private string RUN_ORIGINAL_VAR
private string PARAM_INDEX_PREFIX
private string INSTANCE_FIELD_PREFIX
private bool debug
private MethodBase original
private MethodBase source
private List`1<MethodInfo> prefixes
private List`1<MethodInfo> postfixes
private List`1<MethodInfo> transpilers
private List`1<MethodInfo> finalizers
private int idx
private Type returnType
private DynamicMethodDefinition patch
private ILGenerator il
private Emitter emitter
private MethodInfo m_GetMethodFromHandle1
private MethodInfo m_GetMethodFromHandle2
internal void .ctor(MethodBase original, MethodBase source, List`1<MethodInfo> prefixes, List`1<MethodInfo> postfixes, List`1<MethodInfo> transpilers, List`1<MethodInfo> finalizers, bool debug)
internal MethodInfo CreateReplacement(Dictionary`2& finalInstructions)
internal DynamicMethodDefinition CreateDynamicMethod(MethodBase original, string suffix, bool debug)
internal LocalBuilder[] DeclareOriginalLocalVariables(ILGenerator il, MethodBase member)
private LocalBuilder DeclareLocalVariable(Type type, bool isReturnValue)
private OpCode LoadIndOpCodeFor(Type type)
private OpCode StoreIndOpCodeFor(Type type)
private void InitializeOutParameter(int argIndex, Type type)
private bool EmitOriginalBaseMethod()
private void EmitCallParameter(MethodInfo patch, Dictionary`2<string, LocalBuilder> variables, LocalBuilder runOriginalVariable, bool allowFirsParamPassthrough, LocalBuilder& tmpInstanceBoxingVar, LocalBuilder& tmpObjectVar, Boolean& refResultUsed, List`1<KeyValuePair`2<LocalBuilder, Type>> tmpBoxVars)
private bool PrefixAffectsOriginal(MethodInfo fix)
private void AddPrefixes(Dictionary`2<string, LocalBuilder> variables, LocalBuilder runOriginalVariable)
private bool AddPostfixes(Dictionary`2<string, LocalBuilder> variables, LocalBuilder runOriginalVariable, bool passthroughPatches)
private bool AddFinalizers(Dictionary`2<string, LocalBuilder> variables, LocalBuilder runOriginalVariable, bool catchExceptions)
private void PrepareArgumentArray()
private void RestoreArgumentArray(Dictionary`2<string, LocalBuilder> variables)
}
public HarmonyLib.MethodType : Enum {
public int value__
public MethodType Normal
public MethodType Getter
public MethodType Setter
public MethodType Constructor
public MethodType StaticConstructor
public MethodType Enumerator
public MethodType Async
}
public HarmonyLib.Patch : object {
public int index
public string owner
public int priority
public String[] before
public String[] after
public bool debug
private MethodInfo patchMethod
private int methodToken
private string moduleGUID
public MethodInfo PatchMethod
public MethodInfo get_PatchMethod()
public void set_PatchMethod(MethodInfo value)
public void .ctor(MethodInfo patch, int index, string owner, int priority, String[] before, String[] after, bool debug)
public void .ctor(HarmonyMethod method, int index, string owner)
internal void .ctor(int index, string owner, int priority, String[] before, String[] after, bool debug, int methodToken, string moduleGUID)
public MethodInfo GetMethod(MethodBase original)
public bool Equals(object obj)
public int CompareTo(object obj)
public int GetHashCode()
private bool <get_PatchMethod>b__10_2(Module m)
}
internal HarmonyLib.PatchArgumentExtensions : object {
private HarmonyArgument[] AllHarmonyArguments(Object[] attributes)
private HarmonyArgument GetArgumentAttribute(ParameterInfo parameter)
private HarmonyArgument[] GetArgumentAttributes(MethodInfo method)
private HarmonyArgument[] GetArgumentAttributes(Type type)
private string GetOriginalArgumentName(ParameterInfo parameter, String[] originalParameterNames)
private string GetOriginalArgumentName(HarmonyArgument[] attributes, string name, String[] originalParameterNames)
private string GetOriginalArgumentName(MethodInfo method, String[] originalParameterNames, string name)
internal int GetArgumentIndex(MethodInfo patch, String[] originalParameterNames, ParameterInfo patchParam)
}
public HarmonyLib.PatchClassProcessor : object {
private Harmony instance
private Type containerType
private HarmonyMethod containerAttributes
private Dictionary`2<Type, MethodInfo> auxilaryMethods
private List`1<AttributePatch> patchMethods
private List`1<Type> auxilaryTypes
private string <Category>k__BackingField
public string Category
public string get_Category()
public void set_Category(string value)
public void .ctor(Harmony instance, Type type)
public List`1<MethodInfo> Patch()
private void ReversePatch(MethodBase& lastOriginal)
private List`1<MethodInfo> BulkPatch(List`1<MethodBase> originals, MethodBase& lastOriginal)
private List`1<MethodInfo> PatchWithAttributes(MethodBase& lastOriginal)
private void ProcessPatchJob(Job<MethodInfo> job)
private List`1<MethodBase> GetBulkMethods()
private void ReportException(Exception exception, MethodBase original)
private T RunMethod(T defaultIfNotExisting, T defaultIfFailing, Func`2<T, string> failOnResult, Object[] parameters)
private void RunMethod(Exception& exception, Object[] parameters)
}
public HarmonyLib.Patches : object {
public ReadOnlyCollection`1<Patch> Prefixes
public ReadOnlyCollection`1<Patch> Postfixes
public ReadOnlyCollection`1<Patch> Transpilers
public ReadOnlyCollection`1<Patch> Finalizers
public ReadOnlyCollection`1<string> Owners
public ReadOnlyCollection`1<string> get_Owners()
public void .ctor(Patch[] prefixes, Patch[] postfixes, Patch[] transpilers, Patch[] finalizers)
}
internal HarmonyLib.PatchFunctions : object {
internal List`1<MethodInfo> GetSortedPatchMethods(MethodBase original, Patch[] patches, bool debug)
internal MethodInfo UpdateWrapper(MethodBase original, PatchInfo patchInfo)
internal MethodInfo ReversePatch(HarmonyMethod standin, MethodBase original, MethodInfo postTranspiler)
}
public HarmonyLib.PatchInfo : object {
public Patch[] prefixes
public Patch[] postfixes
public Patch[] transpilers
public Patch[] finalizers
public bool Debugging
public bool get_Debugging()
internal void AddPrefixes(string owner, HarmonyMethod[] methods)
public void AddPrefix(MethodInfo patch, string owner, int priority, String[] before, String[] after, bool debug)
public void RemovePrefix(string owner)
internal void AddPostfixes(string owner, HarmonyMethod[] methods)
public void AddPostfix(MethodInfo patch, string owner, int priority, String[] before, String[] after, bool debug)
public void RemovePostfix(string owner)
internal void AddTranspilers(string owner, HarmonyMethod[] methods)
public void AddTranspiler(MethodInfo patch, string owner, int priority, String[] before, String[] after, bool debug)
public void RemoveTranspiler(string owner)
internal void AddFinalizers(string owner, HarmonyMethod[] methods)
public void AddFinalizer(MethodInfo patch, string owner, int priority, String[] before, String[] after, bool debug)
public void RemoveFinalizer(string owner)
public void RemovePatch(MethodInfo patch)
private Patch[] Add(string owner, HarmonyMethod[] add, Patch[] current)
private Patch[] Remove(string owner, Patch[] current)
}
internal HarmonyLib.PatchInfoSerialization : object {
internal BinaryFormatter binaryFormatter
internal Byte[] Serialize(PatchInfo patchInfo)
internal PatchInfo Deserialize(Byte[] bytes)
internal int PriorityComparer(object obj, int index, int priority)
}
internal HarmonyLib.PatchJobs`1 : object {
internal Dictionary`2<MethodBase, Job<T>> state
internal Job<T> GetJob(MethodBase method)
internal List`1<Job<T>> GetJobs()
internal List`1<T> GetReplacements()
}
public HarmonyLib.PatchProcessor : object {
private Harmony instance
private MethodBase original
private HarmonyMethod prefix
private HarmonyMethod postfix
private HarmonyMethod transpiler
private HarmonyMethod finalizer
internal object locker
public void .ctor(Harmony instance, MethodBase original)
public PatchProcessor AddPrefix(HarmonyMethod prefix)
public PatchProcessor AddPrefix(MethodInfo fixMethod)
public PatchProcessor AddPostfix(HarmonyMethod postfix)
public PatchProcessor AddPostfix(MethodInfo fixMethod)
public PatchProcessor AddTranspiler(HarmonyMethod transpiler)
public PatchProcessor AddTranspiler(MethodInfo fixMethod)
public PatchProcessor AddFinalizer(HarmonyMethod finalizer)
public PatchProcessor AddFinalizer(MethodInfo fixMethod)
public IEnumerable`1<MethodBase> GetAllPatchedMethods()
public MethodInfo Patch()
public PatchProcessor Unpatch(HarmonyPatchType type, string harmonyID)
public PatchProcessor Unpatch(MethodInfo patch)
public Patches GetPatchInfo(MethodBase method)
public List`1<MethodInfo> GetSortedPatchMethods(MethodBase original, Patch[] patches)
public Dictionary`2<string, Version> VersionInfo(Version& currentVersion)
public ILGenerator CreateILGenerator()
public ILGenerator CreateILGenerator(MethodBase original)
public List`1<CodeInstruction> GetOriginalInstructions(MethodBase original, ILGenerator generator)
public List`1<CodeInstruction> GetOriginalInstructions(MethodBase original, ILGenerator& generator)
public List`1<CodeInstruction> GetCurrentInstructions(MethodBase original, int maxTranspilers, ILGenerator generator)
public List`1<CodeInstruction> GetCurrentInstructions(MethodBase original, ILGenerator& generator, int maxTranspilers)
public IEnumerable`1<KeyValuePair`2<OpCode, object>> ReadMethodBody(MethodBase method)
public IEnumerable`1<KeyValuePair`2<OpCode, object>> ReadMethodBody(MethodBase method, ILGenerator generator)
}
internal HarmonyLib.PatchSorter : object {
private List`1<PatchSortingWrapper> patches
private HashSet`1<PatchSortingWrapper> handledPatches
private List`1<PatchSortingWrapper> result
private List`1<PatchSortingWrapper> waitingList
internal Patch[] sortedPatchArray
private bool debug
internal void .ctor(Patch[] patches, bool debug)
internal List`1<MethodInfo> Sort(MethodBase original)
internal bool ComparePatchLists(Patch[] patches)
private void CullDependency()
private void ProcessWaitingList()
private void AddNodeToResult(PatchSortingWrapper node)
}
internal HarmonyLib.PatchTools : object {
private Dictionary`2<MethodBase, ICoreDetour> detours
internal string harmonyMethodFullName
internal string harmonyAttributeFullName
internal string harmonyPatchAllFullName
internal MethodInfo m_GetExecutingAssemblyReplacementTranspiler
internal MethodInfo m_GetExecutingAssembly
internal MethodInfo m_GetExecutingAssemblyReplacement
internal void DetourMethod(MethodBase method, MethodBase replacement)
private Assembly GetExecutingAssemblyReplacement()
internal IEnumerable`1<CodeInstruction> GetExecutingAssemblyTranspiler(IEnumerable`1<CodeInstruction> instructions)
public MethodInfo CreateMethod(string name, Type returnType, List`1<KeyValuePair`2<string, Type>> parameters, Action`1<ILGenerator> generator)
internal MethodInfo GetPatchMethod(Type patchType, string attributeName)
internal AssemblyBuilder DefineDynamicAssembly(string name)
internal List`1<AttributePatch> GetPatchMethods(Type type)
internal MethodBase GetOriginalMethod(HarmonyMethod attr)
}
public HarmonyLib.Priority : object {
public int Last
public int VeryLow
public int Low
public int LowerThanNormal
public int Normal
public int HigherThanNormal
public int High
public int VeryHigh
public int First
}
public HarmonyLib.RefResult`1 : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public T& Invoke()
public IAsyncResult BeginInvoke(AsyncCallback callback, object object)
public T& EndInvoke(IAsyncResult result)
}
public HarmonyLib.ReversePatcher : object {
private Harmony instance
private MethodBase original
private HarmonyMethod standin
public void .ctor(Harmony instance, MethodBase original, HarmonyMethod standin)
public MethodInfo Patch(HarmonyReversePatchType type)
internal MethodInfo GetTranspiler(MethodInfo method)
}
public HarmonyLib.SetterHandler`2 : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(T source, S value)
public IAsyncResult BeginInvoke(T source, S value, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public HarmonyLib.SymbolExtensions : object {
public MethodInfo GetMethodInfo(Expression`1<Action> expression)
public MethodInfo GetMethodInfo(Expression`1<Action`1<T>> expression)
public MethodInfo GetMethodInfo(Expression`1<Func`2<T, TResult>> expression)
public MethodInfo GetMethodInfo(LambdaExpression expression)
}
internal HarmonyLib.Tools : object {
internal bool isWindows
internal TypeAndName TypColonName(string typeColonName)
internal void ValidateFieldType(FieldInfo fieldInfo)
internal FieldRef`2<T, F> FieldRefAccess(FieldInfo fieldInfo, bool needCastclass)
internal StructFieldRef`2<T, F> StructFieldRefAccess(FieldInfo fieldInfo)
internal FieldRef`1<F> StaticFieldRefAccess(FieldInfo fieldInfo)
internal FieldInfo GetInstanceField(Type type, string fieldName)
internal bool FieldRefNeedsClasscast(Type delegateInstanceType, Type declaringType)
internal void ValidateStructField(FieldInfo fieldInfo)
}
public HarmonyLib.Transpilers : object {
public IEnumerable`1<CodeInstruction> MethodReplacer(IEnumerable`1<CodeInstruction> instructions, MethodBase from, MethodBase to)
public IEnumerable`1<CodeInstruction> Manipulator(IEnumerable`1<CodeInstruction> instructions, Func`2<CodeInstruction, bool> predicate, Action`1<CodeInstruction> action)
public IEnumerable`1<CodeInstruction> DebugLogger(IEnumerable`1<CodeInstruction> instructions, string text)
}
public HarmonyLib.Traverse : object {
private AccessCache Cache
private Type _type
private object _root
private MemberInfo _info
private MethodBase _method
private Object[] _params
public Action`2<Traverse, Traverse> CopyFields
public Traverse Create(Type type)
public Traverse Create()
public Traverse Create(object root)
public Traverse CreateWithType(string name)
public void .ctor(Type type)
public void .ctor(object root)
private void .ctor(object root, MemberInfo info, Object[] index)
private void .ctor(object root, MethodInfo method, Object[] parameter)
public object GetValue()
public T GetValue()
public object GetValue(Object[] arguments)
public T GetValue(Object[] arguments)
public Traverse SetValue(object value)
public Type GetValueType()
private Traverse Resolve()
public Traverse Type(string name)
public Traverse Field(string name)
public Traverse`1<T> Field(string name)
public List`1<string> Fields()
public Traverse Property(string name, Object[] index)
public Traverse`1<T> Property(string name, Object[] index)
public List`1<string> Properties()
public Traverse Method(string name, Object[] arguments)
public Traverse Method(string name, Type[] paramTypes, Object[] arguments)
public List`1<string> Methods()
public bool FieldExists()
public bool PropertyExists()
public bool MethodExists()
public bool TypeExists()
public void IterateFields(object source, Action`1<Traverse> action)
public void IterateFields(object source, object target, Action`2<Traverse, Traverse> action)
public void IterateFields(object source, object target, Action`3<string, Traverse, Traverse> action)
public void IterateProperties(object source, Action`1<Traverse> action)
public void IterateProperties(object source, object target, Action`2<Traverse, Traverse> action)
public void IterateProperties(object source, object target, Action`3<string, Traverse, Traverse> action)
public string ToString()
}
public HarmonyLib.Traverse`1 : object {
private Traverse traverse
public T Value
public void .ctor(Traverse traverse)
public T get_Value()
public void set_Value(T value)
}
internal Iced.Intel.BlockEncoder : object {
private int bitness
private BlockEncoderOptions options
private Block[] blocks
private Encoder nullEncoder
private Dictionary`2<ulong, Instr> toInstr
internal int Bitness
internal bool FixBranches
private bool ReturnRelocInfos
private bool ReturnNewInstructionOffsets
private bool ReturnConstantOffsets
internal int get_Bitness()
internal bool get_FixBranches()
private bool get_ReturnRelocInfos()
private bool get_ReturnNewInstructionOffsets()
private bool get_ReturnConstantOffsets()
private void .ctor(int bitness, InstructionBlock[] instrBlocks, BlockEncoderOptions options)
public bool TryEncode(int bitness, InstructionBlock block, String& errorMessage, BlockEncoderResult& result, BlockEncoderOptions options)
public bool TryEncode(int bitness, InstructionBlock[] blocks, String& errorMessage, BlockEncoderResult[]& result, BlockEncoderOptions options)
private bool Encode(String& errorMessage, BlockEncoderResult[]& result)
internal TargetInstr GetTarget(ulong address)
internal UInt32 GetInstructionSize(Instruction& instruction, ulong ip)
}
internal Iced.Intel.BlockEncoderInternal.Block : object {
public CodeWriterImpl CodeWriter
public ulong RIP
public List`1<RelocInfo> relocInfos
private Instr[] instructions
private List`1<BlockData> dataList
private ulong alignment
private List`1<BlockData> validData
private ulong validDataAddress
private ulong validDataAddressAligned
public Instr[] Instructions
public bool CanAddRelocInfos
public Instr[] get_Instructions()
public void .ctor(BlockEncoder blockEncoder, CodeWriter codeWriter, ulong rip, List`1<RelocInfo> relocInfos)
internal void SetInstructions(Instr[] instructions)
public BlockData AllocPointerLocation()
public void InitializeData()
public void WriteData()
public bool get_CanAddRelocInfos()
public void AddRelocInfo(RelocInfo relocInfo)
}
internal Iced.Intel.BlockEncoderInternal.BlockData : object {
internal ulong __dont_use_address
internal bool __dont_use_address_initd
public bool IsValid
public ulong Data
public ulong Address
public ulong get_Address()
}
internal Iced.Intel.BlockEncoderInternal.CallInstr : Instr {
private byte bitness
private Instruction instruction
private TargetInstr targetInstr
private byte origInstructionSize
private BlockData pointerData
private bool useOrigInstruction
public void .ctor(BlockEncoder blockEncoder, Block block, Instruction& instruction)
public void Initialize(BlockEncoder blockEncoder)
public bool Optimize(ulong gained)
private bool TryOptimize(ulong gained)
public string TryEncode(Encoder encoder, ConstantOffsets& constantOffsets, Boolean& isOriginalInstruction)
}
internal Iced.Intel.BlockEncoderInternal.CodeWriterImpl : CodeWriter {
public UInt32 BytesWritten
private CodeWriter codeWriter
public void .ctor(CodeWriter codeWriter)
public void WriteByte(byte value)
}
internal Iced.Intel.BlockEncoderInternal.Instr : object {
public Block Block
public UInt32 Size
public ulong IP
public ulong OrigIP
public bool Done
protected UInt32 CallOrJmpPointerDataInstructionSize64
protected void .ctor(Block block, ulong origIp)
public void Initialize(BlockEncoder blockEncoder)
public bool Optimize(ulong gained)
public string TryEncode(Encoder encoder, ConstantOffsets& constantOffsets, Boolean& isOriginalInstruction)
protected string CreateErrorMessage(string errorMessage, Instruction& instruction)
public Instr Create(BlockEncoder blockEncoder, Block block, Instruction& instruction)
protected string EncodeBranchToPointerData(Encoder encoder, bool isCall, ulong ip, BlockData pointerData, UInt32& size, UInt32 minSize)
protected long CorrectDiff(bool inBlock, long diff, ulong gained)
}
internal Iced.Intel.BlockEncoderInternal.IpRelMemOpInstr : Instr {
private Instruction instruction
private InstrKind instrKind
private byte eipInstructionSize
private byte ripInstructionSize
private TargetInstr targetInstr
public void .ctor(BlockEncoder blockEncoder, Block block, Instruction& instruction)
public void Initialize(BlockEncoder blockEncoder)
public bool Optimize(ulong gained)
private bool TryOptimize(ulong gained)
public string TryEncode(Encoder encoder, ConstantOffsets& constantOffsets, Boolean& isOriginalInstruction)
}
internal Iced.Intel.BlockEncoderInternal.JccInstr : Instr {
private Instruction instruction
private TargetInstr targetInstr
private BlockData pointerData
private InstrKind instrKind
private byte shortInstructionSize
private byte nearInstructionSize
private byte longInstructionSize64
private UInt32 GetLongInstructionSize64(Instruction& instruction)
public void .ctor(BlockEncoder blockEncoder, Block block, Instruction& instruction)
public void Initialize(BlockEncoder blockEncoder)
public bool Optimize(ulong gained)
private bool TryOptimize(ulong gained)
public string TryEncode(Encoder encoder, ConstantOffsets& constantOffsets, Boolean& isOriginalInstruction)
private Code ShortBrToNativeBr(Code code, int bitness)
}
internal Iced.Intel.BlockEncoderInternal.JmpInstr : Instr {
private Instruction instruction
private TargetInstr targetInstr
private BlockData pointerData
private InstrKind instrKind
private byte shortInstructionSize
private byte nearInstructionSize
public void .ctor(BlockEncoder blockEncoder, Block block, Instruction& instruction)
public void Initialize(BlockEncoder blockEncoder)
public bool Optimize(ulong gained)
private bool TryOptimize(ulong gained)
public string TryEncode(Encoder encoder, ConstantOffsets& constantOffsets, Boolean& isOriginalInstruction)
}
internal Iced.Intel.BlockEncoderInternal.SimpleBranchInstr : Instr {
private Instruction instruction
private TargetInstr targetInstr
private BlockData pointerData
private InstrKind instrKind
private byte shortInstructionSize
private byte nearInstructionSize
private byte longInstructionSize
private byte nativeInstructionSize
private Code nativeCode
public void .ctor(BlockEncoder blockEncoder, Block block, Instruction& instruction)
private Code ToNativeBranchCode(Code code, int bitness)
public void Initialize(BlockEncoder blockEncoder)
public bool Optimize(ulong gained)
private bool TryOptimize(ulong gained)
public string TryEncode(Encoder encoder, ConstantOffsets& constantOffsets, Boolean& isOriginalInstruction)
}
internal Iced.Intel.BlockEncoderInternal.SimpleInstr : Instr {
private Instruction instruction
public void .ctor(BlockEncoder blockEncoder, Block block, Instruction& instruction)
public void Initialize(BlockEncoder blockEncoder)
public bool Optimize(ulong gained)
public string TryEncode(Encoder encoder, ConstantOffsets& constantOffsets, Boolean& isOriginalInstruction)
}
internal Iced.Intel.BlockEncoderInternal.TargetInstr : ValueType {
private Instr instruction
private ulong address
public void .ctor(Instr instruction)
public void .ctor(ulong address)
public bool IsInBlock(Block block)
public ulong GetAddress()
}
internal Iced.Intel.BlockEncoderInternal.XbeginInstr : Instr {
private Instruction instruction
private TargetInstr targetInstr
private InstrKind instrKind
private byte shortInstructionSize
private byte nearInstructionSize
public void .ctor(BlockEncoder blockEncoder, Block block, Instruction& instruction)
public void Initialize(BlockEncoder blockEncoder)
public bool Optimize(ulong gained)
private bool TryOptimize(ulong gained)
public string TryEncode(Encoder encoder, ConstantOffsets& constantOffsets, Boolean& isOriginalInstruction)
}
internal Iced.Intel.BlockEncoderOptions : Enum {
public int value__
public BlockEncoderOptions None
public BlockEncoderOptions DontFixBranches
public BlockEncoderOptions ReturnRelocInfos
public BlockEncoderOptions ReturnNewInstructionOffsets
public BlockEncoderOptions ReturnConstantOffsets
}
internal Iced.Intel.BlockEncoderResult : ValueType {
public ulong RIP
public List`1<RelocInfo> RelocInfos
public UInt32[] NewInstructionOffsets
public ConstantOffsets[] ConstantOffsets
internal void .ctor(ulong rip, List`1<RelocInfo> relocInfos, UInt32[] newInstructionOffsets, ConstantOffsets[] constantOffsets)
}
internal Iced.Intel.ByteArrayCodeReader : CodeReader {
private Byte[] data
private int currentPosition
private int startPosition
private int endPosition
public int Position
public int Count
public bool CanReadByte
public int get_Position()
public void set_Position(int value)
public int get_Count()
public bool get_CanReadByte()
public void .ctor(string hexData)
public void .ctor(Byte[] data)
public void .ctor(Byte[] data, int index, int count)
public void .ctor(ArraySegment`1<byte> data)
public int ReadByte()
}
internal Iced.Intel.Code : Enum {
public int value__
public Code INVALID
public Code DeclareByte
public Code DeclareWord
public Code DeclareDword
public Code DeclareQword
public Code Add_rm8_r8
public Code Add_rm16_r16
public Code Add_rm32_r32
public Code Add_rm64_r64
public Code Add_r8_rm8
public Code Add_r16_rm16
public Code Add_r32_rm32
public Code Add_r64_rm64
public Code Add_AL_imm8
public Code Add_AX_imm16
public Code Add_EAX_imm32
public Code Add_RAX_imm32
public Code Pushw_ES
public Code Pushd_ES
public Code Popw_ES
public Code Popd_ES
public Code Or_rm8_r8
public Code Or_rm16_r16
public Code Or_rm32_r32
public Code Or_rm64_r64
public Code Or_r8_rm8
public Code Or_r16_rm16
public Code Or_r32_rm32
public Code Or_r64_rm64
public Code Or_AL_imm8
public Code Or_AX_imm16
public Code Or_EAX_imm32
public Code Or_RAX_imm32
public Code Pushw_CS
public Code Pushd_CS
public Code Popw_CS
public Code Adc_rm8_r8
public Code Adc_rm16_r16
public Code Adc_rm32_r32
public Code Adc_rm64_r64
public Code Adc_r8_rm8
public Code Adc_r16_rm16
public Code Adc_r32_rm32
public Code Adc_r64_rm64
public Code Adc_AL_imm8
public Code Adc_AX_imm16
public Code Adc_EAX_imm32
public Code Adc_RAX_imm32
public Code Pushw_SS
public Code Pushd_SS
public Code Popw_SS
public Code Popd_SS
public Code Sbb_rm8_r8
public Code Sbb_rm16_r16
public Code Sbb_rm32_r32
public Code Sbb_rm64_r64
public Code Sbb_r8_rm8
public Code Sbb_r16_rm16
public Code Sbb_r32_rm32
public Code Sbb_r64_rm64
public Code Sbb_AL_imm8
public Code Sbb_AX_imm16
public Code Sbb_EAX_imm32
public Code Sbb_RAX_imm32
public Code Pushw_DS
public Code Pushd_DS
public Code Popw_DS
public Code Popd_DS
public Code And_rm8_r8
public Code And_rm16_r16
public Code And_rm32_r32
public Code And_rm64_r64
public Code And_r8_rm8
public Code And_r16_rm16
public Code And_r32_rm32
public Code And_r64_rm64
public Code And_AL_imm8
public Code And_AX_imm16
public Code And_EAX_imm32
public Code And_RAX_imm32
public Code Daa
public Code Sub_rm8_r8
public Code Sub_rm16_r16
public Code Sub_rm32_r32
public Code Sub_rm64_r64
public Code Sub_r8_rm8
public Code Sub_r16_rm16
public Code Sub_r32_rm32
public Code Sub_r64_rm64
public Code Sub_AL_imm8
public Code Sub_AX_imm16
public Code Sub_EAX_imm32
public Code Sub_RAX_imm32
public Code Das
public Code Xor_rm8_r8
public Code Xor_rm16_r16
public Code Xor_rm32_r32
public Code Xor_rm64_r64
public Code Xor_r8_rm8
public Code Xor_r16_rm16
public Code Xor_r32_rm32
public Code Xor_r64_rm64
public Code Xor_AL_imm8
public Code Xor_AX_imm16
public Code Xor_EAX_imm32
public Code Xor_RAX_imm32
public Code Aaa
public Code Cmp_rm8_r8
public Code Cmp_rm16_r16
public Code Cmp_rm32_r32
public Code Cmp_rm64_r64
public Code Cmp_r8_rm8
public Code Cmp_r16_rm16
public Code Cmp_r32_rm32
public Code Cmp_r64_rm64
public Code Cmp_AL_imm8
public Code Cmp_AX_imm16
public Code Cmp_EAX_imm32
public Code Cmp_RAX_imm32
public Code Aas
public Code Inc_r16
public Code Inc_r32
public Code Dec_r16
public Code Dec_r32
public Code Push_r16
public Code Push_r32
public Code Push_r64
public Code Pop_r16
public Code Pop_r32
public Code Pop_r64
public Code Pushaw
public Code Pushad
public Code Popaw
public Code Popad
public Code Bound_r16_m1616
public Code Bound_r32_m3232
public Code Arpl_rm16_r16
public Code Arpl_r32m16_r32
public Code Movsxd_r16_rm16
public Code Movsxd_r32_rm32
public Code Movsxd_r64_rm32
public Code Push_imm16
public Code Pushd_imm32
public Code Pushq_imm32
public Code Imul_r16_rm16_imm16
public Code Imul_r32_rm32_imm32
public Code Imul_r64_rm64_imm32
public Code Pushw_imm8
public Code Pushd_imm8
public Code Pushq_imm8
public Code Imul_r16_rm16_imm8
public Code Imul_r32_rm32_imm8
public Code Imul_r64_rm64_imm8
public Code Insb_m8_DX
public Code Insw_m16_DX
public Code Insd_m32_DX
public Code Outsb_DX_m8
public Code Outsw_DX_m16
public Code Outsd_DX_m32
public Code Jo_rel8_16
public Code Jo_rel8_32
public Code Jo_rel8_64
public Code Jno_rel8_16
public Code Jno_rel8_32
public Code Jno_rel8_64
public Code Jb_rel8_16
public Code Jb_rel8_32
public Code Jb_rel8_64
public Code Jae_rel8_16
public Code Jae_rel8_32
public Code Jae_rel8_64
public Code Je_rel8_16
public Code Je_rel8_32
public Code Je_rel8_64
public Code Jne_rel8_16
public Code Jne_rel8_32
public Code Jne_rel8_64
public Code Jbe_rel8_16
public Code Jbe_rel8_32
public Code Jbe_rel8_64
public Code Ja_rel8_16
public Code Ja_rel8_32
public Code Ja_rel8_64
public Code Js_rel8_16
public Code Js_rel8_32
public Code Js_rel8_64
public Code Jns_rel8_16
public Code Jns_rel8_32
public Code Jns_rel8_64
public Code Jp_rel8_16
public Code Jp_rel8_32
public Code Jp_rel8_64
public Code Jnp_rel8_16
public Code Jnp_rel8_32
public Code Jnp_rel8_64
public Code Jl_rel8_16
public Code Jl_rel8_32
public Code Jl_rel8_64
public Code Jge_rel8_16
public Code Jge_rel8_32
public Code Jge_rel8_64
public Code Jle_rel8_16
public Code Jle_rel8_32
public Code Jle_rel8_64
public Code Jg_rel8_16
public Code Jg_rel8_32
public Code Jg_rel8_64
public Code Add_rm8_imm8
public Code Or_rm8_imm8
public Code Adc_rm8_imm8
public Code Sbb_rm8_imm8
public Code And_rm8_imm8
public Code Sub_rm8_imm8
public Code Xor_rm8_imm8
public Code Cmp_rm8_imm8
public Code Add_rm16_imm16
public Code Add_rm32_imm32
public Code Add_rm64_imm32
public Code Or_rm16_imm16
public Code Or_rm32_imm32
public Code Or_rm64_imm32
public Code Adc_rm16_imm16
public Code Adc_rm32_imm32
public Code Adc_rm64_imm32
public Code Sbb_rm16_imm16
public Code Sbb_rm32_imm32
public Code Sbb_rm64_imm32
public Code And_rm16_imm16
public Code And_rm32_imm32
public Code And_rm64_imm32
public Code Sub_rm16_imm16
public Code Sub_rm32_imm32
public Code Sub_rm64_imm32
public Code Xor_rm16_imm16
public Code Xor_rm32_imm32
public Code Xor_rm64_imm32
public Code Cmp_rm16_imm16
public Code Cmp_rm32_imm32
public Code Cmp_rm64_imm32
public Code Add_rm8_imm8_82
public Code Or_rm8_imm8_82
public Code Adc_rm8_imm8_82
public Code Sbb_rm8_imm8_82
public Code And_rm8_imm8_82
public Code Sub_rm8_imm8_82
public Code Xor_rm8_imm8_82
public Code Cmp_rm8_imm8_82
public Code Add_rm16_imm8
public Code Add_rm32_imm8
public Code Add_rm64_imm8
public Code Or_rm16_imm8
public Code Or_rm32_imm8
public Code Or_rm64_imm8
public Code Adc_rm16_imm8
public Code Adc_rm32_imm8
public Code Adc_rm64_imm8
public Code Sbb_rm16_imm8
public Code Sbb_rm32_imm8
public Code Sbb_rm64_imm8
public Code And_rm16_imm8
public Code And_rm32_imm8
public Code And_rm64_imm8
public Code Sub_rm16_imm8
public Code Sub_rm32_imm8
public Code Sub_rm64_imm8
public Code Xor_rm16_imm8
public Code Xor_rm32_imm8
public Code Xor_rm64_imm8
public Code Cmp_rm16_imm8
public Code Cmp_rm32_imm8
public Code Cmp_rm64_imm8
public Code Test_rm8_r8
public Code Test_rm16_r16
public Code Test_rm32_r32
public Code Test_rm64_r64
public Code Xchg_rm8_r8
public Code Xchg_rm16_r16
public Code Xchg_rm32_r32
public Code Xchg_rm64_r64
public Code Mov_rm8_r8
public Code Mov_rm16_r16
public Code Mov_rm32_r32
public Code Mov_rm64_r64
public Code Mov_r8_rm8
public Code Mov_r16_rm16
public Code Mov_r32_rm32
public Code Mov_r64_rm64
public Code Mov_rm16_Sreg
public Code Mov_r32m16_Sreg
public Code Mov_r64m16_Sreg
public Code Lea_r16_m
public Code Lea_r32_m
public Code Lea_r64_m
public Code Mov_Sreg_rm16
public Code Mov_Sreg_r32m16
public Code Mov_Sreg_r64m16
public Code Pop_rm16
public Code Pop_rm32
public Code Pop_rm64
public Code Nopw
public Code Nopd
public Code Nopq
public Code Xchg_r16_AX
public Code Xchg_r32_EAX
public Code Xchg_r64_RAX
public Code Pause
public Code Cbw
public Code Cwde
public Code Cdqe
public Code Cwd
public Code Cdq
public Code Cqo
public Code Call_ptr1616
public Code Call_ptr1632
public Code Wait
public Code Pushfw
public Code Pushfd
public Code Pushfq
public Code Popfw
public Code Popfd
public Code Popfq
public Code Sahf
public Code Lahf
public Code Mov_AL_moffs8
public Code Mov_AX_moffs16
public Code Mov_EAX_moffs32
public Code Mov_RAX_moffs64
public Code Mov_moffs8_AL
public Code Mov_moffs16_AX
public Code Mov_moffs32_EAX
public Code Mov_moffs64_RAX
public Code Movsb_m8_m8
public Code Movsw_m16_m16
public Code Movsd_m32_m32
public Code Movsq_m64_m64
public Code Cmpsb_m8_m8
public Code Cmpsw_m16_m16
public Code Cmpsd_m32_m32
public Code Cmpsq_m64_m64
public Code Test_AL_imm8
public Code Test_AX_imm16
public Code Test_EAX_imm32
public Code Test_RAX_imm32
public Code Stosb_m8_AL
public Code Stosw_m16_AX
public Code Stosd_m32_EAX
public Code Stosq_m64_RAX
public Code Lodsb_AL_m8
public Code Lodsw_AX_m16
public Code Lodsd_EAX_m32
public Code Lodsq_RAX_m64
public Code Scasb_AL_m8
public Code Scasw_AX_m16
public Code Scasd_EAX_m32
public Code Scasq_RAX_m64
public Code Mov_r8_imm8
public Code Mov_r16_imm16
public Code Mov_r32_imm32
public Code Mov_r64_imm64
public Code Rol_rm8_imm8
public Code Ror_rm8_imm8
public Code Rcl_rm8_imm8
public Code Rcr_rm8_imm8
public Code Shl_rm8_imm8
public Code Shr_rm8_imm8
public Code Sal_rm8_imm8
public Code Sar_rm8_imm8
public Code Rol_rm16_imm8
public Code Rol_rm32_imm8
public Code Rol_rm64_imm8
public Code Ror_rm16_imm8
public Code Ror_rm32_imm8
public Code Ror_rm64_imm8
public Code Rcl_rm16_imm8
public Code Rcl_rm32_imm8
public Code Rcl_rm64_imm8
public Code Rcr_rm16_imm8
public Code Rcr_rm32_imm8
public Code Rcr_rm64_imm8
public Code Shl_rm16_imm8
public Code Shl_rm32_imm8
public Code Shl_rm64_imm8
public Code Shr_rm16_imm8
public Code Shr_rm32_imm8
public Code Shr_rm64_imm8
public Code Sal_rm16_imm8
public Code Sal_rm32_imm8
public Code Sal_rm64_imm8
public Code Sar_rm16_imm8
public Code Sar_rm32_imm8
public Code Sar_rm64_imm8
public Code Retnw_imm16
public Code Retnd_imm16
public Code Retnq_imm16
public Code Retnw
public Code Retnd
public Code Retnq
public Code Les_r16_m1616
public Code Les_r32_m1632
public Code Lds_r16_m1616
public Code Lds_r32_m1632
public Code Mov_rm8_imm8
public Code Xabort_imm8
public Code Mov_rm16_imm16
public Code Mov_rm32_imm32
public Code Mov_rm64_imm32
public Code Xbegin_rel16
public Code Xbegin_rel32
public Code Enterw_imm16_imm8
public Code Enterd_imm16_imm8
public Code Enterq_imm16_imm8
public Code Leavew
public Code Leaved
public Code Leaveq
public Code Retfw_imm16
public Code Retfd_imm16
public Code Retfq_imm16
public Code Retfw
public Code Retfd
public Code Retfq
public Code Int3
public Code Int_imm8
public Code Into
public Code Iretw
public Code Iretd
public Code Iretq
public Code Rol_rm8_1
public Code Ror_rm8_1
public Code Rcl_rm8_1
public Code Rcr_rm8_1
public Code Shl_rm8_1
public Code Shr_rm8_1
public Code Sal_rm8_1
public Code Sar_rm8_1
public Code Rol_rm16_1
public Code Rol_rm32_1
public Code Rol_rm64_1
public Code Ror_rm16_1
public Code Ror_rm32_1
public Code Ror_rm64_1
public Code Rcl_rm16_1
public Code Rcl_rm32_1
public Code Rcl_rm64_1
public Code Rcr_rm16_1
public Code Rcr_rm32_1
public Code Rcr_rm64_1
public Code Shl_rm16_1
public Code Shl_rm32_1
public Code Shl_rm64_1
public Code Shr_rm16_1
public Code Shr_rm32_1
public Code Shr_rm64_1
public Code Sal_rm16_1
public Code Sal_rm32_1
public Code Sal_rm64_1
public Code Sar_rm16_1
public Code Sar_rm32_1
public Code Sar_rm64_1
public Code Rol_rm8_CL
public Code Ror_rm8_CL
public Code Rcl_rm8_CL
public Code Rcr_rm8_CL
public Code Shl_rm8_CL
public Code Shr_rm8_CL
public Code Sal_rm8_CL
public Code Sar_rm8_CL
public Code Rol_rm16_CL
public Code Rol_rm32_CL
public Code Rol_rm64_CL
public Code Ror_rm16_CL
public Code Ror_rm32_CL
public Code Ror_rm64_CL
public Code Rcl_rm16_CL
public Code Rcl_rm32_CL
public Code Rcl_rm64_CL
public Code Rcr_rm16_CL
public Code Rcr_rm32_CL
public Code Rcr_rm64_CL
public Code Shl_rm16_CL
public Code Shl_rm32_CL
public Code Shl_rm64_CL
public Code Shr_rm16_CL
public Code Shr_rm32_CL
public Code Shr_rm64_CL
public Code Sal_rm16_CL
public Code Sal_rm32_CL
public Code Sal_rm64_CL
public Code Sar_rm16_CL
public Code Sar_rm32_CL
public Code Sar_rm64_CL
public Code Aam_imm8
public Code Aad_imm8
public Code Salc
public Code Xlat_m8
public Code Fadd_m32fp
public Code Fmul_m32fp
public Code Fcom_m32fp
public Code Fcomp_m32fp
public Code Fsub_m32fp
public Code Fsubr_m32fp
public Code Fdiv_m32fp
public Code Fdivr_m32fp
public Code Fadd_st0_sti
public Code Fmul_st0_sti
public Code Fcom_st0_sti
public Code Fcomp_st0_sti
public Code Fsub_st0_sti
public Code Fsubr_st0_sti
public Code Fdiv_st0_sti
public Code Fdivr_st0_sti
public Code Fld_m32fp
public Code Fst_m32fp
public Code Fstp_m32fp
public Code Fldenv_m14byte
public Code Fldenv_m28byte
public Code Fldcw_m2byte
public Code Fnstenv_m14byte
public Code Fstenv_m14byte
public Code Fnstenv_m28byte
public Code Fstenv_m28byte
public Code Fnstcw_m2byte
public Code Fstcw_m2byte
public Code Fld_sti
public Code Fxch_st0_sti
public Code Fnop
public Code Fstpnce_sti
public Code Fchs
public Code Fabs
public Code Ftst
public Code Fxam
public Code Fld1
public Code Fldl2t
public Code Fldl2e
public Code Fldpi
public Code Fldlg2
public Code Fldln2
public Code Fldz
public Code F2xm1
public Code Fyl2x
public Code Fptan
public Code Fpatan
public Code Fxtract
public Code Fprem1
public Code Fdecstp
public Code Fincstp
public Code Fprem
public Code Fyl2xp1
public Code Fsqrt
public Code Fsincos
public Code Frndint
public Code Fscale
public Code Fsin
public Code Fcos
public Code Fiadd_m32int
public Code Fimul_m32int
public Code Ficom_m32int
public Code Ficomp_m32int
public Code Fisub_m32int
public Code Fisubr_m32int
public Code Fidiv_m32int
public Code Fidivr_m32int
public Code Fcmovb_st0_sti
public Code Fcmove_st0_sti
public Code Fcmovbe_st0_sti
public Code Fcmovu_st0_sti
public Code Fucompp
public Code Fild_m32int
public Code Fisttp_m32int
public Code Fist_m32int
public Code Fistp_m32int
public Code Fld_m80fp
public Code Fstp_m80fp
public Code Fcmovnb_st0_sti
public Code Fcmovne_st0_sti
public Code Fcmovnbe_st0_sti
public Code Fcmovnu_st0_sti
public Code Fneni
public Code Feni
public Code Fndisi
public Code Fdisi
public Code Fnclex
public Code Fclex
public Code Fninit
public Code Finit
public Code Fnsetpm
public Code Fsetpm
public Code Frstpm
public Code Fucomi_st0_sti
public Code Fcomi_st0_sti
public Code Fadd_m64fp
public Code Fmul_m64fp
public Code Fcom_m64fp
public Code Fcomp_m64fp
public Code Fsub_m64fp
public Code Fsubr_m64fp
public Code Fdiv_m64fp
public Code Fdivr_m64fp
public Code Fadd_sti_st0
public Code Fmul_sti_st0
public Code Fcom_st0_sti_DCD0
public Code Fcomp_st0_sti_DCD8
public Code Fsubr_sti_st0
public Code Fsub_sti_st0
public Code Fdivr_sti_st0
public Code Fdiv_sti_st0
public Code Fld_m64fp
public Code Fisttp_m64int
public Code Fst_m64fp
public Code Fstp_m64fp
public Code Frstor_m94byte
public Code Frstor_m108byte
public Code Fnsave_m94byte
public Code Fsave_m94byte
public Code Fnsave_m108byte
public Code Fsave_m108byte
public Code Fnstsw_m2byte
public Code Fstsw_m2byte
public Code Ffree_sti
public Code Fxch_st0_sti_DDC8
public Code Fst_sti
public Code Fstp_sti
public Code Fucom_st0_sti
public Code Fucomp_st0_sti
public Code Fiadd_m16int
public Code Fimul_m16int
public Code Ficom_m16int
public Code Ficomp_m16int
public Code Fisub_m16int
public Code Fisubr_m16int
public Code Fidiv_m16int
public Code Fidivr_m16int
public Code Faddp_sti_st0
public Code Fmulp_sti_st0
public Code Fcomp_st0_sti_DED0
public Code Fcompp
public Code Fsubrp_sti_st0
public Code Fsubp_sti_st0
public Code Fdivrp_sti_st0
public Code Fdivp_sti_st0
public Code Fild_m16int
public Code Fisttp_m16int
public Code Fist_m16int
public Code Fistp_m16int
public Code Fbld_m80bcd
public Code Fild_m64int
public Code Fbstp_m80bcd
public Code Fistp_m64int
public Code Ffreep_sti
public Code Fxch_st0_sti_DFC8
public Code Fstp_sti_DFD0
public Code Fstp_sti_DFD8
public Code Fnstsw_AX
public Code Fstsw_AX
public Code Fstdw_AX
public Code Fstsg_AX
public Code Fucomip_st0_sti
public Code Fcomip_st0_sti
public Code Loopne_rel8_16_CX
public Code Loopne_rel8_32_CX
public Code Loopne_rel8_16_ECX
public Code Loopne_rel8_32_ECX
public Code Loopne_rel8_64_ECX
public Code Loopne_rel8_16_RCX
public Code Loopne_rel8_64_RCX
public Code Loope_rel8_16_CX
public Code Loope_rel8_32_CX
public Code Loope_rel8_16_ECX
public Code Loope_rel8_32_ECX
public Code Loope_rel8_64_ECX
public Code Loope_rel8_16_RCX
public Code Loope_rel8_64_RCX
public Code Loop_rel8_16_CX
public Code Loop_rel8_32_CX
public Code Loop_rel8_16_ECX
public Code Loop_rel8_32_ECX
public Code Loop_rel8_64_ECX
public Code Loop_rel8_16_RCX
public Code Loop_rel8_64_RCX
public Code Jcxz_rel8_16
public Code Jcxz_rel8_32
public Code Jecxz_rel8_16
public Code Jecxz_rel8_32
public Code Jecxz_rel8_64
public Code Jrcxz_rel8_16
public Code Jrcxz_rel8_64
public Code In_AL_imm8
public Code In_AX_imm8
public Code In_EAX_imm8
public Code Out_imm8_AL
public Code Out_imm8_AX
public Code Out_imm8_EAX
public Code Call_rel16
public Code Call_rel32_32
public Code Call_rel32_64
public Code Jmp_rel16
public Code Jmp_rel32_32
public Code Jmp_rel32_64
public Code Jmp_ptr1616
public Code Jmp_ptr1632
public Code Jmp_rel8_16
public Code Jmp_rel8_32
public Code Jmp_rel8_64
public Code In_AL_DX
public Code In_AX_DX
public Code In_EAX_DX
public Code Out_DX_AL
public Code Out_DX_AX
public Code Out_DX_EAX
public Code Int1
public Code Hlt
public Code Cmc
public Code Test_rm8_imm8
public Code Test_rm8_imm8_F6r1
public Code Not_rm8
public Code Neg_rm8
public Code Mul_rm8
public Code Imul_rm8
public Code Div_rm8
public Code Idiv_rm8
public Code Test_rm16_imm16
public Code Test_rm32_imm32
public Code Test_rm64_imm32
public Code Test_rm16_imm16_F7r1
public Code Test_rm32_imm32_F7r1
public Code Test_rm64_imm32_F7r1
public Code Not_rm16
public Code Not_rm32
public Code Not_rm64
public Code Neg_rm16
public Code Neg_rm32
public Code Neg_rm64
public Code Mul_rm16
public Code Mul_rm32
public Code Mul_rm64
public Code Imul_rm16
public Code Imul_rm32
public Code Imul_rm64
public Code Div_rm16
public Code Div_rm32
public Code Div_rm64
public Code Idiv_rm16
public Code Idiv_rm32
public Code Idiv_rm64
public Code Clc
public Code Stc
public Code Cli
public Code Sti
public Code Cld
public Code Std
public Code Inc_rm8
public Code Dec_rm8
public Code Inc_rm16
public Code Inc_rm32
public Code Inc_rm64
public Code Dec_rm16
public Code Dec_rm32
public Code Dec_rm64
public Code Call_rm16
public Code Call_rm32
public Code Call_rm64
public Code Call_m1616
public Code Call_m1632
public Code Call_m1664
public Code Jmp_rm16
public Code Jmp_rm32
public Code Jmp_rm64
public Code Jmp_m1616
public Code Jmp_m1632
public Code Jmp_m1664
public Code Push_rm16
public Code Push_rm32
public Code Push_rm64
public Code Sldt_rm16
public Code Sldt_r32m16
public Code Sldt_r64m16
public Code Str_rm16
public Code Str_r32m16
public Code Str_r64m16
public Code Lldt_rm16
public Code Lldt_r32m16
public Code Lldt_r64m16
public Code Ltr_rm16
public Code Ltr_r32m16
public Code Ltr_r64m16
public Code Verr_rm16
public Code Verr_r32m16
public Code Verr_r64m16
public Code Verw_rm16
public Code Verw_r32m16
public Code Verw_r64m16
public Code Jmpe_rm16
public Code Jmpe_rm32
public Code Sgdt_m1632_16
public Code Sgdt_m1632
public Code Sgdt_m1664
public Code Sidt_m1632_16
public Code Sidt_m1632
public Code Sidt_m1664
public Code Lgdt_m1632_16
public Code Lgdt_m1632
public Code Lgdt_m1664
public Code Lidt_m1632_16
public Code Lidt_m1632
public Code Lidt_m1664
public Code Smsw_rm16
public Code Smsw_r32m16
public Code Smsw_r64m16
public Code Rstorssp_m64
public Code Lmsw_rm16
public Code Lmsw_r32m16
public Code Lmsw_r64m16
public Code Invlpg_m
public Code Enclv
public Code Vmcall
public Code Vmlaunch
public Code Vmresume
public Code Vmxoff
public Code Pconfig
public Code Monitorw
public Code Monitord
public Code Monitorq
public Code Mwait
public Code Clac
public Code Stac
public Code Encls
public Code Xgetbv
public Code Xsetbv
public Code Vmfunc
public Code Xend
public Code Xtest
public Code Enclu
public Code Vmrunw
public Code Vmrund
public Code Vmrunq
public Code Vmmcall
public Code Vmloadw
public Code Vmloadd
public Code Vmloadq
public Code Vmsavew
public Code Vmsaved
public Code Vmsaveq
public Code Stgi
public Code Clgi
public Code Skinit
public Code Invlpgaw
public Code Invlpgad
public Code Invlpgaq
public Code Setssbsy
public Code Saveprevssp
public Code Rdpkru
public Code Wrpkru
public Code Swapgs
public Code Rdtscp
public Code Monitorxw
public Code Monitorxd
public Code Monitorxq
public Code Mcommit
public Code Mwaitx
public Code Clzerow
public Code Clzerod
public Code Clzeroq
public Code Rdpru
public Code Lar_r16_rm16
public Code Lar_r32_r32m16
public Code Lar_r64_r64m16
public Code Lsl_r16_rm16
public Code Lsl_r32_r32m16
public Code Lsl_r64_r64m16
public Code Storeall
public Code Loadall286
public Code Syscall
public Code Clts
public Code Loadall386
public Code Sysretd
public Code Sysretq
public Code Invd
public Code Wbinvd
public Code Wbnoinvd
public Code Cl1invmb
public Code Ud2
public Code Reservednop_rm16_r16_0F0D
public Code Reservednop_rm32_r32_0F0D
public Code Reservednop_rm64_r64_0F0D
public Code Prefetch_m8
public Code Prefetchw_m8
public Code Prefetchwt1_m8
public Code Femms
public Code Umov_rm8_r8
public Code Umov_rm16_r16
public Code Umov_rm32_r32
public Code Umov_r8_rm8
public Code Umov_r16_rm16
public Code Umov_r32_rm32
public Code Movups_xmm_xmmm128
public Code VEX_Vmovups_xmm_xmmm128
public Code VEX_Vmovups_ymm_ymmm256
public Code EVEX_Vmovups_xmm_k1z_xmmm128
public Code EVEX_Vmovups_ymm_k1z_ymmm256
public Code EVEX_Vmovups_zmm_k1z_zmmm512
public Code Movupd_xmm_xmmm128
public Code VEX_Vmovupd_xmm_xmmm128
public Code VEX_Vmovupd_ymm_ymmm256
public Code EVEX_Vmovupd_xmm_k1z_xmmm128
public Code EVEX_Vmovupd_ymm_k1z_ymmm256
public Code EVEX_Vmovupd_zmm_k1z_zmmm512
public Code Movss_xmm_xmmm32
public Code VEX_Vmovss_xmm_xmm_xmm
public Code VEX_Vmovss_xmm_m32
public Code EVEX_Vmovss_xmm_k1z_xmm_xmm
public Code EVEX_Vmovss_xmm_k1z_m32
public Code Movsd_xmm_xmmm64
public Code VEX_Vmovsd_xmm_xmm_xmm
public Code VEX_Vmovsd_xmm_m64
public Code EVEX_Vmovsd_xmm_k1z_xmm_xmm
public Code EVEX_Vmovsd_xmm_k1z_m64
public Code Movups_xmmm128_xmm
public Code VEX_Vmovups_xmmm128_xmm
public Code VEX_Vmovups_ymmm256_ymm
public Code EVEX_Vmovups_xmmm128_k1z_xmm
public Code EVEX_Vmovups_ymmm256_k1z_ymm
public Code EVEX_Vmovups_zmmm512_k1z_zmm
public Code Movupd_xmmm128_xmm
public Code VEX_Vmovupd_xmmm128_xmm
public Code VEX_Vmovupd_ymmm256_ymm
public Code EVEX_Vmovupd_xmmm128_k1z_xmm
public Code EVEX_Vmovupd_ymmm256_k1z_ymm
public Code EVEX_Vmovupd_zmmm512_k1z_zmm
public Code Movss_xmmm32_xmm
public Code VEX_Vmovss_xmm_xmm_xmm_0F11
public Code VEX_Vmovss_m32_xmm
public Code EVEX_Vmovss_xmm_k1z_xmm_xmm_0F11
public Code EVEX_Vmovss_m32_k1_xmm
public Code Movsd_xmmm64_xmm
public Code VEX_Vmovsd_xmm_xmm_xmm_0F11
public Code VEX_Vmovsd_m64_xmm
public Code EVEX_Vmovsd_xmm_k1z_xmm_xmm_0F11
public Code EVEX_Vmovsd_m64_k1_xmm
public Code Movhlps_xmm_xmm
public Code Movlps_xmm_m64
public Code VEX_Vmovhlps_xmm_xmm_xmm
public Code VEX_Vmovlps_xmm_xmm_m64
public Code EVEX_Vmovhlps_xmm_xmm_xmm
public Code EVEX_Vmovlps_xmm_xmm_m64
public Code Movlpd_xmm_m64
public Code VEX_Vmovlpd_xmm_xmm_m64
public Code EVEX_Vmovlpd_xmm_xmm_m64
public Code Movsldup_xmm_xmmm128
public Code VEX_Vmovsldup_xmm_xmmm128
public Code VEX_Vmovsldup_ymm_ymmm256
public Code EVEX_Vmovsldup_xmm_k1z_xmmm128
public Code EVEX_Vmovsldup_ymm_k1z_ymmm256
public Code EVEX_Vmovsldup_zmm_k1z_zmmm512
public Code Movddup_xmm_xmmm64
public Code VEX_Vmovddup_xmm_xmmm64
public Code VEX_Vmovddup_ymm_ymmm256
public Code EVEX_Vmovddup_xmm_k1z_xmmm64
public Code EVEX_Vmovddup_ymm_k1z_ymmm256
public Code EVEX_Vmovddup_zmm_k1z_zmmm512
public Code Movlps_m64_xmm
public Code VEX_Vmovlps_m64_xmm
public Code EVEX_Vmovlps_m64_xmm
public Code Movlpd_m64_xmm
public Code VEX_Vmovlpd_m64_xmm
public Code EVEX_Vmovlpd_m64_xmm
public Code Unpcklps_xmm_xmmm128
public Code VEX_Vunpcklps_xmm_xmm_xmmm128
public Code VEX_Vunpcklps_ymm_ymm_ymmm256
public Code EVEX_Vunpcklps_xmm_k1z_xmm_xmmm128b32
public Code EVEX_Vunpcklps_ymm_k1z_ymm_ymmm256b32
public Code EVEX_Vunpcklps_zmm_k1z_zmm_zmmm512b32
public Code Unpcklpd_xmm_xmmm128
public Code VEX_Vunpcklpd_xmm_xmm_xmmm128
public Code VEX_Vunpcklpd_ymm_ymm_ymmm256
public Code EVEX_Vunpcklpd_xmm_k1z_xmm_xmmm128b64
public Code EVEX_Vunpcklpd_ymm_k1z_ymm_ymmm256b64
public Code EVEX_Vunpcklpd_zmm_k1z_zmm_zmmm512b64
public Code Unpckhps_xmm_xmmm128
public Code VEX_Vunpckhps_xmm_xmm_xmmm128
public Code VEX_Vunpckhps_ymm_ymm_ymmm256
public Code EVEX_Vunpckhps_xmm_k1z_xmm_xmmm128b32
public Code EVEX_Vunpckhps_ymm_k1z_ymm_ymmm256b32
public Code EVEX_Vunpckhps_zmm_k1z_zmm_zmmm512b32
public Code Unpckhpd_xmm_xmmm128
public Code VEX_Vunpckhpd_xmm_xmm_xmmm128
public Code VEX_Vunpckhpd_ymm_ymm_ymmm256
public Code EVEX_Vunpckhpd_xmm_k1z_xmm_xmmm128b64
public Code EVEX_Vunpckhpd_ymm_k1z_ymm_ymmm256b64
public Code EVEX_Vunpckhpd_zmm_k1z_zmm_zmmm512b64
public Code Movlhps_xmm_xmm
public Code VEX_Vmovlhps_xmm_xmm_xmm
public Code EVEX_Vmovlhps_xmm_xmm_xmm
public Code Movhps_xmm_m64
public Code VEX_Vmovhps_xmm_xmm_m64
public Code EVEX_Vmovhps_xmm_xmm_m64
public Code Movhpd_xmm_m64
public Code VEX_Vmovhpd_xmm_xmm_m64
public Code EVEX_Vmovhpd_xmm_xmm_m64
public Code Movshdup_xmm_xmmm128
public Code VEX_Vmovshdup_xmm_xmmm128
public Code VEX_Vmovshdup_ymm_ymmm256
public Code EVEX_Vmovshdup_xmm_k1z_xmmm128
public Code EVEX_Vmovshdup_ymm_k1z_ymmm256
public Code EVEX_Vmovshdup_zmm_k1z_zmmm512
public Code Movhps_m64_xmm
public Code VEX_Vmovhps_m64_xmm
public Code EVEX_Vmovhps_m64_xmm
public Code Movhpd_m64_xmm
public Code VEX_Vmovhpd_m64_xmm
public Code EVEX_Vmovhpd_m64_xmm
public Code Reservednop_rm16_r16_0F18
public Code Reservednop_rm32_r32_0F18
public Code Reservednop_rm64_r64_0F18
public Code Reservednop_rm16_r16_0F19
public Code Reservednop_rm32_r32_0F19
public Code Reservednop_rm64_r64_0F19
public Code Reservednop_rm16_r16_0F1A
public Code Reservednop_rm32_r32_0F1A
public Code Reservednop_rm64_r64_0F1A
public Code Reservednop_rm16_r16_0F1B
public Code Reservednop_rm32_r32_0F1B
public Code Reservednop_rm64_r64_0F1B
public Code Reservednop_rm16_r16_0F1C
public Code Reservednop_rm32_r32_0F1C
public Code Reservednop_rm64_r64_0F1C
public Code Reservednop_rm16_r16_0F1D
public Code Reservednop_rm32_r32_0F1D
public Code Reservednop_rm64_r64_0F1D
public Code Reservednop_rm16_r16_0F1E
public Code Reservednop_rm32_r32_0F1E
public Code Reservednop_rm64_r64_0F1E
public Code Reservednop_rm16_r16_0F1F
public Code Reservednop_rm32_r32_0F1F
public Code Reservednop_rm64_r64_0F1F
public Code Prefetchnta_m8
public Code Prefetcht0_m8
public Code Prefetcht1_m8
public Code Prefetcht2_m8
public Code Bndldx_bnd_mib
public Code Bndmov_bnd_bndm64
public Code Bndmov_bnd_bndm128
public Code Bndcl_bnd_rm32
public Code Bndcl_bnd_rm64
public Code Bndcu_bnd_rm32
public Code Bndcu_bnd_rm64
public Code Bndstx_mib_bnd
public Code Bndmov_bndm64_bnd
public Code Bndmov_bndm128_bnd
public Code Bndmk_bnd_m32
public Code Bndmk_bnd_m64
public Code Bndcn_bnd_rm32
public Code Bndcn_bnd_rm64
public Code Cldemote_m8
public Code Rdsspd_r32
public Code Rdsspq_r64
public Code Endbr64
public Code Endbr32
public Code Nop_rm16
public Code Nop_rm32
public Code Nop_rm64
public Code Mov_r32_cr
public Code Mov_r64_cr
public Code Mov_r32_dr
public Code Mov_r64_dr
public Code Mov_cr_r32
public Code Mov_cr_r64
public Code Mov_dr_r32
public Code Mov_dr_r64
public Code Mov_r32_tr
public Code Mov_tr_r32
public Code Movaps_xmm_xmmm128
public Code VEX_Vmovaps_xmm_xmmm128
public Code VEX_Vmovaps_ymm_ymmm256
public Code EVEX_Vmovaps_xmm_k1z_xmmm128
public Code EVEX_Vmovaps_ymm_k1z_ymmm256
public Code EVEX_Vmovaps_zmm_k1z_zmmm512
public Code Movapd_xmm_xmmm128
public Code VEX_Vmovapd_xmm_xmmm128
public Code VEX_Vmovapd_ymm_ymmm256
public Code EVEX_Vmovapd_xmm_k1z_xmmm128
public Code EVEX_Vmovapd_ymm_k1z_ymmm256
public Code EVEX_Vmovapd_zmm_k1z_zmmm512
public Code Movaps_xmmm128_xmm
public Code VEX_Vmovaps_xmmm128_xmm
public Code VEX_Vmovaps_ymmm256_ymm
public Code EVEX_Vmovaps_xmmm128_k1z_xmm
public Code EVEX_Vmovaps_ymmm256_k1z_ymm
public Code EVEX_Vmovaps_zmmm512_k1z_zmm
public Code Movapd_xmmm128_xmm
public Code VEX_Vmovapd_xmmm128_xmm
public Code VEX_Vmovapd_ymmm256_ymm
public Code EVEX_Vmovapd_xmmm128_k1z_xmm
public Code EVEX_Vmovapd_ymmm256_k1z_ymm
public Code EVEX_Vmovapd_zmmm512_k1z_zmm
public Code Cvtpi2ps_xmm_mmm64
public Code Cvtpi2pd_xmm_mmm64
public Code Cvtsi2ss_xmm_rm32
public Code Cvtsi2ss_xmm_rm64
public Code VEX_Vcvtsi2ss_xmm_xmm_rm32
public Code VEX_Vcvtsi2ss_xmm_xmm_rm64
public Code EVEX_Vcvtsi2ss_xmm_xmm_rm32_er
public Code EVEX_Vcvtsi2ss_xmm_xmm_rm64_er
public Code Cvtsi2sd_xmm_rm32
public Code Cvtsi2sd_xmm_rm64
public Code VEX_Vcvtsi2sd_xmm_xmm_rm32
public Code VEX_Vcvtsi2sd_xmm_xmm_rm64
public Code EVEX_Vcvtsi2sd_xmm_xmm_rm32_er
public Code EVEX_Vcvtsi2sd_xmm_xmm_rm64_er
public Code Movntps_m128_xmm
public Code VEX_Vmovntps_m128_xmm
public Code VEX_Vmovntps_m256_ymm
public Code EVEX_Vmovntps_m128_xmm
public Code EVEX_Vmovntps_m256_ymm
public Code EVEX_Vmovntps_m512_zmm
public Code Movntpd_m128_xmm
public Code VEX_Vmovntpd_m128_xmm
public Code VEX_Vmovntpd_m256_ymm
public Code EVEX_Vmovntpd_m128_xmm
public Code EVEX_Vmovntpd_m256_ymm
public Code EVEX_Vmovntpd_m512_zmm
public Code Movntss_m32_xmm
public Code Movntsd_m64_xmm
public Code Cvttps2pi_mm_xmmm64
public Code Cvttpd2pi_mm_xmmm128
public Code Cvttss2si_r32_xmmm32
public Code Cvttss2si_r64_xmmm32
public Code VEX_Vcvttss2si_r32_xmmm32
public Code VEX_Vcvttss2si_r64_xmmm32
public Code EVEX_Vcvttss2si_r32_xmmm32_sae
public Code EVEX_Vcvttss2si_r64_xmmm32_sae
public Code Cvttsd2si_r32_xmmm64
public Code Cvttsd2si_r64_xmmm64
public Code VEX_Vcvttsd2si_r32_xmmm64
public Code VEX_Vcvttsd2si_r64_xmmm64
public Code EVEX_Vcvttsd2si_r32_xmmm64_sae
public Code EVEX_Vcvttsd2si_r64_xmmm64_sae
public Code Cvtps2pi_mm_xmmm64
public Code Cvtpd2pi_mm_xmmm128
public Code Cvtss2si_r32_xmmm32
public Code Cvtss2si_r64_xmmm32
public Code VEX_Vcvtss2si_r32_xmmm32
public Code VEX_Vcvtss2si_r64_xmmm32
public Code EVEX_Vcvtss2si_r32_xmmm32_er
public Code EVEX_Vcvtss2si_r64_xmmm32_er
public Code Cvtsd2si_r32_xmmm64
public Code Cvtsd2si_r64_xmmm64
public Code VEX_Vcvtsd2si_r32_xmmm64
public Code VEX_Vcvtsd2si_r64_xmmm64
public Code EVEX_Vcvtsd2si_r32_xmmm64_er
public Code EVEX_Vcvtsd2si_r64_xmmm64_er
public Code Ucomiss_xmm_xmmm32
public Code VEX_Vucomiss_xmm_xmmm32
public Code EVEX_Vucomiss_xmm_xmmm32_sae
public Code Ucomisd_xmm_xmmm64
public Code VEX_Vucomisd_xmm_xmmm64
public Code EVEX_Vucomisd_xmm_xmmm64_sae
public Code Comiss_xmm_xmmm32
public Code Comisd_xmm_xmmm64
public Code VEX_Vcomiss_xmm_xmmm32
public Code VEX_Vcomisd_xmm_xmmm64
public Code EVEX_Vcomiss_xmm_xmmm32_sae
public Code EVEX_Vcomisd_xmm_xmmm64_sae
public Code Wrmsr
public Code Rdtsc
public Code Rdmsr
public Code Rdpmc
public Code Sysenter
public Code Sysexitd
public Code Sysexitq
public Code Getsecd
public Code Cmovo_r16_rm16
public Code Cmovo_r32_rm32
public Code Cmovo_r64_rm64
public Code Cmovno_r16_rm16
public Code Cmovno_r32_rm32
public Code Cmovno_r64_rm64
public Code Cmovb_r16_rm16
public Code Cmovb_r32_rm32
public Code Cmovb_r64_rm64
public Code Cmovae_r16_rm16
public Code Cmovae_r32_rm32
public Code Cmovae_r64_rm64
public Code Cmove_r16_rm16
public Code Cmove_r32_rm32
public Code Cmove_r64_rm64
public Code Cmovne_r16_rm16
public Code Cmovne_r32_rm32
public Code Cmovne_r64_rm64
public Code Cmovbe_r16_rm16
public Code Cmovbe_r32_rm32
public Code Cmovbe_r64_rm64
public Code Cmova_r16_rm16
public Code Cmova_r32_rm32
public Code Cmova_r64_rm64
public Code Cmovs_r16_rm16
public Code Cmovs_r32_rm32
public Code Cmovs_r64_rm64
public Code Cmovns_r16_rm16
public Code Cmovns_r32_rm32
public Code Cmovns_r64_rm64
public Code Cmovp_r16_rm16
public Code Cmovp_r32_rm32
public Code Cmovp_r64_rm64
public Code Cmovnp_r16_rm16
public Code Cmovnp_r32_rm32
public Code Cmovnp_r64_rm64
public Code Cmovl_r16_rm16
public Code Cmovl_r32_rm32
public Code Cmovl_r64_rm64
public Code Cmovge_r16_rm16
public Code Cmovge_r32_rm32
public Code Cmovge_r64_rm64
public Code Cmovle_r16_rm16
public Code Cmovle_r32_rm32
public Code Cmovle_r64_rm64
public Code Cmovg_r16_rm16
public Code Cmovg_r32_rm32
public Code Cmovg_r64_rm64
public Code VEX_Kandw_kr_kr_kr
public Code VEX_Kandq_kr_kr_kr
public Code VEX_Kandb_kr_kr_kr
public Code VEX_Kandd_kr_kr_kr
public Code VEX_Kandnw_kr_kr_kr
public Code VEX_Kandnq_kr_kr_kr
public Code VEX_Kandnb_kr_kr_kr
public Code VEX_Kandnd_kr_kr_kr
public Code VEX_Knotw_kr_kr
public Code VEX_Knotq_kr_kr
public Code VEX_Knotb_kr_kr
public Code VEX_Knotd_kr_kr
public Code VEX_Korw_kr_kr_kr
public Code VEX_Korq_kr_kr_kr
public Code VEX_Korb_kr_kr_kr
public Code VEX_Kord_kr_kr_kr
public Code VEX_Kxnorw_kr_kr_kr
public Code VEX_Kxnorq_kr_kr_kr
public Code VEX_Kxnorb_kr_kr_kr
public Code VEX_Kxnord_kr_kr_kr
public Code VEX_Kxorw_kr_kr_kr
public Code VEX_Kxorq_kr_kr_kr
public Code VEX_Kxorb_kr_kr_kr
public Code VEX_Kxord_kr_kr_kr
public Code VEX_Kaddw_kr_kr_kr
public Code VEX_Kaddq_kr_kr_kr
public Code VEX_Kaddb_kr_kr_kr
public Code VEX_Kaddd_kr_kr_kr
public Code VEX_Kunpckwd_kr_kr_kr
public Code VEX_Kunpckdq_kr_kr_kr
public Code VEX_Kunpckbw_kr_kr_kr
public Code Movmskps_r32_xmm
public Code Movmskps_r64_xmm
public Code VEX_Vmovmskps_r32_xmm
public Code VEX_Vmovmskps_r64_xmm
public Code VEX_Vmovmskps_r32_ymm
public Code VEX_Vmovmskps_r64_ymm
public Code Movmskpd_r32_xmm
public Code Movmskpd_r64_xmm
public Code VEX_Vmovmskpd_r32_xmm
public Code VEX_Vmovmskpd_r64_xmm
public Code VEX_Vmovmskpd_r32_ymm
public Code VEX_Vmovmskpd_r64_ymm
public Code Sqrtps_xmm_xmmm128
public Code VEX_Vsqrtps_xmm_xmmm128
public Code VEX_Vsqrtps_ymm_ymmm256
public Code EVEX_Vsqrtps_xmm_k1z_xmmm128b32
public Code EVEX_Vsqrtps_ymm_k1z_ymmm256b32
public Code EVEX_Vsqrtps_zmm_k1z_zmmm512b32_er
public Code Sqrtpd_xmm_xmmm128
public Code VEX_Vsqrtpd_xmm_xmmm128
public Code VEX_Vsqrtpd_ymm_ymmm256
public Code EVEX_Vsqrtpd_xmm_k1z_xmmm128b64
public Code EVEX_Vsqrtpd_ymm_k1z_ymmm256b64
public Code EVEX_Vsqrtpd_zmm_k1z_zmmm512b64_er
public Code Sqrtss_xmm_xmmm32
public Code VEX_Vsqrtss_xmm_xmm_xmmm32
public Code EVEX_Vsqrtss_xmm_k1z_xmm_xmmm32_er
public Code Sqrtsd_xmm_xmmm64
public Code VEX_Vsqrtsd_xmm_xmm_xmmm64
public Code EVEX_Vsqrtsd_xmm_k1z_xmm_xmmm64_er
public Code Rsqrtps_xmm_xmmm128
public Code VEX_Vrsqrtps_xmm_xmmm128
public Code VEX_Vrsqrtps_ymm_ymmm256
public Code Rsqrtss_xmm_xmmm32
public Code VEX_Vrsqrtss_xmm_xmm_xmmm32
public Code Rcpps_xmm_xmmm128
public Code VEX_Vrcpps_xmm_xmmm128
public Code VEX_Vrcpps_ymm_ymmm256
public Code Rcpss_xmm_xmmm32
public Code VEX_Vrcpss_xmm_xmm_xmmm32
public Code Andps_xmm_xmmm128
public Code VEX_Vandps_xmm_xmm_xmmm128
public Code VEX_Vandps_ymm_ymm_ymmm256
public Code EVEX_Vandps_xmm_k1z_xmm_xmmm128b32
public Code EVEX_Vandps_ymm_k1z_ymm_ymmm256b32
public Code EVEX_Vandps_zmm_k1z_zmm_zmmm512b32
public Code Andpd_xmm_xmmm128
public Code VEX_Vandpd_xmm_xmm_xmmm128
public Code VEX_Vandpd_ymm_ymm_ymmm256
public Code EVEX_Vandpd_xmm_k1z_xmm_xmmm128b64
public Code EVEX_Vandpd_ymm_k1z_ymm_ymmm256b64
public Code EVEX_Vandpd_zmm_k1z_zmm_zmmm512b64
public Code Andnps_xmm_xmmm128
public Code VEX_Vandnps_xmm_xmm_xmmm128
public Code VEX_Vandnps_ymm_ymm_ymmm256
public Code EVEX_Vandnps_xmm_k1z_xmm_xmmm128b32
public Code EVEX_Vandnps_ymm_k1z_ymm_ymmm256b32
public Code EVEX_Vandnps_zmm_k1z_zmm_zmmm512b32
public Code Andnpd_xmm_xmmm128
public Code VEX_Vandnpd_xmm_xmm_xmmm128
public Code VEX_Vandnpd_ymm_ymm_ymmm256
public Code EVEX_Vandnpd_xmm_k1z_xmm_xmmm128b64
public Code EVEX_Vandnpd_ymm_k1z_ymm_ymmm256b64
public Code EVEX_Vandnpd_zmm_k1z_zmm_zmmm512b64
public Code Orps_xmm_xmmm128
public Code VEX_Vorps_xmm_xmm_xmmm128
public Code VEX_Vorps_ymm_ymm_ymmm256
public Code EVEX_Vorps_xmm_k1z_xmm_xmmm128b32
public Code EVEX_Vorps_ymm_k1z_ymm_ymmm256b32
public Code EVEX_Vorps_zmm_k1z_zmm_zmmm512b32
public Code Orpd_xmm_xmmm128
public Code VEX_Vorpd_xmm_xmm_xmmm128
public Code VEX_Vorpd_ymm_ymm_ymmm256
public Code EVEX_Vorpd_xmm_k1z_xmm_xmmm128b64
public Code EVEX_Vorpd_ymm_k1z_ymm_ymmm256b64
public Code EVEX_Vorpd_zmm_k1z_zmm_zmmm512b64
public Code Xorps_xmm_xmmm128
public Code VEX_Vxorps_xmm_xmm_xmmm128
public Code VEX_Vxorps_ymm_ymm_ymmm256
public Code EVEX_Vxorps_xmm_k1z_xmm_xmmm128b32
public Code EVEX_Vxorps_ymm_k1z_ymm_ymmm256b32
public Code EVEX_Vxorps_zmm_k1z_zmm_zmmm512b32
public Code Xorpd_xmm_xmmm128
public Code VEX_Vxorpd_xmm_xmm_xmmm128
public Code VEX_Vxorpd_ymm_ymm_ymmm256
public Code EVEX_Vxorpd_xmm_k1z_xmm_xmmm128b64
public Code EVEX_Vxorpd_ymm_k1z_ymm_ymmm256b64
public Code EVEX_Vxorpd_zmm_k1z_zmm_zmmm512b64
public Code Addps_xmm_xmmm128
public Code VEX_Vaddps_xmm_xmm_xmmm128
public Code VEX_Vaddps_ymm_ymm_ymmm256
public Code EVEX_Vaddps_xmm_k1z_xmm_xmmm128b32
public Code EVEX_Vaddps_ymm_k1z_ymm_ymmm256b32
public Code EVEX_Vaddps_zmm_k1z_zmm_zmmm512b32_er
public Code Addpd_xmm_xmmm128
public Code VEX_Vaddpd_xmm_xmm_xmmm128
public Code VEX_Vaddpd_ymm_ymm_ymmm256
public Code EVEX_Vaddpd_xmm_k1z_xmm_xmmm128b64
public Code EVEX_Vaddpd_ymm_k1z_ymm_ymmm256b64
public Code EVEX_Vaddpd_zmm_k1z_zmm_zmmm512b64_er
public Code Addss_xmm_xmmm32
public Code VEX_Vaddss_xmm_xmm_xmmm32
public Code EVEX_Vaddss_xmm_k1z_xmm_xmmm32_er
public Code Addsd_xmm_xmmm64
public Code VEX_Vaddsd_xmm_xmm_xmmm64
public Code EVEX_Vaddsd_xmm_k1z_xmm_xmmm64_er
public Code Mulps_xmm_xmmm128
public Code VEX_Vmulps_xmm_xmm_xmmm128
public Code VEX_Vmulps_ymm_ymm_ymmm256
public Code EVEX_Vmulps_xmm_k1z_xmm_xmmm128b32
public Code EVEX_Vmulps_ymm_k1z_ymm_ymmm256b32
public Code EVEX_Vmulps_zmm_k1z_zmm_zmmm512b32_er
public Code Mulpd_xmm_xmmm128
public Code VEX_Vmulpd_xmm_xmm_xmmm128
public Code VEX_Vmulpd_ymm_ymm_ymmm256
public Code EVEX_Vmulpd_xmm_k1z_xmm_xmmm128b64
public Code EVEX_Vmulpd_ymm_k1z_ymm_ymmm256b64
public Code EVEX_Vmulpd_zmm_k1z_zmm_zmmm512b64_er
public Code Mulss_xmm_xmmm32
public Code VEX_Vmulss_xmm_xmm_xmmm32
public Code EVEX_Vmulss_xmm_k1z_xmm_xmmm32_er
public Code Mulsd_xmm_xmmm64
public Code VEX_Vmulsd_xmm_xmm_xmmm64
public Code EVEX_Vmulsd_xmm_k1z_xmm_xmmm64_er
public Code Cvtps2pd_xmm_xmmm64
public Code VEX_Vcvtps2pd_xmm_xmmm64
public Code VEX_Vcvtps2pd_ymm_xmmm128
public Code EVEX_Vcvtps2pd_xmm_k1z_xmmm64b32
public Code EVEX_Vcvtps2pd_ymm_k1z_xmmm128b32
public Code EVEX_Vcvtps2pd_zmm_k1z_ymmm256b32_sae
public Code Cvtpd2ps_xmm_xmmm128
public Code VEX_Vcvtpd2ps_xmm_xmmm128
public Code VEX_Vcvtpd2ps_xmm_ymmm256
public Code EVEX_Vcvtpd2ps_xmm_k1z_xmmm128b64
public Code EVEX_Vcvtpd2ps_xmm_k1z_ymmm256b64
public Code EVEX_Vcvtpd2ps_ymm_k1z_zmmm512b64_er
public Code Cvtss2sd_xmm_xmmm32
public Code VEX_Vcvtss2sd_xmm_xmm_xmmm32
public Code EVEX_Vcvtss2sd_xmm_k1z_xmm_xmmm32_sae
public Code Cvtsd2ss_xmm_xmmm64
public Code VEX_Vcvtsd2ss_xmm_xmm_xmmm64
public Code EVEX_Vcvtsd2ss_xmm_k1z_xmm_xmmm64_er
public Code Cvtdq2ps_xmm_xmmm128
public Code VEX_Vcvtdq2ps_xmm_xmmm128
public Code VEX_Vcvtdq2ps_ymm_ymmm256
public Code EVEX_Vcvtdq2ps_xmm_k1z_xmmm128b32
public Code EVEX_Vcvtdq2ps_ymm_k1z_ymmm256b32
public Code EVEX_Vcvtdq2ps_zmm_k1z_zmmm512b32_er
public Code EVEX_Vcvtqq2ps_xmm_k1z_xmmm128b64
public Code EVEX_Vcvtqq2ps_xmm_k1z_ymmm256b64
public Code EVEX_Vcvtqq2ps_ymm_k1z_zmmm512b64_er
public Code Cvtps2dq_xmm_xmmm128
public Code VEX_Vcvtps2dq_xmm_xmmm128
public Code VEX_Vcvtps2dq_ymm_ymmm256
public Code EVEX_Vcvtps2dq_xmm_k1z_xmmm128b32
public Code EVEX_Vcvtps2dq_ymm_k1z_ymmm256b32
public Code EVEX_Vcvtps2dq_zmm_k1z_zmmm512b32_er
public Code Cvttps2dq_xmm_xmmm128
public Code VEX_Vcvttps2dq_xmm_xmmm128
public Code VEX_Vcvttps2dq_ymm_ymmm256
public Code EVEX_Vcvttps2dq_xmm_k1z_xmmm128b32
public Code EVEX_Vcvttps2dq_ymm_k1z_ymmm256b32
public Code EVEX_Vcvttps2dq_zmm_k1z_zmmm512b32_sae
public Code Subps_xmm_xmmm128
public Code VEX_Vsubps_xmm_xmm_xmmm128
public Code VEX_Vsubps_ymm_ymm_ymmm256
public Code EVEX_Vsubps_xmm_k1z_xmm_xmmm128b32
public Code EVEX_Vsubps_ymm_k1z_ymm_ymmm256b32
public Code EVEX_Vsubps_zmm_k1z_zmm_zmmm512b32_er
public Code Subpd_xmm_xmmm128
public Code VEX_Vsubpd_xmm_xmm_xmmm128
public Code VEX_Vsubpd_ymm_ymm_ymmm256
public Code EVEX_Vsubpd_xmm_k1z_xmm_xmmm128b64
public Code EVEX_Vsubpd_ymm_k1z_ymm_ymmm256b64
public Code EVEX_Vsubpd_zmm_k1z_zmm_zmmm512b64_er
public Code Subss_xmm_xmmm32
public Code VEX_Vsubss_xmm_xmm_xmmm32
public Code EVEX_Vsubss_xmm_k1z_xmm_xmmm32_er
public Code Subsd_xmm_xmmm64
public Code VEX_Vsubsd_xmm_xmm_xmmm64
public Code EVEX_Vsubsd_xmm_k1z_xmm_xmmm64_er
public Code Minps_xmm_xmmm128
public Code VEX_Vminps_xmm_xmm_xmmm128
public Code VEX_Vminps_ymm_ymm_ymmm256
public Code EVEX_Vminps_xmm_k1z_xmm_xmmm128b32
public Code EVEX_Vminps_ymm_k1z_ymm_ymmm256b32
public Code EVEX_Vminps_zmm_k1z_zmm_zmmm512b32_sae
public Code Minpd_xmm_xmmm128
public Code VEX_Vminpd_xmm_xmm_xmmm128
public Code VEX_Vminpd_ymm_ymm_ymmm256
public Code EVEX_Vminpd_xmm_k1z_xmm_xmmm128b64
public Code EVEX_Vminpd_ymm_k1z_ymm_ymmm256b64
public Code EVEX_Vminpd_zmm_k1z_zmm_zmmm512b64_sae
public Code Minss_xmm_xmmm32
public Code VEX_Vminss_xmm_xmm_xmmm32
public Code EVEX_Vminss_xmm_k1z_xmm_xmmm32_sae
public Code Minsd_xmm_xmmm64
public Code VEX_Vminsd_xmm_xmm_xmmm64
public Code EVEX_Vminsd_xmm_k1z_xmm_xmmm64_sae
public Code Divps_xmm_xmmm128
public Code VEX_Vdivps_xmm_xmm_xmmm128
public Code VEX_Vdivps_ymm_ymm_ymmm256
public Code EVEX_Vdivps_xmm_k1z_xmm_xmmm128b32
public Code EVEX_Vdivps_ymm_k1z_ymm_ymmm256b32
public Code EVEX_Vdivps_zmm_k1z_zmm_zmmm512b32_er
public Code Divpd_xmm_xmmm128
public Code VEX_Vdivpd_xmm_xmm_xmmm128
public Code VEX_Vdivpd_ymm_ymm_ymmm256
public Code EVEX_Vdivpd_xmm_k1z_xmm_xmmm128b64
public Code EVEX_Vdivpd_ymm_k1z_ymm_ymmm256b64
public Code EVEX_Vdivpd_zmm_k1z_zmm_zmmm512b64_er
public Code Divss_xmm_xmmm32
public Code VEX_Vdivss_xmm_xmm_xmmm32
public Code EVEX_Vdivss_xmm_k1z_xmm_xmmm32_er
public Code Divsd_xmm_xmmm64
public Code VEX_Vdivsd_xmm_xmm_xmmm64
public Code EVEX_Vdivsd_xmm_k1z_xmm_xmmm64_er
public Code Maxps_xmm_xmmm128
public Code VEX_Vmaxps_xmm_xmm_xmmm128
public Code VEX_Vmaxps_ymm_ymm_ymmm256
public Code EVEX_Vmaxps_xmm_k1z_xmm_xmmm128b32
public Code EVEX_Vmaxps_ymm_k1z_ymm_ymmm256b32
public Code EVEX_Vmaxps_zmm_k1z_zmm_zmmm512b32_sae
public Code Maxpd_xmm_xmmm128
public Code VEX_Vmaxpd_xmm_xmm_xmmm128
public Code VEX_Vmaxpd_ymm_ymm_ymmm256
public Code EVEX_Vmaxpd_xmm_k1z_xmm_xmmm128b64
public Code EVEX_Vmaxpd_ymm_k1z_ymm_ymmm256b64
public Code EVEX_Vmaxpd_zmm_k1z_zmm_zmmm512b64_sae
public Code Maxss_xmm_xmmm32
public Code VEX_Vmaxss_xmm_xmm_xmmm32
public Code EVEX_Vmaxss_xmm_k1z_xmm_xmmm32_sae
public Code Maxsd_xmm_xmmm64
public Code VEX_Vmaxsd_xmm_xmm_xmmm64
public Code EVEX_Vmaxsd_xmm_k1z_xmm_xmmm64_sae
public Code Punpcklbw_mm_mmm32
public Code Punpcklbw_xmm_xmmm128
public Code VEX_Vpunpcklbw_xmm_xmm_xmmm128
public Code VEX_Vpunpcklbw_ymm_ymm_ymmm256
public Code EVEX_Vpunpcklbw_xmm_k1z_xmm_xmmm128
public Code EVEX_Vpunpcklbw_ymm_k1z_ymm_ymmm256
public Code EVEX_Vpunpcklbw_zmm_k1z_zmm_zmmm512
public Code Punpcklwd_mm_mmm32
public Code Punpcklwd_xmm_xmmm128
public Code VEX_Vpunpcklwd_xmm_xmm_xmmm128
public Code VEX_Vpunpcklwd_ymm_ymm_ymmm256
public Code EVEX_Vpunpcklwd_xmm_k1z_xmm_xmmm128
public Code EVEX_Vpunpcklwd_ymm_k1z_ymm_ymmm256
public Code EVEX_Vpunpcklwd_zmm_k1z_zmm_zmmm512
public Code Punpckldq_mm_mmm32
public Code Punpckldq_xmm_xmmm128
public Code VEX_Vpunpckldq_xmm_xmm_xmmm128
public Code VEX_Vpunpckldq_ymm_ymm_ymmm256
public Code EVEX_Vpunpckldq_xmm_k1z_xmm_xmmm128b32
public Code EVEX_Vpunpckldq_ymm_k1z_ymm_ymmm256b32
public Code EVEX_Vpunpckldq_zmm_k1z_zmm_zmmm512b32
public Code Packsswb_mm_mmm64
public Code Packsswb_xmm_xmmm128
public Code VEX_Vpacksswb_xmm_xmm_xmmm128
public Code VEX_Vpacksswb_ymm_ymm_ymmm256
public Code EVEX_Vpacksswb_xmm_k1z_xmm_xmmm128
public Code EVEX_Vpacksswb_ymm_k1z_ymm_ymmm256
public Code EVEX_Vpacksswb_zmm_k1z_zmm_zmmm512
public Code Pcmpgtb_mm_mmm64
public Code Pcmpgtb_xmm_xmmm128
public Code VEX_Vpcmpgtb_xmm_xmm_xmmm128
public Code VEX_Vpcmpgtb_ymm_ymm_ymmm256
public Code EVEX_Vpcmpgtb_kr_k1_xmm_xmmm128
public Code EVEX_Vpcmpgtb_kr_k1_ymm_ymmm256
public Code EVEX_Vpcmpgtb_kr_k1_zmm_zmmm512
public Code Pcmpgtw_mm_mmm64
public Code Pcmpgtw_xmm_xmmm128
public Code VEX_Vpcmpgtw_xmm_xmm_xmmm128
public Code VEX_Vpcmpgtw_ymm_ymm_ymmm256
public Code EVEX_Vpcmpgtw_kr_k1_xmm_xmmm128
public Code EVEX_Vpcmpgtw_kr_k1_ymm_ymmm256
public Code EVEX_Vpcmpgtw_kr_k1_zmm_zmmm512
public Code Pcmpgtd_mm_mmm64
public Code Pcmpgtd_xmm_xmmm128
public Code VEX_Vpcmpgtd_xmm_xmm_xmmm128
public Code VEX_Vpcmpgtd_ymm_ymm_ymmm256
public Code EVEX_Vpcmpgtd_kr_k1_xmm_xmmm128b32
public Code EVEX_Vpcmpgtd_kr_k1_ymm_ymmm256b32
public Code EVEX_Vpcmpgtd_kr_k1_zmm_zmmm512b32
public Code Packuswb_mm_mmm64
public Code Packuswb_xmm_xmmm128
public Code VEX_Vpackuswb_xmm_xmm_xmmm128
public Code VEX_Vpackuswb_ymm_ymm_ymmm256
public Code EVEX_Vpackuswb_xmm_k1z_xmm_xmmm128
public Code EVEX_Vpackuswb_ymm_k1z_ymm_ymmm256
public Code EVEX_Vpackuswb_zmm_k1z_zmm_zmmm512
public Code Punpckhbw_mm_mmm64
public Code Punpckhbw_xmm_xmmm128
public Code VEX_Vpunpckhbw_xmm_xmm_xmmm128
public Code VEX_Vpunpckhbw_ymm_ymm_ymmm256
public Code EVEX_Vpunpckhbw_xmm_k1z_xmm_xmmm128
public Code EVEX_Vpunpckhbw_ymm_k1z_ymm_ymmm256
public Code EVEX_Vpunpckhbw_zmm_k1z_zmm_zmmm512
public Code Punpckhwd_mm_mmm64
public Code Punpckhwd_xmm_xmmm128
public Code VEX_Vpunpckhwd_xmm_xmm_xmmm128
public Code VEX_Vpunpckhwd_ymm_ymm_ymmm256
public Code EVEX_Vpunpckhwd_xmm_k1z_xmm_xmmm128
public Code EVEX_Vpunpckhwd_ymm_k1z_ymm_ymmm256
public Code EVEX_Vpunpckhwd_zmm_k1z_zmm_zmmm512
public Code Punpckhdq_mm_mmm64
public Code Punpckhdq_xmm_xmmm128
public Code VEX_Vpunpckhdq_xmm_xmm_xmmm128
public Code VEX_Vpunpckhdq_ymm_ymm_ymmm256
public Code EVEX_Vpunpckhdq_xmm_k1z_xmm_xmmm128b32
public Code EVEX_Vpunpckhdq_ymm_k1z_ymm_ymmm256b32
public Code EVEX_Vpunpckhdq_zmm_k1z_zmm_zmmm512b32
public Code Packssdw_mm_mmm64
public Code Packssdw_xmm_xmmm128
public Code VEX_Vpackssdw_xmm_xmm_xmmm128
public Code VEX_Vpackssdw_ymm_ymm_ymmm256
public Code EVEX_Vpackssdw_xmm_k1z_xmm_xmmm128b32
public Code EVEX_Vpackssdw_ymm_k1z_ymm_ymmm256b32
public Code EVEX_Vpackssdw_zmm_k1z_zmm_zmmm512b32
public Code Punpcklqdq_xmm_xmmm128
public Code VEX_Vpunpcklqdq_xmm_xmm_xmmm128
public Code VEX_Vpunpcklqdq_ymm_ymm_ymmm256
public Code EVEX_Vpunpcklqdq_xmm_k1z_xmm_xmmm128b64
public Code EVEX_Vpunpcklqdq_ymm_k1z_ymm_ymmm256b64
public Code EVEX_Vpunpcklqdq_zmm_k1z_zmm_zmmm512b64
public Code Punpckhqdq_xmm_xmmm128
public Code VEX_Vpunpckhqdq_xmm_xmm_xmmm128
public Code VEX_Vpunpckhqdq_ymm_ymm_ymmm256
public Code EVEX_Vpunpckhqdq_xmm_k1z_xmm_xmmm128b64
public Code EVEX_Vpunpckhqdq_ymm_k1z_ymm_ymmm256b64
public Code EVEX_Vpunpckhqdq_zmm_k1z_zmm_zmmm512b64
public Code Movd_mm_rm32
public Code Movq_mm_rm64
public Code Movd_xmm_rm32
public Code Movq_xmm_rm64
public Code VEX_Vmovd_xmm_rm32
public Code VEX_Vmovq_xmm_rm64
public Code EVEX_Vmovd_xmm_rm32
public Code EVEX_Vmovq_xmm_rm64
public Code Movq_mm_mmm64
public Code Movdqa_xmm_xmmm128
public Code VEX_Vmovdqa_xmm_xmmm128
public Code VEX_Vmovdqa_ymm_ymmm256
public Code EVEX_Vmovdqa32_xmm_k1z_xmmm128
public Code EVEX_Vmovdqa32_ymm_k1z_ymmm256
public Code EVEX_Vmovdqa32_zmm_k1z_zmmm512
public Code EVEX_Vmovdqa64_xmm_k1z_xmmm128
public Code EVEX_Vmovdqa64_ymm_k1z_ymmm256
public Code EVEX_Vmovdqa64_zmm_k1z_zmmm512
public Code Movdqu_xmm_xmmm128
public Code VEX_Vmovdqu_xmm_xmmm128
public Code VEX_Vmovdqu_ymm_ymmm256
public Code EVEX_Vmovdqu32_xmm_k1z_xmmm128
public Code EVEX_Vmovdqu32_ymm_k1z_ymmm256
public Code EVEX_Vmovdqu32_zmm_k1z_zmmm512
public Code EVEX_Vmovdqu64_xmm_k1z_xmmm128
public Code EVEX_Vmovdqu64_ymm_k1z_ymmm256
public Code EVEX_Vmovdqu64_zmm_k1z_zmmm512
public Code EVEX_Vmovdqu8_xmm_k1z_xmmm128
public Code EVEX_Vmovdqu8_ymm_k1z_ymmm256
public Code EVEX_Vmovdqu8_zmm_k1z_zmmm512
public Code EVEX_Vmovdqu16_xmm_k1z_xmmm128
public Code EVEX_Vmovdqu16_ymm_k1z_ymmm256
public Code EVEX_Vmovdqu16_zmm_k1z_zmmm512
public Code Pshufw_mm_mmm64_imm8
public Code Pshufd_xmm_xmmm128_imm8
public Code VEX_Vpshufd_xmm_xmmm128_imm8
public Code VEX_Vpshufd_ymm_ymmm256_imm8
public Code EVEX_Vpshufd_xmm_k1z_xmmm128b32_imm8
public Code EVEX_Vpshufd_ymm_k1z_ymmm256b32_imm8
public Code EVEX_Vpshufd_zmm_k1z_zmmm512b32_imm8
public Code Pshufhw_xmm_xmmm128_imm8
public Code VEX_Vpshufhw_xmm_xmmm128_imm8
public Code VEX_Vpshufhw_ymm_ymmm256_imm8
public Code EVEX_Vpshufhw_xmm_k1z_xmmm128_imm8
public Code EVEX_Vpshufhw_ymm_k1z_ymmm256_imm8
public Code EVEX_Vpshufhw_zmm_k1z_zmmm512_imm8
public Code Pshuflw_xmm_xmmm128_imm8
public Code VEX_Vpshuflw_xmm_xmmm128_imm8
public Code VEX_Vpshuflw_ymm_ymmm256_imm8
public Code EVEX_Vpshuflw_xmm_k1z_xmmm128_imm8
public Code EVEX_Vpshuflw_ymm_k1z_ymmm256_imm8
public Code EVEX_Vpshuflw_zmm_k1z_zmmm512_imm8
public Code Psrlw_mm_imm8
public Code Psrlw_xmm_imm8
public Code VEX_Vpsrlw_xmm_xmm_imm8
public Code VEX_Vpsrlw_ymm_ymm_imm8
public Code EVEX_Vpsrlw_xmm_k1z_xmmm128_imm8
public Code EVEX_Vpsrlw_ymm_k1z_ymmm256_imm8
public Code EVEX_Vpsrlw_zmm_k1z_zmmm512_imm8
public Code Psraw_mm_imm8
public Code Psraw_xmm_imm8
public Code VEX_Vpsraw_xmm_xmm_imm8
public Code VEX_Vpsraw_ymm_ymm_imm8
public Code EVEX_Vpsraw_xmm_k1z_xmmm128_imm8
public Code EVEX_Vpsraw_ymm_k1z_ymmm256_imm8
public Code EVEX_Vpsraw_zmm_k1z_zmmm512_imm8
public Code Psllw_mm_imm8
public Code Psllw_xmm_imm8
public Code VEX_Vpsllw_xmm_xmm_imm8
public Code VEX_Vpsllw_ymm_ymm_imm8
public Code EVEX_Vpsllw_xmm_k1z_xmmm128_imm8
public Code EVEX_Vpsllw_ymm_k1z_ymmm256_imm8
public Code EVEX_Vpsllw_zmm_k1z_zmmm512_imm8
public Code EVEX_Vprord_xmm_k1z_xmmm128b32_imm8
public Code EVEX_Vprord_ymm_k1z_ymmm256b32_imm8
public Code EVEX_Vprord_zmm_k1z_zmmm512b32_imm8
public Code EVEX_Vprorq_xmm_k1z_xmmm128b64_imm8
public Code EVEX_Vprorq_ymm_k1z_ymmm256b64_imm8
public Code EVEX_Vprorq_zmm_k1z_zmmm512b64_imm8
public Code EVEX_Vprold_xmm_k1z_xmmm128b32_imm8
public Code EVEX_Vprold_ymm_k1z_ymmm256b32_imm8
public Code EVEX_Vprold_zmm_k1z_zmmm512b32_imm8
public Code EVEX_Vprolq_xmm_k1z_xmmm128b64_imm8
public Code EVEX_Vprolq_ymm_k1z_ymmm256b64_imm8
public Code EVEX_Vprolq_zmm_k1z_zmmm512b64_imm8
public Code Psrld_mm_imm8
public Code Psrld_xmm_imm8
public Code VEX_Vpsrld_xmm_xmm_imm8
public Code VEX_Vpsrld_ymm_ymm_imm8
public Code EVEX_Vpsrld_xmm_k1z_xmmm128b32_imm8
public Code EVEX_Vpsrld_ymm_k1z_ymmm256b32_imm8
public Code EVEX_Vpsrld_zmm_k1z_zmmm512b32_imm8
public Code Psrad_mm_imm8
public Code Psrad_xmm_imm8
public Code VEX_Vpsrad_xmm_xmm_imm8
public Code VEX_Vpsrad_ymm_ymm_imm8
public Code EVEX_Vpsrad_xmm_k1z_xmmm128b32_imm8
public Code EVEX_Vpsrad_ymm_k1z_ymmm256b32_imm8
public Code EVEX_Vpsrad_zmm_k1z_zmmm512b32_imm8
public Code EVEX_Vpsraq_xmm_k1z_xmmm128b64_imm8
public Code EVEX_Vpsraq_ymm_k1z_ymmm256b64_imm8
public Code EVEX_Vpsraq_zmm_k1z_zmmm512b64_imm8
public Code Pslld_mm_imm8
public Code Pslld_xmm_imm8
public Code VEX_Vpslld_xmm_xmm_imm8
public Code VEX_Vpslld_ymm_ymm_imm8
public Code EVEX_Vpslld_xmm_k1z_xmmm128b32_imm8
public Code EVEX_Vpslld_ymm_k1z_ymmm256b32_imm8
public Code EVEX_Vpslld_zmm_k1z_zmmm512b32_imm8
public Code Psrlq_mm_imm8
public Code Psrlq_xmm_imm8
public Code VEX_Vpsrlq_xmm_xmm_imm8
public Code VEX_Vpsrlq_ymm_ymm_imm8
public Code EVEX_Vpsrlq_xmm_k1z_xmmm128b64_imm8
public Code EVEX_Vpsrlq_ymm_k1z_ymmm256b64_imm8
public Code EVEX_Vpsrlq_zmm_k1z_zmmm512b64_imm8
public Code Psrldq_xmm_imm8
public Code VEX_Vpsrldq_xmm_xmm_imm8
public Code VEX_Vpsrldq_ymm_ymm_imm8
public Code EVEX_Vpsrldq_xmm_xmmm128_imm8
public Code EVEX_Vpsrldq_ymm_ymmm256_imm8
public Code EVEX_Vpsrldq_zmm_zmmm512_imm8
public Code Psllq_mm_imm8
public Code Psllq_xmm_imm8
public Code VEX_Vpsllq_xmm_xmm_imm8
public Code VEX_Vpsllq_ymm_ymm_imm8
public Code EVEX_Vpsllq_xmm_k1z_xmmm128b64_imm8
public Code EVEX_Vpsllq_ymm_k1z_ymmm256b64_imm8
public Code EVEX_Vpsllq_zmm_k1z_zmmm512b64_imm8
public Code Pslldq_xmm_imm8
public Code VEX_Vpslldq_xmm_xmm_imm8
public Code VEX_Vpslldq_ymm_ymm_imm8
public Code EVEX_Vpslldq_xmm_xmmm128_imm8
public Code EVEX_Vpslldq_ymm_ymmm256_imm8
public Code EVEX_Vpslldq_zmm_zmmm512_imm8
public Code Pcmpeqb_mm_mmm64
public Code Pcmpeqb_xmm_xmmm128
public Code VEX_Vpcmpeqb_xmm_xmm_xmmm128
public Code VEX_Vpcmpeqb_ymm_ymm_ymmm256
public Code EVEX_Vpcmpeqb_kr_k1_xmm_xmmm128
public Code EVEX_Vpcmpeqb_kr_k1_ymm_ymmm256
public Code EVEX_Vpcmpeqb_kr_k1_zmm_zmmm512
public Code Pcmpeqw_mm_mmm64
public Code Pcmpeqw_xmm_xmmm128
public Code VEX_Vpcmpeqw_xmm_xmm_xmmm128
public Code VEX_Vpcmpeqw_ymm_ymm_ymmm256
public Code EVEX_Vpcmpeqw_kr_k1_xmm_xmmm128
public Code EVEX_Vpcmpeqw_kr_k1_ymm_ymmm256
public Code EVEX_Vpcmpeqw_kr_k1_zmm_zmmm512
public Code Pcmpeqd_mm_mmm64
public Code Pcmpeqd_xmm_xmmm128
public Code VEX_Vpcmpeqd_xmm_xmm_xmmm128
public Code VEX_Vpcmpeqd_ymm_ymm_ymmm256
public Code EVEX_Vpcmpeqd_kr_k1_xmm_xmmm128b32
public Code EVEX_Vpcmpeqd_kr_k1_ymm_ymmm256b32
public Code EVEX_Vpcmpeqd_kr_k1_zmm_zmmm512b32
public Code Emms
public Code VEX_Vzeroupper
public Code VEX_Vzeroall
public Code Vmread_rm32_r32
public Code Vmread_rm64_r64
public Code EVEX_Vcvttps2udq_xmm_k1z_xmmm128b32
public Code EVEX_Vcvttps2udq_ymm_k1z_ymmm256b32
public Code EVEX_Vcvttps2udq_zmm_k1z_zmmm512b32_sae
public Code EVEX_Vcvttpd2udq_xmm_k1z_xmmm128b64
public Code EVEX_Vcvttpd2udq_xmm_k1z_ymmm256b64
public Code EVEX_Vcvttpd2udq_ymm_k1z_zmmm512b64_sae
public Code Extrq_xmm_imm8_imm8
public Code EVEX_Vcvttps2uqq_xmm_k1z_xmmm64b32
public Code EVEX_Vcvttps2uqq_ymm_k1z_xmmm128b32
public Code EVEX_Vcvttps2uqq_zmm_k1z_ymmm256b32_sae
public Code EVEX_Vcvttpd2uqq_xmm_k1z_xmmm128b64
public Code EVEX_Vcvttpd2uqq_ymm_k1z_ymmm256b64
public Code EVEX_Vcvttpd2uqq_zmm_k1z_zmmm512b64_sae
public Code EVEX_Vcvttss2usi_r32_xmmm32_sae
public Code EVEX_Vcvttss2usi_r64_xmmm32_sae
public Code Insertq_xmm_xmm_imm8_imm8
public Code EVEX_Vcvttsd2usi_r32_xmmm64_sae
public Code EVEX_Vcvttsd2usi_r64_xmmm64_sae
public Code Vmwrite_r32_rm32
public Code Vmwrite_r64_rm64
public Code EVEX_Vcvtps2udq_xmm_k1z_xmmm128b32
public Code EVEX_Vcvtps2udq_ymm_k1z_ymmm256b32
public Code EVEX_Vcvtps2udq_zmm_k1z_zmmm512b32_er
public Code EVEX_Vcvtpd2udq_xmm_k1z_xmmm128b64
public Code EVEX_Vcvtpd2udq_xmm_k1z_ymmm256b64
public Code EVEX_Vcvtpd2udq_ymm_k1z_zmmm512b64_er
public Code Extrq_xmm_xmm
public Code EVEX_Vcvtps2uqq_xmm_k1z_xmmm64b32
public Code EVEX_Vcvtps2uqq_ymm_k1z_xmmm128b32
public Code EVEX_Vcvtps2uqq_zmm_k1z_ymmm256b32_er
public Code EVEX_Vcvtpd2uqq_xmm_k1z_xmmm128b64
public Code EVEX_Vcvtpd2uqq_ymm_k1z_ymmm256b64
public Code EVEX_Vcvtpd2uqq_zmm_k1z_zmmm512b64_er
public Code EVEX_Vcvtss2usi_r32_xmmm32_er
public Code EVEX_Vcvtss2usi_r64_xmmm32_er
public Code Insertq_xmm_xmm
public Code EVEX_Vcvtsd2usi_r32_xmmm64_er
public Code EVEX_Vcvtsd2usi_r64_xmmm64_er
public Code EVEX_Vcvttps2qq_xmm_k1z_xmmm64b32
public Code EVEX_Vcvttps2qq_ymm_k1z_xmmm128b32
public Code EVEX_Vcvttps2qq_zmm_k1z_ymmm256b32_sae
public Code EVEX_Vcvttpd2qq_xmm_k1z_xmmm128b64
public Code EVEX_Vcvttpd2qq_ymm_k1z_ymmm256b64
public Code EVEX_Vcvttpd2qq_zmm_k1z_zmmm512b64_sae
public Code EVEX_Vcvtudq2pd_xmm_k1z_xmmm64b32
public Code EVEX_Vcvtudq2pd_ymm_k1z_xmmm128b32
public Code EVEX_Vcvtudq2pd_zmm_k1z_ymmm256b32_er
public Code EVEX_Vcvtuqq2pd_xmm_k1z_xmmm128b64
public Code EVEX_Vcvtuqq2pd_ymm_k1z_ymmm256b64
public Code EVEX_Vcvtuqq2pd_zmm_k1z_zmmm512b64_er
public Code EVEX_Vcvtudq2ps_xmm_k1z_xmmm128b32
public Code EVEX_Vcvtudq2ps_ymm_k1z_ymmm256b32
public Code EVEX_Vcvtudq2ps_zmm_k1z_zmmm512b32_er
public Code EVEX_Vcvtuqq2ps_xmm_k1z_xmmm128b64
public Code EVEX_Vcvtuqq2ps_xmm_k1z_ymmm256b64
public Code EVEX_Vcvtuqq2ps_ymm_k1z_zmmm512b64_er
public Code EVEX_Vcvtps2qq_xmm_k1z_xmmm64b32
public Code EVEX_Vcvtps2qq_ymm_k1z_xmmm128b32
public Code EVEX_Vcvtps2qq_zmm_k1z_ymmm256b32_er
public Code EVEX_Vcvtpd2qq_xmm_k1z_xmmm128b64
public Code EVEX_Vcvtpd2qq_ymm_k1z_ymmm256b64
public Code EVEX_Vcvtpd2qq_zmm_k1z_zmmm512b64_er
public Code EVEX_Vcvtusi2ss_xmm_xmm_rm32_er
public Code EVEX_Vcvtusi2ss_xmm_xmm_rm64_er
public Code EVEX_Vcvtusi2sd_xmm_xmm_rm32_er
public Code EVEX_Vcvtusi2sd_xmm_xmm_rm64_er
public Code Haddpd_xmm_xmmm128
public Code VEX_Vhaddpd_xmm_xmm_xmmm128
public Code VEX_Vhaddpd_ymm_ymm_ymmm256
public Code Haddps_xmm_xmmm128
public Code VEX_Vhaddps_xmm_xmm_xmmm128
public Code VEX_Vhaddps_ymm_ymm_ymmm256
public Code Hsubpd_xmm_xmmm128
public Code VEX_Vhsubpd_xmm_xmm_xmmm128
public Code VEX_Vhsubpd_ymm_ymm_ymmm256
public Code Hsubps_xmm_xmmm128
public Code VEX_Vhsubps_xmm_xmm_xmmm128
public Code VEX_Vhsubps_ymm_ymm_ymmm256
public Code Movd_rm32_mm
public Code Movq_rm64_mm
public Code Movd_rm32_xmm
public Code Movq_rm64_xmm
public Code VEX_Vmovd_rm32_xmm
public Code VEX_Vmovq_rm64_xmm
public Code EVEX_Vmovd_rm32_xmm
public Code EVEX_Vmovq_rm64_xmm
public Code Movq_xmm_xmmm64
public Code VEX_Vmovq_xmm_xmmm64
public Code EVEX_Vmovq_xmm_xmmm64
public Code Movq_mmm64_mm
public Code Movdqa_xmmm128_xmm
public Code VEX_Vmovdqa_xmmm128_xmm
public Code VEX_Vmovdqa_ymmm256_ymm
public Code EVEX_Vmovdqa32_xmmm128_k1z_xmm
public Code EVEX_Vmovdqa32_ymmm256_k1z_ymm
public Code EVEX_Vmovdqa32_zmmm512_k1z_zmm
public Code EVEX_Vmovdqa64_xmmm128_k1z_xmm
public Code EVEX_Vmovdqa64_ymmm256_k1z_ymm
public Code EVEX_Vmovdqa64_zmmm512_k1z_zmm
public Code Movdqu_xmmm128_xmm
public Code VEX_Vmovdqu_xmmm128_xmm
public Code VEX_Vmovdqu_ymmm256_ymm
public Code EVEX_Vmovdqu32_xmmm128_k1z_xmm
public Code EVEX_Vmovdqu32_ymmm256_k1z_ymm
public Code EVEX_Vmovdqu32_zmmm512_k1z_zmm
public Code EVEX_Vmovdqu64_xmmm128_k1z_xmm
public Code EVEX_Vmovdqu64_ymmm256_k1z_ymm
public Code EVEX_Vmovdqu64_zmmm512_k1z_zmm
public Code EVEX_Vmovdqu8_xmmm128_k1z_xmm
public Code EVEX_Vmovdqu8_ymmm256_k1z_ymm
public Code EVEX_Vmovdqu8_zmmm512_k1z_zmm
public Code EVEX_Vmovdqu16_xmmm128_k1z_xmm
public Code EVEX_Vmovdqu16_ymmm256_k1z_ymm
public Code EVEX_Vmovdqu16_zmmm512_k1z_zmm
public Code Jo_rel16
public Code Jo_rel32_32
public Code Jo_rel32_64
public Code Jno_rel16
public Code Jno_rel32_32
public Code Jno_rel32_64
public Code Jb_rel16
public Code Jb_rel32_32
public Code Jb_rel32_64
public Code Jae_rel16
public Code Jae_rel32_32
public Code Jae_rel32_64
public Code Je_rel16
public Code Je_rel32_32
public Code Je_rel32_64
public Code Jne_rel16
public Code Jne_rel32_32
public Code Jne_rel32_64
public Code Jbe_rel16
public Code Jbe_rel32_32
public Code Jbe_rel32_64
public Code Ja_rel16
public Code Ja_rel32_32
public Code Ja_rel32_64
public Code Js_rel16
public Code Js_rel32_32
public Code Js_rel32_64
public Code Jns_rel16
public Code Jns_rel32_32
public Code Jns_rel32_64
public Code Jp_rel16
public Code Jp_rel32_32
public Code Jp_rel32_64
public Code Jnp_rel16
public Code Jnp_rel32_32
public Code Jnp_rel32_64
public Code Jl_rel16
public Code Jl_rel32_32
public Code Jl_rel32_64
public Code Jge_rel16
public Code Jge_rel32_32
public Code Jge_rel32_64
public Code Jle_rel16
public Code Jle_rel32_32
public Code Jle_rel32_64
public Code Jg_rel16
public Code Jg_rel32_32
public Code Jg_rel32_64
public Code Seto_rm8
public Code Setno_rm8
public Code Setb_rm8
public Code Setae_rm8
public Code Sete_rm8
public Code Setne_rm8
public Code Setbe_rm8
public Code Seta_rm8
public Code Sets_rm8
public Code Setns_rm8
public Code Setp_rm8
public Code Setnp_rm8
public Code Setl_rm8
public Code Setge_rm8
public Code Setle_rm8
public Code Setg_rm8
public Code VEX_Kmovw_kr_km16
public Code VEX_Kmovq_kr_km64
public Code VEX_Kmovb_kr_km8
public Code VEX_Kmovd_kr_km32
public Code VEX_Kmovw_m16_kr
public Code VEX_Kmovq_m64_kr
public Code VEX_Kmovb_m8_kr
public Code VEX_Kmovd_m32_kr
public Code VEX_Kmovw_kr_r32
public Code VEX_Kmovb_kr_r32
public Code VEX_Kmovd_kr_r32
public Code VEX_Kmovq_kr_r64
public Code VEX_Kmovw_r32_kr
public Code VEX_Kmovb_r32_kr
public Code VEX_Kmovd_r32_kr
public Code VEX_Kmovq_r64_kr
public Code VEX_Kortestw_kr_kr
public Code VEX_Kortestq_kr_kr
public Code VEX_Kortestb_kr_kr
public Code VEX_Kortestd_kr_kr
public Code VEX_Ktestw_kr_kr
public Code VEX_Ktestq_kr_kr
public Code VEX_Ktestb_kr_kr
public Code VEX_Ktestd_kr_kr
public Code Pushw_FS
public Code Pushd_FS
public Code Pushq_FS
public Code Popw_FS
public Code Popd_FS
public Code Popq_FS
public Code Cpuid
public Code Bt_rm16_r16
public Code Bt_rm32_r32
public Code Bt_rm64_r64
public Code Shld_rm16_r16_imm8
public Code Shld_rm32_r32_imm8
public Code Shld_rm64_r64_imm8
public Code Shld_rm16_r16_CL
public Code Shld_rm32_r32_CL
public Code Shld_rm64_r64_CL
public Code Montmul_16
public Code Montmul_32
public Code Montmul_64
public Code Xsha1_16
public Code Xsha1_32
public Code Xsha1_64
public Code Xsha256_16
public Code Xsha256_32
public Code Xsha256_64
public Code Xbts_r16_rm16
public Code Xbts_r32_rm32
public Code Xstore_16
public Code Xstore_32
public Code Xstore_64
public Code Xcryptecb_16
public Code Xcryptecb_32
public Code Xcryptecb_64
public Code Xcryptcbc_16
public Code Xcryptcbc_32
public Code Xcryptcbc_64
public Code Xcryptctr_16
public Code Xcryptctr_32
public Code Xcryptctr_64
public Code Xcryptcfb_16
public Code Xcryptcfb_32
public Code Xcryptcfb_64
public Code Xcryptofb_16
public Code Xcryptofb_32
public Code Xcryptofb_64
public Code Ibts_rm16_r16
public Code Ibts_rm32_r32
public Code Cmpxchg486_rm8_r8
public Code Cmpxchg486_rm16_r16
public Code Cmpxchg486_rm32_r32
public Code Pushw_GS
public Code Pushd_GS
public Code Pushq_GS
public Code Popw_GS
public Code Popd_GS
public Code Popq_GS
public Code Rsm
public Code Bts_rm16_r16
public Code Bts_rm32_r32
public Code Bts_rm64_r64
public Code Shrd_rm16_r16_imm8
public Code Shrd_rm32_r32_imm8
public Code Shrd_rm64_r64_imm8
public Code Shrd_rm16_r16_CL
public Code Shrd_rm32_r32_CL
public Code Shrd_rm64_r64_CL
public Code Fxsave_m512byte
public Code Fxsave64_m512byte
public Code Rdfsbase_r32
public Code Rdfsbase_r64
public Code Fxrstor_m512byte
public Code Fxrstor64_m512byte
public Code Rdgsbase_r32
public Code Rdgsbase_r64
public Code Ldmxcsr_m32
public Code Wrfsbase_r32
public Code Wrfsbase_r64
public Code VEX_Vldmxcsr_m32
public Code Stmxcsr_m32
public Code Wrgsbase_r32
public Code Wrgsbase_r64
public Code VEX_Vstmxcsr_m32
public Code Xsave_mem
public Code Xsave64_mem
public Code Ptwrite_rm32
public Code Ptwrite_rm64
public Code Xrstor_mem
public Code Xrstor64_mem
public Code Incsspd_r32
public Code Incsspq_r64
public Code Xsaveopt_mem
public Code Xsaveopt64_mem
public Code Clwb_m8
public Code Tpause_r32
public Code Tpause_r64
public Code Clrssbsy_m64
public Code Umonitor_r16
public Code Umonitor_r32
public Code Umonitor_r64
public Code Umwait_r32
public Code Umwait_r64
public Code Clflush_m8
public Code Clflushopt_m8
public Code Lfence
public Code Lfence_E9
public Code Lfence_EA
public Code Lfence_EB
public Code Lfence_EC
public Code Lfence_ED
public Code Lfence_EE
public Code Lfence_EF
public Code Mfence
public Code Mfence_F1
public Code Mfence_F2
public Code Mfence_F3
public Code Mfence_F4
public Code Mfence_F5
public Code Mfence_F6
public Code Mfence_F7
public Code Sfence
public Code Sfence_F9
public Code Sfence_FA
public Code Sfence_FB
public Code Sfence_FC
public Code Sfence_FD
public Code Sfence_FE
public Code Sfence_FF
public Code Pcommit
public Code Imul_r16_rm16
public Code Imul_r32_rm32
public Code Imul_r64_rm64
public Code Cmpxchg_rm8_r8
public Code Cmpxchg_rm16_r16
public Code Cmpxchg_rm32_r32
public Code Cmpxchg_rm64_r64
public Code Lss_r16_m1616
public Code Lss_r32_m1632
public Code Lss_r64_m1664
public Code Btr_rm16_r16
public Code Btr_rm32_r32
public Code Btr_rm64_r64
public Code Lfs_r16_m1616
public Code Lfs_r32_m1632
public Code Lfs_r64_m1664
public Code Lgs_r16_m1616
public Code Lgs_r32_m1632
public Code Lgs_r64_m1664
public Code Movzx_r16_rm8
public Code Movzx_r32_rm8
public Code Movzx_r64_rm8
public Code Movzx_r16_rm16
public Code Movzx_r32_rm16
public Code Movzx_r64_rm16
public Code Jmpe_disp16
public Code Jmpe_disp32
public Code Popcnt_r16_rm16
public Code Popcnt_r32_rm32
public Code Popcnt_r64_rm64
public Code Ud1_r16_rm16
public Code Ud1_r32_rm32
public Code Ud1_r64_rm64
public Code Bt_rm16_imm8
public Code Bt_rm32_imm8
public Code Bt_rm64_imm8
public Code Bts_rm16_imm8
public Code Bts_rm32_imm8
public Code Bts_rm64_imm8
public Code Btr_rm16_imm8
public Code Btr_rm32_imm8
public Code Btr_rm64_imm8
public Code Btc_rm16_imm8
public Code Btc_rm32_imm8
public Code Btc_rm64_imm8
public Code Btc_rm16_r16
public Code Btc_rm32_r32
public Code Btc_rm64_r64
public Code Bsf_r16_rm16
public Code Bsf_r32_rm32
public Code Bsf_r64_rm64
public Code Tzcnt_r16_rm16
public Code Tzcnt_r32_rm32
public Code Tzcnt_r64_rm64
public Code Bsr_r16_rm16
public Code Bsr_r32_rm32
public Code Bsr_r64_rm64
public Code Lzcnt_r16_rm16
public Code Lzcnt_r32_rm32
public Code Lzcnt_r64_rm64
public Code Movsx_r16_rm8
public Code Movsx_r32_rm8
public Code Movsx_r64_rm8
public Code Movsx_r16_rm16
public Code Movsx_r32_rm16
public Code Movsx_r64_rm16
public Code Xadd_rm8_r8
public Code Xadd_rm16_r16
public Code Xadd_rm32_r32
public Code Xadd_rm64_r64
public Code Cmpps_xmm_xmmm128_imm8
public Code VEX_Vcmpps_xmm_xmm_xmmm128_imm8
public Code VEX_Vcmpps_ymm_ymm_ymmm256_imm8
public Code EVEX_Vcmpps_kr_k1_xmm_xmmm128b32_imm8
public Code EVEX_Vcmpps_kr_k1_ymm_ymmm256b32_imm8
public Code EVEX_Vcmpps_kr_k1_zmm_zmmm512b32_imm8_sae
public Code Cmppd_xmm_xmmm128_imm8
public Code VEX_Vcmppd_xmm_xmm_xmmm128_imm8
public Code VEX_Vcmppd_ymm_ymm_ymmm256_imm8
public Code EVEX_Vcmppd_kr_k1_xmm_xmmm128b64_imm8
public Code EVEX_Vcmppd_kr_k1_ymm_ymmm256b64_imm8
public Code EVEX_Vcmppd_kr_k1_zmm_zmmm512b64_imm8_sae
public Code Cmpss_xmm_xmmm32_imm8
public Code VEX_Vcmpss_xmm_xmm_xmmm32_imm8
public Code EVEX_Vcmpss_kr_k1_xmm_xmmm32_imm8_sae
public Code Cmpsd_xmm_xmmm64_imm8
public Code VEX_Vcmpsd_xmm_xmm_xmmm64_imm8
public Code EVEX_Vcmpsd_kr_k1_xmm_xmmm64_imm8_sae
public Code Movnti_m32_r32
public Code Movnti_m64_r64
public Code Pinsrw_mm_r32m16_imm8
public Code Pinsrw_mm_r64m16_imm8
public Code Pinsrw_xmm_r32m16_imm8
public Code Pinsrw_xmm_r64m16_imm8
public Code VEX_Vpinsrw_xmm_xmm_r32m16_imm8
public Code VEX_Vpinsrw_xmm_xmm_r64m16_imm8
public Code EVEX_Vpinsrw_xmm_xmm_r32m16_imm8
public Code EVEX_Vpinsrw_xmm_xmm_r64m16_imm8
public Code Pextrw_r32_mm_imm8
public Code Pextrw_r64_mm_imm8
public Code Pextrw_r32_xmm_imm8
public Code Pextrw_r64_xmm_imm8
public Code VEX_Vpextrw_r32_xmm_imm8
public Code VEX_Vpextrw_r64_xmm_imm8
public Code EVEX_Vpextrw_r32_xmm_imm8
public Code EVEX_Vpextrw_r64_xmm_imm8
public Code Shufps_xmm_xmmm128_imm8
public Code VEX_Vshufps_xmm_xmm_xmmm128_imm8
public Code VEX_Vshufps_ymm_ymm_ymmm256_imm8
public Code EVEX_Vshufps_xmm_k1z_xmm_xmmm128b32_imm8
public Code EVEX_Vshufps_ymm_k1z_ymm_ymmm256b32_imm8
public Code EVEX_Vshufps_zmm_k1z_zmm_zmmm512b32_imm8
public Code Shufpd_xmm_xmmm128_imm8
public Code VEX_Vshufpd_xmm_xmm_xmmm128_imm8
public Code VEX_Vshufpd_ymm_ymm_ymmm256_imm8
public Code EVEX_Vshufpd_xmm_k1z_xmm_xmmm128b64_imm8
public Code EVEX_Vshufpd_ymm_k1z_ymm_ymmm256b64_imm8
public Code EVEX_Vshufpd_zmm_k1z_zmm_zmmm512b64_imm8
public Code Cmpxchg8b_m64
public Code Cmpxchg16b_m128
public Code Xrstors_mem
public Code Xrstors64_mem
public Code Xsavec_mem
public Code Xsavec64_mem
public Code Xsaves_mem
public Code Xsaves64_mem
public Code Vmptrld_m64
public Code Vmclear_m64
public Code Vmxon_m64
public Code Rdrand_r16
public Code Rdrand_r32
public Code Rdrand_r64
public Code Vmptrst_m64
public Code Rdseed_r16
public Code Rdseed_r32
public Code Rdseed_r64
public Code Rdpid_r32
public Code Rdpid_r64
public Code Bswap_r16
public Code Bswap_r32
public Code Bswap_r64
public Code Addsubpd_xmm_xmmm128
public Code VEX_Vaddsubpd_xmm_xmm_xmmm128
public Code VEX_Vaddsubpd_ymm_ymm_ymmm256
public Code Addsubps_xmm_xmmm128
public Code VEX_Vaddsubps_xmm_xmm_xmmm128
public Code VEX_Vaddsubps_ymm_ymm_ymmm256
public Code Psrlw_mm_mmm64
public Code Psrlw_xmm_xmmm128
public Code VEX_Vpsrlw_xmm_xmm_xmmm128
public Code VEX_Vpsrlw_ymm_ymm_xmmm128
public Code EVEX_Vpsrlw_xmm_k1z_xmm_xmmm128
public Code EVEX_Vpsrlw_ymm_k1z_ymm_xmmm128
public Code EVEX_Vpsrlw_zmm_k1z_zmm_xmmm128
public Code Psrld_mm_mmm64
public Code Psrld_xmm_xmmm128
public Code VEX_Vpsrld_xmm_xmm_xmmm128
public Code VEX_Vpsrld_ymm_ymm_xmmm128
public Code EVEX_Vpsrld_xmm_k1z_xmm_xmmm128
public Code EVEX_Vpsrld_ymm_k1z_ymm_xmmm128
public Code EVEX_Vpsrld_zmm_k1z_zmm_xmmm128
public Code Psrlq_mm_mmm64
public Code Psrlq_xmm_xmmm128
public Code VEX_Vpsrlq_xmm_xmm_xmmm128
public Code VEX_Vpsrlq_ymm_ymm_xmmm128
public Code EVEX_Vpsrlq_xmm_k1z_xmm_xmmm128
public Code EVEX_Vpsrlq_ymm_k1z_ymm_xmmm128
public Code EVEX_Vpsrlq_zmm_k1z_zmm_xmmm128
public Code Paddq_mm_mmm64
public Code Paddq_xmm_xmmm128
public Code VEX_Vpaddq_xmm_xmm_xmmm128
public Code VEX_Vpaddq_ymm_ymm_ymmm256
public Code EVEX_Vpaddq_xmm_k1z_xmm_xmmm128b64
public Code EVEX_Vpaddq_ymm_k1z_ymm_ymmm256b64
public Code EVEX_Vpaddq_zmm_k1z_zmm_zmmm512b64
public Code Pmullw_mm_mmm64
public Code Pmullw_xmm_xmmm128
public Code VEX_Vpmullw_xmm_xmm_xmmm128
public Code VEX_Vpmullw_ymm_ymm_ymmm256
public Code EVEX_Vpmullw_xmm_k1z_xmm_xmmm128
public Code EVEX_Vpmullw_ymm_k1z_ymm_ymmm256
public Code EVEX_Vpmullw_zmm_k1z_zmm_zmmm512
public Code Movq_xmmm64_xmm
public Code VEX_Vmovq_xmmm64_xmm
public Code EVEX_Vmovq_xmmm64_xmm
public Code Movq2dq_xmm_mm
public Code Movdq2q_mm_xmm
public Code Pmovmskb_r32_mm
public Code Pmovmskb_r64_mm
public Code Pmovmskb_r32_xmm
public Code Pmovmskb_r64_xmm
public Code VEX_Vpmovmskb_r32_xmm
public Code VEX_Vpmovmskb_r64_xmm
public Code VEX_Vpmovmskb_r32_ymm
public Code VEX_Vpmovmskb_r64_ymm
public Code Psubusb_mm_mmm64
public Code Psubusb_xmm_xmmm128
public Code VEX_Vpsubusb_xmm_xmm_xmmm128
public Code VEX_Vpsubusb_ymm_ymm_ymmm256
public Code EVEX_Vpsubusb_xmm_k1z_xmm_xmmm128
public Code EVEX_Vpsubusb_ymm_k1z_ymm_ymmm256
public Code EVEX_Vpsubusb_zmm_k1z_zmm_zmmm512
public Code Psubusw_mm_mmm64
public Code Psubusw_xmm_xmmm128
public Code VEX_Vpsubusw_xmm_xmm_xmmm128
public Code VEX_Vpsubusw_ymm_ymm_ymmm256
public Code EVEX_Vpsubusw_xmm_k1z_xmm_xmmm128
public Code EVEX_Vpsubusw_ymm_k1z_ymm_ymmm256
public Code EVEX_Vpsubusw_zmm_k1z_zmm_zmmm512
public Code Pminub_mm_mmm64
public Code Pminub_xmm_xmmm128
public Code VEX_Vpminub_xmm_xmm_xmmm128
public Code VEX_Vpminub_ymm_ymm_ymmm256
public Code EVEX_Vpminub_xmm_k1z_xmm_xmmm128
public Code EVEX_Vpminub_ymm_k1z_ymm_ymmm256
public Code EVEX_Vpminub_zmm_k1z_zmm_zmmm512
public Code Pand_mm_mmm64
public Code Pand_xmm_xmmm128
public Code VEX_Vpand_xmm_xmm_xmmm128
public Code VEX_Vpand_ymm_ymm_ymmm256
public Code EVEX_Vpandd_xmm_k1z_xmm_xmmm128b32
public Code EVEX_Vpandd_ymm_k1z_ymm_ymmm256b32
public Code EVEX_Vpandd_zmm_k1z_zmm_zmmm512b32
public Code EVEX_Vpandq_xmm_k1z_xmm_xmmm128b64
public Code EVEX_Vpandq_ymm_k1z_ymm_ymmm256b64
public Code EVEX_Vpandq_zmm_k1z_zmm_zmmm512b64
public Code Paddusb_mm_mmm64
public Code Paddusb_xmm_xmmm128
public Code VEX_Vpaddusb_xmm_xmm_xmmm128
public Code VEX_Vpaddusb_ymm_ymm_ymmm256
public Code EVEX_Vpaddusb_xmm_k1z_xmm_xmmm128
public Code EVEX_Vpaddusb_ymm_k1z_ymm_ymmm256
public Code EVEX_Vpaddusb_zmm_k1z_zmm_zmmm512
public Code Paddusw_mm_mmm64
public Code Paddusw_xmm_xmmm128
public Code VEX_Vpaddusw_xmm_xmm_xmmm128
public Code VEX_Vpaddusw_ymm_ymm_ymmm256
public Code EVEX_Vpaddusw_xmm_k1z_xmm_xmmm128
public Code EVEX_Vpaddusw_ymm_k1z_ymm_ymmm256
public Code EVEX_Vpaddusw_zmm_k1z_zmm_zmmm512
public Code Pmaxub_mm_mmm64
public Code Pmaxub_xmm_xmmm128
public Code VEX_Vpmaxub_xmm_xmm_xmmm128
public Code VEX_Vpmaxub_ymm_ymm_ymmm256
public Code EVEX_Vpmaxub_xmm_k1z_xmm_xmmm128
public Code EVEX_Vpmaxub_ymm_k1z_ymm_ymmm256
public Code EVEX_Vpmaxub_zmm_k1z_zmm_zmmm512
public Code Pandn_mm_mmm64
public Code Pandn_xmm_xmmm128
public Code VEX_Vpandn_xmm_xmm_xmmm128
public Code VEX_Vpandn_ymm_ymm_ymmm256
public Code EVEX_Vpandnd_xmm_k1z_xmm_xmmm128b32
public Code EVEX_Vpandnd_ymm_k1z_ymm_ymmm256b32
public Code EVEX_Vpandnd_zmm_k1z_zmm_zmmm512b32
public Code EVEX_Vpandnq_xmm_k1z_xmm_xmmm128b64
public Code EVEX_Vpandnq_ymm_k1z_ymm_ymmm256b64
public Code EVEX_Vpandnq_zmm_k1z_zmm_zmmm512b64
public Code Pavgb_mm_mmm64
public Code Pavgb_xmm_xmmm128
public Code VEX_Vpavgb_xmm_xmm_xmmm128
public Code VEX_Vpavgb_ymm_ymm_ymmm256
public Code EVEX_Vpavgb_xmm_k1z_xmm_xmmm128
public Code EVEX_Vpavgb_ymm_k1z_ymm_ymmm256
public Code EVEX_Vpavgb_zmm_k1z_zmm_zmmm512
public Code Psraw_mm_mmm64
public Code Psraw_xmm_xmmm128
public Code VEX_Vpsraw_xmm_xmm_xmmm128
public Code VEX_Vpsraw_ymm_ymm_xmmm128
public Code EVEX_Vpsraw_xmm_k1z_xmm_xmmm128
public Code EVEX_Vpsraw_ymm_k1z_ymm_xmmm128
public Code EVEX_Vpsraw_zmm_k1z_zmm_xmmm128
public Code Psrad_mm_mmm64
public Code Psrad_xmm_xmmm128
public Code VEX_Vpsrad_xmm_xmm_xmmm128
public Code VEX_Vpsrad_ymm_ymm_xmmm128
public Code EVEX_Vpsrad_xmm_k1z_xmm_xmmm128
public Code EVEX_Vpsrad_ymm_k1z_ymm_xmmm128
public Code EVEX_Vpsrad_zmm_k1z_zmm_xmmm128
public Code EVEX_Vpsraq_xmm_k1z_xmm_xmmm128
public Code EVEX_Vpsraq_ymm_k1z_ymm_xmmm128
public Code EVEX_Vpsraq_zmm_k1z_zmm_xmmm128
public Code Pavgw_mm_mmm64
public Code Pavgw_xmm_xmmm128
public Code VEX_Vpavgw_xmm_xmm_xmmm128
public Code VEX_Vpavgw_ymm_ymm_ymmm256
public Code EVEX_Vpavgw_xmm_k1z_xmm_xmmm128
public Code EVEX_Vpavgw_ymm_k1z_ymm_ymmm256
public Code EVEX_Vpavgw_zmm_k1z_zmm_zmmm512
public Code Pmulhuw_mm_mmm64
public Code Pmulhuw_xmm_xmmm128
public Code VEX_Vpmulhuw_xmm_xmm_xmmm128
public Code VEX_Vpmulhuw_ymm_ymm_ymmm256
public Code EVEX_Vpmulhuw_xmm_k1z_xmm_xmmm128
public Code EVEX_Vpmulhuw_ymm_k1z_ymm_ymmm256
public Code EVEX_Vpmulhuw_zmm_k1z_zmm_zmmm512
public Code Pmulhw_mm_mmm64
public Code Pmulhw_xmm_xmmm128
public Code VEX_Vpmulhw_xmm_xmm_xmmm128
public Code VEX_Vpmulhw_ymm_ymm_ymmm256
public Code EVEX_Vpmulhw_xmm_k1z_xmm_xmmm128
public Code EVEX_Vpmulhw_ymm_k1z_ymm_ymmm256
public Code EVEX_Vpmulhw_zmm_k1z_zmm_zmmm512
public Code Cvttpd2dq_xmm_xmmm128
public Code VEX_Vcvttpd2dq_xmm_xmmm128
public Code VEX_Vcvttpd2dq_xmm_ymmm256
public Code EVEX_Vcvttpd2dq_xmm_k1z_xmmm128b64
public Code EVEX_Vcvttpd2dq_xmm_k1z_ymmm256b64
public Code EVEX_Vcvttpd2dq_ymm_k1z_zmmm512b64_sae
public Code Cvtdq2pd_xmm_xmmm64
public Code VEX_Vcvtdq2pd_xmm_xmmm64
public Code VEX_Vcvtdq2pd_ymm_xmmm128
public Code EVEX_Vcvtdq2pd_xmm_k1z_xmmm64b32
public Code EVEX_Vcvtdq2pd_ymm_k1z_xmmm128b32
public Code EVEX_Vcvtdq2pd_zmm_k1z_ymmm256b32_er
public Code EVEX_Vcvtqq2pd_xmm_k1z_xmmm128b64
public Code EVEX_Vcvtqq2pd_ymm_k1z_ymmm256b64
public Code EVEX_Vcvtqq2pd_zmm_k1z_zmmm512b64_er
public Code Cvtpd2dq_xmm_xmmm128
public Code VEX_Vcvtpd2dq_xmm_xmmm128
public Code VEX_Vcvtpd2dq_xmm_ymmm256
public Code EVEX_Vcvtpd2dq_xmm_k1z_xmmm128b64
public Code EVEX_Vcvtpd2dq_xmm_k1z_ymmm256b64
public Code EVEX_Vcvtpd2dq_ymm_k1z_zmmm512b64_er
public Code Movntq_m64_mm
public Code Movntdq_m128_xmm
public Code VEX_Vmovntdq_m128_xmm
public Code VEX_Vmovntdq_m256_ymm
public Code EVEX_Vmovntdq_m128_xmm
public Code EVEX_Vmovntdq_m256_ymm
public Code EVEX_Vmovntdq_m512_zmm
public Code Psubsb_mm_mmm64
public Code Psubsb_xmm_xmmm128
public Code VEX_Vpsubsb_xmm_xmm_xmmm128
public Code VEX_Vpsubsb_ymm_ymm_ymmm256
public Code EVEX_Vpsubsb_xmm_k1z_xmm_xmmm128
public Code EVEX_Vpsubsb_ymm_k1z_ymm_ymmm256
public Code EVEX_Vpsubsb_zmm_k1z_zmm_zmmm512
public Code Psubsw_mm_mmm64
public Code Psubsw_xmm_xmmm128
public Code VEX_Vpsubsw_xmm_xmm_xmmm128
public Code VEX_Vpsubsw_ymm_ymm_ymmm256
public Code EVEX_Vpsubsw_xmm_k1z_xmm_xmmm128
public Code EVEX_Vpsubsw_ymm_k1z_ymm_ymmm256
public Code EVEX_Vpsubsw_zmm_k1z_zmm_zmmm512
public Code Pminsw_mm_mmm64
public Code Pminsw_xmm_xmmm128
public Code VEX_Vpminsw_xmm_xmm_xmmm128
public Code VEX_Vpminsw_ymm_ymm_ymmm256
public Code EVEX_Vpminsw_xmm_k1z_xmm_xmmm128
public Code EVEX_Vpminsw_ymm_k1z_ymm_ymmm256
public Code EVEX_Vpminsw_zmm_k1z_zmm_zmmm512
public Code Por_mm_mmm64
public Code Por_xmm_xmmm128
public Code VEX_Vpor_xmm_xmm_xmmm128
public Code VEX_Vpor_ymm_ymm_ymmm256
public Code EVEX_Vpord_xmm_k1z_xmm_xmmm128b32
public Code EVEX_Vpord_ymm_k1z_ymm_ymmm256b32
public Code EVEX_Vpord_zmm_k1z_zmm_zmmm512b32
public Code EVEX_Vporq_xmm_k1z_xmm_xmmm128b64
public Code EVEX_Vporq_ymm_k1z_ymm_ymmm256b64
public Code EVEX_Vporq_zmm_k1z_zmm_zmmm512b64
public Code Paddsb_mm_mmm64
public Code Paddsb_xmm_xmmm128
public Code VEX_Vpaddsb_xmm_xmm_xmmm128
public Code VEX_Vpaddsb_ymm_ymm_ymmm256
public Code EVEX_Vpaddsb_xmm_k1z_xmm_xmmm128
public Code EVEX_Vpaddsb_ymm_k1z_ymm_ymmm256
public Code EVEX_Vpaddsb_zmm_k1z_zmm_zmmm512
public Code Paddsw_mm_mmm64
public Code Paddsw_xmm_xmmm128
public Code VEX_Vpaddsw_xmm_xmm_xmmm128
public Code VEX_Vpaddsw_ymm_ymm_ymmm256
public Code EVEX_Vpaddsw_xmm_k1z_xmm_xmmm128
public Code EVEX_Vpaddsw_ymm_k1z_ymm_ymmm256
public Code EVEX_Vpaddsw_zmm_k1z_zmm_zmmm512
public Code Pmaxsw_mm_mmm64
public Code Pmaxsw_xmm_xmmm128
public Code VEX_Vpmaxsw_xmm_xmm_xmmm128
public Code VEX_Vpmaxsw_ymm_ymm_ymmm256
public Code EVEX_Vpmaxsw_xmm_k1z_xmm_xmmm128
public Code EVEX_Vpmaxsw_ymm_k1z_ymm_ymmm256
public Code EVEX_Vpmaxsw_zmm_k1z_zmm_zmmm512
public Code Pxor_mm_mmm64
public Code Pxor_xmm_xmmm128
public Code VEX_Vpxor_xmm_xmm_xmmm128
public Code VEX_Vpxor_ymm_ymm_ymmm256
public Code EVEX_Vpxord_xmm_k1z_xmm_xmmm128b32
public Code EVEX_Vpxord_ymm_k1z_ymm_ymmm256b32
public Code EVEX_Vpxord_zmm_k1z_zmm_zmmm512b32
public Code EVEX_Vpxorq_xmm_k1z_xmm_xmmm128b64
public Code EVEX_Vpxorq_ymm_k1z_ymm_ymmm256b64
public Code EVEX_Vpxorq_zmm_k1z_zmm_zmmm512b64
public Code Lddqu_xmm_m128
public Code VEX_Vlddqu_xmm_m128
public Code VEX_Vlddqu_ymm_m256
public Code Psllw_mm_mmm64
public Code Psllw_xmm_xmmm128
public Code VEX_Vpsllw_xmm_xmm_xmmm128
public Code VEX_Vpsllw_ymm_ymm_xmmm128
public Code EVEX_Vpsllw_xmm_k1z_xmm_xmmm128
public Code EVEX_Vpsllw_ymm_k1z_ymm_xmmm128
public Code EVEX_Vpsllw_zmm_k1z_zmm_xmmm128
public Code Pslld_mm_mmm64
public Code Pslld_xmm_xmmm128
public Code VEX_Vpslld_xmm_xmm_xmmm128
public Code VEX_Vpslld_ymm_ymm_xmmm128
public Code EVEX_Vpslld_xmm_k1z_xmm_xmmm128
public Code EVEX_Vpslld_ymm_k1z_ymm_xmmm128
public Code EVEX_Vpslld_zmm_k1z_zmm_xmmm128
public Code Psllq_mm_mmm64
public Code Psllq_xmm_xmmm128
public Code VEX_Vpsllq_xmm_xmm_xmmm128
public Code VEX_Vpsllq_ymm_ymm_xmmm128
public Code EVEX_Vpsllq_xmm_k1z_xmm_xmmm128
public Code EVEX_Vpsllq_ymm_k1z_ymm_xmmm128
public Code EVEX_Vpsllq_zmm_k1z_zmm_xmmm128
public Code Pmuludq_mm_mmm64
public Code Pmuludq_xmm_xmmm128
public Code VEX_Vpmuludq_xmm_xmm_xmmm128
public Code VEX_Vpmuludq_ymm_ymm_ymmm256
public Code EVEX_Vpmuludq_xmm_k1z_xmm_xmmm128b64
public Code EVEX_Vpmuludq_ymm_k1z_ymm_ymmm256b64
public Code EVEX_Vpmuludq_zmm_k1z_zmm_zmmm512b64
public Code Pmaddwd_mm_mmm64
public Code Pmaddwd_xmm_xmmm128
public Code VEX_Vpmaddwd_xmm_xmm_xmmm128
public Code VEX_Vpmaddwd_ymm_ymm_ymmm256
public Code EVEX_Vpmaddwd_xmm_k1z_xmm_xmmm128
public Code EVEX_Vpmaddwd_ymm_k1z_ymm_ymmm256
public Code EVEX_Vpmaddwd_zmm_k1z_zmm_zmmm512
public Code Psadbw_mm_mmm64
public Code Psadbw_xmm_xmmm128
public Code VEX_Vpsadbw_xmm_xmm_xmmm128
public Code VEX_Vpsadbw_ymm_ymm_ymmm256
public Code EVEX_Vpsadbw_xmm_xmm_xmmm128
public Code EVEX_Vpsadbw_ymm_ymm_ymmm256
public Code EVEX_Vpsadbw_zmm_zmm_zmmm512
public Code Maskmovq_rDI_mm_mm
public Code Maskmovdqu_rDI_xmm_xmm
public Code VEX_Vmaskmovdqu_rDI_xmm_xmm
public Code Psubb_mm_mmm64
public Code Psubb_xmm_xmmm128
public Code VEX_Vpsubb_xmm_xmm_xmmm128
public Code VEX_Vpsubb_ymm_ymm_ymmm256
public Code EVEX_Vpsubb_xmm_k1z_xmm_xmmm128
public Code EVEX_Vpsubb_ymm_k1z_ymm_ymmm256
public Code EVEX_Vpsubb_zmm_k1z_zmm_zmmm512
public Code Psubw_mm_mmm64
public Code Psubw_xmm_xmmm128
public Code VEX_Vpsubw_xmm_xmm_xmmm128
public Code VEX_Vpsubw_ymm_ymm_ymmm256
public Code EVEX_Vpsubw_xmm_k1z_xmm_xmmm128
public Code EVEX_Vpsubw_ymm_k1z_ymm_ymmm256
public Code EVEX_Vpsubw_zmm_k1z_zmm_zmmm512
public Code Psubd_mm_mmm64
public Code Psubd_xmm_xmmm128
public Code VEX_Vpsubd_xmm_xmm_xmmm128
public Code VEX_Vpsubd_ymm_ymm_ymmm256
public Code EVEX_Vpsubd_xmm_k1z_xmm_xmmm128b32
public Code EVEX_Vpsubd_ymm_k1z_ymm_ymmm256b32
public Code EVEX_Vpsubd_zmm_k1z_zmm_zmmm512b32
public Code Psubq_mm_mmm64
public Code Psubq_xmm_xmmm128
public Code VEX_Vpsubq_xmm_xmm_xmmm128
public Code VEX_Vpsubq_ymm_ymm_ymmm256
public Code EVEX_Vpsubq_xmm_k1z_xmm_xmmm128b64
public Code EVEX_Vpsubq_ymm_k1z_ymm_ymmm256b64
public Code EVEX_Vpsubq_zmm_k1z_zmm_zmmm512b64
public Code Paddb_mm_mmm64
public Code Paddb_xmm_xmmm128
public Code VEX_Vpaddb_xmm_xmm_xmmm128
public Code VEX_Vpaddb_ymm_ymm_ymmm256
public Code EVEX_Vpaddb_xmm_k1z_xmm_xmmm128
public Code EVEX_Vpaddb_ymm_k1z_ymm_ymmm256
public Code EVEX_Vpaddb_zmm_k1z_zmm_zmmm512
public Code Paddw_mm_mmm64
public Code Paddw_xmm_xmmm128
public Code VEX_Vpaddw_xmm_xmm_xmmm128
public Code VEX_Vpaddw_ymm_ymm_ymmm256
public Code EVEX_Vpaddw_xmm_k1z_xmm_xmmm128
public Code EVEX_Vpaddw_ymm_k1z_ymm_ymmm256
public Code EVEX_Vpaddw_zmm_k1z_zmm_zmmm512
public Code Paddd_mm_mmm64
public Code Paddd_xmm_xmmm128
public Code VEX_Vpaddd_xmm_xmm_xmmm128
public Code VEX_Vpaddd_ymm_ymm_ymmm256
public Code EVEX_Vpaddd_xmm_k1z_xmm_xmmm128b32
public Code EVEX_Vpaddd_ymm_k1z_ymm_ymmm256b32
public Code EVEX_Vpaddd_zmm_k1z_zmm_zmmm512b32
public Code Ud0_r16_rm16
public Code Ud0_r32_rm32
public Code Ud0_r64_rm64
public Code Pshufb_mm_mmm64
public Code Pshufb_xmm_xmmm128
public Code VEX_Vpshufb_xmm_xmm_xmmm128
public Code VEX_Vpshufb_ymm_ymm_ymmm256
public Code EVEX_Vpshufb_xmm_k1z_xmm_xmmm128
public Code EVEX_Vpshufb_ymm_k1z_ymm_ymmm256
public Code EVEX_Vpshufb_zmm_k1z_zmm_zmmm512
public Code Phaddw_mm_mmm64
public Code Phaddw_xmm_xmmm128
public Code VEX_Vphaddw_xmm_xmm_xmmm128
public Code VEX_Vphaddw_ymm_ymm_ymmm256
public Code Phaddd_mm_mmm64
public Code Phaddd_xmm_xmmm128
public Code VEX_Vphaddd_xmm_xmm_xmmm128
public Code VEX_Vphaddd_ymm_ymm_ymmm256
public Code Phaddsw_mm_mmm64
public Code Phaddsw_xmm_xmmm128
public Code VEX_Vphaddsw_xmm_xmm_xmmm128
public Code VEX_Vphaddsw_ymm_ymm_ymmm256
public Code Pmaddubsw_mm_mmm64
public Code Pmaddubsw_xmm_xmmm128
public Code VEX_Vpmaddubsw_xmm_xmm_xmmm128
public Code VEX_Vpmaddubsw_ymm_ymm_ymmm256
public Code EVEX_Vpmaddubsw_xmm_k1z_xmm_xmmm128
public Code EVEX_Vpmaddubsw_ymm_k1z_ymm_ymmm256
public Code EVEX_Vpmaddubsw_zmm_k1z_zmm_zmmm512
public Code Phsubw_mm_mmm64
public Code Phsubw_xmm_xmmm128
public Code VEX_Vphsubw_xmm_xmm_xmmm128
public Code VEX_Vphsubw_ymm_ymm_ymmm256
public Code Phsubd_mm_mmm64
public Code Phsubd_xmm_xmmm128
public Code VEX_Vphsubd_xmm_xmm_xmmm128
public Code VEX_Vphsubd_ymm_ymm_ymmm256
public Code Phsubsw_mm_mmm64
public Code Phsubsw_xmm_xmmm128
public Code VEX_Vphsubsw_xmm_xmm_xmmm128
public Code VEX_Vphsubsw_ymm_ymm_ymmm256
public Code Psignb_mm_mmm64
public Code Psignb_xmm_xmmm128
public Code VEX_Vpsignb_xmm_xmm_xmmm128
public Code VEX_Vpsignb_ymm_ymm_ymmm256
public Code Psignw_mm_mmm64
public Code Psignw_xmm_xmmm128
public Code VEX_Vpsignw_xmm_xmm_xmmm128
public Code VEX_Vpsignw_ymm_ymm_ymmm256
public Code Psignd_mm_mmm64
public Code Psignd_xmm_xmmm128
public Code VEX_Vpsignd_xmm_xmm_xmmm128
public Code VEX_Vpsignd_ymm_ymm_ymmm256
public Code Pmulhrsw_mm_mmm64
public Code Pmulhrsw_xmm_xmmm128
public Code VEX_Vpmulhrsw_xmm_xmm_xmmm128
public Code VEX_Vpmulhrsw_ymm_ymm_ymmm256
public Code EVEX_Vpmulhrsw_xmm_k1z_xmm_xmmm128
public Code EVEX_Vpmulhrsw_ymm_k1z_ymm_ymmm256
public Code EVEX_Vpmulhrsw_zmm_k1z_zmm_zmmm512
public Code VEX_Vpermilps_xmm_xmm_xmmm128
public Code VEX_Vpermilps_ymm_ymm_ymmm256
public Code EVEX_Vpermilps_xmm_k1z_xmm_xmmm128b32
public Code EVEX_Vpermilps_ymm_k1z_ymm_ymmm256b32
public Code EVEX_Vpermilps_zmm_k1z_zmm_zmmm512b32
public Code VEX_Vpermilpd_xmm_xmm_xmmm128
public Code VEX_Vpermilpd_ymm_ymm_ymmm256
public Code EVEX_Vpermilpd_xmm_k1z_xmm_xmmm128b64
public Code EVEX_Vpermilpd_ymm_k1z_ymm_ymmm256b64
public Code EVEX_Vpermilpd_zmm_k1z_zmm_zmmm512b64
public Code VEX_Vtestps_xmm_xmmm128
public Code VEX_Vtestps_ymm_ymmm256
public Code VEX_Vtestpd_xmm_xmmm128
public Code VEX_Vtestpd_ymm_ymmm256
public Code Pblendvb_xmm_xmmm128
public Code EVEX_Vpsrlvw_xmm_k1z_xmm_xmmm128
public Code EVEX_Vpsrlvw_ymm_k1z_ymm_ymmm256
public Code EVEX_Vpsrlvw_zmm_k1z_zmm_zmmm512
public Code EVEX_Vpmovuswb_xmmm64_k1z_xmm
public Code EVEX_Vpmovuswb_xmmm128_k1z_ymm
public Code EVEX_Vpmovuswb_ymmm256_k1z_zmm
public Code EVEX_Vpsravw_xmm_k1z_xmm_xmmm128
public Code EVEX_Vpsravw_ymm_k1z_ymm_ymmm256
public Code EVEX_Vpsravw_zmm_k1z_zmm_zmmm512
public Code EVEX_Vpmovusdb_xmmm32_k1z_xmm
public Code EVEX_Vpmovusdb_xmmm64_k1z_ymm
public Code EVEX_Vpmovusdb_xmmm128_k1z_zmm
public Code EVEX_Vpsllvw_xmm_k1z_xmm_xmmm128
public Code EVEX_Vpsllvw_ymm_k1z_ymm_ymmm256
public Code EVEX_Vpsllvw_zmm_k1z_zmm_zmmm512
public Code EVEX_Vpmovusqb_xmmm16_k1z_xmm
public Code EVEX_Vpmovusqb_xmmm32_k1z_ymm
public Code EVEX_Vpmovusqb_xmmm64_k1z_zmm
public Code VEX_Vcvtph2ps_xmm_xmmm64
public Code VEX_Vcvtph2ps_ymm_xmmm128
public Code EVEX_Vcvtph2ps_xmm_k1z_xmmm64
public Code EVEX_Vcvtph2ps_ymm_k1z_xmmm128
public Code EVEX_Vcvtph2ps_zmm_k1z_ymmm256_sae
public Code EVEX_Vpmovusdw_xmmm64_k1z_xmm
public Code EVEX_Vpmovusdw_xmmm128_k1z_ymm
public Code EVEX_Vpmovusdw_ymmm256_k1z_zmm
public Code Blendvps_xmm_xmmm128
public Code EVEX_Vprorvd_xmm_k1z_xmm_xmmm128b32
public Code EVEX_Vprorvd_ymm_k1z_ymm_ymmm256b32
public Code EVEX_Vprorvd_zmm_k1z_zmm_zmmm512b32
public Code EVEX_Vprorvq_xmm_k1z_xmm_xmmm128b64
public Code EVEX_Vprorvq_ymm_k1z_ymm_ymmm256b64
public Code EVEX_Vprorvq_zmm_k1z_zmm_zmmm512b64
public Code EVEX_Vpmovusqw_xmmm32_k1z_xmm
public Code EVEX_Vpmovusqw_xmmm64_k1z_ymm
public Code EVEX_Vpmovusqw_xmmm128_k1z_zmm
public Code Blendvpd_xmm_xmmm128
public Code EVEX_Vprolvd_xmm_k1z_xmm_xmmm128b32
public Code EVEX_Vprolvd_ymm_k1z_ymm_ymmm256b32
public Code EVEX_Vprolvd_zmm_k1z_zmm_zmmm512b32
public Code EVEX_Vprolvq_xmm_k1z_xmm_xmmm128b64
public Code EVEX_Vprolvq_ymm_k1z_ymm_ymmm256b64
public Code EVEX_Vprolvq_zmm_k1z_zmm_zmmm512b64
public Code EVEX_Vpmovusqd_xmmm64_k1z_xmm
public Code EVEX_Vpmovusqd_xmmm128_k1z_ymm
public Code EVEX_Vpmovusqd_ymmm256_k1z_zmm
public Code VEX_Vpermps_ymm_ymm_ymmm256
public Code EVEX_Vpermps_ymm_k1z_ymm_ymmm256b32
public Code EVEX_Vpermps_zmm_k1z_zmm_zmmm512b32
public Code EVEX_Vpermpd_ymm_k1z_ymm_ymmm256b64
public Code EVEX_Vpermpd_zmm_k1z_zmm_zmmm512b64
public Code Ptest_xmm_xmmm128
public Code VEX_Vptest_xmm_xmmm128
public Code VEX_Vptest_ymm_ymmm256
public Code VEX_Vbroadcastss_xmm_m32
public Code VEX_Vbroadcastss_ymm_m32
public Code EVEX_Vbroadcastss_xmm_k1z_xmmm32
public Code EVEX_Vbroadcastss_ymm_k1z_xmmm32
public Code EVEX_Vbroadcastss_zmm_k1z_xmmm32
public Code VEX_Vbroadcastsd_ymm_m64
public Code EVEX_Vbroadcastf32x2_ymm_k1z_xmmm64
public Code EVEX_Vbroadcastf32x2_zmm_k1z_xmmm64
public Code EVEX_Vbroadcastsd_ymm_k1z_xmmm64
public Code EVEX_Vbroadcastsd_zmm_k1z_xmmm64
public Code VEX_Vbroadcastf128_ymm_m128
public Code EVEX_Vbroadcastf32x4_ymm_k1z_m128
public Code EVEX_Vbroadcastf32x4_zmm_k1z_m128
public Code EVEX_Vbroadcastf64x2_ymm_k1z_m128
public Code EVEX_Vbroadcastf64x2_zmm_k1z_m128
public Code EVEX_Vbroadcastf32x8_zmm_k1z_m256
public Code EVEX_Vbroadcastf64x4_zmm_k1z_m256
public Code Pabsb_mm_mmm64
public Code Pabsb_xmm_xmmm128
public Code VEX_Vpabsb_xmm_xmmm128
public Code VEX_Vpabsb_ymm_ymmm256
public Code EVEX_Vpabsb_xmm_k1z_xmmm128
public Code EVEX_Vpabsb_ymm_k1z_ymmm256
public Code EVEX_Vpabsb_zmm_k1z_zmmm512
public Code Pabsw_mm_mmm64
public Code Pabsw_xmm_xmmm128
public Code VEX_Vpabsw_xmm_xmmm128
public Code VEX_Vpabsw_ymm_ymmm256
public Code EVEX_Vpabsw_xmm_k1z_xmmm128
public Code EVEX_Vpabsw_ymm_k1z_ymmm256
public Code EVEX_Vpabsw_zmm_k1z_zmmm512
public Code Pabsd_mm_mmm64
public Code Pabsd_xmm_xmmm128
public Code VEX_Vpabsd_xmm_xmmm128
public Code VEX_Vpabsd_ymm_ymmm256
public Code EVEX_Vpabsd_xmm_k1z_xmmm128b32
public Code EVEX_Vpabsd_ymm_k1z_ymmm256b32
public Code EVEX_Vpabsd_zmm_k1z_zmmm512b32
public Code EVEX_Vpabsq_xmm_k1z_xmmm128b64
public Code EVEX_Vpabsq_ymm_k1z_ymmm256b64
public Code EVEX_Vpabsq_zmm_k1z_zmmm512b64
public Code Pmovsxbw_xmm_xmmm64
public Code VEX_Vpmovsxbw_xmm_xmmm64
public Code VEX_Vpmovsxbw_ymm_xmmm128
public Code EVEX_Vpmovsxbw_xmm_k1z_xmmm64
public Code EVEX_Vpmovsxbw_ymm_k1z_xmmm128
public Code EVEX_Vpmovsxbw_zmm_k1z_ymmm256
public Code EVEX_Vpmovswb_xmmm64_k1z_xmm
public Code EVEX_Vpmovswb_xmmm128_k1z_ymm
public Code EVEX_Vpmovswb_ymmm256_k1z_zmm
public Code Pmovsxbd_xmm_xmmm32
public Code VEX_Vpmovsxbd_xmm_xmmm32
public Code VEX_Vpmovsxbd_ymm_xmmm64
public Code EVEX_Vpmovsxbd_xmm_k1z_xmmm32
public Code EVEX_Vpmovsxbd_ymm_k1z_xmmm64
public Code EVEX_Vpmovsxbd_zmm_k1z_xmmm128
public Code EVEX_Vpmovsdb_xmmm32_k1z_xmm
public Code EVEX_Vpmovsdb_xmmm64_k1z_ymm
public Code EVEX_Vpmovsdb_xmmm128_k1z_zmm
public Code Pmovsxbq_xmm_xmmm16
public Code VEX_Vpmovsxbq_xmm_xmmm16
public Code VEX_Vpmovsxbq_ymm_xmmm32
public Code EVEX_Vpmovsxbq_xmm_k1z_xmmm16
public Code EVEX_Vpmovsxbq_ymm_k1z_xmmm32
public Code EVEX_Vpmovsxbq_zmm_k1z_xmmm64
public Code EVEX_Vpmovsqb_xmmm16_k1z_xmm
public Code EVEX_Vpmovsqb_xmmm32_k1z_ymm
public Code EVEX_Vpmovsqb_xmmm64_k1z_zmm
public Code Pmovsxwd_xmm_xmmm64
public Code VEX_Vpmovsxwd_xmm_xmmm64
public Code VEX_Vpmovsxwd_ymm_xmmm128
public Code EVEX_Vpmovsxwd_xmm_k1z_xmmm64
public Code EVEX_Vpmovsxwd_ymm_k1z_xmmm128
public Code EVEX_Vpmovsxwd_zmm_k1z_ymmm256
public Code EVEX_Vpmovsdw_xmmm64_k1z_xmm
public Code EVEX_Vpmovsdw_xmmm128_k1z_ymm
public Code EVEX_Vpmovsdw_ymmm256_k1z_zmm
public Code Pmovsxwq_xmm_xmmm32
public Code VEX_Vpmovsxwq_xmm_xmmm32
public Code VEX_Vpmovsxwq_ymm_xmmm64
public Code EVEX_Vpmovsxwq_xmm_k1z_xmmm32
public Code EVEX_Vpmovsxwq_ymm_k1z_xmmm64
public Code EVEX_Vpmovsxwq_zmm_k1z_xmmm128
public Code EVEX_Vpmovsqw_xmmm32_k1z_xmm
public Code EVEX_Vpmovsqw_xmmm64_k1z_ymm
public Code EVEX_Vpmovsqw_xmmm128_k1z_zmm
public Code Pmovsxdq_xmm_xmmm64
public Code VEX_Vpmovsxdq_xmm_xmmm64
public Code VEX_Vpmovsxdq_ymm_xmmm128
public Code EVEX_Vpmovsxdq_xmm_k1z_xmmm64
public Code EVEX_Vpmovsxdq_ymm_k1z_xmmm128
public Code EVEX_Vpmovsxdq_zmm_k1z_ymmm256
public Code EVEX_Vpmovsqd_xmmm64_k1z_xmm
public Code EVEX_Vpmovsqd_xmmm128_k1z_ymm
public Code EVEX_Vpmovsqd_ymmm256_k1z_zmm
public Code EVEX_Vptestmb_kr_k1_xmm_xmmm128
public Code EVEX_Vptestmb_kr_k1_ymm_ymmm256
public Code EVEX_Vptestmb_kr_k1_zmm_zmmm512
public Code EVEX_Vptestmw_kr_k1_xmm_xmmm128
public Code EVEX_Vptestmw_kr_k1_ymm_ymmm256
public Code EVEX_Vptestmw_kr_k1_zmm_zmmm512
public Code EVEX_Vptestnmb_kr_k1_xmm_xmmm128
public Code EVEX_Vptestnmb_kr_k1_ymm_ymmm256
public Code EVEX_Vptestnmb_kr_k1_zmm_zmmm512
public Code EVEX_Vptestnmw_kr_k1_xmm_xmmm128
public Code EVEX_Vptestnmw_kr_k1_ymm_ymmm256
public Code EVEX_Vptestnmw_kr_k1_zmm_zmmm512
public Code EVEX_Vptestmd_kr_k1_xmm_xmmm128b32
public Code EVEX_Vptestmd_kr_k1_ymm_ymmm256b32
public Code EVEX_Vptestmd_kr_k1_zmm_zmmm512b32
public Code EVEX_Vptestmq_kr_k1_xmm_xmmm128b64
public Code EVEX_Vptestmq_kr_k1_ymm_ymmm256b64
public Code EVEX_Vptestmq_kr_k1_zmm_zmmm512b64
public Code EVEX_Vptestnmd_kr_k1_xmm_xmmm128b32
public Code EVEX_Vptestnmd_kr_k1_ymm_ymmm256b32
public Code EVEX_Vptestnmd_kr_k1_zmm_zmmm512b32
public Code EVEX_Vptestnmq_kr_k1_xmm_xmmm128b64
public Code EVEX_Vptestnmq_kr_k1_ymm_ymmm256b64
public Code EVEX_Vptestnmq_kr_k1_zmm_zmmm512b64
public Code Pmuldq_xmm_xmmm128
public Code VEX_Vpmuldq_xmm_xmm_xmmm128
public Code VEX_Vpmuldq_ymm_ymm_ymmm256
public Code EVEX_Vpmuldq_xmm_k1z_xmm_xmmm128b64
public Code EVEX_Vpmuldq_ymm_k1z_ymm_ymmm256b64
public Code EVEX_Vpmuldq_zmm_k1z_zmm_zmmm512b64
public Code EVEX_Vpmovm2b_xmm_kr
public Code EVEX_Vpmovm2b_ymm_kr
public Code EVEX_Vpmovm2b_zmm_kr
public Code EVEX_Vpmovm2w_xmm_kr
public Code EVEX_Vpmovm2w_ymm_kr
public Code EVEX_Vpmovm2w_zmm_kr
public Code Pcmpeqq_xmm_xmmm128
public Code VEX_Vpcmpeqq_xmm_xmm_xmmm128
public Code VEX_Vpcmpeqq_ymm_ymm_ymmm256
public Code EVEX_Vpcmpeqq_kr_k1_xmm_xmmm128b64
public Code EVEX_Vpcmpeqq_kr_k1_ymm_ymmm256b64
public Code EVEX_Vpcmpeqq_kr_k1_zmm_zmmm512b64
public Code EVEX_Vpmovb2m_kr_xmm
public Code EVEX_Vpmovb2m_kr_ymm
public Code EVEX_Vpmovb2m_kr_zmm
public Code EVEX_Vpmovw2m_kr_xmm
public Code EVEX_Vpmovw2m_kr_ymm
public Code EVEX_Vpmovw2m_kr_zmm
public Code Movntdqa_xmm_m128
public Code VEX_Vmovntdqa_xmm_m128
public Code VEX_Vmovntdqa_ymm_m256
public Code EVEX_Vmovntdqa_xmm_m128
public Code EVEX_Vmovntdqa_ymm_m256
public Code EVEX_Vmovntdqa_zmm_m512
public Code EVEX_Vpbroadcastmb2q_xmm_kr
public Code EVEX_Vpbroadcastmb2q_ymm_kr
public Code EVEX_Vpbroadcastmb2q_zmm_kr
public Code Packusdw_xmm_xmmm128
public Code VEX_Vpackusdw_xmm_xmm_xmmm128
public Code VEX_Vpackusdw_ymm_ymm_ymmm256
public Code EVEX_Vpackusdw_xmm_k1z_xmm_xmmm128b32
public Code EVEX_Vpackusdw_ymm_k1z_ymm_ymmm256b32
public Code EVEX_Vpackusdw_zmm_k1z_zmm_zmmm512b32
public Code VEX_Vmaskmovps_xmm_xmm_m128
public Code VEX_Vmaskmovps_ymm_ymm_m256
public Code EVEX_Vscalefps_xmm_k1z_xmm_xmmm128b32
public Code EVEX_Vscalefps_ymm_k1z_ymm_ymmm256b32
public Code EVEX_Vscalefps_zmm_k1z_zmm_zmmm512b32_er
public Code EVEX_Vscalefpd_xmm_k1z_xmm_xmmm128b64
public Code EVEX_Vscalefpd_ymm_k1z_ymm_ymmm256b64
public Code EVEX_Vscalefpd_zmm_k1z_zmm_zmmm512b64_er
public Code VEX_Vmaskmovpd_xmm_xmm_m128
public Code VEX_Vmaskmovpd_ymm_ymm_m256
public Code EVEX_Vscalefss_xmm_k1z_xmm_xmmm32_er
public Code EVEX_Vscalefsd_xmm_k1z_xmm_xmmm64_er
public Code VEX_Vmaskmovps_m128_xmm_xmm
public Code VEX_Vmaskmovps_m256_ymm_ymm
public Code VEX_Vmaskmovpd_m128_xmm_xmm
public Code VEX_Vmaskmovpd_m256_ymm_ymm
public Code Pmovzxbw_xmm_xmmm64
public Code VEX_Vpmovzxbw_xmm_xmmm64
public Code VEX_Vpmovzxbw_ymm_xmmm128
public Code EVEX_Vpmovzxbw_xmm_k1z_xmmm64
public Code EVEX_Vpmovzxbw_ymm_k1z_xmmm128
public Code EVEX_Vpmovzxbw_zmm_k1z_ymmm256
public Code EVEX_Vpmovwb_xmmm64_k1z_xmm
public Code EVEX_Vpmovwb_xmmm128_k1z_ymm
public Code EVEX_Vpmovwb_ymmm256_k1z_zmm
public Code Pmovzxbd_xmm_xmmm32
public Code VEX_Vpmovzxbd_xmm_xmmm32
public Code VEX_Vpmovzxbd_ymm_xmmm64
public Code EVEX_Vpmovzxbd_xmm_k1z_xmmm32
public Code EVEX_Vpmovzxbd_ymm_k1z_xmmm64
public Code EVEX_Vpmovzxbd_zmm_k1z_xmmm128
public Code EVEX_Vpmovdb_xmmm32_k1z_xmm
public Code EVEX_Vpmovdb_xmmm64_k1z_ymm
public Code EVEX_Vpmovdb_xmmm128_k1z_zmm
public Code Pmovzxbq_xmm_xmmm16
public Code VEX_Vpmovzxbq_xmm_xmmm16
public Code VEX_Vpmovzxbq_ymm_xmmm32
public Code EVEX_Vpmovzxbq_xmm_k1z_xmmm16
public Code EVEX_Vpmovzxbq_ymm_k1z_xmmm32
public Code EVEX_Vpmovzxbq_zmm_k1z_xmmm64
public Code EVEX_Vpmovqb_xmmm16_k1z_xmm
public Code EVEX_Vpmovqb_xmmm32_k1z_ymm
public Code EVEX_Vpmovqb_xmmm64_k1z_zmm
public Code Pmovzxwd_xmm_xmmm64
public Code VEX_Vpmovzxwd_xmm_xmmm64
public Code VEX_Vpmovzxwd_ymm_xmmm128
public Code EVEX_Vpmovzxwd_xmm_k1z_xmmm64
public Code EVEX_Vpmovzxwd_ymm_k1z_xmmm128
public Code EVEX_Vpmovzxwd_zmm_k1z_ymmm256
public Code EVEX_Vpmovdw_xmmm64_k1z_xmm
public Code EVEX_Vpmovdw_xmmm128_k1z_ymm
public Code EVEX_Vpmovdw_ymmm256_k1z_zmm
public Code Pmovzxwq_xmm_xmmm32
public Code VEX_Vpmovzxwq_xmm_xmmm32
public Code VEX_Vpmovzxwq_ymm_xmmm64
public Code EVEX_Vpmovzxwq_xmm_k1z_xmmm32
public Code EVEX_Vpmovzxwq_ymm_k1z_xmmm64
public Code EVEX_Vpmovzxwq_zmm_k1z_xmmm128
public Code EVEX_Vpmovqw_xmmm32_k1z_xmm
public Code EVEX_Vpmovqw_xmmm64_k1z_ymm
public Code EVEX_Vpmovqw_xmmm128_k1z_zmm
public Code Pmovzxdq_xmm_xmmm64
public Code VEX_Vpmovzxdq_xmm_xmmm64
public Code VEX_Vpmovzxdq_ymm_xmmm128
public Code EVEX_Vpmovzxdq_xmm_k1z_xmmm64
public Code EVEX_Vpmovzxdq_ymm_k1z_xmmm128
public Code EVEX_Vpmovzxdq_zmm_k1z_ymmm256
public Code EVEX_Vpmovqd_xmmm64_k1z_xmm
public Code EVEX_Vpmovqd_xmmm128_k1z_ymm
public Code EVEX_Vpmovqd_ymmm256_k1z_zmm
public Code VEX_Vpermd_ymm_ymm_ymmm256
public Code EVEX_Vpermd_ymm_k1z_ymm_ymmm256b32
public Code EVEX_Vpermd_zmm_k1z_zmm_zmmm512b32
public Code EVEX_Vpermq_ymm_k1z_ymm_ymmm256b64
public Code EVEX_Vpermq_zmm_k1z_zmm_zmmm512b64
public Code Pcmpgtq_xmm_xmmm128
public Code VEX_Vpcmpgtq_xmm_xmm_xmmm128
public Code VEX_Vpcmpgtq_ymm_ymm_ymmm256
public Code EVEX_Vpcmpgtq_kr_k1_xmm_xmmm128b64
public Code EVEX_Vpcmpgtq_kr_k1_ymm_ymmm256b64
public Code EVEX_Vpcmpgtq_kr_k1_zmm_zmmm512b64
public Code Pminsb_xmm_xmmm128
public Code VEX_Vpminsb_xmm_xmm_xmmm128
public Code VEX_Vpminsb_ymm_ymm_ymmm256
public Code EVEX_Vpminsb_xmm_k1z_xmm_xmmm128
public Code EVEX_Vpminsb_ymm_k1z_ymm_ymmm256
public Code EVEX_Vpminsb_zmm_k1z_zmm_zmmm512
public Code EVEX_Vpmovm2d_xmm_kr
public Code EVEX_Vpmovm2d_ymm_kr
public Code EVEX_Vpmovm2d_zmm_kr
public Code EVEX_Vpmovm2q_xmm_kr
public Code EVEX_Vpmovm2q_ymm_kr
public Code EVEX_Vpmovm2q_zmm_kr
public Code Pminsd_xmm_xmmm128
public Code VEX_Vpminsd_xmm_xmm_xmmm128
public Code VEX_Vpminsd_ymm_ymm_ymmm256
public Code EVEX_Vpminsd_xmm_k1z_xmm_xmmm128b32
public Code EVEX_Vpminsd_ymm_k1z_ymm_ymmm256b32
public Code EVEX_Vpminsd_zmm_k1z_zmm_zmmm512b32
public Code EVEX_Vpminsq_xmm_k1z_xmm_xmmm128b64
public Code EVEX_Vpminsq_ymm_k1z_ymm_ymmm256b64
public Code EVEX_Vpminsq_zmm_k1z_zmm_zmmm512b64
public Code EVEX_Vpmovd2m_kr_xmm
public Code EVEX_Vpmovd2m_kr_ymm
public Code EVEX_Vpmovd2m_kr_zmm
public Code EVEX_Vpmovq2m_kr_xmm
public Code EVEX_Vpmovq2m_kr_ymm
public Code EVEX_Vpmovq2m_kr_zmm
public Code Pminuw_xmm_xmmm128
public Code VEX_Vpminuw_xmm_xmm_xmmm128
public Code VEX_Vpminuw_ymm_ymm_ymmm256
public Code EVEX_Vpminuw_xmm_k1z_xmm_xmmm128
public Code EVEX_Vpminuw_ymm_k1z_ymm_ymmm256
public Code EVEX_Vpminuw_zmm_k1z_zmm_zmmm512
public Code EVEX_Vpbroadcastmw2d_xmm_kr
public Code EVEX_Vpbroadcastmw2d_ymm_kr
public Code EVEX_Vpbroadcastmw2d_zmm_kr
public Code Pminud_xmm_xmmm128
public Code VEX_Vpminud_xmm_xmm_xmmm128
public Code VEX_Vpminud_ymm_ymm_ymmm256
public Code EVEX_Vpminud_xmm_k1z_xmm_xmmm128b32
public Code EVEX_Vpminud_ymm_k1z_ymm_ymmm256b32
public Code EVEX_Vpminud_zmm_k1z_zmm_zmmm512b32
public Code EVEX_Vpminuq_xmm_k1z_xmm_xmmm128b64
public Code EVEX_Vpminuq_ymm_k1z_ymm_ymmm256b64
public Code EVEX_Vpminuq_zmm_k1z_zmm_zmmm512b64
public Code Pmaxsb_xmm_xmmm128
public Code VEX_Vpmaxsb_xmm_xmm_xmmm128
public Code VEX_Vpmaxsb_ymm_ymm_ymmm256
public Code EVEX_Vpmaxsb_xmm_k1z_xmm_xmmm128
public Code EVEX_Vpmaxsb_ymm_k1z_ymm_ymmm256
public Code EVEX_Vpmaxsb_zmm_k1z_zmm_zmmm512
public Code Pmaxsd_xmm_xmmm128
public Code VEX_Vpmaxsd_xmm_xmm_xmmm128
public Code VEX_Vpmaxsd_ymm_ymm_ymmm256
public Code EVEX_Vpmaxsd_xmm_k1z_xmm_xmmm128b32
public Code EVEX_Vpmaxsd_ymm_k1z_ymm_ymmm256b32
public Code EVEX_Vpmaxsd_zmm_k1z_zmm_zmmm512b32
public Code EVEX_Vpmaxsq_xmm_k1z_xmm_xmmm128b64
public Code EVEX_Vpmaxsq_ymm_k1z_ymm_ymmm256b64
public Code EVEX_Vpmaxsq_zmm_k1z_zmm_zmmm512b64
public Code Pmaxuw_xmm_xmmm128
public Code VEX_Vpmaxuw_xmm_xmm_xmmm128
public Code VEX_Vpmaxuw_ymm_ymm_ymmm256
public Code EVEX_Vpmaxuw_xmm_k1z_xmm_xmmm128
public Code EVEX_Vpmaxuw_ymm_k1z_ymm_ymmm256
public Code EVEX_Vpmaxuw_zmm_k1z_zmm_zmmm512
public Code Pmaxud_xmm_xmmm128
public Code VEX_Vpmaxud_xmm_xmm_xmmm128
public Code VEX_Vpmaxud_ymm_ymm_ymmm256
public Code EVEX_Vpmaxud_xmm_k1z_xmm_xmmm128b32
public Code EVEX_Vpmaxud_ymm_k1z_ymm_ymmm256b32
public Code EVEX_Vpmaxud_zmm_k1z_zmm_zmmm512b32
public Code EVEX_Vpmaxuq_xmm_k1z_xmm_xmmm128b64
public Code EVEX_Vpmaxuq_ymm_k1z_ymm_ymmm256b64
public Code EVEX_Vpmaxuq_zmm_k1z_zmm_zmmm512b64
public Code Pmulld_xmm_xmmm128
public Code VEX_Vpmulld_xmm_xmm_xmmm128
public Code VEX_Vpmulld_ymm_ymm_ymmm256
public Code EVEX_Vpmulld_xmm_k1z_xmm_xmmm128b32
public Code EVEX_Vpmulld_ymm_k1z_ymm_ymmm256b32
public Code EVEX_Vpmulld_zmm_k1z_zmm_zmmm512b32
public Code EVEX_Vpmullq_xmm_k1z_xmm_xmmm128b64
public Code EVEX_Vpmullq_ymm_k1z_ymm_ymmm256b64
public Code EVEX_Vpmullq_zmm_k1z_zmm_zmmm512b64
public Code Phminposuw_xmm_xmmm128
public Code VEX_Vphminposuw_xmm_xmmm128
public Code EVEX_Vgetexpps_xmm_k1z_xmmm128b32
public Code EVEX_Vgetexpps_ymm_k1z_ymmm256b32
public Code EVEX_Vgetexpps_zmm_k1z_zmmm512b32_sae
public Code EVEX_Vgetexppd_xmm_k1z_xmmm128b64
public Code EVEX_Vgetexppd_ymm_k1z_ymmm256b64
public Code EVEX_Vgetexppd_zmm_k1z_zmmm512b64_sae
public Code EVEX_Vgetexpss_xmm_k1z_xmm_xmmm32_sae
public Code EVEX_Vgetexpsd_xmm_k1z_xmm_xmmm64_sae
public Code EVEX_Vplzcntd_xmm_k1z_xmmm128b32
public Code EVEX_Vplzcntd_ymm_k1z_ymmm256b32
public Code EVEX_Vplzcntd_zmm_k1z_zmmm512b32
public Code EVEX_Vplzcntq_xmm_k1z_xmmm128b64
public Code EVEX_Vplzcntq_ymm_k1z_ymmm256b64
public Code EVEX_Vplzcntq_zmm_k1z_zmmm512b64
public Code VEX_Vpsrlvd_xmm_xmm_xmmm128
public Code VEX_Vpsrlvd_ymm_ymm_ymmm256
public Code VEX_Vpsrlvq_xmm_xmm_xmmm128
public Code VEX_Vpsrlvq_ymm_ymm_ymmm256
public Code EVEX_Vpsrlvd_xmm_k1z_xmm_xmmm128b32
public Code EVEX_Vpsrlvd_ymm_k1z_ymm_ymmm256b32
public Code EVEX_Vpsrlvd_zmm_k1z_zmm_zmmm512b32
public Code EVEX_Vpsrlvq_xmm_k1z_xmm_xmmm128b64
public Code EVEX_Vpsrlvq_ymm_k1z_ymm_ymmm256b64
public Code EVEX_Vpsrlvq_zmm_k1z_zmm_zmmm512b64
public Code VEX_Vpsravd_xmm_xmm_xmmm128
public Code VEX_Vpsravd_ymm_ymm_ymmm256
public Code EVEX_Vpsravd_xmm_k1z_xmm_xmmm128b32
public Code EVEX_Vpsravd_ymm_k1z_ymm_ymmm256b32
public Code EVEX_Vpsravd_zmm_k1z_zmm_zmmm512b32
public Code EVEX_Vpsravq_xmm_k1z_xmm_xmmm128b64
public Code EVEX_Vpsravq_ymm_k1z_ymm_ymmm256b64
public Code EVEX_Vpsravq_zmm_k1z_zmm_zmmm512b64
public Code VEX_Vpsllvd_xmm_xmm_xmmm128
public Code VEX_Vpsllvd_ymm_ymm_ymmm256
public Code VEX_Vpsllvq_xmm_xmm_xmmm128
public Code VEX_Vpsllvq_ymm_ymm_ymmm256
public Code EVEX_Vpsllvd_xmm_k1z_xmm_xmmm128b32
public Code EVEX_Vpsllvd_ymm_k1z_ymm_ymmm256b32
public Code EVEX_Vpsllvd_zmm_k1z_zmm_zmmm512b32
public Code EVEX_Vpsllvq_xmm_k1z_xmm_xmmm128b64
public Code EVEX_Vpsllvq_ymm_k1z_ymm_ymmm256b64
public Code EVEX_Vpsllvq_zmm_k1z_zmm_zmmm512b64
public Code EVEX_Vrcp14ps_xmm_k1z_xmmm128b32
public Code EVEX_Vrcp14ps_ymm_k1z_ymmm256b32
public Code EVEX_Vrcp14ps_zmm_k1z_zmmm512b32
public Code EVEX_Vrcp14pd_xmm_k1z_xmmm128b64
public Code EVEX_Vrcp14pd_ymm_k1z_ymmm256b64
public Code EVEX_Vrcp14pd_zmm_k1z_zmmm512b64
public Code EVEX_Vrcp14ss_xmm_k1z_xmm_xmmm32
public Code EVEX_Vrcp14sd_xmm_k1z_xmm_xmmm64
public Code EVEX_Vrsqrt14ps_xmm_k1z_xmmm128b32
public Code EVEX_Vrsqrt14ps_ymm_k1z_ymmm256b32
public Code EVEX_Vrsqrt14ps_zmm_k1z_zmmm512b32
public Code EVEX_Vrsqrt14pd_xmm_k1z_xmmm128b64
public Code EVEX_Vrsqrt14pd_ymm_k1z_ymmm256b64
public Code EVEX_Vrsqrt14pd_zmm_k1z_zmmm512b64
public Code EVEX_Vrsqrt14ss_xmm_k1z_xmm_xmmm32
public Code EVEX_Vrsqrt14sd_xmm_k1z_xmm_xmmm64
public Code EVEX_Vpdpbusd_xmm_k1z_xmm_xmmm128b32
public Code EVEX_Vpdpbusd_ymm_k1z_ymm_ymmm256b32
public Code EVEX_Vpdpbusd_zmm_k1z_zmm_zmmm512b32
public Code EVEX_Vpdpbusds_xmm_k1z_xmm_xmmm128b32
public Code EVEX_Vpdpbusds_ymm_k1z_ymm_ymmm256b32
public Code EVEX_Vpdpbusds_zmm_k1z_zmm_zmmm512b32
public Code EVEX_Vpdpwssd_xmm_k1z_xmm_xmmm128b32
public Code EVEX_Vpdpwssd_ymm_k1z_ymm_ymmm256b32
public Code EVEX_Vpdpwssd_zmm_k1z_zmm_zmmm512b32
public Code EVEX_Vdpbf16ps_xmm_k1z_xmm_xmmm128b32
public Code EVEX_Vdpbf16ps_ymm_k1z_ymm_ymmm256b32
public Code EVEX_Vdpbf16ps_zmm_k1z_zmm_zmmm512b32
public Code EVEX_Vp4dpwssd_zmm_k1z_zmmp3_m128
public Code EVEX_Vpdpwssds_xmm_k1z_xmm_xmmm128b32
public Code EVEX_Vpdpwssds_ymm_k1z_ymm_ymmm256b32
public Code EVEX_Vpdpwssds_zmm_k1z_zmm_zmmm512b32
public Code EVEX_Vp4dpwssds_zmm_k1z_zmmp3_m128
public Code EVEX_Vpopcntb_xmm_k1z_xmmm128
public Code EVEX_Vpopcntb_ymm_k1z_ymmm256
public Code EVEX_Vpopcntb_zmm_k1z_zmmm512
public Code EVEX_Vpopcntw_xmm_k1z_xmmm128
public Code EVEX_Vpopcntw_ymm_k1z_ymmm256
public Code EVEX_Vpopcntw_zmm_k1z_zmmm512
public Code EVEX_Vpopcntd_xmm_k1z_xmmm128b32
public Code EVEX_Vpopcntd_ymm_k1z_ymmm256b32
public Code EVEX_Vpopcntd_zmm_k1z_zmmm512b32
public Code EVEX_Vpopcntq_xmm_k1z_xmmm128b64
public Code EVEX_Vpopcntq_ymm_k1z_ymmm256b64
public Code EVEX_Vpopcntq_zmm_k1z_zmmm512b64
public Code VEX_Vpbroadcastd_xmm_xmmm32
public Code VEX_Vpbroadcastd_ymm_xmmm32
public Code EVEX_Vpbroadcastd_xmm_k1z_xmmm32
public Code EVEX_Vpbroadcastd_ymm_k1z_xmmm32
public Code EVEX_Vpbroadcastd_zmm_k1z_xmmm32
public Code VEX_Vpbroadcastq_xmm_xmmm64
public Code VEX_Vpbroadcastq_ymm_xmmm64
public Code EVEX_Vbroadcasti32x2_xmm_k1z_xmmm64
public Code EVEX_Vbroadcasti32x2_ymm_k1z_xmmm64
public Code EVEX_Vbroadcasti32x2_zmm_k1z_xmmm64
public Code EVEX_Vpbroadcastq_xmm_k1z_xmmm64
public Code EVEX_Vpbroadcastq_ymm_k1z_xmmm64
public Code EVEX_Vpbroadcastq_zmm_k1z_xmmm64
public Code VEX_Vbroadcasti128_ymm_m128
public Code EVEX_Vbroadcasti32x4_ymm_k1z_m128
public Code EVEX_Vbroadcasti32x4_zmm_k1z_m128
public Code EVEX_Vbroadcasti64x2_ymm_k1z_m128
public Code EVEX_Vbroadcasti64x2_zmm_k1z_m128
public Code EVEX_Vbroadcasti32x8_zmm_k1z_m256
public Code EVEX_Vbroadcasti64x4_zmm_k1z_m256
public Code EVEX_Vpexpandb_xmm_k1z_xmmm128
public Code EVEX_Vpexpandb_ymm_k1z_ymmm256
public Code EVEX_Vpexpandb_zmm_k1z_zmmm512
public Code EVEX_Vpexpandw_xmm_k1z_xmmm128
public Code EVEX_Vpexpandw_ymm_k1z_ymmm256
public Code EVEX_Vpexpandw_zmm_k1z_zmmm512
public Code EVEX_Vpcompressb_xmmm128_k1z_xmm
public Code EVEX_Vpcompressb_ymmm256_k1z_ymm
public Code EVEX_Vpcompressb_zmmm512_k1z_zmm
public Code EVEX_Vpcompressw_xmmm128_k1z_xmm
public Code EVEX_Vpcompressw_ymmm256_k1z_ymm
public Code EVEX_Vpcompressw_zmmm512_k1z_zmm
public Code EVEX_Vpblendmd_xmm_k1z_xmm_xmmm128b32
public Code EVEX_Vpblendmd_ymm_k1z_ymm_ymmm256b32
public Code EVEX_Vpblendmd_zmm_k1z_zmm_zmmm512b32
public Code EVEX_Vpblendmq_xmm_k1z_xmm_xmmm128b64
public Code EVEX_Vpblendmq_ymm_k1z_ymm_ymmm256b64
public Code EVEX_Vpblendmq_zmm_k1z_zmm_zmmm512b64
public Code EVEX_Vblendmps_xmm_k1z_xmm_xmmm128b32
public Code EVEX_Vblendmps_ymm_k1z_ymm_ymmm256b32
public Code EVEX_Vblendmps_zmm_k1z_zmm_zmmm512b32
public Code EVEX_Vblendmpd_xmm_k1z_xmm_xmmm128b64
public Code EVEX_Vblendmpd_ymm_k1z_ymm_ymmm256b64
public Code EVEX_Vblendmpd_zmm_k1z_zmm_zmmm512b64
public Code EVEX_Vpblendmb_xmm_k1z_xmm_xmmm128
public Code EVEX_Vpblendmb_ymm_k1z_ymm_ymmm256
public Code EVEX_Vpblendmb_zmm_k1z_zmm_zmmm512
public Code EVEX_Vpblendmw_xmm_k1z_xmm_xmmm128
public Code EVEX_Vpblendmw_ymm_k1z_ymm_ymmm256
public Code EVEX_Vpblendmw_zmm_k1z_zmm_zmmm512
public Code EVEX_Vp2intersectd_kp1_xmm_xmmm128b32
public Code EVEX_Vp2intersectd_kp1_ymm_ymmm256b32
public Code EVEX_Vp2intersectd_kp1_zmm_zmmm512b32
public Code EVEX_Vp2intersectq_kp1_xmm_xmmm128b64
public Code EVEX_Vp2intersectq_kp1_ymm_ymmm256b64
public Code EVEX_Vp2intersectq_kp1_zmm_zmmm512b64
public Code EVEX_Vpshldvw_xmm_k1z_xmm_xmmm128
public Code EVEX_Vpshldvw_ymm_k1z_ymm_ymmm256
public Code EVEX_Vpshldvw_zmm_k1z_zmm_zmmm512
public Code EVEX_Vpshldvd_xmm_k1z_xmm_xmmm128b32
public Code EVEX_Vpshldvd_ymm_k1z_ymm_ymmm256b32
public Code EVEX_Vpshldvd_zmm_k1z_zmm_zmmm512b32
public Code EVEX_Vpshldvq_xmm_k1z_xmm_xmmm128b64
public Code EVEX_Vpshldvq_ymm_k1z_ymm_ymmm256b64
public Code EVEX_Vpshldvq_zmm_k1z_zmm_zmmm512b64
public Code EVEX_Vpshrdvw_xmm_k1z_xmm_xmmm128
public Code EVEX_Vpshrdvw_ymm_k1z_ymm_ymmm256
public Code EVEX_Vpshrdvw_zmm_k1z_zmm_zmmm512
public Code EVEX_Vcvtneps2bf16_xmm_k1z_xmmm128b32
public Code EVEX_Vcvtneps2bf16_xmm_k1z_ymmm256b32
public Code EVEX_Vcvtneps2bf16_ymm_k1z_zmmm512b32
public Code EVEX_Vcvtne2ps2bf16_xmm_k1z_xmm_xmmm128b32
public Code EVEX_Vcvtne2ps2bf16_ymm_k1z_ymm_ymmm256b32
public Code EVEX_Vcvtne2ps2bf16_zmm_k1z_zmm_zmmm512b32
public Code EVEX_Vpshrdvd_xmm_k1z_xmm_xmmm128b32
public Code EVEX_Vpshrdvd_ymm_k1z_ymm_ymmm256b32
public Code EVEX_Vpshrdvd_zmm_k1z_zmm_zmmm512b32
public Code EVEX_Vpshrdvq_xmm_k1z_xmm_xmmm128b64
public Code EVEX_Vpshrdvq_ymm_k1z_ymm_ymmm256b64
public Code EVEX_Vpshrdvq_zmm_k1z_zmm_zmmm512b64
public Code EVEX_Vpermi2b_xmm_k1z_xmm_xmmm128
public Code EVEX_Vpermi2b_ymm_k1z_ymm_ymmm256
public Code EVEX_Vpermi2b_zmm_k1z_zmm_zmmm512
public Code EVEX_Vpermi2w_xmm_k1z_xmm_xmmm128
public Code EVEX_Vpermi2w_ymm_k1z_ymm_ymmm256
public Code EVEX_Vpermi2w_zmm_k1z_zmm_zmmm512
public Code EVEX_Vpermi2d_xmm_k1z_xmm_xmmm128b32
public Code EVEX_Vpermi2d_ymm_k1z_ymm_ymmm256b32
public Code EVEX_Vpermi2d_zmm_k1z_zmm_zmmm512b32
public Code EVEX_Vpermi2q_xmm_k1z_xmm_xmmm128b64
public Code EVEX_Vpermi2q_ymm_k1z_ymm_ymmm256b64
public Code EVEX_Vpermi2q_zmm_k1z_zmm_zmmm512b64
public Code EVEX_Vpermi2ps_xmm_k1z_xmm_xmmm128b32
public Code EVEX_Vpermi2ps_ymm_k1z_ymm_ymmm256b32
public Code EVEX_Vpermi2ps_zmm_k1z_zmm_zmmm512b32
public Code EVEX_Vpermi2pd_xmm_k1z_xmm_xmmm128b64
public Code EVEX_Vpermi2pd_ymm_k1z_ymm_ymmm256b64
public Code EVEX_Vpermi2pd_zmm_k1z_zmm_zmmm512b64
public Code VEX_Vpbroadcastb_xmm_xmmm8
public Code VEX_Vpbroadcastb_ymm_xmmm8
public Code EVEX_Vpbroadcastb_xmm_k1z_xmmm8
public Code EVEX_Vpbroadcastb_ymm_k1z_xmmm8
public Code EVEX_Vpbroadcastb_zmm_k1z_xmmm8
public Code VEX_Vpbroadcastw_xmm_xmmm16
public Code VEX_Vpbroadcastw_ymm_xmmm16
public Code EVEX_Vpbroadcastw_xmm_k1z_xmmm16
public Code EVEX_Vpbroadcastw_ymm_k1z_xmmm16
public Code EVEX_Vpbroadcastw_zmm_k1z_xmmm16
public Code EVEX_Vpbroadcastb_xmm_k1z_r32
public Code EVEX_Vpbroadcastb_ymm_k1z_r32
public Code EVEX_Vpbroadcastb_zmm_k1z_r32
public Code EVEX_Vpbroadcastw_xmm_k1z_r32
public Code EVEX_Vpbroadcastw_ymm_k1z_r32
public Code EVEX_Vpbroadcastw_zmm_k1z_r32
public Code EVEX_Vpbroadcastd_xmm_k1z_r32
public Code EVEX_Vpbroadcastd_ymm_k1z_r32
public Code EVEX_Vpbroadcastd_zmm_k1z_r32
public Code EVEX_Vpbroadcastq_xmm_k1z_r64
public Code EVEX_Vpbroadcastq_ymm_k1z_r64
public Code EVEX_Vpbroadcastq_zmm_k1z_r64
public Code EVEX_Vpermt2b_xmm_k1z_xmm_xmmm128
public Code EVEX_Vpermt2b_ymm_k1z_ymm_ymmm256
public Code EVEX_Vpermt2b_zmm_k1z_zmm_zmmm512
public Code EVEX_Vpermt2w_xmm_k1z_xmm_xmmm128
public Code EVEX_Vpermt2w_ymm_k1z_ymm_ymmm256
public Code EVEX_Vpermt2w_zmm_k1z_zmm_zmmm512
public Code EVEX_Vpermt2d_xmm_k1z_xmm_xmmm128b32
public Code EVEX_Vpermt2d_ymm_k1z_ymm_ymmm256b32
public Code EVEX_Vpermt2d_zmm_k1z_zmm_zmmm512b32
public Code EVEX_Vpermt2q_xmm_k1z_xmm_xmmm128b64
public Code EVEX_Vpermt2q_ymm_k1z_ymm_ymmm256b64
public Code EVEX_Vpermt2q_zmm_k1z_zmm_zmmm512b64
public Code EVEX_Vpermt2ps_xmm_k1z_xmm_xmmm128b32
public Code EVEX_Vpermt2ps_ymm_k1z_ymm_ymmm256b32
public Code EVEX_Vpermt2ps_zmm_k1z_zmm_zmmm512b32
public Code EVEX_Vpermt2pd_xmm_k1z_xmm_xmmm128b64
public Code EVEX_Vpermt2pd_ymm_k1z_ymm_ymmm256b64
public Code EVEX_Vpermt2pd_zmm_k1z_zmm_zmmm512b64
public Code Invept_r32_m128
public Code Invept_r64_m128
public Code Invvpid_r32_m128
public Code Invvpid_r64_m128
public Code Invpcid_r32_m128
public Code Invpcid_r64_m128
public Code EVEX_Vpmultishiftqb_xmm_k1z_xmm_xmmm128b64
public Code EVEX_Vpmultishiftqb_ymm_k1z_ymm_ymmm256b64
public Code EVEX_Vpmultishiftqb_zmm_k1z_zmm_zmmm512b64
public Code EVEX_Vexpandps_xmm_k1z_xmmm128
public Code EVEX_Vexpandps_ymm_k1z_ymmm256
public Code EVEX_Vexpandps_zmm_k1z_zmmm512
public Code EVEX_Vexpandpd_xmm_k1z_xmmm128
public Code EVEX_Vexpandpd_ymm_k1z_ymmm256
public Code EVEX_Vexpandpd_zmm_k1z_zmmm512
public Code EVEX_Vpexpandd_xmm_k1z_xmmm128
public Code EVEX_Vpexpandd_ymm_k1z_ymmm256
public Code EVEX_Vpexpandd_zmm_k1z_zmmm512
public Code EVEX_Vpexpandq_xmm_k1z_xmmm128
public Code EVEX_Vpexpandq_ymm_k1z_ymmm256
public Code EVEX_Vpexpandq_zmm_k1z_zmmm512
public Code EVEX_Vcompressps_xmmm128_k1z_xmm
public Code EVEX_Vcompressps_ymmm256_k1z_ymm
public Code EVEX_Vcompressps_zmmm512_k1z_zmm
public Code EVEX_Vcompresspd_xmmm128_k1z_xmm
public Code EVEX_Vcompresspd_ymmm256_k1z_ymm
public Code EVEX_Vcompresspd_zmmm512_k1z_zmm
public Code EVEX_Vpcompressd_xmmm128_k1z_xmm
public Code EVEX_Vpcompressd_ymmm256_k1z_ymm
public Code EVEX_Vpcompressd_zmmm512_k1z_zmm
public Code EVEX_Vpcompressq_xmmm128_k1z_xmm
public Code EVEX_Vpcompressq_ymmm256_k1z_ymm
public Code EVEX_Vpcompressq_zmmm512_k1z_zmm
public Code VEX_Vpmaskmovd_xmm_xmm_m128
public Code VEX_Vpmaskmovd_ymm_ymm_m256
public Code VEX_Vpmaskmovq_xmm_xmm_m128
public Code VEX_Vpmaskmovq_ymm_ymm_m256
public Code EVEX_Vpermb_xmm_k1z_xmm_xmmm128
public Code EVEX_Vpermb_ymm_k1z_ymm_ymmm256
public Code EVEX_Vpermb_zmm_k1z_zmm_zmmm512
public Code EVEX_Vpermw_xmm_k1z_xmm_xmmm128
public Code EVEX_Vpermw_ymm_k1z_ymm_ymmm256
public Code EVEX_Vpermw_zmm_k1z_zmm_zmmm512
public Code VEX_Vpmaskmovd_m128_xmm_xmm
public Code VEX_Vpmaskmovd_m256_ymm_ymm
public Code VEX_Vpmaskmovq_m128_xmm_xmm
public Code VEX_Vpmaskmovq_m256_ymm_ymm
public Code EVEX_Vpshufbitqmb_kr_k1_xmm_xmmm128
public Code EVEX_Vpshufbitqmb_kr_k1_ymm_ymmm256
public Code EVEX_Vpshufbitqmb_kr_k1_zmm_zmmm512
public Code VEX_Vpgatherdd_xmm_vm32x_xmm
public Code VEX_Vpgatherdd_ymm_vm32y_ymm
public Code VEX_Vpgatherdq_xmm_vm32x_xmm
public Code VEX_Vpgatherdq_ymm_vm32x_ymm
public Code EVEX_Vpgatherdd_xmm_k1_vm32x
public Code EVEX_Vpgatherdd_ymm_k1_vm32y
public Code EVEX_Vpgatherdd_zmm_k1_vm32z
public Code EVEX_Vpgatherdq_xmm_k1_vm32x
public Code EVEX_Vpgatherdq_ymm_k1_vm32x
public Code EVEX_Vpgatherdq_zmm_k1_vm32y
public Code VEX_Vpgatherqd_xmm_vm64x_xmm
public Code VEX_Vpgatherqd_xmm_vm64y_xmm
public Code VEX_Vpgatherqq_xmm_vm64x_xmm
public Code VEX_Vpgatherqq_ymm_vm64y_ymm
public Code EVEX_Vpgatherqd_xmm_k1_vm64x
public Code EVEX_Vpgatherqd_xmm_k1_vm64y
public Code EVEX_Vpgatherqd_ymm_k1_vm64z
public Code EVEX_Vpgatherqq_xmm_k1_vm64x
public Code EVEX_Vpgatherqq_ymm_k1_vm64y
public Code EVEX_Vpgatherqq_zmm_k1_vm64z
public Code VEX_Vgatherdps_xmm_vm32x_xmm
public Code VEX_Vgatherdps_ymm_vm32y_ymm
public Code VEX_Vgatherdpd_xmm_vm32x_xmm
public Code VEX_Vgatherdpd_ymm_vm32x_ymm
public Code EVEX_Vgatherdps_xmm_k1_vm32x
public Code EVEX_Vgatherdps_ymm_k1_vm32y
public Code EVEX_Vgatherdps_zmm_k1_vm32z
public Code EVEX_Vgatherdpd_xmm_k1_vm32x
public Code EVEX_Vgatherdpd_ymm_k1_vm32x
public Code EVEX_Vgatherdpd_zmm_k1_vm32y
public Code VEX_Vgatherqps_xmm_vm64x_xmm
public Code VEX_Vgatherqps_xmm_vm64y_xmm
public Code VEX_Vgatherqpd_xmm_vm64x_xmm
public Code VEX_Vgatherqpd_ymm_vm64y_ymm
public Code EVEX_Vgatherqps_xmm_k1_vm64x
public Code EVEX_Vgatherqps_xmm_k1_vm64y
public Code EVEX_Vgatherqps_ymm_k1_vm64z
public Code EVEX_Vgatherqpd_xmm_k1_vm64x
public Code EVEX_Vgatherqpd_ymm_k1_vm64y
public Code EVEX_Vgatherqpd_zmm_k1_vm64z
public Code VEX_Vfmaddsub132ps_xmm_xmm_xmmm128
public Code VEX_Vfmaddsub132ps_ymm_ymm_ymmm256
public Code VEX_Vfmaddsub132pd_xmm_xmm_xmmm128
public Code VEX_Vfmaddsub132pd_ymm_ymm_ymmm256
public Code EVEX_Vfmaddsub132ps_xmm_k1z_xmm_xmmm128b32
public Code EVEX_Vfmaddsub132ps_ymm_k1z_ymm_ymmm256b32
public Code EVEX_Vfmaddsub132ps_zmm_k1z_zmm_zmmm512b32_er
public Code EVEX_Vfmaddsub132pd_xmm_k1z_xmm_xmmm128b64
public Code EVEX_Vfmaddsub132pd_ymm_k1z_ymm_ymmm256b64
public Code EVEX_Vfmaddsub132pd_zmm_k1z_zmm_zmmm512b64_er
public Code VEX_Vfmsubadd132ps_xmm_xmm_xmmm128
public Code VEX_Vfmsubadd132ps_ymm_ymm_ymmm256
public Code VEX_Vfmsubadd132pd_xmm_xmm_xmmm128
public Code VEX_Vfmsubadd132pd_ymm_ymm_ymmm256
public Code EVEX_Vfmsubadd132ps_xmm_k1z_xmm_xmmm128b32
public Code EVEX_Vfmsubadd132ps_ymm_k1z_ymm_ymmm256b32
public Code EVEX_Vfmsubadd132ps_zmm_k1z_zmm_zmmm512b32_er
public Code EVEX_Vfmsubadd132pd_xmm_k1z_xmm_xmmm128b64
public Code EVEX_Vfmsubadd132pd_ymm_k1z_ymm_ymmm256b64
public Code EVEX_Vfmsubadd132pd_zmm_k1z_zmm_zmmm512b64_er
public Code VEX_Vfmadd132ps_xmm_xmm_xmmm128
public Code VEX_Vfmadd132ps_ymm_ymm_ymmm256
public Code VEX_Vfmadd132pd_xmm_xmm_xmmm128
public Code VEX_Vfmadd132pd_ymm_ymm_ymmm256
public Code EVEX_Vfmadd132ps_xmm_k1z_xmm_xmmm128b32
public Code EVEX_Vfmadd132ps_ymm_k1z_ymm_ymmm256b32
public Code EVEX_Vfmadd132ps_zmm_k1z_zmm_zmmm512b32_er
public Code EVEX_Vfmadd132pd_xmm_k1z_xmm_xmmm128b64
public Code EVEX_Vfmadd132pd_ymm_k1z_ymm_ymmm256b64
public Code EVEX_Vfmadd132pd_zmm_k1z_zmm_zmmm512b64_er
public Code VEX_Vfmadd132ss_xmm_xmm_xmmm32
public Code VEX_Vfmadd132sd_xmm_xmm_xmmm64
public Code EVEX_Vfmadd132ss_xmm_k1z_xmm_xmmm32_er
public Code EVEX_Vfmadd132sd_xmm_k1z_xmm_xmmm64_er
public Code VEX_Vfmsub132ps_xmm_xmm_xmmm128
public Code VEX_Vfmsub132ps_ymm_ymm_ymmm256
public Code VEX_Vfmsub132pd_xmm_xmm_xmmm128
public Code VEX_Vfmsub132pd_ymm_ymm_ymmm256
public Code EVEX_Vfmsub132ps_xmm_k1z_xmm_xmmm128b32
public Code EVEX_Vfmsub132ps_ymm_k1z_ymm_ymmm256b32
public Code EVEX_Vfmsub132ps_zmm_k1z_zmm_zmmm512b32_er
public Code EVEX_Vfmsub132pd_xmm_k1z_xmm_xmmm128b64
public Code EVEX_Vfmsub132pd_ymm_k1z_ymm_ymmm256b64
public Code EVEX_Vfmsub132pd_zmm_k1z_zmm_zmmm512b64_er
public Code EVEX_V4fmaddps_zmm_k1z_zmmp3_m128
public Code VEX_Vfmsub132ss_xmm_xmm_xmmm32
public Code VEX_Vfmsub132sd_xmm_xmm_xmmm64
public Code EVEX_Vfmsub132ss_xmm_k1z_xmm_xmmm32_er
public Code EVEX_Vfmsub132sd_xmm_k1z_xmm_xmmm64_er
public Code EVEX_V4fmaddss_xmm_k1z_xmmp3_m128
public Code VEX_Vfnmadd132ps_xmm_xmm_xmmm128
public Code VEX_Vfnmadd132ps_ymm_ymm_ymmm256
public Code VEX_Vfnmadd132pd_xmm_xmm_xmmm128
public Code VEX_Vfnmadd132pd_ymm_ymm_ymmm256
public Code EVEX_Vfnmadd132ps_xmm_k1z_xmm_xmmm128b32
public Code EVEX_Vfnmadd132ps_ymm_k1z_ymm_ymmm256b32
public Code EVEX_Vfnmadd132ps_zmm_k1z_zmm_zmmm512b32_er
public Code EVEX_Vfnmadd132pd_xmm_k1z_xmm_xmmm128b64
public Code EVEX_Vfnmadd132pd_ymm_k1z_ymm_ymmm256b64
public Code EVEX_Vfnmadd132pd_zmm_k1z_zmm_zmmm512b64_er
public Code VEX_Vfnmadd132ss_xmm_xmm_xmmm32
public Code VEX_Vfnmadd132sd_xmm_xmm_xmmm64
public Code EVEX_Vfnmadd132ss_xmm_k1z_xmm_xmmm32_er
public Code EVEX_Vfnmadd132sd_xmm_k1z_xmm_xmmm64_er
public Code VEX_Vfnmsub132ps_xmm_xmm_xmmm128
public Code VEX_Vfnmsub132ps_ymm_ymm_ymmm256
public Code VEX_Vfnmsub132pd_xmm_xmm_xmmm128
public Code VEX_Vfnmsub132pd_ymm_ymm_ymmm256
public Code EVEX_Vfnmsub132ps_xmm_k1z_xmm_xmmm128b32
public Code EVEX_Vfnmsub132ps_ymm_k1z_ymm_ymmm256b32
public Code EVEX_Vfnmsub132ps_zmm_k1z_zmm_zmmm512b32_er
public Code EVEX_Vfnmsub132pd_xmm_k1z_xmm_xmmm128b64
public Code EVEX_Vfnmsub132pd_ymm_k1z_ymm_ymmm256b64
public Code EVEX_Vfnmsub132pd_zmm_k1z_zmm_zmmm512b64_er
public Code VEX_Vfnmsub132ss_xmm_xmm_xmmm32
public Code VEX_Vfnmsub132sd_xmm_xmm_xmmm64
public Code EVEX_Vfnmsub132ss_xmm_k1z_xmm_xmmm32_er
public Code EVEX_Vfnmsub132sd_xmm_k1z_xmm_xmmm64_er
public Code EVEX_Vpscatterdd_vm32x_k1_xmm
public Code EVEX_Vpscatterdd_vm32y_k1_ymm
public Code EVEX_Vpscatterdd_vm32z_k1_zmm
public Code EVEX_Vpscatterdq_vm32x_k1_xmm
public Code EVEX_Vpscatterdq_vm32x_k1_ymm
public Code EVEX_Vpscatterdq_vm32y_k1_zmm
public Code EVEX_Vpscatterqd_vm64x_k1_xmm
public Code EVEX_Vpscatterqd_vm64y_k1_xmm
public Code EVEX_Vpscatterqd_vm64z_k1_ymm
public Code EVEX_Vpscatterqq_vm64x_k1_xmm
public Code EVEX_Vpscatterqq_vm64y_k1_ymm
public Code EVEX_Vpscatterqq_vm64z_k1_zmm
public Code EVEX_Vscatterdps_vm32x_k1_xmm
public Code EVEX_Vscatterdps_vm32y_k1_ymm
public Code EVEX_Vscatterdps_vm32z_k1_zmm
public Code EVEX_Vscatterdpd_vm32x_k1_xmm
public Code EVEX_Vscatterdpd_vm32x_k1_ymm
public Code EVEX_Vscatterdpd_vm32y_k1_zmm
public Code EVEX_Vscatterqps_vm64x_k1_xmm
public Code EVEX_Vscatterqps_vm64y_k1_xmm
public Code EVEX_Vscatterqps_vm64z_k1_ymm
public Code EVEX_Vscatterqpd_vm64x_k1_xmm
public Code EVEX_Vscatterqpd_vm64y_k1_ymm
public Code EVEX_Vscatterqpd_vm64z_k1_zmm
public Code VEX_Vfmaddsub213ps_xmm_xmm_xmmm128
public Code VEX_Vfmaddsub213ps_ymm_ymm_ymmm256
public Code VEX_Vfmaddsub213pd_xmm_xmm_xmmm128
public Code VEX_Vfmaddsub213pd_ymm_ymm_ymmm256
public Code EVEX_Vfmaddsub213ps_xmm_k1z_xmm_xmmm128b32
public Code EVEX_Vfmaddsub213ps_ymm_k1z_ymm_ymmm256b32
public Code EVEX_Vfmaddsub213ps_zmm_k1z_zmm_zmmm512b32_er
public Code EVEX_Vfmaddsub213pd_xmm_k1z_xmm_xmmm128b64
public Code EVEX_Vfmaddsub213pd_ymm_k1z_ymm_ymmm256b64
public Code EVEX_Vfmaddsub213pd_zmm_k1z_zmm_zmmm512b64_er
public Code VEX_Vfmsubadd213ps_xmm_xmm_xmmm128
public Code VEX_Vfmsubadd213ps_ymm_ymm_ymmm256
public Code VEX_Vfmsubadd213pd_xmm_xmm_xmmm128
public Code VEX_Vfmsubadd213pd_ymm_ymm_ymmm256
public Code EVEX_Vfmsubadd213ps_xmm_k1z_xmm_xmmm128b32
public Code EVEX_Vfmsubadd213ps_ymm_k1z_ymm_ymmm256b32
public Code EVEX_Vfmsubadd213ps_zmm_k1z_zmm_zmmm512b32_er
public Code EVEX_Vfmsubadd213pd_xmm_k1z_xmm_xmmm128b64
public Code EVEX_Vfmsubadd213pd_ymm_k1z_ymm_ymmm256b64
public Code EVEX_Vfmsubadd213pd_zmm_k1z_zmm_zmmm512b64_er
public Code VEX_Vfmadd213ps_xmm_xmm_xmmm128
public Code VEX_Vfmadd213ps_ymm_ymm_ymmm256
public Code VEX_Vfmadd213pd_xmm_xmm_xmmm128
public Code VEX_Vfmadd213pd_ymm_ymm_ymmm256
public Code EVEX_Vfmadd213ps_xmm_k1z_xmm_xmmm128b32
public Code EVEX_Vfmadd213ps_ymm_k1z_ymm_ymmm256b32
public Code EVEX_Vfmadd213ps_zmm_k1z_zmm_zmmm512b32_er
public Code EVEX_Vfmadd213pd_xmm_k1z_xmm_xmmm128b64
public Code EVEX_Vfmadd213pd_ymm_k1z_ymm_ymmm256b64
public Code EVEX_Vfmadd213pd_zmm_k1z_zmm_zmmm512b64_er
public Code VEX_Vfmadd213ss_xmm_xmm_xmmm32
public Code VEX_Vfmadd213sd_xmm_xmm_xmmm64
public Code EVEX_Vfmadd213ss_xmm_k1z_xmm_xmmm32_er
public Code EVEX_Vfmadd213sd_xmm_k1z_xmm_xmmm64_er
public Code VEX_Vfmsub213ps_xmm_xmm_xmmm128
public Code VEX_Vfmsub213ps_ymm_ymm_ymmm256
public Code VEX_Vfmsub213pd_xmm_xmm_xmmm128
public Code VEX_Vfmsub213pd_ymm_ymm_ymmm256
public Code EVEX_Vfmsub213ps_xmm_k1z_xmm_xmmm128b32
public Code EVEX_Vfmsub213ps_ymm_k1z_ymm_ymmm256b32
public Code EVEX_Vfmsub213ps_zmm_k1z_zmm_zmmm512b32_er
public Code EVEX_Vfmsub213pd_xmm_k1z_xmm_xmmm128b64
public Code EVEX_Vfmsub213pd_ymm_k1z_ymm_ymmm256b64
public Code EVEX_Vfmsub213pd_zmm_k1z_zmm_zmmm512b64_er
public Code EVEX_V4fnmaddps_zmm_k1z_zmmp3_m128
public Code VEX_Vfmsub213ss_xmm_xmm_xmmm32
public Code VEX_Vfmsub213sd_xmm_xmm_xmmm64
public Code EVEX_Vfmsub213ss_xmm_k1z_xmm_xmmm32_er
public Code EVEX_Vfmsub213sd_xmm_k1z_xmm_xmmm64_er
public Code EVEX_V4fnmaddss_xmm_k1z_xmmp3_m128
public Code VEX_Vfnmadd213ps_xmm_xmm_xmmm128
public Code VEX_Vfnmadd213ps_ymm_ymm_ymmm256
public Code VEX_Vfnmadd213pd_xmm_xmm_xmmm128
public Code VEX_Vfnmadd213pd_ymm_ymm_ymmm256
public Code EVEX_Vfnmadd213ps_xmm_k1z_xmm_xmmm128b32
public Code EVEX_Vfnmadd213ps_ymm_k1z_ymm_ymmm256b32
public Code EVEX_Vfnmadd213ps_zmm_k1z_zmm_zmmm512b32_er
public Code EVEX_Vfnmadd213pd_xmm_k1z_xmm_xmmm128b64
public Code EVEX_Vfnmadd213pd_ymm_k1z_ymm_ymmm256b64
public Code EVEX_Vfnmadd213pd_zmm_k1z_zmm_zmmm512b64_er
public Code VEX_Vfnmadd213ss_xmm_xmm_xmmm32
public Code VEX_Vfnmadd213sd_xmm_xmm_xmmm64
public Code EVEX_Vfnmadd213ss_xmm_k1z_xmm_xmmm32_er
public Code EVEX_Vfnmadd213sd_xmm_k1z_xmm_xmmm64_er
public Code VEX_Vfnmsub213ps_xmm_xmm_xmmm128
public Code VEX_Vfnmsub213ps_ymm_ymm_ymmm256
public Code VEX_Vfnmsub213pd_xmm_xmm_xmmm128
public Code VEX_Vfnmsub213pd_ymm_ymm_ymmm256
public Code EVEX_Vfnmsub213ps_xmm_k1z_xmm_xmmm128b32
public Code EVEX_Vfnmsub213ps_ymm_k1z_ymm_ymmm256b32
public Code EVEX_Vfnmsub213ps_zmm_k1z_zmm_zmmm512b32_er
public Code EVEX_Vfnmsub213pd_xmm_k1z_xmm_xmmm128b64
public Code EVEX_Vfnmsub213pd_ymm_k1z_ymm_ymmm256b64
public Code EVEX_Vfnmsub213pd_zmm_k1z_zmm_zmmm512b64_er
public Code VEX_Vfnmsub213ss_xmm_xmm_xmmm32
public Code VEX_Vfnmsub213sd_xmm_xmm_xmmm64
public Code EVEX_Vfnmsub213ss_xmm_k1z_xmm_xmmm32_er
public Code EVEX_Vfnmsub213sd_xmm_k1z_xmm_xmmm64_er
public Code EVEX_Vpmadd52luq_xmm_k1z_xmm_xmmm128b64
public Code EVEX_Vpmadd52luq_ymm_k1z_ymm_ymmm256b64
public Code EVEX_Vpmadd52luq_zmm_k1z_zmm_zmmm512b64
public Code EVEX_Vpmadd52huq_xmm_k1z_xmm_xmmm128b64
public Code EVEX_Vpmadd52huq_ymm_k1z_ymm_ymmm256b64
public Code EVEX_Vpmadd52huq_zmm_k1z_zmm_zmmm512b64
public Code VEX_Vfmaddsub231ps_xmm_xmm_xmmm128
public Code VEX_Vfmaddsub231ps_ymm_ymm_ymmm256
public Code VEX_Vfmaddsub231pd_xmm_xmm_xmmm128
public Code VEX_Vfmaddsub231pd_ymm_ymm_ymmm256
public Code EVEX_Vfmaddsub231ps_xmm_k1z_xmm_xmmm128b32
public Code EVEX_Vfmaddsub231ps_ymm_k1z_ymm_ymmm256b32
public Code EVEX_Vfmaddsub231ps_zmm_k1z_zmm_zmmm512b32_er
public Code EVEX_Vfmaddsub231pd_xmm_k1z_xmm_xmmm128b64
public Code EVEX_Vfmaddsub231pd_ymm_k1z_ymm_ymmm256b64
public Code EVEX_Vfmaddsub231pd_zmm_k1z_zmm_zmmm512b64_er
public Code VEX_Vfmsubadd231ps_xmm_xmm_xmmm128
public Code VEX_Vfmsubadd231ps_ymm_ymm_ymmm256
public Code VEX_Vfmsubadd231pd_xmm_xmm_xmmm128
public Code VEX_Vfmsubadd231pd_ymm_ymm_ymmm256
public Code EVEX_Vfmsubadd231ps_xmm_k1z_xmm_xmmm128b32
public Code EVEX_Vfmsubadd231ps_ymm_k1z_ymm_ymmm256b32
public Code EVEX_Vfmsubadd231ps_zmm_k1z_zmm_zmmm512b32_er
public Code EVEX_Vfmsubadd231pd_xmm_k1z_xmm_xmmm128b64
public Code EVEX_Vfmsubadd231pd_ymm_k1z_ymm_ymmm256b64
public Code EVEX_Vfmsubadd231pd_zmm_k1z_zmm_zmmm512b64_er
public Code VEX_Vfmadd231ps_xmm_xmm_xmmm128
public Code VEX_Vfmadd231ps_ymm_ymm_ymmm256
public Code VEX_Vfmadd231pd_xmm_xmm_xmmm128
public Code VEX_Vfmadd231pd_ymm_ymm_ymmm256
public Code EVEX_Vfmadd231ps_xmm_k1z_xmm_xmmm128b32
public Code EVEX_Vfmadd231ps_ymm_k1z_ymm_ymmm256b32
public Code EVEX_Vfmadd231ps_zmm_k1z_zmm_zmmm512b32_er
public Code EVEX_Vfmadd231pd_xmm_k1z_xmm_xmmm128b64
public Code EVEX_Vfmadd231pd_ymm_k1z_ymm_ymmm256b64
public Code EVEX_Vfmadd231pd_zmm_k1z_zmm_zmmm512b64_er
public Code VEX_Vfmadd231ss_xmm_xmm_xmmm32
public Code VEX_Vfmadd231sd_xmm_xmm_xmmm64
public Code EVEX_Vfmadd231ss_xmm_k1z_xmm_xmmm32_er
public Code EVEX_Vfmadd231sd_xmm_k1z_xmm_xmmm64_er
public Code VEX_Vfmsub231ps_xmm_xmm_xmmm128
public Code VEX_Vfmsub231ps_ymm_ymm_ymmm256
public Code VEX_Vfmsub231pd_xmm_xmm_xmmm128
public Code VEX_Vfmsub231pd_ymm_ymm_ymmm256
public Code EVEX_Vfmsub231ps_xmm_k1z_xmm_xmmm128b32
public Code EVEX_Vfmsub231ps_ymm_k1z_ymm_ymmm256b32
public Code EVEX_Vfmsub231ps_zmm_k1z_zmm_zmmm512b32_er
public Code EVEX_Vfmsub231pd_xmm_k1z_xmm_xmmm128b64
public Code EVEX_Vfmsub231pd_ymm_k1z_ymm_ymmm256b64
public Code EVEX_Vfmsub231pd_zmm_k1z_zmm_zmmm512b64_er
public Code VEX_Vfmsub231ss_xmm_xmm_xmmm32
public Code VEX_Vfmsub231sd_xmm_xmm_xmmm64
public Code EVEX_Vfmsub231ss_xmm_k1z_xmm_xmmm32_er
public Code EVEX_Vfmsub231sd_xmm_k1z_xmm_xmmm64_er
public Code VEX_Vfnmadd231ps_xmm_xmm_xmmm128
public Code VEX_Vfnmadd231ps_ymm_ymm_ymmm256
public Code VEX_Vfnmadd231pd_xmm_xmm_xmmm128
public Code VEX_Vfnmadd231pd_ymm_ymm_ymmm256
public Code EVEX_Vfnmadd231ps_xmm_k1z_xmm_xmmm128b32
public Code EVEX_Vfnmadd231ps_ymm_k1z_ymm_ymmm256b32
public Code EVEX_Vfnmadd231ps_zmm_k1z_zmm_zmmm512b32_er
public Code EVEX_Vfnmadd231pd_xmm_k1z_xmm_xmmm128b64
public Code EVEX_Vfnmadd231pd_ymm_k1z_ymm_ymmm256b64
public Code EVEX_Vfnmadd231pd_zmm_k1z_zmm_zmmm512b64_er
public Code VEX_Vfnmadd231ss_xmm_xmm_xmmm32
public Code VEX_Vfnmadd231sd_xmm_xmm_xmmm64
public Code EVEX_Vfnmadd231ss_xmm_k1z_xmm_xmmm32_er
public Code EVEX_Vfnmadd231sd_xmm_k1z_xmm_xmmm64_er
public Code VEX_Vfnmsub231ps_xmm_xmm_xmmm128
public Code VEX_Vfnmsub231ps_ymm_ymm_ymmm256
public Code VEX_Vfnmsub231pd_xmm_xmm_xmmm128
public Code VEX_Vfnmsub231pd_ymm_ymm_ymmm256
public Code EVEX_Vfnmsub231ps_xmm_k1z_xmm_xmmm128b32
public Code EVEX_Vfnmsub231ps_ymm_k1z_ymm_ymmm256b32
public Code EVEX_Vfnmsub231ps_zmm_k1z_zmm_zmmm512b32_er
public Code EVEX_Vfnmsub231pd_xmm_k1z_xmm_xmmm128b64
public Code EVEX_Vfnmsub231pd_ymm_k1z_ymm_ymmm256b64
public Code EVEX_Vfnmsub231pd_zmm_k1z_zmm_zmmm512b64_er
public Code VEX_Vfnmsub231ss_xmm_xmm_xmmm32
public Code VEX_Vfnmsub231sd_xmm_xmm_xmmm64
public Code EVEX_Vfnmsub231ss_xmm_k1z_xmm_xmmm32_er
public Code EVEX_Vfnmsub231sd_xmm_k1z_xmm_xmmm64_er
public Code EVEX_Vpconflictd_xmm_k1z_xmmm128b32
public Code EVEX_Vpconflictd_ymm_k1z_ymmm256b32
public Code EVEX_Vpconflictd_zmm_k1z_zmmm512b32
public Code EVEX_Vpconflictq_xmm_k1z_xmmm128b64
public Code EVEX_Vpconflictq_ymm_k1z_ymmm256b64
public Code EVEX_Vpconflictq_zmm_k1z_zmmm512b64
public Code EVEX_Vgatherpf0dps_vm32z_k1
public Code EVEX_Vgatherpf0dpd_vm32y_k1
public Code EVEX_Vgatherpf1dps_vm32z_k1
public Code EVEX_Vgatherpf1dpd_vm32y_k1
public Code EVEX_Vscatterpf0dps_vm32z_k1
public Code EVEX_Vscatterpf0dpd_vm32y_k1
public Code EVEX_Vscatterpf1dps_vm32z_k1
public Code EVEX_Vscatterpf1dpd_vm32y_k1
public Code EVEX_Vgatherpf0qps_vm64z_k1
public Code EVEX_Vgatherpf0qpd_vm64z_k1
public Code EVEX_Vgatherpf1qps_vm64z_k1
public Code EVEX_Vgatherpf1qpd_vm64z_k1
public Code EVEX_Vscatterpf0qps_vm64z_k1
public Code EVEX_Vscatterpf0qpd_vm64z_k1
public Code EVEX_Vscatterpf1qps_vm64z_k1
public Code EVEX_Vscatterpf1qpd_vm64z_k1
public Code Sha1nexte_xmm_xmmm128
public Code EVEX_Vexp2ps_zmm_k1z_zmmm512b32_sae
public Code EVEX_Vexp2pd_zmm_k1z_zmmm512b64_sae
public Code Sha1msg1_xmm_xmmm128
public Code Sha1msg2_xmm_xmmm128
public Code EVEX_Vrcp28ps_zmm_k1z_zmmm512b32_sae
public Code EVEX_Vrcp28pd_zmm_k1z_zmmm512b64_sae
public Code Sha256rnds2_xmm_xmmm128
public Code EVEX_Vrcp28ss_xmm_k1z_xmm_xmmm32_sae
public Code EVEX_Vrcp28sd_xmm_k1z_xmm_xmmm64_sae
public Code Sha256msg1_xmm_xmmm128
public Code EVEX_Vrsqrt28ps_zmm_k1z_zmmm512b32_sae
public Code EVEX_Vrsqrt28pd_zmm_k1z_zmmm512b64_sae
public Code Sha256msg2_xmm_xmmm128
public Code EVEX_Vrsqrt28ss_xmm_k1z_xmm_xmmm32_sae
public Code EVEX_Vrsqrt28sd_xmm_k1z_xmm_xmmm64_sae
public Code Gf2p8mulb_xmm_xmmm128
public Code VEX_Vgf2p8mulb_xmm_xmm_xmmm128
public Code VEX_Vgf2p8mulb_ymm_ymm_ymmm256
public Code EVEX_Vgf2p8mulb_xmm_k1z_xmm_xmmm128
public Code EVEX_Vgf2p8mulb_ymm_k1z_ymm_ymmm256
public Code EVEX_Vgf2p8mulb_zmm_k1z_zmm_zmmm512
public Code Aesimc_xmm_xmmm128
public Code VEX_Vaesimc_xmm_xmmm128
public Code Aesenc_xmm_xmmm128
public Code VEX_Vaesenc_xmm_xmm_xmmm128
public Code VEX_Vaesenc_ymm_ymm_ymmm256
public Code EVEX_Vaesenc_xmm_xmm_xmmm128
public Code EVEX_Vaesenc_ymm_ymm_ymmm256
public Code EVEX_Vaesenc_zmm_zmm_zmmm512
public Code Aesenclast_xmm_xmmm128
public Code VEX_Vaesenclast_xmm_xmm_xmmm128
public Code VEX_Vaesenclast_ymm_ymm_ymmm256
public Code EVEX_Vaesenclast_xmm_xmm_xmmm128
public Code EVEX_Vaesenclast_ymm_ymm_ymmm256
public Code EVEX_Vaesenclast_zmm_zmm_zmmm512
public Code Aesdec_xmm_xmmm128
public Code VEX_Vaesdec_xmm_xmm_xmmm128
public Code VEX_Vaesdec_ymm_ymm_ymmm256
public Code EVEX_Vaesdec_xmm_xmm_xmmm128
public Code EVEX_Vaesdec_ymm_ymm_ymmm256
public Code EVEX_Vaesdec_zmm_zmm_zmmm512
public Code Aesdeclast_xmm_xmmm128
public Code VEX_Vaesdeclast_xmm_xmm_xmmm128
public Code VEX_Vaesdeclast_ymm_ymm_ymmm256
public Code EVEX_Vaesdeclast_xmm_xmm_xmmm128
public Code EVEX_Vaesdeclast_ymm_ymm_ymmm256
public Code EVEX_Vaesdeclast_zmm_zmm_zmmm512
public Code Movbe_r16_m16
public Code Movbe_r32_m32
public Code Movbe_r64_m64
public Code Crc32_r32_rm8
public Code Crc32_r64_rm8
public Code Movbe_m16_r16
public Code Movbe_m32_r32
public Code Movbe_m64_r64
public Code Crc32_r32_rm16
public Code Crc32_r32_rm32
public Code Crc32_r64_rm64
public Code VEX_Andn_r32_r32_rm32
public Code VEX_Andn_r64_r64_rm64
public Code VEX_Blsr_r32_rm32
public Code VEX_Blsr_r64_rm64
public Code VEX_Blsmsk_r32_rm32
public Code VEX_Blsmsk_r64_rm64
public Code VEX_Blsi_r32_rm32
public Code VEX_Blsi_r64_rm64
public Code VEX_Bzhi_r32_rm32_r32
public Code VEX_Bzhi_r64_rm64_r64
public Code Wrussd_m32_r32
public Code Wrussq_m64_r64
public Code VEX_Pext_r32_r32_rm32
public Code VEX_Pext_r64_r64_rm64
public Code VEX_Pdep_r32_r32_rm32
public Code VEX_Pdep_r64_r64_rm64
public Code Wrssd_m32_r32
public Code Wrssq_m64_r64
public Code Adcx_r32_rm32
public Code Adcx_r64_rm64
public Code Adox_r32_rm32
public Code Adox_r64_rm64
public Code VEX_Mulx_r32_r32_rm32
public Code VEX_Mulx_r64_r64_rm64
public Code VEX_Bextr_r32_rm32_r32
public Code VEX_Bextr_r64_rm64_r64
public Code VEX_Shlx_r32_rm32_r32
public Code VEX_Shlx_r64_rm64_r64
public Code VEX_Sarx_r32_rm32_r32
public Code VEX_Sarx_r64_rm64_r64
public Code VEX_Shrx_r32_rm32_r32
public Code VEX_Shrx_r64_rm64_r64
public Code Movdir64b_r16_m512
public Code Movdir64b_r32_m512
public Code Movdir64b_r64_m512
public Code Enqcmds_r16_m512
public Code Enqcmds_r32_m512
public Code Enqcmds_r64_m512
public Code Enqcmd_r16_m512
public Code Enqcmd_r32_m512
public Code Enqcmd_r64_m512
public Code Movdiri_m32_r32
public Code Movdiri_m64_r64
public Code VEX_Vpermq_ymm_ymmm256_imm8
public Code EVEX_Vpermq_ymm_k1z_ymmm256b64_imm8
public Code EVEX_Vpermq_zmm_k1z_zmmm512b64_imm8
public Code VEX_Vpermpd_ymm_ymmm256_imm8
public Code EVEX_Vpermpd_ymm_k1z_ymmm256b64_imm8
public Code EVEX_Vpermpd_zmm_k1z_zmmm512b64_imm8
public Code VEX_Vpblendd_xmm_xmm_xmmm128_imm8
public Code VEX_Vpblendd_ymm_ymm_ymmm256_imm8
public Code EVEX_Valignd_xmm_k1z_xmm_xmmm128b32_imm8
public Code EVEX_Valignd_ymm_k1z_ymm_ymmm256b32_imm8
public Code EVEX_Valignd_zmm_k1z_zmm_zmmm512b32_imm8
public Code EVEX_Valignq_xmm_k1z_xmm_xmmm128b64_imm8
public Code EVEX_Valignq_ymm_k1z_ymm_ymmm256b64_imm8
public Code EVEX_Valignq_zmm_k1z_zmm_zmmm512b64_imm8
public Code VEX_Vpermilps_xmm_xmmm128_imm8
public Code VEX_Vpermilps_ymm_ymmm256_imm8
public Code EVEX_Vpermilps_xmm_k1z_xmmm128b32_imm8
public Code EVEX_Vpermilps_ymm_k1z_ymmm256b32_imm8
public Code EVEX_Vpermilps_zmm_k1z_zmmm512b32_imm8
public Code VEX_Vpermilpd_xmm_xmmm128_imm8
public Code VEX_Vpermilpd_ymm_ymmm256_imm8
public Code EVEX_Vpermilpd_xmm_k1z_xmmm128b64_imm8
public Code EVEX_Vpermilpd_ymm_k1z_ymmm256b64_imm8
public Code EVEX_Vpermilpd_zmm_k1z_zmmm512b64_imm8
public Code VEX_Vperm2f128_ymm_ymm_ymmm256_imm8
public Code Roundps_xmm_xmmm128_imm8
public Code VEX_Vroundps_xmm_xmmm128_imm8
public Code VEX_Vroundps_ymm_ymmm256_imm8
public Code EVEX_Vrndscaleps_xmm_k1z_xmmm128b32_imm8
public Code EVEX_Vrndscaleps_ymm_k1z_ymmm256b32_imm8
public Code EVEX_Vrndscaleps_zmm_k1z_zmmm512b32_imm8_sae
public Code Roundpd_xmm_xmmm128_imm8
public Code VEX_Vroundpd_xmm_xmmm128_imm8
public Code VEX_Vroundpd_ymm_ymmm256_imm8
public Code EVEX_Vrndscalepd_xmm_k1z_xmmm128b64_imm8
public Code EVEX_Vrndscalepd_ymm_k1z_ymmm256b64_imm8
public Code EVEX_Vrndscalepd_zmm_k1z_zmmm512b64_imm8_sae
public Code Roundss_xmm_xmmm32_imm8
public Code VEX_Vroundss_xmm_xmm_xmmm32_imm8
public Code EVEX_Vrndscaless_xmm_k1z_xmm_xmmm32_imm8_sae
public Code Roundsd_xmm_xmmm64_imm8
public Code VEX_Vroundsd_xmm_xmm_xmmm64_imm8
public Code EVEX_Vrndscalesd_xmm_k1z_xmm_xmmm64_imm8_sae
public Code Blendps_xmm_xmmm128_imm8
public Code VEX_Vblendps_xmm_xmm_xmmm128_imm8
public Code VEX_Vblendps_ymm_ymm_ymmm256_imm8
public Code Blendpd_xmm_xmmm128_imm8
public Code VEX_Vblendpd_xmm_xmm_xmmm128_imm8
public Code VEX_Vblendpd_ymm_ymm_ymmm256_imm8
public Code Pblendw_xmm_xmmm128_imm8
public Code VEX_Vpblendw_xmm_xmm_xmmm128_imm8
public Code VEX_Vpblendw_ymm_ymm_ymmm256_imm8
public Code Palignr_mm_mmm64_imm8
public Code Palignr_xmm_xmmm128_imm8
public Code VEX_Vpalignr_xmm_xmm_xmmm128_imm8
public Code VEX_Vpalignr_ymm_ymm_ymmm256_imm8
public Code EVEX_Vpalignr_xmm_k1z_xmm_xmmm128_imm8
public Code EVEX_Vpalignr_ymm_k1z_ymm_ymmm256_imm8
public Code EVEX_Vpalignr_zmm_k1z_zmm_zmmm512_imm8
public Code Pextrb_r32m8_xmm_imm8
public Code Pextrb_r64m8_xmm_imm8
public Code VEX_Vpextrb_r32m8_xmm_imm8
public Code VEX_Vpextrb_r64m8_xmm_imm8
public Code EVEX_Vpextrb_r32m8_xmm_imm8
public Code EVEX_Vpextrb_r64m8_xmm_imm8
public Code Pextrw_r32m16_xmm_imm8
public Code Pextrw_r64m16_xmm_imm8
public Code VEX_Vpextrw_r32m16_xmm_imm8
public Code VEX_Vpextrw_r64m16_xmm_imm8
public Code EVEX_Vpextrw_r32m16_xmm_imm8
public Code EVEX_Vpextrw_r64m16_xmm_imm8
public Code Pextrd_rm32_xmm_imm8
public Code Pextrq_rm64_xmm_imm8
public Code VEX_Vpextrd_rm32_xmm_imm8
public Code VEX_Vpextrq_rm64_xmm_imm8
public Code EVEX_Vpextrd_rm32_xmm_imm8
public Code EVEX_Vpextrq_rm64_xmm_imm8
public Code Extractps_rm32_xmm_imm8
public Code Extractps_r64m32_xmm_imm8
public Code VEX_Vextractps_rm32_xmm_imm8
public Code VEX_Vextractps_r64m32_xmm_imm8
public Code EVEX_Vextractps_rm32_xmm_imm8
public Code EVEX_Vextractps_r64m32_xmm_imm8
public Code VEX_Vinsertf128_ymm_ymm_xmmm128_imm8
public Code EVEX_Vinsertf32x4_ymm_k1z_ymm_xmmm128_imm8
public Code EVEX_Vinsertf32x4_zmm_k1z_zmm_xmmm128_imm8
public Code EVEX_Vinsertf64x2_ymm_k1z_ymm_xmmm128_imm8
public Code EVEX_Vinsertf64x2_zmm_k1z_zmm_xmmm128_imm8
public Code VEX_Vextractf128_xmmm128_ymm_imm8
public Code EVEX_Vextractf32x4_xmmm128_k1z_ymm_imm8
public Code EVEX_Vextractf32x4_xmmm128_k1z_zmm_imm8
public Code EVEX_Vextractf64x2_xmmm128_k1z_ymm_imm8
public Code EVEX_Vextractf64x2_xmmm128_k1z_zmm_imm8
public Code EVEX_Vinsertf32x8_zmm_k1z_zmm_ymmm256_imm8
public Code EVEX_Vinsertf64x4_zmm_k1z_zmm_ymmm256_imm8
public Code EVEX_Vextractf32x8_ymmm256_k1z_zmm_imm8
public Code EVEX_Vextractf64x4_ymmm256_k1z_zmm_imm8
public Code VEX_Vcvtps2ph_xmmm64_xmm_imm8
public Code VEX_Vcvtps2ph_xmmm128_ymm_imm8
public Code EVEX_Vcvtps2ph_xmmm64_k1z_xmm_imm8
public Code EVEX_Vcvtps2ph_xmmm128_k1z_ymm_imm8
public Code EVEX_Vcvtps2ph_ymmm256_k1z_zmm_imm8_sae
public Code EVEX_Vpcmpud_kr_k1_xmm_xmmm128b32_imm8
public Code EVEX_Vpcmpud_kr_k1_ymm_ymmm256b32_imm8
public Code EVEX_Vpcmpud_kr_k1_zmm_zmmm512b32_imm8
public Code EVEX_Vpcmpuq_kr_k1_xmm_xmmm128b64_imm8
public Code EVEX_Vpcmpuq_kr_k1_ymm_ymmm256b64_imm8
public Code EVEX_Vpcmpuq_kr_k1_zmm_zmmm512b64_imm8
public Code EVEX_Vpcmpd_kr_k1_xmm_xmmm128b32_imm8
public Code EVEX_Vpcmpd_kr_k1_ymm_ymmm256b32_imm8
public Code EVEX_Vpcmpd_kr_k1_zmm_zmmm512b32_imm8
public Code EVEX_Vpcmpq_kr_k1_xmm_xmmm128b64_imm8
public Code EVEX_Vpcmpq_kr_k1_ymm_ymmm256b64_imm8
public Code EVEX_Vpcmpq_kr_k1_zmm_zmmm512b64_imm8
public Code Pinsrb_xmm_r32m8_imm8
public Code Pinsrb_xmm_r64m8_imm8
public Code VEX_Vpinsrb_xmm_xmm_r32m8_imm8
public Code VEX_Vpinsrb_xmm_xmm_r64m8_imm8
public Code EVEX_Vpinsrb_xmm_xmm_r32m8_imm8
public Code EVEX_Vpinsrb_xmm_xmm_r64m8_imm8
public Code Insertps_xmm_xmmm32_imm8
public Code VEX_Vinsertps_xmm_xmm_xmmm32_imm8
public Code EVEX_Vinsertps_xmm_xmm_xmmm32_imm8
public Code Pinsrd_xmm_rm32_imm8
public Code Pinsrq_xmm_rm64_imm8
public Code VEX_Vpinsrd_xmm_xmm_rm32_imm8
public Code VEX_Vpinsrq_xmm_xmm_rm64_imm8
public Code EVEX_Vpinsrd_xmm_xmm_rm32_imm8
public Code EVEX_Vpinsrq_xmm_xmm_rm64_imm8
public Code EVEX_Vshuff32x4_ymm_k1z_ymm_ymmm256b32_imm8
public Code EVEX_Vshuff32x4_zmm_k1z_zmm_zmmm512b32_imm8
public Code EVEX_Vshuff64x2_ymm_k1z_ymm_ymmm256b64_imm8
public Code EVEX_Vshuff64x2_zmm_k1z_zmm_zmmm512b64_imm8
public Code EVEX_Vpternlogd_xmm_k1z_xmm_xmmm128b32_imm8
public Code EVEX_Vpternlogd_ymm_k1z_ymm_ymmm256b32_imm8
public Code EVEX_Vpternlogd_zmm_k1z_zmm_zmmm512b32_imm8
public Code EVEX_Vpternlogq_xmm_k1z_xmm_xmmm128b64_imm8
public Code EVEX_Vpternlogq_ymm_k1z_ymm_ymmm256b64_imm8
public Code EVEX_Vpternlogq_zmm_k1z_zmm_zmmm512b64_imm8
public Code EVEX_Vgetmantps_xmm_k1z_xmmm128b32_imm8
public Code EVEX_Vgetmantps_ymm_k1z_ymmm256b32_imm8
public Code EVEX_Vgetmantps_zmm_k1z_zmmm512b32_imm8_sae
public Code EVEX_Vgetmantpd_xmm_k1z_xmmm128b64_imm8
public Code EVEX_Vgetmantpd_ymm_k1z_ymmm256b64_imm8
public Code EVEX_Vgetmantpd_zmm_k1z_zmmm512b64_imm8_sae
public Code EVEX_Vgetmantss_xmm_k1z_xmm_xmmm32_imm8_sae
public Code EVEX_Vgetmantsd_xmm_k1z_xmm_xmmm64_imm8_sae
public Code VEX_Kshiftrb_kr_kr_imm8
public Code VEX_Kshiftrw_kr_kr_imm8
public Code VEX_Kshiftrd_kr_kr_imm8
public Code VEX_Kshiftrq_kr_kr_imm8
public Code VEX_Kshiftlb_kr_kr_imm8
public Code VEX_Kshiftlw_kr_kr_imm8
public Code VEX_Kshiftld_kr_kr_imm8
public Code VEX_Kshiftlq_kr_kr_imm8
public Code VEX_Vinserti128_ymm_ymm_xmmm128_imm8
public Code EVEX_Vinserti32x4_ymm_k1z_ymm_xmmm128_imm8
public Code EVEX_Vinserti32x4_zmm_k1z_zmm_xmmm128_imm8
public Code EVEX_Vinserti64x2_ymm_k1z_ymm_xmmm128_imm8
public Code EVEX_Vinserti64x2_zmm_k1z_zmm_xmmm128_imm8
public Code VEX_Vextracti128_xmmm128_ymm_imm8
public Code EVEX_Vextracti32x4_xmmm128_k1z_ymm_imm8
public Code EVEX_Vextracti32x4_xmmm128_k1z_zmm_imm8
public Code EVEX_Vextracti64x2_xmmm128_k1z_ymm_imm8
public Code EVEX_Vextracti64x2_xmmm128_k1z_zmm_imm8
public Code EVEX_Vinserti32x8_zmm_k1z_zmm_ymmm256_imm8
public Code EVEX_Vinserti64x4_zmm_k1z_zmm_ymmm256_imm8
public Code EVEX_Vextracti32x8_ymmm256_k1z_zmm_imm8
public Code EVEX_Vextracti64x4_ymmm256_k1z_zmm_imm8
public Code EVEX_Vpcmpub_kr_k1_xmm_xmmm128_imm8
public Code EVEX_Vpcmpub_kr_k1_ymm_ymmm256_imm8
public Code EVEX_Vpcmpub_kr_k1_zmm_zmmm512_imm8
public Code EVEX_Vpcmpuw_kr_k1_xmm_xmmm128_imm8
public Code EVEX_Vpcmpuw_kr_k1_ymm_ymmm256_imm8
public Code EVEX_Vpcmpuw_kr_k1_zmm_zmmm512_imm8
public Code EVEX_Vpcmpb_kr_k1_xmm_xmmm128_imm8
public Code EVEX_Vpcmpb_kr_k1_ymm_ymmm256_imm8
public Code EVEX_Vpcmpb_kr_k1_zmm_zmmm512_imm8
public Code EVEX_Vpcmpw_kr_k1_xmm_xmmm128_imm8
public Code EVEX_Vpcmpw_kr_k1_ymm_ymmm256_imm8
public Code EVEX_Vpcmpw_kr_k1_zmm_zmmm512_imm8
public Code Dpps_xmm_xmmm128_imm8
public Code VEX_Vdpps_xmm_xmm_xmmm128_imm8
public Code VEX_Vdpps_ymm_ymm_ymmm256_imm8
public Code Dppd_xmm_xmmm128_imm8
public Code VEX_Vdppd_xmm_xmm_xmmm128_imm8
public Code Mpsadbw_xmm_xmmm128_imm8
public Code VEX_Vmpsadbw_xmm_xmm_xmmm128_imm8
public Code VEX_Vmpsadbw_ymm_ymm_ymmm256_imm8
public Code EVEX_Vdbpsadbw_xmm_k1z_xmm_xmmm128_imm8
public Code EVEX_Vdbpsadbw_ymm_k1z_ymm_ymmm256_imm8
public Code EVEX_Vdbpsadbw_zmm_k1z_zmm_zmmm512_imm8
public Code EVEX_Vshufi32x4_ymm_k1z_ymm_ymmm256b32_imm8
public Code EVEX_Vshufi32x4_zmm_k1z_zmm_zmmm512b32_imm8
public Code EVEX_Vshufi64x2_ymm_k1z_ymm_ymmm256b64_imm8
public Code EVEX_Vshufi64x2_zmm_k1z_zmm_zmmm512b64_imm8
public Code Pclmulqdq_xmm_xmmm128_imm8
public Code VEX_Vpclmulqdq_xmm_xmm_xmmm128_imm8
public Code VEX_Vpclmulqdq_ymm_ymm_ymmm256_imm8
public Code EVEX_Vpclmulqdq_xmm_xmm_xmmm128_imm8
public Code EVEX_Vpclmulqdq_ymm_ymm_ymmm256_imm8
public Code EVEX_Vpclmulqdq_zmm_zmm_zmmm512_imm8
public Code VEX_Vperm2i128_ymm_ymm_ymmm256_imm8
public Code VEX_Vpermil2ps_xmm_xmm_xmmm128_xmm_imm4
public Code VEX_Vpermil2ps_ymm_ymm_ymmm256_ymm_imm4
public Code VEX_Vpermil2ps_xmm_xmm_xmm_xmmm128_imm4
public Code VEX_Vpermil2ps_ymm_ymm_ymm_ymmm256_imm4
public Code VEX_Vpermil2pd_xmm_xmm_xmmm128_xmm_imm4
public Code VEX_Vpermil2pd_ymm_ymm_ymmm256_ymm_imm4
public Code VEX_Vpermil2pd_xmm_xmm_xmm_xmmm128_imm4
public Code VEX_Vpermil2pd_ymm_ymm_ymm_ymmm256_imm4
public Code VEX_Vblendvps_xmm_xmm_xmmm128_xmm
public Code VEX_Vblendvps_ymm_ymm_ymmm256_ymm
public Code VEX_Vblendvpd_xmm_xmm_xmmm128_xmm
public Code VEX_Vblendvpd_ymm_ymm_ymmm256_ymm
public Code VEX_Vpblendvb_xmm_xmm_xmmm128_xmm
public Code VEX_Vpblendvb_ymm_ymm_ymmm256_ymm
public Code EVEX_Vrangeps_xmm_k1z_xmm_xmmm128b32_imm8
public Code EVEX_Vrangeps_ymm_k1z_ymm_ymmm256b32_imm8
public Code EVEX_Vrangeps_zmm_k1z_zmm_zmmm512b32_imm8_sae
public Code EVEX_Vrangepd_xmm_k1z_xmm_xmmm128b64_imm8
public Code EVEX_Vrangepd_ymm_k1z_ymm_ymmm256b64_imm8
public Code EVEX_Vrangepd_zmm_k1z_zmm_zmmm512b64_imm8_sae
public Code EVEX_Vrangess_xmm_k1z_xmm_xmmm32_imm8_sae
public Code EVEX_Vrangesd_xmm_k1z_xmm_xmmm64_imm8_sae
public Code EVEX_Vfixupimmps_xmm_k1z_xmm_xmmm128b32_imm8
public Code EVEX_Vfixupimmps_ymm_k1z_ymm_ymmm256b32_imm8
public Code EVEX_Vfixupimmps_zmm_k1z_zmm_zmmm512b32_imm8_sae
public Code EVEX_Vfixupimmpd_xmm_k1z_xmm_xmmm128b64_imm8
public Code EVEX_Vfixupimmpd_ymm_k1z_ymm_ymmm256b64_imm8
public Code EVEX_Vfixupimmpd_zmm_k1z_zmm_zmmm512b64_imm8_sae
public Code EVEX_Vfixupimmss_xmm_k1z_xmm_xmmm32_imm8_sae
public Code EVEX_Vfixupimmsd_xmm_k1z_xmm_xmmm64_imm8_sae
public Code EVEX_Vreduceps_xmm_k1z_xmmm128b32_imm8
public Code EVEX_Vreduceps_ymm_k1z_ymmm256b32_imm8
public Code EVEX_Vreduceps_zmm_k1z_zmmm512b32_imm8_sae
public Code EVEX_Vreducepd_xmm_k1z_xmmm128b64_imm8
public Code EVEX_Vreducepd_ymm_k1z_ymmm256b64_imm8
public Code EVEX_Vreducepd_zmm_k1z_zmmm512b64_imm8_sae
public Code EVEX_Vreducess_xmm_k1z_xmm_xmmm32_imm8_sae
public Code EVEX_Vreducesd_xmm_k1z_xmm_xmmm64_imm8_sae
public Code VEX_Vfmaddsubps_xmm_xmm_xmmm128_xmm
public Code VEX_Vfmaddsubps_ymm_ymm_ymmm256_ymm
public Code VEX_Vfmaddsubps_xmm_xmm_xmm_xmmm128
public Code VEX_Vfmaddsubps_ymm_ymm_ymm_ymmm256
public Code VEX_Vfmaddsubpd_xmm_xmm_xmmm128_xmm
public Code VEX_Vfmaddsubpd_ymm_ymm_ymmm256_ymm
public Code VEX_Vfmaddsubpd_xmm_xmm_xmm_xmmm128
public Code VEX_Vfmaddsubpd_ymm_ymm_ymm_ymmm256
public Code VEX_Vfmsubaddps_xmm_xmm_xmmm128_xmm
public Code VEX_Vfmsubaddps_ymm_ymm_ymmm256_ymm
public Code VEX_Vfmsubaddps_xmm_xmm_xmm_xmmm128
public Code VEX_Vfmsubaddps_ymm_ymm_ymm_ymmm256
public Code VEX_Vfmsubaddpd_xmm_xmm_xmmm128_xmm
public Code VEX_Vfmsubaddpd_ymm_ymm_ymmm256_ymm
public Code VEX_Vfmsubaddpd_xmm_xmm_xmm_xmmm128
public Code VEX_Vfmsubaddpd_ymm_ymm_ymm_ymmm256
public Code Pcmpestrm_xmm_xmmm128_imm8
public Code Pcmpestrm64_xmm_xmmm128_imm8
public Code VEX_Vpcmpestrm_xmm_xmmm128_imm8
public Code VEX_Vpcmpestrm64_xmm_xmmm128_imm8
public Code Pcmpestri_xmm_xmmm128_imm8
public Code Pcmpestri64_xmm_xmmm128_imm8
public Code VEX_Vpcmpestri_xmm_xmmm128_imm8
public Code VEX_Vpcmpestri64_xmm_xmmm128_imm8
public Code Pcmpistrm_xmm_xmmm128_imm8
public Code VEX_Vpcmpistrm_xmm_xmmm128_imm8
public Code Pcmpistri_xmm_xmmm128_imm8
public Code VEX_Vpcmpistri_xmm_xmmm128_imm8
public Code EVEX_Vfpclassps_kr_k1_xmmm128b32_imm8
public Code EVEX_Vfpclassps_kr_k1_ymmm256b32_imm8
public Code EVEX_Vfpclassps_kr_k1_zmmm512b32_imm8
public Code EVEX_Vfpclasspd_kr_k1_xmmm128b64_imm8
public Code EVEX_Vfpclasspd_kr_k1_ymmm256b64_imm8
public Code EVEX_Vfpclasspd_kr_k1_zmmm512b64_imm8
public Code EVEX_Vfpclassss_kr_k1_xmmm32_imm8
public Code EVEX_Vfpclasssd_kr_k1_xmmm64_imm8
public Code VEX_Vfmaddps_xmm_xmm_xmmm128_xmm
public Code VEX_Vfmaddps_ymm_ymm_ymmm256_ymm
public Code VEX_Vfmaddps_xmm_xmm_xmm_xmmm128
public Code VEX_Vfmaddps_ymm_ymm_ymm_ymmm256
public Code VEX_Vfmaddpd_xmm_xmm_xmmm128_xmm
public Code VEX_Vfmaddpd_ymm_ymm_ymmm256_ymm
public Code VEX_Vfmaddpd_xmm_xmm_xmm_xmmm128
public Code VEX_Vfmaddpd_ymm_ymm_ymm_ymmm256
public Code VEX_Vfmaddss_xmm_xmm_xmmm32_xmm
public Code VEX_Vfmaddss_xmm_xmm_xmm_xmmm32
public Code VEX_Vfmaddsd_xmm_xmm_xmmm64_xmm
public Code VEX_Vfmaddsd_xmm_xmm_xmm_xmmm64
public Code VEX_Vfmsubps_xmm_xmm_xmmm128_xmm
public Code VEX_Vfmsubps_ymm_ymm_ymmm256_ymm
public Code VEX_Vfmsubps_xmm_xmm_xmm_xmmm128
public Code VEX_Vfmsubps_ymm_ymm_ymm_ymmm256
public Code VEX_Vfmsubpd_xmm_xmm_xmmm128_xmm
public Code VEX_Vfmsubpd_ymm_ymm_ymmm256_ymm
public Code VEX_Vfmsubpd_xmm_xmm_xmm_xmmm128
public Code VEX_Vfmsubpd_ymm_ymm_ymm_ymmm256
public Code VEX_Vfmsubss_xmm_xmm_xmmm32_xmm
public Code VEX_Vfmsubss_xmm_xmm_xmm_xmmm32
public Code VEX_Vfmsubsd_xmm_xmm_xmmm64_xmm
public Code VEX_Vfmsubsd_xmm_xmm_xmm_xmmm64
public Code EVEX_Vpshldw_xmm_k1z_xmm_xmmm128_imm8
public Code EVEX_Vpshldw_ymm_k1z_ymm_ymmm256_imm8
public Code EVEX_Vpshldw_zmm_k1z_zmm_zmmm512_imm8
public Code EVEX_Vpshldd_xmm_k1z_xmm_xmmm128b32_imm8
public Code EVEX_Vpshldd_ymm_k1z_ymm_ymmm256b32_imm8
public Code EVEX_Vpshldd_zmm_k1z_zmm_zmmm512b32_imm8
public Code EVEX_Vpshldq_xmm_k1z_xmm_xmmm128b64_imm8
public Code EVEX_Vpshldq_ymm_k1z_ymm_ymmm256b64_imm8
public Code EVEX_Vpshldq_zmm_k1z_zmm_zmmm512b64_imm8
public Code EVEX_Vpshrdw_xmm_k1z_xmm_xmmm128_imm8
public Code EVEX_Vpshrdw_ymm_k1z_ymm_ymmm256_imm8
public Code EVEX_Vpshrdw_zmm_k1z_zmm_zmmm512_imm8
public Code EVEX_Vpshrdd_xmm_k1z_xmm_xmmm128b32_imm8
public Code EVEX_Vpshrdd_ymm_k1z_ymm_ymmm256b32_imm8
public Code EVEX_Vpshrdd_zmm_k1z_zmm_zmmm512b32_imm8
public Code EVEX_Vpshrdq_xmm_k1z_xmm_xmmm128b64_imm8
public Code EVEX_Vpshrdq_ymm_k1z_ymm_ymmm256b64_imm8
public Code EVEX_Vpshrdq_zmm_k1z_zmm_zmmm512b64_imm8
public Code VEX_Vfnmaddps_xmm_xmm_xmmm128_xmm
public Code VEX_Vfnmaddps_ymm_ymm_ymmm256_ymm
public Code VEX_Vfnmaddps_xmm_xmm_xmm_xmmm128
public Code VEX_Vfnmaddps_ymm_ymm_ymm_ymmm256
public Code VEX_Vfnmaddpd_xmm_xmm_xmmm128_xmm
public Code VEX_Vfnmaddpd_ymm_ymm_ymmm256_ymm
public Code VEX_Vfnmaddpd_xmm_xmm_xmm_xmmm128
public Code VEX_Vfnmaddpd_ymm_ymm_ymm_ymmm256
public Code VEX_Vfnmaddss_xmm_xmm_xmmm32_xmm
public Code VEX_Vfnmaddss_xmm_xmm_xmm_xmmm32
public Code VEX_Vfnmaddsd_xmm_xmm_xmmm64_xmm
public Code VEX_Vfnmaddsd_xmm_xmm_xmm_xmmm64
public Code VEX_Vfnmsubps_xmm_xmm_xmmm128_xmm
public Code VEX_Vfnmsubps_ymm_ymm_ymmm256_ymm
public Code VEX_Vfnmsubps_xmm_xmm_xmm_xmmm128
public Code VEX_Vfnmsubps_ymm_ymm_ymm_ymmm256
public Code VEX_Vfnmsubpd_xmm_xmm_xmmm128_xmm
public Code VEX_Vfnmsubpd_ymm_ymm_ymmm256_ymm
public Code VEX_Vfnmsubpd_xmm_xmm_xmm_xmmm128
public Code VEX_Vfnmsubpd_ymm_ymm_ymm_ymmm256
public Code VEX_Vfnmsubss_xmm_xmm_xmmm32_xmm
public Code VEX_Vfnmsubss_xmm_xmm_xmm_xmmm32
public Code VEX_Vfnmsubsd_xmm_xmm_xmmm64_xmm
public Code VEX_Vfnmsubsd_xmm_xmm_xmm_xmmm64
public Code Sha1rnds4_xmm_xmmm128_imm8
public Code Gf2p8affineqb_xmm_xmmm128_imm8
public Code VEX_Vgf2p8affineqb_xmm_xmm_xmmm128_imm8
public Code VEX_Vgf2p8affineqb_ymm_ymm_ymmm256_imm8
public Code EVEX_Vgf2p8affineqb_xmm_k1z_xmm_xmmm128b64_imm8
public Code EVEX_Vgf2p8affineqb_ymm_k1z_ymm_ymmm256b64_imm8
public Code EVEX_Vgf2p8affineqb_zmm_k1z_zmm_zmmm512b64_imm8
public Code Gf2p8affineinvqb_xmm_xmmm128_imm8
public Code VEX_Vgf2p8affineinvqb_xmm_xmm_xmmm128_imm8
public Code VEX_Vgf2p8affineinvqb_ymm_ymm_ymmm256_imm8
public Code EVEX_Vgf2p8affineinvqb_xmm_k1z_xmm_xmmm128b64_imm8
public Code EVEX_Vgf2p8affineinvqb_ymm_k1z_ymm_ymmm256b64_imm8
public Code EVEX_Vgf2p8affineinvqb_zmm_k1z_zmm_zmmm512b64_imm8
public Code Aeskeygenassist_xmm_xmmm128_imm8
public Code VEX_Vaeskeygenassist_xmm_xmmm128_imm8
public Code VEX_Rorx_r32_rm32_imm8
public Code VEX_Rorx_r64_rm64_imm8
public Code XOP_Vpmacssww_xmm_xmm_xmmm128_xmm
public Code XOP_Vpmacsswd_xmm_xmm_xmmm128_xmm
public Code XOP_Vpmacssdql_xmm_xmm_xmmm128_xmm
public Code XOP_Vpmacssdd_xmm_xmm_xmmm128_xmm
public Code XOP_Vpmacssdqh_xmm_xmm_xmmm128_xmm
public Code XOP_Vpmacsww_xmm_xmm_xmmm128_xmm
public Code XOP_Vpmacswd_xmm_xmm_xmmm128_xmm
public Code XOP_Vpmacsdql_xmm_xmm_xmmm128_xmm
public Code XOP_Vpmacsdd_xmm_xmm_xmmm128_xmm
public Code XOP_Vpmacsdqh_xmm_xmm_xmmm128_xmm
public Code XOP_Vpcmov_xmm_xmm_xmmm128_xmm
public Code XOP_Vpcmov_ymm_ymm_ymmm256_ymm
public Code XOP_Vpcmov_xmm_xmm_xmm_xmmm128
public Code XOP_Vpcmov_ymm_ymm_ymm_ymmm256
public Code XOP_Vpperm_xmm_xmm_xmmm128_xmm
public Code XOP_Vpperm_xmm_xmm_xmm_xmmm128
public Code XOP_Vpmadcsswd_xmm_xmm_xmmm128_xmm
public Code XOP_Vpmadcswd_xmm_xmm_xmmm128_xmm
public Code XOP_Vprotb_xmm_xmmm128_imm8
public Code XOP_Vprotw_xmm_xmmm128_imm8
public Code XOP_Vprotd_xmm_xmmm128_imm8
public Code XOP_Vprotq_xmm_xmmm128_imm8
public Code XOP_Vpcomb_xmm_xmm_xmmm128_imm8
public Code XOP_Vpcomw_xmm_xmm_xmmm128_imm8
public Code XOP_Vpcomd_xmm_xmm_xmmm128_imm8
public Code XOP_Vpcomq_xmm_xmm_xmmm128_imm8
public Code XOP_Vpcomub_xmm_xmm_xmmm128_imm8
public Code XOP_Vpcomuw_xmm_xmm_xmmm128_imm8
public Code XOP_Vpcomud_xmm_xmm_xmmm128_imm8
public Code XOP_Vpcomuq_xmm_xmm_xmmm128_imm8
public Code XOP_Blcfill_r32_rm32
public Code XOP_Blcfill_r64_rm64
public Code XOP_Blsfill_r32_rm32
public Code XOP_Blsfill_r64_rm64
public Code XOP_Blcs_r32_rm32
public Code XOP_Blcs_r64_rm64
public Code XOP_Tzmsk_r32_rm32
public Code XOP_Tzmsk_r64_rm64
public Code XOP_Blcic_r32_rm32
public Code XOP_Blcic_r64_rm64
public Code XOP_Blsic_r32_rm32
public Code XOP_Blsic_r64_rm64
public Code XOP_T1mskc_r32_rm32
public Code XOP_T1mskc_r64_rm64
public Code XOP_Blcmsk_r32_rm32
public Code XOP_Blcmsk_r64_rm64
public Code XOP_Blci_r32_rm32
public Code XOP_Blci_r64_rm64
public Code XOP_Llwpcb_r32
public Code XOP_Llwpcb_r64
public Code XOP_Slwpcb_r32
public Code XOP_Slwpcb_r64
public Code XOP_Vfrczps_xmm_xmmm128
public Code XOP_Vfrczps_ymm_ymmm256
public Code XOP_Vfrczpd_xmm_xmmm128
public Code XOP_Vfrczpd_ymm_ymmm256
public Code XOP_Vfrczss_xmm_xmmm32
public Code XOP_Vfrczsd_xmm_xmmm64
public Code XOP_Vprotb_xmm_xmmm128_xmm
public Code XOP_Vprotb_xmm_xmm_xmmm128
public Code XOP_Vprotw_xmm_xmmm128_xmm
public Code XOP_Vprotw_xmm_xmm_xmmm128
public Code XOP_Vprotd_xmm_xmmm128_xmm
public Code XOP_Vprotd_xmm_xmm_xmmm128
public Code XOP_Vprotq_xmm_xmmm128_xmm
public Code XOP_Vprotq_xmm_xmm_xmmm128
public Code XOP_Vpshlb_xmm_xmmm128_xmm
public Code XOP_Vpshlb_xmm_xmm_xmmm128
public Code XOP_Vpshlw_xmm_xmmm128_xmm
public Code XOP_Vpshlw_xmm_xmm_xmmm128
public Code XOP_Vpshld_xmm_xmmm128_xmm
public Code XOP_Vpshld_xmm_xmm_xmmm128
public Code XOP_Vpshlq_xmm_xmmm128_xmm
public Code XOP_Vpshlq_xmm_xmm_xmmm128
public Code XOP_Vpshab_xmm_xmmm128_xmm
public Code XOP_Vpshab_xmm_xmm_xmmm128
public Code XOP_Vpshaw_xmm_xmmm128_xmm
public Code XOP_Vpshaw_xmm_xmm_xmmm128
public Code XOP_Vpshad_xmm_xmmm128_xmm
public Code XOP_Vpshad_xmm_xmm_xmmm128
public Code XOP_Vpshaq_xmm_xmmm128_xmm
public Code XOP_Vpshaq_xmm_xmm_xmmm128
public Code XOP_Vphaddbw_xmm_xmmm128
public Code XOP_Vphaddbd_xmm_xmmm128
public Code XOP_Vphaddbq_xmm_xmmm128
public Code XOP_Vphaddwd_xmm_xmmm128
public Code XOP_Vphaddwq_xmm_xmmm128
public Code XOP_Vphadddq_xmm_xmmm128
public Code XOP_Vphaddubw_xmm_xmmm128
public Code XOP_Vphaddubd_xmm_xmmm128
public Code XOP_Vphaddubq_xmm_xmmm128
public Code XOP_Vphadduwd_xmm_xmmm128
public Code XOP_Vphadduwq_xmm_xmmm128
public Code XOP_Vphaddudq_xmm_xmmm128
public Code XOP_Vphsubbw_xmm_xmmm128
public Code XOP_Vphsubwd_xmm_xmmm128
public Code XOP_Vphsubdq_xmm_xmmm128
public Code XOP_Bextr_r32_rm32_imm32
public Code XOP_Bextr_r64_rm64_imm32
public Code XOP_Lwpins_r32_rm32_imm32
public Code XOP_Lwpins_r64_rm32_imm32
public Code XOP_Lwpval_r32_rm32_imm32
public Code XOP_Lwpval_r64_rm32_imm32
public Code D3NOW_Pi2fw_mm_mmm64
public Code D3NOW_Pi2fd_mm_mmm64
public Code D3NOW_Pf2iw_mm_mmm64
public Code D3NOW_Pf2id_mm_mmm64
public Code D3NOW_Pfrcpv_mm_mmm64
public Code D3NOW_Pfrsqrtv_mm_mmm64
public Code D3NOW_Pfnacc_mm_mmm64
public Code D3NOW_Pfpnacc_mm_mmm64
public Code D3NOW_Pfcmpge_mm_mmm64
public Code D3NOW_Pfmin_mm_mmm64
public Code D3NOW_Pfrcp_mm_mmm64
public Code D3NOW_Pfrsqrt_mm_mmm64
public Code D3NOW_Pfsub_mm_mmm64
public Code D3NOW_Pfadd_mm_mmm64
public Code D3NOW_Pfcmpgt_mm_mmm64
public Code D3NOW_Pfmax_mm_mmm64
public Code D3NOW_Pfrcpit1_mm_mmm64
public Code D3NOW_Pfrsqit1_mm_mmm64
public Code D3NOW_Pfsubr_mm_mmm64
public Code D3NOW_Pfacc_mm_mmm64
public Code D3NOW_Pfcmpeq_mm_mmm64
public Code D3NOW_Pfmul_mm_mmm64
public Code D3NOW_Pfrcpit2_mm_mmm64
public Code D3NOW_Pmulhrw_mm_mmm64
public Code D3NOW_Pswapd_mm_mmm64
public Code D3NOW_Pavgusb_mm_mmm64
public Code Rmpadjust
public Code Rmpupdate
public Code Psmash
public Code Pvalidatew
public Code Pvalidated
public Code Pvalidateq
public Code Serialize
public Code Xsusldtrk
public Code Xresldtrk
public Code Invlpgbw
public Code Invlpgbd
public Code Invlpgbq
public Code Tlbsync
public Code Prefetchreserved3_m8
public Code Prefetchreserved4_m8
public Code Prefetchreserved5_m8
public Code Prefetchreserved6_m8
public Code Prefetchreserved7_m8
public Code Ud0
public Code Vmgexit
public Code Getsecq
public Code VEX_Ldtilecfg_m512
public Code VEX_Tilerelease
public Code VEX_Sttilecfg_m512
public Code VEX_Tilezero_tmm
public Code VEX_Tileloaddt1_tmm_sibmem
public Code VEX_Tilestored_sibmem_tmm
public Code VEX_Tileloadd_tmm_sibmem
public Code VEX_Tdpbf16ps_tmm_tmm_tmm
public Code VEX_Tdpbuud_tmm_tmm_tmm
public Code VEX_Tdpbusd_tmm_tmm_tmm
public Code VEX_Tdpbsud_tmm_tmm_tmm
public Code VEX_Tdpbssd_tmm_tmm_tmm
public Code Fnstdw_AX
public Code Fnstsg_AX
public Code Rdshr_rm32
public Code Wrshr_rm32
public Code Smint
public Code Dmint
public Code Rdm
public Code Svdc_m80_Sreg
public Code Rsdc_Sreg_m80
public Code Svldt_m80
public Code Rsldt_m80
public Code Svts_m80
public Code Rsts_m80
public Code Smint_0F7E
public Code Bb0_reset
public Code Bb1_reset
public Code Cpu_write
public Code Cpu_read
public Code Altinst
public Code Paveb_mm_mmm64
public Code Paddsiw_mm_mmm64
public Code Pmagw_mm_mmm64
public Code Pdistib_mm_m64
public Code Psubsiw_mm_mmm64
public Code Pmvzb_mm_m64
public Code Pmulhrw_mm_mmm64
public Code Pmvnzb_mm_m64
public Code Pmvlzb_mm_m64
public Code Pmvgezb_mm_m64
public Code Pmulhriw_mm_mmm64
public Code Pmachriw_mm_m64
public Code Cyrix_D9D7
public Code Cyrix_D9E2
public Code Ftstp
public Code Cyrix_D9E7
public Code Frint2
public Code Frichop
public Code Cyrix_DED8
public Code Cyrix_DEDA
public Code Cyrix_DEDC
public Code Cyrix_DEDD
public Code Cyrix_DEDE
public Code Frinear
public Code Tdcall
public Code Seamret
public Code Seamops
public Code Seamcall
public Code Aesencwide128kl_m384
public Code Aesdecwide128kl_m384
public Code Aesencwide256kl_m512
public Code Aesdecwide256kl_m512
public Code Loadiwkey_xmm_xmm
public Code Aesenc128kl_xmm_m384
public Code Aesdec128kl_xmm_m384
public Code Aesenc256kl_xmm_m512
public Code Aesdec256kl_xmm_m512
public Code Encodekey128_r32_r32
public Code Encodekey256_r32_r32
public Code VEX_Vbroadcastss_xmm_xmm
public Code VEX_Vbroadcastss_ymm_xmm
public Code VEX_Vbroadcastsd_ymm_xmm
public Code Vmgexit_F2
public Code Uiret
public Code Testui
public Code Clui
public Code Stui
public Code Senduipi_r64
public Code Hreset_imm8
public Code VEX_Vpdpbusd_xmm_xmm_xmmm128
public Code VEX_Vpdpbusd_ymm_ymm_ymmm256
public Code VEX_Vpdpbusds_xmm_xmm_xmmm128
public Code VEX_Vpdpbusds_ymm_ymm_ymmm256
public Code VEX_Vpdpwssd_xmm_xmm_xmmm128
public Code VEX_Vpdpwssd_ymm_ymm_ymmm256
public Code VEX_Vpdpwssds_xmm_xmm_xmmm128
public Code VEX_Vpdpwssds_ymm_ymm_ymmm256
public Code Ccs_hash_16
public Code Ccs_hash_32
public Code Ccs_hash_64
public Code Ccs_encrypt_16
public Code Ccs_encrypt_32
public Code Ccs_encrypt_64
public Code Lkgs_rm16
public Code Lkgs_r32m16
public Code Lkgs_r64m16
public Code Eretu
public Code Erets
public Code EVEX_Vaddph_xmm_k1z_xmm_xmmm128b16
public Code EVEX_Vaddph_ymm_k1z_ymm_ymmm256b16
public Code EVEX_Vaddph_zmm_k1z_zmm_zmmm512b16_er
public Code EVEX_Vaddsh_xmm_k1z_xmm_xmmm16_er
public Code EVEX_Vcmpph_kr_k1_xmm_xmmm128b16_imm8
public Code EVEX_Vcmpph_kr_k1_ymm_ymmm256b16_imm8
public Code EVEX_Vcmpph_kr_k1_zmm_zmmm512b16_imm8_sae
public Code EVEX_Vcmpsh_kr_k1_xmm_xmmm16_imm8_sae
public Code EVEX_Vcomish_xmm_xmmm16_sae
public Code EVEX_Vcvtdq2ph_xmm_k1z_xmmm128b32
public Code EVEX_Vcvtdq2ph_xmm_k1z_ymmm256b32
public Code EVEX_Vcvtdq2ph_ymm_k1z_zmmm512b32_er
public Code EVEX_Vcvtpd2ph_xmm_k1z_xmmm128b64
public Code EVEX_Vcvtpd2ph_xmm_k1z_ymmm256b64
public Code EVEX_Vcvtpd2ph_xmm_k1z_zmmm512b64_er
public Code EVEX_Vcvtph2dq_xmm_k1z_xmmm64b16
public Code EVEX_Vcvtph2dq_ymm_k1z_xmmm128b16
public Code EVEX_Vcvtph2dq_zmm_k1z_ymmm256b16_er
public Code EVEX_Vcvtph2pd_xmm_k1z_xmmm32b16
public Code EVEX_Vcvtph2pd_ymm_k1z_xmmm64b16
public Code EVEX_Vcvtph2pd_zmm_k1z_xmmm128b16_sae
public Code EVEX_Vcvtph2psx_xmm_k1z_xmmm64b16
public Code EVEX_Vcvtph2psx_ymm_k1z_xmmm128b16
public Code EVEX_Vcvtph2psx_zmm_k1z_ymmm256b16_sae
public Code EVEX_Vcvtph2qq_xmm_k1z_xmmm32b16
public Code EVEX_Vcvtph2qq_ymm_k1z_xmmm64b16
public Code EVEX_Vcvtph2qq_zmm_k1z_xmmm128b16_er
public Code EVEX_Vcvtph2udq_xmm_k1z_xmmm64b16
public Code EVEX_Vcvtph2udq_ymm_k1z_xmmm128b16
public Code EVEX_Vcvtph2udq_zmm_k1z_ymmm256b16_er
public Code EVEX_Vcvtph2uqq_xmm_k1z_xmmm32b16
public Code EVEX_Vcvtph2uqq_ymm_k1z_xmmm64b16
public Code EVEX_Vcvtph2uqq_zmm_k1z_xmmm128b16_er
public Code EVEX_Vcvtph2uw_xmm_k1z_xmmm128b16
public Code EVEX_Vcvtph2uw_ymm_k1z_ymmm256b16
public Code EVEX_Vcvtph2uw_zmm_k1z_zmmm512b16_er
public Code EVEX_Vcvtph2w_xmm_k1z_xmmm128b16
public Code EVEX_Vcvtph2w_ymm_k1z_ymmm256b16
public Code EVEX_Vcvtph2w_zmm_k1z_zmmm512b16_er
public Code EVEX_Vcvtps2phx_xmm_k1z_xmmm128b32
public Code EVEX_Vcvtps2phx_xmm_k1z_ymmm256b32
public Code EVEX_Vcvtps2phx_ymm_k1z_zmmm512b32_er
public Code EVEX_Vcvtqq2ph_xmm_k1z_xmmm128b64
public Code EVEX_Vcvtqq2ph_xmm_k1z_ymmm256b64
public Code EVEX_Vcvtqq2ph_xmm_k1z_zmmm512b64_er
public Code EVEX_Vcvtsd2sh_xmm_k1z_xmm_xmmm64_er
public Code EVEX_Vcvtsh2sd_xmm_k1z_xmm_xmmm16_sae
public Code EVEX_Vcvtsh2si_r32_xmmm16_er
public Code EVEX_Vcvtsh2si_r64_xmmm16_er
public Code EVEX_Vcvtsh2ss_xmm_k1z_xmm_xmmm16_sae
public Code EVEX_Vcvtsh2usi_r32_xmmm16_er
public Code EVEX_Vcvtsh2usi_r64_xmmm16_er
public Code EVEX_Vcvtsi2sh_xmm_xmm_rm32_er
public Code EVEX_Vcvtsi2sh_xmm_xmm_rm64_er
public Code EVEX_Vcvtss2sh_xmm_k1z_xmm_xmmm32_er
public Code EVEX_Vcvttph2dq_xmm_k1z_xmmm64b16
public Code EVEX_Vcvttph2dq_ymm_k1z_xmmm128b16
public Code EVEX_Vcvttph2dq_zmm_k1z_ymmm256b16_sae
public Code EVEX_Vcvttph2qq_xmm_k1z_xmmm32b16
public Code EVEX_Vcvttph2qq_ymm_k1z_xmmm64b16
public Code EVEX_Vcvttph2qq_zmm_k1z_xmmm128b16_sae
public Code EVEX_Vcvttph2udq_xmm_k1z_xmmm64b16
public Code EVEX_Vcvttph2udq_ymm_k1z_xmmm128b16
public Code EVEX_Vcvttph2udq_zmm_k1z_ymmm256b16_sae
public Code EVEX_Vcvttph2uqq_xmm_k1z_xmmm32b16
public Code EVEX_Vcvttph2uqq_ymm_k1z_xmmm64b16
public Code EVEX_Vcvttph2uqq_zmm_k1z_xmmm128b16_sae
public Code EVEX_Vcvttph2uw_xmm_k1z_xmmm128b16
public Code EVEX_Vcvttph2uw_ymm_k1z_ymmm256b16
public Code EVEX_Vcvttph2uw_zmm_k1z_zmmm512b16_sae
public Code EVEX_Vcvttph2w_xmm_k1z_xmmm128b16
public Code EVEX_Vcvttph2w_ymm_k1z_ymmm256b16
public Code EVEX_Vcvttph2w_zmm_k1z_zmmm512b16_sae
public Code EVEX_Vcvttsh2si_r32_xmmm16_sae
public Code EVEX_Vcvttsh2si_r64_xmmm16_sae
public Code EVEX_Vcvttsh2usi_r32_xmmm16_sae
public Code EVEX_Vcvttsh2usi_r64_xmmm16_sae
public Code EVEX_Vcvtudq2ph_xmm_k1z_xmmm128b32
public Code EVEX_Vcvtudq2ph_xmm_k1z_ymmm256b32
public Code EVEX_Vcvtudq2ph_ymm_k1z_zmmm512b32_er
public Code EVEX_Vcvtuqq2ph_xmm_k1z_xmmm128b64
public Code EVEX_Vcvtuqq2ph_xmm_k1z_ymmm256b64
public Code EVEX_Vcvtuqq2ph_xmm_k1z_zmmm512b64_er
public Code EVEX_Vcvtusi2sh_xmm_xmm_rm32_er
public Code EVEX_Vcvtusi2sh_xmm_xmm_rm64_er
public Code EVEX_Vcvtuw2ph_xmm_k1z_xmmm128b16
public Code EVEX_Vcvtuw2ph_ymm_k1z_ymmm256b16
public Code EVEX_Vcvtuw2ph_zmm_k1z_zmmm512b16_er
public Code EVEX_Vcvtw2ph_xmm_k1z_xmmm128b16
public Code EVEX_Vcvtw2ph_ymm_k1z_ymmm256b16
public Code EVEX_Vcvtw2ph_zmm_k1z_zmmm512b16_er
public Code EVEX_Vdivph_xmm_k1z_xmm_xmmm128b16
public Code EVEX_Vdivph_ymm_k1z_ymm_ymmm256b16
public Code EVEX_Vdivph_zmm_k1z_zmm_zmmm512b16_er
public Code EVEX_Vdivsh_xmm_k1z_xmm_xmmm16_er
public Code EVEX_Vfcmaddcph_xmm_k1z_xmm_xmmm128b32
public Code EVEX_Vfcmaddcph_ymm_k1z_ymm_ymmm256b32
public Code EVEX_Vfcmaddcph_zmm_k1z_zmm_zmmm512b32_er
public Code EVEX_Vfmaddcph_xmm_k1z_xmm_xmmm128b32
public Code EVEX_Vfmaddcph_ymm_k1z_ymm_ymmm256b32
public Code EVEX_Vfmaddcph_zmm_k1z_zmm_zmmm512b32_er
public Code EVEX_Vfcmaddcsh_xmm_k1z_xmm_xmmm32_er
public Code EVEX_Vfmaddcsh_xmm_k1z_xmm_xmmm32_er
public Code EVEX_Vfcmulcph_xmm_k1z_xmm_xmmm128b32
public Code EVEX_Vfcmulcph_ymm_k1z_ymm_ymmm256b32
public Code EVEX_Vfcmulcph_zmm_k1z_zmm_zmmm512b32_er
public Code EVEX_Vfmulcph_xmm_k1z_xmm_xmmm128b32
public Code EVEX_Vfmulcph_ymm_k1z_ymm_ymmm256b32
public Code EVEX_Vfmulcph_zmm_k1z_zmm_zmmm512b32_er
public Code EVEX_Vfcmulcsh_xmm_k1z_xmm_xmmm32_er
public Code EVEX_Vfmulcsh_xmm_k1z_xmm_xmmm32_er
public Code EVEX_Vfmaddsub132ph_xmm_k1z_xmm_xmmm128b16
public Code EVEX_Vfmaddsub132ph_ymm_k1z_ymm_ymmm256b16
public Code EVEX_Vfmaddsub132ph_zmm_k1z_zmm_zmmm512b16_er
public Code EVEX_Vfmaddsub213ph_xmm_k1z_xmm_xmmm128b16
public Code EVEX_Vfmaddsub213ph_ymm_k1z_ymm_ymmm256b16
public Code EVEX_Vfmaddsub213ph_zmm_k1z_zmm_zmmm512b16_er
public Code EVEX_Vfmaddsub231ph_xmm_k1z_xmm_xmmm128b16
public Code EVEX_Vfmaddsub231ph_ymm_k1z_ymm_ymmm256b16
public Code EVEX_Vfmaddsub231ph_zmm_k1z_zmm_zmmm512b16_er
public Code EVEX_Vfmsubadd132ph_xmm_k1z_xmm_xmmm128b16
public Code EVEX_Vfmsubadd132ph_ymm_k1z_ymm_ymmm256b16
public Code EVEX_Vfmsubadd132ph_zmm_k1z_zmm_zmmm512b16_er
public Code EVEX_Vfmsubadd213ph_xmm_k1z_xmm_xmmm128b16
public Code EVEX_Vfmsubadd213ph_ymm_k1z_ymm_ymmm256b16
public Code EVEX_Vfmsubadd213ph_zmm_k1z_zmm_zmmm512b16_er
public Code EVEX_Vfmsubadd231ph_xmm_k1z_xmm_xmmm128b16
public Code EVEX_Vfmsubadd231ph_ymm_k1z_ymm_ymmm256b16
public Code EVEX_Vfmsubadd231ph_zmm_k1z_zmm_zmmm512b16_er
public Code EVEX_Vfmadd132ph_xmm_k1z_xmm_xmmm128b16
public Code EVEX_Vfmadd132ph_ymm_k1z_ymm_ymmm256b16
public Code EVEX_Vfmadd132ph_zmm_k1z_zmm_zmmm512b16_er
public Code EVEX_Vfmadd213ph_xmm_k1z_xmm_xmmm128b16
public Code EVEX_Vfmadd213ph_ymm_k1z_ymm_ymmm256b16
public Code EVEX_Vfmadd213ph_zmm_k1z_zmm_zmmm512b16_er
public Code EVEX_Vfmadd231ph_xmm_k1z_xmm_xmmm128b16
public Code EVEX_Vfmadd231ph_ymm_k1z_ymm_ymmm256b16
public Code EVEX_Vfmadd231ph_zmm_k1z_zmm_zmmm512b16_er
public Code EVEX_Vfnmadd132ph_xmm_k1z_xmm_xmmm128b16
public Code EVEX_Vfnmadd132ph_ymm_k1z_ymm_ymmm256b16
public Code EVEX_Vfnmadd132ph_zmm_k1z_zmm_zmmm512b16_er
public Code EVEX_Vfnmadd213ph_xmm_k1z_xmm_xmmm128b16
public Code EVEX_Vfnmadd213ph_ymm_k1z_ymm_ymmm256b16
public Code EVEX_Vfnmadd213ph_zmm_k1z_zmm_zmmm512b16_er
public Code EVEX_Vfnmadd231ph_xmm_k1z_xmm_xmmm128b16
public Code EVEX_Vfnmadd231ph_ymm_k1z_ymm_ymmm256b16
public Code EVEX_Vfnmadd231ph_zmm_k1z_zmm_zmmm512b16_er
public Code EVEX_Vfmadd132sh_xmm_k1z_xmm_xmmm16_er
public Code EVEX_Vfmadd213sh_xmm_k1z_xmm_xmmm16_er
public Code EVEX_Vfmadd231sh_xmm_k1z_xmm_xmmm16_er
public Code EVEX_Vfnmadd132sh_xmm_k1z_xmm_xmmm16_er
public Code EVEX_Vfnmadd213sh_xmm_k1z_xmm_xmmm16_er
public Code EVEX_Vfnmadd231sh_xmm_k1z_xmm_xmmm16_er
public Code EVEX_Vfmsub132ph_xmm_k1z_xmm_xmmm128b16
public Code EVEX_Vfmsub132ph_ymm_k1z_ymm_ymmm256b16
public Code EVEX_Vfmsub132ph_zmm_k1z_zmm_zmmm512b16_er
public Code EVEX_Vfmsub213ph_xmm_k1z_xmm_xmmm128b16
public Code EVEX_Vfmsub213ph_ymm_k1z_ymm_ymmm256b16
public Code EVEX_Vfmsub213ph_zmm_k1z_zmm_zmmm512b16_er
public Code EVEX_Vfmsub231ph_xmm_k1z_xmm_xmmm128b16
public Code EVEX_Vfmsub231ph_ymm_k1z_ymm_ymmm256b16
public Code EVEX_Vfmsub231ph_zmm_k1z_zmm_zmmm512b16_er
public Code EVEX_Vfnmsub132ph_xmm_k1z_xmm_xmmm128b16
public Code EVEX_Vfnmsub132ph_ymm_k1z_ymm_ymmm256b16
public Code EVEX_Vfnmsub132ph_zmm_k1z_zmm_zmmm512b16_er
public Code EVEX_Vfnmsub213ph_xmm_k1z_xmm_xmmm128b16
public Code EVEX_Vfnmsub213ph_ymm_k1z_ymm_ymmm256b16
public Code EVEX_Vfnmsub213ph_zmm_k1z_zmm_zmmm512b16_er
public Code EVEX_Vfnmsub231ph_xmm_k1z_xmm_xmmm128b16
public Code EVEX_Vfnmsub231ph_ymm_k1z_ymm_ymmm256b16
public Code EVEX_Vfnmsub231ph_zmm_k1z_zmm_zmmm512b16_er
public Code EVEX_Vfmsub132sh_xmm_k1z_xmm_xmmm16_er
public Code EVEX_Vfmsub213sh_xmm_k1z_xmm_xmmm16_er
public Code EVEX_Vfmsub231sh_xmm_k1z_xmm_xmmm16_er
public Code EVEX_Vfnmsub132sh_xmm_k1z_xmm_xmmm16_er
public Code EVEX_Vfnmsub213sh_xmm_k1z_xmm_xmmm16_er
public Code EVEX_Vfnmsub231sh_xmm_k1z_xmm_xmmm16_er
public Code EVEX_Vfpclassph_kr_k1_xmmm128b16_imm8
public Code EVEX_Vfpclassph_kr_k1_ymmm256b16_imm8
public Code EVEX_Vfpclassph_kr_k1_zmmm512b16_imm8
public Code EVEX_Vfpclasssh_kr_k1_xmmm16_imm8
public Code EVEX_Vgetexpph_xmm_k1z_xmmm128b16
public Code EVEX_Vgetexpph_ymm_k1z_ymmm256b16
public Code EVEX_Vgetexpph_zmm_k1z_zmmm512b16_sae
public Code EVEX_Vgetexpsh_xmm_k1z_xmm_xmmm16_sae
public Code EVEX_Vgetmantph_xmm_k1z_xmmm128b16_imm8
public Code EVEX_Vgetmantph_ymm_k1z_ymmm256b16_imm8
public Code EVEX_Vgetmantph_zmm_k1z_zmmm512b16_imm8_sae
public Code EVEX_Vgetmantsh_xmm_k1z_xmm_xmmm16_imm8_sae
public Code EVEX_Vmaxph_xmm_k1z_xmm_xmmm128b16
public Code EVEX_Vmaxph_ymm_k1z_ymm_ymmm256b16
public Code EVEX_Vmaxph_zmm_k1z_zmm_zmmm512b16_sae
public Code EVEX_Vmaxsh_xmm_k1z_xmm_xmmm16_sae
public Code EVEX_Vminph_xmm_k1z_xmm_xmmm128b16
public Code EVEX_Vminph_ymm_k1z_ymm_ymmm256b16
public Code EVEX_Vminph_zmm_k1z_zmm_zmmm512b16_sae
public Code EVEX_Vminsh_xmm_k1z_xmm_xmmm16_sae
public Code EVEX_Vmovsh_xmm_k1z_m16
public Code EVEX_Vmovsh_m16_k1_xmm
public Code EVEX_Vmovsh_xmm_k1z_xmm_xmm
public Code EVEX_Vmovsh_xmm_k1z_xmm_xmm_MAP5_11
public Code EVEX_Vmovw_xmm_r32m16
public Code EVEX_Vmovw_xmm_r64m16
public Code EVEX_Vmovw_r32m16_xmm
public Code EVEX_Vmovw_r64m16_xmm
public Code EVEX_Vmulph_xmm_k1z_xmm_xmmm128b16
public Code EVEX_Vmulph_ymm_k1z_ymm_ymmm256b16
public Code EVEX_Vmulph_zmm_k1z_zmm_zmmm512b16_er
public Code EVEX_Vmulsh_xmm_k1z_xmm_xmmm16_er
public Code EVEX_Vrcpph_xmm_k1z_xmmm128b16
public Code EVEX_Vrcpph_ymm_k1z_ymmm256b16
public Code EVEX_Vrcpph_zmm_k1z_zmmm512b16
public Code EVEX_Vrcpsh_xmm_k1z_xmm_xmmm16
public Code EVEX_Vreduceph_xmm_k1z_xmmm128b16_imm8
public Code EVEX_Vreduceph_ymm_k1z_ymmm256b16_imm8
public Code EVEX_Vreduceph_zmm_k1z_zmmm512b16_imm8_sae
public Code EVEX_Vreducesh_xmm_k1z_xmm_xmmm16_imm8_sae
public Code EVEX_Vrndscaleph_xmm_k1z_xmmm128b16_imm8
public Code EVEX_Vrndscaleph_ymm_k1z_ymmm256b16_imm8
public Code EVEX_Vrndscaleph_zmm_k1z_zmmm512b16_imm8_sae
public Code EVEX_Vrndscalesh_xmm_k1z_xmm_xmmm16_imm8_sae
public Code EVEX_Vrsqrtph_xmm_k1z_xmmm128b16
public Code EVEX_Vrsqrtph_ymm_k1z_ymmm256b16
public Code EVEX_Vrsqrtph_zmm_k1z_zmmm512b16
public Code EVEX_Vrsqrtsh_xmm_k1z_xmm_xmmm16
public Code EVEX_Vscalefph_xmm_k1z_xmm_xmmm128b16
public Code EVEX_Vscalefph_ymm_k1z_ymm_ymmm256b16
public Code EVEX_Vscalefph_zmm_k1z_zmm_zmmm512b16_er
public Code EVEX_Vscalefsh_xmm_k1z_xmm_xmmm16_er
public Code EVEX_Vsqrtph_xmm_k1z_xmmm128b16
public Code EVEX_Vsqrtph_ymm_k1z_ymmm256b16
public Code EVEX_Vsqrtph_zmm_k1z_zmmm512b16_er
public Code EVEX_Vsqrtsh_xmm_k1z_xmm_xmmm16_er
public Code EVEX_Vsubph_xmm_k1z_xmm_xmmm128b16
public Code EVEX_Vsubph_ymm_k1z_ymm_ymmm256b16
public Code EVEX_Vsubph_zmm_k1z_zmm_zmmm512b16_er
public Code EVEX_Vsubsh_xmm_k1z_xmm_xmmm16_er
public Code EVEX_Vucomish_xmm_xmmm16_sae
public Code Rdudbg
public Code Wrudbg
public Code VEX_KNC_Jkzd_kr_rel8_64
public Code VEX_KNC_Jknzd_kr_rel8_64
public Code VEX_KNC_Vprefetchnta_m8
public Code VEX_KNC_Vprefetch0_m8
public Code VEX_KNC_Vprefetch1_m8
public Code VEX_KNC_Vprefetch2_m8
public Code VEX_KNC_Vprefetchenta_m8
public Code VEX_KNC_Vprefetche0_m8
public Code VEX_KNC_Vprefetche1_m8
public Code VEX_KNC_Vprefetche2_m8
public Code VEX_KNC_Kand_kr_kr
public Code VEX_KNC_Kandn_kr_kr
public Code VEX_KNC_Kandnr_kr_kr
public Code VEX_KNC_Knot_kr_kr
public Code VEX_KNC_Kor_kr_kr
public Code VEX_KNC_Kxnor_kr_kr
public Code VEX_KNC_Kxor_kr_kr
public Code VEX_KNC_Kmerge2l1h_kr_kr
public Code VEX_KNC_Kmerge2l1l_kr_kr
public Code VEX_KNC_Jkzd_kr_rel32_64
public Code VEX_KNC_Jknzd_kr_rel32_64
public Code VEX_KNC_Kmov_kr_kr
public Code VEX_KNC_Kmov_kr_r32
public Code VEX_KNC_Kmov_r32_kr
public Code VEX_KNC_Kconcath_r64_kr_kr
public Code VEX_KNC_Kconcatl_r64_kr_kr
public Code VEX_KNC_Kortest_kr_kr
public Code VEX_KNC_Delay_r32
public Code VEX_KNC_Delay_r64
public Code VEX_KNC_Spflt_r32
public Code VEX_KNC_Spflt_r64
public Code VEX_KNC_Clevict1_m8
public Code VEX_KNC_Clevict0_m8
public Code VEX_KNC_Popcnt_r32_r32
public Code VEX_KNC_Popcnt_r64_r64
public Code VEX_KNC_Tzcnt_r32_r32
public Code VEX_KNC_Tzcnt_r64_r64
public Code VEX_KNC_Tzcnti_r32_r32
public Code VEX_KNC_Tzcnti_r64_r64
public Code VEX_KNC_Lzcnt_r32_r32
public Code VEX_KNC_Lzcnt_r64_r64
public Code VEX_KNC_Undoc_r32_rm32_128_F3_0F38_W0_F0
public Code VEX_KNC_Undoc_r64_rm64_128_F3_0F38_W1_F0
public Code VEX_KNC_Undoc_r32_rm32_128_F2_0F38_W0_F0
public Code VEX_KNC_Undoc_r64_rm64_128_F2_0F38_W1_F0
public Code VEX_KNC_Undoc_r32_rm32_128_F2_0F38_W0_F1
public Code VEX_KNC_Undoc_r64_rm64_128_F2_0F38_W1_F1
public Code VEX_KNC_Kextract_kr_r64_imm8
public Code MVEX_Vprefetchnta_m
public Code MVEX_Vprefetch0_m
public Code MVEX_Vprefetch1_m
public Code MVEX_Vprefetch2_m
public Code MVEX_Vprefetchenta_m
public Code MVEX_Vprefetche0_m
public Code MVEX_Vprefetche1_m
public Code MVEX_Vprefetche2_m
public Code MVEX_Vmovaps_zmm_k1_zmmmt
public Code MVEX_Vmovapd_zmm_k1_zmmmt
public Code MVEX_Vmovaps_mt_k1_zmm
public Code MVEX_Vmovapd_mt_k1_zmm
public Code MVEX_Vmovnrapd_m_k1_zmm
public Code MVEX_Vmovnrngoapd_m_k1_zmm
public Code MVEX_Vmovnraps_m_k1_zmm
public Code MVEX_Vmovnrngoaps_m_k1_zmm
public Code MVEX_Vaddps_zmm_k1_zmm_zmmmt
public Code MVEX_Vaddpd_zmm_k1_zmm_zmmmt
public Code MVEX_Vmulps_zmm_k1_zmm_zmmmt
public Code MVEX_Vmulpd_zmm_k1_zmm_zmmmt
public Code MVEX_Vcvtps2pd_zmm_k1_zmmmt
public Code MVEX_Vcvtpd2ps_zmm_k1_zmmmt
public Code MVEX_Vsubps_zmm_k1_zmm_zmmmt
public Code MVEX_Vsubpd_zmm_k1_zmm_zmmmt
public Code MVEX_Vpcmpgtd_kr_k1_zmm_zmmmt
public Code MVEX_Vmovdqa32_zmm_k1_zmmmt
public Code MVEX_Vmovdqa64_zmm_k1_zmmmt
public Code MVEX_Vpshufd_zmm_k1_zmmmt_imm8
public Code MVEX_Vpsrld_zmm_k1_zmmmt_imm8
public Code MVEX_Vpsrad_zmm_k1_zmmmt_imm8
public Code MVEX_Vpslld_zmm_k1_zmmmt_imm8
public Code MVEX_Vpcmpeqd_kr_k1_zmm_zmmmt
public Code MVEX_Vcvtudq2pd_zmm_k1_zmmmt
public Code MVEX_Vmovdqa32_mt_k1_zmm
public Code MVEX_Vmovdqa64_mt_k1_zmm
public Code MVEX_Clevict1_m
public Code MVEX_Clevict0_m
public Code MVEX_Vcmpps_kr_k1_zmm_zmmmt_imm8
public Code MVEX_Vcmppd_kr_k1_zmm_zmmmt_imm8
public Code MVEX_Vpandd_zmm_k1_zmm_zmmmt
public Code MVEX_Vpandq_zmm_k1_zmm_zmmmt
public Code MVEX_Vpandnd_zmm_k1_zmm_zmmmt
public Code MVEX_Vpandnq_zmm_k1_zmm_zmmmt
public Code MVEX_Vcvtdq2pd_zmm_k1_zmmmt
public Code MVEX_Vpord_zmm_k1_zmm_zmmmt
public Code MVEX_Vporq_zmm_k1_zmm_zmmmt
public Code MVEX_Vpxord_zmm_k1_zmm_zmmmt
public Code MVEX_Vpxorq_zmm_k1_zmm_zmmmt
public Code MVEX_Vpsubd_zmm_k1_zmm_zmmmt
public Code MVEX_Vpaddd_zmm_k1_zmm_zmmmt
public Code MVEX_Vbroadcastss_zmm_k1_mt
public Code MVEX_Vbroadcastsd_zmm_k1_mt
public Code MVEX_Vbroadcastf32x4_zmm_k1_mt
public Code MVEX_Vbroadcastf64x4_zmm_k1_mt
public Code MVEX_Vptestmd_kr_k1_zmm_zmmmt
public Code MVEX_Vpermd_zmm_k1_zmm_zmmmt
public Code MVEX_Vpminsd_zmm_k1_zmm_zmmmt
public Code MVEX_Vpminud_zmm_k1_zmm_zmmmt
public Code MVEX_Vpmaxsd_zmm_k1_zmm_zmmmt
public Code MVEX_Vpmaxud_zmm_k1_zmm_zmmmt
public Code MVEX_Vpmulld_zmm_k1_zmm_zmmmt
public Code MVEX_Vgetexpps_zmm_k1_zmmmt
public Code MVEX_Vgetexppd_zmm_k1_zmmmt
public Code MVEX_Vpsrlvd_zmm_k1_zmm_zmmmt
public Code MVEX_Vpsravd_zmm_k1_zmm_zmmmt
public Code MVEX_Vpsllvd_zmm_k1_zmm_zmmmt
public Code MVEX_Undoc_zmm_k1_zmmmt_512_66_0F38_W0_48
public Code MVEX_Undoc_zmm_k1_zmmmt_512_66_0F38_W0_49
public Code MVEX_Undoc_zmm_k1_zmmmt_512_66_0F38_W0_4A
public Code MVEX_Undoc_zmm_k1_zmmmt_512_66_0F38_W0_4B
public Code MVEX_Vaddnps_zmm_k1_zmm_zmmmt
public Code MVEX_Vaddnpd_zmm_k1_zmm_zmmmt
public Code MVEX_Vgmaxabsps_zmm_k1_zmm_zmmmt
public Code MVEX_Vgminps_zmm_k1_zmm_zmmmt
public Code MVEX_Vgminpd_zmm_k1_zmm_zmmmt
public Code MVEX_Vgmaxps_zmm_k1_zmm_zmmmt
public Code MVEX_Vgmaxpd_zmm_k1_zmm_zmmmt
public Code MVEX_Undoc_zmm_k1_zmm_zmmmt_512_66_0F38_W0_54
public Code MVEX_Vfixupnanps_zmm_k1_zmm_zmmmt
public Code MVEX_Vfixupnanpd_zmm_k1_zmm_zmmmt
public Code MVEX_Undoc_zmm_k1_zmm_zmmmt_512_66_0F38_W0_56
public Code MVEX_Undoc_zmm_k1_zmm_zmmmt_512_66_0F38_W0_57
public Code MVEX_Vpbroadcastd_zmm_k1_mt
public Code MVEX_Vpbroadcastq_zmm_k1_mt
public Code MVEX_Vbroadcasti32x4_zmm_k1_mt
public Code MVEX_Vbroadcasti64x4_zmm_k1_mt
public Code MVEX_Vpadcd_zmm_k1_kr_zmmmt
public Code MVEX_Vpaddsetcd_zmm_k1_kr_zmmmt
public Code MVEX_Vpsbbd_zmm_k1_kr_zmmmt
public Code MVEX_Vpsubsetbd_zmm_k1_kr_zmmmt
public Code MVEX_Vpblendmd_zmm_k1_zmm_zmmmt
public Code MVEX_Vpblendmq_zmm_k1_zmm_zmmmt
public Code MVEX_Vblendmps_zmm_k1_zmm_zmmmt
public Code MVEX_Vblendmpd_zmm_k1_zmm_zmmmt
public Code MVEX_Undoc_zmm_k1_zmm_zmmmt_512_66_0F38_W0_67
public Code MVEX_Undoc_zmm_k1_zmmmt_512_66_0F38_W0_68
public Code MVEX_Undoc_zmm_k1_zmmmt_512_66_0F38_W0_69
public Code MVEX_Undoc_zmm_k1_zmmmt_512_66_0F38_W0_6A
public Code MVEX_Undoc_zmm_k1_zmmmt_512_66_0F38_W0_6B
public Code MVEX_Vpsubrd_zmm_k1_zmm_zmmmt
public Code MVEX_Vsubrps_zmm_k1_zmm_zmmmt
public Code MVEX_Vsubrpd_zmm_k1_zmm_zmmmt
public Code MVEX_Vpsbbrd_zmm_k1_kr_zmmmt
public Code MVEX_Vpsubrsetbd_zmm_k1_kr_zmmmt
public Code MVEX_Undoc_zmm_k1_zmm_zmmmt_512_66_0F38_W0_70
public Code MVEX_Undoc_zmm_k1_zmm_zmmmt_512_66_0F38_W0_71
public Code MVEX_Undoc_zmm_k1_zmm_zmmmt_512_66_0F38_W0_72
public Code MVEX_Undoc_zmm_k1_zmm_zmmmt_512_66_0F38_W0_73
public Code MVEX_Vpcmpltd_kr_k1_zmm_zmmmt
public Code MVEX_Vscaleps_zmm_k1_zmm_zmmmt
public Code MVEX_Vpmulhud_zmm_k1_zmm_zmmmt
public Code MVEX_Vpmulhd_zmm_k1_zmm_zmmmt
public Code MVEX_Vpgatherdd_zmm_k1_mvt
public Code MVEX_Vpgatherdq_zmm_k1_mvt
public Code MVEX_Vgatherdps_zmm_k1_mvt
public Code MVEX_Vgatherdpd_zmm_k1_mvt
public Code MVEX_Undoc_zmm_k1_zmm_zmmmt_512_66_0F38_W0_94
public Code MVEX_Undoc_zmm_k1_zmm_zmmmt_512_66_0F38_W1_94
public Code MVEX_Vfmadd132ps_zmm_k1_zmm_zmmmt
public Code MVEX_Vfmadd132pd_zmm_k1_zmm_zmmmt
public Code MVEX_Vfmsub132ps_zmm_k1_zmm_zmmmt
public Code MVEX_Vfmsub132pd_zmm_k1_zmm_zmmmt
public Code MVEX_Vfnmadd132ps_zmm_k1_zmm_zmmmt
public Code MVEX_Vfnmadd132pd_zmm_k1_zmm_zmmmt
public Code MVEX_Vfnmsub132ps_zmm_k1_zmm_zmmmt
public Code MVEX_Vfnmsub132pd_zmm_k1_zmm_zmmmt
public Code MVEX_Vpscatterdd_mvt_k1_zmm
public Code MVEX_Vpscatterdq_mvt_k1_zmm
public Code MVEX_Vscatterdps_mvt_k1_zmm
public Code MVEX_Vscatterdpd_mvt_k1_zmm
public Code MVEX_Vfmadd233ps_zmm_k1_zmm_zmmmt
public Code MVEX_Vfmadd213ps_zmm_k1_zmm_zmmmt
public Code MVEX_Vfmadd213pd_zmm_k1_zmm_zmmmt
public Code MVEX_Vfmsub213ps_zmm_k1_zmm_zmmmt
public Code MVEX_Vfmsub213pd_zmm_k1_zmm_zmmmt
public Code MVEX_Vfnmadd213ps_zmm_k1_zmm_zmmmt
public Code MVEX_Vfnmadd213pd_zmm_k1_zmm_zmmmt
public Code MVEX_Vfnmsub213ps_zmm_k1_zmm_zmmmt
public Code MVEX_Vfnmsub213pd_zmm_k1_zmm_zmmmt
public Code MVEX_Undoc_zmm_k1_mvt_512_66_0F38_W0_B0
public Code MVEX_Undoc_zmm_k1_mvt_512_66_0F38_W0_B2
public Code MVEX_Vpmadd233d_zmm_k1_zmm_zmmmt
public Code MVEX_Vpmadd231d_zmm_k1_zmm_zmmmt
public Code MVEX_Vfmadd231ps_zmm_k1_zmm_zmmmt
public Code MVEX_Vfmadd231pd_zmm_k1_zmm_zmmmt
public Code MVEX_Vfmsub231ps_zmm_k1_zmm_zmmmt
public Code MVEX_Vfmsub231pd_zmm_k1_zmm_zmmmt
public Code MVEX_Vfnmadd231ps_zmm_k1_zmm_zmmmt
public Code MVEX_Vfnmadd231pd_zmm_k1_zmm_zmmmt
public Code MVEX_Vfnmsub231ps_zmm_k1_zmm_zmmmt
public Code MVEX_Vfnmsub231pd_zmm_k1_zmm_zmmmt
public Code MVEX_Undoc_zmm_k1_mvt_512_66_0F38_W0_C0
public Code MVEX_Vgatherpf0hintdps_mvt_k1
public Code MVEX_Vgatherpf0hintdpd_mvt_k1
public Code MVEX_Vgatherpf0dps_mvt_k1
public Code MVEX_Vgatherpf1dps_mvt_k1
public Code MVEX_Vscatterpf0hintdps_mvt_k1
public Code MVEX_Vscatterpf0hintdpd_mvt_k1
public Code MVEX_Vscatterpf0dps_mvt_k1
public Code MVEX_Vscatterpf1dps_mvt_k1
public Code MVEX_Vexp223ps_zmm_k1_zmmmt
public Code MVEX_Vlog2ps_zmm_k1_zmmmt
public Code MVEX_Vrcp23ps_zmm_k1_zmmmt
public Code MVEX_Vrsqrt23ps_zmm_k1_zmmmt
public Code MVEX_Vaddsetsps_zmm_k1_zmm_zmmmt
public Code MVEX_Vpaddsetsd_zmm_k1_zmm_zmmmt
public Code MVEX_Undoc_zmm_k1_zmm_zmmmt_512_66_0F38_W0_CE
public Code MVEX_Undoc_zmm_k1_zmm_zmmmt_512_66_0F38_W1_CE
public Code MVEX_Undoc_zmm_k1_zmm_zmmmt_512_66_0F38_W0_CF
public Code MVEX_Vloadunpackld_zmm_k1_mt
public Code MVEX_Vloadunpacklq_zmm_k1_mt
public Code MVEX_Vpackstoreld_mt_k1_zmm
public Code MVEX_Vpackstorelq_mt_k1_zmm
public Code MVEX_Vloadunpacklps_zmm_k1_mt
public Code MVEX_Vloadunpacklpd_zmm_k1_mt
public Code MVEX_Vpackstorelps_mt_k1_zmm
public Code MVEX_Vpackstorelpd_mt_k1_zmm
public Code MVEX_Undoc_zmm_k1_zmmmt_512_0F38_W0_D2
public Code MVEX_Undoc_zmm_k1_zmmmt_512_66_0F38_W0_D2
public Code MVEX_Undoc_zmm_k1_zmmmt_512_0F38_W0_D3
public Code MVEX_Vloadunpackhd_zmm_k1_mt
public Code MVEX_Vloadunpackhq_zmm_k1_mt
public Code MVEX_Vpackstorehd_mt_k1_zmm
public Code MVEX_Vpackstorehq_mt_k1_zmm
public Code MVEX_Vloadunpackhps_zmm_k1_mt
public Code MVEX_Vloadunpackhpd_zmm_k1_mt
public Code MVEX_Vpackstorehps_mt_k1_zmm
public Code MVEX_Vpackstorehpd_mt_k1_zmm
public Code MVEX_Undoc_zmm_k1_zmmmt_512_0F38_W0_D6
public Code MVEX_Undoc_zmm_k1_zmmmt_512_66_0F38_W0_D6
public Code MVEX_Undoc_zmm_k1_zmmmt_512_0F38_W0_D7
public Code MVEX_Valignd_zmm_k1_zmm_zmmmt_imm8
public Code MVEX_Vpermf32x4_zmm_k1_zmmmt_imm8
public Code MVEX_Vpcmpud_kr_k1_zmm_zmmmt_imm8
public Code MVEX_Vpcmpd_kr_k1_zmm_zmmmt_imm8
public Code MVEX_Vgetmantps_zmm_k1_zmmmt_imm8
public Code MVEX_Vgetmantpd_zmm_k1_zmmmt_imm8
public Code MVEX_Vrndfxpntps_zmm_k1_zmmmt_imm8
public Code MVEX_Vrndfxpntpd_zmm_k1_zmmmt_imm8
public Code MVEX_Vcvtfxpntudq2ps_zmm_k1_zmmmt_imm8
public Code MVEX_Vcvtfxpntps2udq_zmm_k1_zmmmt_imm8
public Code MVEX_Vcvtfxpntpd2udq_zmm_k1_zmmmt_imm8
public Code MVEX_Vcvtfxpntdq2ps_zmm_k1_zmmmt_imm8
public Code MVEX_Vcvtfxpntps2dq_zmm_k1_zmmmt_imm8
public Code MVEX_Undoc_zmm_k1_zmmmt_imm8_512_66_0F3A_W0_D0
public Code MVEX_Undoc_zmm_k1_zmmmt_imm8_512_66_0F3A_W0_D1
public Code MVEX_Vcvtfxpntpd2dq_zmm_k1_zmmmt_imm8
public Code Via_undoc_F30FA6F0_16
public Code Via_undoc_F30FA6F0_32
public Code Via_undoc_F30FA6F0_64
public Code Via_undoc_F30FA6F8_16
public Code Via_undoc_F30FA6F8_32
public Code Via_undoc_F30FA6F8_64
public Code Xsha512_16
public Code Xsha512_32
public Code Xsha512_64
public Code Xstore_alt_16
public Code Xstore_alt_32
public Code Xstore_alt_64
public Code Xsha512_alt_16
public Code Xsha512_alt_32
public Code Xsha512_alt_64
public Code Zero_bytes
}
internal Iced.Intel.CodeExtensions : object {
internal bool IgnoresSegment(Code code)
internal bool IgnoresIndex(Code code)
internal bool IsTileStrideIndex(Code code)
}
internal Iced.Intel.CodeReader : object {
public int ReadByte()
}
internal Iced.Intel.CodeSize : Enum {
public int value__
public CodeSize Unknown
public CodeSize Code16
public CodeSize Code32
public CodeSize Code64
}
internal Iced.Intel.CodeWriter : object {
public void WriteByte(byte value)
}
internal Iced.Intel.ConstantOffsets : ValueType {
public byte DisplacementOffset
public byte DisplacementSize
public byte ImmediateOffset
public byte ImmediateSize
public byte ImmediateOffset2
public byte ImmediateSize2
private byte pad1
private byte pad2
public bool HasDisplacement
public bool HasImmediate
public bool HasImmediate2
public bool get_HasDisplacement()
public bool get_HasImmediate()
public bool get_HasImmediate2()
}
internal Iced.Intel.Decoder : object {
private ulong instructionPointer
private CodeReader reader
private RegInfo2[] memRegs16
private OpCodeHandler[] handlers_MAP0
private OpCodeHandler[] handlers_VEX_0F
private OpCodeHandler[] handlers_VEX_0F38
private OpCodeHandler[] handlers_VEX_0F3A
private OpCodeHandler[] handlers_EVEX_0F
private OpCodeHandler[] handlers_EVEX_0F38
private OpCodeHandler[] handlers_EVEX_0F3A
private OpCodeHandler[] handlers_EVEX_MAP5
private OpCodeHandler[] handlers_EVEX_MAP6
private OpCodeHandler[] handlers_XOP_MAP8
private OpCodeHandler[] handlers_XOP_MAP9
private OpCodeHandler[] handlers_XOP_MAP10
internal State state
internal UInt32 displIndex
internal DecoderOptions options
internal UInt32 invalidCheckMask
internal UInt32 is64bMode_and_W
internal UInt32 reg15Mask
private UInt32 maskE0
private UInt32 rexMask
internal CodeSize defaultCodeSize
internal OpSize defaultOperandSize
private OpSize defaultAddressSize
internal OpSize defaultInvertedOperandSize
internal OpSize defaultInvertedAddressSize
internal bool is64bMode
private int <Bitness>k__BackingField
private RegInfo2[] s_memRegs16
public ulong IP
public int Bitness
public DecoderError LastError
public ulong get_IP()
public void set_IP(ulong value)
public int get_Bitness()
private void .ctor(CodeReader reader, ulong ip, DecoderOptions options, int bitness)
public Decoder Create(int bitness, CodeReader reader, ulong ip, DecoderOptions options)
public Decoder Create(int bitness, Byte[] data, ulong ip, DecoderOptions options)
public Decoder Create(int bitness, CodeReader reader, DecoderOptions options)
public Decoder Create(int bitness, Byte[] data, DecoderOptions options)
internal UInt32 ReadByte()
internal UInt32 ReadUInt16()
internal UInt32 ReadUInt32()
internal ulong ReadUInt64()
public DecoderError get_LastError()
public Instruction Decode()
public void Decode(Instruction& instruction)
internal void ResetRexPrefixState()
internal void CallOpCodeHandlerXXTable(Instruction& instruction)
internal UInt32 GetCurrentInstructionPointer32()
internal ulong GetCurrentInstructionPointer64()
internal void ClearMandatoryPrefix(Instruction& instruction)
internal void SetXacquireXrelease(Instruction& instruction)
internal void ClearMandatoryPrefixF3(Instruction& instruction)
internal void ClearMandatoryPrefixF2(Instruction& instruction)
internal void SetInvalidInstruction()
internal void DecodeTable(OpCodeHandler[] table, Instruction& instruction)
private void DecodeTable(OpCodeHandler handler, Instruction& instruction)
internal void ReadModRM()
internal void VEX2(Instruction& instruction)
internal void VEX3(Instruction& instruction)
internal void XOP(Instruction& instruction)
internal void EVEX_MVEX(Instruction& instruction)
internal Register ReadOpSegReg()
internal bool ReadOpMem(Instruction& instruction)
internal void ReadOpMemSib(Instruction& instruction)
internal void ReadOpMem_MPX(Instruction& instruction)
internal void ReadOpMem(Instruction& instruction, TupleType tupleType)
internal void ReadOpMem_VSIB(Instruction& instruction, Register vsibIndex, TupleType tupleType)
private void ReadOpMem16(Instruction& instruction, TupleType tupleType)
private bool ReadOpMem32Or64(Instruction& instruction, Register baseReg, Register indexReg, TupleType tupleType, bool isVsib)
private UInt32 GetDisp8N(TupleType tupleType)
public ConstantOffsets GetConstantOffsets(Instruction& instruction)
public Enumerator GetEnumerator()
private IEnumerator`1<Instruction> System.Collections.Generic.IEnumerable<Iced.Intel.Instruction>.GetEnumerator()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
}
internal Iced.Intel.DecoderError : Enum {
public int value__
public DecoderError None
public DecoderError InvalidInstruction
public DecoderError NoMoreBytes
}
internal Iced.Intel.DecoderInternal.Code3 : ValueType {
public <codes>e__FixedBuffer codes
public void .ctor(Code code16, Code code32, Code code64)
}
internal Iced.Intel.DecoderInternal.EvexOpCodeHandlerKind : Enum {
public byte value__
public EvexOpCodeHandlerKind Invalid
public EvexOpCodeHandlerKind Invalid2
public EvexOpCodeHandlerKind Dup
public EvexOpCodeHandlerKind HandlerReference
public EvexOpCodeHandlerKind ArrayReference
public EvexOpCodeHandlerKind RM
public EvexOpCodeHandlerKind Group
public EvexOpCodeHandlerKind W
public EvexOpCodeHandlerKind MandatoryPrefix2
public EvexOpCodeHandlerKind VectorLength
public EvexOpCodeHandlerKind VectorLength_er
public EvexOpCodeHandlerKind Ed_V_Ib
public EvexOpCodeHandlerKind Ev_VX
public EvexOpCodeHandlerKind Ev_VX_Ib
public EvexOpCodeHandlerKind Gv_W_er
public EvexOpCodeHandlerKind GvM_VX_Ib
public EvexOpCodeHandlerKind HkWIb_3
public EvexOpCodeHandlerKind HkWIb_3b
public EvexOpCodeHandlerKind HWIb
public EvexOpCodeHandlerKind KkHW_3
public EvexOpCodeHandlerKind KkHW_3b
public EvexOpCodeHandlerKind KkHWIb_sae_3
public EvexOpCodeHandlerKind KkHWIb_sae_3b
public EvexOpCodeHandlerKind KkHWIb_3
public EvexOpCodeHandlerKind KkHWIb_3b
public EvexOpCodeHandlerKind KkWIb_3
public EvexOpCodeHandlerKind KkWIb_3b
public EvexOpCodeHandlerKind KP1HW
public EvexOpCodeHandlerKind KR
public EvexOpCodeHandlerKind MV
public EvexOpCodeHandlerKind V_H_Ev_er
public EvexOpCodeHandlerKind V_H_Ev_Ib
public EvexOpCodeHandlerKind VHM
public EvexOpCodeHandlerKind VHW_3
public EvexOpCodeHandlerKind VHW_4
public EvexOpCodeHandlerKind VHWIb
public EvexOpCodeHandlerKind VK
public EvexOpCodeHandlerKind Vk_VSIB
public EvexOpCodeHandlerKind VkEv_REXW_2
public EvexOpCodeHandlerKind VkEv_REXW_3
public EvexOpCodeHandlerKind VkHM
public EvexOpCodeHandlerKind VkHW_3
public EvexOpCodeHandlerKind VkHW_3b
public EvexOpCodeHandlerKind VkHW_5
public EvexOpCodeHandlerKind VkHW_er_4
public EvexOpCodeHandlerKind VkHW_er_4b
public EvexOpCodeHandlerKind VkHWIb_3
public EvexOpCodeHandlerKind VkHWIb_3b
public EvexOpCodeHandlerKind VkHWIb_5
public EvexOpCodeHandlerKind VkHWIb_er_4
public EvexOpCodeHandlerKind VkHWIb_er_4b
public EvexOpCodeHandlerKind VkM
public EvexOpCodeHandlerKind VkW_3
public EvexOpCodeHandlerKind VkW_3b
public EvexOpCodeHandlerKind VkW_4
public EvexOpCodeHandlerKind VkW_4b
public EvexOpCodeHandlerKind VkW_er_4
public EvexOpCodeHandlerKind VkW_er_5
public EvexOpCodeHandlerKind VkW_er_6
public EvexOpCodeHandlerKind VkWIb_3
public EvexOpCodeHandlerKind VkWIb_3b
public EvexOpCodeHandlerKind VkWIb_er
public EvexOpCodeHandlerKind VM
public EvexOpCodeHandlerKind VSIB_k1
public EvexOpCodeHandlerKind VSIB_k1_VX
public EvexOpCodeHandlerKind VW
public EvexOpCodeHandlerKind VW_er
public EvexOpCodeHandlerKind VX_Ev
public EvexOpCodeHandlerKind WkHV
public EvexOpCodeHandlerKind WkV_3
public EvexOpCodeHandlerKind WkV_4a
public EvexOpCodeHandlerKind WkV_4b
public EvexOpCodeHandlerKind WkVIb
public EvexOpCodeHandlerKind WkVIb_er
public EvexOpCodeHandlerKind WV
public EvexOpCodeHandlerKind VkHW_er_ur_3
public EvexOpCodeHandlerKind VkHW_er_ur_3b
}
internal Iced.Intel.DecoderInternal.EvexOpCodeHandlerReader : OpCodeHandlerReader {
public int ReadHandlers(TableDeserializer& deserializer, OpCodeHandler[] result, int resultIndex)
}
internal Iced.Intel.DecoderInternal.HandlerFlags : Enum {
public UInt32 value__
public HandlerFlags None
public HandlerFlags Xacquire
public HandlerFlags Xrelease
public HandlerFlags XacquireXreleaseNoLock
public HandlerFlags Lock
}
internal Iced.Intel.DecoderInternal.HandlerInfo : ValueType {
public OpCodeHandler handler
public OpCodeHandler[] handlers
public void .ctor(OpCodeHandler handler)
public void .ctor(OpCodeHandler[] handlers)
}
internal Iced.Intel.DecoderInternal.HandlerOptions : ValueType {
public OpCodeHandler handler
public DecoderOptions options
public void .ctor(OpCodeHandler handler, DecoderOptions options)
}
internal Iced.Intel.DecoderInternal.LegacyHandlerFlags : Enum {
public UInt32 value__
public LegacyHandlerFlags HandlerReg
public LegacyHandlerFlags HandlerMem
public LegacyHandlerFlags Handler66Reg
public LegacyHandlerFlags Handler66Mem
public LegacyHandlerFlags HandlerF3Reg
public LegacyHandlerFlags HandlerF3Mem
public LegacyHandlerFlags HandlerF2Reg
public LegacyHandlerFlags HandlerF2Mem
}
internal Iced.Intel.DecoderInternal.LegacyOpCodeHandlerKind : Enum {
public byte value__
public LegacyOpCodeHandlerKind Bitness
public LegacyOpCodeHandlerKind Bitness_DontReadModRM
public LegacyOpCodeHandlerKind Invalid
public LegacyOpCodeHandlerKind Invalid_NoModRM
public LegacyOpCodeHandlerKind Invalid2
public LegacyOpCodeHandlerKind Dup
public LegacyOpCodeHandlerKind Null
public LegacyOpCodeHandlerKind HandlerReference
public LegacyOpCodeHandlerKind ArrayReference
public LegacyOpCodeHandlerKind RM
public LegacyOpCodeHandlerKind Options3
public LegacyOpCodeHandlerKind Options5
public LegacyOpCodeHandlerKind Options_DontReadModRM
public LegacyOpCodeHandlerKind AnotherTable
public LegacyOpCodeHandlerKind Group
public LegacyOpCodeHandlerKind Group8x64
public LegacyOpCodeHandlerKind Group8x8
public LegacyOpCodeHandlerKind MandatoryPrefix
public LegacyOpCodeHandlerKind MandatoryPrefix4
public LegacyOpCodeHandlerKind Ev_REXW_1a
public LegacyOpCodeHandlerKind MandatoryPrefix_NoModRM
public LegacyOpCodeHandlerKind MandatoryPrefix3
public LegacyOpCodeHandlerKind D3NOW
public LegacyOpCodeHandlerKind EVEX
public LegacyOpCodeHandlerKind VEX2
public LegacyOpCodeHandlerKind VEX3
public LegacyOpCodeHandlerKind XOP
public LegacyOpCodeHandlerKind AL_DX
public LegacyOpCodeHandlerKind Ap
public LegacyOpCodeHandlerKind B_BM
public LegacyOpCodeHandlerKind B_Ev
public LegacyOpCodeHandlerKind B_MIB
public LegacyOpCodeHandlerKind BM_B
public LegacyOpCodeHandlerKind BranchIw
public LegacyOpCodeHandlerKind BranchSimple
public LegacyOpCodeHandlerKind C_R_3a
public LegacyOpCodeHandlerKind C_R_3b
public LegacyOpCodeHandlerKind DX_AL
public LegacyOpCodeHandlerKind DX_eAX
public LegacyOpCodeHandlerKind eAX_DX
public LegacyOpCodeHandlerKind Eb_1
public LegacyOpCodeHandlerKind Eb_2
public LegacyOpCodeHandlerKind Eb_CL
public LegacyOpCodeHandlerKind Eb_Gb_1
public LegacyOpCodeHandlerKind Eb_Gb_2
public LegacyOpCodeHandlerKind Eb_Ib_1
public LegacyOpCodeHandlerKind Eb_Ib_2
public LegacyOpCodeHandlerKind Eb1
public LegacyOpCodeHandlerKind Ed_V_Ib
public LegacyOpCodeHandlerKind Ep
public LegacyOpCodeHandlerKind Ev_3a
public LegacyOpCodeHandlerKind Ev_3b
public LegacyOpCodeHandlerKind Ev_4
public LegacyOpCodeHandlerKind Ev_CL
public LegacyOpCodeHandlerKind Ev_Gv_32_64
public LegacyOpCodeHandlerKind Ev_Gv_3a
public LegacyOpCodeHandlerKind Ev_Gv_3b
public LegacyOpCodeHandlerKind Ev_Gv_4
public LegacyOpCodeHandlerKind Ev_Gv_CL
public LegacyOpCodeHandlerKind Ev_Gv_Ib
public LegacyOpCodeHandlerKind Ev_Gv_REX
public LegacyOpCodeHandlerKind Ev_Ib_3
public LegacyOpCodeHandlerKind Ev_Ib_4
public LegacyOpCodeHandlerKind Ev_Ib2_3
public LegacyOpCodeHandlerKind Ev_Ib2_4
public LegacyOpCodeHandlerKind Ev_Iz_3
public LegacyOpCodeHandlerKind Ev_Iz_4
public LegacyOpCodeHandlerKind Ev_P
public LegacyOpCodeHandlerKind Ev_REXW
public LegacyOpCodeHandlerKind Ev_Sw
public LegacyOpCodeHandlerKind Ev_VX
public LegacyOpCodeHandlerKind Ev1
public LegacyOpCodeHandlerKind Evj
public LegacyOpCodeHandlerKind Evw
public LegacyOpCodeHandlerKind Ew
public LegacyOpCodeHandlerKind Gb_Eb
public LegacyOpCodeHandlerKind Gdq_Ev
public LegacyOpCodeHandlerKind Gv_Eb
public LegacyOpCodeHandlerKind Gv_Eb_REX
public LegacyOpCodeHandlerKind Gv_Ev_32_64
public LegacyOpCodeHandlerKind Gv_Ev_3a
public LegacyOpCodeHandlerKind Gv_Ev_3b
public LegacyOpCodeHandlerKind Gv_Ev_Ib
public LegacyOpCodeHandlerKind Gv_Ev_Ib_REX
public LegacyOpCodeHandlerKind Gv_Ev_Iz
public LegacyOpCodeHandlerKind Gv_Ev_REX
public LegacyOpCodeHandlerKind Gv_Ev2
public LegacyOpCodeHandlerKind Gv_Ev3
public LegacyOpCodeHandlerKind Gv_Ew
public LegacyOpCodeHandlerKind Gv_M
public LegacyOpCodeHandlerKind Gv_M_as
public LegacyOpCodeHandlerKind Gv_Ma
public LegacyOpCodeHandlerKind Gv_Mp_2
public LegacyOpCodeHandlerKind Gv_Mp_3
public LegacyOpCodeHandlerKind Gv_Mv
public LegacyOpCodeHandlerKind Gv_N
public LegacyOpCodeHandlerKind Gv_N_Ib_REX
public LegacyOpCodeHandlerKind Gv_RX
public LegacyOpCodeHandlerKind Gv_W
public LegacyOpCodeHandlerKind GvM_VX_Ib
public LegacyOpCodeHandlerKind Ib
public LegacyOpCodeHandlerKind Ib3
public LegacyOpCodeHandlerKind IbReg
public LegacyOpCodeHandlerKind IbReg2
public LegacyOpCodeHandlerKind Iw_Ib
public LegacyOpCodeHandlerKind Jb
public LegacyOpCodeHandlerKind Jb2
public LegacyOpCodeHandlerKind Jdisp
public LegacyOpCodeHandlerKind Jx
public LegacyOpCodeHandlerKind Jz
public LegacyOpCodeHandlerKind M_1
public LegacyOpCodeHandlerKind M_2
public LegacyOpCodeHandlerKind M_REXW_2
public LegacyOpCodeHandlerKind M_REXW_4
public LegacyOpCodeHandlerKind MemBx
public LegacyOpCodeHandlerKind Mf_1
public LegacyOpCodeHandlerKind Mf_2a
public LegacyOpCodeHandlerKind Mf_2b
public LegacyOpCodeHandlerKind MIB_B
public LegacyOpCodeHandlerKind MP
public LegacyOpCodeHandlerKind Ms
public LegacyOpCodeHandlerKind MV
public LegacyOpCodeHandlerKind Mv_Gv
public LegacyOpCodeHandlerKind Mv_Gv_REXW
public LegacyOpCodeHandlerKind NIb
public LegacyOpCodeHandlerKind Ob_Reg
public LegacyOpCodeHandlerKind Ov_Reg
public LegacyOpCodeHandlerKind P_Ev
public LegacyOpCodeHandlerKind P_Ev_Ib
public LegacyOpCodeHandlerKind P_Q
public LegacyOpCodeHandlerKind P_Q_Ib
public LegacyOpCodeHandlerKind P_R
public LegacyOpCodeHandlerKind P_W
public LegacyOpCodeHandlerKind PushEv
public LegacyOpCodeHandlerKind PushIb2
public LegacyOpCodeHandlerKind PushIz
public LegacyOpCodeHandlerKind PushOpSizeReg_4a
public LegacyOpCodeHandlerKind PushOpSizeReg_4b
public LegacyOpCodeHandlerKind PushSimple2
public LegacyOpCodeHandlerKind PushSimpleReg
public LegacyOpCodeHandlerKind Q_P
public LegacyOpCodeHandlerKind R_C_3a
public LegacyOpCodeHandlerKind R_C_3b
public LegacyOpCodeHandlerKind rDI_P_N
public LegacyOpCodeHandlerKind rDI_VX_RX
public LegacyOpCodeHandlerKind Reg
public LegacyOpCodeHandlerKind Reg_Ib2
public LegacyOpCodeHandlerKind Reg_Iz
public LegacyOpCodeHandlerKind Reg_Ob
public LegacyOpCodeHandlerKind Reg_Ov
public LegacyOpCodeHandlerKind Reg_Xb
public LegacyOpCodeHandlerKind Reg_Xv
public LegacyOpCodeHandlerKind Reg_Xv2
public LegacyOpCodeHandlerKind Reg_Yb
public LegacyOpCodeHandlerKind Reg_Yv
public LegacyOpCodeHandlerKind RegIb
public LegacyOpCodeHandlerKind RegIb3
public LegacyOpCodeHandlerKind RegIz2
public LegacyOpCodeHandlerKind Reservednop
public LegacyOpCodeHandlerKind RIb
public LegacyOpCodeHandlerKind RIbIb
public LegacyOpCodeHandlerKind Rv
public LegacyOpCodeHandlerKind Rv_32_64
public LegacyOpCodeHandlerKind RvMw_Gw
public LegacyOpCodeHandlerKind Simple
public LegacyOpCodeHandlerKind Simple_ModRM
public LegacyOpCodeHandlerKind Simple2_3a
public LegacyOpCodeHandlerKind Simple2_3b
public LegacyOpCodeHandlerKind Simple2Iw
public LegacyOpCodeHandlerKind Simple3
public LegacyOpCodeHandlerKind Simple4
public LegacyOpCodeHandlerKind Simple5
public LegacyOpCodeHandlerKind Simple5_ModRM_as
public LegacyOpCodeHandlerKind SimpleReg
public LegacyOpCodeHandlerKind ST_STi
public LegacyOpCodeHandlerKind STi
public LegacyOpCodeHandlerKind STi_ST
public LegacyOpCodeHandlerKind Sw_Ev
public LegacyOpCodeHandlerKind V_Ev
public LegacyOpCodeHandlerKind VM
public LegacyOpCodeHandlerKind VN
public LegacyOpCodeHandlerKind VQ
public LegacyOpCodeHandlerKind VRIbIb
public LegacyOpCodeHandlerKind VW_2
public LegacyOpCodeHandlerKind VW_3
public LegacyOpCodeHandlerKind VWIb_2
public LegacyOpCodeHandlerKind VWIb_3
public LegacyOpCodeHandlerKind VX_E_Ib
public LegacyOpCodeHandlerKind VX_Ev
public LegacyOpCodeHandlerKind Wbinvd
public LegacyOpCodeHandlerKind WV
public LegacyOpCodeHandlerKind Xb_Yb
public LegacyOpCodeHandlerKind Xchg_Reg_rAX
public LegacyOpCodeHandlerKind Xv_Yv
public LegacyOpCodeHandlerKind Yb_Reg
public LegacyOpCodeHandlerKind Yb_Xb
public LegacyOpCodeHandlerKind Yv_Reg
public LegacyOpCodeHandlerKind Yv_Reg2
public LegacyOpCodeHandlerKind Yv_Xv
public LegacyOpCodeHandlerKind Simple4b
public LegacyOpCodeHandlerKind Options1632_1
public LegacyOpCodeHandlerKind Options1632_2
public LegacyOpCodeHandlerKind M_Sw
public LegacyOpCodeHandlerKind Sw_M
public LegacyOpCodeHandlerKind Rq
public LegacyOpCodeHandlerKind Gd_Rd
public LegacyOpCodeHandlerKind PrefixEsCsSsDs
public LegacyOpCodeHandlerKind PrefixFsGs
public LegacyOpCodeHandlerKind Prefix66
public LegacyOpCodeHandlerKind Prefix67
public LegacyOpCodeHandlerKind PrefixF0
public LegacyOpCodeHandlerKind PrefixF2
public LegacyOpCodeHandlerKind PrefixF3
public LegacyOpCodeHandlerKind PrefixREX
public LegacyOpCodeHandlerKind Simple5_a32
}
internal Iced.Intel.DecoderInternal.LegacyOpCodeHandlerReader : OpCodeHandlerReader {
public int ReadHandlers(TableDeserializer& deserializer, OpCodeHandler[] result, int resultIndex)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler : object {
public bool HasModRM
protected void .ctor(bool hasModRM)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_AL_DX : OpCodeHandler {
private Code code
public void .ctor(Code code)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_AnotherTable : OpCodeHandler {
private OpCodeHandler[] otherTable
public void .ctor(OpCodeHandler[] otherTable)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_Ap : OpCodeHandler {
private Code code16
private Code code32
public void .ctor(Code code16, Code code32)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_B_BM : OpCodeHandlerModRM {
private Code code32
private Code code64
public void .ctor(Code code32, Code code64)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_B_Ev : OpCodeHandlerModRM {
private Code code32
private Code code64
private UInt32 ripRelMask
public void .ctor(Code code32, Code code64, bool supportsRipRel)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_B_MIB : OpCodeHandlerModRM {
private Code code
public void .ctor(Code code)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_Bitness : OpCodeHandler {
private OpCodeHandler handler1632
private OpCodeHandler handler64
public void .ctor(OpCodeHandler handler1632, OpCodeHandler handler64)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_Bitness_DontReadModRM : OpCodeHandlerModRM {
private OpCodeHandler handler1632
private OpCodeHandler handler64
public void .ctor(OpCodeHandler handler1632, OpCodeHandler handler64)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_BM_B : OpCodeHandlerModRM {
private Code code32
private Code code64
public void .ctor(Code code32, Code code64)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_BranchIw : OpCodeHandler {
private Code code16
private Code code32
private Code code64
public void .ctor(Code code16, Code code32, Code code64)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_BranchSimple : OpCodeHandler {
private Code code16
private Code code32
private Code code64
public void .ctor(Code code16, Code code32, Code code64)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_C_R : OpCodeHandlerModRM {
private Code code32
private Code code64
private Register baseReg
public void .ctor(Code code32, Code code64, Register baseReg)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_D3NOW : OpCodeHandlerModRM {
internal Code[] CodeValues
private Code[] codeValues
private Code[] CreateCodeValues()
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_DX_AL : OpCodeHandler {
private Code code
public void .ctor(Code code)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_DX_eAX : OpCodeHandler {
private Code code16
private Code code32
public void .ctor(Code code16, Code code32)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_eAX_DX : OpCodeHandler {
private Code code16
private Code code32
public void .ctor(Code code16, Code code32)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_Eb : OpCodeHandlerModRM {
private Code code
private HandlerFlags flags
public void .ctor(Code code)
public void .ctor(Code code, HandlerFlags flags)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_Eb_1 : OpCodeHandlerModRM {
private Code code
public void .ctor(Code code)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_Eb_CL : OpCodeHandlerModRM {
private Code code
public void .ctor(Code code)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_Eb_Gb : OpCodeHandlerModRM {
private Code code
private HandlerFlags flags
public void .ctor(Code code)
public void .ctor(Code code, HandlerFlags flags)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_Eb_Ib : OpCodeHandlerModRM {
private Code code
private HandlerFlags flags
public void .ctor(Code code)
public void .ctor(Code code, HandlerFlags flags)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_Ed_V_Ib : OpCodeHandlerModRM {
private Code code32
private Code code64
public void .ctor(Code code32, Code code64)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_Ep : OpCodeHandlerModRM {
private Code code16
private Code code32
private Code code64
public void .ctor(Code code16, Code code32, Code code64)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_Ev : OpCodeHandlerModRM {
private Code3 codes
private HandlerFlags flags
public void .ctor(Code code16, Code code32, Code code64)
public void .ctor(Code code16, Code code32, Code code64, HandlerFlags flags)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_Ev_1 : OpCodeHandlerModRM {
private Code3 codes
public void .ctor(Code code16, Code code32, Code code64)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_Ev_CL : OpCodeHandlerModRM {
private Code3 codes
public void .ctor(Code code16, Code code32, Code code64)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_Ev_Gv : OpCodeHandlerModRM {
private Code3 codes
private HandlerFlags flags
public void .ctor(Code code16, Code code32, Code code64)
public void .ctor(Code code16, Code code32, Code code64, HandlerFlags flags)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_Ev_Gv_32_64 : OpCodeHandlerModRM {
private Code code32
private Code code64
public void .ctor(Code code32, Code code64)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_Ev_Gv_CL : OpCodeHandlerModRM {
private Code3 codes
public void .ctor(Code code16, Code code32, Code code64)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_Ev_Gv_Ib : OpCodeHandlerModRM {
private Code3 codes
public void .ctor(Code code16, Code code32, Code code64)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_Ev_Gv_REX : OpCodeHandlerModRM {
private Code code32
private Code code64
public void .ctor(Code code32, Code code64)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_Ev_Ib : OpCodeHandlerModRM {
private Code3 codes
private HandlerFlags flags
public void .ctor(Code code16, Code code32, Code code64)
public void .ctor(Code code16, Code code32, Code code64, HandlerFlags flags)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_Ev_Ib2 : OpCodeHandlerModRM {
private Code3 codes
private HandlerFlags flags
public void .ctor(Code code16, Code code32, Code code64)
public void .ctor(Code code16, Code code32, Code code64, HandlerFlags flags)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_Ev_Iz : OpCodeHandlerModRM {
private Code3 codes
private HandlerFlags flags
public void .ctor(Code code16, Code code32, Code code64)
public void .ctor(Code code16, Code code32, Code code64, HandlerFlags flags)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_Ev_P : OpCodeHandlerModRM {
private Code code32
private Code code64
public void .ctor(Code code32, Code code64)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_Ev_REXW : OpCodeHandlerModRM {
private Code code32
private Code code64
private UInt32 flags
private UInt32 disallowReg
private UInt32 disallowMem
public void .ctor(Code code32, Code code64, UInt32 flags)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_Ev_Sw : OpCodeHandlerModRM {
private Code3 codes
public void .ctor(Code code16, Code code32, Code code64)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_Ev_VX : OpCodeHandlerModRM {
private Code code32
private Code code64
public void .ctor(Code code32, Code code64)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_EVEX : OpCodeHandlerModRM {
private OpCodeHandler handlerMem
public void .ctor(OpCodeHandler handlerMem)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_EVEX_Ed_V_Ib : OpCodeHandlerModRM {
private Register baseReg
private Code code32
private Code code64
private TupleType tupleType32
private TupleType tupleType64
public void .ctor(Register baseReg, Code code32, Code code64, TupleType tupleType32, TupleType tupleType64)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_EVEX_Ev_VX : OpCodeHandlerModRM {
private Code code32
private Code code64
private TupleType tupleTypeW0
private TupleType tupleTypeW1
public void .ctor(Code code32, Code code64, TupleType tupleTypeW0, TupleType tupleTypeW1)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_EVEX_Ev_VX_Ib : OpCodeHandlerModRM {
private Register baseReg
private Code code32
private Code code64
public void .ctor(Register baseReg, Code code32, Code code64)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_EVEX_Gv_W_er : OpCodeHandlerModRM {
private Register baseReg
private Code codeW0
private Code codeW1
private TupleType tupleType
private bool onlySAE
public void .ctor(Register baseReg, Code codeW0, Code codeW1, TupleType tupleType, bool onlySAE)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_EVEX_GvM_VX_Ib : OpCodeHandlerModRM {
private Register baseReg
private Code code32
private Code code64
private TupleType tupleType32
private TupleType tupleType64
public void .ctor(Register baseReg, Code code32, Code code64, TupleType tupleType32, TupleType tupleType64)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_EVEX_HkWIb : OpCodeHandlerModRM {
private Register baseReg1
private Register baseReg2
private Code code
private TupleType tupleType
private bool canBroadcast
public void .ctor(Register baseReg, Code code, TupleType tupleType, bool canBroadcast)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_EVEX_HWIb : OpCodeHandlerModRM {
private Register baseReg1
private Register baseReg2
private Code code
private TupleType tupleType
public void .ctor(Register baseReg, Code code, TupleType tupleType)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_EVEX_KkHW : OpCodeHandlerModRM {
private Register baseReg
private Code code
private TupleType tupleType
private bool canBroadcast
public void .ctor(Register baseReg, Code code, TupleType tupleType, bool canBroadcast)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_EVEX_KkHWIb : OpCodeHandlerModRM {
private Register baseReg
private Code code
private TupleType tupleType
private bool canBroadcast
public void .ctor(Register baseReg, Code code, TupleType tupleType, bool canBroadcast)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_EVEX_KkHWIb_sae : OpCodeHandlerModRM {
private Register baseReg
private Code code
private TupleType tupleType
private bool canBroadcast
public void .ctor(Register baseReg, Code code, TupleType tupleType, bool canBroadcast)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_EVEX_KkWIb : OpCodeHandlerModRM {
private Register baseReg
private Code code
private TupleType tupleType
private bool canBroadcast
public void .ctor(Register baseReg, Code code, TupleType tupleType, bool canBroadcast)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_EVEX_KP1HW : OpCodeHandlerModRM {
private Register baseReg
private Code code
private TupleType tupleType
public void .ctor(Register baseReg, Code code, TupleType tupleType)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_EVEX_KR : OpCodeHandlerModRM {
private Register baseReg
private Code code
public void .ctor(Register baseReg, Code code)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_EVEX_MV : OpCodeHandlerModRM {
private Register baseReg
private Code code
private TupleType tupleType
public void .ctor(Register baseReg, Code code, TupleType tupleType)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_EVEX_V_H_Ev_er : OpCodeHandlerModRM {
private Register baseReg
private Code codeW0
private Code codeW1
private TupleType tupleTypeW0
private TupleType tupleTypeW1
public void .ctor(Register baseReg, Code codeW0, Code codeW1, TupleType tupleTypeW0, TupleType tupleTypeW1)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_EVEX_V_H_Ev_Ib : OpCodeHandlerModRM {
private Register baseReg
private Code codeW0
private Code codeW1
private TupleType tupleTypeW0
private TupleType tupleTypeW1
public void .ctor(Register baseReg, Code codeW0, Code codeW1, TupleType tupleTypeW0, TupleType tupleTypeW1)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_EVEX_VHM : OpCodeHandlerModRM {
private Register baseReg
private Code code
private TupleType tupleType
public void .ctor(Register baseReg, Code code, TupleType tupleType)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_EVEX_VHW : OpCodeHandlerModRM {
private Register baseReg1
private Register baseReg2
private Register baseReg3
private Code codeR
private Code codeM
private TupleType tupleType
public void .ctor(Register baseReg, Code codeR, Code codeM, TupleType tupleType)
public void .ctor(Register baseReg, Code code, TupleType tupleType)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_EVEX_VHWIb : OpCodeHandlerModRM {
private Register baseReg
private Code code
private TupleType tupleType
public void .ctor(Register baseReg, Code code, TupleType tupleType)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_EVEX_VK : OpCodeHandlerModRM {
private Register baseReg
private Code code
public void .ctor(Register baseReg, Code code)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_EVEX_Vk_VSIB : OpCodeHandlerModRM {
private Register baseReg
private Register vsibBase
private Code code
private TupleType tupleType
public void .ctor(Register baseReg, Register vsibBase, Code code, TupleType tupleType)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_EVEX_VkEv_REXW : OpCodeHandlerModRM {
private Register baseReg
private Code code32
private Code code64
public void .ctor(Register baseReg, Code code32)
public void .ctor(Register baseReg, Code code32, Code code64)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_EVEX_VkHM : OpCodeHandlerModRM {
private Register baseReg1
private Register baseReg2
private Code code
private TupleType tupleType
public void .ctor(Register baseReg, Code code, TupleType tupleType)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_EVEX_VkHW : OpCodeHandlerModRM {
private Register baseReg1
private Register baseReg2
private Register baseReg3
private Code code
private TupleType tupleType
private bool canBroadcast
public void .ctor(Register baseReg, Code code, TupleType tupleType, bool canBroadcast)
public void .ctor(Register baseReg1, Register baseReg2, Register baseReg3, Code code, TupleType tupleType, bool canBroadcast)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_EVEX_VkHW_er : OpCodeHandlerModRM {
private Register baseReg
private Code code
private TupleType tupleType
private bool onlySAE
private bool canBroadcast
public void .ctor(Register baseReg, Code code, TupleType tupleType, bool onlySAE, bool canBroadcast)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_EVEX_VkHW_er_ur : OpCodeHandlerModRM {
private Register baseReg
private Code code
private TupleType tupleType
private bool canBroadcast
public void .ctor(Register baseReg, Code code, TupleType tupleType, bool canBroadcast)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_EVEX_VkHWIb : OpCodeHandlerModRM {
private Register baseReg1
private Register baseReg2
private Register baseReg3
private Code code
private TupleType tupleType
private bool canBroadcast
public void .ctor(Register baseReg, Code code, TupleType tupleType, bool canBroadcast)
public void .ctor(Register baseReg1, Register baseReg2, Register baseReg3, Code code, TupleType tupleType, bool canBroadcast)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_EVEX_VkHWIb_er : OpCodeHandlerModRM {
private Register baseReg1
private Register baseReg2
private Register baseReg3
private Code code
private TupleType tupleType
private bool canBroadcast
public void .ctor(Register baseReg, Code code, TupleType tupleType, bool canBroadcast)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_EVEX_VkM : OpCodeHandlerModRM {
private Register baseReg
private Code code
private TupleType tupleType
public void .ctor(Register baseReg, Code code, TupleType tupleType)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_EVEX_VkW : OpCodeHandlerModRM {
private Register baseReg1
private Register baseReg2
private Code code
private TupleType tupleType
private bool canBroadcast
public void .ctor(Register baseReg, Code code, TupleType tupleType, bool canBroadcast)
public void .ctor(Register baseReg1, Register baseReg2, Code code, TupleType tupleType, bool canBroadcast)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_EVEX_VkW_er : OpCodeHandlerModRM {
private Register baseReg1
private Register baseReg2
private Code code
private TupleType tupleType
private bool onlySAE
private bool canBroadcast
public void .ctor(Register baseReg, Code code, TupleType tupleType, bool onlySAE)
public void .ctor(Register baseReg1, Register baseReg2, Code code, TupleType tupleType, bool onlySAE)
public void .ctor(Register baseReg1, Register baseReg2, Code code, TupleType tupleType, bool onlySAE, bool canBroadcast)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_EVEX_VkWIb : OpCodeHandlerModRM {
private Register baseReg1
private Register baseReg2
private Code code
private TupleType tupleType
private bool canBroadcast
public void .ctor(Register baseReg, Code code, TupleType tupleType, bool canBroadcast)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_EVEX_VkWIb_er : OpCodeHandlerModRM {
private Register baseReg1
private Register baseReg2
private Code code
private TupleType tupleType
public void .ctor(Register baseReg, Code code, TupleType tupleType)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_EVEX_VM : OpCodeHandlerModRM {
private Register baseReg
private Code code
private TupleType tupleType
public void .ctor(Register baseReg, Code code, TupleType tupleType)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_EVEX_VSIB_k1 : OpCodeHandlerModRM {
private Register vsibIndex
private Code code
private TupleType tupleType
public void .ctor(Register vsibIndex, Code code, TupleType tupleType)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_EVEX_VSIB_k1_VX : OpCodeHandlerModRM {
private Register vsibIndex
private Register baseReg
private Code code
private TupleType tupleType
public void .ctor(Register vsibIndex, Register baseReg, Code code, TupleType tupleType)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_EVEX_VW : OpCodeHandlerModRM {
private Register baseReg1
private Register baseReg2
private Code code
private TupleType tupleType
public void .ctor(Register baseReg, Code code, TupleType tupleType)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_EVEX_VW_er : OpCodeHandlerModRM {
private Register baseReg1
private Register baseReg2
private Code code
private TupleType tupleType
public void .ctor(Register baseReg, Code code, TupleType tupleType)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_EVEX_VX_Ev : OpCodeHandlerModRM {
private Code code32
private Code code64
private TupleType tupleTypeW0
private TupleType tupleTypeW1
public void .ctor(Code code32, Code code64, TupleType tupleTypeW0, TupleType tupleTypeW1)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_EVEX_WkHV : OpCodeHandlerModRM {
private Register baseReg
private Code code
public void .ctor(Register baseReg, Code code)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_EVEX_WkV : OpCodeHandlerModRM {
private Register baseReg1
private Register baseReg2
private Code code
private TupleType tupleType
private UInt32 disallowZeroingMasking
public void .ctor(Register baseReg, Code code, TupleType tupleType)
public void .ctor(Register baseReg, Code code, TupleType tupleType, bool allowZeroingMasking)
public void .ctor(Register baseReg1, Register baseReg2, Code code, TupleType tupleType)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_EVEX_WkVIb : OpCodeHandlerModRM {
private Register baseReg1
private Register baseReg2
private Code code
private TupleType tupleType
public void .ctor(Register baseReg1, Register baseReg2, Code code, TupleType tupleType)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_EVEX_WkVIb_er : OpCodeHandlerModRM {
private Register baseReg1
private Register baseReg2
private Code code
private TupleType tupleType
public void .ctor(Register baseReg1, Register baseReg2, Code code, TupleType tupleType)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_EVEX_WV : OpCodeHandlerModRM {
private Register baseReg1
private Register baseReg2
private Code code
private TupleType tupleType
public void .ctor(Register baseReg, Code code, TupleType tupleType)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_Evj : OpCodeHandlerModRM {
private Code code16
private Code code32
private Code code64
public void .ctor(Code code16, Code code32, Code code64)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_Evw : OpCodeHandlerModRM {
private Code3 codes
public void .ctor(Code code16, Code code32, Code code64)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_Ew : OpCodeHandlerModRM {
private Code3 codes
public void .ctor(Code code16, Code code32, Code code64)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_Gb_Eb : OpCodeHandlerModRM {
private Code code
public void .ctor(Code code)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_Gd_Rd : OpCodeHandlerModRM {
private Code code
public void .ctor(Code code)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_Gdq_Ev : OpCodeHandlerModRM {
private Code3 codes
public void .ctor(Code code16, Code code32, Code code64)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_Group : OpCodeHandlerModRM {
private OpCodeHandler[] groupHandlers
public void .ctor(OpCodeHandler[] groupHandlers)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_Group8x64 : OpCodeHandlerModRM {
private OpCodeHandler[] tableLow
private OpCodeHandler[] tableHigh
public void .ctor(OpCodeHandler[] tableLow, OpCodeHandler[] tableHigh)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_Group8x8 : OpCodeHandlerModRM {
private OpCodeHandler[] tableLow
private OpCodeHandler[] tableHigh
public void .ctor(OpCodeHandler[] tableLow, OpCodeHandler[] tableHigh)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_Gv_Eb : OpCodeHandlerModRM {
private Code3 codes
public void .ctor(Code code16, Code code32, Code code64)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_Gv_Eb_REX : OpCodeHandlerModRM {
private Code code32
private Code code64
public void .ctor(Code code32, Code code64)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_Gv_Ev : OpCodeHandlerModRM {
private Code3 codes
public void .ctor(Code code16, Code code32, Code code64)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_Gv_Ev_32_64 : OpCodeHandlerModRM {
private Code code32
private Code code64
private UInt32 disallowReg
private UInt32 disallowMem
public void .ctor(Code code32, Code code64, bool allowReg, bool allowMem)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_Gv_Ev_Ib : OpCodeHandlerModRM {
private Code3 codes
public void .ctor(Code code16, Code code32, Code code64)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_Gv_Ev_Ib_REX : OpCodeHandlerModRM {
private Code code32
private Code code64
public void .ctor(Code code32, Code code64)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_Gv_Ev_Iz : OpCodeHandlerModRM {
private Code3 codes
public void .ctor(Code code16, Code code32, Code code64)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_Gv_Ev_REX : OpCodeHandlerModRM {
private Code code32
private Code code64
public void .ctor(Code code32, Code code64)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_Gv_Ev2 : OpCodeHandlerModRM {
private Code3 codes
public void .ctor(Code code16, Code code32, Code code64)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_Gv_Ev3 : OpCodeHandlerModRM {
private Code3 codes
public void .ctor(Code code16, Code code32, Code code64)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_Gv_Ew : OpCodeHandlerModRM {
private Code3 codes
public void .ctor(Code code16, Code code32, Code code64)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_Gv_M : OpCodeHandlerModRM {
private Code3 codes
public void .ctor(Code code16, Code code32, Code code64)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_Gv_M_as : OpCodeHandlerModRM {
private Code3 codes
public void .ctor(Code code16, Code code32, Code code64)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_Gv_Ma : OpCodeHandlerModRM {
private Code code16
private Code code32
public void .ctor(Code code16, Code code32)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_Gv_Mp : OpCodeHandlerModRM {
private Code code16
private Code code32
private Code code64
public void .ctor(Code code16, Code code32, Code code64)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_Gv_Mv : OpCodeHandlerModRM {
private Code3 codes
public void .ctor(Code code16, Code code32, Code code64)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_Gv_N : OpCodeHandlerModRM {
private Code code32
private Code code64
public void .ctor(Code code32, Code code64)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_Gv_N_Ib_REX : OpCodeHandlerModRM {
private Code code32
private Code code64
public void .ctor(Code code32, Code code64)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_Gv_RX : OpCodeHandlerModRM {
private Code code32
private Code code64
public void .ctor(Code code32, Code code64)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_Gv_W : OpCodeHandlerModRM {
private Code codeW0
private Code codeW1
public void .ctor(Code codeW0, Code codeW1)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_GvM_VX_Ib : OpCodeHandlerModRM {
private Code code32
private Code code64
public void .ctor(Code code32, Code code64)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_Ib : OpCodeHandler {
private Code code
public void .ctor(Code code)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_Ib3 : OpCodeHandlerModRM {
private Code code
public void .ctor(Code code)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_IbReg : OpCodeHandler {
private Code code
private Register reg
public void .ctor(Code code, Register reg)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_IbReg2 : OpCodeHandler {
private Code code16
private Code code32
public void .ctor(Code code16, Code code32)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_Invalid : OpCodeHandlerModRM {
public OpCodeHandler_Invalid Instance
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_Invalid_NoModRM : OpCodeHandler {
public OpCodeHandler_Invalid_NoModRM Instance
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_Iw_Ib : OpCodeHandler {
private Code code16
private Code code32
private Code code64
public void .ctor(Code code16, Code code32, Code code64)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_Jb : OpCodeHandler {
private Code code16
private Code code32
private Code code64
public void .ctor(Code code16, Code code32, Code code64)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_Jb2 : OpCodeHandler {
private Code code16_16
private Code code16_32
private Code code16_64
private Code code32_16
private Code code32_32
private Code code64_32
private Code code64_64
public void .ctor(Code code16_16, Code code16_32, Code code16_64, Code code32_16, Code code32_32, Code code64_32, Code code64_64)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_Jdisp : OpCodeHandler {
private Code code16
private Code code32
public void .ctor(Code code16, Code code32)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_Jx : OpCodeHandler {
private Code code16
private Code code32
private Code code64
public void .ctor(Code code16, Code code32, Code code64)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_Jz : OpCodeHandler {
private Code code16
private Code code32
private Code code64
public void .ctor(Code code16, Code code32, Code code64)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_M : OpCodeHandlerModRM {
private Code codeW0
private Code codeW1
public void .ctor(Code codeW0, Code codeW1)
public void .ctor(Code codeW0)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_M_REXW : OpCodeHandlerModRM {
private Code code32
private Code code64
private HandlerFlags flags32
private HandlerFlags flags64
public void .ctor(Code code32, Code code64)
public void .ctor(Code code32, Code code64, HandlerFlags flags32, HandlerFlags flags64)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_M_Sw : OpCodeHandlerModRM {
private Code code
public void .ctor(Code code)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_MandatoryPrefix : OpCodeHandlerModRM {
private OpCodeHandler[] handlers
public void .ctor(OpCodeHandler handler, OpCodeHandler handler66, OpCodeHandler handlerF3, OpCodeHandler handlerF2)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_MandatoryPrefix_NoModRM : OpCodeHandler {
private OpCodeHandler[] handlers
public void .ctor(OpCodeHandler handler, OpCodeHandler handler66, OpCodeHandler handlerF3, OpCodeHandler handlerF2)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_MandatoryPrefix2 : OpCodeHandlerModRM {
private OpCodeHandler[] handlers
public void .ctor(OpCodeHandler handler)
public void .ctor(OpCodeHandler handler, OpCodeHandler handler66, OpCodeHandler handlerF3, OpCodeHandler handlerF2)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_MandatoryPrefix2_NoModRM : OpCodeHandler {
private OpCodeHandler[] handlers
public void .ctor(OpCodeHandler handler, OpCodeHandler handler66, OpCodeHandler handlerF3, OpCodeHandler handlerF2)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_MandatoryPrefix3 : OpCodeHandlerModRM {
private Info[] handlers_reg
private Info[] handlers_mem
public void .ctor(OpCodeHandler handler_reg, OpCodeHandler handler_mem, OpCodeHandler handler66_reg, OpCodeHandler handler66_mem, OpCodeHandler handlerF3_reg, OpCodeHandler handlerF3_mem, OpCodeHandler handlerF2_reg, OpCodeHandler handlerF2_mem, LegacyHandlerFlags flags)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_MandatoryPrefix4 : OpCodeHandler {
private OpCodeHandler handlerNP
private OpCodeHandler handler66
private OpCodeHandler handlerF3
private OpCodeHandler handlerF2
private UInt32 flags
public void .ctor(OpCodeHandler handlerNP, OpCodeHandler handler66, OpCodeHandler handlerF3, OpCodeHandler handlerF2, UInt32 flags)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_MemBx : OpCodeHandler {
private Code code
public void .ctor(Code code)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_Mf : OpCodeHandlerModRM {
private Code code16
private Code code32
public void .ctor(Code code)
public void .ctor(Code code16, Code code32)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_MIB_B : OpCodeHandlerModRM {
private Code code
public void .ctor(Code code)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_MP : OpCodeHandlerModRM {
private Code code
public void .ctor(Code code)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_Ms : OpCodeHandlerModRM {
private Code code16
private Code code32
private Code code64
public void .ctor(Code code16, Code code32, Code code64)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_MV : OpCodeHandlerModRM {
private Code code
public void .ctor(Code code)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_Mv_Gv : OpCodeHandlerModRM {
private Code3 codes
public void .ctor(Code code16, Code code32, Code code64)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_Mv_Gv_REXW : OpCodeHandlerModRM {
private Code code32
private Code code64
public void .ctor(Code code32, Code code64)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_NIb : OpCodeHandlerModRM {
private Code code
public void .ctor(Code code)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_Ob_Reg : OpCodeHandler {
private Code code
private Register reg
public void .ctor(Code code, Register reg)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_Options : OpCodeHandler {
private OpCodeHandler defaultHandler
private HandlerOptions[] infos
private DecoderOptions infoOptions
public void .ctor(OpCodeHandler defaultHandler, OpCodeHandler handler1, DecoderOptions options1)
public void .ctor(OpCodeHandler defaultHandler, OpCodeHandler handler1, DecoderOptions options1, OpCodeHandler handler2, DecoderOptions options2)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_Options_DontReadModRM : OpCodeHandlerModRM {
private OpCodeHandler defaultHandler
private HandlerOptions[] infos
public void .ctor(OpCodeHandler defaultHandler, OpCodeHandler handler1, DecoderOptions options1)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_Options1632 : OpCodeHandler {
private OpCodeHandler defaultHandler
private HandlerOptions[] infos
private DecoderOptions infoOptions
public void .ctor(OpCodeHandler defaultHandler, OpCodeHandler handler1, DecoderOptions options1)
public void .ctor(OpCodeHandler defaultHandler, OpCodeHandler handler1, DecoderOptions options1, OpCodeHandler handler2, DecoderOptions options2)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_Ov_Reg : OpCodeHandler {
private Code3 codes
public void .ctor(Code code16, Code code32, Code code64)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_P_Ev : OpCodeHandlerModRM {
private Code code32
private Code code64
public void .ctor(Code code32, Code code64)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_P_Ev_Ib : OpCodeHandlerModRM {
private Code code32
private Code code64
public void .ctor(Code code32, Code code64)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_P_Q : OpCodeHandlerModRM {
private Code code
public void .ctor(Code code)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_P_Q_Ib : OpCodeHandlerModRM {
private Code code
public void .ctor(Code code)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_P_R : OpCodeHandlerModRM {
private Code code
public void .ctor(Code code)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_P_W : OpCodeHandlerModRM {
private Code code
public void .ctor(Code code)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_Prefix66 : OpCodeHandler {
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_Prefix67 : OpCodeHandler {
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_PrefixEsCsSsDs : OpCodeHandler {
private Register seg
public void .ctor(Register seg)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_PrefixF0 : OpCodeHandler {
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_PrefixF2 : OpCodeHandler {
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_PrefixF3 : OpCodeHandler {
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_PrefixFsGs : OpCodeHandler {
private Register seg
public void .ctor(Register seg)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_PrefixREX : OpCodeHandler {
private OpCodeHandler handler
private UInt32 rex
public void .ctor(OpCodeHandler handler, UInt32 rex)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_PushEv : OpCodeHandlerModRM {
private Code code16
private Code code32
private Code code64
public void .ctor(Code code16, Code code32, Code code64)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_PushIb2 : OpCodeHandler {
private Code code16
private Code code32
private Code code64
public void .ctor(Code code16, Code code32, Code code64)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_PushIz : OpCodeHandler {
private Code code16
private Code code32
private Code code64
public void .ctor(Code code16, Code code32, Code code64)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_PushOpSizeReg : OpCodeHandler {
private Code code16
private Code code32
private Code code64
private Register reg
public void .ctor(Code code16, Code code32, Code code64, Register reg)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_PushSimple2 : OpCodeHandler {
private Code code16
private Code code32
private Code code64
public void .ctor(Code code16, Code code32, Code code64)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_PushSimpleReg : OpCodeHandler {
private int index
private Code code16
private Code code32
private Code code64
public void .ctor(int index, Code code16, Code code32, Code code64)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_Q_P : OpCodeHandlerModRM {
private Code code
public void .ctor(Code code)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_R_C : OpCodeHandlerModRM {
private Code code32
private Code code64
private Register baseReg
public void .ctor(Code code32, Code code64, Register baseReg)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_rDI_P_N : OpCodeHandlerModRM {
private Code code
public void .ctor(Code code)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_rDI_VX_RX : OpCodeHandlerModRM {
private Code code
public void .ctor(Code code)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_Reg : OpCodeHandler {
private Code code
private Register reg
public void .ctor(Code code, Register reg)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_Reg_Ib2 : OpCodeHandler {
private Code code16
private Code code32
public void .ctor(Code code16, Code code32)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_Reg_Iz : OpCodeHandler {
private Code code16
private Code code32
private Code code64
public void .ctor(Code code16, Code code32, Code code64)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_Reg_Ob : OpCodeHandler {
private Code code
private Register reg
public void .ctor(Code code, Register reg)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_Reg_Ov : OpCodeHandler {
private Code3 codes
public void .ctor(Code code16, Code code32, Code code64)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_Reg_Xb : OpCodeHandler {
private Code code
private Register reg
public void .ctor(Code code, Register reg)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_Reg_Xv : OpCodeHandler {
private Code3 codes
public void .ctor(Code code16, Code code32, Code code64)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_Reg_Xv2 : OpCodeHandler {
private Code code16
private Code code32
public void .ctor(Code code16, Code code32)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_Reg_Yb : OpCodeHandler {
private Code code
private Register reg
public void .ctor(Code code, Register reg)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_Reg_Yv : OpCodeHandler {
private Code3 codes
public void .ctor(Code code16, Code code32, Code code64)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_RegIb : OpCodeHandler {
private Code code
private Register reg
public void .ctor(Code code, Register reg)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_RegIb3 : OpCodeHandler {
private int index
private Register[] withRexPrefix
private Register[] s_withRexPrefix
public void .ctor(int index)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_RegIz2 : OpCodeHandler {
private int index
public void .ctor(int index)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_Reservednop : OpCodeHandlerModRM {
private OpCodeHandler reservedNopHandler
private OpCodeHandler otherHandler
public void .ctor(OpCodeHandler reservedNopHandler, OpCodeHandler otherHandler)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_RIb : OpCodeHandlerModRM {
private Code code
public void .ctor(Code code)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_RIbIb : OpCodeHandlerModRM {
private Code code
public void .ctor(Code code)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_RM : OpCodeHandlerModRM {
private OpCodeHandler reg
private OpCodeHandler mem
public void .ctor(OpCodeHandler reg, OpCodeHandler mem)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_Rq : OpCodeHandlerModRM {
private Code code
public void .ctor(Code code)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_Rv : OpCodeHandlerModRM {
private Code3 codes
public void .ctor(Code code16, Code code32, Code code64)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_Rv_32_64 : OpCodeHandlerModRM {
private Code code32
private Code code64
public void .ctor(Code code32, Code code64)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_RvMw_Gw : OpCodeHandlerModRM {
private Code code16
private Code code32
public void .ctor(Code code16, Code code32)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_Simple : OpCodeHandler {
private Code code
public void .ctor(Code code)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_Simple_ModRM : OpCodeHandlerModRM {
private Code code
public void .ctor(Code code)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_Simple2 : OpCodeHandler {
private Code3 codes
public void .ctor(Code code16, Code code32, Code code64)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_Simple2Iw : OpCodeHandler {
private Code3 codes
public void .ctor(Code code16, Code code32, Code code64)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_Simple3 : OpCodeHandler {
private Code code16
private Code code32
private Code code64
public void .ctor(Code code16, Code code32, Code code64)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_Simple4 : OpCodeHandler {
private Code code32
private Code code64
public void .ctor(Code code32, Code code64)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_Simple5 : OpCodeHandler {
private Code3 codes
public void .ctor(Code code16, Code code32, Code code64)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_Simple5_a32 : OpCodeHandler {
private Code3 codes
public void .ctor(Code code16, Code code32, Code code64)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_Simple5_ModRM_as : OpCodeHandlerModRM {
private Code3 codes
public void .ctor(Code code16, Code code32, Code code64)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_SimpleReg : OpCodeHandler {
private Code code
private int index
public void .ctor(Code code, int index)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_ST_STi : OpCodeHandlerModRM {
private Code code
public void .ctor(Code code)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_STi : OpCodeHandlerModRM {
private Code code
public void .ctor(Code code)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_STi_ST : OpCodeHandlerModRM {
private Code code
public void .ctor(Code code)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_Sw_Ev : OpCodeHandlerModRM {
private Code3 codes
public void .ctor(Code code16, Code code32, Code code64)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_Sw_M : OpCodeHandlerModRM {
private Code code
public void .ctor(Code code)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_V_Ev : OpCodeHandlerModRM {
private Code codeW0
private Code codeW1
public void .ctor(Code codeW0, Code codeW1)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_VectorLength_EVEX : OpCodeHandlerModRM {
private OpCodeHandler[] handlers
public void .ctor(OpCodeHandler handler128, OpCodeHandler handler256, OpCodeHandler handler512)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_VectorLength_EVEX_er : OpCodeHandlerModRM {
private OpCodeHandler[] handlers
public void .ctor(OpCodeHandler handler128, OpCodeHandler handler256, OpCodeHandler handler512)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_VectorLength_NoModRM_VEX : OpCodeHandler {
private OpCodeHandler[] handlers
public void .ctor(OpCodeHandler handler128, OpCodeHandler handler256)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_VectorLength_VEX : OpCodeHandlerModRM {
private OpCodeHandler[] handlers
public void .ctor(OpCodeHandler handler128, OpCodeHandler handler256)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_VEX_Ed_V_Ib : OpCodeHandlerModRM {
private Register baseReg
private Code code32
private Code code64
public void .ctor(Register baseReg, Code code32, Code code64)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_VEX_Ev : OpCodeHandlerModRM {
private Code code32
private Code code64
public void .ctor(Code code32, Code code64)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_VEX_Ev_VX : OpCodeHandlerModRM {
private Code code32
private Code code64
public void .ctor(Code code32, Code code64)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_VEX_G_VK : OpCodeHandlerModRM {
private Code code
private Register gpr
public void .ctor(Code code, Register gpr)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_VEX_Gq_HK_RK : OpCodeHandlerModRM {
private Code code
public void .ctor(Code code)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_VEX_Gv_Ev : OpCodeHandlerModRM {
private Code code32
private Code code64
public void .ctor(Code code32, Code code64)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_VEX_Gv_Ev_Gv : OpCodeHandlerModRM {
private Code code32
private Code code64
public void .ctor(Code code32, Code code64)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_VEX_Gv_Ev_Ib : OpCodeHandlerModRM {
private Code code32
private Code code64
public void .ctor(Code code32, Code code64)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_VEX_Gv_Ev_Id : OpCodeHandlerModRM {
private Code code32
private Code code64
public void .ctor(Code code32, Code code64)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_VEX_Gv_GPR_Ib : OpCodeHandlerModRM {
private Register baseReg
private Code code32
private Code code64
public void .ctor(Register baseReg, Code code32, Code code64)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_VEX_Gv_Gv_Ev : OpCodeHandlerModRM {
private Code code32
private Code code64
public void .ctor(Code code32, Code code64)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_VEX_Gv_RX : OpCodeHandlerModRM {
private Register baseReg
private Code code32
private Code code64
public void .ctor(Register baseReg, Code code32, Code code64)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_VEX_Gv_W : OpCodeHandlerModRM {
private Register baseReg
private Code codeW0
private Code codeW1
public void .ctor(Register baseReg, Code codeW0, Code codeW1)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_VEX_GvM_VX_Ib : OpCodeHandlerModRM {
private Register baseReg
private Code code32
private Code code64
public void .ctor(Register baseReg, Code code32, Code code64)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_VEX_HRIb : OpCodeHandlerModRM {
private Register baseReg
private Code code
public void .ctor(Register baseReg, Code code)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_VEX_Hv_Ed_Id : OpCodeHandlerModRM {
private Code code32
private Code code64
public void .ctor(Code code32, Code code64)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_VEX_Hv_Ev : OpCodeHandlerModRM {
private Code code32
private Code code64
public void .ctor(Code code32, Code code64)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_VEX_K_Jb : OpCodeHandlerModRM {
private Code code
public void .ctor(Code code)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_VEX_K_Jz : OpCodeHandlerModRM {
private Code code
public void .ctor(Code code)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_VEX_M : OpCodeHandlerModRM {
private Code code
public void .ctor(Code code)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_VEX_M_VK : OpCodeHandlerModRM {
private Code code
public void .ctor(Code code)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_VEX_MHV : OpCodeHandlerModRM {
private Register baseReg
private Code code
public void .ctor(Register baseReg, Code code)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_VEX_MV : OpCodeHandlerModRM {
private Register baseReg
private Code code
public void .ctor(Register baseReg, Code code)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_VEX_rDI_VX_RX : OpCodeHandlerModRM {
private Register baseReg
private Code code
public void .ctor(Register baseReg, Code code)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_VEX_RdRq : OpCodeHandlerModRM {
private Code code32
private Code code64
public void .ctor(Code code32, Code code64)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_VEX_SIBMEM_VT : OpCodeHandlerModRM {
private Code code
public void .ctor(Code code)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_VEX_Simple : OpCodeHandler {
private Code code
public void .ctor(Code code)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_VEX_VHEv : OpCodeHandlerModRM {
private Register baseReg
private Code codeW0
private Code codeW1
public void .ctor(Register baseReg, Code codeW0, Code codeW1)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_VEX_VHEvIb : OpCodeHandlerModRM {
private Register baseReg
private Code codeW0
private Code codeW1
public void .ctor(Register baseReg, Code codeW0, Code codeW1)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_VEX_VHIs4W : OpCodeHandlerModRM {
private Register baseReg
private Code code
public void .ctor(Register baseReg, Code code)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_VEX_VHIs5W : OpCodeHandlerModRM {
private Register baseReg
private Code code
public void .ctor(Register baseReg, Code code)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_VEX_VHM : OpCodeHandlerModRM {
private Register baseReg
private Code code
public void .ctor(Register baseReg, Code code)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_VEX_VHW : OpCodeHandlerModRM {
private Register baseReg1
private Register baseReg2
private Register baseReg3
private Code codeR
private Code codeM
public void .ctor(Register baseReg, Code codeR, Code codeM)
public void .ctor(Register baseReg, Code code)
public void .ctor(Register baseReg1, Register baseReg2, Register baseReg3, Code code)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_VEX_VHWIb : OpCodeHandlerModRM {
private Register baseReg1
private Register baseReg2
private Register baseReg3
private Code code
public void .ctor(Register baseReg, Code code)
public void .ctor(Register baseReg1, Register baseReg2, Register baseReg3, Code code)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_VEX_VHWIs4 : OpCodeHandlerModRM {
private Register baseReg
private Code code
public void .ctor(Register baseReg, Code code)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_VEX_VHWIs5 : OpCodeHandlerModRM {
private Register baseReg
private Code code
public void .ctor(Register baseReg, Code code)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_VEX_VK_HK_RK : OpCodeHandlerModRM {
private Code code
public void .ctor(Code code)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_VEX_VK_R : OpCodeHandlerModRM {
private Code code
private Register gpr
public void .ctor(Code code, Register gpr)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_VEX_VK_R_Ib : OpCodeHandlerModRM {
private Code code
private Register gpr
public void .ctor(Code code, Register gpr)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_VEX_VK_RK : OpCodeHandlerModRM {
private Code code
public void .ctor(Code code)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_VEX_VK_RK_Ib : OpCodeHandlerModRM {
private Code code
public void .ctor(Code code)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_VEX_VK_WK : OpCodeHandlerModRM {
private Code code
public void .ctor(Code code)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_VEX_VM : OpCodeHandlerModRM {
private Register baseReg
private Code code
public void .ctor(Register baseReg, Code code)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_VEX_VT : OpCodeHandlerModRM {
private Code code
public void .ctor(Code code)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_VEX_VT_RT_HT : OpCodeHandlerModRM {
private Code code
public void .ctor(Code code)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_VEX_VT_SIBMEM : OpCodeHandlerModRM {
private Code code
public void .ctor(Code code)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_VEX_VW : OpCodeHandlerModRM {
private Register baseReg1
private Register baseReg2
private Code code
public void .ctor(Register baseReg, Code code)
public void .ctor(Register baseReg1, Register baseReg2, Code code)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_VEX_VWH : OpCodeHandlerModRM {
private Register baseReg
private Code code
public void .ctor(Register baseReg, Code code)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_VEX_VWIb : OpCodeHandlerModRM {
private Register baseReg1
private Register baseReg2
private Code codeW0
private Code codeW1
public void .ctor(Register baseReg, Code code)
public void .ctor(Register baseReg, Code codeW0, Code codeW1)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_VEX_VX_Ev : OpCodeHandlerModRM {
private Code code32
private Code code64
public void .ctor(Code code32, Code code64)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_VEX_VX_VSIB_HX : OpCodeHandlerModRM {
private Register baseReg1
private Register vsibIndex
private Register baseReg3
private Code code
public void .ctor(Register baseReg1, Register vsibIndex, Register baseReg3, Code code)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_VEX_WHV : OpCodeHandlerModRM {
private Register baseReg
private Code codeR
public void .ctor(Register baseReg, Code code)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_VEX_WV : OpCodeHandlerModRM {
private Register baseReg1
private Register baseReg2
private Code code
public void .ctor(Register baseReg, Code code)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_VEX_WVIb : OpCodeHandlerModRM {
private Register baseReg1
private Register baseReg2
private Code code
public void .ctor(Register baseReg1, Register baseReg2, Code code)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_VEX2 : OpCodeHandlerModRM {
private OpCodeHandler handlerMem
public void .ctor(OpCodeHandler handlerMem)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_VEX3 : OpCodeHandlerModRM {
private OpCodeHandler handlerMem
public void .ctor(OpCodeHandler handlerMem)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_VM : OpCodeHandlerModRM {
private Code code
public void .ctor(Code code)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_VN : OpCodeHandlerModRM {
private Code code
public void .ctor(Code code)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_VQ : OpCodeHandlerModRM {
private Code code
public void .ctor(Code code)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_VRIbIb : OpCodeHandlerModRM {
private Code code
public void .ctor(Code code)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_VW : OpCodeHandlerModRM {
private Code codeR
private Code codeM
public void .ctor(Code codeR, Code codeM)
public void .ctor(Code code)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_VWIb : OpCodeHandlerModRM {
private Code codeW0
private Code codeW1
public void .ctor(Code code)
public void .ctor(Code codeW0, Code codeW1)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_VX_E_Ib : OpCodeHandlerModRM {
private Code code32
private Code code64
public void .ctor(Code code32, Code code64)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_VX_Ev : OpCodeHandlerModRM {
private Code code32
private Code code64
public void .ctor(Code code32, Code code64)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_W : OpCodeHandlerModRM {
private OpCodeHandler handlerW0
private OpCodeHandler handlerW1
public void .ctor(OpCodeHandler handlerW0, OpCodeHandler handlerW1)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_Wbinvd : OpCodeHandler {
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_WV : OpCodeHandlerModRM {
private Code code
public void .ctor(Code code)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_Xb_Yb : OpCodeHandler {
private Code code
public void .ctor(Code code)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_Xchg_Reg_rAX : OpCodeHandler {
private int index
private Code[] codes
private Code[] s_codes
public void .ctor(int index)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_XOP : OpCodeHandlerModRM {
private OpCodeHandler handler_reg0
public void .ctor(OpCodeHandler handler_reg0)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_Xv_Yv : OpCodeHandler {
private Code3 codes
public void .ctor(Code code16, Code code32, Code code64)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_Yb_Reg : OpCodeHandler {
private Code code
private Register reg
public void .ctor(Code code, Register reg)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_Yb_Xb : OpCodeHandler {
private Code code
public void .ctor(Code code)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_Yv_Reg : OpCodeHandler {
private Code3 codes
public void .ctor(Code code16, Code code32, Code code64)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_Yv_Reg2 : OpCodeHandler {
private Code code16
private Code code32
public void .ctor(Code code16, Code code32)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandler_Yv_Xv : OpCodeHandler {
private Code3 codes
public void .ctor(Code code16, Code code32, Code code64)
public void Decode(Decoder decoder, Instruction& instruction)
}
internal Iced.Intel.DecoderInternal.OpCodeHandlerReader : object {
public int ReadHandlers(TableDeserializer& deserializer, OpCodeHandler[] result, int resultIndex)
}
internal Iced.Intel.DecoderInternal.OpCodeHandlersTables_EVEX : object {
internal OpCodeHandler[] Handlers_0F
internal OpCodeHandler[] Handlers_0F38
internal OpCodeHandler[] Handlers_0F3A
internal OpCodeHandler[] Handlers_MAP5
internal OpCodeHandler[] Handlers_MAP6
private int MaxIdNames
private UInt32 Handlers_0FIndex
private UInt32 Handlers_0F38Index
private UInt32 Handlers_0F3AIndex
private UInt32 Handlers_MAP5Index
private UInt32 Handlers_MAP6Index
private ReadOnlySpan`1<byte> GetSerializedTables()
}
internal Iced.Intel.DecoderInternal.OpCodeHandlersTables_Legacy : object {
internal OpCodeHandler[] Handlers_MAP0
private int MaxIdNames
private UInt32 Handlers_MAP0Index
private ReadOnlySpan`1<byte> GetSerializedTables()
}
internal Iced.Intel.DecoderInternal.OpCodeHandlersTables_VEX : object {
internal OpCodeHandler[] Handlers_0F
internal OpCodeHandler[] Handlers_0F38
internal OpCodeHandler[] Handlers_0F3A
private int MaxIdNames
private UInt32 Handlers_MAP0Index
private UInt32 Handlers_0FIndex
private UInt32 Handlers_0F38Index
private UInt32 Handlers_0F3AIndex
private ReadOnlySpan`1<byte> GetSerializedTables()
}
internal Iced.Intel.DecoderInternal.OpCodeHandlersTables_XOP : object {
internal OpCodeHandler[] Handlers_MAP8
internal OpCodeHandler[] Handlers_MAP9
internal OpCodeHandler[] Handlers_MAP10
private int MaxIdNames
private UInt32 Handlers_MAP8Index
private UInt32 Handlers_MAP9Index
private UInt32 Handlers_MAP10Index
private ReadOnlySpan`1<byte> GetSerializedTables()
}
internal Iced.Intel.DecoderInternal.SerializedDataKind : Enum {
public byte value__
public SerializedDataKind HandlerReference
public SerializedDataKind ArrayReference
}
internal Iced.Intel.DecoderInternal.TableDeserializer : ValueType {
private DataReader reader
private OpCodeHandlerReader handlerReader
private List`1<HandlerInfo> idToHandler
private OpCodeHandler[] handlerArray
public void .ctor(OpCodeHandlerReader handlerReader, int maxIds, ReadOnlySpan`1<byte> data)
public void Deserialize()
public LegacyOpCodeHandlerKind ReadLegacyOpCodeHandlerKind()
public VexOpCodeHandlerKind ReadVexOpCodeHandlerKind()
public EvexOpCodeHandlerKind ReadEvexOpCodeHandlerKind()
public Code ReadCode()
public Register ReadRegister()
public DecoderOptions ReadDecoderOptions()
public HandlerFlags ReadHandlerFlags()
public LegacyHandlerFlags ReadLegacyHandlerFlags()
public TupleType ReadTupleType()
public bool ReadBoolean()
public int ReadInt32()
public OpCodeHandler ReadHandler()
public OpCodeHandler ReadHandlerOrNull()
public OpCodeHandler[] ReadHandlers(int count)
public OpCodeHandler ReadHandlerReference()
public OpCodeHandler[] ReadArrayReference(UInt32 kind)
public OpCodeHandler[] GetTable(UInt32 index)
}
internal Iced.Intel.DecoderInternal.VexOpCodeHandlerKind : Enum {
public byte value__
public VexOpCodeHandlerKind Invalid
public VexOpCodeHandlerKind Invalid2
public VexOpCodeHandlerKind Dup
public VexOpCodeHandlerKind Invalid_NoModRM
public VexOpCodeHandlerKind Bitness_DontReadModRM
public VexOpCodeHandlerKind HandlerReference
public VexOpCodeHandlerKind ArrayReference
public VexOpCodeHandlerKind RM
public VexOpCodeHandlerKind Group
public VexOpCodeHandlerKind W
public VexOpCodeHandlerKind MandatoryPrefix2_1
public VexOpCodeHandlerKind MandatoryPrefix2_4
public VexOpCodeHandlerKind MandatoryPrefix2_NoModRM
public VexOpCodeHandlerKind VectorLength_NoModRM
public VexOpCodeHandlerKind VectorLength
public VexOpCodeHandlerKind Ed_V_Ib
public VexOpCodeHandlerKind Ev_VX
public VexOpCodeHandlerKind G_VK
public VexOpCodeHandlerKind Gv_Ev_Gv
public VexOpCodeHandlerKind Gv_Ev_Ib
public VexOpCodeHandlerKind Gv_Ev_Id
public VexOpCodeHandlerKind Gv_GPR_Ib
public VexOpCodeHandlerKind Gv_Gv_Ev
public VexOpCodeHandlerKind Gv_RX
public VexOpCodeHandlerKind Gv_W
public VexOpCodeHandlerKind GvM_VX_Ib
public VexOpCodeHandlerKind HRIb
public VexOpCodeHandlerKind Hv_Ed_Id
public VexOpCodeHandlerKind Hv_Ev
public VexOpCodeHandlerKind M
public VexOpCodeHandlerKind MHV
public VexOpCodeHandlerKind M_VK
public VexOpCodeHandlerKind MV
public VexOpCodeHandlerKind rDI_VX_RX
public VexOpCodeHandlerKind RdRq
public VexOpCodeHandlerKind Simple
public VexOpCodeHandlerKind VHEv
public VexOpCodeHandlerKind VHEvIb
public VexOpCodeHandlerKind VHIs4W
public VexOpCodeHandlerKind VHIs5W
public VexOpCodeHandlerKind VHM
public VexOpCodeHandlerKind VHW_2
public VexOpCodeHandlerKind VHW_3
public VexOpCodeHandlerKind VHW_4
public VexOpCodeHandlerKind VHWIb_2
public VexOpCodeHandlerKind VHWIb_4
public VexOpCodeHandlerKind VHWIs4
public VexOpCodeHandlerKind VHWIs5
public VexOpCodeHandlerKind VK_HK_RK
public VexOpCodeHandlerKind VK_R
public VexOpCodeHandlerKind VK_RK
public VexOpCodeHandlerKind VK_RK_Ib
public VexOpCodeHandlerKind VK_WK
public VexOpCodeHandlerKind VM
public VexOpCodeHandlerKind VW_2
public VexOpCodeHandlerKind VW_3
public VexOpCodeHandlerKind VWH
public VexOpCodeHandlerKind VWIb_2
public VexOpCodeHandlerKind VWIb_3
public VexOpCodeHandlerKind VX_Ev
public VexOpCodeHandlerKind VX_VSIB_HX
public VexOpCodeHandlerKind WHV
public VexOpCodeHandlerKind WV
public VexOpCodeHandlerKind WVIb
public VexOpCodeHandlerKind VT_SIBMEM
public VexOpCodeHandlerKind SIBMEM_VT
public VexOpCodeHandlerKind VT
public VexOpCodeHandlerKind VT_RT_HT
public VexOpCodeHandlerKind Group8x64
public VexOpCodeHandlerKind Bitness
public VexOpCodeHandlerKind Null
public VexOpCodeHandlerKind Options_DontReadModRM
public VexOpCodeHandlerKind Gq_HK_RK
public VexOpCodeHandlerKind VK_R_Ib
public VexOpCodeHandlerKind Gv_Ev
public VexOpCodeHandlerKind Ev
public VexOpCodeHandlerKind K_Jb
public VexOpCodeHandlerKind K_Jz
}
internal Iced.Intel.DecoderInternal.VexOpCodeHandlerReader : OpCodeHandlerReader {
public int ReadHandlers(TableDeserializer& deserializer, OpCodeHandler[] result, int resultIndex)
}
internal Iced.Intel.DecoderOptions : Enum {
public UInt32 value__
public DecoderOptions None
public DecoderOptions NoInvalidCheck
public DecoderOptions AMD
public DecoderOptions ForceReservedNop
public DecoderOptions Umov
public DecoderOptions Xbts
public DecoderOptions Cmpxchg486A
public DecoderOptions OldFpu
public DecoderOptions Pcommit
public DecoderOptions Loadall286
public DecoderOptions Loadall386
public DecoderOptions Cl1invmb
public DecoderOptions MovTr
public DecoderOptions Jmpe
public DecoderOptions NoPause
public DecoderOptions NoWbnoinvd
public DecoderOptions Udbg
public DecoderOptions NoMPFX_0FBC
public DecoderOptions NoMPFX_0FBD
public DecoderOptions NoLahfSahf64
public DecoderOptions MPX
public DecoderOptions Cyrix
public DecoderOptions Cyrix_SMINT_0F7E
public DecoderOptions Cyrix_DMI
public DecoderOptions ALTINST
public DecoderOptions KNC
}
internal Iced.Intel.Encoder : object {
private UInt32[] s_immSizes
internal UInt32 Internal_PreventVEX2
internal UInt32 Internal_VEX_WIG_LIG
internal UInt32 Internal_VEX_LIG
internal UInt32 Internal_EVEX_WIG
internal UInt32 Internal_EVEX_LIG
internal string ERROR_ONLY_1632_BIT_MODE
internal string ERROR_ONLY_64_BIT_MODE
private CodeWriter writer
private int bitness
private OpCodeHandler[] handlers
private UInt32[] immSizes
private ulong currentRip
private string errorMessage
private OpCodeHandler handler
private UInt32 eip
private UInt32 displAddr
private UInt32 immAddr
internal UInt32 Immediate
internal UInt32 ImmediateHi
private UInt32 Displ
private UInt32 DisplHi
private EncoderFlags opSize16Flags
private EncoderFlags opSize32Flags
private EncoderFlags adrSize16Flags
private EncoderFlags adrSize32Flags
internal UInt32 OpCode
internal EncoderFlags EncoderFlags
private DisplSize DisplSize
internal ImmSize ImmSize
private byte ModRM
private byte Sib
public bool PreventVEX2
public UInt32 VEX_WIG
public UInt32 VEX_LIG
public UInt32 EVEX_WIG
public UInt32 EVEX_LIG
public int Bitness
internal string ErrorMessage
private ReadOnlySpan`1<byte> SegmentOverrides
public bool get_PreventVEX2()
public void set_PreventVEX2(bool value)
public UInt32 get_VEX_WIG()
public void set_VEX_WIG(UInt32 value)
public UInt32 get_VEX_LIG()
public void set_VEX_LIG(UInt32 value)
public UInt32 get_EVEX_WIG()
public void set_EVEX_WIG(UInt32 value)
public UInt32 get_EVEX_LIG()
public void set_EVEX_LIG(UInt32 value)
public int get_Bitness()
private void .ctor(CodeWriter writer, int bitness)
public Encoder Create(int bitness, CodeWriter writer)
public UInt32 Encode(Instruction& instruction, ulong rip)
private void ThrowEncoderException(Instruction& instruction, string errorMessage)
public bool TryEncode(Instruction& instruction, ulong rip, UInt32& encodedLength, String& errorMessage)
internal void set_ErrorMessage(string value)
internal bool Verify(int operand, OpKind expected, OpKind actual)
internal bool Verify(int operand, Register expected, Register actual)
internal bool Verify(int operand, Register register, Register regLo, Register regHi)
internal void AddBranch(OpKind opKind, int immSize, Instruction& instruction, int operand)
internal void AddBranchX(int immSize, Instruction& instruction, int operand)
internal void AddBranchDisp(int displSize, Instruction& instruction, int operand)
internal void AddFarBranch(Instruction& instruction, int operand, int size)
internal void SetAddrSize(int regSize)
internal void AddAbsMem(Instruction& instruction, int operand)
internal void AddModRMRegister(Instruction& instruction, int operand, Register regLo, Register regHi)
internal void AddReg(Instruction& instruction, int operand, Register regLo, Register regHi)
internal void AddRegOrMem(Instruction& instruction, int operand, Register regLo, Register regHi, bool allowMemOp, bool allowRegOp)
internal void AddRegOrMem(Instruction& instruction, int operand, Register regLo, Register regHi, Register vsibIndexRegLo, Register vsibIndexRegHi, bool allowMemOp, bool allowRegOp)
private int GetRegisterOpSize(Instruction& instruction)
private bool TryConvertToDisp8N(Instruction& instruction, int displ, SByte& compressedValue)
private void AddMemOp16(Instruction& instruction, int operand)
private void AddMemOp(Instruction& instruction, int operand, int addrSize, Register vsibIndexRegLo, Register vsibIndexRegHi)
private ReadOnlySpan`1<byte> get_SegmentOverrides()
internal void WritePrefixes(Instruction& instruction, bool canWriteF3)
private void WriteModRM()
private void WriteImmediate()
public void WriteByte(byte value)
internal void WriteByteInternal(UInt32 value)
public ConstantOffsets GetConstantOffsets()
}
internal Iced.Intel.EncoderException : Exception {
private Instruction <Instruction>k__BackingField
public Instruction Instruction
public Instruction get_Instruction()
public void .ctor(string message, Instruction& instruction)
protected void .ctor(SerializationInfo info, StreamingContext context)
}
internal Iced.Intel.EncoderInternal.D3nowHandler : OpCodeHandler {
private Op[] operands
private UInt32 immediate
public void .ctor(EncFlags2 encFlags2, EncFlags3 encFlags3)
public void Encode(Encoder encoder, Instruction& modreq(System.Runtime.InteropServices.InAttribute) instruction)
}
internal Iced.Intel.EncoderInternal.DeclareDataHandler : OpCodeHandler {
private int elemLength
private int maxLength
public void .ctor(Code code)
public void Encode(Encoder encoder, Instruction& modreq(System.Runtime.InteropServices.InAttribute) instruction)
}
internal Iced.Intel.EncoderInternal.DisplSize : Enum {
public int value__
public DisplSize None
public DisplSize Size1
public DisplSize Size2
public DisplSize Size4
public DisplSize Size8
public DisplSize RipRelSize4_Target32
public DisplSize RipRelSize4_Target64
}
internal Iced.Intel.EncoderInternal.EncFlags1 : Enum {
public UInt32 value__
public EncFlags1 None
public EncFlags1 Legacy_OpMask
public EncFlags1 Legacy_Op0Shift
public EncFlags1 Legacy_Op1Shift
public EncFlags1 Legacy_Op2Shift
public EncFlags1 Legacy_Op3Shift
public EncFlags1 VEX_OpMask
public EncFlags1 VEX_Op0Shift
public EncFlags1 VEX_Op1Shift
public EncFlags1 VEX_Op2Shift
public EncFlags1 VEX_Op3Shift
public EncFlags1 VEX_Op4Shift
public EncFlags1 XOP_OpMask
public EncFlags1 XOP_Op0Shift
public EncFlags1 XOP_Op1Shift
public EncFlags1 XOP_Op2Shift
public EncFlags1 XOP_Op3Shift
public EncFlags1 EVEX_OpMask
public EncFlags1 EVEX_Op0Shift
public EncFlags1 EVEX_Op1Shift
public EncFlags1 EVEX_Op2Shift
public EncFlags1 EVEX_Op3Shift
public EncFlags1 MVEX_OpMask
public EncFlags1 MVEX_Op0Shift
public EncFlags1 MVEX_Op1Shift
public EncFlags1 MVEX_Op2Shift
public EncFlags1 MVEX_Op3Shift
public EncFlags1 IgnoresRoundingControl
public EncFlags1 AmdLockRegBit
}
internal Iced.Intel.EncoderInternal.EncFlags2 : Enum {
public UInt32 value__
public EncFlags2 None
public EncFlags2 OpCodeShift
public EncFlags2 OpCodeIs2Bytes
public EncFlags2 TableShift
public EncFlags2 TableMask
public EncFlags2 MandatoryPrefixShift
public EncFlags2 MandatoryPrefixMask
public EncFlags2 WBitShift
public EncFlags2 WBitMask
public EncFlags2 LBitShift
public EncFlags2 LBitMask
public EncFlags2 GroupIndexShift
public EncFlags2 GroupIndexMask
public EncFlags2 HasMandatoryPrefix
public EncFlags2 HasGroupIndex
}
internal Iced.Intel.EncoderInternal.EncFlags3 : Enum {
public UInt32 value__
public EncFlags3 None
public EncFlags3 EncodingShift
public EncFlags3 EncodingMask
public EncFlags3 OperandSizeShift
public EncFlags3 OperandSizeMask
public EncFlags3 AddressSizeShift
public EncFlags3 AddressSizeMask
public EncFlags3 TupleTypeShift
public EncFlags3 TupleTypeMask
public EncFlags3 DefaultOpSize64
public EncFlags3 HasRmGroupIndex
public EncFlags3 IntelForceOpSize64
public EncFlags3 Fwait
public EncFlags3 Bit16or32
public EncFlags3 Bit64
public EncFlags3 Lock
public EncFlags3 Xacquire
public EncFlags3 Xrelease
public EncFlags3 Rep
public EncFlags3 Repne
public EncFlags3 Bnd
public EncFlags3 HintTaken
public EncFlags3 Notrack
public EncFlags3 Broadcast
public EncFlags3 RoundingControl
public EncFlags3 SuppressAllExceptions
public EncFlags3 OpMaskRegister
public EncFlags3 ZeroingMasking
public EncFlags3 RequireOpMaskRegister
}
internal Iced.Intel.EncoderInternal.EncoderData : object {
internal UInt32[] EncFlags1
internal UInt32[] EncFlags2
internal UInt32[] EncFlags3
private UInt32[] GetEncFlags1()
private UInt32[] GetEncFlags2()
private UInt32[] GetEncFlags3()
}
internal Iced.Intel.EncoderInternal.EncoderFlags : Enum {
public UInt32 value__
public EncoderFlags None
public EncoderFlags B
public EncoderFlags X
public EncoderFlags R
public EncoderFlags W
public EncoderFlags ModRM
public EncoderFlags Sib
public EncoderFlags REX
public EncoderFlags P66
public EncoderFlags P67
public EncoderFlags R2
public EncoderFlags Broadcast
public EncoderFlags HighLegacy8BitRegs
public EncoderFlags Displ
public EncoderFlags PF0
public EncoderFlags RegIsMemory
public EncoderFlags MustUseSib
public EncoderFlags VvvvvShift
public EncoderFlags VvvvvMask
}
internal Iced.Intel.EncoderInternal.EvexHandler : OpCodeHandler {
private WBit wbit
private TupleType tupleType
private UInt32 table
private UInt32 p1Bits
private UInt32 llBits
private UInt32 mask_W
private UInt32 mask_LL
private TryConvertToDisp8N tryConvertToDisp8N
private Op[] CreateOps(EncFlags1 encFlags1)
public void .ctor(EncFlags1 encFlags1, EncFlags2 encFlags2, EncFlags3 encFlags3)
public void Encode(Encoder encoder, Instruction& modreq(System.Runtime.InteropServices.InAttribute) instruction)
}
internal Iced.Intel.EncoderInternal.EvexOpCodeTable : Enum {
public int value__
public EvexOpCodeTable MAP0F
public EvexOpCodeTable MAP0F38
public EvexOpCodeTable MAP0F3A
public EvexOpCodeTable MAP5
public EvexOpCodeTable MAP6
}
internal Iced.Intel.EncoderInternal.ImmSize : Enum {
public int value__
public ImmSize None
public ImmSize Size1
public ImmSize Size2
public ImmSize Size4
public ImmSize Size8
public ImmSize Size2_1
public ImmSize Size1_1
public ImmSize Size2_2
public ImmSize Size4_2
public ImmSize RipRelSize1_Target16
public ImmSize RipRelSize1_Target32
public ImmSize RipRelSize1_Target64
public ImmSize RipRelSize2_Target16
public ImmSize RipRelSize2_Target32
public ImmSize RipRelSize2_Target64
public ImmSize RipRelSize4_Target32
public ImmSize RipRelSize4_Target64
public ImmSize SizeIbReg
public ImmSize Size1OpCode
}
internal Iced.Intel.EncoderInternal.InvalidHandler : OpCodeHandler {
internal string ERROR_MESSAGE
public void Encode(Encoder encoder, Instruction& modreq(System.Runtime.InteropServices.InAttribute) instruction)
}
internal Iced.Intel.EncoderInternal.LBit : Enum {
public UInt32 value__
public LBit L0
public LBit L1
public LBit LIG
public LBit LZ
public LBit L128
public LBit L256
public LBit L512
}
internal Iced.Intel.EncoderInternal.LegacyHandler : OpCodeHandler {
private UInt32 tableByte1
private UInt32 tableByte2
private UInt32 mandatoryPrefix
private Op[] CreateOps(EncFlags1 encFlags1)
public void .ctor(EncFlags1 encFlags1, EncFlags2 encFlags2, EncFlags3 encFlags3)
public void Encode(Encoder encoder, Instruction& modreq(System.Runtime.InteropServices.InAttribute) instruction)
}
internal Iced.Intel.EncoderInternal.LegacyOpCodeTable : Enum {
public int value__
public LegacyOpCodeTable MAP0
public LegacyOpCodeTable MAP0F
public LegacyOpCodeTable MAP0F38
public LegacyOpCodeTable MAP0F3A
}
internal Iced.Intel.EncoderInternal.MvexOpCodeTable : Enum {
public int value__
public MvexOpCodeTable MAP0F
public MvexOpCodeTable MAP0F38
public MvexOpCodeTable MAP0F3A
}
internal Iced.Intel.EncoderInternal.Op : object {
public void Encode(Encoder encoder, Instruction& modreq(System.Runtime.InteropServices.InAttribute) instruction, int operand)
public OpKind GetImmediateOpKind()
public OpKind GetNearBranchOpKind()
public OpKind GetFarBranchOpKind()
}
internal Iced.Intel.EncoderInternal.OpA : Op {
private int size
public void .ctor(int size)
public void Encode(Encoder encoder, Instruction& modreq(System.Runtime.InteropServices.InAttribute) instruction, int operand)
public OpKind GetFarBranchOpKind()
}
internal Iced.Intel.EncoderInternal.OpCodeHandler : object {
internal UInt32 OpCode
internal bool Is2ByteOpCode
internal int GroupIndex
internal int RmGroupIndex
internal bool IsSpecialInstr
internal EncFlags3 EncFlags3
internal CodeSize OpSize
internal CodeSize AddrSize
internal TryConvertToDisp8N TryConvertToDisp8N
internal Op[] Operands
protected void .ctor(EncFlags2 encFlags2, EncFlags3 encFlags3, bool isSpecialInstr, TryConvertToDisp8N tryConvertToDisp8N, Op[] operands)
protected UInt32 GetOpCode(EncFlags2 encFlags2)
public void Encode(Encoder encoder, Instruction& modreq(System.Runtime.InteropServices.InAttribute) instruction)
}
internal Iced.Intel.EncoderInternal.OpCodeHandlers : object {
public OpCodeHandler[] Handlers
}
internal Iced.Intel.EncoderInternal.OpHandlerData : object {
public Op[] LegacyOps
public Op[] VexOps
public Op[] XopOps
public Op[] EvexOps
}
internal Iced.Intel.EncoderInternal.OpHx : Op {
private Register regLo
private Register regHi
public void .ctor(Register regLo, Register regHi)
public void Encode(Encoder encoder, Instruction& modreq(System.Runtime.InteropServices.InAttribute) instruction, int operand)
}
internal Iced.Intel.EncoderInternal.OpI4 : Op {
public void Encode(Encoder encoder, Instruction& modreq(System.Runtime.InteropServices.InAttribute) instruction, int operand)
public OpKind GetImmediateOpKind()
}
internal Iced.Intel.EncoderInternal.OpIb : Op {
private OpKind opKind
public void .ctor(OpKind opKind)
public void Encode(Encoder encoder, Instruction& modreq(System.Runtime.InteropServices.InAttribute) instruction, int operand)
public OpKind GetImmediateOpKind()
}
internal Iced.Intel.EncoderInternal.OpId : Op {
private OpKind opKind
public void .ctor(OpKind opKind)
public void Encode(Encoder encoder, Instruction& modreq(System.Runtime.InteropServices.InAttribute) instruction, int operand)
public OpKind GetImmediateOpKind()
}
internal Iced.Intel.EncoderInternal.OpImm : Op {
private byte value
public void .ctor(byte value)
public void Encode(Encoder encoder, Instruction& modreq(System.Runtime.InteropServices.InAttribute) instruction, int operand)
public OpKind GetImmediateOpKind()
}
internal Iced.Intel.EncoderInternal.OpIq : Op {
public void Encode(Encoder encoder, Instruction& modreq(System.Runtime.InteropServices.InAttribute) instruction, int operand)
public OpKind GetImmediateOpKind()
}
internal Iced.Intel.EncoderInternal.OpIsX : Op {
private Register regLo
private Register regHi
public void .ctor(Register regLo, Register regHi)
public void Encode(Encoder encoder, Instruction& modreq(System.Runtime.InteropServices.InAttribute) instruction, int operand)
}
internal Iced.Intel.EncoderInternal.OpIw : Op {
public void Encode(Encoder encoder, Instruction& modreq(System.Runtime.InteropServices.InAttribute) instruction, int operand)
public OpKind GetImmediateOpKind()
}
internal Iced.Intel.EncoderInternal.OpJ : Op {
private OpKind opKind
private int immSize
public void .ctor(OpKind opKind, int immSize)
public void Encode(Encoder encoder, Instruction& modreq(System.Runtime.InteropServices.InAttribute) instruction, int operand)
public OpKind GetNearBranchOpKind()
}
internal Iced.Intel.EncoderInternal.OpJdisp : Op {
private int displSize
public void .ctor(int displSize)
public void Encode(Encoder encoder, Instruction& modreq(System.Runtime.InteropServices.InAttribute) instruction, int operand)
public OpKind GetNearBranchOpKind()
}
internal Iced.Intel.EncoderInternal.OpJx : Op {
private int immSize
public void .ctor(int immSize)
public void Encode(Encoder encoder, Instruction& modreq(System.Runtime.InteropServices.InAttribute) instruction, int operand)
public OpKind GetNearBranchOpKind()
}
internal Iced.Intel.EncoderInternal.OpModRM_reg : Op {
private Register regLo
private Register regHi
public void .ctor(Register regLo, Register regHi)
public void Encode(Encoder encoder, Instruction& modreq(System.Runtime.InteropServices.InAttribute) instruction, int operand)
}
internal Iced.Intel.EncoderInternal.OpModRM_reg_mem : Op {
private Register regLo
private Register regHi
public void .ctor(Register regLo, Register regHi)
public void Encode(Encoder encoder, Instruction& modreq(System.Runtime.InteropServices.InAttribute) instruction, int operand)
}
internal Iced.Intel.EncoderInternal.OpModRM_regF0 : Op {
private Register regLo
private Register regHi
public void .ctor(Register regLo, Register regHi)
public void Encode(Encoder encoder, Instruction& modreq(System.Runtime.InteropServices.InAttribute) instruction, int operand)
}
internal Iced.Intel.EncoderInternal.OpModRM_rm : Op {
private Register regLo
private Register regHi
public void .ctor(Register regLo, Register regHi)
public void Encode(Encoder encoder, Instruction& modreq(System.Runtime.InteropServices.InAttribute) instruction, int operand)
}
internal Iced.Intel.EncoderInternal.OpModRM_rm_mem_only : Op {
private bool mustUseSib
public void .ctor(bool mustUseSib)
public void Encode(Encoder encoder, Instruction& modreq(System.Runtime.InteropServices.InAttribute) instruction, int operand)
}
internal Iced.Intel.EncoderInternal.OpModRM_rm_reg_only : Op {
private Register regLo
private Register regHi
public void .ctor(Register regLo, Register regHi)
public void Encode(Encoder encoder, Instruction& modreq(System.Runtime.InteropServices.InAttribute) instruction, int operand)
}
internal Iced.Intel.EncoderInternal.OpMRBX : Op {
public void Encode(Encoder encoder, Instruction& modreq(System.Runtime.InteropServices.InAttribute) instruction, int operand)
}
internal Iced.Intel.EncoderInternal.OpO : Op {
public void Encode(Encoder encoder, Instruction& modreq(System.Runtime.InteropServices.InAttribute) instruction, int operand)
}
internal Iced.Intel.EncoderInternal.OprDI : Op {
private int GetRegSize(OpKind opKind)
public void Encode(Encoder encoder, Instruction& modreq(System.Runtime.InteropServices.InAttribute) instruction, int operand)
}
internal Iced.Intel.EncoderInternal.OpReg : Op {
private Register register
public void .ctor(Register register)
public void Encode(Encoder encoder, Instruction& modreq(System.Runtime.InteropServices.InAttribute) instruction, int operand)
}
internal Iced.Intel.EncoderInternal.OpRegEmbed8 : Op {
private Register regLo
private Register regHi
public void .ctor(Register regLo, Register regHi)
public void Encode(Encoder encoder, Instruction& modreq(System.Runtime.InteropServices.InAttribute) instruction, int operand)
}
internal Iced.Intel.EncoderInternal.OpRegSTi : Op {
public void Encode(Encoder encoder, Instruction& modreq(System.Runtime.InteropServices.InAttribute) instruction, int operand)
}
internal Iced.Intel.EncoderInternal.OpVsib : Op {
private Register vsibIndexRegLo
private Register vsibIndexRegHi
public void .ctor(Register regLo, Register regHi)
public void Encode(Encoder encoder, Instruction& modreq(System.Runtime.InteropServices.InAttribute) instruction, int operand)
}
internal Iced.Intel.EncoderInternal.OpX : Op {
internal int GetXRegSize(OpKind opKind)
internal int GetYRegSize(OpKind opKind)
public void Encode(Encoder encoder, Instruction& modreq(System.Runtime.InteropServices.InAttribute) instruction, int operand)
}
internal Iced.Intel.EncoderInternal.OpY : Op {
public void Encode(Encoder encoder, Instruction& modreq(System.Runtime.InteropServices.InAttribute) instruction, int operand)
}
internal Iced.Intel.EncoderInternal.TryConvertToDisp8N : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public bool Invoke(Encoder encoder, OpCodeHandler handler, Instruction& modreq(System.Runtime.InteropServices.InAttribute) instruction, int displ, SByte& compressedValue)
public IAsyncResult BeginInvoke(Encoder encoder, OpCodeHandler handler, Instruction& modreq(System.Runtime.InteropServices.InAttribute) instruction, int displ, SByte& compressedValue, AsyncCallback callback, object object)
public bool EndInvoke(Instruction& modreq(System.Runtime.InteropServices.InAttribute) instruction, SByte& compressedValue, IAsyncResult result)
}
internal Iced.Intel.EncoderInternal.VexHandler : OpCodeHandler {
private UInt32 table
private UInt32 lastByte
private UInt32 mask_W_L
private UInt32 mask_L
private UInt32 W1
private Op[] CreateOps(EncFlags1 encFlags1)
public void .ctor(EncFlags1 encFlags1, EncFlags2 encFlags2, EncFlags3 encFlags3)
public void Encode(Encoder encoder, Instruction& modreq(System.Runtime.InteropServices.InAttribute) instruction)
}
internal Iced.Intel.EncoderInternal.VexOpCodeTable : Enum {
public int value__
public VexOpCodeTable MAP0
public VexOpCodeTable MAP0F
public VexOpCodeTable MAP0F38
public VexOpCodeTable MAP0F3A
}
internal Iced.Intel.EncoderInternal.WBit : Enum {
public UInt32 value__
public WBit W0
public WBit W1
public WBit WIG
public WBit WIG32
}
internal Iced.Intel.EncoderInternal.XopHandler : OpCodeHandler {
private UInt32 table
private UInt32 lastByte
private Op[] CreateOps(EncFlags1 encFlags1)
public void .ctor(EncFlags1 encFlags1, EncFlags2 encFlags2, EncFlags3 encFlags3)
public void Encode(Encoder encoder, Instruction& modreq(System.Runtime.InteropServices.InAttribute) instruction)
}
internal Iced.Intel.EncoderInternal.XopOpCodeTable : Enum {
public int value__
public XopOpCodeTable MAP8
public XopOpCodeTable MAP9
public XopOpCodeTable MAP10
}
internal Iced.Intel.EncoderInternal.ZeroBytesHandler : OpCodeHandler {
public void .ctor(Code code)
public void Encode(Encoder encoder, Instruction& modreq(System.Runtime.InteropServices.InAttribute) instruction)
}
internal Iced.Intel.EncodingKind : Enum {
public int value__
public EncodingKind Legacy
public EncodingKind VEX
public EncodingKind EVEX
public EncodingKind XOP
public EncodingKind D3NOW
public EncodingKind MVEX
}
internal Iced.Intel.HexUtils : object {
public Byte[] ToByteArray(string hexData)
private int TryParseHexChar(char c)
}
internal Iced.Intel.IcedConstants : object {
internal int MaxOpCount
internal int MaxInstructionLength
internal int RegisterBits
internal Register VMM_first
internal Register VMM_last
internal int VMM_count
internal Register XMM_last
internal Register YMM_last
internal Register ZMM_last
internal Register TMM_last
internal int MaxCpuidFeatureInternalValues
internal MemorySize FirstBroadcastMemorySize
internal UInt32 MvexStart
internal UInt32 MvexLength
internal int CC_a_EnumCount
internal int CC_ae_EnumCount
internal int CC_b_EnumCount
internal int CC_be_EnumCount
internal int CC_e_EnumCount
internal int CC_g_EnumCount
internal int CC_ge_EnumCount
internal int CC_l_EnumCount
internal int CC_le_EnumCount
internal int CC_ne_EnumCount
internal int CC_np_EnumCount
internal int CC_p_EnumCount
internal int CodeEnumCount
internal int CodeSizeEnumCount
internal int ConditionCodeEnumCount
internal int CpuidFeatureEnumCount
internal int DecoderErrorEnumCount
internal int DecoratorKindEnumCount
internal int EncodingKindEnumCount
internal int FlowControlEnumCount
internal int FormatterSyntaxEnumCount
internal int FormatterTextKindEnumCount
internal int MandatoryPrefixEnumCount
internal int MemorySizeEnumCount
internal int MemorySizeOptionsEnumCount
internal int MnemonicEnumCount
internal int MvexConvFnEnumCount
internal int MvexEHBitEnumCount
internal int MvexRegMemConvEnumCount
internal int MvexTupleTypeLutKindEnumCount
internal int NumberBaseEnumCount
internal int NumberKindEnumCount
internal int OpAccessEnumCount
internal int OpCodeOperandKindEnumCount
internal int OpCodeTableKindEnumCount
internal int OpKindEnumCount
internal int PrefixKindEnumCount
internal int RegisterEnumCount
internal int RelocKindEnumCount
internal int RepPrefixKindEnumCount
internal int RoundingControlEnumCount
internal int TupleTypeEnumCount
public bool IsMvex(Code code)
}
internal Iced.Intel.IcedFeatures : object {
public bool HasGasFormatter
public bool HasIntelFormatter
public bool HasMasmFormatter
public bool HasNasmFormatter
public bool HasFastFormatter
public bool HasDecoder
public bool HasEncoder
public bool HasBlockEncoder
public bool HasOpCodeInfo
public bool HasInstructionInfo
public bool get_HasGasFormatter()
public bool get_HasIntelFormatter()
public bool get_HasMasmFormatter()
public bool get_HasNasmFormatter()
public bool get_HasFastFormatter()
public bool get_HasDecoder()
public bool get_HasEncoder()
public bool get_HasBlockEncoder()
public bool get_HasOpCodeInfo()
public bool get_HasInstructionInfo()
public void Initialize()
}
internal Iced.Intel.Instruction : ValueType {
internal int TOTAL_SIZE
private ulong nextRip
private ulong memDispl
private UInt32 flags1
private UInt32 immediate
private ushort code
private byte memBaseReg
private byte memIndexReg
private byte reg0
private byte reg1
private byte reg2
private byte reg3
private byte opKind0
private byte opKind1
private byte opKind2
private byte opKind3
private byte scale
private byte displSize
private byte len
private byte pad
public ushort IP16
public UInt32 IP32
public ulong IP
public ushort NextIP16
public UInt32 NextIP32
public ulong NextIP
public CodeSize CodeSize
internal CodeSize InternalCodeSize
public bool IsInvalid
public Code Code
public Mnemonic Mnemonic
public int OpCount
public int Length
internal bool Internal_HasRepeOrRepnePrefix
internal UInt32 HasAnyOf_Lock_Rep_Repne_Prefix
public bool HasXacquirePrefix
public bool HasXreleasePrefix
public bool HasRepPrefix
public bool HasRepePrefix
public bool HasRepnePrefix
public bool HasLockPrefix
public OpKind Op0Kind
internal bool Internal_Op0IsNotReg_or_Op1IsNotReg
public OpKind Op1Kind
public OpKind Op2Kind
public OpKind Op3Kind
public OpKind Op4Kind
public bool HasSegmentPrefix
public Register SegmentPrefix
public Register MemorySegment
public int MemoryDisplSize
public bool IsBroadcast
public MemorySize MemorySize
public int MemoryIndexScale
internal int InternalMemoryIndexScale
public UInt32 MemoryDisplacement32
public ulong MemoryDisplacement64
public byte Immediate8
internal UInt32 InternalImmediate8
public byte Immediate8_2nd
internal UInt32 InternalImmediate8_2nd
public ushort Immediate16
internal UInt32 InternalImmediate16
public UInt32 Immediate32
public ulong Immediate64
internal UInt32 InternalImmediate64_lo
internal UInt32 InternalImmediate64_hi
public short Immediate8to16
public int Immediate8to32
public long Immediate8to64
public long Immediate32to64
public ushort NearBranch16
internal UInt32 InternalNearBranch16
public UInt32 NearBranch32
public ulong NearBranch64
public ulong NearBranchTarget
public ushort FarBranch16
internal UInt32 InternalFarBranch16
public UInt32 FarBranch32
public ushort FarBranchSelector
internal UInt32 InternalFarBranchSelector
public Register MemoryBase
internal Register InternalMemoryBase
public Register MemoryIndex
internal Register InternalMemoryIndex
public Register Op0Register
internal Register InternalOp0Register
public Register Op1Register
internal Register InternalOp1Register
public Register Op2Register
internal Register InternalOp2Register
public Register Op3Register
internal Register InternalOp3Register
public Register Op4Register
public Register OpMask
internal UInt32 InternalOpMask
public bool HasOpMask
internal bool HasOpMask_or_ZeroingMasking
public bool ZeroingMasking
public bool MergingMasking
public RoundingControl RoundingControl
internal UInt32 InternalRoundingControl
internal bool HasRoundingControlOrSae
public int DeclareDataCount
internal UInt32 InternalDeclareDataCount
public bool IsVsib
public bool IsVsib32
public bool IsVsib64
public bool SuppressAllExceptions
public bool IsIPRelativeMemoryOperand
public ulong IPRelativeMemoryAddress
private void InitializeSignedImmediate(Instruction& instruction, int operand, long immediate)
private void InitializeUnsignedImmediate(Instruction& instruction, int operand, ulong immediate)
private OpKind GetImmediateOpKind(Code code, int operand)
private OpKind GetNearBranchOpKind(Code code, int operand)
private OpKind GetFarBranchOpKind(Code code, int operand)
private Instruction CreateString_Reg_SegRSI(Code code, int addressSize, Register register, Register segmentPrefix, RepPrefixKind repPrefix)
private Instruction CreateString_Reg_ESRDI(Code code, int addressSize, Register register, RepPrefixKind repPrefix)
private Instruction CreateString_ESRDI_Reg(Code code, int addressSize, Register register, RepPrefixKind repPrefix)
private Instruction CreateString_SegRSI_ESRDI(Code code, int addressSize, Register segmentPrefix, RepPrefixKind repPrefix)
private Instruction CreateString_ESRDI_SegRSI(Code code, int addressSize, Register segmentPrefix, RepPrefixKind repPrefix)
private Instruction CreateMaskmov(Code code, int addressSize, Register register1, Register register2, Register segmentPrefix)
private void InitMemoryOperand(Instruction& instruction, MemoryOperand& memory)
public Instruction Create(Code code)
public Instruction Create(Code code, Register register)
public Instruction Create(Code code, int immediate)
public Instruction Create(Code code, UInt32 immediate)
public Instruction Create(Code code, MemoryOperand& memory)
public Instruction Create(Code code, Register register1, Register register2)
public Instruction Create(Code code, Register register, int immediate)
public Instruction Create(Code code, Register register, UInt32 immediate)
public Instruction Create(Code code, Register register, long immediate)
public Instruction Create(Code code, Register register, ulong immediate)
public Instruction Create(Code code, Register register, MemoryOperand& memory)
public Instruction Create(Code code, int immediate, Register register)
public Instruction Create(Code code, UInt32 immediate, Register register)
public Instruction Create(Code code, int immediate1, int immediate2)
public Instruction Create(Code code, UInt32 immediate1, UInt32 immediate2)
public Instruction Create(Code code, MemoryOperand& memory, Register register)
public Instruction Create(Code code, MemoryOperand& memory, int immediate)
public Instruction Create(Code code, MemoryOperand& memory, UInt32 immediate)
public Instruction Create(Code code, Register register1, Register register2, Register register3)
public Instruction Create(Code code, Register register1, Register register2, int immediate)
public Instruction Create(Code code, Register register1, Register register2, UInt32 immediate)
public Instruction Create(Code code, Register register1, Register register2, MemoryOperand& memory)
public Instruction Create(Code code, Register register, int immediate1, int immediate2)
public Instruction Create(Code code, Register register, UInt32 immediate1, UInt32 immediate2)
public Instruction Create(Code code, Register register1, MemoryOperand& memory, Register register2)
public Instruction Create(Code code, Register register, MemoryOperand& memory, int immediate)
public Instruction Create(Code code, Register register, MemoryOperand& memory, UInt32 immediate)
public Instruction Create(Code code, MemoryOperand& memory, Register register1, Register register2)
public Instruction Create(Code code, MemoryOperand& memory, Register register, int immediate)
public Instruction Create(Code code, MemoryOperand& memory, Register register, UInt32 immediate)
public Instruction Create(Code code, Register register1, Register register2, Register register3, Register register4)
public Instruction Create(Code code, Register register1, Register register2, Register register3, int immediate)
public Instruction Create(Code code, Register register1, Register register2, Register register3, UInt32 immediate)
public Instruction Create(Code code, Register register1, Register register2, Register register3, MemoryOperand& memory)
public Instruction Create(Code code, Register register1, Register register2, int immediate1, int immediate2)
public Instruction Create(Code code, Register register1, Register register2, UInt32 immediate1, UInt32 immediate2)
public Instruction Create(Code code, Register register1, Register register2, MemoryOperand& memory, Register register3)
public Instruction Create(Code code, Register register1, Register register2, MemoryOperand& memory, int immediate)
public Instruction Create(Code code, Register register1, Register register2, MemoryOperand& memory, UInt32 immediate)
public Instruction Create(Code code, Register register1, Register register2, Register register3, Register register4, int immediate)
public Instruction Create(Code code, Register register1, Register register2, Register register3, Register register4, UInt32 immediate)
public Instruction Create(Code code, Register register1, Register register2, Register register3, MemoryOperand& memory, int immediate)
public Instruction Create(Code code, Register register1, Register register2, Register register3, MemoryOperand& memory, UInt32 immediate)
public Instruction Create(Code code, Register register1, Register register2, MemoryOperand& memory, Register register3, int immediate)
public Instruction Create(Code code, Register register1, Register register2, MemoryOperand& memory, Register register3, UInt32 immediate)
public Instruction CreateBranch(Code code, ulong target)
public Instruction CreateBranch(Code code, ushort selector, UInt32 offset)
public Instruction CreateXbegin(int bitness, ulong target)
public Instruction CreateOutsb(int addressSize, Register segmentPrefix, RepPrefixKind repPrefix)
public Instruction CreateRepOutsb(int addressSize)
public Instruction CreateOutsw(int addressSize, Register segmentPrefix, RepPrefixKind repPrefix)
public Instruction CreateRepOutsw(int addressSize)
public Instruction CreateOutsd(int addressSize, Register segmentPrefix, RepPrefixKind repPrefix)
public Instruction CreateRepOutsd(int addressSize)
public Instruction CreateLodsb(int addressSize, Register segmentPrefix, RepPrefixKind repPrefix)
public Instruction CreateRepLodsb(int addressSize)
public Instruction CreateLodsw(int addressSize, Register segmentPrefix, RepPrefixKind repPrefix)
public Instruction CreateRepLodsw(int addressSize)
public Instruction CreateLodsd(int addressSize, Register segmentPrefix, RepPrefixKind repPrefix)
public Instruction CreateRepLodsd(int addressSize)
public Instruction CreateLodsq(int addressSize, Register segmentPrefix, RepPrefixKind repPrefix)
public Instruction CreateRepLodsq(int addressSize)
public Instruction CreateScasb(int addressSize, RepPrefixKind repPrefix)
public Instruction CreateRepeScasb(int addressSize)
public Instruction CreateRepneScasb(int addressSize)
public Instruction CreateScasw(int addressSize, RepPrefixKind repPrefix)
public Instruction CreateRepeScasw(int addressSize)
public Instruction CreateRepneScasw(int addressSize)
public Instruction CreateScasd(int addressSize, RepPrefixKind repPrefix)
public Instruction CreateRepeScasd(int addressSize)
public Instruction CreateRepneScasd(int addressSize)
public Instruction CreateScasq(int addressSize, RepPrefixKind repPrefix)
public Instruction CreateRepeScasq(int addressSize)
public Instruction CreateRepneScasq(int addressSize)
public Instruction CreateInsb(int addressSize, RepPrefixKind repPrefix)
public Instruction CreateRepInsb(int addressSize)
public Instruction CreateInsw(int addressSize, RepPrefixKind repPrefix)
public Instruction CreateRepInsw(int addressSize)
public Instruction CreateInsd(int addressSize, RepPrefixKind repPrefix)
public Instruction CreateRepInsd(int addressSize)
public Instruction CreateStosb(int addressSize, RepPrefixKind repPrefix)
public Instruction CreateRepStosb(int addressSize)
public Instruction CreateStosw(int addressSize, RepPrefixKind repPrefix)
public Instruction CreateRepStosw(int addressSize)
public Instruction CreateStosd(int addressSize, RepPrefixKind repPrefix)
public Instruction CreateRepStosd(int addressSize)
public Instruction CreateStosq(int addressSize, RepPrefixKind repPrefix)
public Instruction CreateRepStosq(int addressSize)
public Instruction CreateCmpsb(int addressSize, Register segmentPrefix, RepPrefixKind repPrefix)
public Instruction CreateRepeCmpsb(int addressSize)
public Instruction CreateRepneCmpsb(int addressSize)
public Instruction CreateCmpsw(int addressSize, Register segmentPrefix, RepPrefixKind repPrefix)
public Instruction CreateRepeCmpsw(int addressSize)
public Instruction CreateRepneCmpsw(int addressSize)
public Instruction CreateCmpsd(int addressSize, Register segmentPrefix, RepPrefixKind repPrefix)
public Instruction CreateRepeCmpsd(int addressSize)
public Instruction CreateRepneCmpsd(int addressSize)
public Instruction CreateCmpsq(int addressSize, Register segmentPrefix, RepPrefixKind repPrefix)
public Instruction CreateRepeCmpsq(int addressSize)
public Instruction CreateRepneCmpsq(int addressSize)
public Instruction CreateMovsb(int addressSize, Register segmentPrefix, RepPrefixKind repPrefix)
public Instruction CreateRepMovsb(int addressSize)
public Instruction CreateMovsw(int addressSize, Register segmentPrefix, RepPrefixKind repPrefix)
public Instruction CreateRepMovsw(int addressSize)
public Instruction CreateMovsd(int addressSize, Register segmentPrefix, RepPrefixKind repPrefix)
public Instruction CreateRepMovsd(int addressSize)
public Instruction CreateMovsq(int addressSize, Register segmentPrefix, RepPrefixKind repPrefix)
public Instruction CreateRepMovsq(int addressSize)
public Instruction CreateMaskmovq(int addressSize, Register register1, Register register2, Register segmentPrefix)
public Instruction CreateMaskmovdqu(int addressSize, Register register1, Register register2, Register segmentPrefix)
public Instruction CreateVmaskmovdqu(int addressSize, Register register1, Register register2, Register segmentPrefix)
public Instruction CreateDeclareByte(byte b0)
public Instruction CreateDeclareByte(byte b0, byte b1)
public Instruction CreateDeclareByte(byte b0, byte b1, byte b2)
public Instruction CreateDeclareByte(byte b0, byte b1, byte b2, byte b3)
public Instruction CreateDeclareByte(byte b0, byte b1, byte b2, byte b3, byte b4)
public Instruction CreateDeclareByte(byte b0, byte b1, byte b2, byte b3, byte b4, byte b5)
public Instruction CreateDeclareByte(byte b0, byte b1, byte b2, byte b3, byte b4, byte b5, byte b6)
public Instruction CreateDeclareByte(byte b0, byte b1, byte b2, byte b3, byte b4, byte b5, byte b6, byte b7)
public Instruction CreateDeclareByte(byte b0, byte b1, byte b2, byte b3, byte b4, byte b5, byte b6, byte b7, byte b8)
public Instruction CreateDeclareByte(byte b0, byte b1, byte b2, byte b3, byte b4, byte b5, byte b6, byte b7, byte b8, byte b9)
public Instruction CreateDeclareByte(byte b0, byte b1, byte b2, byte b3, byte b4, byte b5, byte b6, byte b7, byte b8, byte b9, byte b10)
public Instruction CreateDeclareByte(byte b0, byte b1, byte b2, byte b3, byte b4, byte b5, byte b6, byte b7, byte b8, byte b9, byte b10, byte b11)
public Instruction CreateDeclareByte(byte b0, byte b1, byte b2, byte b3, byte b4, byte b5, byte b6, byte b7, byte b8, byte b9, byte b10, byte b11, byte b12)
public Instruction CreateDeclareByte(byte b0, byte b1, byte b2, byte b3, byte b4, byte b5, byte b6, byte b7, byte b8, byte b9, byte b10, byte b11, byte b12, byte b13)
public Instruction CreateDeclareByte(byte b0, byte b1, byte b2, byte b3, byte b4, byte b5, byte b6, byte b7, byte b8, byte b9, byte b10, byte b11, byte b12, byte b13, byte b14)
public Instruction CreateDeclareByte(byte b0, byte b1, byte b2, byte b3, byte b4, byte b5, byte b6, byte b7, byte b8, byte b9, byte b10, byte b11, byte b12, byte b13, byte b14, byte b15)
public Instruction CreateDeclareByte(ReadOnlySpan`1<byte> data)
public Instruction CreateDeclareByte(Byte[] data)
public Instruction CreateDeclareByte(Byte[] data, int index, int length)
public Instruction CreateDeclareWord(ushort w0)
public Instruction CreateDeclareWord(ushort w0, ushort w1)
public Instruction CreateDeclareWord(ushort w0, ushort w1, ushort w2)
public Instruction CreateDeclareWord(ushort w0, ushort w1, ushort w2, ushort w3)
public Instruction CreateDeclareWord(ushort w0, ushort w1, ushort w2, ushort w3, ushort w4)
public Instruction CreateDeclareWord(ushort w0, ushort w1, ushort w2, ushort w3, ushort w4, ushort w5)
public Instruction CreateDeclareWord(ushort w0, ushort w1, ushort w2, ushort w3, ushort w4, ushort w5, ushort w6)
public Instruction CreateDeclareWord(ushort w0, ushort w1, ushort w2, ushort w3, ushort w4, ushort w5, ushort w6, ushort w7)
public Instruction CreateDeclareWord(ReadOnlySpan`1<byte> data)
public Instruction CreateDeclareWord(Byte[] data)
public Instruction CreateDeclareWord(Byte[] data, int index, int length)
public Instruction CreateDeclareWord(ReadOnlySpan`1<ushort> data)
public Instruction CreateDeclareWord(UInt16[] data)
public Instruction CreateDeclareWord(UInt16[] data, int index, int length)
public Instruction CreateDeclareDword(UInt32 d0)
public Instruction CreateDeclareDword(UInt32 d0, UInt32 d1)
public Instruction CreateDeclareDword(UInt32 d0, UInt32 d1, UInt32 d2)
public Instruction CreateDeclareDword(UInt32 d0, UInt32 d1, UInt32 d2, UInt32 d3)
public Instruction CreateDeclareDword(ReadOnlySpan`1<byte> data)
public Instruction CreateDeclareDword(Byte[] data)
public Instruction CreateDeclareDword(Byte[] data, int index, int length)
public Instruction CreateDeclareDword(ReadOnlySpan`1<UInt32> data)
public Instruction CreateDeclareDword(UInt32[] data)
public Instruction CreateDeclareDword(UInt32[] data, int index, int length)
public Instruction CreateDeclareQword(ulong q0)
public Instruction CreateDeclareQword(ulong q0, ulong q1)
public Instruction CreateDeclareQword(ReadOnlySpan`1<byte> data)
public Instruction CreateDeclareQword(Byte[] data)
public Instruction CreateDeclareQword(Byte[] data, int index, int length)
public Instruction CreateDeclareQword(ReadOnlySpan`1<ulong> data)
public Instruction CreateDeclareQword(UInt64[] data)
public Instruction CreateDeclareQword(UInt64[] data, int index, int length)
public bool op_Equality(Instruction& left, Instruction& right)
public bool op_Inequality(Instruction& left, Instruction& right)
public bool Equals(Instruction& other)
private bool System.IEquatable<Iced.Intel.Instruction>.Equals(Instruction other)
private bool EqualsInternal(Instruction& a, Instruction& b)
public int GetHashCode()
public bool Equals(object obj)
public bool EqualsAllBits(Instruction& a, Instruction& b)
public ushort get_IP16()
public void set_IP16(ushort value)
public UInt32 get_IP32()
public void set_IP32(UInt32 value)
public ulong get_IP()
public void set_IP(ulong value)
public ushort get_NextIP16()
public void set_NextIP16(ushort value)
public UInt32 get_NextIP32()
public void set_NextIP32(UInt32 value)
public ulong get_NextIP()
public void set_NextIP(ulong value)
public CodeSize get_CodeSize()
public void set_CodeSize(CodeSize value)
internal void set_InternalCodeSize(CodeSize value)
public bool get_IsInvalid()
public Code get_Code()
public void set_Code(Code value)
internal void InternalSetCodeNoCheck(Code code)
public Mnemonic get_Mnemonic()
public int get_OpCount()
public int get_Length()
public void set_Length(int value)
internal bool get_Internal_HasRepeOrRepnePrefix()
internal UInt32 get_HasAnyOf_Lock_Rep_Repne_Prefix()
private bool IsXacquireInstr()
private bool IsXreleaseInstr()
public bool get_HasXacquirePrefix()
public void set_HasXacquirePrefix(bool value)
internal void InternalSetHasXacquirePrefix()
public bool get_HasXreleasePrefix()
public void set_HasXreleasePrefix(bool value)
internal void InternalSetHasXreleasePrefix()
public bool get_HasRepPrefix()
public void set_HasRepPrefix(bool value)
public bool get_HasRepePrefix()
public void set_HasRepePrefix(bool value)
internal void InternalSetHasRepePrefix()
internal void InternalClearHasRepePrefix()
internal void InternalClearHasRepeRepnePrefix()
public bool get_HasRepnePrefix()
public void set_HasRepnePrefix(bool value)
internal void InternalSetHasRepnePrefix()
internal void InternalClearHasRepnePrefix()
public bool get_HasLockPrefix()
public void set_HasLockPrefix(bool value)
internal void InternalSetHasLockPrefix()
internal void InternalClearHasLockPrefix()
public OpKind get_Op0Kind()
public void set_Op0Kind(OpKind value)
internal bool get_Internal_Op0IsNotReg_or_Op1IsNotReg()
public OpKind get_Op1Kind()
public void set_Op1Kind(OpKind value)
public OpKind get_Op2Kind()
public void set_Op2Kind(OpKind value)
public OpKind get_Op3Kind()
public void set_Op3Kind(OpKind value)
public OpKind get_Op4Kind()
public void set_Op4Kind(OpKind value)
public OpKind GetOpKind(int operand)
public bool HasOpKind(OpKind opKind)
public void SetOpKind(int operand, OpKind opKind)
public bool get_HasSegmentPrefix()
public Register get_SegmentPrefix()
public void set_SegmentPrefix(Register value)
public Register get_MemorySegment()
public int get_MemoryDisplSize()
public void set_MemoryDisplSize(int value)
internal void InternalSetMemoryDisplSize(UInt32 scale)
public bool get_IsBroadcast()
public void set_IsBroadcast(bool value)
internal void InternalSetIsBroadcast()
public MemorySize get_MemorySize()
public int get_MemoryIndexScale()
public void set_MemoryIndexScale(int value)
internal int get_InternalMemoryIndexScale()
internal void set_InternalMemoryIndexScale(int value)
public UInt32 get_MemoryDisplacement32()
public void set_MemoryDisplacement32(UInt32 value)
public ulong get_MemoryDisplacement64()
public void set_MemoryDisplacement64(ulong value)
public ulong GetImmediate(int operand)
public void SetImmediate(int operand, int immediate)
public void SetImmediate(int operand, UInt32 immediate)
public void SetImmediate(int operand, long immediate)
public void SetImmediate(int operand, ulong immediate)
public byte get_Immediate8()
public void set_Immediate8(byte value)
internal void set_InternalImmediate8(UInt32 value)
public byte get_Immediate8_2nd()
public void set_Immediate8_2nd(byte value)
internal void set_InternalImmediate8_2nd(UInt32 value)
public ushort get_Immediate16()
public void set_Immediate16(ushort value)
internal void set_InternalImmediate16(UInt32 value)
public UInt32 get_Immediate32()
public void set_Immediate32(UInt32 value)
public ulong get_Immediate64()
public void set_Immediate64(ulong value)
internal void set_InternalImmediate64_lo(UInt32 value)
internal void set_InternalImmediate64_hi(UInt32 value)
public short get_Immediate8to16()
public void set_Immediate8to16(short value)
public int get_Immediate8to32()
public void set_Immediate8to32(int value)
public long get_Immediate8to64()
public void set_Immediate8to64(long value)
public long get_Immediate32to64()
public void set_Immediate32to64(long value)
public ushort get_NearBranch16()
public void set_NearBranch16(ushort value)
internal void set_InternalNearBranch16(UInt32 value)
public UInt32 get_NearBranch32()
public void set_NearBranch32(UInt32 value)
public ulong get_NearBranch64()
public void set_NearBranch64(ulong value)
public ulong get_NearBranchTarget()
public ushort get_FarBranch16()
public void set_FarBranch16(ushort value)
internal void set_InternalFarBranch16(UInt32 value)
public UInt32 get_FarBranch32()
public void set_FarBranch32(UInt32 value)
public ushort get_FarBranchSelector()
public void set_FarBranchSelector(ushort value)
internal void set_InternalFarBranchSelector(UInt32 value)
public Register get_MemoryBase()
public void set_MemoryBase(Register value)
internal void set_InternalMemoryBase(Register value)
public Register get_MemoryIndex()
public void set_MemoryIndex(Register value)
internal void set_InternalMemoryIndex(Register value)
public Register get_Op0Register()
public void set_Op0Register(Register value)
internal void set_InternalOp0Register(Register value)
public Register get_Op1Register()
public void set_Op1Register(Register value)
internal void set_InternalOp1Register(Register value)
public Register get_Op2Register()
public void set_Op2Register(Register value)
internal void set_InternalOp2Register(Register value)
public Register get_Op3Register()
public void set_Op3Register(Register value)
internal void set_InternalOp3Register(Register value)
public Register get_Op4Register()
public void set_Op4Register(Register value)
public Register GetOpRegister(int operand)
public void SetOpRegister(int operand, Register register)
public Register get_OpMask()
public void set_OpMask(Register value)
internal UInt32 get_InternalOpMask()
internal void set_InternalOpMask(UInt32 value)
public bool get_HasOpMask()
internal bool get_HasOpMask_or_ZeroingMasking()
public bool get_ZeroingMasking()
public void set_ZeroingMasking(bool value)
internal void InternalSetZeroingMasking()
public bool get_MergingMasking()
public void set_MergingMasking(bool value)
public RoundingControl get_RoundingControl()
public void set_RoundingControl(RoundingControl value)
internal void set_InternalRoundingControl(UInt32 value)
internal bool get_HasRoundingControlOrSae()
public int get_DeclareDataCount()
public void set_DeclareDataCount(int value)
internal void set_InternalDeclareDataCount(UInt32 value)
public void SetDeclareByteValue(int index, sbyte value)
public void SetDeclareByteValue(int index, byte value)
public byte GetDeclareByteValue(int index)
public void SetDeclareWordValue(int index, short value)
public void SetDeclareWordValue(int index, ushort value)
public ushort GetDeclareWordValue(int index)
public void SetDeclareDwordValue(int index, int value)
public void SetDeclareDwordValue(int index, UInt32 value)
public UInt32 GetDeclareDwordValue(int index)
public void SetDeclareQwordValue(int index, long value)
public void SetDeclareQwordValue(int index, ulong value)
public ulong GetDeclareQwordValue(int index)
public bool get_IsVsib()
public bool get_IsVsib32()
public bool get_IsVsib64()
public bool TryGetVsib64(Boolean& vsib64)
public bool get_SuppressAllExceptions()
public void set_SuppressAllExceptions(bool value)
internal void InternalSetSuppressAllExceptions()
public bool get_IsIPRelativeMemoryOperand()
public ulong get_IPRelativeMemoryAddress()
public string ToString()
public ulong GetVirtualAddress(int operand, int elementIndex, VAGetRegisterValue getRegisterValue)
public ulong GetVirtualAddress(int operand, int elementIndex, IVARegisterValueProvider registerValueProvider)
public bool TryGetVirtualAddress(int operand, int elementIndex, UInt64& result, VATryGetRegisterValue getRegisterValue)
public bool TryGetVirtualAddress(int operand, int elementIndex, IVATryGetRegisterValueProvider registerValueProvider, UInt64& result)
}
internal Iced.Intel.InstructionBlock : ValueType {
public CodeWriter CodeWriter
public IList`1<Instruction> Instructions
public ulong RIP
public void .ctor(CodeWriter codeWriter, IList`1<Instruction> instructions, ulong rip)
}
internal Iced.Intel.InstructionInfoExtensions : object {
public Code NegateConditionCode(Code code)
public Code ToShortBranch(Code code)
public Code ToNearBranch(Code code)
}
internal Iced.Intel.InstructionList : object {
private Instruction[] elements
private int count
public int Count
private int System.Collections.Generic.ICollection<Iced.Intel.Instruction>.Count
private int System.Collections.ICollection.Count
private int System.Collections.Generic.IReadOnlyCollection<Iced.Intel.Instruction>.Count
public int Capacity
private bool System.Collections.Generic.ICollection<Iced.Intel.Instruction>.IsReadOnly
private bool System.Collections.IList.IsReadOnly
private bool System.Collections.IList.IsFixedSize
private bool System.Collections.ICollection.IsSynchronized
private object System.Collections.ICollection.SyncRoot
public Instruction& Item
private Instruction System.Collections.Generic.IList<Iced.Intel.Instruction>.Item
private Instruction System.Collections.Generic.IReadOnlyList<Iced.Intel.Instruction>.Item
private object System.Collections.IList.Item
public int get_Count()
private int System.Collections.Generic.ICollection<Iced.Intel.Instruction>.get_Count()
private int System.Collections.ICollection.get_Count()
private int System.Collections.Generic.IReadOnlyCollection<Iced.Intel.Instruction>.get_Count()
public int get_Capacity()
private bool System.Collections.Generic.ICollection<Iced.Intel.Instruction>.get_IsReadOnly()
private bool System.Collections.IList.get_IsReadOnly()
private bool System.Collections.IList.get_IsFixedSize()
private bool System.Collections.ICollection.get_IsSynchronized()
private object System.Collections.ICollection.get_SyncRoot()
public Instruction& get_Item(int index)
private Instruction System.Collections.Generic.IList<Iced.Intel.Instruction>.get_Item(int index)
private void System.Collections.Generic.IList<Iced.Intel.Instruction>.set_Item(int index, Instruction value)
private Instruction System.Collections.Generic.IReadOnlyList<Iced.Intel.Instruction>.get_Item(int index)
private object System.Collections.IList.get_Item(int index)
private void System.Collections.IList.set_Item(int index, object value)
public void .ctor(int capacity)
public void .ctor(InstructionList list)
public void .ctor(IEnumerable`1<Instruction> collection)
private void SetMinCapacity(int minCapacity)
public Instruction& AllocUninitializedElement()
private void MakeRoom(int index, int extraLength)
public void Insert(int index, Instruction& instruction)
private void System.Collections.Generic.IList<Iced.Intel.Instruction>.Insert(int index, Instruction instruction)
private void System.Collections.IList.Insert(int index, object value)
public void RemoveAt(int index)
private void System.Collections.Generic.IList<Iced.Intel.Instruction>.RemoveAt(int index)
private void System.Collections.IList.RemoveAt(int index)
public void AddRange(IEnumerable`1<Instruction> collection)
public void InsertRange(int index, IEnumerable`1<Instruction> collection)
public void RemoveRange(int index, int count)
public void Add(Instruction& instruction)
private void System.Collections.Generic.ICollection<Iced.Intel.Instruction>.Add(Instruction instruction)
private int System.Collections.IList.Add(object value)
public void Clear()
private void System.Collections.Generic.ICollection<Iced.Intel.Instruction>.Clear()
private void System.Collections.IList.Clear()
public bool Contains(Instruction& instruction)
private bool System.Collections.Generic.ICollection<Iced.Intel.Instruction>.Contains(Instruction instruction)
private bool System.Collections.IList.Contains(object value)
public int IndexOf(Instruction& instruction)
private int System.Collections.Generic.IList<Iced.Intel.Instruction>.IndexOf(Instruction instruction)
private int System.Collections.IList.IndexOf(object value)
public int IndexOf(Instruction& instruction, int index)
public int IndexOf(Instruction& instruction, int index, int count)
public int LastIndexOf(Instruction& instruction)
public int LastIndexOf(Instruction& instruction, int index)
public int LastIndexOf(Instruction& instruction, int index, int count)
public bool Remove(Instruction& instruction)
private bool System.Collections.Generic.ICollection<Iced.Intel.Instruction>.Remove(Instruction instruction)
private void System.Collections.IList.Remove(object value)
public void CopyTo(Instruction[] array)
public void CopyTo(Instruction[] array, int arrayIndex)
private void System.Collections.Generic.ICollection<Iced.Intel.Instruction>.CopyTo(Instruction[] array, int arrayIndex)
private void System.Collections.ICollection.CopyTo(Array array, int index)
public void CopyTo(int index, Instruction[] array, int arrayIndex, int count)
public InstructionList GetRange(int index, int count)
public Enumerator GetEnumerator()
private IEnumerator`1<Instruction> System.Collections.Generic.IEnumerable<Iced.Intel.Instruction>.GetEnumerator()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
public ReadOnlyCollection`1<Instruction> AsReadOnly()
public Instruction[] ToArray()
}
internal Iced.Intel.InstructionListDebugView : object {
private InstructionList list
public Instruction[] Items
public void .ctor(InstructionList list)
public Instruction[] get_Items()
}
internal Iced.Intel.InstructionMemorySizes : object {
internal ReadOnlySpan`1<byte> SizesNormal
internal ReadOnlySpan`1<byte> SizesBcst
internal ReadOnlySpan`1<byte> get_SizesNormal()
internal ReadOnlySpan`1<byte> get_SizesBcst()
}
internal Iced.Intel.InstructionOpCounts : object {
internal ReadOnlySpan`1<byte> OpCount
internal ReadOnlySpan`1<byte> get_OpCount()
}
internal Iced.Intel.InstructionUtils : object {
public int GetAddressSizeInBytes(Register baseReg, Register indexReg, int displSize, CodeSize codeSize)
}
internal Iced.Intel.Internal.DataReader : ValueType {
private ReadOnlySpan`1<byte> data
private Char[] stringData
private int index
public int Index
public bool CanRead
public int get_Index()
public void set_Index(int value)
public bool get_CanRead()
public void .ctor(ReadOnlySpan`1<byte> data)
public void .ctor(ReadOnlySpan`1<byte> data, int maxStringLength)
public byte ReadByte()
public UInt32 ReadCompressedUInt32()
public string ReadAsciiString()
}
internal Iced.Intel.IVARegisterValueProvider {
public ulong GetRegisterValue(Register register, int elementIndex, int elementSize)
}
internal Iced.Intel.IVATryGetRegisterValueProvider {
public bool TryGetRegisterValue(Register register, int elementIndex, int elementSize, UInt64& value)
}
internal Iced.Intel.MandatoryPrefixByte : Enum {
public UInt32 value__
public MandatoryPrefixByte None
public MandatoryPrefixByte P66
public MandatoryPrefixByte PF3
public MandatoryPrefixByte PF2
}
internal Iced.Intel.MemoryOperand : ValueType {
public Register SegmentPrefix
public Register Base
public Register Index
public int Scale
public long Displacement
public int DisplSize
public bool IsBroadcast
public void .ctor(Register base, Register index, int scale, long displacement, int displSize, bool isBroadcast, Register segmentPrefix)
public void .ctor(Register base, Register index, int scale, bool isBroadcast, Register segmentPrefix)
public void .ctor(Register base, long displacement, int displSize, bool isBroadcast, Register segmentPrefix)
public void .ctor(Register index, int scale, long displacement, int displSize, bool isBroadcast, Register segmentPrefix)
public void .ctor(Register base, long displacement, bool isBroadcast, Register segmentPrefix)
public void .ctor(Register base, Register index, int scale, long displacement, int displSize)
public void .ctor(Register base, Register index, int scale)
public void .ctor(Register base, Register index)
public void .ctor(Register base, long displacement, int displSize)
public void .ctor(Register index, int scale, long displacement, int displSize)
public void .ctor(Register base, long displacement)
public void .ctor(Register base)
public void .ctor(ulong displacement, int displSize)
}
internal Iced.Intel.MemorySize : Enum {
public int value__
public MemorySize Unknown
public MemorySize UInt8
public MemorySize UInt16
public MemorySize UInt32
public MemorySize UInt52
public MemorySize UInt64
public MemorySize UInt128
public MemorySize UInt256
public MemorySize UInt512
public MemorySize Int8
public MemorySize Int16
public MemorySize Int32
public MemorySize Int64
public MemorySize Int128
public MemorySize Int256
public MemorySize Int512
public MemorySize SegPtr16
public MemorySize SegPtr32
public MemorySize SegPtr64
public MemorySize WordOffset
public MemorySize DwordOffset
public MemorySize QwordOffset
public MemorySize Bound16_WordWord
public MemorySize Bound32_DwordDword
public MemorySize Bnd32
public MemorySize Bnd64
public MemorySize Fword6
public MemorySize Fword10
public MemorySize Float16
public MemorySize Float32
public MemorySize Float64
public MemorySize Float80
public MemorySize Float128
public MemorySize BFloat16
public MemorySize FpuEnv14
public MemorySize FpuEnv28
public MemorySize FpuState94
public MemorySize FpuState108
public MemorySize Fxsave_512Byte
public MemorySize Fxsave64_512Byte
public MemorySize Xsave
public MemorySize Xsave64
public MemorySize Bcd
public MemorySize Tilecfg
public MemorySize Tile
public MemorySize SegmentDescSelector
public MemorySize KLHandleAes128
public MemorySize KLHandleAes256
public MemorySize Packed16_UInt8
public MemorySize Packed16_Int8
public MemorySize Packed32_UInt8
public MemorySize Packed32_Int8
public MemorySize Packed32_UInt16
public MemorySize Packed32_Int16
public MemorySize Packed32_Float16
public MemorySize Packed32_BFloat16
public MemorySize Packed64_UInt8
public MemorySize Packed64_Int8
public MemorySize Packed64_UInt16
public MemorySize Packed64_Int16
public MemorySize Packed64_UInt32
public MemorySize Packed64_Int32
public MemorySize Packed64_Float16
public MemorySize Packed64_Float32
public MemorySize Packed128_UInt8
public MemorySize Packed128_Int8
public MemorySize Packed128_UInt16
public MemorySize Packed128_Int16
public MemorySize Packed128_UInt32
public MemorySize Packed128_Int32
public MemorySize Packed128_UInt52
public MemorySize Packed128_UInt64
public MemorySize Packed128_Int64
public MemorySize Packed128_Float16
public MemorySize Packed128_Float32
public MemorySize Packed128_Float64
public MemorySize Packed128_2xFloat16
public MemorySize Packed128_2xBFloat16
public MemorySize Packed256_UInt8
public MemorySize Packed256_Int8
public MemorySize Packed256_UInt16
public MemorySize Packed256_Int16
public MemorySize Packed256_UInt32
public MemorySize Packed256_Int32
public MemorySize Packed256_UInt52
public MemorySize Packed256_UInt64
public MemorySize Packed256_Int64
public MemorySize Packed256_UInt128
public MemorySize Packed256_Int128
public MemorySize Packed256_Float16
public MemorySize Packed256_Float32
public MemorySize Packed256_Float64
public MemorySize Packed256_Float128
public MemorySize Packed256_2xFloat16
public MemorySize Packed256_2xBFloat16
public MemorySize Packed512_UInt8
public MemorySize Packed512_Int8
public MemorySize Packed512_UInt16
public MemorySize Packed512_Int16
public MemorySize Packed512_UInt32
public MemorySize Packed512_Int32
public MemorySize Packed512_UInt52
public MemorySize Packed512_UInt64
public MemorySize Packed512_Int64
public MemorySize Packed512_UInt128
public MemorySize Packed512_Float16
public MemorySize Packed512_Float32
public MemorySize Packed512_Float64
public MemorySize Packed512_2xFloat16
public MemorySize Packed512_2xBFloat16
public MemorySize Broadcast32_Float16
public MemorySize Broadcast64_UInt32
public MemorySize Broadcast64_Int32
public MemorySize Broadcast64_Float16
public MemorySize Broadcast64_Float32
public MemorySize Broadcast128_Int16
public MemorySize Broadcast128_UInt16
public MemorySize Broadcast128_UInt32
public MemorySize Broadcast128_Int32
public MemorySize Broadcast128_UInt52
public MemorySize Broadcast128_UInt64
public MemorySize Broadcast128_Int64
public MemorySize Broadcast128_Float16
public MemorySize Broadcast128_Float32
public MemorySize Broadcast128_Float64
public MemorySize Broadcast128_2xInt16
public MemorySize Broadcast128_2xInt32
public MemorySize Broadcast128_2xUInt32
public MemorySize Broadcast128_2xFloat16
public MemorySize Broadcast128_2xBFloat16
public MemorySize Broadcast256_Int16
public MemorySize Broadcast256_UInt16
public MemorySize Broadcast256_UInt32
public MemorySize Broadcast256_Int32
public MemorySize Broadcast256_UInt52
public MemorySize Broadcast256_UInt64
public MemorySize Broadcast256_Int64
public MemorySize Broadcast256_Float16
public MemorySize Broadcast256_Float32
public MemorySize Broadcast256_Float64
public MemorySize Broadcast256_2xInt16
public MemorySize Broadcast256_2xInt32
public MemorySize Broadcast256_2xUInt32
public MemorySize Broadcast256_2xFloat16
public MemorySize Broadcast256_2xBFloat16
public MemorySize Broadcast512_Int16
public MemorySize Broadcast512_UInt16
public MemorySize Broadcast512_UInt32
public MemorySize Broadcast512_Int32
public MemorySize Broadcast512_UInt52
public MemorySize Broadcast512_UInt64
public MemorySize Broadcast512_Int64
public MemorySize Broadcast512_Float16
public MemorySize Broadcast512_Float32
public MemorySize Broadcast512_Float64
public MemorySize Broadcast512_2xFloat16
public MemorySize Broadcast512_2xInt16
public MemorySize Broadcast512_2xUInt32
public MemorySize Broadcast512_2xInt32
public MemorySize Broadcast512_2xBFloat16
}
internal Iced.Intel.MemorySizeExtensions : object {
internal MemorySizeInfo[] MemorySizeInfos
public bool IsBroadcast(MemorySize memorySize)
private MemorySizeInfo[] GetMemorySizeInfos()
public MemorySizeInfo GetInfo(MemorySize memorySize)
public int GetSize(MemorySize memorySize)
public int GetElementSize(MemorySize memorySize)
public MemorySize GetElementType(MemorySize memorySize)
public MemorySizeInfo GetElementTypeInfo(MemorySize memorySize)
public bool IsSigned(MemorySize memorySize)
public bool IsPacked(MemorySize memorySize)
public int GetElementCount(MemorySize memorySize)
}
internal Iced.Intel.MemorySizeInfo : ValueType {
private ushort size
private ushort elementSize
private byte memorySize
private byte elementType
private bool isSigned
private bool isBroadcast
public MemorySize MemorySize
public int Size
public int ElementSize
public MemorySize ElementType
public bool IsSigned
public bool IsBroadcast
public bool IsPacked
public int ElementCount
public MemorySize get_MemorySize()
public int get_Size()
public int get_ElementSize()
public MemorySize get_ElementType()
public bool get_IsSigned()
public bool get_IsBroadcast()
public bool get_IsPacked()
public int get_ElementCount()
public void .ctor(MemorySize memorySize, int size, int elementSize, MemorySize elementType, bool isSigned, bool isBroadcast)
}
internal Iced.Intel.Mnemonic : Enum {
public int value__
public Mnemonic INVALID
public Mnemonic Aaa
public Mnemonic Aad
public Mnemonic Aam
public Mnemonic Aas
public Mnemonic Adc
public Mnemonic Adcx
public Mnemonic Add
public Mnemonic Addpd
public Mnemonic Addps
public Mnemonic Addsd
public Mnemonic Addss
public Mnemonic Addsubpd
public Mnemonic Addsubps
public Mnemonic Adox
public Mnemonic Aesdec
public Mnemonic Aesdeclast
public Mnemonic Aesenc
public Mnemonic Aesenclast
public Mnemonic Aesimc
public Mnemonic Aeskeygenassist
public Mnemonic And
public Mnemonic Andn
public Mnemonic Andnpd
public Mnemonic Andnps
public Mnemonic Andpd
public Mnemonic Andps
public Mnemonic Arpl
public Mnemonic Bextr
public Mnemonic Blcfill
public Mnemonic Blci
public Mnemonic Blcic
public Mnemonic Blcmsk
public Mnemonic Blcs
public Mnemonic Blendpd
public Mnemonic Blendps
public Mnemonic Blendvpd
public Mnemonic Blendvps
public Mnemonic Blsfill
public Mnemonic Blsi
public Mnemonic Blsic
public Mnemonic Blsmsk
public Mnemonic Blsr
public Mnemonic Bndcl
public Mnemonic Bndcn
public Mnemonic Bndcu
public Mnemonic Bndldx
public Mnemonic Bndmk
public Mnemonic Bndmov
public Mnemonic Bndstx
public Mnemonic Bound
public Mnemonic Bsf
public Mnemonic Bsr
public Mnemonic Bswap
public Mnemonic Bt
public Mnemonic Btc
public Mnemonic Btr
public Mnemonic Bts
public Mnemonic Bzhi
public Mnemonic Call
public Mnemonic Cbw
public Mnemonic Cdq
public Mnemonic Cdqe
public Mnemonic Cl1invmb
public Mnemonic Clac
public Mnemonic Clc
public Mnemonic Cld
public Mnemonic Cldemote
public Mnemonic Clflush
public Mnemonic Clflushopt
public Mnemonic Clgi
public Mnemonic Cli
public Mnemonic Clrssbsy
public Mnemonic Clts
public Mnemonic Clwb
public Mnemonic Clzero
public Mnemonic Cmc
public Mnemonic Cmova
public Mnemonic Cmovae
public Mnemonic Cmovb
public Mnemonic Cmovbe
public Mnemonic Cmove
public Mnemonic Cmovg
public Mnemonic Cmovge
public Mnemonic Cmovl
public Mnemonic Cmovle
public Mnemonic Cmovne
public Mnemonic Cmovno
public Mnemonic Cmovnp
public Mnemonic Cmovns
public Mnemonic Cmovo
public Mnemonic Cmovp
public Mnemonic Cmovs
public Mnemonic Cmp
public Mnemonic Cmppd
public Mnemonic Cmpps
public Mnemonic Cmpsb
public Mnemonic Cmpsd
public Mnemonic Cmpsq
public Mnemonic Cmpss
public Mnemonic Cmpsw
public Mnemonic Cmpxchg
public Mnemonic Cmpxchg16b
public Mnemonic Cmpxchg8b
public Mnemonic Comisd
public Mnemonic Comiss
public Mnemonic Cpuid
public Mnemonic Cqo
public Mnemonic Crc32
public Mnemonic Cvtdq2pd
public Mnemonic Cvtdq2ps
public Mnemonic Cvtpd2dq
public Mnemonic Cvtpd2pi
public Mnemonic Cvtpd2ps
public Mnemonic Cvtpi2pd
public Mnemonic Cvtpi2ps
public Mnemonic Cvtps2dq
public Mnemonic Cvtps2pd
public Mnemonic Cvtps2pi
public Mnemonic Cvtsd2si
public Mnemonic Cvtsd2ss
public Mnemonic Cvtsi2sd
public Mnemonic Cvtsi2ss
public Mnemonic Cvtss2sd
public Mnemonic Cvtss2si
public Mnemonic Cvttpd2dq
public Mnemonic Cvttpd2pi
public Mnemonic Cvttps2dq
public Mnemonic Cvttps2pi
public Mnemonic Cvttsd2si
public Mnemonic Cvttss2si
public Mnemonic Cwd
public Mnemonic Cwde
public Mnemonic Daa
public Mnemonic Das
public Mnemonic Db
public Mnemonic Dd
public Mnemonic Dec
public Mnemonic Div
public Mnemonic Divpd
public Mnemonic Divps
public Mnemonic Divsd
public Mnemonic Divss
public Mnemonic Dppd
public Mnemonic Dpps
public Mnemonic Dq
public Mnemonic Dw
public Mnemonic Emms
public Mnemonic Encls
public Mnemonic Enclu
public Mnemonic Enclv
public Mnemonic Endbr32
public Mnemonic Endbr64
public Mnemonic Enqcmd
public Mnemonic Enqcmds
public Mnemonic Enter
public Mnemonic Extractps
public Mnemonic Extrq
public Mnemonic F2xm1
public Mnemonic Fabs
public Mnemonic Fadd
public Mnemonic Faddp
public Mnemonic Fbld
public Mnemonic Fbstp
public Mnemonic Fchs
public Mnemonic Fclex
public Mnemonic Fcmovb
public Mnemonic Fcmovbe
public Mnemonic Fcmove
public Mnemonic Fcmovnb
public Mnemonic Fcmovnbe
public Mnemonic Fcmovne
public Mnemonic Fcmovnu
public Mnemonic Fcmovu
public Mnemonic Fcom
public Mnemonic Fcomi
public Mnemonic Fcomip
public Mnemonic Fcomp
public Mnemonic Fcompp
public Mnemonic Fcos
public Mnemonic Fdecstp
public Mnemonic Fdisi
public Mnemonic Fdiv
public Mnemonic Fdivp
public Mnemonic Fdivr
public Mnemonic Fdivrp
public Mnemonic Femms
public Mnemonic Feni
public Mnemonic Ffree
public Mnemonic Ffreep
public Mnemonic Fiadd
public Mnemonic Ficom
public Mnemonic Ficomp
public Mnemonic Fidiv
public Mnemonic Fidivr
public Mnemonic Fild
public Mnemonic Fimul
public Mnemonic Fincstp
public Mnemonic Finit
public Mnemonic Fist
public Mnemonic Fistp
public Mnemonic Fisttp
public Mnemonic Fisub
public Mnemonic Fisubr
public Mnemonic Fld
public Mnemonic Fld1
public Mnemonic Fldcw
public Mnemonic Fldenv
public Mnemonic Fldl2e
public Mnemonic Fldl2t
public Mnemonic Fldlg2
public Mnemonic Fldln2
public Mnemonic Fldpi
public Mnemonic Fldz
public Mnemonic Fmul
public Mnemonic Fmulp
public Mnemonic Fnclex
public Mnemonic Fndisi
public Mnemonic Fneni
public Mnemonic Fninit
public Mnemonic Fnop
public Mnemonic Fnsave
public Mnemonic Fnsetpm
public Mnemonic Fnstcw
public Mnemonic Fnstenv
public Mnemonic Fnstsw
public Mnemonic Fpatan
public Mnemonic Fprem
public Mnemonic Fprem1
public Mnemonic Fptan
public Mnemonic Frndint
public Mnemonic Frstor
public Mnemonic Frstpm
public Mnemonic Fsave
public Mnemonic Fscale
public Mnemonic Fsetpm
public Mnemonic Fsin
public Mnemonic Fsincos
public Mnemonic Fsqrt
public Mnemonic Fst
public Mnemonic Fstcw
public Mnemonic Fstdw
public Mnemonic Fstenv
public Mnemonic Fstp
public Mnemonic Fstpnce
public Mnemonic Fstsg
public Mnemonic Fstsw
public Mnemonic Fsub
public Mnemonic Fsubp
public Mnemonic Fsubr
public Mnemonic Fsubrp
public Mnemonic Ftst
public Mnemonic Fucom
public Mnemonic Fucomi
public Mnemonic Fucomip
public Mnemonic Fucomp
public Mnemonic Fucompp
public Mnemonic Fxam
public Mnemonic Fxch
public Mnemonic Fxrstor
public Mnemonic Fxrstor64
public Mnemonic Fxsave
public Mnemonic Fxsave64
public Mnemonic Fxtract
public Mnemonic Fyl2x
public Mnemonic Fyl2xp1
public Mnemonic Getsec
public Mnemonic Gf2p8affineinvqb
public Mnemonic Gf2p8affineqb
public Mnemonic Gf2p8mulb
public Mnemonic Haddpd
public Mnemonic Haddps
public Mnemonic Hlt
public Mnemonic Hsubpd
public Mnemonic Hsubps
public Mnemonic Ibts
public Mnemonic Idiv
public Mnemonic Imul
public Mnemonic In
public Mnemonic Inc
public Mnemonic Incsspd
public Mnemonic Incsspq
public Mnemonic Insb
public Mnemonic Insd
public Mnemonic Insertps
public Mnemonic Insertq
public Mnemonic Insw
public Mnemonic Int
public Mnemonic Int1
public Mnemonic Into
public Mnemonic Invd
public Mnemonic Invept
public Mnemonic Invlpg
public Mnemonic Invlpga
public Mnemonic Invpcid
public Mnemonic Invvpid
public Mnemonic Iret
public Mnemonic Ja
public Mnemonic Jae
public Mnemonic Jb
public Mnemonic Jbe
public Mnemonic Jcxz
public Mnemonic Je
public Mnemonic Jecxz
public Mnemonic Jg
public Mnemonic Jge
public Mnemonic Jl
public Mnemonic Jle
public Mnemonic Jmp
public Mnemonic Jmpe
public Mnemonic Jne
public Mnemonic Jno
public Mnemonic Jnp
public Mnemonic Jns
public Mnemonic Jo
public Mnemonic Jp
public Mnemonic Jrcxz
public Mnemonic Js
public Mnemonic Kaddb
public Mnemonic Kaddd
public Mnemonic Kaddq
public Mnemonic Kaddw
public Mnemonic Kandb
public Mnemonic Kandd
public Mnemonic Kandnb
public Mnemonic Kandnd
public Mnemonic Kandnq
public Mnemonic Kandnw
public Mnemonic Kandq
public Mnemonic Kandw
public Mnemonic Kmovb
public Mnemonic Kmovd
public Mnemonic Kmovq
public Mnemonic Kmovw
public Mnemonic Knotb
public Mnemonic Knotd
public Mnemonic Knotq
public Mnemonic Knotw
public Mnemonic Korb
public Mnemonic Kord
public Mnemonic Korq
public Mnemonic Kortestb
public Mnemonic Kortestd
public Mnemonic Kortestq
public Mnemonic Kortestw
public Mnemonic Korw
public Mnemonic Kshiftlb
public Mnemonic Kshiftld
public Mnemonic Kshiftlq
public Mnemonic Kshiftlw
public Mnemonic Kshiftrb
public Mnemonic Kshiftrd
public Mnemonic Kshiftrq
public Mnemonic Kshiftrw
public Mnemonic Ktestb
public Mnemonic Ktestd
public Mnemonic Ktestq
public Mnemonic Ktestw
public Mnemonic Kunpckbw
public Mnemonic Kunpckdq
public Mnemonic Kunpckwd
public Mnemonic Kxnorb
public Mnemonic Kxnord
public Mnemonic Kxnorq
public Mnemonic Kxnorw
public Mnemonic Kxorb
public Mnemonic Kxord
public Mnemonic Kxorq
public Mnemonic Kxorw
public Mnemonic Lahf
public Mnemonic Lar
public Mnemonic Lddqu
public Mnemonic Ldmxcsr
public Mnemonic Lds
public Mnemonic Lea
public Mnemonic Leave
public Mnemonic Les
public Mnemonic Lfence
public Mnemonic Lfs
public Mnemonic Lgdt
public Mnemonic Lgs
public Mnemonic Lidt
public Mnemonic Lldt
public Mnemonic Llwpcb
public Mnemonic Lmsw
public Mnemonic Loadall
public Mnemonic Lodsb
public Mnemonic Lodsd
public Mnemonic Lodsq
public Mnemonic Lodsw
public Mnemonic Loop
public Mnemonic Loope
public Mnemonic Loopne
public Mnemonic Lsl
public Mnemonic Lss
public Mnemonic Ltr
public Mnemonic Lwpins
public Mnemonic Lwpval
public Mnemonic Lzcnt
public Mnemonic Maskmovdqu
public Mnemonic Maskmovq
public Mnemonic Maxpd
public Mnemonic Maxps
public Mnemonic Maxsd
public Mnemonic Maxss
public Mnemonic Mcommit
public Mnemonic Mfence
public Mnemonic Minpd
public Mnemonic Minps
public Mnemonic Minsd
public Mnemonic Minss
public Mnemonic Monitor
public Mnemonic Monitorx
public Mnemonic Montmul
public Mnemonic Mov
public Mnemonic Movapd
public Mnemonic Movaps
public Mnemonic Movbe
public Mnemonic Movd
public Mnemonic Movddup
public Mnemonic Movdir64b
public Mnemonic Movdiri
public Mnemonic Movdq2q
public Mnemonic Movdqa
public Mnemonic Movdqu
public Mnemonic Movhlps
public Mnemonic Movhpd
public Mnemonic Movhps
public Mnemonic Movlhps
public Mnemonic Movlpd
public Mnemonic Movlps
public Mnemonic Movmskpd
public Mnemonic Movmskps
public Mnemonic Movntdq
public Mnemonic Movntdqa
public Mnemonic Movnti
public Mnemonic Movntpd
public Mnemonic Movntps
public Mnemonic Movntq
public Mnemonic Movntsd
public Mnemonic Movntss
public Mnemonic Movq
public Mnemonic Movq2dq
public Mnemonic Movsb
public Mnemonic Movsd
public Mnemonic Movshdup
public Mnemonic Movsldup
public Mnemonic Movsq
public Mnemonic Movss
public Mnemonic Movsw
public Mnemonic Movsx
public Mnemonic Movsxd
public Mnemonic Movupd
public Mnemonic Movups
public Mnemonic Movzx
public Mnemonic Mpsadbw
public Mnemonic Mul
public Mnemonic Mulpd
public Mnemonic Mulps
public Mnemonic Mulsd
public Mnemonic Mulss
public Mnemonic Mulx
public Mnemonic Mwait
public Mnemonic Mwaitx
public Mnemonic Neg
public Mnemonic Nop
public Mnemonic Not
public Mnemonic Or
public Mnemonic Orpd
public Mnemonic Orps
public Mnemonic Out
public Mnemonic Outsb
public Mnemonic Outsd
public Mnemonic Outsw
public Mnemonic Pabsb
public Mnemonic Pabsd
public Mnemonic Pabsw
public Mnemonic Packssdw
public Mnemonic Packsswb
public Mnemonic Packusdw
public Mnemonic Packuswb
public Mnemonic Paddb
public Mnemonic Paddd
public Mnemonic Paddq
public Mnemonic Paddsb
public Mnemonic Paddsw
public Mnemonic Paddusb
public Mnemonic Paddusw
public Mnemonic Paddw
public Mnemonic Palignr
public Mnemonic Pand
public Mnemonic Pandn
public Mnemonic Pause
public Mnemonic Pavgb
public Mnemonic Pavgusb
public Mnemonic Pavgw
public Mnemonic Pblendvb
public Mnemonic Pblendw
public Mnemonic Pclmulqdq
public Mnemonic Pcmpeqb
public Mnemonic Pcmpeqd
public Mnemonic Pcmpeqq
public Mnemonic Pcmpeqw
public Mnemonic Pcmpestri
public Mnemonic Pcmpestri64
public Mnemonic Pcmpestrm
public Mnemonic Pcmpestrm64
public Mnemonic Pcmpgtb
public Mnemonic Pcmpgtd
public Mnemonic Pcmpgtq
public Mnemonic Pcmpgtw
public Mnemonic Pcmpistri
public Mnemonic Pcmpistrm
public Mnemonic Pcommit
public Mnemonic Pconfig
public Mnemonic Pdep
public Mnemonic Pext
public Mnemonic Pextrb
public Mnemonic Pextrd
public Mnemonic Pextrq
public Mnemonic Pextrw
public Mnemonic Pf2id
public Mnemonic Pf2iw
public Mnemonic Pfacc
public Mnemonic Pfadd
public Mnemonic Pfcmpeq
public Mnemonic Pfcmpge
public Mnemonic Pfcmpgt
public Mnemonic Pfmax
public Mnemonic Pfmin
public Mnemonic Pfmul
public Mnemonic Pfnacc
public Mnemonic Pfpnacc
public Mnemonic Pfrcp
public Mnemonic Pfrcpit1
public Mnemonic Pfrcpit2
public Mnemonic Pfrcpv
public Mnemonic Pfrsqit1
public Mnemonic Pfrsqrt
public Mnemonic Pfrsqrtv
public Mnemonic Pfsub
public Mnemonic Pfsubr
public Mnemonic Phaddd
public Mnemonic Phaddsw
public Mnemonic Phaddw
public Mnemonic Phminposuw
public Mnemonic Phsubd
public Mnemonic Phsubsw
public Mnemonic Phsubw
public Mnemonic Pi2fd
public Mnemonic Pi2fw
public Mnemonic Pinsrb
public Mnemonic Pinsrd
public Mnemonic Pinsrq
public Mnemonic Pinsrw
public Mnemonic Pmaddubsw
public Mnemonic Pmaddwd
public Mnemonic Pmaxsb
public Mnemonic Pmaxsd
public Mnemonic Pmaxsw
public Mnemonic Pmaxub
public Mnemonic Pmaxud
public Mnemonic Pmaxuw
public Mnemonic Pminsb
public Mnemonic Pminsd
public Mnemonic Pminsw
public Mnemonic Pminub
public Mnemonic Pminud
public Mnemonic Pminuw
public Mnemonic Pmovmskb
public Mnemonic Pmovsxbd
public Mnemonic Pmovsxbq
public Mnemonic Pmovsxbw
public Mnemonic Pmovsxdq
public Mnemonic Pmovsxwd
public Mnemonic Pmovsxwq
public Mnemonic Pmovzxbd
public Mnemonic Pmovzxbq
public Mnemonic Pmovzxbw
public Mnemonic Pmovzxdq
public Mnemonic Pmovzxwd
public Mnemonic Pmovzxwq
public Mnemonic Pmuldq
public Mnemonic Pmulhrsw
public Mnemonic Pmulhrw
public Mnemonic Pmulhuw
public Mnemonic Pmulhw
public Mnemonic Pmulld
public Mnemonic Pmullw
public Mnemonic Pmuludq
public Mnemonic Pop
public Mnemonic Popa
public Mnemonic Popcnt
public Mnemonic Popf
public Mnemonic Por
public Mnemonic Prefetch
public Mnemonic Prefetchnta
public Mnemonic Prefetcht0
public Mnemonic Prefetcht1
public Mnemonic Prefetcht2
public Mnemonic Prefetchw
public Mnemonic Prefetchwt1
public Mnemonic Psadbw
public Mnemonic Pshufb
public Mnemonic Pshufd
public Mnemonic Pshufhw
public Mnemonic Pshuflw
public Mnemonic Pshufw
public Mnemonic Psignb
public Mnemonic Psignd
public Mnemonic Psignw
public Mnemonic Pslld
public Mnemonic Pslldq
public Mnemonic Psllq
public Mnemonic Psllw
public Mnemonic Psrad
public Mnemonic Psraw
public Mnemonic Psrld
public Mnemonic Psrldq
public Mnemonic Psrlq
public Mnemonic Psrlw
public Mnemonic Psubb
public Mnemonic Psubd
public Mnemonic Psubq
public Mnemonic Psubsb
public Mnemonic Psubsw
public Mnemonic Psubusb
public Mnemonic Psubusw
public Mnemonic Psubw
public Mnemonic Pswapd
public Mnemonic Ptest
public Mnemonic Ptwrite
public Mnemonic Punpckhbw
public Mnemonic Punpckhdq
public Mnemonic Punpckhqdq
public Mnemonic Punpckhwd
public Mnemonic Punpcklbw
public Mnemonic Punpckldq
public Mnemonic Punpcklqdq
public Mnemonic Punpcklwd
public Mnemonic Push
public Mnemonic Pusha
public Mnemonic Pushf
public Mnemonic Pxor
public Mnemonic Rcl
public Mnemonic Rcpps
public Mnemonic Rcpss
public Mnemonic Rcr
public Mnemonic Rdfsbase
public Mnemonic Rdgsbase
public Mnemonic Rdmsr
public Mnemonic Rdpid
public Mnemonic Rdpkru
public Mnemonic Rdpmc
public Mnemonic Rdpru
public Mnemonic Rdrand
public Mnemonic Rdseed
public Mnemonic Rdsspd
public Mnemonic Rdsspq
public Mnemonic Rdtsc
public Mnemonic Rdtscp
public Mnemonic Reservednop
public Mnemonic Ret
public Mnemonic Retf
public Mnemonic Rol
public Mnemonic Ror
public Mnemonic Rorx
public Mnemonic Roundpd
public Mnemonic Roundps
public Mnemonic Roundsd
public Mnemonic Roundss
public Mnemonic Rsm
public Mnemonic Rsqrtps
public Mnemonic Rsqrtss
public Mnemonic Rstorssp
public Mnemonic Sahf
public Mnemonic Sal
public Mnemonic Salc
public Mnemonic Sar
public Mnemonic Sarx
public Mnemonic Saveprevssp
public Mnemonic Sbb
public Mnemonic Scasb
public Mnemonic Scasd
public Mnemonic Scasq
public Mnemonic Scasw
public Mnemonic Seta
public Mnemonic Setae
public Mnemonic Setb
public Mnemonic Setbe
public Mnemonic Sete
public Mnemonic Setg
public Mnemonic Setge
public Mnemonic Setl
public Mnemonic Setle
public Mnemonic Setne
public Mnemonic Setno
public Mnemonic Setnp
public Mnemonic Setns
public Mnemonic Seto
public Mnemonic Setp
public Mnemonic Sets
public Mnemonic Setssbsy
public Mnemonic Sfence
public Mnemonic Sgdt
public Mnemonic Sha1msg1
public Mnemonic Sha1msg2
public Mnemonic Sha1nexte
public Mnemonic Sha1rnds4
public Mnemonic Sha256msg1
public Mnemonic Sha256msg2
public Mnemonic Sha256rnds2
public Mnemonic Shl
public Mnemonic Shld
public Mnemonic Shlx
public Mnemonic Shr
public Mnemonic Shrd
public Mnemonic Shrx
public Mnemonic Shufpd
public Mnemonic Shufps
public Mnemonic Sidt
public Mnemonic Skinit
public Mnemonic Sldt
public Mnemonic Slwpcb
public Mnemonic Smsw
public Mnemonic Sqrtpd
public Mnemonic Sqrtps
public Mnemonic Sqrtsd
public Mnemonic Sqrtss
public Mnemonic Stac
public Mnemonic Stc
public Mnemonic Std
public Mnemonic Stgi
public Mnemonic Sti
public Mnemonic Stmxcsr
public Mnemonic Stosb
public Mnemonic Stosd
public Mnemonic Stosq
public Mnemonic Stosw
public Mnemonic Str
public Mnemonic Sub
public Mnemonic Subpd
public Mnemonic Subps
public Mnemonic Subsd
public Mnemonic Subss
public Mnemonic Swapgs
public Mnemonic Syscall
public Mnemonic Sysenter
public Mnemonic Sysexit
public Mnemonic Sysret
public Mnemonic T1mskc
public Mnemonic Test
public Mnemonic Tpause
public Mnemonic Tzcnt
public Mnemonic Tzmsk
public Mnemonic Ucomisd
public Mnemonic Ucomiss
public Mnemonic Ud0
public Mnemonic Ud1
public Mnemonic Ud2
public Mnemonic Umonitor
public Mnemonic Umov
public Mnemonic Umwait
public Mnemonic Unpckhpd
public Mnemonic Unpckhps
public Mnemonic Unpcklpd
public Mnemonic Unpcklps
public Mnemonic V4fmaddps
public Mnemonic V4fmaddss
public Mnemonic V4fnmaddps
public Mnemonic V4fnmaddss
public Mnemonic Vaddpd
public Mnemonic Vaddps
public Mnemonic Vaddsd
public Mnemonic Vaddss
public Mnemonic Vaddsubpd
public Mnemonic Vaddsubps
public Mnemonic Vaesdec
public Mnemonic Vaesdeclast
public Mnemonic Vaesenc
public Mnemonic Vaesenclast
public Mnemonic Vaesimc
public Mnemonic Vaeskeygenassist
public Mnemonic Valignd
public Mnemonic Valignq
public Mnemonic Vandnpd
public Mnemonic Vandnps
public Mnemonic Vandpd
public Mnemonic Vandps
public Mnemonic Vblendmpd
public Mnemonic Vblendmps
public Mnemonic Vblendpd
public Mnemonic Vblendps
public Mnemonic Vblendvpd
public Mnemonic Vblendvps
public Mnemonic Vbroadcastf128
public Mnemonic Vbroadcastf32x2
public Mnemonic Vbroadcastf32x4
public Mnemonic Vbroadcastf32x8
public Mnemonic Vbroadcastf64x2
public Mnemonic Vbroadcastf64x4
public Mnemonic Vbroadcasti128
public Mnemonic Vbroadcasti32x2
public Mnemonic Vbroadcasti32x4
public Mnemonic Vbroadcasti32x8
public Mnemonic Vbroadcasti64x2
public Mnemonic Vbroadcasti64x4
public Mnemonic Vbroadcastsd
public Mnemonic Vbroadcastss
public Mnemonic Vcmppd
public Mnemonic Vcmpps
public Mnemonic Vcmpsd
public Mnemonic Vcmpss
public Mnemonic Vcomisd
public Mnemonic Vcomiss
public Mnemonic Vcompresspd
public Mnemonic Vcompressps
public Mnemonic Vcvtdq2pd
public Mnemonic Vcvtdq2ps
public Mnemonic Vcvtne2ps2bf16
public Mnemonic Vcvtneps2bf16
public Mnemonic Vcvtpd2dq
public Mnemonic Vcvtpd2ps
public Mnemonic Vcvtpd2qq
public Mnemonic Vcvtpd2udq
public Mnemonic Vcvtpd2uqq
public Mnemonic Vcvtph2ps
public Mnemonic Vcvtps2dq
public Mnemonic Vcvtps2pd
public Mnemonic Vcvtps2ph
public Mnemonic Vcvtps2qq
public Mnemonic Vcvtps2udq
public Mnemonic Vcvtps2uqq
public Mnemonic Vcvtqq2pd
public Mnemonic Vcvtqq2ps
public Mnemonic Vcvtsd2si
public Mnemonic Vcvtsd2ss
public Mnemonic Vcvtsd2usi
public Mnemonic Vcvtsi2sd
public Mnemonic Vcvtsi2ss
public Mnemonic Vcvtss2sd
public Mnemonic Vcvtss2si
public Mnemonic Vcvtss2usi
public Mnemonic Vcvttpd2dq
public Mnemonic Vcvttpd2qq
public Mnemonic Vcvttpd2udq
public Mnemonic Vcvttpd2uqq
public Mnemonic Vcvttps2dq
public Mnemonic Vcvttps2qq
public Mnemonic Vcvttps2udq
public Mnemonic Vcvttps2uqq
public Mnemonic Vcvttsd2si
public Mnemonic Vcvttsd2usi
public Mnemonic Vcvttss2si
public Mnemonic Vcvttss2usi
public Mnemonic Vcvtudq2pd
public Mnemonic Vcvtudq2ps
public Mnemonic Vcvtuqq2pd
public Mnemonic Vcvtuqq2ps
public Mnemonic Vcvtusi2sd
public Mnemonic Vcvtusi2ss
public Mnemonic Vdbpsadbw
public Mnemonic Vdivpd
public Mnemonic Vdivps
public Mnemonic Vdivsd
public Mnemonic Vdivss
public Mnemonic Vdpbf16ps
public Mnemonic Vdppd
public Mnemonic Vdpps
public Mnemonic Verr
public Mnemonic Verw
public Mnemonic Vexp2pd
public Mnemonic Vexp2ps
public Mnemonic Vexpandpd
public Mnemonic Vexpandps
public Mnemonic Vextractf128
public Mnemonic Vextractf32x4
public Mnemonic Vextractf32x8
public Mnemonic Vextractf64x2
public Mnemonic Vextractf64x4
public Mnemonic Vextracti128
public Mnemonic Vextracti32x4
public Mnemonic Vextracti32x8
public Mnemonic Vextracti64x2
public Mnemonic Vextracti64x4
public Mnemonic Vextractps
public Mnemonic Vfixupimmpd
public Mnemonic Vfixupimmps
public Mnemonic Vfixupimmsd
public Mnemonic Vfixupimmss
public Mnemonic Vfmadd132pd
public Mnemonic Vfmadd132ps
public Mnemonic Vfmadd132sd
public Mnemonic Vfmadd132ss
public Mnemonic Vfmadd213pd
public Mnemonic Vfmadd213ps
public Mnemonic Vfmadd213sd
public Mnemonic Vfmadd213ss
public Mnemonic Vfmadd231pd
public Mnemonic Vfmadd231ps
public Mnemonic Vfmadd231sd
public Mnemonic Vfmadd231ss
public Mnemonic Vfmaddpd
public Mnemonic Vfmaddps
public Mnemonic Vfmaddsd
public Mnemonic Vfmaddss
public Mnemonic Vfmaddsub132pd
public Mnemonic Vfmaddsub132ps
public Mnemonic Vfmaddsub213pd
public Mnemonic Vfmaddsub213ps
public Mnemonic Vfmaddsub231pd
public Mnemonic Vfmaddsub231ps
public Mnemonic Vfmaddsubpd
public Mnemonic Vfmaddsubps
public Mnemonic Vfmsub132pd
public Mnemonic Vfmsub132ps
public Mnemonic Vfmsub132sd
public Mnemonic Vfmsub132ss
public Mnemonic Vfmsub213pd
public Mnemonic Vfmsub213ps
public Mnemonic Vfmsub213sd
public Mnemonic Vfmsub213ss
public Mnemonic Vfmsub231pd
public Mnemonic Vfmsub231ps
public Mnemonic Vfmsub231sd
public Mnemonic Vfmsub231ss
public Mnemonic Vfmsubadd132pd
public Mnemonic Vfmsubadd132ps
public Mnemonic Vfmsubadd213pd
public Mnemonic Vfmsubadd213ps
public Mnemonic Vfmsubadd231pd
public Mnemonic Vfmsubadd231ps
public Mnemonic Vfmsubaddpd
public Mnemonic Vfmsubaddps
public Mnemonic Vfmsubpd
public Mnemonic Vfmsubps
public Mnemonic Vfmsubsd
public Mnemonic Vfmsubss
public Mnemonic Vfnmadd132pd
public Mnemonic Vfnmadd132ps
public Mnemonic Vfnmadd132sd
public Mnemonic Vfnmadd132ss
public Mnemonic Vfnmadd213pd
public Mnemonic Vfnmadd213ps
public Mnemonic Vfnmadd213sd
public Mnemonic Vfnmadd213ss
public Mnemonic Vfnmadd231pd
public Mnemonic Vfnmadd231ps
public Mnemonic Vfnmadd231sd
public Mnemonic Vfnmadd231ss
public Mnemonic Vfnmaddpd
public Mnemonic Vfnmaddps
public Mnemonic Vfnmaddsd
public Mnemonic Vfnmaddss
public Mnemonic Vfnmsub132pd
public Mnemonic Vfnmsub132ps
public Mnemonic Vfnmsub132sd
public Mnemonic Vfnmsub132ss
public Mnemonic Vfnmsub213pd
public Mnemonic Vfnmsub213ps
public Mnemonic Vfnmsub213sd
public Mnemonic Vfnmsub213ss
public Mnemonic Vfnmsub231pd
public Mnemonic Vfnmsub231ps
public Mnemonic Vfnmsub231sd
public Mnemonic Vfnmsub231ss
public Mnemonic Vfnmsubpd
public Mnemonic Vfnmsubps
public Mnemonic Vfnmsubsd
public Mnemonic Vfnmsubss
public Mnemonic Vfpclasspd
public Mnemonic Vfpclassps
public Mnemonic Vfpclasssd
public Mnemonic Vfpclassss
public Mnemonic Vfrczpd
public Mnemonic Vfrczps
public Mnemonic Vfrczsd
public Mnemonic Vfrczss
public Mnemonic Vgatherdpd
public Mnemonic Vgatherdps
public Mnemonic Vgatherpf0dpd
public Mnemonic Vgatherpf0dps
public Mnemonic Vgatherpf0qpd
public Mnemonic Vgatherpf0qps
public Mnemonic Vgatherpf1dpd
public Mnemonic Vgatherpf1dps
public Mnemonic Vgatherpf1qpd
public Mnemonic Vgatherpf1qps
public Mnemonic Vgatherqpd
public Mnemonic Vgatherqps
public Mnemonic Vgetexppd
public Mnemonic Vgetexpps
public Mnemonic Vgetexpsd
public Mnemonic Vgetexpss
public Mnemonic Vgetmantpd
public Mnemonic Vgetmantps
public Mnemonic Vgetmantsd
public Mnemonic Vgetmantss
public Mnemonic Vgf2p8affineinvqb
public Mnemonic Vgf2p8affineqb
public Mnemonic Vgf2p8mulb
public Mnemonic Vhaddpd
public Mnemonic Vhaddps
public Mnemonic Vhsubpd
public Mnemonic Vhsubps
public Mnemonic Vinsertf128
public Mnemonic Vinsertf32x4
public Mnemonic Vinsertf32x8
public Mnemonic Vinsertf64x2
public Mnemonic Vinsertf64x4
public Mnemonic Vinserti128
public Mnemonic Vinserti32x4
public Mnemonic Vinserti32x8
public Mnemonic Vinserti64x2
public Mnemonic Vinserti64x4
public Mnemonic Vinsertps
public Mnemonic Vlddqu
public Mnemonic Vldmxcsr
public Mnemonic Vmaskmovdqu
public Mnemonic Vmaskmovpd
public Mnemonic Vmaskmovps
public Mnemonic Vmaxpd
public Mnemonic Vmaxps
public Mnemonic Vmaxsd
public Mnemonic Vmaxss
public Mnemonic Vmcall
public Mnemonic Vmclear
public Mnemonic Vmfunc
public Mnemonic Vminpd
public Mnemonic Vminps
public Mnemonic Vminsd
public Mnemonic Vminss
public Mnemonic Vmlaunch
public Mnemonic Vmload
public Mnemonic Vmmcall
public Mnemonic Vmovapd
public Mnemonic Vmovaps
public Mnemonic Vmovd
public Mnemonic Vmovddup
public Mnemonic Vmovdqa
public Mnemonic Vmovdqa32
public Mnemonic Vmovdqa64
public Mnemonic Vmovdqu
public Mnemonic Vmovdqu16
public Mnemonic Vmovdqu32
public Mnemonic Vmovdqu64
public Mnemonic Vmovdqu8
public Mnemonic Vmovhlps
public Mnemonic Vmovhpd
public Mnemonic Vmovhps
public Mnemonic Vmovlhps
public Mnemonic Vmovlpd
public Mnemonic Vmovlps
public Mnemonic Vmovmskpd
public Mnemonic Vmovmskps
public Mnemonic Vmovntdq
public Mnemonic Vmovntdqa
public Mnemonic Vmovntpd
public Mnemonic Vmovntps
public Mnemonic Vmovq
public Mnemonic Vmovsd
public Mnemonic Vmovshdup
public Mnemonic Vmovsldup
public Mnemonic Vmovss
public Mnemonic Vmovupd
public Mnemonic Vmovups
public Mnemonic Vmpsadbw
public Mnemonic Vmptrld
public Mnemonic Vmptrst
public Mnemonic Vmread
public Mnemonic Vmresume
public Mnemonic Vmrun
public Mnemonic Vmsave
public Mnemonic Vmulpd
public Mnemonic Vmulps
public Mnemonic Vmulsd
public Mnemonic Vmulss
public Mnemonic Vmwrite
public Mnemonic Vmxoff
public Mnemonic Vmxon
public Mnemonic Vorpd
public Mnemonic Vorps
public Mnemonic Vp2intersectd
public Mnemonic Vp2intersectq
public Mnemonic Vp4dpwssd
public Mnemonic Vp4dpwssds
public Mnemonic Vpabsb
public Mnemonic Vpabsd
public Mnemonic Vpabsq
public Mnemonic Vpabsw
public Mnemonic Vpackssdw
public Mnemonic Vpacksswb
public Mnemonic Vpackusdw
public Mnemonic Vpackuswb
public Mnemonic Vpaddb
public Mnemonic Vpaddd
public Mnemonic Vpaddq
public Mnemonic Vpaddsb
public Mnemonic Vpaddsw
public Mnemonic Vpaddusb
public Mnemonic Vpaddusw
public Mnemonic Vpaddw
public Mnemonic Vpalignr
public Mnemonic Vpand
public Mnemonic Vpandd
public Mnemonic Vpandn
public Mnemonic Vpandnd
public Mnemonic Vpandnq
public Mnemonic Vpandq
public Mnemonic Vpavgb
public Mnemonic Vpavgw
public Mnemonic Vpblendd
public Mnemonic Vpblendmb
public Mnemonic Vpblendmd
public Mnemonic Vpblendmq
public Mnemonic Vpblendmw
public Mnemonic Vpblendvb
public Mnemonic Vpblendw
public Mnemonic Vpbroadcastb
public Mnemonic Vpbroadcastd
public Mnemonic Vpbroadcastmb2q
public Mnemonic Vpbroadcastmw2d
public Mnemonic Vpbroadcastq
public Mnemonic Vpbroadcastw
public Mnemonic Vpclmulqdq
public Mnemonic Vpcmov
public Mnemonic Vpcmpb
public Mnemonic Vpcmpd
public Mnemonic Vpcmpeqb
public Mnemonic Vpcmpeqd
public Mnemonic Vpcmpeqq
public Mnemonic Vpcmpeqw
public Mnemonic Vpcmpestri
public Mnemonic Vpcmpestri64
public Mnemonic Vpcmpestrm
public Mnemonic Vpcmpestrm64
public Mnemonic Vpcmpgtb
public Mnemonic Vpcmpgtd
public Mnemonic Vpcmpgtq
public Mnemonic Vpcmpgtw
public Mnemonic Vpcmpistri
public Mnemonic Vpcmpistrm
public Mnemonic Vpcmpq
public Mnemonic Vpcmpub
public Mnemonic Vpcmpud
public Mnemonic Vpcmpuq
public Mnemonic Vpcmpuw
public Mnemonic Vpcmpw
public Mnemonic Vpcomb
public Mnemonic Vpcomd
public Mnemonic Vpcompressb
public Mnemonic Vpcompressd
public Mnemonic Vpcompressq
public Mnemonic Vpcompressw
public Mnemonic Vpcomq
public Mnemonic Vpcomub
public Mnemonic Vpcomud
public Mnemonic Vpcomuq
public Mnemonic Vpcomuw
public Mnemonic Vpcomw
public Mnemonic Vpconflictd
public Mnemonic Vpconflictq
public Mnemonic Vpdpbusd
public Mnemonic Vpdpbusds
public Mnemonic Vpdpwssd
public Mnemonic Vpdpwssds
public Mnemonic Vperm2f128
public Mnemonic Vperm2i128
public Mnemonic Vpermb
public Mnemonic Vpermd
public Mnemonic Vpermi2b
public Mnemonic Vpermi2d
public Mnemonic Vpermi2pd
public Mnemonic Vpermi2ps
public Mnemonic Vpermi2q
public Mnemonic Vpermi2w
public Mnemonic Vpermil2pd
public Mnemonic Vpermil2ps
public Mnemonic Vpermilpd
public Mnemonic Vpermilps
public Mnemonic Vpermpd
public Mnemonic Vpermps
public Mnemonic Vpermq
public Mnemonic Vpermt2b
public Mnemonic Vpermt2d
public Mnemonic Vpermt2pd
public Mnemonic Vpermt2ps
public Mnemonic Vpermt2q
public Mnemonic Vpermt2w
public Mnemonic Vpermw
public Mnemonic Vpexpandb
public Mnemonic Vpexpandd
public Mnemonic Vpexpandq
public Mnemonic Vpexpandw
public Mnemonic Vpextrb
public Mnemonic Vpextrd
public Mnemonic Vpextrq
public Mnemonic Vpextrw
public Mnemonic Vpgatherdd
public Mnemonic Vpgatherdq
public Mnemonic Vpgatherqd
public Mnemonic Vpgatherqq
public Mnemonic Vphaddbd
public Mnemonic Vphaddbq
public Mnemonic Vphaddbw
public Mnemonic Vphaddd
public Mnemonic Vphadddq
public Mnemonic Vphaddsw
public Mnemonic Vphaddubd
public Mnemonic Vphaddubq
public Mnemonic Vphaddubw
public Mnemonic Vphaddudq
public Mnemonic Vphadduwd
public Mnemonic Vphadduwq
public Mnemonic Vphaddw
public Mnemonic Vphaddwd
public Mnemonic Vphaddwq
public Mnemonic Vphminposuw
public Mnemonic Vphsubbw
public Mnemonic Vphsubd
public Mnemonic Vphsubdq
public Mnemonic Vphsubsw
public Mnemonic Vphsubw
public Mnemonic Vphsubwd
public Mnemonic Vpinsrb
public Mnemonic Vpinsrd
public Mnemonic Vpinsrq
public Mnemonic Vpinsrw
public Mnemonic Vplzcntd
public Mnemonic Vplzcntq
public Mnemonic Vpmacsdd
public Mnemonic Vpmacsdqh
public Mnemonic Vpmacsdql
public Mnemonic Vpmacssdd
public Mnemonic Vpmacssdqh
public Mnemonic Vpmacssdql
public Mnemonic Vpmacsswd
public Mnemonic Vpmacssww
public Mnemonic Vpmacswd
public Mnemonic Vpmacsww
public Mnemonic Vpmadcsswd
public Mnemonic Vpmadcswd
public Mnemonic Vpmadd52huq
public Mnemonic Vpmadd52luq
public Mnemonic Vpmaddubsw
public Mnemonic Vpmaddwd
public Mnemonic Vpmaskmovd
public Mnemonic Vpmaskmovq
public Mnemonic Vpmaxsb
public Mnemonic Vpmaxsd
public Mnemonic Vpmaxsq
public Mnemonic Vpmaxsw
public Mnemonic Vpmaxub
public Mnemonic Vpmaxud
public Mnemonic Vpmaxuq
public Mnemonic Vpmaxuw
public Mnemonic Vpminsb
public Mnemonic Vpminsd
public Mnemonic Vpminsq
public Mnemonic Vpminsw
public Mnemonic Vpminub
public Mnemonic Vpminud
public Mnemonic Vpminuq
public Mnemonic Vpminuw
public Mnemonic Vpmovb2m
public Mnemonic Vpmovd2m
public Mnemonic Vpmovdb
public Mnemonic Vpmovdw
public Mnemonic Vpmovm2b
public Mnemonic Vpmovm2d
public Mnemonic Vpmovm2q
public Mnemonic Vpmovm2w
public Mnemonic Vpmovmskb
public Mnemonic Vpmovq2m
public Mnemonic Vpmovqb
public Mnemonic Vpmovqd
public Mnemonic Vpmovqw
public Mnemonic Vpmovsdb
public Mnemonic Vpmovsdw
public Mnemonic Vpmovsqb
public Mnemonic Vpmovsqd
public Mnemonic Vpmovsqw
public Mnemonic Vpmovswb
public Mnemonic Vpmovsxbd
public Mnemonic Vpmovsxbq
public Mnemonic Vpmovsxbw
public Mnemonic Vpmovsxdq
public Mnemonic Vpmovsxwd
public Mnemonic Vpmovsxwq
public Mnemonic Vpmovusdb
public Mnemonic Vpmovusdw
public Mnemonic Vpmovusqb
public Mnemonic Vpmovusqd
public Mnemonic Vpmovusqw
public Mnemonic Vpmovuswb
public Mnemonic Vpmovw2m
public Mnemonic Vpmovwb
public Mnemonic Vpmovzxbd
public Mnemonic Vpmovzxbq
public Mnemonic Vpmovzxbw
public Mnemonic Vpmovzxdq
public Mnemonic Vpmovzxwd
public Mnemonic Vpmovzxwq
public Mnemonic Vpmuldq
public Mnemonic Vpmulhrsw
public Mnemonic Vpmulhuw
public Mnemonic Vpmulhw
public Mnemonic Vpmulld
public Mnemonic Vpmullq
public Mnemonic Vpmullw
public Mnemonic Vpmultishiftqb
public Mnemonic Vpmuludq
public Mnemonic Vpopcntb
public Mnemonic Vpopcntd
public Mnemonic Vpopcntq
public Mnemonic Vpopcntw
public Mnemonic Vpor
public Mnemonic Vpord
public Mnemonic Vporq
public Mnemonic Vpperm
public Mnemonic Vprold
public Mnemonic Vprolq
public Mnemonic Vprolvd
public Mnemonic Vprolvq
public Mnemonic Vprord
public Mnemonic Vprorq
public Mnemonic Vprorvd
public Mnemonic Vprorvq
public Mnemonic Vprotb
public Mnemonic Vprotd
public Mnemonic Vprotq
public Mnemonic Vprotw
public Mnemonic Vpsadbw
public Mnemonic Vpscatterdd
public Mnemonic Vpscatterdq
public Mnemonic Vpscatterqd
public Mnemonic Vpscatterqq
public Mnemonic Vpshab
public Mnemonic Vpshad
public Mnemonic Vpshaq
public Mnemonic Vpshaw
public Mnemonic Vpshlb
public Mnemonic Vpshld
public Mnemonic Vpshldd
public Mnemonic Vpshldq
public Mnemonic Vpshldvd
public Mnemonic Vpshldvq
public Mnemonic Vpshldvw
public Mnemonic Vpshldw
public Mnemonic Vpshlq
public Mnemonic Vpshlw
public Mnemonic Vpshrdd
public Mnemonic Vpshrdq
public Mnemonic Vpshrdvd
public Mnemonic Vpshrdvq
public Mnemonic Vpshrdvw
public Mnemonic Vpshrdw
public Mnemonic Vpshufb
public Mnemonic Vpshufbitqmb
public Mnemonic Vpshufd
public Mnemonic Vpshufhw
public Mnemonic Vpshuflw
public Mnemonic Vpsignb
public Mnemonic Vpsignd
public Mnemonic Vpsignw
public Mnemonic Vpslld
public Mnemonic Vpslldq
public Mnemonic Vpsllq
public Mnemonic Vpsllvd
public Mnemonic Vpsllvq
public Mnemonic Vpsllvw
public Mnemonic Vpsllw
public Mnemonic Vpsrad
public Mnemonic Vpsraq
public Mnemonic Vpsravd
public Mnemonic Vpsravq
public Mnemonic Vpsravw
public Mnemonic Vpsraw
public Mnemonic Vpsrld
public Mnemonic Vpsrldq
public Mnemonic Vpsrlq
public Mnemonic Vpsrlvd
public Mnemonic Vpsrlvq
public Mnemonic Vpsrlvw
public Mnemonic Vpsrlw
public Mnemonic Vpsubb
public Mnemonic Vpsubd
public Mnemonic Vpsubq
public Mnemonic Vpsubsb
public Mnemonic Vpsubsw
public Mnemonic Vpsubusb
public Mnemonic Vpsubusw
public Mnemonic Vpsubw
public Mnemonic Vpternlogd
public Mnemonic Vpternlogq
public Mnemonic Vptest
public Mnemonic Vptestmb
public Mnemonic Vptestmd
public Mnemonic Vptestmq
public Mnemonic Vptestmw
public Mnemonic Vptestnmb
public Mnemonic Vptestnmd
public Mnemonic Vptestnmq
public Mnemonic Vptestnmw
public Mnemonic Vpunpckhbw
public Mnemonic Vpunpckhdq
public Mnemonic Vpunpckhqdq
public Mnemonic Vpunpckhwd
public Mnemonic Vpunpcklbw
public Mnemonic Vpunpckldq
public Mnemonic Vpunpcklqdq
public Mnemonic Vpunpcklwd
public Mnemonic Vpxor
public Mnemonic Vpxord
public Mnemonic Vpxorq
public Mnemonic Vrangepd
public Mnemonic Vrangeps
public Mnemonic Vrangesd
public Mnemonic Vrangess
public Mnemonic Vrcp14pd
public Mnemonic Vrcp14ps
public Mnemonic Vrcp14sd
public Mnemonic Vrcp14ss
public Mnemonic Vrcp28pd
public Mnemonic Vrcp28ps
public Mnemonic Vrcp28sd
public Mnemonic Vrcp28ss
public Mnemonic Vrcpps
public Mnemonic Vrcpss
public Mnemonic Vreducepd
public Mnemonic Vreduceps
public Mnemonic Vreducesd
public Mnemonic Vreducess
public Mnemonic Vrndscalepd
public Mnemonic Vrndscaleps
public Mnemonic Vrndscalesd
public Mnemonic Vrndscaless
public Mnemonic Vroundpd
public Mnemonic Vroundps
public Mnemonic Vroundsd
public Mnemonic Vroundss
public Mnemonic Vrsqrt14pd
public Mnemonic Vrsqrt14ps
public Mnemonic Vrsqrt14sd
public Mnemonic Vrsqrt14ss
public Mnemonic Vrsqrt28pd
public Mnemonic Vrsqrt28ps
public Mnemonic Vrsqrt28sd
public Mnemonic Vrsqrt28ss
public Mnemonic Vrsqrtps
public Mnemonic Vrsqrtss
public Mnemonic Vscalefpd
public Mnemonic Vscalefps
public Mnemonic Vscalefsd
public Mnemonic Vscalefss
public Mnemonic Vscatterdpd
public Mnemonic Vscatterdps
public Mnemonic Vscatterpf0dpd
public Mnemonic Vscatterpf0dps
public Mnemonic Vscatterpf0qpd
public Mnemonic Vscatterpf0qps
public Mnemonic Vscatterpf1dpd
public Mnemonic Vscatterpf1dps
public Mnemonic Vscatterpf1qpd
public Mnemonic Vscatterpf1qps
public Mnemonic Vscatterqpd
public Mnemonic Vscatterqps
public Mnemonic Vshuff32x4
public Mnemonic Vshuff64x2
public Mnemonic Vshufi32x4
public Mnemonic Vshufi64x2
public Mnemonic Vshufpd
public Mnemonic Vshufps
public Mnemonic Vsqrtpd
public Mnemonic Vsqrtps
public Mnemonic Vsqrtsd
public Mnemonic Vsqrtss
public Mnemonic Vstmxcsr
public Mnemonic Vsubpd
public Mnemonic Vsubps
public Mnemonic Vsubsd
public Mnemonic Vsubss
public Mnemonic Vtestpd
public Mnemonic Vtestps
public Mnemonic Vucomisd
public Mnemonic Vucomiss
public Mnemonic Vunpckhpd
public Mnemonic Vunpckhps
public Mnemonic Vunpcklpd
public Mnemonic Vunpcklps
public Mnemonic Vxorpd
public Mnemonic Vxorps
public Mnemonic Vzeroall
public Mnemonic Vzeroupper
public Mnemonic Wait
public Mnemonic Wbinvd
public Mnemonic Wbnoinvd
public Mnemonic Wrfsbase
public Mnemonic Wrgsbase
public Mnemonic Wrmsr
public Mnemonic Wrpkru
public Mnemonic Wrssd
public Mnemonic Wrssq
public Mnemonic Wrussd
public Mnemonic Wrussq
public Mnemonic Xabort
public Mnemonic Xadd
public Mnemonic Xbegin
public Mnemonic Xbts
public Mnemonic Xchg
public Mnemonic Xcryptcbc
public Mnemonic Xcryptcfb
public Mnemonic Xcryptctr
public Mnemonic Xcryptecb
public Mnemonic Xcryptofb
public Mnemonic Xend
public Mnemonic Xgetbv
public Mnemonic Xlatb
public Mnemonic Xor
public Mnemonic Xorpd
public Mnemonic Xorps
public Mnemonic Xrstor
public Mnemonic Xrstor64
public Mnemonic Xrstors
public Mnemonic Xrstors64
public Mnemonic Xsave
public Mnemonic Xsave64
public Mnemonic Xsavec
public Mnemonic Xsavec64
public Mnemonic Xsaveopt
public Mnemonic Xsaveopt64
public Mnemonic Xsaves
public Mnemonic Xsaves64
public Mnemonic Xsetbv
public Mnemonic Xsha1
public Mnemonic Xsha256
public Mnemonic Xstore
public Mnemonic Xtest
public Mnemonic Rmpadjust
public Mnemonic Rmpupdate
public Mnemonic Psmash
public Mnemonic Pvalidate
public Mnemonic Serialize
public Mnemonic Xsusldtrk
public Mnemonic Xresldtrk
public Mnemonic Invlpgb
public Mnemonic Tlbsync
public Mnemonic Vmgexit
public Mnemonic Getsecq
public Mnemonic Sysexitq
public Mnemonic Ldtilecfg
public Mnemonic Tilerelease
public Mnemonic Sttilecfg
public Mnemonic Tilezero
public Mnemonic Tileloaddt1
public Mnemonic Tilestored
public Mnemonic Tileloadd
public Mnemonic Tdpbf16ps
public Mnemonic Tdpbuud
public Mnemonic Tdpbusd
public Mnemonic Tdpbsud
public Mnemonic Tdpbssd
public Mnemonic Sysretq
public Mnemonic Fnstdw
public Mnemonic Fnstsg
public Mnemonic Rdshr
public Mnemonic Wrshr
public Mnemonic Smint
public Mnemonic Dmint
public Mnemonic Rdm
public Mnemonic Svdc
public Mnemonic Rsdc
public Mnemonic Svldt
public Mnemonic Rsldt
public Mnemonic Svts
public Mnemonic Rsts
public Mnemonic Bb0_reset
public Mnemonic Bb1_reset
public Mnemonic Cpu_write
public Mnemonic Cpu_read
public Mnemonic Altinst
public Mnemonic Paveb
public Mnemonic Paddsiw
public Mnemonic Pmagw
public Mnemonic Pdistib
public Mnemonic Psubsiw
public Mnemonic Pmvzb
public Mnemonic Pmvnzb
public Mnemonic Pmvlzb
public Mnemonic Pmvgezb
public Mnemonic Pmulhriw
public Mnemonic Pmachriw
public Mnemonic Ftstp
public Mnemonic Frint2
public Mnemonic Frichop
public Mnemonic Frinear
public Mnemonic Undoc
public Mnemonic Tdcall
public Mnemonic Seamret
public Mnemonic Seamops
public Mnemonic Seamcall
public Mnemonic Aesencwide128kl
public Mnemonic Aesdecwide128kl
public Mnemonic Aesencwide256kl
public Mnemonic Aesdecwide256kl
public Mnemonic Loadiwkey
public Mnemonic Aesenc128kl
public Mnemonic Aesdec128kl
public Mnemonic Aesenc256kl
public Mnemonic Aesdec256kl
public Mnemonic Encodekey128
public Mnemonic Encodekey256
public Mnemonic Pushad
public Mnemonic Popad
public Mnemonic Pushfd
public Mnemonic Pushfq
public Mnemonic Popfd
public Mnemonic Popfq
public Mnemonic Iretd
public Mnemonic Iretq
public Mnemonic Int3
public Mnemonic Uiret
public Mnemonic Testui
public Mnemonic Clui
public Mnemonic Stui
public Mnemonic Senduipi
public Mnemonic Hreset
public Mnemonic Ccs_hash
public Mnemonic Ccs_encrypt
public Mnemonic Lkgs
public Mnemonic Eretu
public Mnemonic Erets
public Mnemonic Storeall
public Mnemonic Vaddph
public Mnemonic Vaddsh
public Mnemonic Vcmpph
public Mnemonic Vcmpsh
public Mnemonic Vcomish
public Mnemonic Vcvtdq2ph
public Mnemonic Vcvtpd2ph
public Mnemonic Vcvtph2dq
public Mnemonic Vcvtph2pd
public Mnemonic Vcvtph2psx
public Mnemonic Vcvtph2qq
public Mnemonic Vcvtph2udq
public Mnemonic Vcvtph2uqq
public Mnemonic Vcvtph2uw
public Mnemonic Vcvtph2w
public Mnemonic Vcvtps2phx
public Mnemonic Vcvtqq2ph
public Mnemonic Vcvtsd2sh
public Mnemonic Vcvtsh2sd
public Mnemonic Vcvtsh2si
public Mnemonic Vcvtsh2ss
public Mnemonic Vcvtsh2usi
public Mnemonic Vcvtsi2sh
public Mnemonic Vcvtss2sh
public Mnemonic Vcvttph2dq
public Mnemonic Vcvttph2qq
public Mnemonic Vcvttph2udq
public Mnemonic Vcvttph2uqq
public Mnemonic Vcvttph2uw
public Mnemonic Vcvttph2w
public Mnemonic Vcvttsh2si
public Mnemonic Vcvttsh2usi
public Mnemonic Vcvtudq2ph
public Mnemonic Vcvtuqq2ph
public Mnemonic Vcvtusi2sh
public Mnemonic Vcvtuw2ph
public Mnemonic Vcvtw2ph
public Mnemonic Vdivph
public Mnemonic Vdivsh
public Mnemonic Vfcmaddcph
public Mnemonic Vfmaddcph
public Mnemonic Vfcmaddcsh
public Mnemonic Vfmaddcsh
public Mnemonic Vfcmulcph
public Mnemonic Vfmulcph
public Mnemonic Vfcmulcsh
public Mnemonic Vfmulcsh
public Mnemonic Vfmaddsub132ph
public Mnemonic Vfmaddsub213ph
public Mnemonic Vfmaddsub231ph
public Mnemonic Vfmsubadd132ph
public Mnemonic Vfmsubadd213ph
public Mnemonic Vfmsubadd231ph
public Mnemonic Vfmadd132ph
public Mnemonic Vfmadd213ph
public Mnemonic Vfmadd231ph
public Mnemonic Vfnmadd132ph
public Mnemonic Vfnmadd213ph
public Mnemonic Vfnmadd231ph
public Mnemonic Vfmadd132sh
public Mnemonic Vfmadd213sh
public Mnemonic Vfmadd231sh
public Mnemonic Vfnmadd132sh
public Mnemonic Vfnmadd213sh
public Mnemonic Vfnmadd231sh
public Mnemonic Vfmsub132ph
public Mnemonic Vfmsub213ph
public Mnemonic Vfmsub231ph
public Mnemonic Vfnmsub132ph
public Mnemonic Vfnmsub213ph
public Mnemonic Vfnmsub231ph
public Mnemonic Vfmsub132sh
public Mnemonic Vfmsub213sh
public Mnemonic Vfmsub231sh
public Mnemonic Vfnmsub132sh
public Mnemonic Vfnmsub213sh
public Mnemonic Vfnmsub231sh
public Mnemonic Vfpclassph
public Mnemonic Vfpclasssh
public Mnemonic Vgetexpph
public Mnemonic Vgetexpsh
public Mnemonic Vgetmantph
public Mnemonic Vgetmantsh
public Mnemonic Vmaxph
public Mnemonic Vmaxsh
public Mnemonic Vminph
public Mnemonic Vminsh
public Mnemonic Vmovsh
public Mnemonic Vmovw
public Mnemonic Vmulph
public Mnemonic Vmulsh
public Mnemonic Vrcpph
public Mnemonic Vrcpsh
public Mnemonic Vreduceph
public Mnemonic Vreducesh
public Mnemonic Vrndscaleph
public Mnemonic Vrndscalesh
public Mnemonic Vrsqrtph
public Mnemonic Vrsqrtsh
public Mnemonic Vscalefph
public Mnemonic Vscalefsh
public Mnemonic Vsqrtph
public Mnemonic Vsqrtsh
public Mnemonic Vsubph
public Mnemonic Vsubsh
public Mnemonic Vucomish
public Mnemonic Rdudbg
public Mnemonic Wrudbg
public Mnemonic Clevict0
public Mnemonic Clevict1
public Mnemonic Delay
public Mnemonic Jknzd
public Mnemonic Jkzd
public Mnemonic Kand
public Mnemonic Kandn
public Mnemonic Kandnr
public Mnemonic Kconcath
public Mnemonic Kconcatl
public Mnemonic Kextract
public Mnemonic Kmerge2l1h
public Mnemonic Kmerge2l1l
public Mnemonic Kmov
public Mnemonic Knot
public Mnemonic Kor
public Mnemonic Kortest
public Mnemonic Kxnor
public Mnemonic Kxor
public Mnemonic Spflt
public Mnemonic Tzcnti
public Mnemonic Vaddnpd
public Mnemonic Vaddnps
public Mnemonic Vaddsetsps
public Mnemonic Vcvtfxpntdq2ps
public Mnemonic Vcvtfxpntpd2dq
public Mnemonic Vcvtfxpntpd2udq
public Mnemonic Vcvtfxpntps2dq
public Mnemonic Vcvtfxpntps2udq
public Mnemonic Vcvtfxpntudq2ps
public Mnemonic Vexp223ps
public Mnemonic Vfixupnanpd
public Mnemonic Vfixupnanps
public Mnemonic Vfmadd233ps
public Mnemonic Vgatherpf0hintdpd
public Mnemonic Vgatherpf0hintdps
public Mnemonic Vgmaxabsps
public Mnemonic Vgmaxpd
public Mnemonic Vgmaxps
public Mnemonic Vgminpd
public Mnemonic Vgminps
public Mnemonic Vloadunpackhd
public Mnemonic Vloadunpackhpd
public Mnemonic Vloadunpackhps
public Mnemonic Vloadunpackhq
public Mnemonic Vloadunpackld
public Mnemonic Vloadunpacklpd
public Mnemonic Vloadunpacklps
public Mnemonic Vloadunpacklq
public Mnemonic Vlog2ps
public Mnemonic Vmovnrapd
public Mnemonic Vmovnraps
public Mnemonic Vmovnrngoapd
public Mnemonic Vmovnrngoaps
public Mnemonic Vpackstorehd
public Mnemonic Vpackstorehpd
public Mnemonic Vpackstorehps
public Mnemonic Vpackstorehq
public Mnemonic Vpackstoreld
public Mnemonic Vpackstorelpd
public Mnemonic Vpackstorelps
public Mnemonic Vpackstorelq
public Mnemonic Vpadcd
public Mnemonic Vpaddsetcd
public Mnemonic Vpaddsetsd
public Mnemonic Vpcmpltd
public Mnemonic Vpermf32x4
public Mnemonic Vpmadd231d
public Mnemonic Vpmadd233d
public Mnemonic Vpmulhd
public Mnemonic Vpmulhud
public Mnemonic Vprefetch0
public Mnemonic Vprefetch1
public Mnemonic Vprefetch2
public Mnemonic Vprefetche0
public Mnemonic Vprefetche1
public Mnemonic Vprefetche2
public Mnemonic Vprefetchenta
public Mnemonic Vprefetchnta
public Mnemonic Vpsbbd
public Mnemonic Vpsbbrd
public Mnemonic Vpsubrd
public Mnemonic Vpsubrsetbd
public Mnemonic Vpsubsetbd
public Mnemonic Vrcp23ps
public Mnemonic Vrndfxpntpd
public Mnemonic Vrndfxpntps
public Mnemonic Vrsqrt23ps
public Mnemonic Vscaleps
public Mnemonic Vscatterpf0hintdpd
public Mnemonic Vscatterpf0hintdps
public Mnemonic Vsubrpd
public Mnemonic Vsubrps
public Mnemonic Xsha512
public Mnemonic Xstore_alt
public Mnemonic Xsha512_alt
public Mnemonic Zero_bytes
}
internal Iced.Intel.MnemonicUtils : object {
public Mnemonic Mnemonic(Code code)
}
internal Iced.Intel.MnemonicUtilsData : object {
internal UInt16[] toMnemonic
}
internal Iced.Intel.OpKind : Enum {
public int value__
public OpKind Register
public OpKind NearBranch16
public OpKind NearBranch32
public OpKind NearBranch64
public OpKind FarBranch16
public OpKind FarBranch32
public OpKind Immediate8
public OpKind Immediate8_2nd
public OpKind Immediate16
public OpKind Immediate32
public OpKind Immediate64
public OpKind Immediate8to16
public OpKind Immediate8to32
public OpKind Immediate8to64
public OpKind Immediate32to64
public OpKind MemorySegSI
public OpKind MemorySegESI
public OpKind MemorySegRSI
public OpKind MemorySegDI
public OpKind MemorySegEDI
public OpKind MemorySegRDI
public OpKind MemoryESDI
public OpKind MemoryESEDI
public OpKind MemoryESRDI
public OpKind Memory
}
internal Iced.Intel.OpSize : Enum {
public byte value__
public OpSize Size16
public OpSize Size32
public OpSize Size64
}
internal Iced.Intel.Register : Enum {
public int value__
public Register None
public Register AL
public Register CL
public Register DL
public Register BL
public Register AH
public Register CH
public Register DH
public Register BH
public Register SPL
public Register BPL
public Register SIL
public Register DIL
public Register R8L
public Register R9L
public Register R10L
public Register R11L
public Register R12L
public Register R13L
public Register R14L
public Register R15L
public Register AX
public Register CX
public Register DX
public Register BX
public Register SP
public Register BP
public Register SI
public Register DI
public Register R8W
public Register R9W
public Register R10W
public Register R11W
public Register R12W
public Register R13W
public Register R14W
public Register R15W
public Register EAX
public Register ECX
public Register EDX
public Register EBX
public Register ESP
public Register EBP
public Register ESI
public Register EDI
public Register R8D
public Register R9D
public Register R10D
public Register R11D
public Register R12D
public Register R13D
public Register R14D
public Register R15D
public Register RAX
public Register RCX
public Register RDX
public Register RBX
public Register RSP
public Register RBP
public Register RSI
public Register RDI
public Register R8
public Register R9
public Register R10
public Register R11
public Register R12
public Register R13
public Register R14
public Register R15
public Register EIP
public Register RIP
public Register ES
public Register CS
public Register SS
public Register DS
public Register FS
public Register GS
public Register XMM0
public Register XMM1
public Register XMM2
public Register XMM3
public Register XMM4
public Register XMM5
public Register XMM6
public Register XMM7
public Register XMM8
public Register XMM9
public Register XMM10
public Register XMM11
public Register XMM12
public Register XMM13
public Register XMM14
public Register XMM15
public Register XMM16
public Register XMM17
public Register XMM18
public Register XMM19
public Register XMM20
public Register XMM21
public Register XMM22
public Register XMM23
public Register XMM24
public Register XMM25
public Register XMM26
public Register XMM27
public Register XMM28
public Register XMM29
public Register XMM30
public Register XMM31
public Register YMM0
public Register YMM1
public Register YMM2
public Register YMM3
public Register YMM4
public Register YMM5
public Register YMM6
public Register YMM7
public Register YMM8
public Register YMM9
public Register YMM10
public Register YMM11
public Register YMM12
public Register YMM13
public Register YMM14
public Register YMM15
public Register YMM16
public Register YMM17
public Register YMM18
public Register YMM19
public Register YMM20
public Register YMM21
public Register YMM22
public Register YMM23
public Register YMM24
public Register YMM25
public Register YMM26
public Register YMM27
public Register YMM28
public Register YMM29
public Register YMM30
public Register YMM31
public Register ZMM0
public Register ZMM1
public Register ZMM2
public Register ZMM3
public Register ZMM4
public Register ZMM5
public Register ZMM6
public Register ZMM7
public Register ZMM8
public Register ZMM9
public Register ZMM10
public Register ZMM11
public Register ZMM12
public Register ZMM13
public Register ZMM14
public Register ZMM15
public Register ZMM16
public Register ZMM17
public Register ZMM18
public Register ZMM19
public Register ZMM20
public Register ZMM21
public Register ZMM22
public Register ZMM23
public Register ZMM24
public Register ZMM25
public Register ZMM26
public Register ZMM27
public Register ZMM28
public Register ZMM29
public Register ZMM30
public Register ZMM31
public Register K0
public Register K1
public Register K2
public Register K3
public Register K4
public Register K5
public Register K6
public Register K7
public Register BND0
public Register BND1
public Register BND2
public Register BND3
public Register CR0
public Register CR1
public Register CR2
public Register CR3
public Register CR4
public Register CR5
public Register CR6
public Register CR7
public Register CR8
public Register CR9
public Register CR10
public Register CR11
public Register CR12
public Register CR13
public Register CR14
public Register CR15
public Register DR0
public Register DR1
public Register DR2
public Register DR3
public Register DR4
public Register DR5
public Register DR6
public Register DR7
public Register DR8
public Register DR9
public Register DR10
public Register DR11
public Register DR12
public Register DR13
public Register DR14
public Register DR15
public Register ST0
public Register ST1
public Register ST2
public Register ST3
public Register ST4
public Register ST5
public Register ST6
public Register ST7
public Register MM0
public Register MM1
public Register MM2
public Register MM3
public Register MM4
public Register MM5
public Register MM6
public Register MM7
public Register TR0
public Register TR1
public Register TR2
public Register TR3
public Register TR4
public Register TR5
public Register TR6
public Register TR7
public Register TMM0
public Register TMM1
public Register TMM2
public Register TMM3
public Register TMM4
public Register TMM5
public Register TMM6
public Register TMM7
public Register DontUse0
public Register DontUseFA
public Register DontUseFB
public Register DontUseFC
public Register DontUseFD
public Register DontUseFE
public Register DontUseFF
}
internal Iced.Intel.RegisterExtensions : object {
public bool IsSegmentRegister(Register register)
public bool IsGPR(Register register)
public bool IsGPR8(Register register)
public bool IsGPR16(Register register)
public bool IsGPR32(Register register)
public bool IsGPR64(Register register)
public bool IsXMM(Register register)
public bool IsYMM(Register register)
public bool IsZMM(Register register)
public bool IsIP(Register register)
public bool IsK(Register register)
public bool IsCR(Register register)
public bool IsDR(Register register)
public bool IsTR(Register register)
public bool IsST(Register register)
public bool IsBND(Register register)
public bool IsMM(Register register)
public bool IsTMM(Register register)
public bool IsVectorRegister(Register register)
}
internal Iced.Intel.RelocInfo : ValueType {
public ulong Address
public RelocKind Kind
public void .ctor(RelocKind kind, ulong address)
}
internal Iced.Intel.RelocKind : Enum {
public int value__
public RelocKind Offset64
}
internal Iced.Intel.RepPrefixKind : Enum {
public int value__
public RepPrefixKind None
public RepPrefixKind Repe
public RepPrefixKind Repne
}
internal Iced.Intel.RoundingControl : Enum {
public int value__
public RoundingControl None
public RoundingControl RoundToNearest
public RoundingControl RoundDown
public RoundingControl RoundUp
public RoundingControl RoundTowardZero
}
internal Iced.Intel.StateFlags : Enum {
public UInt32 value__
public StateFlags IpRel64
public StateFlags IpRel32
public StateFlags HasRex
public StateFlags b
public StateFlags z
public StateFlags IsInvalid
public StateFlags W
public StateFlags NoImm
public StateFlags Addr64
public StateFlags BranchImm8
public StateFlags Xbegin
public StateFlags Lock
public StateFlags AllowLock
public StateFlags NoMoreBytes
public StateFlags Has66
public StateFlags MvexSssMask
public StateFlags MvexSssShift
public StateFlags MvexEH
public StateFlags EncodingMask
public StateFlags EncodingShift
}
internal Iced.Intel.Static : object {
public void Assert(byte ignored)
}
internal Iced.Intel.StreamCodeReader : CodeReader {
public Stream Stream
public void .ctor(Stream stream)
public int ReadByte()
}
internal Iced.Intel.StreamCodeWriter : CodeWriter {
public Stream Stream
public void .ctor(Stream stream)
public void WriteByte(byte value)
}
internal Iced.Intel.ThrowHelper : object {
internal void ThrowArgumentException()
internal void ThrowInvalidOperationException()
internal void ThrowArgumentNullException_codeWriter()
internal void ThrowArgumentNullException_data()
internal void ThrowArgumentNullException_writer()
internal void ThrowArgumentNullException_options()
internal void ThrowArgumentNullException_value()
internal void ThrowArgumentNullException_list()
internal void ThrowArgumentNullException_collection()
internal void ThrowArgumentNullException_array()
internal void ThrowArgumentNullException_sb()
internal void ThrowArgumentNullException_output()
internal void ThrowArgumentOutOfRangeException_value()
internal void ThrowArgumentOutOfRangeException_index()
internal void ThrowArgumentOutOfRangeException_count()
internal void ThrowArgumentOutOfRangeException_length()
internal void ThrowArgumentOutOfRangeException_operand()
internal void ThrowArgumentOutOfRangeException_instructionOperand()
internal void ThrowArgumentOutOfRangeException_capacity()
internal void ThrowArgumentOutOfRangeException_memorySize()
internal void ThrowArgumentOutOfRangeException_size()
internal void ThrowArgumentOutOfRangeException_elementSize()
internal void ThrowArgumentOutOfRangeException_register()
internal void ThrowArgumentOutOfRangeException_code()
internal void ThrowArgumentOutOfRangeException_data()
}
internal Iced.Intel.TupleType : Enum {
public int value__
public TupleType N1
public TupleType N2
public TupleType N4
public TupleType N8
public TupleType N16
public TupleType N32
public TupleType N64
public TupleType N8b4
public TupleType N16b4
public TupleType N32b4
public TupleType N64b4
public TupleType N16b8
public TupleType N32b8
public TupleType N64b8
public TupleType N4b2
public TupleType N8b2
public TupleType N16b2
public TupleType N32b2
public TupleType N64b2
}
internal Iced.Intel.TupleTypeTable : object {
private ReadOnlySpan`1<byte> tupleTypeData
private ReadOnlySpan`1<byte> get_tupleTypeData()
public UInt32 GetDisp8N(TupleType tupleType, bool bcst)
}
internal Iced.Intel.VAGetRegisterValue : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public ulong Invoke(Register register, int elementIndex, int elementSize)
public IAsyncResult BeginInvoke(Register register, int elementIndex, int elementSize, AsyncCallback callback, object object)
public ulong EndInvoke(IAsyncResult result)
}
internal Iced.Intel.VARegisterValueProviderAdapter : object {
private IVARegisterValueProvider provider
public void .ctor(IVARegisterValueProvider provider)
public bool TryGetRegisterValue(Register register, int elementIndex, int elementSize, UInt64& value)
}
internal Iced.Intel.VARegisterValueProviderDelegateImpl : object {
private VAGetRegisterValue getRegisterValue
public void .ctor(VAGetRegisterValue getRegisterValue)
public bool TryGetRegisterValue(Register register, int elementIndex, int elementSize, UInt64& value)
}
internal Iced.Intel.VATryGetRegisterValue : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public bool Invoke(Register register, int elementIndex, int elementSize, UInt64& value)
public IAsyncResult BeginInvoke(Register register, int elementIndex, int elementSize, UInt64& value, AsyncCallback callback, object object)
public bool EndInvoke(UInt64& value, IAsyncResult result)
}
internal Iced.Intel.VATryGetRegisterValueDelegateImpl : object {
private VATryGetRegisterValue getRegisterValue
public void .ctor(VATryGetRegisterValue getRegisterValue)
public bool TryGetRegisterValue(Register register, int elementIndex, int elementSize, UInt64& value)
}
internal Iced.Intel.VectorLength : Enum {
public int value__
public VectorLength L128
public VectorLength L256
public VectorLength L512
public VectorLength Unknown
}
internal Microsoft.Cci.Pdb.AnnotationSym : ValueType {
internal UInt32 off
internal ushort seg
internal ushort csz
internal String[] rgsz
}
internal Microsoft.Cci.Pdb.AttrManyRegSym : ValueType {
internal UInt32 typind
internal UInt32 offCod
internal ushort segCod
internal ushort flags
internal byte count
internal Byte[] reg
internal string name
}
internal Microsoft.Cci.Pdb.AttrManyRegSym2 : ValueType {
internal UInt32 typind
internal UInt32 offCod
internal ushort segCod
internal ushort flags
internal ushort count
internal UInt16[] reg
internal string name
}
internal Microsoft.Cci.Pdb.AttrRegRel : ValueType {
internal UInt32 off
internal UInt32 typind
internal ushort reg
internal UInt32 offCod
internal ushort segCod
internal ushort flags
internal string name
}
internal Microsoft.Cci.Pdb.AttrRegSym : ValueType {
internal UInt32 typind
internal UInt32 offCod
internal ushort segCod
internal ushort flags
internal ushort reg
internal string name
}
internal Microsoft.Cci.Pdb.AttrSlotSym : ValueType {
internal UInt32 index
internal UInt32 typind
internal UInt32 offCod
internal ushort segCod
internal ushort flags
internal string name
}
internal Microsoft.Cci.Pdb.BitAccess : object {
private Byte[] buffer
private int offset
internal Byte[] Buffer
internal int Position
internal void .ctor(int capacity)
internal void .ctor(Byte[] buffer)
internal Byte[] get_Buffer()
internal void FillBuffer(Stream stream, int capacity)
internal void Append(Stream stream, int count)
internal int get_Position()
internal void set_Position(int value)
internal void MinCapacity(int capacity)
internal void Align(int alignment)
internal void ReadInt16(Int16& value)
internal void ReadInt8(SByte& value)
internal void ReadInt32(Int32& value)
internal void ReadInt64(Int64& value)
internal void ReadUInt16(UInt16& value)
internal void ReadUInt8(Byte& value)
internal void ReadUInt32(UInt32& value)
internal void ReadUInt64(UInt64& value)
internal void ReadInt32(Int32[] values)
internal void ReadUInt32(UInt32[] values)
internal void ReadBytes(Byte[] bytes)
internal float ReadFloat()
internal double ReadDouble()
internal decimal ReadDecimal()
internal void ReadBString(String& value)
internal string ReadBString(int len)
internal void ReadCString(String& value)
internal void SkipCString(String& value)
internal void ReadGuid(Guid& guid)
internal string ReadString()
}
internal Microsoft.Cci.Pdb.BitSet : ValueType {
private int size
private UInt32[] words
internal bool IsEmpty
internal void .ctor(BitAccess bits)
internal bool IsSet(int index)
private UInt32 GetBit(int index)
internal bool get_IsEmpty()
}
internal Microsoft.Cci.Pdb.BlockSym32 : ValueType {
internal UInt32 parent
internal UInt32 end
internal UInt32 len
internal UInt32 off
internal ushort seg
internal string name
}
internal Microsoft.Cci.Pdb.BpRelSym32 : ValueType {
internal int off
internal UInt32 typind
internal string name
}
internal Microsoft.Cci.Pdb.CallsiteInfo : ValueType {
internal int off
internal ushort ect
internal ushort pad0
internal UInt32 typind
}
internal Microsoft.Cci.Pdb.CFlagSym : ValueType {
internal byte machine
internal byte language
internal ushort flags
internal string ver
}
internal Microsoft.Cci.Pdb.CFLAGSYM_FLAGS : Enum {
public ushort value__
public CFLAGSYM_FLAGS pcode
public CFLAGSYM_FLAGS floatprec
public CFLAGSYM_FLAGS floatpkg
public CFLAGSYM_FLAGS ambdata
public CFLAGSYM_FLAGS ambcode
public CFLAGSYM_FLAGS mode32
}
internal Microsoft.Cci.Pdb.CoffGroupSym : ValueType {
internal UInt32 cb
internal UInt32 characteristics
internal UInt32 off
internal ushort seg
internal string name
}
internal Microsoft.Cci.Pdb.CompileSym : ValueType {
internal UInt32 flags
internal ushort machine
internal ushort verFEMajor
internal ushort verFEMinor
internal ushort verFEBuild
internal ushort verMajor
internal ushort verMinor
internal ushort verBuild
internal string verSt
internal String[] verArgs
}
internal Microsoft.Cci.Pdb.COMPILESYM_FLAGS : Enum {
public UInt32 value__
public COMPILESYM_FLAGS iLanguage
public COMPILESYM_FLAGS fEC
public COMPILESYM_FLAGS fNoDbgInfo
public COMPILESYM_FLAGS fLTCG
public COMPILESYM_FLAGS fNoDataAlign
public COMPILESYM_FLAGS fManagedPresent
public COMPILESYM_FLAGS fSecurityChecks
public COMPILESYM_FLAGS fHotPatch
public COMPILESYM_FLAGS fCVTCIL
public COMPILESYM_FLAGS fMSILModule
}
internal Microsoft.Cci.Pdb.ConstSym : ValueType {
internal UInt32 typind
internal ushort value
internal string name
}
internal Microsoft.Cci.Pdb.CV_CFL_CODE : Enum {
public int value__
public CV_CFL_CODE CV_CFL_CNEAR
public CV_CFL_CODE CV_CFL_CFAR
public CV_CFL_CODE CV_CFL_CHUGE
}
internal Microsoft.Cci.Pdb.CV_CFL_DATA : Enum {
public int value__
public CV_CFL_DATA CV_CFL_DNEAR
public CV_CFL_DATA CV_CFL_DFAR
public CV_CFL_DATA CV_CFL_DHUGE
}
internal Microsoft.Cci.Pdb.CV_CFL_FPKG : Enum {
public int value__
public CV_CFL_FPKG CV_CFL_NDP
public CV_CFL_FPKG CV_CFL_EMU
public CV_CFL_FPKG CV_CFL_ALT
}
internal Microsoft.Cci.Pdb.CV_Column : ValueType {
internal ushort offColumnStart
internal ushort offColumnEnd
}
internal Microsoft.Cci.Pdb.CV_cookietype : Enum {
public int value__
public CV_cookietype CV_COOKIETYPE_COPY
public CV_cookietype CV_COOKIETYPE_XOR_SP
public CV_cookietype CV_COOKIETYPE_XOR_BP
public CV_cookietype CV_COOKIETYPE_XOR_R13
}
internal Microsoft.Cci.Pdb.CV_DISCARDED : Enum {
public UInt32 value__
public CV_DISCARDED CV_DISCARDED_UNKNOWN
public CV_DISCARDED CV_DISCARDED_NOT_SELECTED
public CV_DISCARDED CV_DISCARDED_NOT_REFERENCED
}
internal Microsoft.Cci.Pdb.CV_EXPROCFLAGS : ValueType {
internal byte flags
internal byte reserved
}
internal Microsoft.Cci.Pdb.CV_FILE_CHECKSUM_TYPE : Enum {
public byte value__
public CV_FILE_CHECKSUM_TYPE None
public CV_FILE_CHECKSUM_TYPE MD5
}
internal Microsoft.Cci.Pdb.CV_FileCheckSum : ValueType {
internal UInt32 name
internal byte len
internal byte type
}
internal Microsoft.Cci.Pdb.CV_fldattr : Enum {
public int value__
public CV_fldattr access
public CV_fldattr mprop
public CV_fldattr pseudo
public CV_fldattr noinherit
public CV_fldattr noconstruct
public CV_fldattr compgenx
}
internal Microsoft.Cci.Pdb.CV_GENERIC_FLAG : Enum {
public ushort value__
public CV_GENERIC_FLAG cstyle
public CV_GENERIC_FLAG rsclean
}
internal Microsoft.Cci.Pdb.CV_GENERIC_STYLE : Enum {
public int value__
public CV_GENERIC_STYLE CV_GENERIC_VOID
public CV_GENERIC_STYLE CV_GENERIC_REG
public CV_GENERIC_STYLE CV_GENERIC_ICAN
public CV_GENERIC_STYLE CV_GENERIC_ICAF
public CV_GENERIC_STYLE CV_GENERIC_IRAN
public CV_GENERIC_STYLE CV_GENERIC_IRAF
public CV_GENERIC_STYLE CV_GENERIC_UNUSED
}
internal Microsoft.Cci.Pdb.CV_int : Enum {
public int value__
public CV_int CV_RI_CHAR
public CV_int CV_RI_INT1
public CV_int CV_RI_WCHAR
public CV_int CV_RI_UINT1
public CV_int CV_RI_INT2
public CV_int CV_RI_UINT2
public CV_int CV_RI_INT4
public CV_int CV_RI_UINT4
public CV_int CV_RI_INT8
public CV_int CV_RI_UINT8
public CV_int CV_RI_INT16
public CV_int CV_RI_UINT16
}
internal Microsoft.Cci.Pdb.CV_integral : Enum {
public int value__
public CV_integral CV_IN_1BYTE
public CV_integral CV_IN_2BYTE
public CV_integral CV_IN_4BYTE
public CV_integral CV_IN_8BYTE
public CV_integral CV_IN_16BYTE
}
internal Microsoft.Cci.Pdb.CV_LABEL_TYPE : Enum {
public int value__
public CV_LABEL_TYPE CV_LABEL_NEAR
public CV_LABEL_TYPE CV_LABEL_FAR
}
internal Microsoft.Cci.Pdb.CV_Line : ValueType {
internal UInt32 offset
internal UInt32 flags
}
internal Microsoft.Cci.Pdb.CV_Line_Flags : Enum {
public UInt32 value__
public CV_Line_Flags linenumStart
public CV_Line_Flags deltaLineEnd
public CV_Line_Flags fStatement
}
internal Microsoft.Cci.Pdb.CV_LINE_SUBSECTION_FLAGS : Enum {
public ushort value__
public CV_LINE_SUBSECTION_FLAGS CV_LINES_HAVE_COLUMNS
}
internal Microsoft.Cci.Pdb.CV_LineSection : ValueType {
internal UInt32 off
internal ushort sec
internal ushort flags
internal UInt32 cod
}
internal Microsoft.Cci.Pdb.CV_lvar_addr_range : ValueType {
internal UInt32 offStart
internal ushort isectStart
internal UInt32 cbRange
}
internal Microsoft.Cci.Pdb.CV_LVARFLAGS : Enum {
public ushort value__
public CV_LVARFLAGS fIsParam
public CV_LVARFLAGS fAddrTaken
public CV_LVARFLAGS fCompGenx
public CV_LVARFLAGS fIsAggregate
public CV_LVARFLAGS fIsAggregated
public CV_LVARFLAGS fIsAliased
public CV_LVARFLAGS fIsAlias
}
internal Microsoft.Cci.Pdb.CV_methodprop : Enum {
public int value__
public CV_methodprop CV_MTvanilla
public CV_methodprop CV_MTvirtual
public CV_methodprop CV_MTstatic
public CV_methodprop CV_MTfriend
public CV_methodprop CV_MTintro
public CV_methodprop CV_MTpurevirt
public CV_methodprop CV_MTpureintro
}
internal Microsoft.Cci.Pdb.CV_modifier : Enum {
public ushort value__
public CV_modifier MOD_const
public CV_modifier MOD_volatile
public CV_modifier MOD_unaligned
}
internal Microsoft.Cci.Pdb.CV_PDMR32_NVVFCN : ValueType {
internal int mdisp
}
internal Microsoft.Cci.Pdb.CV_PDMR32_VBASE : ValueType {
internal int mdisp
internal int pdisp
internal int vdisp
}
internal Microsoft.Cci.Pdb.CV_PMFR32_NVMA : ValueType {
internal UInt32 off
internal int disp
}
internal Microsoft.Cci.Pdb.CV_PMFR32_NVSA : ValueType {
internal UInt32 off
}
internal Microsoft.Cci.Pdb.CV_PMFR32_VBASE : ValueType {
internal UInt32 off
internal int mdisp
internal int pdisp
internal int vdisp
}
internal Microsoft.Cci.Pdb.CV_pmtype : Enum {
public int value__
public CV_pmtype CV_PMTYPE_Undef
public CV_pmtype CV_PMTYPE_D_Single
public CV_pmtype CV_PMTYPE_D_Multiple
public CV_pmtype CV_PMTYPE_D_Virtual
public CV_pmtype CV_PMTYPE_D_General
public CV_pmtype CV_PMTYPE_F_Single
public CV_pmtype CV_PMTYPE_F_Multiple
public CV_pmtype CV_PMTYPE_F_Virtual
public CV_pmtype CV_PMTYPE_F_General
}
internal Microsoft.Cci.Pdb.CV_PRIMITIVE_TYPE : ValueType {
private UInt32 CV_MMASK
private UInt32 CV_TMASK
private UInt32 CV_SMASK
private int CV_MSHIFT
private int CV_TSHIFT
private int CV_SSHIFT
private UInt32 CV_FIRST_NONPRIM
}
internal Microsoft.Cci.Pdb.CV_prmode : Enum {
public int value__
public CV_prmode CV_TM_DIRECT
public CV_prmode CV_TM_NPTR32
public CV_prmode CV_TM_NPTR64
public CV_prmode CV_TM_NPTR128
}
internal Microsoft.Cci.Pdb.CV_PROCFLAGS : Enum {
public byte value__
public CV_PROCFLAGS CV_PFLAG_NOFPO
public CV_PROCFLAGS CV_PFLAG_INT
public CV_PROCFLAGS CV_PFLAG_FAR
public CV_PROCFLAGS CV_PFLAG_NEVER
public CV_PROCFLAGS CV_PFLAG_NOTREACHED
public CV_PROCFLAGS CV_PFLAG_CUST_CALL
public CV_PROCFLAGS CV_PFLAG_NOINLINE
public CV_PROCFLAGS CV_PFLAG_OPTDBGINFO
}
internal Microsoft.Cci.Pdb.CV_prop : Enum {
public ushort value__
public CV_prop packed
public CV_prop ctor
public CV_prop ovlops
public CV_prop isnested
public CV_prop cnested
public CV_prop opassign
public CV_prop opcast
public CV_prop fwdref
public CV_prop scoped
}
internal Microsoft.Cci.Pdb.CV_ptrmode : Enum {
public int value__
public CV_ptrmode CV_PTR_MODE_PTR
public CV_ptrmode CV_PTR_MODE_REF
public CV_ptrmode CV_PTR_MODE_PMEM
public CV_ptrmode CV_PTR_MODE_PMFUNC
public CV_ptrmode CV_PTR_MODE_RESERVED
}
internal Microsoft.Cci.Pdb.CV_ptrtype : Enum {
public int value__
public CV_ptrtype CV_PTR_BASE_SEG
public CV_ptrtype CV_PTR_BASE_VAL
public CV_ptrtype CV_PTR_BASE_SEGVAL
public CV_ptrtype CV_PTR_BASE_ADDR
public CV_ptrtype CV_PTR_BASE_SEGADDR
public CV_ptrtype CV_PTR_BASE_TYPE
public CV_ptrtype CV_PTR_BASE_SELF
public CV_ptrtype CV_PTR_NEAR32
public CV_ptrtype CV_PTR_64
public CV_ptrtype CV_PTR_UNUSEDPTR
}
internal Microsoft.Cci.Pdb.CV_PUBSYMFLAGS : Enum {
public UInt32 value__
public CV_PUBSYMFLAGS fNone
public CV_PUBSYMFLAGS fCode
public CV_PUBSYMFLAGS fFunction
public CV_PUBSYMFLAGS fManaged
public CV_PUBSYMFLAGS fMSIL
}
internal Microsoft.Cci.Pdb.CV_real : Enum {
public int value__
public CV_real CV_RC_REAL32
public CV_real CV_RC_REAL64
public CV_real CV_RC_REAL80
public CV_real CV_RC_REAL128
}
internal Microsoft.Cci.Pdb.CV_SEPCODEFLAGS : Enum {
public UInt32 value__
public CV_SEPCODEFLAGS fIsLexicalScope
public CV_SEPCODEFLAGS fReturnsToParent
}
internal Microsoft.Cci.Pdb.CV_SIGNATURE : Enum {
public int value__
public CV_SIGNATURE C6
public CV_SIGNATURE C7
public CV_SIGNATURE C11
public CV_SIGNATURE C13
public CV_SIGNATURE RESERVERD
}
internal Microsoft.Cci.Pdb.CV_SourceFile : ValueType {
internal UInt32 index
internal UInt32 count
internal UInt32 linsiz
}
internal Microsoft.Cci.Pdb.CV_special : Enum {
public int value__
public CV_special CV_SP_NOTYPE
public CV_special CV_SP_ABS
public CV_special CV_SP_SEGMENT
public CV_special CV_SP_VOID
public CV_special CV_SP_CURRENCY
public CV_special CV_SP_NBASICSTR
public CV_special CV_SP_FBASICSTR
public CV_special CV_SP_NOTTRANS
public CV_special CV_SP_HRESULT
}
internal Microsoft.Cci.Pdb.CV_special2 : Enum {
public int value__
public CV_special2 CV_S2_BIT
public CV_special2 CV_S2_PASCHAR
}
internal Microsoft.Cci.Pdb.CV_type : Enum {
public int value__
public CV_type CV_SPECIAL
public CV_type CV_SIGNED
public CV_type CV_UNSIGNED
public CV_type CV_BOOLEAN
public CV_type CV_REAL
public CV_type CV_COMPLEX
public CV_type CV_SPECIAL2
public CV_type CV_INT
public CV_type CV_CVRESERVED
}
internal Microsoft.Cci.Pdb.CV_VTS_desc : Enum {
public int value__
public CV_VTS_desc CV_VTS_near
public CV_VTS_desc CV_VTS_far
public CV_VTS_desc CV_VTS_thin
public CV_VTS_desc CV_VTS_outer
public CV_VTS_desc CV_VTS_meta
public CV_VTS_desc CV_VTS_near32
public CV_VTS_desc CV_VTS_far32
public CV_VTS_desc CV_VTS_unused
}
internal Microsoft.Cci.Pdb.DatasSym32 : ValueType {
internal UInt32 typind
internal UInt32 off
internal ushort seg
internal string name
}
internal Microsoft.Cci.Pdb.DataStream : object {
internal int contentSize
internal Int32[] pages
internal int Length
internal void .ctor(int contentSize, BitAccess bits, int count)
internal void Read(PdbReader reader, BitAccess bits)
internal void Read(PdbReader reader, int position, Byte[] bytes, int offset, int data)
internal int get_Length()
}
internal Microsoft.Cci.Pdb.DbiDbgHdr : ValueType {
internal ushort snFPO
internal ushort snException
internal ushort snFixup
internal ushort snOmapToSrc
internal ushort snOmapFromSrc
internal ushort snSectionHdr
internal ushort snTokenRidMap
internal ushort snXdata
internal ushort snPdata
internal ushort snNewFPO
internal ushort snSectionHdrOrig
internal void .ctor(BitAccess bits)
}
internal Microsoft.Cci.Pdb.DbiHeader : ValueType {
internal int sig
internal int ver
internal int age
internal short gssymStream
internal ushort vers
internal short pssymStream
internal ushort pdbver
internal short symrecStream
internal ushort pdbver2
internal int gpmodiSize
internal int secconSize
internal int secmapSize
internal int filinfSize
internal int tsmapSize
internal int mfcIndex
internal int dbghdrSize
internal int ecinfoSize
internal ushort flags
internal ushort machine
internal int reserved
internal void .ctor(BitAccess bits)
}
internal Microsoft.Cci.Pdb.DbiModuleInfo : object {
internal int opened
internal ushort flags
internal short stream
internal int cbSyms
internal int cbOldLines
internal int cbLines
internal short files
internal short pad1
internal UInt32 offsets
internal int niSource
internal int niCompiler
internal string moduleName
internal string objectName
internal void .ctor(BitAccess bits, bool readStrings)
}
internal Microsoft.Cci.Pdb.DbiSecCon : ValueType {
internal short section
internal short pad1
internal int offset
internal int size
internal UInt32 flags
internal short module
internal short pad2
internal UInt32 dataCrc
internal UInt32 relocCrc
internal void .ctor(BitAccess bits)
}
internal Microsoft.Cci.Pdb.DEBUG_S_SUBSECTION : Enum {
public int value__
public DEBUG_S_SUBSECTION SYMBOLS
public DEBUG_S_SUBSECTION LINES
public DEBUG_S_SUBSECTION STRINGTABLE
public DEBUG_S_SUBSECTION FILECHKSMS
public DEBUG_S_SUBSECTION FRAMEDATA
}
internal Microsoft.Cci.Pdb.DEBUG_S_SUBSECTION_TYPE : Enum {
public UInt32 value__
public DEBUG_S_SUBSECTION_TYPE DEBUG_S_IGNORE
public DEBUG_S_SUBSECTION_TYPE DEBUG_S_SYMBOLS
public DEBUG_S_SUBSECTION_TYPE DEBUG_S_LINES
public DEBUG_S_SUBSECTION_TYPE DEBUG_S_STRINGTABLE
public DEBUG_S_SUBSECTION_TYPE DEBUG_S_FILECHKSMS
public DEBUG_S_SUBSECTION_TYPE DEBUG_S_FRAMEDATA
}
internal Microsoft.Cci.Pdb.DefRangeSym : ValueType {
internal UInt32 id
internal UInt32 program
internal CV_lvar_addr_range range
}
internal Microsoft.Cci.Pdb.DefRangeSym2 : ValueType {
internal UInt32 id
internal UInt32 program
internal ushort count
internal CV_lvar_addr_range[] range
}
internal Microsoft.Cci.Pdb.DiscardedSym : ValueType {
internal CV_DISCARDED iscarded
internal UInt32 fileid
internal UInt32 linenum
internal Byte[] data
}
internal Microsoft.Cci.Pdb.EntryThisSym : ValueType {
internal byte thissym
}
internal Microsoft.Cci.Pdb.ExportSym : ValueType {
internal ushort ordinal
internal ushort flags
internal string name
}
internal Microsoft.Cci.Pdb.EXPORTSYM_FLAGS : Enum {
public ushort value__
public EXPORTSYM_FLAGS fConstant
public EXPORTSYM_FLAGS fData
public EXPORTSYM_FLAGS fPrivate
public EXPORTSYM_FLAGS fNoName
public EXPORTSYM_FLAGS fOrdinal
public EXPORTSYM_FLAGS fForwarder
}
internal Microsoft.Cci.Pdb.FLOAT10 : ValueType {
internal byte Data_0
internal byte Data_1
internal byte Data_2
internal byte Data_3
internal byte Data_4
internal byte Data_5
internal byte Data_6
internal byte Data_7
internal byte Data_8
internal byte Data_9
}
internal Microsoft.Cci.Pdb.FrameCookie : ValueType {
internal int off
internal ushort reg
internal int cookietype
internal byte flags
}
internal Microsoft.Cci.Pdb.FrameData : ValueType {
internal UInt32 ulRvaStart
internal UInt32 cbBlock
internal UInt32 cbLocals
internal UInt32 cbParams
internal UInt32 cbStkMax
internal UInt32 frameFunc
internal ushort cbProlog
internal ushort cbSavedRegs
internal UInt32 flags
}
internal Microsoft.Cci.Pdb.FRAMEDATA_FLAGS : Enum {
public UInt32 value__
public FRAMEDATA_FLAGS fHasSEH
public FRAMEDATA_FLAGS fHasEH
public FRAMEDATA_FLAGS fIsFunctionStart
}
internal Microsoft.Cci.Pdb.FrameProcSym : ValueType {
internal UInt32 cbFrame
internal UInt32 cbPad
internal UInt32 offPad
internal UInt32 cbSaveRegs
internal UInt32 offExHdlr
internal ushort secExHdlr
internal UInt32 flags
}
internal Microsoft.Cci.Pdb.FRAMEPROCSYM_FLAGS : Enum {
public UInt32 value__
public FRAMEPROCSYM_FLAGS fHasAlloca
public FRAMEPROCSYM_FLAGS fHasSetJmp
public FRAMEPROCSYM_FLAGS fHasLongJmp
public FRAMEPROCSYM_FLAGS fHasInlAsm
public FRAMEPROCSYM_FLAGS fHasEH
public FRAMEPROCSYM_FLAGS fInlSpec
public FRAMEPROCSYM_FLAGS fHasSEH
public FRAMEPROCSYM_FLAGS fNaked
public FRAMEPROCSYM_FLAGS fSecurityChecks
public FRAMEPROCSYM_FLAGS fAsyncEH
public FRAMEPROCSYM_FLAGS fGSNoStackOrdering
public FRAMEPROCSYM_FLAGS fWasInlined
}
internal Microsoft.Cci.Pdb.FrameRelSym : ValueType {
internal int off
internal UInt32 typind
internal UInt32 offCod
internal ushort segCod
internal ushort flags
internal string name
}
internal Microsoft.Cci.Pdb.ILocalScope {
public UInt32 Offset
public UInt32 Length
public UInt32 get_Offset()
public UInt32 get_Length()
}
internal Microsoft.Cci.Pdb.IName {
public int UniqueKey
public int UniqueKeyIgnoringCase
public string Value
public int get_UniqueKey()
public int get_UniqueKeyIgnoringCase()
public string get_Value()
}
internal Microsoft.Cci.Pdb.INamespaceScope {
public IEnumerable`1<IUsedNamespace> UsedNamespaces
public IEnumerable`1<IUsedNamespace> get_UsedNamespaces()
}
internal Microsoft.Cci.Pdb.IntHashTable : object {
private Int32[] primes
private bucket[] buckets
private int count
private int occupancy
private int loadsize
private int loadFactorPerc
private int version
internal object Item
private int GetPrime(int minSize)
internal void .ctor(int capacity, int loadFactorPerc)
private UInt32 InitHash(int key, int hashsize, UInt32& seed, UInt32& incr)
internal void Add(int key, object value)
internal object get_Item(int key)
private void expand()
private void rehash()
private void rehash(int newsize)
private void Insert(int key, object nvalue, bool add)
private void putEntry(bucket[] newBuckets, int key, object nvalue, int hashcode)
}
internal Microsoft.Cci.Pdb.IUsedNamespace {
public IName Alias
public IName NamespaceName
public IName get_Alias()
public IName get_NamespaceName()
}
internal Microsoft.Cci.Pdb.LabelSym32 : ValueType {
internal UInt32 off
internal ushort seg
internal byte flags
internal string name
}
internal Microsoft.Cci.Pdb.LEAF : Enum {
public int value__
public LEAF LF_VTSHAPE
public LEAF LF_COBOL1
public LEAF LF_LABEL
public LEAF LF_NULL
public LEAF LF_NOTTRAN
public LEAF LF_ENDPRECOMP
public LEAF LF_TYPESERVER_ST
public LEAF LF_LIST
public LEAF LF_REFSYM
public LEAF LF_ENUMERATE_ST
public LEAF LF_TI16_MAX
public LEAF LF_MODIFIER
public LEAF LF_POINTER
public LEAF LF_ARRAY_ST
public LEAF LF_CLASS_ST
public LEAF LF_STRUCTURE_ST
public LEAF LF_UNION_ST
public LEAF LF_ENUM_ST
public LEAF LF_PROCEDURE
public LEAF LF_MFUNCTION
public LEAF LF_COBOL0
public LEAF LF_BARRAY
public LEAF LF_DIMARRAY_ST
public LEAF LF_VFTPATH
public LEAF LF_PRECOMP_ST
public LEAF LF_OEM
public LEAF LF_ALIAS_ST
public LEAF LF_OEM2
public LEAF LF_SKIP
public LEAF LF_ARGLIST
public LEAF LF_DEFARG_ST
public LEAF LF_FIELDLIST
public LEAF LF_DERIVED
public LEAF LF_BITFIELD
public LEAF LF_METHODLIST
public LEAF LF_DIMCONU
public LEAF LF_DIMCONLU
public LEAF LF_DIMVARU
public LEAF LF_DIMVARLU
public LEAF LF_BCLASS
public LEAF LF_VBCLASS
public LEAF LF_IVBCLASS
public LEAF LF_FRIENDFCN_ST
public LEAF LF_INDEX
public LEAF LF_MEMBER_ST
public LEAF LF_STMEMBER_ST
public LEAF LF_METHOD_ST
public LEAF LF_NESTTYPE_ST
public LEAF LF_VFUNCTAB
public LEAF LF_FRIENDCLS
public LEAF LF_ONEMETHOD_ST
public LEAF LF_VFUNCOFF
public LEAF LF_NESTTYPEEX_ST
public LEAF LF_MEMBERMODIFY_ST
public LEAF LF_MANAGED_ST
public LEAF LF_ST_MAX
public LEAF LF_TYPESERVER
public LEAF LF_ENUMERATE
public LEAF LF_ARRAY
public LEAF LF_CLASS
public LEAF LF_STRUCTURE
public LEAF LF_UNION
public LEAF LF_ENUM
public LEAF LF_DIMARRAY
public LEAF LF_PRECOMP
public LEAF LF_ALIAS
public LEAF LF_DEFARG
public LEAF LF_FRIENDFCN
public LEAF LF_MEMBER
public LEAF LF_STMEMBER
public LEAF LF_METHOD
public LEAF LF_NESTTYPE
public LEAF LF_ONEMETHOD
public LEAF LF_NESTTYPEEX
public LEAF LF_MEMBERMODIFY
public LEAF LF_MANAGED
public LEAF LF_TYPESERVER2
public LEAF LF_NUMERIC
public LEAF LF_CHAR
public LEAF LF_SHORT
public LEAF LF_USHORT
public LEAF LF_LONG
public LEAF LF_ULONG
public LEAF LF_REAL32
public LEAF LF_REAL64
public LEAF LF_REAL80
public LEAF LF_REAL128
public LEAF LF_QUADWORD
public LEAF LF_UQUADWORD
public LEAF LF_COMPLEX32
public LEAF LF_COMPLEX64
public LEAF LF_COMPLEX80
public LEAF LF_COMPLEX128
public LEAF LF_VARSTRING
public LEAF LF_OCTWORD
public LEAF LF_UOCTWORD
public LEAF LF_DECIMAL
public LEAF LF_DATE
public LEAF LF_UTF8STRING
public LEAF LF_PAD0
public LEAF LF_PAD1
public LEAF LF_PAD2
public LEAF LF_PAD3
public LEAF LF_PAD4
public LEAF LF_PAD5
public LEAF LF_PAD6
public LEAF LF_PAD7
public LEAF LF_PAD8
public LEAF LF_PAD9
public LEAF LF_PAD10
public LEAF LF_PAD11
public LEAF LF_PAD12
public LEAF LF_PAD13
public LEAF LF_PAD14
public LEAF LF_PAD15
}
internal Microsoft.Cci.Pdb.LeafAlias : ValueType {
internal UInt32 utype
internal string name
}
internal Microsoft.Cci.Pdb.LeafArgList : ValueType {
internal UInt32 count
internal UInt32[] arg
}
internal Microsoft.Cci.Pdb.LeafArray : ValueType {
internal UInt32 elemtype
internal UInt32 idxtype
internal Byte[] data
internal string name
}
internal Microsoft.Cci.Pdb.LeafBArray : ValueType {
internal UInt32 utype
}
internal Microsoft.Cci.Pdb.LeafBClass : ValueType {
internal ushort attr
internal UInt32 index
internal Byte[] offset
}
internal Microsoft.Cci.Pdb.LeafBitfield : ValueType {
internal UInt32 type
internal byte length
internal byte position
}
internal Microsoft.Cci.Pdb.LeafChar : ValueType {
internal sbyte val
}
internal Microsoft.Cci.Pdb.LeafClass : ValueType {
internal ushort count
internal ushort property
internal UInt32 field
internal UInt32 derived
internal UInt32 vshape
internal Byte[] data
internal string name
}
internal Microsoft.Cci.Pdb.LeafCmplx128 : ValueType {
internal ulong val0_real
internal ulong val1_real
internal ulong val0_imag
internal ulong val1_imag
}
internal Microsoft.Cci.Pdb.LeafCmplx32 : ValueType {
internal float val_real
internal float val_imag
}
internal Microsoft.Cci.Pdb.LeafCmplx64 : ValueType {
internal double val_real
internal double val_imag
}
internal Microsoft.Cci.Pdb.LeafCmplx80 : ValueType {
internal FLOAT10 val_real
internal FLOAT10 val_imag
}
internal Microsoft.Cci.Pdb.LeafCobol0 : ValueType {
internal UInt32 type
internal Byte[] data
}
internal Microsoft.Cci.Pdb.LeafCobol1 : ValueType {
internal Byte[] data
}
internal Microsoft.Cci.Pdb.LeafDefArg : ValueType {
internal UInt32 type
internal Byte[] expr
}
internal Microsoft.Cci.Pdb.LeafDerived : ValueType {
internal UInt32 count
internal UInt32[] drvdcls
}
internal Microsoft.Cci.Pdb.LeafDimArray : ValueType {
internal UInt32 utype
internal UInt32 diminfo
internal string name
}
internal Microsoft.Cci.Pdb.LeafDimCon : ValueType {
internal UInt32 typ
internal ushort rank
internal Byte[] dim
}
internal Microsoft.Cci.Pdb.LeafDimVar : ValueType {
internal UInt32 rank
internal UInt32 typ
internal UInt32[] dim
}
internal Microsoft.Cci.Pdb.LeafEndPreComp : ValueType {
internal UInt32 signature
}
internal Microsoft.Cci.Pdb.LeafEnum : ValueType {
internal ushort count
internal ushort property
internal UInt32 utype
internal UInt32 field
internal string name
}
internal Microsoft.Cci.Pdb.LeafEnumerate : ValueType {
internal ushort attr
internal Byte[] value
internal string name
}
internal Microsoft.Cci.Pdb.LeafFieldList : ValueType {
internal Char[] data
}
internal Microsoft.Cci.Pdb.LeafFriendCls : ValueType {
internal ushort pad0
internal UInt32 index
}
internal Microsoft.Cci.Pdb.LeafFriendFcn : ValueType {
internal ushort pad0
internal UInt32 index
internal string name
}
internal Microsoft.Cci.Pdb.LeafIndex : ValueType {
internal ushort pad0
internal UInt32 index
}
internal Microsoft.Cci.Pdb.LeafLabel : ValueType {
internal ushort mode
}
internal Microsoft.Cci.Pdb.LeafList : ValueType {
internal Byte[] data
}
internal Microsoft.Cci.Pdb.LeafLong : ValueType {
internal int val
}
internal Microsoft.Cci.Pdb.LeafManaged : ValueType {
internal string name
}
internal Microsoft.Cci.Pdb.LeafMember : ValueType {
internal ushort attr
internal UInt32 index
internal Byte[] offset
internal string name
}
internal Microsoft.Cci.Pdb.LeafMemberModify : ValueType {
internal ushort attr
internal UInt32 index
internal string name
}
internal Microsoft.Cci.Pdb.LeafMethod : ValueType {
internal ushort count
internal UInt32 mList
internal string name
}
internal Microsoft.Cci.Pdb.LeafMethodList : ValueType {
internal Byte[] mList
}
internal Microsoft.Cci.Pdb.LeafMFunc : ValueType {
internal UInt32 rvtype
internal UInt32 classtype
internal UInt32 thistype
internal byte calltype
internal byte reserved
internal ushort parmcount
internal UInt32 arglist
internal int thisadjust
}
internal Microsoft.Cci.Pdb.LeafModifier : ValueType {
internal UInt32 type
internal CV_modifier attr
}
internal Microsoft.Cci.Pdb.LeafNestType : ValueType {
internal ushort pad0
internal UInt32 index
internal string name
}
internal Microsoft.Cci.Pdb.LeafNestTypeEx : ValueType {
internal ushort attr
internal UInt32 index
internal string name
}
internal Microsoft.Cci.Pdb.LeafOct : ValueType {
internal ulong val0
internal ulong val1
}
internal Microsoft.Cci.Pdb.LeafOEM : ValueType {
internal ushort cvOEM
internal ushort recOEM
internal UInt32 count
internal UInt32[] index
}
internal Microsoft.Cci.Pdb.LeafOEM2 : ValueType {
internal Guid idOem
internal UInt32 count
internal UInt32[] index
}
internal Microsoft.Cci.Pdb.LeafOneMethod : ValueType {
internal ushort attr
internal UInt32 index
internal UInt32[] vbaseoff
internal string name
}
internal Microsoft.Cci.Pdb.LeafPad : ValueType {
internal byte leaf
}
internal Microsoft.Cci.Pdb.LeafPointerAttr : Enum {
public UInt32 value__
public LeafPointerAttr ptrtype
public LeafPointerAttr ptrmode
public LeafPointerAttr isflat32
public LeafPointerAttr isvolatile
public LeafPointerAttr isconst
public LeafPointerAttr isunaligned
public LeafPointerAttr isrestrict
}
internal Microsoft.Cci.Pdb.LeafPreComp : ValueType {
internal UInt32 start
internal UInt32 count
internal UInt32 signature
internal string name
}
internal Microsoft.Cci.Pdb.LeafProc : ValueType {
internal UInt32 rvtype
internal byte calltype
internal byte reserved
internal ushort parmcount
internal UInt32 arglist
}
internal Microsoft.Cci.Pdb.LeafQuad : ValueType {
internal long val
}
internal Microsoft.Cci.Pdb.LeafReal128 : ValueType {
internal ulong val0
internal ulong val1
}
internal Microsoft.Cci.Pdb.LeafReal32 : ValueType {
internal float val
}
internal Microsoft.Cci.Pdb.LeafReal64 : ValueType {
internal double val
}
internal Microsoft.Cci.Pdb.LeafReal80 : ValueType {
internal FLOAT10 val
}
internal Microsoft.Cci.Pdb.LeafRefSym : ValueType {
internal Byte[] Sym
}
internal Microsoft.Cci.Pdb.LeafShort : ValueType {
internal short val
}
internal Microsoft.Cci.Pdb.LeafSkip : ValueType {
internal UInt32 type
internal Byte[] data
}
internal Microsoft.Cci.Pdb.LeafSTMember : ValueType {
internal ushort attr
internal UInt32 index
internal string name
}
internal Microsoft.Cci.Pdb.LeafTypeServer : ValueType {
internal UInt32 signature
internal UInt32 age
internal string name
}
internal Microsoft.Cci.Pdb.LeafTypeServer2 : ValueType {
internal Guid sig70
internal UInt32 age
internal string name
}
internal Microsoft.Cci.Pdb.LeafULong : ValueType {
internal UInt32 val
}
internal Microsoft.Cci.Pdb.LeafUnion : ValueType {
internal ushort count
internal ushort property
internal UInt32 field
internal Byte[] data
internal string name
}
internal Microsoft.Cci.Pdb.LeafUOct : ValueType {
internal ulong val0
internal ulong val1
}
internal Microsoft.Cci.Pdb.LeafUQuad : ValueType {
internal ulong val
}
internal Microsoft.Cci.Pdb.LeafUShort : ValueType {
internal ushort val
}
internal Microsoft.Cci.Pdb.LeafVarString : ValueType {
internal ushort len
internal Byte[] value
}
internal Microsoft.Cci.Pdb.LeafVBClass : ValueType {
internal ushort attr
internal UInt32 index
internal UInt32 vbptr
internal Byte[] vbpoff
}
internal Microsoft.Cci.Pdb.LeafVFTPath : ValueType {
internal UInt32 count
internal UInt32[] bases
}
internal Microsoft.Cci.Pdb.LeafVFuncOff : ValueType {
internal ushort pad0
internal UInt32 type
internal int offset
}
internal Microsoft.Cci.Pdb.LeafVFuncTab : ValueType {
internal ushort pad0
internal UInt32 type
}
internal Microsoft.Cci.Pdb.LeafVTShape : ValueType {
internal ushort count
internal Byte[] desc
}
internal Microsoft.Cci.Pdb.LocalSym : ValueType {
internal UInt32 id
internal UInt32 typind
internal ushort flags
internal UInt32 idParent
internal UInt32 offParent
internal UInt32 expr
internal UInt32 pad0
internal UInt32 pad1
internal string name
}
internal Microsoft.Cci.Pdb.ManProcSym : ValueType {
internal UInt32 parent
internal UInt32 end
internal UInt32 next
internal UInt32 len
internal UInt32 dbgStart
internal UInt32 dbgEnd
internal UInt32 token
internal UInt32 off
internal ushort seg
internal byte flags
internal ushort retReg
internal string name
}
internal Microsoft.Cci.Pdb.ManProcSymMips : ValueType {
internal UInt32 parent
internal UInt32 end
internal UInt32 next
internal UInt32 len
internal UInt32 dbgStart
internal UInt32 dbgEnd
internal UInt32 regSave
internal UInt32 fpSave
internal UInt32 intOff
internal UInt32 fpOff
internal UInt32 token
internal UInt32 off
internal ushort seg
internal byte retReg
internal byte frameReg
internal string name
}
internal Microsoft.Cci.Pdb.ManyRegSym : ValueType {
internal UInt32 typind
internal byte count
internal Byte[] reg
internal string name
}
internal Microsoft.Cci.Pdb.ManyRegSym2 : ValueType {
internal UInt32 typind
internal ushort count
internal UInt16[] reg
internal string name
}
internal Microsoft.Cci.Pdb.ManyTypRef : ValueType {
internal UInt32 typind
}
internal Microsoft.Cci.Pdb.mlMethod : ValueType {
internal ushort attr
internal ushort pad0
internal UInt32 index
internal UInt32[] vbaseoff
}
internal Microsoft.Cci.Pdb.MsfDirectory : object {
internal DataStream[] streams
internal void .ctor(PdbReader reader, PdbFileHeader head, BitAccess bits)
}
internal Microsoft.Cci.Pdb.ObjNameSym : ValueType {
internal UInt32 signature
internal string name
}
internal Microsoft.Cci.Pdb.OEM_ID : Enum {
public int value__
public OEM_ID OEM_MS_FORTRAN90
public OEM_ID OEM_ODI
public OEM_ID OEM_THOMSON_SOFTWARE
public OEM_ID OEM_ODI_REC_BASELIST
}
internal Microsoft.Cci.Pdb.OemSymbol : ValueType {
internal Guid idOem
internal UInt32 typind
internal Byte[] rgl
}
internal Microsoft.Cci.Pdb.PdbConstant : object {
internal string name
internal UInt32 token
internal object value
internal void .ctor(string name, UInt32 token, object value)
internal void .ctor(BitAccess bits)
}
internal Microsoft.Cci.Pdb.PdbDebugException : IOException {
internal void .ctor(string format, Object[] args)
}
internal Microsoft.Cci.Pdb.PdbException : IOException {
internal void .ctor(string format, Object[] args)
}
internal Microsoft.Cci.Pdb.PdbFile : object {
private Guid BasicLanguageGuid
public Guid SymDocumentType_Text
private void LoadInjectedSourceInformation(BitAccess bits, Guid& doctype, Guid& language, Guid& vendor, Guid& checksumAlgo, Byte[]& checksum)
private Dictionary`2<string, int> LoadNameIndex(BitAccess bits, Int32& age, Guid& guid)
private IntHashTable LoadNameStream(BitAccess bits)
private int FindFunction(PdbFunction[] funcs, ushort sec, UInt32 off)
private void LoadManagedLines(PdbFunction[] funcs, IntHashTable names, BitAccess bits, MsfDirectory dir, Dictionary`2<string, int> nameIndex, PdbReader reader, UInt32 limit, Dictionary`2<string, PdbSource> sourceCache)
private void LoadFuncsFromDbiModule(BitAccess bits, DbiModuleInfo info, IntHashTable names, List`1<PdbFunction> funcList, bool readStrings, MsfDirectory dir, Dictionary`2<string, int> nameIndex, PdbReader reader, Dictionary`2<string, PdbSource> sourceCache)
private void LoadDbiStream(BitAccess bits, DbiModuleInfo[]& modules, DbiDbgHdr& header, bool readStrings)
internal PdbInfo LoadFunctions(Stream read)
private void LoadTokenToSourceInfo(BitAccess bits, DbiModuleInfo module, IntHashTable names, MsfDirectory dir, Dictionary`2<string, int> nameIndex, PdbReader reader, Dictionary`2<UInt32, PdbTokenLine> tokenToSourceMapping, Dictionary`2<string, PdbSource> sourceCache)
private IntHashTable ReadSourceFileInfo(BitAccess bits, UInt32 limit, IntHashTable names, MsfDirectory dir, Dictionary`2<string, int> nameIndex, PdbReader reader, Dictionary`2<string, PdbSource> sourceCache)
}
internal Microsoft.Cci.Pdb.PdbFileHeader : object {
private Byte[] windowsPdbMagic
internal Byte[] magic
internal int pageSize
internal int freePageMap
internal int pagesUsed
internal int directorySize
internal int zero
internal Int32[] directoryRoot
internal void .ctor(Stream reader, BitAccess bits)
}
internal Microsoft.Cci.Pdb.PdbFunction : object {
internal Guid msilMetaData
internal IComparer byAddress
internal IComparer byAddressAndToken
internal UInt32 token
internal UInt32 slotToken
internal UInt32 tokenOfMethodWhoseUsingInfoAppliesToThisMethod
internal UInt32 segment
internal UInt32 address
internal UInt32 length
internal PdbScope[] scopes
internal PdbSlot[] slots
internal PdbConstant[] constants
internal String[] usedNamespaces
internal PdbLines[] lines
internal UInt16[] usingCounts
internal IEnumerable`1<INamespaceScope> namespaceScopes
internal string iteratorClass
internal List`1<ILocalScope> iteratorScopes
internal PdbSynchronizationInformation synchronizationInformation
private bool visualBasicScopesAdjusted
private string StripNamespace(string module)
internal void AdjustVisualBasicScopes()
private void AdjustVisualBasicScopes(PdbScope[] scopes)
internal PdbFunction[] LoadManagedFunctions(BitAccess bits, UInt32 limit, bool readStrings)
internal void CountScopesAndSlots(BitAccess bits, UInt32 limit, Int32& constants, Int32& scopes, Int32& slots, Int32& usedNamespaces)
internal void .ctor(ManProcSym proc, BitAccess bits)
internal void ReadMD2CustomMetadata(BitAccess bits)
private void ReadCustomMetadata(BitAccess bits)
private void ReadForwardIterator(BitAccess bits)
private void ReadIteratorLocals(BitAccess bits)
private void ReadForwardInfo(BitAccess bits)
private void ReadUsingInfo(BitAccess bits)
}
internal Microsoft.Cci.Pdb.PdbInfo : object {
public PdbFunction[] Functions
public Dictionary`2<UInt32, PdbTokenLine> TokenToSourceMapping
public string SourceServerData
public int Age
public Guid Guid
public Byte[] SourceLinkData
}
internal Microsoft.Cci.Pdb.PdbIteratorScope : object {
private UInt32 offset
private UInt32 length
public UInt32 Offset
public UInt32 Length
internal void .ctor(UInt32 offset, UInt32 length)
public UInt32 get_Offset()
public UInt32 get_Length()
}
internal Microsoft.Cci.Pdb.PdbLine : ValueType {
internal UInt32 offset
internal UInt32 lineBegin
internal UInt32 lineEnd
internal ushort colBegin
internal ushort colEnd
internal void .ctor(UInt32 offset, UInt32 lineBegin, ushort colBegin, UInt32 lineEnd, ushort colEnd)
}
internal Microsoft.Cci.Pdb.PdbLines : object {
internal PdbSource file
internal PdbLine[] lines
internal void .ctor(PdbSource file, UInt32 count)
}
internal Microsoft.Cci.Pdb.PdbReader : object {
internal int pageSize
internal Stream reader
internal void .ctor(Stream reader, int pageSize)
internal void Seek(int page, int offset)
internal void Read(Byte[] bytes, int offset, int count)
internal int PagesFromSize(int size)
}
internal Microsoft.Cci.Pdb.PdbScope : object {
internal PdbConstant[] constants
internal PdbSlot[] slots
internal PdbScope[] scopes
internal String[] usedNamespaces
internal UInt32 address
internal UInt32 offset
internal UInt32 length
internal void .ctor(UInt32 address, UInt32 offset, UInt32 length, PdbSlot[] slots, PdbConstant[] constants, String[] usedNamespaces)
internal void .ctor(UInt32 address, UInt32 length, PdbSlot[] slots, PdbConstant[] constants, String[] usedNamespaces)
internal void .ctor(UInt32 funcOffset, BlockSym32 block, BitAccess bits, UInt32& typind)
}
internal Microsoft.Cci.Pdb.PdbSlot : object {
internal UInt32 slot
internal UInt32 typeToken
internal string name
internal ushort flags
internal void .ctor(UInt32 slot, UInt32 typeToken, string name, ushort flags)
internal void .ctor(BitAccess bits)
}
internal Microsoft.Cci.Pdb.PdbSource : object {
internal string name
internal Guid doctype
internal Guid language
internal Guid vendor
internal Guid checksumAlgorithm
internal Byte[] checksum
internal void .ctor(string name, Guid doctype, Guid language, Guid vendor, Guid checksumAlgorithm, Byte[] checksum)
}
internal Microsoft.Cci.Pdb.PdbSynchronizationInformation : object {
internal UInt32 kickoffMethodToken
internal UInt32 generatedCatchHandlerIlOffset
internal PdbSynchronizationPoint[] synchronizationPoints
public UInt32 GeneratedCatchHandlerOffset
internal void .ctor(BitAccess bits)
public UInt32 get_GeneratedCatchHandlerOffset()
}
internal Microsoft.Cci.Pdb.PdbSynchronizationPoint : object {
internal UInt32 synchronizeOffset
internal UInt32 continuationMethodToken
internal UInt32 continuationOffset
public UInt32 SynchronizeOffset
public UInt32 ContinuationOffset
internal void .ctor(BitAccess bits)
public UInt32 get_SynchronizeOffset()
public UInt32 get_ContinuationOffset()
}
internal Microsoft.Cci.Pdb.PdbTokenLine : object {
internal UInt32 token
internal UInt32 file_id
internal UInt32 line
internal UInt32 column
internal UInt32 endLine
internal UInt32 endColumn
internal PdbSource sourceFile
internal PdbTokenLine nextLine
internal void .ctor(UInt32 token, UInt32 file_id, UInt32 line, UInt32 column, UInt32 endLine, UInt32 endColumn)
}
internal Microsoft.Cci.Pdb.ProcSym32 : ValueType {
internal UInt32 parent
internal UInt32 end
internal UInt32 next
internal UInt32 len
internal UInt32 dbgStart
internal UInt32 dbgEnd
internal UInt32 typind
internal UInt32 off
internal ushort seg
internal byte flags
internal string name
}
internal Microsoft.Cci.Pdb.ProcSymIa64 : ValueType {
internal UInt32 parent
internal UInt32 end
internal UInt32 next
internal UInt32 len
internal UInt32 dbgStart
internal UInt32 dbgEnd
internal UInt32 typind
internal UInt32 off
internal ushort seg
internal ushort retReg
internal byte flags
internal string name
}
internal Microsoft.Cci.Pdb.ProcSymMips : ValueType {
internal UInt32 parent
internal UInt32 end
internal UInt32 next
internal UInt32 len
internal UInt32 dbgStart
internal UInt32 dbgEnd
internal UInt32 regSave
internal UInt32 fpSave
internal UInt32 intOff
internal UInt32 fpOff
internal UInt32 typind
internal UInt32 off
internal ushort seg
internal byte retReg
internal byte frameReg
internal string name
}
internal Microsoft.Cci.Pdb.PubSym32 : ValueType {
internal UInt32 flags
internal UInt32 off
internal ushort seg
internal string name
}
internal Microsoft.Cci.Pdb.RefSym : ValueType {
internal UInt32 sumName
internal UInt32 ibSym
internal ushort imod
internal ushort usFill
}
internal Microsoft.Cci.Pdb.RefSym2 : ValueType {
internal UInt32 sumName
internal UInt32 ibSym
internal ushort imod
internal string name
}
internal Microsoft.Cci.Pdb.RegRel32 : ValueType {
internal UInt32 off
internal UInt32 typind
internal ushort reg
internal string name
}
internal Microsoft.Cci.Pdb.RegSym : ValueType {
internal UInt32 typind
internal ushort reg
internal string name
}
internal Microsoft.Cci.Pdb.ReturnSym : ValueType {
internal CV_GENERIC_FLAG flags
internal byte style
}
internal Microsoft.Cci.Pdb.SearchSym : ValueType {
internal UInt32 startsym
internal ushort seg
}
internal Microsoft.Cci.Pdb.SectionSym : ValueType {
internal ushort isec
internal byte align
internal byte bReserved
internal UInt32 rva
internal UInt32 cb
internal UInt32 characteristics
internal string name
}
internal Microsoft.Cci.Pdb.SepCodSym : ValueType {
internal UInt32 parent
internal UInt32 end
internal UInt32 length
internal UInt32 scf
internal UInt32 off
internal UInt32 offParent
internal ushort sec
internal ushort secParent
}
internal Microsoft.Cci.Pdb.Slink32 : ValueType {
internal UInt32 framesize
internal int off
internal ushort reg
}
internal Microsoft.Cci.Pdb.SlotSym32 : ValueType {
internal UInt32 index
internal UInt32 typind
internal string name
}
internal Microsoft.Cci.Pdb.SYM : Enum {
public int value__
public SYM S_END
public SYM S_OEM
public SYM S_REGISTER_ST
public SYM S_CONSTANT_ST
public SYM S_UDT_ST
public SYM S_COBOLUDT_ST
public SYM S_MANYREG_ST
public SYM S_BPREL32_ST
public SYM S_LDATA32_ST
public SYM S_GDATA32_ST
public SYM S_PUB32_ST
public SYM S_LPROC32_ST
public SYM S_GPROC32_ST
public SYM S_VFTABLE32
public SYM S_REGREL32_ST
public SYM S_LTHREAD32_ST
public SYM S_GTHREAD32_ST
public SYM S_LPROCMIPS_ST
public SYM S_GPROCMIPS_ST
public SYM S_FRAMEPROC
public SYM S_COMPILE2_ST
public SYM S_MANYREG2_ST
public SYM S_LPROCIA64_ST
public SYM S_GPROCIA64_ST
public SYM S_LOCALSLOT_ST
public SYM S_PARAMSLOT_ST
public SYM S_ANNOTATION
public SYM S_GMANPROC_ST
public SYM S_LMANPROC_ST
public SYM S_RESERVED1
public SYM S_RESERVED2
public SYM S_RESERVED3
public SYM S_RESERVED4
public SYM S_LMANDATA_ST
public SYM S_GMANDATA_ST
public SYM S_MANFRAMEREL_ST
public SYM S_MANREGISTER_ST
public SYM S_MANSLOT_ST
public SYM S_MANMANYREG_ST
public SYM S_MANREGREL_ST
public SYM S_MANMANYREG2_ST
public SYM S_MANTYPREF
public SYM S_UNAMESPACE_ST
public SYM S_ST_MAX
public SYM S_OBJNAME
public SYM S_THUNK32
public SYM S_BLOCK32
public SYM S_WITH32
public SYM S_LABEL32
public SYM S_REGISTER
public SYM S_CONSTANT
public SYM S_UDT
public SYM S_COBOLUDT
public SYM S_MANYREG
public SYM S_BPREL32
public SYM S_LDATA32
public SYM S_GDATA32
public SYM S_PUB32
public SYM S_LPROC32
public SYM S_GPROC32
public SYM S_REGREL32
public SYM S_LTHREAD32
public SYM S_GTHREAD32
public SYM S_LPROCMIPS
public SYM S_GPROCMIPS
public SYM S_COMPILE2
public SYM S_MANYREG2
public SYM S_LPROCIA64
public SYM S_GPROCIA64
public SYM S_LOCALSLOT
public SYM S_SLOT
public SYM S_PARAMSLOT
public SYM S_LMANDATA
public SYM S_GMANDATA
public SYM S_MANFRAMEREL
public SYM S_MANREGISTER
public SYM S_MANSLOT
public SYM S_MANMANYREG
public SYM S_MANREGREL
public SYM S_MANMANYREG2
public SYM S_UNAMESPACE
public SYM S_PROCREF
public SYM S_DATAREF
public SYM S_LPROCREF
public SYM S_ANNOTATIONREF
public SYM S_TOKENREF
public SYM S_GMANPROC
public SYM S_LMANPROC
public SYM S_TRAMPOLINE
public SYM S_MANCONSTANT
public SYM S_ATTR_FRAMEREL
public SYM S_ATTR_REGISTER
public SYM S_ATTR_REGREL
public SYM S_ATTR_MANYREG
public SYM S_SEPCODE
public SYM S_LOCAL
public SYM S_DEFRANGE
public SYM S_DEFRANGE2
public SYM S_SECTION
public SYM S_COFFGROUP
public SYM S_EXPORT
public SYM S_CALLSITEINFO
public SYM S_FRAMECOOKIE
public SYM S_DISCARDED
public SYM S_RECTYPE_MAX
public SYM S_RECTYPE_LAST
}
internal Microsoft.Cci.Pdb.SYMTYPE : ValueType {
internal ushort reclen
internal ushort rectyp
}
internal Microsoft.Cci.Pdb.ThreadSym32 : ValueType {
internal UInt32 typind
internal UInt32 off
internal ushort seg
internal string name
}
internal Microsoft.Cci.Pdb.ThunkSym32 : ValueType {
internal UInt32 parent
internal UInt32 end
internal UInt32 next
internal UInt32 off
internal ushort seg
internal ushort len
internal byte ord
internal string name
internal Byte[] variant
}
internal Microsoft.Cci.Pdb.TRAMP : Enum {
public int value__
public TRAMP trampIncremental
public TRAMP trampBranchIsland
}
internal Microsoft.Cci.Pdb.TrampolineSym : ValueType {
internal ushort trampType
internal ushort cbThunk
internal UInt32 offThunk
internal UInt32 offTarget
internal ushort sectThunk
internal ushort sectTarget
}
internal Microsoft.Cci.Pdb.TYPE_ENUM : Enum {
public int value__
public TYPE_ENUM T_NOTYPE
public TYPE_ENUM T_ABS
public TYPE_ENUM T_SEGMENT
public TYPE_ENUM T_VOID
public TYPE_ENUM T_HRESULT
public TYPE_ENUM T_32PHRESULT
public TYPE_ENUM T_64PHRESULT
public TYPE_ENUM T_PVOID
public TYPE_ENUM T_PFVOID
public TYPE_ENUM T_PHVOID
public TYPE_ENUM T_32PVOID
public TYPE_ENUM T_64PVOID
public TYPE_ENUM T_CURRENCY
public TYPE_ENUM T_NOTTRANS
public TYPE_ENUM T_BIT
public TYPE_ENUM T_PASCHAR
public TYPE_ENUM T_CHAR
public TYPE_ENUM T_32PCHAR
public TYPE_ENUM T_64PCHAR
public TYPE_ENUM T_UCHAR
public TYPE_ENUM T_32PUCHAR
public TYPE_ENUM T_64PUCHAR
public TYPE_ENUM T_RCHAR
public TYPE_ENUM T_32PRCHAR
public TYPE_ENUM T_64PRCHAR
public TYPE_ENUM T_WCHAR
public TYPE_ENUM T_32PWCHAR
public TYPE_ENUM T_64PWCHAR
public TYPE_ENUM T_INT1
public TYPE_ENUM T_32PINT1
public TYPE_ENUM T_64PINT1
public TYPE_ENUM T_UINT1
public TYPE_ENUM T_32PUINT1
public TYPE_ENUM T_64PUINT1
public TYPE_ENUM T_SHORT
public TYPE_ENUM T_32PSHORT
public TYPE_ENUM T_64PSHORT
public TYPE_ENUM T_USHORT
public TYPE_ENUM T_32PUSHORT
public TYPE_ENUM T_64PUSHORT
public TYPE_ENUM T_INT2
public TYPE_ENUM T_32PINT2
public TYPE_ENUM T_64PINT2
public TYPE_ENUM T_UINT2
public TYPE_ENUM T_32PUINT2
public TYPE_ENUM T_64PUINT2
public TYPE_ENUM T_LONG
public TYPE_ENUM T_ULONG
public TYPE_ENUM T_32PLONG
public TYPE_ENUM T_32PULONG
public TYPE_ENUM T_64PLONG
public TYPE_ENUM T_64PULONG
public TYPE_ENUM T_INT4
public TYPE_ENUM T_32PINT4
public TYPE_ENUM T_64PINT4
public TYPE_ENUM T_UINT4
public TYPE_ENUM T_32PUINT4
public TYPE_ENUM T_64PUINT4
public TYPE_ENUM T_QUAD
public TYPE_ENUM T_32PQUAD
public TYPE_ENUM T_64PQUAD
public TYPE_ENUM T_UQUAD
public TYPE_ENUM T_32PUQUAD
public TYPE_ENUM T_64PUQUAD
public TYPE_ENUM T_INT8
public TYPE_ENUM T_32PINT8
public TYPE_ENUM T_64PINT8
public TYPE_ENUM T_UINT8
public TYPE_ENUM T_32PUINT8
public TYPE_ENUM T_64PUINT8
public TYPE_ENUM T_OCT
public TYPE_ENUM T_32POCT
public TYPE_ENUM T_64POCT
public TYPE_ENUM T_UOCT
public TYPE_ENUM T_32PUOCT
public TYPE_ENUM T_64PUOCT
public TYPE_ENUM T_INT16
public TYPE_ENUM T_32PINT16
public TYPE_ENUM T_64PINT16
public TYPE_ENUM T_UINT16
public TYPE_ENUM T_32PUINT16
public TYPE_ENUM T_64PUINT16
public TYPE_ENUM T_REAL32
public TYPE_ENUM T_32PREAL32
public TYPE_ENUM T_64PREAL32
public TYPE_ENUM T_REAL64
public TYPE_ENUM T_32PREAL64
public TYPE_ENUM T_64PREAL64
public TYPE_ENUM T_REAL80
public TYPE_ENUM T_32PREAL80
public TYPE_ENUM T_64PREAL80
public TYPE_ENUM T_REAL128
public TYPE_ENUM T_32PREAL128
public TYPE_ENUM T_64PREAL128
public TYPE_ENUM T_CPLX32
public TYPE_ENUM T_32PCPLX32
public TYPE_ENUM T_64PCPLX32
public TYPE_ENUM T_CPLX64
public TYPE_ENUM T_32PCPLX64
public TYPE_ENUM T_64PCPLX64
public TYPE_ENUM T_CPLX80
public TYPE_ENUM T_32PCPLX80
public TYPE_ENUM T_64PCPLX80
public TYPE_ENUM T_CPLX128
public TYPE_ENUM T_32PCPLX128
public TYPE_ENUM T_64PCPLX128
public TYPE_ENUM T_BOOL08
public TYPE_ENUM T_32PBOOL08
public TYPE_ENUM T_64PBOOL08
public TYPE_ENUM T_BOOL16
public TYPE_ENUM T_32PBOOL16
public TYPE_ENUM T_64PBOOL16
public TYPE_ENUM T_BOOL32
public TYPE_ENUM T_32PBOOL32
public TYPE_ENUM T_64PBOOL32
public TYPE_ENUM T_BOOL64
public TYPE_ENUM T_32PBOOL64
public TYPE_ENUM T_64PBOOL64
}
internal Microsoft.Cci.Pdb.TYPTYPE : ValueType {
internal ushort len
internal ushort leaf
}
internal Microsoft.Cci.Pdb.UdtSym : ValueType {
internal UInt32 typind
internal string name
}
internal Microsoft.Cci.Pdb.UnamespaceSym : ValueType {
internal string name
}
internal Microsoft.Cci.Pdb.VpathSym32 : ValueType {
internal UInt32 root
internal UInt32 path
internal UInt32 off
internal ushort seg
}
internal Microsoft.Cci.Pdb.WithSym32 : ValueType {
internal UInt32 parent
internal UInt32 end
internal UInt32 len
internal UInt32 off
internal ushort seg
internal string expr
}
internal Microsoft.Cci.Pdb.XFixupData : ValueType {
internal ushort wType
internal ushort wExtra
internal UInt32 rva
internal UInt32 rvaTarget
}
internal Mono.ArgumentNullOrEmptyException : ArgumentException {
public void .ctor(string paramName)
}
internal Mono.Cecil.ArrayDimension : ValueType {
private Nullable`1<int> lower_bound
private Nullable`1<int> upper_bound
public Nullable`1<int> LowerBound
public Nullable`1<int> UpperBound
public bool IsSized
public Nullable`1<int> get_LowerBound()
public void set_LowerBound(Nullable`1<int> value)
public Nullable`1<int> get_UpperBound()
public void set_UpperBound(Nullable`1<int> value)
public bool get_IsSized()
public void .ctor(Nullable`1<int> lowerBound, Nullable`1<int> upperBound)
public string ToString()
}
internal Mono.Cecil.ArrayMarshalInfo : MarshalInfo {
internal NativeType element_type
internal int size_parameter_index
internal int size
internal int size_parameter_multiplier
public NativeType ElementType
public int SizeParameterIndex
public int Size
public int SizeParameterMultiplier
public NativeType get_ElementType()
public void set_ElementType(NativeType value)
public int get_SizeParameterIndex()
public void set_SizeParameterIndex(int value)
public int get_Size()
public void set_Size(int value)
public int get_SizeParameterMultiplier()
public void set_SizeParameterMultiplier(int value)
}
internal Mono.Cecil.ArrayType : TypeSpecification {
private Collection`1<ArrayDimension> dimensions
public Collection`1<ArrayDimension> Dimensions
public int Rank
public bool IsVector
public bool IsValueType
public string Name
public string FullName
private string Suffix
public bool IsArray
public Collection`1<ArrayDimension> get_Dimensions()
public int get_Rank()
public bool get_IsVector()
public bool get_IsValueType()
public void set_IsValueType(bool value)
public string get_Name()
public string get_FullName()
private string get_Suffix()
public bool get_IsArray()
public void .ctor(TypeReference type)
public void .ctor(TypeReference type, int rank)
}
internal Mono.Cecil.AssemblyAttributes : Enum {
public UInt32 value__
public AssemblyAttributes PublicKey
public AssemblyAttributes SideBySideCompatible
public AssemblyAttributes Retargetable
public AssemblyAttributes WindowsRuntime
public AssemblyAttributes DisableJITCompileOptimizer
public AssemblyAttributes EnableJITCompileTracking
}
internal Mono.Cecil.AssemblyDefinition : object {
private AssemblyNameDefinition name
internal ModuleDefinition main_module
private Collection`1<ModuleDefinition> modules
private Collection`1<CustomAttribute> custom_attributes
private Collection`1<SecurityDeclaration> security_declarations
public AssemblyNameDefinition Name
public string FullName
public MetadataToken MetadataToken
public Collection`1<ModuleDefinition> Modules
public ModuleDefinition MainModule
public MethodDefinition EntryPoint
public bool HasCustomAttributes
public Collection`1<CustomAttribute> CustomAttributes
public bool HasSecurityDeclarations
public Collection`1<SecurityDeclaration> SecurityDeclarations
public AssemblyNameDefinition get_Name()
public void set_Name(AssemblyNameDefinition value)
public string get_FullName()
public MetadataToken get_MetadataToken()
public void set_MetadataToken(MetadataToken value)
public Collection`1<ModuleDefinition> get_Modules()
public ModuleDefinition get_MainModule()
public MethodDefinition get_EntryPoint()
public void set_EntryPoint(MethodDefinition value)
public bool get_HasCustomAttributes()
public Collection`1<CustomAttribute> get_CustomAttributes()
public bool get_HasSecurityDeclarations()
public Collection`1<SecurityDeclaration> get_SecurityDeclarations()
public void Dispose()
public AssemblyDefinition CreateAssembly(AssemblyNameDefinition assemblyName, string moduleName, ModuleKind kind)
public AssemblyDefinition CreateAssembly(AssemblyNameDefinition assemblyName, string moduleName, ModuleParameters parameters)
public AssemblyDefinition ReadAssembly(string fileName)
public AssemblyDefinition ReadAssembly(string fileName, ReaderParameters parameters)
public AssemblyDefinition ReadAssembly(Stream stream)
public AssemblyDefinition ReadAssembly(Stream stream, ReaderParameters parameters)
private AssemblyDefinition ReadAssembly(ModuleDefinition module)
public void Write(string fileName)
public void Write(string fileName, WriterParameters parameters)
public void Write()
public void Write(WriterParameters parameters)
public void Write(Stream stream)
public void Write(Stream stream, WriterParameters parameters)
public string ToString()
}
internal Mono.Cecil.AssemblyHashAlgorithm : Enum {
public UInt32 value__
public AssemblyHashAlgorithm None
public AssemblyHashAlgorithm MD5
public AssemblyHashAlgorithm SHA1
public AssemblyHashAlgorithm SHA256
public AssemblyHashAlgorithm SHA384
public AssemblyHashAlgorithm SHA512
public AssemblyHashAlgorithm Reserved
}
internal Mono.Cecil.AssemblyLinkedResource : Resource {
private AssemblyNameReference reference
public AssemblyNameReference Assembly
public ResourceType ResourceType
public AssemblyNameReference get_Assembly()
public void set_Assembly(AssemblyNameReference value)
public ResourceType get_ResourceType()
public void .ctor(string name, ManifestResourceAttributes flags)
public void .ctor(string name, ManifestResourceAttributes flags, AssemblyNameReference reference)
}
internal Mono.Cecil.AssemblyNameDefinition : AssemblyNameReference {
public Byte[] Hash
public Byte[] get_Hash()
public void .ctor(string name, Version version)
}
internal Mono.Cecil.AssemblyNameReference : object {
private string name
private string culture
private Version version
private UInt32 attributes
private Byte[] public_key
private Byte[] public_key_token
private AssemblyHashAlgorithm hash_algorithm
private Byte[] hash
internal MetadataToken token
private string full_name
public string Name
public string Culture
public Version Version
public AssemblyAttributes Attributes
public bool HasPublicKey
public bool IsSideBySideCompatible
public bool IsRetargetable
public bool IsWindowsRuntime
public Byte[] PublicKey
public Byte[] PublicKeyToken
public MetadataScopeType MetadataScopeType
public string FullName
public AssemblyHashAlgorithm HashAlgorithm
public Byte[] Hash
public MetadataToken MetadataToken
public string get_Name()
public void set_Name(string value)
public string get_Culture()
public void set_Culture(string value)
public Version get_Version()
public void set_Version(Version value)
public AssemblyAttributes get_Attributes()
public void set_Attributes(AssemblyAttributes value)
public bool get_HasPublicKey()
public void set_HasPublicKey(bool value)
public bool get_IsSideBySideCompatible()
public void set_IsSideBySideCompatible(bool value)
public bool get_IsRetargetable()
public void set_IsRetargetable(bool value)
public bool get_IsWindowsRuntime()
public void set_IsWindowsRuntime(bool value)
public Byte[] get_PublicKey()
public void set_PublicKey(Byte[] value)
public Byte[] get_PublicKeyToken()
public void set_PublicKeyToken(Byte[] value)
private Byte[] HashPublicKey()
public MetadataScopeType get_MetadataScopeType()
public string get_FullName()
public AssemblyNameReference Parse(string fullName)
public AssemblyHashAlgorithm get_HashAlgorithm()
public void set_HashAlgorithm(AssemblyHashAlgorithm value)
public Byte[] get_Hash()
public void set_Hash(Byte[] value)
public MetadataToken get_MetadataToken()
public void set_MetadataToken(MetadataToken value)
public void .ctor(string name, Version version)
public string ToString()
}
internal Mono.Cecil.AssemblyRefTable : MetadataTable`1<Row`9<ushort, ushort, ushort, ushort, AssemblyAttributes, UInt32, UInt32, UInt32, UInt32>> {
public void Write(TableHeapBuffer buffer)
}
internal Mono.Cecil.AssemblyResolutionException : FileNotFoundException {
private AssemblyNameReference reference
public AssemblyNameReference AssemblyReference
public AssemblyNameReference get_AssemblyReference()
public void .ctor(AssemblyNameReference reference)
public void .ctor(AssemblyNameReference reference, Exception innerException)
private void .ctor(SerializationInfo info, StreamingContext context)
}
internal Mono.Cecil.AssemblyResolveEventArgs : EventArgs {
private AssemblyNameReference reference
public AssemblyNameReference AssemblyReference
public AssemblyNameReference get_AssemblyReference()
public void .ctor(AssemblyNameReference reference)
}
internal Mono.Cecil.AssemblyResolveEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public AssemblyDefinition Invoke(object sender, AssemblyNameReference reference)
public IAsyncResult BeginInvoke(object sender, AssemblyNameReference reference, AsyncCallback callback, object object)
public AssemblyDefinition EndInvoke(IAsyncResult result)
}
internal Mono.Cecil.AssemblyTable : OneRowTable`1<Row`9<AssemblyHashAlgorithm, ushort, ushort, ushort, ushort, AssemblyAttributes, UInt32, UInt32, UInt32>> {
public void Write(TableHeapBuffer buffer)
}
internal Mono.Cecil.BaseAssemblyResolver : object {
private bool on_mono
private Collection`1<string> directories
private Collection`1<string> gac_paths
private AssemblyResolveEventHandler ResolveFailure
public void AddSearchDirectory(string directory)
public void RemoveSearchDirectory(string directory)
public String[] GetSearchDirectories()
public void add_ResolveFailure(AssemblyResolveEventHandler value)
public void remove_ResolveFailure(AssemblyResolveEventHandler value)
private AssemblyDefinition GetAssembly(string file, ReaderParameters parameters)
public AssemblyDefinition Resolve(AssemblyNameReference name)
public AssemblyDefinition Resolve(AssemblyNameReference name, ReaderParameters parameters)
protected AssemblyDefinition SearchDirectory(AssemblyNameReference name, IEnumerable`1<string> directories, ReaderParameters parameters)
private bool IsZero(Version version)
private AssemblyDefinition GetCorlib(AssemblyNameReference reference, ReaderParameters parameters)
private Collection`1<string> GetGacPaths()
private Collection`1<string> GetDefaultMonoGacPaths()
private string GetCurrentMonoGac()
private AssemblyDefinition GetAssemblyInGac(AssemblyNameReference reference, ReaderParameters parameters)
private AssemblyDefinition GetAssemblyInMonoGac(AssemblyNameReference reference, ReaderParameters parameters)
private AssemblyDefinition GetAssemblyInNetGac(AssemblyNameReference reference, ReaderParameters parameters)
private string GetAssemblyFile(AssemblyNameReference reference, string prefix, string gac)
public void Dispose()
protected void Dispose(bool disposing)
}
internal Mono.Cecil.ByReferenceType : TypeSpecification {
public string Name
public string FullName
public bool IsValueType
public bool IsByReference
public string get_Name()
public string get_FullName()
public bool get_IsValueType()
public void set_IsValueType(bool value)
public bool get_IsByReference()
public void .ctor(TypeReference type)
}
internal Mono.Cecil.CallSite : object {
private MethodReference signature
public bool HasThis
public bool ExplicitThis
public MethodCallingConvention CallingConvention
public bool HasParameters
public Collection`1<ParameterDefinition> Parameters
public TypeReference ReturnType
public MethodReturnType MethodReturnType
public string Name
public string Namespace
public ModuleDefinition Module
public IMetadataScope Scope
public MetadataToken MetadataToken
public string FullName
public bool get_HasThis()
public void set_HasThis(bool value)
public bool get_ExplicitThis()
public void set_ExplicitThis(bool value)
public MethodCallingConvention get_CallingConvention()
public void set_CallingConvention(MethodCallingConvention value)
public bool get_HasParameters()
public Collection`1<ParameterDefinition> get_Parameters()
public TypeReference get_ReturnType()
public void set_ReturnType(TypeReference value)
public MethodReturnType get_MethodReturnType()
public string get_Name()
public void set_Name(string value)
public string get_Namespace()
public void set_Namespace(string value)
public ModuleDefinition get_Module()
public IMetadataScope get_Scope()
public MetadataToken get_MetadataToken()
public void set_MetadataToken(MetadataToken value)
public string get_FullName()
public void .ctor(TypeReference returnType)
public string ToString()
}
internal Mono.Cecil.Cil.AsyncMethodBodyDebugInformation : CustomDebugInformation {
internal InstructionOffset catch_handler
internal Collection`1<InstructionOffset> yields
internal Collection`1<InstructionOffset> resumes
internal Collection`1<MethodDefinition> resume_methods
public Guid KindIdentifier
public InstructionOffset CatchHandler
public Collection`1<InstructionOffset> Yields
public Collection`1<InstructionOffset> Resumes
public Collection`1<MethodDefinition> ResumeMethods
public CustomDebugInformationKind Kind
public InstructionOffset get_CatchHandler()
public void set_CatchHandler(InstructionOffset value)
public Collection`1<InstructionOffset> get_Yields()
public Collection`1<InstructionOffset> get_Resumes()
public Collection`1<MethodDefinition> get_ResumeMethods()
public CustomDebugInformationKind get_Kind()
internal void .ctor(int catchHandler)
public void .ctor(Instruction catchHandler)
}
internal Mono.Cecil.Cil.BinaryCustomDebugInformation : CustomDebugInformation {
private Byte[] data
public Byte[] Data
public CustomDebugInformationKind Kind
public Byte[] get_Data()
public void set_Data(Byte[] value)
public CustomDebugInformationKind get_Kind()
public void .ctor(Guid identifier, Byte[] data)
}
internal Mono.Cecil.Cil.Code : Enum {
public int value__
public Code Nop
public Code Break
public Code Ldarg_0
public Code Ldarg_1
public Code Ldarg_2
public Code Ldarg_3
public Code Ldloc_0
public Code Ldloc_1
public Code Ldloc_2
public Code Ldloc_3
public Code Stloc_0
public Code Stloc_1
public Code Stloc_2
public Code Stloc_3
public Code Ldarg_S
public Code Ldarga_S
public Code Starg_S
public Code Ldloc_S
public Code Ldloca_S
public Code Stloc_S
public Code Ldnull
public Code Ldc_I4_M1
public Code Ldc_I4_0
public Code Ldc_I4_1
public Code Ldc_I4_2
public Code Ldc_I4_3
public Code Ldc_I4_4
public Code Ldc_I4_5
public Code Ldc_I4_6
public Code Ldc_I4_7
public Code Ldc_I4_8
public Code Ldc_I4_S
public Code Ldc_I4
public Code Ldc_I8
public Code Ldc_R4
public Code Ldc_R8
public Code Dup
public Code Pop
public Code Jmp
public Code Call
public Code Calli
public Code Ret
public Code Br_S
public Code Brfalse_S
public Code Brtrue_S
public Code Beq_S
public Code Bge_S
public Code Bgt_S
public Code Ble_S
public Code Blt_S
public Code Bne_Un_S
public Code Bge_Un_S
public Code Bgt_Un_S
public Code Ble_Un_S
public Code Blt_Un_S
public Code Br
public Code Brfalse
public Code Brtrue
public Code Beq
public Code Bge
public Code Bgt
public Code Ble
public Code Blt
public Code Bne_Un
public Code Bge_Un
public Code Bgt_Un
public Code Ble_Un
public Code Blt_Un
public Code Switch
public Code Ldind_I1
public Code Ldind_U1
public Code Ldind_I2
public Code Ldind_U2
public Code Ldind_I4
public Code Ldind_U4
public Code Ldind_I8
public Code Ldind_I
public Code Ldind_R4
public Code Ldind_R8
public Code Ldind_Ref
public Code Stind_Ref
public Code Stind_I1
public Code Stind_I2
public Code Stind_I4
public Code Stind_I8
public Code Stind_R4
public Code Stind_R8
public Code Add
public Code Sub
public Code Mul
public Code Div
public Code Div_Un
public Code Rem
public Code Rem_Un
public Code And
public Code Or
public Code Xor
public Code Shl
public Code Shr
public Code Shr_Un
public Code Neg
public Code Not
public Code Conv_I1
public Code Conv_I2
public Code Conv_I4
public Code Conv_I8
public Code Conv_R4
public Code Conv_R8
public Code Conv_U4
public Code Conv_U8
public Code Callvirt
public Code Cpobj
public Code Ldobj
public Code Ldstr
public Code Newobj
public Code Castclass
public Code Isinst
public Code Conv_R_Un
public Code Unbox
public Code Throw
public Code Ldfld
public Code Ldflda
public Code Stfld
public Code Ldsfld
public Code Ldsflda
public Code Stsfld
public Code Stobj
public Code Conv_Ovf_I1_Un
public Code Conv_Ovf_I2_Un
public Code Conv_Ovf_I4_Un
public Code Conv_Ovf_I8_Un
public Code Conv_Ovf_U1_Un
public Code Conv_Ovf_U2_Un
public Code Conv_Ovf_U4_Un
public Code Conv_Ovf_U8_Un
public Code Conv_Ovf_I_Un
public Code Conv_Ovf_U_Un
public Code Box
public Code Newarr
public Code Ldlen
public Code Ldelema
public Code Ldelem_I1
public Code Ldelem_U1
public Code Ldelem_I2
public Code Ldelem_U2
public Code Ldelem_I4
public Code Ldelem_U4
public Code Ldelem_I8
public Code Ldelem_I
public Code Ldelem_R4
public Code Ldelem_R8
public Code Ldelem_Ref
public Code Stelem_I
public Code Stelem_I1
public Code Stelem_I2
public Code Stelem_I4
public Code Stelem_I8
public Code Stelem_R4
public Code Stelem_R8
public Code Stelem_Ref
public Code Ldelem_Any
public Code Stelem_Any
public Code Unbox_Any
public Code Conv_Ovf_I1
public Code Conv_Ovf_U1
public Code Conv_Ovf_I2
public Code Conv_Ovf_U2
public Code Conv_Ovf_I4
public Code Conv_Ovf_U4
public Code Conv_Ovf_I8
public Code Conv_Ovf_U8
public Code Refanyval
public Code Ckfinite
public Code Mkrefany
public Code Ldtoken
public Code Conv_U2
public Code Conv_U1
public Code Conv_I
public Code Conv_Ovf_I
public Code Conv_Ovf_U
public Code Add_Ovf
public Code Add_Ovf_Un
public Code Mul_Ovf
public Code Mul_Ovf_Un
public Code Sub_Ovf
public Code Sub_Ovf_Un
public Code Endfinally
public Code Leave
public Code Leave_S
public Code Stind_I
public Code Conv_U
public Code Arglist
public Code Ceq
public Code Cgt
public Code Cgt_Un
public Code Clt
public Code Clt_Un
public Code Ldftn
public Code Ldvirtftn
public Code Ldarg
public Code Ldarga
public Code Starg
public Code Ldloc
public Code Ldloca
public Code Stloc
public Code Localloc
public Code Endfilter
public Code Unaligned
public Code Volatile
public Code Tail
public Code Initobj
public Code Constrained
public Code Cpblk
public Code Initblk
public Code No
public Code Rethrow
public Code Sizeof
public Code Refanytype
public Code Readonly
}
internal Mono.Cecil.Cil.CodeReader : BinaryStreamReader {
internal MetadataReader reader
private int start
private MethodDefinition method
private MethodBody body
private int Offset
private int get_Offset()
public void .ctor(MetadataReader reader)
public int MoveTo(MethodDefinition method)
public void MoveBackTo(int position)
public MethodBody ReadMethodBody(MethodDefinition method)
public int ReadCodeSize(MethodDefinition method)
private int ReadCodeSize()
private void ReadMethodBody()
private void ReadFatMethod()
public VariableDefinitionCollection ReadVariables(MetadataToken local_var_token)
private void ReadCode()
private OpCode ReadOpCode()
private object ReadOperand(Instruction instruction)
public string GetString(MetadataToken token)
public ParameterDefinition GetParameter(int index)
public VariableDefinition GetVariable(int index)
public CallSite GetCallSite(MetadataToken token)
private void ResolveBranches(Collection`1<Instruction> instructions)
private Instruction GetInstruction(int offset)
private Instruction GetInstruction(Collection`1<Instruction> instructions, int offset)
private void ReadSection()
private void ReadSmallSection()
private void ReadFatSection()
private void ReadExceptionHandlers(int count, Func`1<int> read_entry, Func`1<int> read_length)
private void ReadExceptionHandlerSpecific(ExceptionHandler handler)
public MetadataToken ReadToken()
private void ReadDebugInfo()
private void ReadCustomDebugInformations(MethodDefinition method)
private void ReadAsyncMethodBody(AsyncMethodBodyDebugInformation async_method)
private void ReadStateMachineScope(StateMachineScopeDebugInformation state_machine_scope)
private void ReadSequencePoints()
private void ReadScopes(Collection`1<ScopeDebugInformation> scopes)
private void ReadScope(ScopeDebugInformation scope)
public ByteBuffer PatchRawMethodBody(MethodDefinition method, CodeWriter writer, Int32& code_size, MetadataToken& local_var_token)
private void PatchRawFatMethod(ByteBuffer buffer, CodeWriter writer, Int32& code_size, MetadataToken& local_var_token)
private void PatchRawCode(ByteBuffer buffer, int code_size, CodeWriter writer)
private void PatchRawSection(ByteBuffer buffer, MetadataBuilder metadata)
private void PatchRawSmallSection(ByteBuffer buffer, MetadataBuilder metadata)
private void PatchRawFatSection(ByteBuffer buffer, MetadataBuilder metadata)
private void PatchRawExceptionHandlers(ByteBuffer buffer, MetadataBuilder metadata, int count, bool fat_entry)
private int <ReadSmallSection>b__26_0()
private int <ReadSmallSection>b__26_1()
}
internal Mono.Cecil.Cil.CodeWriter : ByteBuffer {
private UInt32 code_base
internal MetadataBuilder metadata
private Dictionary`2<UInt32, MetadataToken> standalone_signatures
private Dictionary`2<ByteBuffer, UInt32> tiny_method_bodies
private MethodBody body
public void .ctor(MetadataBuilder metadata)
public UInt32 WriteMethodBody(MethodDefinition method)
private bool IsEmptyMethodBody(MethodBody body)
private bool IsUnresolved(MethodDefinition method)
private UInt32 WriteUnresolvedMethodBody(MethodDefinition method)
private UInt32 WriteResolvedMethodBody(MethodDefinition method)
private bool GetOrMapTinyMethodBody(ByteBuffer body, UInt32& rva)
private void WriteFatHeader()
private void WriteInstructions()
private void WriteOpCode(OpCode opcode)
private void WriteOperand(Instruction instruction)
private int GetTargetOffset(Instruction instruction)
private UInt32 GetUserStringIndex(string string)
private int GetVariableIndex(VariableDefinition variable)
private int GetParameterIndex(ParameterDefinition parameter)
private bool RequiresFatHeader()
private void ComputeHeader()
private void ComputeExceptionHandlerStackSize(Dictionary`2& stack_sizes)
private void AddExceptionStackSize(Instruction handler_start, Dictionary`2& stack_sizes)
private void ComputeStackSize(Instruction instruction, Dictionary`2& stack_sizes, Int32& stack_size, Int32& max_stack)
private void CopyBranchStackSize(Instruction instruction, Dictionary`2& stack_sizes, int stack_size)
private void CopyBranchStackSize(Dictionary`2& stack_sizes, Instruction target, int stack_size)
private void ComputeStackSize(Instruction instruction, Int32& stack_size)
private void ComputeStackDelta(Instruction instruction, Int32& stack_size)
private void ComputePopDelta(StackBehaviour pop_behavior, Int32& stack_size)
private void ComputePushDelta(StackBehaviour push_behaviour, Int32& stack_size)
private void WriteExceptionHandlers()
private bool RequiresFatSection(Collection`1<ExceptionHandler> handlers)
private bool IsFatRange(Instruction start, Instruction end)
private void WriteSmallSection(Collection`1<ExceptionHandler> handlers)
private void WriteFatSection(Collection`1<ExceptionHandler> handlers)
private void WriteExceptionHandlers(Collection`1<ExceptionHandler> handlers, Action`1<int> write_entry, Action`1<int> write_length)
private void WriteExceptionHandlerSpecific(ExceptionHandler handler)
public MetadataToken GetStandAloneSignature(Collection`1<VariableDefinition> variables)
public MetadataToken GetStandAloneSignature(CallSite call_site)
private MetadataToken GetStandAloneSignatureToken(UInt32 signature)
private UInt32 BeginMethod()
private void WriteMetadataToken(MetadataToken token)
private void Align(int align)
private void <WriteSmallSection>b__34_0(int i)
private void <WriteSmallSection>b__34_1(int i)
}
internal Mono.Cecil.Cil.ConstantDebugInformation : DebugInformation {
private string name
private TypeReference constant_type
private object value
public string Name
public TypeReference ConstantType
public object Value
public string get_Name()
public void set_Name(string value)
public TypeReference get_ConstantType()
public void set_ConstantType(TypeReference value)
public object get_Value()
public void set_Value(object value)
public void .ctor(string name, TypeReference constant_type, object value)
}
internal Mono.Cecil.Cil.CustomDebugInformation : DebugInformation {
private Guid identifier
public Guid Identifier
public CustomDebugInformationKind Kind
public Guid get_Identifier()
public CustomDebugInformationKind get_Kind()
internal void .ctor(Guid identifier)
}
internal Mono.Cecil.Cil.CustomDebugInformationKind : Enum {
public int value__
public CustomDebugInformationKind Binary
public CustomDebugInformationKind StateMachineScope
public CustomDebugInformationKind DynamicVariable
public CustomDebugInformationKind DefaultNamespace
public CustomDebugInformationKind AsyncMethodBody
public CustomDebugInformationKind EmbeddedSource
public CustomDebugInformationKind SourceLink
}
internal Mono.Cecil.Cil.DebugInformation : object {
internal MetadataToken token
internal Collection`1<CustomDebugInformation> custom_infos
public MetadataToken MetadataToken
public bool HasCustomDebugInformations
public Collection`1<CustomDebugInformation> CustomDebugInformations
public MetadataToken get_MetadataToken()
public void set_MetadataToken(MetadataToken value)
public bool get_HasCustomDebugInformations()
public Collection`1<CustomDebugInformation> get_CustomDebugInformations()
}
internal Mono.Cecil.Cil.DefaultSymbolReaderProvider : object {
private bool throw_if_no_symbol
public void .ctor(bool throwIfNoSymbol)
public ISymbolReader GetSymbolReader(ModuleDefinition module, string fileName)
public ISymbolReader GetSymbolReader(ModuleDefinition module, Stream symbolStream)
}
internal Mono.Cecil.Cil.DefaultSymbolWriterProvider : object {
public ISymbolWriter GetSymbolWriter(ModuleDefinition module, string fileName)
public ISymbolWriter GetSymbolWriter(ModuleDefinition module, Stream symbolStream)
}
internal Mono.Cecil.Cil.Document : DebugInformation {
private string url
private Guid type
private Guid hash_algorithm
private Guid language
private Guid language_vendor
private Byte[] hash
private Byte[] embedded_source
public string Url
public DocumentType Type
public Guid TypeGuid
public DocumentHashAlgorithm HashAlgorithm
public Guid HashAlgorithmGuid
public DocumentLanguage Language
public Guid LanguageGuid
public DocumentLanguageVendor LanguageVendor
public Guid LanguageVendorGuid
public Byte[] Hash
public Byte[] EmbeddedSource
public string get_Url()
public void set_Url(string value)
public DocumentType get_Type()
public void set_Type(DocumentType value)
public Guid get_TypeGuid()
public void set_TypeGuid(Guid value)
public DocumentHashAlgorithm get_HashAlgorithm()
public void set_HashAlgorithm(DocumentHashAlgorithm value)
public Guid get_HashAlgorithmGuid()
public void set_HashAlgorithmGuid(Guid value)
public DocumentLanguage get_Language()
public void set_Language(DocumentLanguage value)
public Guid get_LanguageGuid()
public void set_LanguageGuid(Guid value)
public DocumentLanguageVendor get_LanguageVendor()
public void set_LanguageVendor(DocumentLanguageVendor value)
public Guid get_LanguageVendorGuid()
public void set_LanguageVendorGuid(Guid value)
public Byte[] get_Hash()
public void set_Hash(Byte[] value)
public Byte[] get_EmbeddedSource()
public void set_EmbeddedSource(Byte[] value)
public void .ctor(string url)
}
internal Mono.Cecil.Cil.DocumentHashAlgorithm : Enum {
public int value__
public DocumentHashAlgorithm None
public DocumentHashAlgorithm MD5
public DocumentHashAlgorithm SHA1
public DocumentHashAlgorithm SHA256
}
internal Mono.Cecil.Cil.DocumentLanguage : Enum {
public int value__
public DocumentLanguage Other
public DocumentLanguage C
public DocumentLanguage Cpp
public DocumentLanguage CSharp
public DocumentLanguage Basic
public DocumentLanguage Java
public DocumentLanguage Cobol
public DocumentLanguage Pascal
public DocumentLanguage Cil
public DocumentLanguage JScript
public DocumentLanguage Smc
public DocumentLanguage MCpp
public DocumentLanguage FSharp
}
internal Mono.Cecil.Cil.DocumentLanguageVendor : Enum {
public int value__
public DocumentLanguageVendor Other
public DocumentLanguageVendor Microsoft
}
internal Mono.Cecil.Cil.DocumentType : Enum {
public int value__
public DocumentType Other
public DocumentType Text
}
internal Mono.Cecil.Cil.EmbeddedPortablePdbReader : object {
private PortablePdbReader reader
internal void .ctor(PortablePdbReader reader)
public ISymbolWriterProvider GetWriterProvider()
public bool ProcessDebugHeader(ImageDebugHeader header)
public MethodDebugInformation Read(MethodDefinition method)
public void Dispose()
}
internal Mono.Cecil.Cil.EmbeddedPortablePdbReaderProvider : object {
public ISymbolReader GetSymbolReader(ModuleDefinition module, string fileName)
private Stream GetPortablePdbStream(ImageDebugHeaderEntry entry)
public ISymbolReader GetSymbolReader(ModuleDefinition module, Stream symbolStream)
}
internal Mono.Cecil.Cil.EmbeddedPortablePdbWriter : object {
private Stream stream
private PortablePdbWriter writer
internal void .ctor(Stream stream, PortablePdbWriter writer)
public ISymbolReaderProvider GetReaderProvider()
public void Write(MethodDebugInformation info)
public ImageDebugHeader GetDebugHeader()
public void Write()
public void Dispose()
}
internal Mono.Cecil.Cil.EmbeddedPortablePdbWriterProvider : object {
public ISymbolWriter GetSymbolWriter(ModuleDefinition module, string fileName)
public ISymbolWriter GetSymbolWriter(ModuleDefinition module, Stream symbolStream)
}
internal Mono.Cecil.Cil.EmbeddedSourceDebugInformation : CustomDebugInformation {
internal UInt32 index
internal MetadataReader debug_reader
internal bool resolved
internal Byte[] content
internal bool compress
public Guid KindIdentifier
public Byte[] Content
public bool Compress
public CustomDebugInformationKind Kind
public Byte[] get_Content()
public void set_Content(Byte[] value)
public bool get_Compress()
public void set_Compress(bool value)
public CustomDebugInformationKind get_Kind()
internal void .ctor(UInt32 index, MetadataReader debug_reader)
public void .ctor(Byte[] content, bool compress)
internal Byte[] ReadRawEmbeddedSourceDebugInformation()
private void Resolve()
}
internal Mono.Cecil.Cil.ExceptionHandler : object {
private Instruction try_start
private Instruction try_end
private Instruction filter_start
private Instruction handler_start
private Instruction handler_end
private TypeReference catch_type
private ExceptionHandlerType handler_type
public Instruction TryStart
public Instruction TryEnd
public Instruction FilterStart
public Instruction HandlerStart
public Instruction HandlerEnd
public TypeReference CatchType
public ExceptionHandlerType HandlerType
public Instruction get_TryStart()
public void set_TryStart(Instruction value)
public Instruction get_TryEnd()
public void set_TryEnd(Instruction value)
public Instruction get_FilterStart()
public void set_FilterStart(Instruction value)
public Instruction get_HandlerStart()
public void set_HandlerStart(Instruction value)
public Instruction get_HandlerEnd()
public void set_HandlerEnd(Instruction value)
public TypeReference get_CatchType()
public void set_CatchType(TypeReference value)
public ExceptionHandlerType get_HandlerType()
public void set_HandlerType(ExceptionHandlerType value)
public void .ctor(ExceptionHandlerType handlerType)
}
internal Mono.Cecil.Cil.ExceptionHandlerType : Enum {
public int value__
public ExceptionHandlerType Catch
public ExceptionHandlerType Filter
public ExceptionHandlerType Finally
public ExceptionHandlerType Fault
}
internal Mono.Cecil.Cil.FlowControl : Enum {
public int value__
public FlowControl Branch
public FlowControl Break
public FlowControl Call
public FlowControl Cond_Branch
public FlowControl Meta
public FlowControl Next
public FlowControl Phi
public FlowControl Return
public FlowControl Throw
}
internal Mono.Cecil.Cil.ICustomDebugInformationProvider {
public bool HasCustomDebugInformations
public Collection`1<CustomDebugInformation> CustomDebugInformations
public bool get_HasCustomDebugInformations()
public Collection`1<CustomDebugInformation> get_CustomDebugInformations()
}
internal Mono.Cecil.Cil.ILProcessor : object {
private MethodBody body
private Collection`1<Instruction> instructions
public MethodBody Body
public MethodBody get_Body()
internal void .ctor(MethodBody body)
public Instruction Create(OpCode opcode)
public Instruction Create(OpCode opcode, TypeReference type)
public Instruction Create(OpCode opcode, CallSite site)
public Instruction Create(OpCode opcode, MethodReference method)
public Instruction Create(OpCode opcode, FieldReference field)
public Instruction Create(OpCode opcode, string value)
public Instruction Create(OpCode opcode, sbyte value)
public Instruction Create(OpCode opcode, byte value)
public Instruction Create(OpCode opcode, int value)
public Instruction Create(OpCode opcode, long value)
public Instruction Create(OpCode opcode, float value)
public Instruction Create(OpCode opcode, double value)
public Instruction Create(OpCode opcode, Instruction target)
public Instruction Create(OpCode opcode, Instruction[] targets)
public Instruction Create(OpCode opcode, VariableDefinition variable)
public Instruction Create(OpCode opcode, ParameterDefinition parameter)
public void Emit(OpCode opcode)
public void Emit(OpCode opcode, TypeReference type)
public void Emit(OpCode opcode, MethodReference method)
public void Emit(OpCode opcode, CallSite site)
public void Emit(OpCode opcode, FieldReference field)
public void Emit(OpCode opcode, string value)
public void Emit(OpCode opcode, byte value)
public void Emit(OpCode opcode, sbyte value)
public void Emit(OpCode opcode, int value)
public void Emit(OpCode opcode, long value)
public void Emit(OpCode opcode, float value)
public void Emit(OpCode opcode, double value)
public void Emit(OpCode opcode, Instruction target)
public void Emit(OpCode opcode, Instruction[] targets)
public void Emit(OpCode opcode, VariableDefinition variable)
public void Emit(OpCode opcode, ParameterDefinition parameter)
public void InsertBefore(Instruction target, Instruction instruction)
public void InsertAfter(Instruction target, Instruction instruction)
public void InsertAfter(int index, Instruction instruction)
public void Append(Instruction instruction)
public void Replace(Instruction target, Instruction instruction)
public void Replace(int index, Instruction instruction)
public void Remove(Instruction instruction)
public void RemoveAt(int index)
public void Clear()
}
internal Mono.Cecil.Cil.ImageDebugDirectory : ValueType {
public int Size
public int Characteristics
public int TimeDateStamp
public short MajorVersion
public short MinorVersion
public ImageDebugType Type
public int SizeOfData
public int AddressOfRawData
public int PointerToRawData
}
internal Mono.Cecil.Cil.ImageDebugHeader : object {
private ImageDebugHeaderEntry[] entries
public bool HasEntries
public ImageDebugHeaderEntry[] Entries
public bool get_HasEntries()
public ImageDebugHeaderEntry[] get_Entries()
public void .ctor(ImageDebugHeaderEntry[] entries)
public void .ctor(ImageDebugHeaderEntry entry)
}
internal Mono.Cecil.Cil.ImageDebugHeaderEntry : object {
private ImageDebugDirectory directory
private Byte[] data
public ImageDebugDirectory Directory
public Byte[] Data
public ImageDebugDirectory get_Directory()
internal void set_Directory(ImageDebugDirectory value)
public Byte[] get_Data()
public void .ctor(ImageDebugDirectory directory, Byte[] data)
}
internal Mono.Cecil.Cil.ImageDebugType : Enum {
public int value__
public ImageDebugType CodeView
public ImageDebugType Deterministic
public ImageDebugType EmbeddedPortablePdb
public ImageDebugType PdbChecksum
}
internal Mono.Cecil.Cil.ImportDebugInformation : DebugInformation {
internal ImportDebugInformation parent
internal Collection`1<ImportTarget> targets
public bool HasTargets
public Collection`1<ImportTarget> Targets
public ImportDebugInformation Parent
public bool get_HasTargets()
public Collection`1<ImportTarget> get_Targets()
public ImportDebugInformation get_Parent()
public void set_Parent(ImportDebugInformation value)
}
internal Mono.Cecil.Cil.ImportTarget : object {
internal ImportTargetKind kind
internal string namespace
internal TypeReference type
internal AssemblyNameReference reference
internal string alias
public string Namespace
public TypeReference Type
public AssemblyNameReference AssemblyReference
public string Alias
public ImportTargetKind Kind
public string get_Namespace()
public void set_Namespace(string value)
public TypeReference get_Type()
public void set_Type(TypeReference value)
public AssemblyNameReference get_AssemblyReference()
public void set_AssemblyReference(AssemblyNameReference value)
public string get_Alias()
public void set_Alias(string value)
public ImportTargetKind get_Kind()
public void set_Kind(ImportTargetKind value)
public void .ctor(ImportTargetKind kind)
}
internal Mono.Cecil.Cil.ImportTargetKind : Enum {
public byte value__
public ImportTargetKind ImportNamespace
public ImportTargetKind ImportNamespaceInAssembly
public ImportTargetKind ImportType
public ImportTargetKind ImportXmlNamespaceWithAlias
public ImportTargetKind ImportAlias
public ImportTargetKind DefineAssemblyAlias
public ImportTargetKind DefineNamespaceAlias
public ImportTargetKind DefineNamespaceInAssemblyAlias
public ImportTargetKind DefineTypeAlias
}
internal Mono.Cecil.Cil.Instruction : object {
internal int offset
internal OpCode opcode
internal object operand
internal Instruction previous
internal Instruction next
public int Offset
public OpCode OpCode
public object Operand
public Instruction Previous
public Instruction Next
public int get_Offset()
public void set_Offset(int value)
public OpCode get_OpCode()
public void set_OpCode(OpCode value)
public object get_Operand()
public void set_Operand(object value)
public Instruction get_Previous()
public void set_Previous(Instruction value)
public Instruction get_Next()
public void set_Next(Instruction value)
internal void .ctor(int offset, OpCode opCode)
internal void .ctor(OpCode opcode, object operand)
public int GetSize()
public string ToString()
private void AppendLabel(StringBuilder builder, Instruction instruction)
public Instruction Create(OpCode opcode)
public Instruction Create(OpCode opcode, TypeReference type)
public Instruction Create(OpCode opcode, CallSite site)
public Instruction Create(OpCode opcode, MethodReference method)
public Instruction Create(OpCode opcode, FieldReference field)
public Instruction Create(OpCode opcode, string value)
public Instruction Create(OpCode opcode, sbyte value)
public Instruction Create(OpCode opcode, byte value)
public Instruction Create(OpCode opcode, int value)
public Instruction Create(OpCode opcode, long value)
public Instruction Create(OpCode opcode, float value)
public Instruction Create(OpCode opcode, double value)
public Instruction Create(OpCode opcode, Instruction target)
public Instruction Create(OpCode opcode, Instruction[] targets)
public Instruction Create(OpCode opcode, VariableDefinition variable)
public Instruction Create(OpCode opcode, ParameterDefinition parameter)
}
internal Mono.Cecil.Cil.InstructionCollection : Collection`1<Instruction> {
private MethodDefinition method
internal void .ctor(MethodDefinition method)
internal void .ctor(MethodDefinition method, int capacity)
protected void OnAdd(Instruction item, int index)
protected void OnInsert(Instruction item, int index)
protected void OnSet(Instruction item, int index)
protected void OnRemove(Instruction item, int index)
private void RemoveSequencePoint(Instruction instruction)
private void UpdateDebugInformation(Instruction removedInstruction, Instruction existingInstruction)
private void UpdateLocalScope(ScopeDebugInformation scope, InstructionOffsetResolver& resolver)
private void UpdateStateMachineScope(StateMachineScopeDebugInformation debugInfo, InstructionOffsetResolver& resolver)
private void UpdateAsyncMethodBody(AsyncMethodBodyDebugInformation debugInfo, InstructionOffsetResolver& resolver)
}
internal Mono.Cecil.Cil.InstructionOffset : ValueType {
private Instruction instruction
private Nullable`1<int> offset
public int Offset
public bool IsEndOfMethod
internal bool IsResolved
internal Instruction ResolvedInstruction
public int get_Offset()
public bool get_IsEndOfMethod()
internal bool get_IsResolved()
internal Instruction get_ResolvedInstruction()
public void .ctor(Instruction instruction)
public void .ctor(int offset)
}
internal Mono.Cecil.Cil.ISymbolReader {
public ISymbolWriterProvider GetWriterProvider()
public bool ProcessDebugHeader(ImageDebugHeader header)
public MethodDebugInformation Read(MethodDefinition method)
}
internal Mono.Cecil.Cil.ISymbolReaderProvider {
public ISymbolReader GetSymbolReader(ModuleDefinition module, string fileName)
public ISymbolReader GetSymbolReader(ModuleDefinition module, Stream symbolStream)
}
internal Mono.Cecil.Cil.ISymbolWriter {
public ISymbolReaderProvider GetReaderProvider()
public ImageDebugHeader GetDebugHeader()
public void Write(MethodDebugInformation info)
public void Write()
}
internal Mono.Cecil.Cil.ISymbolWriterProvider {
public ISymbolWriter GetSymbolWriter(ModuleDefinition module, string fileName)
public ISymbolWriter GetSymbolWriter(ModuleDefinition module, Stream symbolStream)
}
internal Mono.Cecil.Cil.MethodBody : object {
internal MethodDefinition method
internal ParameterDefinition this_parameter
internal int max_stack_size
internal int code_size
internal bool init_locals
internal MetadataToken local_var_token
internal Collection`1<Instruction> instructions
internal Collection`1<ExceptionHandler> exceptions
internal Collection`1<VariableDefinition> variables
public MethodDefinition Method
public int MaxStackSize
public int CodeSize
public bool InitLocals
public MetadataToken LocalVarToken
public Collection`1<Instruction> Instructions
public bool HasExceptionHandlers
public Collection`1<ExceptionHandler> ExceptionHandlers
public bool HasVariables
public Collection`1<VariableDefinition> Variables
public ParameterDefinition ThisParameter
public MethodDefinition get_Method()
public int get_MaxStackSize()
public void set_MaxStackSize(int value)
public int get_CodeSize()
public bool get_InitLocals()
public void set_InitLocals(bool value)
public MetadataToken get_LocalVarToken()
public void set_LocalVarToken(MetadataToken value)
public Collection`1<Instruction> get_Instructions()
public bool get_HasExceptionHandlers()
public Collection`1<ExceptionHandler> get_ExceptionHandlers()
public bool get_HasVariables()
public Collection`1<VariableDefinition> get_Variables()
public ParameterDefinition get_ThisParameter()
private ParameterDefinition CreateThisParameter(MethodDefinition method)
public void .ctor(MethodDefinition method)
public ILProcessor GetILProcessor()
}
internal Mono.Cecil.Cil.MethodDebugInformation : DebugInformation {
internal MethodDefinition method
internal Collection`1<SequencePoint> sequence_points
internal ScopeDebugInformation scope
internal MethodDefinition kickoff_method
internal int code_size
internal MetadataToken local_var_token
public MethodDefinition Method
public bool HasSequencePoints
public Collection`1<SequencePoint> SequencePoints
public ScopeDebugInformation Scope
public MethodDefinition StateMachineKickOffMethod
public MethodDefinition get_Method()
public bool get_HasSequencePoints()
public Collection`1<SequencePoint> get_SequencePoints()
public ScopeDebugInformation get_Scope()
public void set_Scope(ScopeDebugInformation value)
public MethodDefinition get_StateMachineKickOffMethod()
public void set_StateMachineKickOffMethod(MethodDefinition value)
internal void .ctor(MethodDefinition method)
public SequencePoint GetSequencePoint(Instruction instruction)
public IDictionary`2<Instruction, SequencePoint> GetSequencePointMapping()
public IEnumerable`1<ScopeDebugInformation> GetScopes()
private IEnumerable`1<ScopeDebugInformation> GetScopes(IList`1<ScopeDebugInformation> scopes)
public bool TryGetName(VariableDefinition variable, String& name)
}
internal Mono.Cecil.Cil.OpCode : ValueType {
private byte op1
private byte op2
private byte code
private byte flow_control
private byte opcode_type
private byte operand_type
private byte stack_behavior_pop
private byte stack_behavior_push
public string Name
public int Size
public byte Op1
public byte Op2
public short Value
public Code Code
public FlowControl FlowControl
public OpCodeType OpCodeType
public OperandType OperandType
public StackBehaviour StackBehaviourPop
public StackBehaviour StackBehaviourPush
public string get_Name()
public int get_Size()
public byte get_Op1()
public byte get_Op2()
public short get_Value()
public Code get_Code()
public FlowControl get_FlowControl()
public OpCodeType get_OpCodeType()
public OperandType get_OperandType()
public StackBehaviour get_StackBehaviourPop()
public StackBehaviour get_StackBehaviourPush()
internal void .ctor(int x, int y)
public int GetHashCode()
public bool Equals(object obj)
public bool Equals(OpCode opcode)
public bool op_Equality(OpCode one, OpCode other)
public bool op_Inequality(OpCode one, OpCode other)
public string ToString()
}
internal Mono.Cecil.Cil.OpCodeNames : object {
internal String[] names
}
internal Mono.Cecil.Cil.OpCodes : object {
internal OpCode[] OneByteOpCode
internal OpCode[] TwoBytesOpCode
public OpCode Nop
public OpCode Break
public OpCode Ldarg_0
public OpCode Ldarg_1
public OpCode Ldarg_2
public OpCode Ldarg_3
public OpCode Ldloc_0
public OpCode Ldloc_1
public OpCode Ldloc_2
public OpCode Ldloc_3
public OpCode Stloc_0
public OpCode Stloc_1
public OpCode Stloc_2
public OpCode Stloc_3
public OpCode Ldarg_S
public OpCode Ldarga_S
public OpCode Starg_S
public OpCode Ldloc_S
public OpCode Ldloca_S
public OpCode Stloc_S
public OpCode Ldnull
public OpCode Ldc_I4_M1
public OpCode Ldc_I4_0
public OpCode Ldc_I4_1
public OpCode Ldc_I4_2
public OpCode Ldc_I4_3
public OpCode Ldc_I4_4
public OpCode Ldc_I4_5
public OpCode Ldc_I4_6
public OpCode Ldc_I4_7
public OpCode Ldc_I4_8
public OpCode Ldc_I4_S
public OpCode Ldc_I4
public OpCode Ldc_I8
public OpCode Ldc_R4
public OpCode Ldc_R8
public OpCode Dup
public OpCode Pop
public OpCode Jmp
public OpCode Call
public OpCode Calli
public OpCode Ret
public OpCode Br_S
public OpCode Brfalse_S
public OpCode Brtrue_S
public OpCode Beq_S
public OpCode Bge_S
public OpCode Bgt_S
public OpCode Ble_S
public OpCode Blt_S
public OpCode Bne_Un_S
public OpCode Bge_Un_S
public OpCode Bgt_Un_S
public OpCode Ble_Un_S
public OpCode Blt_Un_S
public OpCode Br
public OpCode Brfalse
public OpCode Brtrue
public OpCode Beq
public OpCode Bge
public OpCode Bgt
public OpCode Ble
public OpCode Blt
public OpCode Bne_Un
public OpCode Bge_Un
public OpCode Bgt_Un
public OpCode Ble_Un
public OpCode Blt_Un
public OpCode Switch
public OpCode Ldind_I1
public OpCode Ldind_U1
public OpCode Ldind_I2
public OpCode Ldind_U2
public OpCode Ldind_I4
public OpCode Ldind_U4
public OpCode Ldind_I8
public OpCode Ldind_I
public OpCode Ldind_R4
public OpCode Ldind_R8
public OpCode Ldind_Ref
public OpCode Stind_Ref
public OpCode Stind_I1
public OpCode Stind_I2
public OpCode Stind_I4
public OpCode Stind_I8
public OpCode Stind_R4
public OpCode Stind_R8
public OpCode Add
public OpCode Sub
public OpCode Mul
public OpCode Div
public OpCode Div_Un
public OpCode Rem
public OpCode Rem_Un
public OpCode And
public OpCode Or
public OpCode Xor
public OpCode Shl
public OpCode Shr
public OpCode Shr_Un
public OpCode Neg
public OpCode Not
public OpCode Conv_I1
public OpCode Conv_I2
public OpCode Conv_I4
public OpCode Conv_I8
public OpCode Conv_R4
public OpCode Conv_R8
public OpCode Conv_U4
public OpCode Conv_U8
public OpCode Callvirt
public OpCode Cpobj
public OpCode Ldobj
public OpCode Ldstr
public OpCode Newobj
public OpCode Castclass
public OpCode Isinst
public OpCode Conv_R_Un
public OpCode Unbox
public OpCode Throw
public OpCode Ldfld
public OpCode Ldflda
public OpCode Stfld
public OpCode Ldsfld
public OpCode Ldsflda
public OpCode Stsfld
public OpCode Stobj
public OpCode Conv_Ovf_I1_Un
public OpCode Conv_Ovf_I2_Un
public OpCode Conv_Ovf_I4_Un
public OpCode Conv_Ovf_I8_Un
public OpCode Conv_Ovf_U1_Un
public OpCode Conv_Ovf_U2_Un
public OpCode Conv_Ovf_U4_Un
public OpCode Conv_Ovf_U8_Un
public OpCode Conv_Ovf_I_Un
public OpCode Conv_Ovf_U_Un
public OpCode Box
public OpCode Newarr
public OpCode Ldlen
public OpCode Ldelema
public OpCode Ldelem_I1
public OpCode Ldelem_U1
public OpCode Ldelem_I2
public OpCode Ldelem_U2
public OpCode Ldelem_I4
public OpCode Ldelem_U4
public OpCode Ldelem_I8
public OpCode Ldelem_I
public OpCode Ldelem_R4
public OpCode Ldelem_R8
public OpCode Ldelem_Ref
public OpCode Stelem_I
public OpCode Stelem_I1
public OpCode Stelem_I2
public OpCode Stelem_I4
public OpCode Stelem_I8
public OpCode Stelem_R4
public OpCode Stelem_R8
public OpCode Stelem_Ref
public OpCode Ldelem_Any
public OpCode Stelem_Any
public OpCode Unbox_Any
public OpCode Conv_Ovf_I1
public OpCode Conv_Ovf_U1
public OpCode Conv_Ovf_I2
public OpCode Conv_Ovf_U2
public OpCode Conv_Ovf_I4
public OpCode Conv_Ovf_U4
public OpCode Conv_Ovf_I8
public OpCode Conv_Ovf_U8
public OpCode Refanyval
public OpCode Ckfinite
public OpCode Mkrefany
public OpCode Ldtoken
public OpCode Conv_U2
public OpCode Conv_U1
public OpCode Conv_I
public OpCode Conv_Ovf_I
public OpCode Conv_Ovf_U
public OpCode Add_Ovf
public OpCode Add_Ovf_Un
public OpCode Mul_Ovf
public OpCode Mul_Ovf_Un
public OpCode Sub_Ovf
public OpCode Sub_Ovf_Un
public OpCode Endfinally
public OpCode Leave
public OpCode Leave_S
public OpCode Stind_I
public OpCode Conv_U
public OpCode Arglist
public OpCode Ceq
public OpCode Cgt
public OpCode Cgt_Un
public OpCode Clt
public OpCode Clt_Un
public OpCode Ldftn
public OpCode Ldvirtftn
public OpCode Ldarg
public OpCode Ldarga
public OpCode Starg
public OpCode Ldloc
public OpCode Ldloca
public OpCode Stloc
public OpCode Localloc
public OpCode Endfilter
public OpCode Unaligned
public OpCode Volatile
public OpCode Tail
public OpCode Initobj
public OpCode Constrained
public OpCode Cpblk
public OpCode Initblk
public OpCode No
public OpCode Rethrow
public OpCode Sizeof
public OpCode Refanytype
public OpCode Readonly
}
internal Mono.Cecil.Cil.OpCodeType : Enum {
public int value__
public OpCodeType Annotation
public OpCodeType Macro
public OpCodeType Nternal
public OpCodeType Objmodel
public OpCodeType Prefix
public OpCodeType Primitive
}
internal Mono.Cecil.Cil.OperandType : Enum {
public int value__
public OperandType InlineBrTarget
public OperandType InlineField
public OperandType InlineI
public OperandType InlineI8
public OperandType InlineMethod
public OperandType InlineNone
public OperandType InlinePhi
public OperandType InlineR
public OperandType InlineSig
public OperandType InlineString
public OperandType InlineSwitch
public OperandType InlineTok
public OperandType InlineType
public OperandType InlineVar
public OperandType InlineArg
public OperandType ShortInlineBrTarget
public OperandType ShortInlineI
public OperandType ShortInlineR
public OperandType ShortInlineVar
public OperandType ShortInlineArg
}
internal Mono.Cecil.Cil.PdbGuidMapping : object {
private Dictionary`2<Guid, DocumentLanguage> guid_language
private Dictionary`2<DocumentLanguage, Guid> language_guid
private Guid type_text
private Guid hash_md5
private Guid hash_sha1
private Guid hash_sha256
private Guid vendor_ms
private void AddMapping(DocumentLanguage language, Guid guid)
public DocumentType ToType(Guid guid)
public Guid ToGuid(DocumentType type)
public DocumentHashAlgorithm ToHashAlgorithm(Guid guid)
public Guid ToGuid(DocumentHashAlgorithm hash_algo)
public DocumentLanguage ToLanguage(Guid guid)
public Guid ToGuid(DocumentLanguage language)
public DocumentLanguageVendor ToVendor(Guid guid)
public Guid ToGuid(DocumentLanguageVendor vendor)
}
internal Mono.Cecil.Cil.PortablePdbReader : object {
private Image image
private ModuleDefinition module
private MetadataReader reader
private MetadataReader debug_reader
private bool IsEmbedded
private bool get_IsEmbedded()
internal void .ctor(Image image, ModuleDefinition module)
public ISymbolWriterProvider GetWriterProvider()
public bool ProcessDebugHeader(ImageDebugHeader header)
private bool IsMatchingEntry(PdbHeap heap, ImageDebugHeaderEntry entry)
private int ReadInt32(Byte[] bytes, int start)
private void ReadModule()
public MethodDebugInformation Read(MethodDefinition method)
private void ReadSequencePoints(MethodDebugInformation method_info)
private void ReadScope(MethodDebugInformation method_info)
private void ReadStateMachineKickOffMethod(MethodDebugInformation method_info)
private void ReadCustomDebugInformations(MethodDebugInformation info)
public void Dispose()
}
internal Mono.Cecil.Cil.PortablePdbReaderProvider : object {
public ISymbolReader GetSymbolReader(ModuleDefinition module, string fileName)
public ISymbolReader GetSymbolReader(ModuleDefinition module, Stream symbolStream)
private ISymbolReader GetSymbolReader(ModuleDefinition module, Disposable`1<Stream> symbolStream, string fileName)
}
internal Mono.Cecil.Cil.PortablePdbWriter : object {
private MetadataBuilder pdb_metadata
private ModuleDefinition module
private ImageWriter writer
private Disposable`1<Stream> final_stream
private MetadataBuilder module_metadata
internal Byte[] pdb_checksum
internal Guid pdb_id_guid
internal UInt32 pdb_id_stamp
private bool IsEmbedded
private bool get_IsEmbedded()
internal void .ctor(MetadataBuilder pdb_metadata, ModuleDefinition module)
internal void .ctor(MetadataBuilder pdb_metadata, ModuleDefinition module, ImageWriter writer, Disposable`1<Stream> final_stream)
public ISymbolReaderProvider GetReaderProvider()
public void Write(MethodDebugInformation info)
public void Write()
public ImageDebugHeader GetDebugHeader()
private void CheckMethodDebugInformationTable()
public void Dispose()
private void WritePdbFile()
private void WritePdbHeap()
private void WriteTableHeap()
private void ComputeChecksumAndPdbId()
private void WritePdbId()
}
internal Mono.Cecil.Cil.PortablePdbWriterProvider : object {
public ISymbolWriter GetSymbolWriter(ModuleDefinition module, string fileName)
public ISymbolWriter GetSymbolWriter(ModuleDefinition module, Stream symbolStream)
private ISymbolWriter GetSymbolWriter(ModuleDefinition module, Disposable`1<Stream> stream, Disposable`1<Stream> final_stream)
}
internal Mono.Cecil.Cil.ScopeDebugInformation : DebugInformation {
internal InstructionOffset start
internal InstructionOffset end
internal ImportDebugInformation import
internal Collection`1<ScopeDebugInformation> scopes
internal Collection`1<VariableDebugInformation> variables
internal Collection`1<ConstantDebugInformation> constants
public InstructionOffset Start
public InstructionOffset End
public ImportDebugInformation Import
public bool HasScopes
public Collection`1<ScopeDebugInformation> Scopes
public bool HasVariables
public Collection`1<VariableDebugInformation> Variables
public bool HasConstants
public Collection`1<ConstantDebugInformation> Constants
public InstructionOffset get_Start()
public void set_Start(InstructionOffset value)
public InstructionOffset get_End()
public void set_End(InstructionOffset value)
public ImportDebugInformation get_Import()
public void set_Import(ImportDebugInformation value)
public bool get_HasScopes()
public Collection`1<ScopeDebugInformation> get_Scopes()
public bool get_HasVariables()
public Collection`1<VariableDebugInformation> get_Variables()
public bool get_HasConstants()
public Collection`1<ConstantDebugInformation> get_Constants()
public void .ctor(Instruction start, Instruction end)
public bool TryGetName(VariableDefinition variable, String& name)
}
internal Mono.Cecil.Cil.SequencePoint : object {
internal InstructionOffset offset
private Document document
private int start_line
private int start_column
private int end_line
private int end_column
public int Offset
public int StartLine
public int StartColumn
public int EndLine
public int EndColumn
public bool IsHidden
public Document Document
public int get_Offset()
public int get_StartLine()
public void set_StartLine(int value)
public int get_StartColumn()
public void set_StartColumn(int value)
public int get_EndLine()
public void set_EndLine(int value)
public int get_EndColumn()
public void set_EndColumn(int value)
public bool get_IsHidden()
public Document get_Document()
public void set_Document(Document value)
internal void .ctor(int offset, Document document)
public void .ctor(Instruction instruction, Document document)
}
internal Mono.Cecil.Cil.SourceLinkDebugInformation : CustomDebugInformation {
internal string content
public Guid KindIdentifier
public string Content
public CustomDebugInformationKind Kind
public string get_Content()
public void set_Content(string value)
public CustomDebugInformationKind get_Kind()
public void .ctor(string content)
}
internal Mono.Cecil.Cil.StackBehaviour : Enum {
public int value__
public StackBehaviour Pop0
public StackBehaviour Pop1
public StackBehaviour Pop1_pop1
public StackBehaviour Popi
public StackBehaviour Popi_pop1
public StackBehaviour Popi_popi
public StackBehaviour Popi_popi8
public StackBehaviour Popi_popi_popi
public StackBehaviour Popi_popr4
public StackBehaviour Popi_popr8
public StackBehaviour Popref
public StackBehaviour Popref_pop1
public StackBehaviour Popref_popi
public StackBehaviour Popref_popi_popi
public StackBehaviour Popref_popi_popi8
public StackBehaviour Popref_popi_popr4
public StackBehaviour Popref_popi_popr8
public StackBehaviour Popref_popi_popref
public StackBehaviour PopAll
public StackBehaviour Push0
public StackBehaviour Push1
public StackBehaviour Push1_push1
public StackBehaviour Pushi
public StackBehaviour Pushi8
public StackBehaviour Pushr4
public StackBehaviour Pushr8
public StackBehaviour Pushref
public StackBehaviour Varpop
public StackBehaviour Varpush
}
internal Mono.Cecil.Cil.StateMachineScope : object {
internal InstructionOffset start
internal InstructionOffset end
public InstructionOffset Start
public InstructionOffset End
public InstructionOffset get_Start()
public void set_Start(InstructionOffset value)
public InstructionOffset get_End()
public void set_End(InstructionOffset value)
internal void .ctor(int start, int end)
public void .ctor(Instruction start, Instruction end)
}
internal Mono.Cecil.Cil.StateMachineScopeDebugInformation : CustomDebugInformation {
internal Collection`1<StateMachineScope> scopes
public Guid KindIdentifier
public Collection`1<StateMachineScope> Scopes
public CustomDebugInformationKind Kind
public Collection`1<StateMachineScope> get_Scopes()
public CustomDebugInformationKind get_Kind()
}
internal Mono.Cecil.Cil.SymbolKind : Enum {
public int value__
public SymbolKind NativePdb
public SymbolKind PortablePdb
public SymbolKind EmbeddedPortablePdb
public SymbolKind Mdb
}
internal Mono.Cecil.Cil.SymbolProvider : object {
private AssemblyName GetSymbolAssemblyName(SymbolKind kind)
private Type GetSymbolType(SymbolKind kind, string fullname)
public ISymbolReaderProvider GetReaderProvider(SymbolKind kind)
private string GetSymbolTypeName(SymbolKind kind, string name)
private string GetSymbolNamespace(SymbolKind kind)
}
internal Mono.Cecil.Cil.SymbolsNotFoundException : FileNotFoundException {
public void .ctor(string message)
private void .ctor(SerializationInfo info, StreamingContext context)
}
internal Mono.Cecil.Cil.SymbolsNotMatchingException : InvalidOperationException {
public void .ctor(string message)
private void .ctor(SerializationInfo info, StreamingContext context)
}
internal Mono.Cecil.Cil.VariableAttributes : Enum {
public ushort value__
public VariableAttributes None
public VariableAttributes DebuggerHidden
}
internal Mono.Cecil.Cil.VariableDebugInformation : DebugInformation {
private string name
private ushort attributes
internal VariableIndex index
public int Index
public string Name
public VariableAttributes Attributes
public bool IsDebuggerHidden
public int get_Index()
public string get_Name()
public void set_Name(string value)
public VariableAttributes get_Attributes()
public void set_Attributes(VariableAttributes value)
public bool get_IsDebuggerHidden()
public void set_IsDebuggerHidden(bool value)
internal void .ctor(int index, string name)
public void .ctor(VariableDefinition variable, string name)
}
internal Mono.Cecil.Cil.VariableDefinition : VariableReference {
public bool IsPinned
public bool get_IsPinned()
public void .ctor(TypeReference variableType)
public VariableDefinition Resolve()
}
internal Mono.Cecil.Cil.VariableDefinitionCollection : Collection`1<VariableDefinition> {
private MethodDefinition method
internal void .ctor(MethodDefinition method)
internal void .ctor(MethodDefinition method, int capacity)
protected void OnAdd(VariableDefinition item, int index)
protected void OnInsert(VariableDefinition item, int index)
protected void OnSet(VariableDefinition item, int index)
protected void OnRemove(VariableDefinition item, int index)
private void UpdateVariableIndices(int startIndex, int offset, VariableDefinition variableToRemove)
}
internal Mono.Cecil.Cil.VariableIndex : ValueType {
private VariableDefinition variable
private Nullable`1<int> index
public int Index
internal bool IsResolved
internal VariableDefinition ResolvedVariable
public int get_Index()
internal bool get_IsResolved()
internal VariableDefinition get_ResolvedVariable()
public void .ctor(VariableDefinition variable)
public void .ctor(int index)
}
internal Mono.Cecil.Cil.VariableReference : object {
internal int index
protected TypeReference variable_type
public TypeReference VariableType
public int Index
public TypeReference get_VariableType()
public void set_VariableType(TypeReference value)
public int get_Index()
internal void .ctor(TypeReference variable_type)
public VariableDefinition Resolve()
public string ToString()
}
internal Mono.Cecil.ClassLayoutTable : SortedTable`1<Row`3<ushort, UInt32, UInt32>> {
public void Write(TableHeapBuffer buffer)
public int Compare(Row`3<ushort, UInt32, UInt32> x, Row`3<ushort, UInt32, UInt32> y)
}
internal Mono.Cecil.ConstantTable : SortedTable`1<Row`3<ElementType, UInt32, UInt32>> {
public void Write(TableHeapBuffer buffer)
public int Compare(Row`3<ElementType, UInt32, UInt32> x, Row`3<ElementType, UInt32, UInt32> y)
}
internal Mono.Cecil.CryptoService : object {
public Byte[] GetPublicKey(WriterParameters parameters)
public void StrongName(Stream stream, ImageWriter writer, WriterParameters parameters)
private void PatchStrongName(Stream stream, int strong_name_pointer, Byte[] strong_name)
private Byte[] CreateStrongName(WriterParameters parameters, Byte[] hash)
private Byte[] HashStream(Stream stream, ImageWriter writer, Int32& strong_name_pointer)
public void CopyStreamChunk(Stream stream, Stream dest_stream, Byte[] buffer, int length)
public Byte[] ComputeHash(string file)
public Byte[] ComputeHash(Stream stream)
public Byte[] ComputeHash(ByteBuffer[] buffers)
public Guid ComputeGuid(Byte[] hash)
}
internal Mono.Cecil.CustomAttribute : object {
internal CustomAttributeValueProjection projection
internal UInt32 signature
internal bool resolved
private MethodReference constructor
private Byte[] blob
internal Collection`1<CustomAttributeArgument> arguments
internal Collection`1<CustomAttributeNamedArgument> fields
internal Collection`1<CustomAttributeNamedArgument> properties
public MethodReference Constructor
public TypeReference AttributeType
public bool IsResolved
public bool HasConstructorArguments
public Collection`1<CustomAttributeArgument> ConstructorArguments
public bool HasFields
public Collection`1<CustomAttributeNamedArgument> Fields
public bool HasProperties
public Collection`1<CustomAttributeNamedArgument> Properties
internal bool HasImage
internal ModuleDefinition Module
public MethodReference get_Constructor()
public void set_Constructor(MethodReference value)
public TypeReference get_AttributeType()
public bool get_IsResolved()
public bool get_HasConstructorArguments()
public Collection`1<CustomAttributeArgument> get_ConstructorArguments()
public bool get_HasFields()
public Collection`1<CustomAttributeNamedArgument> get_Fields()
public bool get_HasProperties()
public Collection`1<CustomAttributeNamedArgument> get_Properties()
internal bool get_HasImage()
internal ModuleDefinition get_Module()
internal void .ctor(UInt32 signature, MethodReference constructor)
public void .ctor(MethodReference constructor)
public void .ctor(MethodReference constructor, Byte[] blob)
public Byte[] GetBlob()
private void Resolve()
private void <Resolve>b__35_0(CustomAttribute attribute, MetadataReader reader)
}
internal Mono.Cecil.CustomAttributeArgument : ValueType {
private TypeReference type
private object value
public TypeReference Type
public object Value
public TypeReference get_Type()
public object get_Value()
public void .ctor(TypeReference type, object value)
}
internal Mono.Cecil.CustomAttributeNamedArgument : ValueType {
private string name
private CustomAttributeArgument argument
public string Name
public CustomAttributeArgument Argument
public string get_Name()
public CustomAttributeArgument get_Argument()
public void .ctor(string name, CustomAttributeArgument argument)
}
internal Mono.Cecil.CustomAttributeTable : SortedTable`1<Row`3<UInt32, UInt32, UInt32>> {
public void Write(TableHeapBuffer buffer)
public int Compare(Row`3<UInt32, UInt32, UInt32> x, Row`3<UInt32, UInt32, UInt32> y)
}
internal Mono.Cecil.CustomAttributeValueProjection : object {
public AttributeTargets Targets
public CustomAttributeValueTreatment Treatment
public void .ctor(AttributeTargets targets, CustomAttributeValueTreatment treatment)
}
internal Mono.Cecil.CustomAttributeValueTreatment : Enum {
public int value__
public CustomAttributeValueTreatment None
public CustomAttributeValueTreatment AllowSingle
public CustomAttributeValueTreatment AllowMultiple
public CustomAttributeValueTreatment VersionAttribute
public CustomAttributeValueTreatment DeprecatedAttribute
}
internal Mono.Cecil.CustomDebugInformationTable : SortedTable`1<Row`3<UInt32, UInt32, UInt32>> {
public void Write(TableHeapBuffer buffer)
public int Compare(Row`3<UInt32, UInt32, UInt32> x, Row`3<UInt32, UInt32, UInt32> y)
}
internal Mono.Cecil.CustomMarshalInfo : MarshalInfo {
internal Guid guid
internal string unmanaged_type
internal TypeReference managed_type
internal string cookie
public Guid Guid
public string UnmanagedType
public TypeReference ManagedType
public string Cookie
public Guid get_Guid()
public void set_Guid(Guid value)
public string get_UnmanagedType()
public void set_UnmanagedType(string value)
public TypeReference get_ManagedType()
public void set_ManagedType(TypeReference value)
public string get_Cookie()
public void set_Cookie(string value)
}
internal Mono.Cecil.DeclSecurityTable : SortedTable`1<Row`3<SecurityAction, UInt32, UInt32>> {
public void Write(TableHeapBuffer buffer)
public int Compare(Row`3<SecurityAction, UInt32, UInt32> x, Row`3<SecurityAction, UInt32, UInt32> y)
}
internal Mono.Cecil.DefaultAssemblyResolver : BaseAssemblyResolver {
private IDictionary`2<string, AssemblyDefinition> cache
public AssemblyDefinition Resolve(AssemblyNameReference name)
protected void RegisterAssembly(AssemblyDefinition assembly)
protected void Dispose(bool disposing)
}
internal Mono.Cecil.DefaultMetadataImporter : object {
protected ModuleDefinition module
public void .ctor(ModuleDefinition module)
private TypeReference ImportType(TypeReference type, ImportGenericContext context)
protected IMetadataScope ImportScope(TypeReference type)
protected IMetadataScope ImportScope(IMetadataScope scope)
public AssemblyNameReference ImportReference(AssemblyNameReference name)
private void ImportGenericParameters(IGenericParameterProvider imported, IGenericParameterProvider original)
private TypeReference ImportTypeSpecification(TypeReference type, ImportGenericContext context)
private FieldReference ImportField(FieldReference field, ImportGenericContext context)
private MethodReference ImportMethod(MethodReference method, ImportGenericContext context)
private MethodSpecification ImportMethodSpecification(MethodReference method, ImportGenericContext context)
public TypeReference ImportReference(TypeReference type, IGenericParameterProvider context)
public FieldReference ImportReference(FieldReference field, IGenericParameterProvider context)
public MethodReference ImportReference(MethodReference method, IGenericParameterProvider context)
}
internal Mono.Cecil.DefaultReflectionImporter : object {
protected ModuleDefinition module
private Dictionary`2<Type, ElementType> type_etype_mapping
public void .ctor(ModuleDefinition module)
private TypeReference ImportType(Type type, ImportGenericContext context)
private TypeReference ImportType(Type type, ImportGenericContext context, ImportGenericKind import_kind)
protected IMetadataScope ImportScope(Type type)
private bool ImportOpenGenericType(Type type, ImportGenericKind import_kind)
private bool ImportOpenGenericMethod(MethodBase method, ImportGenericKind import_kind)
private bool IsNestedType(Type type)
private TypeReference ImportTypeSpecification(Type type, ImportGenericContext context)
private TypeReference ImportGenericParameter(Type type, ImportGenericContext context)
private string NormalizeMethodName(MethodBase method)
private string NormalizeTypeFullName(Type type)
private TypeReference ImportGenericInstance(Type type, ImportGenericContext context)
private bool IsTypeSpecification(Type type)
private bool IsGenericInstance(Type type)
private ElementType ImportElementType(Type type)
protected AssemblyNameReference ImportScope(Assembly assembly)
public AssemblyNameReference ImportReference(AssemblyName name)
private bool TryGetAssemblyNameReference(AssemblyName name, AssemblyNameReference& assembly_reference)
private FieldReference ImportField(FieldInfo field, ImportGenericContext context)
private FieldInfo ResolveFieldDefinition(FieldInfo field)
private MethodBase ResolveMethodDefinition(MethodBase method)
private MethodReference ImportMethod(MethodBase method, ImportGenericContext context, ImportGenericKind import_kind)
private void ImportGenericParameters(IGenericParameterProvider provider, Type[] arguments)
private bool IsMethodSpecification(MethodBase method)
private MethodReference ImportMethodSpecification(MethodBase method, ImportGenericContext context)
private bool HasCallingConvention(MethodBase method, CallingConventions conventions)
public TypeReference ImportReference(Type type, IGenericParameterProvider context)
public FieldReference ImportReference(FieldInfo field, IGenericParameterProvider context)
public MethodReference ImportReference(MethodBase method, IGenericParameterProvider context)
}
internal Mono.Cecil.DeferredModuleReader : ModuleReader {
public void .ctor(Image image)
protected void ReadModule()
public void ReadSymbols(ModuleDefinition module)
private void <ReadModule>b__1_0(ModuleDefinition _, MetadataReader reader)
}
internal Mono.Cecil.DocumentTable : MetadataTable`1<Row`4<UInt32, UInt32, UInt32, UInt32>> {
public void Write(TableHeapBuffer buffer)
}
internal Mono.Cecil.EmbeddedResource : Resource {
private MetadataReader reader
private Nullable`1<UInt32> offset
private Byte[] data
private Stream stream
public ResourceType ResourceType
public ResourceType get_ResourceType()
public void .ctor(string name, ManifestResourceAttributes attributes, Byte[] data)
public void .ctor(string name, ManifestResourceAttributes attributes, Stream stream)
internal void .ctor(string name, ManifestResourceAttributes attributes, UInt32 offset, MetadataReader reader)
public Stream GetResourceStream()
public Byte[] GetResourceData()
private Byte[] ReadStream(Stream stream)
}
internal Mono.Cecil.EventAttributes : Enum {
public ushort value__
public EventAttributes None
public EventAttributes SpecialName
public EventAttributes RTSpecialName
}
internal Mono.Cecil.EventDefinition : EventReference {
private ushort attributes
private Collection`1<CustomAttribute> custom_attributes
internal MethodDefinition add_method
internal MethodDefinition invoke_method
internal MethodDefinition remove_method
internal Collection`1<MethodDefinition> other_methods
public EventAttributes Attributes
public MethodDefinition AddMethod
public MethodDefinition InvokeMethod
public MethodDefinition RemoveMethod
public bool HasOtherMethods
public Collection`1<MethodDefinition> OtherMethods
public bool HasCustomAttributes
public Collection`1<CustomAttribute> CustomAttributes
public bool IsSpecialName
public bool IsRuntimeSpecialName
public TypeDefinition DeclaringType
public bool IsDefinition
public EventAttributes get_Attributes()
public void set_Attributes(EventAttributes value)
public MethodDefinition get_AddMethod()
public void set_AddMethod(MethodDefinition value)
public MethodDefinition get_InvokeMethod()
public void set_InvokeMethod(MethodDefinition value)
public MethodDefinition get_RemoveMethod()
public void set_RemoveMethod(MethodDefinition value)
public bool get_HasOtherMethods()
public Collection`1<MethodDefinition> get_OtherMethods()
public bool get_HasCustomAttributes()
public Collection`1<CustomAttribute> get_CustomAttributes()
public bool get_IsSpecialName()
public void set_IsSpecialName(bool value)
public bool get_IsRuntimeSpecialName()
public void set_IsRuntimeSpecialName(bool value)
public TypeDefinition get_DeclaringType()
public void set_DeclaringType(TypeDefinition value)
public bool get_IsDefinition()
public void .ctor(string name, EventAttributes attributes, TypeReference eventType)
private void InitializeMethods()
public EventDefinition Resolve()
}
internal Mono.Cecil.EventMapTable : MetadataTable`1<Row`2<UInt32, UInt32>> {
public void Write(TableHeapBuffer buffer)
}
internal Mono.Cecil.EventReference : MemberReference {
private TypeReference event_type
public TypeReference EventType
public string FullName
public TypeReference get_EventType()
public void set_EventType(TypeReference value)
public string get_FullName()
protected void .ctor(string name, TypeReference eventType)
protected IMemberDefinition ResolveDefinition()
public EventDefinition Resolve()
}
internal Mono.Cecil.EventTable : MetadataTable`1<Row`3<EventAttributes, UInt32, UInt32>> {
public void Write(TableHeapBuffer buffer)
}
internal Mono.Cecil.ExportedType : object {
private string namespace
private string name
private UInt32 attributes
private IMetadataScope scope
private ModuleDefinition module
private int identifier
private ExportedType declaring_type
internal MetadataToken token
public string Namespace
public string Name
public TypeAttributes Attributes
public IMetadataScope Scope
public ExportedType DeclaringType
public MetadataToken MetadataToken
public int Identifier
public bool IsNotPublic
public bool IsPublic
public bool IsNestedPublic
public bool IsNestedPrivate
public bool IsNestedFamily
public bool IsNestedAssembly
public bool IsNestedFamilyAndAssembly
public bool IsNestedFamilyOrAssembly
public bool IsAutoLayout
public bool IsSequentialLayout
public bool IsExplicitLayout
public bool IsClass
public bool IsInterface
public bool IsAbstract
public bool IsSealed
public bool IsSpecialName
public bool IsImport
public bool IsSerializable
public bool IsAnsiClass
public bool IsUnicodeClass
public bool IsAutoClass
public bool IsBeforeFieldInit
public bool IsRuntimeSpecialName
public bool HasSecurity
public bool IsForwarder
public string FullName
public string get_Namespace()
public void set_Namespace(string value)
public string get_Name()
public void set_Name(string value)
public TypeAttributes get_Attributes()
public void set_Attributes(TypeAttributes value)
public IMetadataScope get_Scope()
public void set_Scope(IMetadataScope value)
public ExportedType get_DeclaringType()
public void set_DeclaringType(ExportedType value)
public MetadataToken get_MetadataToken()
public void set_MetadataToken(MetadataToken value)
public int get_Identifier()
public void set_Identifier(int value)
public bool get_IsNotPublic()
public void set_IsNotPublic(bool value)
public bool get_IsPublic()
public void set_IsPublic(bool value)
public bool get_IsNestedPublic()
public void set_IsNestedPublic(bool value)
public bool get_IsNestedPrivate()
public void set_IsNestedPrivate(bool value)
public bool get_IsNestedFamily()
public void set_IsNestedFamily(bool value)
public bool get_IsNestedAssembly()
public void set_IsNestedAssembly(bool value)
public bool get_IsNestedFamilyAndAssembly()
public void set_IsNestedFamilyAndAssembly(bool value)
public bool get_IsNestedFamilyOrAssembly()
public void set_IsNestedFamilyOrAssembly(bool value)
public bool get_IsAutoLayout()
public void set_IsAutoLayout(bool value)
public bool get_IsSequentialLayout()
public void set_IsSequentialLayout(bool value)
public bool get_IsExplicitLayout()
public void set_IsExplicitLayout(bool value)
public bool get_IsClass()
public void set_IsClass(bool value)
public bool get_IsInterface()
public void set_IsInterface(bool value)
public bool get_IsAbstract()
public void set_IsAbstract(bool value)
public bool get_IsSealed()
public void set_IsSealed(bool value)
public bool get_IsSpecialName()
public void set_IsSpecialName(bool value)
public bool get_IsImport()
public void set_IsImport(bool value)
public bool get_IsSerializable()
public void set_IsSerializable(bool value)
public bool get_IsAnsiClass()
public void set_IsAnsiClass(bool value)
public bool get_IsUnicodeClass()
public void set_IsUnicodeClass(bool value)
public bool get_IsAutoClass()
public void set_IsAutoClass(bool value)
public bool get_IsBeforeFieldInit()
public void set_IsBeforeFieldInit(bool value)
public bool get_IsRuntimeSpecialName()
public void set_IsRuntimeSpecialName(bool value)
public bool get_HasSecurity()
public void set_HasSecurity(bool value)
public bool get_IsForwarder()
public void set_IsForwarder(bool value)
public string get_FullName()
public void .ctor(string namespace, string name, ModuleDefinition module, IMetadataScope scope)
public string ToString()
public TypeDefinition Resolve()
internal TypeReference CreateReference()
}
internal Mono.Cecil.ExportedTypeTable : MetadataTable`1<Row`5<TypeAttributes, UInt32, UInt32, UInt32, UInt32>> {
public void Write(TableHeapBuffer buffer)
}
internal Mono.Cecil.FieldAttributes : Enum {
public ushort value__
public FieldAttributes FieldAccessMask
public FieldAttributes CompilerControlled
public FieldAttributes Private
public FieldAttributes FamANDAssem
public FieldAttributes Assembly
public FieldAttributes Family
public FieldAttributes FamORAssem
public FieldAttributes Public
public FieldAttributes Static
public FieldAttributes InitOnly
public FieldAttributes Literal
public FieldAttributes NotSerialized
public FieldAttributes SpecialName
public FieldAttributes PInvokeImpl
public FieldAttributes RTSpecialName
public FieldAttributes HasFieldMarshal
public FieldAttributes HasDefault
public FieldAttributes HasFieldRVA
}
internal Mono.Cecil.FieldDefinition : FieldReference {
private ushort attributes
private Collection`1<CustomAttribute> custom_attributes
private int offset
internal int rva
private Byte[] initial_value
private object constant
private MarshalInfo marshal_info
public bool HasLayoutInfo
public int Offset
internal FieldDefinitionProjection WindowsRuntimeProjection
public int RVA
public Byte[] InitialValue
public FieldAttributes Attributes
public bool HasConstant
public object Constant
public bool HasCustomAttributes
public Collection`1<CustomAttribute> CustomAttributes
public bool HasMarshalInfo
public MarshalInfo MarshalInfo
public bool IsCompilerControlled
public bool IsPrivate
public bool IsFamilyAndAssembly
public bool IsAssembly
public bool IsFamily
public bool IsFamilyOrAssembly
public bool IsPublic
public bool IsStatic
public bool IsInitOnly
public bool IsLiteral
public bool IsNotSerialized
public bool IsSpecialName
public bool IsPInvokeImpl
public bool IsRuntimeSpecialName
public bool HasDefault
public bool HasFieldRVA
public bool IsDefinition
public TypeDefinition DeclaringType
private void ResolveLayout()
public bool get_HasLayoutInfo()
public int get_Offset()
public void set_Offset(int value)
internal FieldDefinitionProjection get_WindowsRuntimeProjection()
internal void set_WindowsRuntimeProjection(FieldDefinitionProjection value)
private void ResolveRVA()
public int get_RVA()
public Byte[] get_InitialValue()
public void set_InitialValue(Byte[] value)
public FieldAttributes get_Attributes()
public void set_Attributes(FieldAttributes value)
public bool get_HasConstant()
public void set_HasConstant(bool value)
public object get_Constant()
public void set_Constant(object value)
public bool get_HasCustomAttributes()
public Collection`1<CustomAttribute> get_CustomAttributes()
public bool get_HasMarshalInfo()
public MarshalInfo get_MarshalInfo()
public void set_MarshalInfo(MarshalInfo value)
public bool get_IsCompilerControlled()
public void set_IsCompilerControlled(bool value)
public bool get_IsPrivate()
public void set_IsPrivate(bool value)
public bool get_IsFamilyAndAssembly()
public void set_IsFamilyAndAssembly(bool value)
public bool get_IsAssembly()
public void set_IsAssembly(bool value)
public bool get_IsFamily()
public void set_IsFamily(bool value)
public bool get_IsFamilyOrAssembly()
public void set_IsFamilyOrAssembly(bool value)
public bool get_IsPublic()
public void set_IsPublic(bool value)
public bool get_IsStatic()
public void set_IsStatic(bool value)
public bool get_IsInitOnly()
public void set_IsInitOnly(bool value)
public bool get_IsLiteral()
public void set_IsLiteral(bool value)
public bool get_IsNotSerialized()
public void set_IsNotSerialized(bool value)
public bool get_IsSpecialName()
public void set_IsSpecialName(bool value)
public bool get_IsPInvokeImpl()
public void set_IsPInvokeImpl(bool value)
public bool get_IsRuntimeSpecialName()
public void set_IsRuntimeSpecialName(bool value)
public bool get_HasDefault()
public void set_HasDefault(bool value)
public bool get_HasFieldRVA()
public void set_HasFieldRVA(bool value)
public bool get_IsDefinition()
public TypeDefinition get_DeclaringType()
public void set_DeclaringType(TypeDefinition value)
public void .ctor(string name, FieldAttributes attributes, TypeReference fieldType)
public FieldDefinition Resolve()
}
internal Mono.Cecil.FieldDefinitionProjection : object {
public FieldAttributes Attributes
public FieldDefinitionTreatment Treatment
public void .ctor(FieldDefinition field, FieldDefinitionTreatment treatment)
}
internal Mono.Cecil.FieldDefinitionTreatment : Enum {
public int value__
public FieldDefinitionTreatment None
public FieldDefinitionTreatment Public
}
internal Mono.Cecil.FieldLayoutTable : SortedTable`1<Row`2<UInt32, UInt32>> {
public void Write(TableHeapBuffer buffer)
public int Compare(Row`2<UInt32, UInt32> x, Row`2<UInt32, UInt32> y)
}
internal Mono.Cecil.FieldMarshalTable : SortedTable`1<Row`2<UInt32, UInt32>> {
public void Write(TableHeapBuffer buffer)
public int Compare(Row`2<UInt32, UInt32> x, Row`2<UInt32, UInt32> y)
}
internal Mono.Cecil.FieldReference : MemberReference {
private TypeReference field_type
public TypeReference FieldType
public string FullName
public bool ContainsGenericParameter
public TypeReference get_FieldType()
public void set_FieldType(TypeReference value)
public string get_FullName()
public bool get_ContainsGenericParameter()
public void .ctor(string name, TypeReference fieldType)
public void .ctor(string name, TypeReference fieldType, TypeReference declaringType)
protected IMemberDefinition ResolveDefinition()
public FieldDefinition Resolve()
}
internal Mono.Cecil.FieldRVATable : SortedTable`1<Row`2<UInt32, UInt32>> {
internal int position
public void Write(TableHeapBuffer buffer)
public int Compare(Row`2<UInt32, UInt32> x, Row`2<UInt32, UInt32> y)
}
internal Mono.Cecil.FieldTable : MetadataTable`1<Row`3<FieldAttributes, UInt32, UInt32>> {
public void Write(TableHeapBuffer buffer)
}
internal Mono.Cecil.FileAttributes : Enum {
public UInt32 value__
public FileAttributes ContainsMetaData
public FileAttributes ContainsNoMetaData
}
internal Mono.Cecil.FileTable : MetadataTable`1<Row`3<FileAttributes, UInt32, UInt32>> {
public void Write(TableHeapBuffer buffer)
}
internal Mono.Cecil.FixedArrayMarshalInfo : MarshalInfo {
internal NativeType element_type
internal int size
public NativeType ElementType
public int Size
public NativeType get_ElementType()
public void set_ElementType(NativeType value)
public int get_Size()
public void set_Size(int value)
}
internal Mono.Cecil.FixedSysStringMarshalInfo : MarshalInfo {
internal int size
public int Size
public int get_Size()
public void set_Size(int value)
}
internal Mono.Cecil.FunctionPointerType : TypeSpecification {
private MethodReference function
public bool HasThis
public bool ExplicitThis
public MethodCallingConvention CallingConvention
public bool HasParameters
public Collection`1<ParameterDefinition> Parameters
public TypeReference ReturnType
public MethodReturnType MethodReturnType
public string Name
public string Namespace
public ModuleDefinition Module
public IMetadataScope Scope
public bool IsFunctionPointer
public bool ContainsGenericParameter
public string FullName
public bool get_HasThis()
public void set_HasThis(bool value)
public bool get_ExplicitThis()
public void set_ExplicitThis(bool value)
public MethodCallingConvention get_CallingConvention()
public void set_CallingConvention(MethodCallingConvention value)
public bool get_HasParameters()
public Collection`1<ParameterDefinition> get_Parameters()
public TypeReference get_ReturnType()
public void set_ReturnType(TypeReference value)
public MethodReturnType get_MethodReturnType()
public string get_Name()
public void set_Name(string value)
public string get_Namespace()
public void set_Namespace(string value)
public ModuleDefinition get_Module()
public IMetadataScope get_Scope()
public void set_Scope(IMetadataScope value)
public bool get_IsFunctionPointer()
public bool get_ContainsGenericParameter()
public string get_FullName()
public TypeDefinition Resolve()
public TypeReference GetElementType()
}
internal Mono.Cecil.GenericInstanceMethod : MethodSpecification {
private Collection`1<TypeReference> arguments
public bool HasGenericArguments
public Collection`1<TypeReference> GenericArguments
public bool IsGenericInstance
private IGenericParameterProvider Mono.Cecil.IGenericContext.Method
private IGenericParameterProvider Mono.Cecil.IGenericContext.Type
public bool ContainsGenericParameter
public string FullName
public bool get_HasGenericArguments()
public Collection`1<TypeReference> get_GenericArguments()
public bool get_IsGenericInstance()
private IGenericParameterProvider Mono.Cecil.IGenericContext.get_Method()
private IGenericParameterProvider Mono.Cecil.IGenericContext.get_Type()
public bool get_ContainsGenericParameter()
public string get_FullName()
public void .ctor(MethodReference method)
internal void .ctor(MethodReference method, int arity)
}
internal Mono.Cecil.GenericInstanceType : TypeSpecification {
private Collection`1<TypeReference> arguments
public bool HasGenericArguments
public Collection`1<TypeReference> GenericArguments
public TypeReference DeclaringType
public string FullName
public bool IsGenericInstance
public bool ContainsGenericParameter
private IGenericParameterProvider Mono.Cecil.IGenericContext.Type
public bool get_HasGenericArguments()
public Collection`1<TypeReference> get_GenericArguments()
public TypeReference get_DeclaringType()
public void set_DeclaringType(TypeReference value)
public string get_FullName()
public bool get_IsGenericInstance()
public bool get_ContainsGenericParameter()
private IGenericParameterProvider Mono.Cecil.IGenericContext.get_Type()
public void .ctor(TypeReference type)
internal void .ctor(TypeReference type, int arity)
}
internal Mono.Cecil.GenericParamConstraintTable : MetadataTable`1<Row`2<UInt32, UInt32>> {
public void Write(TableHeapBuffer buffer)
}
internal Mono.Cecil.GenericParameter : TypeReference {
internal int position
internal GenericParameterType type
internal IGenericParameterProvider owner
private ushort attributes
private GenericParameterConstraintCollection constraints
private Collection`1<CustomAttribute> custom_attributes
public GenericParameterAttributes Attributes
public int Position
public GenericParameterType Type
public IGenericParameterProvider Owner
public bool HasConstraints
public Collection`1<GenericParameterConstraint> Constraints
public bool HasCustomAttributes
public Collection`1<CustomAttribute> CustomAttributes
public IMetadataScope Scope
public TypeReference DeclaringType
public MethodReference DeclaringMethod
public ModuleDefinition Module
public string Name
public string Namespace
public string FullName
public bool IsGenericParameter
public bool ContainsGenericParameter
public MetadataType MetadataType
public bool IsNonVariant
public bool IsCovariant
public bool IsContravariant
public bool HasReferenceTypeConstraint
public bool HasNotNullableValueTypeConstraint
public bool HasDefaultConstructorConstraint
public GenericParameterAttributes get_Attributes()
public void set_Attributes(GenericParameterAttributes value)
public int get_Position()
public GenericParameterType get_Type()
public IGenericParameterProvider get_Owner()
public bool get_HasConstraints()
public Collection`1<GenericParameterConstraint> get_Constraints()
public bool get_HasCustomAttributes()
public Collection`1<CustomAttribute> get_CustomAttributes()
public IMetadataScope get_Scope()
public void set_Scope(IMetadataScope value)
public TypeReference get_DeclaringType()
public void set_DeclaringType(TypeReference value)
public MethodReference get_DeclaringMethod()
public ModuleDefinition get_Module()
public string get_Name()
public string get_Namespace()
public void set_Namespace(string value)
public string get_FullName()
public bool get_IsGenericParameter()
public bool get_ContainsGenericParameter()
public MetadataType get_MetadataType()
public bool get_IsNonVariant()
public void set_IsNonVariant(bool value)
public bool get_IsCovariant()
public void set_IsCovariant(bool value)
public bool get_IsContravariant()
public void set_IsContravariant(bool value)
public bool get_HasReferenceTypeConstraint()
public void set_HasReferenceTypeConstraint(bool value)
public bool get_HasNotNullableValueTypeConstraint()
public void set_HasNotNullableValueTypeConstraint(bool value)
public bool get_HasDefaultConstructorConstraint()
public void set_HasDefaultConstructorConstraint(bool value)
public void .ctor(IGenericParameterProvider owner)
public void .ctor(string name, IGenericParameterProvider owner)
internal void .ctor(int position, GenericParameterType type, ModuleDefinition module)
private ElementType ConvertGenericParameterType(GenericParameterType type)
public TypeDefinition Resolve()
}
internal Mono.Cecil.GenericParameterAttributes : Enum {
public ushort value__
public GenericParameterAttributes VarianceMask
public GenericParameterAttributes NonVariant
public GenericParameterAttributes Covariant
public GenericParameterAttributes Contravariant
public GenericParameterAttributes SpecialConstraintMask
public GenericParameterAttributes ReferenceTypeConstraint
public GenericParameterAttributes NotNullableValueTypeConstraint
public GenericParameterAttributes DefaultConstructorConstraint
}
internal Mono.Cecil.GenericParameterCollection : Collection`1<GenericParameter> {
private IGenericParameterProvider owner
internal void .ctor(IGenericParameterProvider owner)
internal void .ctor(IGenericParameterProvider owner, int capacity)
protected void OnAdd(GenericParameter item, int index)
protected void OnInsert(GenericParameter item, int index)
protected void OnSet(GenericParameter item, int index)
private void UpdateGenericParameter(GenericParameter item, int index)
protected void OnRemove(GenericParameter item, int index)
}
internal Mono.Cecil.GenericParameterConstraint : object {
internal GenericParameter generic_parameter
internal MetadataToken token
private TypeReference constraint_type
private Collection`1<CustomAttribute> custom_attributes
public TypeReference ConstraintType
public bool HasCustomAttributes
public Collection`1<CustomAttribute> CustomAttributes
public MetadataToken MetadataToken
public TypeReference get_ConstraintType()
public void set_ConstraintType(TypeReference value)
public bool get_HasCustomAttributes()
public Collection`1<CustomAttribute> get_CustomAttributes()
public MetadataToken get_MetadataToken()
public void set_MetadataToken(MetadataToken value)
internal void .ctor(TypeReference constraintType, MetadataToken token)
public void .ctor(TypeReference constraintType)
}
internal Mono.Cecil.GenericParameterConstraintCollection : Collection`1<GenericParameterConstraint> {
private GenericParameter generic_parameter
internal void .ctor(GenericParameter genericParameter)
internal void .ctor(GenericParameter genericParameter, int length)
protected void OnAdd(GenericParameterConstraint item, int index)
protected void OnInsert(GenericParameterConstraint item, int index)
protected void OnSet(GenericParameterConstraint item, int index)
protected void OnRemove(GenericParameterConstraint item, int index)
}
internal Mono.Cecil.GenericParameterResolver : object {
internal TypeReference ResolveReturnTypeIfNeeded(MethodReference methodReference)
internal TypeReference ResolveFieldTypeIfNeeded(FieldReference fieldReference)
internal TypeReference ResolveParameterTypeIfNeeded(MethodReference method, ParameterReference parameter)
internal TypeReference ResolveVariableTypeIfNeeded(MethodReference method, VariableReference variable)
private TypeReference ResolveIfNeeded(IGenericInstance genericInstanceMethod, IGenericInstance declaringGenericInstanceType, TypeReference parameterType)
private TypeReference ResolveIfNeeded(IGenericInstance genericInstanceMethod, IGenericInstance genericInstanceType, GenericParameter genericParameterElement)
private ArrayType ResolveIfNeeded(IGenericInstance genericInstanceMethod, IGenericInstance genericInstanceType, ArrayType arrayType)
private ByReferenceType ResolveIfNeeded(IGenericInstance genericInstanceMethod, IGenericInstance genericInstanceType, ByReferenceType byReferenceType)
private GenericInstanceType ResolveIfNeeded(IGenericInstance genericInstanceMethod, IGenericInstance genericInstanceType, GenericInstanceType genericInstanceType1)
private bool ContainsGenericParameters(TypeReference typeReference)
}
internal Mono.Cecil.GenericParameterType : Enum {
public int value__
public GenericParameterType Type
public GenericParameterType Method
}
internal Mono.Cecil.GenericParamTable : MetadataTable`1<Row`4<ushort, GenericParameterAttributes, UInt32, UInt32>> {
public void Write(TableHeapBuffer buffer)
}
internal Mono.Cecil.IAssemblyResolver {
public AssemblyDefinition Resolve(AssemblyNameReference name)
public AssemblyDefinition Resolve(AssemblyNameReference name, ReaderParameters parameters)
}
internal Mono.Cecil.IConstantProvider {
public bool HasConstant
public object Constant
public bool get_HasConstant()
public void set_HasConstant(bool value)
public object get_Constant()
public void set_Constant(object value)
}
internal Mono.Cecil.ICustomAttribute {
public TypeReference AttributeType
public bool HasFields
public bool HasProperties
public bool HasConstructorArguments
public Collection`1<CustomAttributeNamedArgument> Fields
public Collection`1<CustomAttributeNamedArgument> Properties
public Collection`1<CustomAttributeArgument> ConstructorArguments
public TypeReference get_AttributeType()
public bool get_HasFields()
public bool get_HasProperties()
public bool get_HasConstructorArguments()
public Collection`1<CustomAttributeNamedArgument> get_Fields()
public Collection`1<CustomAttributeNamedArgument> get_Properties()
public Collection`1<CustomAttributeArgument> get_ConstructorArguments()
}
internal Mono.Cecil.ICustomAttributeProvider {
public Collection`1<CustomAttribute> CustomAttributes
public bool HasCustomAttributes
public Collection`1<CustomAttribute> get_CustomAttributes()
public bool get_HasCustomAttributes()
}
internal Mono.Cecil.IGenericContext {
public bool IsDefinition
public IGenericParameterProvider Type
public IGenericParameterProvider Method
public bool get_IsDefinition()
public IGenericParameterProvider get_Type()
public IGenericParameterProvider get_Method()
}
internal Mono.Cecil.IGenericInstance {
public bool HasGenericArguments
public Collection`1<TypeReference> GenericArguments
public bool get_HasGenericArguments()
public Collection`1<TypeReference> get_GenericArguments()
}
internal Mono.Cecil.IGenericParameterProvider {
public bool HasGenericParameters
public bool IsDefinition
public ModuleDefinition Module
public Collection`1<GenericParameter> GenericParameters
public GenericParameterType GenericParameterType
public bool get_HasGenericParameters()
public bool get_IsDefinition()
public ModuleDefinition get_Module()
public Collection`1<GenericParameter> get_GenericParameters()
public GenericParameterType get_GenericParameterType()
}
internal Mono.Cecil.IMarshalInfoProvider {
public bool HasMarshalInfo
public MarshalInfo MarshalInfo
public bool get_HasMarshalInfo()
public MarshalInfo get_MarshalInfo()
public void set_MarshalInfo(MarshalInfo value)
}
internal Mono.Cecil.IMemberDefinition {
public string Name
public string FullName
public bool IsSpecialName
public bool IsRuntimeSpecialName
public TypeDefinition DeclaringType
public string get_Name()
public void set_Name(string value)
public string get_FullName()
public bool get_IsSpecialName()
public void set_IsSpecialName(bool value)
public bool get_IsRuntimeSpecialName()
public void set_IsRuntimeSpecialName(bool value)
public TypeDefinition get_DeclaringType()
public void set_DeclaringType(TypeDefinition value)
}
internal Mono.Cecil.IMetadataImporter {
public AssemblyNameReference ImportReference(AssemblyNameReference reference)
public TypeReference ImportReference(TypeReference type, IGenericParameterProvider context)
public FieldReference ImportReference(FieldReference field, IGenericParameterProvider context)
public MethodReference ImportReference(MethodReference method, IGenericParameterProvider context)
}
internal Mono.Cecil.IMetadataImporterProvider {
public IMetadataImporter GetMetadataImporter(ModuleDefinition module)
}
internal Mono.Cecil.IMetadataResolver {
public TypeDefinition Resolve(TypeReference type)
public FieldDefinition Resolve(FieldReference field)
public MethodDefinition Resolve(MethodReference method)
}
internal Mono.Cecil.IMetadataScope {
public MetadataScopeType MetadataScopeType
public string Name
public MetadataScopeType get_MetadataScopeType()
public string get_Name()
public void set_Name(string value)
}
internal Mono.Cecil.IMetadataTokenProvider {
public MetadataToken MetadataToken
public MetadataToken get_MetadataToken()
public void set_MetadataToken(MetadataToken value)
}
internal Mono.Cecil.IMethodSignature {
public bool HasThis
public bool ExplicitThis
public MethodCallingConvention CallingConvention
public bool HasParameters
public Collection`1<ParameterDefinition> Parameters
public TypeReference ReturnType
public MethodReturnType MethodReturnType
public bool get_HasThis()
public void set_HasThis(bool value)
public bool get_ExplicitThis()
public void set_ExplicitThis(bool value)
public MethodCallingConvention get_CallingConvention()
public void set_CallingConvention(MethodCallingConvention value)
public bool get_HasParameters()
public Collection`1<ParameterDefinition> get_Parameters()
public TypeReference get_ReturnType()
public void set_ReturnType(TypeReference value)
public MethodReturnType get_MethodReturnType()
}
internal Mono.Cecil.ImmediateModuleReader : ModuleReader {
private bool resolve_attributes
public void .ctor(Image image)
protected void ReadModule()
public void ReadModule(ModuleDefinition module, bool resolve_attributes)
private void ReadTypes(Collection`1<TypeDefinition> types)
private void ReadType(TypeDefinition type)
private void ReadInterfaces(TypeDefinition type)
private void ReadGenericParameters(IGenericParameterProvider provider)
private void ReadGenericParameterConstraints(GenericParameter parameter)
private void ReadSecurityDeclarations(ISecurityDeclarationProvider provider)
private void ReadCustomAttributes(ICustomAttributeProvider provider)
private void ReadFields(TypeDefinition type)
private void ReadMethods(TypeDefinition type)
private void ReadParameters(MethodDefinition method)
private void ReadProperties(TypeDefinition type)
private void ReadEvents(TypeDefinition type)
public void ReadSymbols(ModuleDefinition module)
private void ReadTypesSymbols(Collection`1<TypeDefinition> types, ISymbolReader symbol_reader)
private void ReadMethodsSymbols(TypeDefinition type, ISymbolReader symbol_reader)
private void <ReadModule>b__2_0(ModuleDefinition module, MetadataReader reader)
}
internal Mono.Cecil.IModifierType {
public TypeReference ModifierType
public TypeReference ElementType
public TypeReference get_ModifierType()
public TypeReference get_ElementType()
}
internal Mono.Cecil.ImplMapTable : SortedTable`1<Row`4<PInvokeAttributes, UInt32, UInt32, UInt32>> {
public void Write(TableHeapBuffer buffer)
public int Compare(Row`4<PInvokeAttributes, UInt32, UInt32, UInt32> x, Row`4<PInvokeAttributes, UInt32, UInt32, UInt32> y)
}
internal Mono.Cecil.ImportGenericContext : ValueType {
private Collection`1<IGenericParameterProvider> stack
public bool IsEmpty
public bool get_IsEmpty()
public void .ctor(IGenericParameterProvider provider)
public void Push(IGenericParameterProvider provider)
public void Pop()
public TypeReference MethodParameter(string method, int position)
public string NormalizeMethodName(MethodReference method)
public TypeReference TypeParameter(string type, int position)
private TypeReference GenericTypeFor(IGenericParameterProvider context)
public ImportGenericContext For(IGenericParameterProvider context)
}
internal Mono.Cecil.ImportScopeTable : MetadataTable`1<Row`2<UInt32, UInt32>> {
public void Write(TableHeapBuffer buffer)
}
internal Mono.Cecil.InterfaceImplementation : object {
internal TypeDefinition type
internal MetadataToken token
private TypeReference interface_type
private Collection`1<CustomAttribute> custom_attributes
public TypeReference InterfaceType
public bool HasCustomAttributes
public Collection`1<CustomAttribute> CustomAttributes
public MetadataToken MetadataToken
public TypeReference get_InterfaceType()
public void set_InterfaceType(TypeReference value)
public bool get_HasCustomAttributes()
public Collection`1<CustomAttribute> get_CustomAttributes()
public MetadataToken get_MetadataToken()
public void set_MetadataToken(MetadataToken value)
internal void .ctor(TypeReference interfaceType, MetadataToken token)
public void .ctor(TypeReference interfaceType)
}
internal Mono.Cecil.InterfaceImplementationCollection : Collection`1<InterfaceImplementation> {
private TypeDefinition type
internal void .ctor(TypeDefinition type)
internal void .ctor(TypeDefinition type, int length)
protected void OnAdd(InterfaceImplementation item, int index)
protected void OnInsert(InterfaceImplementation item, int index)
protected void OnSet(InterfaceImplementation item, int index)
protected void OnRemove(InterfaceImplementation item, int index)
}
internal Mono.Cecil.InterfaceImplTable : MetadataTable`1<Row`2<UInt32, UInt32>> {
public void Write(TableHeapBuffer buffer)
}
internal Mono.Cecil.IReflectionImporter {
public AssemblyNameReference ImportReference(AssemblyName reference)
public TypeReference ImportReference(Type type, IGenericParameterProvider context)
public FieldReference ImportReference(FieldInfo field, IGenericParameterProvider context)
public MethodReference ImportReference(MethodBase method, IGenericParameterProvider context)
}
internal Mono.Cecil.IReflectionImporterProvider {
public IReflectionImporter GetReflectionImporter(ModuleDefinition module)
}
internal Mono.Cecil.ISecurityDeclarationProvider {
public bool HasSecurityDeclarations
public Collection`1<SecurityDeclaration> SecurityDeclarations
public bool get_HasSecurityDeclarations()
public Collection`1<SecurityDeclaration> get_SecurityDeclarations()
}
internal Mono.Cecil.LinkedResource : Resource {
internal Byte[] hash
private string file
public Byte[] Hash
public string File
public ResourceType ResourceType
public Byte[] get_Hash()
public string get_File()
public void set_File(string value)
public ResourceType get_ResourceType()
public void .ctor(string name, ManifestResourceAttributes flags)
public void .ctor(string name, ManifestResourceAttributes flags, string file)
}
internal Mono.Cecil.LocalConstantTable : MetadataTable`1<Row`2<UInt32, UInt32>> {
public void Write(TableHeapBuffer buffer)
}
internal Mono.Cecil.LocalScopeTable : MetadataTable`1<Row`6<UInt32, UInt32, UInt32, UInt32, UInt32, UInt32>> {
public void Write(TableHeapBuffer buffer)
}
internal Mono.Cecil.LocalVariableTable : MetadataTable`1<Row`3<VariableAttributes, ushort, UInt32>> {
public void Write(TableHeapBuffer buffer)
}
internal Mono.Cecil.ManifestResourceAttributes : Enum {
public UInt32 value__
public ManifestResourceAttributes VisibilityMask
public ManifestResourceAttributes Public
public ManifestResourceAttributes Private
}
internal Mono.Cecil.ManifestResourceTable : MetadataTable`1<Row`4<UInt32, ManifestResourceAttributes, UInt32, UInt32>> {
public void Write(TableHeapBuffer buffer)
}
internal Mono.Cecil.MarshalInfo : object {
internal NativeType native
public NativeType NativeType
public NativeType get_NativeType()
public void set_NativeType(NativeType value)
public void .ctor(NativeType native)
}
internal Mono.Cecil.Mdb.MdbReader : object {
private ModuleDefinition module
private MonoSymbolFile symbol_file
private Dictionary`2<string, Document> documents
public void .ctor(ModuleDefinition module, MonoSymbolFile symFile)
public ISymbolWriterProvider GetWriterProvider()
public bool ProcessDebugHeader(ImageDebugHeader header)
public MethodDebugInformation Read(MethodDefinition method)
private int ReadCodeSize(MethodDefinition method)
private void ReadLocalVariables(MethodEntry entry, ScopeDebugInformation[] scopes)
private void ReadLineNumbers(MethodEntry entry, MethodDebugInformation info)
private Document GetDocument(SourceFileEntry file)
private ScopeDebugInformation[] ReadScopes(MethodEntry entry, MethodDebugInformation info)
private bool AddScope(Collection`1<ScopeDebugInformation> scopes, ScopeDebugInformation scope)
private SequencePoint LineToSequencePoint(LineNumberEntry line)
public void Dispose()
}
internal Mono.Cecil.Mdb.MdbReaderProvider : object {
public ISymbolReader GetSymbolReader(ModuleDefinition module, string fileName)
public ISymbolReader GetSymbolReader(ModuleDefinition module, Stream symbolStream)
}
internal Mono.Cecil.Mdb.MdbWriter : object {
private ModuleDefinition module
private MonoSymbolWriter writer
private Dictionary`2<string, SourceFile> source_files
public void .ctor(ModuleDefinition module, string assembly)
public ISymbolReaderProvider GetReaderProvider()
private SourceFile GetSourceFile(Document document)
private void Populate(Collection`1<SequencePoint> sequencePoints, Int32[] offsets, Int32[] startRows, Int32[] endRows, Int32[] startCols, Int32[] endCols, SourceFile& file)
public void Write(MethodDebugInformation info)
private void WriteRootScope(ScopeDebugInformation scope, MethodDebugInformation info)
private void WriteScope(ScopeDebugInformation scope, MethodDebugInformation info)
private void WriteScopes(Collection`1<ScopeDebugInformation> scopes, MethodDebugInformation info)
private void WriteScopeVariables(ScopeDebugInformation scope)
public ImageDebugHeader GetDebugHeader()
public void Write()
public void Dispose()
}
internal Mono.Cecil.Mdb.MdbWriterProvider : object {
public ISymbolWriter GetSymbolWriter(ModuleDefinition module, string fileName)
public ISymbolWriter GetSymbolWriter(ModuleDefinition module, Stream symbolStream)
}
internal Mono.Cecil.Mdb.MethodEntryExtensions : object {
public bool HasColumnInfo(MethodEntry entry)
public bool HasEndInfo(MethodEntry entry)
}
internal Mono.Cecil.MemberDefinitionCollection`1 : Collection`1<T> {
private TypeDefinition container
internal void .ctor(TypeDefinition container)
internal void .ctor(TypeDefinition container, int capacity)
protected void OnAdd(T item, int index)
protected void OnSet(T item, int index)
protected void OnInsert(T item, int index)
protected void OnRemove(T item, int index)
protected void OnClear()
private void Attach(T element)
private void Detach(T element)
}
internal Mono.Cecil.MemberReference : object {
private string name
private TypeReference declaring_type
internal MetadataToken token
internal object projection
public string Name
public string FullName
public TypeReference DeclaringType
public MetadataToken MetadataToken
public bool IsWindowsRuntimeProjection
internal bool HasImage
public ModuleDefinition Module
public bool IsDefinition
public bool ContainsGenericParameter
public string get_Name()
public void set_Name(string value)
public string get_FullName()
public TypeReference get_DeclaringType()
public void set_DeclaringType(TypeReference value)
public MetadataToken get_MetadataToken()
public void set_MetadataToken(MetadataToken value)
public bool get_IsWindowsRuntimeProjection()
internal bool get_HasImage()
public ModuleDefinition get_Module()
public bool get_IsDefinition()
public bool get_ContainsGenericParameter()
internal void .ctor(string name)
internal string MemberFullName()
public IMemberDefinition Resolve()
protected IMemberDefinition ResolveDefinition()
public string ToString()
}
internal Mono.Cecil.MemberRefTable : MetadataTable`1<Row`3<UInt32, UInt32, UInt32>> {
public void Write(TableHeapBuffer buffer)
}
internal Mono.Cecil.Metadata.BlobHeap : Heap {
public void .ctor(Byte[] data)
public Byte[] Read(UInt32 index)
public void GetView(UInt32 signature, Byte[]& buffer, Int32& index, Int32& length)
}
internal Mono.Cecil.Metadata.BlobHeapBuffer : HeapBuffer {
private Dictionary`2<ByteBuffer, UInt32> blobs
public bool IsEmpty
public bool get_IsEmpty()
public UInt32 GetBlobIndex(ByteBuffer blob)
private void WriteBlob(ByteBuffer blob)
}
internal Mono.Cecil.Metadata.CodedIndex : Enum {
public int value__
public CodedIndex TypeDefOrRef
public CodedIndex HasConstant
public CodedIndex HasCustomAttribute
public CodedIndex HasFieldMarshal
public CodedIndex HasDeclSecurity
public CodedIndex MemberRefParent
public CodedIndex HasSemantics
public CodedIndex MethodDefOrRef
public CodedIndex MemberForwarded
public CodedIndex Implementation
public CodedIndex CustomAttributeType
public CodedIndex ResolutionScope
public CodedIndex TypeOrMethodDef
public CodedIndex HasCustomDebugInformation
}
internal Mono.Cecil.Metadata.DataBuffer : ByteBuffer {
private int buffer_align
public int BufferAlign
private void Align(int align)
public UInt32 AddData(Byte[] data, int align)
public int get_BufferAlign()
}
internal Mono.Cecil.Metadata.ElementType : Enum {
public byte value__
public ElementType None
public ElementType Void
public ElementType Boolean
public ElementType Char
public ElementType I1
public ElementType U1
public ElementType I2
public ElementType U2
public ElementType I4
public ElementType U4
public ElementType I8
public ElementType U8
public ElementType R4
public ElementType R8
public ElementType String
public ElementType Ptr
public ElementType ByRef
public ElementType ValueType
public ElementType Class
public ElementType Var
public ElementType Array
public ElementType GenericInst
public ElementType TypedByRef
public ElementType I
public ElementType U
public ElementType FnPtr
public ElementType Object
public ElementType SzArray
public ElementType MVar
public ElementType CModReqD
public ElementType CModOpt
public ElementType Internal
public ElementType Modifier
public ElementType Sentinel
public ElementType Pinned
public ElementType Type
public ElementType Boxed
public ElementType Enum
}
internal Mono.Cecil.Metadata.GuidHeap : Heap {
public void .ctor(Byte[] data)
public Guid Read(UInt32 index)
}
internal Mono.Cecil.Metadata.GuidHeapBuffer : HeapBuffer {
private Dictionary`2<Guid, UInt32> guids
public bool IsEmpty
public bool get_IsEmpty()
public UInt32 GetGuidIndex(Guid guid)
private void WriteGuid(Guid guid)
}
internal Mono.Cecil.Metadata.Heap : object {
public int IndexSize
internal Byte[] data
protected void .ctor(Byte[] data)
}
internal Mono.Cecil.Metadata.HeapBuffer : ByteBuffer {
public bool IsLarge
public bool IsEmpty
public bool get_IsLarge()
public bool get_IsEmpty()
protected void .ctor(int length)
}
internal Mono.Cecil.Metadata.PdbHeap : Heap {
public Byte[] Id
public UInt32 EntryPoint
public long TypeSystemTables
public UInt32[] TypeSystemTableRows
public void .ctor(Byte[] data)
public bool HasTable(Table table)
}
internal Mono.Cecil.Metadata.PdbHeapBuffer : HeapBuffer {
public bool IsEmpty
public bool get_IsEmpty()
}
internal Mono.Cecil.Metadata.ResourceBuffer : ByteBuffer {
public UInt32 AddResource(Byte[] resource)
}
internal Mono.Cecil.Metadata.Row`2 : ValueType {
internal T1 Col1
internal T2 Col2
public void .ctor(T1 col1, T2 col2)
}
internal Mono.Cecil.Metadata.Row`3 : ValueType {
internal T1 Col1
internal T2 Col2
internal T3 Col3
public void .ctor(T1 col1, T2 col2, T3 col3)
}
internal Mono.Cecil.Metadata.Row`4 : ValueType {
internal T1 Col1
internal T2 Col2
internal T3 Col3
internal T4 Col4
public void .ctor(T1 col1, T2 col2, T3 col3, T4 col4)
}
internal Mono.Cecil.Metadata.Row`5 : ValueType {
internal T1 Col1
internal T2 Col2
internal T3 Col3
internal T4 Col4
internal T5 Col5
public void .ctor(T1 col1, T2 col2, T3 col3, T4 col4, T5 col5)
}
internal Mono.Cecil.Metadata.Row`6 : ValueType {
internal T1 Col1
internal T2 Col2
internal T3 Col3
internal T4 Col4
internal T5 Col5
internal T6 Col6
public void .ctor(T1 col1, T2 col2, T3 col3, T4 col4, T5 col5, T6 col6)
}
internal Mono.Cecil.Metadata.Row`9 : ValueType {
internal T1 Col1
internal T2 Col2
internal T3 Col3
internal T4 Col4
internal T5 Col5
internal T6 Col6
internal T7 Col7
internal T8 Col8
internal T9 Col9
public void .ctor(T1 col1, T2 col2, T3 col3, T4 col4, T5 col5, T6 col6, T7 col7, T8 col8, T9 col9)
}
internal Mono.Cecil.Metadata.RowEqualityComparer : object {
public bool Equals(Row`2<string, string> x, Row`2<string, string> y)
public int GetHashCode(Row`2<string, string> obj)
public bool Equals(Row`2<UInt32, UInt32> x, Row`2<UInt32, UInt32> y)
public int GetHashCode(Row`2<UInt32, UInt32> obj)
public bool Equals(Row`3<UInt32, UInt32, UInt32> x, Row`3<UInt32, UInt32, UInt32> y)
public int GetHashCode(Row`3<UInt32, UInt32, UInt32> obj)
}
internal Mono.Cecil.Metadata.StringHeap : Heap {
private Dictionary`2<UInt32, string> strings
public void .ctor(Byte[] data)
public string Read(UInt32 index)
protected string ReadStringAt(UInt32 index)
}
internal Mono.Cecil.Metadata.StringHeapBuffer : HeapBuffer {
protected Dictionary`2<string, UInt32> strings
public bool IsEmpty
public bool get_IsEmpty()
public UInt32 GetStringIndex(string string)
public UInt32[] WriteStrings()
private List`1<KeyValuePair`2<string, UInt32>> SortStrings(Dictionary`2<string, UInt32> strings)
private bool IsLowSurrogateChar(int c)
protected void WriteString(string string)
}
internal Mono.Cecil.Metadata.Table : Enum {
public byte value__
public Table Module
public Table TypeRef
public Table TypeDef
public Table FieldPtr
public Table Field
public Table MethodPtr
public Table Method
public Table ParamPtr
public Table Param
public Table InterfaceImpl
public Table MemberRef
public Table Constant
public Table CustomAttribute
public Table FieldMarshal
public Table DeclSecurity
public Table ClassLayout
public Table FieldLayout
public Table StandAloneSig
public Table EventMap
public Table EventPtr
public Table Event
public Table PropertyMap
public Table PropertyPtr
public Table Property
public Table MethodSemantics
public Table MethodImpl
public Table ModuleRef
public Table TypeSpec
public Table ImplMap
public Table FieldRVA
public Table EncLog
public Table EncMap
public Table Assembly
public Table AssemblyProcessor
public Table AssemblyOS
public Table AssemblyRef
public Table AssemblyRefProcessor
public Table AssemblyRefOS
public Table File
public Table ExportedType
public Table ManifestResource
public Table NestedClass
public Table GenericParam
public Table MethodSpec
public Table GenericParamConstraint
public Table Document
public Table MethodDebugInformation
public Table LocalScope
public Table LocalVariable
public Table LocalConstant
public Table ImportScope
public Table StateMachineMethod
public Table CustomDebugInformation
}
internal Mono.Cecil.Metadata.TableHeap : Heap {
public long Valid
public long Sorted
public TableInformation[] Tables
public TableInformation Item
public TableInformation get_Item(Table table)
public void .ctor(Byte[] data)
public bool HasTable(Table table)
}
internal Mono.Cecil.Metadata.TableHeapBuffer : HeapBuffer {
private ModuleDefinition module
private MetadataBuilder metadata
internal TableInformation[] table_infos
internal MetadataTable[] tables
private bool large_string
private bool large_blob
private bool large_guid
private Int32[] coded_index_sizes
private Func`2<Table, int> counter
internal UInt32[] string_offsets
public bool IsEmpty
public bool get_IsEmpty()
public void .ctor(ModuleDefinition module, MetadataBuilder metadata)
private int GetTableLength(Table table)
public TTable GetTable(Table table)
public void WriteBySize(UInt32 value, int size)
public void WriteBySize(UInt32 value, bool large)
public void WriteString(UInt32 string)
public void WriteBlob(UInt32 blob)
public void WriteGuid(UInt32 guid)
public void WriteRID(UInt32 rid, Table table)
private int GetCodedIndexSize(CodedIndex coded_index)
public void WriteCodedRID(UInt32 rid, CodedIndex coded_index)
public void WriteTableHeap()
private void WriteRowCount()
private void WriteTables()
private ulong GetValid()
public void ComputeTableInformations()
private void ComputeTableInformations(TableHeapBuffer table_heap)
private byte GetHeapSizes()
private byte GetTableHeapVersion()
public void FixupData(UInt32 data_rva)
}
internal Mono.Cecil.Metadata.TableInformation : ValueType {
public UInt32 Offset
public UInt32 Length
public UInt32 RowSize
public bool IsLarge
public bool get_IsLarge()
}
internal Mono.Cecil.Metadata.UserStringHeap : StringHeap {
public void .ctor(Byte[] data)
protected string ReadStringAt(UInt32 index)
}
internal Mono.Cecil.Metadata.UserStringHeapBuffer : StringHeapBuffer {
public UInt32 GetStringIndex(string string)
protected void WriteString(string string)
}
internal Mono.Cecil.MetadataBuilder : object {
internal ModuleDefinition module
internal ISymbolWriterProvider symbol_writer_provider
internal ISymbolWriter symbol_writer
internal TextMap text_map
internal string fq_name
internal UInt32 timestamp
private Dictionary`2<Row`3<UInt32, UInt32, UInt32>, MetadataToken> type_ref_map
private Dictionary`2<UInt32, MetadataToken> type_spec_map
private Dictionary`2<Row`3<UInt32, UInt32, UInt32>, MetadataToken> member_ref_map
private Dictionary`2<Row`2<UInt32, UInt32>, MetadataToken> method_spec_map
private Collection`1<GenericParameter> generic_parameters
internal CodeWriter code
internal DataBuffer data
internal ResourceBuffer resources
internal StringHeapBuffer string_heap
internal GuidHeapBuffer guid_heap
internal UserStringHeapBuffer user_string_heap
internal BlobHeapBuffer blob_heap
internal TableHeapBuffer table_heap
internal PdbHeapBuffer pdb_heap
internal MetadataToken entry_point
internal UInt32 type_rid
internal UInt32 field_rid
internal UInt32 method_rid
internal UInt32 param_rid
internal UInt32 property_rid
internal UInt32 event_rid
internal UInt32 local_variable_rid
internal UInt32 local_constant_rid
private TypeRefTable type_ref_table
private TypeDefTable type_def_table
private FieldTable field_table
private MethodTable method_table
private ParamTable param_table
private InterfaceImplTable iface_impl_table
private MemberRefTable member_ref_table
private ConstantTable constant_table
private CustomAttributeTable custom_attribute_table
private DeclSecurityTable declsec_table
private StandAloneSigTable standalone_sig_table
private EventMapTable event_map_table
private EventTable event_table
private PropertyMapTable property_map_table
private PropertyTable property_table
private TypeSpecTable typespec_table
private MethodSpecTable method_spec_table
internal MetadataBuilder metadata_builder
private DocumentTable document_table
private MethodDebugInformationTable method_debug_information_table
private LocalScopeTable local_scope_table
private LocalVariableTable local_variable_table
private LocalConstantTable local_constant_table
private ImportScopeTable import_scope_table
private StateMachineMethodTable state_machine_method_table
private CustomDebugInformationTable custom_debug_information_table
private Dictionary`2<Row`2<UInt32, UInt32>, MetadataToken> import_scope_map
private Dictionary`2<string, MetadataToken> document_map
public void .ctor(ModuleDefinition module, string fq_name, UInt32 timestamp, ISymbolWriterProvider symbol_writer_provider)
public void .ctor(ModuleDefinition module, PortablePdbWriterProvider writer_provider)
public void SetSymbolWriter(ISymbolWriter writer)
private TextMap CreateTextMap()
private TTable GetTable(Table table)
private UInt32 GetStringIndex(string string)
private UInt32 GetGuidIndex(Guid guid)
private UInt32 GetBlobIndex(ByteBuffer blob)
private UInt32 GetBlobIndex(Byte[] blob)
public void BuildMetadata()
private void BuildModule()
private void BuildAssembly()
private void BuildModules()
private string GetModuleFileName(string name)
private void AddAssemblyReferences()
private void AddModuleReferences()
private void AddResources()
private UInt32 AddLinkedResource(LinkedResource resource)
private UInt32 AddEmbeddedResource(EmbeddedResource resource)
private void AddExportedTypes()
private MetadataToken GetExportedTypeScope(ExportedType exported_type)
private void BuildTypes()
private void AttachTokens()
private void AttachTypeToken(TypeDefinition type)
private void AttachNestedTypesToken(TypeDefinition type)
private void AttachFieldsToken(TypeDefinition type)
private void AttachMethodsToken(TypeDefinition type)
private MetadataToken GetTypeToken(TypeReference type)
private MetadataToken GetTypeSpecToken(TypeReference type)
private MetadataToken AddTypeSpecification(TypeReference type, UInt32 row)
private MetadataToken GetTypeRefToken(TypeReference type)
private Row`3<UInt32, UInt32, UInt32> CreateTypeRefRow(TypeReference type)
private MetadataToken GetScopeToken(TypeReference type)
private UInt32 MakeCodedRID(IMetadataTokenProvider provider, CodedIndex index)
private UInt32 MakeCodedRID(MetadataToken token, CodedIndex index)
private MetadataToken AddTypeReference(TypeReference type, Row`3<UInt32, UInt32, UInt32> row)
private void AddTypes()
private void AddType(TypeDefinition type)
private void AddGenericParameters(IGenericParameterProvider owner)
private void AddGenericParameters()
private void AddConstraints(GenericParameter generic_parameter, GenericParamConstraintTable table)
private void AddInterfaces(TypeDefinition type)
private void AddLayoutInfo(TypeDefinition type)
private void AddNestedTypes(TypeDefinition type)
private void AddFields(TypeDefinition type)
private void AddField(FieldDefinition field)
private void AddFieldRVA(FieldDefinition field)
private void AddFieldLayout(FieldDefinition field)
private void AddMethods(TypeDefinition type)
private void AddMethod(MethodDefinition method)
private void AddParameters(MethodDefinition method)
private void AddPInvokeInfo(MethodDefinition method)
private void AddOverrides(MethodDefinition method)
private bool RequiresParameterRow(ParameterDefinition parameter)
private void AddParameter(ushort sequence, ParameterDefinition parameter, ParamTable table)
private void AddMarshalInfo(IMarshalInfoProvider owner)
private void AddProperties(TypeDefinition type)
private void AddProperty(PropertyDefinition property)
private void AddOtherSemantic(IMetadataTokenProvider owner, Collection`1<MethodDefinition> others)
private void AddEvents(TypeDefinition type)
private void AddEvent(EventDefinition event)
private void AddSemantic(MethodSemanticsAttributes semantics, IMetadataTokenProvider provider, MethodDefinition method)
private void AddConstant(IConstantProvider owner, TypeReference type)
private ElementType GetConstantType(TypeReference constant_type, object constant)
private ElementType GetConstantType(Type type)
private void AddCustomAttributes(ICustomAttributeProvider owner)
private void AddSecurityDeclarations(ISecurityDeclarationProvider owner)
private MetadataToken GetMemberRefToken(MemberReference member)
private Row`3<UInt32, UInt32, UInt32> CreateMemberRefRow(MemberReference member)
private MetadataToken AddMemberReference(MemberReference member, Row`3<UInt32, UInt32, UInt32> row)
private MetadataToken GetMethodSpecToken(MethodSpecification method_spec)
private void AddMethodSpecification(MethodSpecification method_spec, Row`2<UInt32, UInt32> row)
private Row`2<UInt32, UInt32> CreateMethodSpecRow(MethodSpecification method_spec)
private SignatureWriter CreateSignatureWriter()
private SignatureWriter GetMethodSpecSignature(MethodSpecification method_spec)
public UInt32 AddStandAloneSignature(UInt32 signature)
public UInt32 GetLocalVariableBlobIndex(Collection`1<VariableDefinition> variables)
public UInt32 GetCallSiteBlobIndex(CallSite call_site)
public UInt32 GetConstantTypeBlobIndex(TypeReference constant_type)
private SignatureWriter GetVariablesSignature(Collection`1<VariableDefinition> variables)
private SignatureWriter GetConstantTypeSignature(TypeReference constant_type)
private SignatureWriter GetFieldSignature(FieldReference field)
private SignatureWriter GetMethodSignature(IMethodSignature method)
private SignatureWriter GetMemberRefSignature(MemberReference member)
private SignatureWriter GetPropertySignature(PropertyDefinition property)
private SignatureWriter GetTypeSpecSignature(TypeReference type)
private SignatureWriter GetConstantSignature(ElementType type, object value)
private SignatureWriter GetCustomAttributeSignature(CustomAttribute attribute)
private SignatureWriter GetSecurityDeclarationSignature(SecurityDeclaration declaration)
private SignatureWriter GetMarshalInfoSignature(IMarshalInfoProvider owner)
private Exception CreateForeignMemberException(MemberReference member)
public MetadataToken LookupToken(IMetadataTokenProvider provider)
public void AddMethodDebugInformation(MethodDebugInformation method_info)
private void AddStateMachineMethod(MethodDebugInformation method_info)
private void AddLocalScope(MethodDebugInformation method_info, ScopeDebugInformation scope)
private void AddLocalVariables(ScopeDebugInformation scope)
private void AddLocalConstants(ScopeDebugInformation scope)
private SignatureWriter GetConstantSignature(ConstantDebugInformation constant)
public void AddCustomDebugInformations(ICustomDebugInformationProvider provider)
private void AddStateMachineScopeDebugInformation(ICustomDebugInformationProvider provider, StateMachineScopeDebugInformation state_machine_scope)
private void AddAsyncMethodBodyDebugInformation(ICustomDebugInformationProvider provider, AsyncMethodBodyDebugInformation async_method)
private void AddEmbeddedSourceDebugInformation(ICustomDebugInformationProvider provider, EmbeddedSourceDebugInformation embedded_source)
private void AddSourceLinkDebugInformation(ICustomDebugInformationProvider provider, SourceLinkDebugInformation source_link)
private void AddCustomDebugInformation(ICustomDebugInformationProvider provider, CustomDebugInformation custom_info, SignatureWriter signature)
private void AddCustomDebugInformation(ICustomDebugInformationProvider provider, CustomDebugInformation custom_info, UInt32 blob_index)
private UInt32 AddImportScope(ImportDebugInformation import)
private void AddImportTarget(ImportTarget target, SignatureWriter signature)
private UInt32 GetUTF8StringBlobIndex(string s)
public MetadataToken GetDocumentToken(Document document)
private SignatureWriter GetDocumentNameSignature(Document document)
private bool TryGetDocumentNameSeparator(string path, Char& separator)
private void AddSequencePoints(MethodDebugInformation info)
}
internal Mono.Cecil.MetadataKind : Enum {
public int value__
public MetadataKind Ecma335
public MetadataKind WindowsMetadata
public MetadataKind ManagedWindowsMetadata
}
internal Mono.Cecil.MetadataReader : ByteBuffer {
internal Image image
internal ModuleDefinition module
internal MetadataSystem metadata
internal CodeReader code
internal IGenericContext context
private MetadataReader metadata_reader
public void .ctor(ModuleDefinition module)
public void .ctor(Image image, ModuleDefinition module, MetadataReader metadata_reader)
private int GetCodedIndexSize(CodedIndex index)
private UInt32 ReadByIndexSize(int size)
private Byte[] ReadBlob()
private Byte[] ReadBlob(UInt32 signature)
private UInt32 ReadBlobIndex()
private void GetBlobView(UInt32 signature, Byte[]& blob, Int32& index, Int32& count)
private string ReadString()
private UInt32 ReadStringIndex()
private Guid ReadGuid()
private UInt32 ReadTableIndex(Table table)
private MetadataToken ReadMetadataToken(CodedIndex index)
private int MoveTo(Table table)
private bool MoveTo(Table table, UInt32 row)
public AssemblyNameDefinition ReadAssemblyNameDefinition()
public ModuleDefinition Populate(ModuleDefinition module)
private void InitializeAssemblyReferences()
public Collection`1<AssemblyNameReference> ReadAssemblyReferences()
public MethodDefinition ReadEntryPoint()
public Collection`1<ModuleDefinition> ReadModules()
private string GetModuleFileName(string name)
private void InitializeModuleReferences()
public Collection`1<ModuleReference> ReadModuleReferences()
public bool HasFileResource()
public Collection`1<Resource> ReadResources()
private Row`3<FileAttributes, string, UInt32> ReadFileRecord(UInt32 rid)
public Byte[] GetManagedResource(UInt32 offset)
private void PopulateVersionAndFlags(AssemblyNameReference name)
private void PopulateNameAndCulture(AssemblyNameReference name)
public TypeDefinitionCollection ReadTypes()
private void CompleteTypes()
private void InitializeTypeDefinitions()
private bool IsNested(TypeAttributes attributes)
public bool HasNestedTypes(TypeDefinition type)
public Collection`1<TypeDefinition> ReadNestedTypes(TypeDefinition type)
private void InitializeNestedTypes()
private void AddNestedMapping(UInt32 declaring, UInt32 nested)
private Collection`1<TValue> AddMapping(Dictionary`2<TKey, Collection`1<TValue>> cache, TKey key, TValue value)
private TypeDefinition ReadType(UInt32 rid)
private TypeDefinition GetNestedTypeDeclaringType(TypeDefinition type)
private Range ReadListRange(UInt32 current_index, Table current, Table target)
public Row`2<short, int> ReadTypeLayout(TypeDefinition type)
private void InitializeTypeLayouts()
public TypeReference GetTypeDefOrRef(MetadataToken token)
public TypeDefinition GetTypeDefinition(UInt32 rid)
private TypeDefinition ReadTypeDefinition(UInt32 rid)
private void InitializeTypeReferences()
public TypeReference GetTypeReference(string scope, string full_name)
private TypeReference GetTypeReference(UInt32 rid)
private TypeReference ReadTypeReference(UInt32 rid)
private IMetadataScope GetTypeReferenceScope(MetadataToken scope)
public IEnumerable`1<TypeReference> GetTypeReferences()
private TypeReference GetTypeSpecification(UInt32 rid)
private SignatureReader ReadSignature(UInt32 signature)
public bool HasInterfaces(TypeDefinition type)
public InterfaceImplementationCollection ReadInterfaces(TypeDefinition type)
private void InitializeInterfaces()
private void AddInterfaceMapping(UInt32 type, Row`2<UInt32, MetadataToken> interface)
public Collection`1<FieldDefinition> ReadFields(TypeDefinition type)
private void ReadField(UInt32 field_rid, Collection`1<FieldDefinition> fields)
private void InitializeFields()
private TypeReference ReadFieldType(UInt32 signature)
public int ReadFieldRVA(FieldDefinition field)
private Byte[] GetFieldInitializeValue(int size, UInt32 rva)
private int GetFieldTypeSize(TypeReference type)
private void InitializeFieldRVAs()
public int ReadFieldLayout(FieldDefinition field)
private void InitializeFieldLayouts()
public bool HasEvents(TypeDefinition type)
public Collection`1<EventDefinition> ReadEvents(TypeDefinition type)
private void ReadEvent(UInt32 event_rid, Collection`1<EventDefinition> events)
private void InitializeEvents()
public bool HasProperties(TypeDefinition type)
public Collection`1<PropertyDefinition> ReadProperties(TypeDefinition type)
private void ReadProperty(UInt32 property_rid, Collection`1<PropertyDefinition> properties)
private void InitializeProperties()
private MethodSemanticsAttributes ReadMethodSemantics(MethodDefinition method)
private EventDefinition GetEvent(TypeDefinition type, MetadataToken token)
private PropertyDefinition GetProperty(TypeDefinition type, MetadataToken token)
private TMember GetMember(Collection`1<TMember> members, MetadataToken token)
private void InitializeMethodSemantics()
public void ReadMethods(PropertyDefinition property)
public void ReadMethods(EventDefinition event)
public void ReadAllSemantics(MethodDefinition method)
private void ReadAllSemantics(TypeDefinition type)
public Collection`1<MethodDefinition> ReadMethods(TypeDefinition type)
private void ReadPointers(Table ptr, Table table, Range range, Collection`1<TMember> members, Action`2<UInt32, Collection`1<TMember>> reader)
private bool IsDeleted(IMemberDefinition member)
private void InitializeMethods()
private void ReadMethod(UInt32 method_rid, Collection`1<MethodDefinition> methods)
private void ReadParameters(MethodDefinition method, Range param_range)
private void ReadParameterPointers(MethodDefinition method, Range range)
private void ReadParameter(UInt32 param_rid, MethodDefinition method)
private void ReadMethodSignature(UInt32 signature, IMethodSignature method)
public PInvokeInfo ReadPInvokeInfo(MethodDefinition method)
private void InitializePInvokes()
public bool HasGenericParameters(IGenericParameterProvider provider)
public Collection`1<GenericParameter> ReadGenericParameters(IGenericParameterProvider provider)
private void ReadGenericParametersRange(Range range, IGenericParameterProvider provider, GenericParameterCollection generic_parameters)
private void InitializeGenericParameters()
private Dictionary`2<MetadataToken, Range[]> InitializeRanges(Table table, Func`1<MetadataToken> get_next)
private void AddRange(Dictionary`2<MetadataToken, Range[]> ranges, MetadataToken owner, Range range)
public bool HasGenericConstraints(GenericParameter generic_parameter)
public GenericParameterConstraintCollection ReadGenericConstraints(GenericParameter generic_parameter)
private void InitializeGenericConstraints()
private void AddGenericConstraintMapping(UInt32 generic_parameter, Row`2<UInt32, MetadataToken> constraint)
public bool HasOverrides(MethodDefinition method)
public Collection`1<MethodReference> ReadOverrides(MethodDefinition method)
private void InitializeOverrides()
private void AddOverrideMapping(UInt32 method_rid, MetadataToken override)
public MethodBody ReadMethodBody(MethodDefinition method)
public int ReadCodeSize(MethodDefinition method)
public CallSite ReadCallSite(MetadataToken token)
public VariableDefinitionCollection ReadVariables(MetadataToken local_var_token, MethodDefinition method)
public IMetadataTokenProvider LookupToken(MetadataToken token)
public FieldDefinition GetFieldDefinition(UInt32 rid)
private FieldDefinition LookupField(UInt32 rid)
public MethodDefinition GetMethodDefinition(UInt32 rid)
private MethodDefinition LookupMethod(UInt32 rid)
private MethodSpecification GetMethodSpecification(UInt32 rid)
private MethodSpecification ReadMethodSpecSignature(UInt32 signature, MethodReference method)
private MemberReference GetMemberReference(UInt32 rid)
private MemberReference ReadMemberReference(UInt32 rid)
private MemberReference ReadTypeMemberReference(MetadataToken type, string name, UInt32 signature)
private MemberReference ReadMemberReferenceSignature(UInt32 signature, TypeReference declaring_type)
private MemberReference ReadMethodMemberReference(MetadataToken token, string name, UInt32 signature)
private void InitializeMemberReferences()
public IEnumerable`1<MemberReference> GetMemberReferences()
private void InitializeConstants()
public TypeReference ReadConstantSignature(MetadataToken token)
public object ReadConstant(IConstantProvider owner)
private object ReadConstantValue(ElementType etype, UInt32 signature)
private string ReadConstantString(UInt32 signature)
private object ReadConstantPrimitive(ElementType type, UInt32 signature)
internal void InitializeCustomAttributes()
public bool HasCustomAttributes(ICustomAttributeProvider owner)
public Collection`1<CustomAttribute> ReadCustomAttributes(ICustomAttributeProvider owner)
private void ReadCustomAttributeRange(Range range, Collection`1<CustomAttribute> custom_attributes)
private int RangesSize(Range[] ranges)
public IEnumerable`1<CustomAttribute> GetCustomAttributes()
public Byte[] ReadCustomAttributeBlob(UInt32 signature)
public void ReadCustomAttributeSignature(CustomAttribute attribute)
private void InitializeMarshalInfos()
public bool HasMarshalInfo(IMarshalInfoProvider owner)
public MarshalInfo ReadMarshalInfo(IMarshalInfoProvider owner)
private void InitializeSecurityDeclarations()
public bool HasSecurityDeclarations(ISecurityDeclarationProvider owner)
public Collection`1<SecurityDeclaration> ReadSecurityDeclarations(ISecurityDeclarationProvider owner)
private void ReadSecurityDeclarationRange(Range range, Collection`1<SecurityDeclaration> security_declarations)
public Byte[] ReadSecurityDeclarationBlob(UInt32 signature)
public void ReadSecurityDeclarationSignature(SecurityDeclaration declaration)
private void ReadXmlSecurityDeclaration(UInt32 signature, SecurityDeclaration declaration)
public Collection`1<ExportedType> ReadExportedTypes()
private IMetadataScope GetExportedTypeScope(MetadataToken token)
private ModuleReference GetModuleReferenceFromFile(MetadataToken token)
private void InitializeDocuments()
public Collection`1<SequencePoint> ReadSequencePoints(MethodDefinition method)
public Document GetDocument(UInt32 rid)
private void InitializeLocalScopes()
public ScopeDebugInformation ReadScope(MethodDefinition method)
private bool AddScope(Collection`1<ScopeDebugInformation> scopes, ScopeDebugInformation scope)
private ScopeDebugInformation ReadLocalScope(Row`6<UInt32, Range, Range, UInt32, UInt32, UInt32> record)
private VariableDebugInformation ReadLocalVariable(UInt32 rid)
private ConstantDebugInformation ReadLocalConstant(UInt32 rid)
private void InitializeImportScopes()
public string ReadUTF8StringBlob(UInt32 signature)
private string ReadUnicodeStringBlob(UInt32 signature)
private string ReadStringBlob(UInt32 signature, Encoding encoding)
private ImportTarget ReadImportTarget(SignatureReader signature)
private void InitializeStateMachineMethods()
public MethodDefinition ReadStateMachineKickoffMethod(MethodDefinition method)
private void InitializeCustomDebugInformations()
public Collection`1<CustomDebugInformation> GetCustomDebugInformation(ICustomDebugInformationProvider provider)
public Byte[] ReadRawEmbeddedSourceDebugInformation(UInt32 index)
public Row`2<Byte[], bool> ReadEmbeddedSourceDebugInformation(UInt32 index)
private MetadataToken <InitializeGenericParameters>b__106_0()
private MetadataToken <InitializeCustomAttributes>b__141_0()
private MetadataToken <InitializeSecurityDeclarations>b__152_0()
}
internal Mono.Cecil.MetadataResolver : object {
private IAssemblyResolver assembly_resolver
public IAssemblyResolver AssemblyResolver
public IAssemblyResolver get_AssemblyResolver()
public void .ctor(IAssemblyResolver assemblyResolver)
public TypeDefinition Resolve(TypeReference type)
private TypeDefinition GetType(ModuleDefinition module, TypeReference reference)
private TypeDefinition GetTypeDefinition(ModuleDefinition module, TypeReference type)
public FieldDefinition Resolve(FieldReference field)
private FieldDefinition GetField(TypeDefinition type, FieldReference reference)
private FieldDefinition GetField(Collection`1<FieldDefinition> fields, FieldReference reference)
public MethodDefinition Resolve(MethodReference method)
private MethodDefinition GetMethod(TypeDefinition type, MethodReference reference)
public MethodDefinition GetMethod(Collection`1<MethodDefinition> methods, MethodReference reference)
private bool AreSame(Collection`1<ParameterDefinition> a, Collection`1<ParameterDefinition> b)
private bool IsVarArgCallTo(MethodDefinition method, MethodReference reference)
private bool AreSame(TypeSpecification a, TypeSpecification b)
private bool AreSame(FunctionPointerType a, FunctionPointerType b)
private bool AreSame(ArrayType a, ArrayType b)
private bool AreSame(IModifierType a, IModifierType b)
private bool AreSame(GenericInstanceType a, GenericInstanceType b)
private bool AreSame(GenericParameter a, GenericParameter b)
private bool AreSame(TypeReference a, TypeReference b)
}
internal Mono.Cecil.MetadataScopeType : Enum {
public int value__
public MetadataScopeType AssemblyNameReference
public MetadataScopeType ModuleReference
public MetadataScopeType ModuleDefinition
}
internal Mono.Cecil.MetadataSystem : object {
internal AssemblyNameReference[] AssemblyReferences
internal ModuleReference[] ModuleReferences
internal TypeDefinition[] Types
internal TypeReference[] TypeReferences
internal FieldDefinition[] Fields
internal MethodDefinition[] Methods
internal MemberReference[] MemberReferences
internal Dictionary`2<UInt32, Collection`1<UInt32>> NestedTypes
internal Dictionary`2<UInt32, UInt32> ReverseNestedTypes
internal Dictionary`2<UInt32, Collection`1<Row`2<UInt32, MetadataToken>>> Interfaces
internal Dictionary`2<UInt32, Row`2<ushort, UInt32>> ClassLayouts
internal Dictionary`2<UInt32, UInt32> FieldLayouts
internal Dictionary`2<UInt32, UInt32> FieldRVAs
internal Dictionary`2<MetadataToken, UInt32> FieldMarshals
internal Dictionary`2<MetadataToken, Row`2<ElementType, UInt32>> Constants
internal Dictionary`2<UInt32, Collection`1<MetadataToken>> Overrides
internal Dictionary`2<MetadataToken, Range[]> CustomAttributes
internal Dictionary`2<MetadataToken, Range[]> SecurityDeclarations
internal Dictionary`2<UInt32, Range> Events
internal Dictionary`2<UInt32, Range> Properties
internal Dictionary`2<UInt32, Row`2<MethodSemanticsAttributes, MetadataToken>> Semantics
internal Dictionary`2<UInt32, Row`3<PInvokeAttributes, UInt32, UInt32>> PInvokes
internal Dictionary`2<MetadataToken, Range[]> GenericParameters
internal Dictionary`2<UInt32, Collection`1<Row`2<UInt32, MetadataToken>>> GenericConstraints
internal Document[] Documents
internal Dictionary`2<UInt32, Collection`1<Row`6<UInt32, Range, Range, UInt32, UInt32, UInt32>>> LocalScopes
internal ImportDebugInformation[] ImportScopes
internal Dictionary`2<UInt32, UInt32> StateMachineMethods
internal Dictionary`2<MetadataToken, Row`3[]> CustomDebugInformations
private Dictionary`2<string, Row`2<ElementType, bool>> primitive_value_types
private void InitializePrimitives()
public void TryProcessPrimitiveTypeReference(TypeReference type)
public bool TryGetPrimitiveElementType(TypeDefinition type, ElementType& etype)
private bool TryGetPrimitiveData(TypeReference type, Row`2& primitive_data)
public void Clear()
public AssemblyNameReference GetAssemblyNameReference(UInt32 rid)
public TypeDefinition GetTypeDefinition(UInt32 rid)
public void AddTypeDefinition(TypeDefinition type)
public TypeReference GetTypeReference(UInt32 rid)
public void AddTypeReference(TypeReference type)
public FieldDefinition GetFieldDefinition(UInt32 rid)
public void AddFieldDefinition(FieldDefinition field)
public MethodDefinition GetMethodDefinition(UInt32 rid)
public void AddMethodDefinition(MethodDefinition method)
public MemberReference GetMemberReference(UInt32 rid)
public void AddMemberReference(MemberReference member)
public bool TryGetNestedTypeMapping(TypeDefinition type, Collection`1& mapping)
public void SetNestedTypeMapping(UInt32 type_rid, Collection`1<UInt32> mapping)
public bool TryGetReverseNestedTypeMapping(TypeDefinition type, UInt32& declaring)
public void SetReverseNestedTypeMapping(UInt32 nested, UInt32 declaring)
public bool TryGetInterfaceMapping(TypeDefinition type, Collection`1& mapping)
public void SetInterfaceMapping(UInt32 type_rid, Collection`1<Row`2<UInt32, MetadataToken>> mapping)
public void AddPropertiesRange(UInt32 type_rid, Range range)
public bool TryGetPropertiesRange(TypeDefinition type, Range& range)
public void AddEventsRange(UInt32 type_rid, Range range)
public bool TryGetEventsRange(TypeDefinition type, Range& range)
public bool TryGetGenericParameterRanges(IGenericParameterProvider owner, Range[]& ranges)
public bool TryGetCustomAttributeRanges(ICustomAttributeProvider owner, Range[]& ranges)
public bool TryGetSecurityDeclarationRanges(ISecurityDeclarationProvider owner, Range[]& ranges)
public bool TryGetGenericConstraintMapping(GenericParameter generic_parameter, Collection`1& mapping)
public void SetGenericConstraintMapping(UInt32 gp_rid, Collection`1<Row`2<UInt32, MetadataToken>> mapping)
public bool TryGetOverrideMapping(MethodDefinition method, Collection`1& mapping)
public void SetOverrideMapping(UInt32 rid, Collection`1<MetadataToken> mapping)
public Document GetDocument(UInt32 rid)
public bool TryGetLocalScopes(MethodDefinition method, Collection`1& scopes)
public void SetLocalScopes(UInt32 method_rid, Collection`1<Row`6<UInt32, Range, Range, UInt32, UInt32, UInt32>> records)
public ImportDebugInformation GetImportScope(UInt32 rid)
public bool TryGetStateMachineKickOffMethod(MethodDefinition method, UInt32& rid)
public TypeDefinition GetFieldDeclaringType(UInt32 field_rid)
public TypeDefinition GetMethodDeclaringType(UInt32 method_rid)
private TypeDefinition BinaryRangeSearch(TypeDefinition[] types, UInt32 rid, bool field)
}
internal Mono.Cecil.MetadataTable : object {
public int Length
public bool IsLarge
public int get_Length()
public bool get_IsLarge()
public void Write(TableHeapBuffer buffer)
public void Sort()
}
internal Mono.Cecil.MetadataTable`1 : MetadataTable {
internal TRow[] rows
internal int length
public int Length
public int get_Length()
public int AddRow(TRow row)
private void Grow()
public void Sort()
}
internal Mono.Cecil.MetadataToken : ValueType {
private UInt32 token
public MetadataToken Zero
public UInt32 RID
public TokenType TokenType
public UInt32 get_RID()
public TokenType get_TokenType()
public void .ctor(UInt32 token)
public void .ctor(TokenType type)
public void .ctor(TokenType type, UInt32 rid)
public void .ctor(TokenType type, int rid)
public int ToInt32()
public UInt32 ToUInt32()
public int GetHashCode()
public bool Equals(MetadataToken other)
public bool Equals(object obj)
public bool op_Equality(MetadataToken one, MetadataToken other)
public bool op_Inequality(MetadataToken one, MetadataToken other)
public string ToString()
}
internal Mono.Cecil.MetadataType : Enum {
public byte value__
public MetadataType Void
public MetadataType Boolean
public MetadataType Char
public MetadataType SByte
public MetadataType Byte
public MetadataType Int16
public MetadataType UInt16
public MetadataType Int32
public MetadataType UInt32
public MetadataType Int64
public MetadataType UInt64
public MetadataType Single
public MetadataType Double
public MetadataType String
public MetadataType Pointer
public MetadataType ByReference
public MetadataType ValueType
public MetadataType Class
public MetadataType Var
public MetadataType Array
public MetadataType GenericInstance
public MetadataType TypedByReference
public MetadataType IntPtr
public MetadataType UIntPtr
public MetadataType FunctionPointer
public MetadataType Object
public MetadataType MVar
public MetadataType RequiredModifier
public MetadataType OptionalModifier
public MetadataType Sentinel
public MetadataType Pinned
}
internal Mono.Cecil.MethodAttributes : Enum {
public ushort value__
public MethodAttributes MemberAccessMask
public MethodAttributes CompilerControlled
public MethodAttributes Private
public MethodAttributes FamANDAssem
public MethodAttributes Assembly
public MethodAttributes Family
public MethodAttributes FamORAssem
public MethodAttributes Public
public MethodAttributes Static
public MethodAttributes Final
public MethodAttributes Virtual
public MethodAttributes HideBySig
public MethodAttributes VtableLayoutMask
public MethodAttributes ReuseSlot
public MethodAttributes NewSlot
public MethodAttributes CheckAccessOnOverride
public MethodAttributes Abstract
public MethodAttributes SpecialName
public MethodAttributes PInvokeImpl
public MethodAttributes UnmanagedExport
public MethodAttributes RTSpecialName
public MethodAttributes HasSecurity
public MethodAttributes RequireSecObject
}
internal Mono.Cecil.MethodCallingConvention : Enum {
public byte value__
public MethodCallingConvention Default
public MethodCallingConvention C
public MethodCallingConvention StdCall
public MethodCallingConvention ThisCall
public MethodCallingConvention FastCall
public MethodCallingConvention VarArg
public MethodCallingConvention Unmanaged
public MethodCallingConvention Generic
}
internal Mono.Cecil.MethodDebugInformationTable : MetadataTable`1<Row`2<UInt32, UInt32>> {
public void Write(TableHeapBuffer buffer)
}
internal Mono.Cecil.MethodDefinition : MethodReference {
private ushort attributes
private ushort impl_attributes
internal Boolean modreq(System.Runtime.CompilerServices.IsVolatile) sem_attrs_ready
internal MethodSemanticsAttributes sem_attrs
private Collection`1<CustomAttribute> custom_attributes
private Collection`1<SecurityDeclaration> security_declarations
internal UInt32 rva
internal PInvokeInfo pinvoke
private Collection`1<MethodReference> overrides
internal MethodBody body
internal MethodDebugInformation debug_info
internal Collection`1<CustomDebugInformation> custom_infos
public string Name
public MethodAttributes Attributes
public MethodImplAttributes ImplAttributes
public MethodSemanticsAttributes SemanticsAttributes
internal MethodDefinitionProjection WindowsRuntimeProjection
public bool HasSecurityDeclarations
public Collection`1<SecurityDeclaration> SecurityDeclarations
public bool HasCustomAttributes
public Collection`1<CustomAttribute> CustomAttributes
public int RVA
public bool HasBody
public MethodBody Body
public MethodDebugInformation DebugInformation
public bool HasPInvokeInfo
public PInvokeInfo PInvokeInfo
public bool HasOverrides
public Collection`1<MethodReference> Overrides
public bool HasGenericParameters
public Collection`1<GenericParameter> GenericParameters
public bool HasCustomDebugInformations
public Collection`1<CustomDebugInformation> CustomDebugInformations
public bool IsCompilerControlled
public bool IsPrivate
public bool IsFamilyAndAssembly
public bool IsAssembly
public bool IsFamily
public bool IsFamilyOrAssembly
public bool IsPublic
public bool IsStatic
public bool IsFinal
public bool IsVirtual
public bool IsHideBySig
public bool IsReuseSlot
public bool IsNewSlot
public bool IsCheckAccessOnOverride
public bool IsAbstract
public bool IsSpecialName
public bool IsPInvokeImpl
public bool IsUnmanagedExport
public bool IsRuntimeSpecialName
public bool HasSecurity
public bool IsIL
public bool IsNative
public bool IsRuntime
public bool IsUnmanaged
public bool IsManaged
public bool IsForwardRef
public bool IsPreserveSig
public bool IsInternalCall
public bool IsSynchronized
public bool NoInlining
public bool NoOptimization
public bool AggressiveInlining
public bool AggressiveOptimization
public bool IsSetter
public bool IsGetter
public bool IsOther
public bool IsAddOn
public bool IsRemoveOn
public bool IsFire
public TypeDefinition DeclaringType
public bool IsConstructor
public bool IsDefinition
public string get_Name()
public void set_Name(string value)
public MethodAttributes get_Attributes()
public void set_Attributes(MethodAttributes value)
public MethodImplAttributes get_ImplAttributes()
public void set_ImplAttributes(MethodImplAttributes value)
public MethodSemanticsAttributes get_SemanticsAttributes()
public void set_SemanticsAttributes(MethodSemanticsAttributes value)
internal MethodDefinitionProjection get_WindowsRuntimeProjection()
internal void set_WindowsRuntimeProjection(MethodDefinitionProjection value)
internal void ReadSemantics()
public bool get_HasSecurityDeclarations()
public Collection`1<SecurityDeclaration> get_SecurityDeclarations()
public bool get_HasCustomAttributes()
public Collection`1<CustomAttribute> get_CustomAttributes()
public int get_RVA()
public bool get_HasBody()
public MethodBody get_Body()
public void set_Body(MethodBody value)
public MethodDebugInformation get_DebugInformation()
public void set_DebugInformation(MethodDebugInformation value)
public bool get_HasPInvokeInfo()
public PInvokeInfo get_PInvokeInfo()
public void set_PInvokeInfo(PInvokeInfo value)
public bool get_HasOverrides()
public Collection`1<MethodReference> get_Overrides()
public bool get_HasGenericParameters()
public Collection`1<GenericParameter> get_GenericParameters()
public bool get_HasCustomDebugInformations()
public Collection`1<CustomDebugInformation> get_CustomDebugInformations()
public bool get_IsCompilerControlled()
public void set_IsCompilerControlled(bool value)
public bool get_IsPrivate()
public void set_IsPrivate(bool value)
public bool get_IsFamilyAndAssembly()
public void set_IsFamilyAndAssembly(bool value)
public bool get_IsAssembly()
public void set_IsAssembly(bool value)
public bool get_IsFamily()
public void set_IsFamily(bool value)
public bool get_IsFamilyOrAssembly()
public void set_IsFamilyOrAssembly(bool value)
public bool get_IsPublic()
public void set_IsPublic(bool value)
public bool get_IsStatic()
public void set_IsStatic(bool value)
public bool get_IsFinal()
public void set_IsFinal(bool value)
public bool get_IsVirtual()
public void set_IsVirtual(bool value)
public bool get_IsHideBySig()
public void set_IsHideBySig(bool value)
public bool get_IsReuseSlot()
public void set_IsReuseSlot(bool value)
public bool get_IsNewSlot()
public void set_IsNewSlot(bool value)
public bool get_IsCheckAccessOnOverride()
public void set_IsCheckAccessOnOverride(bool value)
public bool get_IsAbstract()
public void set_IsAbstract(bool value)
public bool get_IsSpecialName()
public void set_IsSpecialName(bool value)
public bool get_IsPInvokeImpl()
public void set_IsPInvokeImpl(bool value)
public bool get_IsUnmanagedExport()
public void set_IsUnmanagedExport(bool value)
public bool get_IsRuntimeSpecialName()
public void set_IsRuntimeSpecialName(bool value)
public bool get_HasSecurity()
public void set_HasSecurity(bool value)
public bool get_IsIL()
public void set_IsIL(bool value)
public bool get_IsNative()
public void set_IsNative(bool value)
public bool get_IsRuntime()
public void set_IsRuntime(bool value)
public bool get_IsUnmanaged()
public void set_IsUnmanaged(bool value)
public bool get_IsManaged()
public void set_IsManaged(bool value)
public bool get_IsForwardRef()
public void set_IsForwardRef(bool value)
public bool get_IsPreserveSig()
public void set_IsPreserveSig(bool value)
public bool get_IsInternalCall()
public void set_IsInternalCall(bool value)
public bool get_IsSynchronized()
public void set_IsSynchronized(bool value)
public bool get_NoInlining()
public void set_NoInlining(bool value)
public bool get_NoOptimization()
public void set_NoOptimization(bool value)
public bool get_AggressiveInlining()
public void set_AggressiveInlining(bool value)
public bool get_AggressiveOptimization()
public void set_AggressiveOptimization(bool value)
public bool get_IsSetter()
public void set_IsSetter(bool value)
public bool get_IsGetter()
public void set_IsGetter(bool value)
public bool get_IsOther()
public void set_IsOther(bool value)
public bool get_IsAddOn()
public void set_IsAddOn(bool value)
public bool get_IsRemoveOn()
public void set_IsRemoveOn(bool value)
public bool get_IsFire()
public void set_IsFire(bool value)
public TypeDefinition get_DeclaringType()
public void set_DeclaringType(TypeDefinition value)
public bool get_IsConstructor()
public bool get_IsDefinition()
public void .ctor(string name, MethodAttributes attributes, TypeReference returnType)
public MethodDefinition Resolve()
}
internal Mono.Cecil.MethodDefinitionProjection : object {
public MethodAttributes Attributes
public MethodImplAttributes ImplAttributes
public string Name
public MethodDefinitionTreatment Treatment
public void .ctor(MethodDefinition method, MethodDefinitionTreatment treatment)
}
internal Mono.Cecil.MethodDefinitionTreatment : Enum {
public int value__
public MethodDefinitionTreatment None
public MethodDefinitionTreatment Abstract
public MethodDefinitionTreatment Private
public MethodDefinitionTreatment Public
public MethodDefinitionTreatment Runtime
public MethodDefinitionTreatment InternalCall
}
internal Mono.Cecil.MethodImplAttributes : Enum {
public ushort value__
public MethodImplAttributes CodeTypeMask
public MethodImplAttributes IL
public MethodImplAttributes Native
public MethodImplAttributes OPTIL
public MethodImplAttributes Runtime
public MethodImplAttributes ManagedMask
public MethodImplAttributes Unmanaged
public MethodImplAttributes Managed
public MethodImplAttributes ForwardRef
public MethodImplAttributes PreserveSig
public MethodImplAttributes InternalCall
public MethodImplAttributes Synchronized
public MethodImplAttributes NoOptimization
public MethodImplAttributes NoInlining
public MethodImplAttributes AggressiveInlining
public MethodImplAttributes AggressiveOptimization
}
internal Mono.Cecil.MethodImplTable : MetadataTable`1<Row`3<UInt32, UInt32, UInt32>> {
public void Write(TableHeapBuffer buffer)
}
internal Mono.Cecil.MethodReference : MemberReference {
internal ParameterDefinitionCollection parameters
private MethodReturnType return_type
private bool has_this
private bool explicit_this
private MethodCallingConvention calling_convention
internal Collection`1<GenericParameter> generic_parameters
public bool HasThis
public bool ExplicitThis
public MethodCallingConvention CallingConvention
public bool HasParameters
public Collection`1<ParameterDefinition> Parameters
private IGenericParameterProvider Mono.Cecil.IGenericContext.Type
private IGenericParameterProvider Mono.Cecil.IGenericContext.Method
private GenericParameterType Mono.Cecil.IGenericParameterProvider.GenericParameterType
public bool HasGenericParameters
public Collection`1<GenericParameter> GenericParameters
public TypeReference ReturnType
public MethodReturnType MethodReturnType
public string FullName
public bool IsGenericInstance
public bool ContainsGenericParameter
public bool get_HasThis()
public void set_HasThis(bool value)
public bool get_ExplicitThis()
public void set_ExplicitThis(bool value)
public MethodCallingConvention get_CallingConvention()
public void set_CallingConvention(MethodCallingConvention value)
public bool get_HasParameters()
public Collection`1<ParameterDefinition> get_Parameters()
private IGenericParameterProvider Mono.Cecil.IGenericContext.get_Type()
private IGenericParameterProvider Mono.Cecil.IGenericContext.get_Method()
private GenericParameterType Mono.Cecil.IGenericParameterProvider.get_GenericParameterType()
public bool get_HasGenericParameters()
public Collection`1<GenericParameter> get_GenericParameters()
public TypeReference get_ReturnType()
public void set_ReturnType(TypeReference value)
public MethodReturnType get_MethodReturnType()
public void set_MethodReturnType(MethodReturnType value)
public string get_FullName()
public bool get_IsGenericInstance()
public bool get_ContainsGenericParameter()
public void .ctor(string name, TypeReference returnType)
public void .ctor(string name, TypeReference returnType, TypeReference declaringType)
public MethodReference GetElementMethod()
protected IMemberDefinition ResolveDefinition()
public MethodDefinition Resolve()
}
internal Mono.Cecil.MethodReferenceComparer : EqualityComparer`1<MethodReference> {
private List`1<MethodReference> xComparisonStack
private List`1<MethodReference> yComparisonStack
public bool Equals(MethodReference x, MethodReference y)
public int GetHashCode(MethodReference obj)
public bool AreEqual(MethodReference x, MethodReference y)
public bool AreSignaturesEqual(MethodReference x, MethodReference y, TypeComparisonMode comparisonMode)
public int GetHashCodeFor(MethodReference obj)
}
internal Mono.Cecil.MethodReturnType : object {
internal IMethodSignature method
internal ParameterDefinition parameter
private TypeReference return_type
public IMethodSignature Method
public TypeReference ReturnType
internal ParameterDefinition Parameter
public MetadataToken MetadataToken
public ParameterAttributes Attributes
public string Name
public bool HasCustomAttributes
public Collection`1<CustomAttribute> CustomAttributes
public bool HasDefault
public bool HasConstant
public object Constant
public bool HasFieldMarshal
public bool HasMarshalInfo
public MarshalInfo MarshalInfo
public IMethodSignature get_Method()
public TypeReference get_ReturnType()
public void set_ReturnType(TypeReference value)
internal ParameterDefinition get_Parameter()
public MetadataToken get_MetadataToken()
public void set_MetadataToken(MetadataToken value)
public ParameterAttributes get_Attributes()
public void set_Attributes(ParameterAttributes value)
public string get_Name()
public void set_Name(string value)
public bool get_HasCustomAttributes()
public Collection`1<CustomAttribute> get_CustomAttributes()
public bool get_HasDefault()
public void set_HasDefault(bool value)
public bool get_HasConstant()
public void set_HasConstant(bool value)
public object get_Constant()
public void set_Constant(object value)
public bool get_HasFieldMarshal()
public void set_HasFieldMarshal(bool value)
public bool get_HasMarshalInfo()
public MarshalInfo get_MarshalInfo()
public void set_MarshalInfo(MarshalInfo value)
public void .ctor(IMethodSignature method)
}
internal Mono.Cecil.MethodSemanticsAttributes : Enum {
public ushort value__
public MethodSemanticsAttributes None
public MethodSemanticsAttributes Setter
public MethodSemanticsAttributes Getter
public MethodSemanticsAttributes Other
public MethodSemanticsAttributes AddOn
public MethodSemanticsAttributes RemoveOn
public MethodSemanticsAttributes Fire
}
internal Mono.Cecil.MethodSemanticsTable : SortedTable`1<Row`3<MethodSemanticsAttributes, UInt32, UInt32>> {
public void Write(TableHeapBuffer buffer)
public int Compare(Row`3<MethodSemanticsAttributes, UInt32, UInt32> x, Row`3<MethodSemanticsAttributes, UInt32, UInt32> y)
}
internal Mono.Cecil.MethodSpecification : MethodReference {
private MethodReference method
public MethodReference ElementMethod
public string Name
public MethodCallingConvention CallingConvention
public bool HasThis
public bool ExplicitThis
public MethodReturnType MethodReturnType
public TypeReference DeclaringType
public ModuleDefinition Module
public bool HasParameters
public Collection`1<ParameterDefinition> Parameters
public bool ContainsGenericParameter
public MethodReference get_ElementMethod()
public string get_Name()
public void set_Name(string value)
public MethodCallingConvention get_CallingConvention()
public void set_CallingConvention(MethodCallingConvention value)
public bool get_HasThis()
public void set_HasThis(bool value)
public bool get_ExplicitThis()
public void set_ExplicitThis(bool value)
public MethodReturnType get_MethodReturnType()
public void set_MethodReturnType(MethodReturnType value)
public TypeReference get_DeclaringType()
public void set_DeclaringType(TypeReference value)
public ModuleDefinition get_Module()
public bool get_HasParameters()
public Collection`1<ParameterDefinition> get_Parameters()
public bool get_ContainsGenericParameter()
internal void .ctor(MethodReference method)
public MethodReference GetElementMethod()
}
internal Mono.Cecil.MethodSpecTable : MetadataTable`1<Row`2<UInt32, UInt32>> {
public void Write(TableHeapBuffer buffer)
}
internal Mono.Cecil.MethodTable : MetadataTable`1<Row`6<UInt32, MethodImplAttributes, MethodAttributes, UInt32, UInt32, UInt32>> {
public void Write(TableHeapBuffer buffer)
}
internal Mono.Cecil.Mixin : object {
public Version ZeroVersion
public int NotResolvedMarker
public int NoDataMarker
internal object NoValue
internal object NotResolved
public string mscorlib
public string system_runtime
public string system_private_corelib
public string netstandard
public int TableCount
public int CodedIndexCount
public bool IsNullOrEmpty(T[] self)
public bool IsNullOrEmpty(Collection`1<T> self)
public T[] Resize(T[] self, int length)
public T[] Add(T[] self, T item)
public Version CheckVersion(Version version)
public bool TryGetUniqueDocument(MethodDebugInformation info, Document& document)
public void ResolveConstant(IConstantProvider self, Object& constant, ModuleDefinition module)
public bool GetHasCustomAttributes(ICustomAttributeProvider self, ModuleDefinition module)
public Collection`1<CustomAttribute> GetCustomAttributes(ICustomAttributeProvider self, Collection`1& variable, ModuleDefinition module)
public bool ContainsGenericParameter(IGenericInstance self)
public void GenericInstanceFullName(IGenericInstance self, StringBuilder builder)
public bool GetHasGenericParameters(IGenericParameterProvider self, ModuleDefinition module)
public Collection`1<GenericParameter> GetGenericParameters(IGenericParameterProvider self, Collection`1& collection, ModuleDefinition module)
public bool GetHasMarshalInfo(IMarshalInfoProvider self, ModuleDefinition module)
public MarshalInfo GetMarshalInfo(IMarshalInfoProvider self, MarshalInfo& variable, ModuleDefinition module)
public bool GetAttributes(UInt32 self, UInt32 attributes)
public UInt32 SetAttributes(UInt32 self, UInt32 attributes, bool value)
public bool GetMaskedAttributes(UInt32 self, UInt32 mask, UInt32 attributes)
public UInt32 SetMaskedAttributes(UInt32 self, UInt32 mask, UInt32 attributes, bool value)
public bool GetAttributes(ushort self, ushort attributes)
public ushort SetAttributes(ushort self, ushort attributes, bool value)
public bool GetMaskedAttributes(ushort self, ushort mask, UInt32 attributes)
public ushort SetMaskedAttributes(ushort self, ushort mask, UInt32 attributes, bool value)
public bool HasImplicitThis(IMethodSignature self)
public void MethodSignatureFullName(IMethodSignature self, StringBuilder builder)
public void CheckModule(ModuleDefinition module)
public bool TryGetAssemblyNameReference(ModuleDefinition module, AssemblyNameReference name_reference, AssemblyNameReference& assembly_reference)
private bool Equals(Byte[] a, Byte[] b)
private bool Equals(T a, T b)
private bool Equals(AssemblyNameReference a, AssemblyNameReference b)
public ParameterDefinition GetParameter(MethodBody self, int index)
public VariableDefinition GetVariable(MethodBody self, int index)
public bool GetSemantics(MethodDefinition self, MethodSemanticsAttributes semantics)
public void SetSemantics(MethodDefinition self, MethodSemanticsAttributes semantics, bool value)
public bool IsVarArg(IMethodSignature self)
public int GetSentinelPosition(IMethodSignature self)
public void CheckName(object name)
public void CheckName(string name)
public void CheckFileName(string fileName)
public void CheckFullName(string fullName)
public void CheckStream(object stream)
public void CheckWriteSeek(Stream stream)
public void CheckReadSeek(Stream stream)
public void CheckType(object type)
public void CheckType(object type, Argument argument)
public void CheckField(object field)
public void CheckMethod(object method)
public void CheckParameters(object parameters)
public UInt32 GetTimestamp()
public bool HasImage(ModuleDefinition self)
public string GetFileName(Stream self)
public TargetRuntime ParseRuntime(string self)
public string RuntimeVersionString(TargetRuntime runtime)
public bool IsWindowsMetadata(ModuleDefinition module)
public Byte[] ReadAll(Stream self)
public void Read(object o)
public bool GetHasSecurityDeclarations(ISecurityDeclarationProvider self, ModuleDefinition module)
public Collection`1<SecurityDeclaration> GetSecurityDeclarations(ISecurityDeclarationProvider self, Collection`1& variable, ModuleDefinition module)
public TypeReference GetEnumUnderlyingType(TypeDefinition self)
public TypeDefinition GetNestedType(TypeDefinition self, string fullname)
public bool IsPrimitive(ElementType self)
public string TypeFullName(TypeReference self)
public bool IsTypeOf(TypeReference self, string namespace, string name)
public bool IsTypeSpecification(TypeReference type)
public TypeDefinition CheckedResolve(TypeReference self)
public bool TryGetCoreLibraryReference(ModuleDefinition module, AssemblyNameReference& reference)
public bool IsCoreLibrary(ModuleDefinition module)
public void KnownValueType(TypeReference type)
private bool IsCoreLibrary(AssemblyNameReference reference)
public ImageDebugHeaderEntry GetCodeViewEntry(ImageDebugHeader header)
public ImageDebugHeaderEntry GetDeterministicEntry(ImageDebugHeader header)
public ImageDebugHeader AddDeterministicEntry(ImageDebugHeader header)
public ImageDebugHeaderEntry GetEmbeddedPortablePdbEntry(ImageDebugHeader header)
public ImageDebugHeaderEntry GetPdbChecksumEntry(ImageDebugHeader header)
private ImageDebugHeaderEntry GetEntry(ImageDebugHeader header, ImageDebugType type)
public string GetPdbFileName(string assemblyFileName)
public string GetMdbFileName(string assemblyFileName)
public bool IsPortablePdb(string fileName)
public bool IsPortablePdb(Stream stream)
public UInt32 ReadCompressedUInt32(Byte[] data, Int32& position)
public MetadataToken GetMetadataToken(CodedIndex self, UInt32 data)
public UInt32 CompressMetadataToken(CodedIndex self, MetadataToken token)
public int GetSize(CodedIndex self, Func`2<Table, int> counter)
public RSA CreateRSA(WriterParameters writer_parameters)
private bool TryGetKeyContainer(ISerializable key_pair, Byte[]& key, String& key_container)
}
internal Mono.Cecil.ModuleAttributes : Enum {
public int value__
public ModuleAttributes ILOnly
public ModuleAttributes Required32Bit
public ModuleAttributes ILLibrary
public ModuleAttributes StrongNameSigned
public ModuleAttributes Preferred32Bit
}
internal Mono.Cecil.ModuleCharacteristics : Enum {
public int value__
public ModuleCharacteristics HighEntropyVA
public ModuleCharacteristics DynamicBase
public ModuleCharacteristics NoSEH
public ModuleCharacteristics NXCompat
public ModuleCharacteristics AppContainer
public ModuleCharacteristics TerminalServerAware
}
internal Mono.Cecil.ModuleDefinition : ModuleReference {
internal Image Image
internal MetadataSystem MetadataSystem
internal ReadingMode ReadingMode
internal ISymbolReaderProvider SymbolReaderProvider
internal ISymbolReader symbol_reader
internal Disposable`1<IAssemblyResolver> assembly_resolver
internal IMetadataResolver metadata_resolver
internal TypeSystem type_system
internal MetadataReader reader
private string file_name
internal string runtime_version
internal ModuleKind kind
private WindowsRuntimeProjections projections
private MetadataKind metadata_kind
private TargetRuntime runtime
private TargetArchitecture architecture
private ModuleAttributes attributes
private ModuleCharacteristics characteristics
private Guid mvid
internal ushort linker_version
internal ushort subsystem_major
internal ushort subsystem_minor
internal UInt32 timestamp
internal AssemblyDefinition assembly
private MethodDefinition entry_point
private bool entry_point_set
internal IReflectionImporter reflection_importer
internal IMetadataImporter metadata_importer
private Collection`1<CustomAttribute> custom_attributes
private Collection`1<AssemblyNameReference> references
private Collection`1<ModuleReference> modules
private Collection`1<Resource> resources
private Collection`1<ExportedType> exported_types
private TypeDefinitionCollection types
internal Collection`1<CustomDebugInformation> custom_infos
internal MetadataBuilder metadata_builder
private object module_lock
public bool IsMain
public ModuleKind Kind
public MetadataKind MetadataKind
internal WindowsRuntimeProjections Projections
public TargetRuntime Runtime
public string RuntimeVersion
public TargetArchitecture Architecture
public ModuleAttributes Attributes
public ModuleCharacteristics Characteristics
public string FullyQualifiedName
public string FileName
public Guid Mvid
internal bool HasImage
public bool HasSymbols
public ISymbolReader SymbolReader
public MetadataScopeType MetadataScopeType
public AssemblyDefinition Assembly
internal IReflectionImporter ReflectionImporter
internal IMetadataImporter MetadataImporter
public IAssemblyResolver AssemblyResolver
public IMetadataResolver MetadataResolver
public TypeSystem TypeSystem
public bool HasAssemblyReferences
public Collection`1<AssemblyNameReference> AssemblyReferences
public bool HasModuleReferences
public Collection`1<ModuleReference> ModuleReferences
public bool HasResources
public Collection`1<Resource> Resources
public bool HasCustomAttributes
public Collection`1<CustomAttribute> CustomAttributes
public bool HasTypes
public Collection`1<TypeDefinition> Types
public bool HasExportedTypes
public Collection`1<ExportedType> ExportedTypes
public MethodDefinition EntryPoint
public bool HasCustomDebugInformations
public Collection`1<CustomDebugInformation> CustomDebugInformations
internal object SyncRoot
public bool HasDebugHeader
public bool get_IsMain()
public ModuleKind get_Kind()
public void set_Kind(ModuleKind value)
public MetadataKind get_MetadataKind()
public void set_MetadataKind(MetadataKind value)
internal WindowsRuntimeProjections get_Projections()
public TargetRuntime get_Runtime()
public void set_Runtime(TargetRuntime value)
public string get_RuntimeVersion()
public void set_RuntimeVersion(string value)
public TargetArchitecture get_Architecture()
public void set_Architecture(TargetArchitecture value)
public ModuleAttributes get_Attributes()
public void set_Attributes(ModuleAttributes value)
public ModuleCharacteristics get_Characteristics()
public void set_Characteristics(ModuleCharacteristics value)
public string get_FullyQualifiedName()
public string get_FileName()
public Guid get_Mvid()
public void set_Mvid(Guid value)
internal bool get_HasImage()
public bool get_HasSymbols()
public ISymbolReader get_SymbolReader()
public MetadataScopeType get_MetadataScopeType()
public AssemblyDefinition get_Assembly()
internal IReflectionImporter get_ReflectionImporter()
internal IMetadataImporter get_MetadataImporter()
public IAssemblyResolver get_AssemblyResolver()
public IMetadataResolver get_MetadataResolver()
public TypeSystem get_TypeSystem()
public bool get_HasAssemblyReferences()
public Collection`1<AssemblyNameReference> get_AssemblyReferences()
public bool get_HasModuleReferences()
public Collection`1<ModuleReference> get_ModuleReferences()
public bool get_HasResources()
public Collection`1<Resource> get_Resources()
public bool get_HasCustomAttributes()
public Collection`1<CustomAttribute> get_CustomAttributes()
public bool get_HasTypes()
public Collection`1<TypeDefinition> get_Types()
public bool get_HasExportedTypes()
public Collection`1<ExportedType> get_ExportedTypes()
public MethodDefinition get_EntryPoint()
public void set_EntryPoint(MethodDefinition value)
public bool get_HasCustomDebugInformations()
public Collection`1<CustomDebugInformation> get_CustomDebugInformations()
internal void .ctor(Image image)
public void Dispose()
public bool HasTypeReference(string fullName)
public bool HasTypeReference(string scope, string fullName)
public bool TryGetTypeReference(string fullName, TypeReference& type)
public bool TryGetTypeReference(string scope, string fullName, TypeReference& type)
private TypeReference GetTypeReference(string scope, string fullname)
public IEnumerable`1<TypeReference> GetTypeReferences()
public IEnumerable`1<MemberReference> GetMemberReferences()
public IEnumerable`1<CustomAttribute> GetCustomAttributes()
public TypeReference GetType(string fullName, bool runtimeName)
public TypeDefinition GetType(string fullName)
public TypeDefinition GetType(string namespace, string name)
public IEnumerable`1<TypeDefinition> GetTypes()
private IEnumerable`1<TypeDefinition> GetTypes(Collection`1<TypeDefinition> types)
private TypeDefinition GetNestedType(string fullname)
internal FieldDefinition Resolve(FieldReference field)
internal MethodDefinition Resolve(MethodReference method)
internal TypeDefinition Resolve(TypeReference type)
private void CheckContext(IGenericParameterProvider context, ModuleDefinition module)
public TypeReference Import(Type type)
public TypeReference ImportReference(Type type)
public TypeReference Import(Type type, IGenericParameterProvider context)
public TypeReference ImportReference(Type type, IGenericParameterProvider context)
public FieldReference Import(FieldInfo field)
public FieldReference Import(FieldInfo field, IGenericParameterProvider context)
public FieldReference ImportReference(FieldInfo field)
public FieldReference ImportReference(FieldInfo field, IGenericParameterProvider context)
public MethodReference Import(MethodBase method)
public MethodReference Import(MethodBase method, IGenericParameterProvider context)
public MethodReference ImportReference(MethodBase method)
public MethodReference ImportReference(MethodBase method, IGenericParameterProvider context)
public TypeReference Import(TypeReference type)
public TypeReference Import(TypeReference type, IGenericParameterProvider context)
public TypeReference ImportReference(TypeReference type)
public TypeReference ImportReference(TypeReference type, IGenericParameterProvider context)
public FieldReference Import(FieldReference field)
public FieldReference Import(FieldReference field, IGenericParameterProvider context)
public FieldReference ImportReference(FieldReference field)
public FieldReference ImportReference(FieldReference field, IGenericParameterProvider context)
public MethodReference Import(MethodReference method)
public MethodReference Import(MethodReference method, IGenericParameterProvider context)
public MethodReference ImportReference(MethodReference method)
public MethodReference ImportReference(MethodReference method, IGenericParameterProvider context)
public IMetadataTokenProvider LookupToken(int token)
public IMetadataTokenProvider LookupToken(MetadataToken token)
public void ImmediateRead()
internal object get_SyncRoot()
internal void Read(TItem item, Action`2<TItem, MetadataReader> read)
internal TRet Read(TItem item, Func`3<TItem, MetadataReader, TRet> read)
internal TRet Read(TRet& variable, TItem item, Func`3<TItem, MetadataReader, TRet> read)
public bool get_HasDebugHeader()
public ImageDebugHeader GetDebugHeader()
public ModuleDefinition CreateModule(string name, ModuleKind kind)
public ModuleDefinition CreateModule(string name, ModuleParameters parameters)
private AssemblyNameDefinition CreateAssemblyName(string name)
public void ReadSymbols()
public void ReadSymbols(ISymbolReader reader)
public void ReadSymbols(ISymbolReader reader, bool throwIfSymbolsAreNotMaching)
public ModuleDefinition ReadModule(string fileName)
public ModuleDefinition ReadModule(string fileName, ReaderParameters parameters)
private Stream GetFileStream(string fileName, FileMode mode, FileAccess access, FileShare share)
public ModuleDefinition ReadModule(Stream stream)
public ModuleDefinition ReadModule(Stream stream, ReaderParameters parameters)
private ModuleDefinition ReadModule(Disposable`1<Stream> stream, string fileName, ReaderParameters parameters)
public void Write(string fileName)
public void Write(string fileName, WriterParameters parameters)
public void Write()
public void Write(WriterParameters parameters)
public void Write(Stream stream)
public void Write(Stream stream, WriterParameters parameters)
}
internal Mono.Cecil.ModuleKind : Enum {
public int value__
public ModuleKind Dll
public ModuleKind Console
public ModuleKind Windows
public ModuleKind NetModule
}
internal Mono.Cecil.ModuleParameters : object {
private ModuleKind kind
private TargetRuntime runtime
private Nullable`1<UInt32> timestamp
private TargetArchitecture architecture
private IAssemblyResolver assembly_resolver
private IMetadataResolver metadata_resolver
private IMetadataImporterProvider metadata_importer_provider
private IReflectionImporterProvider reflection_importer_provider
public ModuleKind Kind
public TargetRuntime Runtime
public Nullable`1<UInt32> Timestamp
public TargetArchitecture Architecture
public IAssemblyResolver AssemblyResolver
public IMetadataResolver MetadataResolver
public IMetadataImporterProvider MetadataImporterProvider
public IReflectionImporterProvider ReflectionImporterProvider
public ModuleKind get_Kind()
public void set_Kind(ModuleKind value)
public TargetRuntime get_Runtime()
public void set_Runtime(TargetRuntime value)
public Nullable`1<UInt32> get_Timestamp()
public void set_Timestamp(Nullable`1<UInt32> value)
public TargetArchitecture get_Architecture()
public void set_Architecture(TargetArchitecture value)
public IAssemblyResolver get_AssemblyResolver()
public void set_AssemblyResolver(IAssemblyResolver value)
public IMetadataResolver get_MetadataResolver()
public void set_MetadataResolver(IMetadataResolver value)
public IMetadataImporterProvider get_MetadataImporterProvider()
public void set_MetadataImporterProvider(IMetadataImporterProvider value)
public IReflectionImporterProvider get_ReflectionImporterProvider()
public void set_ReflectionImporterProvider(IReflectionImporterProvider value)
private TargetRuntime GetCurrentRuntime()
}
internal Mono.Cecil.ModuleReader : object {
protected ModuleDefinition module
protected void .ctor(Image image, ReadingMode mode)
protected void ReadModule()
public void ReadSymbols(ModuleDefinition module)
protected void ReadModuleManifest(MetadataReader reader)
private void ReadAssembly(MetadataReader reader)
public ModuleDefinition CreateModule(Image image, ReaderParameters parameters)
private void ReadSymbols(ModuleDefinition module, ReaderParameters parameters)
private void GetMetadataKind(ModuleDefinition module, ReaderParameters parameters)
private ModuleReader CreateModuleReader(Image image, ReadingMode mode)
}
internal Mono.Cecil.ModuleReference : object {
private string name
internal MetadataToken token
public string Name
public MetadataScopeType MetadataScopeType
public MetadataToken MetadataToken
public string get_Name()
public void set_Name(string value)
public MetadataScopeType get_MetadataScopeType()
public MetadataToken get_MetadataToken()
public void set_MetadataToken(MetadataToken value)
public void .ctor(string name)
public string ToString()
}
internal Mono.Cecil.ModuleRefTable : MetadataTable`1<UInt32> {
public void Write(TableHeapBuffer buffer)
}
internal Mono.Cecil.ModuleTable : OneRowTable`1<Row`2<UInt32, UInt32>> {
public void Write(TableHeapBuffer buffer)
}
internal Mono.Cecil.ModuleWriter : object {
public void WriteModule(ModuleDefinition module, Disposable`1<Stream> stream, WriterParameters parameters)
private void Write(ModuleDefinition module, Disposable`1<Stream> stream, WriterParameters parameters)
private void BuildMetadata(ModuleDefinition module, MetadataBuilder metadata)
private ISymbolWriter GetSymbolWriter(ModuleDefinition module, string fq_name, ISymbolWriterProvider symbol_writer_provider, WriterParameters parameters)
private void ComputeDeterministicMvid(ImageWriter writer, ModuleDefinition module)
}
internal Mono.Cecil.NativeType : Enum {
public int value__
public NativeType None
public NativeType Boolean
public NativeType I1
public NativeType U1
public NativeType I2
public NativeType U2
public NativeType I4
public NativeType U4
public NativeType I8
public NativeType U8
public NativeType R4
public NativeType R8
public NativeType LPStr
public NativeType Int
public NativeType UInt
public NativeType Func
public NativeType Array
public NativeType Currency
public NativeType BStr
public NativeType LPWStr
public NativeType LPTStr
public NativeType FixedSysString
public NativeType IUnknown
public NativeType IDispatch
public NativeType Struct
public NativeType IntF
public NativeType SafeArray
public NativeType FixedArray
public NativeType ByValStr
public NativeType ANSIBStr
public NativeType TBStr
public NativeType VariantBool
public NativeType ASAny
public NativeType LPStruct
public NativeType CustomMarshaler
public NativeType Error
public NativeType Max
}
internal Mono.Cecil.NestedClassTable : SortedTable`1<Row`2<UInt32, UInt32>> {
public void Write(TableHeapBuffer buffer)
public int Compare(Row`2<UInt32, UInt32> x, Row`2<UInt32, UInt32> y)
}
internal Mono.Cecil.OneRowTable`1 : MetadataTable {
internal TRow row
public int Length
public int get_Length()
public void Sort()
}
internal Mono.Cecil.OptionalModifierType : TypeSpecification {
private TypeReference modifier_type
public TypeReference ModifierType
public string Name
public string FullName
private string Suffix
public bool IsValueType
public bool IsOptionalModifier
public bool ContainsGenericParameter
public TypeReference get_ModifierType()
public void set_ModifierType(TypeReference value)
public string get_Name()
public string get_FullName()
private string get_Suffix()
public bool get_IsValueType()
public void set_IsValueType(bool value)
public bool get_IsOptionalModifier()
public bool get_ContainsGenericParameter()
public void .ctor(TypeReference modifierType, TypeReference type)
}
internal Mono.Cecil.ParameterAttributes : Enum {
public ushort value__
public ParameterAttributes None
public ParameterAttributes In
public ParameterAttributes Out
public ParameterAttributes Lcid
public ParameterAttributes Retval
public ParameterAttributes Optional
public ParameterAttributes HasDefault
public ParameterAttributes HasFieldMarshal
public ParameterAttributes Unused
}
internal Mono.Cecil.ParameterDefinition : ParameterReference {
private ushort attributes
internal IMethodSignature method
private object constant
private Collection`1<CustomAttribute> custom_attributes
private MarshalInfo marshal_info
public ParameterAttributes Attributes
public IMethodSignature Method
public int Sequence
public bool HasConstant
public object Constant
public bool HasCustomAttributes
public Collection`1<CustomAttribute> CustomAttributes
public bool HasMarshalInfo
public MarshalInfo MarshalInfo
public bool IsIn
public bool IsOut
public bool IsLcid
public bool IsReturnValue
public bool IsOptional
public bool HasDefault
public bool HasFieldMarshal
public ParameterAttributes get_Attributes()
public void set_Attributes(ParameterAttributes value)
public IMethodSignature get_Method()
public int get_Sequence()
public bool get_HasConstant()
public void set_HasConstant(bool value)
public object get_Constant()
public void set_Constant(object value)
public bool get_HasCustomAttributes()
public Collection`1<CustomAttribute> get_CustomAttributes()
public bool get_HasMarshalInfo()
public MarshalInfo get_MarshalInfo()
public void set_MarshalInfo(MarshalInfo value)
public bool get_IsIn()
public void set_IsIn(bool value)
public bool get_IsOut()
public void set_IsOut(bool value)
public bool get_IsLcid()
public void set_IsLcid(bool value)
public bool get_IsReturnValue()
public void set_IsReturnValue(bool value)
public bool get_IsOptional()
public void set_IsOptional(bool value)
public bool get_HasDefault()
public void set_HasDefault(bool value)
public bool get_HasFieldMarshal()
public void set_HasFieldMarshal(bool value)
internal void .ctor(TypeReference parameterType, IMethodSignature method)
public void .ctor(TypeReference parameterType)
public void .ctor(string name, ParameterAttributes attributes, TypeReference parameterType)
public ParameterDefinition Resolve()
}
internal Mono.Cecil.ParameterDefinitionCollection : Collection`1<ParameterDefinition> {
private IMethodSignature method
internal void .ctor(IMethodSignature method)
internal void .ctor(IMethodSignature method, int capacity)
protected void OnAdd(ParameterDefinition item, int index)
protected void OnInsert(ParameterDefinition item, int index)
protected void OnSet(ParameterDefinition item, int index)
protected void OnRemove(ParameterDefinition item, int index)
}
internal Mono.Cecil.ParameterReference : object {
private string name
internal int index
protected TypeReference parameter_type
internal MetadataToken token
public string Name
public int Index
public TypeReference ParameterType
public MetadataToken MetadataToken
public string get_Name()
public void set_Name(string value)
public int get_Index()
public TypeReference get_ParameterType()
public void set_ParameterType(TypeReference value)
public MetadataToken get_MetadataToken()
public void set_MetadataToken(MetadataToken value)
internal void .ctor(string name, TypeReference parameterType)
public string ToString()
public ParameterDefinition Resolve()
}
internal Mono.Cecil.ParamTable : MetadataTable`1<Row`3<ParameterAttributes, ushort, UInt32>> {
public void Write(TableHeapBuffer buffer)
}
internal Mono.Cecil.Pdb.CustomMetadataType : Enum {
public byte value__
public CustomMetadataType UsingInfo
public CustomMetadataType ForwardInfo
public CustomMetadataType IteratorScopes
public CustomMetadataType ForwardIterator
}
internal Mono.Cecil.Pdb.CustomMetadataWriter : object {
private SymWriter sym_writer
private MemoryStream stream
private BinaryStreamWriter writer
private int count
private byte version
public void .ctor(SymWriter sym_writer)
public void WriteUsingInfo(ImportDebugInformation import_info)
public void WriteForwardInfo(MetadataToken import_parent)
public void WriteIteratorScopes(StateMachineScopeDebugInformation state_machine, MethodDebugInformation debug_info)
public void WriteForwardIterator(TypeReference type)
private void Write(CustomMetadataType type, Action write)
public void WriteCustomMetadata()
public void Dispose()
}
internal Mono.Cecil.Pdb.IMetaDataEmit {
public void SetModuleProps(string szName)
public void Save(string szFile, UInt32 dwSaveFlags)
public void SaveToStream(IntPtr pIStream, UInt32 dwSaveFlags)
public UInt32 GetSaveSize(UInt32 fSave)
public UInt32 DefineTypeDef(IntPtr szTypeDef, UInt32 dwTypeDefFlags, UInt32 tkExtends, IntPtr rtkImplements)
public UInt32 DefineNestedType(IntPtr szTypeDef, UInt32 dwTypeDefFlags, UInt32 tkExtends, IntPtr rtkImplements, UInt32 tdEncloser)
public void SetHandler(object pUnk)
public UInt32 DefineMethod(UInt32 td, IntPtr zName, UInt32 dwMethodFlags, IntPtr pvSigBlob, UInt32 cbSigBlob, UInt32 ulCodeRVA, UInt32 dwImplFlags)
public void DefineMethodImpl(UInt32 td, UInt32 tkBody, UInt32 tkDecl)
public UInt32 DefineTypeRefByName(UInt32 tkResolutionScope, IntPtr szName)
public UInt32 DefineImportType(IntPtr pAssemImport, IntPtr pbHashValue, UInt32 cbHashValue, IMetaDataImport pImport, UInt32 tdImport, IntPtr pAssemEmit)
public UInt32 DefineMemberRef(UInt32 tkImport, string szName, IntPtr pvSigBlob, UInt32 cbSigBlob)
public UInt32 DefineImportMember(IntPtr pAssemImport, IntPtr pbHashValue, UInt32 cbHashValue, IMetaDataImport pImport, UInt32 mbMember, IntPtr pAssemEmit, UInt32 tkParent)
public UInt32 DefineEvent(UInt32 td, string szEvent, UInt32 dwEventFlags, UInt32 tkEventType, UInt32 mdAddOn, UInt32 mdRemoveOn, UInt32 mdFire, IntPtr rmdOtherMethods)
public void SetClassLayout(UInt32 td, UInt32 dwPackSize, IntPtr rFieldOffsets, UInt32 ulClassSize)
public void DeleteClassLayout(UInt32 td)
public void SetFieldMarshal(UInt32 tk, IntPtr pvNativeType, UInt32 cbNativeType)
public void DeleteFieldMarshal(UInt32 tk)
public UInt32 DefinePermissionSet(UInt32 tk, UInt32 dwAction, IntPtr pvPermission, UInt32 cbPermission)
public void SetRVA(UInt32 md, UInt32 ulRVA)
public UInt32 GetTokenFromSig(IntPtr pvSig, UInt32 cbSig)
public UInt32 DefineModuleRef(string szName)
public void SetParent(UInt32 mr, UInt32 tk)
public UInt32 GetTokenFromTypeSpec(IntPtr pvSig, UInt32 cbSig)
public void SaveToMemory(IntPtr pbData, UInt32 cbData)
public UInt32 DefineUserString(string szString, UInt32 cchString)
public void DeleteToken(UInt32 tkObj)
public void SetMethodProps(UInt32 md, UInt32 dwMethodFlags, UInt32 ulCodeRVA, UInt32 dwImplFlags)
public void SetTypeDefProps(UInt32 td, UInt32 dwTypeDefFlags, UInt32 tkExtends, IntPtr rtkImplements)
public void SetEventProps(UInt32 ev, UInt32 dwEventFlags, UInt32 tkEventType, UInt32 mdAddOn, UInt32 mdRemoveOn, UInt32 mdFire, IntPtr rmdOtherMethods)
public UInt32 SetPermissionSetProps(UInt32 tk, UInt32 dwAction, IntPtr pvPermission, UInt32 cbPermission)
public void DefinePinvokeMap(UInt32 tk, UInt32 dwMappingFlags, string szImportName, UInt32 mrImportDLL)
public void SetPinvokeMap(UInt32 tk, UInt32 dwMappingFlags, string szImportName, UInt32 mrImportDLL)
public void DeletePinvokeMap(UInt32 tk)
public UInt32 DefineCustomAttribute(UInt32 tkObj, UInt32 tkType, IntPtr pCustomAttribute, UInt32 cbCustomAttribute)
public void SetCustomAttributeValue(UInt32 pcv, IntPtr pCustomAttribute, UInt32 cbCustomAttribute)
public UInt32 DefineField(UInt32 td, string szName, UInt32 dwFieldFlags, IntPtr pvSigBlob, UInt32 cbSigBlob, UInt32 dwCPlusTypeFlag, IntPtr pValue, UInt32 cchValue)
public UInt32 DefineProperty(UInt32 td, string szProperty, UInt32 dwPropFlags, IntPtr pvSig, UInt32 cbSig, UInt32 dwCPlusTypeFlag, IntPtr pValue, UInt32 cchValue, UInt32 mdSetter, UInt32 mdGetter, IntPtr rmdOtherMethods)
public UInt32 DefineParam(UInt32 md, UInt32 ulParamSeq, string szName, UInt32 dwParamFlags, UInt32 dwCPlusTypeFlag, IntPtr pValue, UInt32 cchValue)
public void SetFieldProps(UInt32 fd, UInt32 dwFieldFlags, UInt32 dwCPlusTypeFlag, IntPtr pValue, UInt32 cchValue)
public void SetPropertyProps(UInt32 pr, UInt32 dwPropFlags, UInt32 dwCPlusTypeFlag, IntPtr pValue, UInt32 cchValue, UInt32 mdSetter, UInt32 mdGetter, IntPtr rmdOtherMethods)
public void SetParamProps(UInt32 pd, string szName, UInt32 dwParamFlags, UInt32 dwCPlusTypeFlag, IntPtr pValue, UInt32 cchValue)
public UInt32 DefineSecurityAttributeSet(UInt32 tkObj, IntPtr rSecAttrs, UInt32 cSecAttrs)
public void ApplyEditAndContinue(object pImport)
public UInt32 TranslateSigWithScope(IntPtr pAssemImport, IntPtr pbHashValue, UInt32 cbHashValue, IMetaDataImport import, IntPtr pbSigBlob, UInt32 cbSigBlob, IntPtr pAssemEmit, IMetaDataEmit emit, IntPtr pvTranslatedSig, UInt32 cbTranslatedSigMax)
public void SetMethodImplFlags(UInt32 md, UInt32 dwImplFlags)
public void SetFieldRVA(UInt32 fd, UInt32 ulRVA)
public void Merge(IMetaDataImport pImport, IntPtr pHostMapToken, object pHandler)
public void MergeEnd()
}
internal Mono.Cecil.Pdb.IMetaDataImport {
public void CloseEnum(UInt32 hEnum)
public UInt32 CountEnum(UInt32 hEnum)
public void ResetEnum(UInt32 hEnum, UInt32 ulPos)
public UInt32 EnumTypeDefs(UInt32& phEnum, UInt32[] rTypeDefs, UInt32 cMax)
public UInt32 EnumInterfaceImpls(UInt32& phEnum, UInt32 td, UInt32[] rImpls, UInt32 cMax)
public UInt32 EnumTypeRefs(UInt32& phEnum, UInt32[] rTypeRefs, UInt32 cMax)
public UInt32 FindTypeDefByName(string szTypeDef, UInt32 tkEnclosingClass)
public Guid GetScopeProps(StringBuilder szName, UInt32 cchName, UInt32& pchName)
public UInt32 GetModuleFromScope()
public UInt32 GetTypeDefProps(UInt32 td, Char* szTypeDef, UInt32 cchTypeDef, UInt32* pchTypeDef, UInt32* pdwTypeDefFlags, UInt32* ptkExtends)
public UInt32 GetInterfaceImplProps(UInt32 iiImpl, UInt32& pClass)
public UInt32 GetTypeRefProps(UInt32 tr, UInt32& ptkResolutionScope, StringBuilder szName, UInt32 cchName)
public UInt32 ResolveTypeRef(UInt32 tr, Guid& riid, Object& ppIScope)
public UInt32 EnumMembers(UInt32& phEnum, UInt32 cl, UInt32[] rMembers, UInt32 cMax)
public UInt32 EnumMembersWithName(UInt32& phEnum, UInt32 cl, string szName, UInt32[] rMembers, UInt32 cMax)
public UInt32 EnumMethods(UInt32& phEnum, UInt32 cl, IntPtr rMethods, UInt32 cMax)
public UInt32 EnumMethodsWithName(UInt32& phEnum, UInt32 cl, string szName, UInt32[] rMethods, UInt32 cMax)
public UInt32 EnumFields(UInt32& phEnum, UInt32 cl, IntPtr rFields, UInt32 cMax)
public UInt32 EnumFieldsWithName(UInt32& phEnum, UInt32 cl, string szName, UInt32[] rFields, UInt32 cMax)
public UInt32 EnumParams(UInt32& phEnum, UInt32 mb, UInt32[] rParams, UInt32 cMax)
public UInt32 EnumMemberRefs(UInt32& phEnum, UInt32 tkParent, UInt32[] rMemberRefs, UInt32 cMax)
public UInt32 EnumMethodImpls(UInt32& phEnum, UInt32 td, UInt32[] rMethodBody, UInt32[] rMethodDecl, UInt32 cMax)
public UInt32 EnumPermissionSets(UInt32& phEnum, UInt32 tk, UInt32 dwActions, UInt32[] rPermission, UInt32 cMax)
public UInt32 FindMember(UInt32 td, string szName, Byte[] pvSigBlob, UInt32 cbSigBlob)
public UInt32 FindMethod(UInt32 td, string szName, Byte[] pvSigBlob, UInt32 cbSigBlob)
public UInt32 FindField(UInt32 td, string szName, Byte[] pvSigBlob, UInt32 cbSigBlob)
public UInt32 FindMemberRef(UInt32 td, string szName, Byte[] pvSigBlob, UInt32 cbSigBlob)
public UInt32 GetMethodProps(UInt32 mb, UInt32* pClass, Char* szMethod, UInt32 cchMethod, UInt32* pchMethod, UInt32* pdwAttr, IntPtr ppvSigBlob, IntPtr pcbSigBlob, UInt32* pulCodeRVA, UInt32* pdwImplFlags)
public UInt32 GetMemberRefProps(UInt32 mr, UInt32& ptk, StringBuilder szMember, UInt32 cchMember, UInt32& pchMember, IntPtr& ppvSigBlob)
public UInt32 EnumProperties(UInt32& phEnum, UInt32 td, IntPtr rProperties, UInt32 cMax)
public UInt32 EnumEvents(UInt32& phEnum, UInt32 td, IntPtr rEvents, UInt32 cMax)
public UInt32 GetEventProps(UInt32 ev, UInt32& pClass, StringBuilder szEvent, UInt32 cchEvent, UInt32& pchEvent, UInt32& pdwEventFlags, UInt32& ptkEventType, UInt32& pmdAddOn, UInt32& pmdRemoveOn, UInt32& pmdFire, UInt32[] rmdOtherMethod, UInt32 cMax)
public UInt32 EnumMethodSemantics(UInt32& phEnum, UInt32 mb, UInt32[] rEventProp, UInt32 cMax)
public UInt32 GetMethodSemantics(UInt32 mb, UInt32 tkEventProp)
public UInt32 GetClassLayout(UInt32 td, UInt32& pdwPackSize, IntPtr rFieldOffset, UInt32 cMax, UInt32& pcFieldOffset)
public UInt32 GetFieldMarshal(UInt32 tk, IntPtr& ppvNativeType)
public UInt32 GetRVA(UInt32 tk, UInt32& pulCodeRVA)
public UInt32 GetPermissionSetProps(UInt32 pm, UInt32& pdwAction, IntPtr& ppvPermission)
public UInt32 GetSigFromToken(UInt32 mdSig, IntPtr& ppvSig)
public UInt32 GetModuleRefProps(UInt32 mur, StringBuilder szName, UInt32 cchName)
public UInt32 EnumModuleRefs(UInt32& phEnum, UInt32[] rModuleRefs, UInt32 cmax)
public UInt32 GetTypeSpecFromToken(UInt32 typespec, IntPtr& ppvSig)
public UInt32 GetNameFromToken(UInt32 tk)
public UInt32 EnumUnresolvedMethods(UInt32& phEnum, UInt32[] rMethods, UInt32 cMax)
public UInt32 GetUserString(UInt32 stk, StringBuilder szString, UInt32 cchString)
public UInt32 GetPinvokeMap(UInt32 tk, UInt32& pdwMappingFlags, StringBuilder szImportName, UInt32 cchImportName, UInt32& pchImportName)
public UInt32 EnumSignatures(UInt32& phEnum, UInt32[] rSignatures, UInt32 cmax)
public UInt32 EnumTypeSpecs(UInt32& phEnum, UInt32[] rTypeSpecs, UInt32 cmax)
public UInt32 EnumUserStrings(UInt32& phEnum, UInt32[] rStrings, UInt32 cmax)
public int GetParamForMethodIndex(UInt32 md, UInt32 ulParamSeq, UInt32& pParam)
public UInt32 EnumCustomAttributes(UInt32& phEnum, UInt32 tk, UInt32 tkType, UInt32[] rCustomAttributes, UInt32 cMax)
public UInt32 GetCustomAttributeProps(UInt32 cv, UInt32& ptkObj, UInt32& ptkType, IntPtr& ppBlob)
public UInt32 FindTypeRef(UInt32 tkResolutionScope, string szName)
public UInt32 GetMemberProps(UInt32 mb, UInt32& pClass, StringBuilder szMember, UInt32 cchMember, UInt32& pchMember, UInt32& pdwAttr, IntPtr& ppvSigBlob, UInt32& pcbSigBlob, UInt32& pulCodeRVA, UInt32& pdwImplFlags, UInt32& pdwCPlusTypeFlag, IntPtr& ppValue)
public UInt32 GetFieldProps(UInt32 mb, UInt32& pClass, StringBuilder szField, UInt32 cchField, UInt32& pchField, UInt32& pdwAttr, IntPtr& ppvSigBlob, UInt32& pcbSigBlob, UInt32& pdwCPlusTypeFlag, IntPtr& ppValue)
public UInt32 GetPropertyProps(UInt32 prop, UInt32& pClass, StringBuilder szProperty, UInt32 cchProperty, UInt32& pchProperty, UInt32& pdwPropFlags, IntPtr& ppvSig, UInt32& pbSig, UInt32& pdwCPlusTypeFlag, IntPtr& ppDefaultValue, UInt32& pcchDefaultValue, UInt32& pmdSetter, UInt32& pmdGetter, UInt32[] rmdOtherMethod, UInt32 cMax)
public UInt32 GetParamProps(UInt32 tk, UInt32& pmd, UInt32& pulSequence, StringBuilder szName, UInt32 cchName, UInt32& pchName, UInt32& pdwAttr, UInt32& pdwCPlusTypeFlag, IntPtr& ppValue)
public UInt32 GetCustomAttributeByName(UInt32 tkObj, string szName, IntPtr& ppData)
public bool IsValidToken(UInt32 tk)
public UInt32 GetNestedClassProps(UInt32 tdNestedClass, UInt32* ptdEnclosingClass)
public UInt32 GetNativeCallConvFromSig(IntPtr pvSig, UInt32 cbSig)
public int IsGlobal(UInt32 pd)
}
internal Mono.Cecil.Pdb.ISymUnmanagedDocumentWriter {
public void SetSource(UInt32 sourceSize, Byte[] source)
public void SetCheckSum(Guid algorithmId, UInt32 checkSumSize, Byte[] checkSum)
}
internal Mono.Cecil.Pdb.ISymUnmanagedWriter2 {
public void DefineDocument(string url, Guid& langauge, Guid& languageVendor, Guid& documentType, ISymUnmanagedDocumentWriter& pRetVal)
public void SetUserEntryPoint(int methodToken)
public void OpenMethod(int methodToken)
public void CloseMethod()
public void OpenScope(int startOffset, Int32& pRetVal)
public void CloseScope(int endOffset)
public void SetScopeRange_Placeholder()
public void DefineLocalVariable_Placeholder()
public void DefineParameter_Placeholder()
public void DefineField_Placeholder()
public void DefineGlobalVariable_Placeholder()
public void Close()
public void SetSymAttribute(UInt32 parent, string name, UInt32 data, IntPtr signature)
public void OpenNamespace(string name)
public void CloseNamespace()
public void UsingNamespace(string fullName)
public void SetMethodSourceRange_Placeholder()
public void Initialize(object emitter, string filename, IStream pIStream, bool fFullBuild)
public void GetDebugInfo(ImageDebugDirectory& pIDD, int cData, Int32& pcData, Byte[] data)
public void DefineSequencePoints(ISymUnmanagedDocumentWriter document, int spCount, Int32[] offsets, Int32[] lines, Int32[] columns, Int32[] endLines, Int32[] endColumns)
public void RemapToken_Placeholder()
public void Initialize2_Placeholder()
public void DefineConstant_Placeholder()
public void Abort_Placeholder()
public void DefineLocalVariable2(string name, int attributes, int sigToken, int addrKind, int addr1, int addr2, int addr3, int startOffset, int endOffset)
public void DefineGlobalVariable2_Placeholder()
public void DefineConstant2(string name, object variant, int sigToken)
}
internal Mono.Cecil.Pdb.ModuleMetadata : object {
private ModuleDefinition module
private Dictionary`2<UInt32, TypeDefinition> types
private Dictionary`2<UInt32, MethodDefinition> methods
private UInt32 S_OK
private UInt32 E_FAIL
public void .ctor(ModuleDefinition module)
private bool TryGetType(UInt32 token, TypeDefinition& type)
private bool TryGetMethod(UInt32 token, MethodDefinition& method)
private void InitializeMetadata(ModuleDefinition module)
private void InitializeMethods(TypeDefinition type)
public void SetModuleProps(string szName)
public void Save(string szFile, UInt32 dwSaveFlags)
public void SaveToStream(IntPtr pIStream, UInt32 dwSaveFlags)
public UInt32 GetSaveSize(UInt32 fSave)
public UInt32 DefineTypeDef(IntPtr szTypeDef, UInt32 dwTypeDefFlags, UInt32 tkExtends, IntPtr rtkImplements)
public UInt32 DefineNestedType(IntPtr szTypeDef, UInt32 dwTypeDefFlags, UInt32 tkExtends, IntPtr rtkImplements, UInt32 tdEncloser)
public void SetHandler(object pUnk)
public UInt32 DefineMethod(UInt32 td, IntPtr zName, UInt32 dwMethodFlags, IntPtr pvSigBlob, UInt32 cbSigBlob, UInt32 ulCodeRVA, UInt32 dwImplFlags)
public void DefineMethodImpl(UInt32 td, UInt32 tkBody, UInt32 tkDecl)
public UInt32 DefineTypeRefByName(UInt32 tkResolutionScope, IntPtr szName)
public UInt32 DefineImportType(IntPtr pAssemImport, IntPtr pbHashValue, UInt32 cbHashValue, IMetaDataImport pImport, UInt32 tdImport, IntPtr pAssemEmit)
public UInt32 DefineMemberRef(UInt32 tkImport, string szName, IntPtr pvSigBlob, UInt32 cbSigBlob)
public UInt32 DefineImportMember(IntPtr pAssemImport, IntPtr pbHashValue, UInt32 cbHashValue, IMetaDataImport pImport, UInt32 mbMember, IntPtr pAssemEmit, UInt32 tkParent)
public UInt32 DefineEvent(UInt32 td, string szEvent, UInt32 dwEventFlags, UInt32 tkEventType, UInt32 mdAddOn, UInt32 mdRemoveOn, UInt32 mdFire, IntPtr rmdOtherMethods)
public void SetClassLayout(UInt32 td, UInt32 dwPackSize, IntPtr rFieldOffsets, UInt32 ulClassSize)
public void DeleteClassLayout(UInt32 td)
public void SetFieldMarshal(UInt32 tk, IntPtr pvNativeType, UInt32 cbNativeType)
public void DeleteFieldMarshal(UInt32 tk)
public UInt32 DefinePermissionSet(UInt32 tk, UInt32 dwAction, IntPtr pvPermission, UInt32 cbPermission)
public void SetRVA(UInt32 md, UInt32 ulRVA)
public UInt32 GetTokenFromSig(IntPtr pvSig, UInt32 cbSig)
public UInt32 DefineModuleRef(string szName)
public void SetParent(UInt32 mr, UInt32 tk)
public UInt32 GetTokenFromTypeSpec(IntPtr pvSig, UInt32 cbSig)
public void SaveToMemory(IntPtr pbData, UInt32 cbData)
public UInt32 DefineUserString(string szString, UInt32 cchString)
public void DeleteToken(UInt32 tkObj)
public void SetMethodProps(UInt32 md, UInt32 dwMethodFlags, UInt32 ulCodeRVA, UInt32 dwImplFlags)
public void SetTypeDefProps(UInt32 td, UInt32 dwTypeDefFlags, UInt32 tkExtends, IntPtr rtkImplements)
public void SetEventProps(UInt32 ev, UInt32 dwEventFlags, UInt32 tkEventType, UInt32 mdAddOn, UInt32 mdRemoveOn, UInt32 mdFire, IntPtr rmdOtherMethods)
public UInt32 SetPermissionSetProps(UInt32 tk, UInt32 dwAction, IntPtr pvPermission, UInt32 cbPermission)
public void DefinePinvokeMap(UInt32 tk, UInt32 dwMappingFlags, string szImportName, UInt32 mrImportDLL)
public void SetPinvokeMap(UInt32 tk, UInt32 dwMappingFlags, string szImportName, UInt32 mrImportDLL)
public void DeletePinvokeMap(UInt32 tk)
public UInt32 DefineCustomAttribute(UInt32 tkObj, UInt32 tkType, IntPtr pCustomAttribute, UInt32 cbCustomAttribute)
public void SetCustomAttributeValue(UInt32 pcv, IntPtr pCustomAttribute, UInt32 cbCustomAttribute)
public UInt32 DefineField(UInt32 td, string szName, UInt32 dwFieldFlags, IntPtr pvSigBlob, UInt32 cbSigBlob, UInt32 dwCPlusTypeFlag, IntPtr pValue, UInt32 cchValue)
public UInt32 DefineProperty(UInt32 td, string szProperty, UInt32 dwPropFlags, IntPtr pvSig, UInt32 cbSig, UInt32 dwCPlusTypeFlag, IntPtr pValue, UInt32 cchValue, UInt32 mdSetter, UInt32 mdGetter, IntPtr rmdOtherMethods)
public UInt32 DefineParam(UInt32 md, UInt32 ulParamSeq, string szName, UInt32 dwParamFlags, UInt32 dwCPlusTypeFlag, IntPtr pValue, UInt32 cchValue)
public void SetFieldProps(UInt32 fd, UInt32 dwFieldFlags, UInt32 dwCPlusTypeFlag, IntPtr pValue, UInt32 cchValue)
public void SetPropertyProps(UInt32 pr, UInt32 dwPropFlags, UInt32 dwCPlusTypeFlag, IntPtr pValue, UInt32 cchValue, UInt32 mdSetter, UInt32 mdGetter, IntPtr rmdOtherMethods)
public void SetParamProps(UInt32 pd, string szName, UInt32 dwParamFlags, UInt32 dwCPlusTypeFlag, IntPtr pValue, UInt32 cchValue)
public UInt32 DefineSecurityAttributeSet(UInt32 tkObj, IntPtr rSecAttrs, UInt32 cSecAttrs)
public void ApplyEditAndContinue(object pImport)
public UInt32 TranslateSigWithScope(IntPtr pAssemImport, IntPtr pbHashValue, UInt32 cbHashValue, IMetaDataImport import, IntPtr pbSigBlob, UInt32 cbSigBlob, IntPtr pAssemEmit, IMetaDataEmit emit, IntPtr pvTranslatedSig, UInt32 cbTranslatedSigMax)
public void SetMethodImplFlags(UInt32 md, UInt32 dwImplFlags)
public void SetFieldRVA(UInt32 fd, UInt32 ulRVA)
public void Merge(IMetaDataImport pImport, IntPtr pHostMapToken, object pHandler)
public void MergeEnd()
public void CloseEnum(UInt32 hEnum)
public UInt32 CountEnum(UInt32 hEnum)
public void ResetEnum(UInt32 hEnum, UInt32 ulPos)
public UInt32 EnumTypeDefs(UInt32& phEnum, UInt32[] rTypeDefs, UInt32 cMax)
public UInt32 EnumInterfaceImpls(UInt32& phEnum, UInt32 td, UInt32[] rImpls, UInt32 cMax)
public UInt32 EnumTypeRefs(UInt32& phEnum, UInt32[] rTypeRefs, UInt32 cMax)
public UInt32 FindTypeDefByName(string szTypeDef, UInt32 tkEnclosingClass)
public Guid GetScopeProps(StringBuilder szName, UInt32 cchName, UInt32& pchName)
public UInt32 GetModuleFromScope()
public UInt32 GetTypeDefProps(UInt32 td, Char* szTypeDef, UInt32 cchTypeDef, UInt32* pchTypeDef, UInt32* pdwTypeDefFlags, UInt32* ptkExtends)
public UInt32 GetInterfaceImplProps(UInt32 iiImpl, UInt32& pClass)
public UInt32 GetTypeRefProps(UInt32 tr, UInt32& ptkResolutionScope, StringBuilder szName, UInt32 cchName)
public UInt32 ResolveTypeRef(UInt32 tr, Guid& riid, Object& ppIScope)
public UInt32 EnumMembers(UInt32& phEnum, UInt32 cl, UInt32[] rMembers, UInt32 cMax)
public UInt32 EnumMembersWithName(UInt32& phEnum, UInt32 cl, string szName, UInt32[] rMembers, UInt32 cMax)
public UInt32 EnumMethods(UInt32& phEnum, UInt32 cl, IntPtr rMethods, UInt32 cMax)
public UInt32 EnumMethodsWithName(UInt32& phEnum, UInt32 cl, string szName, UInt32[] rMethods, UInt32 cMax)
public UInt32 EnumFields(UInt32& phEnum, UInt32 cl, IntPtr rFields, UInt32 cMax)
public UInt32 EnumFieldsWithName(UInt32& phEnum, UInt32 cl, string szName, UInt32[] rFields, UInt32 cMax)
public UInt32 EnumParams(UInt32& phEnum, UInt32 mb, UInt32[] rParams, UInt32 cMax)
public UInt32 EnumMemberRefs(UInt32& phEnum, UInt32 tkParent, UInt32[] rMemberRefs, UInt32 cMax)
public UInt32 EnumMethodImpls(UInt32& phEnum, UInt32 td, UInt32[] rMethodBody, UInt32[] rMethodDecl, UInt32 cMax)
public UInt32 EnumPermissionSets(UInt32& phEnum, UInt32 tk, UInt32 dwActions, UInt32[] rPermission, UInt32 cMax)
public UInt32 FindMember(UInt32 td, string szName, Byte[] pvSigBlob, UInt32 cbSigBlob)
public UInt32 FindMethod(UInt32 td, string szName, Byte[] pvSigBlob, UInt32 cbSigBlob)
public UInt32 FindField(UInt32 td, string szName, Byte[] pvSigBlob, UInt32 cbSigBlob)
public UInt32 FindMemberRef(UInt32 td, string szName, Byte[] pvSigBlob, UInt32 cbSigBlob)
public UInt32 GetMethodProps(UInt32 mb, UInt32* pClass, Char* szMethod, UInt32 cchMethod, UInt32* pchMethod, UInt32* pdwAttr, IntPtr ppvSigBlob, IntPtr pcbSigBlob, UInt32* pulCodeRVA, UInt32* pdwImplFlags)
private void WriteNameBuffer(string name, Char* buffer, UInt32 bufferLength, UInt32* actualLength)
public UInt32 GetMemberRefProps(UInt32 mr, UInt32& ptk, StringBuilder szMember, UInt32 cchMember, UInt32& pchMember, IntPtr& ppvSigBlob)
public UInt32 EnumProperties(UInt32& phEnum, UInt32 td, IntPtr rProperties, UInt32 cMax)
public UInt32 EnumEvents(UInt32& phEnum, UInt32 td, IntPtr rEvents, UInt32 cMax)
public UInt32 GetEventProps(UInt32 ev, UInt32& pClass, StringBuilder szEvent, UInt32 cchEvent, UInt32& pchEvent, UInt32& pdwEventFlags, UInt32& ptkEventType, UInt32& pmdAddOn, UInt32& pmdRemoveOn, UInt32& pmdFire, UInt32[] rmdOtherMethod, UInt32 cMax)
public UInt32 EnumMethodSemantics(UInt32& phEnum, UInt32 mb, UInt32[] rEventProp, UInt32 cMax)
public UInt32 GetMethodSemantics(UInt32 mb, UInt32 tkEventProp)
public UInt32 GetClassLayout(UInt32 td, UInt32& pdwPackSize, IntPtr rFieldOffset, UInt32 cMax, UInt32& pcFieldOffset)
public UInt32 GetFieldMarshal(UInt32 tk, IntPtr& ppvNativeType)
public UInt32 GetRVA(UInt32 tk, UInt32& pulCodeRVA)
public UInt32 GetPermissionSetProps(UInt32 pm, UInt32& pdwAction, IntPtr& ppvPermission)
public UInt32 GetSigFromToken(UInt32 mdSig, IntPtr& ppvSig)
public UInt32 GetModuleRefProps(UInt32 mur, StringBuilder szName, UInt32 cchName)
public UInt32 EnumModuleRefs(UInt32& phEnum, UInt32[] rModuleRefs, UInt32 cmax)
public UInt32 GetTypeSpecFromToken(UInt32 typespec, IntPtr& ppvSig)
public UInt32 GetNameFromToken(UInt32 tk)
public UInt32 EnumUnresolvedMethods(UInt32& phEnum, UInt32[] rMethods, UInt32 cMax)
public UInt32 GetUserString(UInt32 stk, StringBuilder szString, UInt32 cchString)
public UInt32 GetPinvokeMap(UInt32 tk, UInt32& pdwMappingFlags, StringBuilder szImportName, UInt32 cchImportName, UInt32& pchImportName)
public UInt32 EnumSignatures(UInt32& phEnum, UInt32[] rSignatures, UInt32 cmax)
public UInt32 EnumTypeSpecs(UInt32& phEnum, UInt32[] rTypeSpecs, UInt32 cmax)
public UInt32 EnumUserStrings(UInt32& phEnum, UInt32[] rStrings, UInt32 cmax)
public int GetParamForMethodIndex(UInt32 md, UInt32 ulParamSeq, UInt32& pParam)
public UInt32 EnumCustomAttributes(UInt32& phEnum, UInt32 tk, UInt32 tkType, UInt32[] rCustomAttributes, UInt32 cMax)
public UInt32 GetCustomAttributeProps(UInt32 cv, UInt32& ptkObj, UInt32& ptkType, IntPtr& ppBlob)
public UInt32 FindTypeRef(UInt32 tkResolutionScope, string szName)
public UInt32 GetMemberProps(UInt32 mb, UInt32& pClass, StringBuilder szMember, UInt32 cchMember, UInt32& pchMember, UInt32& pdwAttr, IntPtr& ppvSigBlob, UInt32& pcbSigBlob, UInt32& pulCodeRVA, UInt32& pdwImplFlags, UInt32& pdwCPlusTypeFlag, IntPtr& ppValue)
public UInt32 GetFieldProps(UInt32 mb, UInt32& pClass, StringBuilder szField, UInt32 cchField, UInt32& pchField, UInt32& pdwAttr, IntPtr& ppvSigBlob, UInt32& pcbSigBlob, UInt32& pdwCPlusTypeFlag, IntPtr& ppValue)
public UInt32 GetPropertyProps(UInt32 prop, UInt32& pClass, StringBuilder szProperty, UInt32 cchProperty, UInt32& pchProperty, UInt32& pdwPropFlags, IntPtr& ppvSig, UInt32& pbSig, UInt32& pdwCPlusTypeFlag, IntPtr& ppDefaultValue, UInt32& pcchDefaultValue, UInt32& pmdSetter, UInt32& pmdGetter, UInt32[] rmdOtherMethod, UInt32 cMax)
public UInt32 GetParamProps(UInt32 tk, UInt32& pmd, UInt32& pulSequence, StringBuilder szName, UInt32 cchName, UInt32& pchName, UInt32& pdwAttr, UInt32& pdwCPlusTypeFlag, IntPtr& ppValue)
public UInt32 GetCustomAttributeByName(UInt32 tkObj, string szName, IntPtr& ppData)
public bool IsValidToken(UInt32 tk)
public UInt32 GetNestedClassProps(UInt32 tdNestedClass, UInt32* ptdEnclosingClass)
public UInt32 GetNativeCallConvFromSig(IntPtr pvSig, UInt32 cbSig)
public int IsGlobal(UInt32 pd)
}
internal Mono.Cecil.Pdb.NativePdbReader : object {
private Disposable`1<Stream> pdb_file
private Dictionary`2<string, Document> documents
private Dictionary`2<UInt32, PdbFunction> functions
private Dictionary`2<PdbScope, ImportDebugInformation> imports
internal void .ctor(Disposable`1<Stream> file)
public ISymbolWriterProvider GetWriterProvider()
public bool ProcessDebugHeader(ImageDebugHeader header)
private bool IsMatchingEntry(PdbInfo info, ImageDebugHeaderEntry entry)
private int ReadInt32(Byte[] bytes, int start)
public MethodDebugInformation Read(MethodDefinition method)
private Collection`1<ScopeDebugInformation> ReadScopeAndLocals(PdbScope[] scopes, MethodDebugInformation info)
private ScopeDebugInformation ReadScopeAndLocals(PdbScope scope, MethodDebugInformation info)
private bool AddScope(Collection`1<ScopeDebugInformation> scopes, ScopeDebugInformation scope)
private ImportDebugInformation GetImport(UInt32 token, ModuleDefinition module)
private ImportDebugInformation GetImport(PdbScope scope, ModuleDefinition module)
private void ReadSequencePoints(PdbFunction function, MethodDebugInformation info)
private void ReadLines(PdbLines lines, MethodDebugInformation info)
private void ReadLine(PdbLine line, Document document, MethodDebugInformation info)
private Document GetDocument(PdbSource source)
public void Dispose()
}
internal Mono.Cecil.Pdb.NativePdbReaderProvider : object {
public ISymbolReader GetSymbolReader(ModuleDefinition module, string fileName)
public ISymbolReader GetSymbolReader(ModuleDefinition module, Stream symbolStream)
}
internal Mono.Cecil.Pdb.NativePdbWriter : object {
private ModuleDefinition module
private MetadataBuilder metadata
private SymWriter writer
private Dictionary`2<string, SymDocumentWriter> documents
private Dictionary`2<ImportDebugInformation, MetadataToken> import_info_to_parent
private ImageDebugDirectory debug_directory
private Byte[] debug_info
internal void .ctor(ModuleDefinition module, SymWriter writer)
public ISymbolReaderProvider GetReaderProvider()
public ImageDebugHeader GetDebugHeader()
public void Write(MethodDebugInformation info)
private void DefineCustomMetadata(MethodDebugInformation info, MetadataToken import_parent)
private void DefineAsyncCustomMetadata(MethodDebugInformation info)
private void DefineScope(ScopeDebugInformation scope, MethodDebugInformation info, MetadataToken& import_parent)
private void DefineSequencePoints(Collection`1<SequencePoint> sequence_points)
private void DefineLocalVariable(VariableDebugInformation variable, int local_var_token, int start_offset, int end_offset)
private void DefineConstant(ConstantDebugInformation constant)
private SymDocumentWriter GetDocument(Document document)
public void Write()
public void Dispose()
}
internal Mono.Cecil.Pdb.NativePdbWriterProvider : object {
public ISymbolWriter GetSymbolWriter(ModuleDefinition module, string fileName)
private SymWriter CreateWriter(ModuleDefinition module, string pdb)
public ISymbolWriter GetSymbolWriter(ModuleDefinition module, Stream symbolStream)
}
internal Mono.Cecil.Pdb.PdbReaderProvider : object {
public ISymbolReader GetSymbolReader(ModuleDefinition module, string fileName)
public ISymbolReader GetSymbolReader(ModuleDefinition module, Stream symbolStream)
}
internal Mono.Cecil.Pdb.PdbWriterProvider : object {
public ISymbolWriter GetSymbolWriter(ModuleDefinition module, string fileName)
private bool HasPortablePdbSymbols(ModuleDefinition module)
public ISymbolWriter GetSymbolWriter(ModuleDefinition module, Stream symbolStream)
}
internal Mono.Cecil.Pdb.SymDocumentWriter : object {
private ISymUnmanagedDocumentWriter writer
public ISymUnmanagedDocumentWriter Writer
public ISymUnmanagedDocumentWriter get_Writer()
public void .ctor(ISymUnmanagedDocumentWriter writer)
public void SetSource(Byte[] source)
public void SetCheckSum(Guid hashAlgo, Byte[] checkSum)
}
internal Mono.Cecil.Pdb.SymWriter : object {
private Guid s_symUnmangedWriterIID
private Guid s_CorSymWriter_SxS_ClassID
private ISymUnmanagedWriter2 writer
private Collection`1<ISymUnmanagedDocumentWriter> documents
private int CoCreateInstance(Guid& rclsid, object pUnkOuter, UInt32 dwClsContext, Guid& riid, Object& ppv)
public Byte[] GetDebugInfo(ImageDebugDirectory& idd)
public void DefineLocalVariable2(string name, VariableAttributes attributes, int sigToken, int addr1, int addr2, int addr3, int startOffset, int endOffset)
public void DefineConstant2(string name, object value, int sigToken)
public void Close()
public void CloseMethod()
public void CloseNamespace()
public void CloseScope(int endOffset)
public SymDocumentWriter DefineDocument(string url, Guid language, Guid languageVendor, Guid documentType)
public void DefineSequencePoints(SymDocumentWriter document, Int32[] offsets, Int32[] lines, Int32[] columns, Int32[] endLines, Int32[] endColumns)
public void Initialize(object emitter, string filename, bool fFullBuild)
public void SetUserEntryPoint(int methodToken)
public void OpenMethod(int methodToken)
public void OpenNamespace(string name)
public int OpenScope(int startOffset)
public void UsingNamespace(string fullName)
public void DefineCustomMetadata(string name, Byte[] metadata)
}
internal Mono.Cecil.PE.BinaryStreamReader : BinaryReader {
public int Position
public int Length
public int get_Position()
public void set_Position(int value)
public int get_Length()
public void .ctor(Stream stream)
public void Advance(int bytes)
public void MoveTo(UInt32 position)
public void Align(int align)
public DataDirectory ReadDataDirectory()
}
internal Mono.Cecil.PE.BinaryStreamWriter : BinaryWriter {
public int Position
public int get_Position()
public void set_Position(int value)
public void .ctor(Stream stream)
public void WriteByte(byte value)
public void WriteUInt16(ushort value)
public void WriteInt16(short value)
public void WriteUInt32(UInt32 value)
public void WriteInt32(int value)
public void WriteUInt64(ulong value)
public void WriteBytes(Byte[] bytes)
public void WriteDataDirectory(DataDirectory directory)
public void WriteBuffer(ByteBuffer buffer)
protected void Advance(int bytes)
public void Align(int align)
}
internal Mono.Cecil.PE.ByteBuffer : object {
internal Byte[] buffer
internal int length
internal int position
public void .ctor(int length)
public void .ctor(Byte[] buffer)
public void Advance(int length)
public byte ReadByte()
public sbyte ReadSByte()
public Byte[] ReadBytes(int length)
public ushort ReadUInt16()
public short ReadInt16()
public UInt32 ReadUInt32()
public int ReadInt32()
public ulong ReadUInt64()
public long ReadInt64()
public UInt32 ReadCompressedUInt32()
public int ReadCompressedInt32()
public float ReadSingle()
public double ReadDouble()
public void WriteByte(byte value)
public void WriteSByte(sbyte value)
public void WriteUInt16(ushort value)
public void WriteInt16(short value)
public void WriteUInt32(UInt32 value)
public void WriteInt32(int value)
public void WriteUInt64(ulong value)
public void WriteInt64(long value)
public void WriteCompressedUInt32(UInt32 value)
public void WriteCompressedInt32(int value)
public void WriteBytes(Byte[] bytes)
public void WriteBytes(int length)
public void WriteBytes(ByteBuffer buffer)
public void WriteSingle(float value)
public void WriteDouble(double value)
private void Grow(int desired)
}
internal Mono.Cecil.PE.ByteBufferEqualityComparer : object {
public bool Equals(ByteBuffer x, ByteBuffer y)
public int GetHashCode(ByteBuffer buffer)
}
internal Mono.Cecil.PE.DataDirectory : ValueType {
public UInt32 VirtualAddress
public UInt32 Size
public bool IsZero
public bool get_IsZero()
public void .ctor(UInt32 rva, UInt32 size)
}
internal Mono.Cecil.PE.Image : object {
public Disposable`1<Stream> Stream
public string FileName
public ModuleKind Kind
public UInt32 Characteristics
public string RuntimeVersion
public TargetArchitecture Architecture
public ModuleCharacteristics DllCharacteristics
public ushort LinkerVersion
public ushort SubSystemMajor
public ushort SubSystemMinor
public ImageDebugHeader DebugHeader
public Section[] Sections
public Section MetadataSection
public UInt32 EntryPointToken
public UInt32 Timestamp
public ModuleAttributes Attributes
public DataDirectory Win32Resources
public DataDirectory Debug
public DataDirectory Resources
public DataDirectory StrongName
public StringHeap StringHeap
public BlobHeap BlobHeap
public UserStringHeap UserStringHeap
public GuidHeap GuidHeap
public TableHeap TableHeap
public PdbHeap PdbHeap
private Int32[] coded_index_sizes
private Func`2<Table, int> counter
public bool HasTable(Table table)
public int GetTableLength(Table table)
public int GetTableIndexSize(Table table)
public int GetCodedIndexSize(CodedIndex coded_index)
public UInt32 ResolveVirtualAddress(UInt32 rva)
public UInt32 ResolveVirtualAddressInSection(UInt32 rva, Section section)
public Section GetSection(string name)
public Section GetSectionAtVirtualAddress(UInt32 rva)
private BinaryStreamReader GetReaderAt(UInt32 rva)
public TRet GetReaderAt(UInt32 rva, TItem item, Func`3<TItem, BinaryStreamReader, TRet> read)
public bool HasDebugTables()
public void Dispose()
}
internal Mono.Cecil.PE.ImageReader : BinaryStreamReader {
private Image image
private DataDirectory cli
private DataDirectory metadata
private UInt32 table_heap_offset
private UInt32 pdb_heap_offset
public void .ctor(Disposable`1<Stream> stream, string file_name)
private void MoveTo(DataDirectory directory)
private void ReadImage()
private TargetArchitecture ReadArchitecture()
private ModuleKind GetModuleKind(ushort characteristics, ushort subsystem)
private void ReadOptionalHeaders(UInt16& subsystem, UInt16& dll_characteristics)
private string ReadAlignedString(int length)
private string ReadZeroTerminatedString(int length)
private void ReadSections(ushort count)
private void ReadCLIHeader()
private void ReadMetadata()
private void ReadDebugHeader()
private void ReadMetadataStream(Section section)
private Byte[] ReadHeapData(UInt32 offset, UInt32 size)
private void ReadTableHeap()
private void SetIndexSize(Heap heap, UInt32 sizes, byte flag)
private int GetTableIndexSize(Table table)
private int GetCodedIndexSize(CodedIndex index)
private void ComputeTableInformations()
private void ReadPdbHeap()
public Image ReadImage(Disposable`1<Stream> stream, string file_name)
public Image ReadPortablePdb(Disposable`1<Stream> stream, string file_name, UInt32& pdb_heap_offset)
}
internal Mono.Cecil.PE.ImageWriter : BinaryStreamWriter {
private ModuleDefinition module
private MetadataBuilder metadata
private TextMap text_map
internal Disposable`1<Stream> stream
private string runtime_version
private ImageDebugHeader debug_header
private ByteBuffer win32_resources
private UInt32 pe_header_size
private UInt32 section_header_size
private UInt32 file_alignment
private UInt32 section_alignment
private ulong image_base
internal UInt32 text_rva
private bool pe64
private bool has_reloc
internal Section text
internal Section rsrc
internal Section reloc
private ushort sections
internal long debug_header_entries_position
private void .ctor(ModuleDefinition module, string runtime_version, MetadataBuilder metadata, Disposable`1<Stream> stream, bool metadataOnly)
private void GetDebugHeader()
private void GetWin32Resources()
public ImageWriter CreateWriter(ModuleDefinition module, MetadataBuilder metadata, Disposable`1<Stream> stream)
public ImageWriter CreateDebugWriter(ModuleDefinition module, MetadataBuilder metadata, Disposable`1<Stream> stream)
private void BuildSections()
private Section CreateSection(string name, UInt32 size, Section previous)
private UInt32 Align(UInt32 value, UInt32 align)
private void WriteDOSHeader()
private ushort SizeOfOptionalHeader()
private void WritePEFileHeader()
private Section LastSection()
private void WriteOptionalHeaders()
private void WriteZeroDataDirectory()
private ushort GetSubSystem()
private void WriteSectionHeaders()
private void WriteSection(Section section, UInt32 characteristics)
private UInt32 GetRVAFileOffset(Section section, UInt32 rva)
private void MoveTo(UInt32 pointer)
private void MoveToRVA(Section section, UInt32 rva)
internal void MoveToRVA(TextSegment segment)
private void WriteRVA(UInt32 rva)
private void PrepareSection(Section section)
private void WriteText()
private UInt32 GetMetadataLength()
public void WriteMetadataHeader()
private ushort GetStreamCount()
private void WriteStreamHeader(UInt32& offset, TextSegment heap, string name)
private int GetZeroTerminatedStringLength(string string)
private Byte[] GetZeroTerminatedString(string string)
private Byte[] GetSimpleString(string string)
private Byte[] GetString(string string, int length)
public void WriteMetadata()
private void WriteHeap(TextSegment heap, HeapBuffer buffer)
private void WriteDebugDirectory()
private void WriteImportDirectory()
private Byte[] GetRuntimeMain()
private void WriteStartupStub()
private void WriteRsrc()
private void WriteReloc()
public void WriteImage()
private void BuildTextMap()
public void BuildMetadataTextMap()
private UInt32 GetStartupStubLength()
private int GetMetadataHeaderLength(string runtimeVersion)
private int GetStrongNameLength()
public DataDirectory GetStrongNameSignatureDirectory()
public UInt32 GetHeaderSize()
private void PatchWin32Resources(ByteBuffer resources)
private void PatchResourceDirectoryTable(ByteBuffer resources)
private void PatchResourceDirectoryEntry(ByteBuffer resources)
private void PatchResourceDataEntry(ByteBuffer resources)
}
internal Mono.Cecil.PE.Section : object {
public string Name
public UInt32 VirtualAddress
public UInt32 VirtualSize
public UInt32 SizeOfRawData
public UInt32 PointerToRawData
}
internal Mono.Cecil.PE.TextMap : object {
private Range[] map
public void AddMap(TextSegment segment, int length)
private UInt32 AlignUp(UInt32 value, UInt32 align)
public void AddMap(TextSegment segment, int length, int align)
public void AddMap(TextSegment segment, Range range)
public Range GetRange(TextSegment segment)
public DataDirectory GetDataDirectory(TextSegment segment)
public UInt32 GetRVA(TextSegment segment)
public UInt32 GetNextRVA(TextSegment segment)
public int GetLength(TextSegment segment)
private UInt32 GetStart(TextSegment segment)
private UInt32 ComputeStart(int index)
public UInt32 GetLength()
}
internal Mono.Cecil.PE.TextSegment : Enum {
public int value__
public TextSegment ImportAddressTable
public TextSegment CLIHeader
public TextSegment Code
public TextSegment Resources
public TextSegment Data
public TextSegment StrongNameSignature
public TextSegment MetadataHeader
public TextSegment TableHeap
public TextSegment StringHeap
public TextSegment UserStringHeap
public TextSegment GuidHeap
public TextSegment BlobHeap
public TextSegment PdbHeap
public TextSegment DebugDirectory
public TextSegment ImportDirectory
public TextSegment ImportHintNameTable
public TextSegment StartupStub
}
internal Mono.Cecil.PinnedType : TypeSpecification {
public bool IsValueType
public bool IsPinned
public bool get_IsValueType()
public void set_IsValueType(bool value)
public bool get_IsPinned()
public void .ctor(TypeReference type)
}
internal Mono.Cecil.PInvokeAttributes : Enum {
public ushort value__
public PInvokeAttributes NoMangle
public PInvokeAttributes CharSetMask
public PInvokeAttributes CharSetNotSpec
public PInvokeAttributes CharSetAnsi
public PInvokeAttributes CharSetUnicode
public PInvokeAttributes CharSetAuto
public PInvokeAttributes SupportsLastError
public PInvokeAttributes CallConvMask
public PInvokeAttributes CallConvWinapi
public PInvokeAttributes CallConvCdecl
public PInvokeAttributes CallConvStdCall
public PInvokeAttributes CallConvThiscall
public PInvokeAttributes CallConvFastcall
public PInvokeAttributes BestFitMask
public PInvokeAttributes BestFitEnabled
public PInvokeAttributes BestFitDisabled
public PInvokeAttributes ThrowOnUnmappableCharMask
public PInvokeAttributes ThrowOnUnmappableCharEnabled
public PInvokeAttributes ThrowOnUnmappableCharDisabled
}
internal Mono.Cecil.PInvokeInfo : object {
private ushort attributes
private string entry_point
private ModuleReference module
public PInvokeAttributes Attributes
public string EntryPoint
public ModuleReference Module
public bool IsNoMangle
public bool IsCharSetNotSpec
public bool IsCharSetAnsi
public bool IsCharSetUnicode
public bool IsCharSetAuto
public bool SupportsLastError
public bool IsCallConvWinapi
public bool IsCallConvCdecl
public bool IsCallConvStdCall
public bool IsCallConvThiscall
public bool IsCallConvFastcall
public bool IsBestFitEnabled
public bool IsBestFitDisabled
public bool IsThrowOnUnmappableCharEnabled
public bool IsThrowOnUnmappableCharDisabled
public PInvokeAttributes get_Attributes()
public void set_Attributes(PInvokeAttributes value)
public string get_EntryPoint()
public void set_EntryPoint(string value)
public ModuleReference get_Module()
public void set_Module(ModuleReference value)
public bool get_IsNoMangle()
public void set_IsNoMangle(bool value)
public bool get_IsCharSetNotSpec()
public void set_IsCharSetNotSpec(bool value)
public bool get_IsCharSetAnsi()
public void set_IsCharSetAnsi(bool value)
public bool get_IsCharSetUnicode()
public void set_IsCharSetUnicode(bool value)
public bool get_IsCharSetAuto()
public void set_IsCharSetAuto(bool value)
public bool get_SupportsLastError()
public void set_SupportsLastError(bool value)
public bool get_IsCallConvWinapi()
public void set_IsCallConvWinapi(bool value)
public bool get_IsCallConvCdecl()
public void set_IsCallConvCdecl(bool value)
public bool get_IsCallConvStdCall()
public void set_IsCallConvStdCall(bool value)
public bool get_IsCallConvThiscall()
public void set_IsCallConvThiscall(bool value)
public bool get_IsCallConvFastcall()
public void set_IsCallConvFastcall(bool value)
public bool get_IsBestFitEnabled()
public void set_IsBestFitEnabled(bool value)
public bool get_IsBestFitDisabled()
public void set_IsBestFitDisabled(bool value)
public bool get_IsThrowOnUnmappableCharEnabled()
public void set_IsThrowOnUnmappableCharEnabled(bool value)
public bool get_IsThrowOnUnmappableCharDisabled()
public void set_IsThrowOnUnmappableCharDisabled(bool value)
public void .ctor(PInvokeAttributes attributes, string entryPoint, ModuleReference module)
}
internal Mono.Cecil.PointerType : TypeSpecification {
public string Name
public string FullName
public bool IsValueType
public bool IsPointer
public string get_Name()
public string get_FullName()
public bool get_IsValueType()
public void set_IsValueType(bool value)
public bool get_IsPointer()
public void .ctor(TypeReference type)
}
internal Mono.Cecil.PropertyAttributes : Enum {
public ushort value__
public PropertyAttributes None
public PropertyAttributes SpecialName
public PropertyAttributes RTSpecialName
public PropertyAttributes HasDefault
public PropertyAttributes Unused
}
internal Mono.Cecil.PropertyDefinition : PropertyReference {
private Nullable`1<bool> has_this
private ushort attributes
private Collection`1<CustomAttribute> custom_attributes
internal MethodDefinition get_method
internal MethodDefinition set_method
internal Collection`1<MethodDefinition> other_methods
private object constant
public PropertyAttributes Attributes
public bool HasThis
public bool HasCustomAttributes
public Collection`1<CustomAttribute> CustomAttributes
public MethodDefinition GetMethod
public MethodDefinition SetMethod
public bool HasOtherMethods
public Collection`1<MethodDefinition> OtherMethods
public bool HasParameters
public Collection`1<ParameterDefinition> Parameters
public bool HasConstant
public object Constant
public bool IsSpecialName
public bool IsRuntimeSpecialName
public bool HasDefault
public TypeDefinition DeclaringType
public bool IsDefinition
public string FullName
public PropertyAttributes get_Attributes()
public void set_Attributes(PropertyAttributes value)
public bool get_HasThis()
public void set_HasThis(bool value)
public bool get_HasCustomAttributes()
public Collection`1<CustomAttribute> get_CustomAttributes()
public MethodDefinition get_GetMethod()
public void set_GetMethod(MethodDefinition value)
public MethodDefinition get_SetMethod()
public void set_SetMethod(MethodDefinition value)
public bool get_HasOtherMethods()
public Collection`1<MethodDefinition> get_OtherMethods()
public bool get_HasParameters()
public Collection`1<ParameterDefinition> get_Parameters()
private Collection`1<ParameterDefinition> MirrorParameters(MethodDefinition method, int bound)
public bool get_HasConstant()
public void set_HasConstant(bool value)
public object get_Constant()
public void set_Constant(object value)
public bool get_IsSpecialName()
public void set_IsSpecialName(bool value)
public bool get_IsRuntimeSpecialName()
public void set_IsRuntimeSpecialName(bool value)
public bool get_HasDefault()
public void set_HasDefault(bool value)
public TypeDefinition get_DeclaringType()
public void set_DeclaringType(TypeDefinition value)
public bool get_IsDefinition()
public string get_FullName()
public void .ctor(string name, PropertyAttributes attributes, TypeReference propertyType)
private void InitializeMethods()
public PropertyDefinition Resolve()
}
internal Mono.Cecil.PropertyMapTable : MetadataTable`1<Row`2<UInt32, UInt32>> {
public void Write(TableHeapBuffer buffer)
}
internal Mono.Cecil.PropertyReference : MemberReference {
private TypeReference property_type
public TypeReference PropertyType
public Collection`1<ParameterDefinition> Parameters
public TypeReference get_PropertyType()
public void set_PropertyType(TypeReference value)
public Collection`1<ParameterDefinition> get_Parameters()
internal void .ctor(string name, TypeReference propertyType)
protected IMemberDefinition ResolveDefinition()
public PropertyDefinition Resolve()
}
internal Mono.Cecil.PropertyTable : MetadataTable`1<Row`3<PropertyAttributes, UInt32, UInt32>> {
public void Write(TableHeapBuffer buffer)
}
internal Mono.Cecil.Range : ValueType {
public UInt32 Start
public UInt32 Length
public void .ctor(UInt32 index, UInt32 length)
}
internal Mono.Cecil.ReaderParameters : object {
private ReadingMode reading_mode
internal IAssemblyResolver assembly_resolver
internal IMetadataResolver metadata_resolver
internal IMetadataImporterProvider metadata_importer_provider
internal IReflectionImporterProvider reflection_importer_provider
private Stream symbol_stream
private ISymbolReaderProvider symbol_reader_provider
private bool read_symbols
private bool throw_symbols_mismatch
private bool projections
private bool in_memory
private bool read_write
public ReadingMode ReadingMode
public bool InMemory
public IAssemblyResolver AssemblyResolver
public IMetadataResolver MetadataResolver
public IMetadataImporterProvider MetadataImporterProvider
public IReflectionImporterProvider ReflectionImporterProvider
public Stream SymbolStream
public ISymbolReaderProvider SymbolReaderProvider
public bool ReadSymbols
public bool ThrowIfSymbolsAreNotMatching
public bool ReadWrite
public bool ApplyWindowsRuntimeProjections
public ReadingMode get_ReadingMode()
public void set_ReadingMode(ReadingMode value)
public bool get_InMemory()
public void set_InMemory(bool value)
public IAssemblyResolver get_AssemblyResolver()
public void set_AssemblyResolver(IAssemblyResolver value)
public IMetadataResolver get_MetadataResolver()
public void set_MetadataResolver(IMetadataResolver value)
public IMetadataImporterProvider get_MetadataImporterProvider()
public void set_MetadataImporterProvider(IMetadataImporterProvider value)
public IReflectionImporterProvider get_ReflectionImporterProvider()
public void set_ReflectionImporterProvider(IReflectionImporterProvider value)
public Stream get_SymbolStream()
public void set_SymbolStream(Stream value)
public ISymbolReaderProvider get_SymbolReaderProvider()
public void set_SymbolReaderProvider(ISymbolReaderProvider value)
public bool get_ReadSymbols()
public void set_ReadSymbols(bool value)
public bool get_ThrowIfSymbolsAreNotMatching()
public void set_ThrowIfSymbolsAreNotMatching(bool value)
public bool get_ReadWrite()
public void set_ReadWrite(bool value)
public bool get_ApplyWindowsRuntimeProjections()
public void set_ApplyWindowsRuntimeProjections(bool value)
public void .ctor(ReadingMode readingMode)
}
internal Mono.Cecil.ReadingMode : Enum {
public int value__
public ReadingMode Immediate
public ReadingMode Deferred
}
internal Mono.Cecil.RequiredModifierType : TypeSpecification {
private TypeReference modifier_type
public TypeReference ModifierType
public string Name
public string FullName
private string Suffix
public bool IsValueType
public bool IsRequiredModifier
public bool ContainsGenericParameter
public TypeReference get_ModifierType()
public void set_ModifierType(TypeReference value)
public string get_Name()
public string get_FullName()
private string get_Suffix()
public bool get_IsValueType()
public void set_IsValueType(bool value)
public bool get_IsRequiredModifier()
public bool get_ContainsGenericParameter()
public void .ctor(TypeReference modifierType, TypeReference type)
}
internal Mono.Cecil.ResolutionException : Exception {
private MemberReference member
public MemberReference Member
public IMetadataScope Scope
public MemberReference get_Member()
public IMetadataScope get_Scope()
public void .ctor(MemberReference member)
public void .ctor(MemberReference member, Exception innerException)
private void .ctor(SerializationInfo info, StreamingContext context)
}
internal Mono.Cecil.Resource : object {
private string name
private UInt32 attributes
public string Name
public ManifestResourceAttributes Attributes
public ResourceType ResourceType
public bool IsPublic
public bool IsPrivate
public string get_Name()
public void set_Name(string value)
public ManifestResourceAttributes get_Attributes()
public void set_Attributes(ManifestResourceAttributes value)
public ResourceType get_ResourceType()
public bool get_IsPublic()
public void set_IsPublic(bool value)
public bool get_IsPrivate()
public void set_IsPrivate(bool value)
internal void .ctor(string name, ManifestResourceAttributes attributes)
}
internal Mono.Cecil.ResourceType : Enum {
public int value__
public ResourceType Linked
public ResourceType Embedded
public ResourceType AssemblyLinked
}
internal Mono.Cecil.Rocks.DocCommentId : object {
private IMemberDefinition commentMember
private StringBuilder id
private void .ctor(IMemberDefinition member)
private void WriteField(FieldDefinition field)
private void WriteEvent(EventDefinition event)
private void WriteType(TypeDefinition type)
private void WriteMethod(MethodDefinition method)
private bool IsConversionOperator(MethodDefinition self)
private void WriteReturnType(MethodDefinition method)
private void WriteProperty(PropertyDefinition property)
private void WriteParameters(IList`1<ParameterDefinition> parameters)
private void WriteTypeSignature(TypeReference type)
private bool IsGenericMethodTypeParameter(TypeReference type)
private void WriteGenericInstanceTypeSignature(GenericInstanceType type)
private void WriteList(IList`1<T> list, Action`1<T> action)
private void WriteModiferTypeSignature(IModifierType type, char id)
private void WriteFunctionPointerTypeSignature(FunctionPointerType type)
private void WriteArrayTypeSignature(ArrayType type)
private void WriteDefinition(char id, IMemberDefinition member)
private void WriteTypeFullName(TypeReference type)
private void WriteTypeFullName(TypeReference type, GenericTypeOptions options)
private void WriteGenericTypeParameters(TypeReference type, GenericTypeOptions options)
private bool IsGenericType(TypeReference type)
private IList`1<TypeReference> GetGenericTypeArguments(TypeReference type, GenericTypeOptions options)
private void WriteItemName(string name)
public string ToString()
public string GetDocCommentId(IMemberDefinition member)
private void <WriteParameters>b__10_0(ParameterDefinition p)
private void <WriteArrayTypeSignature>b__17_0(ArrayDimension dimension)
}
internal Mono.Cecil.Rocks.Functional : object {
public Func`2<A, R> Y(Func`2<Func`2<A, R>, Func`2<A, R>> f)
public IEnumerable`1<TSource> Prepend(IEnumerable`1<TSource> source, TSource element)
private IEnumerable`1<TSource> PrependIterator(IEnumerable`1<TSource> source, TSource element)
}
internal Mono.Cecil.Rocks.IILVisitor {
public void OnInlineNone(OpCode opcode)
public void OnInlineSByte(OpCode opcode, sbyte value)
public void OnInlineByte(OpCode opcode, byte value)
public void OnInlineInt32(OpCode opcode, int value)
public void OnInlineInt64(OpCode opcode, long value)
public void OnInlineSingle(OpCode opcode, float value)
public void OnInlineDouble(OpCode opcode, double value)
public void OnInlineString(OpCode opcode, string value)
public void OnInlineBranch(OpCode opcode, int offset)
public void OnInlineSwitch(OpCode opcode, Int32[] offsets)
public void OnInlineVariable(OpCode opcode, VariableDefinition variable)
public void OnInlineArgument(OpCode opcode, ParameterDefinition parameter)
public void OnInlineSignature(OpCode opcode, CallSite callSite)
public void OnInlineType(OpCode opcode, TypeReference type)
public void OnInlineField(OpCode opcode, FieldReference field)
public void OnInlineMethod(OpCode opcode, MethodReference method)
}
internal Mono.Cecil.Rocks.ILParser : object {
public void Parse(MethodDefinition method, IILVisitor visitor)
private void ParseMethod(MethodDefinition method, IILVisitor visitor)
private ParseContext CreateContext(MethodDefinition method, IILVisitor visitor)
private void ParseFatMethod(ParseContext context)
private void ParseCode(int code_size, ParseContext context)
private VariableDefinition GetVariable(ParseContext context, int index)
}
internal Mono.Cecil.Rocks.MethodBodyRocks : object {
public void SimplifyMacros(MethodBody self)
private void ExpandMacro(Instruction instruction, OpCode opcode, object operand)
private void MakeMacro(Instruction instruction, OpCode opcode)
public void Optimize(MethodBody self)
private void OptimizeLongs(MethodBody self)
public void OptimizeMacros(MethodBody self)
private void OptimizeBranches(MethodBody body)
private bool OptimizeBranch(Instruction instruction)
private void ComputeOffsets(MethodBody body)
}
internal Mono.Cecil.Rocks.MethodDefinitionRocks : object {
public MethodDefinition GetBaseMethod(MethodDefinition self)
public MethodDefinition GetOriginalBaseMethod(MethodDefinition self)
private TypeDefinition ResolveBaseType(TypeDefinition type)
private MethodDefinition GetMatchingMethod(TypeDefinition type, MethodDefinition method)
}
internal Mono.Cecil.Rocks.ModuleDefinitionRocks : object {
public IEnumerable`1<TypeDefinition> GetAllTypes(ModuleDefinition self)
}
internal Mono.Cecil.Rocks.ParameterReferenceRocks : object {
public int GetSequence(ParameterReference self)
}
internal Mono.Cecil.Rocks.SecurityDeclarationRocks : object {
public PermissionSet ToPermissionSet(SecurityDeclaration self)
private bool TryProcessPermissionSetAttribute(SecurityDeclaration declaration, PermissionSet& set)
private PermissionSet CreatePermissionSet(SecurityDeclaration declaration)
private IPermission CreatePermission(SecurityDeclaration declaration, SecurityAttribute attribute)
private void CompleteSecurityAttribute(SecurityAttribute security_attribute, SecurityAttribute attribute)
private void CompleteSecurityAttributeFields(SecurityAttribute security_attribute, SecurityAttribute attribute)
private void CompleteSecurityAttributeProperties(SecurityAttribute security_attribute, SecurityAttribute attribute)
private SecurityAttribute CreateSecurityAttribute(Type attribute_type, SecurityDeclaration declaration)
public SecurityDeclaration ToSecurityDeclaration(PermissionSet self, SecurityAction action, ModuleDefinition module)
}
internal Mono.Cecil.Rocks.TypeDefinitionRocks : object {
public IEnumerable`1<MethodDefinition> GetConstructors(TypeDefinition self)
public MethodDefinition GetStaticConstructor(TypeDefinition self)
public IEnumerable`1<MethodDefinition> GetMethods(TypeDefinition self)
public TypeReference GetEnumUnderlyingType(TypeDefinition self)
}
internal Mono.Cecil.Rocks.TypeReferenceRocks : object {
public ArrayType MakeArrayType(TypeReference self)
public ArrayType MakeArrayType(TypeReference self, int rank)
public PointerType MakePointerType(TypeReference self)
public ByReferenceType MakeByReferenceType(TypeReference self)
public OptionalModifierType MakeOptionalModifierType(TypeReference self, TypeReference modifierType)
public RequiredModifierType MakeRequiredModifierType(TypeReference self, TypeReference modifierType)
public GenericInstanceType MakeGenericInstanceType(TypeReference self, TypeReference[] arguments)
public PinnedType MakePinnedType(TypeReference self)
public SentinelType MakeSentinelType(TypeReference self)
}
internal Mono.Cecil.SafeArrayMarshalInfo : MarshalInfo {
internal VariantType element_type
public VariantType ElementType
public VariantType get_ElementType()
public void set_ElementType(VariantType value)
}
internal Mono.Cecil.SecurityAction : Enum {
public ushort value__
public SecurityAction Request
public SecurityAction Demand
public SecurityAction Assert
public SecurityAction Deny
public SecurityAction PermitOnly
public SecurityAction LinkDemand
public SecurityAction InheritDemand
public SecurityAction RequestMinimum
public SecurityAction RequestOptional
public SecurityAction RequestRefuse
public SecurityAction PreJitGrant
public SecurityAction PreJitDeny
public SecurityAction NonCasDemand
public SecurityAction NonCasLinkDemand
public SecurityAction NonCasInheritance
}
internal Mono.Cecil.SecurityAttribute : object {
private TypeReference attribute_type
internal Collection`1<CustomAttributeNamedArgument> fields
internal Collection`1<CustomAttributeNamedArgument> properties
public TypeReference AttributeType
public bool HasFields
public Collection`1<CustomAttributeNamedArgument> Fields
public bool HasProperties
public Collection`1<CustomAttributeNamedArgument> Properties
private bool Mono.Cecil.ICustomAttribute.HasConstructorArguments
private Collection`1<CustomAttributeArgument> Mono.Cecil.ICustomAttribute.ConstructorArguments
public TypeReference get_AttributeType()
public void set_AttributeType(TypeReference value)
public bool get_HasFields()
public Collection`1<CustomAttributeNamedArgument> get_Fields()
public bool get_HasProperties()
public Collection`1<CustomAttributeNamedArgument> get_Properties()
public void .ctor(TypeReference attributeType)
private bool Mono.Cecil.ICustomAttribute.get_HasConstructorArguments()
private Collection`1<CustomAttributeArgument> Mono.Cecil.ICustomAttribute.get_ConstructorArguments()
}
internal Mono.Cecil.SecurityDeclaration : object {
internal UInt32 signature
private Byte[] blob
private ModuleDefinition module
internal bool resolved
private SecurityAction action
internal Collection`1<SecurityAttribute> security_attributes
public SecurityAction Action
public bool HasSecurityAttributes
public Collection`1<SecurityAttribute> SecurityAttributes
internal bool HasImage
public SecurityAction get_Action()
public void set_Action(SecurityAction value)
public bool get_HasSecurityAttributes()
public Collection`1<SecurityAttribute> get_SecurityAttributes()
internal bool get_HasImage()
internal void .ctor(SecurityAction action, UInt32 signature, ModuleDefinition module)
public void .ctor(SecurityAction action)
public void .ctor(SecurityAction action, Byte[] blob)
public Byte[] GetBlob()
private void Resolve()
}
internal Mono.Cecil.SentinelType : TypeSpecification {
public bool IsValueType
public bool IsSentinel
public bool get_IsValueType()
public void set_IsValueType(bool value)
public bool get_IsSentinel()
public void .ctor(TypeReference type)
}
internal Mono.Cecil.SignatureReader : ByteBuffer {
private MetadataReader reader
internal UInt32 start
internal UInt32 sig_length
private TypeSystem TypeSystem
private TypeSystem get_TypeSystem()
public void .ctor(UInt32 blob, MetadataReader reader)
private MetadataToken ReadTypeTokenSignature()
private GenericParameter GetGenericParameter(GenericParameterType type, UInt32 var)
private GenericParameter GetUnboundGenericParameter(GenericParameterType type, int index)
private void CheckGenericContext(IGenericParameterProvider owner, int index)
public void ReadGenericInstanceSignature(IGenericParameterProvider provider, IGenericInstance instance, UInt32 arity)
private ArrayType ReadArrayTypeSignature()
private TypeReference GetTypeDefOrRef(MetadataToken token)
public TypeReference ReadTypeSignature()
public TypeReference ReadTypeToken()
private TypeReference ReadTypeSignature(ElementType etype)
public void ReadMethodSignature(IMethodSignature method)
public object ReadConstantSignature(ElementType type)
public void ReadCustomAttributeConstructorArguments(CustomAttribute attribute, Collection`1<ParameterDefinition> parameters)
private CustomAttributeArgument ReadCustomAttributeFixedArgument(TypeReference type)
public void ReadCustomAttributeNamedArguments(ushort count, Collection`1& fields, Collection`1& properties)
private void ReadCustomAttributeNamedArgument(Collection`1& fields, Collection`1& properties)
private Collection`1<CustomAttributeNamedArgument> GetCustomAttributeNamedArgumentCollection(Collection`1& collection)
private CustomAttributeArgument ReadCustomAttributeFixedArrayArgument(ArrayType type)
private CustomAttributeArgument ReadCustomAttributeElement(TypeReference type)
private object ReadCustomAttributeElementValue(TypeReference type)
private object ReadPrimitiveValue(ElementType type)
private TypeReference GetPrimitiveType(ElementType etype)
private TypeReference ReadCustomAttributeFieldOrPropType()
public TypeReference ReadTypeReference()
private object ReadCustomAttributeEnum(TypeReference enum_type)
public SecurityAttribute ReadSecurityAttribute()
public MarshalInfo ReadMarshalInfo()
private NativeType ReadNativeType()
private VariantType ReadVariantType()
private string ReadUTF8String()
public string ReadDocumentName()
public Collection`1<SequencePoint> ReadSequencePoints(Document document)
public bool CanReadMore()
}
internal Mono.Cecil.SignatureWriter : ByteBuffer {
private MetadataBuilder metadata
public void .ctor(MetadataBuilder metadata)
public void WriteElementType(ElementType element_type)
public void WriteUTF8String(string string)
public void WriteMethodSignature(IMethodSignature method)
private UInt32 MakeTypeDefOrRefCodedRID(TypeReference type)
public void WriteTypeToken(TypeReference type)
public void WriteTypeSignature(TypeReference type)
private void WriteArrayTypeSignature(ArrayType array)
public void WriteGenericInstanceSignature(IGenericInstance instance)
private void WriteModifierSignature(ElementType element_type, IModifierType type)
private bool TryWriteElementType(TypeReference type)
public void WriteConstantString(string value)
public void WriteConstantPrimitive(object value)
public void WriteCustomAttributeConstructorArguments(CustomAttribute attribute)
private void WriteCustomAttributeFixedArgument(TypeReference type, CustomAttributeArgument argument)
private void WriteCustomAttributeFixedArrayArgument(ArrayType type, CustomAttributeArgument argument)
private void WriteCustomAttributeElement(TypeReference type, CustomAttributeArgument argument)
private void WriteCustomAttributeValue(TypeReference type, object value)
private void WriteCustomAttributeTypeValue(TypeReference value)
private void WritePrimitiveValue(object value)
private void WriteCustomAttributeEnumValue(TypeReference enum_type, object value)
private void WriteCustomAttributeFieldOrPropType(TypeReference type)
public void WriteCustomAttributeNamedArguments(CustomAttribute attribute)
private int GetNamedArgumentCount(ICustomAttribute attribute)
private void WriteICustomAttributeNamedArguments(ICustomAttribute attribute)
private void WriteCustomAttributeNamedArguments(byte kind, Collection`1<CustomAttributeNamedArgument> named_arguments)
private void WriteCustomAttributeNamedArgument(byte kind, CustomAttributeNamedArgument named_argument)
private void WriteSecurityAttribute(SecurityAttribute attribute)
public void WriteSecurityDeclaration(SecurityDeclaration declaration)
public void WriteXmlSecurityDeclaration(SecurityDeclaration declaration)
private string GetXmlSecurityDeclaration(SecurityDeclaration declaration)
private void WriteTypeReference(TypeReference type)
public void WriteMarshalInfo(MarshalInfo marshal_info)
private void WriteNativeType(NativeType native)
private void WriteVariantType(VariantType variant)
public void WriteSequencePoints(MethodDebugInformation info)
}
internal Mono.Cecil.SortedTable`1 : MetadataTable`1<TRow> {
public void Sort()
protected int Compare(UInt32 x, UInt32 y)
public int Compare(TRow x, TRow y)
}
internal Mono.Cecil.StandAloneSigTable : MetadataTable`1<UInt32> {
public void Write(TableHeapBuffer buffer)
}
internal Mono.Cecil.StateMachineMethodTable : MetadataTable`1<Row`2<UInt32, UInt32>> {
public void Write(TableHeapBuffer buffer)
}
internal Mono.Cecil.TargetArchitecture : Enum {
public int value__
public TargetArchitecture I386
public TargetArchitecture AMD64
public TargetArchitecture IA64
public TargetArchitecture ARM
public TargetArchitecture ARMv7
public TargetArchitecture ARM64
}
internal Mono.Cecil.TargetRuntime : Enum {
public int value__
public TargetRuntime Net_1_0
public TargetRuntime Net_1_1
public TargetRuntime Net_2_0
public TargetRuntime Net_4_0
}
internal Mono.Cecil.TokenType : Enum {
public UInt32 value__
public TokenType Module
public TokenType TypeRef
public TokenType TypeDef
public TokenType Field
public TokenType Method
public TokenType Param
public TokenType InterfaceImpl
public TokenType MemberRef
public TokenType CustomAttribute
public TokenType Permission
public TokenType Signature
public TokenType Event
public TokenType Property
public TokenType ModuleRef
public TokenType TypeSpec
public TokenType Assembly
public TokenType AssemblyRef
public TokenType File
public TokenType ExportedType
public TokenType ManifestResource
public TokenType GenericParam
public TokenType MethodSpec
public TokenType GenericParamConstraint
public TokenType Document
public TokenType MethodDebugInformation
public TokenType LocalScope
public TokenType LocalVariable
public TokenType LocalConstant
public TokenType ImportScope
public TokenType StateMachineMethod
public TokenType CustomDebugInformation
public TokenType String
}
internal Mono.Cecil.TypeAttributes : Enum {
public UInt32 value__
public TypeAttributes VisibilityMask
public TypeAttributes NotPublic
public TypeAttributes Public
public TypeAttributes NestedPublic
public TypeAttributes NestedPrivate
public TypeAttributes NestedFamily
public TypeAttributes NestedAssembly
public TypeAttributes NestedFamANDAssem
public TypeAttributes NestedFamORAssem
public TypeAttributes LayoutMask
public TypeAttributes AutoLayout
public TypeAttributes SequentialLayout
public TypeAttributes ExplicitLayout
public TypeAttributes ClassSemanticMask
public TypeAttributes Class
public TypeAttributes Interface
public TypeAttributes Abstract
public TypeAttributes Sealed
public TypeAttributes SpecialName
public TypeAttributes Import
public TypeAttributes Serializable
public TypeAttributes WindowsRuntime
public TypeAttributes StringFormatMask
public TypeAttributes AnsiClass
public TypeAttributes UnicodeClass
public TypeAttributes AutoClass
public TypeAttributes BeforeFieldInit
public TypeAttributes RTSpecialName
public TypeAttributes HasSecurity
public TypeAttributes Forwarder
}
internal Mono.Cecil.TypeComparisonMode : Enum {
public int value__
public TypeComparisonMode Exact
public TypeComparisonMode SignatureOnly
public TypeComparisonMode SignatureOnlyLoose
}
internal Mono.Cecil.TypeDefinition : TypeReference {
private UInt32 attributes
private TypeReference base_type
internal Range fields_range
internal Range methods_range
private short packing_size
private int class_size
private InterfaceImplementationCollection interfaces
private Collection`1<TypeDefinition> nested_types
private Collection`1<MethodDefinition> methods
private Collection`1<FieldDefinition> fields
private Collection`1<EventDefinition> events
private Collection`1<PropertyDefinition> properties
private Collection`1<CustomAttribute> custom_attributes
private Collection`1<SecurityDeclaration> security_declarations
public TypeAttributes Attributes
public TypeReference BaseType
public string Name
public bool HasLayoutInfo
public short PackingSize
public int ClassSize
public bool HasInterfaces
public Collection`1<InterfaceImplementation> Interfaces
public bool HasNestedTypes
public Collection`1<TypeDefinition> NestedTypes
public bool HasMethods
public Collection`1<MethodDefinition> Methods
public bool HasFields
public Collection`1<FieldDefinition> Fields
public bool HasEvents
public Collection`1<EventDefinition> Events
public bool HasProperties
public Collection`1<PropertyDefinition> Properties
public bool HasSecurityDeclarations
public Collection`1<SecurityDeclaration> SecurityDeclarations
public bool HasCustomAttributes
public Collection`1<CustomAttribute> CustomAttributes
public bool HasGenericParameters
public Collection`1<GenericParameter> GenericParameters
public bool IsNotPublic
public bool IsPublic
public bool IsNestedPublic
public bool IsNestedPrivate
public bool IsNestedFamily
public bool IsNestedAssembly
public bool IsNestedFamilyAndAssembly
public bool IsNestedFamilyOrAssembly
public bool IsAutoLayout
public bool IsSequentialLayout
public bool IsExplicitLayout
public bool IsClass
public bool IsInterface
public bool IsAbstract
public bool IsSealed
public bool IsSpecialName
public bool IsImport
public bool IsSerializable
public bool IsWindowsRuntime
public bool IsAnsiClass
public bool IsUnicodeClass
public bool IsAutoClass
public bool IsBeforeFieldInit
public bool IsRuntimeSpecialName
public bool HasSecurity
public bool IsEnum
public bool IsValueType
public bool IsPrimitive
public MetadataType MetadataType
public bool IsDefinition
public TypeDefinition DeclaringType
internal TypeDefinitionProjection WindowsRuntimeProjection
public TypeAttributes get_Attributes()
public void set_Attributes(TypeAttributes value)
public TypeReference get_BaseType()
public void set_BaseType(TypeReference value)
public string get_Name()
public void set_Name(string value)
private void ResolveLayout()
public bool get_HasLayoutInfo()
public short get_PackingSize()
public void set_PackingSize(short value)
public int get_ClassSize()
public void set_ClassSize(int value)
public bool get_HasInterfaces()
public Collection`1<InterfaceImplementation> get_Interfaces()
public bool get_HasNestedTypes()
public Collection`1<TypeDefinition> get_NestedTypes()
public bool get_HasMethods()
public Collection`1<MethodDefinition> get_Methods()
public bool get_HasFields()
public Collection`1<FieldDefinition> get_Fields()
public bool get_HasEvents()
public Collection`1<EventDefinition> get_Events()
public bool get_HasProperties()
public Collection`1<PropertyDefinition> get_Properties()
public bool get_HasSecurityDeclarations()
public Collection`1<SecurityDeclaration> get_SecurityDeclarations()
public bool get_HasCustomAttributes()
public Collection`1<CustomAttribute> get_CustomAttributes()
public bool get_HasGenericParameters()
public Collection`1<GenericParameter> get_GenericParameters()
public bool get_IsNotPublic()
public void set_IsNotPublic(bool value)
public bool get_IsPublic()
public void set_IsPublic(bool value)
public bool get_IsNestedPublic()
public void set_IsNestedPublic(bool value)
public bool get_IsNestedPrivate()
public void set_IsNestedPrivate(bool value)
public bool get_IsNestedFamily()
public void set_IsNestedFamily(bool value)
public bool get_IsNestedAssembly()
public void set_IsNestedAssembly(bool value)
public bool get_IsNestedFamilyAndAssembly()
public void set_IsNestedFamilyAndAssembly(bool value)
public bool get_IsNestedFamilyOrAssembly()
public void set_IsNestedFamilyOrAssembly(bool value)
public bool get_IsAutoLayout()
public void set_IsAutoLayout(bool value)
public bool get_IsSequentialLayout()
public void set_IsSequentialLayout(bool value)
public bool get_IsExplicitLayout()
public void set_IsExplicitLayout(bool value)
public bool get_IsClass()
public void set_IsClass(bool value)
public bool get_IsInterface()
public void set_IsInterface(bool value)
public bool get_IsAbstract()
public void set_IsAbstract(bool value)
public bool get_IsSealed()
public void set_IsSealed(bool value)
public bool get_IsSpecialName()
public void set_IsSpecialName(bool value)
public bool get_IsImport()
public void set_IsImport(bool value)
public bool get_IsSerializable()
public void set_IsSerializable(bool value)
public bool get_IsWindowsRuntime()
public void set_IsWindowsRuntime(bool value)
public bool get_IsAnsiClass()
public void set_IsAnsiClass(bool value)
public bool get_IsUnicodeClass()
public void set_IsUnicodeClass(bool value)
public bool get_IsAutoClass()
public void set_IsAutoClass(bool value)
public bool get_IsBeforeFieldInit()
public void set_IsBeforeFieldInit(bool value)
public bool get_IsRuntimeSpecialName()
public void set_IsRuntimeSpecialName(bool value)
public bool get_HasSecurity()
public void set_HasSecurity(bool value)
public bool get_IsEnum()
public bool get_IsValueType()
public void set_IsValueType(bool value)
public bool get_IsPrimitive()
public MetadataType get_MetadataType()
public bool get_IsDefinition()
public TypeDefinition get_DeclaringType()
public void set_DeclaringType(TypeDefinition value)
internal TypeDefinitionProjection get_WindowsRuntimeProjection()
internal void set_WindowsRuntimeProjection(TypeDefinitionProjection value)
public void .ctor(string namespace, string name, TypeAttributes attributes)
public void .ctor(string namespace, string name, TypeAttributes attributes, TypeReference baseType)
protected void ClearFullName()
public TypeDefinition Resolve()
}
internal Mono.Cecil.TypeDefinitionCollection : Collection`1<TypeDefinition> {
private ModuleDefinition container
private Dictionary`2<Row`2<string, string>, TypeDefinition> name_cache
internal void .ctor(ModuleDefinition container)
internal void .ctor(ModuleDefinition container, int capacity)
protected void OnAdd(TypeDefinition item, int index)
protected void OnSet(TypeDefinition item, int index)
protected void OnInsert(TypeDefinition item, int index)
protected void OnRemove(TypeDefinition item, int index)
protected void OnClear()
private void Attach(TypeDefinition type)
private void Detach(TypeDefinition type)
public TypeDefinition GetType(string fullname)
public TypeDefinition GetType(string namespace, string name)
}
internal Mono.Cecil.TypeDefinitionProjection : object {
public TypeAttributes Attributes
public string Name
public TypeDefinitionTreatment Treatment
public Collection`1<MethodDefinition> RedirectedMethods
public Collection`1<KeyValuePair`2<InterfaceImplementation, InterfaceImplementation>> RedirectedInterfaces
public void .ctor(TypeDefinition type, TypeDefinitionTreatment treatment, Collection`1<MethodDefinition> redirectedMethods, Collection`1<KeyValuePair`2<InterfaceImplementation, InterfaceImplementation>> redirectedInterfaces)
}
internal Mono.Cecil.TypeDefinitionTreatment : Enum {
public int value__
public TypeDefinitionTreatment None
public TypeDefinitionTreatment KindMask
public TypeDefinitionTreatment NormalType
public TypeDefinitionTreatment NormalAttribute
public TypeDefinitionTreatment UnmangleWindowsRuntimeName
public TypeDefinitionTreatment PrefixWindowsRuntimeName
public TypeDefinitionTreatment RedirectToClrType
public TypeDefinitionTreatment RedirectToClrAttribute
public TypeDefinitionTreatment RedirectImplementedMethods
public TypeDefinitionTreatment Abstract
public TypeDefinitionTreatment Internal
}
internal Mono.Cecil.TypeDefTable : MetadataTable`1<Row`6<TypeAttributes, UInt32, UInt32, UInt32, UInt32, UInt32>> {
public void Write(TableHeapBuffer buffer)
}
internal Mono.Cecil.TypeParser : object {
private string fullname
private int length
private int position
private void .ctor(string fullname)
private Type ParseType(bool fq_name)
private bool TryGetArity(Type type)
private bool TryGetArity(string name, Int32& arity)
private bool ParseInt32(string value, Int32& result)
private void TryAddArity(string name, Int32& arity)
private string ParsePart()
private bool IsDelimiter(char chr)
private void TryParseWhiteSpace()
private String[] ParseNestedNames()
private bool TryParse(char chr)
private void Add(T[]& array, T item)
private Int32[] ParseSpecs()
private Type[] ParseGenericArguments(int arity)
private string ParseAssemblyName()
public TypeReference ParseType(ModuleDefinition module, string fullname, bool typeDefinitionOnly)
private TypeReference GetTypeReference(ModuleDefinition module, Type type_info, bool type_def_only)
private TypeReference CreateSpecs(TypeReference type, Type type_info)
private TypeReference TryCreateGenericInstanceType(TypeReference type, Type type_info)
public void SplitFullName(string fullname, String& namespace, String& name)
private TypeReference CreateReference(Type type_info, ModuleDefinition module, IMetadataScope scope)
private void AdjustGenericParameters(TypeReference type)
private IMetadataScope GetMetadataScope(ModuleDefinition module, Type type_info)
private bool TryGetDefinition(ModuleDefinition module, Type type_info, TypeReference& type)
private bool TryCurrentModule(ModuleDefinition module, Type type_info)
public string ToParseable(TypeReference type, bool top_level)
private void AppendNamePart(string part, StringBuilder name)
private void AppendType(TypeReference type, StringBuilder name, bool fq_name, bool top_level)
private string GetScopeFullName(TypeReference type)
private void AppendTypeSpecification(TypeSpecification type, StringBuilder name)
private bool RequiresFullyQualifiedName(TypeReference type, bool top_level)
}
internal Mono.Cecil.TypeReference : MemberReference {
private string namespace
private bool value_type
internal IMetadataScope scope
internal ModuleDefinition module
internal ElementType etype
private string fullname
protected Collection`1<GenericParameter> generic_parameters
public string Name
public string Namespace
public bool IsValueType
public ModuleDefinition Module
internal TypeReferenceProjection WindowsRuntimeProjection
private IGenericParameterProvider Mono.Cecil.IGenericContext.Type
private IGenericParameterProvider Mono.Cecil.IGenericContext.Method
private GenericParameterType Mono.Cecil.IGenericParameterProvider.GenericParameterType
public bool HasGenericParameters
public Collection`1<GenericParameter> GenericParameters
public IMetadataScope Scope
public bool IsNested
public TypeReference DeclaringType
public string FullName
public bool IsByReference
public bool IsPointer
public bool IsSentinel
public bool IsArray
public bool IsGenericParameter
public bool IsGenericInstance
public bool IsRequiredModifier
public bool IsOptionalModifier
public bool IsPinned
public bool IsFunctionPointer
public bool IsPrimitive
public MetadataType MetadataType
public string get_Name()
public void set_Name(string value)
public string get_Namespace()
public void set_Namespace(string value)
public bool get_IsValueType()
public void set_IsValueType(bool value)
public ModuleDefinition get_Module()
internal TypeReferenceProjection get_WindowsRuntimeProjection()
internal void set_WindowsRuntimeProjection(TypeReferenceProjection value)
private IGenericParameterProvider Mono.Cecil.IGenericContext.get_Type()
private IGenericParameterProvider Mono.Cecil.IGenericContext.get_Method()
private GenericParameterType Mono.Cecil.IGenericParameterProvider.get_GenericParameterType()
public bool get_HasGenericParameters()
public Collection`1<GenericParameter> get_GenericParameters()
public IMetadataScope get_Scope()
public void set_Scope(IMetadataScope value)
public bool get_IsNested()
public TypeReference get_DeclaringType()
public void set_DeclaringType(TypeReference value)
public string get_FullName()
public bool get_IsByReference()
public bool get_IsPointer()
public bool get_IsSentinel()
public bool get_IsArray()
public bool get_IsGenericParameter()
public bool get_IsGenericInstance()
public bool get_IsRequiredModifier()
public bool get_IsOptionalModifier()
public bool get_IsPinned()
public bool get_IsFunctionPointer()
public bool get_IsPrimitive()
public MetadataType get_MetadataType()
protected void .ctor(string namespace, string name)
public void .ctor(string namespace, string name, ModuleDefinition module, IMetadataScope scope)
public void .ctor(string namespace, string name, ModuleDefinition module, IMetadataScope scope, bool valueType)
protected void ClearFullName()
public TypeReference GetElementType()
protected IMemberDefinition ResolveDefinition()
public TypeDefinition Resolve()
}
internal Mono.Cecil.TypeReferenceEqualityComparer : EqualityComparer`1<TypeReference> {
public bool Equals(TypeReference x, TypeReference y)
public int GetHashCode(TypeReference obj)
public bool AreEqual(TypeReference a, TypeReference b, TypeComparisonMode comparisonMode)
private bool AreEqual(GenericParameter a, GenericParameter b, TypeComparisonMode comparisonMode)
private bool AreEqual(GenericInstanceType a, GenericInstanceType b, TypeComparisonMode comparisonMode)
public int GetHashCodeFor(TypeReference obj)
}
internal Mono.Cecil.TypeReferenceProjection : object {
public string Name
public string Namespace
public IMetadataScope Scope
public TypeReferenceTreatment Treatment
public void .ctor(TypeReference type, TypeReferenceTreatment treatment)
}
internal Mono.Cecil.TypeReferenceTreatment : Enum {
public int value__
public TypeReferenceTreatment None
public TypeReferenceTreatment SystemDelegate
public TypeReferenceTreatment SystemAttribute
public TypeReferenceTreatment UseProjectionInfo
}
internal Mono.Cecil.TypeRefTable : MetadataTable`1<Row`3<UInt32, UInt32, UInt32>> {
public void Write(TableHeapBuffer buffer)
}
internal Mono.Cecil.TypeResolver : object {
private IGenericInstance _typeDefinitionContext
private IGenericInstance _methodDefinitionContext
public TypeResolver For(TypeReference typeReference)
public TypeResolver For(TypeReference typeReference, MethodReference methodReference)
public void .ctor(GenericInstanceType typeDefinitionContext)
public void .ctor(GenericInstanceMethod methodDefinitionContext)
public void .ctor(GenericInstanceType typeDefinitionContext, GenericInstanceMethod methodDefinitionContext)
public MethodReference Resolve(MethodReference method)
public FieldReference Resolve(FieldReference field)
public TypeReference ResolveReturnType(MethodReference method)
public TypeReference ResolveParameterType(MethodReference method, ParameterReference parameter)
public TypeReference ResolveVariableType(MethodReference method, VariableReference variable)
public TypeReference ResolveFieldType(FieldReference field)
public TypeReference Resolve(TypeReference typeReference)
public TypeReference Resolve(TypeReference typeReference, bool includeTypeDefinitions)
internal TypeResolver Nested(GenericInstanceMethod genericInstanceMethod)
private TypeReference ResolveGenericParameter(GenericParameter genericParameter)
private TypeReference HandleOwnerlessInvalidILCode(GenericParameter genericParameter)
private bool IsDummy()
}
internal Mono.Cecil.TypeSpecification : TypeReference {
private TypeReference element_type
public TypeReference ElementType
public string Name
public string Namespace
public IMetadataScope Scope
public ModuleDefinition Module
public string FullName
public bool ContainsGenericParameter
public MetadataType MetadataType
public TypeReference get_ElementType()
public string get_Name()
public void set_Name(string value)
public string get_Namespace()
public void set_Namespace(string value)
public IMetadataScope get_Scope()
public void set_Scope(IMetadataScope value)
public ModuleDefinition get_Module()
public string get_FullName()
public bool get_ContainsGenericParameter()
public MetadataType get_MetadataType()
internal void .ctor(TypeReference type)
public TypeReference GetElementType()
}
internal Mono.Cecil.TypeSpecTable : MetadataTable`1<UInt32> {
public void Write(TableHeapBuffer buffer)
}
internal Mono.Cecil.TypeSystem : object {
private ModuleDefinition module
private TypeReference type_object
private TypeReference type_void
private TypeReference type_bool
private TypeReference type_char
private TypeReference type_sbyte
private TypeReference type_byte
private TypeReference type_int16
private TypeReference type_uint16
private TypeReference type_int32
private TypeReference type_uint32
private TypeReference type_int64
private TypeReference type_uint64
private TypeReference type_single
private TypeReference type_double
private TypeReference type_intptr
private TypeReference type_uintptr
private TypeReference type_string
private TypeReference type_typedref
public IMetadataScope Corlib
public IMetadataScope CoreLibrary
public TypeReference Object
public TypeReference Void
public TypeReference Boolean
public TypeReference Char
public TypeReference SByte
public TypeReference Byte
public TypeReference Int16
public TypeReference UInt16
public TypeReference Int32
public TypeReference UInt32
public TypeReference Int64
public TypeReference UInt64
public TypeReference Single
public TypeReference Double
public TypeReference IntPtr
public TypeReference UIntPtr
public TypeReference String
public TypeReference TypedReference
private void .ctor(ModuleDefinition module)
internal TypeSystem CreateTypeSystem(ModuleDefinition module)
internal TypeReference LookupType(string namespace, string name)
private TypeReference LookupSystemType(TypeReference& reference, string name, ElementType element_type)
private TypeReference LookupSystemValueType(TypeReference& typeRef, string name, ElementType element_type)
public IMetadataScope get_Corlib()
public IMetadataScope get_CoreLibrary()
public TypeReference get_Object()
public TypeReference get_Void()
public TypeReference get_Boolean()
public TypeReference get_Char()
public TypeReference get_SByte()
public TypeReference get_Byte()
public TypeReference get_Int16()
public TypeReference get_UInt16()
public TypeReference get_Int32()
public TypeReference get_UInt32()
public TypeReference get_Int64()
public TypeReference get_UInt64()
public TypeReference get_Single()
public TypeReference get_Double()
public TypeReference get_IntPtr()
public TypeReference get_UIntPtr()
public TypeReference get_String()
public TypeReference get_TypedReference()
}
internal Mono.Cecil.VariantType : Enum {
public int value__
public VariantType None
public VariantType I2
public VariantType I4
public VariantType R4
public VariantType R8
public VariantType CY
public VariantType Date
public VariantType BStr
public VariantType Dispatch
public VariantType Error
public VariantType Bool
public VariantType Variant
public VariantType Unknown
public VariantType Decimal
public VariantType I1
public VariantType UI1
public VariantType UI2
public VariantType UI4
public VariantType I8
public VariantType UI8
public VariantType Int
public VariantType UInt
}
internal Mono.Cecil.WindowsRuntimeProjections : object {
private Version version
private Byte[] contract_pk_token
private Byte[] contract_pk
private Dictionary`2<string, ProjectionInfo> projections
private ModuleDefinition module
private Version corlib_version
private AssemblyNameReference[] virtual_references
private Dictionary`2<string, ProjectionInfo> Projections
private AssemblyNameReference[] VirtualReferences
private Dictionary`2<string, ProjectionInfo> get_Projections()
private AssemblyNameReference[] get_VirtualReferences()
public void .ctor(ModuleDefinition module)
public void Project(TypeDefinition type)
private TypeDefinitionTreatment GetWellKnownTypeDefinitionTreatment(TypeDefinition type)
private TypeDefinitionTreatment GenerateRedirectionInformation(TypeDefinition type, Collection`1& redirectedMethods, Collection`1& redirectedInterfaces)
private void CollectImplementedInterfaces(TypeReference type, HashSet`1<TypeReference> results)
private void RedirectInterfaceMethods(TypeReference interfaceType, Collection`1<MethodDefinition> redirectedMethods)
private bool IsRedirectedType(TypeReference type)
private bool NeedsWindowsRuntimePrefix(TypeDefinition type)
public bool IsClrImplementationType(TypeDefinition type)
public void ApplyProjection(TypeDefinition type, TypeDefinitionProjection projection)
public TypeDefinitionProjection RemoveProjection(TypeDefinition type)
public void Project(TypeReference type)
private TypeReferenceTreatment GetSpecialTypeReferenceTreatment(TypeReference type)
private bool IsAttribute(TypeReference type)
private bool IsEnum(TypeReference type)
public void ApplyProjection(TypeReference type, TypeReferenceProjection projection)
public TypeReferenceProjection RemoveProjection(TypeReference type)
public void Project(MethodDefinition method)
private MethodDefinitionTreatment GetMethodDefinitionTreatmentFromCustomAttributes(MethodDefinition method)
public void ApplyProjection(MethodDefinition method, MethodDefinitionProjection projection)
public MethodDefinitionProjection RemoveProjection(MethodDefinition method)
public void Project(FieldDefinition field)
public void ApplyProjection(FieldDefinition field, FieldDefinitionProjection projection)
public FieldDefinitionProjection RemoveProjection(FieldDefinition field)
private bool ImplementsRedirectedInterface(MemberReference member)
public void AddVirtualReferences(Collection`1<AssemblyNameReference> references)
public void RemoveVirtualReferences(Collection`1<AssemblyNameReference> references)
private AssemblyNameReference[] GetAssemblyReferences(AssemblyNameReference corlib)
private AssemblyNameReference GetCoreLibrary(Collection`1<AssemblyNameReference> references)
private AssemblyNameReference GetAssemblyReference(string name)
public void Project(ICustomAttributeProvider owner, Collection`1<CustomAttribute> owner_attributes, CustomAttribute attribute)
private bool IsWindowsAttributeUsageAttribute(ICustomAttributeProvider owner, CustomAttribute attribute)
private bool HasAttribute(Collection`1<CustomAttribute> attributes, string namespace, string name)
public void ApplyProjection(CustomAttribute attribute, CustomAttributeValueProjection projection)
public CustomAttributeValueProjection RemoveProjection(CustomAttribute attribute)
}
internal Mono.Cecil.WriterParameters : object {
private Nullable`1<UInt32> timestamp
private Stream symbol_stream
private ISymbolWriterProvider symbol_writer_provider
private bool write_symbols
private Byte[] key_blob
private string key_container
private StrongNameKeyPair key_pair
private bool <DeterministicMvid>k__BackingField
public Nullable`1<UInt32> Timestamp
public Stream SymbolStream
public ISymbolWriterProvider SymbolWriterProvider
public bool WriteSymbols
public bool HasStrongNameKey
public Byte[] StrongNameKeyBlob
public string StrongNameKeyContainer
public StrongNameKeyPair StrongNameKeyPair
public bool DeterministicMvid
public Nullable`1<UInt32> get_Timestamp()
public void set_Timestamp(Nullable`1<UInt32> value)
public Stream get_SymbolStream()
public void set_SymbolStream(Stream value)
public ISymbolWriterProvider get_SymbolWriterProvider()
public void set_SymbolWriterProvider(ISymbolWriterProvider value)
public bool get_WriteSymbols()
public void set_WriteSymbols(bool value)
public bool get_HasStrongNameKey()
public Byte[] get_StrongNameKeyBlob()
public void set_StrongNameKeyBlob(Byte[] value)
public string get_StrongNameKeyContainer()
public void set_StrongNameKeyContainer(string value)
public StrongNameKeyPair get_StrongNameKeyPair()
public void set_StrongNameKeyPair(StrongNameKeyPair value)
public bool get_DeterministicMvid()
public void set_DeterministicMvid(bool value)
}
internal Mono.Collections.Generic.Collection`1 : object {
internal T[] items
internal int size
private int version
public int Count
public T Item
public int Capacity
private bool System.Collections.Generic.ICollection<T>.IsReadOnly
private bool System.Collections.IList.IsFixedSize
private bool System.Collections.IList.IsReadOnly
private object System.Collections.IList.Item
private int System.Collections.ICollection.Count
private bool System.Collections.ICollection.IsSynchronized
private object System.Collections.ICollection.SyncRoot
public int get_Count()
public T get_Item(int index)
public void set_Item(int index, T value)
public int get_Capacity()
public void set_Capacity(int value)
private bool System.Collections.Generic.ICollection<T>.get_IsReadOnly()
private bool System.Collections.IList.get_IsFixedSize()
private bool System.Collections.IList.get_IsReadOnly()
private object System.Collections.IList.get_Item(int index)
private void System.Collections.IList.set_Item(int index, object value)
private int System.Collections.ICollection.get_Count()
private bool System.Collections.ICollection.get_IsSynchronized()
private object System.Collections.ICollection.get_SyncRoot()
public void .ctor(int capacity)
public void .ctor(ICollection`1<T> items)
public void Add(T item)
public bool Contains(T item)
public int IndexOf(T item)
public void Insert(int index, T item)
public void RemoveAt(int index)
public bool Remove(T item)
public void Clear()
public void CopyTo(T[] array, int arrayIndex)
public T[] ToArray()
private void CheckIndex(int index)
private void Shift(int start, int delta)
protected void OnAdd(T item, int index)
protected void OnInsert(T item, int index)
protected void OnSet(T item, int index)
protected void OnRemove(T item, int index)
protected void OnClear()
internal void Grow(int desired)
protected void Resize(int new_size)
private int System.Collections.IList.Add(object value)
private void System.Collections.IList.Clear()
private bool System.Collections.IList.Contains(object value)
private int System.Collections.IList.IndexOf(object value)
private void System.Collections.IList.Insert(int index, object value)
private void System.Collections.IList.Remove(object value)
private void System.Collections.IList.RemoveAt(int index)
private void System.Collections.ICollection.CopyTo(Array array, int index)
public Enumerator<T> GetEnumerator()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
private IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator()
}
internal Mono.Collections.Generic.ReadOnlyCollection`1 : Collection`1<T> {
private ReadOnlyCollection`1<T> empty
public ReadOnlyCollection`1<T> Empty
private bool System.Collections.Generic.ICollection<T>.IsReadOnly
private bool System.Collections.IList.IsFixedSize
private bool System.Collections.IList.IsReadOnly
public ReadOnlyCollection`1<T> get_Empty()
private bool System.Collections.Generic.ICollection<T>.get_IsReadOnly()
private bool System.Collections.IList.get_IsFixedSize()
private bool System.Collections.IList.get_IsReadOnly()
public void .ctor(T[] array)
public void .ctor(Collection`1<T> collection)
private void Initialize(T[] items, int size)
internal void Grow(int desired)
protected void OnAdd(T item, int index)
protected void OnClear()
protected void OnInsert(T item, int index)
protected void OnRemove(T item, int index)
protected void OnSet(T item, int index)
}
internal Mono.CompilerServices.SymbolWriter.AnonymousScopeEntry : object {
public int ID
private List`1<CapturedVariable> captured_vars
private List`1<CapturedScope> captured_scopes
public CapturedVariable[] CapturedVariables
public CapturedScope[] CapturedScopes
public void .ctor(int id)
internal void .ctor(MyBinaryReader reader)
internal void AddCapturedVariable(string name, string captured_name, CapturedKind kind)
public CapturedVariable[] get_CapturedVariables()
internal void AddCapturedScope(int scope, string captured_name)
public CapturedScope[] get_CapturedScopes()
internal void Write(MyBinaryWriter bw)
public string ToString()
}
internal Mono.CompilerServices.SymbolWriter.CapturedScope : ValueType {
public int Scope
public string CapturedName
public void .ctor(int scope, string captured_name)
internal void .ctor(MyBinaryReader reader)
internal void Write(MyBinaryWriter bw)
public string ToString()
}
internal Mono.CompilerServices.SymbolWriter.CapturedVariable : ValueType {
public string Name
public string CapturedName
public CapturedKind Kind
public void .ctor(string name, string captured_name, CapturedKind kind)
internal void .ctor(MyBinaryReader reader)
internal void Write(MyBinaryWriter bw)
public string ToString()
}
internal Mono.CompilerServices.SymbolWriter.CodeBlockEntry : object {
public int Index
public int Parent
public Type BlockType
public int StartOffset
public int EndOffset
public void .ctor(int index, int parent, Type type, int start_offset)
internal void .ctor(int index, MyBinaryReader reader)
public void Close(int end_offset)
internal void Write(MyBinaryWriter bw)
public string ToString()
}
internal Mono.CompilerServices.SymbolWriter.CompileUnitEntry : object {
public int Index
private int DataOffset
private MonoSymbolFile file
private SourceFileEntry source
private List`1<SourceFileEntry> include_files
private List`1<NamespaceEntry> namespaces
private bool creating
public int Size
private CompileUnitEntry Mono.CompilerServices.SymbolWriter.ICompileUnit.Entry
public SourceFileEntry SourceFile
public NamespaceEntry[] Namespaces
public SourceFileEntry[] IncludeFiles
public int get_Size()
private CompileUnitEntry Mono.CompilerServices.SymbolWriter.ICompileUnit.get_Entry()
public void .ctor(MonoSymbolFile file, SourceFileEntry source)
public void AddFile(SourceFileEntry file)
public SourceFileEntry get_SourceFile()
public int DefineNamespace(string name, String[] using_clauses, int parent)
internal void WriteData(MyBinaryWriter bw)
internal void Write(BinaryWriter bw)
internal void .ctor(MonoSymbolFile file, MyBinaryReader reader)
public void ReadAll()
private void ReadData()
public NamespaceEntry[] get_Namespaces()
public SourceFileEntry[] get_IncludeFiles()
}
internal Mono.CompilerServices.SymbolWriter.ICompileUnit {
public CompileUnitEntry Entry
public CompileUnitEntry get_Entry()
}
internal Mono.CompilerServices.SymbolWriter.IMethodDef {
public string Name
public int Token
public string get_Name()
public int get_Token()
}
internal Mono.CompilerServices.SymbolWriter.ISourceFile {
public SourceFileEntry Entry
public SourceFileEntry get_Entry()
}
internal Mono.CompilerServices.SymbolWriter.LineNumberEntry : object {
public int Row
public int Column
public int EndRow
public int EndColumn
public int File
public int Offset
public bool IsHidden
public LineNumberEntry Null
public void .ctor(int file, int row, int column, int offset)
public void .ctor(int file, int row, int offset)
public void .ctor(int file, int row, int column, int offset, bool is_hidden)
public void .ctor(int file, int row, int column, int end_row, int end_column, int offset, bool is_hidden)
public string ToString()
}
internal Mono.CompilerServices.SymbolWriter.LineNumberTable : object {
protected LineNumberEntry[] _line_numbers
public int LineBase
public int LineRange
public byte OpcodeBase
public int MaxAddressIncrement
public int Default_LineBase
public int Default_LineRange
public byte Default_OpcodeBase
public byte DW_LNS_copy
public byte DW_LNS_advance_pc
public byte DW_LNS_advance_line
public byte DW_LNS_set_file
public byte DW_LNS_const_add_pc
public byte DW_LNE_end_sequence
public byte DW_LNE_MONO_negate_is_hidden
internal byte DW_LNE_MONO__extensions_start
internal byte DW_LNE_MONO__extensions_end
public LineNumberEntry[] LineNumbers
public LineNumberEntry[] get_LineNumbers()
protected void .ctor(MonoSymbolFile file)
internal void .ctor(MonoSymbolFile file, LineNumberEntry[] lines)
internal void Write(MonoSymbolFile file, MyBinaryWriter bw, bool hasColumnsInfo, bool hasEndInfo)
internal LineNumberTable Read(MonoSymbolFile file, MyBinaryReader br, bool readColumnsInfo, bool readEndInfo)
private void DoRead(MonoSymbolFile file, MyBinaryReader br, bool includesColumns, bool includesEnds)
public bool GetMethodBounds(LineNumberEntry& start, LineNumberEntry& end)
}
internal Mono.CompilerServices.SymbolWriter.LocalVariableEntry : ValueType {
public int Index
public string Name
public int BlockIndex
public void .ctor(int index, string name, int block)
internal void .ctor(MonoSymbolFile file, MyBinaryReader reader)
internal void Write(MonoSymbolFile file, MyBinaryWriter bw)
public string ToString()
}
internal Mono.CompilerServices.SymbolWriter.MethodEntry : object {
public int CompileUnitIndex
public int Token
public int NamespaceID
private int DataOffset
private int LocalVariableTableOffset
private int LineNumberTableOffset
private int CodeBlockTableOffset
private int ScopeVariableTableOffset
private int RealNameOffset
private Flags flags
private int index
public CompileUnitEntry CompileUnit
private LocalVariableEntry[] locals
private CodeBlockEntry[] code_blocks
private ScopeVariable[] scope_vars
private LineNumberTable lnt
private string real_name
public MonoSymbolFile SymbolFile
public int Size
public Flags MethodFlags
public int Index
public Flags get_MethodFlags()
public int get_Index()
public void set_Index(int value)
internal void .ctor(MonoSymbolFile file, MyBinaryReader reader, int index)
internal void .ctor(MonoSymbolFile file, CompileUnitEntry comp_unit, int token, ScopeVariable[] scope_vars, LocalVariableEntry[] locals, LineNumberEntry[] lines, CodeBlockEntry[] code_blocks, string real_name, Flags flags, int namespace_id)
private void CheckLineNumberTable(LineNumberEntry[] line_numbers)
internal void Write(MyBinaryWriter bw)
internal void WriteData(MonoSymbolFile file, MyBinaryWriter bw)
public void ReadAll()
public LineNumberTable GetLineNumberTable()
public LocalVariableEntry[] GetLocals()
public CodeBlockEntry[] GetCodeBlocks()
public ScopeVariable[] GetScopeVariables()
public string GetRealName()
public int CompareTo(object obj)
public string ToString()
}
internal Mono.CompilerServices.SymbolWriter.MonoSymbolFile : object {
private List`1<MethodEntry> methods
private List`1<SourceFileEntry> sources
private List`1<CompileUnitEntry> comp_units
private Dictionary`2<int, AnonymousScopeEntry> anonymous_scopes
private OffsetTable ot
private int last_type_index
private int last_method_index
private int last_namespace_index
public int MajorVersion
public int MinorVersion
public int NumLineNumbers
private MyBinaryReader reader
private Dictionary`2<int, SourceFileEntry> source_file_hash
private Dictionary`2<int, CompileUnitEntry> compile_unit_hash
private List`1<MethodEntry> method_list
private Dictionary`2<int, MethodEntry> method_token_hash
private Dictionary`2<string, int> source_name_hash
private Guid guid
internal int LineNumberCount
internal int LocalCount
internal int StringSize
internal int LineNumberSize
internal int ExtendedLineNumberSize
public int CompileUnitCount
public int SourceCount
public int MethodCount
public int TypeCount
public int AnonymousScopeCount
public int NamespaceCount
public Guid Guid
public OffsetTable OffsetTable
public SourceFileEntry[] Sources
public CompileUnitEntry[] CompileUnits
public MethodEntry[] Methods
internal MyBinaryReader BinaryReader
public int AddSource(SourceFileEntry source)
public int AddCompileUnit(CompileUnitEntry entry)
public void AddMethod(MethodEntry entry)
public MethodEntry DefineMethod(CompileUnitEntry comp_unit, int token, ScopeVariable[] scope_vars, LocalVariableEntry[] locals, LineNumberEntry[] lines, CodeBlockEntry[] code_blocks, string real_name, Flags flags, int namespace_id)
internal void DefineAnonymousScope(int id)
internal void DefineCapturedVariable(int scope_id, string name, string captured_name, CapturedKind kind)
internal void DefineCapturedScope(int scope_id, int id, string captured_name)
internal int GetNextTypeIndex()
internal int GetNextMethodIndex()
internal int GetNextNamespaceIndex()
private void Write(MyBinaryWriter bw, Guid guid)
public void CreateSymbolFile(Guid guid, FileStream fs)
private void .ctor(Stream stream)
public MonoSymbolFile ReadSymbolFile(Assembly assembly)
public MonoSymbolFile ReadSymbolFile(string mdbFilename)
public MonoSymbolFile ReadSymbolFile(string mdbFilename, Guid assemblyGuid)
public MonoSymbolFile ReadSymbolFile(Stream stream)
public int get_CompileUnitCount()
public int get_SourceCount()
public int get_MethodCount()
public int get_TypeCount()
public int get_AnonymousScopeCount()
public int get_NamespaceCount()
public Guid get_Guid()
public OffsetTable get_OffsetTable()
public SourceFileEntry GetSourceFile(int index)
public SourceFileEntry[] get_Sources()
public CompileUnitEntry GetCompileUnit(int index)
public CompileUnitEntry[] get_CompileUnits()
private void read_methods()
public MethodEntry GetMethodByToken(int token)
public MethodEntry GetMethod(int index)
public MethodEntry[] get_Methods()
public int FindSource(string file_name)
public AnonymousScopeEntry GetAnonymousScope(int id)
internal MyBinaryReader get_BinaryReader()
public void Dispose()
protected void Dispose(bool disposing)
}
internal Mono.CompilerServices.SymbolWriter.MonoSymbolFileException : Exception {
public void .ctor(string message, Object[] args)
public void .ctor(string message, Exception innerException)
}
internal Mono.CompilerServices.SymbolWriter.MonoSymbolWriter : object {
private List`1<SourceMethodBuilder> methods
private List`1<SourceFileEntry> sources
private List`1<CompileUnitEntry> comp_units
protected MonoSymbolFile file
private string filename
private SourceMethodBuilder current_method
private Stack`1<SourceMethodBuilder> current_method_stack
public MonoSymbolFile SymbolFile
public void .ctor(string filename)
public MonoSymbolFile get_SymbolFile()
public void CloseNamespace()
public void DefineLocalVariable(int index, string name)
public void DefineCapturedLocal(int scope_id, string name, string captured_name)
public void DefineCapturedParameter(int scope_id, string name, string captured_name)
public void DefineCapturedThis(int scope_id, string captured_name)
public void DefineCapturedScope(int scope_id, int id, string captured_name)
public void DefineScopeVariable(int scope, int index)
public void MarkSequencePoint(int offset, SourceFileEntry file, int line, int column, bool is_hidden)
public SourceMethodBuilder OpenMethod(ICompileUnit file, int ns_id, IMethodDef method)
public void CloseMethod()
public SourceFileEntry DefineDocument(string url)
public SourceFileEntry DefineDocument(string url, Byte[] guid, Byte[] checksum)
public CompileUnitEntry DefineCompilationUnit(SourceFileEntry source)
public int DefineNamespace(string name, CompileUnitEntry unit, String[] using_clauses, int parent)
public int OpenScope(int start_offset)
public void CloseScope(int end_offset)
public void OpenCompilerGeneratedBlock(int start_offset)
public void CloseCompilerGeneratedBlock(int end_offset)
public void StartIteratorBody(int start_offset)
public void EndIteratorBody(int end_offset)
public void StartIteratorDispatcher(int start_offset)
public void EndIteratorDispatcher(int end_offset)
public void DefineAnonymousScope(int id)
public void WriteSymbolFile(Guid guid)
}
internal Mono.CompilerServices.SymbolWriter.MyBinaryReader : BinaryReader {
public void .ctor(Stream stream)
public int ReadLeb128()
public string ReadString(int offset)
}
internal Mono.CompilerServices.SymbolWriter.MyBinaryWriter : BinaryWriter {
public void .ctor(Stream stream)
public void WriteLeb128(int value)
}
internal Mono.CompilerServices.SymbolWriter.NamespaceEntry : ValueType {
public string Name
public int Index
public int Parent
public String[] UsingClauses
public void .ctor(string name, int index, String[] using_clauses, int parent)
internal void .ctor(MonoSymbolFile file, MyBinaryReader reader)
internal void Write(MonoSymbolFile file, MyBinaryWriter bw)
public string ToString()
}
internal Mono.CompilerServices.SymbolWriter.NamespaceInfo : object {
public string Name
public int NamespaceID
public ArrayList UsingClauses
}
internal Mono.CompilerServices.SymbolWriter.OffsetTable : object {
public int MajorVersion
public int MinorVersion
public long Magic
public int TotalFileSize
public int DataSectionOffset
public int DataSectionSize
public int CompileUnitCount
public int CompileUnitTableOffset
public int CompileUnitTableSize
public int SourceCount
public int SourceTableOffset
public int SourceTableSize
public int MethodCount
public int MethodTableOffset
public int MethodTableSize
public int TypeCount
public int AnonymousScopeCount
public int AnonymousScopeTableOffset
public int AnonymousScopeTableSize
public Flags FileFlags
public int LineNumberTable_LineBase
public int LineNumberTable_LineRange
public int LineNumberTable_OpcodeBase
internal void .ctor(BinaryReader reader, int major_version, int minor_version)
internal void Write(BinaryWriter bw, int major_version, int minor_version)
public string ToString()
}
internal Mono.CompilerServices.SymbolWriter.ScopeVariable : ValueType {
public int Scope
public int Index
public void .ctor(int scope, int index)
internal void .ctor(MyBinaryReader reader)
internal void Write(MyBinaryWriter bw)
public string ToString()
}
internal Mono.CompilerServices.SymbolWriter.SourceFileEntry : object {
public int Index
private int DataOffset
private MonoSymbolFile file
private string file_name
private Byte[] guid
private Byte[] hash
private bool creating
private bool auto_generated
private string sourceFile
public int Size
public Byte[] Checksum
public string FileName
public bool AutoGenerated
public int get_Size()
public void .ctor(MonoSymbolFile file, string file_name)
public void .ctor(MonoSymbolFile file, string sourceFile, Byte[] guid, Byte[] checksum)
public void .ctor(MonoSymbolFile file, string fileName, string sourceFile, Byte[] guid, Byte[] checksum)
public Byte[] get_Checksum()
internal void WriteData(MyBinaryWriter bw)
internal void Write(BinaryWriter bw)
internal void .ctor(MonoSymbolFile file, MyBinaryReader reader)
public string get_FileName()
public void set_FileName(string value)
public bool get_AutoGenerated()
public void SetAutoGenerated()
public bool CheckChecksum()
public string ToString()
}
internal Mono.CompilerServices.SymbolWriter.SourceMethodBuilder : object {
private List`1<LocalVariableEntry> _locals
private List`1<CodeBlockEntry> _blocks
private List`1<ScopeVariable> _scope_vars
private Stack`1<CodeBlockEntry> _block_stack
private List`1<LineNumberEntry> method_lines
private ICompileUnit _comp_unit
private int ns_id
private IMethodDef method
public CodeBlockEntry[] Blocks
public CodeBlockEntry CurrentBlock
public LocalVariableEntry[] Locals
public ICompileUnit SourceFile
public ScopeVariable[] ScopeVariables
public void .ctor(ICompileUnit comp_unit)
public void .ctor(ICompileUnit comp_unit, int ns_id, IMethodDef method)
public void MarkSequencePoint(int offset, SourceFileEntry file, int line, int column, bool is_hidden)
public void MarkSequencePoint(int offset, SourceFileEntry file, int line, int column, int end_line, int end_column, bool is_hidden)
public void StartBlock(Type type, int start_offset)
public void StartBlock(Type type, int start_offset, int scopeIndex)
public void EndBlock(int end_offset)
public CodeBlockEntry[] get_Blocks()
public CodeBlockEntry get_CurrentBlock()
public LocalVariableEntry[] get_Locals()
public ICompileUnit get_SourceFile()
public void AddLocal(int index, string name)
public ScopeVariable[] get_ScopeVariables()
public void AddScopeVariable(int scope, int index)
public void DefineMethod(MonoSymbolFile file)
public void DefineMethod(MonoSymbolFile file, int token)
}
internal Mono.CompilerServices.SymbolWriter.SourceMethodImpl : object {
private string name
private int token
private int namespaceID
public string Name
public int NamespaceID
public int Token
public void .ctor(string name, int token, int namespaceID)
public string get_Name()
public int get_NamespaceID()
public int get_Token()
}
internal Mono.CompilerServices.SymbolWriter.SymbolDocumentWriterImpl : object {
private CompileUnitEntry comp_unit
private SourceFileEntry Mono.CompilerServices.SymbolWriter.ISourceFile.Entry
public CompileUnitEntry Entry
public void .ctor(CompileUnitEntry comp_unit)
public void SetCheckSum(Guid algorithmId, Byte[] checkSum)
public void SetSource(Byte[] source)
private SourceFileEntry Mono.CompilerServices.SymbolWriter.ISourceFile.get_Entry()
public CompileUnitEntry get_Entry()
}
internal Mono.CompilerServices.SymbolWriter.SymbolWriterImpl : object {
private MonoSymbolWriter msw
private int nextLocalIndex
private int currentToken
private string methodName
private Stack namespaceStack
private bool methodOpened
private Hashtable documents
private Guid guid
public void .ctor(Guid guid)
public void Close()
public void CloseMethod()
public void CloseNamespace()
public void CloseScope(int endOffset)
public ISymbolDocumentWriter DefineDocument(string url, Guid language, Guid languageVendor, Guid documentType)
public void DefineField(SymbolToken parent, string name, FieldAttributes attributes, Byte[] signature, SymAddressKind addrKind, int addr1, int addr2, int addr3)
public void DefineGlobalVariable(string name, FieldAttributes attributes, Byte[] signature, SymAddressKind addrKind, int addr1, int addr2, int addr3)
public void DefineLocalVariable(string name, FieldAttributes attributes, Byte[] signature, SymAddressKind addrKind, int addr1, int addr2, int addr3, int startOffset, int endOffset)
public void DefineParameter(string name, ParameterAttributes attributes, int sequence, SymAddressKind addrKind, int addr1, int addr2, int addr3)
public void DefineSequencePoints(ISymbolDocumentWriter document, Int32[] offsets, Int32[] lines, Int32[] columns, Int32[] endLines, Int32[] endColumns)
public void Initialize(IntPtr emitter, string filename, bool fFullBuild)
public void OpenMethod(SymbolToken method)
public void OpenNamespace(string name)
public int OpenScope(int startOffset)
public void SetMethodSourceRange(ISymbolDocumentWriter startDoc, int startLine, int startColumn, ISymbolDocumentWriter endDoc, int endLine, int endColumn)
public void SetScopeRange(int scopeID, int startOffset, int endOffset)
public void SetSymAttribute(SymbolToken parent, string name, Byte[] data)
public void SetUnderlyingWriter(IntPtr underlyingWriter)
public void SetUserEntryPoint(SymbolToken entryMethod)
public void UsingNamespace(string fullName)
private int GetCurrentNamespace(ISymbolDocumentWriter doc)
}
internal Mono.Disposable : object {
public Disposable`1<T> Owned(T value)
public Disposable`1<T> NotOwned(T value)
}
internal Mono.Disposable`1 : ValueType {
internal T value
private bool owned
public void .ctor(T value, bool owned)
public void Dispose()
}
internal Mono.Empty`1 : object {
public T[] Array
}
internal Mono.MergeSort`1 : object {
private T[] elements
private T[] buffer
private IComparer`1<T> comparer
private void .ctor(T[] elements, IComparer`1<T> comparer)
public void Sort(T[] source, IComparer`1<T> comparer)
public void Sort(T[] source, int start, int length, IComparer`1<T> comparer)
private void Sort(int start, int length)
private void TopDownSplitMerge(T[] a, T[] b, int start, int end)
private void TopDownMerge(T[] a, T[] b, int start, int middle, int end)
}
internal Mono.Security.Cryptography.CryptoConvert : object {
private int ToInt32LE(Byte[] bytes, int offset)
private UInt32 ToUInt32LE(Byte[] bytes, int offset)
private Byte[] GetBytesLE(int val)
private Byte[] Trim(Byte[] array)
private RSA FromCapiPrivateKeyBlob(Byte[] blob, int offset)
private RSA FromCapiPublicKeyBlob(Byte[] blob, int offset)
public RSA FromCapiKeyBlob(Byte[] blob)
public RSA FromCapiKeyBlob(Byte[] blob, int offset)
public Byte[] ToCapiPublicKeyBlob(RSA rsa)
}
internal MonoMod.<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog : object {
public bool IsWritingLog
public bool get_IsWritingLog()
internal void LogVersion()
public void Log(LogLevel level, string message)
public void Log(LogLevel level, DebugLogInterpolatedStringHandler& message)
public void Spam(string message)
public void Spam(DebugLogSpamStringHandler& message)
public void Trace(string message)
public void Trace(DebugLogTraceStringHandler& message)
public void Info(string message)
public void Info(DebugLogInfoStringHandler& message)
public void Warning(string message)
public void Warning(DebugLogWarningStringHandler& message)
public void Error(string message)
public void Error(DebugLogErrorStringHandler& message)
}
internal MonoMod.<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MultiTargetShims : object {
public TypeReference GetConstraintType(GenericParameterConstraint constraint)
}
internal MonoMod.Backports.MethodImplOptionsEx : object {
public MethodImplOptions Unmanaged
public MethodImplOptions NoInlining
public MethodImplOptions ForwardRef
public MethodImplOptions Synchronized
public MethodImplOptions NoOptimization
public MethodImplOptions PreserveSig
public MethodImplOptions AggressiveInlining
public MethodImplOptions AggressiveOptimization
public MethodImplOptions InternalCall
}
internal MonoMod.Cil.FastDelegateInvokers : object {
private ValueTuple`2[] invokers
private int MaxFastInvokerParams
private ConditionalWeakTable`2<Type, Tuple`2<MethodInfo, Type>> invokerCache
private ValueTuple`2[] GetInvokers()
private Nullable`1<ValueTuple`2<MethodInfo, Type>> TryGetInvokerForSig(MethodSignature sig)
public Nullable`1<ValueTuple`2<MethodInfo, Type>> GetDelegateInvoker(Type delegateType)
private void InvokeVoidVal1(T0 _0, VoidVal1`1<T0> del)
private TResult InvokeTypeVal1(T0 _0, TypeVal1`2<TResult, T0> del)
private void InvokeVoidRef1(T0& _0, VoidRef1`1<T0> del)
private TResult InvokeTypeRef1(T0& _0, TypeRef1`2<TResult, T0> del)
private void InvokeVoidVal2(T0 _0, T1 _1, VoidVal2`2<T0, T1> del)
private TResult InvokeTypeVal2(T0 _0, T1 _1, TypeVal2`3<TResult, T0, T1> del)
private void InvokeVoidRef2(T0& _0, T1 _1, VoidRef2`2<T0, T1> del)
private TResult InvokeTypeRef2(T0& _0, T1 _1, TypeRef2`3<TResult, T0, T1> del)
private void InvokeVoidVal3(T0 _0, T1 _1, T2 _2, VoidVal3`3<T0, T1, T2> del)
private TResult InvokeTypeVal3(T0 _0, T1 _1, T2 _2, TypeVal3`4<TResult, T0, T1, T2> del)
private void InvokeVoidRef3(T0& _0, T1 _1, T2 _2, VoidRef3`3<T0, T1, T2> del)
private TResult InvokeTypeRef3(T0& _0, T1 _1, T2 _2, TypeRef3`4<TResult, T0, T1, T2> del)
private void InvokeVoidVal4(T0 _0, T1 _1, T2 _2, T3 _3, VoidVal4`4<T0, T1, T2, T3> del)
private TResult InvokeTypeVal4(T0 _0, T1 _1, T2 _2, T3 _3, TypeVal4`5<TResult, T0, T1, T2, T3> del)
private void InvokeVoidRef4(T0& _0, T1 _1, T2 _2, T3 _3, VoidRef4`4<T0, T1, T2, T3> del)
private TResult InvokeTypeRef4(T0& _0, T1 _1, T2 _2, T3 _3, TypeRef4`5<TResult, T0, T1, T2, T3> del)
private void InvokeVoidVal5(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, VoidVal5`5<T0, T1, T2, T3, T4> del)
private TResult InvokeTypeVal5(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, TypeVal5`6<TResult, T0, T1, T2, T3, T4> del)
private void InvokeVoidRef5(T0& _0, T1 _1, T2 _2, T3 _3, T4 _4, VoidRef5`5<T0, T1, T2, T3, T4> del)
private TResult InvokeTypeRef5(T0& _0, T1 _1, T2 _2, T3 _3, T4 _4, TypeRef5`6<TResult, T0, T1, T2, T3, T4> del)
private void InvokeVoidVal6(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, VoidVal6`6<T0, T1, T2, T3, T4, T5> del)
private TResult InvokeTypeVal6(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, TypeVal6`7<TResult, T0, T1, T2, T3, T4, T5> del)
private void InvokeVoidRef6(T0& _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, VoidRef6`6<T0, T1, T2, T3, T4, T5> del)
private TResult InvokeTypeRef6(T0& _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, TypeRef6`7<TResult, T0, T1, T2, T3, T4, T5> del)
private void InvokeVoidVal7(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, VoidVal7`7<T0, T1, T2, T3, T4, T5, T6> del)
private TResult InvokeTypeVal7(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, TypeVal7`8<TResult, T0, T1, T2, T3, T4, T5, T6> del)
private void InvokeVoidRef7(T0& _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, VoidRef7`7<T0, T1, T2, T3, T4, T5, T6> del)
private TResult InvokeTypeRef7(T0& _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, TypeRef7`8<TResult, T0, T1, T2, T3, T4, T5, T6> del)
private void InvokeVoidVal8(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, VoidVal8`8<T0, T1, T2, T3, T4, T5, T6, T7> del)
private TResult InvokeTypeVal8(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, TypeVal8`9<TResult, T0, T1, T2, T3, T4, T5, T6, T7> del)
private void InvokeVoidRef8(T0& _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, VoidRef8`8<T0, T1, T2, T3, T4, T5, T6, T7> del)
private TResult InvokeTypeRef8(T0& _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, TypeRef8`9<TResult, T0, T1, T2, T3, T4, T5, T6, T7> del)
private void InvokeVoidVal9(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, VoidVal9`9<T0, T1, T2, T3, T4, T5, T6, T7, T8> del)
private TResult InvokeTypeVal9(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, TypeVal9`10<TResult, T0, T1, T2, T3, T4, T5, T6, T7, T8> del)
private void InvokeVoidRef9(T0& _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, VoidRef9`9<T0, T1, T2, T3, T4, T5, T6, T7, T8> del)
private TResult InvokeTypeRef9(T0& _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, TypeRef9`10<TResult, T0, T1, T2, T3, T4, T5, T6, T7, T8> del)
private void InvokeVoidVal10(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, VoidVal10`10<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9> del)
private TResult InvokeTypeVal10(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, TypeVal10`11<TResult, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9> del)
private void InvokeVoidRef10(T0& _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, VoidRef10`10<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9> del)
private TResult InvokeTypeRef10(T0& _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, TypeRef10`11<TResult, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9> del)
private void InvokeVoidVal11(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, T10 _10, VoidVal11`11<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> del)
private TResult InvokeTypeVal11(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, T10 _10, TypeVal11`12<TResult, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> del)
private void InvokeVoidRef11(T0& _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, T10 _10, VoidRef11`11<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> del)
private TResult InvokeTypeRef11(T0& _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, T10 _10, TypeRef11`12<TResult, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> del)
private void InvokeVoidVal12(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, T10 _10, T11 _11, VoidVal12`12<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> del)
private TResult InvokeTypeVal12(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, T10 _10, T11 _11, TypeVal12`13<TResult, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> del)
private void InvokeVoidRef12(T0& _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, T10 _10, T11 _11, VoidRef12`12<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> del)
private TResult InvokeTypeRef12(T0& _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, T10 _10, T11 _11, TypeRef12`13<TResult, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> del)
private void InvokeVoidVal13(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, T10 _10, T11 _11, T12 _12, VoidVal13`13<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> del)
private TResult InvokeTypeVal13(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, T10 _10, T11 _11, T12 _12, TypeVal13`14<TResult, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> del)
private void InvokeVoidRef13(T0& _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, T10 _10, T11 _11, T12 _12, VoidRef13`13<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> del)
private TResult InvokeTypeRef13(T0& _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, T10 _10, T11 _11, T12 _12, TypeRef13`14<TResult, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> del)
private void InvokeVoidVal14(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, T10 _10, T11 _11, T12 _12, T13 _13, VoidVal14`14<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> del)
private TResult InvokeTypeVal14(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, T10 _10, T11 _11, T12 _12, T13 _13, TypeVal14`15<TResult, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> del)
private void InvokeVoidRef14(T0& _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, T10 _10, T11 _11, T12 _12, T13 _13, VoidRef14`14<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> del)
private TResult InvokeTypeRef14(T0& _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, T10 _10, T11 _11, T12 _12, T13 _13, TypeRef14`15<TResult, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> del)
private void InvokeVoidVal15(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, T10 _10, T11 _11, T12 _12, T13 _13, T14 _14, VoidVal15`15<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> del)
private TResult InvokeTypeVal15(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, T10 _10, T11 _11, T12 _12, T13 _13, T14 _14, TypeVal15`16<TResult, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> del)
private void InvokeVoidRef15(T0& _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, T10 _10, T11 _11, T12 _12, T13 _13, T14 _14, VoidRef15`15<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> del)
private TResult InvokeTypeRef15(T0& _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, T10 _10, T11 _11, T12 _12, T13 _13, T14 _14, TypeRef15`16<TResult, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> del)
private void InvokeVoidVal16(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, T10 _10, T11 _11, T12 _12, T13 _13, T14 _14, T15 _15, VoidVal16`16<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> del)
private TResult InvokeTypeVal16(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, T10 _10, T11 _11, T12 _12, T13 _13, T14 _14, T15 _15, TypeVal16`17<TResult, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> del)
private void InvokeVoidRef16(T0& _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, T10 _10, T11 _11, T12 _12, T13 _13, T14 _14, T15 _15, VoidRef16`16<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> del)
private TResult InvokeTypeRef16(T0& _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, T10 _10, T11 _11, T12 _12, T13 _13, T14 _14, T15 _15, TypeRef16`17<TResult, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> del)
}
internal MonoMod.Cil.GetFastDelegateInvokersArrayAttribute : Attribute {
private int <MaxParams>k__BackingField
public int MaxParams
public int get_MaxParams()
public void .ctor(int maxParams)
}
internal MonoMod.Cil.ILContext : object {
private MethodDefinition <Method>k__BackingField
private ILProcessor <IL>k__BackingField
internal List`1<ILLabel> _Labels
private bool disposedValue
private List`1<DataScope`1<DynamicReferenceCell>> managedObjectRefs
private Action OnDispose
public MethodDefinition Method
public ILProcessor IL
public MethodBody Body
public ModuleDefinition Module
public Collection`1<Instruction> Instrs
public ReadOnlyCollection`1<ILLabel> Labels
public bool IsReadOnly
public MethodDefinition get_Method()
private void set_Method(MethodDefinition value)
public ILProcessor get_IL()
private void set_IL(ILProcessor value)
public MethodBody get_Body()
public ModuleDefinition get_Module()
public Collection`1<Instruction> get_Instrs()
public ReadOnlyCollection`1<ILLabel> get_Labels()
public bool get_IsReadOnly()
public void add_OnDispose(Action value)
public void remove_OnDispose(Action value)
public void .ctor(MethodDefinition method)
public void Invoke(Manipulator manip)
public void MakeReadOnly()
public ILCursor At(int index)
public ILCursor At(ILLabel label)
public ILCursor At(Instruction instr)
public FieldReference Import(FieldInfo field)
public MethodReference Import(MethodBase method)
public TypeReference Import(Type type)
public ILLabel DefineLabel()
public ILLabel DefineLabel(Instruction target)
public int IndexOf(Instruction instr)
public IEnumerable`1<ILLabel> GetIncomingLabels(Instruction instr)
public int AddReference(T& value)
public T GetReference(int id)
public void SetReference(int id, T& value)
public DynamicReferenceCell GetReferenceCell(int id)
public string ToString()
internal StringBuilder ToString(StringBuilder builder, Instruction instr)
protected void Dispose(bool disposing)
protected void Finalize()
public void Dispose()
private ILLabel <Invoke>b__26_0(Instruction t)
}
internal MonoMod.Cil.ILCursor : object {
private ILContext <Context>k__BackingField
private Instruction _next
private ILLabel[] _afterLabels
private bool _afterHandlerStarts
private bool _afterHandlerEnds
private SearchTarget _searchTarget
public ILContext Context
public Instruction Next
public Instruction Prev
public Instruction Previous
public int Index
public SearchTarget SearchTarget
public IEnumerable`1<ILLabel> IncomingLabels
public MethodDefinition Method
public ILProcessor IL
public MethodBody Body
public ModuleDefinition Module
public Collection`1<Instruction> Instrs
public ILContext get_Context()
public Instruction get_Next()
public void set_Next(Instruction value)
public Instruction get_Prev()
public void set_Prev(Instruction value)
public Instruction get_Previous()
public void set_Previous(Instruction value)
public int get_Index()
public void set_Index(int value)
public SearchTarget get_SearchTarget()
public void set_SearchTarget(SearchTarget value)
public IEnumerable`1<ILLabel> get_IncomingLabels()
public MethodDefinition get_Method()
public ILProcessor get_IL()
public MethodBody get_Body()
public ModuleDefinition get_Module()
public Collection`1<Instruction> get_Instrs()
public void .ctor(ILContext context)
public void .ctor(ILCursor c)
public ILCursor Clone()
public bool IsBefore(Instruction instr)
public bool IsAfter(Instruction instr)
public string ToString()
public ILCursor Goto(Instruction insn, MoveType moveType, bool setTarget)
public ILCursor MoveAfterLabels()
public ILCursor MoveAfterLabels(bool intoEHRanges)
public ILCursor MoveBeforeLabels()
public ILCursor Goto(int index, MoveType moveType, bool setTarget)
public ILCursor GotoLabel(ILLabel label, MoveType moveType, bool setTarget)
public ILCursor GotoNext(MoveType moveType, Func`2[] predicates)
public bool TryGotoNext(MoveType moveType, Func`2[] predicates)
public ILCursor GotoPrev(MoveType moveType, Func`2[] predicates)
public bool TryGotoPrev(MoveType moveType, Func`2[] predicates)
public ILCursor GotoNext(Func`2[] predicates)
public bool TryGotoNext(Func`2[] predicates)
public ILCursor GotoPrev(Func`2[] predicates)
public bool TryGotoPrev(Func`2[] predicates)
public void FindNext(ILCursor[]& cursors, Func`2[] predicates)
public bool TryFindNext(ILCursor[]& cursors, Func`2[] predicates)
public void FindPrev(ILCursor[]& cursors, Func`2[] predicates)
public bool TryFindPrev(ILCursor[]& cursors, Func`2[] predicates)
public void MarkLabel(ILLabel label)
public ILLabel MarkLabel(Instruction inst)
public ILLabel MarkLabel()
public ILLabel DefineLabel()
private ILCursor _Insert(Instruction instr)
public ILCursor Remove()
public ILCursor RemoveRange(int num)
public ILCursor Emit(OpCode opcode, ParameterDefinition parameter)
public ILCursor Emit(OpCode opcode, VariableDefinition variable)
public ILCursor Emit(OpCode opcode, Instruction[] targets)
public ILCursor Emit(OpCode opcode, Instruction target)
public ILCursor Emit(OpCode opcode, double value)
public ILCursor Emit(OpCode opcode, float value)
public ILCursor Emit(OpCode opcode, long value)
public ILCursor Emit(OpCode opcode, sbyte value)
public ILCursor Emit(OpCode opcode, byte value)
public ILCursor Emit(OpCode opcode, string value)
public ILCursor Emit(OpCode opcode, FieldReference field)
public ILCursor Emit(OpCode opcode, CallSite site)
public ILCursor Emit(OpCode opcode, TypeReference type)
public ILCursor Emit(OpCode opcode)
public ILCursor Emit(OpCode opcode, int value)
public ILCursor Emit(OpCode opcode, MethodReference method)
public ILCursor Emit(OpCode opcode, FieldInfo field)
public ILCursor Emit(OpCode opcode, MethodBase method)
public ILCursor Emit(OpCode opcode, Type type)
public ILCursor Emit(OpCode opcode, object operand)
public ILCursor Emit(OpCode opcode, string memberName)
public int AddReference(T& t)
public void EmitGetReference(int id)
public int EmitReference(T& t)
public int EmitDelegate(T cb)
public ILCursor EmitAdd()
public ILCursor EmitAddOvf()
public ILCursor EmitAddOvfUn()
public ILCursor EmitAnd()
public ILCursor EmitArglist()
public ILCursor EmitBeq(ILLabel operand)
public ILCursor EmitBeq(Instruction operand)
public ILCursor EmitBge(ILLabel operand)
public ILCursor EmitBge(Instruction operand)
public ILCursor EmitBgeUn(ILLabel operand)
public ILCursor EmitBgeUn(Instruction operand)
public ILCursor EmitBgt(ILLabel operand)
public ILCursor EmitBgt(Instruction operand)
public ILCursor EmitBgtUn(ILLabel operand)
public ILCursor EmitBgtUn(Instruction operand)
public ILCursor EmitBle(ILLabel operand)
public ILCursor EmitBle(Instruction operand)
public ILCursor EmitBleUn(ILLabel operand)
public ILCursor EmitBleUn(Instruction operand)
public ILCursor EmitBlt(ILLabel operand)
public ILCursor EmitBlt(Instruction operand)
public ILCursor EmitBltUn(ILLabel operand)
public ILCursor EmitBltUn(Instruction operand)
public ILCursor EmitBneUn(ILLabel operand)
public ILCursor EmitBneUn(Instruction operand)
public ILCursor EmitBox(TypeReference operand)
public ILCursor EmitBox(Type operand)
public ILCursor EmitBr(ILLabel operand)
public ILCursor EmitBr(Instruction operand)
public ILCursor EmitBreak()
public ILCursor EmitBrfalse(ILLabel operand)
public ILCursor EmitBrfalse(Instruction operand)
public ILCursor EmitBrtrue(ILLabel operand)
public ILCursor EmitBrtrue(Instruction operand)
public ILCursor EmitCall(MethodReference operand)
public ILCursor EmitCall(MethodBase operand)
public ILCursor EmitCalli(IMethodSignature operand)
public ILCursor EmitCallvirt(MethodReference operand)
public ILCursor EmitCallvirt(MethodBase operand)
public ILCursor EmitCastclass(TypeReference operand)
public ILCursor EmitCastclass(Type operand)
public ILCursor EmitCeq()
public ILCursor EmitCgt()
public ILCursor EmitCgtUn()
public ILCursor EmitCkfinite()
public ILCursor EmitClt()
public ILCursor EmitCltUn()
public ILCursor EmitConstrained(TypeReference operand)
public ILCursor EmitConstrained(Type operand)
public ILCursor EmitConvI()
public ILCursor EmitConvI1()
public ILCursor EmitConvI2()
public ILCursor EmitConvI4()
public ILCursor EmitConvI8()
public ILCursor EmitConvOvfI()
public ILCursor EmitConvOvfIUn()
public ILCursor EmitConvOvfI1()
public ILCursor EmitConvOvfI1Un()
public ILCursor EmitConvOvfI2()
public ILCursor EmitConvOvfI2Un()
public ILCursor EmitConvOvfI4()
public ILCursor EmitConvOvfI4Un()
public ILCursor EmitConvOvfI8()
public ILCursor EmitConvOvfI8Un()
public ILCursor EmitConvOvfU()
public ILCursor EmitConvOvfUUn()
public ILCursor EmitConvOvfU1()
public ILCursor EmitConvOvfU1Un()
public ILCursor EmitConvOvfU2()
public ILCursor EmitConvOvfU2Un()
public ILCursor EmitConvOvfU4()
public ILCursor EmitConvOvfU4Un()
public ILCursor EmitConvOvfU8()
public ILCursor EmitConvOvfU8Un()
public ILCursor EmitConvRUn()
public ILCursor EmitConvR4()
public ILCursor EmitConvR8()
public ILCursor EmitConvU()
public ILCursor EmitConvU1()
public ILCursor EmitConvU2()
public ILCursor EmitConvU4()
public ILCursor EmitConvU8()
public ILCursor EmitCpblk()
public ILCursor EmitCpobj(TypeReference operand)
public ILCursor EmitCpobj(Type operand)
public ILCursor EmitDiv()
public ILCursor EmitDivUn()
public ILCursor EmitDup()
public ILCursor EmitEndfilter()
public ILCursor EmitEndfinally()
public ILCursor EmitInitblk()
public ILCursor EmitInitobj(TypeReference operand)
public ILCursor EmitInitobj(Type operand)
public ILCursor EmitIsinst(TypeReference operand)
public ILCursor EmitIsinst(Type operand)
public ILCursor EmitJmp(MethodReference operand)
public ILCursor EmitJmp(MethodBase operand)
public ILCursor EmitLdarg0()
public ILCursor EmitLdarg1()
public ILCursor EmitLdarg2()
public ILCursor EmitLdarg3()
public ILCursor EmitLdarg(int operand)
public ILCursor EmitLdarg(UInt32 operand)
public ILCursor EmitLdarg(ParameterReference operand)
public ILCursor EmitLdarga(int operand)
public ILCursor EmitLdarga(UInt32 operand)
public ILCursor EmitLdarga(ParameterReference operand)
public ILCursor EmitLdcI4(int operand)
public ILCursor EmitLdcI4(UInt32 operand)
public ILCursor EmitLdcI8(long operand)
public ILCursor EmitLdcI8(ulong operand)
public ILCursor EmitLdcR4(float operand)
public ILCursor EmitLdcR8(double operand)
public ILCursor EmitLdelemAny(TypeReference operand)
public ILCursor EmitLdelemAny(Type operand)
public ILCursor EmitLdelemI()
public ILCursor EmitLdelemI1()
public ILCursor EmitLdelemI2()
public ILCursor EmitLdelemI4()
public ILCursor EmitLdelemI8()
public ILCursor EmitLdelemR4()
public ILCursor EmitLdelemR8()
public ILCursor EmitLdelemRef()
public ILCursor EmitLdelemU1()
public ILCursor EmitLdelemU2()
public ILCursor EmitLdelemU4()
public ILCursor EmitLdelema(TypeReference operand)
public ILCursor EmitLdelema(Type operand)
public ILCursor EmitLdfld(FieldReference operand)
public ILCursor EmitLdfld(FieldInfo operand)
public ILCursor EmitLdflda(FieldReference operand)
public ILCursor EmitLdflda(FieldInfo operand)
public ILCursor EmitLdftn(MethodReference operand)
public ILCursor EmitLdftn(MethodBase operand)
public ILCursor EmitLdindI()
public ILCursor EmitLdindI1()
public ILCursor EmitLdindI2()
public ILCursor EmitLdindI4()
public ILCursor EmitLdindI8()
public ILCursor EmitLdindR4()
public ILCursor EmitLdindR8()
public ILCursor EmitLdindRef()
public ILCursor EmitLdindU1()
public ILCursor EmitLdindU2()
public ILCursor EmitLdindU4()
public ILCursor EmitLdlen()
public ILCursor EmitLdloc0()
public ILCursor EmitLdloc1()
public ILCursor EmitLdloc2()
public ILCursor EmitLdloc3()
public ILCursor EmitLdloc(int operand)
public ILCursor EmitLdloc(UInt32 operand)
public ILCursor EmitLdloc(VariableReference operand)
public ILCursor EmitLdloca(int operand)
public ILCursor EmitLdloca(UInt32 operand)
public ILCursor EmitLdloca(VariableReference operand)
public ILCursor EmitLdnull()
public ILCursor EmitLdobj(TypeReference operand)
public ILCursor EmitLdobj(Type operand)
public ILCursor EmitLdsfld(FieldReference operand)
public ILCursor EmitLdsfld(FieldInfo operand)
public ILCursor EmitLdsflda(FieldReference operand)
public ILCursor EmitLdsflda(FieldInfo operand)
public ILCursor EmitLdstr(string operand)
public ILCursor EmitLdtoken(IMetadataTokenProvider operand)
public ILCursor EmitLdtoken(Type operand)
public ILCursor EmitLdtoken(FieldInfo operand)
public ILCursor EmitLdtoken(MethodBase operand)
public ILCursor EmitLdvirtftn(MethodReference operand)
public ILCursor EmitLdvirtftn(MethodBase operand)
public ILCursor EmitLeave(ILLabel operand)
public ILCursor EmitLeave(Instruction operand)
public ILCursor EmitLocalloc()
public ILCursor EmitMkrefany(TypeReference operand)
public ILCursor EmitMkrefany(Type operand)
public ILCursor EmitMul()
public ILCursor EmitMulOvf()
public ILCursor EmitMulOvfUn()
public ILCursor EmitNeg()
public ILCursor EmitNewarr(TypeReference operand)
public ILCursor EmitNewarr(Type operand)
public ILCursor EmitNewobj(MethodReference operand)
public ILCursor EmitNewobj(MethodBase operand)
public ILCursor EmitNop()
public ILCursor EmitNot()
public ILCursor EmitOr()
public ILCursor EmitPop()
public ILCursor EmitReadonly()
public ILCursor EmitRefanytype()
public ILCursor EmitRefanyval(TypeReference operand)
public ILCursor EmitRefanyval(Type operand)
public ILCursor EmitRem()
public ILCursor EmitRemUn()
public ILCursor EmitRet()
public ILCursor EmitRethrow()
public ILCursor EmitShl()
public ILCursor EmitShr()
public ILCursor EmitShrUn()
public ILCursor EmitSizeof(TypeReference operand)
public ILCursor EmitSizeof(Type operand)
public ILCursor EmitStarg(int operand)
public ILCursor EmitStarg(UInt32 operand)
public ILCursor EmitStarg(ParameterReference operand)
public ILCursor EmitStelemAny(TypeReference operand)
public ILCursor EmitStelemAny(Type operand)
public ILCursor EmitStelemI()
public ILCursor EmitStelemI1()
public ILCursor EmitStelemI2()
public ILCursor EmitStelemI4()
public ILCursor EmitStelemI8()
public ILCursor EmitStelemR4()
public ILCursor EmitStelemR8()
public ILCursor EmitStelemRef()
public ILCursor EmitStfld(FieldReference operand)
public ILCursor EmitStfld(FieldInfo operand)
public ILCursor EmitStindI()
public ILCursor EmitStindI1()
public ILCursor EmitStindI2()
public ILCursor EmitStindI4()
public ILCursor EmitStindI8()
public ILCursor EmitStindR4()
public ILCursor EmitStindR8()
public ILCursor EmitStindRef()
public ILCursor EmitStloc0()
public ILCursor EmitStloc1()
public ILCursor EmitStloc2()
public ILCursor EmitStloc3()
public ILCursor EmitStloc(int operand)
public ILCursor EmitStloc(UInt32 operand)
public ILCursor EmitStloc(VariableReference operand)
public ILCursor EmitStobj(TypeReference operand)
public ILCursor EmitStobj(Type operand)
public ILCursor EmitStsfld(FieldReference operand)
public ILCursor EmitStsfld(FieldInfo operand)
public ILCursor EmitSub()
public ILCursor EmitSubOvf()
public ILCursor EmitSubOvfUn()
public ILCursor EmitSwitch(ILLabel[] operand)
public ILCursor EmitSwitch(Instruction[] operand)
public ILCursor EmitTail()
public ILCursor EmitThrow()
public ILCursor EmitUnaligned(byte operand)
public ILCursor EmitUnbox(TypeReference operand)
public ILCursor EmitUnbox(Type operand)
public ILCursor EmitUnboxAny(TypeReference operand)
public ILCursor EmitUnboxAny(Type operand)
public ILCursor EmitVolatile()
public ILCursor EmitXor()
}
internal MonoMod.Cil.ILLabel : object {
private ILContext Context
private Instruction <Target>k__BackingField
public Instruction Target
public IEnumerable`1<Instruction> Branches
public Instruction get_Target()
public void set_Target(Instruction value)
public IEnumerable`1<Instruction> get_Branches()
internal void .ctor(ILContext context)
internal void .ctor(ILContext context, Instruction target)
private bool <get_Branches>b__6_0(Instruction i)
}
internal MonoMod.Cil.ILPatternMatchingExt : object {
private bool IsEquivalent(int l, int r)
private bool IsEquivalent(int l, UInt32 r)
private bool IsEquivalent(long l, long r)
private bool IsEquivalent(long l, ulong r)
private bool IsEquivalent(float l, float r)
private bool IsEquivalent(double l, double r)
private bool IsEquivalent(string l, string r)
private bool IsEquivalent(ILLabel l, ILLabel r)
private bool IsEquivalent(ILLabel l, Instruction r)
private bool IsEquivalent(Instruction l, Instruction r)
private bool IsEquivalent(TypeReference l, TypeReference r)
private bool IsEquivalent(TypeReference l, Type r)
private bool IsEquivalent(MethodReference l, MethodReference r)
private bool IsEquivalent(MethodReference l, MethodBase r)
private bool IsEquivalent(MethodReference l, Type type, string name)
private bool IsEquivalent(FieldReference l, FieldReference r)
private bool IsEquivalent(FieldReference l, FieldInfo r)
private bool IsEquivalent(FieldReference l, Type type, string name)
private bool IsEquivalent(ILLabel[] l, ILLabel[] r)
private bool IsEquivalent(ILLabel[] l, Instruction[] r)
private bool IsEquivalent(IMethodSignature l, IMethodSignature r)
private IEnumerable`1<ParameterReference> CastParamsToRef(IMethodSignature sig)
private bool IsEquivalent(IMetadataTokenProvider l, IMetadataTokenProvider r)
private bool IsEquivalent(IMetadataTokenProvider l, Type r)
private bool IsEquivalent(IMetadataTokenProvider l, FieldInfo r)
private bool IsEquivalent(IMetadataTokenProvider l, MethodBase r)
public bool Match(Instruction instr, OpCode opcode)
public bool Match(Instruction instr, OpCode opcode, T value)
public bool Match(Instruction instr, OpCode opcode, T& value)
public bool MatchLeaveS(Instruction instr, ILLabel value)
public bool MatchLeaveS(Instruction instr, ILLabel& value)
public bool MatchLdarg(Instruction instr, Int32& value)
public bool MatchStarg(Instruction instr, Int32& value)
public bool MatchLdarga(Instruction instr, Int32& value)
public bool MatchLdloc(Instruction instr, Int32& value)
public bool MatchStloc(Instruction instr, Int32& value)
public bool MatchLdloca(Instruction instr, Int32& value)
public bool MatchLdcI4(Instruction instr, Int32& value)
public bool MatchCallOrCallvirt(Instruction instr, MethodReference& value)
public bool MatchNewobj(Instruction instr, Type type)
public bool MatchNewobj(Instruction instr)
public bool MatchNewobj(Instruction instr, string typeFullName)
public bool MatchAdd(Instruction instr)
public bool MatchAddOvf(Instruction instr)
public bool MatchAddOvfUn(Instruction instr)
public bool MatchAnd(Instruction instr)
public bool MatchArglist(Instruction instr)
public bool MatchBeq(Instruction instr, ILLabel& value)
public bool MatchBeq(Instruction instr, ILLabel value)
public bool MatchBeq(Instruction instr, Instruction value)
public bool MatchBge(Instruction instr, ILLabel& value)
public bool MatchBge(Instruction instr, ILLabel value)
public bool MatchBge(Instruction instr, Instruction value)
public bool MatchBgeUn(Instruction instr, ILLabel& value)
public bool MatchBgeUn(Instruction instr, ILLabel value)
public bool MatchBgeUn(Instruction instr, Instruction value)
public bool MatchBgt(Instruction instr, ILLabel& value)
public bool MatchBgt(Instruction instr, ILLabel value)
public bool MatchBgt(Instruction instr, Instruction value)
public bool MatchBgtUn(Instruction instr, ILLabel& value)
public bool MatchBgtUn(Instruction instr, ILLabel value)
public bool MatchBgtUn(Instruction instr, Instruction value)
public bool MatchBle(Instruction instr, ILLabel& value)
public bool MatchBle(Instruction instr, ILLabel value)
public bool MatchBle(Instruction instr, Instruction value)
public bool MatchBleUn(Instruction instr, ILLabel& value)
public bool MatchBleUn(Instruction instr, ILLabel value)
public bool MatchBleUn(Instruction instr, Instruction value)
public bool MatchBlt(Instruction instr, ILLabel& value)
public bool MatchBlt(Instruction instr, ILLabel value)
public bool MatchBlt(Instruction instr, Instruction value)
public bool MatchBltUn(Instruction instr, ILLabel& value)
public bool MatchBltUn(Instruction instr, ILLabel value)
public bool MatchBltUn(Instruction instr, Instruction value)
public bool MatchBneUn(Instruction instr, ILLabel& value)
public bool MatchBneUn(Instruction instr, ILLabel value)
public bool MatchBneUn(Instruction instr, Instruction value)
public bool MatchBox(Instruction instr, TypeReference& value)
public bool MatchBox(Instruction instr, TypeReference value)
public bool MatchBox(Instruction instr, Type value)
public bool MatchBox(Instruction instr)
public bool MatchBox(Instruction instr, string typeFullName)
public bool MatchBr(Instruction instr, ILLabel& value)
public bool MatchBr(Instruction instr, ILLabel value)
public bool MatchBr(Instruction instr, Instruction value)
public bool MatchBreak(Instruction instr)
public bool MatchBrfalse(Instruction instr, ILLabel& value)
public bool MatchBrfalse(Instruction instr, ILLabel value)
public bool MatchBrfalse(Instruction instr, Instruction value)
public bool MatchBrtrue(Instruction instr, ILLabel& value)
public bool MatchBrtrue(Instruction instr, ILLabel value)
public bool MatchBrtrue(Instruction instr, Instruction value)
public bool MatchCall(Instruction instr, MethodReference& value)
public bool MatchCall(Instruction instr, MethodReference value)
public bool MatchCall(Instruction instr, MethodBase value)
public bool MatchCall(Instruction instr, Type type, string name)
public bool MatchCall(Instruction instr, string name)
public bool MatchCall(Instruction instr, string typeFullName, string name)
public bool MatchCalli(Instruction instr, IMethodSignature& value)
public bool MatchCalli(Instruction instr, IMethodSignature value)
public bool MatchCallvirt(Instruction instr, MethodReference& value)
public bool MatchCallvirt(Instruction instr, MethodReference value)
public bool MatchCallvirt(Instruction instr, MethodBase value)
public bool MatchCallvirt(Instruction instr, Type type, string name)
public bool MatchCallvirt(Instruction instr, string name)
public bool MatchCallvirt(Instruction instr, string typeFullName, string name)
public bool MatchCallOrCallvirt(Instruction instr, MethodReference value)
public bool MatchCallOrCallvirt(Instruction instr, MethodBase value)
public bool MatchCallOrCallvirt(Instruction instr, Type type, string name)
public bool MatchCallOrCallvirt(Instruction instr, string name)
public bool MatchCallOrCallvirt(Instruction instr, string typeFullName, string name)
public bool MatchCastclass(Instruction instr, TypeReference& value)
public bool MatchCastclass(Instruction instr, TypeReference value)
public bool MatchCastclass(Instruction instr, Type value)
public bool MatchCastclass(Instruction instr)
public bool MatchCastclass(Instruction instr, string typeFullName)
public bool MatchCeq(Instruction instr)
public bool MatchCgt(Instruction instr)
public bool MatchCgtUn(Instruction instr)
public bool MatchCkfinite(Instruction instr)
public bool MatchClt(Instruction instr)
public bool MatchCltUn(Instruction instr)
public bool MatchConstrained(Instruction instr, TypeReference& value)
public bool MatchConstrained(Instruction instr, TypeReference value)
public bool MatchConstrained(Instruction instr, Type value)
public bool MatchConstrained(Instruction instr)
public bool MatchConstrained(Instruction instr, string typeFullName)
public bool MatchConvI(Instruction instr)
public bool MatchConvI1(Instruction instr)
public bool MatchConvI2(Instruction instr)
public bool MatchConvI4(Instruction instr)
public bool MatchConvI8(Instruction instr)
public bool MatchConvOvfI(Instruction instr)
public bool MatchConvOvfIUn(Instruction instr)
public bool MatchConvOvfI1(Instruction instr)
public bool MatchConvOvfI1Un(Instruction instr)
public bool MatchConvOvfI2(Instruction instr)
public bool MatchConvOvfI2Un(Instruction instr)
public bool MatchConvOvfI4(Instruction instr)
public bool MatchConvOvfI4Un(Instruction instr)
public bool MatchConvOvfI8(Instruction instr)
public bool MatchConvOvfI8Un(Instruction instr)
public bool MatchConvOvfU(Instruction instr)
public bool MatchConvOvfUUn(Instruction instr)
public bool MatchConvOvfU1(Instruction instr)
public bool MatchConvOvfU1Un(Instruction instr)
public bool MatchConvOvfU2(Instruction instr)
public bool MatchConvOvfU2Un(Instruction instr)
public bool MatchConvOvfU4(Instruction instr)
public bool MatchConvOvfU4Un(Instruction instr)
public bool MatchConvOvfU8(Instruction instr)
public bool MatchConvOvfU8Un(Instruction instr)
public bool MatchConvRUn(Instruction instr)
public bool MatchConvR4(Instruction instr)
public bool MatchConvR8(Instruction instr)
public bool MatchConvU(Instruction instr)
public bool MatchConvU1(Instruction instr)
public bool MatchConvU2(Instruction instr)
public bool MatchConvU4(Instruction instr)
public bool MatchConvU8(Instruction instr)
public bool MatchCpblk(Instruction instr)
public bool MatchCpobj(Instruction instr, TypeReference& value)
public bool MatchCpobj(Instruction instr, TypeReference value)
public bool MatchCpobj(Instruction instr, Type value)
public bool MatchCpobj(Instruction instr)
public bool MatchCpobj(Instruction instr, string typeFullName)
public bool MatchDiv(Instruction instr)
public bool MatchDivUn(Instruction instr)
public bool MatchDup(Instruction instr)
public bool MatchEndfilter(Instruction instr)
public bool MatchEndfinally(Instruction instr)
public bool MatchInitblk(Instruction instr)
public bool MatchInitobj(Instruction instr, TypeReference& value)
public bool MatchInitobj(Instruction instr, TypeReference value)
public bool MatchInitobj(Instruction instr, Type value)
public bool MatchInitobj(Instruction instr)
public bool MatchInitobj(Instruction instr, string typeFullName)
public bool MatchIsinst(Instruction instr, TypeReference& value)
public bool MatchIsinst(Instruction instr, TypeReference value)
public bool MatchIsinst(Instruction instr, Type value)
public bool MatchIsinst(Instruction instr)
public bool MatchIsinst(Instruction instr, string typeFullName)
public bool MatchJmp(Instruction instr, MethodReference& value)
public bool MatchJmp(Instruction instr, MethodReference value)
public bool MatchJmp(Instruction instr, MethodBase value)
public bool MatchJmp(Instruction instr, Type type, string name)
public bool MatchJmp(Instruction instr, string name)
public bool MatchJmp(Instruction instr, string typeFullName, string name)
public bool MatchLdarg0(Instruction instr)
public bool MatchLdarg1(Instruction instr)
public bool MatchLdarg2(Instruction instr)
public bool MatchLdarg3(Instruction instr)
public bool MatchLdarg(Instruction instr, int value)
public bool MatchLdarg(Instruction instr, UInt32 value)
public bool MatchLdarga(Instruction instr, int value)
public bool MatchLdarga(Instruction instr, UInt32 value)
public bool MatchLdcI4(Instruction instr, int value)
public bool MatchLdcI4(Instruction instr, UInt32 value)
public bool MatchLdcI8(Instruction instr, Int64& value)
public bool MatchLdcI8(Instruction instr, long value)
public bool MatchLdcI8(Instruction instr, ulong value)
public bool MatchLdcR4(Instruction instr, Single& value)
public bool MatchLdcR4(Instruction instr, float value)
public bool MatchLdcR8(Instruction instr, Double& value)
public bool MatchLdcR8(Instruction instr, double value)
public bool MatchLdelemAny(Instruction instr, TypeReference& value)
public bool MatchLdelemAny(Instruction instr, TypeReference value)
public bool MatchLdelemAny(Instruction instr, Type value)
public bool MatchLdelemAny(Instruction instr)
public bool MatchLdelemAny(Instruction instr, string typeFullName)
public bool MatchLdelemI(Instruction instr)
public bool MatchLdelemI1(Instruction instr)
public bool MatchLdelemI2(Instruction instr)
public bool MatchLdelemI4(Instruction instr)
public bool MatchLdelemI8(Instruction instr)
public bool MatchLdelemR4(Instruction instr)
public bool MatchLdelemR8(Instruction instr)
public bool MatchLdelemRef(Instruction instr)
public bool MatchLdelemU1(Instruction instr)
public bool MatchLdelemU2(Instruction instr)
public bool MatchLdelemU4(Instruction instr)
public bool MatchLdelema(Instruction instr, TypeReference& value)
public bool MatchLdelema(Instruction instr, TypeReference value)
public bool MatchLdelema(Instruction instr, Type value)
public bool MatchLdelema(Instruction instr)
public bool MatchLdelema(Instruction instr, string typeFullName)
public bool MatchLdfld(Instruction instr, FieldReference& value)
public bool MatchLdfld(Instruction instr, FieldReference value)
public bool MatchLdfld(Instruction instr, FieldInfo value)
public bool MatchLdfld(Instruction instr, Type type, string name)
public bool MatchLdfld(Instruction instr, string name)
public bool MatchLdfld(Instruction instr, string typeFullName, string name)
public bool MatchLdflda(Instruction instr, FieldReference& value)
public bool MatchLdflda(Instruction instr, FieldReference value)
public bool MatchLdflda(Instruction instr, FieldInfo value)
public bool MatchLdflda(Instruction instr, Type type, string name)
public bool MatchLdflda(Instruction instr, string name)
public bool MatchLdflda(Instruction instr, string typeFullName, string name)
public bool MatchLdftn(Instruction instr, MethodReference& value)
public bool MatchLdftn(Instruction instr, MethodReference value)
public bool MatchLdftn(Instruction instr, MethodBase value)
public bool MatchLdftn(Instruction instr, Type type, string name)
public bool MatchLdftn(Instruction instr, string name)
public bool MatchLdftn(Instruction instr, string typeFullName, string name)
public bool MatchLdindI(Instruction instr)
public bool MatchLdindI1(Instruction instr)
public bool MatchLdindI2(Instruction instr)
public bool MatchLdindI4(Instruction instr)
public bool MatchLdindI8(Instruction instr)
public bool MatchLdindR4(Instruction instr)
public bool MatchLdindR8(Instruction instr)
public bool MatchLdindRef(Instruction instr)
public bool MatchLdindU1(Instruction instr)
public bool MatchLdindU2(Instruction instr)
public bool MatchLdindU4(Instruction instr)
public bool MatchLdlen(Instruction instr)
public bool MatchLdloc0(Instruction instr)
public bool MatchLdloc1(Instruction instr)
public bool MatchLdloc2(Instruction instr)
public bool MatchLdloc3(Instruction instr)
public bool MatchLdloc(Instruction instr, int value)
public bool MatchLdloc(Instruction instr, UInt32 value)
public bool MatchLdloca(Instruction instr, int value)
public bool MatchLdloca(Instruction instr, UInt32 value)
public bool MatchLdnull(Instruction instr)
public bool MatchLdobj(Instruction instr, TypeReference& value)
public bool MatchLdobj(Instruction instr, TypeReference value)
public bool MatchLdobj(Instruction instr, Type value)
public bool MatchLdobj(Instruction instr)
public bool MatchLdobj(Instruction instr, string typeFullName)
public bool MatchLdsfld(Instruction instr, FieldReference& value)
public bool MatchLdsfld(Instruction instr, FieldReference value)
public bool MatchLdsfld(Instruction instr, FieldInfo value)
public bool MatchLdsfld(Instruction instr, Type type, string name)
public bool MatchLdsfld(Instruction instr, string name)
public bool MatchLdsfld(Instruction instr, string typeFullName, string name)
public bool MatchLdsflda(Instruction instr, FieldReference& value)
public bool MatchLdsflda(Instruction instr, FieldReference value)
public bool MatchLdsflda(Instruction instr, FieldInfo value)
public bool MatchLdsflda(Instruction instr, Type type, string name)
public bool MatchLdsflda(Instruction instr, string name)
public bool MatchLdsflda(Instruction instr, string typeFullName, string name)
public bool MatchLdstr(Instruction instr, String& value)
public bool MatchLdstr(Instruction instr, string value)
public bool MatchLdtoken(Instruction instr, IMetadataTokenProvider& value)
public bool MatchLdtoken(Instruction instr, IMetadataTokenProvider value)
public bool MatchLdtoken(Instruction instr, Type value)
public bool MatchLdtoken(Instruction instr)
public bool MatchLdtoken(Instruction instr, FieldInfo value)
public bool MatchLdtoken(Instruction instr, MethodBase value)
public bool MatchLdvirtftn(Instruction instr, MethodReference& value)
public bool MatchLdvirtftn(Instruction instr, MethodReference value)
public bool MatchLdvirtftn(Instruction instr, MethodBase value)
public bool MatchLdvirtftn(Instruction instr, Type type, string name)
public bool MatchLdvirtftn(Instruction instr, string name)
public bool MatchLdvirtftn(Instruction instr, string typeFullName, string name)
public bool MatchLeave(Instruction instr, ILLabel& value)
public bool MatchLeave(Instruction instr, ILLabel value)
public bool MatchLeave(Instruction instr, Instruction value)
public bool MatchLocalloc(Instruction instr)
public bool MatchMkrefany(Instruction instr, TypeReference& value)
public bool MatchMkrefany(Instruction instr, TypeReference value)
public bool MatchMkrefany(Instruction instr, Type value)
public bool MatchMkrefany(Instruction instr)
public bool MatchMkrefany(Instruction instr, string typeFullName)
public bool MatchMul(Instruction instr)
public bool MatchMulOvf(Instruction instr)
public bool MatchMulOvfUn(Instruction instr)
public bool MatchNeg(Instruction instr)
public bool MatchNewarr(Instruction instr, TypeReference& value)
public bool MatchNewarr(Instruction instr, TypeReference value)
public bool MatchNewarr(Instruction instr, Type value)
public bool MatchNewarr(Instruction instr)
public bool MatchNewarr(Instruction instr, string typeFullName)
public bool MatchNewobj(Instruction instr, MethodReference& value)
public bool MatchNewobj(Instruction instr, MethodReference value)
public bool MatchNewobj(Instruction instr, MethodBase value)
public bool MatchNewobj(Instruction instr, Type type, string name)
public bool MatchNewobj(Instruction instr, string name)
public bool MatchNewobj(Instruction instr, string typeFullName, string name)
public bool MatchNop(Instruction instr)
public bool MatchNot(Instruction instr)
public bool MatchOr(Instruction instr)
public bool MatchPop(Instruction instr)
public bool MatchReadonly(Instruction instr)
public bool MatchRefanytype(Instruction instr)
public bool MatchRefanyval(Instruction instr, TypeReference& value)
public bool MatchRefanyval(Instruction instr, TypeReference value)
public bool MatchRefanyval(Instruction instr, Type value)
public bool MatchRefanyval(Instruction instr)
public bool MatchRefanyval(Instruction instr, string typeFullName)
public bool MatchRem(Instruction instr)
public bool MatchRemUn(Instruction instr)
public bool MatchRet(Instruction instr)
public bool MatchRethrow(Instruction instr)
public bool MatchShl(Instruction instr)
public bool MatchShr(Instruction instr)
public bool MatchShrUn(Instruction instr)
public bool MatchSizeof(Instruction instr, TypeReference& value)
public bool MatchSizeof(Instruction instr, TypeReference value)
public bool MatchSizeof(Instruction instr, Type value)
public bool MatchSizeof(Instruction instr)
public bool MatchSizeof(Instruction instr, string typeFullName)
public bool MatchStarg(Instruction instr, int value)
public bool MatchStarg(Instruction instr, UInt32 value)
public bool MatchStelemAny(Instruction instr, TypeReference& value)
public bool MatchStelemAny(Instruction instr, TypeReference value)
public bool MatchStelemAny(Instruction instr, Type value)
public bool MatchStelemAny(Instruction instr)
public bool MatchStelemAny(Instruction instr, string typeFullName)
public bool MatchStelemI(Instruction instr)
public bool MatchStelemI1(Instruction instr)
public bool MatchStelemI2(Instruction instr)
public bool MatchStelemI4(Instruction instr)
public bool MatchStelemI8(Instruction instr)
public bool MatchStelemR4(Instruction instr)
public bool MatchStelemR8(Instruction instr)
public bool MatchStelemRef(Instruction instr)
public bool MatchStfld(Instruction instr, FieldReference& value)
public bool MatchStfld(Instruction instr, FieldReference value)
public bool MatchStfld(Instruction instr, FieldInfo value)
public bool MatchStfld(Instruction instr, Type type, string name)
public bool MatchStfld(Instruction instr, string name)
public bool MatchStfld(Instruction instr, string typeFullName, string name)
public bool MatchStindI(Instruction instr)
public bool MatchStindI1(Instruction instr)
public bool MatchStindI2(Instruction instr)
public bool MatchStindI4(Instruction instr)
public bool MatchStindI8(Instruction instr)
public bool MatchStindR4(Instruction instr)
public bool MatchStindR8(Instruction instr)
public bool MatchStindRef(Instruction instr)
public bool MatchStloc0(Instruction instr)
public bool MatchStloc1(Instruction instr)
public bool MatchStloc2(Instruction instr)
public bool MatchStloc3(Instruction instr)
public bool MatchStloc(Instruction instr, int value)
public bool MatchStloc(Instruction instr, UInt32 value)
public bool MatchStobj(Instruction instr, TypeReference& value)
public bool MatchStobj(Instruction instr, TypeReference value)
public bool MatchStobj(Instruction instr, Type value)
public bool MatchStobj(Instruction instr)
public bool MatchStobj(Instruction instr, string typeFullName)
public bool MatchStsfld(Instruction instr, FieldReference& value)
public bool MatchStsfld(Instruction instr, FieldReference value)
public bool MatchStsfld(Instruction instr, FieldInfo value)
public bool MatchStsfld(Instruction instr, Type type, string name)
public bool MatchStsfld(Instruction instr, string name)
public bool MatchStsfld(Instruction instr, string typeFullName, string name)
public bool MatchSub(Instruction instr)
public bool MatchSubOvf(Instruction instr)
public bool MatchSubOvfUn(Instruction instr)
public bool MatchSwitch(Instruction instr, ILLabel[]& value)
public bool MatchSwitch(Instruction instr, ILLabel[] value)
public bool MatchSwitch(Instruction instr, Instruction[] value)
public bool MatchTail(Instruction instr)
public bool MatchThrow(Instruction instr)
public bool MatchUnaligned(Instruction instr, Byte& value)
public bool MatchUnaligned(Instruction instr, byte value)
public bool MatchUnbox(Instruction instr, TypeReference& value)
public bool MatchUnbox(Instruction instr, TypeReference value)
public bool MatchUnbox(Instruction instr, Type value)
public bool MatchUnbox(Instruction instr)
public bool MatchUnbox(Instruction instr, string typeFullName)
public bool MatchUnboxAny(Instruction instr, TypeReference& value)
public bool MatchUnboxAny(Instruction instr, TypeReference value)
public bool MatchUnboxAny(Instruction instr, Type value)
public bool MatchUnboxAny(Instruction instr)
public bool MatchUnboxAny(Instruction instr, string typeFullName)
public bool MatchVolatile(Instruction instr)
public bool MatchXor(Instruction instr)
}
internal MonoMod.Cil.MoveType : Enum {
public int value__
public MoveType Before
public MoveType AfterLabel
public MoveType After
}
internal MonoMod.Cil.SearchTarget : Enum {
public int value__
public SearchTarget None
public SearchTarget Next
public SearchTarget Prev
}
internal MonoMod.Core.AssemblyInfo : object {
public string AssemblyName
public string AssemblyVersion
}
internal MonoMod.Core.CreateDetourRequest : ValueType {
private MethodBase <Source>k__BackingField
private MethodBase <Target>k__BackingField
private bool <ApplyByDefault>k__BackingField
public MethodBase Source
public MethodBase Target
public bool ApplyByDefault
public void .ctor(MethodBase Source, MethodBase Target)
public MethodBase get_Source()
public Void modreq(System.Runtime.CompilerServices.<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>IsExternalInit) set_Source(MethodBase value)
public MethodBase get_Target()
public Void modreq(System.Runtime.CompilerServices.<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>IsExternalInit) set_Target(MethodBase value)
public bool get_ApplyByDefault()
public Void modreq(System.Runtime.CompilerServices.<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>IsExternalInit) set_ApplyByDefault(bool value)
public string ToString()
private bool PrintMembers(StringBuilder builder)
public bool op_Inequality(CreateDetourRequest left, CreateDetourRequest right)
public bool op_Equality(CreateDetourRequest left, CreateDetourRequest right)
public int GetHashCode()
public bool Equals(object obj)
public bool Equals(CreateDetourRequest other)
public void Deconstruct(MethodBase& Source, MethodBase& Target)
}
internal MonoMod.Core.CreateNativeDetourRequest : ValueType {
private IntPtr <Source>k__BackingField
private IntPtr <Target>k__BackingField
private bool <ApplyByDefault>k__BackingField
public IntPtr Source
public IntPtr Target
public bool ApplyByDefault
public void .ctor(IntPtr Source, IntPtr Target)
public IntPtr get_Source()
public Void modreq(System.Runtime.CompilerServices.<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>IsExternalInit) set_Source(IntPtr value)
public IntPtr get_Target()
public Void modreq(System.Runtime.CompilerServices.<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>IsExternalInit) set_Target(IntPtr value)
public bool get_ApplyByDefault()
public Void modreq(System.Runtime.CompilerServices.<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>IsExternalInit) set_ApplyByDefault(bool value)
public string ToString()
private bool PrintMembers(StringBuilder builder)
public bool op_Inequality(CreateNativeDetourRequest left, CreateNativeDetourRequest right)
public bool op_Equality(CreateNativeDetourRequest left, CreateNativeDetourRequest right)
public int GetHashCode()
public bool Equals(object obj)
public bool Equals(CreateNativeDetourRequest other)
public void Deconstruct(IntPtr& Source, IntPtr& Target)
}
internal MonoMod.Core.DetourFactory : object {
private PlatformTripleDetourFactory lazyCurrent
public IDetourFactory Current
public IDetourFactory get_Current()
private PlatformTripleDetourFactory CreateDefaultFactory()
public ICoreDetour CreateDetour(IDetourFactory factory, MethodBase source, MethodBase target, bool applyByDefault)
public ICoreNativeDetour CreateNativeDetour(IDetourFactory factory, IntPtr source, IntPtr target, bool applyByDefault)
}
internal MonoMod.Core.ICoreDetour {
public MethodBase Source
public MethodBase Target
public MethodBase get_Source()
public MethodBase get_Target()
}
internal MonoMod.Core.ICoreDetourBase {
public bool IsApplied
public bool get_IsApplied()
public void Apply()
public void Undo()
}
internal MonoMod.Core.ICoreNativeDetour {
public IntPtr Source
public IntPtr Target
public bool HasOrigEntrypoint
public IntPtr OrigEntrypoint
public IntPtr get_Source()
public IntPtr get_Target()
public bool get_HasOrigEntrypoint()
public IntPtr get_OrigEntrypoint()
}
internal MonoMod.Core.IDetourFactory {
public ICoreDetour CreateDetour(CreateDetourRequest request)
public ICoreNativeDetour CreateNativeDetour(CreateNativeDetourRequest request)
}
internal MonoMod.Core.Interop.Attributes.FatInterfaceImplAttribute : Attribute {
private Type <FatInterface>k__BackingField
public Type FatInterface
public Type get_FatInterface()
public void .ctor(Type fatInterface)
}
internal MonoMod.Core.Interop.Attributes.MultipurposeSlotOffsetTableAttribute : Attribute {
private int <Bits>k__BackingField
private Type <HelperType>k__BackingField
public int Bits
public Type HelperType
public int get_Bits()
public Type get_HelperType()
public void .ctor(int bits, Type helperType)
}
internal MonoMod.Core.Interop.OSX : object {
public string LibSystem
private Int32* mach_task_self_
public int Errno
public int GetPageSize()
public void sys_icache_invalidate(Void* start, UIntPtr size)
public int MkSTemp(Byte* template)
public Int32* __error()
public int get_Errno()
public kern_return_t mach_vm_region_recurse(int targetTask, UInt64* address, UInt64* size, Int32* nestingDepth, vm_region_submap_short_info_64* info, Int32* infoSize)
public kern_return_t mach_vm_protect(int targetTask, ulong address, ulong size, boolean_t setMax, vm_prot_t protection)
public kern_return_t mach_vm_allocate(int targetTask, UInt64* address, ulong size, vm_flags flags)
public kern_return_t mach_vm_map(int targetTask, UInt64* address, ulong size, ulong mask, vm_flags flags, int object, ulong offset, boolean_t copy, vm_prot_t curProt, vm_prot_t maxProt, vm_inherit_t inheritance)
public kern_return_t mach_vm_remap(int targetTask, UInt64* targetAddress, ulong size, ulong offset, vm_flags flags, int srcTask, ulong srcAddress, boolean_t copy, vm_prot_t* curProt, vm_prot_t* maxProt, vm_inherit_t inherit)
public kern_return_t mach_make_memory_entry_64(int targetTask, UInt64* size, ulong offset, vm_prot_t permission, Int32* objectHandle, int parentHandle)
public kern_return_t mach_vm_deallocate(int targetTask, ulong address, ulong size)
public int mach_task_self()
public kern_return_t task_info(int targetTask, task_flavor_t flavor, task_dyld_info* taskInfoOut, Int32* taskInfoCnt)
public VmProtFmtProxy P(vm_prot_t prot)
}
internal MonoMod.Core.Interop.PCSTR : ValueType {
internal Byte* Value
internal int Length
private string DebuggerDisplay
internal void .ctor(Byte* value)
public Byte* op_Implicit(PCSTR value)
public PCSTR op_Explicit(Byte* value)
public bool Equals(PCSTR other)
public bool Equals(object obj)
public int GetHashCode()
internal int get_Length()
public string ToString()
private string get_DebuggerDisplay()
internal ReadOnlySpan`1<byte> AsSpan()
}
internal MonoMod.Core.Interop.Unix : object {
public string LibC
public int Errno
public IntPtr Read(int fd, IntPtr buf, IntPtr count)
public IntPtr Write(int fd, IntPtr buf, IntPtr count)
public int Pipe2(Int32* pipefd, PipeFlags flags)
public IntPtr Mmap(IntPtr addr, UIntPtr length, Protection prot, MmapFlags flags, int fd, int offset)
public int Munmap(IntPtr addr, UIntPtr length)
public int Mprotect(IntPtr addr, UIntPtr len, Protection prot)
public long Sysconf(SysconfName name)
public int Mincore(IntPtr addr, UIntPtr len, Byte* vec)
public int MkSTemp(Byte* template)
public Int32* __errno_location()
public int get_Errno()
}
internal MonoMod.Core.Interop.Windows : object {
public int MEM_COMMIT
public int MEM_RESERVE
public int MEM_REPLACE_PLACEHOLDER
public int MEM_RESERVE_PLACEHOLDER
public int MEM_RESET
public int MEM_TOP_DOWN
public int MEM_WRITE_WATCH
public int MEM_PHYSICAL
public int MEM_ROTATE
public int MEM_DIFFERENT_IMAGE_BASE_OK
public int MEM_RESET_UNDO
public int MEM_LARGE_PAGES
public UInt32 MEM_4MB_PAGES
public int MEM_64K_PAGES
public int MEM_UNMAP_WITH_TRANSIENT_BOOST
public int MEM_COALESCE_PLACEHOLDERS
public int MEM_PRESERVE_PLACEHOLDER
public int MEM_DECOMMIT
public int MEM_RELEASE
public int MEM_FREE
public int MEM_EXTENDED_PARAMETER_GRAPHICS
public int MEM_EXTENDED_PARAMETER_NONPAGED
public int MEM_EXTENDED_PARAMETER_ZERO_PAGES_OPTIONAL
public int MEM_EXTENDED_PARAMETER_NONPAGED_LARGE
public int MEM_EXTENDED_PARAMETER_NONPAGED_HUGE
public int MEM_EXTENDED_PARAMETER_SOFT_FAULT_PAGES
public int MEM_EXTENDED_PARAMETER_EC_CODE
public int MEM_EXTENDED_PARAMETER_IMAGE_NO_HPAT
public long MEM_EXTENDED_PARAMETER_NUMA_NODE_MANDATORY
public int MEM_EXTENDED_PARAMETER_TYPE_BITS
public ulong MEM_DEDICATED_ATTRIBUTE_NOT_SPECIFIED
public int MEM_PRIVATE
public int MEM_MAPPED
public int MEM_IMAGE
public int PAGE_NOACCESS
public int PAGE_READONLY
public int PAGE_READWRITE
public int PAGE_WRITECOPY
public int PAGE_EXECUTE
public int PAGE_EXECUTE_READ
public int PAGE_EXECUTE_READWRITE
public int PAGE_EXECUTE_WRITECOPY
public int PAGE_GUARD
public int PAGE_NOCACHE
public int PAGE_WRITECOMBINE
public int PAGE_GRAPHICS_NOACCESS
public int PAGE_GRAPHICS_READONLY
public int PAGE_GRAPHICS_READWRITE
public int PAGE_GRAPHICS_EXECUTE
public int PAGE_GRAPHICS_EXECUTE_READ
public int PAGE_GRAPHICS_EXECUTE_READWRITE
public int PAGE_GRAPHICS_COHERENT
public int PAGE_GRAPHICS_NOCACHE
public UInt32 PAGE_ENCLAVE_THREAD_CONTROL
public UInt32 PAGE_REVERT_TO_FILE_MAP
public int PAGE_TARGETS_NO_UPDATE
public int PAGE_TARGETS_INVALID
public int PAGE_ENCLAVE_UNVALIDATED
public int PAGE_ENCLAVE_MASK
public int PAGE_ENCLAVE_DECOMMIT
public int PAGE_ENCLAVE_SS_FIRST
public int PAGE_ENCLAVE_SS_REST
public int PROCESSOR_ARCHITECTURE_INTEL
public int PROCESSOR_ARCHITECTURE_MIPS
public int PROCESSOR_ARCHITECTURE_ALPHA
public int PROCESSOR_ARCHITECTURE_PPC
public int PROCESSOR_ARCHITECTURE_SHX
public int PROCESSOR_ARCHITECTURE_ARM
public int PROCESSOR_ARCHITECTURE_IA64
public int PROCESSOR_ARCHITECTURE_ALPHA64
public int PROCESSOR_ARCHITECTURE_MSIL
public int PROCESSOR_ARCHITECTURE_AMD64
public int PROCESSOR_ARCHITECTURE_IA32_ON_WIN64
public int PROCESSOR_ARCHITECTURE_NEUTRAL
public int PROCESSOR_ARCHITECTURE_ARM64
public int PROCESSOR_ARCHITECTURE_ARM32_ON_WIN64
public int PROCESSOR_ARCHITECTURE_IA32_ON_ARM64
public int PROCESSOR_ARCHITECTURE_UNKNOWN
public Void* VirtualAlloc(Void* lpAddress, UIntPtr dwSize, UInt32 flAllocationType, UInt32 flProtect)
public BOOL VirtualProtect(Void* lpAddress, UIntPtr dwSize, UInt32 flNewProtect, UInt32* lpflOldProtect)
public BOOL VirtualFree(Void* lpAddress, UIntPtr dwSize, UInt32 dwFreeType)
public UIntPtr VirtualQuery(Void* lpAddress, MEMORY_BASIC_INFORMATION* lpBuffer, UIntPtr dwLength)
public void GetSystemInfo(SYSTEM_INFO* lpSystemInfo)
public HANDLE GetCurrentProcess()
public BOOL FlushInstructionCache(HANDLE hProcess, Void* lpBaseAddress, UIntPtr dwSize)
public UInt32 GetLastError()
}
internal MonoMod.Core.Platforms.Abi : ValueType {
private ReadOnlyMemory`1<SpecialArgumentKind> <ArgumentOrder>k__BackingField
private Classifier <Classifier>k__BackingField
private bool <ReturnsReturnBuffer>k__BackingField
public ReadOnlyMemory`1<SpecialArgumentKind> ArgumentOrder
public Classifier Classifier
public bool ReturnsReturnBuffer
public void .ctor(ReadOnlyMemory`1<SpecialArgumentKind> ArgumentOrder, Classifier Classifier, bool ReturnsReturnBuffer)
public ReadOnlyMemory`1<SpecialArgumentKind> get_ArgumentOrder()
public Void modreq(System.Runtime.CompilerServices.<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>IsExternalInit) set_ArgumentOrder(ReadOnlyMemory`1<SpecialArgumentKind> value)
public Classifier get_Classifier()
public Void modreq(System.Runtime.CompilerServices.<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>IsExternalInit) set_Classifier(Classifier value)
public bool get_ReturnsReturnBuffer()
public Void modreq(System.Runtime.CompilerServices.<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>IsExternalInit) set_ReturnsReturnBuffer(bool value)
public TypeClassification Classify(Type type, bool isReturn)
public string ToString()
private bool PrintMembers(StringBuilder builder)
public bool op_Inequality(Abi left, Abi right)
public bool op_Equality(Abi left, Abi right)
public int GetHashCode()
public bool Equals(object obj)
public bool Equals(Abi other)
public void Deconstruct(ReadOnlyMemory`1& ArgumentOrder, Classifier& Classifier, Boolean& ReturnsReturnBuffer)
}
internal MonoMod.Core.Platforms.AllocationRequest : ValueType {
private int <Size>k__BackingField
private int <Alignment>k__BackingField
private bool <Executable>k__BackingField
public int Size
public int Alignment
public bool Executable
public void .ctor(int Size)
public int get_Size()
public Void modreq(System.Runtime.CompilerServices.<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>IsExternalInit) set_Size(int value)
public int get_Alignment()
public Void modreq(System.Runtime.CompilerServices.<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>IsExternalInit) set_Alignment(int value)
public bool get_Executable()
public Void modreq(System.Runtime.CompilerServices.<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>IsExternalInit) set_Executable(bool value)
public string ToString()
private bool PrintMembers(StringBuilder builder)
public bool op_Inequality(AllocationRequest left, AllocationRequest right)
public bool op_Equality(AllocationRequest left, AllocationRequest right)
public int GetHashCode()
public bool Equals(object obj)
public bool Equals(AllocationRequest other)
public void Deconstruct(Int32& Size)
}
internal MonoMod.Core.Platforms.ArchitectureFeature : Enum {
public int value__
public ArchitectureFeature None
public ArchitectureFeature FixedInstructionSize
public ArchitectureFeature Immediate64
public ArchitectureFeature CreateAltEntryPoint
}
internal MonoMod.Core.Platforms.Architectures.AltEntryFactories.IcedAltEntryFactory : object {
private ISystem system
private IMemoryAllocator alloc
private int bitness
public void .ctor(ISystem system, int bitness)
public IntPtr CreateAlternateEntrypoint(IntPtr entrypoint, int minLength, IDisposable& handle)
}
internal MonoMod.Core.Platforms.Architectures.DetourKindBase : object {
public int Size
public int get_Size()
public int GetBytes(IntPtr from, IntPtr to, Span`1<byte> buffer, object data, IDisposable& allocHandle)
public int GetDetourBytes(NativeDetourInfo info, Span`1<byte> buffer, IDisposable& allocHandle)
public bool TryGetRetargetInfo(NativeDetourInfo orig, IntPtr to, int maxSize, NativeDetourInfo& retargetInfo)
public bool TryFindRetargetInfo(NativeDetourInfo info, IntPtr to, int maxSize, NativeDetourInfo& retargetInfo)
public int DoRetarget(NativeDetourInfo origInfo, IntPtr to, Span`1<byte> buffer, object data, IDisposable& allocationHandle, Boolean& needsRepatch, Boolean& disposeOldAlloc)
public int DoRetarget(NativeDetourInfo orig, NativeDetourInfo info, Span`1<byte> buffer, IDisposable& allocationHandle, Boolean& needsRepatch, Boolean& disposeOldAlloc)
}
internal MonoMod.Core.Platforms.Architectures.Shared : object {
public ReadOnlyMemory`1<IAllocatedMemory> CreateVtableStubs(ISystem system, IntPtr vtableBase, int vtableSize, ReadOnlySpan`1<byte> stubData, int indexOffs, bool premulOffset)
internal void <CreateVtableStubs>g__FillBufferIndicies|0_0(int stubSize, int indexOffs, int numPerAlloc, int i, Span`1<byte> mainAllocBuf, bool premul)
internal void <CreateVtableStubs>g__FillVtbl|0_1(int stubSize, int baseIndex, IntPtr& vtblBase, int numEntries, IntPtr baseAddr)
}
internal MonoMod.Core.Platforms.Architectures.x86_64Arch : object {
private BytePatternCollection lazyKnownMethodThunks
private IAltEntryFactory <AltEntryFactory>k__BackingField
private ISystem system
private int VtblProxyStubIdxOffs
private bool VtblProxyStubIdxPremul
private int SpecEntryStubArgOffs
private int SpecEntryStubTargetOffs
public ArchitectureKind Target
public ArchitectureFeature Features
public BytePatternCollection KnownMethodThunks
public IAltEntryFactory AltEntryFactory
private ReadOnlySpan`1<byte> VtblProxyStubWin
private ReadOnlySpan`1<byte> VtblProxyStubSysV
private ReadOnlySpan`1<byte> SpecEntryStub
public ArchitectureKind get_Target()
public ArchitectureFeature get_Features()
public BytePatternCollection get_KnownMethodThunks()
public IAltEntryFactory get_AltEntryFactory()
private BytePatternCollection CreateKnownMethodThunks()
public void .ctor(ISystem system)
public NativeDetourInfo ComputeDetourInfo(IntPtr from, IntPtr to, int sizeHint)
public int GetDetourBytes(NativeDetourInfo info, Span`1<byte> buffer, IDisposable& allocHandle)
public NativeDetourInfo ComputeRetargetInfo(NativeDetourInfo detour, IntPtr to, int maxSizeHint)
public int GetRetargetBytes(NativeDetourInfo original, NativeDetourInfo retarget, Span`1<byte> buffer, IDisposable& allocationHandle, Boolean& needsRepatch, Boolean& disposeOldAlloc)
private ReadOnlySpan`1<byte> get_VtblProxyStubWin()
private ReadOnlySpan`1<byte> get_VtblProxyStubSysV()
public ReadOnlyMemory`1<IAllocatedMemory> CreateNativeVtableProxyStubs(IntPtr vtableBase, int vtableSize)
private ReadOnlySpan`1<byte> get_SpecEntryStub()
public IAllocatedMemory CreateSpecialEntryStub(IntPtr target, IntPtr argument)
}
internal MonoMod.Core.Platforms.Architectures.x86Arch : object {
private BytePatternCollection lazyKnownMethodThunks
private IAltEntryFactory <AltEntryFactory>k__BackingField
private ISystem system
private int WinThisVtableThunkIndexOffs
private int SpecEntryStubArgOffs
private int SpecEntryStubTargetOffs
public ArchitectureKind Target
public ArchitectureFeature Features
public BytePatternCollection KnownMethodThunks
public IAltEntryFactory AltEntryFactory
private ReadOnlySpan`1<byte> WinThisVtableProxyThunk
private ReadOnlySpan`1<byte> SpecEntryStub
public ArchitectureKind get_Target()
public ArchitectureFeature get_Features()
public BytePatternCollection get_KnownMethodThunks()
public IAltEntryFactory get_AltEntryFactory()
private BytePatternCollection CreateKnownMethodThunks()
public NativeDetourInfo ComputeDetourInfo(IntPtr from, IntPtr to, int maxSizeHint)
public int GetDetourBytes(NativeDetourInfo info, Span`1<byte> buffer, IDisposable& allocationHandle)
public NativeDetourInfo ComputeRetargetInfo(NativeDetourInfo detour, IntPtr to, int maxSizeHint)
public int GetRetargetBytes(NativeDetourInfo original, NativeDetourInfo retarget, Span`1<byte> buffer, IDisposable& allocationHandle, Boolean& needsRepatch, Boolean& disposeOldAlloc)
public void .ctor(ISystem system)
private ReadOnlySpan`1<byte> get_WinThisVtableProxyThunk()
public ReadOnlyMemory`1<IAllocatedMemory> CreateNativeVtableProxyStubs(IntPtr vtableBase, int vtableSize)
private ReadOnlySpan`1<byte> get_SpecEntryStub()
public IAllocatedMemory CreateSpecialEntryStub(IntPtr target, IntPtr argument)
}
internal MonoMod.Core.Platforms.Architectures.x86Shared : object {
public void FixSizeHint(Int32& sizeHint)
public bool TryRel32Detour(IntPtr from, IntPtr to, int sizeHint, NativeDetourInfo& info)
public bool Is32Bit(long to)
}
internal MonoMod.Core.Platforms.Classifier : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public TypeClassification Invoke(Type type, bool isReturn)
public IAsyncResult BeginInvoke(Type type, bool isReturn, AsyncCallback callback, object object)
public TypeClassification EndInvoke(IAsyncResult result)
}
internal MonoMod.Core.Platforms.FeatureFlags : ValueType {
private ArchitectureFeature <Architecture>k__BackingField
private SystemFeature <System>k__BackingField
private RuntimeFeature <Runtime>k__BackingField
public ArchitectureFeature Architecture
public SystemFeature System
public RuntimeFeature Runtime
public ArchitectureFeature get_Architecture()
public SystemFeature get_System()
public RuntimeFeature get_Runtime()
public void .ctor(ArchitectureFeature archFlags, SystemFeature sysFlags, RuntimeFeature runtimeFlags)
public bool Has(RuntimeFeature feature)
public bool Has(ArchitectureFeature feature)
public bool Has(SystemFeature feature)
public bool Equals(object obj)
public bool Equals(FeatureFlags other)
public int GetHashCode()
public string ToString()
public bool op_Equality(FeatureFlags left, FeatureFlags right)
public bool op_Inequality(FeatureFlags left, FeatureFlags right)
}
internal MonoMod.Core.Platforms.GetExceptionSlot : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public IntPtr* Invoke()
public IAsyncResult BeginInvoke(AsyncCallback callback, object object)
public IntPtr* EndInvoke(IAsyncResult result)
}
internal MonoMod.Core.Platforms.IAllocatedMemory {
public bool IsExecutable
public IntPtr BaseAddress
public int Size
public Span`1<byte> Memory
public bool get_IsExecutable()
public IntPtr get_BaseAddress()
public int get_Size()
public Span`1<byte> get_Memory()
}
internal MonoMod.Core.Platforms.IAltEntryFactory {
public IntPtr CreateAlternateEntrypoint(IntPtr entrypoint, int minLength, IDisposable& handle)
}
internal MonoMod.Core.Platforms.IArchitecture {
public ArchitectureKind Target
public ArchitectureFeature Features
public BytePatternCollection KnownMethodThunks
public IAltEntryFactory AltEntryFactory
public ArchitectureKind get_Target()
public ArchitectureFeature get_Features()
public BytePatternCollection get_KnownMethodThunks()
public IAltEntryFactory get_AltEntryFactory()
public NativeDetourInfo ComputeDetourInfo(IntPtr from, IntPtr target, int maxSizeHint)
public int GetDetourBytes(NativeDetourInfo info, Span`1<byte> buffer, IDisposable& allocationHandle)
public NativeDetourInfo ComputeRetargetInfo(NativeDetourInfo detour, IntPtr target, int maxSizeHint)
public int GetRetargetBytes(NativeDetourInfo original, NativeDetourInfo retarget, Span`1<byte> buffer, IDisposable& allocationHandle, Boolean& needsRepatch, Boolean& disposeOldAlloc)
public ReadOnlyMemory`1<IAllocatedMemory> CreateNativeVtableProxyStubs(IntPtr vtableBase, int vtableSize)
public IAllocatedMemory CreateSpecialEntryStub(IntPtr target, IntPtr argument)
}
internal MonoMod.Core.Platforms.IMemoryAllocator {
public int MaxSize
public int get_MaxSize()
public bool TryAllocate(AllocationRequest request, IAllocatedMemory& allocated)
public bool TryAllocateInRange(PositionedAllocationRequest request, IAllocatedMemory& allocated)
}
internal MonoMod.Core.Platforms.INativeDetourKind {
public int Size
public int get_Size()
}
internal MonoMod.Core.Platforms.INativeExceptionHelper {
public GetExceptionSlot GetExceptionSlot
public GetExceptionSlot get_GetExceptionSlot()
public IntPtr CreateNativeToManagedHelper(IntPtr target, IDisposable& handle)
public IntPtr CreateManagedToNativeHelper(IntPtr target, IDisposable& handle)
}
internal MonoMod.Core.Platforms.IRuntime {
public RuntimeKind Target
public RuntimeFeature Features
public Abi Abi
public RuntimeKind get_Target()
public RuntimeFeature get_Features()
public Abi get_Abi()
public void add_OnMethodCompiled(OnMethodCompiledCallback value)
public void remove_OnMethodCompiled(OnMethodCompiledCallback value)
public MethodBase GetIdentifiable(MethodBase method)
public RuntimeMethodHandle GetMethodHandle(MethodBase method)
public void DisableInlining(MethodBase method)
public IDisposable PinMethodIfNeeded(MethodBase method)
public IntPtr GetMethodEntryPoint(MethodBase method)
public void Compile(MethodBase method)
}
internal MonoMod.Core.Platforms.ISystem {
public OSKind Target
public SystemFeature Features
public Nullable`1<Abi> DefaultAbi
public IMemoryAllocator MemoryAllocator
public INativeExceptionHelper NativeExceptionHelper
public OSKind get_Target()
public SystemFeature get_Features()
public Nullable`1<Abi> get_DefaultAbi()
public IMemoryAllocator get_MemoryAllocator()
public INativeExceptionHelper get_NativeExceptionHelper()
public IEnumerable`1<string> EnumerateLoadedModuleFiles()
public IntPtr GetSizeOfReadableMemory(IntPtr start, IntPtr guess)
public void PatchData(PatchTargetKind targetKind, IntPtr patchTarget, ReadOnlySpan`1<byte> data, Span`1<byte> backup)
}
internal MonoMod.Core.Platforms.Memory.PagedMemoryAllocator : object {
private IntPtr pageBaseMask
private IntPtr pageSize
private bool pageSizeIsPow2
private Page[] allocationList
private int pageCount
private ConcurrentBag`1<Page> pagesToClean
private int registeredForCleanup
private object sync
protected IntPtr PageSize
private ReadOnlySpan`1<Page> AllocList
public int MaxSize
protected IntPtr get_PageSize()
protected void .ctor(IntPtr pageSize)
public IntPtr RoundDownToPageBoundary(IntPtr addr)
protected void InsertAllocatedPage(Page page)
private void RemoveAllocatedPage(Page page)
private ReadOnlySpan`1<Page> get_AllocList()
private int GetBoundIndex(IntPtr ptr)
protected void RegisterForCleanup(Page page)
private bool DoCleanup()
protected bool TryFreePage(Page page, String& errorMsg)
public int get_MaxSize()
public bool TryAllocateInRange(PositionedAllocationRequest request, IAllocatedMemory& allocated)
private bool TryAllocWithPage(Page page, PositionedAllocationRequest request, IAllocatedMemory& allocated)
public bool TryAllocate(AllocationRequest request, IAllocatedMemory& allocated)
protected bool TryAllocateNewPage(AllocationRequest request, IAllocatedMemory& allocated)
protected bool TryAllocateNewPage(PositionedAllocationRequest request, IntPtr targetPage, IntPtr lowPageBound, IntPtr highPageBound, IAllocatedMemory& allocated)
}
internal MonoMod.Core.Platforms.Memory.QueryingMemoryPageAllocatorBase : object {
public UInt32 PageSize
public UInt32 get_PageSize()
public bool TryQueryPage(IntPtr pageAddr, Boolean& isFree, IntPtr& allocBase, IntPtr& allocSize)
public bool TryAllocatePage(IntPtr size, bool executable, IntPtr& allocated)
public bool TryAllocatePage(IntPtr pageAddr, IntPtr size, bool executable, IntPtr& allocated)
public bool TryFreePage(IntPtr pageAddr, String& errorMsg)
}
internal MonoMod.Core.Platforms.Memory.QueryingPagedMemoryAllocator : PagedMemoryAllocator {
private QueryingMemoryPageAllocatorBase pageAlloc
public void .ctor(QueryingMemoryPageAllocatorBase alloc)
protected bool TryAllocateNewPage(AllocationRequest request, IAllocatedMemory& allocated)
protected bool TryAllocateNewPage(PositionedAllocationRequest request, IntPtr targetPage, IntPtr lowPageBound, IntPtr highPageBound, IAllocatedMemory& allocated)
private bool TryAllocNewPage(PositionedAllocationRequest request, IntPtr& page, bool goingUp, IAllocatedMemory& allocated)
protected bool TryFreePage(Page page, String& errorMsg)
}
internal MonoMod.Core.Platforms.NativeDetourInfo : ValueType {
private IntPtr <From>k__BackingField
private IntPtr <To>k__BackingField
private INativeDetourKind <InternalKind>k__BackingField
private IDisposable <InternalData>k__BackingField
public IntPtr From
public IntPtr To
public INativeDetourKind InternalKind
public IDisposable InternalData
public int Size
public void .ctor(IntPtr From, IntPtr To, INativeDetourKind InternalKind, IDisposable InternalData)
public IntPtr get_From()
public Void modreq(System.Runtime.CompilerServices.<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>IsExternalInit) set_From(IntPtr value)
public IntPtr get_To()
public Void modreq(System.Runtime.CompilerServices.<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>IsExternalInit) set_To(IntPtr value)
public INativeDetourKind get_InternalKind()
public Void modreq(System.Runtime.CompilerServices.<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>IsExternalInit) set_InternalKind(INativeDetourKind value)
public IDisposable get_InternalData()
public Void modreq(System.Runtime.CompilerServices.<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>IsExternalInit) set_InternalData(IDisposable value)
public int get_Size()
public string ToString()
private bool PrintMembers(StringBuilder builder)
public bool op_Inequality(NativeDetourInfo left, NativeDetourInfo right)
public bool op_Equality(NativeDetourInfo left, NativeDetourInfo right)
public int GetHashCode()
public bool Equals(object obj)
public bool Equals(NativeDetourInfo other)
public void Deconstruct(IntPtr& From, IntPtr& To, INativeDetourKind& InternalKind, IDisposable& InternalData)
}
internal MonoMod.Core.Platforms.OnMethodCompiledCallback : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(RuntimeMethodHandle methodHandle, MethodBase method, IntPtr codeStart, IntPtr codeRw, ulong codeSize)
public IAsyncResult BeginInvoke(RuntimeMethodHandle methodHandle, MethodBase method, IntPtr codeStart, IntPtr codeRw, ulong codeSize, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
internal MonoMod.Core.Platforms.PatchTargetKind : Enum {
public int value__
public PatchTargetKind Executable
public PatchTargetKind ReadOnly
}
internal MonoMod.Core.Platforms.PlatformTriple : object {
private IArchitecture <Architecture>k__BackingField
private ISystem <System>k__BackingField
private IRuntime <Runtime>k__BackingField
private object lazyCurrentLock
private PlatformTriple lazyCurrent
private FeatureFlags <SupportedFeatures>k__BackingField
private Abi <Abi>k__BackingField
private IntPtr ThePreStub
public IArchitecture Architecture
public ISystem System
public IRuntime Runtime
public PlatformTriple Current
public ValueTuple`3<ArchitectureKind, OSKind, RuntimeKind> HostTriple
public FeatureFlags SupportedFeatures
public Abi Abi
public IRuntime CreateCurrentRuntime(ISystem system, IArchitecture arch)
public IArchitecture CreateCurrentArchitecture(ISystem system)
public ISystem CreateCurrentSystem()
public IArchitecture get_Architecture()
public ISystem get_System()
public IRuntime get_Runtime()
public PlatformTriple get_Current()
private PlatformTriple CreateCurrent()
public void SetPlatformTriple(PlatformTriple triple)
private void ThrowTripleAlreadyExists()
public void .ctor(IArchitecture architecture, ISystem system, IRuntime runtime)
private void InitIfNeeded(object obj)
public ValueTuple`3<ArchitectureKind, OSKind, RuntimeKind> get_HostTriple()
public FeatureFlags get_SupportedFeatures()
public Abi get_Abi()
public void Compile(MethodBase method)
public MethodBase GetIdentifiable(MethodBase method)
public IDisposable PinMethodIfNeeded(MethodBase method)
public bool TryDisableInlining(MethodBase method)
public SimpleNativeDetour CreateSimpleDetour(IntPtr from, IntPtr to, int detourMaxSize, IntPtr fromRw)
public NativeDetour CreateNativeDetour(IntPtr from, IntPtr to, int detourMaxSize, IntPtr fromRw)
public IntPtr GetNativeMethodBody(MethodBase method)
private IntPtr GetNativeMethodBodyWalk(MethodBase method, bool reloadPtr)
private IntPtr GetNativeMethodBodyDirect(MethodBase method)
private IntPtr NotThePreStub(IntPtr ptrGot, IntPtr ptrParsed, Boolean& wasPreStub)
public MethodBase GetRealDetourTarget(MethodBase from, MethodBase to)
private IntPtr <NotThePreStub>b__40_0(MethodInfo m)
}
internal MonoMod.Core.Platforms.PlatformTripleDetourFactory : object {
private PlatformTriple triple
public void .ctor(PlatformTriple triple)
public ICoreDetour CreateDetour(CreateDetourRequest request)
public ICoreNativeDetour CreateNativeDetour(CreateNativeDetourRequest request)
}
internal MonoMod.Core.Platforms.PositionedAllocationRequest : ValueType {
private IntPtr <Target>k__BackingField
private IntPtr <LowBound>k__BackingField
private IntPtr <HighBound>k__BackingField
private AllocationRequest <Base>k__BackingField
public IntPtr Target
public IntPtr LowBound
public IntPtr HighBound
public AllocationRequest Base
public void .ctor(IntPtr Target, IntPtr LowBound, IntPtr HighBound, AllocationRequest Base)
public IntPtr get_Target()
public Void modreq(System.Runtime.CompilerServices.<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>IsExternalInit) set_Target(IntPtr value)
public IntPtr get_LowBound()
public Void modreq(System.Runtime.CompilerServices.<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>IsExternalInit) set_LowBound(IntPtr value)
public IntPtr get_HighBound()
public Void modreq(System.Runtime.CompilerServices.<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>IsExternalInit) set_HighBound(IntPtr value)
public AllocationRequest get_Base()
public Void modreq(System.Runtime.CompilerServices.<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>IsExternalInit) set_Base(AllocationRequest value)
public string ToString()
private bool PrintMembers(StringBuilder builder)
public bool op_Inequality(PositionedAllocationRequest left, PositionedAllocationRequest right)
public bool op_Equality(PositionedAllocationRequest left, PositionedAllocationRequest right)
public int GetHashCode()
public bool Equals(object obj)
public bool Equals(PositionedAllocationRequest other)
public void Deconstruct(IntPtr& Target, IntPtr& LowBound, IntPtr& HighBound, AllocationRequest& Base)
}
internal MonoMod.Core.Platforms.RuntimeFeature : Enum {
public int value__
public RuntimeFeature None
public RuntimeFeature PreciseGC
public RuntimeFeature CompileMethodHook
public RuntimeFeature ILDetour
public RuntimeFeature GenericSharing
public RuntimeFeature ListGenericInstantiations
public RuntimeFeature DisableInlining
public RuntimeFeature Uninlining
public RuntimeFeature RequiresMethodPinning
public RuntimeFeature RequiresMethodIdentification
public RuntimeFeature RequiresBodyThunkWalking
public RuntimeFeature HasKnownABI
public RuntimeFeature RequiresCustomMethodCompile
}
internal MonoMod.Core.Platforms.Runtimes.Core21Runtime : CoreBaseRuntime {
private object sync
private JitHookHelpersHolder lazyJitHookHelpers
private Guid JitVersionGuid
private Delegate ourCompileMethod
private IDisposable n2mHookHelper
private IDisposable m2nHookHelper
private FieldInfo RuntimeAssemblyPtrField
public RuntimeFeature Features
protected JitHookHelpersHolder JitHookHelpers
protected Guid ExpectedJitVersion
protected int VtableIndexICorJitCompilerGetVersionGuid
protected int VtableIndexICorJitCompilerCompileMethod
protected InvokeCompileMethodPtr InvokeCompileMethodPtr
public RuntimeFeature get_Features()
public void .ctor(ISystem system)
private JitHookHelpersHolder CreateJitHookHelpers(Core21Runtime self)
protected JitHookHelpersHolder get_JitHookHelpers()
protected Guid get_ExpectedJitVersion()
protected int get_VtableIndexICorJitCompilerGetVersionGuid()
protected int get_VtableIndexICorJitCompilerCompileMethod()
protected InvokeCompileMethodPtr get_InvokeCompileMethodPtr()
protected Delegate CastCompileHookToRealType(Delegate del)
protected IntPtr* GetVTableEntry(IntPtr object, int index)
protected IntPtr ReadObjectVTable(IntPtr object, int index)
private void CheckVersionGuid(IntPtr jit)
protected void InstallJitHook(IntPtr jit)
protected void InvokeCompileMethodToPrepare(IntPtr method)
protected Delegate CreateCompileMethodDelegate(IntPtr compileMethod)
protected void MakeAssemblySystemAssembly(Assembly assembly)
}
internal MonoMod.Core.Platforms.Runtimes.Core30Runtime : Core21Runtime {
private Guid JitVersionGuid
protected Guid ExpectedJitVersion
protected InvokeCompileMethodPtr InvokeCompileMethodPtr
public void .ctor(ISystem system)
protected Guid get_ExpectedJitVersion()
protected InvokeCompileMethodPtr get_InvokeCompileMethodPtr()
protected Delegate CastCompileHookToRealType(Delegate del)
}
internal MonoMod.Core.Platforms.Runtimes.Core31Runtime : Core30Runtime {
protected InvokeCompileMethodPtr InvokeCompileMethodPtr
public void .ctor(ISystem system)
protected InvokeCompileMethodPtr get_InvokeCompileMethodPtr()
protected Delegate CastCompileHookToRealType(Delegate del)
}
internal MonoMod.Core.Platforms.Runtimes.Core50Runtime : Core31Runtime {
private Guid JitVersionGuid
protected Guid ExpectedJitVersion
protected int VtableIndexICorJitCompilerGetVersionGuid
protected InvokeCompileMethodPtr InvokeCompileMethodPtr
public void .ctor(ISystem system)
protected Guid get_ExpectedJitVersion()
protected int get_VtableIndexICorJitCompilerGetVersionGuid()
protected InvokeCompileMethodPtr get_InvokeCompileMethodPtr()
protected Delegate CastCompileHookToRealType(Delegate del)
}
internal MonoMod.Core.Platforms.Runtimes.Core60Runtime : Core50Runtime {
private Guid JitVersionGuid
protected Guid ExpectedJitVersion
protected InvokeCompileMethodPtr InvokeCompileMethodPtr
public void .ctor(ISystem system)
protected Guid get_ExpectedJitVersion()
protected InvokeCompileMethodPtr get_InvokeCompileMethodPtr()
protected Delegate CastCompileHookToRealType(Delegate del)
}
internal MonoMod.Core.Platforms.Runtimes.Core70Runtime : Core60Runtime {
private IArchitecture arch
private Guid JitVersionGuid
private Delegate allocMemDelegate
private IDisposable n2mAllocMemHelper
protected Guid ExpectedJitVersion
protected int VtableIndexICorJitInfoAllocMem
protected int ICorJitInfoFullVtableCount
protected InvokeAllocMemPtr InvokeAllocMemPtr
public void .ctor(ISystem system, IArchitecture arch)
protected Guid get_ExpectedJitVersion()
protected Delegate CreateCompileMethodDelegate(IntPtr compileMethod)
protected void PatchWrapperVtable(IntPtr* vtbl)
protected int get_VtableIndexICorJitInfoAllocMem()
protected int get_ICorJitInfoFullVtableCount()
protected InvokeAllocMemPtr get_InvokeAllocMemPtr()
protected Delegate CastAllocMemToRealType(Delegate del)
protected Delegate CreateAllocMemDelegate()
}
internal MonoMod.Core.Platforms.Runtimes.Core80Runtime : Core70Runtime {
private Guid JitVersionGuid
protected Guid ExpectedJitVersion
protected int VtableIndexICorJitInfoAllocMem
protected int ICorJitInfoFullVtableCount
public void .ctor(ISystem system, IArchitecture arch)
protected Guid get_ExpectedJitVersion()
protected int get_VtableIndexICorJitInfoAllocMem()
protected int get_ICorJitInfoFullVtableCount()
}
internal MonoMod.Core.Platforms.Runtimes.CoreBaseRuntime : FxCoreBaseRuntime {
private ISystem <System>k__BackingField
private Nullable`1<IntPtr> lazyJitObject
private INativeExceptionHelper lazyNativeExceptionHelper
public RuntimeKind Target
protected ISystem System
protected IntPtr JitObject
protected INativeExceptionHelper NativeExceptionHelper
public CoreBaseRuntime CreateForVersion(Version version, ISystem system, IArchitecture arch)
public RuntimeKind get_Target()
protected ISystem get_System()
protected void .ctor(ISystem system)
private void MonoMod.Core.Utils.IInitialize.Initialize()
private bool IsMaybeClrJitPath(string path)
protected string GetClrJitPath()
protected IntPtr get_JitObject()
private IntPtr GetJitObject()
protected void InstallJitHook(IntPtr jit)
protected INativeExceptionHelper get_NativeExceptionHelper()
protected IntPtr EHNativeToManaged(IntPtr target, IDisposable& handle)
protected IntPtr EHManagedToNative(IntPtr target, IDisposable& handle)
}
internal MonoMod.Core.Platforms.Runtimes.FxBaseRuntime : FxCoreBaseRuntime {
public RuntimeKind Target
public RuntimeKind get_Target()
public FxBaseRuntime CreateForVersion(Version version, ISystem system)
}
internal MonoMod.Core.Platforms.Runtimes.FxCLR2Runtime : FxBaseRuntime {
private ISystem system
public void .ctor(ISystem system)
}
internal MonoMod.Core.Platforms.Runtimes.FxCLR4Runtime : FxBaseRuntime {
private ISystem system
public RuntimeFeature Features
public void .ctor(ISystem system)
public RuntimeFeature get_Features()
private IntPtr GetMethodBodyPtr(MethodBase method, RuntimeMethodHandle handle)
public IntPtr GetMethodEntryPoint(MethodBase method)
}
internal MonoMod.Core.Platforms.Runtimes.FxCoreBaseRuntime : object {
protected Nullable`1<Abi> AbiCore
private Type RTDynamicMethod
private FieldInfo RTDynamicMethod_m_owner
private FieldInfo _DynamicMethod_m_method
private MethodInfo _DynamicMethod_GetMethodDescriptor
private MethodInfo _RuntimeMethodHandle_get_Value
private FieldInfo _RuntimeMethodHandle_m_value
private MethodInfo _IRuntimeMethodInfo_get_Value
private MethodInfo _RuntimeHelpers__CompileMethod
private Type RtH_CM_FirstArg
private bool _RuntimeHelpers__CompileMethod_TakesIntPtr
private bool _RuntimeHelpers__CompileMethod_TakesIRuntimeMethodInfo
private bool _RuntimeHelpers__CompileMethod_TakesRuntimeMethodHandleInternal
private Func`2<DynamicMethod, RuntimeMethodHandle> lazyGetDmHandleHelper
private Action`1<RuntimeMethodHandle> lazyBclCompileMethod
protected bool IsDebugClr
private OnMethodCompiledCallback OnMethodCompiled
public RuntimeKind Target
public RuntimeFeature Features
public Abi Abi
private Func`2<DynamicMethod, RuntimeMethodHandle> GetDMHandleHelper
private bool CanCreateGetDMHandleHelper
private Action`1<RuntimeMethodHandle> BclCompileMethodHelper
private bool CanCreateBclCompileMethodHelper
public RuntimeKind get_Target()
public RuntimeFeature get_Features()
public Abi get_Abi()
private TypeClassification ClassifyRyuJitX86(Type type, bool isReturn)
protected Abi AbiForCoreFx45X64(Abi baseAbi)
public MethodBase GetIdentifiable(MethodBase method)
public RuntimeMethodHandle GetMethodHandle(MethodBase method)
private Func`2<DynamicMethod, RuntimeMethodHandle> get_GetDMHandleHelper()
private bool get_CanCreateGetDMHandleHelper()
private Func`2<DynamicMethod, RuntimeMethodHandle> CreateGetDMHandleHelper()
private Action`1<RuntimeMethodHandle> get_BclCompileMethodHelper()
private bool get_CanCreateBclCompileMethodHelper()
private Action`1<RuntimeMethodHandle> CreateBclCompileMethodHelper()
private bool TryGetDMHandle(DynamicMethod dm, RuntimeMethodHandle& handle)
protected bool TryInvokeBclCompileMethod(RuntimeMethodHandle handle)
private bool TryGetDMHandleRefl(DynamicMethod dm, RuntimeMethodHandle& handle)
private bool TryInvokeBclCompileMethodRefl(RuntimeMethodHandle handle)
public void Compile(MethodBase method)
protected bool TryGetCanonicalMethodHandle(RuntimeMethodHandle& handle)
public IDisposable PinMethodIfNeeded(MethodBase method)
public void DisableInlining(MethodBase method)
public IntPtr GetMethodEntryPoint(MethodBase method)
public void add_OnMethodCompiled(OnMethodCompiledCallback value)
public void remove_OnMethodCompiled(OnMethodCompiledCallback value)
protected void OnMethodCompiledCore(RuntimeTypeHandle declaringType, RuntimeMethodHandle methodHandle, Nullable`1<ReadOnlyMemory`1<RuntimeTypeHandle>> genericTypeArguments, Nullable`1<ReadOnlyMemory`1<RuntimeTypeHandle>> genericMethodArguments, IntPtr methodBodyStart, IntPtr methodBodyRw, ulong methodBodySize)
}
internal MonoMod.Core.Platforms.Runtimes.MonoRuntime : object {
private Abi <Abi>k__BackingField
private ISystem system
private OnMethodCompiledCallback OnMethodCompiled
private MethodInfo _DynamicMethod_CreateDynMethod
private FieldInfo _DynamicMethod_mhandle
private ConcurrentDictionary`2<MethodBase, PrivateMethodPin> pinnedMethods
private ConcurrentDictionary`2<RuntimeMethodHandle, PrivateMethodPin> pinnedHandles
public RuntimeKind Target
public RuntimeFeature Features
public Abi Abi
public RuntimeKind get_Target()
public RuntimeFeature get_Features()
public Abi get_Abi()
private TypeClassification LinuxAmd64Classifier(Type type, bool isReturn)
private TypeClassification ClassifyValueType(Type type, bool isReturn)
private IEnumerable`1<FieldInfo> NestedValutypeFields(Type type)
public void .ctor(ISystem system)
public void add_OnMethodCompiled(OnMethodCompiledCallback value)
public void remove_OnMethodCompiled(OnMethodCompiledCallback value)
public void DisableInlining(MethodBase method)
public RuntimeMethodHandle GetMethodHandle(MethodBase method)
public IDisposable PinMethodIfNeeded(MethodBase method)
private void UnpinOnce(PrivateMethodPin pin)
public MethodBase GetIdentifiable(MethodBase method)
public IntPtr GetMethodEntryPoint(MethodBase method)
public void Compile(MethodBase method)
}
internal MonoMod.Core.Platforms.SimpleNativeDetour : object {
private bool disposedValue
private PlatformTriple triple
private NativeDetourInfo detourInfo
private Memory`1<byte> backup
private IDisposable AllocHandle
public ReadOnlyMemory`1<byte> DetourBackup
public IntPtr Source
public IntPtr Destination
public ReadOnlyMemory`1<byte> get_DetourBackup()
public IntPtr get_Source()
public IntPtr get_Destination()
internal void .ctor(PlatformTriple triple, NativeDetourInfo detourInfo, Memory`1<byte> backup, IDisposable allocHandle)
public void ChangeTarget(IntPtr newTarget)
public void Undo()
private void CheckDisposed()
private void UndoCore(bool disposing)
private void Cleanup()
private void Dispose(bool disposing)
protected void Finalize()
public void Dispose()
}
internal MonoMod.Core.Platforms.SpecialArgumentKind : Enum {
public int value__
public SpecialArgumentKind ThisPointer
public SpecialArgumentKind ReturnBuffer
public SpecialArgumentKind GenericContext
public SpecialArgumentKind UserArguments
}
internal MonoMod.Core.Platforms.SystemFeature : Enum {
public int value__
public SystemFeature None
public SystemFeature RWXPages
public SystemFeature RXPages
}
internal MonoMod.Core.Platforms.Systems.LinuxSystem : object {
private Abi defaultAbi
private IntPtr PageSize
private MmapPagedMemoryAllocator allocator
private IArchitecture arch
private PosixExceptionHelper lazyNativeExceptionHelper
public OSKind Target
public SystemFeature Features
public Nullable`1<Abi> DefaultAbi
public IMemoryAllocator MemoryAllocator
public INativeExceptionHelper NativeExceptionHelper
private ReadOnlySpan`1<byte> NEHTempl
public OSKind get_Target()
public SystemFeature get_Features()
public Nullable`1<Abi> get_DefaultAbi()
public IEnumerable`1<string> EnumerateLoadedModuleFiles()
public IMemoryAllocator get_MemoryAllocator()
public IntPtr GetSizeOfReadableMemory(IntPtr start, IntPtr guess)
public void PatchData(PatchTargetKind patchKind, IntPtr patchTarget, ReadOnlySpan`1<byte> data, Span`1<byte> backup)
private void RoundToPageBoundary(IntPtr& addr, IntPtr& size)
private void ProtectRW(IntPtr addr, IntPtr size)
private void ProtectRWX(IntPtr addr, IntPtr size)
private void MonoMod.Core.Utils.IInitialize<MonoMod.Core.Platforms.IArchitecture>.Initialize(IArchitecture value)
public INativeExceptionHelper get_NativeExceptionHelper()
private ReadOnlySpan`1<byte> get_NEHTempl()
private PosixExceptionHelper CreateNativeExceptionHelper()
}
internal MonoMod.Core.Platforms.Systems.MacOSSystem : object {
private Nullable`1<Abi> <DefaultAbi>k__BackingField
private IMemoryAllocator <MemoryAllocator>k__BackingField
private IArchitecture arch
private PosixExceptionHelper lazyNativeExceptionHelper
public OSKind Target
public SystemFeature Features
public Nullable`1<Abi> DefaultAbi
public IMemoryAllocator MemoryAllocator
public INativeExceptionHelper NativeExceptionHelper
private ReadOnlySpan`1<byte> NEHTempl
public OSKind get_Target()
public SystemFeature get_Features()
public Nullable`1<Abi> get_DefaultAbi()
public IEnumerable`1<string> EnumerateLoadedModuleFiles()
public IntPtr GetSizeOfReadableMemory(IntPtr start, IntPtr guess)
public void PatchData(PatchTargetKind targetKind, IntPtr patchTarget, ReadOnlySpan`1<byte> data, Span`1<byte> backup)
private void MakePageWritable(IntPtr addrInPage)
private bool TryGetProtForMem(IntPtr addr, int length, vm_prot_t& maxProt, vm_prot_t& prot, Boolean& crossesAllocBoundary, Boolean& notAllocated)
private kern_return_t GetLocalRegionInfo(IntPtr origAddr, IntPtr& startAddr, IntPtr& outSize, vm_prot_t& prot, vm_prot_t& maxProt)
public IMemoryAllocator get_MemoryAllocator()
private void MonoMod.Core.Utils.IInitialize<MonoMod.Core.Platforms.IArchitecture>.Initialize(IArchitecture value)
public INativeExceptionHelper get_NativeExceptionHelper()
private ReadOnlySpan`1<byte> get_NEHTempl()
private PosixExceptionHelper CreateNativeExceptionHelper()
}
internal MonoMod.Core.Platforms.Systems.PosixExceptionHelper : object {
private IArchitecture arch
private IntPtr eh_get_exception_ptr
private IntPtr eh_managed_to_native
private IntPtr eh_native_to_managed
public IntPtr NativeException
public GetExceptionSlot GetExceptionSlot
private void .ctor(IArchitecture arch, IntPtr getExPtr, IntPtr m2n, IntPtr n2m)
public PosixExceptionHelper CreateHelper(IArchitecture arch, string filename)
public IntPtr get_NativeException()
public void set_NativeException(IntPtr value)
public GetExceptionSlot get_GetExceptionSlot()
public IntPtr CreateManagedToNativeHelper(IntPtr target, IDisposable& handle)
public IntPtr CreateNativeToManagedHelper(IntPtr target, IDisposable& handle)
private IntPtr* <get_GetExceptionSlot>b__10_0()
}
internal MonoMod.Core.Platforms.Systems.SystemVABI : object {
private ConditionalWeakTable`2<Type, StrongBox`1<bool>> SysVIsMemoryCache
public TypeClassification ClassifyAMD64(Type type, bool isReturn)
private bool AnyFieldsNotFloat(Type type)
}
internal MonoMod.Core.Platforms.Systems.WindowsSystem : object {
private Nullable`1<Abi> <DefaultAbi>k__BackingField
private IMemoryAllocator <MemoryAllocator>k__BackingField
public OSKind Target
public SystemFeature Features
public INativeExceptionHelper NativeExceptionHelper
public Nullable`1<Abi> DefaultAbi
public IMemoryAllocator MemoryAllocator
public OSKind get_Target()
public SystemFeature get_Features()
public INativeExceptionHelper get_NativeExceptionHelper()
public Nullable`1<Abi> get_DefaultAbi()
private TypeClassification ClassifyX64(Type type, bool isReturn)
private TypeClassification ClassifyX86(Type type, bool isReturn)
public void PatchData(PatchTargetKind patchKind, IntPtr patchTarget, ReadOnlySpan`1<byte> data, Span`1<byte> backup)
private void ProtectRW(IntPtr addr, UIntPtr size)
private void ProtectRWX(IntPtr addr, UIntPtr size)
private void FlushInstructionCache(IntPtr addr, UIntPtr size)
public IEnumerable`1<string> EnumerateLoadedModuleFiles()
public IntPtr GetSizeOfReadableMemory(IntPtr start, IntPtr guess)
private Exception LogAllSections(UInt32 error, IntPtr src, UIntPtr size, string from)
public IMemoryAllocator get_MemoryAllocator()
}
internal MonoMod.Core.Platforms.TypeClassification : Enum {
public int value__
public TypeClassification InRegister
public TypeClassification ByReference
public TypeClassification OnStack
}
internal MonoMod.Core.Utils.AddressKind : Enum {
public int value__
public AddressKind Rel32
public AddressKind Rel64
public AddressKind Abs32
public AddressKind Abs64
public AddressKind PrecodeFixupThunkRel32
public AddressKind PrecodeFixupThunkRel64
public AddressKind PrecodeFixupThunkAbs32
public AddressKind PrecodeFixupThunkAbs64
public AddressKind Indirect
}
internal MonoMod.Core.Utils.AddressKindExtensions : object {
public AddressKind IsAbsoluteField
public AddressKind Is64BitField
public AddressKind IsPrecodeFixupField
public AddressKind IsIndirectField
public bool IsRelative(AddressKind value)
public bool IsAbsolute(AddressKind value)
public bool Is32Bit(AddressKind value)
public bool Is64Bit(AddressKind value)
public bool IsPrecodeFixup(AddressKind value)
public bool IsIndirect(AddressKind value)
public void Validate(AddressKind value, string argName)
public string FastToString(AddressKind value)
}
internal MonoMod.Core.Utils.AddressMeaning : ValueType {
private AddressKind <Kind>k__BackingField
private int <RelativeToOffset>k__BackingField
public AddressKind Kind
public int RelativeToOffset
public AddressKind get_Kind()
public int get_RelativeToOffset()
public void .ctor(AddressKind kind)
public void .ctor(AddressKind kind, int relativeOffset)
private IntPtr DoProcessAddress(AddressKind kind, IntPtr basePtr, int offset, ulong address)
public IntPtr ProcessAddress(IntPtr basePtr, int offset, ulong address)
public bool Equals(object obj)
public bool Equals(AddressMeaning other)
public string ToString()
public int GetHashCode()
public bool op_Equality(AddressMeaning left, AddressMeaning right)
public bool op_Inequality(AddressMeaning left, AddressMeaning right)
}
internal MonoMod.Core.Utils.BytePattern : object {
private ushort MaskMask
public byte BAnyValue
public ushort SAnyValue
public byte BAnyRepeatingValue
public ushort SAnyRepeatingValue
public byte BAddressValue
public ushort SAddressValue
private ReadOnlyMemory`1<byte> pattern
private ReadOnlyMemory`1<byte> bitmask
private PatternSegment[] segments
private int <AddressBytes>k__BackingField
private int <MinLength>k__BackingField
private AddressMeaning <AddressMeaning>k__BackingField
private bool <MustMatchAtStart>k__BackingField
private Nullable`1<ValueTuple`2<ReadOnlyMemory`1<byte>, int>> lazyFirstLiteralSegment
public int AddressBytes
public int MinLength
public AddressMeaning AddressMeaning
public bool MustMatchAtStart
public ValueTuple`2<ReadOnlyMemory`1<byte>, int> FirstLiteralSegment
public int get_AddressBytes()
public int get_MinLength()
public AddressMeaning get_AddressMeaning()
public bool get_MustMatchAtStart()
public void .ctor(AddressMeaning meaning, UInt16[] pattern)
public void .ctor(AddressMeaning meaning, bool mustMatchAtStart, UInt16[] pattern)
public void .ctor(AddressMeaning meaning, ReadOnlyMemory`1<ushort> pattern)
public void .ctor(AddressMeaning meaning, bool mustMatchAtStart, ReadOnlyMemory`1<ushort> pattern)
public void .ctor(AddressMeaning meaning, ReadOnlyMemory`1<byte> mask, ReadOnlyMemory`1<byte> pattern)
public void .ctor(AddressMeaning meaning, bool mustMatchAtStart, ReadOnlyMemory`1<byte> mask, ReadOnlyMemory`1<byte> pattern)
private ComputeSegmentsResult ComputeSegmentsFromShort(ReadOnlyMemory`1<ushort> pattern)
private ComputeSegmentsResult ComputeSegmentsFromMaskPattern(ReadOnlyMemory`1<byte> mask, ReadOnlyMemory`1<byte> pattern)
private ComputeSegmentsResult ComputeSegmentsCore(method kindForIdx, int patternLength, TPattern pattern)
public bool TryMatchAt(ReadOnlySpan`1<byte> data, UInt64& address, Int32& length)
public bool TryMatchAt(ReadOnlySpan`1<byte> data, Span`1<byte> addrBuf, Int32& length)
private bool TryMatchAtImpl(ReadOnlySpan`1<byte> patternSpan, ReadOnlySpan`1<byte> data, Span`1<byte> addrBuf, Int32& length, int startAtSegment)
public bool TryFindMatch(ReadOnlySpan`1<byte> data, UInt64& address, Int32& offset, Int32& length)
public bool TryFindMatch(ReadOnlySpan`1<byte> data, Span`1<byte> addrBuf, Int32& offset, Int32& length)
private bool ScanForNextLiteral(ReadOnlySpan`1<byte> patternSpan, ReadOnlySpan`1<byte> data, Span`1<byte> addrBuf, Int32& offset, Int32& length, int segmentIndex)
public ValueTuple`2<ReadOnlyMemory`1<byte>, int> get_FirstLiteralSegment()
private ValueTuple`2<ReadOnlyMemory`1<byte>, int> GetFirstLiteralSegment()
private ValueTuple`2<PatternSegment, int> GetNextLiteralSegment(int segmentIndexId)
internal SegmentKind <ComputeSegmentsFromShort>g__KindForShort|31_0(ReadOnlyMemory`1<ushort> pattern, int idx)
internal SegmentKind <ComputeSegmentsFromMaskPattern>g__KindForIdx|32_0(ValueTuple`2<ReadOnlyMemory`1<byte>, ReadOnlyMemory`1<byte>> t, int idx)
}
internal MonoMod.Core.Utils.BytePatternCollection : object {
private HomogenousPatternCollection[] patternCollections
private BytePattern[] emptyPatterns
private int <MinLength>k__BackingField
private int <MaxMinLength>k__BackingField
private int <MaxAddressLength>k__BackingField
private Nullable`1<ReadOnlyMemory`1<byte>> lazyPossibleFirstBytes
public int MinLength
public int MaxMinLength
public int MaxAddressLength
private ReadOnlyMemory`1<byte> PossibleFirstBytes
public int get_MinLength()
public int get_MaxMinLength()
public int get_MaxAddressLength()
public void .ctor(ReadOnlyMemory`1<BytePattern> patterns)
public void .ctor(BytePattern[] patterns)
public IEnumerator`1<BytePattern> GetEnumerator()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
private ValueTuple`2<HomogenousPatternCollection[], BytePattern[]> ComputeLut(ReadOnlyMemory`1<BytePattern> patterns, Int32& minLength, Int32& maxMinLength, Int32& maxAddrLength)
public bool TryMatchAt(ReadOnlySpan`1<byte> data, UInt64& address, BytePattern& matchingPattern, Int32& length)
public bool TryMatchAt(ReadOnlySpan`1<byte> data, Span`1<byte> addrBuf, BytePattern& matchingPattern, Int32& length)
public bool TryFindMatch(ReadOnlySpan`1<byte> data, UInt64& address, BytePattern& matchingPattern, Int32& offset, Int32& length)
public bool TryFindMatch(ReadOnlySpan`1<byte> data, Span`1<byte> addrBuf, BytePattern& matchingPattern, Int32& offset, Int32& length)
private ReadOnlyMemory`1<byte> get_PossibleFirstBytes()
private ReadOnlyMemory`1<byte> GetPossibleFirstBytes()
internal void <ComputeLut>g__AddToPatternCollection|15_0(HomogenousPatternCollection& collection, ReadOnlySpan`1<int> arrayCounts, BytePattern pattern)
}
internal MonoMod.Core.Utils.IcedExtensions : object {
public string FormatInsns(IList`1<Instruction> insns)
public string FormatInsns(InstructionList insns)
}
internal MonoMod.Core.Utils.IInitialize {
public void Initialize()
}
internal MonoMod.Core.Utils.IInitialize`1 {
public void Initialize(T value)
}
internal MonoMod.ILHelpers : object {
public T TailCallDelegatePtr(IntPtr source)
public T TailCallFunc(Func`1<T> func)
public T& UnboxAnyUnsafe(Object& box)
}
internal MonoMod.Logs.DebugFormatter : object {
public bool CanDebugFormat(T& value, Object& extraData)
public bool TryFormatInto(T& value, object extraData, Span`1<char> into, Int32& wrote)
private bool TryFormatException(Exception e, string eStr, Span`1<char> into, Int32& wrote)
private bool TryFormatType(Type type, Span`1<char> into, Int32& wrote)
private bool TryFormatMethodInfo(MethodInfo method, Span`1<char> into, Int32& wrote)
private bool TryFormatMemberInfoName(MemberInfo member, Span`1<char> into, Int32& wrote)
private bool TryFormatMethodBase(MethodBase method, Span`1<char> into, Int32& wrote)
private bool TryFormatFieldInfo(FieldInfo field, Span`1<char> into, Int32& wrote)
private bool TryFormatPropertyInfo(PropertyInfo prop, Span`1<char> into, Int32& wrote)
public string Format(FormatInterpolatedStringHandler& handler)
public bool Into(Span`1<char> into, Int32& wrote, FormatIntoInterpolatedStringHandler& handler)
internal TOut& <TryFormatInto>g__Transmute|1_0(T& val)
}
internal MonoMod.Logs.DebugLog : object {
internal DebugLog Instance
private ConcurrentBag`1<WeakReference`1<LogMessage>> weakRefCache
private ConcurrentBag`1<WeakReference`1<LogMessage>> messageObjectCache
private Char[] listEnvSeparator
private bool recordHoles
private int replayQueueLength
private ConcurrentQueue`1<LogMessage> replayQueue
private LogLevelFilter globalFilter
private Byte[] memlog
private int memlogPos
private LevelSubscriptions subscriptions
private ConcurrentDictionary`2<OnLogMessage, IDisposable> simpleRegDict
public bool IsFinalizing
public bool IsWritingLog
internal bool AlwaysLog
internal bool ShouldLog
internal bool RecordHoles
public bool get_IsFinalizing()
private LogMessage MakeMessage(string source, DateTime time, LogLevel level, string formatted, ReadOnlyMemory`1<MessageHole> holes)
private void ReturnMessage(LogMessage message)
public bool get_IsWritingLog()
internal bool get_AlwaysLog()
internal bool get_ShouldLog()
internal bool get_RecordHoles()
private void PostMessage(LogMessage message)
internal bool ShouldLogLevel(LogLevel level)
internal bool ShouldLevelRecordHoles(LogLevel level)
public void Write(string source, DateTime time, LogLevel level, string message)
public void Write(string source, DateTime time, LogLevel level, DebugLogInterpolatedStringHandler& message)
internal void LogCore(string source, LogLevel level, string message)
internal void LogCore(string source, LogLevel level, DebugLogInterpolatedStringHandler& message)
public void Log(string source, LogLevel level, string message)
public void Log(string source, LogLevel level, DebugLogInterpolatedStringHandler& message)
private String[] GetListEnvVar(string text)
private void TryInitializeLogToFile(string file, String[] sourceFilter, LogLevelFilter filter)
private void TryInitializeMemoryLog(LogLevelFilter filter)
private void MaybeReplayTo(LogLevelFilter filter, OnLogMessage del)
private void MaybeReplayTo(LogLevelFilter filter, OnLogMessageDetailed del)
public IDisposable Subscribe(LogLevelFilter filter, OnLogMessage value)
private IDisposable SubscribeCore(LogLevelFilter filter, OnLogMessage value)
public IDisposable Subscribe(LogLevelFilter filter, OnLogMessageDetailed value)
private IDisposable SubscribeCore(LogLevelFilter filter, OnLogMessageDetailed value)
public void add_OnLog(OnLogMessage value)
public void remove_OnLog(OnLogMessage value)
}
internal MonoMod.Logs.DebugLogInterpolatedStringHandler : ValueType {
private int GuessedLengthPerHole
private int MinimumArrayPoolLength
private Char[] _arrayToReturnToPool
private Span`1<char> _chars
private int _pos
private int holeBegin
private int holePos
private Memory`1<MessageHole> holes
internal bool enabled
internal ReadOnlySpan`1<char> Text
public void .ctor(int literalLength, int formattedCount, bool enabled, bool recordHoles, Boolean& isEnabled)
public void .ctor(int literalLength, int formattedCount, Boolean& isEnabled)
public void .ctor(int literalLength, int formattedCount, LogLevel level, Boolean& isEnabled)
internal int GetDefaultLength(int literalLength, int formattedCount)
internal ReadOnlySpan`1<char> get_Text()
public string ToString()
public string ToStringAndClear()
internal string ToStringAndClear(ReadOnlyMemory`1& holes)
internal void Clear()
public void AppendLiteral(string value)
private void AppendStringDirect(string value)
private void BeginHole()
private void EndHole(object obj, bool reprd)
private void EndHole(T& obj, bool reprd)
public void AppendFormatted(string value)
private void AppendFormattedSlow(string value)
public void AppendFormatted(string value, int alignment, string format)
public void AppendFormatted(ReadOnlySpan`1<char> value)
public void AppendFormatted(ReadOnlySpan`1<char> value, int alignment, string format)
public void AppendFormatted(T value)
private void AppendFormatted(IntPtr value)
private void AppendFormatted(IntPtr value, string format)
private void AppendFormatted(UIntPtr value)
private void AppendFormatted(UIntPtr value, string format)
public void AppendFormatted(T value, int alignment)
public void AppendFormatted(T value, string format)
public void AppendFormatted(T value, int alignment, string format)
private void AppendOrInsertAlignmentIfNeeded(int startingPos, int alignment)
private void EnsureCapacityForAdditionalChars(int additionalChars)
private void GrowThenCopyString(string value)
private void GrowThenCopySpan(ReadOnlySpan`1<char> value)
private void Grow(int additionalChars)
private void Grow()
private void GrowCore(UInt32 requiredMinCapacity)
}
internal MonoMod.Logs.FormatInterpolatedStringHandler : ValueType {
private DebugLogInterpolatedStringHandler handler
public void .ctor(int literalLen, int formattedCount)
public string ToString()
public string ToStringAndClear()
public void AppendLiteral(string s)
public void AppendFormatted(string s)
public void AppendFormatted(string s, int alignment, string format)
public void AppendFormatted(ReadOnlySpan`1<char> s)
public void AppendFormatted(ReadOnlySpan`1<char> s, int alignment, string format)
public void AppendFormatted(T value)
public void AppendFormatted(T value, int alignment)
public void AppendFormatted(T value, string format)
public void AppendFormatted(T value, int alignment, string format)
}
internal MonoMod.Logs.FormatIntoInterpolatedStringHandler : ValueType {
private Span`1<char> _chars
internal int pos
internal bool incomplete
public void .ctor(int literalLen, int numHoles, Span`1<char> into, Boolean& enabled)
public bool AppendLiteral(string value)
private bool AppendStringDirect(string value)
public bool AppendFormatted(string value)
public bool AppendFormatted(string value, int alignment, string format)
public bool AppendFormatted(ReadOnlySpan`1<char> value)
public bool AppendFormatted(ReadOnlySpan`1<char> value, int alignment, string format)
public bool AppendFormatted(T value)
private bool AppendFormatted(IntPtr value)
private bool AppendFormatted(IntPtr value, string format)
private bool AppendFormatted(UIntPtr value)
private bool AppendFormatted(UIntPtr value, string format)
public bool AppendFormatted(T value, int alignment)
public bool AppendFormatted(T value, string format)
public bool AppendFormatted(T value, int alignment, string format)
private bool AppendOrInsertAlignmentIfNeeded(int startingPos, int alignment)
}
internal MonoMod.Logs.IDebugFormattable {
public bool TryFormatInto(Span`1<char> span, Int32& wrote)
}
internal MonoMod.Logs.LogLevel : Enum {
public int value__
public LogLevel Spam
public LogLevel Trace
public LogLevel Info
public LogLevel Warning
public LogLevel Error
public LogLevel Assert
}
internal MonoMod.Logs.LogLevelExtensions : object {
public LogLevel MaxLevel
public string FastToString(LogLevel level, IFormatProvider provider)
}
internal MonoMod.Logs.LogLevelFilter : Enum {
public int value__
public LogLevelFilter None
public LogLevelFilter Spam
public LogLevelFilter Trace
public LogLevelFilter Info
public LogLevelFilter Warning
public LogLevelFilter Error
public LogLevelFilter Assert
public LogLevelFilter DefaultFilter
}
internal MonoMod.Logs.MessageHole : ValueType {
private int <Start>k__BackingField
private int <End>k__BackingField
private object <Value>k__BackingField
private bool <IsValueUnrepresentable>k__BackingField
public int Start
public int End
public object Value
public bool IsValueUnrepresentable
public int get_Start()
public int get_End()
public object get_Value()
public bool get_IsValueUnrepresentable()
public void .ctor(int start, int end)
public void .ctor(int start, int end, object value)
public string ToString()
private bool PrintMembers(StringBuilder builder)
public bool op_Inequality(MessageHole left, MessageHole right)
public bool op_Equality(MessageHole left, MessageHole right)
public int GetHashCode()
public bool Equals(object obj)
public bool Equals(MessageHole other)
}
internal MonoMod.MMDbgLog : object {
public bool IsWritingLog
public bool get_IsWritingLog()
internal void LogVersion()
public void Log(LogLevel level, string message)
public void Log(LogLevel level, DebugLogInterpolatedStringHandler& message)
public void Spam(string message)
public void Spam(DebugLogSpamStringHandler& message)
public void Trace(string message)
public void Trace(DebugLogTraceStringHandler& message)
public void Info(string message)
public void Info(DebugLogInfoStringHandler& message)
public void Warning(string message)
public void Warning(DebugLogWarningStringHandler& message)
public void Error(string message)
public void Error(DebugLogErrorStringHandler& message)
}
internal MonoMod.ModInterop.ModExportNameAttribute : Attribute {
private string <Name>k__BackingField
public string Name
public string get_Name()
public void .ctor(string name)
}
internal MonoMod.ModInterop.ModImportNameAttribute : Attribute {
private string <Name>k__BackingField
public string Name
public string get_Name()
public void .ctor(string name)
}
internal MonoMod.ModInterop.ModInteropManager : object {
private HashSet`1<Type> Registered
private Dictionary`2<string, List`1<MethodInfo>> Methods
private List`1<FieldInfo> Fields
public void ModInterop(Type type)
public void RegisterModExport(MethodInfo method, string prefix)
private string GetModImportName(FieldInfo field)
}
internal MonoMod.MultiTargetShims : object {
public TypeReference GetConstraintType(GenericParameterConstraint constraint)
}
internal MonoMod.SourceGen.Attributes.<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>EmitILOverloadsAttribute : Attribute {
public void .ctor(string filename, string kind)
}
internal MonoMod.SourceGen.Attributes.<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>ILOverloadKind : object {
public string Cursor
public string Matcher
}
internal MonoMod.SourceGen.Attributes.EmitILOverloadsAttribute : Attribute {
public void .ctor(string filename, string kind)
}
internal MonoMod.SourceGen.Attributes.ILOverloadKind : object {
public string Cursor
public string Matcher
}
internal MonoMod.Switches : object {
private ConcurrentDictionary`2<string, object> switchValues
private string Prefix
public string RunningOnWine
public string DebugClr
public string JitPath
public string LogRecordHoles
public string LogInMemory
public string LogSpam
public string LogReplayQueueLength
public string LogToFile
public string LogToFileFilter
public string DMDType
public string DMDDebug
public string DMDDumpTo
private Type tAppContext
private Func`2<string, object> dGetData
private MethodInfo miTryGetSwitch
private TryGetSwitchFunc dTryGetSwitch
private object BestEffortParseEnvVar(string value)
public void SetSwitchValue(string switch, object value)
public void ClearSwitchValue(string switch)
private Func`2<string, object> MakeGetDataDelegate()
public bool TryGetSwitchValue(string switch, Object& value)
public bool TryGetSwitchEnabled(string switch, Boolean& isEnabled)
private bool TryProcessBoolData(object data, Boolean& boolVal)
}
internal MonoMod.Utils._DMDEmit : object {
private MethodInfo m_MethodBase_InvokeSimple
private Dictionary`2<short, OpCode> _ReflOpCodes
private Dictionary`2<short, OpCode> _CecilOpCodes
private MethodInfo _ILGen_make_room
private MethodInfo _ILGen_emit_int
private MethodInfo _ILGen_ll_emit
private MethodInfo _ILGen_EnsureCapacity
private MethodInfo _ILGen_PutInteger4
private MethodInfo _ILGen_InternalEmit
private MethodInfo _ILGen_UpdateStackSize
private FieldInfo f_DynILGen_m_scope
private FieldInfo f_DynScope_m_tokens
private Type[] CorElementTypes
private MethodBuilder _CreateMethodProxy(MethodBuilder context, MethodInfo target)
public void Generate(DynamicMethodDefinition dmd, MethodBase _mb, ILGenerator il)
public void ResolveWithModifiers(TypeReference typeRef, Type& type, Type[]& typeModReq, Type[]& typeModOpt, List`1<Type> modReq, List`1<Type> modOpt)
internal void _EmitCallSite(DynamicMethod dm, ILGenerator il, OpCode opcode, CallSite csite)
internal int <_EmitCallSite>g___GetTokenForType|17_0(Type v, <>c__DisplayClass17_0& )
internal int <_EmitCallSite>g___GetTokenForSig|17_1(Byte[] v, <>c__DisplayClass17_0& )
internal int <_EmitCallSite>g__GetTokenForType|17_2(Type v, <>c__DisplayClass17_0& )
internal int <_EmitCallSite>g__GetTokenForSig|17_3(Byte[] v, <>c__DisplayClass17_0& )
internal void <_EmitCallSite>g__AddArgument|17_4(Type clsArgument, Type[] requiredCustomModifiers, Type[] optionalCustomModifiers, <>c__DisplayClass17_0& )
internal void <_EmitCallSite>g__AddData|17_5(int data, <>c__DisplayClass17_0& )
internal Byte[] <_EmitCallSite>g__ExpandArray|17_6(Byte[] inArray, int requiredLength)
internal void <_EmitCallSite>g__AddElementType|17_7(byte cvt, <>c__DisplayClass17_0& )
internal void <_EmitCallSite>g__AddToken|17_8(int token, <>c__DisplayClass17_0& )
internal void <_EmitCallSite>g__InternalAddTypeToken|17_9(int clsToken, byte CorType, <>c__DisplayClass17_0& )
internal void <_EmitCallSite>g__AddOneArgTypeHelper|17_10(Type clsArgument, <>c__DisplayClass17_0& )
internal void <_EmitCallSite>g__AddOneArgTypeHelperWorker|17_11(Type clsArgument, bool lastWasGenericInst, <>c__DisplayClass17_0& )
}
internal MonoMod.Utils.ArchitectureKind : Enum {
public int value__
public ArchitectureKind Unknown
public ArchitectureKind Bits64
public ArchitectureKind x86
public ArchitectureKind x86_64
public ArchitectureKind Arm
public ArchitectureKind Arm64
}
internal MonoMod.Utils.AssemblyInfo : object {
public string AssemblyName
public string AssemblyVersion
}
internal MonoMod.Utils.AssertionFailedException : Exception {
private string AssertFailed
private string <Expression>k__BackingField
private string <Message>k__BackingField
public string Expression
public string Message
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
public void .ctor(string message, string expression)
public string get_Expression()
public string get_Message()
}
internal MonoMod.Utils.AssertionInterpolatedStringHandler : ValueType {
private DebugLogInterpolatedStringHandler handler
public void .ctor(int literalLen, int formattedCount, bool assertValue, Boolean& isEnabled)
public string ToString()
public string ToStringAndClear()
public void AppendLiteral(string s)
public void AppendFormatted(string s)
public void AppendFormatted(string s, int alignment, string format)
public void AppendFormatted(ReadOnlySpan`1<char> s)
public void AppendFormatted(ReadOnlySpan`1<char> s, int alignment, string format)
public void AppendFormatted(T value)
public void AppendFormatted(T value, int alignment)
public void AppendFormatted(T value, string format)
public void AppendFormatted(T value, int alignment, string format)
}
internal MonoMod.Utils.Cil.CecilILGenerator : ILGeneratorShim {
private ConstructorInfo c_LocalBuilder
private FieldInfo f_LocalBuilder_position
private FieldInfo f_LocalBuilder_is_pinned
private int c_LocalBuilder_params
private Dictionary`2<short, OpCode> _MCCOpCodes
private Label NullLabel
private ILProcessor <IL>k__BackingField
private Dictionary`2<Label, LabelInfo> _LabelInfos
private List`1<LabelInfo> _LabelsToMark
private List`1<LabelledExceptionHandler> _ExceptionHandlersToMark
private Dictionary`2<LocalBuilder, VariableDefinition> _Variables
private Stack`1<ExceptionHandlerChain> _ExceptionHandlers
private int labelCounter
private int _ILOffset
public ILProcessor IL
public int ILOffset
public ILProcessor get_IL()
public void .ctor(ILProcessor il)
private OpCode _(OpCode opcode)
private LabelInfo _(Label handle)
private VariableDefinition _(LocalBuilder handle)
private TypeReference _(Type info)
private FieldReference _(FieldInfo info)
private MethodReference _(MethodBase info)
public int get_ILOffset()
private Instruction ProcessLabels(Instruction ins)
public Label DefineLabel()
public void MarkLabel(Label loc)
public LocalBuilder DeclareLocal(Type localType)
public LocalBuilder DeclareLocal(Type localType, bool pinned)
private void Emit(Instruction ins)
public void Emit(OpCode opcode)
public void Emit(OpCode opcode, byte arg)
public void Emit(OpCode opcode, sbyte arg)
public void Emit(OpCode opcode, short arg)
public void Emit(OpCode opcode, int arg)
public void Emit(OpCode opcode, long arg)
public void Emit(OpCode opcode, float arg)
public void Emit(OpCode opcode, double arg)
public void Emit(OpCode opcode, string str)
public void Emit(OpCode opcode, Type cls)
public void Emit(OpCode opcode, FieldInfo field)
public void Emit(OpCode opcode, ConstructorInfo con)
public void Emit(OpCode opcode, MethodInfo meth)
public void Emit(OpCode opcode, Label label)
public void Emit(OpCode opcode, Label[] labels)
public void Emit(OpCode opcode, LocalBuilder local)
public void Emit(OpCode opcode, SignatureHelper signature)
public void Emit(OpCode opcode, ICallSiteGenerator signature)
private void _EmitInlineVar(OpCode opcode, int index)
public void EmitCall(OpCode opcode, MethodInfo methodInfo, Type[] optionalParameterTypes)
public void EmitCalli(OpCode opcode, CallingConventions callingConvention, Type returnType, Type[] parameterTypes, Type[] optionalParameterTypes)
public void EmitCalli(OpCode opcode, CallingConvention unmanagedCallConv, Type returnType, Type[] parameterTypes)
public void EmitWriteLine(FieldInfo fld)
public void EmitWriteLine(LocalBuilder localBuilder)
public void EmitWriteLine(string value)
public void ThrowException(Type excType)
public Label BeginExceptionBlock()
public void BeginCatchBlock(Type exceptionType)
public void BeginExceptFilterBlock()
public void BeginFaultBlock()
public void BeginFinallyBlock()
public void EndExceptionBlock()
public void BeginScope()
public void EndScope()
public void UsingNamespace(string usingNamespace)
}
internal MonoMod.Utils.Cil.ILGeneratorShim : object {
public int ILOffset
public Type GenericProxyType
public int get_ILOffset()
public void BeginCatchBlock(Type exceptionType)
public void BeginExceptFilterBlock()
public Label BeginExceptionBlock()
public void BeginFaultBlock()
public void BeginFinallyBlock()
public void BeginScope()
public LocalBuilder DeclareLocal(Type localType)
public LocalBuilder DeclareLocal(Type localType, bool pinned)
public Label DefineLabel()
public void Emit(OpCode opcode)
public void Emit(OpCode opcode, byte arg)
public void Emit(OpCode opcode, double arg)
public void Emit(OpCode opcode, short arg)
public void Emit(OpCode opcode, int arg)
public void Emit(OpCode opcode, long arg)
public void Emit(OpCode opcode, ConstructorInfo con)
public void Emit(OpCode opcode, Label label)
public void Emit(OpCode opcode, Label[] labels)
public void Emit(OpCode opcode, LocalBuilder local)
public void Emit(OpCode opcode, SignatureHelper signature)
public void Emit(OpCode opcode, FieldInfo field)
public void Emit(OpCode opcode, MethodInfo meth)
public void Emit(OpCode opcode, sbyte arg)
public void Emit(OpCode opcode, float arg)
public void Emit(OpCode opcode, string str)
public void Emit(OpCode opcode, Type cls)
public void EmitCall(OpCode opcode, MethodInfo methodInfo, Type[] optionalParameterTypes)
public void EmitCalli(OpCode opcode, CallingConventions callingConvention, Type returnType, Type[] parameterTypes, Type[] optionalParameterTypes)
public void EmitCalli(OpCode opcode, CallingConvention unmanagedCallConv, Type returnType, Type[] parameterTypes)
public void EmitWriteLine(LocalBuilder localBuilder)
public void EmitWriteLine(FieldInfo fld)
public void EmitWriteLine(string value)
public void EndExceptionBlock()
public void EndScope()
public void MarkLabel(Label loc)
public void ThrowException(Type excType)
public void UsingNamespace(string usingNamespace)
public ILGenerator GetProxy()
public Type GetProxyType()
public Type GetProxyType(Type tShim)
public Type get_GenericProxyType()
}
internal MonoMod.Utils.Cil.ILGeneratorShimExt : object {
private Dictionary`2<Type, MethodInfo> _Emitters
private Dictionary`2<Type, MethodInfo> _EmittersShim
public ILGeneratorShim GetProxiedShim(ILGenerator il)
public T GetProxiedShim(ILGenerator il)
public object DynEmit(ILGenerator il, OpCode opcode, object operand)
public object DynEmit(ILGenerator il, Object[] emitArgs)
}
internal MonoMod.Utils.DataScope : ValueType {
private ScopeHandlerBase handler
private object data
public object Data
public object get_Data()
public void .ctor(ScopeHandlerBase handler, object data)
public void Dispose()
}
internal MonoMod.Utils.DataScope`1 : ValueType {
private ScopeHandlerBase`1<T> handler
private T data
public T Data
public T get_Data()
public void .ctor(ScopeHandlerBase`1<T> handler, T data)
public void Dispose()
}
internal MonoMod.Utils.DMDCecilGenerator : DMDGenerator`1<DMDCecilGenerator> {
protected MethodInfo GenerateCore(DynamicMethodDefinition dmd, object context)
}
internal MonoMod.Utils.DMDEmitDynamicMethodGenerator : DMDGenerator`1<DMDEmitDynamicMethodGenerator> {
private FieldInfo _DynamicMethod_returnType
protected MethodInfo GenerateCore(DynamicMethodDefinition dmd, object context)
}
internal MonoMod.Utils.DMDEmitMethodBuilderGenerator : DMDGenerator`1<DMDEmitMethodBuilderGenerator> {
private bool _MBCanRunAndCollect
protected MethodInfo GenerateCore(DynamicMethodDefinition dmd, object context)
public MethodBuilder GenerateMethodBuilder(DynamicMethodDefinition dmd, TypeBuilder typeBuilder)
}
internal MonoMod.Utils.DMDGenerator`1 : object {
private TSelf Instance
protected MethodInfo GenerateCore(DynamicMethodDefinition dmd, object context)
private MethodInfo MonoMod.Utils.IDMDGenerator.Generate(DynamicMethodDefinition dmd, object context)
public MethodInfo Generate(DynamicMethodDefinition dmd, object context)
internal MethodInfo Postbuild(MethodInfo mi)
}
internal MonoMod.Utils.DynamicData : DynamicObject {
private Object[] _NoArgs
private Action`3<DynamicData, Type, object> OnInitialize
private Dictionary`2<Type, _Cache_> _CacheMap
private Dictionary`2<Type, _Data_> _DataStaticMap
private ConditionalWeakTable`2<object, _Data_> _DataMap
private ConditionalWeakTable`2<object, DynamicData> _DynamicDataMap
private WeakReference Weak
private object KeepAlive
private _Cache_ _Cache
private _Data_ _Data
private Type <TargetType>k__BackingField
public Dictionary`2<string, Func`2<object, object>> Getters
public Dictionary`2<string, Action`2<object, object>> Setters
public Dictionary`2<string, Func`3<object, Object[], object>> Methods
public Dictionary`2<string, object> Data
public bool IsAlive
public object Target
public Type TargetType
public void add_OnInitialize(Action`3<DynamicData, Type, object> value)
public void remove_OnInitialize(Action`3<DynamicData, Type, object> value)
public Dictionary`2<string, Func`2<object, object>> get_Getters()
public Dictionary`2<string, Action`2<object, object>> get_Setters()
public Dictionary`2<string, Func`3<object, Object[], object>> get_Methods()
public Dictionary`2<string, object> get_Data()
public bool get_IsAlive()
public object get_Target()
public Type get_TargetType()
private void set_TargetType(Type value)
public void .ctor(Type type)
public void .ctor(object obj)
public void .ctor(Type type, object obj)
public void .ctor(Type type, object obj, bool keepAlive)
public DynamicData For(object obj)
public Func`2<object, T> New(Object[] args)
public Func`2<object, object> New(Type type, Object[] args)
public Func`2<object, object> NewWrap(Object[] args)
public Func`2<object, object> NewWrap(Type type, Object[] args)
public object Wrap(object target, object other)
public T Set(T target, object other)
public object Set(object target, object other)
public void RegisterProperty(string name, Func`2<object, object> getter, Action`2<object, object> setter)
public void UnregisterProperty(string name)
public void RegisterMethod(string name, Func`3<object, Object[], object> cb)
public void UnregisterMethod(string name)
public void CopyFrom(object other)
public object Get(string name)
public bool TryGet(string name, Object& value)
public T Get(string name)
public bool TryGet(string name, T& value)
public void Set(string name, object value)
public void Add(KeyValuePair`2<string, object> kvp)
public void Add(string key, object value)
public object Invoke(string name, Object[] args)
public bool TryInvoke(string name, Object[] args, Object& result)
public T Invoke(string name, Object[] args)
public bool TryInvoke(string name, Object[] args, T& result)
private void Dispose(bool disposing)
protected void Finalize()
public void Dispose()
public IEnumerable`1<string> GetDynamicMemberNames()
public bool TryConvert(ConvertBinder binder, Object& result)
public bool TryGetMember(GetMemberBinder binder, Object& result)
public bool TrySetMember(SetMemberBinder binder, object value)
public bool TryInvokeMember(InvokeMemberBinder binder, Object[] args, Object& result)
public IEnumerator`1<KeyValuePair`2<string, object>> GetEnumerator()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
}
internal MonoMod.Utils.DynamicMethodDefinition : object {
private OpCode[] _CecilOpCodes1X
private OpCode[] _CecilOpCodes2X
internal bool _IsNewMonoSRE
internal bool _IsOldMonoSRE
private bool _PreferCecil
internal ConstructorInfo c_DebuggableAttribute
internal ConstructorInfo c_UnverifiableCodeAttribute
internal ConstructorInfo c_IgnoresAccessChecksToAttribute
internal Type t__IDMDGenerator
internal ConcurrentDictionary`2<string, IDMDGenerator> _DMDGeneratorCache
private MethodBase <OriginalMethod>k__BackingField
private MethodDefinition <Definition>k__BackingField
private ModuleDefinition <Module>k__BackingField
private string <Name>k__BackingField
private bool <Debug>k__BackingField
private Guid GUID
private bool isDisposed
public bool IsDynamicILAvailable
public MethodBase OriginalMethod
public MethodDefinition Definition
public ModuleDefinition Module
public string Name
public bool Debug
private void _InitCopier()
private void _CopyMethodToDefinition(MethodBase from, MethodDefinition into)
public bool get_IsDynamicILAvailable()
public MethodBase get_OriginalMethod()
public MethodDefinition get_Definition()
public ModuleDefinition get_Module()
public string get_Name()
public bool get_Debug()
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Debug(bool value)
private bool GetDefaultDebugValue()
public void .ctor(MethodBase method)
public void .ctor(string name, Type returnType, Type[] parameterTypes)
public ILProcessor GetILProcessor()
public ILGenerator GetILGenerator()
private void _CreateDynModule(string name, Type returnType, Type[] parameterTypes, ModuleDefinition& Module, MethodDefinition& Definition)
private void LoadFromMethod(MethodBase orig, ModuleDefinition& Module, MethodDefinition& def)
public MethodInfo Generate()
public MethodInfo Generate(object context)
public void Dispose()
public string GetDumpName(string type)
}
internal MonoMod.Utils.DynamicMethodReference : MethodReference {
private MethodInfo <DynamicMethod>k__BackingField
public MethodInfo DynamicMethod
public MethodInfo get_DynamicMethod()
public void .ctor(ModuleDefinition module, MethodInfo dm)
}
internal MonoMod.Utils.DynamicReferenceCell : ValueType {
private int <Index>k__BackingField
private int <Hash>k__BackingField
public int Index
public int Hash
public int get_Index()
internal void set_Index(int value)
public int get_Hash()
internal void set_Hash(int value)
public void .ctor(int idx, int hash)
public string ToString()
private bool PrintMembers(StringBuilder builder)
public bool op_Inequality(DynamicReferenceCell left, DynamicReferenceCell right)
public bool op_Equality(DynamicReferenceCell left, DynamicReferenceCell right)
public int GetHashCode()
public bool Equals(object obj)
public bool Equals(DynamicReferenceCell other)
}
internal MonoMod.Utils.DynamicReferenceManager : object {
private UIntPtr RefValueCell
private UIntPtr ValueTypeCell
private SpinLock writeLock
private Cell[] modreq(System.Runtime.CompilerServices.IsVolatile) cells
private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) firstEmptyCell
private MethodInfo Self_GetValue_ii
private MethodInfo Self_GetValueT_ii
private MethodInfo Self_GetValueTUnsafe_ii
private DataScope`1<DynamicReferenceCell> AllocReferenceCore(Cell cell, DynamicReferenceCell& cellRef)
private DataScope`1<DynamicReferenceCell> AllocReferenceClass(object value, DynamicReferenceCell& cellRef)
private DataScope`1<DynamicReferenceCell> AllocReferenceStruct(T& value, DynamicReferenceCell& cellRef)
public DataScope`1<DynamicReferenceCell> AllocReference(T& value, DynamicReferenceCell& cellRef)
private Cell GetCell(DynamicReferenceCell cellRef)
public object GetValue(DynamicReferenceCell cellRef)
private T& GetValueRef(DynamicReferenceCell cellRef)
private T& GetValueRefUnsafe(DynamicReferenceCell cellRef)
public T GetValue(DynamicReferenceCell cellRef)
internal object GetValue(int index, int hash)
internal T GetValueT(int index, int hash)
internal T GetValueTUnsafe(int index, int hash)
public void SetValue(DynamicReferenceCell cellRef, T& value)
public void EmitLoadReference(ILProcessor il, DynamicReferenceCell cellRef)
public void EmitLoadReference(ILCursor il, DynamicReferenceCell cellRef)
public void EmitLoadReference(ILGenerator il, DynamicReferenceCell cellRef)
public void EmitLoadTypedReference(ILProcessor il, DynamicReferenceCell cellRef, Type type)
public void EmitLoadTypedReference(ILCursor il, DynamicReferenceCell cellRef, Type type)
public void EmitLoadTypedReference(ILGenerator il, DynamicReferenceCell cellRef, Type type)
internal void EmitLoadTypedReferenceUnsafe(ILProcessor il, DynamicReferenceCell cellRef, Type type)
internal void EmitLoadTypedReferenceUnsafe(ILCursor il, DynamicReferenceCell cellRef, Type type)
internal void EmitLoadTypedReferenceUnsafe(ILGenerator il, DynamicReferenceCell cellRef, Type type)
public DataScope`1<DynamicReferenceCell> EmitNewReference(ILProcessor il, object value, DynamicReferenceCell& cellRef)
public DataScope`1<DynamicReferenceCell> EmitNewReference(ILCursor il, object value, DynamicReferenceCell& cellRef)
public DataScope`1<DynamicReferenceCell> EmitNewReference(ILGenerator il, object value, DynamicReferenceCell& cellRef)
public DataScope`1<DynamicReferenceCell> EmitNewTypedReference(ILProcessor il, T value, DynamicReferenceCell& cellRef)
public DataScope`1<DynamicReferenceCell> EmitNewTypedReference(ILCursor il, T value, DynamicReferenceCell& cellRef)
public DataScope`1<DynamicReferenceCell> EmitNewTypedReference(ILGenerator il, T value, DynamicReferenceCell& cellRef)
}
internal MonoMod.Utils.DynData`1 : object {
private Action`2<DynData`1<TTarget>, TTarget> OnInitialize
private _Data_<TTarget> _DataStatic
private ConditionalWeakTable`2<object, _Data_<TTarget>> _DataMap
private Dictionary`2<string, Func`2<TTarget, object>> _SpecialGetters
private Dictionary`2<string, Action`2<TTarget, object>> _SpecialSetters
private WeakReference Weak
private TTarget KeepAlive
private _Data_<TTarget> _Data
public Dictionary`2<string, Func`2<TTarget, object>> Getters
public Dictionary`2<string, Action`2<TTarget, object>> Setters
public Dictionary`2<string, object> Data
public bool IsAlive
public TTarget Target
public object Item
public void add_OnInitialize(Action`2<DynData`1<TTarget>, TTarget> value)
public void remove_OnInitialize(Action`2<DynData`1<TTarget>, TTarget> value)
public Dictionary`2<string, Func`2<TTarget, object>> get_Getters()
public Dictionary`2<string, Action`2<TTarget, object>> get_Setters()
public Dictionary`2<string, object> get_Data()
public bool get_IsAlive()
public TTarget get_Target()
public object get_Item(string name)
public void set_Item(string name, object value)
public void .ctor(TTarget obj)
public void .ctor(TTarget obj, bool keepAlive)
public T Get(string name)
public void Set(string name, T value)
public void RegisterProperty(string name, Func`2<TTarget, object> getter, Action`2<TTarget, object> setter)
public void UnregisterProperty(string name)
private void Dispose(bool disposing)
protected void Finalize()
public void Dispose()
}
internal MonoMod.Utils.DynDll : object {
private BackendImpl Backend
private BackendImpl CreateCrossplatBackend()
public IntPtr OpenLibrary(string name)
public bool TryOpenLibrary(string name, IntPtr& libraryPtr)
public void CloseLibrary(IntPtr lib)
public bool TryCloseLibrary(IntPtr lib)
public IntPtr GetExport(IntPtr libraryPtr, string name)
public bool TryGetExport(IntPtr libraryPtr, string name, IntPtr& functionPtr)
}
internal MonoMod.Utils.Extensions : object {
private Type t_Code
private Type t_OpCodes
private Dictionary`2<int, OpCode> _ToLongOp
private Dictionary`2<int, OpCode> _ToShortOp
private Dictionary`2<Type, FieldInfo> fmap_mono_assembly
private bool _MonoAssemblyNameHasArch
private Type _RTDynamicMethod
private Type t_ParamArrayAttribute
private FieldInfo f_GenericParameter_position
private FieldInfo f_GenericParameter_type
private ConcurrentDictionary`2<Type, int> _GetManagedSizeCache
private MethodInfo _GetManagedSizeHelper
private Dictionary`2<MethodBase, Func`1<IntPtr>> _GetLdftnPointerCache
private Type RTDynamicMethod
private FieldInfo RTDynamicMethod_m_owner
private Type t_StateMachineAttribute
private PropertyInfo p_StateMachineType
public TypeDefinition SafeResolve(TypeReference r)
public FieldDefinition SafeResolve(FieldReference r)
public MethodDefinition SafeResolve(MethodReference r)
public PropertyDefinition SafeResolve(PropertyReference r)
public CustomAttribute GetCustomAttribute(ICustomAttributeProvider cap, string attribute)
public bool HasCustomAttribute(ICustomAttributeProvider cap, string attribute)
public int GetInt(Instruction instr)
public Nullable`1<int> GetIntOrNull(Instruction instr)
public bool IsBaseMethodCall(MethodBody body, MethodReference called)
public bool IsCallvirt(MethodReference method)
public bool IsStruct(TypeReference type)
public OpCode ToLongOp(OpCode op)
public OpCode ToShortOp(OpCode op)
public void RecalculateILOffsets(MethodDefinition method)
public void FixShortLongOps(MethodDefinition method)
public bool Is(MemberInfo minfo, MemberReference mref)
public bool Is(MemberReference mref, MemberInfo minfo)
public IMetadataTokenProvider ImportReference(ModuleDefinition mod, IMetadataTokenProvider mtp)
public void AddRange(Collection`1<T> list, IEnumerable`1<T> other)
public void AddRange(IDictionary dict, IDictionary other)
public void AddRange(IDictionary`2<TKey, TValue> dict, IDictionary`2<TKey, TValue> other)
public void AddRange(Dictionary`2<TKey, TValue> dict, Dictionary`2<TKey, TValue> other)
public void InsertRange(Collection`1<T> list, int index, IEnumerable`1<T> other)
public bool IsCompatible(Type type, Type other)
private bool _IsCompatible(Type type, Type other)
public T GetDeclaredMember(T member)
public void SetMonoCorlibInternal(Assembly asm, bool value)
public bool IsDynamicMethod(MethodBase method)
public object SafeGetTarget(WeakReference weak)
public bool SafeGetIsAlive(WeakReference weak)
public T CreateDelegate(MethodBase method)
public T CreateDelegate(MethodBase method, object target)
public Delegate CreateDelegate(MethodBase method, Type delegateType)
public Delegate CreateDelegate(MethodBase method, Type delegateType, object target)
public T TryCreateDelegate(MethodInfo mi)
public MethodDefinition FindMethod(TypeDefinition type, string id, bool simple)
public MethodDefinition FindMethodDeep(TypeDefinition type, string id, bool simple)
public MethodInfo FindMethod(Type type, string id, bool simple)
public MethodInfo FindMethodDeep(Type type, string id, bool simple)
public PropertyDefinition FindProperty(TypeDefinition type, string name)
public PropertyDefinition FindPropertyDeep(TypeDefinition type, string name)
public FieldDefinition FindField(TypeDefinition type, string name)
public FieldDefinition FindFieldDeep(TypeDefinition type, string name)
public EventDefinition FindEvent(TypeDefinition type, string name)
public EventDefinition FindEventDeep(TypeDefinition type, string name)
public string GetID(MethodReference method, string name, string type, bool withType, bool simple)
public string GetID(CallSite method)
public string GetID(MethodBase method, string name, string type, bool withType, bool proxyMethod, bool simple)
public string GetPatchName(MemberReference mr)
public string GetPatchFullName(MemberReference mr)
private string GetPatchName(ICustomAttributeProvider cap)
private string GetPatchFullName(ICustomAttributeProvider cap, MemberReference mr)
public MethodDefinition Clone(MethodDefinition o, MethodDefinition c)
public MethodBody Clone(MethodBody bo, MethodDefinition m)
public GenericParameter Update(GenericParameter param, int position, GenericParameterType type)
public GenericParameter ResolveGenericParameter(IGenericParameterProvider provider, GenericParameter orig)
public IMetadataTokenProvider Relink(IMetadataTokenProvider mtp, Relinker relinker, IGenericParameterProvider context)
public TypeReference Relink(TypeReference type, Relinker relinker, IGenericParameterProvider context)
public GenericParameterConstraint Relink(GenericParameterConstraint constraint, Relinker relinker, IGenericParameterProvider context)
public IMetadataTokenProvider Relink(MethodReference method, Relinker relinker, IGenericParameterProvider context)
public CallSite Relink(CallSite method, Relinker relinker, IGenericParameterProvider context)
public IMetadataTokenProvider Relink(FieldReference field, Relinker relinker, IGenericParameterProvider context)
public ParameterDefinition Relink(ParameterDefinition param, Relinker relinker, IGenericParameterProvider context)
public ParameterDefinition Clone(ParameterDefinition param)
public CustomAttribute Relink(CustomAttribute attrib, Relinker relinker, IGenericParameterProvider context)
public CustomAttribute Clone(CustomAttribute attrib)
public GenericParameter Relink(GenericParameter param, Relinker relinker, IGenericParameterProvider context)
public GenericParameter Clone(GenericParameter param)
public int GetManagedSize(Type t)
private int ComputeManagedSize(Type t)
public Type GetThisParamType(MethodBase method)
public IntPtr GetLdftnPointer(MethodBase m)
public string ToHexadecimalString(Byte[] data)
public T InvokePassing(MulticastDelegate md, T val, Object[] args)
public bool InvokeWhileTrue(MulticastDelegate md, Object[] args)
public bool InvokeWhileFalse(MulticastDelegate md, Object[] args)
public T InvokeWhileNull(MulticastDelegate md, Object[] args)
public string SpacedPascalCase(string input)
public string ReadNullTerminatedString(BinaryReader stream)
public void WriteNullTerminatedString(BinaryWriter stream, string text)
private MethodBase GetRealMethod(MethodBase method)
public T CastDelegate(Delegate source)
public Delegate CastDelegate(Delegate source, Type type)
public bool TryCastDelegate(Delegate source, T& result)
public bool TryCastDelegate(Delegate source, Type type, Delegate& result)
public MethodInfo GetStateMachineTarget(MethodInfo method)
public MethodBase GetActualGenericMethodDefinition(MethodInfo method)
public MethodBase GetUnfilledMethodOnGenericType(MethodBase method)
public bool Is(MemberReference member, string fullName)
public bool Is(MemberReference member, string typeFullName, string name)
public bool Is(MemberReference member, Type type, string name)
public bool Is(MethodReference method, string fullName)
public bool Is(MethodReference method, string typeFullName, string name)
public bool Is(MethodReference method, Type type, string name)
public void ReplaceOperands(ILProcessor il, object from, object to)
public FieldReference Import(ILProcessor il, FieldInfo field)
public MethodReference Import(ILProcessor il, MethodBase method)
public TypeReference Import(ILProcessor il, Type type)
public MemberReference Import(ILProcessor il, MemberInfo member)
public Instruction Create(ILProcessor il, OpCode opcode, FieldInfo field)
public Instruction Create(ILProcessor il, OpCode opcode, MethodBase method)
public Instruction Create(ILProcessor il, OpCode opcode, Type type)
public Instruction Create(ILProcessor il, OpCode opcode, object operand)
public Instruction Create(ILProcessor il, OpCode opcode, MemberInfo member)
public void Emit(ILProcessor il, OpCode opcode, FieldInfo field)
public void Emit(ILProcessor il, OpCode opcode, MethodBase method)
public void Emit(ILProcessor il, OpCode opcode, Type type)
public void Emit(ILProcessor il, OpCode opcode, MemberInfo member)
public void Emit(ILProcessor il, OpCode opcode, object operand)
}
internal MonoMod.Utils.FastReflectionHelper : object {
private Type[] FastStructInvokerArgs
private MethodInfo S2FValueType
private MethodInfo S2FNullable
private WeakBox CachedWeakBox
private MethodInfo S2FClass
private MethodInfo S2FVoid
private ConditionalWeakTable`2<MemberInfo, FSITuple> fastStructInvokers
private ConditionalWeakTable`2<FSITuple, FastInvoker> fastInvokers
private MethodInfo CheckArgsMethod
private int TargetArgId
private int ResultArgId
private MethodInfo BadArgExceptionMethod
private FieldInfo WeakBoxValueField
private object FastInvokerForStructInvokerVT(FastStructInvoker invoker, object target, Object[] args)
private object FastInvokerForStructInvokerNullable(FastStructInvoker invoker, object target, Object[] args)
private object FastInvokerForStructInvokerClass(FastStructInvoker invoker, object target, Object[] args)
private object FastInvokerForStructInvokerVoid(FastStructInvoker invoker, object target, Object[] args)
private FastInvoker CreateFastInvoker(FastStructInvoker fsi, ReturnTypeClass retTypeClass, Type returnType)
private FSITuple GetFSITuple(MethodBase method)
private FSITuple GetFSITuple(FieldInfo field)
private FSITuple GetFSITuple(MemberInfo member)
private FastInvoker GetFastInvoker(FSITuple tuple)
public FastStructInvoker GetFastStructInvoker(MethodBase method)
public FastStructInvoker GetFastStructInvoker(FieldInfo field)
public FastStructInvoker GetFastStructInvoker(MemberInfo member)
public FastInvoker GetFastInvoker(MethodBase method)
public FastInvoker GetFastInvoker(FieldInfo field)
public FastInvoker GetFastInvoker(MemberInfo member)
private void CheckArgs(bool isStatic, object target, int retTypeClass, object result, int expectLen, Object[] args)
private Exception BadArgException(int arg, RuntimeTypeHandle expectType, object target, object result, Object[] args)
private ReturnTypeClass ClassifyType(Type returnType)
private void EmitCheckArgs(ILCursor il, bool isStatic, ReturnTypeClass rtc, int expectParams)
private void EmitCheckType(ILCursor il, int argId, Type expectType, ILLabel badArgLbl)
private void EmitCheckAllowNull(ILCursor il, int argId, Type expectType, ILLabel badArgLbl)
private void EmitBadArgCall(ILCursor il, ILLabel badArgLbl)
private void EmitCheckByref(ILCursor il, ReturnTypeClass rtc, Type returnType, ILLabel badArgLbl, int argId)
private void EmitLoadByref(ILCursor il, ReturnTypeClass rtc, Type returnType)
private void EmitLoadArgO(ILCursor il, int arg)
private void EmitStoreByref(ILCursor il, ReturnTypeClass rtc, Type returnType)
private FastStructInvoker CreateMethodInvoker(MethodBase method, ReturnTypeClass& retTypeClass, Type& retType)
private FastStructInvoker CreateFieldInvoker(FieldInfo field, ReturnTypeClass& retTypeClass, Type& retType)
internal void <CheckArgs>g__ThrowArgumentOutOfRange|28_0()
}
internal MonoMod.Utils.GenericMethodInstantiationComparer : object {
internal Type CannonicalFillType
private IEqualityComparer`1<Type> genericTypeComparer
public void .ctor(IEqualityComparer`1<Type> typeComparer)
public bool Equals(MethodBase x, MethodBase y)
public int GetHashCode(MethodBase obj)
}
internal MonoMod.Utils.GenericTypeInstantiationComparer : object {
private Type CannonicalFillType
public bool Equals(Type x, Type y)
public int GetHashCode(Type obj)
}
internal MonoMod.Utils.Helpers : object {
public void Swap(T& a, T& b)
public bool Has(T value, T flag)
public void ThrowIfArgumentNull(T arg, string name)
public T ThrowIfNull(T arg, string name)
public T EventAdd(T& evt, T del)
public T EventRemove(T& evt, T del)
public void Assert(bool value, string message, string expr)
public void DAssert(bool value, string message, string expr)
public void Assert(bool value, AssertionInterpolatedStringHandler& message, string expr)
public void DAssert(bool value, AssertionInterpolatedStringHandler& message, string expr)
private void ThrowArgumentNull(string argName)
private void ThrowAssertionFailed(string msg, string expr)
private void ThrowAssertionFailed(AssertionInterpolatedStringHandler& message, string expr)
public T GetOrInit(T& location, Func`1<T> init)
public T GetOrInitWithLock(T& location, object lock, Func`1<T> init)
public T GetOrInit(T& location, method init)
public T GetOrInitWithLock(T& location, object lock, method init)
public T GetOrInit(T& location, method init, TParam obj)
public T GetOrInitWithLock(T& location, object lock, method init, TParam obj)
private T InitializeValue(T& location, method init, TParam obj)
private T InitializeValueWithLock(T& location, object lock, method init, TParam obj)
public bool MaskedSequenceEqual(ReadOnlySpan`1<byte> first, ReadOnlySpan`1<byte> second, ReadOnlySpan`1<byte> mask)
private void ThrowMaskTooShort()
private bool MaskedSequenceEqualCore(Byte& first, Byte& second, Byte& maskBytes, UIntPtr length)
public Byte[] ReadAllBytes(string path)
private Byte[] ReadAllBytesUnknownLength(FileStream fs)
}
internal MonoMod.Utils.ICallSiteGenerator {
public CallSite ToCallSite(ModuleDefinition module)
}
internal MonoMod.Utils.IDMDGenerator {
public MethodInfo Generate(DynamicMethodDefinition dmd, object context)
}
internal MonoMod.Utils.Interop.OSX : object {
public string LibSystem
public int Uname(Byte* buf)
}
internal MonoMod.Utils.Interop.Unix : object {
public string LibC
public string DL1
public string DL2
public int AT_PLATFORM
private int dlVersion
public int Uname(Byte* buf)
private IntPtr DL1dlopen(Byte* filename, DlopenFlags flags)
private int DL1dlclose(IntPtr handle)
private IntPtr DL1dlsym(IntPtr handle, Byte* symbol)
private IntPtr DL1dlerror()
private IntPtr DL2dlopen(Byte* filename, DlopenFlags flags)
private int DL2dlclose(IntPtr handle)
private IntPtr DL2dlsym(IntPtr handle, Byte* symbol)
private IntPtr DL2dlerror()
internal Byte[] MarshalToUtf8(string str)
internal void FreeMarshalledArray(Byte[] arr)
public IntPtr DlOpen(string filename, DlopenFlags flags)
public bool DlClose(IntPtr handle)
public IntPtr DlSym(IntPtr handle, string symbol)
public IntPtr DlError()
}
internal MonoMod.Utils.Interop.Windows : object {
public int PROCESSOR_ARCHITECTURE_INTEL
public int PROCESSOR_ARCHITECTURE_MIPS
public int PROCESSOR_ARCHITECTURE_ALPHA
public int PROCESSOR_ARCHITECTURE_PPC
public int PROCESSOR_ARCHITECTURE_SHX
public int PROCESSOR_ARCHITECTURE_ARM
public int PROCESSOR_ARCHITECTURE_IA64
public int PROCESSOR_ARCHITECTURE_ALPHA64
public int PROCESSOR_ARCHITECTURE_MSIL
public int PROCESSOR_ARCHITECTURE_AMD64
public int PROCESSOR_ARCHITECTURE_IA32_ON_WIN64
public int PROCESSOR_ARCHITECTURE_NEUTRAL
public int PROCESSOR_ARCHITECTURE_ARM64
public int PROCESSOR_ARCHITECTURE_ARM32_ON_WIN64
public int PROCESSOR_ARCHITECTURE_IA32_ON_ARM64
public int PROCESSOR_ARCHITECTURE_UNKNOWN
public void GetSystemInfo(SYSTEM_INFO* lpSystemInfo)
public HMODULE GetModuleHandleW(UInt16* lpModuleName)
public IntPtr GetProcAddress(HMODULE hModule, SByte* lpProcName)
public HMODULE LoadLibraryW(UInt16* lpLibFileName)
public BOOL FreeLibrary(HMODULE hLibModule)
public UInt32 GetLastError()
}
internal MonoMod.Utils.LazyDisposable : object {
private Action OnDispose
public void add_OnDispose(Action value)
public void remove_OnDispose(Action value)
public void .ctor(Action a)
public void Dispose()
}
internal MonoMod.Utils.LazyDisposable`1 : object {
private T Instance
private Action`1<T> OnDispose
public void add_OnDispose(Action`1<T> value)
public void remove_OnDispose(Action`1<T> value)
public void .ctor(T instance)
public void .ctor(T instance, Action`1<T> a)
public void Dispose()
}
internal MonoMod.Utils.MethodSignature : object {
private Type <ReturnType>k__BackingField
private Type[] parameters
private ConditionalWeakTable`2<MethodBase, MethodSignature> thisSigMap
private ConditionalWeakTable`2<MethodBase, MethodSignature> noThisSigMap
public Type ReturnType
public int ParameterCount
public IEnumerable`1<Type> Parameters
public Type FirstParameter
public Type get_ReturnType()
public int get_ParameterCount()
public IEnumerable`1<Type> get_Parameters()
public Type get_FirstParameter()
public void .ctor(Type returnType, Type[] parameters)
public void .ctor(Type returnType, IEnumerable`1<Type> parameters)
public void .ctor(MethodBase method)
public void .ctor(MethodBase method, bool ignoreThis)
public MethodSignature ForMethod(MethodBase method)
public MethodSignature ForMethod(MethodBase method, bool ignoreThis)
public bool IsCompatibleWith(MethodSignature other)
public DynamicMethodDefinition CreateDmd(string name)
public string ToString()
private bool MonoMod.Logs.IDebugFormattable.TryFormatInto(Span`1<char> span, Int32& wrote)
public bool Equals(MethodSignature other)
public bool Equals(object obj)
public int GetHashCode()
}
internal MonoMod.Utils.MMReflectionImporter : object {
public IReflectionImporterProvider Provider
public IReflectionImporterProvider ProviderNoDefault
private ModuleDefinition Module
private DefaultReflectionImporter Default
private Dictionary`2<Assembly, AssemblyNameReference> CachedAsms
private Dictionary`2<Module, TypeReference> CachedModuleTypes
private Dictionary`2<Type, TypeReference> CachedTypes
private Dictionary`2<FieldInfo, FieldReference> CachedFields
private Dictionary`2<MethodBase, MethodReference> CachedMethods
private bool <UseDefault>k__BackingField
private Dictionary`2<Type, TypeReference> ElementTypes
public bool UseDefault
public bool get_UseDefault()
public void set_UseDefault(bool value)
public void .ctor(ModuleDefinition module)
private bool TryGetCachedType(Type type, TypeReference& typeRef, GenericImportKind importKind)
private TypeReference SetCachedType(Type type, TypeReference typeRef, GenericImportKind importKind)
public AssemblyNameReference ImportReference(AssemblyName reference)
public AssemblyNameReference ImportReference(Assembly asm)
public TypeReference ImportModuleType(Module module, IGenericParameterProvider context)
public TypeReference ImportReference(Type type, IGenericParameterProvider context)
private bool _IsGenericInstance(Type type, GenericImportKind importKind)
private GenericInstanceType _ImportGenericInstance(Type type, IGenericParameterProvider context, TypeReference typeRef)
private TypeReference _ImportReference(Type type, IGenericParameterProvider context, GenericImportKind importKind)
private GenericParameter ImportGenericParameter(Type type, IGenericParameterProvider context)
public FieldReference ImportReference(FieldInfo field, IGenericParameterProvider context)
public MethodReference ImportReference(MethodBase method, IGenericParameterProvider context)
private MethodReference _ImportReference(MethodBase method, IGenericParameterProvider context, GenericImportKind importKind)
}
internal MonoMod.Utils.OSKind : Enum {
public int value__
public OSKind Unknown
public OSKind Posix
public OSKind Linux
public OSKind Android
public OSKind OSX
public OSKind IOS
public OSKind BSD
public OSKind Windows
public OSKind Wine
}
internal MonoMod.Utils.OSKindExtensions : object {
public bool Is(OSKind operatingSystem, OSKind test)
public OSKind GetKernel(OSKind operatingSystem)
public int GetSubtypeId(OSKind operatingSystem)
}
internal MonoMod.Utils.PlatformDetection : object {
private int platInitState
private OSKind os
private ArchitectureKind arch
private int runtimeInitState
private RuntimeKind runtime
private Version runtimeVersion
public OSKind OS
public ArchitectureKind Architecture
public RuntimeKind Runtime
public Version RuntimeVersion
private void EnsurePlatformInfoInitialized()
public OSKind get_OS()
public ArchitectureKind get_Architecture()
private ValueTuple`2<OSKind, ArchitectureKind> DetectPlatformInfo()
private int PosixUname(OSKind os, Byte* buf)
private string GetCString(ReadOnlySpan`1<byte> buffer, Int32& nullByte)
private void DetectInfoPosix(OSKind& os, ArchitectureKind& arch)
private void DetectInfoWindows(OSKind& os, ArchitectureKind& arch)
private bool CheckWine()
private void EnsureRuntimeInitialized()
public RuntimeKind get_Runtime()
public Version get_RuntimeVersion()
private ValueTuple`2<RuntimeKind, Version> DetermineRuntimeInfo()
internal int <PosixUname>g__Libc|9_0(Byte* buf)
internal int <PosixUname>g__Osx|9_1(Byte* buf)
}
internal MonoMod.Utils.ReflectionHelper : object {
internal bool IsCoreBCL
internal Dictionary`2<string, WeakReference> AssemblyCache
internal Dictionary`2<string, WeakReference[]> AssembliesCache
internal Dictionary`2<string, WeakReference> ResolveReflectionCache
public Byte[] AssemblyHashPrefix
public string AssemblyHashNameTag
private BindingFlags _BindingFlagsAll
private GetUnmanagedSigHelperDelegate GetUnmanagedSigHelper
private Object[] _CacheGetterArgs
private Type t_RuntimeType
private Type t_RuntimeTypeCache
private PropertyInfo p_RuntimeType_Cache
private MethodInfo m_RuntimeTypeCache_GetFieldList
private MethodInfo m_RuntimeTypeCache_GetPropertyList
private ConditionalWeakTable`2<Type, CacheFixEntry> _CacheFixed
private Type t_RuntimeModule
private PropertyInfo p_RuntimeModule_RuntimeType
private FieldInfo f_RuntimeModule__impl
private MethodInfo m_RuntimeModule_GetGlobalType
private FieldInfo f_SignatureHelper_module
private MemberInfo _Cache(string cacheKey, MemberInfo value)
public Assembly Load(ModuleDefinition module)
public Assembly Load(Stream stream)
public Type GetType(string name)
public void ApplyRuntimeHash(AssemblyNameReference asmRef, Assembly asm)
public string GetRuntimeHashedFullName(Assembly asm)
public string GetRuntimeHashedFullName(AssemblyNameReference asm)
public Type ResolveReflection(TypeReference mref)
public MethodBase ResolveReflection(MethodReference mref)
public FieldInfo ResolveReflection(FieldReference mref)
public PropertyInfo ResolveReflection(PropertyReference mref)
public EventInfo ResolveReflection(EventReference mref)
public MemberInfo ResolveReflection(MemberReference mref)
private MemberInfo _ResolveReflection(MemberReference mref, Module[] modules)
public SignatureHelper ResolveReflection(CallSite csite, Module context)
public SignatureHelper ResolveReflectionSignature(IMethodSignature csite, Module context)
public void FixReflectionCacheAuto(Type type)
public void FixReflectionCache(Type type)
private bool _Verify(CacheFixEntry entry, Type type)
private Array _GetArray(object cache, MethodInfo getter)
private void _FixReflectionCacheOrder(Array orig)
public Type GetModuleType(Module module)
public Type GetRealDeclaringType(MemberInfo member)
private Module GetSignatureHelperModule(SignatureHelper signature)
public CallSite ImportCallSite(ModuleDefinition moduleTo, ICallSiteGenerator signature)
public CallSite ImportCallSite(ModuleDefinition moduleTo, SignatureHelper signature)
public CallSite ImportCallSite(ModuleDefinition moduleTo, Module moduleFrom, int token)
public CallSite ImportCallSite(ModuleDefinition moduleTo, Module moduleFrom, Byte[] data)
internal void <ImportCallSite>g__ReadMethodSignature|50_0(IMethodSignature method, <>c__DisplayClass50_0& , <>c__DisplayClass50_1& )
internal UInt32 <ImportCallSite>g__ReadCompressedUInt32|50_1(<>c__DisplayClass50_1& )
internal int <ImportCallSite>g__ReadCompressedInt32|50_2(<>c__DisplayClass50_1& )
internal TypeReference <ImportCallSite>g__GetTypeDefOrRef|50_3(<>c__DisplayClass50_0& , <>c__DisplayClass50_1& )
internal TypeReference <ImportCallSite>g__ReadTypeSignature|50_4(<>c__DisplayClass50_0& , <>c__DisplayClass50_1& )
}
internal MonoMod.Utils.Relinker : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public IMetadataTokenProvider Invoke(IMetadataTokenProvider mtp, IGenericParameterProvider context)
public IAsyncResult BeginInvoke(IMetadataTokenProvider mtp, IGenericParameterProvider context, AsyncCallback callback, object object)
public IMetadataTokenProvider EndInvoke(IAsyncResult result)
}
internal MonoMod.Utils.RelinkFailedException : Exception {
public string DefaultMessage
private IMetadataTokenProvider <MTP>k__BackingField
private IMetadataTokenProvider <Context>k__BackingField
public IMetadataTokenProvider MTP
public IMetadataTokenProvider Context
public IMetadataTokenProvider get_MTP()
public IMetadataTokenProvider get_Context()
public void .ctor(IMetadataTokenProvider mtp, IMetadataTokenProvider context)
public void .ctor(string message, IMetadataTokenProvider mtp, IMetadataTokenProvider context)
public void .ctor(string message, Exception innerException, IMetadataTokenProvider mtp, IMetadataTokenProvider context)
protected string Format(string message, IMetadataTokenProvider mtp, IMetadataTokenProvider context)
}
internal MonoMod.Utils.RelinkTargetNotFoundException : RelinkFailedException {
public string DefaultMessage
public void .ctor(IMetadataTokenProvider mtp, IMetadataTokenProvider context)
public void .ctor(string message, IMetadataTokenProvider mtp, IMetadataTokenProvider context)
public void .ctor(string message, Exception innerException, IMetadataTokenProvider mtp, IMetadataTokenProvider context)
}
internal MonoMod.Utils.RuntimeKind : Enum {
public int value__
public RuntimeKind Unknown
public RuntimeKind Framework
public RuntimeKind CoreCLR
public RuntimeKind Mono
}
internal MonoMod.Utils.ScopeHandlerBase : object {
public void EndScope(object data)
}
internal MonoMod.Utils.ScopeHandlerBase`1 : ScopeHandlerBase {
public void EndScope(object data)
public void EndScope(T data)
}
internal MonoMod.Utils.WeakBox : object {
public object Value
}
internal MonoMod.Utils.WeakReferenceComparer : EqualityComparer`1<WeakReference> {
public bool Equals(WeakReference x, WeakReference y)
public int GetHashCode(WeakReference obj)
}
internal System.Array2 : object {
public T[] Empty()
}
internal System.ArrayEx : object {
public int MaxLength
public T[] Empty()
public int get_MaxLength()
}
internal System.Buffers.ArrayPool`1 : object {
private TlsOverPerCoreLockedStacksArrayPool`1<T> s_shared
public ArrayPool`1<T> Shared
public ArrayPool`1<T> get_Shared()
public ArrayPool`1<T> Create()
public ArrayPool`1<T> Create(int maxArrayLength, int maxArraysPerBucket)
public T[] Rent(int minimumLength)
public void Return(T[] array, bool clearArray)
}
internal System.Buffers.BuffersExtensions : object {
public Nullable`1<SequencePosition> PositionOf(ReadOnlySequence`1& source, T value)
private Nullable`1<SequencePosition> PositionOfMultiSegment(ReadOnlySequence`1& source, T value)
public void CopyTo(ReadOnlySequence`1& source, Span`1<T> destination)
private void CopyToMultiSegment(ReadOnlySequence`1& sequence, Span`1<T> destination)
public T[] ToArray(ReadOnlySequence`1& sequence)
public void Write(IBufferWriter`1<T> writer, ReadOnlySpan`1<T> value)
private void WriteMultiSegment(IBufferWriter`1<T> writer, ReadOnlySpan`1& source, Span`1<T> destination)
}
internal System.Buffers.ConfigurableArrayPool`1 : ArrayPool`1<T> {
private int DefaultMaxArrayLength
private int DefaultMaxNumberOfArraysPerBucket
private Bucket[] _buckets
private int Id
internal void .ctor(int maxArrayLength, int maxArraysPerBucket)
private int get_Id()
public T[] Rent(int minimumLength)
public void Return(T[] array, bool clearArray)
}
internal System.Buffers.IBufferWriter`1 {
public void Advance(int count)
public Memory`1<T> GetMemory(int sizeHint)
public Span`1<T> GetSpan(int sizeHint)
}
internal System.Buffers.IMemoryOwner`1 {
public Memory`1<T> Memory
public Memory`1<T> get_Memory()
}
internal System.Buffers.IPinnable {
public MemoryHandle Pin(int elementIndex)
public void Unpin()
}
internal System.Buffers.MemoryHandle : ValueType {
private Void* _pointer
private GCHandle _handle
private IPinnable _pinnable
public Void* Pointer
public void .ctor(Void* pointer, GCHandle handle, IPinnable pinnable)
public Void* get_Pointer()
public void Dispose()
}
internal System.Buffers.MemoryManager`1 : object {
public Memory`1<T> Memory
public Memory`1<T> get_Memory()
public Span`1<T> GetSpan()
public MemoryHandle Pin(int elementIndex)
public void Unpin()
protected Memory`1<T> CreateMemory(int length)
protected Memory`1<T> CreateMemory(int start, int length)
protected internal bool TryGetArray(ArraySegment`1& segment)
private void System.IDisposable.Dispose()
protected void Dispose(bool disposing)
}
internal System.Buffers.ReadOnlySequence : object {
public int FlagBitMask
public int IndexBitMask
public int SegmentStartMask
public int SegmentEndMask
public int ArrayStartMask
public int ArrayEndMask
public int MemoryManagerStartMask
public int MemoryManagerEndMask
public int StringStartMask
public int StringEndMask
public int SegmentToSequenceStart(int startIndex)
public int SegmentToSequenceEnd(int endIndex)
public int ArrayToSequenceStart(int startIndex)
public int ArrayToSequenceEnd(int endIndex)
public int MemoryManagerToSequenceStart(int startIndex)
public int MemoryManagerToSequenceEnd(int endIndex)
public int StringToSequenceStart(int startIndex)
public int StringToSequenceEnd(int endIndex)
}
internal System.Buffers.ReadOnlySequence`1 : ValueType {
private SequencePosition _sequenceStart
private SequencePosition _sequenceEnd
public ReadOnlySequence`1<T> Empty
public long Length
public bool IsEmpty
public bool IsSingleSegment
public ReadOnlyMemory`1<T> First
public SequencePosition Start
public SequencePosition End
public long get_Length()
public bool get_IsEmpty()
public bool get_IsSingleSegment()
public ReadOnlyMemory`1<T> get_First()
public SequencePosition get_Start()
public SequencePosition get_End()
private void .ctor(object startSegment, int startIndexAndFlags, object endSegment, int endIndexAndFlags)
public void .ctor(ReadOnlySequenceSegment`1<T> startSegment, int startIndex, ReadOnlySequenceSegment`1<T> endSegment, int endIndex)
public void .ctor(T[] array)
public void .ctor(T[] array, int start, int length)
public void .ctor(ReadOnlyMemory`1<T> memory)
public ReadOnlySequence`1<T> Slice(long start, long length)
public ReadOnlySequence`1<T> Slice(long start, SequencePosition end)
public ReadOnlySequence`1<T> Slice(SequencePosition start, long length)
public ReadOnlySequence`1<T> Slice(int start, int length)
public ReadOnlySequence`1<T> Slice(int start, SequencePosition end)
public ReadOnlySequence`1<T> Slice(SequencePosition start, int length)
public ReadOnlySequence`1<T> Slice(SequencePosition start, SequencePosition end)
public ReadOnlySequence`1<T> Slice(SequencePosition start)
public ReadOnlySequence`1<T> Slice(long start)
public string ToString()
public Enumerator<T> GetEnumerator()
public SequencePosition GetPosition(long offset)
public SequencePosition GetPosition(long offset, SequencePosition origin)
public bool TryGet(SequencePosition& position, ReadOnlyMemory`1& memory, bool advance)
internal bool TryGetBuffer(SequencePosition& position, ReadOnlyMemory`1& memory, SequencePosition& next)
private ReadOnlyMemory`1<T> GetFirstBuffer()
private SequencePosition Seek(SequencePosition& start, SequencePosition& end, long offset, ExceptionArgument argument)
private SequencePosition SeekMultiSegment(ReadOnlySequenceSegment`1<T> currentSegment, object endObject, int endIndex, long offset, ExceptionArgument argument)
private void BoundsCheck(SequencePosition& position)
private void BoundsCheck(UInt32 sliceStartIndex, object sliceStartObject, UInt32 sliceEndIndex, object sliceEndObject)
private SequencePosition GetEndPosition(ReadOnlySequenceSegment`1<T> startSegment, object startObject, int startIndex, object endObject, int endIndex, long length)
private SequenceType<T> GetSequenceType()
private int GetIndex(SequencePosition& position)
private ReadOnlySequence`1<T> SliceImpl(SequencePosition& start, SequencePosition& end)
private long GetLength()
internal bool TryGetReadOnlySequenceSegment(ReadOnlySequenceSegment`1& startSegment, Int32& startIndex, ReadOnlySequenceSegment`1& endSegment, Int32& endIndex)
internal bool TryGetArray(ArraySegment`1& segment)
internal bool TryGetString(String& text, Int32& start, Int32& length)
private bool InRange(UInt32 value, UInt32 start, UInt32 end)
private bool InRange(ulong value, ulong start, ulong end)
}
internal System.Buffers.ReadOnlySequenceDebugView`1 : object {
private T[] _array
private ReadOnlySequenceDebugViewSegments<T> _segments
public ReadOnlySequenceDebugViewSegments<T> BufferSegments
public T[] Items
public void .ctor(ReadOnlySequence`1<T> sequence)
public ReadOnlySequenceDebugViewSegments<T> get_BufferSegments()
public T[] get_Items()
}
internal System.Buffers.ReadOnlySequenceSegment`1 : object {
private ReadOnlyMemory`1<T> <Memory>k__BackingField
private ReadOnlySequenceSegment`1<T> <Next>k__BackingField
private long <RunningIndex>k__BackingField
public ReadOnlyMemory`1<T> Memory
public ReadOnlySequenceSegment`1<T> Next
public long RunningIndex
public ReadOnlyMemory`1<T> get_Memory()
protected void set_Memory(ReadOnlyMemory`1<T> value)
public ReadOnlySequenceSegment`1<T> get_Next()
protected void set_Next(ReadOnlySequenceSegment`1<T> value)
public long get_RunningIndex()
protected void set_RunningIndex(long value)
}
internal System.Buffers.StandardFormat : ValueType {
public byte NoPrecision
public byte MaxPrecision
private byte _format
private byte _precision
public char Symbol
public byte Precision
public bool HasPrecision
public bool IsDefault
public char get_Symbol()
public byte get_Precision()
public bool get_HasPrecision()
public bool get_IsDefault()
public void .ctor(char symbol, byte precision)
public StandardFormat op_Implicit(char symbol)
public StandardFormat Parse(ReadOnlySpan`1<char> format)
public StandardFormat Parse(string format)
public bool Equals(object obj)
public int GetHashCode()
public bool Equals(StandardFormat other)
public string ToString()
public bool op_Equality(StandardFormat left, StandardFormat right)
public bool op_Inequality(StandardFormat left, StandardFormat right)
}
internal System.Buffers.TlsOverPerCoreLockedStacksArrayPool`1 : ArrayPool`1<T> {
private int NumBuckets
private int MaxPerCorePerArraySizeStacks
private int MaxBuffersPerArraySizePerCore
private ThreadLocalArray[] t_tlsBuckets
private ConditionalWeakTable`2<ThreadLocalArray[], object> _allTlsBuckets
private PerCoreLockedStacks[] _buckets
private int _trimCallbackCreated
private int Id
private PerCoreLockedStacks<T> CreatePerCoreLockedStacks(int bucketIndex)
private int get_Id()
public T[] Rent(int minimumLength)
public void Return(T[] array, bool clearArray)
public bool Trim()
private ThreadLocalArray[] InitializeTlsBucketsAndTrimming()
}
internal System.Buffers.Utilities : object {
internal int SelectBucketIndex(int bufferSize)
internal int GetMaxSizeForBucket(int binIndex)
internal MemoryPressure GetMemoryPressure()
}
internal System.Collections.Concurrent.ConcurrentExtensions : object {
public void Clear(ConcurrentBag`1<T> bag)
public void Clear(ConcurrentQueue`1<T> queue)
public TValue AddOrUpdate(ConcurrentDictionary`2<TKey, TValue> dict, TKey key, Func`3<TKey, TArg, TValue> addValueFactory, Func`4<TKey, TValue, TArg, TValue> updateValueFactory, TArg factoryArgument)
public TValue GetOrAdd(ConcurrentDictionary`2<TKey, TValue> dict, TKey key, Func`3<TKey, TArg, TValue> valueFactory, TArg factoryArgument)
public bool TryRemove(ConcurrentDictionary`2<TKey, TValue> dict, KeyValuePair`2<TKey, TValue> item)
}
internal System.Collections.HashHelpers : object {
public UInt32 HashCollisionThreshold
public int MaxPrimeArrayLength
public int HashPrime
private Int32[] s_primes
public bool IsPrime(int candidate)
public int GetPrime(int min)
public int ExpandPrime(int oldSize)
public ulong GetFastModMultiplier(UInt32 divisor)
public UInt32 FastMod(UInt32 value, UInt32 divisor, ulong multiplier)
}
internal System.Diagnostics.CodeAnalysis.<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>DoesNotReturnIfAttribute : Attribute {
private bool <ParameterValue>k__BackingField
public bool ParameterValue
public bool get_ParameterValue()
public void .ctor(bool parameterValue)
}
internal System.Diagnostics.CodeAnalysis.<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MaybeNullWhenAttribute : Attribute {
private bool <ReturnValue>k__BackingField
public bool ReturnValue
public bool get_ReturnValue()
public void .ctor(bool returnValue)
}
internal System.Diagnostics.CodeAnalysis.<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MemberNotNullAttribute : Attribute {
private String[] <Members>k__BackingField
public String[] Members
public String[] get_Members()
public void .ctor(string member)
public void .ctor(String[] members)
}
internal System.Diagnostics.CodeAnalysis.<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MemberNotNullWhenAttribute : Attribute {
private bool <ReturnValue>k__BackingField
private String[] <Members>k__BackingField
public bool ReturnValue
public String[] Members
public bool get_ReturnValue()
public String[] get_Members()
public void .ctor(bool returnValue, string member)
public void .ctor(bool returnValue, String[] members)
}
internal System.Diagnostics.CodeAnalysis.<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>NotNullIfNotNullAttribute : Attribute {
private string <ParameterName>k__BackingField
public string ParameterName
public string get_ParameterName()
public void .ctor(string parameterName)
}
internal System.Diagnostics.CodeAnalysis.<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>NotNullWhenAttribute : Attribute {
private bool <ReturnValue>k__BackingField
public bool ReturnValue
public bool get_ReturnValue()
public void .ctor(bool returnValue)
}
internal System.Diagnostics.CodeAnalysis.<22576685-8ec8-4022-94e7-b5a630de7c65>DoesNotReturnIfAttribute : Attribute {
private bool <ParameterValue>k__BackingField
public bool ParameterValue
public bool get_ParameterValue()
public void .ctor(bool parameterValue)
}
internal System.Diagnostics.CodeAnalysis.<22576685-8ec8-4022-94e7-b5a630de7c65>MaybeNullWhenAttribute : Attribute {
private bool <ReturnValue>k__BackingField
public bool ReturnValue
public bool get_ReturnValue()
public void .ctor(bool returnValue)
}
internal System.Diagnostics.CodeAnalysis.<22576685-8ec8-4022-94e7-b5a630de7c65>MemberNotNullAttribute : Attribute {
private String[] <Members>k__BackingField
public String[] Members
public String[] get_Members()
public void .ctor(string member)
public void .ctor(String[] members)
}
internal System.Diagnostics.CodeAnalysis.<22576685-8ec8-4022-94e7-b5a630de7c65>MemberNotNullWhenAttribute : Attribute {
private bool <ReturnValue>k__BackingField
private String[] <Members>k__BackingField
public bool ReturnValue
public String[] Members
public bool get_ReturnValue()
public String[] get_Members()
public void .ctor(bool returnValue, string member)
public void .ctor(bool returnValue, String[] members)
}
internal System.Diagnostics.CodeAnalysis.<22576685-8ec8-4022-94e7-b5a630de7c65>NotNullIfNotNullAttribute : Attribute {
private string <ParameterName>k__BackingField
public string ParameterName
public string get_ParameterName()
public void .ctor(string parameterName)
}
internal System.Diagnostics.CodeAnalysis.<22576685-8ec8-4022-94e7-b5a630de7c65>NotNullWhenAttribute : Attribute {
private bool <ReturnValue>k__BackingField
public bool ReturnValue
public bool get_ReturnValue()
public void .ctor(bool returnValue)
}
internal System.Diagnostics.CodeAnalysis.<b2ffb5d6-6a81-4f20-8e75-7064682f7f7c>DoesNotReturnIfAttribute : Attribute {
private bool <ParameterValue>k__BackingField
public bool ParameterValue
public bool get_ParameterValue()
public void .ctor(bool parameterValue)
}
internal System.Diagnostics.CodeAnalysis.<b2ffb5d6-6a81-4f20-8e75-7064682f7f7c>MaybeNullWhenAttribute : Attribute {
private bool <ReturnValue>k__BackingField
public bool ReturnValue
public bool get_ReturnValue()
public void .ctor(bool returnValue)
}
internal System.Diagnostics.CodeAnalysis.<b2ffb5d6-6a81-4f20-8e75-7064682f7f7c>MemberNotNullAttribute : Attribute {
private String[] <Members>k__BackingField
public String[] Members
public String[] get_Members()
public void .ctor(string member)
public void .ctor(String[] members)
}
internal System.Diagnostics.CodeAnalysis.<b2ffb5d6-6a81-4f20-8e75-7064682f7f7c>MemberNotNullWhenAttribute : Attribute {
private bool <ReturnValue>k__BackingField
private String[] <Members>k__BackingField
public bool ReturnValue
public String[] Members
public bool get_ReturnValue()
public String[] get_Members()
public void .ctor(bool returnValue, string member)
public void .ctor(bool returnValue, String[] members)
}
internal System.Diagnostics.CodeAnalysis.<b2ffb5d6-6a81-4f20-8e75-7064682f7f7c>NotNullIfNotNullAttribute : Attribute {
private string <ParameterName>k__BackingField
public string ParameterName
public string get_ParameterName()
public void .ctor(string parameterName)
}
internal System.Diagnostics.CodeAnalysis.<b2ffb5d6-6a81-4f20-8e75-7064682f7f7c>NotNullWhenAttribute : Attribute {
private bool <ReturnValue>k__BackingField
public bool ReturnValue
public bool get_ReturnValue()
public void .ctor(bool returnValue)
}
internal System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute : Attribute {
private bool <ParameterValue>k__BackingField
public bool ParameterValue
public bool get_ParameterValue()
public void .ctor(bool parameterValue)
}
internal System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembersAttribute : Attribute {
private DynamicallyAccessedMemberTypes <MemberTypes>k__BackingField
public DynamicallyAccessedMemberTypes MemberTypes
public void .ctor(DynamicallyAccessedMemberTypes memberTypes)
public DynamicallyAccessedMemberTypes get_MemberTypes()
}
internal System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes : Enum {
public int value__
public DynamicallyAccessedMemberTypes None
public DynamicallyAccessedMemberTypes PublicParameterlessConstructor
public DynamicallyAccessedMemberTypes PublicConstructors
public DynamicallyAccessedMemberTypes NonPublicConstructors
public DynamicallyAccessedMemberTypes PublicMethods
public DynamicallyAccessedMemberTypes NonPublicMethods
public DynamicallyAccessedMemberTypes PublicFields
public DynamicallyAccessedMemberTypes NonPublicFields
public DynamicallyAccessedMemberTypes PublicNestedTypes
public DynamicallyAccessedMemberTypes NonPublicNestedTypes
public DynamicallyAccessedMemberTypes PublicProperties
public DynamicallyAccessedMemberTypes NonPublicProperties
public DynamicallyAccessedMemberTypes PublicEvents
public DynamicallyAccessedMemberTypes NonPublicEvents
public DynamicallyAccessedMemberTypes All
}
internal System.Diagnostics.CodeAnalysis.ExtraDynamicallyAccessedMemberTypes : object {
public DynamicallyAccessedMemberTypes Interfaces
}
internal System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute : Attribute {
private bool <ReturnValue>k__BackingField
public bool ReturnValue
public bool get_ReturnValue()
public void .ctor(bool returnValue)
}
internal System.Diagnostics.CodeAnalysis.MemberNotNullAttribute : Attribute {
private String[] <Members>k__BackingField
public String[] Members
public String[] get_Members()
public void .ctor(string member)
public void .ctor(String[] members)
}
internal System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute : Attribute {
private bool <ReturnValue>k__BackingField
private String[] <Members>k__BackingField
public bool ReturnValue
public String[] Members
public bool get_ReturnValue()
public String[] get_Members()
public void .ctor(bool returnValue, string member)
public void .ctor(bool returnValue, String[] members)
}
internal System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute : Attribute {
private string <ParameterName>k__BackingField
public string ParameterName
public string get_ParameterName()
public void .ctor(string parameterName)
}
internal System.Diagnostics.CodeAnalysis.NotNullWhenAttribute : Attribute {
private bool <ReturnValue>k__BackingField
public bool ReturnValue
public bool get_ReturnValue()
public void .ctor(bool returnValue)
}
internal System.Diagnostics.Debug2 : object {
public void Assert(bool condition)
}
internal System.EnvironmentEx : object {
public int CurrentManagedThreadId
public int get_CurrentManagedThreadId()
}
internal System.ExceptionArgument : Enum {
public int value__
public ExceptionArgument length
public ExceptionArgument start
public ExceptionArgument bufferSize
public ExceptionArgument minimumBufferSize
public ExceptionArgument elementIndex
public ExceptionArgument comparable
public ExceptionArgument comparer
public ExceptionArgument destination
public ExceptionArgument offset
public ExceptionArgument startSegment
public ExceptionArgument endSegment
public ExceptionArgument startIndex
public ExceptionArgument endIndex
public ExceptionArgument array
public ExceptionArgument culture
public ExceptionArgument manager
public ExceptionArgument key
public ExceptionArgument collection
public ExceptionArgument index
public ExceptionArgument type
public ExceptionArgument self
public ExceptionArgument value
public ExceptionArgument oldValue
public ExceptionArgument newValue
}
internal System.Gen2GcCallback : CriticalFinalizerObject {
private Func`1<bool> _callback0
private Func`2<object, bool> _callback1
private GCHandle _weakTargetObj
private void .ctor(Func`1<bool> callback)
private void .ctor(Func`2<object, bool> callback, object targetObj)
public void Register(Func`1<bool> callback)
public void Register(Func`2<object, bool> callback, object targetObj)
protected void Finalize()
}
internal System.HashCode : ValueType {
private UInt32 s_seed
private UInt32 Prime1
private UInt32 Prime2
private UInt32 Prime3
private UInt32 Prime4
private UInt32 Prime5
private UInt32 _v1
private UInt32 _v2
private UInt32 _v3
private UInt32 _v4
private UInt32 _queue1
private UInt32 _queue2
private UInt32 _queue3
private UInt32 _length
private UInt32 GenerateGlobalSeed()
public int Combine(T1 value1)
public int Combine(T1 value1, T2 value2)
public int Combine(T1 value1, T2 value2, T3 value3)
public int Combine(T1 value1, T2 value2, T3 value3, T4 value4)
public int Combine(T1 value1, T2 value2, T3 value3, T4 value4, T5 value5)
public int Combine(T1 value1, T2 value2, T3 value3, T4 value4, T5 value5, T6 value6)
public int Combine(T1 value1, T2 value2, T3 value3, T4 value4, T5 value5, T6 value6, T7 value7)
public int Combine(T1 value1, T2 value2, T3 value3, T4 value4, T5 value5, T6 value6, T7 value7, T8 value8)
private void Initialize(UInt32& v1, UInt32& v2, UInt32& v3, UInt32& v4)
private UInt32 Round(UInt32 hash, UInt32 input)
private UInt32 QueueRound(UInt32 hash, UInt32 queuedValue)
private UInt32 MixState(UInt32 v1, UInt32 v2, UInt32 v3, UInt32 v4)
private UInt32 MixEmptyState()
private UInt32 MixFinal(UInt32 hash)
public void Add(T value)
public void Add(T value, IEqualityComparer`1<T> comparer)
public void AddBytes(ReadOnlySpan`1<byte> value)
private void Add(int value)
public int ToHashCode()
public int GetHashCode()
public bool Equals(object obj)
}
internal System.IO.StreamExtensions : object {
public void CopyTo(Stream src, Stream destination)
public void CopyTo(Stream src, Stream destination, int bufferSize)
}
internal System.MathEx : object {
public byte Clamp(byte value, byte min, byte max)
public decimal Clamp(decimal value, decimal min, decimal max)
public double Clamp(double value, double min, double max)
public short Clamp(short value, short min, short max)
public int Clamp(int value, int min, int max)
public long Clamp(long value, long min, long max)
public IntPtr Clamp(IntPtr value, IntPtr min, IntPtr max)
public sbyte Clamp(sbyte value, sbyte min, sbyte max)
public float Clamp(float value, float min, float max)
public ushort Clamp(ushort value, ushort min, ushort max)
public UInt32 Clamp(UInt32 value, UInt32 min, UInt32 max)
public ulong Clamp(ulong value, ulong min, ulong max)
public UIntPtr Clamp(UIntPtr value, UIntPtr min, UIntPtr max)
private void ThrowMinMaxException(T min, T max)
}
internal System.Memory`1 : ValueType {
private object _object
private int _index
private int _length
private int RemoveFlagsBitMask
public Memory`1<T> Empty
public int Length
public bool IsEmpty
public Span`1<T> Span
public void .ctor(T[] array)
internal void .ctor(T[] array, int start)
public void .ctor(T[] array, int start, int length)
internal void .ctor(MemoryManager`1<T> manager, int length)
internal void .ctor(MemoryManager`1<T> manager, int start, int length)
internal void .ctor(object obj, int start, int length)
public Memory`1<T> op_Implicit(T[] array)
public Memory`1<T> op_Implicit(ArraySegment`1<T> segment)
public ReadOnlyMemory`1<T> op_Implicit(Memory`1<T> memory)
public Memory`1<T> get_Empty()
public int get_Length()
public bool get_IsEmpty()
public string ToString()
public Memory`1<T> Slice(int start)
public Memory`1<T> Slice(int start, int length)
public Span`1<T> get_Span()
public void CopyTo(Memory`1<T> destination)
public bool TryCopyTo(Memory`1<T> destination)
public MemoryHandle Pin()
public T[] ToArray()
public bool Equals(object obj)
public bool Equals(Memory`1<T> other)
public int GetHashCode()
}
internal System.MemoryDebugView`1 : object {
private ReadOnlyMemory`1<T> _memory
public T[] Items
public void .ctor(Memory`1<T> memory)
public void .ctor(ReadOnlyMemory`1<T> memory)
public T[] get_Items()
}
internal System.MemoryExtensions : object {
internal IntPtr StringAdjustment
public ReadOnlySpan`1<char> Trim(ReadOnlySpan`1<char> span)
public ReadOnlySpan`1<char> TrimStart(ReadOnlySpan`1<char> span)
public ReadOnlySpan`1<char> TrimEnd(ReadOnlySpan`1<char> span)
public ReadOnlySpan`1<char> Trim(ReadOnlySpan`1<char> span, char trimChar)
public ReadOnlySpan`1<char> TrimStart(ReadOnlySpan`1<char> span, char trimChar)
public ReadOnlySpan`1<char> TrimEnd(ReadOnlySpan`1<char> span, char trimChar)
public ReadOnlySpan`1<char> Trim(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> trimChars)
public ReadOnlySpan`1<char> TrimStart(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> trimChars)
public ReadOnlySpan`1<char> TrimEnd(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> trimChars)
public bool IsWhiteSpace(ReadOnlySpan`1<char> span)
public int IndexOf(Span`1<T> span, T value)
public int IndexOf(Span`1<T> span, ReadOnlySpan`1<T> value)
public int LastIndexOf(Span`1<T> span, T value)
public int LastIndexOf(Span`1<T> span, ReadOnlySpan`1<T> value)
public bool SequenceEqual(Span`1<T> span, ReadOnlySpan`1<T> other)
public int SequenceCompareTo(Span`1<T> span, ReadOnlySpan`1<T> other)
public int IndexOf(ReadOnlySpan`1<T> span, T value)
public int IndexOf(ReadOnlySpan`1<T> span, ReadOnlySpan`1<T> value)
public int LastIndexOf(ReadOnlySpan`1<T> span, T value)
public int LastIndexOf(ReadOnlySpan`1<T> span, ReadOnlySpan`1<T> value)
public int IndexOfAny(Span`1<T> span, T value0, T value1)
public int IndexOfAny(Span`1<T> span, T value0, T value1, T value2)
public int IndexOfAny(Span`1<T> span, ReadOnlySpan`1<T> values)
public int IndexOfAny(ReadOnlySpan`1<T> span, T value0, T value1)
public int IndexOfAny(ReadOnlySpan`1<T> span, T value0, T value1, T value2)
public int IndexOfAny(ReadOnlySpan`1<T> span, ReadOnlySpan`1<T> values)
public int LastIndexOfAny(Span`1<T> span, T value0, T value1)
public int LastIndexOfAny(Span`1<T> span, T value0, T value1, T value2)
public int LastIndexOfAny(Span`1<T> span, ReadOnlySpan`1<T> values)
public int LastIndexOfAny(ReadOnlySpan`1<T> span, T value0, T value1)
public int LastIndexOfAny(ReadOnlySpan`1<T> span, T value0, T value1, T value2)
public int LastIndexOfAny(ReadOnlySpan`1<T> span, ReadOnlySpan`1<T> values)
public bool SequenceEqual(ReadOnlySpan`1<T> span, ReadOnlySpan`1<T> other)
public int SequenceCompareTo(ReadOnlySpan`1<T> span, ReadOnlySpan`1<T> other)
public bool StartsWith(Span`1<T> span, ReadOnlySpan`1<T> value)
public bool StartsWith(ReadOnlySpan`1<T> span, ReadOnlySpan`1<T> value)
public bool EndsWith(Span`1<T> span, ReadOnlySpan`1<T> value)
public bool EndsWith(ReadOnlySpan`1<T> span, ReadOnlySpan`1<T> value)
public void Reverse(Span`1<T> span)
public Span`1<T> AsSpan(T[] array)
public Span`1<T> AsSpan(T[] array, int start, int length)
public Span`1<T> AsSpan(ArraySegment`1<T> segment)
public Span`1<T> AsSpan(ArraySegment`1<T> segment, int start)
public Span`1<T> AsSpan(ArraySegment`1<T> segment, int start, int length)
public Memory`1<T> AsMemory(T[] array)
public Memory`1<T> AsMemory(T[] array, int start)
public Memory`1<T> AsMemory(T[] array, int start, int length)
public Memory`1<T> AsMemory(ArraySegment`1<T> segment)
public Memory`1<T> AsMemory(ArraySegment`1<T> segment, int start)
public Memory`1<T> AsMemory(ArraySegment`1<T> segment, int start, int length)
public void CopyTo(T[] source, Span`1<T> destination)
public void CopyTo(T[] source, Memory`1<T> destination)
public bool Overlaps(Span`1<T> span, ReadOnlySpan`1<T> other)
public bool Overlaps(Span`1<T> span, ReadOnlySpan`1<T> other, Int32& elementOffset)
public bool Overlaps(ReadOnlySpan`1<T> span, ReadOnlySpan`1<T> other)
public bool Overlaps(ReadOnlySpan`1<T> span, ReadOnlySpan`1<T> other, Int32& elementOffset)
public int BinarySearch(Span`1<T> span, IComparable`1<T> comparable)
public int BinarySearch(Span`1<T> span, TComparable comparable)
public int BinarySearch(Span`1<T> span, T value, TComparer comparer)
public int BinarySearch(ReadOnlySpan`1<T> span, IComparable`1<T> comparable)
public int BinarySearch(ReadOnlySpan`1<T> span, TComparable comparable)
public int BinarySearch(ReadOnlySpan`1<T> span, T value, TComparer comparer)
private bool IsTypeComparableAsBytes(UIntPtr& size)
public Span`1<T> AsSpan(T[] array, int start)
public bool Contains(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> value, StringComparison comparisonType)
public bool Equals(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> other, StringComparison comparisonType)
private bool EqualsOrdinalIgnoreCase(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> other)
public int CompareTo(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> other, StringComparison comparisonType)
private int CompareToOrdinalIgnoreCase(ReadOnlySpan`1<char> strA, ReadOnlySpan`1<char> strB)
public int IndexOf(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> value, StringComparison comparisonType)
public int ToLower(ReadOnlySpan`1<char> source, Span`1<char> destination, CultureInfo culture)
public int ToLowerInvariant(ReadOnlySpan`1<char> source, Span`1<char> destination)
public int ToUpper(ReadOnlySpan`1<char> source, Span`1<char> destination, CultureInfo culture)
public int ToUpperInvariant(ReadOnlySpan`1<char> source, Span`1<char> destination)
public bool EndsWith(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> value, StringComparison comparisonType)
public bool StartsWith(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> value, StringComparison comparisonType)
public ReadOnlySpan`1<char> AsSpan(string text)
public ReadOnlySpan`1<char> AsSpan(string text, int start)
public ReadOnlySpan`1<char> AsSpan(string text, int start, int length)
public ReadOnlyMemory`1<char> AsMemory(string text)
public ReadOnlyMemory`1<char> AsMemory(string text, int start)
public ReadOnlyMemory`1<char> AsMemory(string text, int start, int length)
private IntPtr MeasureStringAdjustment()
}
internal System.Numerics.BitOperations : object {
private ReadOnlySpan`1<byte> TrailingZeroCountDeBruijn
private ReadOnlySpan`1<byte> Log2DeBruijn
private ReadOnlySpan`1<byte> get_TrailingZeroCountDeBruijn()
private ReadOnlySpan`1<byte> get_Log2DeBruijn()
public int LeadingZeroCount(UInt32 value)
public int LeadingZeroCount(ulong value)
public int Log2(UInt32 value)
public int Log2(ulong value)
private int Log2SoftwareFallback(UInt32 value)
internal int Log2Ceiling(UInt32 value)
internal int Log2Ceiling(ulong value)
public int PopCount(UInt32 value)
public int PopCount(ulong value)
public int TrailingZeroCount(int value)
public int TrailingZeroCount(UInt32 value)
public int TrailingZeroCount(long value)
public int TrailingZeroCount(ulong value)
public UInt32 RotateLeft(UInt32 value, int offset)
public ulong RotateLeft(ulong value, int offset)
public UInt32 RotateRight(UInt32 value, int offset)
public ulong RotateRight(ulong value, int offset)
internal UInt32 ResetLowestSetBit(UInt32 value)
internal UInt32 ResetBit(UInt32 value, int bitPos)
internal int <PopCount>g__SoftwareFallback|11_0(UInt32 value)
internal int <PopCount>g__SoftwareFallback|12_0(ulong value)
}
internal System.Numerics.BitOperationsEx : object {
public bool IsPow2(int value)
public bool IsPow2(UInt32 value)
public bool IsPow2(long value)
public bool IsPow2(ulong value)
public bool IsPow2(IntPtr value)
public bool IsPow2(UIntPtr value)
public UInt32 RoundUpToPowerOf2(UInt32 value)
public ulong RoundUpToPowerOf2(ulong value)
public UIntPtr RoundUpToPowerOf2(UIntPtr value)
public int LeadingZeroCount(UInt32 value)
public int LeadingZeroCount(ulong value)
public int LeadingZeroCount(UIntPtr value)
public int Log2(UInt32 value)
public int Log2(ulong value)
public int Log2(UIntPtr value)
public int PopCount(UInt32 value)
public int PopCount(ulong value)
public int PopCount(UIntPtr value)
public int TrailingZeroCount(int value)
public int TrailingZeroCount(UInt32 value)
public int TrailingZeroCount(long value)
public int TrailingZeroCount(ulong value)
public int TrailingZeroCount(IntPtr value)
public int TrailingZeroCount(UIntPtr value)
public UInt32 RotateLeft(UInt32 value, int offset)
public ulong RotateLeft(ulong value, int offset)
public UIntPtr RotateLeft(UIntPtr value, int offset)
public UInt32 RotateRight(UInt32 value, int offset)
public ulong RotateRight(ulong value, int offset)
public UIntPtr RotateRight(UIntPtr value, int offset)
}
internal System.Pinnable`1 : object {
public T Data
}
internal System.ReadOnlyMemory`1 : ValueType {
private object _object
private int _index
private int _length
internal int RemoveFlagsBitMask
public ReadOnlyMemory`1<T> Empty
public int Length
public bool IsEmpty
public ReadOnlySpan`1<T> Span
public void .ctor(T[] array)
public void .ctor(T[] array, int start, int length)
internal void .ctor(object obj, int start, int length)
public ReadOnlyMemory`1<T> op_Implicit(T[] array)
public ReadOnlyMemory`1<T> op_Implicit(ArraySegment`1<T> segment)
public ReadOnlyMemory`1<T> get_Empty()
public int get_Length()
public bool get_IsEmpty()
public string ToString()
public ReadOnlyMemory`1<T> Slice(int start)
public ReadOnlyMemory`1<T> Slice(int start, int length)
public ReadOnlySpan`1<T> get_Span()
public void CopyTo(Memory`1<T> destination)
public bool TryCopyTo(Memory`1<T> destination)
public MemoryHandle Pin()
public T[] ToArray()
public bool Equals(object obj)
public bool Equals(ReadOnlyMemory`1<T> other)
public int GetHashCode()
internal object GetObjectStartLength(Int32& start, Int32& length)
}
internal System.ReadOnlySpan`1 : ValueType {
private Pinnable`1<T> _pinnable
private IntPtr _byteOffset
private int _length
public int Length
public bool IsEmpty
public ReadOnlySpan`1<T> Empty
public T& modreq(System.Runtime.InteropServices.InAttribute) Item
internal Pinnable`1<T> Pinnable
internal IntPtr ByteOffset
public int get_Length()
public bool get_IsEmpty()
public bool op_Inequality(ReadOnlySpan`1<T> left, ReadOnlySpan`1<T> right)
public bool Equals(object obj)
public int GetHashCode()
public ReadOnlySpan`1<T> op_Implicit(T[] array)
public ReadOnlySpan`1<T> op_Implicit(ArraySegment`1<T> segment)
public ReadOnlySpan`1<T> get_Empty()
public Enumerator<T> GetEnumerator()
public void .ctor(T[] array)
public void .ctor(T[] array, int start, int length)
public void .ctor(Void* pointer, int length)
internal void .ctor(Pinnable`1<T> pinnable, IntPtr byteOffset, int length)
public T& modreq(System.Runtime.InteropServices.InAttribute) get_Item(int index)
public T& modreq(System.Runtime.InteropServices.InAttribute) GetPinnableReference()
public void CopyTo(Span`1<T> destination)
public bool TryCopyTo(Span`1<T> destination)
public bool op_Equality(ReadOnlySpan`1<T> left, ReadOnlySpan`1<T> right)
public string ToString()
public ReadOnlySpan`1<T> Slice(int start)
public ReadOnlySpan`1<T> Slice(int start, int length)
public T[] ToArray()
internal T& DangerousGetPinnableReference()
internal Pinnable`1<T> get_Pinnable()
internal IntPtr get_ByteOffset()
}
internal System.Runtime.CompilerServices.CallerArgumentExpressionAttribute : Attribute {
private string <ParameterName>k__BackingField
public string ParameterName
public void .ctor(string parameterName)
public string get_ParameterName()
}
internal System.Runtime.CompilerServices.ConditionalWeakTableExtensions : object {
public IEnumerable`1<KeyValuePair`2<TKey, TValue>> AsEnumerable(ConditionalWeakTable`2<TKey, TValue> self)
public IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator(ConditionalWeakTable`2<TKey, TValue> self)
public void Clear(ConditionalWeakTable`2<TKey, TValue> self)
public bool TryAdd(ConditionalWeakTable`2<TKey, TValue> self, TKey key, TValue value)
internal IEnumerator`1<KeyValuePair`2<TKey, TValue>> <GetEnumerator>g__Enumerate|2_0(ConditionalWeakTable`2<TKey, TValue> cwt, IEnumerable`1<TKey> keys)
}
internal System.Runtime.CompilerServices.CWTEnumerable`2 : object {
private ConditionalWeakTable`2<TKey, TValue> cwt
public void .ctor(ConditionalWeakTable`2<TKey, TValue> table)
public IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
}
internal System.Runtime.CompilerServices.DefaultInterpolatedStringHandler : ValueType {
private int GuessedLengthPerHole
private int MinimumArrayPoolLength
private IFormatProvider _provider
private Char[] _arrayToReturnToPool
private Span`1<char> _chars
private int _pos
private bool _hasCustomFormatter
internal ReadOnlySpan`1<char> Text
public void .ctor(int literalLength, int formattedCount)
public void .ctor(int literalLength, int formattedCount, IFormatProvider provider)
public void .ctor(int literalLength, int formattedCount, IFormatProvider provider, Span`1<char> initialBuffer)
internal int GetDefaultLength(int literalLength, int formattedCount)
public string ToString()
public string ToStringAndClear()
internal void Clear()
internal ReadOnlySpan`1<char> get_Text()
public void AppendLiteral(string value)
private void AppendStringDirect(string value)
public void AppendFormatted(T value)
public void AppendFormatted(T value, string format)
public void AppendFormatted(T value, int alignment)
public void AppendFormatted(T value, int alignment, string format)
private void AppendFormatted(IntPtr value)
private void AppendFormatted(IntPtr value, string format)
private void AppendFormatted(UIntPtr value)
private void AppendFormatted(UIntPtr value, string format)
public void AppendFormatted(ReadOnlySpan`1<char> value)
public void AppendFormatted(ReadOnlySpan`1<char> value, int alignment, string format)
public void AppendFormatted(string value)
private void AppendFormattedSlow(string value)
public void AppendFormatted(string value, int alignment, string format)
public void AppendFormatted(object value, int alignment, string format)
internal bool HasCustomFormatter(IFormatProvider provider)
private void AppendCustomFormatter(T value, string format)
private void AppendOrInsertAlignmentIfNeeded(int startingPos, int alignment)
private void EnsureCapacityForAdditionalChars(int additionalChars)
private void GrowThenCopyString(string value)
private void GrowThenCopySpan(ReadOnlySpan`1<char> value)
private void Grow(int additionalChars)
private void Grow()
private void GrowCore(UInt32 requiredMinCapacity)
}
internal System.Runtime.CompilerServices.ICWTEnumerable`1 {
public IEnumerable`1<T> SelfEnumerable
public IEnumerable`1<T> get_SelfEnumerable()
public IEnumerator`1<T> GetEnumerator()
}
internal System.Runtime.CompilerServices.IgnoresAccessChecksToAttribute : Attribute {
private string <AssemblyName>k__BackingField
public string AssemblyName
public string get_AssemblyName()
public void .ctor(string assemblyName)
}
internal System.Runtime.CompilerServices.InterpolatedStringHandlerArgumentAttribute : Attribute {
private String[] <Arguments>k__BackingField
public String[] Arguments
public void .ctor(string argument)
public void .ctor(String[] arguments)
public String[] get_Arguments()
}
internal System.Runtime.CompilerServices.ITuple {
public int Length
public object Item
public int get_Length()
public object get_Item(int index)
}
internal System.Runtime.CompilerServices.NativeIntegerAttribute : Attribute {
public Boolean[] TransformFlags
public void .ctor(Boolean[] )
}
internal System.Runtime.CompilerServices.NullableAttribute : Attribute {
public Byte[] NullableFlags
public void .ctor(byte )
public void .ctor(Byte[] )
}
internal System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
public byte Flag
public void .ctor(byte )
}
internal System.Runtime.CompilerServices.NullablePublicOnlyAttribute : Attribute {
public bool IncludesInternals
public void .ctor(bool )
}
internal System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
public int Version
public void .ctor(int )
}
internal System.Runtime.CompilerServices.Unsafe : object {
public T Read(Void* source)
public T ReadUnaligned(Void* source)
public T ReadUnaligned(Byte& source)
public void Write(Void* destination, T value)
public void WriteUnaligned(Void* destination, T value)
public void WriteUnaligned(Byte& destination, T value)
public void Copy(Void* destination, T& source)
public void Copy(T& destination, Void* source)
public Void* AsPointer(T& value)
public void SkipInit(T& value)
public int SizeOf()
public void CopyBlock(Void* destination, Void* source, UInt32 byteCount)
public void CopyBlock(Byte& destination, Byte& source, UInt32 byteCount)
public void CopyBlockUnaligned(Void* destination, Void* source, UInt32 byteCount)
public void CopyBlockUnaligned(Byte& destination, Byte& source, UInt32 byteCount)
public void InitBlock(Void* startAddress, byte value, UInt32 byteCount)
public void InitBlock(Byte& startAddress, byte value, UInt32 byteCount)
public void InitBlockUnaligned(Void* startAddress, byte value, UInt32 byteCount)
public void InitBlockUnaligned(Byte& startAddress, byte value, UInt32 byteCount)
public T As(object o)
public T& AsRef(Void* source)
public T& AsRef(T& source)
public TTo& As(TFrom& source)
public T& Unbox(object box)
public T& Add(T& source, int elementOffset)
public Void* Add(Void* source, int elementOffset)
public T& Add(T& source, IntPtr elementOffset)
public T& Add(T& source, UIntPtr elementOffset)
public T& AddByteOffset(T& source, IntPtr byteOffset)
public T& AddByteOffset(T& source, UIntPtr byteOffset)
public T& Subtract(T& source, int elementOffset)
public Void* Subtract(Void* source, int elementOffset)
public T& Subtract(T& source, IntPtr elementOffset)
public T& Subtract(T& source, UIntPtr elementOffset)
public T& SubtractByteOffset(T& source, IntPtr byteOffset)
public T& SubtractByteOffset(T& source, UIntPtr byteOffset)
public IntPtr ByteOffset(T& origin, T& target)
public bool AreSame(T& left, T& right)
public bool IsAddressGreaterThan(T& left, T& right)
public bool IsAddressLessThan(T& left, T& right)
public bool IsNullRef(T& source)
public T& NullRef()
}
internal System.Runtime.DependentHandle : ValueType {
private GCHandle dependentHandle
private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) allocated
public bool IsAllocated
public object Target
public object Dependent
public ValueTuple`2<object, object> TargetAndDependent
public void .ctor(object target, object dependent)
private GCHandle AllocDepHolder(GCHandle targetHandle, object dependent)
public bool get_IsAllocated()
public object get_Target()
public void set_Target(object value)
public object get_Dependent()
public void set_Dependent(object value)
public ValueTuple`2<object, object> get_TargetAndDependent()
private DependentHolder UnsafeGetHolder()
internal object UnsafeGetTarget()
internal object UnsafeGetTargetAndDependent(Object& dependent)
internal void UnsafeSetTargetToNull()
internal void UnsafeSetDependent(object value)
private void FreeDependentHandle()
private void Free()
public void Dispose()
}
internal System.Runtime.InteropServices.MarshalEx : object {
private MethodInfo Marshal_SetLastWin32Error_Meth
private Action`1<int> Marshal_SetLastWin32Error
public int GetLastPInvokeError()
public void SetLastPInvokeError(int error)
}
internal System.Runtime.InteropServices.MemoryMarshal : object {
public bool TryGetArray(ReadOnlyMemory`1<T> memory, ArraySegment`1& segment)
public bool TryGetMemoryManager(ReadOnlyMemory`1<T> memory, TManager& manager)
public bool TryGetMemoryManager(ReadOnlyMemory`1<T> memory, TManager& manager, Int32& start, Int32& length)
public IEnumerable`1<T> ToEnumerable(ReadOnlyMemory`1<T> memory)
public bool TryGetString(ReadOnlyMemory`1<char> memory, String& text, Int32& start, Int32& length)
public T Read(ReadOnlySpan`1<byte> source)
public bool TryRead(ReadOnlySpan`1<byte> source, T& value)
public void Write(Span`1<byte> destination, T& value)
public bool TryWrite(Span`1<byte> destination, T& value)
public Memory`1<T> CreateFromPinnedArray(T[] array, int start, int length)
public Span`1<byte> AsBytes(Span`1<T> span)
public ReadOnlySpan`1<byte> AsBytes(ReadOnlySpan`1<T> span)
public Memory`1<T> AsMemory(ReadOnlyMemory`1<T> memory)
public T& GetReference(Span`1<T> span)
public T& GetReference(ReadOnlySpan`1<T> span)
public Span`1<TTo> Cast(Span`1<TFrom> span)
public ReadOnlySpan`1<TTo> Cast(ReadOnlySpan`1<TFrom> span)
}
internal System.Runtime.InteropServices.SequenceMarshal : object {
public bool TryGetReadOnlySequenceSegment(ReadOnlySequence`1<T> sequence, ReadOnlySequenceSegment`1& startSegment, Int32& startIndex, ReadOnlySequenceSegment`1& endSegment, Int32& endIndex)
public bool TryGetArray(ReadOnlySequence`1<T> sequence, ArraySegment`1& segment)
public bool TryGetReadOnlyMemory(ReadOnlySequence`1<T> sequence, ReadOnlyMemory`1& memory)
internal bool TryGetString(ReadOnlySequence`1<char> sequence, String& text, Int32& start, Int32& length)
}
internal System.SequencePosition : ValueType {
private object _object
private int _integer
public void .ctor(object object, int integer)
public object GetObject()
public int GetInteger()
public bool Equals(SequencePosition other)
public bool Equals(object obj)
public int GetHashCode()
}
internal System.Span`1 : ValueType {
private Pinnable`1<T> _pinnable
private IntPtr _byteOffset
private int _length
public int Length
public bool IsEmpty
public Span`1<T> Empty
public T& Item
internal Pinnable`1<T> Pinnable
internal IntPtr ByteOffset
public int get_Length()
public bool get_IsEmpty()
public bool op_Inequality(Span`1<T> left, Span`1<T> right)
public bool Equals(object obj)
public int GetHashCode()
public Span`1<T> op_Implicit(T[] array)
public Span`1<T> op_Implicit(ArraySegment`1<T> segment)
public Span`1<T> get_Empty()
public Enumerator<T> GetEnumerator()
public void .ctor(T[] array)
internal Span`1<T> Create(T[] array, int start)
public void .ctor(T[] array, int start, int length)
public void .ctor(Void* pointer, int length)
internal void .ctor(Pinnable`1<T> pinnable, IntPtr byteOffset, int length)
public T& get_Item(int index)
public T& GetPinnableReference()
public void Clear()
public void Fill(T value)
public void CopyTo(Span`1<T> destination)
public bool TryCopyTo(Span`1<T> destination)
public bool op_Equality(Span`1<T> left, Span`1<T> right)
public ReadOnlySpan`1<T> op_Implicit(Span`1<T> span)
public string ToString()
public Span`1<T> Slice(int start)
public Span`1<T> Slice(int start, int length)
public T[] ToArray()
internal T& DangerousGetPinnableReference()
internal Pinnable`1<T> get_Pinnable()
internal IntPtr get_ByteOffset()
}
internal System.SpanDebugView`1 : object {
private T[] _array
public T[] Items
public void .ctor(Span`1<T> span)
public void .ctor(ReadOnlySpan`1<T> span)
public T[] get_Items()
}
internal System.SpanHelpers : object {
public int BinarySearch(ReadOnlySpan`1<T> span, TComparable comparable)
public int BinarySearch(T& spanStart, int length, TComparable comparable)
public int IndexOf(Byte& searchSpace, int searchSpaceLength, Byte& value, int valueLength)
public int IndexOfAny(Byte& searchSpace, int searchSpaceLength, Byte& value, int valueLength)
public int LastIndexOfAny(Byte& searchSpace, int searchSpaceLength, Byte& value, int valueLength)
public int IndexOf(Byte& searchSpace, byte value, int length)
public int LastIndexOf(Byte& searchSpace, int searchSpaceLength, Byte& value, int valueLength)
public int LastIndexOf(Byte& searchSpace, byte value, int length)
public int IndexOfAny(Byte& searchSpace, byte value0, byte value1, int length)
public int IndexOfAny(Byte& searchSpace, byte value0, byte value1, byte value2, int length)
public int LastIndexOfAny(Byte& searchSpace, byte value0, byte value1, int length)
public int LastIndexOfAny(Byte& searchSpace, byte value0, byte value1, byte value2, int length)
public bool SequenceEqual(Byte& first, Byte& second, UIntPtr length)
public int SequenceCompareTo(Byte& first, int firstLength, Byte& second, int secondLength)
public int SequenceCompareTo(Char& first, int firstLength, Char& second, int secondLength)
public int IndexOf(Char& searchSpace, char value, int length)
public int LastIndexOf(Char& searchSpace, char value, int length)
public void CopyTo(T& dst, int dstLength, T& src, int srcLength)
public IntPtr Add(IntPtr start, int index)
public bool IsReferenceOrContainsReferences()
private bool IsReferenceOrContainsReferencesCore(Type type)
public void ClearLessThanPointerSized(Byte* ptr, UIntPtr byteLength)
public void ClearLessThanPointerSized(Byte& b, UIntPtr byteLength)
public void ClearPointerSizedWithoutReferences(Byte& b, UIntPtr byteLength)
public void ClearPointerSizedWithReferences(IntPtr& ip, UIntPtr pointerSizeLength)
private bool LessThanEqual(IntPtr index, UIntPtr length)
public int IndexOf(T& searchSpace, int searchSpaceLength, T& value, int valueLength)
public int IndexOf(T& searchSpace, T value, int length)
public int IndexOfAny(T& searchSpace, T value0, T value1, int length)
public int IndexOfAny(T& searchSpace, T value0, T value1, T value2, int length)
public int IndexOfAny(T& searchSpace, int searchSpaceLength, T& value, int valueLength)
public int LastIndexOf(T& searchSpace, int searchSpaceLength, T& value, int valueLength)
public int LastIndexOf(T& searchSpace, T value, int length)
public int LastIndexOfAny(T& searchSpace, T value0, T value1, int length)
public int LastIndexOfAny(T& searchSpace, T value0, T value1, T value2, int length)
public int LastIndexOfAny(T& searchSpace, int searchSpaceLength, T& value, int valueLength)
public bool SequenceEqual(T& first, T& second, int length)
public int SequenceCompareTo(T& first, int firstLength, T& second, int secondLength)
}
internal System.SR : object {
private ResourceManager s_resourceManager
private Type <ResourceType>k__BackingField
private ResourceManager ResourceManager
internal Type ResourceType
internal string ArgumentException_ValueTupleIncorrectType
internal string ArgumentException_ValueTupleLastArgumentNotAValueTuple
private ResourceManager get_ResourceManager()
private bool UsingResourceKeys()
internal string GetResourceString(string resourceKey, string defaultString)
internal string Format(string resourceFormat, Object[] args)
internal string Format(string resourceFormat, object p1)
internal string Format(string resourceFormat, object p1, object p2)
internal string Format(string resourceFormat, object p1, object p2, object p3)
internal Type get_ResourceType()
internal string get_ArgumentException_ValueTupleIncorrectType()
internal string get_ArgumentException_ValueTupleLastArgumentNotAValueTuple()
}
internal System.string2 : object {
public bool IsNullOrEmpty(string value)
}
internal System.StringComparerEx : object {
public StringComparer FromComparison(StringComparison comparisonType)
}
internal System.StringExtensions : object {
public string Replace(string self, string oldValue, string newValue, StringComparison comparison)
public bool Contains(string self, string value, StringComparison comparison)
public bool Contains(string self, char value, StringComparison comparison)
public int GetHashCode(string self, StringComparison comparison)
public int IndexOf(string self, char value, StringComparison comparison)
}
internal System.Text.StringBuilderExtensions : object {
public StringBuilder Clear(StringBuilder builder)
}
internal System.Threading.MonitorEx : object {
public void Enter(object obj, Boolean& lockTaken)
}
internal System.ThrowHelper : object {
internal void ThrowIfArgumentNull(object obj, ExceptionArgument argument)
internal void ThrowIfArgumentNull(object obj, string argument, string message)
internal void ThrowArgumentNullException(ExceptionArgument argument)
internal void ThrowArgumentNullException(string argument, string message)
private Exception CreateArgumentNullException(ExceptionArgument argument)
private Exception CreateArgumentNullException(string argument, string message)
internal void ThrowArrayTypeMismatchException()
private Exception CreateArrayTypeMismatchException()
internal void ThrowArgumentException_InvalidTypeWithPointersNotSupported(Type type)
private Exception CreateArgumentException_InvalidTypeWithPointersNotSupported(Type type)
internal void ThrowArgumentException_DestinationTooShort()
private Exception CreateArgumentException_DestinationTooShort()
internal void ThrowArgumentException(string message, string argument)
private Exception CreateArgumentException(string message, string argument)
internal void ThrowIndexOutOfRangeException()
private Exception CreateIndexOutOfRangeException()
internal void ThrowArgumentOutOfRangeException()
private Exception CreateArgumentOutOfRangeException()
internal void ThrowArgumentOutOfRangeException(ExceptionArgument argument)
private Exception CreateArgumentOutOfRangeException(ExceptionArgument argument)
internal void ThrowArgumentOutOfRangeException_PrecisionTooLarge()
private Exception CreateArgumentOutOfRangeException_PrecisionTooLarge()
internal void ThrowArgumentOutOfRangeException_SymbolDoesNotFit()
private Exception CreateArgumentOutOfRangeException_SymbolDoesNotFit()
internal void ThrowInvalidOperationException()
private Exception CreateInvalidOperationException()
internal void ThrowInvalidOperationException_OutstandingReferences()
private Exception CreateInvalidOperationException_OutstandingReferences()
internal void ThrowInvalidOperationException_UnexpectedSegmentType()
private Exception CreateInvalidOperationException_UnexpectedSegmentType()
internal void ThrowInvalidOperationException_EndPositionNotReached()
private Exception CreateInvalidOperationException_EndPositionNotReached()
internal void ThrowArgumentOutOfRangeException_PositionOutOfRange()
private Exception CreateArgumentOutOfRangeException_PositionOutOfRange()
internal void ThrowArgumentOutOfRangeException_OffsetOutOfRange()
private Exception CreateArgumentOutOfRangeException_OffsetOutOfRange()
internal void ThrowObjectDisposedException_ArrayMemoryPoolBuffer()
private Exception CreateObjectDisposedException_ArrayMemoryPoolBuffer()
internal void ThrowFormatException_BadFormatSpecifier()
private Exception CreateFormatException_BadFormatSpecifier()
internal void ThrowArgumentException_OverlapAlignmentMismatch()
private Exception CreateArgumentException_OverlapAlignmentMismatch()
internal void ThrowNotSupportedException(string msg)
private Exception CreateThrowNotSupportedException(string msg)
internal void ThrowKeyNullException()
internal void ThrowValueNullException()
private Exception CreateThrowValueNullException()
internal void ThrowOutOfMemoryException()
private Exception CreateOutOfMemoryException()
public bool TryFormatThrowFormatException(Int32& bytesWritten)
public bool TryParseThrowFormatException(T& value, Int32& bytesConsumed)
public void ThrowArgumentValidationException(ReadOnlySequenceSegment`1<T> startSegment, int startIndex, ReadOnlySequenceSegment`1<T> endSegment)
private Exception CreateArgumentValidationException(ReadOnlySequenceSegment`1<T> startSegment, int startIndex, ReadOnlySequenceSegment`1<T> endSegment)
public void ThrowArgumentValidationException(Array array, int start)
private Exception CreateArgumentValidationException(Array array, int start)
internal void ThrowArgumentException_TupleIncorrectType(object other)
public void ThrowStartOrEndArgumentValidationException(long start)
private Exception CreateStartOrEndArgumentValidationException(long start)
}
internal System.TypeExtensions : object {
public bool IsByRefLike(Type type)
}
