internal static class Consts : object {
    
public static string AssemblyName;
    
public static string PublicKey;
}
internal static class FxResources.System.ValueTuple.SR : object {
}
internal class HarmonyLib.AccessCache : object {
    
private static BindingFlags BasicFlags;
    
private static Dictionary`2<MemberType, BindingFlags> declaredOnlyBindingFlags;
    
private Dictionary`2<Type, Dictionary`2<string, FieldInfo>> declaredFields;
    
private Dictionary`2<Type, Dictionary`2<string, PropertyInfo>> declaredProperties;
    
private Dictionary`2<Type, Dictionary`2<string, Dictionary`2<int, MethodBase>>> declaredMethods;
    
private Dictionary`2<Type, Dictionary`2<string, FieldInfo>> inheritedFields;
    
private Dictionary`2<Type, Dictionary`2<string, PropertyInfo>> inheritedProperties;
    
private Dictionary`2<Type, Dictionary`2<string, Dictionary`2<int, MethodBase>>> inheritedMethods;
    private static AccessCache();
    private static T Get(Dictionary`2<Type, Dictionary`2<string, T>> dict, Type type, string name, Func`1<T> fetcher);
    private static T Get(Dictionary`2<Type, Dictionary`2<string, Dictionary`2<int, T>>> dict, Type type, string name, Type[] arguments, Func`1<T> fetcher);
    internal FieldInfo GetFieldInfo(Type type, string name, MemberType memberType, bool declaredOnly);
    internal PropertyInfo GetPropertyInfo(Type type, string name, MemberType memberType, bool declaredOnly);
    internal MethodBase GetMethodInfo(Type type, string name, Type[] arguments, MemberType memberType, bool declaredOnly);
}
[ExtensionAttribute]
public static class HarmonyLib.AccessTools : object {
    
public static BindingFlags all;
    
public static BindingFlags allDeclared;
    [CompilerGeneratedAttribute]

private static bool <IsMonoRuntime>k__BackingField;
    [CompilerGeneratedAttribute]

private static bool <IsNetFrameworkRuntime>k__BackingField;
    [CompilerGeneratedAttribute]

private static bool <IsNetCoreRuntime>k__BackingField;
    
private static Dictionary`2<Type, FastInvokeHandler> addHandlerCache;
    
private static ReaderWriterLockSlim addHandlerCacheLock;
    
public static bool IsMonoRuntime { get; }
    
public static bool IsNetFrameworkRuntime { get; }
    
public static bool IsNetCoreRuntime { get; }
    private static AccessTools();
    public static IEnumerable`1<Assembly> AllAssemblies();
    public static Type TypeByName(string name);
    public static Type[] GetTypesFromAssembly(Assembly assembly);
    public static IEnumerable`1<Type> AllTypes();
    public static IEnumerable`1<Type> InnerTypes(Type type);
    public static T FindIncludingBaseTypes(Type type, Func`2<Type, T> func);
    public static T FindIncludingInnerTypes(Type type, Func`2<Type, T> func);
    public static FieldInfo DeclaredField(Type type, string name);
    public static FieldInfo DeclaredField(string typeColonName);
    public static FieldInfo Field(Type type, string name);
    public static FieldInfo Field(string typeColonName);
    public static FieldInfo DeclaredField(Type type, int idx);
    public static PropertyInfo DeclaredProperty(Type type, string name);
    public static PropertyInfo DeclaredProperty(string typeColonName);
    public static PropertyInfo DeclaredIndexer(Type type, Type[] parameters);
    public static MethodInfo DeclaredPropertyGetter(Type type, string name);
    public static MethodInfo DeclaredPropertyGetter(string typeColonName);
    public static MethodInfo DeclaredIndexerGetter(Type type, Type[] parameters);
    public static MethodInfo DeclaredPropertySetter(Type type, string name);
    public static MethodInfo DeclaredPropertySetter(string typeColonName);
    public static MethodInfo DeclaredIndexerSetter(Type type, Type[] parameters);
    public static PropertyInfo Property(Type type, string name);
    public static PropertyInfo Property(string typeColonName);
    public static PropertyInfo Indexer(Type type, Type[] parameters);
    public static MethodInfo PropertyGetter(Type type, string name);
    public static MethodInfo PropertyGetter(string typeColonName);
    public static MethodInfo IndexerGetter(Type type, Type[] parameters);
    public static MethodInfo PropertySetter(Type type, string name);
    public static MethodInfo PropertySetter(string typeColonName);
    public static MethodInfo IndexerSetter(Type type, Type[] parameters);
    public static MethodInfo DeclaredMethod(Type type, string name, Type[] parameters, Type[] generics);
    public static MethodInfo DeclaredMethod(string typeColonName, Type[] parameters, Type[] generics);
    public static MethodInfo Method(Type type, string name, Type[] parameters, Type[] generics);
    public static MethodInfo Method(string typeColonName, Type[] parameters, Type[] generics);
    public static MethodInfo EnumeratorMoveNext(MethodBase method);
    public static MethodInfo AsyncMoveNext(MethodBase method);
    public static List`1<string> GetMethodNames(Type type);
    public static List`1<string> GetMethodNames(object instance);
    public static List`1<string> GetFieldNames(Type type);
    public static List`1<string> GetFieldNames(object instance);
    public static List`1<string> GetPropertyNames(Type type);
    public static List`1<string> GetPropertyNames(object instance);
    [ExtensionAttribute]
public static Type GetUnderlyingType(MemberInfo member);
    [ExtensionAttribute]
public static bool IsDeclaredMember(T member);
    [ExtensionAttribute]
public static T GetDeclaredMember(T member);
    public static ConstructorInfo DeclaredConstructor(Type type, Type[] parameters, bool searchForStatic);
    public static ConstructorInfo Constructor(Type type, Type[] parameters, bool searchForStatic);
    public static List`1<ConstructorInfo> GetDeclaredConstructors(Type type, Nullable`1<bool> searchForStatic);
    public static List`1<MethodInfo> GetDeclaredMethods(Type type);
    public static List`1<PropertyInfo> GetDeclaredProperties(Type type);
    public static List`1<FieldInfo> GetDeclaredFields(Type type);
    public static Type GetReturnedType(MethodBase methodOrConstructor);
    public static Type Inner(Type type, string name);
    public static Type FirstInner(Type type, Func`2<Type, bool> predicate);
    public static MethodInfo FirstMethod(Type type, Func`2<MethodInfo, bool> predicate);
    public static ConstructorInfo FirstConstructor(Type type, Func`2<ConstructorInfo, bool> predicate);
    public static PropertyInfo FirstProperty(Type type, Func`2<PropertyInfo, bool> predicate);
    public static Type[] GetTypes(Object[] parameters);
    public static Object[] ActualParameters(MethodBase method, Object[] inputs);
    public static FieldRef`2<T, F> FieldRefAccess(string fieldName);
    public static F& FieldRefAccess(T instance, string fieldName);
    public static FieldRef`2<object, F> FieldRefAccess(Type type, string fieldName);
    public static FieldRef`2<object, F> FieldRefAccess(string typeColonName);
    public static FieldRef`2<T, F> FieldRefAccess(FieldInfo fieldInfo);
    public static F& FieldRefAccess(T instance, FieldInfo fieldInfo);
    public static StructFieldRef`2<T, F> StructFieldRefAccess(string fieldName);
    public static F& StructFieldRefAccess(T& instance, string fieldName);
    public static StructFieldRef`2<T, F> StructFieldRefAccess(FieldInfo fieldInfo);
    public static F& StructFieldRefAccess(T& instance, FieldInfo fieldInfo);
    public static F& StaticFieldRefAccess(string fieldName);
    public static F& StaticFieldRefAccess(Type type, string fieldName);
    public static F& StaticFieldRefAccess(string typeColonName);
    public static F& StaticFieldRefAccess(FieldInfo fieldInfo);
    public static FieldRef`1<F> StaticFieldRefAccess(FieldInfo fieldInfo);
    public static DelegateType MethodDelegate(MethodInfo method, object instance, bool virtualCall);
    public static DelegateType MethodDelegate(string typeColonName, object instance, bool virtualCall);
    public static DelegateType HarmonyDelegate(object instance);
    public static MethodBase GetOutsideCaller();
    public static void RethrowException(Exception exception);
    [CompilerGeneratedAttribute]
public static bool get_IsMonoRuntime();
    [CompilerGeneratedAttribute]
public static bool get_IsNetFrameworkRuntime();
    [CompilerGeneratedAttribute]
public static bool get_IsNetCoreRuntime();
    public static void ThrowMissingMemberException(Type type, String[] names);
    public static object GetDefaultValue(Type type);
    public static object CreateInstance(Type type);
    public static T CreateInstance();
    public static T MakeDeepCopy(object source);
    public static void MakeDeepCopy(object source, T& result, Func`4<string, Traverse, Traverse, object> processor, string pathRoot);
    public static object MakeDeepCopy(object source, Type resultType, Func`4<string, Traverse, Traverse, object> processor, string pathRoot);
    public static bool IsStruct(Type type);
    public static bool IsClass(Type type);
    public static bool IsValue(Type type);
    public static bool IsInteger(Type type);
    public static bool IsFloatingPoint(Type type);
    public static bool IsNumber(Type type);
    public static bool IsVoid(Type type);
    public static bool IsOfNullableType(T instance);
    public static bool IsStatic(MemberInfo member);
    [EditorBrowsableAttribute("1")]
public static bool IsStatic(Type type);
    [EditorBrowsableAttribute("1")]
public static bool IsStatic(PropertyInfo propertyInfo);
    [EditorBrowsableAttribute("1")]
public static bool IsStatic(EventInfo eventInfo);
    public static int CombinedHashCode(IEnumerable`1<object> objects);
}
[ExtensionAttribute]
public static class HarmonyLib.AccessToolsExtensions : object {
    [ExtensionAttribute]
public static IEnumerable`1<Type> InnerTypes(Type type);
    [ExtensionAttribute]
public static T FindIncludingBaseTypes(Type type, Func`2<Type, T> func);
    [ExtensionAttribute]
public static T FindIncludingInnerTypes(Type type, Func`2<Type, T> func);
    [ExtensionAttribute]
public static FieldInfo DeclaredField(Type type, string name);
    [ExtensionAttribute]
public static FieldInfo Field(Type type, string name);
    [ExtensionAttribute]
public static FieldInfo DeclaredField(Type type, int idx);
    [ExtensionAttribute]
public static PropertyInfo DeclaredProperty(Type type, string name);
    [ExtensionAttribute]
public static PropertyInfo DeclaredIndexer(Type type, Type[] parameters);
    [ExtensionAttribute]
public static MethodInfo DeclaredPropertyGetter(Type type, string name);
    [ExtensionAttribute]
public static MethodInfo DeclaredIndexerGetter(Type type, Type[] parameters);
    [ExtensionAttribute]
public static MethodInfo DeclaredPropertySetter(Type type, string name);
    [ExtensionAttribute]
public static MethodInfo DeclaredIndexerSetter(Type type, Type[] parameters);
    [ExtensionAttribute]
public static PropertyInfo Property(Type type, string name);
    [ExtensionAttribute]
public static PropertyInfo Indexer(Type type, Type[] parameters);
    [ExtensionAttribute]
public static MethodInfo PropertyGetter(Type type, string name);
    [ExtensionAttribute]
public static MethodInfo IndexerGetter(Type type, Type[] parameters);
    [ExtensionAttribute]
public static MethodInfo PropertySetter(Type type, string name);
    [ExtensionAttribute]
public static MethodInfo IndexerSetter(Type type, Type[] parameters);
    [ExtensionAttribute]
public static MethodInfo DeclaredMethod(Type type, string name, Type[] parameters, Type[] generics);
    [ExtensionAttribute]
public static MethodInfo Method(Type type, string name, Type[] parameters, Type[] generics);
    [ExtensionAttribute]
public static List`1<string> GetMethodNames(Type type);
    [ExtensionAttribute]
public static List`1<string> GetFieldNames(Type type);
    [ExtensionAttribute]
public static List`1<string> GetPropertyNames(Type type);
    [ExtensionAttribute]
public static ConstructorInfo DeclaredConstructor(Type type, Type[] parameters, bool searchForStatic);
    [ExtensionAttribute]
public static ConstructorInfo Constructor(Type type, Type[] parameters, bool searchForStatic);
    [ExtensionAttribute]
public static List`1<ConstructorInfo> GetDeclaredConstructors(Type type, Nullable`1<bool> searchForStatic);
    [ExtensionAttribute]
public static List`1<MethodInfo> GetDeclaredMethods(Type type);
    [ExtensionAttribute]
public static List`1<PropertyInfo> GetDeclaredProperties(Type type);
    [ExtensionAttribute]
public static List`1<FieldInfo> GetDeclaredFields(Type type);
    [ExtensionAttribute]
public static Type Inner(Type type, string name);
    [ExtensionAttribute]
public static Type FirstInner(Type type, Func`2<Type, bool> predicate);
    [ExtensionAttribute]
public static MethodInfo FirstMethod(Type type, Func`2<MethodInfo, bool> predicate);
    [ExtensionAttribute]
public static ConstructorInfo FirstConstructor(Type type, Func`2<ConstructorInfo, bool> predicate);
    [ExtensionAttribute]
public static PropertyInfo FirstProperty(Type type, Func`2<PropertyInfo, bool> predicate);
    [ExtensionAttribute]
public static FieldRef`2<object, F> FieldRefAccess(Type type, string fieldName);
    [ExtensionAttribute]
public static F& StaticFieldRefAccess(Type type, string fieldName);
    [ExtensionAttribute]
public static void ThrowMissingMemberException(Type type, String[] names);
    [ExtensionAttribute]
public static object GetDefaultValue(Type type);
    [ExtensionAttribute]
public static object CreateInstance(Type type);
    [ExtensionAttribute]
public static bool IsStruct(Type type);
    [ExtensionAttribute]
public static bool IsClass(Type type);
    [ExtensionAttribute]
public static bool IsValue(Type type);
    [ExtensionAttribute]
public static bool IsInteger(Type type);
    [ExtensionAttribute]
public static bool IsFloatingPoint(Type type);
    [ExtensionAttribute]
public static bool IsNumber(Type type);
    [ExtensionAttribute]
public static bool IsVoid(Type type);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static bool IsStatic(Type type);
}
public enum HarmonyLib.ArgumentType : Enum {
    
public int value__;
    
public static ArgumentType Normal;
    
public static ArgumentType Ref;
    
public static ArgumentType Out;
    
public static ArgumentType Pointer;
}
internal class HarmonyLib.AttributePatch : object {
    
private static HarmonyPatchType[] allPatchTypes;
    
internal HarmonyMethod info;
    
internal Nullable`1<HarmonyPatchType> type;
    private static AttributePatch();
    internal static AttributePatch Create(MethodInfo patch);
    private static Nullable`1<HarmonyPatchType> GetPatchType(string methodName, Object[] allAttributes);
}
internal class HarmonyLib.ByteBuffer : object {
    
internal Byte[] buffer;
    
internal int position;
    internal ByteBuffer(Byte[] buffer);
    internal byte ReadByte();
    internal Byte[] ReadBytes(int length);
    internal short ReadInt16();
    internal int ReadInt32();
    internal long ReadInt64();
    internal float ReadSingle();
    internal double ReadDouble();
    private void CheckCanRead(int count);
}
public static class HarmonyLib.Code : object {
    
public static Operand_ Operand { get; }
    
public static Nop_ Nop { get; }
    
public static Break_ Break { get; }
    
public static Ldarg_0_ Ldarg_0 { get; }
    
public static Ldarg_1_ Ldarg_1 { get; }
    
public static Ldarg_2_ Ldarg_2 { get; }
    
public static Ldarg_3_ Ldarg_3 { get; }
    
public static Ldloc_0_ Ldloc_0 { get; }
    
public static Ldloc_1_ Ldloc_1 { get; }
    
public static Ldloc_2_ Ldloc_2 { get; }
    
public static Ldloc_3_ Ldloc_3 { get; }
    
public static Stloc_0_ Stloc_0 { get; }
    
public static Stloc_1_ Stloc_1 { get; }
    
public static Stloc_2_ Stloc_2 { get; }
    
public static Stloc_3_ Stloc_3 { get; }
    
public static Ldarg_S_ Ldarg_S { get; }
    
public static Ldarga_S_ Ldarga_S { get; }
    
public static Starg_S_ Starg_S { get; }
    
public static Ldloc_S_ Ldloc_S { get; }
    
public static Ldloca_S_ Ldloca_S { get; }
    
public static Stloc_S_ Stloc_S { get; }
    
public static Ldnull_ Ldnull { get; }
    
public static Ldc_I4_M1_ Ldc_I4_M1 { get; }
    
public static Ldc_I4_0_ Ldc_I4_0 { get; }
    
public static Ldc_I4_1_ Ldc_I4_1 { get; }
    
public static Ldc_I4_2_ Ldc_I4_2 { get; }
    
public static Ldc_I4_3_ Ldc_I4_3 { get; }
    
public static Ldc_I4_4_ Ldc_I4_4 { get; }
    
public static Ldc_I4_5_ Ldc_I4_5 { get; }
    
public static Ldc_I4_6_ Ldc_I4_6 { get; }
    
public static Ldc_I4_7_ Ldc_I4_7 { get; }
    
public static Ldc_I4_8_ Ldc_I4_8 { get; }
    
public static Ldc_I4_S_ Ldc_I4_S { get; }
    
public static Ldc_I4_ Ldc_I4 { get; }
    
public static Ldc_I8_ Ldc_I8 { get; }
    
public static Ldc_R4_ Ldc_R4 { get; }
    
public static Ldc_R8_ Ldc_R8 { get; }
    
public static Dup_ Dup { get; }
    
public static Pop_ Pop { get; }
    
public static Jmp_ Jmp { get; }
    
public static Call_ Call { get; }
    
public static Calli_ Calli { get; }
    
public static Ret_ Ret { get; }
    
public static Br_S_ Br_S { get; }
    
public static Brfalse_S_ Brfalse_S { get; }
    
public static Brtrue_S_ Brtrue_S { get; }
    
public static Beq_S_ Beq_S { get; }
    
public static Bge_S_ Bge_S { get; }
    
public static Bgt_S_ Bgt_S { get; }
    
public static Ble_S_ Ble_S { get; }
    
public static Blt_S_ Blt_S { get; }
    
public static Bne_Un_S_ Bne_Un_S { get; }
    
public static Bge_Un_S_ Bge_Un_S { get; }
    
public static Bgt_Un_S_ Bgt_Un_S { get; }
    
public static Ble_Un_S_ Ble_Un_S { get; }
    
public static Blt_Un_S_ Blt_Un_S { get; }
    
public static Br_ Br { get; }
    
public static Brfalse_ Brfalse { get; }
    
public static Brtrue_ Brtrue { get; }
    
public static Beq_ Beq { get; }
    
public static Bge_ Bge { get; }
    
public static Bgt_ Bgt { get; }
    
public static Ble_ Ble { get; }
    
public static Blt_ Blt { get; }
    
public static Bne_Un_ Bne_Un { get; }
    
public static Bge_Un_ Bge_Un { get; }
    
public static Bgt_Un_ Bgt_Un { get; }
    
public static Ble_Un_ Ble_Un { get; }
    
public static Blt_Un_ Blt_Un { get; }
    
public static Switch_ Switch { get; }
    
public static Ldind_I1_ Ldind_I1 { get; }
    
public static Ldind_U1_ Ldind_U1 { get; }
    
public static Ldind_I2_ Ldind_I2 { get; }
    
public static Ldind_U2_ Ldind_U2 { get; }
    
public static Ldind_I4_ Ldind_I4 { get; }
    
public static Ldind_U4_ Ldind_U4 { get; }
    
public static Ldind_I8_ Ldind_I8 { get; }
    
public static Ldind_I_ Ldind_I { get; }
    
public static Ldind_R4_ Ldind_R4 { get; }
    
public static Ldind_R8_ Ldind_R8 { get; }
    
public static Ldind_Ref_ Ldind_Ref { get; }
    
public static Stind_Ref_ Stind_Ref { get; }
    
public static Stind_I1_ Stind_I1 { get; }
    
public static Stind_I2_ Stind_I2 { get; }
    
public static Stind_I4_ Stind_I4 { get; }
    
public static Stind_I8_ Stind_I8 { get; }
    
public static Stind_R4_ Stind_R4 { get; }
    
public static Stind_R8_ Stind_R8 { get; }
    
public static Add_ Add { get; }
    
public static Sub_ Sub { get; }
    
public static Mul_ Mul { get; }
    
public static Div_ Div { get; }
    
public static Div_Un_ Div_Un { get; }
    
public static Rem_ Rem { get; }
    
public static Rem_Un_ Rem_Un { get; }
    
public static And_ And { get; }
    
public static Or_ Or { get; }
    
public static Xor_ Xor { get; }
    
public static Shl_ Shl { get; }
    
public static Shr_ Shr { get; }
    
public static Shr_Un_ Shr_Un { get; }
    
public static Neg_ Neg { get; }
    
public static Not_ Not { get; }
    
public static Conv_I1_ Conv_I1 { get; }
    
public static Conv_I2_ Conv_I2 { get; }
    
public static Conv_I4_ Conv_I4 { get; }
    
public static Conv_I8_ Conv_I8 { get; }
    
public static Conv_R4_ Conv_R4 { get; }
    
public static Conv_R8_ Conv_R8 { get; }
    
public static Conv_U4_ Conv_U4 { get; }
    
public static Conv_U8_ Conv_U8 { get; }
    
public static Callvirt_ Callvirt { get; }
    
public static Cpobj_ Cpobj { get; }
    
public static Ldobj_ Ldobj { get; }
    
public static Ldstr_ Ldstr { get; }
    
public static Newobj_ Newobj { get; }
    
public static Castclass_ Castclass { get; }
    
public static Isinst_ Isinst { get; }
    
public static Conv_R_Un_ Conv_R_Un { get; }
    
public static Unbox_ Unbox { get; }
    
public static Throw_ Throw { get; }
    
public static Ldfld_ Ldfld { get; }
    
public static Ldflda_ Ldflda { get; }
    
public static Stfld_ Stfld { get; }
    
public static Ldsfld_ Ldsfld { get; }
    
public static Ldsflda_ Ldsflda { get; }
    
public static Stsfld_ Stsfld { get; }
    
public static Stobj_ Stobj { get; }
    
public static Conv_Ovf_I1_Un_ Conv_Ovf_I1_Un { get; }
    
public static Conv_Ovf_I2_Un_ Conv_Ovf_I2_Un { get; }
    
public static Conv_Ovf_I4_Un_ Conv_Ovf_I4_Un { get; }
    
public static Conv_Ovf_I8_Un_ Conv_Ovf_I8_Un { get; }
    
public static Conv_Ovf_U1_Un_ Conv_Ovf_U1_Un { get; }
    
public static Conv_Ovf_U2_Un_ Conv_Ovf_U2_Un { get; }
    
public static Conv_Ovf_U4_Un_ Conv_Ovf_U4_Un { get; }
    
public static Conv_Ovf_U8_Un_ Conv_Ovf_U8_Un { get; }
    
public static Conv_Ovf_I_Un_ Conv_Ovf_I_Un { get; }
    
public static Conv_Ovf_U_Un_ Conv_Ovf_U_Un { get; }
    
public static Box_ Box { get; }
    
public static Newarr_ Newarr { get; }
    
public static Ldlen_ Ldlen { get; }
    
public static Ldelema_ Ldelema { get; }
    
public static Ldelem_I1_ Ldelem_I1 { get; }
    
public static Ldelem_U1_ Ldelem_U1 { get; }
    
public static Ldelem_I2_ Ldelem_I2 { get; }
    
public static Ldelem_U2_ Ldelem_U2 { get; }
    
public static Ldelem_I4_ Ldelem_I4 { get; }
    
public static Ldelem_U4_ Ldelem_U4 { get; }
    
public static Ldelem_I8_ Ldelem_I8 { get; }
    
public static Ldelem_I_ Ldelem_I { get; }
    
public static Ldelem_R4_ Ldelem_R4 { get; }
    
public static Ldelem_R8_ Ldelem_R8 { get; }
    
public static Ldelem_Ref_ Ldelem_Ref { get; }
    
public static Stelem_I_ Stelem_I { get; }
    
public static Stelem_I1_ Stelem_I1 { get; }
    
public static Stelem_I2_ Stelem_I2 { get; }
    
public static Stelem_I4_ Stelem_I4 { get; }
    
public static Stelem_I8_ Stelem_I8 { get; }
    
public static Stelem_R4_ Stelem_R4 { get; }
    
public static Stelem_R8_ Stelem_R8 { get; }
    
public static Stelem_Ref_ Stelem_Ref { get; }
    
public static Ldelem_ Ldelem { get; }
    
public static Stelem_ Stelem { get; }
    
public static Unbox_Any_ Unbox_Any { get; }
    
public static Conv_Ovf_I1_ Conv_Ovf_I1 { get; }
    
public static Conv_Ovf_U1_ Conv_Ovf_U1 { get; }
    
public static Conv_Ovf_I2_ Conv_Ovf_I2 { get; }
    
public static Conv_Ovf_U2_ Conv_Ovf_U2 { get; }
    
public static Conv_Ovf_I4_ Conv_Ovf_I4 { get; }
    
public static Conv_Ovf_U4_ Conv_Ovf_U4 { get; }
    
public static Conv_Ovf_I8_ Conv_Ovf_I8 { get; }
    
public static Conv_Ovf_U8_ Conv_Ovf_U8 { get; }
    
public static Refanyval_ Refanyval { get; }
    
public static Ckfinite_ Ckfinite { get; }
    
public static Mkrefany_ Mkrefany { get; }
    
public static Ldtoken_ Ldtoken { get; }
    
public static Conv_U2_ Conv_U2 { get; }
    
public static Conv_U1_ Conv_U1 { get; }
    
public static Conv_I_ Conv_I { get; }
    
public static Conv_Ovf_I_ Conv_Ovf_I { get; }
    
public static Conv_Ovf_U_ Conv_Ovf_U { get; }
    
public static Add_Ovf_ Add_Ovf { get; }
    
public static Add_Ovf_Un_ Add_Ovf_Un { get; }
    
public static Mul_Ovf_ Mul_Ovf { get; }
    
public static Mul_Ovf_Un_ Mul_Ovf_Un { get; }
    
public static Sub_Ovf_ Sub_Ovf { get; }
    
public static Sub_Ovf_Un_ Sub_Ovf_Un { get; }
    
public static Endfinally_ Endfinally { get; }
    
public static Leave_ Leave { get; }
    
public static Leave_S_ Leave_S { get; }
    
public static Stind_I_ Stind_I { get; }
    
public static Conv_U_ Conv_U { get; }
    
public static Prefix7_ Prefix7 { get; }
    
public static Prefix6_ Prefix6 { get; }
    
public static Prefix5_ Prefix5 { get; }
    
public static Prefix4_ Prefix4 { get; }
    
public static Prefix3_ Prefix3 { get; }
    
public static Prefix2_ Prefix2 { get; }
    
public static Prefix1_ Prefix1 { get; }
    
public static Prefixref_ Prefixref { get; }
    
public static Arglist_ Arglist { get; }
    
public static Ceq_ Ceq { get; }
    
public static Cgt_ Cgt { get; }
    
public static Cgt_Un_ Cgt_Un { get; }
    
public static Clt_ Clt { get; }
    
public static Clt_Un_ Clt_Un { get; }
    
public static Ldftn_ Ldftn { get; }
    
public static Ldvirtftn_ Ldvirtftn { get; }
    
public static Ldarg_ Ldarg { get; }
    
public static Ldarga_ Ldarga { get; }
    
public static Starg_ Starg { get; }
    
public static Ldloc_ Ldloc { get; }
    
public static Ldloca_ Ldloca { get; }
    
public static Stloc_ Stloc { get; }
    
public static Localloc_ Localloc { get; }
    
public static Endfilter_ Endfilter { get; }
    
public static Unaligned_ Unaligned { get; }
    
public static Volatile_ Volatile { get; }
    
public static Tailcall_ Tailcall { get; }
    
public static Initobj_ Initobj { get; }
    
public static Constrained_ Constrained { get; }
    
public static Cpblk_ Cpblk { get; }
    
public static Initblk_ Initblk { get; }
    
public static Rethrow_ Rethrow { get; }
    
public static Sizeof_ Sizeof { get; }
    
public static Refanytype_ Refanytype { get; }
    
public static Readonly_ Readonly { get; }
    public static Operand_ get_Operand();
    public static Nop_ get_Nop();
    public static Break_ get_Break();
    public static Ldarg_0_ get_Ldarg_0();
    public static Ldarg_1_ get_Ldarg_1();
    public static Ldarg_2_ get_Ldarg_2();
    public static Ldarg_3_ get_Ldarg_3();
    public static Ldloc_0_ get_Ldloc_0();
    public static Ldloc_1_ get_Ldloc_1();
    public static Ldloc_2_ get_Ldloc_2();
    public static Ldloc_3_ get_Ldloc_3();
    public static Stloc_0_ get_Stloc_0();
    public static Stloc_1_ get_Stloc_1();
    public static Stloc_2_ get_Stloc_2();
    public static Stloc_3_ get_Stloc_3();
    public static Ldarg_S_ get_Ldarg_S();
    public static Ldarga_S_ get_Ldarga_S();
    public static Starg_S_ get_Starg_S();
    public static Ldloc_S_ get_Ldloc_S();
    public static Ldloca_S_ get_Ldloca_S();
    public static Stloc_S_ get_Stloc_S();
    public static Ldnull_ get_Ldnull();
    public static Ldc_I4_M1_ get_Ldc_I4_M1();
    public static Ldc_I4_0_ get_Ldc_I4_0();
    public static Ldc_I4_1_ get_Ldc_I4_1();
    public static Ldc_I4_2_ get_Ldc_I4_2();
    public static Ldc_I4_3_ get_Ldc_I4_3();
    public static Ldc_I4_4_ get_Ldc_I4_4();
    public static Ldc_I4_5_ get_Ldc_I4_5();
    public static Ldc_I4_6_ get_Ldc_I4_6();
    public static Ldc_I4_7_ get_Ldc_I4_7();
    public static Ldc_I4_8_ get_Ldc_I4_8();
    public static Ldc_I4_S_ get_Ldc_I4_S();
    public static Ldc_I4_ get_Ldc_I4();
    public static Ldc_I8_ get_Ldc_I8();
    public static Ldc_R4_ get_Ldc_R4();
    public static Ldc_R8_ get_Ldc_R8();
    public static Dup_ get_Dup();
    public static Pop_ get_Pop();
    public static Jmp_ get_Jmp();
    public static Call_ get_Call();
    public static Calli_ get_Calli();
    public static Ret_ get_Ret();
    public static Br_S_ get_Br_S();
    public static Brfalse_S_ get_Brfalse_S();
    public static Brtrue_S_ get_Brtrue_S();
    public static Beq_S_ get_Beq_S();
    public static Bge_S_ get_Bge_S();
    public static Bgt_S_ get_Bgt_S();
    public static Ble_S_ get_Ble_S();
    public static Blt_S_ get_Blt_S();
    public static Bne_Un_S_ get_Bne_Un_S();
    public static Bge_Un_S_ get_Bge_Un_S();
    public static Bgt_Un_S_ get_Bgt_Un_S();
    public static Ble_Un_S_ get_Ble_Un_S();
    public static Blt_Un_S_ get_Blt_Un_S();
    public static Br_ get_Br();
    public static Brfalse_ get_Brfalse();
    public static Brtrue_ get_Brtrue();
    public static Beq_ get_Beq();
    public static Bge_ get_Bge();
    public static Bgt_ get_Bgt();
    public static Ble_ get_Ble();
    public static Blt_ get_Blt();
    public static Bne_Un_ get_Bne_Un();
    public static Bge_Un_ get_Bge_Un();
    public static Bgt_Un_ get_Bgt_Un();
    public static Ble_Un_ get_Ble_Un();
    public static Blt_Un_ get_Blt_Un();
    public static Switch_ get_Switch();
    public static Ldind_I1_ get_Ldind_I1();
    public static Ldind_U1_ get_Ldind_U1();
    public static Ldind_I2_ get_Ldind_I2();
    public static Ldind_U2_ get_Ldind_U2();
    public static Ldind_I4_ get_Ldind_I4();
    public static Ldind_U4_ get_Ldind_U4();
    public static Ldind_I8_ get_Ldind_I8();
    public static Ldind_I_ get_Ldind_I();
    public static Ldind_R4_ get_Ldind_R4();
    public static Ldind_R8_ get_Ldind_R8();
    public static Ldind_Ref_ get_Ldind_Ref();
    public static Stind_Ref_ get_Stind_Ref();
    public static Stind_I1_ get_Stind_I1();
    public static Stind_I2_ get_Stind_I2();
    public static Stind_I4_ get_Stind_I4();
    public static Stind_I8_ get_Stind_I8();
    public static Stind_R4_ get_Stind_R4();
    public static Stind_R8_ get_Stind_R8();
    public static Add_ get_Add();
    public static Sub_ get_Sub();
    public static Mul_ get_Mul();
    public static Div_ get_Div();
    public static Div_Un_ get_Div_Un();
    public static Rem_ get_Rem();
    public static Rem_Un_ get_Rem_Un();
    public static And_ get_And();
    public static Or_ get_Or();
    public static Xor_ get_Xor();
    public static Shl_ get_Shl();
    public static Shr_ get_Shr();
    public static Shr_Un_ get_Shr_Un();
    public static Neg_ get_Neg();
    public static Not_ get_Not();
    public static Conv_I1_ get_Conv_I1();
    public static Conv_I2_ get_Conv_I2();
    public static Conv_I4_ get_Conv_I4();
    public static Conv_I8_ get_Conv_I8();
    public static Conv_R4_ get_Conv_R4();
    public static Conv_R8_ get_Conv_R8();
    public static Conv_U4_ get_Conv_U4();
    public static Conv_U8_ get_Conv_U8();
    public static Callvirt_ get_Callvirt();
    public static Cpobj_ get_Cpobj();
    public static Ldobj_ get_Ldobj();
    public static Ldstr_ get_Ldstr();
    public static Newobj_ get_Newobj();
    public static Castclass_ get_Castclass();
    public static Isinst_ get_Isinst();
    public static Conv_R_Un_ get_Conv_R_Un();
    public static Unbox_ get_Unbox();
    public static Throw_ get_Throw();
    public static Ldfld_ get_Ldfld();
    public static Ldflda_ get_Ldflda();
    public static Stfld_ get_Stfld();
    public static Ldsfld_ get_Ldsfld();
    public static Ldsflda_ get_Ldsflda();
    public static Stsfld_ get_Stsfld();
    public static Stobj_ get_Stobj();
    public static Conv_Ovf_I1_Un_ get_Conv_Ovf_I1_Un();
    public static Conv_Ovf_I2_Un_ get_Conv_Ovf_I2_Un();
    public static Conv_Ovf_I4_Un_ get_Conv_Ovf_I4_Un();
    public static Conv_Ovf_I8_Un_ get_Conv_Ovf_I8_Un();
    public static Conv_Ovf_U1_Un_ get_Conv_Ovf_U1_Un();
    public static Conv_Ovf_U2_Un_ get_Conv_Ovf_U2_Un();
    public static Conv_Ovf_U4_Un_ get_Conv_Ovf_U4_Un();
    public static Conv_Ovf_U8_Un_ get_Conv_Ovf_U8_Un();
    public static Conv_Ovf_I_Un_ get_Conv_Ovf_I_Un();
    public static Conv_Ovf_U_Un_ get_Conv_Ovf_U_Un();
    public static Box_ get_Box();
    public static Newarr_ get_Newarr();
    public static Ldlen_ get_Ldlen();
    public static Ldelema_ get_Ldelema();
    public static Ldelem_I1_ get_Ldelem_I1();
    public static Ldelem_U1_ get_Ldelem_U1();
    public static Ldelem_I2_ get_Ldelem_I2();
    public static Ldelem_U2_ get_Ldelem_U2();
    public static Ldelem_I4_ get_Ldelem_I4();
    public static Ldelem_U4_ get_Ldelem_U4();
    public static Ldelem_I8_ get_Ldelem_I8();
    public static Ldelem_I_ get_Ldelem_I();
    public static Ldelem_R4_ get_Ldelem_R4();
    public static Ldelem_R8_ get_Ldelem_R8();
    public static Ldelem_Ref_ get_Ldelem_Ref();
    public static Stelem_I_ get_Stelem_I();
    public static Stelem_I1_ get_Stelem_I1();
    public static Stelem_I2_ get_Stelem_I2();
    public static Stelem_I4_ get_Stelem_I4();
    public static Stelem_I8_ get_Stelem_I8();
    public static Stelem_R4_ get_Stelem_R4();
    public static Stelem_R8_ get_Stelem_R8();
    public static Stelem_Ref_ get_Stelem_Ref();
    public static Ldelem_ get_Ldelem();
    public static Stelem_ get_Stelem();
    public static Unbox_Any_ get_Unbox_Any();
    public static Conv_Ovf_I1_ get_Conv_Ovf_I1();
    public static Conv_Ovf_U1_ get_Conv_Ovf_U1();
    public static Conv_Ovf_I2_ get_Conv_Ovf_I2();
    public static Conv_Ovf_U2_ get_Conv_Ovf_U2();
    public static Conv_Ovf_I4_ get_Conv_Ovf_I4();
    public static Conv_Ovf_U4_ get_Conv_Ovf_U4();
    public static Conv_Ovf_I8_ get_Conv_Ovf_I8();
    public static Conv_Ovf_U8_ get_Conv_Ovf_U8();
    public static Refanyval_ get_Refanyval();
    public static Ckfinite_ get_Ckfinite();
    public static Mkrefany_ get_Mkrefany();
    public static Ldtoken_ get_Ldtoken();
    public static Conv_U2_ get_Conv_U2();
    public static Conv_U1_ get_Conv_U1();
    public static Conv_I_ get_Conv_I();
    public static Conv_Ovf_I_ get_Conv_Ovf_I();
    public static Conv_Ovf_U_ get_Conv_Ovf_U();
    public static Add_Ovf_ get_Add_Ovf();
    public static Add_Ovf_Un_ get_Add_Ovf_Un();
    public static Mul_Ovf_ get_Mul_Ovf();
    public static Mul_Ovf_Un_ get_Mul_Ovf_Un();
    public static Sub_Ovf_ get_Sub_Ovf();
    public static Sub_Ovf_Un_ get_Sub_Ovf_Un();
    public static Endfinally_ get_Endfinally();
    public static Leave_ get_Leave();
    public static Leave_S_ get_Leave_S();
    public static Stind_I_ get_Stind_I();
    public static Conv_U_ get_Conv_U();
    public static Prefix7_ get_Prefix7();
    public static Prefix6_ get_Prefix6();
    public static Prefix5_ get_Prefix5();
    public static Prefix4_ get_Prefix4();
    public static Prefix3_ get_Prefix3();
    public static Prefix2_ get_Prefix2();
    public static Prefix1_ get_Prefix1();
    public static Prefixref_ get_Prefixref();
    public static Arglist_ get_Arglist();
    public static Ceq_ get_Ceq();
    public static Cgt_ get_Cgt();
    public static Cgt_Un_ get_Cgt_Un();
    public static Clt_ get_Clt();
    public static Clt_Un_ get_Clt_Un();
    public static Ldftn_ get_Ldftn();
    public static Ldvirtftn_ get_Ldvirtftn();
    public static Ldarg_ get_Ldarg();
    public static Ldarga_ get_Ldarga();
    public static Starg_ get_Starg();
    public static Ldloc_ get_Ldloc();
    public static Ldloca_ get_Ldloca();
    public static Stloc_ get_Stloc();
    public static Localloc_ get_Localloc();
    public static Endfilter_ get_Endfilter();
    public static Unaligned_ get_Unaligned();
    public static Volatile_ get_Volatile();
    public static Tailcall_ get_Tailcall();
    public static Initobj_ get_Initobj();
    public static Constrained_ get_Constrained();
    public static Cpblk_ get_Cpblk();
    public static Initblk_ get_Initblk();
    public static Rethrow_ get_Rethrow();
    public static Sizeof_ get_Sizeof();
    public static Refanytype_ get_Refanytype();
    public static Readonly_ get_Readonly();
}
public class HarmonyLib.CodeInstruction : object {
    
public OpCode opcode;
    
public object operand;
    
public List`1<Label> labels;
    
public List`1<ExceptionBlock> blocks;
    public CodeInstruction(OpCode opcode, object operand);
    public CodeInstruction(CodeInstruction instruction);
    public CodeInstruction Clone();
    public CodeInstruction Clone(OpCode opcode);
    public CodeInstruction Clone(object operand);
    public static CodeInstruction Call(Type type, string name, Type[] parameters, Type[] generics);
    public static CodeInstruction Call(string typeColonMethodname, Type[] parameters, Type[] generics);
    public static CodeInstruction Call(Expression`1<Action> expression);
    public static CodeInstruction Call(Expression`1<Action`1<T>> expression);
    public static CodeInstruction Call(Expression`1<Func`2<T, TResult>> expression);
    public static CodeInstruction Call(LambdaExpression expression);
    public static CodeInstruction CallClosure(T closure);
    public static CodeInstruction LoadField(Type type, string name, bool useAddress);
    public static CodeInstruction StoreField(Type type, string name);
    public static CodeInstruction LoadLocal(int index, bool useAddress);
    public static CodeInstruction StoreLocal(int index);
    public static CodeInstruction LoadArgument(int index, bool useAddress);
    public static CodeInstruction StoreArgument(int index);
    public virtual string ToString();
}
[ExtensionAttribute]
public static class HarmonyLib.CodeInstructionExtensions : object {
    
internal static HashSet`1<OpCode> opcodesCalling;
    
internal static HashSet`1<OpCode> opcodesLoadingLocalByAddress;
    
internal static HashSet`1<OpCode> opcodesLoadingLocalNormal;
    
internal static HashSet`1<OpCode> opcodesStoringLocal;
    
internal static HashSet`1<OpCode> opcodesLoadingArgumentByAddress;
    
internal static HashSet`1<OpCode> opcodesLoadingArgumentNormal;
    
internal static HashSet`1<OpCode> opcodesStoringArgument;
    
internal static HashSet`1<OpCode> opcodesBranching;
    
private static HashSet`1<OpCode> constantLoadingCodes;
    private static CodeInstructionExtensions();
    [ExtensionAttribute]
public static bool IsValid(OpCode code);
    [ExtensionAttribute]
public static bool OperandIs(CodeInstruction code, object value);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static bool OperandIs(CodeInstruction code, MemberInfo value);
    [ExtensionAttribute]
public static bool Is(CodeInstruction code, OpCode opcode, object operand);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static bool Is(CodeInstruction code, OpCode opcode, MemberInfo operand);
    [ExtensionAttribute]
public static bool IsLdarg(CodeInstruction code, Nullable`1<int> n);
    [ExtensionAttribute]
public static bool IsLdarga(CodeInstruction code, Nullable`1<int> n);
    [ExtensionAttribute]
public static bool IsStarg(CodeInstruction code, Nullable`1<int> n);
    [ExtensionAttribute]
public static bool IsLdloc(CodeInstruction code, LocalBuilder variable);
    [ExtensionAttribute]
public static bool IsStloc(CodeInstruction code, LocalBuilder variable);
    [ExtensionAttribute]
public static bool Branches(CodeInstruction code, Nullable`1& label);
    [ExtensionAttribute]
public static bool Calls(CodeInstruction code, MethodInfo method);
    [ExtensionAttribute]
public static bool LoadsConstant(CodeInstruction code);
    [ExtensionAttribute]
public static bool LoadsConstant(CodeInstruction code, long number);
    [ExtensionAttribute]
public static bool LoadsConstant(CodeInstruction code, double number);
    [ExtensionAttribute]
public static bool LoadsConstant(CodeInstruction code, Enum e);
    [ExtensionAttribute]
public static bool LoadsConstant(CodeInstruction code, string str);
    [ExtensionAttribute]
public static bool LoadsField(CodeInstruction code, FieldInfo field, bool byAddress);
    [ExtensionAttribute]
public static bool StoresField(CodeInstruction code, FieldInfo field);
    [ExtensionAttribute]
public static int LocalIndex(CodeInstruction code);
    [ExtensionAttribute]
public static int ArgumentIndex(CodeInstruction code);
    [ExtensionAttribute]
public static CodeInstruction WithLabels(CodeInstruction code, Label[] labels);
    [ExtensionAttribute]
public static CodeInstruction WithLabels(CodeInstruction code, IEnumerable`1<Label> labels);
    [ExtensionAttribute]
public static List`1<Label> ExtractLabels(CodeInstruction code);
    [ExtensionAttribute]
public static CodeInstruction MoveLabelsTo(CodeInstruction code, CodeInstruction other);
    [ExtensionAttribute]
public static CodeInstruction MoveLabelsFrom(CodeInstruction code, CodeInstruction other);
    [ExtensionAttribute]
public static CodeInstruction WithBlocks(CodeInstruction code, ExceptionBlock[] blocks);
    [ExtensionAttribute]
public static CodeInstruction WithBlocks(CodeInstruction code, IEnumerable`1<ExceptionBlock> blocks);
    [ExtensionAttribute]
public static List`1<ExceptionBlock> ExtractBlocks(CodeInstruction code);
    [ExtensionAttribute]
public static CodeInstruction MoveBlocksTo(CodeInstruction code, CodeInstruction other);
    [ExtensionAttribute]
public static CodeInstruction MoveBlocksFrom(CodeInstruction code, CodeInstruction other);
}
[ExtensionAttribute]
public static class HarmonyLib.CodeInstructionsExtensions : object {
    [ExtensionAttribute]
public static bool Matches(IEnumerable`1<CodeInstruction> instructions, CodeMatch[] matches);
}
public class HarmonyLib.CodeMatch : CodeInstruction {
    
public string name;
    
public HashSet`1<OpCode> opcodeSet;
    
public List`1<object> operands;
    
public List`1<int> jumpsFrom;
    
public List`1<int> jumpsTo;
    
public Func`2<CodeInstruction, bool> predicate;
    [ObsoleteAttribute("Use opcodeSet instead")]

public List`1<OpCode> opcodes { get; public set; }
    public CodeMatch(Nullable`1<OpCode> opcode, object operand, string name);
    public CodeMatch(Expression`1<Action> expression, string name);
    public CodeMatch(LambdaExpression expression, string name);
    public CodeMatch(CodeInstruction instruction, string name);
    public CodeMatch(Func`2<CodeInstruction, bool> predicate, string name);
    public List`1<OpCode> get_opcodes();
    public void set_opcodes(List`1<OpCode> value);
    internal CodeMatch Set(object operand, string name);
    internal CodeMatch Set(OpCode opcode, object operand, string name);
    public static CodeMatch WithOpcodes(HashSet`1<OpCode> opcodes, object operand, string name);
    internal bool Matches(List`1<CodeInstruction> codes, CodeInstruction instruction);
    public static CodeMatch IsLdarg(Nullable`1<int> n);
    public static CodeMatch IsLdarga(Nullable`1<int> n);
    public static CodeMatch IsStarg(Nullable`1<int> n);
    public static CodeMatch IsLdloc(LocalBuilder variable);
    public static CodeMatch IsStloc(LocalBuilder variable);
    public static CodeMatch Calls(MethodInfo method);
    public static CodeMatch LoadsConstant();
    public static CodeMatch LoadsConstant(long number);
    public static CodeMatch LoadsConstant(double number);
    public static CodeMatch LoadsConstant(Enum e);
    public static CodeMatch LoadsConstant(string str);
    public static CodeMatch LoadsField(FieldInfo field, bool byAddress);
    public static CodeMatch StoresField(FieldInfo field);
    public static CodeMatch Calls(Expression`1<Action> expression);
    public static CodeMatch Calls(LambdaExpression expression);
    public static CodeMatch LoadsLocal(bool useAddress, string name);
    public static CodeMatch StoresLocal(string name);
    public static CodeMatch LoadsArgument(bool useAddress, string name);
    public static CodeMatch StoresArgument(string name);
    public static CodeMatch Branches(string name);
    public virtual string ToString();
}
public class HarmonyLib.CodeMatcher : object {
    
private ILGenerator generator;
    
private List`1<CodeInstruction> codes;
    [CompilerGeneratedAttribute]

private int <Pos>k__BackingField;
    
private Dictionary`2<string, CodeInstruction> lastMatches;
    
private string lastError;
    
private MatchDelegate lastMatchCall;
    
public int Pos { get; private set; }
    
public int Length { get; }
    
public bool IsValid { get; }
    
public bool IsInvalid { get; }
    
public int Remaining { get; }
    
public OpCode& Opcode { get; }
    
public Object& Operand { get; }
    
public List`1& Labels { get; }
    
public List`1& Blocks { get; }
    
public CodeInstruction Instruction { get; }
    public CodeMatcher(IEnumerable`1<CodeInstruction> instructions, ILGenerator generator);
    [CompilerGeneratedAttribute]
public int get_Pos();
    [CompilerGeneratedAttribute]
private void set_Pos(int value);
    private void FixStart();
    private void SetOutOfBounds(int direction);
    public int get_Length();
    public bool get_IsValid();
    public bool get_IsInvalid();
    public int get_Remaining();
    public OpCode& get_Opcode();
    public Object& get_Operand();
    public List`1& get_Labels();
    public List`1& get_Blocks();
    public CodeMatcher Clone();
    public CodeInstruction get_Instruction();
    public CodeInstruction InstructionAt(int offset);
    public List`1<CodeInstruction> Instructions();
    public IEnumerable`1<CodeInstruction> InstructionEnumeration();
    public List`1<CodeInstruction> Instructions(int count);
    public List`1<CodeInstruction> InstructionsInRange(int start, int end);
    public List`1<CodeInstruction> InstructionsWithOffsets(int startOffset, int endOffset);
    public List`1<Label> DistinctLabels(IEnumerable`1<CodeInstruction> instructions);
    public bool ReportFailure(MethodBase method, Action`1<string> logger);
    public CodeMatcher ThrowIfInvalid(string explanation);
    public CodeMatcher ThrowIfNotMatch(string explanation, CodeMatch[] matches);
    private void ThrowIfNotMatch(string explanation, int direction, CodeMatch[] matches);
    public CodeMatcher ThrowIfNotMatchForward(string explanation, CodeMatch[] matches);
    public CodeMatcher ThrowIfNotMatchBack(string explanation, CodeMatch[] matches);
    public CodeMatcher ThrowIfFalse(string explanation, Func`2<CodeMatcher, bool> stateCheckFunc);
    public CodeMatcher SetInstruction(CodeInstruction instruction);
    public CodeMatcher SetInstructionAndAdvance(CodeInstruction instruction);
    public CodeMatcher Set(OpCode opcode, object operand);
    public CodeMatcher SetAndAdvance(OpCode opcode, object operand);
    public CodeMatcher SetOpcodeAndAdvance(OpCode opcode);
    public CodeMatcher SetOperandAndAdvance(object operand);
    public CodeMatcher DeclareLocal(Type variableType, LocalBuilder& localVariable);
    public CodeMatcher DefineLabel(Label& label);
    public CodeMatcher CreateLabel(Label& label);
    public CodeMatcher CreateLabelAt(int position, Label& label);
    public CodeMatcher CreateLabelWithOffsets(int offset, Label& label);
    public CodeMatcher AddLabels(IEnumerable`1<Label> labels);
    public CodeMatcher AddLabelsAt(int position, IEnumerable`1<Label> labels);
    public CodeMatcher SetJumpTo(OpCode opcode, int destination, Label& label);
    public CodeMatcher Insert(CodeInstruction[] instructions);
    public CodeMatcher Insert(IEnumerable`1<CodeInstruction> instructions);
    public CodeMatcher InsertBranch(OpCode opcode, int destination);
    public CodeMatcher InsertAndAdvance(CodeInstruction[] instructions);
    public CodeMatcher InsertAndAdvance(IEnumerable`1<CodeInstruction> instructions);
    public CodeMatcher InsertBranchAndAdvance(OpCode opcode, int destination);
    public CodeMatcher RemoveInstruction();
    public CodeMatcher RemoveInstructions(int count);
    public CodeMatcher RemoveInstructionsInRange(int start, int end);
    public CodeMatcher RemoveInstructionsWithOffsets(int startOffset, int endOffset);
    public CodeMatcher Advance(int offset);
    public CodeMatcher Start();
    public CodeMatcher End();
    public CodeMatcher SearchForward(Func`2<CodeInstruction, bool> predicate);
    public CodeMatcher SearchBackwards(Func`2<CodeInstruction, bool> predicate);
    private CodeMatcher Search(Func`2<CodeInstruction, bool> predicate, int direction);
    public CodeMatcher MatchStartForward(CodeMatch[] matches);
    public CodeMatcher MatchEndForward(CodeMatch[] matches);
    public CodeMatcher MatchStartBackwards(CodeMatch[] matches);
    public CodeMatcher MatchEndBackwards(CodeMatch[] matches);
    private CodeMatcher Match(CodeMatch[] matches, int direction, bool useEnd);
    public CodeMatcher Repeat(Action`1<CodeMatcher> matchAction, Action`1<string> notFoundAction);
    public CodeInstruction NamedMatch(string name);
    private bool MatchSequence(int start, CodeMatch[] matches);
}
internal class HarmonyLib.CodeTranspiler : object {
    
private IEnumerable`1<CodeInstruction> codeInstructions;
    
private List`1<MethodInfo> transpilers;
    
private static Dictionary`2<OpCode, OpCode> allJumpCodes;
    internal CodeTranspiler(List`1<ILInstruction> ilInstructions);
    private static CodeTranspiler();
    internal void Add(MethodInfo transpiler);
    internal static object ConvertInstruction(Type type, object instruction, Dictionary`2& unassigned);
    internal static bool ShouldAddExceptionInfo(object op, int opIndex, List`1<object> originalInstructions, List`1<object> newInstructions, Dictionary`2<object, Dictionary`2<string, object>> unassignedValues);
    internal static IEnumerable ConvertInstructionsAndUnassignedValues(Type type, IEnumerable enumerable, Dictionary`2& unassignedValues);
    [IteratorStateMachineAttribute("HarmonyLib.CodeTranspiler/<ConvertToOurInstructions>d__7")]
internal static IEnumerable ConvertToOurInstructions(IEnumerable instructions, Type codeInstructionType, List`1<object> originalInstructions, Dictionary`2<object, Dictionary`2<string, object>> unassignedValues);
    private static bool IsCodeInstructionsParameter(Type type);
    internal static IEnumerable ConvertToGeneralInstructions(MethodInfo transpiler, IEnumerable enumerable, Dictionary`2& unassignedValues);
    internal static List`1<object> GetTranspilerCallParameters(ILGenerator generator, MethodInfo transpiler, MethodBase method, IEnumerable instructions);
    internal List`1<CodeInstruction> GetResult(ILGenerator generator, MethodBase method);
    private static OpCode ReplaceShortJumps(OpCode opcode);
}
[ExtensionAttribute]
public static class HarmonyLib.CollectionExtensions : object {
    [ExtensionAttribute]
public static void Do(IEnumerable`1<T> sequence, Action`1<T> action);
    [ExtensionAttribute]
public static void DoIf(IEnumerable`1<T> sequence, Func`2<T, bool> condition, Action`1<T> action);
    [ExtensionAttribute]
public static IEnumerable`1<T> AddItem(IEnumerable`1<T> sequence, T item);
    [ExtensionAttribute]
public static T[] AddToArray(T[] sequence, T item);
    [ExtensionAttribute]
public static T[] AddRangeToArray(T[] sequence, T[] items);
    [ExtensionAttribute]
internal static Dictionary`2<K, V> Merge(IEnumerable`1<KeyValuePair`2<K, V>> firstDict, IEnumerable`1[] otherDicts);
    [ExtensionAttribute]
internal static Dictionary`2<K, V> TransformKeys(Dictionary`2<K, V> origDict, Func`2<K, K> transform);
}
public class HarmonyLib.DelegateTypeFactory : object {
    
private ModuleBuilder module;
    
private static int counter;
    public Type CreateDelegateType(MethodInfo method);
}
internal class HarmonyLib.Emitter : object {
    
private CecilILGenerator il;
    
private Dictionary`2<int, CodeInstruction> instructions;
    
private bool debug;
    internal Emitter(ILGenerator il, bool debug);
    internal Dictionary`2<int, CodeInstruction> GetInstructions();
    internal void AddInstruction(OpCode opcode, object operand);
    internal int CurrentPos();
    internal static string CodePos(int offset);
    internal string CodePos();
    internal void LogComment(string comment);
    internal void LogIL(OpCode opcode);
    internal void LogIL(OpCode opcode, object arg, string extra);
    internal void LogAllLocalVariables();
    internal static string FormatArgument(object argument, string extra);
    internal void MarkLabel(Label label);
    internal void MarkBlockBefore(ExceptionBlock block, Nullable`1& label);
    internal void MarkBlockAfter(ExceptionBlock block);
    internal void Emit(OpCode opcode);
    internal void Emit(OpCode opcode, LocalBuilder local);
    internal void Emit(OpCode opcode, FieldInfo field);
    internal void Emit(OpCode opcode, Label[] labels);
    internal void Emit(OpCode opcode, Label label);
    internal void Emit(OpCode opcode, string str);
    internal void Emit(OpCode opcode, float arg);
    internal void Emit(OpCode opcode, byte arg);
    internal void Emit(OpCode opcode, sbyte arg);
    internal void Emit(OpCode opcode, double arg);
    internal void Emit(OpCode opcode, int arg);
    internal void Emit(OpCode opcode, MethodInfo meth);
    internal void Emit(OpCode opcode, short arg);
    internal void Emit(OpCode opcode, SignatureHelper signature);
    internal void Emit(OpCode opcode, ConstructorInfo con);
    internal void Emit(OpCode opcode, Type cls);
    internal void Emit(OpCode opcode, long arg);
    internal void EmitCall(OpCode opcode, MethodInfo methodInfo, Type[] optionalParameterTypes);
    internal void EmitCalli(OpCode opcode, CallingConvention unmanagedCallConv, Type returnType, Type[] parameterTypes);
    internal void EmitCalli(OpCode opcode, CallingConventions callingConvention, Type returnType, Type[] parameterTypes, Type[] optionalParameterTypes);
}
public class HarmonyLib.ExceptionBlock : object {
    
public ExceptionBlockType blockType;
    
public Type catchType;
    public ExceptionBlock(ExceptionBlockType blockType, Type catchType);
}
public enum HarmonyLib.ExceptionBlockType : Enum {
    
public int value__;
    
public static ExceptionBlockType BeginExceptionBlock;
    
public static ExceptionBlockType BeginCatchBlock;
    
public static ExceptionBlockType BeginExceptFilterBlock;
    
public static ExceptionBlockType BeginFaultBlock;
    
public static ExceptionBlockType BeginFinallyBlock;
    
public static ExceptionBlockType EndExceptionBlock;
}
public static class HarmonyLib.FastAccess : object {
    public static InstantiationHandler`1<T> CreateInstantiationHandler();
    [ObsoleteAttribute("Use AccessTools.MethodDelegate<Func<T, S>>(PropertyInfo.GetGetMethod(true))")]
public static GetterHandler`2<T, S> CreateGetterHandler(PropertyInfo propertyInfo);
    [ObsoleteAttribute("Use AccessTools.FieldRefAccess<T, S>(fieldInfo)")]
public static GetterHandler`2<T, S> CreateGetterHandler(FieldInfo fieldInfo);
    [ObsoleteAttribute("Use AccessTools.FieldRefAccess<T, S>(name) for fields and AccessTools.MethodDelegate<Func<T, S>>(AccessTools.PropertyGetter(typeof(T), name)) for properties")]
public static GetterHandler`2<T, S> CreateFieldGetter(String[] names);
    [ObsoleteAttribute("Use AccessTools.MethodDelegate<Action<T, S>>(PropertyInfo.GetSetMethod(true))")]
public static SetterHandler`2<T, S> CreateSetterHandler(PropertyInfo propertyInfo);
    [ObsoleteAttribute("Use AccessTools.FieldRefAccess<T, S>(fieldInfo)")]
public static SetterHandler`2<T, S> CreateSetterHandler(FieldInfo fieldInfo);
    private static DynamicMethodDefinition CreateGetDynamicMethod(Type type);
    private static DynamicMethodDefinition CreateSetDynamicMethod(Type type);
}
public class HarmonyLib.FastInvokeHandler : MulticastDelegate {
    public FastInvokeHandler(object object, IntPtr method);
    public virtual object Invoke(object target, Object[] parameters);
    public virtual IAsyncResult BeginInvoke(object target, Object[] parameters, AsyncCallback callback, object object);
    public virtual object EndInvoke(IAsyncResult result);
}
public static class HarmonyLib.FileLog : object {
    
private static object fileLock;
    
private static bool _logPathInited;
    
private static string _logPath;
    [CompilerGeneratedAttribute]

private static StreamWriter <LogWriter>k__BackingField;
    
public static char indentChar;
    
public static int indentLevel;
    
private static List`1<string> buffer;
    
public static StreamWriter LogWriter { get; public set; }
    
public static string LogPath { get; }
    private static FileLog();
    [CompilerGeneratedAttribute]
public static StreamWriter get_LogWriter();
    [CompilerGeneratedAttribute]
public static void set_LogWriter(StreamWriter value);
    public static string get_LogPath();
    private static string IndentString();
    public static void ChangeIndent(int delta);
    public static void LogBuffered(string str);
    public static void LogBuffered(List`1<string> strings);
    public static List`1<string> GetBuffer(bool clear);
    public static void SetBuffer(List`1<string> buffer);
    public static void FlushBuffer();
    public static void Log(string str);
    public static void Debug(string str);
    public static void Reset();
    public static void LogBytes(long ptr, int len);
}
[ExtensionAttribute]
public static class HarmonyLib.GeneralExtensions : object {
    [ExtensionAttribute]
public static string Join(IEnumerable`1<T> enumeration, Func`2<T, string> converter, string delimiter);
    [ExtensionAttribute]
public static string Description(Type[] parameters);
    [ExtensionAttribute]
public static string FullDescription(Type type);
    [ExtensionAttribute]
public static string FullDescription(MethodBase member);
    [ExtensionAttribute]
public static Type[] Types(ParameterInfo[] pinfo);
    [ExtensionAttribute]
public static T GetValueSafe(Dictionary`2<S, T> dictionary, S key);
    [ExtensionAttribute]
public static T GetTypedValue(Dictionary`2<string, object> dictionary, string key);
    [ExtensionAttribute]
public static string ToLiteral(string input, string quoteChar);
}
[ObsoleteAttribute("Use AccessTools.FieldRefAccess<T, S> for fields and AccessTools.MethodDelegate<Func<T, S>> for property getters")]
public class HarmonyLib.GetterHandler`2 : MulticastDelegate {
    public GetterHandler`2(object object, IntPtr method);
    public virtual S Invoke(T source);
    public virtual IAsyncResult BeginInvoke(T source, AsyncCallback callback, object object);
    public virtual S EndInvoke(IAsyncResult result);
}
public class HarmonyLib.Harmony : object {
    [CompilerGeneratedAttribute]

private string <Id>k__BackingField;
    
public static bool DEBUG;
    
public string Id { get; private set; }
    public Harmony(string id);
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
private void set_Id(string value);
    public void PatchAll();
    public PatchProcessor CreateProcessor(MethodBase original);
    public PatchClassProcessor CreateClassProcessor(Type type);
    public ReversePatcher CreateReversePatcher(MethodBase original, HarmonyMethod standin);
    public void PatchAll(Assembly assembly);
    public void PatchAllUncategorized();
    public void PatchAllUncategorized(Assembly assembly);
    public void PatchCategory(string category);
    public void PatchCategory(Assembly assembly, string category);
    public MethodInfo Patch(MethodBase original, HarmonyMethod prefix, HarmonyMethod postfix, HarmonyMethod transpiler, HarmonyMethod finalizer);
    public static MethodInfo ReversePatch(MethodBase original, HarmonyMethod standin, MethodInfo transpiler);
    public void UnpatchAll(string harmonyID);
    public void Unpatch(MethodBase original, HarmonyPatchType type, string harmonyID);
    public void Unpatch(MethodBase original, MethodInfo patch);
    public static bool HasAnyPatches(string harmonyID);
    public static Patches GetPatchInfo(MethodBase method);
    public IEnumerable`1<MethodBase> GetPatchedMethods();
    public static IEnumerable`1<MethodBase> GetAllPatchedMethods();
    public static MethodBase GetOriginalMethod(MethodInfo replacement);
    public static MethodBase GetMethodFromStackframe(StackFrame frame);
    public static MethodBase GetOriginalMethodFromStackframe(StackFrame frame);
    public static Dictionary`2<string, Version> VersionInfo(Version& currentVersion);
    [CompilerGeneratedAttribute]
private void <PatchAll>b__10_0(Type type);
    [CompilerGeneratedAttribute]
private bool <GetPatchedMethods>b__22_0(MethodBase original);
}
[AttributeUsageAttribute("68")]
public class HarmonyLib.HarmonyAfter : HarmonyAttribute {
    public HarmonyAfter(String[] after);
}
[AttributeUsageAttribute("2116")]
public class HarmonyLib.HarmonyArgument : Attribute {
    [CompilerGeneratedAttribute]

private string <OriginalName>k__BackingField;
    [CompilerGeneratedAttribute]

private int <Index>k__BackingField;
    [CompilerGeneratedAttribute]

private string <NewName>k__BackingField;
    
public string OriginalName { get; private set; }
    
public int Index { get; private set; }
    
public string NewName { get; private set; }
    public HarmonyArgument(string originalName);
    public HarmonyArgument(int index);
    public HarmonyArgument(string originalName, string newName);
    public HarmonyArgument(int index, string name);
    [CompilerGeneratedAttribute]
public string get_OriginalName();
    [CompilerGeneratedAttribute]
private void set_OriginalName(string value);
    [CompilerGeneratedAttribute]
public int get_Index();
    [CompilerGeneratedAttribute]
private void set_Index(int value);
    [CompilerGeneratedAttribute]
public string get_NewName();
    [CompilerGeneratedAttribute]
private void set_NewName(string value);
}
public class HarmonyLib.HarmonyAttribute : Attribute {
    
public HarmonyMethod info;
}
[AttributeUsageAttribute("68")]
public class HarmonyLib.HarmonyBefore : HarmonyAttribute {
    public HarmonyBefore(String[] before);
}
[AttributeUsageAttribute("64")]
public class HarmonyLib.HarmonyCleanup : Attribute {
}
[AttributeUsageAttribute("68")]
public class HarmonyLib.HarmonyDebug : HarmonyAttribute {
}
[AttributeUsageAttribute("4096")]
public class HarmonyLib.HarmonyDelegate : HarmonyPatch {
    public HarmonyDelegate(Type declaringType);
    public HarmonyDelegate(Type declaringType, Type[] argumentTypes);
    public HarmonyDelegate(Type declaringType, string methodName);
    public HarmonyDelegate(Type declaringType, string methodName, Type[] argumentTypes);
    public HarmonyDelegate(Type declaringType, string methodName, Type[] argumentTypes, ArgumentType[] argumentVariations);
    public HarmonyDelegate(Type declaringType, MethodDispatchType methodDispatchType);
    public HarmonyDelegate(Type declaringType, MethodDispatchType methodDispatchType, Type[] argumentTypes);
    public HarmonyDelegate(Type declaringType, MethodDispatchType methodDispatchType, Type[] argumentTypes, ArgumentType[] argumentVariations);
    public HarmonyDelegate(Type declaringType, string methodName, MethodDispatchType methodDispatchType);
    public HarmonyDelegate(string methodName);
    public HarmonyDelegate(string methodName, Type[] argumentTypes);
    public HarmonyDelegate(string methodName, Type[] argumentTypes, ArgumentType[] argumentVariations);
    public HarmonyDelegate(string methodName, MethodDispatchType methodDispatchType);
    public HarmonyDelegate(MethodDispatchType methodDispatchType);
    public HarmonyDelegate(MethodDispatchType methodDispatchType, Type[] argumentTypes);
    public HarmonyDelegate(MethodDispatchType methodDispatchType, Type[] argumentTypes, ArgumentType[] argumentVariations);
    public HarmonyDelegate(Type[] argumentTypes);
    public HarmonyDelegate(Type[] argumentTypes, ArgumentType[] argumentVariations);
}
public class HarmonyLib.HarmonyException : Exception {
    
private Dictionary`2<int, CodeInstruction> instructions;
    
private int errorOffset;
    internal HarmonyException(string message);
    internal HarmonyException(string message, Exception innerException);
    protected HarmonyException(SerializationInfo serializationInfo, StreamingContext streamingContext);
    internal HarmonyException(Exception innerException, Dictionary`2<int, CodeInstruction> instructions, int errorOffset);
    internal static Exception Create(Exception ex, Dictionary`2<int, CodeInstruction> finalInstructions);
    public List`1<KeyValuePair`2<int, CodeInstruction>> GetInstructionsWithOffsets();
    public List`1<CodeInstruction> GetInstructions();
    public int GetErrorOffset();
    public int GetErrorIndex();
}
[AttributeUsageAttribute("64")]
public class HarmonyLib.HarmonyFinalizer : Attribute {
}
public class HarmonyLib.HarmonyMethod : object {
    
public MethodInfo method;
    
public string category;
    
public Type declaringType;
    
public string methodName;
    
public Nullable`1<MethodType> methodType;
    
public Type[] argumentTypes;
    
public int priority;
    
public String[] before;
    
public String[] after;
    
public Nullable`1<HarmonyReversePatchType> reversePatchType;
    
public Nullable`1<bool> debug;
    
public bool nonVirtualDelegate;
    public HarmonyMethod(MethodInfo method);
    public HarmonyMethod(Delegate delegate);
    public HarmonyMethod(MethodInfo method, int priority, String[] before, String[] after, Nullable`1<bool> debug);
    public HarmonyMethod(Delegate delegate, int priority, String[] before, String[] after, Nullable`1<bool> debug);
    public HarmonyMethod(Type methodType, string methodName, Type[] argumentTypes);
    private void ImportMethod(MethodInfo theMethod);
    public static List`1<string> HarmonyFields();
    public static HarmonyMethod Merge(List`1<HarmonyMethod> attributes);
    public virtual string ToString();
    internal string Description();
    public static HarmonyMethod op_Implicit(MethodInfo method);
    public static HarmonyMethod op_Implicit(Delegate delegate);
}
[ExtensionAttribute]
public static class HarmonyLib.HarmonyMethodExtensions : object {
    internal static void SetValue(Traverse trv, string name, object val);
    [ExtensionAttribute]
public static void CopyTo(HarmonyMethod from, HarmonyMethod to);
    [ExtensionAttribute]
public static HarmonyMethod Clone(HarmonyMethod original);
    [ExtensionAttribute]
public static HarmonyMethod Merge(HarmonyMethod master, HarmonyMethod detail);
    private static HarmonyMethod GetHarmonyMethodInfo(object attribute);
    public static List`1<HarmonyMethod> GetFromType(Type type);
    public static HarmonyMethod GetMergedFromType(Type type);
    public static List`1<HarmonyMethod> GetFromMethod(MethodBase method);
    public static HarmonyMethod GetMergedFromMethod(MethodBase method);
}
[AttributeUsageAttribute("4164")]
public class HarmonyLib.HarmonyPatch : HarmonyAttribute {
    public HarmonyPatch(Type declaringType);
    public HarmonyPatch(Type declaringType, Type[] argumentTypes);
    public HarmonyPatch(Type declaringType, string methodName);
    public HarmonyPatch(Type declaringType, string methodName, Type[] argumentTypes);
    public HarmonyPatch(Type declaringType, string methodName, Type[] argumentTypes, ArgumentType[] argumentVariations);
    public HarmonyPatch(Type declaringType, MethodType methodType);
    public HarmonyPatch(Type declaringType, MethodType methodType, Type[] argumentTypes);
    public HarmonyPatch(Type declaringType, MethodType methodType, Type[] argumentTypes, ArgumentType[] argumentVariations);
    public HarmonyPatch(Type declaringType, string methodName, MethodType methodType);
    public HarmonyPatch(string methodName);
    public HarmonyPatch(string methodName, Type[] argumentTypes);
    public HarmonyPatch(string methodName, Type[] argumentTypes, ArgumentType[] argumentVariations);
    public HarmonyPatch(string methodName, MethodType methodType);
    public HarmonyPatch(MethodType methodType);
    public HarmonyPatch(MethodType methodType, Type[] argumentTypes);
    public HarmonyPatch(MethodType methodType, Type[] argumentTypes, ArgumentType[] argumentVariations);
    public HarmonyPatch(Type[] argumentTypes);
    public HarmonyPatch(Type[] argumentTypes, ArgumentType[] argumentVariations);
    public HarmonyPatch(string typeName, string methodName, MethodType methodType);
    private void ParseSpecialArguments(Type[] argumentTypes, ArgumentType[] argumentVariations);
}
[AttributeUsageAttribute("4")]
public class HarmonyLib.HarmonyPatchAll : HarmonyAttribute {
}
[AttributeUsageAttribute("4")]
public class HarmonyLib.HarmonyPatchCategory : HarmonyAttribute {
    public HarmonyPatchCategory(string category);
}
public enum HarmonyLib.HarmonyPatchType : Enum {
    
public int value__;
    
public static HarmonyPatchType All;
    
public static HarmonyPatchType Prefix;
    
public static HarmonyPatchType Postfix;
    
public static HarmonyPatchType Transpiler;
    
public static HarmonyPatchType Finalizer;
    
public static HarmonyPatchType ReversePatch;
}
[AttributeUsageAttribute("64")]
public class HarmonyLib.HarmonyPostfix : Attribute {
}
[AttributeUsageAttribute("64")]
public class HarmonyLib.HarmonyPrefix : Attribute {
}
[AttributeUsageAttribute("64")]
public class HarmonyLib.HarmonyPrepare : Attribute {
}
[AttributeUsageAttribute("68")]
public class HarmonyLib.HarmonyPriority : HarmonyAttribute {
    public HarmonyPriority(int priority);
}
[AttributeUsageAttribute("68")]
public class HarmonyLib.HarmonyReversePatch : HarmonyAttribute {
    public HarmonyReversePatch(HarmonyReversePatchType type);
}
public enum HarmonyLib.HarmonyReversePatchType : Enum {
    
public int value__;
    
public static HarmonyReversePatchType Original;
    
public static HarmonyReversePatchType Snapshot;
}
internal static class HarmonyLib.HarmonySharedState : object {
    
private static string name;
    
internal static int internalVersion;
    
private static Dictionary`2<MethodBase, Byte[]> state;
    
private static Dictionary`2<MethodInfo, MethodBase> originals;
    
internal static int actualVersion;
    private static HarmonySharedState();
    private static Type GetOrCreateSharedStateType();
    internal static PatchInfo GetPatchInfo(MethodBase method);
    internal static IEnumerable`1<MethodBase> GetPatchedMethods();
    internal static void UpdatePatchInfo(MethodBase original, MethodInfo replacement, PatchInfo patchInfo);
    internal static MethodBase GetOriginal(MethodInfo replacement);
    internal static MethodBase FindReplacement(StackFrame frame);
}
[AttributeUsageAttribute("64")]
public class HarmonyLib.HarmonyTargetMethod : Attribute {
}
[AttributeUsageAttribute("64")]
public class HarmonyLib.HarmonyTargetMethods : Attribute {
}
[AttributeUsageAttribute("64")]
public class HarmonyLib.HarmonyTranspiler : Attribute {
}
internal class HarmonyLib.ILInstruction : object {
    
internal int offset;
    
internal OpCode opcode;
    
internal object operand;
    
internal object argument;
    
internal List`1<Label> labels;
    
internal List`1<ExceptionBlock> blocks;
    internal ILInstruction(OpCode opcode, object operand);
    internal CodeInstruction GetCodeInstruction();
    internal int GetSize();
    public virtual string ToString();
    private static void AppendLabel(String& str, object argument);
}
internal class HarmonyLib.InlineSignature : object {
    [CompilerGeneratedAttribute]

private bool <HasThis>k__BackingField;
    [CompilerGeneratedAttribute]

private bool <ExplicitThis>k__BackingField;
    [CompilerGeneratedAttribute]

private CallingConvention <CallingConvention>k__BackingField;
    [CompilerGeneratedAttribute]

private List`1<object> <Parameters>k__BackingField;
    [CompilerGeneratedAttribute]

private object <ReturnType>k__BackingField;
    
public bool HasThis { get; public set; }
    
public bool ExplicitThis { get; public set; }
    
public CallingConvention CallingConvention { get; public set; }
    
public List`1<object> Parameters { get; public set; }
    
public object ReturnType { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_HasThis();
    [CompilerGeneratedAttribute]
public void set_HasThis(bool value);
    [CompilerGeneratedAttribute]
public bool get_ExplicitThis();
    [CompilerGeneratedAttribute]
public void set_ExplicitThis(bool value);
    [CompilerGeneratedAttribute]
public CallingConvention get_CallingConvention();
    [CompilerGeneratedAttribute]
public void set_CallingConvention(CallingConvention value);
    [CompilerGeneratedAttribute]
public List`1<object> get_Parameters();
    [CompilerGeneratedAttribute]
public void set_Parameters(List`1<object> value);
    [CompilerGeneratedAttribute]
public object get_ReturnType();
    [CompilerGeneratedAttribute]
public void set_ReturnType(object value);
    public virtual string ToString();
    internal static TypeReference GetTypeReference(ModuleDefinition module, object param);
    private sealed virtual override CallSite MonoMod.Utils.ICallSiteGenerator.ToCallSite(ModuleDefinition module);
    private FunctionPointerType ToFunctionPointer(ModuleDefinition module);
}
internal static class HarmonyLib.InlineSignatureParser : object {
    internal static InlineSignature ImportCallSite(Module moduleFrom, Byte[] data);
}
public class HarmonyLib.InstantiationHandler`1 : MulticastDelegate {
    public InstantiationHandler`1(object object, IntPtr method);
    public virtual T Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual T EndInvoke(IAsyncResult result);
}
internal class HarmonyLib.LeaveTry : object {
    public virtual string ToString();
}
[ExtensionAttribute]
public static class HarmonyLib.MethodBaseExtensions : object {
    [ExtensionAttribute]
public static bool HasMethodBody(MethodBase member);
}
internal class HarmonyLib.MethodBodyReader : object {
    
private ILGenerator generator;
    
private MethodBase method;
    
private bool debug;
    
private Module module;
    
private Type[] typeArguments;
    
private Type[] methodArguments;
    
private ByteBuffer ilBytes;
    
private ParameterInfo this_parameter;
    
private ParameterInfo[] parameters;
    
private IList`1<ExceptionHandlingClause> exceptions;
    
private List`1<ILInstruction> ilInstructions;
    
private List`1<LocalVariableInfo> localVariables;
    
private LocalBuilder[] variables;
    
private static Dictionary`2<OpCode, OpCode> shortJumps;
    
private static OpCode[] one_byte_opcodes;
    
private static OpCode[] two_bytes_opcodes;
    internal MethodBodyReader(MethodBase method, ILGenerator generator);
    private static MethodBodyReader();
    internal static List`1<ILInstruction> GetInstructions(ILGenerator generator, MethodBase method);
    internal void SetDebugging(bool debug);
    internal void GenerateInstructions();
    internal void HandleNativeMethod();
    internal void DeclareVariables(LocalBuilder[] existingVariables);
    private void ResolveBranches();
    private void ParseExceptions();
    private bool EndsInDeadCode(List`1<CodeInstruction> list);
    internal List`1<CodeInstruction> FinalizeILCodes(Emitter emitter, List`1<MethodInfo> transpilers, List`1<Label> endLabels, Boolean& hasReturnCode, Boolean& methodEndsInDeadCode);
    private static void GetMemberInfoValue(MemberInfo info, Object& result);
    private void ReadOperand(ILInstruction instruction);
    private ILInstruction GetInstruction(int offset, bool isEndOfInstruction);
    private static bool TargetsLocalVariable(OpCode opcode);
    private LocalVariableInfo GetLocalVariable(int index);
    private ParameterInfo GetParameter(int index);
    private OpCode ReadOpCode();
    [CompilerGeneratedAttribute]
private LocalBuilder <DeclareVariables>b__18_0(LocalVariableInfo lvi);
}
internal class HarmonyLib.MethodCopier : object {
    
private MethodBodyReader reader;
    
private List`1<MethodInfo> transpilers;
    internal MethodCopier(MethodBase fromMethod, ILGenerator toILGenerator, LocalBuilder[] existingVariables);
    internal void SetDebugging(bool debug);
    internal void AddTranspiler(MethodInfo transpiler);
    internal List`1<CodeInstruction> Finalize(Emitter emitter, List`1<Label> endLabels, Boolean& hasReturnCode, Boolean& methodEndsInDeadCode);
    internal static List`1<CodeInstruction> GetInstructions(ILGenerator generator, MethodBase method, int maxTranspilers);
}
public enum HarmonyLib.MethodDispatchType : Enum {
    
public int value__;
    
public static MethodDispatchType VirtualCall;
    
public static MethodDispatchType Call;
}
public static class HarmonyLib.MethodInvoker : object {
    public static FastInvokeHandler GetHandler(MethodInfo methodInfo, bool directBoxValueAccess);
    internal static void Emit(ILGenerator il, OpCode opcode);
    internal static void Emit(ILGenerator il, OpCode opcode, Type type);
    internal static void EmitCall(ILGenerator il, OpCode opcode, MethodInfo methodInfo);
    private static void EmitUnboxIfNeeded(ILGenerator il, Type type);
    private static void EmitBoxIfNeeded(ILGenerator il, Type type);
    internal static void EmitFastInt(ILGenerator il, int value);
}
internal class HarmonyLib.MethodPatcher : object {
    
private static string INSTANCE_PARAM;
    
private static string ORIGINAL_METHOD_PARAM;
    
private static string ARGS_ARRAY_VAR;
    
private static string RESULT_VAR;
    
private static string RESULT_REF_VAR;
    
private static string STATE_VAR;
    
private static string EXCEPTION_VAR;
    
private static string RUN_ORIGINAL_VAR;
    
private static string PARAM_INDEX_PREFIX;
    
private static string INSTANCE_FIELD_PREFIX;
    
private bool debug;
    
private MethodBase original;
    
private MethodBase source;
    
private List`1<MethodInfo> prefixes;
    
private List`1<MethodInfo> postfixes;
    
private List`1<MethodInfo> transpilers;
    
private List`1<MethodInfo> finalizers;
    
private int idx;
    
private Type returnType;
    
private DynamicMethodDefinition patch;
    
private ILGenerator il;
    
private Emitter emitter;
    
private static MethodInfo m_GetMethodFromHandle1;
    
private static MethodInfo m_GetMethodFromHandle2;
    internal MethodPatcher(MethodBase original, MethodBase source, List`1<MethodInfo> prefixes, List`1<MethodInfo> postfixes, List`1<MethodInfo> transpilers, List`1<MethodInfo> finalizers, bool debug);
    private static MethodPatcher();
    internal MethodInfo CreateReplacement(Dictionary`2& finalInstructions);
    internal static DynamicMethodDefinition CreateDynamicMethod(MethodBase original, string suffix, bool debug);
    internal static LocalBuilder[] DeclareOriginalLocalVariables(ILGenerator il, MethodBase member);
    private LocalBuilder DeclareLocalVariable(Type type, bool isReturnValue);
    private static OpCode LoadIndOpCodeFor(Type type);
    private static OpCode StoreIndOpCodeFor(Type type);
    private void InitializeOutParameter(int argIndex, Type type);
    private bool EmitOriginalBaseMethod();
    private void EmitCallParameter(MethodInfo patch, Dictionary`2<string, LocalBuilder> variables, LocalBuilder runOriginalVariable, bool allowFirsParamPassthrough, LocalBuilder& tmpInstanceBoxingVar, LocalBuilder& tmpObjectVar, Boolean& refResultUsed, List`1<KeyValuePair`2<LocalBuilder, Type>> tmpBoxVars);
    private static bool PrefixAffectsOriginal(MethodInfo fix);
    private void AddPrefixes(Dictionary`2<string, LocalBuilder> variables, LocalBuilder runOriginalVariable);
    private bool AddPostfixes(Dictionary`2<string, LocalBuilder> variables, LocalBuilder runOriginalVariable, bool passthroughPatches);
    private bool AddFinalizers(Dictionary`2<string, LocalBuilder> variables, LocalBuilder runOriginalVariable, bool catchExceptions);
    private void PrepareArgumentArray();
    private void RestoreArgumentArray(Dictionary`2<string, LocalBuilder> variables);
}
public enum HarmonyLib.MethodType : Enum {
    
public int value__;
    
public static MethodType Normal;
    
public static MethodType Getter;
    
public static MethodType Setter;
    
public static MethodType Constructor;
    
public static MethodType StaticConstructor;
    
public static MethodType Enumerator;
    
public static MethodType Async;
}
public class HarmonyLib.Patch : object {
    
public int index;
    
public string owner;
    
public int priority;
    
public String[] before;
    
public String[] after;
    
public bool debug;
    
private MethodInfo patchMethod;
    
private int methodToken;
    
private string moduleGUID;
    
public MethodInfo PatchMethod { get; public set; }
    public Patch(MethodInfo patch, int index, string owner, int priority, String[] before, String[] after, bool debug);
    public Patch(HarmonyMethod method, int index, string owner);
    internal Patch(int index, string owner, int priority, String[] before, String[] after, bool debug, int methodToken, string moduleGUID);
    public MethodInfo get_PatchMethod();
    public void set_PatchMethod(MethodInfo value);
    public MethodInfo GetMethod(MethodBase original);
    public virtual bool Equals(object obj);
    public sealed virtual int CompareTo(object obj);
    public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
private bool <get_PatchMethod>b__10_2(Module m);
}
[ExtensionAttribute]
internal static class HarmonyLib.PatchArgumentExtensions : object {
    private static HarmonyArgument[] AllHarmonyArguments(Object[] attributes);
    [ExtensionAttribute]
private static HarmonyArgument GetArgumentAttribute(ParameterInfo parameter);
    [ExtensionAttribute]
private static HarmonyArgument[] GetArgumentAttributes(MethodInfo method);
    [ExtensionAttribute]
private static HarmonyArgument[] GetArgumentAttributes(Type type);
    [ExtensionAttribute]
private static string GetOriginalArgumentName(ParameterInfo parameter, String[] originalParameterNames);
    private static string GetOriginalArgumentName(HarmonyArgument[] attributes, string name, String[] originalParameterNames);
    [ExtensionAttribute]
private static string GetOriginalArgumentName(MethodInfo method, String[] originalParameterNames, string name);
    [ExtensionAttribute]
internal static int GetArgumentIndex(MethodInfo patch, String[] originalParameterNames, ParameterInfo patchParam);
}
public class HarmonyLib.PatchClassProcessor : object {
    
private Harmony instance;
    
private Type containerType;
    
private HarmonyMethod containerAttributes;
    
private Dictionary`2<Type, MethodInfo> auxilaryMethods;
    
private List`1<AttributePatch> patchMethods;
    
private static List`1<Type> auxilaryTypes;
    [CompilerGeneratedAttribute]

private string <Category>k__BackingField;
    
public string Category { get; public set; }
    public PatchClassProcessor(Harmony instance, Type type);
    private static PatchClassProcessor();
    [CompilerGeneratedAttribute]
public string get_Category();
    [CompilerGeneratedAttribute]
public void set_Category(string value);
    public List`1<MethodInfo> Patch();
    private void ReversePatch(MethodBase& lastOriginal);
    private List`1<MethodInfo> BulkPatch(List`1<MethodBase> originals, MethodBase& lastOriginal);
    private List`1<MethodInfo> PatchWithAttributes(MethodBase& lastOriginal);
    private void ProcessPatchJob(Job<MethodInfo> job);
    private List`1<MethodBase> GetBulkMethods();
    private void ReportException(Exception exception, MethodBase original);
    private T RunMethod(T defaultIfNotExisting, T defaultIfFailing, Func`2<T, string> failOnResult, Object[] parameters);
    private void RunMethod(Exception& exception, Object[] parameters);
}
public class HarmonyLib.Patches : object {
    
public ReadOnlyCollection`1<Patch> Prefixes;
    
public ReadOnlyCollection`1<Patch> Postfixes;
    
public ReadOnlyCollection`1<Patch> Transpilers;
    
public ReadOnlyCollection`1<Patch> Finalizers;
    
public ReadOnlyCollection`1<string> Owners { get; }
    public Patches(Patch[] prefixes, Patch[] postfixes, Patch[] transpilers, Patch[] finalizers);
    public ReadOnlyCollection`1<string> get_Owners();
}
internal static class HarmonyLib.PatchFunctions : object {
    internal static List`1<MethodInfo> GetSortedPatchMethods(MethodBase original, Patch[] patches, bool debug);
    internal static MethodInfo UpdateWrapper(MethodBase original, PatchInfo patchInfo);
    internal static MethodInfo ReversePatch(HarmonyMethod standin, MethodBase original, MethodInfo postTranspiler);
}
public class HarmonyLib.PatchInfo : object {
    
public Patch[] prefixes;
    
public Patch[] postfixes;
    
public Patch[] transpilers;
    
public Patch[] finalizers;
    
public bool Debugging { get; }
    public bool get_Debugging();
    internal void AddPrefixes(string owner, HarmonyMethod[] methods);
    [ObsoleteAttribute("This method only exists for backwards compatibility since the class is public.")]
public void AddPrefix(MethodInfo patch, string owner, int priority, String[] before, String[] after, bool debug);
    public void RemovePrefix(string owner);
    internal void AddPostfixes(string owner, HarmonyMethod[] methods);
    [ObsoleteAttribute("This method only exists for backwards compatibility since the class is public.")]
public void AddPostfix(MethodInfo patch, string owner, int priority, String[] before, String[] after, bool debug);
    public void RemovePostfix(string owner);
    internal void AddTranspilers(string owner, HarmonyMethod[] methods);
    [ObsoleteAttribute("This method only exists for backwards compatibility since the class is public.")]
public void AddTranspiler(MethodInfo patch, string owner, int priority, String[] before, String[] after, bool debug);
    public void RemoveTranspiler(string owner);
    internal void AddFinalizers(string owner, HarmonyMethod[] methods);
    [ObsoleteAttribute("This method only exists for backwards compatibility since the class is public.")]
public void AddFinalizer(MethodInfo patch, string owner, int priority, String[] before, String[] after, bool debug);
    public void RemoveFinalizer(string owner);
    public void RemovePatch(MethodInfo patch);
    private static Patch[] Add(string owner, HarmonyMethod[] add, Patch[] current);
    private static Patch[] Remove(string owner, Patch[] current);
}
[ExtensionAttribute]
internal static class HarmonyLib.PatchInfoSerialization : object {
    
internal static BinaryFormatter binaryFormatter;
    private static PatchInfoSerialization();
    [ExtensionAttribute]
internal static Byte[] Serialize(PatchInfo patchInfo);
    internal static PatchInfo Deserialize(Byte[] bytes);
    internal static int PriorityComparer(object obj, int index, int priority);
}
internal class HarmonyLib.PatchJobs`1 : object {
    
internal Dictionary`2<MethodBase, Job<T>> state;
    internal Job<T> GetJob(MethodBase method);
    internal List`1<Job<T>> GetJobs();
    internal List`1<T> GetReplacements();
}
public class HarmonyLib.PatchProcessor : object {
    
private Harmony instance;
    
private MethodBase original;
    
private HarmonyMethod prefix;
    
private HarmonyMethod postfix;
    
private HarmonyMethod transpiler;
    
private HarmonyMethod finalizer;
    
internal static object locker;
    public PatchProcessor(Harmony instance, MethodBase original);
    private static PatchProcessor();
    public PatchProcessor AddPrefix(HarmonyMethod prefix);
    public PatchProcessor AddPrefix(MethodInfo fixMethod);
    public PatchProcessor AddPostfix(HarmonyMethod postfix);
    public PatchProcessor AddPostfix(MethodInfo fixMethod);
    public PatchProcessor AddTranspiler(HarmonyMethod transpiler);
    public PatchProcessor AddTranspiler(MethodInfo fixMethod);
    public PatchProcessor AddFinalizer(HarmonyMethod finalizer);
    public PatchProcessor AddFinalizer(MethodInfo fixMethod);
    public static IEnumerable`1<MethodBase> GetAllPatchedMethods();
    public MethodInfo Patch();
    public PatchProcessor Unpatch(HarmonyPatchType type, string harmonyID);
    public PatchProcessor Unpatch(MethodInfo patch);
    public static Patches GetPatchInfo(MethodBase method);
    public static List`1<MethodInfo> GetSortedPatchMethods(MethodBase original, Patch[] patches);
    public static Dictionary`2<string, Version> VersionInfo(Version& currentVersion);
    public static ILGenerator CreateILGenerator();
    public static ILGenerator CreateILGenerator(MethodBase original);
    public static List`1<CodeInstruction> GetOriginalInstructions(MethodBase original, ILGenerator generator);
    public static List`1<CodeInstruction> GetOriginalInstructions(MethodBase original, ILGenerator& generator);
    public static List`1<CodeInstruction> GetCurrentInstructions(MethodBase original, int maxTranspilers, ILGenerator generator);
    public static List`1<CodeInstruction> GetCurrentInstructions(MethodBase original, ILGenerator& generator, int maxTranspilers);
    public static IEnumerable`1<KeyValuePair`2<OpCode, object>> ReadMethodBody(MethodBase method);
    public static IEnumerable`1<KeyValuePair`2<OpCode, object>> ReadMethodBody(MethodBase method, ILGenerator generator);
}
internal class HarmonyLib.PatchSorter : object {
    
private List`1<PatchSortingWrapper> patches;
    
private HashSet`1<PatchSortingWrapper> handledPatches;
    
private List`1<PatchSortingWrapper> result;
    
private List`1<PatchSortingWrapper> waitingList;
    
internal Patch[] sortedPatchArray;
    
private bool debug;
    internal PatchSorter(Patch[] patches, bool debug);
    internal List`1<MethodInfo> Sort(MethodBase original);
    internal bool ComparePatchLists(Patch[] patches);
    private void CullDependency();
    private void ProcessWaitingList();
    private void AddNodeToResult(PatchSortingWrapper node);
}
[ExtensionAttribute]
internal static class HarmonyLib.PatchTools : object {
    
private static Dictionary`2<MethodBase, ICoreDetour> detours;
    
internal static string harmonyMethodFullName;
    
internal static string harmonyAttributeFullName;
    
internal static string harmonyPatchAllFullName;
    
internal static MethodInfo m_GetExecutingAssemblyReplacementTranspiler;
    
internal static MethodInfo m_GetExecutingAssembly;
    
internal static MethodInfo m_GetExecutingAssemblyReplacement;
    private static PatchTools();
    internal static void DetourMethod(MethodBase method, MethodBase replacement);
    private static Assembly GetExecutingAssemblyReplacement();
    internal static IEnumerable`1<CodeInstruction> GetExecutingAssemblyTranspiler(IEnumerable`1<CodeInstruction> instructions);
    public static MethodInfo CreateMethod(string name, Type returnType, List`1<KeyValuePair`2<string, Type>> parameters, Action`1<ILGenerator> generator);
    internal static MethodInfo GetPatchMethod(Type patchType, string attributeName);
    internal static AssemblyBuilder DefineDynamicAssembly(string name);
    internal static List`1<AttributePatch> GetPatchMethods(Type type);
    [ExtensionAttribute]
internal static MethodBase GetOriginalMethod(HarmonyMethod attr);
}
public static class HarmonyLib.Priority : object {
    
public static int Last;
    
public static int VeryLow;
    
public static int Low;
    
public static int LowerThanNormal;
    
public static int Normal;
    
public static int HigherThanNormal;
    
public static int High;
    
public static int VeryHigh;
    
public static int First;
}
public class HarmonyLib.RefResult`1 : MulticastDelegate {
    public RefResult`1(object object, IntPtr method);
    public virtual T& Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual T& EndInvoke(IAsyncResult result);
}
public class HarmonyLib.ReversePatcher : object {
    
private Harmony instance;
    
private MethodBase original;
    
private HarmonyMethod standin;
    public ReversePatcher(Harmony instance, MethodBase original, HarmonyMethod standin);
    public MethodInfo Patch(HarmonyReversePatchType type);
    internal static MethodInfo GetTranspiler(MethodInfo method);
}
[ObsoleteAttribute("Use AccessTools.FieldRefAccess<T, S> for fields and AccessTools.MethodDelegate<Action<T, S>> for property setters")]
public class HarmonyLib.SetterHandler`2 : MulticastDelegate {
    public SetterHandler`2(object object, IntPtr method);
    public virtual void Invoke(T source, S value);
    public virtual IAsyncResult BeginInvoke(T source, S value, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public static class HarmonyLib.SymbolExtensions : object {
    public static MethodInfo GetMethodInfo(Expression`1<Action> expression);
    public static MethodInfo GetMethodInfo(Expression`1<Action`1<T>> expression);
    public static MethodInfo GetMethodInfo(Expression`1<Func`2<T, TResult>> expression);
    public static MethodInfo GetMethodInfo(LambdaExpression expression);
}
internal class HarmonyLib.Tools : object {
    
internal static bool isWindows;
    private static Tools();
    internal static TypeAndName TypColonName(string typeColonName);
    internal static void ValidateFieldType(FieldInfo fieldInfo);
    internal static FieldRef`2<T, F> FieldRefAccess(FieldInfo fieldInfo, bool needCastclass);
    internal static StructFieldRef`2<T, F> StructFieldRefAccess(FieldInfo fieldInfo);
    internal static FieldRef`1<F> StaticFieldRefAccess(FieldInfo fieldInfo);
    internal static FieldInfo GetInstanceField(Type type, string fieldName);
    internal static bool FieldRefNeedsClasscast(Type delegateInstanceType, Type declaringType);
    internal static void ValidateStructField(FieldInfo fieldInfo);
}
[ExtensionAttribute]
public static class HarmonyLib.Transpilers : object {
    [IteratorStateMachineAttribute("HarmonyLib.Transpilers/<MethodReplacer>d__0")]
[ExtensionAttribute]
public static IEnumerable`1<CodeInstruction> MethodReplacer(IEnumerable`1<CodeInstruction> instructions, MethodBase from, MethodBase to);
    [ExtensionAttribute]
public static IEnumerable`1<CodeInstruction> Manipulator(IEnumerable`1<CodeInstruction> instructions, Func`2<CodeInstruction, bool> predicate, Action`1<CodeInstruction> action);
    [IteratorStateMachineAttribute("HarmonyLib.Transpilers/<DebugLogger>d__2")]
[ExtensionAttribute]
public static IEnumerable`1<CodeInstruction> DebugLogger(IEnumerable`1<CodeInstruction> instructions, string text);
}
public class HarmonyLib.Traverse : object {
    
private static AccessCache Cache;
    
private Type _type;
    
private object _root;
    
private MemberInfo _info;
    
private MethodBase _method;
    
private Object[] _params;
    
public static Action`2<Traverse, Traverse> CopyFields;
    private static Traverse();
    public Traverse(Type type);
    public Traverse(object root);
    private Traverse(object root, MemberInfo info, Object[] index);
    private Traverse(object root, MethodInfo method, Object[] parameter);
    public static Traverse Create(Type type);
    public static Traverse Create();
    public static Traverse Create(object root);
    public static Traverse CreateWithType(string name);
    public object GetValue();
    public T GetValue();
    public object GetValue(Object[] arguments);
    public T GetValue(Object[] arguments);
    public Traverse SetValue(object value);
    public Type GetValueType();
    private Traverse Resolve();
    public Traverse Type(string name);
    public Traverse Field(string name);
    public Traverse`1<T> Field(string name);
    public List`1<string> Fields();
    public Traverse Property(string name, Object[] index);
    public Traverse`1<T> Property(string name, Object[] index);
    public List`1<string> Properties();
    public Traverse Method(string name, Object[] arguments);
    public Traverse Method(string name, Type[] paramTypes, Object[] arguments);
    public List`1<string> Methods();
    public bool FieldExists();
    public bool PropertyExists();
    public bool MethodExists();
    public bool TypeExists();
    public static void IterateFields(object source, Action`1<Traverse> action);
    public static void IterateFields(object source, object target, Action`2<Traverse, Traverse> action);
    public static void IterateFields(object source, object target, Action`3<string, Traverse, Traverse> action);
    public static void IterateProperties(object source, Action`1<Traverse> action);
    public static void IterateProperties(object source, object target, Action`2<Traverse, Traverse> action);
    public static void IterateProperties(object source, object target, Action`3<string, Traverse, Traverse> action);
    public virtual string ToString();
}
public class HarmonyLib.Traverse`1 : object {
    
private Traverse traverse;
    
public T Value { get; public set; }
    public Traverse`1(Traverse traverse);
    public T get_Value();
    public void set_Value(T value);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Iced.Intel.BlockEncoder : object {
    
private int bitness;
    
private BlockEncoderOptions options;
    
private Block[] blocks;
    
private Encoder nullEncoder;
    
private Dictionary`2<ulong, Instr> toInstr;
    
internal int Bitness { get; }
    
internal bool FixBranches { get; }
    
private bool ReturnRelocInfos { get; }
    
private bool ReturnNewInstructionOffsets { get; }
    
private bool ReturnConstantOffsets { get; }
    private BlockEncoder(int bitness, InstructionBlock[] instrBlocks, BlockEncoderOptions options);
    internal int get_Bitness();
    internal bool get_FixBranches();
    private bool get_ReturnRelocInfos();
    private bool get_ReturnNewInstructionOffsets();
    private bool get_ReturnConstantOffsets();
    public static bool TryEncode(int bitness, InstructionBlock block, String& errorMessage, BlockEncoderResult& result, BlockEncoderOptions options);
    public static bool TryEncode(int bitness, InstructionBlock[] blocks, String& errorMessage, BlockEncoderResult[]& result, BlockEncoderOptions options);
    private bool Encode(String& errorMessage, BlockEncoderResult[]& result);
    internal TargetInstr GetTarget(ulong address);
    internal UInt32 GetInstructionSize(Instruction& instruction, ulong ip);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Iced.Intel.BlockEncoderInternal.Block : object {
    
public CodeWriterImpl CodeWriter;
    
public ulong RIP;
    [NullableAttribute("2")]

public List`1<RelocInfo> relocInfos;
    
private Instr[] instructions;
    
private List`1<BlockData> dataList;
    
private ulong alignment;
    
private List`1<BlockData> validData;
    
private ulong validDataAddress;
    
private ulong validDataAddressAligned;
    
public Instr[] Instructions { get; }
    
public bool CanAddRelocInfos { get; }
    public Block(BlockEncoder blockEncoder, CodeWriter codeWriter, ulong rip, List`1<RelocInfo> relocInfos);
    public Instr[] get_Instructions();
    internal void SetInstructions(Instr[] instructions);
    public BlockData AllocPointerLocation();
    public void InitializeData();
    public void WriteData();
    public bool get_CanAddRelocInfos();
    public void AddRelocInfo(RelocInfo relocInfo);
}
internal class Iced.Intel.BlockEncoderInternal.BlockData : object {
    
internal ulong __dont_use_address;
    
internal bool __dont_use_address_initd;
    
public bool IsValid;
    
public ulong Data;
    
public ulong Address { get; }
    public ulong get_Address();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Iced.Intel.BlockEncoderInternal.CallInstr : Instr {
    
private byte bitness;
    
private Instruction instruction;
    
private TargetInstr targetInstr;
    
private byte origInstructionSize;
    
private BlockData pointerData;
    
private bool useOrigInstruction;
    public CallInstr(BlockEncoder blockEncoder, Block block, Instruction& instruction);
    public virtual void Initialize(BlockEncoder blockEncoder);
    public virtual bool Optimize(ulong gained);
    private bool TryOptimize(ulong gained);
    public virtual string TryEncode(Encoder encoder, ConstantOffsets& constantOffsets, Boolean& isOriginalInstruction);
}
internal class Iced.Intel.BlockEncoderInternal.CodeWriterImpl : CodeWriter {
    
public UInt32 BytesWritten;
    
private CodeWriter codeWriter;
    [NullableContextAttribute("1")]
public CodeWriterImpl(CodeWriter codeWriter);
    public virtual void WriteByte(byte value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Iced.Intel.BlockEncoderInternal.Instr : object {
    
public Block Block;
    
public UInt32 Size;
    
public ulong IP;
    
public ulong OrigIP;
    
public bool Done;
    
protected static UInt32 CallOrJmpPointerDataInstructionSize64;
    protected Instr(Block block, ulong origIp);
    public abstract virtual void Initialize(BlockEncoder blockEncoder);
    public abstract virtual bool Optimize(ulong gained);
    public abstract virtual string TryEncode(Encoder encoder, ConstantOffsets& constantOffsets, Boolean& isOriginalInstruction);
    protected static string CreateErrorMessage(string errorMessage, Instruction& instruction);
    public static Instr Create(BlockEncoder blockEncoder, Block block, Instruction& instruction);
    protected string EncodeBranchToPointerData(Encoder encoder, bool isCall, ulong ip, BlockData pointerData, UInt32& size, UInt32 minSize);
    protected static long CorrectDiff(bool inBlock, long diff, ulong gained);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Iced.Intel.BlockEncoderInternal.IpRelMemOpInstr : Instr {
    
private Instruction instruction;
    
private InstrKind instrKind;
    
private byte eipInstructionSize;
    
private byte ripInstructionSize;
    
private TargetInstr targetInstr;
    public IpRelMemOpInstr(BlockEncoder blockEncoder, Block block, Instruction& instruction);
    public virtual void Initialize(BlockEncoder blockEncoder);
    public virtual bool Optimize(ulong gained);
    private bool TryOptimize(ulong gained);
    public virtual string TryEncode(Encoder encoder, ConstantOffsets& constantOffsets, Boolean& isOriginalInstruction);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Iced.Intel.BlockEncoderInternal.JccInstr : Instr {
    
private Instruction instruction;
    
private TargetInstr targetInstr;
    
private BlockData pointerData;
    
private InstrKind instrKind;
    
private byte shortInstructionSize;
    
private byte nearInstructionSize;
    
private byte longInstructionSize64;
    public JccInstr(BlockEncoder blockEncoder, Block block, Instruction& instruction);
    private static UInt32 GetLongInstructionSize64(Instruction& instruction);
    public virtual void Initialize(BlockEncoder blockEncoder);
    public virtual bool Optimize(ulong gained);
    private bool TryOptimize(ulong gained);
    public virtual string TryEncode(Encoder encoder, ConstantOffsets& constantOffsets, Boolean& isOriginalInstruction);
    private static Code ShortBrToNativeBr(Code code, int bitness);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Iced.Intel.BlockEncoderInternal.JmpInstr : Instr {
    
private Instruction instruction;
    
private TargetInstr targetInstr;
    
private BlockData pointerData;
    
private InstrKind instrKind;
    
private byte shortInstructionSize;
    
private byte nearInstructionSize;
    public JmpInstr(BlockEncoder blockEncoder, Block block, Instruction& instruction);
    public virtual void Initialize(BlockEncoder blockEncoder);
    public virtual bool Optimize(ulong gained);
    private bool TryOptimize(ulong gained);
    public virtual string TryEncode(Encoder encoder, ConstantOffsets& constantOffsets, Boolean& isOriginalInstruction);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Iced.Intel.BlockEncoderInternal.SimpleBranchInstr : Instr {
    
private Instruction instruction;
    
private TargetInstr targetInstr;
    
private BlockData pointerData;
    
private InstrKind instrKind;
    
private byte shortInstructionSize;
    
private byte nearInstructionSize;
    
private byte longInstructionSize;
    
private byte nativeInstructionSize;
    
private Code nativeCode;
    public SimpleBranchInstr(BlockEncoder blockEncoder, Block block, Instruction& instruction);
    private static Code ToNativeBranchCode(Code code, int bitness);
    public virtual void Initialize(BlockEncoder blockEncoder);
    public virtual bool Optimize(ulong gained);
    private bool TryOptimize(ulong gained);
    public virtual string TryEncode(Encoder encoder, ConstantOffsets& constantOffsets, Boolean& isOriginalInstruction);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Iced.Intel.BlockEncoderInternal.SimpleInstr : Instr {
    
private Instruction instruction;
    public SimpleInstr(BlockEncoder blockEncoder, Block block, Instruction& instruction);
    public virtual void Initialize(BlockEncoder blockEncoder);
    public virtual bool Optimize(ulong gained);
    public virtual string TryEncode(Encoder encoder, ConstantOffsets& constantOffsets, Boolean& isOriginalInstruction);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Iced.Intel.BlockEncoderInternal.TargetInstr : ValueType {
    
private Instr instruction;
    
private ulong address;
    public TargetInstr(Instr instruction);
    public TargetInstr(ulong address);
    public bool IsInBlock(Block block);
    public ulong GetAddress();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Iced.Intel.BlockEncoderInternal.XbeginInstr : Instr {
    
private Instruction instruction;
    
private TargetInstr targetInstr;
    
private InstrKind instrKind;
    
private byte shortInstructionSize;
    
private byte nearInstructionSize;
    public XbeginInstr(BlockEncoder blockEncoder, Block block, Instruction& instruction);
    public virtual void Initialize(BlockEncoder blockEncoder);
    public virtual bool Optimize(ulong gained);
    private bool TryOptimize(ulong gained);
    public virtual string TryEncode(Encoder encoder, ConstantOffsets& constantOffsets, Boolean& isOriginalInstruction);
}
[FlagsAttribute]
internal enum Iced.Intel.BlockEncoderOptions : Enum {
    
public int value__;
    
public static BlockEncoderOptions None;
    
public static BlockEncoderOptions DontFixBranches;
    
public static BlockEncoderOptions ReturnRelocInfos;
    
public static BlockEncoderOptions ReturnNewInstructionOffsets;
    
public static BlockEncoderOptions ReturnConstantOffsets;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Iced.Intel.BlockEncoderResult : ValueType {
    
public ulong RIP;
    [NullableAttribute("2")]

public List`1<RelocInfo> RelocInfos;
    
public UInt32[] NewInstructionOffsets;
    
public ConstantOffsets[] ConstantOffsets;
    [NullableContextAttribute("2")]
internal BlockEncoderResult(ulong rip, List`1<RelocInfo> relocInfos, UInt32[] newInstructionOffsets, ConstantOffsets[] constantOffsets);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Iced.Intel.ByteArrayCodeReader : CodeReader {
    
private Byte[] data;
    
private int currentPosition;
    
private int startPosition;
    
private int endPosition;
    
public int Position { get; public set; }
    
public int Count { get; }
    
public bool CanReadByte { get; }
    public ByteArrayCodeReader(string hexData);
    public ByteArrayCodeReader(Byte[] data);
    public ByteArrayCodeReader(Byte[] data, int index, int count);
    [NullableContextAttribute("0")]
public ByteArrayCodeReader(ArraySegment`1<byte> data);
    public int get_Position();
    public void set_Position(int value);
    public int get_Count();
    public bool get_CanReadByte();
    public virtual int ReadByte();
}
internal enum Iced.Intel.Code : Enum {
    
public int value__;
    
public static Code INVALID;
    
public static Code DeclareByte;
    
public static Code DeclareWord;
    
public static Code DeclareDword;
    
public static Code DeclareQword;
    
public static Code Add_rm8_r8;
    
public static Code Add_rm16_r16;
    
public static Code Add_rm32_r32;
    
public static Code Add_rm64_r64;
    
public static Code Add_r8_rm8;
    
public static Code Add_r16_rm16;
    
public static Code Add_r32_rm32;
    
public static Code Add_r64_rm64;
    
public static Code Add_AL_imm8;
    
public static Code Add_AX_imm16;
    
public static Code Add_EAX_imm32;
    
public static Code Add_RAX_imm32;
    
public static Code Pushw_ES;
    
public static Code Pushd_ES;
    
public static Code Popw_ES;
    
public static Code Popd_ES;
    
public static Code Or_rm8_r8;
    
public static Code Or_rm16_r16;
    
public static Code Or_rm32_r32;
    
public static Code Or_rm64_r64;
    
public static Code Or_r8_rm8;
    
public static Code Or_r16_rm16;
    
public static Code Or_r32_rm32;
    
public static Code Or_r64_rm64;
    
public static Code Or_AL_imm8;
    
public static Code Or_AX_imm16;
    
public static Code Or_EAX_imm32;
    
public static Code Or_RAX_imm32;
    
public static Code Pushw_CS;
    
public static Code Pushd_CS;
    
public static Code Popw_CS;
    
public static Code Adc_rm8_r8;
    
public static Code Adc_rm16_r16;
    
public static Code Adc_rm32_r32;
    
public static Code Adc_rm64_r64;
    
public static Code Adc_r8_rm8;
    
public static Code Adc_r16_rm16;
    
public static Code Adc_r32_rm32;
    
public static Code Adc_r64_rm64;
    
public static Code Adc_AL_imm8;
    
public static Code Adc_AX_imm16;
    
public static Code Adc_EAX_imm32;
    
public static Code Adc_RAX_imm32;
    
public static Code Pushw_SS;
    
public static Code Pushd_SS;
    
public static Code Popw_SS;
    
public static Code Popd_SS;
    
public static Code Sbb_rm8_r8;
    
public static Code Sbb_rm16_r16;
    
public static Code Sbb_rm32_r32;
    
public static Code Sbb_rm64_r64;
    
public static Code Sbb_r8_rm8;
    
public static Code Sbb_r16_rm16;
    
public static Code Sbb_r32_rm32;
    
public static Code Sbb_r64_rm64;
    
public static Code Sbb_AL_imm8;
    
public static Code Sbb_AX_imm16;
    
public static Code Sbb_EAX_imm32;
    
public static Code Sbb_RAX_imm32;
    
public static Code Pushw_DS;
    
public static Code Pushd_DS;
    
public static Code Popw_DS;
    
public static Code Popd_DS;
    
public static Code And_rm8_r8;
    
public static Code And_rm16_r16;
    
public static Code And_rm32_r32;
    
public static Code And_rm64_r64;
    
public static Code And_r8_rm8;
    
public static Code And_r16_rm16;
    
public static Code And_r32_rm32;
    
public static Code And_r64_rm64;
    
public static Code And_AL_imm8;
    
public static Code And_AX_imm16;
    
public static Code And_EAX_imm32;
    
public static Code And_RAX_imm32;
    
public static Code Daa;
    
public static Code Sub_rm8_r8;
    
public static Code Sub_rm16_r16;
    
public static Code Sub_rm32_r32;
    
public static Code Sub_rm64_r64;
    
public static Code Sub_r8_rm8;
    
public static Code Sub_r16_rm16;
    
public static Code Sub_r32_rm32;
    
public static Code Sub_r64_rm64;
    
public static Code Sub_AL_imm8;
    
public static Code Sub_AX_imm16;
    
public static Code Sub_EAX_imm32;
    
public static Code Sub_RAX_imm32;
    
public static Code Das;
    
public static Code Xor_rm8_r8;
    
public static Code Xor_rm16_r16;
    
public static Code Xor_rm32_r32;
    
public static Code Xor_rm64_r64;
    
public static Code Xor_r8_rm8;
    
public static Code Xor_r16_rm16;
    
public static Code Xor_r32_rm32;
    
public static Code Xor_r64_rm64;
    
public static Code Xor_AL_imm8;
    
public static Code Xor_AX_imm16;
    
public static Code Xor_EAX_imm32;
    
public static Code Xor_RAX_imm32;
    
public static Code Aaa;
    
public static Code Cmp_rm8_r8;
    
public static Code Cmp_rm16_r16;
    
public static Code Cmp_rm32_r32;
    
public static Code Cmp_rm64_r64;
    
public static Code Cmp_r8_rm8;
    
public static Code Cmp_r16_rm16;
    
public static Code Cmp_r32_rm32;
    
public static Code Cmp_r64_rm64;
    
public static Code Cmp_AL_imm8;
    
public static Code Cmp_AX_imm16;
    
public static Code Cmp_EAX_imm32;
    
public static Code Cmp_RAX_imm32;
    
public static Code Aas;
    
public static Code Inc_r16;
    
public static Code Inc_r32;
    
public static Code Dec_r16;
    
public static Code Dec_r32;
    
public static Code Push_r16;
    
public static Code Push_r32;
    
public static Code Push_r64;
    
public static Code Pop_r16;
    
public static Code Pop_r32;
    
public static Code Pop_r64;
    
public static Code Pushaw;
    
public static Code Pushad;
    
public static Code Popaw;
    
public static Code Popad;
    
public static Code Bound_r16_m1616;
    
public static Code Bound_r32_m3232;
    
public static Code Arpl_rm16_r16;
    
public static Code Arpl_r32m16_r32;
    
public static Code Movsxd_r16_rm16;
    
public static Code Movsxd_r32_rm32;
    
public static Code Movsxd_r64_rm32;
    
public static Code Push_imm16;
    
public static Code Pushd_imm32;
    
public static Code Pushq_imm32;
    
public static Code Imul_r16_rm16_imm16;
    
public static Code Imul_r32_rm32_imm32;
    
public static Code Imul_r64_rm64_imm32;
    
public static Code Pushw_imm8;
    
public static Code Pushd_imm8;
    
public static Code Pushq_imm8;
    
public static Code Imul_r16_rm16_imm8;
    
public static Code Imul_r32_rm32_imm8;
    
public static Code Imul_r64_rm64_imm8;
    
public static Code Insb_m8_DX;
    
public static Code Insw_m16_DX;
    
public static Code Insd_m32_DX;
    
public static Code Outsb_DX_m8;
    
public static Code Outsw_DX_m16;
    
public static Code Outsd_DX_m32;
    
public static Code Jo_rel8_16;
    
public static Code Jo_rel8_32;
    
public static Code Jo_rel8_64;
    
public static Code Jno_rel8_16;
    
public static Code Jno_rel8_32;
    
public static Code Jno_rel8_64;
    
public static Code Jb_rel8_16;
    
public static Code Jb_rel8_32;
    
public static Code Jb_rel8_64;
    
public static Code Jae_rel8_16;
    
public static Code Jae_rel8_32;
    
public static Code Jae_rel8_64;
    
public static Code Je_rel8_16;
    
public static Code Je_rel8_32;
    
public static Code Je_rel8_64;
    
public static Code Jne_rel8_16;
    
public static Code Jne_rel8_32;
    
public static Code Jne_rel8_64;
    
public static Code Jbe_rel8_16;
    
public static Code Jbe_rel8_32;
    
public static Code Jbe_rel8_64;
    
public static Code Ja_rel8_16;
    
public static Code Ja_rel8_32;
    
public static Code Ja_rel8_64;
    
public static Code Js_rel8_16;
    
public static Code Js_rel8_32;
    
public static Code Js_rel8_64;
    
public static Code Jns_rel8_16;
    
public static Code Jns_rel8_32;
    
public static Code Jns_rel8_64;
    
public static Code Jp_rel8_16;
    
public static Code Jp_rel8_32;
    
public static Code Jp_rel8_64;
    
public static Code Jnp_rel8_16;
    
public static Code Jnp_rel8_32;
    
public static Code Jnp_rel8_64;
    
public static Code Jl_rel8_16;
    
public static Code Jl_rel8_32;
    
public static Code Jl_rel8_64;
    
public static Code Jge_rel8_16;
    
public static Code Jge_rel8_32;
    
public static Code Jge_rel8_64;
    
public static Code Jle_rel8_16;
    
public static Code Jle_rel8_32;
    
public static Code Jle_rel8_64;
    
public static Code Jg_rel8_16;
    
public static Code Jg_rel8_32;
    
public static Code Jg_rel8_64;
    
public static Code Add_rm8_imm8;
    
public static Code Or_rm8_imm8;
    
public static Code Adc_rm8_imm8;
    
public static Code Sbb_rm8_imm8;
    
public static Code And_rm8_imm8;
    
public static Code Sub_rm8_imm8;
    
public static Code Xor_rm8_imm8;
    
public static Code Cmp_rm8_imm8;
    
public static Code Add_rm16_imm16;
    
public static Code Add_rm32_imm32;
    
public static Code Add_rm64_imm32;
    
public static Code Or_rm16_imm16;
    
public static Code Or_rm32_imm32;
    
public static Code Or_rm64_imm32;
    
public static Code Adc_rm16_imm16;
    
public static Code Adc_rm32_imm32;
    
public static Code Adc_rm64_imm32;
    
public static Code Sbb_rm16_imm16;
    
public static Code Sbb_rm32_imm32;
    
public static Code Sbb_rm64_imm32;
    
public static Code And_rm16_imm16;
    
public static Code And_rm32_imm32;
    
public static Code And_rm64_imm32;
    
public static Code Sub_rm16_imm16;
    
public static Code Sub_rm32_imm32;
    
public static Code Sub_rm64_imm32;
    
public static Code Xor_rm16_imm16;
    
public static Code Xor_rm32_imm32;
    
public static Code Xor_rm64_imm32;
    
public static Code Cmp_rm16_imm16;
    
public static Code Cmp_rm32_imm32;
    
public static Code Cmp_rm64_imm32;
    
public static Code Add_rm8_imm8_82;
    
public static Code Or_rm8_imm8_82;
    
public static Code Adc_rm8_imm8_82;
    
public static Code Sbb_rm8_imm8_82;
    
public static Code And_rm8_imm8_82;
    
public static Code Sub_rm8_imm8_82;
    
public static Code Xor_rm8_imm8_82;
    
public static Code Cmp_rm8_imm8_82;
    
public static Code Add_rm16_imm8;
    
public static Code Add_rm32_imm8;
    
public static Code Add_rm64_imm8;
    
public static Code Or_rm16_imm8;
    
public static Code Or_rm32_imm8;
    
public static Code Or_rm64_imm8;
    
public static Code Adc_rm16_imm8;
    
public static Code Adc_rm32_imm8;
    
public static Code Adc_rm64_imm8;
    
public static Code Sbb_rm16_imm8;
    
public static Code Sbb_rm32_imm8;
    
public static Code Sbb_rm64_imm8;
    
public static Code And_rm16_imm8;
    
public static Code And_rm32_imm8;
    
public static Code And_rm64_imm8;
    
public static Code Sub_rm16_imm8;
    
public static Code Sub_rm32_imm8;
    
public static Code Sub_rm64_imm8;
    
public static Code Xor_rm16_imm8;
    
public static Code Xor_rm32_imm8;
    
public static Code Xor_rm64_imm8;
    
public static Code Cmp_rm16_imm8;
    
public static Code Cmp_rm32_imm8;
    
public static Code Cmp_rm64_imm8;
    
public static Code Test_rm8_r8;
    
public static Code Test_rm16_r16;
    
public static Code Test_rm32_r32;
    
public static Code Test_rm64_r64;
    
public static Code Xchg_rm8_r8;
    
public static Code Xchg_rm16_r16;
    
public static Code Xchg_rm32_r32;
    
public static Code Xchg_rm64_r64;
    
public static Code Mov_rm8_r8;
    
public static Code Mov_rm16_r16;
    
public static Code Mov_rm32_r32;
    
public static Code Mov_rm64_r64;
    
public static Code Mov_r8_rm8;
    
public static Code Mov_r16_rm16;
    
public static Code Mov_r32_rm32;
    
public static Code Mov_r64_rm64;
    
public static Code Mov_rm16_Sreg;
    
public static Code Mov_r32m16_Sreg;
    
public static Code Mov_r64m16_Sreg;
    
public static Code Lea_r16_m;
    
public static Code Lea_r32_m;
    
public static Code Lea_r64_m;
    
public static Code Mov_Sreg_rm16;
    
public static Code Mov_Sreg_r32m16;
    
public static Code Mov_Sreg_r64m16;
    
public static Code Pop_rm16;
    
public static Code Pop_rm32;
    
public static Code Pop_rm64;
    
public static Code Nopw;
    
public static Code Nopd;
    
public static Code Nopq;
    
public static Code Xchg_r16_AX;
    
public static Code Xchg_r32_EAX;
    
public static Code Xchg_r64_RAX;
    
public static Code Pause;
    
public static Code Cbw;
    
public static Code Cwde;
    
public static Code Cdqe;
    
public static Code Cwd;
    
public static Code Cdq;
    
public static Code Cqo;
    
public static Code Call_ptr1616;
    
public static Code Call_ptr1632;
    
public static Code Wait;
    
public static Code Pushfw;
    
public static Code Pushfd;
    
public static Code Pushfq;
    
public static Code Popfw;
    
public static Code Popfd;
    
public static Code Popfq;
    
public static Code Sahf;
    
public static Code Lahf;
    
public static Code Mov_AL_moffs8;
    
public static Code Mov_AX_moffs16;
    
public static Code Mov_EAX_moffs32;
    
public static Code Mov_RAX_moffs64;
    
public static Code Mov_moffs8_AL;
    
public static Code Mov_moffs16_AX;
    
public static Code Mov_moffs32_EAX;
    
public static Code Mov_moffs64_RAX;
    
public static Code Movsb_m8_m8;
    
public static Code Movsw_m16_m16;
    
public static Code Movsd_m32_m32;
    
public static Code Movsq_m64_m64;
    
public static Code Cmpsb_m8_m8;
    
public static Code Cmpsw_m16_m16;
    
public static Code Cmpsd_m32_m32;
    
public static Code Cmpsq_m64_m64;
    
public static Code Test_AL_imm8;
    
public static Code Test_AX_imm16;
    
public static Code Test_EAX_imm32;
    
public static Code Test_RAX_imm32;
    
public static Code Stosb_m8_AL;
    
public static Code Stosw_m16_AX;
    
public static Code Stosd_m32_EAX;
    
public static Code Stosq_m64_RAX;
    
public static Code Lodsb_AL_m8;
    
public static Code Lodsw_AX_m16;
    
public static Code Lodsd_EAX_m32;
    
public static Code Lodsq_RAX_m64;
    
public static Code Scasb_AL_m8;
    
public static Code Scasw_AX_m16;
    
public static Code Scasd_EAX_m32;
    
public static Code Scasq_RAX_m64;
    
public static Code Mov_r8_imm8;
    
public static Code Mov_r16_imm16;
    
public static Code Mov_r32_imm32;
    
public static Code Mov_r64_imm64;
    
public static Code Rol_rm8_imm8;
    
public static Code Ror_rm8_imm8;
    
public static Code Rcl_rm8_imm8;
    
public static Code Rcr_rm8_imm8;
    
public static Code Shl_rm8_imm8;
    
public static Code Shr_rm8_imm8;
    
public static Code Sal_rm8_imm8;
    
public static Code Sar_rm8_imm8;
    
public static Code Rol_rm16_imm8;
    
public static Code Rol_rm32_imm8;
    
public static Code Rol_rm64_imm8;
    
public static Code Ror_rm16_imm8;
    
public static Code Ror_rm32_imm8;
    
public static Code Ror_rm64_imm8;
    
public static Code Rcl_rm16_imm8;
    
public static Code Rcl_rm32_imm8;
    
public static Code Rcl_rm64_imm8;
    
public static Code Rcr_rm16_imm8;
    
public static Code Rcr_rm32_imm8;
    
public static Code Rcr_rm64_imm8;
    
public static Code Shl_rm16_imm8;
    
public static Code Shl_rm32_imm8;
    
public static Code Shl_rm64_imm8;
    
public static Code Shr_rm16_imm8;
    
public static Code Shr_rm32_imm8;
    
public static Code Shr_rm64_imm8;
    
public static Code Sal_rm16_imm8;
    
public static Code Sal_rm32_imm8;
    
public static Code Sal_rm64_imm8;
    
public static Code Sar_rm16_imm8;
    
public static Code Sar_rm32_imm8;
    
public static Code Sar_rm64_imm8;
    
public static Code Retnw_imm16;
    
public static Code Retnd_imm16;
    
public static Code Retnq_imm16;
    
public static Code Retnw;
    
public static Code Retnd;
    
public static Code Retnq;
    
public static Code Les_r16_m1616;
    
public static Code Les_r32_m1632;
    
public static Code Lds_r16_m1616;
    
public static Code Lds_r32_m1632;
    
public static Code Mov_rm8_imm8;
    
public static Code Xabort_imm8;
    
public static Code Mov_rm16_imm16;
    
public static Code Mov_rm32_imm32;
    
public static Code Mov_rm64_imm32;
    
public static Code Xbegin_rel16;
    
public static Code Xbegin_rel32;
    
public static Code Enterw_imm16_imm8;
    
public static Code Enterd_imm16_imm8;
    
public static Code Enterq_imm16_imm8;
    
public static Code Leavew;
    
public static Code Leaved;
    
public static Code Leaveq;
    
public static Code Retfw_imm16;
    
public static Code Retfd_imm16;
    
public static Code Retfq_imm16;
    
public static Code Retfw;
    
public static Code Retfd;
    
public static Code Retfq;
    
public static Code Int3;
    
public static Code Int_imm8;
    
public static Code Into;
    
public static Code Iretw;
    
public static Code Iretd;
    
public static Code Iretq;
    
public static Code Rol_rm8_1;
    
public static Code Ror_rm8_1;
    
public static Code Rcl_rm8_1;
    
public static Code Rcr_rm8_1;
    
public static Code Shl_rm8_1;
    
public static Code Shr_rm8_1;
    
public static Code Sal_rm8_1;
    
public static Code Sar_rm8_1;
    
public static Code Rol_rm16_1;
    
public static Code Rol_rm32_1;
    
public static Code Rol_rm64_1;
    
public static Code Ror_rm16_1;
    
public static Code Ror_rm32_1;
    
public static Code Ror_rm64_1;
    
public static Code Rcl_rm16_1;
    
public static Code Rcl_rm32_1;
    
public static Code Rcl_rm64_1;
    
public static Code Rcr_rm16_1;
    
public static Code Rcr_rm32_1;
    
public static Code Rcr_rm64_1;
    
public static Code Shl_rm16_1;
    
public static Code Shl_rm32_1;
    
public static Code Shl_rm64_1;
    
public static Code Shr_rm16_1;
    
public static Code Shr_rm32_1;
    
public static Code Shr_rm64_1;
    
public static Code Sal_rm16_1;
    
public static Code Sal_rm32_1;
    
public static Code Sal_rm64_1;
    
public static Code Sar_rm16_1;
    
public static Code Sar_rm32_1;
    
public static Code Sar_rm64_1;
    
public static Code Rol_rm8_CL;
    
public static Code Ror_rm8_CL;
    
public static Code Rcl_rm8_CL;
    
public static Code Rcr_rm8_CL;
    
public static Code Shl_rm8_CL;
    
public static Code Shr_rm8_CL;
    
public static Code Sal_rm8_CL;
    
public static Code Sar_rm8_CL;
    
public static Code Rol_rm16_CL;
    
public static Code Rol_rm32_CL;
    
public static Code Rol_rm64_CL;
    
public static Code Ror_rm16_CL;
    
public static Code Ror_rm32_CL;
    
public static Code Ror_rm64_CL;
    
public static Code Rcl_rm16_CL;
    
public static Code Rcl_rm32_CL;
    
public static Code Rcl_rm64_CL;
    
public static Code Rcr_rm16_CL;
    
public static Code Rcr_rm32_CL;
    
public static Code Rcr_rm64_CL;
    
public static Code Shl_rm16_CL;
    
public static Code Shl_rm32_CL;
    
public static Code Shl_rm64_CL;
    
public static Code Shr_rm16_CL;
    
public static Code Shr_rm32_CL;
    
public static Code Shr_rm64_CL;
    
public static Code Sal_rm16_CL;
    
public static Code Sal_rm32_CL;
    
public static Code Sal_rm64_CL;
    
public static Code Sar_rm16_CL;
    
public static Code Sar_rm32_CL;
    
public static Code Sar_rm64_CL;
    
public static Code Aam_imm8;
    
public static Code Aad_imm8;
    
public static Code Salc;
    
public static Code Xlat_m8;
    
public static Code Fadd_m32fp;
    
public static Code Fmul_m32fp;
    
public static Code Fcom_m32fp;
    
public static Code Fcomp_m32fp;
    
public static Code Fsub_m32fp;
    
public static Code Fsubr_m32fp;
    
public static Code Fdiv_m32fp;
    
public static Code Fdivr_m32fp;
    
public static Code Fadd_st0_sti;
    
public static Code Fmul_st0_sti;
    
public static Code Fcom_st0_sti;
    
public static Code Fcomp_st0_sti;
    
public static Code Fsub_st0_sti;
    
public static Code Fsubr_st0_sti;
    
public static Code Fdiv_st0_sti;
    
public static Code Fdivr_st0_sti;
    
public static Code Fld_m32fp;
    
public static Code Fst_m32fp;
    
public static Code Fstp_m32fp;
    
public static Code Fldenv_m14byte;
    
public static Code Fldenv_m28byte;
    
public static Code Fldcw_m2byte;
    
public static Code Fnstenv_m14byte;
    
public static Code Fstenv_m14byte;
    
public static Code Fnstenv_m28byte;
    
public static Code Fstenv_m28byte;
    
public static Code Fnstcw_m2byte;
    
public static Code Fstcw_m2byte;
    
public static Code Fld_sti;
    
public static Code Fxch_st0_sti;
    
public static Code Fnop;
    
public static Code Fstpnce_sti;
    
public static Code Fchs;
    
public static Code Fabs;
    
public static Code Ftst;
    
public static Code Fxam;
    
public static Code Fld1;
    
public static Code Fldl2t;
    
public static Code Fldl2e;
    
public static Code Fldpi;
    
public static Code Fldlg2;
    
public static Code Fldln2;
    
public static Code Fldz;
    
public static Code F2xm1;
    
public static Code Fyl2x;
    
public static Code Fptan;
    
public static Code Fpatan;
    
public static Code Fxtract;
    
public static Code Fprem1;
    
public static Code Fdecstp;
    
public static Code Fincstp;
    
public static Code Fprem;
    
public static Code Fyl2xp1;
    
public static Code Fsqrt;
    
public static Code Fsincos;
    
public static Code Frndint;
    
public static Code Fscale;
    
public static Code Fsin;
    
public static Code Fcos;
    
public static Code Fiadd_m32int;
    
public static Code Fimul_m32int;
    
public static Code Ficom_m32int;
    
public static Code Ficomp_m32int;
    
public static Code Fisub_m32int;
    
public static Code Fisubr_m32int;
    
public static Code Fidiv_m32int;
    
public static Code Fidivr_m32int;
    
public static Code Fcmovb_st0_sti;
    
public static Code Fcmove_st0_sti;
    
public static Code Fcmovbe_st0_sti;
    
public static Code Fcmovu_st0_sti;
    
public static Code Fucompp;
    
public static Code Fild_m32int;
    
public static Code Fisttp_m32int;
    
public static Code Fist_m32int;
    
public static Code Fistp_m32int;
    
public static Code Fld_m80fp;
    
public static Code Fstp_m80fp;
    
public static Code Fcmovnb_st0_sti;
    
public static Code Fcmovne_st0_sti;
    
public static Code Fcmovnbe_st0_sti;
    
public static Code Fcmovnu_st0_sti;
    
public static Code Fneni;
    
public static Code Feni;
    
public static Code Fndisi;
    
public static Code Fdisi;
    
public static Code Fnclex;
    
public static Code Fclex;
    
public static Code Fninit;
    
public static Code Finit;
    
public static Code Fnsetpm;
    
public static Code Fsetpm;
    
public static Code Frstpm;
    
public static Code Fucomi_st0_sti;
    
public static Code Fcomi_st0_sti;
    
public static Code Fadd_m64fp;
    
public static Code Fmul_m64fp;
    
public static Code Fcom_m64fp;
    
public static Code Fcomp_m64fp;
    
public static Code Fsub_m64fp;
    
public static Code Fsubr_m64fp;
    
public static Code Fdiv_m64fp;
    
public static Code Fdivr_m64fp;
    
public static Code Fadd_sti_st0;
    
public static Code Fmul_sti_st0;
    
public static Code Fcom_st0_sti_DCD0;
    
public static Code Fcomp_st0_sti_DCD8;
    
public static Code Fsubr_sti_st0;
    
public static Code Fsub_sti_st0;
    
public static Code Fdivr_sti_st0;
    
public static Code Fdiv_sti_st0;
    
public static Code Fld_m64fp;
    
public static Code Fisttp_m64int;
    
public static Code Fst_m64fp;
    
public static Code Fstp_m64fp;
    
public static Code Frstor_m94byte;
    
public static Code Frstor_m108byte;
    
public static Code Fnsave_m94byte;
    
public static Code Fsave_m94byte;
    
public static Code Fnsave_m108byte;
    
public static Code Fsave_m108byte;
    
public static Code Fnstsw_m2byte;
    
public static Code Fstsw_m2byte;
    
public static Code Ffree_sti;
    
public static Code Fxch_st0_sti_DDC8;
    
public static Code Fst_sti;
    
public static Code Fstp_sti;
    
public static Code Fucom_st0_sti;
    
public static Code Fucomp_st0_sti;
    
public static Code Fiadd_m16int;
    
public static Code Fimul_m16int;
    
public static Code Ficom_m16int;
    
public static Code Ficomp_m16int;
    
public static Code Fisub_m16int;
    
public static Code Fisubr_m16int;
    
public static Code Fidiv_m16int;
    
public static Code Fidivr_m16int;
    
public static Code Faddp_sti_st0;
    
public static Code Fmulp_sti_st0;
    
public static Code Fcomp_st0_sti_DED0;
    
public static Code Fcompp;
    
public static Code Fsubrp_sti_st0;
    
public static Code Fsubp_sti_st0;
    
public static Code Fdivrp_sti_st0;
    
public static Code Fdivp_sti_st0;
    
public static Code Fild_m16int;
    
public static Code Fisttp_m16int;
    
public static Code Fist_m16int;
    
public static Code Fistp_m16int;
    
public static Code Fbld_m80bcd;
    
public static Code Fild_m64int;
    
public static Code Fbstp_m80bcd;
    
public static Code Fistp_m64int;
    
public static Code Ffreep_sti;
    
public static Code Fxch_st0_sti_DFC8;
    
public static Code Fstp_sti_DFD0;
    
public static Code Fstp_sti_DFD8;
    
public static Code Fnstsw_AX;
    
public static Code Fstsw_AX;
    
public static Code Fstdw_AX;
    
public static Code Fstsg_AX;
    
public static Code Fucomip_st0_sti;
    
public static Code Fcomip_st0_sti;
    
public static Code Loopne_rel8_16_CX;
    
public static Code Loopne_rel8_32_CX;
    
public static Code Loopne_rel8_16_ECX;
    
public static Code Loopne_rel8_32_ECX;
    
public static Code Loopne_rel8_64_ECX;
    
public static Code Loopne_rel8_16_RCX;
    
public static Code Loopne_rel8_64_RCX;
    
public static Code Loope_rel8_16_CX;
    
public static Code Loope_rel8_32_CX;
    
public static Code Loope_rel8_16_ECX;
    
public static Code Loope_rel8_32_ECX;
    
public static Code Loope_rel8_64_ECX;
    
public static Code Loope_rel8_16_RCX;
    
public static Code Loope_rel8_64_RCX;
    
public static Code Loop_rel8_16_CX;
    
public static Code Loop_rel8_32_CX;
    
public static Code Loop_rel8_16_ECX;
    
public static Code Loop_rel8_32_ECX;
    
public static Code Loop_rel8_64_ECX;
    
public static Code Loop_rel8_16_RCX;
    
public static Code Loop_rel8_64_RCX;
    
public static Code Jcxz_rel8_16;
    
public static Code Jcxz_rel8_32;
    
public static Code Jecxz_rel8_16;
    
public static Code Jecxz_rel8_32;
    
public static Code Jecxz_rel8_64;
    
public static Code Jrcxz_rel8_16;
    
public static Code Jrcxz_rel8_64;
    
public static Code In_AL_imm8;
    
public static Code In_AX_imm8;
    
public static Code In_EAX_imm8;
    
public static Code Out_imm8_AL;
    
public static Code Out_imm8_AX;
    
public static Code Out_imm8_EAX;
    
public static Code Call_rel16;
    
public static Code Call_rel32_32;
    
public static Code Call_rel32_64;
    
public static Code Jmp_rel16;
    
public static Code Jmp_rel32_32;
    
public static Code Jmp_rel32_64;
    
public static Code Jmp_ptr1616;
    
public static Code Jmp_ptr1632;
    
public static Code Jmp_rel8_16;
    
public static Code Jmp_rel8_32;
    
public static Code Jmp_rel8_64;
    
public static Code In_AL_DX;
    
public static Code In_AX_DX;
    
public static Code In_EAX_DX;
    
public static Code Out_DX_AL;
    
public static Code Out_DX_AX;
    
public static Code Out_DX_EAX;
    
public static Code Int1;
    
public static Code Hlt;
    
public static Code Cmc;
    
public static Code Test_rm8_imm8;
    
public static Code Test_rm8_imm8_F6r1;
    
public static Code Not_rm8;
    
public static Code Neg_rm8;
    
public static Code Mul_rm8;
    
public static Code Imul_rm8;
    
public static Code Div_rm8;
    
public static Code Idiv_rm8;
    
public static Code Test_rm16_imm16;
    
public static Code Test_rm32_imm32;
    
public static Code Test_rm64_imm32;
    
public static Code Test_rm16_imm16_F7r1;
    
public static Code Test_rm32_imm32_F7r1;
    
public static Code Test_rm64_imm32_F7r1;
    
public static Code Not_rm16;
    
public static Code Not_rm32;
    
public static Code Not_rm64;
    
public static Code Neg_rm16;
    
public static Code Neg_rm32;
    
public static Code Neg_rm64;
    
public static Code Mul_rm16;
    
public static Code Mul_rm32;
    
public static Code Mul_rm64;
    
public static Code Imul_rm16;
    
public static Code Imul_rm32;
    
public static Code Imul_rm64;
    
public static Code Div_rm16;
    
public static Code Div_rm32;
    
public static Code Div_rm64;
    
public static Code Idiv_rm16;
    
public static Code Idiv_rm32;
    
public static Code Idiv_rm64;
    
public static Code Clc;
    
public static Code Stc;
    
public static Code Cli;
    
public static Code Sti;
    
public static Code Cld;
    
public static Code Std;
    
public static Code Inc_rm8;
    
public static Code Dec_rm8;
    
public static Code Inc_rm16;
    
public static Code Inc_rm32;
    
public static Code Inc_rm64;
    
public static Code Dec_rm16;
    
public static Code Dec_rm32;
    
public static Code Dec_rm64;
    
public static Code Call_rm16;
    
public static Code Call_rm32;
    
public static Code Call_rm64;
    
public static Code Call_m1616;
    
public static Code Call_m1632;
    
public static Code Call_m1664;
    
public static Code Jmp_rm16;
    
public static Code Jmp_rm32;
    
public static Code Jmp_rm64;
    
public static Code Jmp_m1616;
    
public static Code Jmp_m1632;
    
public static Code Jmp_m1664;
    
public static Code Push_rm16;
    
public static Code Push_rm32;
    
public static Code Push_rm64;
    
public static Code Sldt_rm16;
    
public static Code Sldt_r32m16;
    
public static Code Sldt_r64m16;
    
public static Code Str_rm16;
    
public static Code Str_r32m16;
    
public static Code Str_r64m16;
    
public static Code Lldt_rm16;
    
public static Code Lldt_r32m16;
    
public static Code Lldt_r64m16;
    
public static Code Ltr_rm16;
    
public static Code Ltr_r32m16;
    
public static Code Ltr_r64m16;
    
public static Code Verr_rm16;
    
public static Code Verr_r32m16;
    
public static Code Verr_r64m16;
    
public static Code Verw_rm16;
    
public static Code Verw_r32m16;
    
public static Code Verw_r64m16;
    
public static Code Jmpe_rm16;
    
public static Code Jmpe_rm32;
    
public static Code Sgdt_m1632_16;
    
public static Code Sgdt_m1632;
    
public static Code Sgdt_m1664;
    
public static Code Sidt_m1632_16;
    
public static Code Sidt_m1632;
    
public static Code Sidt_m1664;
    
public static Code Lgdt_m1632_16;
    
public static Code Lgdt_m1632;
    
public static Code Lgdt_m1664;
    
public static Code Lidt_m1632_16;
    
public static Code Lidt_m1632;
    
public static Code Lidt_m1664;
    
public static Code Smsw_rm16;
    
public static Code Smsw_r32m16;
    
public static Code Smsw_r64m16;
    
public static Code Rstorssp_m64;
    
public static Code Lmsw_rm16;
    
public static Code Lmsw_r32m16;
    
public static Code Lmsw_r64m16;
    
public static Code Invlpg_m;
    
public static Code Enclv;
    
public static Code Vmcall;
    
public static Code Vmlaunch;
    
public static Code Vmresume;
    
public static Code Vmxoff;
    
public static Code Pconfig;
    
public static Code Monitorw;
    
public static Code Monitord;
    
public static Code Monitorq;
    
public static Code Mwait;
    
public static Code Clac;
    
public static Code Stac;
    
public static Code Encls;
    
public static Code Xgetbv;
    
public static Code Xsetbv;
    
public static Code Vmfunc;
    
public static Code Xend;
    
public static Code Xtest;
    
public static Code Enclu;
    
public static Code Vmrunw;
    
public static Code Vmrund;
    
public static Code Vmrunq;
    
public static Code Vmmcall;
    
public static Code Vmloadw;
    
public static Code Vmloadd;
    
public static Code Vmloadq;
    
public static Code Vmsavew;
    
public static Code Vmsaved;
    
public static Code Vmsaveq;
    
public static Code Stgi;
    
public static Code Clgi;
    
public static Code Skinit;
    
public static Code Invlpgaw;
    
public static Code Invlpgad;
    
public static Code Invlpgaq;
    
public static Code Setssbsy;
    
public static Code Saveprevssp;
    
public static Code Rdpkru;
    
public static Code Wrpkru;
    
public static Code Swapgs;
    
public static Code Rdtscp;
    
public static Code Monitorxw;
    
public static Code Monitorxd;
    
public static Code Monitorxq;
    
public static Code Mcommit;
    
public static Code Mwaitx;
    
public static Code Clzerow;
    
public static Code Clzerod;
    
public static Code Clzeroq;
    
public static Code Rdpru;
    
public static Code Lar_r16_rm16;
    
public static Code Lar_r32_r32m16;
    
public static Code Lar_r64_r64m16;
    
public static Code Lsl_r16_rm16;
    
public static Code Lsl_r32_r32m16;
    
public static Code Lsl_r64_r64m16;
    
public static Code Storeall;
    
public static Code Loadall286;
    
public static Code Syscall;
    
public static Code Clts;
    
public static Code Loadall386;
    
public static Code Sysretd;
    
public static Code Sysretq;
    
public static Code Invd;
    
public static Code Wbinvd;
    
public static Code Wbnoinvd;
    
public static Code Cl1invmb;
    
public static Code Ud2;
    
public static Code Reservednop_rm16_r16_0F0D;
    
public static Code Reservednop_rm32_r32_0F0D;
    
public static Code Reservednop_rm64_r64_0F0D;
    
public static Code Prefetch_m8;
    
public static Code Prefetchw_m8;
    
public static Code Prefetchwt1_m8;
    
public static Code Femms;
    
public static Code Umov_rm8_r8;
    
public static Code Umov_rm16_r16;
    
public static Code Umov_rm32_r32;
    
public static Code Umov_r8_rm8;
    
public static Code Umov_r16_rm16;
    
public static Code Umov_r32_rm32;
    
public static Code Movups_xmm_xmmm128;
    
public static Code VEX_Vmovups_xmm_xmmm128;
    
public static Code VEX_Vmovups_ymm_ymmm256;
    
public static Code EVEX_Vmovups_xmm_k1z_xmmm128;
    
public static Code EVEX_Vmovups_ymm_k1z_ymmm256;
    
public static Code EVEX_Vmovups_zmm_k1z_zmmm512;
    
public static Code Movupd_xmm_xmmm128;
    
public static Code VEX_Vmovupd_xmm_xmmm128;
    
public static Code VEX_Vmovupd_ymm_ymmm256;
    
public static Code EVEX_Vmovupd_xmm_k1z_xmmm128;
    
public static Code EVEX_Vmovupd_ymm_k1z_ymmm256;
    
public static Code EVEX_Vmovupd_zmm_k1z_zmmm512;
    
public static Code Movss_xmm_xmmm32;
    
public static Code VEX_Vmovss_xmm_xmm_xmm;
    
public static Code VEX_Vmovss_xmm_m32;
    
public static Code EVEX_Vmovss_xmm_k1z_xmm_xmm;
    
public static Code EVEX_Vmovss_xmm_k1z_m32;
    
public static Code Movsd_xmm_xmmm64;
    
public static Code VEX_Vmovsd_xmm_xmm_xmm;
    
public static Code VEX_Vmovsd_xmm_m64;
    
public static Code EVEX_Vmovsd_xmm_k1z_xmm_xmm;
    
public static Code EVEX_Vmovsd_xmm_k1z_m64;
    
public static Code Movups_xmmm128_xmm;
    
public static Code VEX_Vmovups_xmmm128_xmm;
    
public static Code VEX_Vmovups_ymmm256_ymm;
    
public static Code EVEX_Vmovups_xmmm128_k1z_xmm;
    
public static Code EVEX_Vmovups_ymmm256_k1z_ymm;
    
public static Code EVEX_Vmovups_zmmm512_k1z_zmm;
    
public static Code Movupd_xmmm128_xmm;
    
public static Code VEX_Vmovupd_xmmm128_xmm;
    
public static Code VEX_Vmovupd_ymmm256_ymm;
    
public static Code EVEX_Vmovupd_xmmm128_k1z_xmm;
    
public static Code EVEX_Vmovupd_ymmm256_k1z_ymm;
    
public static Code EVEX_Vmovupd_zmmm512_k1z_zmm;
    
public static Code Movss_xmmm32_xmm;
    
public static Code VEX_Vmovss_xmm_xmm_xmm_0F11;
    
public static Code VEX_Vmovss_m32_xmm;
    
public static Code EVEX_Vmovss_xmm_k1z_xmm_xmm_0F11;
    
public static Code EVEX_Vmovss_m32_k1_xmm;
    
public static Code Movsd_xmmm64_xmm;
    
public static Code VEX_Vmovsd_xmm_xmm_xmm_0F11;
    
public static Code VEX_Vmovsd_m64_xmm;
    
public static Code EVEX_Vmovsd_xmm_k1z_xmm_xmm_0F11;
    
public static Code EVEX_Vmovsd_m64_k1_xmm;
    
public static Code Movhlps_xmm_xmm;
    
public static Code Movlps_xmm_m64;
    
public static Code VEX_Vmovhlps_xmm_xmm_xmm;
    
public static Code VEX_Vmovlps_xmm_xmm_m64;
    
public static Code EVEX_Vmovhlps_xmm_xmm_xmm;
    
public static Code EVEX_Vmovlps_xmm_xmm_m64;
    
public static Code Movlpd_xmm_m64;
    
public static Code VEX_Vmovlpd_xmm_xmm_m64;
    
public static Code EVEX_Vmovlpd_xmm_xmm_m64;
    
public static Code Movsldup_xmm_xmmm128;
    
public static Code VEX_Vmovsldup_xmm_xmmm128;
    
public static Code VEX_Vmovsldup_ymm_ymmm256;
    
public static Code EVEX_Vmovsldup_xmm_k1z_xmmm128;
    
public static Code EVEX_Vmovsldup_ymm_k1z_ymmm256;
    
public static Code EVEX_Vmovsldup_zmm_k1z_zmmm512;
    
public static Code Movddup_xmm_xmmm64;
    
public static Code VEX_Vmovddup_xmm_xmmm64;
    
public static Code VEX_Vmovddup_ymm_ymmm256;
    
public static Code EVEX_Vmovddup_xmm_k1z_xmmm64;
    
public static Code EVEX_Vmovddup_ymm_k1z_ymmm256;
    
public static Code EVEX_Vmovddup_zmm_k1z_zmmm512;
    
public static Code Movlps_m64_xmm;
    
public static Code VEX_Vmovlps_m64_xmm;
    
public static Code EVEX_Vmovlps_m64_xmm;
    
public static Code Movlpd_m64_xmm;
    
public static Code VEX_Vmovlpd_m64_xmm;
    
public static Code EVEX_Vmovlpd_m64_xmm;
    
public static Code Unpcklps_xmm_xmmm128;
    
public static Code VEX_Vunpcklps_xmm_xmm_xmmm128;
    
public static Code VEX_Vunpcklps_ymm_ymm_ymmm256;
    
public static Code EVEX_Vunpcklps_xmm_k1z_xmm_xmmm128b32;
    
public static Code EVEX_Vunpcklps_ymm_k1z_ymm_ymmm256b32;
    
public static Code EVEX_Vunpcklps_zmm_k1z_zmm_zmmm512b32;
    
public static Code Unpcklpd_xmm_xmmm128;
    
public static Code VEX_Vunpcklpd_xmm_xmm_xmmm128;
    
public static Code VEX_Vunpcklpd_ymm_ymm_ymmm256;
    
public static Code EVEX_Vunpcklpd_xmm_k1z_xmm_xmmm128b64;
    
public static Code EVEX_Vunpcklpd_ymm_k1z_ymm_ymmm256b64;
    
public static Code EVEX_Vunpcklpd_zmm_k1z_zmm_zmmm512b64;
    
public static Code Unpckhps_xmm_xmmm128;
    
public static Code VEX_Vunpckhps_xmm_xmm_xmmm128;
    
public static Code VEX_Vunpckhps_ymm_ymm_ymmm256;
    
public static Code EVEX_Vunpckhps_xmm_k1z_xmm_xmmm128b32;
    
public static Code EVEX_Vunpckhps_ymm_k1z_ymm_ymmm256b32;
    
public static Code EVEX_Vunpckhps_zmm_k1z_zmm_zmmm512b32;
    
public static Code Unpckhpd_xmm_xmmm128;
    
public static Code VEX_Vunpckhpd_xmm_xmm_xmmm128;
    
public static Code VEX_Vunpckhpd_ymm_ymm_ymmm256;
    
public static Code EVEX_Vunpckhpd_xmm_k1z_xmm_xmmm128b64;
    
public static Code EVEX_Vunpckhpd_ymm_k1z_ymm_ymmm256b64;
    
public static Code EVEX_Vunpckhpd_zmm_k1z_zmm_zmmm512b64;
    
public static Code Movlhps_xmm_xmm;
    
public static Code VEX_Vmovlhps_xmm_xmm_xmm;
    
public static Code EVEX_Vmovlhps_xmm_xmm_xmm;
    
public static Code Movhps_xmm_m64;
    
public static Code VEX_Vmovhps_xmm_xmm_m64;
    
public static Code EVEX_Vmovhps_xmm_xmm_m64;
    
public static Code Movhpd_xmm_m64;
    
public static Code VEX_Vmovhpd_xmm_xmm_m64;
    
public static Code EVEX_Vmovhpd_xmm_xmm_m64;
    
public static Code Movshdup_xmm_xmmm128;
    
public static Code VEX_Vmovshdup_xmm_xmmm128;
    
public static Code VEX_Vmovshdup_ymm_ymmm256;
    
public static Code EVEX_Vmovshdup_xmm_k1z_xmmm128;
    
public static Code EVEX_Vmovshdup_ymm_k1z_ymmm256;
    
public static Code EVEX_Vmovshdup_zmm_k1z_zmmm512;
    
public static Code Movhps_m64_xmm;
    
public static Code VEX_Vmovhps_m64_xmm;
    
public static Code EVEX_Vmovhps_m64_xmm;
    
public static Code Movhpd_m64_xmm;
    
public static Code VEX_Vmovhpd_m64_xmm;
    
public static Code EVEX_Vmovhpd_m64_xmm;
    
public static Code Reservednop_rm16_r16_0F18;
    
public static Code Reservednop_rm32_r32_0F18;
    
public static Code Reservednop_rm64_r64_0F18;
    
public static Code Reservednop_rm16_r16_0F19;
    
public static Code Reservednop_rm32_r32_0F19;
    
public static Code Reservednop_rm64_r64_0F19;
    
public static Code Reservednop_rm16_r16_0F1A;
    
public static Code Reservednop_rm32_r32_0F1A;
    
public static Code Reservednop_rm64_r64_0F1A;
    
public static Code Reservednop_rm16_r16_0F1B;
    
public static Code Reservednop_rm32_r32_0F1B;
    
public static Code Reservednop_rm64_r64_0F1B;
    
public static Code Reservednop_rm16_r16_0F1C;
    
public static Code Reservednop_rm32_r32_0F1C;
    
public static Code Reservednop_rm64_r64_0F1C;
    
public static Code Reservednop_rm16_r16_0F1D;
    
public static Code Reservednop_rm32_r32_0F1D;
    
public static Code Reservednop_rm64_r64_0F1D;
    
public static Code Reservednop_rm16_r16_0F1E;
    
public static Code Reservednop_rm32_r32_0F1E;
    
public static Code Reservednop_rm64_r64_0F1E;
    
public static Code Reservednop_rm16_r16_0F1F;
    
public static Code Reservednop_rm32_r32_0F1F;
    
public static Code Reservednop_rm64_r64_0F1F;
    
public static Code Prefetchnta_m8;
    
public static Code Prefetcht0_m8;
    
public static Code Prefetcht1_m8;
    
public static Code Prefetcht2_m8;
    
public static Code Bndldx_bnd_mib;
    
public static Code Bndmov_bnd_bndm64;
    
public static Code Bndmov_bnd_bndm128;
    
public static Code Bndcl_bnd_rm32;
    
public static Code Bndcl_bnd_rm64;
    
public static Code Bndcu_bnd_rm32;
    
public static Code Bndcu_bnd_rm64;
    
public static Code Bndstx_mib_bnd;
    
public static Code Bndmov_bndm64_bnd;
    
public static Code Bndmov_bndm128_bnd;
    
public static Code Bndmk_bnd_m32;
    
public static Code Bndmk_bnd_m64;
    
public static Code Bndcn_bnd_rm32;
    
public static Code Bndcn_bnd_rm64;
    
public static Code Cldemote_m8;
    
public static Code Rdsspd_r32;
    
public static Code Rdsspq_r64;
    
public static Code Endbr64;
    
public static Code Endbr32;
    
public static Code Nop_rm16;
    
public static Code Nop_rm32;
    
public static Code Nop_rm64;
    
public static Code Mov_r32_cr;
    
public static Code Mov_r64_cr;
    
public static Code Mov_r32_dr;
    
public static Code Mov_r64_dr;
    
public static Code Mov_cr_r32;
    
public static Code Mov_cr_r64;
    
public static Code Mov_dr_r32;
    
public static Code Mov_dr_r64;
    
public static Code Mov_r32_tr;
    
public static Code Mov_tr_r32;
    
public static Code Movaps_xmm_xmmm128;
    
public static Code VEX_Vmovaps_xmm_xmmm128;
    
public static Code VEX_Vmovaps_ymm_ymmm256;
    
public static Code EVEX_Vmovaps_xmm_k1z_xmmm128;
    
public static Code EVEX_Vmovaps_ymm_k1z_ymmm256;
    
public static Code EVEX_Vmovaps_zmm_k1z_zmmm512;
    
public static Code Movapd_xmm_xmmm128;
    
public static Code VEX_Vmovapd_xmm_xmmm128;
    
public static Code VEX_Vmovapd_ymm_ymmm256;
    
public static Code EVEX_Vmovapd_xmm_k1z_xmmm128;
    
public static Code EVEX_Vmovapd_ymm_k1z_ymmm256;
    
public static Code EVEX_Vmovapd_zmm_k1z_zmmm512;
    
public static Code Movaps_xmmm128_xmm;
    
public static Code VEX_Vmovaps_xmmm128_xmm;
    
public static Code VEX_Vmovaps_ymmm256_ymm;
    
public static Code EVEX_Vmovaps_xmmm128_k1z_xmm;
    
public static Code EVEX_Vmovaps_ymmm256_k1z_ymm;
    
public static Code EVEX_Vmovaps_zmmm512_k1z_zmm;
    
public static Code Movapd_xmmm128_xmm;
    
public static Code VEX_Vmovapd_xmmm128_xmm;
    
public static Code VEX_Vmovapd_ymmm256_ymm;
    
public static Code EVEX_Vmovapd_xmmm128_k1z_xmm;
    
public static Code EVEX_Vmovapd_ymmm256_k1z_ymm;
    
public static Code EVEX_Vmovapd_zmmm512_k1z_zmm;
    
public static Code Cvtpi2ps_xmm_mmm64;
    
public static Code Cvtpi2pd_xmm_mmm64;
    
public static Code Cvtsi2ss_xmm_rm32;
    
public static Code Cvtsi2ss_xmm_rm64;
    
public static Code VEX_Vcvtsi2ss_xmm_xmm_rm32;
    
public static Code VEX_Vcvtsi2ss_xmm_xmm_rm64;
    
public static Code EVEX_Vcvtsi2ss_xmm_xmm_rm32_er;
    
public static Code EVEX_Vcvtsi2ss_xmm_xmm_rm64_er;
    
public static Code Cvtsi2sd_xmm_rm32;
    
public static Code Cvtsi2sd_xmm_rm64;
    
public static Code VEX_Vcvtsi2sd_xmm_xmm_rm32;
    
public static Code VEX_Vcvtsi2sd_xmm_xmm_rm64;
    
public static Code EVEX_Vcvtsi2sd_xmm_xmm_rm32_er;
    
public static Code EVEX_Vcvtsi2sd_xmm_xmm_rm64_er;
    
public static Code Movntps_m128_xmm;
    
public static Code VEX_Vmovntps_m128_xmm;
    
public static Code VEX_Vmovntps_m256_ymm;
    
public static Code EVEX_Vmovntps_m128_xmm;
    
public static Code EVEX_Vmovntps_m256_ymm;
    
public static Code EVEX_Vmovntps_m512_zmm;
    
public static Code Movntpd_m128_xmm;
    
public static Code VEX_Vmovntpd_m128_xmm;
    
public static Code VEX_Vmovntpd_m256_ymm;
    
public static Code EVEX_Vmovntpd_m128_xmm;
    
public static Code EVEX_Vmovntpd_m256_ymm;
    
public static Code EVEX_Vmovntpd_m512_zmm;
    
public static Code Movntss_m32_xmm;
    
public static Code Movntsd_m64_xmm;
    
public static Code Cvttps2pi_mm_xmmm64;
    
public static Code Cvttpd2pi_mm_xmmm128;
    
public static Code Cvttss2si_r32_xmmm32;
    
public static Code Cvttss2si_r64_xmmm32;
    
public static Code VEX_Vcvttss2si_r32_xmmm32;
    
public static Code VEX_Vcvttss2si_r64_xmmm32;
    
public static Code EVEX_Vcvttss2si_r32_xmmm32_sae;
    
public static Code EVEX_Vcvttss2si_r64_xmmm32_sae;
    
public static Code Cvttsd2si_r32_xmmm64;
    
public static Code Cvttsd2si_r64_xmmm64;
    
public static Code VEX_Vcvttsd2si_r32_xmmm64;
    
public static Code VEX_Vcvttsd2si_r64_xmmm64;
    
public static Code EVEX_Vcvttsd2si_r32_xmmm64_sae;
    
public static Code EVEX_Vcvttsd2si_r64_xmmm64_sae;
    
public static Code Cvtps2pi_mm_xmmm64;
    
public static Code Cvtpd2pi_mm_xmmm128;
    
public static Code Cvtss2si_r32_xmmm32;
    
public static Code Cvtss2si_r64_xmmm32;
    
public static Code VEX_Vcvtss2si_r32_xmmm32;
    
public static Code VEX_Vcvtss2si_r64_xmmm32;
    
public static Code EVEX_Vcvtss2si_r32_xmmm32_er;
    
public static Code EVEX_Vcvtss2si_r64_xmmm32_er;
    
public static Code Cvtsd2si_r32_xmmm64;
    
public static Code Cvtsd2si_r64_xmmm64;
    
public static Code VEX_Vcvtsd2si_r32_xmmm64;
    
public static Code VEX_Vcvtsd2si_r64_xmmm64;
    
public static Code EVEX_Vcvtsd2si_r32_xmmm64_er;
    
public static Code EVEX_Vcvtsd2si_r64_xmmm64_er;
    
public static Code Ucomiss_xmm_xmmm32;
    
public static Code VEX_Vucomiss_xmm_xmmm32;
    
public static Code EVEX_Vucomiss_xmm_xmmm32_sae;
    
public static Code Ucomisd_xmm_xmmm64;
    
public static Code VEX_Vucomisd_xmm_xmmm64;
    
public static Code EVEX_Vucomisd_xmm_xmmm64_sae;
    
public static Code Comiss_xmm_xmmm32;
    
public static Code Comisd_xmm_xmmm64;
    
public static Code VEX_Vcomiss_xmm_xmmm32;
    
public static Code VEX_Vcomisd_xmm_xmmm64;
    
public static Code EVEX_Vcomiss_xmm_xmmm32_sae;
    
public static Code EVEX_Vcomisd_xmm_xmmm64_sae;
    
public static Code Wrmsr;
    
public static Code Rdtsc;
    
public static Code Rdmsr;
    
public static Code Rdpmc;
    
public static Code Sysenter;
    
public static Code Sysexitd;
    
public static Code Sysexitq;
    
public static Code Getsecd;
    
public static Code Cmovo_r16_rm16;
    
public static Code Cmovo_r32_rm32;
    
public static Code Cmovo_r64_rm64;
    
public static Code Cmovno_r16_rm16;
    
public static Code Cmovno_r32_rm32;
    
public static Code Cmovno_r64_rm64;
    
public static Code Cmovb_r16_rm16;
    
public static Code Cmovb_r32_rm32;
    
public static Code Cmovb_r64_rm64;
    
public static Code Cmovae_r16_rm16;
    
public static Code Cmovae_r32_rm32;
    
public static Code Cmovae_r64_rm64;
    
public static Code Cmove_r16_rm16;
    
public static Code Cmove_r32_rm32;
    
public static Code Cmove_r64_rm64;
    
public static Code Cmovne_r16_rm16;
    
public static Code Cmovne_r32_rm32;
    
public static Code Cmovne_r64_rm64;
    
public static Code Cmovbe_r16_rm16;
    
public static Code Cmovbe_r32_rm32;
    
public static Code Cmovbe_r64_rm64;
    
public static Code Cmova_r16_rm16;
    
public static Code Cmova_r32_rm32;
    
public static Code Cmova_r64_rm64;
    
public static Code Cmovs_r16_rm16;
    
public static Code Cmovs_r32_rm32;
    
public static Code Cmovs_r64_rm64;
    
public static Code Cmovns_r16_rm16;
    
public static Code Cmovns_r32_rm32;
    
public static Code Cmovns_r64_rm64;
    
public static Code Cmovp_r16_rm16;
    
public static Code Cmovp_r32_rm32;
    
public static Code Cmovp_r64_rm64;
    
public static Code Cmovnp_r16_rm16;
    
public static Code Cmovnp_r32_rm32;
    
public static Code Cmovnp_r64_rm64;
    
public static Code Cmovl_r16_rm16;
    
public static Code Cmovl_r32_rm32;
    
public static Code Cmovl_r64_rm64;
    
public static Code Cmovge_r16_rm16;
    
public static Code Cmovge_r32_rm32;
    
public static Code Cmovge_r64_rm64;
    
public static Code Cmovle_r16_rm16;
    
public static Code Cmovle_r32_rm32;
    
public static Code Cmovle_r64_rm64;
    
public static Code Cmovg_r16_rm16;
    
public static Code Cmovg_r32_rm32;
    
public static Code Cmovg_r64_rm64;
    
public static Code VEX_Kandw_kr_kr_kr;
    
public static Code VEX_Kandq_kr_kr_kr;
    
public static Code VEX_Kandb_kr_kr_kr;
    
public static Code VEX_Kandd_kr_kr_kr;
    
public static Code VEX_Kandnw_kr_kr_kr;
    
public static Code VEX_Kandnq_kr_kr_kr;
    
public static Code VEX_Kandnb_kr_kr_kr;
    
public static Code VEX_Kandnd_kr_kr_kr;
    
public static Code VEX_Knotw_kr_kr;
    
public static Code VEX_Knotq_kr_kr;
    
public static Code VEX_Knotb_kr_kr;
    
public static Code VEX_Knotd_kr_kr;
    
public static Code VEX_Korw_kr_kr_kr;
    
public static Code VEX_Korq_kr_kr_kr;
    
public static Code VEX_Korb_kr_kr_kr;
    
public static Code VEX_Kord_kr_kr_kr;
    
public static Code VEX_Kxnorw_kr_kr_kr;
    
public static Code VEX_Kxnorq_kr_kr_kr;
    
public static Code VEX_Kxnorb_kr_kr_kr;
    
public static Code VEX_Kxnord_kr_kr_kr;
    
public static Code VEX_Kxorw_kr_kr_kr;
    
public static Code VEX_Kxorq_kr_kr_kr;
    
public static Code VEX_Kxorb_kr_kr_kr;
    
public static Code VEX_Kxord_kr_kr_kr;
    
public static Code VEX_Kaddw_kr_kr_kr;
    
public static Code VEX_Kaddq_kr_kr_kr;
    
public static Code VEX_Kaddb_kr_kr_kr;
    
public static Code VEX_Kaddd_kr_kr_kr;
    
public static Code VEX_Kunpckwd_kr_kr_kr;
    
public static Code VEX_Kunpckdq_kr_kr_kr;
    
public static Code VEX_Kunpckbw_kr_kr_kr;
    
public static Code Movmskps_r32_xmm;
    
public static Code Movmskps_r64_xmm;
    
public static Code VEX_Vmovmskps_r32_xmm;
    
public static Code VEX_Vmovmskps_r64_xmm;
    
public static Code VEX_Vmovmskps_r32_ymm;
    
public static Code VEX_Vmovmskps_r64_ymm;
    
public static Code Movmskpd_r32_xmm;
    
public static Code Movmskpd_r64_xmm;
    
public static Code VEX_Vmovmskpd_r32_xmm;
    
public static Code VEX_Vmovmskpd_r64_xmm;
    
public static Code VEX_Vmovmskpd_r32_ymm;
    
public static Code VEX_Vmovmskpd_r64_ymm;
    
public static Code Sqrtps_xmm_xmmm128;
    
public static Code VEX_Vsqrtps_xmm_xmmm128;
    
public static Code VEX_Vsqrtps_ymm_ymmm256;
    
public static Code EVEX_Vsqrtps_xmm_k1z_xmmm128b32;
    
public static Code EVEX_Vsqrtps_ymm_k1z_ymmm256b32;
    
public static Code EVEX_Vsqrtps_zmm_k1z_zmmm512b32_er;
    
public static Code Sqrtpd_xmm_xmmm128;
    
public static Code VEX_Vsqrtpd_xmm_xmmm128;
    
public static Code VEX_Vsqrtpd_ymm_ymmm256;
    
public static Code EVEX_Vsqrtpd_xmm_k1z_xmmm128b64;
    
public static Code EVEX_Vsqrtpd_ymm_k1z_ymmm256b64;
    
public static Code EVEX_Vsqrtpd_zmm_k1z_zmmm512b64_er;
    
public static Code Sqrtss_xmm_xmmm32;
    
public static Code VEX_Vsqrtss_xmm_xmm_xmmm32;
    
public static Code EVEX_Vsqrtss_xmm_k1z_xmm_xmmm32_er;
    
public static Code Sqrtsd_xmm_xmmm64;
    
public static Code VEX_Vsqrtsd_xmm_xmm_xmmm64;
    
public static Code EVEX_Vsqrtsd_xmm_k1z_xmm_xmmm64_er;
    
public static Code Rsqrtps_xmm_xmmm128;
    
public static Code VEX_Vrsqrtps_xmm_xmmm128;
    
public static Code VEX_Vrsqrtps_ymm_ymmm256;
    
public static Code Rsqrtss_xmm_xmmm32;
    
public static Code VEX_Vrsqrtss_xmm_xmm_xmmm32;
    
public static Code Rcpps_xmm_xmmm128;
    
public static Code VEX_Vrcpps_xmm_xmmm128;
    
public static Code VEX_Vrcpps_ymm_ymmm256;
    
public static Code Rcpss_xmm_xmmm32;
    
public static Code VEX_Vrcpss_xmm_xmm_xmmm32;
    
public static Code Andps_xmm_xmmm128;
    
public static Code VEX_Vandps_xmm_xmm_xmmm128;
    
public static Code VEX_Vandps_ymm_ymm_ymmm256;
    
public static Code EVEX_Vandps_xmm_k1z_xmm_xmmm128b32;
    
public static Code EVEX_Vandps_ymm_k1z_ymm_ymmm256b32;
    
public static Code EVEX_Vandps_zmm_k1z_zmm_zmmm512b32;
    
public static Code Andpd_xmm_xmmm128;
    
public static Code VEX_Vandpd_xmm_xmm_xmmm128;
    
public static Code VEX_Vandpd_ymm_ymm_ymmm256;
    
public static Code EVEX_Vandpd_xmm_k1z_xmm_xmmm128b64;
    
public static Code EVEX_Vandpd_ymm_k1z_ymm_ymmm256b64;
    
public static Code EVEX_Vandpd_zmm_k1z_zmm_zmmm512b64;
    
public static Code Andnps_xmm_xmmm128;
    
public static Code VEX_Vandnps_xmm_xmm_xmmm128;
    
public static Code VEX_Vandnps_ymm_ymm_ymmm256;
    
public static Code EVEX_Vandnps_xmm_k1z_xmm_xmmm128b32;
    
public static Code EVEX_Vandnps_ymm_k1z_ymm_ymmm256b32;
    
public static Code EVEX_Vandnps_zmm_k1z_zmm_zmmm512b32;
    
public static Code Andnpd_xmm_xmmm128;
    
public static Code VEX_Vandnpd_xmm_xmm_xmmm128;
    
public static Code VEX_Vandnpd_ymm_ymm_ymmm256;
    
public static Code EVEX_Vandnpd_xmm_k1z_xmm_xmmm128b64;
    
public static Code EVEX_Vandnpd_ymm_k1z_ymm_ymmm256b64;
    
public static Code EVEX_Vandnpd_zmm_k1z_zmm_zmmm512b64;
    
public static Code Orps_xmm_xmmm128;
    
public static Code VEX_Vorps_xmm_xmm_xmmm128;
    
public static Code VEX_Vorps_ymm_ymm_ymmm256;
    
public static Code EVEX_Vorps_xmm_k1z_xmm_xmmm128b32;
    
public static Code EVEX_Vorps_ymm_k1z_ymm_ymmm256b32;
    
public static Code EVEX_Vorps_zmm_k1z_zmm_zmmm512b32;
    
public static Code Orpd_xmm_xmmm128;
    
public static Code VEX_Vorpd_xmm_xmm_xmmm128;
    
public static Code VEX_Vorpd_ymm_ymm_ymmm256;
    
public static Code EVEX_Vorpd_xmm_k1z_xmm_xmmm128b64;
    
public static Code EVEX_Vorpd_ymm_k1z_ymm_ymmm256b64;
    
public static Code EVEX_Vorpd_zmm_k1z_zmm_zmmm512b64;
    
public static Code Xorps_xmm_xmmm128;
    
public static Code VEX_Vxorps_xmm_xmm_xmmm128;
    
public static Code VEX_Vxorps_ymm_ymm_ymmm256;
    
public static Code EVEX_Vxorps_xmm_k1z_xmm_xmmm128b32;
    
public static Code EVEX_Vxorps_ymm_k1z_ymm_ymmm256b32;
    
public static Code EVEX_Vxorps_zmm_k1z_zmm_zmmm512b32;
    
public static Code Xorpd_xmm_xmmm128;
    
public static Code VEX_Vxorpd_xmm_xmm_xmmm128;
    
public static Code VEX_Vxorpd_ymm_ymm_ymmm256;
    
public static Code EVEX_Vxorpd_xmm_k1z_xmm_xmmm128b64;
    
public static Code EVEX_Vxorpd_ymm_k1z_ymm_ymmm256b64;
    
public static Code EVEX_Vxorpd_zmm_k1z_zmm_zmmm512b64;
    
public static Code Addps_xmm_xmmm128;
    
public static Code VEX_Vaddps_xmm_xmm_xmmm128;
    
public static Code VEX_Vaddps_ymm_ymm_ymmm256;
    
public static Code EVEX_Vaddps_xmm_k1z_xmm_xmmm128b32;
    
public static Code EVEX_Vaddps_ymm_k1z_ymm_ymmm256b32;
    
public static Code EVEX_Vaddps_zmm_k1z_zmm_zmmm512b32_er;
    
public static Code Addpd_xmm_xmmm128;
    
public static Code VEX_Vaddpd_xmm_xmm_xmmm128;
    
public static Code VEX_Vaddpd_ymm_ymm_ymmm256;
    
public static Code EVEX_Vaddpd_xmm_k1z_xmm_xmmm128b64;
    
public static Code EVEX_Vaddpd_ymm_k1z_ymm_ymmm256b64;
    
public static Code EVEX_Vaddpd_zmm_k1z_zmm_zmmm512b64_er;
    
public static Code Addss_xmm_xmmm32;
    
public static Code VEX_Vaddss_xmm_xmm_xmmm32;
    
public static Code EVEX_Vaddss_xmm_k1z_xmm_xmmm32_er;
    
public static Code Addsd_xmm_xmmm64;
    
public static Code VEX_Vaddsd_xmm_xmm_xmmm64;
    
public static Code EVEX_Vaddsd_xmm_k1z_xmm_xmmm64_er;
    
public static Code Mulps_xmm_xmmm128;
    
public static Code VEX_Vmulps_xmm_xmm_xmmm128;
    
public static Code VEX_Vmulps_ymm_ymm_ymmm256;
    
public static Code EVEX_Vmulps_xmm_k1z_xmm_xmmm128b32;
    
public static Code EVEX_Vmulps_ymm_k1z_ymm_ymmm256b32;
    
public static Code EVEX_Vmulps_zmm_k1z_zmm_zmmm512b32_er;
    
public static Code Mulpd_xmm_xmmm128;
    
public static Code VEX_Vmulpd_xmm_xmm_xmmm128;
    
public static Code VEX_Vmulpd_ymm_ymm_ymmm256;
    
public static Code EVEX_Vmulpd_xmm_k1z_xmm_xmmm128b64;
    
public static Code EVEX_Vmulpd_ymm_k1z_ymm_ymmm256b64;
    
public static Code EVEX_Vmulpd_zmm_k1z_zmm_zmmm512b64_er;
    
public static Code Mulss_xmm_xmmm32;
    
public static Code VEX_Vmulss_xmm_xmm_xmmm32;
    
public static Code EVEX_Vmulss_xmm_k1z_xmm_xmmm32_er;
    
public static Code Mulsd_xmm_xmmm64;
    
public static Code VEX_Vmulsd_xmm_xmm_xmmm64;
    
public static Code EVEX_Vmulsd_xmm_k1z_xmm_xmmm64_er;
    
public static Code Cvtps2pd_xmm_xmmm64;
    
public static Code VEX_Vcvtps2pd_xmm_xmmm64;
    
public static Code VEX_Vcvtps2pd_ymm_xmmm128;
    
public static Code EVEX_Vcvtps2pd_xmm_k1z_xmmm64b32;
    
public static Code EVEX_Vcvtps2pd_ymm_k1z_xmmm128b32;
    
public static Code EVEX_Vcvtps2pd_zmm_k1z_ymmm256b32_sae;
    
public static Code Cvtpd2ps_xmm_xmmm128;
    
public static Code VEX_Vcvtpd2ps_xmm_xmmm128;
    
public static Code VEX_Vcvtpd2ps_xmm_ymmm256;
    
public static Code EVEX_Vcvtpd2ps_xmm_k1z_xmmm128b64;
    
public static Code EVEX_Vcvtpd2ps_xmm_k1z_ymmm256b64;
    
public static Code EVEX_Vcvtpd2ps_ymm_k1z_zmmm512b64_er;
    
public static Code Cvtss2sd_xmm_xmmm32;
    
public static Code VEX_Vcvtss2sd_xmm_xmm_xmmm32;
    
public static Code EVEX_Vcvtss2sd_xmm_k1z_xmm_xmmm32_sae;
    
public static Code Cvtsd2ss_xmm_xmmm64;
    
public static Code VEX_Vcvtsd2ss_xmm_xmm_xmmm64;
    
public static Code EVEX_Vcvtsd2ss_xmm_k1z_xmm_xmmm64_er;
    
public static Code Cvtdq2ps_xmm_xmmm128;
    
public static Code VEX_Vcvtdq2ps_xmm_xmmm128;
    
public static Code VEX_Vcvtdq2ps_ymm_ymmm256;
    
public static Code EVEX_Vcvtdq2ps_xmm_k1z_xmmm128b32;
    
public static Code EVEX_Vcvtdq2ps_ymm_k1z_ymmm256b32;
    
public static Code EVEX_Vcvtdq2ps_zmm_k1z_zmmm512b32_er;
    
public static Code EVEX_Vcvtqq2ps_xmm_k1z_xmmm128b64;
    
public static Code EVEX_Vcvtqq2ps_xmm_k1z_ymmm256b64;
    
public static Code EVEX_Vcvtqq2ps_ymm_k1z_zmmm512b64_er;
    
public static Code Cvtps2dq_xmm_xmmm128;
    
public static Code VEX_Vcvtps2dq_xmm_xmmm128;
    
public static Code VEX_Vcvtps2dq_ymm_ymmm256;
    
public static Code EVEX_Vcvtps2dq_xmm_k1z_xmmm128b32;
    
public static Code EVEX_Vcvtps2dq_ymm_k1z_ymmm256b32;
    
public static Code EVEX_Vcvtps2dq_zmm_k1z_zmmm512b32_er;
    
public static Code Cvttps2dq_xmm_xmmm128;
    
public static Code VEX_Vcvttps2dq_xmm_xmmm128;
    
public static Code VEX_Vcvttps2dq_ymm_ymmm256;
    
public static Code EVEX_Vcvttps2dq_xmm_k1z_xmmm128b32;
    
public static Code EVEX_Vcvttps2dq_ymm_k1z_ymmm256b32;
    
public static Code EVEX_Vcvttps2dq_zmm_k1z_zmmm512b32_sae;
    
public static Code Subps_xmm_xmmm128;
    
public static Code VEX_Vsubps_xmm_xmm_xmmm128;
    
public static Code VEX_Vsubps_ymm_ymm_ymmm256;
    
public static Code EVEX_Vsubps_xmm_k1z_xmm_xmmm128b32;
    
public static Code EVEX_Vsubps_ymm_k1z_ymm_ymmm256b32;
    
public static Code EVEX_Vsubps_zmm_k1z_zmm_zmmm512b32_er;
    
public static Code Subpd_xmm_xmmm128;
    
public static Code VEX_Vsubpd_xmm_xmm_xmmm128;
    
public static Code VEX_Vsubpd_ymm_ymm_ymmm256;
    
public static Code EVEX_Vsubpd_xmm_k1z_xmm_xmmm128b64;
    
public static Code EVEX_Vsubpd_ymm_k1z_ymm_ymmm256b64;
    
public static Code EVEX_Vsubpd_zmm_k1z_zmm_zmmm512b64_er;
    
public static Code Subss_xmm_xmmm32;
    
public static Code VEX_Vsubss_xmm_xmm_xmmm32;
    
public static Code EVEX_Vsubss_xmm_k1z_xmm_xmmm32_er;
    
public static Code Subsd_xmm_xmmm64;
    
public static Code VEX_Vsubsd_xmm_xmm_xmmm64;
    
public static Code EVEX_Vsubsd_xmm_k1z_xmm_xmmm64_er;
    
public static Code Minps_xmm_xmmm128;
    
public static Code VEX_Vminps_xmm_xmm_xmmm128;
    
public static Code VEX_Vminps_ymm_ymm_ymmm256;
    
public static Code EVEX_Vminps_xmm_k1z_xmm_xmmm128b32;
    
public static Code EVEX_Vminps_ymm_k1z_ymm_ymmm256b32;
    
public static Code EVEX_Vminps_zmm_k1z_zmm_zmmm512b32_sae;
    
public static Code Minpd_xmm_xmmm128;
    
public static Code VEX_Vminpd_xmm_xmm_xmmm128;
    
public static Code VEX_Vminpd_ymm_ymm_ymmm256;
    
public static Code EVEX_Vminpd_xmm_k1z_xmm_xmmm128b64;
    
public static Code EVEX_Vminpd_ymm_k1z_ymm_ymmm256b64;
    
public static Code EVEX_Vminpd_zmm_k1z_zmm_zmmm512b64_sae;
    
public static Code Minss_xmm_xmmm32;
    
public static Code VEX_Vminss_xmm_xmm_xmmm32;
    
public static Code EVEX_Vminss_xmm_k1z_xmm_xmmm32_sae;
    
public static Code Minsd_xmm_xmmm64;
    
public static Code VEX_Vminsd_xmm_xmm_xmmm64;
    
public static Code EVEX_Vminsd_xmm_k1z_xmm_xmmm64_sae;
    
public static Code Divps_xmm_xmmm128;
    
public static Code VEX_Vdivps_xmm_xmm_xmmm128;
    
public static Code VEX_Vdivps_ymm_ymm_ymmm256;
    
public static Code EVEX_Vdivps_xmm_k1z_xmm_xmmm128b32;
    
public static Code EVEX_Vdivps_ymm_k1z_ymm_ymmm256b32;
    
public static Code EVEX_Vdivps_zmm_k1z_zmm_zmmm512b32_er;
    
public static Code Divpd_xmm_xmmm128;
    
public static Code VEX_Vdivpd_xmm_xmm_xmmm128;
    
public static Code VEX_Vdivpd_ymm_ymm_ymmm256;
    
public static Code EVEX_Vdivpd_xmm_k1z_xmm_xmmm128b64;
    
public static Code EVEX_Vdivpd_ymm_k1z_ymm_ymmm256b64;
    
public static Code EVEX_Vdivpd_zmm_k1z_zmm_zmmm512b64_er;
    
public static Code Divss_xmm_xmmm32;
    
public static Code VEX_Vdivss_xmm_xmm_xmmm32;
    
public static Code EVEX_Vdivss_xmm_k1z_xmm_xmmm32_er;
    
public static Code Divsd_xmm_xmmm64;
    
public static Code VEX_Vdivsd_xmm_xmm_xmmm64;
    
public static Code EVEX_Vdivsd_xmm_k1z_xmm_xmmm64_er;
    
public static Code Maxps_xmm_xmmm128;
    
public static Code VEX_Vmaxps_xmm_xmm_xmmm128;
    
public static Code VEX_Vmaxps_ymm_ymm_ymmm256;
    
public static Code EVEX_Vmaxps_xmm_k1z_xmm_xmmm128b32;
    
public static Code EVEX_Vmaxps_ymm_k1z_ymm_ymmm256b32;
    
public static Code EVEX_Vmaxps_zmm_k1z_zmm_zmmm512b32_sae;
    
public static Code Maxpd_xmm_xmmm128;
    
public static Code VEX_Vmaxpd_xmm_xmm_xmmm128;
    
public static Code VEX_Vmaxpd_ymm_ymm_ymmm256;
    
public static Code EVEX_Vmaxpd_xmm_k1z_xmm_xmmm128b64;
    
public static Code EVEX_Vmaxpd_ymm_k1z_ymm_ymmm256b64;
    
public static Code EVEX_Vmaxpd_zmm_k1z_zmm_zmmm512b64_sae;
    
public static Code Maxss_xmm_xmmm32;
    
public static Code VEX_Vmaxss_xmm_xmm_xmmm32;
    
public static Code EVEX_Vmaxss_xmm_k1z_xmm_xmmm32_sae;
    
public static Code Maxsd_xmm_xmmm64;
    
public static Code VEX_Vmaxsd_xmm_xmm_xmmm64;
    
public static Code EVEX_Vmaxsd_xmm_k1z_xmm_xmmm64_sae;
    
public static Code Punpcklbw_mm_mmm32;
    
public static Code Punpcklbw_xmm_xmmm128;
    
public static Code VEX_Vpunpcklbw_xmm_xmm_xmmm128;
    
public static Code VEX_Vpunpcklbw_ymm_ymm_ymmm256;
    
public static Code EVEX_Vpunpcklbw_xmm_k1z_xmm_xmmm128;
    
public static Code EVEX_Vpunpcklbw_ymm_k1z_ymm_ymmm256;
    
public static Code EVEX_Vpunpcklbw_zmm_k1z_zmm_zmmm512;
    
public static Code Punpcklwd_mm_mmm32;
    
public static Code Punpcklwd_xmm_xmmm128;
    
public static Code VEX_Vpunpcklwd_xmm_xmm_xmmm128;
    
public static Code VEX_Vpunpcklwd_ymm_ymm_ymmm256;
    
public static Code EVEX_Vpunpcklwd_xmm_k1z_xmm_xmmm128;
    
public static Code EVEX_Vpunpcklwd_ymm_k1z_ymm_ymmm256;
    
public static Code EVEX_Vpunpcklwd_zmm_k1z_zmm_zmmm512;
    
public static Code Punpckldq_mm_mmm32;
    
public static Code Punpckldq_xmm_xmmm128;
    
public static Code VEX_Vpunpckldq_xmm_xmm_xmmm128;
    
public static Code VEX_Vpunpckldq_ymm_ymm_ymmm256;
    
public static Code EVEX_Vpunpckldq_xmm_k1z_xmm_xmmm128b32;
    
public static Code EVEX_Vpunpckldq_ymm_k1z_ymm_ymmm256b32;
    
public static Code EVEX_Vpunpckldq_zmm_k1z_zmm_zmmm512b32;
    
public static Code Packsswb_mm_mmm64;
    
public static Code Packsswb_xmm_xmmm128;
    
public static Code VEX_Vpacksswb_xmm_xmm_xmmm128;
    
public static Code VEX_Vpacksswb_ymm_ymm_ymmm256;
    
public static Code EVEX_Vpacksswb_xmm_k1z_xmm_xmmm128;
    
public static Code EVEX_Vpacksswb_ymm_k1z_ymm_ymmm256;
    
public static Code EVEX_Vpacksswb_zmm_k1z_zmm_zmmm512;
    
public static Code Pcmpgtb_mm_mmm64;
    
public static Code Pcmpgtb_xmm_xmmm128;
    
public static Code VEX_Vpcmpgtb_xmm_xmm_xmmm128;
    
public static Code VEX_Vpcmpgtb_ymm_ymm_ymmm256;
    
public static Code EVEX_Vpcmpgtb_kr_k1_xmm_xmmm128;
    
public static Code EVEX_Vpcmpgtb_kr_k1_ymm_ymmm256;
    
public static Code EVEX_Vpcmpgtb_kr_k1_zmm_zmmm512;
    
public static Code Pcmpgtw_mm_mmm64;
    
public static Code Pcmpgtw_xmm_xmmm128;
    
public static Code VEX_Vpcmpgtw_xmm_xmm_xmmm128;
    
public static Code VEX_Vpcmpgtw_ymm_ymm_ymmm256;
    
public static Code EVEX_Vpcmpgtw_kr_k1_xmm_xmmm128;
    
public static Code EVEX_Vpcmpgtw_kr_k1_ymm_ymmm256;
    
public static Code EVEX_Vpcmpgtw_kr_k1_zmm_zmmm512;
    
public static Code Pcmpgtd_mm_mmm64;
    
public static Code Pcmpgtd_xmm_xmmm128;
    
public static Code VEX_Vpcmpgtd_xmm_xmm_xmmm128;
    
public static Code VEX_Vpcmpgtd_ymm_ymm_ymmm256;
    
public static Code EVEX_Vpcmpgtd_kr_k1_xmm_xmmm128b32;
    
public static Code EVEX_Vpcmpgtd_kr_k1_ymm_ymmm256b32;
    
public static Code EVEX_Vpcmpgtd_kr_k1_zmm_zmmm512b32;
    
public static Code Packuswb_mm_mmm64;
    
public static Code Packuswb_xmm_xmmm128;
    
public static Code VEX_Vpackuswb_xmm_xmm_xmmm128;
    
public static Code VEX_Vpackuswb_ymm_ymm_ymmm256;
    
public static Code EVEX_Vpackuswb_xmm_k1z_xmm_xmmm128;
    
public static Code EVEX_Vpackuswb_ymm_k1z_ymm_ymmm256;
    
public static Code EVEX_Vpackuswb_zmm_k1z_zmm_zmmm512;
    
public static Code Punpckhbw_mm_mmm64;
    
public static Code Punpckhbw_xmm_xmmm128;
    
public static Code VEX_Vpunpckhbw_xmm_xmm_xmmm128;
    
public static Code VEX_Vpunpckhbw_ymm_ymm_ymmm256;
    
public static Code EVEX_Vpunpckhbw_xmm_k1z_xmm_xmmm128;
    
public static Code EVEX_Vpunpckhbw_ymm_k1z_ymm_ymmm256;
    
public static Code EVEX_Vpunpckhbw_zmm_k1z_zmm_zmmm512;
    
public static Code Punpckhwd_mm_mmm64;
    
public static Code Punpckhwd_xmm_xmmm128;
    
public static Code VEX_Vpunpckhwd_xmm_xmm_xmmm128;
    
public static Code VEX_Vpunpckhwd_ymm_ymm_ymmm256;
    
public static Code EVEX_Vpunpckhwd_xmm_k1z_xmm_xmmm128;
    
public static Code EVEX_Vpunpckhwd_ymm_k1z_ymm_ymmm256;
    
public static Code EVEX_Vpunpckhwd_zmm_k1z_zmm_zmmm512;
    
public static Code Punpckhdq_mm_mmm64;
    
public static Code Punpckhdq_xmm_xmmm128;
    
public static Code VEX_Vpunpckhdq_xmm_xmm_xmmm128;
    
public static Code VEX_Vpunpckhdq_ymm_ymm_ymmm256;
    
public static Code EVEX_Vpunpckhdq_xmm_k1z_xmm_xmmm128b32;
    
public static Code EVEX_Vpunpckhdq_ymm_k1z_ymm_ymmm256b32;
    
public static Code EVEX_Vpunpckhdq_zmm_k1z_zmm_zmmm512b32;
    
public static Code Packssdw_mm_mmm64;
    
public static Code Packssdw_xmm_xmmm128;
    
public static Code VEX_Vpackssdw_xmm_xmm_xmmm128;
    
public static Code VEX_Vpackssdw_ymm_ymm_ymmm256;
    
public static Code EVEX_Vpackssdw_xmm_k1z_xmm_xmmm128b32;
    
public static Code EVEX_Vpackssdw_ymm_k1z_ymm_ymmm256b32;
    
public static Code EVEX_Vpackssdw_zmm_k1z_zmm_zmmm512b32;
    
public static Code Punpcklqdq_xmm_xmmm128;
    
public static Code VEX_Vpunpcklqdq_xmm_xmm_xmmm128;
    
public static Code VEX_Vpunpcklqdq_ymm_ymm_ymmm256;
    
public static Code EVEX_Vpunpcklqdq_xmm_k1z_xmm_xmmm128b64;
    
public static Code EVEX_Vpunpcklqdq_ymm_k1z_ymm_ymmm256b64;
    
public static Code EVEX_Vpunpcklqdq_zmm_k1z_zmm_zmmm512b64;
    
public static Code Punpckhqdq_xmm_xmmm128;
    
public static Code VEX_Vpunpckhqdq_xmm_xmm_xmmm128;
    
public static Code VEX_Vpunpckhqdq_ymm_ymm_ymmm256;
    
public static Code EVEX_Vpunpckhqdq_xmm_k1z_xmm_xmmm128b64;
    
public static Code EVEX_Vpunpckhqdq_ymm_k1z_ymm_ymmm256b64;
    
public static Code EVEX_Vpunpckhqdq_zmm_k1z_zmm_zmmm512b64;
    
public static Code Movd_mm_rm32;
    
public static Code Movq_mm_rm64;
    
public static Code Movd_xmm_rm32;
    
public static Code Movq_xmm_rm64;
    
public static Code VEX_Vmovd_xmm_rm32;
    
public static Code VEX_Vmovq_xmm_rm64;
    
public static Code EVEX_Vmovd_xmm_rm32;
    
public static Code EVEX_Vmovq_xmm_rm64;
    
public static Code Movq_mm_mmm64;
    
public static Code Movdqa_xmm_xmmm128;
    
public static Code VEX_Vmovdqa_xmm_xmmm128;
    
public static Code VEX_Vmovdqa_ymm_ymmm256;
    
public static Code EVEX_Vmovdqa32_xmm_k1z_xmmm128;
    
public static Code EVEX_Vmovdqa32_ymm_k1z_ymmm256;
    
public static Code EVEX_Vmovdqa32_zmm_k1z_zmmm512;
    
public static Code EVEX_Vmovdqa64_xmm_k1z_xmmm128;
    
public static Code EVEX_Vmovdqa64_ymm_k1z_ymmm256;
    
public static Code EVEX_Vmovdqa64_zmm_k1z_zmmm512;
    
public static Code Movdqu_xmm_xmmm128;
    
public static Code VEX_Vmovdqu_xmm_xmmm128;
    
public static Code VEX_Vmovdqu_ymm_ymmm256;
    
public static Code EVEX_Vmovdqu32_xmm_k1z_xmmm128;
    
public static Code EVEX_Vmovdqu32_ymm_k1z_ymmm256;
    
public static Code EVEX_Vmovdqu32_zmm_k1z_zmmm512;
    
public static Code EVEX_Vmovdqu64_xmm_k1z_xmmm128;
    
public static Code EVEX_Vmovdqu64_ymm_k1z_ymmm256;
    
public static Code EVEX_Vmovdqu64_zmm_k1z_zmmm512;
    
public static Code EVEX_Vmovdqu8_xmm_k1z_xmmm128;
    
public static Code EVEX_Vmovdqu8_ymm_k1z_ymmm256;
    
public static Code EVEX_Vmovdqu8_zmm_k1z_zmmm512;
    
public static Code EVEX_Vmovdqu16_xmm_k1z_xmmm128;
    
public static Code EVEX_Vmovdqu16_ymm_k1z_ymmm256;
    
public static Code EVEX_Vmovdqu16_zmm_k1z_zmmm512;
    
public static Code Pshufw_mm_mmm64_imm8;
    
public static Code Pshufd_xmm_xmmm128_imm8;
    
public static Code VEX_Vpshufd_xmm_xmmm128_imm8;
    
public static Code VEX_Vpshufd_ymm_ymmm256_imm8;
    
public static Code EVEX_Vpshufd_xmm_k1z_xmmm128b32_imm8;
    
public static Code EVEX_Vpshufd_ymm_k1z_ymmm256b32_imm8;
    
public static Code EVEX_Vpshufd_zmm_k1z_zmmm512b32_imm8;
    
public static Code Pshufhw_xmm_xmmm128_imm8;
    
public static Code VEX_Vpshufhw_xmm_xmmm128_imm8;
    
public static Code VEX_Vpshufhw_ymm_ymmm256_imm8;
    
public static Code EVEX_Vpshufhw_xmm_k1z_xmmm128_imm8;
    
public static Code EVEX_Vpshufhw_ymm_k1z_ymmm256_imm8;
    
public static Code EVEX_Vpshufhw_zmm_k1z_zmmm512_imm8;
    
public static Code Pshuflw_xmm_xmmm128_imm8;
    
public static Code VEX_Vpshuflw_xmm_xmmm128_imm8;
    
public static Code VEX_Vpshuflw_ymm_ymmm256_imm8;
    
public static Code EVEX_Vpshuflw_xmm_k1z_xmmm128_imm8;
    
public static Code EVEX_Vpshuflw_ymm_k1z_ymmm256_imm8;
    
public static Code EVEX_Vpshuflw_zmm_k1z_zmmm512_imm8;
    
public static Code Psrlw_mm_imm8;
    
public static Code Psrlw_xmm_imm8;
    
public static Code VEX_Vpsrlw_xmm_xmm_imm8;
    
public static Code VEX_Vpsrlw_ymm_ymm_imm8;
    
public static Code EVEX_Vpsrlw_xmm_k1z_xmmm128_imm8;
    
public static Code EVEX_Vpsrlw_ymm_k1z_ymmm256_imm8;
    
public static Code EVEX_Vpsrlw_zmm_k1z_zmmm512_imm8;
    
public static Code Psraw_mm_imm8;
    
public static Code Psraw_xmm_imm8;
    
public static Code VEX_Vpsraw_xmm_xmm_imm8;
    
public static Code VEX_Vpsraw_ymm_ymm_imm8;
    
public static Code EVEX_Vpsraw_xmm_k1z_xmmm128_imm8;
    
public static Code EVEX_Vpsraw_ymm_k1z_ymmm256_imm8;
    
public static Code EVEX_Vpsraw_zmm_k1z_zmmm512_imm8;
    
public static Code Psllw_mm_imm8;
    
public static Code Psllw_xmm_imm8;
    
public static Code VEX_Vpsllw_xmm_xmm_imm8;
    
public static Code VEX_Vpsllw_ymm_ymm_imm8;
    
public static Code EVEX_Vpsllw_xmm_k1z_xmmm128_imm8;
    
public static Code EVEX_Vpsllw_ymm_k1z_ymmm256_imm8;
    
public static Code EVEX_Vpsllw_zmm_k1z_zmmm512_imm8;
    
public static Code EVEX_Vprord_xmm_k1z_xmmm128b32_imm8;
    
public static Code EVEX_Vprord_ymm_k1z_ymmm256b32_imm8;
    
public static Code EVEX_Vprord_zmm_k1z_zmmm512b32_imm8;
    
public static Code EVEX_Vprorq_xmm_k1z_xmmm128b64_imm8;
    
public static Code EVEX_Vprorq_ymm_k1z_ymmm256b64_imm8;
    
public static Code EVEX_Vprorq_zmm_k1z_zmmm512b64_imm8;
    
public static Code EVEX_Vprold_xmm_k1z_xmmm128b32_imm8;
    
public static Code EVEX_Vprold_ymm_k1z_ymmm256b32_imm8;
    
public static Code EVEX_Vprold_zmm_k1z_zmmm512b32_imm8;
    
public static Code EVEX_Vprolq_xmm_k1z_xmmm128b64_imm8;
    
public static Code EVEX_Vprolq_ymm_k1z_ymmm256b64_imm8;
    
public static Code EVEX_Vprolq_zmm_k1z_zmmm512b64_imm8;
    
public static Code Psrld_mm_imm8;
    
public static Code Psrld_xmm_imm8;
    
public static Code VEX_Vpsrld_xmm_xmm_imm8;
    
public static Code VEX_Vpsrld_ymm_ymm_imm8;
    
public static Code EVEX_Vpsrld_xmm_k1z_xmmm128b32_imm8;
    
public static Code EVEX_Vpsrld_ymm_k1z_ymmm256b32_imm8;
    
public static Code EVEX_Vpsrld_zmm_k1z_zmmm512b32_imm8;
    
public static Code Psrad_mm_imm8;
    
public static Code Psrad_xmm_imm8;
    
public static Code VEX_Vpsrad_xmm_xmm_imm8;
    
public static Code VEX_Vpsrad_ymm_ymm_imm8;
    
public static Code EVEX_Vpsrad_xmm_k1z_xmmm128b32_imm8;
    
public static Code EVEX_Vpsrad_ymm_k1z_ymmm256b32_imm8;
    
public static Code EVEX_Vpsrad_zmm_k1z_zmmm512b32_imm8;
    
public static Code EVEX_Vpsraq_xmm_k1z_xmmm128b64_imm8;
    
public static Code EVEX_Vpsraq_ymm_k1z_ymmm256b64_imm8;
    
public static Code EVEX_Vpsraq_zmm_k1z_zmmm512b64_imm8;
    
public static Code Pslld_mm_imm8;
    
public static Code Pslld_xmm_imm8;
    
public static Code VEX_Vpslld_xmm_xmm_imm8;
    
public static Code VEX_Vpslld_ymm_ymm_imm8;
    
public static Code EVEX_Vpslld_xmm_k1z_xmmm128b32_imm8;
    
public static Code EVEX_Vpslld_ymm_k1z_ymmm256b32_imm8;
    
public static Code EVEX_Vpslld_zmm_k1z_zmmm512b32_imm8;
    
public static Code Psrlq_mm_imm8;
    
public static Code Psrlq_xmm_imm8;
    
public static Code VEX_Vpsrlq_xmm_xmm_imm8;
    
public static Code VEX_Vpsrlq_ymm_ymm_imm8;
    
public static Code EVEX_Vpsrlq_xmm_k1z_xmmm128b64_imm8;
    
public static Code EVEX_Vpsrlq_ymm_k1z_ymmm256b64_imm8;
    
public static Code EVEX_Vpsrlq_zmm_k1z_zmmm512b64_imm8;
    
public static Code Psrldq_xmm_imm8;
    
public static Code VEX_Vpsrldq_xmm_xmm_imm8;
    
public static Code VEX_Vpsrldq_ymm_ymm_imm8;
    
public static Code EVEX_Vpsrldq_xmm_xmmm128_imm8;
    
public static Code EVEX_Vpsrldq_ymm_ymmm256_imm8;
    
public static Code EVEX_Vpsrldq_zmm_zmmm512_imm8;
    
public static Code Psllq_mm_imm8;
    
public static Code Psllq_xmm_imm8;
    
public static Code VEX_Vpsllq_xmm_xmm_imm8;
    
public static Code VEX_Vpsllq_ymm_ymm_imm8;
    
public static Code EVEX_Vpsllq_xmm_k1z_xmmm128b64_imm8;
    
public static Code EVEX_Vpsllq_ymm_k1z_ymmm256b64_imm8;
    
public static Code EVEX_Vpsllq_zmm_k1z_zmmm512b64_imm8;
    
public static Code Pslldq_xmm_imm8;
    
public static Code VEX_Vpslldq_xmm_xmm_imm8;
    
public static Code VEX_Vpslldq_ymm_ymm_imm8;
    
public static Code EVEX_Vpslldq_xmm_xmmm128_imm8;
    
public static Code EVEX_Vpslldq_ymm_ymmm256_imm8;
    
public static Code EVEX_Vpslldq_zmm_zmmm512_imm8;
    
public static Code Pcmpeqb_mm_mmm64;
    
public static Code Pcmpeqb_xmm_xmmm128;
    
public static Code VEX_Vpcmpeqb_xmm_xmm_xmmm128;
    
public static Code VEX_Vpcmpeqb_ymm_ymm_ymmm256;
    
public static Code EVEX_Vpcmpeqb_kr_k1_xmm_xmmm128;
    
public static Code EVEX_Vpcmpeqb_kr_k1_ymm_ymmm256;
    
public static Code EVEX_Vpcmpeqb_kr_k1_zmm_zmmm512;
    
public static Code Pcmpeqw_mm_mmm64;
    
public static Code Pcmpeqw_xmm_xmmm128;
    
public static Code VEX_Vpcmpeqw_xmm_xmm_xmmm128;
    
public static Code VEX_Vpcmpeqw_ymm_ymm_ymmm256;
    
public static Code EVEX_Vpcmpeqw_kr_k1_xmm_xmmm128;
    
public static Code EVEX_Vpcmpeqw_kr_k1_ymm_ymmm256;
    
public static Code EVEX_Vpcmpeqw_kr_k1_zmm_zmmm512;
    
public static Code Pcmpeqd_mm_mmm64;
    
public static Code Pcmpeqd_xmm_xmmm128;
    
public static Code VEX_Vpcmpeqd_xmm_xmm_xmmm128;
    
public static Code VEX_Vpcmpeqd_ymm_ymm_ymmm256;
    
public static Code EVEX_Vpcmpeqd_kr_k1_xmm_xmmm128b32;
    
public static Code EVEX_Vpcmpeqd_kr_k1_ymm_ymmm256b32;
    
public static Code EVEX_Vpcmpeqd_kr_k1_zmm_zmmm512b32;
    
public static Code Emms;
    
public static Code VEX_Vzeroupper;
    
public static Code VEX_Vzeroall;
    
public static Code Vmread_rm32_r32;
    
public static Code Vmread_rm64_r64;
    
public static Code EVEX_Vcvttps2udq_xmm_k1z_xmmm128b32;
    
public static Code EVEX_Vcvttps2udq_ymm_k1z_ymmm256b32;
    
public static Code EVEX_Vcvttps2udq_zmm_k1z_zmmm512b32_sae;
    
public static Code EVEX_Vcvttpd2udq_xmm_k1z_xmmm128b64;
    
public static Code EVEX_Vcvttpd2udq_xmm_k1z_ymmm256b64;
    
public static Code EVEX_Vcvttpd2udq_ymm_k1z_zmmm512b64_sae;
    
public static Code Extrq_xmm_imm8_imm8;
    
public static Code EVEX_Vcvttps2uqq_xmm_k1z_xmmm64b32;
    
public static Code EVEX_Vcvttps2uqq_ymm_k1z_xmmm128b32;
    
public static Code EVEX_Vcvttps2uqq_zmm_k1z_ymmm256b32_sae;
    
public static Code EVEX_Vcvttpd2uqq_xmm_k1z_xmmm128b64;
    
public static Code EVEX_Vcvttpd2uqq_ymm_k1z_ymmm256b64;
    
public static Code EVEX_Vcvttpd2uqq_zmm_k1z_zmmm512b64_sae;
    
public static Code EVEX_Vcvttss2usi_r32_xmmm32_sae;
    
public static Code EVEX_Vcvttss2usi_r64_xmmm32_sae;
    
public static Code Insertq_xmm_xmm_imm8_imm8;
    
public static Code EVEX_Vcvttsd2usi_r32_xmmm64_sae;
    
public static Code EVEX_Vcvttsd2usi_r64_xmmm64_sae;
    
public static Code Vmwrite_r32_rm32;
    
public static Code Vmwrite_r64_rm64;
    
public static Code EVEX_Vcvtps2udq_xmm_k1z_xmmm128b32;
    
public static Code EVEX_Vcvtps2udq_ymm_k1z_ymmm256b32;
    
public static Code EVEX_Vcvtps2udq_zmm_k1z_zmmm512b32_er;
    
public static Code EVEX_Vcvtpd2udq_xmm_k1z_xmmm128b64;
    
public static Code EVEX_Vcvtpd2udq_xmm_k1z_ymmm256b64;
    
public static Code EVEX_Vcvtpd2udq_ymm_k1z_zmmm512b64_er;
    
public static Code Extrq_xmm_xmm;
    
public static Code EVEX_Vcvtps2uqq_xmm_k1z_xmmm64b32;
    
public static Code EVEX_Vcvtps2uqq_ymm_k1z_xmmm128b32;
    
public static Code EVEX_Vcvtps2uqq_zmm_k1z_ymmm256b32_er;
    
public static Code EVEX_Vcvtpd2uqq_xmm_k1z_xmmm128b64;
    
public static Code EVEX_Vcvtpd2uqq_ymm_k1z_ymmm256b64;
    
public static Code EVEX_Vcvtpd2uqq_zmm_k1z_zmmm512b64_er;
    
public static Code EVEX_Vcvtss2usi_r32_xmmm32_er;
    
public static Code EVEX_Vcvtss2usi_r64_xmmm32_er;
    
public static Code Insertq_xmm_xmm;
    
public static Code EVEX_Vcvtsd2usi_r32_xmmm64_er;
    
public static Code EVEX_Vcvtsd2usi_r64_xmmm64_er;
    
public static Code EVEX_Vcvttps2qq_xmm_k1z_xmmm64b32;
    
public static Code EVEX_Vcvttps2qq_ymm_k1z_xmmm128b32;
    
public static Code EVEX_Vcvttps2qq_zmm_k1z_ymmm256b32_sae;
    
public static Code EVEX_Vcvttpd2qq_xmm_k1z_xmmm128b64;
    
public static Code EVEX_Vcvttpd2qq_ymm_k1z_ymmm256b64;
    
public static Code EVEX_Vcvttpd2qq_zmm_k1z_zmmm512b64_sae;
    
public static Code EVEX_Vcvtudq2pd_xmm_k1z_xmmm64b32;
    
public static Code EVEX_Vcvtudq2pd_ymm_k1z_xmmm128b32;
    
public static Code EVEX_Vcvtudq2pd_zmm_k1z_ymmm256b32_er;
    
public static Code EVEX_Vcvtuqq2pd_xmm_k1z_xmmm128b64;
    
public static Code EVEX_Vcvtuqq2pd_ymm_k1z_ymmm256b64;
    
public static Code EVEX_Vcvtuqq2pd_zmm_k1z_zmmm512b64_er;
    
public static Code EVEX_Vcvtudq2ps_xmm_k1z_xmmm128b32;
    
public static Code EVEX_Vcvtudq2ps_ymm_k1z_ymmm256b32;
    
public static Code EVEX_Vcvtudq2ps_zmm_k1z_zmmm512b32_er;
    
public static Code EVEX_Vcvtuqq2ps_xmm_k1z_xmmm128b64;
    
public static Code EVEX_Vcvtuqq2ps_xmm_k1z_ymmm256b64;
    
public static Code EVEX_Vcvtuqq2ps_ymm_k1z_zmmm512b64_er;
    
public static Code EVEX_Vcvtps2qq_xmm_k1z_xmmm64b32;
    
public static Code EVEX_Vcvtps2qq_ymm_k1z_xmmm128b32;
    
public static Code EVEX_Vcvtps2qq_zmm_k1z_ymmm256b32_er;
    
public static Code EVEX_Vcvtpd2qq_xmm_k1z_xmmm128b64;
    
public static Code EVEX_Vcvtpd2qq_ymm_k1z_ymmm256b64;
    
public static Code EVEX_Vcvtpd2qq_zmm_k1z_zmmm512b64_er;
    
public static Code EVEX_Vcvtusi2ss_xmm_xmm_rm32_er;
    
public static Code EVEX_Vcvtusi2ss_xmm_xmm_rm64_er;
    
public static Code EVEX_Vcvtusi2sd_xmm_xmm_rm32_er;
    
public static Code EVEX_Vcvtusi2sd_xmm_xmm_rm64_er;
    
public static Code Haddpd_xmm_xmmm128;
    
public static Code VEX_Vhaddpd_xmm_xmm_xmmm128;
    
public static Code VEX_Vhaddpd_ymm_ymm_ymmm256;
    
public static Code Haddps_xmm_xmmm128;
    
public static Code VEX_Vhaddps_xmm_xmm_xmmm128;
    
public static Code VEX_Vhaddps_ymm_ymm_ymmm256;
    
public static Code Hsubpd_xmm_xmmm128;
    
public static Code VEX_Vhsubpd_xmm_xmm_xmmm128;
    
public static Code VEX_Vhsubpd_ymm_ymm_ymmm256;
    
public static Code Hsubps_xmm_xmmm128;
    
public static Code VEX_Vhsubps_xmm_xmm_xmmm128;
    
public static Code VEX_Vhsubps_ymm_ymm_ymmm256;
    
public static Code Movd_rm32_mm;
    
public static Code Movq_rm64_mm;
    
public static Code Movd_rm32_xmm;
    
public static Code Movq_rm64_xmm;
    
public static Code VEX_Vmovd_rm32_xmm;
    
public static Code VEX_Vmovq_rm64_xmm;
    
public static Code EVEX_Vmovd_rm32_xmm;
    
public static Code EVEX_Vmovq_rm64_xmm;
    
public static Code Movq_xmm_xmmm64;
    
public static Code VEX_Vmovq_xmm_xmmm64;
    
public static Code EVEX_Vmovq_xmm_xmmm64;
    
public static Code Movq_mmm64_mm;
    
public static Code Movdqa_xmmm128_xmm;
    
public static Code VEX_Vmovdqa_xmmm128_xmm;
    
public static Code VEX_Vmovdqa_ymmm256_ymm;
    
public static Code EVEX_Vmovdqa32_xmmm128_k1z_xmm;
    
public static Code EVEX_Vmovdqa32_ymmm256_k1z_ymm;
    
public static Code EVEX_Vmovdqa32_zmmm512_k1z_zmm;
    
public static Code EVEX_Vmovdqa64_xmmm128_k1z_xmm;
    
public static Code EVEX_Vmovdqa64_ymmm256_k1z_ymm;
    
public static Code EVEX_Vmovdqa64_zmmm512_k1z_zmm;
    
public static Code Movdqu_xmmm128_xmm;
    
public static Code VEX_Vmovdqu_xmmm128_xmm;
    
public static Code VEX_Vmovdqu_ymmm256_ymm;
    
public static Code EVEX_Vmovdqu32_xmmm128_k1z_xmm;
    
public static Code EVEX_Vmovdqu32_ymmm256_k1z_ymm;
    
public static Code EVEX_Vmovdqu32_zmmm512_k1z_zmm;
    
public static Code EVEX_Vmovdqu64_xmmm128_k1z_xmm;
    
public static Code EVEX_Vmovdqu64_ymmm256_k1z_ymm;
    
public static Code EVEX_Vmovdqu64_zmmm512_k1z_zmm;
    
public static Code EVEX_Vmovdqu8_xmmm128_k1z_xmm;
    
public static Code EVEX_Vmovdqu8_ymmm256_k1z_ymm;
    
public static Code EVEX_Vmovdqu8_zmmm512_k1z_zmm;
    
public static Code EVEX_Vmovdqu16_xmmm128_k1z_xmm;
    
public static Code EVEX_Vmovdqu16_ymmm256_k1z_ymm;
    
public static Code EVEX_Vmovdqu16_zmmm512_k1z_zmm;
    
public static Code Jo_rel16;
    
public static Code Jo_rel32_32;
    
public static Code Jo_rel32_64;
    
public static Code Jno_rel16;
    
public static Code Jno_rel32_32;
    
public static Code Jno_rel32_64;
    
public static Code Jb_rel16;
    
public static Code Jb_rel32_32;
    
public static Code Jb_rel32_64;
    
public static Code Jae_rel16;
    
public static Code Jae_rel32_32;
    
public static Code Jae_rel32_64;
    
public static Code Je_rel16;
    
public static Code Je_rel32_32;
    
public static Code Je_rel32_64;
    
public static Code Jne_rel16;
    
public static Code Jne_rel32_32;
    
public static Code Jne_rel32_64;
    
public static Code Jbe_rel16;
    
public static Code Jbe_rel32_32;
    
public static Code Jbe_rel32_64;
    
public static Code Ja_rel16;
    
public static Code Ja_rel32_32;
    
public static Code Ja_rel32_64;
    
public static Code Js_rel16;
    
public static Code Js_rel32_32;
    
public static Code Js_rel32_64;
    
public static Code Jns_rel16;
    
public static Code Jns_rel32_32;
    
public static Code Jns_rel32_64;
    
public static Code Jp_rel16;
    
public static Code Jp_rel32_32;
    
public static Code Jp_rel32_64;
    
public static Code Jnp_rel16;
    
public static Code Jnp_rel32_32;
    
public static Code Jnp_rel32_64;
    
public static Code Jl_rel16;
    
public static Code Jl_rel32_32;
    
public static Code Jl_rel32_64;
    
public static Code Jge_rel16;
    
public static Code Jge_rel32_32;
    
public static Code Jge_rel32_64;
    
public static Code Jle_rel16;
    
public static Code Jle_rel32_32;
    
public static Code Jle_rel32_64;
    
public static Code Jg_rel16;
    
public static Code Jg_rel32_32;
    
public static Code Jg_rel32_64;
    
public static Code Seto_rm8;
    
public static Code Setno_rm8;
    
public static Code Setb_rm8;
    
public static Code Setae_rm8;
    
public static Code Sete_rm8;
    
public static Code Setne_rm8;
    
public static Code Setbe_rm8;
    
public static Code Seta_rm8;
    
public static Code Sets_rm8;
    
public static Code Setns_rm8;
    
public static Code Setp_rm8;
    
public static Code Setnp_rm8;
    
public static Code Setl_rm8;
    
public static Code Setge_rm8;
    
public static Code Setle_rm8;
    
public static Code Setg_rm8;
    
public static Code VEX_Kmovw_kr_km16;
    
public static Code VEX_Kmovq_kr_km64;
    
public static Code VEX_Kmovb_kr_km8;
    
public static Code VEX_Kmovd_kr_km32;
    
public static Code VEX_Kmovw_m16_kr;
    
public static Code VEX_Kmovq_m64_kr;
    
public static Code VEX_Kmovb_m8_kr;
    
public static Code VEX_Kmovd_m32_kr;
    
public static Code VEX_Kmovw_kr_r32;
    
public static Code VEX_Kmovb_kr_r32;
    
public static Code VEX_Kmovd_kr_r32;
    
public static Code VEX_Kmovq_kr_r64;
    
public static Code VEX_Kmovw_r32_kr;
    
public static Code VEX_Kmovb_r32_kr;
    
public static Code VEX_Kmovd_r32_kr;
    
public static Code VEX_Kmovq_r64_kr;
    
public static Code VEX_Kortestw_kr_kr;
    
public static Code VEX_Kortestq_kr_kr;
    
public static Code VEX_Kortestb_kr_kr;
    
public static Code VEX_Kortestd_kr_kr;
    
public static Code VEX_Ktestw_kr_kr;
    
public static Code VEX_Ktestq_kr_kr;
    
public static Code VEX_Ktestb_kr_kr;
    
public static Code VEX_Ktestd_kr_kr;
    
public static Code Pushw_FS;
    
public static Code Pushd_FS;
    
public static Code Pushq_FS;
    
public static Code Popw_FS;
    
public static Code Popd_FS;
    
public static Code Popq_FS;
    
public static Code Cpuid;
    
public static Code Bt_rm16_r16;
    
public static Code Bt_rm32_r32;
    
public static Code Bt_rm64_r64;
    
public static Code Shld_rm16_r16_imm8;
    
public static Code Shld_rm32_r32_imm8;
    
public static Code Shld_rm64_r64_imm8;
    
public static Code Shld_rm16_r16_CL;
    
public static Code Shld_rm32_r32_CL;
    
public static Code Shld_rm64_r64_CL;
    
public static Code Montmul_16;
    
public static Code Montmul_32;
    
public static Code Montmul_64;
    
public static Code Xsha1_16;
    
public static Code Xsha1_32;
    
public static Code Xsha1_64;
    
public static Code Xsha256_16;
    
public static Code Xsha256_32;
    
public static Code Xsha256_64;
    
public static Code Xbts_r16_rm16;
    
public static Code Xbts_r32_rm32;
    
public static Code Xstore_16;
    
public static Code Xstore_32;
    
public static Code Xstore_64;
    
public static Code Xcryptecb_16;
    
public static Code Xcryptecb_32;
    
public static Code Xcryptecb_64;
    
public static Code Xcryptcbc_16;
    
public static Code Xcryptcbc_32;
    
public static Code Xcryptcbc_64;
    
public static Code Xcryptctr_16;
    
public static Code Xcryptctr_32;
    
public static Code Xcryptctr_64;
    
public static Code Xcryptcfb_16;
    
public static Code Xcryptcfb_32;
    
public static Code Xcryptcfb_64;
    
public static Code Xcryptofb_16;
    
public static Code Xcryptofb_32;
    
public static Code Xcryptofb_64;
    
public static Code Ibts_rm16_r16;
    
public static Code Ibts_rm32_r32;
    
public static Code Cmpxchg486_rm8_r8;
    
public static Code Cmpxchg486_rm16_r16;
    
public static Code Cmpxchg486_rm32_r32;
    
public static Code Pushw_GS;
    
public static Code Pushd_GS;
    
public static Code Pushq_GS;
    
public static Code Popw_GS;
    
public static Code Popd_GS;
    
public static Code Popq_GS;
    
public static Code Rsm;
    
public static Code Bts_rm16_r16;
    
public static Code Bts_rm32_r32;
    
public static Code Bts_rm64_r64;
    
public static Code Shrd_rm16_r16_imm8;
    
public static Code Shrd_rm32_r32_imm8;
    
public static Code Shrd_rm64_r64_imm8;
    
public static Code Shrd_rm16_r16_CL;
    
public static Code Shrd_rm32_r32_CL;
    
public static Code Shrd_rm64_r64_CL;
    
public static Code Fxsave_m512byte;
    
public static Code Fxsave64_m512byte;
    
public static Code Rdfsbase_r32;
    
public static Code Rdfsbase_r64;
    
public static Code Fxrstor_m512byte;
    
public static Code Fxrstor64_m512byte;
    
public static Code Rdgsbase_r32;
    
public static Code Rdgsbase_r64;
    
public static Code Ldmxcsr_m32;
    
public static Code Wrfsbase_r32;
    
public static Code Wrfsbase_r64;
    
public static Code VEX_Vldmxcsr_m32;
    
public static Code Stmxcsr_m32;
    
public static Code Wrgsbase_r32;
    
public static Code Wrgsbase_r64;
    
public static Code VEX_Vstmxcsr_m32;
    
public static Code Xsave_mem;
    
public static Code Xsave64_mem;
    
public static Code Ptwrite_rm32;
    
public static Code Ptwrite_rm64;
    
public static Code Xrstor_mem;
    
public static Code Xrstor64_mem;
    
public static Code Incsspd_r32;
    
public static Code Incsspq_r64;
    
public static Code Xsaveopt_mem;
    
public static Code Xsaveopt64_mem;
    
public static Code Clwb_m8;
    
public static Code Tpause_r32;
    
public static Code Tpause_r64;
    
public static Code Clrssbsy_m64;
    
public static Code Umonitor_r16;
    
public static Code Umonitor_r32;
    
public static Code Umonitor_r64;
    
public static Code Umwait_r32;
    
public static Code Umwait_r64;
    
public static Code Clflush_m8;
    
public static Code Clflushopt_m8;
    
public static Code Lfence;
    
public static Code Lfence_E9;
    
public static Code Lfence_EA;
    
public static Code Lfence_EB;
    
public static Code Lfence_EC;
    
public static Code Lfence_ED;
    
public static Code Lfence_EE;
    
public static Code Lfence_EF;
    
public static Code Mfence;
    
public static Code Mfence_F1;
    
public static Code Mfence_F2;
    
public static Code Mfence_F3;
    
public static Code Mfence_F4;
    
public static Code Mfence_F5;
    
public static Code Mfence_F6;
    
public static Code Mfence_F7;
    
public static Code Sfence;
    
public static Code Sfence_F9;
    
public static Code Sfence_FA;
    
public static Code Sfence_FB;
    
public static Code Sfence_FC;
    
public static Code Sfence_FD;
    
public static Code Sfence_FE;
    
public static Code Sfence_FF;
    
public static Code Pcommit;
    
public static Code Imul_r16_rm16;
    
public static Code Imul_r32_rm32;
    
public static Code Imul_r64_rm64;
    
public static Code Cmpxchg_rm8_r8;
    
public static Code Cmpxchg_rm16_r16;
    
public static Code Cmpxchg_rm32_r32;
    
public static Code Cmpxchg_rm64_r64;
    
public static Code Lss_r16_m1616;
    
public static Code Lss_r32_m1632;
    
public static Code Lss_r64_m1664;
    
public static Code Btr_rm16_r16;
    
public static Code Btr_rm32_r32;
    
public static Code Btr_rm64_r64;
    
public static Code Lfs_r16_m1616;
    
public static Code Lfs_r32_m1632;
    
public static Code Lfs_r64_m1664;
    
public static Code Lgs_r16_m1616;
    
public static Code Lgs_r32_m1632;
    
public static Code Lgs_r64_m1664;
    
public static Code Movzx_r16_rm8;
    
public static Code Movzx_r32_rm8;
    
public static Code Movzx_r64_rm8;
    
public static Code Movzx_r16_rm16;
    
public static Code Movzx_r32_rm16;
    
public static Code Movzx_r64_rm16;
    
public static Code Jmpe_disp16;
    
public static Code Jmpe_disp32;
    
public static Code Popcnt_r16_rm16;
    
public static Code Popcnt_r32_rm32;
    
public static Code Popcnt_r64_rm64;
    
public static Code Ud1_r16_rm16;
    
public static Code Ud1_r32_rm32;
    
public static Code Ud1_r64_rm64;
    
public static Code Bt_rm16_imm8;
    
public static Code Bt_rm32_imm8;
    
public static Code Bt_rm64_imm8;
    
public static Code Bts_rm16_imm8;
    
public static Code Bts_rm32_imm8;
    
public static Code Bts_rm64_imm8;
    
public static Code Btr_rm16_imm8;
    
public static Code Btr_rm32_imm8;
    
public static Code Btr_rm64_imm8;
    
public static Code Btc_rm16_imm8;
    
public static Code Btc_rm32_imm8;
    
public static Code Btc_rm64_imm8;
    
public static Code Btc_rm16_r16;
    
public static Code Btc_rm32_r32;
    
public static Code Btc_rm64_r64;
    
public static Code Bsf_r16_rm16;
    
public static Code Bsf_r32_rm32;
    
public static Code Bsf_r64_rm64;
    
public static Code Tzcnt_r16_rm16;
    
public static Code Tzcnt_r32_rm32;
    
public static Code Tzcnt_r64_rm64;
    
public static Code Bsr_r16_rm16;
    
public static Code Bsr_r32_rm32;
    
public static Code Bsr_r64_rm64;
    
public static Code Lzcnt_r16_rm16;
    
public static Code Lzcnt_r32_rm32;
    
public static Code Lzcnt_r64_rm64;
    
public static Code Movsx_r16_rm8;
    
public static Code Movsx_r32_rm8;
    
public static Code Movsx_r64_rm8;
    
public static Code Movsx_r16_rm16;
    
public static Code Movsx_r32_rm16;
    
public static Code Movsx_r64_rm16;
    
public static Code Xadd_rm8_r8;
    
public static Code Xadd_rm16_r16;
    
public static Code Xadd_rm32_r32;
    
public static Code Xadd_rm64_r64;
    
public static Code Cmpps_xmm_xmmm128_imm8;
    
public static Code VEX_Vcmpps_xmm_xmm_xmmm128_imm8;
    
public static Code VEX_Vcmpps_ymm_ymm_ymmm256_imm8;
    
public static Code EVEX_Vcmpps_kr_k1_xmm_xmmm128b32_imm8;
    
public static Code EVEX_Vcmpps_kr_k1_ymm_ymmm256b32_imm8;
    
public static Code EVEX_Vcmpps_kr_k1_zmm_zmmm512b32_imm8_sae;
    
public static Code Cmppd_xmm_xmmm128_imm8;
    
public static Code VEX_Vcmppd_xmm_xmm_xmmm128_imm8;
    
public static Code VEX_Vcmppd_ymm_ymm_ymmm256_imm8;
    
public static Code EVEX_Vcmppd_kr_k1_xmm_xmmm128b64_imm8;
    
public static Code EVEX_Vcmppd_kr_k1_ymm_ymmm256b64_imm8;
    
public static Code EVEX_Vcmppd_kr_k1_zmm_zmmm512b64_imm8_sae;
    
public static Code Cmpss_xmm_xmmm32_imm8;
    
public static Code VEX_Vcmpss_xmm_xmm_xmmm32_imm8;
    
public static Code EVEX_Vcmpss_kr_k1_xmm_xmmm32_imm8_sae;
    
public static Code Cmpsd_xmm_xmmm64_imm8;
    
public static Code VEX_Vcmpsd_xmm_xmm_xmmm64_imm8;
    
public static Code EVEX_Vcmpsd_kr_k1_xmm_xmmm64_imm8_sae;
    
public static Code Movnti_m32_r32;
    
public static Code Movnti_m64_r64;
    
public static Code Pinsrw_mm_r32m16_imm8;
    
public static Code Pinsrw_mm_r64m16_imm8;
    
public static Code Pinsrw_xmm_r32m16_imm8;
    
public static Code Pinsrw_xmm_r64m16_imm8;
    
public static Code VEX_Vpinsrw_xmm_xmm_r32m16_imm8;
    
public static Code VEX_Vpinsrw_xmm_xmm_r64m16_imm8;
    
public static Code EVEX_Vpinsrw_xmm_xmm_r32m16_imm8;
    
public static Code EVEX_Vpinsrw_xmm_xmm_r64m16_imm8;
    
public static Code Pextrw_r32_mm_imm8;
    
public static Code Pextrw_r64_mm_imm8;
    
public static Code Pextrw_r32_xmm_imm8;
    
public static Code Pextrw_r64_xmm_imm8;
    
public static Code VEX_Vpextrw_r32_xmm_imm8;
    
public static Code VEX_Vpextrw_r64_xmm_imm8;
    
public static Code EVEX_Vpextrw_r32_xmm_imm8;
    
public static Code EVEX_Vpextrw_r64_xmm_imm8;
    
public static Code Shufps_xmm_xmmm128_imm8;
    
public static Code VEX_Vshufps_xmm_xmm_xmmm128_imm8;
    
public static Code VEX_Vshufps_ymm_ymm_ymmm256_imm8;
    
public static Code EVEX_Vshufps_xmm_k1z_xmm_xmmm128b32_imm8;
    
public static Code EVEX_Vshufps_ymm_k1z_ymm_ymmm256b32_imm8;
    
public static Code EVEX_Vshufps_zmm_k1z_zmm_zmmm512b32_imm8;
    
public static Code Shufpd_xmm_xmmm128_imm8;
    
public static Code VEX_Vshufpd_xmm_xmm_xmmm128_imm8;
    
public static Code VEX_Vshufpd_ymm_ymm_ymmm256_imm8;
    
public static Code EVEX_Vshufpd_xmm_k1z_xmm_xmmm128b64_imm8;
    
public static Code EVEX_Vshufpd_ymm_k1z_ymm_ymmm256b64_imm8;
    
public static Code EVEX_Vshufpd_zmm_k1z_zmm_zmmm512b64_imm8;
    
public static Code Cmpxchg8b_m64;
    
public static Code Cmpxchg16b_m128;
    
public static Code Xrstors_mem;
    
public static Code Xrstors64_mem;
    
public static Code Xsavec_mem;
    
public static Code Xsavec64_mem;
    
public static Code Xsaves_mem;
    
public static Code Xsaves64_mem;
    
public static Code Vmptrld_m64;
    
public static Code Vmclear_m64;
    
public static Code Vmxon_m64;
    
public static Code Rdrand_r16;
    
public static Code Rdrand_r32;
    
public static Code Rdrand_r64;
    
public static Code Vmptrst_m64;
    
public static Code Rdseed_r16;
    
public static Code Rdseed_r32;
    
public static Code Rdseed_r64;
    
public static Code Rdpid_r32;
    
public static Code Rdpid_r64;
    
public static Code Bswap_r16;
    
public static Code Bswap_r32;
    
public static Code Bswap_r64;
    
public static Code Addsubpd_xmm_xmmm128;
    
public static Code VEX_Vaddsubpd_xmm_xmm_xmmm128;
    
public static Code VEX_Vaddsubpd_ymm_ymm_ymmm256;
    
public static Code Addsubps_xmm_xmmm128;
    
public static Code VEX_Vaddsubps_xmm_xmm_xmmm128;
    
public static Code VEX_Vaddsubps_ymm_ymm_ymmm256;
    
public static Code Psrlw_mm_mmm64;
    
public static Code Psrlw_xmm_xmmm128;
    
public static Code VEX_Vpsrlw_xmm_xmm_xmmm128;
    
public static Code VEX_Vpsrlw_ymm_ymm_xmmm128;
    
public static Code EVEX_Vpsrlw_xmm_k1z_xmm_xmmm128;
    
public static Code EVEX_Vpsrlw_ymm_k1z_ymm_xmmm128;
    
public static Code EVEX_Vpsrlw_zmm_k1z_zmm_xmmm128;
    
public static Code Psrld_mm_mmm64;
    
public static Code Psrld_xmm_xmmm128;
    
public static Code VEX_Vpsrld_xmm_xmm_xmmm128;
    
public static Code VEX_Vpsrld_ymm_ymm_xmmm128;
    
public static Code EVEX_Vpsrld_xmm_k1z_xmm_xmmm128;
    
public static Code EVEX_Vpsrld_ymm_k1z_ymm_xmmm128;
    
public static Code EVEX_Vpsrld_zmm_k1z_zmm_xmmm128;
    
public static Code Psrlq_mm_mmm64;
    
public static Code Psrlq_xmm_xmmm128;
    
public static Code VEX_Vpsrlq_xmm_xmm_xmmm128;
    
public static Code VEX_Vpsrlq_ymm_ymm_xmmm128;
    
public static Code EVEX_Vpsrlq_xmm_k1z_xmm_xmmm128;
    
public static Code EVEX_Vpsrlq_ymm_k1z_ymm_xmmm128;
    
public static Code EVEX_Vpsrlq_zmm_k1z_zmm_xmmm128;
    
public static Code Paddq_mm_mmm64;
    
public static Code Paddq_xmm_xmmm128;
    
public static Code VEX_Vpaddq_xmm_xmm_xmmm128;
    
public static Code VEX_Vpaddq_ymm_ymm_ymmm256;
    
public static Code EVEX_Vpaddq_xmm_k1z_xmm_xmmm128b64;
    
public static Code EVEX_Vpaddq_ymm_k1z_ymm_ymmm256b64;
    
public static Code EVEX_Vpaddq_zmm_k1z_zmm_zmmm512b64;
    
public static Code Pmullw_mm_mmm64;
    
public static Code Pmullw_xmm_xmmm128;
    
public static Code VEX_Vpmullw_xmm_xmm_xmmm128;
    
public static Code VEX_Vpmullw_ymm_ymm_ymmm256;
    
public static Code EVEX_Vpmullw_xmm_k1z_xmm_xmmm128;
    
public static Code EVEX_Vpmullw_ymm_k1z_ymm_ymmm256;
    
public static Code EVEX_Vpmullw_zmm_k1z_zmm_zmmm512;
    
public static Code Movq_xmmm64_xmm;
    
public static Code VEX_Vmovq_xmmm64_xmm;
    
public static Code EVEX_Vmovq_xmmm64_xmm;
    
public static Code Movq2dq_xmm_mm;
    
public static Code Movdq2q_mm_xmm;
    
public static Code Pmovmskb_r32_mm;
    
public static Code Pmovmskb_r64_mm;
    
public static Code Pmovmskb_r32_xmm;
    
public static Code Pmovmskb_r64_xmm;
    
public static Code VEX_Vpmovmskb_r32_xmm;
    
public static Code VEX_Vpmovmskb_r64_xmm;
    
public static Code VEX_Vpmovmskb_r32_ymm;
    
public static Code VEX_Vpmovmskb_r64_ymm;
    
public static Code Psubusb_mm_mmm64;
    
public static Code Psubusb_xmm_xmmm128;
    
public static Code VEX_Vpsubusb_xmm_xmm_xmmm128;
    
public static Code VEX_Vpsubusb_ymm_ymm_ymmm256;
    
public static Code EVEX_Vpsubusb_xmm_k1z_xmm_xmmm128;
    
public static Code EVEX_Vpsubusb_ymm_k1z_ymm_ymmm256;
    
public static Code EVEX_Vpsubusb_zmm_k1z_zmm_zmmm512;
    
public static Code Psubusw_mm_mmm64;
    
public static Code Psubusw_xmm_xmmm128;
    
public static Code VEX_Vpsubusw_xmm_xmm_xmmm128;
    
public static Code VEX_Vpsubusw_ymm_ymm_ymmm256;
    
public static Code EVEX_Vpsubusw_xmm_k1z_xmm_xmmm128;
    
public static Code EVEX_Vpsubusw_ymm_k1z_ymm_ymmm256;
    
public static Code EVEX_Vpsubusw_zmm_k1z_zmm_zmmm512;
    
public static Code Pminub_mm_mmm64;
    
public static Code Pminub_xmm_xmmm128;
    
public static Code VEX_Vpminub_xmm_xmm_xmmm128;
    
public static Code VEX_Vpminub_ymm_ymm_ymmm256;
    
public static Code EVEX_Vpminub_xmm_k1z_xmm_xmmm128;
    
public static Code EVEX_Vpminub_ymm_k1z_ymm_ymmm256;
    
public static Code EVEX_Vpminub_zmm_k1z_zmm_zmmm512;
    
public static Code Pand_mm_mmm64;
    
public static Code Pand_xmm_xmmm128;
    
public static Code VEX_Vpand_xmm_xmm_xmmm128;
    
public static Code VEX_Vpand_ymm_ymm_ymmm256;
    
public static Code EVEX_Vpandd_xmm_k1z_xmm_xmmm128b32;
    
public static Code EVEX_Vpandd_ymm_k1z_ymm_ymmm256b32;
    
public static Code EVEX_Vpandd_zmm_k1z_zmm_zmmm512b32;
    
public static Code EVEX_Vpandq_xmm_k1z_xmm_xmmm128b64;
    
public static Code EVEX_Vpandq_ymm_k1z_ymm_ymmm256b64;
    
public static Code EVEX_Vpandq_zmm_k1z_zmm_zmmm512b64;
    
public static Code Paddusb_mm_mmm64;
    
public static Code Paddusb_xmm_xmmm128;
    
public static Code VEX_Vpaddusb_xmm_xmm_xmmm128;
    
public static Code VEX_Vpaddusb_ymm_ymm_ymmm256;
    
public static Code EVEX_Vpaddusb_xmm_k1z_xmm_xmmm128;
    
public static Code EVEX_Vpaddusb_ymm_k1z_ymm_ymmm256;
    
public static Code EVEX_Vpaddusb_zmm_k1z_zmm_zmmm512;
    
public static Code Paddusw_mm_mmm64;
    
public static Code Paddusw_xmm_xmmm128;
    
public static Code VEX_Vpaddusw_xmm_xmm_xmmm128;
    
public static Code VEX_Vpaddusw_ymm_ymm_ymmm256;
    
public static Code EVEX_Vpaddusw_xmm_k1z_xmm_xmmm128;
    
public static Code EVEX_Vpaddusw_ymm_k1z_ymm_ymmm256;
    
public static Code EVEX_Vpaddusw_zmm_k1z_zmm_zmmm512;
    
public static Code Pmaxub_mm_mmm64;
    
public static Code Pmaxub_xmm_xmmm128;
    
public static Code VEX_Vpmaxub_xmm_xmm_xmmm128;
    
public static Code VEX_Vpmaxub_ymm_ymm_ymmm256;
    
public static Code EVEX_Vpmaxub_xmm_k1z_xmm_xmmm128;
    
public static Code EVEX_Vpmaxub_ymm_k1z_ymm_ymmm256;
    
public static Code EVEX_Vpmaxub_zmm_k1z_zmm_zmmm512;
    
public static Code Pandn_mm_mmm64;
    
public static Code Pandn_xmm_xmmm128;
    
public static Code VEX_Vpandn_xmm_xmm_xmmm128;
    
public static Code VEX_Vpandn_ymm_ymm_ymmm256;
    
public static Code EVEX_Vpandnd_xmm_k1z_xmm_xmmm128b32;
    
public static Code EVEX_Vpandnd_ymm_k1z_ymm_ymmm256b32;
    
public static Code EVEX_Vpandnd_zmm_k1z_zmm_zmmm512b32;
    
public static Code EVEX_Vpandnq_xmm_k1z_xmm_xmmm128b64;
    
public static Code EVEX_Vpandnq_ymm_k1z_ymm_ymmm256b64;
    
public static Code EVEX_Vpandnq_zmm_k1z_zmm_zmmm512b64;
    
public static Code Pavgb_mm_mmm64;
    
public static Code Pavgb_xmm_xmmm128;
    
public static Code VEX_Vpavgb_xmm_xmm_xmmm128;
    
public static Code VEX_Vpavgb_ymm_ymm_ymmm256;
    
public static Code EVEX_Vpavgb_xmm_k1z_xmm_xmmm128;
    
public static Code EVEX_Vpavgb_ymm_k1z_ymm_ymmm256;
    
public static Code EVEX_Vpavgb_zmm_k1z_zmm_zmmm512;
    
public static Code Psraw_mm_mmm64;
    
public static Code Psraw_xmm_xmmm128;
    
public static Code VEX_Vpsraw_xmm_xmm_xmmm128;
    
public static Code VEX_Vpsraw_ymm_ymm_xmmm128;
    
public static Code EVEX_Vpsraw_xmm_k1z_xmm_xmmm128;
    
public static Code EVEX_Vpsraw_ymm_k1z_ymm_xmmm128;
    
public static Code EVEX_Vpsraw_zmm_k1z_zmm_xmmm128;
    
public static Code Psrad_mm_mmm64;
    
public static Code Psrad_xmm_xmmm128;
    
public static Code VEX_Vpsrad_xmm_xmm_xmmm128;
    
public static Code VEX_Vpsrad_ymm_ymm_xmmm128;
    
public static Code EVEX_Vpsrad_xmm_k1z_xmm_xmmm128;
    
public static Code EVEX_Vpsrad_ymm_k1z_ymm_xmmm128;
    
public static Code EVEX_Vpsrad_zmm_k1z_zmm_xmmm128;
    
public static Code EVEX_Vpsraq_xmm_k1z_xmm_xmmm128;
    
public static Code EVEX_Vpsraq_ymm_k1z_ymm_xmmm128;
    
public static Code EVEX_Vpsraq_zmm_k1z_zmm_xmmm128;
    
public static Code Pavgw_mm_mmm64;
    
public static Code Pavgw_xmm_xmmm128;
    
public static Code VEX_Vpavgw_xmm_xmm_xmmm128;
    
public static Code VEX_Vpavgw_ymm_ymm_ymmm256;
    
public static Code EVEX_Vpavgw_xmm_k1z_xmm_xmmm128;
    
public static Code EVEX_Vpavgw_ymm_k1z_ymm_ymmm256;
    
public static Code EVEX_Vpavgw_zmm_k1z_zmm_zmmm512;
    
public static Code Pmulhuw_mm_mmm64;
    
public static Code Pmulhuw_xmm_xmmm128;
    
public static Code VEX_Vpmulhuw_xmm_xmm_xmmm128;
    
public static Code VEX_Vpmulhuw_ymm_ymm_ymmm256;
    
public static Code EVEX_Vpmulhuw_xmm_k1z_xmm_xmmm128;
    
public static Code EVEX_Vpmulhuw_ymm_k1z_ymm_ymmm256;
    
public static Code EVEX_Vpmulhuw_zmm_k1z_zmm_zmmm512;
    
public static Code Pmulhw_mm_mmm64;
    
public static Code Pmulhw_xmm_xmmm128;
    
public static Code VEX_Vpmulhw_xmm_xmm_xmmm128;
    
public static Code VEX_Vpmulhw_ymm_ymm_ymmm256;
    
public static Code EVEX_Vpmulhw_xmm_k1z_xmm_xmmm128;
    
public static Code EVEX_Vpmulhw_ymm_k1z_ymm_ymmm256;
    
public static Code EVEX_Vpmulhw_zmm_k1z_zmm_zmmm512;
    
public static Code Cvttpd2dq_xmm_xmmm128;
    
public static Code VEX_Vcvttpd2dq_xmm_xmmm128;
    
public static Code VEX_Vcvttpd2dq_xmm_ymmm256;
    
public static Code EVEX_Vcvttpd2dq_xmm_k1z_xmmm128b64;
    
public static Code EVEX_Vcvttpd2dq_xmm_k1z_ymmm256b64;
    
public static Code EVEX_Vcvttpd2dq_ymm_k1z_zmmm512b64_sae;
    
public static Code Cvtdq2pd_xmm_xmmm64;
    
public static Code VEX_Vcvtdq2pd_xmm_xmmm64;
    
public static Code VEX_Vcvtdq2pd_ymm_xmmm128;
    
public static Code EVEX_Vcvtdq2pd_xmm_k1z_xmmm64b32;
    
public static Code EVEX_Vcvtdq2pd_ymm_k1z_xmmm128b32;
    
public static Code EVEX_Vcvtdq2pd_zmm_k1z_ymmm256b32_er;
    
public static Code EVEX_Vcvtqq2pd_xmm_k1z_xmmm128b64;
    
public static Code EVEX_Vcvtqq2pd_ymm_k1z_ymmm256b64;
    
public static Code EVEX_Vcvtqq2pd_zmm_k1z_zmmm512b64_er;
    
public static Code Cvtpd2dq_xmm_xmmm128;
    
public static Code VEX_Vcvtpd2dq_xmm_xmmm128;
    
public static Code VEX_Vcvtpd2dq_xmm_ymmm256;
    
public static Code EVEX_Vcvtpd2dq_xmm_k1z_xmmm128b64;
    
public static Code EVEX_Vcvtpd2dq_xmm_k1z_ymmm256b64;
    
public static Code EVEX_Vcvtpd2dq_ymm_k1z_zmmm512b64_er;
    
public static Code Movntq_m64_mm;
    
public static Code Movntdq_m128_xmm;
    
public static Code VEX_Vmovntdq_m128_xmm;
    
public static Code VEX_Vmovntdq_m256_ymm;
    
public static Code EVEX_Vmovntdq_m128_xmm;
    
public static Code EVEX_Vmovntdq_m256_ymm;
    
public static Code EVEX_Vmovntdq_m512_zmm;
    
public static Code Psubsb_mm_mmm64;
    
public static Code Psubsb_xmm_xmmm128;
    
public static Code VEX_Vpsubsb_xmm_xmm_xmmm128;
    
public static Code VEX_Vpsubsb_ymm_ymm_ymmm256;
    
public static Code EVEX_Vpsubsb_xmm_k1z_xmm_xmmm128;
    
public static Code EVEX_Vpsubsb_ymm_k1z_ymm_ymmm256;
    
public static Code EVEX_Vpsubsb_zmm_k1z_zmm_zmmm512;
    
public static Code Psubsw_mm_mmm64;
    
public static Code Psubsw_xmm_xmmm128;
    
public static Code VEX_Vpsubsw_xmm_xmm_xmmm128;
    
public static Code VEX_Vpsubsw_ymm_ymm_ymmm256;
    
public static Code EVEX_Vpsubsw_xmm_k1z_xmm_xmmm128;
    
public static Code EVEX_Vpsubsw_ymm_k1z_ymm_ymmm256;
    
public static Code EVEX_Vpsubsw_zmm_k1z_zmm_zmmm512;
    
public static Code Pminsw_mm_mmm64;
    
public static Code Pminsw_xmm_xmmm128;
    
public static Code VEX_Vpminsw_xmm_xmm_xmmm128;
    
public static Code VEX_Vpminsw_ymm_ymm_ymmm256;
    
public static Code EVEX_Vpminsw_xmm_k1z_xmm_xmmm128;
    
public static Code EVEX_Vpminsw_ymm_k1z_ymm_ymmm256;
    
public static Code EVEX_Vpminsw_zmm_k1z_zmm_zmmm512;
    
public static Code Por_mm_mmm64;
    
public static Code Por_xmm_xmmm128;
    
public static Code VEX_Vpor_xmm_xmm_xmmm128;
    
public static Code VEX_Vpor_ymm_ymm_ymmm256;
    
public static Code EVEX_Vpord_xmm_k1z_xmm_xmmm128b32;
    
public static Code EVEX_Vpord_ymm_k1z_ymm_ymmm256b32;
    
public static Code EVEX_Vpord_zmm_k1z_zmm_zmmm512b32;
    
public static Code EVEX_Vporq_xmm_k1z_xmm_xmmm128b64;
    
public static Code EVEX_Vporq_ymm_k1z_ymm_ymmm256b64;
    
public static Code EVEX_Vporq_zmm_k1z_zmm_zmmm512b64;
    
public static Code Paddsb_mm_mmm64;
    
public static Code Paddsb_xmm_xmmm128;
    
public static Code VEX_Vpaddsb_xmm_xmm_xmmm128;
    
public static Code VEX_Vpaddsb_ymm_ymm_ymmm256;
    
public static Code EVEX_Vpaddsb_xmm_k1z_xmm_xmmm128;
    
public static Code EVEX_Vpaddsb_ymm_k1z_ymm_ymmm256;
    
public static Code EVEX_Vpaddsb_zmm_k1z_zmm_zmmm512;
    
public static Code Paddsw_mm_mmm64;
    
public static Code Paddsw_xmm_xmmm128;
    
public static Code VEX_Vpaddsw_xmm_xmm_xmmm128;
    
public static Code VEX_Vpaddsw_ymm_ymm_ymmm256;
    
public static Code EVEX_Vpaddsw_xmm_k1z_xmm_xmmm128;
    
public static Code EVEX_Vpaddsw_ymm_k1z_ymm_ymmm256;
    
public static Code EVEX_Vpaddsw_zmm_k1z_zmm_zmmm512;
    
public static Code Pmaxsw_mm_mmm64;
    
public static Code Pmaxsw_xmm_xmmm128;
    
public static Code VEX_Vpmaxsw_xmm_xmm_xmmm128;
    
public static Code VEX_Vpmaxsw_ymm_ymm_ymmm256;
    
public static Code EVEX_Vpmaxsw_xmm_k1z_xmm_xmmm128;
    
public static Code EVEX_Vpmaxsw_ymm_k1z_ymm_ymmm256;
    
public static Code EVEX_Vpmaxsw_zmm_k1z_zmm_zmmm512;
    
public static Code Pxor_mm_mmm64;
    
public static Code Pxor_xmm_xmmm128;
    
public static Code VEX_Vpxor_xmm_xmm_xmmm128;
    
public static Code VEX_Vpxor_ymm_ymm_ymmm256;
    
public static Code EVEX_Vpxord_xmm_k1z_xmm_xmmm128b32;
    
public static Code EVEX_Vpxord_ymm_k1z_ymm_ymmm256b32;
    
public static Code EVEX_Vpxord_zmm_k1z_zmm_zmmm512b32;
    
public static Code EVEX_Vpxorq_xmm_k1z_xmm_xmmm128b64;
    
public static Code EVEX_Vpxorq_ymm_k1z_ymm_ymmm256b64;
    
public static Code EVEX_Vpxorq_zmm_k1z_zmm_zmmm512b64;
    
public static Code Lddqu_xmm_m128;
    
public static Code VEX_Vlddqu_xmm_m128;
    
public static Code VEX_Vlddqu_ymm_m256;
    
public static Code Psllw_mm_mmm64;
    
public static Code Psllw_xmm_xmmm128;
    
public static Code VEX_Vpsllw_xmm_xmm_xmmm128;
    
public static Code VEX_Vpsllw_ymm_ymm_xmmm128;
    
public static Code EVEX_Vpsllw_xmm_k1z_xmm_xmmm128;
    
public static Code EVEX_Vpsllw_ymm_k1z_ymm_xmmm128;
    
public static Code EVEX_Vpsllw_zmm_k1z_zmm_xmmm128;
    
public static Code Pslld_mm_mmm64;
    
public static Code Pslld_xmm_xmmm128;
    
public static Code VEX_Vpslld_xmm_xmm_xmmm128;
    
public static Code VEX_Vpslld_ymm_ymm_xmmm128;
    
public static Code EVEX_Vpslld_xmm_k1z_xmm_xmmm128;
    
public static Code EVEX_Vpslld_ymm_k1z_ymm_xmmm128;
    
public static Code EVEX_Vpslld_zmm_k1z_zmm_xmmm128;
    
public static Code Psllq_mm_mmm64;
    
public static Code Psllq_xmm_xmmm128;
    
public static Code VEX_Vpsllq_xmm_xmm_xmmm128;
    
public static Code VEX_Vpsllq_ymm_ymm_xmmm128;
    
public static Code EVEX_Vpsllq_xmm_k1z_xmm_xmmm128;
    
public static Code EVEX_Vpsllq_ymm_k1z_ymm_xmmm128;
    
public static Code EVEX_Vpsllq_zmm_k1z_zmm_xmmm128;
    
public static Code Pmuludq_mm_mmm64;
    
public static Code Pmuludq_xmm_xmmm128;
    
public static Code VEX_Vpmuludq_xmm_xmm_xmmm128;
    
public static Code VEX_Vpmuludq_ymm_ymm_ymmm256;
    
public static Code EVEX_Vpmuludq_xmm_k1z_xmm_xmmm128b64;
    
public static Code EVEX_Vpmuludq_ymm_k1z_ymm_ymmm256b64;
    
public static Code EVEX_Vpmuludq_zmm_k1z_zmm_zmmm512b64;
    
public static Code Pmaddwd_mm_mmm64;
    
public static Code Pmaddwd_xmm_xmmm128;
    
public static Code VEX_Vpmaddwd_xmm_xmm_xmmm128;
    
public static Code VEX_Vpmaddwd_ymm_ymm_ymmm256;
    
public static Code EVEX_Vpmaddwd_xmm_k1z_xmm_xmmm128;
    
public static Code EVEX_Vpmaddwd_ymm_k1z_ymm_ymmm256;
    
public static Code EVEX_Vpmaddwd_zmm_k1z_zmm_zmmm512;
    
public static Code Psadbw_mm_mmm64;
    
public static Code Psadbw_xmm_xmmm128;
    
public static Code VEX_Vpsadbw_xmm_xmm_xmmm128;
    
public static Code VEX_Vpsadbw_ymm_ymm_ymmm256;
    
public static Code EVEX_Vpsadbw_xmm_xmm_xmmm128;
    
public static Code EVEX_Vpsadbw_ymm_ymm_ymmm256;
    
public static Code EVEX_Vpsadbw_zmm_zmm_zmmm512;
    
public static Code Maskmovq_rDI_mm_mm;
    
public static Code Maskmovdqu_rDI_xmm_xmm;
    
public static Code VEX_Vmaskmovdqu_rDI_xmm_xmm;
    
public static Code Psubb_mm_mmm64;
    
public static Code Psubb_xmm_xmmm128;
    
public static Code VEX_Vpsubb_xmm_xmm_xmmm128;
    
public static Code VEX_Vpsubb_ymm_ymm_ymmm256;
    
public static Code EVEX_Vpsubb_xmm_k1z_xmm_xmmm128;
    
public static Code EVEX_Vpsubb_ymm_k1z_ymm_ymmm256;
    
public static Code EVEX_Vpsubb_zmm_k1z_zmm_zmmm512;
    
public static Code Psubw_mm_mmm64;
    
public static Code Psubw_xmm_xmmm128;
    
public static Code VEX_Vpsubw_xmm_xmm_xmmm128;
    
public static Code VEX_Vpsubw_ymm_ymm_ymmm256;
    
public static Code EVEX_Vpsubw_xmm_k1z_xmm_xmmm128;
    
public static Code EVEX_Vpsubw_ymm_k1z_ymm_ymmm256;
    
public static Code EVEX_Vpsubw_zmm_k1z_zmm_zmmm512;
    
public static Code Psubd_mm_mmm64;
    
public static Code Psubd_xmm_xmmm128;
    
public static Code VEX_Vpsubd_xmm_xmm_xmmm128;
    
public static Code VEX_Vpsubd_ymm_ymm_ymmm256;
    
public static Code EVEX_Vpsubd_xmm_k1z_xmm_xmmm128b32;
    
public static Code EVEX_Vpsubd_ymm_k1z_ymm_ymmm256b32;
    
public static Code EVEX_Vpsubd_zmm_k1z_zmm_zmmm512b32;
    
public static Code Psubq_mm_mmm64;
    
public static Code Psubq_xmm_xmmm128;
    
public static Code VEX_Vpsubq_xmm_xmm_xmmm128;
    
public static Code VEX_Vpsubq_ymm_ymm_ymmm256;
    
public static Code EVEX_Vpsubq_xmm_k1z_xmm_xmmm128b64;
    
public static Code EVEX_Vpsubq_ymm_k1z_ymm_ymmm256b64;
    
public static Code EVEX_Vpsubq_zmm_k1z_zmm_zmmm512b64;
    
public static Code Paddb_mm_mmm64;
    
public static Code Paddb_xmm_xmmm128;
    
public static Code VEX_Vpaddb_xmm_xmm_xmmm128;
    
public static Code VEX_Vpaddb_ymm_ymm_ymmm256;
    
public static Code EVEX_Vpaddb_xmm_k1z_xmm_xmmm128;
    
public static Code EVEX_Vpaddb_ymm_k1z_ymm_ymmm256;
    
public static Code EVEX_Vpaddb_zmm_k1z_zmm_zmmm512;
    
public static Code Paddw_mm_mmm64;
    
public static Code Paddw_xmm_xmmm128;
    
public static Code VEX_Vpaddw_xmm_xmm_xmmm128;
    
public static Code VEX_Vpaddw_ymm_ymm_ymmm256;
    
public static Code EVEX_Vpaddw_xmm_k1z_xmm_xmmm128;
    
public static Code EVEX_Vpaddw_ymm_k1z_ymm_ymmm256;
    
public static Code EVEX_Vpaddw_zmm_k1z_zmm_zmmm512;
    
public static Code Paddd_mm_mmm64;
    
public static Code Paddd_xmm_xmmm128;
    
public static Code VEX_Vpaddd_xmm_xmm_xmmm128;
    
public static Code VEX_Vpaddd_ymm_ymm_ymmm256;
    
public static Code EVEX_Vpaddd_xmm_k1z_xmm_xmmm128b32;
    
public static Code EVEX_Vpaddd_ymm_k1z_ymm_ymmm256b32;
    
public static Code EVEX_Vpaddd_zmm_k1z_zmm_zmmm512b32;
    
public static Code Ud0_r16_rm16;
    
public static Code Ud0_r32_rm32;
    
public static Code Ud0_r64_rm64;
    
public static Code Pshufb_mm_mmm64;
    
public static Code Pshufb_xmm_xmmm128;
    
public static Code VEX_Vpshufb_xmm_xmm_xmmm128;
    
public static Code VEX_Vpshufb_ymm_ymm_ymmm256;
    
public static Code EVEX_Vpshufb_xmm_k1z_xmm_xmmm128;
    
public static Code EVEX_Vpshufb_ymm_k1z_ymm_ymmm256;
    
public static Code EVEX_Vpshufb_zmm_k1z_zmm_zmmm512;
    
public static Code Phaddw_mm_mmm64;
    
public static Code Phaddw_xmm_xmmm128;
    
public static Code VEX_Vphaddw_xmm_xmm_xmmm128;
    
public static Code VEX_Vphaddw_ymm_ymm_ymmm256;
    
public static Code Phaddd_mm_mmm64;
    
public static Code Phaddd_xmm_xmmm128;
    
public static Code VEX_Vphaddd_xmm_xmm_xmmm128;
    
public static Code VEX_Vphaddd_ymm_ymm_ymmm256;
    
public static Code Phaddsw_mm_mmm64;
    
public static Code Phaddsw_xmm_xmmm128;
    
public static Code VEX_Vphaddsw_xmm_xmm_xmmm128;
    
public static Code VEX_Vphaddsw_ymm_ymm_ymmm256;
    
public static Code Pmaddubsw_mm_mmm64;
    
public static Code Pmaddubsw_xmm_xmmm128;
    
public static Code VEX_Vpmaddubsw_xmm_xmm_xmmm128;
    
public static Code VEX_Vpmaddubsw_ymm_ymm_ymmm256;
    
public static Code EVEX_Vpmaddubsw_xmm_k1z_xmm_xmmm128;
    
public static Code EVEX_Vpmaddubsw_ymm_k1z_ymm_ymmm256;
    
public static Code EVEX_Vpmaddubsw_zmm_k1z_zmm_zmmm512;
    
public static Code Phsubw_mm_mmm64;
    
public static Code Phsubw_xmm_xmmm128;
    
public static Code VEX_Vphsubw_xmm_xmm_xmmm128;
    
public static Code VEX_Vphsubw_ymm_ymm_ymmm256;
    
public static Code Phsubd_mm_mmm64;
    
public static Code Phsubd_xmm_xmmm128;
    
public static Code VEX_Vphsubd_xmm_xmm_xmmm128;
    
public static Code VEX_Vphsubd_ymm_ymm_ymmm256;
    
public static Code Phsubsw_mm_mmm64;
    
public static Code Phsubsw_xmm_xmmm128;
    
public static Code VEX_Vphsubsw_xmm_xmm_xmmm128;
    
public static Code VEX_Vphsubsw_ymm_ymm_ymmm256;
    
public static Code Psignb_mm_mmm64;
    
public static Code Psignb_xmm_xmmm128;
    
public static Code VEX_Vpsignb_xmm_xmm_xmmm128;
    
public static Code VEX_Vpsignb_ymm_ymm_ymmm256;
    
public static Code Psignw_mm_mmm64;
    
public static Code Psignw_xmm_xmmm128;
    
public static Code VEX_Vpsignw_xmm_xmm_xmmm128;
    
public static Code VEX_Vpsignw_ymm_ymm_ymmm256;
    
public static Code Psignd_mm_mmm64;
    
public static Code Psignd_xmm_xmmm128;
    
public static Code VEX_Vpsignd_xmm_xmm_xmmm128;
    
public static Code VEX_Vpsignd_ymm_ymm_ymmm256;
    
public static Code Pmulhrsw_mm_mmm64;
    
public static Code Pmulhrsw_xmm_xmmm128;
    
public static Code VEX_Vpmulhrsw_xmm_xmm_xmmm128;
    
public static Code VEX_Vpmulhrsw_ymm_ymm_ymmm256;
    
public static Code EVEX_Vpmulhrsw_xmm_k1z_xmm_xmmm128;
    
public static Code EVEX_Vpmulhrsw_ymm_k1z_ymm_ymmm256;
    
public static Code EVEX_Vpmulhrsw_zmm_k1z_zmm_zmmm512;
    
public static Code VEX_Vpermilps_xmm_xmm_xmmm128;
    
public static Code VEX_Vpermilps_ymm_ymm_ymmm256;
    
public static Code EVEX_Vpermilps_xmm_k1z_xmm_xmmm128b32;
    
public static Code EVEX_Vpermilps_ymm_k1z_ymm_ymmm256b32;
    
public static Code EVEX_Vpermilps_zmm_k1z_zmm_zmmm512b32;
    
public static Code VEX_Vpermilpd_xmm_xmm_xmmm128;
    
public static Code VEX_Vpermilpd_ymm_ymm_ymmm256;
    
public static Code EVEX_Vpermilpd_xmm_k1z_xmm_xmmm128b64;
    
public static Code EVEX_Vpermilpd_ymm_k1z_ymm_ymmm256b64;
    
public static Code EVEX_Vpermilpd_zmm_k1z_zmm_zmmm512b64;
    
public static Code VEX_Vtestps_xmm_xmmm128;
    
public static Code VEX_Vtestps_ymm_ymmm256;
    
public static Code VEX_Vtestpd_xmm_xmmm128;
    
public static Code VEX_Vtestpd_ymm_ymmm256;
    
public static Code Pblendvb_xmm_xmmm128;
    
public static Code EVEX_Vpsrlvw_xmm_k1z_xmm_xmmm128;
    
public static Code EVEX_Vpsrlvw_ymm_k1z_ymm_ymmm256;
    
public static Code EVEX_Vpsrlvw_zmm_k1z_zmm_zmmm512;
    
public static Code EVEX_Vpmovuswb_xmmm64_k1z_xmm;
    
public static Code EVEX_Vpmovuswb_xmmm128_k1z_ymm;
    
public static Code EVEX_Vpmovuswb_ymmm256_k1z_zmm;
    
public static Code EVEX_Vpsravw_xmm_k1z_xmm_xmmm128;
    
public static Code EVEX_Vpsravw_ymm_k1z_ymm_ymmm256;
    
public static Code EVEX_Vpsravw_zmm_k1z_zmm_zmmm512;
    
public static Code EVEX_Vpmovusdb_xmmm32_k1z_xmm;
    
public static Code EVEX_Vpmovusdb_xmmm64_k1z_ymm;
    
public static Code EVEX_Vpmovusdb_xmmm128_k1z_zmm;
    
public static Code EVEX_Vpsllvw_xmm_k1z_xmm_xmmm128;
    
public static Code EVEX_Vpsllvw_ymm_k1z_ymm_ymmm256;
    
public static Code EVEX_Vpsllvw_zmm_k1z_zmm_zmmm512;
    
public static Code EVEX_Vpmovusqb_xmmm16_k1z_xmm;
    
public static Code EVEX_Vpmovusqb_xmmm32_k1z_ymm;
    
public static Code EVEX_Vpmovusqb_xmmm64_k1z_zmm;
    
public static Code VEX_Vcvtph2ps_xmm_xmmm64;
    
public static Code VEX_Vcvtph2ps_ymm_xmmm128;
    
public static Code EVEX_Vcvtph2ps_xmm_k1z_xmmm64;
    
public static Code EVEX_Vcvtph2ps_ymm_k1z_xmmm128;
    
public static Code EVEX_Vcvtph2ps_zmm_k1z_ymmm256_sae;
    
public static Code EVEX_Vpmovusdw_xmmm64_k1z_xmm;
    
public static Code EVEX_Vpmovusdw_xmmm128_k1z_ymm;
    
public static Code EVEX_Vpmovusdw_ymmm256_k1z_zmm;
    
public static Code Blendvps_xmm_xmmm128;
    
public static Code EVEX_Vprorvd_xmm_k1z_xmm_xmmm128b32;
    
public static Code EVEX_Vprorvd_ymm_k1z_ymm_ymmm256b32;
    
public static Code EVEX_Vprorvd_zmm_k1z_zmm_zmmm512b32;
    
public static Code EVEX_Vprorvq_xmm_k1z_xmm_xmmm128b64;
    
public static Code EVEX_Vprorvq_ymm_k1z_ymm_ymmm256b64;
    
public static Code EVEX_Vprorvq_zmm_k1z_zmm_zmmm512b64;
    
public static Code EVEX_Vpmovusqw_xmmm32_k1z_xmm;
    
public static Code EVEX_Vpmovusqw_xmmm64_k1z_ymm;
    
public static Code EVEX_Vpmovusqw_xmmm128_k1z_zmm;
    
public static Code Blendvpd_xmm_xmmm128;
    
public static Code EVEX_Vprolvd_xmm_k1z_xmm_xmmm128b32;
    
public static Code EVEX_Vprolvd_ymm_k1z_ymm_ymmm256b32;
    
public static Code EVEX_Vprolvd_zmm_k1z_zmm_zmmm512b32;
    
public static Code EVEX_Vprolvq_xmm_k1z_xmm_xmmm128b64;
    
public static Code EVEX_Vprolvq_ymm_k1z_ymm_ymmm256b64;
    
public static Code EVEX_Vprolvq_zmm_k1z_zmm_zmmm512b64;
    
public static Code EVEX_Vpmovusqd_xmmm64_k1z_xmm;
    
public static Code EVEX_Vpmovusqd_xmmm128_k1z_ymm;
    
public static Code EVEX_Vpmovusqd_ymmm256_k1z_zmm;
    
public static Code VEX_Vpermps_ymm_ymm_ymmm256;
    
public static Code EVEX_Vpermps_ymm_k1z_ymm_ymmm256b32;
    
public static Code EVEX_Vpermps_zmm_k1z_zmm_zmmm512b32;
    
public static Code EVEX_Vpermpd_ymm_k1z_ymm_ymmm256b64;
    
public static Code EVEX_Vpermpd_zmm_k1z_zmm_zmmm512b64;
    
public static Code Ptest_xmm_xmmm128;
    
public static Code VEX_Vptest_xmm_xmmm128;
    
public static Code VEX_Vptest_ymm_ymmm256;
    
public static Code VEX_Vbroadcastss_xmm_m32;
    
public static Code VEX_Vbroadcastss_ymm_m32;
    
public static Code EVEX_Vbroadcastss_xmm_k1z_xmmm32;
    
public static Code EVEX_Vbroadcastss_ymm_k1z_xmmm32;
    
public static Code EVEX_Vbroadcastss_zmm_k1z_xmmm32;
    
public static Code VEX_Vbroadcastsd_ymm_m64;
    
public static Code EVEX_Vbroadcastf32x2_ymm_k1z_xmmm64;
    
public static Code EVEX_Vbroadcastf32x2_zmm_k1z_xmmm64;
    
public static Code EVEX_Vbroadcastsd_ymm_k1z_xmmm64;
    
public static Code EVEX_Vbroadcastsd_zmm_k1z_xmmm64;
    
public static Code VEX_Vbroadcastf128_ymm_m128;
    
public static Code EVEX_Vbroadcastf32x4_ymm_k1z_m128;
    
public static Code EVEX_Vbroadcastf32x4_zmm_k1z_m128;
    
public static Code EVEX_Vbroadcastf64x2_ymm_k1z_m128;
    
public static Code EVEX_Vbroadcastf64x2_zmm_k1z_m128;
    
public static Code EVEX_Vbroadcastf32x8_zmm_k1z_m256;
    
public static Code EVEX_Vbroadcastf64x4_zmm_k1z_m256;
    
public static Code Pabsb_mm_mmm64;
    
public static Code Pabsb_xmm_xmmm128;
    
public static Code VEX_Vpabsb_xmm_xmmm128;
    
public static Code VEX_Vpabsb_ymm_ymmm256;
    
public static Code EVEX_Vpabsb_xmm_k1z_xmmm128;
    
public static Code EVEX_Vpabsb_ymm_k1z_ymmm256;
    
public static Code EVEX_Vpabsb_zmm_k1z_zmmm512;
    
public static Code Pabsw_mm_mmm64;
    
public static Code Pabsw_xmm_xmmm128;
    
public static Code VEX_Vpabsw_xmm_xmmm128;
    
public static Code VEX_Vpabsw_ymm_ymmm256;
    
public static Code EVEX_Vpabsw_xmm_k1z_xmmm128;
    
public static Code EVEX_Vpabsw_ymm_k1z_ymmm256;
    
public static Code EVEX_Vpabsw_zmm_k1z_zmmm512;
    
public static Code Pabsd_mm_mmm64;
    
public static Code Pabsd_xmm_xmmm128;
    
public static Code VEX_Vpabsd_xmm_xmmm128;
    
public static Code VEX_Vpabsd_ymm_ymmm256;
    
public static Code EVEX_Vpabsd_xmm_k1z_xmmm128b32;
    
public static Code EVEX_Vpabsd_ymm_k1z_ymmm256b32;
    
public static Code EVEX_Vpabsd_zmm_k1z_zmmm512b32;
    
public static Code EVEX_Vpabsq_xmm_k1z_xmmm128b64;
    
public static Code EVEX_Vpabsq_ymm_k1z_ymmm256b64;
    
public static Code EVEX_Vpabsq_zmm_k1z_zmmm512b64;
    
public static Code Pmovsxbw_xmm_xmmm64;
    
public static Code VEX_Vpmovsxbw_xmm_xmmm64;
    
public static Code VEX_Vpmovsxbw_ymm_xmmm128;
    
public static Code EVEX_Vpmovsxbw_xmm_k1z_xmmm64;
    
public static Code EVEX_Vpmovsxbw_ymm_k1z_xmmm128;
    
public static Code EVEX_Vpmovsxbw_zmm_k1z_ymmm256;
    
public static Code EVEX_Vpmovswb_xmmm64_k1z_xmm;
    
public static Code EVEX_Vpmovswb_xmmm128_k1z_ymm;
    
public static Code EVEX_Vpmovswb_ymmm256_k1z_zmm;
    
public static Code Pmovsxbd_xmm_xmmm32;
    
public static Code VEX_Vpmovsxbd_xmm_xmmm32;
    
public static Code VEX_Vpmovsxbd_ymm_xmmm64;
    
public static Code EVEX_Vpmovsxbd_xmm_k1z_xmmm32;
    
public static Code EVEX_Vpmovsxbd_ymm_k1z_xmmm64;
    
public static Code EVEX_Vpmovsxbd_zmm_k1z_xmmm128;
    
public static Code EVEX_Vpmovsdb_xmmm32_k1z_xmm;
    
public static Code EVEX_Vpmovsdb_xmmm64_k1z_ymm;
    
public static Code EVEX_Vpmovsdb_xmmm128_k1z_zmm;
    
public static Code Pmovsxbq_xmm_xmmm16;
    
public static Code VEX_Vpmovsxbq_xmm_xmmm16;
    
public static Code VEX_Vpmovsxbq_ymm_xmmm32;
    
public static Code EVEX_Vpmovsxbq_xmm_k1z_xmmm16;
    
public static Code EVEX_Vpmovsxbq_ymm_k1z_xmmm32;
    
public static Code EVEX_Vpmovsxbq_zmm_k1z_xmmm64;
    
public static Code EVEX_Vpmovsqb_xmmm16_k1z_xmm;
    
public static Code EVEX_Vpmovsqb_xmmm32_k1z_ymm;
    
public static Code EVEX_Vpmovsqb_xmmm64_k1z_zmm;
    
public static Code Pmovsxwd_xmm_xmmm64;
    
public static Code VEX_Vpmovsxwd_xmm_xmmm64;
    
public static Code VEX_Vpmovsxwd_ymm_xmmm128;
    
public static Code EVEX_Vpmovsxwd_xmm_k1z_xmmm64;
    
public static Code EVEX_Vpmovsxwd_ymm_k1z_xmmm128;
    
public static Code EVEX_Vpmovsxwd_zmm_k1z_ymmm256;
    
public static Code EVEX_Vpmovsdw_xmmm64_k1z_xmm;
    
public static Code EVEX_Vpmovsdw_xmmm128_k1z_ymm;
    
public static Code EVEX_Vpmovsdw_ymmm256_k1z_zmm;
    
public static Code Pmovsxwq_xmm_xmmm32;
    
public static Code VEX_Vpmovsxwq_xmm_xmmm32;
    
public static Code VEX_Vpmovsxwq_ymm_xmmm64;
    
public static Code EVEX_Vpmovsxwq_xmm_k1z_xmmm32;
    
public static Code EVEX_Vpmovsxwq_ymm_k1z_xmmm64;
    
public static Code EVEX_Vpmovsxwq_zmm_k1z_xmmm128;
    
public static Code EVEX_Vpmovsqw_xmmm32_k1z_xmm;
    
public static Code EVEX_Vpmovsqw_xmmm64_k1z_ymm;
    
public static Code EVEX_Vpmovsqw_xmmm128_k1z_zmm;
    
public static Code Pmovsxdq_xmm_xmmm64;
    
public static Code VEX_Vpmovsxdq_xmm_xmmm64;
    
public static Code VEX_Vpmovsxdq_ymm_xmmm128;
    
public static Code EVEX_Vpmovsxdq_xmm_k1z_xmmm64;
    
public static Code EVEX_Vpmovsxdq_ymm_k1z_xmmm128;
    
public static Code EVEX_Vpmovsxdq_zmm_k1z_ymmm256;
    
public static Code EVEX_Vpmovsqd_xmmm64_k1z_xmm;
    
public static Code EVEX_Vpmovsqd_xmmm128_k1z_ymm;
    
public static Code EVEX_Vpmovsqd_ymmm256_k1z_zmm;
    
public static Code EVEX_Vptestmb_kr_k1_xmm_xmmm128;
    
public static Code EVEX_Vptestmb_kr_k1_ymm_ymmm256;
    
public static Code EVEX_Vptestmb_kr_k1_zmm_zmmm512;
    
public static Code EVEX_Vptestmw_kr_k1_xmm_xmmm128;
    
public static Code EVEX_Vptestmw_kr_k1_ymm_ymmm256;
    
public static Code EVEX_Vptestmw_kr_k1_zmm_zmmm512;
    
public static Code EVEX_Vptestnmb_kr_k1_xmm_xmmm128;
    
public static Code EVEX_Vptestnmb_kr_k1_ymm_ymmm256;
    
public static Code EVEX_Vptestnmb_kr_k1_zmm_zmmm512;
    
public static Code EVEX_Vptestnmw_kr_k1_xmm_xmmm128;
    
public static Code EVEX_Vptestnmw_kr_k1_ymm_ymmm256;
    
public static Code EVEX_Vptestnmw_kr_k1_zmm_zmmm512;
    
public static Code EVEX_Vptestmd_kr_k1_xmm_xmmm128b32;
    
public static Code EVEX_Vptestmd_kr_k1_ymm_ymmm256b32;
    
public static Code EVEX_Vptestmd_kr_k1_zmm_zmmm512b32;
    
public static Code EVEX_Vptestmq_kr_k1_xmm_xmmm128b64;
    
public static Code EVEX_Vptestmq_kr_k1_ymm_ymmm256b64;
    
public static Code EVEX_Vptestmq_kr_k1_zmm_zmmm512b64;
    
public static Code EVEX_Vptestnmd_kr_k1_xmm_xmmm128b32;
    
public static Code EVEX_Vptestnmd_kr_k1_ymm_ymmm256b32;
    
public static Code EVEX_Vptestnmd_kr_k1_zmm_zmmm512b32;
    
public static Code EVEX_Vptestnmq_kr_k1_xmm_xmmm128b64;
    
public static Code EVEX_Vptestnmq_kr_k1_ymm_ymmm256b64;
    
public static Code EVEX_Vptestnmq_kr_k1_zmm_zmmm512b64;
    
public static Code Pmuldq_xmm_xmmm128;
    
public static Code VEX_Vpmuldq_xmm_xmm_xmmm128;
    
public static Code VEX_Vpmuldq_ymm_ymm_ymmm256;
    
public static Code EVEX_Vpmuldq_xmm_k1z_xmm_xmmm128b64;
    
public static Code EVEX_Vpmuldq_ymm_k1z_ymm_ymmm256b64;
    
public static Code EVEX_Vpmuldq_zmm_k1z_zmm_zmmm512b64;
    
public static Code EVEX_Vpmovm2b_xmm_kr;
    
public static Code EVEX_Vpmovm2b_ymm_kr;
    
public static Code EVEX_Vpmovm2b_zmm_kr;
    
public static Code EVEX_Vpmovm2w_xmm_kr;
    
public static Code EVEX_Vpmovm2w_ymm_kr;
    
public static Code EVEX_Vpmovm2w_zmm_kr;
    
public static Code Pcmpeqq_xmm_xmmm128;
    
public static Code VEX_Vpcmpeqq_xmm_xmm_xmmm128;
    
public static Code VEX_Vpcmpeqq_ymm_ymm_ymmm256;
    
public static Code EVEX_Vpcmpeqq_kr_k1_xmm_xmmm128b64;
    
public static Code EVEX_Vpcmpeqq_kr_k1_ymm_ymmm256b64;
    
public static Code EVEX_Vpcmpeqq_kr_k1_zmm_zmmm512b64;
    
public static Code EVEX_Vpmovb2m_kr_xmm;
    
public static Code EVEX_Vpmovb2m_kr_ymm;
    
public static Code EVEX_Vpmovb2m_kr_zmm;
    
public static Code EVEX_Vpmovw2m_kr_xmm;
    
public static Code EVEX_Vpmovw2m_kr_ymm;
    
public static Code EVEX_Vpmovw2m_kr_zmm;
    
public static Code Movntdqa_xmm_m128;
    
public static Code VEX_Vmovntdqa_xmm_m128;
    
public static Code VEX_Vmovntdqa_ymm_m256;
    
public static Code EVEX_Vmovntdqa_xmm_m128;
    
public static Code EVEX_Vmovntdqa_ymm_m256;
    
public static Code EVEX_Vmovntdqa_zmm_m512;
    
public static Code EVEX_Vpbroadcastmb2q_xmm_kr;
    
public static Code EVEX_Vpbroadcastmb2q_ymm_kr;
    
public static Code EVEX_Vpbroadcastmb2q_zmm_kr;
    
public static Code Packusdw_xmm_xmmm128;
    
public static Code VEX_Vpackusdw_xmm_xmm_xmmm128;
    
public static Code VEX_Vpackusdw_ymm_ymm_ymmm256;
    
public static Code EVEX_Vpackusdw_xmm_k1z_xmm_xmmm128b32;
    
public static Code EVEX_Vpackusdw_ymm_k1z_ymm_ymmm256b32;
    
public static Code EVEX_Vpackusdw_zmm_k1z_zmm_zmmm512b32;
    
public static Code VEX_Vmaskmovps_xmm_xmm_m128;
    
public static Code VEX_Vmaskmovps_ymm_ymm_m256;
    
public static Code EVEX_Vscalefps_xmm_k1z_xmm_xmmm128b32;
    
public static Code EVEX_Vscalefps_ymm_k1z_ymm_ymmm256b32;
    
public static Code EVEX_Vscalefps_zmm_k1z_zmm_zmmm512b32_er;
    
public static Code EVEX_Vscalefpd_xmm_k1z_xmm_xmmm128b64;
    
public static Code EVEX_Vscalefpd_ymm_k1z_ymm_ymmm256b64;
    
public static Code EVEX_Vscalefpd_zmm_k1z_zmm_zmmm512b64_er;
    
public static Code VEX_Vmaskmovpd_xmm_xmm_m128;
    
public static Code VEX_Vmaskmovpd_ymm_ymm_m256;
    
public static Code EVEX_Vscalefss_xmm_k1z_xmm_xmmm32_er;
    
public static Code EVEX_Vscalefsd_xmm_k1z_xmm_xmmm64_er;
    
public static Code VEX_Vmaskmovps_m128_xmm_xmm;
    
public static Code VEX_Vmaskmovps_m256_ymm_ymm;
    
public static Code VEX_Vmaskmovpd_m128_xmm_xmm;
    
public static Code VEX_Vmaskmovpd_m256_ymm_ymm;
    
public static Code Pmovzxbw_xmm_xmmm64;
    
public static Code VEX_Vpmovzxbw_xmm_xmmm64;
    
public static Code VEX_Vpmovzxbw_ymm_xmmm128;
    
public static Code EVEX_Vpmovzxbw_xmm_k1z_xmmm64;
    
public static Code EVEX_Vpmovzxbw_ymm_k1z_xmmm128;
    
public static Code EVEX_Vpmovzxbw_zmm_k1z_ymmm256;
    
public static Code EVEX_Vpmovwb_xmmm64_k1z_xmm;
    
public static Code EVEX_Vpmovwb_xmmm128_k1z_ymm;
    
public static Code EVEX_Vpmovwb_ymmm256_k1z_zmm;
    
public static Code Pmovzxbd_xmm_xmmm32;
    
public static Code VEX_Vpmovzxbd_xmm_xmmm32;
    
public static Code VEX_Vpmovzxbd_ymm_xmmm64;
    
public static Code EVEX_Vpmovzxbd_xmm_k1z_xmmm32;
    
public static Code EVEX_Vpmovzxbd_ymm_k1z_xmmm64;
    
public static Code EVEX_Vpmovzxbd_zmm_k1z_xmmm128;
    
public static Code EVEX_Vpmovdb_xmmm32_k1z_xmm;
    
public static Code EVEX_Vpmovdb_xmmm64_k1z_ymm;
    
public static Code EVEX_Vpmovdb_xmmm128_k1z_zmm;
    
public static Code Pmovzxbq_xmm_xmmm16;
    
public static Code VEX_Vpmovzxbq_xmm_xmmm16;
    
public static Code VEX_Vpmovzxbq_ymm_xmmm32;
    
public static Code EVEX_Vpmovzxbq_xmm_k1z_xmmm16;
    
public static Code EVEX_Vpmovzxbq_ymm_k1z_xmmm32;
    
public static Code EVEX_Vpmovzxbq_zmm_k1z_xmmm64;
    
public static Code EVEX_Vpmovqb_xmmm16_k1z_xmm;
    
public static Code EVEX_Vpmovqb_xmmm32_k1z_ymm;
    
public static Code EVEX_Vpmovqb_xmmm64_k1z_zmm;
    
public static Code Pmovzxwd_xmm_xmmm64;
    
public static Code VEX_Vpmovzxwd_xmm_xmmm64;
    
public static Code VEX_Vpmovzxwd_ymm_xmmm128;
    
public static Code EVEX_Vpmovzxwd_xmm_k1z_xmmm64;
    
public static Code EVEX_Vpmovzxwd_ymm_k1z_xmmm128;
    
public static Code EVEX_Vpmovzxwd_zmm_k1z_ymmm256;
    
public static Code EVEX_Vpmovdw_xmmm64_k1z_xmm;
    
public static Code EVEX_Vpmovdw_xmmm128_k1z_ymm;
    
public static Code EVEX_Vpmovdw_ymmm256_k1z_zmm;
    
public static Code Pmovzxwq_xmm_xmmm32;
    
public static Code VEX_Vpmovzxwq_xmm_xmmm32;
    
public static Code VEX_Vpmovzxwq_ymm_xmmm64;
    
public static Code EVEX_Vpmovzxwq_xmm_k1z_xmmm32;
    
public static Code EVEX_Vpmovzxwq_ymm_k1z_xmmm64;
    
public static Code EVEX_Vpmovzxwq_zmm_k1z_xmmm128;
    
public static Code EVEX_Vpmovqw_xmmm32_k1z_xmm;
    
public static Code EVEX_Vpmovqw_xmmm64_k1z_ymm;
    
public static Code EVEX_Vpmovqw_xmmm128_k1z_zmm;
    
public static Code Pmovzxdq_xmm_xmmm64;
    
public static Code VEX_Vpmovzxdq_xmm_xmmm64;
    
public static Code VEX_Vpmovzxdq_ymm_xmmm128;
    
public static Code EVEX_Vpmovzxdq_xmm_k1z_xmmm64;
    
public static Code EVEX_Vpmovzxdq_ymm_k1z_xmmm128;
    
public static Code EVEX_Vpmovzxdq_zmm_k1z_ymmm256;
    
public static Code EVEX_Vpmovqd_xmmm64_k1z_xmm;
    
public static Code EVEX_Vpmovqd_xmmm128_k1z_ymm;
    
public static Code EVEX_Vpmovqd_ymmm256_k1z_zmm;
    
public static Code VEX_Vpermd_ymm_ymm_ymmm256;
    
public static Code EVEX_Vpermd_ymm_k1z_ymm_ymmm256b32;
    
public static Code EVEX_Vpermd_zmm_k1z_zmm_zmmm512b32;
    
public static Code EVEX_Vpermq_ymm_k1z_ymm_ymmm256b64;
    
public static Code EVEX_Vpermq_zmm_k1z_zmm_zmmm512b64;
    
public static Code Pcmpgtq_xmm_xmmm128;
    
public static Code VEX_Vpcmpgtq_xmm_xmm_xmmm128;
    
public static Code VEX_Vpcmpgtq_ymm_ymm_ymmm256;
    
public static Code EVEX_Vpcmpgtq_kr_k1_xmm_xmmm128b64;
    
public static Code EVEX_Vpcmpgtq_kr_k1_ymm_ymmm256b64;
    
public static Code EVEX_Vpcmpgtq_kr_k1_zmm_zmmm512b64;
    
public static Code Pminsb_xmm_xmmm128;
    
public static Code VEX_Vpminsb_xmm_xmm_xmmm128;
    
public static Code VEX_Vpminsb_ymm_ymm_ymmm256;
    
public static Code EVEX_Vpminsb_xmm_k1z_xmm_xmmm128;
    
public static Code EVEX_Vpminsb_ymm_k1z_ymm_ymmm256;
    
public static Code EVEX_Vpminsb_zmm_k1z_zmm_zmmm512;
    
public static Code EVEX_Vpmovm2d_xmm_kr;
    
public static Code EVEX_Vpmovm2d_ymm_kr;
    
public static Code EVEX_Vpmovm2d_zmm_kr;
    
public static Code EVEX_Vpmovm2q_xmm_kr;
    
public static Code EVEX_Vpmovm2q_ymm_kr;
    
public static Code EVEX_Vpmovm2q_zmm_kr;
    
public static Code Pminsd_xmm_xmmm128;
    
public static Code VEX_Vpminsd_xmm_xmm_xmmm128;
    
public static Code VEX_Vpminsd_ymm_ymm_ymmm256;
    
public static Code EVEX_Vpminsd_xmm_k1z_xmm_xmmm128b32;
    
public static Code EVEX_Vpminsd_ymm_k1z_ymm_ymmm256b32;
    
public static Code EVEX_Vpminsd_zmm_k1z_zmm_zmmm512b32;
    
public static Code EVEX_Vpminsq_xmm_k1z_xmm_xmmm128b64;
    
public static Code EVEX_Vpminsq_ymm_k1z_ymm_ymmm256b64;
    
public static Code EVEX_Vpminsq_zmm_k1z_zmm_zmmm512b64;
    
public static Code EVEX_Vpmovd2m_kr_xmm;
    
public static Code EVEX_Vpmovd2m_kr_ymm;
    
public static Code EVEX_Vpmovd2m_kr_zmm;
    
public static Code EVEX_Vpmovq2m_kr_xmm;
    
public static Code EVEX_Vpmovq2m_kr_ymm;
    
public static Code EVEX_Vpmovq2m_kr_zmm;
    
public static Code Pminuw_xmm_xmmm128;
    
public static Code VEX_Vpminuw_xmm_xmm_xmmm128;
    
public static Code VEX_Vpminuw_ymm_ymm_ymmm256;
    
public static Code EVEX_Vpminuw_xmm_k1z_xmm_xmmm128;
    
public static Code EVEX_Vpminuw_ymm_k1z_ymm_ymmm256;
    
public static Code EVEX_Vpminuw_zmm_k1z_zmm_zmmm512;
    
public static Code EVEX_Vpbroadcastmw2d_xmm_kr;
    
public static Code EVEX_Vpbroadcastmw2d_ymm_kr;
    
public static Code EVEX_Vpbroadcastmw2d_zmm_kr;
    
public static Code Pminud_xmm_xmmm128;
    
public static Code VEX_Vpminud_xmm_xmm_xmmm128;
    
public static Code VEX_Vpminud_ymm_ymm_ymmm256;
    
public static Code EVEX_Vpminud_xmm_k1z_xmm_xmmm128b32;
    
public static Code EVEX_Vpminud_ymm_k1z_ymm_ymmm256b32;
    
public static Code EVEX_Vpminud_zmm_k1z_zmm_zmmm512b32;
    
public static Code EVEX_Vpminuq_xmm_k1z_xmm_xmmm128b64;
    
public static Code EVEX_Vpminuq_ymm_k1z_ymm_ymmm256b64;
    
public static Code EVEX_Vpminuq_zmm_k1z_zmm_zmmm512b64;
    
public static Code Pmaxsb_xmm_xmmm128;
    
public static Code VEX_Vpmaxsb_xmm_xmm_xmmm128;
    
public static Code VEX_Vpmaxsb_ymm_ymm_ymmm256;
    
public static Code EVEX_Vpmaxsb_xmm_k1z_xmm_xmmm128;
    
public static Code EVEX_Vpmaxsb_ymm_k1z_ymm_ymmm256;
    
public static Code EVEX_Vpmaxsb_zmm_k1z_zmm_zmmm512;
    
public static Code Pmaxsd_xmm_xmmm128;
    
public static Code VEX_Vpmaxsd_xmm_xmm_xmmm128;
    
public static Code VEX_Vpmaxsd_ymm_ymm_ymmm256;
    
public static Code EVEX_Vpmaxsd_xmm_k1z_xmm_xmmm128b32;
    
public static Code EVEX_Vpmaxsd_ymm_k1z_ymm_ymmm256b32;
    
public static Code EVEX_Vpmaxsd_zmm_k1z_zmm_zmmm512b32;
    
public static Code EVEX_Vpmaxsq_xmm_k1z_xmm_xmmm128b64;
    
public static Code EVEX_Vpmaxsq_ymm_k1z_ymm_ymmm256b64;
    
public static Code EVEX_Vpmaxsq_zmm_k1z_zmm_zmmm512b64;
    
public static Code Pmaxuw_xmm_xmmm128;
    
public static Code VEX_Vpmaxuw_xmm_xmm_xmmm128;
    
public static Code VEX_Vpmaxuw_ymm_ymm_ymmm256;
    
public static Code EVEX_Vpmaxuw_xmm_k1z_xmm_xmmm128;
    
public static Code EVEX_Vpmaxuw_ymm_k1z_ymm_ymmm256;
    
public static Code EVEX_Vpmaxuw_zmm_k1z_zmm_zmmm512;
    
public static Code Pmaxud_xmm_xmmm128;
    
public static Code VEX_Vpmaxud_xmm_xmm_xmmm128;
    
public static Code VEX_Vpmaxud_ymm_ymm_ymmm256;
    
public static Code EVEX_Vpmaxud_xmm_k1z_xmm_xmmm128b32;
    
public static Code EVEX_Vpmaxud_ymm_k1z_ymm_ymmm256b32;
    
public static Code EVEX_Vpmaxud_zmm_k1z_zmm_zmmm512b32;
    
public static Code EVEX_Vpmaxuq_xmm_k1z_xmm_xmmm128b64;
    
public static Code EVEX_Vpmaxuq_ymm_k1z_ymm_ymmm256b64;
    
public static Code EVEX_Vpmaxuq_zmm_k1z_zmm_zmmm512b64;
    
public static Code Pmulld_xmm_xmmm128;
    
public static Code VEX_Vpmulld_xmm_xmm_xmmm128;
    
public static Code VEX_Vpmulld_ymm_ymm_ymmm256;
    
public static Code EVEX_Vpmulld_xmm_k1z_xmm_xmmm128b32;
    
public static Code EVEX_Vpmulld_ymm_k1z_ymm_ymmm256b32;
    
public static Code EVEX_Vpmulld_zmm_k1z_zmm_zmmm512b32;
    
public static Code EVEX_Vpmullq_xmm_k1z_xmm_xmmm128b64;
    
public static Code EVEX_Vpmullq_ymm_k1z_ymm_ymmm256b64;
    
public static Code EVEX_Vpmullq_zmm_k1z_zmm_zmmm512b64;
    
public static Code Phminposuw_xmm_xmmm128;
    
public static Code VEX_Vphminposuw_xmm_xmmm128;
    
public static Code EVEX_Vgetexpps_xmm_k1z_xmmm128b32;
    
public static Code EVEX_Vgetexpps_ymm_k1z_ymmm256b32;
    
public static Code EVEX_Vgetexpps_zmm_k1z_zmmm512b32_sae;
    
public static Code EVEX_Vgetexppd_xmm_k1z_xmmm128b64;
    
public static Code EVEX_Vgetexppd_ymm_k1z_ymmm256b64;
    
public static Code EVEX_Vgetexppd_zmm_k1z_zmmm512b64_sae;
    
public static Code EVEX_Vgetexpss_xmm_k1z_xmm_xmmm32_sae;
    
public static Code EVEX_Vgetexpsd_xmm_k1z_xmm_xmmm64_sae;
    
public static Code EVEX_Vplzcntd_xmm_k1z_xmmm128b32;
    
public static Code EVEX_Vplzcntd_ymm_k1z_ymmm256b32;
    
public static Code EVEX_Vplzcntd_zmm_k1z_zmmm512b32;
    
public static Code EVEX_Vplzcntq_xmm_k1z_xmmm128b64;
    
public static Code EVEX_Vplzcntq_ymm_k1z_ymmm256b64;
    
public static Code EVEX_Vplzcntq_zmm_k1z_zmmm512b64;
    
public static Code VEX_Vpsrlvd_xmm_xmm_xmmm128;
    
public static Code VEX_Vpsrlvd_ymm_ymm_ymmm256;
    
public static Code VEX_Vpsrlvq_xmm_xmm_xmmm128;
    
public static Code VEX_Vpsrlvq_ymm_ymm_ymmm256;
    
public static Code EVEX_Vpsrlvd_xmm_k1z_xmm_xmmm128b32;
    
public static Code EVEX_Vpsrlvd_ymm_k1z_ymm_ymmm256b32;
    
public static Code EVEX_Vpsrlvd_zmm_k1z_zmm_zmmm512b32;
    
public static Code EVEX_Vpsrlvq_xmm_k1z_xmm_xmmm128b64;
    
public static Code EVEX_Vpsrlvq_ymm_k1z_ymm_ymmm256b64;
    
public static Code EVEX_Vpsrlvq_zmm_k1z_zmm_zmmm512b64;
    
public static Code VEX_Vpsravd_xmm_xmm_xmmm128;
    
public static Code VEX_Vpsravd_ymm_ymm_ymmm256;
    
public static Code EVEX_Vpsravd_xmm_k1z_xmm_xmmm128b32;
    
public static Code EVEX_Vpsravd_ymm_k1z_ymm_ymmm256b32;
    
public static Code EVEX_Vpsravd_zmm_k1z_zmm_zmmm512b32;
    
public static Code EVEX_Vpsravq_xmm_k1z_xmm_xmmm128b64;
    
public static Code EVEX_Vpsravq_ymm_k1z_ymm_ymmm256b64;
    
public static Code EVEX_Vpsravq_zmm_k1z_zmm_zmmm512b64;
    
public static Code VEX_Vpsllvd_xmm_xmm_xmmm128;
    
public static Code VEX_Vpsllvd_ymm_ymm_ymmm256;
    
public static Code VEX_Vpsllvq_xmm_xmm_xmmm128;
    
public static Code VEX_Vpsllvq_ymm_ymm_ymmm256;
    
public static Code EVEX_Vpsllvd_xmm_k1z_xmm_xmmm128b32;
    
public static Code EVEX_Vpsllvd_ymm_k1z_ymm_ymmm256b32;
    
public static Code EVEX_Vpsllvd_zmm_k1z_zmm_zmmm512b32;
    
public static Code EVEX_Vpsllvq_xmm_k1z_xmm_xmmm128b64;
    
public static Code EVEX_Vpsllvq_ymm_k1z_ymm_ymmm256b64;
    
public static Code EVEX_Vpsllvq_zmm_k1z_zmm_zmmm512b64;
    
public static Code EVEX_Vrcp14ps_xmm_k1z_xmmm128b32;
    
public static Code EVEX_Vrcp14ps_ymm_k1z_ymmm256b32;
    
public static Code EVEX_Vrcp14ps_zmm_k1z_zmmm512b32;
    
public static Code EVEX_Vrcp14pd_xmm_k1z_xmmm128b64;
    
public static Code EVEX_Vrcp14pd_ymm_k1z_ymmm256b64;
    
public static Code EVEX_Vrcp14pd_zmm_k1z_zmmm512b64;
    
public static Code EVEX_Vrcp14ss_xmm_k1z_xmm_xmmm32;
    
public static Code EVEX_Vrcp14sd_xmm_k1z_xmm_xmmm64;
    
public static Code EVEX_Vrsqrt14ps_xmm_k1z_xmmm128b32;
    
public static Code EVEX_Vrsqrt14ps_ymm_k1z_ymmm256b32;
    
public static Code EVEX_Vrsqrt14ps_zmm_k1z_zmmm512b32;
    
public static Code EVEX_Vrsqrt14pd_xmm_k1z_xmmm128b64;
    
public static Code EVEX_Vrsqrt14pd_ymm_k1z_ymmm256b64;
    
public static Code EVEX_Vrsqrt14pd_zmm_k1z_zmmm512b64;
    
public static Code EVEX_Vrsqrt14ss_xmm_k1z_xmm_xmmm32;
    
public static Code EVEX_Vrsqrt14sd_xmm_k1z_xmm_xmmm64;
    
public static Code EVEX_Vpdpbusd_xmm_k1z_xmm_xmmm128b32;
    
public static Code EVEX_Vpdpbusd_ymm_k1z_ymm_ymmm256b32;
    
public static Code EVEX_Vpdpbusd_zmm_k1z_zmm_zmmm512b32;
    
public static Code EVEX_Vpdpbusds_xmm_k1z_xmm_xmmm128b32;
    
public static Code EVEX_Vpdpbusds_ymm_k1z_ymm_ymmm256b32;
    
public static Code EVEX_Vpdpbusds_zmm_k1z_zmm_zmmm512b32;
    
public static Code EVEX_Vpdpwssd_xmm_k1z_xmm_xmmm128b32;
    
public static Code EVEX_Vpdpwssd_ymm_k1z_ymm_ymmm256b32;
    
public static Code EVEX_Vpdpwssd_zmm_k1z_zmm_zmmm512b32;
    
public static Code EVEX_Vdpbf16ps_xmm_k1z_xmm_xmmm128b32;
    
public static Code EVEX_Vdpbf16ps_ymm_k1z_ymm_ymmm256b32;
    
public static Code EVEX_Vdpbf16ps_zmm_k1z_zmm_zmmm512b32;
    
public static Code EVEX_Vp4dpwssd_zmm_k1z_zmmp3_m128;
    
public static Code EVEX_Vpdpwssds_xmm_k1z_xmm_xmmm128b32;
    
public static Code EVEX_Vpdpwssds_ymm_k1z_ymm_ymmm256b32;
    
public static Code EVEX_Vpdpwssds_zmm_k1z_zmm_zmmm512b32;
    
public static Code EVEX_Vp4dpwssds_zmm_k1z_zmmp3_m128;
    
public static Code EVEX_Vpopcntb_xmm_k1z_xmmm128;
    
public static Code EVEX_Vpopcntb_ymm_k1z_ymmm256;
    
public static Code EVEX_Vpopcntb_zmm_k1z_zmmm512;
    
public static Code EVEX_Vpopcntw_xmm_k1z_xmmm128;
    
public static Code EVEX_Vpopcntw_ymm_k1z_ymmm256;
    
public static Code EVEX_Vpopcntw_zmm_k1z_zmmm512;
    
public static Code EVEX_Vpopcntd_xmm_k1z_xmmm128b32;
    
public static Code EVEX_Vpopcntd_ymm_k1z_ymmm256b32;
    
public static Code EVEX_Vpopcntd_zmm_k1z_zmmm512b32;
    
public static Code EVEX_Vpopcntq_xmm_k1z_xmmm128b64;
    
public static Code EVEX_Vpopcntq_ymm_k1z_ymmm256b64;
    
public static Code EVEX_Vpopcntq_zmm_k1z_zmmm512b64;
    
public static Code VEX_Vpbroadcastd_xmm_xmmm32;
    
public static Code VEX_Vpbroadcastd_ymm_xmmm32;
    
public static Code EVEX_Vpbroadcastd_xmm_k1z_xmmm32;
    
public static Code EVEX_Vpbroadcastd_ymm_k1z_xmmm32;
    
public static Code EVEX_Vpbroadcastd_zmm_k1z_xmmm32;
    
public static Code VEX_Vpbroadcastq_xmm_xmmm64;
    
public static Code VEX_Vpbroadcastq_ymm_xmmm64;
    
public static Code EVEX_Vbroadcasti32x2_xmm_k1z_xmmm64;
    
public static Code EVEX_Vbroadcasti32x2_ymm_k1z_xmmm64;
    
public static Code EVEX_Vbroadcasti32x2_zmm_k1z_xmmm64;
    
public static Code EVEX_Vpbroadcastq_xmm_k1z_xmmm64;
    
public static Code EVEX_Vpbroadcastq_ymm_k1z_xmmm64;
    
public static Code EVEX_Vpbroadcastq_zmm_k1z_xmmm64;
    
public static Code VEX_Vbroadcasti128_ymm_m128;
    
public static Code EVEX_Vbroadcasti32x4_ymm_k1z_m128;
    
public static Code EVEX_Vbroadcasti32x4_zmm_k1z_m128;
    
public static Code EVEX_Vbroadcasti64x2_ymm_k1z_m128;
    
public static Code EVEX_Vbroadcasti64x2_zmm_k1z_m128;
    
public static Code EVEX_Vbroadcasti32x8_zmm_k1z_m256;
    
public static Code EVEX_Vbroadcasti64x4_zmm_k1z_m256;
    
public static Code EVEX_Vpexpandb_xmm_k1z_xmmm128;
    
public static Code EVEX_Vpexpandb_ymm_k1z_ymmm256;
    
public static Code EVEX_Vpexpandb_zmm_k1z_zmmm512;
    
public static Code EVEX_Vpexpandw_xmm_k1z_xmmm128;
    
public static Code EVEX_Vpexpandw_ymm_k1z_ymmm256;
    
public static Code EVEX_Vpexpandw_zmm_k1z_zmmm512;
    
public static Code EVEX_Vpcompressb_xmmm128_k1z_xmm;
    
public static Code EVEX_Vpcompressb_ymmm256_k1z_ymm;
    
public static Code EVEX_Vpcompressb_zmmm512_k1z_zmm;
    
public static Code EVEX_Vpcompressw_xmmm128_k1z_xmm;
    
public static Code EVEX_Vpcompressw_ymmm256_k1z_ymm;
    
public static Code EVEX_Vpcompressw_zmmm512_k1z_zmm;
    
public static Code EVEX_Vpblendmd_xmm_k1z_xmm_xmmm128b32;
    
public static Code EVEX_Vpblendmd_ymm_k1z_ymm_ymmm256b32;
    
public static Code EVEX_Vpblendmd_zmm_k1z_zmm_zmmm512b32;
    
public static Code EVEX_Vpblendmq_xmm_k1z_xmm_xmmm128b64;
    
public static Code EVEX_Vpblendmq_ymm_k1z_ymm_ymmm256b64;
    
public static Code EVEX_Vpblendmq_zmm_k1z_zmm_zmmm512b64;
    
public static Code EVEX_Vblendmps_xmm_k1z_xmm_xmmm128b32;
    
public static Code EVEX_Vblendmps_ymm_k1z_ymm_ymmm256b32;
    
public static Code EVEX_Vblendmps_zmm_k1z_zmm_zmmm512b32;
    
public static Code EVEX_Vblendmpd_xmm_k1z_xmm_xmmm128b64;
    
public static Code EVEX_Vblendmpd_ymm_k1z_ymm_ymmm256b64;
    
public static Code EVEX_Vblendmpd_zmm_k1z_zmm_zmmm512b64;
    
public static Code EVEX_Vpblendmb_xmm_k1z_xmm_xmmm128;
    
public static Code EVEX_Vpblendmb_ymm_k1z_ymm_ymmm256;
    
public static Code EVEX_Vpblendmb_zmm_k1z_zmm_zmmm512;
    
public static Code EVEX_Vpblendmw_xmm_k1z_xmm_xmmm128;
    
public static Code EVEX_Vpblendmw_ymm_k1z_ymm_ymmm256;
    
public static Code EVEX_Vpblendmw_zmm_k1z_zmm_zmmm512;
    
public static Code EVEX_Vp2intersectd_kp1_xmm_xmmm128b32;
    
public static Code EVEX_Vp2intersectd_kp1_ymm_ymmm256b32;
    
public static Code EVEX_Vp2intersectd_kp1_zmm_zmmm512b32;
    
public static Code EVEX_Vp2intersectq_kp1_xmm_xmmm128b64;
    
public static Code EVEX_Vp2intersectq_kp1_ymm_ymmm256b64;
    
public static Code EVEX_Vp2intersectq_kp1_zmm_zmmm512b64;
    
public static Code EVEX_Vpshldvw_xmm_k1z_xmm_xmmm128;
    
public static Code EVEX_Vpshldvw_ymm_k1z_ymm_ymmm256;
    
public static Code EVEX_Vpshldvw_zmm_k1z_zmm_zmmm512;
    
public static Code EVEX_Vpshldvd_xmm_k1z_xmm_xmmm128b32;
    
public static Code EVEX_Vpshldvd_ymm_k1z_ymm_ymmm256b32;
    
public static Code EVEX_Vpshldvd_zmm_k1z_zmm_zmmm512b32;
    
public static Code EVEX_Vpshldvq_xmm_k1z_xmm_xmmm128b64;
    
public static Code EVEX_Vpshldvq_ymm_k1z_ymm_ymmm256b64;
    
public static Code EVEX_Vpshldvq_zmm_k1z_zmm_zmmm512b64;
    
public static Code EVEX_Vpshrdvw_xmm_k1z_xmm_xmmm128;
    
public static Code EVEX_Vpshrdvw_ymm_k1z_ymm_ymmm256;
    
public static Code EVEX_Vpshrdvw_zmm_k1z_zmm_zmmm512;
    
public static Code EVEX_Vcvtneps2bf16_xmm_k1z_xmmm128b32;
    
public static Code EVEX_Vcvtneps2bf16_xmm_k1z_ymmm256b32;
    
public static Code EVEX_Vcvtneps2bf16_ymm_k1z_zmmm512b32;
    
public static Code EVEX_Vcvtne2ps2bf16_xmm_k1z_xmm_xmmm128b32;
    
public static Code EVEX_Vcvtne2ps2bf16_ymm_k1z_ymm_ymmm256b32;
    
public static Code EVEX_Vcvtne2ps2bf16_zmm_k1z_zmm_zmmm512b32;
    
public static Code EVEX_Vpshrdvd_xmm_k1z_xmm_xmmm128b32;
    
public static Code EVEX_Vpshrdvd_ymm_k1z_ymm_ymmm256b32;
    
public static Code EVEX_Vpshrdvd_zmm_k1z_zmm_zmmm512b32;
    
public static Code EVEX_Vpshrdvq_xmm_k1z_xmm_xmmm128b64;
    
public static Code EVEX_Vpshrdvq_ymm_k1z_ymm_ymmm256b64;
    
public static Code EVEX_Vpshrdvq_zmm_k1z_zmm_zmmm512b64;
    
public static Code EVEX_Vpermi2b_xmm_k1z_xmm_xmmm128;
    
public static Code EVEX_Vpermi2b_ymm_k1z_ymm_ymmm256;
    
public static Code EVEX_Vpermi2b_zmm_k1z_zmm_zmmm512;
    
public static Code EVEX_Vpermi2w_xmm_k1z_xmm_xmmm128;
    
public static Code EVEX_Vpermi2w_ymm_k1z_ymm_ymmm256;
    
public static Code EVEX_Vpermi2w_zmm_k1z_zmm_zmmm512;
    
public static Code EVEX_Vpermi2d_xmm_k1z_xmm_xmmm128b32;
    
public static Code EVEX_Vpermi2d_ymm_k1z_ymm_ymmm256b32;
    
public static Code EVEX_Vpermi2d_zmm_k1z_zmm_zmmm512b32;
    
public static Code EVEX_Vpermi2q_xmm_k1z_xmm_xmmm128b64;
    
public static Code EVEX_Vpermi2q_ymm_k1z_ymm_ymmm256b64;
    
public static Code EVEX_Vpermi2q_zmm_k1z_zmm_zmmm512b64;
    
public static Code EVEX_Vpermi2ps_xmm_k1z_xmm_xmmm128b32;
    
public static Code EVEX_Vpermi2ps_ymm_k1z_ymm_ymmm256b32;
    
public static Code EVEX_Vpermi2ps_zmm_k1z_zmm_zmmm512b32;
    
public static Code EVEX_Vpermi2pd_xmm_k1z_xmm_xmmm128b64;
    
public static Code EVEX_Vpermi2pd_ymm_k1z_ymm_ymmm256b64;
    
public static Code EVEX_Vpermi2pd_zmm_k1z_zmm_zmmm512b64;
    
public static Code VEX_Vpbroadcastb_xmm_xmmm8;
    
public static Code VEX_Vpbroadcastb_ymm_xmmm8;
    
public static Code EVEX_Vpbroadcastb_xmm_k1z_xmmm8;
    
public static Code EVEX_Vpbroadcastb_ymm_k1z_xmmm8;
    
public static Code EVEX_Vpbroadcastb_zmm_k1z_xmmm8;
    
public static Code VEX_Vpbroadcastw_xmm_xmmm16;
    
public static Code VEX_Vpbroadcastw_ymm_xmmm16;
    
public static Code EVEX_Vpbroadcastw_xmm_k1z_xmmm16;
    
public static Code EVEX_Vpbroadcastw_ymm_k1z_xmmm16;
    
public static Code EVEX_Vpbroadcastw_zmm_k1z_xmmm16;
    
public static Code EVEX_Vpbroadcastb_xmm_k1z_r32;
    
public static Code EVEX_Vpbroadcastb_ymm_k1z_r32;
    
public static Code EVEX_Vpbroadcastb_zmm_k1z_r32;
    
public static Code EVEX_Vpbroadcastw_xmm_k1z_r32;
    
public static Code EVEX_Vpbroadcastw_ymm_k1z_r32;
    
public static Code EVEX_Vpbroadcastw_zmm_k1z_r32;
    
public static Code EVEX_Vpbroadcastd_xmm_k1z_r32;
    
public static Code EVEX_Vpbroadcastd_ymm_k1z_r32;
    
public static Code EVEX_Vpbroadcastd_zmm_k1z_r32;
    
public static Code EVEX_Vpbroadcastq_xmm_k1z_r64;
    
public static Code EVEX_Vpbroadcastq_ymm_k1z_r64;
    
public static Code EVEX_Vpbroadcastq_zmm_k1z_r64;
    
public static Code EVEX_Vpermt2b_xmm_k1z_xmm_xmmm128;
    
public static Code EVEX_Vpermt2b_ymm_k1z_ymm_ymmm256;
    
public static Code EVEX_Vpermt2b_zmm_k1z_zmm_zmmm512;
    
public static Code EVEX_Vpermt2w_xmm_k1z_xmm_xmmm128;
    
public static Code EVEX_Vpermt2w_ymm_k1z_ymm_ymmm256;
    
public static Code EVEX_Vpermt2w_zmm_k1z_zmm_zmmm512;
    
public static Code EVEX_Vpermt2d_xmm_k1z_xmm_xmmm128b32;
    
public static Code EVEX_Vpermt2d_ymm_k1z_ymm_ymmm256b32;
    
public static Code EVEX_Vpermt2d_zmm_k1z_zmm_zmmm512b32;
    
public static Code EVEX_Vpermt2q_xmm_k1z_xmm_xmmm128b64;
    
public static Code EVEX_Vpermt2q_ymm_k1z_ymm_ymmm256b64;
    
public static Code EVEX_Vpermt2q_zmm_k1z_zmm_zmmm512b64;
    
public static Code EVEX_Vpermt2ps_xmm_k1z_xmm_xmmm128b32;
    
public static Code EVEX_Vpermt2ps_ymm_k1z_ymm_ymmm256b32;
    
public static Code EVEX_Vpermt2ps_zmm_k1z_zmm_zmmm512b32;
    
public static Code EVEX_Vpermt2pd_xmm_k1z_xmm_xmmm128b64;
    
public static Code EVEX_Vpermt2pd_ymm_k1z_ymm_ymmm256b64;
    
public static Code EVEX_Vpermt2pd_zmm_k1z_zmm_zmmm512b64;
    
public static Code Invept_r32_m128;
    
public static Code Invept_r64_m128;
    
public static Code Invvpid_r32_m128;
    
public static Code Invvpid_r64_m128;
    
public static Code Invpcid_r32_m128;
    
public static Code Invpcid_r64_m128;
    
public static Code EVEX_Vpmultishiftqb_xmm_k1z_xmm_xmmm128b64;
    
public static Code EVEX_Vpmultishiftqb_ymm_k1z_ymm_ymmm256b64;
    
public static Code EVEX_Vpmultishiftqb_zmm_k1z_zmm_zmmm512b64;
    
public static Code EVEX_Vexpandps_xmm_k1z_xmmm128;
    
public static Code EVEX_Vexpandps_ymm_k1z_ymmm256;
    
public static Code EVEX_Vexpandps_zmm_k1z_zmmm512;
    
public static Code EVEX_Vexpandpd_xmm_k1z_xmmm128;
    
public static Code EVEX_Vexpandpd_ymm_k1z_ymmm256;
    
public static Code EVEX_Vexpandpd_zmm_k1z_zmmm512;
    
public static Code EVEX_Vpexpandd_xmm_k1z_xmmm128;
    
public static Code EVEX_Vpexpandd_ymm_k1z_ymmm256;
    
public static Code EVEX_Vpexpandd_zmm_k1z_zmmm512;
    
public static Code EVEX_Vpexpandq_xmm_k1z_xmmm128;
    
public static Code EVEX_Vpexpandq_ymm_k1z_ymmm256;
    
public static Code EVEX_Vpexpandq_zmm_k1z_zmmm512;
    
public static Code EVEX_Vcompressps_xmmm128_k1z_xmm;
    
public static Code EVEX_Vcompressps_ymmm256_k1z_ymm;
    
public static Code EVEX_Vcompressps_zmmm512_k1z_zmm;
    
public static Code EVEX_Vcompresspd_xmmm128_k1z_xmm;
    
public static Code EVEX_Vcompresspd_ymmm256_k1z_ymm;
    
public static Code EVEX_Vcompresspd_zmmm512_k1z_zmm;
    
public static Code EVEX_Vpcompressd_xmmm128_k1z_xmm;
    
public static Code EVEX_Vpcompressd_ymmm256_k1z_ymm;
    
public static Code EVEX_Vpcompressd_zmmm512_k1z_zmm;
    
public static Code EVEX_Vpcompressq_xmmm128_k1z_xmm;
    
public static Code EVEX_Vpcompressq_ymmm256_k1z_ymm;
    
public static Code EVEX_Vpcompressq_zmmm512_k1z_zmm;
    
public static Code VEX_Vpmaskmovd_xmm_xmm_m128;
    
public static Code VEX_Vpmaskmovd_ymm_ymm_m256;
    
public static Code VEX_Vpmaskmovq_xmm_xmm_m128;
    
public static Code VEX_Vpmaskmovq_ymm_ymm_m256;
    
public static Code EVEX_Vpermb_xmm_k1z_xmm_xmmm128;
    
public static Code EVEX_Vpermb_ymm_k1z_ymm_ymmm256;
    
public static Code EVEX_Vpermb_zmm_k1z_zmm_zmmm512;
    
public static Code EVEX_Vpermw_xmm_k1z_xmm_xmmm128;
    
public static Code EVEX_Vpermw_ymm_k1z_ymm_ymmm256;
    
public static Code EVEX_Vpermw_zmm_k1z_zmm_zmmm512;
    
public static Code VEX_Vpmaskmovd_m128_xmm_xmm;
    
public static Code VEX_Vpmaskmovd_m256_ymm_ymm;
    
public static Code VEX_Vpmaskmovq_m128_xmm_xmm;
    
public static Code VEX_Vpmaskmovq_m256_ymm_ymm;
    
public static Code EVEX_Vpshufbitqmb_kr_k1_xmm_xmmm128;
    
public static Code EVEX_Vpshufbitqmb_kr_k1_ymm_ymmm256;
    
public static Code EVEX_Vpshufbitqmb_kr_k1_zmm_zmmm512;
    
public static Code VEX_Vpgatherdd_xmm_vm32x_xmm;
    
public static Code VEX_Vpgatherdd_ymm_vm32y_ymm;
    
public static Code VEX_Vpgatherdq_xmm_vm32x_xmm;
    
public static Code VEX_Vpgatherdq_ymm_vm32x_ymm;
    
public static Code EVEX_Vpgatherdd_xmm_k1_vm32x;
    
public static Code EVEX_Vpgatherdd_ymm_k1_vm32y;
    
public static Code EVEX_Vpgatherdd_zmm_k1_vm32z;
    
public static Code EVEX_Vpgatherdq_xmm_k1_vm32x;
    
public static Code EVEX_Vpgatherdq_ymm_k1_vm32x;
    
public static Code EVEX_Vpgatherdq_zmm_k1_vm32y;
    
public static Code VEX_Vpgatherqd_xmm_vm64x_xmm;
    
public static Code VEX_Vpgatherqd_xmm_vm64y_xmm;
    
public static Code VEX_Vpgatherqq_xmm_vm64x_xmm;
    
public static Code VEX_Vpgatherqq_ymm_vm64y_ymm;
    
public static Code EVEX_Vpgatherqd_xmm_k1_vm64x;
    
public static Code EVEX_Vpgatherqd_xmm_k1_vm64y;
    
public static Code EVEX_Vpgatherqd_ymm_k1_vm64z;
    
public static Code EVEX_Vpgatherqq_xmm_k1_vm64x;
    
public static Code EVEX_Vpgatherqq_ymm_k1_vm64y;
    
public static Code EVEX_Vpgatherqq_zmm_k1_vm64z;
    
public static Code VEX_Vgatherdps_xmm_vm32x_xmm;
    
public static Code VEX_Vgatherdps_ymm_vm32y_ymm;
    
public static Code VEX_Vgatherdpd_xmm_vm32x_xmm;
    
public static Code VEX_Vgatherdpd_ymm_vm32x_ymm;
    
public static Code EVEX_Vgatherdps_xmm_k1_vm32x;
    
public static Code EVEX_Vgatherdps_ymm_k1_vm32y;
    
public static Code EVEX_Vgatherdps_zmm_k1_vm32z;
    
public static Code EVEX_Vgatherdpd_xmm_k1_vm32x;
    
public static Code EVEX_Vgatherdpd_ymm_k1_vm32x;
    
public static Code EVEX_Vgatherdpd_zmm_k1_vm32y;
    
public static Code VEX_Vgatherqps_xmm_vm64x_xmm;
    
public static Code VEX_Vgatherqps_xmm_vm64y_xmm;
    
public static Code VEX_Vgatherqpd_xmm_vm64x_xmm;
    
public static Code VEX_Vgatherqpd_ymm_vm64y_ymm;
    
public static Code EVEX_Vgatherqps_xmm_k1_vm64x;
    
public static Code EVEX_Vgatherqps_xmm_k1_vm64y;
    
public static Code EVEX_Vgatherqps_ymm_k1_vm64z;
    
public static Code EVEX_Vgatherqpd_xmm_k1_vm64x;
    
public static Code EVEX_Vgatherqpd_ymm_k1_vm64y;
    
public static Code EVEX_Vgatherqpd_zmm_k1_vm64z;
    
public static Code VEX_Vfmaddsub132ps_xmm_xmm_xmmm128;
    
public static Code VEX_Vfmaddsub132ps_ymm_ymm_ymmm256;
    
public static Code VEX_Vfmaddsub132pd_xmm_xmm_xmmm128;
    
public static Code VEX_Vfmaddsub132pd_ymm_ymm_ymmm256;
    
public static Code EVEX_Vfmaddsub132ps_xmm_k1z_xmm_xmmm128b32;
    
public static Code EVEX_Vfmaddsub132ps_ymm_k1z_ymm_ymmm256b32;
    
public static Code EVEX_Vfmaddsub132ps_zmm_k1z_zmm_zmmm512b32_er;
    
public static Code EVEX_Vfmaddsub132pd_xmm_k1z_xmm_xmmm128b64;
    
public static Code EVEX_Vfmaddsub132pd_ymm_k1z_ymm_ymmm256b64;
    
public static Code EVEX_Vfmaddsub132pd_zmm_k1z_zmm_zmmm512b64_er;
    
public static Code VEX_Vfmsubadd132ps_xmm_xmm_xmmm128;
    
public static Code VEX_Vfmsubadd132ps_ymm_ymm_ymmm256;
    
public static Code VEX_Vfmsubadd132pd_xmm_xmm_xmmm128;
    
public static Code VEX_Vfmsubadd132pd_ymm_ymm_ymmm256;
    
public static Code EVEX_Vfmsubadd132ps_xmm_k1z_xmm_xmmm128b32;
    
public static Code EVEX_Vfmsubadd132ps_ymm_k1z_ymm_ymmm256b32;
    
public static Code EVEX_Vfmsubadd132ps_zmm_k1z_zmm_zmmm512b32_er;
    
public static Code EVEX_Vfmsubadd132pd_xmm_k1z_xmm_xmmm128b64;
    
public static Code EVEX_Vfmsubadd132pd_ymm_k1z_ymm_ymmm256b64;
    
public static Code EVEX_Vfmsubadd132pd_zmm_k1z_zmm_zmmm512b64_er;
    
public static Code VEX_Vfmadd132ps_xmm_xmm_xmmm128;
    
public static Code VEX_Vfmadd132ps_ymm_ymm_ymmm256;
    
public static Code VEX_Vfmadd132pd_xmm_xmm_xmmm128;
    
public static Code VEX_Vfmadd132pd_ymm_ymm_ymmm256;
    
public static Code EVEX_Vfmadd132ps_xmm_k1z_xmm_xmmm128b32;
    
public static Code EVEX_Vfmadd132ps_ymm_k1z_ymm_ymmm256b32;
    
public static Code EVEX_Vfmadd132ps_zmm_k1z_zmm_zmmm512b32_er;
    
public static Code EVEX_Vfmadd132pd_xmm_k1z_xmm_xmmm128b64;
    
public static Code EVEX_Vfmadd132pd_ymm_k1z_ymm_ymmm256b64;
    
public static Code EVEX_Vfmadd132pd_zmm_k1z_zmm_zmmm512b64_er;
    
public static Code VEX_Vfmadd132ss_xmm_xmm_xmmm32;
    
public static Code VEX_Vfmadd132sd_xmm_xmm_xmmm64;
    
public static Code EVEX_Vfmadd132ss_xmm_k1z_xmm_xmmm32_er;
    
public static Code EVEX_Vfmadd132sd_xmm_k1z_xmm_xmmm64_er;
    
public static Code VEX_Vfmsub132ps_xmm_xmm_xmmm128;
    
public static Code VEX_Vfmsub132ps_ymm_ymm_ymmm256;
    
public static Code VEX_Vfmsub132pd_xmm_xmm_xmmm128;
    
public static Code VEX_Vfmsub132pd_ymm_ymm_ymmm256;
    
public static Code EVEX_Vfmsub132ps_xmm_k1z_xmm_xmmm128b32;
    
public static Code EVEX_Vfmsub132ps_ymm_k1z_ymm_ymmm256b32;
    
public static Code EVEX_Vfmsub132ps_zmm_k1z_zmm_zmmm512b32_er;
    
public static Code EVEX_Vfmsub132pd_xmm_k1z_xmm_xmmm128b64;
    
public static Code EVEX_Vfmsub132pd_ymm_k1z_ymm_ymmm256b64;
    
public static Code EVEX_Vfmsub132pd_zmm_k1z_zmm_zmmm512b64_er;
    
public static Code EVEX_V4fmaddps_zmm_k1z_zmmp3_m128;
    
public static Code VEX_Vfmsub132ss_xmm_xmm_xmmm32;
    
public static Code VEX_Vfmsub132sd_xmm_xmm_xmmm64;
    
public static Code EVEX_Vfmsub132ss_xmm_k1z_xmm_xmmm32_er;
    
public static Code EVEX_Vfmsub132sd_xmm_k1z_xmm_xmmm64_er;
    
public static Code EVEX_V4fmaddss_xmm_k1z_xmmp3_m128;
    
public static Code VEX_Vfnmadd132ps_xmm_xmm_xmmm128;
    
public static Code VEX_Vfnmadd132ps_ymm_ymm_ymmm256;
    
public static Code VEX_Vfnmadd132pd_xmm_xmm_xmmm128;
    
public static Code VEX_Vfnmadd132pd_ymm_ymm_ymmm256;
    
public static Code EVEX_Vfnmadd132ps_xmm_k1z_xmm_xmmm128b32;
    
public static Code EVEX_Vfnmadd132ps_ymm_k1z_ymm_ymmm256b32;
    
public static Code EVEX_Vfnmadd132ps_zmm_k1z_zmm_zmmm512b32_er;
    
public static Code EVEX_Vfnmadd132pd_xmm_k1z_xmm_xmmm128b64;
    
public static Code EVEX_Vfnmadd132pd_ymm_k1z_ymm_ymmm256b64;
    
public static Code EVEX_Vfnmadd132pd_zmm_k1z_zmm_zmmm512b64_er;
    
public static Code VEX_Vfnmadd132ss_xmm_xmm_xmmm32;
    
public static Code VEX_Vfnmadd132sd_xmm_xmm_xmmm64;
    
public static Code EVEX_Vfnmadd132ss_xmm_k1z_xmm_xmmm32_er;
    
public static Code EVEX_Vfnmadd132sd_xmm_k1z_xmm_xmmm64_er;
    
public static Code VEX_Vfnmsub132ps_xmm_xmm_xmmm128;
    
public static Code VEX_Vfnmsub132ps_ymm_ymm_ymmm256;
    
public static Code VEX_Vfnmsub132pd_xmm_xmm_xmmm128;
    
public static Code VEX_Vfnmsub132pd_ymm_ymm_ymmm256;
    
public static Code EVEX_Vfnmsub132ps_xmm_k1z_xmm_xmmm128b32;
    
public static Code EVEX_Vfnmsub132ps_ymm_k1z_ymm_ymmm256b32;
    
public static Code EVEX_Vfnmsub132ps_zmm_k1z_zmm_zmmm512b32_er;
    
public static Code EVEX_Vfnmsub132pd_xmm_k1z_xmm_xmmm128b64;
    
public static Code EVEX_Vfnmsub132pd_ymm_k1z_ymm_ymmm256b64;
    
public static Code EVEX_Vfnmsub132pd_zmm_k1z_zmm_zmmm512b64_er;
    
public static Code VEX_Vfnmsub132ss_xmm_xmm_xmmm32;
    
public static Code VEX_Vfnmsub132sd_xmm_xmm_xmmm64;
    
public static Code EVEX_Vfnmsub132ss_xmm_k1z_xmm_xmmm32_er;
    
public static Code EVEX_Vfnmsub132sd_xmm_k1z_xmm_xmmm64_er;
    
public static Code EVEX_Vpscatterdd_vm32x_k1_xmm;
    
public static Code EVEX_Vpscatterdd_vm32y_k1_ymm;
    
public static Code EVEX_Vpscatterdd_vm32z_k1_zmm;
    
public static Code EVEX_Vpscatterdq_vm32x_k1_xmm;
    
public static Code EVEX_Vpscatterdq_vm32x_k1_ymm;
    
public static Code EVEX_Vpscatterdq_vm32y_k1_zmm;
    
public static Code EVEX_Vpscatterqd_vm64x_k1_xmm;
    
public static Code EVEX_Vpscatterqd_vm64y_k1_xmm;
    
public static Code EVEX_Vpscatterqd_vm64z_k1_ymm;
    
public static Code EVEX_Vpscatterqq_vm64x_k1_xmm;
    
public static Code EVEX_Vpscatterqq_vm64y_k1_ymm;
    
public static Code EVEX_Vpscatterqq_vm64z_k1_zmm;
    
public static Code EVEX_Vscatterdps_vm32x_k1_xmm;
    
public static Code EVEX_Vscatterdps_vm32y_k1_ymm;
    
public static Code EVEX_Vscatterdps_vm32z_k1_zmm;
    
public static Code EVEX_Vscatterdpd_vm32x_k1_xmm;
    
public static Code EVEX_Vscatterdpd_vm32x_k1_ymm;
    
public static Code EVEX_Vscatterdpd_vm32y_k1_zmm;
    
public static Code EVEX_Vscatterqps_vm64x_k1_xmm;
    
public static Code EVEX_Vscatterqps_vm64y_k1_xmm;
    
public static Code EVEX_Vscatterqps_vm64z_k1_ymm;
    
public static Code EVEX_Vscatterqpd_vm64x_k1_xmm;
    
public static Code EVEX_Vscatterqpd_vm64y_k1_ymm;
    
public static Code EVEX_Vscatterqpd_vm64z_k1_zmm;
    
public static Code VEX_Vfmaddsub213ps_xmm_xmm_xmmm128;
    
public static Code VEX_Vfmaddsub213ps_ymm_ymm_ymmm256;
    
public static Code VEX_Vfmaddsub213pd_xmm_xmm_xmmm128;
    
public static Code VEX_Vfmaddsub213pd_ymm_ymm_ymmm256;
    
public static Code EVEX_Vfmaddsub213ps_xmm_k1z_xmm_xmmm128b32;
    
public static Code EVEX_Vfmaddsub213ps_ymm_k1z_ymm_ymmm256b32;
    
public static Code EVEX_Vfmaddsub213ps_zmm_k1z_zmm_zmmm512b32_er;
    
public static Code EVEX_Vfmaddsub213pd_xmm_k1z_xmm_xmmm128b64;
    
public static Code EVEX_Vfmaddsub213pd_ymm_k1z_ymm_ymmm256b64;
    
public static Code EVEX_Vfmaddsub213pd_zmm_k1z_zmm_zmmm512b64_er;
    
public static Code VEX_Vfmsubadd213ps_xmm_xmm_xmmm128;
    
public static Code VEX_Vfmsubadd213ps_ymm_ymm_ymmm256;
    
public static Code VEX_Vfmsubadd213pd_xmm_xmm_xmmm128;
    
public static Code VEX_Vfmsubadd213pd_ymm_ymm_ymmm256;
    
public static Code EVEX_Vfmsubadd213ps_xmm_k1z_xmm_xmmm128b32;
    
public static Code EVEX_Vfmsubadd213ps_ymm_k1z_ymm_ymmm256b32;
    
public static Code EVEX_Vfmsubadd213ps_zmm_k1z_zmm_zmmm512b32_er;
    
public static Code EVEX_Vfmsubadd213pd_xmm_k1z_xmm_xmmm128b64;
    
public static Code EVEX_Vfmsubadd213pd_ymm_k1z_ymm_ymmm256b64;
    
public static Code EVEX_Vfmsubadd213pd_zmm_k1z_zmm_zmmm512b64_er;
    
public static Code VEX_Vfmadd213ps_xmm_xmm_xmmm128;
    
public static Code VEX_Vfmadd213ps_ymm_ymm_ymmm256;
    
public static Code VEX_Vfmadd213pd_xmm_xmm_xmmm128;
    
public static Code VEX_Vfmadd213pd_ymm_ymm_ymmm256;
    
public static Code EVEX_Vfmadd213ps_xmm_k1z_xmm_xmmm128b32;
    
public static Code EVEX_Vfmadd213ps_ymm_k1z_ymm_ymmm256b32;
    
public static Code EVEX_Vfmadd213ps_zmm_k1z_zmm_zmmm512b32_er;
    
public static Code EVEX_Vfmadd213pd_xmm_k1z_xmm_xmmm128b64;
    
public static Code EVEX_Vfmadd213pd_ymm_k1z_ymm_ymmm256b64;
    
public static Code EVEX_Vfmadd213pd_zmm_k1z_zmm_zmmm512b64_er;
    
public static Code VEX_Vfmadd213ss_xmm_xmm_xmmm32;
    
public static Code VEX_Vfmadd213sd_xmm_xmm_xmmm64;
    
public static Code EVEX_Vfmadd213ss_xmm_k1z_xmm_xmmm32_er;
    
public static Code EVEX_Vfmadd213sd_xmm_k1z_xmm_xmmm64_er;
    
public static Code VEX_Vfmsub213ps_xmm_xmm_xmmm128;
    
public static Code VEX_Vfmsub213ps_ymm_ymm_ymmm256;
    
public static Code VEX_Vfmsub213pd_xmm_xmm_xmmm128;
    
public static Code VEX_Vfmsub213pd_ymm_ymm_ymmm256;
    
public static Code EVEX_Vfmsub213ps_xmm_k1z_xmm_xmmm128b32;
    
public static Code EVEX_Vfmsub213ps_ymm_k1z_ymm_ymmm256b32;
    
public static Code EVEX_Vfmsub213ps_zmm_k1z_zmm_zmmm512b32_er;
    
public static Code EVEX_Vfmsub213pd_xmm_k1z_xmm_xmmm128b64;
    
public static Code EVEX_Vfmsub213pd_ymm_k1z_ymm_ymmm256b64;
    
public static Code EVEX_Vfmsub213pd_zmm_k1z_zmm_zmmm512b64_er;
    
public static Code EVEX_V4fnmaddps_zmm_k1z_zmmp3_m128;
    
public static Code VEX_Vfmsub213ss_xmm_xmm_xmmm32;
    
public static Code VEX_Vfmsub213sd_xmm_xmm_xmmm64;
    
public static Code EVEX_Vfmsub213ss_xmm_k1z_xmm_xmmm32_er;
    
public static Code EVEX_Vfmsub213sd_xmm_k1z_xmm_xmmm64_er;
    
public static Code EVEX_V4fnmaddss_xmm_k1z_xmmp3_m128;
    
public static Code VEX_Vfnmadd213ps_xmm_xmm_xmmm128;
    
public static Code VEX_Vfnmadd213ps_ymm_ymm_ymmm256;
    
public static Code VEX_Vfnmadd213pd_xmm_xmm_xmmm128;
    
public static Code VEX_Vfnmadd213pd_ymm_ymm_ymmm256;
    
public static Code EVEX_Vfnmadd213ps_xmm_k1z_xmm_xmmm128b32;
    
public static Code EVEX_Vfnmadd213ps_ymm_k1z_ymm_ymmm256b32;
    
public static Code EVEX_Vfnmadd213ps_zmm_k1z_zmm_zmmm512b32_er;
    
public static Code EVEX_Vfnmadd213pd_xmm_k1z_xmm_xmmm128b64;
    
public static Code EVEX_Vfnmadd213pd_ymm_k1z_ymm_ymmm256b64;
    
public static Code EVEX_Vfnmadd213pd_zmm_k1z_zmm_zmmm512b64_er;
    
public static Code VEX_Vfnmadd213ss_xmm_xmm_xmmm32;
    
public static Code VEX_Vfnmadd213sd_xmm_xmm_xmmm64;
    
public static Code EVEX_Vfnmadd213ss_xmm_k1z_xmm_xmmm32_er;
    
public static Code EVEX_Vfnmadd213sd_xmm_k1z_xmm_xmmm64_er;
    
public static Code VEX_Vfnmsub213ps_xmm_xmm_xmmm128;
    
public static Code VEX_Vfnmsub213ps_ymm_ymm_ymmm256;
    
public static Code VEX_Vfnmsub213pd_xmm_xmm_xmmm128;
    
public static Code VEX_Vfnmsub213pd_ymm_ymm_ymmm256;
    
public static Code EVEX_Vfnmsub213ps_xmm_k1z_xmm_xmmm128b32;
    
public static Code EVEX_Vfnmsub213ps_ymm_k1z_ymm_ymmm256b32;
    
public static Code EVEX_Vfnmsub213ps_zmm_k1z_zmm_zmmm512b32_er;
    
public static Code EVEX_Vfnmsub213pd_xmm_k1z_xmm_xmmm128b64;
    
public static Code EVEX_Vfnmsub213pd_ymm_k1z_ymm_ymmm256b64;
    
public static Code EVEX_Vfnmsub213pd_zmm_k1z_zmm_zmmm512b64_er;
    
public static Code VEX_Vfnmsub213ss_xmm_xmm_xmmm32;
    
public static Code VEX_Vfnmsub213sd_xmm_xmm_xmmm64;
    
public static Code EVEX_Vfnmsub213ss_xmm_k1z_xmm_xmmm32_er;
    
public static Code EVEX_Vfnmsub213sd_xmm_k1z_xmm_xmmm64_er;
    
public static Code EVEX_Vpmadd52luq_xmm_k1z_xmm_xmmm128b64;
    
public static Code EVEX_Vpmadd52luq_ymm_k1z_ymm_ymmm256b64;
    
public static Code EVEX_Vpmadd52luq_zmm_k1z_zmm_zmmm512b64;
    
public static Code EVEX_Vpmadd52huq_xmm_k1z_xmm_xmmm128b64;
    
public static Code EVEX_Vpmadd52huq_ymm_k1z_ymm_ymmm256b64;
    
public static Code EVEX_Vpmadd52huq_zmm_k1z_zmm_zmmm512b64;
    
public static Code VEX_Vfmaddsub231ps_xmm_xmm_xmmm128;
    
public static Code VEX_Vfmaddsub231ps_ymm_ymm_ymmm256;
    
public static Code VEX_Vfmaddsub231pd_xmm_xmm_xmmm128;
    
public static Code VEX_Vfmaddsub231pd_ymm_ymm_ymmm256;
    
public static Code EVEX_Vfmaddsub231ps_xmm_k1z_xmm_xmmm128b32;
    
public static Code EVEX_Vfmaddsub231ps_ymm_k1z_ymm_ymmm256b32;
    
public static Code EVEX_Vfmaddsub231ps_zmm_k1z_zmm_zmmm512b32_er;
    
public static Code EVEX_Vfmaddsub231pd_xmm_k1z_xmm_xmmm128b64;
    
public static Code EVEX_Vfmaddsub231pd_ymm_k1z_ymm_ymmm256b64;
    
public static Code EVEX_Vfmaddsub231pd_zmm_k1z_zmm_zmmm512b64_er;
    
public static Code VEX_Vfmsubadd231ps_xmm_xmm_xmmm128;
    
public static Code VEX_Vfmsubadd231ps_ymm_ymm_ymmm256;
    
public static Code VEX_Vfmsubadd231pd_xmm_xmm_xmmm128;
    
public static Code VEX_Vfmsubadd231pd_ymm_ymm_ymmm256;
    
public static Code EVEX_Vfmsubadd231ps_xmm_k1z_xmm_xmmm128b32;
    
public static Code EVEX_Vfmsubadd231ps_ymm_k1z_ymm_ymmm256b32;
    
public static Code EVEX_Vfmsubadd231ps_zmm_k1z_zmm_zmmm512b32_er;
    
public static Code EVEX_Vfmsubadd231pd_xmm_k1z_xmm_xmmm128b64;
    
public static Code EVEX_Vfmsubadd231pd_ymm_k1z_ymm_ymmm256b64;
    
public static Code EVEX_Vfmsubadd231pd_zmm_k1z_zmm_zmmm512b64_er;
    
public static Code VEX_Vfmadd231ps_xmm_xmm_xmmm128;
    
public static Code VEX_Vfmadd231ps_ymm_ymm_ymmm256;
    
public static Code VEX_Vfmadd231pd_xmm_xmm_xmmm128;
    
public static Code VEX_Vfmadd231pd_ymm_ymm_ymmm256;
    
public static Code EVEX_Vfmadd231ps_xmm_k1z_xmm_xmmm128b32;
    
public static Code EVEX_Vfmadd231ps_ymm_k1z_ymm_ymmm256b32;
    
public static Code EVEX_Vfmadd231ps_zmm_k1z_zmm_zmmm512b32_er;
    
public static Code EVEX_Vfmadd231pd_xmm_k1z_xmm_xmmm128b64;
    
public static Code EVEX_Vfmadd231pd_ymm_k1z_ymm_ymmm256b64;
    
public static Code EVEX_Vfmadd231pd_zmm_k1z_zmm_zmmm512b64_er;
    
public static Code VEX_Vfmadd231ss_xmm_xmm_xmmm32;
    
public static Code VEX_Vfmadd231sd_xmm_xmm_xmmm64;
    
public static Code EVEX_Vfmadd231ss_xmm_k1z_xmm_xmmm32_er;
    
public static Code EVEX_Vfmadd231sd_xmm_k1z_xmm_xmmm64_er;
    
public static Code VEX_Vfmsub231ps_xmm_xmm_xmmm128;
    
public static Code VEX_Vfmsub231ps_ymm_ymm_ymmm256;
    
public static Code VEX_Vfmsub231pd_xmm_xmm_xmmm128;
    
public static Code VEX_Vfmsub231pd_ymm_ymm_ymmm256;
    
public static Code EVEX_Vfmsub231ps_xmm_k1z_xmm_xmmm128b32;
    
public static Code EVEX_Vfmsub231ps_ymm_k1z_ymm_ymmm256b32;
    
public static Code EVEX_Vfmsub231ps_zmm_k1z_zmm_zmmm512b32_er;
    
public static Code EVEX_Vfmsub231pd_xmm_k1z_xmm_xmmm128b64;
    
public static Code EVEX_Vfmsub231pd_ymm_k1z_ymm_ymmm256b64;
    
public static Code EVEX_Vfmsub231pd_zmm_k1z_zmm_zmmm512b64_er;
    
public static Code VEX_Vfmsub231ss_xmm_xmm_xmmm32;
    
public static Code VEX_Vfmsub231sd_xmm_xmm_xmmm64;
    
public static Code EVEX_Vfmsub231ss_xmm_k1z_xmm_xmmm32_er;
    
public static Code EVEX_Vfmsub231sd_xmm_k1z_xmm_xmmm64_er;
    
public static Code VEX_Vfnmadd231ps_xmm_xmm_xmmm128;
    
public static Code VEX_Vfnmadd231ps_ymm_ymm_ymmm256;
    
public static Code VEX_Vfnmadd231pd_xmm_xmm_xmmm128;
    
public static Code VEX_Vfnmadd231pd_ymm_ymm_ymmm256;
    
public static Code EVEX_Vfnmadd231ps_xmm_k1z_xmm_xmmm128b32;
    
public static Code EVEX_Vfnmadd231ps_ymm_k1z_ymm_ymmm256b32;
    
public static Code EVEX_Vfnmadd231ps_zmm_k1z_zmm_zmmm512b32_er;
    
public static Code EVEX_Vfnmadd231pd_xmm_k1z_xmm_xmmm128b64;
    
public static Code EVEX_Vfnmadd231pd_ymm_k1z_ymm_ymmm256b64;
    
public static Code EVEX_Vfnmadd231pd_zmm_k1z_zmm_zmmm512b64_er;
    
public static Code VEX_Vfnmadd231ss_xmm_xmm_xmmm32;
    
public static Code VEX_Vfnmadd231sd_xmm_xmm_xmmm64;
    
public static Code EVEX_Vfnmadd231ss_xmm_k1z_xmm_xmmm32_er;
    
public static Code EVEX_Vfnmadd231sd_xmm_k1z_xmm_xmmm64_er;
    
public static Code VEX_Vfnmsub231ps_xmm_xmm_xmmm128;
    
public static Code VEX_Vfnmsub231ps_ymm_ymm_ymmm256;
    
public static Code VEX_Vfnmsub231pd_xmm_xmm_xmmm128;
    
public static Code VEX_Vfnmsub231pd_ymm_ymm_ymmm256;
    
public static Code EVEX_Vfnmsub231ps_xmm_k1z_xmm_xmmm128b32;
    
public static Code EVEX_Vfnmsub231ps_ymm_k1z_ymm_ymmm256b32;
    
public static Code EVEX_Vfnmsub231ps_zmm_k1z_zmm_zmmm512b32_er;
    
public static Code EVEX_Vfnmsub231pd_xmm_k1z_xmm_xmmm128b64;
    
public static Code EVEX_Vfnmsub231pd_ymm_k1z_ymm_ymmm256b64;
    
public static Code EVEX_Vfnmsub231pd_zmm_k1z_zmm_zmmm512b64_er;
    
public static Code VEX_Vfnmsub231ss_xmm_xmm_xmmm32;
    
public static Code VEX_Vfnmsub231sd_xmm_xmm_xmmm64;
    
public static Code EVEX_Vfnmsub231ss_xmm_k1z_xmm_xmmm32_er;
    
public static Code EVEX_Vfnmsub231sd_xmm_k1z_xmm_xmmm64_er;
    
public static Code EVEX_Vpconflictd_xmm_k1z_xmmm128b32;
    
public static Code EVEX_Vpconflictd_ymm_k1z_ymmm256b32;
    
public static Code EVEX_Vpconflictd_zmm_k1z_zmmm512b32;
    
public static Code EVEX_Vpconflictq_xmm_k1z_xmmm128b64;
    
public static Code EVEX_Vpconflictq_ymm_k1z_ymmm256b64;
    
public static Code EVEX_Vpconflictq_zmm_k1z_zmmm512b64;
    
public static Code EVEX_Vgatherpf0dps_vm32z_k1;
    
public static Code EVEX_Vgatherpf0dpd_vm32y_k1;
    
public static Code EVEX_Vgatherpf1dps_vm32z_k1;
    
public static Code EVEX_Vgatherpf1dpd_vm32y_k1;
    
public static Code EVEX_Vscatterpf0dps_vm32z_k1;
    
public static Code EVEX_Vscatterpf0dpd_vm32y_k1;
    
public static Code EVEX_Vscatterpf1dps_vm32z_k1;
    
public static Code EVEX_Vscatterpf1dpd_vm32y_k1;
    
public static Code EVEX_Vgatherpf0qps_vm64z_k1;
    
public static Code EVEX_Vgatherpf0qpd_vm64z_k1;
    
public static Code EVEX_Vgatherpf1qps_vm64z_k1;
    
public static Code EVEX_Vgatherpf1qpd_vm64z_k1;
    
public static Code EVEX_Vscatterpf0qps_vm64z_k1;
    
public static Code EVEX_Vscatterpf0qpd_vm64z_k1;
    
public static Code EVEX_Vscatterpf1qps_vm64z_k1;
    
public static Code EVEX_Vscatterpf1qpd_vm64z_k1;
    
public static Code Sha1nexte_xmm_xmmm128;
    
public static Code EVEX_Vexp2ps_zmm_k1z_zmmm512b32_sae;
    
public static Code EVEX_Vexp2pd_zmm_k1z_zmmm512b64_sae;
    
public static Code Sha1msg1_xmm_xmmm128;
    
public static Code Sha1msg2_xmm_xmmm128;
    
public static Code EVEX_Vrcp28ps_zmm_k1z_zmmm512b32_sae;
    
public static Code EVEX_Vrcp28pd_zmm_k1z_zmmm512b64_sae;
    
public static Code Sha256rnds2_xmm_xmmm128;
    
public static Code EVEX_Vrcp28ss_xmm_k1z_xmm_xmmm32_sae;
    
public static Code EVEX_Vrcp28sd_xmm_k1z_xmm_xmmm64_sae;
    
public static Code Sha256msg1_xmm_xmmm128;
    
public static Code EVEX_Vrsqrt28ps_zmm_k1z_zmmm512b32_sae;
    
public static Code EVEX_Vrsqrt28pd_zmm_k1z_zmmm512b64_sae;
    
public static Code Sha256msg2_xmm_xmmm128;
    
public static Code EVEX_Vrsqrt28ss_xmm_k1z_xmm_xmmm32_sae;
    
public static Code EVEX_Vrsqrt28sd_xmm_k1z_xmm_xmmm64_sae;
    
public static Code Gf2p8mulb_xmm_xmmm128;
    
public static Code VEX_Vgf2p8mulb_xmm_xmm_xmmm128;
    
public static Code VEX_Vgf2p8mulb_ymm_ymm_ymmm256;
    
public static Code EVEX_Vgf2p8mulb_xmm_k1z_xmm_xmmm128;
    
public static Code EVEX_Vgf2p8mulb_ymm_k1z_ymm_ymmm256;
    
public static Code EVEX_Vgf2p8mulb_zmm_k1z_zmm_zmmm512;
    
public static Code Aesimc_xmm_xmmm128;
    
public static Code VEX_Vaesimc_xmm_xmmm128;
    
public static Code Aesenc_xmm_xmmm128;
    
public static Code VEX_Vaesenc_xmm_xmm_xmmm128;
    
public static Code VEX_Vaesenc_ymm_ymm_ymmm256;
    
public static Code EVEX_Vaesenc_xmm_xmm_xmmm128;
    
public static Code EVEX_Vaesenc_ymm_ymm_ymmm256;
    
public static Code EVEX_Vaesenc_zmm_zmm_zmmm512;
    
public static Code Aesenclast_xmm_xmmm128;
    
public static Code VEX_Vaesenclast_xmm_xmm_xmmm128;
    
public static Code VEX_Vaesenclast_ymm_ymm_ymmm256;
    
public static Code EVEX_Vaesenclast_xmm_xmm_xmmm128;
    
public static Code EVEX_Vaesenclast_ymm_ymm_ymmm256;
    
public static Code EVEX_Vaesenclast_zmm_zmm_zmmm512;
    
public static Code Aesdec_xmm_xmmm128;
    
public static Code VEX_Vaesdec_xmm_xmm_xmmm128;
    
public static Code VEX_Vaesdec_ymm_ymm_ymmm256;
    
public static Code EVEX_Vaesdec_xmm_xmm_xmmm128;
    
public static Code EVEX_Vaesdec_ymm_ymm_ymmm256;
    
public static Code EVEX_Vaesdec_zmm_zmm_zmmm512;
    
public static Code Aesdeclast_xmm_xmmm128;
    
public static Code VEX_Vaesdeclast_xmm_xmm_xmmm128;
    
public static Code VEX_Vaesdeclast_ymm_ymm_ymmm256;
    
public static Code EVEX_Vaesdeclast_xmm_xmm_xmmm128;
    
public static Code EVEX_Vaesdeclast_ymm_ymm_ymmm256;
    
public static Code EVEX_Vaesdeclast_zmm_zmm_zmmm512;
    
public static Code Movbe_r16_m16;
    
public static Code Movbe_r32_m32;
    
public static Code Movbe_r64_m64;
    
public static Code Crc32_r32_rm8;
    
public static Code Crc32_r64_rm8;
    
public static Code Movbe_m16_r16;
    
public static Code Movbe_m32_r32;
    
public static Code Movbe_m64_r64;
    
public static Code Crc32_r32_rm16;
    
public static Code Crc32_r32_rm32;
    
public static Code Crc32_r64_rm64;
    
public static Code VEX_Andn_r32_r32_rm32;
    
public static Code VEX_Andn_r64_r64_rm64;
    
public static Code VEX_Blsr_r32_rm32;
    
public static Code VEX_Blsr_r64_rm64;
    
public static Code VEX_Blsmsk_r32_rm32;
    
public static Code VEX_Blsmsk_r64_rm64;
    
public static Code VEX_Blsi_r32_rm32;
    
public static Code VEX_Blsi_r64_rm64;
    
public static Code VEX_Bzhi_r32_rm32_r32;
    
public static Code VEX_Bzhi_r64_rm64_r64;
    
public static Code Wrussd_m32_r32;
    
public static Code Wrussq_m64_r64;
    
public static Code VEX_Pext_r32_r32_rm32;
    
public static Code VEX_Pext_r64_r64_rm64;
    
public static Code VEX_Pdep_r32_r32_rm32;
    
public static Code VEX_Pdep_r64_r64_rm64;
    
public static Code Wrssd_m32_r32;
    
public static Code Wrssq_m64_r64;
    
public static Code Adcx_r32_rm32;
    
public static Code Adcx_r64_rm64;
    
public static Code Adox_r32_rm32;
    
public static Code Adox_r64_rm64;
    
public static Code VEX_Mulx_r32_r32_rm32;
    
public static Code VEX_Mulx_r64_r64_rm64;
    
public static Code VEX_Bextr_r32_rm32_r32;
    
public static Code VEX_Bextr_r64_rm64_r64;
    
public static Code VEX_Shlx_r32_rm32_r32;
    
public static Code VEX_Shlx_r64_rm64_r64;
    
public static Code VEX_Sarx_r32_rm32_r32;
    
public static Code VEX_Sarx_r64_rm64_r64;
    
public static Code VEX_Shrx_r32_rm32_r32;
    
public static Code VEX_Shrx_r64_rm64_r64;
    
public static Code Movdir64b_r16_m512;
    
public static Code Movdir64b_r32_m512;
    
public static Code Movdir64b_r64_m512;
    
public static Code Enqcmds_r16_m512;
    
public static Code Enqcmds_r32_m512;
    
public static Code Enqcmds_r64_m512;
    
public static Code Enqcmd_r16_m512;
    
public static Code Enqcmd_r32_m512;
    
public static Code Enqcmd_r64_m512;
    
public static Code Movdiri_m32_r32;
    
public static Code Movdiri_m64_r64;
    
public static Code VEX_Vpermq_ymm_ymmm256_imm8;
    
public static Code EVEX_Vpermq_ymm_k1z_ymmm256b64_imm8;
    
public static Code EVEX_Vpermq_zmm_k1z_zmmm512b64_imm8;
    
public static Code VEX_Vpermpd_ymm_ymmm256_imm8;
    
public static Code EVEX_Vpermpd_ymm_k1z_ymmm256b64_imm8;
    
public static Code EVEX_Vpermpd_zmm_k1z_zmmm512b64_imm8;
    
public static Code VEX_Vpblendd_xmm_xmm_xmmm128_imm8;
    
public static Code VEX_Vpblendd_ymm_ymm_ymmm256_imm8;
    
public static Code EVEX_Valignd_xmm_k1z_xmm_xmmm128b32_imm8;
    
public static Code EVEX_Valignd_ymm_k1z_ymm_ymmm256b32_imm8;
    
public static Code EVEX_Valignd_zmm_k1z_zmm_zmmm512b32_imm8;
    
public static Code EVEX_Valignq_xmm_k1z_xmm_xmmm128b64_imm8;
    
public static Code EVEX_Valignq_ymm_k1z_ymm_ymmm256b64_imm8;
    
public static Code EVEX_Valignq_zmm_k1z_zmm_zmmm512b64_imm8;
    
public static Code VEX_Vpermilps_xmm_xmmm128_imm8;
    
public static Code VEX_Vpermilps_ymm_ymmm256_imm8;
    
public static Code EVEX_Vpermilps_xmm_k1z_xmmm128b32_imm8;
    
public static Code EVEX_Vpermilps_ymm_k1z_ymmm256b32_imm8;
    
public static Code EVEX_Vpermilps_zmm_k1z_zmmm512b32_imm8;
    
public static Code VEX_Vpermilpd_xmm_xmmm128_imm8;
    
public static Code VEX_Vpermilpd_ymm_ymmm256_imm8;
    
public static Code EVEX_Vpermilpd_xmm_k1z_xmmm128b64_imm8;
    
public static Code EVEX_Vpermilpd_ymm_k1z_ymmm256b64_imm8;
    
public static Code EVEX_Vpermilpd_zmm_k1z_zmmm512b64_imm8;
    
public static Code VEX_Vperm2f128_ymm_ymm_ymmm256_imm8;
    
public static Code Roundps_xmm_xmmm128_imm8;
    
public static Code VEX_Vroundps_xmm_xmmm128_imm8;
    
public static Code VEX_Vroundps_ymm_ymmm256_imm8;
    
public static Code EVEX_Vrndscaleps_xmm_k1z_xmmm128b32_imm8;
    
public static Code EVEX_Vrndscaleps_ymm_k1z_ymmm256b32_imm8;
    
public static Code EVEX_Vrndscaleps_zmm_k1z_zmmm512b32_imm8_sae;
    
public static Code Roundpd_xmm_xmmm128_imm8;
    
public static Code VEX_Vroundpd_xmm_xmmm128_imm8;
    
public static Code VEX_Vroundpd_ymm_ymmm256_imm8;
    
public static Code EVEX_Vrndscalepd_xmm_k1z_xmmm128b64_imm8;
    
public static Code EVEX_Vrndscalepd_ymm_k1z_ymmm256b64_imm8;
    
public static Code EVEX_Vrndscalepd_zmm_k1z_zmmm512b64_imm8_sae;
    
public static Code Roundss_xmm_xmmm32_imm8;
    
public static Code VEX_Vroundss_xmm_xmm_xmmm32_imm8;
    
public static Code EVEX_Vrndscaless_xmm_k1z_xmm_xmmm32_imm8_sae;
    
public static Code Roundsd_xmm_xmmm64_imm8;
    
public static Code VEX_Vroundsd_xmm_xmm_xmmm64_imm8;
    
public static Code EVEX_Vrndscalesd_xmm_k1z_xmm_xmmm64_imm8_sae;
    
public static Code Blendps_xmm_xmmm128_imm8;
    
public static Code VEX_Vblendps_xmm_xmm_xmmm128_imm8;
    
public static Code VEX_Vblendps_ymm_ymm_ymmm256_imm8;
    
public static Code Blendpd_xmm_xmmm128_imm8;
    
public static Code VEX_Vblendpd_xmm_xmm_xmmm128_imm8;
    
public static Code VEX_Vblendpd_ymm_ymm_ymmm256_imm8;
    
public static Code Pblendw_xmm_xmmm128_imm8;
    
public static Code VEX_Vpblendw_xmm_xmm_xmmm128_imm8;
    
public static Code VEX_Vpblendw_ymm_ymm_ymmm256_imm8;
    
public static Code Palignr_mm_mmm64_imm8;
    
public static Code Palignr_xmm_xmmm128_imm8;
    
public static Code VEX_Vpalignr_xmm_xmm_xmmm128_imm8;
    
public static Code VEX_Vpalignr_ymm_ymm_ymmm256_imm8;
    
public static Code EVEX_Vpalignr_xmm_k1z_xmm_xmmm128_imm8;
    
public static Code EVEX_Vpalignr_ymm_k1z_ymm_ymmm256_imm8;
    
public static Code EVEX_Vpalignr_zmm_k1z_zmm_zmmm512_imm8;
    
public static Code Pextrb_r32m8_xmm_imm8;
    
public static Code Pextrb_r64m8_xmm_imm8;
    
public static Code VEX_Vpextrb_r32m8_xmm_imm8;
    
public static Code VEX_Vpextrb_r64m8_xmm_imm8;
    
public static Code EVEX_Vpextrb_r32m8_xmm_imm8;
    
public static Code EVEX_Vpextrb_r64m8_xmm_imm8;
    
public static Code Pextrw_r32m16_xmm_imm8;
    
public static Code Pextrw_r64m16_xmm_imm8;
    
public static Code VEX_Vpextrw_r32m16_xmm_imm8;
    
public static Code VEX_Vpextrw_r64m16_xmm_imm8;
    
public static Code EVEX_Vpextrw_r32m16_xmm_imm8;
    
public static Code EVEX_Vpextrw_r64m16_xmm_imm8;
    
public static Code Pextrd_rm32_xmm_imm8;
    
public static Code Pextrq_rm64_xmm_imm8;
    
public static Code VEX_Vpextrd_rm32_xmm_imm8;
    
public static Code VEX_Vpextrq_rm64_xmm_imm8;
    
public static Code EVEX_Vpextrd_rm32_xmm_imm8;
    
public static Code EVEX_Vpextrq_rm64_xmm_imm8;
    
public static Code Extractps_rm32_xmm_imm8;
    
public static Code Extractps_r64m32_xmm_imm8;
    
public static Code VEX_Vextractps_rm32_xmm_imm8;
    
public static Code VEX_Vextractps_r64m32_xmm_imm8;
    
public static Code EVEX_Vextractps_rm32_xmm_imm8;
    
public static Code EVEX_Vextractps_r64m32_xmm_imm8;
    
public static Code VEX_Vinsertf128_ymm_ymm_xmmm128_imm8;
    
public static Code EVEX_Vinsertf32x4_ymm_k1z_ymm_xmmm128_imm8;
    
public static Code EVEX_Vinsertf32x4_zmm_k1z_zmm_xmmm128_imm8;
    
public static Code EVEX_Vinsertf64x2_ymm_k1z_ymm_xmmm128_imm8;
    
public static Code EVEX_Vinsertf64x2_zmm_k1z_zmm_xmmm128_imm8;
    
public static Code VEX_Vextractf128_xmmm128_ymm_imm8;
    
public static Code EVEX_Vextractf32x4_xmmm128_k1z_ymm_imm8;
    
public static Code EVEX_Vextractf32x4_xmmm128_k1z_zmm_imm8;
    
public static Code EVEX_Vextractf64x2_xmmm128_k1z_ymm_imm8;
    
public static Code EVEX_Vextractf64x2_xmmm128_k1z_zmm_imm8;
    
public static Code EVEX_Vinsertf32x8_zmm_k1z_zmm_ymmm256_imm8;
    
public static Code EVEX_Vinsertf64x4_zmm_k1z_zmm_ymmm256_imm8;
    
public static Code EVEX_Vextractf32x8_ymmm256_k1z_zmm_imm8;
    
public static Code EVEX_Vextractf64x4_ymmm256_k1z_zmm_imm8;
    
public static Code VEX_Vcvtps2ph_xmmm64_xmm_imm8;
    
public static Code VEX_Vcvtps2ph_xmmm128_ymm_imm8;
    
public static Code EVEX_Vcvtps2ph_xmmm64_k1z_xmm_imm8;
    
public static Code EVEX_Vcvtps2ph_xmmm128_k1z_ymm_imm8;
    
public static Code EVEX_Vcvtps2ph_ymmm256_k1z_zmm_imm8_sae;
    
public static Code EVEX_Vpcmpud_kr_k1_xmm_xmmm128b32_imm8;
    
public static Code EVEX_Vpcmpud_kr_k1_ymm_ymmm256b32_imm8;
    
public static Code EVEX_Vpcmpud_kr_k1_zmm_zmmm512b32_imm8;
    
public static Code EVEX_Vpcmpuq_kr_k1_xmm_xmmm128b64_imm8;
    
public static Code EVEX_Vpcmpuq_kr_k1_ymm_ymmm256b64_imm8;
    
public static Code EVEX_Vpcmpuq_kr_k1_zmm_zmmm512b64_imm8;
    
public static Code EVEX_Vpcmpd_kr_k1_xmm_xmmm128b32_imm8;
    
public static Code EVEX_Vpcmpd_kr_k1_ymm_ymmm256b32_imm8;
    
public static Code EVEX_Vpcmpd_kr_k1_zmm_zmmm512b32_imm8;
    
public static Code EVEX_Vpcmpq_kr_k1_xmm_xmmm128b64_imm8;
    
public static Code EVEX_Vpcmpq_kr_k1_ymm_ymmm256b64_imm8;
    
public static Code EVEX_Vpcmpq_kr_k1_zmm_zmmm512b64_imm8;
    
public static Code Pinsrb_xmm_r32m8_imm8;
    
public static Code Pinsrb_xmm_r64m8_imm8;
    
public static Code VEX_Vpinsrb_xmm_xmm_r32m8_imm8;
    
public static Code VEX_Vpinsrb_xmm_xmm_r64m8_imm8;
    
public static Code EVEX_Vpinsrb_xmm_xmm_r32m8_imm8;
    
public static Code EVEX_Vpinsrb_xmm_xmm_r64m8_imm8;
    
public static Code Insertps_xmm_xmmm32_imm8;
    
public static Code VEX_Vinsertps_xmm_xmm_xmmm32_imm8;
    
public static Code EVEX_Vinsertps_xmm_xmm_xmmm32_imm8;
    
public static Code Pinsrd_xmm_rm32_imm8;
    
public static Code Pinsrq_xmm_rm64_imm8;
    
public static Code VEX_Vpinsrd_xmm_xmm_rm32_imm8;
    
public static Code VEX_Vpinsrq_xmm_xmm_rm64_imm8;
    
public static Code EVEX_Vpinsrd_xmm_xmm_rm32_imm8;
    
public static Code EVEX_Vpinsrq_xmm_xmm_rm64_imm8;
    
public static Code EVEX_Vshuff32x4_ymm_k1z_ymm_ymmm256b32_imm8;
    
public static Code EVEX_Vshuff32x4_zmm_k1z_zmm_zmmm512b32_imm8;
    
public static Code EVEX_Vshuff64x2_ymm_k1z_ymm_ymmm256b64_imm8;
    
public static Code EVEX_Vshuff64x2_zmm_k1z_zmm_zmmm512b64_imm8;
    
public static Code EVEX_Vpternlogd_xmm_k1z_xmm_xmmm128b32_imm8;
    
public static Code EVEX_Vpternlogd_ymm_k1z_ymm_ymmm256b32_imm8;
    
public static Code EVEX_Vpternlogd_zmm_k1z_zmm_zmmm512b32_imm8;
    
public static Code EVEX_Vpternlogq_xmm_k1z_xmm_xmmm128b64_imm8;
    
public static Code EVEX_Vpternlogq_ymm_k1z_ymm_ymmm256b64_imm8;
    
public static Code EVEX_Vpternlogq_zmm_k1z_zmm_zmmm512b64_imm8;
    
public static Code EVEX_Vgetmantps_xmm_k1z_xmmm128b32_imm8;
    
public static Code EVEX_Vgetmantps_ymm_k1z_ymmm256b32_imm8;
    
public static Code EVEX_Vgetmantps_zmm_k1z_zmmm512b32_imm8_sae;
    
public static Code EVEX_Vgetmantpd_xmm_k1z_xmmm128b64_imm8;
    
public static Code EVEX_Vgetmantpd_ymm_k1z_ymmm256b64_imm8;
    
public static Code EVEX_Vgetmantpd_zmm_k1z_zmmm512b64_imm8_sae;
    
public static Code EVEX_Vgetmantss_xmm_k1z_xmm_xmmm32_imm8_sae;
    
public static Code EVEX_Vgetmantsd_xmm_k1z_xmm_xmmm64_imm8_sae;
    
public static Code VEX_Kshiftrb_kr_kr_imm8;
    
public static Code VEX_Kshiftrw_kr_kr_imm8;
    
public static Code VEX_Kshiftrd_kr_kr_imm8;
    
public static Code VEX_Kshiftrq_kr_kr_imm8;
    
public static Code VEX_Kshiftlb_kr_kr_imm8;
    
public static Code VEX_Kshiftlw_kr_kr_imm8;
    
public static Code VEX_Kshiftld_kr_kr_imm8;
    
public static Code VEX_Kshiftlq_kr_kr_imm8;
    
public static Code VEX_Vinserti128_ymm_ymm_xmmm128_imm8;
    
public static Code EVEX_Vinserti32x4_ymm_k1z_ymm_xmmm128_imm8;
    
public static Code EVEX_Vinserti32x4_zmm_k1z_zmm_xmmm128_imm8;
    
public static Code EVEX_Vinserti64x2_ymm_k1z_ymm_xmmm128_imm8;
    
public static Code EVEX_Vinserti64x2_zmm_k1z_zmm_xmmm128_imm8;
    
public static Code VEX_Vextracti128_xmmm128_ymm_imm8;
    
public static Code EVEX_Vextracti32x4_xmmm128_k1z_ymm_imm8;
    
public static Code EVEX_Vextracti32x4_xmmm128_k1z_zmm_imm8;
    
public static Code EVEX_Vextracti64x2_xmmm128_k1z_ymm_imm8;
    
public static Code EVEX_Vextracti64x2_xmmm128_k1z_zmm_imm8;
    
public static Code EVEX_Vinserti32x8_zmm_k1z_zmm_ymmm256_imm8;
    
public static Code EVEX_Vinserti64x4_zmm_k1z_zmm_ymmm256_imm8;
    
public static Code EVEX_Vextracti32x8_ymmm256_k1z_zmm_imm8;
    
public static Code EVEX_Vextracti64x4_ymmm256_k1z_zmm_imm8;
    
public static Code EVEX_Vpcmpub_kr_k1_xmm_xmmm128_imm8;
    
public static Code EVEX_Vpcmpub_kr_k1_ymm_ymmm256_imm8;
    
public static Code EVEX_Vpcmpub_kr_k1_zmm_zmmm512_imm8;
    
public static Code EVEX_Vpcmpuw_kr_k1_xmm_xmmm128_imm8;
    
public static Code EVEX_Vpcmpuw_kr_k1_ymm_ymmm256_imm8;
    
public static Code EVEX_Vpcmpuw_kr_k1_zmm_zmmm512_imm8;
    
public static Code EVEX_Vpcmpb_kr_k1_xmm_xmmm128_imm8;
    
public static Code EVEX_Vpcmpb_kr_k1_ymm_ymmm256_imm8;
    
public static Code EVEX_Vpcmpb_kr_k1_zmm_zmmm512_imm8;
    
public static Code EVEX_Vpcmpw_kr_k1_xmm_xmmm128_imm8;
    
public static Code EVEX_Vpcmpw_kr_k1_ymm_ymmm256_imm8;
    
public static Code EVEX_Vpcmpw_kr_k1_zmm_zmmm512_imm8;
    
public static Code Dpps_xmm_xmmm128_imm8;
    
public static Code VEX_Vdpps_xmm_xmm_xmmm128_imm8;
    
public static Code VEX_Vdpps_ymm_ymm_ymmm256_imm8;
    
public static Code Dppd_xmm_xmmm128_imm8;
    
public static Code VEX_Vdppd_xmm_xmm_xmmm128_imm8;
    
public static Code Mpsadbw_xmm_xmmm128_imm8;
    
public static Code VEX_Vmpsadbw_xmm_xmm_xmmm128_imm8;
    
public static Code VEX_Vmpsadbw_ymm_ymm_ymmm256_imm8;
    
public static Code EVEX_Vdbpsadbw_xmm_k1z_xmm_xmmm128_imm8;
    
public static Code EVEX_Vdbpsadbw_ymm_k1z_ymm_ymmm256_imm8;
    
public static Code EVEX_Vdbpsadbw_zmm_k1z_zmm_zmmm512_imm8;
    
public static Code EVEX_Vshufi32x4_ymm_k1z_ymm_ymmm256b32_imm8;
    
public static Code EVEX_Vshufi32x4_zmm_k1z_zmm_zmmm512b32_imm8;
    
public static Code EVEX_Vshufi64x2_ymm_k1z_ymm_ymmm256b64_imm8;
    
public static Code EVEX_Vshufi64x2_zmm_k1z_zmm_zmmm512b64_imm8;
    
public static Code Pclmulqdq_xmm_xmmm128_imm8;
    
public static Code VEX_Vpclmulqdq_xmm_xmm_xmmm128_imm8;
    
public static Code VEX_Vpclmulqdq_ymm_ymm_ymmm256_imm8;
    
public static Code EVEX_Vpclmulqdq_xmm_xmm_xmmm128_imm8;
    
public static Code EVEX_Vpclmulqdq_ymm_ymm_ymmm256_imm8;
    
public static Code EVEX_Vpclmulqdq_zmm_zmm_zmmm512_imm8;
    
public static Code VEX_Vperm2i128_ymm_ymm_ymmm256_imm8;
    
public static Code VEX_Vpermil2ps_xmm_xmm_xmmm128_xmm_imm4;
    
public static Code VEX_Vpermil2ps_ymm_ymm_ymmm256_ymm_imm4;
    
public static Code VEX_Vpermil2ps_xmm_xmm_xmm_xmmm128_imm4;
    
public static Code VEX_Vpermil2ps_ymm_ymm_ymm_ymmm256_imm4;
    
public static Code VEX_Vpermil2pd_xmm_xmm_xmmm128_xmm_imm4;
    
public static Code VEX_Vpermil2pd_ymm_ymm_ymmm256_ymm_imm4;
    
public static Code VEX_Vpermil2pd_xmm_xmm_xmm_xmmm128_imm4;
    
public static Code VEX_Vpermil2pd_ymm_ymm_ymm_ymmm256_imm4;
    
public static Code VEX_Vblendvps_xmm_xmm_xmmm128_xmm;
    
public static Code VEX_Vblendvps_ymm_ymm_ymmm256_ymm;
    
public static Code VEX_Vblendvpd_xmm_xmm_xmmm128_xmm;
    
public static Code VEX_Vblendvpd_ymm_ymm_ymmm256_ymm;
    
public static Code VEX_Vpblendvb_xmm_xmm_xmmm128_xmm;
    
public static Code VEX_Vpblendvb_ymm_ymm_ymmm256_ymm;
    
public static Code EVEX_Vrangeps_xmm_k1z_xmm_xmmm128b32_imm8;
    
public static Code EVEX_Vrangeps_ymm_k1z_ymm_ymmm256b32_imm8;
    
public static Code EVEX_Vrangeps_zmm_k1z_zmm_zmmm512b32_imm8_sae;
    
public static Code EVEX_Vrangepd_xmm_k1z_xmm_xmmm128b64_imm8;
    
public static Code EVEX_Vrangepd_ymm_k1z_ymm_ymmm256b64_imm8;
    
public static Code EVEX_Vrangepd_zmm_k1z_zmm_zmmm512b64_imm8_sae;
    
public static Code EVEX_Vrangess_xmm_k1z_xmm_xmmm32_imm8_sae;
    
public static Code EVEX_Vrangesd_xmm_k1z_xmm_xmmm64_imm8_sae;
    
public static Code EVEX_Vfixupimmps_xmm_k1z_xmm_xmmm128b32_imm8;
    
public static Code EVEX_Vfixupimmps_ymm_k1z_ymm_ymmm256b32_imm8;
    
public static Code EVEX_Vfixupimmps_zmm_k1z_zmm_zmmm512b32_imm8_sae;
    
public static Code EVEX_Vfixupimmpd_xmm_k1z_xmm_xmmm128b64_imm8;
    
public static Code EVEX_Vfixupimmpd_ymm_k1z_ymm_ymmm256b64_imm8;
    
public static Code EVEX_Vfixupimmpd_zmm_k1z_zmm_zmmm512b64_imm8_sae;
    
public static Code EVEX_Vfixupimmss_xmm_k1z_xmm_xmmm32_imm8_sae;
    
public static Code EVEX_Vfixupimmsd_xmm_k1z_xmm_xmmm64_imm8_sae;
    
public static Code EVEX_Vreduceps_xmm_k1z_xmmm128b32_imm8;
    
public static Code EVEX_Vreduceps_ymm_k1z_ymmm256b32_imm8;
    
public static Code EVEX_Vreduceps_zmm_k1z_zmmm512b32_imm8_sae;
    
public static Code EVEX_Vreducepd_xmm_k1z_xmmm128b64_imm8;
    
public static Code EVEX_Vreducepd_ymm_k1z_ymmm256b64_imm8;
    
public static Code EVEX_Vreducepd_zmm_k1z_zmmm512b64_imm8_sae;
    
public static Code EVEX_Vreducess_xmm_k1z_xmm_xmmm32_imm8_sae;
    
public static Code EVEX_Vreducesd_xmm_k1z_xmm_xmmm64_imm8_sae;
    
public static Code VEX_Vfmaddsubps_xmm_xmm_xmmm128_xmm;
    
public static Code VEX_Vfmaddsubps_ymm_ymm_ymmm256_ymm;
    
public static Code VEX_Vfmaddsubps_xmm_xmm_xmm_xmmm128;
    
public static Code VEX_Vfmaddsubps_ymm_ymm_ymm_ymmm256;
    
public static Code VEX_Vfmaddsubpd_xmm_xmm_xmmm128_xmm;
    
public static Code VEX_Vfmaddsubpd_ymm_ymm_ymmm256_ymm;
    
public static Code VEX_Vfmaddsubpd_xmm_xmm_xmm_xmmm128;
    
public static Code VEX_Vfmaddsubpd_ymm_ymm_ymm_ymmm256;
    
public static Code VEX_Vfmsubaddps_xmm_xmm_xmmm128_xmm;
    
public static Code VEX_Vfmsubaddps_ymm_ymm_ymmm256_ymm;
    
public static Code VEX_Vfmsubaddps_xmm_xmm_xmm_xmmm128;
    
public static Code VEX_Vfmsubaddps_ymm_ymm_ymm_ymmm256;
    
public static Code VEX_Vfmsubaddpd_xmm_xmm_xmmm128_xmm;
    
public static Code VEX_Vfmsubaddpd_ymm_ymm_ymmm256_ymm;
    
public static Code VEX_Vfmsubaddpd_xmm_xmm_xmm_xmmm128;
    
public static Code VEX_Vfmsubaddpd_ymm_ymm_ymm_ymmm256;
    
public static Code Pcmpestrm_xmm_xmmm128_imm8;
    
public static Code Pcmpestrm64_xmm_xmmm128_imm8;
    
public static Code VEX_Vpcmpestrm_xmm_xmmm128_imm8;
    
public static Code VEX_Vpcmpestrm64_xmm_xmmm128_imm8;
    
public static Code Pcmpestri_xmm_xmmm128_imm8;
    
public static Code Pcmpestri64_xmm_xmmm128_imm8;
    
public static Code VEX_Vpcmpestri_xmm_xmmm128_imm8;
    
public static Code VEX_Vpcmpestri64_xmm_xmmm128_imm8;
    
public static Code Pcmpistrm_xmm_xmmm128_imm8;
    
public static Code VEX_Vpcmpistrm_xmm_xmmm128_imm8;
    
public static Code Pcmpistri_xmm_xmmm128_imm8;
    
public static Code VEX_Vpcmpistri_xmm_xmmm128_imm8;
    
public static Code EVEX_Vfpclassps_kr_k1_xmmm128b32_imm8;
    
public static Code EVEX_Vfpclassps_kr_k1_ymmm256b32_imm8;
    
public static Code EVEX_Vfpclassps_kr_k1_zmmm512b32_imm8;
    
public static Code EVEX_Vfpclasspd_kr_k1_xmmm128b64_imm8;
    
public static Code EVEX_Vfpclasspd_kr_k1_ymmm256b64_imm8;
    
public static Code EVEX_Vfpclasspd_kr_k1_zmmm512b64_imm8;
    
public static Code EVEX_Vfpclassss_kr_k1_xmmm32_imm8;
    
public static Code EVEX_Vfpclasssd_kr_k1_xmmm64_imm8;
    
public static Code VEX_Vfmaddps_xmm_xmm_xmmm128_xmm;
    
public static Code VEX_Vfmaddps_ymm_ymm_ymmm256_ymm;
    
public static Code VEX_Vfmaddps_xmm_xmm_xmm_xmmm128;
    
public static Code VEX_Vfmaddps_ymm_ymm_ymm_ymmm256;
    
public static Code VEX_Vfmaddpd_xmm_xmm_xmmm128_xmm;
    
public static Code VEX_Vfmaddpd_ymm_ymm_ymmm256_ymm;
    
public static Code VEX_Vfmaddpd_xmm_xmm_xmm_xmmm128;
    
public static Code VEX_Vfmaddpd_ymm_ymm_ymm_ymmm256;
    
public static Code VEX_Vfmaddss_xmm_xmm_xmmm32_xmm;
    
public static Code VEX_Vfmaddss_xmm_xmm_xmm_xmmm32;
    
public static Code VEX_Vfmaddsd_xmm_xmm_xmmm64_xmm;
    
public static Code VEX_Vfmaddsd_xmm_xmm_xmm_xmmm64;
    
public static Code VEX_Vfmsubps_xmm_xmm_xmmm128_xmm;
    
public static Code VEX_Vfmsubps_ymm_ymm_ymmm256_ymm;
    
public static Code VEX_Vfmsubps_xmm_xmm_xmm_xmmm128;
    
public static Code VEX_Vfmsubps_ymm_ymm_ymm_ymmm256;
    
public static Code VEX_Vfmsubpd_xmm_xmm_xmmm128_xmm;
    
public static Code VEX_Vfmsubpd_ymm_ymm_ymmm256_ymm;
    
public static Code VEX_Vfmsubpd_xmm_xmm_xmm_xmmm128;
    
public static Code VEX_Vfmsubpd_ymm_ymm_ymm_ymmm256;
    
public static Code VEX_Vfmsubss_xmm_xmm_xmmm32_xmm;
    
public static Code VEX_Vfmsubss_xmm_xmm_xmm_xmmm32;
    
public static Code VEX_Vfmsubsd_xmm_xmm_xmmm64_xmm;
    
public static Code VEX_Vfmsubsd_xmm_xmm_xmm_xmmm64;
    
public static Code EVEX_Vpshldw_xmm_k1z_xmm_xmmm128_imm8;
    
public static Code EVEX_Vpshldw_ymm_k1z_ymm_ymmm256_imm8;
    
public static Code EVEX_Vpshldw_zmm_k1z_zmm_zmmm512_imm8;
    
public static Code EVEX_Vpshldd_xmm_k1z_xmm_xmmm128b32_imm8;
    
public static Code EVEX_Vpshldd_ymm_k1z_ymm_ymmm256b32_imm8;
    
public static Code EVEX_Vpshldd_zmm_k1z_zmm_zmmm512b32_imm8;
    
public static Code EVEX_Vpshldq_xmm_k1z_xmm_xmmm128b64_imm8;
    
public static Code EVEX_Vpshldq_ymm_k1z_ymm_ymmm256b64_imm8;
    
public static Code EVEX_Vpshldq_zmm_k1z_zmm_zmmm512b64_imm8;
    
public static Code EVEX_Vpshrdw_xmm_k1z_xmm_xmmm128_imm8;
    
public static Code EVEX_Vpshrdw_ymm_k1z_ymm_ymmm256_imm8;
    
public static Code EVEX_Vpshrdw_zmm_k1z_zmm_zmmm512_imm8;
    
public static Code EVEX_Vpshrdd_xmm_k1z_xmm_xmmm128b32_imm8;
    
public static Code EVEX_Vpshrdd_ymm_k1z_ymm_ymmm256b32_imm8;
    
public static Code EVEX_Vpshrdd_zmm_k1z_zmm_zmmm512b32_imm8;
    
public static Code EVEX_Vpshrdq_xmm_k1z_xmm_xmmm128b64_imm8;
    
public static Code EVEX_Vpshrdq_ymm_k1z_ymm_ymmm256b64_imm8;
    
public static Code EVEX_Vpshrdq_zmm_k1z_zmm_zmmm512b64_imm8;
    
public static Code VEX_Vfnmaddps_xmm_xmm_xmmm128_xmm;
    
public static Code VEX_Vfnmaddps_ymm_ymm_ymmm256_ymm;
    
public static Code VEX_Vfnmaddps_xmm_xmm_xmm_xmmm128;
    
public static Code VEX_Vfnmaddps_ymm_ymm_ymm_ymmm256;
    
public static Code VEX_Vfnmaddpd_xmm_xmm_xmmm128_xmm;
    
public static Code VEX_Vfnmaddpd_ymm_ymm_ymmm256_ymm;
    
public static Code VEX_Vfnmaddpd_xmm_xmm_xmm_xmmm128;
    
public static Code VEX_Vfnmaddpd_ymm_ymm_ymm_ymmm256;
    
public static Code VEX_Vfnmaddss_xmm_xmm_xmmm32_xmm;
    
public static Code VEX_Vfnmaddss_xmm_xmm_xmm_xmmm32;
    
public static Code VEX_Vfnmaddsd_xmm_xmm_xmmm64_xmm;
    
public static Code VEX_Vfnmaddsd_xmm_xmm_xmm_xmmm64;
    
public static Code VEX_Vfnmsubps_xmm_xmm_xmmm128_xmm;
    
public static Code VEX_Vfnmsubps_ymm_ymm_ymmm256_ymm;
    
public static Code VEX_Vfnmsubps_xmm_xmm_xmm_xmmm128;
    
public static Code VEX_Vfnmsubps_ymm_ymm_ymm_ymmm256;
    
public static Code VEX_Vfnmsubpd_xmm_xmm_xmmm128_xmm;
    
public static Code VEX_Vfnmsubpd_ymm_ymm_ymmm256_ymm;
    
public static Code VEX_Vfnmsubpd_xmm_xmm_xmm_xmmm128;
    
public static Code VEX_Vfnmsubpd_ymm_ymm_ymm_ymmm256;
    
public static Code VEX_Vfnmsubss_xmm_xmm_xmmm32_xmm;
    
public static Code VEX_Vfnmsubss_xmm_xmm_xmm_xmmm32;
    
public static Code VEX_Vfnmsubsd_xmm_xmm_xmmm64_xmm;
    
public static Code VEX_Vfnmsubsd_xmm_xmm_xmm_xmmm64;
    
public static Code Sha1rnds4_xmm_xmmm128_imm8;
    
public static Code Gf2p8affineqb_xmm_xmmm128_imm8;
    
public static Code VEX_Vgf2p8affineqb_xmm_xmm_xmmm128_imm8;
    
public static Code VEX_Vgf2p8affineqb_ymm_ymm_ymmm256_imm8;
    
public static Code EVEX_Vgf2p8affineqb_xmm_k1z_xmm_xmmm128b64_imm8;
    
public static Code EVEX_Vgf2p8affineqb_ymm_k1z_ymm_ymmm256b64_imm8;
    
public static Code EVEX_Vgf2p8affineqb_zmm_k1z_zmm_zmmm512b64_imm8;
    
public static Code Gf2p8affineinvqb_xmm_xmmm128_imm8;
    
public static Code VEX_Vgf2p8affineinvqb_xmm_xmm_xmmm128_imm8;
    
public static Code VEX_Vgf2p8affineinvqb_ymm_ymm_ymmm256_imm8;
    
public static Code EVEX_Vgf2p8affineinvqb_xmm_k1z_xmm_xmmm128b64_imm8;
    
public static Code EVEX_Vgf2p8affineinvqb_ymm_k1z_ymm_ymmm256b64_imm8;
    
public static Code EVEX_Vgf2p8affineinvqb_zmm_k1z_zmm_zmmm512b64_imm8;
    
public static Code Aeskeygenassist_xmm_xmmm128_imm8;
    
public static Code VEX_Vaeskeygenassist_xmm_xmmm128_imm8;
    
public static Code VEX_Rorx_r32_rm32_imm8;
    
public static Code VEX_Rorx_r64_rm64_imm8;
    
public static Code XOP_Vpmacssww_xmm_xmm_xmmm128_xmm;
    
public static Code XOP_Vpmacsswd_xmm_xmm_xmmm128_xmm;
    
public static Code XOP_Vpmacssdql_xmm_xmm_xmmm128_xmm;
    
public static Code XOP_Vpmacssdd_xmm_xmm_xmmm128_xmm;
    
public static Code XOP_Vpmacssdqh_xmm_xmm_xmmm128_xmm;
    
public static Code XOP_Vpmacsww_xmm_xmm_xmmm128_xmm;
    
public static Code XOP_Vpmacswd_xmm_xmm_xmmm128_xmm;
    
public static Code XOP_Vpmacsdql_xmm_xmm_xmmm128_xmm;
    
public static Code XOP_Vpmacsdd_xmm_xmm_xmmm128_xmm;
    
public static Code XOP_Vpmacsdqh_xmm_xmm_xmmm128_xmm;
    
public static Code XOP_Vpcmov_xmm_xmm_xmmm128_xmm;
    
public static Code XOP_Vpcmov_ymm_ymm_ymmm256_ymm;
    
public static Code XOP_Vpcmov_xmm_xmm_xmm_xmmm128;
    
public static Code XOP_Vpcmov_ymm_ymm_ymm_ymmm256;
    
public static Code XOP_Vpperm_xmm_xmm_xmmm128_xmm;
    
public static Code XOP_Vpperm_xmm_xmm_xmm_xmmm128;
    
public static Code XOP_Vpmadcsswd_xmm_xmm_xmmm128_xmm;
    
public static Code XOP_Vpmadcswd_xmm_xmm_xmmm128_xmm;
    
public static Code XOP_Vprotb_xmm_xmmm128_imm8;
    
public static Code XOP_Vprotw_xmm_xmmm128_imm8;
    
public static Code XOP_Vprotd_xmm_xmmm128_imm8;
    
public static Code XOP_Vprotq_xmm_xmmm128_imm8;
    
public static Code XOP_Vpcomb_xmm_xmm_xmmm128_imm8;
    
public static Code XOP_Vpcomw_xmm_xmm_xmmm128_imm8;
    
public static Code XOP_Vpcomd_xmm_xmm_xmmm128_imm8;
    
public static Code XOP_Vpcomq_xmm_xmm_xmmm128_imm8;
    
public static Code XOP_Vpcomub_xmm_xmm_xmmm128_imm8;
    
public static Code XOP_Vpcomuw_xmm_xmm_xmmm128_imm8;
    
public static Code XOP_Vpcomud_xmm_xmm_xmmm128_imm8;
    
public static Code XOP_Vpcomuq_xmm_xmm_xmmm128_imm8;
    
public static Code XOP_Blcfill_r32_rm32;
    
public static Code XOP_Blcfill_r64_rm64;
    
public static Code XOP_Blsfill_r32_rm32;
    
public static Code XOP_Blsfill_r64_rm64;
    
public static Code XOP_Blcs_r32_rm32;
    
public static Code XOP_Blcs_r64_rm64;
    
public static Code XOP_Tzmsk_r32_rm32;
    
public static Code XOP_Tzmsk_r64_rm64;
    
public static Code XOP_Blcic_r32_rm32;
    
public static Code XOP_Blcic_r64_rm64;
    
public static Code XOP_Blsic_r32_rm32;
    
public static Code XOP_Blsic_r64_rm64;
    
public static Code XOP_T1mskc_r32_rm32;
    
public static Code XOP_T1mskc_r64_rm64;
    
public static Code XOP_Blcmsk_r32_rm32;
    
public static Code XOP_Blcmsk_r64_rm64;
    
public static Code XOP_Blci_r32_rm32;
    
public static Code XOP_Blci_r64_rm64;
    
public static Code XOP_Llwpcb_r32;
    
public static Code XOP_Llwpcb_r64;
    
public static Code XOP_Slwpcb_r32;
    
public static Code XOP_Slwpcb_r64;
    
public static Code XOP_Vfrczps_xmm_xmmm128;
    
public static Code XOP_Vfrczps_ymm_ymmm256;
    
public static Code XOP_Vfrczpd_xmm_xmmm128;
    
public static Code XOP_Vfrczpd_ymm_ymmm256;
    
public static Code XOP_Vfrczss_xmm_xmmm32;
    
public static Code XOP_Vfrczsd_xmm_xmmm64;
    
public static Code XOP_Vprotb_xmm_xmmm128_xmm;
    
public static Code XOP_Vprotb_xmm_xmm_xmmm128;
    
public static Code XOP_Vprotw_xmm_xmmm128_xmm;
    
public static Code XOP_Vprotw_xmm_xmm_xmmm128;
    
public static Code XOP_Vprotd_xmm_xmmm128_xmm;
    
public static Code XOP_Vprotd_xmm_xmm_xmmm128;
    
public static Code XOP_Vprotq_xmm_xmmm128_xmm;
    
public static Code XOP_Vprotq_xmm_xmm_xmmm128;
    
public static Code XOP_Vpshlb_xmm_xmmm128_xmm;
    
public static Code XOP_Vpshlb_xmm_xmm_xmmm128;
    
public static Code XOP_Vpshlw_xmm_xmmm128_xmm;
    
public static Code XOP_Vpshlw_xmm_xmm_xmmm128;
    
public static Code XOP_Vpshld_xmm_xmmm128_xmm;
    
public static Code XOP_Vpshld_xmm_xmm_xmmm128;
    
public static Code XOP_Vpshlq_xmm_xmmm128_xmm;
    
public static Code XOP_Vpshlq_xmm_xmm_xmmm128;
    
public static Code XOP_Vpshab_xmm_xmmm128_xmm;
    
public static Code XOP_Vpshab_xmm_xmm_xmmm128;
    
public static Code XOP_Vpshaw_xmm_xmmm128_xmm;
    
public static Code XOP_Vpshaw_xmm_xmm_xmmm128;
    
public static Code XOP_Vpshad_xmm_xmmm128_xmm;
    
public static Code XOP_Vpshad_xmm_xmm_xmmm128;
    
public static Code XOP_Vpshaq_xmm_xmmm128_xmm;
    
public static Code XOP_Vpshaq_xmm_xmm_xmmm128;
    
public static Code XOP_Vphaddbw_xmm_xmmm128;
    
public static Code XOP_Vphaddbd_xmm_xmmm128;
    
public static Code XOP_Vphaddbq_xmm_xmmm128;
    
public static Code XOP_Vphaddwd_xmm_xmmm128;
    
public static Code XOP_Vphaddwq_xmm_xmmm128;
    
public static Code XOP_Vphadddq_xmm_xmmm128;
    
public static Code XOP_Vphaddubw_xmm_xmmm128;
    
public static Code XOP_Vphaddubd_xmm_xmmm128;
    
public static Code XOP_Vphaddubq_xmm_xmmm128;
    
public static Code XOP_Vphadduwd_xmm_xmmm128;
    
public static Code XOP_Vphadduwq_xmm_xmmm128;
    
public static Code XOP_Vphaddudq_xmm_xmmm128;
    
public static Code XOP_Vphsubbw_xmm_xmmm128;
    
public static Code XOP_Vphsubwd_xmm_xmmm128;
    
public static Code XOP_Vphsubdq_xmm_xmmm128;
    
public static Code XOP_Bextr_r32_rm32_imm32;
    
public static Code XOP_Bextr_r64_rm64_imm32;
    
public static Code XOP_Lwpins_r32_rm32_imm32;
    
public static Code XOP_Lwpins_r64_rm32_imm32;
    
public static Code XOP_Lwpval_r32_rm32_imm32;
    
public static Code XOP_Lwpval_r64_rm32_imm32;
    
public static Code D3NOW_Pi2fw_mm_mmm64;
    
public static Code D3NOW_Pi2fd_mm_mmm64;
    
public static Code D3NOW_Pf2iw_mm_mmm64;
    
public static Code D3NOW_Pf2id_mm_mmm64;
    
public static Code D3NOW_Pfrcpv_mm_mmm64;
    
public static Code D3NOW_Pfrsqrtv_mm_mmm64;
    
public static Code D3NOW_Pfnacc_mm_mmm64;
    
public static Code D3NOW_Pfpnacc_mm_mmm64;
    
public static Code D3NOW_Pfcmpge_mm_mmm64;
    
public static Code D3NOW_Pfmin_mm_mmm64;
    
public static Code D3NOW_Pfrcp_mm_mmm64;
    
public static Code D3NOW_Pfrsqrt_mm_mmm64;
    
public static Code D3NOW_Pfsub_mm_mmm64;
    
public static Code D3NOW_Pfadd_mm_mmm64;
    
public static Code D3NOW_Pfcmpgt_mm_mmm64;
    
public static Code D3NOW_Pfmax_mm_mmm64;
    
public static Code D3NOW_Pfrcpit1_mm_mmm64;
    
public static Code D3NOW_Pfrsqit1_mm_mmm64;
    
public static Code D3NOW_Pfsubr_mm_mmm64;
    
public static Code D3NOW_Pfacc_mm_mmm64;
    
public static Code D3NOW_Pfcmpeq_mm_mmm64;
    
public static Code D3NOW_Pfmul_mm_mmm64;
    
public static Code D3NOW_Pfrcpit2_mm_mmm64;
    
public static Code D3NOW_Pmulhrw_mm_mmm64;
    
public static Code D3NOW_Pswapd_mm_mmm64;
    
public static Code D3NOW_Pavgusb_mm_mmm64;
    
public static Code Rmpadjust;
    
public static Code Rmpupdate;
    
public static Code Psmash;
    
public static Code Pvalidatew;
    
public static Code Pvalidated;
    
public static Code Pvalidateq;
    
public static Code Serialize;
    
public static Code Xsusldtrk;
    
public static Code Xresldtrk;
    
public static Code Invlpgbw;
    
public static Code Invlpgbd;
    
public static Code Invlpgbq;
    
public static Code Tlbsync;
    
public static Code Prefetchreserved3_m8;
    
public static Code Prefetchreserved4_m8;
    
public static Code Prefetchreserved5_m8;
    
public static Code Prefetchreserved6_m8;
    
public static Code Prefetchreserved7_m8;
    
public static Code Ud0;
    
public static Code Vmgexit;
    
public static Code Getsecq;
    
public static Code VEX_Ldtilecfg_m512;
    
public static Code VEX_Tilerelease;
    
public static Code VEX_Sttilecfg_m512;
    
public static Code VEX_Tilezero_tmm;
    
public static Code VEX_Tileloaddt1_tmm_sibmem;
    
public static Code VEX_Tilestored_sibmem_tmm;
    
public static Code VEX_Tileloadd_tmm_sibmem;
    
public static Code VEX_Tdpbf16ps_tmm_tmm_tmm;
    
public static Code VEX_Tdpbuud_tmm_tmm_tmm;
    
public static Code VEX_Tdpbusd_tmm_tmm_tmm;
    
public static Code VEX_Tdpbsud_tmm_tmm_tmm;
    
public static Code VEX_Tdpbssd_tmm_tmm_tmm;
    
public static Code Fnstdw_AX;
    
public static Code Fnstsg_AX;
    
public static Code Rdshr_rm32;
    
public static Code Wrshr_rm32;
    
public static Code Smint;
    
public static Code Dmint;
    
public static Code Rdm;
    
public static Code Svdc_m80_Sreg;
    
public static Code Rsdc_Sreg_m80;
    
public static Code Svldt_m80;
    
public static Code Rsldt_m80;
    
public static Code Svts_m80;
    
public static Code Rsts_m80;
    
public static Code Smint_0F7E;
    
public static Code Bb0_reset;
    
public static Code Bb1_reset;
    
public static Code Cpu_write;
    
public static Code Cpu_read;
    
public static Code Altinst;
    
public static Code Paveb_mm_mmm64;
    
public static Code Paddsiw_mm_mmm64;
    
public static Code Pmagw_mm_mmm64;
    
public static Code Pdistib_mm_m64;
    
public static Code Psubsiw_mm_mmm64;
    
public static Code Pmvzb_mm_m64;
    
public static Code Pmulhrw_mm_mmm64;
    
public static Code Pmvnzb_mm_m64;
    
public static Code Pmvlzb_mm_m64;
    
public static Code Pmvgezb_mm_m64;
    
public static Code Pmulhriw_mm_mmm64;
    
public static Code Pmachriw_mm_m64;
    
public static Code Cyrix_D9D7;
    
public static Code Cyrix_D9E2;
    
public static Code Ftstp;
    
public static Code Cyrix_D9E7;
    
public static Code Frint2;
    
public static Code Frichop;
    
public static Code Cyrix_DED8;
    
public static Code Cyrix_DEDA;
    
public static Code Cyrix_DEDC;
    
public static Code Cyrix_DEDD;
    
public static Code Cyrix_DEDE;
    
public static Code Frinear;
    
public static Code Tdcall;
    
public static Code Seamret;
    
public static Code Seamops;
    
public static Code Seamcall;
    
public static Code Aesencwide128kl_m384;
    
public static Code Aesdecwide128kl_m384;
    
public static Code Aesencwide256kl_m512;
    
public static Code Aesdecwide256kl_m512;
    
public static Code Loadiwkey_xmm_xmm;
    
public static Code Aesenc128kl_xmm_m384;
    
public static Code Aesdec128kl_xmm_m384;
    
public static Code Aesenc256kl_xmm_m512;
    
public static Code Aesdec256kl_xmm_m512;
    
public static Code Encodekey128_r32_r32;
    
public static Code Encodekey256_r32_r32;
    
public static Code VEX_Vbroadcastss_xmm_xmm;
    
public static Code VEX_Vbroadcastss_ymm_xmm;
    
public static Code VEX_Vbroadcastsd_ymm_xmm;
    
public static Code Vmgexit_F2;
    
public static Code Uiret;
    
public static Code Testui;
    
public static Code Clui;
    
public static Code Stui;
    
public static Code Senduipi_r64;
    
public static Code Hreset_imm8;
    
public static Code VEX_Vpdpbusd_xmm_xmm_xmmm128;
    
public static Code VEX_Vpdpbusd_ymm_ymm_ymmm256;
    
public static Code VEX_Vpdpbusds_xmm_xmm_xmmm128;
    
public static Code VEX_Vpdpbusds_ymm_ymm_ymmm256;
    
public static Code VEX_Vpdpwssd_xmm_xmm_xmmm128;
    
public static Code VEX_Vpdpwssd_ymm_ymm_ymmm256;
    
public static Code VEX_Vpdpwssds_xmm_xmm_xmmm128;
    
public static Code VEX_Vpdpwssds_ymm_ymm_ymmm256;
    
public static Code Ccs_hash_16;
    
public static Code Ccs_hash_32;
    
public static Code Ccs_hash_64;
    
public static Code Ccs_encrypt_16;
    
public static Code Ccs_encrypt_32;
    
public static Code Ccs_encrypt_64;
    
public static Code Lkgs_rm16;
    
public static Code Lkgs_r32m16;
    
public static Code Lkgs_r64m16;
    
public static Code Eretu;
    
public static Code Erets;
    
public static Code EVEX_Vaddph_xmm_k1z_xmm_xmmm128b16;
    
public static Code EVEX_Vaddph_ymm_k1z_ymm_ymmm256b16;
    
public static Code EVEX_Vaddph_zmm_k1z_zmm_zmmm512b16_er;
    
public static Code EVEX_Vaddsh_xmm_k1z_xmm_xmmm16_er;
    
public static Code EVEX_Vcmpph_kr_k1_xmm_xmmm128b16_imm8;
    
public static Code EVEX_Vcmpph_kr_k1_ymm_ymmm256b16_imm8;
    
public static Code EVEX_Vcmpph_kr_k1_zmm_zmmm512b16_imm8_sae;
    
public static Code EVEX_Vcmpsh_kr_k1_xmm_xmmm16_imm8_sae;
    
public static Code EVEX_Vcomish_xmm_xmmm16_sae;
    
public static Code EVEX_Vcvtdq2ph_xmm_k1z_xmmm128b32;
    
public static Code EVEX_Vcvtdq2ph_xmm_k1z_ymmm256b32;
    
public static Code EVEX_Vcvtdq2ph_ymm_k1z_zmmm512b32_er;
    
public static Code EVEX_Vcvtpd2ph_xmm_k1z_xmmm128b64;
    
public static Code EVEX_Vcvtpd2ph_xmm_k1z_ymmm256b64;
    
public static Code EVEX_Vcvtpd2ph_xmm_k1z_zmmm512b64_er;
    
public static Code EVEX_Vcvtph2dq_xmm_k1z_xmmm64b16;
    
public static Code EVEX_Vcvtph2dq_ymm_k1z_xmmm128b16;
    
public static Code EVEX_Vcvtph2dq_zmm_k1z_ymmm256b16_er;
    
public static Code EVEX_Vcvtph2pd_xmm_k1z_xmmm32b16;
    
public static Code EVEX_Vcvtph2pd_ymm_k1z_xmmm64b16;
    
public static Code EVEX_Vcvtph2pd_zmm_k1z_xmmm128b16_sae;
    
public static Code EVEX_Vcvtph2psx_xmm_k1z_xmmm64b16;
    
public static Code EVEX_Vcvtph2psx_ymm_k1z_xmmm128b16;
    
public static Code EVEX_Vcvtph2psx_zmm_k1z_ymmm256b16_sae;
    
public static Code EVEX_Vcvtph2qq_xmm_k1z_xmmm32b16;
    
public static Code EVEX_Vcvtph2qq_ymm_k1z_xmmm64b16;
    
public static Code EVEX_Vcvtph2qq_zmm_k1z_xmmm128b16_er;
    
public static Code EVEX_Vcvtph2udq_xmm_k1z_xmmm64b16;
    
public static Code EVEX_Vcvtph2udq_ymm_k1z_xmmm128b16;
    
public static Code EVEX_Vcvtph2udq_zmm_k1z_ymmm256b16_er;
    
public static Code EVEX_Vcvtph2uqq_xmm_k1z_xmmm32b16;
    
public static Code EVEX_Vcvtph2uqq_ymm_k1z_xmmm64b16;
    
public static Code EVEX_Vcvtph2uqq_zmm_k1z_xmmm128b16_er;
    
public static Code EVEX_Vcvtph2uw_xmm_k1z_xmmm128b16;
    
public static Code EVEX_Vcvtph2uw_ymm_k1z_ymmm256b16;
    
public static Code EVEX_Vcvtph2uw_zmm_k1z_zmmm512b16_er;
    
public static Code EVEX_Vcvtph2w_xmm_k1z_xmmm128b16;
    
public static Code EVEX_Vcvtph2w_ymm_k1z_ymmm256b16;
    
public static Code EVEX_Vcvtph2w_zmm_k1z_zmmm512b16_er;
    
public static Code EVEX_Vcvtps2phx_xmm_k1z_xmmm128b32;
    
public static Code EVEX_Vcvtps2phx_xmm_k1z_ymmm256b32;
    
public static Code EVEX_Vcvtps2phx_ymm_k1z_zmmm512b32_er;
    
public static Code EVEX_Vcvtqq2ph_xmm_k1z_xmmm128b64;
    
public static Code EVEX_Vcvtqq2ph_xmm_k1z_ymmm256b64;
    
public static Code EVEX_Vcvtqq2ph_xmm_k1z_zmmm512b64_er;
    
public static Code EVEX_Vcvtsd2sh_xmm_k1z_xmm_xmmm64_er;
    
public static Code EVEX_Vcvtsh2sd_xmm_k1z_xmm_xmmm16_sae;
    
public static Code EVEX_Vcvtsh2si_r32_xmmm16_er;
    
public static Code EVEX_Vcvtsh2si_r64_xmmm16_er;
    
public static Code EVEX_Vcvtsh2ss_xmm_k1z_xmm_xmmm16_sae;
    
public static Code EVEX_Vcvtsh2usi_r32_xmmm16_er;
    
public static Code EVEX_Vcvtsh2usi_r64_xmmm16_er;
    
public static Code EVEX_Vcvtsi2sh_xmm_xmm_rm32_er;
    
public static Code EVEX_Vcvtsi2sh_xmm_xmm_rm64_er;
    
public static Code EVEX_Vcvtss2sh_xmm_k1z_xmm_xmmm32_er;
    
public static Code EVEX_Vcvttph2dq_xmm_k1z_xmmm64b16;
    
public static Code EVEX_Vcvttph2dq_ymm_k1z_xmmm128b16;
    
public static Code EVEX_Vcvttph2dq_zmm_k1z_ymmm256b16_sae;
    
public static Code EVEX_Vcvttph2qq_xmm_k1z_xmmm32b16;
    
public static Code EVEX_Vcvttph2qq_ymm_k1z_xmmm64b16;
    
public static Code EVEX_Vcvttph2qq_zmm_k1z_xmmm128b16_sae;
    
public static Code EVEX_Vcvttph2udq_xmm_k1z_xmmm64b16;
    
public static Code EVEX_Vcvttph2udq_ymm_k1z_xmmm128b16;
    
public static Code EVEX_Vcvttph2udq_zmm_k1z_ymmm256b16_sae;
    
public static Code EVEX_Vcvttph2uqq_xmm_k1z_xmmm32b16;
    
public static Code EVEX_Vcvttph2uqq_ymm_k1z_xmmm64b16;
    
public static Code EVEX_Vcvttph2uqq_zmm_k1z_xmmm128b16_sae;
    
public static Code EVEX_Vcvttph2uw_xmm_k1z_xmmm128b16;
    
public static Code EVEX_Vcvttph2uw_ymm_k1z_ymmm256b16;
    
public static Code EVEX_Vcvttph2uw_zmm_k1z_zmmm512b16_sae;
    
public static Code EVEX_Vcvttph2w_xmm_k1z_xmmm128b16;
    
public static Code EVEX_Vcvttph2w_ymm_k1z_ymmm256b16;
    
public static Code EVEX_Vcvttph2w_zmm_k1z_zmmm512b16_sae;
    
public static Code EVEX_Vcvttsh2si_r32_xmmm16_sae;
    
public static Code EVEX_Vcvttsh2si_r64_xmmm16_sae;
    
public static Code EVEX_Vcvttsh2usi_r32_xmmm16_sae;
    
public static Code EVEX_Vcvttsh2usi_r64_xmmm16_sae;
    
public static Code EVEX_Vcvtudq2ph_xmm_k1z_xmmm128b32;
    
public static Code EVEX_Vcvtudq2ph_xmm_k1z_ymmm256b32;
    
public static Code EVEX_Vcvtudq2ph_ymm_k1z_zmmm512b32_er;
    
public static Code EVEX_Vcvtuqq2ph_xmm_k1z_xmmm128b64;
    
public static Code EVEX_Vcvtuqq2ph_xmm_k1z_ymmm256b64;
    
public static Code EVEX_Vcvtuqq2ph_xmm_k1z_zmmm512b64_er;
    
public static Code EVEX_Vcvtusi2sh_xmm_xmm_rm32_er;
    
public static Code EVEX_Vcvtusi2sh_xmm_xmm_rm64_er;
    
public static Code EVEX_Vcvtuw2ph_xmm_k1z_xmmm128b16;
    
public static Code EVEX_Vcvtuw2ph_ymm_k1z_ymmm256b16;
    
public static Code EVEX_Vcvtuw2ph_zmm_k1z_zmmm512b16_er;
    
public static Code EVEX_Vcvtw2ph_xmm_k1z_xmmm128b16;
    
public static Code EVEX_Vcvtw2ph_ymm_k1z_ymmm256b16;
    
public static Code EVEX_Vcvtw2ph_zmm_k1z_zmmm512b16_er;
    
public static Code EVEX_Vdivph_xmm_k1z_xmm_xmmm128b16;
    
public static Code EVEX_Vdivph_ymm_k1z_ymm_ymmm256b16;
    
public static Code EVEX_Vdivph_zmm_k1z_zmm_zmmm512b16_er;
    
public static Code EVEX_Vdivsh_xmm_k1z_xmm_xmmm16_er;
    
public static Code EVEX_Vfcmaddcph_xmm_k1z_xmm_xmmm128b32;
    
public static Code EVEX_Vfcmaddcph_ymm_k1z_ymm_ymmm256b32;
    
public static Code EVEX_Vfcmaddcph_zmm_k1z_zmm_zmmm512b32_er;
    
public static Code EVEX_Vfmaddcph_xmm_k1z_xmm_xmmm128b32;
    
public static Code EVEX_Vfmaddcph_ymm_k1z_ymm_ymmm256b32;
    
public static Code EVEX_Vfmaddcph_zmm_k1z_zmm_zmmm512b32_er;
    
public static Code EVEX_Vfcmaddcsh_xmm_k1z_xmm_xmmm32_er;
    
public static Code EVEX_Vfmaddcsh_xmm_k1z_xmm_xmmm32_er;
    
public static Code EVEX_Vfcmulcph_xmm_k1z_xmm_xmmm128b32;
    
public static Code EVEX_Vfcmulcph_ymm_k1z_ymm_ymmm256b32;
    
public static Code EVEX_Vfcmulcph_zmm_k1z_zmm_zmmm512b32_er;
    
public static Code EVEX_Vfmulcph_xmm_k1z_xmm_xmmm128b32;
    
public static Code EVEX_Vfmulcph_ymm_k1z_ymm_ymmm256b32;
    
public static Code EVEX_Vfmulcph_zmm_k1z_zmm_zmmm512b32_er;
    
public static Code EVEX_Vfcmulcsh_xmm_k1z_xmm_xmmm32_er;
    
public static Code EVEX_Vfmulcsh_xmm_k1z_xmm_xmmm32_er;
    
public static Code EVEX_Vfmaddsub132ph_xmm_k1z_xmm_xmmm128b16;
    
public static Code EVEX_Vfmaddsub132ph_ymm_k1z_ymm_ymmm256b16;
    
public static Code EVEX_Vfmaddsub132ph_zmm_k1z_zmm_zmmm512b16_er;
    
public static Code EVEX_Vfmaddsub213ph_xmm_k1z_xmm_xmmm128b16;
    
public static Code EVEX_Vfmaddsub213ph_ymm_k1z_ymm_ymmm256b16;
    
public static Code EVEX_Vfmaddsub213ph_zmm_k1z_zmm_zmmm512b16_er;
    
public static Code EVEX_Vfmaddsub231ph_xmm_k1z_xmm_xmmm128b16;
    
public static Code EVEX_Vfmaddsub231ph_ymm_k1z_ymm_ymmm256b16;
    
public static Code EVEX_Vfmaddsub231ph_zmm_k1z_zmm_zmmm512b16_er;
    
public static Code EVEX_Vfmsubadd132ph_xmm_k1z_xmm_xmmm128b16;
    
public static Code EVEX_Vfmsubadd132ph_ymm_k1z_ymm_ymmm256b16;
    
public static Code EVEX_Vfmsubadd132ph_zmm_k1z_zmm_zmmm512b16_er;
    
public static Code EVEX_Vfmsubadd213ph_xmm_k1z_xmm_xmmm128b16;
    
public static Code EVEX_Vfmsubadd213ph_ymm_k1z_ymm_ymmm256b16;
    
public static Code EVEX_Vfmsubadd213ph_zmm_k1z_zmm_zmmm512b16_er;
    
public static Code EVEX_Vfmsubadd231ph_xmm_k1z_xmm_xmmm128b16;
    
public static Code EVEX_Vfmsubadd231ph_ymm_k1z_ymm_ymmm256b16;
    
public static Code EVEX_Vfmsubadd231ph_zmm_k1z_zmm_zmmm512b16_er;
    
public static Code EVEX_Vfmadd132ph_xmm_k1z_xmm_xmmm128b16;
    
public static Code EVEX_Vfmadd132ph_ymm_k1z_ymm_ymmm256b16;
    
public static Code EVEX_Vfmadd132ph_zmm_k1z_zmm_zmmm512b16_er;
    
public static Code EVEX_Vfmadd213ph_xmm_k1z_xmm_xmmm128b16;
    
public static Code EVEX_Vfmadd213ph_ymm_k1z_ymm_ymmm256b16;
    
public static Code EVEX_Vfmadd213ph_zmm_k1z_zmm_zmmm512b16_er;
    
public static Code EVEX_Vfmadd231ph_xmm_k1z_xmm_xmmm128b16;
    
public static Code EVEX_Vfmadd231ph_ymm_k1z_ymm_ymmm256b16;
    
public static Code EVEX_Vfmadd231ph_zmm_k1z_zmm_zmmm512b16_er;
    
public static Code EVEX_Vfnmadd132ph_xmm_k1z_xmm_xmmm128b16;
    
public static Code EVEX_Vfnmadd132ph_ymm_k1z_ymm_ymmm256b16;
    
public static Code EVEX_Vfnmadd132ph_zmm_k1z_zmm_zmmm512b16_er;
    
public static Code EVEX_Vfnmadd213ph_xmm_k1z_xmm_xmmm128b16;
    
public static Code EVEX_Vfnmadd213ph_ymm_k1z_ymm_ymmm256b16;
    
public static Code EVEX_Vfnmadd213ph_zmm_k1z_zmm_zmmm512b16_er;
    
public static Code EVEX_Vfnmadd231ph_xmm_k1z_xmm_xmmm128b16;
    
public static Code EVEX_Vfnmadd231ph_ymm_k1z_ymm_ymmm256b16;
    
public static Code EVEX_Vfnmadd231ph_zmm_k1z_zmm_zmmm512b16_er;
    
public static Code EVEX_Vfmadd132sh_xmm_k1z_xmm_xmmm16_er;
    
public static Code EVEX_Vfmadd213sh_xmm_k1z_xmm_xmmm16_er;
    
public static Code EVEX_Vfmadd231sh_xmm_k1z_xmm_xmmm16_er;
    
public static Code EVEX_Vfnmadd132sh_xmm_k1z_xmm_xmmm16_er;
    
public static Code EVEX_Vfnmadd213sh_xmm_k1z_xmm_xmmm16_er;
    
public static Code EVEX_Vfnmadd231sh_xmm_k1z_xmm_xmmm16_er;
    
public static Code EVEX_Vfmsub132ph_xmm_k1z_xmm_xmmm128b16;
    
public static Code EVEX_Vfmsub132ph_ymm_k1z_ymm_ymmm256b16;
    
public static Code EVEX_Vfmsub132ph_zmm_k1z_zmm_zmmm512b16_er;
    
public static Code EVEX_Vfmsub213ph_xmm_k1z_xmm_xmmm128b16;
    
public static Code EVEX_Vfmsub213ph_ymm_k1z_ymm_ymmm256b16;
    
public static Code EVEX_Vfmsub213ph_zmm_k1z_zmm_zmmm512b16_er;
    
public static Code EVEX_Vfmsub231ph_xmm_k1z_xmm_xmmm128b16;
    
public static Code EVEX_Vfmsub231ph_ymm_k1z_ymm_ymmm256b16;
    
public static Code EVEX_Vfmsub231ph_zmm_k1z_zmm_zmmm512b16_er;
    
public static Code EVEX_Vfnmsub132ph_xmm_k1z_xmm_xmmm128b16;
    
public static Code EVEX_Vfnmsub132ph_ymm_k1z_ymm_ymmm256b16;
    
public static Code EVEX_Vfnmsub132ph_zmm_k1z_zmm_zmmm512b16_er;
    
public static Code EVEX_Vfnmsub213ph_xmm_k1z_xmm_xmmm128b16;
    
public static Code EVEX_Vfnmsub213ph_ymm_k1z_ymm_ymmm256b16;
    
public static Code EVEX_Vfnmsub213ph_zmm_k1z_zmm_zmmm512b16_er;
    
public static Code EVEX_Vfnmsub231ph_xmm_k1z_xmm_xmmm128b16;
    
public static Code EVEX_Vfnmsub231ph_ymm_k1z_ymm_ymmm256b16;
    
public static Code EVEX_Vfnmsub231ph_zmm_k1z_zmm_zmmm512b16_er;
    
public static Code EVEX_Vfmsub132sh_xmm_k1z_xmm_xmmm16_er;
    
public static Code EVEX_Vfmsub213sh_xmm_k1z_xmm_xmmm16_er;
    
public static Code EVEX_Vfmsub231sh_xmm_k1z_xmm_xmmm16_er;
    
public static Code EVEX_Vfnmsub132sh_xmm_k1z_xmm_xmmm16_er;
    
public static Code EVEX_Vfnmsub213sh_xmm_k1z_xmm_xmmm16_er;
    
public static Code EVEX_Vfnmsub231sh_xmm_k1z_xmm_xmmm16_er;
    
public static Code EVEX_Vfpclassph_kr_k1_xmmm128b16_imm8;
    
public static Code EVEX_Vfpclassph_kr_k1_ymmm256b16_imm8;
    
public static Code EVEX_Vfpclassph_kr_k1_zmmm512b16_imm8;
    
public static Code EVEX_Vfpclasssh_kr_k1_xmmm16_imm8;
    
public static Code EVEX_Vgetexpph_xmm_k1z_xmmm128b16;
    
public static Code EVEX_Vgetexpph_ymm_k1z_ymmm256b16;
    
public static Code EVEX_Vgetexpph_zmm_k1z_zmmm512b16_sae;
    
public static Code EVEX_Vgetexpsh_xmm_k1z_xmm_xmmm16_sae;
    
public static Code EVEX_Vgetmantph_xmm_k1z_xmmm128b16_imm8;
    
public static Code EVEX_Vgetmantph_ymm_k1z_ymmm256b16_imm8;
    
public static Code EVEX_Vgetmantph_zmm_k1z_zmmm512b16_imm8_sae;
    
public static Code EVEX_Vgetmantsh_xmm_k1z_xmm_xmmm16_imm8_sae;
    
public static Code EVEX_Vmaxph_xmm_k1z_xmm_xmmm128b16;
    
public static Code EVEX_Vmaxph_ymm_k1z_ymm_ymmm256b16;
    
public static Code EVEX_Vmaxph_zmm_k1z_zmm_zmmm512b16_sae;
    
public static Code EVEX_Vmaxsh_xmm_k1z_xmm_xmmm16_sae;
    
public static Code EVEX_Vminph_xmm_k1z_xmm_xmmm128b16;
    
public static Code EVEX_Vminph_ymm_k1z_ymm_ymmm256b16;
    
public static Code EVEX_Vminph_zmm_k1z_zmm_zmmm512b16_sae;
    
public static Code EVEX_Vminsh_xmm_k1z_xmm_xmmm16_sae;
    
public static Code EVEX_Vmovsh_xmm_k1z_m16;
    
public static Code EVEX_Vmovsh_m16_k1_xmm;
    
public static Code EVEX_Vmovsh_xmm_k1z_xmm_xmm;
    
public static Code EVEX_Vmovsh_xmm_k1z_xmm_xmm_MAP5_11;
    
public static Code EVEX_Vmovw_xmm_r32m16;
    
public static Code EVEX_Vmovw_xmm_r64m16;
    
public static Code EVEX_Vmovw_r32m16_xmm;
    
public static Code EVEX_Vmovw_r64m16_xmm;
    
public static Code EVEX_Vmulph_xmm_k1z_xmm_xmmm128b16;
    
public static Code EVEX_Vmulph_ymm_k1z_ymm_ymmm256b16;
    
public static Code EVEX_Vmulph_zmm_k1z_zmm_zmmm512b16_er;
    
public static Code EVEX_Vmulsh_xmm_k1z_xmm_xmmm16_er;
    
public static Code EVEX_Vrcpph_xmm_k1z_xmmm128b16;
    
public static Code EVEX_Vrcpph_ymm_k1z_ymmm256b16;
    
public static Code EVEX_Vrcpph_zmm_k1z_zmmm512b16;
    
public static Code EVEX_Vrcpsh_xmm_k1z_xmm_xmmm16;
    
public static Code EVEX_Vreduceph_xmm_k1z_xmmm128b16_imm8;
    
public static Code EVEX_Vreduceph_ymm_k1z_ymmm256b16_imm8;
    
public static Code EVEX_Vreduceph_zmm_k1z_zmmm512b16_imm8_sae;
    
public static Code EVEX_Vreducesh_xmm_k1z_xmm_xmmm16_imm8_sae;
    
public static Code EVEX_Vrndscaleph_xmm_k1z_xmmm128b16_imm8;
    
public static Code EVEX_Vrndscaleph_ymm_k1z_ymmm256b16_imm8;
    
public static Code EVEX_Vrndscaleph_zmm_k1z_zmmm512b16_imm8_sae;
    
public static Code EVEX_Vrndscalesh_xmm_k1z_xmm_xmmm16_imm8_sae;
    
public static Code EVEX_Vrsqrtph_xmm_k1z_xmmm128b16;
    
public static Code EVEX_Vrsqrtph_ymm_k1z_ymmm256b16;
    
public static Code EVEX_Vrsqrtph_zmm_k1z_zmmm512b16;
    
public static Code EVEX_Vrsqrtsh_xmm_k1z_xmm_xmmm16;
    
public static Code EVEX_Vscalefph_xmm_k1z_xmm_xmmm128b16;
    
public static Code EVEX_Vscalefph_ymm_k1z_ymm_ymmm256b16;
    
public static Code EVEX_Vscalefph_zmm_k1z_zmm_zmmm512b16_er;
    
public static Code EVEX_Vscalefsh_xmm_k1z_xmm_xmmm16_er;
    
public static Code EVEX_Vsqrtph_xmm_k1z_xmmm128b16;
    
public static Code EVEX_Vsqrtph_ymm_k1z_ymmm256b16;
    
public static Code EVEX_Vsqrtph_zmm_k1z_zmmm512b16_er;
    
public static Code EVEX_Vsqrtsh_xmm_k1z_xmm_xmmm16_er;
    
public static Code EVEX_Vsubph_xmm_k1z_xmm_xmmm128b16;
    
public static Code EVEX_Vsubph_ymm_k1z_ymm_ymmm256b16;
    
public static Code EVEX_Vsubph_zmm_k1z_zmm_zmmm512b16_er;
    
public static Code EVEX_Vsubsh_xmm_k1z_xmm_xmmm16_er;
    
public static Code EVEX_Vucomish_xmm_xmmm16_sae;
    
public static Code Rdudbg;
    
public static Code Wrudbg;
    
public static Code VEX_KNC_Jkzd_kr_rel8_64;
    
public static Code VEX_KNC_Jknzd_kr_rel8_64;
    
public static Code VEX_KNC_Vprefetchnta_m8;
    
public static Code VEX_KNC_Vprefetch0_m8;
    
public static Code VEX_KNC_Vprefetch1_m8;
    
public static Code VEX_KNC_Vprefetch2_m8;
    
public static Code VEX_KNC_Vprefetchenta_m8;
    
public static Code VEX_KNC_Vprefetche0_m8;
    
public static Code VEX_KNC_Vprefetche1_m8;
    
public static Code VEX_KNC_Vprefetche2_m8;
    
public static Code VEX_KNC_Kand_kr_kr;
    
public static Code VEX_KNC_Kandn_kr_kr;
    
public static Code VEX_KNC_Kandnr_kr_kr;
    
public static Code VEX_KNC_Knot_kr_kr;
    
public static Code VEX_KNC_Kor_kr_kr;
    
public static Code VEX_KNC_Kxnor_kr_kr;
    
public static Code VEX_KNC_Kxor_kr_kr;
    
public static Code VEX_KNC_Kmerge2l1h_kr_kr;
    
public static Code VEX_KNC_Kmerge2l1l_kr_kr;
    
public static Code VEX_KNC_Jkzd_kr_rel32_64;
    
public static Code VEX_KNC_Jknzd_kr_rel32_64;
    
public static Code VEX_KNC_Kmov_kr_kr;
    
public static Code VEX_KNC_Kmov_kr_r32;
    
public static Code VEX_KNC_Kmov_r32_kr;
    
public static Code VEX_KNC_Kconcath_r64_kr_kr;
    
public static Code VEX_KNC_Kconcatl_r64_kr_kr;
    
public static Code VEX_KNC_Kortest_kr_kr;
    
public static Code VEX_KNC_Delay_r32;
    
public static Code VEX_KNC_Delay_r64;
    
public static Code VEX_KNC_Spflt_r32;
    
public static Code VEX_KNC_Spflt_r64;
    
public static Code VEX_KNC_Clevict1_m8;
    
public static Code VEX_KNC_Clevict0_m8;
    
public static Code VEX_KNC_Popcnt_r32_r32;
    
public static Code VEX_KNC_Popcnt_r64_r64;
    
public static Code VEX_KNC_Tzcnt_r32_r32;
    
public static Code VEX_KNC_Tzcnt_r64_r64;
    
public static Code VEX_KNC_Tzcnti_r32_r32;
    
public static Code VEX_KNC_Tzcnti_r64_r64;
    
public static Code VEX_KNC_Lzcnt_r32_r32;
    
public static Code VEX_KNC_Lzcnt_r64_r64;
    
public static Code VEX_KNC_Undoc_r32_rm32_128_F3_0F38_W0_F0;
    
public static Code VEX_KNC_Undoc_r64_rm64_128_F3_0F38_W1_F0;
    
public static Code VEX_KNC_Undoc_r32_rm32_128_F2_0F38_W0_F0;
    
public static Code VEX_KNC_Undoc_r64_rm64_128_F2_0F38_W1_F0;
    
public static Code VEX_KNC_Undoc_r32_rm32_128_F2_0F38_W0_F1;
    
public static Code VEX_KNC_Undoc_r64_rm64_128_F2_0F38_W1_F1;
    
public static Code VEX_KNC_Kextract_kr_r64_imm8;
    
public static Code MVEX_Vprefetchnta_m;
    
public static Code MVEX_Vprefetch0_m;
    
public static Code MVEX_Vprefetch1_m;
    
public static Code MVEX_Vprefetch2_m;
    
public static Code MVEX_Vprefetchenta_m;
    
public static Code MVEX_Vprefetche0_m;
    
public static Code MVEX_Vprefetche1_m;
    
public static Code MVEX_Vprefetche2_m;
    
public static Code MVEX_Vmovaps_zmm_k1_zmmmt;
    
public static Code MVEX_Vmovapd_zmm_k1_zmmmt;
    
public static Code MVEX_Vmovaps_mt_k1_zmm;
    
public static Code MVEX_Vmovapd_mt_k1_zmm;
    
public static Code MVEX_Vmovnrapd_m_k1_zmm;
    
public static Code MVEX_Vmovnrngoapd_m_k1_zmm;
    
public static Code MVEX_Vmovnraps_m_k1_zmm;
    
public static Code MVEX_Vmovnrngoaps_m_k1_zmm;
    
public static Code MVEX_Vaddps_zmm_k1_zmm_zmmmt;
    
public static Code MVEX_Vaddpd_zmm_k1_zmm_zmmmt;
    
public static Code MVEX_Vmulps_zmm_k1_zmm_zmmmt;
    
public static Code MVEX_Vmulpd_zmm_k1_zmm_zmmmt;
    
public static Code MVEX_Vcvtps2pd_zmm_k1_zmmmt;
    
public static Code MVEX_Vcvtpd2ps_zmm_k1_zmmmt;
    
public static Code MVEX_Vsubps_zmm_k1_zmm_zmmmt;
    
public static Code MVEX_Vsubpd_zmm_k1_zmm_zmmmt;
    
public static Code MVEX_Vpcmpgtd_kr_k1_zmm_zmmmt;
    
public static Code MVEX_Vmovdqa32_zmm_k1_zmmmt;
    
public static Code MVEX_Vmovdqa64_zmm_k1_zmmmt;
    
public static Code MVEX_Vpshufd_zmm_k1_zmmmt_imm8;
    
public static Code MVEX_Vpsrld_zmm_k1_zmmmt_imm8;
    
public static Code MVEX_Vpsrad_zmm_k1_zmmmt_imm8;
    
public static Code MVEX_Vpslld_zmm_k1_zmmmt_imm8;
    
public static Code MVEX_Vpcmpeqd_kr_k1_zmm_zmmmt;
    
public static Code MVEX_Vcvtudq2pd_zmm_k1_zmmmt;
    
public static Code MVEX_Vmovdqa32_mt_k1_zmm;
    
public static Code MVEX_Vmovdqa64_mt_k1_zmm;
    
public static Code MVEX_Clevict1_m;
    
public static Code MVEX_Clevict0_m;
    
public static Code MVEX_Vcmpps_kr_k1_zmm_zmmmt_imm8;
    
public static Code MVEX_Vcmppd_kr_k1_zmm_zmmmt_imm8;
    
public static Code MVEX_Vpandd_zmm_k1_zmm_zmmmt;
    
public static Code MVEX_Vpandq_zmm_k1_zmm_zmmmt;
    
public static Code MVEX_Vpandnd_zmm_k1_zmm_zmmmt;
    
public static Code MVEX_Vpandnq_zmm_k1_zmm_zmmmt;
    
public static Code MVEX_Vcvtdq2pd_zmm_k1_zmmmt;
    
public static Code MVEX_Vpord_zmm_k1_zmm_zmmmt;
    
public static Code MVEX_Vporq_zmm_k1_zmm_zmmmt;
    
public static Code MVEX_Vpxord_zmm_k1_zmm_zmmmt;
    
public static Code MVEX_Vpxorq_zmm_k1_zmm_zmmmt;
    
public static Code MVEX_Vpsubd_zmm_k1_zmm_zmmmt;
    
public static Code MVEX_Vpaddd_zmm_k1_zmm_zmmmt;
    
public static Code MVEX_Vbroadcastss_zmm_k1_mt;
    
public static Code MVEX_Vbroadcastsd_zmm_k1_mt;
    
public static Code MVEX_Vbroadcastf32x4_zmm_k1_mt;
    
public static Code MVEX_Vbroadcastf64x4_zmm_k1_mt;
    
public static Code MVEX_Vptestmd_kr_k1_zmm_zmmmt;
    
public static Code MVEX_Vpermd_zmm_k1_zmm_zmmmt;
    
public static Code MVEX_Vpminsd_zmm_k1_zmm_zmmmt;
    
public static Code MVEX_Vpminud_zmm_k1_zmm_zmmmt;
    
public static Code MVEX_Vpmaxsd_zmm_k1_zmm_zmmmt;
    
public static Code MVEX_Vpmaxud_zmm_k1_zmm_zmmmt;
    
public static Code MVEX_Vpmulld_zmm_k1_zmm_zmmmt;
    
public static Code MVEX_Vgetexpps_zmm_k1_zmmmt;
    
public static Code MVEX_Vgetexppd_zmm_k1_zmmmt;
    
public static Code MVEX_Vpsrlvd_zmm_k1_zmm_zmmmt;
    
public static Code MVEX_Vpsravd_zmm_k1_zmm_zmmmt;
    
public static Code MVEX_Vpsllvd_zmm_k1_zmm_zmmmt;
    
public static Code MVEX_Undoc_zmm_k1_zmmmt_512_66_0F38_W0_48;
    
public static Code MVEX_Undoc_zmm_k1_zmmmt_512_66_0F38_W0_49;
    
public static Code MVEX_Undoc_zmm_k1_zmmmt_512_66_0F38_W0_4A;
    
public static Code MVEX_Undoc_zmm_k1_zmmmt_512_66_0F38_W0_4B;
    
public static Code MVEX_Vaddnps_zmm_k1_zmm_zmmmt;
    
public static Code MVEX_Vaddnpd_zmm_k1_zmm_zmmmt;
    
public static Code MVEX_Vgmaxabsps_zmm_k1_zmm_zmmmt;
    
public static Code MVEX_Vgminps_zmm_k1_zmm_zmmmt;
    
public static Code MVEX_Vgminpd_zmm_k1_zmm_zmmmt;
    
public static Code MVEX_Vgmaxps_zmm_k1_zmm_zmmmt;
    
public static Code MVEX_Vgmaxpd_zmm_k1_zmm_zmmmt;
    
public static Code MVEX_Undoc_zmm_k1_zmm_zmmmt_512_66_0F38_W0_54;
    
public static Code MVEX_Vfixupnanps_zmm_k1_zmm_zmmmt;
    
public static Code MVEX_Vfixupnanpd_zmm_k1_zmm_zmmmt;
    
public static Code MVEX_Undoc_zmm_k1_zmm_zmmmt_512_66_0F38_W0_56;
    
public static Code MVEX_Undoc_zmm_k1_zmm_zmmmt_512_66_0F38_W0_57;
    
public static Code MVEX_Vpbroadcastd_zmm_k1_mt;
    
public static Code MVEX_Vpbroadcastq_zmm_k1_mt;
    
public static Code MVEX_Vbroadcasti32x4_zmm_k1_mt;
    
public static Code MVEX_Vbroadcasti64x4_zmm_k1_mt;
    
public static Code MVEX_Vpadcd_zmm_k1_kr_zmmmt;
    
public static Code MVEX_Vpaddsetcd_zmm_k1_kr_zmmmt;
    
public static Code MVEX_Vpsbbd_zmm_k1_kr_zmmmt;
    
public static Code MVEX_Vpsubsetbd_zmm_k1_kr_zmmmt;
    
public static Code MVEX_Vpblendmd_zmm_k1_zmm_zmmmt;
    
public static Code MVEX_Vpblendmq_zmm_k1_zmm_zmmmt;
    
public static Code MVEX_Vblendmps_zmm_k1_zmm_zmmmt;
    
public static Code MVEX_Vblendmpd_zmm_k1_zmm_zmmmt;
    
public static Code MVEX_Undoc_zmm_k1_zmm_zmmmt_512_66_0F38_W0_67;
    
public static Code MVEX_Undoc_zmm_k1_zmmmt_512_66_0F38_W0_68;
    
public static Code MVEX_Undoc_zmm_k1_zmmmt_512_66_0F38_W0_69;
    
public static Code MVEX_Undoc_zmm_k1_zmmmt_512_66_0F38_W0_6A;
    
public static Code MVEX_Undoc_zmm_k1_zmmmt_512_66_0F38_W0_6B;
    
public static Code MVEX_Vpsubrd_zmm_k1_zmm_zmmmt;
    
public static Code MVEX_Vsubrps_zmm_k1_zmm_zmmmt;
    
public static Code MVEX_Vsubrpd_zmm_k1_zmm_zmmmt;
    
public static Code MVEX_Vpsbbrd_zmm_k1_kr_zmmmt;
    
public static Code MVEX_Vpsubrsetbd_zmm_k1_kr_zmmmt;
    
public static Code MVEX_Undoc_zmm_k1_zmm_zmmmt_512_66_0F38_W0_70;
    
public static Code MVEX_Undoc_zmm_k1_zmm_zmmmt_512_66_0F38_W0_71;
    
public static Code MVEX_Undoc_zmm_k1_zmm_zmmmt_512_66_0F38_W0_72;
    
public static Code MVEX_Undoc_zmm_k1_zmm_zmmmt_512_66_0F38_W0_73;
    
public static Code MVEX_Vpcmpltd_kr_k1_zmm_zmmmt;
    
public static Code MVEX_Vscaleps_zmm_k1_zmm_zmmmt;
    
public static Code MVEX_Vpmulhud_zmm_k1_zmm_zmmmt;
    
public static Code MVEX_Vpmulhd_zmm_k1_zmm_zmmmt;
    
public static Code MVEX_Vpgatherdd_zmm_k1_mvt;
    
public static Code MVEX_Vpgatherdq_zmm_k1_mvt;
    
public static Code MVEX_Vgatherdps_zmm_k1_mvt;
    
public static Code MVEX_Vgatherdpd_zmm_k1_mvt;
    
public static Code MVEX_Undoc_zmm_k1_zmm_zmmmt_512_66_0F38_W0_94;
    
public static Code MVEX_Undoc_zmm_k1_zmm_zmmmt_512_66_0F38_W1_94;
    
public static Code MVEX_Vfmadd132ps_zmm_k1_zmm_zmmmt;
    
public static Code MVEX_Vfmadd132pd_zmm_k1_zmm_zmmmt;
    
public static Code MVEX_Vfmsub132ps_zmm_k1_zmm_zmmmt;
    
public static Code MVEX_Vfmsub132pd_zmm_k1_zmm_zmmmt;
    
public static Code MVEX_Vfnmadd132ps_zmm_k1_zmm_zmmmt;
    
public static Code MVEX_Vfnmadd132pd_zmm_k1_zmm_zmmmt;
    
public static Code MVEX_Vfnmsub132ps_zmm_k1_zmm_zmmmt;
    
public static Code MVEX_Vfnmsub132pd_zmm_k1_zmm_zmmmt;
    
public static Code MVEX_Vpscatterdd_mvt_k1_zmm;
    
public static Code MVEX_Vpscatterdq_mvt_k1_zmm;
    
public static Code MVEX_Vscatterdps_mvt_k1_zmm;
    
public static Code MVEX_Vscatterdpd_mvt_k1_zmm;
    
public static Code MVEX_Vfmadd233ps_zmm_k1_zmm_zmmmt;
    
public static Code MVEX_Vfmadd213ps_zmm_k1_zmm_zmmmt;
    
public static Code MVEX_Vfmadd213pd_zmm_k1_zmm_zmmmt;
    
public static Code MVEX_Vfmsub213ps_zmm_k1_zmm_zmmmt;
    
public static Code MVEX_Vfmsub213pd_zmm_k1_zmm_zmmmt;
    
public static Code MVEX_Vfnmadd213ps_zmm_k1_zmm_zmmmt;
    
public static Code MVEX_Vfnmadd213pd_zmm_k1_zmm_zmmmt;
    
public static Code MVEX_Vfnmsub213ps_zmm_k1_zmm_zmmmt;
    
public static Code MVEX_Vfnmsub213pd_zmm_k1_zmm_zmmmt;
    
public static Code MVEX_Undoc_zmm_k1_mvt_512_66_0F38_W0_B0;
    
public static Code MVEX_Undoc_zmm_k1_mvt_512_66_0F38_W0_B2;
    
public static Code MVEX_Vpmadd233d_zmm_k1_zmm_zmmmt;
    
public static Code MVEX_Vpmadd231d_zmm_k1_zmm_zmmmt;
    
public static Code MVEX_Vfmadd231ps_zmm_k1_zmm_zmmmt;
    
public static Code MVEX_Vfmadd231pd_zmm_k1_zmm_zmmmt;
    
public static Code MVEX_Vfmsub231ps_zmm_k1_zmm_zmmmt;
    
public static Code MVEX_Vfmsub231pd_zmm_k1_zmm_zmmmt;
    
public static Code MVEX_Vfnmadd231ps_zmm_k1_zmm_zmmmt;
    
public static Code MVEX_Vfnmadd231pd_zmm_k1_zmm_zmmmt;
    
public static Code MVEX_Vfnmsub231ps_zmm_k1_zmm_zmmmt;
    
public static Code MVEX_Vfnmsub231pd_zmm_k1_zmm_zmmmt;
    
public static Code MVEX_Undoc_zmm_k1_mvt_512_66_0F38_W0_C0;
    
public static Code MVEX_Vgatherpf0hintdps_mvt_k1;
    
public static Code MVEX_Vgatherpf0hintdpd_mvt_k1;
    
public static Code MVEX_Vgatherpf0dps_mvt_k1;
    
public static Code MVEX_Vgatherpf1dps_mvt_k1;
    
public static Code MVEX_Vscatterpf0hintdps_mvt_k1;
    
public static Code MVEX_Vscatterpf0hintdpd_mvt_k1;
    
public static Code MVEX_Vscatterpf0dps_mvt_k1;
    
public static Code MVEX_Vscatterpf1dps_mvt_k1;
    
public static Code MVEX_Vexp223ps_zmm_k1_zmmmt;
    
public static Code MVEX_Vlog2ps_zmm_k1_zmmmt;
    
public static Code MVEX_Vrcp23ps_zmm_k1_zmmmt;
    
public static Code MVEX_Vrsqrt23ps_zmm_k1_zmmmt;
    
public static Code MVEX_Vaddsetsps_zmm_k1_zmm_zmmmt;
    
public static Code MVEX_Vpaddsetsd_zmm_k1_zmm_zmmmt;
    
public static Code MVEX_Undoc_zmm_k1_zmm_zmmmt_512_66_0F38_W0_CE;
    
public static Code MVEX_Undoc_zmm_k1_zmm_zmmmt_512_66_0F38_W1_CE;
    
public static Code MVEX_Undoc_zmm_k1_zmm_zmmmt_512_66_0F38_W0_CF;
    
public static Code MVEX_Vloadunpackld_zmm_k1_mt;
    
public static Code MVEX_Vloadunpacklq_zmm_k1_mt;
    
public static Code MVEX_Vpackstoreld_mt_k1_zmm;
    
public static Code MVEX_Vpackstorelq_mt_k1_zmm;
    
public static Code MVEX_Vloadunpacklps_zmm_k1_mt;
    
public static Code MVEX_Vloadunpacklpd_zmm_k1_mt;
    
public static Code MVEX_Vpackstorelps_mt_k1_zmm;
    
public static Code MVEX_Vpackstorelpd_mt_k1_zmm;
    
public static Code MVEX_Undoc_zmm_k1_zmmmt_512_0F38_W0_D2;
    
public static Code MVEX_Undoc_zmm_k1_zmmmt_512_66_0F38_W0_D2;
    
public static Code MVEX_Undoc_zmm_k1_zmmmt_512_0F38_W0_D3;
    
public static Code MVEX_Vloadunpackhd_zmm_k1_mt;
    
public static Code MVEX_Vloadunpackhq_zmm_k1_mt;
    
public static Code MVEX_Vpackstorehd_mt_k1_zmm;
    
public static Code MVEX_Vpackstorehq_mt_k1_zmm;
    
public static Code MVEX_Vloadunpackhps_zmm_k1_mt;
    
public static Code MVEX_Vloadunpackhpd_zmm_k1_mt;
    
public static Code MVEX_Vpackstorehps_mt_k1_zmm;
    
public static Code MVEX_Vpackstorehpd_mt_k1_zmm;
    
public static Code MVEX_Undoc_zmm_k1_zmmmt_512_0F38_W0_D6;
    
public static Code MVEX_Undoc_zmm_k1_zmmmt_512_66_0F38_W0_D6;
    
public static Code MVEX_Undoc_zmm_k1_zmmmt_512_0F38_W0_D7;
    
public static Code MVEX_Valignd_zmm_k1_zmm_zmmmt_imm8;
    
public static Code MVEX_Vpermf32x4_zmm_k1_zmmmt_imm8;
    
public static Code MVEX_Vpcmpud_kr_k1_zmm_zmmmt_imm8;
    
public static Code MVEX_Vpcmpd_kr_k1_zmm_zmmmt_imm8;
    
public static Code MVEX_Vgetmantps_zmm_k1_zmmmt_imm8;
    
public static Code MVEX_Vgetmantpd_zmm_k1_zmmmt_imm8;
    
public static Code MVEX_Vrndfxpntps_zmm_k1_zmmmt_imm8;
    
public static Code MVEX_Vrndfxpntpd_zmm_k1_zmmmt_imm8;
    
public static Code MVEX_Vcvtfxpntudq2ps_zmm_k1_zmmmt_imm8;
    
public static Code MVEX_Vcvtfxpntps2udq_zmm_k1_zmmmt_imm8;
    
public static Code MVEX_Vcvtfxpntpd2udq_zmm_k1_zmmmt_imm8;
    
public static Code MVEX_Vcvtfxpntdq2ps_zmm_k1_zmmmt_imm8;
    
public static Code MVEX_Vcvtfxpntps2dq_zmm_k1_zmmmt_imm8;
    
public static Code MVEX_Undoc_zmm_k1_zmmmt_imm8_512_66_0F3A_W0_D0;
    
public static Code MVEX_Undoc_zmm_k1_zmmmt_imm8_512_66_0F3A_W0_D1;
    
public static Code MVEX_Vcvtfxpntpd2dq_zmm_k1_zmmmt_imm8;
    
public static Code Via_undoc_F30FA6F0_16;
    
public static Code Via_undoc_F30FA6F0_32;
    
public static Code Via_undoc_F30FA6F0_64;
    
public static Code Via_undoc_F30FA6F8_16;
    
public static Code Via_undoc_F30FA6F8_32;
    
public static Code Via_undoc_F30FA6F8_64;
    
public static Code Xsha512_16;
    
public static Code Xsha512_32;
    
public static Code Xsha512_64;
    
public static Code Xstore_alt_16;
    
public static Code Xstore_alt_32;
    
public static Code Xstore_alt_64;
    
public static Code Xsha512_alt_16;
    
public static Code Xsha512_alt_32;
    
public static Code Xsha512_alt_64;
    
public static Code Zero_bytes;
}
[ExtensionAttribute]
internal static class Iced.Intel.CodeExtensions : object {
    [ExtensionAttribute]
internal static bool IgnoresSegment(Code code);
    [ExtensionAttribute]
internal static bool IgnoresIndex(Code code);
    [ExtensionAttribute]
internal static bool IsTileStrideIndex(Code code);
}
internal abstract class Iced.Intel.CodeReader : object {
    public abstract virtual int ReadByte();
}
internal enum Iced.Intel.CodeSize : Enum {
    
public int value__;
    
public static CodeSize Unknown;
    
public static CodeSize Code16;
    
public static CodeSize Code32;
    
public static CodeSize Code64;
}
internal abstract class Iced.Intel.CodeWriter : object {
    public abstract virtual void WriteByte(byte value);
}
internal class Iced.Intel.ConstantOffsets : ValueType {
    
public byte DisplacementOffset;
    
public byte DisplacementSize;
    
public byte ImmediateOffset;
    
public byte ImmediateSize;
    
public byte ImmediateOffset2;
    
public byte ImmediateSize2;
    
private byte pad1;
    
private byte pad2;
    
public bool HasDisplacement { get; }
    
public bool HasImmediate { get; }
    
public bool HasImmediate2 { get; }
    [IsReadOnlyAttribute]
public bool get_HasDisplacement();
    [IsReadOnlyAttribute]
public bool get_HasImmediate();
    [IsReadOnlyAttribute]
public bool get_HasImmediate2();
}
internal class Iced.Intel.Decoder : object {
    
private ulong instructionPointer;
    
private CodeReader reader;
    
private RegInfo2[] memRegs16;
    
private OpCodeHandler[] handlers_MAP0;
    
private OpCodeHandler[] handlers_VEX_0F;
    
private OpCodeHandler[] handlers_VEX_0F38;
    
private OpCodeHandler[] handlers_VEX_0F3A;
    
private OpCodeHandler[] handlers_EVEX_0F;
    
private OpCodeHandler[] handlers_EVEX_0F38;
    
private OpCodeHandler[] handlers_EVEX_0F3A;
    
private OpCodeHandler[] handlers_EVEX_MAP5;
    
private OpCodeHandler[] handlers_EVEX_MAP6;
    
private OpCodeHandler[] handlers_XOP_MAP8;
    
private OpCodeHandler[] handlers_XOP_MAP9;
    
private OpCodeHandler[] handlers_XOP_MAP10;
    
internal State state;
    
internal UInt32 displIndex;
    
internal DecoderOptions options;
    
internal UInt32 invalidCheckMask;
    
internal UInt32 is64bMode_and_W;
    
internal UInt32 reg15Mask;
    
private UInt32 maskE0;
    
private UInt32 rexMask;
    
internal CodeSize defaultCodeSize;
    
internal OpSize defaultOperandSize;
    
private OpSize defaultAddressSize;
    
internal OpSize defaultInvertedOperandSize;
    
internal OpSize defaultInvertedAddressSize;
    
internal bool is64bMode;
    [CompilerGeneratedAttribute]

private int <Bitness>k__BackingField;
    
private static RegInfo2[] s_memRegs16;
    
public ulong IP { get; public set; }
    
public int Bitness { get; }
    
public DecoderError LastError { get; }
    private static Decoder();
    private Decoder(CodeReader reader, ulong ip, DecoderOptions options, int bitness);
    public ulong get_IP();
    public void set_IP(ulong value);
    [CompilerGeneratedAttribute]
public int get_Bitness();
    [NullableContextAttribute("1")]
public static Decoder Create(int bitness, CodeReader reader, ulong ip, DecoderOptions options);
    [NullableContextAttribute("1")]
public static Decoder Create(int bitness, Byte[] data, ulong ip, DecoderOptions options);
    [NullableContextAttribute("1")]
public static Decoder Create(int bitness, CodeReader reader, DecoderOptions options);
    [NullableContextAttribute("1")]
public static Decoder Create(int bitness, Byte[] data, DecoderOptions options);
    internal UInt32 ReadByte();
    internal UInt32 ReadUInt16();
    internal UInt32 ReadUInt32();
    internal ulong ReadUInt64();
    public DecoderError get_LastError();
    public Instruction Decode();
    public void Decode(Instruction& instruction);
    internal void ResetRexPrefixState();
    internal void CallOpCodeHandlerXXTable(Instruction& instruction);
    internal UInt32 GetCurrentInstructionPointer32();
    internal ulong GetCurrentInstructionPointer64();
    internal void ClearMandatoryPrefix(Instruction& instruction);
    internal void SetXacquireXrelease(Instruction& instruction);
    internal void ClearMandatoryPrefixF3(Instruction& instruction);
    internal void ClearMandatoryPrefixF2(Instruction& instruction);
    internal void SetInvalidInstruction();
    [NullableContextAttribute("1")]
internal void DecodeTable(OpCodeHandler[] table, Instruction& instruction);
    private void DecodeTable(OpCodeHandler handler, Instruction& instruction);
    internal void ReadModRM();
    internal void VEX2(Instruction& instruction);
    internal void VEX3(Instruction& instruction);
    internal void XOP(Instruction& instruction);
    internal void EVEX_MVEX(Instruction& instruction);
    internal Register ReadOpSegReg();
    internal bool ReadOpMem(Instruction& instruction);
    internal void ReadOpMemSib(Instruction& instruction);
    internal void ReadOpMem_MPX(Instruction& instruction);
    internal void ReadOpMem(Instruction& instruction, TupleType tupleType);
    internal void ReadOpMem_VSIB(Instruction& instruction, Register vsibIndex, TupleType tupleType);
    private void ReadOpMem16(Instruction& instruction, TupleType tupleType);
    private bool ReadOpMem32Or64(Instruction& instruction, Register baseReg, Register indexReg, TupleType tupleType, bool isVsib);
    private UInt32 GetDisp8N(TupleType tupleType);
    public ConstantOffsets GetConstantOffsets(Instruction& instruction);
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<Instruction> System.Collections.Generic.IEnumerable<Iced.Intel.Instruction>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal enum Iced.Intel.DecoderError : Enum {
    
public int value__;
    
public static DecoderError None;
    
public static DecoderError InvalidInstruction;
    
public static DecoderError NoMoreBytes;
}
internal class Iced.Intel.DecoderInternal.Code3 : ValueType {
    [FixedBufferAttribute("System.UInt16", "3")]

public <codes>e__FixedBuffer codes;
    public Code3(Code code16, Code code32, Code code64);
}
internal enum Iced.Intel.DecoderInternal.EvexOpCodeHandlerKind : Enum {
    
public byte value__;
    
public static EvexOpCodeHandlerKind Invalid;
    
public static EvexOpCodeHandlerKind Invalid2;
    
public static EvexOpCodeHandlerKind Dup;
    
public static EvexOpCodeHandlerKind HandlerReference;
    
public static EvexOpCodeHandlerKind ArrayReference;
    
public static EvexOpCodeHandlerKind RM;
    
public static EvexOpCodeHandlerKind Group;
    
public static EvexOpCodeHandlerKind W;
    
public static EvexOpCodeHandlerKind MandatoryPrefix2;
    
public static EvexOpCodeHandlerKind VectorLength;
    
public static EvexOpCodeHandlerKind VectorLength_er;
    
public static EvexOpCodeHandlerKind Ed_V_Ib;
    
public static EvexOpCodeHandlerKind Ev_VX;
    
public static EvexOpCodeHandlerKind Ev_VX_Ib;
    
public static EvexOpCodeHandlerKind Gv_W_er;
    
public static EvexOpCodeHandlerKind GvM_VX_Ib;
    
public static EvexOpCodeHandlerKind HkWIb_3;
    
public static EvexOpCodeHandlerKind HkWIb_3b;
    
public static EvexOpCodeHandlerKind HWIb;
    
public static EvexOpCodeHandlerKind KkHW_3;
    
public static EvexOpCodeHandlerKind KkHW_3b;
    
public static EvexOpCodeHandlerKind KkHWIb_sae_3;
    
public static EvexOpCodeHandlerKind KkHWIb_sae_3b;
    
public static EvexOpCodeHandlerKind KkHWIb_3;
    
public static EvexOpCodeHandlerKind KkHWIb_3b;
    
public static EvexOpCodeHandlerKind KkWIb_3;
    
public static EvexOpCodeHandlerKind KkWIb_3b;
    
public static EvexOpCodeHandlerKind KP1HW;
    
public static EvexOpCodeHandlerKind KR;
    
public static EvexOpCodeHandlerKind MV;
    
public static EvexOpCodeHandlerKind V_H_Ev_er;
    
public static EvexOpCodeHandlerKind V_H_Ev_Ib;
    
public static EvexOpCodeHandlerKind VHM;
    
public static EvexOpCodeHandlerKind VHW_3;
    
public static EvexOpCodeHandlerKind VHW_4;
    
public static EvexOpCodeHandlerKind VHWIb;
    
public static EvexOpCodeHandlerKind VK;
    
public static EvexOpCodeHandlerKind Vk_VSIB;
    
public static EvexOpCodeHandlerKind VkEv_REXW_2;
    
public static EvexOpCodeHandlerKind VkEv_REXW_3;
    
public static EvexOpCodeHandlerKind VkHM;
    
public static EvexOpCodeHandlerKind VkHW_3;
    
public static EvexOpCodeHandlerKind VkHW_3b;
    
public static EvexOpCodeHandlerKind VkHW_5;
    
public static EvexOpCodeHandlerKind VkHW_er_4;
    
public static EvexOpCodeHandlerKind VkHW_er_4b;
    
public static EvexOpCodeHandlerKind VkHWIb_3;
    
public static EvexOpCodeHandlerKind VkHWIb_3b;
    
public static EvexOpCodeHandlerKind VkHWIb_5;
    
public static EvexOpCodeHandlerKind VkHWIb_er_4;
    
public static EvexOpCodeHandlerKind VkHWIb_er_4b;
    
public static EvexOpCodeHandlerKind VkM;
    
public static EvexOpCodeHandlerKind VkW_3;
    
public static EvexOpCodeHandlerKind VkW_3b;
    
public static EvexOpCodeHandlerKind VkW_4;
    
public static EvexOpCodeHandlerKind VkW_4b;
    
public static EvexOpCodeHandlerKind VkW_er_4;
    
public static EvexOpCodeHandlerKind VkW_er_5;
    
public static EvexOpCodeHandlerKind VkW_er_6;
    
public static EvexOpCodeHandlerKind VkWIb_3;
    
public static EvexOpCodeHandlerKind VkWIb_3b;
    
public static EvexOpCodeHandlerKind VkWIb_er;
    
public static EvexOpCodeHandlerKind VM;
    
public static EvexOpCodeHandlerKind VSIB_k1;
    
public static EvexOpCodeHandlerKind VSIB_k1_VX;
    
public static EvexOpCodeHandlerKind VW;
    
public static EvexOpCodeHandlerKind VW_er;
    
public static EvexOpCodeHandlerKind VX_Ev;
    
public static EvexOpCodeHandlerKind WkHV;
    
public static EvexOpCodeHandlerKind WkV_3;
    
public static EvexOpCodeHandlerKind WkV_4a;
    
public static EvexOpCodeHandlerKind WkV_4b;
    
public static EvexOpCodeHandlerKind WkVIb;
    
public static EvexOpCodeHandlerKind WkVIb_er;
    
public static EvexOpCodeHandlerKind WV;
    
public static EvexOpCodeHandlerKind VkHW_er_ur_3;
    
public static EvexOpCodeHandlerKind VkHW_er_ur_3b;
}
internal class Iced.Intel.DecoderInternal.EvexOpCodeHandlerReader : OpCodeHandlerReader {
    public virtual int ReadHandlers(TableDeserializer& deserializer, OpCodeHandler[] result, int resultIndex);
}
[FlagsAttribute]
internal enum Iced.Intel.DecoderInternal.HandlerFlags : Enum {
    
public UInt32 value__;
    
public static HandlerFlags None;
    
public static HandlerFlags Xacquire;
    
public static HandlerFlags Xrelease;
    
public static HandlerFlags XacquireXreleaseNoLock;
    
public static HandlerFlags Lock;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Iced.Intel.DecoderInternal.HandlerInfo : ValueType {
    
public OpCodeHandler handler;
    
public OpCodeHandler[] handlers;
    [NullableContextAttribute("1")]
public HandlerInfo(OpCodeHandler handler);
    public HandlerInfo(OpCodeHandler[] handlers);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Iced.Intel.DecoderInternal.HandlerOptions : ValueType {
    
public OpCodeHandler handler;
    
public DecoderOptions options;
    public HandlerOptions(OpCodeHandler handler, DecoderOptions options);
}
[FlagsAttribute]
internal enum Iced.Intel.DecoderInternal.LegacyHandlerFlags : Enum {
    
public UInt32 value__;
    
public static LegacyHandlerFlags HandlerReg;
    
public static LegacyHandlerFlags HandlerMem;
    
public static LegacyHandlerFlags Handler66Reg;
    
public static LegacyHandlerFlags Handler66Mem;
    
public static LegacyHandlerFlags HandlerF3Reg;
    
public static LegacyHandlerFlags HandlerF3Mem;
    
public static LegacyHandlerFlags HandlerF2Reg;
    
public static LegacyHandlerFlags HandlerF2Mem;
}
internal enum Iced.Intel.DecoderInternal.LegacyOpCodeHandlerKind : Enum {
    
public byte value__;
    
public static LegacyOpCodeHandlerKind Bitness;
    
public static LegacyOpCodeHandlerKind Bitness_DontReadModRM;
    
public static LegacyOpCodeHandlerKind Invalid;
    
public static LegacyOpCodeHandlerKind Invalid_NoModRM;
    
public static LegacyOpCodeHandlerKind Invalid2;
    
public static LegacyOpCodeHandlerKind Dup;
    
public static LegacyOpCodeHandlerKind Null;
    
public static LegacyOpCodeHandlerKind HandlerReference;
    
public static LegacyOpCodeHandlerKind ArrayReference;
    
public static LegacyOpCodeHandlerKind RM;
    
public static LegacyOpCodeHandlerKind Options3;
    
public static LegacyOpCodeHandlerKind Options5;
    
public static LegacyOpCodeHandlerKind Options_DontReadModRM;
    
public static LegacyOpCodeHandlerKind AnotherTable;
    
public static LegacyOpCodeHandlerKind Group;
    
public static LegacyOpCodeHandlerKind Group8x64;
    
public static LegacyOpCodeHandlerKind Group8x8;
    
public static LegacyOpCodeHandlerKind MandatoryPrefix;
    
public static LegacyOpCodeHandlerKind MandatoryPrefix4;
    
public static LegacyOpCodeHandlerKind Ev_REXW_1a;
    
public static LegacyOpCodeHandlerKind MandatoryPrefix_NoModRM;
    
public static LegacyOpCodeHandlerKind MandatoryPrefix3;
    
public static LegacyOpCodeHandlerKind D3NOW;
    
public static LegacyOpCodeHandlerKind EVEX;
    
public static LegacyOpCodeHandlerKind VEX2;
    
public static LegacyOpCodeHandlerKind VEX3;
    
public static LegacyOpCodeHandlerKind XOP;
    
public static LegacyOpCodeHandlerKind AL_DX;
    
public static LegacyOpCodeHandlerKind Ap;
    
public static LegacyOpCodeHandlerKind B_BM;
    
public static LegacyOpCodeHandlerKind B_Ev;
    
public static LegacyOpCodeHandlerKind B_MIB;
    
public static LegacyOpCodeHandlerKind BM_B;
    
public static LegacyOpCodeHandlerKind BranchIw;
    
public static LegacyOpCodeHandlerKind BranchSimple;
    
public static LegacyOpCodeHandlerKind C_R_3a;
    
public static LegacyOpCodeHandlerKind C_R_3b;
    
public static LegacyOpCodeHandlerKind DX_AL;
    
public static LegacyOpCodeHandlerKind DX_eAX;
    
public static LegacyOpCodeHandlerKind eAX_DX;
    
public static LegacyOpCodeHandlerKind Eb_1;
    
public static LegacyOpCodeHandlerKind Eb_2;
    
public static LegacyOpCodeHandlerKind Eb_CL;
    
public static LegacyOpCodeHandlerKind Eb_Gb_1;
    
public static LegacyOpCodeHandlerKind Eb_Gb_2;
    
public static LegacyOpCodeHandlerKind Eb_Ib_1;
    
public static LegacyOpCodeHandlerKind Eb_Ib_2;
    
public static LegacyOpCodeHandlerKind Eb1;
    
public static LegacyOpCodeHandlerKind Ed_V_Ib;
    
public static LegacyOpCodeHandlerKind Ep;
    
public static LegacyOpCodeHandlerKind Ev_3a;
    
public static LegacyOpCodeHandlerKind Ev_3b;
    
public static LegacyOpCodeHandlerKind Ev_4;
    
public static LegacyOpCodeHandlerKind Ev_CL;
    
public static LegacyOpCodeHandlerKind Ev_Gv_32_64;
    
public static LegacyOpCodeHandlerKind Ev_Gv_3a;
    
public static LegacyOpCodeHandlerKind Ev_Gv_3b;
    
public static LegacyOpCodeHandlerKind Ev_Gv_4;
    
public static LegacyOpCodeHandlerKind Ev_Gv_CL;
    
public static LegacyOpCodeHandlerKind Ev_Gv_Ib;
    
public static LegacyOpCodeHandlerKind Ev_Gv_REX;
    
public static LegacyOpCodeHandlerKind Ev_Ib_3;
    
public static LegacyOpCodeHandlerKind Ev_Ib_4;
    
public static LegacyOpCodeHandlerKind Ev_Ib2_3;
    
public static LegacyOpCodeHandlerKind Ev_Ib2_4;
    
public static LegacyOpCodeHandlerKind Ev_Iz_3;
    
public static LegacyOpCodeHandlerKind Ev_Iz_4;
    
public static LegacyOpCodeHandlerKind Ev_P;
    
public static LegacyOpCodeHandlerKind Ev_REXW;
    
public static LegacyOpCodeHandlerKind Ev_Sw;
    
public static LegacyOpCodeHandlerKind Ev_VX;
    
public static LegacyOpCodeHandlerKind Ev1;
    
public static LegacyOpCodeHandlerKind Evj;
    
public static LegacyOpCodeHandlerKind Evw;
    
public static LegacyOpCodeHandlerKind Ew;
    
public static LegacyOpCodeHandlerKind Gb_Eb;
    
public static LegacyOpCodeHandlerKind Gdq_Ev;
    
public static LegacyOpCodeHandlerKind Gv_Eb;
    
public static LegacyOpCodeHandlerKind Gv_Eb_REX;
    
public static LegacyOpCodeHandlerKind Gv_Ev_32_64;
    
public static LegacyOpCodeHandlerKind Gv_Ev_3a;
    
public static LegacyOpCodeHandlerKind Gv_Ev_3b;
    
public static LegacyOpCodeHandlerKind Gv_Ev_Ib;
    
public static LegacyOpCodeHandlerKind Gv_Ev_Ib_REX;
    
public static LegacyOpCodeHandlerKind Gv_Ev_Iz;
    
public static LegacyOpCodeHandlerKind Gv_Ev_REX;
    
public static LegacyOpCodeHandlerKind Gv_Ev2;
    
public static LegacyOpCodeHandlerKind Gv_Ev3;
    
public static LegacyOpCodeHandlerKind Gv_Ew;
    
public static LegacyOpCodeHandlerKind Gv_M;
    
public static LegacyOpCodeHandlerKind Gv_M_as;
    
public static LegacyOpCodeHandlerKind Gv_Ma;
    
public static LegacyOpCodeHandlerKind Gv_Mp_2;
    
public static LegacyOpCodeHandlerKind Gv_Mp_3;
    
public static LegacyOpCodeHandlerKind Gv_Mv;
    
public static LegacyOpCodeHandlerKind Gv_N;
    
public static LegacyOpCodeHandlerKind Gv_N_Ib_REX;
    
public static LegacyOpCodeHandlerKind Gv_RX;
    
public static LegacyOpCodeHandlerKind Gv_W;
    
public static LegacyOpCodeHandlerKind GvM_VX_Ib;
    
public static LegacyOpCodeHandlerKind Ib;
    
public static LegacyOpCodeHandlerKind Ib3;
    
public static LegacyOpCodeHandlerKind IbReg;
    
public static LegacyOpCodeHandlerKind IbReg2;
    
public static LegacyOpCodeHandlerKind Iw_Ib;
    
public static LegacyOpCodeHandlerKind Jb;
    
public static LegacyOpCodeHandlerKind Jb2;
    
public static LegacyOpCodeHandlerKind Jdisp;
    
public static LegacyOpCodeHandlerKind Jx;
    
public static LegacyOpCodeHandlerKind Jz;
    
public static LegacyOpCodeHandlerKind M_1;
    
public static LegacyOpCodeHandlerKind M_2;
    
public static LegacyOpCodeHandlerKind M_REXW_2;
    
public static LegacyOpCodeHandlerKind M_REXW_4;
    
public static LegacyOpCodeHandlerKind MemBx;
    
public static LegacyOpCodeHandlerKind Mf_1;
    
public static LegacyOpCodeHandlerKind Mf_2a;
    
public static LegacyOpCodeHandlerKind Mf_2b;
    
public static LegacyOpCodeHandlerKind MIB_B;
    
public static LegacyOpCodeHandlerKind MP;
    
public static LegacyOpCodeHandlerKind Ms;
    
public static LegacyOpCodeHandlerKind MV;
    
public static LegacyOpCodeHandlerKind Mv_Gv;
    
public static LegacyOpCodeHandlerKind Mv_Gv_REXW;
    
public static LegacyOpCodeHandlerKind NIb;
    
public static LegacyOpCodeHandlerKind Ob_Reg;
    
public static LegacyOpCodeHandlerKind Ov_Reg;
    
public static LegacyOpCodeHandlerKind P_Ev;
    
public static LegacyOpCodeHandlerKind P_Ev_Ib;
    
public static LegacyOpCodeHandlerKind P_Q;
    
public static LegacyOpCodeHandlerKind P_Q_Ib;
    
public static LegacyOpCodeHandlerKind P_R;
    
public static LegacyOpCodeHandlerKind P_W;
    
public static LegacyOpCodeHandlerKind PushEv;
    
public static LegacyOpCodeHandlerKind PushIb2;
    
public static LegacyOpCodeHandlerKind PushIz;
    
public static LegacyOpCodeHandlerKind PushOpSizeReg_4a;
    
public static LegacyOpCodeHandlerKind PushOpSizeReg_4b;
    
public static LegacyOpCodeHandlerKind PushSimple2;
    
public static LegacyOpCodeHandlerKind PushSimpleReg;
    
public static LegacyOpCodeHandlerKind Q_P;
    
public static LegacyOpCodeHandlerKind R_C_3a;
    
public static LegacyOpCodeHandlerKind R_C_3b;
    
public static LegacyOpCodeHandlerKind rDI_P_N;
    
public static LegacyOpCodeHandlerKind rDI_VX_RX;
    
public static LegacyOpCodeHandlerKind Reg;
    
public static LegacyOpCodeHandlerKind Reg_Ib2;
    
public static LegacyOpCodeHandlerKind Reg_Iz;
    
public static LegacyOpCodeHandlerKind Reg_Ob;
    
public static LegacyOpCodeHandlerKind Reg_Ov;
    
public static LegacyOpCodeHandlerKind Reg_Xb;
    
public static LegacyOpCodeHandlerKind Reg_Xv;
    
public static LegacyOpCodeHandlerKind Reg_Xv2;
    
public static LegacyOpCodeHandlerKind Reg_Yb;
    
public static LegacyOpCodeHandlerKind Reg_Yv;
    
public static LegacyOpCodeHandlerKind RegIb;
    
public static LegacyOpCodeHandlerKind RegIb3;
    
public static LegacyOpCodeHandlerKind RegIz2;
    
public static LegacyOpCodeHandlerKind Reservednop;
    
public static LegacyOpCodeHandlerKind RIb;
    
public static LegacyOpCodeHandlerKind RIbIb;
    
public static LegacyOpCodeHandlerKind Rv;
    
public static LegacyOpCodeHandlerKind Rv_32_64;
    
public static LegacyOpCodeHandlerKind RvMw_Gw;
    
public static LegacyOpCodeHandlerKind Simple;
    
public static LegacyOpCodeHandlerKind Simple_ModRM;
    
public static LegacyOpCodeHandlerKind Simple2_3a;
    
public static LegacyOpCodeHandlerKind Simple2_3b;
    
public static LegacyOpCodeHandlerKind Simple2Iw;
    
public static LegacyOpCodeHandlerKind Simple3;
    
public static LegacyOpCodeHandlerKind Simple4;
    
public static LegacyOpCodeHandlerKind Simple5;
    
public static LegacyOpCodeHandlerKind Simple5_ModRM_as;
    
public static LegacyOpCodeHandlerKind SimpleReg;
    
public static LegacyOpCodeHandlerKind ST_STi;
    
public static LegacyOpCodeHandlerKind STi;
    
public static LegacyOpCodeHandlerKind STi_ST;
    
public static LegacyOpCodeHandlerKind Sw_Ev;
    
public static LegacyOpCodeHandlerKind V_Ev;
    
public static LegacyOpCodeHandlerKind VM;
    
public static LegacyOpCodeHandlerKind VN;
    
public static LegacyOpCodeHandlerKind VQ;
    
public static LegacyOpCodeHandlerKind VRIbIb;
    
public static LegacyOpCodeHandlerKind VW_2;
    
public static LegacyOpCodeHandlerKind VW_3;
    
public static LegacyOpCodeHandlerKind VWIb_2;
    
public static LegacyOpCodeHandlerKind VWIb_3;
    
public static LegacyOpCodeHandlerKind VX_E_Ib;
    
public static LegacyOpCodeHandlerKind VX_Ev;
    
public static LegacyOpCodeHandlerKind Wbinvd;
    
public static LegacyOpCodeHandlerKind WV;
    
public static LegacyOpCodeHandlerKind Xb_Yb;
    
public static LegacyOpCodeHandlerKind Xchg_Reg_rAX;
    
public static LegacyOpCodeHandlerKind Xv_Yv;
    
public static LegacyOpCodeHandlerKind Yb_Reg;
    
public static LegacyOpCodeHandlerKind Yb_Xb;
    
public static LegacyOpCodeHandlerKind Yv_Reg;
    
public static LegacyOpCodeHandlerKind Yv_Reg2;
    
public static LegacyOpCodeHandlerKind Yv_Xv;
    
public static LegacyOpCodeHandlerKind Simple4b;
    
public static LegacyOpCodeHandlerKind Options1632_1;
    
public static LegacyOpCodeHandlerKind Options1632_2;
    
public static LegacyOpCodeHandlerKind M_Sw;
    
public static LegacyOpCodeHandlerKind Sw_M;
    
public static LegacyOpCodeHandlerKind Rq;
    
public static LegacyOpCodeHandlerKind Gd_Rd;
    
public static LegacyOpCodeHandlerKind PrefixEsCsSsDs;
    
public static LegacyOpCodeHandlerKind PrefixFsGs;
    
public static LegacyOpCodeHandlerKind Prefix66;
    
public static LegacyOpCodeHandlerKind Prefix67;
    
public static LegacyOpCodeHandlerKind PrefixF0;
    
public static LegacyOpCodeHandlerKind PrefixF2;
    
public static LegacyOpCodeHandlerKind PrefixF3;
    
public static LegacyOpCodeHandlerKind PrefixREX;
    
public static LegacyOpCodeHandlerKind Simple5_a32;
}
internal class Iced.Intel.DecoderInternal.LegacyOpCodeHandlerReader : OpCodeHandlerReader {
    public virtual int ReadHandlers(TableDeserializer& deserializer, OpCodeHandler[] result, int resultIndex);
}
internal abstract class Iced.Intel.DecoderInternal.OpCodeHandler : object {
    
public bool HasModRM;
    protected OpCodeHandler(bool hasModRM);
    [NullableContextAttribute("1")]
public abstract virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_AL_DX : OpCodeHandler {
    
private Code code;
    public OpCodeHandler_AL_DX(Code code);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Iced.Intel.DecoderInternal.OpCodeHandler_AnotherTable : OpCodeHandler {
    
private OpCodeHandler[] otherTable;
    public OpCodeHandler_AnotherTable(OpCodeHandler[] otherTable);
    public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_Ap : OpCodeHandler {
    
private Code code16;
    
private Code code32;
    public OpCodeHandler_Ap(Code code16, Code code32);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_B_BM : OpCodeHandlerModRM {
    
private Code code32;
    
private Code code64;
    public OpCodeHandler_B_BM(Code code32, Code code64);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_B_Ev : OpCodeHandlerModRM {
    
private Code code32;
    
private Code code64;
    
private UInt32 ripRelMask;
    public OpCodeHandler_B_Ev(Code code32, Code code64, bool supportsRipRel);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_B_MIB : OpCodeHandlerModRM {
    
private Code code;
    public OpCodeHandler_B_MIB(Code code);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Iced.Intel.DecoderInternal.OpCodeHandler_Bitness : OpCodeHandler {
    
private OpCodeHandler handler1632;
    
private OpCodeHandler handler64;
    public OpCodeHandler_Bitness(OpCodeHandler handler1632, OpCodeHandler handler64);
    public virtual void Decode(Decoder decoder, Instruction& instruction);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Iced.Intel.DecoderInternal.OpCodeHandler_Bitness_DontReadModRM : OpCodeHandlerModRM {
    
private OpCodeHandler handler1632;
    
private OpCodeHandler handler64;
    public OpCodeHandler_Bitness_DontReadModRM(OpCodeHandler handler1632, OpCodeHandler handler64);
    public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_BM_B : OpCodeHandlerModRM {
    
private Code code32;
    
private Code code64;
    public OpCodeHandler_BM_B(Code code32, Code code64);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_BranchIw : OpCodeHandler {
    
private Code code16;
    
private Code code32;
    
private Code code64;
    public OpCodeHandler_BranchIw(Code code16, Code code32, Code code64);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_BranchSimple : OpCodeHandler {
    
private Code code16;
    
private Code code32;
    
private Code code64;
    public OpCodeHandler_BranchSimple(Code code16, Code code32, Code code64);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_C_R : OpCodeHandlerModRM {
    
private Code code32;
    
private Code code64;
    
private Register baseReg;
    public OpCodeHandler_C_R(Code code32, Code code64, Register baseReg);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Iced.Intel.DecoderInternal.OpCodeHandler_D3NOW : OpCodeHandlerModRM {
    
internal static Code[] CodeValues;
    
private Code[] codeValues;
    private static OpCodeHandler_D3NOW();
    private static Code[] CreateCodeValues();
    public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_DX_AL : OpCodeHandler {
    
private Code code;
    public OpCodeHandler_DX_AL(Code code);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_DX_eAX : OpCodeHandler {
    
private Code code16;
    
private Code code32;
    public OpCodeHandler_DX_eAX(Code code16, Code code32);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_eAX_DX : OpCodeHandler {
    
private Code code16;
    
private Code code32;
    public OpCodeHandler_eAX_DX(Code code16, Code code32);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_Eb : OpCodeHandlerModRM {
    
private Code code;
    
private HandlerFlags flags;
    public OpCodeHandler_Eb(Code code);
    public OpCodeHandler_Eb(Code code, HandlerFlags flags);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_Eb_1 : OpCodeHandlerModRM {
    
private Code code;
    public OpCodeHandler_Eb_1(Code code);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_Eb_CL : OpCodeHandlerModRM {
    
private Code code;
    public OpCodeHandler_Eb_CL(Code code);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_Eb_Gb : OpCodeHandlerModRM {
    
private Code code;
    
private HandlerFlags flags;
    public OpCodeHandler_Eb_Gb(Code code);
    public OpCodeHandler_Eb_Gb(Code code, HandlerFlags flags);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_Eb_Ib : OpCodeHandlerModRM {
    
private Code code;
    
private HandlerFlags flags;
    public OpCodeHandler_Eb_Ib(Code code);
    public OpCodeHandler_Eb_Ib(Code code, HandlerFlags flags);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_Ed_V_Ib : OpCodeHandlerModRM {
    
private Code code32;
    
private Code code64;
    public OpCodeHandler_Ed_V_Ib(Code code32, Code code64);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_Ep : OpCodeHandlerModRM {
    
private Code code16;
    
private Code code32;
    
private Code code64;
    public OpCodeHandler_Ep(Code code16, Code code32, Code code64);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_Ev : OpCodeHandlerModRM {
    
private Code3 codes;
    
private HandlerFlags flags;
    public OpCodeHandler_Ev(Code code16, Code code32, Code code64);
    public OpCodeHandler_Ev(Code code16, Code code32, Code code64, HandlerFlags flags);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_Ev_1 : OpCodeHandlerModRM {
    
private Code3 codes;
    public OpCodeHandler_Ev_1(Code code16, Code code32, Code code64);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_Ev_CL : OpCodeHandlerModRM {
    
private Code3 codes;
    public OpCodeHandler_Ev_CL(Code code16, Code code32, Code code64);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_Ev_Gv : OpCodeHandlerModRM {
    
private Code3 codes;
    
private HandlerFlags flags;
    public OpCodeHandler_Ev_Gv(Code code16, Code code32, Code code64);
    public OpCodeHandler_Ev_Gv(Code code16, Code code32, Code code64, HandlerFlags flags);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_Ev_Gv_32_64 : OpCodeHandlerModRM {
    
private Code code32;
    
private Code code64;
    public OpCodeHandler_Ev_Gv_32_64(Code code32, Code code64);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_Ev_Gv_CL : OpCodeHandlerModRM {
    
private Code3 codes;
    public OpCodeHandler_Ev_Gv_CL(Code code16, Code code32, Code code64);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_Ev_Gv_Ib : OpCodeHandlerModRM {
    
private Code3 codes;
    public OpCodeHandler_Ev_Gv_Ib(Code code16, Code code32, Code code64);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_Ev_Gv_REX : OpCodeHandlerModRM {
    
private Code code32;
    
private Code code64;
    public OpCodeHandler_Ev_Gv_REX(Code code32, Code code64);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_Ev_Ib : OpCodeHandlerModRM {
    
private Code3 codes;
    
private HandlerFlags flags;
    public OpCodeHandler_Ev_Ib(Code code16, Code code32, Code code64);
    public OpCodeHandler_Ev_Ib(Code code16, Code code32, Code code64, HandlerFlags flags);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_Ev_Ib2 : OpCodeHandlerModRM {
    
private Code3 codes;
    
private HandlerFlags flags;
    public OpCodeHandler_Ev_Ib2(Code code16, Code code32, Code code64);
    public OpCodeHandler_Ev_Ib2(Code code16, Code code32, Code code64, HandlerFlags flags);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_Ev_Iz : OpCodeHandlerModRM {
    
private Code3 codes;
    
private HandlerFlags flags;
    public OpCodeHandler_Ev_Iz(Code code16, Code code32, Code code64);
    public OpCodeHandler_Ev_Iz(Code code16, Code code32, Code code64, HandlerFlags flags);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_Ev_P : OpCodeHandlerModRM {
    
private Code code32;
    
private Code code64;
    public OpCodeHandler_Ev_P(Code code32, Code code64);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_Ev_REXW : OpCodeHandlerModRM {
    
private Code code32;
    
private Code code64;
    
private UInt32 flags;
    
private UInt32 disallowReg;
    
private UInt32 disallowMem;
    public OpCodeHandler_Ev_REXW(Code code32, Code code64, UInt32 flags);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_Ev_Sw : OpCodeHandlerModRM {
    
private Code3 codes;
    public OpCodeHandler_Ev_Sw(Code code16, Code code32, Code code64);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_Ev_VX : OpCodeHandlerModRM {
    
private Code code32;
    
private Code code64;
    public OpCodeHandler_Ev_VX(Code code32, Code code64);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Iced.Intel.DecoderInternal.OpCodeHandler_EVEX : OpCodeHandlerModRM {
    
private OpCodeHandler handlerMem;
    public OpCodeHandler_EVEX(OpCodeHandler handlerMem);
    public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_EVEX_Ed_V_Ib : OpCodeHandlerModRM {
    
private Register baseReg;
    
private Code code32;
    
private Code code64;
    
private TupleType tupleType32;
    
private TupleType tupleType64;
    public OpCodeHandler_EVEX_Ed_V_Ib(Register baseReg, Code code32, Code code64, TupleType tupleType32, TupleType tupleType64);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_EVEX_Ev_VX : OpCodeHandlerModRM {
    
private Code code32;
    
private Code code64;
    
private TupleType tupleTypeW0;
    
private TupleType tupleTypeW1;
    public OpCodeHandler_EVEX_Ev_VX(Code code32, Code code64, TupleType tupleTypeW0, TupleType tupleTypeW1);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_EVEX_Ev_VX_Ib : OpCodeHandlerModRM {
    
private Register baseReg;
    
private Code code32;
    
private Code code64;
    public OpCodeHandler_EVEX_Ev_VX_Ib(Register baseReg, Code code32, Code code64);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_EVEX_Gv_W_er : OpCodeHandlerModRM {
    
private Register baseReg;
    
private Code codeW0;
    
private Code codeW1;
    
private TupleType tupleType;
    
private bool onlySAE;
    public OpCodeHandler_EVEX_Gv_W_er(Register baseReg, Code codeW0, Code codeW1, TupleType tupleType, bool onlySAE);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_EVEX_GvM_VX_Ib : OpCodeHandlerModRM {
    
private Register baseReg;
    
private Code code32;
    
private Code code64;
    
private TupleType tupleType32;
    
private TupleType tupleType64;
    public OpCodeHandler_EVEX_GvM_VX_Ib(Register baseReg, Code code32, Code code64, TupleType tupleType32, TupleType tupleType64);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_EVEX_HkWIb : OpCodeHandlerModRM {
    
private Register baseReg1;
    
private Register baseReg2;
    
private Code code;
    
private TupleType tupleType;
    
private bool canBroadcast;
    public OpCodeHandler_EVEX_HkWIb(Register baseReg, Code code, TupleType tupleType, bool canBroadcast);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_EVEX_HWIb : OpCodeHandlerModRM {
    
private Register baseReg1;
    
private Register baseReg2;
    
private Code code;
    
private TupleType tupleType;
    public OpCodeHandler_EVEX_HWIb(Register baseReg, Code code, TupleType tupleType);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_EVEX_KkHW : OpCodeHandlerModRM {
    
private Register baseReg;
    
private Code code;
    
private TupleType tupleType;
    
private bool canBroadcast;
    public OpCodeHandler_EVEX_KkHW(Register baseReg, Code code, TupleType tupleType, bool canBroadcast);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_EVEX_KkHWIb : OpCodeHandlerModRM {
    
private Register baseReg;
    
private Code code;
    
private TupleType tupleType;
    
private bool canBroadcast;
    public OpCodeHandler_EVEX_KkHWIb(Register baseReg, Code code, TupleType tupleType, bool canBroadcast);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_EVEX_KkHWIb_sae : OpCodeHandlerModRM {
    
private Register baseReg;
    
private Code code;
    
private TupleType tupleType;
    
private bool canBroadcast;
    public OpCodeHandler_EVEX_KkHWIb_sae(Register baseReg, Code code, TupleType tupleType, bool canBroadcast);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_EVEX_KkWIb : OpCodeHandlerModRM {
    
private Register baseReg;
    
private Code code;
    
private TupleType tupleType;
    
private bool canBroadcast;
    public OpCodeHandler_EVEX_KkWIb(Register baseReg, Code code, TupleType tupleType, bool canBroadcast);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_EVEX_KP1HW : OpCodeHandlerModRM {
    
private Register baseReg;
    
private Code code;
    
private TupleType tupleType;
    public OpCodeHandler_EVEX_KP1HW(Register baseReg, Code code, TupleType tupleType);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_EVEX_KR : OpCodeHandlerModRM {
    
private Register baseReg;
    
private Code code;
    public OpCodeHandler_EVEX_KR(Register baseReg, Code code);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_EVEX_MV : OpCodeHandlerModRM {
    
private Register baseReg;
    
private Code code;
    
private TupleType tupleType;
    public OpCodeHandler_EVEX_MV(Register baseReg, Code code, TupleType tupleType);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_EVEX_V_H_Ev_er : OpCodeHandlerModRM {
    
private Register baseReg;
    
private Code codeW0;
    
private Code codeW1;
    
private TupleType tupleTypeW0;
    
private TupleType tupleTypeW1;
    public OpCodeHandler_EVEX_V_H_Ev_er(Register baseReg, Code codeW0, Code codeW1, TupleType tupleTypeW0, TupleType tupleTypeW1);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_EVEX_V_H_Ev_Ib : OpCodeHandlerModRM {
    
private Register baseReg;
    
private Code codeW0;
    
private Code codeW1;
    
private TupleType tupleTypeW0;
    
private TupleType tupleTypeW1;
    public OpCodeHandler_EVEX_V_H_Ev_Ib(Register baseReg, Code codeW0, Code codeW1, TupleType tupleTypeW0, TupleType tupleTypeW1);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_EVEX_VHM : OpCodeHandlerModRM {
    
private Register baseReg;
    
private Code code;
    
private TupleType tupleType;
    public OpCodeHandler_EVEX_VHM(Register baseReg, Code code, TupleType tupleType);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_EVEX_VHW : OpCodeHandlerModRM {
    
private Register baseReg1;
    
private Register baseReg2;
    
private Register baseReg3;
    
private Code codeR;
    
private Code codeM;
    
private TupleType tupleType;
    public OpCodeHandler_EVEX_VHW(Register baseReg, Code codeR, Code codeM, TupleType tupleType);
    public OpCodeHandler_EVEX_VHW(Register baseReg, Code code, TupleType tupleType);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_EVEX_VHWIb : OpCodeHandlerModRM {
    
private Register baseReg;
    
private Code code;
    
private TupleType tupleType;
    public OpCodeHandler_EVEX_VHWIb(Register baseReg, Code code, TupleType tupleType);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_EVEX_VK : OpCodeHandlerModRM {
    
private Register baseReg;
    
private Code code;
    public OpCodeHandler_EVEX_VK(Register baseReg, Code code);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_EVEX_Vk_VSIB : OpCodeHandlerModRM {
    
private Register baseReg;
    
private Register vsibBase;
    
private Code code;
    
private TupleType tupleType;
    public OpCodeHandler_EVEX_Vk_VSIB(Register baseReg, Register vsibBase, Code code, TupleType tupleType);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_EVEX_VkEv_REXW : OpCodeHandlerModRM {
    
private Register baseReg;
    
private Code code32;
    
private Code code64;
    public OpCodeHandler_EVEX_VkEv_REXW(Register baseReg, Code code32);
    public OpCodeHandler_EVEX_VkEv_REXW(Register baseReg, Code code32, Code code64);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_EVEX_VkHM : OpCodeHandlerModRM {
    
private Register baseReg1;
    
private Register baseReg2;
    
private Code code;
    
private TupleType tupleType;
    public OpCodeHandler_EVEX_VkHM(Register baseReg, Code code, TupleType tupleType);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_EVEX_VkHW : OpCodeHandlerModRM {
    
private Register baseReg1;
    
private Register baseReg2;
    
private Register baseReg3;
    
private Code code;
    
private TupleType tupleType;
    
private bool canBroadcast;
    public OpCodeHandler_EVEX_VkHW(Register baseReg, Code code, TupleType tupleType, bool canBroadcast);
    public OpCodeHandler_EVEX_VkHW(Register baseReg1, Register baseReg2, Register baseReg3, Code code, TupleType tupleType, bool canBroadcast);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_EVEX_VkHW_er : OpCodeHandlerModRM {
    
private Register baseReg;
    
private Code code;
    
private TupleType tupleType;
    
private bool onlySAE;
    
private bool canBroadcast;
    public OpCodeHandler_EVEX_VkHW_er(Register baseReg, Code code, TupleType tupleType, bool onlySAE, bool canBroadcast);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_EVEX_VkHW_er_ur : OpCodeHandlerModRM {
    
private Register baseReg;
    
private Code code;
    
private TupleType tupleType;
    
private bool canBroadcast;
    public OpCodeHandler_EVEX_VkHW_er_ur(Register baseReg, Code code, TupleType tupleType, bool canBroadcast);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_EVEX_VkHWIb : OpCodeHandlerModRM {
    
private Register baseReg1;
    
private Register baseReg2;
    
private Register baseReg3;
    
private Code code;
    
private TupleType tupleType;
    
private bool canBroadcast;
    public OpCodeHandler_EVEX_VkHWIb(Register baseReg, Code code, TupleType tupleType, bool canBroadcast);
    public OpCodeHandler_EVEX_VkHWIb(Register baseReg1, Register baseReg2, Register baseReg3, Code code, TupleType tupleType, bool canBroadcast);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_EVEX_VkHWIb_er : OpCodeHandlerModRM {
    
private Register baseReg1;
    
private Register baseReg2;
    
private Register baseReg3;
    
private Code code;
    
private TupleType tupleType;
    
private bool canBroadcast;
    public OpCodeHandler_EVEX_VkHWIb_er(Register baseReg, Code code, TupleType tupleType, bool canBroadcast);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_EVEX_VkM : OpCodeHandlerModRM {
    
private Register baseReg;
    
private Code code;
    
private TupleType tupleType;
    public OpCodeHandler_EVEX_VkM(Register baseReg, Code code, TupleType tupleType);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_EVEX_VkW : OpCodeHandlerModRM {
    
private Register baseReg1;
    
private Register baseReg2;
    
private Code code;
    
private TupleType tupleType;
    
private bool canBroadcast;
    public OpCodeHandler_EVEX_VkW(Register baseReg, Code code, TupleType tupleType, bool canBroadcast);
    public OpCodeHandler_EVEX_VkW(Register baseReg1, Register baseReg2, Code code, TupleType tupleType, bool canBroadcast);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_EVEX_VkW_er : OpCodeHandlerModRM {
    
private Register baseReg1;
    
private Register baseReg2;
    
private Code code;
    
private TupleType tupleType;
    
private bool onlySAE;
    
private bool canBroadcast;
    public OpCodeHandler_EVEX_VkW_er(Register baseReg, Code code, TupleType tupleType, bool onlySAE);
    public OpCodeHandler_EVEX_VkW_er(Register baseReg1, Register baseReg2, Code code, TupleType tupleType, bool onlySAE);
    public OpCodeHandler_EVEX_VkW_er(Register baseReg1, Register baseReg2, Code code, TupleType tupleType, bool onlySAE, bool canBroadcast);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_EVEX_VkWIb : OpCodeHandlerModRM {
    
private Register baseReg1;
    
private Register baseReg2;
    
private Code code;
    
private TupleType tupleType;
    
private bool canBroadcast;
    public OpCodeHandler_EVEX_VkWIb(Register baseReg, Code code, TupleType tupleType, bool canBroadcast);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_EVEX_VkWIb_er : OpCodeHandlerModRM {
    
private Register baseReg1;
    
private Register baseReg2;
    
private Code code;
    
private TupleType tupleType;
    public OpCodeHandler_EVEX_VkWIb_er(Register baseReg, Code code, TupleType tupleType);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_EVEX_VM : OpCodeHandlerModRM {
    
private Register baseReg;
    
private Code code;
    
private TupleType tupleType;
    public OpCodeHandler_EVEX_VM(Register baseReg, Code code, TupleType tupleType);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_EVEX_VSIB_k1 : OpCodeHandlerModRM {
    
private Register vsibIndex;
    
private Code code;
    
private TupleType tupleType;
    public OpCodeHandler_EVEX_VSIB_k1(Register vsibIndex, Code code, TupleType tupleType);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_EVEX_VSIB_k1_VX : OpCodeHandlerModRM {
    
private Register vsibIndex;
    
private Register baseReg;
    
private Code code;
    
private TupleType tupleType;
    public OpCodeHandler_EVEX_VSIB_k1_VX(Register vsibIndex, Register baseReg, Code code, TupleType tupleType);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_EVEX_VW : OpCodeHandlerModRM {
    
private Register baseReg1;
    
private Register baseReg2;
    
private Code code;
    
private TupleType tupleType;
    public OpCodeHandler_EVEX_VW(Register baseReg, Code code, TupleType tupleType);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_EVEX_VW_er : OpCodeHandlerModRM {
    
private Register baseReg1;
    
private Register baseReg2;
    
private Code code;
    
private TupleType tupleType;
    public OpCodeHandler_EVEX_VW_er(Register baseReg, Code code, TupleType tupleType);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_EVEX_VX_Ev : OpCodeHandlerModRM {
    
private Code code32;
    
private Code code64;
    
private TupleType tupleTypeW0;
    
private TupleType tupleTypeW1;
    public OpCodeHandler_EVEX_VX_Ev(Code code32, Code code64, TupleType tupleTypeW0, TupleType tupleTypeW1);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_EVEX_WkHV : OpCodeHandlerModRM {
    
private Register baseReg;
    
private Code code;
    public OpCodeHandler_EVEX_WkHV(Register baseReg, Code code);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_EVEX_WkV : OpCodeHandlerModRM {
    
private Register baseReg1;
    
private Register baseReg2;
    
private Code code;
    
private TupleType tupleType;
    
private UInt32 disallowZeroingMasking;
    public OpCodeHandler_EVEX_WkV(Register baseReg, Code code, TupleType tupleType);
    public OpCodeHandler_EVEX_WkV(Register baseReg, Code code, TupleType tupleType, bool allowZeroingMasking);
    public OpCodeHandler_EVEX_WkV(Register baseReg1, Register baseReg2, Code code, TupleType tupleType);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_EVEX_WkVIb : OpCodeHandlerModRM {
    
private Register baseReg1;
    
private Register baseReg2;
    
private Code code;
    
private TupleType tupleType;
    public OpCodeHandler_EVEX_WkVIb(Register baseReg1, Register baseReg2, Code code, TupleType tupleType);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_EVEX_WkVIb_er : OpCodeHandlerModRM {
    
private Register baseReg1;
    
private Register baseReg2;
    
private Code code;
    
private TupleType tupleType;
    public OpCodeHandler_EVEX_WkVIb_er(Register baseReg1, Register baseReg2, Code code, TupleType tupleType);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_EVEX_WV : OpCodeHandlerModRM {
    
private Register baseReg1;
    
private Register baseReg2;
    
private Code code;
    
private TupleType tupleType;
    public OpCodeHandler_EVEX_WV(Register baseReg, Code code, TupleType tupleType);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_Evj : OpCodeHandlerModRM {
    
private Code code16;
    
private Code code32;
    
private Code code64;
    public OpCodeHandler_Evj(Code code16, Code code32, Code code64);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_Evw : OpCodeHandlerModRM {
    
private Code3 codes;
    public OpCodeHandler_Evw(Code code16, Code code32, Code code64);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_Ew : OpCodeHandlerModRM {
    
private Code3 codes;
    public OpCodeHandler_Ew(Code code16, Code code32, Code code64);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_Gb_Eb : OpCodeHandlerModRM {
    
private Code code;
    public OpCodeHandler_Gb_Eb(Code code);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_Gd_Rd : OpCodeHandlerModRM {
    
private Code code;
    public OpCodeHandler_Gd_Rd(Code code);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_Gdq_Ev : OpCodeHandlerModRM {
    
private Code3 codes;
    public OpCodeHandler_Gdq_Ev(Code code16, Code code32, Code code64);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Iced.Intel.DecoderInternal.OpCodeHandler_Group : OpCodeHandlerModRM {
    
private OpCodeHandler[] groupHandlers;
    public OpCodeHandler_Group(OpCodeHandler[] groupHandlers);
    public virtual void Decode(Decoder decoder, Instruction& instruction);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Iced.Intel.DecoderInternal.OpCodeHandler_Group8x64 : OpCodeHandlerModRM {
    
private OpCodeHandler[] tableLow;
    
private OpCodeHandler[] tableHigh;
    public OpCodeHandler_Group8x64(OpCodeHandler[] tableLow, OpCodeHandler[] tableHigh);
    public virtual void Decode(Decoder decoder, Instruction& instruction);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Iced.Intel.DecoderInternal.OpCodeHandler_Group8x8 : OpCodeHandlerModRM {
    
private OpCodeHandler[] tableLow;
    
private OpCodeHandler[] tableHigh;
    public OpCodeHandler_Group8x8(OpCodeHandler[] tableLow, OpCodeHandler[] tableHigh);
    public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_Gv_Eb : OpCodeHandlerModRM {
    
private Code3 codes;
    public OpCodeHandler_Gv_Eb(Code code16, Code code32, Code code64);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_Gv_Eb_REX : OpCodeHandlerModRM {
    
private Code code32;
    
private Code code64;
    public OpCodeHandler_Gv_Eb_REX(Code code32, Code code64);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_Gv_Ev : OpCodeHandlerModRM {
    
private Code3 codes;
    public OpCodeHandler_Gv_Ev(Code code16, Code code32, Code code64);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_Gv_Ev_32_64 : OpCodeHandlerModRM {
    
private Code code32;
    
private Code code64;
    
private UInt32 disallowReg;
    
private UInt32 disallowMem;
    public OpCodeHandler_Gv_Ev_32_64(Code code32, Code code64, bool allowReg, bool allowMem);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_Gv_Ev_Ib : OpCodeHandlerModRM {
    
private Code3 codes;
    public OpCodeHandler_Gv_Ev_Ib(Code code16, Code code32, Code code64);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_Gv_Ev_Ib_REX : OpCodeHandlerModRM {
    
private Code code32;
    
private Code code64;
    public OpCodeHandler_Gv_Ev_Ib_REX(Code code32, Code code64);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_Gv_Ev_Iz : OpCodeHandlerModRM {
    
private Code3 codes;
    public OpCodeHandler_Gv_Ev_Iz(Code code16, Code code32, Code code64);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_Gv_Ev_REX : OpCodeHandlerModRM {
    
private Code code32;
    
private Code code64;
    public OpCodeHandler_Gv_Ev_REX(Code code32, Code code64);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_Gv_Ev2 : OpCodeHandlerModRM {
    
private Code3 codes;
    public OpCodeHandler_Gv_Ev2(Code code16, Code code32, Code code64);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_Gv_Ev3 : OpCodeHandlerModRM {
    
private Code3 codes;
    public OpCodeHandler_Gv_Ev3(Code code16, Code code32, Code code64);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_Gv_Ew : OpCodeHandlerModRM {
    
private Code3 codes;
    public OpCodeHandler_Gv_Ew(Code code16, Code code32, Code code64);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_Gv_M : OpCodeHandlerModRM {
    
private Code3 codes;
    public OpCodeHandler_Gv_M(Code code16, Code code32, Code code64);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_Gv_M_as : OpCodeHandlerModRM {
    
private Code3 codes;
    public OpCodeHandler_Gv_M_as(Code code16, Code code32, Code code64);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_Gv_Ma : OpCodeHandlerModRM {
    
private Code code16;
    
private Code code32;
    public OpCodeHandler_Gv_Ma(Code code16, Code code32);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_Gv_Mp : OpCodeHandlerModRM {
    
private Code code16;
    
private Code code32;
    
private Code code64;
    public OpCodeHandler_Gv_Mp(Code code16, Code code32, Code code64);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_Gv_Mv : OpCodeHandlerModRM {
    
private Code3 codes;
    public OpCodeHandler_Gv_Mv(Code code16, Code code32, Code code64);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_Gv_N : OpCodeHandlerModRM {
    
private Code code32;
    
private Code code64;
    public OpCodeHandler_Gv_N(Code code32, Code code64);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_Gv_N_Ib_REX : OpCodeHandlerModRM {
    
private Code code32;
    
private Code code64;
    public OpCodeHandler_Gv_N_Ib_REX(Code code32, Code code64);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_Gv_RX : OpCodeHandlerModRM {
    
private Code code32;
    
private Code code64;
    public OpCodeHandler_Gv_RX(Code code32, Code code64);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_Gv_W : OpCodeHandlerModRM {
    
private Code codeW0;
    
private Code codeW1;
    public OpCodeHandler_Gv_W(Code codeW0, Code codeW1);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_GvM_VX_Ib : OpCodeHandlerModRM {
    
private Code code32;
    
private Code code64;
    public OpCodeHandler_GvM_VX_Ib(Code code32, Code code64);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_Ib : OpCodeHandler {
    
private Code code;
    public OpCodeHandler_Ib(Code code);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_Ib3 : OpCodeHandlerModRM {
    
private Code code;
    public OpCodeHandler_Ib3(Code code);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_IbReg : OpCodeHandler {
    
private Code code;
    
private Register reg;
    public OpCodeHandler_IbReg(Code code, Register reg);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_IbReg2 : OpCodeHandler {
    
private Code code16;
    
private Code code32;
    public OpCodeHandler_IbReg2(Code code16, Code code32);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Iced.Intel.DecoderInternal.OpCodeHandler_Invalid : OpCodeHandlerModRM {
    
public static OpCodeHandler_Invalid Instance;
    private static OpCodeHandler_Invalid();
    public virtual void Decode(Decoder decoder, Instruction& instruction);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Iced.Intel.DecoderInternal.OpCodeHandler_Invalid_NoModRM : OpCodeHandler {
    
public static OpCodeHandler_Invalid_NoModRM Instance;
    private static OpCodeHandler_Invalid_NoModRM();
    public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_Iw_Ib : OpCodeHandler {
    
private Code code16;
    
private Code code32;
    
private Code code64;
    public OpCodeHandler_Iw_Ib(Code code16, Code code32, Code code64);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_Jb : OpCodeHandler {
    
private Code code16;
    
private Code code32;
    
private Code code64;
    public OpCodeHandler_Jb(Code code16, Code code32, Code code64);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_Jb2 : OpCodeHandler {
    
private Code code16_16;
    
private Code code16_32;
    
private Code code16_64;
    
private Code code32_16;
    
private Code code32_32;
    
private Code code64_32;
    
private Code code64_64;
    public OpCodeHandler_Jb2(Code code16_16, Code code16_32, Code code16_64, Code code32_16, Code code32_32, Code code64_32, Code code64_64);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_Jdisp : OpCodeHandler {
    
private Code code16;
    
private Code code32;
    public OpCodeHandler_Jdisp(Code code16, Code code32);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_Jx : OpCodeHandler {
    
private Code code16;
    
private Code code32;
    
private Code code64;
    public OpCodeHandler_Jx(Code code16, Code code32, Code code64);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_Jz : OpCodeHandler {
    
private Code code16;
    
private Code code32;
    
private Code code64;
    public OpCodeHandler_Jz(Code code16, Code code32, Code code64);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_M : OpCodeHandlerModRM {
    
private Code codeW0;
    
private Code codeW1;
    public OpCodeHandler_M(Code codeW0, Code codeW1);
    public OpCodeHandler_M(Code codeW0);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_M_REXW : OpCodeHandlerModRM {
    
private Code code32;
    
private Code code64;
    
private HandlerFlags flags32;
    
private HandlerFlags flags64;
    public OpCodeHandler_M_REXW(Code code32, Code code64);
    public OpCodeHandler_M_REXW(Code code32, Code code64, HandlerFlags flags32, HandlerFlags flags64);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_M_Sw : OpCodeHandlerModRM {
    
private Code code;
    public OpCodeHandler_M_Sw(Code code);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Iced.Intel.DecoderInternal.OpCodeHandler_MandatoryPrefix : OpCodeHandlerModRM {
    
private OpCodeHandler[] handlers;
    public OpCodeHandler_MandatoryPrefix(OpCodeHandler handler, OpCodeHandler handler66, OpCodeHandler handlerF3, OpCodeHandler handlerF2);
    public virtual void Decode(Decoder decoder, Instruction& instruction);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Iced.Intel.DecoderInternal.OpCodeHandler_MandatoryPrefix_NoModRM : OpCodeHandler {
    
private OpCodeHandler[] handlers;
    public OpCodeHandler_MandatoryPrefix_NoModRM(OpCodeHandler handler, OpCodeHandler handler66, OpCodeHandler handlerF3, OpCodeHandler handlerF2);
    public virtual void Decode(Decoder decoder, Instruction& instruction);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Iced.Intel.DecoderInternal.OpCodeHandler_MandatoryPrefix2 : OpCodeHandlerModRM {
    
private OpCodeHandler[] handlers;
    public OpCodeHandler_MandatoryPrefix2(OpCodeHandler handler);
    public OpCodeHandler_MandatoryPrefix2(OpCodeHandler handler, OpCodeHandler handler66, OpCodeHandler handlerF3, OpCodeHandler handlerF2);
    public virtual void Decode(Decoder decoder, Instruction& instruction);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Iced.Intel.DecoderInternal.OpCodeHandler_MandatoryPrefix2_NoModRM : OpCodeHandler {
    
private OpCodeHandler[] handlers;
    public OpCodeHandler_MandatoryPrefix2_NoModRM(OpCodeHandler handler, OpCodeHandler handler66, OpCodeHandler handlerF3, OpCodeHandler handlerF2);
    public virtual void Decode(Decoder decoder, Instruction& instruction);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Iced.Intel.DecoderInternal.OpCodeHandler_MandatoryPrefix3 : OpCodeHandlerModRM {
    
private Info[] handlers_reg;
    
private Info[] handlers_mem;
    public OpCodeHandler_MandatoryPrefix3(OpCodeHandler handler_reg, OpCodeHandler handler_mem, OpCodeHandler handler66_reg, OpCodeHandler handler66_mem, OpCodeHandler handlerF3_reg, OpCodeHandler handlerF3_mem, OpCodeHandler handlerF2_reg, OpCodeHandler handlerF2_mem, LegacyHandlerFlags flags);
    public virtual void Decode(Decoder decoder, Instruction& instruction);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Iced.Intel.DecoderInternal.OpCodeHandler_MandatoryPrefix4 : OpCodeHandler {
    
private OpCodeHandler handlerNP;
    
private OpCodeHandler handler66;
    
private OpCodeHandler handlerF3;
    
private OpCodeHandler handlerF2;
    
private UInt32 flags;
    public OpCodeHandler_MandatoryPrefix4(OpCodeHandler handlerNP, OpCodeHandler handler66, OpCodeHandler handlerF3, OpCodeHandler handlerF2, UInt32 flags);
    public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_MemBx : OpCodeHandler {
    
private Code code;
    public OpCodeHandler_MemBx(Code code);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_Mf : OpCodeHandlerModRM {
    
private Code code16;
    
private Code code32;
    public OpCodeHandler_Mf(Code code);
    public OpCodeHandler_Mf(Code code16, Code code32);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_MIB_B : OpCodeHandlerModRM {
    
private Code code;
    public OpCodeHandler_MIB_B(Code code);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_MP : OpCodeHandlerModRM {
    
private Code code;
    public OpCodeHandler_MP(Code code);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_Ms : OpCodeHandlerModRM {
    
private Code code16;
    
private Code code32;
    
private Code code64;
    public OpCodeHandler_Ms(Code code16, Code code32, Code code64);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_MV : OpCodeHandlerModRM {
    
private Code code;
    public OpCodeHandler_MV(Code code);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_Mv_Gv : OpCodeHandlerModRM {
    
private Code3 codes;
    public OpCodeHandler_Mv_Gv(Code code16, Code code32, Code code64);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_Mv_Gv_REXW : OpCodeHandlerModRM {
    
private Code code32;
    
private Code code64;
    public OpCodeHandler_Mv_Gv_REXW(Code code32, Code code64);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_NIb : OpCodeHandlerModRM {
    
private Code code;
    public OpCodeHandler_NIb(Code code);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_Ob_Reg : OpCodeHandler {
    
private Code code;
    
private Register reg;
    public OpCodeHandler_Ob_Reg(Code code, Register reg);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Iced.Intel.DecoderInternal.OpCodeHandler_Options : OpCodeHandler {
    
private OpCodeHandler defaultHandler;
    
private HandlerOptions[] infos;
    
private DecoderOptions infoOptions;
    public OpCodeHandler_Options(OpCodeHandler defaultHandler, OpCodeHandler handler1, DecoderOptions options1);
    public OpCodeHandler_Options(OpCodeHandler defaultHandler, OpCodeHandler handler1, DecoderOptions options1, OpCodeHandler handler2, DecoderOptions options2);
    public virtual void Decode(Decoder decoder, Instruction& instruction);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Iced.Intel.DecoderInternal.OpCodeHandler_Options_DontReadModRM : OpCodeHandlerModRM {
    
private OpCodeHandler defaultHandler;
    
private HandlerOptions[] infos;
    public OpCodeHandler_Options_DontReadModRM(OpCodeHandler defaultHandler, OpCodeHandler handler1, DecoderOptions options1);
    public virtual void Decode(Decoder decoder, Instruction& instruction);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Iced.Intel.DecoderInternal.OpCodeHandler_Options1632 : OpCodeHandler {
    
private OpCodeHandler defaultHandler;
    
private HandlerOptions[] infos;
    
private DecoderOptions infoOptions;
    public OpCodeHandler_Options1632(OpCodeHandler defaultHandler, OpCodeHandler handler1, DecoderOptions options1);
    public OpCodeHandler_Options1632(OpCodeHandler defaultHandler, OpCodeHandler handler1, DecoderOptions options1, OpCodeHandler handler2, DecoderOptions options2);
    public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_Ov_Reg : OpCodeHandler {
    
private Code3 codes;
    public OpCodeHandler_Ov_Reg(Code code16, Code code32, Code code64);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_P_Ev : OpCodeHandlerModRM {
    
private Code code32;
    
private Code code64;
    public OpCodeHandler_P_Ev(Code code32, Code code64);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_P_Ev_Ib : OpCodeHandlerModRM {
    
private Code code32;
    
private Code code64;
    public OpCodeHandler_P_Ev_Ib(Code code32, Code code64);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_P_Q : OpCodeHandlerModRM {
    
private Code code;
    public OpCodeHandler_P_Q(Code code);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_P_Q_Ib : OpCodeHandlerModRM {
    
private Code code;
    public OpCodeHandler_P_Q_Ib(Code code);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_P_R : OpCodeHandlerModRM {
    
private Code code;
    public OpCodeHandler_P_R(Code code);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_P_W : OpCodeHandlerModRM {
    
private Code code;
    public OpCodeHandler_P_W(Code code);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_Prefix66 : OpCodeHandler {
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_Prefix67 : OpCodeHandler {
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_PrefixEsCsSsDs : OpCodeHandler {
    
private Register seg;
    public OpCodeHandler_PrefixEsCsSsDs(Register seg);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_PrefixF0 : OpCodeHandler {
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_PrefixF2 : OpCodeHandler {
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_PrefixF3 : OpCodeHandler {
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_PrefixFsGs : OpCodeHandler {
    
private Register seg;
    public OpCodeHandler_PrefixFsGs(Register seg);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Iced.Intel.DecoderInternal.OpCodeHandler_PrefixREX : OpCodeHandler {
    
private OpCodeHandler handler;
    
private UInt32 rex;
    public OpCodeHandler_PrefixREX(OpCodeHandler handler, UInt32 rex);
    public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_PushEv : OpCodeHandlerModRM {
    
private Code code16;
    
private Code code32;
    
private Code code64;
    public OpCodeHandler_PushEv(Code code16, Code code32, Code code64);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_PushIb2 : OpCodeHandler {
    
private Code code16;
    
private Code code32;
    
private Code code64;
    public OpCodeHandler_PushIb2(Code code16, Code code32, Code code64);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_PushIz : OpCodeHandler {
    
private Code code16;
    
private Code code32;
    
private Code code64;
    public OpCodeHandler_PushIz(Code code16, Code code32, Code code64);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_PushOpSizeReg : OpCodeHandler {
    
private Code code16;
    
private Code code32;
    
private Code code64;
    
private Register reg;
    public OpCodeHandler_PushOpSizeReg(Code code16, Code code32, Code code64, Register reg);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_PushSimple2 : OpCodeHandler {
    
private Code code16;
    
private Code code32;
    
private Code code64;
    public OpCodeHandler_PushSimple2(Code code16, Code code32, Code code64);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_PushSimpleReg : OpCodeHandler {
    
private int index;
    
private Code code16;
    
private Code code32;
    
private Code code64;
    public OpCodeHandler_PushSimpleReg(int index, Code code16, Code code32, Code code64);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_Q_P : OpCodeHandlerModRM {
    
private Code code;
    public OpCodeHandler_Q_P(Code code);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_R_C : OpCodeHandlerModRM {
    
private Code code32;
    
private Code code64;
    
private Register baseReg;
    public OpCodeHandler_R_C(Code code32, Code code64, Register baseReg);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_rDI_P_N : OpCodeHandlerModRM {
    
private Code code;
    public OpCodeHandler_rDI_P_N(Code code);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_rDI_VX_RX : OpCodeHandlerModRM {
    
private Code code;
    public OpCodeHandler_rDI_VX_RX(Code code);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_Reg : OpCodeHandler {
    
private Code code;
    
private Register reg;
    public OpCodeHandler_Reg(Code code, Register reg);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_Reg_Ib2 : OpCodeHandler {
    
private Code code16;
    
private Code code32;
    public OpCodeHandler_Reg_Ib2(Code code16, Code code32);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_Reg_Iz : OpCodeHandler {
    
private Code code16;
    
private Code code32;
    
private Code code64;
    public OpCodeHandler_Reg_Iz(Code code16, Code code32, Code code64);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_Reg_Ob : OpCodeHandler {
    
private Code code;
    
private Register reg;
    public OpCodeHandler_Reg_Ob(Code code, Register reg);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_Reg_Ov : OpCodeHandler {
    
private Code3 codes;
    public OpCodeHandler_Reg_Ov(Code code16, Code code32, Code code64);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_Reg_Xb : OpCodeHandler {
    
private Code code;
    
private Register reg;
    public OpCodeHandler_Reg_Xb(Code code, Register reg);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_Reg_Xv : OpCodeHandler {
    
private Code3 codes;
    public OpCodeHandler_Reg_Xv(Code code16, Code code32, Code code64);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_Reg_Xv2 : OpCodeHandler {
    
private Code code16;
    
private Code code32;
    public OpCodeHandler_Reg_Xv2(Code code16, Code code32);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_Reg_Yb : OpCodeHandler {
    
private Code code;
    
private Register reg;
    public OpCodeHandler_Reg_Yb(Code code, Register reg);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_Reg_Yv : OpCodeHandler {
    
private Code3 codes;
    public OpCodeHandler_Reg_Yv(Code code16, Code code32, Code code64);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_RegIb : OpCodeHandler {
    
private Code code;
    
private Register reg;
    public OpCodeHandler_RegIb(Code code, Register reg);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_RegIb3 : OpCodeHandler {
    
private int index;
    
private Register[] withRexPrefix;
    
private static Register[] s_withRexPrefix;
    public OpCodeHandler_RegIb3(int index);
    private static OpCodeHandler_RegIb3();
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_RegIz2 : OpCodeHandler {
    
private int index;
    public OpCodeHandler_RegIz2(int index);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Iced.Intel.DecoderInternal.OpCodeHandler_Reservednop : OpCodeHandlerModRM {
    
private OpCodeHandler reservedNopHandler;
    
private OpCodeHandler otherHandler;
    public OpCodeHandler_Reservednop(OpCodeHandler reservedNopHandler, OpCodeHandler otherHandler);
    public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_RIb : OpCodeHandlerModRM {
    
private Code code;
    public OpCodeHandler_RIb(Code code);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_RIbIb : OpCodeHandlerModRM {
    
private Code code;
    public OpCodeHandler_RIbIb(Code code);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Iced.Intel.DecoderInternal.OpCodeHandler_RM : OpCodeHandlerModRM {
    
private OpCodeHandler reg;
    
private OpCodeHandler mem;
    public OpCodeHandler_RM(OpCodeHandler reg, OpCodeHandler mem);
    public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_Rq : OpCodeHandlerModRM {
    
private Code code;
    public OpCodeHandler_Rq(Code code);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_Rv : OpCodeHandlerModRM {
    
private Code3 codes;
    public OpCodeHandler_Rv(Code code16, Code code32, Code code64);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_Rv_32_64 : OpCodeHandlerModRM {
    
private Code code32;
    
private Code code64;
    public OpCodeHandler_Rv_32_64(Code code32, Code code64);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_RvMw_Gw : OpCodeHandlerModRM {
    
private Code code16;
    
private Code code32;
    public OpCodeHandler_RvMw_Gw(Code code16, Code code32);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_Simple : OpCodeHandler {
    
private Code code;
    public OpCodeHandler_Simple(Code code);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_Simple_ModRM : OpCodeHandlerModRM {
    
private Code code;
    public OpCodeHandler_Simple_ModRM(Code code);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_Simple2 : OpCodeHandler {
    
private Code3 codes;
    public OpCodeHandler_Simple2(Code code16, Code code32, Code code64);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_Simple2Iw : OpCodeHandler {
    
private Code3 codes;
    public OpCodeHandler_Simple2Iw(Code code16, Code code32, Code code64);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_Simple3 : OpCodeHandler {
    
private Code code16;
    
private Code code32;
    
private Code code64;
    public OpCodeHandler_Simple3(Code code16, Code code32, Code code64);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_Simple4 : OpCodeHandler {
    
private Code code32;
    
private Code code64;
    public OpCodeHandler_Simple4(Code code32, Code code64);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_Simple5 : OpCodeHandler {
    
private Code3 codes;
    public OpCodeHandler_Simple5(Code code16, Code code32, Code code64);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_Simple5_a32 : OpCodeHandler {
    
private Code3 codes;
    public OpCodeHandler_Simple5_a32(Code code16, Code code32, Code code64);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_Simple5_ModRM_as : OpCodeHandlerModRM {
    
private Code3 codes;
    public OpCodeHandler_Simple5_ModRM_as(Code code16, Code code32, Code code64);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_SimpleReg : OpCodeHandler {
    
private Code code;
    
private int index;
    public OpCodeHandler_SimpleReg(Code code, int index);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_ST_STi : OpCodeHandlerModRM {
    
private Code code;
    public OpCodeHandler_ST_STi(Code code);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_STi : OpCodeHandlerModRM {
    
private Code code;
    public OpCodeHandler_STi(Code code);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_STi_ST : OpCodeHandlerModRM {
    
private Code code;
    public OpCodeHandler_STi_ST(Code code);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_Sw_Ev : OpCodeHandlerModRM {
    
private Code3 codes;
    public OpCodeHandler_Sw_Ev(Code code16, Code code32, Code code64);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_Sw_M : OpCodeHandlerModRM {
    
private Code code;
    public OpCodeHandler_Sw_M(Code code);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_V_Ev : OpCodeHandlerModRM {
    
private Code codeW0;
    
private Code codeW1;
    public OpCodeHandler_V_Ev(Code codeW0, Code codeW1);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Iced.Intel.DecoderInternal.OpCodeHandler_VectorLength_EVEX : OpCodeHandlerModRM {
    
private OpCodeHandler[] handlers;
    public OpCodeHandler_VectorLength_EVEX(OpCodeHandler handler128, OpCodeHandler handler256, OpCodeHandler handler512);
    public virtual void Decode(Decoder decoder, Instruction& instruction);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Iced.Intel.DecoderInternal.OpCodeHandler_VectorLength_EVEX_er : OpCodeHandlerModRM {
    
private OpCodeHandler[] handlers;
    public OpCodeHandler_VectorLength_EVEX_er(OpCodeHandler handler128, OpCodeHandler handler256, OpCodeHandler handler512);
    public virtual void Decode(Decoder decoder, Instruction& instruction);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Iced.Intel.DecoderInternal.OpCodeHandler_VectorLength_NoModRM_VEX : OpCodeHandler {
    
private OpCodeHandler[] handlers;
    public OpCodeHandler_VectorLength_NoModRM_VEX(OpCodeHandler handler128, OpCodeHandler handler256);
    public virtual void Decode(Decoder decoder, Instruction& instruction);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Iced.Intel.DecoderInternal.OpCodeHandler_VectorLength_VEX : OpCodeHandlerModRM {
    
private OpCodeHandler[] handlers;
    public OpCodeHandler_VectorLength_VEX(OpCodeHandler handler128, OpCodeHandler handler256);
    public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_VEX_Ed_V_Ib : OpCodeHandlerModRM {
    
private Register baseReg;
    
private Code code32;
    
private Code code64;
    public OpCodeHandler_VEX_Ed_V_Ib(Register baseReg, Code code32, Code code64);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_VEX_Ev : OpCodeHandlerModRM {
    
private Code code32;
    
private Code code64;
    public OpCodeHandler_VEX_Ev(Code code32, Code code64);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_VEX_Ev_VX : OpCodeHandlerModRM {
    
private Code code32;
    
private Code code64;
    public OpCodeHandler_VEX_Ev_VX(Code code32, Code code64);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_VEX_G_VK : OpCodeHandlerModRM {
    
private Code code;
    
private Register gpr;
    public OpCodeHandler_VEX_G_VK(Code code, Register gpr);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_VEX_Gq_HK_RK : OpCodeHandlerModRM {
    
private Code code;
    public OpCodeHandler_VEX_Gq_HK_RK(Code code);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_VEX_Gv_Ev : OpCodeHandlerModRM {
    
private Code code32;
    
private Code code64;
    public OpCodeHandler_VEX_Gv_Ev(Code code32, Code code64);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_VEX_Gv_Ev_Gv : OpCodeHandlerModRM {
    
private Code code32;
    
private Code code64;
    public OpCodeHandler_VEX_Gv_Ev_Gv(Code code32, Code code64);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_VEX_Gv_Ev_Ib : OpCodeHandlerModRM {
    
private Code code32;
    
private Code code64;
    public OpCodeHandler_VEX_Gv_Ev_Ib(Code code32, Code code64);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_VEX_Gv_Ev_Id : OpCodeHandlerModRM {
    
private Code code32;
    
private Code code64;
    public OpCodeHandler_VEX_Gv_Ev_Id(Code code32, Code code64);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_VEX_Gv_GPR_Ib : OpCodeHandlerModRM {
    
private Register baseReg;
    
private Code code32;
    
private Code code64;
    public OpCodeHandler_VEX_Gv_GPR_Ib(Register baseReg, Code code32, Code code64);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_VEX_Gv_Gv_Ev : OpCodeHandlerModRM {
    
private Code code32;
    
private Code code64;
    public OpCodeHandler_VEX_Gv_Gv_Ev(Code code32, Code code64);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_VEX_Gv_RX : OpCodeHandlerModRM {
    
private Register baseReg;
    
private Code code32;
    
private Code code64;
    public OpCodeHandler_VEX_Gv_RX(Register baseReg, Code code32, Code code64);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_VEX_Gv_W : OpCodeHandlerModRM {
    
private Register baseReg;
    
private Code codeW0;
    
private Code codeW1;
    public OpCodeHandler_VEX_Gv_W(Register baseReg, Code codeW0, Code codeW1);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_VEX_GvM_VX_Ib : OpCodeHandlerModRM {
    
private Register baseReg;
    
private Code code32;
    
private Code code64;
    public OpCodeHandler_VEX_GvM_VX_Ib(Register baseReg, Code code32, Code code64);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_VEX_HRIb : OpCodeHandlerModRM {
    
private Register baseReg;
    
private Code code;
    public OpCodeHandler_VEX_HRIb(Register baseReg, Code code);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_VEX_Hv_Ed_Id : OpCodeHandlerModRM {
    
private Code code32;
    
private Code code64;
    public OpCodeHandler_VEX_Hv_Ed_Id(Code code32, Code code64);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_VEX_Hv_Ev : OpCodeHandlerModRM {
    
private Code code32;
    
private Code code64;
    public OpCodeHandler_VEX_Hv_Ev(Code code32, Code code64);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_VEX_K_Jb : OpCodeHandlerModRM {
    
private Code code;
    public OpCodeHandler_VEX_K_Jb(Code code);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_VEX_K_Jz : OpCodeHandlerModRM {
    
private Code code;
    public OpCodeHandler_VEX_K_Jz(Code code);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_VEX_M : OpCodeHandlerModRM {
    
private Code code;
    public OpCodeHandler_VEX_M(Code code);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_VEX_M_VK : OpCodeHandlerModRM {
    
private Code code;
    public OpCodeHandler_VEX_M_VK(Code code);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_VEX_MHV : OpCodeHandlerModRM {
    
private Register baseReg;
    
private Code code;
    public OpCodeHandler_VEX_MHV(Register baseReg, Code code);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_VEX_MV : OpCodeHandlerModRM {
    
private Register baseReg;
    
private Code code;
    public OpCodeHandler_VEX_MV(Register baseReg, Code code);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_VEX_rDI_VX_RX : OpCodeHandlerModRM {
    
private Register baseReg;
    
private Code code;
    public OpCodeHandler_VEX_rDI_VX_RX(Register baseReg, Code code);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_VEX_RdRq : OpCodeHandlerModRM {
    
private Code code32;
    
private Code code64;
    public OpCodeHandler_VEX_RdRq(Code code32, Code code64);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_VEX_SIBMEM_VT : OpCodeHandlerModRM {
    
private Code code;
    public OpCodeHandler_VEX_SIBMEM_VT(Code code);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_VEX_Simple : OpCodeHandler {
    
private Code code;
    public OpCodeHandler_VEX_Simple(Code code);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_VEX_VHEv : OpCodeHandlerModRM {
    
private Register baseReg;
    
private Code codeW0;
    
private Code codeW1;
    public OpCodeHandler_VEX_VHEv(Register baseReg, Code codeW0, Code codeW1);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_VEX_VHEvIb : OpCodeHandlerModRM {
    
private Register baseReg;
    
private Code codeW0;
    
private Code codeW1;
    public OpCodeHandler_VEX_VHEvIb(Register baseReg, Code codeW0, Code codeW1);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_VEX_VHIs4W : OpCodeHandlerModRM {
    
private Register baseReg;
    
private Code code;
    public OpCodeHandler_VEX_VHIs4W(Register baseReg, Code code);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_VEX_VHIs5W : OpCodeHandlerModRM {
    
private Register baseReg;
    
private Code code;
    public OpCodeHandler_VEX_VHIs5W(Register baseReg, Code code);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_VEX_VHM : OpCodeHandlerModRM {
    
private Register baseReg;
    
private Code code;
    public OpCodeHandler_VEX_VHM(Register baseReg, Code code);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_VEX_VHW : OpCodeHandlerModRM {
    
private Register baseReg1;
    
private Register baseReg2;
    
private Register baseReg3;
    
private Code codeR;
    
private Code codeM;
    public OpCodeHandler_VEX_VHW(Register baseReg, Code codeR, Code codeM);
    public OpCodeHandler_VEX_VHW(Register baseReg, Code code);
    public OpCodeHandler_VEX_VHW(Register baseReg1, Register baseReg2, Register baseReg3, Code code);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_VEX_VHWIb : OpCodeHandlerModRM {
    
private Register baseReg1;
    
private Register baseReg2;
    
private Register baseReg3;
    
private Code code;
    public OpCodeHandler_VEX_VHWIb(Register baseReg, Code code);
    public OpCodeHandler_VEX_VHWIb(Register baseReg1, Register baseReg2, Register baseReg3, Code code);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_VEX_VHWIs4 : OpCodeHandlerModRM {
    
private Register baseReg;
    
private Code code;
    public OpCodeHandler_VEX_VHWIs4(Register baseReg, Code code);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_VEX_VHWIs5 : OpCodeHandlerModRM {
    
private Register baseReg;
    
private Code code;
    public OpCodeHandler_VEX_VHWIs5(Register baseReg, Code code);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_VEX_VK_HK_RK : OpCodeHandlerModRM {
    
private Code code;
    public OpCodeHandler_VEX_VK_HK_RK(Code code);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_VEX_VK_R : OpCodeHandlerModRM {
    
private Code code;
    
private Register gpr;
    public OpCodeHandler_VEX_VK_R(Code code, Register gpr);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_VEX_VK_R_Ib : OpCodeHandlerModRM {
    
private Code code;
    
private Register gpr;
    public OpCodeHandler_VEX_VK_R_Ib(Code code, Register gpr);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_VEX_VK_RK : OpCodeHandlerModRM {
    
private Code code;
    public OpCodeHandler_VEX_VK_RK(Code code);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_VEX_VK_RK_Ib : OpCodeHandlerModRM {
    
private Code code;
    public OpCodeHandler_VEX_VK_RK_Ib(Code code);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_VEX_VK_WK : OpCodeHandlerModRM {
    
private Code code;
    public OpCodeHandler_VEX_VK_WK(Code code);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_VEX_VM : OpCodeHandlerModRM {
    
private Register baseReg;
    
private Code code;
    public OpCodeHandler_VEX_VM(Register baseReg, Code code);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_VEX_VT : OpCodeHandlerModRM {
    
private Code code;
    public OpCodeHandler_VEX_VT(Code code);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_VEX_VT_RT_HT : OpCodeHandlerModRM {
    
private Code code;
    public OpCodeHandler_VEX_VT_RT_HT(Code code);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_VEX_VT_SIBMEM : OpCodeHandlerModRM {
    
private Code code;
    public OpCodeHandler_VEX_VT_SIBMEM(Code code);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_VEX_VW : OpCodeHandlerModRM {
    
private Register baseReg1;
    
private Register baseReg2;
    
private Code code;
    public OpCodeHandler_VEX_VW(Register baseReg, Code code);
    public OpCodeHandler_VEX_VW(Register baseReg1, Register baseReg2, Code code);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_VEX_VWH : OpCodeHandlerModRM {
    
private Register baseReg;
    
private Code code;
    public OpCodeHandler_VEX_VWH(Register baseReg, Code code);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_VEX_VWIb : OpCodeHandlerModRM {
    
private Register baseReg1;
    
private Register baseReg2;
    
private Code codeW0;
    
private Code codeW1;
    public OpCodeHandler_VEX_VWIb(Register baseReg, Code code);
    public OpCodeHandler_VEX_VWIb(Register baseReg, Code codeW0, Code codeW1);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_VEX_VX_Ev : OpCodeHandlerModRM {
    
private Code code32;
    
private Code code64;
    public OpCodeHandler_VEX_VX_Ev(Code code32, Code code64);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_VEX_VX_VSIB_HX : OpCodeHandlerModRM {
    
private Register baseReg1;
    
private Register vsibIndex;
    
private Register baseReg3;
    
private Code code;
    public OpCodeHandler_VEX_VX_VSIB_HX(Register baseReg1, Register vsibIndex, Register baseReg3, Code code);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_VEX_WHV : OpCodeHandlerModRM {
    
private Register baseReg;
    
private Code codeR;
    public OpCodeHandler_VEX_WHV(Register baseReg, Code code);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_VEX_WV : OpCodeHandlerModRM {
    
private Register baseReg1;
    
private Register baseReg2;
    
private Code code;
    public OpCodeHandler_VEX_WV(Register baseReg, Code code);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_VEX_WVIb : OpCodeHandlerModRM {
    
private Register baseReg1;
    
private Register baseReg2;
    
private Code code;
    public OpCodeHandler_VEX_WVIb(Register baseReg1, Register baseReg2, Code code);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Iced.Intel.DecoderInternal.OpCodeHandler_VEX2 : OpCodeHandlerModRM {
    
private OpCodeHandler handlerMem;
    public OpCodeHandler_VEX2(OpCodeHandler handlerMem);
    public virtual void Decode(Decoder decoder, Instruction& instruction);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Iced.Intel.DecoderInternal.OpCodeHandler_VEX3 : OpCodeHandlerModRM {
    
private OpCodeHandler handlerMem;
    public OpCodeHandler_VEX3(OpCodeHandler handlerMem);
    public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_VM : OpCodeHandlerModRM {
    
private Code code;
    public OpCodeHandler_VM(Code code);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_VN : OpCodeHandlerModRM {
    
private Code code;
    public OpCodeHandler_VN(Code code);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_VQ : OpCodeHandlerModRM {
    
private Code code;
    public OpCodeHandler_VQ(Code code);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_VRIbIb : OpCodeHandlerModRM {
    
private Code code;
    public OpCodeHandler_VRIbIb(Code code);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_VW : OpCodeHandlerModRM {
    
private Code codeR;
    
private Code codeM;
    public OpCodeHandler_VW(Code codeR, Code codeM);
    public OpCodeHandler_VW(Code code);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_VWIb : OpCodeHandlerModRM {
    
private Code codeW0;
    
private Code codeW1;
    public OpCodeHandler_VWIb(Code code);
    public OpCodeHandler_VWIb(Code codeW0, Code codeW1);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_VX_E_Ib : OpCodeHandlerModRM {
    
private Code code32;
    
private Code code64;
    public OpCodeHandler_VX_E_Ib(Code code32, Code code64);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_VX_Ev : OpCodeHandlerModRM {
    
private Code code32;
    
private Code code64;
    public OpCodeHandler_VX_Ev(Code code32, Code code64);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Iced.Intel.DecoderInternal.OpCodeHandler_W : OpCodeHandlerModRM {
    
private OpCodeHandler handlerW0;
    
private OpCodeHandler handlerW1;
    public OpCodeHandler_W(OpCodeHandler handlerW0, OpCodeHandler handlerW1);
    public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_Wbinvd : OpCodeHandler {
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_WV : OpCodeHandlerModRM {
    
private Code code;
    public OpCodeHandler_WV(Code code);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_Xb_Yb : OpCodeHandler {
    
private Code code;
    public OpCodeHandler_Xb_Yb(Code code);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_Xchg_Reg_rAX : OpCodeHandler {
    
private int index;
    
private Code[] codes;
    
private static Code[] s_codes;
    public OpCodeHandler_Xchg_Reg_rAX(int index);
    private static OpCodeHandler_Xchg_Reg_rAX();
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Iced.Intel.DecoderInternal.OpCodeHandler_XOP : OpCodeHandlerModRM {
    
private OpCodeHandler handler_reg0;
    public OpCodeHandler_XOP(OpCodeHandler handler_reg0);
    public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_Xv_Yv : OpCodeHandler {
    
private Code3 codes;
    public OpCodeHandler_Xv_Yv(Code code16, Code code32, Code code64);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_Yb_Reg : OpCodeHandler {
    
private Code code;
    
private Register reg;
    public OpCodeHandler_Yb_Reg(Code code, Register reg);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_Yb_Xb : OpCodeHandler {
    
private Code code;
    public OpCodeHandler_Yb_Xb(Code code);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_Yv_Reg : OpCodeHandler {
    
private Code3 codes;
    public OpCodeHandler_Yv_Reg(Code code16, Code code32, Code code64);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_Yv_Reg2 : OpCodeHandler {
    
private Code code16;
    
private Code code32;
    public OpCodeHandler_Yv_Reg2(Code code16, Code code32);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal class Iced.Intel.DecoderInternal.OpCodeHandler_Yv_Xv : OpCodeHandler {
    
private Code3 codes;
    public OpCodeHandler_Yv_Xv(Code code16, Code code32, Code code64);
    [NullableContextAttribute("1")]
public virtual void Decode(Decoder decoder, Instruction& instruction);
}
internal abstract class Iced.Intel.DecoderInternal.OpCodeHandlerModRM : OpCodeHandler {
}
internal abstract class Iced.Intel.DecoderInternal.OpCodeHandlerReader : object {
    public abstract virtual int ReadHandlers(TableDeserializer& deserializer, OpCodeHandler[] result, int resultIndex);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Iced.Intel.DecoderInternal.OpCodeHandlersTables_EVEX : object {
    
internal static OpCodeHandler[] Handlers_0F;
    
internal static OpCodeHandler[] Handlers_0F38;
    
internal static OpCodeHandler[] Handlers_0F3A;
    
internal static OpCodeHandler[] Handlers_MAP5;
    
internal static OpCodeHandler[] Handlers_MAP6;
    
private static int MaxIdNames;
    
private static UInt32 Handlers_0FIndex;
    
private static UInt32 Handlers_0F38Index;
    
private static UInt32 Handlers_0F3AIndex;
    
private static UInt32 Handlers_MAP5Index;
    
private static UInt32 Handlers_MAP6Index;
    private static OpCodeHandlersTables_EVEX();
    private static ReadOnlySpan`1<byte> GetSerializedTables();
}
internal static class Iced.Intel.DecoderInternal.OpCodeHandlersTables_Legacy : object {
    [NullableAttribute("1")]

internal static OpCodeHandler[] Handlers_MAP0;
    
private static int MaxIdNames;
    
private static UInt32 Handlers_MAP0Index;
    private static OpCodeHandlersTables_Legacy();
    private static ReadOnlySpan`1<byte> GetSerializedTables();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Iced.Intel.DecoderInternal.OpCodeHandlersTables_VEX : object {
    
internal static OpCodeHandler[] Handlers_0F;
    
internal static OpCodeHandler[] Handlers_0F38;
    
internal static OpCodeHandler[] Handlers_0F3A;
    
private static int MaxIdNames;
    
private static UInt32 Handlers_MAP0Index;
    
private static UInt32 Handlers_0FIndex;
    
private static UInt32 Handlers_0F38Index;
    
private static UInt32 Handlers_0F3AIndex;
    private static OpCodeHandlersTables_VEX();
    private static ReadOnlySpan`1<byte> GetSerializedTables();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Iced.Intel.DecoderInternal.OpCodeHandlersTables_XOP : object {
    
internal static OpCodeHandler[] Handlers_MAP8;
    
internal static OpCodeHandler[] Handlers_MAP9;
    
internal static OpCodeHandler[] Handlers_MAP10;
    
private static int MaxIdNames;
    
private static UInt32 Handlers_MAP8Index;
    
private static UInt32 Handlers_MAP9Index;
    
private static UInt32 Handlers_MAP10Index;
    private static OpCodeHandlersTables_XOP();
    private static ReadOnlySpan`1<byte> GetSerializedTables();
}
internal enum Iced.Intel.DecoderInternal.SerializedDataKind : Enum {
    
public byte value__;
    
public static SerializedDataKind HandlerReference;
    
public static SerializedDataKind ArrayReference;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
internal class Iced.Intel.DecoderInternal.TableDeserializer : ValueType {
    
private DataReader reader;
    
private OpCodeHandlerReader handlerReader;
    
private List`1<HandlerInfo> idToHandler;
    
private OpCodeHandler[] handlerArray;
    [NullableContextAttribute("0")]
public TableDeserializer(OpCodeHandlerReader handlerReader, int maxIds, ReadOnlySpan`1<byte> data);
    public void Deserialize();
    public LegacyOpCodeHandlerKind ReadLegacyOpCodeHandlerKind();
    public VexOpCodeHandlerKind ReadVexOpCodeHandlerKind();
    public EvexOpCodeHandlerKind ReadEvexOpCodeHandlerKind();
    public Code ReadCode();
    public Register ReadRegister();
    public DecoderOptions ReadDecoderOptions();
    public HandlerFlags ReadHandlerFlags();
    public LegacyHandlerFlags ReadLegacyHandlerFlags();
    public TupleType ReadTupleType();
    public bool ReadBoolean();
    public int ReadInt32();
    public OpCodeHandler ReadHandler();
    [NullableContextAttribute("2")]
public OpCodeHandler ReadHandlerOrNull();
    public OpCodeHandler[] ReadHandlers(int count);
    public OpCodeHandler ReadHandlerReference();
    public OpCodeHandler[] ReadArrayReference(UInt32 kind);
    public OpCodeHandler[] GetTable(UInt32 index);
}
internal enum Iced.Intel.DecoderInternal.VexOpCodeHandlerKind : Enum {
    
public byte value__;
    
public static VexOpCodeHandlerKind Invalid;
    
public static VexOpCodeHandlerKind Invalid2;
    
public static VexOpCodeHandlerKind Dup;
    
public static VexOpCodeHandlerKind Invalid_NoModRM;
    
public static VexOpCodeHandlerKind Bitness_DontReadModRM;
    
public static VexOpCodeHandlerKind HandlerReference;
    
public static VexOpCodeHandlerKind ArrayReference;
    
public static VexOpCodeHandlerKind RM;
    
public static VexOpCodeHandlerKind Group;
    
public static VexOpCodeHandlerKind W;
    
public static VexOpCodeHandlerKind MandatoryPrefix2_1;
    
public static VexOpCodeHandlerKind MandatoryPrefix2_4;
    
public static VexOpCodeHandlerKind MandatoryPrefix2_NoModRM;
    
public static VexOpCodeHandlerKind VectorLength_NoModRM;
    
public static VexOpCodeHandlerKind VectorLength;
    
public static VexOpCodeHandlerKind Ed_V_Ib;
    
public static VexOpCodeHandlerKind Ev_VX;
    
public static VexOpCodeHandlerKind G_VK;
    
public static VexOpCodeHandlerKind Gv_Ev_Gv;
    
public static VexOpCodeHandlerKind Gv_Ev_Ib;
    
public static VexOpCodeHandlerKind Gv_Ev_Id;
    
public static VexOpCodeHandlerKind Gv_GPR_Ib;
    
public static VexOpCodeHandlerKind Gv_Gv_Ev;
    
public static VexOpCodeHandlerKind Gv_RX;
    
public static VexOpCodeHandlerKind Gv_W;
    
public static VexOpCodeHandlerKind GvM_VX_Ib;
    
public static VexOpCodeHandlerKind HRIb;
    
public static VexOpCodeHandlerKind Hv_Ed_Id;
    
public static VexOpCodeHandlerKind Hv_Ev;
    
public static VexOpCodeHandlerKind M;
    
public static VexOpCodeHandlerKind MHV;
    
public static VexOpCodeHandlerKind M_VK;
    
public static VexOpCodeHandlerKind MV;
    
public static VexOpCodeHandlerKind rDI_VX_RX;
    
public static VexOpCodeHandlerKind RdRq;
    
public static VexOpCodeHandlerKind Simple;
    
public static VexOpCodeHandlerKind VHEv;
    
public static VexOpCodeHandlerKind VHEvIb;
    
public static VexOpCodeHandlerKind VHIs4W;
    
public static VexOpCodeHandlerKind VHIs5W;
    
public static VexOpCodeHandlerKind VHM;
    
public static VexOpCodeHandlerKind VHW_2;
    
public static VexOpCodeHandlerKind VHW_3;
    
public static VexOpCodeHandlerKind VHW_4;
    
public static VexOpCodeHandlerKind VHWIb_2;
    
public static VexOpCodeHandlerKind VHWIb_4;
    
public static VexOpCodeHandlerKind VHWIs4;
    
public static VexOpCodeHandlerKind VHWIs5;
    
public static VexOpCodeHandlerKind VK_HK_RK;
    
public static VexOpCodeHandlerKind VK_R;
    
public static VexOpCodeHandlerKind VK_RK;
    
public static VexOpCodeHandlerKind VK_RK_Ib;
    
public static VexOpCodeHandlerKind VK_WK;
    
public static VexOpCodeHandlerKind VM;
    
public static VexOpCodeHandlerKind VW_2;
    
public static VexOpCodeHandlerKind VW_3;
    
public static VexOpCodeHandlerKind VWH;
    
public static VexOpCodeHandlerKind VWIb_2;
    
public static VexOpCodeHandlerKind VWIb_3;
    
public static VexOpCodeHandlerKind VX_Ev;
    
public static VexOpCodeHandlerKind VX_VSIB_HX;
    
public static VexOpCodeHandlerKind WHV;
    
public static VexOpCodeHandlerKind WV;
    
public static VexOpCodeHandlerKind WVIb;
    
public static VexOpCodeHandlerKind VT_SIBMEM;
    
public static VexOpCodeHandlerKind SIBMEM_VT;
    
public static VexOpCodeHandlerKind VT;
    
public static VexOpCodeHandlerKind VT_RT_HT;
    
public static VexOpCodeHandlerKind Group8x64;
    
public static VexOpCodeHandlerKind Bitness;
    
public static VexOpCodeHandlerKind Null;
    
public static VexOpCodeHandlerKind Options_DontReadModRM;
    
public static VexOpCodeHandlerKind Gq_HK_RK;
    
public static VexOpCodeHandlerKind VK_R_Ib;
    
public static VexOpCodeHandlerKind Gv_Ev;
    
public static VexOpCodeHandlerKind Ev;
    
public static VexOpCodeHandlerKind K_Jb;
    
public static VexOpCodeHandlerKind K_Jz;
}
internal class Iced.Intel.DecoderInternal.VexOpCodeHandlerReader : OpCodeHandlerReader {
    public virtual int ReadHandlers(TableDeserializer& deserializer, OpCodeHandler[] result, int resultIndex);
}
[FlagsAttribute]
internal enum Iced.Intel.DecoderOptions : Enum {
    
public UInt32 value__;
    
public static DecoderOptions None;
    
public static DecoderOptions NoInvalidCheck;
    
public static DecoderOptions AMD;
    
public static DecoderOptions ForceReservedNop;
    
public static DecoderOptions Umov;
    
public static DecoderOptions Xbts;
    
public static DecoderOptions Cmpxchg486A;
    
public static DecoderOptions OldFpu;
    
public static DecoderOptions Pcommit;
    
public static DecoderOptions Loadall286;
    
public static DecoderOptions Loadall386;
    
public static DecoderOptions Cl1invmb;
    
public static DecoderOptions MovTr;
    
public static DecoderOptions Jmpe;
    
public static DecoderOptions NoPause;
    
public static DecoderOptions NoWbnoinvd;
    
public static DecoderOptions Udbg;
    
public static DecoderOptions NoMPFX_0FBC;
    
public static DecoderOptions NoMPFX_0FBD;
    
public static DecoderOptions NoLahfSahf64;
    
public static DecoderOptions MPX;
    
public static DecoderOptions Cyrix;
    
public static DecoderOptions Cyrix_SMINT_0F7E;
    
public static DecoderOptions Cyrix_DMI;
    
public static DecoderOptions ALTINST;
    
public static DecoderOptions KNC;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Iced.Intel.Encoder : object {
    
private static UInt32[] s_immSizes;
    
internal UInt32 Internal_PreventVEX2;
    
internal UInt32 Internal_VEX_WIG_LIG;
    
internal UInt32 Internal_VEX_LIG;
    
internal UInt32 Internal_EVEX_WIG;
    
internal UInt32 Internal_EVEX_LIG;
    
internal static string ERROR_ONLY_1632_BIT_MODE;
    
internal static string ERROR_ONLY_64_BIT_MODE;
    
private CodeWriter writer;
    
private int bitness;
    
private OpCodeHandler[] handlers;
    
private UInt32[] immSizes;
    
private ulong currentRip;
    
private string errorMessage;
    
private OpCodeHandler handler;
    
private UInt32 eip;
    
private UInt32 displAddr;
    
private UInt32 immAddr;
    
internal UInt32 Immediate;
    
internal UInt32 ImmediateHi;
    
private UInt32 Displ;
    
private UInt32 DisplHi;
    
private EncoderFlags opSize16Flags;
    
private EncoderFlags opSize32Flags;
    
private EncoderFlags adrSize16Flags;
    
private EncoderFlags adrSize32Flags;
    
internal UInt32 OpCode;
    
internal EncoderFlags EncoderFlags;
    
private DisplSize DisplSize;
    
internal ImmSize ImmSize;
    
private byte ModRM;
    
private byte Sib;
    
public bool PreventVEX2 { get; public set; }
    
public UInt32 VEX_WIG { get; public set; }
    
public UInt32 VEX_LIG { get; public set; }
    
public UInt32 EVEX_WIG { get; public set; }
    
public UInt32 EVEX_LIG { get; public set; }
    
public int Bitness { get; }
    [NullableAttribute("2")]

unknown string ErrorMessage {internal set; }
    [NullableAttribute("0")]

private static ReadOnlySpan`1<byte> SegmentOverrides { get; }
    private Encoder(CodeWriter writer, int bitness);
    private static Encoder();
    public bool get_PreventVEX2();
    public void set_PreventVEX2(bool value);
    public UInt32 get_VEX_WIG();
    public void set_VEX_WIG(UInt32 value);
    public UInt32 get_VEX_LIG();
    public void set_VEX_LIG(UInt32 value);
    public UInt32 get_EVEX_WIG();
    public void set_EVEX_WIG(UInt32 value);
    public UInt32 get_EVEX_LIG();
    public void set_EVEX_LIG(UInt32 value);
    public int get_Bitness();
    public static Encoder Create(int bitness, CodeWriter writer);
    public UInt32 Encode(Instruction& instruction, ulong rip);
    private static void ThrowEncoderException(Instruction& instruction, string errorMessage);
    [NullableContextAttribute("2")]
public bool TryEncode(Instruction& instruction, ulong rip, UInt32& encodedLength, String& errorMessage);
    [NullableContextAttribute("2")]
internal void set_ErrorMessage(string value);
    internal bool Verify(int operand, OpKind expected, OpKind actual);
    internal bool Verify(int operand, Register expected, Register actual);
    internal bool Verify(int operand, Register register, Register regLo, Register regHi);
    internal void AddBranch(OpKind opKind, int immSize, Instruction& instruction, int operand);
    internal void AddBranchX(int immSize, Instruction& instruction, int operand);
    internal void AddBranchDisp(int displSize, Instruction& instruction, int operand);
    internal void AddFarBranch(Instruction& instruction, int operand, int size);
    internal void SetAddrSize(int regSize);
    internal void AddAbsMem(Instruction& instruction, int operand);
    internal void AddModRMRegister(Instruction& instruction, int operand, Register regLo, Register regHi);
    internal void AddReg(Instruction& instruction, int operand, Register regLo, Register regHi);
    internal void AddRegOrMem(Instruction& instruction, int operand, Register regLo, Register regHi, bool allowMemOp, bool allowRegOp);
    internal void AddRegOrMem(Instruction& instruction, int operand, Register regLo, Register regHi, Register vsibIndexRegLo, Register vsibIndexRegHi, bool allowMemOp, bool allowRegOp);
    private static int GetRegisterOpSize(Instruction& instruction);
    private bool TryConvertToDisp8N(Instruction& instruction, int displ, SByte& compressedValue);
    private void AddMemOp16(Instruction& instruction, int operand);
    private void AddMemOp(Instruction& instruction, int operand, int addrSize, Register vsibIndexRegLo, Register vsibIndexRegHi);
    private static ReadOnlySpan`1<byte> get_SegmentOverrides();
    internal void WritePrefixes(Instruction& instruction, bool canWriteF3);
    private void WriteModRM();
    private void WriteImmediate();
    public void WriteByte(byte value);
    internal void WriteByteInternal(UInt32 value);
    public ConstantOffsets GetConstantOffsets();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Iced.Intel.EncoderException : Exception {
    [CompilerGeneratedAttribute]

private Instruction <Instruction>k__BackingField;
    
public Instruction Instruction { get; }
    public EncoderException(string message, Instruction& instruction);
    protected EncoderException(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
public Instruction get_Instruction();
}
internal class Iced.Intel.EncoderInternal.D3nowHandler : OpCodeHandler {
    
private static Op[] operands;
    
private UInt32 immediate;
    public D3nowHandler(EncFlags2 encFlags2, EncFlags3 encFlags3);
    private static D3nowHandler();
    [NullableContextAttribute("1")]
public virtual void Encode(Encoder encoder, Instruction& modreq(System.Runtime.InteropServices.InAttribute) instruction);
}
internal class Iced.Intel.EncoderInternal.DeclareDataHandler : OpCodeHandler {
    
private int elemLength;
    
private int maxLength;
    public DeclareDataHandler(Code code);
    [NullableContextAttribute("1")]
public virtual void Encode(Encoder encoder, Instruction& modreq(System.Runtime.InteropServices.InAttribute) instruction);
}
internal enum Iced.Intel.EncoderInternal.DisplSize : Enum {
    
public int value__;
    
public static DisplSize None;
    
public static DisplSize Size1;
    
public static DisplSize Size2;
    
public static DisplSize Size4;
    
public static DisplSize Size8;
    
public static DisplSize RipRelSize4_Target32;
    
public static DisplSize RipRelSize4_Target64;
}
[FlagsAttribute]
internal enum Iced.Intel.EncoderInternal.EncFlags1 : Enum {
    
public UInt32 value__;
    
public static EncFlags1 None;
    
public static EncFlags1 Legacy_OpMask;
    
public static EncFlags1 Legacy_Op0Shift;
    
public static EncFlags1 Legacy_Op1Shift;
    
public static EncFlags1 Legacy_Op2Shift;
    
public static EncFlags1 Legacy_Op3Shift;
    
public static EncFlags1 VEX_OpMask;
    
public static EncFlags1 VEX_Op0Shift;
    
public static EncFlags1 VEX_Op1Shift;
    
public static EncFlags1 VEX_Op2Shift;
    
public static EncFlags1 VEX_Op3Shift;
    
public static EncFlags1 VEX_Op4Shift;
    
public static EncFlags1 XOP_OpMask;
    
public static EncFlags1 XOP_Op0Shift;
    
public static EncFlags1 XOP_Op1Shift;
    
public static EncFlags1 XOP_Op2Shift;
    
public static EncFlags1 XOP_Op3Shift;
    
public static EncFlags1 EVEX_OpMask;
    
public static EncFlags1 EVEX_Op0Shift;
    
public static EncFlags1 EVEX_Op1Shift;
    
public static EncFlags1 EVEX_Op2Shift;
    
public static EncFlags1 EVEX_Op3Shift;
    
public static EncFlags1 MVEX_OpMask;
    
public static EncFlags1 MVEX_Op0Shift;
    
public static EncFlags1 MVEX_Op1Shift;
    
public static EncFlags1 MVEX_Op2Shift;
    
public static EncFlags1 MVEX_Op3Shift;
    
public static EncFlags1 IgnoresRoundingControl;
    
public static EncFlags1 AmdLockRegBit;
}
[FlagsAttribute]
internal enum Iced.Intel.EncoderInternal.EncFlags2 : Enum {
    
public UInt32 value__;
    
public static EncFlags2 None;
    
public static EncFlags2 OpCodeShift;
    
public static EncFlags2 OpCodeIs2Bytes;
    
public static EncFlags2 TableShift;
    
public static EncFlags2 TableMask;
    
public static EncFlags2 MandatoryPrefixShift;
    
public static EncFlags2 MandatoryPrefixMask;
    
public static EncFlags2 WBitShift;
    
public static EncFlags2 WBitMask;
    
public static EncFlags2 LBitShift;
    
public static EncFlags2 LBitMask;
    
public static EncFlags2 GroupIndexShift;
    
public static EncFlags2 GroupIndexMask;
    
public static EncFlags2 HasMandatoryPrefix;
    
public static EncFlags2 HasGroupIndex;
}
[FlagsAttribute]
internal enum Iced.Intel.EncoderInternal.EncFlags3 : Enum {
    
public UInt32 value__;
    
public static EncFlags3 None;
    
public static EncFlags3 EncodingShift;
    
public static EncFlags3 EncodingMask;
    
public static EncFlags3 OperandSizeShift;
    
public static EncFlags3 OperandSizeMask;
    
public static EncFlags3 AddressSizeShift;
    
public static EncFlags3 AddressSizeMask;
    
public static EncFlags3 TupleTypeShift;
    
public static EncFlags3 TupleTypeMask;
    
public static EncFlags3 DefaultOpSize64;
    
public static EncFlags3 HasRmGroupIndex;
    
public static EncFlags3 IntelForceOpSize64;
    
public static EncFlags3 Fwait;
    
public static EncFlags3 Bit16or32;
    
public static EncFlags3 Bit64;
    
public static EncFlags3 Lock;
    
public static EncFlags3 Xacquire;
    
public static EncFlags3 Xrelease;
    
public static EncFlags3 Rep;
    
public static EncFlags3 Repne;
    
public static EncFlags3 Bnd;
    
public static EncFlags3 HintTaken;
    
public static EncFlags3 Notrack;
    
public static EncFlags3 Broadcast;
    
public static EncFlags3 RoundingControl;
    
public static EncFlags3 SuppressAllExceptions;
    
public static EncFlags3 OpMaskRegister;
    
public static EncFlags3 ZeroingMasking;
    
public static EncFlags3 RequireOpMaskRegister;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Iced.Intel.EncoderInternal.EncoderData : object {
    
internal static UInt32[] EncFlags1;
    
internal static UInt32[] EncFlags2;
    
internal static UInt32[] EncFlags3;
    private static EncoderData();
    private static UInt32[] GetEncFlags1();
    private static UInt32[] GetEncFlags2();
    private static UInt32[] GetEncFlags3();
}
[FlagsAttribute]
internal enum Iced.Intel.EncoderInternal.EncoderFlags : Enum {
    
public UInt32 value__;
    
public static EncoderFlags None;
    
public static EncoderFlags B;
    
public static EncoderFlags X;
    
public static EncoderFlags R;
    
public static EncoderFlags W;
    
public static EncoderFlags ModRM;
    
public static EncoderFlags Sib;
    
public static EncoderFlags REX;
    
public static EncoderFlags P66;
    
public static EncoderFlags P67;
    
public static EncoderFlags R2;
    
public static EncoderFlags Broadcast;
    
public static EncoderFlags HighLegacy8BitRegs;
    
public static EncoderFlags Displ;
    
public static EncoderFlags PF0;
    
public static EncoderFlags RegIsMemory;
    
public static EncoderFlags MustUseSib;
    
public static EncoderFlags VvvvvShift;
    
public static EncoderFlags VvvvvMask;
}
internal class Iced.Intel.EncoderInternal.EvexHandler : OpCodeHandler {
    
private WBit wbit;
    
private TupleType tupleType;
    
private UInt32 table;
    
private UInt32 p1Bits;
    
private UInt32 llBits;
    
private UInt32 mask_W;
    
private UInt32 mask_LL;
    
private static TryConvertToDisp8N tryConvertToDisp8N;
    public EvexHandler(EncFlags1 encFlags1, EncFlags2 encFlags2, EncFlags3 encFlags3);
    private static EvexHandler();
    private static Op[] CreateOps(EncFlags1 encFlags1);
    [NullableContextAttribute("1")]
public virtual void Encode(Encoder encoder, Instruction& modreq(System.Runtime.InteropServices.InAttribute) instruction);
}
internal enum Iced.Intel.EncoderInternal.EvexOpCodeTable : Enum {
    
public int value__;
    
public static EvexOpCodeTable MAP0F;
    
public static EvexOpCodeTable MAP0F38;
    
public static EvexOpCodeTable MAP0F3A;
    
public static EvexOpCodeTable MAP5;
    
public static EvexOpCodeTable MAP6;
}
internal enum Iced.Intel.EncoderInternal.ImmSize : Enum {
    
public int value__;
    
public static ImmSize None;
    
public static ImmSize Size1;
    
public static ImmSize Size2;
    
public static ImmSize Size4;
    
public static ImmSize Size8;
    
public static ImmSize Size2_1;
    
public static ImmSize Size1_1;
    
public static ImmSize Size2_2;
    
public static ImmSize Size4_2;
    
public static ImmSize RipRelSize1_Target16;
    
public static ImmSize RipRelSize1_Target32;
    
public static ImmSize RipRelSize1_Target64;
    
public static ImmSize RipRelSize2_Target16;
    
public static ImmSize RipRelSize2_Target32;
    
public static ImmSize RipRelSize2_Target64;
    
public static ImmSize RipRelSize4_Target32;
    
public static ImmSize RipRelSize4_Target64;
    
public static ImmSize SizeIbReg;
    
public static ImmSize Size1OpCode;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Iced.Intel.EncoderInternal.InvalidHandler : OpCodeHandler {
    
internal static string ERROR_MESSAGE;
    public virtual void Encode(Encoder encoder, Instruction& modreq(System.Runtime.InteropServices.InAttribute) instruction);
}
internal enum Iced.Intel.EncoderInternal.LBit : Enum {
    
public UInt32 value__;
    
public static LBit L0;
    
public static LBit L1;
    
public static LBit LIG;
    
public static LBit LZ;
    
public static LBit L128;
    
public static LBit L256;
    
public static LBit L512;
}
internal class Iced.Intel.EncoderInternal.LegacyHandler : OpCodeHandler {
    
private UInt32 tableByte1;
    
private UInt32 tableByte2;
    
private UInt32 mandatoryPrefix;
    public LegacyHandler(EncFlags1 encFlags1, EncFlags2 encFlags2, EncFlags3 encFlags3);
    private static Op[] CreateOps(EncFlags1 encFlags1);
    [NullableContextAttribute("1")]
public virtual void Encode(Encoder encoder, Instruction& modreq(System.Runtime.InteropServices.InAttribute) instruction);
}
internal enum Iced.Intel.EncoderInternal.LegacyOpCodeTable : Enum {
    
public int value__;
    
public static LegacyOpCodeTable MAP0;
    
public static LegacyOpCodeTable MAP0F;
    
public static LegacyOpCodeTable MAP0F38;
    
public static LegacyOpCodeTable MAP0F3A;
}
internal enum Iced.Intel.EncoderInternal.MvexOpCodeTable : Enum {
    
public int value__;
    
public static MvexOpCodeTable MAP0F;
    
public static MvexOpCodeTable MAP0F38;
    
public static MvexOpCodeTable MAP0F3A;
}
internal abstract class Iced.Intel.EncoderInternal.Op : object {
    [NullableContextAttribute("1")]
public abstract virtual void Encode(Encoder encoder, Instruction& modreq(System.Runtime.InteropServices.InAttribute) instruction, int operand);
    public virtual OpKind GetImmediateOpKind();
    public virtual OpKind GetNearBranchOpKind();
    public virtual OpKind GetFarBranchOpKind();
}
internal class Iced.Intel.EncoderInternal.OpA : Op {
    
private int size;
    public OpA(int size);
    [NullableContextAttribute("1")]
public virtual void Encode(Encoder encoder, Instruction& modreq(System.Runtime.InteropServices.InAttribute) instruction, int operand);
    public virtual OpKind GetFarBranchOpKind();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Iced.Intel.EncoderInternal.OpCodeHandler : object {
    
internal UInt32 OpCode;
    
internal bool Is2ByteOpCode;
    
internal int GroupIndex;
    
internal int RmGroupIndex;
    
internal bool IsSpecialInstr;
    
internal EncFlags3 EncFlags3;
    
internal CodeSize OpSize;
    
internal CodeSize AddrSize;
    [NullableAttribute("2")]

internal TryConvertToDisp8N TryConvertToDisp8N;
    
internal Op[] Operands;
    protected OpCodeHandler(EncFlags2 encFlags2, EncFlags3 encFlags3, bool isSpecialInstr, TryConvertToDisp8N tryConvertToDisp8N, Op[] operands);
    protected static UInt32 GetOpCode(EncFlags2 encFlags2);
    public abstract virtual void Encode(Encoder encoder, Instruction& modreq(System.Runtime.InteropServices.InAttribute) instruction);
}
internal static class Iced.Intel.EncoderInternal.OpCodeHandlers : object {
    [NullableAttribute("1")]

public static OpCodeHandler[] Handlers;
    private static OpCodeHandlers();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Iced.Intel.EncoderInternal.OpHandlerData : object {
    
public static Op[] LegacyOps;
    
public static Op[] VexOps;
    
public static Op[] XopOps;
    
public static Op[] EvexOps;
    private static OpHandlerData();
}
internal class Iced.Intel.EncoderInternal.OpHx : Op {
    
private Register regLo;
    
private Register regHi;
    public OpHx(Register regLo, Register regHi);
    [NullableContextAttribute("1")]
public virtual void Encode(Encoder encoder, Instruction& modreq(System.Runtime.InteropServices.InAttribute) instruction, int operand);
}
internal class Iced.Intel.EncoderInternal.OpI4 : Op {
    [NullableContextAttribute("1")]
public virtual void Encode(Encoder encoder, Instruction& modreq(System.Runtime.InteropServices.InAttribute) instruction, int operand);
    public virtual OpKind GetImmediateOpKind();
}
internal class Iced.Intel.EncoderInternal.OpIb : Op {
    
private OpKind opKind;
    public OpIb(OpKind opKind);
    [NullableContextAttribute("1")]
public virtual void Encode(Encoder encoder, Instruction& modreq(System.Runtime.InteropServices.InAttribute) instruction, int operand);
    public virtual OpKind GetImmediateOpKind();
}
internal class Iced.Intel.EncoderInternal.OpId : Op {
    
private OpKind opKind;
    public OpId(OpKind opKind);
    [NullableContextAttribute("1")]
public virtual void Encode(Encoder encoder, Instruction& modreq(System.Runtime.InteropServices.InAttribute) instruction, int operand);
    public virtual OpKind GetImmediateOpKind();
}
internal class Iced.Intel.EncoderInternal.OpImm : Op {
    
private byte value;
    public OpImm(byte value);
    [NullableContextAttribute("1")]
public virtual void Encode(Encoder encoder, Instruction& modreq(System.Runtime.InteropServices.InAttribute) instruction, int operand);
    public virtual OpKind GetImmediateOpKind();
}
internal class Iced.Intel.EncoderInternal.OpIq : Op {
    [NullableContextAttribute("1")]
public virtual void Encode(Encoder encoder, Instruction& modreq(System.Runtime.InteropServices.InAttribute) instruction, int operand);
    public virtual OpKind GetImmediateOpKind();
}
internal class Iced.Intel.EncoderInternal.OpIsX : Op {
    
private Register regLo;
    
private Register regHi;
    public OpIsX(Register regLo, Register regHi);
    [NullableContextAttribute("1")]
public virtual void Encode(Encoder encoder, Instruction& modreq(System.Runtime.InteropServices.InAttribute) instruction, int operand);
}
internal class Iced.Intel.EncoderInternal.OpIw : Op {
    [NullableContextAttribute("1")]
public virtual void Encode(Encoder encoder, Instruction& modreq(System.Runtime.InteropServices.InAttribute) instruction, int operand);
    public virtual OpKind GetImmediateOpKind();
}
internal class Iced.Intel.EncoderInternal.OpJ : Op {
    
private OpKind opKind;
    
private int immSize;
    public OpJ(OpKind opKind, int immSize);
    [NullableContextAttribute("1")]
public virtual void Encode(Encoder encoder, Instruction& modreq(System.Runtime.InteropServices.InAttribute) instruction, int operand);
    public virtual OpKind GetNearBranchOpKind();
}
internal class Iced.Intel.EncoderInternal.OpJdisp : Op {
    
private int displSize;
    public OpJdisp(int displSize);
    [NullableContextAttribute("1")]
public virtual void Encode(Encoder encoder, Instruction& modreq(System.Runtime.InteropServices.InAttribute) instruction, int operand);
    public virtual OpKind GetNearBranchOpKind();
}
internal class Iced.Intel.EncoderInternal.OpJx : Op {
    
private int immSize;
    public OpJx(int immSize);
    [NullableContextAttribute("1")]
public virtual void Encode(Encoder encoder, Instruction& modreq(System.Runtime.InteropServices.InAttribute) instruction, int operand);
    public virtual OpKind GetNearBranchOpKind();
}
internal class Iced.Intel.EncoderInternal.OpModRM_reg : Op {
    
private Register regLo;
    
private Register regHi;
    public OpModRM_reg(Register regLo, Register regHi);
    [NullableContextAttribute("1")]
public virtual void Encode(Encoder encoder, Instruction& modreq(System.Runtime.InteropServices.InAttribute) instruction, int operand);
}
internal class Iced.Intel.EncoderInternal.OpModRM_reg_mem : Op {
    
private Register regLo;
    
private Register regHi;
    public OpModRM_reg_mem(Register regLo, Register regHi);
    [NullableContextAttribute("1")]
public virtual void Encode(Encoder encoder, Instruction& modreq(System.Runtime.InteropServices.InAttribute) instruction, int operand);
}
internal class Iced.Intel.EncoderInternal.OpModRM_regF0 : Op {
    
private Register regLo;
    
private Register regHi;
    public OpModRM_regF0(Register regLo, Register regHi);
    [NullableContextAttribute("1")]
public virtual void Encode(Encoder encoder, Instruction& modreq(System.Runtime.InteropServices.InAttribute) instruction, int operand);
}
internal class Iced.Intel.EncoderInternal.OpModRM_rm : Op {
    
private Register regLo;
    
private Register regHi;
    public OpModRM_rm(Register regLo, Register regHi);
    [NullableContextAttribute("1")]
public virtual void Encode(Encoder encoder, Instruction& modreq(System.Runtime.InteropServices.InAttribute) instruction, int operand);
}
internal class Iced.Intel.EncoderInternal.OpModRM_rm_mem_only : Op {
    
private bool mustUseSib;
    public OpModRM_rm_mem_only(bool mustUseSib);
    [NullableContextAttribute("1")]
public virtual void Encode(Encoder encoder, Instruction& modreq(System.Runtime.InteropServices.InAttribute) instruction, int operand);
}
internal class Iced.Intel.EncoderInternal.OpModRM_rm_reg_only : Op {
    
private Register regLo;
    
private Register regHi;
    public OpModRM_rm_reg_only(Register regLo, Register regHi);
    [NullableContextAttribute("1")]
public virtual void Encode(Encoder encoder, Instruction& modreq(System.Runtime.InteropServices.InAttribute) instruction, int operand);
}
internal class Iced.Intel.EncoderInternal.OpMRBX : Op {
    [NullableContextAttribute("1")]
public virtual void Encode(Encoder encoder, Instruction& modreq(System.Runtime.InteropServices.InAttribute) instruction, int operand);
}
internal class Iced.Intel.EncoderInternal.OpO : Op {
    [NullableContextAttribute("1")]
public virtual void Encode(Encoder encoder, Instruction& modreq(System.Runtime.InteropServices.InAttribute) instruction, int operand);
}
internal class Iced.Intel.EncoderInternal.OprDI : Op {
    private static int GetRegSize(OpKind opKind);
    [NullableContextAttribute("1")]
public virtual void Encode(Encoder encoder, Instruction& modreq(System.Runtime.InteropServices.InAttribute) instruction, int operand);
}
internal class Iced.Intel.EncoderInternal.OpReg : Op {
    
private Register register;
    public OpReg(Register register);
    [NullableContextAttribute("1")]
public virtual void Encode(Encoder encoder, Instruction& modreq(System.Runtime.InteropServices.InAttribute) instruction, int operand);
}
internal class Iced.Intel.EncoderInternal.OpRegEmbed8 : Op {
    
private Register regLo;
    
private Register regHi;
    public OpRegEmbed8(Register regLo, Register regHi);
    [NullableContextAttribute("1")]
public virtual void Encode(Encoder encoder, Instruction& modreq(System.Runtime.InteropServices.InAttribute) instruction, int operand);
}
internal class Iced.Intel.EncoderInternal.OpRegSTi : Op {
    [NullableContextAttribute("1")]
public virtual void Encode(Encoder encoder, Instruction& modreq(System.Runtime.InteropServices.InAttribute) instruction, int operand);
}
internal class Iced.Intel.EncoderInternal.OpVsib : Op {
    
private Register vsibIndexRegLo;
    
private Register vsibIndexRegHi;
    public OpVsib(Register regLo, Register regHi);
    [NullableContextAttribute("1")]
public virtual void Encode(Encoder encoder, Instruction& modreq(System.Runtime.InteropServices.InAttribute) instruction, int operand);
}
internal class Iced.Intel.EncoderInternal.OpX : Op {
    internal static int GetXRegSize(OpKind opKind);
    internal static int GetYRegSize(OpKind opKind);
    [NullableContextAttribute("1")]
public virtual void Encode(Encoder encoder, Instruction& modreq(System.Runtime.InteropServices.InAttribute) instruction, int operand);
}
internal class Iced.Intel.EncoderInternal.OpY : Op {
    [NullableContextAttribute("1")]
public virtual void Encode(Encoder encoder, Instruction& modreq(System.Runtime.InteropServices.InAttribute) instruction, int operand);
}
internal class Iced.Intel.EncoderInternal.TryConvertToDisp8N : MulticastDelegate {
    public TryConvertToDisp8N(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual bool Invoke(Encoder encoder, OpCodeHandler handler, Instruction& modreq(System.Runtime.InteropServices.InAttribute) instruction, int displ, SByte& compressedValue);
    public virtual IAsyncResult BeginInvoke(Encoder encoder, OpCodeHandler handler, Instruction& modreq(System.Runtime.InteropServices.InAttribute) instruction, int displ, SByte& compressedValue, AsyncCallback callback, object object);
    public virtual bool EndInvoke(Instruction& modreq(System.Runtime.InteropServices.InAttribute) instruction, SByte& compressedValue, IAsyncResult result);
}
internal class Iced.Intel.EncoderInternal.VexHandler : OpCodeHandler {
    
private UInt32 table;
    
private UInt32 lastByte;
    
private UInt32 mask_W_L;
    
private UInt32 mask_L;
    
private UInt32 W1;
    public VexHandler(EncFlags1 encFlags1, EncFlags2 encFlags2, EncFlags3 encFlags3);
    private static Op[] CreateOps(EncFlags1 encFlags1);
    [NullableContextAttribute("1")]
public virtual void Encode(Encoder encoder, Instruction& modreq(System.Runtime.InteropServices.InAttribute) instruction);
}
internal enum Iced.Intel.EncoderInternal.VexOpCodeTable : Enum {
    
public int value__;
    
public static VexOpCodeTable MAP0;
    
public static VexOpCodeTable MAP0F;
    
public static VexOpCodeTable MAP0F38;
    
public static VexOpCodeTable MAP0F3A;
}
internal enum Iced.Intel.EncoderInternal.WBit : Enum {
    
public UInt32 value__;
    
public static WBit W0;
    
public static WBit W1;
    
public static WBit WIG;
    
public static WBit WIG32;
}
internal class Iced.Intel.EncoderInternal.XopHandler : OpCodeHandler {
    
private UInt32 table;
    
private UInt32 lastByte;
    public XopHandler(EncFlags1 encFlags1, EncFlags2 encFlags2, EncFlags3 encFlags3);
    private static Op[] CreateOps(EncFlags1 encFlags1);
    [NullableContextAttribute("1")]
public virtual void Encode(Encoder encoder, Instruction& modreq(System.Runtime.InteropServices.InAttribute) instruction);
}
internal enum Iced.Intel.EncoderInternal.XopOpCodeTable : Enum {
    
public int value__;
    
public static XopOpCodeTable MAP8;
    
public static XopOpCodeTable MAP9;
    
public static XopOpCodeTable MAP10;
}
internal class Iced.Intel.EncoderInternal.ZeroBytesHandler : OpCodeHandler {
    public ZeroBytesHandler(Code code);
    [NullableContextAttribute("1")]
public virtual void Encode(Encoder encoder, Instruction& modreq(System.Runtime.InteropServices.InAttribute) instruction);
}
internal enum Iced.Intel.EncodingKind : Enum {
    
public int value__;
    
public static EncodingKind Legacy;
    
public static EncodingKind VEX;
    
public static EncodingKind EVEX;
    
public static EncodingKind XOP;
    
public static EncodingKind D3NOW;
    
public static EncodingKind MVEX;
}
internal static class Iced.Intel.HexUtils : object {
    [NullableContextAttribute("1")]
public static Byte[] ToByteArray(string hexData);
    private static int TryParseHexChar(char c);
}
internal static class Iced.Intel.IcedConstants : object {
    
internal static int MaxOpCount;
    
internal static int MaxInstructionLength;
    
internal static int RegisterBits;
    
internal static Register VMM_first;
    
internal static Register VMM_last;
    
internal static int VMM_count;
    
internal static Register XMM_last;
    
internal static Register YMM_last;
    
internal static Register ZMM_last;
    
internal static Register TMM_last;
    
internal static int MaxCpuidFeatureInternalValues;
    
internal static MemorySize FirstBroadcastMemorySize;
    
internal static UInt32 MvexStart;
    
internal static UInt32 MvexLength;
    
internal static int CC_a_EnumCount;
    
internal static int CC_ae_EnumCount;
    
internal static int CC_b_EnumCount;
    
internal static int CC_be_EnumCount;
    
internal static int CC_e_EnumCount;
    
internal static int CC_g_EnumCount;
    
internal static int CC_ge_EnumCount;
    
internal static int CC_l_EnumCount;
    
internal static int CC_le_EnumCount;
    
internal static int CC_ne_EnumCount;
    
internal static int CC_np_EnumCount;
    
internal static int CC_p_EnumCount;
    
internal static int CodeEnumCount;
    
internal static int CodeSizeEnumCount;
    
internal static int ConditionCodeEnumCount;
    
internal static int CpuidFeatureEnumCount;
    
internal static int DecoderErrorEnumCount;
    
internal static int DecoratorKindEnumCount;
    
internal static int EncodingKindEnumCount;
    
internal static int FlowControlEnumCount;
    
internal static int FormatterSyntaxEnumCount;
    
internal static int FormatterTextKindEnumCount;
    
internal static int MandatoryPrefixEnumCount;
    
internal static int MemorySizeEnumCount;
    
internal static int MemorySizeOptionsEnumCount;
    
internal static int MnemonicEnumCount;
    
internal static int MvexConvFnEnumCount;
    
internal static int MvexEHBitEnumCount;
    
internal static int MvexRegMemConvEnumCount;
    
internal static int MvexTupleTypeLutKindEnumCount;
    
internal static int NumberBaseEnumCount;
    
internal static int NumberKindEnumCount;
    
internal static int OpAccessEnumCount;
    
internal static int OpCodeOperandKindEnumCount;
    
internal static int OpCodeTableKindEnumCount;
    
internal static int OpKindEnumCount;
    
internal static int PrefixKindEnumCount;
    
internal static int RegisterEnumCount;
    
internal static int RelocKindEnumCount;
    
internal static int RepPrefixKindEnumCount;
    
internal static int RoundingControlEnumCount;
    
internal static int TupleTypeEnumCount;
    public static bool IsMvex(Code code);
}
internal static class Iced.Intel.IcedFeatures : object {
    
public static bool HasGasFormatter { get; }
    
public static bool HasIntelFormatter { get; }
    
public static bool HasMasmFormatter { get; }
    
public static bool HasNasmFormatter { get; }
    
public static bool HasFastFormatter { get; }
    
public static bool HasDecoder { get; }
    
public static bool HasEncoder { get; }
    
public static bool HasBlockEncoder { get; }
    
public static bool HasOpCodeInfo { get; }
    
public static bool HasInstructionInfo { get; }
    public static bool get_HasGasFormatter();
    public static bool get_HasIntelFormatter();
    public static bool get_HasMasmFormatter();
    public static bool get_HasNasmFormatter();
    public static bool get_HasFastFormatter();
    public static bool get_HasDecoder();
    public static bool get_HasEncoder();
    public static bool get_HasBlockEncoder();
    public static bool get_HasOpCodeInfo();
    public static bool get_HasInstructionInfo();
    public static void Initialize();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Iced.Intel.Instruction : ValueType {
    
internal static int TOTAL_SIZE;
    
private ulong nextRip;
    
private ulong memDispl;
    
private UInt32 flags1;
    
private UInt32 immediate;
    
private ushort code;
    
private byte memBaseReg;
    
private byte memIndexReg;
    
private byte reg0;
    
private byte reg1;
    
private byte reg2;
    
private byte reg3;
    
private byte opKind0;
    
private byte opKind1;
    
private byte opKind2;
    
private byte opKind3;
    
private byte scale;
    
private byte displSize;
    
private byte len;
    
private byte pad;
    
public ushort IP16 { get; public set; }
    
public UInt32 IP32 { get; public set; }
    
public ulong IP { get; public set; }
    
public ushort NextIP16 { get; public set; }
    
public UInt32 NextIP32 { get; public set; }
    
public ulong NextIP { get; public set; }
    
public CodeSize CodeSize { get; public set; }
    
unknown CodeSize InternalCodeSize {internal set; }
    
public bool IsInvalid { get; }
    
public Code Code { get; public set; }
    
public Mnemonic Mnemonic { get; }
    
public int OpCount { get; }
    
public int Length { get; public set; }
    
internal bool Internal_HasRepeOrRepnePrefix { get; }
    
internal UInt32 HasAnyOf_Lock_Rep_Repne_Prefix { get; }
    
public bool HasXacquirePrefix { get; public set; }
    
public bool HasXreleasePrefix { get; public set; }
    
public bool HasRepPrefix { get; public set; }
    
public bool HasRepePrefix { get; public set; }
    
public bool HasRepnePrefix { get; public set; }
    
public bool HasLockPrefix { get; public set; }
    
public OpKind Op0Kind { get; public set; }
    
internal bool Internal_Op0IsNotReg_or_Op1IsNotReg { get; }
    
public OpKind Op1Kind { get; public set; }
    
public OpKind Op2Kind { get; public set; }
    
public OpKind Op3Kind { get; public set; }
    
public OpKind Op4Kind { get; public set; }
    
public bool HasSegmentPrefix { get; }
    
public Register SegmentPrefix { get; public set; }
    
public Register MemorySegment { get; }
    
public int MemoryDisplSize { get; public set; }
    
public bool IsBroadcast { get; public set; }
    
public MemorySize MemorySize { get; }
    
public int MemoryIndexScale { get; public set; }
    
internal int InternalMemoryIndexScale { get; internal set; }
    
public UInt32 MemoryDisplacement32 { get; public set; }
    
public ulong MemoryDisplacement64 { get; public set; }
    
public byte Immediate8 { get; public set; }
    
unknown UInt32 InternalImmediate8 {internal set; }
    
public byte Immediate8_2nd { get; public set; }
    
unknown UInt32 InternalImmediate8_2nd {internal set; }
    
public ushort Immediate16 { get; public set; }
    
unknown UInt32 InternalImmediate16 {internal set; }
    
public UInt32 Immediate32 { get; public set; }
    
public ulong Immediate64 { get; public set; }
    
unknown UInt32 InternalImmediate64_lo {internal set; }
    
unknown UInt32 InternalImmediate64_hi {internal set; }
    
public short Immediate8to16 { get; public set; }
    
public int Immediate8to32 { get; public set; }
    
public long Immediate8to64 { get; public set; }
    
public long Immediate32to64 { get; public set; }
    
public ushort NearBranch16 { get; public set; }
    
unknown UInt32 InternalNearBranch16 {internal set; }
    
public UInt32 NearBranch32 { get; public set; }
    
public ulong NearBranch64 { get; public set; }
    
public ulong NearBranchTarget { get; }
    
public ushort FarBranch16 { get; public set; }
    
unknown UInt32 InternalFarBranch16 {internal set; }
    
public UInt32 FarBranch32 { get; public set; }
    
public ushort FarBranchSelector { get; public set; }
    
unknown UInt32 InternalFarBranchSelector {internal set; }
    
public Register MemoryBase { get; public set; }
    
unknown Register InternalMemoryBase {internal set; }
    
public Register MemoryIndex { get; public set; }
    
unknown Register InternalMemoryIndex {internal set; }
    
public Register Op0Register { get; public set; }
    
unknown Register InternalOp0Register {internal set; }
    
public Register Op1Register { get; public set; }
    
unknown Register InternalOp1Register {internal set; }
    
public Register Op2Register { get; public set; }
    
unknown Register InternalOp2Register {internal set; }
    
public Register Op3Register { get; public set; }
    
unknown Register InternalOp3Register {internal set; }
    
public Register Op4Register { get; public set; }
    
public Register OpMask { get; public set; }
    
internal UInt32 InternalOpMask { get; internal set; }
    
public bool HasOpMask { get; }
    
internal bool HasOpMask_or_ZeroingMasking { get; }
    
public bool ZeroingMasking { get; public set; }
    
public bool MergingMasking { get; public set; }
    
public RoundingControl RoundingControl { get; public set; }
    
unknown UInt32 InternalRoundingControl {internal set; }
    
internal bool HasRoundingControlOrSae { get; }
    
public int DeclareDataCount { get; public set; }
    
unknown UInt32 InternalDeclareDataCount {internal set; }
    
public bool IsVsib { get; }
    
public bool IsVsib32 { get; }
    
public bool IsVsib64 { get; }
    
public bool SuppressAllExceptions { get; public set; }
    
public bool IsIPRelativeMemoryOperand { get; }
    
public ulong IPRelativeMemoryAddress { get; }
    private static void InitializeSignedImmediate(Instruction& instruction, int operand, long immediate);
    private static void InitializeUnsignedImmediate(Instruction& instruction, int operand, ulong immediate);
    private static OpKind GetImmediateOpKind(Code code, int operand);
    private static OpKind GetNearBranchOpKind(Code code, int operand);
    private static OpKind GetFarBranchOpKind(Code code, int operand);
    private static Instruction CreateString_Reg_SegRSI(Code code, int addressSize, Register register, Register segmentPrefix, RepPrefixKind repPrefix);
    private static Instruction CreateString_Reg_ESRDI(Code code, int addressSize, Register register, RepPrefixKind repPrefix);
    private static Instruction CreateString_ESRDI_Reg(Code code, int addressSize, Register register, RepPrefixKind repPrefix);
    private static Instruction CreateString_SegRSI_ESRDI(Code code, int addressSize, Register segmentPrefix, RepPrefixKind repPrefix);
    private static Instruction CreateString_ESRDI_SegRSI(Code code, int addressSize, Register segmentPrefix, RepPrefixKind repPrefix);
    private static Instruction CreateMaskmov(Code code, int addressSize, Register register1, Register register2, Register segmentPrefix);
    private static void InitMemoryOperand(Instruction& instruction, MemoryOperand& memory);
    public static Instruction Create(Code code);
    public static Instruction Create(Code code, Register register);
    public static Instruction Create(Code code, int immediate);
    public static Instruction Create(Code code, UInt32 immediate);
    public static Instruction Create(Code code, MemoryOperand& memory);
    public static Instruction Create(Code code, Register register1, Register register2);
    public static Instruction Create(Code code, Register register, int immediate);
    public static Instruction Create(Code code, Register register, UInt32 immediate);
    public static Instruction Create(Code code, Register register, long immediate);
    public static Instruction Create(Code code, Register register, ulong immediate);
    public static Instruction Create(Code code, Register register, MemoryOperand& memory);
    public static Instruction Create(Code code, int immediate, Register register);
    public static Instruction Create(Code code, UInt32 immediate, Register register);
    public static Instruction Create(Code code, int immediate1, int immediate2);
    public static Instruction Create(Code code, UInt32 immediate1, UInt32 immediate2);
    public static Instruction Create(Code code, MemoryOperand& memory, Register register);
    public static Instruction Create(Code code, MemoryOperand& memory, int immediate);
    public static Instruction Create(Code code, MemoryOperand& memory, UInt32 immediate);
    public static Instruction Create(Code code, Register register1, Register register2, Register register3);
    public static Instruction Create(Code code, Register register1, Register register2, int immediate);
    public static Instruction Create(Code code, Register register1, Register register2, UInt32 immediate);
    public static Instruction Create(Code code, Register register1, Register register2, MemoryOperand& memory);
    public static Instruction Create(Code code, Register register, int immediate1, int immediate2);
    public static Instruction Create(Code code, Register register, UInt32 immediate1, UInt32 immediate2);
    public static Instruction Create(Code code, Register register1, MemoryOperand& memory, Register register2);
    public static Instruction Create(Code code, Register register, MemoryOperand& memory, int immediate);
    public static Instruction Create(Code code, Register register, MemoryOperand& memory, UInt32 immediate);
    public static Instruction Create(Code code, MemoryOperand& memory, Register register1, Register register2);
    public static Instruction Create(Code code, MemoryOperand& memory, Register register, int immediate);
    public static Instruction Create(Code code, MemoryOperand& memory, Register register, UInt32 immediate);
    public static Instruction Create(Code code, Register register1, Register register2, Register register3, Register register4);
    public static Instruction Create(Code code, Register register1, Register register2, Register register3, int immediate);
    public static Instruction Create(Code code, Register register1, Register register2, Register register3, UInt32 immediate);
    public static Instruction Create(Code code, Register register1, Register register2, Register register3, MemoryOperand& memory);
    public static Instruction Create(Code code, Register register1, Register register2, int immediate1, int immediate2);
    public static Instruction Create(Code code, Register register1, Register register2, UInt32 immediate1, UInt32 immediate2);
    public static Instruction Create(Code code, Register register1, Register register2, MemoryOperand& memory, Register register3);
    public static Instruction Create(Code code, Register register1, Register register2, MemoryOperand& memory, int immediate);
    public static Instruction Create(Code code, Register register1, Register register2, MemoryOperand& memory, UInt32 immediate);
    public static Instruction Create(Code code, Register register1, Register register2, Register register3, Register register4, int immediate);
    public static Instruction Create(Code code, Register register1, Register register2, Register register3, Register register4, UInt32 immediate);
    public static Instruction Create(Code code, Register register1, Register register2, Register register3, MemoryOperand& memory, int immediate);
    public static Instruction Create(Code code, Register register1, Register register2, Register register3, MemoryOperand& memory, UInt32 immediate);
    public static Instruction Create(Code code, Register register1, Register register2, MemoryOperand& memory, Register register3, int immediate);
    public static Instruction Create(Code code, Register register1, Register register2, MemoryOperand& memory, Register register3, UInt32 immediate);
    public static Instruction CreateBranch(Code code, ulong target);
    public static Instruction CreateBranch(Code code, ushort selector, UInt32 offset);
    public static Instruction CreateXbegin(int bitness, ulong target);
    public static Instruction CreateOutsb(int addressSize, Register segmentPrefix, RepPrefixKind repPrefix);
    public static Instruction CreateRepOutsb(int addressSize);
    public static Instruction CreateOutsw(int addressSize, Register segmentPrefix, RepPrefixKind repPrefix);
    public static Instruction CreateRepOutsw(int addressSize);
    public static Instruction CreateOutsd(int addressSize, Register segmentPrefix, RepPrefixKind repPrefix);
    public static Instruction CreateRepOutsd(int addressSize);
    public static Instruction CreateLodsb(int addressSize, Register segmentPrefix, RepPrefixKind repPrefix);
    public static Instruction CreateRepLodsb(int addressSize);
    public static Instruction CreateLodsw(int addressSize, Register segmentPrefix, RepPrefixKind repPrefix);
    public static Instruction CreateRepLodsw(int addressSize);
    public static Instruction CreateLodsd(int addressSize, Register segmentPrefix, RepPrefixKind repPrefix);
    public static Instruction CreateRepLodsd(int addressSize);
    public static Instruction CreateLodsq(int addressSize, Register segmentPrefix, RepPrefixKind repPrefix);
    public static Instruction CreateRepLodsq(int addressSize);
    public static Instruction CreateScasb(int addressSize, RepPrefixKind repPrefix);
    public static Instruction CreateRepeScasb(int addressSize);
    public static Instruction CreateRepneScasb(int addressSize);
    public static Instruction CreateScasw(int addressSize, RepPrefixKind repPrefix);
    public static Instruction CreateRepeScasw(int addressSize);
    public static Instruction CreateRepneScasw(int addressSize);
    public static Instruction CreateScasd(int addressSize, RepPrefixKind repPrefix);
    public static Instruction CreateRepeScasd(int addressSize);
    public static Instruction CreateRepneScasd(int addressSize);
    public static Instruction CreateScasq(int addressSize, RepPrefixKind repPrefix);
    public static Instruction CreateRepeScasq(int addressSize);
    public static Instruction CreateRepneScasq(int addressSize);
    public static Instruction CreateInsb(int addressSize, RepPrefixKind repPrefix);
    public static Instruction CreateRepInsb(int addressSize);
    public static Instruction CreateInsw(int addressSize, RepPrefixKind repPrefix);
    public static Instruction CreateRepInsw(int addressSize);
    public static Instruction CreateInsd(int addressSize, RepPrefixKind repPrefix);
    public static Instruction CreateRepInsd(int addressSize);
    public static Instruction CreateStosb(int addressSize, RepPrefixKind repPrefix);
    public static Instruction CreateRepStosb(int addressSize);
    public static Instruction CreateStosw(int addressSize, RepPrefixKind repPrefix);
    public static Instruction CreateRepStosw(int addressSize);
    public static Instruction CreateStosd(int addressSize, RepPrefixKind repPrefix);
    public static Instruction CreateRepStosd(int addressSize);
    public static Instruction CreateStosq(int addressSize, RepPrefixKind repPrefix);
    public static Instruction CreateRepStosq(int addressSize);
    public static Instruction CreateCmpsb(int addressSize, Register segmentPrefix, RepPrefixKind repPrefix);
    public static Instruction CreateRepeCmpsb(int addressSize);
    public static Instruction CreateRepneCmpsb(int addressSize);
    public static Instruction CreateCmpsw(int addressSize, Register segmentPrefix, RepPrefixKind repPrefix);
    public static Instruction CreateRepeCmpsw(int addressSize);
    public static Instruction CreateRepneCmpsw(int addressSize);
    public static Instruction CreateCmpsd(int addressSize, Register segmentPrefix, RepPrefixKind repPrefix);
    public static Instruction CreateRepeCmpsd(int addressSize);
    public static Instruction CreateRepneCmpsd(int addressSize);
    public static Instruction CreateCmpsq(int addressSize, Register segmentPrefix, RepPrefixKind repPrefix);
    public static Instruction CreateRepeCmpsq(int addressSize);
    public static Instruction CreateRepneCmpsq(int addressSize);
    public static Instruction CreateMovsb(int addressSize, Register segmentPrefix, RepPrefixKind repPrefix);
    public static Instruction CreateRepMovsb(int addressSize);
    public static Instruction CreateMovsw(int addressSize, Register segmentPrefix, RepPrefixKind repPrefix);
    public static Instruction CreateRepMovsw(int addressSize);
    public static Instruction CreateMovsd(int addressSize, Register segmentPrefix, RepPrefixKind repPrefix);
    public static Instruction CreateRepMovsd(int addressSize);
    public static Instruction CreateMovsq(int addressSize, Register segmentPrefix, RepPrefixKind repPrefix);
    public static Instruction CreateRepMovsq(int addressSize);
    public static Instruction CreateMaskmovq(int addressSize, Register register1, Register register2, Register segmentPrefix);
    public static Instruction CreateMaskmovdqu(int addressSize, Register register1, Register register2, Register segmentPrefix);
    public static Instruction CreateVmaskmovdqu(int addressSize, Register register1, Register register2, Register segmentPrefix);
    public static Instruction CreateDeclareByte(byte b0);
    public static Instruction CreateDeclareByte(byte b0, byte b1);
    public static Instruction CreateDeclareByte(byte b0, byte b1, byte b2);
    public static Instruction CreateDeclareByte(byte b0, byte b1, byte b2, byte b3);
    public static Instruction CreateDeclareByte(byte b0, byte b1, byte b2, byte b3, byte b4);
    public static Instruction CreateDeclareByte(byte b0, byte b1, byte b2, byte b3, byte b4, byte b5);
    public static Instruction CreateDeclareByte(byte b0, byte b1, byte b2, byte b3, byte b4, byte b5, byte b6);
    public static Instruction CreateDeclareByte(byte b0, byte b1, byte b2, byte b3, byte b4, byte b5, byte b6, byte b7);
    public static Instruction CreateDeclareByte(byte b0, byte b1, byte b2, byte b3, byte b4, byte b5, byte b6, byte b7, byte b8);
    public static Instruction CreateDeclareByte(byte b0, byte b1, byte b2, byte b3, byte b4, byte b5, byte b6, byte b7, byte b8, byte b9);
    public static Instruction CreateDeclareByte(byte b0, byte b1, byte b2, byte b3, byte b4, byte b5, byte b6, byte b7, byte b8, byte b9, byte b10);
    public static Instruction CreateDeclareByte(byte b0, byte b1, byte b2, byte b3, byte b4, byte b5, byte b6, byte b7, byte b8, byte b9, byte b10, byte b11);
    public static Instruction CreateDeclareByte(byte b0, byte b1, byte b2, byte b3, byte b4, byte b5, byte b6, byte b7, byte b8, byte b9, byte b10, byte b11, byte b12);
    public static Instruction CreateDeclareByte(byte b0, byte b1, byte b2, byte b3, byte b4, byte b5, byte b6, byte b7, byte b8, byte b9, byte b10, byte b11, byte b12, byte b13);
    public static Instruction CreateDeclareByte(byte b0, byte b1, byte b2, byte b3, byte b4, byte b5, byte b6, byte b7, byte b8, byte b9, byte b10, byte b11, byte b12, byte b13, byte b14);
    public static Instruction CreateDeclareByte(byte b0, byte b1, byte b2, byte b3, byte b4, byte b5, byte b6, byte b7, byte b8, byte b9, byte b10, byte b11, byte b12, byte b13, byte b14, byte b15);
    [NullableContextAttribute("0")]
public static Instruction CreateDeclareByte(ReadOnlySpan`1<byte> data);
    public static Instruction CreateDeclareByte(Byte[] data);
    public static Instruction CreateDeclareByte(Byte[] data, int index, int length);
    public static Instruction CreateDeclareWord(ushort w0);
    public static Instruction CreateDeclareWord(ushort w0, ushort w1);
    public static Instruction CreateDeclareWord(ushort w0, ushort w1, ushort w2);
    public static Instruction CreateDeclareWord(ushort w0, ushort w1, ushort w2, ushort w3);
    public static Instruction CreateDeclareWord(ushort w0, ushort w1, ushort w2, ushort w3, ushort w4);
    public static Instruction CreateDeclareWord(ushort w0, ushort w1, ushort w2, ushort w3, ushort w4, ushort w5);
    public static Instruction CreateDeclareWord(ushort w0, ushort w1, ushort w2, ushort w3, ushort w4, ushort w5, ushort w6);
    public static Instruction CreateDeclareWord(ushort w0, ushort w1, ushort w2, ushort w3, ushort w4, ushort w5, ushort w6, ushort w7);
    [NullableContextAttribute("0")]
public static Instruction CreateDeclareWord(ReadOnlySpan`1<byte> data);
    public static Instruction CreateDeclareWord(Byte[] data);
    public static Instruction CreateDeclareWord(Byte[] data, int index, int length);
    [NullableContextAttribute("0")]
public static Instruction CreateDeclareWord(ReadOnlySpan`1<ushort> data);
    public static Instruction CreateDeclareWord(UInt16[] data);
    public static Instruction CreateDeclareWord(UInt16[] data, int index, int length);
    public static Instruction CreateDeclareDword(UInt32 d0);
    public static Instruction CreateDeclareDword(UInt32 d0, UInt32 d1);
    public static Instruction CreateDeclareDword(UInt32 d0, UInt32 d1, UInt32 d2);
    public static Instruction CreateDeclareDword(UInt32 d0, UInt32 d1, UInt32 d2, UInt32 d3);
    [NullableContextAttribute("0")]
public static Instruction CreateDeclareDword(ReadOnlySpan`1<byte> data);
    public static Instruction CreateDeclareDword(Byte[] data);
    public static Instruction CreateDeclareDword(Byte[] data, int index, int length);
    [NullableContextAttribute("0")]
public static Instruction CreateDeclareDword(ReadOnlySpan`1<UInt32> data);
    public static Instruction CreateDeclareDword(UInt32[] data);
    public static Instruction CreateDeclareDword(UInt32[] data, int index, int length);
    public static Instruction CreateDeclareQword(ulong q0);
    public static Instruction CreateDeclareQword(ulong q0, ulong q1);
    [NullableContextAttribute("0")]
public static Instruction CreateDeclareQword(ReadOnlySpan`1<byte> data);
    public static Instruction CreateDeclareQword(Byte[] data);
    public static Instruction CreateDeclareQword(Byte[] data, int index, int length);
    [NullableContextAttribute("0")]
public static Instruction CreateDeclareQword(ReadOnlySpan`1<ulong> data);
    public static Instruction CreateDeclareQword(UInt64[] data);
    public static Instruction CreateDeclareQword(UInt64[] data, int index, int length);
    public static bool op_Equality(Instruction& left, Instruction& right);
    public static bool op_Inequality(Instruction& left, Instruction& right);
    [IsReadOnlyAttribute]
public bool Equals(Instruction& other);
    [IsReadOnlyAttribute]
private sealed virtual override bool System.IEquatable<Iced.Intel.Instruction>.Equals(Instruction other);
    private static bool EqualsInternal(Instruction& a, Instruction& b);
    [IsReadOnlyAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public static bool EqualsAllBits(Instruction& a, Instruction& b);
    [IsReadOnlyAttribute]
public ushort get_IP16();
    public void set_IP16(ushort value);
    [IsReadOnlyAttribute]
public UInt32 get_IP32();
    public void set_IP32(UInt32 value);
    [IsReadOnlyAttribute]
public ulong get_IP();
    public void set_IP(ulong value);
    [IsReadOnlyAttribute]
public ushort get_NextIP16();
    public void set_NextIP16(ushort value);
    [IsReadOnlyAttribute]
public UInt32 get_NextIP32();
    public void set_NextIP32(UInt32 value);
    [IsReadOnlyAttribute]
public ulong get_NextIP();
    public void set_NextIP(ulong value);
    [IsReadOnlyAttribute]
public CodeSize get_CodeSize();
    public void set_CodeSize(CodeSize value);
    internal void set_InternalCodeSize(CodeSize value);
    [IsReadOnlyAttribute]
public bool get_IsInvalid();
    [IsReadOnlyAttribute]
public Code get_Code();
    public void set_Code(Code value);
    internal void InternalSetCodeNoCheck(Code code);
    [IsReadOnlyAttribute]
public Mnemonic get_Mnemonic();
    [IsReadOnlyAttribute]
public int get_OpCount();
    [IsReadOnlyAttribute]
public int get_Length();
    public void set_Length(int value);
    [IsReadOnlyAttribute]
internal bool get_Internal_HasRepeOrRepnePrefix();
    [IsReadOnlyAttribute]
internal UInt32 get_HasAnyOf_Lock_Rep_Repne_Prefix();
    [IsReadOnlyAttribute]
private bool IsXacquireInstr();
    [IsReadOnlyAttribute]
private bool IsXreleaseInstr();
    [IsReadOnlyAttribute]
public bool get_HasXacquirePrefix();
    public void set_HasXacquirePrefix(bool value);
    internal void InternalSetHasXacquirePrefix();
    [IsReadOnlyAttribute]
public bool get_HasXreleasePrefix();
    public void set_HasXreleasePrefix(bool value);
    internal void InternalSetHasXreleasePrefix();
    [IsReadOnlyAttribute]
public bool get_HasRepPrefix();
    public void set_HasRepPrefix(bool value);
    [IsReadOnlyAttribute]
public bool get_HasRepePrefix();
    public void set_HasRepePrefix(bool value);
    internal void InternalSetHasRepePrefix();
    internal void InternalClearHasRepePrefix();
    internal void InternalClearHasRepeRepnePrefix();
    [IsReadOnlyAttribute]
public bool get_HasRepnePrefix();
    public void set_HasRepnePrefix(bool value);
    internal void InternalSetHasRepnePrefix();
    internal void InternalClearHasRepnePrefix();
    [IsReadOnlyAttribute]
public bool get_HasLockPrefix();
    public void set_HasLockPrefix(bool value);
    internal void InternalSetHasLockPrefix();
    internal void InternalClearHasLockPrefix();
    [IsReadOnlyAttribute]
public OpKind get_Op0Kind();
    public void set_Op0Kind(OpKind value);
    [IsReadOnlyAttribute]
internal bool get_Internal_Op0IsNotReg_or_Op1IsNotReg();
    [IsReadOnlyAttribute]
public OpKind get_Op1Kind();
    public void set_Op1Kind(OpKind value);
    [IsReadOnlyAttribute]
public OpKind get_Op2Kind();
    public void set_Op2Kind(OpKind value);
    [IsReadOnlyAttribute]
public OpKind get_Op3Kind();
    public void set_Op3Kind(OpKind value);
    [IsReadOnlyAttribute]
public OpKind get_Op4Kind();
    public void set_Op4Kind(OpKind value);
    [IsReadOnlyAttribute]
public OpKind GetOpKind(int operand);
    [IsReadOnlyAttribute]
public bool HasOpKind(OpKind opKind);
    public void SetOpKind(int operand, OpKind opKind);
    [IsReadOnlyAttribute]
public bool get_HasSegmentPrefix();
    [IsReadOnlyAttribute]
public Register get_SegmentPrefix();
    public void set_SegmentPrefix(Register value);
    [IsReadOnlyAttribute]
public Register get_MemorySegment();
    [IsReadOnlyAttribute]
public int get_MemoryDisplSize();
    public void set_MemoryDisplSize(int value);
    internal void InternalSetMemoryDisplSize(UInt32 scale);
    [IsReadOnlyAttribute]
public bool get_IsBroadcast();
    public void set_IsBroadcast(bool value);
    internal void InternalSetIsBroadcast();
    [IsReadOnlyAttribute]
public MemorySize get_MemorySize();
    [IsReadOnlyAttribute]
public int get_MemoryIndexScale();
    public void set_MemoryIndexScale(int value);
    [IsReadOnlyAttribute]
internal int get_InternalMemoryIndexScale();
    internal void set_InternalMemoryIndexScale(int value);
    [IsReadOnlyAttribute]
public UInt32 get_MemoryDisplacement32();
    public void set_MemoryDisplacement32(UInt32 value);
    [IsReadOnlyAttribute]
public ulong get_MemoryDisplacement64();
    public void set_MemoryDisplacement64(ulong value);
    [IsReadOnlyAttribute]
public ulong GetImmediate(int operand);
    public void SetImmediate(int operand, int immediate);
    public void SetImmediate(int operand, UInt32 immediate);
    public void SetImmediate(int operand, long immediate);
    public void SetImmediate(int operand, ulong immediate);
    [IsReadOnlyAttribute]
public byte get_Immediate8();
    public void set_Immediate8(byte value);
    internal void set_InternalImmediate8(UInt32 value);
    [IsReadOnlyAttribute]
public byte get_Immediate8_2nd();
    public void set_Immediate8_2nd(byte value);
    internal void set_InternalImmediate8_2nd(UInt32 value);
    [IsReadOnlyAttribute]
public ushort get_Immediate16();
    public void set_Immediate16(ushort value);
    internal void set_InternalImmediate16(UInt32 value);
    [IsReadOnlyAttribute]
public UInt32 get_Immediate32();
    public void set_Immediate32(UInt32 value);
    [IsReadOnlyAttribute]
public ulong get_Immediate64();
    public void set_Immediate64(ulong value);
    internal void set_InternalImmediate64_lo(UInt32 value);
    internal void set_InternalImmediate64_hi(UInt32 value);
    [IsReadOnlyAttribute]
public short get_Immediate8to16();
    public void set_Immediate8to16(short value);
    [IsReadOnlyAttribute]
public int get_Immediate8to32();
    public void set_Immediate8to32(int value);
    [IsReadOnlyAttribute]
public long get_Immediate8to64();
    public void set_Immediate8to64(long value);
    [IsReadOnlyAttribute]
public long get_Immediate32to64();
    public void set_Immediate32to64(long value);
    [IsReadOnlyAttribute]
public ushort get_NearBranch16();
    public void set_NearBranch16(ushort value);
    internal void set_InternalNearBranch16(UInt32 value);
    [IsReadOnlyAttribute]
public UInt32 get_NearBranch32();
    public void set_NearBranch32(UInt32 value);
    [IsReadOnlyAttribute]
public ulong get_NearBranch64();
    public void set_NearBranch64(ulong value);
    [IsReadOnlyAttribute]
public ulong get_NearBranchTarget();
    [IsReadOnlyAttribute]
public ushort get_FarBranch16();
    public void set_FarBranch16(ushort value);
    internal void set_InternalFarBranch16(UInt32 value);
    [IsReadOnlyAttribute]
public UInt32 get_FarBranch32();
    public void set_FarBranch32(UInt32 value);
    [IsReadOnlyAttribute]
public ushort get_FarBranchSelector();
    public void set_FarBranchSelector(ushort value);
    internal void set_InternalFarBranchSelector(UInt32 value);
    [IsReadOnlyAttribute]
public Register get_MemoryBase();
    public void set_MemoryBase(Register value);
    internal void set_InternalMemoryBase(Register value);
    [IsReadOnlyAttribute]
public Register get_MemoryIndex();
    public void set_MemoryIndex(Register value);
    internal void set_InternalMemoryIndex(Register value);
    [IsReadOnlyAttribute]
public Register get_Op0Register();
    public void set_Op0Register(Register value);
    internal void set_InternalOp0Register(Register value);
    [IsReadOnlyAttribute]
public Register get_Op1Register();
    public void set_Op1Register(Register value);
    internal void set_InternalOp1Register(Register value);
    [IsReadOnlyAttribute]
public Register get_Op2Register();
    public void set_Op2Register(Register value);
    internal void set_InternalOp2Register(Register value);
    [IsReadOnlyAttribute]
public Register get_Op3Register();
    public void set_Op3Register(Register value);
    internal void set_InternalOp3Register(Register value);
    [IsReadOnlyAttribute]
public Register get_Op4Register();
    public void set_Op4Register(Register value);
    [IsReadOnlyAttribute]
public Register GetOpRegister(int operand);
    public void SetOpRegister(int operand, Register register);
    [IsReadOnlyAttribute]
public Register get_OpMask();
    public void set_OpMask(Register value);
    [IsReadOnlyAttribute]
internal UInt32 get_InternalOpMask();
    internal void set_InternalOpMask(UInt32 value);
    [IsReadOnlyAttribute]
public bool get_HasOpMask();
    [IsReadOnlyAttribute]
internal bool get_HasOpMask_or_ZeroingMasking();
    [IsReadOnlyAttribute]
public bool get_ZeroingMasking();
    public void set_ZeroingMasking(bool value);
    internal void InternalSetZeroingMasking();
    [IsReadOnlyAttribute]
public bool get_MergingMasking();
    public void set_MergingMasking(bool value);
    [IsReadOnlyAttribute]
public RoundingControl get_RoundingControl();
    public void set_RoundingControl(RoundingControl value);
    internal void set_InternalRoundingControl(UInt32 value);
    [IsReadOnlyAttribute]
internal bool get_HasRoundingControlOrSae();
    [IsReadOnlyAttribute]
public int get_DeclareDataCount();
    public void set_DeclareDataCount(int value);
    internal void set_InternalDeclareDataCount(UInt32 value);
    public void SetDeclareByteValue(int index, sbyte value);
    public void SetDeclareByteValue(int index, byte value);
    [IsReadOnlyAttribute]
public byte GetDeclareByteValue(int index);
    public void SetDeclareWordValue(int index, short value);
    public void SetDeclareWordValue(int index, ushort value);
    [IsReadOnlyAttribute]
public ushort GetDeclareWordValue(int index);
    public void SetDeclareDwordValue(int index, int value);
    public void SetDeclareDwordValue(int index, UInt32 value);
    [IsReadOnlyAttribute]
public UInt32 GetDeclareDwordValue(int index);
    public void SetDeclareQwordValue(int index, long value);
    public void SetDeclareQwordValue(int index, ulong value);
    [IsReadOnlyAttribute]
public ulong GetDeclareQwordValue(int index);
    [IsReadOnlyAttribute]
public bool get_IsVsib();
    [IsReadOnlyAttribute]
public bool get_IsVsib32();
    [IsReadOnlyAttribute]
public bool get_IsVsib64();
    [IsReadOnlyAttribute]
public bool TryGetVsib64(Boolean& vsib64);
    [IsReadOnlyAttribute]
public bool get_SuppressAllExceptions();
    public void set_SuppressAllExceptions(bool value);
    internal void InternalSetSuppressAllExceptions();
    [IsReadOnlyAttribute]
public bool get_IsIPRelativeMemoryOperand();
    [IsReadOnlyAttribute]
public ulong get_IPRelativeMemoryAddress();
    [IsReadOnlyAttribute]
public virtual string ToString();
    [IsReadOnlyAttribute]
public ulong GetVirtualAddress(int operand, int elementIndex, VAGetRegisterValue getRegisterValue);
    [IsReadOnlyAttribute]
public ulong GetVirtualAddress(int operand, int elementIndex, IVARegisterValueProvider registerValueProvider);
    [IsReadOnlyAttribute]
public bool TryGetVirtualAddress(int operand, int elementIndex, UInt64& result, VATryGetRegisterValue getRegisterValue);
    [IsReadOnlyAttribute]
public bool TryGetVirtualAddress(int operand, int elementIndex, IVATryGetRegisterValueProvider registerValueProvider, UInt64& result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Iced.Intel.InstructionBlock : ValueType {
    
public CodeWriter CodeWriter;
    
public IList`1<Instruction> Instructions;
    
public ulong RIP;
    public InstructionBlock(CodeWriter codeWriter, IList`1<Instruction> instructions, ulong rip);
}
[ExtensionAttribute]
internal static class Iced.Intel.InstructionInfoExtensions : object {
    [ExtensionAttribute]
public static Code NegateConditionCode(Code code);
    [ExtensionAttribute]
public static Code ToShortBranch(Code code);
    [ExtensionAttribute]
public static Code ToNearBranch(Code code);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("Count = {Count}")]
[DebuggerTypeProxyAttribute("Iced.Intel.InstructionListDebugView")]
[EditorBrowsableAttribute("1")]
internal class Iced.Intel.InstructionList : object {
    
private Instruction[] elements;
    
private int count;
    
public int Count { get; }
    
private int System.Collections.Generic.ICollection<Iced.Intel.Instruction>.Count { get; }
    
private int System.Collections.ICollection.Count { get; }
    
private int System.Collections.Generic.IReadOnlyCollection<Iced.Intel.Instruction>.Count { get; }
    
public int Capacity { get; }
    
private bool System.Collections.Generic.ICollection<Iced.Intel.Instruction>.IsReadOnly { get; }
    
private bool System.Collections.IList.IsReadOnly { get; }
    
private bool System.Collections.IList.IsFixedSize { get; }
    
private bool System.Collections.ICollection.IsSynchronized { get; }
    
private object System.Collections.ICollection.SyncRoot { get; }
    
public Instruction& Item { get; }
    
private Instruction System.Collections.Generic.IList<Iced.Intel.Instruction>.Item { get; private set; }
    
private Instruction System.Collections.Generic.IReadOnlyList<Iced.Intel.Instruction>.Item { get; }
    [NullableAttribute("2")]

private object System.Collections.IList.Item { get; private set; }
    public InstructionList(int capacity);
    public InstructionList(InstructionList list);
    public InstructionList(IEnumerable`1<Instruction> collection);
    public int get_Count();
    private sealed virtual override int System.Collections.Generic.ICollection<Iced.Intel.Instruction>.get_Count();
    private sealed virtual override int System.Collections.ICollection.get_Count();
    private sealed virtual override int System.Collections.Generic.IReadOnlyCollection<Iced.Intel.Instruction>.get_Count();
    public int get_Capacity();
    private sealed virtual override bool System.Collections.Generic.ICollection<Iced.Intel.Instruction>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    public Instruction& get_Item(int index);
    private sealed virtual override Instruction System.Collections.Generic.IList<Iced.Intel.Instruction>.get_Item(int index);
    private sealed virtual override void System.Collections.Generic.IList<Iced.Intel.Instruction>.set_Item(int index, Instruction value);
    private sealed virtual override Instruction System.Collections.Generic.IReadOnlyList<Iced.Intel.Instruction>.get_Item(int index);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private void SetMinCapacity(int minCapacity);
    public Instruction& AllocUninitializedElement();
    private void MakeRoom(int index, int extraLength);
    public void Insert(int index, Instruction& instruction);
    private sealed virtual override void System.Collections.Generic.IList<Iced.Intel.Instruction>.Insert(int index, Instruction instruction);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    public void RemoveAt(int index);
    private sealed virtual override void System.Collections.Generic.IList<Iced.Intel.Instruction>.RemoveAt(int index);
    private sealed virtual override void System.Collections.IList.RemoveAt(int index);
    public void AddRange(IEnumerable`1<Instruction> collection);
    public void InsertRange(int index, IEnumerable`1<Instruction> collection);
    public void RemoveRange(int index, int count);
    public void Add(Instruction& instruction);
    private sealed virtual override void System.Collections.Generic.ICollection<Iced.Intel.Instruction>.Add(Instruction instruction);
    private sealed virtual override int System.Collections.IList.Add(object value);
    public void Clear();
    private sealed virtual override void System.Collections.Generic.ICollection<Iced.Intel.Instruction>.Clear();
    private sealed virtual override void System.Collections.IList.Clear();
    public bool Contains(Instruction& instruction);
    private sealed virtual override bool System.Collections.Generic.ICollection<Iced.Intel.Instruction>.Contains(Instruction instruction);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    public int IndexOf(Instruction& instruction);
    private sealed virtual override int System.Collections.Generic.IList<Iced.Intel.Instruction>.IndexOf(Instruction instruction);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    public int IndexOf(Instruction& instruction, int index);
    public int IndexOf(Instruction& instruction, int index, int count);
    public int LastIndexOf(Instruction& instruction);
    public int LastIndexOf(Instruction& instruction, int index);
    public int LastIndexOf(Instruction& instruction, int index, int count);
    public bool Remove(Instruction& instruction);
    private sealed virtual override bool System.Collections.Generic.ICollection<Iced.Intel.Instruction>.Remove(Instruction instruction);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    public void CopyTo(Instruction[] array);
    public void CopyTo(Instruction[] array, int arrayIndex);
    private sealed virtual override void System.Collections.Generic.ICollection<Iced.Intel.Instruction>.CopyTo(Instruction[] array, int arrayIndex);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public void CopyTo(int index, Instruction[] array, int arrayIndex, int count);
    public InstructionList GetRange(int index, int count);
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<Instruction> System.Collections.Generic.IEnumerable<Iced.Intel.Instruction>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public ReadOnlyCollection`1<Instruction> AsReadOnly();
    public Instruction[] ToArray();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Iced.Intel.InstructionListDebugView : object {
    
private InstructionList list;
    [DebuggerBrowsableAttribute("3")]

public Instruction[] Items { get; }
    public InstructionListDebugView(InstructionList list);
    public Instruction[] get_Items();
}
internal static class Iced.Intel.InstructionMemorySizes : object {
    
internal static ReadOnlySpan`1<byte> SizesNormal { get; }
    
internal static ReadOnlySpan`1<byte> SizesBcst { get; }
    internal static ReadOnlySpan`1<byte> get_SizesNormal();
    internal static ReadOnlySpan`1<byte> get_SizesBcst();
}
internal static class Iced.Intel.InstructionOpCounts : object {
    
internal static ReadOnlySpan`1<byte> OpCount { get; }
    internal static ReadOnlySpan`1<byte> get_OpCount();
}
internal static class Iced.Intel.InstructionUtils : object {
    public static int GetAddressSizeInBytes(Register baseReg, Register indexReg, int displSize, CodeSize codeSize);
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
internal class Iced.Intel.Internal.DataReader : ValueType {
    
private ReadOnlySpan`1<byte> data;
    
private Char[] stringData;
    
private int index;
    
public int Index { get; public set; }
    
public bool CanRead { get; }
    public DataReader(ReadOnlySpan`1<byte> data);
    public DataReader(ReadOnlySpan`1<byte> data, int maxStringLength);
    [IsReadOnlyAttribute]
public int get_Index();
    public void set_Index(int value);
    [IsReadOnlyAttribute]
public bool get_CanRead();
    public byte ReadByte();
    public UInt32 ReadCompressedUInt32();
    [NullableContextAttribute("1")]
public string ReadAsciiString();
}
internal interface Iced.Intel.IVARegisterValueProvider {
    public abstract virtual ulong GetRegisterValue(Register register, int elementIndex, int elementSize);
}
internal interface Iced.Intel.IVATryGetRegisterValueProvider {
    public abstract virtual bool TryGetRegisterValue(Register register, int elementIndex, int elementSize, UInt64& value);
}
internal enum Iced.Intel.MandatoryPrefixByte : Enum {
    
public UInt32 value__;
    
public static MandatoryPrefixByte None;
    
public static MandatoryPrefixByte P66;
    
public static MandatoryPrefixByte PF3;
    
public static MandatoryPrefixByte PF2;
}
[IsReadOnlyAttribute]
internal class Iced.Intel.MemoryOperand : ValueType {
    
public Register SegmentPrefix;
    
public Register Base;
    
public Register Index;
    
public int Scale;
    
public long Displacement;
    
public int DisplSize;
    
public bool IsBroadcast;
    public MemoryOperand(Register base, Register index, int scale, long displacement, int displSize, bool isBroadcast, Register segmentPrefix);
    public MemoryOperand(Register base, Register index, int scale, bool isBroadcast, Register segmentPrefix);
    public MemoryOperand(Register base, long displacement, int displSize, bool isBroadcast, Register segmentPrefix);
    public MemoryOperand(Register index, int scale, long displacement, int displSize, bool isBroadcast, Register segmentPrefix);
    public MemoryOperand(Register base, long displacement, bool isBroadcast, Register segmentPrefix);
    public MemoryOperand(Register base, Register index, int scale, long displacement, int displSize);
    public MemoryOperand(Register base, Register index, int scale);
    public MemoryOperand(Register base, Register index);
    public MemoryOperand(Register base, long displacement, int displSize);
    public MemoryOperand(Register index, int scale, long displacement, int displSize);
    public MemoryOperand(Register base, long displacement);
    public MemoryOperand(Register base);
    public MemoryOperand(ulong displacement, int displSize);
}
internal enum Iced.Intel.MemorySize : Enum {
    
public int value__;
    
public static MemorySize Unknown;
    
public static MemorySize UInt8;
    
public static MemorySize UInt16;
    
public static MemorySize UInt32;
    
public static MemorySize UInt52;
    
public static MemorySize UInt64;
    
public static MemorySize UInt128;
    
public static MemorySize UInt256;
    
public static MemorySize UInt512;
    
public static MemorySize Int8;
    
public static MemorySize Int16;
    
public static MemorySize Int32;
    
public static MemorySize Int64;
    
public static MemorySize Int128;
    
public static MemorySize Int256;
    
public static MemorySize Int512;
    
public static MemorySize SegPtr16;
    
public static MemorySize SegPtr32;
    
public static MemorySize SegPtr64;
    
public static MemorySize WordOffset;
    
public static MemorySize DwordOffset;
    
public static MemorySize QwordOffset;
    
public static MemorySize Bound16_WordWord;
    
public static MemorySize Bound32_DwordDword;
    
public static MemorySize Bnd32;
    
public static MemorySize Bnd64;
    
public static MemorySize Fword6;
    
public static MemorySize Fword10;
    
public static MemorySize Float16;
    
public static MemorySize Float32;
    
public static MemorySize Float64;
    
public static MemorySize Float80;
    
public static MemorySize Float128;
    
public static MemorySize BFloat16;
    
public static MemorySize FpuEnv14;
    
public static MemorySize FpuEnv28;
    
public static MemorySize FpuState94;
    
public static MemorySize FpuState108;
    
public static MemorySize Fxsave_512Byte;
    
public static MemorySize Fxsave64_512Byte;
    
public static MemorySize Xsave;
    
public static MemorySize Xsave64;
    
public static MemorySize Bcd;
    
public static MemorySize Tilecfg;
    
public static MemorySize Tile;
    
public static MemorySize SegmentDescSelector;
    
public static MemorySize KLHandleAes128;
    
public static MemorySize KLHandleAes256;
    
public static MemorySize Packed16_UInt8;
    
public static MemorySize Packed16_Int8;
    
public static MemorySize Packed32_UInt8;
    
public static MemorySize Packed32_Int8;
    
public static MemorySize Packed32_UInt16;
    
public static MemorySize Packed32_Int16;
    
public static MemorySize Packed32_Float16;
    
public static MemorySize Packed32_BFloat16;
    
public static MemorySize Packed64_UInt8;
    
public static MemorySize Packed64_Int8;
    
public static MemorySize Packed64_UInt16;
    
public static MemorySize Packed64_Int16;
    
public static MemorySize Packed64_UInt32;
    
public static MemorySize Packed64_Int32;
    
public static MemorySize Packed64_Float16;
    
public static MemorySize Packed64_Float32;
    
public static MemorySize Packed128_UInt8;
    
public static MemorySize Packed128_Int8;
    
public static MemorySize Packed128_UInt16;
    
public static MemorySize Packed128_Int16;
    
public static MemorySize Packed128_UInt32;
    
public static MemorySize Packed128_Int32;
    
public static MemorySize Packed128_UInt52;
    
public static MemorySize Packed128_UInt64;
    
public static MemorySize Packed128_Int64;
    
public static MemorySize Packed128_Float16;
    
public static MemorySize Packed128_Float32;
    
public static MemorySize Packed128_Float64;
    
public static MemorySize Packed128_2xFloat16;
    
public static MemorySize Packed128_2xBFloat16;
    
public static MemorySize Packed256_UInt8;
    
public static MemorySize Packed256_Int8;
    
public static MemorySize Packed256_UInt16;
    
public static MemorySize Packed256_Int16;
    
public static MemorySize Packed256_UInt32;
    
public static MemorySize Packed256_Int32;
    
public static MemorySize Packed256_UInt52;
    
public static MemorySize Packed256_UInt64;
    
public static MemorySize Packed256_Int64;
    
public static MemorySize Packed256_UInt128;
    
public static MemorySize Packed256_Int128;
    
public static MemorySize Packed256_Float16;
    
public static MemorySize Packed256_Float32;
    
public static MemorySize Packed256_Float64;
    
public static MemorySize Packed256_Float128;
    
public static MemorySize Packed256_2xFloat16;
    
public static MemorySize Packed256_2xBFloat16;
    
public static MemorySize Packed512_UInt8;
    
public static MemorySize Packed512_Int8;
    
public static MemorySize Packed512_UInt16;
    
public static MemorySize Packed512_Int16;
    
public static MemorySize Packed512_UInt32;
    
public static MemorySize Packed512_Int32;
    
public static MemorySize Packed512_UInt52;
    
public static MemorySize Packed512_UInt64;
    
public static MemorySize Packed512_Int64;
    
public static MemorySize Packed512_UInt128;
    
public static MemorySize Packed512_Float16;
    
public static MemorySize Packed512_Float32;
    
public static MemorySize Packed512_Float64;
    
public static MemorySize Packed512_2xFloat16;
    
public static MemorySize Packed512_2xBFloat16;
    
public static MemorySize Broadcast32_Float16;
    
public static MemorySize Broadcast64_UInt32;
    
public static MemorySize Broadcast64_Int32;
    
public static MemorySize Broadcast64_Float16;
    
public static MemorySize Broadcast64_Float32;
    
public static MemorySize Broadcast128_Int16;
    
public static MemorySize Broadcast128_UInt16;
    
public static MemorySize Broadcast128_UInt32;
    
public static MemorySize Broadcast128_Int32;
    
public static MemorySize Broadcast128_UInt52;
    
public static MemorySize Broadcast128_UInt64;
    
public static MemorySize Broadcast128_Int64;
    
public static MemorySize Broadcast128_Float16;
    
public static MemorySize Broadcast128_Float32;
    
public static MemorySize Broadcast128_Float64;
    
public static MemorySize Broadcast128_2xInt16;
    
public static MemorySize Broadcast128_2xInt32;
    
public static MemorySize Broadcast128_2xUInt32;
    
public static MemorySize Broadcast128_2xFloat16;
    
public static MemorySize Broadcast128_2xBFloat16;
    
public static MemorySize Broadcast256_Int16;
    
public static MemorySize Broadcast256_UInt16;
    
public static MemorySize Broadcast256_UInt32;
    
public static MemorySize Broadcast256_Int32;
    
public static MemorySize Broadcast256_UInt52;
    
public static MemorySize Broadcast256_UInt64;
    
public static MemorySize Broadcast256_Int64;
    
public static MemorySize Broadcast256_Float16;
    
public static MemorySize Broadcast256_Float32;
    
public static MemorySize Broadcast256_Float64;
    
public static MemorySize Broadcast256_2xInt16;
    
public static MemorySize Broadcast256_2xInt32;
    
public static MemorySize Broadcast256_2xUInt32;
    
public static MemorySize Broadcast256_2xFloat16;
    
public static MemorySize Broadcast256_2xBFloat16;
    
public static MemorySize Broadcast512_Int16;
    
public static MemorySize Broadcast512_UInt16;
    
public static MemorySize Broadcast512_UInt32;
    
public static MemorySize Broadcast512_Int32;
    
public static MemorySize Broadcast512_UInt52;
    
public static MemorySize Broadcast512_UInt64;
    
public static MemorySize Broadcast512_Int64;
    
public static MemorySize Broadcast512_Float16;
    
public static MemorySize Broadcast512_Float32;
    
public static MemorySize Broadcast512_Float64;
    
public static MemorySize Broadcast512_2xFloat16;
    
public static MemorySize Broadcast512_2xInt16;
    
public static MemorySize Broadcast512_2xUInt32;
    
public static MemorySize Broadcast512_2xInt32;
    
public static MemorySize Broadcast512_2xBFloat16;
}
[ExtensionAttribute]
internal static class Iced.Intel.MemorySizeExtensions : object {
    [NullableAttribute("1")]

internal static MemorySizeInfo[] MemorySizeInfos;
    private static MemorySizeExtensions();
    [ExtensionAttribute]
public static bool IsBroadcast(MemorySize memorySize);
    private static MemorySizeInfo[] GetMemorySizeInfos();
    [ExtensionAttribute]
public static MemorySizeInfo GetInfo(MemorySize memorySize);
    [ExtensionAttribute]
public static int GetSize(MemorySize memorySize);
    [ExtensionAttribute]
public static int GetElementSize(MemorySize memorySize);
    [ExtensionAttribute]
public static MemorySize GetElementType(MemorySize memorySize);
    [ExtensionAttribute]
public static MemorySizeInfo GetElementTypeInfo(MemorySize memorySize);
    [ExtensionAttribute]
public static bool IsSigned(MemorySize memorySize);
    [ExtensionAttribute]
public static bool IsPacked(MemorySize memorySize);
    [ExtensionAttribute]
public static int GetElementCount(MemorySize memorySize);
}
[IsReadOnlyAttribute]
internal class Iced.Intel.MemorySizeInfo : ValueType {
    
private ushort size;
    
private ushort elementSize;
    
private byte memorySize;
    
private byte elementType;
    
private bool isSigned;
    
private bool isBroadcast;
    
public MemorySize MemorySize { get; }
    
public int Size { get; }
    
public int ElementSize { get; }
    
public MemorySize ElementType { get; }
    
public bool IsSigned { get; }
    
public bool IsBroadcast { get; }
    
public bool IsPacked { get; }
    
public int ElementCount { get; }
    public MemorySizeInfo(MemorySize memorySize, int size, int elementSize, MemorySize elementType, bool isSigned, bool isBroadcast);
    public MemorySize get_MemorySize();
    public int get_Size();
    public int get_ElementSize();
    public MemorySize get_ElementType();
    public bool get_IsSigned();
    public bool get_IsBroadcast();
    public bool get_IsPacked();
    public int get_ElementCount();
}
internal enum Iced.Intel.Mnemonic : Enum {
    
public int value__;
    
public static Mnemonic INVALID;
    
public static Mnemonic Aaa;
    
public static Mnemonic Aad;
    
public static Mnemonic Aam;
    
public static Mnemonic Aas;
    
public static Mnemonic Adc;
    
public static Mnemonic Adcx;
    
public static Mnemonic Add;
    
public static Mnemonic Addpd;
    
public static Mnemonic Addps;
    
public static Mnemonic Addsd;
    
public static Mnemonic Addss;
    
public static Mnemonic Addsubpd;
    
public static Mnemonic Addsubps;
    
public static Mnemonic Adox;
    
public static Mnemonic Aesdec;
    
public static Mnemonic Aesdeclast;
    
public static Mnemonic Aesenc;
    
public static Mnemonic Aesenclast;
    
public static Mnemonic Aesimc;
    
public static Mnemonic Aeskeygenassist;
    
public static Mnemonic And;
    
public static Mnemonic Andn;
    
public static Mnemonic Andnpd;
    
public static Mnemonic Andnps;
    
public static Mnemonic Andpd;
    
public static Mnemonic Andps;
    
public static Mnemonic Arpl;
    
public static Mnemonic Bextr;
    
public static Mnemonic Blcfill;
    
public static Mnemonic Blci;
    
public static Mnemonic Blcic;
    
public static Mnemonic Blcmsk;
    
public static Mnemonic Blcs;
    
public static Mnemonic Blendpd;
    
public static Mnemonic Blendps;
    
public static Mnemonic Blendvpd;
    
public static Mnemonic Blendvps;
    
public static Mnemonic Blsfill;
    
public static Mnemonic Blsi;
    
public static Mnemonic Blsic;
    
public static Mnemonic Blsmsk;
    
public static Mnemonic Blsr;
    
public static Mnemonic Bndcl;
    
public static Mnemonic Bndcn;
    
public static Mnemonic Bndcu;
    
public static Mnemonic Bndldx;
    
public static Mnemonic Bndmk;
    
public static Mnemonic Bndmov;
    
public static Mnemonic Bndstx;
    
public static Mnemonic Bound;
    
public static Mnemonic Bsf;
    
public static Mnemonic Bsr;
    
public static Mnemonic Bswap;
    
public static Mnemonic Bt;
    
public static Mnemonic Btc;
    
public static Mnemonic Btr;
    
public static Mnemonic Bts;
    
public static Mnemonic Bzhi;
    
public static Mnemonic Call;
    
public static Mnemonic Cbw;
    
public static Mnemonic Cdq;
    
public static Mnemonic Cdqe;
    
public static Mnemonic Cl1invmb;
    
public static Mnemonic Clac;
    
public static Mnemonic Clc;
    
public static Mnemonic Cld;
    
public static Mnemonic Cldemote;
    
public static Mnemonic Clflush;
    
public static Mnemonic Clflushopt;
    
public static Mnemonic Clgi;
    
public static Mnemonic Cli;
    
public static Mnemonic Clrssbsy;
    
public static Mnemonic Clts;
    
public static Mnemonic Clwb;
    
public static Mnemonic Clzero;
    
public static Mnemonic Cmc;
    
public static Mnemonic Cmova;
    
public static Mnemonic Cmovae;
    
public static Mnemonic Cmovb;
    
public static Mnemonic Cmovbe;
    
public static Mnemonic Cmove;
    
public static Mnemonic Cmovg;
    
public static Mnemonic Cmovge;
    
public static Mnemonic Cmovl;
    
public static Mnemonic Cmovle;
    
public static Mnemonic Cmovne;
    
public static Mnemonic Cmovno;
    
public static Mnemonic Cmovnp;
    
public static Mnemonic Cmovns;
    
public static Mnemonic Cmovo;
    
public static Mnemonic Cmovp;
    
public static Mnemonic Cmovs;
    
public static Mnemonic Cmp;
    
public static Mnemonic Cmppd;
    
public static Mnemonic Cmpps;
    
public static Mnemonic Cmpsb;
    
public static Mnemonic Cmpsd;
    
public static Mnemonic Cmpsq;
    
public static Mnemonic Cmpss;
    
public static Mnemonic Cmpsw;
    
public static Mnemonic Cmpxchg;
    
public static Mnemonic Cmpxchg16b;
    
public static Mnemonic Cmpxchg8b;
    
public static Mnemonic Comisd;
    
public static Mnemonic Comiss;
    
public static Mnemonic Cpuid;
    
public static Mnemonic Cqo;
    
public static Mnemonic Crc32;
    
public static Mnemonic Cvtdq2pd;
    
public static Mnemonic Cvtdq2ps;
    
public static Mnemonic Cvtpd2dq;
    
public static Mnemonic Cvtpd2pi;
    
public static Mnemonic Cvtpd2ps;
    
public static Mnemonic Cvtpi2pd;
    
public static Mnemonic Cvtpi2ps;
    
public static Mnemonic Cvtps2dq;
    
public static Mnemonic Cvtps2pd;
    
public static Mnemonic Cvtps2pi;
    
public static Mnemonic Cvtsd2si;
    
public static Mnemonic Cvtsd2ss;
    
public static Mnemonic Cvtsi2sd;
    
public static Mnemonic Cvtsi2ss;
    
public static Mnemonic Cvtss2sd;
    
public static Mnemonic Cvtss2si;
    
public static Mnemonic Cvttpd2dq;
    
public static Mnemonic Cvttpd2pi;
    
public static Mnemonic Cvttps2dq;
    
public static Mnemonic Cvttps2pi;
    
public static Mnemonic Cvttsd2si;
    
public static Mnemonic Cvttss2si;
    
public static Mnemonic Cwd;
    
public static Mnemonic Cwde;
    
public static Mnemonic Daa;
    
public static Mnemonic Das;
    
public static Mnemonic Db;
    
public static Mnemonic Dd;
    
public static Mnemonic Dec;
    
public static Mnemonic Div;
    
public static Mnemonic Divpd;
    
public static Mnemonic Divps;
    
public static Mnemonic Divsd;
    
public static Mnemonic Divss;
    
public static Mnemonic Dppd;
    
public static Mnemonic Dpps;
    
public static Mnemonic Dq;
    
public static Mnemonic Dw;
    
public static Mnemonic Emms;
    
public static Mnemonic Encls;
    
public static Mnemonic Enclu;
    
public static Mnemonic Enclv;
    
public static Mnemonic Endbr32;
    
public static Mnemonic Endbr64;
    
public static Mnemonic Enqcmd;
    
public static Mnemonic Enqcmds;
    
public static Mnemonic Enter;
    
public static Mnemonic Extractps;
    
public static Mnemonic Extrq;
    
public static Mnemonic F2xm1;
    
public static Mnemonic Fabs;
    
public static Mnemonic Fadd;
    
public static Mnemonic Faddp;
    
public static Mnemonic Fbld;
    
public static Mnemonic Fbstp;
    
public static Mnemonic Fchs;
    
public static Mnemonic Fclex;
    
public static Mnemonic Fcmovb;
    
public static Mnemonic Fcmovbe;
    
public static Mnemonic Fcmove;
    
public static Mnemonic Fcmovnb;
    
public static Mnemonic Fcmovnbe;
    
public static Mnemonic Fcmovne;
    
public static Mnemonic Fcmovnu;
    
public static Mnemonic Fcmovu;
    
public static Mnemonic Fcom;
    
public static Mnemonic Fcomi;
    
public static Mnemonic Fcomip;
    
public static Mnemonic Fcomp;
    
public static Mnemonic Fcompp;
    
public static Mnemonic Fcos;
    
public static Mnemonic Fdecstp;
    
public static Mnemonic Fdisi;
    
public static Mnemonic Fdiv;
    
public static Mnemonic Fdivp;
    
public static Mnemonic Fdivr;
    
public static Mnemonic Fdivrp;
    
public static Mnemonic Femms;
    
public static Mnemonic Feni;
    
public static Mnemonic Ffree;
    
public static Mnemonic Ffreep;
    
public static Mnemonic Fiadd;
    
public static Mnemonic Ficom;
    
public static Mnemonic Ficomp;
    
public static Mnemonic Fidiv;
    
public static Mnemonic Fidivr;
    
public static Mnemonic Fild;
    
public static Mnemonic Fimul;
    
public static Mnemonic Fincstp;
    
public static Mnemonic Finit;
    
public static Mnemonic Fist;
    
public static Mnemonic Fistp;
    
public static Mnemonic Fisttp;
    
public static Mnemonic Fisub;
    
public static Mnemonic Fisubr;
    
public static Mnemonic Fld;
    
public static Mnemonic Fld1;
    
public static Mnemonic Fldcw;
    
public static Mnemonic Fldenv;
    
public static Mnemonic Fldl2e;
    
public static Mnemonic Fldl2t;
    
public static Mnemonic Fldlg2;
    
public static Mnemonic Fldln2;
    
public static Mnemonic Fldpi;
    
public static Mnemonic Fldz;
    
public static Mnemonic Fmul;
    
public static Mnemonic Fmulp;
    
public static Mnemonic Fnclex;
    
public static Mnemonic Fndisi;
    
public static Mnemonic Fneni;
    
public static Mnemonic Fninit;
    
public static Mnemonic Fnop;
    
public static Mnemonic Fnsave;
    
public static Mnemonic Fnsetpm;
    
public static Mnemonic Fnstcw;
    
public static Mnemonic Fnstenv;
    
public static Mnemonic Fnstsw;
    
public static Mnemonic Fpatan;
    
public static Mnemonic Fprem;
    
public static Mnemonic Fprem1;
    
public static Mnemonic Fptan;
    
public static Mnemonic Frndint;
    
public static Mnemonic Frstor;
    
public static Mnemonic Frstpm;
    
public static Mnemonic Fsave;
    
public static Mnemonic Fscale;
    
public static Mnemonic Fsetpm;
    
public static Mnemonic Fsin;
    
public static Mnemonic Fsincos;
    
public static Mnemonic Fsqrt;
    
public static Mnemonic Fst;
    
public static Mnemonic Fstcw;
    
public static Mnemonic Fstdw;
    
public static Mnemonic Fstenv;
    
public static Mnemonic Fstp;
    
public static Mnemonic Fstpnce;
    
public static Mnemonic Fstsg;
    
public static Mnemonic Fstsw;
    
public static Mnemonic Fsub;
    
public static Mnemonic Fsubp;
    
public static Mnemonic Fsubr;
    
public static Mnemonic Fsubrp;
    
public static Mnemonic Ftst;
    
public static Mnemonic Fucom;
    
public static Mnemonic Fucomi;
    
public static Mnemonic Fucomip;
    
public static Mnemonic Fucomp;
    
public static Mnemonic Fucompp;
    
public static Mnemonic Fxam;
    
public static Mnemonic Fxch;
    
public static Mnemonic Fxrstor;
    
public static Mnemonic Fxrstor64;
    
public static Mnemonic Fxsave;
    
public static Mnemonic Fxsave64;
    
public static Mnemonic Fxtract;
    
public static Mnemonic Fyl2x;
    
public static Mnemonic Fyl2xp1;
    
public static Mnemonic Getsec;
    
public static Mnemonic Gf2p8affineinvqb;
    
public static Mnemonic Gf2p8affineqb;
    
public static Mnemonic Gf2p8mulb;
    
public static Mnemonic Haddpd;
    
public static Mnemonic Haddps;
    
public static Mnemonic Hlt;
    
public static Mnemonic Hsubpd;
    
public static Mnemonic Hsubps;
    
public static Mnemonic Ibts;
    
public static Mnemonic Idiv;
    
public static Mnemonic Imul;
    
public static Mnemonic In;
    
public static Mnemonic Inc;
    
public static Mnemonic Incsspd;
    
public static Mnemonic Incsspq;
    
public static Mnemonic Insb;
    
public static Mnemonic Insd;
    
public static Mnemonic Insertps;
    
public static Mnemonic Insertq;
    
public static Mnemonic Insw;
    
public static Mnemonic Int;
    
public static Mnemonic Int1;
    
public static Mnemonic Into;
    
public static Mnemonic Invd;
    
public static Mnemonic Invept;
    
public static Mnemonic Invlpg;
    
public static Mnemonic Invlpga;
    
public static Mnemonic Invpcid;
    
public static Mnemonic Invvpid;
    
public static Mnemonic Iret;
    
public static Mnemonic Ja;
    
public static Mnemonic Jae;
    
public static Mnemonic Jb;
    
public static Mnemonic Jbe;
    
public static Mnemonic Jcxz;
    
public static Mnemonic Je;
    
public static Mnemonic Jecxz;
    
public static Mnemonic Jg;
    
public static Mnemonic Jge;
    
public static Mnemonic Jl;
    
public static Mnemonic Jle;
    
public static Mnemonic Jmp;
    
public static Mnemonic Jmpe;
    
public static Mnemonic Jne;
    
public static Mnemonic Jno;
    
public static Mnemonic Jnp;
    
public static Mnemonic Jns;
    
public static Mnemonic Jo;
    
public static Mnemonic Jp;
    
public static Mnemonic Jrcxz;
    
public static Mnemonic Js;
    
public static Mnemonic Kaddb;
    
public static Mnemonic Kaddd;
    
public static Mnemonic Kaddq;
    
public static Mnemonic Kaddw;
    
public static Mnemonic Kandb;
    
public static Mnemonic Kandd;
    
public static Mnemonic Kandnb;
    
public static Mnemonic Kandnd;
    
public static Mnemonic Kandnq;
    
public static Mnemonic Kandnw;
    
public static Mnemonic Kandq;
    
public static Mnemonic Kandw;
    
public static Mnemonic Kmovb;
    
public static Mnemonic Kmovd;
    
public static Mnemonic Kmovq;
    
public static Mnemonic Kmovw;
    
public static Mnemonic Knotb;
    
public static Mnemonic Knotd;
    
public static Mnemonic Knotq;
    
public static Mnemonic Knotw;
    
public static Mnemonic Korb;
    
public static Mnemonic Kord;
    
public static Mnemonic Korq;
    
public static Mnemonic Kortestb;
    
public static Mnemonic Kortestd;
    
public static Mnemonic Kortestq;
    
public static Mnemonic Kortestw;
    
public static Mnemonic Korw;
    
public static Mnemonic Kshiftlb;
    
public static Mnemonic Kshiftld;
    
public static Mnemonic Kshiftlq;
    
public static Mnemonic Kshiftlw;
    
public static Mnemonic Kshiftrb;
    
public static Mnemonic Kshiftrd;
    
public static Mnemonic Kshiftrq;
    
public static Mnemonic Kshiftrw;
    
public static Mnemonic Ktestb;
    
public static Mnemonic Ktestd;
    
public static Mnemonic Ktestq;
    
public static Mnemonic Ktestw;
    
public static Mnemonic Kunpckbw;
    
public static Mnemonic Kunpckdq;
    
public static Mnemonic Kunpckwd;
    
public static Mnemonic Kxnorb;
    
public static Mnemonic Kxnord;
    
public static Mnemonic Kxnorq;
    
public static Mnemonic Kxnorw;
    
public static Mnemonic Kxorb;
    
public static Mnemonic Kxord;
    
public static Mnemonic Kxorq;
    
public static Mnemonic Kxorw;
    
public static Mnemonic Lahf;
    
public static Mnemonic Lar;
    
public static Mnemonic Lddqu;
    
public static Mnemonic Ldmxcsr;
    
public static Mnemonic Lds;
    
public static Mnemonic Lea;
    
public static Mnemonic Leave;
    
public static Mnemonic Les;
    
public static Mnemonic Lfence;
    
public static Mnemonic Lfs;
    
public static Mnemonic Lgdt;
    
public static Mnemonic Lgs;
    
public static Mnemonic Lidt;
    
public static Mnemonic Lldt;
    
public static Mnemonic Llwpcb;
    
public static Mnemonic Lmsw;
    
public static Mnemonic Loadall;
    
public static Mnemonic Lodsb;
    
public static Mnemonic Lodsd;
    
public static Mnemonic Lodsq;
    
public static Mnemonic Lodsw;
    
public static Mnemonic Loop;
    
public static Mnemonic Loope;
    
public static Mnemonic Loopne;
    
public static Mnemonic Lsl;
    
public static Mnemonic Lss;
    
public static Mnemonic Ltr;
    
public static Mnemonic Lwpins;
    
public static Mnemonic Lwpval;
    
public static Mnemonic Lzcnt;
    
public static Mnemonic Maskmovdqu;
    
public static Mnemonic Maskmovq;
    
public static Mnemonic Maxpd;
    
public static Mnemonic Maxps;
    
public static Mnemonic Maxsd;
    
public static Mnemonic Maxss;
    
public static Mnemonic Mcommit;
    
public static Mnemonic Mfence;
    
public static Mnemonic Minpd;
    
public static Mnemonic Minps;
    
public static Mnemonic Minsd;
    
public static Mnemonic Minss;
    
public static Mnemonic Monitor;
    
public static Mnemonic Monitorx;
    
public static Mnemonic Montmul;
    
public static Mnemonic Mov;
    
public static Mnemonic Movapd;
    
public static Mnemonic Movaps;
    
public static Mnemonic Movbe;
    
public static Mnemonic Movd;
    
public static Mnemonic Movddup;
    
public static Mnemonic Movdir64b;
    
public static Mnemonic Movdiri;
    
public static Mnemonic Movdq2q;
    
public static Mnemonic Movdqa;
    
public static Mnemonic Movdqu;
    
public static Mnemonic Movhlps;
    
public static Mnemonic Movhpd;
    
public static Mnemonic Movhps;
    
public static Mnemonic Movlhps;
    
public static Mnemonic Movlpd;
    
public static Mnemonic Movlps;
    
public static Mnemonic Movmskpd;
    
public static Mnemonic Movmskps;
    
public static Mnemonic Movntdq;
    
public static Mnemonic Movntdqa;
    
public static Mnemonic Movnti;
    
public static Mnemonic Movntpd;
    
public static Mnemonic Movntps;
    
public static Mnemonic Movntq;
    
public static Mnemonic Movntsd;
    
public static Mnemonic Movntss;
    
public static Mnemonic Movq;
    
public static Mnemonic Movq2dq;
    
public static Mnemonic Movsb;
    
public static Mnemonic Movsd;
    
public static Mnemonic Movshdup;
    
public static Mnemonic Movsldup;
    
public static Mnemonic Movsq;
    
public static Mnemonic Movss;
    
public static Mnemonic Movsw;
    
public static Mnemonic Movsx;
    
public static Mnemonic Movsxd;
    
public static Mnemonic Movupd;
    
public static Mnemonic Movups;
    
public static Mnemonic Movzx;
    
public static Mnemonic Mpsadbw;
    
public static Mnemonic Mul;
    
public static Mnemonic Mulpd;
    
public static Mnemonic Mulps;
    
public static Mnemonic Mulsd;
    
public static Mnemonic Mulss;
    
public static Mnemonic Mulx;
    
public static Mnemonic Mwait;
    
public static Mnemonic Mwaitx;
    
public static Mnemonic Neg;
    
public static Mnemonic Nop;
    
public static Mnemonic Not;
    
public static Mnemonic Or;
    
public static Mnemonic Orpd;
    
public static Mnemonic Orps;
    
public static Mnemonic Out;
    
public static Mnemonic Outsb;
    
public static Mnemonic Outsd;
    
public static Mnemonic Outsw;
    
public static Mnemonic Pabsb;
    
public static Mnemonic Pabsd;
    
public static Mnemonic Pabsw;
    
public static Mnemonic Packssdw;
    
public static Mnemonic Packsswb;
    
public static Mnemonic Packusdw;
    
public static Mnemonic Packuswb;
    
public static Mnemonic Paddb;
    
public static Mnemonic Paddd;
    
public static Mnemonic Paddq;
    
public static Mnemonic Paddsb;
    
public static Mnemonic Paddsw;
    
public static Mnemonic Paddusb;
    
public static Mnemonic Paddusw;
    
public static Mnemonic Paddw;
    
public static Mnemonic Palignr;
    
public static Mnemonic Pand;
    
public static Mnemonic Pandn;
    
public static Mnemonic Pause;
    
public static Mnemonic Pavgb;
    
public static Mnemonic Pavgusb;
    
public static Mnemonic Pavgw;
    
public static Mnemonic Pblendvb;
    
public static Mnemonic Pblendw;
    
public static Mnemonic Pclmulqdq;
    
public static Mnemonic Pcmpeqb;
    
public static Mnemonic Pcmpeqd;
    
public static Mnemonic Pcmpeqq;
    
public static Mnemonic Pcmpeqw;
    
public static Mnemonic Pcmpestri;
    
public static Mnemonic Pcmpestri64;
    
public static Mnemonic Pcmpestrm;
    
public static Mnemonic Pcmpestrm64;
    
public static Mnemonic Pcmpgtb;
    
public static Mnemonic Pcmpgtd;
    
public static Mnemonic Pcmpgtq;
    
public static Mnemonic Pcmpgtw;
    
public static Mnemonic Pcmpistri;
    
public static Mnemonic Pcmpistrm;
    
public static Mnemonic Pcommit;
    
public static Mnemonic Pconfig;
    
public static Mnemonic Pdep;
    
public static Mnemonic Pext;
    
public static Mnemonic Pextrb;
    
public static Mnemonic Pextrd;
    
public static Mnemonic Pextrq;
    
public static Mnemonic Pextrw;
    
public static Mnemonic Pf2id;
    
public static Mnemonic Pf2iw;
    
public static Mnemonic Pfacc;
    
public static Mnemonic Pfadd;
    
public static Mnemonic Pfcmpeq;
    
public static Mnemonic Pfcmpge;
    
public static Mnemonic Pfcmpgt;
    
public static Mnemonic Pfmax;
    
public static Mnemonic Pfmin;
    
public static Mnemonic Pfmul;
    
public static Mnemonic Pfnacc;
    
public static Mnemonic Pfpnacc;
    
public static Mnemonic Pfrcp;
    
public static Mnemonic Pfrcpit1;
    
public static Mnemonic Pfrcpit2;
    
public static Mnemonic Pfrcpv;
    
public static Mnemonic Pfrsqit1;
    
public static Mnemonic Pfrsqrt;
    
public static Mnemonic Pfrsqrtv;
    
public static Mnemonic Pfsub;
    
public static Mnemonic Pfsubr;
    
public static Mnemonic Phaddd;
    
public static Mnemonic Phaddsw;
    
public static Mnemonic Phaddw;
    
public static Mnemonic Phminposuw;
    
public static Mnemonic Phsubd;
    
public static Mnemonic Phsubsw;
    
public static Mnemonic Phsubw;
    
public static Mnemonic Pi2fd;
    
public static Mnemonic Pi2fw;
    
public static Mnemonic Pinsrb;
    
public static Mnemonic Pinsrd;
    
public static Mnemonic Pinsrq;
    
public static Mnemonic Pinsrw;
    
public static Mnemonic Pmaddubsw;
    
public static Mnemonic Pmaddwd;
    
public static Mnemonic Pmaxsb;
    
public static Mnemonic Pmaxsd;
    
public static Mnemonic Pmaxsw;
    
public static Mnemonic Pmaxub;
    
public static Mnemonic Pmaxud;
    
public static Mnemonic Pmaxuw;
    
public static Mnemonic Pminsb;
    
public static Mnemonic Pminsd;
    
public static Mnemonic Pminsw;
    
public static Mnemonic Pminub;
    
public static Mnemonic Pminud;
    
public static Mnemonic Pminuw;
    
public static Mnemonic Pmovmskb;
    
public static Mnemonic Pmovsxbd;
    
public static Mnemonic Pmovsxbq;
    
public static Mnemonic Pmovsxbw;
    
public static Mnemonic Pmovsxdq;
    
public static Mnemonic Pmovsxwd;
    
public static Mnemonic Pmovsxwq;
    
public static Mnemonic Pmovzxbd;
    
public static Mnemonic Pmovzxbq;
    
public static Mnemonic Pmovzxbw;
    
public static Mnemonic Pmovzxdq;
    
public static Mnemonic Pmovzxwd;
    
public static Mnemonic Pmovzxwq;
    
public static Mnemonic Pmuldq;
    
public static Mnemonic Pmulhrsw;
    
public static Mnemonic Pmulhrw;
    
public static Mnemonic Pmulhuw;
    
public static Mnemonic Pmulhw;
    
public static Mnemonic Pmulld;
    
public static Mnemonic Pmullw;
    
public static Mnemonic Pmuludq;
    
public static Mnemonic Pop;
    
public static Mnemonic Popa;
    
public static Mnemonic Popcnt;
    
public static Mnemonic Popf;
    
public static Mnemonic Por;
    
public static Mnemonic Prefetch;
    
public static Mnemonic Prefetchnta;
    
public static Mnemonic Prefetcht0;
    
public static Mnemonic Prefetcht1;
    
public static Mnemonic Prefetcht2;
    
public static Mnemonic Prefetchw;
    
public static Mnemonic Prefetchwt1;
    
public static Mnemonic Psadbw;
    
public static Mnemonic Pshufb;
    
public static Mnemonic Pshufd;
    
public static Mnemonic Pshufhw;
    
public static Mnemonic Pshuflw;
    
public static Mnemonic Pshufw;
    
public static Mnemonic Psignb;
    
public static Mnemonic Psignd;
    
public static Mnemonic Psignw;
    
public static Mnemonic Pslld;
    
public static Mnemonic Pslldq;
    
public static Mnemonic Psllq;
    
public static Mnemonic Psllw;
    
public static Mnemonic Psrad;
    
public static Mnemonic Psraw;
    
public static Mnemonic Psrld;
    
public static Mnemonic Psrldq;
    
public static Mnemonic Psrlq;
    
public static Mnemonic Psrlw;
    
public static Mnemonic Psubb;
    
public static Mnemonic Psubd;
    
public static Mnemonic Psubq;
    
public static Mnemonic Psubsb;
    
public static Mnemonic Psubsw;
    
public static Mnemonic Psubusb;
    
public static Mnemonic Psubusw;
    
public static Mnemonic Psubw;
    
public static Mnemonic Pswapd;
    
public static Mnemonic Ptest;
    
public static Mnemonic Ptwrite;
    
public static Mnemonic Punpckhbw;
    
public static Mnemonic Punpckhdq;
    
public static Mnemonic Punpckhqdq;
    
public static Mnemonic Punpckhwd;
    
public static Mnemonic Punpcklbw;
    
public static Mnemonic Punpckldq;
    
public static Mnemonic Punpcklqdq;
    
public static Mnemonic Punpcklwd;
    
public static Mnemonic Push;
    
public static Mnemonic Pusha;
    
public static Mnemonic Pushf;
    
public static Mnemonic Pxor;
    
public static Mnemonic Rcl;
    
public static Mnemonic Rcpps;
    
public static Mnemonic Rcpss;
    
public static Mnemonic Rcr;
    
public static Mnemonic Rdfsbase;
    
public static Mnemonic Rdgsbase;
    
public static Mnemonic Rdmsr;
    
public static Mnemonic Rdpid;
    
public static Mnemonic Rdpkru;
    
public static Mnemonic Rdpmc;
    
public static Mnemonic Rdpru;
    
public static Mnemonic Rdrand;
    
public static Mnemonic Rdseed;
    
public static Mnemonic Rdsspd;
    
public static Mnemonic Rdsspq;
    
public static Mnemonic Rdtsc;
    
public static Mnemonic Rdtscp;
    
public static Mnemonic Reservednop;
    
public static Mnemonic Ret;
    
public static Mnemonic Retf;
    
public static Mnemonic Rol;
    
public static Mnemonic Ror;
    
public static Mnemonic Rorx;
    
public static Mnemonic Roundpd;
    
public static Mnemonic Roundps;
    
public static Mnemonic Roundsd;
    
public static Mnemonic Roundss;
    
public static Mnemonic Rsm;
    
public static Mnemonic Rsqrtps;
    
public static Mnemonic Rsqrtss;
    
public static Mnemonic Rstorssp;
    
public static Mnemonic Sahf;
    
public static Mnemonic Sal;
    
public static Mnemonic Salc;
    
public static Mnemonic Sar;
    
public static Mnemonic Sarx;
    
public static Mnemonic Saveprevssp;
    
public static Mnemonic Sbb;
    
public static Mnemonic Scasb;
    
public static Mnemonic Scasd;
    
public static Mnemonic Scasq;
    
public static Mnemonic Scasw;
    
public static Mnemonic Seta;
    
public static Mnemonic Setae;
    
public static Mnemonic Setb;
    
public static Mnemonic Setbe;
    
public static Mnemonic Sete;
    
public static Mnemonic Setg;
    
public static Mnemonic Setge;
    
public static Mnemonic Setl;
    
public static Mnemonic Setle;
    
public static Mnemonic Setne;
    
public static Mnemonic Setno;
    
public static Mnemonic Setnp;
    
public static Mnemonic Setns;
    
public static Mnemonic Seto;
    
public static Mnemonic Setp;
    
public static Mnemonic Sets;
    
public static Mnemonic Setssbsy;
    
public static Mnemonic Sfence;
    
public static Mnemonic Sgdt;
    
public static Mnemonic Sha1msg1;
    
public static Mnemonic Sha1msg2;
    
public static Mnemonic Sha1nexte;
    
public static Mnemonic Sha1rnds4;
    
public static Mnemonic Sha256msg1;
    
public static Mnemonic Sha256msg2;
    
public static Mnemonic Sha256rnds2;
    
public static Mnemonic Shl;
    
public static Mnemonic Shld;
    
public static Mnemonic Shlx;
    
public static Mnemonic Shr;
    
public static Mnemonic Shrd;
    
public static Mnemonic Shrx;
    
public static Mnemonic Shufpd;
    
public static Mnemonic Shufps;
    
public static Mnemonic Sidt;
    
public static Mnemonic Skinit;
    
public static Mnemonic Sldt;
    
public static Mnemonic Slwpcb;
    
public static Mnemonic Smsw;
    
public static Mnemonic Sqrtpd;
    
public static Mnemonic Sqrtps;
    
public static Mnemonic Sqrtsd;
    
public static Mnemonic Sqrtss;
    
public static Mnemonic Stac;
    
public static Mnemonic Stc;
    
public static Mnemonic Std;
    
public static Mnemonic Stgi;
    
public static Mnemonic Sti;
    
public static Mnemonic Stmxcsr;
    
public static Mnemonic Stosb;
    
public static Mnemonic Stosd;
    
public static Mnemonic Stosq;
    
public static Mnemonic Stosw;
    
public static Mnemonic Str;
    
public static Mnemonic Sub;
    
public static Mnemonic Subpd;
    
public static Mnemonic Subps;
    
public static Mnemonic Subsd;
    
public static Mnemonic Subss;
    
public static Mnemonic Swapgs;
    
public static Mnemonic Syscall;
    
public static Mnemonic Sysenter;
    
public static Mnemonic Sysexit;
    
public static Mnemonic Sysret;
    
public static Mnemonic T1mskc;
    
public static Mnemonic Test;
    
public static Mnemonic Tpause;
    
public static Mnemonic Tzcnt;
    
public static Mnemonic Tzmsk;
    
public static Mnemonic Ucomisd;
    
public static Mnemonic Ucomiss;
    
public static Mnemonic Ud0;
    
public static Mnemonic Ud1;
    
public static Mnemonic Ud2;
    
public static Mnemonic Umonitor;
    
public static Mnemonic Umov;
    
public static Mnemonic Umwait;
    
public static Mnemonic Unpckhpd;
    
public static Mnemonic Unpckhps;
    
public static Mnemonic Unpcklpd;
    
public static Mnemonic Unpcklps;
    
public static Mnemonic V4fmaddps;
    
public static Mnemonic V4fmaddss;
    
public static Mnemonic V4fnmaddps;
    
public static Mnemonic V4fnmaddss;
    
public static Mnemonic Vaddpd;
    
public static Mnemonic Vaddps;
    
public static Mnemonic Vaddsd;
    
public static Mnemonic Vaddss;
    
public static Mnemonic Vaddsubpd;
    
public static Mnemonic Vaddsubps;
    
public static Mnemonic Vaesdec;
    
public static Mnemonic Vaesdeclast;
    
public static Mnemonic Vaesenc;
    
public static Mnemonic Vaesenclast;
    
public static Mnemonic Vaesimc;
    
public static Mnemonic Vaeskeygenassist;
    
public static Mnemonic Valignd;
    
public static Mnemonic Valignq;
    
public static Mnemonic Vandnpd;
    
public static Mnemonic Vandnps;
    
public static Mnemonic Vandpd;
    
public static Mnemonic Vandps;
    
public static Mnemonic Vblendmpd;
    
public static Mnemonic Vblendmps;
    
public static Mnemonic Vblendpd;
    
public static Mnemonic Vblendps;
    
public static Mnemonic Vblendvpd;
    
public static Mnemonic Vblendvps;
    
public static Mnemonic Vbroadcastf128;
    
public static Mnemonic Vbroadcastf32x2;
    
public static Mnemonic Vbroadcastf32x4;
    
public static Mnemonic Vbroadcastf32x8;
    
public static Mnemonic Vbroadcastf64x2;
    
public static Mnemonic Vbroadcastf64x4;
    
public static Mnemonic Vbroadcasti128;
    
public static Mnemonic Vbroadcasti32x2;
    
public static Mnemonic Vbroadcasti32x4;
    
public static Mnemonic Vbroadcasti32x8;
    
public static Mnemonic Vbroadcasti64x2;
    
public static Mnemonic Vbroadcasti64x4;
    
public static Mnemonic Vbroadcastsd;
    
public static Mnemonic Vbroadcastss;
    
public static Mnemonic Vcmppd;
    
public static Mnemonic Vcmpps;
    
public static Mnemonic Vcmpsd;
    
public static Mnemonic Vcmpss;
    
public static Mnemonic Vcomisd;
    
public static Mnemonic Vcomiss;
    
public static Mnemonic Vcompresspd;
    
public static Mnemonic Vcompressps;
    
public static Mnemonic Vcvtdq2pd;
    
public static Mnemonic Vcvtdq2ps;
    
public static Mnemonic Vcvtne2ps2bf16;
    
public static Mnemonic Vcvtneps2bf16;
    
public static Mnemonic Vcvtpd2dq;
    
public static Mnemonic Vcvtpd2ps;
    
public static Mnemonic Vcvtpd2qq;
    
public static Mnemonic Vcvtpd2udq;
    
public static Mnemonic Vcvtpd2uqq;
    
public static Mnemonic Vcvtph2ps;
    
public static Mnemonic Vcvtps2dq;
    
public static Mnemonic Vcvtps2pd;
    
public static Mnemonic Vcvtps2ph;
    
public static Mnemonic Vcvtps2qq;
    
public static Mnemonic Vcvtps2udq;
    
public static Mnemonic Vcvtps2uqq;
    
public static Mnemonic Vcvtqq2pd;
    
public static Mnemonic Vcvtqq2ps;
    
public static Mnemonic Vcvtsd2si;
    
public static Mnemonic Vcvtsd2ss;
    
public static Mnemonic Vcvtsd2usi;
    
public static Mnemonic Vcvtsi2sd;
    
public static Mnemonic Vcvtsi2ss;
    
public static Mnemonic Vcvtss2sd;
    
public static Mnemonic Vcvtss2si;
    
public static Mnemonic Vcvtss2usi;
    
public static Mnemonic Vcvttpd2dq;
    
public static Mnemonic Vcvttpd2qq;
    
public static Mnemonic Vcvttpd2udq;
    
public static Mnemonic Vcvttpd2uqq;
    
public static Mnemonic Vcvttps2dq;
    
public static Mnemonic Vcvttps2qq;
    
public static Mnemonic Vcvttps2udq;
    
public static Mnemonic Vcvttps2uqq;
    
public static Mnemonic Vcvttsd2si;
    
public static Mnemonic Vcvttsd2usi;
    
public static Mnemonic Vcvttss2si;
    
public static Mnemonic Vcvttss2usi;
    
public static Mnemonic Vcvtudq2pd;
    
public static Mnemonic Vcvtudq2ps;
    
public static Mnemonic Vcvtuqq2pd;
    
public static Mnemonic Vcvtuqq2ps;
    
public static Mnemonic Vcvtusi2sd;
    
public static Mnemonic Vcvtusi2ss;
    
public static Mnemonic Vdbpsadbw;
    
public static Mnemonic Vdivpd;
    
public static Mnemonic Vdivps;
    
public static Mnemonic Vdivsd;
    
public static Mnemonic Vdivss;
    
public static Mnemonic Vdpbf16ps;
    
public static Mnemonic Vdppd;
    
public static Mnemonic Vdpps;
    
public static Mnemonic Verr;
    
public static Mnemonic Verw;
    
public static Mnemonic Vexp2pd;
    
public static Mnemonic Vexp2ps;
    
public static Mnemonic Vexpandpd;
    
public static Mnemonic Vexpandps;
    
public static Mnemonic Vextractf128;
    
public static Mnemonic Vextractf32x4;
    
public static Mnemonic Vextractf32x8;
    
public static Mnemonic Vextractf64x2;
    
public static Mnemonic Vextractf64x4;
    
public static Mnemonic Vextracti128;
    
public static Mnemonic Vextracti32x4;
    
public static Mnemonic Vextracti32x8;
    
public static Mnemonic Vextracti64x2;
    
public static Mnemonic Vextracti64x4;
    
public static Mnemonic Vextractps;
    
public static Mnemonic Vfixupimmpd;
    
public static Mnemonic Vfixupimmps;
    
public static Mnemonic Vfixupimmsd;
    
public static Mnemonic Vfixupimmss;
    
public static Mnemonic Vfmadd132pd;
    
public static Mnemonic Vfmadd132ps;
    
public static Mnemonic Vfmadd132sd;
    
public static Mnemonic Vfmadd132ss;
    
public static Mnemonic Vfmadd213pd;
    
public static Mnemonic Vfmadd213ps;
    
public static Mnemonic Vfmadd213sd;
    
public static Mnemonic Vfmadd213ss;
    
public static Mnemonic Vfmadd231pd;
    
public static Mnemonic Vfmadd231ps;
    
public static Mnemonic Vfmadd231sd;
    
public static Mnemonic Vfmadd231ss;
    
public static Mnemonic Vfmaddpd;
    
public static Mnemonic Vfmaddps;
    
public static Mnemonic Vfmaddsd;
    
public static Mnemonic Vfmaddss;
    
public static Mnemonic Vfmaddsub132pd;
    
public static Mnemonic Vfmaddsub132ps;
    
public static Mnemonic Vfmaddsub213pd;
    
public static Mnemonic Vfmaddsub213ps;
    
public static Mnemonic Vfmaddsub231pd;
    
public static Mnemonic Vfmaddsub231ps;
    
public static Mnemonic Vfmaddsubpd;
    
public static Mnemonic Vfmaddsubps;
    
public static Mnemonic Vfmsub132pd;
    
public static Mnemonic Vfmsub132ps;
    
public static Mnemonic Vfmsub132sd;
    
public static Mnemonic Vfmsub132ss;
    
public static Mnemonic Vfmsub213pd;
    
public static Mnemonic Vfmsub213ps;
    
public static Mnemonic Vfmsub213sd;
    
public static Mnemonic Vfmsub213ss;
    
public static Mnemonic Vfmsub231pd;
    
public static Mnemonic Vfmsub231ps;
    
public static Mnemonic Vfmsub231sd;
    
public static Mnemonic Vfmsub231ss;
    
public static Mnemonic Vfmsubadd132pd;
    
public static Mnemonic Vfmsubadd132ps;
    
public static Mnemonic Vfmsubadd213pd;
    
public static Mnemonic Vfmsubadd213ps;
    
public static Mnemonic Vfmsubadd231pd;
    
public static Mnemonic Vfmsubadd231ps;
    
public static Mnemonic Vfmsubaddpd;
    
public static Mnemonic Vfmsubaddps;
    
public static Mnemonic Vfmsubpd;
    
public static Mnemonic Vfmsubps;
    
public static Mnemonic Vfmsubsd;
    
public static Mnemonic Vfmsubss;
    
public static Mnemonic Vfnmadd132pd;
    
public static Mnemonic Vfnmadd132ps;
    
public static Mnemonic Vfnmadd132sd;
    
public static Mnemonic Vfnmadd132ss;
    
public static Mnemonic Vfnmadd213pd;
    
public static Mnemonic Vfnmadd213ps;
    
public static Mnemonic Vfnmadd213sd;
    
public static Mnemonic Vfnmadd213ss;
    
public static Mnemonic Vfnmadd231pd;
    
public static Mnemonic Vfnmadd231ps;
    
public static Mnemonic Vfnmadd231sd;
    
public static Mnemonic Vfnmadd231ss;
    
public static Mnemonic Vfnmaddpd;
    
public static Mnemonic Vfnmaddps;
    
public static Mnemonic Vfnmaddsd;
    
public static Mnemonic Vfnmaddss;
    
public static Mnemonic Vfnmsub132pd;
    
public static Mnemonic Vfnmsub132ps;
    
public static Mnemonic Vfnmsub132sd;
    
public static Mnemonic Vfnmsub132ss;
    
public static Mnemonic Vfnmsub213pd;
    
public static Mnemonic Vfnmsub213ps;
    
public static Mnemonic Vfnmsub213sd;
    
public static Mnemonic Vfnmsub213ss;
    
public static Mnemonic Vfnmsub231pd;
    
public static Mnemonic Vfnmsub231ps;
    
public static Mnemonic Vfnmsub231sd;
    
public static Mnemonic Vfnmsub231ss;
    
public static Mnemonic Vfnmsubpd;
    
public static Mnemonic Vfnmsubps;
    
public static Mnemonic Vfnmsubsd;
    
public static Mnemonic Vfnmsubss;
    
public static Mnemonic Vfpclasspd;
    
public static Mnemonic Vfpclassps;
    
public static Mnemonic Vfpclasssd;
    
public static Mnemonic Vfpclassss;
    
public static Mnemonic Vfrczpd;
    
public static Mnemonic Vfrczps;
    
public static Mnemonic Vfrczsd;
    
public static Mnemonic Vfrczss;
    
public static Mnemonic Vgatherdpd;
    
public static Mnemonic Vgatherdps;
    
public static Mnemonic Vgatherpf0dpd;
    
public static Mnemonic Vgatherpf0dps;
    
public static Mnemonic Vgatherpf0qpd;
    
public static Mnemonic Vgatherpf0qps;
    
public static Mnemonic Vgatherpf1dpd;
    
public static Mnemonic Vgatherpf1dps;
    
public static Mnemonic Vgatherpf1qpd;
    
public static Mnemonic Vgatherpf1qps;
    
public static Mnemonic Vgatherqpd;
    
public static Mnemonic Vgatherqps;
    
public static Mnemonic Vgetexppd;
    
public static Mnemonic Vgetexpps;
    
public static Mnemonic Vgetexpsd;
    
public static Mnemonic Vgetexpss;
    
public static Mnemonic Vgetmantpd;
    
public static Mnemonic Vgetmantps;
    
public static Mnemonic Vgetmantsd;
    
public static Mnemonic Vgetmantss;
    
public static Mnemonic Vgf2p8affineinvqb;
    
public static Mnemonic Vgf2p8affineqb;
    
public static Mnemonic Vgf2p8mulb;
    
public static Mnemonic Vhaddpd;
    
public static Mnemonic Vhaddps;
    
public static Mnemonic Vhsubpd;
    
public static Mnemonic Vhsubps;
    
public static Mnemonic Vinsertf128;
    
public static Mnemonic Vinsertf32x4;
    
public static Mnemonic Vinsertf32x8;
    
public static Mnemonic Vinsertf64x2;
    
public static Mnemonic Vinsertf64x4;
    
public static Mnemonic Vinserti128;
    
public static Mnemonic Vinserti32x4;
    
public static Mnemonic Vinserti32x8;
    
public static Mnemonic Vinserti64x2;
    
public static Mnemonic Vinserti64x4;
    
public static Mnemonic Vinsertps;
    
public static Mnemonic Vlddqu;
    
public static Mnemonic Vldmxcsr;
    
public static Mnemonic Vmaskmovdqu;
    
public static Mnemonic Vmaskmovpd;
    
public static Mnemonic Vmaskmovps;
    
public static Mnemonic Vmaxpd;
    
public static Mnemonic Vmaxps;
    
public static Mnemonic Vmaxsd;
    
public static Mnemonic Vmaxss;
    
public static Mnemonic Vmcall;
    
public static Mnemonic Vmclear;
    
public static Mnemonic Vmfunc;
    
public static Mnemonic Vminpd;
    
public static Mnemonic Vminps;
    
public static Mnemonic Vminsd;
    
public static Mnemonic Vminss;
    
public static Mnemonic Vmlaunch;
    
public static Mnemonic Vmload;
    
public static Mnemonic Vmmcall;
    
public static Mnemonic Vmovapd;
    
public static Mnemonic Vmovaps;
    
public static Mnemonic Vmovd;
    
public static Mnemonic Vmovddup;
    
public static Mnemonic Vmovdqa;
    
public static Mnemonic Vmovdqa32;
    
public static Mnemonic Vmovdqa64;
    
public static Mnemonic Vmovdqu;
    
public static Mnemonic Vmovdqu16;
    
public static Mnemonic Vmovdqu32;
    
public static Mnemonic Vmovdqu64;
    
public static Mnemonic Vmovdqu8;
    
public static Mnemonic Vmovhlps;
    
public static Mnemonic Vmovhpd;
    
public static Mnemonic Vmovhps;
    
public static Mnemonic Vmovlhps;
    
public static Mnemonic Vmovlpd;
    
public static Mnemonic Vmovlps;
    
public static Mnemonic Vmovmskpd;
    
public static Mnemonic Vmovmskps;
    
public static Mnemonic Vmovntdq;
    
public static Mnemonic Vmovntdqa;
    
public static Mnemonic Vmovntpd;
    
public static Mnemonic Vmovntps;
    
public static Mnemonic Vmovq;
    
public static Mnemonic Vmovsd;
    
public static Mnemonic Vmovshdup;
    
public static Mnemonic Vmovsldup;
    
public static Mnemonic Vmovss;
    
public static Mnemonic Vmovupd;
    
public static Mnemonic Vmovups;
    
public static Mnemonic Vmpsadbw;
    
public static Mnemonic Vmptrld;
    
public static Mnemonic Vmptrst;
    
public static Mnemonic Vmread;
    
public static Mnemonic Vmresume;
    
public static Mnemonic Vmrun;
    
public static Mnemonic Vmsave;
    
public static Mnemonic Vmulpd;
    
public static Mnemonic Vmulps;
    
public static Mnemonic Vmulsd;
    
public static Mnemonic Vmulss;
    
public static Mnemonic Vmwrite;
    
public static Mnemonic Vmxoff;
    
public static Mnemonic Vmxon;
    
public static Mnemonic Vorpd;
    
public static Mnemonic Vorps;
    
public static Mnemonic Vp2intersectd;
    
public static Mnemonic Vp2intersectq;
    
public static Mnemonic Vp4dpwssd;
    
public static Mnemonic Vp4dpwssds;
    
public static Mnemonic Vpabsb;
    
public static Mnemonic Vpabsd;
    
public static Mnemonic Vpabsq;
    
public static Mnemonic Vpabsw;
    
public static Mnemonic Vpackssdw;
    
public static Mnemonic Vpacksswb;
    
public static Mnemonic Vpackusdw;
    
public static Mnemonic Vpackuswb;
    
public static Mnemonic Vpaddb;
    
public static Mnemonic Vpaddd;
    
public static Mnemonic Vpaddq;
    
public static Mnemonic Vpaddsb;
    
public static Mnemonic Vpaddsw;
    
public static Mnemonic Vpaddusb;
    
public static Mnemonic Vpaddusw;
    
public static Mnemonic Vpaddw;
    
public static Mnemonic Vpalignr;
    
public static Mnemonic Vpand;
    
public static Mnemonic Vpandd;
    
public static Mnemonic Vpandn;
    
public static Mnemonic Vpandnd;
    
public static Mnemonic Vpandnq;
    
public static Mnemonic Vpandq;
    
public static Mnemonic Vpavgb;
    
public static Mnemonic Vpavgw;
    
public static Mnemonic Vpblendd;
    
public static Mnemonic Vpblendmb;
    
public static Mnemonic Vpblendmd;
    
public static Mnemonic Vpblendmq;
    
public static Mnemonic Vpblendmw;
    
public static Mnemonic Vpblendvb;
    
public static Mnemonic Vpblendw;
    
public static Mnemonic Vpbroadcastb;
    
public static Mnemonic Vpbroadcastd;
    
public static Mnemonic Vpbroadcastmb2q;
    
public static Mnemonic Vpbroadcastmw2d;
    
public static Mnemonic Vpbroadcastq;
    
public static Mnemonic Vpbroadcastw;
    
public static Mnemonic Vpclmulqdq;
    
public static Mnemonic Vpcmov;
    
public static Mnemonic Vpcmpb;
    
public static Mnemonic Vpcmpd;
    
public static Mnemonic Vpcmpeqb;
    
public static Mnemonic Vpcmpeqd;
    
public static Mnemonic Vpcmpeqq;
    
public static Mnemonic Vpcmpeqw;
    
public static Mnemonic Vpcmpestri;
    
public static Mnemonic Vpcmpestri64;
    
public static Mnemonic Vpcmpestrm;
    
public static Mnemonic Vpcmpestrm64;
    
public static Mnemonic Vpcmpgtb;
    
public static Mnemonic Vpcmpgtd;
    
public static Mnemonic Vpcmpgtq;
    
public static Mnemonic Vpcmpgtw;
    
public static Mnemonic Vpcmpistri;
    
public static Mnemonic Vpcmpistrm;
    
public static Mnemonic Vpcmpq;
    
public static Mnemonic Vpcmpub;
    
public static Mnemonic Vpcmpud;
    
public static Mnemonic Vpcmpuq;
    
public static Mnemonic Vpcmpuw;
    
public static Mnemonic Vpcmpw;
    
public static Mnemonic Vpcomb;
    
public static Mnemonic Vpcomd;
    
public static Mnemonic Vpcompressb;
    
public static Mnemonic Vpcompressd;
    
public static Mnemonic Vpcompressq;
    
public static Mnemonic Vpcompressw;
    
public static Mnemonic Vpcomq;
    
public static Mnemonic Vpcomub;
    
public static Mnemonic Vpcomud;
    
public static Mnemonic Vpcomuq;
    
public static Mnemonic Vpcomuw;
    
public static Mnemonic Vpcomw;
    
public static Mnemonic Vpconflictd;
    
public static Mnemonic Vpconflictq;
    
public static Mnemonic Vpdpbusd;
    
public static Mnemonic Vpdpbusds;
    
public static Mnemonic Vpdpwssd;
    
public static Mnemonic Vpdpwssds;
    
public static Mnemonic Vperm2f128;
    
public static Mnemonic Vperm2i128;
    
public static Mnemonic Vpermb;
    
public static Mnemonic Vpermd;
    
public static Mnemonic Vpermi2b;
    
public static Mnemonic Vpermi2d;
    
public static Mnemonic Vpermi2pd;
    
public static Mnemonic Vpermi2ps;
    
public static Mnemonic Vpermi2q;
    
public static Mnemonic Vpermi2w;
    
public static Mnemonic Vpermil2pd;
    
public static Mnemonic Vpermil2ps;
    
public static Mnemonic Vpermilpd;
    
public static Mnemonic Vpermilps;
    
public static Mnemonic Vpermpd;
    
public static Mnemonic Vpermps;
    
public static Mnemonic Vpermq;
    
public static Mnemonic Vpermt2b;
    
public static Mnemonic Vpermt2d;
    
public static Mnemonic Vpermt2pd;
    
public static Mnemonic Vpermt2ps;
    
public static Mnemonic Vpermt2q;
    
public static Mnemonic Vpermt2w;
    
public static Mnemonic Vpermw;
    
public static Mnemonic Vpexpandb;
    
public static Mnemonic Vpexpandd;
    
public static Mnemonic Vpexpandq;
    
public static Mnemonic Vpexpandw;
    
public static Mnemonic Vpextrb;
    
public static Mnemonic Vpextrd;
    
public static Mnemonic Vpextrq;
    
public static Mnemonic Vpextrw;
    
public static Mnemonic Vpgatherdd;
    
public static Mnemonic Vpgatherdq;
    
public static Mnemonic Vpgatherqd;
    
public static Mnemonic Vpgatherqq;
    
public static Mnemonic Vphaddbd;
    
public static Mnemonic Vphaddbq;
    
public static Mnemonic Vphaddbw;
    
public static Mnemonic Vphaddd;
    
public static Mnemonic Vphadddq;
    
public static Mnemonic Vphaddsw;
    
public static Mnemonic Vphaddubd;
    
public static Mnemonic Vphaddubq;
    
public static Mnemonic Vphaddubw;
    
public static Mnemonic Vphaddudq;
    
public static Mnemonic Vphadduwd;
    
public static Mnemonic Vphadduwq;
    
public static Mnemonic Vphaddw;
    
public static Mnemonic Vphaddwd;
    
public static Mnemonic Vphaddwq;
    
public static Mnemonic Vphminposuw;
    
public static Mnemonic Vphsubbw;
    
public static Mnemonic Vphsubd;
    
public static Mnemonic Vphsubdq;
    
public static Mnemonic Vphsubsw;
    
public static Mnemonic Vphsubw;
    
public static Mnemonic Vphsubwd;
    
public static Mnemonic Vpinsrb;
    
public static Mnemonic Vpinsrd;
    
public static Mnemonic Vpinsrq;
    
public static Mnemonic Vpinsrw;
    
public static Mnemonic Vplzcntd;
    
public static Mnemonic Vplzcntq;
    
public static Mnemonic Vpmacsdd;
    
public static Mnemonic Vpmacsdqh;
    
public static Mnemonic Vpmacsdql;
    
public static Mnemonic Vpmacssdd;
    
public static Mnemonic Vpmacssdqh;
    
public static Mnemonic Vpmacssdql;
    
public static Mnemonic Vpmacsswd;
    
public static Mnemonic Vpmacssww;
    
public static Mnemonic Vpmacswd;
    
public static Mnemonic Vpmacsww;
    
public static Mnemonic Vpmadcsswd;
    
public static Mnemonic Vpmadcswd;
    
public static Mnemonic Vpmadd52huq;
    
public static Mnemonic Vpmadd52luq;
    
public static Mnemonic Vpmaddubsw;
    
public static Mnemonic Vpmaddwd;
    
public static Mnemonic Vpmaskmovd;
    
public static Mnemonic Vpmaskmovq;
    
public static Mnemonic Vpmaxsb;
    
public static Mnemonic Vpmaxsd;
    
public static Mnemonic Vpmaxsq;
    
public static Mnemonic Vpmaxsw;
    
public static Mnemonic Vpmaxub;
    
public static Mnemonic Vpmaxud;
    
public static Mnemonic Vpmaxuq;
    
public static Mnemonic Vpmaxuw;
    
public static Mnemonic Vpminsb;
    
public static Mnemonic Vpminsd;
    
public static Mnemonic Vpminsq;
    
public static Mnemonic Vpminsw;
    
public static Mnemonic Vpminub;
    
public static Mnemonic Vpminud;
    
public static Mnemonic Vpminuq;
    
public static Mnemonic Vpminuw;
    
public static Mnemonic Vpmovb2m;
    
public static Mnemonic Vpmovd2m;
    
public static Mnemonic Vpmovdb;
    
public static Mnemonic Vpmovdw;
    
public static Mnemonic Vpmovm2b;
    
public static Mnemonic Vpmovm2d;
    
public static Mnemonic Vpmovm2q;
    
public static Mnemonic Vpmovm2w;
    
public static Mnemonic Vpmovmskb;
    
public static Mnemonic Vpmovq2m;
    
public static Mnemonic Vpmovqb;
    
public static Mnemonic Vpmovqd;
    
public static Mnemonic Vpmovqw;
    
public static Mnemonic Vpmovsdb;
    
public static Mnemonic Vpmovsdw;
    
public static Mnemonic Vpmovsqb;
    
public static Mnemonic Vpmovsqd;
    
public static Mnemonic Vpmovsqw;
    
public static Mnemonic Vpmovswb;
    
public static Mnemonic Vpmovsxbd;
    
public static Mnemonic Vpmovsxbq;
    
public static Mnemonic Vpmovsxbw;
    
public static Mnemonic Vpmovsxdq;
    
public static Mnemonic Vpmovsxwd;
    
public static Mnemonic Vpmovsxwq;
    
public static Mnemonic Vpmovusdb;
    
public static Mnemonic Vpmovusdw;
    
public static Mnemonic Vpmovusqb;
    
public static Mnemonic Vpmovusqd;
    
public static Mnemonic Vpmovusqw;
    
public static Mnemonic Vpmovuswb;
    
public static Mnemonic Vpmovw2m;
    
public static Mnemonic Vpmovwb;
    
public static Mnemonic Vpmovzxbd;
    
public static Mnemonic Vpmovzxbq;
    
public static Mnemonic Vpmovzxbw;
    
public static Mnemonic Vpmovzxdq;
    
public static Mnemonic Vpmovzxwd;
    
public static Mnemonic Vpmovzxwq;
    
public static Mnemonic Vpmuldq;
    
public static Mnemonic Vpmulhrsw;
    
public static Mnemonic Vpmulhuw;
    
public static Mnemonic Vpmulhw;
    
public static Mnemonic Vpmulld;
    
public static Mnemonic Vpmullq;
    
public static Mnemonic Vpmullw;
    
public static Mnemonic Vpmultishiftqb;
    
public static Mnemonic Vpmuludq;
    
public static Mnemonic Vpopcntb;
    
public static Mnemonic Vpopcntd;
    
public static Mnemonic Vpopcntq;
    
public static Mnemonic Vpopcntw;
    
public static Mnemonic Vpor;
    
public static Mnemonic Vpord;
    
public static Mnemonic Vporq;
    
public static Mnemonic Vpperm;
    
public static Mnemonic Vprold;
    
public static Mnemonic Vprolq;
    
public static Mnemonic Vprolvd;
    
public static Mnemonic Vprolvq;
    
public static Mnemonic Vprord;
    
public static Mnemonic Vprorq;
    
public static Mnemonic Vprorvd;
    
public static Mnemonic Vprorvq;
    
public static Mnemonic Vprotb;
    
public static Mnemonic Vprotd;
    
public static Mnemonic Vprotq;
    
public static Mnemonic Vprotw;
    
public static Mnemonic Vpsadbw;
    
public static Mnemonic Vpscatterdd;
    
public static Mnemonic Vpscatterdq;
    
public static Mnemonic Vpscatterqd;
    
public static Mnemonic Vpscatterqq;
    
public static Mnemonic Vpshab;
    
public static Mnemonic Vpshad;
    
public static Mnemonic Vpshaq;
    
public static Mnemonic Vpshaw;
    
public static Mnemonic Vpshlb;
    
public static Mnemonic Vpshld;
    
public static Mnemonic Vpshldd;
    
public static Mnemonic Vpshldq;
    
public static Mnemonic Vpshldvd;
    
public static Mnemonic Vpshldvq;
    
public static Mnemonic Vpshldvw;
    
public static Mnemonic Vpshldw;
    
public static Mnemonic Vpshlq;
    
public static Mnemonic Vpshlw;
    
public static Mnemonic Vpshrdd;
    
public static Mnemonic Vpshrdq;
    
public static Mnemonic Vpshrdvd;
    
public static Mnemonic Vpshrdvq;
    
public static Mnemonic Vpshrdvw;
    
public static Mnemonic Vpshrdw;
    
public static Mnemonic Vpshufb;
    
public static Mnemonic Vpshufbitqmb;
    
public static Mnemonic Vpshufd;
    
public static Mnemonic Vpshufhw;
    
public static Mnemonic Vpshuflw;
    
public static Mnemonic Vpsignb;
    
public static Mnemonic Vpsignd;
    
public static Mnemonic Vpsignw;
    
public static Mnemonic Vpslld;
    
public static Mnemonic Vpslldq;
    
public static Mnemonic Vpsllq;
    
public static Mnemonic Vpsllvd;
    
public static Mnemonic Vpsllvq;
    
public static Mnemonic Vpsllvw;
    
public static Mnemonic Vpsllw;
    
public static Mnemonic Vpsrad;
    
public static Mnemonic Vpsraq;
    
public static Mnemonic Vpsravd;
    
public static Mnemonic Vpsravq;
    
public static Mnemonic Vpsravw;
    
public static Mnemonic Vpsraw;
    
public static Mnemonic Vpsrld;
    
public static Mnemonic Vpsrldq;
    
public static Mnemonic Vpsrlq;
    
public static Mnemonic Vpsrlvd;
    
public static Mnemonic Vpsrlvq;
    
public static Mnemonic Vpsrlvw;
    
public static Mnemonic Vpsrlw;
    
public static Mnemonic Vpsubb;
    
public static Mnemonic Vpsubd;
    
public static Mnemonic Vpsubq;
    
public static Mnemonic Vpsubsb;
    
public static Mnemonic Vpsubsw;
    
public static Mnemonic Vpsubusb;
    
public static Mnemonic Vpsubusw;
    
public static Mnemonic Vpsubw;
    
public static Mnemonic Vpternlogd;
    
public static Mnemonic Vpternlogq;
    
public static Mnemonic Vptest;
    
public static Mnemonic Vptestmb;
    
public static Mnemonic Vptestmd;
    
public static Mnemonic Vptestmq;
    
public static Mnemonic Vptestmw;
    
public static Mnemonic Vptestnmb;
    
public static Mnemonic Vptestnmd;
    
public static Mnemonic Vptestnmq;
    
public static Mnemonic Vptestnmw;
    
public static Mnemonic Vpunpckhbw;
    
public static Mnemonic Vpunpckhdq;
    
public static Mnemonic Vpunpckhqdq;
    
public static Mnemonic Vpunpckhwd;
    
public static Mnemonic Vpunpcklbw;
    
public static Mnemonic Vpunpckldq;
    
public static Mnemonic Vpunpcklqdq;
    
public static Mnemonic Vpunpcklwd;
    
public static Mnemonic Vpxor;
    
public static Mnemonic Vpxord;
    
public static Mnemonic Vpxorq;
    
public static Mnemonic Vrangepd;
    
public static Mnemonic Vrangeps;
    
public static Mnemonic Vrangesd;
    
public static Mnemonic Vrangess;
    
public static Mnemonic Vrcp14pd;
    
public static Mnemonic Vrcp14ps;
    
public static Mnemonic Vrcp14sd;
    
public static Mnemonic Vrcp14ss;
    
public static Mnemonic Vrcp28pd;
    
public static Mnemonic Vrcp28ps;
    
public static Mnemonic Vrcp28sd;
    
public static Mnemonic Vrcp28ss;
    
public static Mnemonic Vrcpps;
    
public static Mnemonic Vrcpss;
    
public static Mnemonic Vreducepd;
    
public static Mnemonic Vreduceps;
    
public static Mnemonic Vreducesd;
    
public static Mnemonic Vreducess;
    
public static Mnemonic Vrndscalepd;
    
public static Mnemonic Vrndscaleps;
    
public static Mnemonic Vrndscalesd;
    
public static Mnemonic Vrndscaless;
    
public static Mnemonic Vroundpd;
    
public static Mnemonic Vroundps;
    
public static Mnemonic Vroundsd;
    
public static Mnemonic Vroundss;
    
public static Mnemonic Vrsqrt14pd;
    
public static Mnemonic Vrsqrt14ps;
    
public static Mnemonic Vrsqrt14sd;
    
public static Mnemonic Vrsqrt14ss;
    
public static Mnemonic Vrsqrt28pd;
    
public static Mnemonic Vrsqrt28ps;
    
public static Mnemonic Vrsqrt28sd;
    
public static Mnemonic Vrsqrt28ss;
    
public static Mnemonic Vrsqrtps;
    
public static Mnemonic Vrsqrtss;
    
public static Mnemonic Vscalefpd;
    
public static Mnemonic Vscalefps;
    
public static Mnemonic Vscalefsd;
    
public static Mnemonic Vscalefss;
    
public static Mnemonic Vscatterdpd;
    
public static Mnemonic Vscatterdps;
    
public static Mnemonic Vscatterpf0dpd;
    
public static Mnemonic Vscatterpf0dps;
    
public static Mnemonic Vscatterpf0qpd;
    
public static Mnemonic Vscatterpf0qps;
    
public static Mnemonic Vscatterpf1dpd;
    
public static Mnemonic Vscatterpf1dps;
    
public static Mnemonic Vscatterpf1qpd;
    
public static Mnemonic Vscatterpf1qps;
    
public static Mnemonic Vscatterqpd;
    
public static Mnemonic Vscatterqps;
    
public static Mnemonic Vshuff32x4;
    
public static Mnemonic Vshuff64x2;
    
public static Mnemonic Vshufi32x4;
    
public static Mnemonic Vshufi64x2;
    
public static Mnemonic Vshufpd;
    
public static Mnemonic Vshufps;
    
public static Mnemonic Vsqrtpd;
    
public static Mnemonic Vsqrtps;
    
public static Mnemonic Vsqrtsd;
    
public static Mnemonic Vsqrtss;
    
public static Mnemonic Vstmxcsr;
    
public static Mnemonic Vsubpd;
    
public static Mnemonic Vsubps;
    
public static Mnemonic Vsubsd;
    
public static Mnemonic Vsubss;
    
public static Mnemonic Vtestpd;
    
public static Mnemonic Vtestps;
    
public static Mnemonic Vucomisd;
    
public static Mnemonic Vucomiss;
    
public static Mnemonic Vunpckhpd;
    
public static Mnemonic Vunpckhps;
    
public static Mnemonic Vunpcklpd;
    
public static Mnemonic Vunpcklps;
    
public static Mnemonic Vxorpd;
    
public static Mnemonic Vxorps;
    
public static Mnemonic Vzeroall;
    
public static Mnemonic Vzeroupper;
    
public static Mnemonic Wait;
    
public static Mnemonic Wbinvd;
    
public static Mnemonic Wbnoinvd;
    
public static Mnemonic Wrfsbase;
    
public static Mnemonic Wrgsbase;
    
public static Mnemonic Wrmsr;
    
public static Mnemonic Wrpkru;
    
public static Mnemonic Wrssd;
    
public static Mnemonic Wrssq;
    
public static Mnemonic Wrussd;
    
public static Mnemonic Wrussq;
    
public static Mnemonic Xabort;
    
public static Mnemonic Xadd;
    
public static Mnemonic Xbegin;
    
public static Mnemonic Xbts;
    
public static Mnemonic Xchg;
    
public static Mnemonic Xcryptcbc;
    
public static Mnemonic Xcryptcfb;
    
public static Mnemonic Xcryptctr;
    
public static Mnemonic Xcryptecb;
    
public static Mnemonic Xcryptofb;
    
public static Mnemonic Xend;
    
public static Mnemonic Xgetbv;
    
public static Mnemonic Xlatb;
    
public static Mnemonic Xor;
    
public static Mnemonic Xorpd;
    
public static Mnemonic Xorps;
    
public static Mnemonic Xrstor;
    
public static Mnemonic Xrstor64;
    
public static Mnemonic Xrstors;
    
public static Mnemonic Xrstors64;
    
public static Mnemonic Xsave;
    
public static Mnemonic Xsave64;
    
public static Mnemonic Xsavec;
    
public static Mnemonic Xsavec64;
    
public static Mnemonic Xsaveopt;
    
public static Mnemonic Xsaveopt64;
    
public static Mnemonic Xsaves;
    
public static Mnemonic Xsaves64;
    
public static Mnemonic Xsetbv;
    
public static Mnemonic Xsha1;
    
public static Mnemonic Xsha256;
    
public static Mnemonic Xstore;
    
public static Mnemonic Xtest;
    
public static Mnemonic Rmpadjust;
    
public static Mnemonic Rmpupdate;
    
public static Mnemonic Psmash;
    
public static Mnemonic Pvalidate;
    
public static Mnemonic Serialize;
    
public static Mnemonic Xsusldtrk;
    
public static Mnemonic Xresldtrk;
    
public static Mnemonic Invlpgb;
    
public static Mnemonic Tlbsync;
    
public static Mnemonic Vmgexit;
    
public static Mnemonic Getsecq;
    
public static Mnemonic Sysexitq;
    
public static Mnemonic Ldtilecfg;
    
public static Mnemonic Tilerelease;
    
public static Mnemonic Sttilecfg;
    
public static Mnemonic Tilezero;
    
public static Mnemonic Tileloaddt1;
    
public static Mnemonic Tilestored;
    
public static Mnemonic Tileloadd;
    
public static Mnemonic Tdpbf16ps;
    
public static Mnemonic Tdpbuud;
    
public static Mnemonic Tdpbusd;
    
public static Mnemonic Tdpbsud;
    
public static Mnemonic Tdpbssd;
    
public static Mnemonic Sysretq;
    
public static Mnemonic Fnstdw;
    
public static Mnemonic Fnstsg;
    
public static Mnemonic Rdshr;
    
public static Mnemonic Wrshr;
    
public static Mnemonic Smint;
    
public static Mnemonic Dmint;
    
public static Mnemonic Rdm;
    
public static Mnemonic Svdc;
    
public static Mnemonic Rsdc;
    
public static Mnemonic Svldt;
    
public static Mnemonic Rsldt;
    
public static Mnemonic Svts;
    
public static Mnemonic Rsts;
    
public static Mnemonic Bb0_reset;
    
public static Mnemonic Bb1_reset;
    
public static Mnemonic Cpu_write;
    
public static Mnemonic Cpu_read;
    
public static Mnemonic Altinst;
    
public static Mnemonic Paveb;
    
public static Mnemonic Paddsiw;
    
public static Mnemonic Pmagw;
    
public static Mnemonic Pdistib;
    
public static Mnemonic Psubsiw;
    
public static Mnemonic Pmvzb;
    
public static Mnemonic Pmvnzb;
    
public static Mnemonic Pmvlzb;
    
public static Mnemonic Pmvgezb;
    
public static Mnemonic Pmulhriw;
    
public static Mnemonic Pmachriw;
    
public static Mnemonic Ftstp;
    
public static Mnemonic Frint2;
    
public static Mnemonic Frichop;
    
public static Mnemonic Frinear;
    
public static Mnemonic Undoc;
    
public static Mnemonic Tdcall;
    
public static Mnemonic Seamret;
    
public static Mnemonic Seamops;
    
public static Mnemonic Seamcall;
    
public static Mnemonic Aesencwide128kl;
    
public static Mnemonic Aesdecwide128kl;
    
public static Mnemonic Aesencwide256kl;
    
public static Mnemonic Aesdecwide256kl;
    
public static Mnemonic Loadiwkey;
    
public static Mnemonic Aesenc128kl;
    
public static Mnemonic Aesdec128kl;
    
public static Mnemonic Aesenc256kl;
    
public static Mnemonic Aesdec256kl;
    
public static Mnemonic Encodekey128;
    
public static Mnemonic Encodekey256;
    
public static Mnemonic Pushad;
    
public static Mnemonic Popad;
    
public static Mnemonic Pushfd;
    
public static Mnemonic Pushfq;
    
public static Mnemonic Popfd;
    
public static Mnemonic Popfq;
    
public static Mnemonic Iretd;
    
public static Mnemonic Iretq;
    
public static Mnemonic Int3;
    
public static Mnemonic Uiret;
    
public static Mnemonic Testui;
    
public static Mnemonic Clui;
    
public static Mnemonic Stui;
    
public static Mnemonic Senduipi;
    
public static Mnemonic Hreset;
    
public static Mnemonic Ccs_hash;
    
public static Mnemonic Ccs_encrypt;
    
public static Mnemonic Lkgs;
    
public static Mnemonic Eretu;
    
public static Mnemonic Erets;
    
public static Mnemonic Storeall;
    
public static Mnemonic Vaddph;
    
public static Mnemonic Vaddsh;
    
public static Mnemonic Vcmpph;
    
public static Mnemonic Vcmpsh;
    
public static Mnemonic Vcomish;
    
public static Mnemonic Vcvtdq2ph;
    
public static Mnemonic Vcvtpd2ph;
    
public static Mnemonic Vcvtph2dq;
    
public static Mnemonic Vcvtph2pd;
    
public static Mnemonic Vcvtph2psx;
    
public static Mnemonic Vcvtph2qq;
    
public static Mnemonic Vcvtph2udq;
    
public static Mnemonic Vcvtph2uqq;
    
public static Mnemonic Vcvtph2uw;
    
public static Mnemonic Vcvtph2w;
    
public static Mnemonic Vcvtps2phx;
    
public static Mnemonic Vcvtqq2ph;
    
public static Mnemonic Vcvtsd2sh;
    
public static Mnemonic Vcvtsh2sd;
    
public static Mnemonic Vcvtsh2si;
    
public static Mnemonic Vcvtsh2ss;
    
public static Mnemonic Vcvtsh2usi;
    
public static Mnemonic Vcvtsi2sh;
    
public static Mnemonic Vcvtss2sh;
    
public static Mnemonic Vcvttph2dq;
    
public static Mnemonic Vcvttph2qq;
    
public static Mnemonic Vcvttph2udq;
    
public static Mnemonic Vcvttph2uqq;
    
public static Mnemonic Vcvttph2uw;
    
public static Mnemonic Vcvttph2w;
    
public static Mnemonic Vcvttsh2si;
    
public static Mnemonic Vcvttsh2usi;
    
public static Mnemonic Vcvtudq2ph;
    
public static Mnemonic Vcvtuqq2ph;
    
public static Mnemonic Vcvtusi2sh;
    
public static Mnemonic Vcvtuw2ph;
    
public static Mnemonic Vcvtw2ph;
    
public static Mnemonic Vdivph;
    
public static Mnemonic Vdivsh;
    
public static Mnemonic Vfcmaddcph;
    
public static Mnemonic Vfmaddcph;
    
public static Mnemonic Vfcmaddcsh;
    
public static Mnemonic Vfmaddcsh;
    
public static Mnemonic Vfcmulcph;
    
public static Mnemonic Vfmulcph;
    
public static Mnemonic Vfcmulcsh;
    
public static Mnemonic Vfmulcsh;
    
public static Mnemonic Vfmaddsub132ph;
    
public static Mnemonic Vfmaddsub213ph;
    
public static Mnemonic Vfmaddsub231ph;
    
public static Mnemonic Vfmsubadd132ph;
    
public static Mnemonic Vfmsubadd213ph;
    
public static Mnemonic Vfmsubadd231ph;
    
public static Mnemonic Vfmadd132ph;
    
public static Mnemonic Vfmadd213ph;
    
public static Mnemonic Vfmadd231ph;
    
public static Mnemonic Vfnmadd132ph;
    
public static Mnemonic Vfnmadd213ph;
    
public static Mnemonic Vfnmadd231ph;
    
public static Mnemonic Vfmadd132sh;
    
public static Mnemonic Vfmadd213sh;
    
public static Mnemonic Vfmadd231sh;
    
public static Mnemonic Vfnmadd132sh;
    
public static Mnemonic Vfnmadd213sh;
    
public static Mnemonic Vfnmadd231sh;
    
public static Mnemonic Vfmsub132ph;
    
public static Mnemonic Vfmsub213ph;
    
public static Mnemonic Vfmsub231ph;
    
public static Mnemonic Vfnmsub132ph;
    
public static Mnemonic Vfnmsub213ph;
    
public static Mnemonic Vfnmsub231ph;
    
public static Mnemonic Vfmsub132sh;
    
public static Mnemonic Vfmsub213sh;
    
public static Mnemonic Vfmsub231sh;
    
public static Mnemonic Vfnmsub132sh;
    
public static Mnemonic Vfnmsub213sh;
    
public static Mnemonic Vfnmsub231sh;
    
public static Mnemonic Vfpclassph;
    
public static Mnemonic Vfpclasssh;
    
public static Mnemonic Vgetexpph;
    
public static Mnemonic Vgetexpsh;
    
public static Mnemonic Vgetmantph;
    
public static Mnemonic Vgetmantsh;
    
public static Mnemonic Vmaxph;
    
public static Mnemonic Vmaxsh;
    
public static Mnemonic Vminph;
    
public static Mnemonic Vminsh;
    
public static Mnemonic Vmovsh;
    
public static Mnemonic Vmovw;
    
public static Mnemonic Vmulph;
    
public static Mnemonic Vmulsh;
    
public static Mnemonic Vrcpph;
    
public static Mnemonic Vrcpsh;
    
public static Mnemonic Vreduceph;
    
public static Mnemonic Vreducesh;
    
public static Mnemonic Vrndscaleph;
    
public static Mnemonic Vrndscalesh;
    
public static Mnemonic Vrsqrtph;
    
public static Mnemonic Vrsqrtsh;
    
public static Mnemonic Vscalefph;
    
public static Mnemonic Vscalefsh;
    
public static Mnemonic Vsqrtph;
    
public static Mnemonic Vsqrtsh;
    
public static Mnemonic Vsubph;
    
public static Mnemonic Vsubsh;
    
public static Mnemonic Vucomish;
    
public static Mnemonic Rdudbg;
    
public static Mnemonic Wrudbg;
    
public static Mnemonic Clevict0;
    
public static Mnemonic Clevict1;
    
public static Mnemonic Delay;
    
public static Mnemonic Jknzd;
    
public static Mnemonic Jkzd;
    
public static Mnemonic Kand;
    
public static Mnemonic Kandn;
    
public static Mnemonic Kandnr;
    
public static Mnemonic Kconcath;
    
public static Mnemonic Kconcatl;
    
public static Mnemonic Kextract;
    
public static Mnemonic Kmerge2l1h;
    
public static Mnemonic Kmerge2l1l;
    
public static Mnemonic Kmov;
    
public static Mnemonic Knot;
    
public static Mnemonic Kor;
    
public static Mnemonic Kortest;
    
public static Mnemonic Kxnor;
    
public static Mnemonic Kxor;
    
public static Mnemonic Spflt;
    
public static Mnemonic Tzcnti;
    
public static Mnemonic Vaddnpd;
    
public static Mnemonic Vaddnps;
    
public static Mnemonic Vaddsetsps;
    
public static Mnemonic Vcvtfxpntdq2ps;
    
public static Mnemonic Vcvtfxpntpd2dq;
    
public static Mnemonic Vcvtfxpntpd2udq;
    
public static Mnemonic Vcvtfxpntps2dq;
    
public static Mnemonic Vcvtfxpntps2udq;
    
public static Mnemonic Vcvtfxpntudq2ps;
    
public static Mnemonic Vexp223ps;
    
public static Mnemonic Vfixupnanpd;
    
public static Mnemonic Vfixupnanps;
    
public static Mnemonic Vfmadd233ps;
    
public static Mnemonic Vgatherpf0hintdpd;
    
public static Mnemonic Vgatherpf0hintdps;
    
public static Mnemonic Vgmaxabsps;
    
public static Mnemonic Vgmaxpd;
    
public static Mnemonic Vgmaxps;
    
public static Mnemonic Vgminpd;
    
public static Mnemonic Vgminps;
    
public static Mnemonic Vloadunpackhd;
    
public static Mnemonic Vloadunpackhpd;
    
public static Mnemonic Vloadunpackhps;
    
public static Mnemonic Vloadunpackhq;
    
public static Mnemonic Vloadunpackld;
    
public static Mnemonic Vloadunpacklpd;
    
public static Mnemonic Vloadunpacklps;
    
public static Mnemonic Vloadunpacklq;
    
public static Mnemonic Vlog2ps;
    
public static Mnemonic Vmovnrapd;
    
public static Mnemonic Vmovnraps;
    
public static Mnemonic Vmovnrngoapd;
    
public static Mnemonic Vmovnrngoaps;
    
public static Mnemonic Vpackstorehd;
    
public static Mnemonic Vpackstorehpd;
    
public static Mnemonic Vpackstorehps;
    
public static Mnemonic Vpackstorehq;
    
public static Mnemonic Vpackstoreld;
    
public static Mnemonic Vpackstorelpd;
    
public static Mnemonic Vpackstorelps;
    
public static Mnemonic Vpackstorelq;
    
public static Mnemonic Vpadcd;
    
public static Mnemonic Vpaddsetcd;
    
public static Mnemonic Vpaddsetsd;
    
public static Mnemonic Vpcmpltd;
    
public static Mnemonic Vpermf32x4;
    
public static Mnemonic Vpmadd231d;
    
public static Mnemonic Vpmadd233d;
    
public static Mnemonic Vpmulhd;
    
public static Mnemonic Vpmulhud;
    
public static Mnemonic Vprefetch0;
    
public static Mnemonic Vprefetch1;
    
public static Mnemonic Vprefetch2;
    
public static Mnemonic Vprefetche0;
    
public static Mnemonic Vprefetche1;
    
public static Mnemonic Vprefetche2;
    
public static Mnemonic Vprefetchenta;
    
public static Mnemonic Vprefetchnta;
    
public static Mnemonic Vpsbbd;
    
public static Mnemonic Vpsbbrd;
    
public static Mnemonic Vpsubrd;
    
public static Mnemonic Vpsubrsetbd;
    
public static Mnemonic Vpsubsetbd;
    
public static Mnemonic Vrcp23ps;
    
public static Mnemonic Vrndfxpntpd;
    
public static Mnemonic Vrndfxpntps;
    
public static Mnemonic Vrsqrt23ps;
    
public static Mnemonic Vscaleps;
    
public static Mnemonic Vscatterpf0hintdpd;
    
public static Mnemonic Vscatterpf0hintdps;
    
public static Mnemonic Vsubrpd;
    
public static Mnemonic Vsubrps;
    
public static Mnemonic Xsha512;
    
public static Mnemonic Xstore_alt;
    
public static Mnemonic Xsha512_alt;
    
public static Mnemonic Zero_bytes;
}
[ExtensionAttribute]
internal static class Iced.Intel.MnemonicUtils : object {
    [ExtensionAttribute]
public static Mnemonic Mnemonic(Code code);
}
internal static class Iced.Intel.MnemonicUtilsData : object {
    [NullableAttribute("1")]

internal static UInt16[] toMnemonic;
    private static MnemonicUtilsData();
}
internal enum Iced.Intel.OpKind : Enum {
    
public int value__;
    
public static OpKind Register;
    
public static OpKind NearBranch16;
    
public static OpKind NearBranch32;
    
public static OpKind NearBranch64;
    
public static OpKind FarBranch16;
    
public static OpKind FarBranch32;
    
public static OpKind Immediate8;
    
public static OpKind Immediate8_2nd;
    
public static OpKind Immediate16;
    
public static OpKind Immediate32;
    
public static OpKind Immediate64;
    
public static OpKind Immediate8to16;
    
public static OpKind Immediate8to32;
    
public static OpKind Immediate8to64;
    
public static OpKind Immediate32to64;
    
public static OpKind MemorySegSI;
    
public static OpKind MemorySegESI;
    
public static OpKind MemorySegRSI;
    
public static OpKind MemorySegDI;
    
public static OpKind MemorySegEDI;
    
public static OpKind MemorySegRDI;
    
public static OpKind MemoryESDI;
    
public static OpKind MemoryESEDI;
    
public static OpKind MemoryESRDI;
    
public static OpKind Memory;
}
internal enum Iced.Intel.OpSize : Enum {
    
public byte value__;
    
public static OpSize Size16;
    
public static OpSize Size32;
    
public static OpSize Size64;
}
internal enum Iced.Intel.Register : Enum {
    
public int value__;
    
public static Register None;
    
public static Register AL;
    
public static Register CL;
    
public static Register DL;
    
public static Register BL;
    
public static Register AH;
    
public static Register CH;
    
public static Register DH;
    
public static Register BH;
    
public static Register SPL;
    
public static Register BPL;
    
public static Register SIL;
    
public static Register DIL;
    
public static Register R8L;
    
public static Register R9L;
    
public static Register R10L;
    
public static Register R11L;
    
public static Register R12L;
    
public static Register R13L;
    
public static Register R14L;
    
public static Register R15L;
    
public static Register AX;
    
public static Register CX;
    
public static Register DX;
    
public static Register BX;
    
public static Register SP;
    
public static Register BP;
    
public static Register SI;
    
public static Register DI;
    
public static Register R8W;
    
public static Register R9W;
    
public static Register R10W;
    
public static Register R11W;
    
public static Register R12W;
    
public static Register R13W;
    
public static Register R14W;
    
public static Register R15W;
    
public static Register EAX;
    
public static Register ECX;
    
public static Register EDX;
    
public static Register EBX;
    
public static Register ESP;
    
public static Register EBP;
    
public static Register ESI;
    
public static Register EDI;
    
public static Register R8D;
    
public static Register R9D;
    
public static Register R10D;
    
public static Register R11D;
    
public static Register R12D;
    
public static Register R13D;
    
public static Register R14D;
    
public static Register R15D;
    
public static Register RAX;
    
public static Register RCX;
    
public static Register RDX;
    
public static Register RBX;
    
public static Register RSP;
    
public static Register RBP;
    
public static Register RSI;
    
public static Register RDI;
    
public static Register R8;
    
public static Register R9;
    
public static Register R10;
    
public static Register R11;
    
public static Register R12;
    
public static Register R13;
    
public static Register R14;
    
public static Register R15;
    
public static Register EIP;
    
public static Register RIP;
    
public static Register ES;
    
public static Register CS;
    
public static Register SS;
    
public static Register DS;
    
public static Register FS;
    
public static Register GS;
    
public static Register XMM0;
    
public static Register XMM1;
    
public static Register XMM2;
    
public static Register XMM3;
    
public static Register XMM4;
    
public static Register XMM5;
    
public static Register XMM6;
    
public static Register XMM7;
    
public static Register XMM8;
    
public static Register XMM9;
    
public static Register XMM10;
    
public static Register XMM11;
    
public static Register XMM12;
    
public static Register XMM13;
    
public static Register XMM14;
    
public static Register XMM15;
    
public static Register XMM16;
    
public static Register XMM17;
    
public static Register XMM18;
    
public static Register XMM19;
    
public static Register XMM20;
    
public static Register XMM21;
    
public static Register XMM22;
    
public static Register XMM23;
    
public static Register XMM24;
    
public static Register XMM25;
    
public static Register XMM26;
    
public static Register XMM27;
    
public static Register XMM28;
    
public static Register XMM29;
    
public static Register XMM30;
    
public static Register XMM31;
    
public static Register YMM0;
    
public static Register YMM1;
    
public static Register YMM2;
    
public static Register YMM3;
    
public static Register YMM4;
    
public static Register YMM5;
    
public static Register YMM6;
    
public static Register YMM7;
    
public static Register YMM8;
    
public static Register YMM9;
    
public static Register YMM10;
    
public static Register YMM11;
    
public static Register YMM12;
    
public static Register YMM13;
    
public static Register YMM14;
    
public static Register YMM15;
    
public static Register YMM16;
    
public static Register YMM17;
    
public static Register YMM18;
    
public static Register YMM19;
    
public static Register YMM20;
    
public static Register YMM21;
    
public static Register YMM22;
    
public static Register YMM23;
    
public static Register YMM24;
    
public static Register YMM25;
    
public static Register YMM26;
    
public static Register YMM27;
    
public static Register YMM28;
    
public static Register YMM29;
    
public static Register YMM30;
    
public static Register YMM31;
    
public static Register ZMM0;
    
public static Register ZMM1;
    
public static Register ZMM2;
    
public static Register ZMM3;
    
public static Register ZMM4;
    
public static Register ZMM5;
    
public static Register ZMM6;
    
public static Register ZMM7;
    
public static Register ZMM8;
    
public static Register ZMM9;
    
public static Register ZMM10;
    
public static Register ZMM11;
    
public static Register ZMM12;
    
public static Register ZMM13;
    
public static Register ZMM14;
    
public static Register ZMM15;
    
public static Register ZMM16;
    
public static Register ZMM17;
    
public static Register ZMM18;
    
public static Register ZMM19;
    
public static Register ZMM20;
    
public static Register ZMM21;
    
public static Register ZMM22;
    
public static Register ZMM23;
    
public static Register ZMM24;
    
public static Register ZMM25;
    
public static Register ZMM26;
    
public static Register ZMM27;
    
public static Register ZMM28;
    
public static Register ZMM29;
    
public static Register ZMM30;
    
public static Register ZMM31;
    
public static Register K0;
    
public static Register K1;
    
public static Register K2;
    
public static Register K3;
    
public static Register K4;
    
public static Register K5;
    
public static Register K6;
    
public static Register K7;
    
public static Register BND0;
    
public static Register BND1;
    
public static Register BND2;
    
public static Register BND3;
    
public static Register CR0;
    
public static Register CR1;
    
public static Register CR2;
    
public static Register CR3;
    
public static Register CR4;
    
public static Register CR5;
    
public static Register CR6;
    
public static Register CR7;
    
public static Register CR8;
    
public static Register CR9;
    
public static Register CR10;
    
public static Register CR11;
    
public static Register CR12;
    
public static Register CR13;
    
public static Register CR14;
    
public static Register CR15;
    
public static Register DR0;
    
public static Register DR1;
    
public static Register DR2;
    
public static Register DR3;
    
public static Register DR4;
    
public static Register DR5;
    
public static Register DR6;
    
public static Register DR7;
    
public static Register DR8;
    
public static Register DR9;
    
public static Register DR10;
    
public static Register DR11;
    
public static Register DR12;
    
public static Register DR13;
    
public static Register DR14;
    
public static Register DR15;
    
public static Register ST0;
    
public static Register ST1;
    
public static Register ST2;
    
public static Register ST3;
    
public static Register ST4;
    
public static Register ST5;
    
public static Register ST6;
    
public static Register ST7;
    
public static Register MM0;
    
public static Register MM1;
    
public static Register MM2;
    
public static Register MM3;
    
public static Register MM4;
    
public static Register MM5;
    
public static Register MM6;
    
public static Register MM7;
    
public static Register TR0;
    
public static Register TR1;
    
public static Register TR2;
    
public static Register TR3;
    
public static Register TR4;
    
public static Register TR5;
    
public static Register TR6;
    
public static Register TR7;
    
public static Register TMM0;
    
public static Register TMM1;
    
public static Register TMM2;
    
public static Register TMM3;
    
public static Register TMM4;
    
public static Register TMM5;
    
public static Register TMM6;
    
public static Register TMM7;
    [ObsoleteAttribute("Not part of the public API", "False")]
[EditorBrowsableAttribute("1")]

public static Register DontUse0;
    [ObsoleteAttribute("Not part of the public API", "False")]
[EditorBrowsableAttribute("1")]

public static Register DontUseFA;
    [ObsoleteAttribute("Not part of the public API", "False")]
[EditorBrowsableAttribute("1")]

public static Register DontUseFB;
    [ObsoleteAttribute("Not part of the public API", "False")]
[EditorBrowsableAttribute("1")]

public static Register DontUseFC;
    [ObsoleteAttribute("Not part of the public API", "False")]
[EditorBrowsableAttribute("1")]

public static Register DontUseFD;
    [ObsoleteAttribute("Not part of the public API", "False")]
[EditorBrowsableAttribute("1")]

public static Register DontUseFE;
    [ObsoleteAttribute("Not part of the public API", "False")]
[EditorBrowsableAttribute("1")]

public static Register DontUseFF;
}
[ExtensionAttribute]
internal static class Iced.Intel.RegisterExtensions : object {
    [ExtensionAttribute]
public static bool IsSegmentRegister(Register register);
    [ExtensionAttribute]
public static bool IsGPR(Register register);
    [ExtensionAttribute]
public static bool IsGPR8(Register register);
    [ExtensionAttribute]
public static bool IsGPR16(Register register);
    [ExtensionAttribute]
public static bool IsGPR32(Register register);
    [ExtensionAttribute]
public static bool IsGPR64(Register register);
    [ExtensionAttribute]
public static bool IsXMM(Register register);
    [ExtensionAttribute]
public static bool IsYMM(Register register);
    [ExtensionAttribute]
public static bool IsZMM(Register register);
    [ExtensionAttribute]
public static bool IsIP(Register register);
    [ExtensionAttribute]
public static bool IsK(Register register);
    [ExtensionAttribute]
public static bool IsCR(Register register);
    [ExtensionAttribute]
public static bool IsDR(Register register);
    [ExtensionAttribute]
public static bool IsTR(Register register);
    [ExtensionAttribute]
public static bool IsST(Register register);
    [ExtensionAttribute]
public static bool IsBND(Register register);
    [ExtensionAttribute]
public static bool IsMM(Register register);
    [ExtensionAttribute]
public static bool IsTMM(Register register);
    [ExtensionAttribute]
public static bool IsVectorRegister(Register register);
}
[IsReadOnlyAttribute]
internal class Iced.Intel.RelocInfo : ValueType {
    
public ulong Address;
    
public RelocKind Kind;
    public RelocInfo(RelocKind kind, ulong address);
}
internal enum Iced.Intel.RelocKind : Enum {
    
public int value__;
    
public static RelocKind Offset64;
}
internal enum Iced.Intel.RepPrefixKind : Enum {
    
public int value__;
    
public static RepPrefixKind None;
    
public static RepPrefixKind Repe;
    
public static RepPrefixKind Repne;
}
internal enum Iced.Intel.RoundingControl : Enum {
    
public int value__;
    
public static RoundingControl None;
    
public static RoundingControl RoundToNearest;
    
public static RoundingControl RoundDown;
    
public static RoundingControl RoundUp;
    
public static RoundingControl RoundTowardZero;
}
[FlagsAttribute]
internal enum Iced.Intel.StateFlags : Enum {
    
public UInt32 value__;
    
public static StateFlags IpRel64;
    
public static StateFlags IpRel32;
    
public static StateFlags HasRex;
    
public static StateFlags b;
    
public static StateFlags z;
    
public static StateFlags IsInvalid;
    
public static StateFlags W;
    
public static StateFlags NoImm;
    
public static StateFlags Addr64;
    
public static StateFlags BranchImm8;
    
public static StateFlags Xbegin;
    
public static StateFlags Lock;
    
public static StateFlags AllowLock;
    
public static StateFlags NoMoreBytes;
    
public static StateFlags Has66;
    
public static StateFlags MvexSssMask;
    
public static StateFlags MvexSssShift;
    
public static StateFlags MvexEH;
    
public static StateFlags EncodingMask;
    
public static StateFlags EncodingShift;
}
internal static class Iced.Intel.Static : object {
    [ConditionalAttribute("E3967789CA584C48B3D02600CAB3C7B2")]
public static void Assert(byte ignored);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Iced.Intel.StreamCodeReader : CodeReader {
    
public Stream Stream;
    public StreamCodeReader(Stream stream);
    public virtual int ReadByte();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Iced.Intel.StreamCodeWriter : CodeWriter {
    
public Stream Stream;
    public StreamCodeWriter(Stream stream);
    public virtual void WriteByte(byte value);
}
internal static class Iced.Intel.ThrowHelper : object {
    [<b2ffb5d6-6a81-4f20-8e75-7064682f7f7c>DoesNotReturnAttribute]
internal static void ThrowArgumentException();
    [<b2ffb5d6-6a81-4f20-8e75-7064682f7f7c>DoesNotReturnAttribute]
internal static void ThrowInvalidOperationException();
    [<b2ffb5d6-6a81-4f20-8e75-7064682f7f7c>DoesNotReturnAttribute]
internal static void ThrowArgumentNullException_codeWriter();
    [<b2ffb5d6-6a81-4f20-8e75-7064682f7f7c>DoesNotReturnAttribute]
internal static void ThrowArgumentNullException_data();
    [<b2ffb5d6-6a81-4f20-8e75-7064682f7f7c>DoesNotReturnAttribute]
internal static void ThrowArgumentNullException_writer();
    [<b2ffb5d6-6a81-4f20-8e75-7064682f7f7c>DoesNotReturnAttribute]
internal static void ThrowArgumentNullException_options();
    [<b2ffb5d6-6a81-4f20-8e75-7064682f7f7c>DoesNotReturnAttribute]
internal static void ThrowArgumentNullException_value();
    [<b2ffb5d6-6a81-4f20-8e75-7064682f7f7c>DoesNotReturnAttribute]
internal static void ThrowArgumentNullException_list();
    [<b2ffb5d6-6a81-4f20-8e75-7064682f7f7c>DoesNotReturnAttribute]
internal static void ThrowArgumentNullException_collection();
    [<b2ffb5d6-6a81-4f20-8e75-7064682f7f7c>DoesNotReturnAttribute]
internal static void ThrowArgumentNullException_array();
    [<b2ffb5d6-6a81-4f20-8e75-7064682f7f7c>DoesNotReturnAttribute]
internal static void ThrowArgumentNullException_sb();
    [<b2ffb5d6-6a81-4f20-8e75-7064682f7f7c>DoesNotReturnAttribute]
internal static void ThrowArgumentNullException_output();
    [<b2ffb5d6-6a81-4f20-8e75-7064682f7f7c>DoesNotReturnAttribute]
internal static void ThrowArgumentOutOfRangeException_value();
    [<b2ffb5d6-6a81-4f20-8e75-7064682f7f7c>DoesNotReturnAttribute]
internal static void ThrowArgumentOutOfRangeException_index();
    [<b2ffb5d6-6a81-4f20-8e75-7064682f7f7c>DoesNotReturnAttribute]
internal static void ThrowArgumentOutOfRangeException_count();
    [<b2ffb5d6-6a81-4f20-8e75-7064682f7f7c>DoesNotReturnAttribute]
internal static void ThrowArgumentOutOfRangeException_length();
    [<b2ffb5d6-6a81-4f20-8e75-7064682f7f7c>DoesNotReturnAttribute]
internal static void ThrowArgumentOutOfRangeException_operand();
    [<b2ffb5d6-6a81-4f20-8e75-7064682f7f7c>DoesNotReturnAttribute]
internal static void ThrowArgumentOutOfRangeException_instructionOperand();
    [<b2ffb5d6-6a81-4f20-8e75-7064682f7f7c>DoesNotReturnAttribute]
internal static void ThrowArgumentOutOfRangeException_capacity();
    [<b2ffb5d6-6a81-4f20-8e75-7064682f7f7c>DoesNotReturnAttribute]
internal static void ThrowArgumentOutOfRangeException_memorySize();
    [<b2ffb5d6-6a81-4f20-8e75-7064682f7f7c>DoesNotReturnAttribute]
internal static void ThrowArgumentOutOfRangeException_size();
    [<b2ffb5d6-6a81-4f20-8e75-7064682f7f7c>DoesNotReturnAttribute]
internal static void ThrowArgumentOutOfRangeException_elementSize();
    [<b2ffb5d6-6a81-4f20-8e75-7064682f7f7c>DoesNotReturnAttribute]
internal static void ThrowArgumentOutOfRangeException_register();
    [<b2ffb5d6-6a81-4f20-8e75-7064682f7f7c>DoesNotReturnAttribute]
internal static void ThrowArgumentOutOfRangeException_code();
    [<b2ffb5d6-6a81-4f20-8e75-7064682f7f7c>DoesNotReturnAttribute]
internal static void ThrowArgumentOutOfRangeException_data();
}
internal enum Iced.Intel.TupleType : Enum {
    
public int value__;
    
public static TupleType N1;
    
public static TupleType N2;
    
public static TupleType N4;
    
public static TupleType N8;
    
public static TupleType N16;
    
public static TupleType N32;
    
public static TupleType N64;
    
public static TupleType N8b4;
    
public static TupleType N16b4;
    
public static TupleType N32b4;
    
public static TupleType N64b4;
    
public static TupleType N16b8;
    
public static TupleType N32b8;
    
public static TupleType N64b8;
    
public static TupleType N4b2;
    
public static TupleType N8b2;
    
public static TupleType N16b2;
    
public static TupleType N32b2;
    
public static TupleType N64b2;
}
internal static class Iced.Intel.TupleTypeTable : object {
    
private static ReadOnlySpan`1<byte> tupleTypeData { get; }
    private static ReadOnlySpan`1<byte> get_tupleTypeData();
    public static UInt32 GetDisp8N(TupleType tupleType, bool bcst);
}
internal class Iced.Intel.VAGetRegisterValue : MulticastDelegate {
    public VAGetRegisterValue(object object, IntPtr method);
    public virtual ulong Invoke(Register register, int elementIndex, int elementSize);
    public virtual IAsyncResult BeginInvoke(Register register, int elementIndex, int elementSize, AsyncCallback callback, object object);
    public virtual ulong EndInvoke(IAsyncResult result);
}
internal class Iced.Intel.VARegisterValueProviderAdapter : object {
    
private IVARegisterValueProvider provider;
    [NullableContextAttribute("1")]
public VARegisterValueProviderAdapter(IVARegisterValueProvider provider);
    public sealed virtual bool TryGetRegisterValue(Register register, int elementIndex, int elementSize, UInt64& value);
}
internal class Iced.Intel.VARegisterValueProviderDelegateImpl : object {
    
private VAGetRegisterValue getRegisterValue;
    [NullableContextAttribute("1")]
public VARegisterValueProviderDelegateImpl(VAGetRegisterValue getRegisterValue);
    public sealed virtual bool TryGetRegisterValue(Register register, int elementIndex, int elementSize, UInt64& value);
}
internal class Iced.Intel.VATryGetRegisterValue : MulticastDelegate {
    public VATryGetRegisterValue(object object, IntPtr method);
    public virtual bool Invoke(Register register, int elementIndex, int elementSize, UInt64& value);
    public virtual IAsyncResult BeginInvoke(Register register, int elementIndex, int elementSize, UInt64& value, AsyncCallback callback, object object);
    public virtual bool EndInvoke(UInt64& value, IAsyncResult result);
}
internal class Iced.Intel.VATryGetRegisterValueDelegateImpl : object {
    
private VATryGetRegisterValue getRegisterValue;
    [NullableContextAttribute("1")]
public VATryGetRegisterValueDelegateImpl(VATryGetRegisterValue getRegisterValue);
    public sealed virtual bool TryGetRegisterValue(Register register, int elementIndex, int elementSize, UInt64& value);
}
internal enum Iced.Intel.VectorLength : Enum {
    
public int value__;
    
public static VectorLength L128;
    
public static VectorLength L256;
    
public static VectorLength L512;
    
public static VectorLength Unknown;
}
internal class Microsoft.Cci.Pdb.AlignSym : ValueType {
}
internal class Microsoft.Cci.Pdb.AnnotationSym : ValueType {
    
internal UInt32 off;
    
internal ushort seg;
    
internal ushort csz;
    
internal String[] rgsz;
}
internal class Microsoft.Cci.Pdb.AttrManyRegSym : ValueType {
    
internal UInt32 typind;
    
internal UInt32 offCod;
    
internal ushort segCod;
    
internal ushort flags;
    
internal byte count;
    
internal Byte[] reg;
    
internal string name;
}
internal class Microsoft.Cci.Pdb.AttrManyRegSym2 : ValueType {
    
internal UInt32 typind;
    
internal UInt32 offCod;
    
internal ushort segCod;
    
internal ushort flags;
    
internal ushort count;
    
internal UInt16[] reg;
    
internal string name;
}
internal class Microsoft.Cci.Pdb.AttrRegRel : ValueType {
    
internal UInt32 off;
    
internal UInt32 typind;
    
internal ushort reg;
    
internal UInt32 offCod;
    
internal ushort segCod;
    
internal ushort flags;
    
internal string name;
}
internal class Microsoft.Cci.Pdb.AttrRegSym : ValueType {
    
internal UInt32 typind;
    
internal UInt32 offCod;
    
internal ushort segCod;
    
internal ushort flags;
    
internal ushort reg;
    
internal string name;
}
internal class Microsoft.Cci.Pdb.AttrSlotSym : ValueType {
    
internal UInt32 index;
    
internal UInt32 typind;
    
internal UInt32 offCod;
    
internal ushort segCod;
    
internal ushort flags;
    
internal string name;
}
internal class Microsoft.Cci.Pdb.BitAccess : object {
    
private Byte[] buffer;
    
private int offset;
    
internal Byte[] Buffer { get; }
    
internal int Position { get; internal set; }
    internal BitAccess(int capacity);
    internal BitAccess(Byte[] buffer);
    internal Byte[] get_Buffer();
    internal void FillBuffer(Stream stream, int capacity);
    internal void Append(Stream stream, int count);
    internal int get_Position();
    internal void set_Position(int value);
    internal void MinCapacity(int capacity);
    internal void Align(int alignment);
    internal void ReadInt16(Int16& value);
    internal void ReadInt8(SByte& value);
    internal void ReadInt32(Int32& value);
    internal void ReadInt64(Int64& value);
    internal void ReadUInt16(UInt16& value);
    internal void ReadUInt8(Byte& value);
    internal void ReadUInt32(UInt32& value);
    internal void ReadUInt64(UInt64& value);
    internal void ReadInt32(Int32[] values);
    internal void ReadUInt32(UInt32[] values);
    internal void ReadBytes(Byte[] bytes);
    internal float ReadFloat();
    internal double ReadDouble();
    internal decimal ReadDecimal();
    internal void ReadBString(String& value);
    internal string ReadBString(int len);
    internal void ReadCString(String& value);
    internal void SkipCString(String& value);
    internal void ReadGuid(Guid& guid);
    internal string ReadString();
}
internal class Microsoft.Cci.Pdb.BitSet : ValueType {
    
private int size;
    
private UInt32[] words;
    
internal bool IsEmpty { get; }
    internal BitSet(BitAccess bits);
    internal bool IsSet(int index);
    private static UInt32 GetBit(int index);
    internal bool get_IsEmpty();
}
internal class Microsoft.Cci.Pdb.BlockSym32 : ValueType {
    
internal UInt32 parent;
    
internal UInt32 end;
    
internal UInt32 len;
    
internal UInt32 off;
    
internal ushort seg;
    
internal string name;
}
internal class Microsoft.Cci.Pdb.BpRelSym32 : ValueType {
    
internal int off;
    
internal UInt32 typind;
    
internal string name;
}
internal class Microsoft.Cci.Pdb.CallsiteInfo : ValueType {
    
internal int off;
    
internal ushort ect;
    
internal ushort pad0;
    
internal UInt32 typind;
}
internal class Microsoft.Cci.Pdb.CFlagSym : ValueType {
    
internal byte machine;
    
internal byte language;
    
internal ushort flags;
    
internal string ver;
}
[FlagsAttribute]
internal enum Microsoft.Cci.Pdb.CFLAGSYM_FLAGS : Enum {
    
public ushort value__;
    
public static CFLAGSYM_FLAGS pcode;
    
public static CFLAGSYM_FLAGS floatprec;
    
public static CFLAGSYM_FLAGS floatpkg;
    
public static CFLAGSYM_FLAGS ambdata;
    
public static CFLAGSYM_FLAGS ambcode;
    
public static CFLAGSYM_FLAGS mode32;
}
internal class Microsoft.Cci.Pdb.CoffGroupSym : ValueType {
    
internal UInt32 cb;
    
internal UInt32 characteristics;
    
internal UInt32 off;
    
internal ushort seg;
    
internal string name;
}
internal class Microsoft.Cci.Pdb.CompileSym : ValueType {
    
internal UInt32 flags;
    
internal ushort machine;
    
internal ushort verFEMajor;
    
internal ushort verFEMinor;
    
internal ushort verFEBuild;
    
internal ushort verMajor;
    
internal ushort verMinor;
    
internal ushort verBuild;
    
internal string verSt;
    
internal String[] verArgs;
}
[FlagsAttribute]
internal enum Microsoft.Cci.Pdb.COMPILESYM_FLAGS : Enum {
    
public UInt32 value__;
    
public static COMPILESYM_FLAGS iLanguage;
    
public static COMPILESYM_FLAGS fEC;
    
public static COMPILESYM_FLAGS fNoDbgInfo;
    
public static COMPILESYM_FLAGS fLTCG;
    
public static COMPILESYM_FLAGS fNoDataAlign;
    
public static COMPILESYM_FLAGS fManagedPresent;
    
public static COMPILESYM_FLAGS fSecurityChecks;
    
public static COMPILESYM_FLAGS fHotPatch;
    
public static COMPILESYM_FLAGS fCVTCIL;
    
public static COMPILESYM_FLAGS fMSILModule;
}
internal class Microsoft.Cci.Pdb.ConstSym : ValueType {
    
internal UInt32 typind;
    
internal ushort value;
    
internal string name;
}
internal enum Microsoft.Cci.Pdb.CV_CFL_CODE : Enum {
    
public int value__;
    
public static CV_CFL_CODE CV_CFL_CNEAR;
    
public static CV_CFL_CODE CV_CFL_CFAR;
    
public static CV_CFL_CODE CV_CFL_CHUGE;
}
internal enum Microsoft.Cci.Pdb.CV_CFL_DATA : Enum {
    
public int value__;
    
public static CV_CFL_DATA CV_CFL_DNEAR;
    
public static CV_CFL_DATA CV_CFL_DFAR;
    
public static CV_CFL_DATA CV_CFL_DHUGE;
}
internal enum Microsoft.Cci.Pdb.CV_CFL_FPKG : Enum {
    
public int value__;
    
public static CV_CFL_FPKG CV_CFL_NDP;
    
public static CV_CFL_FPKG CV_CFL_EMU;
    
public static CV_CFL_FPKG CV_CFL_ALT;
}
internal class Microsoft.Cci.Pdb.CV_Column : ValueType {
    
internal ushort offColumnStart;
    
internal ushort offColumnEnd;
}
internal enum Microsoft.Cci.Pdb.CV_cookietype : Enum {
    
public int value__;
    
public static CV_cookietype CV_COOKIETYPE_COPY;
    
public static CV_cookietype CV_COOKIETYPE_XOR_SP;
    
public static CV_cookietype CV_COOKIETYPE_XOR_BP;
    
public static CV_cookietype CV_COOKIETYPE_XOR_R13;
}
internal enum Microsoft.Cci.Pdb.CV_DISCARDED : Enum {
    
public UInt32 value__;
    
public static CV_DISCARDED CV_DISCARDED_UNKNOWN;
    
public static CV_DISCARDED CV_DISCARDED_NOT_SELECTED;
    
public static CV_DISCARDED CV_DISCARDED_NOT_REFERENCED;
}
internal class Microsoft.Cci.Pdb.CV_EXPROCFLAGS : ValueType {
    
internal byte flags;
    
internal byte reserved;
}
internal enum Microsoft.Cci.Pdb.CV_FILE_CHECKSUM_TYPE : Enum {
    
public byte value__;
    
public static CV_FILE_CHECKSUM_TYPE None;
    
public static CV_FILE_CHECKSUM_TYPE MD5;
}
internal class Microsoft.Cci.Pdb.CV_FileCheckSum : ValueType {
    
internal UInt32 name;
    
internal byte len;
    
internal byte type;
}
[FlagsAttribute]
internal enum Microsoft.Cci.Pdb.CV_fldattr : Enum {
    
public int value__;
    
public static CV_fldattr access;
    
public static CV_fldattr mprop;
    
public static CV_fldattr pseudo;
    
public static CV_fldattr noinherit;
    
public static CV_fldattr noconstruct;
    
public static CV_fldattr compgenx;
}
[FlagsAttribute]
internal enum Microsoft.Cci.Pdb.CV_GENERIC_FLAG : Enum {
    
public ushort value__;
    
public static CV_GENERIC_FLAG cstyle;
    
public static CV_GENERIC_FLAG rsclean;
}
internal enum Microsoft.Cci.Pdb.CV_GENERIC_STYLE : Enum {
    
public int value__;
    
public static CV_GENERIC_STYLE CV_GENERIC_VOID;
    
public static CV_GENERIC_STYLE CV_GENERIC_REG;
    
public static CV_GENERIC_STYLE CV_GENERIC_ICAN;
    
public static CV_GENERIC_STYLE CV_GENERIC_ICAF;
    
public static CV_GENERIC_STYLE CV_GENERIC_IRAN;
    
public static CV_GENERIC_STYLE CV_GENERIC_IRAF;
    
public static CV_GENERIC_STYLE CV_GENERIC_UNUSED;
}
internal enum Microsoft.Cci.Pdb.CV_int : Enum {
    
public int value__;
    
public static CV_int CV_RI_CHAR;
    
public static CV_int CV_RI_INT1;
    
public static CV_int CV_RI_WCHAR;
    
public static CV_int CV_RI_UINT1;
    
public static CV_int CV_RI_INT2;
    
public static CV_int CV_RI_UINT2;
    
public static CV_int CV_RI_INT4;
    
public static CV_int CV_RI_UINT4;
    
public static CV_int CV_RI_INT8;
    
public static CV_int CV_RI_UINT8;
    
public static CV_int CV_RI_INT16;
    
public static CV_int CV_RI_UINT16;
}
internal enum Microsoft.Cci.Pdb.CV_integral : Enum {
    
public int value__;
    
public static CV_integral CV_IN_1BYTE;
    
public static CV_integral CV_IN_2BYTE;
    
public static CV_integral CV_IN_4BYTE;
    
public static CV_integral CV_IN_8BYTE;
    
public static CV_integral CV_IN_16BYTE;
}
internal enum Microsoft.Cci.Pdb.CV_LABEL_TYPE : Enum {
    
public int value__;
    
public static CV_LABEL_TYPE CV_LABEL_NEAR;
    
public static CV_LABEL_TYPE CV_LABEL_FAR;
}
internal class Microsoft.Cci.Pdb.CV_Line : ValueType {
    
internal UInt32 offset;
    
internal UInt32 flags;
}
[FlagsAttribute]
internal enum Microsoft.Cci.Pdb.CV_Line_Flags : Enum {
    
public UInt32 value__;
    
public static CV_Line_Flags linenumStart;
    
public static CV_Line_Flags deltaLineEnd;
    
public static CV_Line_Flags fStatement;
}
internal enum Microsoft.Cci.Pdb.CV_LINE_SUBSECTION_FLAGS : Enum {
    
public ushort value__;
    
public static CV_LINE_SUBSECTION_FLAGS CV_LINES_HAVE_COLUMNS;
}
internal class Microsoft.Cci.Pdb.CV_LineSection : ValueType {
    
internal UInt32 off;
    
internal ushort sec;
    
internal ushort flags;
    
internal UInt32 cod;
}
internal class Microsoft.Cci.Pdb.CV_lvar_addr_range : ValueType {
    
internal UInt32 offStart;
    
internal ushort isectStart;
    
internal UInt32 cbRange;
}
[FlagsAttribute]
internal enum Microsoft.Cci.Pdb.CV_LVARFLAGS : Enum {
    
public ushort value__;
    
public static CV_LVARFLAGS fIsParam;
    
public static CV_LVARFLAGS fAddrTaken;
    
public static CV_LVARFLAGS fCompGenx;
    
public static CV_LVARFLAGS fIsAggregate;
    
public static CV_LVARFLAGS fIsAggregated;
    
public static CV_LVARFLAGS fIsAliased;
    
public static CV_LVARFLAGS fIsAlias;
}
internal enum Microsoft.Cci.Pdb.CV_methodprop : Enum {
    
public int value__;
    
public static CV_methodprop CV_MTvanilla;
    
public static CV_methodprop CV_MTvirtual;
    
public static CV_methodprop CV_MTstatic;
    
public static CV_methodprop CV_MTfriend;
    
public static CV_methodprop CV_MTintro;
    
public static CV_methodprop CV_MTpurevirt;
    
public static CV_methodprop CV_MTpureintro;
}
[FlagsAttribute]
internal enum Microsoft.Cci.Pdb.CV_modifier : Enum {
    
public ushort value__;
    
public static CV_modifier MOD_const;
    
public static CV_modifier MOD_volatile;
    
public static CV_modifier MOD_unaligned;
}
internal class Microsoft.Cci.Pdb.CV_PDMR32_NVVFCN : ValueType {
    
internal int mdisp;
}
internal class Microsoft.Cci.Pdb.CV_PDMR32_VBASE : ValueType {
    
internal int mdisp;
    
internal int pdisp;
    
internal int vdisp;
}
internal class Microsoft.Cci.Pdb.CV_PMFR32_NVMA : ValueType {
    
internal UInt32 off;
    
internal int disp;
}
internal class Microsoft.Cci.Pdb.CV_PMFR32_NVSA : ValueType {
    
internal UInt32 off;
}
internal class Microsoft.Cci.Pdb.CV_PMFR32_VBASE : ValueType {
    
internal UInt32 off;
    
internal int mdisp;
    
internal int pdisp;
    
internal int vdisp;
}
internal enum Microsoft.Cci.Pdb.CV_pmtype : Enum {
    
public int value__;
    
public static CV_pmtype CV_PMTYPE_Undef;
    
public static CV_pmtype CV_PMTYPE_D_Single;
    
public static CV_pmtype CV_PMTYPE_D_Multiple;
    
public static CV_pmtype CV_PMTYPE_D_Virtual;
    
public static CV_pmtype CV_PMTYPE_D_General;
    
public static CV_pmtype CV_PMTYPE_F_Single;
    
public static CV_pmtype CV_PMTYPE_F_Multiple;
    
public static CV_pmtype CV_PMTYPE_F_Virtual;
    
public static CV_pmtype CV_PMTYPE_F_General;
}
internal class Microsoft.Cci.Pdb.CV_PRIMITIVE_TYPE : ValueType {
    
private static UInt32 CV_MMASK;
    
private static UInt32 CV_TMASK;
    
private static UInt32 CV_SMASK;
    
private static int CV_MSHIFT;
    
private static int CV_TSHIFT;
    
private static int CV_SSHIFT;
    
private static UInt32 CV_FIRST_NONPRIM;
}
internal enum Microsoft.Cci.Pdb.CV_prmode : Enum {
    
public int value__;
    
public static CV_prmode CV_TM_DIRECT;
    
public static CV_prmode CV_TM_NPTR32;
    
public static CV_prmode CV_TM_NPTR64;
    
public static CV_prmode CV_TM_NPTR128;
}
[FlagsAttribute]
internal enum Microsoft.Cci.Pdb.CV_PROCFLAGS : Enum {
    
public byte value__;
    
public static CV_PROCFLAGS CV_PFLAG_NOFPO;
    
public static CV_PROCFLAGS CV_PFLAG_INT;
    
public static CV_PROCFLAGS CV_PFLAG_FAR;
    
public static CV_PROCFLAGS CV_PFLAG_NEVER;
    
public static CV_PROCFLAGS CV_PFLAG_NOTREACHED;
    
public static CV_PROCFLAGS CV_PFLAG_CUST_CALL;
    
public static CV_PROCFLAGS CV_PFLAG_NOINLINE;
    
public static CV_PROCFLAGS CV_PFLAG_OPTDBGINFO;
}
[FlagsAttribute]
internal enum Microsoft.Cci.Pdb.CV_prop : Enum {
    
public ushort value__;
    
public static CV_prop packed;
    
public static CV_prop ctor;
    
public static CV_prop ovlops;
    
public static CV_prop isnested;
    
public static CV_prop cnested;
    
public static CV_prop opassign;
    
public static CV_prop opcast;
    
public static CV_prop fwdref;
    
public static CV_prop scoped;
}
internal enum Microsoft.Cci.Pdb.CV_ptrmode : Enum {
    
public int value__;
    
public static CV_ptrmode CV_PTR_MODE_PTR;
    
public static CV_ptrmode CV_PTR_MODE_REF;
    
public static CV_ptrmode CV_PTR_MODE_PMEM;
    
public static CV_ptrmode CV_PTR_MODE_PMFUNC;
    
public static CV_ptrmode CV_PTR_MODE_RESERVED;
}
internal enum Microsoft.Cci.Pdb.CV_ptrtype : Enum {
    
public int value__;
    
public static CV_ptrtype CV_PTR_BASE_SEG;
    
public static CV_ptrtype CV_PTR_BASE_VAL;
    
public static CV_ptrtype CV_PTR_BASE_SEGVAL;
    
public static CV_ptrtype CV_PTR_BASE_ADDR;
    
public static CV_ptrtype CV_PTR_BASE_SEGADDR;
    
public static CV_ptrtype CV_PTR_BASE_TYPE;
    
public static CV_ptrtype CV_PTR_BASE_SELF;
    
public static CV_ptrtype CV_PTR_NEAR32;
    
public static CV_ptrtype CV_PTR_64;
    
public static CV_ptrtype CV_PTR_UNUSEDPTR;
}
[FlagsAttribute]
internal enum Microsoft.Cci.Pdb.CV_PUBSYMFLAGS : Enum {
    
public UInt32 value__;
    
public static CV_PUBSYMFLAGS fNone;
    
public static CV_PUBSYMFLAGS fCode;
    
public static CV_PUBSYMFLAGS fFunction;
    
public static CV_PUBSYMFLAGS fManaged;
    
public static CV_PUBSYMFLAGS fMSIL;
}
internal enum Microsoft.Cci.Pdb.CV_real : Enum {
    
public int value__;
    
public static CV_real CV_RC_REAL32;
    
public static CV_real CV_RC_REAL64;
    
public static CV_real CV_RC_REAL80;
    
public static CV_real CV_RC_REAL128;
}
[FlagsAttribute]
internal enum Microsoft.Cci.Pdb.CV_SEPCODEFLAGS : Enum {
    
public UInt32 value__;
    
public static CV_SEPCODEFLAGS fIsLexicalScope;
    
public static CV_SEPCODEFLAGS fReturnsToParent;
}
internal enum Microsoft.Cci.Pdb.CV_SIGNATURE : Enum {
    
public int value__;
    
public static CV_SIGNATURE C6;
    
public static CV_SIGNATURE C7;
    
public static CV_SIGNATURE C11;
    
public static CV_SIGNATURE C13;
    
public static CV_SIGNATURE RESERVERD;
}
internal class Microsoft.Cci.Pdb.CV_SourceFile : ValueType {
    
internal UInt32 index;
    
internal UInt32 count;
    
internal UInt32 linsiz;
}
internal enum Microsoft.Cci.Pdb.CV_special : Enum {
    
public int value__;
    
public static CV_special CV_SP_NOTYPE;
    
public static CV_special CV_SP_ABS;
    
public static CV_special CV_SP_SEGMENT;
    
public static CV_special CV_SP_VOID;
    
public static CV_special CV_SP_CURRENCY;
    
public static CV_special CV_SP_NBASICSTR;
    
public static CV_special CV_SP_FBASICSTR;
    
public static CV_special CV_SP_NOTTRANS;
    
public static CV_special CV_SP_HRESULT;
}
internal enum Microsoft.Cci.Pdb.CV_special2 : Enum {
    
public int value__;
    
public static CV_special2 CV_S2_BIT;
    
public static CV_special2 CV_S2_PASCHAR;
}
internal enum Microsoft.Cci.Pdb.CV_type : Enum {
    
public int value__;
    
public static CV_type CV_SPECIAL;
    
public static CV_type CV_SIGNED;
    
public static CV_type CV_UNSIGNED;
    
public static CV_type CV_BOOLEAN;
    
public static CV_type CV_REAL;
    
public static CV_type CV_COMPLEX;
    
public static CV_type CV_SPECIAL2;
    
public static CV_type CV_INT;
    
public static CV_type CV_CVRESERVED;
}
internal enum Microsoft.Cci.Pdb.CV_VTS_desc : Enum {
    
public int value__;
    
public static CV_VTS_desc CV_VTS_near;
    
public static CV_VTS_desc CV_VTS_far;
    
public static CV_VTS_desc CV_VTS_thin;
    
public static CV_VTS_desc CV_VTS_outer;
    
public static CV_VTS_desc CV_VTS_meta;
    
public static CV_VTS_desc CV_VTS_near32;
    
public static CV_VTS_desc CV_VTS_far32;
    
public static CV_VTS_desc CV_VTS_unused;
}
internal class Microsoft.Cci.Pdb.DatasSym32 : ValueType {
    
internal UInt32 typind;
    
internal UInt32 off;
    
internal ushort seg;
    
internal string name;
}
internal class Microsoft.Cci.Pdb.DataStream : object {
    
internal int contentSize;
    
internal Int32[] pages;
    
internal int Length { get; }
    internal DataStream(int contentSize, BitAccess bits, int count);
    internal void Read(PdbReader reader, BitAccess bits);
    internal void Read(PdbReader reader, int position, Byte[] bytes, int offset, int data);
    internal int get_Length();
}
internal class Microsoft.Cci.Pdb.DbiDbgHdr : ValueType {
    
internal ushort snFPO;
    
internal ushort snException;
    
internal ushort snFixup;
    
internal ushort snOmapToSrc;
    
internal ushort snOmapFromSrc;
    
internal ushort snSectionHdr;
    
internal ushort snTokenRidMap;
    
internal ushort snXdata;
    
internal ushort snPdata;
    
internal ushort snNewFPO;
    
internal ushort snSectionHdrOrig;
    internal DbiDbgHdr(BitAccess bits);
}
internal class Microsoft.Cci.Pdb.DbiHeader : ValueType {
    
internal int sig;
    
internal int ver;
    
internal int age;
    
internal short gssymStream;
    
internal ushort vers;
    
internal short pssymStream;
    
internal ushort pdbver;
    
internal short symrecStream;
    
internal ushort pdbver2;
    
internal int gpmodiSize;
    
internal int secconSize;
    
internal int secmapSize;
    
internal int filinfSize;
    
internal int tsmapSize;
    
internal int mfcIndex;
    
internal int dbghdrSize;
    
internal int ecinfoSize;
    
internal ushort flags;
    
internal ushort machine;
    
internal int reserved;
    internal DbiHeader(BitAccess bits);
}
internal class Microsoft.Cci.Pdb.DbiModuleInfo : object {
    
internal int opened;
    
internal ushort flags;
    
internal short stream;
    
internal int cbSyms;
    
internal int cbOldLines;
    
internal int cbLines;
    
internal short files;
    
internal short pad1;
    
internal UInt32 offsets;
    
internal int niSource;
    
internal int niCompiler;
    
internal string moduleName;
    
internal string objectName;
    internal DbiModuleInfo(BitAccess bits, bool readStrings);
}
internal class Microsoft.Cci.Pdb.DbiSecCon : ValueType {
    
internal short section;
    
internal short pad1;
    
internal int offset;
    
internal int size;
    
internal UInt32 flags;
    
internal short module;
    
internal short pad2;
    
internal UInt32 dataCrc;
    
internal UInt32 relocCrc;
    internal DbiSecCon(BitAccess bits);
}
internal enum Microsoft.Cci.Pdb.DEBUG_S_SUBSECTION : Enum {
    
public int value__;
    
public static DEBUG_S_SUBSECTION SYMBOLS;
    
public static DEBUG_S_SUBSECTION LINES;
    
public static DEBUG_S_SUBSECTION STRINGTABLE;
    
public static DEBUG_S_SUBSECTION FILECHKSMS;
    
public static DEBUG_S_SUBSECTION FRAMEDATA;
}
internal enum Microsoft.Cci.Pdb.DEBUG_S_SUBSECTION_TYPE : Enum {
    
public UInt32 value__;
    
public static DEBUG_S_SUBSECTION_TYPE DEBUG_S_IGNORE;
    
public static DEBUG_S_SUBSECTION_TYPE DEBUG_S_SYMBOLS;
    
public static DEBUG_S_SUBSECTION_TYPE DEBUG_S_LINES;
    
public static DEBUG_S_SUBSECTION_TYPE DEBUG_S_STRINGTABLE;
    
public static DEBUG_S_SUBSECTION_TYPE DEBUG_S_FILECHKSMS;
    
public static DEBUG_S_SUBSECTION_TYPE DEBUG_S_FRAMEDATA;
}
internal class Microsoft.Cci.Pdb.DefRangeSym : ValueType {
    
internal UInt32 id;
    
internal UInt32 program;
    
internal CV_lvar_addr_range range;
}
internal class Microsoft.Cci.Pdb.DefRangeSym2 : ValueType {
    
internal UInt32 id;
    
internal UInt32 program;
    
internal ushort count;
    
internal CV_lvar_addr_range[] range;
}
internal class Microsoft.Cci.Pdb.DiscardedSym : ValueType {
    
internal CV_DISCARDED iscarded;
    
internal UInt32 fileid;
    
internal UInt32 linenum;
    
internal Byte[] data;
}
internal class Microsoft.Cci.Pdb.EndArgSym : ValueType {
}
internal class Microsoft.Cci.Pdb.EntryThisSym : ValueType {
    
internal byte thissym;
}
internal class Microsoft.Cci.Pdb.ExportSym : ValueType {
    
internal ushort ordinal;
    
internal ushort flags;
    
internal string name;
}
[FlagsAttribute]
internal enum Microsoft.Cci.Pdb.EXPORTSYM_FLAGS : Enum {
    
public ushort value__;
    
public static EXPORTSYM_FLAGS fConstant;
    
public static EXPORTSYM_FLAGS fData;
    
public static EXPORTSYM_FLAGS fPrivate;
    
public static EXPORTSYM_FLAGS fNoName;
    
public static EXPORTSYM_FLAGS fOrdinal;
    
public static EXPORTSYM_FLAGS fForwarder;
}
internal class Microsoft.Cci.Pdb.FLOAT10 : ValueType {
    
internal byte Data_0;
    
internal byte Data_1;
    
internal byte Data_2;
    
internal byte Data_3;
    
internal byte Data_4;
    
internal byte Data_5;
    
internal byte Data_6;
    
internal byte Data_7;
    
internal byte Data_8;
    
internal byte Data_9;
}
internal class Microsoft.Cci.Pdb.FrameCookie : ValueType {
    
internal int off;
    
internal ushort reg;
    
internal int cookietype;
    
internal byte flags;
}
internal class Microsoft.Cci.Pdb.FrameData : ValueType {
    
internal UInt32 ulRvaStart;
    
internal UInt32 cbBlock;
    
internal UInt32 cbLocals;
    
internal UInt32 cbParams;
    
internal UInt32 cbStkMax;
    
internal UInt32 frameFunc;
    
internal ushort cbProlog;
    
internal ushort cbSavedRegs;
    
internal UInt32 flags;
}
[FlagsAttribute]
internal enum Microsoft.Cci.Pdb.FRAMEDATA_FLAGS : Enum {
    
public UInt32 value__;
    
public static FRAMEDATA_FLAGS fHasSEH;
    
public static FRAMEDATA_FLAGS fHasEH;
    
public static FRAMEDATA_FLAGS fIsFunctionStart;
}
internal class Microsoft.Cci.Pdb.FrameProcSym : ValueType {
    
internal UInt32 cbFrame;
    
internal UInt32 cbPad;
    
internal UInt32 offPad;
    
internal UInt32 cbSaveRegs;
    
internal UInt32 offExHdlr;
    
internal ushort secExHdlr;
    
internal UInt32 flags;
}
[FlagsAttribute]
internal enum Microsoft.Cci.Pdb.FRAMEPROCSYM_FLAGS : Enum {
    
public UInt32 value__;
    
public static FRAMEPROCSYM_FLAGS fHasAlloca;
    
public static FRAMEPROCSYM_FLAGS fHasSetJmp;
    
public static FRAMEPROCSYM_FLAGS fHasLongJmp;
    
public static FRAMEPROCSYM_FLAGS fHasInlAsm;
    
public static FRAMEPROCSYM_FLAGS fHasEH;
    
public static FRAMEPROCSYM_FLAGS fInlSpec;
    
public static FRAMEPROCSYM_FLAGS fHasSEH;
    
public static FRAMEPROCSYM_FLAGS fNaked;
    
public static FRAMEPROCSYM_FLAGS fSecurityChecks;
    
public static FRAMEPROCSYM_FLAGS fAsyncEH;
    
public static FRAMEPROCSYM_FLAGS fGSNoStackOrdering;
    
public static FRAMEPROCSYM_FLAGS fWasInlined;
}
internal class Microsoft.Cci.Pdb.FrameRelSym : ValueType {
    
internal int off;
    
internal UInt32 typind;
    
internal UInt32 offCod;
    
internal ushort segCod;
    
internal ushort flags;
    
internal string name;
}
internal interface Microsoft.Cci.Pdb.ILocalScope {
    
public UInt32 Offset { get; }
    
public UInt32 Length { get; }
    public abstract virtual UInt32 get_Offset();
    public abstract virtual UInt32 get_Length();
}
internal interface Microsoft.Cci.Pdb.IName {
    
public int UniqueKey { get; }
    
public int UniqueKeyIgnoringCase { get; }
    
public string Value { get; }
    public abstract virtual int get_UniqueKey();
    public abstract virtual int get_UniqueKeyIgnoringCase();
    public abstract virtual string get_Value();
}
internal interface Microsoft.Cci.Pdb.INamespaceScope {
    
public IEnumerable`1<IUsedNamespace> UsedNamespaces { get; }
    public abstract virtual IEnumerable`1<IUsedNamespace> get_UsedNamespaces();
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.Cci.Pdb.IntHashTable : object {
    
private static Int32[] primes;
    
private bucket[] buckets;
    
private int count;
    
private int occupancy;
    
private int loadsize;
    
private int loadFactorPerc;
    
private int version;
    
internal object Item { get; }
    internal IntHashTable(int capacity, int loadFactorPerc);
    private static IntHashTable();
    private static int GetPrime(int minSize);
    private static UInt32 InitHash(int key, int hashsize, UInt32& seed, UInt32& incr);
    internal void Add(int key, object value);
    internal object get_Item(int key);
    private void expand();
    private void rehash();
    private void rehash(int newsize);
    private void Insert(int key, object nvalue, bool add);
    private void putEntry(bucket[] newBuckets, int key, object nvalue, int hashcode);
}
internal interface Microsoft.Cci.Pdb.IUsedNamespace {
    
public IName Alias { get; }
    
public IName NamespaceName { get; }
    public abstract virtual IName get_Alias();
    public abstract virtual IName get_NamespaceName();
}
internal class Microsoft.Cci.Pdb.LabelSym32 : ValueType {
    
internal UInt32 off;
    
internal ushort seg;
    
internal byte flags;
    
internal string name;
}
internal enum Microsoft.Cci.Pdb.LEAF : Enum {
    
public int value__;
    
public static LEAF LF_VTSHAPE;
    
public static LEAF LF_COBOL1;
    
public static LEAF LF_LABEL;
    
public static LEAF LF_NULL;
    
public static LEAF LF_NOTTRAN;
    
public static LEAF LF_ENDPRECOMP;
    
public static LEAF LF_TYPESERVER_ST;
    
public static LEAF LF_LIST;
    
public static LEAF LF_REFSYM;
    
public static LEAF LF_ENUMERATE_ST;
    
public static LEAF LF_TI16_MAX;
    
public static LEAF LF_MODIFIER;
    
public static LEAF LF_POINTER;
    
public static LEAF LF_ARRAY_ST;
    
public static LEAF LF_CLASS_ST;
    
public static LEAF LF_STRUCTURE_ST;
    
public static LEAF LF_UNION_ST;
    
public static LEAF LF_ENUM_ST;
    
public static LEAF LF_PROCEDURE;
    
public static LEAF LF_MFUNCTION;
    
public static LEAF LF_COBOL0;
    
public static LEAF LF_BARRAY;
    
public static LEAF LF_DIMARRAY_ST;
    
public static LEAF LF_VFTPATH;
    
public static LEAF LF_PRECOMP_ST;
    
public static LEAF LF_OEM;
    
public static LEAF LF_ALIAS_ST;
    
public static LEAF LF_OEM2;
    
public static LEAF LF_SKIP;
    
public static LEAF LF_ARGLIST;
    
public static LEAF LF_DEFARG_ST;
    
public static LEAF LF_FIELDLIST;
    
public static LEAF LF_DERIVED;
    
public static LEAF LF_BITFIELD;
    
public static LEAF LF_METHODLIST;
    
public static LEAF LF_DIMCONU;
    
public static LEAF LF_DIMCONLU;
    
public static LEAF LF_DIMVARU;
    
public static LEAF LF_DIMVARLU;
    
public static LEAF LF_BCLASS;
    
public static LEAF LF_VBCLASS;
    
public static LEAF LF_IVBCLASS;
    
public static LEAF LF_FRIENDFCN_ST;
    
public static LEAF LF_INDEX;
    
public static LEAF LF_MEMBER_ST;
    
public static LEAF LF_STMEMBER_ST;
    
public static LEAF LF_METHOD_ST;
    
public static LEAF LF_NESTTYPE_ST;
    
public static LEAF LF_VFUNCTAB;
    
public static LEAF LF_FRIENDCLS;
    
public static LEAF LF_ONEMETHOD_ST;
    
public static LEAF LF_VFUNCOFF;
    
public static LEAF LF_NESTTYPEEX_ST;
    
public static LEAF LF_MEMBERMODIFY_ST;
    
public static LEAF LF_MANAGED_ST;
    
public static LEAF LF_ST_MAX;
    
public static LEAF LF_TYPESERVER;
    
public static LEAF LF_ENUMERATE;
    
public static LEAF LF_ARRAY;
    
public static LEAF LF_CLASS;
    
public static LEAF LF_STRUCTURE;
    
public static LEAF LF_UNION;
    
public static LEAF LF_ENUM;
    
public static LEAF LF_DIMARRAY;
    
public static LEAF LF_PRECOMP;
    
public static LEAF LF_ALIAS;
    
public static LEAF LF_DEFARG;
    
public static LEAF LF_FRIENDFCN;
    
public static LEAF LF_MEMBER;
    
public static LEAF LF_STMEMBER;
    
public static LEAF LF_METHOD;
    
public static LEAF LF_NESTTYPE;
    
public static LEAF LF_ONEMETHOD;
    
public static LEAF LF_NESTTYPEEX;
    
public static LEAF LF_MEMBERMODIFY;
    
public static LEAF LF_MANAGED;
    
public static LEAF LF_TYPESERVER2;
    
public static LEAF LF_NUMERIC;
    
public static LEAF LF_CHAR;
    
public static LEAF LF_SHORT;
    
public static LEAF LF_USHORT;
    
public static LEAF LF_LONG;
    
public static LEAF LF_ULONG;
    
public static LEAF LF_REAL32;
    
public static LEAF LF_REAL64;
    
public static LEAF LF_REAL80;
    
public static LEAF LF_REAL128;
    
public static LEAF LF_QUADWORD;
    
public static LEAF LF_UQUADWORD;
    
public static LEAF LF_COMPLEX32;
    
public static LEAF LF_COMPLEX64;
    
public static LEAF LF_COMPLEX80;
    
public static LEAF LF_COMPLEX128;
    
public static LEAF LF_VARSTRING;
    
public static LEAF LF_OCTWORD;
    
public static LEAF LF_UOCTWORD;
    
public static LEAF LF_DECIMAL;
    
public static LEAF LF_DATE;
    
public static LEAF LF_UTF8STRING;
    
public static LEAF LF_PAD0;
    
public static LEAF LF_PAD1;
    
public static LEAF LF_PAD2;
    
public static LEAF LF_PAD3;
    
public static LEAF LF_PAD4;
    
public static LEAF LF_PAD5;
    
public static LEAF LF_PAD6;
    
public static LEAF LF_PAD7;
    
public static LEAF LF_PAD8;
    
public static LEAF LF_PAD9;
    
public static LEAF LF_PAD10;
    
public static LEAF LF_PAD11;
    
public static LEAF LF_PAD12;
    
public static LEAF LF_PAD13;
    
public static LEAF LF_PAD14;
    
public static LEAF LF_PAD15;
}
internal class Microsoft.Cci.Pdb.LeafAlias : ValueType {
    
internal UInt32 utype;
    
internal string name;
}
internal class Microsoft.Cci.Pdb.LeafArgList : ValueType {
    
internal UInt32 count;
    
internal UInt32[] arg;
}
internal class Microsoft.Cci.Pdb.LeafArray : ValueType {
    
internal UInt32 elemtype;
    
internal UInt32 idxtype;
    
internal Byte[] data;
    
internal string name;
}
internal class Microsoft.Cci.Pdb.LeafBArray : ValueType {
    
internal UInt32 utype;
}
internal class Microsoft.Cci.Pdb.LeafBClass : ValueType {
    
internal ushort attr;
    
internal UInt32 index;
    
internal Byte[] offset;
}
internal class Microsoft.Cci.Pdb.LeafBitfield : ValueType {
    
internal UInt32 type;
    
internal byte length;
    
internal byte position;
}
internal class Microsoft.Cci.Pdb.LeafChar : ValueType {
    
internal sbyte val;
}
internal class Microsoft.Cci.Pdb.LeafClass : ValueType {
    
internal ushort count;
    
internal ushort property;
    
internal UInt32 field;
    
internal UInt32 derived;
    
internal UInt32 vshape;
    
internal Byte[] data;
    
internal string name;
}
internal class Microsoft.Cci.Pdb.LeafCmplx128 : ValueType {
    
internal ulong val0_real;
    
internal ulong val1_real;
    
internal ulong val0_imag;
    
internal ulong val1_imag;
}
internal class Microsoft.Cci.Pdb.LeafCmplx32 : ValueType {
    
internal float val_real;
    
internal float val_imag;
}
internal class Microsoft.Cci.Pdb.LeafCmplx64 : ValueType {
    
internal double val_real;
    
internal double val_imag;
}
internal class Microsoft.Cci.Pdb.LeafCmplx80 : ValueType {
    
internal FLOAT10 val_real;
    
internal FLOAT10 val_imag;
}
internal class Microsoft.Cci.Pdb.LeafCobol0 : ValueType {
    
internal UInt32 type;
    
internal Byte[] data;
}
internal class Microsoft.Cci.Pdb.LeafCobol1 : ValueType {
    
internal Byte[] data;
}
internal class Microsoft.Cci.Pdb.LeafDefArg : ValueType {
    
internal UInt32 type;
    
internal Byte[] expr;
}
internal class Microsoft.Cci.Pdb.LeafDerived : ValueType {
    
internal UInt32 count;
    
internal UInt32[] drvdcls;
}
internal class Microsoft.Cci.Pdb.LeafDimArray : ValueType {
    
internal UInt32 utype;
    
internal UInt32 diminfo;
    
internal string name;
}
internal class Microsoft.Cci.Pdb.LeafDimCon : ValueType {
    
internal UInt32 typ;
    
internal ushort rank;
    
internal Byte[] dim;
}
internal class Microsoft.Cci.Pdb.LeafDimVar : ValueType {
    
internal UInt32 rank;
    
internal UInt32 typ;
    
internal UInt32[] dim;
}
internal class Microsoft.Cci.Pdb.LeafEndPreComp : ValueType {
    
internal UInt32 signature;
}
internal class Microsoft.Cci.Pdb.LeafEnum : ValueType {
    
internal ushort count;
    
internal ushort property;
    
internal UInt32 utype;
    
internal UInt32 field;
    
internal string name;
}
internal class Microsoft.Cci.Pdb.LeafEnumerate : ValueType {
    
internal ushort attr;
    
internal Byte[] value;
    
internal string name;
}
internal class Microsoft.Cci.Pdb.LeafFieldList : ValueType {
    
internal Char[] data;
}
internal class Microsoft.Cci.Pdb.LeafFriendCls : ValueType {
    
internal ushort pad0;
    
internal UInt32 index;
}
internal class Microsoft.Cci.Pdb.LeafFriendFcn : ValueType {
    
internal ushort pad0;
    
internal UInt32 index;
    
internal string name;
}
internal class Microsoft.Cci.Pdb.LeafIndex : ValueType {
    
internal ushort pad0;
    
internal UInt32 index;
}
internal class Microsoft.Cci.Pdb.LeafLabel : ValueType {
    
internal ushort mode;
}
internal class Microsoft.Cci.Pdb.LeafList : ValueType {
    
internal Byte[] data;
}
internal class Microsoft.Cci.Pdb.LeafLong : ValueType {
    
internal int val;
}
internal class Microsoft.Cci.Pdb.LeafManaged : ValueType {
    
internal string name;
}
internal class Microsoft.Cci.Pdb.LeafMember : ValueType {
    
internal ushort attr;
    
internal UInt32 index;
    
internal Byte[] offset;
    
internal string name;
}
internal class Microsoft.Cci.Pdb.LeafMemberModify : ValueType {
    
internal ushort attr;
    
internal UInt32 index;
    
internal string name;
}
internal class Microsoft.Cci.Pdb.LeafMethod : ValueType {
    
internal ushort count;
    
internal UInt32 mList;
    
internal string name;
}
internal class Microsoft.Cci.Pdb.LeafMethodList : ValueType {
    
internal Byte[] mList;
}
internal class Microsoft.Cci.Pdb.LeafMFunc : ValueType {
    
internal UInt32 rvtype;
    
internal UInt32 classtype;
    
internal UInt32 thistype;
    
internal byte calltype;
    
internal byte reserved;
    
internal ushort parmcount;
    
internal UInt32 arglist;
    
internal int thisadjust;
}
internal class Microsoft.Cci.Pdb.LeafModifier : ValueType {
    
internal UInt32 type;
    
internal CV_modifier attr;
}
internal class Microsoft.Cci.Pdb.LeafNestType : ValueType {
    
internal ushort pad0;
    
internal UInt32 index;
    
internal string name;
}
internal class Microsoft.Cci.Pdb.LeafNestTypeEx : ValueType {
    
internal ushort attr;
    
internal UInt32 index;
    
internal string name;
}
internal class Microsoft.Cci.Pdb.LeafOct : ValueType {
    
internal ulong val0;
    
internal ulong val1;
}
internal class Microsoft.Cci.Pdb.LeafOEM : ValueType {
    
internal ushort cvOEM;
    
internal ushort recOEM;
    
internal UInt32 count;
    
internal UInt32[] index;
}
internal class Microsoft.Cci.Pdb.LeafOEM2 : ValueType {
    
internal Guid idOem;
    
internal UInt32 count;
    
internal UInt32[] index;
}
internal class Microsoft.Cci.Pdb.LeafOneMethod : ValueType {
    
internal ushort attr;
    
internal UInt32 index;
    
internal UInt32[] vbaseoff;
    
internal string name;
}
internal class Microsoft.Cci.Pdb.LeafPad : ValueType {
    
internal byte leaf;
}
internal class Microsoft.Cci.Pdb.LeafPointer : ValueType {
}
[FlagsAttribute]
internal enum Microsoft.Cci.Pdb.LeafPointerAttr : Enum {
    
public UInt32 value__;
    
public static LeafPointerAttr ptrtype;
    
public static LeafPointerAttr ptrmode;
    
public static LeafPointerAttr isflat32;
    
public static LeafPointerAttr isvolatile;
    
public static LeafPointerAttr isconst;
    
public static LeafPointerAttr isunaligned;
    
public static LeafPointerAttr isrestrict;
}
internal class Microsoft.Cci.Pdb.LeafPreComp : ValueType {
    
internal UInt32 start;
    
internal UInt32 count;
    
internal UInt32 signature;
    
internal string name;
}
internal class Microsoft.Cci.Pdb.LeafProc : ValueType {
    
internal UInt32 rvtype;
    
internal byte calltype;
    
internal byte reserved;
    
internal ushort parmcount;
    
internal UInt32 arglist;
}
internal class Microsoft.Cci.Pdb.LeafQuad : ValueType {
    
internal long val;
}
internal class Microsoft.Cci.Pdb.LeafReal128 : ValueType {
    
internal ulong val0;
    
internal ulong val1;
}
internal class Microsoft.Cci.Pdb.LeafReal32 : ValueType {
    
internal float val;
}
internal class Microsoft.Cci.Pdb.LeafReal64 : ValueType {
    
internal double val;
}
internal class Microsoft.Cci.Pdb.LeafReal80 : ValueType {
    
internal FLOAT10 val;
}
internal class Microsoft.Cci.Pdb.LeafRefSym : ValueType {
    
internal Byte[] Sym;
}
internal class Microsoft.Cci.Pdb.LeafShort : ValueType {
    
internal short val;
}
internal class Microsoft.Cci.Pdb.LeafSkip : ValueType {
    
internal UInt32 type;
    
internal Byte[] data;
}
internal class Microsoft.Cci.Pdb.LeafSTMember : ValueType {
    
internal ushort attr;
    
internal UInt32 index;
    
internal string name;
}
internal class Microsoft.Cci.Pdb.LeafTypeServer : ValueType {
    
internal UInt32 signature;
    
internal UInt32 age;
    
internal string name;
}
internal class Microsoft.Cci.Pdb.LeafTypeServer2 : ValueType {
    
internal Guid sig70;
    
internal UInt32 age;
    
internal string name;
}
internal class Microsoft.Cci.Pdb.LeafULong : ValueType {
    
internal UInt32 val;
}
internal class Microsoft.Cci.Pdb.LeafUnion : ValueType {
    
internal ushort count;
    
internal ushort property;
    
internal UInt32 field;
    
internal Byte[] data;
    
internal string name;
}
internal class Microsoft.Cci.Pdb.LeafUOct : ValueType {
    
internal ulong val0;
    
internal ulong val1;
}
internal class Microsoft.Cci.Pdb.LeafUQuad : ValueType {
    
internal ulong val;
}
internal class Microsoft.Cci.Pdb.LeafUShort : ValueType {
    
internal ushort val;
}
internal class Microsoft.Cci.Pdb.LeafVarString : ValueType {
    
internal ushort len;
    
internal Byte[] value;
}
internal class Microsoft.Cci.Pdb.LeafVBClass : ValueType {
    
internal ushort attr;
    
internal UInt32 index;
    
internal UInt32 vbptr;
    
internal Byte[] vbpoff;
}
internal class Microsoft.Cci.Pdb.LeafVFTPath : ValueType {
    
internal UInt32 count;
    
internal UInt32[] bases;
}
internal class Microsoft.Cci.Pdb.LeafVFuncOff : ValueType {
    
internal ushort pad0;
    
internal UInt32 type;
    
internal int offset;
}
internal class Microsoft.Cci.Pdb.LeafVFuncTab : ValueType {
    
internal ushort pad0;
    
internal UInt32 type;
}
internal class Microsoft.Cci.Pdb.LeafVTShape : ValueType {
    
internal ushort count;
    
internal Byte[] desc;
}
internal class Microsoft.Cci.Pdb.LocalSym : ValueType {
    
internal UInt32 id;
    
internal UInt32 typind;
    
internal ushort flags;
    
internal UInt32 idParent;
    
internal UInt32 offParent;
    
internal UInt32 expr;
    
internal UInt32 pad0;
    
internal UInt32 pad1;
    
internal string name;
}
internal class Microsoft.Cci.Pdb.ManProcSym : ValueType {
    
internal UInt32 parent;
    
internal UInt32 end;
    
internal UInt32 next;
    
internal UInt32 len;
    
internal UInt32 dbgStart;
    
internal UInt32 dbgEnd;
    
internal UInt32 token;
    
internal UInt32 off;
    
internal ushort seg;
    
internal byte flags;
    
internal ushort retReg;
    
internal string name;
}
internal class Microsoft.Cci.Pdb.ManProcSymMips : ValueType {
    
internal UInt32 parent;
    
internal UInt32 end;
    
internal UInt32 next;
    
internal UInt32 len;
    
internal UInt32 dbgStart;
    
internal UInt32 dbgEnd;
    
internal UInt32 regSave;
    
internal UInt32 fpSave;
    
internal UInt32 intOff;
    
internal UInt32 fpOff;
    
internal UInt32 token;
    
internal UInt32 off;
    
internal ushort seg;
    
internal byte retReg;
    
internal byte frameReg;
    
internal string name;
}
internal class Microsoft.Cci.Pdb.ManyRegSym : ValueType {
    
internal UInt32 typind;
    
internal byte count;
    
internal Byte[] reg;
    
internal string name;
}
internal class Microsoft.Cci.Pdb.ManyRegSym2 : ValueType {
    
internal UInt32 typind;
    
internal ushort count;
    
internal UInt16[] reg;
    
internal string name;
}
internal class Microsoft.Cci.Pdb.ManyTypRef : ValueType {
    
internal UInt32 typind;
}
internal class Microsoft.Cci.Pdb.mlMethod : ValueType {
    
internal ushort attr;
    
internal ushort pad0;
    
internal UInt32 index;
    
internal UInt32[] vbaseoff;
}
internal class Microsoft.Cci.Pdb.MsfDirectory : object {
    
internal DataStream[] streams;
    internal MsfDirectory(PdbReader reader, PdbFileHeader head, BitAccess bits);
}
internal class Microsoft.Cci.Pdb.ObjNameSym : ValueType {
    
internal UInt32 signature;
    
internal string name;
}
internal enum Microsoft.Cci.Pdb.OEM_ID : Enum {
    
public int value__;
    
public static OEM_ID OEM_MS_FORTRAN90;
    
public static OEM_ID OEM_ODI;
    
public static OEM_ID OEM_THOMSON_SOFTWARE;
    
public static OEM_ID OEM_ODI_REC_BASELIST;
}
internal class Microsoft.Cci.Pdb.OemSymbol : ValueType {
    
internal Guid idOem;
    
internal UInt32 typind;
    
internal Byte[] rgl;
}
internal class Microsoft.Cci.Pdb.PdbConstant : object {
    
internal string name;
    
internal UInt32 token;
    
internal object value;
    internal PdbConstant(string name, UInt32 token, object value);
    internal PdbConstant(BitAccess bits);
}
internal class Microsoft.Cci.Pdb.PdbDebugException : IOException {
    internal PdbDebugException(string format, Object[] args);
}
internal class Microsoft.Cci.Pdb.PdbException : IOException {
    internal PdbException(string format, Object[] args);
}
internal class Microsoft.Cci.Pdb.PdbFile : object {
    
private static Guid BasicLanguageGuid;
    
public static Guid SymDocumentType_Text;
    private static PdbFile();
    private static void LoadInjectedSourceInformation(BitAccess bits, Guid& doctype, Guid& language, Guid& vendor, Guid& checksumAlgo, Byte[]& checksum);
    private static Dictionary`2<string, int> LoadNameIndex(BitAccess bits, Int32& age, Guid& guid);
    private static IntHashTable LoadNameStream(BitAccess bits);
    private static int FindFunction(PdbFunction[] funcs, ushort sec, UInt32 off);
    private static void LoadManagedLines(PdbFunction[] funcs, IntHashTable names, BitAccess bits, MsfDirectory dir, Dictionary`2<string, int> nameIndex, PdbReader reader, UInt32 limit, Dictionary`2<string, PdbSource> sourceCache);
    private static void LoadFuncsFromDbiModule(BitAccess bits, DbiModuleInfo info, IntHashTable names, List`1<PdbFunction> funcList, bool readStrings, MsfDirectory dir, Dictionary`2<string, int> nameIndex, PdbReader reader, Dictionary`2<string, PdbSource> sourceCache);
    private static void LoadDbiStream(BitAccess bits, DbiModuleInfo[]& modules, DbiDbgHdr& header, bool readStrings);
    internal static PdbInfo LoadFunctions(Stream read);
    private static void LoadTokenToSourceInfo(BitAccess bits, DbiModuleInfo module, IntHashTable names, MsfDirectory dir, Dictionary`2<string, int> nameIndex, PdbReader reader, Dictionary`2<UInt32, PdbTokenLine> tokenToSourceMapping, Dictionary`2<string, PdbSource> sourceCache);
    private static IntHashTable ReadSourceFileInfo(BitAccess bits, UInt32 limit, IntHashTable names, MsfDirectory dir, Dictionary`2<string, int> nameIndex, PdbReader reader, Dictionary`2<string, PdbSource> sourceCache);
}
internal class Microsoft.Cci.Pdb.PdbFileHeader : object {
    
private Byte[] windowsPdbMagic;
    
internal Byte[] magic;
    
internal int pageSize;
    
internal int freePageMap;
    
internal int pagesUsed;
    
internal int directorySize;
    
internal int zero;
    
internal Int32[] directoryRoot;
    internal PdbFileHeader(Stream reader, BitAccess bits);
}
internal class Microsoft.Cci.Pdb.PdbFunction : object {
    
internal static Guid msilMetaData;
    
internal static IComparer byAddress;
    
internal static IComparer byAddressAndToken;
    
internal UInt32 token;
    
internal UInt32 slotToken;
    
internal UInt32 tokenOfMethodWhoseUsingInfoAppliesToThisMethod;
    
internal UInt32 segment;
    
internal UInt32 address;
    
internal UInt32 length;
    
internal PdbScope[] scopes;
    
internal PdbSlot[] slots;
    
internal PdbConstant[] constants;
    
internal String[] usedNamespaces;
    
internal PdbLines[] lines;
    
internal UInt16[] usingCounts;
    
internal IEnumerable`1<INamespaceScope> namespaceScopes;
    
internal string iteratorClass;
    
internal List`1<ILocalScope> iteratorScopes;
    
internal PdbSynchronizationInformation synchronizationInformation;
    
private bool visualBasicScopesAdjusted;
    internal PdbFunction(ManProcSym proc, BitAccess bits);
    private static PdbFunction();
    private static string StripNamespace(string module);
    internal void AdjustVisualBasicScopes();
    private void AdjustVisualBasicScopes(PdbScope[] scopes);
    internal static PdbFunction[] LoadManagedFunctions(BitAccess bits, UInt32 limit, bool readStrings);
    internal static void CountScopesAndSlots(BitAccess bits, UInt32 limit, Int32& constants, Int32& scopes, Int32& slots, Int32& usedNamespaces);
    internal void ReadMD2CustomMetadata(BitAccess bits);
    private void ReadCustomMetadata(BitAccess bits);
    private void ReadForwardIterator(BitAccess bits);
    private void ReadIteratorLocals(BitAccess bits);
    private void ReadForwardInfo(BitAccess bits);
    private void ReadUsingInfo(BitAccess bits);
}
internal class Microsoft.Cci.Pdb.PdbInfo : object {
    
public PdbFunction[] Functions;
    
public Dictionary`2<UInt32, PdbTokenLine> TokenToSourceMapping;
    
public string SourceServerData;
    
public int Age;
    
public Guid Guid;
    
public Byte[] SourceLinkData;
}
internal class Microsoft.Cci.Pdb.PdbIteratorScope : object {
    
private UInt32 offset;
    
private UInt32 length;
    
public UInt32 Offset { get; }
    
public UInt32 Length { get; }
    internal PdbIteratorScope(UInt32 offset, UInt32 length);
    public sealed virtual UInt32 get_Offset();
    public sealed virtual UInt32 get_Length();
}
internal class Microsoft.Cci.Pdb.PdbLine : ValueType {
    
internal UInt32 offset;
    
internal UInt32 lineBegin;
    
internal UInt32 lineEnd;
    
internal ushort colBegin;
    
internal ushort colEnd;
    internal PdbLine(UInt32 offset, UInt32 lineBegin, ushort colBegin, UInt32 lineEnd, ushort colEnd);
}
internal class Microsoft.Cci.Pdb.PdbLines : object {
    
internal PdbSource file;
    
internal PdbLine[] lines;
    internal PdbLines(PdbSource file, UInt32 count);
}
internal class Microsoft.Cci.Pdb.PdbReader : object {
    
internal int pageSize;
    
internal Stream reader;
    internal PdbReader(Stream reader, int pageSize);
    internal void Seek(int page, int offset);
    internal void Read(Byte[] bytes, int offset, int count);
    internal int PagesFromSize(int size);
}
internal class Microsoft.Cci.Pdb.PdbScope : object {
    
internal PdbConstant[] constants;
    
internal PdbSlot[] slots;
    
internal PdbScope[] scopes;
    
internal String[] usedNamespaces;
    
internal UInt32 address;
    
internal UInt32 offset;
    
internal UInt32 length;
    internal PdbScope(UInt32 address, UInt32 offset, UInt32 length, PdbSlot[] slots, PdbConstant[] constants, String[] usedNamespaces);
    internal PdbScope(UInt32 address, UInt32 length, PdbSlot[] slots, PdbConstant[] constants, String[] usedNamespaces);
    internal PdbScope(UInt32 funcOffset, BlockSym32 block, BitAccess bits, UInt32& typind);
}
internal class Microsoft.Cci.Pdb.PdbSlot : object {
    
internal UInt32 slot;
    
internal UInt32 typeToken;
    
internal string name;
    
internal ushort flags;
    internal PdbSlot(UInt32 slot, UInt32 typeToken, string name, ushort flags);
    internal PdbSlot(BitAccess bits);
}
internal class Microsoft.Cci.Pdb.PdbSource : object {
    
internal string name;
    
internal Guid doctype;
    
internal Guid language;
    
internal Guid vendor;
    
internal Guid checksumAlgorithm;
    
internal Byte[] checksum;
    internal PdbSource(string name, Guid doctype, Guid language, Guid vendor, Guid checksumAlgorithm, Byte[] checksum);
}
internal class Microsoft.Cci.Pdb.PdbSynchronizationInformation : object {
    
internal UInt32 kickoffMethodToken;
    
internal UInt32 generatedCatchHandlerIlOffset;
    
internal PdbSynchronizationPoint[] synchronizationPoints;
    
public UInt32 GeneratedCatchHandlerOffset { get; }
    internal PdbSynchronizationInformation(BitAccess bits);
    public UInt32 get_GeneratedCatchHandlerOffset();
}
internal class Microsoft.Cci.Pdb.PdbSynchronizationPoint : object {
    
internal UInt32 synchronizeOffset;
    
internal UInt32 continuationMethodToken;
    
internal UInt32 continuationOffset;
    
public UInt32 SynchronizeOffset { get; }
    
public UInt32 ContinuationOffset { get; }
    internal PdbSynchronizationPoint(BitAccess bits);
    public UInt32 get_SynchronizeOffset();
    public UInt32 get_ContinuationOffset();
}
internal class Microsoft.Cci.Pdb.PdbTokenLine : object {
    
internal UInt32 token;
    
internal UInt32 file_id;
    
internal UInt32 line;
    
internal UInt32 column;
    
internal UInt32 endLine;
    
internal UInt32 endColumn;
    
internal PdbSource sourceFile;
    
internal PdbTokenLine nextLine;
    internal PdbTokenLine(UInt32 token, UInt32 file_id, UInt32 line, UInt32 column, UInt32 endLine, UInt32 endColumn);
}
internal class Microsoft.Cci.Pdb.ProcSym32 : ValueType {
    
internal UInt32 parent;
    
internal UInt32 end;
    
internal UInt32 next;
    
internal UInt32 len;
    
internal UInt32 dbgStart;
    
internal UInt32 dbgEnd;
    
internal UInt32 typind;
    
internal UInt32 off;
    
internal ushort seg;
    
internal byte flags;
    
internal string name;
}
internal class Microsoft.Cci.Pdb.ProcSymIa64 : ValueType {
    
internal UInt32 parent;
    
internal UInt32 end;
    
internal UInt32 next;
    
internal UInt32 len;
    
internal UInt32 dbgStart;
    
internal UInt32 dbgEnd;
    
internal UInt32 typind;
    
internal UInt32 off;
    
internal ushort seg;
    
internal ushort retReg;
    
internal byte flags;
    
internal string name;
}
internal class Microsoft.Cci.Pdb.ProcSymMips : ValueType {
    
internal UInt32 parent;
    
internal UInt32 end;
    
internal UInt32 next;
    
internal UInt32 len;
    
internal UInt32 dbgStart;
    
internal UInt32 dbgEnd;
    
internal UInt32 regSave;
    
internal UInt32 fpSave;
    
internal UInt32 intOff;
    
internal UInt32 fpOff;
    
internal UInt32 typind;
    
internal UInt32 off;
    
internal ushort seg;
    
internal byte retReg;
    
internal byte frameReg;
    
internal string name;
}
internal class Microsoft.Cci.Pdb.PubSym32 : ValueType {
    
internal UInt32 flags;
    
internal UInt32 off;
    
internal ushort seg;
    
internal string name;
}
internal class Microsoft.Cci.Pdb.RefSym : ValueType {
    
internal UInt32 sumName;
    
internal UInt32 ibSym;
    
internal ushort imod;
    
internal ushort usFill;
}
internal class Microsoft.Cci.Pdb.RefSym2 : ValueType {
    
internal UInt32 sumName;
    
internal UInt32 ibSym;
    
internal ushort imod;
    
internal string name;
}
internal class Microsoft.Cci.Pdb.RegRel32 : ValueType {
    
internal UInt32 off;
    
internal UInt32 typind;
    
internal ushort reg;
    
internal string name;
}
internal class Microsoft.Cci.Pdb.RegSym : ValueType {
    
internal UInt32 typind;
    
internal ushort reg;
    
internal string name;
}
internal class Microsoft.Cci.Pdb.ReturnSym : ValueType {
    
internal CV_GENERIC_FLAG flags;
    
internal byte style;
}
internal class Microsoft.Cci.Pdb.SearchSym : ValueType {
    
internal UInt32 startsym;
    
internal ushort seg;
}
internal class Microsoft.Cci.Pdb.SectionSym : ValueType {
    
internal ushort isec;
    
internal byte align;
    
internal byte bReserved;
    
internal UInt32 rva;
    
internal UInt32 cb;
    
internal UInt32 characteristics;
    
internal string name;
}
internal class Microsoft.Cci.Pdb.SepCodSym : ValueType {
    
internal UInt32 parent;
    
internal UInt32 end;
    
internal UInt32 length;
    
internal UInt32 scf;
    
internal UInt32 off;
    
internal UInt32 offParent;
    
internal ushort sec;
    
internal ushort secParent;
}
internal class Microsoft.Cci.Pdb.Slink32 : ValueType {
    
internal UInt32 framesize;
    
internal int off;
    
internal ushort reg;
}
internal class Microsoft.Cci.Pdb.SlotSym32 : ValueType {
    
internal UInt32 index;
    
internal UInt32 typind;
    
internal string name;
}
internal enum Microsoft.Cci.Pdb.SYM : Enum {
    
public int value__;
    
public static SYM S_END;
    
public static SYM S_OEM;
    
public static SYM S_REGISTER_ST;
    
public static SYM S_CONSTANT_ST;
    
public static SYM S_UDT_ST;
    
public static SYM S_COBOLUDT_ST;
    
public static SYM S_MANYREG_ST;
    
public static SYM S_BPREL32_ST;
    
public static SYM S_LDATA32_ST;
    
public static SYM S_GDATA32_ST;
    
public static SYM S_PUB32_ST;
    
public static SYM S_LPROC32_ST;
    
public static SYM S_GPROC32_ST;
    
public static SYM S_VFTABLE32;
    
public static SYM S_REGREL32_ST;
    
public static SYM S_LTHREAD32_ST;
    
public static SYM S_GTHREAD32_ST;
    
public static SYM S_LPROCMIPS_ST;
    
public static SYM S_GPROCMIPS_ST;
    
public static SYM S_FRAMEPROC;
    
public static SYM S_COMPILE2_ST;
    
public static SYM S_MANYREG2_ST;
    
public static SYM S_LPROCIA64_ST;
    
public static SYM S_GPROCIA64_ST;
    
public static SYM S_LOCALSLOT_ST;
    
public static SYM S_PARAMSLOT_ST;
    
public static SYM S_ANNOTATION;
    
public static SYM S_GMANPROC_ST;
    
public static SYM S_LMANPROC_ST;
    
public static SYM S_RESERVED1;
    
public static SYM S_RESERVED2;
    
public static SYM S_RESERVED3;
    
public static SYM S_RESERVED4;
    
public static SYM S_LMANDATA_ST;
    
public static SYM S_GMANDATA_ST;
    
public static SYM S_MANFRAMEREL_ST;
    
public static SYM S_MANREGISTER_ST;
    
public static SYM S_MANSLOT_ST;
    
public static SYM S_MANMANYREG_ST;
    
public static SYM S_MANREGREL_ST;
    
public static SYM S_MANMANYREG2_ST;
    
public static SYM S_MANTYPREF;
    
public static SYM S_UNAMESPACE_ST;
    
public static SYM S_ST_MAX;
    
public static SYM S_OBJNAME;
    
public static SYM S_THUNK32;
    
public static SYM S_BLOCK32;
    
public static SYM S_WITH32;
    
public static SYM S_LABEL32;
    
public static SYM S_REGISTER;
    
public static SYM S_CONSTANT;
    
public static SYM S_UDT;
    
public static SYM S_COBOLUDT;
    
public static SYM S_MANYREG;
    
public static SYM S_BPREL32;
    
public static SYM S_LDATA32;
    
public static SYM S_GDATA32;
    
public static SYM S_PUB32;
    
public static SYM S_LPROC32;
    
public static SYM S_GPROC32;
    
public static SYM S_REGREL32;
    
public static SYM S_LTHREAD32;
    
public static SYM S_GTHREAD32;
    
public static SYM S_LPROCMIPS;
    
public static SYM S_GPROCMIPS;
    
public static SYM S_COMPILE2;
    
public static SYM S_MANYREG2;
    
public static SYM S_LPROCIA64;
    
public static SYM S_GPROCIA64;
    
public static SYM S_LOCALSLOT;
    
public static SYM S_SLOT;
    
public static SYM S_PARAMSLOT;
    
public static SYM S_LMANDATA;
    
public static SYM S_GMANDATA;
    
public static SYM S_MANFRAMEREL;
    
public static SYM S_MANREGISTER;
    
public static SYM S_MANSLOT;
    
public static SYM S_MANMANYREG;
    
public static SYM S_MANREGREL;
    
public static SYM S_MANMANYREG2;
    
public static SYM S_UNAMESPACE;
    
public static SYM S_PROCREF;
    
public static SYM S_DATAREF;
    
public static SYM S_LPROCREF;
    
public static SYM S_ANNOTATIONREF;
    
public static SYM S_TOKENREF;
    
public static SYM S_GMANPROC;
    
public static SYM S_LMANPROC;
    
public static SYM S_TRAMPOLINE;
    
public static SYM S_MANCONSTANT;
    
public static SYM S_ATTR_FRAMEREL;
    
public static SYM S_ATTR_REGISTER;
    
public static SYM S_ATTR_REGREL;
    
public static SYM S_ATTR_MANYREG;
    
public static SYM S_SEPCODE;
    
public static SYM S_LOCAL;
    
public static SYM S_DEFRANGE;
    
public static SYM S_DEFRANGE2;
    
public static SYM S_SECTION;
    
public static SYM S_COFFGROUP;
    
public static SYM S_EXPORT;
    
public static SYM S_CALLSITEINFO;
    
public static SYM S_FRAMECOOKIE;
    
public static SYM S_DISCARDED;
    
public static SYM S_RECTYPE_MAX;
    
public static SYM S_RECTYPE_LAST;
}
internal class Microsoft.Cci.Pdb.SYMTYPE : ValueType {
    
internal ushort reclen;
    
internal ushort rectyp;
}
internal class Microsoft.Cci.Pdb.ThreadSym32 : ValueType {
    
internal UInt32 typind;
    
internal UInt32 off;
    
internal ushort seg;
    
internal string name;
}
internal class Microsoft.Cci.Pdb.ThunkSym32 : ValueType {
    
internal UInt32 parent;
    
internal UInt32 end;
    
internal UInt32 next;
    
internal UInt32 off;
    
internal ushort seg;
    
internal ushort len;
    
internal byte ord;
    
internal string name;
    
internal Byte[] variant;
}
internal enum Microsoft.Cci.Pdb.TRAMP : Enum {
    
public int value__;
    
public static TRAMP trampIncremental;
    
public static TRAMP trampBranchIsland;
}
internal class Microsoft.Cci.Pdb.TrampolineSym : ValueType {
    
internal ushort trampType;
    
internal ushort cbThunk;
    
internal UInt32 offThunk;
    
internal UInt32 offTarget;
    
internal ushort sectThunk;
    
internal ushort sectTarget;
}
internal enum Microsoft.Cci.Pdb.TYPE_ENUM : Enum {
    
public int value__;
    
public static TYPE_ENUM T_NOTYPE;
    
public static TYPE_ENUM T_ABS;
    
public static TYPE_ENUM T_SEGMENT;
    
public static TYPE_ENUM T_VOID;
    
public static TYPE_ENUM T_HRESULT;
    
public static TYPE_ENUM T_32PHRESULT;
    
public static TYPE_ENUM T_64PHRESULT;
    
public static TYPE_ENUM T_PVOID;
    
public static TYPE_ENUM T_PFVOID;
    
public static TYPE_ENUM T_PHVOID;
    
public static TYPE_ENUM T_32PVOID;
    
public static TYPE_ENUM T_64PVOID;
    
public static TYPE_ENUM T_CURRENCY;
    
public static TYPE_ENUM T_NOTTRANS;
    
public static TYPE_ENUM T_BIT;
    
public static TYPE_ENUM T_PASCHAR;
    
public static TYPE_ENUM T_CHAR;
    
public static TYPE_ENUM T_32PCHAR;
    
public static TYPE_ENUM T_64PCHAR;
    
public static TYPE_ENUM T_UCHAR;
    
public static TYPE_ENUM T_32PUCHAR;
    
public static TYPE_ENUM T_64PUCHAR;
    
public static TYPE_ENUM T_RCHAR;
    
public static TYPE_ENUM T_32PRCHAR;
    
public static TYPE_ENUM T_64PRCHAR;
    
public static TYPE_ENUM T_WCHAR;
    
public static TYPE_ENUM T_32PWCHAR;
    
public static TYPE_ENUM T_64PWCHAR;
    
public static TYPE_ENUM T_INT1;
    
public static TYPE_ENUM T_32PINT1;
    
public static TYPE_ENUM T_64PINT1;
    
public static TYPE_ENUM T_UINT1;
    
public static TYPE_ENUM T_32PUINT1;
    
public static TYPE_ENUM T_64PUINT1;
    
public static TYPE_ENUM T_SHORT;
    
public static TYPE_ENUM T_32PSHORT;
    
public static TYPE_ENUM T_64PSHORT;
    
public static TYPE_ENUM T_USHORT;
    
public static TYPE_ENUM T_32PUSHORT;
    
public static TYPE_ENUM T_64PUSHORT;
    
public static TYPE_ENUM T_INT2;
    
public static TYPE_ENUM T_32PINT2;
    
public static TYPE_ENUM T_64PINT2;
    
public static TYPE_ENUM T_UINT2;
    
public static TYPE_ENUM T_32PUINT2;
    
public static TYPE_ENUM T_64PUINT2;
    
public static TYPE_ENUM T_LONG;
    
public static TYPE_ENUM T_ULONG;
    
public static TYPE_ENUM T_32PLONG;
    
public static TYPE_ENUM T_32PULONG;
    
public static TYPE_ENUM T_64PLONG;
    
public static TYPE_ENUM T_64PULONG;
    
public static TYPE_ENUM T_INT4;
    
public static TYPE_ENUM T_32PINT4;
    
public static TYPE_ENUM T_64PINT4;
    
public static TYPE_ENUM T_UINT4;
    
public static TYPE_ENUM T_32PUINT4;
    
public static TYPE_ENUM T_64PUINT4;
    
public static TYPE_ENUM T_QUAD;
    
public static TYPE_ENUM T_32PQUAD;
    
public static TYPE_ENUM T_64PQUAD;
    
public static TYPE_ENUM T_UQUAD;
    
public static TYPE_ENUM T_32PUQUAD;
    
public static TYPE_ENUM T_64PUQUAD;
    
public static TYPE_ENUM T_INT8;
    
public static TYPE_ENUM T_32PINT8;
    
public static TYPE_ENUM T_64PINT8;
    
public static TYPE_ENUM T_UINT8;
    
public static TYPE_ENUM T_32PUINT8;
    
public static TYPE_ENUM T_64PUINT8;
    
public static TYPE_ENUM T_OCT;
    
public static TYPE_ENUM T_32POCT;
    
public static TYPE_ENUM T_64POCT;
    
public static TYPE_ENUM T_UOCT;
    
public static TYPE_ENUM T_32PUOCT;
    
public static TYPE_ENUM T_64PUOCT;
    
public static TYPE_ENUM T_INT16;
    
public static TYPE_ENUM T_32PINT16;
    
public static TYPE_ENUM T_64PINT16;
    
public static TYPE_ENUM T_UINT16;
    
public static TYPE_ENUM T_32PUINT16;
    
public static TYPE_ENUM T_64PUINT16;
    
public static TYPE_ENUM T_REAL32;
    
public static TYPE_ENUM T_32PREAL32;
    
public static TYPE_ENUM T_64PREAL32;
    
public static TYPE_ENUM T_REAL64;
    
public static TYPE_ENUM T_32PREAL64;
    
public static TYPE_ENUM T_64PREAL64;
    
public static TYPE_ENUM T_REAL80;
    
public static TYPE_ENUM T_32PREAL80;
    
public static TYPE_ENUM T_64PREAL80;
    
public static TYPE_ENUM T_REAL128;
    
public static TYPE_ENUM T_32PREAL128;
    
public static TYPE_ENUM T_64PREAL128;
    
public static TYPE_ENUM T_CPLX32;
    
public static TYPE_ENUM T_32PCPLX32;
    
public static TYPE_ENUM T_64PCPLX32;
    
public static TYPE_ENUM T_CPLX64;
    
public static TYPE_ENUM T_32PCPLX64;
    
public static TYPE_ENUM T_64PCPLX64;
    
public static TYPE_ENUM T_CPLX80;
    
public static TYPE_ENUM T_32PCPLX80;
    
public static TYPE_ENUM T_64PCPLX80;
    
public static TYPE_ENUM T_CPLX128;
    
public static TYPE_ENUM T_32PCPLX128;
    
public static TYPE_ENUM T_64PCPLX128;
    
public static TYPE_ENUM T_BOOL08;
    
public static TYPE_ENUM T_32PBOOL08;
    
public static TYPE_ENUM T_64PBOOL08;
    
public static TYPE_ENUM T_BOOL16;
    
public static TYPE_ENUM T_32PBOOL16;
    
public static TYPE_ENUM T_64PBOOL16;
    
public static TYPE_ENUM T_BOOL32;
    
public static TYPE_ENUM T_32PBOOL32;
    
public static TYPE_ENUM T_64PBOOL32;
    
public static TYPE_ENUM T_BOOL64;
    
public static TYPE_ENUM T_32PBOOL64;
    
public static TYPE_ENUM T_64PBOOL64;
}
internal class Microsoft.Cci.Pdb.TYPTYPE : ValueType {
    
internal ushort len;
    
internal ushort leaf;
}
internal class Microsoft.Cci.Pdb.UdtSym : ValueType {
    
internal UInt32 typind;
    
internal string name;
}
internal class Microsoft.Cci.Pdb.UnamespaceSym : ValueType {
    
internal string name;
}
internal class Microsoft.Cci.Pdb.VpathSym32 : ValueType {
    
internal UInt32 root;
    
internal UInt32 path;
    
internal UInt32 off;
    
internal ushort seg;
}
internal class Microsoft.Cci.Pdb.WithSym32 : ValueType {
    
internal UInt32 parent;
    
internal UInt32 end;
    
internal UInt32 len;
    
internal UInt32 off;
    
internal ushort seg;
    
internal string expr;
}
internal class Microsoft.Cci.Pdb.XFixupData : ValueType {
    
internal ushort wType;
    
internal ushort wExtra;
    
internal UInt32 rva;
    
internal UInt32 rvaTarget;
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
internal class Mono.ArgumentNullOrEmptyException : ArgumentException {
    public ArgumentNullOrEmptyException(string paramName);
}
internal class Mono.Cecil.ArrayDimension : ValueType {
    
private Nullable`1<int> lower_bound;
    
private Nullable`1<int> upper_bound;
    
public Nullable`1<int> LowerBound { get; public set; }
    
public Nullable`1<int> UpperBound { get; public set; }
    
public bool IsSized { get; }
    public ArrayDimension(Nullable`1<int> lowerBound, Nullable`1<int> upperBound);
    public Nullable`1<int> get_LowerBound();
    public void set_LowerBound(Nullable`1<int> value);
    public Nullable`1<int> get_UpperBound();
    public void set_UpperBound(Nullable`1<int> value);
    public bool get_IsSized();
    public virtual string ToString();
}
internal class Mono.Cecil.ArrayMarshalInfo : MarshalInfo {
    
internal NativeType element_type;
    
internal int size_parameter_index;
    
internal int size;
    
internal int size_parameter_multiplier;
    
public NativeType ElementType { get; public set; }
    
public int SizeParameterIndex { get; public set; }
    
public int Size { get; public set; }
    
public int SizeParameterMultiplier { get; public set; }
    public NativeType get_ElementType();
    public void set_ElementType(NativeType value);
    public int get_SizeParameterIndex();
    public void set_SizeParameterIndex(int value);
    public int get_Size();
    public void set_Size(int value);
    public int get_SizeParameterMultiplier();
    public void set_SizeParameterMultiplier(int value);
}
internal class Mono.Cecil.ArrayType : TypeSpecification {
    
private Collection`1<ArrayDimension> dimensions;
    
public Collection`1<ArrayDimension> Dimensions { get; }
    
public int Rank { get; }
    
public bool IsVector { get; }
    
public bool IsValueType { get; public set; }
    
public string Name { get; }
    
public string FullName { get; }
    
private string Suffix { get; }
    
public bool IsArray { get; }
    public ArrayType(TypeReference type);
    public ArrayType(TypeReference type, int rank);
    public Collection`1<ArrayDimension> get_Dimensions();
    public int get_Rank();
    public bool get_IsVector();
    public virtual bool get_IsValueType();
    public virtual void set_IsValueType(bool value);
    public virtual string get_Name();
    public virtual string get_FullName();
    private string get_Suffix();
    public virtual bool get_IsArray();
}
[FlagsAttribute]
internal enum Mono.Cecil.AssemblyAttributes : Enum {
    
public UInt32 value__;
    
public static AssemblyAttributes PublicKey;
    
public static AssemblyAttributes SideBySideCompatible;
    
public static AssemblyAttributes Retargetable;
    
public static AssemblyAttributes WindowsRuntime;
    
public static AssemblyAttributes DisableJITCompileOptimizer;
    
public static AssemblyAttributes EnableJITCompileTracking;
}
internal class Mono.Cecil.AssemblyDefinition : object {
    
private AssemblyNameDefinition name;
    
internal ModuleDefinition main_module;
    
private Collection`1<ModuleDefinition> modules;
    
private Collection`1<CustomAttribute> custom_attributes;
    
private Collection`1<SecurityDeclaration> security_declarations;
    
public AssemblyNameDefinition Name { get; public set; }
    
public string FullName { get; }
    
public MetadataToken MetadataToken { get; public set; }
    
public Collection`1<ModuleDefinition> Modules { get; }
    
public ModuleDefinition MainModule { get; }
    
public MethodDefinition EntryPoint { get; public set; }
    
public bool HasCustomAttributes { get; }
    
public Collection`1<CustomAttribute> CustomAttributes { get; }
    
public bool HasSecurityDeclarations { get; }
    
public Collection`1<SecurityDeclaration> SecurityDeclarations { get; }
    public AssemblyNameDefinition get_Name();
    public void set_Name(AssemblyNameDefinition value);
    public string get_FullName();
    public sealed virtual MetadataToken get_MetadataToken();
    public sealed virtual void set_MetadataToken(MetadataToken value);
    public Collection`1<ModuleDefinition> get_Modules();
    public ModuleDefinition get_MainModule();
    public MethodDefinition get_EntryPoint();
    public void set_EntryPoint(MethodDefinition value);
    public sealed virtual bool get_HasCustomAttributes();
    public sealed virtual Collection`1<CustomAttribute> get_CustomAttributes();
    public sealed virtual bool get_HasSecurityDeclarations();
    public sealed virtual Collection`1<SecurityDeclaration> get_SecurityDeclarations();
    public sealed virtual void Dispose();
    public static AssemblyDefinition CreateAssembly(AssemblyNameDefinition assemblyName, string moduleName, ModuleKind kind);
    public static AssemblyDefinition CreateAssembly(AssemblyNameDefinition assemblyName, string moduleName, ModuleParameters parameters);
    public static AssemblyDefinition ReadAssembly(string fileName);
    public static AssemblyDefinition ReadAssembly(string fileName, ReaderParameters parameters);
    public static AssemblyDefinition ReadAssembly(Stream stream);
    public static AssemblyDefinition ReadAssembly(Stream stream, ReaderParameters parameters);
    private static AssemblyDefinition ReadAssembly(ModuleDefinition module);
    public void Write(string fileName);
    public void Write(string fileName, WriterParameters parameters);
    public void Write();
    public void Write(WriterParameters parameters);
    public void Write(Stream stream);
    public void Write(Stream stream, WriterParameters parameters);
    public virtual string ToString();
}
internal enum Mono.Cecil.AssemblyHashAlgorithm : Enum {
    
public UInt32 value__;
    
public static AssemblyHashAlgorithm None;
    
public static AssemblyHashAlgorithm MD5;
    
public static AssemblyHashAlgorithm SHA1;
    
public static AssemblyHashAlgorithm SHA256;
    
public static AssemblyHashAlgorithm SHA384;
    
public static AssemblyHashAlgorithm SHA512;
    
public static AssemblyHashAlgorithm Reserved;
}
internal class Mono.Cecil.AssemblyLinkedResource : Resource {
    
private AssemblyNameReference reference;
    
public AssemblyNameReference Assembly { get; public set; }
    
public ResourceType ResourceType { get; }
    public AssemblyLinkedResource(string name, ManifestResourceAttributes flags);
    public AssemblyLinkedResource(string name, ManifestResourceAttributes flags, AssemblyNameReference reference);
    public AssemblyNameReference get_Assembly();
    public void set_Assembly(AssemblyNameReference value);
    public virtual ResourceType get_ResourceType();
}
internal class Mono.Cecil.AssemblyNameDefinition : AssemblyNameReference {
    
public Byte[] Hash { get; }
    public AssemblyNameDefinition(string name, Version version);
    public virtual Byte[] get_Hash();
}
internal class Mono.Cecil.AssemblyNameReference : object {
    
private string name;
    
private string culture;
    
private Version version;
    
private UInt32 attributes;
    
private Byte[] public_key;
    
private Byte[] public_key_token;
    
private AssemblyHashAlgorithm hash_algorithm;
    
private Byte[] hash;
    
internal MetadataToken token;
    
private string full_name;
    
public string Name { get; public set; }
    
public string Culture { get; public set; }
    
public Version Version { get; public set; }
    
public AssemblyAttributes Attributes { get; public set; }
    
public bool HasPublicKey { get; public set; }
    
public bool IsSideBySideCompatible { get; public set; }
    
public bool IsRetargetable { get; public set; }
    
public bool IsWindowsRuntime { get; public set; }
    
public Byte[] PublicKey { get; public set; }
    
public Byte[] PublicKeyToken { get; public set; }
    
public MetadataScopeType MetadataScopeType { get; }
    
public string FullName { get; }
    
public AssemblyHashAlgorithm HashAlgorithm { get; public set; }
    
public Byte[] Hash { get; public set; }
    
public MetadataToken MetadataToken { get; public set; }
    public AssemblyNameReference(string name, Version version);
    public sealed virtual string get_Name();
    public sealed virtual void set_Name(string value);
    public string get_Culture();
    public void set_Culture(string value);
    public Version get_Version();
    public void set_Version(Version value);
    public AssemblyAttributes get_Attributes();
    public void set_Attributes(AssemblyAttributes value);
    public bool get_HasPublicKey();
    public void set_HasPublicKey(bool value);
    public bool get_IsSideBySideCompatible();
    public void set_IsSideBySideCompatible(bool value);
    public bool get_IsRetargetable();
    public void set_IsRetargetable(bool value);
    public bool get_IsWindowsRuntime();
    public void set_IsWindowsRuntime(bool value);
    public Byte[] get_PublicKey();
    public void set_PublicKey(Byte[] value);
    public Byte[] get_PublicKeyToken();
    public void set_PublicKeyToken(Byte[] value);
    private Byte[] HashPublicKey();
    public virtual MetadataScopeType get_MetadataScopeType();
    public string get_FullName();
    public static AssemblyNameReference Parse(string fullName);
    public AssemblyHashAlgorithm get_HashAlgorithm();
    public void set_HashAlgorithm(AssemblyHashAlgorithm value);
    public virtual Byte[] get_Hash();
    public virtual void set_Hash(Byte[] value);
    public sealed virtual MetadataToken get_MetadataToken();
    public sealed virtual void set_MetadataToken(MetadataToken value);
    public virtual string ToString();
}
internal class Mono.Cecil.AssemblyRefTable : MetadataTable`1<Row`9<ushort, ushort, ushort, ushort, AssemblyAttributes, UInt32, UInt32, UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
}
internal class Mono.Cecil.AssemblyResolutionException : FileNotFoundException {
    
private AssemblyNameReference reference;
    
public AssemblyNameReference AssemblyReference { get; }
    public AssemblyResolutionException(AssemblyNameReference reference);
    public AssemblyResolutionException(AssemblyNameReference reference, Exception innerException);
    private AssemblyResolutionException(SerializationInfo info, StreamingContext context);
    public AssemblyNameReference get_AssemblyReference();
}
internal class Mono.Cecil.AssemblyResolveEventArgs : EventArgs {
    
private AssemblyNameReference reference;
    
public AssemblyNameReference AssemblyReference { get; }
    public AssemblyResolveEventArgs(AssemblyNameReference reference);
    public AssemblyNameReference get_AssemblyReference();
}
internal class Mono.Cecil.AssemblyResolveEventHandler : MulticastDelegate {
    public AssemblyResolveEventHandler(object object, IntPtr method);
    public virtual AssemblyDefinition Invoke(object sender, AssemblyNameReference reference);
    public virtual IAsyncResult BeginInvoke(object sender, AssemblyNameReference reference, AsyncCallback callback, object object);
    public virtual AssemblyDefinition EndInvoke(IAsyncResult result);
}
internal class Mono.Cecil.AssemblyTable : OneRowTable`1<Row`9<AssemblyHashAlgorithm, ushort, ushort, ushort, ushort, AssemblyAttributes, UInt32, UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
}
internal abstract class Mono.Cecil.BaseAssemblyResolver : object {
    
private static bool on_mono;
    
private Collection`1<string> directories;
    
private Collection`1<string> gac_paths;
    [CompilerGeneratedAttribute]

private AssemblyResolveEventHandler ResolveFailure;
    private static BaseAssemblyResolver();
    public void AddSearchDirectory(string directory);
    public void RemoveSearchDirectory(string directory);
    public String[] GetSearchDirectories();
    [CompilerGeneratedAttribute]
public void add_ResolveFailure(AssemblyResolveEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_ResolveFailure(AssemblyResolveEventHandler value);
    private AssemblyDefinition GetAssembly(string file, ReaderParameters parameters);
    public virtual AssemblyDefinition Resolve(AssemblyNameReference name);
    public virtual AssemblyDefinition Resolve(AssemblyNameReference name, ReaderParameters parameters);
    protected virtual AssemblyDefinition SearchDirectory(AssemblyNameReference name, IEnumerable`1<string> directories, ReaderParameters parameters);
    private static bool IsZero(Version version);
    private AssemblyDefinition GetCorlib(AssemblyNameReference reference, ReaderParameters parameters);
    private static Collection`1<string> GetGacPaths();
    private static Collection`1<string> GetDefaultMonoGacPaths();
    private static string GetCurrentMonoGac();
    private AssemblyDefinition GetAssemblyInGac(AssemblyNameReference reference, ReaderParameters parameters);
    private AssemblyDefinition GetAssemblyInMonoGac(AssemblyNameReference reference, ReaderParameters parameters);
    private AssemblyDefinition GetAssemblyInNetGac(AssemblyNameReference reference, ReaderParameters parameters);
    private static string GetAssemblyFile(AssemblyNameReference reference, string prefix, string gac);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
internal class Mono.Cecil.ByReferenceType : TypeSpecification {
    
public string Name { get; }
    
public string FullName { get; }
    
public bool IsValueType { get; public set; }
    
public bool IsByReference { get; }
    public ByReferenceType(TypeReference type);
    public virtual string get_Name();
    public virtual string get_FullName();
    public virtual bool get_IsValueType();
    public virtual void set_IsValueType(bool value);
    public virtual bool get_IsByReference();
}
internal class Mono.Cecil.CallSite : object {
    
private MethodReference signature;
    
public bool HasThis { get; public set; }
    
public bool ExplicitThis { get; public set; }
    
public MethodCallingConvention CallingConvention { get; public set; }
    
public bool HasParameters { get; }
    
public Collection`1<ParameterDefinition> Parameters { get; }
    
public TypeReference ReturnType { get; public set; }
    
public MethodReturnType MethodReturnType { get; }
    
public string Name { get; public set; }
    
public string Namespace { get; public set; }
    
public ModuleDefinition Module { get; }
    
public IMetadataScope Scope { get; }
    
public MetadataToken MetadataToken { get; public set; }
    
public string FullName { get; }
    public CallSite(TypeReference returnType);
    public sealed virtual bool get_HasThis();
    public sealed virtual void set_HasThis(bool value);
    public sealed virtual bool get_ExplicitThis();
    public sealed virtual void set_ExplicitThis(bool value);
    public sealed virtual MethodCallingConvention get_CallingConvention();
    public sealed virtual void set_CallingConvention(MethodCallingConvention value);
    public sealed virtual bool get_HasParameters();
    public sealed virtual Collection`1<ParameterDefinition> get_Parameters();
    public sealed virtual TypeReference get_ReturnType();
    public sealed virtual void set_ReturnType(TypeReference value);
    public sealed virtual MethodReturnType get_MethodReturnType();
    public string get_Name();
    public void set_Name(string value);
    public string get_Namespace();
    public void set_Namespace(string value);
    public ModuleDefinition get_Module();
    public IMetadataScope get_Scope();
    public sealed virtual MetadataToken get_MetadataToken();
    public sealed virtual void set_MetadataToken(MetadataToken value);
    public string get_FullName();
    public virtual string ToString();
}
internal class Mono.Cecil.Cil.AsyncMethodBodyDebugInformation : CustomDebugInformation {
    
internal InstructionOffset catch_handler;
    
internal Collection`1<InstructionOffset> yields;
    
internal Collection`1<InstructionOffset> resumes;
    
internal Collection`1<MethodDefinition> resume_methods;
    
public static Guid KindIdentifier;
    
public InstructionOffset CatchHandler { get; public set; }
    
public Collection`1<InstructionOffset> Yields { get; }
    
public Collection`1<InstructionOffset> Resumes { get; }
    
public Collection`1<MethodDefinition> ResumeMethods { get; }
    
public CustomDebugInformationKind Kind { get; }
    internal AsyncMethodBodyDebugInformation(int catchHandler);
    public AsyncMethodBodyDebugInformation(Instruction catchHandler);
    private static AsyncMethodBodyDebugInformation();
    public InstructionOffset get_CatchHandler();
    public void set_CatchHandler(InstructionOffset value);
    public Collection`1<InstructionOffset> get_Yields();
    public Collection`1<InstructionOffset> get_Resumes();
    public Collection`1<MethodDefinition> get_ResumeMethods();
    public virtual CustomDebugInformationKind get_Kind();
}
internal class Mono.Cecil.Cil.BinaryCustomDebugInformation : CustomDebugInformation {
    
private Byte[] data;
    
public Byte[] Data { get; public set; }
    
public CustomDebugInformationKind Kind { get; }
    public BinaryCustomDebugInformation(Guid identifier, Byte[] data);
    public Byte[] get_Data();
    public void set_Data(Byte[] value);
    public virtual CustomDebugInformationKind get_Kind();
}
internal enum Mono.Cecil.Cil.Code : Enum {
    
public int value__;
    
public static Code Nop;
    
public static Code Break;
    
public static Code Ldarg_0;
    
public static Code Ldarg_1;
    
public static Code Ldarg_2;
    
public static Code Ldarg_3;
    
public static Code Ldloc_0;
    
public static Code Ldloc_1;
    
public static Code Ldloc_2;
    
public static Code Ldloc_3;
    
public static Code Stloc_0;
    
public static Code Stloc_1;
    
public static Code Stloc_2;
    
public static Code Stloc_3;
    
public static Code Ldarg_S;
    
public static Code Ldarga_S;
    
public static Code Starg_S;
    
public static Code Ldloc_S;
    
public static Code Ldloca_S;
    
public static Code Stloc_S;
    
public static Code Ldnull;
    
public static Code Ldc_I4_M1;
    
public static Code Ldc_I4_0;
    
public static Code Ldc_I4_1;
    
public static Code Ldc_I4_2;
    
public static Code Ldc_I4_3;
    
public static Code Ldc_I4_4;
    
public static Code Ldc_I4_5;
    
public static Code Ldc_I4_6;
    
public static Code Ldc_I4_7;
    
public static Code Ldc_I4_8;
    
public static Code Ldc_I4_S;
    
public static Code Ldc_I4;
    
public static Code Ldc_I8;
    
public static Code Ldc_R4;
    
public static Code Ldc_R8;
    
public static Code Dup;
    
public static Code Pop;
    
public static Code Jmp;
    
public static Code Call;
    
public static Code Calli;
    
public static Code Ret;
    
public static Code Br_S;
    
public static Code Brfalse_S;
    
public static Code Brtrue_S;
    
public static Code Beq_S;
    
public static Code Bge_S;
    
public static Code Bgt_S;
    
public static Code Ble_S;
    
public static Code Blt_S;
    
public static Code Bne_Un_S;
    
public static Code Bge_Un_S;
    
public static Code Bgt_Un_S;
    
public static Code Ble_Un_S;
    
public static Code Blt_Un_S;
    
public static Code Br;
    
public static Code Brfalse;
    
public static Code Brtrue;
    
public static Code Beq;
    
public static Code Bge;
    
public static Code Bgt;
    
public static Code Ble;
    
public static Code Blt;
    
public static Code Bne_Un;
    
public static Code Bge_Un;
    
public static Code Bgt_Un;
    
public static Code Ble_Un;
    
public static Code Blt_Un;
    
public static Code Switch;
    
public static Code Ldind_I1;
    
public static Code Ldind_U1;
    
public static Code Ldind_I2;
    
public static Code Ldind_U2;
    
public static Code Ldind_I4;
    
public static Code Ldind_U4;
    
public static Code Ldind_I8;
    
public static Code Ldind_I;
    
public static Code Ldind_R4;
    
public static Code Ldind_R8;
    
public static Code Ldind_Ref;
    
public static Code Stind_Ref;
    
public static Code Stind_I1;
    
public static Code Stind_I2;
    
public static Code Stind_I4;
    
public static Code Stind_I8;
    
public static Code Stind_R4;
    
public static Code Stind_R8;
    
public static Code Add;
    
public static Code Sub;
    
public static Code Mul;
    
public static Code Div;
    
public static Code Div_Un;
    
public static Code Rem;
    
public static Code Rem_Un;
    
public static Code And;
    
public static Code Or;
    
public static Code Xor;
    
public static Code Shl;
    
public static Code Shr;
    
public static Code Shr_Un;
    
public static Code Neg;
    
public static Code Not;
    
public static Code Conv_I1;
    
public static Code Conv_I2;
    
public static Code Conv_I4;
    
public static Code Conv_I8;
    
public static Code Conv_R4;
    
public static Code Conv_R8;
    
public static Code Conv_U4;
    
public static Code Conv_U8;
    
public static Code Callvirt;
    
public static Code Cpobj;
    
public static Code Ldobj;
    
public static Code Ldstr;
    
public static Code Newobj;
    
public static Code Castclass;
    
public static Code Isinst;
    
public static Code Conv_R_Un;
    
public static Code Unbox;
    
public static Code Throw;
    
public static Code Ldfld;
    
public static Code Ldflda;
    
public static Code Stfld;
    
public static Code Ldsfld;
    
public static Code Ldsflda;
    
public static Code Stsfld;
    
public static Code Stobj;
    
public static Code Conv_Ovf_I1_Un;
    
public static Code Conv_Ovf_I2_Un;
    
public static Code Conv_Ovf_I4_Un;
    
public static Code Conv_Ovf_I8_Un;
    
public static Code Conv_Ovf_U1_Un;
    
public static Code Conv_Ovf_U2_Un;
    
public static Code Conv_Ovf_U4_Un;
    
public static Code Conv_Ovf_U8_Un;
    
public static Code Conv_Ovf_I_Un;
    
public static Code Conv_Ovf_U_Un;
    
public static Code Box;
    
public static Code Newarr;
    
public static Code Ldlen;
    
public static Code Ldelema;
    
public static Code Ldelem_I1;
    
public static Code Ldelem_U1;
    
public static Code Ldelem_I2;
    
public static Code Ldelem_U2;
    
public static Code Ldelem_I4;
    
public static Code Ldelem_U4;
    
public static Code Ldelem_I8;
    
public static Code Ldelem_I;
    
public static Code Ldelem_R4;
    
public static Code Ldelem_R8;
    
public static Code Ldelem_Ref;
    
public static Code Stelem_I;
    
public static Code Stelem_I1;
    
public static Code Stelem_I2;
    
public static Code Stelem_I4;
    
public static Code Stelem_I8;
    
public static Code Stelem_R4;
    
public static Code Stelem_R8;
    
public static Code Stelem_Ref;
    
public static Code Ldelem_Any;
    
public static Code Stelem_Any;
    
public static Code Unbox_Any;
    
public static Code Conv_Ovf_I1;
    
public static Code Conv_Ovf_U1;
    
public static Code Conv_Ovf_I2;
    
public static Code Conv_Ovf_U2;
    
public static Code Conv_Ovf_I4;
    
public static Code Conv_Ovf_U4;
    
public static Code Conv_Ovf_I8;
    
public static Code Conv_Ovf_U8;
    
public static Code Refanyval;
    
public static Code Ckfinite;
    
public static Code Mkrefany;
    
public static Code Ldtoken;
    
public static Code Conv_U2;
    
public static Code Conv_U1;
    
public static Code Conv_I;
    
public static Code Conv_Ovf_I;
    
public static Code Conv_Ovf_U;
    
public static Code Add_Ovf;
    
public static Code Add_Ovf_Un;
    
public static Code Mul_Ovf;
    
public static Code Mul_Ovf_Un;
    
public static Code Sub_Ovf;
    
public static Code Sub_Ovf_Un;
    
public static Code Endfinally;
    
public static Code Leave;
    
public static Code Leave_S;
    
public static Code Stind_I;
    
public static Code Conv_U;
    
public static Code Arglist;
    
public static Code Ceq;
    
public static Code Cgt;
    
public static Code Cgt_Un;
    
public static Code Clt;
    
public static Code Clt_Un;
    
public static Code Ldftn;
    
public static Code Ldvirtftn;
    
public static Code Ldarg;
    
public static Code Ldarga;
    
public static Code Starg;
    
public static Code Ldloc;
    
public static Code Ldloca;
    
public static Code Stloc;
    
public static Code Localloc;
    
public static Code Endfilter;
    
public static Code Unaligned;
    
public static Code Volatile;
    
public static Code Tail;
    
public static Code Initobj;
    
public static Code Constrained;
    
public static Code Cpblk;
    
public static Code Initblk;
    
public static Code No;
    
public static Code Rethrow;
    
public static Code Sizeof;
    
public static Code Refanytype;
    
public static Code Readonly;
}
internal class Mono.Cecil.Cil.CodeReader : BinaryStreamReader {
    
internal MetadataReader reader;
    
private int start;
    
private MethodDefinition method;
    
private MethodBody body;
    
private int Offset { get; }
    public CodeReader(MetadataReader reader);
    private int get_Offset();
    public int MoveTo(MethodDefinition method);
    public void MoveBackTo(int position);
    public MethodBody ReadMethodBody(MethodDefinition method);
    public int ReadCodeSize(MethodDefinition method);
    private int ReadCodeSize();
    private void ReadMethodBody();
    private void ReadFatMethod();
    public VariableDefinitionCollection ReadVariables(MetadataToken local_var_token);
    private void ReadCode();
    private OpCode ReadOpCode();
    private object ReadOperand(Instruction instruction);
    public string GetString(MetadataToken token);
    public ParameterDefinition GetParameter(int index);
    public VariableDefinition GetVariable(int index);
    public CallSite GetCallSite(MetadataToken token);
    private void ResolveBranches(Collection`1<Instruction> instructions);
    private Instruction GetInstruction(int offset);
    private static Instruction GetInstruction(Collection`1<Instruction> instructions, int offset);
    private void ReadSection();
    private void ReadSmallSection();
    private void ReadFatSection();
    private void ReadExceptionHandlers(int count, Func`1<int> read_entry, Func`1<int> read_length);
    private void ReadExceptionHandlerSpecific(ExceptionHandler handler);
    public MetadataToken ReadToken();
    private void ReadDebugInfo();
    private void ReadCustomDebugInformations(MethodDefinition method);
    private void ReadAsyncMethodBody(AsyncMethodBodyDebugInformation async_method);
    private void ReadStateMachineScope(StateMachineScopeDebugInformation state_machine_scope);
    private void ReadSequencePoints();
    private void ReadScopes(Collection`1<ScopeDebugInformation> scopes);
    private void ReadScope(ScopeDebugInformation scope);
    public ByteBuffer PatchRawMethodBody(MethodDefinition method, CodeWriter writer, Int32& code_size, MetadataToken& local_var_token);
    private void PatchRawFatMethod(ByteBuffer buffer, CodeWriter writer, Int32& code_size, MetadataToken& local_var_token);
    private void PatchRawCode(ByteBuffer buffer, int code_size, CodeWriter writer);
    private void PatchRawSection(ByteBuffer buffer, MetadataBuilder metadata);
    private void PatchRawSmallSection(ByteBuffer buffer, MetadataBuilder metadata);
    private void PatchRawFatSection(ByteBuffer buffer, MetadataBuilder metadata);
    private void PatchRawExceptionHandlers(ByteBuffer buffer, MetadataBuilder metadata, int count, bool fat_entry);
    [CompilerGeneratedAttribute]
private int <ReadSmallSection>b__26_0();
    [CompilerGeneratedAttribute]
private int <ReadSmallSection>b__26_1();
}
internal class Mono.Cecil.Cil.CodeWriter : ByteBuffer {
    
private UInt32 code_base;
    
internal MetadataBuilder metadata;
    
private Dictionary`2<UInt32, MetadataToken> standalone_signatures;
    
private Dictionary`2<ByteBuffer, UInt32> tiny_method_bodies;
    
private MethodBody body;
    public CodeWriter(MetadataBuilder metadata);
    public UInt32 WriteMethodBody(MethodDefinition method);
    private static bool IsEmptyMethodBody(MethodBody body);
    private static bool IsUnresolved(MethodDefinition method);
    private UInt32 WriteUnresolvedMethodBody(MethodDefinition method);
    private UInt32 WriteResolvedMethodBody(MethodDefinition method);
    private bool GetOrMapTinyMethodBody(ByteBuffer body, UInt32& rva);
    private void WriteFatHeader();
    private void WriteInstructions();
    private void WriteOpCode(OpCode opcode);
    private void WriteOperand(Instruction instruction);
    private int GetTargetOffset(Instruction instruction);
    private UInt32 GetUserStringIndex(string string);
    private static int GetVariableIndex(VariableDefinition variable);
    private int GetParameterIndex(ParameterDefinition parameter);
    private bool RequiresFatHeader();
    private void ComputeHeader();
    private void ComputeExceptionHandlerStackSize(Dictionary`2& stack_sizes);
    private static void AddExceptionStackSize(Instruction handler_start, Dictionary`2& stack_sizes);
    private static void ComputeStackSize(Instruction instruction, Dictionary`2& stack_sizes, Int32& stack_size, Int32& max_stack);
    private static void CopyBranchStackSize(Instruction instruction, Dictionary`2& stack_sizes, int stack_size);
    private static void CopyBranchStackSize(Dictionary`2& stack_sizes, Instruction target, int stack_size);
    private static void ComputeStackSize(Instruction instruction, Int32& stack_size);
    private static void ComputeStackDelta(Instruction instruction, Int32& stack_size);
    private static void ComputePopDelta(StackBehaviour pop_behavior, Int32& stack_size);
    private static void ComputePushDelta(StackBehaviour push_behaviour, Int32& stack_size);
    private void WriteExceptionHandlers();
    private static bool RequiresFatSection(Collection`1<ExceptionHandler> handlers);
    private static bool IsFatRange(Instruction start, Instruction end);
    private void WriteSmallSection(Collection`1<ExceptionHandler> handlers);
    private void WriteFatSection(Collection`1<ExceptionHandler> handlers);
    private void WriteExceptionHandlers(Collection`1<ExceptionHandler> handlers, Action`1<int> write_entry, Action`1<int> write_length);
    private void WriteExceptionHandlerSpecific(ExceptionHandler handler);
    public MetadataToken GetStandAloneSignature(Collection`1<VariableDefinition> variables);
    public MetadataToken GetStandAloneSignature(CallSite call_site);
    private MetadataToken GetStandAloneSignatureToken(UInt32 signature);
    private UInt32 BeginMethod();
    private void WriteMetadataToken(MetadataToken token);
    private void Align(int align);
    [CompilerGeneratedAttribute]
private void <WriteSmallSection>b__34_0(int i);
    [CompilerGeneratedAttribute]
private void <WriteSmallSection>b__34_1(int i);
}
internal class Mono.Cecil.Cil.ConstantDebugInformation : DebugInformation {
    
private string name;
    
private TypeReference constant_type;
    
private object value;
    
public string Name { get; public set; }
    
public TypeReference ConstantType { get; public set; }
    
public object Value { get; public set; }
    public ConstantDebugInformation(string name, TypeReference constant_type, object value);
    public string get_Name();
    public void set_Name(string value);
    public TypeReference get_ConstantType();
    public void set_ConstantType(TypeReference value);
    public object get_Value();
    public void set_Value(object value);
}
internal abstract class Mono.Cecil.Cil.CustomDebugInformation : DebugInformation {
    
private Guid identifier;
    
public Guid Identifier { get; }
    
public CustomDebugInformationKind Kind { get; }
    internal CustomDebugInformation(Guid identifier);
    public Guid get_Identifier();
    public abstract virtual CustomDebugInformationKind get_Kind();
}
internal enum Mono.Cecil.Cil.CustomDebugInformationKind : Enum {
    
public int value__;
    
public static CustomDebugInformationKind Binary;
    
public static CustomDebugInformationKind StateMachineScope;
    
public static CustomDebugInformationKind DynamicVariable;
    
public static CustomDebugInformationKind DefaultNamespace;
    
public static CustomDebugInformationKind AsyncMethodBody;
    
public static CustomDebugInformationKind EmbeddedSource;
    
public static CustomDebugInformationKind SourceLink;
}
internal abstract class Mono.Cecil.Cil.DebugInformation : object {
    
internal MetadataToken token;
    
internal Collection`1<CustomDebugInformation> custom_infos;
    
public MetadataToken MetadataToken { get; public set; }
    
public bool HasCustomDebugInformations { get; }
    
public Collection`1<CustomDebugInformation> CustomDebugInformations { get; }
    public sealed virtual MetadataToken get_MetadataToken();
    public sealed virtual void set_MetadataToken(MetadataToken value);
    public sealed virtual bool get_HasCustomDebugInformations();
    public sealed virtual Collection`1<CustomDebugInformation> get_CustomDebugInformations();
}
internal class Mono.Cecil.Cil.DefaultSymbolReaderProvider : object {
    
private bool throw_if_no_symbol;
    public DefaultSymbolReaderProvider(bool throwIfNoSymbol);
    public sealed virtual ISymbolReader GetSymbolReader(ModuleDefinition module, string fileName);
    public sealed virtual ISymbolReader GetSymbolReader(ModuleDefinition module, Stream symbolStream);
}
internal class Mono.Cecil.Cil.DefaultSymbolWriterProvider : object {
    public sealed virtual ISymbolWriter GetSymbolWriter(ModuleDefinition module, string fileName);
    public sealed virtual ISymbolWriter GetSymbolWriter(ModuleDefinition module, Stream symbolStream);
}
internal class Mono.Cecil.Cil.Document : DebugInformation {
    
private string url;
    
private Guid type;
    
private Guid hash_algorithm;
    
private Guid language;
    
private Guid language_vendor;
    
private Byte[] hash;
    
private Byte[] embedded_source;
    
public string Url { get; public set; }
    
public DocumentType Type { get; public set; }
    
public Guid TypeGuid { get; public set; }
    
public DocumentHashAlgorithm HashAlgorithm { get; public set; }
    
public Guid HashAlgorithmGuid { get; public set; }
    
public DocumentLanguage Language { get; public set; }
    
public Guid LanguageGuid { get; public set; }
    
public DocumentLanguageVendor LanguageVendor { get; public set; }
    
public Guid LanguageVendorGuid { get; public set; }
    
public Byte[] Hash { get; public set; }
    
public Byte[] EmbeddedSource { get; public set; }
    public Document(string url);
    public string get_Url();
    public void set_Url(string value);
    public DocumentType get_Type();
    public void set_Type(DocumentType value);
    public Guid get_TypeGuid();
    public void set_TypeGuid(Guid value);
    public DocumentHashAlgorithm get_HashAlgorithm();
    public void set_HashAlgorithm(DocumentHashAlgorithm value);
    public Guid get_HashAlgorithmGuid();
    public void set_HashAlgorithmGuid(Guid value);
    public DocumentLanguage get_Language();
    public void set_Language(DocumentLanguage value);
    public Guid get_LanguageGuid();
    public void set_LanguageGuid(Guid value);
    public DocumentLanguageVendor get_LanguageVendor();
    public void set_LanguageVendor(DocumentLanguageVendor value);
    public Guid get_LanguageVendorGuid();
    public void set_LanguageVendorGuid(Guid value);
    public Byte[] get_Hash();
    public void set_Hash(Byte[] value);
    public Byte[] get_EmbeddedSource();
    public void set_EmbeddedSource(Byte[] value);
}
internal enum Mono.Cecil.Cil.DocumentHashAlgorithm : Enum {
    
public int value__;
    
public static DocumentHashAlgorithm None;
    
public static DocumentHashAlgorithm MD5;
    
public static DocumentHashAlgorithm SHA1;
    
public static DocumentHashAlgorithm SHA256;
}
internal enum Mono.Cecil.Cil.DocumentLanguage : Enum {
    
public int value__;
    
public static DocumentLanguage Other;
    
public static DocumentLanguage C;
    
public static DocumentLanguage Cpp;
    
public static DocumentLanguage CSharp;
    
public static DocumentLanguage Basic;
    
public static DocumentLanguage Java;
    
public static DocumentLanguage Cobol;
    
public static DocumentLanguage Pascal;
    
public static DocumentLanguage Cil;
    
public static DocumentLanguage JScript;
    
public static DocumentLanguage Smc;
    
public static DocumentLanguage MCpp;
    
public static DocumentLanguage FSharp;
}
internal enum Mono.Cecil.Cil.DocumentLanguageVendor : Enum {
    
public int value__;
    
public static DocumentLanguageVendor Other;
    
public static DocumentLanguageVendor Microsoft;
}
internal enum Mono.Cecil.Cil.DocumentType : Enum {
    
public int value__;
    
public static DocumentType Other;
    
public static DocumentType Text;
}
internal class Mono.Cecil.Cil.EmbeddedPortablePdbReader : object {
    
private PortablePdbReader reader;
    internal EmbeddedPortablePdbReader(PortablePdbReader reader);
    public sealed virtual ISymbolWriterProvider GetWriterProvider();
    public sealed virtual bool ProcessDebugHeader(ImageDebugHeader header);
    public sealed virtual MethodDebugInformation Read(MethodDefinition method);
    public sealed virtual void Dispose();
}
internal class Mono.Cecil.Cil.EmbeddedPortablePdbReaderProvider : object {
    public sealed virtual ISymbolReader GetSymbolReader(ModuleDefinition module, string fileName);
    private static Stream GetPortablePdbStream(ImageDebugHeaderEntry entry);
    public sealed virtual ISymbolReader GetSymbolReader(ModuleDefinition module, Stream symbolStream);
}
internal class Mono.Cecil.Cil.EmbeddedPortablePdbWriter : object {
    
private Stream stream;
    
private PortablePdbWriter writer;
    internal EmbeddedPortablePdbWriter(Stream stream, PortablePdbWriter writer);
    public sealed virtual ISymbolReaderProvider GetReaderProvider();
    public sealed virtual void Write(MethodDebugInformation info);
    public sealed virtual ImageDebugHeader GetDebugHeader();
    public sealed virtual void Write();
    public sealed virtual void Dispose();
}
internal class Mono.Cecil.Cil.EmbeddedPortablePdbWriterProvider : object {
    public sealed virtual ISymbolWriter GetSymbolWriter(ModuleDefinition module, string fileName);
    public sealed virtual ISymbolWriter GetSymbolWriter(ModuleDefinition module, Stream symbolStream);
}
internal class Mono.Cecil.Cil.EmbeddedSourceDebugInformation : CustomDebugInformation {
    
internal UInt32 index;
    
internal MetadataReader debug_reader;
    
internal bool resolved;
    
internal Byte[] content;
    
internal bool compress;
    
public static Guid KindIdentifier;
    
public Byte[] Content { get; public set; }
    
public bool Compress { get; public set; }
    
public CustomDebugInformationKind Kind { get; }
    internal EmbeddedSourceDebugInformation(UInt32 index, MetadataReader debug_reader);
    public EmbeddedSourceDebugInformation(Byte[] content, bool compress);
    private static EmbeddedSourceDebugInformation();
    public Byte[] get_Content();
    public void set_Content(Byte[] value);
    public bool get_Compress();
    public void set_Compress(bool value);
    public virtual CustomDebugInformationKind get_Kind();
    internal Byte[] ReadRawEmbeddedSourceDebugInformation();
    private void Resolve();
}
internal class Mono.Cecil.Cil.ExceptionHandler : object {
    
private Instruction try_start;
    
private Instruction try_end;
    
private Instruction filter_start;
    
private Instruction handler_start;
    
private Instruction handler_end;
    
private TypeReference catch_type;
    
private ExceptionHandlerType handler_type;
    
public Instruction TryStart { get; public set; }
    
public Instruction TryEnd { get; public set; }
    
public Instruction FilterStart { get; public set; }
    
public Instruction HandlerStart { get; public set; }
    
public Instruction HandlerEnd { get; public set; }
    
public TypeReference CatchType { get; public set; }
    
public ExceptionHandlerType HandlerType { get; public set; }
    public ExceptionHandler(ExceptionHandlerType handlerType);
    public Instruction get_TryStart();
    public void set_TryStart(Instruction value);
    public Instruction get_TryEnd();
    public void set_TryEnd(Instruction value);
    public Instruction get_FilterStart();
    public void set_FilterStart(Instruction value);
    public Instruction get_HandlerStart();
    public void set_HandlerStart(Instruction value);
    public Instruction get_HandlerEnd();
    public void set_HandlerEnd(Instruction value);
    public TypeReference get_CatchType();
    public void set_CatchType(TypeReference value);
    public ExceptionHandlerType get_HandlerType();
    public void set_HandlerType(ExceptionHandlerType value);
}
internal enum Mono.Cecil.Cil.ExceptionHandlerType : Enum {
    
public int value__;
    
public static ExceptionHandlerType Catch;
    
public static ExceptionHandlerType Filter;
    
public static ExceptionHandlerType Finally;
    
public static ExceptionHandlerType Fault;
}
internal enum Mono.Cecil.Cil.FlowControl : Enum {
    
public int value__;
    
public static FlowControl Branch;
    
public static FlowControl Break;
    
public static FlowControl Call;
    
public static FlowControl Cond_Branch;
    
public static FlowControl Meta;
    
public static FlowControl Next;
    
public static FlowControl Phi;
    
public static FlowControl Return;
    
public static FlowControl Throw;
}
internal interface Mono.Cecil.Cil.ICustomDebugInformationProvider {
    
public bool HasCustomDebugInformations { get; }
    
public Collection`1<CustomDebugInformation> CustomDebugInformations { get; }
    public abstract virtual bool get_HasCustomDebugInformations();
    public abstract virtual Collection`1<CustomDebugInformation> get_CustomDebugInformations();
}
internal class Mono.Cecil.Cil.ILProcessor : object {
    
private MethodBody body;
    
private Collection`1<Instruction> instructions;
    
public MethodBody Body { get; }
    internal ILProcessor(MethodBody body);
    public MethodBody get_Body();
    public Instruction Create(OpCode opcode);
    public Instruction Create(OpCode opcode, TypeReference type);
    public Instruction Create(OpCode opcode, CallSite site);
    public Instruction Create(OpCode opcode, MethodReference method);
    public Instruction Create(OpCode opcode, FieldReference field);
    public Instruction Create(OpCode opcode, string value);
    public Instruction Create(OpCode opcode, sbyte value);
    public Instruction Create(OpCode opcode, byte value);
    public Instruction Create(OpCode opcode, int value);
    public Instruction Create(OpCode opcode, long value);
    public Instruction Create(OpCode opcode, float value);
    public Instruction Create(OpCode opcode, double value);
    public Instruction Create(OpCode opcode, Instruction target);
    public Instruction Create(OpCode opcode, Instruction[] targets);
    public Instruction Create(OpCode opcode, VariableDefinition variable);
    public Instruction Create(OpCode opcode, ParameterDefinition parameter);
    public void Emit(OpCode opcode);
    public void Emit(OpCode opcode, TypeReference type);
    public void Emit(OpCode opcode, MethodReference method);
    public void Emit(OpCode opcode, CallSite site);
    public void Emit(OpCode opcode, FieldReference field);
    public void Emit(OpCode opcode, string value);
    public void Emit(OpCode opcode, byte value);
    public void Emit(OpCode opcode, sbyte value);
    public void Emit(OpCode opcode, int value);
    public void Emit(OpCode opcode, long value);
    public void Emit(OpCode opcode, float value);
    public void Emit(OpCode opcode, double value);
    public void Emit(OpCode opcode, Instruction target);
    public void Emit(OpCode opcode, Instruction[] targets);
    public void Emit(OpCode opcode, VariableDefinition variable);
    public void Emit(OpCode opcode, ParameterDefinition parameter);
    public void InsertBefore(Instruction target, Instruction instruction);
    public void InsertAfter(Instruction target, Instruction instruction);
    public void InsertAfter(int index, Instruction instruction);
    public void Append(Instruction instruction);
    public void Replace(Instruction target, Instruction instruction);
    public void Replace(int index, Instruction instruction);
    public void Remove(Instruction instruction);
    public void RemoveAt(int index);
    public void Clear();
}
internal class Mono.Cecil.Cil.ImageDebugDirectory : ValueType {
    
public static int Size;
    
public int Characteristics;
    
public int TimeDateStamp;
    
public short MajorVersion;
    
public short MinorVersion;
    
public ImageDebugType Type;
    
public int SizeOfData;
    
public int AddressOfRawData;
    
public int PointerToRawData;
}
internal class Mono.Cecil.Cil.ImageDebugHeader : object {
    
private ImageDebugHeaderEntry[] entries;
    
public bool HasEntries { get; }
    
public ImageDebugHeaderEntry[] Entries { get; }
    public ImageDebugHeader(ImageDebugHeaderEntry[] entries);
    public ImageDebugHeader(ImageDebugHeaderEntry entry);
    public bool get_HasEntries();
    public ImageDebugHeaderEntry[] get_Entries();
}
internal class Mono.Cecil.Cil.ImageDebugHeaderEntry : object {
    
private ImageDebugDirectory directory;
    
private Byte[] data;
    
public ImageDebugDirectory Directory { get; internal set; }
    
public Byte[] Data { get; }
    public ImageDebugHeaderEntry(ImageDebugDirectory directory, Byte[] data);
    public ImageDebugDirectory get_Directory();
    internal void set_Directory(ImageDebugDirectory value);
    public Byte[] get_Data();
}
internal enum Mono.Cecil.Cil.ImageDebugType : Enum {
    
public int value__;
    
public static ImageDebugType CodeView;
    
public static ImageDebugType Deterministic;
    
public static ImageDebugType EmbeddedPortablePdb;
    
public static ImageDebugType PdbChecksum;
}
internal class Mono.Cecil.Cil.ImportDebugInformation : DebugInformation {
    
internal ImportDebugInformation parent;
    
internal Collection`1<ImportTarget> targets;
    
public bool HasTargets { get; }
    
public Collection`1<ImportTarget> Targets { get; }
    
public ImportDebugInformation Parent { get; public set; }
    public bool get_HasTargets();
    public Collection`1<ImportTarget> get_Targets();
    public ImportDebugInformation get_Parent();
    public void set_Parent(ImportDebugInformation value);
}
internal class Mono.Cecil.Cil.ImportTarget : object {
    
internal ImportTargetKind kind;
    
internal string namespace;
    
internal TypeReference type;
    
internal AssemblyNameReference reference;
    
internal string alias;
    
public string Namespace { get; public set; }
    
public TypeReference Type { get; public set; }
    
public AssemblyNameReference AssemblyReference { get; public set; }
    
public string Alias { get; public set; }
    
public ImportTargetKind Kind { get; public set; }
    public ImportTarget(ImportTargetKind kind);
    public string get_Namespace();
    public void set_Namespace(string value);
    public TypeReference get_Type();
    public void set_Type(TypeReference value);
    public AssemblyNameReference get_AssemblyReference();
    public void set_AssemblyReference(AssemblyNameReference value);
    public string get_Alias();
    public void set_Alias(string value);
    public ImportTargetKind get_Kind();
    public void set_Kind(ImportTargetKind value);
}
internal enum Mono.Cecil.Cil.ImportTargetKind : Enum {
    
public byte value__;
    
public static ImportTargetKind ImportNamespace;
    
public static ImportTargetKind ImportNamespaceInAssembly;
    
public static ImportTargetKind ImportType;
    
public static ImportTargetKind ImportXmlNamespaceWithAlias;
    
public static ImportTargetKind ImportAlias;
    
public static ImportTargetKind DefineAssemblyAlias;
    
public static ImportTargetKind DefineNamespaceAlias;
    
public static ImportTargetKind DefineNamespaceInAssemblyAlias;
    
public static ImportTargetKind DefineTypeAlias;
}
internal class Mono.Cecil.Cil.Instruction : object {
    
internal int offset;
    
internal OpCode opcode;
    
internal object operand;
    
internal Instruction previous;
    
internal Instruction next;
    
public int Offset { get; public set; }
    
public OpCode OpCode { get; public set; }
    
public object Operand { get; public set; }
    
public Instruction Previous { get; public set; }
    
public Instruction Next { get; public set; }
    internal Instruction(int offset, OpCode opCode);
    internal Instruction(OpCode opcode, object operand);
    public int get_Offset();
    public void set_Offset(int value);
    public OpCode get_OpCode();
    public void set_OpCode(OpCode value);
    public object get_Operand();
    public void set_Operand(object value);
    public Instruction get_Previous();
    public void set_Previous(Instruction value);
    public Instruction get_Next();
    public void set_Next(Instruction value);
    public int GetSize();
    public virtual string ToString();
    private static void AppendLabel(StringBuilder builder, Instruction instruction);
    public static Instruction Create(OpCode opcode);
    public static Instruction Create(OpCode opcode, TypeReference type);
    public static Instruction Create(OpCode opcode, CallSite site);
    public static Instruction Create(OpCode opcode, MethodReference method);
    public static Instruction Create(OpCode opcode, FieldReference field);
    public static Instruction Create(OpCode opcode, string value);
    public static Instruction Create(OpCode opcode, sbyte value);
    public static Instruction Create(OpCode opcode, byte value);
    public static Instruction Create(OpCode opcode, int value);
    public static Instruction Create(OpCode opcode, long value);
    public static Instruction Create(OpCode opcode, float value);
    public static Instruction Create(OpCode opcode, double value);
    public static Instruction Create(OpCode opcode, Instruction target);
    public static Instruction Create(OpCode opcode, Instruction[] targets);
    public static Instruction Create(OpCode opcode, VariableDefinition variable);
    public static Instruction Create(OpCode opcode, ParameterDefinition parameter);
}
internal class Mono.Cecil.Cil.InstructionCollection : Collection`1<Instruction> {
    
private MethodDefinition method;
    internal InstructionCollection(MethodDefinition method);
    internal InstructionCollection(MethodDefinition method, int capacity);
    protected virtual void OnAdd(Instruction item, int index);
    protected virtual void OnInsert(Instruction item, int index);
    protected virtual void OnSet(Instruction item, int index);
    protected virtual void OnRemove(Instruction item, int index);
    private void RemoveSequencePoint(Instruction instruction);
    private void UpdateDebugInformation(Instruction removedInstruction, Instruction existingInstruction);
    private void UpdateLocalScope(ScopeDebugInformation scope, InstructionOffsetResolver& resolver);
    private void UpdateStateMachineScope(StateMachineScopeDebugInformation debugInfo, InstructionOffsetResolver& resolver);
    private void UpdateAsyncMethodBody(AsyncMethodBodyDebugInformation debugInfo, InstructionOffsetResolver& resolver);
}
internal class Mono.Cecil.Cil.InstructionOffset : ValueType {
    
private Instruction instruction;
    
private Nullable`1<int> offset;
    
public int Offset { get; }
    
public bool IsEndOfMethod { get; }
    
internal bool IsResolved { get; }
    
internal Instruction ResolvedInstruction { get; }
    public InstructionOffset(Instruction instruction);
    public InstructionOffset(int offset);
    public int get_Offset();
    public bool get_IsEndOfMethod();
    internal bool get_IsResolved();
    internal Instruction get_ResolvedInstruction();
}
internal interface Mono.Cecil.Cil.ISymbolReader {
    public abstract virtual ISymbolWriterProvider GetWriterProvider();
    public abstract virtual bool ProcessDebugHeader(ImageDebugHeader header);
    public abstract virtual MethodDebugInformation Read(MethodDefinition method);
}
internal interface Mono.Cecil.Cil.ISymbolReaderProvider {
    public abstract virtual ISymbolReader GetSymbolReader(ModuleDefinition module, string fileName);
    public abstract virtual ISymbolReader GetSymbolReader(ModuleDefinition module, Stream symbolStream);
}
internal interface Mono.Cecil.Cil.ISymbolWriter {
    public abstract virtual ISymbolReaderProvider GetReaderProvider();
    public abstract virtual ImageDebugHeader GetDebugHeader();
    public abstract virtual void Write(MethodDebugInformation info);
    public abstract virtual void Write();
}
internal interface Mono.Cecil.Cil.ISymbolWriterProvider {
    public abstract virtual ISymbolWriter GetSymbolWriter(ModuleDefinition module, string fileName);
    public abstract virtual ISymbolWriter GetSymbolWriter(ModuleDefinition module, Stream symbolStream);
}
internal class Mono.Cecil.Cil.MethodBody : object {
    
internal MethodDefinition method;
    
internal ParameterDefinition this_parameter;
    
internal int max_stack_size;
    
internal int code_size;
    
internal bool init_locals;
    
internal MetadataToken local_var_token;
    
internal Collection`1<Instruction> instructions;
    
internal Collection`1<ExceptionHandler> exceptions;
    
internal Collection`1<VariableDefinition> variables;
    
public MethodDefinition Method { get; }
    
public int MaxStackSize { get; public set; }
    
public int CodeSize { get; }
    
public bool InitLocals { get; public set; }
    
public MetadataToken LocalVarToken { get; public set; }
    
public Collection`1<Instruction> Instructions { get; }
    
public bool HasExceptionHandlers { get; }
    
public Collection`1<ExceptionHandler> ExceptionHandlers { get; }
    
public bool HasVariables { get; }
    
public Collection`1<VariableDefinition> Variables { get; }
    
public ParameterDefinition ThisParameter { get; }
    public MethodBody(MethodDefinition method);
    public MethodDefinition get_Method();
    public int get_MaxStackSize();
    public void set_MaxStackSize(int value);
    public int get_CodeSize();
    public bool get_InitLocals();
    public void set_InitLocals(bool value);
    public MetadataToken get_LocalVarToken();
    public void set_LocalVarToken(MetadataToken value);
    public Collection`1<Instruction> get_Instructions();
    public bool get_HasExceptionHandlers();
    public Collection`1<ExceptionHandler> get_ExceptionHandlers();
    public bool get_HasVariables();
    public Collection`1<VariableDefinition> get_Variables();
    public ParameterDefinition get_ThisParameter();
    private static ParameterDefinition CreateThisParameter(MethodDefinition method);
    public ILProcessor GetILProcessor();
}
internal class Mono.Cecil.Cil.MethodDebugInformation : DebugInformation {
    
internal MethodDefinition method;
    
internal Collection`1<SequencePoint> sequence_points;
    
internal ScopeDebugInformation scope;
    
internal MethodDefinition kickoff_method;
    
internal int code_size;
    
internal MetadataToken local_var_token;
    
public MethodDefinition Method { get; }
    
public bool HasSequencePoints { get; }
    
public Collection`1<SequencePoint> SequencePoints { get; }
    
public ScopeDebugInformation Scope { get; public set; }
    
public MethodDefinition StateMachineKickOffMethod { get; public set; }
    internal MethodDebugInformation(MethodDefinition method);
    public MethodDefinition get_Method();
    public bool get_HasSequencePoints();
    public Collection`1<SequencePoint> get_SequencePoints();
    public ScopeDebugInformation get_Scope();
    public void set_Scope(ScopeDebugInformation value);
    public MethodDefinition get_StateMachineKickOffMethod();
    public void set_StateMachineKickOffMethod(MethodDefinition value);
    public SequencePoint GetSequencePoint(Instruction instruction);
    public IDictionary`2<Instruction, SequencePoint> GetSequencePointMapping();
    public IEnumerable`1<ScopeDebugInformation> GetScopes();
    private static IEnumerable`1<ScopeDebugInformation> GetScopes(IList`1<ScopeDebugInformation> scopes);
    public bool TryGetName(VariableDefinition variable, String& name);
}
internal class Mono.Cecil.Cil.OpCode : ValueType {
    
private byte op1;
    
private byte op2;
    
private byte code;
    
private byte flow_control;
    
private byte opcode_type;
    
private byte operand_type;
    
private byte stack_behavior_pop;
    
private byte stack_behavior_push;
    
public string Name { get; }
    
public int Size { get; }
    
public byte Op1 { get; }
    
public byte Op2 { get; }
    
public short Value { get; }
    
public Code Code { get; }
    
public FlowControl FlowControl { get; }
    
public OpCodeType OpCodeType { get; }
    
public OperandType OperandType { get; }
    
public StackBehaviour StackBehaviourPop { get; }
    
public StackBehaviour StackBehaviourPush { get; }
    internal OpCode(int x, int y);
    public string get_Name();
    public int get_Size();
    public byte get_Op1();
    public byte get_Op2();
    public short get_Value();
    public Code get_Code();
    public FlowControl get_FlowControl();
    public OpCodeType get_OpCodeType();
    public OperandType get_OperandType();
    public StackBehaviour get_StackBehaviourPop();
    public StackBehaviour get_StackBehaviourPush();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(OpCode opcode);
    public static bool op_Equality(OpCode one, OpCode other);
    public static bool op_Inequality(OpCode one, OpCode other);
    public virtual string ToString();
}
internal static class Mono.Cecil.Cil.OpCodeNames : object {
    
internal static String[] names;
    private static OpCodeNames();
}
internal static class Mono.Cecil.Cil.OpCodes : object {
    
internal static OpCode[] OneByteOpCode;
    
internal static OpCode[] TwoBytesOpCode;
    
public static OpCode Nop;
    
public static OpCode Break;
    
public static OpCode Ldarg_0;
    
public static OpCode Ldarg_1;
    
public static OpCode Ldarg_2;
    
public static OpCode Ldarg_3;
    
public static OpCode Ldloc_0;
    
public static OpCode Ldloc_1;
    
public static OpCode Ldloc_2;
    
public static OpCode Ldloc_3;
    
public static OpCode Stloc_0;
    
public static OpCode Stloc_1;
    
public static OpCode Stloc_2;
    
public static OpCode Stloc_3;
    
public static OpCode Ldarg_S;
    
public static OpCode Ldarga_S;
    
public static OpCode Starg_S;
    
public static OpCode Ldloc_S;
    
public static OpCode Ldloca_S;
    
public static OpCode Stloc_S;
    
public static OpCode Ldnull;
    
public static OpCode Ldc_I4_M1;
    
public static OpCode Ldc_I4_0;
    
public static OpCode Ldc_I4_1;
    
public static OpCode Ldc_I4_2;
    
public static OpCode Ldc_I4_3;
    
public static OpCode Ldc_I4_4;
    
public static OpCode Ldc_I4_5;
    
public static OpCode Ldc_I4_6;
    
public static OpCode Ldc_I4_7;
    
public static OpCode Ldc_I4_8;
    
public static OpCode Ldc_I4_S;
    
public static OpCode Ldc_I4;
    
public static OpCode Ldc_I8;
    
public static OpCode Ldc_R4;
    
public static OpCode Ldc_R8;
    
public static OpCode Dup;
    
public static OpCode Pop;
    
public static OpCode Jmp;
    
public static OpCode Call;
    
public static OpCode Calli;
    
public static OpCode Ret;
    
public static OpCode Br_S;
    
public static OpCode Brfalse_S;
    
public static OpCode Brtrue_S;
    
public static OpCode Beq_S;
    
public static OpCode Bge_S;
    
public static OpCode Bgt_S;
    
public static OpCode Ble_S;
    
public static OpCode Blt_S;
    
public static OpCode Bne_Un_S;
    
public static OpCode Bge_Un_S;
    
public static OpCode Bgt_Un_S;
    
public static OpCode Ble_Un_S;
    
public static OpCode Blt_Un_S;
    
public static OpCode Br;
    
public static OpCode Brfalse;
    
public static OpCode Brtrue;
    
public static OpCode Beq;
    
public static OpCode Bge;
    
public static OpCode Bgt;
    
public static OpCode Ble;
    
public static OpCode Blt;
    
public static OpCode Bne_Un;
    
public static OpCode Bge_Un;
    
public static OpCode Bgt_Un;
    
public static OpCode Ble_Un;
    
public static OpCode Blt_Un;
    
public static OpCode Switch;
    
public static OpCode Ldind_I1;
    
public static OpCode Ldind_U1;
    
public static OpCode Ldind_I2;
    
public static OpCode Ldind_U2;
    
public static OpCode Ldind_I4;
    
public static OpCode Ldind_U4;
    
public static OpCode Ldind_I8;
    
public static OpCode Ldind_I;
    
public static OpCode Ldind_R4;
    
public static OpCode Ldind_R8;
    
public static OpCode Ldind_Ref;
    
public static OpCode Stind_Ref;
    
public static OpCode Stind_I1;
    
public static OpCode Stind_I2;
    
public static OpCode Stind_I4;
    
public static OpCode Stind_I8;
    
public static OpCode Stind_R4;
    
public static OpCode Stind_R8;
    
public static OpCode Add;
    
public static OpCode Sub;
    
public static OpCode Mul;
    
public static OpCode Div;
    
public static OpCode Div_Un;
    
public static OpCode Rem;
    
public static OpCode Rem_Un;
    
public static OpCode And;
    
public static OpCode Or;
    
public static OpCode Xor;
    
public static OpCode Shl;
    
public static OpCode Shr;
    
public static OpCode Shr_Un;
    
public static OpCode Neg;
    
public static OpCode Not;
    
public static OpCode Conv_I1;
    
public static OpCode Conv_I2;
    
public static OpCode Conv_I4;
    
public static OpCode Conv_I8;
    
public static OpCode Conv_R4;
    
public static OpCode Conv_R8;
    
public static OpCode Conv_U4;
    
public static OpCode Conv_U8;
    
public static OpCode Callvirt;
    
public static OpCode Cpobj;
    
public static OpCode Ldobj;
    
public static OpCode Ldstr;
    
public static OpCode Newobj;
    
public static OpCode Castclass;
    
public static OpCode Isinst;
    
public static OpCode Conv_R_Un;
    
public static OpCode Unbox;
    
public static OpCode Throw;
    
public static OpCode Ldfld;
    
public static OpCode Ldflda;
    
public static OpCode Stfld;
    
public static OpCode Ldsfld;
    
public static OpCode Ldsflda;
    
public static OpCode Stsfld;
    
public static OpCode Stobj;
    
public static OpCode Conv_Ovf_I1_Un;
    
public static OpCode Conv_Ovf_I2_Un;
    
public static OpCode Conv_Ovf_I4_Un;
    
public static OpCode Conv_Ovf_I8_Un;
    
public static OpCode Conv_Ovf_U1_Un;
    
public static OpCode Conv_Ovf_U2_Un;
    
public static OpCode Conv_Ovf_U4_Un;
    
public static OpCode Conv_Ovf_U8_Un;
    
public static OpCode Conv_Ovf_I_Un;
    
public static OpCode Conv_Ovf_U_Un;
    
public static OpCode Box;
    
public static OpCode Newarr;
    
public static OpCode Ldlen;
    
public static OpCode Ldelema;
    
public static OpCode Ldelem_I1;
    
public static OpCode Ldelem_U1;
    
public static OpCode Ldelem_I2;
    
public static OpCode Ldelem_U2;
    
public static OpCode Ldelem_I4;
    
public static OpCode Ldelem_U4;
    
public static OpCode Ldelem_I8;
    
public static OpCode Ldelem_I;
    
public static OpCode Ldelem_R4;
    
public static OpCode Ldelem_R8;
    
public static OpCode Ldelem_Ref;
    
public static OpCode Stelem_I;
    
public static OpCode Stelem_I1;
    
public static OpCode Stelem_I2;
    
public static OpCode Stelem_I4;
    
public static OpCode Stelem_I8;
    
public static OpCode Stelem_R4;
    
public static OpCode Stelem_R8;
    
public static OpCode Stelem_Ref;
    
public static OpCode Ldelem_Any;
    
public static OpCode Stelem_Any;
    
public static OpCode Unbox_Any;
    
public static OpCode Conv_Ovf_I1;
    
public static OpCode Conv_Ovf_U1;
    
public static OpCode Conv_Ovf_I2;
    
public static OpCode Conv_Ovf_U2;
    
public static OpCode Conv_Ovf_I4;
    
public static OpCode Conv_Ovf_U4;
    
public static OpCode Conv_Ovf_I8;
    
public static OpCode Conv_Ovf_U8;
    
public static OpCode Refanyval;
    
public static OpCode Ckfinite;
    
public static OpCode Mkrefany;
    
public static OpCode Ldtoken;
    
public static OpCode Conv_U2;
    
public static OpCode Conv_U1;
    
public static OpCode Conv_I;
    
public static OpCode Conv_Ovf_I;
    
public static OpCode Conv_Ovf_U;
    
public static OpCode Add_Ovf;
    
public static OpCode Add_Ovf_Un;
    
public static OpCode Mul_Ovf;
    
public static OpCode Mul_Ovf_Un;
    
public static OpCode Sub_Ovf;
    
public static OpCode Sub_Ovf_Un;
    
public static OpCode Endfinally;
    
public static OpCode Leave;
    
public static OpCode Leave_S;
    
public static OpCode Stind_I;
    
public static OpCode Conv_U;
    
public static OpCode Arglist;
    
public static OpCode Ceq;
    
public static OpCode Cgt;
    
public static OpCode Cgt_Un;
    
public static OpCode Clt;
    
public static OpCode Clt_Un;
    
public static OpCode Ldftn;
    
public static OpCode Ldvirtftn;
    
public static OpCode Ldarg;
    
public static OpCode Ldarga;
    
public static OpCode Starg;
    
public static OpCode Ldloc;
    
public static OpCode Ldloca;
    
public static OpCode Stloc;
    
public static OpCode Localloc;
    
public static OpCode Endfilter;
    
public static OpCode Unaligned;
    
public static OpCode Volatile;
    
public static OpCode Tail;
    
public static OpCode Initobj;
    
public static OpCode Constrained;
    
public static OpCode Cpblk;
    
public static OpCode Initblk;
    
public static OpCode No;
    
public static OpCode Rethrow;
    
public static OpCode Sizeof;
    
public static OpCode Refanytype;
    
public static OpCode Readonly;
    private static OpCodes();
}
internal enum Mono.Cecil.Cil.OpCodeType : Enum {
    
public int value__;
    
public static OpCodeType Annotation;
    
public static OpCodeType Macro;
    
public static OpCodeType Nternal;
    
public static OpCodeType Objmodel;
    
public static OpCodeType Prefix;
    
public static OpCodeType Primitive;
}
internal enum Mono.Cecil.Cil.OperandType : Enum {
    
public int value__;
    
public static OperandType InlineBrTarget;
    
public static OperandType InlineField;
    
public static OperandType InlineI;
    
public static OperandType InlineI8;
    
public static OperandType InlineMethod;
    
public static OperandType InlineNone;
    
public static OperandType InlinePhi;
    
public static OperandType InlineR;
    
public static OperandType InlineSig;
    
public static OperandType InlineString;
    
public static OperandType InlineSwitch;
    
public static OperandType InlineTok;
    
public static OperandType InlineType;
    
public static OperandType InlineVar;
    
public static OperandType InlineArg;
    
public static OperandType ShortInlineBrTarget;
    
public static OperandType ShortInlineI;
    
public static OperandType ShortInlineR;
    
public static OperandType ShortInlineVar;
    
public static OperandType ShortInlineArg;
}
[ExtensionAttribute]
internal static class Mono.Cecil.Cil.PdbGuidMapping : object {
    
private static Dictionary`2<Guid, DocumentLanguage> guid_language;
    
private static Dictionary`2<DocumentLanguage, Guid> language_guid;
    
private static Guid type_text;
    
private static Guid hash_md5;
    
private static Guid hash_sha1;
    
private static Guid hash_sha256;
    
private static Guid vendor_ms;
    private static PdbGuidMapping();
    private static void AddMapping(DocumentLanguage language, Guid guid);
    [ExtensionAttribute]
public static DocumentType ToType(Guid guid);
    [ExtensionAttribute]
public static Guid ToGuid(DocumentType type);
    [ExtensionAttribute]
public static DocumentHashAlgorithm ToHashAlgorithm(Guid guid);
    [ExtensionAttribute]
public static Guid ToGuid(DocumentHashAlgorithm hash_algo);
    [ExtensionAttribute]
public static DocumentLanguage ToLanguage(Guid guid);
    [ExtensionAttribute]
public static Guid ToGuid(DocumentLanguage language);
    [ExtensionAttribute]
public static DocumentLanguageVendor ToVendor(Guid guid);
    [ExtensionAttribute]
public static Guid ToGuid(DocumentLanguageVendor vendor);
}
internal class Mono.Cecil.Cil.PortablePdbReader : object {
    
private Image image;
    
private ModuleDefinition module;
    
private MetadataReader reader;
    
private MetadataReader debug_reader;
    
private bool IsEmbedded { get; }
    internal PortablePdbReader(Image image, ModuleDefinition module);
    private bool get_IsEmbedded();
    public sealed virtual ISymbolWriterProvider GetWriterProvider();
    public sealed virtual bool ProcessDebugHeader(ImageDebugHeader header);
    private static bool IsMatchingEntry(PdbHeap heap, ImageDebugHeaderEntry entry);
    private static int ReadInt32(Byte[] bytes, int start);
    private void ReadModule();
    public sealed virtual MethodDebugInformation Read(MethodDefinition method);
    private void ReadSequencePoints(MethodDebugInformation method_info);
    private void ReadScope(MethodDebugInformation method_info);
    private void ReadStateMachineKickOffMethod(MethodDebugInformation method_info);
    private void ReadCustomDebugInformations(MethodDebugInformation info);
    public sealed virtual void Dispose();
}
internal class Mono.Cecil.Cil.PortablePdbReaderProvider : object {
    public sealed virtual ISymbolReader GetSymbolReader(ModuleDefinition module, string fileName);
    public sealed virtual ISymbolReader GetSymbolReader(ModuleDefinition module, Stream symbolStream);
    private ISymbolReader GetSymbolReader(ModuleDefinition module, Disposable`1<Stream> symbolStream, string fileName);
}
internal class Mono.Cecil.Cil.PortablePdbWriter : object {
    
private MetadataBuilder pdb_metadata;
    
private ModuleDefinition module;
    
private ImageWriter writer;
    
private Disposable`1<Stream> final_stream;
    
private MetadataBuilder module_metadata;
    
internal Byte[] pdb_checksum;
    
internal Guid pdb_id_guid;
    
internal UInt32 pdb_id_stamp;
    
private bool IsEmbedded { get; }
    internal PortablePdbWriter(MetadataBuilder pdb_metadata, ModuleDefinition module);
    internal PortablePdbWriter(MetadataBuilder pdb_metadata, ModuleDefinition module, ImageWriter writer, Disposable`1<Stream> final_stream);
    private bool get_IsEmbedded();
    public sealed virtual ISymbolReaderProvider GetReaderProvider();
    public sealed virtual void Write(MethodDebugInformation info);
    public sealed virtual void Write();
    public sealed virtual ImageDebugHeader GetDebugHeader();
    private void CheckMethodDebugInformationTable();
    public sealed virtual void Dispose();
    private void WritePdbFile();
    private void WritePdbHeap();
    private void WriteTableHeap();
    private void ComputeChecksumAndPdbId();
    private void WritePdbId();
}
internal class Mono.Cecil.Cil.PortablePdbWriterProvider : object {
    public sealed virtual ISymbolWriter GetSymbolWriter(ModuleDefinition module, string fileName);
    public sealed virtual ISymbolWriter GetSymbolWriter(ModuleDefinition module, Stream symbolStream);
    private ISymbolWriter GetSymbolWriter(ModuleDefinition module, Disposable`1<Stream> stream, Disposable`1<Stream> final_stream);
}
internal class Mono.Cecil.Cil.ScopeDebugInformation : DebugInformation {
    
internal InstructionOffset start;
    
internal InstructionOffset end;
    
internal ImportDebugInformation import;
    
internal Collection`1<ScopeDebugInformation> scopes;
    
internal Collection`1<VariableDebugInformation> variables;
    
internal Collection`1<ConstantDebugInformation> constants;
    
public InstructionOffset Start { get; public set; }
    
public InstructionOffset End { get; public set; }
    
public ImportDebugInformation Import { get; public set; }
    
public bool HasScopes { get; }
    
public Collection`1<ScopeDebugInformation> Scopes { get; }
    
public bool HasVariables { get; }
    
public Collection`1<VariableDebugInformation> Variables { get; }
    
public bool HasConstants { get; }
    
public Collection`1<ConstantDebugInformation> Constants { get; }
    public ScopeDebugInformation(Instruction start, Instruction end);
    public InstructionOffset get_Start();
    public void set_Start(InstructionOffset value);
    public InstructionOffset get_End();
    public void set_End(InstructionOffset value);
    public ImportDebugInformation get_Import();
    public void set_Import(ImportDebugInformation value);
    public bool get_HasScopes();
    public Collection`1<ScopeDebugInformation> get_Scopes();
    public bool get_HasVariables();
    public Collection`1<VariableDebugInformation> get_Variables();
    public bool get_HasConstants();
    public Collection`1<ConstantDebugInformation> get_Constants();
    public bool TryGetName(VariableDefinition variable, String& name);
}
internal class Mono.Cecil.Cil.SequencePoint : object {
    
internal InstructionOffset offset;
    
private Document document;
    
private int start_line;
    
private int start_column;
    
private int end_line;
    
private int end_column;
    
public int Offset { get; }
    
public int StartLine { get; public set; }
    
public int StartColumn { get; public set; }
    
public int EndLine { get; public set; }
    
public int EndColumn { get; public set; }
    
public bool IsHidden { get; }
    
public Document Document { get; public set; }
    internal SequencePoint(int offset, Document document);
    public SequencePoint(Instruction instruction, Document document);
    public int get_Offset();
    public int get_StartLine();
    public void set_StartLine(int value);
    public int get_StartColumn();
    public void set_StartColumn(int value);
    public int get_EndLine();
    public void set_EndLine(int value);
    public int get_EndColumn();
    public void set_EndColumn(int value);
    public bool get_IsHidden();
    public Document get_Document();
    public void set_Document(Document value);
}
internal class Mono.Cecil.Cil.SourceLinkDebugInformation : CustomDebugInformation {
    
internal string content;
    
public static Guid KindIdentifier;
    
public string Content { get; public set; }
    
public CustomDebugInformationKind Kind { get; }
    public SourceLinkDebugInformation(string content);
    private static SourceLinkDebugInformation();
    public string get_Content();
    public void set_Content(string value);
    public virtual CustomDebugInformationKind get_Kind();
}
internal enum Mono.Cecil.Cil.StackBehaviour : Enum {
    
public int value__;
    
public static StackBehaviour Pop0;
    
public static StackBehaviour Pop1;
    
public static StackBehaviour Pop1_pop1;
    
public static StackBehaviour Popi;
    
public static StackBehaviour Popi_pop1;
    
public static StackBehaviour Popi_popi;
    
public static StackBehaviour Popi_popi8;
    
public static StackBehaviour Popi_popi_popi;
    
public static StackBehaviour Popi_popr4;
    
public static StackBehaviour Popi_popr8;
    
public static StackBehaviour Popref;
    
public static StackBehaviour Popref_pop1;
    
public static StackBehaviour Popref_popi;
    
public static StackBehaviour Popref_popi_popi;
    
public static StackBehaviour Popref_popi_popi8;
    
public static StackBehaviour Popref_popi_popr4;
    
public static StackBehaviour Popref_popi_popr8;
    
public static StackBehaviour Popref_popi_popref;
    
public static StackBehaviour PopAll;
    
public static StackBehaviour Push0;
    
public static StackBehaviour Push1;
    
public static StackBehaviour Push1_push1;
    
public static StackBehaviour Pushi;
    
public static StackBehaviour Pushi8;
    
public static StackBehaviour Pushr4;
    
public static StackBehaviour Pushr8;
    
public static StackBehaviour Pushref;
    
public static StackBehaviour Varpop;
    
public static StackBehaviour Varpush;
}
internal class Mono.Cecil.Cil.StateMachineScope : object {
    
internal InstructionOffset start;
    
internal InstructionOffset end;
    
public InstructionOffset Start { get; public set; }
    
public InstructionOffset End { get; public set; }
    internal StateMachineScope(int start, int end);
    public StateMachineScope(Instruction start, Instruction end);
    public InstructionOffset get_Start();
    public void set_Start(InstructionOffset value);
    public InstructionOffset get_End();
    public void set_End(InstructionOffset value);
}
internal class Mono.Cecil.Cil.StateMachineScopeDebugInformation : CustomDebugInformation {
    
internal Collection`1<StateMachineScope> scopes;
    
public static Guid KindIdentifier;
    
public Collection`1<StateMachineScope> Scopes { get; }
    
public CustomDebugInformationKind Kind { get; }
    private static StateMachineScopeDebugInformation();
    public Collection`1<StateMachineScope> get_Scopes();
    public virtual CustomDebugInformationKind get_Kind();
}
internal enum Mono.Cecil.Cil.SymbolKind : Enum {
    
public int value__;
    
public static SymbolKind NativePdb;
    
public static SymbolKind PortablePdb;
    
public static SymbolKind EmbeddedPortablePdb;
    
public static SymbolKind Mdb;
}
internal static class Mono.Cecil.Cil.SymbolProvider : object {
    private static AssemblyName GetSymbolAssemblyName(SymbolKind kind);
    private static Type GetSymbolType(SymbolKind kind, string fullname);
    public static ISymbolReaderProvider GetReaderProvider(SymbolKind kind);
    private static string GetSymbolTypeName(SymbolKind kind, string name);
    private static string GetSymbolNamespace(SymbolKind kind);
}
internal class Mono.Cecil.Cil.SymbolsNotFoundException : FileNotFoundException {
    public SymbolsNotFoundException(string message);
    private SymbolsNotFoundException(SerializationInfo info, StreamingContext context);
}
internal class Mono.Cecil.Cil.SymbolsNotMatchingException : InvalidOperationException {
    public SymbolsNotMatchingException(string message);
    private SymbolsNotMatchingException(SerializationInfo info, StreamingContext context);
}
[FlagsAttribute]
internal enum Mono.Cecil.Cil.VariableAttributes : Enum {
    
public ushort value__;
    
public static VariableAttributes None;
    
public static VariableAttributes DebuggerHidden;
}
internal class Mono.Cecil.Cil.VariableDebugInformation : DebugInformation {
    
private string name;
    
private ushort attributes;
    
internal VariableIndex index;
    
public int Index { get; }
    
public string Name { get; public set; }
    
public VariableAttributes Attributes { get; public set; }
    
public bool IsDebuggerHidden { get; public set; }
    internal VariableDebugInformation(int index, string name);
    public VariableDebugInformation(VariableDefinition variable, string name);
    public int get_Index();
    public string get_Name();
    public void set_Name(string value);
    public VariableAttributes get_Attributes();
    public void set_Attributes(VariableAttributes value);
    public bool get_IsDebuggerHidden();
    public void set_IsDebuggerHidden(bool value);
}
internal class Mono.Cecil.Cil.VariableDefinition : VariableReference {
    
public bool IsPinned { get; }
    public VariableDefinition(TypeReference variableType);
    public bool get_IsPinned();
    public virtual VariableDefinition Resolve();
}
internal class Mono.Cecil.Cil.VariableDefinitionCollection : Collection`1<VariableDefinition> {
    
private MethodDefinition method;
    internal VariableDefinitionCollection(MethodDefinition method);
    internal VariableDefinitionCollection(MethodDefinition method, int capacity);
    protected virtual void OnAdd(VariableDefinition item, int index);
    protected virtual void OnInsert(VariableDefinition item, int index);
    protected virtual void OnSet(VariableDefinition item, int index);
    protected virtual void OnRemove(VariableDefinition item, int index);
    private void UpdateVariableIndices(int startIndex, int offset, VariableDefinition variableToRemove);
}
internal class Mono.Cecil.Cil.VariableIndex : ValueType {
    
private VariableDefinition variable;
    
private Nullable`1<int> index;
    
public int Index { get; }
    
internal bool IsResolved { get; }
    
internal VariableDefinition ResolvedVariable { get; }
    public VariableIndex(VariableDefinition variable);
    public VariableIndex(int index);
    public int get_Index();
    internal bool get_IsResolved();
    internal VariableDefinition get_ResolvedVariable();
}
internal abstract class Mono.Cecil.Cil.VariableReference : object {
    
internal int index;
    
protected TypeReference variable_type;
    
public TypeReference VariableType { get; public set; }
    
public int Index { get; }
    internal VariableReference(TypeReference variable_type);
    public TypeReference get_VariableType();
    public void set_VariableType(TypeReference value);
    public int get_Index();
    public abstract virtual VariableDefinition Resolve();
    public virtual string ToString();
}
internal class Mono.Cecil.ClassLayoutTable : SortedTable`1<Row`3<ushort, UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
    public virtual int Compare(Row`3<ushort, UInt32, UInt32> x, Row`3<ushort, UInt32, UInt32> y);
}
internal class Mono.Cecil.ConstantTable : SortedTable`1<Row`3<ElementType, UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
    public virtual int Compare(Row`3<ElementType, UInt32, UInt32> x, Row`3<ElementType, UInt32, UInt32> y);
}
internal static class Mono.Cecil.CryptoService : object {
    public static Byte[] GetPublicKey(WriterParameters parameters);
    public static void StrongName(Stream stream, ImageWriter writer, WriterParameters parameters);
    private static void PatchStrongName(Stream stream, int strong_name_pointer, Byte[] strong_name);
    private static Byte[] CreateStrongName(WriterParameters parameters, Byte[] hash);
    private static Byte[] HashStream(Stream stream, ImageWriter writer, Int32& strong_name_pointer);
    public static void CopyStreamChunk(Stream stream, Stream dest_stream, Byte[] buffer, int length);
    public static Byte[] ComputeHash(string file);
    public static Byte[] ComputeHash(Stream stream);
    public static Byte[] ComputeHash(ByteBuffer[] buffers);
    public static Guid ComputeGuid(Byte[] hash);
}
[DebuggerDisplayAttribute("{AttributeType}")]
internal class Mono.Cecil.CustomAttribute : object {
    
internal CustomAttributeValueProjection projection;
    
internal UInt32 signature;
    
internal bool resolved;
    
private MethodReference constructor;
    
private Byte[] blob;
    
internal Collection`1<CustomAttributeArgument> arguments;
    
internal Collection`1<CustomAttributeNamedArgument> fields;
    
internal Collection`1<CustomAttributeNamedArgument> properties;
    
public MethodReference Constructor { get; public set; }
    
public TypeReference AttributeType { get; }
    
public bool IsResolved { get; }
    
public bool HasConstructorArguments { get; }
    
public Collection`1<CustomAttributeArgument> ConstructorArguments { get; }
    
public bool HasFields { get; }
    
public Collection`1<CustomAttributeNamedArgument> Fields { get; }
    
public bool HasProperties { get; }
    
public Collection`1<CustomAttributeNamedArgument> Properties { get; }
    
internal bool HasImage { get; }
    
internal ModuleDefinition Module { get; }
    internal CustomAttribute(UInt32 signature, MethodReference constructor);
    public CustomAttribute(MethodReference constructor);
    public CustomAttribute(MethodReference constructor, Byte[] blob);
    public MethodReference get_Constructor();
    public void set_Constructor(MethodReference value);
    public sealed virtual TypeReference get_AttributeType();
    public bool get_IsResolved();
    public sealed virtual bool get_HasConstructorArguments();
    public sealed virtual Collection`1<CustomAttributeArgument> get_ConstructorArguments();
    public sealed virtual bool get_HasFields();
    public sealed virtual Collection`1<CustomAttributeNamedArgument> get_Fields();
    public sealed virtual bool get_HasProperties();
    public sealed virtual Collection`1<CustomAttributeNamedArgument> get_Properties();
    internal bool get_HasImage();
    internal ModuleDefinition get_Module();
    public Byte[] GetBlob();
    private void Resolve();
    [CompilerGeneratedAttribute]
private void <Resolve>b__35_0(CustomAttribute attribute, MetadataReader reader);
}
internal class Mono.Cecil.CustomAttributeArgument : ValueType {
    
private TypeReference type;
    
private object value;
    
public TypeReference Type { get; }
    
public object Value { get; }
    public CustomAttributeArgument(TypeReference type, object value);
    public TypeReference get_Type();
    public object get_Value();
}
internal class Mono.Cecil.CustomAttributeNamedArgument : ValueType {
    
private string name;
    
private CustomAttributeArgument argument;
    
public string Name { get; }
    
public CustomAttributeArgument Argument { get; }
    public CustomAttributeNamedArgument(string name, CustomAttributeArgument argument);
    public string get_Name();
    public CustomAttributeArgument get_Argument();
}
internal class Mono.Cecil.CustomAttributeTable : SortedTable`1<Row`3<UInt32, UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
    public virtual int Compare(Row`3<UInt32, UInt32, UInt32> x, Row`3<UInt32, UInt32, UInt32> y);
}
internal class Mono.Cecil.CustomAttributeValueProjection : object {
    
public AttributeTargets Targets;
    
public CustomAttributeValueTreatment Treatment;
    public CustomAttributeValueProjection(AttributeTargets targets, CustomAttributeValueTreatment treatment);
}
internal enum Mono.Cecil.CustomAttributeValueTreatment : Enum {
    
public int value__;
    
public static CustomAttributeValueTreatment None;
    
public static CustomAttributeValueTreatment AllowSingle;
    
public static CustomAttributeValueTreatment AllowMultiple;
    
public static CustomAttributeValueTreatment VersionAttribute;
    
public static CustomAttributeValueTreatment DeprecatedAttribute;
}
internal class Mono.Cecil.CustomDebugInformationTable : SortedTable`1<Row`3<UInt32, UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
    public virtual int Compare(Row`3<UInt32, UInt32, UInt32> x, Row`3<UInt32, UInt32, UInt32> y);
}
internal class Mono.Cecil.CustomMarshalInfo : MarshalInfo {
    
internal Guid guid;
    
internal string unmanaged_type;
    
internal TypeReference managed_type;
    
internal string cookie;
    
public Guid Guid { get; public set; }
    
public string UnmanagedType { get; public set; }
    
public TypeReference ManagedType { get; public set; }
    
public string Cookie { get; public set; }
    public Guid get_Guid();
    public void set_Guid(Guid value);
    public string get_UnmanagedType();
    public void set_UnmanagedType(string value);
    public TypeReference get_ManagedType();
    public void set_ManagedType(TypeReference value);
    public string get_Cookie();
    public void set_Cookie(string value);
}
internal class Mono.Cecil.DeclSecurityTable : SortedTable`1<Row`3<SecurityAction, UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
    public virtual int Compare(Row`3<SecurityAction, UInt32, UInt32> x, Row`3<SecurityAction, UInt32, UInt32> y);
}
internal class Mono.Cecil.DefaultAssemblyResolver : BaseAssemblyResolver {
    
private IDictionary`2<string, AssemblyDefinition> cache;
    public virtual AssemblyDefinition Resolve(AssemblyNameReference name);
    protected void RegisterAssembly(AssemblyDefinition assembly);
    protected virtual void Dispose(bool disposing);
}
internal class Mono.Cecil.DefaultMetadataImporter : object {
    
protected ModuleDefinition module;
    public DefaultMetadataImporter(ModuleDefinition module);
    private TypeReference ImportType(TypeReference type, ImportGenericContext context);
    protected virtual IMetadataScope ImportScope(TypeReference type);
    protected IMetadataScope ImportScope(IMetadataScope scope);
    public virtual AssemblyNameReference ImportReference(AssemblyNameReference name);
    private static void ImportGenericParameters(IGenericParameterProvider imported, IGenericParameterProvider original);
    private TypeReference ImportTypeSpecification(TypeReference type, ImportGenericContext context);
    private FieldReference ImportField(FieldReference field, ImportGenericContext context);
    private MethodReference ImportMethod(MethodReference method, ImportGenericContext context);
    private MethodSpecification ImportMethodSpecification(MethodReference method, ImportGenericContext context);
    public virtual TypeReference ImportReference(TypeReference type, IGenericParameterProvider context);
    public virtual FieldReference ImportReference(FieldReference field, IGenericParameterProvider context);
    public virtual MethodReference ImportReference(MethodReference method, IGenericParameterProvider context);
}
internal class Mono.Cecil.DefaultReflectionImporter : object {
    
protected ModuleDefinition module;
    
private static Dictionary`2<Type, ElementType> type_etype_mapping;
    public DefaultReflectionImporter(ModuleDefinition module);
    private static DefaultReflectionImporter();
    private TypeReference ImportType(Type type, ImportGenericContext context);
    private TypeReference ImportType(Type type, ImportGenericContext context, ImportGenericKind import_kind);
    protected virtual IMetadataScope ImportScope(Type type);
    private static bool ImportOpenGenericType(Type type, ImportGenericKind import_kind);
    private static bool ImportOpenGenericMethod(MethodBase method, ImportGenericKind import_kind);
    private static bool IsNestedType(Type type);
    private TypeReference ImportTypeSpecification(Type type, ImportGenericContext context);
    private static TypeReference ImportGenericParameter(Type type, ImportGenericContext context);
    private static string NormalizeMethodName(MethodBase method);
    private static string NormalizeTypeFullName(Type type);
    private TypeReference ImportGenericInstance(Type type, ImportGenericContext context);
    private static bool IsTypeSpecification(Type type);
    private static bool IsGenericInstance(Type type);
    private static ElementType ImportElementType(Type type);
    protected AssemblyNameReference ImportScope(Assembly assembly);
    public virtual AssemblyNameReference ImportReference(AssemblyName name);
    private bool TryGetAssemblyNameReference(AssemblyName name, AssemblyNameReference& assembly_reference);
    private FieldReference ImportField(FieldInfo field, ImportGenericContext context);
    private static FieldInfo ResolveFieldDefinition(FieldInfo field);
    private static MethodBase ResolveMethodDefinition(MethodBase method);
    private MethodReference ImportMethod(MethodBase method, ImportGenericContext context, ImportGenericKind import_kind);
    private static void ImportGenericParameters(IGenericParameterProvider provider, Type[] arguments);
    private static bool IsMethodSpecification(MethodBase method);
    private MethodReference ImportMethodSpecification(MethodBase method, ImportGenericContext context);
    private static bool HasCallingConvention(MethodBase method, CallingConventions conventions);
    public virtual TypeReference ImportReference(Type type, IGenericParameterProvider context);
    public virtual FieldReference ImportReference(FieldInfo field, IGenericParameterProvider context);
    public virtual MethodReference ImportReference(MethodBase method, IGenericParameterProvider context);
}
internal class Mono.Cecil.DeferredModuleReader : ModuleReader {
    public DeferredModuleReader(Image image);
    protected virtual void ReadModule();
    public virtual void ReadSymbols(ModuleDefinition module);
    [CompilerGeneratedAttribute]
private void <ReadModule>b__1_0(ModuleDefinition _, MetadataReader reader);
}
internal class Mono.Cecil.DocumentTable : MetadataTable`1<Row`4<UInt32, UInt32, UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
}
internal class Mono.Cecil.EmbeddedResource : Resource {
    
private MetadataReader reader;
    
private Nullable`1<UInt32> offset;
    
private Byte[] data;
    
private Stream stream;
    
public ResourceType ResourceType { get; }
    public EmbeddedResource(string name, ManifestResourceAttributes attributes, Byte[] data);
    public EmbeddedResource(string name, ManifestResourceAttributes attributes, Stream stream);
    internal EmbeddedResource(string name, ManifestResourceAttributes attributes, UInt32 offset, MetadataReader reader);
    public virtual ResourceType get_ResourceType();
    public Stream GetResourceStream();
    public Byte[] GetResourceData();
    private static Byte[] ReadStream(Stream stream);
}
[FlagsAttribute]
internal enum Mono.Cecil.EventAttributes : Enum {
    
public ushort value__;
    
public static EventAttributes None;
    
public static EventAttributes SpecialName;
    
public static EventAttributes RTSpecialName;
}
internal class Mono.Cecil.EventDefinition : EventReference {
    
private ushort attributes;
    
private Collection`1<CustomAttribute> custom_attributes;
    
internal MethodDefinition add_method;
    
internal MethodDefinition invoke_method;
    
internal MethodDefinition remove_method;
    
internal Collection`1<MethodDefinition> other_methods;
    
public EventAttributes Attributes { get; public set; }
    
public MethodDefinition AddMethod { get; public set; }
    
public MethodDefinition InvokeMethod { get; public set; }
    
public MethodDefinition RemoveMethod { get; public set; }
    
public bool HasOtherMethods { get; }
    
public Collection`1<MethodDefinition> OtherMethods { get; }
    
public bool HasCustomAttributes { get; }
    
public Collection`1<CustomAttribute> CustomAttributes { get; }
    
public bool IsSpecialName { get; public set; }
    
public bool IsRuntimeSpecialName { get; public set; }
    
public TypeDefinition DeclaringType { get; public set; }
    
public bool IsDefinition { get; }
    public EventDefinition(string name, EventAttributes attributes, TypeReference eventType);
    public EventAttributes get_Attributes();
    public void set_Attributes(EventAttributes value);
    public MethodDefinition get_AddMethod();
    public void set_AddMethod(MethodDefinition value);
    public MethodDefinition get_InvokeMethod();
    public void set_InvokeMethod(MethodDefinition value);
    public MethodDefinition get_RemoveMethod();
    public void set_RemoveMethod(MethodDefinition value);
    public bool get_HasOtherMethods();
    public Collection`1<MethodDefinition> get_OtherMethods();
    public sealed virtual bool get_HasCustomAttributes();
    public sealed virtual Collection`1<CustomAttribute> get_CustomAttributes();
    public sealed virtual bool get_IsSpecialName();
    public sealed virtual void set_IsSpecialName(bool value);
    public sealed virtual bool get_IsRuntimeSpecialName();
    public sealed virtual void set_IsRuntimeSpecialName(bool value);
    public sealed virtual TypeDefinition get_DeclaringType();
    public sealed virtual void set_DeclaringType(TypeDefinition value);
    public virtual bool get_IsDefinition();
    private void InitializeMethods();
    public virtual EventDefinition Resolve();
}
internal class Mono.Cecil.EventMapTable : MetadataTable`1<Row`2<UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
}
internal abstract class Mono.Cecil.EventReference : MemberReference {
    
private TypeReference event_type;
    
public TypeReference EventType { get; public set; }
    
public string FullName { get; }
    protected EventReference(string name, TypeReference eventType);
    public TypeReference get_EventType();
    public void set_EventType(TypeReference value);
    public virtual string get_FullName();
    protected virtual IMemberDefinition ResolveDefinition();
    public abstract virtual EventDefinition Resolve();
}
internal class Mono.Cecil.EventTable : MetadataTable`1<Row`3<EventAttributes, UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
}
internal class Mono.Cecil.ExportedType : object {
    
private string namespace;
    
private string name;
    
private UInt32 attributes;
    
private IMetadataScope scope;
    
private ModuleDefinition module;
    
private int identifier;
    
private ExportedType declaring_type;
    
internal MetadataToken token;
    
public string Namespace { get; public set; }
    
public string Name { get; public set; }
    
public TypeAttributes Attributes { get; public set; }
    
public IMetadataScope Scope { get; public set; }
    
public ExportedType DeclaringType { get; public set; }
    
public MetadataToken MetadataToken { get; public set; }
    
public int Identifier { get; public set; }
    
public bool IsNotPublic { get; public set; }
    
public bool IsPublic { get; public set; }
    
public bool IsNestedPublic { get; public set; }
    
public bool IsNestedPrivate { get; public set; }
    
public bool IsNestedFamily { get; public set; }
    
public bool IsNestedAssembly { get; public set; }
    
public bool IsNestedFamilyAndAssembly { get; public set; }
    
public bool IsNestedFamilyOrAssembly { get; public set; }
    
public bool IsAutoLayout { get; public set; }
    
public bool IsSequentialLayout { get; public set; }
    
public bool IsExplicitLayout { get; public set; }
    
public bool IsClass { get; public set; }
    
public bool IsInterface { get; public set; }
    
public bool IsAbstract { get; public set; }
    
public bool IsSealed { get; public set; }
    
public bool IsSpecialName { get; public set; }
    
public bool IsImport { get; public set; }
    
public bool IsSerializable { get; public set; }
    
public bool IsAnsiClass { get; public set; }
    
public bool IsUnicodeClass { get; public set; }
    
public bool IsAutoClass { get; public set; }
    
public bool IsBeforeFieldInit { get; public set; }
    
public bool IsRuntimeSpecialName { get; public set; }
    
public bool HasSecurity { get; public set; }
    
public bool IsForwarder { get; public set; }
    
public string FullName { get; }
    public ExportedType(string namespace, string name, ModuleDefinition module, IMetadataScope scope);
    public string get_Namespace();
    public void set_Namespace(string value);
    public string get_Name();
    public void set_Name(string value);
    public TypeAttributes get_Attributes();
    public void set_Attributes(TypeAttributes value);
    public IMetadataScope get_Scope();
    public void set_Scope(IMetadataScope value);
    public ExportedType get_DeclaringType();
    public void set_DeclaringType(ExportedType value);
    public sealed virtual MetadataToken get_MetadataToken();
    public sealed virtual void set_MetadataToken(MetadataToken value);
    public int get_Identifier();
    public void set_Identifier(int value);
    public bool get_IsNotPublic();
    public void set_IsNotPublic(bool value);
    public bool get_IsPublic();
    public void set_IsPublic(bool value);
    public bool get_IsNestedPublic();
    public void set_IsNestedPublic(bool value);
    public bool get_IsNestedPrivate();
    public void set_IsNestedPrivate(bool value);
    public bool get_IsNestedFamily();
    public void set_IsNestedFamily(bool value);
    public bool get_IsNestedAssembly();
    public void set_IsNestedAssembly(bool value);
    public bool get_IsNestedFamilyAndAssembly();
    public void set_IsNestedFamilyAndAssembly(bool value);
    public bool get_IsNestedFamilyOrAssembly();
    public void set_IsNestedFamilyOrAssembly(bool value);
    public bool get_IsAutoLayout();
    public void set_IsAutoLayout(bool value);
    public bool get_IsSequentialLayout();
    public void set_IsSequentialLayout(bool value);
    public bool get_IsExplicitLayout();
    public void set_IsExplicitLayout(bool value);
    public bool get_IsClass();
    public void set_IsClass(bool value);
    public bool get_IsInterface();
    public void set_IsInterface(bool value);
    public bool get_IsAbstract();
    public void set_IsAbstract(bool value);
    public bool get_IsSealed();
    public void set_IsSealed(bool value);
    public bool get_IsSpecialName();
    public void set_IsSpecialName(bool value);
    public bool get_IsImport();
    public void set_IsImport(bool value);
    public bool get_IsSerializable();
    public void set_IsSerializable(bool value);
    public bool get_IsAnsiClass();
    public void set_IsAnsiClass(bool value);
    public bool get_IsUnicodeClass();
    public void set_IsUnicodeClass(bool value);
    public bool get_IsAutoClass();
    public void set_IsAutoClass(bool value);
    public bool get_IsBeforeFieldInit();
    public void set_IsBeforeFieldInit(bool value);
    public bool get_IsRuntimeSpecialName();
    public void set_IsRuntimeSpecialName(bool value);
    public bool get_HasSecurity();
    public void set_HasSecurity(bool value);
    public bool get_IsForwarder();
    public void set_IsForwarder(bool value);
    public string get_FullName();
    public virtual string ToString();
    public TypeDefinition Resolve();
    internal TypeReference CreateReference();
}
internal class Mono.Cecil.ExportedTypeTable : MetadataTable`1<Row`5<TypeAttributes, UInt32, UInt32, UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
}
[FlagsAttribute]
internal enum Mono.Cecil.FieldAttributes : Enum {
    
public ushort value__;
    
public static FieldAttributes FieldAccessMask;
    
public static FieldAttributes CompilerControlled;
    
public static FieldAttributes Private;
    
public static FieldAttributes FamANDAssem;
    
public static FieldAttributes Assembly;
    
public static FieldAttributes Family;
    
public static FieldAttributes FamORAssem;
    
public static FieldAttributes Public;
    
public static FieldAttributes Static;
    
public static FieldAttributes InitOnly;
    
public static FieldAttributes Literal;
    
public static FieldAttributes NotSerialized;
    
public static FieldAttributes SpecialName;
    
public static FieldAttributes PInvokeImpl;
    
public static FieldAttributes RTSpecialName;
    
public static FieldAttributes HasFieldMarshal;
    
public static FieldAttributes HasDefault;
    
public static FieldAttributes HasFieldRVA;
}
internal class Mono.Cecil.FieldDefinition : FieldReference {
    
private ushort attributes;
    
private Collection`1<CustomAttribute> custom_attributes;
    
private int offset;
    
internal int rva;
    
private Byte[] initial_value;
    
private object constant;
    
private MarshalInfo marshal_info;
    
public bool HasLayoutInfo { get; }
    
public int Offset { get; public set; }
    
internal FieldDefinitionProjection WindowsRuntimeProjection { get; internal set; }
    
public int RVA { get; }
    
public Byte[] InitialValue { get; public set; }
    
public FieldAttributes Attributes { get; public set; }
    
public bool HasConstant { get; public set; }
    
public object Constant { get; public set; }
    
public bool HasCustomAttributes { get; }
    
public Collection`1<CustomAttribute> CustomAttributes { get; }
    
public bool HasMarshalInfo { get; }
    
public MarshalInfo MarshalInfo { get; public set; }
    
public bool IsCompilerControlled { get; public set; }
    
public bool IsPrivate { get; public set; }
    
public bool IsFamilyAndAssembly { get; public set; }
    
public bool IsAssembly { get; public set; }
    
public bool IsFamily { get; public set; }
    
public bool IsFamilyOrAssembly { get; public set; }
    
public bool IsPublic { get; public set; }
    
public bool IsStatic { get; public set; }
    
public bool IsInitOnly { get; public set; }
    
public bool IsLiteral { get; public set; }
    
public bool IsNotSerialized { get; public set; }
    
public bool IsSpecialName { get; public set; }
    
public bool IsPInvokeImpl { get; public set; }
    
public bool IsRuntimeSpecialName { get; public set; }
    
public bool HasDefault { get; public set; }
    
public bool HasFieldRVA { get; public set; }
    
public bool IsDefinition { get; }
    
public TypeDefinition DeclaringType { get; public set; }
    public FieldDefinition(string name, FieldAttributes attributes, TypeReference fieldType);
    private void ResolveLayout();
    public bool get_HasLayoutInfo();
    public int get_Offset();
    public void set_Offset(int value);
    internal FieldDefinitionProjection get_WindowsRuntimeProjection();
    internal void set_WindowsRuntimeProjection(FieldDefinitionProjection value);
    private void ResolveRVA();
    public int get_RVA();
    public Byte[] get_InitialValue();
    public void set_InitialValue(Byte[] value);
    public FieldAttributes get_Attributes();
    public void set_Attributes(FieldAttributes value);
    public sealed virtual bool get_HasConstant();
    public sealed virtual void set_HasConstant(bool value);
    public sealed virtual object get_Constant();
    public sealed virtual void set_Constant(object value);
    public sealed virtual bool get_HasCustomAttributes();
    public sealed virtual Collection`1<CustomAttribute> get_CustomAttributes();
    public sealed virtual bool get_HasMarshalInfo();
    public sealed virtual MarshalInfo get_MarshalInfo();
    public sealed virtual void set_MarshalInfo(MarshalInfo value);
    public bool get_IsCompilerControlled();
    public void set_IsCompilerControlled(bool value);
    public bool get_IsPrivate();
    public void set_IsPrivate(bool value);
    public bool get_IsFamilyAndAssembly();
    public void set_IsFamilyAndAssembly(bool value);
    public bool get_IsAssembly();
    public void set_IsAssembly(bool value);
    public bool get_IsFamily();
    public void set_IsFamily(bool value);
    public bool get_IsFamilyOrAssembly();
    public void set_IsFamilyOrAssembly(bool value);
    public bool get_IsPublic();
    public void set_IsPublic(bool value);
    public bool get_IsStatic();
    public void set_IsStatic(bool value);
    public bool get_IsInitOnly();
    public void set_IsInitOnly(bool value);
    public bool get_IsLiteral();
    public void set_IsLiteral(bool value);
    public bool get_IsNotSerialized();
    public void set_IsNotSerialized(bool value);
    public sealed virtual bool get_IsSpecialName();
    public sealed virtual void set_IsSpecialName(bool value);
    public bool get_IsPInvokeImpl();
    public void set_IsPInvokeImpl(bool value);
    public sealed virtual bool get_IsRuntimeSpecialName();
    public sealed virtual void set_IsRuntimeSpecialName(bool value);
    public bool get_HasDefault();
    public void set_HasDefault(bool value);
    public bool get_HasFieldRVA();
    public void set_HasFieldRVA(bool value);
    public virtual bool get_IsDefinition();
    public sealed virtual TypeDefinition get_DeclaringType();
    public sealed virtual void set_DeclaringType(TypeDefinition value);
    public virtual FieldDefinition Resolve();
}
internal class Mono.Cecil.FieldDefinitionProjection : object {
    
public FieldAttributes Attributes;
    
public FieldDefinitionTreatment Treatment;
    public FieldDefinitionProjection(FieldDefinition field, FieldDefinitionTreatment treatment);
}
internal enum Mono.Cecil.FieldDefinitionTreatment : Enum {
    
public int value__;
    
public static FieldDefinitionTreatment None;
    
public static FieldDefinitionTreatment Public;
}
internal class Mono.Cecil.FieldLayoutTable : SortedTable`1<Row`2<UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
    public virtual int Compare(Row`2<UInt32, UInt32> x, Row`2<UInt32, UInt32> y);
}
internal class Mono.Cecil.FieldMarshalTable : SortedTable`1<Row`2<UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
    public virtual int Compare(Row`2<UInt32, UInt32> x, Row`2<UInt32, UInt32> y);
}
internal class Mono.Cecil.FieldReference : MemberReference {
    
private TypeReference field_type;
    
public TypeReference FieldType { get; public set; }
    
public string FullName { get; }
    
public bool ContainsGenericParameter { get; }
    public FieldReference(string name, TypeReference fieldType);
    public FieldReference(string name, TypeReference fieldType, TypeReference declaringType);
    public TypeReference get_FieldType();
    public void set_FieldType(TypeReference value);
    public virtual string get_FullName();
    public virtual bool get_ContainsGenericParameter();
    protected virtual IMemberDefinition ResolveDefinition();
    public virtual FieldDefinition Resolve();
}
internal class Mono.Cecil.FieldRVATable : SortedTable`1<Row`2<UInt32, UInt32>> {
    
internal int position;
    public virtual void Write(TableHeapBuffer buffer);
    public virtual int Compare(Row`2<UInt32, UInt32> x, Row`2<UInt32, UInt32> y);
}
internal class Mono.Cecil.FieldTable : MetadataTable`1<Row`3<FieldAttributes, UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
}
internal enum Mono.Cecil.FileAttributes : Enum {
    
public UInt32 value__;
    
public static FileAttributes ContainsMetaData;
    
public static FileAttributes ContainsNoMetaData;
}
internal class Mono.Cecil.FileTable : MetadataTable`1<Row`3<FileAttributes, UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
}
internal class Mono.Cecil.FixedArrayMarshalInfo : MarshalInfo {
    
internal NativeType element_type;
    
internal int size;
    
public NativeType ElementType { get; public set; }
    
public int Size { get; public set; }
    public NativeType get_ElementType();
    public void set_ElementType(NativeType value);
    public int get_Size();
    public void set_Size(int value);
}
internal class Mono.Cecil.FixedSysStringMarshalInfo : MarshalInfo {
    
internal int size;
    
public int Size { get; public set; }
    public int get_Size();
    public void set_Size(int value);
}
internal class Mono.Cecil.FunctionPointerType : TypeSpecification {
    
private MethodReference function;
    
public bool HasThis { get; public set; }
    
public bool ExplicitThis { get; public set; }
    
public MethodCallingConvention CallingConvention { get; public set; }
    
public bool HasParameters { get; }
    
public Collection`1<ParameterDefinition> Parameters { get; }
    
public TypeReference ReturnType { get; public set; }
    
public MethodReturnType MethodReturnType { get; }
    
public string Name { get; public set; }
    
public string Namespace { get; public set; }
    
public ModuleDefinition Module { get; }
    
public IMetadataScope Scope { get; public set; }
    
public bool IsFunctionPointer { get; }
    
public bool ContainsGenericParameter { get; }
    
public string FullName { get; }
    public sealed virtual bool get_HasThis();
    public sealed virtual void set_HasThis(bool value);
    public sealed virtual bool get_ExplicitThis();
    public sealed virtual void set_ExplicitThis(bool value);
    public sealed virtual MethodCallingConvention get_CallingConvention();
    public sealed virtual void set_CallingConvention(MethodCallingConvention value);
    public sealed virtual bool get_HasParameters();
    public sealed virtual Collection`1<ParameterDefinition> get_Parameters();
    public sealed virtual TypeReference get_ReturnType();
    public sealed virtual void set_ReturnType(TypeReference value);
    public sealed virtual MethodReturnType get_MethodReturnType();
    public virtual string get_Name();
    public virtual void set_Name(string value);
    public virtual string get_Namespace();
    public virtual void set_Namespace(string value);
    public virtual ModuleDefinition get_Module();
    public virtual IMetadataScope get_Scope();
    public virtual void set_Scope(IMetadataScope value);
    public virtual bool get_IsFunctionPointer();
    public virtual bool get_ContainsGenericParameter();
    public virtual string get_FullName();
    public virtual TypeDefinition Resolve();
    public virtual TypeReference GetElementType();
}
internal class Mono.Cecil.GenericInstanceMethod : MethodSpecification {
    
private Collection`1<TypeReference> arguments;
    
public bool HasGenericArguments { get; }
    
public Collection`1<TypeReference> GenericArguments { get; }
    
public bool IsGenericInstance { get; }
    
private IGenericParameterProvider Mono.Cecil.IGenericContext.Method { get; }
    
private IGenericParameterProvider Mono.Cecil.IGenericContext.Type { get; }
    
public bool ContainsGenericParameter { get; }
    
public string FullName { get; }
    public GenericInstanceMethod(MethodReference method);
    internal GenericInstanceMethod(MethodReference method, int arity);
    public sealed virtual bool get_HasGenericArguments();
    public sealed virtual Collection`1<TypeReference> get_GenericArguments();
    public virtual bool get_IsGenericInstance();
    private sealed virtual override IGenericParameterProvider Mono.Cecil.IGenericContext.get_Method();
    private sealed virtual override IGenericParameterProvider Mono.Cecil.IGenericContext.get_Type();
    public virtual bool get_ContainsGenericParameter();
    public virtual string get_FullName();
}
internal class Mono.Cecil.GenericInstanceType : TypeSpecification {
    
private Collection`1<TypeReference> arguments;
    
public bool HasGenericArguments { get; }
    
public Collection`1<TypeReference> GenericArguments { get; }
    
public TypeReference DeclaringType { get; public set; }
    
public string FullName { get; }
    
public bool IsGenericInstance { get; }
    
public bool ContainsGenericParameter { get; }
    
private IGenericParameterProvider Mono.Cecil.IGenericContext.Type { get; }
    public GenericInstanceType(TypeReference type);
    internal GenericInstanceType(TypeReference type, int arity);
    public sealed virtual bool get_HasGenericArguments();
    public sealed virtual Collection`1<TypeReference> get_GenericArguments();
    public virtual TypeReference get_DeclaringType();
    public virtual void set_DeclaringType(TypeReference value);
    public virtual string get_FullName();
    public virtual bool get_IsGenericInstance();
    public virtual bool get_ContainsGenericParameter();
    private sealed virtual override IGenericParameterProvider Mono.Cecil.IGenericContext.get_Type();
}
internal class Mono.Cecil.GenericParamConstraintTable : MetadataTable`1<Row`2<UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
}
internal class Mono.Cecil.GenericParameter : TypeReference {
    
internal int position;
    
internal GenericParameterType type;
    
internal IGenericParameterProvider owner;
    
private ushort attributes;
    
private GenericParameterConstraintCollection constraints;
    
private Collection`1<CustomAttribute> custom_attributes;
    
public GenericParameterAttributes Attributes { get; public set; }
    
public int Position { get; }
    
public GenericParameterType Type { get; }
    
public IGenericParameterProvider Owner { get; }
    
public bool HasConstraints { get; }
    
public Collection`1<GenericParameterConstraint> Constraints { get; }
    
public bool HasCustomAttributes { get; }
    
public Collection`1<CustomAttribute> CustomAttributes { get; }
    
public IMetadataScope Scope { get; public set; }
    
public TypeReference DeclaringType { get; public set; }
    
public MethodReference DeclaringMethod { get; }
    
public ModuleDefinition Module { get; }
    
public string Name { get; }
    
public string Namespace { get; public set; }
    
public string FullName { get; }
    
public bool IsGenericParameter { get; }
    
public bool ContainsGenericParameter { get; }
    
public MetadataType MetadataType { get; }
    
public bool IsNonVariant { get; public set; }
    
public bool IsCovariant { get; public set; }
    
public bool IsContravariant { get; public set; }
    
public bool HasReferenceTypeConstraint { get; public set; }
    
public bool HasNotNullableValueTypeConstraint { get; public set; }
    
public bool HasDefaultConstructorConstraint { get; public set; }
    public GenericParameter(IGenericParameterProvider owner);
    public GenericParameter(string name, IGenericParameterProvider owner);
    internal GenericParameter(int position, GenericParameterType type, ModuleDefinition module);
    public GenericParameterAttributes get_Attributes();
    public void set_Attributes(GenericParameterAttributes value);
    public int get_Position();
    public GenericParameterType get_Type();
    public IGenericParameterProvider get_Owner();
    public bool get_HasConstraints();
    public Collection`1<GenericParameterConstraint> get_Constraints();
    public sealed virtual bool get_HasCustomAttributes();
    public sealed virtual Collection`1<CustomAttribute> get_CustomAttributes();
    public virtual IMetadataScope get_Scope();
    public virtual void set_Scope(IMetadataScope value);
    public virtual TypeReference get_DeclaringType();
    public virtual void set_DeclaringType(TypeReference value);
    public MethodReference get_DeclaringMethod();
    public virtual ModuleDefinition get_Module();
    public virtual string get_Name();
    public virtual string get_Namespace();
    public virtual void set_Namespace(string value);
    public virtual string get_FullName();
    public virtual bool get_IsGenericParameter();
    public virtual bool get_ContainsGenericParameter();
    public virtual MetadataType get_MetadataType();
    public bool get_IsNonVariant();
    public void set_IsNonVariant(bool value);
    public bool get_IsCovariant();
    public void set_IsCovariant(bool value);
    public bool get_IsContravariant();
    public void set_IsContravariant(bool value);
    public bool get_HasReferenceTypeConstraint();
    public void set_HasReferenceTypeConstraint(bool value);
    public bool get_HasNotNullableValueTypeConstraint();
    public void set_HasNotNullableValueTypeConstraint(bool value);
    public bool get_HasDefaultConstructorConstraint();
    public void set_HasDefaultConstructorConstraint(bool value);
    private static ElementType ConvertGenericParameterType(GenericParameterType type);
    public virtual TypeDefinition Resolve();
}
[FlagsAttribute]
internal enum Mono.Cecil.GenericParameterAttributes : Enum {
    
public ushort value__;
    
public static GenericParameterAttributes VarianceMask;
    
public static GenericParameterAttributes NonVariant;
    
public static GenericParameterAttributes Covariant;
    
public static GenericParameterAttributes Contravariant;
    
public static GenericParameterAttributes SpecialConstraintMask;
    
public static GenericParameterAttributes ReferenceTypeConstraint;
    
public static GenericParameterAttributes NotNullableValueTypeConstraint;
    
public static GenericParameterAttributes DefaultConstructorConstraint;
}
internal class Mono.Cecil.GenericParameterCollection : Collection`1<GenericParameter> {
    
private IGenericParameterProvider owner;
    internal GenericParameterCollection(IGenericParameterProvider owner);
    internal GenericParameterCollection(IGenericParameterProvider owner, int capacity);
    protected virtual void OnAdd(GenericParameter item, int index);
    protected virtual void OnInsert(GenericParameter item, int index);
    protected virtual void OnSet(GenericParameter item, int index);
    private void UpdateGenericParameter(GenericParameter item, int index);
    protected virtual void OnRemove(GenericParameter item, int index);
}
internal class Mono.Cecil.GenericParameterConstraint : object {
    
internal GenericParameter generic_parameter;
    
internal MetadataToken token;
    
private TypeReference constraint_type;
    
private Collection`1<CustomAttribute> custom_attributes;
    
public TypeReference ConstraintType { get; public set; }
    
public bool HasCustomAttributes { get; }
    
public Collection`1<CustomAttribute> CustomAttributes { get; }
    
public MetadataToken MetadataToken { get; public set; }
    internal GenericParameterConstraint(TypeReference constraintType, MetadataToken token);
    public GenericParameterConstraint(TypeReference constraintType);
    public TypeReference get_ConstraintType();
    public void set_ConstraintType(TypeReference value);
    public sealed virtual bool get_HasCustomAttributes();
    public sealed virtual Collection`1<CustomAttribute> get_CustomAttributes();
    public sealed virtual MetadataToken get_MetadataToken();
    public sealed virtual void set_MetadataToken(MetadataToken value);
}
internal class Mono.Cecil.GenericParameterConstraintCollection : Collection`1<GenericParameterConstraint> {
    
private GenericParameter generic_parameter;
    internal GenericParameterConstraintCollection(GenericParameter genericParameter);
    internal GenericParameterConstraintCollection(GenericParameter genericParameter, int length);
    protected virtual void OnAdd(GenericParameterConstraint item, int index);
    protected virtual void OnInsert(GenericParameterConstraint item, int index);
    protected virtual void OnSet(GenericParameterConstraint item, int index);
    protected virtual void OnRemove(GenericParameterConstraint item, int index);
}
internal class Mono.Cecil.GenericParameterResolver : object {
    internal static TypeReference ResolveReturnTypeIfNeeded(MethodReference methodReference);
    internal static TypeReference ResolveFieldTypeIfNeeded(FieldReference fieldReference);
    internal static TypeReference ResolveParameterTypeIfNeeded(MethodReference method, ParameterReference parameter);
    internal static TypeReference ResolveVariableTypeIfNeeded(MethodReference method, VariableReference variable);
    private static TypeReference ResolveIfNeeded(IGenericInstance genericInstanceMethod, IGenericInstance declaringGenericInstanceType, TypeReference parameterType);
    private static TypeReference ResolveIfNeeded(IGenericInstance genericInstanceMethod, IGenericInstance genericInstanceType, GenericParameter genericParameterElement);
    private static ArrayType ResolveIfNeeded(IGenericInstance genericInstanceMethod, IGenericInstance genericInstanceType, ArrayType arrayType);
    private static ByReferenceType ResolveIfNeeded(IGenericInstance genericInstanceMethod, IGenericInstance genericInstanceType, ByReferenceType byReferenceType);
    private static GenericInstanceType ResolveIfNeeded(IGenericInstance genericInstanceMethod, IGenericInstance genericInstanceType, GenericInstanceType genericInstanceType1);
    private static bool ContainsGenericParameters(TypeReference typeReference);
}
internal enum Mono.Cecil.GenericParameterType : Enum {
    
public int value__;
    
public static GenericParameterType Type;
    
public static GenericParameterType Method;
}
internal class Mono.Cecil.GenericParamTable : MetadataTable`1<Row`4<ushort, GenericParameterAttributes, UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
}
internal interface Mono.Cecil.IAssemblyResolver {
    public abstract virtual AssemblyDefinition Resolve(AssemblyNameReference name);
    public abstract virtual AssemblyDefinition Resolve(AssemblyNameReference name, ReaderParameters parameters);
}
internal interface Mono.Cecil.IConstantProvider {
    
public bool HasConstant { get; public set; }
    
public object Constant { get; public set; }
    public abstract virtual bool get_HasConstant();
    public abstract virtual void set_HasConstant(bool value);
    public abstract virtual object get_Constant();
    public abstract virtual void set_Constant(object value);
}
internal interface Mono.Cecil.ICustomAttribute {
    
public TypeReference AttributeType { get; }
    
public bool HasFields { get; }
    
public bool HasProperties { get; }
    
public bool HasConstructorArguments { get; }
    
public Collection`1<CustomAttributeNamedArgument> Fields { get; }
    
public Collection`1<CustomAttributeNamedArgument> Properties { get; }
    
public Collection`1<CustomAttributeArgument> ConstructorArguments { get; }
    public abstract virtual TypeReference get_AttributeType();
    public abstract virtual bool get_HasFields();
    public abstract virtual bool get_HasProperties();
    public abstract virtual bool get_HasConstructorArguments();
    public abstract virtual Collection`1<CustomAttributeNamedArgument> get_Fields();
    public abstract virtual Collection`1<CustomAttributeNamedArgument> get_Properties();
    public abstract virtual Collection`1<CustomAttributeArgument> get_ConstructorArguments();
}
internal interface Mono.Cecil.ICustomAttributeProvider {
    
public Collection`1<CustomAttribute> CustomAttributes { get; }
    
public bool HasCustomAttributes { get; }
    public abstract virtual Collection`1<CustomAttribute> get_CustomAttributes();
    public abstract virtual bool get_HasCustomAttributes();
}
internal interface Mono.Cecil.IGenericContext {
    
public bool IsDefinition { get; }
    
public IGenericParameterProvider Type { get; }
    
public IGenericParameterProvider Method { get; }
    public abstract virtual bool get_IsDefinition();
    public abstract virtual IGenericParameterProvider get_Type();
    public abstract virtual IGenericParameterProvider get_Method();
}
internal interface Mono.Cecil.IGenericInstance {
    
public bool HasGenericArguments { get; }
    
public Collection`1<TypeReference> GenericArguments { get; }
    public abstract virtual bool get_HasGenericArguments();
    public abstract virtual Collection`1<TypeReference> get_GenericArguments();
}
internal interface Mono.Cecil.IGenericParameterProvider {
    
public bool HasGenericParameters { get; }
    
public bool IsDefinition { get; }
    
public ModuleDefinition Module { get; }
    
public Collection`1<GenericParameter> GenericParameters { get; }
    
public GenericParameterType GenericParameterType { get; }
    public abstract virtual bool get_HasGenericParameters();
    public abstract virtual bool get_IsDefinition();
    public abstract virtual ModuleDefinition get_Module();
    public abstract virtual Collection`1<GenericParameter> get_GenericParameters();
    public abstract virtual GenericParameterType get_GenericParameterType();
}
internal interface Mono.Cecil.IMarshalInfoProvider {
    
public bool HasMarshalInfo { get; }
    
public MarshalInfo MarshalInfo { get; public set; }
    public abstract virtual bool get_HasMarshalInfo();
    public abstract virtual MarshalInfo get_MarshalInfo();
    public abstract virtual void set_MarshalInfo(MarshalInfo value);
}
internal interface Mono.Cecil.IMemberDefinition {
    
public string Name { get; public set; }
    
public string FullName { get; }
    
public bool IsSpecialName { get; public set; }
    
public bool IsRuntimeSpecialName { get; public set; }
    
public TypeDefinition DeclaringType { get; public set; }
    public abstract virtual string get_Name();
    public abstract virtual void set_Name(string value);
    public abstract virtual string get_FullName();
    public abstract virtual bool get_IsSpecialName();
    public abstract virtual void set_IsSpecialName(bool value);
    public abstract virtual bool get_IsRuntimeSpecialName();
    public abstract virtual void set_IsRuntimeSpecialName(bool value);
    public abstract virtual TypeDefinition get_DeclaringType();
    public abstract virtual void set_DeclaringType(TypeDefinition value);
}
internal interface Mono.Cecil.IMetadataImporter {
    public abstract virtual AssemblyNameReference ImportReference(AssemblyNameReference reference);
    public abstract virtual TypeReference ImportReference(TypeReference type, IGenericParameterProvider context);
    public abstract virtual FieldReference ImportReference(FieldReference field, IGenericParameterProvider context);
    public abstract virtual MethodReference ImportReference(MethodReference method, IGenericParameterProvider context);
}
internal interface Mono.Cecil.IMetadataImporterProvider {
    public abstract virtual IMetadataImporter GetMetadataImporter(ModuleDefinition module);
}
internal interface Mono.Cecil.IMetadataResolver {
    public abstract virtual TypeDefinition Resolve(TypeReference type);
    public abstract virtual FieldDefinition Resolve(FieldReference field);
    public abstract virtual MethodDefinition Resolve(MethodReference method);
}
internal interface Mono.Cecil.IMetadataScope {
    
public MetadataScopeType MetadataScopeType { get; }
    
public string Name { get; public set; }
    public abstract virtual MetadataScopeType get_MetadataScopeType();
    public abstract virtual string get_Name();
    public abstract virtual void set_Name(string value);
}
internal interface Mono.Cecil.IMetadataTokenProvider {
    
public MetadataToken MetadataToken { get; public set; }
    public abstract virtual MetadataToken get_MetadataToken();
    public abstract virtual void set_MetadataToken(MetadataToken value);
}
internal interface Mono.Cecil.IMethodSignature {
    
public bool HasThis { get; public set; }
    
public bool ExplicitThis { get; public set; }
    
public MethodCallingConvention CallingConvention { get; public set; }
    
public bool HasParameters { get; }
    
public Collection`1<ParameterDefinition> Parameters { get; }
    
public TypeReference ReturnType { get; public set; }
    
public MethodReturnType MethodReturnType { get; }
    public abstract virtual bool get_HasThis();
    public abstract virtual void set_HasThis(bool value);
    public abstract virtual bool get_ExplicitThis();
    public abstract virtual void set_ExplicitThis(bool value);
    public abstract virtual MethodCallingConvention get_CallingConvention();
    public abstract virtual void set_CallingConvention(MethodCallingConvention value);
    public abstract virtual bool get_HasParameters();
    public abstract virtual Collection`1<ParameterDefinition> get_Parameters();
    public abstract virtual TypeReference get_ReturnType();
    public abstract virtual void set_ReturnType(TypeReference value);
    public abstract virtual MethodReturnType get_MethodReturnType();
}
internal class Mono.Cecil.ImmediateModuleReader : ModuleReader {
    
private bool resolve_attributes;
    public ImmediateModuleReader(Image image);
    protected virtual void ReadModule();
    public void ReadModule(ModuleDefinition module, bool resolve_attributes);
    private void ReadTypes(Collection`1<TypeDefinition> types);
    private void ReadType(TypeDefinition type);
    private void ReadInterfaces(TypeDefinition type);
    private void ReadGenericParameters(IGenericParameterProvider provider);
    private void ReadGenericParameterConstraints(GenericParameter parameter);
    private void ReadSecurityDeclarations(ISecurityDeclarationProvider provider);
    private void ReadCustomAttributes(ICustomAttributeProvider provider);
    private void ReadFields(TypeDefinition type);
    private void ReadMethods(TypeDefinition type);
    private void ReadParameters(MethodDefinition method);
    private void ReadProperties(TypeDefinition type);
    private void ReadEvents(TypeDefinition type);
    public virtual void ReadSymbols(ModuleDefinition module);
    private void ReadTypesSymbols(Collection`1<TypeDefinition> types, ISymbolReader symbol_reader);
    private void ReadMethodsSymbols(TypeDefinition type, ISymbolReader symbol_reader);
    [CompilerGeneratedAttribute]
private void <ReadModule>b__2_0(ModuleDefinition module, MetadataReader reader);
}
internal interface Mono.Cecil.IModifierType {
    
public TypeReference ModifierType { get; }
    
public TypeReference ElementType { get; }
    public abstract virtual TypeReference get_ModifierType();
    public abstract virtual TypeReference get_ElementType();
}
internal class Mono.Cecil.ImplMapTable : SortedTable`1<Row`4<PInvokeAttributes, UInt32, UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
    public virtual int Compare(Row`4<PInvokeAttributes, UInt32, UInt32, UInt32> x, Row`4<PInvokeAttributes, UInt32, UInt32, UInt32> y);
}
internal class Mono.Cecil.ImportGenericContext : ValueType {
    
private Collection`1<IGenericParameterProvider> stack;
    
public bool IsEmpty { get; }
    public ImportGenericContext(IGenericParameterProvider provider);
    public bool get_IsEmpty();
    public void Push(IGenericParameterProvider provider);
    public void Pop();
    public TypeReference MethodParameter(string method, int position);
    public string NormalizeMethodName(MethodReference method);
    public TypeReference TypeParameter(string type, int position);
    private static TypeReference GenericTypeFor(IGenericParameterProvider context);
    public static ImportGenericContext For(IGenericParameterProvider context);
}
internal class Mono.Cecil.ImportScopeTable : MetadataTable`1<Row`2<UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
}
internal class Mono.Cecil.InterfaceImplementation : object {
    
internal TypeDefinition type;
    
internal MetadataToken token;
    
private TypeReference interface_type;
    
private Collection`1<CustomAttribute> custom_attributes;
    
public TypeReference InterfaceType { get; public set; }
    
public bool HasCustomAttributes { get; }
    
public Collection`1<CustomAttribute> CustomAttributes { get; }
    
public MetadataToken MetadataToken { get; public set; }
    internal InterfaceImplementation(TypeReference interfaceType, MetadataToken token);
    public InterfaceImplementation(TypeReference interfaceType);
    public TypeReference get_InterfaceType();
    public void set_InterfaceType(TypeReference value);
    public sealed virtual bool get_HasCustomAttributes();
    public sealed virtual Collection`1<CustomAttribute> get_CustomAttributes();
    public sealed virtual MetadataToken get_MetadataToken();
    public sealed virtual void set_MetadataToken(MetadataToken value);
}
internal class Mono.Cecil.InterfaceImplementationCollection : Collection`1<InterfaceImplementation> {
    
private TypeDefinition type;
    internal InterfaceImplementationCollection(TypeDefinition type);
    internal InterfaceImplementationCollection(TypeDefinition type, int length);
    protected virtual void OnAdd(InterfaceImplementation item, int index);
    protected virtual void OnInsert(InterfaceImplementation item, int index);
    protected virtual void OnSet(InterfaceImplementation item, int index);
    protected virtual void OnRemove(InterfaceImplementation item, int index);
}
internal class Mono.Cecil.InterfaceImplTable : MetadataTable`1<Row`2<UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
}
internal interface Mono.Cecil.IReflectionImporter {
    public abstract virtual AssemblyNameReference ImportReference(AssemblyName reference);
    public abstract virtual TypeReference ImportReference(Type type, IGenericParameterProvider context);
    public abstract virtual FieldReference ImportReference(FieldInfo field, IGenericParameterProvider context);
    public abstract virtual MethodReference ImportReference(MethodBase method, IGenericParameterProvider context);
}
internal interface Mono.Cecil.IReflectionImporterProvider {
    public abstract virtual IReflectionImporter GetReflectionImporter(ModuleDefinition module);
}
internal interface Mono.Cecil.ISecurityDeclarationProvider {
    
public bool HasSecurityDeclarations { get; }
    
public Collection`1<SecurityDeclaration> SecurityDeclarations { get; }
    public abstract virtual bool get_HasSecurityDeclarations();
    public abstract virtual Collection`1<SecurityDeclaration> get_SecurityDeclarations();
}
internal class Mono.Cecil.LinkedResource : Resource {
    
internal Byte[] hash;
    
private string file;
    
public Byte[] Hash { get; }
    
public string File { get; public set; }
    
public ResourceType ResourceType { get; }
    public LinkedResource(string name, ManifestResourceAttributes flags);
    public LinkedResource(string name, ManifestResourceAttributes flags, string file);
    public Byte[] get_Hash();
    public string get_File();
    public void set_File(string value);
    public virtual ResourceType get_ResourceType();
}
internal class Mono.Cecil.LocalConstantTable : MetadataTable`1<Row`2<UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
}
internal class Mono.Cecil.LocalScopeTable : MetadataTable`1<Row`6<UInt32, UInt32, UInt32, UInt32, UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
}
internal class Mono.Cecil.LocalVariableTable : MetadataTable`1<Row`3<VariableAttributes, ushort, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
}
[FlagsAttribute]
internal enum Mono.Cecil.ManifestResourceAttributes : Enum {
    
public UInt32 value__;
    
public static ManifestResourceAttributes VisibilityMask;
    
public static ManifestResourceAttributes Public;
    
public static ManifestResourceAttributes Private;
}
internal class Mono.Cecil.ManifestResourceTable : MetadataTable`1<Row`4<UInt32, ManifestResourceAttributes, UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
}
internal class Mono.Cecil.MarshalInfo : object {
    
internal NativeType native;
    
public NativeType NativeType { get; public set; }
    public MarshalInfo(NativeType native);
    public NativeType get_NativeType();
    public void set_NativeType(NativeType value);
}
internal class Mono.Cecil.Mdb.MdbReader : object {
    
private ModuleDefinition module;
    
private MonoSymbolFile symbol_file;
    
private Dictionary`2<string, Document> documents;
    public MdbReader(ModuleDefinition module, MonoSymbolFile symFile);
    public sealed virtual ISymbolWriterProvider GetWriterProvider();
    public sealed virtual bool ProcessDebugHeader(ImageDebugHeader header);
    public sealed virtual MethodDebugInformation Read(MethodDefinition method);
    private static int ReadCodeSize(MethodDefinition method);
    private static void ReadLocalVariables(MethodEntry entry, ScopeDebugInformation[] scopes);
    private void ReadLineNumbers(MethodEntry entry, MethodDebugInformation info);
    private Document GetDocument(SourceFileEntry file);
    private static ScopeDebugInformation[] ReadScopes(MethodEntry entry, MethodDebugInformation info);
    private static bool AddScope(Collection`1<ScopeDebugInformation> scopes, ScopeDebugInformation scope);
    private SequencePoint LineToSequencePoint(LineNumberEntry line);
    public sealed virtual void Dispose();
}
internal class Mono.Cecil.Mdb.MdbReaderProvider : object {
    public sealed virtual ISymbolReader GetSymbolReader(ModuleDefinition module, string fileName);
    public sealed virtual ISymbolReader GetSymbolReader(ModuleDefinition module, Stream symbolStream);
}
internal class Mono.Cecil.Mdb.MdbWriter : object {
    
private ModuleDefinition module;
    
private MonoSymbolWriter writer;
    
private Dictionary`2<string, SourceFile> source_files;
    public MdbWriter(ModuleDefinition module, string assembly);
    public sealed virtual ISymbolReaderProvider GetReaderProvider();
    private SourceFile GetSourceFile(Document document);
    private void Populate(Collection`1<SequencePoint> sequencePoints, Int32[] offsets, Int32[] startRows, Int32[] endRows, Int32[] startCols, Int32[] endCols, SourceFile& file);
    public sealed virtual void Write(MethodDebugInformation info);
    private void WriteRootScope(ScopeDebugInformation scope, MethodDebugInformation info);
    private void WriteScope(ScopeDebugInformation scope, MethodDebugInformation info);
    private void WriteScopes(Collection`1<ScopeDebugInformation> scopes, MethodDebugInformation info);
    private void WriteScopeVariables(ScopeDebugInformation scope);
    public sealed virtual ImageDebugHeader GetDebugHeader();
    public sealed virtual void Write();
    public sealed virtual void Dispose();
}
internal class Mono.Cecil.Mdb.MdbWriterProvider : object {
    public sealed virtual ISymbolWriter GetSymbolWriter(ModuleDefinition module, string fileName);
    public sealed virtual ISymbolWriter GetSymbolWriter(ModuleDefinition module, Stream symbolStream);
}
[ExtensionAttribute]
internal static class Mono.Cecil.Mdb.MethodEntryExtensions : object {
    [ExtensionAttribute]
public static bool HasColumnInfo(MethodEntry entry);
    [ExtensionAttribute]
public static bool HasEndInfo(MethodEntry entry);
}
internal class Mono.Cecil.MemberDefinitionCollection`1 : Collection`1<T> {
    
private TypeDefinition container;
    internal MemberDefinitionCollection`1(TypeDefinition container);
    internal MemberDefinitionCollection`1(TypeDefinition container, int capacity);
    protected virtual void OnAdd(T item, int index);
    protected sealed virtual void OnSet(T item, int index);
    protected sealed virtual void OnInsert(T item, int index);
    protected sealed virtual void OnRemove(T item, int index);
    protected sealed virtual void OnClear();
    private void Attach(T element);
    private static void Detach(T element);
}
internal abstract class Mono.Cecil.MemberReference : object {
    
private string name;
    
private TypeReference declaring_type;
    
internal MetadataToken token;
    
internal object projection;
    
public string Name { get; public set; }
    
public string FullName { get; }
    
public TypeReference DeclaringType { get; public set; }
    
public MetadataToken MetadataToken { get; public set; }
    
public bool IsWindowsRuntimeProjection { get; }
    
internal bool HasImage { get; }
    
public ModuleDefinition Module { get; }
    
public bool IsDefinition { get; }
    
public bool ContainsGenericParameter { get; }
    internal MemberReference(string name);
    public virtual string get_Name();
    public virtual void set_Name(string value);
    public abstract virtual string get_FullName();
    public virtual TypeReference get_DeclaringType();
    public virtual void set_DeclaringType(TypeReference value);
    public sealed virtual MetadataToken get_MetadataToken();
    public sealed virtual void set_MetadataToken(MetadataToken value);
    public bool get_IsWindowsRuntimeProjection();
    internal bool get_HasImage();
    public virtual ModuleDefinition get_Module();
    public virtual bool get_IsDefinition();
    public virtual bool get_ContainsGenericParameter();
    internal string MemberFullName();
    public IMemberDefinition Resolve();
    protected abstract virtual IMemberDefinition ResolveDefinition();
    public virtual string ToString();
}
internal class Mono.Cecil.MemberRefTable : MetadataTable`1<Row`3<UInt32, UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
}
internal class Mono.Cecil.Metadata.BlobHeap : Heap {
    public BlobHeap(Byte[] data);
    public Byte[] Read(UInt32 index);
    public void GetView(UInt32 signature, Byte[]& buffer, Int32& index, Int32& length);
}
internal class Mono.Cecil.Metadata.BlobHeapBuffer : HeapBuffer {
    
private Dictionary`2<ByteBuffer, UInt32> blobs;
    
public bool IsEmpty { get; }
    public virtual bool get_IsEmpty();
    public UInt32 GetBlobIndex(ByteBuffer blob);
    private void WriteBlob(ByteBuffer blob);
}
internal enum Mono.Cecil.Metadata.CodedIndex : Enum {
    
public int value__;
    
public static CodedIndex TypeDefOrRef;
    
public static CodedIndex HasConstant;
    
public static CodedIndex HasCustomAttribute;
    
public static CodedIndex HasFieldMarshal;
    
public static CodedIndex HasDeclSecurity;
    
public static CodedIndex MemberRefParent;
    
public static CodedIndex HasSemantics;
    
public static CodedIndex MethodDefOrRef;
    
public static CodedIndex MemberForwarded;
    
public static CodedIndex Implementation;
    
public static CodedIndex CustomAttributeType;
    
public static CodedIndex ResolutionScope;
    
public static CodedIndex TypeOrMethodDef;
    
public static CodedIndex HasCustomDebugInformation;
}
internal class Mono.Cecil.Metadata.DataBuffer : ByteBuffer {
    
private int buffer_align;
    
public int BufferAlign { get; }
    private void Align(int align);
    public UInt32 AddData(Byte[] data, int align);
    public int get_BufferAlign();
}
internal enum Mono.Cecil.Metadata.ElementType : Enum {
    
public byte value__;
    
public static ElementType None;
    
public static ElementType Void;
    
public static ElementType Boolean;
    
public static ElementType Char;
    
public static ElementType I1;
    
public static ElementType U1;
    
public static ElementType I2;
    
public static ElementType U2;
    
public static ElementType I4;
    
public static ElementType U4;
    
public static ElementType I8;
    
public static ElementType U8;
    
public static ElementType R4;
    
public static ElementType R8;
    
public static ElementType String;
    
public static ElementType Ptr;
    
public static ElementType ByRef;
    
public static ElementType ValueType;
    
public static ElementType Class;
    
public static ElementType Var;
    
public static ElementType Array;
    
public static ElementType GenericInst;
    
public static ElementType TypedByRef;
    
public static ElementType I;
    
public static ElementType U;
    
public static ElementType FnPtr;
    
public static ElementType Object;
    
public static ElementType SzArray;
    
public static ElementType MVar;
    
public static ElementType CModReqD;
    
public static ElementType CModOpt;
    
public static ElementType Internal;
    
public static ElementType Modifier;
    
public static ElementType Sentinel;
    
public static ElementType Pinned;
    
public static ElementType Type;
    
public static ElementType Boxed;
    
public static ElementType Enum;
}
internal class Mono.Cecil.Metadata.GuidHeap : Heap {
    public GuidHeap(Byte[] data);
    public Guid Read(UInt32 index);
}
internal class Mono.Cecil.Metadata.GuidHeapBuffer : HeapBuffer {
    
private Dictionary`2<Guid, UInt32> guids;
    
public bool IsEmpty { get; }
    public virtual bool get_IsEmpty();
    public UInt32 GetGuidIndex(Guid guid);
    private void WriteGuid(Guid guid);
}
internal abstract class Mono.Cecil.Metadata.Heap : object {
    
public int IndexSize;
    
internal Byte[] data;
    protected Heap(Byte[] data);
}
internal abstract class Mono.Cecil.Metadata.HeapBuffer : ByteBuffer {
    
public bool IsLarge { get; }
    
public bool IsEmpty { get; }
    protected HeapBuffer(int length);
    public bool get_IsLarge();
    public abstract virtual bool get_IsEmpty();
}
internal class Mono.Cecil.Metadata.PdbHeap : Heap {
    
public Byte[] Id;
    
public UInt32 EntryPoint;
    
public long TypeSystemTables;
    
public UInt32[] TypeSystemTableRows;
    public PdbHeap(Byte[] data);
    public bool HasTable(Table table);
}
internal class Mono.Cecil.Metadata.PdbHeapBuffer : HeapBuffer {
    
public bool IsEmpty { get; }
    public virtual bool get_IsEmpty();
}
internal class Mono.Cecil.Metadata.ResourceBuffer : ByteBuffer {
    public UInt32 AddResource(Byte[] resource);
}
internal class Mono.Cecil.Metadata.Row`2 : ValueType {
    
internal T1 Col1;
    
internal T2 Col2;
    public Row`2(T1 col1, T2 col2);
}
internal class Mono.Cecil.Metadata.Row`3 : ValueType {
    
internal T1 Col1;
    
internal T2 Col2;
    
internal T3 Col3;
    public Row`3(T1 col1, T2 col2, T3 col3);
}
internal class Mono.Cecil.Metadata.Row`4 : ValueType {
    
internal T1 Col1;
    
internal T2 Col2;
    
internal T3 Col3;
    
internal T4 Col4;
    public Row`4(T1 col1, T2 col2, T3 col3, T4 col4);
}
internal class Mono.Cecil.Metadata.Row`5 : ValueType {
    
internal T1 Col1;
    
internal T2 Col2;
    
internal T3 Col3;
    
internal T4 Col4;
    
internal T5 Col5;
    public Row`5(T1 col1, T2 col2, T3 col3, T4 col4, T5 col5);
}
internal class Mono.Cecil.Metadata.Row`6 : ValueType {
    
internal T1 Col1;
    
internal T2 Col2;
    
internal T3 Col3;
    
internal T4 Col4;
    
internal T5 Col5;
    
internal T6 Col6;
    public Row`6(T1 col1, T2 col2, T3 col3, T4 col4, T5 col5, T6 col6);
}
internal class Mono.Cecil.Metadata.Row`9 : ValueType {
    
internal T1 Col1;
    
internal T2 Col2;
    
internal T3 Col3;
    
internal T4 Col4;
    
internal T5 Col5;
    
internal T6 Col6;
    
internal T7 Col7;
    
internal T8 Col8;
    
internal T9 Col9;
    public Row`9(T1 col1, T2 col2, T3 col3, T4 col4, T5 col5, T6 col6, T7 col7, T8 col8, T9 col9);
}
internal class Mono.Cecil.Metadata.RowEqualityComparer : object {
    public sealed virtual bool Equals(Row`2<string, string> x, Row`2<string, string> y);
    public sealed virtual int GetHashCode(Row`2<string, string> obj);
    public sealed virtual bool Equals(Row`2<UInt32, UInt32> x, Row`2<UInt32, UInt32> y);
    public sealed virtual int GetHashCode(Row`2<UInt32, UInt32> obj);
    public sealed virtual bool Equals(Row`3<UInt32, UInt32, UInt32> x, Row`3<UInt32, UInt32, UInt32> y);
    public sealed virtual int GetHashCode(Row`3<UInt32, UInt32, UInt32> obj);
}
internal class Mono.Cecil.Metadata.StringHeap : Heap {
    
private Dictionary`2<UInt32, string> strings;
    public StringHeap(Byte[] data);
    public string Read(UInt32 index);
    protected virtual string ReadStringAt(UInt32 index);
}
internal class Mono.Cecil.Metadata.StringHeapBuffer : HeapBuffer {
    
protected Dictionary`2<string, UInt32> strings;
    
public bool IsEmpty { get; }
    public sealed virtual bool get_IsEmpty();
    public virtual UInt32 GetStringIndex(string string);
    public UInt32[] WriteStrings();
    private static List`1<KeyValuePair`2<string, UInt32>> SortStrings(Dictionary`2<string, UInt32> strings);
    private static bool IsLowSurrogateChar(int c);
    protected virtual void WriteString(string string);
}
internal enum Mono.Cecil.Metadata.Table : Enum {
    
public byte value__;
    
public static Table Module;
    
public static Table TypeRef;
    
public static Table TypeDef;
    
public static Table FieldPtr;
    
public static Table Field;
    
public static Table MethodPtr;
    
public static Table Method;
    
public static Table ParamPtr;
    
public static Table Param;
    
public static Table InterfaceImpl;
    
public static Table MemberRef;
    
public static Table Constant;
    
public static Table CustomAttribute;
    
public static Table FieldMarshal;
    
public static Table DeclSecurity;
    
public static Table ClassLayout;
    
public static Table FieldLayout;
    
public static Table StandAloneSig;
    
public static Table EventMap;
    
public static Table EventPtr;
    
public static Table Event;
    
public static Table PropertyMap;
    
public static Table PropertyPtr;
    
public static Table Property;
    
public static Table MethodSemantics;
    
public static Table MethodImpl;
    
public static Table ModuleRef;
    
public static Table TypeSpec;
    
public static Table ImplMap;
    
public static Table FieldRVA;
    
public static Table EncLog;
    
public static Table EncMap;
    
public static Table Assembly;
    
public static Table AssemblyProcessor;
    
public static Table AssemblyOS;
    
public static Table AssemblyRef;
    
public static Table AssemblyRefProcessor;
    
public static Table AssemblyRefOS;
    
public static Table File;
    
public static Table ExportedType;
    
public static Table ManifestResource;
    
public static Table NestedClass;
    
public static Table GenericParam;
    
public static Table MethodSpec;
    
public static Table GenericParamConstraint;
    
public static Table Document;
    
public static Table MethodDebugInformation;
    
public static Table LocalScope;
    
public static Table LocalVariable;
    
public static Table LocalConstant;
    
public static Table ImportScope;
    
public static Table StateMachineMethod;
    
public static Table CustomDebugInformation;
}
[DefaultMemberAttribute("Item")]
internal class Mono.Cecil.Metadata.TableHeap : Heap {
    
public long Valid;
    
public long Sorted;
    
public TableInformation[] Tables;
    
public TableInformation Item { get; }
    public TableHeap(Byte[] data);
    public TableInformation get_Item(Table table);
    public bool HasTable(Table table);
}
internal class Mono.Cecil.Metadata.TableHeapBuffer : HeapBuffer {
    
private ModuleDefinition module;
    
private MetadataBuilder metadata;
    
internal TableInformation[] table_infos;
    
internal MetadataTable[] tables;
    
private bool large_string;
    
private bool large_blob;
    
private bool large_guid;
    
private Int32[] coded_index_sizes;
    
private Func`2<Table, int> counter;
    
internal UInt32[] string_offsets;
    
public bool IsEmpty { get; }
    public TableHeapBuffer(ModuleDefinition module, MetadataBuilder metadata);
    public virtual bool get_IsEmpty();
    private int GetTableLength(Table table);
    public TTable GetTable(Table table);
    public void WriteBySize(UInt32 value, int size);
    public void WriteBySize(UInt32 value, bool large);
    public void WriteString(UInt32 string);
    public void WriteBlob(UInt32 blob);
    public void WriteGuid(UInt32 guid);
    public void WriteRID(UInt32 rid, Table table);
    private int GetCodedIndexSize(CodedIndex coded_index);
    public void WriteCodedRID(UInt32 rid, CodedIndex coded_index);
    public void WriteTableHeap();
    private void WriteRowCount();
    private void WriteTables();
    private ulong GetValid();
    public void ComputeTableInformations();
    private void ComputeTableInformations(TableHeapBuffer table_heap);
    private byte GetHeapSizes();
    private byte GetTableHeapVersion();
    public void FixupData(UInt32 data_rva);
}
internal class Mono.Cecil.Metadata.TableInformation : ValueType {
    
public UInt32 Offset;
    
public UInt32 Length;
    
public UInt32 RowSize;
    
public bool IsLarge { get; }
    public bool get_IsLarge();
}
internal class Mono.Cecil.Metadata.UserStringHeap : StringHeap {
    public UserStringHeap(Byte[] data);
    protected virtual string ReadStringAt(UInt32 index);
}
internal class Mono.Cecil.Metadata.UserStringHeapBuffer : StringHeapBuffer {
    public virtual UInt32 GetStringIndex(string string);
    protected virtual void WriteString(string string);
}
internal class Mono.Cecil.MetadataBuilder : object {
    
internal ModuleDefinition module;
    
internal ISymbolWriterProvider symbol_writer_provider;
    
internal ISymbolWriter symbol_writer;
    
internal TextMap text_map;
    
internal string fq_name;
    
internal UInt32 timestamp;
    
private Dictionary`2<Row`3<UInt32, UInt32, UInt32>, MetadataToken> type_ref_map;
    
private Dictionary`2<UInt32, MetadataToken> type_spec_map;
    
private Dictionary`2<Row`3<UInt32, UInt32, UInt32>, MetadataToken> member_ref_map;
    
private Dictionary`2<Row`2<UInt32, UInt32>, MetadataToken> method_spec_map;
    
private Collection`1<GenericParameter> generic_parameters;
    
internal CodeWriter code;
    
internal DataBuffer data;
    
internal ResourceBuffer resources;
    
internal StringHeapBuffer string_heap;
    
internal GuidHeapBuffer guid_heap;
    
internal UserStringHeapBuffer user_string_heap;
    
internal BlobHeapBuffer blob_heap;
    
internal TableHeapBuffer table_heap;
    
internal PdbHeapBuffer pdb_heap;
    
internal MetadataToken entry_point;
    
internal UInt32 type_rid;
    
internal UInt32 field_rid;
    
internal UInt32 method_rid;
    
internal UInt32 param_rid;
    
internal UInt32 property_rid;
    
internal UInt32 event_rid;
    
internal UInt32 local_variable_rid;
    
internal UInt32 local_constant_rid;
    
private TypeRefTable type_ref_table;
    
private TypeDefTable type_def_table;
    
private FieldTable field_table;
    
private MethodTable method_table;
    
private ParamTable param_table;
    
private InterfaceImplTable iface_impl_table;
    
private MemberRefTable member_ref_table;
    
private ConstantTable constant_table;
    
private CustomAttributeTable custom_attribute_table;
    
private DeclSecurityTable declsec_table;
    
private StandAloneSigTable standalone_sig_table;
    
private EventMapTable event_map_table;
    
private EventTable event_table;
    
private PropertyMapTable property_map_table;
    
private PropertyTable property_table;
    
private TypeSpecTable typespec_table;
    
private MethodSpecTable method_spec_table;
    
internal MetadataBuilder metadata_builder;
    
private DocumentTable document_table;
    
private MethodDebugInformationTable method_debug_information_table;
    
private LocalScopeTable local_scope_table;
    
private LocalVariableTable local_variable_table;
    
private LocalConstantTable local_constant_table;
    
private ImportScopeTable import_scope_table;
    
private StateMachineMethodTable state_machine_method_table;
    
private CustomDebugInformationTable custom_debug_information_table;
    
private Dictionary`2<Row`2<UInt32, UInt32>, MetadataToken> import_scope_map;
    
private Dictionary`2<string, MetadataToken> document_map;
    public MetadataBuilder(ModuleDefinition module, string fq_name, UInt32 timestamp, ISymbolWriterProvider symbol_writer_provider);
    public MetadataBuilder(ModuleDefinition module, PortablePdbWriterProvider writer_provider);
    public void SetSymbolWriter(ISymbolWriter writer);
    private TextMap CreateTextMap();
    private TTable GetTable(Table table);
    private UInt32 GetStringIndex(string string);
    private UInt32 GetGuidIndex(Guid guid);
    private UInt32 GetBlobIndex(ByteBuffer blob);
    private UInt32 GetBlobIndex(Byte[] blob);
    public void BuildMetadata();
    private void BuildModule();
    private void BuildAssembly();
    private void BuildModules();
    private string GetModuleFileName(string name);
    private void AddAssemblyReferences();
    private void AddModuleReferences();
    private void AddResources();
    private UInt32 AddLinkedResource(LinkedResource resource);
    private UInt32 AddEmbeddedResource(EmbeddedResource resource);
    private void AddExportedTypes();
    private MetadataToken GetExportedTypeScope(ExportedType exported_type);
    private void BuildTypes();
    private void AttachTokens();
    private void AttachTypeToken(TypeDefinition type);
    private void AttachNestedTypesToken(TypeDefinition type);
    private void AttachFieldsToken(TypeDefinition type);
    private void AttachMethodsToken(TypeDefinition type);
    private MetadataToken GetTypeToken(TypeReference type);
    private MetadataToken GetTypeSpecToken(TypeReference type);
    private MetadataToken AddTypeSpecification(TypeReference type, UInt32 row);
    private MetadataToken GetTypeRefToken(TypeReference type);
    private Row`3<UInt32, UInt32, UInt32> CreateTypeRefRow(TypeReference type);
    private MetadataToken GetScopeToken(TypeReference type);
    private static UInt32 MakeCodedRID(IMetadataTokenProvider provider, CodedIndex index);
    private static UInt32 MakeCodedRID(MetadataToken token, CodedIndex index);
    private MetadataToken AddTypeReference(TypeReference type, Row`3<UInt32, UInt32, UInt32> row);
    private void AddTypes();
    private void AddType(TypeDefinition type);
    private void AddGenericParameters(IGenericParameterProvider owner);
    private void AddGenericParameters();
    private void AddConstraints(GenericParameter generic_parameter, GenericParamConstraintTable table);
    private void AddInterfaces(TypeDefinition type);
    private void AddLayoutInfo(TypeDefinition type);
    private void AddNestedTypes(TypeDefinition type);
    private void AddFields(TypeDefinition type);
    private void AddField(FieldDefinition field);
    private void AddFieldRVA(FieldDefinition field);
    private void AddFieldLayout(FieldDefinition field);
    private void AddMethods(TypeDefinition type);
    private void AddMethod(MethodDefinition method);
    private void AddParameters(MethodDefinition method);
    private void AddPInvokeInfo(MethodDefinition method);
    private void AddOverrides(MethodDefinition method);
    private static bool RequiresParameterRow(ParameterDefinition parameter);
    private void AddParameter(ushort sequence, ParameterDefinition parameter, ParamTable table);
    private void AddMarshalInfo(IMarshalInfoProvider owner);
    private void AddProperties(TypeDefinition type);
    private void AddProperty(PropertyDefinition property);
    private void AddOtherSemantic(IMetadataTokenProvider owner, Collection`1<MethodDefinition> others);
    private void AddEvents(TypeDefinition type);
    private void AddEvent(EventDefinition event);
    private void AddSemantic(MethodSemanticsAttributes semantics, IMetadataTokenProvider provider, MethodDefinition method);
    private void AddConstant(IConstantProvider owner, TypeReference type);
    private static ElementType GetConstantType(TypeReference constant_type, object constant);
    private static ElementType GetConstantType(Type type);
    private void AddCustomAttributes(ICustomAttributeProvider owner);
    private void AddSecurityDeclarations(ISecurityDeclarationProvider owner);
    private MetadataToken GetMemberRefToken(MemberReference member);
    private Row`3<UInt32, UInt32, UInt32> CreateMemberRefRow(MemberReference member);
    private MetadataToken AddMemberReference(MemberReference member, Row`3<UInt32, UInt32, UInt32> row);
    private MetadataToken GetMethodSpecToken(MethodSpecification method_spec);
    private void AddMethodSpecification(MethodSpecification method_spec, Row`2<UInt32, UInt32> row);
    private Row`2<UInt32, UInt32> CreateMethodSpecRow(MethodSpecification method_spec);
    private SignatureWriter CreateSignatureWriter();
    private SignatureWriter GetMethodSpecSignature(MethodSpecification method_spec);
    public UInt32 AddStandAloneSignature(UInt32 signature);
    public UInt32 GetLocalVariableBlobIndex(Collection`1<VariableDefinition> variables);
    public UInt32 GetCallSiteBlobIndex(CallSite call_site);
    public UInt32 GetConstantTypeBlobIndex(TypeReference constant_type);
    private SignatureWriter GetVariablesSignature(Collection`1<VariableDefinition> variables);
    private SignatureWriter GetConstantTypeSignature(TypeReference constant_type);
    private SignatureWriter GetFieldSignature(FieldReference field);
    private SignatureWriter GetMethodSignature(IMethodSignature method);
    private SignatureWriter GetMemberRefSignature(MemberReference member);
    private SignatureWriter GetPropertySignature(PropertyDefinition property);
    private SignatureWriter GetTypeSpecSignature(TypeReference type);
    private SignatureWriter GetConstantSignature(ElementType type, object value);
    private SignatureWriter GetCustomAttributeSignature(CustomAttribute attribute);
    private SignatureWriter GetSecurityDeclarationSignature(SecurityDeclaration declaration);
    private SignatureWriter GetMarshalInfoSignature(IMarshalInfoProvider owner);
    private static Exception CreateForeignMemberException(MemberReference member);
    public MetadataToken LookupToken(IMetadataTokenProvider provider);
    public void AddMethodDebugInformation(MethodDebugInformation method_info);
    private void AddStateMachineMethod(MethodDebugInformation method_info);
    private void AddLocalScope(MethodDebugInformation method_info, ScopeDebugInformation scope);
    private void AddLocalVariables(ScopeDebugInformation scope);
    private void AddLocalConstants(ScopeDebugInformation scope);
    private SignatureWriter GetConstantSignature(ConstantDebugInformation constant);
    public void AddCustomDebugInformations(ICustomDebugInformationProvider provider);
    private void AddStateMachineScopeDebugInformation(ICustomDebugInformationProvider provider, StateMachineScopeDebugInformation state_machine_scope);
    private void AddAsyncMethodBodyDebugInformation(ICustomDebugInformationProvider provider, AsyncMethodBodyDebugInformation async_method);
    private void AddEmbeddedSourceDebugInformation(ICustomDebugInformationProvider provider, EmbeddedSourceDebugInformation embedded_source);
    private void AddSourceLinkDebugInformation(ICustomDebugInformationProvider provider, SourceLinkDebugInformation source_link);
    private void AddCustomDebugInformation(ICustomDebugInformationProvider provider, CustomDebugInformation custom_info, SignatureWriter signature);
    private void AddCustomDebugInformation(ICustomDebugInformationProvider provider, CustomDebugInformation custom_info, UInt32 blob_index);
    private UInt32 AddImportScope(ImportDebugInformation import);
    private void AddImportTarget(ImportTarget target, SignatureWriter signature);
    private UInt32 GetUTF8StringBlobIndex(string s);
    public MetadataToken GetDocumentToken(Document document);
    private SignatureWriter GetDocumentNameSignature(Document document);
    private static bool TryGetDocumentNameSeparator(string path, Char& separator);
    private void AddSequencePoints(MethodDebugInformation info);
}
internal enum Mono.Cecil.MetadataKind : Enum {
    
public int value__;
    
public static MetadataKind Ecma335;
    
public static MetadataKind WindowsMetadata;
    
public static MetadataKind ManagedWindowsMetadata;
}
internal class Mono.Cecil.MetadataReader : ByteBuffer {
    
internal Image image;
    
internal ModuleDefinition module;
    
internal MetadataSystem metadata;
    
internal CodeReader code;
    
internal IGenericContext context;
    
private MetadataReader metadata_reader;
    public MetadataReader(ModuleDefinition module);
    public MetadataReader(Image image, ModuleDefinition module, MetadataReader metadata_reader);
    private int GetCodedIndexSize(CodedIndex index);
    private UInt32 ReadByIndexSize(int size);
    private Byte[] ReadBlob();
    private Byte[] ReadBlob(UInt32 signature);
    private UInt32 ReadBlobIndex();
    private void GetBlobView(UInt32 signature, Byte[]& blob, Int32& index, Int32& count);
    private string ReadString();
    private UInt32 ReadStringIndex();
    private Guid ReadGuid();
    private UInt32 ReadTableIndex(Table table);
    private MetadataToken ReadMetadataToken(CodedIndex index);
    private int MoveTo(Table table);
    private bool MoveTo(Table table, UInt32 row);
    public AssemblyNameDefinition ReadAssemblyNameDefinition();
    public ModuleDefinition Populate(ModuleDefinition module);
    private void InitializeAssemblyReferences();
    public Collection`1<AssemblyNameReference> ReadAssemblyReferences();
    public MethodDefinition ReadEntryPoint();
    public Collection`1<ModuleDefinition> ReadModules();
    private string GetModuleFileName(string name);
    private void InitializeModuleReferences();
    public Collection`1<ModuleReference> ReadModuleReferences();
    public bool HasFileResource();
    public Collection`1<Resource> ReadResources();
    private Row`3<FileAttributes, string, UInt32> ReadFileRecord(UInt32 rid);
    public Byte[] GetManagedResource(UInt32 offset);
    private void PopulateVersionAndFlags(AssemblyNameReference name);
    private void PopulateNameAndCulture(AssemblyNameReference name);
    public TypeDefinitionCollection ReadTypes();
    private void CompleteTypes();
    private void InitializeTypeDefinitions();
    private static bool IsNested(TypeAttributes attributes);
    public bool HasNestedTypes(TypeDefinition type);
    public Collection`1<TypeDefinition> ReadNestedTypes(TypeDefinition type);
    private void InitializeNestedTypes();
    private void AddNestedMapping(UInt32 declaring, UInt32 nested);
    private static Collection`1<TValue> AddMapping(Dictionary`2<TKey, Collection`1<TValue>> cache, TKey key, TValue value);
    private TypeDefinition ReadType(UInt32 rid);
    private TypeDefinition GetNestedTypeDeclaringType(TypeDefinition type);
    private Range ReadListRange(UInt32 current_index, Table current, Table target);
    public Row`2<short, int> ReadTypeLayout(TypeDefinition type);
    private void InitializeTypeLayouts();
    public TypeReference GetTypeDefOrRef(MetadataToken token);
    public TypeDefinition GetTypeDefinition(UInt32 rid);
    private TypeDefinition ReadTypeDefinition(UInt32 rid);
    private void InitializeTypeReferences();
    public TypeReference GetTypeReference(string scope, string full_name);
    private TypeReference GetTypeReference(UInt32 rid);
    private TypeReference ReadTypeReference(UInt32 rid);
    private IMetadataScope GetTypeReferenceScope(MetadataToken scope);
    public IEnumerable`1<TypeReference> GetTypeReferences();
    private TypeReference GetTypeSpecification(UInt32 rid);
    private SignatureReader ReadSignature(UInt32 signature);
    public bool HasInterfaces(TypeDefinition type);
    public InterfaceImplementationCollection ReadInterfaces(TypeDefinition type);
    private void InitializeInterfaces();
    private void AddInterfaceMapping(UInt32 type, Row`2<UInt32, MetadataToken> interface);
    public Collection`1<FieldDefinition> ReadFields(TypeDefinition type);
    private void ReadField(UInt32 field_rid, Collection`1<FieldDefinition> fields);
    private void InitializeFields();
    private TypeReference ReadFieldType(UInt32 signature);
    public int ReadFieldRVA(FieldDefinition field);
    private Byte[] GetFieldInitializeValue(int size, UInt32 rva);
    private static int GetFieldTypeSize(TypeReference type);
    private void InitializeFieldRVAs();
    public int ReadFieldLayout(FieldDefinition field);
    private void InitializeFieldLayouts();
    public bool HasEvents(TypeDefinition type);
    public Collection`1<EventDefinition> ReadEvents(TypeDefinition type);
    private void ReadEvent(UInt32 event_rid, Collection`1<EventDefinition> events);
    private void InitializeEvents();
    public bool HasProperties(TypeDefinition type);
    public Collection`1<PropertyDefinition> ReadProperties(TypeDefinition type);
    private void ReadProperty(UInt32 property_rid, Collection`1<PropertyDefinition> properties);
    private void InitializeProperties();
    private MethodSemanticsAttributes ReadMethodSemantics(MethodDefinition method);
    private static EventDefinition GetEvent(TypeDefinition type, MetadataToken token);
    private static PropertyDefinition GetProperty(TypeDefinition type, MetadataToken token);
    private static TMember GetMember(Collection`1<TMember> members, MetadataToken token);
    private void InitializeMethodSemantics();
    public void ReadMethods(PropertyDefinition property);
    public void ReadMethods(EventDefinition event);
    public void ReadAllSemantics(MethodDefinition method);
    private void ReadAllSemantics(TypeDefinition type);
    public Collection`1<MethodDefinition> ReadMethods(TypeDefinition type);
    private void ReadPointers(Table ptr, Table table, Range range, Collection`1<TMember> members, Action`2<UInt32, Collection`1<TMember>> reader);
    private static bool IsDeleted(IMemberDefinition member);
    private void InitializeMethods();
    private void ReadMethod(UInt32 method_rid, Collection`1<MethodDefinition> methods);
    private void ReadParameters(MethodDefinition method, Range param_range);
    private void ReadParameterPointers(MethodDefinition method, Range range);
    private void ReadParameter(UInt32 param_rid, MethodDefinition method);
    private void ReadMethodSignature(UInt32 signature, IMethodSignature method);
    public PInvokeInfo ReadPInvokeInfo(MethodDefinition method);
    private void InitializePInvokes();
    public bool HasGenericParameters(IGenericParameterProvider provider);
    public Collection`1<GenericParameter> ReadGenericParameters(IGenericParameterProvider provider);
    private void ReadGenericParametersRange(Range range, IGenericParameterProvider provider, GenericParameterCollection generic_parameters);
    private void InitializeGenericParameters();
    private Dictionary`2<MetadataToken, Range[]> InitializeRanges(Table table, Func`1<MetadataToken> get_next);
    private static void AddRange(Dictionary`2<MetadataToken, Range[]> ranges, MetadataToken owner, Range range);
    public bool HasGenericConstraints(GenericParameter generic_parameter);
    public GenericParameterConstraintCollection ReadGenericConstraints(GenericParameter generic_parameter);
    private void InitializeGenericConstraints();
    private void AddGenericConstraintMapping(UInt32 generic_parameter, Row`2<UInt32, MetadataToken> constraint);
    public bool HasOverrides(MethodDefinition method);
    public Collection`1<MethodReference> ReadOverrides(MethodDefinition method);
    private void InitializeOverrides();
    private void AddOverrideMapping(UInt32 method_rid, MetadataToken override);
    public MethodBody ReadMethodBody(MethodDefinition method);
    public int ReadCodeSize(MethodDefinition method);
    public CallSite ReadCallSite(MetadataToken token);
    public VariableDefinitionCollection ReadVariables(MetadataToken local_var_token, MethodDefinition method);
    public IMetadataTokenProvider LookupToken(MetadataToken token);
    public FieldDefinition GetFieldDefinition(UInt32 rid);
    private FieldDefinition LookupField(UInt32 rid);
    public MethodDefinition GetMethodDefinition(UInt32 rid);
    private MethodDefinition LookupMethod(UInt32 rid);
    private MethodSpecification GetMethodSpecification(UInt32 rid);
    private MethodSpecification ReadMethodSpecSignature(UInt32 signature, MethodReference method);
    private MemberReference GetMemberReference(UInt32 rid);
    private MemberReference ReadMemberReference(UInt32 rid);
    private MemberReference ReadTypeMemberReference(MetadataToken type, string name, UInt32 signature);
    private MemberReference ReadMemberReferenceSignature(UInt32 signature, TypeReference declaring_type);
    private MemberReference ReadMethodMemberReference(MetadataToken token, string name, UInt32 signature);
    private void InitializeMemberReferences();
    public IEnumerable`1<MemberReference> GetMemberReferences();
    private void InitializeConstants();
    public TypeReference ReadConstantSignature(MetadataToken token);
    public object ReadConstant(IConstantProvider owner);
    private object ReadConstantValue(ElementType etype, UInt32 signature);
    private string ReadConstantString(UInt32 signature);
    private object ReadConstantPrimitive(ElementType type, UInt32 signature);
    internal void InitializeCustomAttributes();
    public bool HasCustomAttributes(ICustomAttributeProvider owner);
    public Collection`1<CustomAttribute> ReadCustomAttributes(ICustomAttributeProvider owner);
    private void ReadCustomAttributeRange(Range range, Collection`1<CustomAttribute> custom_attributes);
    private static int RangesSize(Range[] ranges);
    public IEnumerable`1<CustomAttribute> GetCustomAttributes();
    public Byte[] ReadCustomAttributeBlob(UInt32 signature);
    public void ReadCustomAttributeSignature(CustomAttribute attribute);
    private void InitializeMarshalInfos();
    public bool HasMarshalInfo(IMarshalInfoProvider owner);
    public MarshalInfo ReadMarshalInfo(IMarshalInfoProvider owner);
    private void InitializeSecurityDeclarations();
    public bool HasSecurityDeclarations(ISecurityDeclarationProvider owner);
    public Collection`1<SecurityDeclaration> ReadSecurityDeclarations(ISecurityDeclarationProvider owner);
    private void ReadSecurityDeclarationRange(Range range, Collection`1<SecurityDeclaration> security_declarations);
    public Byte[] ReadSecurityDeclarationBlob(UInt32 signature);
    public void ReadSecurityDeclarationSignature(SecurityDeclaration declaration);
    private void ReadXmlSecurityDeclaration(UInt32 signature, SecurityDeclaration declaration);
    public Collection`1<ExportedType> ReadExportedTypes();
    private IMetadataScope GetExportedTypeScope(MetadataToken token);
    private ModuleReference GetModuleReferenceFromFile(MetadataToken token);
    private void InitializeDocuments();
    public Collection`1<SequencePoint> ReadSequencePoints(MethodDefinition method);
    public Document GetDocument(UInt32 rid);
    private void InitializeLocalScopes();
    public ScopeDebugInformation ReadScope(MethodDefinition method);
    private static bool AddScope(Collection`1<ScopeDebugInformation> scopes, ScopeDebugInformation scope);
    private ScopeDebugInformation ReadLocalScope(Row`6<UInt32, Range, Range, UInt32, UInt32, UInt32> record);
    private VariableDebugInformation ReadLocalVariable(UInt32 rid);
    private ConstantDebugInformation ReadLocalConstant(UInt32 rid);
    private void InitializeImportScopes();
    public string ReadUTF8StringBlob(UInt32 signature);
    private string ReadUnicodeStringBlob(UInt32 signature);
    private string ReadStringBlob(UInt32 signature, Encoding encoding);
    private ImportTarget ReadImportTarget(SignatureReader signature);
    private void InitializeStateMachineMethods();
    public MethodDefinition ReadStateMachineKickoffMethod(MethodDefinition method);
    private void InitializeCustomDebugInformations();
    public Collection`1<CustomDebugInformation> GetCustomDebugInformation(ICustomDebugInformationProvider provider);
    public Byte[] ReadRawEmbeddedSourceDebugInformation(UInt32 index);
    public Row`2<Byte[], bool> ReadEmbeddedSourceDebugInformation(UInt32 index);
    [CompilerGeneratedAttribute]
private MetadataToken <InitializeGenericParameters>b__106_0();
    [CompilerGeneratedAttribute]
private MetadataToken <InitializeCustomAttributes>b__141_0();
    [CompilerGeneratedAttribute]
private MetadataToken <InitializeSecurityDeclarations>b__152_0();
}
internal class Mono.Cecil.MetadataResolver : object {
    
private IAssemblyResolver assembly_resolver;
    
public IAssemblyResolver AssemblyResolver { get; }
    public MetadataResolver(IAssemblyResolver assemblyResolver);
    public IAssemblyResolver get_AssemblyResolver();
    public virtual TypeDefinition Resolve(TypeReference type);
    private static TypeDefinition GetType(ModuleDefinition module, TypeReference reference);
    private static TypeDefinition GetTypeDefinition(ModuleDefinition module, TypeReference type);
    public virtual FieldDefinition Resolve(FieldReference field);
    private FieldDefinition GetField(TypeDefinition type, FieldReference reference);
    private static FieldDefinition GetField(Collection`1<FieldDefinition> fields, FieldReference reference);
    public virtual MethodDefinition Resolve(MethodReference method);
    private MethodDefinition GetMethod(TypeDefinition type, MethodReference reference);
    public static MethodDefinition GetMethod(Collection`1<MethodDefinition> methods, MethodReference reference);
    private static bool AreSame(Collection`1<ParameterDefinition> a, Collection`1<ParameterDefinition> b);
    private static bool IsVarArgCallTo(MethodDefinition method, MethodReference reference);
    private static bool AreSame(TypeSpecification a, TypeSpecification b);
    private static bool AreSame(FunctionPointerType a, FunctionPointerType b);
    private static bool AreSame(ArrayType a, ArrayType b);
    private static bool AreSame(IModifierType a, IModifierType b);
    private static bool AreSame(GenericInstanceType a, GenericInstanceType b);
    private static bool AreSame(GenericParameter a, GenericParameter b);
    private static bool AreSame(TypeReference a, TypeReference b);
}
internal enum Mono.Cecil.MetadataScopeType : Enum {
    
public int value__;
    
public static MetadataScopeType AssemblyNameReference;
    
public static MetadataScopeType ModuleReference;
    
public static MetadataScopeType ModuleDefinition;
}
internal class Mono.Cecil.MetadataSystem : object {
    
internal AssemblyNameReference[] AssemblyReferences;
    
internal ModuleReference[] ModuleReferences;
    
internal TypeDefinition[] Types;
    
internal TypeReference[] TypeReferences;
    
internal FieldDefinition[] Fields;
    
internal MethodDefinition[] Methods;
    
internal MemberReference[] MemberReferences;
    
internal Dictionary`2<UInt32, Collection`1<UInt32>> NestedTypes;
    
internal Dictionary`2<UInt32, UInt32> ReverseNestedTypes;
    
internal Dictionary`2<UInt32, Collection`1<Row`2<UInt32, MetadataToken>>> Interfaces;
    
internal Dictionary`2<UInt32, Row`2<ushort, UInt32>> ClassLayouts;
    
internal Dictionary`2<UInt32, UInt32> FieldLayouts;
    
internal Dictionary`2<UInt32, UInt32> FieldRVAs;
    
internal Dictionary`2<MetadataToken, UInt32> FieldMarshals;
    
internal Dictionary`2<MetadataToken, Row`2<ElementType, UInt32>> Constants;
    
internal Dictionary`2<UInt32, Collection`1<MetadataToken>> Overrides;
    
internal Dictionary`2<MetadataToken, Range[]> CustomAttributes;
    
internal Dictionary`2<MetadataToken, Range[]> SecurityDeclarations;
    
internal Dictionary`2<UInt32, Range> Events;
    
internal Dictionary`2<UInt32, Range> Properties;
    
internal Dictionary`2<UInt32, Row`2<MethodSemanticsAttributes, MetadataToken>> Semantics;
    
internal Dictionary`2<UInt32, Row`3<PInvokeAttributes, UInt32, UInt32>> PInvokes;
    
internal Dictionary`2<MetadataToken, Range[]> GenericParameters;
    
internal Dictionary`2<UInt32, Collection`1<Row`2<UInt32, MetadataToken>>> GenericConstraints;
    
internal Document[] Documents;
    
internal Dictionary`2<UInt32, Collection`1<Row`6<UInt32, Range, Range, UInt32, UInt32, UInt32>>> LocalScopes;
    
internal ImportDebugInformation[] ImportScopes;
    
internal Dictionary`2<UInt32, UInt32> StateMachineMethods;
    
internal Dictionary`2<MetadataToken, Row`3[]> CustomDebugInformations;
    
private static Dictionary`2<string, Row`2<ElementType, bool>> primitive_value_types;
    private static void InitializePrimitives();
    public static void TryProcessPrimitiveTypeReference(TypeReference type);
    public static bool TryGetPrimitiveElementType(TypeDefinition type, ElementType& etype);
    private static bool TryGetPrimitiveData(TypeReference type, Row`2& primitive_data);
    public void Clear();
    public AssemblyNameReference GetAssemblyNameReference(UInt32 rid);
    public TypeDefinition GetTypeDefinition(UInt32 rid);
    public void AddTypeDefinition(TypeDefinition type);
    public TypeReference GetTypeReference(UInt32 rid);
    public void AddTypeReference(TypeReference type);
    public FieldDefinition GetFieldDefinition(UInt32 rid);
    public void AddFieldDefinition(FieldDefinition field);
    public MethodDefinition GetMethodDefinition(UInt32 rid);
    public void AddMethodDefinition(MethodDefinition method);
    public MemberReference GetMemberReference(UInt32 rid);
    public void AddMemberReference(MemberReference member);
    public bool TryGetNestedTypeMapping(TypeDefinition type, Collection`1& mapping);
    public void SetNestedTypeMapping(UInt32 type_rid, Collection`1<UInt32> mapping);
    public bool TryGetReverseNestedTypeMapping(TypeDefinition type, UInt32& declaring);
    public void SetReverseNestedTypeMapping(UInt32 nested, UInt32 declaring);
    public bool TryGetInterfaceMapping(TypeDefinition type, Collection`1& mapping);
    public void SetInterfaceMapping(UInt32 type_rid, Collection`1<Row`2<UInt32, MetadataToken>> mapping);
    public void AddPropertiesRange(UInt32 type_rid, Range range);
    public bool TryGetPropertiesRange(TypeDefinition type, Range& range);
    public void AddEventsRange(UInt32 type_rid, Range range);
    public bool TryGetEventsRange(TypeDefinition type, Range& range);
    public bool TryGetGenericParameterRanges(IGenericParameterProvider owner, Range[]& ranges);
    public bool TryGetCustomAttributeRanges(ICustomAttributeProvider owner, Range[]& ranges);
    public bool TryGetSecurityDeclarationRanges(ISecurityDeclarationProvider owner, Range[]& ranges);
    public bool TryGetGenericConstraintMapping(GenericParameter generic_parameter, Collection`1& mapping);
    public void SetGenericConstraintMapping(UInt32 gp_rid, Collection`1<Row`2<UInt32, MetadataToken>> mapping);
    public bool TryGetOverrideMapping(MethodDefinition method, Collection`1& mapping);
    public void SetOverrideMapping(UInt32 rid, Collection`1<MetadataToken> mapping);
    public Document GetDocument(UInt32 rid);
    public bool TryGetLocalScopes(MethodDefinition method, Collection`1& scopes);
    public void SetLocalScopes(UInt32 method_rid, Collection`1<Row`6<UInt32, Range, Range, UInt32, UInt32, UInt32>> records);
    public ImportDebugInformation GetImportScope(UInt32 rid);
    public bool TryGetStateMachineKickOffMethod(MethodDefinition method, UInt32& rid);
    public TypeDefinition GetFieldDeclaringType(UInt32 field_rid);
    public TypeDefinition GetMethodDeclaringType(UInt32 method_rid);
    private static TypeDefinition BinaryRangeSearch(TypeDefinition[] types, UInt32 rid, bool field);
}
internal abstract class Mono.Cecil.MetadataTable : object {
    
public int Length { get; }
    
public bool IsLarge { get; }
    public abstract virtual int get_Length();
    public bool get_IsLarge();
    public abstract virtual void Write(TableHeapBuffer buffer);
    public abstract virtual void Sort();
}
internal abstract class Mono.Cecil.MetadataTable`1 : MetadataTable {
    
internal TRow[] rows;
    
internal int length;
    
public int Length { get; }
    public sealed virtual int get_Length();
    public int AddRow(TRow row);
    private void Grow();
    public virtual void Sort();
}
internal class Mono.Cecil.MetadataToken : ValueType {
    
private UInt32 token;
    
public static MetadataToken Zero;
    
public UInt32 RID { get; }
    
public TokenType TokenType { get; }
    public MetadataToken(UInt32 token);
    public MetadataToken(TokenType type);
    public MetadataToken(TokenType type, UInt32 rid);
    public MetadataToken(TokenType type, int rid);
    private static MetadataToken();
    public UInt32 get_RID();
    public TokenType get_TokenType();
    public int ToInt32();
    public UInt32 ToUInt32();
    public virtual int GetHashCode();
    public sealed virtual bool Equals(MetadataToken other);
    public virtual bool Equals(object obj);
    public static bool op_Equality(MetadataToken one, MetadataToken other);
    public static bool op_Inequality(MetadataToken one, MetadataToken other);
    public virtual string ToString();
}
internal enum Mono.Cecil.MetadataType : Enum {
    
public byte value__;
    
public static MetadataType Void;
    
public static MetadataType Boolean;
    
public static MetadataType Char;
    
public static MetadataType SByte;
    
public static MetadataType Byte;
    
public static MetadataType Int16;
    
public static MetadataType UInt16;
    
public static MetadataType Int32;
    
public static MetadataType UInt32;
    
public static MetadataType Int64;
    
public static MetadataType UInt64;
    
public static MetadataType Single;
    
public static MetadataType Double;
    
public static MetadataType String;
    
public static MetadataType Pointer;
    
public static MetadataType ByReference;
    
public static MetadataType ValueType;
    
public static MetadataType Class;
    
public static MetadataType Var;
    
public static MetadataType Array;
    
public static MetadataType GenericInstance;
    
public static MetadataType TypedByReference;
    
public static MetadataType IntPtr;
    
public static MetadataType UIntPtr;
    
public static MetadataType FunctionPointer;
    
public static MetadataType Object;
    
public static MetadataType MVar;
    
public static MetadataType RequiredModifier;
    
public static MetadataType OptionalModifier;
    
public static MetadataType Sentinel;
    
public static MetadataType Pinned;
}
[FlagsAttribute]
internal enum Mono.Cecil.MethodAttributes : Enum {
    
public ushort value__;
    
public static MethodAttributes MemberAccessMask;
    
public static MethodAttributes CompilerControlled;
    
public static MethodAttributes Private;
    
public static MethodAttributes FamANDAssem;
    
public static MethodAttributes Assembly;
    
public static MethodAttributes Family;
    
public static MethodAttributes FamORAssem;
    
public static MethodAttributes Public;
    
public static MethodAttributes Static;
    
public static MethodAttributes Final;
    
public static MethodAttributes Virtual;
    
public static MethodAttributes HideBySig;
    
public static MethodAttributes VtableLayoutMask;
    
public static MethodAttributes ReuseSlot;
    
public static MethodAttributes NewSlot;
    
public static MethodAttributes CheckAccessOnOverride;
    
public static MethodAttributes Abstract;
    
public static MethodAttributes SpecialName;
    
public static MethodAttributes PInvokeImpl;
    
public static MethodAttributes UnmanagedExport;
    
public static MethodAttributes RTSpecialName;
    
public static MethodAttributes HasSecurity;
    
public static MethodAttributes RequireSecObject;
}
internal enum Mono.Cecil.MethodCallingConvention : Enum {
    
public byte value__;
    
public static MethodCallingConvention Default;
    
public static MethodCallingConvention C;
    
public static MethodCallingConvention StdCall;
    
public static MethodCallingConvention ThisCall;
    
public static MethodCallingConvention FastCall;
    
public static MethodCallingConvention VarArg;
    
public static MethodCallingConvention Unmanaged;
    
public static MethodCallingConvention Generic;
}
internal class Mono.Cecil.MethodDebugInformationTable : MetadataTable`1<Row`2<UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
}
internal class Mono.Cecil.MethodDefinition : MethodReference {
    
private ushort attributes;
    
private ushort impl_attributes;
    
internal Boolean modreq(System.Runtime.CompilerServices.IsVolatile) sem_attrs_ready;
    
internal MethodSemanticsAttributes sem_attrs;
    
private Collection`1<CustomAttribute> custom_attributes;
    
private Collection`1<SecurityDeclaration> security_declarations;
    
internal UInt32 rva;
    
internal PInvokeInfo pinvoke;
    
private Collection`1<MethodReference> overrides;
    
internal MethodBody body;
    
internal MethodDebugInformation debug_info;
    
internal Collection`1<CustomDebugInformation> custom_infos;
    
public string Name { get; public set; }
    
public MethodAttributes Attributes { get; public set; }
    
public MethodImplAttributes ImplAttributes { get; public set; }
    
public MethodSemanticsAttributes SemanticsAttributes { get; public set; }
    
internal MethodDefinitionProjection WindowsRuntimeProjection { get; internal set; }
    
public bool HasSecurityDeclarations { get; }
    
public Collection`1<SecurityDeclaration> SecurityDeclarations { get; }
    
public bool HasCustomAttributes { get; }
    
public Collection`1<CustomAttribute> CustomAttributes { get; }
    
public int RVA { get; }
    
public bool HasBody { get; }
    
public MethodBody Body { get; public set; }
    
public MethodDebugInformation DebugInformation { get; public set; }
    
public bool HasPInvokeInfo { get; }
    
public PInvokeInfo PInvokeInfo { get; public set; }
    
public bool HasOverrides { get; }
    
public Collection`1<MethodReference> Overrides { get; }
    
public bool HasGenericParameters { get; }
    
public Collection`1<GenericParameter> GenericParameters { get; }
    
public bool HasCustomDebugInformations { get; }
    
public Collection`1<CustomDebugInformation> CustomDebugInformations { get; }
    
public bool IsCompilerControlled { get; public set; }
    
public bool IsPrivate { get; public set; }
    
public bool IsFamilyAndAssembly { get; public set; }
    
public bool IsAssembly { get; public set; }
    
public bool IsFamily { get; public set; }
    
public bool IsFamilyOrAssembly { get; public set; }
    
public bool IsPublic { get; public set; }
    
public bool IsStatic { get; public set; }
    
public bool IsFinal { get; public set; }
    
public bool IsVirtual { get; public set; }
    
public bool IsHideBySig { get; public set; }
    
public bool IsReuseSlot { get; public set; }
    
public bool IsNewSlot { get; public set; }
    
public bool IsCheckAccessOnOverride { get; public set; }
    
public bool IsAbstract { get; public set; }
    
public bool IsSpecialName { get; public set; }
    
public bool IsPInvokeImpl { get; public set; }
    
public bool IsUnmanagedExport { get; public set; }
    
public bool IsRuntimeSpecialName { get; public set; }
    
public bool HasSecurity { get; public set; }
    
public bool IsIL { get; public set; }
    
public bool IsNative { get; public set; }
    
public bool IsRuntime { get; public set; }
    
public bool IsUnmanaged { get; public set; }
    
public bool IsManaged { get; public set; }
    
public bool IsForwardRef { get; public set; }
    
public bool IsPreserveSig { get; public set; }
    
public bool IsInternalCall { get; public set; }
    
public bool IsSynchronized { get; public set; }
    
public bool NoInlining { get; public set; }
    
public bool NoOptimization { get; public set; }
    
public bool AggressiveInlining { get; public set; }
    
public bool AggressiveOptimization { get; public set; }
    
public bool IsSetter { get; public set; }
    
public bool IsGetter { get; public set; }
    
public bool IsOther { get; public set; }
    
public bool IsAddOn { get; public set; }
    
public bool IsRemoveOn { get; public set; }
    
public bool IsFire { get; public set; }
    
public TypeDefinition DeclaringType { get; public set; }
    
public bool IsConstructor { get; }
    
public bool IsDefinition { get; }
    public MethodDefinition(string name, MethodAttributes attributes, TypeReference returnType);
    public virtual string get_Name();
    public virtual void set_Name(string value);
    public MethodAttributes get_Attributes();
    public void set_Attributes(MethodAttributes value);
    public MethodImplAttributes get_ImplAttributes();
    public void set_ImplAttributes(MethodImplAttributes value);
    public MethodSemanticsAttributes get_SemanticsAttributes();
    public void set_SemanticsAttributes(MethodSemanticsAttributes value);
    internal MethodDefinitionProjection get_WindowsRuntimeProjection();
    internal void set_WindowsRuntimeProjection(MethodDefinitionProjection value);
    internal void ReadSemantics();
    public sealed virtual bool get_HasSecurityDeclarations();
    public sealed virtual Collection`1<SecurityDeclaration> get_SecurityDeclarations();
    public sealed virtual bool get_HasCustomAttributes();
    public sealed virtual Collection`1<CustomAttribute> get_CustomAttributes();
    public int get_RVA();
    public bool get_HasBody();
    public MethodBody get_Body();
    public void set_Body(MethodBody value);
    public MethodDebugInformation get_DebugInformation();
    public void set_DebugInformation(MethodDebugInformation value);
    public bool get_HasPInvokeInfo();
    public PInvokeInfo get_PInvokeInfo();
    public void set_PInvokeInfo(PInvokeInfo value);
    public bool get_HasOverrides();
    public Collection`1<MethodReference> get_Overrides();
    public virtual bool get_HasGenericParameters();
    public virtual Collection`1<GenericParameter> get_GenericParameters();
    public sealed virtual bool get_HasCustomDebugInformations();
    public sealed virtual Collection`1<CustomDebugInformation> get_CustomDebugInformations();
    public bool get_IsCompilerControlled();
    public void set_IsCompilerControlled(bool value);
    public bool get_IsPrivate();
    public void set_IsPrivate(bool value);
    public bool get_IsFamilyAndAssembly();
    public void set_IsFamilyAndAssembly(bool value);
    public bool get_IsAssembly();
    public void set_IsAssembly(bool value);
    public bool get_IsFamily();
    public void set_IsFamily(bool value);
    public bool get_IsFamilyOrAssembly();
    public void set_IsFamilyOrAssembly(bool value);
    public bool get_IsPublic();
    public void set_IsPublic(bool value);
    public bool get_IsStatic();
    public void set_IsStatic(bool value);
    public bool get_IsFinal();
    public void set_IsFinal(bool value);
    public bool get_IsVirtual();
    public void set_IsVirtual(bool value);
    public bool get_IsHideBySig();
    public void set_IsHideBySig(bool value);
    public bool get_IsReuseSlot();
    public void set_IsReuseSlot(bool value);
    public bool get_IsNewSlot();
    public void set_IsNewSlot(bool value);
    public bool get_IsCheckAccessOnOverride();
    public void set_IsCheckAccessOnOverride(bool value);
    public bool get_IsAbstract();
    public void set_IsAbstract(bool value);
    public sealed virtual bool get_IsSpecialName();
    public sealed virtual void set_IsSpecialName(bool value);
    public bool get_IsPInvokeImpl();
    public void set_IsPInvokeImpl(bool value);
    public bool get_IsUnmanagedExport();
    public void set_IsUnmanagedExport(bool value);
    public sealed virtual bool get_IsRuntimeSpecialName();
    public sealed virtual void set_IsRuntimeSpecialName(bool value);
    public bool get_HasSecurity();
    public void set_HasSecurity(bool value);
    public bool get_IsIL();
    public void set_IsIL(bool value);
    public bool get_IsNative();
    public void set_IsNative(bool value);
    public bool get_IsRuntime();
    public void set_IsRuntime(bool value);
    public bool get_IsUnmanaged();
    public void set_IsUnmanaged(bool value);
    public bool get_IsManaged();
    public void set_IsManaged(bool value);
    public bool get_IsForwardRef();
    public void set_IsForwardRef(bool value);
    public bool get_IsPreserveSig();
    public void set_IsPreserveSig(bool value);
    public bool get_IsInternalCall();
    public void set_IsInternalCall(bool value);
    public bool get_IsSynchronized();
    public void set_IsSynchronized(bool value);
    public bool get_NoInlining();
    public void set_NoInlining(bool value);
    public bool get_NoOptimization();
    public void set_NoOptimization(bool value);
    public bool get_AggressiveInlining();
    public void set_AggressiveInlining(bool value);
    public bool get_AggressiveOptimization();
    public void set_AggressiveOptimization(bool value);
    public bool get_IsSetter();
    public void set_IsSetter(bool value);
    public bool get_IsGetter();
    public void set_IsGetter(bool value);
    public bool get_IsOther();
    public void set_IsOther(bool value);
    public bool get_IsAddOn();
    public void set_IsAddOn(bool value);
    public bool get_IsRemoveOn();
    public void set_IsRemoveOn(bool value);
    public bool get_IsFire();
    public void set_IsFire(bool value);
    public sealed virtual TypeDefinition get_DeclaringType();
    public sealed virtual void set_DeclaringType(TypeDefinition value);
    public bool get_IsConstructor();
    public virtual bool get_IsDefinition();
    public virtual MethodDefinition Resolve();
}
internal class Mono.Cecil.MethodDefinitionProjection : object {
    
public MethodAttributes Attributes;
    
public MethodImplAttributes ImplAttributes;
    
public string Name;
    
public MethodDefinitionTreatment Treatment;
    public MethodDefinitionProjection(MethodDefinition method, MethodDefinitionTreatment treatment);
}
[FlagsAttribute]
internal enum Mono.Cecil.MethodDefinitionTreatment : Enum {
    
public int value__;
    
public static MethodDefinitionTreatment None;
    
public static MethodDefinitionTreatment Abstract;
    
public static MethodDefinitionTreatment Private;
    
public static MethodDefinitionTreatment Public;
    
public static MethodDefinitionTreatment Runtime;
    
public static MethodDefinitionTreatment InternalCall;
}
[FlagsAttribute]
internal enum Mono.Cecil.MethodImplAttributes : Enum {
    
public ushort value__;
    
public static MethodImplAttributes CodeTypeMask;
    
public static MethodImplAttributes IL;
    
public static MethodImplAttributes Native;
    
public static MethodImplAttributes OPTIL;
    
public static MethodImplAttributes Runtime;
    
public static MethodImplAttributes ManagedMask;
    
public static MethodImplAttributes Unmanaged;
    
public static MethodImplAttributes Managed;
    
public static MethodImplAttributes ForwardRef;
    
public static MethodImplAttributes PreserveSig;
    
public static MethodImplAttributes InternalCall;
    
public static MethodImplAttributes Synchronized;
    
public static MethodImplAttributes NoOptimization;
    
public static MethodImplAttributes NoInlining;
    
public static MethodImplAttributes AggressiveInlining;
    
public static MethodImplAttributes AggressiveOptimization;
}
internal class Mono.Cecil.MethodImplTable : MetadataTable`1<Row`3<UInt32, UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
}
internal class Mono.Cecil.MethodReference : MemberReference {
    
internal ParameterDefinitionCollection parameters;
    
private MethodReturnType return_type;
    
private bool has_this;
    
private bool explicit_this;
    
private MethodCallingConvention calling_convention;
    
internal Collection`1<GenericParameter> generic_parameters;
    
public bool HasThis { get; public set; }
    
public bool ExplicitThis { get; public set; }
    
public MethodCallingConvention CallingConvention { get; public set; }
    
public bool HasParameters { get; }
    
public Collection`1<ParameterDefinition> Parameters { get; }
    
private IGenericParameterProvider Mono.Cecil.IGenericContext.Type { get; }
    
private IGenericParameterProvider Mono.Cecil.IGenericContext.Method { get; }
    
private GenericParameterType Mono.Cecil.IGenericParameterProvider.GenericParameterType { get; }
    
public bool HasGenericParameters { get; }
    
public Collection`1<GenericParameter> GenericParameters { get; }
    
public TypeReference ReturnType { get; public set; }
    
public MethodReturnType MethodReturnType { get; public set; }
    
public string FullName { get; }
    
public bool IsGenericInstance { get; }
    
public bool ContainsGenericParameter { get; }
    public MethodReference(string name, TypeReference returnType);
    public MethodReference(string name, TypeReference returnType, TypeReference declaringType);
    public virtual bool get_HasThis();
    public virtual void set_HasThis(bool value);
    public virtual bool get_ExplicitThis();
    public virtual void set_ExplicitThis(bool value);
    public virtual MethodCallingConvention get_CallingConvention();
    public virtual void set_CallingConvention(MethodCallingConvention value);
    public virtual bool get_HasParameters();
    public virtual Collection`1<ParameterDefinition> get_Parameters();
    private sealed virtual override IGenericParameterProvider Mono.Cecil.IGenericContext.get_Type();
    private sealed virtual override IGenericParameterProvider Mono.Cecil.IGenericContext.get_Method();
    private sealed virtual override GenericParameterType Mono.Cecil.IGenericParameterProvider.get_GenericParameterType();
    public virtual bool get_HasGenericParameters();
    public virtual Collection`1<GenericParameter> get_GenericParameters();
    public sealed virtual TypeReference get_ReturnType();
    public sealed virtual void set_ReturnType(TypeReference value);
    public virtual MethodReturnType get_MethodReturnType();
    public virtual void set_MethodReturnType(MethodReturnType value);
    public virtual string get_FullName();
    public virtual bool get_IsGenericInstance();
    public virtual bool get_ContainsGenericParameter();
    public virtual MethodReference GetElementMethod();
    protected virtual IMemberDefinition ResolveDefinition();
    public virtual MethodDefinition Resolve();
}
internal class Mono.Cecil.MethodReferenceComparer : EqualityComparer`1<MethodReference> {
    [ThreadStaticAttribute]

private static List`1<MethodReference> xComparisonStack;
    [ThreadStaticAttribute]

private static List`1<MethodReference> yComparisonStack;
    public virtual bool Equals(MethodReference x, MethodReference y);
    public virtual int GetHashCode(MethodReference obj);
    public static bool AreEqual(MethodReference x, MethodReference y);
    public static bool AreSignaturesEqual(MethodReference x, MethodReference y, TypeComparisonMode comparisonMode);
    public static int GetHashCodeFor(MethodReference obj);
}
internal class Mono.Cecil.MethodReturnType : object {
    
internal IMethodSignature method;
    
internal ParameterDefinition parameter;
    
private TypeReference return_type;
    
public IMethodSignature Method { get; }
    
public TypeReference ReturnType { get; public set; }
    
internal ParameterDefinition Parameter { get; }
    
public MetadataToken MetadataToken { get; public set; }
    
public ParameterAttributes Attributes { get; public set; }
    
public string Name { get; public set; }
    
public bool HasCustomAttributes { get; }
    
public Collection`1<CustomAttribute> CustomAttributes { get; }
    
public bool HasDefault { get; public set; }
    
public bool HasConstant { get; public set; }
    
public object Constant { get; public set; }
    
public bool HasFieldMarshal { get; public set; }
    
public bool HasMarshalInfo { get; }
    
public MarshalInfo MarshalInfo { get; public set; }
    public MethodReturnType(IMethodSignature method);
    public IMethodSignature get_Method();
    public TypeReference get_ReturnType();
    public void set_ReturnType(TypeReference value);
    internal ParameterDefinition get_Parameter();
    public sealed virtual MetadataToken get_MetadataToken();
    public sealed virtual void set_MetadataToken(MetadataToken value);
    public ParameterAttributes get_Attributes();
    public void set_Attributes(ParameterAttributes value);
    public string get_Name();
    public void set_Name(string value);
    public sealed virtual bool get_HasCustomAttributes();
    public sealed virtual Collection`1<CustomAttribute> get_CustomAttributes();
    public bool get_HasDefault();
    public void set_HasDefault(bool value);
    public sealed virtual bool get_HasConstant();
    public sealed virtual void set_HasConstant(bool value);
    public sealed virtual object get_Constant();
    public sealed virtual void set_Constant(object value);
    public bool get_HasFieldMarshal();
    public void set_HasFieldMarshal(bool value);
    public sealed virtual bool get_HasMarshalInfo();
    public sealed virtual MarshalInfo get_MarshalInfo();
    public sealed virtual void set_MarshalInfo(MarshalInfo value);
}
[FlagsAttribute]
internal enum Mono.Cecil.MethodSemanticsAttributes : Enum {
    
public ushort value__;
    
public static MethodSemanticsAttributes None;
    
public static MethodSemanticsAttributes Setter;
    
public static MethodSemanticsAttributes Getter;
    
public static MethodSemanticsAttributes Other;
    
public static MethodSemanticsAttributes AddOn;
    
public static MethodSemanticsAttributes RemoveOn;
    
public static MethodSemanticsAttributes Fire;
}
internal class Mono.Cecil.MethodSemanticsTable : SortedTable`1<Row`3<MethodSemanticsAttributes, UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
    public virtual int Compare(Row`3<MethodSemanticsAttributes, UInt32, UInt32> x, Row`3<MethodSemanticsAttributes, UInt32, UInt32> y);
}
internal abstract class Mono.Cecil.MethodSpecification : MethodReference {
    
private MethodReference method;
    
public MethodReference ElementMethod { get; }
    
public string Name { get; public set; }
    
public MethodCallingConvention CallingConvention { get; public set; }
    
public bool HasThis { get; public set; }
    
public bool ExplicitThis { get; public set; }
    
public MethodReturnType MethodReturnType { get; public set; }
    
public TypeReference DeclaringType { get; public set; }
    
public ModuleDefinition Module { get; }
    
public bool HasParameters { get; }
    
public Collection`1<ParameterDefinition> Parameters { get; }
    
public bool ContainsGenericParameter { get; }
    internal MethodSpecification(MethodReference method);
    public MethodReference get_ElementMethod();
    public virtual string get_Name();
    public virtual void set_Name(string value);
    public virtual MethodCallingConvention get_CallingConvention();
    public virtual void set_CallingConvention(MethodCallingConvention value);
    public virtual bool get_HasThis();
    public virtual void set_HasThis(bool value);
    public virtual bool get_ExplicitThis();
    public virtual void set_ExplicitThis(bool value);
    public virtual MethodReturnType get_MethodReturnType();
    public virtual void set_MethodReturnType(MethodReturnType value);
    public virtual TypeReference get_DeclaringType();
    public virtual void set_DeclaringType(TypeReference value);
    public virtual ModuleDefinition get_Module();
    public virtual bool get_HasParameters();
    public virtual Collection`1<ParameterDefinition> get_Parameters();
    public virtual bool get_ContainsGenericParameter();
    public sealed virtual MethodReference GetElementMethod();
}
internal class Mono.Cecil.MethodSpecTable : MetadataTable`1<Row`2<UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
}
internal class Mono.Cecil.MethodTable : MetadataTable`1<Row`6<UInt32, MethodImplAttributes, MethodAttributes, UInt32, UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
}
[ExtensionAttribute]
internal static class Mono.Cecil.Mixin : object {
    
public static Version ZeroVersion;
    
public static int NotResolvedMarker;
    
public static int NoDataMarker;
    
internal static object NoValue;
    
internal static object NotResolved;
    
public static string mscorlib;
    
public static string system_runtime;
    
public static string system_private_corelib;
    
public static string netstandard;
    
public static int TableCount;
    
public static int CodedIndexCount;
    private static Mixin();
    [ExtensionAttribute]
public static bool IsNullOrEmpty(T[] self);
    [ExtensionAttribute]
public static bool IsNullOrEmpty(Collection`1<T> self);
    [ExtensionAttribute]
public static T[] Resize(T[] self, int length);
    [ExtensionAttribute]
public static T[] Add(T[] self, T item);
    public static Version CheckVersion(Version version);
    [ExtensionAttribute]
public static bool TryGetUniqueDocument(MethodDebugInformation info, Document& document);
    [ExtensionAttribute]
public static void ResolveConstant(IConstantProvider self, Object& constant, ModuleDefinition module);
    [ExtensionAttribute]
public static bool GetHasCustomAttributes(ICustomAttributeProvider self, ModuleDefinition module);
    [ExtensionAttribute]
public static Collection`1<CustomAttribute> GetCustomAttributes(ICustomAttributeProvider self, Collection`1& variable, ModuleDefinition module);
    [ExtensionAttribute]
public static bool ContainsGenericParameter(IGenericInstance self);
    [ExtensionAttribute]
public static void GenericInstanceFullName(IGenericInstance self, StringBuilder builder);
    [ExtensionAttribute]
public static bool GetHasGenericParameters(IGenericParameterProvider self, ModuleDefinition module);
    [ExtensionAttribute]
public static Collection`1<GenericParameter> GetGenericParameters(IGenericParameterProvider self, Collection`1& collection, ModuleDefinition module);
    [ExtensionAttribute]
public static bool GetHasMarshalInfo(IMarshalInfoProvider self, ModuleDefinition module);
    [ExtensionAttribute]
public static MarshalInfo GetMarshalInfo(IMarshalInfoProvider self, MarshalInfo& variable, ModuleDefinition module);
    [ExtensionAttribute]
public static bool GetAttributes(UInt32 self, UInt32 attributes);
    [ExtensionAttribute]
public static UInt32 SetAttributes(UInt32 self, UInt32 attributes, bool value);
    [ExtensionAttribute]
public static bool GetMaskedAttributes(UInt32 self, UInt32 mask, UInt32 attributes);
    [ExtensionAttribute]
public static UInt32 SetMaskedAttributes(UInt32 self, UInt32 mask, UInt32 attributes, bool value);
    [ExtensionAttribute]
public static bool GetAttributes(ushort self, ushort attributes);
    [ExtensionAttribute]
public static ushort SetAttributes(ushort self, ushort attributes, bool value);
    [ExtensionAttribute]
public static bool GetMaskedAttributes(ushort self, ushort mask, UInt32 attributes);
    [ExtensionAttribute]
public static ushort SetMaskedAttributes(ushort self, ushort mask, UInt32 attributes, bool value);
    [ExtensionAttribute]
public static bool HasImplicitThis(IMethodSignature self);
    [ExtensionAttribute]
public static void MethodSignatureFullName(IMethodSignature self, StringBuilder builder);
    public static void CheckModule(ModuleDefinition module);
    [ExtensionAttribute]
public static bool TryGetAssemblyNameReference(ModuleDefinition module, AssemblyNameReference name_reference, AssemblyNameReference& assembly_reference);
    private static bool Equals(Byte[] a, Byte[] b);
    private static bool Equals(T a, T b);
    private static bool Equals(AssemblyNameReference a, AssemblyNameReference b);
    [ExtensionAttribute]
public static ParameterDefinition GetParameter(MethodBody self, int index);
    [ExtensionAttribute]
public static VariableDefinition GetVariable(MethodBody self, int index);
    [ExtensionAttribute]
public static bool GetSemantics(MethodDefinition self, MethodSemanticsAttributes semantics);
    [ExtensionAttribute]
public static void SetSemantics(MethodDefinition self, MethodSemanticsAttributes semantics, bool value);
    [ExtensionAttribute]
public static bool IsVarArg(IMethodSignature self);
    [ExtensionAttribute]
public static int GetSentinelPosition(IMethodSignature self);
    public static void CheckName(object name);
    public static void CheckName(string name);
    public static void CheckFileName(string fileName);
    public static void CheckFullName(string fullName);
    public static void CheckStream(object stream);
    public static void CheckWriteSeek(Stream stream);
    public static void CheckReadSeek(Stream stream);
    public static void CheckType(object type);
    public static void CheckType(object type, Argument argument);
    public static void CheckField(object field);
    public static void CheckMethod(object method);
    public static void CheckParameters(object parameters);
    public static UInt32 GetTimestamp();
    [ExtensionAttribute]
public static bool HasImage(ModuleDefinition self);
    [ExtensionAttribute]
public static string GetFileName(Stream self);
    [ExtensionAttribute]
public static TargetRuntime ParseRuntime(string self);
    [ExtensionAttribute]
public static string RuntimeVersionString(TargetRuntime runtime);
    [ExtensionAttribute]
public static bool IsWindowsMetadata(ModuleDefinition module);
    [ExtensionAttribute]
public static Byte[] ReadAll(Stream self);
    public static void Read(object o);
    [ExtensionAttribute]
public static bool GetHasSecurityDeclarations(ISecurityDeclarationProvider self, ModuleDefinition module);
    [ExtensionAttribute]
public static Collection`1<SecurityDeclaration> GetSecurityDeclarations(ISecurityDeclarationProvider self, Collection`1& variable, ModuleDefinition module);
    [ExtensionAttribute]
public static TypeReference GetEnumUnderlyingType(TypeDefinition self);
    [ExtensionAttribute]
public static TypeDefinition GetNestedType(TypeDefinition self, string fullname);
    [ExtensionAttribute]
public static bool IsPrimitive(ElementType self);
    [ExtensionAttribute]
public static string TypeFullName(TypeReference self);
    [ExtensionAttribute]
public static bool IsTypeOf(TypeReference self, string namespace, string name);
    [ExtensionAttribute]
public static bool IsTypeSpecification(TypeReference type);
    [ExtensionAttribute]
public static TypeDefinition CheckedResolve(TypeReference self);
    [ExtensionAttribute]
public static bool TryGetCoreLibraryReference(ModuleDefinition module, AssemblyNameReference& reference);
    [ExtensionAttribute]
public static bool IsCoreLibrary(ModuleDefinition module);
    [ExtensionAttribute]
public static void KnownValueType(TypeReference type);
    private static bool IsCoreLibrary(AssemblyNameReference reference);
    [ExtensionAttribute]
public static ImageDebugHeaderEntry GetCodeViewEntry(ImageDebugHeader header);
    [ExtensionAttribute]
public static ImageDebugHeaderEntry GetDeterministicEntry(ImageDebugHeader header);
    [ExtensionAttribute]
public static ImageDebugHeader AddDeterministicEntry(ImageDebugHeader header);
    [ExtensionAttribute]
public static ImageDebugHeaderEntry GetEmbeddedPortablePdbEntry(ImageDebugHeader header);
    [ExtensionAttribute]
public static ImageDebugHeaderEntry GetPdbChecksumEntry(ImageDebugHeader header);
    [ExtensionAttribute]
private static ImageDebugHeaderEntry GetEntry(ImageDebugHeader header, ImageDebugType type);
    public static string GetPdbFileName(string assemblyFileName);
    public static string GetMdbFileName(string assemblyFileName);
    public static bool IsPortablePdb(string fileName);
    public static bool IsPortablePdb(Stream stream);
    [ExtensionAttribute]
public static UInt32 ReadCompressedUInt32(Byte[] data, Int32& position);
    [ExtensionAttribute]
public static MetadataToken GetMetadataToken(CodedIndex self, UInt32 data);
    [ExtensionAttribute]
public static UInt32 CompressMetadataToken(CodedIndex self, MetadataToken token);
    [ExtensionAttribute]
public static int GetSize(CodedIndex self, Func`2<Table, int> counter);
    [ExtensionAttribute]
public static RSA CreateRSA(WriterParameters writer_parameters);
    private static bool TryGetKeyContainer(ISerializable key_pair, Byte[]& key, String& key_container);
}
[FlagsAttribute]
internal enum Mono.Cecil.ModuleAttributes : Enum {
    
public int value__;
    
public static ModuleAttributes ILOnly;
    
public static ModuleAttributes Required32Bit;
    
public static ModuleAttributes ILLibrary;
    
public static ModuleAttributes StrongNameSigned;
    
public static ModuleAttributes Preferred32Bit;
}
[FlagsAttribute]
internal enum Mono.Cecil.ModuleCharacteristics : Enum {
    
public int value__;
    
public static ModuleCharacteristics HighEntropyVA;
    
public static ModuleCharacteristics DynamicBase;
    
public static ModuleCharacteristics NoSEH;
    
public static ModuleCharacteristics NXCompat;
    
public static ModuleCharacteristics AppContainer;
    
public static ModuleCharacteristics TerminalServerAware;
}
internal class Mono.Cecil.ModuleDefinition : ModuleReference {
    
internal Image Image;
    
internal MetadataSystem MetadataSystem;
    
internal ReadingMode ReadingMode;
    
internal ISymbolReaderProvider SymbolReaderProvider;
    
internal ISymbolReader symbol_reader;
    
internal Disposable`1<IAssemblyResolver> assembly_resolver;
    
internal IMetadataResolver metadata_resolver;
    
internal TypeSystem type_system;
    
internal MetadataReader reader;
    
private string file_name;
    
internal string runtime_version;
    
internal ModuleKind kind;
    
private WindowsRuntimeProjections projections;
    
private MetadataKind metadata_kind;
    
private TargetRuntime runtime;
    
private TargetArchitecture architecture;
    
private ModuleAttributes attributes;
    
private ModuleCharacteristics characteristics;
    
private Guid mvid;
    
internal ushort linker_version;
    
internal ushort subsystem_major;
    
internal ushort subsystem_minor;
    
internal UInt32 timestamp;
    
internal AssemblyDefinition assembly;
    
private MethodDefinition entry_point;
    
private bool entry_point_set;
    
internal IReflectionImporter reflection_importer;
    
internal IMetadataImporter metadata_importer;
    
private Collection`1<CustomAttribute> custom_attributes;
    
private Collection`1<AssemblyNameReference> references;
    
private Collection`1<ModuleReference> modules;
    
private Collection`1<Resource> resources;
    
private Collection`1<ExportedType> exported_types;
    
private TypeDefinitionCollection types;
    
internal Collection`1<CustomDebugInformation> custom_infos;
    
internal MetadataBuilder metadata_builder;
    
private object module_lock;
    
public bool IsMain { get; }
    
public ModuleKind Kind { get; public set; }
    
public MetadataKind MetadataKind { get; public set; }
    
internal WindowsRuntimeProjections Projections { get; }
    
public TargetRuntime Runtime { get; public set; }
    
public string RuntimeVersion { get; public set; }
    
public TargetArchitecture Architecture { get; public set; }
    
public ModuleAttributes Attributes { get; public set; }
    
public ModuleCharacteristics Characteristics { get; public set; }
    [ObsoleteAttribute("Use FileName")]

public string FullyQualifiedName { get; }
    
public string FileName { get; }
    
public Guid Mvid { get; public set; }
    
internal bool HasImage { get; }
    
public bool HasSymbols { get; }
    
public ISymbolReader SymbolReader { get; }
    
public MetadataScopeType MetadataScopeType { get; }
    
public AssemblyDefinition Assembly { get; }
    
internal IReflectionImporter ReflectionImporter { get; }
    
internal IMetadataImporter MetadataImporter { get; }
    
public IAssemblyResolver AssemblyResolver { get; }
    
public IMetadataResolver MetadataResolver { get; }
    
public TypeSystem TypeSystem { get; }
    
public bool HasAssemblyReferences { get; }
    
public Collection`1<AssemblyNameReference> AssemblyReferences { get; }
    
public bool HasModuleReferences { get; }
    
public Collection`1<ModuleReference> ModuleReferences { get; }
    
public bool HasResources { get; }
    
public Collection`1<Resource> Resources { get; }
    
public bool HasCustomAttributes { get; }
    
public Collection`1<CustomAttribute> CustomAttributes { get; }
    
public bool HasTypes { get; }
    
public Collection`1<TypeDefinition> Types { get; }
    
public bool HasExportedTypes { get; }
    
public Collection`1<ExportedType> ExportedTypes { get; }
    
public MethodDefinition EntryPoint { get; public set; }
    
public bool HasCustomDebugInformations { get; }
    
public Collection`1<CustomDebugInformation> CustomDebugInformations { get; }
    
internal object SyncRoot { get; }
    
public bool HasDebugHeader { get; }
    internal ModuleDefinition(Image image);
    public bool get_IsMain();
    public ModuleKind get_Kind();
    public void set_Kind(ModuleKind value);
    public MetadataKind get_MetadataKind();
    public void set_MetadataKind(MetadataKind value);
    internal WindowsRuntimeProjections get_Projections();
    public TargetRuntime get_Runtime();
    public void set_Runtime(TargetRuntime value);
    public string get_RuntimeVersion();
    public void set_RuntimeVersion(string value);
    public TargetArchitecture get_Architecture();
    public void set_Architecture(TargetArchitecture value);
    public ModuleAttributes get_Attributes();
    public void set_Attributes(ModuleAttributes value);
    public ModuleCharacteristics get_Characteristics();
    public void set_Characteristics(ModuleCharacteristics value);
    public string get_FullyQualifiedName();
    public string get_FileName();
    public Guid get_Mvid();
    public void set_Mvid(Guid value);
    internal bool get_HasImage();
    public bool get_HasSymbols();
    public ISymbolReader get_SymbolReader();
    public virtual MetadataScopeType get_MetadataScopeType();
    public AssemblyDefinition get_Assembly();
    internal IReflectionImporter get_ReflectionImporter();
    internal IMetadataImporter get_MetadataImporter();
    public IAssemblyResolver get_AssemblyResolver();
    public IMetadataResolver get_MetadataResolver();
    public TypeSystem get_TypeSystem();
    public bool get_HasAssemblyReferences();
    public Collection`1<AssemblyNameReference> get_AssemblyReferences();
    public bool get_HasModuleReferences();
    public Collection`1<ModuleReference> get_ModuleReferences();
    public bool get_HasResources();
    public Collection`1<Resource> get_Resources();
    public sealed virtual bool get_HasCustomAttributes();
    public sealed virtual Collection`1<CustomAttribute> get_CustomAttributes();
    public bool get_HasTypes();
    public Collection`1<TypeDefinition> get_Types();
    public bool get_HasExportedTypes();
    public Collection`1<ExportedType> get_ExportedTypes();
    public MethodDefinition get_EntryPoint();
    public void set_EntryPoint(MethodDefinition value);
    public sealed virtual bool get_HasCustomDebugInformations();
    public sealed virtual Collection`1<CustomDebugInformation> get_CustomDebugInformations();
    public sealed virtual void Dispose();
    public bool HasTypeReference(string fullName);
    public bool HasTypeReference(string scope, string fullName);
    public bool TryGetTypeReference(string fullName, TypeReference& type);
    public bool TryGetTypeReference(string scope, string fullName, TypeReference& type);
    private TypeReference GetTypeReference(string scope, string fullname);
    public IEnumerable`1<TypeReference> GetTypeReferences();
    public IEnumerable`1<MemberReference> GetMemberReferences();
    public IEnumerable`1<CustomAttribute> GetCustomAttributes();
    public TypeReference GetType(string fullName, bool runtimeName);
    public TypeDefinition GetType(string fullName);
    public TypeDefinition GetType(string namespace, string name);
    public IEnumerable`1<TypeDefinition> GetTypes();
    private static IEnumerable`1<TypeDefinition> GetTypes(Collection`1<TypeDefinition> types);
    private TypeDefinition GetNestedType(string fullname);
    internal FieldDefinition Resolve(FieldReference field);
    internal MethodDefinition Resolve(MethodReference method);
    internal TypeDefinition Resolve(TypeReference type);
    private static void CheckContext(IGenericParameterProvider context, ModuleDefinition module);
    [ObsoleteAttribute("Use ImportReference", "False")]
public TypeReference Import(Type type);
    public TypeReference ImportReference(Type type);
    [ObsoleteAttribute("Use ImportReference", "False")]
public TypeReference Import(Type type, IGenericParameterProvider context);
    public TypeReference ImportReference(Type type, IGenericParameterProvider context);
    [ObsoleteAttribute("Use ImportReference", "False")]
public FieldReference Import(FieldInfo field);
    [ObsoleteAttribute("Use ImportReference", "False")]
public FieldReference Import(FieldInfo field, IGenericParameterProvider context);
    public FieldReference ImportReference(FieldInfo field);
    public FieldReference ImportReference(FieldInfo field, IGenericParameterProvider context);
    [ObsoleteAttribute("Use ImportReference", "False")]
public MethodReference Import(MethodBase method);
    [ObsoleteAttribute("Use ImportReference", "False")]
public MethodReference Import(MethodBase method, IGenericParameterProvider context);
    public MethodReference ImportReference(MethodBase method);
    public MethodReference ImportReference(MethodBase method, IGenericParameterProvider context);
    [ObsoleteAttribute("Use ImportReference", "False")]
public TypeReference Import(TypeReference type);
    [ObsoleteAttribute("Use ImportReference", "False")]
public TypeReference Import(TypeReference type, IGenericParameterProvider context);
    public TypeReference ImportReference(TypeReference type);
    public TypeReference ImportReference(TypeReference type, IGenericParameterProvider context);
    [ObsoleteAttribute("Use ImportReference", "False")]
public FieldReference Import(FieldReference field);
    [ObsoleteAttribute("Use ImportReference", "False")]
public FieldReference Import(FieldReference field, IGenericParameterProvider context);
    public FieldReference ImportReference(FieldReference field);
    public FieldReference ImportReference(FieldReference field, IGenericParameterProvider context);
    [ObsoleteAttribute("Use ImportReference", "False")]
public MethodReference Import(MethodReference method);
    [ObsoleteAttribute("Use ImportReference", "False")]
public MethodReference Import(MethodReference method, IGenericParameterProvider context);
    public MethodReference ImportReference(MethodReference method);
    public MethodReference ImportReference(MethodReference method, IGenericParameterProvider context);
    public IMetadataTokenProvider LookupToken(int token);
    public IMetadataTokenProvider LookupToken(MetadataToken token);
    public void ImmediateRead();
    internal object get_SyncRoot();
    internal void Read(TItem item, Action`2<TItem, MetadataReader> read);
    internal TRet Read(TItem item, Func`3<TItem, MetadataReader, TRet> read);
    internal TRet Read(TRet& variable, TItem item, Func`3<TItem, MetadataReader, TRet> read);
    public bool get_HasDebugHeader();
    public ImageDebugHeader GetDebugHeader();
    public static ModuleDefinition CreateModule(string name, ModuleKind kind);
    public static ModuleDefinition CreateModule(string name, ModuleParameters parameters);
    private static AssemblyNameDefinition CreateAssemblyName(string name);
    public void ReadSymbols();
    public void ReadSymbols(ISymbolReader reader);
    public void ReadSymbols(ISymbolReader reader, bool throwIfSymbolsAreNotMaching);
    public static ModuleDefinition ReadModule(string fileName);
    public static ModuleDefinition ReadModule(string fileName, ReaderParameters parameters);
    private static Stream GetFileStream(string fileName, FileMode mode, FileAccess access, FileShare share);
    public static ModuleDefinition ReadModule(Stream stream);
    public static ModuleDefinition ReadModule(Stream stream, ReaderParameters parameters);
    private static ModuleDefinition ReadModule(Disposable`1<Stream> stream, string fileName, ReaderParameters parameters);
    public void Write(string fileName);
    public void Write(string fileName, WriterParameters parameters);
    public void Write();
    public void Write(WriterParameters parameters);
    public void Write(Stream stream);
    public void Write(Stream stream, WriterParameters parameters);
}
internal enum Mono.Cecil.ModuleKind : Enum {
    
public int value__;
    
public static ModuleKind Dll;
    
public static ModuleKind Console;
    
public static ModuleKind Windows;
    
public static ModuleKind NetModule;
}
internal class Mono.Cecil.ModuleParameters : object {
    
private ModuleKind kind;
    
private TargetRuntime runtime;
    
private Nullable`1<UInt32> timestamp;
    
private TargetArchitecture architecture;
    
private IAssemblyResolver assembly_resolver;
    
private IMetadataResolver metadata_resolver;
    
private IMetadataImporterProvider metadata_importer_provider;
    
private IReflectionImporterProvider reflection_importer_provider;
    
public ModuleKind Kind { get; public set; }
    
public TargetRuntime Runtime { get; public set; }
    
public Nullable`1<UInt32> Timestamp { get; public set; }
    
public TargetArchitecture Architecture { get; public set; }
    
public IAssemblyResolver AssemblyResolver { get; public set; }
    
public IMetadataResolver MetadataResolver { get; public set; }
    
public IMetadataImporterProvider MetadataImporterProvider { get; public set; }
    
public IReflectionImporterProvider ReflectionImporterProvider { get; public set; }
    public ModuleKind get_Kind();
    public void set_Kind(ModuleKind value);
    public TargetRuntime get_Runtime();
    public void set_Runtime(TargetRuntime value);
    public Nullable`1<UInt32> get_Timestamp();
    public void set_Timestamp(Nullable`1<UInt32> value);
    public TargetArchitecture get_Architecture();
    public void set_Architecture(TargetArchitecture value);
    public IAssemblyResolver get_AssemblyResolver();
    public void set_AssemblyResolver(IAssemblyResolver value);
    public IMetadataResolver get_MetadataResolver();
    public void set_MetadataResolver(IMetadataResolver value);
    public IMetadataImporterProvider get_MetadataImporterProvider();
    public void set_MetadataImporterProvider(IMetadataImporterProvider value);
    public IReflectionImporterProvider get_ReflectionImporterProvider();
    public void set_ReflectionImporterProvider(IReflectionImporterProvider value);
    private static TargetRuntime GetCurrentRuntime();
}
internal abstract class Mono.Cecil.ModuleReader : object {
    
protected ModuleDefinition module;
    protected ModuleReader(Image image, ReadingMode mode);
    protected abstract virtual void ReadModule();
    public abstract virtual void ReadSymbols(ModuleDefinition module);
    protected void ReadModuleManifest(MetadataReader reader);
    private void ReadAssembly(MetadataReader reader);
    public static ModuleDefinition CreateModule(Image image, ReaderParameters parameters);
    private static void ReadSymbols(ModuleDefinition module, ReaderParameters parameters);
    private static void GetMetadataKind(ModuleDefinition module, ReaderParameters parameters);
    private static ModuleReader CreateModuleReader(Image image, ReadingMode mode);
}
internal class Mono.Cecil.ModuleReference : object {
    
private string name;
    
internal MetadataToken token;
    
public string Name { get; public set; }
    
public MetadataScopeType MetadataScopeType { get; }
    
public MetadataToken MetadataToken { get; public set; }
    public ModuleReference(string name);
    public sealed virtual string get_Name();
    public sealed virtual void set_Name(string value);
    public virtual MetadataScopeType get_MetadataScopeType();
    public sealed virtual MetadataToken get_MetadataToken();
    public sealed virtual void set_MetadataToken(MetadataToken value);
    public virtual string ToString();
}
internal class Mono.Cecil.ModuleRefTable : MetadataTable`1<UInt32> {
    public virtual void Write(TableHeapBuffer buffer);
}
internal class Mono.Cecil.ModuleTable : OneRowTable`1<Row`2<UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
}
internal static class Mono.Cecil.ModuleWriter : object {
    public static void WriteModule(ModuleDefinition module, Disposable`1<Stream> stream, WriterParameters parameters);
    private static void Write(ModuleDefinition module, Disposable`1<Stream> stream, WriterParameters parameters);
    private static void BuildMetadata(ModuleDefinition module, MetadataBuilder metadata);
    private static ISymbolWriter GetSymbolWriter(ModuleDefinition module, string fq_name, ISymbolWriterProvider symbol_writer_provider, WriterParameters parameters);
    private static void ComputeDeterministicMvid(ImageWriter writer, ModuleDefinition module);
}
internal enum Mono.Cecil.NativeType : Enum {
    
public int value__;
    
public static NativeType None;
    
public static NativeType Boolean;
    
public static NativeType I1;
    
public static NativeType U1;
    
public static NativeType I2;
    
public static NativeType U2;
    
public static NativeType I4;
    
public static NativeType U4;
    
public static NativeType I8;
    
public static NativeType U8;
    
public static NativeType R4;
    
public static NativeType R8;
    
public static NativeType LPStr;
    
public static NativeType Int;
    
public static NativeType UInt;
    
public static NativeType Func;
    
public static NativeType Array;
    
public static NativeType Currency;
    
public static NativeType BStr;
    
public static NativeType LPWStr;
    
public static NativeType LPTStr;
    
public static NativeType FixedSysString;
    
public static NativeType IUnknown;
    
public static NativeType IDispatch;
    
public static NativeType Struct;
    
public static NativeType IntF;
    
public static NativeType SafeArray;
    
public static NativeType FixedArray;
    
public static NativeType ByValStr;
    
public static NativeType ANSIBStr;
    
public static NativeType TBStr;
    
public static NativeType VariantBool;
    
public static NativeType ASAny;
    
public static NativeType LPStruct;
    
public static NativeType CustomMarshaler;
    
public static NativeType Error;
    
public static NativeType Max;
}
internal class Mono.Cecil.NestedClassTable : SortedTable`1<Row`2<UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
    public virtual int Compare(Row`2<UInt32, UInt32> x, Row`2<UInt32, UInt32> y);
}
internal abstract class Mono.Cecil.OneRowTable`1 : MetadataTable {
    
internal TRow row;
    
public int Length { get; }
    public sealed virtual int get_Length();
    public sealed virtual void Sort();
}
internal class Mono.Cecil.OptionalModifierType : TypeSpecification {
    
private TypeReference modifier_type;
    
public TypeReference ModifierType { get; public set; }
    
public string Name { get; }
    
public string FullName { get; }
    
private string Suffix { get; }
    
public bool IsValueType { get; public set; }
    
public bool IsOptionalModifier { get; }
    
public bool ContainsGenericParameter { get; }
    public OptionalModifierType(TypeReference modifierType, TypeReference type);
    public sealed virtual TypeReference get_ModifierType();
    public void set_ModifierType(TypeReference value);
    public virtual string get_Name();
    public virtual string get_FullName();
    private string get_Suffix();
    public virtual bool get_IsValueType();
    public virtual void set_IsValueType(bool value);
    public virtual bool get_IsOptionalModifier();
    public virtual bool get_ContainsGenericParameter();
}
[FlagsAttribute]
internal enum Mono.Cecil.ParameterAttributes : Enum {
    
public ushort value__;
    
public static ParameterAttributes None;
    
public static ParameterAttributes In;
    
public static ParameterAttributes Out;
    
public static ParameterAttributes Lcid;
    
public static ParameterAttributes Retval;
    
public static ParameterAttributes Optional;
    
public static ParameterAttributes HasDefault;
    
public static ParameterAttributes HasFieldMarshal;
    
public static ParameterAttributes Unused;
}
internal class Mono.Cecil.ParameterDefinition : ParameterReference {
    
private ushort attributes;
    
internal IMethodSignature method;
    
private object constant;
    
private Collection`1<CustomAttribute> custom_attributes;
    
private MarshalInfo marshal_info;
    
public ParameterAttributes Attributes { get; public set; }
    
public IMethodSignature Method { get; }
    
public int Sequence { get; }
    
public bool HasConstant { get; public set; }
    
public object Constant { get; public set; }
    
public bool HasCustomAttributes { get; }
    
public Collection`1<CustomAttribute> CustomAttributes { get; }
    
public bool HasMarshalInfo { get; }
    
public MarshalInfo MarshalInfo { get; public set; }
    
public bool IsIn { get; public set; }
    
public bool IsOut { get; public set; }
    
public bool IsLcid { get; public set; }
    
public bool IsReturnValue { get; public set; }
    
public bool IsOptional { get; public set; }
    
public bool HasDefault { get; public set; }
    
public bool HasFieldMarshal { get; public set; }
    internal ParameterDefinition(TypeReference parameterType, IMethodSignature method);
    public ParameterDefinition(TypeReference parameterType);
    public ParameterDefinition(string name, ParameterAttributes attributes, TypeReference parameterType);
    public ParameterAttributes get_Attributes();
    public void set_Attributes(ParameterAttributes value);
    public IMethodSignature get_Method();
    public int get_Sequence();
    public sealed virtual bool get_HasConstant();
    public sealed virtual void set_HasConstant(bool value);
    public sealed virtual object get_Constant();
    public sealed virtual void set_Constant(object value);
    public sealed virtual bool get_HasCustomAttributes();
    public sealed virtual Collection`1<CustomAttribute> get_CustomAttributes();
    public sealed virtual bool get_HasMarshalInfo();
    public sealed virtual MarshalInfo get_MarshalInfo();
    public sealed virtual void set_MarshalInfo(MarshalInfo value);
    public bool get_IsIn();
    public void set_IsIn(bool value);
    public bool get_IsOut();
    public void set_IsOut(bool value);
    public bool get_IsLcid();
    public void set_IsLcid(bool value);
    public bool get_IsReturnValue();
    public void set_IsReturnValue(bool value);
    public bool get_IsOptional();
    public void set_IsOptional(bool value);
    public bool get_HasDefault();
    public void set_HasDefault(bool value);
    public bool get_HasFieldMarshal();
    public void set_HasFieldMarshal(bool value);
    public virtual ParameterDefinition Resolve();
}
internal class Mono.Cecil.ParameterDefinitionCollection : Collection`1<ParameterDefinition> {
    
private IMethodSignature method;
    internal ParameterDefinitionCollection(IMethodSignature method);
    internal ParameterDefinitionCollection(IMethodSignature method, int capacity);
    protected virtual void OnAdd(ParameterDefinition item, int index);
    protected virtual void OnInsert(ParameterDefinition item, int index);
    protected virtual void OnSet(ParameterDefinition item, int index);
    protected virtual void OnRemove(ParameterDefinition item, int index);
}
internal abstract class Mono.Cecil.ParameterReference : object {
    
private string name;
    
internal int index;
    
protected TypeReference parameter_type;
    
internal MetadataToken token;
    
public string Name { get; public set; }
    
public int Index { get; }
    
public TypeReference ParameterType { get; public set; }
    
public MetadataToken MetadataToken { get; public set; }
    internal ParameterReference(string name, TypeReference parameterType);
    public string get_Name();
    public void set_Name(string value);
    public int get_Index();
    public TypeReference get_ParameterType();
    public void set_ParameterType(TypeReference value);
    public sealed virtual MetadataToken get_MetadataToken();
    public sealed virtual void set_MetadataToken(MetadataToken value);
    public virtual string ToString();
    public abstract virtual ParameterDefinition Resolve();
}
internal class Mono.Cecil.ParamTable : MetadataTable`1<Row`3<ParameterAttributes, ushort, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
}
internal enum Mono.Cecil.Pdb.CustomMetadataType : Enum {
    
public byte value__;
    
public static CustomMetadataType UsingInfo;
    
public static CustomMetadataType ForwardInfo;
    
public static CustomMetadataType IteratorScopes;
    
public static CustomMetadataType ForwardIterator;
}
internal class Mono.Cecil.Pdb.CustomMetadataWriter : object {
    
private SymWriter sym_writer;
    
private MemoryStream stream;
    
private BinaryStreamWriter writer;
    
private int count;
    
private static byte version;
    public CustomMetadataWriter(SymWriter sym_writer);
    public void WriteUsingInfo(ImportDebugInformation import_info);
    public void WriteForwardInfo(MetadataToken import_parent);
    public void WriteIteratorScopes(StateMachineScopeDebugInformation state_machine, MethodDebugInformation debug_info);
    public void WriteForwardIterator(TypeReference type);
    private void Write(CustomMetadataType type, Action write);
    public void WriteCustomMetadata();
    public sealed virtual void Dispose();
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("BA3FEE4C-ECB9-4e41-83B7-183FA41CD859")]
internal interface Mono.Cecil.Pdb.IMetaDataEmit {
    public abstract virtual void SetModuleProps(string szName);
    public abstract virtual void Save(string szFile, UInt32 dwSaveFlags);
    public abstract virtual void SaveToStream(IntPtr pIStream, UInt32 dwSaveFlags);
    public abstract virtual UInt32 GetSaveSize(UInt32 fSave);
    public abstract virtual UInt32 DefineTypeDef(IntPtr szTypeDef, UInt32 dwTypeDefFlags, UInt32 tkExtends, IntPtr rtkImplements);
    public abstract virtual UInt32 DefineNestedType(IntPtr szTypeDef, UInt32 dwTypeDefFlags, UInt32 tkExtends, IntPtr rtkImplements, UInt32 tdEncloser);
    public abstract virtual void SetHandler(object pUnk);
    public abstract virtual UInt32 DefineMethod(UInt32 td, IntPtr zName, UInt32 dwMethodFlags, IntPtr pvSigBlob, UInt32 cbSigBlob, UInt32 ulCodeRVA, UInt32 dwImplFlags);
    public abstract virtual void DefineMethodImpl(UInt32 td, UInt32 tkBody, UInt32 tkDecl);
    public abstract virtual UInt32 DefineTypeRefByName(UInt32 tkResolutionScope, IntPtr szName);
    public abstract virtual UInt32 DefineImportType(IntPtr pAssemImport, IntPtr pbHashValue, UInt32 cbHashValue, IMetaDataImport pImport, UInt32 tdImport, IntPtr pAssemEmit);
    public abstract virtual UInt32 DefineMemberRef(UInt32 tkImport, string szName, IntPtr pvSigBlob, UInt32 cbSigBlob);
    public abstract virtual UInt32 DefineImportMember(IntPtr pAssemImport, IntPtr pbHashValue, UInt32 cbHashValue, IMetaDataImport pImport, UInt32 mbMember, IntPtr pAssemEmit, UInt32 tkParent);
    public abstract virtual UInt32 DefineEvent(UInt32 td, string szEvent, UInt32 dwEventFlags, UInt32 tkEventType, UInt32 mdAddOn, UInt32 mdRemoveOn, UInt32 mdFire, IntPtr rmdOtherMethods);
    public abstract virtual void SetClassLayout(UInt32 td, UInt32 dwPackSize, IntPtr rFieldOffsets, UInt32 ulClassSize);
    public abstract virtual void DeleteClassLayout(UInt32 td);
    public abstract virtual void SetFieldMarshal(UInt32 tk, IntPtr pvNativeType, UInt32 cbNativeType);
    public abstract virtual void DeleteFieldMarshal(UInt32 tk);
    public abstract virtual UInt32 DefinePermissionSet(UInt32 tk, UInt32 dwAction, IntPtr pvPermission, UInt32 cbPermission);
    public abstract virtual void SetRVA(UInt32 md, UInt32 ulRVA);
    public abstract virtual UInt32 GetTokenFromSig(IntPtr pvSig, UInt32 cbSig);
    public abstract virtual UInt32 DefineModuleRef(string szName);
    public abstract virtual void SetParent(UInt32 mr, UInt32 tk);
    public abstract virtual UInt32 GetTokenFromTypeSpec(IntPtr pvSig, UInt32 cbSig);
    public abstract virtual void SaveToMemory(IntPtr pbData, UInt32 cbData);
    public abstract virtual UInt32 DefineUserString(string szString, UInt32 cchString);
    public abstract virtual void DeleteToken(UInt32 tkObj);
    public abstract virtual void SetMethodProps(UInt32 md, UInt32 dwMethodFlags, UInt32 ulCodeRVA, UInt32 dwImplFlags);
    public abstract virtual void SetTypeDefProps(UInt32 td, UInt32 dwTypeDefFlags, UInt32 tkExtends, IntPtr rtkImplements);
    public abstract virtual void SetEventProps(UInt32 ev, UInt32 dwEventFlags, UInt32 tkEventType, UInt32 mdAddOn, UInt32 mdRemoveOn, UInt32 mdFire, IntPtr rmdOtherMethods);
    public abstract virtual UInt32 SetPermissionSetProps(UInt32 tk, UInt32 dwAction, IntPtr pvPermission, UInt32 cbPermission);
    public abstract virtual void DefinePinvokeMap(UInt32 tk, UInt32 dwMappingFlags, string szImportName, UInt32 mrImportDLL);
    public abstract virtual void SetPinvokeMap(UInt32 tk, UInt32 dwMappingFlags, string szImportName, UInt32 mrImportDLL);
    public abstract virtual void DeletePinvokeMap(UInt32 tk);
    public abstract virtual UInt32 DefineCustomAttribute(UInt32 tkObj, UInt32 tkType, IntPtr pCustomAttribute, UInt32 cbCustomAttribute);
    public abstract virtual void SetCustomAttributeValue(UInt32 pcv, IntPtr pCustomAttribute, UInt32 cbCustomAttribute);
    public abstract virtual UInt32 DefineField(UInt32 td, string szName, UInt32 dwFieldFlags, IntPtr pvSigBlob, UInt32 cbSigBlob, UInt32 dwCPlusTypeFlag, IntPtr pValue, UInt32 cchValue);
    public abstract virtual UInt32 DefineProperty(UInt32 td, string szProperty, UInt32 dwPropFlags, IntPtr pvSig, UInt32 cbSig, UInt32 dwCPlusTypeFlag, IntPtr pValue, UInt32 cchValue, UInt32 mdSetter, UInt32 mdGetter, IntPtr rmdOtherMethods);
    public abstract virtual UInt32 DefineParam(UInt32 md, UInt32 ulParamSeq, string szName, UInt32 dwParamFlags, UInt32 dwCPlusTypeFlag, IntPtr pValue, UInt32 cchValue);
    public abstract virtual void SetFieldProps(UInt32 fd, UInt32 dwFieldFlags, UInt32 dwCPlusTypeFlag, IntPtr pValue, UInt32 cchValue);
    public abstract virtual void SetPropertyProps(UInt32 pr, UInt32 dwPropFlags, UInt32 dwCPlusTypeFlag, IntPtr pValue, UInt32 cchValue, UInt32 mdSetter, UInt32 mdGetter, IntPtr rmdOtherMethods);
    public abstract virtual void SetParamProps(UInt32 pd, string szName, UInt32 dwParamFlags, UInt32 dwCPlusTypeFlag, IntPtr pValue, UInt32 cchValue);
    public abstract virtual UInt32 DefineSecurityAttributeSet(UInt32 tkObj, IntPtr rSecAttrs, UInt32 cSecAttrs);
    public abstract virtual void ApplyEditAndContinue(object pImport);
    public abstract virtual UInt32 TranslateSigWithScope(IntPtr pAssemImport, IntPtr pbHashValue, UInt32 cbHashValue, IMetaDataImport import, IntPtr pbSigBlob, UInt32 cbSigBlob, IntPtr pAssemEmit, IMetaDataEmit emit, IntPtr pvTranslatedSig, UInt32 cbTranslatedSigMax);
    public abstract virtual void SetMethodImplFlags(UInt32 md, UInt32 dwImplFlags);
    public abstract virtual void SetFieldRVA(UInt32 fd, UInt32 ulRVA);
    public abstract virtual void Merge(IMetaDataImport pImport, IntPtr pHostMapToken, object pHandler);
    public abstract virtual void MergeEnd();
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("7DAC8207-D3AE-4c75-9B67-92801A497D44")]
internal interface Mono.Cecil.Pdb.IMetaDataImport {
    public abstract virtual void CloseEnum(UInt32 hEnum);
    public abstract virtual UInt32 CountEnum(UInt32 hEnum);
    public abstract virtual void ResetEnum(UInt32 hEnum, UInt32 ulPos);
    public abstract virtual UInt32 EnumTypeDefs(UInt32& phEnum, UInt32[] rTypeDefs, UInt32 cMax);
    public abstract virtual UInt32 EnumInterfaceImpls(UInt32& phEnum, UInt32 td, UInt32[] rImpls, UInt32 cMax);
    public abstract virtual UInt32 EnumTypeRefs(UInt32& phEnum, UInt32[] rTypeRefs, UInt32 cMax);
    public abstract virtual UInt32 FindTypeDefByName(string szTypeDef, UInt32 tkEnclosingClass);
    public abstract virtual Guid GetScopeProps(StringBuilder szName, UInt32 cchName, UInt32& pchName);
    public abstract virtual UInt32 GetModuleFromScope();
    public abstract virtual UInt32 GetTypeDefProps(UInt32 td, Char* szTypeDef, UInt32 cchTypeDef, UInt32* pchTypeDef, UInt32* pdwTypeDefFlags, UInt32* ptkExtends);
    public abstract virtual UInt32 GetInterfaceImplProps(UInt32 iiImpl, UInt32& pClass);
    public abstract virtual UInt32 GetTypeRefProps(UInt32 tr, UInt32& ptkResolutionScope, StringBuilder szName, UInt32 cchName);
    public abstract virtual UInt32 ResolveTypeRef(UInt32 tr, Guid& riid, Object& ppIScope);
    public abstract virtual UInt32 EnumMembers(UInt32& phEnum, UInt32 cl, UInt32[] rMembers, UInt32 cMax);
    public abstract virtual UInt32 EnumMembersWithName(UInt32& phEnum, UInt32 cl, string szName, UInt32[] rMembers, UInt32 cMax);
    public abstract virtual UInt32 EnumMethods(UInt32& phEnum, UInt32 cl, IntPtr rMethods, UInt32 cMax);
    public abstract virtual UInt32 EnumMethodsWithName(UInt32& phEnum, UInt32 cl, string szName, UInt32[] rMethods, UInt32 cMax);
    public abstract virtual UInt32 EnumFields(UInt32& phEnum, UInt32 cl, IntPtr rFields, UInt32 cMax);
    public abstract virtual UInt32 EnumFieldsWithName(UInt32& phEnum, UInt32 cl, string szName, UInt32[] rFields, UInt32 cMax);
    public abstract virtual UInt32 EnumParams(UInt32& phEnum, UInt32 mb, UInt32[] rParams, UInt32 cMax);
    public abstract virtual UInt32 EnumMemberRefs(UInt32& phEnum, UInt32 tkParent, UInt32[] rMemberRefs, UInt32 cMax);
    public abstract virtual UInt32 EnumMethodImpls(UInt32& phEnum, UInt32 td, UInt32[] rMethodBody, UInt32[] rMethodDecl, UInt32 cMax);
    public abstract virtual UInt32 EnumPermissionSets(UInt32& phEnum, UInt32 tk, UInt32 dwActions, UInt32[] rPermission, UInt32 cMax);
    public abstract virtual UInt32 FindMember(UInt32 td, string szName, Byte[] pvSigBlob, UInt32 cbSigBlob);
    public abstract virtual UInt32 FindMethod(UInt32 td, string szName, Byte[] pvSigBlob, UInt32 cbSigBlob);
    public abstract virtual UInt32 FindField(UInt32 td, string szName, Byte[] pvSigBlob, UInt32 cbSigBlob);
    public abstract virtual UInt32 FindMemberRef(UInt32 td, string szName, Byte[] pvSigBlob, UInt32 cbSigBlob);
    public abstract virtual UInt32 GetMethodProps(UInt32 mb, UInt32* pClass, Char* szMethod, UInt32 cchMethod, UInt32* pchMethod, UInt32* pdwAttr, IntPtr ppvSigBlob, IntPtr pcbSigBlob, UInt32* pulCodeRVA, UInt32* pdwImplFlags);
    public abstract virtual UInt32 GetMemberRefProps(UInt32 mr, UInt32& ptk, StringBuilder szMember, UInt32 cchMember, UInt32& pchMember, IntPtr& ppvSigBlob);
    public abstract virtual UInt32 EnumProperties(UInt32& phEnum, UInt32 td, IntPtr rProperties, UInt32 cMax);
    public abstract virtual UInt32 EnumEvents(UInt32& phEnum, UInt32 td, IntPtr rEvents, UInt32 cMax);
    public abstract virtual UInt32 GetEventProps(UInt32 ev, UInt32& pClass, StringBuilder szEvent, UInt32 cchEvent, UInt32& pchEvent, UInt32& pdwEventFlags, UInt32& ptkEventType, UInt32& pmdAddOn, UInt32& pmdRemoveOn, UInt32& pmdFire, UInt32[] rmdOtherMethod, UInt32 cMax);
    public abstract virtual UInt32 EnumMethodSemantics(UInt32& phEnum, UInt32 mb, UInt32[] rEventProp, UInt32 cMax);
    public abstract virtual UInt32 GetMethodSemantics(UInt32 mb, UInt32 tkEventProp);
    public abstract virtual UInt32 GetClassLayout(UInt32 td, UInt32& pdwPackSize, IntPtr rFieldOffset, UInt32 cMax, UInt32& pcFieldOffset);
    public abstract virtual UInt32 GetFieldMarshal(UInt32 tk, IntPtr& ppvNativeType);
    public abstract virtual UInt32 GetRVA(UInt32 tk, UInt32& pulCodeRVA);
    public abstract virtual UInt32 GetPermissionSetProps(UInt32 pm, UInt32& pdwAction, IntPtr& ppvPermission);
    public abstract virtual UInt32 GetSigFromToken(UInt32 mdSig, IntPtr& ppvSig);
    public abstract virtual UInt32 GetModuleRefProps(UInt32 mur, StringBuilder szName, UInt32 cchName);
    public abstract virtual UInt32 EnumModuleRefs(UInt32& phEnum, UInt32[] rModuleRefs, UInt32 cmax);
    public abstract virtual UInt32 GetTypeSpecFromToken(UInt32 typespec, IntPtr& ppvSig);
    public abstract virtual UInt32 GetNameFromToken(UInt32 tk);
    public abstract virtual UInt32 EnumUnresolvedMethods(UInt32& phEnum, UInt32[] rMethods, UInt32 cMax);
    public abstract virtual UInt32 GetUserString(UInt32 stk, StringBuilder szString, UInt32 cchString);
    public abstract virtual UInt32 GetPinvokeMap(UInt32 tk, UInt32& pdwMappingFlags, StringBuilder szImportName, UInt32 cchImportName, UInt32& pchImportName);
    public abstract virtual UInt32 EnumSignatures(UInt32& phEnum, UInt32[] rSignatures, UInt32 cmax);
    public abstract virtual UInt32 EnumTypeSpecs(UInt32& phEnum, UInt32[] rTypeSpecs, UInt32 cmax);
    public abstract virtual UInt32 EnumUserStrings(UInt32& phEnum, UInt32[] rStrings, UInt32 cmax);
    public abstract virtual int GetParamForMethodIndex(UInt32 md, UInt32 ulParamSeq, UInt32& pParam);
    public abstract virtual UInt32 EnumCustomAttributes(UInt32& phEnum, UInt32 tk, UInt32 tkType, UInt32[] rCustomAttributes, UInt32 cMax);
    public abstract virtual UInt32 GetCustomAttributeProps(UInt32 cv, UInt32& ptkObj, UInt32& ptkType, IntPtr& ppBlob);
    public abstract virtual UInt32 FindTypeRef(UInt32 tkResolutionScope, string szName);
    public abstract virtual UInt32 GetMemberProps(UInt32 mb, UInt32& pClass, StringBuilder szMember, UInt32 cchMember, UInt32& pchMember, UInt32& pdwAttr, IntPtr& ppvSigBlob, UInt32& pcbSigBlob, UInt32& pulCodeRVA, UInt32& pdwImplFlags, UInt32& pdwCPlusTypeFlag, IntPtr& ppValue);
    public abstract virtual UInt32 GetFieldProps(UInt32 mb, UInt32& pClass, StringBuilder szField, UInt32 cchField, UInt32& pchField, UInt32& pdwAttr, IntPtr& ppvSigBlob, UInt32& pcbSigBlob, UInt32& pdwCPlusTypeFlag, IntPtr& ppValue);
    public abstract virtual UInt32 GetPropertyProps(UInt32 prop, UInt32& pClass, StringBuilder szProperty, UInt32 cchProperty, UInt32& pchProperty, UInt32& pdwPropFlags, IntPtr& ppvSig, UInt32& pbSig, UInt32& pdwCPlusTypeFlag, IntPtr& ppDefaultValue, UInt32& pcchDefaultValue, UInt32& pmdSetter, UInt32& pmdGetter, UInt32[] rmdOtherMethod, UInt32 cMax);
    public abstract virtual UInt32 GetParamProps(UInt32 tk, UInt32& pmd, UInt32& pulSequence, StringBuilder szName, UInt32 cchName, UInt32& pchName, UInt32& pdwAttr, UInt32& pdwCPlusTypeFlag, IntPtr& ppValue);
    public abstract virtual UInt32 GetCustomAttributeByName(UInt32 tkObj, string szName, IntPtr& ppData);
    public abstract virtual bool IsValidToken(UInt32 tk);
    public abstract virtual UInt32 GetNestedClassProps(UInt32 tdNestedClass, UInt32* ptdEnclosingClass);
    public abstract virtual UInt32 GetNativeCallConvFromSig(IntPtr pvSig, UInt32 cbSig);
    public abstract virtual int IsGlobal(UInt32 pd);
}
[GuidAttribute("B01FAFEB-C450-3A4D-BEEC-B4CEEC01E006")]
[InterfaceTypeAttribute("1")]
internal interface Mono.Cecil.Pdb.ISymUnmanagedDocumentWriter {
    public abstract virtual void SetSource(UInt32 sourceSize, Byte[] source);
    public abstract virtual void SetCheckSum(Guid algorithmId, UInt32 checkSumSize, Byte[] checkSum);
}
[GuidAttribute("0B97726E-9E6D-4f05-9A26-424022093CAA")]
[InterfaceTypeAttribute("1")]
internal interface Mono.Cecil.Pdb.ISymUnmanagedWriter2 {
    public abstract virtual void DefineDocument(string url, Guid& langauge, Guid& languageVendor, Guid& documentType, ISymUnmanagedDocumentWriter& pRetVal);
    public abstract virtual void SetUserEntryPoint(int methodToken);
    public abstract virtual void OpenMethod(int methodToken);
    public abstract virtual void CloseMethod();
    public abstract virtual void OpenScope(int startOffset, Int32& pRetVal);
    public abstract virtual void CloseScope(int endOffset);
    public abstract virtual void SetScopeRange_Placeholder();
    public abstract virtual void DefineLocalVariable_Placeholder();
    public abstract virtual void DefineParameter_Placeholder();
    public abstract virtual void DefineField_Placeholder();
    public abstract virtual void DefineGlobalVariable_Placeholder();
    public abstract virtual void Close();
    public abstract virtual void SetSymAttribute(UInt32 parent, string name, UInt32 data, IntPtr signature);
    public abstract virtual void OpenNamespace(string name);
    public abstract virtual void CloseNamespace();
    public abstract virtual void UsingNamespace(string fullName);
    public abstract virtual void SetMethodSourceRange_Placeholder();
    public abstract virtual void Initialize(object emitter, string filename, IStream pIStream, bool fFullBuild);
    public abstract virtual void GetDebugInfo(ImageDebugDirectory& pIDD, int cData, Int32& pcData, Byte[] data);
    public abstract virtual void DefineSequencePoints(ISymUnmanagedDocumentWriter document, int spCount, Int32[] offsets, Int32[] lines, Int32[] columns, Int32[] endLines, Int32[] endColumns);
    public abstract virtual void RemapToken_Placeholder();
    public abstract virtual void Initialize2_Placeholder();
    public abstract virtual void DefineConstant_Placeholder();
    public abstract virtual void Abort_Placeholder();
    public abstract virtual void DefineLocalVariable2(string name, int attributes, int sigToken, int addrKind, int addr1, int addr2, int addr3, int startOffset, int endOffset);
    public abstract virtual void DefineGlobalVariable2_Placeholder();
    public abstract virtual void DefineConstant2(string name, object variant, int sigToken);
}
internal class Mono.Cecil.Pdb.ModuleMetadata : object {
    
private ModuleDefinition module;
    
private Dictionary`2<UInt32, TypeDefinition> types;
    
private Dictionary`2<UInt32, MethodDefinition> methods;
    
private static UInt32 S_OK;
    
private static UInt32 E_FAIL;
    public ModuleMetadata(ModuleDefinition module);
    private bool TryGetType(UInt32 token, TypeDefinition& type);
    private bool TryGetMethod(UInt32 token, MethodDefinition& method);
    private void InitializeMetadata(ModuleDefinition module);
    private void InitializeMethods(TypeDefinition type);
    public sealed virtual void SetModuleProps(string szName);
    public sealed virtual void Save(string szFile, UInt32 dwSaveFlags);
    public sealed virtual void SaveToStream(IntPtr pIStream, UInt32 dwSaveFlags);
    public sealed virtual UInt32 GetSaveSize(UInt32 fSave);
    public sealed virtual UInt32 DefineTypeDef(IntPtr szTypeDef, UInt32 dwTypeDefFlags, UInt32 tkExtends, IntPtr rtkImplements);
    public sealed virtual UInt32 DefineNestedType(IntPtr szTypeDef, UInt32 dwTypeDefFlags, UInt32 tkExtends, IntPtr rtkImplements, UInt32 tdEncloser);
    public sealed virtual void SetHandler(object pUnk);
    public sealed virtual UInt32 DefineMethod(UInt32 td, IntPtr zName, UInt32 dwMethodFlags, IntPtr pvSigBlob, UInt32 cbSigBlob, UInt32 ulCodeRVA, UInt32 dwImplFlags);
    public sealed virtual void DefineMethodImpl(UInt32 td, UInt32 tkBody, UInt32 tkDecl);
    public sealed virtual UInt32 DefineTypeRefByName(UInt32 tkResolutionScope, IntPtr szName);
    public sealed virtual UInt32 DefineImportType(IntPtr pAssemImport, IntPtr pbHashValue, UInt32 cbHashValue, IMetaDataImport pImport, UInt32 tdImport, IntPtr pAssemEmit);
    public sealed virtual UInt32 DefineMemberRef(UInt32 tkImport, string szName, IntPtr pvSigBlob, UInt32 cbSigBlob);
    public sealed virtual UInt32 DefineImportMember(IntPtr pAssemImport, IntPtr pbHashValue, UInt32 cbHashValue, IMetaDataImport pImport, UInt32 mbMember, IntPtr pAssemEmit, UInt32 tkParent);
    public sealed virtual UInt32 DefineEvent(UInt32 td, string szEvent, UInt32 dwEventFlags, UInt32 tkEventType, UInt32 mdAddOn, UInt32 mdRemoveOn, UInt32 mdFire, IntPtr rmdOtherMethods);
    public sealed virtual void SetClassLayout(UInt32 td, UInt32 dwPackSize, IntPtr rFieldOffsets, UInt32 ulClassSize);
    public sealed virtual void DeleteClassLayout(UInt32 td);
    public sealed virtual void SetFieldMarshal(UInt32 tk, IntPtr pvNativeType, UInt32 cbNativeType);
    public sealed virtual void DeleteFieldMarshal(UInt32 tk);
    public sealed virtual UInt32 DefinePermissionSet(UInt32 tk, UInt32 dwAction, IntPtr pvPermission, UInt32 cbPermission);
    public sealed virtual void SetRVA(UInt32 md, UInt32 ulRVA);
    public sealed virtual UInt32 GetTokenFromSig(IntPtr pvSig, UInt32 cbSig);
    public sealed virtual UInt32 DefineModuleRef(string szName);
    public sealed virtual void SetParent(UInt32 mr, UInt32 tk);
    public sealed virtual UInt32 GetTokenFromTypeSpec(IntPtr pvSig, UInt32 cbSig);
    public sealed virtual void SaveToMemory(IntPtr pbData, UInt32 cbData);
    public sealed virtual UInt32 DefineUserString(string szString, UInt32 cchString);
    public sealed virtual void DeleteToken(UInt32 tkObj);
    public sealed virtual void SetMethodProps(UInt32 md, UInt32 dwMethodFlags, UInt32 ulCodeRVA, UInt32 dwImplFlags);
    public sealed virtual void SetTypeDefProps(UInt32 td, UInt32 dwTypeDefFlags, UInt32 tkExtends, IntPtr rtkImplements);
    public sealed virtual void SetEventProps(UInt32 ev, UInt32 dwEventFlags, UInt32 tkEventType, UInt32 mdAddOn, UInt32 mdRemoveOn, UInt32 mdFire, IntPtr rmdOtherMethods);
    public sealed virtual UInt32 SetPermissionSetProps(UInt32 tk, UInt32 dwAction, IntPtr pvPermission, UInt32 cbPermission);
    public sealed virtual void DefinePinvokeMap(UInt32 tk, UInt32 dwMappingFlags, string szImportName, UInt32 mrImportDLL);
    public sealed virtual void SetPinvokeMap(UInt32 tk, UInt32 dwMappingFlags, string szImportName, UInt32 mrImportDLL);
    public sealed virtual void DeletePinvokeMap(UInt32 tk);
    public sealed virtual UInt32 DefineCustomAttribute(UInt32 tkObj, UInt32 tkType, IntPtr pCustomAttribute, UInt32 cbCustomAttribute);
    public sealed virtual void SetCustomAttributeValue(UInt32 pcv, IntPtr pCustomAttribute, UInt32 cbCustomAttribute);
    public sealed virtual UInt32 DefineField(UInt32 td, string szName, UInt32 dwFieldFlags, IntPtr pvSigBlob, UInt32 cbSigBlob, UInt32 dwCPlusTypeFlag, IntPtr pValue, UInt32 cchValue);
    public sealed virtual UInt32 DefineProperty(UInt32 td, string szProperty, UInt32 dwPropFlags, IntPtr pvSig, UInt32 cbSig, UInt32 dwCPlusTypeFlag, IntPtr pValue, UInt32 cchValue, UInt32 mdSetter, UInt32 mdGetter, IntPtr rmdOtherMethods);
    public sealed virtual UInt32 DefineParam(UInt32 md, UInt32 ulParamSeq, string szName, UInt32 dwParamFlags, UInt32 dwCPlusTypeFlag, IntPtr pValue, UInt32 cchValue);
    public sealed virtual void SetFieldProps(UInt32 fd, UInt32 dwFieldFlags, UInt32 dwCPlusTypeFlag, IntPtr pValue, UInt32 cchValue);
    public sealed virtual void SetPropertyProps(UInt32 pr, UInt32 dwPropFlags, UInt32 dwCPlusTypeFlag, IntPtr pValue, UInt32 cchValue, UInt32 mdSetter, UInt32 mdGetter, IntPtr rmdOtherMethods);
    public sealed virtual void SetParamProps(UInt32 pd, string szName, UInt32 dwParamFlags, UInt32 dwCPlusTypeFlag, IntPtr pValue, UInt32 cchValue);
    public sealed virtual UInt32 DefineSecurityAttributeSet(UInt32 tkObj, IntPtr rSecAttrs, UInt32 cSecAttrs);
    public sealed virtual void ApplyEditAndContinue(object pImport);
    public sealed virtual UInt32 TranslateSigWithScope(IntPtr pAssemImport, IntPtr pbHashValue, UInt32 cbHashValue, IMetaDataImport import, IntPtr pbSigBlob, UInt32 cbSigBlob, IntPtr pAssemEmit, IMetaDataEmit emit, IntPtr pvTranslatedSig, UInt32 cbTranslatedSigMax);
    public sealed virtual void SetMethodImplFlags(UInt32 md, UInt32 dwImplFlags);
    public sealed virtual void SetFieldRVA(UInt32 fd, UInt32 ulRVA);
    public sealed virtual void Merge(IMetaDataImport pImport, IntPtr pHostMapToken, object pHandler);
    public sealed virtual void MergeEnd();
    public sealed virtual void CloseEnum(UInt32 hEnum);
    public sealed virtual UInt32 CountEnum(UInt32 hEnum);
    public sealed virtual void ResetEnum(UInt32 hEnum, UInt32 ulPos);
    public sealed virtual UInt32 EnumTypeDefs(UInt32& phEnum, UInt32[] rTypeDefs, UInt32 cMax);
    public sealed virtual UInt32 EnumInterfaceImpls(UInt32& phEnum, UInt32 td, UInt32[] rImpls, UInt32 cMax);
    public sealed virtual UInt32 EnumTypeRefs(UInt32& phEnum, UInt32[] rTypeRefs, UInt32 cMax);
    public sealed virtual UInt32 FindTypeDefByName(string szTypeDef, UInt32 tkEnclosingClass);
    public sealed virtual Guid GetScopeProps(StringBuilder szName, UInt32 cchName, UInt32& pchName);
    public sealed virtual UInt32 GetModuleFromScope();
    public sealed virtual UInt32 GetTypeDefProps(UInt32 td, Char* szTypeDef, UInt32 cchTypeDef, UInt32* pchTypeDef, UInt32* pdwTypeDefFlags, UInt32* ptkExtends);
    public sealed virtual UInt32 GetInterfaceImplProps(UInt32 iiImpl, UInt32& pClass);
    public sealed virtual UInt32 GetTypeRefProps(UInt32 tr, UInt32& ptkResolutionScope, StringBuilder szName, UInt32 cchName);
    public sealed virtual UInt32 ResolveTypeRef(UInt32 tr, Guid& riid, Object& ppIScope);
    public sealed virtual UInt32 EnumMembers(UInt32& phEnum, UInt32 cl, UInt32[] rMembers, UInt32 cMax);
    public sealed virtual UInt32 EnumMembersWithName(UInt32& phEnum, UInt32 cl, string szName, UInt32[] rMembers, UInt32 cMax);
    public sealed virtual UInt32 EnumMethods(UInt32& phEnum, UInt32 cl, IntPtr rMethods, UInt32 cMax);
    public sealed virtual UInt32 EnumMethodsWithName(UInt32& phEnum, UInt32 cl, string szName, UInt32[] rMethods, UInt32 cMax);
    public sealed virtual UInt32 EnumFields(UInt32& phEnum, UInt32 cl, IntPtr rFields, UInt32 cMax);
    public sealed virtual UInt32 EnumFieldsWithName(UInt32& phEnum, UInt32 cl, string szName, UInt32[] rFields, UInt32 cMax);
    public sealed virtual UInt32 EnumParams(UInt32& phEnum, UInt32 mb, UInt32[] rParams, UInt32 cMax);
    public sealed virtual UInt32 EnumMemberRefs(UInt32& phEnum, UInt32 tkParent, UInt32[] rMemberRefs, UInt32 cMax);
    public sealed virtual UInt32 EnumMethodImpls(UInt32& phEnum, UInt32 td, UInt32[] rMethodBody, UInt32[] rMethodDecl, UInt32 cMax);
    public sealed virtual UInt32 EnumPermissionSets(UInt32& phEnum, UInt32 tk, UInt32 dwActions, UInt32[] rPermission, UInt32 cMax);
    public sealed virtual UInt32 FindMember(UInt32 td, string szName, Byte[] pvSigBlob, UInt32 cbSigBlob);
    public sealed virtual UInt32 FindMethod(UInt32 td, string szName, Byte[] pvSigBlob, UInt32 cbSigBlob);
    public sealed virtual UInt32 FindField(UInt32 td, string szName, Byte[] pvSigBlob, UInt32 cbSigBlob);
    public sealed virtual UInt32 FindMemberRef(UInt32 td, string szName, Byte[] pvSigBlob, UInt32 cbSigBlob);
    public sealed virtual UInt32 GetMethodProps(UInt32 mb, UInt32* pClass, Char* szMethod, UInt32 cchMethod, UInt32* pchMethod, UInt32* pdwAttr, IntPtr ppvSigBlob, IntPtr pcbSigBlob, UInt32* pulCodeRVA, UInt32* pdwImplFlags);
    private static void WriteNameBuffer(string name, Char* buffer, UInt32 bufferLength, UInt32* actualLength);
    public sealed virtual UInt32 GetMemberRefProps(UInt32 mr, UInt32& ptk, StringBuilder szMember, UInt32 cchMember, UInt32& pchMember, IntPtr& ppvSigBlob);
    public sealed virtual UInt32 EnumProperties(UInt32& phEnum, UInt32 td, IntPtr rProperties, UInt32 cMax);
    public sealed virtual UInt32 EnumEvents(UInt32& phEnum, UInt32 td, IntPtr rEvents, UInt32 cMax);
    public sealed virtual UInt32 GetEventProps(UInt32 ev, UInt32& pClass, StringBuilder szEvent, UInt32 cchEvent, UInt32& pchEvent, UInt32& pdwEventFlags, UInt32& ptkEventType, UInt32& pmdAddOn, UInt32& pmdRemoveOn, UInt32& pmdFire, UInt32[] rmdOtherMethod, UInt32 cMax);
    public sealed virtual UInt32 EnumMethodSemantics(UInt32& phEnum, UInt32 mb, UInt32[] rEventProp, UInt32 cMax);
    public sealed virtual UInt32 GetMethodSemantics(UInt32 mb, UInt32 tkEventProp);
    public sealed virtual UInt32 GetClassLayout(UInt32 td, UInt32& pdwPackSize, IntPtr rFieldOffset, UInt32 cMax, UInt32& pcFieldOffset);
    public sealed virtual UInt32 GetFieldMarshal(UInt32 tk, IntPtr& ppvNativeType);
    public sealed virtual UInt32 GetRVA(UInt32 tk, UInt32& pulCodeRVA);
    public sealed virtual UInt32 GetPermissionSetProps(UInt32 pm, UInt32& pdwAction, IntPtr& ppvPermission);
    public sealed virtual UInt32 GetSigFromToken(UInt32 mdSig, IntPtr& ppvSig);
    public sealed virtual UInt32 GetModuleRefProps(UInt32 mur, StringBuilder szName, UInt32 cchName);
    public sealed virtual UInt32 EnumModuleRefs(UInt32& phEnum, UInt32[] rModuleRefs, UInt32 cmax);
    public sealed virtual UInt32 GetTypeSpecFromToken(UInt32 typespec, IntPtr& ppvSig);
    public sealed virtual UInt32 GetNameFromToken(UInt32 tk);
    public sealed virtual UInt32 EnumUnresolvedMethods(UInt32& phEnum, UInt32[] rMethods, UInt32 cMax);
    public sealed virtual UInt32 GetUserString(UInt32 stk, StringBuilder szString, UInt32 cchString);
    public sealed virtual UInt32 GetPinvokeMap(UInt32 tk, UInt32& pdwMappingFlags, StringBuilder szImportName, UInt32 cchImportName, UInt32& pchImportName);
    public sealed virtual UInt32 EnumSignatures(UInt32& phEnum, UInt32[] rSignatures, UInt32 cmax);
    public sealed virtual UInt32 EnumTypeSpecs(UInt32& phEnum, UInt32[] rTypeSpecs, UInt32 cmax);
    public sealed virtual UInt32 EnumUserStrings(UInt32& phEnum, UInt32[] rStrings, UInt32 cmax);
    public sealed virtual int GetParamForMethodIndex(UInt32 md, UInt32 ulParamSeq, UInt32& pParam);
    public sealed virtual UInt32 EnumCustomAttributes(UInt32& phEnum, UInt32 tk, UInt32 tkType, UInt32[] rCustomAttributes, UInt32 cMax);
    public sealed virtual UInt32 GetCustomAttributeProps(UInt32 cv, UInt32& ptkObj, UInt32& ptkType, IntPtr& ppBlob);
    public sealed virtual UInt32 FindTypeRef(UInt32 tkResolutionScope, string szName);
    public sealed virtual UInt32 GetMemberProps(UInt32 mb, UInt32& pClass, StringBuilder szMember, UInt32 cchMember, UInt32& pchMember, UInt32& pdwAttr, IntPtr& ppvSigBlob, UInt32& pcbSigBlob, UInt32& pulCodeRVA, UInt32& pdwImplFlags, UInt32& pdwCPlusTypeFlag, IntPtr& ppValue);
    public sealed virtual UInt32 GetFieldProps(UInt32 mb, UInt32& pClass, StringBuilder szField, UInt32 cchField, UInt32& pchField, UInt32& pdwAttr, IntPtr& ppvSigBlob, UInt32& pcbSigBlob, UInt32& pdwCPlusTypeFlag, IntPtr& ppValue);
    public sealed virtual UInt32 GetPropertyProps(UInt32 prop, UInt32& pClass, StringBuilder szProperty, UInt32 cchProperty, UInt32& pchProperty, UInt32& pdwPropFlags, IntPtr& ppvSig, UInt32& pbSig, UInt32& pdwCPlusTypeFlag, IntPtr& ppDefaultValue, UInt32& pcchDefaultValue, UInt32& pmdSetter, UInt32& pmdGetter, UInt32[] rmdOtherMethod, UInt32 cMax);
    public sealed virtual UInt32 GetParamProps(UInt32 tk, UInt32& pmd, UInt32& pulSequence, StringBuilder szName, UInt32 cchName, UInt32& pchName, UInt32& pdwAttr, UInt32& pdwCPlusTypeFlag, IntPtr& ppValue);
    public sealed virtual UInt32 GetCustomAttributeByName(UInt32 tkObj, string szName, IntPtr& ppData);
    public sealed virtual bool IsValidToken(UInt32 tk);
    public sealed virtual UInt32 GetNestedClassProps(UInt32 tdNestedClass, UInt32* ptdEnclosingClass);
    public sealed virtual UInt32 GetNativeCallConvFromSig(IntPtr pvSig, UInt32 cbSig);
    public sealed virtual int IsGlobal(UInt32 pd);
}
internal class Mono.Cecil.Pdb.NativePdbReader : object {
    
private Disposable`1<Stream> pdb_file;
    
private Dictionary`2<string, Document> documents;
    
private Dictionary`2<UInt32, PdbFunction> functions;
    
private Dictionary`2<PdbScope, ImportDebugInformation> imports;
    internal NativePdbReader(Disposable`1<Stream> file);
    public sealed virtual ISymbolWriterProvider GetWriterProvider();
    public sealed virtual bool ProcessDebugHeader(ImageDebugHeader header);
    private static bool IsMatchingEntry(PdbInfo info, ImageDebugHeaderEntry entry);
    private static int ReadInt32(Byte[] bytes, int start);
    public sealed virtual MethodDebugInformation Read(MethodDefinition method);
    private Collection`1<ScopeDebugInformation> ReadScopeAndLocals(PdbScope[] scopes, MethodDebugInformation info);
    private ScopeDebugInformation ReadScopeAndLocals(PdbScope scope, MethodDebugInformation info);
    private static bool AddScope(Collection`1<ScopeDebugInformation> scopes, ScopeDebugInformation scope);
    private ImportDebugInformation GetImport(UInt32 token, ModuleDefinition module);
    private static ImportDebugInformation GetImport(PdbScope scope, ModuleDefinition module);
    private void ReadSequencePoints(PdbFunction function, MethodDebugInformation info);
    private void ReadLines(PdbLines lines, MethodDebugInformation info);
    private static void ReadLine(PdbLine line, Document document, MethodDebugInformation info);
    private Document GetDocument(PdbSource source);
    public sealed virtual void Dispose();
}
internal class Mono.Cecil.Pdb.NativePdbReaderProvider : object {
    public sealed virtual ISymbolReader GetSymbolReader(ModuleDefinition module, string fileName);
    public sealed virtual ISymbolReader GetSymbolReader(ModuleDefinition module, Stream symbolStream);
}
internal class Mono.Cecil.Pdb.NativePdbWriter : object {
    
private ModuleDefinition module;
    
private MetadataBuilder metadata;
    
private SymWriter writer;
    
private Dictionary`2<string, SymDocumentWriter> documents;
    
private Dictionary`2<ImportDebugInformation, MetadataToken> import_info_to_parent;
    
private ImageDebugDirectory debug_directory;
    
private Byte[] debug_info;
    internal NativePdbWriter(ModuleDefinition module, SymWriter writer);
    public sealed virtual ISymbolReaderProvider GetReaderProvider();
    public sealed virtual ImageDebugHeader GetDebugHeader();
    public sealed virtual void Write(MethodDebugInformation info);
    private void DefineCustomMetadata(MethodDebugInformation info, MetadataToken import_parent);
    private void DefineAsyncCustomMetadata(MethodDebugInformation info);
    private void DefineScope(ScopeDebugInformation scope, MethodDebugInformation info, MetadataToken& import_parent);
    private void DefineSequencePoints(Collection`1<SequencePoint> sequence_points);
    private void DefineLocalVariable(VariableDebugInformation variable, int local_var_token, int start_offset, int end_offset);
    private void DefineConstant(ConstantDebugInformation constant);
    private SymDocumentWriter GetDocument(Document document);
    public sealed virtual void Write();
    public sealed virtual void Dispose();
}
internal class Mono.Cecil.Pdb.NativePdbWriterProvider : object {
    public sealed virtual ISymbolWriter GetSymbolWriter(ModuleDefinition module, string fileName);
    private static SymWriter CreateWriter(ModuleDefinition module, string pdb);
    public sealed virtual ISymbolWriter GetSymbolWriter(ModuleDefinition module, Stream symbolStream);
}
internal class Mono.Cecil.Pdb.PdbReaderProvider : object {
    public sealed virtual ISymbolReader GetSymbolReader(ModuleDefinition module, string fileName);
    public sealed virtual ISymbolReader GetSymbolReader(ModuleDefinition module, Stream symbolStream);
}
internal class Mono.Cecil.Pdb.PdbWriterProvider : object {
    public sealed virtual ISymbolWriter GetSymbolWriter(ModuleDefinition module, string fileName);
    private static bool HasPortablePdbSymbols(ModuleDefinition module);
    public sealed virtual ISymbolWriter GetSymbolWriter(ModuleDefinition module, Stream symbolStream);
}
internal class Mono.Cecil.Pdb.SymDocumentWriter : object {
    
private ISymUnmanagedDocumentWriter writer;
    
public ISymUnmanagedDocumentWriter Writer { get; }
    public SymDocumentWriter(ISymUnmanagedDocumentWriter writer);
    public ISymUnmanagedDocumentWriter get_Writer();
    public void SetSource(Byte[] source);
    public void SetCheckSum(Guid hashAlgo, Byte[] checkSum);
}
internal class Mono.Cecil.Pdb.SymWriter : object {
    
private static Guid s_symUnmangedWriterIID;
    
private static Guid s_CorSymWriter_SxS_ClassID;
    
private ISymUnmanagedWriter2 writer;
    
private Collection`1<ISymUnmanagedDocumentWriter> documents;
    private static SymWriter();
    private static int CoCreateInstance(Guid& rclsid, object pUnkOuter, UInt32 dwClsContext, Guid& riid, Object& ppv);
    public Byte[] GetDebugInfo(ImageDebugDirectory& idd);
    public void DefineLocalVariable2(string name, VariableAttributes attributes, int sigToken, int addr1, int addr2, int addr3, int startOffset, int endOffset);
    public void DefineConstant2(string name, object value, int sigToken);
    public void Close();
    public void CloseMethod();
    public void CloseNamespace();
    public void CloseScope(int endOffset);
    public SymDocumentWriter DefineDocument(string url, Guid language, Guid languageVendor, Guid documentType);
    public void DefineSequencePoints(SymDocumentWriter document, Int32[] offsets, Int32[] lines, Int32[] columns, Int32[] endLines, Int32[] endColumns);
    public void Initialize(object emitter, string filename, bool fFullBuild);
    public void SetUserEntryPoint(int methodToken);
    public void OpenMethod(int methodToken);
    public void OpenNamespace(string name);
    public int OpenScope(int startOffset);
    public void UsingNamespace(string fullName);
    public void DefineCustomMetadata(string name, Byte[] metadata);
}
internal class Mono.Cecil.PE.BinaryStreamReader : BinaryReader {
    
public int Position { get; public set; }
    
public int Length { get; }
    public BinaryStreamReader(Stream stream);
    public int get_Position();
    public void set_Position(int value);
    public int get_Length();
    public void Advance(int bytes);
    public void MoveTo(UInt32 position);
    public void Align(int align);
    public DataDirectory ReadDataDirectory();
}
internal class Mono.Cecil.PE.BinaryStreamWriter : BinaryWriter {
    
public int Position { get; public set; }
    public BinaryStreamWriter(Stream stream);
    public int get_Position();
    public void set_Position(int value);
    public void WriteByte(byte value);
    public void WriteUInt16(ushort value);
    public void WriteInt16(short value);
    public void WriteUInt32(UInt32 value);
    public void WriteInt32(int value);
    public void WriteUInt64(ulong value);
    public void WriteBytes(Byte[] bytes);
    public void WriteDataDirectory(DataDirectory directory);
    public void WriteBuffer(ByteBuffer buffer);
    protected void Advance(int bytes);
    public void Align(int align);
}
internal class Mono.Cecil.PE.ByteBuffer : object {
    
internal Byte[] buffer;
    
internal int length;
    
internal int position;
    public ByteBuffer(int length);
    public ByteBuffer(Byte[] buffer);
    public void Advance(int length);
    public byte ReadByte();
    public sbyte ReadSByte();
    public Byte[] ReadBytes(int length);
    public ushort ReadUInt16();
    public short ReadInt16();
    public UInt32 ReadUInt32();
    public int ReadInt32();
    public ulong ReadUInt64();
    public long ReadInt64();
    public UInt32 ReadCompressedUInt32();
    public int ReadCompressedInt32();
    public float ReadSingle();
    public double ReadDouble();
    public void WriteByte(byte value);
    public void WriteSByte(sbyte value);
    public void WriteUInt16(ushort value);
    public void WriteInt16(short value);
    public void WriteUInt32(UInt32 value);
    public void WriteInt32(int value);
    public void WriteUInt64(ulong value);
    public void WriteInt64(long value);
    public void WriteCompressedUInt32(UInt32 value);
    public void WriteCompressedInt32(int value);
    public void WriteBytes(Byte[] bytes);
    public void WriteBytes(int length);
    public void WriteBytes(ByteBuffer buffer);
    public void WriteSingle(float value);
    public void WriteDouble(double value);
    private void Grow(int desired);
}
internal class Mono.Cecil.PE.ByteBufferEqualityComparer : object {
    public sealed virtual bool Equals(ByteBuffer x, ByteBuffer y);
    public sealed virtual int GetHashCode(ByteBuffer buffer);
}
internal class Mono.Cecil.PE.DataDirectory : ValueType {
    
public UInt32 VirtualAddress;
    
public UInt32 Size;
    
public bool IsZero { get; }
    public DataDirectory(UInt32 rva, UInt32 size);
    public bool get_IsZero();
}
internal class Mono.Cecil.PE.Image : object {
    
public Disposable`1<Stream> Stream;
    
public string FileName;
    
public ModuleKind Kind;
    
public UInt32 Characteristics;
    
public string RuntimeVersion;
    
public TargetArchitecture Architecture;
    
public ModuleCharacteristics DllCharacteristics;
    
public ushort LinkerVersion;
    
public ushort SubSystemMajor;
    
public ushort SubSystemMinor;
    
public ImageDebugHeader DebugHeader;
    
public Section[] Sections;
    
public Section MetadataSection;
    
public UInt32 EntryPointToken;
    
public UInt32 Timestamp;
    
public ModuleAttributes Attributes;
    
public DataDirectory Win32Resources;
    
public DataDirectory Debug;
    
public DataDirectory Resources;
    
public DataDirectory StrongName;
    
public StringHeap StringHeap;
    
public BlobHeap BlobHeap;
    
public UserStringHeap UserStringHeap;
    
public GuidHeap GuidHeap;
    
public TableHeap TableHeap;
    
public PdbHeap PdbHeap;
    
private Int32[] coded_index_sizes;
    
private Func`2<Table, int> counter;
    public bool HasTable(Table table);
    public int GetTableLength(Table table);
    public int GetTableIndexSize(Table table);
    public int GetCodedIndexSize(CodedIndex coded_index);
    public UInt32 ResolveVirtualAddress(UInt32 rva);
    public UInt32 ResolveVirtualAddressInSection(UInt32 rva, Section section);
    public Section GetSection(string name);
    public Section GetSectionAtVirtualAddress(UInt32 rva);
    private BinaryStreamReader GetReaderAt(UInt32 rva);
    public TRet GetReaderAt(UInt32 rva, TItem item, Func`3<TItem, BinaryStreamReader, TRet> read);
    public bool HasDebugTables();
    public sealed virtual void Dispose();
}
internal class Mono.Cecil.PE.ImageReader : BinaryStreamReader {
    
private Image image;
    
private DataDirectory cli;
    
private DataDirectory metadata;
    
private UInt32 table_heap_offset;
    
private UInt32 pdb_heap_offset;
    public ImageReader(Disposable`1<Stream> stream, string file_name);
    private void MoveTo(DataDirectory directory);
    private void ReadImage();
    private TargetArchitecture ReadArchitecture();
    private static ModuleKind GetModuleKind(ushort characteristics, ushort subsystem);
    private void ReadOptionalHeaders(UInt16& subsystem, UInt16& dll_characteristics);
    private string ReadAlignedString(int length);
    private string ReadZeroTerminatedString(int length);
    private void ReadSections(ushort count);
    private void ReadCLIHeader();
    private void ReadMetadata();
    private void ReadDebugHeader();
    private void ReadMetadataStream(Section section);
    private Byte[] ReadHeapData(UInt32 offset, UInt32 size);
    private void ReadTableHeap();
    private static void SetIndexSize(Heap heap, UInt32 sizes, byte flag);
    private int GetTableIndexSize(Table table);
    private int GetCodedIndexSize(CodedIndex index);
    private void ComputeTableInformations();
    private void ReadPdbHeap();
    public static Image ReadImage(Disposable`1<Stream> stream, string file_name);
    public static Image ReadPortablePdb(Disposable`1<Stream> stream, string file_name, UInt32& pdb_heap_offset);
}
internal class Mono.Cecil.PE.ImageWriter : BinaryStreamWriter {
    
private ModuleDefinition module;
    
private MetadataBuilder metadata;
    
private TextMap text_map;
    
internal Disposable`1<Stream> stream;
    
private string runtime_version;
    
private ImageDebugHeader debug_header;
    
private ByteBuffer win32_resources;
    
private static UInt32 pe_header_size;
    
private static UInt32 section_header_size;
    
private static UInt32 file_alignment;
    
private static UInt32 section_alignment;
    
private static ulong image_base;
    
internal static UInt32 text_rva;
    
private bool pe64;
    
private bool has_reloc;
    
internal Section text;
    
internal Section rsrc;
    
internal Section reloc;
    
private ushort sections;
    
internal long debug_header_entries_position;
    private ImageWriter(ModuleDefinition module, string runtime_version, MetadataBuilder metadata, Disposable`1<Stream> stream, bool metadataOnly);
    private void GetDebugHeader();
    private void GetWin32Resources();
    public static ImageWriter CreateWriter(ModuleDefinition module, MetadataBuilder metadata, Disposable`1<Stream> stream);
    public static ImageWriter CreateDebugWriter(ModuleDefinition module, MetadataBuilder metadata, Disposable`1<Stream> stream);
    private void BuildSections();
    private Section CreateSection(string name, UInt32 size, Section previous);
    private static UInt32 Align(UInt32 value, UInt32 align);
    private void WriteDOSHeader();
    private ushort SizeOfOptionalHeader();
    private void WritePEFileHeader();
    private Section LastSection();
    private void WriteOptionalHeaders();
    private void WriteZeroDataDirectory();
    private ushort GetSubSystem();
    private void WriteSectionHeaders();
    private void WriteSection(Section section, UInt32 characteristics);
    private UInt32 GetRVAFileOffset(Section section, UInt32 rva);
    private void MoveTo(UInt32 pointer);
    private void MoveToRVA(Section section, UInt32 rva);
    internal void MoveToRVA(TextSegment segment);
    private void WriteRVA(UInt32 rva);
    private void PrepareSection(Section section);
    private void WriteText();
    private UInt32 GetMetadataLength();
    public void WriteMetadataHeader();
    private ushort GetStreamCount();
    private void WriteStreamHeader(UInt32& offset, TextSegment heap, string name);
    private static int GetZeroTerminatedStringLength(string string);
    private static Byte[] GetZeroTerminatedString(string string);
    private static Byte[] GetSimpleString(string string);
    private static Byte[] GetString(string string, int length);
    public void WriteMetadata();
    private void WriteHeap(TextSegment heap, HeapBuffer buffer);
    private void WriteDebugDirectory();
    private void WriteImportDirectory();
    private Byte[] GetRuntimeMain();
    private void WriteStartupStub();
    private void WriteRsrc();
    private void WriteReloc();
    public void WriteImage();
    private void BuildTextMap();
    public void BuildMetadataTextMap();
    private UInt32 GetStartupStubLength();
    private int GetMetadataHeaderLength(string runtimeVersion);
    private int GetStrongNameLength();
    public DataDirectory GetStrongNameSignatureDirectory();
    public UInt32 GetHeaderSize();
    private void PatchWin32Resources(ByteBuffer resources);
    private void PatchResourceDirectoryTable(ByteBuffer resources);
    private void PatchResourceDirectoryEntry(ByteBuffer resources);
    private void PatchResourceDataEntry(ByteBuffer resources);
}
internal class Mono.Cecil.PE.Section : object {
    
public string Name;
    
public UInt32 VirtualAddress;
    
public UInt32 VirtualSize;
    
public UInt32 SizeOfRawData;
    
public UInt32 PointerToRawData;
}
internal class Mono.Cecil.PE.TextMap : object {
    
private Range[] map;
    public void AddMap(TextSegment segment, int length);
    private UInt32 AlignUp(UInt32 value, UInt32 align);
    public void AddMap(TextSegment segment, int length, int align);
    public void AddMap(TextSegment segment, Range range);
    public Range GetRange(TextSegment segment);
    public DataDirectory GetDataDirectory(TextSegment segment);
    public UInt32 GetRVA(TextSegment segment);
    public UInt32 GetNextRVA(TextSegment segment);
    public int GetLength(TextSegment segment);
    private UInt32 GetStart(TextSegment segment);
    private UInt32 ComputeStart(int index);
    public UInt32 GetLength();
}
internal enum Mono.Cecil.PE.TextSegment : Enum {
    
public int value__;
    
public static TextSegment ImportAddressTable;
    
public static TextSegment CLIHeader;
    
public static TextSegment Code;
    
public static TextSegment Resources;
    
public static TextSegment Data;
    
public static TextSegment StrongNameSignature;
    
public static TextSegment MetadataHeader;
    
public static TextSegment TableHeap;
    
public static TextSegment StringHeap;
    
public static TextSegment UserStringHeap;
    
public static TextSegment GuidHeap;
    
public static TextSegment BlobHeap;
    
public static TextSegment PdbHeap;
    
public static TextSegment DebugDirectory;
    
public static TextSegment ImportDirectory;
    
public static TextSegment ImportHintNameTable;
    
public static TextSegment StartupStub;
}
internal class Mono.Cecil.PinnedType : TypeSpecification {
    
public bool IsValueType { get; public set; }
    
public bool IsPinned { get; }
    public PinnedType(TypeReference type);
    public virtual bool get_IsValueType();
    public virtual void set_IsValueType(bool value);
    public virtual bool get_IsPinned();
}
[FlagsAttribute]
internal enum Mono.Cecil.PInvokeAttributes : Enum {
    
public ushort value__;
    
public static PInvokeAttributes NoMangle;
    
public static PInvokeAttributes CharSetMask;
    
public static PInvokeAttributes CharSetNotSpec;
    
public static PInvokeAttributes CharSetAnsi;
    
public static PInvokeAttributes CharSetUnicode;
    
public static PInvokeAttributes CharSetAuto;
    
public static PInvokeAttributes SupportsLastError;
    
public static PInvokeAttributes CallConvMask;
    
public static PInvokeAttributes CallConvWinapi;
    
public static PInvokeAttributes CallConvCdecl;
    
public static PInvokeAttributes CallConvStdCall;
    
public static PInvokeAttributes CallConvThiscall;
    
public static PInvokeAttributes CallConvFastcall;
    
public static PInvokeAttributes BestFitMask;
    
public static PInvokeAttributes BestFitEnabled;
    
public static PInvokeAttributes BestFitDisabled;
    
public static PInvokeAttributes ThrowOnUnmappableCharMask;
    
public static PInvokeAttributes ThrowOnUnmappableCharEnabled;
    
public static PInvokeAttributes ThrowOnUnmappableCharDisabled;
}
internal class Mono.Cecil.PInvokeInfo : object {
    
private ushort attributes;
    
private string entry_point;
    
private ModuleReference module;
    
public PInvokeAttributes Attributes { get; public set; }
    
public string EntryPoint { get; public set; }
    
public ModuleReference Module { get; public set; }
    
public bool IsNoMangle { get; public set; }
    
public bool IsCharSetNotSpec { get; public set; }
    
public bool IsCharSetAnsi { get; public set; }
    
public bool IsCharSetUnicode { get; public set; }
    
public bool IsCharSetAuto { get; public set; }
    
public bool SupportsLastError { get; public set; }
    
public bool IsCallConvWinapi { get; public set; }
    
public bool IsCallConvCdecl { get; public set; }
    
public bool IsCallConvStdCall { get; public set; }
    
public bool IsCallConvThiscall { get; public set; }
    
public bool IsCallConvFastcall { get; public set; }
    
public bool IsBestFitEnabled { get; public set; }
    
public bool IsBestFitDisabled { get; public set; }
    
public bool IsThrowOnUnmappableCharEnabled { get; public set; }
    
public bool IsThrowOnUnmappableCharDisabled { get; public set; }
    public PInvokeInfo(PInvokeAttributes attributes, string entryPoint, ModuleReference module);
    public PInvokeAttributes get_Attributes();
    public void set_Attributes(PInvokeAttributes value);
    public string get_EntryPoint();
    public void set_EntryPoint(string value);
    public ModuleReference get_Module();
    public void set_Module(ModuleReference value);
    public bool get_IsNoMangle();
    public void set_IsNoMangle(bool value);
    public bool get_IsCharSetNotSpec();
    public void set_IsCharSetNotSpec(bool value);
    public bool get_IsCharSetAnsi();
    public void set_IsCharSetAnsi(bool value);
    public bool get_IsCharSetUnicode();
    public void set_IsCharSetUnicode(bool value);
    public bool get_IsCharSetAuto();
    public void set_IsCharSetAuto(bool value);
    public bool get_SupportsLastError();
    public void set_SupportsLastError(bool value);
    public bool get_IsCallConvWinapi();
    public void set_IsCallConvWinapi(bool value);
    public bool get_IsCallConvCdecl();
    public void set_IsCallConvCdecl(bool value);
    public bool get_IsCallConvStdCall();
    public void set_IsCallConvStdCall(bool value);
    public bool get_IsCallConvThiscall();
    public void set_IsCallConvThiscall(bool value);
    public bool get_IsCallConvFastcall();
    public void set_IsCallConvFastcall(bool value);
    public bool get_IsBestFitEnabled();
    public void set_IsBestFitEnabled(bool value);
    public bool get_IsBestFitDisabled();
    public void set_IsBestFitDisabled(bool value);
    public bool get_IsThrowOnUnmappableCharEnabled();
    public void set_IsThrowOnUnmappableCharEnabled(bool value);
    public bool get_IsThrowOnUnmappableCharDisabled();
    public void set_IsThrowOnUnmappableCharDisabled(bool value);
}
internal class Mono.Cecil.PointerType : TypeSpecification {
    
public string Name { get; }
    
public string FullName { get; }
    
public bool IsValueType { get; public set; }
    
public bool IsPointer { get; }
    public PointerType(TypeReference type);
    public virtual string get_Name();
    public virtual string get_FullName();
    public virtual bool get_IsValueType();
    public virtual void set_IsValueType(bool value);
    public virtual bool get_IsPointer();
}
[FlagsAttribute]
internal enum Mono.Cecil.PropertyAttributes : Enum {
    
public ushort value__;
    
public static PropertyAttributes None;
    
public static PropertyAttributes SpecialName;
    
public static PropertyAttributes RTSpecialName;
    
public static PropertyAttributes HasDefault;
    
public static PropertyAttributes Unused;
}
internal class Mono.Cecil.PropertyDefinition : PropertyReference {
    
private Nullable`1<bool> has_this;
    
private ushort attributes;
    
private Collection`1<CustomAttribute> custom_attributes;
    
internal MethodDefinition get_method;
    
internal MethodDefinition set_method;
    
internal Collection`1<MethodDefinition> other_methods;
    
private object constant;
    
public PropertyAttributes Attributes { get; public set; }
    
public bool HasThis { get; public set; }
    
public bool HasCustomAttributes { get; }
    
public Collection`1<CustomAttribute> CustomAttributes { get; }
    
public MethodDefinition GetMethod { get; public set; }
    
public MethodDefinition SetMethod { get; public set; }
    
public bool HasOtherMethods { get; }
    
public Collection`1<MethodDefinition> OtherMethods { get; }
    
public bool HasParameters { get; }
    
public Collection`1<ParameterDefinition> Parameters { get; }
    
public bool HasConstant { get; public set; }
    
public object Constant { get; public set; }
    
public bool IsSpecialName { get; public set; }
    
public bool IsRuntimeSpecialName { get; public set; }
    
public bool HasDefault { get; public set; }
    
public TypeDefinition DeclaringType { get; public set; }
    
public bool IsDefinition { get; }
    
public string FullName { get; }
    public PropertyDefinition(string name, PropertyAttributes attributes, TypeReference propertyType);
    public PropertyAttributes get_Attributes();
    public void set_Attributes(PropertyAttributes value);
    public bool get_HasThis();
    public void set_HasThis(bool value);
    public sealed virtual bool get_HasCustomAttributes();
    public sealed virtual Collection`1<CustomAttribute> get_CustomAttributes();
    public MethodDefinition get_GetMethod();
    public void set_GetMethod(MethodDefinition value);
    public MethodDefinition get_SetMethod();
    public void set_SetMethod(MethodDefinition value);
    public bool get_HasOtherMethods();
    public Collection`1<MethodDefinition> get_OtherMethods();
    public bool get_HasParameters();
    public virtual Collection`1<ParameterDefinition> get_Parameters();
    private static Collection`1<ParameterDefinition> MirrorParameters(MethodDefinition method, int bound);
    public sealed virtual bool get_HasConstant();
    public sealed virtual void set_HasConstant(bool value);
    public sealed virtual object get_Constant();
    public sealed virtual void set_Constant(object value);
    public sealed virtual bool get_IsSpecialName();
    public sealed virtual void set_IsSpecialName(bool value);
    public sealed virtual bool get_IsRuntimeSpecialName();
    public sealed virtual void set_IsRuntimeSpecialName(bool value);
    public bool get_HasDefault();
    public void set_HasDefault(bool value);
    public sealed virtual TypeDefinition get_DeclaringType();
    public sealed virtual void set_DeclaringType(TypeDefinition value);
    public virtual bool get_IsDefinition();
    public virtual string get_FullName();
    private void InitializeMethods();
    public virtual PropertyDefinition Resolve();
}
internal class Mono.Cecil.PropertyMapTable : MetadataTable`1<Row`2<UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
}
internal abstract class Mono.Cecil.PropertyReference : MemberReference {
    
private TypeReference property_type;
    
public TypeReference PropertyType { get; public set; }
    
public Collection`1<ParameterDefinition> Parameters { get; }
    internal PropertyReference(string name, TypeReference propertyType);
    public TypeReference get_PropertyType();
    public void set_PropertyType(TypeReference value);
    public abstract virtual Collection`1<ParameterDefinition> get_Parameters();
    protected virtual IMemberDefinition ResolveDefinition();
    public abstract virtual PropertyDefinition Resolve();
}
internal class Mono.Cecil.PropertyTable : MetadataTable`1<Row`3<PropertyAttributes, UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
}
internal class Mono.Cecil.Range : ValueType {
    
public UInt32 Start;
    
public UInt32 Length;
    public Range(UInt32 index, UInt32 length);
}
internal class Mono.Cecil.ReaderParameters : object {
    
private ReadingMode reading_mode;
    
internal IAssemblyResolver assembly_resolver;
    
internal IMetadataResolver metadata_resolver;
    
internal IMetadataImporterProvider metadata_importer_provider;
    
internal IReflectionImporterProvider reflection_importer_provider;
    
private Stream symbol_stream;
    
private ISymbolReaderProvider symbol_reader_provider;
    
private bool read_symbols;
    
private bool throw_symbols_mismatch;
    
private bool projections;
    
private bool in_memory;
    
private bool read_write;
    
public ReadingMode ReadingMode { get; public set; }
    
public bool InMemory { get; public set; }
    
public IAssemblyResolver AssemblyResolver { get; public set; }
    
public IMetadataResolver MetadataResolver { get; public set; }
    
public IMetadataImporterProvider MetadataImporterProvider { get; public set; }
    
public IReflectionImporterProvider ReflectionImporterProvider { get; public set; }
    
public Stream SymbolStream { get; public set; }
    
public ISymbolReaderProvider SymbolReaderProvider { get; public set; }
    
public bool ReadSymbols { get; public set; }
    
public bool ThrowIfSymbolsAreNotMatching { get; public set; }
    
public bool ReadWrite { get; public set; }
    
public bool ApplyWindowsRuntimeProjections { get; public set; }
    public ReaderParameters(ReadingMode readingMode);
    public ReadingMode get_ReadingMode();
    public void set_ReadingMode(ReadingMode value);
    public bool get_InMemory();
    public void set_InMemory(bool value);
    public IAssemblyResolver get_AssemblyResolver();
    public void set_AssemblyResolver(IAssemblyResolver value);
    public IMetadataResolver get_MetadataResolver();
    public void set_MetadataResolver(IMetadataResolver value);
    public IMetadataImporterProvider get_MetadataImporterProvider();
    public void set_MetadataImporterProvider(IMetadataImporterProvider value);
    public IReflectionImporterProvider get_ReflectionImporterProvider();
    public void set_ReflectionImporterProvider(IReflectionImporterProvider value);
    public Stream get_SymbolStream();
    public void set_SymbolStream(Stream value);
    public ISymbolReaderProvider get_SymbolReaderProvider();
    public void set_SymbolReaderProvider(ISymbolReaderProvider value);
    public bool get_ReadSymbols();
    public void set_ReadSymbols(bool value);
    public bool get_ThrowIfSymbolsAreNotMatching();
    public void set_ThrowIfSymbolsAreNotMatching(bool value);
    public bool get_ReadWrite();
    public void set_ReadWrite(bool value);
    public bool get_ApplyWindowsRuntimeProjections();
    public void set_ApplyWindowsRuntimeProjections(bool value);
}
internal enum Mono.Cecil.ReadingMode : Enum {
    
public int value__;
    
public static ReadingMode Immediate;
    
public static ReadingMode Deferred;
}
internal class Mono.Cecil.RequiredModifierType : TypeSpecification {
    
private TypeReference modifier_type;
    
public TypeReference ModifierType { get; public set; }
    
public string Name { get; }
    
public string FullName { get; }
    
private string Suffix { get; }
    
public bool IsValueType { get; public set; }
    
public bool IsRequiredModifier { get; }
    
public bool ContainsGenericParameter { get; }
    public RequiredModifierType(TypeReference modifierType, TypeReference type);
    public sealed virtual TypeReference get_ModifierType();
    public void set_ModifierType(TypeReference value);
    public virtual string get_Name();
    public virtual string get_FullName();
    private string get_Suffix();
    public virtual bool get_IsValueType();
    public virtual void set_IsValueType(bool value);
    public virtual bool get_IsRequiredModifier();
    public virtual bool get_ContainsGenericParameter();
}
internal class Mono.Cecil.ResolutionException : Exception {
    
private MemberReference member;
    
public MemberReference Member { get; }
    
public IMetadataScope Scope { get; }
    public ResolutionException(MemberReference member);
    public ResolutionException(MemberReference member, Exception innerException);
    private ResolutionException(SerializationInfo info, StreamingContext context);
    public MemberReference get_Member();
    public IMetadataScope get_Scope();
}
internal abstract class Mono.Cecil.Resource : object {
    
private string name;
    
private UInt32 attributes;
    
public string Name { get; public set; }
    
public ManifestResourceAttributes Attributes { get; public set; }
    
public ResourceType ResourceType { get; }
    
public bool IsPublic { get; public set; }
    
public bool IsPrivate { get; public set; }
    internal Resource(string name, ManifestResourceAttributes attributes);
    public string get_Name();
    public void set_Name(string value);
    public ManifestResourceAttributes get_Attributes();
    public void set_Attributes(ManifestResourceAttributes value);
    public abstract virtual ResourceType get_ResourceType();
    public bool get_IsPublic();
    public void set_IsPublic(bool value);
    public bool get_IsPrivate();
    public void set_IsPrivate(bool value);
}
internal enum Mono.Cecil.ResourceType : Enum {
    
public int value__;
    
public static ResourceType Linked;
    
public static ResourceType Embedded;
    
public static ResourceType AssemblyLinked;
}
internal class Mono.Cecil.Rocks.DocCommentId : object {
    
private IMemberDefinition commentMember;
    
private StringBuilder id;
    private DocCommentId(IMemberDefinition member);
    private void WriteField(FieldDefinition field);
    private void WriteEvent(EventDefinition event);
    private void WriteType(TypeDefinition type);
    private void WriteMethod(MethodDefinition method);
    private static bool IsConversionOperator(MethodDefinition self);
    private void WriteReturnType(MethodDefinition method);
    private void WriteProperty(PropertyDefinition property);
    private void WriteParameters(IList`1<ParameterDefinition> parameters);
    private void WriteTypeSignature(TypeReference type);
    private bool IsGenericMethodTypeParameter(TypeReference type);
    private void WriteGenericInstanceTypeSignature(GenericInstanceType type);
    private void WriteList(IList`1<T> list, Action`1<T> action);
    private void WriteModiferTypeSignature(IModifierType type, char id);
    private void WriteFunctionPointerTypeSignature(FunctionPointerType type);
    private void WriteArrayTypeSignature(ArrayType type);
    private void WriteDefinition(char id, IMemberDefinition member);
    private void WriteTypeFullName(TypeReference type);
    private void WriteTypeFullName(TypeReference type, GenericTypeOptions options);
    private void WriteGenericTypeParameters(TypeReference type, GenericTypeOptions options);
    private static bool IsGenericType(TypeReference type);
    private IList`1<TypeReference> GetGenericTypeArguments(TypeReference type, GenericTypeOptions options);
    private void WriteItemName(string name);
    public virtual string ToString();
    public static string GetDocCommentId(IMemberDefinition member);
    [CompilerGeneratedAttribute]
private void <WriteParameters>b__10_0(ParameterDefinition p);
    [CompilerGeneratedAttribute]
private void <WriteArrayTypeSignature>b__17_0(ArrayDimension dimension);
}
[ExtensionAttribute]
internal static class Mono.Cecil.Rocks.Functional : object {
    public static Func`2<A, R> Y(Func`2<Func`2<A, R>, Func`2<A, R>> f);
    [ExtensionAttribute]
public static IEnumerable`1<TSource> Prepend(IEnumerable`1<TSource> source, TSource element);
    private static IEnumerable`1<TSource> PrependIterator(IEnumerable`1<TSource> source, TSource element);
}
internal interface Mono.Cecil.Rocks.IILVisitor {
    public abstract virtual void OnInlineNone(OpCode opcode);
    public abstract virtual void OnInlineSByte(OpCode opcode, sbyte value);
    public abstract virtual void OnInlineByte(OpCode opcode, byte value);
    public abstract virtual void OnInlineInt32(OpCode opcode, int value);
    public abstract virtual void OnInlineInt64(OpCode opcode, long value);
    public abstract virtual void OnInlineSingle(OpCode opcode, float value);
    public abstract virtual void OnInlineDouble(OpCode opcode, double value);
    public abstract virtual void OnInlineString(OpCode opcode, string value);
    public abstract virtual void OnInlineBranch(OpCode opcode, int offset);
    public abstract virtual void OnInlineSwitch(OpCode opcode, Int32[] offsets);
    public abstract virtual void OnInlineVariable(OpCode opcode, VariableDefinition variable);
    public abstract virtual void OnInlineArgument(OpCode opcode, ParameterDefinition parameter);
    public abstract virtual void OnInlineSignature(OpCode opcode, CallSite callSite);
    public abstract virtual void OnInlineType(OpCode opcode, TypeReference type);
    public abstract virtual void OnInlineField(OpCode opcode, FieldReference field);
    public abstract virtual void OnInlineMethod(OpCode opcode, MethodReference method);
}
internal static class Mono.Cecil.Rocks.ILParser : object {
    public static void Parse(MethodDefinition method, IILVisitor visitor);
    private static void ParseMethod(MethodDefinition method, IILVisitor visitor);
    private static ParseContext CreateContext(MethodDefinition method, IILVisitor visitor);
    private static void ParseFatMethod(ParseContext context);
    private static void ParseCode(int code_size, ParseContext context);
    private static VariableDefinition GetVariable(ParseContext context, int index);
}
[ExtensionAttribute]
internal static class Mono.Cecil.Rocks.MethodBodyRocks : object {
    [ExtensionAttribute]
public static void SimplifyMacros(MethodBody self);
    private static void ExpandMacro(Instruction instruction, OpCode opcode, object operand);
    private static void MakeMacro(Instruction instruction, OpCode opcode);
    [ExtensionAttribute]
public static void Optimize(MethodBody self);
    [ExtensionAttribute]
private static void OptimizeLongs(MethodBody self);
    [ExtensionAttribute]
public static void OptimizeMacros(MethodBody self);
    private static void OptimizeBranches(MethodBody body);
    private static bool OptimizeBranch(Instruction instruction);
    private static void ComputeOffsets(MethodBody body);
}
[ExtensionAttribute]
internal static class Mono.Cecil.Rocks.MethodDefinitionRocks : object {
    [ExtensionAttribute]
public static MethodDefinition GetBaseMethod(MethodDefinition self);
    [ExtensionAttribute]
public static MethodDefinition GetOriginalBaseMethod(MethodDefinition self);
    private static TypeDefinition ResolveBaseType(TypeDefinition type);
    private static MethodDefinition GetMatchingMethod(TypeDefinition type, MethodDefinition method);
}
[ExtensionAttribute]
internal static class Mono.Cecil.Rocks.ModuleDefinitionRocks : object {
    [ExtensionAttribute]
public static IEnumerable`1<TypeDefinition> GetAllTypes(ModuleDefinition self);
}
[ExtensionAttribute]
internal static class Mono.Cecil.Rocks.ParameterReferenceRocks : object {
    [ExtensionAttribute]
public static int GetSequence(ParameterReference self);
}
[ExtensionAttribute]
internal static class Mono.Cecil.Rocks.SecurityDeclarationRocks : object {
    [ExtensionAttribute]
public static PermissionSet ToPermissionSet(SecurityDeclaration self);
    private static bool TryProcessPermissionSetAttribute(SecurityDeclaration declaration, PermissionSet& set);
    private static PermissionSet CreatePermissionSet(SecurityDeclaration declaration);
    private static IPermission CreatePermission(SecurityDeclaration declaration, SecurityAttribute attribute);
    private static void CompleteSecurityAttribute(SecurityAttribute security_attribute, SecurityAttribute attribute);
    private static void CompleteSecurityAttributeFields(SecurityAttribute security_attribute, SecurityAttribute attribute);
    private static void CompleteSecurityAttributeProperties(SecurityAttribute security_attribute, SecurityAttribute attribute);
    private static SecurityAttribute CreateSecurityAttribute(Type attribute_type, SecurityDeclaration declaration);
    [ExtensionAttribute]
public static SecurityDeclaration ToSecurityDeclaration(PermissionSet self, SecurityAction action, ModuleDefinition module);
}
[ExtensionAttribute]
internal static class Mono.Cecil.Rocks.TypeDefinitionRocks : object {
    [ExtensionAttribute]
public static IEnumerable`1<MethodDefinition> GetConstructors(TypeDefinition self);
    [ExtensionAttribute]
public static MethodDefinition GetStaticConstructor(TypeDefinition self);
    [ExtensionAttribute]
public static IEnumerable`1<MethodDefinition> GetMethods(TypeDefinition self);
    [ExtensionAttribute]
public static TypeReference GetEnumUnderlyingType(TypeDefinition self);
}
[ExtensionAttribute]
internal static class Mono.Cecil.Rocks.TypeReferenceRocks : object {
    [ExtensionAttribute]
public static ArrayType MakeArrayType(TypeReference self);
    [ExtensionAttribute]
public static ArrayType MakeArrayType(TypeReference self, int rank);
    [ExtensionAttribute]
public static PointerType MakePointerType(TypeReference self);
    [ExtensionAttribute]
public static ByReferenceType MakeByReferenceType(TypeReference self);
    [ExtensionAttribute]
public static OptionalModifierType MakeOptionalModifierType(TypeReference self, TypeReference modifierType);
    [ExtensionAttribute]
public static RequiredModifierType MakeRequiredModifierType(TypeReference self, TypeReference modifierType);
    [ExtensionAttribute]
public static GenericInstanceType MakeGenericInstanceType(TypeReference self, TypeReference[] arguments);
    [ExtensionAttribute]
public static PinnedType MakePinnedType(TypeReference self);
    [ExtensionAttribute]
public static SentinelType MakeSentinelType(TypeReference self);
}
internal class Mono.Cecil.SafeArrayMarshalInfo : MarshalInfo {
    
internal VariantType element_type;
    
public VariantType ElementType { get; public set; }
    public VariantType get_ElementType();
    public void set_ElementType(VariantType value);
}
internal enum Mono.Cecil.SecurityAction : Enum {
    
public ushort value__;
    
public static SecurityAction Request;
    
public static SecurityAction Demand;
    
public static SecurityAction Assert;
    
public static SecurityAction Deny;
    
public static SecurityAction PermitOnly;
    
public static SecurityAction LinkDemand;
    
public static SecurityAction InheritDemand;
    
public static SecurityAction RequestMinimum;
    
public static SecurityAction RequestOptional;
    
public static SecurityAction RequestRefuse;
    
public static SecurityAction PreJitGrant;
    
public static SecurityAction PreJitDeny;
    
public static SecurityAction NonCasDemand;
    
public static SecurityAction NonCasLinkDemand;
    
public static SecurityAction NonCasInheritance;
}
[DebuggerDisplayAttribute("{AttributeType}")]
internal class Mono.Cecil.SecurityAttribute : object {
    
private TypeReference attribute_type;
    
internal Collection`1<CustomAttributeNamedArgument> fields;
    
internal Collection`1<CustomAttributeNamedArgument> properties;
    
public TypeReference AttributeType { get; public set; }
    
public bool HasFields { get; }
    
public Collection`1<CustomAttributeNamedArgument> Fields { get; }
    
public bool HasProperties { get; }
    
public Collection`1<CustomAttributeNamedArgument> Properties { get; }
    
private bool Mono.Cecil.ICustomAttribute.HasConstructorArguments { get; }
    
private Collection`1<CustomAttributeArgument> Mono.Cecil.ICustomAttribute.ConstructorArguments { get; }
    public SecurityAttribute(TypeReference attributeType);
    public sealed virtual TypeReference get_AttributeType();
    public void set_AttributeType(TypeReference value);
    public sealed virtual bool get_HasFields();
    public sealed virtual Collection`1<CustomAttributeNamedArgument> get_Fields();
    public sealed virtual bool get_HasProperties();
    public sealed virtual Collection`1<CustomAttributeNamedArgument> get_Properties();
    private sealed virtual override bool Mono.Cecil.ICustomAttribute.get_HasConstructorArguments();
    private sealed virtual override Collection`1<CustomAttributeArgument> Mono.Cecil.ICustomAttribute.get_ConstructorArguments();
}
internal class Mono.Cecil.SecurityDeclaration : object {
    
internal UInt32 signature;
    
private Byte[] blob;
    
private ModuleDefinition module;
    
internal bool resolved;
    
private SecurityAction action;
    
internal Collection`1<SecurityAttribute> security_attributes;
    
public SecurityAction Action { get; public set; }
    
public bool HasSecurityAttributes { get; }
    
public Collection`1<SecurityAttribute> SecurityAttributes { get; }
    
internal bool HasImage { get; }
    internal SecurityDeclaration(SecurityAction action, UInt32 signature, ModuleDefinition module);
    public SecurityDeclaration(SecurityAction action);
    public SecurityDeclaration(SecurityAction action, Byte[] blob);
    public SecurityAction get_Action();
    public void set_Action(SecurityAction value);
    public bool get_HasSecurityAttributes();
    public Collection`1<SecurityAttribute> get_SecurityAttributes();
    internal bool get_HasImage();
    public Byte[] GetBlob();
    private void Resolve();
}
internal class Mono.Cecil.SentinelType : TypeSpecification {
    
public bool IsValueType { get; public set; }
    
public bool IsSentinel { get; }
    public SentinelType(TypeReference type);
    public virtual bool get_IsValueType();
    public virtual void set_IsValueType(bool value);
    public virtual bool get_IsSentinel();
}
internal class Mono.Cecil.SignatureReader : ByteBuffer {
    
private MetadataReader reader;
    
internal UInt32 start;
    
internal UInt32 sig_length;
    
private TypeSystem TypeSystem { get; }
    public SignatureReader(UInt32 blob, MetadataReader reader);
    private TypeSystem get_TypeSystem();
    private MetadataToken ReadTypeTokenSignature();
    private GenericParameter GetGenericParameter(GenericParameterType type, UInt32 var);
    private GenericParameter GetUnboundGenericParameter(GenericParameterType type, int index);
    private static void CheckGenericContext(IGenericParameterProvider owner, int index);
    public void ReadGenericInstanceSignature(IGenericParameterProvider provider, IGenericInstance instance, UInt32 arity);
    private ArrayType ReadArrayTypeSignature();
    private TypeReference GetTypeDefOrRef(MetadataToken token);
    public TypeReference ReadTypeSignature();
    public TypeReference ReadTypeToken();
    private TypeReference ReadTypeSignature(ElementType etype);
    public void ReadMethodSignature(IMethodSignature method);
    public object ReadConstantSignature(ElementType type);
    public void ReadCustomAttributeConstructorArguments(CustomAttribute attribute, Collection`1<ParameterDefinition> parameters);
    private CustomAttributeArgument ReadCustomAttributeFixedArgument(TypeReference type);
    public void ReadCustomAttributeNamedArguments(ushort count, Collection`1& fields, Collection`1& properties);
    private void ReadCustomAttributeNamedArgument(Collection`1& fields, Collection`1& properties);
    private static Collection`1<CustomAttributeNamedArgument> GetCustomAttributeNamedArgumentCollection(Collection`1& collection);
    private CustomAttributeArgument ReadCustomAttributeFixedArrayArgument(ArrayType type);
    private CustomAttributeArgument ReadCustomAttributeElement(TypeReference type);
    private object ReadCustomAttributeElementValue(TypeReference type);
    private object ReadPrimitiveValue(ElementType type);
    private TypeReference GetPrimitiveType(ElementType etype);
    private TypeReference ReadCustomAttributeFieldOrPropType();
    public TypeReference ReadTypeReference();
    private object ReadCustomAttributeEnum(TypeReference enum_type);
    public SecurityAttribute ReadSecurityAttribute();
    public MarshalInfo ReadMarshalInfo();
    private NativeType ReadNativeType();
    private VariantType ReadVariantType();
    private string ReadUTF8String();
    public string ReadDocumentName();
    public Collection`1<SequencePoint> ReadSequencePoints(Document document);
    public bool CanReadMore();
}
internal class Mono.Cecil.SignatureWriter : ByteBuffer {
    
private MetadataBuilder metadata;
    public SignatureWriter(MetadataBuilder metadata);
    public void WriteElementType(ElementType element_type);
    public void WriteUTF8String(string string);
    public void WriteMethodSignature(IMethodSignature method);
    private UInt32 MakeTypeDefOrRefCodedRID(TypeReference type);
    public void WriteTypeToken(TypeReference type);
    public void WriteTypeSignature(TypeReference type);
    private void WriteArrayTypeSignature(ArrayType array);
    public void WriteGenericInstanceSignature(IGenericInstance instance);
    private void WriteModifierSignature(ElementType element_type, IModifierType type);
    private bool TryWriteElementType(TypeReference type);
    public void WriteConstantString(string value);
    public void WriteConstantPrimitive(object value);
    public void WriteCustomAttributeConstructorArguments(CustomAttribute attribute);
    private void WriteCustomAttributeFixedArgument(TypeReference type, CustomAttributeArgument argument);
    private void WriteCustomAttributeFixedArrayArgument(ArrayType type, CustomAttributeArgument argument);
    private void WriteCustomAttributeElement(TypeReference type, CustomAttributeArgument argument);
    private void WriteCustomAttributeValue(TypeReference type, object value);
    private void WriteCustomAttributeTypeValue(TypeReference value);
    private void WritePrimitiveValue(object value);
    private void WriteCustomAttributeEnumValue(TypeReference enum_type, object value);
    private void WriteCustomAttributeFieldOrPropType(TypeReference type);
    public void WriteCustomAttributeNamedArguments(CustomAttribute attribute);
    private static int GetNamedArgumentCount(ICustomAttribute attribute);
    private void WriteICustomAttributeNamedArguments(ICustomAttribute attribute);
    private void WriteCustomAttributeNamedArguments(byte kind, Collection`1<CustomAttributeNamedArgument> named_arguments);
    private void WriteCustomAttributeNamedArgument(byte kind, CustomAttributeNamedArgument named_argument);
    private void WriteSecurityAttribute(SecurityAttribute attribute);
    public void WriteSecurityDeclaration(SecurityDeclaration declaration);
    public void WriteXmlSecurityDeclaration(SecurityDeclaration declaration);
    private static string GetXmlSecurityDeclaration(SecurityDeclaration declaration);
    private void WriteTypeReference(TypeReference type);
    public void WriteMarshalInfo(MarshalInfo marshal_info);
    private void WriteNativeType(NativeType native);
    private void WriteVariantType(VariantType variant);
    public void WriteSequencePoints(MethodDebugInformation info);
}
internal abstract class Mono.Cecil.SortedTable`1 : MetadataTable`1<TRow> {
    public sealed virtual void Sort();
    protected static int Compare(UInt32 x, UInt32 y);
    public abstract virtual int Compare(TRow x, TRow y);
}
internal class Mono.Cecil.StandAloneSigTable : MetadataTable`1<UInt32> {
    public virtual void Write(TableHeapBuffer buffer);
}
internal class Mono.Cecil.StateMachineMethodTable : MetadataTable`1<Row`2<UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
}
internal enum Mono.Cecil.TargetArchitecture : Enum {
    
public int value__;
    
public static TargetArchitecture I386;
    
public static TargetArchitecture AMD64;
    
public static TargetArchitecture IA64;
    
public static TargetArchitecture ARM;
    
public static TargetArchitecture ARMv7;
    
public static TargetArchitecture ARM64;
}
internal enum Mono.Cecil.TargetRuntime : Enum {
    
public int value__;
    
public static TargetRuntime Net_1_0;
    
public static TargetRuntime Net_1_1;
    
public static TargetRuntime Net_2_0;
    
public static TargetRuntime Net_4_0;
}
internal enum Mono.Cecil.TokenType : Enum {
    
public UInt32 value__;
    
public static TokenType Module;
    
public static TokenType TypeRef;
    
public static TokenType TypeDef;
    
public static TokenType Field;
    
public static TokenType Method;
    
public static TokenType Param;
    
public static TokenType InterfaceImpl;
    
public static TokenType MemberRef;
    
public static TokenType CustomAttribute;
    
public static TokenType Permission;
    
public static TokenType Signature;
    
public static TokenType Event;
    
public static TokenType Property;
    
public static TokenType ModuleRef;
    
public static TokenType TypeSpec;
    
public static TokenType Assembly;
    
public static TokenType AssemblyRef;
    
public static TokenType File;
    
public static TokenType ExportedType;
    
public static TokenType ManifestResource;
    
public static TokenType GenericParam;
    
public static TokenType MethodSpec;
    
public static TokenType GenericParamConstraint;
    
public static TokenType Document;
    
public static TokenType MethodDebugInformation;
    
public static TokenType LocalScope;
    
public static TokenType LocalVariable;
    
public static TokenType LocalConstant;
    
public static TokenType ImportScope;
    
public static TokenType StateMachineMethod;
    
public static TokenType CustomDebugInformation;
    
public static TokenType String;
}
[FlagsAttribute]
internal enum Mono.Cecil.TypeAttributes : Enum {
    
public UInt32 value__;
    
public static TypeAttributes VisibilityMask;
    
public static TypeAttributes NotPublic;
    
public static TypeAttributes Public;
    
public static TypeAttributes NestedPublic;
    
public static TypeAttributes NestedPrivate;
    
public static TypeAttributes NestedFamily;
    
public static TypeAttributes NestedAssembly;
    
public static TypeAttributes NestedFamANDAssem;
    
public static TypeAttributes NestedFamORAssem;
    
public static TypeAttributes LayoutMask;
    
public static TypeAttributes AutoLayout;
    
public static TypeAttributes SequentialLayout;
    
public static TypeAttributes ExplicitLayout;
    
public static TypeAttributes ClassSemanticMask;
    
public static TypeAttributes Class;
    
public static TypeAttributes Interface;
    
public static TypeAttributes Abstract;
    
public static TypeAttributes Sealed;
    
public static TypeAttributes SpecialName;
    
public static TypeAttributes Import;
    
public static TypeAttributes Serializable;
    
public static TypeAttributes WindowsRuntime;
    
public static TypeAttributes StringFormatMask;
    
public static TypeAttributes AnsiClass;
    
public static TypeAttributes UnicodeClass;
    
public static TypeAttributes AutoClass;
    
public static TypeAttributes BeforeFieldInit;
    
public static TypeAttributes RTSpecialName;
    
public static TypeAttributes HasSecurity;
    
public static TypeAttributes Forwarder;
}
internal enum Mono.Cecil.TypeComparisonMode : Enum {
    
public int value__;
    
public static TypeComparisonMode Exact;
    
public static TypeComparisonMode SignatureOnly;
    
public static TypeComparisonMode SignatureOnlyLoose;
}
internal class Mono.Cecil.TypeDefinition : TypeReference {
    
private UInt32 attributes;
    
private TypeReference base_type;
    
internal Range fields_range;
    
internal Range methods_range;
    
private short packing_size;
    
private int class_size;
    
private InterfaceImplementationCollection interfaces;
    
private Collection`1<TypeDefinition> nested_types;
    
private Collection`1<MethodDefinition> methods;
    
private Collection`1<FieldDefinition> fields;
    
private Collection`1<EventDefinition> events;
    
private Collection`1<PropertyDefinition> properties;
    
private Collection`1<CustomAttribute> custom_attributes;
    
private Collection`1<SecurityDeclaration> security_declarations;
    
public TypeAttributes Attributes { get; public set; }
    
public TypeReference BaseType { get; public set; }
    
public string Name { get; public set; }
    
public bool HasLayoutInfo { get; }
    
public short PackingSize { get; public set; }
    
public int ClassSize { get; public set; }
    
public bool HasInterfaces { get; }
    
public Collection`1<InterfaceImplementation> Interfaces { get; }
    
public bool HasNestedTypes { get; }
    
public Collection`1<TypeDefinition> NestedTypes { get; }
    
public bool HasMethods { get; }
    
public Collection`1<MethodDefinition> Methods { get; }
    
public bool HasFields { get; }
    
public Collection`1<FieldDefinition> Fields { get; }
    
public bool HasEvents { get; }
    
public Collection`1<EventDefinition> Events { get; }
    
public bool HasProperties { get; }
    
public Collection`1<PropertyDefinition> Properties { get; }
    
public bool HasSecurityDeclarations { get; }
    
public Collection`1<SecurityDeclaration> SecurityDeclarations { get; }
    
public bool HasCustomAttributes { get; }
    
public Collection`1<CustomAttribute> CustomAttributes { get; }
    
public bool HasGenericParameters { get; }
    
public Collection`1<GenericParameter> GenericParameters { get; }
    
public bool IsNotPublic { get; public set; }
    
public bool IsPublic { get; public set; }
    
public bool IsNestedPublic { get; public set; }
    
public bool IsNestedPrivate { get; public set; }
    
public bool IsNestedFamily { get; public set; }
    
public bool IsNestedAssembly { get; public set; }
    
public bool IsNestedFamilyAndAssembly { get; public set; }
    
public bool IsNestedFamilyOrAssembly { get; public set; }
    
public bool IsAutoLayout { get; public set; }
    
public bool IsSequentialLayout { get; public set; }
    
public bool IsExplicitLayout { get; public set; }
    
public bool IsClass { get; public set; }
    
public bool IsInterface { get; public set; }
    
public bool IsAbstract { get; public set; }
    
public bool IsSealed { get; public set; }
    
public bool IsSpecialName { get; public set; }
    
public bool IsImport { get; public set; }
    
public bool IsSerializable { get; public set; }
    
public bool IsWindowsRuntime { get; public set; }
    
public bool IsAnsiClass { get; public set; }
    
public bool IsUnicodeClass { get; public set; }
    
public bool IsAutoClass { get; public set; }
    
public bool IsBeforeFieldInit { get; public set; }
    
public bool IsRuntimeSpecialName { get; public set; }
    
public bool HasSecurity { get; public set; }
    
public bool IsEnum { get; }
    
public bool IsValueType { get; public set; }
    
public bool IsPrimitive { get; }
    
public MetadataType MetadataType { get; }
    
public bool IsDefinition { get; }
    
public TypeDefinition DeclaringType { get; public set; }
    
internal TypeDefinitionProjection WindowsRuntimeProjection { get; internal set; }
    public TypeDefinition(string namespace, string name, TypeAttributes attributes);
    public TypeDefinition(string namespace, string name, TypeAttributes attributes, TypeReference baseType);
    public TypeAttributes get_Attributes();
    public void set_Attributes(TypeAttributes value);
    public TypeReference get_BaseType();
    public void set_BaseType(TypeReference value);
    public virtual string get_Name();
    public virtual void set_Name(string value);
    private void ResolveLayout();
    public bool get_HasLayoutInfo();
    public short get_PackingSize();
    public void set_PackingSize(short value);
    public int get_ClassSize();
    public void set_ClassSize(int value);
    public bool get_HasInterfaces();
    public Collection`1<InterfaceImplementation> get_Interfaces();
    public bool get_HasNestedTypes();
    public Collection`1<TypeDefinition> get_NestedTypes();
    public bool get_HasMethods();
    public Collection`1<MethodDefinition> get_Methods();
    public bool get_HasFields();
    public Collection`1<FieldDefinition> get_Fields();
    public bool get_HasEvents();
    public Collection`1<EventDefinition> get_Events();
    public bool get_HasProperties();
    public Collection`1<PropertyDefinition> get_Properties();
    public sealed virtual bool get_HasSecurityDeclarations();
    public sealed virtual Collection`1<SecurityDeclaration> get_SecurityDeclarations();
    public sealed virtual bool get_HasCustomAttributes();
    public sealed virtual Collection`1<CustomAttribute> get_CustomAttributes();
    public virtual bool get_HasGenericParameters();
    public virtual Collection`1<GenericParameter> get_GenericParameters();
    public bool get_IsNotPublic();
    public void set_IsNotPublic(bool value);
    public bool get_IsPublic();
    public void set_IsPublic(bool value);
    public bool get_IsNestedPublic();
    public void set_IsNestedPublic(bool value);
    public bool get_IsNestedPrivate();
    public void set_IsNestedPrivate(bool value);
    public bool get_IsNestedFamily();
    public void set_IsNestedFamily(bool value);
    public bool get_IsNestedAssembly();
    public void set_IsNestedAssembly(bool value);
    public bool get_IsNestedFamilyAndAssembly();
    public void set_IsNestedFamilyAndAssembly(bool value);
    public bool get_IsNestedFamilyOrAssembly();
    public void set_IsNestedFamilyOrAssembly(bool value);
    public bool get_IsAutoLayout();
    public void set_IsAutoLayout(bool value);
    public bool get_IsSequentialLayout();
    public void set_IsSequentialLayout(bool value);
    public bool get_IsExplicitLayout();
    public void set_IsExplicitLayout(bool value);
    public bool get_IsClass();
    public void set_IsClass(bool value);
    public bool get_IsInterface();
    public void set_IsInterface(bool value);
    public bool get_IsAbstract();
    public void set_IsAbstract(bool value);
    public bool get_IsSealed();
    public void set_IsSealed(bool value);
    public sealed virtual bool get_IsSpecialName();
    public sealed virtual void set_IsSpecialName(bool value);
    public bool get_IsImport();
    public void set_IsImport(bool value);
    public bool get_IsSerializable();
    public void set_IsSerializable(bool value);
    public bool get_IsWindowsRuntime();
    public void set_IsWindowsRuntime(bool value);
    public bool get_IsAnsiClass();
    public void set_IsAnsiClass(bool value);
    public bool get_IsUnicodeClass();
    public void set_IsUnicodeClass(bool value);
    public bool get_IsAutoClass();
    public void set_IsAutoClass(bool value);
    public bool get_IsBeforeFieldInit();
    public void set_IsBeforeFieldInit(bool value);
    public sealed virtual bool get_IsRuntimeSpecialName();
    public sealed virtual void set_IsRuntimeSpecialName(bool value);
    public bool get_HasSecurity();
    public void set_HasSecurity(bool value);
    public bool get_IsEnum();
    public virtual bool get_IsValueType();
    public virtual void set_IsValueType(bool value);
    public virtual bool get_IsPrimitive();
    public virtual MetadataType get_MetadataType();
    public virtual bool get_IsDefinition();
    public sealed virtual TypeDefinition get_DeclaringType();
    public sealed virtual void set_DeclaringType(TypeDefinition value);
    internal TypeDefinitionProjection get_WindowsRuntimeProjection();
    internal void set_WindowsRuntimeProjection(TypeDefinitionProjection value);
    protected virtual void ClearFullName();
    public virtual TypeDefinition Resolve();
}
internal class Mono.Cecil.TypeDefinitionCollection : Collection`1<TypeDefinition> {
    
private ModuleDefinition container;
    
private Dictionary`2<Row`2<string, string>, TypeDefinition> name_cache;
    internal TypeDefinitionCollection(ModuleDefinition container);
    internal TypeDefinitionCollection(ModuleDefinition container, int capacity);
    protected virtual void OnAdd(TypeDefinition item, int index);
    protected virtual void OnSet(TypeDefinition item, int index);
    protected virtual void OnInsert(TypeDefinition item, int index);
    protected virtual void OnRemove(TypeDefinition item, int index);
    protected virtual void OnClear();
    private void Attach(TypeDefinition type);
    private void Detach(TypeDefinition type);
    public TypeDefinition GetType(string fullname);
    public TypeDefinition GetType(string namespace, string name);
}
internal class Mono.Cecil.TypeDefinitionProjection : object {
    
public TypeAttributes Attributes;
    
public string Name;
    
public TypeDefinitionTreatment Treatment;
    
public Collection`1<MethodDefinition> RedirectedMethods;
    
public Collection`1<KeyValuePair`2<InterfaceImplementation, InterfaceImplementation>> RedirectedInterfaces;
    public TypeDefinitionProjection(TypeDefinition type, TypeDefinitionTreatment treatment, Collection`1<MethodDefinition> redirectedMethods, Collection`1<KeyValuePair`2<InterfaceImplementation, InterfaceImplementation>> redirectedInterfaces);
}
[FlagsAttribute]
internal enum Mono.Cecil.TypeDefinitionTreatment : Enum {
    
public int value__;
    
public static TypeDefinitionTreatment None;
    
public static TypeDefinitionTreatment KindMask;
    
public static TypeDefinitionTreatment NormalType;
    
public static TypeDefinitionTreatment NormalAttribute;
    
public static TypeDefinitionTreatment UnmangleWindowsRuntimeName;
    
public static TypeDefinitionTreatment PrefixWindowsRuntimeName;
    
public static TypeDefinitionTreatment RedirectToClrType;
    
public static TypeDefinitionTreatment RedirectToClrAttribute;
    
public static TypeDefinitionTreatment RedirectImplementedMethods;
    
public static TypeDefinitionTreatment Abstract;
    
public static TypeDefinitionTreatment Internal;
}
internal class Mono.Cecil.TypeDefTable : MetadataTable`1<Row`6<TypeAttributes, UInt32, UInt32, UInt32, UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
}
internal class Mono.Cecil.TypeParser : object {
    
private string fullname;
    
private int length;
    
private int position;
    private TypeParser(string fullname);
    private Type ParseType(bool fq_name);
    private static bool TryGetArity(Type type);
    private static bool TryGetArity(string name, Int32& arity);
    private static bool ParseInt32(string value, Int32& result);
    private static void TryAddArity(string name, Int32& arity);
    private string ParsePart();
    private static bool IsDelimiter(char chr);
    private void TryParseWhiteSpace();
    private String[] ParseNestedNames();
    private bool TryParse(char chr);
    private static void Add(T[]& array, T item);
    private Int32[] ParseSpecs();
    private Type[] ParseGenericArguments(int arity);
    private string ParseAssemblyName();
    public static TypeReference ParseType(ModuleDefinition module, string fullname, bool typeDefinitionOnly);
    private static TypeReference GetTypeReference(ModuleDefinition module, Type type_info, bool type_def_only);
    private static TypeReference CreateSpecs(TypeReference type, Type type_info);
    private static TypeReference TryCreateGenericInstanceType(TypeReference type, Type type_info);
    public static void SplitFullName(string fullname, String& namespace, String& name);
    private static TypeReference CreateReference(Type type_info, ModuleDefinition module, IMetadataScope scope);
    private static void AdjustGenericParameters(TypeReference type);
    private static IMetadataScope GetMetadataScope(ModuleDefinition module, Type type_info);
    private static bool TryGetDefinition(ModuleDefinition module, Type type_info, TypeReference& type);
    private static bool TryCurrentModule(ModuleDefinition module, Type type_info);
    public static string ToParseable(TypeReference type, bool top_level);
    private static void AppendNamePart(string part, StringBuilder name);
    private static void AppendType(TypeReference type, StringBuilder name, bool fq_name, bool top_level);
    private static string GetScopeFullName(TypeReference type);
    private static void AppendTypeSpecification(TypeSpecification type, StringBuilder name);
    private static bool RequiresFullyQualifiedName(TypeReference type, bool top_level);
}
internal class Mono.Cecil.TypeReference : MemberReference {
    
private string namespace;
    
private bool value_type;
    
internal IMetadataScope scope;
    
internal ModuleDefinition module;
    
internal ElementType etype;
    
private string fullname;
    
protected Collection`1<GenericParameter> generic_parameters;
    
public string Name { get; public set; }
    
public string Namespace { get; public set; }
    
public bool IsValueType { get; public set; }
    
public ModuleDefinition Module { get; }
    
internal TypeReferenceProjection WindowsRuntimeProjection { get; internal set; }
    
private IGenericParameterProvider Mono.Cecil.IGenericContext.Type { get; }
    
private IGenericParameterProvider Mono.Cecil.IGenericContext.Method { get; }
    
private GenericParameterType Mono.Cecil.IGenericParameterProvider.GenericParameterType { get; }
    
public bool HasGenericParameters { get; }
    
public Collection`1<GenericParameter> GenericParameters { get; }
    
public IMetadataScope Scope { get; public set; }
    
public bool IsNested { get; }
    
public TypeReference DeclaringType { get; public set; }
    
public string FullName { get; }
    
public bool IsByReference { get; }
    
public bool IsPointer { get; }
    
public bool IsSentinel { get; }
    
public bool IsArray { get; }
    
public bool IsGenericParameter { get; }
    
public bool IsGenericInstance { get; }
    
public bool IsRequiredModifier { get; }
    
public bool IsOptionalModifier { get; }
    
public bool IsPinned { get; }
    
public bool IsFunctionPointer { get; }
    
public bool IsPrimitive { get; }
    
public MetadataType MetadataType { get; }
    protected TypeReference(string namespace, string name);
    public TypeReference(string namespace, string name, ModuleDefinition module, IMetadataScope scope);
    public TypeReference(string namespace, string name, ModuleDefinition module, IMetadataScope scope, bool valueType);
    public virtual string get_Name();
    public virtual void set_Name(string value);
    public virtual string get_Namespace();
    public virtual void set_Namespace(string value);
    public virtual bool get_IsValueType();
    public virtual void set_IsValueType(bool value);
    public virtual ModuleDefinition get_Module();
    internal TypeReferenceProjection get_WindowsRuntimeProjection();
    internal void set_WindowsRuntimeProjection(TypeReferenceProjection value);
    private sealed virtual override IGenericParameterProvider Mono.Cecil.IGenericContext.get_Type();
    private sealed virtual override IGenericParameterProvider Mono.Cecil.IGenericContext.get_Method();
    private sealed virtual override GenericParameterType Mono.Cecil.IGenericParameterProvider.get_GenericParameterType();
    public virtual bool get_HasGenericParameters();
    public virtual Collection`1<GenericParameter> get_GenericParameters();
    public virtual IMetadataScope get_Scope();
    public virtual void set_Scope(IMetadataScope value);
    public bool get_IsNested();
    public virtual TypeReference get_DeclaringType();
    public virtual void set_DeclaringType(TypeReference value);
    public virtual string get_FullName();
    public virtual bool get_IsByReference();
    public virtual bool get_IsPointer();
    public virtual bool get_IsSentinel();
    public virtual bool get_IsArray();
    public virtual bool get_IsGenericParameter();
    public virtual bool get_IsGenericInstance();
    public virtual bool get_IsRequiredModifier();
    public virtual bool get_IsOptionalModifier();
    public virtual bool get_IsPinned();
    public virtual bool get_IsFunctionPointer();
    public virtual bool get_IsPrimitive();
    public virtual MetadataType get_MetadataType();
    protected virtual void ClearFullName();
    public virtual TypeReference GetElementType();
    protected virtual IMemberDefinition ResolveDefinition();
    public virtual TypeDefinition Resolve();
}
internal class Mono.Cecil.TypeReferenceEqualityComparer : EqualityComparer`1<TypeReference> {
    public virtual bool Equals(TypeReference x, TypeReference y);
    public virtual int GetHashCode(TypeReference obj);
    public static bool AreEqual(TypeReference a, TypeReference b, TypeComparisonMode comparisonMode);
    private static bool AreEqual(GenericParameter a, GenericParameter b, TypeComparisonMode comparisonMode);
    private static bool AreEqual(GenericInstanceType a, GenericInstanceType b, TypeComparisonMode comparisonMode);
    public static int GetHashCodeFor(TypeReference obj);
}
internal class Mono.Cecil.TypeReferenceProjection : object {
    
public string Name;
    
public string Namespace;
    
public IMetadataScope Scope;
    
public TypeReferenceTreatment Treatment;
    public TypeReferenceProjection(TypeReference type, TypeReferenceTreatment treatment);
}
internal enum Mono.Cecil.TypeReferenceTreatment : Enum {
    
public int value__;
    
public static TypeReferenceTreatment None;
    
public static TypeReferenceTreatment SystemDelegate;
    
public static TypeReferenceTreatment SystemAttribute;
    
public static TypeReferenceTreatment UseProjectionInfo;
}
internal class Mono.Cecil.TypeRefTable : MetadataTable`1<Row`3<UInt32, UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
}
internal class Mono.Cecil.TypeResolver : object {
    
private IGenericInstance _typeDefinitionContext;
    
private IGenericInstance _methodDefinitionContext;
    public TypeResolver(GenericInstanceType typeDefinitionContext);
    public TypeResolver(GenericInstanceMethod methodDefinitionContext);
    public TypeResolver(GenericInstanceType typeDefinitionContext, GenericInstanceMethod methodDefinitionContext);
    public static TypeResolver For(TypeReference typeReference);
    public static TypeResolver For(TypeReference typeReference, MethodReference methodReference);
    public MethodReference Resolve(MethodReference method);
    public FieldReference Resolve(FieldReference field);
    public TypeReference ResolveReturnType(MethodReference method);
    public TypeReference ResolveParameterType(MethodReference method, ParameterReference parameter);
    public TypeReference ResolveVariableType(MethodReference method, VariableReference variable);
    public TypeReference ResolveFieldType(FieldReference field);
    public TypeReference Resolve(TypeReference typeReference);
    public TypeReference Resolve(TypeReference typeReference, bool includeTypeDefinitions);
    internal TypeResolver Nested(GenericInstanceMethod genericInstanceMethod);
    private TypeReference ResolveGenericParameter(GenericParameter genericParameter);
    private TypeReference HandleOwnerlessInvalidILCode(GenericParameter genericParameter);
    private bool IsDummy();
}
internal abstract class Mono.Cecil.TypeSpecification : TypeReference {
    
private TypeReference element_type;
    
public TypeReference ElementType { get; }
    
public string Name { get; public set; }
    
public string Namespace { get; public set; }
    
public IMetadataScope Scope { get; public set; }
    
public ModuleDefinition Module { get; }
    
public string FullName { get; }
    
public bool ContainsGenericParameter { get; }
    
public MetadataType MetadataType { get; }
    internal TypeSpecification(TypeReference type);
    public sealed virtual TypeReference get_ElementType();
    public virtual string get_Name();
    public virtual void set_Name(string value);
    public virtual string get_Namespace();
    public virtual void set_Namespace(string value);
    public virtual IMetadataScope get_Scope();
    public virtual void set_Scope(IMetadataScope value);
    public virtual ModuleDefinition get_Module();
    public virtual string get_FullName();
    public virtual bool get_ContainsGenericParameter();
    public virtual MetadataType get_MetadataType();
    public virtual TypeReference GetElementType();
}
internal class Mono.Cecil.TypeSpecTable : MetadataTable`1<UInt32> {
    public virtual void Write(TableHeapBuffer buffer);
}
internal abstract class Mono.Cecil.TypeSystem : object {
    
private ModuleDefinition module;
    
private TypeReference type_object;
    
private TypeReference type_void;
    
private TypeReference type_bool;
    
private TypeReference type_char;
    
private TypeReference type_sbyte;
    
private TypeReference type_byte;
    
private TypeReference type_int16;
    
private TypeReference type_uint16;
    
private TypeReference type_int32;
    
private TypeReference type_uint32;
    
private TypeReference type_int64;
    
private TypeReference type_uint64;
    
private TypeReference type_single;
    
private TypeReference type_double;
    
private TypeReference type_intptr;
    
private TypeReference type_uintptr;
    
private TypeReference type_string;
    
private TypeReference type_typedref;
    [ObsoleteAttribute("Use CoreLibrary")]

public IMetadataScope Corlib { get; }
    
public IMetadataScope CoreLibrary { get; }
    
public TypeReference Object { get; }
    
public TypeReference Void { get; }
    
public TypeReference Boolean { get; }
    
public TypeReference Char { get; }
    
public TypeReference SByte { get; }
    
public TypeReference Byte { get; }
    
public TypeReference Int16 { get; }
    
public TypeReference UInt16 { get; }
    
public TypeReference Int32 { get; }
    
public TypeReference UInt32 { get; }
    
public TypeReference Int64 { get; }
    
public TypeReference UInt64 { get; }
    
public TypeReference Single { get; }
    
public TypeReference Double { get; }
    
public TypeReference IntPtr { get; }
    
public TypeReference UIntPtr { get; }
    
public TypeReference String { get; }
    
public TypeReference TypedReference { get; }
    private TypeSystem(ModuleDefinition module);
    internal static TypeSystem CreateTypeSystem(ModuleDefinition module);
    internal abstract virtual TypeReference LookupType(string namespace, string name);
    private TypeReference LookupSystemType(TypeReference& reference, string name, ElementType element_type);
    private TypeReference LookupSystemValueType(TypeReference& typeRef, string name, ElementType element_type);
    public IMetadataScope get_Corlib();
    public IMetadataScope get_CoreLibrary();
    public TypeReference get_Object();
    public TypeReference get_Void();
    public TypeReference get_Boolean();
    public TypeReference get_Char();
    public TypeReference get_SByte();
    public TypeReference get_Byte();
    public TypeReference get_Int16();
    public TypeReference get_UInt16();
    public TypeReference get_Int32();
    public TypeReference get_UInt32();
    public TypeReference get_Int64();
    public TypeReference get_UInt64();
    public TypeReference get_Single();
    public TypeReference get_Double();
    public TypeReference get_IntPtr();
    public TypeReference get_UIntPtr();
    public TypeReference get_String();
    public TypeReference get_TypedReference();
}
internal enum Mono.Cecil.VariantType : Enum {
    
public int value__;
    
public static VariantType None;
    
public static VariantType I2;
    
public static VariantType I4;
    
public static VariantType R4;
    
public static VariantType R8;
    
public static VariantType CY;
    
public static VariantType Date;
    
public static VariantType BStr;
    
public static VariantType Dispatch;
    
public static VariantType Error;
    
public static VariantType Bool;
    
public static VariantType Variant;
    
public static VariantType Unknown;
    
public static VariantType Decimal;
    
public static VariantType I1;
    
public static VariantType UI1;
    
public static VariantType UI2;
    
public static VariantType UI4;
    
public static VariantType I8;
    
public static VariantType UI8;
    
public static VariantType Int;
    
public static VariantType UInt;
}
internal class Mono.Cecil.WindowsRuntimeProjections : object {
    
private static Version version;
    
private static Byte[] contract_pk_token;
    
private static Byte[] contract_pk;
    
private static Dictionary`2<string, ProjectionInfo> projections;
    
private ModuleDefinition module;
    
private Version corlib_version;
    
private AssemblyNameReference[] virtual_references;
    
private static Dictionary`2<string, ProjectionInfo> Projections { get; }
    
private AssemblyNameReference[] VirtualReferences { get; }
    public WindowsRuntimeProjections(ModuleDefinition module);
    private static WindowsRuntimeProjections();
    private static Dictionary`2<string, ProjectionInfo> get_Projections();
    private AssemblyNameReference[] get_VirtualReferences();
    public static void Project(TypeDefinition type);
    private static TypeDefinitionTreatment GetWellKnownTypeDefinitionTreatment(TypeDefinition type);
    private static TypeDefinitionTreatment GenerateRedirectionInformation(TypeDefinition type, Collection`1& redirectedMethods, Collection`1& redirectedInterfaces);
    private static void CollectImplementedInterfaces(TypeReference type, HashSet`1<TypeReference> results);
    private static void RedirectInterfaceMethods(TypeReference interfaceType, Collection`1<MethodDefinition> redirectedMethods);
    private static bool IsRedirectedType(TypeReference type);
    private static bool NeedsWindowsRuntimePrefix(TypeDefinition type);
    public static bool IsClrImplementationType(TypeDefinition type);
    public static void ApplyProjection(TypeDefinition type, TypeDefinitionProjection projection);
    public static TypeDefinitionProjection RemoveProjection(TypeDefinition type);
    public static void Project(TypeReference type);
    private static TypeReferenceTreatment GetSpecialTypeReferenceTreatment(TypeReference type);
    private static bool IsAttribute(TypeReference type);
    private static bool IsEnum(TypeReference type);
    public static void ApplyProjection(TypeReference type, TypeReferenceProjection projection);
    public static TypeReferenceProjection RemoveProjection(TypeReference type);
    public static void Project(MethodDefinition method);
    private static MethodDefinitionTreatment GetMethodDefinitionTreatmentFromCustomAttributes(MethodDefinition method);
    public static void ApplyProjection(MethodDefinition method, MethodDefinitionProjection projection);
    public static MethodDefinitionProjection RemoveProjection(MethodDefinition method);
    public static void Project(FieldDefinition field);
    public static void ApplyProjection(FieldDefinition field, FieldDefinitionProjection projection);
    public static FieldDefinitionProjection RemoveProjection(FieldDefinition field);
    private static bool ImplementsRedirectedInterface(MemberReference member);
    public void AddVirtualReferences(Collection`1<AssemblyNameReference> references);
    public void RemoveVirtualReferences(Collection`1<AssemblyNameReference> references);
    private static AssemblyNameReference[] GetAssemblyReferences(AssemblyNameReference corlib);
    private static AssemblyNameReference GetCoreLibrary(Collection`1<AssemblyNameReference> references);
    private AssemblyNameReference GetAssemblyReference(string name);
    public static void Project(ICustomAttributeProvider owner, Collection`1<CustomAttribute> owner_attributes, CustomAttribute attribute);
    private static bool IsWindowsAttributeUsageAttribute(ICustomAttributeProvider owner, CustomAttribute attribute);
    private static bool HasAttribute(Collection`1<CustomAttribute> attributes, string namespace, string name);
    public static void ApplyProjection(CustomAttribute attribute, CustomAttributeValueProjection projection);
    public static CustomAttributeValueProjection RemoveProjection(CustomAttribute attribute);
}
internal class Mono.Cecil.WriterParameters : object {
    
private Nullable`1<UInt32> timestamp;
    
private Stream symbol_stream;
    
private ISymbolWriterProvider symbol_writer_provider;
    
private bool write_symbols;
    
private Byte[] key_blob;
    
private string key_container;
    
private StrongNameKeyPair key_pair;
    [CompilerGeneratedAttribute]

private bool <DeterministicMvid>k__BackingField;
    
public Nullable`1<UInt32> Timestamp { get; public set; }
    
public Stream SymbolStream { get; public set; }
    
public ISymbolWriterProvider SymbolWriterProvider { get; public set; }
    
public bool WriteSymbols { get; public set; }
    
public bool HasStrongNameKey { get; }
    
public Byte[] StrongNameKeyBlob { get; public set; }
    
public string StrongNameKeyContainer { get; public set; }
    
public StrongNameKeyPair StrongNameKeyPair { get; public set; }
    
public bool DeterministicMvid { get; public set; }
    public Nullable`1<UInt32> get_Timestamp();
    public void set_Timestamp(Nullable`1<UInt32> value);
    public Stream get_SymbolStream();
    public void set_SymbolStream(Stream value);
    public ISymbolWriterProvider get_SymbolWriterProvider();
    public void set_SymbolWriterProvider(ISymbolWriterProvider value);
    public bool get_WriteSymbols();
    public void set_WriteSymbols(bool value);
    public bool get_HasStrongNameKey();
    public Byte[] get_StrongNameKeyBlob();
    public void set_StrongNameKeyBlob(Byte[] value);
    public string get_StrongNameKeyContainer();
    public void set_StrongNameKeyContainer(string value);
    public StrongNameKeyPair get_StrongNameKeyPair();
    public void set_StrongNameKeyPair(StrongNameKeyPair value);
    [CompilerGeneratedAttribute]
public bool get_DeterministicMvid();
    [CompilerGeneratedAttribute]
public void set_DeterministicMvid(bool value);
}
[DefaultMemberAttribute("Item")]
internal class Mono.Collections.Generic.Collection`1 : object {
    
internal T[] items;
    
internal int size;
    
private int version;
    
public int Count { get; }
    
public T Item { get; public set; }
    
public int Capacity { get; public set; }
    
private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    
private bool System.Collections.IList.IsFixedSize { get; }
    
private bool System.Collections.IList.IsReadOnly { get; }
    
private object System.Collections.IList.Item { get; private set; }
    
private int System.Collections.ICollection.Count { get; }
    
private bool System.Collections.ICollection.IsSynchronized { get; }
    
private object System.Collections.ICollection.SyncRoot { get; }
    public Collection`1(int capacity);
    public Collection`1(ICollection`1<T> items);
    public sealed virtual int get_Count();
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
    public int get_Capacity();
    public void set_Capacity(int value);
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override int System.Collections.ICollection.get_Count();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    public sealed virtual void Add(T item);
    public sealed virtual bool Contains(T item);
    public sealed virtual int IndexOf(T item);
    public sealed virtual void Insert(int index, T item);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual bool Remove(T item);
    public sealed virtual void Clear();
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public T[] ToArray();
    private void CheckIndex(int index);
    private void Shift(int start, int delta);
    protected virtual void OnAdd(T item, int index);
    protected virtual void OnInsert(T item, int index);
    protected virtual void OnSet(T item, int index);
    protected virtual void OnRemove(T item, int index);
    protected virtual void OnClear();
    internal virtual void Grow(int desired);
    protected void Resize(int new_size);
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override void System.Collections.IList.Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.IList.RemoveAt(int index);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public Enumerator<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
}
internal class Mono.Collections.Generic.ReadOnlyCollection`1 : Collection`1<T> {
    
private static ReadOnlyCollection`1<T> empty;
    
public static ReadOnlyCollection`1<T> Empty { get; }
    
private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    
private bool System.Collections.IList.IsFixedSize { get; }
    
private bool System.Collections.IList.IsReadOnly { get; }
    public ReadOnlyCollection`1(T[] array);
    public ReadOnlyCollection`1(Collection`1<T> collection);
    public static ReadOnlyCollection`1<T> get_Empty();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private void Initialize(T[] items, int size);
    internal virtual void Grow(int desired);
    protected virtual void OnAdd(T item, int index);
    protected virtual void OnClear();
    protected virtual void OnInsert(T item, int index);
    protected virtual void OnRemove(T item, int index);
    protected virtual void OnSet(T item, int index);
}
internal class Mono.CompilerServices.SymbolWriter.AnonymousScopeEntry : object {
    
public int ID;
    
private List`1<CapturedVariable> captured_vars;
    
private List`1<CapturedScope> captured_scopes;
    
public CapturedVariable[] CapturedVariables { get; }
    
public CapturedScope[] CapturedScopes { get; }
    public AnonymousScopeEntry(int id);
    internal AnonymousScopeEntry(MyBinaryReader reader);
    internal void AddCapturedVariable(string name, string captured_name, CapturedKind kind);
    public CapturedVariable[] get_CapturedVariables();
    internal void AddCapturedScope(int scope, string captured_name);
    public CapturedScope[] get_CapturedScopes();
    internal void Write(MyBinaryWriter bw);
    public virtual string ToString();
}
internal class Mono.CompilerServices.SymbolWriter.CapturedScope : ValueType {
    
public int Scope;
    
public string CapturedName;
    public CapturedScope(int scope, string captured_name);
    internal CapturedScope(MyBinaryReader reader);
    internal void Write(MyBinaryWriter bw);
    public virtual string ToString();
}
internal class Mono.CompilerServices.SymbolWriter.CapturedVariable : ValueType {
    
public string Name;
    
public string CapturedName;
    
public CapturedKind Kind;
    public CapturedVariable(string name, string captured_name, CapturedKind kind);
    internal CapturedVariable(MyBinaryReader reader);
    internal void Write(MyBinaryWriter bw);
    public virtual string ToString();
}
internal class Mono.CompilerServices.SymbolWriter.CodeBlockEntry : object {
    
public int Index;
    
public int Parent;
    
public Type BlockType;
    
public int StartOffset;
    
public int EndOffset;
    public CodeBlockEntry(int index, int parent, Type type, int start_offset);
    internal CodeBlockEntry(int index, MyBinaryReader reader);
    public void Close(int end_offset);
    internal void Write(MyBinaryWriter bw);
    public virtual string ToString();
}
internal class Mono.CompilerServices.SymbolWriter.CompileUnitEntry : object {
    
public int Index;
    
private int DataOffset;
    
private MonoSymbolFile file;
    
private SourceFileEntry source;
    
private List`1<SourceFileEntry> include_files;
    
private List`1<NamespaceEntry> namespaces;
    
private bool creating;
    
public static int Size { get; }
    
private CompileUnitEntry Mono.CompilerServices.SymbolWriter.ICompileUnit.Entry { get; }
    
public SourceFileEntry SourceFile { get; }
    
public NamespaceEntry[] Namespaces { get; }
    
public SourceFileEntry[] IncludeFiles { get; }
    public CompileUnitEntry(MonoSymbolFile file, SourceFileEntry source);
    internal CompileUnitEntry(MonoSymbolFile file, MyBinaryReader reader);
    public static int get_Size();
    private sealed virtual override CompileUnitEntry Mono.CompilerServices.SymbolWriter.ICompileUnit.get_Entry();
    public void AddFile(SourceFileEntry file);
    public SourceFileEntry get_SourceFile();
    public int DefineNamespace(string name, String[] using_clauses, int parent);
    internal void WriteData(MyBinaryWriter bw);
    internal void Write(BinaryWriter bw);
    public void ReadAll();
    private void ReadData();
    public NamespaceEntry[] get_Namespaces();
    public SourceFileEntry[] get_IncludeFiles();
}
internal interface Mono.CompilerServices.SymbolWriter.ICompileUnit {
    
public CompileUnitEntry Entry { get; }
    public abstract virtual CompileUnitEntry get_Entry();
}
internal interface Mono.CompilerServices.SymbolWriter.IMethodDef {
    
public string Name { get; }
    
public int Token { get; }
    public abstract virtual string get_Name();
    public abstract virtual int get_Token();
}
internal interface Mono.CompilerServices.SymbolWriter.ISourceFile {
    
public SourceFileEntry Entry { get; }
    public abstract virtual SourceFileEntry get_Entry();
}
internal class Mono.CompilerServices.SymbolWriter.LineNumberEntry : object {
    
public int Row;
    
public int Column;
    
public int EndRow;
    
public int EndColumn;
    
public int File;
    
public int Offset;
    
public bool IsHidden;
    
public static LineNumberEntry Null;
    public LineNumberEntry(int file, int row, int column, int offset);
    public LineNumberEntry(int file, int row, int offset);
    public LineNumberEntry(int file, int row, int column, int offset, bool is_hidden);
    public LineNumberEntry(int file, int row, int column, int end_row, int end_column, int offset, bool is_hidden);
    private static LineNumberEntry();
    public virtual string ToString();
}
internal class Mono.CompilerServices.SymbolWriter.LineNumberTable : object {
    
protected LineNumberEntry[] _line_numbers;
    
public int LineBase;
    
public int LineRange;
    
public byte OpcodeBase;
    
public int MaxAddressIncrement;
    
public static int Default_LineBase;
    
public static int Default_LineRange;
    
public static byte Default_OpcodeBase;
    
public static byte DW_LNS_copy;
    
public static byte DW_LNS_advance_pc;
    
public static byte DW_LNS_advance_line;
    
public static byte DW_LNS_set_file;
    
public static byte DW_LNS_const_add_pc;
    
public static byte DW_LNE_end_sequence;
    
public static byte DW_LNE_MONO_negate_is_hidden;
    
internal static byte DW_LNE_MONO__extensions_start;
    
internal static byte DW_LNE_MONO__extensions_end;
    
public LineNumberEntry[] LineNumbers { get; }
    protected LineNumberTable(MonoSymbolFile file);
    internal LineNumberTable(MonoSymbolFile file, LineNumberEntry[] lines);
    public LineNumberEntry[] get_LineNumbers();
    internal void Write(MonoSymbolFile file, MyBinaryWriter bw, bool hasColumnsInfo, bool hasEndInfo);
    internal static LineNumberTable Read(MonoSymbolFile file, MyBinaryReader br, bool readColumnsInfo, bool readEndInfo);
    private void DoRead(MonoSymbolFile file, MyBinaryReader br, bool includesColumns, bool includesEnds);
    public bool GetMethodBounds(LineNumberEntry& start, LineNumberEntry& end);
}
internal class Mono.CompilerServices.SymbolWriter.LocalVariableEntry : ValueType {
    
public int Index;
    
public string Name;
    
public int BlockIndex;
    public LocalVariableEntry(int index, string name, int block);
    internal LocalVariableEntry(MonoSymbolFile file, MyBinaryReader reader);
    internal void Write(MonoSymbolFile file, MyBinaryWriter bw);
    public virtual string ToString();
}
internal class Mono.CompilerServices.SymbolWriter.MethodEntry : object {
    
public int CompileUnitIndex;
    
public int Token;
    
public int NamespaceID;
    
private int DataOffset;
    
private int LocalVariableTableOffset;
    
private int LineNumberTableOffset;
    
private int CodeBlockTableOffset;
    
private int ScopeVariableTableOffset;
    
private int RealNameOffset;
    
private Flags flags;
    
private int index;
    
public CompileUnitEntry CompileUnit;
    
private LocalVariableEntry[] locals;
    
private CodeBlockEntry[] code_blocks;
    
private ScopeVariable[] scope_vars;
    
private LineNumberTable lnt;
    
private string real_name;
    
public MonoSymbolFile SymbolFile;
    
public static int Size;
    
public Flags MethodFlags { get; }
    
public int Index { get; public set; }
    internal MethodEntry(MonoSymbolFile file, MyBinaryReader reader, int index);
    internal MethodEntry(MonoSymbolFile file, CompileUnitEntry comp_unit, int token, ScopeVariable[] scope_vars, LocalVariableEntry[] locals, LineNumberEntry[] lines, CodeBlockEntry[] code_blocks, string real_name, Flags flags, int namespace_id);
    public Flags get_MethodFlags();
    public int get_Index();
    public void set_Index(int value);
    private static void CheckLineNumberTable(LineNumberEntry[] line_numbers);
    internal void Write(MyBinaryWriter bw);
    internal void WriteData(MonoSymbolFile file, MyBinaryWriter bw);
    public void ReadAll();
    public LineNumberTable GetLineNumberTable();
    public LocalVariableEntry[] GetLocals();
    public CodeBlockEntry[] GetCodeBlocks();
    public ScopeVariable[] GetScopeVariables();
    public string GetRealName();
    public sealed virtual int CompareTo(object obj);
    public virtual string ToString();
}
internal class Mono.CompilerServices.SymbolWriter.MonoSymbolFile : object {
    
private List`1<MethodEntry> methods;
    
private List`1<SourceFileEntry> sources;
    
private List`1<CompileUnitEntry> comp_units;
    
private Dictionary`2<int, AnonymousScopeEntry> anonymous_scopes;
    
private OffsetTable ot;
    
private int last_type_index;
    
private int last_method_index;
    
private int last_namespace_index;
    
public int MajorVersion;
    
public int MinorVersion;
    
public int NumLineNumbers;
    
private MyBinaryReader reader;
    
private Dictionary`2<int, SourceFileEntry> source_file_hash;
    
private Dictionary`2<int, CompileUnitEntry> compile_unit_hash;
    
private List`1<MethodEntry> method_list;
    
private Dictionary`2<int, MethodEntry> method_token_hash;
    
private Dictionary`2<string, int> source_name_hash;
    
private Guid guid;
    
internal int LineNumberCount;
    
internal int LocalCount;
    
internal int StringSize;
    
internal int LineNumberSize;
    
internal int ExtendedLineNumberSize;
    
public int CompileUnitCount { get; }
    
public int SourceCount { get; }
    
public int MethodCount { get; }
    
public int TypeCount { get; }
    
public int AnonymousScopeCount { get; }
    
public int NamespaceCount { get; }
    
public Guid Guid { get; }
    
public OffsetTable OffsetTable { get; }
    
public SourceFileEntry[] Sources { get; }
    
public CompileUnitEntry[] CompileUnits { get; }
    
public MethodEntry[] Methods { get; }
    
internal MyBinaryReader BinaryReader { get; }
    private MonoSymbolFile(Stream stream);
    public int AddSource(SourceFileEntry source);
    public int AddCompileUnit(CompileUnitEntry entry);
    public void AddMethod(MethodEntry entry);
    public MethodEntry DefineMethod(CompileUnitEntry comp_unit, int token, ScopeVariable[] scope_vars, LocalVariableEntry[] locals, LineNumberEntry[] lines, CodeBlockEntry[] code_blocks, string real_name, Flags flags, int namespace_id);
    internal void DefineAnonymousScope(int id);
    internal void DefineCapturedVariable(int scope_id, string name, string captured_name, CapturedKind kind);
    internal void DefineCapturedScope(int scope_id, int id, string captured_name);
    internal int GetNextTypeIndex();
    internal int GetNextMethodIndex();
    internal int GetNextNamespaceIndex();
    private void Write(MyBinaryWriter bw, Guid guid);
    public void CreateSymbolFile(Guid guid, FileStream fs);
    public static MonoSymbolFile ReadSymbolFile(Assembly assembly);
    public static MonoSymbolFile ReadSymbolFile(string mdbFilename);
    public static MonoSymbolFile ReadSymbolFile(string mdbFilename, Guid assemblyGuid);
    public static MonoSymbolFile ReadSymbolFile(Stream stream);
    public int get_CompileUnitCount();
    public int get_SourceCount();
    public int get_MethodCount();
    public int get_TypeCount();
    public int get_AnonymousScopeCount();
    public int get_NamespaceCount();
    public Guid get_Guid();
    public OffsetTable get_OffsetTable();
    public SourceFileEntry GetSourceFile(int index);
    public SourceFileEntry[] get_Sources();
    public CompileUnitEntry GetCompileUnit(int index);
    public CompileUnitEntry[] get_CompileUnits();
    private void read_methods();
    public MethodEntry GetMethodByToken(int token);
    public MethodEntry GetMethod(int index);
    public MethodEntry[] get_Methods();
    public int FindSource(string file_name);
    public AnonymousScopeEntry GetAnonymousScope(int id);
    internal MyBinaryReader get_BinaryReader();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
internal class Mono.CompilerServices.SymbolWriter.MonoSymbolFileException : Exception {
    public MonoSymbolFileException(string message, Object[] args);
    public MonoSymbolFileException(string message, Exception innerException);
}
internal class Mono.CompilerServices.SymbolWriter.MonoSymbolWriter : object {
    
private List`1<SourceMethodBuilder> methods;
    
private List`1<SourceFileEntry> sources;
    
private List`1<CompileUnitEntry> comp_units;
    
protected MonoSymbolFile file;
    
private string filename;
    
private SourceMethodBuilder current_method;
    
private Stack`1<SourceMethodBuilder> current_method_stack;
    
public MonoSymbolFile SymbolFile { get; }
    public MonoSymbolWriter(string filename);
    public MonoSymbolFile get_SymbolFile();
    public void CloseNamespace();
    public void DefineLocalVariable(int index, string name);
    public void DefineCapturedLocal(int scope_id, string name, string captured_name);
    public void DefineCapturedParameter(int scope_id, string name, string captured_name);
    public void DefineCapturedThis(int scope_id, string captured_name);
    public void DefineCapturedScope(int scope_id, int id, string captured_name);
    public void DefineScopeVariable(int scope, int index);
    public void MarkSequencePoint(int offset, SourceFileEntry file, int line, int column, bool is_hidden);
    public SourceMethodBuilder OpenMethod(ICompileUnit file, int ns_id, IMethodDef method);
    public void CloseMethod();
    public SourceFileEntry DefineDocument(string url);
    public SourceFileEntry DefineDocument(string url, Byte[] guid, Byte[] checksum);
    public CompileUnitEntry DefineCompilationUnit(SourceFileEntry source);
    public int DefineNamespace(string name, CompileUnitEntry unit, String[] using_clauses, int parent);
    public int OpenScope(int start_offset);
    public void CloseScope(int end_offset);
    public void OpenCompilerGeneratedBlock(int start_offset);
    public void CloseCompilerGeneratedBlock(int end_offset);
    public void StartIteratorBody(int start_offset);
    public void EndIteratorBody(int end_offset);
    public void StartIteratorDispatcher(int start_offset);
    public void EndIteratorDispatcher(int end_offset);
    public void DefineAnonymousScope(int id);
    public void WriteSymbolFile(Guid guid);
}
internal class Mono.CompilerServices.SymbolWriter.MyBinaryReader : BinaryReader {
    public MyBinaryReader(Stream stream);
    public int ReadLeb128();
    public string ReadString(int offset);
}
internal class Mono.CompilerServices.SymbolWriter.MyBinaryWriter : BinaryWriter {
    public MyBinaryWriter(Stream stream);
    public void WriteLeb128(int value);
}
internal class Mono.CompilerServices.SymbolWriter.NamespaceEntry : ValueType {
    
public string Name;
    
public int Index;
    
public int Parent;
    
public String[] UsingClauses;
    public NamespaceEntry(string name, int index, String[] using_clauses, int parent);
    internal NamespaceEntry(MonoSymbolFile file, MyBinaryReader reader);
    internal void Write(MonoSymbolFile file, MyBinaryWriter bw);
    public virtual string ToString();
}
internal class Mono.CompilerServices.SymbolWriter.NamespaceInfo : object {
    
public string Name;
    
public int NamespaceID;
    
public ArrayList UsingClauses;
}
internal class Mono.CompilerServices.SymbolWriter.OffsetTable : object {
    
public static int MajorVersion;
    
public static int MinorVersion;
    
public static long Magic;
    
public int TotalFileSize;
    
public int DataSectionOffset;
    
public int DataSectionSize;
    
public int CompileUnitCount;
    
public int CompileUnitTableOffset;
    
public int CompileUnitTableSize;
    
public int SourceCount;
    
public int SourceTableOffset;
    
public int SourceTableSize;
    
public int MethodCount;
    
public int MethodTableOffset;
    
public int MethodTableSize;
    
public int TypeCount;
    
public int AnonymousScopeCount;
    
public int AnonymousScopeTableOffset;
    
public int AnonymousScopeTableSize;
    
public Flags FileFlags;
    
public int LineNumberTable_LineBase;
    
public int LineNumberTable_LineRange;
    
public int LineNumberTable_OpcodeBase;
    internal OffsetTable(BinaryReader reader, int major_version, int minor_version);
    internal void Write(BinaryWriter bw, int major_version, int minor_version);
    public virtual string ToString();
}
internal class Mono.CompilerServices.SymbolWriter.ScopeVariable : ValueType {
    
public int Scope;
    
public int Index;
    public ScopeVariable(int scope, int index);
    internal ScopeVariable(MyBinaryReader reader);
    internal void Write(MyBinaryWriter bw);
    public virtual string ToString();
}
internal class Mono.CompilerServices.SymbolWriter.SourceFileEntry : object {
    
public int Index;
    
private int DataOffset;
    
private MonoSymbolFile file;
    
private string file_name;
    
private Byte[] guid;
    
private Byte[] hash;
    
private bool creating;
    
private bool auto_generated;
    
private string sourceFile;
    
public static int Size { get; }
    
public Byte[] Checksum { get; }
    
public string FileName { get; public set; }
    
public bool AutoGenerated { get; }
    public SourceFileEntry(MonoSymbolFile file, string file_name);
    public SourceFileEntry(MonoSymbolFile file, string sourceFile, Byte[] guid, Byte[] checksum);
    public SourceFileEntry(MonoSymbolFile file, string fileName, string sourceFile, Byte[] guid, Byte[] checksum);
    internal SourceFileEntry(MonoSymbolFile file, MyBinaryReader reader);
    public static int get_Size();
    public Byte[] get_Checksum();
    internal void WriteData(MyBinaryWriter bw);
    internal void Write(BinaryWriter bw);
    public string get_FileName();
    public void set_FileName(string value);
    public bool get_AutoGenerated();
    public void SetAutoGenerated();
    public bool CheckChecksum();
    public virtual string ToString();
}
internal class Mono.CompilerServices.SymbolWriter.SourceMethodBuilder : object {
    
private List`1<LocalVariableEntry> _locals;
    
private List`1<CodeBlockEntry> _blocks;
    
private List`1<ScopeVariable> _scope_vars;
    
private Stack`1<CodeBlockEntry> _block_stack;
    
private List`1<LineNumberEntry> method_lines;
    
private ICompileUnit _comp_unit;
    
private int ns_id;
    
private IMethodDef method;
    
public CodeBlockEntry[] Blocks { get; }
    
public CodeBlockEntry CurrentBlock { get; }
    
public LocalVariableEntry[] Locals { get; }
    
public ICompileUnit SourceFile { get; }
    
public ScopeVariable[] ScopeVariables { get; }
    public SourceMethodBuilder(ICompileUnit comp_unit);
    public SourceMethodBuilder(ICompileUnit comp_unit, int ns_id, IMethodDef method);
    public void MarkSequencePoint(int offset, SourceFileEntry file, int line, int column, bool is_hidden);
    public void MarkSequencePoint(int offset, SourceFileEntry file, int line, int column, int end_line, int end_column, bool is_hidden);
    public void StartBlock(Type type, int start_offset);
    public void StartBlock(Type type, int start_offset, int scopeIndex);
    public void EndBlock(int end_offset);
    public CodeBlockEntry[] get_Blocks();
    public CodeBlockEntry get_CurrentBlock();
    public LocalVariableEntry[] get_Locals();
    public ICompileUnit get_SourceFile();
    public void AddLocal(int index, string name);
    public ScopeVariable[] get_ScopeVariables();
    public void AddScopeVariable(int scope, int index);
    public void DefineMethod(MonoSymbolFile file);
    public void DefineMethod(MonoSymbolFile file, int token);
}
internal class Mono.CompilerServices.SymbolWriter.SourceMethodImpl : object {
    
private string name;
    
private int token;
    
private int namespaceID;
    
public string Name { get; }
    
public int NamespaceID { get; }
    
public int Token { get; }
    public SourceMethodImpl(string name, int token, int namespaceID);
    public sealed virtual string get_Name();
    public int get_NamespaceID();
    public sealed virtual int get_Token();
}
internal class Mono.CompilerServices.SymbolWriter.SymbolDocumentWriterImpl : object {
    
private CompileUnitEntry comp_unit;
    
private SourceFileEntry Mono.CompilerServices.SymbolWriter.ISourceFile.Entry { get; }
    
public CompileUnitEntry Entry { get; }
    public SymbolDocumentWriterImpl(CompileUnitEntry comp_unit);
    public sealed virtual void SetCheckSum(Guid algorithmId, Byte[] checkSum);
    public sealed virtual void SetSource(Byte[] source);
    private sealed virtual override SourceFileEntry Mono.CompilerServices.SymbolWriter.ISourceFile.get_Entry();
    public sealed virtual CompileUnitEntry get_Entry();
}
internal class Mono.CompilerServices.SymbolWriter.SymbolWriterImpl : object {
    
private MonoSymbolWriter msw;
    
private int nextLocalIndex;
    
private int currentToken;
    
private string methodName;
    
private Stack namespaceStack;
    
private bool methodOpened;
    
private Hashtable documents;
    
private Guid guid;
    public SymbolWriterImpl(Guid guid);
    public sealed virtual void Close();
    public sealed virtual void CloseMethod();
    public sealed virtual void CloseNamespace();
    public sealed virtual void CloseScope(int endOffset);
    public sealed virtual ISymbolDocumentWriter DefineDocument(string url, Guid language, Guid languageVendor, Guid documentType);
    public sealed virtual void DefineField(SymbolToken parent, string name, FieldAttributes attributes, Byte[] signature, SymAddressKind addrKind, int addr1, int addr2, int addr3);
    public sealed virtual void DefineGlobalVariable(string name, FieldAttributes attributes, Byte[] signature, SymAddressKind addrKind, int addr1, int addr2, int addr3);
    public sealed virtual void DefineLocalVariable(string name, FieldAttributes attributes, Byte[] signature, SymAddressKind addrKind, int addr1, int addr2, int addr3, int startOffset, int endOffset);
    public sealed virtual void DefineParameter(string name, ParameterAttributes attributes, int sequence, SymAddressKind addrKind, int addr1, int addr2, int addr3);
    public sealed virtual void DefineSequencePoints(ISymbolDocumentWriter document, Int32[] offsets, Int32[] lines, Int32[] columns, Int32[] endLines, Int32[] endColumns);
    public sealed virtual void Initialize(IntPtr emitter, string filename, bool fFullBuild);
    public sealed virtual void OpenMethod(SymbolToken method);
    public sealed virtual void OpenNamespace(string name);
    public sealed virtual int OpenScope(int startOffset);
    public sealed virtual void SetMethodSourceRange(ISymbolDocumentWriter startDoc, int startLine, int startColumn, ISymbolDocumentWriter endDoc, int endLine, int endColumn);
    public sealed virtual void SetScopeRange(int scopeID, int startOffset, int endOffset);
    public sealed virtual void SetSymAttribute(SymbolToken parent, string name, Byte[] data);
    public sealed virtual void SetUnderlyingWriter(IntPtr underlyingWriter);
    public sealed virtual void SetUserEntryPoint(SymbolToken entryMethod);
    public sealed virtual void UsingNamespace(string fullName);
    private int GetCurrentNamespace(ISymbolDocumentWriter doc);
}
internal static class Mono.Disposable : object {
    public static Disposable`1<T> Owned(T value);
    public static Disposable`1<T> NotOwned(T value);
}
internal class Mono.Disposable`1 : ValueType {
    
internal T value;
    
private bool owned;
    public Disposable`1(T value, bool owned);
    public sealed virtual void Dispose();
}
internal static class Mono.Empty`1 : object {
    
public static T[] Array;
    private static Empty`1();
}
internal class Mono.MergeSort`1 : object {
    
private T[] elements;
    
private T[] buffer;
    
private IComparer`1<T> comparer;
    private MergeSort`1(T[] elements, IComparer`1<T> comparer);
    public static void Sort(T[] source, IComparer`1<T> comparer);
    public static void Sort(T[] source, int start, int length, IComparer`1<T> comparer);
    private void Sort(int start, int length);
    private void TopDownSplitMerge(T[] a, T[] b, int start, int end);
    private void TopDownMerge(T[] a, T[] b, int start, int middle, int end);
}
internal static class Mono.Security.Cryptography.CryptoConvert : object {
    private static int ToInt32LE(Byte[] bytes, int offset);
    private static UInt32 ToUInt32LE(Byte[] bytes, int offset);
    private static Byte[] GetBytesLE(int val);
    private static Byte[] Trim(Byte[] array);
    private static RSA FromCapiPrivateKeyBlob(Byte[] blob, int offset);
    private static RSA FromCapiPublicKeyBlob(Byte[] blob, int offset);
    public static RSA FromCapiKeyBlob(Byte[] blob);
    public static RSA FromCapiKeyBlob(Byte[] blob, int offset);
    public static Byte[] ToCapiPublicKeyBlob(RSA rsa);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class MonoMod.<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog : object {
    
public static bool IsWritingLog { get; }
    public static bool get_IsWritingLog();
    [ModuleInitializerAttribute]
internal static void LogVersion();
    public static void Log(LogLevel level, string message);
    public static void Log(LogLevel level, DebugLogInterpolatedStringHandler& message);
    public static void Spam(string message);
    public static void Spam(DebugLogSpamStringHandler& message);
    public static void Trace(string message);
    public static void Trace(DebugLogTraceStringHandler& message);
    public static void Info(string message);
    public static void Info(DebugLogInfoStringHandler& message);
    public static void Warning(string message);
    public static void Warning(DebugLogWarningStringHandler& message);
    public static void Error(string message);
    public static void Error(DebugLogErrorStringHandler& message);
}
[ExtensionAttribute]
internal static class MonoMod.<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MultiTargetShims : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static TypeReference GetConstraintType(GenericParameterConstraint constraint);
}
internal static class MonoMod.Backports.MethodImplOptionsEx : object {
    
public static MethodImplOptions Unmanaged;
    
public static MethodImplOptions NoInlining;
    
public static MethodImplOptions ForwardRef;
    
public static MethodImplOptions Synchronized;
    
public static MethodImplOptions NoOptimization;
    
public static MethodImplOptions PreserveSig;
    
public static MethodImplOptions AggressiveInlining;
    
public static MethodImplOptions AggressiveOptimization;
    
public static MethodImplOptions InternalCall;
}
internal static class MonoMod.Cil.FastDelegateInvokers : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]

private static ValueTuple`2[] invokers;
    
private static int MaxFastInvokerParams;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]

private static ConditionalWeakTable`2<Type, Tuple`2<MethodInfo, Type>> invokerCache;
    private static FastDelegateInvokers();
    [GetFastDelegateInvokersArrayAttribute("16")]
private static ValueTuple`2[] GetInvokers();
    [NullableContextAttribute("1")]
private static Nullable`1<ValueTuple`2<MethodInfo, Type>> TryGetInvokerForSig(MethodSignature sig);
    [NullableContextAttribute("1")]
public static Nullable`1<ValueTuple`2<MethodInfo, Type>> GetDelegateInvoker(Type delegateType);
    private static void InvokeVoidVal1(T0 _0, VoidVal1`1<T0> del);
    private static TResult InvokeTypeVal1(T0 _0, TypeVal1`2<TResult, T0> del);
    private static void InvokeVoidRef1(T0& _0, VoidRef1`1<T0> del);
    private static TResult InvokeTypeRef1(T0& _0, TypeRef1`2<TResult, T0> del);
    private static void InvokeVoidVal2(T0 _0, T1 _1, VoidVal2`2<T0, T1> del);
    private static TResult InvokeTypeVal2(T0 _0, T1 _1, TypeVal2`3<TResult, T0, T1> del);
    private static void InvokeVoidRef2(T0& _0, T1 _1, VoidRef2`2<T0, T1> del);
    private static TResult InvokeTypeRef2(T0& _0, T1 _1, TypeRef2`3<TResult, T0, T1> del);
    private static void InvokeVoidVal3(T0 _0, T1 _1, T2 _2, VoidVal3`3<T0, T1, T2> del);
    private static TResult InvokeTypeVal3(T0 _0, T1 _1, T2 _2, TypeVal3`4<TResult, T0, T1, T2> del);
    private static void InvokeVoidRef3(T0& _0, T1 _1, T2 _2, VoidRef3`3<T0, T1, T2> del);
    private static TResult InvokeTypeRef3(T0& _0, T1 _1, T2 _2, TypeRef3`4<TResult, T0, T1, T2> del);
    private static void InvokeVoidVal4(T0 _0, T1 _1, T2 _2, T3 _3, VoidVal4`4<T0, T1, T2, T3> del);
    private static TResult InvokeTypeVal4(T0 _0, T1 _1, T2 _2, T3 _3, TypeVal4`5<TResult, T0, T1, T2, T3> del);
    private static void InvokeVoidRef4(T0& _0, T1 _1, T2 _2, T3 _3, VoidRef4`4<T0, T1, T2, T3> del);
    private static TResult InvokeTypeRef4(T0& _0, T1 _1, T2 _2, T3 _3, TypeRef4`5<TResult, T0, T1, T2, T3> del);
    private static void InvokeVoidVal5(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, VoidVal5`5<T0, T1, T2, T3, T4> del);
    private static TResult InvokeTypeVal5(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, TypeVal5`6<TResult, T0, T1, T2, T3, T4> del);
    private static void InvokeVoidRef5(T0& _0, T1 _1, T2 _2, T3 _3, T4 _4, VoidRef5`5<T0, T1, T2, T3, T4> del);
    private static TResult InvokeTypeRef5(T0& _0, T1 _1, T2 _2, T3 _3, T4 _4, TypeRef5`6<TResult, T0, T1, T2, T3, T4> del);
    private static void InvokeVoidVal6(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, VoidVal6`6<T0, T1, T2, T3, T4, T5> del);
    private static TResult InvokeTypeVal6(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, TypeVal6`7<TResult, T0, T1, T2, T3, T4, T5> del);
    private static void InvokeVoidRef6(T0& _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, VoidRef6`6<T0, T1, T2, T3, T4, T5> del);
    private static TResult InvokeTypeRef6(T0& _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, TypeRef6`7<TResult, T0, T1, T2, T3, T4, T5> del);
    private static void InvokeVoidVal7(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, VoidVal7`7<T0, T1, T2, T3, T4, T5, T6> del);
    private static TResult InvokeTypeVal7(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, TypeVal7`8<TResult, T0, T1, T2, T3, T4, T5, T6> del);
    private static void InvokeVoidRef7(T0& _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, VoidRef7`7<T0, T1, T2, T3, T4, T5, T6> del);
    private static TResult InvokeTypeRef7(T0& _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, TypeRef7`8<TResult, T0, T1, T2, T3, T4, T5, T6> del);
    private static void InvokeVoidVal8(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, VoidVal8`8<T0, T1, T2, T3, T4, T5, T6, T7> del);
    private static TResult InvokeTypeVal8(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, TypeVal8`9<TResult, T0, T1, T2, T3, T4, T5, T6, T7> del);
    private static void InvokeVoidRef8(T0& _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, VoidRef8`8<T0, T1, T2, T3, T4, T5, T6, T7> del);
    private static TResult InvokeTypeRef8(T0& _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, TypeRef8`9<TResult, T0, T1, T2, T3, T4, T5, T6, T7> del);
    private static void InvokeVoidVal9(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, VoidVal9`9<T0, T1, T2, T3, T4, T5, T6, T7, T8> del);
    private static TResult InvokeTypeVal9(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, TypeVal9`10<TResult, T0, T1, T2, T3, T4, T5, T6, T7, T8> del);
    private static void InvokeVoidRef9(T0& _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, VoidRef9`9<T0, T1, T2, T3, T4, T5, T6, T7, T8> del);
    private static TResult InvokeTypeRef9(T0& _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, TypeRef9`10<TResult, T0, T1, T2, T3, T4, T5, T6, T7, T8> del);
    private static void InvokeVoidVal10(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, VoidVal10`10<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9> del);
    private static TResult InvokeTypeVal10(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, TypeVal10`11<TResult, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9> del);
    private static void InvokeVoidRef10(T0& _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, VoidRef10`10<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9> del);
    private static TResult InvokeTypeRef10(T0& _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, TypeRef10`11<TResult, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9> del);
    private static void InvokeVoidVal11(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, T10 _10, VoidVal11`11<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> del);
    private static TResult InvokeTypeVal11(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, T10 _10, TypeVal11`12<TResult, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> del);
    private static void InvokeVoidRef11(T0& _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, T10 _10, VoidRef11`11<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> del);
    private static TResult InvokeTypeRef11(T0& _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, T10 _10, TypeRef11`12<TResult, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> del);
    private static void InvokeVoidVal12(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, T10 _10, T11 _11, VoidVal12`12<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> del);
    private static TResult InvokeTypeVal12(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, T10 _10, T11 _11, TypeVal12`13<TResult, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> del);
    private static void InvokeVoidRef12(T0& _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, T10 _10, T11 _11, VoidRef12`12<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> del);
    private static TResult InvokeTypeRef12(T0& _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, T10 _10, T11 _11, TypeRef12`13<TResult, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> del);
    private static void InvokeVoidVal13(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, T10 _10, T11 _11, T12 _12, VoidVal13`13<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> del);
    private static TResult InvokeTypeVal13(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, T10 _10, T11 _11, T12 _12, TypeVal13`14<TResult, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> del);
    private static void InvokeVoidRef13(T0& _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, T10 _10, T11 _11, T12 _12, VoidRef13`13<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> del);
    private static TResult InvokeTypeRef13(T0& _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, T10 _10, T11 _11, T12 _12, TypeRef13`14<TResult, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> del);
    private static void InvokeVoidVal14(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, T10 _10, T11 _11, T12 _12, T13 _13, VoidVal14`14<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> del);
    private static TResult InvokeTypeVal14(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, T10 _10, T11 _11, T12 _12, T13 _13, TypeVal14`15<TResult, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> del);
    private static void InvokeVoidRef14(T0& _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, T10 _10, T11 _11, T12 _12, T13 _13, VoidRef14`14<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> del);
    private static TResult InvokeTypeRef14(T0& _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, T10 _10, T11 _11, T12 _12, T13 _13, TypeRef14`15<TResult, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> del);
    private static void InvokeVoidVal15(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, T10 _10, T11 _11, T12 _12, T13 _13, T14 _14, VoidVal15`15<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> del);
    private static TResult InvokeTypeVal15(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, T10 _10, T11 _11, T12 _12, T13 _13, T14 _14, TypeVal15`16<TResult, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> del);
    private static void InvokeVoidRef15(T0& _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, T10 _10, T11 _11, T12 _12, T13 _13, T14 _14, VoidRef15`15<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> del);
    private static TResult InvokeTypeRef15(T0& _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, T10 _10, T11 _11, T12 _12, T13 _13, T14 _14, TypeRef15`16<TResult, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> del);
    private static void InvokeVoidVal16(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, T10 _10, T11 _11, T12 _12, T13 _13, T14 _14, T15 _15, VoidVal16`16<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> del);
    private static TResult InvokeTypeVal16(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, T10 _10, T11 _11, T12 _12, T13 _13, T14 _14, T15 _15, TypeVal16`17<TResult, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> del);
    private static void InvokeVoidRef16(T0& _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, T10 _10, T11 _11, T12 _12, T13 _13, T14 _14, T15 _15, VoidRef16`16<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> del);
    private static TResult InvokeTypeRef16(T0& _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, T10 _10, T11 _11, T12 _12, T13 _13, T14 _14, T15 _15, TypeRef16`17<TResult, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> del);
}
[AttributeUsageAttribute("64")]
internal class MonoMod.Cil.GetFastDelegateInvokersArrayAttribute : Attribute {
    [CompilerGeneratedAttribute]

private int <MaxParams>k__BackingField;
    
public int MaxParams { get; }
    public GetFastDelegateInvokersArrayAttribute(int maxParams);
    [CompilerGeneratedAttribute]
public int get_MaxParams();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class MonoMod.Cil.ILContext : object {
    [CompilerGeneratedAttribute]

private MethodDefinition <Method>k__BackingField;
    [CompilerGeneratedAttribute]

private ILProcessor <IL>k__BackingField;
    
internal List`1<ILLabel> _Labels;
    
private bool disposedValue;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]

private List`1<DataScope`1<DynamicReferenceCell>> managedObjectRefs;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]

private Action OnDispose;
    
public MethodDefinition Method { get; private set; }
    
public ILProcessor IL { get; private set; }
    
public MethodBody Body { get; }
    
public ModuleDefinition Module { get; }
    
public Collection`1<Instruction> Instrs { get; }
    
public ReadOnlyCollection`1<ILLabel> Labels { get; }
    
public bool IsReadOnly { get; }
    public ILContext(MethodDefinition method);
    [CompilerGeneratedAttribute]
public MethodDefinition get_Method();
    [CompilerGeneratedAttribute]
private void set_Method(MethodDefinition value);
    [CompilerGeneratedAttribute]
public ILProcessor get_IL();
    [CompilerGeneratedAttribute]
private void set_IL(ILProcessor value);
    public MethodBody get_Body();
    public ModuleDefinition get_Module();
    public Collection`1<Instruction> get_Instrs();
    public ReadOnlyCollection`1<ILLabel> get_Labels();
    public bool get_IsReadOnly();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void add_OnDispose(Action value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void remove_OnDispose(Action value);
    public void Invoke(Manipulator manip);
    public void MakeReadOnly();
    [ObsoleteAttribute("Use new ILCursor(il).Goto(index)")]
public ILCursor At(int index);
    [ObsoleteAttribute("Use new ILCursor(il).Goto(index)")]
public ILCursor At(ILLabel label);
    [ObsoleteAttribute("Use new ILCursor(il).Goto(index)")]
public ILCursor At(Instruction instr);
    public FieldReference Import(FieldInfo field);
    public MethodReference Import(MethodBase method);
    public TypeReference Import(Type type);
    public ILLabel DefineLabel();
    public ILLabel DefineLabel(Instruction target);
    [NullableContextAttribute("2")]
public int IndexOf(Instruction instr);
    public IEnumerable`1<ILLabel> GetIncomingLabels(Instruction instr);
    [NullableContextAttribute("2")]
public int AddReference(T& value);
    [NullableContextAttribute("2")]
public T GetReference(int id);
    [NullableContextAttribute("2")]
public void SetReference(int id, T& value);
    public DynamicReferenceCell GetReferenceCell(int id);
    public virtual string ToString();
    internal static StringBuilder ToString(StringBuilder builder, Instruction instr);
    protected virtual void Dispose(bool disposing);
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private ILLabel <Invoke>b__26_0(Instruction t);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[EmitILOverloadsAttribute("ILOpcodes.txt", "ILCursor")]
internal class MonoMod.Cil.ILCursor : object {
    [CompilerGeneratedAttribute]

private ILContext <Context>k__BackingField;
    [NullableAttribute("2")]

private Instruction _next;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]

private ILLabel[] _afterLabels;
    
private bool _afterHandlerStarts;
    
private bool _afterHandlerEnds;
    
private SearchTarget _searchTarget;
    
public ILContext Context { get; }
    [NullableAttribute("2")]

public Instruction Next { get; public set; }
    
public Instruction Prev { get; public set; }
    
public Instruction Previous { get; public set; }
    
public int Index { get; public set; }
    
public SearchTarget SearchTarget { get; public set; }
    
public IEnumerable`1<ILLabel> IncomingLabels { get; }
    
public MethodDefinition Method { get; }
    
public ILProcessor IL { get; }
    
public MethodBody Body { get; }
    
public ModuleDefinition Module { get; }
    
public Collection`1<Instruction> Instrs { get; }
    public ILCursor(ILContext context);
    public ILCursor(ILCursor c);
    [CompilerGeneratedAttribute]
public ILContext get_Context();
    [NullableContextAttribute("2")]
public Instruction get_Next();
    [NullableContextAttribute("2")]
public void set_Next(Instruction value);
    public Instruction get_Prev();
    public void set_Prev(Instruction value);
    public Instruction get_Previous();
    public void set_Previous(Instruction value);
    public int get_Index();
    public void set_Index(int value);
    public SearchTarget get_SearchTarget();
    public void set_SearchTarget(SearchTarget value);
    public IEnumerable`1<ILLabel> get_IncomingLabels();
    public MethodDefinition get_Method();
    public ILProcessor get_IL();
    public MethodBody get_Body();
    public ModuleDefinition get_Module();
    public Collection`1<Instruction> get_Instrs();
    public ILCursor Clone();
    public bool IsBefore(Instruction instr);
    public bool IsAfter(Instruction instr);
    public virtual string ToString();
    public ILCursor Goto(Instruction insn, MoveType moveType, bool setTarget);
    public ILCursor MoveAfterLabels();
    public ILCursor MoveAfterLabels(bool intoEHRanges);
    public ILCursor MoveBeforeLabels();
    public ILCursor Goto(int index, MoveType moveType, bool setTarget);
    public ILCursor GotoLabel(ILLabel label, MoveType moveType, bool setTarget);
    public ILCursor GotoNext(MoveType moveType, Func`2[] predicates);
    public bool TryGotoNext(MoveType moveType, Func`2[] predicates);
    public ILCursor GotoPrev(MoveType moveType, Func`2[] predicates);
    public bool TryGotoPrev(MoveType moveType, Func`2[] predicates);
    public ILCursor GotoNext(Func`2[] predicates);
    public bool TryGotoNext(Func`2[] predicates);
    public ILCursor GotoPrev(Func`2[] predicates);
    public bool TryGotoPrev(Func`2[] predicates);
    public void FindNext(ILCursor[]& cursors, Func`2[] predicates);
    public bool TryFindNext(ILCursor[]& cursors, Func`2[] predicates);
    public void FindPrev(ILCursor[]& cursors, Func`2[] predicates);
    public bool TryFindPrev(ILCursor[]& cursors, Func`2[] predicates);
    [NullableContextAttribute("2")]
public void MarkLabel(ILLabel label);
    public ILLabel MarkLabel(Instruction inst);
    public ILLabel MarkLabel();
    public ILLabel DefineLabel();
    private ILCursor _Insert(Instruction instr);
    public ILCursor Remove();
    public ILCursor RemoveRange(int num);
    public ILCursor Emit(OpCode opcode, ParameterDefinition parameter);
    public ILCursor Emit(OpCode opcode, VariableDefinition variable);
    public ILCursor Emit(OpCode opcode, Instruction[] targets);
    public ILCursor Emit(OpCode opcode, Instruction target);
    public ILCursor Emit(OpCode opcode, double value);
    public ILCursor Emit(OpCode opcode, float value);
    public ILCursor Emit(OpCode opcode, long value);
    public ILCursor Emit(OpCode opcode, sbyte value);
    public ILCursor Emit(OpCode opcode, byte value);
    public ILCursor Emit(OpCode opcode, string value);
    public ILCursor Emit(OpCode opcode, FieldReference field);
    public ILCursor Emit(OpCode opcode, CallSite site);
    public ILCursor Emit(OpCode opcode, TypeReference type);
    public ILCursor Emit(OpCode opcode);
    public ILCursor Emit(OpCode opcode, int value);
    public ILCursor Emit(OpCode opcode, MethodReference method);
    public ILCursor Emit(OpCode opcode, FieldInfo field);
    public ILCursor Emit(OpCode opcode, MethodBase method);
    public ILCursor Emit(OpCode opcode, Type type);
    public ILCursor Emit(OpCode opcode, object operand);
    public ILCursor Emit(OpCode opcode, string memberName);
    public int AddReference(T& t);
    [NullableContextAttribute("2")]
public void EmitGetReference(int id);
    [NullableContextAttribute("2")]
public int EmitReference(T& t);
    public int EmitDelegate(T cb);
    public ILCursor EmitAdd();
    public ILCursor EmitAddOvf();
    public ILCursor EmitAddOvfUn();
    public ILCursor EmitAnd();
    public ILCursor EmitArglist();
    public ILCursor EmitBeq(ILLabel operand);
    public ILCursor EmitBeq(Instruction operand);
    public ILCursor EmitBge(ILLabel operand);
    public ILCursor EmitBge(Instruction operand);
    public ILCursor EmitBgeUn(ILLabel operand);
    public ILCursor EmitBgeUn(Instruction operand);
    public ILCursor EmitBgt(ILLabel operand);
    public ILCursor EmitBgt(Instruction operand);
    public ILCursor EmitBgtUn(ILLabel operand);
    public ILCursor EmitBgtUn(Instruction operand);
    public ILCursor EmitBle(ILLabel operand);
    public ILCursor EmitBle(Instruction operand);
    public ILCursor EmitBleUn(ILLabel operand);
    public ILCursor EmitBleUn(Instruction operand);
    public ILCursor EmitBlt(ILLabel operand);
    public ILCursor EmitBlt(Instruction operand);
    public ILCursor EmitBltUn(ILLabel operand);
    public ILCursor EmitBltUn(Instruction operand);
    public ILCursor EmitBneUn(ILLabel operand);
    public ILCursor EmitBneUn(Instruction operand);
    public ILCursor EmitBox(TypeReference operand);
    public ILCursor EmitBox(Type operand);
    public ILCursor EmitBr(ILLabel operand);
    public ILCursor EmitBr(Instruction operand);
    public ILCursor EmitBreak();
    public ILCursor EmitBrfalse(ILLabel operand);
    public ILCursor EmitBrfalse(Instruction operand);
    public ILCursor EmitBrtrue(ILLabel operand);
    public ILCursor EmitBrtrue(Instruction operand);
    public ILCursor EmitCall(MethodReference operand);
    public ILCursor EmitCall(MethodBase operand);
    public ILCursor EmitCalli(IMethodSignature operand);
    public ILCursor EmitCallvirt(MethodReference operand);
    public ILCursor EmitCallvirt(MethodBase operand);
    public ILCursor EmitCastclass(TypeReference operand);
    public ILCursor EmitCastclass(Type operand);
    public ILCursor EmitCeq();
    public ILCursor EmitCgt();
    public ILCursor EmitCgtUn();
    public ILCursor EmitCkfinite();
    public ILCursor EmitClt();
    public ILCursor EmitCltUn();
    public ILCursor EmitConstrained(TypeReference operand);
    public ILCursor EmitConstrained(Type operand);
    public ILCursor EmitConvI();
    public ILCursor EmitConvI1();
    public ILCursor EmitConvI2();
    public ILCursor EmitConvI4();
    public ILCursor EmitConvI8();
    public ILCursor EmitConvOvfI();
    public ILCursor EmitConvOvfIUn();
    public ILCursor EmitConvOvfI1();
    public ILCursor EmitConvOvfI1Un();
    public ILCursor EmitConvOvfI2();
    public ILCursor EmitConvOvfI2Un();
    public ILCursor EmitConvOvfI4();
    public ILCursor EmitConvOvfI4Un();
    public ILCursor EmitConvOvfI8();
    public ILCursor EmitConvOvfI8Un();
    public ILCursor EmitConvOvfU();
    public ILCursor EmitConvOvfUUn();
    public ILCursor EmitConvOvfU1();
    public ILCursor EmitConvOvfU1Un();
    public ILCursor EmitConvOvfU2();
    public ILCursor EmitConvOvfU2Un();
    public ILCursor EmitConvOvfU4();
    public ILCursor EmitConvOvfU4Un();
    public ILCursor EmitConvOvfU8();
    public ILCursor EmitConvOvfU8Un();
    public ILCursor EmitConvRUn();
    public ILCursor EmitConvR4();
    public ILCursor EmitConvR8();
    public ILCursor EmitConvU();
    public ILCursor EmitConvU1();
    public ILCursor EmitConvU2();
    public ILCursor EmitConvU4();
    public ILCursor EmitConvU8();
    public ILCursor EmitCpblk();
    public ILCursor EmitCpobj(TypeReference operand);
    public ILCursor EmitCpobj(Type operand);
    public ILCursor EmitDiv();
    public ILCursor EmitDivUn();
    public ILCursor EmitDup();
    public ILCursor EmitEndfilter();
    public ILCursor EmitEndfinally();
    public ILCursor EmitInitblk();
    public ILCursor EmitInitobj(TypeReference operand);
    public ILCursor EmitInitobj(Type operand);
    public ILCursor EmitIsinst(TypeReference operand);
    public ILCursor EmitIsinst(Type operand);
    public ILCursor EmitJmp(MethodReference operand);
    public ILCursor EmitJmp(MethodBase operand);
    public ILCursor EmitLdarg0();
    public ILCursor EmitLdarg1();
    public ILCursor EmitLdarg2();
    public ILCursor EmitLdarg3();
    public ILCursor EmitLdarg(int operand);
    public ILCursor EmitLdarg(UInt32 operand);
    public ILCursor EmitLdarg(ParameterReference operand);
    public ILCursor EmitLdarga(int operand);
    public ILCursor EmitLdarga(UInt32 operand);
    public ILCursor EmitLdarga(ParameterReference operand);
    public ILCursor EmitLdcI4(int operand);
    public ILCursor EmitLdcI4(UInt32 operand);
    public ILCursor EmitLdcI8(long operand);
    public ILCursor EmitLdcI8(ulong operand);
    public ILCursor EmitLdcR4(float operand);
    public ILCursor EmitLdcR8(double operand);
    public ILCursor EmitLdelemAny(TypeReference operand);
    public ILCursor EmitLdelemAny(Type operand);
    public ILCursor EmitLdelemI();
    public ILCursor EmitLdelemI1();
    public ILCursor EmitLdelemI2();
    public ILCursor EmitLdelemI4();
    public ILCursor EmitLdelemI8();
    public ILCursor EmitLdelemR4();
    public ILCursor EmitLdelemR8();
    public ILCursor EmitLdelemRef();
    public ILCursor EmitLdelemU1();
    public ILCursor EmitLdelemU2();
    public ILCursor EmitLdelemU4();
    public ILCursor EmitLdelema(TypeReference operand);
    public ILCursor EmitLdelema(Type operand);
    public ILCursor EmitLdfld(FieldReference operand);
    public ILCursor EmitLdfld(FieldInfo operand);
    public ILCursor EmitLdflda(FieldReference operand);
    public ILCursor EmitLdflda(FieldInfo operand);
    public ILCursor EmitLdftn(MethodReference operand);
    public ILCursor EmitLdftn(MethodBase operand);
    public ILCursor EmitLdindI();
    public ILCursor EmitLdindI1();
    public ILCursor EmitLdindI2();
    public ILCursor EmitLdindI4();
    public ILCursor EmitLdindI8();
    public ILCursor EmitLdindR4();
    public ILCursor EmitLdindR8();
    public ILCursor EmitLdindRef();
    public ILCursor EmitLdindU1();
    public ILCursor EmitLdindU2();
    public ILCursor EmitLdindU4();
    public ILCursor EmitLdlen();
    public ILCursor EmitLdloc0();
    public ILCursor EmitLdloc1();
    public ILCursor EmitLdloc2();
    public ILCursor EmitLdloc3();
    public ILCursor EmitLdloc(int operand);
    public ILCursor EmitLdloc(UInt32 operand);
    public ILCursor EmitLdloc(VariableReference operand);
    public ILCursor EmitLdloca(int operand);
    public ILCursor EmitLdloca(UInt32 operand);
    public ILCursor EmitLdloca(VariableReference operand);
    public ILCursor EmitLdnull();
    public ILCursor EmitLdobj(TypeReference operand);
    public ILCursor EmitLdobj(Type operand);
    public ILCursor EmitLdsfld(FieldReference operand);
    public ILCursor EmitLdsfld(FieldInfo operand);
    public ILCursor EmitLdsflda(FieldReference operand);
    public ILCursor EmitLdsflda(FieldInfo operand);
    public ILCursor EmitLdstr(string operand);
    public ILCursor EmitLdtoken(IMetadataTokenProvider operand);
    public ILCursor EmitLdtoken(Type operand);
    public ILCursor EmitLdtoken(FieldInfo operand);
    public ILCursor EmitLdtoken(MethodBase operand);
    public ILCursor EmitLdvirtftn(MethodReference operand);
    public ILCursor EmitLdvirtftn(MethodBase operand);
    public ILCursor EmitLeave(ILLabel operand);
    public ILCursor EmitLeave(Instruction operand);
    public ILCursor EmitLocalloc();
    public ILCursor EmitMkrefany(TypeReference operand);
    public ILCursor EmitMkrefany(Type operand);
    public ILCursor EmitMul();
    public ILCursor EmitMulOvf();
    public ILCursor EmitMulOvfUn();
    public ILCursor EmitNeg();
    public ILCursor EmitNewarr(TypeReference operand);
    public ILCursor EmitNewarr(Type operand);
    public ILCursor EmitNewobj(MethodReference operand);
    public ILCursor EmitNewobj(MethodBase operand);
    public ILCursor EmitNop();
    public ILCursor EmitNot();
    public ILCursor EmitOr();
    public ILCursor EmitPop();
    public ILCursor EmitReadonly();
    public ILCursor EmitRefanytype();
    public ILCursor EmitRefanyval(TypeReference operand);
    public ILCursor EmitRefanyval(Type operand);
    public ILCursor EmitRem();
    public ILCursor EmitRemUn();
    public ILCursor EmitRet();
    public ILCursor EmitRethrow();
    public ILCursor EmitShl();
    public ILCursor EmitShr();
    public ILCursor EmitShrUn();
    public ILCursor EmitSizeof(TypeReference operand);
    public ILCursor EmitSizeof(Type operand);
    public ILCursor EmitStarg(int operand);
    public ILCursor EmitStarg(UInt32 operand);
    public ILCursor EmitStarg(ParameterReference operand);
    public ILCursor EmitStelemAny(TypeReference operand);
    public ILCursor EmitStelemAny(Type operand);
    public ILCursor EmitStelemI();
    public ILCursor EmitStelemI1();
    public ILCursor EmitStelemI2();
    public ILCursor EmitStelemI4();
    public ILCursor EmitStelemI8();
    public ILCursor EmitStelemR4();
    public ILCursor EmitStelemR8();
    public ILCursor EmitStelemRef();
    public ILCursor EmitStfld(FieldReference operand);
    public ILCursor EmitStfld(FieldInfo operand);
    public ILCursor EmitStindI();
    public ILCursor EmitStindI1();
    public ILCursor EmitStindI2();
    public ILCursor EmitStindI4();
    public ILCursor EmitStindI8();
    public ILCursor EmitStindR4();
    public ILCursor EmitStindR8();
    public ILCursor EmitStindRef();
    public ILCursor EmitStloc0();
    public ILCursor EmitStloc1();
    public ILCursor EmitStloc2();
    public ILCursor EmitStloc3();
    public ILCursor EmitStloc(int operand);
    public ILCursor EmitStloc(UInt32 operand);
    public ILCursor EmitStloc(VariableReference operand);
    public ILCursor EmitStobj(TypeReference operand);
    public ILCursor EmitStobj(Type operand);
    public ILCursor EmitStsfld(FieldReference operand);
    public ILCursor EmitStsfld(FieldInfo operand);
    public ILCursor EmitSub();
    public ILCursor EmitSubOvf();
    public ILCursor EmitSubOvfUn();
    public ILCursor EmitSwitch(ILLabel[] operand);
    public ILCursor EmitSwitch(Instruction[] operand);
    public ILCursor EmitTail();
    public ILCursor EmitThrow();
    public ILCursor EmitUnaligned(byte operand);
    public ILCursor EmitUnbox(TypeReference operand);
    public ILCursor EmitUnbox(Type operand);
    public ILCursor EmitUnboxAny(TypeReference operand);
    public ILCursor EmitUnboxAny(Type operand);
    public ILCursor EmitVolatile();
    public ILCursor EmitXor();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class MonoMod.Cil.ILLabel : object {
    
private ILContext Context;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]

private Instruction <Target>k__BackingField;
    [NullableAttribute("2")]

public Instruction Target { get; public set; }
    
public IEnumerable`1<Instruction> Branches { get; }
    internal ILLabel(ILContext context);
    internal ILLabel(ILContext context, Instruction target);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public Instruction get_Target();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_Target(Instruction value);
    public IEnumerable`1<Instruction> get_Branches();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool <get_Branches>b__6_0(Instruction i);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
[EmitILOverloadsAttribute("ILOpcodes.txt", "ILMatcher")]
internal static class MonoMod.Cil.ILPatternMatchingExt : object {
    private static bool IsEquivalent(int l, int r);
    private static bool IsEquivalent(int l, UInt32 r);
    private static bool IsEquivalent(long l, long r);
    private static bool IsEquivalent(long l, ulong r);
    private static bool IsEquivalent(float l, float r);
    private static bool IsEquivalent(double l, double r);
    private static bool IsEquivalent(string l, string r);
    private static bool IsEquivalent(ILLabel l, ILLabel r);
    private static bool IsEquivalent(ILLabel l, Instruction r);
    [NullableContextAttribute("2")]
private static bool IsEquivalent(Instruction l, Instruction r);
    private static bool IsEquivalent(TypeReference l, TypeReference r);
    private static bool IsEquivalent(TypeReference l, Type r);
    private static bool IsEquivalent(MethodReference l, MethodReference r);
    private static bool IsEquivalent(MethodReference l, MethodBase r);
    private static bool IsEquivalent(MethodReference l, Type type, string name);
    private static bool IsEquivalent(FieldReference l, FieldReference r);
    private static bool IsEquivalent(FieldReference l, FieldInfo r);
    private static bool IsEquivalent(FieldReference l, Type type, string name);
    private static bool IsEquivalent(ILLabel[] l, ILLabel[] r);
    private static bool IsEquivalent(ILLabel[] l, Instruction[] r);
    private static bool IsEquivalent(IMethodSignature l, IMethodSignature r);
    private static IEnumerable`1<ParameterReference> CastParamsToRef(IMethodSignature sig);
    private static bool IsEquivalent(IMetadataTokenProvider l, IMetadataTokenProvider r);
    private static bool IsEquivalent(IMetadataTokenProvider l, Type r);
    private static bool IsEquivalent(IMetadataTokenProvider l, FieldInfo r);
    private static bool IsEquivalent(IMetadataTokenProvider l, MethodBase r);
    [ExtensionAttribute]
public static bool Match(Instruction instr, OpCode opcode);
    [ExtensionAttribute]
public static bool Match(Instruction instr, OpCode opcode, T value);
    [ExtensionAttribute]
public static bool Match(Instruction instr, OpCode opcode, T& value);
    [ExtensionAttribute]
[ObsoleteAttribute("Leftover from legacy MonoMod, use MatchLeave instead")]
public static bool MatchLeaveS(Instruction instr, ILLabel value);
    [ExtensionAttribute]
[ObsoleteAttribute("Leftover from legacy MonoMod, use MatchLeave instead")]
public static bool MatchLeaveS(Instruction instr, ILLabel& value);
    [ExtensionAttribute]
public static bool MatchLdarg(Instruction instr, Int32& value);
    [ExtensionAttribute]
public static bool MatchStarg(Instruction instr, Int32& value);
    [ExtensionAttribute]
public static bool MatchLdarga(Instruction instr, Int32& value);
    [ExtensionAttribute]
public static bool MatchLdloc(Instruction instr, Int32& value);
    [ExtensionAttribute]
public static bool MatchStloc(Instruction instr, Int32& value);
    [ExtensionAttribute]
public static bool MatchLdloca(Instruction instr, Int32& value);
    [ExtensionAttribute]
public static bool MatchLdcI4(Instruction instr, Int32& value);
    [ExtensionAttribute]
public static bool MatchCallOrCallvirt(Instruction instr, MethodReference& value);
    [ExtensionAttribute]
public static bool MatchNewobj(Instruction instr, Type type);
    [ExtensionAttribute]
public static bool MatchNewobj(Instruction instr);
    [ExtensionAttribute]
public static bool MatchNewobj(Instruction instr, string typeFullName);
    [ExtensionAttribute]
public static bool MatchAdd(Instruction instr);
    [ExtensionAttribute]
public static bool MatchAddOvf(Instruction instr);
    [ExtensionAttribute]
public static bool MatchAddOvfUn(Instruction instr);
    [ExtensionAttribute]
public static bool MatchAnd(Instruction instr);
    [ExtensionAttribute]
public static bool MatchArglist(Instruction instr);
    [ExtensionAttribute]
public static bool MatchBeq(Instruction instr, ILLabel& value);
    [ExtensionAttribute]
public static bool MatchBeq(Instruction instr, ILLabel value);
    [ExtensionAttribute]
public static bool MatchBeq(Instruction instr, Instruction value);
    [ExtensionAttribute]
public static bool MatchBge(Instruction instr, ILLabel& value);
    [ExtensionAttribute]
public static bool MatchBge(Instruction instr, ILLabel value);
    [ExtensionAttribute]
public static bool MatchBge(Instruction instr, Instruction value);
    [ExtensionAttribute]
public static bool MatchBgeUn(Instruction instr, ILLabel& value);
    [ExtensionAttribute]
public static bool MatchBgeUn(Instruction instr, ILLabel value);
    [ExtensionAttribute]
public static bool MatchBgeUn(Instruction instr, Instruction value);
    [ExtensionAttribute]
public static bool MatchBgt(Instruction instr, ILLabel& value);
    [ExtensionAttribute]
public static bool MatchBgt(Instruction instr, ILLabel value);
    [ExtensionAttribute]
public static bool MatchBgt(Instruction instr, Instruction value);
    [ExtensionAttribute]
public static bool MatchBgtUn(Instruction instr, ILLabel& value);
    [ExtensionAttribute]
public static bool MatchBgtUn(Instruction instr, ILLabel value);
    [ExtensionAttribute]
public static bool MatchBgtUn(Instruction instr, Instruction value);
    [ExtensionAttribute]
public static bool MatchBle(Instruction instr, ILLabel& value);
    [ExtensionAttribute]
public static bool MatchBle(Instruction instr, ILLabel value);
    [ExtensionAttribute]
public static bool MatchBle(Instruction instr, Instruction value);
    [ExtensionAttribute]
public static bool MatchBleUn(Instruction instr, ILLabel& value);
    [ExtensionAttribute]
public static bool MatchBleUn(Instruction instr, ILLabel value);
    [ExtensionAttribute]
public static bool MatchBleUn(Instruction instr, Instruction value);
    [ExtensionAttribute]
public static bool MatchBlt(Instruction instr, ILLabel& value);
    [ExtensionAttribute]
public static bool MatchBlt(Instruction instr, ILLabel value);
    [ExtensionAttribute]
public static bool MatchBlt(Instruction instr, Instruction value);
    [ExtensionAttribute]
public static bool MatchBltUn(Instruction instr, ILLabel& value);
    [ExtensionAttribute]
public static bool MatchBltUn(Instruction instr, ILLabel value);
    [ExtensionAttribute]
public static bool MatchBltUn(Instruction instr, Instruction value);
    [ExtensionAttribute]
public static bool MatchBneUn(Instruction instr, ILLabel& value);
    [ExtensionAttribute]
public static bool MatchBneUn(Instruction instr, ILLabel value);
    [ExtensionAttribute]
public static bool MatchBneUn(Instruction instr, Instruction value);
    [ExtensionAttribute]
public static bool MatchBox(Instruction instr, TypeReference& value);
    [ExtensionAttribute]
public static bool MatchBox(Instruction instr, TypeReference value);
    [ExtensionAttribute]
public static bool MatchBox(Instruction instr, Type value);
    [ExtensionAttribute]
public static bool MatchBox(Instruction instr);
    [ExtensionAttribute]
public static bool MatchBox(Instruction instr, string typeFullName);
    [ExtensionAttribute]
public static bool MatchBr(Instruction instr, ILLabel& value);
    [ExtensionAttribute]
public static bool MatchBr(Instruction instr, ILLabel value);
    [ExtensionAttribute]
public static bool MatchBr(Instruction instr, Instruction value);
    [ExtensionAttribute]
public static bool MatchBreak(Instruction instr);
    [ExtensionAttribute]
public static bool MatchBrfalse(Instruction instr, ILLabel& value);
    [ExtensionAttribute]
public static bool MatchBrfalse(Instruction instr, ILLabel value);
    [ExtensionAttribute]
public static bool MatchBrfalse(Instruction instr, Instruction value);
    [ExtensionAttribute]
public static bool MatchBrtrue(Instruction instr, ILLabel& value);
    [ExtensionAttribute]
public static bool MatchBrtrue(Instruction instr, ILLabel value);
    [ExtensionAttribute]
public static bool MatchBrtrue(Instruction instr, Instruction value);
    [ExtensionAttribute]
public static bool MatchCall(Instruction instr, MethodReference& value);
    [ExtensionAttribute]
public static bool MatchCall(Instruction instr, MethodReference value);
    [ExtensionAttribute]
public static bool MatchCall(Instruction instr, MethodBase value);
    [ExtensionAttribute]
public static bool MatchCall(Instruction instr, Type type, string name);
    [ExtensionAttribute]
public static bool MatchCall(Instruction instr, string name);
    [ExtensionAttribute]
public static bool MatchCall(Instruction instr, string typeFullName, string name);
    [ExtensionAttribute]
public static bool MatchCalli(Instruction instr, IMethodSignature& value);
    [ExtensionAttribute]
public static bool MatchCalli(Instruction instr, IMethodSignature value);
    [ExtensionAttribute]
public static bool MatchCallvirt(Instruction instr, MethodReference& value);
    [ExtensionAttribute]
public static bool MatchCallvirt(Instruction instr, MethodReference value);
    [ExtensionAttribute]
public static bool MatchCallvirt(Instruction instr, MethodBase value);
    [ExtensionAttribute]
public static bool MatchCallvirt(Instruction instr, Type type, string name);
    [ExtensionAttribute]
public static bool MatchCallvirt(Instruction instr, string name);
    [ExtensionAttribute]
public static bool MatchCallvirt(Instruction instr, string typeFullName, string name);
    [ExtensionAttribute]
public static bool MatchCallOrCallvirt(Instruction instr, MethodReference value);
    [ExtensionAttribute]
public static bool MatchCallOrCallvirt(Instruction instr, MethodBase value);
    [ExtensionAttribute]
public static bool MatchCallOrCallvirt(Instruction instr, Type type, string name);
    [ExtensionAttribute]
public static bool MatchCallOrCallvirt(Instruction instr, string name);
    [ExtensionAttribute]
public static bool MatchCallOrCallvirt(Instruction instr, string typeFullName, string name);
    [ExtensionAttribute]
public static bool MatchCastclass(Instruction instr, TypeReference& value);
    [ExtensionAttribute]
public static bool MatchCastclass(Instruction instr, TypeReference value);
    [ExtensionAttribute]
public static bool MatchCastclass(Instruction instr, Type value);
    [ExtensionAttribute]
public static bool MatchCastclass(Instruction instr);
    [ExtensionAttribute]
public static bool MatchCastclass(Instruction instr, string typeFullName);
    [ExtensionAttribute]
public static bool MatchCeq(Instruction instr);
    [ExtensionAttribute]
public static bool MatchCgt(Instruction instr);
    [ExtensionAttribute]
public static bool MatchCgtUn(Instruction instr);
    [ExtensionAttribute]
public static bool MatchCkfinite(Instruction instr);
    [ExtensionAttribute]
public static bool MatchClt(Instruction instr);
    [ExtensionAttribute]
public static bool MatchCltUn(Instruction instr);
    [ExtensionAttribute]
public static bool MatchConstrained(Instruction instr, TypeReference& value);
    [ExtensionAttribute]
public static bool MatchConstrained(Instruction instr, TypeReference value);
    [ExtensionAttribute]
public static bool MatchConstrained(Instruction instr, Type value);
    [ExtensionAttribute]
public static bool MatchConstrained(Instruction instr);
    [ExtensionAttribute]
public static bool MatchConstrained(Instruction instr, string typeFullName);
    [ExtensionAttribute]
public static bool MatchConvI(Instruction instr);
    [ExtensionAttribute]
public static bool MatchConvI1(Instruction instr);
    [ExtensionAttribute]
public static bool MatchConvI2(Instruction instr);
    [ExtensionAttribute]
public static bool MatchConvI4(Instruction instr);
    [ExtensionAttribute]
public static bool MatchConvI8(Instruction instr);
    [ExtensionAttribute]
public static bool MatchConvOvfI(Instruction instr);
    [ExtensionAttribute]
public static bool MatchConvOvfIUn(Instruction instr);
    [ExtensionAttribute]
public static bool MatchConvOvfI1(Instruction instr);
    [ExtensionAttribute]
public static bool MatchConvOvfI1Un(Instruction instr);
    [ExtensionAttribute]
public static bool MatchConvOvfI2(Instruction instr);
    [ExtensionAttribute]
public static bool MatchConvOvfI2Un(Instruction instr);
    [ExtensionAttribute]
public static bool MatchConvOvfI4(Instruction instr);
    [ExtensionAttribute]
public static bool MatchConvOvfI4Un(Instruction instr);
    [ExtensionAttribute]
public static bool MatchConvOvfI8(Instruction instr);
    [ExtensionAttribute]
public static bool MatchConvOvfI8Un(Instruction instr);
    [ExtensionAttribute]
public static bool MatchConvOvfU(Instruction instr);
    [ExtensionAttribute]
public static bool MatchConvOvfUUn(Instruction instr);
    [ExtensionAttribute]
public static bool MatchConvOvfU1(Instruction instr);
    [ExtensionAttribute]
public static bool MatchConvOvfU1Un(Instruction instr);
    [ExtensionAttribute]
public static bool MatchConvOvfU2(Instruction instr);
    [ExtensionAttribute]
public static bool MatchConvOvfU2Un(Instruction instr);
    [ExtensionAttribute]
public static bool MatchConvOvfU4(Instruction instr);
    [ExtensionAttribute]
public static bool MatchConvOvfU4Un(Instruction instr);
    [ExtensionAttribute]
public static bool MatchConvOvfU8(Instruction instr);
    [ExtensionAttribute]
public static bool MatchConvOvfU8Un(Instruction instr);
    [ExtensionAttribute]
public static bool MatchConvRUn(Instruction instr);
    [ExtensionAttribute]
public static bool MatchConvR4(Instruction instr);
    [ExtensionAttribute]
public static bool MatchConvR8(Instruction instr);
    [ExtensionAttribute]
public static bool MatchConvU(Instruction instr);
    [ExtensionAttribute]
public static bool MatchConvU1(Instruction instr);
    [ExtensionAttribute]
public static bool MatchConvU2(Instruction instr);
    [ExtensionAttribute]
public static bool MatchConvU4(Instruction instr);
    [ExtensionAttribute]
public static bool MatchConvU8(Instruction instr);
    [ExtensionAttribute]
public static bool MatchCpblk(Instruction instr);
    [ExtensionAttribute]
public static bool MatchCpobj(Instruction instr, TypeReference& value);
    [ExtensionAttribute]
public static bool MatchCpobj(Instruction instr, TypeReference value);
    [ExtensionAttribute]
public static bool MatchCpobj(Instruction instr, Type value);
    [ExtensionAttribute]
public static bool MatchCpobj(Instruction instr);
    [ExtensionAttribute]
public static bool MatchCpobj(Instruction instr, string typeFullName);
    [ExtensionAttribute]
public static bool MatchDiv(Instruction instr);
    [ExtensionAttribute]
public static bool MatchDivUn(Instruction instr);
    [ExtensionAttribute]
public static bool MatchDup(Instruction instr);
    [ExtensionAttribute]
public static bool MatchEndfilter(Instruction instr);
    [ExtensionAttribute]
public static bool MatchEndfinally(Instruction instr);
    [ExtensionAttribute]
public static bool MatchInitblk(Instruction instr);
    [ExtensionAttribute]
public static bool MatchInitobj(Instruction instr, TypeReference& value);
    [ExtensionAttribute]
public static bool MatchInitobj(Instruction instr, TypeReference value);
    [ExtensionAttribute]
public static bool MatchInitobj(Instruction instr, Type value);
    [ExtensionAttribute]
public static bool MatchInitobj(Instruction instr);
    [ExtensionAttribute]
public static bool MatchInitobj(Instruction instr, string typeFullName);
    [ExtensionAttribute]
public static bool MatchIsinst(Instruction instr, TypeReference& value);
    [ExtensionAttribute]
public static bool MatchIsinst(Instruction instr, TypeReference value);
    [ExtensionAttribute]
public static bool MatchIsinst(Instruction instr, Type value);
    [ExtensionAttribute]
public static bool MatchIsinst(Instruction instr);
    [ExtensionAttribute]
public static bool MatchIsinst(Instruction instr, string typeFullName);
    [ExtensionAttribute]
public static bool MatchJmp(Instruction instr, MethodReference& value);
    [ExtensionAttribute]
public static bool MatchJmp(Instruction instr, MethodReference value);
    [ExtensionAttribute]
public static bool MatchJmp(Instruction instr, MethodBase value);
    [ExtensionAttribute]
public static bool MatchJmp(Instruction instr, Type type, string name);
    [ExtensionAttribute]
public static bool MatchJmp(Instruction instr, string name);
    [ExtensionAttribute]
public static bool MatchJmp(Instruction instr, string typeFullName, string name);
    [ExtensionAttribute]
public static bool MatchLdarg0(Instruction instr);
    [ExtensionAttribute]
public static bool MatchLdarg1(Instruction instr);
    [ExtensionAttribute]
public static bool MatchLdarg2(Instruction instr);
    [ExtensionAttribute]
public static bool MatchLdarg3(Instruction instr);
    [ExtensionAttribute]
public static bool MatchLdarg(Instruction instr, int value);
    [ExtensionAttribute]
public static bool MatchLdarg(Instruction instr, UInt32 value);
    [ExtensionAttribute]
public static bool MatchLdarga(Instruction instr, int value);
    [ExtensionAttribute]
public static bool MatchLdarga(Instruction instr, UInt32 value);
    [ExtensionAttribute]
public static bool MatchLdcI4(Instruction instr, int value);
    [ExtensionAttribute]
public static bool MatchLdcI4(Instruction instr, UInt32 value);
    [ExtensionAttribute]
public static bool MatchLdcI8(Instruction instr, Int64& value);
    [ExtensionAttribute]
public static bool MatchLdcI8(Instruction instr, long value);
    [ExtensionAttribute]
public static bool MatchLdcI8(Instruction instr, ulong value);
    [ExtensionAttribute]
public static bool MatchLdcR4(Instruction instr, Single& value);
    [ExtensionAttribute]
public static bool MatchLdcR4(Instruction instr, float value);
    [ExtensionAttribute]
public static bool MatchLdcR8(Instruction instr, Double& value);
    [ExtensionAttribute]
public static bool MatchLdcR8(Instruction instr, double value);
    [ExtensionAttribute]
public static bool MatchLdelemAny(Instruction instr, TypeReference& value);
    [ExtensionAttribute]
public static bool MatchLdelemAny(Instruction instr, TypeReference value);
    [ExtensionAttribute]
public static bool MatchLdelemAny(Instruction instr, Type value);
    [ExtensionAttribute]
public static bool MatchLdelemAny(Instruction instr);
    [ExtensionAttribute]
public static bool MatchLdelemAny(Instruction instr, string typeFullName);
    [ExtensionAttribute]
public static bool MatchLdelemI(Instruction instr);
    [ExtensionAttribute]
public static bool MatchLdelemI1(Instruction instr);
    [ExtensionAttribute]
public static bool MatchLdelemI2(Instruction instr);
    [ExtensionAttribute]
public static bool MatchLdelemI4(Instruction instr);
    [ExtensionAttribute]
public static bool MatchLdelemI8(Instruction instr);
    [ExtensionAttribute]
public static bool MatchLdelemR4(Instruction instr);
    [ExtensionAttribute]
public static bool MatchLdelemR8(Instruction instr);
    [ExtensionAttribute]
public static bool MatchLdelemRef(Instruction instr);
    [ExtensionAttribute]
public static bool MatchLdelemU1(Instruction instr);
    [ExtensionAttribute]
public static bool MatchLdelemU2(Instruction instr);
    [ExtensionAttribute]
public static bool MatchLdelemU4(Instruction instr);
    [ExtensionAttribute]
public static bool MatchLdelema(Instruction instr, TypeReference& value);
    [ExtensionAttribute]
public static bool MatchLdelema(Instruction instr, TypeReference value);
    [ExtensionAttribute]
public static bool MatchLdelema(Instruction instr, Type value);
    [ExtensionAttribute]
public static bool MatchLdelema(Instruction instr);
    [ExtensionAttribute]
public static bool MatchLdelema(Instruction instr, string typeFullName);
    [ExtensionAttribute]
public static bool MatchLdfld(Instruction instr, FieldReference& value);
    [ExtensionAttribute]
public static bool MatchLdfld(Instruction instr, FieldReference value);
    [ExtensionAttribute]
public static bool MatchLdfld(Instruction instr, FieldInfo value);
    [ExtensionAttribute]
public static bool MatchLdfld(Instruction instr, Type type, string name);
    [ExtensionAttribute]
public static bool MatchLdfld(Instruction instr, string name);
    [ExtensionAttribute]
public static bool MatchLdfld(Instruction instr, string typeFullName, string name);
    [ExtensionAttribute]
public static bool MatchLdflda(Instruction instr, FieldReference& value);
    [ExtensionAttribute]
public static bool MatchLdflda(Instruction instr, FieldReference value);
    [ExtensionAttribute]
public static bool MatchLdflda(Instruction instr, FieldInfo value);
    [ExtensionAttribute]
public static bool MatchLdflda(Instruction instr, Type type, string name);
    [ExtensionAttribute]
public static bool MatchLdflda(Instruction instr, string name);
    [ExtensionAttribute]
public static bool MatchLdflda(Instruction instr, string typeFullName, string name);
    [ExtensionAttribute]
public static bool MatchLdftn(Instruction instr, MethodReference& value);
    [ExtensionAttribute]
public static bool MatchLdftn(Instruction instr, MethodReference value);
    [ExtensionAttribute]
public static bool MatchLdftn(Instruction instr, MethodBase value);
    [ExtensionAttribute]
public static bool MatchLdftn(Instruction instr, Type type, string name);
    [ExtensionAttribute]
public static bool MatchLdftn(Instruction instr, string name);
    [ExtensionAttribute]
public static bool MatchLdftn(Instruction instr, string typeFullName, string name);
    [ExtensionAttribute]
public static bool MatchLdindI(Instruction instr);
    [ExtensionAttribute]
public static bool MatchLdindI1(Instruction instr);
    [ExtensionAttribute]
public static bool MatchLdindI2(Instruction instr);
    [ExtensionAttribute]
public static bool MatchLdindI4(Instruction instr);
    [ExtensionAttribute]
public static bool MatchLdindI8(Instruction instr);
    [ExtensionAttribute]
public static bool MatchLdindR4(Instruction instr);
    [ExtensionAttribute]
public static bool MatchLdindR8(Instruction instr);
    [ExtensionAttribute]
public static bool MatchLdindRef(Instruction instr);
    [ExtensionAttribute]
public static bool MatchLdindU1(Instruction instr);
    [ExtensionAttribute]
public static bool MatchLdindU2(Instruction instr);
    [ExtensionAttribute]
public static bool MatchLdindU4(Instruction instr);
    [ExtensionAttribute]
public static bool MatchLdlen(Instruction instr);
    [ExtensionAttribute]
public static bool MatchLdloc0(Instruction instr);
    [ExtensionAttribute]
public static bool MatchLdloc1(Instruction instr);
    [ExtensionAttribute]
public static bool MatchLdloc2(Instruction instr);
    [ExtensionAttribute]
public static bool MatchLdloc3(Instruction instr);
    [ExtensionAttribute]
public static bool MatchLdloc(Instruction instr, int value);
    [ExtensionAttribute]
public static bool MatchLdloc(Instruction instr, UInt32 value);
    [ExtensionAttribute]
public static bool MatchLdloca(Instruction instr, int value);
    [ExtensionAttribute]
public static bool MatchLdloca(Instruction instr, UInt32 value);
    [ExtensionAttribute]
public static bool MatchLdnull(Instruction instr);
    [ExtensionAttribute]
public static bool MatchLdobj(Instruction instr, TypeReference& value);
    [ExtensionAttribute]
public static bool MatchLdobj(Instruction instr, TypeReference value);
    [ExtensionAttribute]
public static bool MatchLdobj(Instruction instr, Type value);
    [ExtensionAttribute]
public static bool MatchLdobj(Instruction instr);
    [ExtensionAttribute]
public static bool MatchLdobj(Instruction instr, string typeFullName);
    [ExtensionAttribute]
public static bool MatchLdsfld(Instruction instr, FieldReference& value);
    [ExtensionAttribute]
public static bool MatchLdsfld(Instruction instr, FieldReference value);
    [ExtensionAttribute]
public static bool MatchLdsfld(Instruction instr, FieldInfo value);
    [ExtensionAttribute]
public static bool MatchLdsfld(Instruction instr, Type type, string name);
    [ExtensionAttribute]
public static bool MatchLdsfld(Instruction instr, string name);
    [ExtensionAttribute]
public static bool MatchLdsfld(Instruction instr, string typeFullName, string name);
    [ExtensionAttribute]
public static bool MatchLdsflda(Instruction instr, FieldReference& value);
    [ExtensionAttribute]
public static bool MatchLdsflda(Instruction instr, FieldReference value);
    [ExtensionAttribute]
public static bool MatchLdsflda(Instruction instr, FieldInfo value);
    [ExtensionAttribute]
public static bool MatchLdsflda(Instruction instr, Type type, string name);
    [ExtensionAttribute]
public static bool MatchLdsflda(Instruction instr, string name);
    [ExtensionAttribute]
public static bool MatchLdsflda(Instruction instr, string typeFullName, string name);
    [ExtensionAttribute]
public static bool MatchLdstr(Instruction instr, String& value);
    [ExtensionAttribute]
public static bool MatchLdstr(Instruction instr, string value);
    [ExtensionAttribute]
public static bool MatchLdtoken(Instruction instr, IMetadataTokenProvider& value);
    [ExtensionAttribute]
public static bool MatchLdtoken(Instruction instr, IMetadataTokenProvider value);
    [ExtensionAttribute]
public static bool MatchLdtoken(Instruction instr, Type value);
    [ExtensionAttribute]
public static bool MatchLdtoken(Instruction instr);
    [ExtensionAttribute]
public static bool MatchLdtoken(Instruction instr, FieldInfo value);
    [ExtensionAttribute]
public static bool MatchLdtoken(Instruction instr, MethodBase value);
    [ExtensionAttribute]
public static bool MatchLdvirtftn(Instruction instr, MethodReference& value);
    [ExtensionAttribute]
public static bool MatchLdvirtftn(Instruction instr, MethodReference value);
    [ExtensionAttribute]
public static bool MatchLdvirtftn(Instruction instr, MethodBase value);
    [ExtensionAttribute]
public static bool MatchLdvirtftn(Instruction instr, Type type, string name);
    [ExtensionAttribute]
public static bool MatchLdvirtftn(Instruction instr, string name);
    [ExtensionAttribute]
public static bool MatchLdvirtftn(Instruction instr, string typeFullName, string name);
    [ExtensionAttribute]
public static bool MatchLeave(Instruction instr, ILLabel& value);
    [ExtensionAttribute]
public static bool MatchLeave(Instruction instr, ILLabel value);
    [ExtensionAttribute]
public static bool MatchLeave(Instruction instr, Instruction value);
    [ExtensionAttribute]
public static bool MatchLocalloc(Instruction instr);
    [ExtensionAttribute]
public static bool MatchMkrefany(Instruction instr, TypeReference& value);
    [ExtensionAttribute]
public static bool MatchMkrefany(Instruction instr, TypeReference value);
    [ExtensionAttribute]
public static bool MatchMkrefany(Instruction instr, Type value);
    [ExtensionAttribute]
public static bool MatchMkrefany(Instruction instr);
    [ExtensionAttribute]
public static bool MatchMkrefany(Instruction instr, string typeFullName);
    [ExtensionAttribute]
public static bool MatchMul(Instruction instr);
    [ExtensionAttribute]
public static bool MatchMulOvf(Instruction instr);
    [ExtensionAttribute]
public static bool MatchMulOvfUn(Instruction instr);
    [ExtensionAttribute]
public static bool MatchNeg(Instruction instr);
    [ExtensionAttribute]
public static bool MatchNewarr(Instruction instr, TypeReference& value);
    [ExtensionAttribute]
public static bool MatchNewarr(Instruction instr, TypeReference value);
    [ExtensionAttribute]
public static bool MatchNewarr(Instruction instr, Type value);
    [ExtensionAttribute]
public static bool MatchNewarr(Instruction instr);
    [ExtensionAttribute]
public static bool MatchNewarr(Instruction instr, string typeFullName);
    [ExtensionAttribute]
public static bool MatchNewobj(Instruction instr, MethodReference& value);
    [ExtensionAttribute]
public static bool MatchNewobj(Instruction instr, MethodReference value);
    [ExtensionAttribute]
public static bool MatchNewobj(Instruction instr, MethodBase value);
    [ExtensionAttribute]
public static bool MatchNewobj(Instruction instr, Type type, string name);
    [ExtensionAttribute]
public static bool MatchNewobj(Instruction instr, string name);
    [ExtensionAttribute]
public static bool MatchNewobj(Instruction instr, string typeFullName, string name);
    [ExtensionAttribute]
public static bool MatchNop(Instruction instr);
    [ExtensionAttribute]
public static bool MatchNot(Instruction instr);
    [ExtensionAttribute]
public static bool MatchOr(Instruction instr);
    [ExtensionAttribute]
public static bool MatchPop(Instruction instr);
    [ExtensionAttribute]
public static bool MatchReadonly(Instruction instr);
    [ExtensionAttribute]
public static bool MatchRefanytype(Instruction instr);
    [ExtensionAttribute]
public static bool MatchRefanyval(Instruction instr, TypeReference& value);
    [ExtensionAttribute]
public static bool MatchRefanyval(Instruction instr, TypeReference value);
    [ExtensionAttribute]
public static bool MatchRefanyval(Instruction instr, Type value);
    [ExtensionAttribute]
public static bool MatchRefanyval(Instruction instr);
    [ExtensionAttribute]
public static bool MatchRefanyval(Instruction instr, string typeFullName);
    [ExtensionAttribute]
public static bool MatchRem(Instruction instr);
    [ExtensionAttribute]
public static bool MatchRemUn(Instruction instr);
    [ExtensionAttribute]
public static bool MatchRet(Instruction instr);
    [ExtensionAttribute]
public static bool MatchRethrow(Instruction instr);
    [ExtensionAttribute]
public static bool MatchShl(Instruction instr);
    [ExtensionAttribute]
public static bool MatchShr(Instruction instr);
    [ExtensionAttribute]
public static bool MatchShrUn(Instruction instr);
    [ExtensionAttribute]
public static bool MatchSizeof(Instruction instr, TypeReference& value);
    [ExtensionAttribute]
public static bool MatchSizeof(Instruction instr, TypeReference value);
    [ExtensionAttribute]
public static bool MatchSizeof(Instruction instr, Type value);
    [ExtensionAttribute]
public static bool MatchSizeof(Instruction instr);
    [ExtensionAttribute]
public static bool MatchSizeof(Instruction instr, string typeFullName);
    [ExtensionAttribute]
public static bool MatchStarg(Instruction instr, int value);
    [ExtensionAttribute]
public static bool MatchStarg(Instruction instr, UInt32 value);
    [ExtensionAttribute]
public static bool MatchStelemAny(Instruction instr, TypeReference& value);
    [ExtensionAttribute]
public static bool MatchStelemAny(Instruction instr, TypeReference value);
    [ExtensionAttribute]
public static bool MatchStelemAny(Instruction instr, Type value);
    [ExtensionAttribute]
public static bool MatchStelemAny(Instruction instr);
    [ExtensionAttribute]
public static bool MatchStelemAny(Instruction instr, string typeFullName);
    [ExtensionAttribute]
public static bool MatchStelemI(Instruction instr);
    [ExtensionAttribute]
public static bool MatchStelemI1(Instruction instr);
    [ExtensionAttribute]
public static bool MatchStelemI2(Instruction instr);
    [ExtensionAttribute]
public static bool MatchStelemI4(Instruction instr);
    [ExtensionAttribute]
public static bool MatchStelemI8(Instruction instr);
    [ExtensionAttribute]
public static bool MatchStelemR4(Instruction instr);
    [ExtensionAttribute]
public static bool MatchStelemR8(Instruction instr);
    [ExtensionAttribute]
public static bool MatchStelemRef(Instruction instr);
    [ExtensionAttribute]
public static bool MatchStfld(Instruction instr, FieldReference& value);
    [ExtensionAttribute]
public static bool MatchStfld(Instruction instr, FieldReference value);
    [ExtensionAttribute]
public static bool MatchStfld(Instruction instr, FieldInfo value);
    [ExtensionAttribute]
public static bool MatchStfld(Instruction instr, Type type, string name);
    [ExtensionAttribute]
public static bool MatchStfld(Instruction instr, string name);
    [ExtensionAttribute]
public static bool MatchStfld(Instruction instr, string typeFullName, string name);
    [ExtensionAttribute]
public static bool MatchStindI(Instruction instr);
    [ExtensionAttribute]
public static bool MatchStindI1(Instruction instr);
    [ExtensionAttribute]
public static bool MatchStindI2(Instruction instr);
    [ExtensionAttribute]
public static bool MatchStindI4(Instruction instr);
    [ExtensionAttribute]
public static bool MatchStindI8(Instruction instr);
    [ExtensionAttribute]
public static bool MatchStindR4(Instruction instr);
    [ExtensionAttribute]
public static bool MatchStindR8(Instruction instr);
    [ExtensionAttribute]
public static bool MatchStindRef(Instruction instr);
    [ExtensionAttribute]
public static bool MatchStloc0(Instruction instr);
    [ExtensionAttribute]
public static bool MatchStloc1(Instruction instr);
    [ExtensionAttribute]
public static bool MatchStloc2(Instruction instr);
    [ExtensionAttribute]
public static bool MatchStloc3(Instruction instr);
    [ExtensionAttribute]
public static bool MatchStloc(Instruction instr, int value);
    [ExtensionAttribute]
public static bool MatchStloc(Instruction instr, UInt32 value);
    [ExtensionAttribute]
public static bool MatchStobj(Instruction instr, TypeReference& value);
    [ExtensionAttribute]
public static bool MatchStobj(Instruction instr, TypeReference value);
    [ExtensionAttribute]
public static bool MatchStobj(Instruction instr, Type value);
    [ExtensionAttribute]
public static bool MatchStobj(Instruction instr);
    [ExtensionAttribute]
public static bool MatchStobj(Instruction instr, string typeFullName);
    [ExtensionAttribute]
public static bool MatchStsfld(Instruction instr, FieldReference& value);
    [ExtensionAttribute]
public static bool MatchStsfld(Instruction instr, FieldReference value);
    [ExtensionAttribute]
public static bool MatchStsfld(Instruction instr, FieldInfo value);
    [ExtensionAttribute]
public static bool MatchStsfld(Instruction instr, Type type, string name);
    [ExtensionAttribute]
public static bool MatchStsfld(Instruction instr, string name);
    [ExtensionAttribute]
public static bool MatchStsfld(Instruction instr, string typeFullName, string name);
    [ExtensionAttribute]
public static bool MatchSub(Instruction instr);
    [ExtensionAttribute]
public static bool MatchSubOvf(Instruction instr);
    [ExtensionAttribute]
public static bool MatchSubOvfUn(Instruction instr);
    [ExtensionAttribute]
public static bool MatchSwitch(Instruction instr, ILLabel[]& value);
    [ExtensionAttribute]
public static bool MatchSwitch(Instruction instr, ILLabel[] value);
    [ExtensionAttribute]
public static bool MatchSwitch(Instruction instr, Instruction[] value);
    [ExtensionAttribute]
public static bool MatchTail(Instruction instr);
    [ExtensionAttribute]
public static bool MatchThrow(Instruction instr);
    [ExtensionAttribute]
public static bool MatchUnaligned(Instruction instr, Byte& value);
    [ExtensionAttribute]
public static bool MatchUnaligned(Instruction instr, byte value);
    [ExtensionAttribute]
public static bool MatchUnbox(Instruction instr, TypeReference& value);
    [ExtensionAttribute]
public static bool MatchUnbox(Instruction instr, TypeReference value);
    [ExtensionAttribute]
public static bool MatchUnbox(Instruction instr, Type value);
    [ExtensionAttribute]
public static bool MatchUnbox(Instruction instr);
    [ExtensionAttribute]
public static bool MatchUnbox(Instruction instr, string typeFullName);
    [ExtensionAttribute]
public static bool MatchUnboxAny(Instruction instr, TypeReference& value);
    [ExtensionAttribute]
public static bool MatchUnboxAny(Instruction instr, TypeReference value);
    [ExtensionAttribute]
public static bool MatchUnboxAny(Instruction instr, Type value);
    [ExtensionAttribute]
public static bool MatchUnboxAny(Instruction instr);
    [ExtensionAttribute]
public static bool MatchUnboxAny(Instruction instr, string typeFullName);
    [ExtensionAttribute]
public static bool MatchVolatile(Instruction instr);
    [ExtensionAttribute]
public static bool MatchXor(Instruction instr);
}
internal enum MonoMod.Cil.MoveType : Enum {
    
public int value__;
    
public static MoveType Before;
    
public static MoveType AfterLabel;
    
public static MoveType After;
}
internal enum MonoMod.Cil.SearchTarget : Enum {
    
public int value__;
    
public static SearchTarget None;
    
public static SearchTarget Next;
    
public static SearchTarget Prev;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class MonoMod.Core.AssemblyInfo : object {
    
public static string AssemblyName;
    
public static string AssemblyVersion;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[CLSCompliantAttribute("True")]
internal class MonoMod.Core.CreateDetourRequest : ValueType {
    [CompilerGeneratedAttribute]

private MethodBase <Source>k__BackingField;
    [CompilerGeneratedAttribute]

private MethodBase <Target>k__BackingField;
    [CompilerGeneratedAttribute]

private bool <ApplyByDefault>k__BackingField;
    
public MethodBase Source { get; public set; }
    
public MethodBase Target { get; public set; }
    
public bool ApplyByDefault { get; public set; }
    public CreateDetourRequest(MethodBase Source, MethodBase Target);
    [CompilerGeneratedAttribute]
public MethodBase get_Source();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>IsExternalInit) set_Source(MethodBase value);
    [CompilerGeneratedAttribute]
public MethodBase get_Target();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>IsExternalInit) set_Target(MethodBase value);
    [CompilerGeneratedAttribute]
public bool get_ApplyByDefault();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>IsExternalInit) set_ApplyByDefault(bool value);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(CreateDetourRequest left, CreateDetourRequest right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(CreateDetourRequest left, CreateDetourRequest right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(CreateDetourRequest other);
    [CompilerGeneratedAttribute]
public void Deconstruct(MethodBase& Source, MethodBase& Target);
}
[IsReadOnlyAttribute]
[CLSCompliantAttribute("True")]
internal class MonoMod.Core.CreateNativeDetourRequest : ValueType {
    [CompilerGeneratedAttribute]

private IntPtr <Source>k__BackingField;
    [CompilerGeneratedAttribute]

private IntPtr <Target>k__BackingField;
    [CompilerGeneratedAttribute]

private bool <ApplyByDefault>k__BackingField;
    
public IntPtr Source { get; public set; }
    
public IntPtr Target { get; public set; }
    
public bool ApplyByDefault { get; public set; }
    public CreateNativeDetourRequest(IntPtr Source, IntPtr Target);
    [CompilerGeneratedAttribute]
public IntPtr get_Source();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>IsExternalInit) set_Source(IntPtr value);
    [CompilerGeneratedAttribute]
public IntPtr get_Target();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>IsExternalInit) set_Target(IntPtr value);
    [CompilerGeneratedAttribute]
public bool get_ApplyByDefault();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>IsExternalInit) set_ApplyByDefault(bool value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(CreateNativeDetourRequest left, CreateNativeDetourRequest right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(CreateNativeDetourRequest left, CreateNativeDetourRequest right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(CreateNativeDetourRequest other);
    [CompilerGeneratedAttribute]
public void Deconstruct(IntPtr& Source, IntPtr& Target);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
[CLSCompliantAttribute("True")]
internal static class MonoMod.Core.DetourFactory : object {
    [NullableAttribute("2")]

private static PlatformTripleDetourFactory lazyCurrent;
    
public static IDetourFactory Current { get; }
    public static IDetourFactory get_Current();
    private static PlatformTripleDetourFactory CreateDefaultFactory();
    [ExtensionAttribute]
public static ICoreDetour CreateDetour(IDetourFactory factory, MethodBase source, MethodBase target, bool applyByDefault);
    [ExtensionAttribute]
public static ICoreNativeDetour CreateNativeDetour(IDetourFactory factory, IntPtr source, IntPtr target, bool applyByDefault);
}
[NullableContextAttribute("1")]
[CLSCompliantAttribute("True")]
internal interface MonoMod.Core.ICoreDetour {
    
public MethodBase Source { get; }
    
public MethodBase Target { get; }
    public abstract virtual MethodBase get_Source();
    public abstract virtual MethodBase get_Target();
}
internal interface MonoMod.Core.ICoreDetourBase {
    
public bool IsApplied { get; }
    public abstract virtual bool get_IsApplied();
    public abstract virtual void Apply();
    public abstract virtual void Undo();
}
internal interface MonoMod.Core.ICoreNativeDetour {
    
public IntPtr Source { get; }
    
public IntPtr Target { get; }
    
public bool HasOrigEntrypoint { get; }
    
public IntPtr OrigEntrypoint { get; }
    public abstract virtual IntPtr get_Source();
    public abstract virtual IntPtr get_Target();
    public abstract virtual bool get_HasOrigEntrypoint();
    public abstract virtual IntPtr get_OrigEntrypoint();
}
[NullableContextAttribute("1")]
[CLSCompliantAttribute("True")]
internal interface MonoMod.Core.IDetourFactory {
    public abstract virtual ICoreDetour CreateDetour(CreateDetourRequest request);
    public abstract virtual ICoreNativeDetour CreateNativeDetour(CreateNativeDetourRequest request);
}
[AttributeUsageAttribute("8")]
internal class MonoMod.Core.Interop.Attributes.FatInterfaceAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
internal class MonoMod.Core.Interop.Attributes.FatInterfaceIgnoreAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("8")]
internal class MonoMod.Core.Interop.Attributes.FatInterfaceImplAttribute : Attribute {
    [CompilerGeneratedAttribute]

private Type <FatInterface>k__BackingField;
    
public Type FatInterface { get; }
    public FatInterfaceImplAttribute(Type fatInterface);
    [CompilerGeneratedAttribute]
public Type get_FatInterface();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("64")]
internal class MonoMod.Core.Interop.Attributes.MultipurposeSlotOffsetTableAttribute : Attribute {
    [CompilerGeneratedAttribute]

private int <Bits>k__BackingField;
    [CompilerGeneratedAttribute]

private Type <HelperType>k__BackingField;
    
public int Bits { get; }
    
public Type HelperType { get; }
    public MultipurposeSlotOffsetTableAttribute(int bits, Type helperType);
    [CompilerGeneratedAttribute]
public int get_Bits();
    [CompilerGeneratedAttribute]
public Type get_HelperType();
}
internal static class MonoMod.Core.Interop.CoreCLR : object {
}
internal static class MonoMod.Core.Interop.Fx : object {
}
internal static class MonoMod.Core.Interop.OSX : object {
    [NullableAttribute("1")]

public static string LibSystem;
    
private static Int32* mach_task_self_;
    
public static int Errno { get; }
    public static int GetPageSize();
    public static void sys_icache_invalidate(Void* start, UIntPtr size);
    public static int MkSTemp(Byte* template);
    public static Int32* __error();
    public static int get_Errno();
    public static kern_return_t mach_vm_region_recurse(int targetTask, UInt64* address, UInt64* size, Int32* nestingDepth, vm_region_submap_short_info_64* info, Int32* infoSize);
    public static kern_return_t mach_vm_protect(int targetTask, ulong address, ulong size, boolean_t setMax, vm_prot_t protection);
    public static kern_return_t mach_vm_allocate(int targetTask, UInt64* address, ulong size, vm_flags flags);
    public static kern_return_t mach_vm_map(int targetTask, UInt64* address, ulong size, ulong mask, vm_flags flags, int object, ulong offset, boolean_t copy, vm_prot_t curProt, vm_prot_t maxProt, vm_inherit_t inheritance);
    public static kern_return_t mach_vm_remap(int targetTask, UInt64* targetAddress, ulong size, ulong offset, vm_flags flags, int srcTask, ulong srcAddress, boolean_t copy, vm_prot_t* curProt, vm_prot_t* maxProt, vm_inherit_t inherit);
    public static kern_return_t mach_make_memory_entry_64(int targetTask, UInt64* size, ulong offset, vm_prot_t permission, Int32* objectHandle, int parentHandle);
    public static kern_return_t mach_vm_deallocate(int targetTask, ulong address, ulong size);
    public static int mach_task_self();
    public static kern_return_t task_info(int targetTask, task_flavor_t flavor, task_dyld_info* taskInfoOut, Int32* taskInfoCnt);
    public static VmProtFmtProxy P(vm_prot_t prot);
}
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{DebuggerDisplay}")]
internal class MonoMod.Core.Interop.PCSTR : ValueType {
    
internal Byte* Value;
    
internal int Length { get; }
    [NullableAttribute("2")]

private string DebuggerDisplay { get; }
    internal PCSTR(Byte* value);
    public static Byte* op_Implicit(PCSTR value);
    public static PCSTR op_Explicit(Byte* value);
    public sealed virtual bool Equals(PCSTR other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    internal int get_Length();
    [NullableContextAttribute("2")]
public virtual string ToString();
    [NullableContextAttribute("2")]
private string get_DebuggerDisplay();
    internal ReadOnlySpan`1<byte> AsSpan();
}
internal static class MonoMod.Core.Interop.Unix : object {
    [NullableAttribute("1")]

public static string LibC;
    
public static int Errno { get; }
    public static IntPtr Read(int fd, IntPtr buf, IntPtr count);
    public static IntPtr Write(int fd, IntPtr buf, IntPtr count);
    public static int Pipe2(Int32* pipefd, PipeFlags flags);
    public static IntPtr Mmap(IntPtr addr, UIntPtr length, Protection prot, MmapFlags flags, int fd, int offset);
    public static int Munmap(IntPtr addr, UIntPtr length);
    public static int Mprotect(IntPtr addr, UIntPtr len, Protection prot);
    public static long Sysconf(SysconfName name);
    public static int Mincore(IntPtr addr, UIntPtr len, Byte* vec);
    public static int MkSTemp(Byte* template);
    public static Int32* __errno_location();
    public static int get_Errno();
}
internal static class MonoMod.Core.Interop.Windows : object {
    
public static int MEM_COMMIT;
    
public static int MEM_RESERVE;
    
public static int MEM_REPLACE_PLACEHOLDER;
    
public static int MEM_RESERVE_PLACEHOLDER;
    
public static int MEM_RESET;
    
public static int MEM_TOP_DOWN;
    
public static int MEM_WRITE_WATCH;
    
public static int MEM_PHYSICAL;
    
public static int MEM_ROTATE;
    
public static int MEM_DIFFERENT_IMAGE_BASE_OK;
    
public static int MEM_RESET_UNDO;
    
public static int MEM_LARGE_PAGES;
    
public static UInt32 MEM_4MB_PAGES;
    
public static int MEM_64K_PAGES;
    
public static int MEM_UNMAP_WITH_TRANSIENT_BOOST;
    
public static int MEM_COALESCE_PLACEHOLDERS;
    
public static int MEM_PRESERVE_PLACEHOLDER;
    
public static int MEM_DECOMMIT;
    
public static int MEM_RELEASE;
    
public static int MEM_FREE;
    
public static int MEM_EXTENDED_PARAMETER_GRAPHICS;
    
public static int MEM_EXTENDED_PARAMETER_NONPAGED;
    
public static int MEM_EXTENDED_PARAMETER_ZERO_PAGES_OPTIONAL;
    
public static int MEM_EXTENDED_PARAMETER_NONPAGED_LARGE;
    
public static int MEM_EXTENDED_PARAMETER_NONPAGED_HUGE;
    
public static int MEM_EXTENDED_PARAMETER_SOFT_FAULT_PAGES;
    
public static int MEM_EXTENDED_PARAMETER_EC_CODE;
    
public static int MEM_EXTENDED_PARAMETER_IMAGE_NO_HPAT;
    
public static long MEM_EXTENDED_PARAMETER_NUMA_NODE_MANDATORY;
    
public static int MEM_EXTENDED_PARAMETER_TYPE_BITS;
    
public static ulong MEM_DEDICATED_ATTRIBUTE_NOT_SPECIFIED;
    
public static int MEM_PRIVATE;
    
public static int MEM_MAPPED;
    
public static int MEM_IMAGE;
    
public static int PAGE_NOACCESS;
    
public static int PAGE_READONLY;
    
public static int PAGE_READWRITE;
    
public static int PAGE_WRITECOPY;
    
public static int PAGE_EXECUTE;
    
public static int PAGE_EXECUTE_READ;
    
public static int PAGE_EXECUTE_READWRITE;
    
public static int PAGE_EXECUTE_WRITECOPY;
    
public static int PAGE_GUARD;
    
public static int PAGE_NOCACHE;
    
public static int PAGE_WRITECOMBINE;
    
public static int PAGE_GRAPHICS_NOACCESS;
    
public static int PAGE_GRAPHICS_READONLY;
    
public static int PAGE_GRAPHICS_READWRITE;
    
public static int PAGE_GRAPHICS_EXECUTE;
    
public static int PAGE_GRAPHICS_EXECUTE_READ;
    
public static int PAGE_GRAPHICS_EXECUTE_READWRITE;
    
public static int PAGE_GRAPHICS_COHERENT;
    
public static int PAGE_GRAPHICS_NOCACHE;
    
public static UInt32 PAGE_ENCLAVE_THREAD_CONTROL;
    
public static UInt32 PAGE_REVERT_TO_FILE_MAP;
    
public static int PAGE_TARGETS_NO_UPDATE;
    
public static int PAGE_TARGETS_INVALID;
    
public static int PAGE_ENCLAVE_UNVALIDATED;
    
public static int PAGE_ENCLAVE_MASK;
    
public static int PAGE_ENCLAVE_DECOMMIT;
    
public static int PAGE_ENCLAVE_SS_FIRST;
    
public static int PAGE_ENCLAVE_SS_REST;
    
public static int PROCESSOR_ARCHITECTURE_INTEL;
    
public static int PROCESSOR_ARCHITECTURE_MIPS;
    
public static int PROCESSOR_ARCHITECTURE_ALPHA;
    
public static int PROCESSOR_ARCHITECTURE_PPC;
    
public static int PROCESSOR_ARCHITECTURE_SHX;
    
public static int PROCESSOR_ARCHITECTURE_ARM;
    
public static int PROCESSOR_ARCHITECTURE_IA64;
    
public static int PROCESSOR_ARCHITECTURE_ALPHA64;
    
public static int PROCESSOR_ARCHITECTURE_MSIL;
    
public static int PROCESSOR_ARCHITECTURE_AMD64;
    
public static int PROCESSOR_ARCHITECTURE_IA32_ON_WIN64;
    
public static int PROCESSOR_ARCHITECTURE_NEUTRAL;
    
public static int PROCESSOR_ARCHITECTURE_ARM64;
    
public static int PROCESSOR_ARCHITECTURE_ARM32_ON_WIN64;
    
public static int PROCESSOR_ARCHITECTURE_IA32_ON_ARM64;
    
public static int PROCESSOR_ARCHITECTURE_UNKNOWN;
    public static Void* VirtualAlloc(Void* lpAddress, UIntPtr dwSize, UInt32 flAllocationType, UInt32 flProtect);
    public static BOOL VirtualProtect(Void* lpAddress, UIntPtr dwSize, UInt32 flNewProtect, UInt32* lpflOldProtect);
    public static BOOL VirtualFree(Void* lpAddress, UIntPtr dwSize, UInt32 dwFreeType);
    public static UIntPtr VirtualQuery(Void* lpAddress, MEMORY_BASIC_INFORMATION* lpBuffer, UIntPtr dwLength);
    public static void GetSystemInfo(SYSTEM_INFO* lpSystemInfo);
    public static HANDLE GetCurrentProcess();
    public static BOOL FlushInstructionCache(HANDLE hProcess, Void* lpBaseAddress, UIntPtr dwSize);
    public static UInt32 GetLastError();
}
[IsReadOnlyAttribute]
internal class MonoMod.Core.Platforms.Abi : ValueType {
    [CompilerGeneratedAttribute]

private ReadOnlyMemory`1<SpecialArgumentKind> <ArgumentOrder>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]

private Classifier <Classifier>k__BackingField;
    [CompilerGeneratedAttribute]

private bool <ReturnsReturnBuffer>k__BackingField;
    
public ReadOnlyMemory`1<SpecialArgumentKind> ArgumentOrder { get; public set; }
    [NullableAttribute("1")]

public Classifier Classifier { get; public set; }
    
public bool ReturnsReturnBuffer { get; public set; }
    public Abi(ReadOnlyMemory`1<SpecialArgumentKind> ArgumentOrder, Classifier Classifier, bool ReturnsReturnBuffer);
    [CompilerGeneratedAttribute]
public ReadOnlyMemory`1<SpecialArgumentKind> get_ArgumentOrder();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>IsExternalInit) set_ArgumentOrder(ReadOnlyMemory`1<SpecialArgumentKind> value);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public Classifier get_Classifier();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>IsExternalInit) set_Classifier(Classifier value);
    [CompilerGeneratedAttribute]
public bool get_ReturnsReturnBuffer();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>IsExternalInit) set_ReturnsReturnBuffer(bool value);
    [NullableContextAttribute("1")]
public TypeClassification Classify(Type type, bool isReturn);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(Abi left, Abi right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(Abi left, Abi right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(Abi other);
    [CompilerGeneratedAttribute]
public void Deconstruct(ReadOnlyMemory`1& ArgumentOrder, Classifier& Classifier, Boolean& ReturnsReturnBuffer);
}
[IsReadOnlyAttribute]
internal class MonoMod.Core.Platforms.AllocationRequest : ValueType {
    [CompilerGeneratedAttribute]

private int <Size>k__BackingField;
    [CompilerGeneratedAttribute]

private int <Alignment>k__BackingField;
    [CompilerGeneratedAttribute]

private bool <Executable>k__BackingField;
    
public int Size { get; public set; }
    
public int Alignment { get; public set; }
    
public bool Executable { get; public set; }
    public AllocationRequest(int Size);
    [CompilerGeneratedAttribute]
public int get_Size();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>IsExternalInit) set_Size(int value);
    [CompilerGeneratedAttribute]
public int get_Alignment();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>IsExternalInit) set_Alignment(int value);
    [CompilerGeneratedAttribute]
public bool get_Executable();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>IsExternalInit) set_Executable(bool value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(AllocationRequest left, AllocationRequest right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(AllocationRequest left, AllocationRequest right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(AllocationRequest other);
    [CompilerGeneratedAttribute]
public void Deconstruct(Int32& Size);
}
[FlagsAttribute]
internal enum MonoMod.Core.Platforms.ArchitectureFeature : Enum {
    
public int value__;
    
public static ArchitectureFeature None;
    
public static ArchitectureFeature FixedInstructionSize;
    
public static ArchitectureFeature Immediate64;
    
public static ArchitectureFeature CreateAltEntryPoint;
}
internal class MonoMod.Core.Platforms.Architectures.AltEntryFactories.IcedAltEntryFactory : object {
    [NullableAttribute("1")]

private ISystem system;
    [NullableAttribute("1")]

private IMemoryAllocator alloc;
    
private int bitness;
    [NullableContextAttribute("1")]
public IcedAltEntryFactory(ISystem system, int bitness);
    [NullableContextAttribute("2")]
public sealed virtual IntPtr CreateAlternateEntrypoint(IntPtr entrypoint, int minLength, IDisposable& handle);
}
internal abstract class MonoMod.Core.Platforms.Architectures.DetourKindBase : object {
    
public int Size { get; }
    public abstract virtual int get_Size();
    [NullableContextAttribute("2")]
public abstract virtual int GetBytes(IntPtr from, IntPtr to, Span`1<byte> buffer, object data, IDisposable& allocHandle);
    public static int GetDetourBytes(NativeDetourInfo info, Span`1<byte> buffer, IDisposable& allocHandle);
    public abstract virtual bool TryGetRetargetInfo(NativeDetourInfo orig, IntPtr to, int maxSize, NativeDetourInfo& retargetInfo);
    public static bool TryFindRetargetInfo(NativeDetourInfo info, IntPtr to, int maxSize, NativeDetourInfo& retargetInfo);
    [NullableContextAttribute("2")]
public abstract virtual int DoRetarget(NativeDetourInfo origInfo, IntPtr to, Span`1<byte> buffer, object data, IDisposable& allocationHandle, Boolean& needsRepatch, Boolean& disposeOldAlloc);
    public static int DoRetarget(NativeDetourInfo orig, NativeDetourInfo info, Span`1<byte> buffer, IDisposable& allocationHandle, Boolean& needsRepatch, Boolean& disposeOldAlloc);
}
internal static class MonoMod.Core.Platforms.Architectures.Shared : object {
    public static ReadOnlyMemory`1<IAllocatedMemory> CreateVtableStubs(ISystem system, IntPtr vtableBase, int vtableSize, ReadOnlySpan`1<byte> stubData, int indexOffs, bool premulOffset);
    [CompilerGeneratedAttribute]
internal static void <CreateVtableStubs>g__FillBufferIndicies|0_0(int stubSize, int indexOffs, int numPerAlloc, int i, Span`1<byte> mainAllocBuf, bool premul);
    [CompilerGeneratedAttribute]
internal static void <CreateVtableStubs>g__FillVtbl|0_1(int stubSize, int baseIndex, IntPtr& vtblBase, int numEntries, IntPtr baseAddr);
}
internal class MonoMod.Core.Platforms.Architectures.x86_64Arch : object {
    [NullableAttribute("2")]

private BytePatternCollection lazyKnownMethodThunks;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]

private IAltEntryFactory <AltEntryFactory>k__BackingField;
    [NullableAttribute("1")]

private ISystem system;
    
private static int VtblProxyStubIdxOffs;
    
private static bool VtblProxyStubIdxPremul;
    
private static int SpecEntryStubArgOffs;
    
private static int SpecEntryStubTargetOffs;
    
public ArchitectureKind Target { get; }
    
public ArchitectureFeature Features { get; }
    [NullableAttribute("1")]

public BytePatternCollection KnownMethodThunks { get; }
    [NullableAttribute("1")]

public IAltEntryFactory AltEntryFactory { get; }
    
private static ReadOnlySpan`1<byte> VtblProxyStubWin { get; }
    
private static ReadOnlySpan`1<byte> VtblProxyStubSysV { get; }
    
private static ReadOnlySpan`1<byte> SpecEntryStub { get; }
    [NullableContextAttribute("1")]
public x86_64Arch(ISystem system);
    public sealed virtual ArchitectureKind get_Target();
    public sealed virtual ArchitectureFeature get_Features();
    [NullableContextAttribute("1")]
public sealed virtual BytePatternCollection get_KnownMethodThunks();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public sealed virtual IAltEntryFactory get_AltEntryFactory();
    [NullableContextAttribute("1")]
private static BytePatternCollection CreateKnownMethodThunks();
    public sealed virtual NativeDetourInfo ComputeDetourInfo(IntPtr from, IntPtr to, int sizeHint);
    public sealed virtual int GetDetourBytes(NativeDetourInfo info, Span`1<byte> buffer, IDisposable& allocHandle);
    public sealed virtual NativeDetourInfo ComputeRetargetInfo(NativeDetourInfo detour, IntPtr to, int maxSizeHint);
    public sealed virtual int GetRetargetBytes(NativeDetourInfo original, NativeDetourInfo retarget, Span`1<byte> buffer, IDisposable& allocationHandle, Boolean& needsRepatch, Boolean& disposeOldAlloc);
    private static ReadOnlySpan`1<byte> get_VtblProxyStubWin();
    private static ReadOnlySpan`1<byte> get_VtblProxyStubSysV();
    public sealed virtual ReadOnlyMemory`1<IAllocatedMemory> CreateNativeVtableProxyStubs(IntPtr vtableBase, int vtableSize);
    private static ReadOnlySpan`1<byte> get_SpecEntryStub();
    [NullableContextAttribute("1")]
public sealed virtual IAllocatedMemory CreateSpecialEntryStub(IntPtr target, IntPtr argument);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class MonoMod.Core.Platforms.Architectures.x86Arch : object {
    [NullableAttribute("2")]

private BytePatternCollection lazyKnownMethodThunks;
    [CompilerGeneratedAttribute]

private IAltEntryFactory <AltEntryFactory>k__BackingField;
    
private ISystem system;
    
private static int WinThisVtableThunkIndexOffs;
    
private static int SpecEntryStubArgOffs;
    
private static int SpecEntryStubTargetOffs;
    
public ArchitectureKind Target { get; }
    
public ArchitectureFeature Features { get; }
    
public BytePatternCollection KnownMethodThunks { get; }
    
public IAltEntryFactory AltEntryFactory { get; }
    [NullableAttribute("0")]

private static ReadOnlySpan`1<byte> WinThisVtableProxyThunk { get; }
    [NullableAttribute("0")]

private static ReadOnlySpan`1<byte> SpecEntryStub { get; }
    public x86Arch(ISystem system);
    public sealed virtual ArchitectureKind get_Target();
    public sealed virtual ArchitectureFeature get_Features();
    public sealed virtual BytePatternCollection get_KnownMethodThunks();
    [CompilerGeneratedAttribute]
public sealed virtual IAltEntryFactory get_AltEntryFactory();
    private static BytePatternCollection CreateKnownMethodThunks();
    public sealed virtual NativeDetourInfo ComputeDetourInfo(IntPtr from, IntPtr to, int maxSizeHint);
    [NullableContextAttribute("0")]
public sealed virtual int GetDetourBytes(NativeDetourInfo info, Span`1<byte> buffer, IDisposable& allocationHandle);
    public sealed virtual NativeDetourInfo ComputeRetargetInfo(NativeDetourInfo detour, IntPtr to, int maxSizeHint);
    [NullableContextAttribute("0")]
public sealed virtual int GetRetargetBytes(NativeDetourInfo original, NativeDetourInfo retarget, Span`1<byte> buffer, IDisposable& allocationHandle, Boolean& needsRepatch, Boolean& disposeOldAlloc);
    [NullableContextAttribute("0")]
private static ReadOnlySpan`1<byte> get_WinThisVtableProxyThunk();
    public sealed virtual ReadOnlyMemory`1<IAllocatedMemory> CreateNativeVtableProxyStubs(IntPtr vtableBase, int vtableSize);
    [NullableContextAttribute("0")]
private static ReadOnlySpan`1<byte> get_SpecEntryStub();
    public sealed virtual IAllocatedMemory CreateSpecialEntryStub(IntPtr target, IntPtr argument);
}
internal static class MonoMod.Core.Platforms.Architectures.x86Shared : object {
    public static void FixSizeHint(Int32& sizeHint);
    public static bool TryRel32Detour(IntPtr from, IntPtr to, int sizeHint, NativeDetourInfo& info);
    public static bool Is32Bit(long to);
}
internal class MonoMod.Core.Platforms.Classifier : MulticastDelegate {
    public Classifier(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual TypeClassification Invoke(Type type, bool isReturn);
    public virtual IAsyncResult BeginInvoke(Type type, bool isReturn, AsyncCallback callback, object object);
    public virtual TypeClassification EndInvoke(IAsyncResult result);
}
[IsReadOnlyAttribute]
internal class MonoMod.Core.Platforms.FeatureFlags : ValueType {
    [CompilerGeneratedAttribute]

private ArchitectureFeature <Architecture>k__BackingField;
    [CompilerGeneratedAttribute]

private SystemFeature <System>k__BackingField;
    [CompilerGeneratedAttribute]

private RuntimeFeature <Runtime>k__BackingField;
    
public ArchitectureFeature Architecture { get; }
    
public SystemFeature System { get; }
    
public RuntimeFeature Runtime { get; }
    public FeatureFlags(ArchitectureFeature archFlags, SystemFeature sysFlags, RuntimeFeature runtimeFlags);
    [CompilerGeneratedAttribute]
public ArchitectureFeature get_Architecture();
    [CompilerGeneratedAttribute]
public SystemFeature get_System();
    [CompilerGeneratedAttribute]
public RuntimeFeature get_Runtime();
    public bool Has(RuntimeFeature feature);
    public bool Has(ArchitectureFeature feature);
    public bool Has(SystemFeature feature);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(FeatureFlags other);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public virtual string ToString();
    public static bool op_Equality(FeatureFlags left, FeatureFlags right);
    public static bool op_Inequality(FeatureFlags left, FeatureFlags right);
}
internal class MonoMod.Core.Platforms.GetExceptionSlot : MulticastDelegate {
    public GetExceptionSlot(object object, IntPtr method);
    public virtual IntPtr* Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual IntPtr* EndInvoke(IAsyncResult result);
}
internal interface MonoMod.Core.Platforms.IAllocatedMemory {
    
public bool IsExecutable { get; }
    
public IntPtr BaseAddress { get; }
    
public int Size { get; }
    
public Span`1<byte> Memory { get; }
    public abstract virtual bool get_IsExecutable();
    public abstract virtual IntPtr get_BaseAddress();
    public abstract virtual int get_Size();
    public abstract virtual Span`1<byte> get_Memory();
}
[NullableContextAttribute("2")]
internal interface MonoMod.Core.Platforms.IAltEntryFactory {
    public abstract virtual IntPtr CreateAlternateEntrypoint(IntPtr entrypoint, int minLength, IDisposable& handle);
}
[NullableContextAttribute("1")]
internal interface MonoMod.Core.Platforms.IArchitecture {
    
public ArchitectureKind Target { get; }
    
public ArchitectureFeature Features { get; }
    
public BytePatternCollection KnownMethodThunks { get; }
    
public IAltEntryFactory AltEntryFactory { get; }
    public abstract virtual ArchitectureKind get_Target();
    public abstract virtual ArchitectureFeature get_Features();
    public abstract virtual BytePatternCollection get_KnownMethodThunks();
    public abstract virtual IAltEntryFactory get_AltEntryFactory();
    public abstract virtual NativeDetourInfo ComputeDetourInfo(IntPtr from, IntPtr target, int maxSizeHint);
    [NullableContextAttribute("0")]
public abstract virtual int GetDetourBytes(NativeDetourInfo info, Span`1<byte> buffer, IDisposable& allocationHandle);
    public abstract virtual NativeDetourInfo ComputeRetargetInfo(NativeDetourInfo detour, IntPtr target, int maxSizeHint);
    [NullableContextAttribute("0")]
public abstract virtual int GetRetargetBytes(NativeDetourInfo original, NativeDetourInfo retarget, Span`1<byte> buffer, IDisposable& allocationHandle, Boolean& needsRepatch, Boolean& disposeOldAlloc);
    public abstract virtual ReadOnlyMemory`1<IAllocatedMemory> CreateNativeVtableProxyStubs(IntPtr vtableBase, int vtableSize);
    public abstract virtual IAllocatedMemory CreateSpecialEntryStub(IntPtr target, IntPtr argument);
}
[NullableContextAttribute("1")]
internal interface MonoMod.Core.Platforms.IMemoryAllocator {
    
public int MaxSize { get; }
    public abstract virtual int get_MaxSize();
    public abstract virtual bool TryAllocate(AllocationRequest request, IAllocatedMemory& allocated);
    public abstract virtual bool TryAllocateInRange(PositionedAllocationRequest request, IAllocatedMemory& allocated);
}
internal interface MonoMod.Core.Platforms.INativeDetourKind {
    
public int Size { get; }
    public abstract virtual int get_Size();
}
[NullableContextAttribute("1")]
internal interface MonoMod.Core.Platforms.INativeExceptionHelper {
    
public GetExceptionSlot GetExceptionSlot { get; }
    public abstract virtual GetExceptionSlot get_GetExceptionSlot();
    [NullableContextAttribute("2")]
public abstract virtual IntPtr CreateNativeToManagedHelper(IntPtr target, IDisposable& handle);
    [NullableContextAttribute("2")]
public abstract virtual IntPtr CreateManagedToNativeHelper(IntPtr target, IDisposable& handle);
}
[NullableContextAttribute("1")]
internal interface MonoMod.Core.Platforms.IRuntime {
    
public RuntimeKind Target { get; }
    
public RuntimeFeature Features { get; }
    
public Abi Abi { get; }
    public abstract virtual RuntimeKind get_Target();
    public abstract virtual RuntimeFeature get_Features();
    public abstract virtual Abi get_Abi();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public abstract virtual void add_OnMethodCompiled(OnMethodCompiledCallback value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public abstract virtual void remove_OnMethodCompiled(OnMethodCompiledCallback value);
    public abstract virtual MethodBase GetIdentifiable(MethodBase method);
    public abstract virtual RuntimeMethodHandle GetMethodHandle(MethodBase method);
    public abstract virtual void DisableInlining(MethodBase method);
    public abstract virtual IDisposable PinMethodIfNeeded(MethodBase method);
    public abstract virtual IntPtr GetMethodEntryPoint(MethodBase method);
    public abstract virtual void Compile(MethodBase method);
}
[NullableContextAttribute("1")]
internal interface MonoMod.Core.Platforms.ISystem {
    
public OSKind Target { get; }
    
public SystemFeature Features { get; }
    
public Nullable`1<Abi> DefaultAbi { get; }
    
public IMemoryAllocator MemoryAllocator { get; }
    [NullableAttribute("2")]

public INativeExceptionHelper NativeExceptionHelper { get; }
    public abstract virtual OSKind get_Target();
    public abstract virtual SystemFeature get_Features();
    public abstract virtual Nullable`1<Abi> get_DefaultAbi();
    public abstract virtual IMemoryAllocator get_MemoryAllocator();
    [NullableContextAttribute("2")]
public abstract virtual INativeExceptionHelper get_NativeExceptionHelper();
    public abstract virtual IEnumerable`1<string> EnumerateLoadedModuleFiles();
    public abstract virtual IntPtr GetSizeOfReadableMemory(IntPtr start, IntPtr guess);
    [NullableContextAttribute("0")]
public abstract virtual void PatchData(PatchTargetKind targetKind, IntPtr patchTarget, ReadOnlySpan`1<byte> data, Span`1<byte> backup);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class MonoMod.Core.Platforms.Memory.PagedMemoryAllocator : object {
    [NativeIntegerAttribute]

private IntPtr pageBaseMask;
    [NativeIntegerAttribute]

private IntPtr pageSize;
    
private bool pageSizeIsPow2;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]

private Page[] allocationList;
    
private int pageCount;
    
private ConcurrentBag`1<Page> pagesToClean;
    
private int registeredForCleanup;
    
private object sync;
    [NativeIntegerAttribute]

protected IntPtr PageSize { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]

private ReadOnlySpan`1<Page> AllocList { get; }
    
public int MaxSize { get; }
    protected PagedMemoryAllocator(IntPtr pageSize);
    protected IntPtr get_PageSize();
    public IntPtr RoundDownToPageBoundary(IntPtr addr);
    protected void InsertAllocatedPage(Page page);
    private void RemoveAllocatedPage(Page page);
    private ReadOnlySpan`1<Page> get_AllocList();
    private int GetBoundIndex(IntPtr ptr);
    protected void RegisterForCleanup(Page page);
    private bool DoCleanup();
    protected abstract virtual bool TryFreePage(Page page, String& errorMsg);
    public sealed virtual int get_MaxSize();
    public sealed virtual bool TryAllocateInRange(PositionedAllocationRequest request, IAllocatedMemory& allocated);
    private static bool TryAllocWithPage(Page page, PositionedAllocationRequest request, IAllocatedMemory& allocated);
    public sealed virtual bool TryAllocate(AllocationRequest request, IAllocatedMemory& allocated);
    protected abstract virtual bool TryAllocateNewPage(AllocationRequest request, IAllocatedMemory& allocated);
    protected abstract virtual bool TryAllocateNewPage(PositionedAllocationRequest request, IntPtr targetPage, IntPtr lowPageBound, IntPtr highPageBound, IAllocatedMemory& allocated);
}
internal abstract class MonoMod.Core.Platforms.Memory.QueryingMemoryPageAllocatorBase : object {
    
public UInt32 PageSize { get; }
    public abstract virtual UInt32 get_PageSize();
    public abstract virtual bool TryQueryPage(IntPtr pageAddr, Boolean& isFree, IntPtr& allocBase, IntPtr& allocSize);
    public abstract virtual bool TryAllocatePage(IntPtr size, bool executable, IntPtr& allocated);
    public abstract virtual bool TryAllocatePage(IntPtr pageAddr, IntPtr size, bool executable, IntPtr& allocated);
    [NullableContextAttribute("2")]
public abstract virtual bool TryFreePage(IntPtr pageAddr, String& errorMsg);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class MonoMod.Core.Platforms.Memory.QueryingPagedMemoryAllocator : PagedMemoryAllocator {
    
private QueryingMemoryPageAllocatorBase pageAlloc;
    public QueryingPagedMemoryAllocator(QueryingMemoryPageAllocatorBase alloc);
    protected virtual bool TryAllocateNewPage(AllocationRequest request, IAllocatedMemory& allocated);
    protected virtual bool TryAllocateNewPage(PositionedAllocationRequest request, IntPtr targetPage, IntPtr lowPageBound, IntPtr highPageBound, IAllocatedMemory& allocated);
    private bool TryAllocNewPage(PositionedAllocationRequest request, IntPtr& page, bool goingUp, IAllocatedMemory& allocated);
    protected virtual bool TryFreePage(Page page, String& errorMsg);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class MonoMod.Core.Platforms.NativeDetourInfo : ValueType {
    [CompilerGeneratedAttribute]

private IntPtr <From>k__BackingField;
    [CompilerGeneratedAttribute]

private IntPtr <To>k__BackingField;
    [CompilerGeneratedAttribute]

private INativeDetourKind <InternalKind>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]

private IDisposable <InternalData>k__BackingField;
    
public IntPtr From { get; public set; }
    
public IntPtr To { get; public set; }
    
public INativeDetourKind InternalKind { get; public set; }
    [NullableAttribute("2")]

public IDisposable InternalData { get; public set; }
    
public int Size { get; }
    public NativeDetourInfo(IntPtr From, IntPtr To, INativeDetourKind InternalKind, IDisposable InternalData);
    [CompilerGeneratedAttribute]
public IntPtr get_From();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>IsExternalInit) set_From(IntPtr value);
    [CompilerGeneratedAttribute]
public IntPtr get_To();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>IsExternalInit) set_To(IntPtr value);
    [CompilerGeneratedAttribute]
public INativeDetourKind get_InternalKind();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>IsExternalInit) set_InternalKind(INativeDetourKind value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public IDisposable get_InternalData();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>IsExternalInit) set_InternalData(IDisposable value);
    public int get_Size();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(NativeDetourInfo left, NativeDetourInfo right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(NativeDetourInfo left, NativeDetourInfo right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(NativeDetourInfo other);
    [CompilerGeneratedAttribute]
public void Deconstruct(IntPtr& From, IntPtr& To, INativeDetourKind& InternalKind, IDisposable& InternalData);
}
internal class MonoMod.Core.Platforms.OnMethodCompiledCallback : MulticastDelegate {
    public OnMethodCompiledCallback(object object, IntPtr method);
    [NullableContextAttribute("2")]
public virtual void Invoke(RuntimeMethodHandle methodHandle, MethodBase method, IntPtr codeStart, IntPtr codeRw, ulong codeSize);
    public virtual IAsyncResult BeginInvoke(RuntimeMethodHandle methodHandle, MethodBase method, IntPtr codeStart, IntPtr codeRw, ulong codeSize, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal enum MonoMod.Core.Platforms.PatchTargetKind : Enum {
    
public int value__;
    
public static PatchTargetKind Executable;
    
public static PatchTargetKind ReadOnly;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class MonoMod.Core.Platforms.PlatformTriple : object {
    [CompilerGeneratedAttribute]

private IArchitecture <Architecture>k__BackingField;
    [CompilerGeneratedAttribute]

private ISystem <System>k__BackingField;
    [CompilerGeneratedAttribute]

private IRuntime <Runtime>k__BackingField;
    
private static object lazyCurrentLock;
    [NullableAttribute("2")]

private static PlatformTriple lazyCurrent;
    [CompilerGeneratedAttribute]

private FeatureFlags <SupportedFeatures>k__BackingField;
    [CompilerGeneratedAttribute]

private Abi <Abi>k__BackingField;
    
private IntPtr ThePreStub;
    
public IArchitecture Architecture { get; }
    
public ISystem System { get; }
    
public IRuntime Runtime { get; }
    
public static PlatformTriple Current { get; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("0")]

public ValueTuple`3<ArchitectureKind, OSKind, RuntimeKind> HostTriple { get; }
    
public FeatureFlags SupportedFeatures { get; }
    
public Abi Abi { get; }
    [EditorBrowsableAttribute("2")]
public PlatformTriple(IArchitecture architecture, ISystem system, IRuntime runtime);
    private static PlatformTriple();
    [EditorBrowsableAttribute("2")]
public static IRuntime CreateCurrentRuntime(ISystem system, IArchitecture arch);
    [EditorBrowsableAttribute("2")]
public static IArchitecture CreateCurrentArchitecture(ISystem system);
    [EditorBrowsableAttribute("2")]
public static ISystem CreateCurrentSystem();
    [CompilerGeneratedAttribute]
public IArchitecture get_Architecture();
    [CompilerGeneratedAttribute]
public ISystem get_System();
    [CompilerGeneratedAttribute]
public IRuntime get_Runtime();
    public static PlatformTriple get_Current();
    private static PlatformTriple CreateCurrent();
    [EditorBrowsableAttribute("2")]
public static void SetPlatformTriple(PlatformTriple triple);
    private static void ThrowTripleAlreadyExists();
    private void InitIfNeeded(object obj);
    [NullableContextAttribute("0")]
public ValueTuple`3<ArchitectureKind, OSKind, RuntimeKind> get_HostTriple();
    [CompilerGeneratedAttribute]
public FeatureFlags get_SupportedFeatures();
    [CompilerGeneratedAttribute]
public Abi get_Abi();
    public void Compile(MethodBase method);
    public MethodBase GetIdentifiable(MethodBase method);
    public IDisposable PinMethodIfNeeded(MethodBase method);
    public bool TryDisableInlining(MethodBase method);
    public SimpleNativeDetour CreateSimpleDetour(IntPtr from, IntPtr to, int detourMaxSize, IntPtr fromRw);
    public NativeDetour CreateNativeDetour(IntPtr from, IntPtr to, int detourMaxSize, IntPtr fromRw);
    public IntPtr GetNativeMethodBody(MethodBase method);
    private IntPtr GetNativeMethodBodyWalk(MethodBase method, bool reloadPtr);
    private IntPtr GetNativeMethodBodyDirect(MethodBase method);
    private IntPtr NotThePreStub(IntPtr ptrGot, IntPtr ptrParsed, Boolean& wasPreStub);
    public MethodBase GetRealDetourTarget(MethodBase from, MethodBase to);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private IntPtr <NotThePreStub>b__40_0(MethodInfo m);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class MonoMod.Core.Platforms.PlatformTripleDetourFactory : object {
    
private PlatformTriple triple;
    public PlatformTripleDetourFactory(PlatformTriple triple);
    public sealed virtual ICoreDetour CreateDetour(CreateDetourRequest request);
    public sealed virtual ICoreNativeDetour CreateNativeDetour(CreateNativeDetourRequest request);
}
[IsReadOnlyAttribute]
internal class MonoMod.Core.Platforms.PositionedAllocationRequest : ValueType {
    [CompilerGeneratedAttribute]

private IntPtr <Target>k__BackingField;
    [CompilerGeneratedAttribute]

private IntPtr <LowBound>k__BackingField;
    [CompilerGeneratedAttribute]

private IntPtr <HighBound>k__BackingField;
    [CompilerGeneratedAttribute]

private AllocationRequest <Base>k__BackingField;
    
public IntPtr Target { get; public set; }
    
public IntPtr LowBound { get; public set; }
    
public IntPtr HighBound { get; public set; }
    
public AllocationRequest Base { get; public set; }
    public PositionedAllocationRequest(IntPtr Target, IntPtr LowBound, IntPtr HighBound, AllocationRequest Base);
    [CompilerGeneratedAttribute]
public IntPtr get_Target();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>IsExternalInit) set_Target(IntPtr value);
    [CompilerGeneratedAttribute]
public IntPtr get_LowBound();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>IsExternalInit) set_LowBound(IntPtr value);
    [CompilerGeneratedAttribute]
public IntPtr get_HighBound();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>IsExternalInit) set_HighBound(IntPtr value);
    [CompilerGeneratedAttribute]
public AllocationRequest get_Base();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>IsExternalInit) set_Base(AllocationRequest value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(PositionedAllocationRequest left, PositionedAllocationRequest right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(PositionedAllocationRequest left, PositionedAllocationRequest right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(PositionedAllocationRequest other);
    [CompilerGeneratedAttribute]
public void Deconstruct(IntPtr& Target, IntPtr& LowBound, IntPtr& HighBound, AllocationRequest& Base);
}
[FlagsAttribute]
internal enum MonoMod.Core.Platforms.RuntimeFeature : Enum {
    
public int value__;
    
public static RuntimeFeature None;
    
public static RuntimeFeature PreciseGC;
    
public static RuntimeFeature CompileMethodHook;
    
public static RuntimeFeature ILDetour;
    
public static RuntimeFeature GenericSharing;
    
public static RuntimeFeature ListGenericInstantiations;
    
public static RuntimeFeature DisableInlining;
    
public static RuntimeFeature Uninlining;
    
public static RuntimeFeature RequiresMethodPinning;
    
public static RuntimeFeature RequiresMethodIdentification;
    
public static RuntimeFeature RequiresBodyThunkWalking;
    
public static RuntimeFeature HasKnownABI;
    
public static RuntimeFeature RequiresCustomMethodCompile;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class MonoMod.Core.Platforms.Runtimes.Core21Runtime : CoreBaseRuntime {
    
private object sync;
    [NullableAttribute("2")]

private JitHookHelpersHolder lazyJitHookHelpers;
    
private static Guid JitVersionGuid;
    [NullableAttribute("2")]

private Delegate ourCompileMethod;
    [NullableAttribute("2")]

private IDisposable n2mHookHelper;
    [NullableAttribute("2")]

private IDisposable m2nHookHelper;
    
private static FieldInfo RuntimeAssemblyPtrField;
    
public RuntimeFeature Features { get; }
    
protected JitHookHelpersHolder JitHookHelpers { get; }
    
protected Guid ExpectedJitVersion { get; }
    
protected int VtableIndexICorJitCompilerGetVersionGuid { get; }
    
protected int VtableIndexICorJitCompilerCompileMethod { get; }
    
protected InvokeCompileMethodPtr InvokeCompileMethodPtr { get; }
    public Core21Runtime(ISystem system);
    private static Core21Runtime();
    public virtual RuntimeFeature get_Features();
    private static JitHookHelpersHolder CreateJitHookHelpers(Core21Runtime self);
    protected JitHookHelpersHolder get_JitHookHelpers();
    protected virtual Guid get_ExpectedJitVersion();
    protected virtual int get_VtableIndexICorJitCompilerGetVersionGuid();
    protected virtual int get_VtableIndexICorJitCompilerCompileMethod();
    protected virtual InvokeCompileMethodPtr get_InvokeCompileMethodPtr();
    protected virtual Delegate CastCompileHookToRealType(Delegate del);
    [NullableContextAttribute("0")]
protected static IntPtr* GetVTableEntry(IntPtr object, int index);
    protected static IntPtr ReadObjectVTable(IntPtr object, int index);
    private void CheckVersionGuid(IntPtr jit);
    protected virtual void InstallJitHook(IntPtr jit);
    protected virtual void InvokeCompileMethodToPrepare(IntPtr method);
    protected virtual Delegate CreateCompileMethodDelegate(IntPtr compileMethod);
    protected virtual void MakeAssemblySystemAssembly(Assembly assembly);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class MonoMod.Core.Platforms.Runtimes.Core30Runtime : Core21Runtime {
    
private static Guid JitVersionGuid;
    
protected Guid ExpectedJitVersion { get; }
    
protected InvokeCompileMethodPtr InvokeCompileMethodPtr { get; }
    public Core30Runtime(ISystem system);
    private static Core30Runtime();
    protected virtual Guid get_ExpectedJitVersion();
    protected virtual InvokeCompileMethodPtr get_InvokeCompileMethodPtr();
    protected virtual Delegate CastCompileHookToRealType(Delegate del);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class MonoMod.Core.Platforms.Runtimes.Core31Runtime : Core30Runtime {
    
protected InvokeCompileMethodPtr InvokeCompileMethodPtr { get; }
    public Core31Runtime(ISystem system);
    protected virtual InvokeCompileMethodPtr get_InvokeCompileMethodPtr();
    protected virtual Delegate CastCompileHookToRealType(Delegate del);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class MonoMod.Core.Platforms.Runtimes.Core50Runtime : Core31Runtime {
    
private static Guid JitVersionGuid;
    
protected Guid ExpectedJitVersion { get; }
    
protected int VtableIndexICorJitCompilerGetVersionGuid { get; }
    
protected InvokeCompileMethodPtr InvokeCompileMethodPtr { get; }
    public Core50Runtime(ISystem system);
    private static Core50Runtime();
    protected virtual Guid get_ExpectedJitVersion();
    protected virtual int get_VtableIndexICorJitCompilerGetVersionGuid();
    protected virtual InvokeCompileMethodPtr get_InvokeCompileMethodPtr();
    protected virtual Delegate CastCompileHookToRealType(Delegate del);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class MonoMod.Core.Platforms.Runtimes.Core60Runtime : Core50Runtime {
    
private static Guid JitVersionGuid;
    
protected Guid ExpectedJitVersion { get; }
    
protected InvokeCompileMethodPtr InvokeCompileMethodPtr { get; }
    public Core60Runtime(ISystem system);
    private static Core60Runtime();
    protected virtual Guid get_ExpectedJitVersion();
    protected virtual InvokeCompileMethodPtr get_InvokeCompileMethodPtr();
    protected virtual Delegate CastCompileHookToRealType(Delegate del);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class MonoMod.Core.Platforms.Runtimes.Core70Runtime : Core60Runtime {
    
private IArchitecture arch;
    
private static Guid JitVersionGuid;
    [NullableAttribute("2")]

private Delegate allocMemDelegate;
    [NullableAttribute("2")]

private IDisposable n2mAllocMemHelper;
    
protected Guid ExpectedJitVersion { get; }
    
protected int VtableIndexICorJitInfoAllocMem { get; }
    
protected int ICorJitInfoFullVtableCount { get; }
    
protected InvokeAllocMemPtr InvokeAllocMemPtr { get; }
    public Core70Runtime(ISystem system, IArchitecture arch);
    private static Core70Runtime();
    protected virtual Guid get_ExpectedJitVersion();
    protected virtual Delegate CreateCompileMethodDelegate(IntPtr compileMethod);
    [NullableContextAttribute("0")]
protected virtual void PatchWrapperVtable(IntPtr* vtbl);
    protected virtual int get_VtableIndexICorJitInfoAllocMem();
    protected virtual int get_ICorJitInfoFullVtableCount();
    protected virtual InvokeAllocMemPtr get_InvokeAllocMemPtr();
    protected virtual Delegate CastAllocMemToRealType(Delegate del);
    protected virtual Delegate CreateAllocMemDelegate();
}
internal class MonoMod.Core.Platforms.Runtimes.Core80Runtime : Core70Runtime {
    
private static Guid JitVersionGuid;
    
protected Guid ExpectedJitVersion { get; }
    
protected int VtableIndexICorJitInfoAllocMem { get; }
    
protected int ICorJitInfoFullVtableCount { get; }
    [NullableContextAttribute("1")]
public Core80Runtime(ISystem system, IArchitecture arch);
    private static Core80Runtime();
    protected virtual Guid get_ExpectedJitVersion();
    protected virtual int get_VtableIndexICorJitInfoAllocMem();
    protected virtual int get_ICorJitInfoFullVtableCount();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class MonoMod.Core.Platforms.Runtimes.CoreBaseRuntime : FxCoreBaseRuntime {
    [CompilerGeneratedAttribute]

private ISystem <System>k__BackingField;
    
private Nullable`1<IntPtr> lazyJitObject;
    [NullableAttribute("2")]

private INativeExceptionHelper lazyNativeExceptionHelper;
    
public RuntimeKind Target { get; }
    
protected ISystem System { get; }
    
protected IntPtr JitObject { get; }
    [NullableAttribute("2")]

protected INativeExceptionHelper NativeExceptionHelper { get; }
    protected CoreBaseRuntime(ISystem system);
    public static CoreBaseRuntime CreateForVersion(Version version, ISystem system, IArchitecture arch);
    public virtual RuntimeKind get_Target();
    [CompilerGeneratedAttribute]
protected ISystem get_System();
    private sealed virtual override void MonoMod.Core.Utils.IInitialize.Initialize();
    private static bool IsMaybeClrJitPath(string path);
    protected virtual string GetClrJitPath();
    protected IntPtr get_JitObject();
    private IntPtr GetJitObject();
    protected abstract virtual void InstallJitHook(IntPtr jit);
    [NullableContextAttribute("2")]
protected INativeExceptionHelper get_NativeExceptionHelper();
    [NullableContextAttribute("2")]
protected IntPtr EHNativeToManaged(IntPtr target, IDisposable& handle);
    [NullableContextAttribute("2")]
protected IntPtr EHManagedToNative(IntPtr target, IDisposable& handle);
}
internal abstract class MonoMod.Core.Platforms.Runtimes.FxBaseRuntime : FxCoreBaseRuntime {
    
public RuntimeKind Target { get; }
    public virtual RuntimeKind get_Target();
    [NullableContextAttribute("1")]
public static FxBaseRuntime CreateForVersion(Version version, ISystem system);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class MonoMod.Core.Platforms.Runtimes.FxCLR2Runtime : FxBaseRuntime {
    
private ISystem system;
    public FxCLR2Runtime(ISystem system);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class MonoMod.Core.Platforms.Runtimes.FxCLR4Runtime : FxBaseRuntime {
    
private ISystem system;
    
public RuntimeFeature Features { get; }
    public FxCLR4Runtime(ISystem system);
    public virtual RuntimeFeature get_Features();
    private IntPtr GetMethodBodyPtr(MethodBase method, RuntimeMethodHandle handle);
    public virtual IntPtr GetMethodEntryPoint(MethodBase method);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class MonoMod.Core.Platforms.Runtimes.FxCoreBaseRuntime : object {
    
protected Nullable`1<Abi> AbiCore;
    [NullableAttribute("2")]

private static Type RTDynamicMethod;
    [NullableAttribute("2")]

private static FieldInfo RTDynamicMethod_m_owner;
    [NullableAttribute("2")]

private static FieldInfo _DynamicMethod_m_method;
    [NullableAttribute("2")]

private static MethodInfo _DynamicMethod_GetMethodDescriptor;
    [NullableAttribute("2")]

private static MethodInfo _RuntimeMethodHandle_get_Value;
    [NullableAttribute("2")]

private static FieldInfo _RuntimeMethodHandle_m_value;
    [NullableAttribute("2")]

private static MethodInfo _IRuntimeMethodInfo_get_Value;
    [NullableAttribute("2")]

private static MethodInfo _RuntimeHelpers__CompileMethod;
    [NullableAttribute("2")]

private static Type RtH_CM_FirstArg;
    
private static bool _RuntimeHelpers__CompileMethod_TakesIntPtr;
    
private static bool _RuntimeHelpers__CompileMethod_TakesIRuntimeMethodInfo;
    
private static bool _RuntimeHelpers__CompileMethod_TakesRuntimeMethodHandleInternal;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]

private Func`2<DynamicMethod, RuntimeMethodHandle> lazyGetDmHandleHelper;
    [NullableAttribute("2")]

private Action`1<RuntimeMethodHandle> lazyBclCompileMethod;
    
protected static bool IsDebugClr;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]

private OnMethodCompiledCallback OnMethodCompiled;
    
public RuntimeKind Target { get; }
    
public RuntimeFeature Features { get; }
    
public Abi Abi { get; }
    
private Func`2<DynamicMethod, RuntimeMethodHandle> GetDMHandleHelper { get; }
    
private static bool CanCreateGetDMHandleHelper { get; }
    
private Action`1<RuntimeMethodHandle> BclCompileMethodHelper { get; }
    
private static bool CanCreateBclCompileMethodHelper { get; }
    private static FxCoreBaseRuntime();
    public abstract virtual RuntimeKind get_Target();
    public virtual RuntimeFeature get_Features();
    public sealed virtual Abi get_Abi();
    private static TypeClassification ClassifyRyuJitX86(Type type, bool isReturn);
    protected static Abi AbiForCoreFx45X64(Abi baseAbi);
    public virtual MethodBase GetIdentifiable(MethodBase method);
    public virtual RuntimeMethodHandle GetMethodHandle(MethodBase method);
    private Func`2<DynamicMethod, RuntimeMethodHandle> get_GetDMHandleHelper();
    private static bool get_CanCreateGetDMHandleHelper();
    private static Func`2<DynamicMethod, RuntimeMethodHandle> CreateGetDMHandleHelper();
    private Action`1<RuntimeMethodHandle> get_BclCompileMethodHelper();
    private static bool get_CanCreateBclCompileMethodHelper();
    private static Action`1<RuntimeMethodHandle> CreateBclCompileMethodHelper();
    private bool TryGetDMHandle(DynamicMethod dm, RuntimeMethodHandle& handle);
    protected bool TryInvokeBclCompileMethod(RuntimeMethodHandle handle);
    private static bool TryGetDMHandleRefl(DynamicMethod dm, RuntimeMethodHandle& handle);
    private static bool TryInvokeBclCompileMethodRefl(RuntimeMethodHandle handle);
    public virtual void Compile(MethodBase method);
    protected virtual bool TryGetCanonicalMethodHandle(RuntimeMethodHandle& handle);
    public virtual IDisposable PinMethodIfNeeded(MethodBase method);
    public virtual void DisableInlining(MethodBase method);
    public virtual IntPtr GetMethodEntryPoint(MethodBase method);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual void add_OnMethodCompiled(OnMethodCompiledCallback value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual void remove_OnMethodCompiled(OnMethodCompiledCallback value);
    [NullableContextAttribute("0")]
protected virtual void OnMethodCompiledCore(RuntimeTypeHandle declaringType, RuntimeMethodHandle methodHandle, Nullable`1<ReadOnlyMemory`1<RuntimeTypeHandle>> genericTypeArguments, Nullable`1<ReadOnlyMemory`1<RuntimeTypeHandle>> genericMethodArguments, IntPtr methodBodyStart, IntPtr methodBodyRw, ulong methodBodySize);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class MonoMod.Core.Platforms.Runtimes.MonoRuntime : object {
    [CompilerGeneratedAttribute]

private Abi <Abi>k__BackingField;
    
private ISystem system;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]

private OnMethodCompiledCallback OnMethodCompiled;
    
private static MethodInfo _DynamicMethod_CreateDynMethod;
    
private static FieldInfo _DynamicMethod_mhandle;
    
private ConcurrentDictionary`2<MethodBase, PrivateMethodPin> pinnedMethods;
    
private ConcurrentDictionary`2<RuntimeMethodHandle, PrivateMethodPin> pinnedHandles;
    
public RuntimeKind Target { get; }
    
public RuntimeFeature Features { get; }
    
public Abi Abi { get; }
    public MonoRuntime(ISystem system);
    private static MonoRuntime();
    public sealed virtual RuntimeKind get_Target();
    public sealed virtual RuntimeFeature get_Features();
    [CompilerGeneratedAttribute]
public sealed virtual Abi get_Abi();
    private static TypeClassification LinuxAmd64Classifier(Type type, bool isReturn);
    private static TypeClassification ClassifyValueType(Type type, bool isReturn);
    [IteratorStateMachineAttribute("MonoMod.Core.Platforms.Runtimes.MonoRuntime/<NestedValutypeFields>d__10")]
private static IEnumerable`1<FieldInfo> NestedValutypeFields(Type type);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual void add_OnMethodCompiled(OnMethodCompiledCallback value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual void remove_OnMethodCompiled(OnMethodCompiledCallback value);
    public sealed virtual void DisableInlining(MethodBase method);
    public sealed virtual RuntimeMethodHandle GetMethodHandle(MethodBase method);
    public sealed virtual IDisposable PinMethodIfNeeded(MethodBase method);
    private void UnpinOnce(PrivateMethodPin pin);
    public sealed virtual MethodBase GetIdentifiable(MethodBase method);
    public sealed virtual IntPtr GetMethodEntryPoint(MethodBase method);
    public sealed virtual void Compile(MethodBase method);
}
internal class MonoMod.Core.Platforms.SimpleNativeDetour : object {
    
private bool disposedValue;
    [NullableAttribute("1")]

private PlatformTriple triple;
    
private NativeDetourInfo detourInfo;
    
private Memory`1<byte> backup;
    [NullableAttribute("2")]

private IDisposable AllocHandle;
    
public ReadOnlyMemory`1<byte> DetourBackup { get; }
    
public IntPtr Source { get; }
    
public IntPtr Destination { get; }
    internal SimpleNativeDetour(PlatformTriple triple, NativeDetourInfo detourInfo, Memory`1<byte> backup, IDisposable allocHandle);
    public ReadOnlyMemory`1<byte> get_DetourBackup();
    public IntPtr get_Source();
    public IntPtr get_Destination();
    public void ChangeTarget(IntPtr newTarget);
    public void Undo();
    private void CheckDisposed();
    private void UndoCore(bool disposing);
    private void Cleanup();
    private void Dispose(bool disposing);
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
}
internal enum MonoMod.Core.Platforms.SpecialArgumentKind : Enum {
    
public int value__;
    
public static SpecialArgumentKind ThisPointer;
    
public static SpecialArgumentKind ReturnBuffer;
    
public static SpecialArgumentKind GenericContext;
    
public static SpecialArgumentKind UserArguments;
}
[FlagsAttribute]
internal enum MonoMod.Core.Platforms.SystemFeature : Enum {
    
public int value__;
    
public static SystemFeature None;
    
public static SystemFeature RWXPages;
    
public static SystemFeature RXPages;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class MonoMod.Core.Platforms.Systems.LinuxSystem : object {
    
private Abi defaultAbi;
    [NativeIntegerAttribute]

private IntPtr PageSize;
    
private MmapPagedMemoryAllocator allocator;
    [NullableAttribute("2")]

private IArchitecture arch;
    [NullableAttribute("2")]

private PosixExceptionHelper lazyNativeExceptionHelper;
    
public OSKind Target { get; }
    
public SystemFeature Features { get; }
    
public Nullable`1<Abi> DefaultAbi { get; }
    
public IMemoryAllocator MemoryAllocator { get; }
    [NullableAttribute("2")]

public INativeExceptionHelper NativeExceptionHelper { get; }
    [NullableAttribute("0")]

private static ReadOnlySpan`1<byte> NEHTempl { get; }
    public sealed virtual OSKind get_Target();
    public sealed virtual SystemFeature get_Features();
    public sealed virtual Nullable`1<Abi> get_DefaultAbi();
    public sealed virtual IEnumerable`1<string> EnumerateLoadedModuleFiles();
    public sealed virtual IMemoryAllocator get_MemoryAllocator();
    public sealed virtual IntPtr GetSizeOfReadableMemory(IntPtr start, IntPtr guess);
    [NullableContextAttribute("0")]
public sealed virtual void PatchData(PatchTargetKind patchKind, IntPtr patchTarget, ReadOnlySpan`1<byte> data, Span`1<byte> backup);
    private void RoundToPageBoundary(IntPtr& addr, IntPtr& size);
    private void ProtectRW(IntPtr addr, IntPtr size);
    private void ProtectRWX(IntPtr addr, IntPtr size);
    private sealed virtual override void MonoMod.Core.Utils.IInitialize<MonoMod.Core.Platforms.IArchitecture>.Initialize(IArchitecture value);
    [NullableContextAttribute("2")]
public sealed virtual INativeExceptionHelper get_NativeExceptionHelper();
    [NullableContextAttribute("0")]
private static ReadOnlySpan`1<byte> get_NEHTempl();
    private PosixExceptionHelper CreateNativeExceptionHelper();
}
internal class MonoMod.Core.Platforms.Systems.MacOSSystem : object {
    [CompilerGeneratedAttribute]

private Nullable`1<Abi> <DefaultAbi>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]

private IMemoryAllocator <MemoryAllocator>k__BackingField;
    [NullableAttribute("2")]

private IArchitecture arch;
    [NullableAttribute("2")]

private PosixExceptionHelper lazyNativeExceptionHelper;
    
public OSKind Target { get; }
    
public SystemFeature Features { get; }
    
public Nullable`1<Abi> DefaultAbi { get; }
    [NullableAttribute("1")]

public IMemoryAllocator MemoryAllocator { get; }
    [NullableAttribute("2")]

public INativeExceptionHelper NativeExceptionHelper { get; }
    
private static ReadOnlySpan`1<byte> NEHTempl { get; }
    public sealed virtual OSKind get_Target();
    public sealed virtual SystemFeature get_Features();
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<Abi> get_DefaultAbi();
    public sealed virtual IEnumerable`1<string> EnumerateLoadedModuleFiles();
    public sealed virtual IntPtr GetSizeOfReadableMemory(IntPtr start, IntPtr guess);
    public sealed virtual void PatchData(PatchTargetKind targetKind, IntPtr patchTarget, ReadOnlySpan`1<byte> data, Span`1<byte> backup);
    private static void MakePageWritable(IntPtr addrInPage);
    private static bool TryGetProtForMem(IntPtr addr, int length, vm_prot_t& maxProt, vm_prot_t& prot, Boolean& crossesAllocBoundary, Boolean& notAllocated);
    private static kern_return_t GetLocalRegionInfo(IntPtr origAddr, IntPtr& startAddr, IntPtr& outSize, vm_prot_t& prot, vm_prot_t& maxProt);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public sealed virtual IMemoryAllocator get_MemoryAllocator();
    [NullableContextAttribute("1")]
private sealed virtual override void MonoMod.Core.Utils.IInitialize<MonoMod.Core.Platforms.IArchitecture>.Initialize(IArchitecture value);
    [NullableContextAttribute("2")]
public sealed virtual INativeExceptionHelper get_NativeExceptionHelper();
    private static ReadOnlySpan`1<byte> get_NEHTempl();
    [NullableContextAttribute("1")]
private PosixExceptionHelper CreateNativeExceptionHelper();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class MonoMod.Core.Platforms.Systems.PosixExceptionHelper : object {
    
private IArchitecture arch;
    
private IntPtr eh_get_exception_ptr;
    
private IntPtr eh_managed_to_native;
    
private IntPtr eh_native_to_managed;
    
public IntPtr NativeException { get; public set; }
    
public GetExceptionSlot GetExceptionSlot { get; }
    private PosixExceptionHelper(IArchitecture arch, IntPtr getExPtr, IntPtr m2n, IntPtr n2m);
    public static PosixExceptionHelper CreateHelper(IArchitecture arch, string filename);
    public IntPtr get_NativeException();
    public void set_NativeException(IntPtr value);
    public sealed virtual GetExceptionSlot get_GetExceptionSlot();
    [NullableContextAttribute("2")]
public sealed virtual IntPtr CreateManagedToNativeHelper(IntPtr target, IDisposable& handle);
    [NullableContextAttribute("2")]
public sealed virtual IntPtr CreateNativeToManagedHelper(IntPtr target, IDisposable& handle);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private IntPtr* <get_GetExceptionSlot>b__10_0();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class MonoMod.Core.Platforms.Systems.SystemVABI : object {
    
private static ConditionalWeakTable`2<Type, StrongBox`1<bool>> SysVIsMemoryCache;
    private static SystemVABI();
    public static TypeClassification ClassifyAMD64(Type type, bool isReturn);
    private static bool AnyFieldsNotFloat(Type type);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class MonoMod.Core.Platforms.Systems.WindowsSystem : object {
    [CompilerGeneratedAttribute]

private Nullable`1<Abi> <DefaultAbi>k__BackingField;
    [CompilerGeneratedAttribute]

private IMemoryAllocator <MemoryAllocator>k__BackingField;
    
public OSKind Target { get; }
    
public SystemFeature Features { get; }
    [NullableAttribute("2")]

public INativeExceptionHelper NativeExceptionHelper { get; }
    
public Nullable`1<Abi> DefaultAbi { get; }
    
public IMemoryAllocator MemoryAllocator { get; }
    public sealed virtual OSKind get_Target();
    public sealed virtual SystemFeature get_Features();
    [NullableContextAttribute("2")]
public sealed virtual INativeExceptionHelper get_NativeExceptionHelper();
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<Abi> get_DefaultAbi();
    private static TypeClassification ClassifyX64(Type type, bool isReturn);
    private static TypeClassification ClassifyX86(Type type, bool isReturn);
    [NullableContextAttribute("0")]
public sealed virtual void PatchData(PatchTargetKind patchKind, IntPtr patchTarget, ReadOnlySpan`1<byte> data, Span`1<byte> backup);
    private static void ProtectRW(IntPtr addr, UIntPtr size);
    private static void ProtectRWX(IntPtr addr, UIntPtr size);
    private static void FlushInstructionCache(IntPtr addr, UIntPtr size);
    public sealed virtual IEnumerable`1<string> EnumerateLoadedModuleFiles();
    public sealed virtual IntPtr GetSizeOfReadableMemory(IntPtr start, IntPtr guess);
    private static Exception LogAllSections(UInt32 error, IntPtr src, UIntPtr size, string from);
    [CompilerGeneratedAttribute]
public sealed virtual IMemoryAllocator get_MemoryAllocator();
}
internal enum MonoMod.Core.Platforms.TypeClassification : Enum {
    
public int value__;
    
public static TypeClassification InRegister;
    
public static TypeClassification ByReference;
    
public static TypeClassification OnStack;
}
[FlagsAttribute]
internal enum MonoMod.Core.Utils.AddressKind : Enum {
    
public int value__;
    
public static AddressKind Rel32;
    
public static AddressKind Rel64;
    
public static AddressKind Abs32;
    
public static AddressKind Abs64;
    
public static AddressKind PrecodeFixupThunkRel32;
    
public static AddressKind PrecodeFixupThunkRel64;
    
public static AddressKind PrecodeFixupThunkAbs32;
    
public static AddressKind PrecodeFixupThunkAbs64;
    
public static AddressKind Indirect;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class MonoMod.Core.Utils.AddressKindExtensions : object {
    
public static AddressKind IsAbsoluteField;
    
public static AddressKind Is64BitField;
    
public static AddressKind IsPrecodeFixupField;
    
public static AddressKind IsIndirectField;
    [ExtensionAttribute]
public static bool IsRelative(AddressKind value);
    [ExtensionAttribute]
public static bool IsAbsolute(AddressKind value);
    [ExtensionAttribute]
public static bool Is32Bit(AddressKind value);
    [ExtensionAttribute]
public static bool Is64Bit(AddressKind value);
    [ExtensionAttribute]
public static bool IsPrecodeFixup(AddressKind value);
    [ExtensionAttribute]
public static bool IsIndirect(AddressKind value);
    [ExtensionAttribute]
public static void Validate(AddressKind value, string argName);
    [ExtensionAttribute]
public static string FastToString(AddressKind value);
}
[IsReadOnlyAttribute]
internal class MonoMod.Core.Utils.AddressMeaning : ValueType {
    [CompilerGeneratedAttribute]

private AddressKind <Kind>k__BackingField;
    [CompilerGeneratedAttribute]

private int <RelativeToOffset>k__BackingField;
    
public AddressKind Kind { get; }
    
public int RelativeToOffset { get; }
    public AddressMeaning(AddressKind kind);
    public AddressMeaning(AddressKind kind, int relativeOffset);
    [CompilerGeneratedAttribute]
public AddressKind get_Kind();
    [CompilerGeneratedAttribute]
public int get_RelativeToOffset();
    private static IntPtr DoProcessAddress(AddressKind kind, IntPtr basePtr, int offset, ulong address);
    public IntPtr ProcessAddress(IntPtr basePtr, int offset, ulong address);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(AddressMeaning other);
    [NullableContextAttribute("1")]
public virtual string ToString();
    public virtual int GetHashCode();
    public static bool op_Equality(AddressMeaning left, AddressMeaning right);
    public static bool op_Inequality(AddressMeaning left, AddressMeaning right);
}
internal class MonoMod.Core.Utils.BytePattern : object {
    
private static ushort MaskMask;
    
public static byte BAnyValue;
    
public static ushort SAnyValue;
    
public static byte BAnyRepeatingValue;
    
public static ushort SAnyRepeatingValue;
    
public static byte BAddressValue;
    
public static ushort SAddressValue;
    
private ReadOnlyMemory`1<byte> pattern;
    
private ReadOnlyMemory`1<byte> bitmask;
    [NullableAttribute("1")]

private PatternSegment[] segments;
    [CompilerGeneratedAttribute]

private int <AddressBytes>k__BackingField;
    [CompilerGeneratedAttribute]

private int <MinLength>k__BackingField;
    [CompilerGeneratedAttribute]

private AddressMeaning <AddressMeaning>k__BackingField;
    [CompilerGeneratedAttribute]

private bool <MustMatchAtStart>k__BackingField;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]

private Nullable`1<ValueTuple`2<ReadOnlyMemory`1<byte>, int>> lazyFirstLiteralSegment;
    
public int AddressBytes { get; }
    
public int MinLength { get; }
    
public AddressMeaning AddressMeaning { get; }
    
public bool MustMatchAtStart { get; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]

public ValueTuple`2<ReadOnlyMemory`1<byte>, int> FirstLiteralSegment { get; }
    [NullableContextAttribute("1")]
public BytePattern(AddressMeaning meaning, UInt16[] pattern);
    [NullableContextAttribute("1")]
public BytePattern(AddressMeaning meaning, bool mustMatchAtStart, UInt16[] pattern);
    public BytePattern(AddressMeaning meaning, ReadOnlyMemory`1<ushort> pattern);
    public BytePattern(AddressMeaning meaning, bool mustMatchAtStart, ReadOnlyMemory`1<ushort> pattern);
    public BytePattern(AddressMeaning meaning, ReadOnlyMemory`1<byte> mask, ReadOnlyMemory`1<byte> pattern);
    public BytePattern(AddressMeaning meaning, bool mustMatchAtStart, ReadOnlyMemory`1<byte> mask, ReadOnlyMemory`1<byte> pattern);
    [CompilerGeneratedAttribute]
public int get_AddressBytes();
    [CompilerGeneratedAttribute]
public int get_MinLength();
    [CompilerGeneratedAttribute]
public AddressMeaning get_AddressMeaning();
    [CompilerGeneratedAttribute]
public bool get_MustMatchAtStart();
    private static ComputeSegmentsResult ComputeSegmentsFromShort(ReadOnlyMemory`1<ushort> pattern);
    private static ComputeSegmentsResult ComputeSegmentsFromMaskPattern(ReadOnlyMemory`1<byte> mask, ReadOnlyMemory`1<byte> pattern);
    [NullableContextAttribute("1")]
private static ComputeSegmentsResult ComputeSegmentsCore(method kindForIdx, int patternLength, TPattern pattern);
    public bool TryMatchAt(ReadOnlySpan`1<byte> data, UInt64& address, Int32& length);
    public bool TryMatchAt(ReadOnlySpan`1<byte> data, Span`1<byte> addrBuf, Int32& length);
    private bool TryMatchAtImpl(ReadOnlySpan`1<byte> patternSpan, ReadOnlySpan`1<byte> data, Span`1<byte> addrBuf, Int32& length, int startAtSegment);
    public bool TryFindMatch(ReadOnlySpan`1<byte> data, UInt64& address, Int32& offset, Int32& length);
    public bool TryFindMatch(ReadOnlySpan`1<byte> data, Span`1<byte> addrBuf, Int32& offset, Int32& length);
    private bool ScanForNextLiteral(ReadOnlySpan`1<byte> patternSpan, ReadOnlySpan`1<byte> data, Span`1<byte> addrBuf, Int32& offset, Int32& length, int segmentIndex);
    public ValueTuple`2<ReadOnlyMemory`1<byte>, int> get_FirstLiteralSegment();
    private ValueTuple`2<ReadOnlyMemory`1<byte>, int> GetFirstLiteralSegment();
    private ValueTuple`2<PatternSegment, int> GetNextLiteralSegment(int segmentIndexId);
    [CompilerGeneratedAttribute]
internal static SegmentKind <ComputeSegmentsFromShort>g__KindForShort|31_0(ReadOnlyMemory`1<ushort> pattern, int idx);
    [CompilerGeneratedAttribute]
internal static SegmentKind <ComputeSegmentsFromMaskPattern>g__KindForIdx|32_0(ValueTuple`2<ReadOnlyMemory`1<byte>, ReadOnlyMemory`1<byte>> t, int idx);
}
internal class MonoMod.Core.Utils.BytePatternCollection : object {
    [NullableAttribute("1")]

private HomogenousPatternCollection[] patternCollections;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]

private BytePattern[] emptyPatterns;
    [CompilerGeneratedAttribute]

private int <MinLength>k__BackingField;
    [CompilerGeneratedAttribute]

private int <MaxMinLength>k__BackingField;
    [CompilerGeneratedAttribute]

private int <MaxAddressLength>k__BackingField;
    
private Nullable`1<ReadOnlyMemory`1<byte>> lazyPossibleFirstBytes;
    
public int MinLength { get; }
    
public int MaxMinLength { get; }
    
public int MaxAddressLength { get; }
    
private ReadOnlyMemory`1<byte> PossibleFirstBytes { get; }
    public BytePatternCollection(ReadOnlyMemory`1<BytePattern> patterns);
    public BytePatternCollection(BytePattern[] patterns);
    [CompilerGeneratedAttribute]
public int get_MinLength();
    [CompilerGeneratedAttribute]
public int get_MaxMinLength();
    [CompilerGeneratedAttribute]
public int get_MaxAddressLength();
    [NullableContextAttribute("1")]
[IteratorStateMachineAttribute("MonoMod.Core.Utils.BytePatternCollection/<GetEnumerator>d__13")]
public sealed virtual IEnumerator`1<BytePattern> GetEnumerator();
    [NullableContextAttribute("1")]
private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private static ValueTuple`2<HomogenousPatternCollection[], BytePattern[]> ComputeLut(ReadOnlyMemory`1<BytePattern> patterns, Int32& minLength, Int32& maxMinLength, Int32& maxAddrLength);
    public bool TryMatchAt(ReadOnlySpan`1<byte> data, UInt64& address, BytePattern& matchingPattern, Int32& length);
    public bool TryMatchAt(ReadOnlySpan`1<byte> data, Span`1<byte> addrBuf, BytePattern& matchingPattern, Int32& length);
    public bool TryFindMatch(ReadOnlySpan`1<byte> data, UInt64& address, BytePattern& matchingPattern, Int32& offset, Int32& length);
    public bool TryFindMatch(ReadOnlySpan`1<byte> data, Span`1<byte> addrBuf, BytePattern& matchingPattern, Int32& offset, Int32& length);
    private ReadOnlyMemory`1<byte> get_PossibleFirstBytes();
    private ReadOnlyMemory`1<byte> GetPossibleFirstBytes();
    [CompilerGeneratedAttribute]
internal static void <ComputeLut>g__AddToPatternCollection|15_0(HomogenousPatternCollection& collection, ReadOnlySpan`1<int> arrayCounts, BytePattern pattern);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class MonoMod.Core.Utils.IcedExtensions : object {
    [ExtensionAttribute]
[ObsoleteAttribute("This method is not supported.", "True")]
public static string FormatInsns(IList`1<Instruction> insns);
    [ExtensionAttribute]
[ObsoleteAttribute("This method is not supported.", "True")]
public static string FormatInsns(InstructionList insns);
}
internal interface MonoMod.Core.Utils.IInitialize {
    public abstract virtual void Initialize();
}
[NullableContextAttribute("1")]
internal interface MonoMod.Core.Utils.IInitialize`1 {
    public abstract virtual void Initialize(T value);
}
internal static class MonoMod.ILHelpers : object {
    public static T TailCallDelegatePtr(IntPtr source);
    public static T TailCallFunc(Func`1<T> func);
    [NullableContextAttribute("2")]
public static T& UnboxAnyUnsafe(Object& box);
}
internal static class MonoMod.Logs.DebugFormatter : object {
    [NullableContextAttribute("2")]
public static bool CanDebugFormat(T& value, Object& extraData);
    [NullableContextAttribute("2")]
public static bool TryFormatInto(T& value, object extraData, Span`1<char> into, Int32& wrote);
    private static bool TryFormatException(Exception e, string eStr, Span`1<char> into, Int32& wrote);
    private static bool TryFormatType(Type type, Span`1<char> into, Int32& wrote);
    private static bool TryFormatMethodInfo(MethodInfo method, Span`1<char> into, Int32& wrote);
    private static bool TryFormatMemberInfoName(MemberInfo member, Span`1<char> into, Int32& wrote);
    private static bool TryFormatMethodBase(MethodBase method, Span`1<char> into, Int32& wrote);
    private static bool TryFormatFieldInfo(FieldInfo field, Span`1<char> into, Int32& wrote);
    private static bool TryFormatPropertyInfo(PropertyInfo prop, Span`1<char> into, Int32& wrote);
    [NullableContextAttribute("1")]
public static string Format(FormatInterpolatedStringHandler& handler);
    public static bool Into(Span`1<char> into, Int32& wrote, FormatIntoInterpolatedStringHandler& handler);
    [CompilerGeneratedAttribute]
internal static TOut& <TryFormatInto>g__Transmute|1_0(T& val);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class MonoMod.Logs.DebugLog : object {
    
internal static DebugLog Instance;
    
private static ConcurrentBag`1<WeakReference`1<LogMessage>> weakRefCache;
    
private static ConcurrentBag`1<WeakReference`1<LogMessage>> messageObjectCache;
    
private static Char[] listEnvSeparator;
    
private bool recordHoles;
    
private int replayQueueLength;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]

private ConcurrentQueue`1<LogMessage> replayQueue;
    
private LogLevelFilter globalFilter;
    [NullableAttribute("2")]

private static Byte[] memlog;
    
private static int memlogPos;
    
private LevelSubscriptions subscriptions;
    
private static ConcurrentDictionary`2<OnLogMessage, IDisposable> simpleRegDict;
    
public static bool IsFinalizing { get; }
    
public static bool IsWritingLog { get; }
    
internal bool AlwaysLog { get; }
    
internal bool ShouldLog { get; }
    
internal bool RecordHoles { get; }
    private static DebugLog();
    public static bool get_IsFinalizing();
    private LogMessage MakeMessage(string source, DateTime time, LogLevel level, string formatted, ReadOnlyMemory`1<MessageHole> holes);
    private void ReturnMessage(LogMessage message);
    public static bool get_IsWritingLog();
    internal bool get_AlwaysLog();
    internal bool get_ShouldLog();
    internal bool get_RecordHoles();
    private void PostMessage(LogMessage message);
    internal bool ShouldLogLevel(LogLevel level);
    internal bool ShouldLevelRecordHoles(LogLevel level);
    public void Write(string source, DateTime time, LogLevel level, string message);
    public void Write(string source, DateTime time, LogLevel level, DebugLogInterpolatedStringHandler& message);
    internal void LogCore(string source, LogLevel level, string message);
    internal void LogCore(string source, LogLevel level, DebugLogInterpolatedStringHandler& message);
    public static void Log(string source, LogLevel level, string message);
    public static void Log(string source, LogLevel level, DebugLogInterpolatedStringHandler& message);
    private static String[] GetListEnvVar(string text);
    private void TryInitializeLogToFile(string file, String[] sourceFilter, LogLevelFilter filter);
    private void TryInitializeMemoryLog(LogLevelFilter filter);
    private void MaybeReplayTo(LogLevelFilter filter, OnLogMessage del);
    private void MaybeReplayTo(LogLevelFilter filter, OnLogMessageDetailed del);
    public static IDisposable Subscribe(LogLevelFilter filter, OnLogMessage value);
    private IDisposable SubscribeCore(LogLevelFilter filter, OnLogMessage value);
    public static IDisposable Subscribe(LogLevelFilter filter, OnLogMessageDetailed value);
    private IDisposable SubscribeCore(LogLevelFilter filter, OnLogMessageDetailed value);
    public static void add_OnLog(OnLogMessage value);
    public static void remove_OnLog(OnLogMessage value);
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[InterpolatedStringHandlerAttribute]
internal class MonoMod.Logs.DebugLogInterpolatedStringHandler : ValueType {
    
private static int GuessedLengthPerHole;
    
private static int MinimumArrayPoolLength;
    [NullableAttribute("2")]

private Char[] _arrayToReturnToPool;
    
private Span`1<char> _chars;
    
private int _pos;
    
private int holeBegin;
    
private int holePos;
    
private Memory`1<MessageHole> holes;
    
internal bool enabled;
    
internal ReadOnlySpan`1<char> Text { get; }
    public DebugLogInterpolatedStringHandler(int literalLength, int formattedCount, bool enabled, bool recordHoles, Boolean& isEnabled);
    public DebugLogInterpolatedStringHandler(int literalLength, int formattedCount, Boolean& isEnabled);
    public DebugLogInterpolatedStringHandler(int literalLength, int formattedCount, LogLevel level, Boolean& isEnabled);
    internal static int GetDefaultLength(int literalLength, int formattedCount);
    internal ReadOnlySpan`1<char> get_Text();
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
public string ToStringAndClear();
    internal string ToStringAndClear(ReadOnlyMemory`1& holes);
    internal void Clear();
    [NullableContextAttribute("1")]
public void AppendLiteral(string value);
    [NullableContextAttribute("1")]
private void AppendStringDirect(string value);
    private void BeginHole();
    [NullableContextAttribute("2")]
private void EndHole(object obj, bool reprd);
    [NullableContextAttribute("1")]
private void EndHole(T& obj, bool reprd);
    [NullableContextAttribute("2")]
public void AppendFormatted(string value);
    [NullableContextAttribute("2")]
private void AppendFormattedSlow(string value);
    [NullableContextAttribute("2")]
public void AppendFormatted(string value, int alignment, string format);
    public void AppendFormatted(ReadOnlySpan`1<char> value);
    public void AppendFormatted(ReadOnlySpan`1<char> value, int alignment, string format);
    [NullableContextAttribute("1")]
public void AppendFormatted(T value);
    private void AppendFormatted(IntPtr value);
    [NullableContextAttribute("2")]
private void AppendFormatted(IntPtr value, string format);
    private void AppendFormatted(UIntPtr value);
    [NullableContextAttribute("2")]
private void AppendFormatted(UIntPtr value, string format);
    [NullableContextAttribute("1")]
public void AppendFormatted(T value, int alignment);
    [NullableContextAttribute("2")]
public void AppendFormatted(T value, string format);
    [NullableContextAttribute("2")]
public void AppendFormatted(T value, int alignment, string format);
    private void AppendOrInsertAlignmentIfNeeded(int startingPos, int alignment);
    private void EnsureCapacityForAdditionalChars(int additionalChars);
    [NullableContextAttribute("1")]
private void GrowThenCopyString(string value);
    private void GrowThenCopySpan(ReadOnlySpan`1<char> value);
    private void Grow(int additionalChars);
    private void Grow();
    private void GrowCore(UInt32 requiredMinCapacity);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[InterpolatedStringHandlerAttribute]
internal class MonoMod.Logs.FormatInterpolatedStringHandler : ValueType {
    
private DebugLogInterpolatedStringHandler handler;
    public FormatInterpolatedStringHandler(int literalLen, int formattedCount);
    public virtual string ToString();
    public string ToStringAndClear();
    public void AppendLiteral(string s);
    [NullableContextAttribute("2")]
public void AppendFormatted(string s);
    [NullableContextAttribute("2")]
public void AppendFormatted(string s, int alignment, string format);
    [NullableContextAttribute("0")]
public void AppendFormatted(ReadOnlySpan`1<char> s);
    [NullableContextAttribute("0")]
public void AppendFormatted(ReadOnlySpan`1<char> s, int alignment, string format);
    public void AppendFormatted(T value);
    public void AppendFormatted(T value, int alignment);
    [NullableContextAttribute("2")]
public void AppendFormatted(T value, string format);
    [NullableContextAttribute("2")]
public void AppendFormatted(T value, int alignment, string format);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[InterpolatedStringHandlerAttribute]
internal class MonoMod.Logs.FormatIntoInterpolatedStringHandler : ValueType {
    [NullableAttribute("0")]

private Span`1<char> _chars;
    
internal int pos;
    
internal bool incomplete;
    [NullableContextAttribute("0")]
public FormatIntoInterpolatedStringHandler(int literalLen, int numHoles, Span`1<char> into, Boolean& enabled);
    [NullableContextAttribute("1")]
public bool AppendLiteral(string value);
    [NullableContextAttribute("1")]
private bool AppendStringDirect(string value);
    public bool AppendFormatted(string value);
    public bool AppendFormatted(string value, int alignment, string format);
    [NullableContextAttribute("0")]
public bool AppendFormatted(ReadOnlySpan`1<char> value);
    [NullableContextAttribute("0")]
public bool AppendFormatted(ReadOnlySpan`1<char> value, int alignment, string format);
    [NullableContextAttribute("1")]
public bool AppendFormatted(T value);
    private bool AppendFormatted(IntPtr value);
    private bool AppendFormatted(IntPtr value, string format);
    private bool AppendFormatted(UIntPtr value);
    private bool AppendFormatted(UIntPtr value, string format);
    [NullableContextAttribute("1")]
public bool AppendFormatted(T value, int alignment);
    public bool AppendFormatted(T value, string format);
    public bool AppendFormatted(T value, int alignment, string format);
    private bool AppendOrInsertAlignmentIfNeeded(int startingPos, int alignment);
}
internal interface MonoMod.Logs.IDebugFormattable {
    public abstract virtual bool TryFormatInto(Span`1<char> span, Int32& wrote);
}
internal enum MonoMod.Logs.LogLevel : Enum {
    
public int value__;
    
public static LogLevel Spam;
    
public static LogLevel Trace;
    
public static LogLevel Info;
    
public static LogLevel Warning;
    
public static LogLevel Error;
    
public static LogLevel Assert;
}
[ExtensionAttribute]
internal static class MonoMod.Logs.LogLevelExtensions : object {
    
public static LogLevel MaxLevel;
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static string FastToString(LogLevel level, IFormatProvider provider);
}
[FlagsAttribute]
internal enum MonoMod.Logs.LogLevelFilter : Enum {
    
public int value__;
    
public static LogLevelFilter None;
    
public static LogLevelFilter Spam;
    
public static LogLevelFilter Trace;
    
public static LogLevelFilter Info;
    
public static LogLevelFilter Warning;
    
public static LogLevelFilter Error;
    
public static LogLevelFilter Assert;
    
public static LogLevelFilter DefaultFilter;
}
[IsReadOnlyAttribute]
internal class MonoMod.Logs.MessageHole : ValueType {
    [CompilerGeneratedAttribute]

private int <Start>k__BackingField;
    [CompilerGeneratedAttribute]

private int <End>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]

private object <Value>k__BackingField;
    [CompilerGeneratedAttribute]

private bool <IsValueUnrepresentable>k__BackingField;
    
public int Start { get; }
    
public int End { get; }
    [NullableAttribute("2")]

public object Value { get; }
    
public bool IsValueUnrepresentable { get; }
    public MessageHole(int start, int end);
    [NullableContextAttribute("2")]
public MessageHole(int start, int end, object value);
    [CompilerGeneratedAttribute]
public int get_Start();
    [CompilerGeneratedAttribute]
public int get_End();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public object get_Value();
    [CompilerGeneratedAttribute]
public bool get_IsValueUnrepresentable();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(MessageHole left, MessageHole right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(MessageHole left, MessageHole right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(MessageHole other);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class MonoMod.MMDbgLog : object {
    
public static bool IsWritingLog { get; }
    public static bool get_IsWritingLog();
    [ModuleInitializerAttribute]
internal static void LogVersion();
    public static void Log(LogLevel level, string message);
    public static void Log(LogLevel level, DebugLogInterpolatedStringHandler& message);
    public static void Spam(string message);
    public static void Spam(DebugLogSpamStringHandler& message);
    public static void Trace(string message);
    public static void Trace(DebugLogTraceStringHandler& message);
    public static void Info(string message);
    public static void Info(DebugLogInfoStringHandler& message);
    public static void Warning(string message);
    public static void Warning(DebugLogWarningStringHandler& message);
    public static void Error(string message);
    public static void Error(DebugLogErrorStringHandler& message);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("4")]
internal class MonoMod.ModInterop.ModExportNameAttribute : Attribute {
    [CompilerGeneratedAttribute]

private string <Name>k__BackingField;
    
public string Name { get; }
    public ModExportNameAttribute(string name);
    [CompilerGeneratedAttribute]
public string get_Name();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("260")]
internal class MonoMod.ModInterop.ModImportNameAttribute : Attribute {
    [CompilerGeneratedAttribute]

private string <Name>k__BackingField;
    
public string Name { get; }
    public ModImportNameAttribute(string name);
    [CompilerGeneratedAttribute]
public string get_Name();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class MonoMod.ModInterop.ModInteropManager : object {
    
private static HashSet`1<Type> Registered;
    
private static Dictionary`2<string, List`1<MethodInfo>> Methods;
    
private static List`1<FieldInfo> Fields;
    private static ModInteropManager();
    [ExtensionAttribute]
public static void ModInterop(Type type);
    [ExtensionAttribute]
public static void RegisterModExport(MethodInfo method, string prefix);
    [ExtensionAttribute]
private static string GetModImportName(FieldInfo field);
}
[ExtensionAttribute]
internal static class MonoMod.MultiTargetShims : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static TypeReference GetConstraintType(GenericParameterConstraint constraint);
}
[AttributeUsageAttribute("4")]
internal class MonoMod.SourceGen.Attributes.<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>EmitILOverloadsAttribute : Attribute {
    public <027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>EmitILOverloadsAttribute(string filename, string kind);
}
internal static class MonoMod.SourceGen.Attributes.<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>ILOverloadKind : object {
    
public static string Cursor;
    
public static string Matcher;
}
[AttributeUsageAttribute("4")]
internal class MonoMod.SourceGen.Attributes.EmitILOverloadsAttribute : Attribute {
    public EmitILOverloadsAttribute(string filename, string kind);
}
internal static class MonoMod.SourceGen.Attributes.ILOverloadKind : object {
    
public static string Cursor;
    
public static string Matcher;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class MonoMod.Switches : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]

private static ConcurrentDictionary`2<string, object> switchValues;
    
private static string Prefix;
    
public static string RunningOnWine;
    
public static string DebugClr;
    
public static string JitPath;
    
public static string LogRecordHoles;
    
public static string LogInMemory;
    
public static string LogSpam;
    
public static string LogReplayQueueLength;
    
public static string LogToFile;
    
public static string LogToFileFilter;
    
public static string DMDType;
    
public static string DMDDebug;
    
public static string DMDDumpTo;
    [NullableAttribute("2")]

private static Type tAppContext;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]

private static Func`2<string, object> dGetData;
    [NullableAttribute("2")]

private static MethodInfo miTryGetSwitch;
    [NullableAttribute("2")]

private static TryGetSwitchFunc dTryGetSwitch;
    private static Switches();
    private static object BestEffortParseEnvVar(string value);
    public static void SetSwitchValue(string switch, object value);
    public static void ClearSwitchValue(string switch);
    private static Func`2<string, object> MakeGetDataDelegate();
    public static bool TryGetSwitchValue(string switch, Object& value);
    public static bool TryGetSwitchEnabled(string switch, Boolean& isEnabled);
    private static bool TryProcessBoolData(object data, Boolean& boolVal);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal static class MonoMod.Utils._DMDEmit : object {
    [NullableAttribute("1")]

private static MethodInfo m_MethodBase_InvokeSimple;
    [NullableAttribute("1")]

private static Dictionary`2<short, OpCode> _ReflOpCodes;
    [NullableAttribute("1")]

private static Dictionary`2<short, OpCode> _CecilOpCodes;
    
private static MethodInfo _ILGen_make_room;
    
private static MethodInfo _ILGen_emit_int;
    
private static MethodInfo _ILGen_ll_emit;
    
private static MethodInfo _ILGen_EnsureCapacity;
    
private static MethodInfo _ILGen_PutInteger4;
    
private static MethodInfo _ILGen_InternalEmit;
    
private static MethodInfo _ILGen_UpdateStackSize;
    
private static FieldInfo f_DynILGen_m_scope;
    
private static FieldInfo f_DynScope_m_tokens;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]

private static Type[] CorElementTypes;
    private static _DMDEmit();
    [NullableContextAttribute("1")]
private static MethodBuilder _CreateMethodProxy(MethodBuilder context, MethodInfo target);
    [NullableContextAttribute("1")]
public static void Generate(DynamicMethodDefinition dmd, MethodBase _mb, ILGenerator il);
    [NullableContextAttribute("1")]
public static void ResolveWithModifiers(TypeReference typeRef, Type& type, Type[]& typeModReq, Type[]& typeModOpt, List`1<Type> modReq, List`1<Type> modOpt);
    [NullableContextAttribute("1")]
internal static void _EmitCallSite(DynamicMethod dm, ILGenerator il, OpCode opcode, CallSite csite);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
internal static int <_EmitCallSite>g___GetTokenForType|17_0(Type v, <>c__DisplayClass17_0& );
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
internal static int <_EmitCallSite>g___GetTokenForSig|17_1(Byte[] v, <>c__DisplayClass17_0& );
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
internal static int <_EmitCallSite>g__GetTokenForType|17_2(Type v, <>c__DisplayClass17_0& );
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
internal static int <_EmitCallSite>g__GetTokenForSig|17_3(Byte[] v, <>c__DisplayClass17_0& );
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
internal static void <_EmitCallSite>g__AddArgument|17_4(Type clsArgument, Type[] requiredCustomModifiers, Type[] optionalCustomModifiers, <>c__DisplayClass17_0& );
    [CompilerGeneratedAttribute]
internal static void <_EmitCallSite>g__AddData|17_5(int data, <>c__DisplayClass17_0& );
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
internal static Byte[] <_EmitCallSite>g__ExpandArray|17_6(Byte[] inArray, int requiredLength);
    [CompilerGeneratedAttribute]
internal static void <_EmitCallSite>g__AddElementType|17_7(byte cvt, <>c__DisplayClass17_0& );
    [CompilerGeneratedAttribute]
internal static void <_EmitCallSite>g__AddToken|17_8(int token, <>c__DisplayClass17_0& );
    [CompilerGeneratedAttribute]
internal static void <_EmitCallSite>g__InternalAddTypeToken|17_9(int clsToken, byte CorType, <>c__DisplayClass17_0& );
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
internal static void <_EmitCallSite>g__AddOneArgTypeHelper|17_10(Type clsArgument, <>c__DisplayClass17_0& );
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
internal static void <_EmitCallSite>g__AddOneArgTypeHelperWorker|17_11(Type clsArgument, bool lastWasGenericInst, <>c__DisplayClass17_0& );
}
internal enum MonoMod.Utils.ArchitectureKind : Enum {
    
public int value__;
    
public static ArchitectureKind Unknown;
    
public static ArchitectureKind Bits64;
    
public static ArchitectureKind x86;
    
public static ArchitectureKind x86_64;
    
public static ArchitectureKind Arm;
    
public static ArchitectureKind Arm64;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class MonoMod.Utils.AssemblyInfo : object {
    
public static string AssemblyName;
    
public static string AssemblyVersion;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class MonoMod.Utils.AssertionFailedException : Exception {
    
private static string AssertFailed;
    [CompilerGeneratedAttribute]

private string <Expression>k__BackingField;
    [CompilerGeneratedAttribute]

private string <Message>k__BackingField;
    
public string Expression { get; }
    
public string Message { get; }
    [NullableContextAttribute("2")]
public AssertionFailedException(string message);
    public AssertionFailedException(string message, Exception innerException);
    public AssertionFailedException(string message, string expression);
    [CompilerGeneratedAttribute]
public string get_Expression();
    [CompilerGeneratedAttribute]
public string get_Message();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[InterpolatedStringHandlerAttribute]
internal class MonoMod.Utils.AssertionInterpolatedStringHandler : ValueType {
    
private DebugLogInterpolatedStringHandler handler;
    public AssertionInterpolatedStringHandler(int literalLen, int formattedCount, bool assertValue, Boolean& isEnabled);
    public virtual string ToString();
    public string ToStringAndClear();
    public void AppendLiteral(string s);
    [NullableContextAttribute("2")]
public void AppendFormatted(string s);
    [NullableContextAttribute("2")]
public void AppendFormatted(string s, int alignment, string format);
    [NullableContextAttribute("0")]
public void AppendFormatted(ReadOnlySpan`1<char> s);
    [NullableContextAttribute("0")]
public void AppendFormatted(ReadOnlySpan`1<char> s, int alignment, string format);
    public void AppendFormatted(T value);
    public void AppendFormatted(T value, int alignment);
    [NullableContextAttribute("2")]
public void AppendFormatted(T value, string format);
    [NullableContextAttribute("2")]
public void AppendFormatted(T value, int alignment, string format);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class MonoMod.Utils.Cil.CecilILGenerator : ILGeneratorShim {
    
private static ConstructorInfo c_LocalBuilder;
    [NullableAttribute("2")]

private static FieldInfo f_LocalBuilder_position;
    [NullableAttribute("2")]

private static FieldInfo f_LocalBuilder_is_pinned;
    
private static int c_LocalBuilder_params;
    
private static Dictionary`2<short, OpCode> _MCCOpCodes;
    
private static Label NullLabel;
    [CompilerGeneratedAttribute]

private ILProcessor <IL>k__BackingField;
    
private Dictionary`2<Label, LabelInfo> _LabelInfos;
    
private List`1<LabelInfo> _LabelsToMark;
    
private List`1<LabelledExceptionHandler> _ExceptionHandlersToMark;
    
private Dictionary`2<LocalBuilder, VariableDefinition> _Variables;
    
private Stack`1<ExceptionHandlerChain> _ExceptionHandlers;
    
private int labelCounter;
    
private int _ILOffset;
    
public ILProcessor IL { get; }
    
public int ILOffset { get; }
    private static CecilILGenerator();
    public CecilILGenerator(ILProcessor il);
    [CompilerGeneratedAttribute]
public ILProcessor get_IL();
    private static OpCode _(OpCode opcode);
    [NullableContextAttribute("2")]
private LabelInfo _(Label handle);
    private VariableDefinition _(LocalBuilder handle);
    private TypeReference _(Type info);
    private FieldReference _(FieldInfo info);
    private MethodReference _(MethodBase info);
    public virtual int get_ILOffset();
    private Instruction ProcessLabels(Instruction ins);
    public virtual Label DefineLabel();
    public virtual void MarkLabel(Label loc);
    public virtual LocalBuilder DeclareLocal(Type localType);
    public virtual LocalBuilder DeclareLocal(Type localType, bool pinned);
    private void Emit(Instruction ins);
    public virtual void Emit(OpCode opcode);
    public virtual void Emit(OpCode opcode, byte arg);
    public virtual void Emit(OpCode opcode, sbyte arg);
    public virtual void Emit(OpCode opcode, short arg);
    public virtual void Emit(OpCode opcode, int arg);
    public virtual void Emit(OpCode opcode, long arg);
    public virtual void Emit(OpCode opcode, float arg);
    public virtual void Emit(OpCode opcode, double arg);
    public virtual void Emit(OpCode opcode, string str);
    public virtual void Emit(OpCode opcode, Type cls);
    public virtual void Emit(OpCode opcode, FieldInfo field);
    public virtual void Emit(OpCode opcode, ConstructorInfo con);
    public virtual void Emit(OpCode opcode, MethodInfo meth);
    public virtual void Emit(OpCode opcode, Label label);
    public virtual void Emit(OpCode opcode, Label[] labels);
    public virtual void Emit(OpCode opcode, LocalBuilder local);
    public virtual void Emit(OpCode opcode, SignatureHelper signature);
    public void Emit(OpCode opcode, ICallSiteGenerator signature);
    private void _EmitInlineVar(OpCode opcode, int index);
    public virtual void EmitCall(OpCode opcode, MethodInfo methodInfo, Type[] optionalParameterTypes);
    [NullableContextAttribute("2")]
public virtual void EmitCalli(OpCode opcode, CallingConventions callingConvention, Type returnType, Type[] parameterTypes, Type[] optionalParameterTypes);
    [NullableContextAttribute("2")]
public virtual void EmitCalli(OpCode opcode, CallingConvention unmanagedCallConv, Type returnType, Type[] parameterTypes);
    public virtual void EmitWriteLine(FieldInfo fld);
    public virtual void EmitWriteLine(LocalBuilder localBuilder);
    public virtual void EmitWriteLine(string value);
    public virtual void ThrowException(Type excType);
    public virtual Label BeginExceptionBlock();
    public virtual void BeginCatchBlock(Type exceptionType);
    public virtual void BeginExceptFilterBlock();
    public virtual void BeginFaultBlock();
    public virtual void BeginFinallyBlock();
    public virtual void EndExceptionBlock();
    public virtual void BeginScope();
    public virtual void EndScope();
    public virtual void UsingNamespace(string usingNamespace);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class MonoMod.Utils.Cil.ILGeneratorShim : object {
    
public int ILOffset { get; }
    
public static Type GenericProxyType { get; }
    public abstract virtual int get_ILOffset();
    public abstract virtual void BeginCatchBlock(Type exceptionType);
    public abstract virtual void BeginExceptFilterBlock();
    public abstract virtual Label BeginExceptionBlock();
    public abstract virtual void BeginFaultBlock();
    public abstract virtual void BeginFinallyBlock();
    public abstract virtual void BeginScope();
    public abstract virtual LocalBuilder DeclareLocal(Type localType);
    public abstract virtual LocalBuilder DeclareLocal(Type localType, bool pinned);
    public abstract virtual Label DefineLabel();
    public abstract virtual void Emit(OpCode opcode);
    public abstract virtual void Emit(OpCode opcode, byte arg);
    public abstract virtual void Emit(OpCode opcode, double arg);
    public abstract virtual void Emit(OpCode opcode, short arg);
    public abstract virtual void Emit(OpCode opcode, int arg);
    public abstract virtual void Emit(OpCode opcode, long arg);
    public abstract virtual void Emit(OpCode opcode, ConstructorInfo con);
    public abstract virtual void Emit(OpCode opcode, Label label);
    public abstract virtual void Emit(OpCode opcode, Label[] labels);
    public abstract virtual void Emit(OpCode opcode, LocalBuilder local);
    public abstract virtual void Emit(OpCode opcode, SignatureHelper signature);
    public abstract virtual void Emit(OpCode opcode, FieldInfo field);
    public abstract virtual void Emit(OpCode opcode, MethodInfo meth);
    public abstract virtual void Emit(OpCode opcode, sbyte arg);
    public abstract virtual void Emit(OpCode opcode, float arg);
    public abstract virtual void Emit(OpCode opcode, string str);
    public abstract virtual void Emit(OpCode opcode, Type cls);
    public abstract virtual void EmitCall(OpCode opcode, MethodInfo methodInfo, Type[] optionalParameterTypes);
    [NullableContextAttribute("2")]
public abstract virtual void EmitCalli(OpCode opcode, CallingConventions callingConvention, Type returnType, Type[] parameterTypes, Type[] optionalParameterTypes);
    [NullableContextAttribute("2")]
public abstract virtual void EmitCalli(OpCode opcode, CallingConvention unmanagedCallConv, Type returnType, Type[] parameterTypes);
    public abstract virtual void EmitWriteLine(LocalBuilder localBuilder);
    public abstract virtual void EmitWriteLine(FieldInfo fld);
    public abstract virtual void EmitWriteLine(string value);
    public abstract virtual void EndExceptionBlock();
    public abstract virtual void EndScope();
    public abstract virtual void MarkLabel(Label loc);
    public abstract virtual void ThrowException(Type excType);
    public abstract virtual void UsingNamespace(string usingNamespace);
    public ILGenerator GetProxy();
    public static Type GetProxyType();
    public static Type GetProxyType(Type tShim);
    public static Type get_GenericProxyType();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class MonoMod.Utils.Cil.ILGeneratorShimExt : object {
    
private static Dictionary`2<Type, MethodInfo> _Emitters;
    
private static Dictionary`2<Type, MethodInfo> _EmittersShim;
    private static ILGeneratorShimExt();
    [ExtensionAttribute]
public static ILGeneratorShim GetProxiedShim(ILGenerator il);
    [ExtensionAttribute]
public static T GetProxiedShim(ILGenerator il);
    [ExtensionAttribute]
public static object DynEmit(ILGenerator il, OpCode opcode, object operand);
    [ExtensionAttribute]
public static object DynEmit(ILGenerator il, Object[] emitArgs);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class MonoMod.Utils.DataScope : ValueType {
    
private ScopeHandlerBase handler;
    
private object data;
    
public object Data { get; }
    [NullableContextAttribute("1")]
public DataScope(ScopeHandlerBase handler, object data);
    public object get_Data();
    public sealed virtual void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class MonoMod.Utils.DataScope`1 : ValueType {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]

private ScopeHandlerBase`1<T> handler;
    
private T data;
    
public T Data { get; }
    public DataScope`1(ScopeHandlerBase`1<T> handler, T data);
    public T get_Data();
    public sealed virtual void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class MonoMod.Utils.DMDCecilGenerator : DMDGenerator`1<DMDCecilGenerator> {
    protected virtual MethodInfo GenerateCore(DynamicMethodDefinition dmd, object context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class MonoMod.Utils.DMDEmitDynamicMethodGenerator : DMDGenerator`1<DMDEmitDynamicMethodGenerator> {
    
private static FieldInfo _DynamicMethod_returnType;
    private static DMDEmitDynamicMethodGenerator();
    protected virtual MethodInfo GenerateCore(DynamicMethodDefinition dmd, object context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class MonoMod.Utils.DMDEmitMethodBuilderGenerator : DMDGenerator`1<DMDEmitMethodBuilderGenerator> {
    
private static bool _MBCanRunAndCollect;
    private static DMDEmitMethodBuilderGenerator();
    protected virtual MethodInfo GenerateCore(DynamicMethodDefinition dmd, object context);
    public static MethodBuilder GenerateMethodBuilder(DynamicMethodDefinition dmd, TypeBuilder typeBuilder);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class MonoMod.Utils.DMDGenerator`1 : object {
    [NullableAttribute("2")]

private static TSelf Instance;
    protected abstract virtual MethodInfo GenerateCore(DynamicMethodDefinition dmd, object context);
    private sealed virtual override MethodInfo MonoMod.Utils.IDMDGenerator.Generate(DynamicMethodDefinition dmd, object context);
    public static MethodInfo Generate(DynamicMethodDefinition dmd, object context);
    internal static MethodInfo Postbuild(MethodInfo mi);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class MonoMod.Utils.DynamicData : DynamicObject {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]

private static Object[] _NoArgs;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]

private static Action`3<DynamicData, Type, object> OnInitialize;
    
private static Dictionary`2<Type, _Cache_> _CacheMap;
    
private static Dictionary`2<Type, _Data_> _DataStaticMap;
    
private static ConditionalWeakTable`2<object, _Data_> _DataMap;
    
private static ConditionalWeakTable`2<object, DynamicData> _DynamicDataMap;
    [NullableAttribute("2")]

private WeakReference Weak;
    [NullableAttribute("2")]

private object KeepAlive;
    
private _Cache_ _Cache;
    
private _Data_ _Data;
    [CompilerGeneratedAttribute]

private Type <TargetType>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]

public Dictionary`2<string, Func`2<object, object>> Getters { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]

public Dictionary`2<string, Action`2<object, object>> Setters { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]

public Dictionary`2<string, Func`3<object, Object[], object>> Methods { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]

public Dictionary`2<string, object> Data { get; }
    
public bool IsAlive { get; }
    [NullableAttribute("2")]

public object Target { get; }
    
public Type TargetType { get; private set; }
    public DynamicData(Type type);
    public DynamicData(object obj);
    public DynamicData(Type type, object obj);
    public DynamicData(Type type, object obj, bool keepAlive);
    private static DynamicData();
    [CompilerGeneratedAttribute]
public static void add_OnInitialize(Action`3<DynamicData, Type, object> value);
    [CompilerGeneratedAttribute]
public static void remove_OnInitialize(Action`3<DynamicData, Type, object> value);
    public Dictionary`2<string, Func`2<object, object>> get_Getters();
    public Dictionary`2<string, Action`2<object, object>> get_Setters();
    public Dictionary`2<string, Func`3<object, Object[], object>> get_Methods();
    public Dictionary`2<string, object> get_Data();
    public bool get_IsAlive();
    [NullableContextAttribute("2")]
public object get_Target();
    [CompilerGeneratedAttribute]
public Type get_TargetType();
    [CompilerGeneratedAttribute]
private void set_TargetType(Type value);
    public static DynamicData For(object obj);
    public static Func`2<object, T> New(Object[] args);
    public static Func`2<object, object> New(Type type, Object[] args);
    public static Func`2<object, object> NewWrap(Object[] args);
    public static Func`2<object, object> NewWrap(Type type, Object[] args);
    public static object Wrap(object target, object other);
    public static T Set(T target, object other);
    [NullableContextAttribute("2")]
public static object Set(object target, object other);
    public void RegisterProperty(string name, Func`2<object, object> getter, Action`2<object, object> setter);
    public void UnregisterProperty(string name);
    public void RegisterMethod(string name, Func`3<object, Object[], object> cb);
    public void UnregisterMethod(string name);
    [NullableContextAttribute("2")]
public void CopyFrom(object other);
    public object Get(string name);
    public bool TryGet(string name, Object& value);
    [NullableContextAttribute("2")]
public T Get(string name);
    public bool TryGet(string name, T& value);
    public void Set(string name, object value);
    public void Add(KeyValuePair`2<string, object> kvp);
    public void Add(string key, object value);
    public object Invoke(string name, Object[] args);
    [NullableContextAttribute("2")]
public bool TryInvoke(string name, Object[] args, Object& result);
    public T Invoke(string name, Object[] args);
    public bool TryInvoke(string name, Object[] args, T& result);
    private void Dispose(bool disposing);
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
    public virtual IEnumerable`1<string> GetDynamicMemberNames();
    public virtual bool TryConvert(ConvertBinder binder, Object& result);
    public virtual bool TryGetMember(GetMemberBinder binder, Object& result);
    public virtual bool TrySetMember(SetMemberBinder binder, object value);
    [NullableContextAttribute("2")]
public virtual bool TryInvokeMember(InvokeMemberBinder binder, Object[] args, Object& result);
    [IteratorStateMachineAttribute("MonoMod.Utils.DynamicData/<GetEnumerator>d__66")]
public sealed virtual IEnumerator`1<KeyValuePair`2<string, object>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class MonoMod.Utils.DynamicMethodDefinition : object {
    
private static OpCode[] _CecilOpCodes1X;
    
private static OpCode[] _CecilOpCodes2X;
    
internal static bool _IsNewMonoSRE;
    
internal static bool _IsOldMonoSRE;
    
private static bool _PreferCecil;
    
internal static ConstructorInfo c_DebuggableAttribute;
    
internal static ConstructorInfo c_UnverifiableCodeAttribute;
    
internal static ConstructorInfo c_IgnoresAccessChecksToAttribute;
    
internal static Type t__IDMDGenerator;
    
internal static ConcurrentDictionary`2<string, IDMDGenerator> _DMDGeneratorCache;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]

private MethodBase <OriginalMethod>k__BackingField;
    [CompilerGeneratedAttribute]

private MethodDefinition <Definition>k__BackingField;
    [CompilerGeneratedAttribute]

private ModuleDefinition <Module>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]

private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]

private bool <Debug>k__BackingField;
    
private Guid GUID;
    
private bool isDisposed;
    
public static bool IsDynamicILAvailable { get; }
    [NullableAttribute("2")]

public MethodBase OriginalMethod { get; }
    
public MethodDefinition Definition { get; }
    
public ModuleDefinition Module { get; }
    [NullableAttribute("2")]

public string Name { get; }
    
public bool Debug { get; public set; }
    private static DynamicMethodDefinition();
    public DynamicMethodDefinition(MethodBase method);
    public DynamicMethodDefinition(string name, Type returnType, Type[] parameterTypes);
    private static void _InitCopier();
    private static void _CopyMethodToDefinition(MethodBase from, MethodDefinition into);
    public static bool get_IsDynamicILAvailable();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public MethodBase get_OriginalMethod();
    [CompilerGeneratedAttribute]
public MethodDefinition get_Definition();
    [CompilerGeneratedAttribute]
public ModuleDefinition get_Module();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public bool get_Debug();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Debug(bool value);
    private static bool GetDefaultDebugValue();
    [MemberNotNullAttribute("Definition")]
public ILProcessor GetILProcessor();
    [MemberNotNullAttribute("Definition")]
public ILGenerator GetILGenerator();
    private void _CreateDynModule(string name, Type returnType, Type[] parameterTypes, ModuleDefinition& Module, MethodDefinition& Definition);
    private void LoadFromMethod(MethodBase orig, ModuleDefinition& Module, MethodDefinition& def);
    public MethodInfo Generate();
    public MethodInfo Generate(object context);
    public sealed virtual void Dispose();
    public string GetDumpName(string type);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class MonoMod.Utils.DynamicMethodReference : MethodReference {
    [CompilerGeneratedAttribute]

private MethodInfo <DynamicMethod>k__BackingField;
    
public MethodInfo DynamicMethod { get; }
    public DynamicMethodReference(ModuleDefinition module, MethodInfo dm);
    [CompilerGeneratedAttribute]
public MethodInfo get_DynamicMethod();
}
internal class MonoMod.Utils.DynamicReferenceCell : ValueType {
    [CompilerGeneratedAttribute]

private int <Index>k__BackingField;
    [CompilerGeneratedAttribute]

private int <Hash>k__BackingField;
    
public int Index { get; internal set; }
    
public int Hash { get; internal set; }
    public DynamicReferenceCell(int idx, int hash);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_Index();
    [CompilerGeneratedAttribute]
internal void set_Index(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_Hash();
    [CompilerGeneratedAttribute]
internal void set_Hash(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(DynamicReferenceCell left, DynamicReferenceCell right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(DynamicReferenceCell left, DynamicReferenceCell right);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(DynamicReferenceCell other);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class MonoMod.Utils.DynamicReferenceManager : object {
    [NativeIntegerAttribute]

private static UIntPtr RefValueCell;
    [NativeIntegerAttribute]

private static UIntPtr ValueTypeCell;
    
private static SpinLock writeLock;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]

private static Cell[] modreq(System.Runtime.CompilerServices.IsVolatile) cells;
    
private static Int32 modreq(System.Runtime.CompilerServices.IsVolatile) firstEmptyCell;
    
private static MethodInfo Self_GetValue_ii;
    
private static MethodInfo Self_GetValueT_ii;
    
private static MethodInfo Self_GetValueTUnsafe_ii;
    private static DynamicReferenceManager();
    [NullableContextAttribute("0")]
private static DataScope`1<DynamicReferenceCell> AllocReferenceCore(Cell cell, DynamicReferenceCell& cellRef);
    [NullableContextAttribute("0")]
private static DataScope`1<DynamicReferenceCell> AllocReferenceClass(object value, DynamicReferenceCell& cellRef);
    [NullableContextAttribute("0")]
private static DataScope`1<DynamicReferenceCell> AllocReferenceStruct(T& value, DynamicReferenceCell& cellRef);
    [NullableContextAttribute("2")]
public static DataScope`1<DynamicReferenceCell> AllocReference(T& value, DynamicReferenceCell& cellRef);
    private static Cell GetCell(DynamicReferenceCell cellRef);
    [NullableContextAttribute("2")]
public static object GetValue(DynamicReferenceCell cellRef);
    [NullableContextAttribute("2")]
private static T& GetValueRef(DynamicReferenceCell cellRef);
    [NullableContextAttribute("2")]
private static T& GetValueRefUnsafe(DynamicReferenceCell cellRef);
    [NullableContextAttribute("2")]
public static T GetValue(DynamicReferenceCell cellRef);
    [NullableContextAttribute("2")]
internal static object GetValue(int index, int hash);
    [NullableContextAttribute("2")]
internal static T GetValueT(int index, int hash);
    [NullableContextAttribute("2")]
internal static T GetValueTUnsafe(int index, int hash);
    [NullableContextAttribute("2")]
public static void SetValue(DynamicReferenceCell cellRef, T& value);
    [ExtensionAttribute]
public static void EmitLoadReference(ILProcessor il, DynamicReferenceCell cellRef);
    [ExtensionAttribute]
public static void EmitLoadReference(ILCursor il, DynamicReferenceCell cellRef);
    [ExtensionAttribute]
public static void EmitLoadReference(ILGenerator il, DynamicReferenceCell cellRef);
    [ExtensionAttribute]
public static void EmitLoadTypedReference(ILProcessor il, DynamicReferenceCell cellRef, Type type);
    [ExtensionAttribute]
public static void EmitLoadTypedReference(ILCursor il, DynamicReferenceCell cellRef, Type type);
    [ExtensionAttribute]
public static void EmitLoadTypedReference(ILGenerator il, DynamicReferenceCell cellRef, Type type);
    [ExtensionAttribute]
internal static void EmitLoadTypedReferenceUnsafe(ILProcessor il, DynamicReferenceCell cellRef, Type type);
    [ExtensionAttribute]
internal static void EmitLoadTypedReferenceUnsafe(ILCursor il, DynamicReferenceCell cellRef, Type type);
    [ExtensionAttribute]
internal static void EmitLoadTypedReferenceUnsafe(ILGenerator il, DynamicReferenceCell cellRef, Type type);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static DataScope`1<DynamicReferenceCell> EmitNewReference(ILProcessor il, object value, DynamicReferenceCell& cellRef);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static DataScope`1<DynamicReferenceCell> EmitNewReference(ILCursor il, object value, DynamicReferenceCell& cellRef);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static DataScope`1<DynamicReferenceCell> EmitNewReference(ILGenerator il, object value, DynamicReferenceCell& cellRef);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static DataScope`1<DynamicReferenceCell> EmitNewTypedReference(ILProcessor il, T value, DynamicReferenceCell& cellRef);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static DataScope`1<DynamicReferenceCell> EmitNewTypedReference(ILCursor il, T value, DynamicReferenceCell& cellRef);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static DataScope`1<DynamicReferenceCell> EmitNewTypedReference(ILGenerator il, T value, DynamicReferenceCell& cellRef);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
internal class MonoMod.Utils.DynData`1 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]

private static Action`2<DynData`1<TTarget>, TTarget> OnInitialize;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]

private static _Data_<TTarget> _DataStatic;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]

private static ConditionalWeakTable`2<object, _Data_<TTarget>> _DataMap;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]

private static Dictionary`2<string, Func`2<TTarget, object>> _SpecialGetters;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]

private static Dictionary`2<string, Action`2<TTarget, object>> _SpecialSetters;
    [NullableAttribute("2")]

private WeakReference Weak;
    [NullableAttribute("2")]

private TTarget KeepAlive;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]

private _Data_<TTarget> _Data;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]

public Dictionary`2<string, Func`2<TTarget, object>> Getters { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]

public Dictionary`2<string, Action`2<TTarget, object>> Setters { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]

public Dictionary`2<string, object> Data { get; }
    
public bool IsAlive { get; }
    
public TTarget Target { get; }
    [NullableAttribute("2")]

public object Item { get; public set; }
    private static DynData`1();
    [NullableContextAttribute("2")]
public DynData`1(TTarget obj);
    [NullableContextAttribute("2")]
public DynData`1(TTarget obj, bool keepAlive);
    [CompilerGeneratedAttribute]
public static void add_OnInitialize(Action`2<DynData`1<TTarget>, TTarget> value);
    [CompilerGeneratedAttribute]
public static void remove_OnInitialize(Action`2<DynData`1<TTarget>, TTarget> value);
    public Dictionary`2<string, Func`2<TTarget, object>> get_Getters();
    public Dictionary`2<string, Action`2<TTarget, object>> get_Setters();
    public Dictionary`2<string, object> get_Data();
    public bool get_IsAlive();
    public TTarget get_Target();
    public object get_Item(string name);
    public void set_Item(string name, object value);
    [NullableContextAttribute("2")]
public T Get(string name);
    public void Set(string name, T value);
    public void RegisterProperty(string name, Func`2<TTarget, object> getter, Action`2<TTarget, object> setter);
    public void UnregisterProperty(string name);
    private void Dispose(bool disposing);
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class MonoMod.Utils.DynDll : object {
    
private static BackendImpl Backend;
    private static DynDll();
    private static BackendImpl CreateCrossplatBackend();
    [NullableContextAttribute("2")]
public static IntPtr OpenLibrary(string name);
    [NullableContextAttribute("2")]
public static bool TryOpenLibrary(string name, IntPtr& libraryPtr);
    public static void CloseLibrary(IntPtr lib);
    public static bool TryCloseLibrary(IntPtr lib);
    [ExtensionAttribute]
public static IntPtr GetExport(IntPtr libraryPtr, string name);
    [ExtensionAttribute]
public static bool TryGetExport(IntPtr libraryPtr, string name, IntPtr& functionPtr);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class MonoMod.Utils.Extensions : object {
    
private static Type t_Code;
    
private static Type t_OpCodes;
    
private static Dictionary`2<int, OpCode> _ToLongOp;
    
private static Dictionary`2<int, OpCode> _ToShortOp;
    
private static Dictionary`2<Type, FieldInfo> fmap_mono_assembly;
    
private static bool _MonoAssemblyNameHasArch;
    [NullableAttribute("2")]

private static Type _RTDynamicMethod;
    
private static Type t_ParamArrayAttribute;
    
private static FieldInfo f_GenericParameter_position;
    
private static FieldInfo f_GenericParameter_type;
    
private static ConcurrentDictionary`2<Type, int> _GetManagedSizeCache;
    [NullableAttribute("2")]

private static MethodInfo _GetManagedSizeHelper;
    
private static Dictionary`2<MethodBase, Func`1<IntPtr>> _GetLdftnPointerCache;
    [NullableAttribute("2")]

private static Type RTDynamicMethod;
    [NullableAttribute("2")]

private static FieldInfo RTDynamicMethod_m_owner;
    [NullableAttribute("2")]

private static Type t_StateMachineAttribute;
    [NullableAttribute("2")]

private static PropertyInfo p_StateMachineType;
    private static Extensions();
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static TypeDefinition SafeResolve(TypeReference r);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static FieldDefinition SafeResolve(FieldReference r);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static MethodDefinition SafeResolve(MethodReference r);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static PropertyDefinition SafeResolve(PropertyReference r);
    [ExtensionAttribute]
public static CustomAttribute GetCustomAttribute(ICustomAttributeProvider cap, string attribute);
    [ExtensionAttribute]
public static bool HasCustomAttribute(ICustomAttributeProvider cap, string attribute);
    [ExtensionAttribute]
public static int GetInt(Instruction instr);
    [ExtensionAttribute]
public static Nullable`1<int> GetIntOrNull(Instruction instr);
    [ExtensionAttribute]
public static bool IsBaseMethodCall(MethodBody body, MethodReference called);
    [ExtensionAttribute]
public static bool IsCallvirt(MethodReference method);
    [ExtensionAttribute]
public static bool IsStruct(TypeReference type);
    [ExtensionAttribute]
public static OpCode ToLongOp(OpCode op);
    [ExtensionAttribute]
public static OpCode ToShortOp(OpCode op);
    [ExtensionAttribute]
public static void RecalculateILOffsets(MethodDefinition method);
    [ExtensionAttribute]
public static void FixShortLongOps(MethodDefinition method);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool Is(MemberInfo minfo, MemberReference mref);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool Is(MemberReference mref, MemberInfo minfo);
    [ExtensionAttribute]
public static IMetadataTokenProvider ImportReference(ModuleDefinition mod, IMetadataTokenProvider mtp);
    [ExtensionAttribute]
public static void AddRange(Collection`1<T> list, IEnumerable`1<T> other);
    [ExtensionAttribute]
public static void AddRange(IDictionary dict, IDictionary other);
    [ExtensionAttribute]
public static void AddRange(IDictionary`2<TKey, TValue> dict, IDictionary`2<TKey, TValue> other);
    [ExtensionAttribute]
public static void AddRange(Dictionary`2<TKey, TValue> dict, Dictionary`2<TKey, TValue> other);
    [ExtensionAttribute]
public static void InsertRange(Collection`1<T> list, int index, IEnumerable`1<T> other);
    [ExtensionAttribute]
public static bool IsCompatible(Type type, Type other);
    [ExtensionAttribute]
private static bool _IsCompatible(Type type, Type other);
    [ExtensionAttribute]
public static T GetDeclaredMember(T member);
    [ExtensionAttribute]
public static void SetMonoCorlibInternal(Assembly asm, bool value);
    [ExtensionAttribute]
public static bool IsDynamicMethod(MethodBase method);
    [ExtensionAttribute]
public static object SafeGetTarget(WeakReference weak);
    [ExtensionAttribute]
public static bool SafeGetIsAlive(WeakReference weak);
    [ExtensionAttribute]
public static T CreateDelegate(MethodBase method);
    [ExtensionAttribute]
public static T CreateDelegate(MethodBase method, object target);
    [ExtensionAttribute]
public static Delegate CreateDelegate(MethodBase method, Type delegateType);
    [ExtensionAttribute]
public static Delegate CreateDelegate(MethodBase method, Type delegateType, object target);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static T TryCreateDelegate(MethodInfo mi);
    [ExtensionAttribute]
public static MethodDefinition FindMethod(TypeDefinition type, string id, bool simple);
    [ExtensionAttribute]
public static MethodDefinition FindMethodDeep(TypeDefinition type, string id, bool simple);
    [ExtensionAttribute]
public static MethodInfo FindMethod(Type type, string id, bool simple);
    [ExtensionAttribute]
public static MethodInfo FindMethodDeep(Type type, string id, bool simple);
    [ExtensionAttribute]
public static PropertyDefinition FindProperty(TypeDefinition type, string name);
    [ExtensionAttribute]
public static PropertyDefinition FindPropertyDeep(TypeDefinition type, string name);
    [ExtensionAttribute]
public static FieldDefinition FindField(TypeDefinition type, string name);
    [ExtensionAttribute]
public static FieldDefinition FindFieldDeep(TypeDefinition type, string name);
    [ExtensionAttribute]
public static EventDefinition FindEvent(TypeDefinition type, string name);
    [ExtensionAttribute]
public static EventDefinition FindEventDeep(TypeDefinition type, string name);
    [ExtensionAttribute]
public static string GetID(MethodReference method, string name, string type, bool withType, bool simple);
    [ExtensionAttribute]
public static string GetID(CallSite method);
    [ExtensionAttribute]
public static string GetID(MethodBase method, string name, string type, bool withType, bool proxyMethod, bool simple);
    [ExtensionAttribute]
public static string GetPatchName(MemberReference mr);
    [ExtensionAttribute]
public static string GetPatchFullName(MemberReference mr);
    [ExtensionAttribute]
private static string GetPatchName(ICustomAttributeProvider cap);
    [ExtensionAttribute]
private static string GetPatchFullName(ICustomAttributeProvider cap, MemberReference mr);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static MethodDefinition Clone(MethodDefinition o, MethodDefinition c);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static MethodBody Clone(MethodBody bo, MethodDefinition m);
    [ExtensionAttribute]
public static GenericParameter Update(GenericParameter param, int position, GenericParameterType type);
    [ExtensionAttribute]
public static GenericParameter ResolveGenericParameter(IGenericParameterProvider provider, GenericParameter orig);
    [ExtensionAttribute]
public static IMetadataTokenProvider Relink(IMetadataTokenProvider mtp, Relinker relinker, IGenericParameterProvider context);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static TypeReference Relink(TypeReference type, Relinker relinker, IGenericParameterProvider context);
    [ExtensionAttribute]
public static GenericParameterConstraint Relink(GenericParameterConstraint constraint, Relinker relinker, IGenericParameterProvider context);
    [ExtensionAttribute]
public static IMetadataTokenProvider Relink(MethodReference method, Relinker relinker, IGenericParameterProvider context);
    [ExtensionAttribute]
public static CallSite Relink(CallSite method, Relinker relinker, IGenericParameterProvider context);
    [ExtensionAttribute]
public static IMetadataTokenProvider Relink(FieldReference field, Relinker relinker, IGenericParameterProvider context);
    [ExtensionAttribute]
public static ParameterDefinition Relink(ParameterDefinition param, Relinker relinker, IGenericParameterProvider context);
    [ExtensionAttribute]
public static ParameterDefinition Clone(ParameterDefinition param);
    [ExtensionAttribute]
public static CustomAttribute Relink(CustomAttribute attrib, Relinker relinker, IGenericParameterProvider context);
    [ExtensionAttribute]
public static CustomAttribute Clone(CustomAttribute attrib);
    [ExtensionAttribute]
public static GenericParameter Relink(GenericParameter param, Relinker relinker, IGenericParameterProvider context);
    [ExtensionAttribute]
public static GenericParameter Clone(GenericParameter param);
    [ExtensionAttribute]
public static int GetManagedSize(Type t);
    private static int ComputeManagedSize(Type t);
    [ExtensionAttribute]
public static Type GetThisParamType(MethodBase method);
    [ExtensionAttribute]
public static IntPtr GetLdftnPointer(MethodBase m);
    [ExtensionAttribute]
public static string ToHexadecimalString(Byte[] data);
    [ExtensionAttribute]
public static T InvokePassing(MulticastDelegate md, T val, Object[] args);
    [ExtensionAttribute]
public static bool InvokeWhileTrue(MulticastDelegate md, Object[] args);
    [ExtensionAttribute]
public static bool InvokeWhileFalse(MulticastDelegate md, Object[] args);
    [ExtensionAttribute]
public static T InvokeWhileNull(MulticastDelegate md, Object[] args);
    [ExtensionAttribute]
public static string SpacedPascalCase(string input);
    [ExtensionAttribute]
public static string ReadNullTerminatedString(BinaryReader stream);
    [ExtensionAttribute]
public static void WriteNullTerminatedString(BinaryWriter stream, string text);
    private static MethodBase GetRealMethod(MethodBase method);
    [ExtensionAttribute]
public static T CastDelegate(Delegate source);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static Delegate CastDelegate(Delegate source, Type type);
    [ExtensionAttribute]
public static bool TryCastDelegate(Delegate source, T& result);
    [ExtensionAttribute]
public static bool TryCastDelegate(Delegate source, Type type, Delegate& result);
    [ExtensionAttribute]
public static MethodInfo GetStateMachineTarget(MethodInfo method);
    [ExtensionAttribute]
public static MethodBase GetActualGenericMethodDefinition(MethodInfo method);
    [ExtensionAttribute]
public static MethodBase GetUnfilledMethodOnGenericType(MethodBase method);
    [ExtensionAttribute]
public static bool Is(MemberReference member, string fullName);
    [ExtensionAttribute]
public static bool Is(MemberReference member, string typeFullName, string name);
    [ExtensionAttribute]
public static bool Is(MemberReference member, Type type, string name);
    [ExtensionAttribute]
public static bool Is(MethodReference method, string fullName);
    [ExtensionAttribute]
public static bool Is(MethodReference method, string typeFullName, string name);
    [ExtensionAttribute]
public static bool Is(MethodReference method, Type type, string name);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static void ReplaceOperands(ILProcessor il, object from, object to);
    [ExtensionAttribute]
public static FieldReference Import(ILProcessor il, FieldInfo field);
    [ExtensionAttribute]
public static MethodReference Import(ILProcessor il, MethodBase method);
    [ExtensionAttribute]
public static TypeReference Import(ILProcessor il, Type type);
    [ExtensionAttribute]
public static MemberReference Import(ILProcessor il, MemberInfo member);
    [ExtensionAttribute]
public static Instruction Create(ILProcessor il, OpCode opcode, FieldInfo field);
    [ExtensionAttribute]
public static Instruction Create(ILProcessor il, OpCode opcode, MethodBase method);
    [ExtensionAttribute]
public static Instruction Create(ILProcessor il, OpCode opcode, Type type);
    [ExtensionAttribute]
public static Instruction Create(ILProcessor il, OpCode opcode, object operand);
    [ExtensionAttribute]
public static Instruction Create(ILProcessor il, OpCode opcode, MemberInfo member);
    [ExtensionAttribute]
public static void Emit(ILProcessor il, OpCode opcode, FieldInfo field);
    [ExtensionAttribute]
public static void Emit(ILProcessor il, OpCode opcode, MethodBase method);
    [ExtensionAttribute]
public static void Emit(ILProcessor il, OpCode opcode, Type type);
    [ExtensionAttribute]
public static void Emit(ILProcessor il, OpCode opcode, MemberInfo member);
    [ExtensionAttribute]
public static void Emit(ILProcessor il, OpCode opcode, object operand);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class MonoMod.Utils.FastReflectionHelper : object {
    
private static Type[] FastStructInvokerArgs;
    
private static MethodInfo S2FValueType;
    
private static MethodInfo S2FNullable;
    [NullableAttribute("2")]
[ThreadStaticAttribute]

private static WeakBox CachedWeakBox;
    
private static MethodInfo S2FClass;
    
private static MethodInfo S2FVoid;
    
private static ConditionalWeakTable`2<MemberInfo, FSITuple> fastStructInvokers;
    
private static ConditionalWeakTable`2<FSITuple, FastInvoker> fastInvokers;
    
private static MethodInfo CheckArgsMethod;
    
private static int TargetArgId;
    
private static int ResultArgId;
    
private static MethodInfo BadArgExceptionMethod;
    
private static FieldInfo WeakBoxValueField;
    private static FastReflectionHelper();
    [NullableContextAttribute("2")]
private static object FastInvokerForStructInvokerVT(FastStructInvoker invoker, object target, Object[] args);
    [NullableContextAttribute("2")]
private static object FastInvokerForStructInvokerNullable(FastStructInvoker invoker, object target, Object[] args);
    [NullableContextAttribute("2")]
private static object FastInvokerForStructInvokerClass(FastStructInvoker invoker, object target, Object[] args);
    [NullableContextAttribute("2")]
private static object FastInvokerForStructInvokerVoid(FastStructInvoker invoker, object target, Object[] args);
    private static FastInvoker CreateFastInvoker(FastStructInvoker fsi, ReturnTypeClass retTypeClass, Type returnType);
    private static FSITuple GetFSITuple(MethodBase method);
    private static FSITuple GetFSITuple(FieldInfo field);
    private static FSITuple GetFSITuple(MemberInfo member);
    private static FastInvoker GetFastInvoker(FSITuple tuple);
    public static FastStructInvoker GetFastStructInvoker(MethodBase method);
    public static FastStructInvoker GetFastStructInvoker(FieldInfo field);
    public static FastStructInvoker GetFastStructInvoker(MemberInfo member);
    [ExtensionAttribute]
public static FastInvoker GetFastInvoker(MethodBase method);
    [ExtensionAttribute]
public static FastInvoker GetFastInvoker(FieldInfo field);
    [ExtensionAttribute]
public static FastInvoker GetFastInvoker(MemberInfo member);
    [NullableContextAttribute("2")]
private static void CheckArgs(bool isStatic, object target, int retTypeClass, object result, int expectLen, Object[] args);
    [NullableContextAttribute("2")]
private static Exception BadArgException(int arg, RuntimeTypeHandle expectType, object target, object result, Object[] args);
    private static ReturnTypeClass ClassifyType(Type returnType);
    private static void EmitCheckArgs(ILCursor il, bool isStatic, ReturnTypeClass rtc, int expectParams);
    private static void EmitCheckType(ILCursor il, int argId, Type expectType, ILLabel badArgLbl);
    private static void EmitCheckAllowNull(ILCursor il, int argId, Type expectType, ILLabel badArgLbl);
    private static void EmitBadArgCall(ILCursor il, ILLabel badArgLbl);
    private static void EmitCheckByref(ILCursor il, ReturnTypeClass rtc, Type returnType, ILLabel badArgLbl, int argId);
    private static void EmitLoadByref(ILCursor il, ReturnTypeClass rtc, Type returnType);
    private static void EmitLoadArgO(ILCursor il, int arg);
    private static void EmitStoreByref(ILCursor il, ReturnTypeClass rtc, Type returnType);
    private static FastStructInvoker CreateMethodInvoker(MethodBase method, ReturnTypeClass& retTypeClass, Type& retType);
    private static FastStructInvoker CreateFieldInvoker(FieldInfo field, ReturnTypeClass& retTypeClass, Type& retType);
    [CompilerGeneratedAttribute]
internal static void <CheckArgs>g__ThrowArgumentOutOfRange|28_0();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class MonoMod.Utils.GenericMethodInstantiationComparer : object {
    [NullableAttribute("2")]

internal static Type CannonicalFillType;
    
private IEqualityComparer`1<Type> genericTypeComparer;
    public GenericMethodInstantiationComparer(IEqualityComparer`1<Type> typeComparer);
    private static GenericMethodInstantiationComparer();
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(MethodBase x, MethodBase y);
    public sealed virtual int GetHashCode(MethodBase obj);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class MonoMod.Utils.GenericTypeInstantiationComparer : object {
    
private static Type CannonicalFillType;
    private static GenericTypeInstantiationComparer();
    public sealed virtual bool Equals(Type x, Type y);
    [NullableContextAttribute("1")]
public sealed virtual int GetHashCode(Type obj);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class MonoMod.Utils.Helpers : object {
    public static void Swap(T& a, T& b);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static bool Has(T value, T flag);
    [NullableContextAttribute("2")]
public static void ThrowIfArgumentNull(T arg, string name);
    public static T ThrowIfNull(T arg, string name);
    public static T EventAdd(T& evt, T del);
    public static T EventRemove(T& evt, T del);
    public static void Assert(bool value, string message, string expr);
    [ConditionalAttribute("DEBUG")]
public static void DAssert(bool value, string message, string expr);
    public static void Assert(bool value, AssertionInterpolatedStringHandler& message, string expr);
    [ConditionalAttribute("DEBUG")]
public static void DAssert(bool value, AssertionInterpolatedStringHandler& message, string expr);
    [DoesNotReturnAttribute]
private static void ThrowArgumentNull(string argName);
    [DoesNotReturnAttribute]
private static void ThrowAssertionFailed(string msg, string expr);
    [DoesNotReturnAttribute]
private static void ThrowAssertionFailed(AssertionInterpolatedStringHandler& message, string expr);
    public static T GetOrInit(T& location, Func`1<T> init);
    public static T GetOrInitWithLock(T& location, object lock, Func`1<T> init);
    public static T GetOrInit(T& location, method init);
    public static T GetOrInitWithLock(T& location, object lock, method init);
    public static T GetOrInit(T& location, method init, TParam obj);
    public static T GetOrInitWithLock(T& location, object lock, method init, TParam obj);
    private static T InitializeValue(T& location, method init, TParam obj);
    private static T InitializeValueWithLock(T& location, object lock, method init, TParam obj);
    [NullableContextAttribute("0")]
public static bool MaskedSequenceEqual(ReadOnlySpan`1<byte> first, ReadOnlySpan`1<byte> second, ReadOnlySpan`1<byte> mask);
    [DoesNotReturnAttribute]
private static void ThrowMaskTooShort();
    private static bool MaskedSequenceEqualCore(Byte& first, Byte& second, Byte& maskBytes, UIntPtr length);
    public static Byte[] ReadAllBytes(string path);
    private static Byte[] ReadAllBytesUnknownLength(FileStream fs);
}
[NullableContextAttribute("1")]
internal interface MonoMod.Utils.ICallSiteGenerator {
    public abstract virtual CallSite ToCallSite(ModuleDefinition module);
}
[NullableContextAttribute("1")]
internal interface MonoMod.Utils.IDMDGenerator {
    public abstract virtual MethodInfo Generate(DynamicMethodDefinition dmd, object context);
}
internal static class MonoMod.Utils.Interop.OSX : object {
    [NullableAttribute("1")]

public static string LibSystem;
    public static int Uname(Byte* buf);
}
internal static class MonoMod.Utils.Interop.Unix : object {
    [NullableAttribute("1")]

public static string LibC;
    [NullableAttribute("1")]

public static string DL1;
    [NullableAttribute("1")]

public static string DL2;
    
public static int AT_PLATFORM;
    
private static int dlVersion;
    private static Unix();
    public static int Uname(Byte* buf);
    private static IntPtr DL1dlopen(Byte* filename, DlopenFlags flags);
    private static int DL1dlclose(IntPtr handle);
    private static IntPtr DL1dlsym(IntPtr handle, Byte* symbol);
    private static IntPtr DL1dlerror();
    private static IntPtr DL2dlopen(Byte* filename, DlopenFlags flags);
    private static int DL2dlclose(IntPtr handle);
    private static IntPtr DL2dlsym(IntPtr handle, Byte* symbol);
    private static IntPtr DL2dlerror();
    [NullableContextAttribute("2")]
internal static Byte[] MarshalToUtf8(string str);
    [NullableContextAttribute("2")]
internal static void FreeMarshalledArray(Byte[] arr);
    [NullableContextAttribute("2")]
public static IntPtr DlOpen(string filename, DlopenFlags flags);
    public static bool DlClose(IntPtr handle);
    [NullableContextAttribute("1")]
public static IntPtr DlSym(IntPtr handle, string symbol);
    public static IntPtr DlError();
}
internal static class MonoMod.Utils.Interop.Windows : object {
    
public static int PROCESSOR_ARCHITECTURE_INTEL;
    
public static int PROCESSOR_ARCHITECTURE_MIPS;
    
public static int PROCESSOR_ARCHITECTURE_ALPHA;
    
public static int PROCESSOR_ARCHITECTURE_PPC;
    
public static int PROCESSOR_ARCHITECTURE_SHX;
    
public static int PROCESSOR_ARCHITECTURE_ARM;
    
public static int PROCESSOR_ARCHITECTURE_IA64;
    
public static int PROCESSOR_ARCHITECTURE_ALPHA64;
    
public static int PROCESSOR_ARCHITECTURE_MSIL;
    
public static int PROCESSOR_ARCHITECTURE_AMD64;
    
public static int PROCESSOR_ARCHITECTURE_IA32_ON_WIN64;
    
public static int PROCESSOR_ARCHITECTURE_NEUTRAL;
    
public static int PROCESSOR_ARCHITECTURE_ARM64;
    
public static int PROCESSOR_ARCHITECTURE_ARM32_ON_WIN64;
    
public static int PROCESSOR_ARCHITECTURE_IA32_ON_ARM64;
    
public static int PROCESSOR_ARCHITECTURE_UNKNOWN;
    [DefaultDllImportSearchPathsAttribute("2048")]
public static void GetSystemInfo(SYSTEM_INFO* lpSystemInfo);
    [DefaultDllImportSearchPathsAttribute("2048")]
public static HMODULE GetModuleHandleW(UInt16* lpModuleName);
    [DefaultDllImportSearchPathsAttribute("2048")]
public static IntPtr GetProcAddress(HMODULE hModule, SByte* lpProcName);
    [DefaultDllImportSearchPathsAttribute("2048")]
public static HMODULE LoadLibraryW(UInt16* lpLibFileName);
    [DefaultDllImportSearchPathsAttribute("2048")]
public static BOOL FreeLibrary(HMODULE hLibModule);
    [DefaultDllImportSearchPathsAttribute("2048")]
public static UInt32 GetLastError();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class MonoMod.Utils.LazyDisposable : object {
    [CompilerGeneratedAttribute]

private Action OnDispose;
    [NullableContextAttribute("1")]
public LazyDisposable(Action a);
    [CompilerGeneratedAttribute]
public void add_OnDispose(Action value);
    [CompilerGeneratedAttribute]
public void remove_OnDispose(Action value);
    public sealed virtual void Dispose();
}
internal class MonoMod.Utils.LazyDisposable`1 : object {
    [NullableAttribute("2")]

private T Instance;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]

private Action`1<T> OnDispose;
    [NullableContextAttribute("1")]
public LazyDisposable`1(T instance);
    [NullableContextAttribute("1")]
public LazyDisposable`1(T instance, Action`1<T> a);
    [CompilerGeneratedAttribute]
public void add_OnDispose(Action`1<T> value);
    [CompilerGeneratedAttribute]
public void remove_OnDispose(Action`1<T> value);
    public sealed virtual void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class MonoMod.Utils.MethodSignature : object {
    [CompilerGeneratedAttribute]

private Type <ReturnType>k__BackingField;
    
private Type[] parameters;
    
private static ConditionalWeakTable`2<MethodBase, MethodSignature> thisSigMap;
    
private static ConditionalWeakTable`2<MethodBase, MethodSignature> noThisSigMap;
    
public Type ReturnType { get; }
    
public int ParameterCount { get; }
    
public IEnumerable`1<Type> Parameters { get; }
    [NullableAttribute("2")]

public Type FirstParameter { get; }
    public MethodSignature(Type returnType, Type[] parameters);
    public MethodSignature(Type returnType, IEnumerable`1<Type> parameters);
    public MethodSignature(MethodBase method);
    public MethodSignature(MethodBase method, bool ignoreThis);
    private static MethodSignature();
    [CompilerGeneratedAttribute]
public Type get_ReturnType();
    public int get_ParameterCount();
    public IEnumerable`1<Type> get_Parameters();
    [NullableContextAttribute("2")]
public Type get_FirstParameter();
    public static MethodSignature ForMethod(MethodBase method);
    public static MethodSignature ForMethod(MethodBase method, bool ignoreThis);
    public bool IsCompatibleWith(MethodSignature other);
    public DynamicMethodDefinition CreateDmd(string name);
    public virtual string ToString();
    [NullableContextAttribute("0")]
private sealed virtual override bool MonoMod.Logs.IDebugFormattable.TryFormatInto(Span`1<char> span, Int32& wrote);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(MethodSignature other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class MonoMod.Utils.MMReflectionImporter : object {
    
public static IReflectionImporterProvider Provider;
    
public static IReflectionImporterProvider ProviderNoDefault;
    
private ModuleDefinition Module;
    
private DefaultReflectionImporter Default;
    
private Dictionary`2<Assembly, AssemblyNameReference> CachedAsms;
    
private Dictionary`2<Module, TypeReference> CachedModuleTypes;
    
private Dictionary`2<Type, TypeReference> CachedTypes;
    
private Dictionary`2<FieldInfo, FieldReference> CachedFields;
    
private Dictionary`2<MethodBase, MethodReference> CachedMethods;
    [CompilerGeneratedAttribute]

private bool <UseDefault>k__BackingField;
    
private Dictionary`2<Type, TypeReference> ElementTypes;
    
public bool UseDefault { get; public set; }
    public MMReflectionImporter(ModuleDefinition module);
    private static MMReflectionImporter();
    [CompilerGeneratedAttribute]
public bool get_UseDefault();
    [CompilerGeneratedAttribute]
public void set_UseDefault(bool value);
    private bool TryGetCachedType(Type type, TypeReference& typeRef, GenericImportKind importKind);
    private TypeReference SetCachedType(Type type, TypeReference typeRef, GenericImportKind importKind);
    [ObsoleteAttribute("Please use the Assembly overload instead.")]
public sealed virtual AssemblyNameReference ImportReference(AssemblyName reference);
    public AssemblyNameReference ImportReference(Assembly asm);
    public TypeReference ImportModuleType(Module module, IGenericParameterProvider context);
    public sealed virtual TypeReference ImportReference(Type type, IGenericParameterProvider context);
    private static bool _IsGenericInstance(Type type, GenericImportKind importKind);
    private GenericInstanceType _ImportGenericInstance(Type type, IGenericParameterProvider context, TypeReference typeRef);
    private TypeReference _ImportReference(Type type, IGenericParameterProvider context, GenericImportKind importKind);
    private static GenericParameter ImportGenericParameter(Type type, IGenericParameterProvider context);
    public sealed virtual FieldReference ImportReference(FieldInfo field, IGenericParameterProvider context);
    public sealed virtual MethodReference ImportReference(MethodBase method, IGenericParameterProvider context);
    private MethodReference _ImportReference(MethodBase method, IGenericParameterProvider context, GenericImportKind importKind);
}
internal enum MonoMod.Utils.OSKind : Enum {
    
public int value__;
    
public static OSKind Unknown;
    
public static OSKind Posix;
    
public static OSKind Linux;
    
public static OSKind Android;
    
public static OSKind OSX;
    
public static OSKind IOS;
    
public static OSKind BSD;
    
public static OSKind Windows;
    
public static OSKind Wine;
}
[ExtensionAttribute]
internal static class MonoMod.Utils.OSKindExtensions : object {
    [ExtensionAttribute]
public static bool Is(OSKind operatingSystem, OSKind test);
    [ExtensionAttribute]
public static OSKind GetKernel(OSKind operatingSystem);
    [ExtensionAttribute]
public static int GetSubtypeId(OSKind operatingSystem);
}
internal static class MonoMod.Utils.PlatformDetection : object {
    
private static int platInitState;
    
private static OSKind os;
    
private static ArchitectureKind arch;
    
private static int runtimeInitState;
    
private static RuntimeKind runtime;
    [NullableAttribute("2")]

private static Version runtimeVersion;
    
public static OSKind OS { get; }
    
public static ArchitectureKind Architecture { get; }
    
public static RuntimeKind Runtime { get; }
    [NullableAttribute("1")]

public static Version RuntimeVersion { get; }
    private static void EnsurePlatformInfoInitialized();
    public static OSKind get_OS();
    public static ArchitectureKind get_Architecture();
    private static ValueTuple`2<OSKind, ArchitectureKind> DetectPlatformInfo();
    private static int PosixUname(OSKind os, Byte* buf);
    private static string GetCString(ReadOnlySpan`1<byte> buffer, Int32& nullByte);
    private static void DetectInfoPosix(OSKind& os, ArchitectureKind& arch);
    private static void DetectInfoWindows(OSKind& os, ArchitectureKind& arch);
    private static bool CheckWine();
    [MemberNotNullAttribute("runtimeVersion")]
private static void EnsureRuntimeInitialized();
    public static RuntimeKind get_Runtime();
    [NullableContextAttribute("1")]
public static Version get_RuntimeVersion();
    private static ValueTuple`2<RuntimeKind, Version> DetermineRuntimeInfo();
    [CompilerGeneratedAttribute]
internal static int <PosixUname>g__Libc|9_0(Byte* buf);
    [CompilerGeneratedAttribute]
internal static int <PosixUname>g__Osx|9_1(Byte* buf);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class MonoMod.Utils.ReflectionHelper : object {
    
internal static bool IsCoreBCL;
    
internal static Dictionary`2<string, WeakReference> AssemblyCache;
    
internal static Dictionary`2<string, WeakReference[]> AssembliesCache;
    
internal static Dictionary`2<string, WeakReference> ResolveReflectionCache;
    
public static Byte[] AssemblyHashPrefix;
    
public static string AssemblyHashNameTag;
    
private static BindingFlags _BindingFlagsAll;
    
private static GetUnmanagedSigHelperDelegate GetUnmanagedSigHelper;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]

private static Object[] _CacheGetterArgs;
    
private static Type t_RuntimeType;
    [NullableAttribute("2")]

private static Type t_RuntimeTypeCache;
    [NullableAttribute("2")]

private static PropertyInfo p_RuntimeType_Cache;
    [NullableAttribute("2")]

private static MethodInfo m_RuntimeTypeCache_GetFieldList;
    [NullableAttribute("2")]

private static MethodInfo m_RuntimeTypeCache_GetPropertyList;
    
private static ConditionalWeakTable`2<Type, CacheFixEntry> _CacheFixed;
    [NullableAttribute("2")]

private static Type t_RuntimeModule;
    [NullableAttribute("2")]

private static PropertyInfo p_RuntimeModule_RuntimeType;
    [NullableAttribute("2")]

private static FieldInfo f_RuntimeModule__impl;
    [NullableAttribute("2")]

private static MethodInfo m_RuntimeModule_GetGlobalType;
    [NullableAttribute("2")]

private static FieldInfo f_SignatureHelper_module;
    private static ReflectionHelper();
    private static MemberInfo _Cache(string cacheKey, MemberInfo value);
    public static Assembly Load(ModuleDefinition module);
    public static Assembly Load(Stream stream);
    public static Type GetType(string name);
    [ExtensionAttribute]
public static void ApplyRuntimeHash(AssemblyNameReference asmRef, Assembly asm);
    [ExtensionAttribute]
public static string GetRuntimeHashedFullName(Assembly asm);
    [ExtensionAttribute]
public static string GetRuntimeHashedFullName(AssemblyNameReference asm);
    [ExtensionAttribute]
public static Type ResolveReflection(TypeReference mref);
    [ExtensionAttribute]
public static MethodBase ResolveReflection(MethodReference mref);
    [ExtensionAttribute]
public static FieldInfo ResolveReflection(FieldReference mref);
    [ExtensionAttribute]
public static PropertyInfo ResolveReflection(PropertyReference mref);
    [ExtensionAttribute]
public static EventInfo ResolveReflection(EventReference mref);
    [ExtensionAttribute]
public static MemberInfo ResolveReflection(MemberReference mref);
    [NullableContextAttribute("2")]
private static MemberInfo _ResolveReflection(MemberReference mref, Module[] modules);
    [ExtensionAttribute]
public static SignatureHelper ResolveReflection(CallSite csite, Module context);
    [ExtensionAttribute]
public static SignatureHelper ResolveReflectionSignature(IMethodSignature csite, Module context);
    [ExtensionAttribute]
public static void FixReflectionCacheAuto(Type type);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static void FixReflectionCache(Type type);
    private static bool _Verify(CacheFixEntry entry, Type type);
    private static Array _GetArray(object cache, MethodInfo getter);
    [NullableContextAttribute("0")]
private static void _FixReflectionCacheOrder(Array orig);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static Type GetModuleType(Module module);
    [ExtensionAttribute]
public static Type GetRealDeclaringType(MemberInfo member);
    private static Module GetSignatureHelperModule(SignatureHelper signature);
    [ExtensionAttribute]
public static CallSite ImportCallSite(ModuleDefinition moduleTo, ICallSiteGenerator signature);
    [ExtensionAttribute]
public static CallSite ImportCallSite(ModuleDefinition moduleTo, SignatureHelper signature);
    [ExtensionAttribute]
public static CallSite ImportCallSite(ModuleDefinition moduleTo, Module moduleFrom, int token);
    [ExtensionAttribute]
public static CallSite ImportCallSite(ModuleDefinition moduleTo, Module moduleFrom, Byte[] data);
    [CompilerGeneratedAttribute]
internal static void <ImportCallSite>g__ReadMethodSignature|50_0(IMethodSignature method, <>c__DisplayClass50_0& , <>c__DisplayClass50_1& );
    [CompilerGeneratedAttribute]
internal static UInt32 <ImportCallSite>g__ReadCompressedUInt32|50_1(<>c__DisplayClass50_1& );
    [CompilerGeneratedAttribute]
internal static int <ImportCallSite>g__ReadCompressedInt32|50_2(<>c__DisplayClass50_1& );
    [CompilerGeneratedAttribute]
internal static TypeReference <ImportCallSite>g__GetTypeDefOrRef|50_3(<>c__DisplayClass50_0& , <>c__DisplayClass50_1& );
    [CompilerGeneratedAttribute]
internal static TypeReference <ImportCallSite>g__ReadTypeSignature|50_4(<>c__DisplayClass50_0& , <>c__DisplayClass50_1& );
}
internal class MonoMod.Utils.Relinker : MulticastDelegate {
    public Relinker(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual IMetadataTokenProvider Invoke(IMetadataTokenProvider mtp, IGenericParameterProvider context);
    public virtual IAsyncResult BeginInvoke(IMetadataTokenProvider mtp, IGenericParameterProvider context, AsyncCallback callback, object object);
    public virtual IMetadataTokenProvider EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class MonoMod.Utils.RelinkFailedException : Exception {
    
public static string DefaultMessage;
    [CompilerGeneratedAttribute]

private IMetadataTokenProvider <MTP>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]

private IMetadataTokenProvider <Context>k__BackingField;
    
public IMetadataTokenProvider MTP { get; }
    [NullableAttribute("2")]

public IMetadataTokenProvider Context { get; }
    public RelinkFailedException(IMetadataTokenProvider mtp, IMetadataTokenProvider context);
    public RelinkFailedException(string message, IMetadataTokenProvider mtp, IMetadataTokenProvider context);
    public RelinkFailedException(string message, Exception innerException, IMetadataTokenProvider mtp, IMetadataTokenProvider context);
    [CompilerGeneratedAttribute]
public IMetadataTokenProvider get_MTP();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public IMetadataTokenProvider get_Context();
    protected static string Format(string message, IMetadataTokenProvider mtp, IMetadataTokenProvider context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class MonoMod.Utils.RelinkTargetNotFoundException : RelinkFailedException {
    
public static string DefaultMessage;
    public RelinkTargetNotFoundException(IMetadataTokenProvider mtp, IMetadataTokenProvider context);
    public RelinkTargetNotFoundException(string message, IMetadataTokenProvider mtp, IMetadataTokenProvider context);
    public RelinkTargetNotFoundException(string message, Exception innerException, IMetadataTokenProvider mtp, IMetadataTokenProvider context);
}
internal enum MonoMod.Utils.RuntimeKind : Enum {
    
public int value__;
    
public static RuntimeKind Unknown;
    
public static RuntimeKind Framework;
    
public static RuntimeKind CoreCLR;
    
public static RuntimeKind Mono;
}
internal abstract class MonoMod.Utils.ScopeHandlerBase : object {
    [NullableContextAttribute("2")]
public abstract virtual void EndScope(object data);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal abstract class MonoMod.Utils.ScopeHandlerBase`1 : ScopeHandlerBase {
    public sealed virtual void EndScope(object data);
    [NullableContextAttribute("1")]
public abstract virtual void EndScope(T data);
}
internal class MonoMod.Utils.WeakBox : object {
    [NullableAttribute("2")]

public object Value;
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class MonoMod.Utils.WeakReferenceComparer : EqualityComparer`1<WeakReference> {
    [NullableContextAttribute("2")]
public virtual bool Equals(WeakReference x, WeakReference y);
    public virtual int GetHashCode(WeakReference obj);
}
internal static class System.Array2 : object {
    [NullableContextAttribute("1")]
public static T[] Empty();
}
internal static class System.ArrayEx : object {
    
public static int MaxLength { get; }
    [NullableContextAttribute("1")]
public static T[] Empty();
    public static int get_MaxLength();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class System.Buffers.ArrayPool`1 : object {
    
private static TlsOverPerCoreLockedStacksArrayPool`1<T> s_shared;
    
public static ArrayPool`1<T> Shared { get; }
    private static ArrayPool`1();
    public static ArrayPool`1<T> get_Shared();
    public static ArrayPool`1<T> Create();
    public static ArrayPool`1<T> Create(int maxArrayLength, int maxArraysPerBucket);
    public abstract virtual T[] Rent(int minimumLength);
    public abstract virtual void Return(T[] array, bool clearArray);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class System.Buffers.BuffersExtensions : object {
    [ExtensionAttribute]
public static Nullable`1<SequencePosition> PositionOf(ReadOnlySequence`1& source, T value);
    private static Nullable`1<SequencePosition> PositionOfMultiSegment(ReadOnlySequence`1& source, T value);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static void CopyTo(ReadOnlySequence`1& source, Span`1<T> destination);
    [NullableContextAttribute("2")]
private static void CopyToMultiSegment(ReadOnlySequence`1& sequence, Span`1<T> destination);
    [ExtensionAttribute]
public static T[] ToArray(ReadOnlySequence`1& sequence);
    [ExtensionAttribute]
public static void Write(IBufferWriter`1<T> writer, ReadOnlySpan`1<T> value);
    private static void WriteMultiSegment(IBufferWriter`1<T> writer, ReadOnlySpan`1& source, Span`1<T> destination);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class System.Buffers.ConfigurableArrayPool`1 : ArrayPool`1<T> {
    
private static int DefaultMaxArrayLength;
    
private static int DefaultMaxNumberOfArraysPerBucket;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]

private Bucket[] _buckets;
    
private int Id { get; }
    internal ConfigurableArrayPool`1(int maxArrayLength, int maxArraysPerBucket);
    private int get_Id();
    public virtual T[] Rent(int minimumLength);
    public virtual void Return(T[] array, bool clearArray);
}
[NullableContextAttribute("2")]
internal interface System.Buffers.IBufferWriter`1 {
    public abstract virtual void Advance(int count);
    public abstract virtual Memory`1<T> GetMemory(int sizeHint);
    public abstract virtual Span`1<T> GetSpan(int sizeHint);
}
internal interface System.Buffers.IMemoryOwner`1 {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]

public Memory`1<T> Memory { get; }
    public abstract virtual Memory`1<T> get_Memory();
}
internal interface System.Buffers.IPinnable {
    public abstract virtual MemoryHandle Pin(int elementIndex);
    public abstract virtual void Unpin();
}
internal class System.Buffers.MemoryHandle : ValueType {
    
private Void* _pointer;
    
private GCHandle _handle;
    [NullableAttribute("2")]

private IPinnable _pinnable;
    [CLSCompliantAttribute("False")]

public Void* Pointer { get; }
    [CLSCompliantAttribute("False")]
public MemoryHandle(Void* pointer, GCHandle handle, IPinnable pinnable);
    public Void* get_Pointer();
    public sealed virtual void Dispose();
}
internal abstract class System.Buffers.MemoryManager`1 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]

public Memory`1<T> Memory { get; }
    public virtual Memory`1<T> get_Memory();
    public abstract virtual Span`1<T> GetSpan();
    public abstract virtual MemoryHandle Pin(int elementIndex);
    public abstract virtual void Unpin();
    protected Memory`1<T> CreateMemory(int length);
    protected Memory`1<T> CreateMemory(int start, int length);
    protected internal virtual bool TryGetArray(ArraySegment`1& segment);
    private sealed virtual override void System.IDisposable.Dispose();
    protected abstract virtual void Dispose(bool disposing);
}
internal static class System.Buffers.ReadOnlySequence : object {
    
public static int FlagBitMask;
    
public static int IndexBitMask;
    
public static int SegmentStartMask;
    
public static int SegmentEndMask;
    
public static int ArrayStartMask;
    
public static int ArrayEndMask;
    
public static int MemoryManagerStartMask;
    
public static int MemoryManagerEndMask;
    
public static int StringStartMask;
    
public static int StringEndMask;
    public static int SegmentToSequenceStart(int startIndex);
    public static int SegmentToSequenceEnd(int endIndex);
    public static int ArrayToSequenceStart(int startIndex);
    public static int ArrayToSequenceEnd(int endIndex);
    public static int MemoryManagerToSequenceStart(int startIndex);
    public static int MemoryManagerToSequenceEnd(int endIndex);
    public static int StringToSequenceStart(int startIndex);
    public static int StringToSequenceEnd(int endIndex);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DebuggerTypeProxyAttribute("System.Buffers.ReadOnlySequenceDebugView`1")]
[DebuggerDisplayAttribute("{ToString(),raw}")]
internal class System.Buffers.ReadOnlySequence`1 : ValueType {
    
private SequencePosition _sequenceStart;
    
private SequencePosition _sequenceEnd;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]

public static ReadOnlySequence`1<T> Empty;
    
public long Length { get; }
    
public bool IsEmpty { get; }
    
public bool IsSingleSegment { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]

public ReadOnlyMemory`1<T> First { get; }
    
public SequencePosition Start { get; }
    
public SequencePosition End { get; }
    [NullableContextAttribute("2")]
private ReadOnlySequence`1(object startSegment, int startIndexAndFlags, object endSegment, int endIndexAndFlags);
    public ReadOnlySequence`1(ReadOnlySequenceSegment`1<T> startSegment, int startIndex, ReadOnlySequenceSegment`1<T> endSegment, int endIndex);
    public ReadOnlySequence`1(T[] array);
    public ReadOnlySequence`1(T[] array, int start, int length);
    public ReadOnlySequence`1(ReadOnlyMemory`1<T> memory);
    private static ReadOnlySequence`1();
    public long get_Length();
    public bool get_IsEmpty();
    public bool get_IsSingleSegment();
    public ReadOnlyMemory`1<T> get_First();
    public SequencePosition get_Start();
    public SequencePosition get_End();
    public ReadOnlySequence`1<T> Slice(long start, long length);
    public ReadOnlySequence`1<T> Slice(long start, SequencePosition end);
    public ReadOnlySequence`1<T> Slice(SequencePosition start, long length);
    public ReadOnlySequence`1<T> Slice(int start, int length);
    public ReadOnlySequence`1<T> Slice(int start, SequencePosition end);
    public ReadOnlySequence`1<T> Slice(SequencePosition start, int length);
    public ReadOnlySequence`1<T> Slice(SequencePosition start, SequencePosition end);
    public ReadOnlySequence`1<T> Slice(SequencePosition start);
    public ReadOnlySequence`1<T> Slice(long start);
    public virtual string ToString();
    [NullableContextAttribute("0")]
public Enumerator<T> GetEnumerator();
    public SequencePosition GetPosition(long offset);
    public SequencePosition GetPosition(long offset, SequencePosition origin);
    public bool TryGet(SequencePosition& position, ReadOnlyMemory`1& memory, bool advance);
    internal bool TryGetBuffer(SequencePosition& position, ReadOnlyMemory`1& memory, SequencePosition& next);
    private ReadOnlyMemory`1<T> GetFirstBuffer();
    private static SequencePosition Seek(SequencePosition& start, SequencePosition& end, long offset, ExceptionArgument argument);
    [NullableContextAttribute("2")]
private static SequencePosition SeekMultiSegment(ReadOnlySequenceSegment`1<T> currentSegment, object endObject, int endIndex, long offset, ExceptionArgument argument);
    private void BoundsCheck(SequencePosition& position);
    [NullableContextAttribute("2")]
private void BoundsCheck(UInt32 sliceStartIndex, object sliceStartObject, UInt32 sliceEndIndex, object sliceEndObject);
    private static SequencePosition GetEndPosition(ReadOnlySequenceSegment`1<T> startSegment, object startObject, int startIndex, object endObject, int endIndex, long length);
    [NullableContextAttribute("0")]
private SequenceType<T> GetSequenceType();
    private static int GetIndex(SequencePosition& position);
    private ReadOnlySequence`1<T> SliceImpl(SequencePosition& start, SequencePosition& end);
    private long GetLength();
    internal bool TryGetReadOnlySequenceSegment(ReadOnlySequenceSegment`1& startSegment, Int32& startIndex, ReadOnlySequenceSegment`1& endSegment, Int32& endIndex);
    internal bool TryGetArray(ArraySegment`1& segment);
    internal bool TryGetString(String& text, Int32& start, Int32& length);
    private static bool InRange(UInt32 value, UInt32 start, UInt32 end);
    private static bool InRange(ulong value, ulong start, ulong end);
}
internal class System.Buffers.ReadOnlySequenceDebugView`1 : object {
    [NullableAttribute("1")]

private T[] _array;
    
private ReadOnlySequenceDebugViewSegments<T> _segments;
    
public ReadOnlySequenceDebugViewSegments<T> BufferSegments { get; }
    [NullableAttribute("1")]
[DebuggerBrowsableAttribute("3")]

public T[] Items { get; }
    public ReadOnlySequenceDebugView`1(ReadOnlySequence`1<T> sequence);
    public ReadOnlySequenceDebugViewSegments<T> get_BufferSegments();
    [NullableContextAttribute("1")]
public T[] get_Items();
}
internal abstract class System.Buffers.ReadOnlySequenceSegment`1 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]

private ReadOnlyMemory`1<T> <Memory>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]

private ReadOnlySequenceSegment`1<T> <Next>k__BackingField;
    [CompilerGeneratedAttribute]

private long <RunningIndex>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]

public ReadOnlyMemory`1<T> Memory { get; protected set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]

public ReadOnlySequenceSegment`1<T> Next { get; protected set; }
    
public long RunningIndex { get; protected set; }
    [CompilerGeneratedAttribute]
public ReadOnlyMemory`1<T> get_Memory();
    [CompilerGeneratedAttribute]
protected void set_Memory(ReadOnlyMemory`1<T> value);
    [CompilerGeneratedAttribute]
public ReadOnlySequenceSegment`1<T> get_Next();
    [CompilerGeneratedAttribute]
protected void set_Next(ReadOnlySequenceSegment`1<T> value);
    [CompilerGeneratedAttribute]
public long get_RunningIndex();
    [CompilerGeneratedAttribute]
protected void set_RunningIndex(long value);
}
[IsReadOnlyAttribute]
internal class System.Buffers.StandardFormat : ValueType {
    
public static byte NoPrecision;
    
public static byte MaxPrecision;
    
private byte _format;
    
private byte _precision;
    
public char Symbol { get; }
    
public byte Precision { get; }
    
public bool HasPrecision { get; }
    
public bool IsDefault { get; }
    public StandardFormat(char symbol, byte precision);
    public char get_Symbol();
    public byte get_Precision();
    public bool get_HasPrecision();
    public bool get_IsDefault();
    public static StandardFormat op_Implicit(char symbol);
    public static StandardFormat Parse(ReadOnlySpan`1<char> format);
    [NullableContextAttribute("2")]
public static StandardFormat Parse(string format);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual bool Equals(StandardFormat other);
    [NullableContextAttribute("1")]
public virtual string ToString();
    public static bool op_Equality(StandardFormat left, StandardFormat right);
    public static bool op_Inequality(StandardFormat left, StandardFormat right);
}
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class System.Buffers.TlsOverPerCoreLockedStacksArrayPool`1 : ArrayPool`1<T> {
    
private static int NumBuckets;
    
private static int MaxPerCorePerArraySizeStacks;
    
private static int MaxBuffersPerArraySizePerCore;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ThreadStaticAttribute]

private static ThreadLocalArray[] t_tlsBuckets;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]

private ConditionalWeakTable`2<ThreadLocalArray[], object> _allTlsBuckets;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]

private PerCoreLockedStacks[] _buckets;
    
private int _trimCallbackCreated;
    
private int Id { get; }
    private PerCoreLockedStacks<T> CreatePerCoreLockedStacks(int bucketIndex);
    private int get_Id();
    [NullableContextAttribute("1")]
public virtual T[] Rent(int minimumLength);
    [NullableContextAttribute("1")]
public virtual void Return(T[] array, bool clearArray);
    public bool Trim();
    private ThreadLocalArray[] InitializeTlsBucketsAndTrimming();
}
internal static class System.Buffers.Utilities : object {
    internal static int SelectBucketIndex(int bufferSize);
    internal static int GetMaxSizeForBucket(int binIndex);
    internal static MemoryPressure GetMemoryPressure();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class System.Collections.Concurrent.ConcurrentExtensions : object {
    [ExtensionAttribute]
public static void Clear(ConcurrentBag`1<T> bag);
    [ExtensionAttribute]
public static void Clear(ConcurrentQueue`1<T> queue);
    [ExtensionAttribute]
public static TValue AddOrUpdate(ConcurrentDictionary`2<TKey, TValue> dict, TKey key, Func`3<TKey, TArg, TValue> addValueFactory, Func`4<TKey, TValue, TArg, TValue> updateValueFactory, TArg factoryArgument);
    [ExtensionAttribute]
public static TValue GetOrAdd(ConcurrentDictionary`2<TKey, TValue> dict, TKey key, Func`3<TKey, TArg, TValue> valueFactory, TArg factoryArgument);
    [ExtensionAttribute]
public static bool TryRemove(ConcurrentDictionary`2<TKey, TValue> dict, KeyValuePair`2<TKey, TValue> item);
}
internal static class System.Collections.HashHelpers : object {
    
public static UInt32 HashCollisionThreshold;
    
public static int MaxPrimeArrayLength;
    
public static int HashPrime;
    [NullableAttribute("1")]

private static Int32[] s_primes;
    private static HashHelpers();
    public static bool IsPrime(int candidate);
    public static int GetPrime(int min);
    public static int ExpandPrime(int oldSize);
    public static ulong GetFastModMultiplier(UInt32 divisor);
    public static UInt32 FastMod(UInt32 value, UInt32 divisor, ulong multiplier);
}
[AttributeUsageAttribute("2432")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>AllowNullAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>DisallowNullAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>DoesNotReturnAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>DoesNotReturnIfAttribute : Attribute {
    [CompilerGeneratedAttribute]

private bool <ParameterValue>k__BackingField;
    
public bool ParameterValue { get; }
    public <027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>DoesNotReturnIfAttribute(bool parameterValue);
    [CompilerGeneratedAttribute]
public bool get_ParameterValue();
}
[AttributeUsageAttribute("10624")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MaybeNullAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MaybeNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]

private bool <ReturnValue>k__BackingField;
    
public bool ReturnValue { get; }
    public <027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MaybeNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("192")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MemberNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]

private String[] <Members>k__BackingField;
    
public String[] Members { get; }
    public <027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MemberNotNullAttribute(string member);
    public <027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MemberNotNullAttribute(String[] members);
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("192")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MemberNotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]

private bool <ReturnValue>k__BackingField;
    [CompilerGeneratedAttribute]

private String[] <Members>k__BackingField;
    
public bool ReturnValue { get; }
    
public String[] Members { get; }
    public <027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MemberNotNullWhenAttribute(bool returnValue, string member);
    public <027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MemberNotNullWhenAttribute(bool returnValue, String[] members);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[AttributeUsageAttribute("10624")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>NotNullAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("10368")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>NotNullIfNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]

private string <ParameterName>k__BackingField;
    
public string ParameterName { get; }
    public <027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>NotNullIfNotNullAttribute(string parameterName);
    [CompilerGeneratedAttribute]
public string get_ParameterName();
}
[AttributeUsageAttribute("2048")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>NotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]

private bool <ReturnValue>k__BackingField;
    
public bool ReturnValue { get; }
    public <027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>NotNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[AttributeUsageAttribute("2432")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.<22576685-8ec8-4022-94e7-b5a630de7c65>AllowNullAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.<22576685-8ec8-4022-94e7-b5a630de7c65>DisallowNullAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.<22576685-8ec8-4022-94e7-b5a630de7c65>DoesNotReturnAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.<22576685-8ec8-4022-94e7-b5a630de7c65>DoesNotReturnIfAttribute : Attribute {
    [CompilerGeneratedAttribute]

private bool <ParameterValue>k__BackingField;
    
public bool ParameterValue { get; }
    public <22576685-8ec8-4022-94e7-b5a630de7c65>DoesNotReturnIfAttribute(bool parameterValue);
    [CompilerGeneratedAttribute]
public bool get_ParameterValue();
}
[AttributeUsageAttribute("10624")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.<22576685-8ec8-4022-94e7-b5a630de7c65>MaybeNullAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.<22576685-8ec8-4022-94e7-b5a630de7c65>MaybeNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]

private bool <ReturnValue>k__BackingField;
    
public bool ReturnValue { get; }
    public <22576685-8ec8-4022-94e7-b5a630de7c65>MaybeNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("192")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.<22576685-8ec8-4022-94e7-b5a630de7c65>MemberNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]

private String[] <Members>k__BackingField;
    
public String[] Members { get; }
    public <22576685-8ec8-4022-94e7-b5a630de7c65>MemberNotNullAttribute(string member);
    public <22576685-8ec8-4022-94e7-b5a630de7c65>MemberNotNullAttribute(String[] members);
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("192")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.<22576685-8ec8-4022-94e7-b5a630de7c65>MemberNotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]

private bool <ReturnValue>k__BackingField;
    [CompilerGeneratedAttribute]

private String[] <Members>k__BackingField;
    
public bool ReturnValue { get; }
    
public String[] Members { get; }
    public <22576685-8ec8-4022-94e7-b5a630de7c65>MemberNotNullWhenAttribute(bool returnValue, string member);
    public <22576685-8ec8-4022-94e7-b5a630de7c65>MemberNotNullWhenAttribute(bool returnValue, String[] members);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[AttributeUsageAttribute("10624")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.<22576685-8ec8-4022-94e7-b5a630de7c65>NotNullAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("10368")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.<22576685-8ec8-4022-94e7-b5a630de7c65>NotNullIfNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]

private string <ParameterName>k__BackingField;
    
public string ParameterName { get; }
    public <22576685-8ec8-4022-94e7-b5a630de7c65>NotNullIfNotNullAttribute(string parameterName);
    [CompilerGeneratedAttribute]
public string get_ParameterName();
}
[AttributeUsageAttribute("2048")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.<22576685-8ec8-4022-94e7-b5a630de7c65>NotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]

private bool <ReturnValue>k__BackingField;
    
public bool ReturnValue { get; }
    public <22576685-8ec8-4022-94e7-b5a630de7c65>NotNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[AttributeUsageAttribute("2432")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.<b2ffb5d6-6a81-4f20-8e75-7064682f7f7c>AllowNullAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.<b2ffb5d6-6a81-4f20-8e75-7064682f7f7c>DisallowNullAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.<b2ffb5d6-6a81-4f20-8e75-7064682f7f7c>DoesNotReturnAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.<b2ffb5d6-6a81-4f20-8e75-7064682f7f7c>DoesNotReturnIfAttribute : Attribute {
    [CompilerGeneratedAttribute]

private bool <ParameterValue>k__BackingField;
    
public bool ParameterValue { get; }
    public <b2ffb5d6-6a81-4f20-8e75-7064682f7f7c>DoesNotReturnIfAttribute(bool parameterValue);
    [CompilerGeneratedAttribute]
public bool get_ParameterValue();
}
[AttributeUsageAttribute("10624")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.<b2ffb5d6-6a81-4f20-8e75-7064682f7f7c>MaybeNullAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.<b2ffb5d6-6a81-4f20-8e75-7064682f7f7c>MaybeNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]

private bool <ReturnValue>k__BackingField;
    
public bool ReturnValue { get; }
    public <b2ffb5d6-6a81-4f20-8e75-7064682f7f7c>MaybeNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("192")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.<b2ffb5d6-6a81-4f20-8e75-7064682f7f7c>MemberNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]

private String[] <Members>k__BackingField;
    
public String[] Members { get; }
    public <b2ffb5d6-6a81-4f20-8e75-7064682f7f7c>MemberNotNullAttribute(string member);
    public <b2ffb5d6-6a81-4f20-8e75-7064682f7f7c>MemberNotNullAttribute(String[] members);
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("192")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.<b2ffb5d6-6a81-4f20-8e75-7064682f7f7c>MemberNotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]

private bool <ReturnValue>k__BackingField;
    [CompilerGeneratedAttribute]

private String[] <Members>k__BackingField;
    
public bool ReturnValue { get; }
    
public String[] Members { get; }
    public <b2ffb5d6-6a81-4f20-8e75-7064682f7f7c>MemberNotNullWhenAttribute(bool returnValue, string member);
    public <b2ffb5d6-6a81-4f20-8e75-7064682f7f7c>MemberNotNullWhenAttribute(bool returnValue, String[] members);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[AttributeUsageAttribute("10624")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.<b2ffb5d6-6a81-4f20-8e75-7064682f7f7c>NotNullAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("10368")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.<b2ffb5d6-6a81-4f20-8e75-7064682f7f7c>NotNullIfNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]

private string <ParameterName>k__BackingField;
    
public string ParameterName { get; }
    public <b2ffb5d6-6a81-4f20-8e75-7064682f7f7c>NotNullIfNotNullAttribute(string parameterName);
    [CompilerGeneratedAttribute]
public string get_ParameterName();
}
[AttributeUsageAttribute("2048")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.<b2ffb5d6-6a81-4f20-8e75-7064682f7f7c>NotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]

private bool <ReturnValue>k__BackingField;
    
public bool ReturnValue { get; }
    public <b2ffb5d6-6a81-4f20-8e75-7064682f7f7c>NotNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[AttributeUsageAttribute("2432")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.AllowNullAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.DisallowNullAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.DoesNotReturnAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute : Attribute {
    [CompilerGeneratedAttribute]

private bool <ParameterValue>k__BackingField;
    
public bool ParameterValue { get; }
    public DoesNotReturnIfAttribute(bool parameterValue);
    [CompilerGeneratedAttribute]
public bool get_ParameterValue();
}
[AttributeUsageAttribute("28108")]
internal class System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembersAttribute : Attribute {
    [CompilerGeneratedAttribute]

private DynamicallyAccessedMemberTypes <MemberTypes>k__BackingField;
    
public DynamicallyAccessedMemberTypes MemberTypes { get; }
    public DynamicallyAccessedMembersAttribute(DynamicallyAccessedMemberTypes memberTypes);
    [CompilerGeneratedAttribute]
public DynamicallyAccessedMemberTypes get_MemberTypes();
}
[FlagsAttribute]
internal enum System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes : Enum {
    
public int value__;
    
public static DynamicallyAccessedMemberTypes None;
    
public static DynamicallyAccessedMemberTypes PublicParameterlessConstructor;
    
public static DynamicallyAccessedMemberTypes PublicConstructors;
    
public static DynamicallyAccessedMemberTypes NonPublicConstructors;
    
public static DynamicallyAccessedMemberTypes PublicMethods;
    
public static DynamicallyAccessedMemberTypes NonPublicMethods;
    
public static DynamicallyAccessedMemberTypes PublicFields;
    
public static DynamicallyAccessedMemberTypes NonPublicFields;
    
public static DynamicallyAccessedMemberTypes PublicNestedTypes;
    
public static DynamicallyAccessedMemberTypes NonPublicNestedTypes;
    
public static DynamicallyAccessedMemberTypes PublicProperties;
    
public static DynamicallyAccessedMemberTypes NonPublicProperties;
    
public static DynamicallyAccessedMemberTypes PublicEvents;
    
public static DynamicallyAccessedMemberTypes NonPublicEvents;
    
public static DynamicallyAccessedMemberTypes All;
}
internal static class System.Diagnostics.CodeAnalysis.ExtraDynamicallyAccessedMemberTypes : object {
    
public static DynamicallyAccessedMemberTypes Interfaces;
}
[AttributeUsageAttribute("10624")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.MaybeNullAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]

private bool <ReturnValue>k__BackingField;
    
public bool ReturnValue { get; }
    public MaybeNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("192")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.MemberNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]

private String[] <Members>k__BackingField;
    
public String[] Members { get; }
    public MemberNotNullAttribute(string member);
    public MemberNotNullAttribute(String[] members);
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("192")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]

private bool <ReturnValue>k__BackingField;
    [CompilerGeneratedAttribute]

private String[] <Members>k__BackingField;
    
public bool ReturnValue { get; }
    
public String[] Members { get; }
    public MemberNotNullWhenAttribute(bool returnValue, string member);
    public MemberNotNullWhenAttribute(bool returnValue, String[] members);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[AttributeUsageAttribute("10624")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.NotNullAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("10368")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]

private string <ParameterName>k__BackingField;
    
public string ParameterName { get; }
    public NotNullIfNotNullAttribute(string parameterName);
    [CompilerGeneratedAttribute]
public string get_ParameterName();
}
[AttributeUsageAttribute("2048")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.NotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]

private bool <ReturnValue>k__BackingField;
    
public bool ReturnValue { get; }
    public NotNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[AttributeUsageAttribute("2240")]
internal class System.Diagnostics.CodeAnalysis.UnscopedRefAttribute : Attribute {
}
internal static class System.Diagnostics.Debug2 : object {
    [ConditionalAttribute("DEBUG")]
public static void Assert(bool condition);
}
internal static class System.EnvironmentEx : object {
    
public static int CurrentManagedThreadId { get; }
    public static int get_CurrentManagedThreadId();
}
internal enum System.ExceptionArgument : Enum {
    
public int value__;
    
public static ExceptionArgument length;
    
public static ExceptionArgument start;
    
public static ExceptionArgument bufferSize;
    
public static ExceptionArgument minimumBufferSize;
    
public static ExceptionArgument elementIndex;
    
public static ExceptionArgument comparable;
    
public static ExceptionArgument comparer;
    
public static ExceptionArgument destination;
    
public static ExceptionArgument offset;
    
public static ExceptionArgument startSegment;
    
public static ExceptionArgument endSegment;
    
public static ExceptionArgument startIndex;
    
public static ExceptionArgument endIndex;
    
public static ExceptionArgument array;
    
public static ExceptionArgument culture;
    
public static ExceptionArgument manager;
    
public static ExceptionArgument key;
    
public static ExceptionArgument collection;
    
public static ExceptionArgument index;
    
public static ExceptionArgument type;
    
public static ExceptionArgument self;
    
public static ExceptionArgument value;
    
public static ExceptionArgument oldValue;
    
public static ExceptionArgument newValue;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class System.Gen2GcCallback : CriticalFinalizerObject {
    [NullableAttribute("2")]

private Func`1<bool> _callback0;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]

private Func`2<object, bool> _callback1;
    
private GCHandle _weakTargetObj;
    private Gen2GcCallback(Func`1<bool> callback);
    private Gen2GcCallback(Func`2<object, bool> callback, object targetObj);
    public static void Register(Func`1<bool> callback);
    public static void Register(Func`2<object, bool> callback, object targetObj);
    protected virtual override void Finalize();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class System.HashCode : ValueType {
    
private static UInt32 s_seed;
    
private static UInt32 Prime1;
    
private static UInt32 Prime2;
    
private static UInt32 Prime3;
    
private static UInt32 Prime4;
    
private static UInt32 Prime5;
    
private UInt32 _v1;
    
private UInt32 _v2;
    
private UInt32 _v3;
    
private UInt32 _v4;
    
private UInt32 _queue1;
    
private UInt32 _queue2;
    
private UInt32 _queue3;
    
private UInt32 _length;
    private static HashCode();
    private static UInt32 GenerateGlobalSeed();
    public static int Combine(T1 value1);
    public static int Combine(T1 value1, T2 value2);
    public static int Combine(T1 value1, T2 value2, T3 value3);
    public static int Combine(T1 value1, T2 value2, T3 value3, T4 value4);
    public static int Combine(T1 value1, T2 value2, T3 value3, T4 value4, T5 value5);
    public static int Combine(T1 value1, T2 value2, T3 value3, T4 value4, T5 value5, T6 value6);
    public static int Combine(T1 value1, T2 value2, T3 value3, T4 value4, T5 value5, T6 value6, T7 value7);
    public static int Combine(T1 value1, T2 value2, T3 value3, T4 value4, T5 value5, T6 value6, T7 value7, T8 value8);
    private static void Initialize(UInt32& v1, UInt32& v2, UInt32& v3, UInt32& v4);
    private static UInt32 Round(UInt32 hash, UInt32 input);
    private static UInt32 QueueRound(UInt32 hash, UInt32 queuedValue);
    private static UInt32 MixState(UInt32 v1, UInt32 v2, UInt32 v3, UInt32 v4);
    private static UInt32 MixEmptyState();
    private static UInt32 MixFinal(UInt32 hash);
    public void Add(T value);
    public void Add(T value, IEqualityComparer`1<T> comparer);
    [NullableContextAttribute("0")]
public void AddBytes(ReadOnlySpan`1<byte> value);
    private void Add(int value);
    public int ToHashCode();
    [ObsoleteAttribute("HashCode is a mutable struct and should not be compared with other HashCodes. Use ToHashCode to retrieve the computed hash code.", "True")]
[EditorBrowsableAttribute("1")]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[ObsoleteAttribute("HashCode is a mutable struct and should not be compared with other HashCodes.", "True")]
[EditorBrowsableAttribute("1")]
public virtual bool Equals(object obj);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class System.IO.StreamExtensions : object {
    [ExtensionAttribute]
public static void CopyTo(Stream src, Stream destination);
    [ExtensionAttribute]
public static void CopyTo(Stream src, Stream destination, int bufferSize);
}
internal static class System.MathEx : object {
    public static byte Clamp(byte value, byte min, byte max);
    public static decimal Clamp(decimal value, decimal min, decimal max);
    public static double Clamp(double value, double min, double max);
    public static short Clamp(short value, short min, short max);
    public static int Clamp(int value, int min, int max);
    public static long Clamp(long value, long min, long max);
    public static IntPtr Clamp(IntPtr value, IntPtr min, IntPtr max);
    [CLSCompliantAttribute("False")]
public static sbyte Clamp(sbyte value, sbyte min, sbyte max);
    public static float Clamp(float value, float min, float max);
    [CLSCompliantAttribute("False")]
public static ushort Clamp(ushort value, ushort min, ushort max);
    [CLSCompliantAttribute("False")]
public static UInt32 Clamp(UInt32 value, UInt32 min, UInt32 max);
    [CLSCompliantAttribute("False")]
public static ulong Clamp(ulong value, ulong min, ulong max);
    [CLSCompliantAttribute("False")]
public static UIntPtr Clamp(UIntPtr value, UIntPtr min, UIntPtr max);
    [NullableContextAttribute("1")]
[<22576685-8ec8-4022-94e7-b5a630de7c65>DoesNotReturnAttribute]
private static void ThrowMinMaxException(T min, T max);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DebuggerTypeProxyAttribute("System.MemoryDebugView`1")]
[DebuggerDisplayAttribute("{ToString(),raw}")]
internal class System.Memory`1 : ValueType {
    [NullableAttribute("2")]

private object _object;
    
private int _index;
    
private int _length;
    
private static int RemoveFlagsBitMask;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]

public static Memory`1<T> Empty { get; }
    
public int Length { get; }
    
public bool IsEmpty { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]

public Span`1<T> Span { get; }
    public Memory`1(T[] array);
    internal Memory`1(T[] array, int start);
    public Memory`1(T[] array, int start, int length);
    internal Memory`1(MemoryManager`1<T> manager, int length);
    internal Memory`1(MemoryManager`1<T> manager, int start, int length);
    [NullableContextAttribute("2")]
internal Memory`1(object obj, int start, int length);
    public static Memory`1<T> op_Implicit(T[] array);
    public static Memory`1<T> op_Implicit(ArraySegment`1<T> segment);
    public static ReadOnlyMemory`1<T> op_Implicit(Memory`1<T> memory);
    public static Memory`1<T> get_Empty();
    public int get_Length();
    public bool get_IsEmpty();
    public virtual string ToString();
    public Memory`1<T> Slice(int start);
    public Memory`1<T> Slice(int start, int length);
    public Span`1<T> get_Span();
    public void CopyTo(Memory`1<T> destination);
    public bool TryCopyTo(Memory`1<T> destination);
    public MemoryHandle Pin();
    public T[] ToArray();
    [NullableContextAttribute("2")]
[EditorBrowsableAttribute("1")]
public virtual bool Equals(object obj);
    public bool Equals(Memory`1<T> other);
    [EditorBrowsableAttribute("1")]
public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class System.MemoryDebugView`1 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]

private ReadOnlyMemory`1<T> _memory;
    [DebuggerBrowsableAttribute("3")]

public T[] Items { get; }
    public MemoryDebugView`1(Memory`1<T> memory);
    public MemoryDebugView`1(ReadOnlyMemory`1<T> memory);
    public T[] get_Items();
}
[ExtensionAttribute]
internal static class System.MemoryExtensions : object {
    [NativeIntegerAttribute]

internal static IntPtr StringAdjustment;
    private static MemoryExtensions();
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> Trim(ReadOnlySpan`1<char> span);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> TrimStart(ReadOnlySpan`1<char> span);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> TrimEnd(ReadOnlySpan`1<char> span);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> Trim(ReadOnlySpan`1<char> span, char trimChar);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> TrimStart(ReadOnlySpan`1<char> span, char trimChar);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> TrimEnd(ReadOnlySpan`1<char> span, char trimChar);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> Trim(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> trimChars);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> TrimStart(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> trimChars);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> TrimEnd(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> trimChars);
    [ExtensionAttribute]
public static bool IsWhiteSpace(ReadOnlySpan`1<char> span);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static int IndexOf(Span`1<T> span, T value);
    [ExtensionAttribute]
public static int IndexOf(Span`1<T> span, ReadOnlySpan`1<T> value);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static int LastIndexOf(Span`1<T> span, T value);
    [ExtensionAttribute]
public static int LastIndexOf(Span`1<T> span, ReadOnlySpan`1<T> value);
    [ExtensionAttribute]
public static bool SequenceEqual(Span`1<T> span, ReadOnlySpan`1<T> other);
    [ExtensionAttribute]
public static int SequenceCompareTo(Span`1<T> span, ReadOnlySpan`1<T> other);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static int IndexOf(ReadOnlySpan`1<T> span, T value);
    [ExtensionAttribute]
public static int IndexOf(ReadOnlySpan`1<T> span, ReadOnlySpan`1<T> value);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static int LastIndexOf(ReadOnlySpan`1<T> span, T value);
    [ExtensionAttribute]
public static int LastIndexOf(ReadOnlySpan`1<T> span, ReadOnlySpan`1<T> value);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static int IndexOfAny(Span`1<T> span, T value0, T value1);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static int IndexOfAny(Span`1<T> span, T value0, T value1, T value2);
    [ExtensionAttribute]
public static int IndexOfAny(Span`1<T> span, ReadOnlySpan`1<T> values);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static int IndexOfAny(ReadOnlySpan`1<T> span, T value0, T value1);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static int IndexOfAny(ReadOnlySpan`1<T> span, T value0, T value1, T value2);
    [ExtensionAttribute]
public static int IndexOfAny(ReadOnlySpan`1<T> span, ReadOnlySpan`1<T> values);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static int LastIndexOfAny(Span`1<T> span, T value0, T value1);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static int LastIndexOfAny(Span`1<T> span, T value0, T value1, T value2);
    [ExtensionAttribute]
public static int LastIndexOfAny(Span`1<T> span, ReadOnlySpan`1<T> values);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static int LastIndexOfAny(ReadOnlySpan`1<T> span, T value0, T value1);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static int LastIndexOfAny(ReadOnlySpan`1<T> span, T value0, T value1, T value2);
    [ExtensionAttribute]
public static int LastIndexOfAny(ReadOnlySpan`1<T> span, ReadOnlySpan`1<T> values);
    [ExtensionAttribute]
public static bool SequenceEqual(ReadOnlySpan`1<T> span, ReadOnlySpan`1<T> other);
    [ExtensionAttribute]
public static int SequenceCompareTo(ReadOnlySpan`1<T> span, ReadOnlySpan`1<T> other);
    [ExtensionAttribute]
public static bool StartsWith(Span`1<T> span, ReadOnlySpan`1<T> value);
    [ExtensionAttribute]
public static bool StartsWith(ReadOnlySpan`1<T> span, ReadOnlySpan`1<T> value);
    [ExtensionAttribute]
public static bool EndsWith(Span`1<T> span, ReadOnlySpan`1<T> value);
    [ExtensionAttribute]
public static bool EndsWith(ReadOnlySpan`1<T> span, ReadOnlySpan`1<T> value);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static void Reverse(Span`1<T> span);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static Span`1<T> AsSpan(T[] array);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static Span`1<T> AsSpan(T[] array, int start, int length);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static Span`1<T> AsSpan(ArraySegment`1<T> segment);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static Span`1<T> AsSpan(ArraySegment`1<T> segment, int start);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static Span`1<T> AsSpan(ArraySegment`1<T> segment, int start, int length);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static Memory`1<T> AsMemory(T[] array);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static Memory`1<T> AsMemory(T[] array, int start);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static Memory`1<T> AsMemory(T[] array, int start, int length);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static Memory`1<T> AsMemory(ArraySegment`1<T> segment);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static Memory`1<T> AsMemory(ArraySegment`1<T> segment, int start);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static Memory`1<T> AsMemory(ArraySegment`1<T> segment, int start, int length);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static void CopyTo(T[] source, Span`1<T> destination);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static void CopyTo(T[] source, Memory`1<T> destination);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool Overlaps(Span`1<T> span, ReadOnlySpan`1<T> other);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool Overlaps(Span`1<T> span, ReadOnlySpan`1<T> other, Int32& elementOffset);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool Overlaps(ReadOnlySpan`1<T> span, ReadOnlySpan`1<T> other);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool Overlaps(ReadOnlySpan`1<T> span, ReadOnlySpan`1<T> other, Int32& elementOffset);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static int BinarySearch(Span`1<T> span, IComparable`1<T> comparable);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static int BinarySearch(Span`1<T> span, TComparable comparable);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static int BinarySearch(Span`1<T> span, T value, TComparer comparer);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static int BinarySearch(ReadOnlySpan`1<T> span, IComparable`1<T> comparable);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static int BinarySearch(ReadOnlySpan`1<T> span, TComparable comparable);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static int BinarySearch(ReadOnlySpan`1<T> span, T value, TComparer comparer);
    [NullableContextAttribute("2")]
private static bool IsTypeComparableAsBytes(UIntPtr& size);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static Span`1<T> AsSpan(T[] array, int start);
    [ExtensionAttribute]
public static bool Contains(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> value, StringComparison comparisonType);
    [ExtensionAttribute]
public static bool Equals(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> other, StringComparison comparisonType);
    private static bool EqualsOrdinalIgnoreCase(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> other);
    [ExtensionAttribute]
public static int CompareTo(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> other, StringComparison comparisonType);
    private static int CompareToOrdinalIgnoreCase(ReadOnlySpan`1<char> strA, ReadOnlySpan`1<char> strB);
    [ExtensionAttribute]
public static int IndexOf(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> value, StringComparison comparisonType);
    [ExtensionAttribute]
public static int ToLower(ReadOnlySpan`1<char> source, Span`1<char> destination, CultureInfo culture);
    [ExtensionAttribute]
public static int ToLowerInvariant(ReadOnlySpan`1<char> source, Span`1<char> destination);
    [ExtensionAttribute]
public static int ToUpper(ReadOnlySpan`1<char> source, Span`1<char> destination, CultureInfo culture);
    [ExtensionAttribute]
public static int ToUpperInvariant(ReadOnlySpan`1<char> source, Span`1<char> destination);
    [ExtensionAttribute]
public static bool EndsWith(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> value, StringComparison comparisonType);
    [ExtensionAttribute]
public static bool StartsWith(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> value, StringComparison comparisonType);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> AsSpan(string text);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> AsSpan(string text, int start);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> AsSpan(string text, int start, int length);
    [ExtensionAttribute]
public static ReadOnlyMemory`1<char> AsMemory(string text);
    [ExtensionAttribute]
public static ReadOnlyMemory`1<char> AsMemory(string text, int start);
    [ExtensionAttribute]
public static ReadOnlyMemory`1<char> AsMemory(string text, int start, int length);
    private static IntPtr MeasureStringAdjustment();
}
internal static class System.Numerics.BitOperations : object {
    
private static ReadOnlySpan`1<byte> TrailingZeroCountDeBruijn { get; }
    
private static ReadOnlySpan`1<byte> Log2DeBruijn { get; }
    private static ReadOnlySpan`1<byte> get_TrailingZeroCountDeBruijn();
    private static ReadOnlySpan`1<byte> get_Log2DeBruijn();
    [CLSCompliantAttribute("False")]
public static int LeadingZeroCount(UInt32 value);
    [CLSCompliantAttribute("False")]
public static int LeadingZeroCount(ulong value);
    [CLSCompliantAttribute("False")]
public static int Log2(UInt32 value);
    [CLSCompliantAttribute("False")]
public static int Log2(ulong value);
    private static int Log2SoftwareFallback(UInt32 value);
    internal static int Log2Ceiling(UInt32 value);
    internal static int Log2Ceiling(ulong value);
    [CLSCompliantAttribute("False")]
public static int PopCount(UInt32 value);
    [CLSCompliantAttribute("False")]
public static int PopCount(ulong value);
    public static int TrailingZeroCount(int value);
    [CLSCompliantAttribute("False")]
public static int TrailingZeroCount(UInt32 value);
    public static int TrailingZeroCount(long value);
    [CLSCompliantAttribute("False")]
public static int TrailingZeroCount(ulong value);
    [CLSCompliantAttribute("False")]
public static UInt32 RotateLeft(UInt32 value, int offset);
    [CLSCompliantAttribute("False")]
public static ulong RotateLeft(ulong value, int offset);
    [CLSCompliantAttribute("False")]
public static UInt32 RotateRight(UInt32 value, int offset);
    [CLSCompliantAttribute("False")]
public static ulong RotateRight(ulong value, int offset);
    internal static UInt32 ResetLowestSetBit(UInt32 value);
    internal static UInt32 ResetBit(UInt32 value, int bitPos);
    [CompilerGeneratedAttribute]
internal static int <PopCount>g__SoftwareFallback|11_0(UInt32 value);
    [CompilerGeneratedAttribute]
internal static int <PopCount>g__SoftwareFallback|12_0(ulong value);
}
internal static class System.Numerics.BitOperationsEx : object {
    public static bool IsPow2(int value);
    [CLSCompliantAttribute("False")]
public static bool IsPow2(UInt32 value);
    public static bool IsPow2(long value);
    [CLSCompliantAttribute("False")]
public static bool IsPow2(ulong value);
    public static bool IsPow2(IntPtr value);
    [CLSCompliantAttribute("False")]
public static bool IsPow2(UIntPtr value);
    [CLSCompliantAttribute("False")]
public static UInt32 RoundUpToPowerOf2(UInt32 value);
    [CLSCompliantAttribute("False")]
public static ulong RoundUpToPowerOf2(ulong value);
    [CLSCompliantAttribute("False")]
public static UIntPtr RoundUpToPowerOf2(UIntPtr value);
    [CLSCompliantAttribute("False")]
public static int LeadingZeroCount(UInt32 value);
    [CLSCompliantAttribute("False")]
public static int LeadingZeroCount(ulong value);
    [CLSCompliantAttribute("False")]
public static int LeadingZeroCount(UIntPtr value);
    [CLSCompliantAttribute("False")]
public static int Log2(UInt32 value);
    [CLSCompliantAttribute("False")]
public static int Log2(ulong value);
    [CLSCompliantAttribute("False")]
public static int Log2(UIntPtr value);
    [CLSCompliantAttribute("False")]
public static int PopCount(UInt32 value);
    [CLSCompliantAttribute("False")]
public static int PopCount(ulong value);
    [CLSCompliantAttribute("False")]
public static int PopCount(UIntPtr value);
    public static int TrailingZeroCount(int value);
    [CLSCompliantAttribute("False")]
public static int TrailingZeroCount(UInt32 value);
    public static int TrailingZeroCount(long value);
    [CLSCompliantAttribute("False")]
public static int TrailingZeroCount(ulong value);
    public static int TrailingZeroCount(IntPtr value);
    [CLSCompliantAttribute("False")]
public static int TrailingZeroCount(UIntPtr value);
    [CLSCompliantAttribute("False")]
public static UInt32 RotateLeft(UInt32 value, int offset);
    [CLSCompliantAttribute("False")]
public static ulong RotateLeft(ulong value, int offset);
    [CLSCompliantAttribute("False")]
public static UIntPtr RotateLeft(UIntPtr value, int offset);
    [CLSCompliantAttribute("False")]
public static UInt32 RotateRight(UInt32 value, int offset);
    [CLSCompliantAttribute("False")]
public static ulong RotateRight(ulong value, int offset);
    [CLSCompliantAttribute("False")]
public static UIntPtr RotateRight(UIntPtr value, int offset);
}
internal class System.Pinnable`1 : object {
    [NullableAttribute("1")]

public T Data;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DebuggerTypeProxyAttribute("System.MemoryDebugView`1")]
[DebuggerDisplayAttribute("{ToString(),raw}")]
internal class System.ReadOnlyMemory`1 : ValueType {
    
private object _object;
    
private int _index;
    
private int _length;
    
internal static int RemoveFlagsBitMask;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]

public static ReadOnlyMemory`1<T> Empty { get; }
    
public int Length { get; }
    
public bool IsEmpty { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]

public ReadOnlySpan`1<T> Span { get; }
    public ReadOnlyMemory`1(T[] array);
    public ReadOnlyMemory`1(T[] array, int start, int length);
    internal ReadOnlyMemory`1(object obj, int start, int length);
    public static ReadOnlyMemory`1<T> op_Implicit(T[] array);
    public static ReadOnlyMemory`1<T> op_Implicit(ArraySegment`1<T> segment);
    public static ReadOnlyMemory`1<T> get_Empty();
    public int get_Length();
    public bool get_IsEmpty();
    [NullableContextAttribute("1")]
public virtual string ToString();
    public ReadOnlyMemory`1<T> Slice(int start);
    public ReadOnlyMemory`1<T> Slice(int start, int length);
    public ReadOnlySpan`1<T> get_Span();
    public void CopyTo(Memory`1<T> destination);
    public bool TryCopyTo(Memory`1<T> destination);
    public MemoryHandle Pin();
    [NullableContextAttribute("1")]
public T[] ToArray();
    [EditorBrowsableAttribute("1")]
public virtual bool Equals(object obj);
    public bool Equals(ReadOnlyMemory`1<T> other);
    [EditorBrowsableAttribute("1")]
public virtual int GetHashCode();
    internal object GetObjectStartLength(Int32& start, Int32& length);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
[DebuggerTypeProxyAttribute("System.SpanDebugView`1")]
[DebuggerDisplayAttribute("{ToString(),raw}")]
internal class System.ReadOnlySpan`1 : ValueType {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]

private Pinnable`1<T> _pinnable;
    
private IntPtr _byteOffset;
    
private int _length;
    
public int Length { get; }
    
public bool IsEmpty { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]

public static ReadOnlySpan`1<T> Empty { get; }
    [IsReadOnlyAttribute]

public T& modreq(System.Runtime.InteropServices.InAttribute) Item { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]

internal Pinnable`1<T> Pinnable { get; }
    
internal IntPtr ByteOffset { get; }
    public ReadOnlySpan`1(T[] array);
    public ReadOnlySpan`1(T[] array, int start, int length);
    [NullableContextAttribute("0")]
[CLSCompliantAttribute("False")]
public ReadOnlySpan`1(Void* pointer, int length);
    internal ReadOnlySpan`1(Pinnable`1<T> pinnable, IntPtr byteOffset, int length);
    public int get_Length();
    public bool get_IsEmpty();
    public static bool op_Inequality(ReadOnlySpan`1<T> left, ReadOnlySpan`1<T> right);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Equals() on ReadOnlySpan will always throw an exception. Use == instead.")]
[EditorBrowsableAttribute("1")]
public virtual bool Equals(object obj);
    [ObsoleteAttribute("GetHashCode() on ReadOnlySpan will always throw an exception.")]
[EditorBrowsableAttribute("1")]
public virtual int GetHashCode();
    public static ReadOnlySpan`1<T> op_Implicit(T[] array);
    public static ReadOnlySpan`1<T> op_Implicit(ArraySegment`1<T> segment);
    public static ReadOnlySpan`1<T> get_Empty();
    [NullableContextAttribute("0")]
public Enumerator<T> GetEnumerator();
    public T& modreq(System.Runtime.InteropServices.InAttribute) get_Item(int index);
    [EditorBrowsableAttribute("1")]
public T& modreq(System.Runtime.InteropServices.InAttribute) GetPinnableReference();
    public void CopyTo(Span`1<T> destination);
    public bool TryCopyTo(Span`1<T> destination);
    public static bool op_Equality(ReadOnlySpan`1<T> left, ReadOnlySpan`1<T> right);
    public virtual string ToString();
    public ReadOnlySpan`1<T> Slice(int start);
    public ReadOnlySpan`1<T> Slice(int start, int length);
    public T[] ToArray();
    [EditorBrowsableAttribute("1")]
internal T& DangerousGetPinnableReference();
    internal Pinnable`1<T> get_Pinnable();
    internal IntPtr get_ByteOffset();
}
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal static class System.Runtime.CompilerServices.<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>IsExternalInit : object {
}
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal static class System.Runtime.CompilerServices.<22576685-8ec8-4022-94e7-b5a630de7c65>IsExternalInit : object {
}
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal static class System.Runtime.CompilerServices.<b2ffb5d6-6a81-4f20-8e75-7064682f7f7c>IsExternalInit : object {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("2048")]
internal class System.Runtime.CompilerServices.CallerArgumentExpressionAttribute : Attribute {
    [CompilerGeneratedAttribute]

private string <ParameterName>k__BackingField;
    
public string ParameterName { get; }
    public CallerArgumentExpressionAttribute(string parameterName);
    [CompilerGeneratedAttribute]
public string get_ParameterName();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class System.Runtime.CompilerServices.ConditionalWeakTableExtensions : object {
    [ExtensionAttribute]
public static IEnumerable`1<KeyValuePair`2<TKey, TValue>> AsEnumerable(ConditionalWeakTable`2<TKey, TValue> self);
    [ExtensionAttribute]
public static IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator(ConditionalWeakTable`2<TKey, TValue> self);
    [ExtensionAttribute]
public static void Clear(ConditionalWeakTable`2<TKey, TValue> self);
    [ExtensionAttribute]
public static bool TryAdd(ConditionalWeakTable`2<TKey, TValue> self, TKey key, TValue value);
    [IteratorStateMachineAttribute("System.Runtime.CompilerServices.ConditionalWeakTableExtensions/<<GetEnumerator>g__Enumerate|2_0>d`2")]
[CompilerGeneratedAttribute]
internal static IEnumerator`1<KeyValuePair`2<TKey, TValue>> <GetEnumerator>g__Enumerate|2_0(ConditionalWeakTable`2<TKey, TValue> cwt, IEnumerable`1<TKey> keys);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class System.Runtime.CompilerServices.CWTEnumerable`2 : object {
    
private ConditionalWeakTable`2<TKey, TValue> cwt;
    public CWTEnumerable`2(ConditionalWeakTable`2<TKey, TValue> table);
    public sealed virtual IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[InterpolatedStringHandlerAttribute]
internal class System.Runtime.CompilerServices.DefaultInterpolatedStringHandler : ValueType {
    
private static int GuessedLengthPerHole;
    
private static int MinimumArrayPoolLength;
    
private IFormatProvider _provider;
    
private Char[] _arrayToReturnToPool;
    [NullableAttribute("0")]

private Span`1<char> _chars;
    
private int _pos;
    
private bool _hasCustomFormatter;
    [NullableAttribute("0")]

internal ReadOnlySpan`1<char> Text { get; }
    public DefaultInterpolatedStringHandler(int literalLength, int formattedCount);
    public DefaultInterpolatedStringHandler(int literalLength, int formattedCount, IFormatProvider provider);
    [NullableContextAttribute("0")]
public DefaultInterpolatedStringHandler(int literalLength, int formattedCount, IFormatProvider provider, Span`1<char> initialBuffer);
    internal static int GetDefaultLength(int literalLength, int formattedCount);
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
public string ToStringAndClear();
    internal void Clear();
    [NullableContextAttribute("0")]
internal ReadOnlySpan`1<char> get_Text();
    [NullableContextAttribute("1")]
public void AppendLiteral(string value);
    [NullableContextAttribute("1")]
private void AppendStringDirect(string value);
    [NullableContextAttribute("1")]
public void AppendFormatted(T value);
    public void AppendFormatted(T value, string format);
    [NullableContextAttribute("1")]
public void AppendFormatted(T value, int alignment);
    public void AppendFormatted(T value, int alignment, string format);
    private void AppendFormatted(IntPtr value);
    private void AppendFormatted(IntPtr value, string format);
    private void AppendFormatted(UIntPtr value);
    private void AppendFormatted(UIntPtr value, string format);
    [NullableContextAttribute("0")]
public void AppendFormatted(ReadOnlySpan`1<char> value);
    [NullableContextAttribute("0")]
public void AppendFormatted(ReadOnlySpan`1<char> value, int alignment, string format);
    public void AppendFormatted(string value);
    private void AppendFormattedSlow(string value);
    public void AppendFormatted(string value, int alignment, string format);
    public void AppendFormatted(object value, int alignment, string format);
    [NullableContextAttribute("1")]
internal static bool HasCustomFormatter(IFormatProvider provider);
    private void AppendCustomFormatter(T value, string format);
    private void AppendOrInsertAlignmentIfNeeded(int startingPos, int alignment);
    private void EnsureCapacityForAdditionalChars(int additionalChars);
    [NullableContextAttribute("1")]
private void GrowThenCopyString(string value);
    [NullableContextAttribute("0")]
private void GrowThenCopySpan(ReadOnlySpan`1<char> value);
    private void Grow(int additionalChars);
    private void Grow();
    private void GrowCore(UInt32 requiredMinCapacity);
}
[AttributeUsageAttribute("1")]
internal class System.Runtime.CompilerServices.DisableRuntimeMarshallingAttribute : Attribute {
}
[NullableContextAttribute("1")]
internal interface System.Runtime.CompilerServices.ICWTEnumerable`1 {
    
public IEnumerable`1<T> SelfEnumerable { get; }
    public abstract virtual IEnumerable`1<T> get_SelfEnumerable();
    public abstract virtual IEnumerator`1<T> GetEnumerator();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("1")]
internal class System.Runtime.CompilerServices.IgnoresAccessChecksToAttribute : Attribute {
    [CompilerGeneratedAttribute]

private string <AssemblyName>k__BackingField;
    
public string AssemblyName { get; }
    public IgnoresAccessChecksToAttribute(string assemblyName);
    [CompilerGeneratedAttribute]
public string get_AssemblyName();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("2048")]
internal class System.Runtime.CompilerServices.InterpolatedStringHandlerArgumentAttribute : Attribute {
    [CompilerGeneratedAttribute]

private String[] <Arguments>k__BackingField;
    
public String[] Arguments { get; }
    public InterpolatedStringHandlerArgumentAttribute(string argument);
    public InterpolatedStringHandlerArgumentAttribute(String[] arguments);
    [CompilerGeneratedAttribute]
public String[] get_Arguments();
}
[AttributeUsageAttribute("12")]
internal class System.Runtime.CompilerServices.InterpolatedStringHandlerAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsByRefLikeAttribute : Attribute {
}
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal static class System.Runtime.CompilerServices.IsExternalInit : object {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsReadOnlyAttribute : Attribute {
}
[NullableContextAttribute("2")]
[DefaultMemberAttribute("Item")]
internal interface System.Runtime.CompilerServices.ITuple {
    
public int Length { get; }
    
public object Item { get; }
    public abstract virtual int get_Length();
    public abstract virtual object get_Item(int index);
}
[AttributeUsageAttribute("64")]
internal class System.Runtime.CompilerServices.ModuleInitializerAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NativeIntegerAttribute : Attribute {
    
public Boolean[] TransformFlags;
    public NativeIntegerAttribute(Boolean[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    
public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    
public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.NullablePublicOnlyAttribute : Attribute {
    
public bool IncludesInternals;
    public NullablePublicOnlyAttribute(bool );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    
public int Version;
    public RefSafetyRulesAttribute(int );
}
internal static class System.Runtime.CompilerServices.Unsafe : object {
    [NonVersionableAttribute]
public static T Read(Void* source);
    [NonVersionableAttribute]
public static T ReadUnaligned(Void* source);
    [NonVersionableAttribute]
public static T ReadUnaligned(Byte& source);
    [NonVersionableAttribute]
public static void Write(Void* destination, T value);
    [NonVersionableAttribute]
public static void WriteUnaligned(Void* destination, T value);
    [NonVersionableAttribute]
public static void WriteUnaligned(Byte& destination, T value);
    [NonVersionableAttribute]
public static void Copy(Void* destination, T& source);
    [NonVersionableAttribute]
public static void Copy(T& destination, Void* source);
    [NonVersionableAttribute]
public static Void* AsPointer(T& value);
    [NonVersionableAttribute]
public static void SkipInit(T& value);
    [NonVersionableAttribute]
public static int SizeOf();
    [NonVersionableAttribute]
public static void CopyBlock(Void* destination, Void* source, UInt32 byteCount);
    [NonVersionableAttribute]
public static void CopyBlock(Byte& destination, Byte& source, UInt32 byteCount);
    [NonVersionableAttribute]
public static void CopyBlockUnaligned(Void* destination, Void* source, UInt32 byteCount);
    [NonVersionableAttribute]
public static void CopyBlockUnaligned(Byte& destination, Byte& source, UInt32 byteCount);
    [NonVersionableAttribute]
public static void InitBlock(Void* startAddress, byte value, UInt32 byteCount);
    [NonVersionableAttribute]
public static void InitBlock(Byte& startAddress, byte value, UInt32 byteCount);
    [NonVersionableAttribute]
public static void InitBlockUnaligned(Void* startAddress, byte value, UInt32 byteCount);
    [NonVersionableAttribute]
public static void InitBlockUnaligned(Byte& startAddress, byte value, UInt32 byteCount);
    [NonVersionableAttribute]
public static T As(object o);
    [NonVersionableAttribute]
public static T& AsRef(Void* source);
    [NonVersionableAttribute]
public static T& AsRef(T& source);
    [NonVersionableAttribute]
public static TTo& As(TFrom& source);
    [NonVersionableAttribute]
public static T& Unbox(object box);
    [NonVersionableAttribute]
public static T& Add(T& source, int elementOffset);
    [NonVersionableAttribute]
public static Void* Add(Void* source, int elementOffset);
    [NonVersionableAttribute]
public static T& Add(T& source, IntPtr elementOffset);
    public static T& Add(T& source, UIntPtr elementOffset);
    [NonVersionableAttribute]
public static T& AddByteOffset(T& source, IntPtr byteOffset);
    public static T& AddByteOffset(T& source, UIntPtr byteOffset);
    [NonVersionableAttribute]
public static T& Subtract(T& source, int elementOffset);
    [NonVersionableAttribute]
public static Void* Subtract(Void* source, int elementOffset);
    [NonVersionableAttribute]
public static T& Subtract(T& source, IntPtr elementOffset);
    public static T& Subtract(T& source, UIntPtr elementOffset);
    [NonVersionableAttribute]
public static T& SubtractByteOffset(T& source, IntPtr byteOffset);
    public static T& SubtractByteOffset(T& source, UIntPtr byteOffset);
    [NonVersionableAttribute]
public static IntPtr ByteOffset(T& origin, T& target);
    [NonVersionableAttribute]
public static bool AreSame(T& left, T& right);
    [NonVersionableAttribute]
public static bool IsAddressGreaterThan(T& left, T& right);
    [NonVersionableAttribute]
public static bool IsAddressLessThan(T& left, T& right);
    [NonVersionableAttribute]
public static bool IsNullRef(T& source);
    [NonVersionableAttribute]
public static T& NullRef();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class System.Runtime.DependentHandle : ValueType {
    
private GCHandle dependentHandle;
    
private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) allocated;
    
public bool IsAllocated { get; }
    
public object Target { get; public set; }
    
public object Dependent { get; public set; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]

public ValueTuple`2<object, object> TargetAndDependent { get; }
    public DependentHandle(object target, object dependent);
    private static GCHandle AllocDepHolder(GCHandle targetHandle, object dependent);
    public bool get_IsAllocated();
    public object get_Target();
    public void set_Target(object value);
    public object get_Dependent();
    public void set_Dependent(object value);
    public ValueTuple`2<object, object> get_TargetAndDependent();
    private DependentHolder UnsafeGetHolder();
    internal object UnsafeGetTarget();
    internal object UnsafeGetTargetAndDependent(Object& dependent);
    internal void UnsafeSetTargetToNull();
    internal void UnsafeSetDependent(object value);
    private void FreeDependentHandle();
    private void Free();
    public sealed virtual void Dispose();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal static class System.Runtime.InteropServices.MarshalEx : object {
    
private static MethodInfo Marshal_SetLastWin32Error_Meth;
    
private static Action`1<int> Marshal_SetLastWin32Error;
    private static MarshalEx();
    public static int GetLastPInvokeError();
    public static void SetLastPInvokeError(int error);
}
internal static class System.Runtime.InteropServices.MemoryMarshal : object {
    [NullableContextAttribute("2")]
public static bool TryGetArray(ReadOnlyMemory`1<T> memory, ArraySegment`1& segment);
    [NullableContextAttribute("2")]
public static bool TryGetMemoryManager(ReadOnlyMemory`1<T> memory, TManager& manager);
    [NullableContextAttribute("2")]
public static bool TryGetMemoryManager(ReadOnlyMemory`1<T> memory, TManager& manager, Int32& start, Int32& length);
    [NullableContextAttribute("1")]
[IteratorStateMachineAttribute("System.Runtime.InteropServices.MemoryMarshal/<ToEnumerable>d__3`1")]
public static IEnumerable`1<T> ToEnumerable(ReadOnlyMemory`1<T> memory);
    public static bool TryGetString(ReadOnlyMemory`1<char> memory, String& text, Int32& start, Int32& length);
    public static T Read(ReadOnlySpan`1<byte> source);
    public static bool TryRead(ReadOnlySpan`1<byte> source, T& value);
    public static void Write(Span`1<byte> destination, T& value);
    public static bool TryWrite(Span`1<byte> destination, T& value);
    [NullableContextAttribute("1")]
public static Memory`1<T> CreateFromPinnedArray(T[] array, int start, int length);
    public static Span`1<byte> AsBytes(Span`1<T> span);
    public static ReadOnlySpan`1<byte> AsBytes(ReadOnlySpan`1<T> span);
    [NullableContextAttribute("2")]
public static Memory`1<T> AsMemory(ReadOnlyMemory`1<T> memory);
    [NullableContextAttribute("1")]
public static T& GetReference(Span`1<T> span);
    [NullableContextAttribute("1")]
public static T& GetReference(ReadOnlySpan`1<T> span);
    public static Span`1<TTo> Cast(Span`1<TFrom> span);
    public static ReadOnlySpan`1<TTo> Cast(ReadOnlySpan`1<TFrom> span);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal static class System.Runtime.InteropServices.SequenceMarshal : object {
    public static bool TryGetReadOnlySequenceSegment(ReadOnlySequence`1<T> sequence, ReadOnlySequenceSegment`1& startSegment, Int32& startIndex, ReadOnlySequenceSegment`1& endSegment, Int32& endIndex);
    public static bool TryGetArray(ReadOnlySequence`1<T> sequence, ArraySegment`1& segment);
    public static bool TryGetReadOnlyMemory(ReadOnlySequence`1<T> sequence, ReadOnlyMemory`1& memory);
    [NullableContextAttribute("0")]
internal static bool TryGetString(ReadOnlySequence`1<char> sequence, String& text, Int32& start, Int32& length);
}
[AttributeUsageAttribute("108")]
internal class System.Runtime.Versioning.NonVersionableAttribute : Attribute {
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class System.SequencePosition : ValueType {
    
private object _object;
    
private int _integer;
    public SequencePosition(object object, int integer);
    [EditorBrowsableAttribute("1")]
public object GetObject();
    [EditorBrowsableAttribute("1")]
public int GetInteger();
    public sealed virtual bool Equals(SequencePosition other);
    [EditorBrowsableAttribute("1")]
public virtual bool Equals(object obj);
    [EditorBrowsableAttribute("1")]
public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
[DebuggerTypeProxyAttribute("System.SpanDebugView`1")]
[DebuggerDisplayAttribute("{ToString(),raw}")]
internal class System.Span`1 : ValueType {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]

private Pinnable`1<T> _pinnable;
    
private IntPtr _byteOffset;
    
private int _length;
    
public int Length { get; }
    
public bool IsEmpty { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]

public static Span`1<T> Empty { get; }
    
public T& Item { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]

internal Pinnable`1<T> Pinnable { get; }
    
internal IntPtr ByteOffset { get; }
    public Span`1(T[] array);
    public Span`1(T[] array, int start, int length);
    [NullableContextAttribute("0")]
[CLSCompliantAttribute("False")]
public Span`1(Void* pointer, int length);
    internal Span`1(Pinnable`1<T> pinnable, IntPtr byteOffset, int length);
    public int get_Length();
    public bool get_IsEmpty();
    public static bool op_Inequality(Span`1<T> left, Span`1<T> right);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Equals() on Span will always throw an exception. Use == instead.")]
[EditorBrowsableAttribute("1")]
public virtual bool Equals(object obj);
    [ObsoleteAttribute("GetHashCode() on Span will always throw an exception.")]
[EditorBrowsableAttribute("1")]
public virtual int GetHashCode();
    public static Span`1<T> op_Implicit(T[] array);
    public static Span`1<T> op_Implicit(ArraySegment`1<T> segment);
    public static Span`1<T> get_Empty();
    [NullableContextAttribute("0")]
public Enumerator<T> GetEnumerator();
    internal static Span`1<T> Create(T[] array, int start);
    public T& get_Item(int index);
    [EditorBrowsableAttribute("1")]
public T& GetPinnableReference();
    public void Clear();
    public void Fill(T value);
    public void CopyTo(Span`1<T> destination);
    public bool TryCopyTo(Span`1<T> destination);
    public static bool op_Equality(Span`1<T> left, Span`1<T> right);
    public static ReadOnlySpan`1<T> op_Implicit(Span`1<T> span);
    public virtual string ToString();
    public Span`1<T> Slice(int start);
    public Span`1<T> Slice(int start, int length);
    public T[] ToArray();
    [EditorBrowsableAttribute("1")]
internal T& DangerousGetPinnableReference();
    internal Pinnable`1<T> get_Pinnable();
    internal IntPtr get_ByteOffset();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class System.SpanDebugView`1 : object {
    
private T[] _array;
    [DebuggerBrowsableAttribute("3")]

public T[] Items { get; }
    public SpanDebugView`1(Span`1<T> span);
    public SpanDebugView`1(ReadOnlySpan`1<T> span);
    public T[] get_Items();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class System.SpanHelpers : object {
    [ExtensionAttribute]
public static int BinarySearch(ReadOnlySpan`1<T> span, TComparable comparable);
    public static int BinarySearch(T& spanStart, int length, TComparable comparable);
    public static int IndexOf(Byte& searchSpace, int searchSpaceLength, Byte& value, int valueLength);
    public static int IndexOfAny(Byte& searchSpace, int searchSpaceLength, Byte& value, int valueLength);
    public static int LastIndexOfAny(Byte& searchSpace, int searchSpaceLength, Byte& value, int valueLength);
    public static int IndexOf(Byte& searchSpace, byte value, int length);
    public static int LastIndexOf(Byte& searchSpace, int searchSpaceLength, Byte& value, int valueLength);
    public static int LastIndexOf(Byte& searchSpace, byte value, int length);
    public static int IndexOfAny(Byte& searchSpace, byte value0, byte value1, int length);
    public static int IndexOfAny(Byte& searchSpace, byte value0, byte value1, byte value2, int length);
    public static int LastIndexOfAny(Byte& searchSpace, byte value0, byte value1, int length);
    public static int LastIndexOfAny(Byte& searchSpace, byte value0, byte value1, byte value2, int length);
    public static bool SequenceEqual(Byte& first, Byte& second, UIntPtr length);
    public static int SequenceCompareTo(Byte& first, int firstLength, Byte& second, int secondLength);
    public static int SequenceCompareTo(Char& first, int firstLength, Char& second, int secondLength);
    public static int IndexOf(Char& searchSpace, char value, int length);
    public static int LastIndexOf(Char& searchSpace, char value, int length);
    public static void CopyTo(T& dst, int dstLength, T& src, int srcLength);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static IntPtr Add(IntPtr start, int index);
    [NullableContextAttribute("2")]
public static bool IsReferenceOrContainsReferences();
    private static bool IsReferenceOrContainsReferencesCore(Type type);
    [NullableContextAttribute("0")]
public static void ClearLessThanPointerSized(Byte* ptr, UIntPtr byteLength);
    public static void ClearLessThanPointerSized(Byte& b, UIntPtr byteLength);
    public static void ClearPointerSizedWithoutReferences(Byte& b, UIntPtr byteLength);
    public static void ClearPointerSizedWithReferences(IntPtr& ip, UIntPtr pointerSizeLength);
    [ExtensionAttribute]
private static bool LessThanEqual(IntPtr index, UIntPtr length);
    public static int IndexOf(T& searchSpace, int searchSpaceLength, T& value, int valueLength);
    public static int IndexOf(T& searchSpace, T value, int length);
    public static int IndexOfAny(T& searchSpace, T value0, T value1, int length);
    public static int IndexOfAny(T& searchSpace, T value0, T value1, T value2, int length);
    public static int IndexOfAny(T& searchSpace, int searchSpaceLength, T& value, int valueLength);
    public static int LastIndexOf(T& searchSpace, int searchSpaceLength, T& value, int valueLength);
    public static int LastIndexOf(T& searchSpace, T value, int length);
    public static int LastIndexOfAny(T& searchSpace, T value0, T value1, int length);
    public static int LastIndexOfAny(T& searchSpace, T value0, T value1, T value2, int length);
    public static int LastIndexOfAny(T& searchSpace, int searchSpaceLength, T& value, int valueLength);
    public static bool SequenceEqual(T& first, T& second, int length);
    public static int SequenceCompareTo(T& first, int firstLength, T& second, int secondLength);
}
internal static class System.SR : object {
    
private static ResourceManager s_resourceManager;
    [CompilerGeneratedAttribute]

private static Type <ResourceType>k__BackingField;
    
private static ResourceManager ResourceManager { get; }
    
internal static Type ResourceType { get; }
    
internal static string ArgumentException_ValueTupleIncorrectType { get; }
    
internal static string ArgumentException_ValueTupleLastArgumentNotAValueTuple { get; }
    private static SR();
    private static ResourceManager get_ResourceManager();
    private static bool UsingResourceKeys();
    internal static string GetResourceString(string resourceKey, string defaultString);
    internal static string Format(string resourceFormat, Object[] args);
    internal static string Format(string resourceFormat, object p1);
    internal static string Format(string resourceFormat, object p1, object p2);
    internal static string Format(string resourceFormat, object p1, object p2, object p3);
    [CompilerGeneratedAttribute]
internal static Type get_ResourceType();
    internal static string get_ArgumentException_ValueTupleIncorrectType();
    internal static string get_ArgumentException_ValueTupleLastArgumentNotAValueTuple();
}
internal static class System.string2 : object {
    [NullableContextAttribute("2")]
public static bool IsNullOrEmpty(string value);
}
internal static class System.StringComparerEx : object {
    [NullableContextAttribute("1")]
public static StringComparer FromComparison(StringComparison comparisonType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class System.StringExtensions : object {
    [ExtensionAttribute]
public static string Replace(string self, string oldValue, string newValue, StringComparison comparison);
    [ExtensionAttribute]
public static bool Contains(string self, string value, StringComparison comparison);
    [ExtensionAttribute]
public static bool Contains(string self, char value, StringComparison comparison);
    [ExtensionAttribute]
public static int GetHashCode(string self, StringComparison comparison);
    [ExtensionAttribute]
public static int IndexOf(string self, char value, StringComparison comparison);
}
[ExtensionAttribute]
internal static class System.Text.StringBuilderExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static StringBuilder Clear(StringBuilder builder);
}
internal static class System.Threading.MonitorEx : object {
    [NullableContextAttribute("1")]
public static void Enter(object obj, Boolean& lockTaken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class System.ThrowHelper : object {
    [NullableContextAttribute("2")]
internal static void ThrowIfArgumentNull(object obj, ExceptionArgument argument);
    [NullableContextAttribute("2")]
internal static void ThrowIfArgumentNull(object obj, string argument, string message);
    [<22576685-8ec8-4022-94e7-b5a630de7c65>DoesNotReturnAttribute]
internal static void ThrowArgumentNullException(ExceptionArgument argument);
    [<22576685-8ec8-4022-94e7-b5a630de7c65>DoesNotReturnAttribute]
internal static void ThrowArgumentNullException(string argument, string message);
    private static Exception CreateArgumentNullException(ExceptionArgument argument);
    private static Exception CreateArgumentNullException(string argument, string message);
    [<22576685-8ec8-4022-94e7-b5a630de7c65>DoesNotReturnAttribute]
internal static void ThrowArrayTypeMismatchException();
    private static Exception CreateArrayTypeMismatchException();
    [<22576685-8ec8-4022-94e7-b5a630de7c65>DoesNotReturnAttribute]
internal static void ThrowArgumentException_InvalidTypeWithPointersNotSupported(Type type);
    private static Exception CreateArgumentException_InvalidTypeWithPointersNotSupported(Type type);
    [<22576685-8ec8-4022-94e7-b5a630de7c65>DoesNotReturnAttribute]
internal static void ThrowArgumentException_DestinationTooShort();
    private static Exception CreateArgumentException_DestinationTooShort();
    [<22576685-8ec8-4022-94e7-b5a630de7c65>DoesNotReturnAttribute]
internal static void ThrowArgumentException(string message, string argument);
    private static Exception CreateArgumentException(string message, string argument);
    [<22576685-8ec8-4022-94e7-b5a630de7c65>DoesNotReturnAttribute]
internal static void ThrowIndexOutOfRangeException();
    private static Exception CreateIndexOutOfRangeException();
    [<22576685-8ec8-4022-94e7-b5a630de7c65>DoesNotReturnAttribute]
internal static void ThrowArgumentOutOfRangeException();
    private static Exception CreateArgumentOutOfRangeException();
    [<22576685-8ec8-4022-94e7-b5a630de7c65>DoesNotReturnAttribute]
internal static void ThrowArgumentOutOfRangeException(ExceptionArgument argument);
    private static Exception CreateArgumentOutOfRangeException(ExceptionArgument argument);
    [<22576685-8ec8-4022-94e7-b5a630de7c65>DoesNotReturnAttribute]
internal static void ThrowArgumentOutOfRangeException_PrecisionTooLarge();
    private static Exception CreateArgumentOutOfRangeException_PrecisionTooLarge();
    [<22576685-8ec8-4022-94e7-b5a630de7c65>DoesNotReturnAttribute]
internal static void ThrowArgumentOutOfRangeException_SymbolDoesNotFit();
    private static Exception CreateArgumentOutOfRangeException_SymbolDoesNotFit();
    [<22576685-8ec8-4022-94e7-b5a630de7c65>DoesNotReturnAttribute]
internal static void ThrowInvalidOperationException();
    private static Exception CreateInvalidOperationException();
    [<22576685-8ec8-4022-94e7-b5a630de7c65>DoesNotReturnAttribute]
internal static void ThrowInvalidOperationException_OutstandingReferences();
    private static Exception CreateInvalidOperationException_OutstandingReferences();
    [<22576685-8ec8-4022-94e7-b5a630de7c65>DoesNotReturnAttribute]
internal static void ThrowInvalidOperationException_UnexpectedSegmentType();
    private static Exception CreateInvalidOperationException_UnexpectedSegmentType();
    [<22576685-8ec8-4022-94e7-b5a630de7c65>DoesNotReturnAttribute]
internal static void ThrowInvalidOperationException_EndPositionNotReached();
    private static Exception CreateInvalidOperationException_EndPositionNotReached();
    [<22576685-8ec8-4022-94e7-b5a630de7c65>DoesNotReturnAttribute]
internal static void ThrowArgumentOutOfRangeException_PositionOutOfRange();
    private static Exception CreateArgumentOutOfRangeException_PositionOutOfRange();
    [<22576685-8ec8-4022-94e7-b5a630de7c65>DoesNotReturnAttribute]
internal static void ThrowArgumentOutOfRangeException_OffsetOutOfRange();
    private static Exception CreateArgumentOutOfRangeException_OffsetOutOfRange();
    [<22576685-8ec8-4022-94e7-b5a630de7c65>DoesNotReturnAttribute]
internal static void ThrowObjectDisposedException_ArrayMemoryPoolBuffer();
    private static Exception CreateObjectDisposedException_ArrayMemoryPoolBuffer();
    [<22576685-8ec8-4022-94e7-b5a630de7c65>DoesNotReturnAttribute]
internal static void ThrowFormatException_BadFormatSpecifier();
    private static Exception CreateFormatException_BadFormatSpecifier();
    [<22576685-8ec8-4022-94e7-b5a630de7c65>DoesNotReturnAttribute]
internal static void ThrowArgumentException_OverlapAlignmentMismatch();
    private static Exception CreateArgumentException_OverlapAlignmentMismatch();
    [NullableContextAttribute("2")]
[<22576685-8ec8-4022-94e7-b5a630de7c65>DoesNotReturnAttribute]
internal static void ThrowNotSupportedException(string msg);
    private static Exception CreateThrowNotSupportedException(string msg);
    [<22576685-8ec8-4022-94e7-b5a630de7c65>DoesNotReturnAttribute]
internal static void ThrowKeyNullException();
    [<22576685-8ec8-4022-94e7-b5a630de7c65>DoesNotReturnAttribute]
internal static void ThrowValueNullException();
    private static Exception CreateThrowValueNullException();
    [<22576685-8ec8-4022-94e7-b5a630de7c65>DoesNotReturnAttribute]
internal static void ThrowOutOfMemoryException();
    private static Exception CreateOutOfMemoryException();
    public static bool TryFormatThrowFormatException(Int32& bytesWritten);
    public static bool TryParseThrowFormatException(T& value, Int32& bytesConsumed);
    [NullableContextAttribute("2")]
[<22576685-8ec8-4022-94e7-b5a630de7c65>DoesNotReturnAttribute]
public static void ThrowArgumentValidationException(ReadOnlySequenceSegment`1<T> startSegment, int startIndex, ReadOnlySequenceSegment`1<T> endSegment);
    private static Exception CreateArgumentValidationException(ReadOnlySequenceSegment`1<T> startSegment, int startIndex, ReadOnlySequenceSegment`1<T> endSegment);
    [NullableContextAttribute("2")]
[<22576685-8ec8-4022-94e7-b5a630de7c65>DoesNotReturnAttribute]
public static void ThrowArgumentValidationException(Array array, int start);
    private static Exception CreateArgumentValidationException(Array array, int start);
    [<22576685-8ec8-4022-94e7-b5a630de7c65>DoesNotReturnAttribute]
internal static void ThrowArgumentException_TupleIncorrectType(object other);
    [<22576685-8ec8-4022-94e7-b5a630de7c65>DoesNotReturnAttribute]
public static void ThrowStartOrEndArgumentValidationException(long start);
    private static Exception CreateStartOrEndArgumentValidationException(long start);
}
[ExtensionAttribute]
internal static class System.TypeExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static bool IsByRefLike(Type type);
}
