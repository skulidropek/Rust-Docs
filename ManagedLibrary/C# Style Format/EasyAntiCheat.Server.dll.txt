internal EasyAntiCheat.Server.Cerberus.Cerberus`1 : object {
private EasyAntiCheatServer`1<TClient> EACServer
internal void .ctor(IntPtr NativeInstance, EasyAntiCheatServer`1<TClient> EACServer)
public void BeginFrame()
public void EndFrame()
public void LogGameRoundStart(string MapName)
public void LogGameRoundEnd(int WinningTeamID)
public void LogPlayerSpawn(TClient Player, int TeamID, int CharacterID)
public void LogPlayerDespawn(TClient Player)
public void LogPlayerKill(TClient PlayerVictim, TClient PlayerAttacker)
public void LogPlayerRevive(TClient PlayerRevived, TClient PlayerReviving)
public void LogPlayerTick(TClient Player, PlayerTick EventParams)
public void LogPlayerUseWeapon(TClient Player, PlayerUseWeapon EventParams)
public void LogPlayerTakeDamage(TClient PlayerVictim, TClient PlayerAttacker, PlayerTakeDamage EventParams)
internal void SetNativeInstance(IntPtr NativeInstance)
}
public EasyAntiCheat.Server.Cerberus.ICerberus`1 {
public void BeginFrame()
public void EndFrame()
public void LogGameRoundStart(string MapName)
public void LogGameRoundEnd(int WinningTeamID)
public void LogPlayerSpawn(TClient Player, int TeamID, int CharacterID)
public void LogPlayerDespawn(TClient Player)
public void LogPlayerKill(TClient ClientVictim, TClient ClientKiller)
public void LogPlayerRevive(TClient PlayerRevived, TClient PlayerReviving)
public void LogPlayerTick(TClient Player, PlayerTick EventParams)
public void LogPlayerUseWeapon(TClient Player, PlayerUseWeapon EventParams)
public void LogPlayerTakeDamage(TClient PlayerVictim, TClient PlayerAttacker, PlayerTakeDamage EventParams)
}
public EasyAntiCheat.Server.Cerberus.PlayerTakeDamage : ValueType {
public Vector3 VictimPosition
public Vector3 VictimViewAngles
public Vector3 AttackerPosition
public Vector3 AttackerViewAngles
public int AttackerFieldOfView
public int WeaponID
public int HitBoneID
public int DamageTaken
public PlayerTakeDamageFlags DamageFlags
}
public EasyAntiCheat.Server.Cerberus.PlayerTakeDamageFlags : Enum {
public int value__
public PlayerTakeDamageFlags PlayerTakeDamageNormalHit
public PlayerTakeDamageFlags PlayerTakeDamageCriticalHit
}
public EasyAntiCheat.Server.Cerberus.PlayerTick : ValueType {
public Vector3 Position
public Vector3 ViewAngles
public int Health
public PlayerTickFlags TickFlags
}
public EasyAntiCheat.Server.Cerberus.PlayerTickFlags : Enum {
public int value__
public PlayerTickFlags PlayerTickNone
public PlayerTickFlags PlayerTickCrouched
public PlayerTickFlags PlayerTickProned
public PlayerTickFlags PlayerTickMounted
public PlayerTickFlags PlayerTickDormant
public PlayerTickFlags PlayerTickSwimming
public PlayerTickFlags PlayerTickAirborne
public PlayerTickFlags PlayerTickClimbingLadder
}
public EasyAntiCheat.Server.Cerberus.PlayerUseWeapon : ValueType {
public Vector3 Position
public Vector3 ViewAngles
public int FieldOfView
public int WeaponID
}
public EasyAntiCheat.Server.Cerberus.Vector3 : ValueType {
public float X
public float Y
public float Z
public void .ctor(float x, float y, float z)
}
public EasyAntiCheat.Server.ClientAuth.ClientAuth : object {
public void Dispose()
public void GenerateChallenge(Byte[] ChallengeBuffer)
public bool VerifyChallenge(Byte[] ServerChallenge, Byte[] ClientResponse)
}
internal EasyAntiCheat.Server.ClientAuth.NativeClientAuth : object {
private string DllFileName
private string InterfaceVersion
private IntPtr Instance
private IntPtr dotCreateClientAuth(string InterfaceVersion)
private void dotInitialize(IntPtr Instance)
private void dotDestroy(IntPtr Instance)
private void dotGenerateChallenge(IntPtr Instance, Byte[] ChallengeBuffer)
private bool dotVerifyChallenge(IntPtr Instance, Byte[] ServerChallenge, Byte[] ClientResponse)
public void Initialize()
public void Dispose()
public void GenerateChallenge(Byte[] ChallengeBuffer)
public bool ServerVerifyChallenge(Byte[] ServerChallenge, Byte[] ClientResponse)
}
public EasyAntiCheat.Server.ClientStatus : Enum {
public int value__
public ClientStatus ClientDisconnected
public ClientStatus ClientAuthenticationFailed
public ClientStatus ClientAuthenticatedLocal
public ClientStatus ClientBanned
public ClientStatus ClientViolation
public ClientStatus ClientAuthenticatedRemote
}
public EasyAntiCheat.Server.Hydra.Client : ValueType {
private UInt32 <ClientID>k__BackingField
public UInt32 ClientID
internal void .ctor(UInt32 clientID)
public bool Equals(Client other)
public int GetHashCode()
public UInt32 get_ClientID()
private void set_ClientID(UInt32 value)
}
public EasyAntiCheat.Server.Hydra.ClientStatusUpdate`1 : object {
private Nullable`1<DateTime> TimeBanExpires
private TClient <Client>k__BackingField
private string <Message>k__BackingField
private ClientStatus <Status>k__BackingField
private DateTime epochTimeStartUTC
public TClient Client
public string Message
public bool RequiresKick
public ClientStatus Status
public TClient get_Client()
private void set_Client(TClient value)
public string get_Message()
private void set_Message(string value)
public bool get_RequiresKick()
public ClientStatus get_Status()
private void set_Status(ClientStatus value)
internal void .ctor(TClient client, ClientStatus clientStatus, long timeBanExpiresEpochSeconds, string message)
public bool IsBanned(Nullable`1& timeBanExpires)
public string ToString()
private Nullable`1<DateTime> getTimeBanExpiresValue(long timeBanExpiresEpochSeconds)
}
public EasyAntiCheat.Server.Hydra.EasyAntiCheatServer`1 : object {
private ClientStatusHandler<TClient> _ClientStatusHandler
internal IDictionary`2<TClient, IntPtr> MapClientToInternalObject
private IDictionary`2<IntPtr, TClient> MapInternalObjectToClient
private IntPtr UniqueClientObjectCounter
private Cerberus`1<TClient> _Cerberus
private NetProtect`1<TClient> _NetProtect
public ICerberus`1<TClient> Cerberus
public INetProtect`1<TClient> NetProtect
public void .ctor(ClientStatusHandler<TClient> clientStatusHandler, string serverName)
public void .ctor(ClientStatusHandler<TClient> clientStatusHandler, int registerTimeout, string serverName)
internal void .ctor(ClientStatusHandler<TClient> clientStatusHandler, ServerConfiguration serverConfiguration, Nullable`1<int> gameID)
public ICerberus`1<TClient> get_Cerberus()
public INetProtect`1<TClient> get_NetProtect()
public void Dispose()
public void HandleClientUpdates()
public void RegisterClient(TClient client, string playerGuid, string playerIP)
public void RegisterClient(TClient client, string playerGuid, string playerIP, string ownerGuid)
public void RegisterClient(TClient client, string playerGuid, string playerIP, string ownerGuid, string playerName, PlayerRegisterFlags flags)
public Client GenerateCompatibilityClient()
public void UnregisterClient(TClient client)
public bool PopNetworkMessage(TClient& client, Byte[]& messageBuffer, Int32& messageLength)
public bool PopNetworkMessage(TClient desiredClient, Byte[]& messageBuffer, Int32& messageLength)
public void SetMaxAllowedMessageLength(TClient client, int maxMessageLength)
public void PushNetworkMessage(TClient client, Byte[] messageBuffer, int messageLength)
public void SetClientNetworkState(TClient client, bool networkActive)
public void SetGameSessionId(string gameSessionId)
private IntPtr GetNextClientObject()
}
internal EasyAntiCheat.Server.Hydra.NativeCerberus : object {
private string DllFileName
private IntPtr Instance
private void dotBeginFrame(IntPtr Instance)
private void dotEndFrame(IntPtr Instance)
private void dotGameRoundStart(IntPtr Instance, string MapName)
private void dotGameRoundEnd(IntPtr Instance, UInt32 WinningTeamID)
private void dotPlayerSpawn(IntPtr Instance, IntPtr Player, UInt32 TeamID, UInt32 CharacterID)
private void dotPlayerDespawn(IntPtr Instance, IntPtr Player, UInt32 IsPlayerDeath, IntPtr PlayerAttacker)
private void dotPlayerRevive(IntPtr Instance, IntPtr PlayerRevived, IntPtr PlayerReviving)
private void dotPlayerTick(IntPtr Instance, IntPtr Player, float PositionX, float PositionY, float PositionZ, float ViewAnglesX, float ViewAnglesY, float ViewAnglesZ, UInt32 Health, UInt32 TickFlags)
private void dotPlayerUseWeapon(IntPtr Instance, IntPtr Player, float PositionX, float PositionY, float PositionZ, float ViewAnglesX, float ViewAnglesY, float ViewAnglesZ, UInt32 FieldOfView, UInt32 WeaponID)
private void dotPlayerTakeDamage(IntPtr Instance, IntPtr PlayerVictim, float VictimPositionX, float VictimPositionY, float VictimPositionZ, float VictimViewAnglesX, float VictimViewAnglesY, float VictimViewAnglesZ, IntPtr PlayerAttacker, float AttackerPositionX, float AttackerPositionY, float AttackerPositionZ, float AttackerViewAnglesX, float AttackerViewAnglesY, float AttackerViewAnglesZ, UInt32 AttackerFieldOfView, UInt32 WeaponID, UInt32 HitBoneID, UInt32 DamageTaken, UInt32 DamageFlags)
internal void SetInstance(IntPtr CerberusInstance)
internal void BeginFrame()
internal void EndFrame()
internal void LogGameRoundStart(string MapName)
internal void LogGameRoundEnd(int WinningTeamID)
internal void LogPlayerSpawn(IntPtr PlayerObject, int TeamID, int CharacterID)
internal void LogPlayerDespawn(IntPtr PlayerObject)
internal void LogPlayerKill(IntPtr PlayerVictim, IntPtr PlayerAttacker)
internal void LogPlayerRevive(IntPtr PlayerRevived, IntPtr PlayerReviving)
internal void LogPlayerTick(IntPtr PlayerObject, PlayerTick EventParams)
internal void LogPlayerUseWeapon(IntPtr PlayerObject, PlayerUseWeapon EventParams)
internal void LogPlayerTakeDamage(IntPtr PlayerVictim, IntPtr PlayerAttacker, PlayerTakeDamage EventParams)
}
internal EasyAntiCheat.Server.Hydra.NativeModule : object {
private string DllFileName
private string InterfaceVersion
private IntPtr Instance
private Byte[] StaticMsgBuf
private LogEventHandler onLogEvent
private IntPtr dotCreateGameServer(string InterfaceVersion)
private bool dotInitialize(IntPtr Instance, UInt32 RegisterTimeout, string ServerName)
private bool dotInitializeWithGameID(IntPtr Instance, UInt32 GameID, UInt32 RegisterTimeout, string ServerName)
private void dotDestroy(IntPtr Instance)
private bool dotRegisterClient(IntPtr Instance, IntPtr ClientObject, string PlayerGUID, string PlayerIP, string OwnerGUID, string PlayerName, UInt32 Flags)
private UInt32 dotGenerateCompatibilityClientID(IntPtr Instance)
private void dotUnregisterClient(IntPtr Instance, IntPtr ClientObject)
private IntPtr dotGetNextClientUpdate(IntPtr Instance, IntPtr ClientObject, Byte* ClientUpdate)
private IntPtr dotPopNetworkMessage(IntPtr Instance, IntPtr ClientObject, IntPtr& MessageBuffer, UInt32& MessageLength)
private void dotSetMaxAllowedMessageLength(IntPtr Instance, IntPtr ClientObject, UInt32 MaxMessageLength)
private void dotPushNetworkMessage(IntPtr Instance, IntPtr ClientObject, Byte[] MessageBuffer, UInt32 MessageLength)
private void dotSetLogCallback(IntPtr Instance, LogEventHandler LogCallback, LogLevel LogLevel)
private IntPtr dotCerberus(IntPtr Instance)
private IntPtr dotNetProtect(IntPtr Instance)
private void dotSetClientNetworkState(IntPtr Instance, IntPtr ClientObject, bool NetworkActive)
private void dotSetGameSessionId(IntPtr Instance, string gameSessionId)
public bool Initialize(ServerConfiguration config)
public bool InitializeWithGameID(int GameID, ServerConfiguration config)
public void Unload()
public bool RegisterClient(IntPtr ClientObject, string PlayerGUID, string PlayerIP, string OwnerGUID, string PlayerName, PlayerRegisterFlags Flags)
public UInt32 GenerateCompatibilityClientID()
public void UnregisterClient(IntPtr ClientObject)
public IntPtr GetNextClientUpdate(IntPtr ClientObject, ClientUpdate& Msg)
public IntPtr PopNetworkMessage(IntPtr ClientObject, Byte[]& MessageBuffer, Int32& MessageLength)
public void SetMaxAllowedMessageLength(IntPtr ClientObject, int MaxMessageLength)
public void PushNetworkMessage(IntPtr ClientObject, Byte[] MessageBuffer, int MessageLength)
public IntPtr Cerberus()
public IntPtr NetProtect()
public void SetClientNetworkState(IntPtr ClientObject, bool NetworkActive)
public void SetGameSessionId(string gameSessionId)
private void OnLogEvent(LogLevel LogLevel, string Message)
}
internal EasyAntiCheat.Server.Hydra.NativeNetProtect : object {
private string DllFileName
private IntPtr Instance
private UInt32 dotProtectMessage(IntPtr Instance, IntPtr ClientObject, Byte[] Input, UInt32 InputLength, Byte[] Output, UInt32& OutputLength)
private UInt32 dotProtectMessage_RawPtr(IntPtr Instance, IntPtr ClientObject, IntPtr Input, UInt32 InputLength, IntPtr Output, UInt32& OutputLength)
private UInt32 dotUnprotectMessage(IntPtr Instance, IntPtr ClientObject, Byte[] Input, UInt32 InputLength, Byte[] Output, UInt32& OutputLength)
private UInt32 dotUnprotectMessage_RawPtr(IntPtr Instance, IntPtr ClientObject, IntPtr Input, UInt32 InputLength, IntPtr Output, UInt32& OutputLength)
private UInt32 dotGetProtectMessageOutputLength(IntPtr Instance, UInt32 InputLength)
internal void SetInstance(IntPtr NetProtectInstance)
public bool ProtectMessage(IntPtr ClientObject, MemoryStream Input, MemoryStream Output)
public bool ProtectMessage(IntPtr ClientObject, MemoryStream Input, long InputOffset, MemoryStream Output, long OutputOffset)
public bool UnprotectMessage(IntPtr ClientObject, MemoryStream Input, MemoryStream Output)
public bool UnprotectMessage(IntPtr ClientObject, MemoryStream Input, long InputOffset, MemoryStream Output, long OutputOffset)
}
public EasyAntiCheat.Server.Hydra.NetProtect.INetProtect`1 {
public bool ProtectMessage(TClient Client, MemoryStream Input, MemoryStream Output)
public bool ProtectMessage(TClient Client, MemoryStream Input, long InputOffset, MemoryStream Output, long OutputOffset)
public bool UnprotectMessage(TClient Client, MemoryStream Input, MemoryStream Output)
public bool UnprotectMessage(TClient Client, MemoryStream Input, long InputOffset, MemoryStream Output, long OutputOffset)
}
internal EasyAntiCheat.Server.Hydra.NetProtect.NetProtect`1 : object {
private EasyAntiCheatServer`1<TClient> ServerInstance
public void .ctor(IntPtr NetProtectInstance, EasyAntiCheatServer`1<TClient> EACServerInstance)
public bool ProtectMessage(TClient Client, MemoryStream Input, MemoryStream Output)
public bool ProtectMessage(TClient Client, MemoryStream Input, long InputOffset, MemoryStream Output, long OutputOffset)
public bool UnprotectMessage(TClient Client, MemoryStream Input, MemoryStream Output)
public bool UnprotectMessage(TClient Client, MemoryStream Input, long InputOffset, MemoryStream Output, long OutputOffset)
}
public EasyAntiCheat.Server.Legacy.Client : ValueType {
private string <OwnerGuid>k__BackingField
private string <PlayerGuid>k__BackingField
private UserToken <Token>k__BackingField
public string OwnerGuid
public string PlayerGuid
public UserToken Token
internal void .ctor(Byte[] token, string playerGuid, string ownerGuid)
public string get_OwnerGuid()
private void set_OwnerGuid(string value)
public string get_PlayerGuid()
private void set_PlayerGuid(string value)
public UserToken get_Token()
private void set_Token(UserToken value)
}
public EasyAntiCheat.Server.Legacy.ClientStatusHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(ClientStatusUpdate userStatus)
public IAsyncResult BeginInvoke(ClientStatusUpdate userStatus, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public EasyAntiCheat.Server.Legacy.ClientStatusUpdate : object {
private Nullable`1<DateTime> timeBanExpires
private Client <Client>k__BackingField
private string <Message>k__BackingField
private ClientStatus <Status>k__BackingField
public Client Client
public string Message
public bool RequiresKick
public ClientStatus Status
public Client get_Client()
private void set_Client(Client value)
public string get_Message()
private void set_Message(string value)
public bool get_RequiresKick()
public ClientStatus get_Status()
private void set_Status(ClientStatus value)
internal void .ctor(Client client, ClientStatus clientStatus, Nullable`1<DateTime> timeBanExpires, string message)
public bool IsBanned(Nullable`1& timeBanExpires)
public string ToString()
}
public EasyAntiCheat.Server.Legacy.EasyAntiCheatServer : object {
private Scout _Scout
private ClientAuth _ClientAuth
public Scout Scout
public ClientAuth ClientAuth
public void .ctor(string serverName)
internal void .ctor(ServerConfiguration serverConfiguration, Nullable`1<int> gameID)
public Scout get_Scout()
public ClientAuth get_ClientAuth()
public void Dispose()
public void HandleUserUpdates(ClientStatusHandler handleStatus)
public void RegisterUser(Byte[] token, string playerGuid)
public void RegisterUser(Byte[] token, string playerGuid, string ownerGuid)
public void RegisterUser(Byte[] token, string playerGuid, string ownerGuid, string playerName, PlayerRegisterFlags flags)
public void UnregisterUser(Byte[] token)
}
internal EasyAntiCheat.Server.Legacy.NativeModule : object {
private string DllFileName
private string InterfaceVersion
private IntPtr Instance
private LogEventHandler onLogEvent
private IntPtr dotCreateGameServer(string InterfaceVersion)
private bool dotInitialize(IntPtr Instance, UInt32 RegisterTimeout, string ServerName)
private bool dotInitializeWithGameID(IntPtr Instance, UInt32 GameID, UInt32 RegisterTimeout, string ServerName)
private void dotDestroy(IntPtr Instance)
private void dotRegisterClient(IntPtr Instance, Byte[] Token, UInt32 SizeOfToken, string PlayerGUID, string OwnerGUID, string PlayerName, UInt32 Flags)
private void dotUnregisterClient(IntPtr Instance, Byte[] Token, UInt32 SizeOfToken)
private bool dotGetNextClientUpdate(IntPtr Instance, EAC_CLIENTUPDATE& Msg)
private void dotSetLogCallback(IntPtr Instance, LogEventHandler LogCallback, LogLevel LogLevel)
public bool Initialize(ServerConfiguration config)
public bool InitializeWithGameID(int GameID, ServerConfiguration config)
public void Unload()
public void RegisterClient(Byte[] Token, string PlayerGUID, string OwnerGUID, string PlayerName, PlayerRegisterFlags Flags)
public void UnregisterClient(Byte[] Token)
public bool GetNextClientUpdate(EAC_CLIENTUPDATE& Msg)
private void OnLogEvent(LogLevel LogLevel, string Message)
}
internal EasyAntiCheat.Server.Legacy.Protocol.EpochTime : ValueType {
private DateTime Epoch
private long _millisecondsFromEpoch
public void .ctor(long millisecondsFromEpoch)
public void .ctor(DateTime dateTime)
public long op_Explicit(EpochTime epochTime)
public EpochTime op_Explicit(long millisecondsFromEpoch)
public DateTime op_Implicit(EpochTime epochTime)
public EpochTime op_Implicit(DateTime dateTime)
public long GetTimeInMillis()
}
public EasyAntiCheat.Server.Legacy.Protocol.UserToken : object {
private Random random
internal Byte[] Token
internal void .ctor(Byte[] token)
public Byte[] Generate()
public Byte[] op_Implicit(UserToken token)
public UserToken op_Implicit(Byte[] token)
public int GetHashCode()
public string ToString()
}
public EasyAntiCheat.Server.Log : object {
private LogWriterDelegate doWrite
private StringBuilder stringBuilder
private Mutex stringBuilderMutex
private LogLevel <Level>k__BackingField
private string <Prefix>k__BackingField
private string <TimestampFormat>k__BackingField
public LogLevel Level
public string Prefix
public string TimestampFormat
public LogLevel get_Level()
public void set_Level(LogLevel value)
public string get_Prefix()
public void set_Prefix(string value)
public string get_TimestampFormat()
public void set_TimestampFormat(string value)
public void SetOut(TextWriter writer)
public void SetOut(LogMessageWriterDelegate doWrite)
public void SetOut(LogWriterDelegate doWrite)
internal void WriteLine(LogLevel logLevel, string message)
internal void WriteException(LogLevel logLevel, string message, Exception e, bool includeStack)
}
public EasyAntiCheat.Server.LogLevel : Enum {
public UInt32 value__
public LogLevel NoLogging
public LogLevel Error
public LogLevel Warning
public LogLevel Info
public LogLevel Verbose
public LogLevel VeryVerbose
}
public EasyAntiCheat.Server.LogMessageWriterDelegate : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(string message)
public IAsyncResult BeginInvoke(string message, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public EasyAntiCheat.Server.LogWriterDelegate : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(LogLevel logLevel, string message)
public IAsyncResult BeginInvoke(LogLevel logLevel, string message, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public EasyAntiCheat.Server.PlayerRegisterFlags : Enum {
public int value__
public PlayerRegisterFlags PlayerRegisterFlagNone
public PlayerRegisterFlags PlayerRegisterFlagAdmin
public PlayerRegisterFlags PlayerRegisterFlagMouseKeyboardControl
public PlayerRegisterFlags PlayerRegisterFlagGamepadControl
public PlayerRegisterFlags PlayerRegisterFlagTouchControl
public PlayerRegisterFlags PlayerRegisterFlagXBox
public PlayerRegisterFlags PlayerRegisterFlagPlaystation
public PlayerRegisterFlags PlayerRegisterFlagiOS
public PlayerRegisterFlags PlayerRegisterFlagAndroid
}
public EasyAntiCheat.Server.Scout.InvalidPlayerStateReportCategory : Enum {
public int value__
public InvalidPlayerStateReportCategory PlayerReportCheating
public InvalidPlayerStateReportCategory PlayerReportExploiting
public InvalidPlayerStateReportCategory PlayerReportProfile
public InvalidPlayerStateReportCategory PlayerReportVerbalAbuse
public InvalidPlayerStateReportCategory PlayerReportScamming
public InvalidPlayerStateReportCategory PlayerReportSpamming
public InvalidPlayerStateReportCategory PlayerReportOther
}
public EasyAntiCheat.Server.Scout.KickReasonCategory : Enum {
public int value__
public KickReasonCategory KickReasonInvalid
public KickReasonCategory KickReasonCheating
public KickReasonCategory KickReasonAdmin
public KickReasonCategory KickReasonEAC
public KickReasonCategory KickReasonOther
}
internal EasyAntiCheat.Server.Scout.NativeScout : object {
private string DllFileName
private string InterfaceVersion
private IntPtr Instance
private IntPtr dotCreateScout(string InterfaceVersion)
private void dotInitialize(IntPtr Instance)
private void dotDestroy(IntPtr Instance)
private void dotSendPlayerReport(IntPtr Instance, string ReportedPlayerGUID, string ReportingPlayerGUID, UInt32 ReportCategoryID, string ReportDescription)
private void dotSendKickReport(IntPtr Instance, string KickPlayerID, string KickDescription, UInt32 KickCategoryID)
private void dotSendInvalidPlayerStateReport(IntPtr Instance, string PlayerGUID, UInt32 InvalidPlayerStateCategory, string Report)
public void Initialize()
public void Unload()
public void SendPlayerReport(string ReportedPlayerGUID, string ReportingPlayerGUID, PlayerReportCategory ReportCategory, string ReportDescription)
public void SendKickReport(string KickPlayerGUID, string KickDescription, KickReasonCategory KickCategoryID)
public void SendInvalidPlayerStateReport(string PlayerGUID, InvalidPlayerStateReportCategory ReportCategory, string Report)
}
public EasyAntiCheat.Server.Scout.PlayerReportCategory : Enum {
public int value__
public PlayerReportCategory PlayerReportCheating
public PlayerReportCategory PlayerReportExploiting
public PlayerReportCategory PlayerReportProfile
public PlayerReportCategory PlayerReportVerbalAbuse
public PlayerReportCategory PlayerReportScamming
public PlayerReportCategory PlayerReportSpamming
public PlayerReportCategory PlayerReportOther
}
public EasyAntiCheat.Server.Scout.Scout : object {
public void Dispose()
public void SendPlayerReport(string ReportedPlayerGUID, string ReportingPlayerGUID, PlayerReportCategory ReportCategory, string ReportDescription)
public void SendKickReport(string KickPlayerGUID, string KickDescription, KickReasonCategory KickCategoryID)
public void SendInvalidPlayerStateReport(string PlayerGUID, InvalidPlayerStateReportCategory ReportCategory, string Report)
}
public EasyAntiCheat.Server.ServerConfiguration : ValueType {
private int <RegisterTimeout>k__BackingField
private string <ServerName>k__BackingField
public ServerConfiguration Default
public int RegisterTimeout
public string ServerName
public void .ctor(string ServerName)
public void .ctor(int RegisterTimeout, string ServerName)
public ServerConfiguration get_Default()
public int get_RegisterTimeout()
public void set_RegisterTimeout(int value)
public string get_ServerName()
public void set_ServerName(string value)
}
