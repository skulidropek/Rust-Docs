internal System.Buffers.ArrayMemoryPool`1 : MemoryPool`1<T> {
private int s_maxBufferSize
public int MaxBufferSize
public int get_MaxBufferSize()
public IMemoryOwner`1<T> Rent(int minimumBufferSize)
protected void Dispose(bool disposing)
}
public System.Buffers.Binary.BinaryPrimitives : object {
public sbyte ReverseEndianness(sbyte value)
public short ReverseEndianness(short value)
public int ReverseEndianness(int value)
public long ReverseEndianness(long value)
public byte ReverseEndianness(byte value)
public ushort ReverseEndianness(ushort value)
public UInt32 ReverseEndianness(UInt32 value)
public ulong ReverseEndianness(ulong value)
public short ReadInt16BigEndian(ReadOnlySpan`1<byte> source)
public int ReadInt32BigEndian(ReadOnlySpan`1<byte> source)
public long ReadInt64BigEndian(ReadOnlySpan`1<byte> source)
public ushort ReadUInt16BigEndian(ReadOnlySpan`1<byte> source)
public UInt32 ReadUInt32BigEndian(ReadOnlySpan`1<byte> source)
public ulong ReadUInt64BigEndian(ReadOnlySpan`1<byte> source)
public bool TryReadInt16BigEndian(ReadOnlySpan`1<byte> source, Int16& value)
public bool TryReadInt32BigEndian(ReadOnlySpan`1<byte> source, Int32& value)
public bool TryReadInt64BigEndian(ReadOnlySpan`1<byte> source, Int64& value)
public bool TryReadUInt16BigEndian(ReadOnlySpan`1<byte> source, UInt16& value)
public bool TryReadUInt32BigEndian(ReadOnlySpan`1<byte> source, UInt32& value)
public bool TryReadUInt64BigEndian(ReadOnlySpan`1<byte> source, UInt64& value)
public short ReadInt16LittleEndian(ReadOnlySpan`1<byte> source)
public int ReadInt32LittleEndian(ReadOnlySpan`1<byte> source)
public long ReadInt64LittleEndian(ReadOnlySpan`1<byte> source)
public ushort ReadUInt16LittleEndian(ReadOnlySpan`1<byte> source)
public UInt32 ReadUInt32LittleEndian(ReadOnlySpan`1<byte> source)
public ulong ReadUInt64LittleEndian(ReadOnlySpan`1<byte> source)
public bool TryReadInt16LittleEndian(ReadOnlySpan`1<byte> source, Int16& value)
public bool TryReadInt32LittleEndian(ReadOnlySpan`1<byte> source, Int32& value)
public bool TryReadInt64LittleEndian(ReadOnlySpan`1<byte> source, Int64& value)
public bool TryReadUInt16LittleEndian(ReadOnlySpan`1<byte> source, UInt16& value)
public bool TryReadUInt32LittleEndian(ReadOnlySpan`1<byte> source, UInt32& value)
public bool TryReadUInt64LittleEndian(ReadOnlySpan`1<byte> source, UInt64& value)
public void WriteInt16BigEndian(Span`1<byte> destination, short value)
public void WriteInt32BigEndian(Span`1<byte> destination, int value)
public void WriteInt64BigEndian(Span`1<byte> destination, long value)
public void WriteUInt16BigEndian(Span`1<byte> destination, ushort value)
public void WriteUInt32BigEndian(Span`1<byte> destination, UInt32 value)
public void WriteUInt64BigEndian(Span`1<byte> destination, ulong value)
public bool TryWriteInt16BigEndian(Span`1<byte> destination, short value)
public bool TryWriteInt32BigEndian(Span`1<byte> destination, int value)
public bool TryWriteInt64BigEndian(Span`1<byte> destination, long value)
public bool TryWriteUInt16BigEndian(Span`1<byte> destination, ushort value)
public bool TryWriteUInt32BigEndian(Span`1<byte> destination, UInt32 value)
public bool TryWriteUInt64BigEndian(Span`1<byte> destination, ulong value)
public void WriteInt16LittleEndian(Span`1<byte> destination, short value)
public void WriteInt32LittleEndian(Span`1<byte> destination, int value)
public void WriteInt64LittleEndian(Span`1<byte> destination, long value)
public void WriteUInt16LittleEndian(Span`1<byte> destination, ushort value)
public void WriteUInt32LittleEndian(Span`1<byte> destination, UInt32 value)
public void WriteUInt64LittleEndian(Span`1<byte> destination, ulong value)
public bool TryWriteInt16LittleEndian(Span`1<byte> destination, short value)
public bool TryWriteInt32LittleEndian(Span`1<byte> destination, int value)
public bool TryWriteInt64LittleEndian(Span`1<byte> destination, long value)
public bool TryWriteUInt16LittleEndian(Span`1<byte> destination, ushort value)
public bool TryWriteUInt32LittleEndian(Span`1<byte> destination, UInt32 value)
public bool TryWriteUInt64LittleEndian(Span`1<byte> destination, ulong value)
}
public System.Buffers.BuffersExtensions : object {
public Nullable`1<SequencePosition> PositionOf(ReadOnlySequence`1& source, T value)
private Nullable`1<SequencePosition> PositionOfMultiSegment(ReadOnlySequence`1& source, T value)
public void CopyTo(ReadOnlySequence`1& source, Span`1<T> destination)
private void CopyToMultiSegment(ReadOnlySequence`1& sequence, Span`1<T> destination)
public T[] ToArray(ReadOnlySequence`1& sequence)
public void Write(IBufferWriter`1<T> writer, ReadOnlySpan`1<T> value)
private void WriteMultiSegment(IBufferWriter`1<T> writer, ReadOnlySpan`1& source, Span`1<T> destination)
}
public System.Buffers.IBufferWriter`1 {
public void Advance(int count)
public Memory`1<T> GetMemory(int sizeHint)
public Span`1<T> GetSpan(int sizeHint)
}
public System.Buffers.IMemoryOwner`1 {
public Memory`1<T> Memory
public Memory`1<T> get_Memory()
}
public System.Buffers.IPinnable {
public MemoryHandle Pin(int elementIndex)
public void Unpin()
}
public System.Buffers.MemoryHandle : ValueType {
private Void* _pointer
private GCHandle _handle
private IPinnable _pinnable
public Void* Pointer
public void .ctor(Void* pointer, GCHandle handle, IPinnable pinnable)
public Void* get_Pointer()
public void Dispose()
}
public System.Buffers.MemoryManager`1 : object {
public Memory`1<T> Memory
public Memory`1<T> get_Memory()
public Span`1<T> GetSpan()
public MemoryHandle Pin(int elementIndex)
public void Unpin()
protected Memory`1<T> CreateMemory(int length)
protected Memory`1<T> CreateMemory(int start, int length)
protected internal bool TryGetArray(ArraySegment`1& segment)
private void System.IDisposable.Dispose()
protected void Dispose(bool disposing)
}
public System.Buffers.MemoryPool`1 : object {
private MemoryPool`1<T> s_shared
public MemoryPool`1<T> Shared
public int MaxBufferSize
public MemoryPool`1<T> get_Shared()
public IMemoryOwner`1<T> Rent(int minBufferSize)
public int get_MaxBufferSize()
public void Dispose()
protected void Dispose(bool disposing)
}
public System.Buffers.OperationStatus : Enum {
public int value__
public OperationStatus Done
public OperationStatus DestinationTooSmall
public OperationStatus NeedMoreData
public OperationStatus InvalidData
}
internal System.Buffers.ReadOnlySequence : object {
public int FlagBitMask
public int IndexBitMask
public int SegmentStartMask
public int SegmentEndMask
public int ArrayStartMask
public int ArrayEndMask
public int MemoryManagerStartMask
public int MemoryManagerEndMask
public int StringStartMask
public int StringEndMask
public int SegmentToSequenceStart(int startIndex)
public int SegmentToSequenceEnd(int endIndex)
public int ArrayToSequenceStart(int startIndex)
public int ArrayToSequenceEnd(int endIndex)
public int MemoryManagerToSequenceStart(int startIndex)
public int MemoryManagerToSequenceEnd(int endIndex)
public int StringToSequenceStart(int startIndex)
public int StringToSequenceEnd(int endIndex)
}
public System.Buffers.ReadOnlySequence`1 : ValueType {
private SequencePosition _sequenceStart
private SequencePosition _sequenceEnd
public ReadOnlySequence`1<T> Empty
public long Length
public bool IsEmpty
public bool IsSingleSegment
public ReadOnlyMemory`1<T> First
public SequencePosition Start
public SequencePosition End
public long get_Length()
public bool get_IsEmpty()
public bool get_IsSingleSegment()
public ReadOnlyMemory`1<T> get_First()
public SequencePosition get_Start()
public SequencePosition get_End()
private void .ctor(object startSegment, int startIndexAndFlags, object endSegment, int endIndexAndFlags)
public void .ctor(ReadOnlySequenceSegment`1<T> startSegment, int startIndex, ReadOnlySequenceSegment`1<T> endSegment, int endIndex)
public void .ctor(T[] array)
public void .ctor(T[] array, int start, int length)
public void .ctor(ReadOnlyMemory`1<T> memory)
public ReadOnlySequence`1<T> Slice(long start, long length)
public ReadOnlySequence`1<T> Slice(long start, SequencePosition end)
public ReadOnlySequence`1<T> Slice(SequencePosition start, long length)
public ReadOnlySequence`1<T> Slice(int start, int length)
public ReadOnlySequence`1<T> Slice(int start, SequencePosition end)
public ReadOnlySequence`1<T> Slice(SequencePosition start, int length)
public ReadOnlySequence`1<T> Slice(SequencePosition start, SequencePosition end)
public ReadOnlySequence`1<T> Slice(SequencePosition start)
public ReadOnlySequence`1<T> Slice(long start)
public string ToString()
public Enumerator<T> GetEnumerator()
public SequencePosition GetPosition(long offset)
public SequencePosition GetPosition(long offset, SequencePosition origin)
public bool TryGet(SequencePosition& position, ReadOnlyMemory`1& memory, bool advance)
internal bool TryGetBuffer(SequencePosition& position, ReadOnlyMemory`1& memory, SequencePosition& next)
private ReadOnlyMemory`1<T> GetFirstBuffer()
private SequencePosition Seek(SequencePosition& start, SequencePosition& end, long offset, ExceptionArgument argument)
private SequencePosition SeekMultiSegment(ReadOnlySequenceSegment`1<T> currentSegment, object endObject, int endIndex, long offset, ExceptionArgument argument)
private void BoundsCheck(SequencePosition& position)
private void BoundsCheck(UInt32 sliceStartIndex, object sliceStartObject, UInt32 sliceEndIndex, object sliceEndObject)
private SequencePosition GetEndPosition(ReadOnlySequenceSegment`1<T> startSegment, object startObject, int startIndex, object endObject, int endIndex, long length)
private SequenceType<T> GetSequenceType()
private int GetIndex(SequencePosition& position)
private ReadOnlySequence`1<T> SliceImpl(SequencePosition& start, SequencePosition& end)
private long GetLength()
internal bool TryGetReadOnlySequenceSegment(ReadOnlySequenceSegment`1& startSegment, Int32& startIndex, ReadOnlySequenceSegment`1& endSegment, Int32& endIndex)
internal bool TryGetArray(ArraySegment`1& segment)
internal bool TryGetString(String& text, Int32& start, Int32& length)
private bool InRange(UInt32 value, UInt32 start, UInt32 end)
private bool InRange(ulong value, ulong start, ulong end)
}
internal System.Buffers.ReadOnlySequenceDebugView`1 : object {
private T[] _array
private ReadOnlySequenceDebugViewSegments<T> _segments
public ReadOnlySequenceDebugViewSegments<T> BufferSegments
public T[] Items
public void .ctor(ReadOnlySequence`1<T> sequence)
public ReadOnlySequenceDebugViewSegments<T> get_BufferSegments()
public T[] get_Items()
}
public System.Buffers.ReadOnlySequenceSegment`1 : object {
private ReadOnlyMemory`1<T> <Memory>k__BackingField
private ReadOnlySequenceSegment`1<T> <Next>k__BackingField
private long <RunningIndex>k__BackingField
public ReadOnlyMemory`1<T> Memory
public ReadOnlySequenceSegment`1<T> Next
public long RunningIndex
public ReadOnlyMemory`1<T> get_Memory()
protected void set_Memory(ReadOnlyMemory`1<T> value)
public ReadOnlySequenceSegment`1<T> get_Next()
protected void set_Next(ReadOnlySequenceSegment`1<T> value)
public long get_RunningIndex()
protected void set_RunningIndex(long value)
}
public System.Buffers.StandardFormat : ValueType {
public byte NoPrecision
public byte MaxPrecision
private byte _format
private byte _precision
public char Symbol
public byte Precision
public bool HasPrecision
public bool IsDefault
public char get_Symbol()
public byte get_Precision()
public bool get_HasPrecision()
public bool get_IsDefault()
public void .ctor(char symbol, byte precision)
public StandardFormat op_Implicit(char symbol)
public StandardFormat Parse(ReadOnlySpan`1<char> format)
public StandardFormat Parse(string format)
public bool Equals(object obj)
public int GetHashCode()
public bool Equals(StandardFormat other)
public string ToString()
public bool op_Equality(StandardFormat left, StandardFormat right)
public bool op_Inequality(StandardFormat left, StandardFormat right)
}
public System.Buffers.Text.Base64 : object {
private SByte[] s_decodingMap
private Byte[] s_encodingMap
private byte EncodingPad
private int MaximumEncodeLength
public OperationStatus DecodeFromUtf8(ReadOnlySpan`1<byte> utf8, Span`1<byte> bytes, Int32& bytesConsumed, Int32& bytesWritten, bool isFinalBlock)
public int GetMaxDecodedFromUtf8Length(int length)
public OperationStatus DecodeFromUtf8InPlace(Span`1<byte> buffer, Int32& bytesWritten)
private int Decode(Byte& encodedBytes, SByte& decodingMap)
private void WriteThreeLowOrderBytes(Byte& destination, int value)
public OperationStatus EncodeToUtf8(ReadOnlySpan`1<byte> bytes, Span`1<byte> utf8, Int32& bytesConsumed, Int32& bytesWritten, bool isFinalBlock)
public int GetMaxEncodedToUtf8Length(int length)
public OperationStatus EncodeToUtf8InPlace(Span`1<byte> buffer, int dataLength, Int32& bytesWritten)
private int Encode(Byte& threeBytes, Byte& encodingMap)
private int EncodeAndPadOne(Byte& twoBytes, Byte& encodingMap)
private int EncodeAndPadTwo(Byte& oneByte, Byte& encodingMap)
}
internal System.Buffers.Text.FormattingHelpers : object {
internal string HexTableLower
internal string HexTableUpper
public char GetSymbolOrDefault(StandardFormat& format, char defaultSymbol)
public void FillWithAsciiZeros(Span`1<byte> buffer)
public void WriteHexByte(byte value, Span`1<byte> buffer, int startingIndex, HexCasing casing)
public void WriteDigits(ulong value, Span`1<byte> buffer)
public void WriteDigitsWithGroupSeparator(ulong value, Span`1<byte> buffer)
public void WriteDigits(UInt32 value, Span`1<byte> buffer)
public void WriteFourDecimalDigits(UInt32 value, Span`1<byte> buffer, int startingIndex)
public void WriteTwoDecimalDigits(UInt32 value, Span`1<byte> buffer, int startingIndex)
public ulong DivMod(ulong numerator, ulong denominator, UInt64& modulo)
public UInt32 DivMod(UInt32 numerator, UInt32 denominator, UInt32& modulo)
public int CountDecimalTrailingZeros(UInt32 value, UInt32& valueWithoutTrailingZeros)
public int CountDigits(ulong value)
public int CountDigits(UInt32 value)
public int CountHexDigits(ulong value)
}
internal System.Buffers.Text.ParserHelpers : object {
public int ByteOverflowLength
public int ByteOverflowLengthHex
public int UInt16OverflowLength
public int UInt16OverflowLengthHex
public int UInt32OverflowLength
public int UInt32OverflowLengthHex
public int UInt64OverflowLength
public int UInt64OverflowLengthHex
public int SByteOverflowLength
public int SByteOverflowLengthHex
public int Int16OverflowLength
public int Int16OverflowLengthHex
public int Int32OverflowLength
public int Int32OverflowLengthHex
public int Int64OverflowLength
public int Int64OverflowLengthHex
public Byte[] s_hexLookup
public bool IsDigit(int i)
}
internal System.Buffers.Text.Utf8Constants : object {
public byte Colon
public byte Comma
public byte Minus
public byte Period
public byte Plus
public byte Slash
public byte Space
public byte Hyphen
public byte Separator
public int GroupSize
public TimeSpan s_nullUtcOffset
public int DateTimeMaxUtcOffsetHours
public int DateTimeNumFractionDigits
public int MaxDateTimeFraction
public ulong BillionMaxUIntValue
public UInt32 Billion
}
public System.Buffers.Text.Utf8Formatter : object {
private byte TimeMarker
private byte UtcMarker
private byte GMT1
private byte GMT2
private byte GMT3
private byte GMT1Lowercase
private byte GMT2Lowercase
private byte GMT3Lowercase
private UInt32[] DayAbbreviations
private UInt32[] DayAbbreviationsLowercase
private UInt32[] MonthAbbreviations
private UInt32[] MonthAbbreviationsLowercase
private byte OpenBrace
private byte CloseBrace
private byte OpenParen
private byte CloseParen
private byte Dash
public bool TryFormat(bool value, Span`1<byte> destination, Int32& bytesWritten, StandardFormat format)
public bool TryFormat(DateTimeOffset value, Span`1<byte> destination, Int32& bytesWritten, StandardFormat format)
public bool TryFormat(DateTime value, Span`1<byte> destination, Int32& bytesWritten, StandardFormat format)
private bool TryFormatDateTimeG(DateTime value, TimeSpan offset, Span`1<byte> destination, Int32& bytesWritten)
private bool TryFormatDateTimeO(DateTime value, TimeSpan offset, Span`1<byte> destination, Int32& bytesWritten)
private bool TryFormatDateTimeR(DateTime value, Span`1<byte> destination, Int32& bytesWritten)
private bool TryFormatDateTimeL(DateTime value, Span`1<byte> destination, Int32& bytesWritten)
public bool TryFormat(decimal value, Span`1<byte> destination, Int32& bytesWritten, StandardFormat format)
private bool TryFormatDecimalE(NumberBuffer& number, Span`1<byte> destination, Int32& bytesWritten, byte precision, byte exponentSymbol)
private bool TryFormatDecimalF(NumberBuffer& number, Span`1<byte> destination, Int32& bytesWritten, byte precision)
private bool TryFormatDecimalG(NumberBuffer& number, Span`1<byte> destination, Int32& bytesWritten)
public bool TryFormat(double value, Span`1<byte> destination, Int32& bytesWritten, StandardFormat format)
public bool TryFormat(float value, Span`1<byte> destination, Int32& bytesWritten, StandardFormat format)
private bool TryFormatFloatingPoint(T value, Span`1<byte> destination, Int32& bytesWritten, StandardFormat format)
public bool TryFormat(Guid value, Span`1<byte> destination, Int32& bytesWritten, StandardFormat format)
public bool TryFormat(byte value, Span`1<byte> destination, Int32& bytesWritten, StandardFormat format)
public bool TryFormat(sbyte value, Span`1<byte> destination, Int32& bytesWritten, StandardFormat format)
public bool TryFormat(ushort value, Span`1<byte> destination, Int32& bytesWritten, StandardFormat format)
public bool TryFormat(short value, Span`1<byte> destination, Int32& bytesWritten, StandardFormat format)
public bool TryFormat(UInt32 value, Span`1<byte> destination, Int32& bytesWritten, StandardFormat format)
public bool TryFormat(int value, Span`1<byte> destination, Int32& bytesWritten, StandardFormat format)
public bool TryFormat(ulong value, Span`1<byte> destination, Int32& bytesWritten, StandardFormat format)
public bool TryFormat(long value, Span`1<byte> destination, Int32& bytesWritten, StandardFormat format)
private bool TryFormatInt64(long value, ulong mask, Span`1<byte> destination, Int32& bytesWritten, StandardFormat format)
private bool TryFormatInt64D(long value, byte precision, Span`1<byte> destination, Int32& bytesWritten)
private bool TryFormatInt64Default(long value, Span`1<byte> destination, Int32& bytesWritten)
private bool TryFormatInt32Default(int value, Span`1<byte> destination, Int32& bytesWritten)
private bool TryFormatInt32MultipleDigits(int value, Span`1<byte> destination, Int32& bytesWritten)
private bool TryFormatInt64MultipleDigits(long value, Span`1<byte> destination, Int32& bytesWritten)
private bool TryFormatInt64MoreThanNegativeBillionMaxUInt(long value, Span`1<byte> destination, Int32& bytesWritten)
private bool TryFormatInt64LessThanNegativeBillionMaxUInt(long value, Span`1<byte> destination, Int32& bytesWritten)
private bool TryFormatInt64N(long value, byte precision, Span`1<byte> destination, Int32& bytesWritten)
private bool TryFormatUInt64(ulong value, Span`1<byte> destination, Int32& bytesWritten, StandardFormat format)
private bool TryFormatUInt64D(ulong value, byte precision, Span`1<byte> destination, bool insertNegationSign, Int32& bytesWritten)
private bool TryFormatUInt64Default(ulong value, Span`1<byte> destination, Int32& bytesWritten)
private bool TryFormatUInt32Default(UInt32 value, Span`1<byte> destination, Int32& bytesWritten)
private bool TryFormatUInt32SingleDigit(UInt32 value, Span`1<byte> destination, Int32& bytesWritten)
private bool TryFormatUInt32MultipleDigits(UInt32 value, Span`1<byte> destination, Int32& bytesWritten)
private bool TryFormatUInt64SingleDigit(ulong value, Span`1<byte> destination, Int32& bytesWritten)
private bool TryFormatUInt64MultipleDigits(ulong value, Span`1<byte> destination, Int32& bytesWritten)
private bool TryFormatUInt64LessThanBillionMaxUInt(ulong value, Span`1<byte> destination, Int32& bytesWritten)
private bool TryFormatUInt64MoreThanBillionMaxUInt(ulong value, Span`1<byte> destination, Int32& bytesWritten)
private bool TryFormatUInt64N(ulong value, byte precision, Span`1<byte> destination, bool insertNegationSign, Int32& bytesWritten)
private bool TryFormatUInt64X(ulong value, byte precision, bool useLower, Span`1<byte> destination, Int32& bytesWritten)
public bool TryFormat(TimeSpan value, Span`1<byte> destination, Int32& bytesWritten, StandardFormat format)
}
public System.Buffers.Text.Utf8Parser : object {
private UInt32 FlipCase
private UInt32 NoFlipCase
private Int32[] s_daysToMonth365
private Int32[] s_daysToMonth366
public bool TryParse(ReadOnlySpan`1<byte> source, Boolean& value, Int32& bytesConsumed, char standardFormat)
public bool TryParse(ReadOnlySpan`1<byte> source, DateTime& value, Int32& bytesConsumed, char standardFormat)
public bool TryParse(ReadOnlySpan`1<byte> source, DateTimeOffset& value, Int32& bytesConsumed, char standardFormat)
private bool TryParseDateTimeOffsetDefault(ReadOnlySpan`1<byte> source, DateTimeOffset& value, Int32& bytesConsumed)
private bool TryParseDateTimeG(ReadOnlySpan`1<byte> source, DateTime& value, DateTimeOffset& valueAsOffset, Int32& bytesConsumed)
private bool TryCreateDateTimeOffset(DateTime dateTime, bool offsetNegative, int offsetHours, int offsetMinutes, DateTimeOffset& value)
private bool TryCreateDateTimeOffset(int year, int month, int day, int hour, int minute, int second, int fraction, bool offsetNegative, int offsetHours, int offsetMinutes, DateTimeOffset& value)
private bool TryCreateDateTimeOffsetInterpretingDataAsLocalTime(int year, int month, int day, int hour, int minute, int second, int fraction, DateTimeOffset& value)
private bool TryCreateDateTime(int year, int month, int day, int hour, int minute, int second, int fraction, DateTimeKind kind, DateTime& value)
private bool TryParseDateTimeOffsetO(ReadOnlySpan`1<byte> source, DateTimeOffset& value, Int32& bytesConsumed, DateTimeKind& kind)
private bool TryParseDateTimeOffsetR(ReadOnlySpan`1<byte> source, UInt32 caseFlipXorMask, DateTimeOffset& dateTimeOffset, Int32& bytesConsumed)
public bool TryParse(ReadOnlySpan`1<byte> source, Decimal& value, Int32& bytesConsumed, char standardFormat)
public bool TryParse(ReadOnlySpan`1<byte> source, Single& value, Int32& bytesConsumed, char standardFormat)
public bool TryParse(ReadOnlySpan`1<byte> source, Double& value, Int32& bytesConsumed, char standardFormat)
private bool TryParseNormalAsFloatingPoint(ReadOnlySpan`1<byte> source, Double& value, Int32& bytesConsumed, char standardFormat)
private bool TryParseAsSpecialFloatingPoint(ReadOnlySpan`1<byte> source, T positiveInfinity, T negativeInfinity, T nan, T& value, Int32& bytesConsumed)
public bool TryParse(ReadOnlySpan`1<byte> source, Guid& value, Int32& bytesConsumed, char standardFormat)
private bool TryParseGuidN(ReadOnlySpan`1<byte> text, Guid& value, Int32& bytesConsumed)
private bool TryParseGuidCore(ReadOnlySpan`1<byte> source, bool ends, char begin, char end, Guid& value, Int32& bytesConsumed)
public bool TryParse(ReadOnlySpan`1<byte> source, SByte& value, Int32& bytesConsumed, char standardFormat)
public bool TryParse(ReadOnlySpan`1<byte> source, Int16& value, Int32& bytesConsumed, char standardFormat)
public bool TryParse(ReadOnlySpan`1<byte> source, Int32& value, Int32& bytesConsumed, char standardFormat)
public bool TryParse(ReadOnlySpan`1<byte> source, Int64& value, Int32& bytesConsumed, char standardFormat)
private bool TryParseSByteD(ReadOnlySpan`1<byte> source, SByte& value, Int32& bytesConsumed)
private bool TryParseInt16D(ReadOnlySpan`1<byte> source, Int16& value, Int32& bytesConsumed)
private bool TryParseInt32D(ReadOnlySpan`1<byte> source, Int32& value, Int32& bytesConsumed)
private bool TryParseInt64D(ReadOnlySpan`1<byte> source, Int64& value, Int32& bytesConsumed)
private bool TryParseSByteN(ReadOnlySpan`1<byte> source, SByte& value, Int32& bytesConsumed)
private bool TryParseInt16N(ReadOnlySpan`1<byte> source, Int16& value, Int32& bytesConsumed)
private bool TryParseInt32N(ReadOnlySpan`1<byte> source, Int32& value, Int32& bytesConsumed)
private bool TryParseInt64N(ReadOnlySpan`1<byte> source, Int64& value, Int32& bytesConsumed)
public bool TryParse(ReadOnlySpan`1<byte> source, Byte& value, Int32& bytesConsumed, char standardFormat)
public bool TryParse(ReadOnlySpan`1<byte> source, UInt16& value, Int32& bytesConsumed, char standardFormat)
public bool TryParse(ReadOnlySpan`1<byte> source, UInt32& value, Int32& bytesConsumed, char standardFormat)
public bool TryParse(ReadOnlySpan`1<byte> source, UInt64& value, Int32& bytesConsumed, char standardFormat)
private bool TryParseByteD(ReadOnlySpan`1<byte> source, Byte& value, Int32& bytesConsumed)
private bool TryParseUInt16D(ReadOnlySpan`1<byte> source, UInt16& value, Int32& bytesConsumed)
private bool TryParseUInt32D(ReadOnlySpan`1<byte> source, UInt32& value, Int32& bytesConsumed)
private bool TryParseUInt64D(ReadOnlySpan`1<byte> source, UInt64& value, Int32& bytesConsumed)
private bool TryParseByteN(ReadOnlySpan`1<byte> source, Byte& value, Int32& bytesConsumed)
private bool TryParseUInt16N(ReadOnlySpan`1<byte> source, UInt16& value, Int32& bytesConsumed)
private bool TryParseUInt32N(ReadOnlySpan`1<byte> source, UInt32& value, Int32& bytesConsumed)
private bool TryParseUInt64N(ReadOnlySpan`1<byte> source, UInt64& value, Int32& bytesConsumed)
private bool TryParseByteX(ReadOnlySpan`1<byte> source, Byte& value, Int32& bytesConsumed)
private bool TryParseUInt16X(ReadOnlySpan`1<byte> source, UInt16& value, Int32& bytesConsumed)
private bool TryParseUInt32X(ReadOnlySpan`1<byte> source, UInt32& value, Int32& bytesConsumed)
private bool TryParseUInt64X(ReadOnlySpan`1<byte> source, UInt64& value, Int32& bytesConsumed)
private bool TryParseNumber(ReadOnlySpan`1<byte> source, NumberBuffer& number, Int32& bytesConsumed, ParseNumberOptions options, Boolean& textUsedExponentNotation)
private bool TryParseTimeSpanBigG(ReadOnlySpan`1<byte> source, TimeSpan& value, Int32& bytesConsumed)
private bool TryParseTimeSpanC(ReadOnlySpan`1<byte> source, TimeSpan& value, Int32& bytesConsumed)
public bool TryParse(ReadOnlySpan`1<byte> source, TimeSpan& value, Int32& bytesConsumed, char standardFormat)
private bool TryParseTimeSpanFraction(ReadOnlySpan`1<byte> source, UInt32& value, Int32& bytesConsumed)
private bool TryCreateTimeSpan(bool isNegative, UInt32 days, UInt32 hours, UInt32 minutes, UInt32 seconds, UInt32 fraction, TimeSpan& timeSpan)
private bool TryParseTimeSpanLittleG(ReadOnlySpan`1<byte> source, TimeSpan& value, Int32& bytesConsumed)
}
internal System.DecimalDecCalc : object {
private UInt32 D32DivMod1E9(UInt32 hi32, UInt32& lo32)
internal UInt32 DecDivMod1E9(MutableDecimal& value)
internal void DecAddInt32(MutableDecimal& value, UInt32 i)
private bool D32AddCarry(UInt32& value, UInt32 i)
internal void DecMul10(MutableDecimal& value)
private void DecShiftLeft(MutableDecimal& value)
private void DecAdd(MutableDecimal& value, MutableDecimal d)
}
internal System.ExceptionArgument : Enum {
public int value__
public ExceptionArgument length
public ExceptionArgument start
public ExceptionArgument minimumBufferSize
public ExceptionArgument elementIndex
public ExceptionArgument comparable
public ExceptionArgument comparer
public ExceptionArgument destination
public ExceptionArgument offset
public ExceptionArgument startSegment
public ExceptionArgument endSegment
public ExceptionArgument startIndex
public ExceptionArgument endIndex
public ExceptionArgument array
public ExceptionArgument culture
public ExceptionArgument manager
}
public System.Memory`1 : ValueType {
private object _object
private int _index
private int _length
private int RemoveFlagsBitMask
public Memory`1<T> Empty
public int Length
public bool IsEmpty
public Span`1<T> Span
public void .ctor(T[] array)
internal void .ctor(T[] array, int start)
public void .ctor(T[] array, int start, int length)
internal void .ctor(MemoryManager`1<T> manager, int length)
internal void .ctor(MemoryManager`1<T> manager, int start, int length)
internal void .ctor(object obj, int start, int length)
public Memory`1<T> op_Implicit(T[] array)
public Memory`1<T> op_Implicit(ArraySegment`1<T> segment)
public ReadOnlyMemory`1<T> op_Implicit(Memory`1<T> memory)
public Memory`1<T> get_Empty()
public int get_Length()
public bool get_IsEmpty()
public string ToString()
public Memory`1<T> Slice(int start)
public Memory`1<T> Slice(int start, int length)
public Span`1<T> get_Span()
public void CopyTo(Memory`1<T> destination)
public bool TryCopyTo(Memory`1<T> destination)
public MemoryHandle Pin()
public T[] ToArray()
public bool Equals(object obj)
public bool Equals(Memory`1<T> other)
public int GetHashCode()
private int CombineHashCodes(int left, int right)
private int CombineHashCodes(int h1, int h2, int h3)
}
internal System.MemoryDebugView`1 : object {
private ReadOnlyMemory`1<T> _memory
public T[] Items
public void .ctor(Memory`1<T> memory)
public void .ctor(ReadOnlyMemory`1<T> memory)
public T[] get_Items()
}
public System.MemoryExtensions : object {
internal IntPtr StringAdjustment
public ReadOnlySpan`1<char> Trim(ReadOnlySpan`1<char> span)
public ReadOnlySpan`1<char> TrimStart(ReadOnlySpan`1<char> span)
public ReadOnlySpan`1<char> TrimEnd(ReadOnlySpan`1<char> span)
public ReadOnlySpan`1<char> Trim(ReadOnlySpan`1<char> span, char trimChar)
public ReadOnlySpan`1<char> TrimStart(ReadOnlySpan`1<char> span, char trimChar)
public ReadOnlySpan`1<char> TrimEnd(ReadOnlySpan`1<char> span, char trimChar)
public ReadOnlySpan`1<char> Trim(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> trimChars)
public ReadOnlySpan`1<char> TrimStart(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> trimChars)
public ReadOnlySpan`1<char> TrimEnd(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> trimChars)
public bool IsWhiteSpace(ReadOnlySpan`1<char> span)
public int IndexOf(Span`1<T> span, T value)
public int IndexOf(Span`1<T> span, ReadOnlySpan`1<T> value)
public int LastIndexOf(Span`1<T> span, T value)
public int LastIndexOf(Span`1<T> span, ReadOnlySpan`1<T> value)
public bool SequenceEqual(Span`1<T> span, ReadOnlySpan`1<T> other)
public int SequenceCompareTo(Span`1<T> span, ReadOnlySpan`1<T> other)
public int IndexOf(ReadOnlySpan`1<T> span, T value)
public int IndexOf(ReadOnlySpan`1<T> span, ReadOnlySpan`1<T> value)
public int LastIndexOf(ReadOnlySpan`1<T> span, T value)
public int LastIndexOf(ReadOnlySpan`1<T> span, ReadOnlySpan`1<T> value)
public int IndexOfAny(Span`1<T> span, T value0, T value1)
public int IndexOfAny(Span`1<T> span, T value0, T value1, T value2)
public int IndexOfAny(Span`1<T> span, ReadOnlySpan`1<T> values)
public int IndexOfAny(ReadOnlySpan`1<T> span, T value0, T value1)
public int IndexOfAny(ReadOnlySpan`1<T> span, T value0, T value1, T value2)
public int IndexOfAny(ReadOnlySpan`1<T> span, ReadOnlySpan`1<T> values)
public int LastIndexOfAny(Span`1<T> span, T value0, T value1)
public int LastIndexOfAny(Span`1<T> span, T value0, T value1, T value2)
public int LastIndexOfAny(Span`1<T> span, ReadOnlySpan`1<T> values)
public int LastIndexOfAny(ReadOnlySpan`1<T> span, T value0, T value1)
public int LastIndexOfAny(ReadOnlySpan`1<T> span, T value0, T value1, T value2)
public int LastIndexOfAny(ReadOnlySpan`1<T> span, ReadOnlySpan`1<T> values)
public bool SequenceEqual(ReadOnlySpan`1<T> span, ReadOnlySpan`1<T> other)
public int SequenceCompareTo(ReadOnlySpan`1<T> span, ReadOnlySpan`1<T> other)
public bool StartsWith(Span`1<T> span, ReadOnlySpan`1<T> value)
public bool StartsWith(ReadOnlySpan`1<T> span, ReadOnlySpan`1<T> value)
public bool EndsWith(Span`1<T> span, ReadOnlySpan`1<T> value)
public bool EndsWith(ReadOnlySpan`1<T> span, ReadOnlySpan`1<T> value)
public void Reverse(Span`1<T> span)
public Span`1<T> AsSpan(T[] array)
public Span`1<T> AsSpan(T[] array, int start, int length)
public Span`1<T> AsSpan(ArraySegment`1<T> segment)
public Span`1<T> AsSpan(ArraySegment`1<T> segment, int start)
public Span`1<T> AsSpan(ArraySegment`1<T> segment, int start, int length)
public Memory`1<T> AsMemory(T[] array)
public Memory`1<T> AsMemory(T[] array, int start)
public Memory`1<T> AsMemory(T[] array, int start, int length)
public Memory`1<T> AsMemory(ArraySegment`1<T> segment)
public Memory`1<T> AsMemory(ArraySegment`1<T> segment, int start)
public Memory`1<T> AsMemory(ArraySegment`1<T> segment, int start, int length)
public void CopyTo(T[] source, Span`1<T> destination)
public void CopyTo(T[] source, Memory`1<T> destination)
public bool Overlaps(Span`1<T> span, ReadOnlySpan`1<T> other)
public bool Overlaps(Span`1<T> span, ReadOnlySpan`1<T> other, Int32& elementOffset)
public bool Overlaps(ReadOnlySpan`1<T> span, ReadOnlySpan`1<T> other)
public bool Overlaps(ReadOnlySpan`1<T> span, ReadOnlySpan`1<T> other, Int32& elementOffset)
public int BinarySearch(Span`1<T> span, IComparable`1<T> comparable)
public int BinarySearch(Span`1<T> span, TComparable comparable)
public int BinarySearch(Span`1<T> span, T value, TComparer comparer)
public int BinarySearch(ReadOnlySpan`1<T> span, IComparable`1<T> comparable)
public int BinarySearch(ReadOnlySpan`1<T> span, TComparable comparable)
public int BinarySearch(ReadOnlySpan`1<T> span, T value, TComparer comparer)
private bool IsTypeComparableAsBytes(NUInt& size)
public Span`1<T> AsSpan(T[] array, int start)
public bool Contains(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> value, StringComparison comparisonType)
public bool Equals(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> other, StringComparison comparisonType)
private bool EqualsOrdinalIgnoreCase(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> other)
public int CompareTo(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> other, StringComparison comparisonType)
private int CompareToOrdinalIgnoreCase(ReadOnlySpan`1<char> strA, ReadOnlySpan`1<char> strB)
public int IndexOf(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> value, StringComparison comparisonType)
public int ToLower(ReadOnlySpan`1<char> source, Span`1<char> destination, CultureInfo culture)
public int ToLowerInvariant(ReadOnlySpan`1<char> source, Span`1<char> destination)
public int ToUpper(ReadOnlySpan`1<char> source, Span`1<char> destination, CultureInfo culture)
public int ToUpperInvariant(ReadOnlySpan`1<char> source, Span`1<char> destination)
public bool EndsWith(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> value, StringComparison comparisonType)
public bool StartsWith(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> value, StringComparison comparisonType)
public ReadOnlySpan`1<char> AsSpan(string text)
public ReadOnlySpan`1<char> AsSpan(string text, int start)
public ReadOnlySpan`1<char> AsSpan(string text, int start, int length)
public ReadOnlyMemory`1<char> AsMemory(string text)
public ReadOnlyMemory`1<char> AsMemory(string text, int start)
public ReadOnlyMemory`1<char> AsMemory(string text, int start, int length)
private IntPtr MeasureStringAdjustment()
}
internal System.MutableDecimal : ValueType {
public UInt32 Flags
public UInt32 High
public UInt32 Low
public UInt32 Mid
private UInt32 SignMask
private UInt32 ScaleMask
private int ScaleShift
public bool IsNegative
public int Scale
public bool get_IsNegative()
public void set_IsNegative(bool value)
public int get_Scale()
public void set_Scale(int value)
}
internal System.NotImplemented : object {
internal Exception ByDesign
internal Exception get_ByDesign()
internal Exception ByDesignWithMessage(string message)
internal Exception ActiveIssue(string issue)
}
internal System.NUInt : ValueType {
private Void* _value
private void .ctor(UInt32 value)
private void .ctor(ulong value)
public NUInt op_Implicit(UInt32 value)
public IntPtr op_Implicit(NUInt value)
public NUInt op_Explicit(int value)
public Void* op_Explicit(NUInt value)
public NUInt op_Multiply(NUInt left, NUInt right)
}
internal System.Number : object {
internal int DECIMAL_PRECISION
private UInt64[] s_rgval64Power10
private SByte[] s_rgexp64Power10
private UInt64[] s_rgval64Power10By16
private Int16[] s_rgexp64Power10By16
public void RoundNumber(NumberBuffer& number, int pos)
internal bool NumberBufferToDouble(NumberBuffer& number, Double& value)
public bool NumberBufferToDecimal(NumberBuffer& number, Decimal& value)
public void DecimalToNumber(decimal value, NumberBuffer& number)
private UInt32 DigitsToInt(ReadOnlySpan`1<byte> digits, int count)
private ulong Mul32x32To64(UInt32 a, UInt32 b)
private ulong Mul64Lossy(ulong a, ulong b, Int32& pexp)
private int abs(int value)
private double NumberToDouble(NumberBuffer& number)
}
internal System.NumberBuffer : ValueType {
public int Scale
public bool IsNegative
public int BufferSize
private byte _b0
private byte _b1
private byte _b2
private byte _b3
private byte _b4
private byte _b5
private byte _b6
private byte _b7
private byte _b8
private byte _b9
private byte _b10
private byte _b11
private byte _b12
private byte _b13
private byte _b14
private byte _b15
private byte _b16
private byte _b17
private byte _b18
private byte _b19
private byte _b20
private byte _b21
private byte _b22
private byte _b23
private byte _b24
private byte _b25
private byte _b26
private byte _b27
private byte _b28
private byte _b29
private byte _b30
private byte _b31
private byte _b32
private byte _b33
private byte _b34
private byte _b35
private byte _b36
private byte _b37
private byte _b38
private byte _b39
private byte _b40
private byte _b41
private byte _b42
private byte _b43
private byte _b44
private byte _b45
private byte _b46
private byte _b47
private byte _b48
private byte _b49
private byte _b50
public Span`1<byte> Digits
public Byte* UnsafeDigits
public int NumDigits
public Span`1<byte> get_Digits()
public Byte* get_UnsafeDigits()
public int get_NumDigits()
public void CheckConsistency()
public string ToString()
}
internal System.Numerics.Hashing.HashHelpers : object {
public int RandomSeed
public int Combine(int h1, int h2)
}
internal System.Pinnable`1 : object {
public T Data
}
public System.ReadOnlyMemory`1 : ValueType {
private object _object
private int _index
private int _length
internal int RemoveFlagsBitMask
public ReadOnlyMemory`1<T> Empty
public int Length
public bool IsEmpty
public ReadOnlySpan`1<T> Span
public void .ctor(T[] array)
public void .ctor(T[] array, int start, int length)
internal void .ctor(object obj, int start, int length)
public ReadOnlyMemory`1<T> op_Implicit(T[] array)
public ReadOnlyMemory`1<T> op_Implicit(ArraySegment`1<T> segment)
public ReadOnlyMemory`1<T> get_Empty()
public int get_Length()
public bool get_IsEmpty()
public string ToString()
public ReadOnlyMemory`1<T> Slice(int start)
public ReadOnlyMemory`1<T> Slice(int start, int length)
public ReadOnlySpan`1<T> get_Span()
public void CopyTo(Memory`1<T> destination)
public bool TryCopyTo(Memory`1<T> destination)
public MemoryHandle Pin()
public T[] ToArray()
public bool Equals(object obj)
public bool Equals(ReadOnlyMemory`1<T> other)
public int GetHashCode()
private int CombineHashCodes(int left, int right)
private int CombineHashCodes(int h1, int h2, int h3)
internal object GetObjectStartLength(Int32& start, Int32& length)
}
public System.ReadOnlySpan`1 : ValueType {
private Pinnable`1<T> _pinnable
private IntPtr _byteOffset
private int _length
public int Length
public bool IsEmpty
public ReadOnlySpan`1<T> Empty
public T& modreq(System.Runtime.InteropServices.InAttribute) Item
internal Pinnable`1<T> Pinnable
internal IntPtr ByteOffset
public int get_Length()
public bool get_IsEmpty()
public bool op_Inequality(ReadOnlySpan`1<T> left, ReadOnlySpan`1<T> right)
public bool Equals(object obj)
public int GetHashCode()
public ReadOnlySpan`1<T> op_Implicit(T[] array)
public ReadOnlySpan`1<T> op_Implicit(ArraySegment`1<T> segment)
public ReadOnlySpan`1<T> get_Empty()
public Enumerator<T> GetEnumerator()
public void .ctor(T[] array)
public void .ctor(T[] array, int start, int length)
public void .ctor(Void* pointer, int length)
internal void .ctor(Pinnable`1<T> pinnable, IntPtr byteOffset, int length)
public T& modreq(System.Runtime.InteropServices.InAttribute) get_Item(int index)
public T& modreq(System.Runtime.InteropServices.InAttribute) GetPinnableReference()
public void CopyTo(Span`1<T> destination)
public bool TryCopyTo(Span`1<T> destination)
public bool op_Equality(ReadOnlySpan`1<T> left, ReadOnlySpan`1<T> right)
public string ToString()
public ReadOnlySpan`1<T> Slice(int start)
public ReadOnlySpan`1<T> Slice(int start, int length)
public T[] ToArray()
internal T& DangerousGetPinnableReference()
internal Pinnable`1<T> get_Pinnable()
internal IntPtr get_ByteOffset()
}
public System.Runtime.InteropServices.MemoryMarshal : object {
public bool TryGetArray(ReadOnlyMemory`1<T> memory, ArraySegment`1& segment)
public bool TryGetMemoryManager(ReadOnlyMemory`1<T> memory, TManager& manager)
public bool TryGetMemoryManager(ReadOnlyMemory`1<T> memory, TManager& manager, Int32& start, Int32& length)
public IEnumerable`1<T> ToEnumerable(ReadOnlyMemory`1<T> memory)
public bool TryGetString(ReadOnlyMemory`1<char> memory, String& text, Int32& start, Int32& length)
public T Read(ReadOnlySpan`1<byte> source)
public bool TryRead(ReadOnlySpan`1<byte> source, T& value)
public void Write(Span`1<byte> destination, T& value)
public bool TryWrite(Span`1<byte> destination, T& value)
public Memory`1<T> CreateFromPinnedArray(T[] array, int start, int length)
public Span`1<byte> AsBytes(Span`1<T> span)
public ReadOnlySpan`1<byte> AsBytes(ReadOnlySpan`1<T> span)
public Memory`1<T> AsMemory(ReadOnlyMemory`1<T> memory)
public T& GetReference(Span`1<T> span)
public T& GetReference(ReadOnlySpan`1<T> span)
public Span`1<TTo> Cast(Span`1<TFrom> span)
public ReadOnlySpan`1<TTo> Cast(ReadOnlySpan`1<TFrom> span)
}
public System.Runtime.InteropServices.SequenceMarshal : object {
public bool TryGetReadOnlySequenceSegment(ReadOnlySequence`1<T> sequence, ReadOnlySequenceSegment`1& startSegment, Int32& startIndex, ReadOnlySequenceSegment`1& endSegment, Int32& endIndex)
public bool TryGetArray(ReadOnlySequence`1<T> sequence, ArraySegment`1& segment)
public bool TryGetReadOnlyMemory(ReadOnlySequence`1<T> sequence, ReadOnlyMemory`1& memory)
internal bool TryGetString(ReadOnlySequence`1<char> sequence, String& text, Int32& start, Int32& length)
}
public System.SequencePosition : ValueType {
private object _object
private int _integer
public void .ctor(object object, int integer)
public object GetObject()
public int GetInteger()
public bool Equals(SequencePosition other)
public bool Equals(object obj)
public int GetHashCode()
}
public System.Span`1 : ValueType {
private Pinnable`1<T> _pinnable
private IntPtr _byteOffset
private int _length
public int Length
public bool IsEmpty
public Span`1<T> Empty
public T& Item
internal Pinnable`1<T> Pinnable
internal IntPtr ByteOffset
public int get_Length()
public bool get_IsEmpty()
public bool op_Inequality(Span`1<T> left, Span`1<T> right)
public bool Equals(object obj)
public int GetHashCode()
public Span`1<T> op_Implicit(T[] array)
public Span`1<T> op_Implicit(ArraySegment`1<T> segment)
public Span`1<T> get_Empty()
public Enumerator<T> GetEnumerator()
public void .ctor(T[] array)
internal Span`1<T> Create(T[] array, int start)
public void .ctor(T[] array, int start, int length)
public void .ctor(Void* pointer, int length)
internal void .ctor(Pinnable`1<T> pinnable, IntPtr byteOffset, int length)
public T& get_Item(int index)
public T& GetPinnableReference()
public void Clear()
public void Fill(T value)
public void CopyTo(Span`1<T> destination)
public bool TryCopyTo(Span`1<T> destination)
public bool op_Equality(Span`1<T> left, Span`1<T> right)
public ReadOnlySpan`1<T> op_Implicit(Span`1<T> span)
public string ToString()
public Span`1<T> Slice(int start)
public Span`1<T> Slice(int start, int length)
public T[] ToArray()
internal T& DangerousGetPinnableReference()
internal Pinnable`1<T> get_Pinnable()
internal IntPtr get_ByteOffset()
}
internal System.SpanDebugView`1 : object {
private T[] _array
public T[] Items
public void .ctor(Span`1<T> span)
public void .ctor(ReadOnlySpan`1<T> span)
public T[] get_Items()
}
internal System.SpanHelpers : object {
private ulong XorPowerOfTwoToHighByte
private ulong XorPowerOfTwoToHighChar
public int BinarySearch(ReadOnlySpan`1<T> span, TComparable comparable)
public int BinarySearch(T& spanStart, int length, TComparable comparable)
public int IndexOf(Byte& searchSpace, int searchSpaceLength, Byte& value, int valueLength)
public int IndexOfAny(Byte& searchSpace, int searchSpaceLength, Byte& value, int valueLength)
public int LastIndexOfAny(Byte& searchSpace, int searchSpaceLength, Byte& value, int valueLength)
public int IndexOf(Byte& searchSpace, byte value, int length)
public int LastIndexOf(Byte& searchSpace, int searchSpaceLength, Byte& value, int valueLength)
public int LastIndexOf(Byte& searchSpace, byte value, int length)
public int IndexOfAny(Byte& searchSpace, byte value0, byte value1, int length)
public int IndexOfAny(Byte& searchSpace, byte value0, byte value1, byte value2, int length)
public int LastIndexOfAny(Byte& searchSpace, byte value0, byte value1, int length)
public int LastIndexOfAny(Byte& searchSpace, byte value0, byte value1, byte value2, int length)
public bool SequenceEqual(Byte& first, Byte& second, NUInt length)
private int LocateFirstFoundByte(Vector`1<byte> match)
public int SequenceCompareTo(Byte& first, int firstLength, Byte& second, int secondLength)
private int LocateLastFoundByte(Vector`1<byte> match)
private int LocateFirstFoundByte(ulong match)
private int LocateLastFoundByte(ulong match)
private Vector`1<byte> GetVector(byte vectorByte)
public int SequenceCompareTo(Char& first, int firstLength, Char& second, int secondLength)
public int IndexOf(Char& searchSpace, char value, int length)
public int LastIndexOf(Char& searchSpace, char value, int length)
private int LocateFirstFoundChar(Vector`1<ushort> match)
private int LocateFirstFoundChar(ulong match)
private int LocateLastFoundChar(Vector`1<ushort> match)
private int LocateLastFoundChar(ulong match)
public int IndexOf(T& searchSpace, int searchSpaceLength, T& value, int valueLength)
public int IndexOf(T& searchSpace, T value, int length)
public int IndexOfAny(T& searchSpace, T value0, T value1, int length)
public int IndexOfAny(T& searchSpace, T value0, T value1, T value2, int length)
public int IndexOfAny(T& searchSpace, int searchSpaceLength, T& value, int valueLength)
public int LastIndexOf(T& searchSpace, int searchSpaceLength, T& value, int valueLength)
public int LastIndexOf(T& searchSpace, T value, int length)
public int LastIndexOfAny(T& searchSpace, T value0, T value1, int length)
public int LastIndexOfAny(T& searchSpace, T value0, T value1, T value2, int length)
public int LastIndexOfAny(T& searchSpace, int searchSpaceLength, T& value, int valueLength)
public bool SequenceEqual(T& first, T& second, int length)
public int SequenceCompareTo(T& first, int firstLength, T& second, int secondLength)
public void CopyTo(T& dst, int dstLength, T& src, int srcLength)
public IntPtr Add(IntPtr start, int index)
public bool IsReferenceOrContainsReferences()
private bool IsReferenceOrContainsReferencesCore(Type type)
public void ClearLessThanPointerSized(Byte* ptr, UIntPtr byteLength)
public void ClearLessThanPointerSized(Byte& b, UIntPtr byteLength)
public void ClearPointerSizedWithoutReferences(Byte& b, UIntPtr byteLength)
public void ClearPointerSizedWithReferences(IntPtr& ip, UIntPtr pointerSizeLength)
private bool LessThanEqual(IntPtr index, UIntPtr length)
}
internal System.SR : object {
private ResourceManager s_resourceManager
private Type <ResourceType>k__BackingField
private ResourceManager ResourceManager
internal Type ResourceType
internal string NotSupported_CannotCallEqualsOnSpan
internal string NotSupported_CannotCallGetHashCodeOnSpan
internal string Argument_InvalidTypeWithPointersNotSupported
internal string Argument_DestinationTooShort
internal string MemoryDisposed
internal string OutstandingReferences
internal string Argument_BadFormatSpecifier
internal string Argument_GWithPrecisionNotSupported
internal string Argument_CannotParsePrecision
internal string Argument_PrecisionTooLarge
internal string Argument_OverlapAlignmentMismatch
internal string EndPositionNotReached
internal string UnexpectedSegmentType
private ResourceManager get_ResourceManager()
private bool UsingResourceKeys()
internal string GetResourceString(string resourceKey, string defaultString)
internal string Format(string resourceFormat, Object[] args)
internal string Format(string resourceFormat, object p1)
internal string Format(string resourceFormat, object p1, object p2)
internal string Format(string resourceFormat, object p1, object p2, object p3)
internal Type get_ResourceType()
internal string get_NotSupported_CannotCallEqualsOnSpan()
internal string get_NotSupported_CannotCallGetHashCodeOnSpan()
internal string get_Argument_InvalidTypeWithPointersNotSupported()
internal string get_Argument_DestinationTooShort()
internal string get_MemoryDisposed()
internal string get_OutstandingReferences()
internal string get_Argument_BadFormatSpecifier()
internal string get_Argument_GWithPrecisionNotSupported()
internal string get_Argument_CannotParsePrecision()
internal string get_Argument_PrecisionTooLarge()
internal string get_Argument_OverlapAlignmentMismatch()
internal string get_EndPositionNotReached()
internal string get_UnexpectedSegmentType()
}
internal System.ThrowHelper : object {
internal void ThrowArgumentNullException(ExceptionArgument argument)
private Exception CreateArgumentNullException(ExceptionArgument argument)
internal void ThrowArrayTypeMismatchException()
private Exception CreateArrayTypeMismatchException()
internal void ThrowArgumentException_InvalidTypeWithPointersNotSupported(Type type)
private Exception CreateArgumentException_InvalidTypeWithPointersNotSupported(Type type)
internal void ThrowArgumentException_DestinationTooShort()
private Exception CreateArgumentException_DestinationTooShort()
internal void ThrowIndexOutOfRangeException()
private Exception CreateIndexOutOfRangeException()
internal void ThrowArgumentOutOfRangeException()
private Exception CreateArgumentOutOfRangeException()
internal void ThrowArgumentOutOfRangeException(ExceptionArgument argument)
private Exception CreateArgumentOutOfRangeException(ExceptionArgument argument)
internal void ThrowArgumentOutOfRangeException_PrecisionTooLarge()
private Exception CreateArgumentOutOfRangeException_PrecisionTooLarge()
internal void ThrowArgumentOutOfRangeException_SymbolDoesNotFit()
private Exception CreateArgumentOutOfRangeException_SymbolDoesNotFit()
internal void ThrowInvalidOperationException()
private Exception CreateInvalidOperationException()
internal void ThrowInvalidOperationException_OutstandingReferences()
private Exception CreateInvalidOperationException_OutstandingReferences()
internal void ThrowInvalidOperationException_UnexpectedSegmentType()
private Exception CreateInvalidOperationException_UnexpectedSegmentType()
internal void ThrowInvalidOperationException_EndPositionNotReached()
private Exception CreateInvalidOperationException_EndPositionNotReached()
internal void ThrowArgumentOutOfRangeException_PositionOutOfRange()
private Exception CreateArgumentOutOfRangeException_PositionOutOfRange()
internal void ThrowArgumentOutOfRangeException_OffsetOutOfRange()
private Exception CreateArgumentOutOfRangeException_OffsetOutOfRange()
internal void ThrowObjectDisposedException_ArrayMemoryPoolBuffer()
private Exception CreateObjectDisposedException_ArrayMemoryPoolBuffer()
internal void ThrowFormatException_BadFormatSpecifier()
private Exception CreateFormatException_BadFormatSpecifier()
internal void ThrowArgumentException_OverlapAlignmentMismatch()
private Exception CreateArgumentException_OverlapAlignmentMismatch()
internal void ThrowNotSupportedException()
private Exception CreateThrowNotSupportedException()
public bool TryFormatThrowFormatException(Int32& bytesWritten)
public bool TryParseThrowFormatException(T& value, Int32& bytesConsumed)
public void ThrowArgumentValidationException(ReadOnlySequenceSegment`1<T> startSegment, int startIndex, ReadOnlySequenceSegment`1<T> endSegment)
private Exception CreateArgumentValidationException(ReadOnlySequenceSegment`1<T> startSegment, int startIndex, ReadOnlySequenceSegment`1<T> endSegment)
public void ThrowArgumentValidationException(Array array, int start)
private Exception CreateArgumentValidationException(Array array, int start)
public void ThrowStartOrEndArgumentValidationException(long start)
private Exception CreateStartOrEndArgumentValidationException(long start)
}
