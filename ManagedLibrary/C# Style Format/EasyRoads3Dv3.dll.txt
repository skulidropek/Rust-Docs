public class EasyRoads3Dv3.BinaryWriterEx : BinaryWriter {
    public BinaryWriterEx(string fileName);
    public long Seek(long offset, SeekOrigin origin);
    public void WriteStruct(object theStruct);
    public void Write(Int32[] array);
    public void Write(Single[] array);
}
public class EasyRoads3Dv3.CombineClass : ValueType {
    public Material m;
    public List`1<MeshInstance> objects;
}
public enum EasyRoads3Dv3.ConnectedTo : Enum {
    public int value__;
    public static ConnectedTo Start;
    public static ConnectedTo End;
    public static ConnectedTo None;
}
public class EasyRoads3Dv3.CRedge : ValueType {
    public int v1;
    public int v2;
    public int count;
    public CRedge(int v_1, int v_2);
}
public class EasyRoads3Dv3.CrossingCornerClass : object {
    public string presetName;
    public double id;
    public double timestamp;
    public float cornerRadius;
    public int cornerSegments;
    public float innerSegmentDistance;
    public CrossingCornerClass(QDOQDSQOOQDDD sw, string name);
}
public class EasyRoads3Dv3.EasyRoads3DTerrainIDv3 : MonoBehaviour {
    public string terrainid;
}
[AddComponentMenu("")]
public class EasyRoads3Dv3.ERBend : MonoBehaviour {
    public float roundAboutRadius;
    public float roundAboutResolution;
    public float rDist;
    public Vector3 raStartPos;
    public float roundaboutWidth;
    public float bendAngle;
    public bool meshInstance;
    public float roadWidth;
    public bool lockLeftRightRoundingRadius;
    public float leftRoundingRadius;
    public float rightRoundingRadius;
    public int roundingSegments;
    public float connectionLength;
    public float maxRoadWidth;
    public float maxRoundingRadius;
    public List`1<Vector3> meshVecs;
    public List`1<Vector3> mainRightPoints;
    public List`1<Vector3> mainCenterPoints;
    public List`1<Vector3> mainLeftPoints;
    public List`1<Vector3> OCCDQOCCDQ;
    public List`1<Vector3> splinePoints;
    public List`1<Vector2> mainRightPointsUVs;
    public List`1<Vector2> mainCenterPointsUVs;
    public List`1<Vector2> mainLeftPointsUVs;
    public List`1<Vector2> OCCDQOCCDQUVs;
    public Vector3 leftPoint;
    public Vector3 leftPoint1;
    public Vector3 rightPoint;
    public Vector3 rightPoint1;
    public Vector3 centerOnLine;
    public Vector3 leftOuterPoint;
    public Vector3 rightOuterPoint;
    public Vector3 pl;
    public Vector3 pr;
    public List`1<Vector3> edgePoints;
    public int newSegmentInt;
    public List`1<ERRoundaboutElement> connections;
    public String[] QDOOOQOOQQQQD;
    public int selectedConnection;
    public int tmpSelectedConnection;
    public int centerInt;
    public int leftOuterInt;
    public int rightOuterInt;
    public List`1<Vector3> leftOuterSegments;
    public List`1<Vector3> leftInnerSegments;
    public List`1<Vector3> rightOuterSegments;
    public List`1<Vector3> rightInnerSegments;
    public List`1<Vector2> leftOuterSegmentsUVs;
    public List`1<Vector2> leftInnerSegmentsUVs;
    public List`1<Vector2> rightOuterSegmentsUVs;
    public List`1<Vector2> rightInnerSegmentsUVs;
    public Material roadMaterial;
    public List`1<Vector3> innerRoundaboutPoints;
    public List`1<Vector2> innerRoundaboutUVs;
    public float innerSegmentDistance;
    public bool leftFlag;
    public bool rightFlag;
    private void Start();
    private void Update();
    public void OOCCCDQDCQ();
}
public class EasyRoads3Dv3.ERBlendVecs : object {
    public int verticeIndex;
    public int meshIndex;
    public float blendWeight;
    public int connection;
    public int blendType;
    public ERBlendVecs(int index, int mIndex, float weight, int conn, int type);
}
public class EasyRoads3Dv3.ERCamNodes : ScriptableObject {
    [SerializeField]
public float sleep;
    [SerializeField]
public float speed;
    [SerializeField]
public float easeOutDistance;
    [SerializeField]
public float easeInDistance;
    [SerializeField]
public GameObject startLookat;
    [SerializeField]
public GameObject endLookat;
}
public class EasyRoads3Dv3.ERCell : ValueType {
    public int x;
    public int y;
    public ERCell(int _x, int _y);
}
public class EasyRoads3Dv3.ERChildsSO : ValueType {
    public double id;
    public float startOffset;
    public float endOffset;
    public float xOffset;
    public float yOffset;
    public ERChildsSO(int _id);
}
public class EasyRoads3Dv3.ERConnection : object {
    public string name;
    public ERCrossingPrefabs prefabScript;
    public GameObject gameObject;
    public ERConnectionData[] connectionData;
    public static string str;
    public ERConnection(GameObject go, string g_name);
    private static ERConnection();
    public static ERConnection Create(GameObject go);
    public void SetPosition(Vector3 pos);
    public string GetName();
    public void SetName(string name);
    public void SetRotation(Vector3 euler);
    public void Destroy();
    public void UnConnect(int connectionIndex);
    public ERConnectionData[] GetConnectionData();
    public Vector3 GetLocalConnectionPosition(int connectionIndex);
    public Vector3[] GetLocalConnectionPositions();
    public Vector3[] GetConnectionWorldPositions();
    public Vector3 GetConnectionWorldPosition(int connectionIndex);
    public int FindNearestConnectionIndex(Vector3 position);
    public bool SwapTurn();
    public bool RotateConnections();
    public ERRoad GetConnectedRoad(int index, ConnectedTo& connectedTo);
    public ERLaneConnector[] GetLaneData(int connectionIndex);
    public ERLaneConnector[] GetLaneData(int connectionIndex, int lane);
    public int GetConnectionCount();
    public void AverageNormals(bool flag);
    public bool RecalculateNormals();
    public bool RecalculateTangents();
    public void Refresh();
    public bool IsFlexConnector();
}
public class EasyRoads3Dv3.ERConnectionData : object {
    public ERRoad road;
    public int marker;
    public int connectionIndex;
    public Vector3 position;
    public ERConnectionData(ERRoad rd, int rm, int index);
}
public class EasyRoads3Dv3.ERConnectionGUIStatus : ValueType {
    public int id;
    public bool favourite;
    public ERConnectionGUIStatus(int _id, bool value);
}
[AddComponentMenu("")]
public class EasyRoads3Dv3.ERConnectionParent : MonoBehaviour {
}
public class EasyRoads3Dv3.ERConnectionSibling : object {
    public string name;
    public ERModularRoad road;
    public Transform transform;
    public Vector3 angleControlPoint;
    public QDQDOOQQDQODD roadType;
    public double roadTypeID;
    public QDQDOOQQDQODD roadTypeAI;
    public double roadTypeAIid;
    public bool aIInit;
    public int roadTypeIndex;
    public int priorityLevel;
    public bool priorityRoad;
    public int prioritySectionStart;
    public int prioritySectionEnd;
    public float angle;
    public float prevAngle;
    public float roadWidth;
    public Vector3 controlPoint;
    public List`1<Vector2> roadShape;
    public List`1<bool> hardEdge;
    public List`1<float> roadShapeUVs;
    public List`1<bool> originalShapeVecs;
    public bool includeOuterLaneOffset;
    public float leftFixedDistance;
    public float rightFixedDistance;
    public int buildPriority;
    public bool highPriorityConnection;
    public int triangulationType;
    public bool adjustRadius;
    public float resolution;
    public int defaultSegments;
    public int segments;
    public float radius;
    public float leftCornerAngle;
    public float rightCornerAngle;
    public Vector3 leftCurvatureDir;
    public Vector3 leftCurvatureVec;
    public Vector3 rightCurvatureDir;
    public Vector3 rightCurvatureVec;
    public ERFlexConnectionType leftConnectionType;
    public ERFlexConnectionType rightConnectionType;
    public Vector3 cp;
    public Vector3 oldCP;
    public Vector3 cp1;
    public Vector3 lStart;
    public Vector3 lEnd;
    public Vector3 rStart;
    public Vector3 rEnd;
    public Vector3 ip;
    public Vector3 dir;
    public Vector3 outerCorner;
    public float cornerHandleScale;
    public List`1<Vector3> leftRoundingPoints;
    public List`1<Vector3> rightRoundingPoints;
    public List`1<Vector3> innerRoundingPoints;
    public List`1<Vector3> priorityLeftPoints;
    public List`1<Vector3> priorityRightPoints;
    public List`1<Vector3> priorityPointsMain;
    public List`1<Vector2> priorityPointsMainUVs;
    public List`1<List`1<Vector3>> roadVecs;
    public List`1<List`1<Vector3>> roadVecsRight;
    public List`1<List`1<Vector3>> roadVecsLeft;
    public List`1<List`1<Vector2>> roadUVs;
    public List`1<List`1<Vector2>> roadUVsLeft;
    public List`1<List`1<Vector2>> roadUVsRight;
    public List`1<int> connectionVecInts;
    public List`1<float> roadVecPerc;
    public int leftFixedIndex;
    public int rightFixedIndex;
    public int middleIndex;
    public int middleIndentIndexLeft;
    public int middleIndentIndexRight;
    public ERSideWalk leftSidewalk;
    public ERSideWalk rightSidewalk;
    public bool leftSidewalkActive;
    public bool rightSidewalkActive;
    public List`1<List`1<Vector3>> leftSidewalkVecs;
    public List`1<List`1<Vector2>> leftSidewalkUVs;
    public List`1<List`1<Vector3>> rightSidewalkVecs;
    public List`1<List`1<Vector2>> rightSidewalkUVs;
    public List`1<Vector3> leftIndentvecs;
    public List`1<Vector3> rightIndentvecs;
    public List`1<Vector3> leftSurroundingvecs;
    public List`1<Vector3> rightSurroundingvecs;
    public int leftIndent;
    public int rightIndent;
    public Vector3 leftIndentV3;
    public Vector3 rightIndentV3;
    public int leftSurrounding;
    public int rightSurrounding;
    public Vector3 leftSurroundingV3;
    public Vector3 rightSurroundingV3;
    public float uvRatio;
    public float uvy;
    public int mainRoadConnectionEdgeDecal;
    public GameObject mainConnectionDecal;
    public List`1<Vector3> mainConnectionDecalVecs;
    public Vector3 mainConnectionDecalEndDir;
    public int middleInt;
    public bool primaryPriorityConnection;
    public bool secondaryPriorityConnection;
    public bool shapeSubSegments;
    public List`1<int> normalIndexes;
    public bool primarySection;
    public ERLaneData laneData;
    public bool hasChanged;
    public void Clear();
    private void Init(ERModularRoad scr, float angle, Vector3 controlPoint, Transform transform);
    public static ERConnectionSibling CreateInstance(ERModularRoad scr, float angle, Vector3 controlPoint, Transform transform, List`1<ERConnectionSibling> siblings);
    private void GetRoadTypeIndex(double id, List`1<QDQDOOQQDQODD> types);
    public void ODDQDOCDCC(int index, List`1<QDQDOOQQDQODD> types);
    public void OCQQDCCOQO(List`1<QDQDOOQQDQODD> types);
    private void BuildRoadShape();
    public static void SetPriorityConnection(List`1<ERConnectionSibling> siblings, int index);
    public Vector2 GetVector2(Vector2 v1, Vector2 v2, Vector2 v3);
    public void OCQODDOQQC(double type, List`1<QDQDOOQQDQODD> roadTypes);
    public static Vector3 GetAngleControlPoint(Vector3 cp, Vector3 p0, Vector3 p1, Vector3 p2);
}
public class EasyRoads3Dv3.ERConnectionVecs : object {
    private List`1<int> ᙃ;
    private List`1<int> ᙄ;
}
public class EasyRoads3Dv3.ERCPUpdate : ValueType {
    public ERModularRoad road;
    public ERCrossingPrefabs prefab;
    public int startEnd;
    public int connection;
    public Vector3 cp;
    public ERCPUpdate(ERModularRoad v_road, ERCrossingPrefabs v_prefab, int v_startEnd, int v_connection, Vector3 v_cp);
}
[AddComponentMenu("")]
public class EasyRoads3Dv3.ERCrossingMainRoad : MonoBehaviour {
    public ERModularBase baseScript;
    public double roadType1;
    public int roadTypeInt1;
    public double roadType2;
    public int roadTypeInt2;
    public double roadType3;
    public int roadTypeInt3;
    public float indent1;
    public float indent2;
    public float roadWidth1;
    public float roadWidth2;
    public float roadWidth3;
    public bool tCrossing;
    public List`1<Vector3> leftOuter1;
    public List`1<Vector3> rightOuter1;
    public List`1<Vector2> leftOuterUV1;
    public List`1<Vector2> rightOuterUV1;
    public List`1<Vector3> leftOuter2;
    public List`1<Vector3> rightOuter2;
    public List`1<Vector2> leftOuterUV2;
    public List`1<Vector2> rightOuterUV2;
    public List`1<Vector3> leftOuter3;
    public List`1<Vector3> rightOuter3;
    public List`1<Vector2> leftOuterUV3;
    public List`1<Vector2> rightOuterUV3;
    public Material sourceMaterial;
    public Material sourceMaterial1;
    public Material targetMaterial;
    public float bottom2;
    public float bottom2Inner;
    public float bottom3;
    public float bottom3Inner;
    public float top2;
    public float top2Inner;
    public float top3;
    public float top3Inner;
    public float left2;
    public float left3;
    public float right2;
    public float right3;
    public int vec2Count;
    public int vec3Count;
    public float uvStart1;
    public float uvEnd1;
    public float uvStart2;
    public float uvEnd2;
    public Vector2 rightTopL;
    public Vector2 rightTopR;
    public Vector2 rightBottomL;
    public Vector2 rightBottomR;
    public Vector2 leftTopL;
    public Vector2 leftTopR;
    public Vector2 leftBottomL;
    public Vector2 leftBottomR;
    public float rightLeftUV;
    public float rightRightUV;
    public float leftLeftUV;
    public float leftRightUV;
    public float bottomuvInner2;
    public float topuvInner2;
    public float innerHeight2;
    public float outerHeight2;
    public float bottomuvInner3;
    public float topuvInner3;
    public float innerHeight3;
    public float outerHeight3;
    public float rightInnerStretch;
    public float leftInnerStretch;
    public Material mat1;
    public Material mat2;
    public Material mat3;
    public string name;
    public void OCQOQCDCQC();
    public void Clear();
    private List`1<int> Triangulate(List`1<Vector3> vecs, List`1<Vector3> edges);
}
[AddComponentMenu("")]
public class EasyRoads3Dv3.ERCrossingPrefabs : MonoBehaviour {
    public List`1<QDOODOQQDQODD> crossingElements;
    public List`1<QDOQDSQOOQDDD> sidewalkControlElements;
    public List`1<ERConnectionSibling> siblings;
    public Vector3[] meshVecs;
    public Vector3[] fullMeshVecs;
    public Vector3[] tmpMeshVecs;
    public Vector3[] tmpFullMeshVecs;
    public Vector3[] tCrossingTmpFullMeshVecs;
    public Int32[] outerVecInts;
    public List`1<Vector3> surfaceVecs;
    public List`1<int> surfaceVecType;
    public List`1<int> surfaceConnectionInt;
    public List`1<ERBlendVecs> tCrossingBlendData;
    public List`1<Vector3> indentVecs;
    public GameObject sourcePrefab;
    public int prefabId;
    public string guid;
    public List`1<int> prioritySegments;
    public float minNodeDistance;
    public int nodeWithinRange;
    public GameObject sourceObject;
    public bool meshInstance;
    public int selectedConnection;
    public String[] QDOOOQOOQQQQD;
    public bool deformTerrain;
    public bool isRoundabout;
    public bool isERCrossing;
    public bool isYConnector;
    public bool isIConnector;
    public bool isFlexConnector;
    public bool isSnapConnector;
    public bool isExitRoadConnector;
    public Vector3 prefabCenterDummy;
    public float snapRadius;
    public ERRoundabouts roundaboutScript;
    public ERCrossings crossingsScript;
    public ERIConnector iConnectorScript;
    public bool isCustomPrefab;
    public int customPrefabVersion;
    public bool recalculateNormals;
    public bool planarUVs;
    public float planarTiling;
    public int lastVecRoadIndex;
    public bool isSceneObject;
    public GameObject surfaceObject;
    public Vector3[] surfaceMeshVecs;
    public Vector3[] tmpSurfaceMeshVecs;
    public Vector3[] tmpSurfaceVecsTCrossings;
    public Int32[] surfaceInts;
    public Vector3 leftBottomCorner;
    public Vector3 leftTopCorner;
    public Vector3 rightBottomCorner;
    public Vector3 rightTopCorner;
    public bool tCrossing;
    public bool tStraightBending;
    public int tCrossingLeftRight;
    public float tMainRoadWidth;
    public float tConnectionRoadWidth;
    public float bottomLeftSidewalkWidth;
    public float bottomLeftSidewalkOuterOffset;
    public float bottomLeftSidewalkCurbDepth;
    public float bottomRightSidewalkWidth;
    public float bottomRightSidewalkOuterOffset;
    public float bottomRightSidewalkCurbDepth;
    public float topLeftSidewalkWidth;
    public float topLeftSidewalkOuterOffset;
    public float topLeftSidewalkCurbDepth;
    public float topRightSidewalkWidth;
    public float topRightSidewalkOuterOffset;
    public float topRightSidewalkCurbDepth;
    public ERConnection connObject;
    public Vector3 testVec;
    public List`1<int> surfaceSurroundingInts;
    public int rotationPriorityElement;
    public Vector3 cornerPos;
    public Vector3 mainCorner;
    public Vector3 connectedCorner;
    public Vector3 mainVecOuter;
    public Vector3 connectionVecOuter;
    public Vector3 indentTopVec;
    public Vector3 indentRightVec;
    public Vector3 mainIndent;
    public Vector3 connectionIndent;
    public int selectedRotationConnection;
    public Vector3 bottomVec;
    public Vector3 rightVec;
    public Vector3 bottomIndent;
    public Vector3 rightIndent;
    public float sAngle;
    public ERModularBase baseScript;
    public bool QDQDQOOQQDQOQQ;
    public Vector3 tp1;
    public Vector3 tp2;
    public bool doTerrainDeformation;
    public bool includeOuterVertices;
    public bool averageNormals;
    public float surroundingDistance;
    public Mesh surfaceMesh;
    public List`1<Vector3> debugVecs1;
    public List`1<Vector3> debugVecs2;
    public bool lightmapAdjusted;
    public bool isFlexUpdating;
    public Vector3 oldPosition;
    public Vector3 oldRotation;
    public bool lockScale;
    public float extraIndentMargin;
    public float indent;
    public float surrounding;
    public void OCOODQQDQO();
    public void OOCQCCQDOQ(Vector3 v1, Vector3 v2, int connectionElement, ERModularRoad road);
    public void OCQDDQODCC(int el);
    public void OCDOCCODOC(int elInt, float distance);
    public void DeformTCossingConnection(int elInt, float distance, float defaultDistance, List`1<Vector3> controlPoints, float multiplyFactor, float angle, Vector3 cpCenterPoint, float curveStrength);
    public void OOODCOOOCQ(List`1<int> affectedVecs, List`1<Vector2> tmpVecs);
    public void OQOQDDOCDC(bool ignorePriority, ERModularRoad road);
    public void OQQODODQCQ();
    public void OQQCDODDQQ(bool forceFlag);
    public void CheckPlanarUVs();
    public static bool OOCCOODCOO(List`1<ERModularRoad> affectedObjects, ERModularRoad roadScr);
    public void OCCDCDDOOQ(bool flag);
    public void OODODQQCOD(int el);
    public bool HasConnections();
    public bool HasConnectionsFull();
    public void OOQOQQODCD();
    public void OCODDQDQCC(int el, int startend);
    public void PopulateSiblingsList();
    public void InitFlexConnector();
    public void AttachRoadToFlexConnector(ERModularBase scr, float OCCDOQCODC, Vector3 OCCQOCQOQD);
    public void OQQQQOOCDO(int index);
    public void SetElementInfo(int index, int sourceIndex);
    public static void ODDQDDQOOD();
    public static bool OQCDCDOOCD(Vector3 pTarget, Vector3 pSource, Vector3 pCheck);
}
[AddComponentMenu("")]
public class EasyRoads3Dv3.ERCrossings : MonoBehaviour {
    [SerializeField]
public ERConnectionData cdata;
    public List`1<List`1<Vector3>> startConnectionV3;
    public List`1<List`1<Vector3>> endConnectionV3;
    public List`1<List`1<Vector3>> leftConnectionV3;
    public List`1<List`1<Vector3>> rightConnectionV3;
    public List`1<List`1<Vector2>> startConnectionUV;
    public List`1<List`1<Vector2>> endConnectionUV;
    public List`1<List`1<Vector2>> leftConnectionUV;
    public List`1<List`1<Vector2>> rightConnectionUV;
    public List`1<List`1<int>> startConnectionTris;
    public List`1<List`1<int>> endConnectionTris;
    public List`1<List`1<int>> leftConnectionTris;
    public List`1<List`1<int>> rightConnectionTris;
    public List`1<List`1<Vector3>> leftSidewalkStartV3;
    public List`1<List`1<Vector3>> rightSidewalkStartV3;
    public List`1<List`1<Vector3>> leftSidewalkEndV3;
    public List`1<List`1<Vector3>> rightSidewalkEndV3;
    public List`1<List`1<Vector2>> leftSidewalkStartUV;
    public List`1<List`1<Vector2>> rightSidewalkStartUV;
    public List`1<List`1<Vector2>> leftSidewalkEndUV;
    public List`1<List`1<Vector2>> rightSidewalkEndUV;
    public List`1<List`1<Vector3>> leftSidewalkLeftV3;
    public List`1<List`1<Vector3>> leftSidewalkRightV3;
    public List`1<List`1<Vector3>> rightSidewalkLeftV3;
    public List`1<List`1<Vector3>> rightSidewalkRightV3;
    public List`1<List`1<Vector2>> leftSidewalkLeftUV;
    public List`1<List`1<Vector2>> leftSidewalkRightUV;
    public List`1<List`1<Vector2>> rightSidewalkLeftUV;
    public List`1<List`1<Vector2>> rightSidewalkRightUV;
    public List`1<List`1<int>> leftSidewalkStartTris;
    public List`1<List`1<int>> rightSidewalkStartTris;
    public List`1<List`1<int>> leftSidewalkEndTris;
    public List`1<List`1<int>> rightSidewalkEndTris;
    public List`1<List`1<int>> leftSidewalkLeftTris;
    public List`1<List`1<int>> leftSidewalkRightTris;
    public List`1<List`1<int>> rightSidewalkLeftTris;
    public List`1<List`1<int>> rightSidewalkRightTris;
    public List`1<float> uvArrayFront;
    public List`1<float> uvArrayBack;
    public List`1<float> uvArrayLeft;
    public List`1<float> uvArrayRight;
    public List`1<int> OCCODQDOQO;
    public List`1<int> OOQODQDOQC;
    public List`1<int> OQCCQOCQDQ;
    public List`1<int> OQDQOQOCQD;
    public List`1<int> ODQDCCQOQD;
    public List`1<int> ODOQODQODO;
    public List`1<int> OOOQCQDOCD;
    public List`1<int> OQCDOOCDCD;
    public List`1<int> OCCODQDOQOStart;
    public List`1<int> OOQODQDOQCStart;
    public List`1<int> OQCCQOCQDQStart;
    public List`1<int> OQDQOQOCQDStart;
    public List`1<int> ODQDCCQOQDStart;
    public List`1<int> ODOQODQODOStart;
    public List`1<int> OOOQCQDOCDStart;
    public List`1<int> OQCDOOCDCDStart;
    public List`1<int> frontLeftRoadInts;
    public List`1<int> frontRightRoadInts;
    public List`1<int> backLeftRoadInts;
    public List`1<int> backRightRoadInts;
    public List`1<int> leftLeftRoadInts;
    public List`1<int> leftRightRoadInts;
    public List`1<int> rightLeftRoadInts;
    public List`1<int> rightRightRoadInts;
    public List`1<ERSideWalk> sidewalkCorners;
    public List`1<float> sidewalkWidths;
    public List`1<float> curbHeights;
    public List`1<float> curbDepths;
    public List`1<bool> beveledCurbs;
    public List`1<float> beveledHeights;
    public List`1<float> beveledDepths;
    public List`1<bool> outerCurbs;
    public List`1<bool> lockUVs;
    public List`1<Material> materials;
    public int leftStartSidewalkCornerInt;
    public int rightStartSidewalkCornerInt;
    public int leftEndSidewalkCornerInt;
    public int rightEndSidewalkCornerInt;
    public int leftLeftSidewalkCornerInt;
    public int rightLeftSidewalkCornerInt;
    public int leftRightSidewalkCornerInt;
    public int rightRightSidewalkCornerInt;
    public Vector3[] sidewalkControlPoints;
    public Boolean[] sidewalkControlStatus;
    public bool copySettingsFlag;
    public bool generalSettingsFlag;
    public bool connectionSettingsFlag;
    public bool cornerSettingsFlag;
    public bool sidewalkSettingsFlag;
    public String[] QDOOOQOOQQQQD;
    public int selectedConnection;
    public float startAngle;
    public bool roundedCorners;
    public float roundingRadius;
    public int roundingSegments;
    public float innerSegmentDistance;
    public bool tCrossing;
    public bool tStraightBending;
    public bool oldTCrossing;
    public int tCrossingLeftRight;
    public int oldtCrossingLeftRight;
    public int geometryType;
    public float resolution;
    public bool includeSidewalks;
    public bool defaultSidewalkEnabledStatus;
    public bool planarUVs;
    public float planarTiling;
    public bool isSceneObject;
    public int connectionHandling;
    public List`1<QDQDOOQQDQODD> roadTypesDynamic;
    public int frontRoadTypeInt;
    public double frontRoadTypeID;
    public float frontRoadWidth;
    public Material frontMaterial;
    public Material frontRoadMaterial;
    public float frontRoadUVTiling;
    public int backRoadTypeInt;
    public double backRoadTypeID;
    public float backRoadWidth;
    public Material backMaterial;
    public Material backRoadMaterial;
    public float backRoadUVTiling;
    public int leftRoadTypeInt;
    public double leftRoadTypeID;
    public float leftRoadWidth;
    public Material leftMaterial;
    public Material leftRoadMaterial;
    public float leftRoadUVTiling;
    public int rightRoadTypeInt;
    public double rightRoadTypeID;
    public float rightRoadWidth;
    public Material rightMaterial;
    public Material rightRoadMaterial;
    public float rightRoadUVTiling;
    public int selectedRoadType;
    public bool uniformCornersFlag;
    public int selectedCorner;
    public int selectedCornerPreset;
    public string cornerPresetName;
    public int selectedSidewalkPreset;
    public string sidewalkPresetName;
    public int OCOQDODDQQCorner;
    public Vector3 leftBottom;
    public Vector3 rightBottom;
    public Vector3 leftTop;
    public Vector3 rightTop;
    public Vector3 frontCenter;
    public Vector3 backCenter;
    public Vector3 leftCenter;
    public Vector3 rightCenter;
    public int prefabId;
    public ERCrossingPrefabs prefabScript;
    public QDOODOQQDQODD connectionElement;
    public int crossingOuterElement;
    public string crossingName;
    public bool guiChanged;
    public bool includeSidewalkChangeFlag;
    public List`1<Vector3> debugVecs;
    public List`1<NormalPairs> normalPairs;
    public float maxConnectionWidth;
    public int crossingStructure;
    public ERModularBase baseScript;
    public List`1<ERConnectionSibling> siblings1;
    public List`1<ERConnectionSibling> prioritySiblings;
    public Vector3 crossPointCenter;
    public List`1<Vector3> edges;
    public ERConnectionSibling primaryPriorityConnection;
    public ERConnectionSibling secondPriorityConnection;
    public bool adjustMainRadiusFlag;
    public bool disableAdjustMainRadiusFlag;
    public bool showScaleSliderAtPrimary;
    public bool showScaleSliderAtSecondary;
    public ERRoadWayType priorityWayType;
    public float leftIntOffset;
    public float rightIntOffset;
    public bool isUpdating;
    public int serializeTest;
    public int updateQueue;
    public void Refresh();
    public void ODOCCDCQOC();
    public Vector3 OOQCQDQCOO(int index, Vector3 p0, Vector3 p1, Vector3 p2, bool update);
    public void UpdateAllConnectionAngles();
    public void OOOCDCQQCO();
    public bool UpdateToRoadType(QDQDOOQQDQODD sourcePreset, List`1& updatedRoads);
    public bool RoadIsUpdated(ERModularRoad rd, List`1& updatedRoads);
    public int SetRoadTypeInt(double id);
    public void OCQCQODOQC(ERCrossings source, bool refreshFlag);
    public void OQCQCOOCDD();
    public void OCQDQODOQD(bool sidewalkSceneHandleFlag, bool rebuildRoads);
    public void OQCQDQDCOD();
    public void ODDDOCDCQO(bool rebuildRoads);
    public void OQCQQCQDCQ(int el, List`1<List`1<int>> trIntArray, List`1<float> uvArray, List`1<List`1<int>> leftSidewalkIntArray, List`1<List`1<int>> rightSidewalkIntArray, int startend);
    public void ODQCODQDDQ(int el, Material roadMaterial, int leftCorner, int rightCorner, int leftVecCount, int rightVecCount);
    public void OCDDOCDDOQ(List`1<Vector3> meshVecs, List`1<int> connectionVecInts, List`1& roadShapeVecs, List`1<List`1<Vector3>> vecArrays, List`1<List`1<Vector3>> leftSidewalkArray, List`1<List`1<Vector3>> rightSidewalkArray, int connectionElement, int startend);
    public static void ODOODQDCCQ(List`1<Vector3> sourceVecs, List`1& roadShapeVecs, Vector3 centerPoint, Vector3 startPoint, float halfWayDistance);
    public static string GetRoadShapeVecString(List`1<Vector2> vecs, List`1<Vector2> lvecs, List`1<Vector2> rvecs, Int32& matchCount);
    public void ODCCCQCQOO();
    public void ODCDCDDOCC(List`1<SidewalkPresetClass> sidewalkPresets, int el);
    public void OCCODQDOCO();
    public void OQDOQDQQQQ(int el);
    public void OODOQQQQCO();
    public void OQCOOQQOOD();
    public bool OQDOOCDOCD(ERModularRoad road, float angle);
}
public class EasyRoads3Dv3.ERDebug : object {
    public static List`1<Vector3> leftTHandles;
    public static List`1<Vector3> rightTHandles;
    private static ERDebug();
}
public class EasyRoads3Dv3.ERDecal : ScriptableObject {
    public int id;
    public string name;
    public ERDecalType type;
    public double roadType1;
    public double roadType2;
    public int connection;
    public GameObject decalPrefab;
    public float baseWidth;
    public float meshWidth;
    public float scale;
    public Vector3 localScale;
    public int priority;
    public bool collapsed;
    public float heightOffset;
    public Material material;
    public Vector2 uvLeftTop;
    public Vector2 uvRightBottom;
    public float width;
    public float length;
    public float xOffset;
    public float startOffset;
    public float endOffset;
    public float endRotation;
    public List`1<Vector2> uvBreakPoints;
    public List`1<float> distances;
    public ERDecalPosition position;
    public Vector2 uvLeftTop1;
    public Vector2 uvRightBottom1;
    public Vector2 uvLeftTop2;
    public Vector2 uvRightBottom2;
    public float width1;
    public float width2;
    public void Init(GameObject prefab, float baseWidth);
    public static ERDecal CreateInstance(GameObject prefab, float baseWidth);
    public static void CopyDecal(ERDecalClass source, ERDecal target);
    public static void OODDOCCOCC(ERDecal source, ERDecal target);
    public void OCQCQCOCOO();
    public static ERDecal OCQCDQDODQ(int id, List`1<ERDecal> decalPresets);
    public static List`1<ERDecal> FilterByType(List`1<ERDecal> lst, ERDecalType type);
    public static String[] OQDOCOQOQD(List`1& decals, string firstItem, int id1, int id2, Int32& _index1, Int32& _index2, ERDecalType type, ERDecalPosition position);
    public static int ODCOCCOOOO(List`1<ERDecal> decals, int tindex, ERDecalType type);
    public static GameObject[] OCCODDOQDO(List`1<ERDecal> decals, List`1& priority, List`1& scale);
    public void MatchDistances(List`1& distances, List`1<Vector2> uvBreakPoints, float length);
    public void SetBreakPointDistances(List`1& distances, List`1<Vector2> uvBreakPoints, float length);
}
public class EasyRoads3Dv3.ERDecalClass : object {
    public int id;
    public ERDecalType type;
    public string name;
    public double roadType1;
    public double roadType2;
    public int connection;
    public GameObject decalPrefab;
    public float baseWidth;
    public float meshWidth;
    public float scale;
    public Vector3 localScale;
    public int priority;
    public bool collapsed;
    public float heightOffset;
    public Material material;
    public Vector2 uvLeftTop;
    public Vector2 uvRightBottom;
    public float width;
    public float length;
    public float xOffset;
    public float startOffset;
    public float endOffset;
    public List`1<Vector2> uvBreakPoints;
    public List`1<float> distances;
    public Vector2 uvLeftTop1;
    public Vector2 uvRightBottom1;
    public Vector2 uvLeftTop2;
    public Vector2 uvRightBottom2;
    public float width1;
    public float width2;
    public static void CopyDecal(ERDecal source, ERDecalClass target);
}
public enum EasyRoads3Dv3.ERDecalPosition : Enum {
    public int value__;
    public static ERDecalPosition Start;
    public static ERDecalPosition End;
    public static ERDecalPosition Both;
}
public enum EasyRoads3Dv3.ERDecalType : Enum {
    public int value__;
    public static ERDecalType StartEnd;
    public static ERDecalType LineMarking;
    public static ERDecalType StopMarking;
    public static ERDecalType MainConnectionLineMarking;
    public static ERDecalType MotorwayRampLineMarking;
    public static ERDecalType MotorwayRampSplitMarking;
}
public enum EasyRoads3Dv3.ERDirectionType : Enum {
    public int value__;
    public static ERDirectionType Straight;
    public static ERDirectionType Left;
    public static ERDirectionType Right;
}
public enum EasyRoads3Dv3.ERExitType : Enum {
    public int value__;
    public static ERExitType RightExit;
    public static ERExitType RightEntry;
    public static ERExitType LeftExit;
    public static ERExitType LeftEntry;
    public static ERExitType BusStop;
}
public class EasyRoads3Dv3.ERExtension : object {
}
public enum EasyRoads3Dv3.ERFlexConnectionType : Enum {
    public int value__;
    public static ERFlexConnectionType Priority;
    public static ERFlexConnectionType SameType;
}
[AddComponentMenu("")]
public class EasyRoads3Dv3.ERIConnector : MonoBehaviour {
    public float roadWidth1;
    public float leftIndentInner1;
    public float leftIndent1;
    public float leftUVXInner1;
    public float leftUVX1;
    public float rightUVX1;
    public float rightUVXInner1;
    public float rightIndentInner1;
    public float rightIndent1;
    public float cornerRadius1;
    public int cornerSegments1;
    public float angle1;
    public float prevAngle1;
    public Material road1Material;
    public Material road1MaterialActive;
    public int roadType1;
    public double roadType1ID;
    public ERTexture road1ERTexture;
    private float ᙃ;
    private float ᙄ;
    private float ᙅ;
    private float 4AAAA;
    public float road1Stretch;
    public int road1StretchType;
    public int subdivide1;
    public float roadWidth2;
    public float leftIndentInner2;
    public float leftIndent2;
    public float leftUVXInner2;
    public float leftUVX2;
    public float rightUVX2;
    public float rightUVXInner2;
    public float rightIndentInner2;
    public float rightIndent2;
    public float cornerRadius2;
    public int cornerSegments2;
    public float angle2;
    public float prevAngle2;
    public Material road2Material;
    public Material road2MaterialActive;
    public int roadType2;
    public double roadType2ID;
    public ERTexture road2ERTexture;
    private float 5AAA1;
    private float 6AAAA;
    private float 7AAA1;
    private float 8AAAA;
    public float road2Stretch;
    public int road2StretchType;
    public int subdivide2;
    public float resolution;
    public int crossingStructure;
    public bool blend;
    public int textureType;
    public int roadStructureType;
    public String[] crossingStructureStrings;
    public bool clampUVs;
    public float attachAngle;
    public List`1<QDQDOOQQDQODD> roadTypesDynamic;
    public List`1<Vector3> splinePoints1;
    public List`1<Vector3> splinePoints2;
    public List`1<int> roadShapeMaterialInts1;
    public List`1<int> roadShapeMaterialInts2;
    public List`1<Vector3> leftRoundingPoints1;
    public List`1<Vector3> centerPoints1;
    public List`1<Vector3> rightRoundingPoints1;
    public List`1<Vector3> leftPointsIndents1;
    public List`1<Vector3> rightPointsIndents1;
    public List`1<Vector3> middlePoints1;
    public List`1<Vector3> leftPoints13;
    public List`1<Vector3> rightPoints12;
    public List`1<Vector2> leftRoundingPointsUV1;
    private List`1<Vector2> 9AAA1;
    public List`1<Vector2> rightRoundingPointsUV1;
    public List`1<Vector2> leftPointsIndentsUV1;
    public List`1<Vector2> rightPointsIndentsUV1;
    public List`1<Vector3> leftRoundingPoints2;
    public List`1<Vector3> centerPoints2;
    public List`1<Vector3> rightRoundingPoints2;
    public List`1<Vector3> leftPointsIndents2;
    public List`1<Vector3> rightPointsIndents2;
    public List`1<Vector3> middlePoints2;
    public List`1<Vector3> rightPoints23;
    public List`1<Vector2> leftRoundingPointsUV2;
    private List`1<Vector2> BAAAA;
    public List`1<Vector2> rightRoundingPointsUV2;
    public List`1<Vector2> leftPointsIndentsUV2;
    public List`1<Vector2> rightPointsIndentsUV2;
    public List`1<Vector3> priorityConnectionPoints;
    public List`1<Vector2> priorityConnectionPointsUV;
    public float minAngle12;
    public float minAngle13;
    public float minAngle23;
    public Vector2 cpUV1;
    public Vector2 cpUV2;
    public Vector2 cpUV3;
    public List`1<Vector3> ll1;
    public List`1<Vector3> ll2;
    public List`1<Vector3> ll3;
    public List`1<Vector3> ll4;
    public Vector3 l1Start;
    public Vector3 l1End;
    public Vector3 l2Start;
    public Vector3 l2End;
    public Vector3 l3Start;
    public Vector3 l3End;
    public Vector3 r1Start;
    public Vector3 r1End;
    public Vector3 r2Start;
    public Vector3 r2End;
    public Vector3 r3Start;
    public Vector3 r3End;
    public Vector3 ip12;
    public Vector3 ip23;
    public Vector3 ip13;
    public Vector3 ip13Left;
    public Vector3 ip12right;
    public Vector3 ip23right;
    public Vector3 cp1Left;
    public Vector3 cp1Right;
    public Vector3 cp2Left;
    public Vector3 cp2Right;
    public Vector3 cp3Left;
    public Vector3 cp3Right;
    public bool lock1;
    public bool lock2;
    public bool lock3;
    private float CAAA1;
    private float 00AAA;
    public ERModularRoad road1;
    public ERModularRoad road2;
    public List`1<Vector2> roadShape1;
    public List`1<Vector2> roadShape2;
    public List`1<float> roadShapeUVs1;
    public List`1<float> roadShapeUVs2;
    public List`1<Material> roadMaterials1;
    public List`1<Material> roadMaterials2;
    public List`1<Vector3> leftPoints;
    public List`1<Vector3> rightPoints;
    public float connectorLength1;
    public float connectorLength2;
    public float blendDistance;
    public int blendSection;
    public bool triangleStrip;
    public float triangleStripDistance;
    public float triangleStripUVStart;
    public float triangleStripUVEnd;
    public Material triangleStripMaterial;
    public Material blendMaterial;
    public Material transitionMaterial;
    public bool transitionSwap;
    public int proceduralMaterialIndex;
    public bool presetSwapped;
    public float t1;
    public float t2;
    public GameObject go1;
    public GameObject go2;
    public GameObject go3;
    public GameObject go4;
    public ERCrossingPrefabs prefabScript;
    public List`1<Vector3> surfaceVecs;
    public Vector3 testPoint;
    public GameObject surfaceMesh;
    public ERModularBase baseScript;
    public Vector3 centerDir;
    public Vector3 cp1;
    public Vector3 cp2;
    public Vector3 cp3;
    public Vector3 cp4;
    public Vector3 tv;
    public List`1<Vector3> tvecs;
    public void UpdateERTexture(int road);
    public void OCQOQCDCQC(ERModularRoad sourceRoad);
    public void GetIConnectionData(List`1<Vector3> vecs1, List`1<bool> conInts1, List`1<bool> conInts2, bool reversed1, bool reversed2, int road2Start);
    public void GetLeftRightInts(List`1<Vector2> roadShape, Int32& mostLeftInt, Int32& mostRightInt);
    public void OQQCQCCODO(List`1<Vector3> splinePoints, List`1<Vector3> splinePointsOther, List`1& vecs, List`1& uvs, List`1& tris, List`1<Vector2> roadShape, List`1<float> roadShapeUVs, List`1<int> roadShapeMaterialInts, float uvRatio, float stretchRatio, float stretchType, List`1& leftPoints, List`1& rightPoints, bool reversed, Vector3 cDir, int firstSecond, int startEnd);
    public List`1<Vector2> OODCQQQQCQ(float startY, List`1<Vector3> splinePoints, List`1<float> roadShapeUVs, float uvRatio, bool reversed, float sourceUV);
    public void OCOQOQOCOQ(List`1& colors, List`1<Vector3> splinePoints1, List`1<Vector3> splinePoints2, List`1<Vector2> roadShape1, List`1<Vector2> roadShape2);
    public void ODDCCDQDCO(List`1& targetArray, List`1<Vector3> otherArray);
    public void SetUVS(List`1<Vector3> leftRoundingPoints, List`1<Vector3> leftPointsIndents, List`1<Vector3> centerPoints, List`1<Vector3> rightPointsIndents, List`1<Vector3> rightRoundingPoints, List`1& leftRoundingPointsUV, List`1& leftPointsIndentsUV, List`1& centerPointsUV, List`1& rightPointsIndentsUV, List`1& rightRoundingPointsUV, Vector2& cp, float leftIndentUVX, float rightIndentUVX);
    public Mesh ODDDOCDCQO();
    private void OCOQOCDCCQ(List`1& tris, List`1& vecs, List`1& uvs, List`1& uvs1, List`1& uvs2, List`1& colors, List`1& trisTmp, List`1& vecsTmp, List`1& uvsTmp, List`1& uvsTmp1, List`1& uvsTmp2, List`1& colorsTmp, bool skipMiddles, bool weldVecs);
    private void OCQODCOQDO(List`1& tris, List`1& vecs, List`1& uvs, List`1& uvs1, List`1& uvs2, List`1& colors, List`1& trisTmp, List`1& vecsTmp, List`1& uvsTmp, List`1& uvsTmp1, List`1& uvsTmp2, List`1& colorsTmp, bool skipMiddles, bool weldVecs);
    private List`1<int> Triangulate(List`1<Vector3> vecs, List`1<Vector3> edges);
    public List`1<Vector3> OQDDOOOOQD(Vector3 p1, Vector3 p2, Vector3 p3, Vector3 p4, float tension, float res, float distance, Single& tValue);
    public void OQCDDQOCOD(List`1& splinePoints, float distance);
    public void Clear();
    public void OOODDOCOOO();
    public void OOOQQDDCCQ(ERTexture roadERTexture, Single& roadWidth, Single& leftIndent, Single& rightIndent, Single& leftUVX, Single& rightUVX, Single& leftIndentInner, Single& rightIndentInner, Single& roadOuterUVXInner, float cornerRadius);
    public static void OCDCCQQQCO(List`1<Vector3> leftPoints, List`1<Vector3> rightPoints, GameObject& surfaceMesh, Transform tr, List`1& surfaceVecs, float indentLeftStart, float indentLeftEnd, float surroundingLeftStart, float surroundingLeftEnd, float indentRightStart, float indentRightEnd, float surroundingRightStart, float surroundingRightEnd, ERModularBase baseScript, bool hasMesh);
}
public enum EasyRoads3Dv3.ERIndentAlignment : Enum {
    public int value__;
    public static ERIndentAlignment Road;
    public static ERIndentAlignment Terrain;
    public static ERIndentAlignment Surrounding;
}
public class EasyRoads3Dv3.ERLane : ValueType {
    public float position;
    public ERLaneDirection direction;
    public ERDirectionType turnDirection;
    public int laneIndex;
    public ERLane(float position, ERLaneDirection direction, int index);
    public ERLane(ERLane lane);
    public void Copy(ERLane lane);
}
public class EasyRoads3Dv3.ERLaneConnector : object {
    public Vector3 connectorStart;
    public Vector3 connectorEnd;
    public Vector3 connectorStartLocal;
    public Vector3 connectorEndLocal;
    public Vector3[] points;
    public int startLaneIndex;
    public int endLaneIndex;
    public int endConnectionIndex;
    public ERLane laneType;
    public ERDirectionType laneDirection;
    public float startOffset;
    public float endOffset;
    public float strength;
    public bool mainConnection;
    public bool stop;
    public float speedLimit;
    public float minSpeed;
    public float maxSpeed;
    public static ERLaneConnector CreateInstance();
    public static List`1<ERLaneConnector> GetLaneConnectors(ERLaneData laneData, int index);
}
public class EasyRoads3Dv3.ERLaneData : object {
    public Vector3[] points;
    public List`1<ERLaneConnector> connectors;
    public ERLane laneType;
    public int laneIndex;
    public ERLaneDirection direction;
    public static ERLaneData CreateInstance();
    public static ERLaneData OOOOCQCDDC(List`1<ERLaneData> laneData, int index);
    public bool Exists(int index, int lane);
}
public enum EasyRoads3Dv3.ERLaneDirection : Enum {
    public int value__;
    public static ERLaneDirection Left;
    public static ERLaneDirection Right;
}
public class EasyRoads3Dv3.ERLocalGrid : ScriptableObject {
    public int id;
    public string name;
    public bool gridActive;
    public bool gridGUIActive;
    public Color gridColor;
    public float gridSize;
    public float gridRadius;
    public float gridRotation;
    public Vector3 tl;
    public Vector3 bl;
    public Vector3 br;
    public float xOffset;
    public float yOffset;
    public Vector3 OOCDQCOOQC;
    public void Init(ERModularBase scr);
    public static ERLocalGrid CreateInstance(ERModularBase scr);
    public static String[] GridNames(ERModularBase scr);
    public void SetOffsets(ERModularBase scr, Vector3 pos, Vector3 v);
}
public class EasyRoads3Dv3.ERMarker : object {
    public bool activeSplineNode;
    public float leftIndent;
    public int leftIndentAlignment;
    public float rightIndent;
    public int rightIndentAlignment;
    public float leftSurrounding;
    public float rightSurrounding;
    public bool bridgeObject;
    public float bridgeStartLevelDistance;
    public float bridgeEndLevelDistance;
    public float rotation;
    public Vector3 position;
    public int controlType;
    public int rotations;
    public float circularRadius;
    public float circularAngle;
    public int circularSegments;
    public float splineStrength;
    public Vector3 direction;
    public Vector3 direction1;
    public bool followTerrainContours;
    public int startSplinePoint;
    public float startDistance;
    public float startUVY;
    public float totalDistance;
    public string totalDistanceString;
    public string angleString;
    public float rotationCenter;
    public List`1<ERSOMarker> soData;
    public ERMarkerControlType controllerType;
    public bool attachExit;
    public int exitType;
    public int exitGeometryType;
    public int startExitInt;
    public int endExitInt;
    public float startExitOffset;
    public float extrusionDistance;
    public int extrusionType;
    public float fixedDistance;
    public float connectionAngle;
    public float connectionRadius;
    public Material exitMaterial;
    public Material connectionMaterial;
    public int exitRoadType;
    public int connectionRoadType;
    public List`1<List`1<Vector3>> exitOuterVerticesExtrusion;
    public List`1<List`1<Vector3>> exitOuterVerticesFixed;
    public List`1<List`1<Vector3>> exitOuterVerticesCurve;
    public List`1<Vector3> exitInnerVertices;
    public List`1<Vector2> roadShape;
    public List`1<Vector3> roadShapeVecsGlobal;
    public float markerStartUVY;
    public Vector3 perpDir;
    public Vector3 perpDirRotated;
    public ERMarker(Vector3 pos, ERModularRoad scr, int element);
    public void SetControlType(ERMarkerControlType type);
}
public enum EasyRoads3Dv3.ERMarkerControlType : Enum {
    public int value__;
    public static ERMarkerControlType Spline;
    public static ERMarkerControlType StraightXZ;
    public static ERMarkerControlType StraightXZY;
    public static ERMarkerControlType Circular;
}
public class EasyRoads3Dv3.ERMarkerExt : ScriptableObject {
    public bool activeSplineNode;
    public float leftIndent;
    public int leftIndentAlignment;
    public float rightIndent;
    public int rightIndentAlignment;
    public float leftSurrounding;
    public float rightSurrounding;
    public float radius;
    public bool bridgeObject;
    public float bridgeStartLevelDistance;
    public float bridgeEndLevelDistance;
    public float rotation;
    public Vector3 position;
    public Vector3 oldPosition;
    public Vector3 positionTmp;
    public int controlType;
    public int controlTypeTmp;
    public int rotations;
    public float circularRadius;
    public float circularAngle;
    public int circularSegments;
    public float splineStrength;
    public Vector3 direction;
    public Vector3 direction1;
    public Vector3 rl;
    public Vector3 rr;
    public bool followTerrainContours;
    public int startSplinePoint;
    public float startDistance;
    public float startUVY;
    public float totalDistance;
    public string totalDistanceString;
    public string angleString;
    public string gradeString;
    public float rotationCenter;
    public List`1<ERSOMarkerExt> soData;
    public ERMarkerControlType controllerType;
    public float randomYPosition;
    public float randomMinYPosition;
    public float randomMaxYPosition;
    public float minRandomYPositionDistance;
    public float maxRandomYPositionDistance;
    public float randomMinRotation;
    public float randomMaxRotation;
    public float minRandomRotationDistance;
    public float maxRandomRotationDistance;
    public float prevLeftIndent;
    public float prevRightIndent;
    public float prevLeftSurrounding;
    public float prevRightSurrounding;
    public int prevControlType;
    public bool attachExit;
    public int exitType;
    public int exitGeometryType;
    public int startExitInt;
    public int endExitInt;
    public float startExitOffset;
    public float extrusionDistance;
    public int extrusionType;
    public float fixedDistance;
    public float connectionAngle;
    public float connectionRadius;
    public Material exitMaterial;
    public Material connectionMaterial;
    public int exitRoadType;
    public int connectionRoadType;
    public List`1<List`1<Vector3>> exitOuterVerticesExtrusion;
    public List`1<List`1<Vector3>> exitOuterVerticesFixed;
    public List`1<List`1<Vector3>> exitOuterVerticesCurve;
    public List`1<Vector3> exitInnerVertices;
    public Color customColor;
    public List`1<Vector2> roadShape;
    public List`1<Vector3> roadShapeVecsGlobal;
    public float roadShapeDistanceMin;
    public float roadShapeDistanceMax;
    public Vector3 perpDir;
    public Vector3 perpDirRotated;
    public float markerStartUVY;
    public List`1<Vector3> customPoints;
    public void Init(Vector3 pos, ERModularRoad scr, int element);
    public static ERMarkerExt CreateInstance(Vector3 pos, ERModularRoad scr, int element);
    public void SetControlType(ERMarkerControlType type);
    public String[] SoNames();
    public static void OOQQCOQDQC(ERMarkerExt source, ERMarkerExt target, string name);
}
public class EasyRoads3Dv3.ERMaterial : ScriptableObject {
    public int id;
    public string name;
    public double roadType1ID;
    public double roadType2ID;
    public double roadType3ID;
    public Material road1Material;
    public Material road2Material;
    public Material road3Material;
    public float connectorLength1;
    public float connectorLength2;
    public float connectorLength3;
    public float road1Stretch;
    public float road2Stretch;
    public float road3Stretch;
    public int road1StretchType;
    public int road2StretchType;
    public int road3StretchType;
    public int subdivide1;
    public int subdivide2;
    public int subdivide3;
    public float resolution;
    public bool blend;
    public float blendDistance;
    public int blendSection;
    public bool triangleStrip;
    public float triangleStripDistance;
    public float triangleStripUVStart;
    public float triangleStripUVEnd;
    public Material triangleStripMaterial;
    public void Init(ERModularBase scr);
    public static ERMaterial CreateInstance(ERModularBase scr);
    public static String[] OCQOOCOQQC(ERModularBase scr);
    public static ERMaterial OQDQOCCODO(ERModularBase scr, ERIConnector prefab, Int32& targetRoad, Int32& index);
    public static Material OOQCDDQODC(ERModularBase scr, ERIConnector prefab);
}
public class EasyRoads3Dv3.ERMath : object {
    public static Vector3 GetPosition(Vector3[] points, Vector3 position, Single& distance, Int32& currentIndex, Single& t);
}
public class EasyRoads3Dv3.ERMesh : object {
    public List`1<int> vecsInt;
    public List`1<Vector3> vecs;
    public List`1<Vector2> uv;
    public List`1<Vector2> uv2;
    public List`1<Color> colors;
    public List`1<Vector3> normals;
    public List`1<Vector4> tangents;
    public List`1<int> triangles;
    public List`1<int> triangles2;
    public List`1<int> startVecsInt;
    public List`1<Vector3> startVecs;
    public List`1<Vector2> startUv;
    public List`1<Vector2> startUv2;
    public List`1<Color> startColors;
    public List`1<Vector3> startNormals;
    public List`1<Vector4> startTangents;
    public List`1<int> startTriangles;
    public List`1<int> startTriangles2;
    public List`1<int> endVecsInt;
    public List`1<Vector3> endVecs;
    public List`1<Vector2> endUv;
    public List`1<Vector2> endUv2;
    public List`1<Color> endColors;
    public List`1<Vector3> endNormals;
    public List`1<Vector4> endTangents;
    public List`1<int> endTriangles;
    public List`1<int> endTriangles2;
    public List`1<int> suVecsInt;
    public List`1<Vector3> suVecs;
    public List`1<Vector2> suUv;
    public List`1<Vector2> suUv2;
    public List`1<Color> suColors;
    public List`1<Vector3> suNormals;
    public List`1<Vector4> suTangents;
    public List`1<int> suTriangles;
    public List`1<int> suTriangles2;
    public List`1<int> sdVecsInt;
    public List`1<Vector3> sdVecs;
    public List`1<Vector2> sdUv;
    public List`1<Vector2> sdUv2;
    public List`1<Color> sdColors;
    public List`1<Vector3> sdNormals;
    public List`1<Vector4> sdTangents;
    public List`1<int> sdTriangles;
    public List`1<int> sdTriangles2;
    public List`1<Material> materials;
    public List`1<Vector3> sVecs;
    public List`1<Vector2> sUv;
    public List`1<Vector2> sUv2;
    public List`1<Color> sColors;
    public List`1<Vector3> sNormals;
    public List`1<Vector4> sTangents;
    public List`1<int> sTriangles;
    public List`1<Vector3> sTerrainNormals;
    public List`1<List`1<Vector3>> sVecsGroups;
    public List`1<List`1<Vector2>> sUvGroups;
    public List`1<List`1<Vector2>> sUv2Groups;
    public List`1<List`1<Color>> sColorsGroups;
    public List`1<List`1<Vector3>> sNormalsGroups;
    public List`1<List`1<Vector4>> sTangentsGroups;
    public List`1<List`1<int>> sTrianglesGroups;
    public List`1<List`1<Vector3>> sTerrainNormalsGroups;
    public List`1<Vector3> sStartVecs;
    public List`1<Vector2> sStartUv;
    public List`1<Vector2> sStartUv2;
    public List`1<Color> sStartColors;
    public List`1<Vector3> sStartNormals;
    public List`1<Vector4> sStartTangents;
    public List`1<int> sStartTriangles;
    public List`1<Vector3> sEndVecs;
    public List`1<Vector2> sEndUv;
    public List`1<Vector2> sEndUv2;
    public List`1<Color> sEndColors;
    public List`1<Vector3> sEndNormals;
    public List`1<Vector4> sEndTangents;
    public List`1<int> sEndTriangles;
    public List`1<Vector3> sSuVecs;
    public List`1<Vector2> sSuUv;
    public List`1<Vector2> sSuUv2;
    public List`1<Color> sSuColors;
    public List`1<Vector3> sSuNormals;
    public List`1<Vector4> sSuTangents;
    public List`1<int> sSuTriangles;
    public List`1<Vector3> sSdVecs;
    public List`1<Vector2> sSdUv;
    public List`1<Vector2> sSdUv2;
    public List`1<Color> sSdColors;
    public List`1<Vector3> sSdNormals;
    public List`1<Vector4> sSdTangents;
    public List`1<int> sSdTriangles;
    public int startEndVecCount;
    public int middleStartVecCount;
    public int middleEndVecCount;
    public int endStartVecCount;
    public List`1<Vector3> middleEndVecs;
    public List`1<int> startEndInts;
    public List`1<int> middleStartInts;
    public List`1<int> middleEndInts;
    public List`1<int> middleStartStartInts;
    public List`1<int> middleEndEndInts;
    public List`1<int> endStartInts;
    public List`1<int> startEndIntsNC;
    public List`1<int> middleStartStartIntsNC;
    public List`1<int> middleStartIntsNC;
    public List`1<int> middleEndIntsNC;
    public List`1<int> middleEndEndIntsNC;
    public List`1<int> endStartIntsNC;
    public int OQOQODDQCCInt;
    public int ODQCDQCCODInt;
    public int middleLeftInt;
    public int middleRightInt;
    public int endLeftInt;
    public int endRightInt;
    public List`1<int> normalArray1;
    public List`1<int> normalArray2;
    public List`1<List`1<int>> normalArray1Group;
    public List`1<List`1<int>> normalArray2Group;
    public int vecCount;
    public List`1<float> zValues;
    public List`1<ZIndexArray> zValueVecIndexes;
    public List`1<float> zValuesStart;
    public List`1<ZIndexArray> zValueVecIndexesStart;
    public List`1<float> zValuesEnd;
    public List`1<ZIndexArray> zValueVecIndexesEnd;
    public List`1<float> zValuesStepUp;
    public List`1<ZIndexArray> zValueVecIndexesStepUp;
    public List`1<float> zValuesStepDown;
    public List`1<ZIndexArray> zValueVecIndexesStepDown;
    public float minZ;
    public float minMiddleZ;
    public float maxZ;
    public float maxMiddleZ;
    public float totalZDistance;
    public float offset1;
    public float offset2;
    public List`1<int> vertexBatches;
    public List`1<int> triangleBatches;
    public int lodIndex;
    public bool castShadows;
    public string name;
    public bool terrainMesh;
    public ERMesh(GameObject m_go, SideObject soScript, float minZ, Transform sourceTransform, Vector3 scale, Mesh m, Material mat, float startMin, bool rotate180);
    public void OCQQQCQQDD();
    private void OCDCDCQQDQ(GameObject m_go, SideObject soScript, float minZ, Transform sourceTransform, Vector3 scale, Mesh m, Material mat, float startMin, bool namingConvention);
    private void OCDCQCQQOC(List`1<Vector3> vecs, List`1& zValueVecIndexes, List`1& zValues);
    public void GetMiddleSementInfo(List`1<Vector3> vecs, Single& minMiddleZ, Single& maxMiddleZ, List`1& middleStartInts, List`1& middleEndInts);
    public void GetMiddleEdges(List`1<Vector3> vecs, float z, List`1& edgeInts);
    public bool OOCDOCOCQO(Vector3 v, int index, List`1<float> zV, List`1& zVIndexes);
    public void OCDQOQOCCD(int index, Vector3 v, List`1& vecsInts, List`1& vecs, List`1& uv, List`1& uv2, List`1& normals, List`1& colors, List`1& tangents, Vector2 sourceUv, Vector2 sourceUv2, Vector3 sourceNormal, Color sourceColor, Vector4 sourceTangent, Int32& tri);
    public void ODDDDDQDOQ(int index, List`1& vecsInts);
    public void InEdgePairArray(int index1, int index2, List`1& vecsInts);
    public void OQCDQOQOCQ(float adjustZ);
    public void OCDDCDODQQ(List`1& groups, List`1<int> triInts, List`1<int> edgeInts);
    public void OOQOCOQOOO(List`1<CRedge> edges, Int32& curInt);
    public bool OCCCOQOCQO(List`1<CRedge> edges, int index, int curInt);
    public bool ODDDDDQDOQ(int index, List`1<int> edgeInts);
    public bool OCDOQODCCQ(List`1<CRedge> edges, int index1, int index2);
    public void MatchEdgePairs(List`1<CRedge> startEdgePairs, List`1<CRedge> endEdgePairs, List`1& startInts, List`1& endInts, List`1& startIntsNC, List`1& endIntsNC, List`1<Vector3> startVecs, List`1<Vector3> endVecs, List`1<Vector3> startNormals, List`1<Vector3> normals, Int32& OQOQODDQCCInt, Int32& ODQCDQCCODInt);
    public void OQOCDDCQDD(List`1<List`1<int>> startGroups, List`1<List`1<int>> endGroups, List`1& startInts, List`1& endInts, List`1<Vector3> startVecs, List`1<Vector3> endVecs);
    public void ODDDOCDCQO(ERModularRoad roadScr, GameObject go, SideObject so, ERModularBase scr, bool mirrored, int sectionListIndex, List`1<int> sectionIndexes, int autoSectionStart);
    public static bool OQCQCDQDOO(ERModularRoad rd, int listIndex, int listItemIndex, SideObject so, bool mirrored);
    private void OODCCOCQOC(GameObject go, SideObject so, ERModularBase scr, List`1<Vector3> sVecs, List`1<Vector2> sUv, List`1<Vector2> sUv2, List`1<Color> sColors, List`1<Vector3> sNormals, List`1<Vector4> sTangents, List`1<int> sTriangles, List`1<int> normalArray1, List`1<int> normalArray2, List`1<Material> materials, List`1<Vector3> sTerrainNormals);
    private void OCOCOQQOOO(Int32& vecCount, List`1& intList, List`1<Vector3> vecsList, float zValue);
    private void OCODQQOCDD(List`1& targetIntList, List`1<int> sourceIntList, List`1<Vector3> targetVecs, List`1<Vector3> sourceVecs);
    public void Clear();
}
public class EasyRoads3Dv3.ERMeshCombineUtility : object {
    public static Mesh Combine(Transform container, MeshInstance[] combines, bool generateStrips);
    private static void Copy(int vertexcount, Vector3[] src, Vector3[] dst, Int32& offset, Matrix4x4 transform);
    private static void CopyNormal(int vertexcount, Vector3[] src, Vector3[] dst, Int32& offset, Matrix4x4 transform);
    private static void Copy(int vertexcount, Vector2[] src, Vector2[] dst, Int32& offset);
    private static void CopyTangents(int vertexcount, Vector4[] src, Vector4[] dst, Int32& offset, Matrix4x4 transform);
    public static void CombineMesh(GameObject go, Mesh mesh, Transform container, bool isSideObject);
    public static List`1<MeshInstance> GetCombinedInstances(List`1<CombineClass> mToMesh, Material m);
}
[AddComponentMenu("")]
public class EasyRoads3Dv3.ERMeshUtility : MonoBehaviour {
    public ERModularBase baseScript;
    public int sourceInt;
    public string name;
    public void OCQOQCDCQC();
}
[AddComponentMenu("")]
public class EasyRoads3Dv3.ERModularBase : MonoBehaviour {
    public int updateInt;
    public bool newSplatMapRestoreCode;
    public int toolbarInt;
    public int oldToolbarInt;
    public int roadToolbarInt;
    public int markerToolbarInt;
    public Texture[] menuTexs;
    public Texture[] subMenuTexs;
    public GameObject cprefab;
    public Texture nodeHandleTexture;
    public Texture lockedTexture;
    public Texture unLockedTexture;
    public Texture favOffTexture;
    public Texture favOffFreeTexture;
    public Texture favOnTexture;
    public Texture selRoadTexture;
    public Texture headerTexture;
    public Texture sceneGUITex;
    public Texture soIcon;
    public Transform roadObjectsParent;
    public Transform connectionObjectsParent;
    public GameObject OCOQDODDQQ;
    public List`1<QDQDOOQQDQODD> roadTypes;
    public int selectedRoadType;
    public int selectedNewRoadType;
    public List`1<QDQDOOQQDQODD> inspRoadTypes;
    public List`1<int> inspRoadTypeInts;
    public List`1<ERDecal> decalPresets;
    public float roadWidth;
    public Material roadMaterial;
    public Material crossingMaterial;
    public Material roundAboutMaterial;
    public Material roundAboutConnectionMaterial;
    public Material roundAboutRoadMaterial;
    public Material sidewalkMaterial;
    public Material targetMaterial;
    public Terrain sourceTerrain;
    public String[] roadMaterials;
    public String[] connectionMaterials;
    public int selectedMaterial;
    public int selectedConnectionMaterial;
    public List`1<ERMaterial> materials;
    public int selectedRoadRoadType;
    public bool roadOptions;
    public bool sidewalkOptions;
    public bool markerOptions;
    public bool showRoadSideObjects;
    public bool markerSOOptions;
    public bool roadTerrainOptions;
    public bool camFlyOver;
    public int selectedRoadMaterial;
    public int roadTextureInfoIndex;
    public Texture2D selectedRoadTexture;
    public float selectedRoadWidth;
    public float selectedRoadLeftOffset;
    public float selectedRoadRightOffset;
    public float selectedRoadLeftInnerOffset;
    public float selectedRoadRightInnerOffset;
    public int selectedCrossingMaterial;
    public int crossingTextureInfoIndex;
    public int handleSelection;
    public int positionHandleSelection;
    public bool markerDirXZ;
    public GameObject defaultCrossing;
    public GameObject defaultTCrossing;
    public GameObject defaultCulDeSac;
    public GameObject defaultRoundabout;
    public Texture2D tex;
    public Texture2D infoTexture;
    public bool showAllPrefabs;
    public bool standardPrefabsFlag;
    public bool sceneSettingsFoldOut;
    public bool sceneRoadsFoldOut;
    public bool scenePrefabsFoldOut;
    public bool sidewalksFoldOut;
    public bool terrainManagementFoldOut;
    public bool importRoadDataFoldOut;
    public bool lodGroupsFoldOut;
    public bool defaultMaterialsFoldOut;
    public bool aiTrafficFoldout;
    public bool kmlFlag;
    public bool osmFlag;
    public bool useOSMHeights;
    public float heightRatio;
    public bool dynamicPrefabsFoldOut;
    public bool customPrefabsFoldOut;
    public List`1<ERConnectionGUIStatus> dynamicFavList;
    public List`1<ERConnectionGUIStatus> customFavList;
    public float prefabsDisplayType;
    public bool ignoreTerrainAlerts;
    public double osmTerrainTopLon;
    public double osmTerrainBottomLon;
    public double osmTerrainLeftLat;
    public double osmTerrainRightLat;
    public float terrainMinIndent;
    public float minIndent;
    public float minSurrounding;
    public float maxIndentSurrounding;
    public float terrainY;
    public float terrainDetailSplatX;
    public float terrainDetailSplatY;
    public Vector3 detailOffsetVec;
    public float raise;
    public Vector3 baseVector;
    public bool mirrorCrossings;
    public String[] terrainNames;
    public Terrain[] terrainObjects;
    public String[] terrainSplatTextures;
    public Terrain activeTerrain;
    public float activeTerrainY;
    public int selectedTerrain;
    public bool selectedRoadsOnly;
    public bool terrainDone;
    public bool enableBackWithoutRestore;
    public float detailDistance;
    public float treeDistance;
    public bool doHeightmap;
    public bool doTrees;
    public bool soTrees;
    public bool doDetail;
    public Rect terrainRect;
    public List`1<GameObject> tunnelObjects;
    public List`1<GameObject> surfaceObjects;
    public float preserveTerrainFloat;
    public float terrainSmoothIndentDistance;
    public float terrainSmoothSurroundingDistance;
    public int indentSmoothStep;
    public int surroundingSmoothStep;
    public bool doTangents;
    public bool doLightmapUVs;
    public bool doLODGroups;
    public bool doSplatmaps;
    public int sLayer;
    public List`1<Vector3> terrainHits;
    public List`1<Vector3> osmCrossingPoints;
    public List`1<CrossingCornerClass> cornerPresets;
    public List`1<SidewalkPresetClass> sidewalkPresets;
    public List`1<ERSideWalk> sidewalks;
    public int selectedSidewalk;
    public int selectedRoadTypeSidewalk;
    public int osmMotorway;
    public int osmMotorwayLink;
    public int osmTrunk;
    public int osmPrimary;
    public int osmSecondary;
    public int osmTertiary;
    public int osmUnclassified;
    public int osmResidential;
    public int osmService;
    public int osmTrack;
    public int osmPath;
    public int osmWalkway;
    public int osmRaceway;
    public int osmHighwayStringInt;
    public bool osmMotorwayFlag;
    public bool osmMotorwayLinkFlag;
    public bool osmTrunkFlag;
    public bool osmPrimaryFlag;
    public bool osmSecondaryFlag;
    public bool osmTertiaryFlag;
    public bool osmUnclassifiedFlag;
    public bool osmResidentialFlag;
    public bool osmServiceFlag;
    public bool osmTrackFlag;
    public bool osmPathFlag;
    public bool osmWalkwayFlag;
    public bool osmRacewayFlag;
    public string osmHighwayString;
    public int kmlRoadType;
    public bool lodGroups;
    public int LODLevels;
    public List`1<float> LODLevelValues;
    public List`1<float> LODLevelResolution;
    public bool embedRoadShape;
    public bool hideSurfaces;
    public bool showSurfaces;
    public bool useLightProbes;
    public bool hideLockedObjects;
    public bool ODQCODODDD;
    public bool isInBuildMode;
    public bool progressFlag;
    public int progressTerrain;
    public float progressStatus;
    public float progressMax;
    [SerializeField]
public List`1<SideObject> QOQDQOOQDDQOOQ;
    public String[] sideObjectNames;
    public int selSideObject;
    public int selSubSideObject;
    public string soID;
    public string sideObjectName;
    [SerializeField]
public int sideObjectType;
    public GameObject sideObjectSource;
    public GameObject soEndObject;
    public int sideObjectTerrainVegetationInt;
    public int prefabChildHandling;
    public float sideObjectDistance;
    public int soYAxisRotation;
    public float soSidewaysDistance;
    public int soSidewaysDistanceHandling;
    public float soDensity;
    public float soOffset;
    public int soTerrainAligment;
    public bool soCombine;
    public bool soWeld;
    public int soControllerType;
    public Material soMaterial;
    public float soXPosition;
    public float soYPosition;
    public bool soMarkerActive;
    public bool enableSOHandles;
    public bool enableShapeNodeHandles;
    public bool enableSOShapeNodeHandles;
    public bool displayCriticalPoints;
    public bool highlightRoad;
    public bool highlightIndents;
    public bool highlightSurroundings;
    public bool highlightSideObject;
    public Color highlightRoadColor;
    public Color highlightIndentColor;
    public Color highlightSurroundingColor;
    public bool onlyShowSelectedRoad;
    public List`1<GameObject> soDeformationObjects;
    public List`1<GameObject> soSplatmapObjects;
    public bool buildSOinEditMode;
    public bool tangentsInEditMode;
    public bool calculateSmoothNormals;
    public bool importSideObjectsAlert;
    public bool importRoadPresetsAlert;
    public bool importCrossingPresetsAlert;
    public bool importSidewalkPresetsAlert;
    public bool updateSideObjectsAlert;
    public bool updateRoadPresetsAlert;
    public bool updateCrossingPresetsAlert;
    public bool updateSidewalkPresetsAlert;
    public float waypointDistance;
    public List`1<ERModularRoad> RoadObjectsSoUpdates;
    public string assetsFolderID;
    public GameObject meshSurface;
    public Collider meshTerrainCollider;
    public float markerScale;
    public float markerDistance;
    public float minMarkerDistance;
    public float maxMarkerDistance;
    public bool debugFlag;
    public List`1<Vector3> leftTHandles;
    public List`1<Vector3> rightTHandles;
    public float roadNetworkY;
    public bool ignoreMinIndents;
    public Vector3 zoomStart;
    public Vector3 zoomEnd;
    public Vector3 lookAtStart;
    public Vector3 lookAtEnd;
    public Quaternion zoomRot;
    public float zoomStartTime;
    public bool hideSurfaceHandles;
    public bool dirtyBool;
    public bool dirtyOnSceneBool;
    public bool forceRoadNetworkSelect;
    public bool ODQDQDQDCO;
    public ERCrossingPrefabs OCOQDODDQQScript;
    public ERCrossings OOOQDOQCCOCrossingsScript;
    public ERCrossingPrefabs OOOQDOQCCOScript;
    public int OCOQDODDQQElement;
    public int OQCOQCOQQQ;
    public ERModularRoad OCCQOOOQQO;
    public ERModularRoad OODDQOOCOD;
    public int OCODDDQOQC;
    public int selectedRoadSOMarker;
    public int selectedMarkerNode;
    public List`1<int> selectedMarkerNodes;
    public int selectedMarkerSONode;
    public List`1<int> selectedMarkerSONodes;
    public List`1<SelectedObject> selectedObjects;
    public int selectedExitRoad;
    public bool newRoadFlag;
    public bool roadTypeUpdateFlag;
    public List`1<ERModularRoad> roadScripts;
    public List`1<ERCrossingPrefabs> prefabScripts;
    public bool globalGridActive;
    public bool gridGUIActive;
    public Color globalGridColor;
    public float globalGridSize;
    public float globalGridRadius;
    public float globalGridRotation;
    public Vector2 gridOffset;
    public Vector3 ggTL;
    public Vector3 ggBL;
    public Vector3 ggBR;
    public bool localGridActive;
    public List`1<ERLocalGrid> localGrids;
    public int selectedLocalGrid;
    public MethodInfo crMethod;
    public MethodInfo upMethod;
    public MethodInfo hmMethod;
    public MethodInfo rmMethod;
    public MethodInfo crBiomeMethod;
    public MethodInfo upBiomeMethod;
    public MethodInfo rmBiomeMethod;
    public MethodInfo thMethodGet;
    public MethodInfo thMethodSet;
    public ERSideWalk sw;
    public bool roadUpdated;
    public bool clampUVs;
    public int soCategoryInt;
    public int soRoadCategoryInt;
    public float minRoadWidth;
    public float maxRoadWidth;
    public float maxCurbHeight;
    public float minCornerRadius;
    public float maxCornerRadius;
    public GameObject SoTestObject;
    public bool lockRoadNetwork;
    public bool showNotifications;
    public bool multipleTerrainsWarning;
    public Texture2D[] OCDCDDQDQC;
    public Texture2D[] OCDCOCCCCC;
    public int textureCounter;
    public static bool AssembliesSet;
    public bool vegetationStudio;
    public bool vegetationStudioPro;
    public bool vegetationStudioActive;
    public bool vegetationStudioMaskLineActive;
    public float vegetationStudioGrassPerimeter;
    public float vegetationStudioPlantPerimeter;
    public float vegetationStudioTreePerimeter;
    public float vegetationStudioObjectPerimeter;
    public float vegetationStudioLargeObjectPerimeter;
    public bool vegetationStudioBiomeMaskActive;
    public float vegetationStudioBiomeMaskDistance;
    public float vegetationStudioBiomeMaskBlendDistance;
    public float vegetationStudioBiomeMaskNoiseScale;
    public bool aiTraffic;
    public bool aiMatchingLanesOnly;
    public bool aiconnectNonMatchinglaneCounts;
    public bool aiIgnoreConnections;
    public bool displayLaneData;
    public int rightHandDriving;
    public Color leftLaneHandleColour;
    public Color rightLaneHandleColour;
    public Color laneHandleSelectedColour;
    public float roadUvThreshold;
    public int updateQueue;
    public static bool checkPresets;
    public bool logChange;
    public bool debugMode;
    public bool RoadNetworkInitFlag;
    public static RoadUpdate onRoadUpdate;
    public static OnBuildMode onBuildModeEnter;
    public List`1<GameObject> excludeFromSelection;
    public GameObject addExcludeFromSelection;
    public Color shapeUVColor;
    public Color startCapColor;
    public Color endCapColor;
    public Material soSectionMaterial;
    public bool v32b4Flag;
    private static ERModularBase();
    public void OnBuildModeEnter();
    public void OnRoadUpdate(ERRoad road);
    public void RoadNetworkInit();
    public void UpdateQueue();
    public void SetRoadTypeList();
    public void UpdateRoadTypeStatus();
    public void OCOCQOODCO();
    public void OCQODDDCQQ();
    public void ODODOQOODO();
    public void OOCQCCCQCD();
    public void OQDQQODDCD(GameObject go, Vector3 pos);
    public void ODCDQQCQOC();
    public ERCrossingPrefabs OCDQQCQCQQ(GameObject prefab, ERModularRoad OCCQOOOQQO, int OCODDDQOQC, int connectionSegment);
    public ERCrossingPrefabs AttachConnector(ERModularRoad OCCQOOOQQO, int OCODDDQOQC);
    public void OCCDCDQOOD(ERModularRoad OCCQOOOQQO, int selectedMarker);
    public int OOOCOQQDQO(ERModularRoad OCCQOOOQQO, ERCrossingPrefabs prefabScript, int OCODDDQOQC, int startConnection, bool swapFlag);
    public int OOQQQQCCOC(string roadShapeString, List`1<string> strings, List`1<QDOODOQQDQODD> crossingElements);
    public GameObject OOQDQOOQQQ(GameObject prefab, Vector3 hitPos, GameObject& newPrefab, ERCrossingPrefabs& prefabScript, ERCrossings& crossingsScript);
    public void OQOCDOOQCQ(ERCrossingPrefabs prefabScript);
    public void OQCDDCDDQC(GameObject newPrefab, GameObject prefab);
    public void ODDQCOQCQC();
    public List`1<ERTerrain> OODQQODOOC(Boolean& multTerrainResFlag);
    public void ODDCCODOOC();
    public void OQQQDCQOOC(bool restoreTerrain);
    public void OQQOOCQQCD(Vector3 pos);
    public void OCDDQOCDCO(Vector3& pos);
    public Vector3 OQOODODDQO(Vector3 pos);
    public Vector2 GetTerrainUV(Vector3 pos);
    public Terrain OQOQDDOQOD(Vector3& pos, bool setSelected);
    public void OQCQQQDQQD();
    public void UpdateLODLevels(int levels);
    public void UpdateSideObjectsInScene();
    public void OOCDOOCQQC();
    public void OQQDDOQQOO();
    public ERRoadType[] GetRoadTypes();
    public ERRoadType GetRoadTypeByName(string name);
    public string GetNewRoadName(double id);
    public string GetRoadNameByID(double id);
    public SideObject OQCDCQCDCQ(string name);
    public void InitLoadImage(string url);
    private IEnumerator LoadImage(string url);
    public IEnumerator BuildTerrainRoutine(ERRoadNetwork roadNetwork);
    public float OCCQDCCCOD(Vector3 fwd, Vector3 targetDir, Vector3 up);
}
[AddComponentMenu("")]
public class EasyRoads3Dv3.ERModularRoad : MonoBehaviour {
    public ERModularBase baseScript;
    public string roadName;
    public bool locked;
    public double roadType;
    public QDQDOOQQDQODD rt;
    public int defaultControlType;
    public bool isCustomRoadSet;
    public bool isCustomRoad;
    public List`1<ERMarker> markers;
    public List`1<ERMarker> tmpMarkers;
    public List`1<ERMarkerExt> markersExt;
    public List`1<ERMarkerExt> tmpMarkersExt;
    public List`1<float> tValues;
    public float roadWidth;
    public float faceDistance;
    public float angleTreshold;
    public bool resolutionFlag;
    public bool angleThresholdFlag;
    public bool closedTrack;
    public float minNodeDistance;
    public int nodeWithinRange;
    public float uvTiling;
    public bool planarUVs;
    public bool flipNormals;
    public int defaultLeftSidewalk;
    public int defaultRightSidewalk;
    public bool leftSidewalkActive;
    public bool rightSidewalkActive;
    public List`1<ERSideWalkInstance> leftSidewalks;
    public List`1<ERSideWalkInstance> rightSidewalks;
    public List`1<OQQCCQCDQQ> exitRoads;
    public int selectedExit;
    public bool randomnessFlag;
    public bool randomnessMarkerFlag;
    public float randomYPosition;
    public float randomMinYPosition;
    public float randomMaxYPosition;
    public float minRandomYPositionDistance;
    public float maxRandomYPositionDistance;
    public float randomMinRotation;
    public float randomMaxRotation;
    public float minRandomRotationDistance;
    public float maxRandomRotationDistance;
    public bool vegetationStudioMaskLineActive;
    public float vegetationStudioGrassPerimeter;
    public float vegetationStudioPlantPerimeter;
    public float vegetationStudioTreePerimeter;
    public float vegetationStudioObjectPerimeter;
    public float vegetationStudioLargeObjectPerimeter;
    public bool vegetationStudioBiomeMaskActive;
    public float vegetationStudioBiomeMaskDistance;
    public float vegetationStudioBiomeMaskBlendDistance;
    public float vegetationStudioBiomeMaskNoiseScale;
    public int vertsStats;
    public int trisStats;
    public float indent;
    public float surrounding;
    public bool followTerrainContours;
    public float terrainContoursOffset;
    public List`1<Vector2> roadShape;
    public List`1<int> roadShapeIntsStart;
    public List`1<int> roadShapeIntsEnd;
    public List`1<int> roadShapeIntsStartFull;
    public List`1<int> roadShapeIntsEndFull;
    public string roadShapeString;
    public string roadShapeReversedString;
    public int roadShapeMatchCount;
    public int geoReversed;
    public int roadShapeCols;
    public bool flipRoadUVs;
    public int subSegments;
    public List`1<float> nodeDistance;
    public List`1<float> roadShapeUVs;
    public List`1<float> roadShapeUVs2;
    public List`1<bool> doConnectionTri;
    public List`1<float> randomRotations;
    public List`1<bool> hardEdge;
    public List`1<int> roadShapeMaterialInts;
    public int subMeshCount;
    public List`1<int> roadShapeMaterialIntCounts;
    public List`1<Vector3> controlPoints;
    public List`1<Vector3> splinePoints;
    public List`1<float> distances;
    public List`1<int> markerInts;
    public List`1<Vector3> insertSplinePoints;
    public List`1<Vector3> soSplinePoints;
    public List`1<Vector3> soSplinePointsLeft;
    public List`1<Vector3> soSplinePointsRight;
    public List`1<Vector3> soSplinePointsLeftClamped;
    public List`1<Vector3> soSplinePointsRightClamped;
    public List`1<float> OQCOCCQCCD;
    public List`1<float> OQQOODQCCC;
    public List`1<float> bendAngles;
    public List`1<Vector3> meshVecs;
    public List`1<Vector2> meshUVs;
    public List`1<Vector2> meshUVs2;
    public List`1<List`1<int>> tris;
    public List`1<Vector3> surfaceMeshVecs;
    public List`1<Vector3> leftIndentVecs;
    public List`1<Vector3> rightIndentVecs;
    public List`1<Vector3> middleIndentVecs;
    public List`1<Vector3> leftSurroundingVecs;
    public List`1<Vector3> rightSurroundingVecs;
    public List`1<Vector3> leftIndentVecsSV;
    public List`1<Vector3> rightIndentVecsSV;
    public List`1<bool> bridgeElement;
    public List`1<Vector3> vecsBelowTerrain;
    public List`1<Vector3> treeVecs;
    public List`1<Vector3> detailVecs;
    public List`1<int> vegetationTris;
    public List`1<bool> doLeftSurrounding;
    public List`1<bool> doRightSurrounding;
    public float totalDistance;
    public List`1<int> nodeSplinePoint;
    public string totalDistanceString;
    public ERCrossingPrefabs startPrefabScript;
    public ERCrossingPrefabs endPrefabScript;
    public int startConnectionSegment;
    public bool startConnectionFlag;
    public int endConnectionSegment;
    public bool endConnectionFlag;
    public bool startSegmentIntAdjusted;
    public bool endSegmentIntAdjusted;
    public bool tCrossingConnected;
    public Material roadMaterial;
    public Material[] roadMaterials;
    public PhysicMaterial roadPhysicsMaterial;
    public PhysicMaterial[] roadPhysicsMaterials;
    public Vector3 startDir;
    public Vector3 endDir;
    public float startAngle;
    public float endAngle;
    private int ᙃ;
    private int ᙄ;
    public int startbendLeftRight;
    public int endbendLeftRight;
    public float connectionAdjustDistanceStart;
    public float connectionAdjustDistanceEnd;
    public Vector3 pivotp;
    public Vector3 p1;
    public Vector3 p2;
    public Vector3 p3;
    public Vector3 p4;
    public Vector3 p5;
    public Vector3 p6;
    public Vector3 p7;
    public Vector3 cp1;
    public Vector3 cp2;
    public Vector3 cp3;
    public Vector3 cp4;
    public Vector3 cp5;
    public Vector3 cp6;
    public Vector3 cp7;
    public Vector3 cp8;
    public Vector3 cp9;
    public Vector3 cpcenter;
    public Vector3 p1Circle;
    public Vector3 p2Circle;
    public float cpradius;
    public float cpangle;
    public Vector3 dp1;
    public Vector3 dp2;
    public Vector3 dp3;
    public Vector3 dp4;
    public List`1<Vector3> segPoints;
    public List`1<Vector3> testPoints;
    public List`1<Vector3> testPoints2;
    public Vector3 OQOQODDQCC;
    public Vector3 ODQCDQCCOD;
    public Vector3 endLeft;
    public Vector3 endRight;
    public Mesh testmesh;
    public GameObject surfaceMesh;
    public Vector3 sv1;
    public Vector3 sv2;
    public Vector3 prefabIndentLeft;
    public Vector3 prefabIndentRight;
    public Vector3 roadIndent1;
    public static int ODQQCDOQOD;
    public static int OCOQCCDDQC;
    public static int ODCDCCQCQC;
    public static int OQDCDCOCQC;
    public static int OQQQOQOQOQ;
    public static int OQOQDOCQCD;
    public Vector3 tmpPerpCP;
    public Vector3 tmpCP;
    private int ᙅ;
    private int 4AAAA;
    public float splinePos;
    public float camHeight;
    public Vector3[] flyOverPoints;
    public Vector3 splinePosV3;
    public List`1<float> markerDistances;
    public string osmRoadType;
    public List`1<ERSORoad> soData;
    public List`1<ERSORoadExt> soDataExt;
    public String[] sideObjectNames;
    public int selectedSO;
    public bool rebuildSos;
    public bool sosCleared;
    public bool isSideObject;
    public int startOffsetActiveMarker;
    public int endOffsetActiveMarker;
    public float leftToCenterPerc;
    public ERRoad road;
    public bool splatMapActive;
    public int splatIndex;
    public int expandLevel;
    public int smoothLevel;
    public float splatOpacity;
    public int layer;
    public bool isStatic;
    public string tag;
    public int tagInt;
    public bool castShadow;
    public bool fadeInFlag;
    public float fadeInDistance;
    public bool fadeOutFlag;
    public float fadeOutDistance;
    public bool doSurroundingSurfaces;
    public bool terrainDeformation;
    public bool snapToTerrain;
    public List`1<ERSOSection> soSectionList1;
    public List`1<ERSOSection> soSectionList2;
    public List`1<ERSOSection> soSectionList3;
    public List`1<ERSOSection> soSectionList4;
    public List`1<ERSOSection> soSectionList5;
    public List`1<ERSOSection> soSectionList6;
    public List`1<ERSOSection> soSectionList7;
    public List`1<ERSOSection> soSectionList8;
    public bool snapVertices;
    public float snapOffset;
    public bool hasMeshCollider;
    public bool isUpdated;
    public bool QDDDQODQQDQDQQD;
    public int uv4Type;
    public float detailDistance;
    public bool startDecalCollapsed;
    public ERDecal startDecal;
    public ERDecal endDecal;
    public GameObject startDecalPrefab;
    public GameObject startDecalPrefabSource;
    public bool endDecalCollapsed;
    public GameObject endDecalPrefab;
    public GameObject endDecalPrefabSource;
    public int startDecalID;
    public int endDecalID;
    public Vector3 lastForward;
    public bool roadUpdate;
    public Bounds bounds;
    public List`1<Vector3> debugVecs;
    public List`1<float> debugFloats;
    public Vector3 exitExtrudeEnd;
    public Vector3 exitFixedEnd;
    public Vector3 exitSplitEnd;
    public Texture2D splatTextureMask;
    public bool lockUVs;
    public List`1<ERLaneData> laneData;
    public bool oneWayRoad;
    public ERLaneDirection oneWayDirection;
    public bool ODDQCOCDQQ(ERCrossingPrefabs prefabScript);
    public void ODQCQCDCDQ(List`1<ERDecal> decalPresets);
    public void OOQOCCOOOD();
    public float GetRoadWidth();
    public void OQQOCOQDCQ(Vector3 pos);
    public int OCDQCCCDCC(Vector3 pos);
    public void GetInsertPointExt(Vector3 pos, Int32& n1, int marker);
    public void OCOOCCODDD(Vector3 pos, Int32& n1);
    public void OOODDDDQQO(Vector3 pos, Int32& n1, int selectedMarker, bool sameRoad);
    public int OQCCQDDOQD(Vector3 pos);
    public int OOCDODCOOD(Vector3 pos, int selectedMarker);
    public int HandleAddMarkerAtStart(Vector3 pos, int selectedMarker);
    public void ODDDCDQCCO(ERCrossingPrefabs ODCQDOOOCC, int targetElement, bool reverse, bool uvReverse, bool UpdateResolutionFlag);
    public void OOOCDCQQCO(bool ignorePrefabAlignment, int selectedMarker);
    public void PrintRoadShape(List`1<Vector2> lst);
    public void OCQOQCDCQC(bool ignorePrefabAlignment, bool forceAutoRotate);
    private void OCODCOOQOC(List`1& vecs, List`1& uvs, List`1& uvs2, int cols, Int32& addedRows, List`1& isPlanar, List`1& colors, Single& uv, Single& uv4);
    public void OCDCOOQOQD(Mesh m);
    public void OQOOOOOOCQ(ERDecal decal, GameObject& decalPrefab, string name);
    public float ODCDOQOOOO(ERDecal decal, float roadWidth);
    public void OOOCOODQCO(string type);
    public void OQOCCDCCDD(GameObject decal, int index);
    public float OCDDDDQDQQ(int startEnd);
    public Vector3[] AdjustNormals(Vector3[] normals);
    public void AdjustPrefabNormals(List`1<int> roadInts, List`1<int> prefabInts, Vector3[] normals, GameObject prefab, Vector3[] verts);
    public bool OQCDCDOOCD(Vector3 pTarget, Vector3 pSource, Vector3 pCheck);
    public void OODCOQOQOD(List`1& surfaceVecs, ERCrossingPrefabs prefabScript, Boolean& startSurfacesSafe, float distance, float minIndent);
    public void ODOCCQDCQO(List`1& surfaceVecs, ERCrossingPrefabs prefabScript, int el, Boolean& surfacesSafe, float distance, float minIndent);
    public bool OQCODQODCO(Vector3 ODCQDOOOCCIndent, Vector3 otherPrefabIndent, Vector3 v);
    public void OCQOQQCDOD(List`1<Vector3> surfaceVecs, List`1<Vector2> uvs, int h, List`1<bool> doBridge, Vector3 firstDir, Vector3 lastDir, float indent, float surrounding, List`1<bool> tunnelSegments);
    public void InterpolateSurfaces(List`1& surfaceVecs, List`1& uvs, List`1& tris, Vector3 dir, int vecCount, int startEnd, float indent, float surrounding);
    public void OOCCDCDCQD();
    public List`1<Vector3> OQDDOOOOQD(List`1<ERMarkerExt> markersExt, float faceDist, bool ignorePrefabAlignment, List`1& tValues, List`1& markerDistances, bool forceAutoRotate, List`1& rotationArray, List`1& bendAngles);
    public void OCQOOCCQDD(List`1<ERMarkerExt> tmpMarkers, int j, Vector3[] tr, Vector3 circleDir, float totalDist, Vector3& startCP, int startMarker, List`1<Vector3> p);
    public void OQDOQOCDDQ(List`1<ERMarkerExt> tmpMarkersExt, int j, Vector3[] tr, Vector3& endCP, int startMarker);
    public void OOCCQCCDQC(Vector3& endCP, Vector3 curV3, Vector3 nextV3, Vector3 nextNextV3);
    public List`1<float> OQDOOOQODD(List`1<float> tValues, List`1<float> markerDistances, List`1<ERMarkerExt> markers, int startMarker, int endMarker, List`1& OQQOODQCCC, List`1<float> randomRotations);
    public void RoadSmoothness(float curDist, ERMarkerExt marker, float totalDistance, Single& randomYDistanceStart, Single& randomYDistanceEnd, Single& randomYDistanceMiddle, Vector3& randomYDistanceV3, Vector3& v, Single& currentRandomYDistance, Single& randomRotationStart, Single& randomRotationEnd, Single& randomRotationMiddle, Vector3& randomRotationV3, Single& currentRandomRotation, List`1& rotationArray);
    public List`1<List`1<Vector2>> GetRoadShapeValues(List`1<float> tValues, List`1<float> markerDistances, List`1<ERMarkerExt> markers, int startMarker, int endMarker, List`1<Vector2> roadShape);
    public List`1<float> GetSurfaceValues(List`1<float> tValues, List`1<float> markerDistances, List`1<ERMarkerExt> markers, int startMarker, int endMarker, List`1& leftIndents, List`1& rightIndents, List`1& leftSurrounding, List`1& rightSurrounding, float minRequiredIndent);
    public bool OCCQQDDDQC(SideObject obj, bool flag);
    public bool ODQCOQQDCD(SideObject obj, int marker, bool flag);
    public bool ERSetSideObjectOffset(SideObject obj, int marker, OffsetPosition position, float value);
    public bool ODQCOQQDCD(SideObject obj, Int32[] markers, bool flag);
    public List`1<Vector3> OQOQDCODCD(bool flag);
    public void OQOQDQCDCQ();
    public List`1<float> ODQQOQQDOO(Vector3[] tr);
    public Vector3 OOOOQCODCQ(float offset);
    public static Vector3 OODODQQQCD(Vector3 P0, Vector3 P1, Vector3 P2, Vector3 P3, float t, float tension);
    public Vector3 OCCDDOCCDQ(int startend, ERCrossingPrefabs prefab);
    public void OQDQOOQODD(bool lineMask, bool biomeMask);
    public void SetMarkerShape(List`1<Vector2> conVecs, Vector3 scale, ERCrossingPrefabs prefab, int connectionIndex);
    public void ODQOCQCCDC(ERIndentAlignment value, int marker, ERRoadSide type);
    public ERIndentAlignment ERGetIndentAlignment(int marker, ERRoadSide type);
    public void FlipRoadUVs(bool update);
    public ERRoadType GetRoadType(ERRoadType[] roadTypes);
}
public class EasyRoads3Dv3.ERPoint : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private double ᙂ;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private double ᙃ;
    public double x { get; public set; }
    public double y { get; public set; }
    public ERPoint(double x, double y);
    [CompilerGeneratedAttribute]
public void set_x(double value);
    [CompilerGeneratedAttribute]
public double get_x();
    [CompilerGeneratedAttribute]
public void set_y(double value);
    [CompilerGeneratedAttribute]
public double get_y();
}
[AddComponentMenu("")]
public class EasyRoads3Dv3.ERPrefab : MonoBehaviour {
    public bool isRoadType;
    public bool isSidewalk;
}
[AddComponentMenu("")]
public class EasyRoads3Dv3.ERPrefabInstance : MonoBehaviour {
    public SideObject so;
    public GameObject prefab;
    public ERSORoadExt soData;
    public double id;
    public ERModularRoad roadScript;
    public bool buildFlag;
    public bool locked;
    public bool child;
    public int sectionIndex;
    public void Copy(ERPrefabInstance source);
}
public class EasyRoads3Dv3.ERRoad : object {
    public ERModularRoad roadScript;
    public GameObject gameObject;
    public string str;
    public ERRoad(ERModularRoad scr);
    public void AddInititialMarkers(Vector3 pos);
    public void AddMarker(Vector3 pos);
    public void ClampUVs(bool value);
    public void FlipTexture();
    public void AddMarkers(Vector3[] pos);
    public void InsertMarker(Vector3 pos);
    public void InsertMarkerAt(Vector3 pos, int index);
    public void DeleteMarker(int i);
    public void SetLayer(int layer);
    public void SetTag(string tag);
    public void SetWidth(float width);
    public float GetWidth();
    public ERRoadType GetRoadType(ERRoadType[] roadTypes);
    public ERRoadType GetRoadType();
    public bool SetRoadType(ERRoadType roadType);
    public bool SetMarkerControlType(int marker, ERMarkerControlType type);
    public bool SetSplineStrength(int marker, float strength);
    public float GetSplineStrength(int marker);
    public void IsSideObject(bool isSideObject);
    public ERRoad InsertIConnector(int index);
    public ERRoad InsertIConnector(int index, string connectionName);
    public ERRoad InsertIConnector(int index, string connectionName, ERConnection& connection);
    private ERRoad InsertIConnectorCore(int index, ERCrossingPrefabs& pScript);
    public ERRoad SplitRoad(int markerIndex);
    [EditorBrowsableAttribute("1")]
private ERModularRoad SplitRoadExt(int markerIndex);
    public void SetSideObjects(List`1<ERSORoadExt> soDataExt);
    public void SetSplatmap(bool active);
    public void SetSplatmap(bool active, int splatIndex, int expand, int smoothLevel, float opacity);
    public void SetMaterial(Material mat);
    public void SetMarkerPosition(int marker, Vector3 vec);
    public void SetResolution(float res);
    public void IsStatic(bool value);
    public bool IsStatic();
    public float GetResolution();
    public void SetAngleThreshold(float res);
    public float GetAngleTreshold(float res);
    public bool ClosedTrack(bool value);
    public void FollowTerrainContours(bool value);
    [ObsoleteAttribute("obsolete")]
public void SetFollowTerrainContoursOffset(float value);
    public void FollowTerrainContourThreshold(float value);
    public void FollowTerrainContours(int markerIndex, bool value);
    public bool IsClosedTrack();
    public void SetMarkerPositions(Vector3[] vecs);
    public void SetMarkerPositions(Vector3[] vecs, int index);
    public Vector3 GetMarkerPosition(int marker);
    public Vector3[] GetMarkerPositions();
    public int GetMarkerCount();
    public void SetMarkerTilting(float value, int index);
    public float GetMarkerTilting(int index);
    public void SetMarkerTiltingCenter(float value, int index);
    public float GetRadius(int markerIndex);
    public float GetMarkerTiltingCenter(int index);
    public Color GetVertexColor(int index);
    public void SetVertexColor(int index, Color color);
    public void SetDistances();
    public Vector3 GetPosition(float distance, Int32& currentElement);
    public Vector3 GetLookatSmooth(float distance, int currentElement);
    [ObsoleteAttribute("obsolete")]
public Vector3 GetLookatAtDistanceSmooth(float distance, Int32& currentElement);
    public int GetMarkerByPoint(int el);
    public Vector3[] GetSplinePointsCenter();
    public Vector3[] GetSplinePointsRightSide();
    public Vector3[] GetSplinePointsRightSideExt();
    public Vector3[] GetSplinePointsLeftSide();
    public float SetIndent(float value, int marker);
    public float SetIndent(float value, int marker, ERRoadSide type);
    [ObsoleteAttribute("obsolete")]
public float SetRightIndent(float value, int marker);
    [ObsoleteAttribute("obsolete")]
public float SetLeftIndent(float value, int marker);
    public float SetSurrounding(float value, int marker);
    public float SetSurrounding(float value, int marker, ERRoadSide type);
    public void SetIndentAlignment(ERIndentAlignment value, int marker, ERRoadSide type);
    public ERIndentAlignment GetIndentAlignment(int marker, ERRoadSide type);
    [ObsoleteAttribute("obsolete")]
public float SetRightSurrouding(float value, int marker);
    [ObsoleteAttribute("obsolete")]
public float SetLeftSurrouding(float value, int marker);
    public Vector3[] GetRightIndentPoints();
    public Vector3[] GetLeftIndentPoints();
    public Vector3[] GetRightSurroundingPoints();
    public Vector3[] GetLeftSurroudingPoints();
    [ObsoleteAttribute("obsolete")]
public float GetLength();
    public float GetDistance();
    public float GetDistance(int markerIndex);
    public void SideObjectSetActive(SideObject obj, bool value);
    public void SideObjectMarkerSetActive(SideObject obj, int marker, bool value);
    public void SideObjectMarkerSetActive(SideObject obj, Int32[] markers, bool value);
    public void SetSideObjectOffset(SideObject obj, int marker, OffsetPosition position, float value);
    public void SetTerrainDeformation(bool value);
    public void SetTerrainDeformation(int markerIndex, bool value);
    public void SetMeshCollider(bool flag);
    public void Refresh();
    public ERConnection GetConnectionAtStart();
    public GameObject GetConnectionObjectAtStart();
    public ERConnection GetConnectionAtStart(Int32& connectionIndex);
    public ERConnection GetConnectionObjectAtEnd();
    public ERConnection GetConnectionAtEnd();
    public ERConnection GetConnectionAtEnd(Int32& connectionIndex);
    public GameObject GetConnectionObjectAtEnd(Int32& connection);
    public bool ConnectionCheck(ERCrossingPrefabs prefab, int index, int startEnd);
    public bool ConnectToStart(ERConnection connectionObject, int connectionIndex);
    public bool ConnectToStart(ERConnection connectionObject, int connectionIndex, bool autoAlign);
    public bool ConnectToStartExt(ERConnection connectionObject, int connectionIndex, bool autoAlign);
    public bool ConnectToEnd(ERConnection connectionObject, int connectionIndex);
    public bool ConnectToEnd(ERConnection connectionObject, int connectionIndex, bool autoAlign);
    public bool ConnectToEndEx(ERConnection connectionObject, int connectionIndex, bool autoAlign);
    public ERConnection AttachToStart(ERConnection connectionObject);
    public ERConnection AttachToEnd(ERConnection connectionObject);
    public ERConnection AttachToStart(ERConnection OQQCOQOCDO, int connectionIndex);
    public ERConnection AttachToEnd(ERConnection connectionInstance, int connectionIndex);
    public bool ConnectionMatch(ERConnection connection);
    public void SetCustomMarkerPoints(int markerIndex, List`1<Vector3> points);
    public ERConnection InsertConnector(ERConnection connectionObject, int markerIndex, int connectionIndex1, int connectionIndex2, ERRoad& road);
    public void UnConnectStart();
    public void UnConnectEnd();
    public bool ConnectionMatch(ERConnection connection, int connectionIndex);
    public void SnapToTerrain(bool flag);
    public void SnapToTerrain(bool flag, float offset);
    public string GetName();
    public void SetName(string name);
    public Vector2[] GetShapeNodes();
    public Vector2[] GetRoadShapeNodes(int markerIndex);
    public void SetRoadShapeNodes(int markerIndex, Vector2[] nodes);
    public void SetRoadShapeNodes(Int32[] markerIndexes, Vector2[] nodes);
    public void Clear();
    public void Destroy();
}
public class EasyRoads3Dv3.ERRoadNetwork : object {
    public ERModularBase roadNetwork;
    public bool isInBuildMode;
    public string str;
    public static RoadUpdateCallback onRoadUpdate;
    public static BuildModeCallback onBuildModeEnter;
    public static EditModeCallback onEditModeEnter;
    public static void OnBuildModeEnter();
    public static void OnEditModeEnter();
    public static void OnRoadUpdated(ERRoad road);
    public void GetTerrainData();
    public ERTrafficDirection GetTrafficDirection();
    public void Translate(Vector3 pos);
    public void CenterPivotPoints();
    public ERRoad[] GetRoads();
    public ERRoad GetRoadByName(string name);
    public ERRoad GetRoadByGameObject(GameObject go);
    public ERRoad CreateRoad(string roadName);
    public ERRoad CreateRoad(string roadName, Vector3[] markers);
    public ERRoad CreateRoad(string roadName, ERRoadType roadType);
    public ERRoad CreateRoad(string roadName, ERRoadType roadType, Vector3[] markers);
    public ERModularRoad InitRoad(string roadName, ERRoadType roadType, Material roadMaterial);
    public void AddInititialMarkers(ERRoad road, Vector3[] markers);
    public void AddIntersection(ERCrossingPrefabs crossing, GameObject crossingPrefab);
    public void BuildRoadNetwork(bool splatmaps, bool trees, bool detail, ERRoad[] roads);
    public void BuildRoadNetwork(bool splatmaps, bool trees, bool detail);
    public void BuildRoadNetwork();
    public void DoBuildRoadNetwork();
    public void RestoreRoadNetwork();
    public ERRoadType[] GetRoadTypes();
    public ERRoadType GetRoadTypeByName(string name);
    public SideObject GetSideObjectByName(string name);
    public ERRoadType AddRoadType();
    public void HideWhiteSurfaces(bool flag);
    public ERConnection[] GetConnections();
    public ERConnection GetConnectionByName(string name);
    public ERConnection[] LoadConnections();
    [ObsoleteAttribute("obsolete")]
public ERConnection GetSourceConnectionByName(string name);
    public ERConnection GetConnectionPrefabByName(string name);
    public ERConnection InstantiateConnection(ERConnection OQQCOQOCDO, string name, Vector3 position, Vector3 euler);
    public void SetRaiseOffset(float value);
    public ERRoad OODOOOQQCO(ERRoad road);
    public float GetRaiseOffset();
    public void ClampUVs(bool clamp);
    public ERRoad ConnectRoads(ERRoad road1, ERRoad road2);
    public ERRoad ConnectRoads(ERRoad road1, int marker1, ERRoad road2, int marker2);
    private bool CheckRoads(ERRoad road1, ERRoad road2, String& str);
    public static void SetTerrainNormals(Mesh m, GameObject go);
    public void Refresh();
    public void FinalizeObjects();
}
public class EasyRoads3Dv3.ERRoadNetworkObject : MonoBehaviour {
}
public class EasyRoads3Dv3.ERRoadShape : ValueType {
    public List`1<Vector2> nodes;
    public List`1<bool> hardEdge;
    public int priorityNodeIndexLeft;
    public int priorityNodeIndexRight;
    public List`1<Vector3> nodesV3;
    public List`1<ERLane> lanes;
    public int leftLanes;
    public int rightLanes;
    public bool symmetrical;
    public float leftSidewalkOffset;
    public float rightSidewalkOffset;
    public int outerLaneMarkingLeftIndex;
    public bool includeOuterlaneLeftInShape;
    public bool includeOuterlaneRightInShape;
    public int outerLaneMarkingRightIndex;
    public int outerOuterLaneMarkingLeftIndex;
    public int outerOuterLaneMarkingRightIndex;
    public int selectedNode;
    public int selectedLaneNode;
    public int isSymmetrical;
    public bool isset;
    public ERRoadShape(float width);
    public void OCCQQDOQOD(List`1<Vector2> _nodes);
    public void Copy(ERRoadShape shape);
    public void IsSymmetrical();
}
public enum EasyRoads3Dv3.ERRoadSide : Enum {
    public int value__;
    public static ERRoadSide Left;
    public static ERRoadSide Right;
    public static ERRoadSide Both;
}
public class EasyRoads3Dv3.ERRoadType : object {
    public double id;
    public string roadTypeName;
    public List`1<Vector2> roadShape;
    public List`1<Vector2> roadShapeExt;
    public List`1<bool> doConnectionTri;
    public List`1<float> roadShapeUVs;
    public List`1<float> roadShapeExtUVs;
    public List`1<float> roadShapeUVs2;
    public List`1<bool> hardEdge;
    public float roadWidth;
    public float faceDistance;
    public float angleTreshold;
    public bool sidewalks;
    public float sidewalkHeight;
    public float sidewalkWidth;
    public Material roadMaterial;
    public PhysicMaterial roadPhysicsMaterial;
    public Material connectionMaterial;
    public bool isSideObject;
    public List`1<ERSORoad> soData;
    public List`1<ERSORoadExt> soDataExt;
    public List`1<ERSORoadLog> soDataLog;
    public int layer;
    public string tag;
    public bool hasMeshCollider;
    public bool terrainDeformation;
    private ERRoadShape ᙃ;
    public void Update();
    public static QDQDOOQQDQODD GetRoadType(ERRoadType t, ERModularBase baseScript);
}
public enum EasyRoads3Dv3.ERRoadWayType : Enum {
    public int value__;
    public static ERRoadWayType Primary;
    public static ERRoadWayType Secondary;
    public static ERRoadWayType Tertiary;
    public static ERRoadWayType Path;
    public static ERRoadWayType MotorwayRamp;
}
public class EasyRoads3Dv3.ERRoundaboutElement : object {
    public float roadWidth;
    public float prevRoadWidth;
    public int roundingSegments;
    public bool lockLeftRightRoundingRadius;
    public float leftRoundingRadius;
    public float prevLeftRoundingRadius;
    public float rightRoundingRadius;
    public float prevRightRoundingRadius;
    public float connectionLength;
    public int centerInt;
    public int prevCenterInt;
    public float positionPercentage;
    public int leftOuterInt;
    public int rightOuterInt;
    public int intsFromCenter;
    public List`1<Vector3> leftOuterSegments;
    public List`1<Vector3> leftInnerSegments;
    public List`1<Vector3> rightOuterSegments;
    public List`1<Vector3> rightInnerSegments;
    public List`1<Vector2> leftOuterSegmentsUVs;
    public List`1<Vector2> leftInnerSegmentsUVs;
    public List`1<Vector2> rightOuterSegmentsUVs;
    public List`1<Vector2> rightInnerSegmentsUVs;
    public List`1<List`1<Vector3>> leftSidewalkV3;
    public List`1<List`1<Vector3>> rightSidewalkV3;
    public List`1<List`1<Vector2>> leftSidewalkUV;
    public List`1<List`1<Vector2>> rightSidewalkUV;
    public List`1<List`1<int>> leftSidewalkTris;
    public List`1<List`1<int>> rightSidewalkTris;
    public List`1<int> leftSidewalkNormalsStart;
    public List`1<int> leftSidewalkNormalsEnd;
    public List`1<int> rightSidewalkNormalsStart;
    public List`1<int> rightSidewalkNormalsEnd;
    public List`1<List`1<int>> roadConnectionTris;
    public List`1<Vector3> leftSidewalkSourceVecs;
    public List`1<Vector3> rightSidewalkSourceVecs;
    public Vector3 outerCenterPoint;
    public List`1<Vector3> innerRoundaboutPoints;
    public List`1<Vector2> innerRoundaboutUVs;
    public bool leftFlag;
    public bool rightFlag;
    public bool blendFlag;
    public Material roadMaterial;
    public Material connectionMaterial;
    public int prefabElement;
    public List`1<int> connectionVecInts;
    public List`1<int> fullConnectionVecInts;
    public Vector3 centerPoint;
    public Vector3 controlPointV3;
    public List`1<Vector2> roadShapeVecs;
    public string roadShapeVecsString;
    public List`1<float> roadShapeUVY;
    public List`1<int> blendCornerPointInts;
    public List`1<float> blendCornerPointWeights;
    public Vector3 sceneSelectionV3;
    public Vector3 sceneSelectionV3Global;
    public List`1<Vector3> rightIndentvecs;
    public List`1<Vector3> rightSurroundingvecs;
    public List`1<Vector3> leftIndentvecs;
    public List`1<Vector3> leftSurroundingvecs;
    public int rightIndentBorderInt;
    public int leftIndentBorderInt;
    public double roadType;
    public double prevRoadType;
    public double roadTypeTimestamp;
    public double prevTimestamp;
}
[AddComponentMenu("")]
public class EasyRoads3Dv3.ERRoundabouts : MonoBehaviour {
    public float roundAboutRadius;
    public float prevRoundAboutRadius;
    public float roundAboutResolution;
    public float prevRoundAboutResolution;
    public float rDist;
    public Vector3 raStartPos;
    public float roundaboutWidth;
    public float prevRoundaboutWidth;
    public int roadTypeInt;
    public int prevRoadTypeInt;
    public float roadWidth;
    public float prevRoadWidth;
    public bool lockLeftRightRoundingRadius;
    public float leftRoundingRadius;
    public float prevLeftRoundingRadius;
    public float rightRoundingRadius;
    public float prevRightRoundingRadius;
    public int roundingSegments;
    public float connectionLength;
    public float maxRoadWidth;
    public float maxRoundingRadius;
    public List`1<Vector3> meshVecs;
    public List`1<Vector3> mainRightPoints;
    public List`1<Vector3> mainCenterPoints;
    public List`1<Vector3> mainLeftPoints;
    public List`1<Vector3> OCCDQOCCDQ;
    public List`1<Vector2> mainRightPointsUVs;
    public List`1<Vector2> mainCenterPointsUVs;
    public List`1<Vector2> mainLeftPointsUVs;
    public List`1<Vector2> OCCDQOCCDQUVs;
    public List`1<Vector3> innerRoundaboutSidewalkV3;
    public List`1<Vector2> innerRoundaboutSidewalUV;
    public List`1<int> innerRoundaboutSidewalTris;
    public Material innerRoundaboutSidewalkMaterial;
    public List`1<int> innerRoundaboutSidewalkIntsStart;
    public List`1<int> innerRoundaboutSidewalkIntsEnd;
    public int innerSidewalkSegments;
    public Vector3 leftPoint;
    public Vector3 leftPoint1;
    public Vector3 rightPoint;
    public Vector3 rightPoint1;
    public Vector3 centerOnLine;
    public Vector3 leftOuterPoint;
    public Vector3 rightOuterPoint;
    public Vector3 pl;
    public Vector3 pr;
    public List`1<Vector3> edgePoints;
    public int newSegmentInt;
    public int prevNewSegmentInt;
    public List`1<ERRoundaboutElement> connections;
    public String[] QDOOOQOOQQQQD;
    public int selectedConnection;
    public int activeConnection;
    public int tmpSelectedConnection;
    public int minStartInt;
    public int maxEndInt;
    public int centerInt;
    public int leftOuterInt;
    public int rightOuterInt;
    public List`1<Vector3> leftOuterSegments;
    public List`1<Vector3> leftInnerSegments;
    public List`1<Vector3> rightOuterSegments;
    public List`1<Vector3> rightInnerSegments;
    public List`1<Vector2> leftOuterSegmentsUVs;
    public List`1<Vector2> leftInnerSegmentsUVs;
    public List`1<Vector2> rightOuterSegmentsUVs;
    public List`1<Vector2> rightInnerSegmentsUVs;
    public Vector3 outerCenterPoint;
    public bool blendFlag;
    public Material mainRoadMaterial;
    public Material roadMaterial;
    public Material connectionMaterial;
    public Material defaultConnectionMaterial;
    public double roadType;
    public double roadTypeTimestamp;
    public List`1<Vector3> innerRoundaboutPoints;
    public List`1<Vector2> innerRoundaboutUVs;
    public float innerSegmentDistance;
    public float innerSidewalkWidth1;
    public float innerSidewalkWidth2;
    public float innerCurbHeight;
    public float innerCurbDepth;
    public bool innerBeveledCurb;
    public float innerBeveledHeight;
    public float innerBeveledDepth;
    public bool innerOuterCurb;
    public bool innerRoadSideCurbUVControl;
    public bool innerOuterSideCurbUVControl;
    public Material innerSidewalkMaterial;
    public List`1<float> innerSidewalkUVs;
    public List`1<float> innerCurbUVs;
    public int selectedCorner;
    public int selectedCornerPreset;
    public int selectedSidewalkPreset;
    public string sidewalkPresetName;
    public int innerRoundaboutPreset;
    public bool leftFlag;
    public bool rightFlag;
    private bool ᙃ;
    public ERCrossingPrefabs prefabScript;
    public QDOODOQQDQODD connectionElement;
    public ERModularBase baseScript;
    public bool isSceneObject;
    public bool guiChanged;
    public string crossingName;
    public bool activeSidewalks;
    public bool newConnectionFlag;
    public Vector3 testIndentMiddlePoint;
    public List`1<QDQDOOQQDQODD> roadTypesDynamic;
    private void Start();
    public bool UpdateToRoadType(QDQDOOQQDQODD sourcePreset);
    public void ResetData();
    public void ODQDCCOQOD();
    public void OOQQDCCCCC();
    public void GetConnectionData();
    public void UpdateMinMaxInts();
    public void ChecknewSegmentInt();
    public int GetRoadPresetInt(double id);
    public void OCQCQODOQC(ERRoundabouts source, bool refreshFlag);
    public void OCDCOQOOQO();
    public void ODCDCDDOCC(List`1<SidewalkPresetClass> sidewalkPresets, int el);
    public void OOCDDOQDDO();
    public void OQQCDOQOOQ();
    public void OQCQDQDCOD(int currentIndex);
    public void OQQOCQQDOQ(List`1& OCCDQOCCDQ, List`1& innerSegmentPoints, int leftRight, int startElement, Vector3 leftPoint, Vector3 rightPoint, Vector3 forward, int currentIndex);
    public void OOCCDCDOQC(int currentIndex);
    public void ODDDOCDCQO();
    public void OQCQQCQDCQ(int el, List`1<int> trIntArray, List`1<float> uvArray, List`1<List`1<int>> leftSidewalkIntArray, List`1<List`1<int>> rightSidewalkIntArray, int startend);
    public void OCDDOCDDOQ(List`1<Vector3> meshVecs, List`1<int> connectionVecInts, List`1& roadShapeVecs, List`1<Vector2> vecArrays, List`1<List`1<Vector3>> leftSidewalkArray, List`1<List`1<Vector3>> rightSidewalkArray, int connectionElement, int startend);
    public void ODQCODQDDQ(int el, Material roadMaterial, int leftVecCount, int rightVecCount);
    public void ODCQOCOOQO();
    public void OCQOCDQQQD(int el);
    public static bool OQQCODDOOQ(int el, float roundaboutIndent, Vector3 prevVec, bool boolCheck, Vector3& vec, Int32& indentBorderInt);
    public void ODQOOCQDDD(float minSurrounding, Vector3 middleVec, Vector3 origVec, bool boolCheck, Vector3& vec);
    public void CheckAgainstFirstSurroundingVec(Vector3 firstIndent, Vector3 firstSurrounding, bool boolCheck, Vector3& vec);
    public static Vector3 OODOQDOODO(Vector3 p1, Vector3 p2, Vector3 p3, Vector3 p4);
    public static Vector3 OQDDDODCOC(Vector3 point, Vector3 pivot, Quaternion angle);
}
[AddComponentMenu("")]
public class EasyRoads3Dv3.ERRoundaboutsFunctions : MonoBehaviour {
    public static void ODCCQQODCO(ERRoundabouts scr, int currentIndex);
    public static void OQQDDDCCDO(ERRoundabouts scr, int currentIndex);
    public static void OOCCDQCCOQ(ERRoundabouts scr, int currentIndex);
    public static void OOOQCOQOOQ(ERRoundabouts scr, List`1<List`1<Vector3>> vecArray, List`1<List`1<Vector3>> vecArrayOther, QDOQDSQOOQDDD corner, int startEnd, int mainOrConnected, int outerCornerInt);
    public static List`1<Vector3> ODCODDCCOC(List`1<Vector3> outer, List`1<Vector3> outerOther, float dist, float height, int startend, int leftright, int outerCornerInt);
    public static List`1<Vector3> OQCDDCOODQ(ERRoundabouts scr, List`1<Vector3> innerArray, List`1<Vector3> outerOther, float dist, float height, float sidewalkWidth, int startend, int leftright, int outerCornerInt);
    public static List`1<Vector3> OQODQDOQOQ(List`1<Vector3> outer, float height);
    public static void ODQDQQOQCC(ERRoundabouts scr, List`1<List`1<Vector3>> vecArray, List`1& uvArray, QDOQDSQOOQDDD corner, bool reverse);
    public static void ODQOQOCCOC(List`1<List`1<Vector3>> vecArray, List`1& sidewalkUVs);
    public static void OCCQQQDDDQ(ERRoundabouts scr);
    public static void SetInnerSidewalkVars(ERRoundabouts scr, int preset);
    public static void BuildInnerRoundaboutSidewalkData(ERRoundabouts scr, ERModularBase baseScr, List`1<Vector3> mainRightPoints, List`1& innerRoundaboutSidewalkV3, List`1& innerRoundaboutSidewalUV, List`1& innerRoundaboutSidewalTris, Int32& innerSidewalkSegments);
}
[AddComponentMenu("")]
public class EasyRoads3Dv3.ERSideObjectInstance : MonoBehaviour {
    [HideInInspector]
public SideObject so;
    [HideInInspector]
public double id;
    [HideInInspector]
public ERModularRoad roadScript;
    [HideInInspector]
public List`1<GameObject> childs;
    [HideInInspector]
public List`1<Vector3> vecs;
    [HideInInspector]
public List`1<bool> terrainIndexes;
    [HideInInspector]
public bool buildFlag;
    [HideInInspector]
public bool postProcess;
    [HideInInspector]
public bool batches;
    [HideInInspector]
public bool combined;
    [HideInInspector]
public List`1<GameObject> batchedObjects;
    [HideInInspector]
public List`1<Vector3> startEndPositions;
}
[AddComponentMenu("")]
public class EasyRoads3Dv3.ERSideObjectLog : MonoBehaviour {
    public List`1<SideObjectLog> QOQDQOOQDDQOOQ;
    public List`1<int> ints;
    public List`1<QDQDOOQQDQODD> roadPresets;
    public List`1<CrossingCornerClass> crossingCornerPresets;
    public List`1<ERSideWalk> sidewalkPresets;
    public List`1<ERTexture> textureData;
    public List`1<string> presetAssets;
    public int logIndex;
    public int updateInt;
    public void AddRoadPreset(List`1<SideObject> sceneSideObjects, List`1<SideObjectLog> projectSideObjects, QDQDOOQQDQODD sourcePreset);
    public void UpdateRoadPreset(QDQDOOQQDQODD sourcePreset, int element, List`1<SideObject> sceneSideObjects, List`1<SideObjectLog> projectSideObjects, bool copyShapeData);
    public void UpdateTextureList(int element, Texture2D _texture, float _roadWidth, float _leftOffset, float _rightOffset, float _leftInnerOffset, float _rightInnerOffset);
}
[AddComponentMenu("")]
public class EasyRoads3Dv3.ERSideObjectSection : MonoBehaviour {
    public ERModularRoad road;
    public int sectionListIndex;
    public int sectionIndex;
    public double soId;
    public int leftright;
    public bool mirrored;
    public void Copy(ERSideObjectSection source);
}
public class EasyRoads3Dv3.ERSideWalk : object {
    public string name;
    public double id;
    public double timestamp;
    public float sidewalkWidth;
    public float curbHeight;
    public float curbDepth;
    public bool beveledCurb;
    public float beveledHeight;
    public float beveledDepth;
    public bool outerCurb;
    public bool roadSideCurbUVControl;
    public bool outerSideCurbUVControl;
    public Material material;
    public bool hardEdges;
    public List`1<Vector2> shape;
    public List`1<float> sidewalkUVs;
    public List`1<float> curbUVs;
    public List`1<bool> doConnectionTri;
    public Rect tileRect;
    public float tileSize;
    public float tiling;
    public float uvRatio;
    public float minEnd;
    public float maxEnd;
    public bool lockUVs;
    public float cornerRadius;
    public int cornerSegments;
    public float innerSegmentDistance;
    public static ERSideWalk CreateInstance(int count);
    public void UpdateTimestamp();
    public static String[] SidewalkNames(List`1<ERSideWalk> sidewalks);
    public static void CopySidewalk(ERSideWalk source, ERSideWalk target);
    public static void RefreshSidewalks(List`1<ERSideWalk> sidewalks);
    public void OOQQDCCDQO();
}
[AddComponentMenu("")]
public class EasyRoads3Dv3.ERSideWalkInstance : object {
    public ERSideWalk sidewalk;
    public GameObject swObject;
    public double id;
    [HideInInspector]
public float start;
    [HideInInspector]
public float end;
    [HideInInspector]
public Vector3 startPos;
    [HideInInspector]
public Vector3 endPos;
    public ERSideWalkInstance(ERSideWalk msidewalk, float mStart, float mEnd, Vector3 mStartPos, Vector3 mEndPos, ERModularRoad road, string side);
    public void CreateObject(ERModularRoad road, string side);
    public void GetObject(ERModularRoad road, string side);
}
public class EasyRoads3Dv3.ERSideWalkInstanceScript : MonoBehaviour {
    public ERSideWalkInstance instance;
}
[AddComponentMenu("")]
public class EasyRoads3Dv3.ERSideWalkVecs : MonoBehaviour {
    public static GameObject sidewalk;
    public static void OQOQDODDCD(ERCrossings scr);
    public static void ODCCDOQOOC(ERCrossings scr);
    public static void OQOQDOOOQO(ERCrossings scr, List`1<Vector3> vecArray, Vector3 firstOther, float sidewalkWidth, int xorz, Int32& cornerInt);
    public static void OOOQCOQOOQ(ERCrossings scr, List`1<List`1<Vector3>> vecArray, List`1<List`1<Vector3>> vecArrayOther, QDOQDSQOOQDDD corner, int startEnd, int mainOrConnected, int outerCornerInt);
    public static void OODDCODCCQ(ERCrossings scr);
    public static List`1<Vector3> ODCODDCCOC(List`1<Vector3> outer, List`1<Vector3> outerOther, float dist, float height, int startend, int leftright, int outerCornerInt);
    public static List`1<Vector3> OQCDDCOODQ(ERCrossings scr, List`1<Vector3> innerArray, List`1<Vector3> outerOther, float dist, float height, float sidewalkWidth, int startend, int leftright, int outerCornerInt);
    public static List`1<Vector3> OQODQDOQOQ(List`1<Vector3> outer, float height);
    public static void ODQDQQOQCC(ERCrossings scr, List`1<List`1<Vector3>> vecArray, List`1& uvArray, QDOQDSQOOQDDD corner, bool reverse, float uvTiling);
    public static void ODQOQOCCOC(List`1<List`1<Vector3>> vecArray, List`1& sidewalkUVs);
    public static void ODDCDODCCQ(List`1& outer1, List`1& outer2);
    public static Vector3[] OODDQOQDCC(ERCrossings scr, Vector3[] normals);
    public static Vector4[] AdjustSidewalkTangents1(ERCrossings scr, Vector4[] tangents);
    public static Vector4[] AdjustSidewalkTangents(ERCrossings scr, Vector4[] tangents);
    public static Vector3[] ODDQQCCODD(ERRoundabouts scr, Vector3[] normals);
    public static Vector3[] SnapSidewalkCornersVecs(ERCrossings scr, Vector3[] vecs);
    public static void ODCQCQDODC(ERModularBase baseScript, ERSideWalk sw, Vector3 pos);
    public static void OQOOQDCQOC(ERSideWalk sw, GameObject sidewalkGO, List`1<Vector3> vecs, int leftRight, float offsetX, bool updateMesh);
    private static List`1<Vector2> OCDODCQCCC(ERSideWalk sw, Int32& innerIndex, List`1& trisFlag);
    public static void ODDDOCDCQO(ERSideWalk sw, List`1<Vector2> shape, List`1<bool> trisFlag, List`1<float> uv, List`1<Vector3> spline, List`1<Vector3> spline2, int leftright, GameObject sidewalkGO, float offsetX, bool closedStart, bool closedEnd);
    public static void OQCODDOCCD(ERSideWalk sw, List`1<List`1<Vector3>> sourceVecs, List`1<List`1<Vector2>> sourceUVs, List`1& vecs, List`1& uvs, List`1& tris, int pointsCount, int leftrightroad, int startEnd);
}
public class EasyRoads3Dv3.ERSOMarker : object {
    public SideObject sideObject;
    public double id;
    public bool active;
    public float startOffset;
    public float endOffset;
    public bool splineActive;
    public float sidewaysDistance;
    public Vector3 startOffsetV3;
    public Vector3 endOffsetV3;
    public Vector3 startOffsetDir;
    public Vector3 endOffsetDir;
    public Vector3 startOffsetV3nb;
    public Vector3 endOffsetV3nb;
    public int curStartInt;
    public int curEndInt;
    public bool startOffsetActive;
    public bool endOffsetActive;
    public List`1<Vector2> nodeList;
    public List`1<Vector3> nodeShapeVecsGlobal;
    public Vector3 rotation;
    public float rotationAngle;
    public float rotationDistance;
    public float rotationCenter;
    public ERSOMarker(SideObject so, bool flag);
    public void OODOOOQQCO(ERSOMarkerExt source);
}
public class EasyRoads3Dv3.ERSOMarkerExt : ScriptableObject {
    public SideObject sideObject;
    public double id;
    public bool active;
    public float startOffset;
    public float endOffset;
    public bool splineActive;
    public float sidewaysDistance;
    public float xPosition;
    public Vector3 startOffsetV3;
    public Vector3 endOffsetV3;
    public Vector3 startOffsetDir;
    public Vector3 endOffsetDir;
    public Vector3 startOffsetV3nb;
    public Vector3 endOffsetV3nb;
    public int curStartInt;
    public int curEndInt;
    public bool startOffsetActive;
    public bool endOffsetActive;
    public List`1<Vector2> nodeList;
    public List`1<Vector3> nodeShapeVecsGlobal;
    public int shapeTransitionType;
    public Vector3 rotation;
    public float rotationAngle;
    public float rotationDistance;
    public float rotationCenter;
    public ERRoadSide side;
    public ERSOMarkerExt otherSide;
    public void Init(SideObject so, bool flag);
    public void OODOOOQQCO(ERSOMarkerExt source);
    public void Copy(ERSOMarkerExt source);
    public static ERSOMarkerExt CreateInstance(SideObject so, bool flag);
    public void ODCOCDOOCQ(SideObject so);
}
public class EasyRoads3Dv3.ERSORoad : object {
    public SideObject sideObject;
    public double id;
    public bool active;
    public List`1<Vector3> vecPositions;
    public bool toggleActive;
    public float xPosition;
    public float yPosition;
    public Vector3 randomRotation;
    public float randomMinRotation;
    public float randomMaxRotation;
    public float minRandomRotationDistance;
    public float maxRandomRotationDistance;
    public bool xPosChange;
    public bool yPosChange;
    public bool rotationAngleChange;
    public bool rotationDistanceChange;
    public bool lockRandomRotations;
    public bool randomXPositionChange;
    public bool xPositionDistanceChange;
    public bool randomYPositionChange;
    public bool yPositionDistanceChange;
    public float randomXPosition;
    public float randomMinXPosition;
    public float randomMaxXPosition;
    public float minRandomXPositionDistance;
    public float maxRandomXPositionDistance;
    public float randomYPosition;
    public float randomMinYPosition;
    public float randomMaxYPosition;
    public float minRandomYPositionDistance;
    public float maxRandomYPositionDistance;
    public ERSORoad(SideObject so);
}
public class EasyRoads3Dv3.ERSORoadExt : ScriptableObject {
    public SideObject sideObject;
    public double id;
    public bool active;
    public List`1<Vector3> vecPositions;
    public bool toggleActive;
    public bool autoGenerate;
    public bool markerActive;
    public float m_distance;
    public float xPosition;
    [HideInInspector]
public float oldXPosition;
    public float yPosition;
    public Vector3 randomRotation;
    public float randomMinRotation;
    public float randomMaxRotation;
    public float minRandomRotationDistance;
    public float maxRandomRotationDistance;
    public bool distanceChange;
    public bool xPosChange;
    public bool yPosChange;
    public bool rotationAngleChange;
    public bool rotationDistanceChange;
    public bool lockRandomRotations;
    public bool randomXPositionChange;
    public bool randomYPositionChange;
    public bool xPositionDistanceChange;
    public float randomXPosition;
    public float randomMinXPosition;
    public float randomMaxXPosition;
    public float minRandomXPositionDistance;
    public float maxRandomXPositionDistance;
    public Vector3 boxColliderScale;
    public bool yPositionDistanceChange;
    public float randomYPosition;
    public float randomMinYPosition;
    public float randomMaxYPosition;
    public float minRandomYPositionDistance;
    public float maxRandomYPositionDistance;
    public GameObject sourceObject;
    public List`1<ERSOSection> sections;
    public List`1<GameObject> objects;
    public bool clampToMarkers;
    public void Init(SideObject so);
    public static ERSORoadExt CreateInstance(SideObject so);
    public static void Copy(ERSORoadExt source, ERSORoadExt target);
}
public class EasyRoads3Dv3.ERSORoadLog : object {
    public double id;
    public bool active;
    public ERSORoadLog(double so);
}
public class EasyRoads3Dv3.ERSOSection : ValueType {
    public Vector3 startPosition;
    public Vector3 endPosition;
    public Vector3 p2;
    public Vector3 p3;
    public Vector3 ms1;
    public Vector3 ms2;
    public Vector3 ms3;
    public Vector3 ms4;
    public Vector3 me1;
    public Vector3 me2;
    public Vector3 me3;
    public Vector3 me4;
    public Vector3 startSplinePointOrig;
    public float startDistance;
    public int startSplinePointObject;
    public int startSplinePoint;
    public int endSplinePoint;
    public float startFraction;
    public float endFraction;
    public float hsStart;
    public float hsEnd;
    public int startSplinePointGeo;
    public float startDistanceGeo;
    public int endSplinePointGeo;
    public float endDistanceGeo;
    public float maxHeightDifference;
    public SideObject so;
    public bool forceSo;
    public ERRoadSide roadSide;
    public double soid;
    public bool acceptBarriers;
    public bool active;
    public double linkedSoId1;
    public double linkedSoId2;
    public ERSOSection(Vector3 _startPos, Vector3 _endPos, int _startIndex, int _endIndex, float _startFraction, float _endFraction, float _hsStart, float _hsEnd);
    public static ERSOSection GetERSOSection(ERModularRoad road, int listIndex, Int32& index, int leftright, String& soType, List`1& sections);
    public static ERSOSection AdjustEndOffset(ERSOSection target, ERSOSection source);
}
public class EasyRoads3Dv3.ERSplatmap : ValueType {
    public int x;
    public int y;
    public int index;
    public int layer;
    public float value;
    public ERModularRoad script;
    public float tValue1;
    public float tValue2;
    public float tValue3;
    public float tValue4;
    public float tValue5;
    public float tValue6;
    public float tValue7;
    public float tValue8;
    public float tValue9;
    public float tValue10;
    public float tValue11;
    public float tValue12;
    public ERSplatmap(int m_x, int m_y, int m_index, int m_layer, float m_value, ERModularRoad scr, float tv1, float tv2, float tv3, float tv4, float tv5, float tv6, float tv7, float tv8, float tv9, float tv10, float tv11, float tv12);
}
[AddComponentMenu("")]
public class EasyRoads3Dv3.ERTerrain : MonoBehaviour {
    public List`1<Vector3> surfacevecs;
    public Single[] tdataFloat;
    public TerrainData terrainData;
    public int xStart;
    public int zStart;
    public GameObject roadSurface;
    public Mesh surfaceMesh;
    public MeshCollider surfaceCollider;
    public List`1<ERTerrainData> terrainDataStored;
    public List`1<ERTerrainChange> terrainChanges;
    public List`1<ERTree> terrainTrees;
    public List`1<List`1<tPoint>> detailInstancesOld;
    public List`1<tPoint> detailInstances;
    public List`1<int> detailInstanceStarts;
    public List`1<GameObject> surfaceObjects;
    public List`1<Vector3> terrainTestPoints;
    public List`1<ERSplatmap> splatData;
    public List`1<ERTreeInstance> addedTrees;
    public List`1<ERCell> holes;
    public List`1<ERTerrainData> terrainHeightsBackup;
    public List`1<ERTree> terrainTreesBackup;
    public List`1<tPoint> terrainDetailBackup;
    public List`1<ERSplatmap> terrainSplatBackup;
    public List`1<int> detailInstanceStartsBackUp;
    public bool heightmapFlag;
    public bool splatmapFlag;
    public bool treeFlag;
    public bool detailFlag;
    public bool holesFlag;
    public bool terrainDone;
    public bool backupFlagNotification;
    public bool ignore;
    public GameObject backupObject;
    public TerrainData terrain;
}
public class EasyRoads3Dv3.ERTerrainChange : ValueType {
    public int index;
    public int value;
    public ERTerrainChange(int v_index, int v_value);
}
public class EasyRoads3Dv3.ERTerrainData : object {
    public int terrainWidth;
    public int terrainHeight;
    public float originalHeight;
    public float flattenedHeight;
    public float outerHeightDifference;
    public bool critical;
    public float perc;
    public Vector3 hitpos;
    public Vector3 outerPos;
    public bool ignorePreserveHeights;
    public ERTerrainData(int m_terrainWidth, int m_terrainHeight, float m_originalHeight, float m_flattenedHeight, bool m_critical, float m_perc, float m_outerHeight, Vector3 m_hitPoint, Vector3 m_outerPoint);
}
public class EasyRoads3Dv3.ERTexture : object {
    public Texture2D texture;
    public float roadWidth;
    public float leftOffset;
    public float rightOffset;
    public float leftInnerOffset;
    public float rightInnerOffset;
    public ERTexture(Texture2D _texture, float _roadWidth, float _leftOffset, float _rightOffset, float _leftInnerOffset, float _rightInnerOffset);
    public static ERTexture GetERTexture(Material mat);
}
public enum EasyRoads3Dv3.ERTrafficDirection : Enum {
    public int value__;
    public static ERTrafficDirection LHT;
    public static ERTrafficDirection RHT;
}
public class EasyRoads3Dv3.ERTree : object {
    public Color color;
    public float heightScale;
    public Color lightmapColor;
    public Vector3 position;
    public int prototypeIndex;
    public float widthScale;
    public ERTree(TreeInstance instance);
    public TreeInstance SetERTreeInstance(ERTree eRTreeinstance);
}
public class EasyRoads3Dv3.ERTreeInstance : object {
    public int prototypeIndex;
    public Vector3 position;
    public ERTreeInstance(TreeInstance tree);
}
[AddComponentMenu("")]
public class EasyRoads3Dv3.ERTSidewalkTriangulation : MonoBehaviour {
    public static void OQDCOQDQDO(ERCrossings scr, List`1& meshVecs, List`1& meshUVs, List`1& triList, List`1& materialList);
    public static void OQCQDDDOQD(ERCrossings scr, List`1<List`1<Vector3>> vecArray, List`1<List`1<Vector2>> uvArray, int frontLeft, int topBottom, List`1& meshVecs, List`1& meshUVs, List`1& triList, List`1& intArray, List`1& materialList, bool reverse, QDOQDSQOOQDDD corner, int outerCornerInt);
    public static List`1<int> OCCQOODCCO(List`1<int> col1, List`1<int> col2);
    public static List`1<int> OODOODOQOO(int outerPoint, List`1<int> innerCol, int startPoint, bool reverse);
    public static void OQCODDOCCD(ERCrossings scr, QDOQDSQOOQDDD corner, List`1<List`1<Vector3>> sourceVecs, List`1<List`1<Vector2>> sourceUVs, List`1<List`1<int>> sourceTris, List`1& vecs, List`1& uvs, List`1& triList, List`1<Material> materialList, int leftrightroad);
    public static void OOCQCDDQOD();
    public static void ODOOOODDOO(List`1& materialList, List`1& triList, Material sidewalkMaterial, Int32& triArrayElement);
}
public class EasyRoads3Dv3.ERVSData : ValueType {
    public Vector3 position;
    public bool active;
    public float width;
    public Vector3 leftPosition;
    public Vector3 rightPosition;
    public Vector3 dir;
    public ERVSData(Vector3 node, bool active, float width, Vector3 leftPosition, Vector3 rightPosition);
}
public class EasyRoads3Dv3.NormalPairs : ValueType {
    public int index1;
    public int index2;
}
[AddComponentMenu("")]
public class EasyRoads3Dv3.OCCQQCCDDD : MonoBehaviour {
    public static List`1<Vector3> OQDDOOOOQD(ERModularRoad scr, int startMarker, int endMarker, List`1<ERMarkerExt> markers, float faceDist, bool ignorePrefabAlignment, List`1& tValues, List`1& markerDistances, List`1& bendAngles);
    public static void OCQOQCDCQC(ERModularRoad scr, bool ignorePrefabAlignment, List`1<Vector3> splinePoints, List`1<float> tValues, List`1<float> markerDistances, int startMarker, int endMarker, int startInt);
    public static void OCQOQCDCQC(ERModularRoad scr);
    public static ERModularRoad DuplicateObject(ERModularRoad scr);
    public static GameObject ODOCOCQODQ(ERModularRoad scr, Transform parent, Vector3 p1, Vector3 p2, float x1, float x2, float height, Vector3 heighthmapscale);
    public static void CreateSplatMeshes(ERModularRoad scr, List`1& soSplatmapObjects, float splatSize);
    public static GameObject BuildSplatMesh(ERModularRoad scr, List`1<Vector3> vecs, List`1<Vector2> uvs, List`1<int> tris, string name, int pos);
    public static void SetMarkerIndentAlignment(ERMarkerExt m, ERModularRoad scr);
    public static float GetleftToCenterPerc(List`1<Vector2> nodeList, int left, int right);
    public static void OQCDDDDOOQ(ERModularRoad r1, ERModularRoad r2, ERCrossingPrefabs prefab);
    public static void ODOOODOOOQ(ERModularRoad r1, ERModularRoad r2, int road1StartEnd, int road2StartEnd);
    public static void AverageTangentsRoadPrefab(ERModularRoad r1, ERCrossingPrefabs prefab, int road1StartEnd, int prefabStartEnd);
}
[AddComponentMenu("")]
public class EasyRoads3Dv3.OCOCDDODDQ : MonoBehaviour {
    public static void OQCODQOCQD(ERSideWalk sw, List`1& vecs, Vector3 startVec, int rows, int closedVecCountStart, int closedVecCountEnd, int startEnd);
}
public class EasyRoads3Dv3.OCQOCDODDQ : MonoBehaviour {
    public static void ODCOOOQQQD(ERCrossingPrefabs scr, Vector3[] meshVecs, Vector3[]& surfaceMeshVecs);
    public static void OQCDOQOQDC(ERCrossingPrefabs scr, float angle, int dirInt, bool leftrightFlag);
    public static Vector3 ODQODDQDQO(Vector3 cornerPos, float indent, Vector3 outerPos, Vector3& dir);
    public static void OCCCQDODDD(ERCrossingPrefabs scr, Vector3 vecOuter1, Vector3 vecOuter2, Vector3& mainSurrounding, Vector3& connectedSurrounding);
    public static void CheckIndentOQCDCDOOCD(Vector3 dir1, Vector3 dir2, Vector3 cornerPos, Vector3 outer2, Vector3& indent2, Vector3& indent1, float angle, float minIndent, bool leftrightFlag);
    public static void OQDCOQOCQC(ERCrossingPrefabs scr, Vector3 corner, Vector3 indentMain, Vector3 indentConnection, Vector3& mainSurrounding, Vector3& connectedSurrounding, int dirInt);
    public static void ODDDDCCQCD(ERCrossingPrefabs scr, int connection, Vector3 leftIndent, Vector3 leftSurrounding, Vector3 rightIndent, Vector3 rightSurrounding);
    public static void OOOOCQCOQO(ERCrossingPrefabs scr, int connection, int leftIndent, int leftSurrounding, int rightIndent, int rightSurrounding);
    public static void ODQDODQOCC(ERCrossingPrefabs scr, int connection, Vector3 outerPoint, Vector3 crosspoint);
    public static float OOCDQCOCQO(Vector3 v11, Vector3 v12, Vector3 v21, Vector3 v22);
    public static void OODCQQDCCD(Vector3 inner, Vector3& outer, float minDist);
    public static void ODOODODQCO(ERCrossingPrefabs scr, Vector3[] meshVecs);
    public static void ODQQQCOCCD(ERCrossingPrefabs scr, int connection);
    public static void ODCQDDDOOO(ERCrossingPrefabs scr, QDOODOQQDQODD el1, QDOODOQQDQODD el2, int leftright);
    public static void OCDOQOOCCC(ERCrossingPrefabs scr);
    public static Vector3 ODCCDOCDQD(Transform transform, Vector3 pos, ERModularBase scr);
}
[AddComponentMenu("")]
public class EasyRoads3Dv3.OCQOQOOOCO : MonoBehaviour {
    public static float OCOCQCDDCD(List`1& splinePoints, ERModularRoad scr, int marker, List`1& segPoints, List`1& tValues, Single& totalDist, int startMarker, Single& xzDistance, bool getDistance, Single& radius, List`1& bendAngles);
    public static Vector3 OOODCCODQD(Vector3& m2, Vector3& m1, Vector3& dir1, Vector3& dir2, Vector3 p1, Vector3 p4, Boolean& isAhead, Int32& firstLastAdjust, Boolean& isNoAdjust, ERModularRoad scr);
    public static float ODOCQOODDO(List`1& splinePoints, ERModularRoad scr, int marker, List`1& segPoints, List`1& tValues, Single& totalDist, int startMarker, Single& xzDistance, bool getDistance, List`1& bendAngles);
    public static Vector3 OCOCQCDDCD(ERModularRoad scr, int marker, Boolean& flag);
    public static void OOCCQCOOQQ(List`1& splinePoints, ERModularRoad scr, int marker, Vector3& pivotp, Vector3& p1, Vector3& p2, List`1& segPoints, List`1& tValues);
    public static void OQCQQDCDQO(ERModularRoad roadScr, List`1& tmpNodes, List`1<float> splineStrength, ERCrossingPrefabs prefabInstance, int connectionSegment, Vector3& connectionDir, Vector3& lastForward, int startEnd);
    public static int OCCCDCOQCC(ERModularRoad scr, List`1<Vector3> splinePoints, float minIndent, float outerRoadDistance, Vector3 ODCQDOOOCCIndent, Vector3 startPrefabIndent, int leftright);
    public static int OOQQDDDOQC(ERModularRoad scr, List`1<Vector3> splinePoints, float minIndent, float outerRoadDistance, Vector3 ODCQDOOOCCIndent, Vector3 startPrefabIndent, int leftright, Int32& endAdjustInt, Single& endAdjustDistance);
    public static ERModularRoad OCQDOCOODD(ERModularRoad scr, int marker);
    public static ERMarkerExt DuplicateMarker(ERMarkerExt sourceMarker);
    public static GameObject JoinRoads(List`1& objects, ERModularRoad& road, Int32& marker);
    public static void SwapIndentsSurroundings(ERModularRoad scr);
    public static void SwapSideObjects(ERModularRoad scr);
    public static int SoIndexMatch(ERSOMarkerExt markerSO, List`1<ERSOMarkerExt> Sos, int index);
    public static bool ODCODDQDCC(List`1<Vector3> splinePoints, int markers);
    public static void ODQDCODODC(ERModularRoad scr, Vector3 OOCDQCOOQC, ERCrossingPrefabs ODCQDOOOCC, int targetElement, bool reverse, bool uvReverse, bool forceAutoRotate);
    public static void OODCOQOQOD(ERModularRoad scr, List`1& surfaceVecs, ERCrossingPrefabs prefabScript, Boolean& startSurfacesSafe, float distance, float minIndent);
    public static void ODOCCQDCQO(ERModularRoad scr, List`1& surfaceVecs, ERCrossingPrefabs prefabScript, int el, Boolean& surfacesSafe, float distance, float minIndent);
    public static void OCDCDQQQDO(ERModularRoad scr, ERCrossingPrefabs ODCQDOOOCC, int targetElement, bool reverse, bool uvReverse, bool UpdateResolutionFlag);
    public static void ODQOCCDCOC(List`1& uv1, List`1& uv2);
    public static List`1<int> OCCCDQCDOC(ERModularRoad scr, List`1<Vector2> roadShapeVecs, List`1<Vector2> connectionVecs, int startend);
    public static List`1<int> ODDCOQQDCO(ERModularRoad scr, List`1<Vector2> roadShapeVecs, ERCrossingPrefabs prefab, int connection, int startend);
    public static void OOCQODCOOQ(ERModularBase baseScr, ERModularRoad scr, int m1, int m2, int m3);
    public static void ODQDQOQQCO(ERModularBase baseScr, ERModularRoad scr, int m1, int m2, int m3);
    public static void OCDDCDDCQC(ERModularBase baseScript, List`1& vecs, List`1<float> tValues, float heigthOffset, Vector3& lastHeightAdjustCP, float resolution, float distance, bool nextMarkerContourAdjust, List`1<Vector3> currentVecs, List`1& testPoints, List`1& randomRotations);
    public static void OQDOQOCDCC(int lastInt, int currentInt, List`1<float> tValues, List`1& tmpTValues);
    public static bool OQCODQODCO(Vector3 ODCQDOOOCCIndent, Vector3 otherPrefabIndent, Vector3 v);
    public static Vector3 OQOCQCOCQQ(Vector3 position, Vector3 sourceV3, float angle, Vector3 euler);
    public static Vector3 ODOQCDQQCC(Vector3 position, Vector3 sourceV3, float angle, Vector3 euler);
    public static Vector3 GetEulerAngles(Vector3 v3direction);
    public static void ODCQCQCQDQ(GameObject road, Mesh sourceMesh, int LODCount, int LODLevel, int colCount, List`1<bool> hardEdge, List`1<int> roadShapeMaterialIntCounts);
    public static void ODQCQCOOCQ(ERCrossingPrefabs prefab, ERModularRoad road, int connectionIndex, int startEnd);
}
[AddComponentMenu("")]
public class EasyRoads3Dv3.ODCCODOCQQ : MonoBehaviour {
    public static GameObject rtg;
    public static GameObject swgLeft;
    public static GameObject swgRight;
    public static Vector3 camdir;
    public static List`1<List`1<Vector3>> vecs;
    private static ODCCODOCQQ();
    public static void OODDQCQQDQ(ERModularBase baseScript, ERModularRoad scr);
    public static void CleanMeshData(Mesh m, List`1<List`1<int>> mtris, List`1& vecs, List`1& uvs, List`1& uvs2, List`1& normals, List`1& tangents, List`1& colors, List`1& tris);
    public static void OCDCQCOQQO(Mesh mesh);
    public static void OOCQQCOQQC(Mesh mesh);
    public static void GenerateWaypoints(ERModularRoad scr, float distance);
    public static void OOQDCQODOD(List`1<SelectedObject> selectedObjects, int alignType);
    public static void OOCDQDQDCQ(GameObject go, SideObject so, List`1<Vector3> vecs, List`1<Vector2> uvs, List`1<Vector2> uvs1, List`1<Color> color, List`1<Vector4> tangents, List`1<int> triangles, List`1<Vector3> normals, List`1<int> normalArray1, List`1<int> normalArray2);
    public static void GetRoadShape(float width, int subSegments, List`1& roadShape, List`1& uvs, List`1& uvs1, float dir);
    public static void GetRoadShape(float oldWidth, QDQDOOQQDQODD roadType, float dir);
    public static void UpdateRoadType(ERModularBase scr, int index);
    public static bool UpdateRoadTypeByRoad(ERModularBase scr, ERModularRoad road, int index, QDQDOOQQDQODD type);
    public static int OCDQQQDDQO(List`1<Vector2> roadShape);
    public static void OCDQCDQQDD(List`1& tmpMarkersExt);
    public static void ODOCDOQDDQ(QDQDOOQQDQODD roadType);
    public static void RebuildMainRoadShape(QDQDOOQQDQODD roadType);
    public static void OQDCDQDCQC(QDQDOOQQDQODD roadType, List`1& roadShape, List`1& roadShapeUVs, List`1& doConnectionTri, List`1& hardEdge, Int32& currentMostLeftInt, Int32& currentMostRightInt, Int32& sectionRoadShapeCols, int leftright, int lineIndexTarget, bool transition, List`1<Vector2> origRoadShape);
    public static List`1<int> OODCQDDQDC(List`1<Vector2> _rs1, List`1<bool> _hd1, int cols1, List`1<Vector2> _rs2, List`1<bool> _hd2, int cols2, List`1& tris, bool flipNormals, int vecCount, int i1, int i2, int last1, int last2);
    public static void OOQCCCDODD(QDQDOOQQDQODD roadType, List`1& roadShapeVecs, List`1& roadShapeUVs, List`1& hardEdge, Int32& rightOuterIndex);
    public static void VisualizeRoadType(ERModularBase baseScript, GameObject prefab, QDQDOOQQDQODD rt, Vector3 pos, Vector3 dir);
    public static void ODODDQCQQC(QDQDOOQQDQODD rt);
    public static void OODDDCCOQO(List`1<Vector3> cvecs, float OOCODCCCOQ, float OQQDDDQDOQ, float OCCOCCCODQ, List`1<float> breakpoints, float OQQOOQOOQQ, Vector3 startDir, Vector3 endDir, List`1& vecs, float length, Vector3 firstRounding, float uvRatio);
    public static void RoadShapeChangeTriangulation(List`1<Vector3> shape1, List`1<Vector3> shape2, int startIndex1, int endIndex1, int startIndex2, int endIndex2, List`1& tris);
}
[AddComponentMenu("")]
public class EasyRoads3Dv3.ODDCOQCOOO : MonoBehaviour {
    public static void OQOQDODDCD(ERCrossings scr);
    public static void ODCCDOQOOC(ERCrossings scr);
    public static void OQOQDOOOQO(ERCrossings scr, List`1<Vector3> vecArray, Vector3 firstOther, float sidewalkWidth, int xorz, Int32& cornerInt);
    public static void OOOQCOQOOQ(ERCrossings scr, List`1<List`1<Vector3>> vecArray, List`1<List`1<Vector3>> vecArrayOther, QDOQDSQOOQDDD corner, int startEnd, int mainOrConnected, int outerCornerInt, bool crossingSide);
    public static void OODDCODCCQ(ERCrossings scr);
    public static List`1<Vector3> ODCODDCCOC(List`1<Vector3> outer, List`1<Vector3> outerOther, float dist, float height, int startend, int leftright, int outerCornerInt);
    public static List`1<Vector3> OOQQQQQCOO(List`1<Vector3> outer, float dist, float height, int startend, int leftright, int outerCornerInt);
    public static List`1<Vector3> OQCDDCOODQ(ERCrossings scr, List`1<Vector3> innerArray, float dist, float height, float sidewalkWidth, int startend, int leftright, int outerCornerInt);
    public static List`1<Vector3> OQODQDOQOQ(List`1<Vector3> outer, float height);
    public static void ODQDQQOQCC(ERCrossings scr, List`1<List`1<Vector3>> vecArray, List`1& uvArray, QDOQDSQOOQDDD corner, bool reverse, float uvTiling);
    public static void ODQOQOCCOC(List`1<List`1<Vector3>> vecArray, List`1& sidewalkUVs);
    public static void ODDCDODCCQ(List`1& outer1, List`1& outer2);
}
[AddComponentMenu("")]
public class EasyRoads3Dv3.ODDCQDDCDD : MonoBehaviour {
    public static void ODQQCQOODQ(List`1<ERRoundaboutElement> connections, List`1<Vector3> mainLeftPoints, List`1& meshVecs, List`1& meshUVs, List`1& fullTris);
    public static void OODQCCOOQC(List`1<ERRoundaboutElement> connections, List`1<Vector3> meshVecs, int vecCount, List`1& connectionVecs, List`1& connectionUVs, List`1& connectionTris, List`1& triList, List`1& materialList);
    public static void OCDDOCDDOQ(List`1<Vector3> meshVecs, List`1<int> connectionVecInts, List`1& roadShapeVecs, List`1& roadShapeUVY);
    public static Vector2 SetUV(Vector3 p1, Vector3 p2, Vector3 p3, Vector2 uv1, Vector2 uv2);
    public static bool OCCQDQQDCC(int nvert, List`1<Vector2> vert, float testx, float testy);
    public static bool OCCDQOCQQQ(int nvert, List`1<float> vertx, List`1<float> verty, float testx, float testy);
    public static bool OQOCDCDOQO(List`1<Vector3> vecs, List`1<OOCOCQCQOQ> edges, int p1, int p2, int p3);
    public static Vector3 OQQCQOCCOQ(Vector3 vA, Vector3 vB, Vector3 vPoint);
}
[AddComponentMenu("")]
public class EasyRoads3Dv3.ODDDDDCCQQ : MonoBehaviour {
    public static void OQDCOQDQDO(ERCrossings scr, List`1& meshVecs, List`1& meshUVs, List`1& triList, List`1<Material> materialList, List`1<Material> connectionMaterialList);
    public static float GetCenterUVY(ERCrossings scr, float uvTiling, List`1<List`1<Vector3>> vecArray, int connection);
    public static void OCODCOCODQ(ERCrossings scr, List`1<List`1<Vector3>> vecArray, List`1<List`1<Vector2>> uvArray, int frontLeft, int topBottom, List`1& meshVecs, List`1& meshUVs, List`1& triList, List`1& intArray, int startRow, int triArrayIndex, int centerPointIndex);
    public static List`1<int> OODCODOODC(List`1<List`1<int>> intArray);
    public static List`1<int> OCCQOODCCO(List`1<int> col1, List`1<int> col2, int startRow);
    public static List`1<int> OOQCQQDDQC(List`1<int> col1, List`1<int> col2, List`1<Vector3> vecs1, List`1<Vector3> vecs2, int frontLeft, int topBottom, int startRow);
    public static void InitODCOCQQDDC(ERCrossings scr);
    public static void ODCOCQQDDC(ERCrossings scr, List`1<List`1<Vector3>> vecArray, List`1& uvs, List`1& uvArray, int verthorz, float uvTiling);
    public static Vector3[] OOQOODDQCC(ERCrossings scr, Vector3[] vecs);
}
[AddComponentMenu("")]
public class EasyRoads3Dv3.ODDQODOOOC : MonoBehaviour {
    public static List`1<Vector3> debugvecs;
    public static bool sidewaysFlag;
    public static bool useLastFowardFlag;
    public static bool lastvecPositionsArray;
    public static int currentSplineInt;
    private static float ᙃ;
    private static float ᙄ;
    private static float ᙅ;
    private static float 4AAAA;
    private static Vector3 5AAA1;
    private static Vector3 6AAAA;
    private static float 7AAA1;
    private static float 8AAAA;
    private static float 9AAA1;
    private static float BAAAA;
    private static float CAAA1;
    private static Vector3 00AAA;
    private static Vector3 10AA1;
    private static float 20AAA;
    private static float 30AA1;
    private static float 40AAA;
    private static float 50AA1;
    private static float 60AAA;
    private static Vector3 70AA1;
    private static Vector3 80AAA;
    private static float 90AA1;
    private static float B0AAA;
    private static float C0AA1;
    private static float 01AAA;
    private static float 11AA1;
    private static float 21AAA;
    private static Vector3 31AA1;
    private static Vector3 41AAA;
    private static float 51AA1;
    private static Bounds 61AAA;
    private static int 71AA1;
    private static int 81AAA;
    private static int 91AA1;
    private static bool B1AAA;
    private static bool C1AA1;
    private static bool 02AAA;
    private static ODDQODOOOC();
    public static void OOCOCOOQCC(List`1<SideObject> QOQDQOOQDDQOOQ, List`1& soDataExt);
    public static void OOCDDOCODO(ERModularBase scr, SideObject so);
    public static void OQOCQOCDOO(ERModularBase scr, SideObject so);
    public static bool ODOOCCCOQD(ERModularRoad scr, SideObject so, bool forceMarkerActive);
    public static void InitOtherMarkerSO(ERModularRoad scr, ERSOMarkerExt soData, SideObject so);
    public static ERSOMarkerExt[] ODODCDDCOD(ERModularRoad scr, SideObject so, Boolean& terrainSurfaceFlag);
    public static void SynchSideObjects(ERModularRoad scr1, ERModularRoad scr2);
    public static void OCCQDQOQCO(ERModularRoad scr, int marker);
    public static String[] OODDQDQDOQ(ERModularRoad scr);
    public static bool OOQDOCDDCO(ERModularRoad scr, SideObject so, int marker, bool mirrored);
    public static bool OOQDOCDDCO(ERModularRoad scr, SideObject so, int marker, Single& startOffset, Single& endOffset, ERSOMarkerExt& soMarker, bool mirrored);
    public static bool GetSidewaysPosition(ERModularRoad scr, SideObject so, List`1& sidewaysList, Boolean& customNodelistFlag, List`1& nodeListValues, List`1& shapeTransitionTypes);
    public static bool OOQOOQCQQO(ERModularBase scr, ERModularRoad roadScr);
    public static void ODQOCCQQCQ(ERModularRoad rScr, SideObject so);
    public static bool ODOOODCQCD(ERModularRoad road, int marker, int soIndex);
    public static bool OCCODCQODC(ERModularRoad road, int marker, int soIndex);
    public static bool OCOCCOODQC(List`1<SideObject> list, SideObject so);
    public static void ODQCOCOCOQ(ERModularBase scr, ERModularRoad roadScr, SideObject so);
    public static void ODOODCCDOC(ERModularBase scr, ERModularRoad roadScr, bool isSideObjectFlag);
    public static void OODQCDDCQO(ERModularBase scr, ERModularRoad roadScr, SideObject so, bool isParent);
    public static void OOOCCQDQCC(GameObject go, SideObject so, ERModularRoad roadScr, ERSORoadExt soData, bool mirrored, bool isChild);
    public static void AddBoxCollider(GameObject go, SideObject so, float zDist, float curDist, List`1<Vector3> vecPositions, List`1<float> vecDistances, int currentVecArrayInt, ERModularRoad roadScr, List`1<Vector3> vecPositionsCenter, List`1<Vector3> vecPositionsRight, ERSORoadExt soData);
    public static void CheckVertexLimit(SideObject so, int segment, bool force);
    public static void ODOCOOOQOC(float curDist, ERMesh mobject, int meshSegment, List`1<ERMarkerExt> markers, List`1<float> segmentDistances, List`1<float> segmentAccDistances, int markerIndex, List`1<Vector3> vecPositions, List`1<Vector3> vecPositionsLeft, List`1<Vector3> vecPositionsRight, List`1<Vector3> vecPositionsCenter, List`1<float> vecAngles, List`1<float> vecDistances, int currentVecArrayInt, bool debugFlag, int segmentCount, bool lastSegment, float scaleFactor, SideObject so, float halfRoadWidth, ERModularRoad roadScr, bool newSegment, bool skipStartBlend, bool skipEndBlend, Vector3& forward, Vector3& startPos, ERSORoadExt soData, bool mirrored, Single& steppedHeight, Int32& lastStep);
    public static void ODCQCCDOQO(float curDist, ERMesh mobject, int meshSegment, List`1<ERMarkerExt> markers, List`1<float> segmentDistances, List`1<float> segmentAccDistances, int markerIndex, List`1<Vector3> vecPositions, List`1<Vector3> vecPositionsLeft, List`1<Vector3> vecPositionsRight, List`1<Vector3> vecPositionsCenter, List`1<float> vecAngles, List`1<float> vecDistances, int currentVecArrayInt, bool debugFlag, int segmentCount, bool lastSegment, float scaleFactor, SideObject so, ERModularRoad roadScr, List`1<List`1<Vector2>> fullNodeList, float clampUVYPerc, float uvyShapeRatio, ERSORoadExt soData, bool mirrored, bool shapeDirFlag);
    public static void ODOODODODO(GameObject parentGo, float curDist, float scaleFactor, SideObject so, List`1<Vector3> vecPositions, List`1<Vector3> vecPositionsLeft, List`1<Vector3> vecPositionsRight, List`1<Vector3> vecPositionsCenter, List`1<float> vecAngles, List`1<float> vecDistances, int currentVecArrayInt, int num, ERModularRoad roadScr, int startConnectionEnd, ERSORoadExt soData, bool mirrored, bool rotateFlag, List`1<int> sectionIndexes, bool shapeDirFlag, int k);
    public static void ODCCQODCOQ(float tmpDist, List`1<Vector3> vecPositions, List`1<float> vecDistances, int currentVecArrayInt, Vector3& v, Vector3& v1, bool doSecond, bool debugFlag);
    public static void GetSplinePositionsMin(float tmpDist, List`1<Vector3> vecPositions, List`1<float> vecDistances, int currentVecArrayInt, Vector3& v, Vector3& v1, bool doSecond, bool debugFlag);
    public static void OCQCOOQCDO(float curDist, List`1<float> vecDistances, Int32& currentVecArrayInt);
    private static void GetRandomXDistance(float distance, Vector3& adjustedRotation, Vector3& currentRandomRotation, float randomRotationStart, float randomRotationMiddle, float randomRotationEnd, float randomRotationDistance, Vector3 randomRotation);
    private static void OCQQCOOQDQ(float distance, Vector3& adjustedRotation, Vector3& currentRandomRotation, float randomRotationStart, float randomRotationMiddle, float randomRotationEnd, float randomRotationDistance, Vector3 randomRotation);
    private static void OCCOOCDCQQ(float distance, Vector3& adjustedRotation);
    public static Terrain OQQOOCQQCD(Vector3 pos);
}
[AddComponentMenu("")]
public class EasyRoads3Dv3.ODOCDOQDCO : MonoBehaviour {
    public static void OQQQQQODDO(ERCrossings scr, Single& firstSegmentDistance);
    public static void OODDQCQOQQ(List`1& vecs, float firstX, float firstZ, float lastX, float lastZ);
    public static Vector3 OCCDQDCQCD(int i, float radius, float angle);
    public static void OQODOQQCOO(ERCrossings scr);
    public static void ODOODDOQOQ(List`1<Vector3> vecs, float firstX, float firstZ, float sidewalkWidth, float resolution, float currentDist);
    public static void OOOCDOCQQO(ERCrossings scr);
    public static void OOOCOQODOO(List`1<Vector3> targetVecs, float targetValue, float firstX, float firstZ, float resolution, int xorz);
    public static void OCOOOQQQQO(ERCrossings scr);
    public static List`1<Vector3> OOOCCCCDDQ(List`1<Vector3> sourceVecs, float leftRight, float distance);
    public static void OOCCOQQDQQ(ERCrossings scr);
    public static List`1<Vector3> OOOODDQDCC(List`1<Vector3> sourceVecs, int xorz);
}
[AddComponentMenu("")]
public class EasyRoads3Dv3.ODOOCCQDOC : MonoBehaviour {
    public static void ODCQCQCQDQ(Mesh mesh);
    public static void OptimizeMeshFull(Mesh mesh);
    public static void OptimizeVertices(List`1<Vector3> vecs, List`1<int> triangles);
    public static int OQQQCDCOOO(Vector3[]& verts, int start, Vector3 v);
    public static void OCDDOQQCDO(Int32[]& tris, int old, int newInt);
}
[AddComponentMenu("")]
public class EasyRoads3Dv3.ODQDQDQDQO : MonoBehaviour {
    public static Vector3 OODOQDOODO(Vector3 p1, Vector3 p2, Vector3 p3, Vector3 p4, bool flag);
    public static float OQDDCCCOQD(Vector3 p1, Vector3 p2, Vector3 p3, Vector3 p);
    public static bool OQCDCDOOCD(Vector3 pTarget, Vector3 pSource, Vector3 pCheck);
    public static Vector3 OQQCQOCCOQ(Vector3 vA, Vector3 vB, Vector3 vPoint);
    public static Vector3 OQDDDODCOC(Vector3 point, Vector3 pivot, Quaternion angle);
    public static float GetYAngleByDir(Vector3 dir);
    public static Vector3 OCOOCOOODQ(Vector3 point, float angle, Vector3 axis);
    public static Vector3 OQQDCOCCCO(Vector3 source, float angle);
    public static int ODOCOCDQCO(List`1<Material> mats, Material mat);
    public static float OCCQDCCCOD(Vector3 fwd, Vector3 targetDir, Vector3 up);
    public static bool OQOQCCCODC(GameObject go, Bounds& bounds);
    public static float OOCQOOCOQC(Vector3 pos, ERModularBase scr);
    public static Vector3 ODCCDOCDQD(Vector3 pos, Vector3 dir);
    public static Vector3 OCCDCCQDDO(Vector3 pos, Vector3 dir);
    public static Vector3 OOQODCCOQD(Vector3 pos, ERModularRoad scr);
    public static int ODQCDQOOCO(int segmentCount, SideObject so, bool newSegment, ERMesh mobject, bool lastSegment, bool skipStartBlend, bool skipEndBlend);
    public static void OCCQCDQQOQ(Vector3& v2, Vector3& n, Vector3 v, Vector3 dir, Vector2 vec, ERModularRoad roadScr, Vector3 randomRotation);
    public static void OQODQODDOQ(Vector3& v2, Vector3& n, Vector3 v, Vector3 dir, Vector2 vec, float angle, Vector3 randomRotation);
    public static void RandomAlignment(Vector3& v2, Vector3& n, Vector3 v, Vector3 dir, Vector2 vec, Vector3 randomRotation);
    public static void OCCDCDCQQQ(GameObject go, Vector3 v, ERModularRoad roadScr, Vector3 randomRotation);
    public static void OQQOODCODQ(GameObject go, Vector3 v1, Vector3 v3, Vector3 dir, Vector3 randomRotation);
    public static void OCOQCDDODO(GameObject go, Vector3 v1, ERModularRoad roadScr, Vector3 randomRotation, Vector3 cp2, Vector3 cp3);
    public static void InstantiatedRandomRotation(GameObject go, Vector3 v1, ERModularRoad roadScr, Vector3 randomRotation);
    public static bool RayTriangleOODOQDOODO(Vector3 p1, Vector3 p2, Vector3 p3, Ray ray);
    public static void OCDODCQDDO(ERModularBase scr, Vector3 v1, Vector3 v2, Single& minY, Single& maxY);
    public static List`1<Vector3> GetSoSplinePoints(ERModularRoad scr, List`1<float> sidewaysList, List`1& markerInts, List`1& tValues, List`1& markerDistances, List`1& tmpMarkers);
    public static List`1<Vector3> OOODQCOOCC(List`1<Vector3> points, float tension, float incr);
    public static List`1<Vector3> OOODQCOOCC(Vector3 p1, Vector3 p2, Vector3 p3, Vector3 p4, float incr);
    public static List`1<List`1<Vector2>> GetRoadShapeValues(List`1<float> tValues, List`1<float> markerDistances, List`1<List`1<Vector2>> nodeListValues, int startMarker, int endMarker, List`1<Vector2> roadShape, List`1<int> shapeTransitionTypes, bool closedTrack);
    public static List`1<Vector3> GetSoMarkerPositionVecs(ERModularRoad scr, List`1<float> sidewaysList, List`1& soMarkerDir, List`1& soMarkerInt);
    public static void CheckGetSoMarkerPositionVecs(ERModularRoad scr, int marker, List`1& soMarkerVecs, List`1& soMarkerDir, List`1& soMarkerInt);
    public static void TerrainSmooth(Terrain terrain, ERModularRoad road, float size, int type, Int32& smoothStep);
    public static bool CheckSmoothPoint(int x, int z, float sampleWidth, float sampleHeight, ERModularBase scr);
    private static float Smooth(int x, int y, TerrainData terrainInfo);
    private static float Smooth1(float indent, float surrounding, float posY);
    public static bool CompareVector2List(List`1<Vector2> list1, List`1<Vector2> list2);
    public static string CheckMesh(GameObject go);
    public static void OCQOQODOCQ(Mesh m, MeshRenderer ren);
    public static List`1<float> OCOCDCOQCD(List`1<Vector2> nodes);
    public List`1<Vector2> ODCOCDCDQC(List`1<Vector3> vecs, float x);
    public static bool CheckConnectAngle(Vector3 r1, Vector3 p1, Vector3 p2);
    public static void OOQQCCOQOC(Transform parent, GameObject& go, string name, List`1<Vector3> OCDCOCQQOO, Material mat, float OOCODCCCOQ, float OQQDDDQDOQ, float OCCOCCCODQ, float ODCCDDDODQ, float ODDQQCDDOD, float OCQCODCDCO, Vector2 OQCOCDQODQ, Vector2 ODDCOOCQCO, float uvRatio);
    public static bool InIntArray(int v, List`1<int> arr);
    public static void OOQCCQCCCC(ERModularBase scr);
    public static OQQCCQCDQQ OQQOCDDDCC(ERModularRoad road, Vector3 pos, QDQDOOQQDQODD rt, int splineIndex);
    public static int GetEdgePositionByDistance(List`1<Vector3> splinePoints, float distance, int startSplinePoint);
    public static int OCOODQDDDO(List`1<Vector3> splinePoints, float distance, int startSplinePoint, Vector3& pos);
    public static int GetSplinePointIndex(List`1<Vector3> splinePoints, float distance, int startIndex, int dir);
    public static float OQQOQODCCC(Terrain terrain, Vector3 p1, Vector3 p2);
    public static bool RaycastRoadsSurfaces(int layer, Vector3 pos, Vector2& uv, GameObject& go, bool checkHeightFlag);
    public static void GetIndexAndFraction(List`1<Vector3> points, float fraction, int index, float dist, Int32& targetIndex, Single& targetFraction, int dir);
    public static ERPoint ODCDDDCCDD(ERPoint source);
    public static void MergeVertices(Mesh m);
    public static int in_array(List`1<Vector3> vecs, List`1<Color> colors, Vector3 v, Color c);
    public static bool Vector2ListComparer(List`1<Vector2> list1, List`1<Vector2> list2);
    public static bool FloatListComparer(List`1<float> list1, List`1<float> list2);
}
[AddComponentMenu("")]
public class EasyRoads3Dv3.ODQDQDQDQOExt : MonoBehaviour {
    public static void OOODCQCQOC(ERModularBase scr);
    public static String[] OQDQCCCDQO(ERModularRoad scr, String[] prefabs, ERCrossingPrefabs[]& prefs, int type);
    public static bool OQDOQQDDOC(ERModularRoad road, Boolean& left, Boolean& right);
    public static bool OCCCQODODQ(ERCrossingPrefabs prefab, ERModularRoad road, int marker, int connection);
    public static bool OCQDQQDOOD(ERCrossingPrefabs prefab, ERModularRoad road, int marker, int connection);
}
public enum EasyRoads3Dv3.OffsetPosition : Enum {
    public int value__;
    public static OffsetPosition Start;
    public static OffsetPosition End;
}
[AddComponentMenu("")]
public class EasyRoads3Dv3.OOCQQOOQOD : MonoBehaviour {
    public static void OOQCQDDOOC(ERModularBase baseScript, ERCrossingPrefabs scr, int connectionSegment, ERModularRoad road, int startend);
    public static void OCOCOCCDOO(ERModularBase baseScript, ERCrossingPrefabs scr, int connectionSegment, ERModularRoad road, int startend);
    public static void OODQQOQDOC(ERModularBase baseScript, ERCrossingPrefabs scr, int connectionSegment, ERModularRoad road, ERCrossingPrefabs otherPrefabScript, int otherConnection);
    public static void ODOCQDCDOQ(ERCrossingPrefabs scr, int lookUpElement, Boolean& roadOnNeighbour, Int32& cornerElement, Boolean& centerStatus);
    public static void OQOOQCDOCD(ERCrossingPrefabs scr, int lookUpElement, Boolean& roadOnNeighbour, Int32& cornerElement, Boolean& centerStatus);
    public static bool CheckRoadTypeChanges(ERModularBase baseScript, ERCrossingPrefabs prefabScript, bool ercrossing, bool erroundabout);
    public static void UpdateToRoadType(ERCrossingPrefabs prefabScript, QDQDOOQQDQODD sourcePreset, List`1& updatedRoads);
    public static void SwapConnectionInit(ERModularBase scr, ERCrossingPrefabs prefab, Int32& newIndex, Int32& oldIndex, Int32& index1, Int32& index2, ERModularRoad& road1, ERModularRoad& road2);
    public static void OCCDCDQOOD(ERModularBase scr, ERCrossingPrefabs prefab, int newIndex, int oldIndex, int index1, int index2, ERModularRoad road1, ERModularRoad road2);
    public static void OCODDODODQ(ERCrossingPrefabs prefab, int index, Int32& newIndex);
}
[AddComponentMenu("")]
public class EasyRoads3Dv3.OODODOQDCC : MonoBehaviour {
    public static void OQCCCDDOQO(ERBend scr, List`1& leftOuterSegments, List`1& leftInnerSegments, List`1& rightOuterSegments, List`1& rightInnerSegments);
    public static List`1<Vector3> OOOOOOODCO(Vector3 prefabCenterpos, Vector3 cpCenterposV3, Vector3 v1, Vector3 cp, Single& totalDistance, List`1& controlPoints);
    public static List`1<Vector3> ODQOQQOQOC(Vector3 prefabCenterpos, Vector3 cpCenterposV3, Vector3 v1, Vector3 cp, Single& totalDistance, List`1& controlPoints, float angle, float multiplyFactor);
    public static Vector3[] OOOOCDQODC(ERCrossingPrefabs scr, int connection, List`1<Vector3> controlPoints, float segmentDistance, float defaultDistance, Vector3[] meshVecs, Vector3[]& tCrossingTmpFullMeshVecs, float multiplyFactor, float angle, float curveStrength);
    public static Vector3[] OCOOCQDCDD(ERCrossingPrefabs scr, int connection, List`1<Vector3> controlPoints, float segmentDistance, float defaultDistance, Vector3[] meshVecs, Vector3[]& tmpSurfaceVecsTCrossings, float multiplyFactor, float angle, float curveStrength);
    public static Vector3[] OCDDOQCCQC(ERCrossingPrefabs scr, int connection, List`1<Vector3> controlPoints, float segmentDistance, Vector3[] meshVecs, float multiplyFactor, float angle, Vector3 cpCenterPoint);
    private static float GetZAdjust(Vector3 vec, float angle);
    public static void OCQQDDOCCD(ERCrossings scr, int connection, int x, int y, List`1<List`1<Vector3>> vecArray);
    public static void OQDDOCOOOO(ERCrossings scr, int connection, List`1<List`1<Vector3>> vecArray, int leftright);
}
[AddComponentMenu("")]
public class EasyRoads3Dv3.OOODCDOCOC : MonoBehaviour {
    public static void OCCCOOOCDO(ERCrossingPrefabs scr, ERModularBase baseScript);
    public static void OQCDCQOQDC(List`1& indentVecs, List`1& baseVecs, List`1& uvs, List`1& doSurroundingTriangle, List`1<Vector3> vecs, List`1<int> surfaceVecType, float indent, float surrounding, ERCrossingPrefabs scr, Boolean& lastIndentIsRight);
    public static void ODCCDDODCD(Vector3& indentVec, Vector3& dir, Vector3 vec, Vector3 prefVec, Vector3 nextVec, float indent, int leftOrRight);
    public static bool OCQODQCOOC(Vector3 vec, Vector3& rightIndentVec, Vector3& rightVec, Vector3& leftIndentVec, Vector3& leftVec, Int32& startInt, List`1<Vector3> vecs, List`1<int> surfaceVecType, float indent, Vector3 leftIndentDir, Vector3 checkVec);
    public static float ERGetInterpolationDistance(Vector3 pos, Vector3 dir, Vector3 vec);
    public static Vector3 GetNextRightVec(int startInt, List`1<Vector3> vecs, List`1<int> surfaceVecType);
    public static void ODDDDQDDQC(List`1& indentVecs, List`1& baseVecs, List`1& doSurroundingTriangle, Vector3 rightVec, Vector3 baseVec);
}
[AddComponentMenu("")]
public class EasyRoads3Dv3.OOQOQOODQC : MonoBehaviour {
    public static void OCDCCCCCCQ(ERCrossings scr, QDOQDSQOOQDDD corner, List`1<List`1<Vector3>> sourceVecs, List`1<List`1<Vector2>> sourceUVs, List`1<List`1<int>> sourceTris, List`1& vecs, List`1& uvs, List`1& triList, int triArrayElement, int leftrightroad, bool hardEdge);
    public static void ODCQCQQQCQ(ERCrossings scr, QDOQDSQOOQDDD corner, List`1<List`1<Vector3>> sourceVecs, List`1<List`1<Vector2>> sourceUVs, List`1<List`1<int>> sourceTris, List`1& vecs, List`1& uvs, List`1& triList, int triArrayElement, int leftrightroad, bool hardEdge);
    public static void OQDDCCCQQQ(ERCrossings scr, QDOQDSQOOQDDD corner, List`1<List`1<Vector3>> sourceVecs, List`1<List`1<Vector2>> sourceUVs, List`1<List`1<int>> sourceTris, List`1& vecs, List`1& uvs, List`1& triList, int triArrayElement, int leftrightroad, bool hardEdge);
    public static void OODCCQQDOO(ERCrossings scr, QDOQDSQOOQDDD corner, List`1<List`1<Vector3>> sourceVecs, List`1<List`1<Vector2>> sourceUVs, List`1<List`1<int>> sourceTris, List`1& vecs, List`1& uvs, List`1& triList, int triArrayElement, int leftrightroad, bool hardEdge);
    public static void OQCDQQODOD(ERCrossings scr, QDOQDSQOOQDDD corner, List`1<List`1<Vector3>> sourceVecs, List`1<List`1<Vector2>> sourceUVs, List`1<List`1<int>> sourceTris, List`1& vecs, List`1& uvs, List`1& triList, int triArrayElement, int leftrightroad, bool hardEdge);
    public static void OCQDQCQDCC(ERCrossings scr, QDOQDSQOOQDDD corner, List`1<List`1<Vector3>> sourceVecs, List`1<List`1<Vector2>> sourceUVs, List`1<List`1<int>> sourceTris, List`1& vecs, List`1& uvs, List`1& triList, int triArrayElement, int leftrightroad, int startEnd, bool hardEdge);
    public static void ODOODOCDOD(ERCrossings scr, QDOQDSQOOQDDD corner, List`1<List`1<Vector3>> sourceVecs, List`1<List`1<Vector2>> sourceUVs, List`1<List`1<int>> sourceTris, List`1& vecs, List`1& uvs, List`1& triList, int triArrayElement, int leftrightroad, bool hardEdge);
    public static void OODDQQQDDQ(ERCrossings scr, QDOQDSQOOQDDD corner, List`1<List`1<Vector3>> sourceVecs, List`1<List`1<Vector2>> sourceUVs, List`1<List`1<int>> sourceTris, List`1& vecs, List`1& uvs, List`1& triList, int triArrayElement, int leftrightroad, bool hardEdge);
    public static void OCCDCDCODO(ERCrossings scr, QDOQDSQOOQDDD corner, List`1<List`1<Vector3>> sourceVecs, List`1<List`1<Vector2>> sourceUVs, List`1<List`1<int>> sourceTris, List`1& vecs, List`1& uvs, List`1& triList, int triArrayElement, int leftrightroad, bool hardEdge);
    public static void ODOQCDCCOQ(ERCrossings scr, QDOQDSQOOQDDD corner, List`1<List`1<Vector3>> sourceVecs, List`1<List`1<Vector2>> sourceUVs, List`1<List`1<int>> sourceTris, List`1& vecs, List`1& uvs, List`1& triList, int triArrayElement, int leftrightroad, bool hardEdge);
    public static float OQDDDOODCQ(Vector3 v1, Vector3 v2, float uvRatio, float startUV, float dir);
}
[AddComponentMenu("")]
public class EasyRoads3Dv3.OOQQQDOCDD : MonoBehaviour {
    public static void OCODDOCODQ(Int32& startInt, float startOffset, List`1& markerInts, List`1& vecPositions, List`1& soSplinePointLeft, List`1<Vector3> soSplinePointRight, ERSOMarkerExt& soMarker, ERModularRoad roadScr, List`1& nodeList);
    public static void OCQCDCDCQC(int startInt, float endOffset, List`1& markerInts, List`1& vecPositions, List`1& soSplinePointLeft, List`1<Vector3> soSplinePointRight, ERSOMarkerExt& soMarker, ERModularRoad roadScr, List`1& nodeList);
    public static bool MoveDirection(ERModularRoad road, ERSOMarkerExt markerSO, Vector3 v);
    public static void OQDCCQDCQQ(ERModularRoad road, ERSOMarkerExt markerSO, Vector3 v, Camera cam, Int32& xDir, Int32& yDir);
    public static void ODODODDCCQ(ERModularRoad road, ERSOMarkerExt markerSO, Vector3 v, Vector3 vOld, float movement);
    public static void OODCOCOCCO(ERModularRoad road, ERSOMarkerExt markerSO, Vector3 v);
    public static void OCQQDCQQCO(int startInt, List`1<Vector3> vecPositions, List`1<int> markersInts, ERSOMarkerExt& soMarker, bool startFlag, ERModularRoad roadScr);
    public static void SynchSoData(ERSORoadExt soData, bool flag);
    public static void OOQQCOQDQC(ERSORoadExt soData, ERSORoadExt source);
    public static void UnlockSORotation(List`1<ERSORoadExt> soDataList);
    public static void CheckMarkerSOData(SideObject so, ERModularRoad road);
    public static void ResetMarkerSOData(ERModularRoad road);
    public static void OQOQCQQCQQ(ERModularRoad road, SideObject so);
    public static void OOCDDOOOOQ(ERModularBase scr, SideObject so, GameObject go);
    public static bool IsActiveAsChild(ERModularBase scr, double soid, double targetSOId);
}
[AddComponentMenu("")]
public class EasyRoads3Dv3.OQCDCDQCCD : MonoBehaviour {
    public static void OQQODODQCQ(ERCrossingPrefabs scr, Vector3[] meshVecs, Vector3[]& surfaceMeshVecs);
    public static void UpdateYCrossingSurfaces(ERCrossingPrefabs scr, Vector3[] meshVecs, List`1<ERConnectionSibling> siblings, Vector3[]& surfaceMeshVecs);
}
public class EasyRoads3Dv3.OQDQODQQCC : MonoBehaviour {
    public static void OODDQOQCCD(int el, List`1& OQCODQQCOO, List`1& OOOQOOOODO, List`1& OCCDOQDDOD, List`1<Vector2> OODQOODCOQ, List`1<Vector2> OCOCQQCDOQ, Int32[] OCQDQOCDCQ, Int32[] OCDCODCDQC, Int32[] ODCQQOQCCC, Int32[] ODCOCDCQDO, Vector3[]& OODOOCCDQO, Vector2[]& OQQOCCDCQO, Int32[]& OOOOQOODCD, Vector3[]& OQCDOCDOQQ, Vector3[]& OOCOOQQDCO, Vector3[]& OCCQCDCOCD, Vector3[]& OCQCCCOOCO, int ODQCCQDCDC, bool OQQOOQCCDD, Vector3 OQCCCODDCD);
    public static void OCOOQCQOQO(List`1& OOQCOODQDO, List`1& OQQQCQQCOC, List`1& OCQQOCQQQD, List`1& OOOQDCCCQD, List`1<Vector3> vecs, List`1<Vector3> OCDQDQQCCC, int start, int end, Vector3 OQCCCODDCD, string OQDQOQDOCO, bool OQQOOQCCDD, Vector3 OCQQCCCQOQ, Vector3 OCDOOQOOCO, List`1& ODQOOOCDQO, List`1& OCOQQDODOO, List`1<Vector2> UVs);
    public static void OQCQCDCOQQ(List`1<Vector2> OCOCQQCDOQ, Vector3 OQCCCODDCD, List`1<Vector3> OOCCDCODCC, List`1<Vector3> OQDQQDCOQO, List`1<Vector2> OCDOCDODOD, List`1<Vector2> OCODQCCQOD, int el, Vector3[] OQODCDCQDD, Vector3[] OQQOCQOQQO, Vector2[] OCDOQODDCC, Vector2[] OOOQOCCOQO, Vector3 OCCCOQCCQO, Vector3 OOCCOQDQOD, Vector2 OCCOCQCDCQ, Vector2 OOCQDQCQDO);
    public static void OCDCOOOCCC(List`1<Vector2> OODQOODCOQ, Vector3 OQCCCODDCD, List`1<Vector3> OQODCDCQDD, List`1<Vector3> OQQOCQOQQO, List`1<Vector2> OCDOCDODOD, List`1<Vector2> OCODQCCQOD, int el, Vector3[] OOCCDCODCC, Vector3[] OQDQQDCOQO, Vector2[] ODQDDQDCCD, Vector2[] ODQQOQQODQ, Vector3 OQOQQDODOO, Vector3 OQOCDOQQOD, Vector2 OQOQQDODOOUV, Vector2 OQOCDOQQODUV);
    public static void ODDDCOCCQO(int el, Vector3[] OQDOQQCOCQ, Vector2[] ODQOOOCDQO, Vector3[] OQODCDCQDD, Vector3[] OOCCDCODCC, Vector2[] OCDOQODDCC, Vector2[] ODQDDQDCCD, Vector3 OQCCCODDCD);
    public static void OQQDCQOCQC(int el, Vector3[] OOQCQCOODD, Vector2[] OCOQQDODOO, Vector3[] OQQOCQOQQO, Vector3[] OQDQQDCOQO, Vector2[] OOOQOCCOQO, Vector2[] ODQQOQQODQ, Vector3 OQCCCODDCD);
}
[AddComponentMenu("")]
public class EasyRoads3Dv3.OQOQCCCDDQ : MonoBehaviour {
    public static void OQDCOQDQDO(ERCrossings scr, List`1& meshVecs, List`1& meshUVs, List`1& triList, List`1& materialList);
    public static void OQCDQOQCOQ(ERRoundabouts scr, List`1& meshVecs, List`1& meshUVs, List`1& triList, List`1& materialList);
    public static void OQCCQQOCCO(ERRoundabouts scr, List`1<Vector3> vecs, List`1<Vector2> uvs, List`1<int> tris, List`1& meshVecs, List`1& meshUVs, List`1& triList, List`1& materialList);
    public static void OQCQDDDOQD(ERCrossings scr, List`1<List`1<Vector3>> vecArray, List`1<List`1<Vector2>> uvArray, int frontLeft, int topBottom, List`1& meshVecs, List`1& meshUVs, List`1& triList, List`1& intArray, List`1& materialList, bool reverse, QDOQDSQOOQDDD corner, int outerCornerInt, List`1& normalInts, List`1& normalIntsStart);
    public static void OQOCDQDDCO(ERRoundabouts scr, List`1<List`1<Vector3>> vecArray, List`1<List`1<Vector2>> uvArray, int frontLeft, int topBottom, List`1& meshVecs, List`1& startNormalInts, List`1& endNormalInts, List`1& meshUVs, List`1& triList, List`1& intArray, List`1& materialList, bool reverse, QDOQDSQOOQDDD corner, int outerCornerInt);
    public static List`1<int> OCCQOODCCO(List`1<int> col1, List`1<int> col2);
    public static List`1<int> OODOODOQOO(int outerPoint, List`1<int> innerCol, int startPoint, bool reverse);
    public static void OQCODDOCCD(ERCrossings scr, QDOQDSQOOQDDD corner, List`1<List`1<Vector3>> sourceVecs, List`1<List`1<Vector2>> sourceUVs, List`1<List`1<int>> sourceTris, List`1& vecs, List`1& uvs, List`1& triList, List`1<Material> materialList, int leftrightroad);
    public static void OOCQCDDQOD();
    public static void ODOOOODDOO(List`1& materialList, List`1& triList, Material sidewalkMaterial, Int32& triArrayElement);
}
[AddComponentMenu("")]
public class EasyRoads3Dv3.OQOQQODODO : MonoBehaviour {
    public static void OQQQQQODDO(ERCrossings scr, Single& firstSegmentDistance);
    public static void OODDQCQOQQ(List`1& vecs, float firstX, float firstZ, float lastX, float lastZ);
    public static Vector3 OCCDQDCQCD(int i, float radius, float angle);
    public static void OQODOQQCOO(ERCrossings scr);
    public static void ODOODDOQOQ(List`1<Vector3> vecs, float firstX, float firstZ, float sidewalkWidth, float resolution, float currentDist);
    public static void OOOCDOCQQO(ERCrossings scr);
    public static void OOOCOQODOO(List`1<Vector3> targetVecs, float targetValue, float firstX, float firstZ, float resolution, int xorz);
    public static void OCOOOQQQQO(ERCrossings scr);
    public static List`1<Vector3> OOOCCCCDDQ(List`1<Vector3> sourceVecs, float leftRight, float distance);
    public static void OOCCOQQDQQ(ERCrossings scr);
    public static List`1<Vector3> OOOODDQDCC(List`1<Vector3> sourceVecs, int xorz);
}
[AddComponentMenu("")]
public class EasyRoads3Dv3.OQQCCQCDQQ : MonoBehaviour {
    [HideInInspector]
public QDQDOOQQDQODD roadType;
    [HideInInspector]
public double roadTypeID;
    [HideInInspector]
public int roadTypeIndex;
    [HideInInspector]
public int geometryType;
    [HideInInspector]
public ERExitType exitType;
    [HideInInspector]
public float offset;
    [HideInInspector]
public int halfwayIndex;
    [HideInInspector]
public int startSplineIndex;
    [HideInInspector]
public int endSplineIndex;
    [HideInInspector]
public Vector3 endSplinePointRight;
    [HideInInspector]
public Vector3 endSplinePointLeft;
    [HideInInspector]
public float startDistance;
    [HideInInspector]
public float endDistance;
    [HideInInspector]
public int markerIndex;
    [HideInInspector]
public int extrusionType;
    [HideInInspector]
public AnimationCurve extrusionCurve;
    [HideInInspector]
public float extrusionDistance;
    [HideInInspector]
public int startDistanceIndex;
    [HideInInspector]
public float startDecalDistance;
    [HideInInspector]
public float fixedDistance;
    [HideInInspector]
public int fixedDistanceIndex;
    [HideInInspector]
public float splitDistance;
    [HideInInspector]
public AnimationCurve splitCurve;
    [HideInInspector]
public float splitEndWidth;
    [HideInInspector]
public float connectionAngle;
    [HideInInspector]
public float connectionRadius;
    [HideInInspector]
public ERModularRoad road;
    [HideInInspector]
public ERCrossingPrefabs connector;
    [HideInInspector]
public Vector3 connectionHandlePosition;
    [HideInInspector]
public Vector3 OCODOQDODQ;
    [HideInInspector]
public Vector3 handleDirection;
    [HideInInspector]
public GameObject surfaceMesh;
    [HideInInspector]
public GameObject exitSignObject;
    [HideInInspector]
public float exitSignObjectOffset;
    [HideInInspector]
public GameObject exitSignObjectInstance;
    [HideInInspector]
public GameObject exitSplitSpawnObject;
    [HideInInspector]
public int exitSplitSpawnType;
    [HideInInspector]
public float exitSplitSpawnDistance;
    [HideInInspector]
public float exitSplitSpawnStartOffset;
    [HideInInspector]
public float exitSplitSpawnOffset;
    [HideInInspector]
public float exitSplitSpawnObjectBounds;
    [HideInInspector]
public List`1<GameObject> spawnedSplitObjects;
    [HideInInspector]
public List`1<Vector3> soPointsRightStart;
    [HideInInspector]
public int soRightSplitEndIndex;
    [HideInInspector]
public List`1<Vector3> soPointsLeftStart;
    [HideInInspector]
public int startLineMarkingDecal;
    [HideInInspector]
public bool startDecalFoldout;
    [HideInInspector]
public int splitLineMarkingDecal1;
    [HideInInspector]
public bool splitDecal1Foldout;
    [HideInInspector]
public int splitLineMarkingDecal2;
    [HideInInspector]
public bool splitDecal2Foldout;
    [HideInInspector]
public List`1<Vector3> edgeVecs;
    [HideInInspector]
public List`1<Vector3> vecs;
    [HideInInspector]
public List`1<Vector2> uvsArray;
    [HideInInspector]
public List`1<Vector2> uvsArray2;
    [HideInInspector]
public List`1<Color> customColors;
    [HideInInspector]
public List`1<Color> colors;
    [HideInInspector]
public List`1<int> tris;
    [HideInInspector]
private int ᙃ;
    [HideInInspector]
private int ᙄ;
    [HideInInspector]
private int ᙅ;
    [HideInInspector]
private List`1<Vector3> 4AAAA;
    [HideInInspector]
private List`1<Vector3> 5AAA1;
    [HideInInspector]
private List`1<Vector3> 6AAAA;
    [HideInInspector]
private List`1<float> 7AAA1;
    [HideInInspector]
private List`1<Vector3> 8AAAA;
    [HideInInspector]
private Vector3 9AAA1;
    [HideInInspector]
private float BAAAA;
    [HideInInspector]
private float CAAA1;
    [HideInInspector]
private float 00AAA;
    [HideInInspector]
private float 10AA1;
    [HideInInspector]
private int 20AAA;
    [HideInInspector]
private int 30AA1;
    [HideInInspector]
public List`1<Vector3> treeVecs;
    [HideInInspector]
public List`1<Vector3> detailVecs;
    public static void OOOCDQDQDC(List`1<ERMarkerExt> markers, List`1<OQQCCQCDQQ> exitRoads, List`1& splinePoints, List`1& tValues);
    public static void ODOCDDDDDO(List`1<ERMarkerExt> markers, OQQCCQCDQQ exitRoad, List`1& splinePoints, List`1& tValues, int currentInt);
    public static void OQCCQOQDDO(ERModularBase baseScript, ERModularRoad road, List`1<OQQCCQCDQQ> exitRoads, List`1<ERMarkerExt> markers, List`1& soSplinePointsLeft, List`1& soSplinePointsRight, Boolean& hasExits, List`1<float> leftIndentFloats, List`1<float> rightIndentFloats, List`1<float> leftSurroundingFloats, List`1<float> rightSurroundingFloats, List`1& surfaceVecs);
    public static void OCCCOOCCQC(ERModularBase baseScript, ERModularRoad road, OQQCCQCDQQ exitRoad, List`1& soSplinePointsLeft, List`1& soSplinePointsRight, List`1<float> leftIndentFloats, List`1<float> rightIndentFloats, List`1<float> leftSurroundingFloats, List`1<float> rightSurroundingFloats, List`1& roadSurfaceVecs);
    public void BuildMeshInit(OQQCCQCDQQ exitRoad, List`1<Vector3> vecs, List`1<Vector2> uvs, List`1<int> tris, List`1<Color> colors, Material mat, ERModularRoad road);
    public void OQDDCODQCD();
    public void SpawnSplitObjects();
    public void OQDDCCQOOO(Int32& curGo, Vector3 v);
    public static void OOOOOCODQO(OQQCCQCDQQ exitRoad, int vecCount, List`1<Vector3> vecs, List`1<Vector2> uvsArray, List`1<int> tris);
    public static void ODQCODOCDO(OQQCCQCDQQ exitRoad, int vecCount, List`1<Vector3> vecs, List`1<Vector2> uvsArray, List`1<int> tris, int decalIndex);
    public static void OQCCDDDOQQ(int i, int j, Vector3 prevPos, List`1<Vector3> edgeVecs, List`1<Vector3> soSplinePointsRight, float angleThreshold, List`1& tmpvecs);
    private static void OOOQCQDCDD(int curLeft, int endLeft, int curRight, int endRight, List`1<int> rightInts, List`1<Vector3> vecs, List`1& tris);
    public static void ODCDCQCOCQ(List`1<Vector3> vecs, List`1& tris);
    public static void ODQDQDCOQD(ERModularBase baseScript, ERModularRoad road, OQQCCQCDQQ exitRoad, List`1& soSplinePointsLeft, List`1& soSplinePointsRight);
    public static void ODDDDDDQQD(ERModularBase baseScript, ERModularRoad road, ERMarkerExt marker, List`1& soSplinePointsLeft, List`1& soSplinePointsRight);
    public static void OQDOQDDCDD(ERModularBase baseScript, ERModularRoad road, OQQCCQCDQQ exitRoad, List`1<ERMarkerExt> markers, List`1<List`1<Vector3>> exitOuterVerticesExtrusion, List`1<List`1<Vector3>> exitOuterVerticesFixed, List`1<List`1<Vector3>> exitOuterVerticesCurve, List`1<Vector3> exitInnerVertices);
    public static void OCDQCQDDOQ(ERModularBase baseScript, ERModularRoad road, List`1<ERMarkerExt> markers);
    public static void OCDDDOQCCO(ERModularBase baseScript, List`1<ERMarkerExt> markers, List`1& vecs, List`1& uvsArray, List`1& uvsArray2, List`1& customColors, List`1& colors, List`1& tris, Material[]& materialsList);
    public static void OCDDCCQCCD(Int32& triIndex, List`1& tris, Material[]& materialsList, Material m);
    public static float OQQDDDDDOC(Vector3 v, List`1<Vector3> soSplinePointsLeft, List`1<Vector3> soSplinePointsRight, Int32& cInt, bool flag, Int32& match);
    private static void ODDDOCDCQO(List`1<Vector3> vecs, List`1<Vector2> uvs, List`1<int> tris, List`1<Color> colors, Material mat, GameObject go, ERModularRoad road);
    private void OCCDCQQDOQ(List`1<Vector3> vecs, List`1<int> connectionInts, List`1<Vector3> surfaceVecs, Vector3 prefDirVec);
    public Vector3 ODCCQQDQQQ();
    public void OCQOQQCDOD(List`1<Vector3> surfaceVecs, List`1<Vector2> uvs, int firstSection, int secondSection);
}
[AddComponentMenu("")]
public class EasyRoads3Dv3.OQQDOCQOCO : MonoBehaviour {
    public static void OQDCOQDQDO(ERCrossings scr, List`1& meshVecs, List`1& meshUVs, List`1& triList, List`1<Material> materialList, List`1<Material> connectionMaterialList);
    public static void OCODCOCODQ(ERCrossings scr, List`1<List`1<Vector3>> vecArray, List`1<List`1<Vector2>> uvArray, int frontLeft, int topBottom, List`1& meshVecs, List`1& meshUVs, List`1& triList, List`1& intArray, int startRow, int triArrayIndex, int connection, List`1& borderIntsLeft, List`1& borderIntsRight, int centerPointIndex);
    public static List`1<int> OODCODOODC(List`1<List`1<int>> intArray);
    public static List`1<int> OCCQOODCCO(List`1<int> col1, List`1<int> col2, int startRow, int type);
    public static List`1<int> OOQCQQDDQC(List`1<int> col1, List`1<int> col2, List`1<Vector3> vecs1, List`1<Vector3> vecs2, int frontLeft, int topBottom, int startRow);
    public static void InitODCOCQQDDC(ERCrossings scr);
    public static void ODCOCQQDDC(ERCrossings scr, List`1<List`1<Vector3>> vecArray, List`1& uvs, List`1& uvArray, int verthorz, float uvTiling);
}
public class EasyRoads3Dv3.PointERV3 : object {
    public float timeCreated;
    public Vector3 position;
    public bool lineBreak;
    public int curveFlag;
    public float Time;
    public int x;
    public int y;
    public int z;
}
[AddComponentMenu("")]
public class EasyRoads3Dv3.QDDDQODDQDQDQDD : MonoBehaviour {
    public static Vector3 testPoint;
    public static ERCrossings cScr;
    public static List`1<Vector3> ll1;
    public static List`1<Vector3> ll2;
    public static List`1<Vector3> ll3;
    public static List`1<Vector3> ll4;
    public static int crossingStructure;
    public static List`1<QDQDOOQQDQODD> roadTypesDynamic;
    public static ERModularBase baseScript;
    public static List`1<ERConnectionSibling> siblings;
    public static Vector3 crossPointCenter;
    public static ERCrossingPrefabs prefabScript;
    public static ERConnectionSibling primaryPriorityConnection;
    public static ERConnectionSibling secondPriorityConnection;
    private static float ᙃ;
    private static float ᙄ;
    public static List`1<Vector3> debugEdges;
    public static List`1<Vector3> debugvecs;
    private static QDDDQODDQDQDQDD();
    public static List`1<QDQDOOQQDQODD> OQQCDQOQCD(List`1<QDQDOOQQDQODD> roadTypes, bool all);
    public static void OQODQQQCOC(ERCrossings scr);
    public static void ODODCOOQDO();
    public static bool OCODDQQOCQ(List`1<ERConnectionSibling> siblings, int thisSibling, int OtherSibling, int startLane);
    public static void OQCDQDQOOO(bool hasLaneControlData);
    public static ERLaneConnector OCODCDQQOQ(ERCrossings scr, int startConnectionIndex, int startLaneIndex, int endConnectionIndex, int endLaneIndex, bool stop);
    public static void OQQDCODOQD(ERCrossingPrefabs scr, ERLaneConnector& conn, int startConnectionIndex);
    public static bool OQQQQQODQD(Vector3 left, Vector3 rightStart, Vector3 rightEnd, Single& angle1, float prevAngle1, float angle2, bool flag);
    public static Vector3 OODQQDCDCD(float distance, float angle);
    public static void OQDOCDCQCD(Vector3 cp, float roadWidth, Vector3& lStart, Vector3& lEnd, Vector3& rStart, Vector3& rEnd, float largestRadius);
    public static void GetOCOCQCDDCD(Vector3 cp, float radius, int cornerSegments, Vector3 leftPoint, Vector3 rightPoint, List`1& leftpoints, List`1& rightpoints, bool flag);
    private static void OOCCQCDQQC(List`1<Vector3> rightPoints1, List`1<Vector3> leftPoints1, List`1<Vector3> leftPoints2, List`1<Vector3> rightPoints2, List`1& outerpoints, List`1& innerpoints, float dist);
    private void OOOQOQODDD(Single& uvRatio, List`1& priorityLeftPoints, List`1& priorityRightPoints, List`1& rightRoundingPoints, List`1& leftRoundingPoints, List`1& leftRoundingPointsOther, List`1& rightRoundingPointsOther);
    private static bool OOCOCOCDQD(float radius, int cornerSegments, Vector3 startPoint, Vector3 endPoint, List`1& points, List`1& priorityPoints, float curvature, bool swapflag, bool priorityIsSingleSection, Vector3 prioritySectionDir, int leftright, bool leftRightCheck, Int32& mainIndex, Boolean& insertFlag);
    private static void MatchLeftRights(List`1& leftRoundingPoints, Vector3 lStart, List`1& rightRoundingPoints, Vector3 rStart);
    public static void OOCDCOQDDO(List`1<Vector3> leftRoundingPoints, List`1<Vector3> rightRoundingPoints, List`1& roadVecs, List`1<Vector2> roadShape, int leftFixedPoint, int rightFixedPoint, int middleIndex, Vector3 cp, Vector3 cp1, List`1& priorityPointsMain, ERConnectionSibling prioritySibling, bool isSecondary);
    public static bool OOCOCCQDCQ(Vector3 v, List`1<Vector3> points, int firstIndex, int lastIndex);
    public static void OODQCOCOQD(List`1<Vector3> leftRoundingPoints, List`1<Vector3> rightRoundingPoints, List`1& roadVecs, List`1<Vector2> roadShape, int leftFixedPoint, int rightFixedPoint, int middleIndex, Vector3 cp, Vector3 cp1);
    public static void OQQDQCQCDQ(List`1<Vector3> roundingPoints, List`1& pointsIndents, float indent, Vector3 lp, Vector3 rp, bool leftSide);
    public static void OOQQOOOQOO(List`1& centerPoints, List`1<Vector3> leftRoundingPoints, List`1<Vector3> leftPointsIndents, List`1<Vector3> rightRoundingPoints, List`1<Vector3> rightPointsIndents, Vector3 cp);
    public static void OOCCDOCDDC(List`1& centerPoints, List`1<Vector3> leftRoundingPoints, List`1<Vector3> leftPointsIndents, List`1<Vector3> rightRoundingPoints, List`1<Vector3> rightPointsIndents);
    public static void MatchInnerOCOCQCDDCD(List`1& innerArray, List`1<Vector3> startVecs, List`1<Vector3> endVecs);
    public static void ODDCCDQDCO(List`1& targetArray, List`1<Vector3> otherArray);
    public static void ERODOCDOOCCC(List`1<List`1<Vector3>> roadVecs, List`1<float> shapeUVs, List`1& uvs, List`1<Vector3> priorityPointsMain, List`1& priorityPointsMainUVs, Vector2 cp, float uvRatio, ERConnectionSibling sibling, bool primarySection);
    public static void OCQODCQDOD(List`1<Vector3> leftRoundingPoints, List`1<Vector3> leftPointsIndents, List`1<Vector3> centerPoints, List`1<Vector3> rightPointsIndents, List`1<Vector3> rightRoundingPoints, List`1& leftRoundingPointsUV, List`1& leftPointsIndentsUV, List`1& centerPointsUV, List`1& rightPointsIndentsUV, List`1& rightRoundingPointsUV, Vector2& cp, float leftIndentUVX, float rightIndentUVX);
    public static void OCOQCCQCCC(List`1<Vector3> leftRoundingPoints, List`1<Vector3> rightRoundingPoints, List`1& leftRoundingPointsUV, List`1& rightRoundingPointsUV);
    public static void OOCDCQQQCD(List`1& leftRoundingPoints, List`1& rightRoundingPoints, List`1& centerPoints, Vector3& cpLeft, Vector3& cpRight, List`1<Vector3> priorityRoad, float cornerRadius, float cornerSegments, Vector3 lStart, Vector3 lEnd, Vector3 rStart, Vector3 rEnd, float leftIndent, float leftIndentUVX, float rightIndent, float rightIndentUVX);
    public static void OOOQCOOQDD(List`1<Vector3> outerPoints, Vector3 pos, Single& uvX, float indentUVX, float indentdist, int leftright);
    public static void OCOCCCCDOO(List`1& indentPoints, List`1<Vector3> outerPoints, List`1<Vector3> priorityConnectionPoints, int leftright);
    public static void OQDQCQCDQQ(List`1& centerPoints, List`1<Vector3> priorityConnectionPoints);
    public static void ODDDOCDCQO(List`1<ERConnectionSibling> priorityRoads, List`1<ERConnectionSibling> primaryRoads);
    public static void OQOQDQDOOO(Transform tr, ERConnectionSibling sibling, int index);
    public static void ODODQCDCOD(List`1& tris, List`1& vecs, List`1& uvs, List`1<List`1<Vector3>> vecsData, List`1<List`1<Vector2>> uvsData, List`1<Vector3> priorityPointsMain, List`1<Vector2> priorityPointsMainUVs, List`1& colors, List`1<bool> originalShapeVecs, List`1& connInts, int totalVecs, List`1& secondPriorityInts, bool singleSectionFlag, ERConnectionSibling sibling);
    public static void ODDCQODOCD(List`1& tris, List`1& vecs, List`1& uvs, List`1<List`1<Vector3>> vecsData, List`1<List`1<Vector2>> uvsData, List`1<Vector3> priorityPointsMain, List`1<Vector2> priorityPointsMainUVs, List`1& colors, List`1<bool> originalShapeVecs, List`1& connInts, int totalVecs, List`1& secondPriorityInts, bool singleSectionFlag, ERConnectionSibling sibling);
    private static void OQCDQQOCOC(int curLeft, int endLeft, int curRight, int endRight, List`1<Vector3> vecs, List`1& tris, ERConnectionSibling sibling);
    private static void OOOQCQDCDD(int curLeft, int endLeft, int curRight, int endRight, List`1<int> rightInts, List`1<Vector3> vecs, List`1& tris, ERConnectionSibling sibling);
    public static void OCDOQDDCQC(List`1& tris, List`1& vecs, List`1& uvs, List`1<List`1<Vector3>> vecsData, List`1<List`1<Vector2>> uvsData, List`1<Vector3> priorityPointsMain, List`1<Vector2> priorityPointsMainUVs, List`1& colors, List`1<bool> originalShapeVecs, List`1& connInts, int totalVecs, List`1& secondPriorityInts, bool singleSectionFlag, ERConnectionSibling sibling);
    public static void OOCCQCDDDQ(List`1& tris, List`1& vecs, List`1& uvs, List`1<List`1<Vector3>> vecsData, List`1<List`1<Vector2>> uvsData, List`1<Vector3> priorityPointsMain, List`1<Vector2> priorityPointsMainUVs, List`1& colors, List`1<bool> originalShapeVecs, List`1& connInts, int totalVecs, List`1& secondPriorityInts, bool singleSectionFlag, ERConnectionSibling sibling);
    public static void OQCQQDDDCQ(List`1& tris, List`1& vecs, List`1& uvs, List`1& uvs1, List`1& uvs2, List`1& colors, List`1<Vector3> mleftPoints, List`1<Vector3> rightPoints, List`1<Vector3> centerPoints, Vector3 leftPoint, Vector3 rightPoint, List`1<Vector2> leftRoundingPointsUV, List`1<Vector2> rightRoundingPointsUV, List`1<Vector2> centerPointsUV, Vector2 cpUV, List`1<Vector3> leftPointsIndents, List`1<Vector2> leftPointsIndentsUV, List`1<Vector3> rightPointsIndents, List`1<Vector2> rightPointsIndentsUV);
    public static void OCDCQDDDCC(List`1& tris, List`1& vecs, List`1& uvs, List`1& uvs1, List`1& uvs2, List`1& colors, List`1<Vector3> mleftPoints, List`1<Vector3> rightPoints, List`1<Vector3> centerPoints, Vector3 leftPoint, Vector3 rightPoint, List`1<Vector2> leftRoundingPointsUV, List`1<Vector2> rightRoundingPointsUV, List`1<Vector2> centerPointsUV, Vector2 cpUV, List`1<Vector3> leftPointsIndents, List`1<Vector2> leftPointsIndentsUV, List`1<Vector3> rightPointsIndents, List`1<Vector2> rightPointsIndentsUV);
    public static void ForkPriorityOCODCOCODQ(List`1& tris, List`1& vecs, List`1& uvs, List`1& uvs1, List`1& uvs2, List`1& colors, List`1<Vector3> mleftPoints, List`1<Vector3> rightPoints, List`1<Vector3> centerPoints, Vector3 leftPoint, Vector3 rightPoint, List`1<Vector2> leftRoundingPointsUV, List`1<Vector2> rightRoundingPointsUV, List`1<Vector2> centerPointsUV, Vector2 cpUV, List`1<Vector3> leftPointsIndents, List`1<Vector2> leftPointsIndentsUV, List`1<Vector3> rightPointsIndents, List`1<Vector2> rightPointsIndentsUV, List`1<Vector3> mainPoints, List`1<Vector2> mainPointsUV);
    private void OCOQOCDCCQ(List`1& tris, List`1& vecs, List`1& uvs, List`1& uvs1, List`1& uvs2, List`1& colors, List`1& trisTmp, List`1& vecsTmp, List`1& uvsTmp, List`1& uvsTmp1, List`1& uvsTmp2, List`1& colorsTmp, bool skipMiddles, bool weldVecs);
    private static void MergeMeshDataExt(List`1& tris, List`1& vecs, List`1& uvs, List`1& uvs1, List`1& uvs2, List`1& colors, List`1& trisTmp, List`1& vecsTmp, List`1& uvsTmp, List`1& uvsTmp1, List`1& uvsTmp2, List`1& colorsTmp, bool skipMiddles, bool weldVecs, Material mat, List`1& mats);
    private void OCQODCOQDO(List`1& tris, List`1& vecs, List`1& uvs, List`1& uvs1, List`1& uvs2, List`1& colors, List`1& trisTmp, List`1& vecsTmp, List`1& uvsTmp, List`1& uvsTmp1, List`1& uvsTmp2, List`1& colorsTmp, bool skipMiddles, bool weldVecs);
    public static List`1<int> Triangulate(List`1<Vector3> vecs, List`1<Vector3> edges);
    public static void OCQDDOQCOQ(QDOODOQQDQODD connection, ERConnectionSibling sibling, int index, int total);
    public static void OOCQCOOOOO(List`1<ERConnectionSibling> siblings, int index);
    public static bool OQQQQQQQCD(QDQDOOQQDQODD roadType);
    public static Vector3 OOQCQDQCOO(int index, Vector3 p0, Vector3 p1, Vector3 p2);
    public static void Clear();
    public static void OOODDOCOOO();
    public static void OOOQQDDCCQ(ERTexture roadERTexture, Single& roadWidth, Single& leftIndent, Single& rightIndent, Single& leftUVX, Single& rightUVX, Single& leftIndentInner, Single& rightIndentInner, Single& roadOuterUVXInner, float cornerRadius);
    public static void OQOCODDDDC(int connection, QDQDOOQQDQODD roadType);
    public static float OOCDQCOCQO(Vector3 v1, Vector3 v2, Vector3 n);
    public static Vector3 OQOQODOOCD(Vector3 dirPos1, Vector3 dirPos2, Vector3 currentPos, List`1<Vector3> vecs, int startend);
    public static Vector3 ODQQOCDCOC(Vector3 currentPos, List`1<Vector3> vecs, Int32& index, int startend);
    public static bool OQQOCCCOCD(Vector3 p1, Vector3 p2, Vector3 v);
}
public class EasyRoads3Dv3.QDOODOQQDQODD : object {
    public Vector3 centerPoint;
    public Vector3 tmpCenterPoint;
    public Vector3 stageCenterPoint;
    public Vector3 tmpStageCenterPoint;
    public List`1<ERBlendVecs> blendData;
    public Vector3 controlPointV3;
    public Vector2 controlPoint;
    public float blendDistance;
    public float extendBounds;
    public List`1<Vector3> blendCornerPoints;
    public List`1<int> blendCornerPointInts;
    public List`1<float> blendCornerPointWeights;
    public List`1<Vector3> blendCornerPointsTransformed;
    public float blendRatio;
    public float curveStrength;
    public List`1<Vector2> roadShapeVecs;
    public string roadShapeVecsString;
    public int roadShapeMatchCount;
    public List`1<float> roadShapeUVY;
    public List`1<float> roadShapeUVY2;
    public List`1<bool> hardEdge;
    public List`1<int> roadShapeMaterialInts;
    public List`1<Vector2> sidewalkLeftVecs;
    public List`1<float> sidewalkLeftUVY;
    public List`1<int> sidewalkLeftMaterialInts;
    public List`1<Vector2> sidewalkRightVecs;
    public List`1<float> sidewalkRightUVY;
    public List`1<int> sidewalkRightMaterialInts;
    public List`1<ERConnectionVecs> connectionVecs;
    public List`1<int> connectionVecInts;
    public List`1<int> fullConnectionVecInts;
    public List`1<int> sidewalkLeftConnectionVecInts;
    public List`1<int> sidewalkRightConnectionVecInts;
    public List`1<bool> doConnectionTri;
    public List`1<int> outerVecInts;
    public bool rotationPriority;
    public float centerPointAngle;
    public ERModularRoad connectedRoad;
    public int connectedMarker;
    public GameObject connectedRoadGO;
    public bool includeLeftSidewalk;
    public bool includeRightSidewalk;
    public Material roadMaterial;
    public Material[] roadMaterials;
    public float centerPointPercentage;
    private float ᙃ;
    public int leftIndent;
    public int rightIndent;
    public int leftSurrounding;
    public int rightSurrounding;
    public Vector3 leftIndentV3;
    public Vector3 leftSurroundingV3;
    public Vector3 rightIndentV3;
    public Vector3 rightSurroundingV3;
    public Vector3 leftRoadpoint;
    public Vector3 rightRoadpoint;
    public int leftCornerInt;
    public int rightCornerInt;
    public int leftIndentInt;
    public int rightIndentInt;
    public int leftInt;
    public int rightInt;
    public int leftIntFull;
    public int rightIntFull;
    public Vector3 alignmentHandleVec;
    public float additionalIndentDistance;
    public float connectionAngle;
    public Vector3 alignmentHandleVecRotationGizmo;
    public bool inwards;
    public double roadType;
    public double roadTypeTimestamp;
}
public class EasyRoads3Dv3.QDOQDSQOOQDDD : object {
    public int crossingElementLeftIndex;
    public int crossingElementRightIndex;
    public Vector3 centerHandleV3;
    public Vector3 centerHandleV3_2;
    public Vector3 leftHandleV3;
    public Vector3 rightHandleV3;
    public bool renderFlag;
    public bool leftConnectionHandle;
    public bool rightConnectionHandle;
    public float sidewalkWidth1;
    public float sidewalkWidth2;
    public float curbHeight;
    public float curbDepth;
    public bool beveledCurb;
    public float beveledHeight;
    public float beveledDepth;
    public bool outerCurb;
    public bool roadSideCurbUVControl;
    public bool outerSideCurbUVControl;
    public Material sidewalkMaterial;
    public List`1<float> sidewalkUVs;
    public List`1<float> curbUVs;
    public bool lockUVs;
    public float cornerRadius;
    public int cornerSegments;
    public float innerSegmentDistance;
    public float startAngle;
    public QDOQDSQOOQDDD(ERModularBase scr);
    public void CopyFromSidewalk(ERSideWalk sw);
    public static bool ERSidewalkMatch(QDOQDSQOOQDDD sw1, QDOQDSQOOQDDD sw2);
}
public class EasyRoads3Dv3.QDQDOOQQDQODD : object {
    public string roadTypeName;
    public double id;
    public double timestamp;
    public float roadWidth;
    public float faceDistance;
    public float angleTreshold;
    public float uvTiling;
    public int uv4Type;
    public ERRoadWayType type;
    public float detailDistance;
    public bool planarUVs;
    public float outerIndent;
    public bool roadShapeDataActive;
    public ERRoadShape roadShapeData;
    public float minSpeed;
    public float maxSpeed;
    public float speedLimit;
    public List`1<Vector2> roadShape;
    public List`1<Vector2> roadShapeExt;
    public List`1<Vector2> roadShapeExt2;
    public List`1<bool> doConnectionTri;
    public List`1<bool> doConnectionTriExt;
    public List`1<float> roadShapeUVs;
    public List`1<float> roadShapeExtUVs;
    public List`1<float> roadShapeExtUVs2;
    public List`1<float> roadShapeUVs2;
    public bool preserveUVs;
    public List`1<bool> hardEdge;
    public string roadShapeVecsString;
    public double defaultSidewalk;
    public bool sidewalks;
    public float sidewalkHeight;
    public float sidewalkWidth;
    public Material roadMaterial;
    public Material[] roadMaterials;
    public PhysicMaterial roadPhysicsMaterial;
    public PhysicMaterial[] roadPhysicsMaterials;
    public Material connectionMaterial;
    public bool isSideObject;
    public bool isCustomRoad;
    public int subSegments;
    public List`1<ERSORoad> soData;
    public List`1<ERSORoadExt> soDataExt;
    public List`1<ERSORoadLog> soDataLog;
    public int layer;
    public bool isStatic;
    public string tag;
    public bool splatMapActive;
    public int splatIndex;
    public int expandLevel;
    public int smoothLevel;
    public float splatOpacity;
    public bool followTerrainContours;
    public float terrainContoursOffset;
    public bool terrainDeformation;
    public float defaultIndent;
    public float defaultSurrounding;
    public bool castShadow;
    public bool randomnessFlag;
    public float randomYPosition;
    public float randomMinYPosition;
    public float randomMaxYPosition;
    public float minRandomYPositionDistance;
    public float maxRandomYPositionDistance;
    public float randomMinRotation;
    public float randomMaxRotation;
    public float minRandomRotationDistance;
    public float maxRandomRotationDistance;
    public bool vegetationStudioMaskLineActive;
    public float vegetationStudioGrassPerimeter;
    public float vegetationStudioPlantPerimeter;
    public float vegetationStudioTreePerimeter;
    public float vegetationStudioObjectPerimeter;
    public float vegetationStudioLargeObjectPerimeter;
    public bool vegetationStudioBiomeMaskActive;
    public float vegetationStudioBiomeMaskDistance;
    public float vegetationStudioBiomeMaskBlendDistance;
    public float vegetationStudioBiomeMaskNoiseScale;
    public List`1<ERDecal> decalPresets;
    public List`1<ERDecalClass> decalClassPresets;
    public double defaultRamp;
    public int extrusionType;
    public float extrusionDistance;
    public float fixedDistance;
    public float connectionAngle;
    public float connectionRadius;
    public int isRoadShape;
    public int controlType;
    public QDQDOOQQDQODD(int count);
    public void RoadTypeUpgrade();
    public int GetTagIndex(String[] tags);
    public static int GetTagIndex(String[] tags, string tag);
    public void OQQOCCODOD();
    public void UpdateTimestamp();
    public static bool ODQDDOCDDC(ERModularBase scr);
    public static String[] RoadNames(List`1<QDQDOOQQDQODD> roadTypes);
    public static String[] Nodes(ERRoadShape data);
    public static String[] LaneNodes(ERRoadShape data);
    public static GUIContent[] LaneNodesContents(ERRoadShape data);
    public void ODQQQODOQD();
    public static int SetRoadType(List`1<QDQDOOQQDQODD> roadTypes, double roadType);
    public void UpdateUVs();
    public static QDQDOOQQDQODD GetRoadTypeElByID(List`1<QDQDOOQQDQODD> roadTypes, double id);
    public static int ODDQDCOODD(List`1<QDQDOOQQDQODD> roadTypes, double id, String[]& ramps, QDQDOOQQDQODD[]& rampTypes);
    public static int GetRoadTypeByID(List`1<QDQDOOQQDQODD> roadTypes, double id);
    public static bool OOQDCODDCO(List`1<QDQDOOQQDQODD> roadTypes, double id, QDQDOOQQDQODD& motorwayLink);
    public static String[] ODODCOQODO(List`1<QDQDOOQQDQODD> roadTypes);
    public static bool GetTerrainDeformationByID(List`1<QDQDOOQQDQODD> roadTypes, double id, Int32& element);
    public static void UpdateUVTiling(List`1<QDQDOOQQDQODD> roadTypes, double id, float tiling);
    public static void UpdateResolution(List`1<QDQDOOQQDQODD> roadTypes, double id, Single& resolution, Single& threshold);
    public void OCDOCDQQQO(QDQDOOQQDQODD sourcePreset, List`1<SideObject> sceneSideObjects, List`1<SideObjectLog> projectSideObjects, bool copyShapeData);
    public static void OOOCDCQQCO(QDQDOOQQDQODD sourcePreset, ERModularRoad road, bool update, int customShapeHandling, bool checkRoadWidth);
    public static void AssignSideObjects(ERModularBase scr, int roadTypeInt, ERModularRoad OCCQOOOQQO);
    public static void HasActiveSideObjects(List`1<ERSORoadExt> sos1, List`1<ERSORoadExt> sos2, Boolean& flag1, Boolean& flag2);
    public int OOOOCQCDDC(int index, ERLaneDirection direction);
    public static bool ODCDDDQCQQ(QDQDOOQQDQODD rt1, QDQDOOQQDQODD rt2);
}
[AddComponentMenu("")]
public class EasyRoads3Dv3.QDQDOOQQOOQDD : MonoBehaviour {
    private List`1<Vector3> ᙃ;
    private Single[0...,0...] ᙄ;
    private Single[] ᙅ;
    private TerrainData 4AAAA;
    public static float minx;
    public static float minz;
    public static float maxx;
    public static float maxz;
    public static Vector2 splatMapScale;
    public static List`1<GameObject> surfaceObjects;
    public static List`1<GameObject> tunnelObjects;
    public static int crossingSurfacesStart;
    public static int sideObjectSurfacesStart;
    public static List`1<GameObject> treeObjects;
    public static List`1<GameObject> detailObjects;
    private static QDQDOOQQOOQDD();
    public static void ODDCCODOOC(ERModularBase scr, Terrain terrain);
    public static void ODCQDDOQCD(ERModularBase scr, ERTerrain terrainScr, Terrain terrain, float m_minx, float m_maxx, float m_minz, float m_maxz);
    public static void OOCQDQCDOD(int triangleIndex, Collider collider, Vector3 hitPos, Single& perc, Boolean& critical, Single& outerHeight, Vector3& outerPoint, RaycastHit hit);
    public static void GetHitPointInfoOld(int triangleIndex, Collider collider, Vector3 hitPos, Single& perc, Boolean& critical, Single& outerHeight, Vector3& outerPoint);
    public static void OQOQCCCODC(ERModularBase scr, Single& minx, Single& minz, Single& maxx, Single& maxz, float splatmapScale);
    public static void ODQODCQQCQ(ERModularBase scr, ERTerrain terrainScr, Terrain terrain, float minx, float maxx, float minz, float maxz);
    public static void OOCDDQCCDD(ERModularBase scr, ERTerrain terrainScr, Terrain terrain, float minx, float maxx, float minz, float maxz);
    public static void OOCDDOOCQC(ERModularBase scr, ERTerrain terrainScr, Terrain terrain, float minx, float maxx, float minz, float maxz);
    public static void OCCDDODDDD(Boolean[0...,0...]& holes, Single[0...,0...] heights, float height, List`1& terrainScrHoles, Vector3 lp, Vector3 rp, Vector3 terrainPos, float stepx, float stepy, float tHeight, float size);
    public static bool ODQODDQCCD(Single[0...,0...] heights, float height, int x, int y, float rHeight, float tHeight, float size, float terrainY);
    public static void ODQCOCOQQD(ERModularBase scr, ERTerrain terrainScr, Terrain terrain, float minx, float maxx, float minz, float maxz);
    public static Single[0...,0...,0...] OCCODCQOCO(List`1<ERSplatmap> mapData, Single[0...,0...,0...] trmap, int layers);
    public static void ODODDDDCOQ(ERModularBase scr, ERTerrain terrainScr, Terrain terrain);
    public static void OQQOQOQQQC(ERTerrain terrainScr, Terrain terrain);
    public static void ODCOOQCCCD(ERTerrain terrainScr, Terrain terrain);
    public static void OOQDOQDCOO(TerrainData terrainInfo, int layer, List`1<tPoint> points);
    public static List`1<tPoint> OQODQCQCCQ(ERModularBase scr, Terrain terrain, TerrainData terrainInfo, float minx, float maxx, float minz, float maxz);
    public static void OQCQDDOOCQ(ERTerrain tr, Terrain terrain);
    public static void OOODOOOQCC(ERTerrain tr, Terrain terrain, float perc);
    public static void OOOCCDQODO(GameObject go, int x, int y, List`1& instances, Single[0...,0...,0...] trmap, int layers, Vector2 uvy);
    public static void OOQQQQDCCO(ERModularBase baseScript, ERModularRoad scr);
    public static GameObject CreateMesh(Transform parent, List`1<Vector3> vecs, List`1<int> tris, int layer, ERModularRoad scr, string name);
    public static void OCCQODOQDD(ERTerrain terrain, string folder);
    public static void OQCOQDDCCC(ERTerrain terrain, string folder);
    public static void OOQQOOOQOO(ERTerrain terrain, string folder);
    public static void ODCOQQQCCO(ERTerrain terrain, string folder);
    public static void OCCOODODOQ(ERTerrain terrain, string folder);
    public static void OCCDQQCODQ(ERTerrain terrain, string folder);
    public static void OOOOCQCDQQ(ERTerrain terrain, string folder);
    public static void OOQOCCCCDD(ERTerrain terrain, string folder);
}
public class EasyRoads3Dv3.SelectedObject : ScriptableObject {
    public ERModularRoad roadScr;
    public ERCrossingPrefabs prefabScr;
    public List`1<int> markers;
    public int startEnd;
    public ERCrossingPrefabs prefab;
    public void Init(ERModularRoad rScr, ERCrossingPrefabs pScr, int marker);
    public static SelectedObject CreateInstance(ERModularRoad rScr, ERCrossingPrefabs pScr, int marker);
}
public class EasyRoads3Dv3.SideObject : ScriptableObject {
    public string version;
    public string name;
    public double id;
    public double timestamp;
    public int objectType;
    public string gameobjectGUID;
    public string textureGUID;
    public float m_distance;
    public float uvx;
    public float uvy;
    public int position;
    public float splinePosition;
    public int selectedRotation;
    public float randomYAxisMinRotation;
    public float randomYAxisMaxRotation;
    public List`1<Vector2> nodeList;
    public List`1<float> uvs;
    public List`1<float> uvDistances;
    public bool clampUVs;
    public bool clampUVY;
    public float clampUVYValue;
    public float totalDistance;
    public bool reverseUVs;
    public bool terrainUVs;
    public List`1<bool> snapList;
    public List`1<float> snapWeightList;
    public List`1<Color> colorList;
    public string gameobjectStartGUID;
    public string gameobjectEndGUID;
    public int align;
    public int alignPoint;
    public bool weld;
    public bool combine;
    public bool combineInstantiated;
    public bool markerActive;
    public int uvType;
    public float uv;
    public bool randomObjects;
    public float forwardStartOffset;
    public float sidewaysOffset;
    public float density;
    public string goPath;
    public string startPath;
    public string endPath;
    public string texturePath;
    public int terrainTree;
    public float minScale;
    public float maxScale;
    public bool childOrderActive;
    public int childOrder;
    public bool meshBoundsAlignment;
    public float xPosition;
    public float xPosition2;
    public int relativeTo;
    public float yPosition;
    public float yRotation;
    public float oldSidwaysDistance;
    public int sidewaysDistanceUpdate;
    public float uvYRound;
    public bool adjustUV;
    public bool collider;
    public bool boxcollider;
    public bool tangents;
    public GameObject sourceObject;
    public bool flipMesh;
    public GameObject startObject;
    public GameObject endObject;
    public GameObject connectionObject;
    public Material material;
    public List`1<ERMesh> meshObjects;
    public Vector2 boxSize;
    public Vector2 boxOffset;
    public bool includeStartSegment;
    public float startSegmentOffset;
    public bool includeStartEdgeTris;
    public bool includeEndSegment;
    public float endSegmentOffset;
    public bool includeEndEdgeTris;
    public bool adjustToRoadWidth;
    public float xOffset;
    public float startOffset;
    public float endOffset;
    public float defaultStartOffset;
    public float defaultEndOffset;
    public float totalZDistance;
    public float middleZDistance;
    public float startZDistance;
    public float endZDistance;
    public float minStartZ;
    public float maxStartZ;
    public float minMiddleZ;
    public float maxMiddleZ;
    public float minEndZ;
    public float maxEndZ;
    public bool smoothStart;
    public bool smoothMiddle;
    public bool smoothEnd;
    public GameObject targetObject;
    public bool bridgeObject;
    public bool tunnelObject;
    public bool snapToTerrain;
    public int layer;
    public bool deformationObject;
    public bool isStatic;
    public bool castShadows;
    public bool scaleToRoad;
    public bool splitInBatches;
    public List`1<GameObject> instantiatedObjects;
    public int maxVertices;
    public bool doTestmesh;
    public Vector3 testMeshPos;
    public Vector3 randomRotation;
    public float randomMinRotation;
    public float randomMaxRotation;
    public float minRandomRotationDistance;
    public float maxRandomRotationDistance;
    public float randomXPosition;
    public float randomMinXPosition;
    public float randomMaxXPosition;
    public float minRandomXPositionDistance;
    public float maxRandomXPositionDistance;
    public Vector3 boxColliderScale;
    public float randomYPosition;
    public float randomMinYPosition;
    public float randomMaxYPosition;
    public float minRandomYPositionDistance;
    public float maxRandomYPositionDistance;
    public bool indentController;
    public bool excludeTerrainSplats;
    public float x1;
    public float x2;
    public float xf1;
    public float xf2;
    public float y1;
    public float bridgeHeight;
    public int markerSplineController;
    public float bridgeLength;
    public float deformationOffset;
    public float markerIndent;
    public float markerSurrounding;
    public Vector3 scale;
    public float indentExt;
    public int category;
    public Texture2D densityMap;
    public float densitySize;
    public float densitySize2;
    public float densityStrength;
    public float densityStrength2;
    public float terrainNormal;
    public float terrainNormal2;
    public List`1<ERChildsSO> childObjects;
    public bool autoGenerate;
    public float heightThreshold;
    public float autogenerateStartOffset;
    public float autogenerateEndOffset;
    public bool snapIndents;
    public float snapIndentWidth;
    public bool cutHoles;
    public float innerStartOffset;
    public float innerEndOffset;
    public bool ignoredForRetainingWalls;
    public float heightMaxThreshold;
    public float heightMaxStartThreshold;
    public float heightMaxEndThreshold;
    public float xThresholdDistance;
    public float angleThreshold;
    public int connectionRatio;
    public bool retainingWall;
    public int surroundingControl;
    public int indentControl;
    public List`1<Vector2> nodeListMirrored;
    public List`1<float> uvsMirrored;
    public List`1<float> snapWeightListMirrored;
    public List`1<Color> colorListMirrored;
    public bool hasVertexColors;
    public float deformationOffsetForward;
    public float deformationOffsetSideways;
    public int connectionObjectRotation;
    public bool subMesh;
    public bool acceptBarriers;
    public bool activeOnBridges;
    public bool dualSided;
    public int mirrorType;
    public bool snapVertexColors;
    public float minSnapRange;
    public float maxSnapRange;
    public bool clampUV4;
    public float geoStartOffset;
    public float geoEndOffset;
    public float startOverlapOffset;
    public float endOverlapOffset;
    public int lodLevels;
    public List`1<bool> hardEdge;
    public float hardEdgePadding;
    public bool startEndCaps;
    public List`1<Vector2> endCapUVs;
    public List`1<Vector2> startCapUVs;
    public List`1<int> startCapTris;
    public List`1<int> startCapTrisMirrored;
    public Vector2 startCapUVOffset;
    public Vector2 endCapUVOffset;
    public float startCapUVScale;
    public float endCapUVScale;
    public float startCapUVRotation;
    public float endCapUVRotation;
    public bool namedChilds;
    public bool startSection;
    public bool endSection;
    public bool stepDown;
    public bool stepUp;
    public float stepDistance;
    public float startDirZOffset;
    public float endDirZOffset;
    public bool buildOtherSideObject1;
    public double defaultOtherSoId1;
    public bool buildOtherSideObject2;
    public double defaultOtherSoId2;
    public List`1<double> buildOtherSideObjects;
    public bool averageDistance;
    public bool randomUVx;
    public bool isUsedAsChild;
    public void SetSideObject(int count, int scategory);
    public void UpdateTimeStamp();
    public void OOCCDCDOQC();
    public void OQOQOQOODC();
    public void SetMaxVertices();
    public static bool CheckSOChildActive(List`1<ERSOSection> sections, SideObject so);
    public void OOOCDOQOOC(bool updateTimeStamp);
    public void OQDODCOODC();
    public void OQDDDDOOQD(Vector3 m_testMeshPos, bool updateTimeStamp);
    private void OQOODQQQQC(List`1<Vector3> vecs, float startDistance, List`1<Vector3> vecs1, float endDistance, List`1& startArray, List`1& endArray, int section);
    private float OQQDDOCDDQ(List`1<GameObject> goObjects, bool rotate180);
    private bool HasMissingData(ERMesh meshData, ERMesh meshData2, int ignore);
    public void OODOOOQQCO(SideObject so);
    public void OCDOCDQQQO(SideObjectLog so);
    public void Clear();
}
public class EasyRoads3Dv3.SideObjectLog : object {
    public string version;
    public string name;
    public double id;
    public double timestamp;
    public int objectType;
    public string gameobjectGUID;
    public string textureGUID;
    public float m_distance;
    public float uvx;
    public float uvy;
    public int position;
    public float splinePosition;
    public int selectedRotation;
    public float randomYAxisMinRotation;
    public float randomYAxisMaxRotation;
    public List`1<Vector2> nodeList;
    public List`1<float> uvs;
    public List`1<float> uvDistances;
    public bool clampUVs;
    public bool clampUVY;
    public float clampUVYValue;
    public bool terrainUVs;
    public bool reverseUVs;
    public float totalDistance;
    public List`1<bool> snapList;
    public List`1<float> snapWeightList;
    public List`1<Color> colorList;
    public string gameobjectStartGUID;
    public string gameobjectEndGUID;
    public int align;
    public int alignPoint;
    public bool weld;
    public bool combine;
    public bool combineInstantiated;
    public bool markerActive;
    public int uvType;
    public float uv;
    public bool randomObjects;
    public float forwardStartOffset;
    public float sidewaysOffset;
    public float density;
    public string goPath;
    public string startPath;
    public string endPath;
    public string texturePath;
    public int terrainTree;
    public float minScale;
    public float maxScale;
    public bool childOrderActive;
    public int childOrder;
    public bool meshBoundsAlignment;
    public float xPosition;
    public float xPosition2;
    public int relativeTo;
    public float yPosition;
    public float yRotation;
    public float oldSidwaysDistance;
    public int sidewaysDistanceUpdate;
    public float uvYRound;
    public bool adjustUV;
    public bool collider;
    public bool boxcollider;
    public bool tangents;
    public GameObject sourceObject;
    public bool flipMesh;
    public GameObject startObject;
    public GameObject endObject;
    public GameObject connectionObject;
    public Material material;
    public List`1<ERMesh> meshObjects;
    public Vector2 boxSize;
    public Vector2 boxOffset;
    public bool includeStartSegment;
    public float startSegmentOffset;
    public bool includeStartEdgeTris;
    public bool includeEndSegment;
    public float endSegmentOffset;
    public bool includeEndEdgeTris;
    public bool adjustToRoadWidth;
    public float xOffset;
    public float startOffset;
    public float endOffset;
    public float defaultStartOffset;
    public float defaultEndOffset;
    public float totalZDistance;
    public float middleZDistance;
    public float startZDistance;
    public float endZDistance;
    public float minStartZ;
    public float maxStartZ;
    public float minMiddleZ;
    public float maxMiddleZ;
    public float minEndZ;
    public float maxEndZ;
    public bool smoothStart;
    public bool smoothMiddle;
    public bool smoothEnd;
    public GameObject targetObject;
    public bool bridgeObject;
    public bool tunnelObject;
    public bool snapToTerrain;
    public int layer;
    public bool deformationObject;
    public bool isStatic;
    public bool castShadows;
    public bool scaleToRoad;
    public bool splitInBatches;
    public Vector3 randomRotation;
    public float randomMinRotation;
    public float randomMaxRotation;
    public float minRandomRotationDistance;
    public float maxRandomRotationDistance;
    public float randomXPosition;
    public float randomMinXPosition;
    public float randomMaxXPosition;
    public float minRandomXPositionDistance;
    public float maxRandomXPositionDistance;
    public Vector3 boxColliderScale;
    public float randomYPosition;
    public float randomMinYPosition;
    public float randomMaxYPosition;
    public float minRandomYPositionDistance;
    public float maxRandomYPositionDistance;
    public float bridgeHeight;
    public int markerSplineController;
    public float bridgeLength;
    public float deformationOffset;
    public float markerIndent;
    public float markerSurrounding;
    public bool indentController;
    public bool excludeTerrainSplats;
    public Vector3 scale;
    public float indentExt;
    public int category;
    public Texture2D densityMap;
    public float densitySize;
    public float densitySize2;
    public float densityStrength;
    public float densityStrength2;
    public float terrainNormal;
    public float terrainNormal2;
    public List`1<ERChildsSO> childObjects;
    public bool autoGenerate;
    public float heightThreshold;
    public float autogenerateStartOffset;
    public float autogenerateEndOffset;
    public bool snapIndents;
    public float snapIndentWidth;
    public bool cutHoles;
    public float innerStartOffset;
    public float innerEndOffset;
    public bool ignoredForRetainingWalls;
    public float heightMaxThreshold;
    public float heightMaxStartThreshold;
    public float heightMaxEndThreshold;
    public float xThresholdDistance;
    public float angleThreshold;
    public int connectionRatio;
    public bool retainingWall;
    public int surroundingControl;
    public int indentControl;
    public List`1<Vector2> nodeListMirrored;
    public List`1<float> uvsMirrored;
    public List`1<float> snapWeightListMirrored;
    public List`1<Color> colorListMirrored;
    public bool hasVertexColors;
    public float deformationOffsetForward;
    public float deformationOffsetSideways;
    public int connectionObjectRotation;
    public bool subMesh;
    public bool acceptBarriers;
    public bool activeOnBridges;
    public bool dualSided;
    public int mirrorType;
    public bool snapVertexColors;
    public float minSnapRange;
    public float maxSnapRange;
    public bool clampUV4;
    public float geoStartOffset;
    public float geoEndOffset;
    public float startOverlapOffset;
    public float endOverlapOffset;
    public int lodLevels;
    public List`1<bool> hardEdge;
    public float hardEdgePadding;
    public bool startEndCaps;
    public List`1<Vector2> endCapUVs;
    public List`1<Vector2> startCapUVs;
    public List`1<int> startCapTris;
    public List`1<int> startCapTrisMirrored;
    public Vector2 startCapUVOffset;
    public Vector2 endCapUVOffset;
    public float startCapUVScale;
    public float endCapUVScale;
    public float startCapUVRotation;
    public float endCapUVRotation;
    public bool namedChilds;
    public bool startSection;
    public bool endSection;
    public bool stepDown;
    public bool stepUp;
    public float stepDistance;
    public float startDirZOffset;
    public float endDirZOffset;
    public bool buildOtherSideObject1;
    public double defaultOtherSoId1;
    public bool buildOtherSideObject2;
    public double defaultOtherSoId2;
    public List`1<double> buildOtherSideObjects;
    public bool averageDistance;
    public bool randomUVx;
    public bool isUsedAsChild;
    public void OODOOOQQCO(SideObject so);
}
public class EasyRoads3Dv3.SideObjectParams : object {
    public Boolean[] soActive;
    public Single[] soDistanceSideWays;
    public Boolean[] soSplineActive;
}
public class EasyRoads3Dv3.SidewalkPresetClass : object {
    public string presetName;
    public double id;
    public double timestamp;
    public float sidewalkWidth1;
    public float sidewalkWidth2;
    public float curbHeight;
    public float curbDepth;
    public bool beveledCurb;
    public float beveledHeight;
    public float beveledDepth;
    public bool outerCurb;
    public bool roadSideCurbUVControl;
    public bool outerSideCurbUVControl;
    public Material sidewalkMaterial;
    public List`1<Vector2> shape;
    public List`1<float> sidewalkUVs;
    public List`1<float> curbUVs;
    public bool lockUVs;
    public SidewalkPresetClass(QDOQDSQOOQDDD corner, string name);
}
public class EasyRoads3Dv3.TerrainsV3 : object {
    public Terrain terrain;
    public string id;
}
public class EasyRoads3Dv3.tPoint : object {
    public int x;
    public int z;
    public bool done;
    public float dist;
    public int v;
}
public class EasyRoads3Dv3.ZIndexArray : object {
    public List`1<int> index;
}
[AddComponentMenu("")]
public class ERSurfaceScript : MonoBehaviour {
    private void Start();
}
