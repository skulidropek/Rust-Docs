internal AssemblyRef : object {
internal string SystemConfiguration
internal string System
public string EcmaPublicKey
public string FrameworkPublicKeyFull
public string FrameworkPublicKeyFull2
public string MicrosoftPublicKey
public string MicrosoftJScript
public string MicrosoftVSDesigner
public string SystemData
public string SystemDesign
public string SystemDrawing
public string SystemWeb
public string SystemWebExtensions
public string SystemWindowsForms
}
internal Consts : object {
public string MonoVersion
public string MonoCompany
public string MonoProduct
public string MonoCopyright
public int MonoCorlibVersion
public string FxVersion
public string FxFileVersion
public string EnvironmentVersion
public string VsVersion
public string VsFileVersion
private string PublicKeyToken
public string AssemblyI18N
public string AssemblyMicrosoft_JScript
public string AssemblyMicrosoft_VisualStudio
public string AssemblyMicrosoft_VisualStudio_Web
public string AssemblyMicrosoft_VSDesigner
public string AssemblyMono_Http
public string AssemblyMono_Posix
public string AssemblyMono_Security
public string AssemblyMono_Messaging_RabbitMQ
public string AssemblyCorlib
public string AssemblySystem
public string AssemblySystem_Data
public string AssemblySystem_Design
public string AssemblySystem_DirectoryServices
public string AssemblySystem_Drawing
public string AssemblySystem_Drawing_Design
public string AssemblySystem_Messaging
public string AssemblySystem_Security
public string AssemblySystem_ServiceProcess
public string AssemblySystem_Web
public string AssemblySystem_Windows_Forms
public string AssemblySystem_2_0
public string AssemblySystemCore_3_5
public string AssemblySystem_Core
public string WindowsBase_3_0
public string AssemblyWindowsBase
public string AssemblyPresentationCore_3_5
public string AssemblyPresentationCore_4_0
public string AssemblyPresentationFramework_3_5
public string AssemblySystemServiceModel_3_0
}
internal SR : object {
internal string GetString(string name, Object[] args)
internal string GetString(CultureInfo culture, string name, Object[] args)
internal string GetString(string name)
internal string GetString(CultureInfo culture, string name)
internal string Format(string resourceFormat, Object[] args)
internal string Format(string resourceFormat, object p1)
internal string Format(string resourceFormat, object p1, object p2)
internal string Format(string resourceFormat, object p1, object p2, object p3)
}
internal System.Runtime.ActionItem : object {
private bool isScheduled
private bool lowPriority
public bool LowPriority
public bool get_LowPriority()
protected void set_LowPriority(bool value)
public void Schedule(Action`1<object> callback, object state)
public void Schedule(Action`1<object> callback, object state, bool lowPriority)
protected void Invoke()
protected void Schedule()
protected void ScheduleWithoutContext()
private void ScheduleCallback(Action`1<object> callback, object state, bool lowPriority)
private void ScheduleCallback(Action`1<object> callback)
}
internal System.Runtime.AssertHelper : object {
internal void FireAssert(string message)
}
internal System.Runtime.AsyncCompletionResult : Enum {
public int value__
public AsyncCompletionResult Queued
public AsyncCompletionResult Completed
}
internal System.Runtime.AsyncEventArgs : object {
private OperationState state
private object asyncState
private AsyncEventArgsCallback callback
private Exception exception
public Exception Exception
public object AsyncState
private OperationState State
public Exception get_Exception()
public object get_AsyncState()
private void set_State(OperationState value)
public void Complete(bool completedSynchronously)
public void Complete(bool completedSynchronously, Exception exception)
protected void SetAsyncState(AsyncEventArgsCallback callback, object state)
}
internal System.Runtime.AsyncEventArgs`1 : AsyncEventArgs {
private TArgument <Arguments>k__BackingField
public TArgument Arguments
public TArgument get_Arguments()
private void set_Arguments(TArgument value)
public void Set(AsyncEventArgsCallback callback, TArgument arguments, object state)
}
internal System.Runtime.AsyncEventArgs`2 : AsyncEventArgs`1<TArgument> {
private TResult <Result>k__BackingField
public TResult Result
public TResult get_Result()
public void set_Result(TResult value)
}
internal System.Runtime.AsyncEventArgsCallback : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(IAsyncEventArgs eventArgs)
public IAsyncResult BeginInvoke(IAsyncEventArgs eventArgs, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
internal System.Runtime.AsyncResult : object {
private AsyncCallback asyncCompletionWrapperCallback
private AsyncCallback callback
private bool completedSynchronously
private bool endCalled
private Exception exception
private bool isCompleted
private AsyncCompletion nextAsyncCompletion
private object state
private Action beforePrepareAsyncCompletionAction
private Func`2<IAsyncResult, bool> checkSyncValidationFunc
private ManualResetEvent manualResetEvent
private object thisLock
private Action`2<AsyncResult, Exception> <OnCompleting>k__BackingField
private Action`2<AsyncCallback, IAsyncResult> <VirtualCallback>k__BackingField
public object AsyncState
public WaitHandle AsyncWaitHandle
public bool CompletedSynchronously
public bool HasCallback
public bool IsCompleted
protected Action`2<AsyncResult, Exception> OnCompleting
private object ThisLock
protected Action`2<AsyncCallback, IAsyncResult> VirtualCallback
protected void .ctor(AsyncCallback callback, object state)
public object get_AsyncState()
public WaitHandle get_AsyncWaitHandle()
public bool get_CompletedSynchronously()
public bool get_HasCallback()
public bool get_IsCompleted()
protected Action`2<AsyncResult, Exception> get_OnCompleting()
protected void set_OnCompleting(Action`2<AsyncResult, Exception> value)
private object get_ThisLock()
protected Action`2<AsyncCallback, IAsyncResult> get_VirtualCallback()
protected void set_VirtualCallback(Action`2<AsyncCallback, IAsyncResult> value)
protected void Complete(bool completedSynchronously)
protected void Complete(bool completedSynchronously, Exception exception)
private void AsyncCompletionWrapperCallback(IAsyncResult result)
protected bool OnContinueAsyncCompletion(IAsyncResult result)
protected void SetBeforePrepareAsyncCompletionAction(Action beforePrepareAsyncCompletionAction)
protected void SetCheckSyncValidationFunc(Func`2<IAsyncResult, bool> checkSyncValidationFunc)
protected AsyncCallback PrepareAsyncCompletion(AsyncCompletion callback)
protected bool CheckSyncContinue(IAsyncResult result)
protected bool SyncContinue(IAsyncResult result)
private bool TryContinueHelper(IAsyncResult result, AsyncCompletion& callback)
private AsyncCompletion GetNextCompletion()
protected void ThrowInvalidAsyncResult(IAsyncResult result)
protected void ThrowInvalidAsyncResult(string debugText)
protected TAsyncResult End(IAsyncResult result)
}
internal System.Runtime.AsyncWaitHandle : object {
private Action`1<object> timerCompleteCallback
private List`1<AsyncWaiter> asyncWaiters
private bool isSignaled
private EventResetMode resetMode
private object syncObject
private int syncWaiterCount
public void .ctor(EventResetMode resetMode)
public bool WaitAsync(Action`2<object, TimeoutException> callback, object state, TimeSpan timeout)
private void OnTimerComplete(object state)
public bool Wait(TimeSpan timeout)
public void Set()
public void Reset()
}
internal System.Runtime.BackoffTimeoutHelper : object {
private int maxSkewMilliseconds
private long maxDriftTicks
private TimeSpan defaultInitialWaitTime
private TimeSpan defaultMaxWaitTime
private DateTime deadline
private TimeSpan maxWaitTime
private TimeSpan waitTime
private IOThreadTimer backoffTimer
private Action`1<object> backoffCallback
private object backoffState
private Random random
private TimeSpan originalTimeout
public TimeSpan OriginalTimeout
internal void .ctor(TimeSpan timeout)
internal void .ctor(TimeSpan timeout, TimeSpan maxWaitTime)
internal void .ctor(TimeSpan timeout, TimeSpan maxWaitTime, TimeSpan initialWaitTime)
public TimeSpan get_OriginalTimeout()
private void Reset(TimeSpan timeout, TimeSpan initialWaitTime)
public bool IsExpired()
public void WaitAndBackoff(Action`1<object> callback, object state)
public void WaitAndBackoff()
private TimeSpan WaitTimeWithDrift()
private void Backoff()
}
internal System.Runtime.BufferedOutputStream : Stream {
private InternalBufferManager bufferManager
private Byte[][] chunks
private int chunkCount
private Byte[] currentChunk
private int currentChunkSize
private int maxSize
private int maxSizeQuota
private int totalSize
private bool callerReturnsBuffer
private bool bufferReturned
private bool initialized
public bool CanRead
public bool CanSeek
public bool CanWrite
public long Length
public long Position
public void .ctor(int initialSize, int maxSize, InternalBufferManager bufferManager)
public void .ctor(int maxSize)
public bool get_CanRead()
public bool get_CanSeek()
public bool get_CanWrite()
public long get_Length()
public long get_Position()
public void set_Position(long value)
public void Reinitialize(int initialSize, int maxSizeQuota, InternalBufferManager bufferManager)
public void Reinitialize(int initialSize, int maxSizeQuota, int effectiveMaxSize, InternalBufferManager bufferManager)
private void AllocNextChunk(int minimumChunkSize)
public IAsyncResult BeginRead(Byte[] buffer, int offset, int size, AsyncCallback callback, object state)
public int EndRead(IAsyncResult result)
public IAsyncResult BeginWrite(Byte[] buffer, int offset, int size, AsyncCallback callback, object state)
public void EndWrite(IAsyncResult result)
public void Clear()
public void Close()
public void Flush()
public int Read(Byte[] buffer, int offset, int size)
public int ReadByte()
public long Seek(long offset, SeekOrigin origin)
public void SetLength(long value)
public MemoryStream ToMemoryStream()
public Byte[] ToArray(Int32& bufferSize)
public void Skip(int size)
public void Write(Byte[] buffer, int offset, int size)
protected Exception CreateQuotaExceededException(int maxSizeQuota)
private void WriteCore(Byte[] buffer, int offset, int size)
public void WriteByte(byte value)
}
internal System.Runtime.CallbackException : FatalException {
public void .ctor(string message, Exception innerException)
protected void .ctor(SerializationInfo info, StreamingContext context)
}
internal System.Runtime.Collections.HopperCache : object {
private int hopperSize
private bool weak
private Hashtable outstandingHopper
private Hashtable strongHopper
private Hashtable limitedHopper
private int promoting
private LastHolder mruEntry
public void .ctor(int hopperSize, bool weak)
public void Add(object key, object value)
public object GetValue(object syncObject, object key)
}
internal System.Runtime.Collections.NullableKeyDictionary`2 : object {
private bool isNullKeyPresent
private TValue nullKeyValue
private IDictionary`2<TKey, TValue> innerDictionary
public int Count
public bool IsReadOnly
public ICollection`1<TKey> Keys
public ICollection`1<TValue> Values
public TValue Item
public int get_Count()
public bool get_IsReadOnly()
public ICollection`1<TKey> get_Keys()
public ICollection`1<TValue> get_Values()
public TValue get_Item(TKey key)
public void set_Item(TKey key, TValue value)
public void Add(TKey key, TValue value)
public bool ContainsKey(TKey key)
public bool Remove(TKey key)
public bool TryGetValue(TKey key, TValue& value)
public void Add(KeyValuePair`2<TKey, TValue> item)
public void Clear()
public bool Contains(KeyValuePair`2<TKey, TValue> item)
public void CopyTo(KeyValuePair`2[] array, int arrayIndex)
public bool Remove(KeyValuePair`2<TKey, TValue> item)
public IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
}
internal System.Runtime.Collections.ObjectCache`2 : object {
private int timerThreshold
private ObjectCacheSettings settings
private Dictionary`2<TKey, Item<TKey, TValue>> cacheItems
private bool idleTimeoutEnabled
private bool leaseTimeoutEnabled
private IOThreadTimer idleTimer
private Action`1<object> onIdle
private bool disposed
private Action`1<TValue> <DisposeItemCallback>k__BackingField
private object ThisLock
public Action`1<TValue> DisposeItemCallback
public int Count
public void .ctor(ObjectCacheSettings settings)
public void .ctor(ObjectCacheSettings settings, IEqualityComparer`1<TKey> comparer)
private object get_ThisLock()
public Action`1<TValue> get_DisposeItemCallback()
public void set_DisposeItemCallback(Action`1<TValue> value)
public int get_Count()
public ObjectCacheItem`1<TValue> Add(TKey key, TValue value)
public ObjectCacheItem`1<TValue> Take(TKey key)
public ObjectCacheItem`1<TValue> Take(TKey key, Func`1<TValue> initializerDelegate)
private Item<TKey, TValue> InternalAdd(TKey key, TValue value)
private bool Return(TKey key, Item<TKey, TValue> cacheItem)
private void StartTimerIfNecessary()
private void OnIdle(object state)
private void Add(List`1& list, T item)
private bool ShouldPurgeItem(Item<TKey, TValue> cacheItem, DateTime now)
private void GatherExpiredItems(List`1& expiredItems, bool calledFromTimer)
private void PurgeCache(bool calledFromTimer)
public void Dispose()
}
internal System.Runtime.Collections.ObjectCacheItem`1 : object {
public T Value
public T get_Value()
public bool TryAddReference()
public void ReleaseReference()
}
internal System.Runtime.Collections.ObjectCacheSettings : object {
private int cacheLimit
private TimeSpan idleTimeout
private TimeSpan leaseTimeout
private int purgeFrequency
private int DefaultCacheLimit
private int DefaultPurgeFrequency
private TimeSpan DefaultIdleTimeout
private TimeSpan DefaultLeaseTimeout
public int CacheLimit
public TimeSpan IdleTimeout
public TimeSpan LeaseTimeout
public int PurgeFrequency
private void .ctor(ObjectCacheSettings other)
internal ObjectCacheSettings Clone()
public int get_CacheLimit()
public void set_CacheLimit(int value)
public TimeSpan get_IdleTimeout()
public void set_IdleTimeout(TimeSpan value)
public TimeSpan get_LeaseTimeout()
public void set_LeaseTimeout(TimeSpan value)
public int get_PurgeFrequency()
public void set_PurgeFrequency(int value)
}
internal System.Runtime.Collections.OrderedDictionary`2 : object {
private OrderedDictionary privateDictionary
public int Count
public bool IsReadOnly
public TValue Item
public ICollection`1<TKey> Keys
public ICollection`1<TValue> Values
private bool System.Collections.IDictionary.IsFixedSize
private bool System.Collections.IDictionary.IsReadOnly
private ICollection System.Collections.IDictionary.Keys
private ICollection System.Collections.IDictionary.Values
private object System.Collections.IDictionary.Item
private int System.Collections.ICollection.Count
private bool System.Collections.ICollection.IsSynchronized
private object System.Collections.ICollection.SyncRoot
public void .ctor(IDictionary`2<TKey, TValue> dictionary)
public int get_Count()
public bool get_IsReadOnly()
public TValue get_Item(TKey key)
public void set_Item(TKey key, TValue value)
public ICollection`1<TKey> get_Keys()
public ICollection`1<TValue> get_Values()
public void Add(KeyValuePair`2<TKey, TValue> item)
public void Add(TKey key, TValue value)
public void Clear()
public bool Contains(KeyValuePair`2<TKey, TValue> item)
public bool ContainsKey(TKey key)
public void CopyTo(KeyValuePair`2[] array, int arrayIndex)
public IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
public bool Remove(KeyValuePair`2<TKey, TValue> item)
public bool Remove(TKey key)
public bool TryGetValue(TKey key, TValue& value)
private void System.Collections.IDictionary.Add(object key, object value)
private void System.Collections.IDictionary.Clear()
private bool System.Collections.IDictionary.Contains(object key)
private IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator()
private bool System.Collections.IDictionary.get_IsFixedSize()
private bool System.Collections.IDictionary.get_IsReadOnly()
private ICollection System.Collections.IDictionary.get_Keys()
private void System.Collections.IDictionary.Remove(object key)
private ICollection System.Collections.IDictionary.get_Values()
private object System.Collections.IDictionary.get_Item(object key)
private void System.Collections.IDictionary.set_Item(object key, object value)
private void System.Collections.ICollection.CopyTo(Array array, int index)
private int System.Collections.ICollection.get_Count()
private bool System.Collections.ICollection.get_IsSynchronized()
private object System.Collections.ICollection.get_SyncRoot()
}
internal System.Runtime.Collections.ValidatingCollection`1 : Collection`1<T> {
private Action`1<T> <OnAddValidationCallback>k__BackingField
private Action <OnMutateValidationCallback>k__BackingField
public Action`1<T> OnAddValidationCallback
public Action OnMutateValidationCallback
public Action`1<T> get_OnAddValidationCallback()
public void set_OnAddValidationCallback(Action`1<T> value)
public Action get_OnMutateValidationCallback()
public void set_OnMutateValidationCallback(Action value)
private void OnAdd(T item)
private void OnMutate()
protected void ClearItems()
protected void InsertItem(int index, T item)
protected void RemoveItem(int index)
protected void SetItem(int index, T item)
}
internal System.Runtime.CompletedAsyncResult : AsyncResult {
public void .ctor(AsyncCallback callback, object state)
public void End(IAsyncResult result)
}
internal System.Runtime.CompletedAsyncResult`1 : AsyncResult {
private T data
public void .ctor(T data, AsyncCallback callback, object state)
public T End(IAsyncResult result)
}
internal System.Runtime.CompletedAsyncResult`2 : AsyncResult {
private TResult resultData
private TParameter parameter
public void .ctor(TResult resultData, TParameter parameter, AsyncCallback callback, object state)
public TResult End(IAsyncResult result, TParameter& parameter)
}
internal System.Runtime.ComputerNameFormat : Enum {
public int value__
public ComputerNameFormat NetBIOS
public ComputerNameFormat DnsHostName
public ComputerNameFormat Dns
public ComputerNameFormat DnsFullyQualified
public ComputerNameFormat PhysicalNetBIOS
public ComputerNameFormat PhysicalDnsHostName
public ComputerNameFormat PhysicalDnsDomain
public ComputerNameFormat PhysicalDnsFullyQualified
}
internal System.Runtime.Diagnostics.ActivityControl : Enum {
public UInt32 value__
public ActivityControl EVENT_ACTIVITY_CTRL_GET_ID
public ActivityControl EVENT_ACTIVITY_CTRL_SET_ID
public ActivityControl EVENT_ACTIVITY_CTRL_CREATE_ID
public ActivityControl EVENT_ACTIVITY_CTRL_GET_SET_ID
public ActivityControl EVENT_ACTIVITY_CTRL_CREATE_SET_ID
}
internal System.Runtime.Diagnostics.DiagnosticsEventProvider : object {
private EtwEnableCallback etwCallback
private long traceRegistrationHandle
private byte currentTraceLevel
private long anyKeywordMask
private long allKeywordMask
private bool isProviderEnabled
private Guid providerId
private int isDisposed
private WriteEventErrorCode errorCode
private int basicTypeAllocationBufferSize
private int etwMaxNumberArguments
private int etwAPIMaxStringCount
private int maxEventDataDescriptors
private int traceEventMaximumSize
private int traceEventMaximumStringSize
private int WindowsVistaMajorNumber
protected void .ctor(Guid providerGuid)
private void EtwRegister()
public void Dispose()
protected void Dispose(bool disposing)
public void Close()
protected void Finalize()
private void Deregister()
private void EtwEnableCallBack(Guid& sourceId, int isEnabled, byte setLevel, long anyKeyword, long allKeyword, Void* filterData, Void* callbackContext)
protected void OnControllerCommand()
public bool IsEnabled()
public bool IsEnabled(byte level, long keywords)
public bool IsEventEnabled(EventDescriptor& eventDescriptor)
public WriteEventErrorCode GetLastWriteEventError()
private void SetLastError(int error)
private string EncodeObject(Object& data, EventData* dataDescriptor, Byte* dataBuffer)
public bool WriteMessageEvent(EventTraceActivity eventTraceActivity, string eventMessage, byte eventLevel, long eventKeywords)
public bool WriteMessageEvent(EventTraceActivity eventTraceActivity, string eventMessage)
public bool WriteEvent(EventDescriptor& eventDescriptor, EventTraceActivity eventTraceActivity, Object[] eventPayload)
public bool WriteEvent(EventDescriptor& eventDescriptor, EventTraceActivity eventTraceActivity, string data)
protected internal bool WriteEvent(EventDescriptor& eventDescriptor, EventTraceActivity eventTraceActivity, int dataCount, IntPtr data)
public bool WriteTransferEvent(EventDescriptor& eventDescriptor, EventTraceActivity eventTraceActivity, Guid relatedActivityId, Object[] eventPayload)
protected bool WriteTransferEvent(EventDescriptor& eventDescriptor, EventTraceActivity eventTraceActivity, Guid relatedActivityId, int dataCount, IntPtr data)
public void SetActivityId(Guid& id)
}
internal System.Runtime.Diagnostics.DiagnosticTraceBase : object {
protected string DefaultTraceListenerName
protected string TraceRecordVersion
protected string AppDomainFriendlyName
private ushort TracingEventLogCategory
private object thisLock
private bool tracingEnabled
private bool calledShutdown
private bool haveListeners
private SourceLevels level
protected string TraceSourceName
private TraceSource traceSource
private string eventSourceName
private DateTime <LastFailure>k__BackingField
protected DateTime LastFailure
public TraceSource TraceSource
public bool HaveListeners
public SourceLevels Level
protected string EventSourceName
public bool TracingEnabled
protected string ProcessName
protected int ProcessId
protected bool CalledShutdown
public Guid ActivityId
public void .ctor(string traceSourceName)
protected DateTime get_LastFailure()
protected void set_LastFailure(DateTime value)
private void UnsafeRemoveDefaultTraceListener(TraceSource traceSource)
public TraceSource get_TraceSource()
public void set_TraceSource(TraceSource value)
protected void SetTraceSource(TraceSource traceSource)
public bool get_HaveListeners()
private SourceLevels FixLevel(SourceLevels level)
protected void OnSetLevel(SourceLevels level)
private void SetLevel(SourceLevels level)
private void SetLevelThreadSafe(SourceLevels level)
public SourceLevels get_Level()
public void set_Level(SourceLevels value)
protected string get_EventSourceName()
protected void set_EventSourceName(string value)
public bool get_TracingEnabled()
protected string get_ProcessName()
protected int get_ProcessId()
public bool ShouldTrace(TraceEventLevel level)
public bool ShouldTrace(TraceEventType type)
public bool ShouldTraceToTraceSource(TraceEventLevel level)
public string XmlEncode(string text)
protected void AddDomainEventHandlersForCleanup()
private void ExitOrUnloadEventHandler(object sender, EventArgs e)
protected void OnUnhandledException(Exception exception)
protected void UnhandledExceptionHandler(object sender, UnhandledExceptionEventArgs args)
protected string CreateSourceString(object source)
internal string CreateDefaultSourceString(object source)
protected void AddExceptionToTraceString(XmlWriter xml, Exception exception)
protected string StackTraceString(Exception exception)
protected void LogTraceFailure(string traceString, Exception exception)
protected void OnShutdownTracing()
private void ShutdownTracing()
protected bool get_CalledShutdown()
public Guid get_ActivityId()
public void set_ActivityId(Guid value)
protected string LookupSeverity(TraceEventType type)
public bool IsEnabled()
public void TraceEventLogEvent(TraceEventType type, TraceRecord traceRecord)
}
internal System.Runtime.Diagnostics.DiagnosticTraceSource : TraceSource {
private string PropagateActivityValue
internal bool PropagateActivity
internal void .ctor(string name)
protected String[] GetSupportedAttributes()
internal bool get_PropagateActivity()
internal void set_PropagateActivity(bool value)
}
internal System.Runtime.Diagnostics.DictionaryTraceRecord : TraceRecord {
private IDictionary dictionary
internal string EventId
internal void .ctor(IDictionary dictionary)
internal string get_EventId()
internal void WriteTo(XmlWriter xml)
}
internal System.Runtime.Diagnostics.EtwDiagnosticTrace : DiagnosticTraceBase {
private int WindowsVistaMajorNumber
private string EventSourceVersion
private ushort TracingEventLogCategory
private int MaxExceptionStringLength
private int MaxExceptionDepth
private string DiagnosticTraceSource
private int XmlBracketsLength
private int XmlBracketsLengthForNullValue
public Guid ImmutableDefaultEtwProviderId
private Guid defaultEtwProviderId
private Hashtable etwProviderCache
private bool isVistaOrGreater
private Func`1<string> traceAnnotation
private EtwProvider etwProvider
private Guid etwProviderId
private EventDescriptor transferEventDescriptor
public Guid DefaultEtwProviderId
public EtwProvider EtwProvider
public bool IsEtwProviderEnabled
public Action RefreshState
public bool IsEnd2EndActivityTracingEnabled
private bool EtwTracingEnabled
public void .ctor(string traceSourceName, Guid etwProviderId)
public Guid get_DefaultEtwProviderId()
public void set_DefaultEtwProviderId(Guid value)
public EtwProvider get_EtwProvider()
public bool get_IsEtwProviderEnabled()
public Action get_RefreshState()
public void set_RefreshState(Action value)
public bool get_IsEnd2EndActivityTracingEnabled()
private bool get_EtwTracingEnabled()
public void SetEnd2EndActivityTracingEnabled(bool isEnd2EndTracingEnabled)
public void SetAnnotation(Func`1<string> annotation)
public bool ShouldTrace(TraceEventLevel level)
public bool ShouldTraceToEtw(TraceEventLevel level)
public void Event(int eventId, TraceEventLevel traceEventLevel, TraceChannel channel, string description)
public void Event(EventDescriptor& eventDescriptor, string description)
public void SetAndTraceTransfer(Guid newId, bool emitTransfer)
public void TraceTransfer(Guid newId)
public void WriteTraceSource(EventDescriptor& eventDescriptor, string description, TracePayload payload)
private string BuildTrace(EventDescriptor& eventDescriptor, string description, TracePayload payload, string msdnTraceCode)
private void GenerateLegacyTraceCode(EventDescriptor& eventDescriptor, String& msdnTraceCode, Int32& legacyEventId)
private string GenerateMsdnTraceCode(string traceSource, string traceCodeString)
private string LookupChannel(TraceChannel traceChannel)
public TracePayload GetSerializedPayload(object source, TraceRecord traceRecord, Exception exception)
public TracePayload GetSerializedPayload(object source, TraceRecord traceRecord, Exception exception, bool getServiceReference)
public bool IsEtwEventEnabled(EventDescriptor& eventDescriptor)
public bool IsEtwEventEnabled(EventDescriptor& eventDescriptor, bool fullCheck)
private void CreateTraceSource()
private void CreateEtwProvider(Guid etwProviderId)
private EventDescriptor GetEventDescriptor(int eventId, TraceChannel channel, TraceEventLevel traceEventLevel)
protected void OnShutdownTracing()
private void ShutdownTraceSource()
private void ShutdownEtwProvider()
public bool IsEnabled()
public void TraceEventLogEvent(TraceEventType type, TraceRecord traceRecord)
protected void OnUnhandledException(Exception exception)
internal string ExceptionToTraceString(Exception exception, int maxTraceStringLength)
private void WriteExceptionToTraceString(XmlTextWriter xml, Exception exception, int remainingLength, int remainingAllowedRecursionDepth)
private string GetInnerException(Exception exception, int remainingLength, int remainingAllowedRecursionDepth)
private string GetExceptionData(Exception exception)
private bool WriteStartElement(XmlTextWriter xml, string localName, Int32& remainingLength)
private bool WriteXmlElementString(XmlTextWriter xml, string localName, string value, Int32& remainingLength)
}
internal System.Runtime.Diagnostics.EtwProvider : DiagnosticsEventProvider {
private Action invokeControllerCallback
private bool end2EndActivityTracingEnabled
internal Action ControllerCallBack
internal bool IsEnd2EndActivityTracingEnabled
internal void .ctor(Guid id)
internal Action get_ControllerCallBack()
internal void set_ControllerCallBack(Action value)
internal bool get_IsEnd2EndActivityTracingEnabled()
protected void OnControllerCommand()
internal void SetEnd2EndActivityTracingEnabled(bool isEnd2EndActivityTracingEnabled)
internal bool WriteEvent(EventDescriptor& eventDescriptor, EventTraceActivity eventTraceActivity, Guid value1, string value2, string value3)
internal bool WriteTransferEvent(EventDescriptor& eventDescriptor, EventTraceActivity eventTraceActivity, Guid relatedActivityId, string value1, string value2)
internal bool WriteEvent(EventDescriptor& eventDescriptor, EventTraceActivity eventTraceActivity, string value1, string value2)
internal bool WriteEvent(EventDescriptor& eventDescriptor, EventTraceActivity eventTraceActivity, string value1, string value2, string value3)
internal bool WriteEvent(EventDescriptor& eventDescriptor, EventTraceActivity eventTraceActivity, string value1, string value2, string value3, string value4)
internal bool WriteEvent(EventDescriptor& eventDescriptor, EventTraceActivity eventTraceActivity, string value1, string value2, string value3, string value4, string value5)
internal bool WriteEvent(EventDescriptor& eventDescriptor, EventTraceActivity eventTraceActivity, string value1, string value2, string value3, string value4, string value5, string value6)
internal bool WriteEvent(EventDescriptor& eventDescriptor, EventTraceActivity eventTraceActivity, string value1, string value2, string value3, string value4, string value5, string value6, string value7)
internal bool WriteEvent(EventDescriptor& eventDescriptor, EventTraceActivity eventTraceActivity, string value1, string value2, string value3, string value4, string value5, string value6, string value7, string value8)
internal bool WriteEvent(EventDescriptor& eventDescriptor, EventTraceActivity eventTraceActivity, string value1, string value2, string value3, string value4, string value5, string value6, string value7, string value8, string value9)
internal bool WriteEvent(EventDescriptor& eventDescriptor, EventTraceActivity eventTraceActivity, string value1, string value2, string value3, string value4, string value5, string value6, string value7, string value8, string value9, string value10)
internal bool WriteEvent(EventDescriptor& eventDescriptor, EventTraceActivity eventTraceActivity, string value1, string value2, string value3, string value4, string value5, string value6, string value7, string value8, string value9, string value10, string value11)
internal bool WriteEvent(EventDescriptor& eventDescriptor, EventTraceActivity eventTraceActivity, string value1, string value2, string value3, string value4, string value5, string value6, string value7, string value8, string value9, string value10, string value11, string value12)
internal bool WriteEvent(EventDescriptor& eventDescriptor, EventTraceActivity eventTraceActivity, string value1, string value2, string value3, string value4, string value5, string value6, string value7, string value8, string value9, string value10, string value11, string value12, string value13)
internal bool WriteEvent(EventDescriptor& eventDescriptor, EventTraceActivity eventTraceActivity, int value1)
internal bool WriteEvent(EventDescriptor& eventDescriptor, EventTraceActivity eventTraceActivity, int value1, int value2)
internal bool WriteEvent(EventDescriptor& eventDescriptor, EventTraceActivity eventTraceActivity, int value1, int value2, int value3)
internal bool WriteEvent(EventDescriptor& eventDescriptor, EventTraceActivity eventTraceActivity, long value1)
internal bool WriteEvent(EventDescriptor& eventDescriptor, EventTraceActivity eventTraceActivity, long value1, long value2)
internal bool WriteEvent(EventDescriptor& eventDescriptor, EventTraceActivity eventTraceActivity, long value1, long value2, long value3)
internal bool WriteEvent(EventDescriptor& eventDescriptor, EventTraceActivity eventTraceActivity, Guid value1, long value2, long value3, string value4, string value5, string value6, string value7, string value8, string value9, string value10, string value11, string value12, string value13, string value14, string value15)
internal bool WriteEvent(EventDescriptor& eventDescriptor, EventTraceActivity eventTraceActivity, Guid value1, long value2, long value3, string value4, string value5, string value6, string value7, string value8, string value9, string value10, string value11, string value12, bool value13, string value14, string value15, string value16, string value17)
internal bool WriteEvent(EventDescriptor& eventDescriptor, EventTraceActivity eventTraceActivity, Guid value1, long value2, long value3, string value4, string value5, string value6, string value7, string value8, string value9)
internal bool WriteEvent(EventDescriptor& eventDescriptor, EventTraceActivity eventTraceActivity, Guid value1, long value2, long value3, string value4, string value5, string value6, string value7, string value8, string value9, string value10, string value11)
internal bool WriteEvent(EventDescriptor& eventDescriptor, EventTraceActivity eventTraceActivity, Guid value1, long value2, long value3, string value4, string value5, string value6, string value7, string value8, string value9, string value10, string value11, string value12, string value13)
internal bool WriteEvent(EventDescriptor& eventDescriptor, EventTraceActivity eventTraceActivity, Guid value1, long value2, long value3, string value4, string value5, string value6, string value7, string value8, string value9, string value10, string value11, string value12, string value13, string value14)
internal bool WriteEvent(EventDescriptor& eventDescriptor, EventTraceActivity eventTraceActivity, Guid value1, long value2, long value3, string value4, Guid value5, string value6, string value7, string value8, string value9, string value10, string value11, string value12, string value13)
internal bool WriteEvent(EventDescriptor& eventDescriptor, EventTraceActivity eventTraceActivity, string value1, long value2, string value3, string value4)
}
internal System.Runtime.Diagnostics.EventDescriptor : ValueType {
private ushort m_id
private byte m_version
private byte m_channel
private byte m_level
private byte m_opcode
private ushort m_task
private long m_keywords
public int EventId
public byte Version
public byte Channel
public byte Level
public byte Opcode
public int Task
public long Keywords
public void .ctor(int id, byte version, byte channel, byte level, byte opcode, int task, long keywords)
public int get_EventId()
public byte get_Version()
public byte get_Channel()
public byte get_Level()
public byte get_Opcode()
public int get_Task()
public long get_Keywords()
public bool Equals(object obj)
public int GetHashCode()
public bool Equals(EventDescriptor other)
public bool op_Equality(EventDescriptor event1, EventDescriptor event2)
public bool op_Inequality(EventDescriptor event1, EventDescriptor event2)
}
internal System.Runtime.Diagnostics.EventFacility : Enum {
public UInt32 value__
public EventFacility Tracing
public EventFacility ServiceModel
public EventFacility TransactionBridge
public EventFacility SMSvcHost
public EventFacility InfoCards
public EventFacility SecurityAudit
}
internal System.Runtime.Diagnostics.EventLogCategory : Enum {
public ushort value__
public EventLogCategory ServiceAuthorization
public EventLogCategory MessageAuthentication
public EventLogCategory ObjectAccess
public EventLogCategory Tracing
public EventLogCategory WebHost
public EventLogCategory FailFast
public EventLogCategory MessageLogging
public EventLogCategory PerformanceCounter
public EventLogCategory Wmi
public EventLogCategory ComPlus
public EventLogCategory StateMachine
public EventLogCategory Wsat
public EventLogCategory SharingService
public EventLogCategory ListenerAdapter
}
internal System.Runtime.Diagnostics.EventLogEventId : Enum {
public UInt32 value__
public EventLogEventId FailedToSetupTracing
public EventLogEventId FailedToInitializeTraceSource
public EventLogEventId FailFast
public EventLogEventId FailFastException
public EventLogEventId FailedToTraceEvent
public EventLogEventId FailedToTraceEventWithException
public EventLogEventId InvariantAssertionFailed
public EventLogEventId PiiLoggingOn
public EventLogEventId PiiLoggingNotAllowed
public EventLogEventId WebHostUnhandledException
public EventLogEventId WebHostHttpError
public EventLogEventId WebHostFailedToProcessRequest
public EventLogEventId WebHostFailedToListen
public EventLogEventId FailedToLogMessage
public EventLogEventId RemovedBadFilter
public EventLogEventId FailedToCreateMessageLoggingTraceSource
public EventLogEventId MessageLoggingOn
public EventLogEventId MessageLoggingOff
public EventLogEventId FailedToLoadPerformanceCounter
public EventLogEventId FailedToRemovePerformanceCounter
public EventLogEventId WmiGetObjectFailed
public EventLogEventId WmiPutInstanceFailed
public EventLogEventId WmiDeleteInstanceFailed
public EventLogEventId WmiCreateInstanceFailed
public EventLogEventId WmiExecQueryFailed
public EventLogEventId WmiExecMethodFailed
public EventLogEventId WmiRegistrationFailed
public EventLogEventId WmiUnregistrationFailed
public EventLogEventId WmiAdminTypeMismatch
public EventLogEventId WmiPropertyMissing
public EventLogEventId ComPlusServiceHostStartingServiceError
public EventLogEventId ComPlusDllHostInitializerStartingError
public EventLogEventId ComPlusTLBImportError
public EventLogEventId ComPlusInvokingMethodFailed
public EventLogEventId ComPlusInstanceCreationError
public EventLogEventId ComPlusInvokingMethodFailedMismatchedTransactions
public EventLogEventId WebHostNotLoggingInsufficientMemoryExceptionsOnActivationForNextTimeInterval
public EventLogEventId UnhandledStateMachineExceptionRecordDescription
public EventLogEventId FatalUnexpectedStateMachineEvent
public EventLogEventId ParticipantRecoveryLogEntryCorrupt
public EventLogEventId CoordinatorRecoveryLogEntryCorrupt
public EventLogEventId CoordinatorRecoveryLogEntryCreationFailure
public EventLogEventId ParticipantRecoveryLogEntryCreationFailure
public EventLogEventId ProtocolInitializationFailure
public EventLogEventId ProtocolStartFailure
public EventLogEventId ProtocolRecoveryBeginningFailure
public EventLogEventId ProtocolRecoveryCompleteFailure
public EventLogEventId TransactionBridgeRecoveryFailure
public EventLogEventId ProtocolStopFailure
public EventLogEventId NonFatalUnexpectedStateMachineEvent
public EventLogEventId PerformanceCounterInitializationFailure
public EventLogEventId ProtocolRecoveryComplete
public EventLogEventId ProtocolStopped
public EventLogEventId ThumbPrintNotFound
public EventLogEventId ThumbPrintNotValidated
public EventLogEventId SslNoPrivateKey
public EventLogEventId SslNoAccessiblePrivateKey
public EventLogEventId MissingNecessaryKeyUsage
public EventLogEventId MissingNecessaryEnhancedKeyUsage
public EventLogEventId StartErrorPublish
public EventLogEventId BindingError
public EventLogEventId LAFailedToListenForApp
public EventLogEventId UnknownListenerAdapterError
public EventLogEventId WasDisconnected
public EventLogEventId WasConnectionTimedout
public EventLogEventId ServiceStartFailed
public EventLogEventId MessageQueueDuplicatedSocketLeak
public EventLogEventId MessageQueueDuplicatedPipeLeak
public EventLogEventId SharingUnhandledException
public EventLogEventId ServiceAuthorizationSuccess
public EventLogEventId ServiceAuthorizationFailure
public EventLogEventId MessageAuthenticationSuccess
public EventLogEventId MessageAuthenticationFailure
public EventLogEventId SecurityNegotiationSuccess
public EventLogEventId SecurityNegotiationFailure
public EventLogEventId TransportAuthenticationSuccess
public EventLogEventId TransportAuthenticationFailure
public EventLogEventId ImpersonationSuccess
public EventLogEventId ImpersonationFailure
}
internal System.Runtime.Diagnostics.EventLogger : object {
private int MaxEventLogsInPT
private int logCountForPT
private bool canLogEvent
private DiagnosticTraceBase diagnosticTrace
private string eventLogSourceName
private bool isInPartialTrust
public void .ctor(string eventLogSourceName, DiagnosticTraceBase diagnosticTrace)
public EventLogger UnsafeCreateEventLogger(string eventLogSourceName, DiagnosticTraceBase diagnosticTrace)
public void UnsafeLogEvent(TraceEventType type, ushort eventLogCategory, UInt32 eventId, bool shouldTrace, String[] values)
public void LogEvent(TraceEventType type, ushort eventLogCategory, UInt32 eventId, bool shouldTrace, String[] values)
public void LogEvent(TraceEventType type, ushort eventLogCategory, UInt32 eventId, String[] values)
private EventLogEntryType EventLogEntryTypeFromEventType(TraceEventType type)
private void SafeLogEvent(TraceEventType type, ushort eventLogCategory, UInt32 eventId, bool shouldTrace, String[] values)
private void SafeSetLogSourceName(string eventLogSourceName)
private void SetLogSourceName(string eventLogSourceName, DiagnosticTraceBase diagnosticTrace)
private bool IsInPartialTrust()
private void UnsafeWriteEventLog(TraceEventType type, ushort eventLogCategory, UInt32 eventId, String[] logValues, Byte[] sidBA, GCHandle stringsRootHandle)
private string UnsafeGetProcessName()
private int UnsafeGetProcessId()
internal string NormalizeEventLogParameter(string eventLogParameter)
}
internal System.Runtime.Diagnostics.EventSeverity : Enum {
public UInt32 value__
public EventSeverity Success
public EventSeverity Informational
public EventSeverity Warning
public EventSeverity Error
}
internal System.Runtime.Diagnostics.EventTraceActivity : object {
public Guid ActivityId
private EventTraceActivity empty
public EventTraceActivity Empty
public string Name
public void .ctor(bool setOnThread)
public void .ctor(Guid guid, bool setOnThread)
public EventTraceActivity get_Empty()
public string get_Name()
public EventTraceActivity GetFromThreadOrCreate(bool clearIdOnThread)
public Guid GetActivityIdFromThread()
public void SetActivityId(Guid guid)
private void SetActivityIdOnThread()
}
internal System.Runtime.Diagnostics.ITraceSourceStringProvider {
public string GetSourceString()
}
internal System.Runtime.Diagnostics.PerformanceCounterNameAttribute : Attribute {
private string <Name>k__BackingField
public string Name
public void .ctor(string name)
public string get_Name()
public void set_Name(string value)
}
internal System.Runtime.Diagnostics.StringTraceRecord : TraceRecord {
private string elementName
private string content
internal string EventId
internal void .ctor(string elementName, string content)
internal string get_EventId()
internal void WriteTo(XmlWriter writer)
}
internal System.Runtime.Diagnostics.TraceRecord : object {
protected string EventIdBase
protected string NamespaceSuffix
internal string EventId
internal string get_EventId()
internal void WriteTo(XmlWriter writer)
protected string BuildEventId(string eventId)
protected string XmlEncode(string text)
}
internal System.Runtime.DiagnosticStrings : object {
internal string AppDomain
internal string ChannelTag
internal string Description
internal string DataTag
internal string DataItemsTag
internal string DescriptionTag
internal string ExceptionTag
internal string ExceptionTypeTag
internal string ExceptionStringTag
internal string ExtendedDataTag
internal string InnerExceptionTag
internal string KeyTag
internal string MessageTag
internal string NamespaceTag
internal string NativeErrorCodeTag
internal string Separator
internal string SeverityTag
internal string SourceTag
internal string StackTraceTag
internal string Task
internal string TraceCodeTag
internal string TraceRecordTag
internal string ValueTag
}
internal System.Runtime.DuplicateDetector`1 : object {
private LinkedList`1<T> fifoList
private Dictionary`2<T, LinkedListNode`1<T>> items
private int capacity
private object thisLock
public void .ctor(int capacity)
public bool AddIfNotDuplicate(T value)
private void Add(T value)
public bool Remove(T value)
public void Clear()
}
internal System.Runtime.ExceptionTrace : object {
private ushort FailFastEventLogCategory
private string eventSourceName
private EtwDiagnosticTrace diagnosticTrace
public void .ctor(string eventSourceName, EtwDiagnosticTrace diagnosticTrace)
public void AsInformation(Exception exception)
public void AsWarning(Exception exception)
public Exception AsError(Exception exception)
public Exception AsError(Exception exception, string eventSource)
public Exception AsError(TargetInvocationException targetInvocationException, string eventSource)
public Exception AsError(AggregateException aggregateException)
public Exception AsError(AggregateException aggregateException, string eventSource)
public ArgumentException Argument(string paramName, string message)
public ArgumentNullException ArgumentNull(string paramName)
public ArgumentNullException ArgumentNull(string paramName, string message)
public ArgumentException ArgumentNullOrEmpty(string paramName)
public ArgumentOutOfRangeException ArgumentOutOfRange(string paramName, object actualValue, string message)
public ObjectDisposedException ObjectDisposed(string message)
public void TraceUnhandledException(Exception exception)
public void TraceHandledException(Exception exception, TraceEventType traceEventType)
public void TraceEtwException(Exception exception, TraceEventType eventType)
private TException TraceException(TException exception)
private TException TraceException(TException exception, string eventSource)
private void BreakOnException(Exception exception)
internal void TraceFailFast(string message)
internal void TraceFailFast(string message, EventLogger logger)
}
internal System.Runtime.FastAsyncCallback : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object state, Exception asyncException)
public IAsyncResult BeginInvoke(object state, Exception asyncException, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
internal System.Runtime.FatalException : SystemException {
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
protected void .ctor(SerializationInfo info, StreamingContext context)
}
internal System.Runtime.Fx : object {
private string defaultEventSource
private ExceptionTrace exceptionTrace
private EtwDiagnosticTrace diagnosticTrace
private ExceptionHandler asynchronousThreadExceptionHandler
public ExceptionTrace Exception
public EtwDiagnosticTrace Trace
public ExceptionHandler AsynchronousThreadExceptionHandler
internal bool AssertsFailFast
internal Type[] BreakOnExceptionTypes
internal bool FastDebug
internal bool StealthDebugger
public ExceptionTrace get_Exception()
public EtwDiagnosticTrace get_Trace()
private EtwDiagnosticTrace InitializeTracing()
public ExceptionHandler get_AsynchronousThreadExceptionHandler()
public void set_AsynchronousThreadExceptionHandler(ExceptionHandler value)
public void Assert(bool condition, string description)
public void Assert(string description)
public void AssertAndThrow(bool condition, string description)
public Exception AssertAndThrow(string description)
public void AssertAndThrowFatal(bool condition, string description)
public Exception AssertAndThrowFatal(string description)
public void AssertAndFailFast(bool condition, string description)
public Exception AssertAndFailFast(string description)
public bool IsFatal(Exception exception)
internal bool get_AssertsFailFast()
internal Type[] get_BreakOnExceptionTypes()
internal bool get_FastDebug()
internal bool get_StealthDebugger()
public Action`1<T1> ThunkCallback(Action`1<T1> callback)
public AsyncCallback ThunkCallback(AsyncCallback callback)
public WaitCallback ThunkCallback(WaitCallback callback)
public TimerCallback ThunkCallback(TimerCallback callback)
public WaitOrTimerCallback ThunkCallback(WaitOrTimerCallback callback)
public SendOrPostCallback ThunkCallback(SendOrPostCallback callback)
public IOCompletionCallback ThunkCallback(IOCompletionCallback callback)
public Guid CreateGuid(string guidString)
public bool TryCreateGuid(string guidString, Guid& result)
public Byte[] AllocateByteArray(int size)
public Char[] AllocateCharArray(int size)
private void TraceExceptionNoThrow(Exception exception)
private bool HandleAtThreadBase(Exception exception)
private void UpdateLevel(EtwDiagnosticTrace trace)
private void UpdateLevel()
}
internal System.Runtime.HashHelper : object {
public Byte[] ComputeHash(Byte[] buffer)
}
internal System.Runtime.IAsyncEventArgs {
public object AsyncState
public Exception Exception
public object get_AsyncState()
public Exception get_Exception()
}
internal System.Runtime.InputQueue`1 : object {
private Action`1<object> completeOutstandingReadersCallback
private Action`1<object> completeWaitersFalseCallback
private Action`1<object> completeWaitersTrueCallback
private Action`1<object> onDispatchCallback
private Action`1<object> onInvokeDequeuedCallback
private QueueState<T> queueState
private ItemQueue<T> itemQueue
private Queue`1<IQueueReader<T>> readerQueue
private List`1<IQueueWaiter<T>> waiterList
private Action`1<T> <DisposeItemCallback>k__BackingField
private Func`1<Action`2<AsyncCallback, IAsyncResult>> <AsyncCallbackGenerator>k__BackingField
public int PendingCount
public Action`1<T> DisposeItemCallback
private Func`1<Action`2<AsyncCallback, IAsyncResult>> AsyncCallbackGenerator
private object ThisLock
public void .ctor(Func`1<Action`2<AsyncCallback, IAsyncResult>> asyncCallbackGenerator)
public int get_PendingCount()
public Action`1<T> get_DisposeItemCallback()
public void set_DisposeItemCallback(Action`1<T> value)
private Func`1<Action`2<AsyncCallback, IAsyncResult>> get_AsyncCallbackGenerator()
private void set_AsyncCallbackGenerator(Func`1<Action`2<AsyncCallback, IAsyncResult>> value)
private object get_ThisLock()
public IAsyncResult BeginDequeue(TimeSpan timeout, AsyncCallback callback, object state)
public IAsyncResult BeginWaitForItem(TimeSpan timeout, AsyncCallback callback, object state)
public void Close()
public T Dequeue(TimeSpan timeout)
public bool Dequeue(TimeSpan timeout, T& value)
public void Dispatch()
public bool EndDequeue(IAsyncResult result, T& value)
public T EndDequeue(IAsyncResult result)
public bool EndWaitForItem(IAsyncResult result)
public void EnqueueAndDispatch(T item)
public void EnqueueAndDispatch(T item, Action dequeuedCallback)
public void EnqueueAndDispatch(Exception exception, Action dequeuedCallback, bool canDispatchOnThisThread)
public void EnqueueAndDispatch(T item, Action dequeuedCallback, bool canDispatchOnThisThread)
public bool EnqueueWithoutDispatch(T item, Action dequeuedCallback)
public bool EnqueueWithoutDispatch(Exception exception, Action dequeuedCallback)
public void Shutdown()
public void Shutdown(Func`1<Exception> pendingExceptionGenerator)
public bool WaitForItem(TimeSpan timeout)
public void Dispose()
private void DisposeItem(Item<T> item)
private void CompleteOutstandingReadersCallback(object state)
private void CompleteWaiters(bool itemAvailable, IQueueWaiter[] waiters)
private void CompleteWaitersFalseCallback(object state)
private void CompleteWaitersLater(bool itemAvailable, IQueueWaiter[] waiters)
private void CompleteWaitersTrueCallback(object state)
private void InvokeDequeuedCallback(Action dequeuedCallback)
private void InvokeDequeuedCallbackLater(Action dequeuedCallback)
private void OnDispatchCallback(object state)
private void OnInvokeDequeuedCallback(object state)
private void EnqueueAndDispatch(Item<T> item, bool canDispatchOnThisThread)
private bool EnqueueWithoutDispatch(Item<T> item)
private void GetWaiters(IQueueWaiter[]& waiters)
private bool RemoveReader(IQueueReader<T> reader)
}
internal System.Runtime.InternalBufferManager : object {
public Byte[] TakeBuffer(int bufferSize)
public void ReturnBuffer(Byte[] buffer)
public void Clear()
public InternalBufferManager Create(long maxBufferPoolSize, int maxBufferSize)
}
internal System.Runtime.InternalSR : object {
public string ActionItemIsAlreadyScheduled
public string AsyncCallbackThrewException
public string AsyncResultAlreadyEnded
public string BadCopyToArray
public string BufferIsNotRightSizeForBufferManager
public string DictionaryIsReadOnly
public string InvalidAsyncResult
public string InvalidAsyncResultImplementationGeneric
public string InvalidNullAsyncResult
public string InvalidSemaphoreExit
public string KeyCollectionUpdatesNotAllowed
public string KeyNotFoundInDictionary
public string MustCancelOldTimer
public string NullKeyAlreadyPresent
public string ReadNotSupported
public string SFxTaskNotStarted
public string SeekNotSupported
public string ThreadNeutralSemaphoreAborted
public string ValueCollectionUpdatesNotAllowed
public string ValueMustBeNonNegative
public string ArgumentNullOrEmpty(string paramName)
public string AsyncEventArgsCompletedTwice(Type t)
public string AsyncEventArgsCompletionPending(Type t)
public string BufferAllocationFailed(int size)
public string BufferedOutputStreamQuotaExceeded(int maxSizeQuota)
public string CannotConvertObject(object source, Type t)
public string EtwAPIMaxStringCountExceeded(object max)
public string EtwMaxNumberArgumentsExceeded(object max)
public string EtwRegistrationFailed(object arg)
public string FailFastMessage(string description)
public string InvalidAsyncResultImplementation(Type t)
public string LockTimeoutExceptionMessage(object timeout)
public string ShipAssertExceptionMessage(object description)
public string TaskTimedOutError(object timeout)
public string TimeoutInputQueueDequeue(object timeout)
public string TimeoutMustBeNonNegative(object argumentName, object timeout)
public string TimeoutMustBePositive(string argumentName, object timeout)
public string TimeoutOnOperation(object timeout)
public string AsyncResultCompletedTwice(Type t)
}
internal System.Runtime.Interop.SafeEventLogWriteHandle : SafeHandleZeroOrMinusOneIsInvalid {
public SafeEventLogWriteHandle RegisterEventSource(string uncServerName, string sourceName)
private bool DeregisterEventSource(IntPtr hEventLog)
protected bool ReleaseHandle()
}
internal System.Runtime.Interop.UnsafeNativeMethods : object {
public string KERNEL32
public string ADVAPI32
public int ERROR_INVALID_HANDLE
public int ERROR_MORE_DATA
public int ERROR_ARITHMETIC_OVERFLOW
public int ERROR_NOT_ENOUGH_MEMORY
public SafeWaitHandle CreateWaitableTimer(IntPtr mustBeZero, bool manualReset, string timerName)
public bool SetWaitableTimer(SafeWaitHandle handle, Int64& dueTime, int period, IntPtr mustBeZero, IntPtr mustBeZeroAlso, bool resume)
public int QueryPerformanceCounter(Int64& time)
public UInt32 GetSystemTimeAdjustment(Int32& adjustment, UInt32& increment, UInt32& adjustmentDisabled)
private void GetSystemTimeAsFileTime(FILETIME& time)
public void GetSystemTimeAsFileTime(Int64& time)
private bool GetComputerNameEx(ComputerNameFormat nameType, StringBuilder lpBuffer, Int32& size)
internal string GetComputerName(ComputerNameFormat nameType)
internal bool IsDebuggerPresent()
internal void DebugBreak()
internal void OutputDebugString(string lpOutputString)
internal UInt32 EventRegister(Guid& providerId, EtwEnableCallback enableCallback, Void* callbackContext, Int64& registrationHandle)
internal UInt32 EventUnregister(long registrationHandle)
internal bool EventEnabled(long registrationHandle, EventDescriptor& eventDescriptor)
internal UInt32 EventWrite(long registrationHandle, EventDescriptor& eventDescriptor, UInt32 userDataCount, EventData* userData)
internal UInt32 EventWriteTransfer(long registrationHandle, EventDescriptor& eventDescriptor, Guid& activityId, Guid& relatedActivityId, UInt32 userDataCount, EventData* userData)
internal UInt32 EventWriteString(long registrationHandle, byte level, long keywords, Char* message)
internal UInt32 EventActivityIdControl(int ControlCode, Guid& ActivityId)
internal bool ReportEvent(SafeHandle hEventLog, ushort type, ushort category, UInt32 eventID, Byte[] userSID, ushort numStrings, UInt32 dataLen, HandleRef strings, Byte[] rawData)
internal SafeEventLogWriteHandle RegisterEventSource(string uncServerName, string sourceName)
}
internal System.Runtime.IOThreadCancellationTokenSource : object {
private Action`1<object> onCancel
private TimeSpan timeout
private CancellationTokenSource source
private Nullable`1<CancellationToken> token
private IOThreadTimer timer
public CancellationToken Token
public void .ctor(TimeSpan timeout)
public void .ctor(int timeout)
public CancellationToken get_Token()
public void Dispose()
private void OnCancel(object obj)
private void Cancel()
}
internal System.Runtime.IOThreadScheduler : object {
private int MaximumCapacity
private IOThreadScheduler current
private ScheduledOverlapped overlapped
private Slot[] slots
private Slot[] slotsLowPri
private int headTail
private int headTailLowPri
private int SlotMask
private int SlotMaskLowPri
private void .ctor(int capacity, int capacityLowPri)
public void ScheduleCallbackNoFlow(Action`1<object> callback, object state)
public void ScheduleCallbackLowPriNoFlow(Action`1<object> callback, object state)
private bool ScheduleCallbackHelper(Action`1<object> callback, object state)
private bool ScheduleCallbackLowPriHelper(Action`1<object> callback, object state)
private void CompletionCallback(Action`1& callback, Object& state)
private bool TryCoalesce(Action`1& callback, Object& state)
private int get_SlotMask()
private int get_SlotMaskLowPri()
protected void Finalize()
private void Cleanup()
}
internal System.Runtime.IOThreadTimer : object {
private int maxSkewInMillisecondsDefault
private long systemTimeResolutionTicks
private Action`1<object> callback
private object callbackState
private long dueTime
private int index
private long maxSkew
private TimerGroup timerGroup
public long SystemTimeResolutionTicks
public void .ctor(Action`1<object> callback, object callbackState, bool isTypicallyCanceledShortlyAfterBeingSet)
public void .ctor(Action`1<object> callback, object callbackState, bool isTypicallyCanceledShortlyAfterBeingSet, int maxSkewInMilliseconds)
public long get_SystemTimeResolutionTicks()
private long GetSystemTimeResolution()
public bool Cancel()
public void Set(TimeSpan timeFromNow)
public void Set(int millisecondsFromNow)
public void SetAt(long dueTime)
}
internal System.Runtime.MruCache`2 : object {
private LinkedList`1<TKey> mruList
private Dictionary`2<TKey, CacheEntry<TKey, TValue>> items
private int lowWatermark
private int highWatermark
private CacheEntry<TKey, TValue> mruEntry
public int Count
public void .ctor(int watermark)
public void .ctor(int lowWatermark, int highWatermark)
public void .ctor(int lowWatermark, int highWatermark, IEqualityComparer`1<TKey> comparer)
public int get_Count()
public void Add(TKey key, TValue value)
public void Clear()
public bool Remove(TKey key)
protected void OnSingleItemRemoved(TValue item)
protected void OnItemAgedOutOfCache(TValue item)
public bool TryGetValue(TKey key, TValue& value)
}
internal System.Runtime.NameGenerator : object {
private NameGenerator nameGenerator
private long id
private string prefix
public string Next()
}
internal System.Runtime.PartialTrustHelpers : object {
private Type aptca
private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) checkedForFullTrust
private bool inFullTrust
internal bool ShouldFlowSecurityContext
internal bool AppDomainFullyTrusted
internal bool get_ShouldFlowSecurityContext()
internal bool IsInFullTrust()
internal bool IsTypeAptca(Type type)
internal void DemandForFullTrust()
private bool IsAssemblyAptca(Assembly assembly)
private bool IsAssemblySigned(Assembly assembly)
internal bool CheckAppDomainPermissions(PermissionSet permissions)
internal bool HasEtwPermissions()
internal bool get_AppDomainFullyTrusted()
}
internal System.Runtime.ReadOnlyDictionaryInternal`2 : object {
private IDictionary`2<TKey, TValue> dictionary
public int Count
public bool IsReadOnly
public ICollection`1<TKey> Keys
public ICollection`1<TValue> Values
public TValue Item
public void .ctor(IDictionary`2<TKey, TValue> dictionary)
public int get_Count()
public bool get_IsReadOnly()
public ICollection`1<TKey> get_Keys()
public ICollection`1<TValue> get_Values()
public TValue get_Item(TKey key)
public void set_Item(TKey key, TValue value)
public IDictionary`2<TKey, TValue> Create(IDictionary`2<TKey, TValue> dictionary)
private Exception CreateReadOnlyException()
public void Add(TKey key, TValue value)
public void Add(KeyValuePair`2<TKey, TValue> item)
public void Clear()
public bool Contains(KeyValuePair`2<TKey, TValue> item)
public bool ContainsKey(TKey key)
public void CopyTo(KeyValuePair`2[] array, int arrayIndex)
public IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
public bool Remove(TKey key)
public bool Remove(KeyValuePair`2<TKey, TValue> item)
public bool TryGetValue(TKey key, TValue& value)
}
internal System.Runtime.ReadOnlyKeyedCollection`2 : ReadOnlyCollection`1<TValue> {
private KeyedCollection`2<TKey, TValue> innerCollection
public TValue Item
public void .ctor(KeyedCollection`2<TKey, TValue> innerCollection)
public TValue get_Item(TKey key)
}
internal System.Runtime.ScheduleActionItemAsyncResult : AsyncResult {
private Action`1<object> doWork
protected void .ctor(AsyncCallback callback, object state)
protected void Schedule()
private void DoWork(object state)
protected void OnDoWork()
public void End(IAsyncResult result)
}
internal System.Runtime.SignalGate : object {
private int state
internal bool IsLocked
internal bool IsSignalled
internal bool get_IsLocked()
internal bool get_IsSignalled()
public bool Signal()
public bool Unlock()
private void ThrowInvalidSignalGateState()
}
internal System.Runtime.SignalGate`1 : SignalGate {
private T result
public bool Signal(T result)
public bool Unlock(T& result)
}
internal System.Runtime.SynchronizedPool`1 : object {
private int maxPendingEntries
private int maxPromotionFailures
private int maxReturnsBeforePromotion
private int maxThreadItemsPerProcessor
private Entry[] entries
private GlobalPool<T> globalPool
private int maxCount
private PendingEntry[] pending
private int promotionFailures
private object ThisLock
public void .ctor(int maxCount)
private object get_ThisLock()
public void Clear()
private void HandlePromotionFailure(int thisThreadID)
private bool PromoteThread(int thisThreadID)
private void RecordReturnToGlobalPool(int thisThreadID)
private void RecordTakeFromGlobalPool(int thisThreadID)
public bool Return(T value)
private bool ReturnToPerThreadPool(int thisThreadID, T value)
private bool ReturnToGlobalPool(int thisThreadID, T value)
public T Take()
private T TakeFromPerThreadPool(int thisThreadID)
private T TakeFromGlobalPool(int thisThreadID)
}
internal System.Runtime.TaskExtensions : object {
public IAsyncResult AsAsyncResult(Task`1<T> task, AsyncCallback callback, object state)
public IAsyncResult AsAsyncResult(Task task, AsyncCallback callback, object state)
public ConfiguredTaskAwaitable SuppressContextFlow(Task task)
public ConfiguredTaskAwaitable`1<T> SuppressContextFlow(Task`1<T> task)
public ConfiguredTaskAwaitable ContinueOnCapturedContextFlow(Task task)
public ConfiguredTaskAwaitable`1<T> ContinueOnCapturedContextFlow(Task`1<T> task)
public void Wait(Task task)
public bool Wait(Task task, int millisecondsTimeout)
public bool Wait(Task task, TimeSpan timeout)
public void Wait(Task task, TimeSpan timeout, Action`3<Exception, TimeSpan, string> exceptionConverter, string operationType)
public Task`1<TBase> Upcast(Task`1<TDerived> task)
private Task`1<TBase> UpcastPrivate(Task`1<TDerived> task)
}
internal System.Runtime.ThreadNeutralSemaphore : object {
private Action`2<object, TimeoutException> enteredAsyncCallback
private bool aborted
private Func`1<Exception> abortedExceptionGenerator
private int count
private int maxCount
private object ThisLock
private Queue`1<AsyncWaitHandle> waiters
private Action`2<object, TimeoutException> EnteredAsyncCallback
private Queue`1<AsyncWaitHandle> Waiters
public void .ctor(int maxCount)
public void .ctor(int maxCount, Func`1<Exception> abortedExceptionGenerator)
private Action`2<object, TimeoutException> get_EnteredAsyncCallback()
private Queue`1<AsyncWaitHandle> get_Waiters()
public bool EnterAsync(TimeSpan timeout, FastAsyncCallback callback, object state)
private void OnEnteredAsync(object state, TimeoutException exception)
public bool TryEnter()
public void Enter(TimeSpan timeout)
public bool TryEnter(TimeSpan timeout)
internal TimeoutException CreateEnterTimedOutException(TimeSpan timeout)
private Exception CreateObjectAbortedException()
private bool RemoveWaiter(AsyncWaitHandle waiter)
private AsyncWaitHandle EnterCore()
public int Exit()
public void Abort()
}
internal System.Runtime.Ticks : object {
public long Now
public long get_Now()
public long FromMilliseconds(int milliseconds)
public int ToMilliseconds(long ticks)
public long FromTimeSpan(TimeSpan duration)
public TimeSpan ToTimeSpan(long ticks)
public long Add(long firstTicks, long secondTicks)
}
internal System.Runtime.TimeoutHelper : ValueType {
private DateTime deadline
private bool deadlineSet
private TimeSpan originalTimeout
public TimeSpan MaxWait
public TimeSpan OriginalTimeout
public void .ctor(TimeSpan timeout)
public TimeSpan get_OriginalTimeout()
public bool IsTooLarge(TimeSpan timeout)
public TimeSpan FromMilliseconds(int milliseconds)
public int ToMilliseconds(TimeSpan timeout)
public TimeSpan Min(TimeSpan val1, TimeSpan val2)
public TimeSpan Add(TimeSpan timeout1, TimeSpan timeout2)
public DateTime Add(DateTime time, TimeSpan timeout)
public DateTime Subtract(DateTime time, TimeSpan timeout)
public TimeSpan Divide(TimeSpan timeout, int factor)
public TimeSpan RemainingTime()
public TimeSpan ElapsedTime()
private void SetDeadline()
public void ThrowIfNegativeArgument(TimeSpan timeout)
public void ThrowIfNegativeArgument(TimeSpan timeout, string argumentName)
public void ThrowIfNonPositiveArgument(TimeSpan timeout)
public void ThrowIfNonPositiveArgument(TimeSpan timeout, string argumentName)
public bool WaitOne(WaitHandle waitHandle, TimeSpan timeout)
}
internal System.Runtime.TraceChannel : Enum {
public int value__
public TraceChannel Admin
public TraceChannel Operational
public TraceChannel Analytic
public TraceChannel Debug
public TraceChannel Perf
public TraceChannel Application
}
internal System.Runtime.TraceCore : object {
private ResourceManager resourceManager
private CultureInfo resourceCulture
private EventDescriptor[] eventDescriptors
private object syncLock
private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) eventDescriptorsCreated
private ResourceManager ResourceManager
internal CultureInfo Culture
private ResourceManager get_ResourceManager()
internal CultureInfo get_Culture()
internal void set_Culture(CultureInfo value)
internal bool AppDomainUnloadIsEnabled(EtwDiagnosticTrace trace)
internal void AppDomainUnload(EtwDiagnosticTrace trace, string appdomainName, string processName, string processId)
internal bool HandledExceptionIsEnabled(EtwDiagnosticTrace trace)
internal void HandledException(EtwDiagnosticTrace trace, string param0, Exception exception)
internal bool ShipAssertExceptionMessageIsEnabled(EtwDiagnosticTrace trace)
internal void ShipAssertExceptionMessage(EtwDiagnosticTrace trace, string param0)
internal bool ThrowingExceptionIsEnabled(EtwDiagnosticTrace trace)
internal void ThrowingException(EtwDiagnosticTrace trace, string param0, string param1, Exception exception)
internal bool UnhandledExceptionIsEnabled(EtwDiagnosticTrace trace)
internal void UnhandledException(EtwDiagnosticTrace trace, string param0, Exception exception)
internal bool TraceCodeEventLogCriticalIsEnabled(EtwDiagnosticTrace trace)
internal void TraceCodeEventLogCritical(EtwDiagnosticTrace trace, TraceRecord traceRecord)
internal bool TraceCodeEventLogErrorIsEnabled(EtwDiagnosticTrace trace)
internal void TraceCodeEventLogError(EtwDiagnosticTrace trace, TraceRecord traceRecord)
internal bool TraceCodeEventLogInfoIsEnabled(EtwDiagnosticTrace trace)
internal void TraceCodeEventLogInfo(EtwDiagnosticTrace trace, TraceRecord traceRecord)
internal bool TraceCodeEventLogVerboseIsEnabled(EtwDiagnosticTrace trace)
internal void TraceCodeEventLogVerbose(EtwDiagnosticTrace trace, TraceRecord traceRecord)
internal bool TraceCodeEventLogWarningIsEnabled(EtwDiagnosticTrace trace)
internal void TraceCodeEventLogWarning(EtwDiagnosticTrace trace, TraceRecord traceRecord)
internal bool HandledExceptionWarningIsEnabled(EtwDiagnosticTrace trace)
internal void HandledExceptionWarning(EtwDiagnosticTrace trace, string param0, Exception exception)
internal bool BufferPoolAllocationIsEnabled(EtwDiagnosticTrace trace)
internal void BufferPoolAllocation(EtwDiagnosticTrace trace, int Size)
internal bool BufferPoolChangeQuotaIsEnabled(EtwDiagnosticTrace trace)
internal void BufferPoolChangeQuota(EtwDiagnosticTrace trace, int PoolSize, int Delta)
internal bool ActionItemScheduledIsEnabled(EtwDiagnosticTrace trace)
internal void ActionItemScheduled(EtwDiagnosticTrace trace, EventTraceActivity eventTraceActivity)
internal bool ActionItemCallbackInvokedIsEnabled(EtwDiagnosticTrace trace)
internal void ActionItemCallbackInvoked(EtwDiagnosticTrace trace, EventTraceActivity eventTraceActivity)
internal bool HandledExceptionErrorIsEnabled(EtwDiagnosticTrace trace)
internal void HandledExceptionError(EtwDiagnosticTrace trace, string param0, Exception exception)
internal bool HandledExceptionVerboseIsEnabled(EtwDiagnosticTrace trace)
internal void HandledExceptionVerbose(EtwDiagnosticTrace trace, string param0, Exception exception)
internal bool EtwUnhandledExceptionIsEnabled(EtwDiagnosticTrace trace)
internal void EtwUnhandledException(EtwDiagnosticTrace trace, string param0, Exception exception)
internal bool ThrowingEtwExceptionIsEnabled(EtwDiagnosticTrace trace)
internal void ThrowingEtwException(EtwDiagnosticTrace trace, string param0, string param1, Exception exception)
internal bool ThrowingEtwExceptionVerboseIsEnabled(EtwDiagnosticTrace trace)
internal void ThrowingEtwExceptionVerbose(EtwDiagnosticTrace trace, string param0, string param1, Exception exception)
internal bool ThrowingExceptionVerboseIsEnabled(EtwDiagnosticTrace trace)
internal void ThrowingExceptionVerbose(EtwDiagnosticTrace trace, string param0, string param1, Exception exception)
private void CreateEventDescriptors()
private void EnsureEventDescriptors()
private bool IsEtwEventEnabled(EtwDiagnosticTrace trace, int eventIndex)
private bool WriteEtwEvent(EtwDiagnosticTrace trace, int eventIndex, EventTraceActivity eventParam0, string eventParam1, string eventParam2, string eventParam3, string eventParam4)
private bool WriteEtwEvent(EtwDiagnosticTrace trace, int eventIndex, EventTraceActivity eventParam0, string eventParam1, string eventParam2, string eventParam3)
private bool WriteEtwEvent(EtwDiagnosticTrace trace, int eventIndex, EventTraceActivity eventParam0, string eventParam1, string eventParam2)
private bool WriteEtwEvent(EtwDiagnosticTrace trace, int eventIndex, EventTraceActivity eventParam0, int eventParam1, string eventParam2)
private bool WriteEtwEvent(EtwDiagnosticTrace trace, int eventIndex, EventTraceActivity eventParam0, int eventParam1, int eventParam2, string eventParam3)
private bool WriteEtwEvent(EtwDiagnosticTrace trace, int eventIndex, EventTraceActivity eventParam0, string eventParam1)
private void WriteTraceSource(EtwDiagnosticTrace trace, int eventIndex, string description, TracePayload payload)
}
internal System.Runtime.TraceEventLevel : Enum {
public int value__
public TraceEventLevel LogAlways
public TraceEventLevel Critical
public TraceEventLevel Error
public TraceEventLevel Warning
public TraceEventLevel Informational
public TraceEventLevel Verbose
}
internal System.Runtime.TraceEventOpcode : Enum {
public int value__
public TraceEventOpcode Info
public TraceEventOpcode Start
public TraceEventOpcode Stop
public TraceEventOpcode Reply
public TraceEventOpcode Resume
public TraceEventOpcode Suspend
public TraceEventOpcode Send
public TraceEventOpcode Receive
}
internal System.Runtime.TraceLevelHelper : object {
private TraceEventType[] EtwLevelToTraceEventType
internal TraceEventType GetTraceEventType(byte level, byte opcode)
internal TraceEventType GetTraceEventType(TraceEventLevel level)
internal TraceEventType GetTraceEventType(byte level)
internal string LookupSeverity(TraceEventLevel level, TraceEventOpcode opcode)
}
internal System.Runtime.TracePayload : ValueType {
private string serializedException
private string eventSource
private string appDomainFriendlyName
private string extendedData
private string hostReference
public string SerializedException
public string EventSource
public string AppDomainFriendlyName
public string ExtendedData
public string HostReference
public void .ctor(string serializedException, string eventSource, string appDomainFriendlyName, string extendedData, string hostReference)
public string get_SerializedException()
public string get_EventSource()
public string get_AppDomainFriendlyName()
public string get_ExtendedData()
public string get_HostReference()
}
internal System.Runtime.TypedAsyncResult`1 : AsyncResult {
private T data
public T Data
public void .ctor(AsyncCallback callback, object state)
public T get_Data()
protected void Complete(T data, bool completedSynchronously)
public T End(IAsyncResult result)
}
internal System.Runtime.TypeHelper : object {
public Type ArrayType
public Type BoolType
public Type GenericCollectionType
public Type ByteType
public Type SByteType
public Type CharType
public Type ShortType
public Type UShortType
public Type IntType
public Type UIntType
public Type LongType
public Type ULongType
public Type FloatType
public Type DoubleType
public Type DecimalType
public Type ExceptionType
public Type NullableType
public Type ObjectType
public Type StringType
public Type TypeType
public Type VoidType
public bool AreTypesCompatible(object source, Type destinationType)
public bool AreTypesCompatible(Type sourceType, Type destinationType)
public bool AreReferenceTypesCompatible(Type sourceType, Type destinationType)
public IEnumerable`1<Type> GetCompatibleTypes(IEnumerable`1<Type> enumerable, Type targetType)
public bool ContainsCompatibleType(IEnumerable`1<Type> enumerable, Type targetType)
public T Convert(object source)
public IEnumerable`1<Type> GetImplementedTypes(Type type)
private void GetImplementedTypesHelper(Type type, Dictionary`2<Type, object> typesEncountered)
private bool IsImplicitNumericConversion(Type source, Type destination)
private bool IsImplicitReferenceConversion(Type sourceType, Type destinationType)
private bool IsImplicitBoxingConversion(Type sourceType, Type destinationType)
private bool IsImplicitNullableConversion(Type sourceType, Type destinationType)
private bool IsNullableType(Type type)
private bool TryNumericConversion(object source, T& result)
public object GetDefaultValueForType(Type type)
public bool IsNullableValueType(Type type)
public bool IsNonNullableValueType(Type type)
public bool ShouldFilterProperty(PropertyDescriptor property, Attribute[] attributes)
}
internal System.Runtime.UrlUtility : object {
public NameValueCollection ParseQueryString(string query)
public NameValueCollection ParseQueryString(string query, Encoding encoding)
public string UrlEncode(string str)
public string UrlPathEncode(string str)
public string UrlEncode(string str, Encoding encoding)
public string UrlEncodeUnicode(string str)
private string UrlEncodeUnicodeStringToStringInternal(string s, bool ignoreAscii)
private string UrlEncodeNonAscii(string str, Encoding e)
private string UrlEncodeSpaces(string str)
public Byte[] UrlEncodeToBytes(string str, Encoding e)
public string UrlDecode(string str, Encoding e)
private Byte[] UrlEncodeBytesToBytesInternal(Byte[] bytes, int offset, int count, bool alwaysCreateReturnValue)
private bool IsNonAsciiByte(byte b)
private Byte[] UrlEncodeBytesToBytesInternalNonAscii(Byte[] bytes, int offset, int count, bool alwaysCreateReturnValue)
private string UrlDecodeStringFromStringInternal(string s, Encoding e)
private int HexToInt(char h)
private char IntToHex(int n)
internal bool IsSafe(char ch)
}
internal System.Runtime.WaitCallbackActionItem : object {
private bool <ShouldUseActivity>k__BackingField
internal bool ShouldUseActivity
internal bool get_ShouldUseActivity()
internal void set_ShouldUseActivity(bool value)
}
internal System.ServiceModel.Internals.LocalAppContextSwitches : object {
public bool IncludeNullExceptionMessageInETWTrace
}
