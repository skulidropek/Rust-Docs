internal static class SR : object {
    internal static string GetString(string name, Object[] args);
    internal static string GetString(CultureInfo culture, string name, Object[] args);
    internal static string GetString(string name);
    internal static string GetString(CultureInfo culture, string name);
    internal static string Format(string resourceFormat, Object[] args);
    internal static string Format(string resourceFormat, object p1);
    internal static string Format(string resourceFormat, object p1, object p2);
    internal static string Format(string resourceFormat, object p1, object p2, object p3);
}
internal static class System.LocalAppContextSwitches : object {
    public static bool DoNotUseTimeZoneInfo;
    public static bool DoNotUseEcmaScriptV6EscapeControlCharacter;
    private static LocalAppContextSwitches();
}
internal class System.Runtime.CompilerServices.FriendAccessAllowedAttribute : Attribute {
}
internal static class System.Runtime.Serialization.AppSettings : object {
    internal static string MaxMimePartsAppSettingsString;
    private static int DefaultMaxMimeParts;
    private static int maxMimeParts;
    private static Boolean modreq(System.Runtime.CompilerServices.IsVolatile) settingsInitalized;
    private static object appSettingsLock;
    internal static int MaxMimeParts { get; }
    private static AppSettings();
    internal static int get_MaxMimeParts();
    private static void EnsureSettingsLoaded();
}
internal class System.Runtime.Serialization.AsmxCharDataContract : CharDataContract {
}
internal class System.Runtime.Serialization.AsmxGuidDataContract : GuidDataContract {
}
internal class System.Runtime.Serialization.AttributeData : object {
    public string prefix;
    public string ns;
    public string localName;
    public string value;
}
internal class System.Runtime.Serialization.Attributes : object {
    [SecurityCriticalAttribute]
private static XmlDictionaryString[] serializationLocalNames;
    [SecurityCriticalAttribute]
private static XmlDictionaryString[] schemaInstanceLocalNames;
    internal string Id;
    internal string Ref;
    internal string XsiTypeName;
    internal string XsiTypeNamespace;
    internal string XsiTypePrefix;
    internal bool XsiNil;
    internal string ClrAssembly;
    internal string ClrType;
    internal int ArraySZSize;
    internal string FactoryTypeName;
    internal string FactoryTypeNamespace;
    internal string FactoryTypePrefix;
    internal bool UnrecognizedAttributesFound;
    [SecuritySafeCriticalAttribute]
private static Attributes();
    [SecuritySafeCriticalAttribute]
internal void Read(XmlReaderDelegator reader);
    internal void Reset();
    private void ReadId(XmlReaderDelegator reader);
    private void ReadRef(XmlReaderDelegator reader);
    private void ReadXsiNil(XmlReaderDelegator reader);
    private void ReadArraySize(XmlReaderDelegator reader);
    private void ReadXsiType(XmlReaderDelegator reader);
    private void ReadFactoryType(XmlReaderDelegator reader);
}
internal class System.Runtime.Serialization.BitFlagsGenerator : object {
    private int bitCount;
    private Byte[] locals;
    public BitFlagsGenerator(int bitCount);
    public void Store(int bitIndex, bool value);
    public bool Load(int bitIndex);
    public Byte[] LoadArray();
    public int GetLocalCount();
    public int GetBitCount();
    public byte GetLocal(int i);
    public static bool IsBitSet(Byte[] bytes, int bitIndex);
    public static void SetBit(Byte[] bytes, int bitIndex);
    private static int GetByteIndex(int bitIndex);
    private static byte GetBitValue(int bitIndex);
}
internal class System.Runtime.Serialization.BooleanDataContract : PrimitiveDataContract {
    internal string WriteMethodName { get; }
    internal string ReadMethodName { get; }
    internal virtual string get_WriteMethodName();
    internal virtual string get_ReadMethodName();
    public virtual void WriteXmlValue(XmlWriterDelegator writer, object obj, XmlObjectSerializerWriteContext context);
    public virtual object ReadXmlValue(XmlReaderDelegator reader, XmlObjectSerializerReadContext context);
}
internal class System.Runtime.Serialization.ByteArrayDataContract : PrimitiveDataContract {
    internal string WriteMethodName { get; }
    internal string ReadMethodName { get; }
    internal virtual string get_WriteMethodName();
    internal virtual string get_ReadMethodName();
    public virtual void WriteXmlValue(XmlWriterDelegator writer, object obj, XmlObjectSerializerWriteContext context);
    public virtual object ReadXmlValue(XmlReaderDelegator reader, XmlObjectSerializerReadContext context);
}
internal class System.Runtime.Serialization.CharDataContract : PrimitiveDataContract {
    internal string WriteMethodName { get; }
    internal string ReadMethodName { get; }
    internal CharDataContract(XmlDictionaryString name, XmlDictionaryString ns);
    internal virtual string get_WriteMethodName();
    internal virtual string get_ReadMethodName();
    public virtual void WriteXmlValue(XmlWriterDelegator writer, object obj, XmlObjectSerializerWriteContext context);
    public virtual object ReadXmlValue(XmlReaderDelegator reader, XmlObjectSerializerReadContext context);
}
internal class System.Runtime.Serialization.ClassDataContract : DataContract {
    public XmlDictionaryString[] ContractNamespaces;
    public XmlDictionaryString[] MemberNames;
    public XmlDictionaryString[] MemberNamespaces;
    [SecurityCriticalAttribute]
private XmlDictionaryString[] childElementNamespaces;
    [SecurityCriticalAttribute]
private ClassDataContractCriticalHelper helper;
    internal ClassDataContract BaseContract { get; internal set; }
    internal List`1<DataMember> Members { get; internal set; }
    public XmlDictionaryString[] ChildElementNamespaces { get; }
    internal MethodInfo OnSerializing { get; }
    internal MethodInfo OnSerialized { get; }
    internal MethodInfo OnDeserializing { get; }
    internal MethodInfo OnDeserialized { get; }
    internal MethodInfo ExtensionDataSetMethod { get; }
    internal Dictionary`2<XmlQualifiedName, DataContract> KnownDataContracts { get; internal set; }
    internal bool IsISerializable { get; internal set; }
    internal bool IsNonAttributedType { get; }
    internal bool HasDataContract { get; }
    internal bool HasExtensionData { get; }
    internal string SerializationExceptionMessage { get; }
    internal string DeserializationExceptionMessage { get; }
    internal bool IsReadOnlyContract { get; }
    internal XmlFormatClassWriterDelegate XmlFormatWriterDelegate { get; }
    internal XmlFormatClassReaderDelegate XmlFormatReaderDelegate { get; }
    [SecuritySafeCriticalAttribute]
internal ClassDataContract(Type type);
    [SecuritySafeCriticalAttribute]
private ClassDataContract(Type type, XmlDictionaryString ns, String[] memberNames);
    [SecurityCriticalAttribute]
private void InitClassDataContract();
    [SecuritySafeCriticalAttribute]
internal ClassDataContract get_BaseContract();
    [SecurityCriticalAttribute]
internal void set_BaseContract(ClassDataContract value);
    [SecuritySafeCriticalAttribute]
internal List`1<DataMember> get_Members();
    [SecurityCriticalAttribute]
internal void set_Members(List`1<DataMember> value);
    [SecuritySafeCriticalAttribute]
public XmlDictionaryString[] get_ChildElementNamespaces();
    [SecuritySafeCriticalAttribute]
internal MethodInfo get_OnSerializing();
    [SecuritySafeCriticalAttribute]
internal MethodInfo get_OnSerialized();
    [SecuritySafeCriticalAttribute]
internal MethodInfo get_OnDeserializing();
    [SecuritySafeCriticalAttribute]
internal MethodInfo get_OnDeserialized();
    [SecuritySafeCriticalAttribute]
internal MethodInfo get_ExtensionDataSetMethod();
    [SecuritySafeCriticalAttribute]
internal virtual Dictionary`2<XmlQualifiedName, DataContract> get_KnownDataContracts();
    [SecurityCriticalAttribute]
internal virtual void set_KnownDataContracts(Dictionary`2<XmlQualifiedName, DataContract> value);
    [SecuritySafeCriticalAttribute]
internal virtual bool get_IsISerializable();
    [SecurityCriticalAttribute]
internal virtual void set_IsISerializable(bool value);
    [SecuritySafeCriticalAttribute]
internal bool get_IsNonAttributedType();
    [SecuritySafeCriticalAttribute]
internal bool get_HasDataContract();
    [SecuritySafeCriticalAttribute]
internal bool get_HasExtensionData();
    [SecuritySafeCriticalAttribute]
internal string get_SerializationExceptionMessage();
    [SecuritySafeCriticalAttribute]
internal string get_DeserializationExceptionMessage();
    internal bool get_IsReadOnlyContract();
    [SecuritySafeCriticalAttribute]
internal ConstructorInfo GetISerializableConstructor();
    [SecuritySafeCriticalAttribute]
internal ConstructorInfo GetNonAttributedTypeConstructor();
    [SecuritySafeCriticalAttribute]
internal XmlFormatClassWriterDelegate get_XmlFormatWriterDelegate();
    [SecuritySafeCriticalAttribute]
internal XmlFormatClassReaderDelegate get_XmlFormatReaderDelegate();
    internal static ClassDataContract CreateClassDataContractForKeyValue(Type type, XmlDictionaryString ns, String[] memberNames);
    internal static void CheckAndAddMember(List`1<DataMember> members, DataMember memberContract, Dictionary`2<string, DataMember> memberNamesTable);
    internal static XmlDictionaryString GetChildNamespaceToDeclare(DataContract dataContract, Type childType, XmlDictionary dictionary);
    internal static bool IsNonAttributedTypeValidForSerialization(Type type);
    private XmlDictionaryString[] CreateChildElementNamespaces();
    [SecuritySafeCriticalAttribute]
private void EnsureMethodsImported();
    public virtual void WriteXmlValue(XmlWriterDelegator xmlWriter, object obj, XmlObjectSerializerWriteContext context);
    public virtual object ReadXmlValue(XmlReaderDelegator xmlReader, XmlObjectSerializerReadContext context);
    [SecuritySafeCriticalAttribute]
internal virtual DataContract BindGenericParameters(DataContract[] paramContracts, Dictionary`2<DataContract, DataContract> boundContracts);
    internal virtual bool Equals(object other, Dictionary`2<DataContractPairKey, object> checkedContracts);
    private bool IsEveryDataMemberOptional(IEnumerable`1<DataMember> dataMembers);
    public virtual int GetHashCode();
}
internal class System.Runtime.Serialization.ClassDataNode : DataNode`1<object> {
    private IList`1<ExtensionDataMember> members;
    internal IList`1<ExtensionDataMember> Members { get; internal set; }
    internal IList`1<ExtensionDataMember> get_Members();
    internal void set_Members(IList`1<ExtensionDataMember> value);
    public virtual void Clear();
}
internal class System.Runtime.Serialization.CodeExporter : object {
    private DataContractSet dataContractSet;
    private CodeCompileUnit codeCompileUnit;
    private ImportOptions options;
    private Dictionary`2<string, string> namespaces;
    private Dictionary`2<string, string> clrNamespaces;
    private static string wildcardNamespaceMapping;
    private static string typeNameFieldName;
    private static object codeUserDataActualTypeKey;
    private static object surrogateDataKey;
    private static int MaxIdentifierLength;
    private bool GenerateSerializableTypes { get; }
    private bool GenerateInternalTypes { get; }
    private bool EnableDataBinding { get; }
    private CodeDomProvider CodeProvider { get; }
    private bool SupportsDeclareEvents { get; }
    private bool SupportsDeclareValueTypes { get; }
    private bool SupportsGenericTypeReference { get; }
    private bool SupportsAssemblyAttributes { get; }
    private bool SupportsPartialTypes { get; }
    private bool SupportsNestedTypes { get; }
    private string FileExtension { get; }
    private Dictionary`2<string, string> Namespaces { get; }
    private Dictionary`2<string, string> ClrNamespaces { get; }
    private XmlQualifiedName GenericListName { get; }
    private CollectionDataContract GenericListContract { get; }
    private XmlQualifiedName GenericDictionaryName { get; }
    private CollectionDataContract GenericDictionaryContract { get; }
    private CodeTypeReference CodeTypeIPropertyChange { get; }
    private CodeThisReferenceExpression ThisReference { get; }
    private CodePrimitiveExpression NullReference { get; }
    private CodeParameterDeclarationExpression SerializationInfoParameter { get; }
    private CodeParameterDeclarationExpression StreamingContextParameter { get; }
    private CodeAttributeDeclaration SerializableAttribute { get; }
    private CodeMemberProperty NodeArrayProperty { get; }
    private CodeMemberField NodeArrayField { get; }
    private CodeMemberMethod ReadXmlMethod { get; }
    private CodeMemberMethod WriteXmlMethod { get; }
    private CodeMemberMethod GetSchemaMethod { get; }
    private CodeMemberMethod GetSchemaStaticMethod { get; }
    private CodeConstructor ISerializableBaseConstructor { get; }
    private CodeConstructor ISerializableDerivedConstructor { get; }
    private CodeMemberField SerializationInfoField { get; }
    private CodeMemberProperty SerializationInfoProperty { get; }
    private CodeMemberMethod GetObjectDataMethod { get; }
    private CodeMemberField ExtensionDataObjectField { get; }
    private CodeMemberProperty ExtensionDataObjectProperty { get; }
    private CodeMemberMethod RaisePropertyChangedEventMethod { get; }
    private CodeMemberEvent PropertyChangedEvent { get; }
    internal CodeExporter(DataContractSet dataContractSet, ImportOptions options, CodeCompileUnit codeCompileUnit);
    private static CodeExporter();
    private void AddReferencedAssembly(Assembly assembly);
    private bool get_GenerateSerializableTypes();
    private bool get_GenerateInternalTypes();
    private bool get_EnableDataBinding();
    private CodeDomProvider get_CodeProvider();
    [SecuritySafeCriticalAttribute]
private bool get_SupportsDeclareEvents();
    [SecuritySafeCriticalAttribute]
private bool get_SupportsDeclareValueTypes();
    [SecuritySafeCriticalAttribute]
private bool get_SupportsGenericTypeReference();
    [SecuritySafeCriticalAttribute]
private bool get_SupportsAssemblyAttributes();
    [SecuritySafeCriticalAttribute]
private bool get_SupportsPartialTypes();
    [SecuritySafeCriticalAttribute]
private bool get_SupportsNestedTypes();
    [SecuritySafeCriticalAttribute]
private string get_FileExtension();
    private Dictionary`2<string, string> get_Namespaces();
    private Dictionary`2<string, string> get_ClrNamespaces();
    private bool TryGetReferencedType(XmlQualifiedName stableName, DataContract dataContract, Type& type);
    [SecurityCriticalAttribute]
internal void Export();
    private void ExportClassDataContractHierarchy(XmlQualifiedName typeName, ClassDataContract classContract, ContractCodeDomInfo contractCodeDomInfo, Dictionary`2<XmlQualifiedName, object> contractNamesInHierarchy);
    private void InvokeProcessImportedType(CollectionBase collection);
    internal CodeTypeReference GetCodeTypeReference(DataContract dataContract);
    private CodeTypeReference GetCodeTypeReference(Type type);
    internal CodeTypeReference GetElementTypeReference(DataContract dataContract, bool isElementTypeNullable);
    private XmlQualifiedName get_GenericListName();
    private CollectionDataContract get_GenericListContract();
    private XmlQualifiedName get_GenericDictionaryName();
    private CollectionDataContract get_GenericDictionaryContract();
    private ContractCodeDomInfo GetContractCodeDomInfo(DataContract dataContract);
    private void GenerateType(DataContract dataContract, ContractCodeDomInfo contractCodeDomInfo);
    private CodeTypeDeclaration GetNestedType(DataContract dataContract, ContractCodeDomInfo contractCodeDomInfo);
    private static CodeTypeDeclaration CreateTypeDeclaration(string typeName, DataContract dataContract);
    [SecuritySafeCriticalAttribute]
private CodeTypeReference GetReferencedType(DataContract dataContract);
    private CodeTypeReference GetReferencedCollectionType(CollectionDataContract collectionContract);
    private bool HasDefaultCollectionNames(CollectionDataContract collectionContract);
    private bool TryGetReferencedDictionaryType(CollectionDataContract collectionContract, CodeTypeReference& typeReference);
    private bool TryGetReferencedListType(DataContract itemContract, bool isItemTypeNullable, CodeTypeReference& typeReference);
    private CodeTypeReference GetSurrogatedTypeReference(DataContract dataContract);
    private CodeTypeReference GetReferencedGenericType(GenericInfo genInfo, DataContract& dataContract);
    private bool NamespaceContainsType(CodeNamespace ns, string typeName);
    private bool GlobalTypeNameConflicts(string clrNamespace, string typeName);
    private void AddGlobalTypeName(string typeName);
    private bool TypeContainsNestedType(CodeTypeDeclaration containingType, string typeName);
    private string GetNameForAttribute(string name);
    private void AddSerializableAttribute(bool generateSerializable, CodeTypeDeclaration type, ContractCodeDomInfo contractCodeDomInfo);
    private void ExportClassDataContract(ClassDataContract classDataContract, ContractCodeDomInfo contractCodeDomInfo);
    private bool CanDeclareAssemblyAttribute(ContractCodeDomInfo contractCodeDomInfo);
    private bool NeedsExplicitNamespace(string dataContractNamespace, string clrNamespace);
    internal ICollection`1<CodeTypeReference> GetKnownTypeReferences(DataContract dataContract);
    private Dictionary`2<XmlQualifiedName, DataContract> GetKnownTypeContracts(DataContract dataContract);
    private Dictionary`2<XmlQualifiedName, DataContract> GetKnownTypeContracts(ClassDataContract dataContract, Dictionary`2<DataContract, object> handledContracts);
    [SecuritySafeCriticalAttribute]
private void AddKnownTypeContracts(ClassDataContract dataContract, Dictionary`2<XmlQualifiedName, DataContract> knownContracts);
    private void AddKnownTypes(ClassDataContract dataContract, ContractCodeDomInfo contractCodeDomInfo);
    private CodeTypeReference WrapNullable(CodeTypeReference memberType);
    private void AddExtensionData(ContractCodeDomInfo contractCodeDomInfo);
    private void AddPropertyChangedNotifier(ContractCodeDomInfo contractCodeDomInfo, bool isValueType);
    private void ThrowIfReferencedBaseTypeSealed(Type baseType, DataContract dataContract);
    private void ExportEnumDataContract(EnumDataContract enumDataContract, ContractCodeDomInfo contractCodeDomInfo);
    private void ExportISerializableDataContract(ClassDataContract dataContract, ContractCodeDomInfo contractCodeDomInfo);
    private void GenerateKeyValueType(ClassDataContract keyValueContract);
    private void ExportCollectionDataContract(CollectionDataContract collectionContract, ContractCodeDomInfo contractCodeDomInfo);
    private void ExportXmlDataContract(XmlDataContract xmlDataContract, ContractCodeDomInfo contractCodeDomInfo);
    private CodeNamespace GetCodeNamespace(string clrNamespace, string dataContractNamespace, ContractCodeDomInfo contractCodeDomInfo);
    private string GetMemberName(string memberName, ContractCodeDomInfo contractCodeDomInfo);
    private void AddBaseMemberNames(ContractCodeDomInfo baseContractCodeDomInfo, ContractCodeDomInfo contractCodeDomInfo);
    [SecuritySafeCriticalAttribute]
private static string GetClrIdentifier(string identifier, string defaultIdentifier);
    private static string AppendToValidClrIdentifier(string identifier, string appendString);
    private string GetClrNamespace(DataContract dataContract, ContractCodeDomInfo contractCodeDomInfo);
    private void AddNamespacePair(string dataContractNamespace, string clrNamespace);
    private void AddImportStatement(string clrNamespace, CodeNamespace codeNamespace);
    private static string GetClrNamespace(string dataContractNamespace);
    private static void AddToNamespace(StringBuilder builder, string fragment, Dictionary`2<string, object> fragments);
    private static void AddNamespaceFragment(StringBuilder builder, int fragmentOffset, int fragmentLength, Dictionary`2<string, object> fragments);
    private static bool IsValidStart(char c);
    private static bool IsValid(char c);
    private CodeTypeReference get_CodeTypeIPropertyChange();
    private CodeThisReferenceExpression get_ThisReference();
    private CodePrimitiveExpression get_NullReference();
    private CodeParameterDeclarationExpression get_SerializationInfoParameter();
    private CodeParameterDeclarationExpression get_StreamingContextParameter();
    private CodeAttributeDeclaration get_SerializableAttribute();
    private CodeMemberProperty get_NodeArrayProperty();
    private CodeMemberField get_NodeArrayField();
    private CodeMemberMethod get_ReadXmlMethod();
    private CodeMemberMethod get_WriteXmlMethod();
    private CodeMemberMethod get_GetSchemaMethod();
    private CodeMemberMethod get_GetSchemaStaticMethod();
    private CodeConstructor get_ISerializableBaseConstructor();
    private CodeConstructor get_ISerializableDerivedConstructor();
    private CodeMemberField get_SerializationInfoField();
    private CodeMemberProperty get_SerializationInfoProperty();
    private CodeMemberMethod get_GetObjectDataMethod();
    private CodeMemberField get_ExtensionDataObjectField();
    private CodeMemberProperty get_ExtensionDataObjectProperty();
    private CodeMemberMethod get_RaisePropertyChangedEventMethod();
    private CodeMemberEvent get_PropertyChangedEvent();
    private CodeMemberProperty CreateProperty(CodeTypeReference type, string propertyName, string fieldName, bool isValueType);
    private CodeMemberProperty CreateProperty(CodeTypeReference type, string propertyName, string fieldName, bool isValueType, bool raisePropertyChanged);
}
internal static class System.Runtime.Serialization.CodeInterpreter : object {
    internal static object ConvertValue(object arg, Type source, Type target);
    private static bool CanConvert(TypeCode typeCode);
    private static object InternalConvert(object arg, Type source, Type target, bool isAddress);
    public static object GetMember(MemberInfo memberInfo, object instance);
    public static void SetMember(MemberInfo memberInfo, object instance, object value);
}
internal class System.Runtime.Serialization.CollectionDataContract : DataContract {
    [SecurityCriticalAttribute]
private XmlDictionaryString collectionItemName;
    [SecurityCriticalAttribute]
private XmlDictionaryString childElementNamespace;
    [SecurityCriticalAttribute]
private DataContract itemContract;
    [SecurityCriticalAttribute]
private CollectionDataContractCriticalHelper helper;
    private static Type[] KnownInterfaces { get; }
    internal CollectionKind Kind { get; }
    internal Type ItemType { get; }
    public DataContract ItemContract { get; public set; }
    internal DataContract SharedTypeContract { get; }
    internal string ItemName { get; internal set; }
    public XmlDictionaryString CollectionItemName { get; }
    internal string KeyName { get; internal set; }
    internal string ValueName { get; internal set; }
    internal bool IsDictionary { get; }
    public XmlDictionaryString ChildElementNamespace { get; }
    internal bool IsItemTypeNullable { get; internal set; }
    internal bool IsConstructorCheckRequired { get; internal set; }
    internal MethodInfo GetEnumeratorMethod { get; }
    internal MethodInfo AddMethod { get; }
    internal ConstructorInfo Constructor { get; }
    internal Dictionary`2<XmlQualifiedName, DataContract> KnownDataContracts { get; internal set; }
    internal string InvalidCollectionInSharedContractMessage { get; }
    internal string SerializationExceptionMessage { get; }
    internal string DeserializationExceptionMessage { get; }
    internal bool IsReadOnlyContract { get; }
    private bool ItemNameSetExplicit { get; }
    internal XmlFormatCollectionWriterDelegate XmlFormatWriterDelegate { get; }
    internal XmlFormatCollectionReaderDelegate XmlFormatReaderDelegate { get; }
    internal XmlFormatGetOnlyCollectionReaderDelegate XmlFormatGetOnlyCollectionReaderDelegate { get; }
    [SecuritySafeCriticalAttribute]
internal CollectionDataContract(CollectionKind kind);
    [SecuritySafeCriticalAttribute]
internal CollectionDataContract(Type type);
    [SecuritySafeCriticalAttribute]
internal CollectionDataContract(Type type, DataContract itemContract);
    [SecuritySafeCriticalAttribute]
private CollectionDataContract(Type type, CollectionKind kind, Type itemType, MethodInfo getEnumeratorMethod, string serializationExceptionMessage, string deserializationExceptionMessage);
    [SecuritySafeCriticalAttribute]
private CollectionDataContract(Type type, CollectionKind kind, Type itemType, MethodInfo getEnumeratorMethod, MethodInfo addMethod, ConstructorInfo constructor);
    [SecuritySafeCriticalAttribute]
private CollectionDataContract(Type type, CollectionKind kind, Type itemType, MethodInfo getEnumeratorMethod, MethodInfo addMethod, ConstructorInfo constructor, bool isConstructorCheckRequired);
    [SecuritySafeCriticalAttribute]
private CollectionDataContract(Type type, string invalidCollectionInSharedContractMessage);
    [SecurityCriticalAttribute]
private void InitCollectionDataContract(DataContract sharedTypeContract);
    private void InitSharedTypeContract();
    [SecuritySafeCriticalAttribute]
private static Type[] get_KnownInterfaces();
    [SecuritySafeCriticalAttribute]
internal CollectionKind get_Kind();
    [SecuritySafeCriticalAttribute]
internal Type get_ItemType();
    [SecuritySafeCriticalAttribute]
public DataContract get_ItemContract();
    [SecurityCriticalAttribute]
public void set_ItemContract(DataContract value);
    [SecuritySafeCriticalAttribute]
internal DataContract get_SharedTypeContract();
    [SecuritySafeCriticalAttribute]
internal string get_ItemName();
    [SecurityCriticalAttribute]
internal void set_ItemName(string value);
    [SecuritySafeCriticalAttribute]
public XmlDictionaryString get_CollectionItemName();
    [SecuritySafeCriticalAttribute]
internal string get_KeyName();
    [SecurityCriticalAttribute]
internal void set_KeyName(string value);
    [SecuritySafeCriticalAttribute]
internal string get_ValueName();
    [SecurityCriticalAttribute]
internal void set_ValueName(string value);
    internal bool get_IsDictionary();
    [SecuritySafeCriticalAttribute]
public XmlDictionaryString get_ChildElementNamespace();
    [SecuritySafeCriticalAttribute]
internal bool get_IsItemTypeNullable();
    [SecurityCriticalAttribute]
internal void set_IsItemTypeNullable(bool value);
    [SecuritySafeCriticalAttribute]
internal bool get_IsConstructorCheckRequired();
    [SecurityCriticalAttribute]
internal void set_IsConstructorCheckRequired(bool value);
    [SecuritySafeCriticalAttribute]
internal MethodInfo get_GetEnumeratorMethod();
    [SecuritySafeCriticalAttribute]
internal MethodInfo get_AddMethod();
    [SecuritySafeCriticalAttribute]
internal ConstructorInfo get_Constructor();
    [SecuritySafeCriticalAttribute]
internal virtual Dictionary`2<XmlQualifiedName, DataContract> get_KnownDataContracts();
    [SecurityCriticalAttribute]
internal virtual void set_KnownDataContracts(Dictionary`2<XmlQualifiedName, DataContract> value);
    [SecuritySafeCriticalAttribute]
internal string get_InvalidCollectionInSharedContractMessage();
    [SecuritySafeCriticalAttribute]
internal string get_SerializationExceptionMessage();
    [SecuritySafeCriticalAttribute]
internal string get_DeserializationExceptionMessage();
    internal bool get_IsReadOnlyContract();
    [SecuritySafeCriticalAttribute]
private bool get_ItemNameSetExplicit();
    [SecuritySafeCriticalAttribute]
internal XmlFormatCollectionWriterDelegate get_XmlFormatWriterDelegate();
    [SecuritySafeCriticalAttribute]
internal XmlFormatCollectionReaderDelegate get_XmlFormatReaderDelegate();
    [SecuritySafeCriticalAttribute]
internal XmlFormatGetOnlyCollectionReaderDelegate get_XmlFormatGetOnlyCollectionReaderDelegate();
    private DataContract GetSharedTypeContract(Type type);
    internal static bool IsCollectionInterface(Type type);
    internal static bool IsCollection(Type type);
    internal static bool IsCollection(Type type, Type& itemType);
    internal static bool IsCollection(Type type, bool constructorRequired, bool skipIfReadOnlyContract);
    private static bool IsCollectionHelper(Type type, Type& itemType, bool constructorRequired, bool skipIfReadOnlyContract);
    internal static bool TryCreate(Type type, DataContract& dataContract);
    internal static bool TryCreateGetOnlyCollectionDataContract(Type type, DataContract& dataContract);
    internal static MethodInfo GetTargetMethodWithName(string name, Type type, Type interfaceType);
    private static bool IsArraySegment(Type t);
    private static bool IsCollectionOrTryCreate(Type type, bool tryCreate, DataContract& dataContract, Type& itemType, bool constructorRequired, bool skipIfReadOnlyContract);
    internal static bool IsCollectionDataContract(Type type);
    private static bool HandleIfInvalidCollection(Type type, bool tryCreate, bool hasCollectionDataContract, bool createContractWithException, string message, string param, DataContract& dataContract);
    private static void GetReadOnlyCollectionExceptionMessages(Type type, bool hasCollectionDataContract, string message, string param, String& serializationExceptionMessage, String& deserializationExceptionMessage);
    private static string GetInvalidCollectionMessage(string message, string nestedMessage, string param);
    private static void FindCollectionMethodsOnInterface(Type type, Type interfaceType, MethodInfo& addMethod, MethodInfo& getEnumeratorMethod);
    private static void GetCollectionMethods(Type type, Type interfaceType, Type[] addMethodTypeArray, bool addMethodOnInterface, MethodInfo& getEnumeratorMethod, MethodInfo& addMethod);
    private static bool IsKnownInterface(Type type);
    [SecuritySafeCriticalAttribute]
internal virtual DataContract BindGenericParameters(DataContract[] paramContracts, Dictionary`2<DataContract, DataContract> boundContracts);
    internal virtual DataContract GetValidContract(SerializationMode mode);
    private void ThrowIfInvalid();
    internal virtual DataContract GetValidContract();
    [SecuritySafeCriticalAttribute]
private void CheckConstructor();
    internal virtual bool IsValidContract(SerializationMode mode);
    internal virtual bool Equals(object other, Dictionary`2<DataContractPairKey, object> checkedContracts);
    public virtual int GetHashCode();
    public virtual void WriteXmlValue(XmlWriterDelegator xmlWriter, object obj, XmlObjectSerializerWriteContext context);
    public virtual object ReadXmlValue(XmlReaderDelegator xmlReader, XmlObjectSerializerReadContext context);
}
[AttributeUsageAttribute("12")]
public class System.Runtime.Serialization.CollectionDataContractAttribute : Attribute {
    private string name;
    private string ns;
    private string itemName;
    private string keyName;
    private string valueName;
    private bool isReference;
    private bool isNameSetExplicitly;
    private bool isNamespaceSetExplicitly;
    private bool isReferenceSetExplicitly;
    private bool isItemNameSetExplicitly;
    private bool isKeyNameSetExplicitly;
    private bool isValueNameSetExplicitly;
    public string Namespace { get; public set; }
    public bool IsNamespaceSetExplicitly { get; }
    public string Name { get; public set; }
    public bool IsNameSetExplicitly { get; }
    public string ItemName { get; public set; }
    public bool IsItemNameSetExplicitly { get; }
    public string KeyName { get; public set; }
    public bool IsReference { get; public set; }
    public bool IsReferenceSetExplicitly { get; }
    public bool IsKeyNameSetExplicitly { get; }
    public string ValueName { get; public set; }
    public bool IsValueNameSetExplicitly { get; }
    public string get_Namespace();
    public void set_Namespace(string value);
    public bool get_IsNamespaceSetExplicitly();
    public string get_Name();
    public void set_Name(string value);
    public bool get_IsNameSetExplicitly();
    public string get_ItemName();
    public void set_ItemName(string value);
    public bool get_IsItemNameSetExplicitly();
    public string get_KeyName();
    public void set_KeyName(string value);
    public bool get_IsReference();
    public void set_IsReference(bool value);
    public bool get_IsReferenceSetExplicitly();
    public bool get_IsKeyNameSetExplicitly();
    public string get_ValueName();
    public void set_ValueName(string value);
    public bool get_IsValueNameSetExplicitly();
}
internal class System.Runtime.Serialization.CollectionDataNode : DataNode`1<Array> {
    private IList`1<IDataNode> items;
    private string itemName;
    private string itemNamespace;
    private int size;
    internal IList`1<IDataNode> Items { get; internal set; }
    internal string ItemName { get; internal set; }
    internal string ItemNamespace { get; internal set; }
    internal int Size { get; internal set; }
    internal IList`1<IDataNode> get_Items();
    internal void set_Items(IList`1<IDataNode> value);
    internal string get_ItemName();
    internal void set_ItemName(string value);
    internal string get_ItemNamespace();
    internal void set_ItemNamespace(string value);
    internal int get_Size();
    internal void set_Size(int value);
    public virtual void GetData(ElementData element);
    public virtual void Clear();
}
internal enum System.Runtime.Serialization.CollectionKind : Enum {
    public byte value__;
    public static CollectionKind None;
    public static CollectionKind GenericDictionary;
    public static CollectionKind Dictionary;
    public static CollectionKind GenericList;
    public static CollectionKind GenericCollection;
    public static CollectionKind List;
    public static CollectionKind GenericEnumerable;
    public static CollectionKind Collection;
    public static CollectionKind Enumerable;
    public static CollectionKind Array;
}
internal static class System.Runtime.Serialization.Configuration.ConfigurationStrings : object {
    internal static string SectionGroupName;
    internal static string DefaultCollectionName;
    internal static string DeclaredTypes;
    internal static string Index;
    internal static string Parameter;
    internal static string Type;
    internal static string EnableUnsafeTypeForwarding;
    internal static string DataContractSerializerSectionName;
    internal static string NetDataContractSerializerSectionName;
    internal static string DataContractSerializerSectionPath { get; }
    internal static string NetDataContractSerializerSectionPath { get; }
    private static string GetSectionPath(string sectionName);
    internal static string get_DataContractSerializerSectionPath();
    internal static string get_NetDataContractSerializerSectionPath();
}
public class System.Runtime.Serialization.Configuration.DataContractSerializerSection : ConfigurationSection {
    private ConfigurationPropertyCollection properties;
    [ConfigurationPropertyAttribute("declaredTypes")]
public DeclaredTypeElementCollection DeclaredTypes { get; }
    protected ConfigurationPropertyCollection Properties { get; }
    [SecurityCriticalAttribute]
internal static DataContractSerializerSection UnsafeGetSection();
    public DeclaredTypeElementCollection get_DeclaredTypes();
    protected virtual ConfigurationPropertyCollection get_Properties();
}
public class System.Runtime.Serialization.Configuration.DeclaredTypeElement : ConfigurationElement {
    private ConfigurationPropertyCollection properties;
    [ConfigurationPropertyAttribute("")]
public TypeElementCollection KnownTypes { get; }
    [ConfigurationPropertyAttribute("type")]
[DeclaredTypeValidatorAttribute]
public string Type { get; public set; }
    protected ConfigurationPropertyCollection Properties { get; }
    public DeclaredTypeElement(string typeName);
    public TypeElementCollection get_KnownTypes();
    public string get_Type();
    public void set_Type(string value);
    [SecuritySafeCriticalAttribute]
protected virtual void PostDeserialize();
    protected virtual ConfigurationPropertyCollection get_Properties();
}
[DefaultMemberAttribute("Item")]
[ConfigurationCollectionAttribute("System.Runtime.Serialization.Configuration.DeclaredTypeElement")]
public class System.Runtime.Serialization.Configuration.DeclaredTypeElementCollection : ConfigurationElementCollection {
    public DeclaredTypeElement Item { get; public set; }
    public DeclaredTypeElement Item { get; public set; }
    public DeclaredTypeElement get_Item(int index);
    public void set_Item(int index, DeclaredTypeElement value);
    public DeclaredTypeElement get_Item(string typeName);
    public void set_Item(string typeName, DeclaredTypeElement value);
    public void Add(DeclaredTypeElement element);
    public void Clear();
    public bool Contains(string typeName);
    protected virtual ConfigurationElement CreateNewElement();
    protected virtual object GetElementKey(ConfigurationElement element);
    public int IndexOf(DeclaredTypeElement element);
    public void Remove(DeclaredTypeElement element);
    public void Remove(string typeName);
    public void RemoveAt(int index);
}
internal class System.Runtime.Serialization.Configuration.DeclaredTypeValidator : ConfigurationValidatorBase {
    public virtual bool CanValidate(Type type);
    public virtual void Validate(object value);
}
[AttributeUsageAttribute("128")]
internal class System.Runtime.Serialization.Configuration.DeclaredTypeValidatorAttribute : ConfigurationValidatorAttribute {
    public ConfigurationValidatorBase ValidatorInstance { get; }
    public virtual ConfigurationValidatorBase get_ValidatorInstance();
}
public class System.Runtime.Serialization.Configuration.NetDataContractSerializerSection : ConfigurationSection {
    private ConfigurationPropertyCollection properties;
    [ConfigurationPropertyAttribute("enableUnsafeTypeForwarding")]
public bool EnableUnsafeTypeForwarding { get; }
    protected ConfigurationPropertyCollection Properties { get; }
    [SecurityCriticalAttribute]
internal static bool TryUnsafeGetSection(NetDataContractSerializerSection& section);
    public bool get_EnableUnsafeTypeForwarding();
    protected virtual ConfigurationPropertyCollection get_Properties();
}
public class System.Runtime.Serialization.Configuration.ParameterElement : ConfigurationElement {
    internal Guid identity;
    private ConfigurationPropertyCollection properties;
    [ConfigurationPropertyAttribute("index")]
[IntegerValidatorAttribute]
public int Index { get; public set; }
    [ConfigurationPropertyAttribute("")]
public ParameterElementCollection Parameters { get; }
    [ConfigurationPropertyAttribute("type")]
[StringValidatorAttribute]
public string Type { get; public set; }
    protected ConfigurationPropertyCollection Properties { get; }
    public ParameterElement(string typeName);
    public ParameterElement(int index);
    public int get_Index();
    public void set_Index(int value);
    public ParameterElementCollection get_Parameters();
    protected virtual void PostDeserialize();
    protected virtual void PreSerialize(XmlWriter writer);
    public string get_Type();
    public void set_Type(string value);
    private void Validate();
    internal Type GetType(string rootType, Type[] typeArgs);
    protected virtual ConfigurationPropertyCollection get_Properties();
}
[DefaultMemberAttribute("Item")]
[ConfigurationCollectionAttribute("System.Runtime.Serialization.Configuration.ParameterElement")]
public class System.Runtime.Serialization.Configuration.ParameterElementCollection : ConfigurationElementCollection {
    public ParameterElement Item { get; public set; }
    public ConfigurationElementCollectionType CollectionType { get; }
    protected string ElementName { get; }
    public ParameterElement get_Item(int index);
    public void set_Item(int index, ParameterElement value);
    public void Add(ParameterElement element);
    public void Clear();
    public virtual ConfigurationElementCollectionType get_CollectionType();
    public bool Contains(string typeName);
    protected virtual ConfigurationElement CreateNewElement();
    protected virtual string get_ElementName();
    protected virtual object GetElementKey(ConfigurationElement element);
    public int IndexOf(ParameterElement element);
    public void Remove(ParameterElement element);
    public void RemoveAt(int index);
}
public class System.Runtime.Serialization.Configuration.SerializationSectionGroup : ConfigurationSectionGroup {
    public DataContractSerializerSection DataContractSerializer { get; }
    public NetDataContractSerializerSection NetDataContractSerializer { get; }
    public static SerializationSectionGroup GetSectionGroup(Configuration config);
    public DataContractSerializerSection get_DataContractSerializer();
    public NetDataContractSerializerSection get_NetDataContractSerializer();
}
public class System.Runtime.Serialization.Configuration.TypeElement : ConfigurationElement {
    private ConfigurationPropertyCollection properties;
    private string key;
    protected ConfigurationPropertyCollection Properties { get; }
    internal string Key { get; }
    [ConfigurationPropertyAttribute("")]
public ParameterElementCollection Parameters { get; }
    [ConfigurationPropertyAttribute("type")]
[StringValidatorAttribute]
public string Type { get; public set; }
    [ConfigurationPropertyAttribute("index")]
[IntegerValidatorAttribute]
public int Index { get; public set; }
    public TypeElement(string typeName);
    protected virtual ConfigurationPropertyCollection get_Properties();
    internal string get_Key();
    public ParameterElementCollection get_Parameters();
    protected virtual void Reset(ConfigurationElement parentElement);
    public string get_Type();
    public void set_Type(string value);
    public int get_Index();
    public void set_Index(int value);
    internal Type GetType(string rootType, Type[] typeArgs);
    internal static Type GetType(string rootType, Type[] typeArgs, string type, int index, ParameterElementCollection parameters);
}
[ConfigurationCollectionAttribute("System.Runtime.Serialization.Configuration.TypeElement")]
[DefaultMemberAttribute("Item")]
public class System.Runtime.Serialization.Configuration.TypeElementCollection : ConfigurationElementCollection {
    private static string KnownTypeConfig;
    public TypeElement Item { get; public set; }
    public ConfigurationElementCollectionType CollectionType { get; }
    protected string ElementName { get; }
    public TypeElement get_Item(int index);
    public void set_Item(int index, TypeElement value);
    public void Add(TypeElement element);
    public void Clear();
    public virtual ConfigurationElementCollectionType get_CollectionType();
    protected virtual ConfigurationElement CreateNewElement();
    protected virtual string get_ElementName();
    protected virtual object GetElementKey(ConfigurationElement element);
    public int IndexOf(TypeElement element);
    public void Remove(TypeElement element);
    public void RemoveAt(int index);
}
internal class System.Runtime.Serialization.ContractCodeDomInfo : object {
    internal bool IsProcessed;
    internal CodeTypeDeclaration TypeDeclaration;
    internal CodeTypeReference TypeReference;
    internal CodeNamespace CodeNamespace;
    internal bool ReferencedTypeExists;
    internal bool UsesWildcardNamespace;
    private string clrNamespace;
    private Dictionary`2<string, object> memberNames;
    internal string ClrNamespace { get; internal set; }
    internal string get_ClrNamespace();
    internal void set_ClrNamespace(string value);
    internal Dictionary`2<string, object> GetMemberNames();
}
[AttributeUsageAttribute("3")]
public class System.Runtime.Serialization.ContractNamespaceAttribute : Attribute {
    private string clrNamespace;
    private string contractNamespace;
    public string ClrNamespace { get; public set; }
    public string ContractNamespace { get; }
    public ContractNamespaceAttribute(string contractNamespace);
    public string get_ClrNamespace();
    public void set_ClrNamespace(string value);
    public string get_ContractNamespace();
}
internal class System.Runtime.Serialization.CreateXmlSerializableDelegate : MulticastDelegate {
    public CreateXmlSerializableDelegate(object object, IntPtr method);
    public virtual IXmlSerializable Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual IXmlSerializable EndInvoke(IAsyncResult result);
}
internal abstract class System.Runtime.Serialization.DataContract : object {
    [SecurityCriticalAttribute]
private XmlDictionaryString name;
    [SecurityCriticalAttribute]
private XmlDictionaryString ns;
    [SecurityCriticalAttribute]
private DataContractCriticalHelper helper;
    [SecurityCriticalAttribute]
private static DataContractSerializerSection configSection;
    protected DataContractCriticalHelper Helper { get; }
    internal Type UnderlyingType { get; }
    internal Type OriginalUnderlyingType { get; }
    internal bool IsBuiltInDataContract { get; }
    internal Type TypeForInitialization { get; }
    internal bool IsValueType { get; internal set; }
    internal bool IsReference { get; internal set; }
    internal XmlQualifiedName StableName { get; internal set; }
    internal GenericInfo GenericInfo { get; internal set; }
    internal Dictionary`2<XmlQualifiedName, DataContract> KnownDataContracts { get; internal set; }
    internal bool IsISerializable { get; internal set; }
    internal XmlDictionaryString Name { get; }
    public XmlDictionaryString Namespace { get; }
    internal bool HasRoot { get; internal set; }
    internal XmlDictionaryString TopLevelElementName { get; internal set; }
    internal XmlDictionaryString TopLevelElementNamespace { get; internal set; }
    internal bool CanContainReferences { get; }
    internal bool IsPrimitive { get; }
    internal MethodInfo ParseMethod { get; }
    private static DataContractSerializerSection ConfigSection { get; }
    [SecuritySafeCriticalAttribute]
protected DataContract(DataContractCriticalHelper helper);
    internal static DataContract GetDataContract(Type type);
    internal static DataContract GetDataContract(RuntimeTypeHandle typeHandle, Type type, SerializationMode mode);
    internal static DataContract GetDataContract(int id, RuntimeTypeHandle typeHandle, SerializationMode mode);
    [SecuritySafeCriticalAttribute]
internal static DataContract GetDataContractSkipValidation(int id, RuntimeTypeHandle typeHandle, Type type);
    internal static DataContract GetGetOnlyCollectionDataContract(int id, RuntimeTypeHandle typeHandle, Type type, SerializationMode mode);
    [SecuritySafeCriticalAttribute]
internal static DataContract GetGetOnlyCollectionDataContractSkipValidation(int id, RuntimeTypeHandle typeHandle, Type type);
    [SecuritySafeCriticalAttribute]
internal static DataContract GetDataContractForInitialization(int id);
    [SecuritySafeCriticalAttribute]
internal static int GetIdForInitialization(ClassDataContract classContract);
    [SecuritySafeCriticalAttribute]
internal static int GetId(RuntimeTypeHandle typeHandle);
    [SecuritySafeCriticalAttribute]
public static DataContract GetBuiltInDataContract(Type type);
    [SecuritySafeCriticalAttribute]
public static DataContract GetBuiltInDataContract(string name, string ns);
    [SecuritySafeCriticalAttribute]
public static DataContract GetBuiltInDataContract(string typeName);
    [SecuritySafeCriticalAttribute]
internal static string GetNamespace(string key);
    [SecuritySafeCriticalAttribute]
internal static XmlDictionaryString GetClrTypeString(string key);
    [SecuritySafeCriticalAttribute]
internal static void ThrowInvalidDataContractException(string message, Type type);
    [SecurityCriticalAttribute]
protected DataContractCriticalHelper get_Helper();
    [SecuritySafeCriticalAttribute]
internal Type get_UnderlyingType();
    [SecuritySafeCriticalAttribute]
internal Type get_OriginalUnderlyingType();
    [SecuritySafeCriticalAttribute]
internal virtual bool get_IsBuiltInDataContract();
    [SecuritySafeCriticalAttribute]
internal Type get_TypeForInitialization();
    public virtual void WriteXmlValue(XmlWriterDelegator xmlWriter, object obj, XmlObjectSerializerWriteContext context);
    public virtual object ReadXmlValue(XmlReaderDelegator xmlReader, XmlObjectSerializerReadContext context);
    [SecuritySafeCriticalAttribute]
internal bool get_IsValueType();
    [SecurityCriticalAttribute]
internal void set_IsValueType(bool value);
    [SecuritySafeCriticalAttribute]
internal bool get_IsReference();
    [SecurityCriticalAttribute]
internal void set_IsReference(bool value);
    [SecuritySafeCriticalAttribute]
internal XmlQualifiedName get_StableName();
    [SecurityCriticalAttribute]
internal void set_StableName(XmlQualifiedName value);
    [SecuritySafeCriticalAttribute]
internal GenericInfo get_GenericInfo();
    [SecurityCriticalAttribute]
internal void set_GenericInfo(GenericInfo value);
    [SecuritySafeCriticalAttribute]
internal virtual Dictionary`2<XmlQualifiedName, DataContract> get_KnownDataContracts();
    [SecurityCriticalAttribute]
internal virtual void set_KnownDataContracts(Dictionary`2<XmlQualifiedName, DataContract> value);
    [SecuritySafeCriticalAttribute]
internal virtual bool get_IsISerializable();
    [SecurityCriticalAttribute]
internal virtual void set_IsISerializable(bool value);
    [SecuritySafeCriticalAttribute]
internal XmlDictionaryString get_Name();
    [SecuritySafeCriticalAttribute]
public virtual XmlDictionaryString get_Namespace();
    internal virtual bool get_HasRoot();
    internal virtual void set_HasRoot(bool value);
    [SecuritySafeCriticalAttribute]
internal virtual XmlDictionaryString get_TopLevelElementName();
    [SecurityCriticalAttribute]
internal virtual void set_TopLevelElementName(XmlDictionaryString value);
    [SecuritySafeCriticalAttribute]
internal virtual XmlDictionaryString get_TopLevelElementNamespace();
    [SecurityCriticalAttribute]
internal virtual void set_TopLevelElementNamespace(XmlDictionaryString value);
    internal virtual bool get_CanContainReferences();
    internal virtual bool get_IsPrimitive();
    internal virtual void WriteRootElement(XmlWriterDelegator writer, XmlDictionaryString name, XmlDictionaryString ns);
    internal virtual DataContract BindGenericParameters(DataContract[] paramContracts, Dictionary`2<DataContract, DataContract> boundContracts);
    internal virtual DataContract GetValidContract(SerializationMode mode);
    internal virtual DataContract GetValidContract();
    internal virtual bool IsValidContract(SerializationMode mode);
    [SecuritySafeCriticalAttribute]
internal MethodInfo get_ParseMethod();
    internal static bool IsTypeSerializable(Type type);
    private static bool IsTypeSerializable(Type type, Dictionary`2<Type, object> previousCollectionTypes);
    private static void ValidatePreviousCollectionTypes(Type collectionType, Type itemType, Dictionary`2<Type, object> previousCollectionTypes);
    internal static Type UnwrapRedundantNullableType(Type type);
    internal static Type UnwrapNullableType(Type type);
    private static bool IsAlpha(char ch);
    private static bool IsDigit(char ch);
    private static bool IsAsciiLocalName(string localName);
    internal static string EncodeLocalName(string localName);
    internal static bool IsValidNCName(string name);
    internal static XmlQualifiedName GetStableName(Type type);
    internal static XmlQualifiedName GetStableName(Type type, Boolean& hasDataContract);
    private static XmlQualifiedName GetStableName(Type type, Dictionary`2<Type, object> previousCollectionTypes, Boolean& hasDataContract);
    private static XmlQualifiedName GetDCTypeStableName(Type type, DataContractAttribute dataContractAttribute);
    private static XmlQualifiedName GetNonDCTypeStableName(Type type, Dictionary`2<Type, object> previousCollectionTypes);
    private static bool TryGetBuiltInXmlAndArrayTypeStableName(Type type, Dictionary`2<Type, object> previousCollectionTypes, XmlQualifiedName& stableName);
    [SecuritySafeCriticalAttribute]
internal static bool TryGetDCAttribute(Type type, DataContractAttribute& dataContractAttribute);
    internal static XmlQualifiedName GetCollectionStableName(Type type, Type itemType, CollectionDataContractAttribute& collectionContractAttribute);
    private static XmlQualifiedName GetCollectionStableName(Type type, Type itemType, Dictionary`2<Type, object> previousCollectionTypes, CollectionDataContractAttribute& collectionContractAttribute);
    private static string GetArrayPrefix(Type& itemType);
    internal XmlQualifiedName GetArrayTypeName(bool isNullable);
    internal static string GetCollectionNamespace(string elementNs);
    internal static XmlQualifiedName GetDefaultStableName(Type type);
    private static string GetDefaultStableLocalName(Type type);
    private static string GetDefaultDataContractNamespace(Type type);
    internal static IList`1<int> GetDataContractNameForGenericName(string typeName, StringBuilder localName);
    internal static bool IsBuiltInNamespace(string ns);
    internal static string GetDefaultStableNamespace(Type type);
    internal static XmlQualifiedName CreateQualifiedName(string localName, string ns);
    internal static string GetDefaultStableNamespace(string clrNs);
    private static void CheckExplicitDataContractNamespaceUri(string dataContractNs, Type type);
    internal static string GetClrTypeFullName(Type type);
    internal static string GetClrAssemblyName(Type type, Boolean& hasTypeForwardedFrom);
    internal static string GetClrTypeFullNameUsingTypeForwardedFromAttribute(Type type);
    private static string GetClrTypeFullNameForArray(Type type);
    private static string GetClrTypeFullNameForNonArrayTypes(Type type);
    internal static void GetClrNameAndNamespace(string fullTypeName, String& localName, String& ns);
    internal static void GetDefaultStableName(string fullTypeName, String& localName, String& ns);
    private static void GetDefaultStableName(CodeTypeReference typeReference, String& localName, String& ns);
    internal static string GetDataContractNamespaceFromUri(string uriString);
    private static string GetGlobalDataContractNamespace(string clrNs, ICustomAttributeProvider customAttribuetProvider);
    private static string GetNamespacesDigest(string namespaces);
    private static string ExpandGenericParameters(string format, Type type);
    internal static string ExpandGenericParameters(string format, IGenericNameProvider genericNameProvider);
    internal static bool IsTypeNullable(Type type);
    public static void ThrowTypeNotSerializable(Type type);
    [SecurityCriticalAttribute]
private static DataContractSerializerSection get_ConfigSection();
    internal static Dictionary`2<XmlQualifiedName, DataContract> ImportKnownTypeAttributes(Type type);
    private static void ImportKnownTypeAttributes(Type type, Dictionary`2<Type, Type> typesChecked, Dictionary`2& knownDataContracts);
    [SecuritySafeCriticalAttribute]
private static void LoadKnownTypesFromConfig(Type type, Dictionary`2<Type, Type> typesChecked, Dictionary`2& knownDataContracts);
    private static void CheckRootTypeInConfigIsGeneric(Type type, Type& rootType, Type[]& genArgs);
    private static bool IsElemTypeNullOrNotEqualToRootType(string elemTypeName, Type rootType);
    private static bool IsCollectionElementTypeEqualToRootType(string collectionElementTypeName, Type rootType);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal static void CheckAndAdd(Type type, Dictionary`2<Type, Type> typesChecked, Dictionary`2& nameToDataContractTable);
    private static bool IsOpenGenericType(Type t);
    public sealed virtual bool Equals(object other);
    internal virtual bool Equals(object other, Dictionary`2<DataContractPairKey, object> checkedContracts);
    internal bool IsEqualOrChecked(object other, Dictionary`2<DataContractPairKey, object> checkedContracts);
    public virtual int GetHashCode();
    internal void ThrowInvalidDataContractException(string message);
    internal static bool IsTypeVisible(Type t);
}
[AttributeUsageAttribute("28")]
public class System.Runtime.Serialization.DataContractAttribute : Attribute {
    private string name;
    private string ns;
    private bool isNameSetExplicitly;
    private bool isNamespaceSetExplicitly;
    private bool isReference;
    private bool isReferenceSetExplicitly;
    public bool IsReference { get; public set; }
    public bool IsReferenceSetExplicitly { get; }
    public string Namespace { get; public set; }
    public bool IsNamespaceSetExplicitly { get; }
    public string Name { get; public set; }
    public bool IsNameSetExplicitly { get; }
    public bool get_IsReference();
    public void set_IsReference(bool value);
    public bool get_IsReferenceSetExplicitly();
    public string get_Namespace();
    public void set_Namespace(string value);
    public bool get_IsNamespaceSetExplicitly();
    public string get_Name();
    public void set_Name(string value);
    public bool get_IsNameSetExplicitly();
}
internal class System.Runtime.Serialization.DataContractPairKey : object {
    private object object1;
    private object object2;
    public DataContractPairKey(object object1, object object2);
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
}
public abstract class System.Runtime.Serialization.DataContractResolver : object {
    public abstract virtual bool TryResolveType(Type type, Type declaredType, DataContractResolver knownTypeResolver, XmlDictionaryString& typeName, XmlDictionaryString& typeNamespace);
    public abstract virtual Type ResolveName(string typeName, string typeNamespace, Type declaredType, DataContractResolver knownTypeResolver);
}
public class System.Runtime.Serialization.DataContractSerializer : XmlObjectSerializer {
    private Type rootType;
    private DataContract rootContract;
    private bool needsContractNsAtRoot;
    private XmlDictionaryString rootName;
    private XmlDictionaryString rootNamespace;
    private int maxItemsInObjectGraph;
    private bool ignoreExtensionDataObject;
    private bool preserveObjectReferences;
    private IDataContractSurrogate dataContractSurrogate;
    private ReadOnlyCollection`1<Type> knownTypeCollection;
    internal IList`1<Type> knownTypeList;
    internal Dictionary`2<XmlQualifiedName, DataContract> knownDataContracts;
    private DataContractResolver dataContractResolver;
    private bool serializeReadOnlyTypes;
    public ReadOnlyCollection`1<Type> KnownTypes { get; }
    internal Dictionary`2<XmlQualifiedName, DataContract> KnownDataContracts { get; }
    public int MaxItemsInObjectGraph { get; }
    public IDataContractSurrogate DataContractSurrogate { get; }
    public bool PreserveObjectReferences { get; }
    public bool IgnoreExtensionDataObject { get; }
    public DataContractResolver DataContractResolver { get; }
    public bool SerializeReadOnlyTypes { get; }
    private DataContract RootContract { get; }
    public DataContractSerializer(Type type);
    public DataContractSerializer(Type type, IEnumerable`1<Type> knownTypes);
    public DataContractSerializer(Type type, IEnumerable`1<Type> knownTypes, int maxItemsInObjectGraph, bool ignoreExtensionDataObject, bool preserveObjectReferences, IDataContractSurrogate dataContractSurrogate);
    public DataContractSerializer(Type type, IEnumerable`1<Type> knownTypes, int maxItemsInObjectGraph, bool ignoreExtensionDataObject, bool preserveObjectReferences, IDataContractSurrogate dataContractSurrogate, DataContractResolver dataContractResolver);
    public DataContractSerializer(Type type, string rootName, string rootNamespace);
    public DataContractSerializer(Type type, string rootName, string rootNamespace, IEnumerable`1<Type> knownTypes);
    public DataContractSerializer(Type type, string rootName, string rootNamespace, IEnumerable`1<Type> knownTypes, int maxItemsInObjectGraph, bool ignoreExtensionDataObject, bool preserveObjectReferences, IDataContractSurrogate dataContractSurrogate);
    public DataContractSerializer(Type type, string rootName, string rootNamespace, IEnumerable`1<Type> knownTypes, int maxItemsInObjectGraph, bool ignoreExtensionDataObject, bool preserveObjectReferences, IDataContractSurrogate dataContractSurrogate, DataContractResolver dataContractResolver);
    public DataContractSerializer(Type type, XmlDictionaryString rootName, XmlDictionaryString rootNamespace);
    public DataContractSerializer(Type type, XmlDictionaryString rootName, XmlDictionaryString rootNamespace, IEnumerable`1<Type> knownTypes);
    public DataContractSerializer(Type type, XmlDictionaryString rootName, XmlDictionaryString rootNamespace, IEnumerable`1<Type> knownTypes, int maxItemsInObjectGraph, bool ignoreExtensionDataObject, bool preserveObjectReferences, IDataContractSurrogate dataContractSurrogate);
    public DataContractSerializer(Type type, XmlDictionaryString rootName, XmlDictionaryString rootNamespace, IEnumerable`1<Type> knownTypes, int maxItemsInObjectGraph, bool ignoreExtensionDataObject, bool preserveObjectReferences, IDataContractSurrogate dataContractSurrogate, DataContractResolver dataContractResolver);
    public DataContractSerializer(Type type, DataContractSerializerSettings settings);
    private void Initialize(Type type, IEnumerable`1<Type> knownTypes, int maxItemsInObjectGraph, bool ignoreExtensionDataObject, bool preserveObjectReferences, IDataContractSurrogate dataContractSurrogate, DataContractResolver dataContractResolver, bool serializeReadOnlyTypes);
    private void Initialize(Type type, XmlDictionaryString rootName, XmlDictionaryString rootNamespace, IEnumerable`1<Type> knownTypes, int maxItemsInObjectGraph, bool ignoreExtensionDataObject, bool preserveObjectReferences, IDataContractSurrogate dataContractSurrogate, DataContractResolver dataContractResolver, bool serializeReadOnlyTypes);
    public ReadOnlyCollection`1<Type> get_KnownTypes();
    internal virtual Dictionary`2<XmlQualifiedName, DataContract> get_KnownDataContracts();
    public int get_MaxItemsInObjectGraph();
    public IDataContractSurrogate get_DataContractSurrogate();
    public bool get_PreserveObjectReferences();
    public bool get_IgnoreExtensionDataObject();
    public DataContractResolver get_DataContractResolver();
    public bool get_SerializeReadOnlyTypes();
    private DataContract get_RootContract();
    internal virtual void InternalWriteObject(XmlWriterDelegator writer, object graph);
    internal virtual void InternalWriteObject(XmlWriterDelegator writer, object graph, DataContractResolver dataContractResolver);
    public virtual void WriteObject(XmlWriter writer, object graph);
    public virtual void WriteStartObject(XmlWriter writer, object graph);
    public virtual void WriteObjectContent(XmlWriter writer, object graph);
    public virtual void WriteEndObject(XmlWriter writer);
    public virtual void WriteStartObject(XmlDictionaryWriter writer, object graph);
    public virtual void WriteObjectContent(XmlDictionaryWriter writer, object graph);
    public virtual void WriteEndObject(XmlDictionaryWriter writer);
    public void WriteObject(XmlDictionaryWriter writer, object graph, DataContractResolver dataContractResolver);
    public virtual object ReadObject(XmlReader reader);
    public virtual object ReadObject(XmlReader reader, bool verifyObjectName);
    public virtual bool IsStartObject(XmlReader reader);
    public virtual object ReadObject(XmlDictionaryReader reader, bool verifyObjectName);
    public virtual bool IsStartObject(XmlDictionaryReader reader);
    public object ReadObject(XmlDictionaryReader reader, bool verifyObjectName, DataContractResolver dataContractResolver);
    internal virtual void InternalWriteStartObject(XmlWriterDelegator writer, object graph);
    internal virtual void InternalWriteObjectContent(XmlWriterDelegator writer, object graph);
    internal void InternalWriteObjectContent(XmlWriterDelegator writer, object graph, DataContractResolver dataContractResolver);
    internal static DataContract GetDataContract(DataContract declaredTypeContract, Type declaredType, Type objectType);
    internal void SetDataContractSurrogate(IDataContractSurrogate adapter);
    internal virtual void InternalWriteEndObject(XmlWriterDelegator writer);
    internal virtual object InternalReadObject(XmlReaderDelegator xmlReader, bool verifyObjectName);
    internal virtual object InternalReadObject(XmlReaderDelegator xmlReader, bool verifyObjectName, DataContractResolver dataContractResolver);
    internal virtual bool InternalIsStartObject(XmlReaderDelegator reader);
    internal virtual Type GetSerializeType(object graph);
    internal virtual Type GetDeserializeType();
    internal static object SurrogateToDataContractType(IDataContractSurrogate dataContractSurrogate, object oldObj, Type surrogatedDeclaredType, Type& objType);
    internal static Type GetSurrogatedType(IDataContractSurrogate dataContractSurrogate, Type type);
}
[EditorBrowsableAttribute("1")]
[ExtensionAttribute]
public static class System.Runtime.Serialization.DataContractSerializerExtensions : object {
    [EditorBrowsableAttribute("1")]
[ExtensionAttribute]
public static ISerializationSurrogateProvider GetSerializationSurrogateProvider(DataContractSerializer serializer);
    [EditorBrowsableAttribute("1")]
[ExtensionAttribute]
public static void SetSerializationSurrogateProvider(DataContractSerializer serializer, ISerializationSurrogateProvider provider);
}
public class System.Runtime.Serialization.DataContractSerializerSettings : object {
    private int maxItemsInObjectGraph;
    [CompilerGeneratedAttribute]
private XmlDictionaryString <RootName>k__BackingField;
    [CompilerGeneratedAttribute]
private XmlDictionaryString <RootNamespace>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<Type> <KnownTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreExtensionDataObject>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PreserveObjectReferences>k__BackingField;
    [CompilerGeneratedAttribute]
private IDataContractSurrogate <DataContractSurrogate>k__BackingField;
    [CompilerGeneratedAttribute]
private DataContractResolver <DataContractResolver>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SerializeReadOnlyTypes>k__BackingField;
    public XmlDictionaryString RootName { get; public set; }
    public XmlDictionaryString RootNamespace { get; public set; }
    public IEnumerable`1<Type> KnownTypes { get; public set; }
    public int MaxItemsInObjectGraph { get; public set; }
    public bool IgnoreExtensionDataObject { get; public set; }
    public bool PreserveObjectReferences { get; public set; }
    public IDataContractSurrogate DataContractSurrogate { get; public set; }
    public DataContractResolver DataContractResolver { get; public set; }
    public bool SerializeReadOnlyTypes { get; public set; }
    [CompilerGeneratedAttribute]
public XmlDictionaryString get_RootName();
    [CompilerGeneratedAttribute]
public void set_RootName(XmlDictionaryString value);
    [CompilerGeneratedAttribute]
public XmlDictionaryString get_RootNamespace();
    [CompilerGeneratedAttribute]
public void set_RootNamespace(XmlDictionaryString value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<Type> get_KnownTypes();
    [CompilerGeneratedAttribute]
public void set_KnownTypes(IEnumerable`1<Type> value);
    public int get_MaxItemsInObjectGraph();
    public void set_MaxItemsInObjectGraph(int value);
    [CompilerGeneratedAttribute]
public bool get_IgnoreExtensionDataObject();
    [CompilerGeneratedAttribute]
public void set_IgnoreExtensionDataObject(bool value);
    [CompilerGeneratedAttribute]
public bool get_PreserveObjectReferences();
    [CompilerGeneratedAttribute]
public void set_PreserveObjectReferences(bool value);
    [CompilerGeneratedAttribute]
public IDataContractSurrogate get_DataContractSurrogate();
    [CompilerGeneratedAttribute]
public void set_DataContractSurrogate(IDataContractSurrogate value);
    [CompilerGeneratedAttribute]
public DataContractResolver get_DataContractResolver();
    [CompilerGeneratedAttribute]
public void set_DataContractResolver(DataContractResolver value);
    [CompilerGeneratedAttribute]
public bool get_SerializeReadOnlyTypes();
    [CompilerGeneratedAttribute]
public void set_SerializeReadOnlyTypes(bool value);
}
[DefaultMemberAttribute("Item")]
internal class System.Runtime.Serialization.DataContractSet : object {
    private Dictionary`2<XmlQualifiedName, DataContract> contracts;
    private Dictionary`2<DataContract, object> processedContracts;
    private IDataContractSurrogate dataContractSurrogate;
    private Hashtable surrogateDataTable;
    private Dictionary`2<XmlQualifiedName, DataContract> knownTypesForObject;
    private ICollection`1<Type> referencedTypes;
    private ICollection`1<Type> referencedCollectionTypes;
    private Dictionary`2<XmlQualifiedName, object> referencedTypesDictionary;
    private Dictionary`2<XmlQualifiedName, object> referencedCollectionTypesDictionary;
    private Dictionary`2<XmlQualifiedName, DataContract> Contracts { get; }
    private Dictionary`2<DataContract, object> ProcessedContracts { get; }
    private Hashtable SurrogateDataTable { get; }
    internal Dictionary`2<XmlQualifiedName, DataContract> KnownTypesForObject { get; internal set; }
    public DataContract Item { get; }
    public IDataContractSurrogate DataContractSurrogate { get; }
    internal DataContractSet(IDataContractSurrogate dataContractSurrogate);
    internal DataContractSet(IDataContractSurrogate dataContractSurrogate, ICollection`1<Type> referencedTypes, ICollection`1<Type> referencedCollectionTypes);
    internal DataContractSet(DataContractSet dataContractSet);
    private Dictionary`2<XmlQualifiedName, DataContract> get_Contracts();
    private Dictionary`2<DataContract, object> get_ProcessedContracts();
    private Hashtable get_SurrogateDataTable();
    internal Dictionary`2<XmlQualifiedName, DataContract> get_KnownTypesForObject();
    internal void set_KnownTypesForObject(Dictionary`2<XmlQualifiedName, DataContract> value);
    internal void Add(Type type);
    internal static void EnsureTypeNotGeneric(Type type);
    private void Add(DataContract dataContract);
    public void Add(XmlQualifiedName name, DataContract dataContract);
    internal void InternalAdd(XmlQualifiedName name, DataContract dataContract);
    private void AddClassDataContract(ClassDataContract classDataContract);
    private void AddCollectionDataContract(CollectionDataContract collectionDataContract);
    private void AddXmlDataContract(XmlDataContract xmlDataContract);
    private void AddKnownDataContracts(Dictionary`2<XmlQualifiedName, DataContract> knownDataContracts);
    internal XmlQualifiedName GetStableName(Type clrType);
    internal DataContract GetDataContract(Type clrType);
    internal DataContract GetMemberTypeDataContract(DataMember dataMember);
    internal DataContract GetItemTypeDataContract(CollectionDataContract collectionContract);
    internal object GetSurrogateData(object key);
    internal void SetSurrogateData(object key, object surrogateData);
    public DataContract get_Item(XmlQualifiedName key);
    public IDataContractSurrogate get_DataContractSurrogate();
    public bool Remove(XmlQualifiedName key);
    public IEnumerator`1<KeyValuePair`2<XmlQualifiedName, DataContract>> GetEnumerator();
    internal bool IsContractProcessed(DataContract dataContract);
    internal void SetContractProcessed(DataContract dataContract);
    internal ContractCodeDomInfo GetContractCodeDomInfo(DataContract dataContract);
    internal void SetContractCodeDomInfo(DataContract dataContract, ContractCodeDomInfo info);
    private Dictionary`2<XmlQualifiedName, object> GetReferencedTypes();
    private Dictionary`2<XmlQualifiedName, object> GetReferencedCollectionTypes();
    private void AddReferencedType(Dictionary`2<XmlQualifiedName, object> referencedTypes, Type type);
    internal bool TryGetReferencedType(XmlQualifiedName stableName, DataContract dataContract, Type& type);
    internal bool TryGetReferencedCollectionType(XmlQualifiedName stableName, DataContract dataContract, Type& type);
    private bool TryGetReferencedType(XmlQualifiedName stableName, DataContract dataContract, bool useReferencedCollectionTypes, Type& type);
    private static bool IsTypeReferenceable(Type type);
}
internal static class System.Runtime.Serialization.DataContractSurrogateCaller : object {
    internal static Type GetDataContractType(IDataContractSurrogate surrogate, Type type);
    internal static object GetObjectToSerialize(IDataContractSurrogate surrogate, object obj, Type objType, Type membertype);
    internal static object GetDeserializedObject(IDataContractSurrogate surrogate, object obj, Type objType, Type memberType);
    internal static object GetCustomDataToExport(IDataContractSurrogate surrogate, MemberInfo memberInfo, Type dataContractType);
    internal static object GetCustomDataToExport(IDataContractSurrogate surrogate, Type clrType, Type dataContractType);
    internal static void GetKnownCustomDataTypes(IDataContractSurrogate surrogate, Collection`1<Type> customDataTypes);
    internal static Type GetReferencedTypeOnImport(IDataContractSurrogate surrogate, string typeName, string typeNamespace, object customData);
    internal static CodeTypeDeclaration ProcessImportedType(IDataContractSurrogate surrogate, CodeTypeDeclaration typeDeclaration, CodeCompileUnit compileUnit);
}
internal class System.Runtime.Serialization.DataMember : object {
    [SecurityCriticalAttribute]
private CriticalHelper helper;
    internal MemberInfo MemberInfo { get; }
    internal string Name { get; internal set; }
    internal int Order { get; internal set; }
    internal bool IsRequired { get; internal set; }
    internal bool EmitDefaultValue { get; internal set; }
    internal bool IsNullable { get; internal set; }
    internal bool IsGetOnlyCollection { get; internal set; }
    internal Type MemberType { get; }
    internal DataContract MemberTypeContract { get; internal set; }
    internal bool HasConflictingNameAndType { get; internal set; }
    internal DataMember ConflictingMember { get; internal set; }
    [SecuritySafeCriticalAttribute]
internal DataMember(MemberInfo memberInfo);
    [SecuritySafeCriticalAttribute]
internal DataMember(string name);
    [SecuritySafeCriticalAttribute]
internal DataMember(DataContract memberTypeContract, string name, bool isNullable, bool isRequired, bool emitDefaultValue, int order);
    [SecuritySafeCriticalAttribute]
internal MemberInfo get_MemberInfo();
    [SecuritySafeCriticalAttribute]
internal string get_Name();
    [SecurityCriticalAttribute]
internal void set_Name(string value);
    [SecuritySafeCriticalAttribute]
internal int get_Order();
    [SecurityCriticalAttribute]
internal void set_Order(int value);
    [SecuritySafeCriticalAttribute]
internal bool get_IsRequired();
    [SecurityCriticalAttribute]
internal void set_IsRequired(bool value);
    [SecuritySafeCriticalAttribute]
internal bool get_EmitDefaultValue();
    [SecurityCriticalAttribute]
internal void set_EmitDefaultValue(bool value);
    [SecuritySafeCriticalAttribute]
internal bool get_IsNullable();
    [SecurityCriticalAttribute]
internal void set_IsNullable(bool value);
    [SecuritySafeCriticalAttribute]
internal bool get_IsGetOnlyCollection();
    [SecurityCriticalAttribute]
internal void set_IsGetOnlyCollection(bool value);
    [SecuritySafeCriticalAttribute]
internal Type get_MemberType();
    [SecuritySafeCriticalAttribute]
internal DataContract get_MemberTypeContract();
    [SecurityCriticalAttribute]
internal void set_MemberTypeContract(DataContract value);
    [SecuritySafeCriticalAttribute]
internal bool get_HasConflictingNameAndType();
    [SecurityCriticalAttribute]
internal void set_HasConflictingNameAndType(bool value);
    [SecuritySafeCriticalAttribute]
internal DataMember get_ConflictingMember();
    [SecurityCriticalAttribute]
internal void set_ConflictingMember(DataMember value);
    internal DataMember BindGenericParameters(DataContract[] paramContracts, Dictionary`2<DataContract, DataContract> boundContracts);
    internal bool Equals(object other, Dictionary`2<DataContractPairKey, object> checkedContracts);
    public virtual int GetHashCode();
}
[AttributeUsageAttribute("384")]
public class System.Runtime.Serialization.DataMemberAttribute : Attribute {
    private string name;
    private bool isNameSetExplicitly;
    private int order;
    private bool isRequired;
    private bool emitDefaultValue;
    public string Name { get; public set; }
    public bool IsNameSetExplicitly { get; }
    public int Order { get; public set; }
    public bool IsRequired { get; public set; }
    public bool EmitDefaultValue { get; public set; }
    public string get_Name();
    public void set_Name(string value);
    public bool get_IsNameSetExplicitly();
    public int get_Order();
    public void set_Order(int value);
    public bool get_IsRequired();
    public void set_IsRequired(bool value);
    public bool get_EmitDefaultValue();
    public void set_EmitDefaultValue(bool value);
}
internal class System.Runtime.Serialization.DataNode`1 : object {
    protected Type dataType;
    private T value;
    private string dataContractName;
    private string dataContractNamespace;
    private string clrTypeName;
    private string clrAssemblyName;
    private string id;
    private bool isFinalValue;
    public Type DataType { get; }
    public object Value { get; public set; }
    private bool System.Runtime.Serialization.IDataNode.IsFinalValue { get; private set; }
    public string DataContractName { get; public set; }
    public string DataContractNamespace { get; public set; }
    public string ClrTypeName { get; public set; }
    public string ClrAssemblyName { get; public set; }
    public bool PreservesReferences { get; }
    public string Id { get; public set; }
    internal DataNode`1(T value);
    public sealed virtual Type get_DataType();
    public sealed virtual object get_Value();
    public sealed virtual void set_Value(object value);
    private sealed virtual override bool System.Runtime.Serialization.IDataNode.get_IsFinalValue();
    private sealed virtual override void System.Runtime.Serialization.IDataNode.set_IsFinalValue(bool value);
    public T GetValue();
    public sealed virtual string get_DataContractName();
    public sealed virtual void set_DataContractName(string value);
    public sealed virtual string get_DataContractNamespace();
    public sealed virtual void set_DataContractNamespace(string value);
    public sealed virtual string get_ClrTypeName();
    public sealed virtual void set_ClrTypeName(string value);
    public sealed virtual string get_ClrAssemblyName();
    public sealed virtual void set_ClrAssemblyName(string value);
    public sealed virtual bool get_PreservesReferences();
    public sealed virtual string get_Id();
    public sealed virtual void set_Id(string value);
    public virtual void GetData(ElementData element);
    public virtual void Clear();
    internal void AddQualifiedNameAttribute(ElementData element, string elementPrefix, string elementName, string elementNs, string valueName, string valueNs);
}
internal class System.Runtime.Serialization.DateDataContract : StringDataContract {
}
internal class System.Runtime.Serialization.DateTimeDataContract : PrimitiveDataContract {
    internal string WriteMethodName { get; }
    internal string ReadMethodName { get; }
    internal virtual string get_WriteMethodName();
    internal virtual string get_ReadMethodName();
    public virtual void WriteXmlValue(XmlWriterDelegator writer, object obj, XmlObjectSerializerWriteContext context);
    public virtual object ReadXmlValue(XmlReaderDelegator reader, XmlObjectSerializerReadContext context);
}
public class System.Runtime.Serialization.DateTimeFormat : object {
    private string formatString;
    private IFormatProvider formatProvider;
    private DateTimeStyles dateTimeStyles;
    public string FormatString { get; }
    public IFormatProvider FormatProvider { get; }
    public DateTimeStyles DateTimeStyles { get; public set; }
    public DateTimeFormat(string formatString);
    public DateTimeFormat(string formatString, IFormatProvider formatProvider);
    public string get_FormatString();
    public IFormatProvider get_FormatProvider();
    public DateTimeStyles get_DateTimeStyles();
    public void set_DateTimeStyles(DateTimeStyles value);
}
[DataContractAttribute]
internal class System.Runtime.Serialization.DateTimeOffsetAdapter : ValueType {
    private DateTime utcDateTime;
    private short offsetMinutes;
    [DataMemberAttribute]
public DateTime UtcDateTime { get; public set; }
    [DataMemberAttribute]
public short OffsetMinutes { get; public set; }
    public DateTimeOffsetAdapter(DateTime dateTime, short offsetMinutes);
    public DateTime get_UtcDateTime();
    public void set_UtcDateTime(DateTime value);
    public short get_OffsetMinutes();
    public void set_OffsetMinutes(short value);
    public static DateTimeOffset GetDateTimeOffset(DateTimeOffsetAdapter value);
    public static DateTimeOffsetAdapter GetDateTimeOffsetAdapter(DateTimeOffset value);
    public string ToString(IFormatProvider provider);
}
internal class System.Runtime.Serialization.DecimalDataContract : PrimitiveDataContract {
    internal string WriteMethodName { get; }
    internal string ReadMethodName { get; }
    internal virtual string get_WriteMethodName();
    internal virtual string get_ReadMethodName();
    public virtual void WriteXmlValue(XmlWriterDelegator writer, object obj, XmlObjectSerializerWriteContext context);
    public virtual object ReadXmlValue(XmlReaderDelegator reader, XmlObjectSerializerReadContext context);
}
internal class System.Runtime.Serialization.Diagnostics.Application.TD : object {
    private static ResourceManager resourceManager;
    private static CultureInfo resourceCulture;
    [SecurityCriticalAttribute]
private static EventDescriptor[] eventDescriptors;
    private static object syncLock;
    private static Boolean modreq(System.Runtime.CompilerServices.IsVolatile) eventDescriptorsCreated;
    private static ResourceManager ResourceManager { get; }
    internal static CultureInfo Culture { get; internal set; }
    private static TD();
    private static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static bool ReaderQuotaExceededIsEnabled();
    internal static void ReaderQuotaExceeded(string param0);
    internal static bool DCSerializeWithSurrogateStartIsEnabled();
    internal static void DCSerializeWithSurrogateStart(string SurrogateType);
    internal static bool DCSerializeWithSurrogateStopIsEnabled();
    internal static void DCSerializeWithSurrogateStop();
    internal static bool DCDeserializeWithSurrogateStartIsEnabled();
    internal static void DCDeserializeWithSurrogateStart(string SurrogateType);
    internal static bool DCDeserializeWithSurrogateStopIsEnabled();
    internal static void DCDeserializeWithSurrogateStop();
    internal static bool ImportKnownTypesStartIsEnabled();
    internal static void ImportKnownTypesStart();
    internal static bool ImportKnownTypesStopIsEnabled();
    internal static void ImportKnownTypesStop();
    internal static bool DCResolverResolveIsEnabled();
    internal static void DCResolverResolve(string TypeName);
    internal static bool DCGenWriterStartIsEnabled();
    internal static void DCGenWriterStart(string Kind, string TypeName);
    internal static bool DCGenWriterStopIsEnabled();
    internal static void DCGenWriterStop();
    internal static bool DCGenReaderStartIsEnabled();
    internal static void DCGenReaderStart(string Kind, string TypeName);
    internal static bool DCGenReaderStopIsEnabled();
    internal static void DCGenReaderStop();
    internal static bool DCJsonGenReaderStartIsEnabled();
    internal static void DCJsonGenReaderStart(string Kind, string TypeName);
    internal static bool DCJsonGenReaderStopIsEnabled();
    internal static void DCJsonGenReaderStop();
    internal static bool DCJsonGenWriterStartIsEnabled();
    internal static void DCJsonGenWriterStart(string Kind, string TypeName);
    internal static bool DCJsonGenWriterStopIsEnabled();
    internal static void DCJsonGenWriterStop();
    internal static bool GenXmlSerializableStartIsEnabled();
    internal static void GenXmlSerializableStart(string DCType);
    internal static bool GenXmlSerializableStopIsEnabled();
    internal static void GenXmlSerializableStop();
    [SecuritySafeCriticalAttribute]
private static void CreateEventDescriptors();
    private static void EnsureEventDescriptors();
    private static bool IsEtwEventEnabled(int eventIndex);
    [SecuritySafeCriticalAttribute]
private static bool WriteEtwEvent(int eventIndex, EventTraceActivity eventParam0, string eventParam1, string eventParam2);
    [SecuritySafeCriticalAttribute]
private static bool WriteEtwEvent(int eventIndex, EventTraceActivity eventParam0, string eventParam1);
    [SecuritySafeCriticalAttribute]
private static bool WriteEtwEvent(int eventIndex, EventTraceActivity eventParam0, string eventParam1, string eventParam2, string eventParam3);
}
internal static class System.Runtime.Serialization.Diagnostics.TraceCode : object {
    public static int Serialization;
    public static int WriteObjectBegin;
    public static int WriteObjectEnd;
    public static int WriteObjectContentBegin;
    public static int WriteObjectContentEnd;
    public static int ReadObjectBegin;
    public static int ReadObjectEnd;
    public static int ElementIgnored;
    public static int XsdExportBegin;
    public static int XsdExportEnd;
    public static int XsdImportBegin;
    public static int XsdImportEnd;
    public static int XsdExportError;
    public static int XsdImportError;
    public static int XsdExportAnnotationFailed;
    public static int XsdImportAnnotationFailed;
    public static int XsdExportDupItems;
    public static int FactoryTypeNotFound;
    public static int ObjectWithLargeDepth;
}
internal static class System.Runtime.Serialization.Diagnostics.TraceUtility : object {
    private static Dictionary`2<int, string> traceCodes;
    private static TraceUtility();
    internal static void Trace(TraceEventType severity, int traceCode, string traceDescription);
    internal static void Trace(TraceEventType severity, int traceCode, string traceDescription, TraceRecord record);
    internal static void Trace(TraceEventType severity, int traceCode, string traceDescription, TraceRecord record, Exception exception);
}
internal static class System.Runtime.Serialization.DiagnosticUtility : object {
    internal static bool ShouldTraceError;
    internal static bool ShouldTraceWarning;
    internal static bool ShouldTraceInformation;
    internal static bool ShouldTraceVerbose;
    private static DiagnosticUtility();
}
internal static class System.Runtime.Serialization.DictionaryGlobals : object {
    public static XmlDictionaryString EmptyString;
    public static XmlDictionaryString SchemaInstanceNamespace;
    public static XmlDictionaryString SchemaNamespace;
    public static XmlDictionaryString SerializationNamespace;
    public static XmlDictionaryString XmlnsNamespace;
    public static XmlDictionaryString XsiTypeLocalName;
    public static XmlDictionaryString XsiNilLocalName;
    public static XmlDictionaryString ClrTypeLocalName;
    public static XmlDictionaryString ClrAssemblyLocalName;
    public static XmlDictionaryString ArraySizeLocalName;
    public static XmlDictionaryString IdLocalName;
    public static XmlDictionaryString RefLocalName;
    public static XmlDictionaryString ISerializableFactoryTypeLocalName;
    public static XmlDictionaryString CharLocalName;
    public static XmlDictionaryString BooleanLocalName;
    public static XmlDictionaryString SignedByteLocalName;
    public static XmlDictionaryString UnsignedByteLocalName;
    public static XmlDictionaryString ShortLocalName;
    public static XmlDictionaryString UnsignedShortLocalName;
    public static XmlDictionaryString IntLocalName;
    public static XmlDictionaryString UnsignedIntLocalName;
    public static XmlDictionaryString LongLocalName;
    public static XmlDictionaryString UnsignedLongLocalName;
    public static XmlDictionaryString FloatLocalName;
    public static XmlDictionaryString DoubleLocalName;
    public static XmlDictionaryString DecimalLocalName;
    public static XmlDictionaryString DateTimeLocalName;
    public static XmlDictionaryString StringLocalName;
    public static XmlDictionaryString ByteArrayLocalName;
    public static XmlDictionaryString ObjectLocalName;
    public static XmlDictionaryString TimeSpanLocalName;
    public static XmlDictionaryString GuidLocalName;
    public static XmlDictionaryString UriLocalName;
    public static XmlDictionaryString QNameLocalName;
    public static XmlDictionaryString Space;
    public static XmlDictionaryString timeLocalName;
    public static XmlDictionaryString dateLocalName;
    public static XmlDictionaryString hexBinaryLocalName;
    public static XmlDictionaryString gYearMonthLocalName;
    public static XmlDictionaryString gYearLocalName;
    public static XmlDictionaryString gMonthDayLocalName;
    public static XmlDictionaryString gDayLocalName;
    public static XmlDictionaryString gMonthLocalName;
    public static XmlDictionaryString integerLocalName;
    public static XmlDictionaryString positiveIntegerLocalName;
    public static XmlDictionaryString negativeIntegerLocalName;
    public static XmlDictionaryString nonPositiveIntegerLocalName;
    public static XmlDictionaryString nonNegativeIntegerLocalName;
    public static XmlDictionaryString normalizedStringLocalName;
    public static XmlDictionaryString tokenLocalName;
    public static XmlDictionaryString languageLocalName;
    public static XmlDictionaryString NameLocalName;
    public static XmlDictionaryString NCNameLocalName;
    public static XmlDictionaryString XSDIDLocalName;
    public static XmlDictionaryString IDREFLocalName;
    public static XmlDictionaryString IDREFSLocalName;
    public static XmlDictionaryString ENTITYLocalName;
    public static XmlDictionaryString ENTITIESLocalName;
    public static XmlDictionaryString NMTOKENLocalName;
    public static XmlDictionaryString NMTOKENSLocalName;
    public static XmlDictionaryString AsmxTypesNamespace;
    private static DictionaryGlobals();
}
internal class System.Runtime.Serialization.DoubleDataContract : PrimitiveDataContract {
    internal string WriteMethodName { get; }
    internal string ReadMethodName { get; }
    internal virtual string get_WriteMethodName();
    internal virtual string get_ReadMethodName();
    public virtual void WriteXmlValue(XmlWriterDelegator writer, object obj, XmlObjectSerializerWriteContext context);
    public virtual object ReadXmlValue(XmlReaderDelegator reader, XmlObjectSerializerReadContext context);
}
internal class System.Runtime.Serialization.ElementData : object {
    public string localName;
    public string ns;
    public string prefix;
    public int attributeCount;
    public AttributeData[] attributes;
    public IDataNode dataNode;
    public int childElementIndex;
    public void AddAttribute(string prefix, string ns, string name, string value);
    private void GrowAttributesIfNeeded();
}
public enum System.Runtime.Serialization.EmitTypeInformation : Enum {
    public int value__;
    public static EmitTypeInformation AsNeeded;
    public static EmitTypeInformation Always;
    public static EmitTypeInformation Never;
}
internal class System.Runtime.Serialization.ENTITIESDataContract : StringDataContract {
}
internal class System.Runtime.Serialization.ENTITYDataContract : StringDataContract {
}
internal class System.Runtime.Serialization.EnumDataContract : DataContract {
    [SecurityCriticalAttribute]
private EnumDataContractCriticalHelper helper;
    internal XmlQualifiedName BaseContractName { get; internal set; }
    internal List`1<DataMember> Members { get; internal set; }
    internal List`1<long> Values { get; internal set; }
    internal bool IsFlags { get; internal set; }
    internal bool IsULong { get; }
    private XmlDictionaryString[] ChildElementNames { get; }
    internal bool CanContainReferences { get; }
    [SecuritySafeCriticalAttribute]
internal EnumDataContract(Type type);
    [SecuritySafeCriticalAttribute]
internal static XmlQualifiedName GetBaseContractName(Type type);
    [SecuritySafeCriticalAttribute]
internal static Type GetBaseType(XmlQualifiedName baseContractName);
    [SecuritySafeCriticalAttribute]
internal XmlQualifiedName get_BaseContractName();
    [SecurityCriticalAttribute]
internal void set_BaseContractName(XmlQualifiedName value);
    [SecuritySafeCriticalAttribute]
internal List`1<DataMember> get_Members();
    [SecurityCriticalAttribute]
internal void set_Members(List`1<DataMember> value);
    [SecuritySafeCriticalAttribute]
internal List`1<long> get_Values();
    [SecurityCriticalAttribute]
internal void set_Values(List`1<long> value);
    [SecuritySafeCriticalAttribute]
internal bool get_IsFlags();
    [SecurityCriticalAttribute]
internal void set_IsFlags(bool value);
    [SecuritySafeCriticalAttribute]
internal bool get_IsULong();
    [SecuritySafeCriticalAttribute]
private XmlDictionaryString[] get_ChildElementNames();
    internal virtual bool get_CanContainReferences();
    internal void WriteEnumValue(XmlWriterDelegator writer, object value);
    internal object ReadEnumValue(XmlReaderDelegator reader);
    private long ReadEnumValue(string value, int index, int count);
    internal string GetStringFromEnumValue(long value);
    internal long GetEnumValueFromString(string value);
    internal virtual bool Equals(object other, Dictionary`2<DataContractPairKey, object> checkedContracts);
    public virtual int GetHashCode();
    public virtual void WriteXmlValue(XmlWriterDelegator xmlWriter, object obj, XmlObjectSerializerWriteContext context);
    public virtual object ReadXmlValue(XmlReaderDelegator xmlReader, XmlObjectSerializerReadContext context);
}
[AttributeUsageAttribute("256")]
public class System.Runtime.Serialization.EnumMemberAttribute : Attribute {
    private string value;
    private bool isValueSetExplicitly;
    public string Value { get; public set; }
    public bool IsValueSetExplicitly { get; }
    public string get_Value();
    public void set_Value(string value);
    public bool get_IsValueSetExplicitly();
}
public class System.Runtime.Serialization.ExportOptions : object {
    private Collection`1<Type> knownTypes;
    private IDataContractSurrogate dataContractSurrogate;
    public IDataContractSurrogate DataContractSurrogate { get; public set; }
    public Collection`1<Type> KnownTypes { get; }
    public IDataContractSurrogate get_DataContractSurrogate();
    public void set_DataContractSurrogate(IDataContractSurrogate value);
    internal IDataContractSurrogate GetSurrogate();
    public Collection`1<Type> get_KnownTypes();
}
internal class System.Runtime.Serialization.ExtensionDataMember : object {
    private string name;
    private string ns;
    private IDataNode value;
    private int memberIndex;
    public string Name { get; public set; }
    public string Namespace { get; public set; }
    public IDataNode Value { get; public set; }
    public int MemberIndex { get; public set; }
    public string get_Name();
    public void set_Name(string value);
    public string get_Namespace();
    public void set_Namespace(string value);
    public IDataNode get_Value();
    public void set_Value(IDataNode value);
    public int get_MemberIndex();
    public void set_MemberIndex(int value);
}
public class System.Runtime.Serialization.ExtensionDataObject : object {
    private IList`1<ExtensionDataMember> members;
    internal IList`1<ExtensionDataMember> Members { get; internal set; }
    internal IList`1<ExtensionDataMember> get_Members();
    internal void set_Members(IList`1<ExtensionDataMember> value);
}
[DefaultMemberAttribute("Item")]
internal class System.Runtime.Serialization.ExtensionDataReader : XmlReader {
    private Hashtable cache;
    private ElementData[] elements;
    private ElementData element;
    private ElementData nextElement;
    private ReadState readState;
    private ExtensionDataNodeType internalNodeType;
    private XmlNodeType nodeType;
    private int depth;
    private string localName;
    private string ns;
    private string prefix;
    private string value;
    private int attributeCount;
    private int attributeIndex;
    private XmlNodeReader xmlNodeReader;
    private Queue`1<IDataNode> deserializedDataNodes;
    private XmlObjectSerializerReadContext context;
    [SecurityCriticalAttribute]
private static Dictionary`2<string, string> nsToPrefixTable;
    [SecurityCriticalAttribute]
private static Dictionary`2<string, string> prefixToNsTable;
    private bool IsXmlDataNode { get; }
    public XmlNodeType NodeType { get; }
    public string LocalName { get; }
    public string NamespaceURI { get; }
    public string Prefix { get; }
    public string Value { get; }
    public int Depth { get; }
    public int AttributeCount { get; }
    public bool EOF { get; }
    public ReadState ReadState { get; }
    public bool IsEmptyElement { get; }
    public bool IsDefault { get; }
    public char QuoteChar { get; }
    public XmlSpace XmlSpace { get; }
    public string XmlLang { get; }
    public string Item { get; }
    public string Item { get; }
    public string Item { get; }
    public string Name { get; }
    public bool HasValue { get; }
    public string BaseURI { get; }
    public XmlNameTable NameTable { get; }
    [SecuritySafeCriticalAttribute]
private static ExtensionDataReader();
    internal ExtensionDataReader(XmlObjectSerializerReadContext context);
    internal void SetDeserializedValue(object obj);
    internal IDataNode GetCurrentNode();
    internal void SetDataNode(IDataNode dataNode, string name, string ns);
    internal void Reset();
    private bool get_IsXmlDataNode();
    public virtual XmlNodeType get_NodeType();
    public virtual string get_LocalName();
    public virtual string get_NamespaceURI();
    public virtual string get_Prefix();
    public virtual string get_Value();
    public virtual int get_Depth();
    public virtual int get_AttributeCount();
    public virtual bool get_EOF();
    public virtual ReadState get_ReadState();
    public virtual bool get_IsEmptyElement();
    public virtual bool get_IsDefault();
    public virtual char get_QuoteChar();
    public virtual XmlSpace get_XmlSpace();
    public virtual string get_XmlLang();
    public virtual string get_Item(int i);
    public virtual string get_Item(string name);
    public virtual string get_Item(string name, string namespaceURI);
    public virtual bool MoveToFirstAttribute();
    public virtual bool MoveToNextAttribute();
    public virtual void MoveToAttribute(int index);
    public virtual string GetAttribute(string name, string namespaceURI);
    public virtual bool MoveToAttribute(string name, string namespaceURI);
    public virtual bool MoveToElement();
    private void SetElement();
    [SecuritySafeCriticalAttribute]
public virtual string LookupNamespace(string prefix);
    public virtual void Skip();
    private bool IsElementNode(ExtensionDataNodeType nodeType);
    public virtual void Close();
    public virtual bool Read();
    public virtual string get_Name();
    public virtual bool get_HasValue();
    public virtual string get_BaseURI();
    public virtual XmlNameTable get_NameTable();
    public virtual string GetAttribute(string name);
    public virtual string GetAttribute(int i);
    public virtual bool MoveToAttribute(string name);
    public virtual void ResolveEntity();
    public virtual bool ReadAttributeValue();
    private void MoveNext(IDataNode dataNode);
    private void SetNextElement(IDataNode node, string name, string ns, string prefix);
    private void AddDeserializedDataNode(IDataNode node);
    private bool CheckIfNodeHandled(IDataNode node);
    private void MoveNextInClass(ClassDataNode dataNode);
    private void MoveNextInCollection(CollectionDataNode dataNode);
    private void MoveNextInISerializable(ISerializableDataNode dataNode);
    private void MoveNextInXml(XmlDataNode dataNode);
    private void MoveToDeserializedObject(IDataNode dataNode);
    private bool MoveToText(Type type, IDataNode dataNode, bool isTypedNode);
    private void PushElement();
    private void PopElement();
    private void GrowElementsIfNeeded();
    private ElementData GetNextElement();
    [SecuritySafeCriticalAttribute]
internal static string GetPrefix(string ns);
    [SecuritySafeCriticalAttribute]
private static void AddPrefix(string prefix, string ns);
}
internal class System.Runtime.Serialization.FloatDataContract : PrimitiveDataContract {
    internal string WriteMethodName { get; }
    internal string ReadMethodName { get; }
    internal virtual string get_WriteMethodName();
    internal virtual string get_ReadMethodName();
    public virtual void WriteXmlValue(XmlWriterDelegator writer, object obj, XmlObjectSerializerWriteContext context);
    public virtual object ReadXmlValue(XmlReaderDelegator reader, XmlObjectSerializerReadContext context);
}
internal static class System.Runtime.Serialization.FxTrace : object {
    public static bool ShouldTraceError;
    public static bool ShouldTraceVerbose;
    public static EtwDiagnosticTrace Trace { get; }
    public static ExceptionTrace Exception { get; }
    private static FxTrace();
    public static EtwDiagnosticTrace get_Trace();
    public static ExceptionTrace get_Exception();
    public static bool IsEventEnabled(int index);
    public static void UpdateEventDefinitions(EventDescriptor[] ed, UInt16[] events);
}
internal class System.Runtime.Serialization.GDayDataContract : StringDataContract {
}
internal class System.Runtime.Serialization.GenericInfo : object {
    private string genericTypeName;
    private XmlQualifiedName stableName;
    private List`1<GenericInfo> paramGenericInfos;
    private List`1<int> nestedParamCounts;
    internal XmlQualifiedName StableName { get; }
    internal IList`1<GenericInfo> Parameters { get; }
    public bool ParametersFromBuiltInNamespaces { get; }
    internal GenericInfo(XmlQualifiedName stableName, string genericTypeName);
    internal void Add(GenericInfo actualParamInfo);
    internal void AddToLevel(int level, int count);
    internal XmlQualifiedName GetExpandedStableName();
    internal string GetStableNamespace();
    internal XmlQualifiedName get_StableName();
    internal IList`1<GenericInfo> get_Parameters();
    public sealed virtual int GetParameterCount();
    public sealed virtual IList`1<int> GetNestedParameterCounts();
    public sealed virtual string GetParameterName(int paramIndex);
    public sealed virtual string GetNamespaces();
    public sealed virtual string GetGenericTypeName();
    public sealed virtual bool get_ParametersFromBuiltInNamespaces();
}
internal class System.Runtime.Serialization.GenericNameProvider : object {
    private string genericTypeName;
    private Object[] genericParams;
    private IList`1<int> nestedParamCounts;
    public bool ParametersFromBuiltInNamespaces { get; }
    internal GenericNameProvider(Type type);
    internal GenericNameProvider(string genericTypeName, Object[] genericParams);
    public sealed virtual int GetParameterCount();
    public sealed virtual IList`1<int> GetNestedParameterCounts();
    public sealed virtual string GetParameterName(int paramIndex);
    public sealed virtual string GetNamespaces();
    public sealed virtual string GetGenericTypeName();
    public sealed virtual bool get_ParametersFromBuiltInNamespaces();
    private XmlQualifiedName GetStableName(int i);
}
internal class System.Runtime.Serialization.GenericParameterDataContract : DataContract {
    [SecurityCriticalAttribute]
private GenericParameterDataContractCriticalHelper helper;
    internal int ParameterPosition { get; }
    internal bool IsBuiltInDataContract { get; }
    [SecuritySafeCriticalAttribute]
internal GenericParameterDataContract(Type type);
    [SecuritySafeCriticalAttribute]
internal int get_ParameterPosition();
    internal virtual bool get_IsBuiltInDataContract();
    internal virtual DataContract BindGenericParameters(DataContract[] paramContracts, Dictionary`2<DataContract, DataContract> boundContracts);
}
internal static class System.Runtime.Serialization.Globals : object {
    internal static BindingFlags ScanAllMembers;
    [SecurityCriticalAttribute]
private static XmlQualifiedName idQualifiedName;
    [SecurityCriticalAttribute]
private static XmlQualifiedName refQualifiedName;
    [SecurityCriticalAttribute]
private static Type typeOfObject;
    [SecurityCriticalAttribute]
private static Type typeOfValueType;
    [SecurityCriticalAttribute]
private static Type typeOfArray;
    [SecurityCriticalAttribute]
private static Type typeOfString;
    [SecurityCriticalAttribute]
private static Type typeOfInt;
    [SecurityCriticalAttribute]
private static Type typeOfULong;
    [SecurityCriticalAttribute]
private static Type typeOfVoid;
    [SecurityCriticalAttribute]
private static Type typeOfByteArray;
    [SecurityCriticalAttribute]
private static Type typeOfTimeSpan;
    [SecurityCriticalAttribute]
private static Type typeOfGuid;
    [SecurityCriticalAttribute]
private static Type typeOfDateTimeOffset;
    [SecurityCriticalAttribute]
private static Type typeOfDateTimeOffsetAdapter;
    [SecurityCriticalAttribute]
private static Type typeOfUri;
    [SecurityCriticalAttribute]
private static Type typeOfTypeEnumerable;
    [SecurityCriticalAttribute]
private static Type typeOfStreamingContext;
    [SecurityCriticalAttribute]
private static Type typeOfISerializable;
    [SecurityCriticalAttribute]
private static Type typeOfIDeserializationCallback;
    [SecurityCriticalAttribute]
private static Type typeOfIObjectReference;
    [SecurityCriticalAttribute]
private static Type typeOfXmlFormatClassWriterDelegate;
    [SecurityCriticalAttribute]
private static Type typeOfXmlFormatCollectionWriterDelegate;
    [SecurityCriticalAttribute]
private static Type typeOfXmlFormatClassReaderDelegate;
    [SecurityCriticalAttribute]
private static Type typeOfXmlFormatCollectionReaderDelegate;
    [SecurityCriticalAttribute]
private static Type typeOfXmlFormatGetOnlyCollectionReaderDelegate;
    [SecurityCriticalAttribute]
private static Type typeOfKnownTypeAttribute;
    [SecurityCriticalAttribute]
private static Type typeOfDataContractAttribute;
    [SecurityCriticalAttribute]
private static Type typeOfContractNamespaceAttribute;
    [SecurityCriticalAttribute]
private static Type typeOfDataMemberAttribute;
    [SecurityCriticalAttribute]
private static Type typeOfEnumMemberAttribute;
    [SecurityCriticalAttribute]
private static Type typeOfCollectionDataContractAttribute;
    [SecurityCriticalAttribute]
private static Type typeOfOptionalFieldAttribute;
    [SecurityCriticalAttribute]
private static Type typeOfObjectArray;
    [SecurityCriticalAttribute]
private static Type typeOfOnSerializingAttribute;
    [SecurityCriticalAttribute]
private static Type typeOfOnSerializedAttribute;
    [SecurityCriticalAttribute]
private static Type typeOfOnDeserializingAttribute;
    [SecurityCriticalAttribute]
private static Type typeOfOnDeserializedAttribute;
    [SecurityCriticalAttribute]
private static Type typeOfFlagsAttribute;
    [SecurityCriticalAttribute]
private static Type typeOfSerializableAttribute;
    [SecurityCriticalAttribute]
private static Type typeOfNonSerializedAttribute;
    [SecurityCriticalAttribute]
private static Type typeOfSerializationInfo;
    [SecurityCriticalAttribute]
private static Type typeOfSerializationInfoEnumerator;
    [SecurityCriticalAttribute]
private static Type typeOfSerializationEntry;
    [SecurityCriticalAttribute]
private static Type typeOfIXmlSerializable;
    [SecurityCriticalAttribute]
private static Type typeOfXmlSchemaProviderAttribute;
    [SecurityCriticalAttribute]
private static Type typeOfXmlRootAttribute;
    [SecurityCriticalAttribute]
private static Type typeOfXmlQualifiedName;
    [SecurityCriticalAttribute]
private static Type typeOfXmlSchemaType;
    [SecurityCriticalAttribute]
private static Type typeOfXmlSerializableServices;
    [SecurityCriticalAttribute]
private static Type typeOfXmlNodeArray;
    [SecurityCriticalAttribute]
private static Type typeOfXmlSchemaSet;
    [SecurityCriticalAttribute]
private static Object[] emptyObjectArray;
    [SecurityCriticalAttribute]
private static Type[] emptyTypeArray;
    [SecurityCriticalAttribute]
private static Type typeOfIPropertyChange;
    [SecurityCriticalAttribute]
private static Type typeOfIExtensibleDataObject;
    [SecurityCriticalAttribute]
private static Type typeOfExtensionDataObject;
    [SecurityCriticalAttribute]
private static Type typeOfISerializableDataNode;
    [SecurityCriticalAttribute]
private static Type typeOfClassDataNode;
    [SecurityCriticalAttribute]
private static Type typeOfCollectionDataNode;
    [SecurityCriticalAttribute]
private static Type typeOfXmlDataNode;
    [SecurityCriticalAttribute]
private static Type typeOfNullable;
    [SecurityCriticalAttribute]
private static Type typeOfReflectionPointer;
    [SecurityCriticalAttribute]
private static Type typeOfIDictionaryGeneric;
    [SecurityCriticalAttribute]
private static Type typeOfIDictionary;
    [SecurityCriticalAttribute]
private static Type typeOfIListGeneric;
    [SecurityCriticalAttribute]
private static Type typeOfIList;
    [SecurityCriticalAttribute]
private static Type typeOfICollectionGeneric;
    [SecurityCriticalAttribute]
private static Type typeOfICollection;
    [SecurityCriticalAttribute]
private static Type typeOfIEnumerableGeneric;
    [SecurityCriticalAttribute]
private static Type typeOfIEnumerable;
    [SecurityCriticalAttribute]
private static Type typeOfIEnumeratorGeneric;
    [SecurityCriticalAttribute]
private static Type typeOfIEnumerator;
    [SecurityCriticalAttribute]
private static Type typeOfKeyValuePair;
    [SecurityCriticalAttribute]
private static Type typeOfKeyValue;
    [SecurityCriticalAttribute]
private static Type typeOfIDictionaryEnumerator;
    [SecurityCriticalAttribute]
private static Type typeOfDictionaryEnumerator;
    [SecurityCriticalAttribute]
private static Type typeOfGenericDictionaryEnumerator;
    [SecurityCriticalAttribute]
private static Type typeOfDictionaryGeneric;
    [SecurityCriticalAttribute]
private static Type typeOfHashtable;
    [SecurityCriticalAttribute]
private static Type typeOfListGeneric;
    [SecurityCriticalAttribute]
private static Type typeOfXmlElement;
    [SecurityCriticalAttribute]
private static Type typeOfDBNull;
    [SecurityCriticalAttribute]
private static Uri dataContractXsdBaseNamespaceUri;
    public static bool DefaultIsRequired;
    public static bool DefaultEmitDefaultValue;
    public static int DefaultOrder;
    public static bool DefaultIsReference;
    public static string NewObjectId;
    public static string SimpleSRSInternalsVisiblePattern;
    public static string FullSRSInternalsVisiblePattern;
    public static string NullObjectId;
    public static string Space;
    public static string OpenBracket;
    public static string CloseBracket;
    public static string Comma;
    public static string XsiPrefix;
    public static string XsdPrefix;
    public static string SerPrefix;
    public static string SerPrefixForSchema;
    public static string ElementPrefix;
    public static string DataContractXsdBaseNamespace;
    public static string DataContractXmlNamespace;
    public static string SchemaInstanceNamespace;
    public static string SchemaNamespace;
    public static string XsiNilLocalName;
    public static string XsiTypeLocalName;
    public static string TnsPrefix;
    public static string OccursUnbounded;
    public static string AnyTypeLocalName;
    public static string StringLocalName;
    public static string IntLocalName;
    public static string True;
    public static string False;
    public static string ArrayPrefix;
    public static string XmlnsNamespace;
    public static string XmlnsPrefix;
    public static string SchemaLocalName;
    public static string CollectionsNamespace;
    public static string DefaultClrNamespace;
    public static string DefaultTypeName;
    public static string DefaultGeneratedMember;
    public static string DefaultFieldSuffix;
    public static string DefaultPropertySuffix;
    public static string DefaultMemberSuffix;
    public static string NameProperty;
    public static string NamespaceProperty;
    public static string OrderProperty;
    public static string IsReferenceProperty;
    public static string IsRequiredProperty;
    public static string EmitDefaultValueProperty;
    public static string ClrNamespaceProperty;
    public static string ItemNameProperty;
    public static string KeyNameProperty;
    public static string ValueNameProperty;
    public static string SerializationInfoPropertyName;
    public static string SerializationInfoFieldName;
    public static string NodeArrayPropertyName;
    public static string NodeArrayFieldName;
    public static string ExportSchemaMethod;
    public static string IsAnyProperty;
    public static string ContextFieldName;
    public static string GetObjectDataMethodName;
    public static string GetEnumeratorMethodName;
    public static string MoveNextMethodName;
    public static string AddValueMethodName;
    public static string CurrentPropertyName;
    public static string ValueProperty;
    public static string EnumeratorFieldName;
    public static string SerializationEntryFieldName;
    public static string ExtensionDataSetMethod;
    public static string ExtensionDataSetExplicitMethod;
    public static string ExtensionDataObjectPropertyName;
    public static string ExtensionDataObjectFieldName;
    public static string AddMethodName;
    public static string ParseMethodName;
    public static string GetCurrentMethodName;
    public static string SerializationNamespace;
    public static string ClrTypeLocalName;
    public static string ClrAssemblyLocalName;
    public static string IsValueTypeLocalName;
    public static string EnumerationValueLocalName;
    public static string SurrogateDataLocalName;
    public static string GenericTypeLocalName;
    public static string GenericParameterLocalName;
    public static string GenericNameAttribute;
    public static string GenericNamespaceAttribute;
    public static string GenericParameterNestedLevelAttribute;
    public static string IsDictionaryLocalName;
    public static string ActualTypeLocalName;
    public static string ActualTypeNameAttribute;
    public static string ActualTypeNamespaceAttribute;
    public static string DefaultValueLocalName;
    public static string EmitDefaultValueAttribute;
    public static string ISerializableFactoryTypeLocalName;
    public static string IdLocalName;
    public static string RefLocalName;
    public static string ArraySizeLocalName;
    public static string KeyLocalName;
    public static string ValueLocalName;
    public static string MscorlibAssemblyName;
    public static string MscorlibAssemblySimpleName;
    public static string MscorlibFileName;
    public static string SerializationSchema;
    internal static XmlQualifiedName IdQualifiedName { get; }
    internal static XmlQualifiedName RefQualifiedName { get; }
    internal static Type TypeOfObject { get; }
    internal static Type TypeOfValueType { get; }
    internal static Type TypeOfArray { get; }
    internal static Type TypeOfString { get; }
    internal static Type TypeOfInt { get; }
    internal static Type TypeOfULong { get; }
    internal static Type TypeOfVoid { get; }
    internal static Type TypeOfByteArray { get; }
    internal static Type TypeOfTimeSpan { get; }
    internal static Type TypeOfGuid { get; }
    internal static Type TypeOfDateTimeOffset { get; }
    internal static Type TypeOfDateTimeOffsetAdapter { get; }
    internal static Type TypeOfUri { get; }
    internal static Type TypeOfTypeEnumerable { get; }
    internal static Type TypeOfStreamingContext { get; }
    internal static Type TypeOfISerializable { get; }
    internal static Type TypeOfIDeserializationCallback { get; }
    internal static Type TypeOfIObjectReference { get; }
    internal static Type TypeOfXmlFormatClassWriterDelegate { get; }
    internal static Type TypeOfXmlFormatCollectionWriterDelegate { get; }
    internal static Type TypeOfXmlFormatClassReaderDelegate { get; }
    internal static Type TypeOfXmlFormatCollectionReaderDelegate { get; }
    internal static Type TypeOfXmlFormatGetOnlyCollectionReaderDelegate { get; }
    internal static Type TypeOfKnownTypeAttribute { get; }
    internal static Type TypeOfDataContractAttribute { get; }
    internal static Type TypeOfContractNamespaceAttribute { get; }
    internal static Type TypeOfDataMemberAttribute { get; }
    internal static Type TypeOfEnumMemberAttribute { get; }
    internal static Type TypeOfCollectionDataContractAttribute { get; }
    internal static Type TypeOfOptionalFieldAttribute { get; }
    internal static Type TypeOfObjectArray { get; }
    internal static Type TypeOfOnSerializingAttribute { get; }
    internal static Type TypeOfOnSerializedAttribute { get; }
    internal static Type TypeOfOnDeserializingAttribute { get; }
    internal static Type TypeOfOnDeserializedAttribute { get; }
    internal static Type TypeOfFlagsAttribute { get; }
    internal static Type TypeOfSerializableAttribute { get; }
    internal static Type TypeOfNonSerializedAttribute { get; }
    internal static Type TypeOfSerializationInfo { get; }
    internal static Type TypeOfSerializationInfoEnumerator { get; }
    internal static Type TypeOfSerializationEntry { get; }
    internal static Type TypeOfIXmlSerializable { get; }
    internal static Type TypeOfXmlSchemaProviderAttribute { get; }
    internal static Type TypeOfXmlRootAttribute { get; }
    internal static Type TypeOfXmlQualifiedName { get; }
    internal static Type TypeOfXmlSchemaType { get; }
    internal static Type TypeOfXmlSerializableServices { get; }
    internal static Type TypeOfXmlNodeArray { get; }
    internal static Type TypeOfXmlSchemaSet { get; }
    internal static Object[] EmptyObjectArray { get; }
    internal static Type[] EmptyTypeArray { get; }
    internal static Type TypeOfIPropertyChange { get; }
    internal static Type TypeOfIExtensibleDataObject { get; }
    internal static Type TypeOfExtensionDataObject { get; }
    internal static Type TypeOfISerializableDataNode { get; }
    internal static Type TypeOfClassDataNode { get; }
    internal static Type TypeOfCollectionDataNode { get; }
    internal static Type TypeOfXmlDataNode { get; }
    internal static Type TypeOfNullable { get; }
    internal static Type TypeOfReflectionPointer { get; }
    internal static Type TypeOfIDictionaryGeneric { get; }
    internal static Type TypeOfIDictionary { get; }
    internal static Type TypeOfIListGeneric { get; }
    internal static Type TypeOfIList { get; }
    internal static Type TypeOfICollectionGeneric { get; }
    internal static Type TypeOfICollection { get; }
    internal static Type TypeOfIEnumerableGeneric { get; }
    internal static Type TypeOfIEnumerable { get; }
    internal static Type TypeOfIEnumeratorGeneric { get; }
    internal static Type TypeOfIEnumerator { get; }
    internal static Type TypeOfKeyValuePair { get; }
    internal static Type TypeOfKeyValue { get; }
    internal static Type TypeOfIDictionaryEnumerator { get; }
    internal static Type TypeOfDictionaryEnumerator { get; }
    internal static Type TypeOfGenericDictionaryEnumerator { get; }
    internal static Type TypeOfDictionaryGeneric { get; }
    internal static Type TypeOfHashtable { get; }
    internal static Type TypeOfListGeneric { get; }
    internal static Type TypeOfXmlElement { get; }
    internal static Type TypeOfDBNull { get; }
    internal static Uri DataContractXsdBaseNamespaceUri { get; }
    private static Globals();
    [SecuritySafeCriticalAttribute]
internal static XmlQualifiedName get_IdQualifiedName();
    [SecuritySafeCriticalAttribute]
internal static XmlQualifiedName get_RefQualifiedName();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfObject();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfValueType();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfArray();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfString();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfInt();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfULong();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfVoid();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfByteArray();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfTimeSpan();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfGuid();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfDateTimeOffset();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfDateTimeOffsetAdapter();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfUri();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfTypeEnumerable();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfStreamingContext();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfISerializable();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfIDeserializationCallback();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfIObjectReference();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfXmlFormatClassWriterDelegate();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfXmlFormatCollectionWriterDelegate();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfXmlFormatClassReaderDelegate();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfXmlFormatCollectionReaderDelegate();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfXmlFormatGetOnlyCollectionReaderDelegate();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfKnownTypeAttribute();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfDataContractAttribute();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfContractNamespaceAttribute();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfDataMemberAttribute();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfEnumMemberAttribute();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfCollectionDataContractAttribute();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfOptionalFieldAttribute();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfObjectArray();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfOnSerializingAttribute();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfOnSerializedAttribute();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfOnDeserializingAttribute();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfOnDeserializedAttribute();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfFlagsAttribute();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfSerializableAttribute();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfNonSerializedAttribute();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfSerializationInfo();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfSerializationInfoEnumerator();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfSerializationEntry();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfIXmlSerializable();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfXmlSchemaProviderAttribute();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfXmlRootAttribute();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfXmlQualifiedName();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfXmlSchemaType();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfXmlSerializableServices();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfXmlNodeArray();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfXmlSchemaSet();
    [SecuritySafeCriticalAttribute]
internal static Object[] get_EmptyObjectArray();
    [SecuritySafeCriticalAttribute]
internal static Type[] get_EmptyTypeArray();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfIPropertyChange();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfIExtensibleDataObject();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfExtensionDataObject();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfISerializableDataNode();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfClassDataNode();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfCollectionDataNode();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfXmlDataNode();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfNullable();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfReflectionPointer();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfIDictionaryGeneric();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfIDictionary();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfIListGeneric();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfIList();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfICollectionGeneric();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfICollection();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfIEnumerableGeneric();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfIEnumerable();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfIEnumeratorGeneric();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfIEnumerator();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfKeyValuePair();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfKeyValue();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfIDictionaryEnumerator();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfDictionaryEnumerator();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfGenericDictionaryEnumerator();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfDictionaryGeneric();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfHashtable();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfListGeneric();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfXmlElement();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfDBNull();
    [SecuritySafeCriticalAttribute]
internal static Uri get_DataContractXsdBaseNamespaceUri();
}
internal class System.Runtime.Serialization.GMonthDataContract : StringDataContract {
}
internal class System.Runtime.Serialization.GMonthDayDataContract : StringDataContract {
}
internal class System.Runtime.Serialization.GuidDataContract : PrimitiveDataContract {
    internal string WriteMethodName { get; }
    internal string ReadMethodName { get; }
    internal GuidDataContract(XmlDictionaryString name, XmlDictionaryString ns);
    internal virtual string get_WriteMethodName();
    internal virtual string get_ReadMethodName();
    public virtual void WriteXmlValue(XmlWriterDelegator writer, object obj, XmlObjectSerializerWriteContext context);
    public virtual object ReadXmlValue(XmlReaderDelegator reader, XmlObjectSerializerReadContext context);
}
internal class System.Runtime.Serialization.GYearDataContract : StringDataContract {
}
internal class System.Runtime.Serialization.GYearMonthDataContract : StringDataContract {
}
internal class System.Runtime.Serialization.HexBinaryDataContract : StringDataContract {
}
internal class System.Runtime.Serialization.HybridObjectCache : object {
    private Dictionary`2<string, object> objectDictionary;
    private Dictionary`2<string, object> referencedObjectDictionary;
    internal void Add(string id, object obj);
    internal void Remove(string id);
    internal object GetObject(string id);
    internal bool IsObjectReferenced(string id);
}
public interface System.Runtime.Serialization.IDataContractSurrogate {
    public abstract virtual Type GetDataContractType(Type type);
    public abstract virtual object GetObjectToSerialize(object obj, Type targetType);
    public abstract virtual object GetDeserializedObject(object obj, Type targetType);
    public abstract virtual object GetCustomDataToExport(MemberInfo memberInfo, Type dataContractType);
    public abstract virtual object GetCustomDataToExport(Type clrType, Type dataContractType);
    public abstract virtual void GetKnownCustomDataTypes(Collection`1<Type> customDataTypes);
    public abstract virtual Type GetReferencedTypeOnImport(string typeName, string typeNamespace, object customData);
    public abstract virtual CodeTypeDeclaration ProcessImportedType(CodeTypeDeclaration typeDeclaration, CodeCompileUnit compileUnit);
}
internal interface System.Runtime.Serialization.IDataNode {
    public Type DataType { get; }
    public object Value { get; public set; }
    public string DataContractName { get; public set; }
    public string DataContractNamespace { get; public set; }
    public string ClrTypeName { get; public set; }
    public string ClrAssemblyName { get; public set; }
    public string Id { get; public set; }
    public bool PreservesReferences { get; }
    public bool IsFinalValue { get; public set; }
    public abstract virtual Type get_DataType();
    public abstract virtual object get_Value();
    public abstract virtual void set_Value(object value);
    public abstract virtual string get_DataContractName();
    public abstract virtual void set_DataContractName(string value);
    public abstract virtual string get_DataContractNamespace();
    public abstract virtual void set_DataContractNamespace(string value);
    public abstract virtual string get_ClrTypeName();
    public abstract virtual void set_ClrTypeName(string value);
    public abstract virtual string get_ClrAssemblyName();
    public abstract virtual void set_ClrAssemblyName(string value);
    public abstract virtual string get_Id();
    public abstract virtual void set_Id(string value);
    public abstract virtual bool get_PreservesReferences();
    public abstract virtual void GetData(ElementData element);
    public abstract virtual bool get_IsFinalValue();
    public abstract virtual void set_IsFinalValue(bool value);
    public abstract virtual void Clear();
}
internal class System.Runtime.Serialization.IDDataContract : StringDataContract {
}
internal class System.Runtime.Serialization.IDREFDataContract : StringDataContract {
}
internal class System.Runtime.Serialization.IDREFSDataContract : StringDataContract {
}
public interface System.Runtime.Serialization.IExtensibleDataObject {
    public ExtensionDataObject ExtensionData { get; public set; }
    public abstract virtual ExtensionDataObject get_ExtensionData();
    public abstract virtual void set_ExtensionData(ExtensionDataObject value);
}
internal interface System.Runtime.Serialization.IGenericNameProvider {
    public bool ParametersFromBuiltInNamespaces { get; }
    public abstract virtual int GetParameterCount();
    public abstract virtual IList`1<int> GetNestedParameterCounts();
    public abstract virtual string GetParameterName(int paramIndex);
    public abstract virtual string GetNamespaces();
    public abstract virtual string GetGenericTypeName();
    public abstract virtual bool get_ParametersFromBuiltInNamespaces();
}
[AttributeUsageAttribute("384")]
public class System.Runtime.Serialization.IgnoreDataMemberAttribute : Attribute {
}
public class System.Runtime.Serialization.ImportOptions : object {
    private bool generateSerializable;
    private bool generateInternal;
    private bool enableDataBinding;
    private CodeDomProvider codeProvider;
    private ICollection`1<Type> referencedTypes;
    private ICollection`1<Type> referencedCollectionTypes;
    private IDictionary`2<string, string> namespaces;
    private bool importXmlType;
    private IDataContractSurrogate dataContractSurrogate;
    public bool GenerateSerializable { get; public set; }
    public bool GenerateInternal { get; public set; }
    public bool EnableDataBinding { get; public set; }
    public CodeDomProvider CodeProvider { get; public set; }
    public ICollection`1<Type> ReferencedTypes { get; }
    public ICollection`1<Type> ReferencedCollectionTypes { get; }
    public IDictionary`2<string, string> Namespaces { get; }
    public bool ImportXmlType { get; public set; }
    public IDataContractSurrogate DataContractSurrogate { get; public set; }
    public bool get_GenerateSerializable();
    public void set_GenerateSerializable(bool value);
    public bool get_GenerateInternal();
    public void set_GenerateInternal(bool value);
    public bool get_EnableDataBinding();
    public void set_EnableDataBinding(bool value);
    public CodeDomProvider get_CodeProvider();
    public void set_CodeProvider(CodeDomProvider value);
    public ICollection`1<Type> get_ReferencedTypes();
    public ICollection`1<Type> get_ReferencedCollectionTypes();
    public IDictionary`2<string, string> get_Namespaces();
    public bool get_ImportXmlType();
    public void set_ImportXmlType(bool value);
    public IDataContractSurrogate get_DataContractSurrogate();
    public void set_DataContractSurrogate(IDataContractSurrogate value);
}
internal class System.Runtime.Serialization.IntDataContract : PrimitiveDataContract {
    internal string WriteMethodName { get; }
    internal string ReadMethodName { get; }
    internal virtual string get_WriteMethodName();
    internal virtual string get_ReadMethodName();
    public virtual void WriteXmlValue(XmlWriterDelegator writer, object obj, XmlObjectSerializerWriteContext context);
    public virtual object ReadXmlValue(XmlReaderDelegator reader, XmlObjectSerializerReadContext context);
}
internal class System.Runtime.Serialization.IntegerDataContract : LongDataContract {
}
internal class System.Runtime.Serialization.IntRef : object {
    private int value;
    public int Value { get; }
    public IntRef(int value);
    public int get_Value();
}
public class System.Runtime.Serialization.InvalidDataContractException : Exception {
    public InvalidDataContractException(string message);
    public InvalidDataContractException(string message, Exception innerException);
    protected InvalidDataContractException(SerializationInfo info, StreamingContext context);
}
internal class System.Runtime.Serialization.ISerializableDataMember : object {
    private string name;
    private IDataNode value;
    internal string Name { get; internal set; }
    internal IDataNode Value { get; internal set; }
    internal string get_Name();
    internal void set_Name(string value);
    internal IDataNode get_Value();
    internal void set_Value(IDataNode value);
}
internal class System.Runtime.Serialization.ISerializableDataNode : DataNode`1<object> {
    private string factoryTypeName;
    private string factoryTypeNamespace;
    private IList`1<ISerializableDataMember> members;
    internal string FactoryTypeName { get; internal set; }
    internal string FactoryTypeNamespace { get; internal set; }
    internal IList`1<ISerializableDataMember> Members { get; internal set; }
    internal string get_FactoryTypeName();
    internal void set_FactoryTypeName(string value);
    internal string get_FactoryTypeNamespace();
    internal void set_FactoryTypeNamespace(string value);
    internal IList`1<ISerializableDataMember> get_Members();
    internal void set_Members(IList`1<ISerializableDataMember> value);
    public virtual void GetData(ElementData element);
    public virtual void Clear();
}
public interface System.Runtime.Serialization.ISerializationSurrogateProvider {
    public abstract virtual Type GetSurrogateType(Type type);
    public abstract virtual object GetObjectToSerialize(object obj, Type targetType);
    public abstract virtual object GetDeserializedObject(object obj, Type targetType);
}
internal class System.Runtime.Serialization.Json.ByteArrayHelperWithString : ArrayHelper`2<string, byte> {
    public static ByteArrayHelperWithString Instance;
    private static ByteArrayHelperWithString();
    internal void WriteArray(XmlWriter writer, Byte[] array, int offset, int count);
    protected virtual int ReadArray(XmlDictionaryReader reader, string localName, string namespaceUri, Byte[] array, int offset, int count);
    protected virtual void WriteArray(XmlDictionaryWriter writer, string prefix, string localName, string namespaceUri, Byte[] array, int offset, int count);
    private void ThrowConversionException(string value, string type);
    private byte ToByte(int value);
}
[TypeForwardedFromAttribute("System.ServiceModel.Web, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")]
public class System.Runtime.Serialization.Json.DataContractJsonSerializer : XmlObjectSerializer {
    internal IList`1<Type> knownTypeList;
    internal Dictionary`2<XmlQualifiedName, DataContract> knownDataContracts;
    private EmitTypeInformation emitTypeInformation;
    private IDataContractSurrogate dataContractSurrogate;
    private bool ignoreExtensionDataObject;
    private ReadOnlyCollection`1<Type> knownTypeCollection;
    private int maxItemsInObjectGraph;
    private DataContract rootContract;
    private XmlDictionaryString rootName;
    private bool rootNameRequiresMapping;
    private Type rootType;
    private bool serializeReadOnlyTypes;
    private DateTimeFormat dateTimeFormat;
    private bool useSimpleDictionaryFormat;
    public IDataContractSurrogate DataContractSurrogate { get; }
    public bool IgnoreExtensionDataObject { get; }
    public ReadOnlyCollection`1<Type> KnownTypes { get; }
    internal Dictionary`2<XmlQualifiedName, DataContract> KnownDataContracts { get; }
    public int MaxItemsInObjectGraph { get; }
    internal bool AlwaysEmitTypeInformation { get; }
    public EmitTypeInformation EmitTypeInformation { get; }
    public bool SerializeReadOnlyTypes { get; }
    public DateTimeFormat DateTimeFormat { get; }
    public bool UseSimpleDictionaryFormat { get; }
    private DataContract RootContract { get; }
    private XmlDictionaryString RootName { get; }
    public DataContractJsonSerializer(Type type);
    public DataContractJsonSerializer(Type type, string rootName);
    public DataContractJsonSerializer(Type type, XmlDictionaryString rootName);
    public DataContractJsonSerializer(Type type, IEnumerable`1<Type> knownTypes);
    public DataContractJsonSerializer(Type type, string rootName, IEnumerable`1<Type> knownTypes);
    public DataContractJsonSerializer(Type type, XmlDictionaryString rootName, IEnumerable`1<Type> knownTypes);
    public DataContractJsonSerializer(Type type, IEnumerable`1<Type> knownTypes, int maxItemsInObjectGraph, bool ignoreExtensionDataObject, IDataContractSurrogate dataContractSurrogate, bool alwaysEmitTypeInformation);
    public DataContractJsonSerializer(Type type, string rootName, IEnumerable`1<Type> knownTypes, int maxItemsInObjectGraph, bool ignoreExtensionDataObject, IDataContractSurrogate dataContractSurrogate, bool alwaysEmitTypeInformation);
    public DataContractJsonSerializer(Type type, XmlDictionaryString rootName, IEnumerable`1<Type> knownTypes, int maxItemsInObjectGraph, bool ignoreExtensionDataObject, IDataContractSurrogate dataContractSurrogate, bool alwaysEmitTypeInformation);
    public DataContractJsonSerializer(Type type, DataContractJsonSerializerSettings settings);
    public IDataContractSurrogate get_DataContractSurrogate();
    public bool get_IgnoreExtensionDataObject();
    public ReadOnlyCollection`1<Type> get_KnownTypes();
    internal virtual Dictionary`2<XmlQualifiedName, DataContract> get_KnownDataContracts();
    public int get_MaxItemsInObjectGraph();
    internal bool get_AlwaysEmitTypeInformation();
    public EmitTypeInformation get_EmitTypeInformation();
    public bool get_SerializeReadOnlyTypes();
    public DateTimeFormat get_DateTimeFormat();
    public bool get_UseSimpleDictionaryFormat();
    private DataContract get_RootContract();
    private XmlDictionaryString get_RootName();
    public virtual bool IsStartObject(XmlReader reader);
    public virtual bool IsStartObject(XmlDictionaryReader reader);
    public virtual object ReadObject(Stream stream);
    public virtual object ReadObject(XmlReader reader);
    public virtual object ReadObject(XmlReader reader, bool verifyObjectName);
    public virtual object ReadObject(XmlDictionaryReader reader);
    public virtual object ReadObject(XmlDictionaryReader reader, bool verifyObjectName);
    public virtual void WriteEndObject(XmlWriter writer);
    public virtual void WriteEndObject(XmlDictionaryWriter writer);
    public virtual void WriteObject(Stream stream, object graph);
    public virtual void WriteObject(XmlWriter writer, object graph);
    public virtual void WriteObject(XmlDictionaryWriter writer, object graph);
    public virtual void WriteObjectContent(XmlWriter writer, object graph);
    public virtual void WriteObjectContent(XmlDictionaryWriter writer, object graph);
    public virtual void WriteStartObject(XmlWriter writer, object graph);
    public virtual void WriteStartObject(XmlDictionaryWriter writer, object graph);
    internal static bool CheckIfJsonNameRequiresMapping(string jsonName);
    internal static bool CheckIfJsonNameRequiresMapping(XmlDictionaryString jsonName);
    internal static bool CheckIfXmlNameRequiresMapping(string xmlName);
    internal static bool CheckIfXmlNameRequiresMapping(XmlDictionaryString xmlName);
    internal static string ConvertXmlNameToJsonName(string xmlName);
    internal static XmlDictionaryString ConvertXmlNameToJsonName(XmlDictionaryString xmlName);
    internal static bool IsJsonLocalName(XmlReaderDelegator reader, string elementName);
    internal static object ReadJsonValue(DataContract contract, XmlReaderDelegator reader, XmlObjectSerializerReadContextComplexJson context);
    internal static void WriteJsonNull(XmlWriterDelegator writer);
    internal static void WriteJsonValue(JsonDataContract contract, XmlWriterDelegator writer, object graph, XmlObjectSerializerWriteContextComplexJson context, RuntimeTypeHandle declaredTypeHandle);
    internal virtual Type GetDeserializeType();
    internal virtual Type GetSerializeType(object graph);
    internal virtual bool InternalIsStartObject(XmlReaderDelegator reader);
    internal virtual object InternalReadObject(XmlReaderDelegator xmlReader, bool verifyObjectName);
    internal virtual void InternalWriteEndObject(XmlWriterDelegator writer);
    internal virtual void InternalWriteObject(XmlWriterDelegator writer, object graph);
    internal virtual void InternalWriteObjectContent(XmlWriterDelegator writer, object graph);
    internal virtual void InternalWriteStartObject(XmlWriterDelegator writer, object graph);
    private void AddCollectionItemTypeToKnownTypes(Type knownType);
    private void Initialize(Type type, IEnumerable`1<Type> knownTypes, int maxItemsInObjectGraph, bool ignoreExtensionDataObject, IDataContractSurrogate dataContractSurrogate, EmitTypeInformation emitTypeInformation, bool serializeReadOnlyTypes, DateTimeFormat dateTimeFormat, bool useSimpleDictionaryFormat);
    private void Initialize(Type type, XmlDictionaryString rootName, IEnumerable`1<Type> knownTypes, int maxItemsInObjectGraph, bool ignoreExtensionDataObject, IDataContractSurrogate dataContractSurrogate, EmitTypeInformation emitTypeInformation, bool serializeReadOnlyTypes, DateTimeFormat dateTimeFormat, bool useSimpleDictionaryFormat);
    internal static void CheckIfTypeIsReference(DataContract dataContract);
    internal static DataContract GetDataContract(DataContract declaredTypeContract, Type declaredType, Type objectType);
}
public class System.Runtime.Serialization.Json.DataContractJsonSerializerSettings : object {
    private int maxItemsInObjectGraph;
    [CompilerGeneratedAttribute]
private string <RootName>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<Type> <KnownTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreExtensionDataObject>k__BackingField;
    [CompilerGeneratedAttribute]
private IDataContractSurrogate <DataContractSurrogate>k__BackingField;
    [CompilerGeneratedAttribute]
private EmitTypeInformation <EmitTypeInformation>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeFormat <DateTimeFormat>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SerializeReadOnlyTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseSimpleDictionaryFormat>k__BackingField;
    public string RootName { get; public set; }
    public IEnumerable`1<Type> KnownTypes { get; public set; }
    public int MaxItemsInObjectGraph { get; public set; }
    public bool IgnoreExtensionDataObject { get; public set; }
    public IDataContractSurrogate DataContractSurrogate { get; public set; }
    public EmitTypeInformation EmitTypeInformation { get; public set; }
    public DateTimeFormat DateTimeFormat { get; public set; }
    public bool SerializeReadOnlyTypes { get; public set; }
    public bool UseSimpleDictionaryFormat { get; public set; }
    [CompilerGeneratedAttribute]
public string get_RootName();
    [CompilerGeneratedAttribute]
public void set_RootName(string value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<Type> get_KnownTypes();
    [CompilerGeneratedAttribute]
public void set_KnownTypes(IEnumerable`1<Type> value);
    public int get_MaxItemsInObjectGraph();
    public void set_MaxItemsInObjectGraph(int value);
    [CompilerGeneratedAttribute]
public bool get_IgnoreExtensionDataObject();
    [CompilerGeneratedAttribute]
public void set_IgnoreExtensionDataObject(bool value);
    [CompilerGeneratedAttribute]
public IDataContractSurrogate get_DataContractSurrogate();
    [CompilerGeneratedAttribute]
public void set_DataContractSurrogate(IDataContractSurrogate value);
    [CompilerGeneratedAttribute]
public EmitTypeInformation get_EmitTypeInformation();
    [CompilerGeneratedAttribute]
public void set_EmitTypeInformation(EmitTypeInformation value);
    [CompilerGeneratedAttribute]
public DateTimeFormat get_DateTimeFormat();
    [CompilerGeneratedAttribute]
public void set_DateTimeFormat(DateTimeFormat value);
    [CompilerGeneratedAttribute]
public bool get_SerializeReadOnlyTypes();
    [CompilerGeneratedAttribute]
public void set_SerializeReadOnlyTypes(bool value);
    [CompilerGeneratedAttribute]
public bool get_UseSimpleDictionaryFormat();
    [CompilerGeneratedAttribute]
public void set_UseSimpleDictionaryFormat(bool value);
}
[TypeForwardedFromAttribute("System.ServiceModel.Web, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")]
public interface System.Runtime.Serialization.Json.IXmlJsonReaderInitializer {
    public abstract virtual void SetInput(Byte[] buffer, int offset, int count, Encoding encoding, XmlDictionaryReaderQuotas quotas, OnXmlDictionaryReaderClose onClose);
    public abstract virtual void SetInput(Stream stream, Encoding encoding, XmlDictionaryReaderQuotas quotas, OnXmlDictionaryReaderClose onClose);
}
[TypeForwardedFromAttribute("System.ServiceModel.Web, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")]
public interface System.Runtime.Serialization.Json.IXmlJsonWriterInitializer {
    public abstract virtual void SetOutput(Stream stream, Encoding encoding, bool ownsStream);
}
internal class System.Runtime.Serialization.Json.JsonByteArrayDataContract : JsonDataContract {
    public JsonByteArrayDataContract(ByteArrayDataContract traditionalByteArrayDataContract);
    public virtual object ReadJsonValueCore(XmlReaderDelegator jsonReader, XmlObjectSerializerReadContextComplexJson context);
}
internal class System.Runtime.Serialization.Json.JsonClassDataContract : JsonDataContract {
    [SecurityCriticalAttribute]
private JsonClassDataContractCriticalHelper helper;
    internal JsonFormatClassReaderDelegate JsonFormatReaderDelegate { get; }
    internal JsonFormatClassWriterDelegate JsonFormatWriterDelegate { get; }
    internal XmlDictionaryString[] MemberNames { get; }
    internal string TypeName { get; }
    private ClassDataContract TraditionalClassDataContract { get; }
    [SecuritySafeCriticalAttribute]
public JsonClassDataContract(ClassDataContract traditionalDataContract);
    [SecuritySafeCriticalAttribute]
internal JsonFormatClassReaderDelegate get_JsonFormatReaderDelegate();
    [SecuritySafeCriticalAttribute]
internal JsonFormatClassWriterDelegate get_JsonFormatWriterDelegate();
    [SecuritySafeCriticalAttribute]
internal XmlDictionaryString[] get_MemberNames();
    [SecuritySafeCriticalAttribute]
internal virtual string get_TypeName();
    [SecuritySafeCriticalAttribute]
private ClassDataContract get_TraditionalClassDataContract();
    public virtual object ReadJsonValueCore(XmlReaderDelegator jsonReader, XmlObjectSerializerReadContextComplexJson context);
    public virtual void WriteJsonValueCore(XmlWriterDelegator jsonWriter, object obj, XmlObjectSerializerWriteContextComplexJson context, RuntimeTypeHandle declaredTypeHandle);
}
internal class System.Runtime.Serialization.Json.JsonCollectionDataContract : JsonDataContract {
    [SecurityCriticalAttribute]
private JsonCollectionDataContractCriticalHelper helper;
    internal JsonFormatCollectionReaderDelegate JsonFormatReaderDelegate { get; }
    internal JsonFormatGetOnlyCollectionReaderDelegate JsonFormatGetOnlyReaderDelegate { get; }
    internal JsonFormatCollectionWriterDelegate JsonFormatWriterDelegate { get; }
    private CollectionDataContract TraditionalCollectionDataContract { get; }
    [SecuritySafeCriticalAttribute]
public JsonCollectionDataContract(CollectionDataContract traditionalDataContract);
    [SecuritySafeCriticalAttribute]
internal JsonFormatCollectionReaderDelegate get_JsonFormatReaderDelegate();
    [SecuritySafeCriticalAttribute]
internal JsonFormatGetOnlyCollectionReaderDelegate get_JsonFormatGetOnlyReaderDelegate();
    [SecuritySafeCriticalAttribute]
internal JsonFormatCollectionWriterDelegate get_JsonFormatWriterDelegate();
    [SecuritySafeCriticalAttribute]
private CollectionDataContract get_TraditionalCollectionDataContract();
    public virtual object ReadJsonValueCore(XmlReaderDelegator jsonReader, XmlObjectSerializerReadContextComplexJson context);
    public virtual void WriteJsonValueCore(XmlWriterDelegator jsonWriter, object obj, XmlObjectSerializerWriteContextComplexJson context, RuntimeTypeHandle declaredTypeHandle);
}
internal class System.Runtime.Serialization.Json.JsonDataContract : object {
    [SecurityCriticalAttribute]
private JsonDataContractCriticalHelper helper;
    internal string TypeName { get; }
    protected JsonDataContractCriticalHelper Helper { get; }
    protected DataContract TraditionalDataContract { get; }
    private Dictionary`2<XmlQualifiedName, DataContract> KnownDataContracts { get; }
    [SecuritySafeCriticalAttribute]
protected JsonDataContract(DataContract traditionalDataContract);
    [SecuritySafeCriticalAttribute]
protected JsonDataContract(JsonDataContractCriticalHelper helper);
    internal virtual string get_TypeName();
    [SecurityCriticalAttribute]
protected JsonDataContractCriticalHelper get_Helper();
    [SecuritySafeCriticalAttribute]
protected DataContract get_TraditionalDataContract();
    [SecuritySafeCriticalAttribute]
private Dictionary`2<XmlQualifiedName, DataContract> get_KnownDataContracts();
    [SecuritySafeCriticalAttribute]
public static JsonDataContract GetJsonDataContract(DataContract traditionalDataContract);
    public object ReadJsonValue(XmlReaderDelegator jsonReader, XmlObjectSerializerReadContextComplexJson context);
    public virtual object ReadJsonValueCore(XmlReaderDelegator jsonReader, XmlObjectSerializerReadContextComplexJson context);
    public void WriteJsonValue(XmlWriterDelegator jsonWriter, object obj, XmlObjectSerializerWriteContextComplexJson context, RuntimeTypeHandle declaredTypeHandle);
    public virtual void WriteJsonValueCore(XmlWriterDelegator jsonWriter, object obj, XmlObjectSerializerWriteContextComplexJson context, RuntimeTypeHandle declaredTypeHandle);
    protected static object HandleReadValue(object obj, XmlObjectSerializerReadContext context);
    protected static bool TryReadNullAtTopLevel(XmlReaderDelegator reader);
    protected void PopKnownDataContracts(XmlObjectSerializerContext context);
    protected void PushKnownDataContracts(XmlObjectSerializerContext context);
}
internal class System.Runtime.Serialization.Json.JsonEncodingStreamWrapper : Stream {
    private static UnicodeEncoding SafeBEUTF16;
    private static UnicodeEncoding SafeUTF16;
    private static UTF8Encoding SafeUTF8;
    private static UnicodeEncoding ValidatingBEUTF16;
    private static UnicodeEncoding ValidatingUTF16;
    private static UTF8Encoding ValidatingUTF8;
    private static int BufferLength;
    private Byte[] byteBuffer;
    private int byteCount;
    private int byteOffset;
    private Byte[] bytes;
    private Char[] chars;
    private Decoder dec;
    private Encoder enc;
    private Encoding encoding;
    private SupportedEncoding encodingCode;
    private bool isReading;
    private Stream stream;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanTimeout { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public int ReadTimeout { get; public set; }
    public int WriteTimeout { get; public set; }
    public JsonEncodingStreamWrapper(Stream stream, Encoding encoding, bool isReader);
    private static JsonEncodingStreamWrapper();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanTimeout();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual int get_ReadTimeout();
    public virtual void set_ReadTimeout(int value);
    public virtual int get_WriteTimeout();
    public virtual void set_WriteTimeout(int value);
    public static ArraySegment`1<byte> ProcessBuffer(Byte[] buffer, int offset, int count, Encoding encoding);
    public virtual void Close();
    public virtual void Flush();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int ReadByte();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void WriteByte(byte b);
    private static Encoding GetEncoding(SupportedEncoding e);
    private static string GetEncodingName(SupportedEncoding enc);
    private static SupportedEncoding GetSupportedEncoding(Encoding encoding);
    private static SupportedEncoding ReadEncoding(byte b1, byte b2);
    private static void ThrowExpectedEncodingMismatch(SupportedEncoding expEnc, SupportedEncoding actualEnc);
    private void CleanupCharBreak();
    private void EnsureBuffers();
    private void EnsureByteBuffer();
    private void FillBuffer(int count);
    private void InitForReading(Stream inputStream, Encoding expectedEncoding);
    private void InitForWriting(Stream outputStream, Encoding writeEncoding);
    private SupportedEncoding ReadEncoding();
}
internal class System.Runtime.Serialization.Json.JsonEnumDataContract : JsonDataContract {
    [SecurityCriticalAttribute]
private JsonEnumDataContractCriticalHelper helper;
    public bool IsULong { get; }
    [SecuritySafeCriticalAttribute]
public JsonEnumDataContract(EnumDataContract traditionalDataContract);
    [SecuritySafeCriticalAttribute]
public bool get_IsULong();
    public virtual object ReadJsonValueCore(XmlReaderDelegator jsonReader, XmlObjectSerializerReadContextComplexJson context);
    public virtual void WriteJsonValueCore(XmlWriterDelegator jsonWriter, object obj, XmlObjectSerializerWriteContextComplexJson context, RuntimeTypeHandle declaredTypeHandle);
}
internal class System.Runtime.Serialization.Json.JsonFormatClassReaderDelegate : MulticastDelegate {
    public JsonFormatClassReaderDelegate(object object, IntPtr method);
    public virtual object Invoke(XmlReaderDelegator xmlReader, XmlObjectSerializerReadContextComplexJson context, XmlDictionaryString emptyDictionaryString, XmlDictionaryString[] memberNames);
    public virtual IAsyncResult BeginInvoke(XmlReaderDelegator xmlReader, XmlObjectSerializerReadContextComplexJson context, XmlDictionaryString emptyDictionaryString, XmlDictionaryString[] memberNames, AsyncCallback callback, object object);
    public virtual object EndInvoke(IAsyncResult result);
}
internal class System.Runtime.Serialization.Json.JsonFormatClassWriterDelegate : MulticastDelegate {
    public JsonFormatClassWriterDelegate(object object, IntPtr method);
    public virtual void Invoke(XmlWriterDelegator xmlWriter, object obj, XmlObjectSerializerWriteContextComplexJson context, ClassDataContract dataContract, XmlDictionaryString[] memberNames);
    public virtual IAsyncResult BeginInvoke(XmlWriterDelegator xmlWriter, object obj, XmlObjectSerializerWriteContextComplexJson context, ClassDataContract dataContract, XmlDictionaryString[] memberNames, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.Runtime.Serialization.Json.JsonFormatCollectionReaderDelegate : MulticastDelegate {
    public JsonFormatCollectionReaderDelegate(object object, IntPtr method);
    public virtual object Invoke(XmlReaderDelegator xmlReader, XmlObjectSerializerReadContextComplexJson context, XmlDictionaryString emptyDictionaryString, XmlDictionaryString itemName, CollectionDataContract collectionContract);
    public virtual IAsyncResult BeginInvoke(XmlReaderDelegator xmlReader, XmlObjectSerializerReadContextComplexJson context, XmlDictionaryString emptyDictionaryString, XmlDictionaryString itemName, CollectionDataContract collectionContract, AsyncCallback callback, object object);
    public virtual object EndInvoke(IAsyncResult result);
}
internal class System.Runtime.Serialization.Json.JsonFormatCollectionWriterDelegate : MulticastDelegate {
    public JsonFormatCollectionWriterDelegate(object object, IntPtr method);
    public virtual void Invoke(XmlWriterDelegator xmlWriter, object obj, XmlObjectSerializerWriteContextComplexJson context, CollectionDataContract dataContract);
    public virtual IAsyncResult BeginInvoke(XmlWriterDelegator xmlWriter, object obj, XmlObjectSerializerWriteContextComplexJson context, CollectionDataContract dataContract, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.Runtime.Serialization.Json.JsonFormatGetOnlyCollectionReaderDelegate : MulticastDelegate {
    public JsonFormatGetOnlyCollectionReaderDelegate(object object, IntPtr method);
    public virtual void Invoke(XmlReaderDelegator xmlReader, XmlObjectSerializerReadContextComplexJson context, XmlDictionaryString emptyDictionaryString, XmlDictionaryString itemName, CollectionDataContract collectionContract);
    public virtual IAsyncResult BeginInvoke(XmlReaderDelegator xmlReader, XmlObjectSerializerReadContextComplexJson context, XmlDictionaryString emptyDictionaryString, XmlDictionaryString itemName, CollectionDataContract collectionContract, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.Runtime.Serialization.Json.JsonFormatReaderGenerator : object {
    [SecurityCriticalAttribute]
private CriticalHelper helper;
    [SecurityCriticalAttribute]
public JsonFormatClassReaderDelegate GenerateClassReader(ClassDataContract classContract);
    [SecurityCriticalAttribute]
public JsonFormatCollectionReaderDelegate GenerateCollectionReader(CollectionDataContract collectionContract);
    [SecurityCriticalAttribute]
public JsonFormatGetOnlyCollectionReaderDelegate GenerateGetOnlyCollectionReader(CollectionDataContract collectionContract);
}
internal class System.Runtime.Serialization.Json.JsonFormatReaderInterpreter : object {
    private bool is_get_only_collection;
    private ClassDataContract classContract;
    private CollectionDataContract collectionContract;
    private object objectLocal;
    private Type objectType;
    private XmlReaderDelegator xmlReader;
    private XmlObjectSerializerReadContextComplexJson context;
    private XmlDictionaryString[] memberNames;
    private XmlDictionaryString emptyDictionaryString;
    private XmlDictionaryString itemName;
    private XmlDictionaryString itemNamespace;
    public JsonFormatReaderInterpreter(ClassDataContract classContract);
    public JsonFormatReaderInterpreter(CollectionDataContract collectionContract, bool isGetOnly);
    public object ReadFromJson(XmlReaderDelegator xmlReader, XmlObjectSerializerReadContextComplexJson context, XmlDictionaryString emptyDictionaryString, XmlDictionaryString[] memberNames);
    public object ReadCollectionFromJson(XmlReaderDelegator xmlReader, XmlObjectSerializerReadContextComplexJson context, XmlDictionaryString emptyDictionaryString, XmlDictionaryString itemName, CollectionDataContract collectionContract);
    public void ReadGetOnlyCollectionFromJson(XmlReaderDelegator xmlReader, XmlObjectSerializerReadContextComplexJson context, XmlDictionaryString emptyDictionaryString, XmlDictionaryString itemName, CollectionDataContract collectionContract);
    private void CreateObject(ClassDataContract classContract);
    private void InvokeOnDeserializing(ClassDataContract classContract);
    private void InvokeOnDeserialized(ClassDataContract classContract);
    private bool HasFactoryMethod(ClassDataContract classContract);
    private bool InvokeFactoryMethod(ClassDataContract classContract);
    private void ReadISerializable(ClassDataContract classContract);
    private void ReadClass(ClassDataContract classContract);
    private void ReadMembers(ClassDataContract classContract, ExtensionDataObject extensionData);
    private int ReadMembers(int index, ClassDataContract classContract, BitFlagsGenerator expectedElements, Int32& memberIndex);
    private bool CheckRequiredElements(BitFlagsGenerator expectedElements, Byte[] requiredElements);
    private int SetRequiredElements(ClassDataContract contract, Byte[] requiredElements);
    private void SetExpectedElements(BitFlagsGenerator expectedElements, int startIndex);
    private void ResetExpectedElements(BitFlagsGenerator expectedElements, int index);
    private object ReadValue(Type type, string name);
    private object InternalDeserialize(Type type, string name);
    private object WrapNullableObject(Type innerType, object innerValue, Type outerType, int nullables);
    private void ReadCollection(CollectionDataContract collectionContract);
    private void ReadSimpleDictionary(CollectionDataContract collectionContract, Type keyValueType);
    private void ReadGetOnlyCollection(CollectionDataContract collectionContract);
    private bool TryReadPrimitiveArray(Type itemType, Boolean& readResult);
    private object ReadCollectionItem(CollectionDataContract collectionContract, Type itemType);
    private void StoreCollectionValue(object collection, Type valueType, object value, CollectionDataContract collectionContract);
    private void HandleUnexpectedItemInCollection(Int32& iterator);
    private bool IsStartElement(XmlDictionaryString name, XmlDictionaryString ns);
    private bool IsStartElement();
    private bool IsEndElement();
    private void ThrowUnexpectedStateException(XmlNodeType expectedState);
    private void ThrowSerializationException(string msg, Object[] values);
}
internal class System.Runtime.Serialization.Json.JsonFormatWriterGenerator : object {
    [SecurityCriticalAttribute]
private CriticalHelper helper;
    [SecurityCriticalAttribute]
internal JsonFormatClassWriterDelegate GenerateClassWriter(ClassDataContract classContract);
    [SecurityCriticalAttribute]
internal JsonFormatCollectionWriterDelegate GenerateCollectionWriter(CollectionDataContract collectionContract);
}
internal class System.Runtime.Serialization.Json.JsonFormatWriterInterpreter : object {
    private ClassDataContract classContract;
    private CollectionDataContract collectionContract;
    private XmlWriterDelegator writer;
    private object obj;
    private XmlObjectSerializerWriteContextComplexJson context;
    private DataContract dataContract;
    private object objLocal;
    private XmlDictionaryString[] memberNames;
    private int typeIndex;
    private int childElementIndex;
    private ClassDataContract classDataContract { get; }
    private CollectionDataContract collectionDataContract { get; }
    public JsonFormatWriterInterpreter(ClassDataContract classContract);
    public JsonFormatWriterInterpreter(CollectionDataContract collectionContract);
    private ClassDataContract get_classDataContract();
    private CollectionDataContract get_collectionDataContract();
    public void WriteToJson(XmlWriterDelegator xmlWriter, object obj, XmlObjectSerializerWriteContextComplexJson context, ClassDataContract dataContract, XmlDictionaryString[] memberNames);
    public void WriteCollectionToJson(XmlWriterDelegator xmlWriter, object obj, XmlObjectSerializerWriteContextComplexJson context, CollectionDataContract dataContract);
    private void InitArgs(Type objType);
    private void InvokeOnSerializing(ClassDataContract classContract, object objSerialized, XmlObjectSerializerWriteContext context);
    private void InvokeOnSerialized(ClassDataContract classContract, object objSerialized, XmlObjectSerializerWriteContext context);
    private void WriteClass(ClassDataContract classContract);
    private void WriteCollection(CollectionDataContract collectionContract);
    private int WriteMembers(ClassDataContract classContract, ExtensionDataObject extensionData, ClassDataContract derivedMostClassContract);
    internal bool IsDefaultValue(Type type, object value);
    internal object GetDefaultValue(Type type);
    private void WriteStartElement(object nameLocal, int nameIndex);
    private void WriteEndElement();
    private void WriteArrayAttribute();
    private void WriteObjectAttribute();
    private void WriteValue(Type memberType, object memberValue);
    private void InternalSerialize(MethodInfo methodInfo, Func`1<object> memberValue, Type memberType, bool writeXsiType);
    private object UnwrapNullableObject(Func`1<object> memberValue, Type& memberType, Boolean& isNull);
    private bool TryWritePrimitive(Type type, Func`1<object> value, MemberInfo memberInfo, Nullable`1<int> arrayItemIndex, XmlDictionaryString name, int nameIndex);
    private bool TryWritePrimitiveArray(Type type, Type itemType, Func`1<object> value, XmlDictionaryString itemName);
    private object LoadMemberValue(DataMember member);
    [CompilerGeneratedAttribute]
private object <WriteCollection>b__22_0();
}
internal static class System.Runtime.Serialization.Json.JsonGlobals : object {
    public static int DataContractXsdBaseNamespaceLength;
    public static XmlDictionaryString dDictionaryString;
    public static Char[] floatingPointCharacters;
    public static XmlDictionaryString itemDictionaryString;
    public static XmlDictionaryString rootDictionaryString;
    public static long unixEpochTicks;
    public static string applicationJsonMediaType;
    public static string arrayString;
    public static string booleanString;
    public static string CacheControlString;
    public static byte CollectionByte;
    public static char CollectionChar;
    public static string DateTimeEndGuardReader;
    public static string DateTimeEndGuardWriter;
    public static string DateTimeStartGuardReader;
    public static string DateTimeStartGuardWriter;
    public static string dString;
    public static byte EndCollectionByte;
    public static char EndCollectionChar;
    public static byte EndObjectByte;
    public static char EndObjectChar;
    public static string ExpiresString;
    public static string IfModifiedSinceString;
    public static string itemString;
    public static string jsonerrorString;
    public static string KeyString;
    public static string LastModifiedString;
    public static int maxScopeSize;
    public static byte MemberSeparatorByte;
    public static char MemberSeparatorChar;
    public static byte NameValueSeparatorByte;
    public static char NameValueSeparatorChar;
    public static string NameValueSeparatorString;
    public static string nullString;
    public static string numberString;
    public static byte ObjectByte;
    public static char ObjectChar;
    public static string objectString;
    public static string publicString;
    public static byte QuoteByte;
    public static char QuoteChar;
    public static string rootString;
    public static string serverTypeString;
    public static string stringString;
    public static string textJsonMediaType;
    public static string trueString;
    public static string typeString;
    public static string ValueString;
    public static char WhitespaceChar;
    public static string xmlnsPrefix;
    public static string xmlPrefix;
    private static JsonGlobals();
}
internal enum System.Runtime.Serialization.Json.JsonNodeType : Enum {
    public int value__;
    public static JsonNodeType None;
    public static JsonNodeType Object;
    public static JsonNodeType Element;
    public static JsonNodeType EndElement;
    public static JsonNodeType QuotedText;
    public static JsonNodeType StandaloneText;
    public static JsonNodeType Collection;
}
internal class System.Runtime.Serialization.Json.JsonObjectDataContract : JsonDataContract {
    public JsonObjectDataContract(DataContract traditionalDataContract);
    public virtual object ReadJsonValueCore(XmlReaderDelegator jsonReader, XmlObjectSerializerReadContextComplexJson context);
    public virtual void WriteJsonValueCore(XmlWriterDelegator jsonWriter, object obj, XmlObjectSerializerWriteContextComplexJson context, RuntimeTypeHandle declaredTypeHandle);
    internal static object ParseJsonNumber(string value, TypeCode& objectTypeCode);
    private static object ParseJsonNumber(string value);
}
internal class System.Runtime.Serialization.Json.JsonQNameDataContract : JsonDataContract {
    public JsonQNameDataContract(QNameDataContract traditionalQNameDataContract);
    public virtual object ReadJsonValueCore(XmlReaderDelegator jsonReader, XmlObjectSerializerReadContextComplexJson context);
}
internal class System.Runtime.Serialization.Json.JsonReaderDelegator : XmlReaderDelegator {
    private DateTimeFormat dateTimeFormat;
    private DateTimeArrayJsonHelperWithString dateTimeArrayHelper;
    internal XmlDictionaryReaderQuotas ReaderQuotas { get; }
    private DateTimeArrayJsonHelperWithString DateTimeArrayHelper { get; }
    public JsonReaderDelegator(XmlReader reader);
    public JsonReaderDelegator(XmlReader reader, DateTimeFormat dateTimeFormat);
    internal XmlDictionaryReaderQuotas get_ReaderQuotas();
    private DateTimeArrayJsonHelperWithString get_DateTimeArrayHelper();
    internal static XmlQualifiedName ParseQualifiedName(string qname);
    internal virtual char ReadContentAsChar();
    internal virtual XmlQualifiedName ReadContentAsQName();
    internal virtual char ReadElementContentAsChar();
    internal virtual Byte[] ReadContentAsBase64();
    internal virtual Byte[] ReadElementContentAsBase64();
    internal virtual DateTime ReadContentAsDateTime();
    internal static DateTime ParseJsonDate(string originalDateTimeValue, DateTimeFormat dateTimeFormat);
    internal static DateTime ParseJsonDateInDefaultFormat(string originalDateTimeValue);
    internal virtual DateTime ReadElementContentAsDateTime();
    internal bool TryReadJsonDateTimeArray(XmlObjectSerializerReadContext context, XmlDictionaryString itemName, XmlDictionaryString itemNamespace, int arrayLength, DateTime[]& array);
    internal virtual ulong ReadContentAsUnsignedLong();
    internal virtual ulong ReadElementContentAsUnsignedLong();
}
[TypeForwardedFromAttribute("System.ServiceModel.Web, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")]
public static class System.Runtime.Serialization.Json.JsonReaderWriterFactory : object {
    private static string DefaultIndentChars;
    public static XmlDictionaryReader CreateJsonReader(Stream stream, XmlDictionaryReaderQuotas quotas);
    public static XmlDictionaryReader CreateJsonReader(Byte[] buffer, XmlDictionaryReaderQuotas quotas);
    public static XmlDictionaryReader CreateJsonReader(Stream stream, Encoding encoding, XmlDictionaryReaderQuotas quotas, OnXmlDictionaryReaderClose onClose);
    public static XmlDictionaryReader CreateJsonReader(Byte[] buffer, int offset, int count, XmlDictionaryReaderQuotas quotas);
    public static XmlDictionaryReader CreateJsonReader(Byte[] buffer, int offset, int count, Encoding encoding, XmlDictionaryReaderQuotas quotas, OnXmlDictionaryReaderClose onClose);
    public static XmlDictionaryWriter CreateJsonWriter(Stream stream);
    public static XmlDictionaryWriter CreateJsonWriter(Stream stream, Encoding encoding);
    public static XmlDictionaryWriter CreateJsonWriter(Stream stream, Encoding encoding, bool ownsStream);
    public static XmlDictionaryWriter CreateJsonWriter(Stream stream, Encoding encoding, bool ownsStream, bool indent);
    public static XmlDictionaryWriter CreateJsonWriter(Stream stream, Encoding encoding, bool ownsStream, bool indent, string indentChars);
}
internal class System.Runtime.Serialization.Json.JsonStringDataContract : JsonDataContract {
    public JsonStringDataContract(StringDataContract traditionalStringDataContract);
    public virtual object ReadJsonValueCore(XmlReaderDelegator jsonReader, XmlObjectSerializerReadContextComplexJson context);
}
internal class System.Runtime.Serialization.Json.JsonUriDataContract : JsonDataContract {
    public JsonUriDataContract(UriDataContract traditionalUriDataContract);
    public virtual object ReadJsonValueCore(XmlReaderDelegator jsonReader, XmlObjectSerializerReadContextComplexJson context);
}
internal class System.Runtime.Serialization.Json.JsonWriterDelegator : XmlWriterDelegator {
    private DateTimeFormat dateTimeFormat;
    public JsonWriterDelegator(XmlWriter writer);
    public JsonWriterDelegator(XmlWriter writer, DateTimeFormat dateTimeFormat);
    internal virtual void WriteChar(char value);
    internal virtual void WriteBase64(Byte[] bytes);
    internal virtual void WriteQName(XmlQualifiedName value);
    internal virtual void WriteUnsignedLong(ulong value);
    internal virtual void WriteDecimal(decimal value);
    internal virtual void WriteDouble(double value);
    internal virtual void WriteFloat(float value);
    internal virtual void WriteLong(long value);
    internal virtual void WriteSignedByte(sbyte value);
    internal virtual void WriteUnsignedInt(UInt32 value);
    internal virtual void WriteUnsignedShort(ushort value);
    internal virtual void WriteUnsignedByte(byte value);
    internal virtual void WriteShort(short value);
    internal virtual void WriteBoolean(bool value);
    internal virtual void WriteInt(int value);
    internal void WriteJsonBooleanArray(Boolean[] value, XmlDictionaryString itemName, XmlDictionaryString itemNamespace);
    internal void WriteJsonDateTimeArray(DateTime[] value, XmlDictionaryString itemName, XmlDictionaryString itemNamespace);
    internal void WriteJsonDecimalArray(Decimal[] value, XmlDictionaryString itemName, XmlDictionaryString itemNamespace);
    internal void WriteJsonInt32Array(Int32[] value, XmlDictionaryString itemName, XmlDictionaryString itemNamespace);
    internal void WriteJsonInt64Array(Int64[] value, XmlDictionaryString itemName, XmlDictionaryString itemNamespace);
    internal virtual void WriteDateTime(DateTime value);
    private void WriteDateTimeInDefaultFormat(DateTime value);
    internal void WriteJsonSingleArray(Single[] value, XmlDictionaryString itemName, XmlDictionaryString itemNamespace);
    internal void WriteJsonDoubleArray(Double[] value, XmlDictionaryString itemName, XmlDictionaryString itemNamespace);
    internal virtual void WriteStartElement(string prefix, string localName, string ns);
}
internal class System.Runtime.Serialization.Json.JsonXmlDataContract : JsonDataContract {
    public JsonXmlDataContract(XmlDataContract traditionalXmlDataContract);
    public virtual object ReadJsonValueCore(XmlReaderDelegator jsonReader, XmlObjectSerializerReadContextComplexJson context);
    public virtual void WriteJsonValueCore(XmlWriterDelegator jsonWriter, object obj, XmlObjectSerializerWriteContextComplexJson context, RuntimeTypeHandle declaredTypeHandle);
    private List`1<Type> GetKnownTypesFromContext(XmlObjectSerializerContext context, IList`1<Type> serializerKnownTypeList);
}
internal class System.Runtime.Serialization.Json.XmlJsonReader : XmlBaseReader {
    private static int MaxTextChunk;
    private static Byte[] charType;
    private bool buffered;
    private Byte[] charactersToSkipOnNextRead;
    private JsonComplexTextMode complexTextMode;
    private bool expectingFirstElementInNonPrimitiveChild;
    private int maxBytesPerRead;
    private OnXmlDictionaryReaderClose onReaderClose;
    private bool readServerTypeElement;
    private int scopeDepth;
    private JsonNodeType[] scopes;
    public bool CanCanonicalize { get; }
    public string Value { get; }
    private bool IsAttributeValue { get; }
    private bool IsReadingCollection { get; }
    private bool IsReadingComplexText { get; }
    private static XmlJsonReader();
    public virtual bool get_CanCanonicalize();
    public virtual string get_Value();
    private bool get_IsAttributeValue();
    private bool get_IsReadingCollection();
    private bool get_IsReadingComplexText();
    public virtual void Close();
    public virtual void EndCanonicalization();
    public virtual string GetAttribute(int index);
    public virtual string GetAttribute(string localName, string namespaceUri);
    public virtual string GetAttribute(string name);
    public virtual string GetAttribute(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    public virtual bool Read();
    public virtual decimal ReadContentAsDecimal();
    public virtual int ReadContentAsInt();
    public virtual long ReadContentAsLong();
    public virtual int ReadValueAsBase64(Byte[] buffer, int offset, int count);
    public virtual int ReadValueChunk(Char[] chars, int offset, int count);
    public sealed virtual void SetInput(Byte[] buffer, int offset, int count, Encoding encoding, XmlDictionaryReaderQuotas quotas, OnXmlDictionaryReaderClose onClose);
    public sealed virtual void SetInput(Stream stream, Encoding encoding, XmlDictionaryReaderQuotas quotas, OnXmlDictionaryReaderClose onClose);
    public virtual void StartCanonicalization(Stream stream, bool includeComments, String[] inclusivePrefixes);
    internal static void CheckArray(Array array, int offset, int count);
    protected virtual XmlSigningNodeWriter CreateSigningNodeWriter();
    private static int BreakText(Byte[] buffer, int offset, int length);
    private static int ComputeNumericalTextLength(Byte[] buffer, int offset, int offsetMax);
    private static int ComputeQuotedTextLengthUntilEndQuote(Byte[] buffer, int offset, int offsetMax, Boolean& escaped);
    private static bool IsWhitespace(byte ch);
    private static char ParseChar(string value, NumberStyles style);
    private static int ParseInt(string value, NumberStyles style);
    private void BufferElement();
    private void EnterJsonScope(JsonNodeType currentNodeType);
    private JsonNodeType ExitJsonScope();
    private void MoveToEndElement();
    private void MoveToInitial(XmlDictionaryReaderQuotas quotas, OnXmlDictionaryReaderClose onClose);
    private void ParseAndSetLocalName();
    private void ParseStartElement();
    private void ReadAttributes();
    private void ReadEscapedCharacter(bool moveToText);
    private void ReadNonExistentElementName(StringHandleConstStringType elementName);
    private int ReadNonFFFE();
    private void ReadNumericalText();
    private void ReadQuotedText(bool moveToText);
    private void ReadServerTypeAttribute(bool consumedObjectChar);
    private void ResetState();
    private void SetJsonNameWithMapping(XmlElementNode elementNode);
    private void SkipExpectedByteInBufferReader(byte characterToSkip);
    private void SkipWhitespaceInBufferReader();
    private bool TryGetByte(Byte& ch);
    private string UnescapeJsonString(string val);
}
internal class System.Runtime.Serialization.Json.XmlJsonWriter : XmlDictionaryWriter {
    private static char BACK_SLASH;
    private static char FORWARD_SLASH;
    private static char HIGH_SURROGATE_START;
    private static char LOW_SURROGATE_END;
    private static char MAX_CHAR;
    private static char WHITESPACE;
    private static char CARRIAGE_RETURN;
    private static char NEWLINE;
    private static char BACKSPACE;
    private static char FORM_FEED;
    private static char HORIZONTAL_TABULATION;
    private static string xmlNamespace;
    private static string xmlnsNamespace;
    [SecurityCriticalAttribute]
private static BinHexEncoding binHexEncoding;
    private static Char[] CharacterAbbrevs;
    private string attributeText;
    private JsonDataType dataType;
    private int depth;
    private bool endElementBuffer;
    private bool isWritingDataTypeAttribute;
    private bool isWritingServerTypeAttribute;
    private bool isWritingXmlnsAttribute;
    private bool isWritingXmlnsAttributeDefaultNs;
    private NameState nameState;
    private JsonNodeType nodeType;
    private JsonNodeWriter nodeWriter;
    private JsonNodeType[] scopes;
    private string serverTypeValue;
    private WriteState writeState;
    private bool wroteServerTypeAttribute;
    private bool indent;
    private string indentChars;
    private int indentLevel;
    public XmlWriterSettings Settings { get; }
    public WriteState WriteState { get; }
    public string XmlLang { get; }
    public XmlSpace XmlSpace { get; }
    private static BinHexEncoding BinHexEncoding { get; }
    private bool HasOpenAttribute { get; }
    private bool IsClosed { get; }
    private bool IsWritingCollection { get; }
    private bool IsWritingNameAttribute { get; }
    private bool IsWritingNameWithMapping { get; }
    private bool WrittenNameWithMapping { get; }
    public XmlJsonWriter(bool indent, string indentChars);
    private static Char[] GetCharacterAbbrevs();
    private static bool TryEscapeControlCharacter(char ch, Char& abbrev);
    public virtual XmlWriterSettings get_Settings();
    public virtual WriteState get_WriteState();
    public virtual string get_XmlLang();
    public virtual XmlSpace get_XmlSpace();
    [SecuritySafeCriticalAttribute]
private static BinHexEncoding get_BinHexEncoding();
    private bool get_HasOpenAttribute();
    private bool get_IsClosed();
    private bool get_IsWritingCollection();
    private bool get_IsWritingNameAttribute();
    private bool get_IsWritingNameWithMapping();
    private bool get_WrittenNameWithMapping();
    public virtual void Close();
    public virtual void Flush();
    public virtual string LookupPrefix(string ns);
    public sealed virtual void SetOutput(Stream stream, Encoding encoding, bool ownsStream);
    public virtual void WriteArray(string prefix, string localName, string namespaceUri, Boolean[] array, int offset, int count);
    public virtual void WriteArray(string prefix, string localName, string namespaceUri, Int16[] array, int offset, int count);
    public virtual void WriteArray(string prefix, string localName, string namespaceUri, Int32[] array, int offset, int count);
    public virtual void WriteArray(string prefix, string localName, string namespaceUri, Int64[] array, int offset, int count);
    public virtual void WriteArray(string prefix, string localName, string namespaceUri, Single[] array, int offset, int count);
    public virtual void WriteArray(string prefix, string localName, string namespaceUri, Double[] array, int offset, int count);
    public virtual void WriteArray(string prefix, string localName, string namespaceUri, Decimal[] array, int offset, int count);
    public virtual void WriteArray(string prefix, string localName, string namespaceUri, DateTime[] array, int offset, int count);
    public virtual void WriteArray(string prefix, string localName, string namespaceUri, Guid[] array, int offset, int count);
    public virtual void WriteArray(string prefix, string localName, string namespaceUri, TimeSpan[] array, int offset, int count);
    public virtual void WriteArray(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Boolean[] array, int offset, int count);
    public virtual void WriteArray(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Decimal[] array, int offset, int count);
    public virtual void WriteArray(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Double[] array, int offset, int count);
    public virtual void WriteArray(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Single[] array, int offset, int count);
    public virtual void WriteArray(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Int32[] array, int offset, int count);
    public virtual void WriteArray(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Int64[] array, int offset, int count);
    public virtual void WriteArray(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Int16[] array, int offset, int count);
    public virtual void WriteArray(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, DateTime[] array, int offset, int count);
    public virtual void WriteArray(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Guid[] array, int offset, int count);
    public virtual void WriteArray(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, TimeSpan[] array, int offset, int count);
    public virtual void WriteBase64(Byte[] buffer, int index, int count);
    public virtual void WriteBinHex(Byte[] buffer, int index, int count);
    public virtual void WriteCData(string text);
    public virtual void WriteCharEntity(char ch);
    public virtual void WriteChars(Char[] buffer, int index, int count);
    public virtual void WriteComment(string text);
    public virtual void WriteDocType(string name, string pubid, string sysid, string subset);
    public virtual void WriteEndAttribute();
    public virtual void WriteEndDocument();
    public virtual void WriteEndElement();
    public virtual void WriteEntityRef(string name);
    public virtual void WriteFullEndElement();
    public virtual void WriteProcessingInstruction(string name, string text);
    public virtual void WriteQualifiedName(string localName, string ns);
    public virtual void WriteRaw(string data);
    public virtual void WriteRaw(Char[] buffer, int index, int count);
    public virtual void WriteStartAttribute(string prefix, string localName, string ns);
    public virtual void WriteStartDocument(bool standalone);
    public virtual void WriteStartDocument();
    public virtual void WriteStartElement(string prefix, string localName, string ns);
    public virtual void WriteString(string text);
    public virtual void WriteSurrogateCharEntity(char lowChar, char highChar);
    public virtual void WriteValue(bool value);
    public virtual void WriteValue(decimal value);
    public virtual void WriteValue(double value);
    public virtual void WriteValue(float value);
    public virtual void WriteValue(int value);
    public virtual void WriteValue(long value);
    public virtual void WriteValue(Guid value);
    public virtual void WriteValue(DateTime value);
    public virtual void WriteValue(string value);
    public virtual void WriteValue(TimeSpan value);
    public virtual void WriteValue(UniqueId value);
    public virtual void WriteValue(object value);
    public virtual void WriteWhitespace(string ws);
    public virtual void WriteXmlAttribute(string localName, string value);
    public virtual void WriteXmlAttribute(XmlDictionaryString localName, XmlDictionaryString value);
    public virtual void WriteXmlnsAttribute(string prefix, string namespaceUri);
    public virtual void WriteXmlnsAttribute(string prefix, XmlDictionaryString namespaceUri);
    internal static bool CharacterNeedsEscaping(char ch);
    private static void ThrowClosed();
    private void CheckText(JsonNodeType nextNodeType);
    private void EnterScope(JsonNodeType currentNodeType);
    private JsonNodeType ExitScope();
    private void InitializeWriter();
    private static bool IsUnicodeNewlineCharacter(char c);
    private void StartText();
    private void ThrowIfServerTypeWritten(string dataTypeSpecified);
    private void ThrowInvalidAttributeContent();
    private bool TrySetWritingNameWithMapping(string localName, string ns);
    private void WriteDataTypeServerType();
    [SecuritySafeCriticalAttribute]
private void WriteEscapedJsonString(string str);
    private void WriteIndent();
    private void WriteNewLine();
    private void WriteJsonElementName(string localName);
    private void WriteJsonQuote();
    private void WritePrimitiveValue(object value);
    private void WriteServerTypeAttribute();
    private void WriteValue(ulong value);
    private void WriteValue(Array array);
}
internal class System.Runtime.Serialization.Json.XmlObjectSerializerReadContextComplexJson : XmlObjectSerializerReadContextComplex {
    private string extensionDataValueType;
    private DateTimeFormat dateTimeFormat;
    private bool useSimpleDictionaryFormat;
    internal IList`1<Type> SerializerKnownTypeList { get; }
    public bool UseSimpleDictionaryFormat { get; }
    public XmlObjectSerializerReadContextComplexJson(DataContractJsonSerializer serializer, DataContract rootTypeDataContract);
    internal IList`1<Type> get_SerializerKnownTypeList();
    public bool get_UseSimpleDictionaryFormat();
    protected virtual void StartReadExtensionDataValue(XmlReaderDelegator xmlReader);
    protected virtual IDataNode ReadPrimitiveExtensionDataValue(XmlReaderDelegator xmlReader, string dataContractName, string dataContractNamespace);
    private IDataNode ReadNumericalPrimitiveExtensionDataValue(XmlReaderDelegator xmlReader);
    internal static XmlObjectSerializerReadContextComplexJson CreateContext(DataContractJsonSerializer serializer, DataContract rootTypeDataContract);
    internal virtual int GetArraySize();
    protected virtual object ReadDataContractValue(DataContract dataContract, XmlReaderDelegator reader);
    internal virtual void ReadAttributes(XmlReaderDelegator xmlReader);
    public int GetJsonMemberIndex(XmlReaderDelegator xmlReader, XmlDictionaryString[] memberNames, int memberIndex, ExtensionDataObject extensionData);
    internal static bool TryGetJsonLocalName(XmlReaderDelegator xmlReader, String& name);
    public static string GetJsonMemberName(XmlReaderDelegator xmlReader);
    public static void ThrowMissingRequiredMembers(object obj, XmlDictionaryString[] memberNames, Byte[] expectedElements, Byte[] requiredElements);
    public static void ThrowDuplicateMemberException(object obj, XmlDictionaryString[] memberNames, int memberIndex);
    [SecuritySafeCriticalAttribute]
private static bool IsBitSet(Byte[] bytes, int bitIndex);
    protected virtual bool IsReadingCollectionExtensionData(XmlReaderDelegator xmlReader);
    protected virtual bool IsReadingClassExtensionData(XmlReaderDelegator xmlReader);
    protected virtual XmlReaderDelegator CreateReaderDelegatorForReader(XmlReader xmlReader);
    internal virtual DataContract GetDataContract(RuntimeTypeHandle typeHandle, Type type);
    internal virtual DataContract GetDataContractSkipValidation(int typeId, RuntimeTypeHandle typeHandle, Type type);
    internal virtual DataContract GetDataContract(int id, RuntimeTypeHandle typeHandle);
    protected virtual DataContract ResolveDataContractFromRootDataContract(XmlQualifiedName typeQName);
}
internal class System.Runtime.Serialization.Json.XmlObjectSerializerWriteContextComplexJson : XmlObjectSerializerWriteContextComplex {
    private EmitTypeInformation emitXsiType;
    private bool perCallXsiTypeAlreadyEmitted;
    private bool useSimpleDictionaryFormat;
    internal IList`1<Type> SerializerKnownTypeList { get; }
    public bool UseSimpleDictionaryFormat { get; }
    internal XmlDictionaryString CollectionItemName { get; }
    public XmlObjectSerializerWriteContextComplexJson(DataContractJsonSerializer serializer, DataContract rootTypeDataContract);
    internal static XmlObjectSerializerWriteContextComplexJson CreateContext(DataContractJsonSerializer serializer, DataContract rootTypeDataContract);
    internal IList`1<Type> get_SerializerKnownTypeList();
    public bool get_UseSimpleDictionaryFormat();
    internal virtual bool WriteClrTypeInfo(XmlWriterDelegator xmlWriter, Type dataContractType, string clrTypeName, string clrAssemblyName);
    internal virtual bool WriteClrTypeInfo(XmlWriterDelegator xmlWriter, DataContract dataContract);
    internal virtual void WriteArraySize(XmlWriterDelegator xmlWriter, int size);
    protected virtual void WriteTypeInfo(XmlWriterDelegator writer, string dataContractName, string dataContractNamespace);
    internal static string TruncateDefaultDataContractNamespace(string dataContractNamespace);
    private static bool RequiresJsonTypeInfo(DataContract contract);
    private void WriteTypeInfo(XmlWriterDelegator writer, string typeInformation);
    protected virtual bool WriteTypeInfo(XmlWriterDelegator writer, DataContract contract, DataContract declaredContract);
    internal void WriteJsonISerializable(XmlWriterDelegator xmlWriter, ISerializable obj);
    internal static DataContract GetRevisedItemContract(DataContract oldItemContract);
    protected virtual void WriteDataContractValue(DataContract dataContract, XmlWriterDelegator xmlWriter, object obj, RuntimeTypeHandle declaredTypeHandle);
    protected virtual void WriteNull(XmlWriterDelegator xmlWriter);
    internal XmlDictionaryString get_CollectionItemName();
    internal static void WriteJsonNameWithMapping(XmlWriterDelegator xmlWriter, XmlDictionaryString[] memberNames, int index);
    internal virtual void WriteExtensionDataTypeInfo(XmlWriterDelegator xmlWriter, IDataNode dataNode);
    protected virtual void SerializeWithXsiType(XmlWriterDelegator xmlWriter, object obj, RuntimeTypeHandle objectTypeHandle, Type objectType, int declaredTypeID, RuntimeTypeHandle declaredTypeHandle, Type declaredType);
    private static void VerifyObjectCompatibilityWithInterface(DataContract contract, object graph, Type declaredType);
    private void HandleCollectionAssignedToObject(Type declaredType, DataContract& dataContract, Object& obj, Boolean& verifyKnownType);
    internal virtual void SerializeWithXsiTypeAtTopLevel(DataContract dataContract, XmlWriterDelegator xmlWriter, object obj, RuntimeTypeHandle originalDeclaredTypeHandle, Type graphType);
    private void VerifyType(DataContract dataContract, Type declaredType);
    internal virtual DataContract GetDataContract(RuntimeTypeHandle typeHandle, Type type);
    internal virtual DataContract GetDataContractSkipValidation(int typeId, RuntimeTypeHandle typeHandle, Type type);
    internal virtual DataContract GetDataContract(int id, RuntimeTypeHandle typeHandle);
    internal static DataContract ResolveJsonDataContractFromRootDataContract(XmlObjectSerializerContext context, XmlQualifiedName typeQName, DataContract rootTypeDataContract);
    protected virtual DataContract ResolveDataContractFromRootDataContract(XmlQualifiedName typeQName);
}
internal static class System.Runtime.Serialization.JsonFormatGeneratorStatics : object {
    [SecurityCriticalAttribute]
private static MethodInfo boxPointer;
    [SecurityCriticalAttribute]
private static PropertyInfo collectionItemNameProperty;
    [SecurityCriticalAttribute]
private static ConstructorInfo extensionDataObjectCtor;
    [SecurityCriticalAttribute]
private static PropertyInfo extensionDataProperty;
    [SecurityCriticalAttribute]
private static MethodInfo getItemContractMethod;
    [SecurityCriticalAttribute]
private static MethodInfo getJsonDataContractMethod;
    [SecurityCriticalAttribute]
private static MethodInfo getJsonMemberIndexMethod;
    [SecurityCriticalAttribute]
private static MethodInfo getRevisedItemContractMethod;
    [SecurityCriticalAttribute]
private static MethodInfo getUninitializedObjectMethod;
    [SecurityCriticalAttribute]
private static MethodInfo ienumeratorGetCurrentMethod;
    [SecurityCriticalAttribute]
private static MethodInfo ienumeratorMoveNextMethod;
    [SecurityCriticalAttribute]
private static MethodInfo isStartElementMethod0;
    [SecurityCriticalAttribute]
private static MethodInfo isStartElementMethod2;
    [SecurityCriticalAttribute]
private static PropertyInfo localNameProperty;
    [SecurityCriticalAttribute]
private static PropertyInfo namespaceProperty;
    [SecurityCriticalAttribute]
private static MethodInfo moveToContentMethod;
    [SecurityCriticalAttribute]
private static PropertyInfo nodeTypeProperty;
    [SecurityCriticalAttribute]
private static MethodInfo onDeserializationMethod;
    [SecurityCriticalAttribute]
private static MethodInfo readJsonValueMethod;
    [SecurityCriticalAttribute]
private static ConstructorInfo serializationExceptionCtor;
    [SecurityCriticalAttribute]
private static Type[] serInfoCtorArgs;
    [SecurityCriticalAttribute]
private static MethodInfo throwDuplicateMemberExceptionMethod;
    [SecurityCriticalAttribute]
private static MethodInfo throwMissingRequiredMembersMethod;
    [SecurityCriticalAttribute]
private static PropertyInfo typeHandleProperty;
    [SecurityCriticalAttribute]
private static MethodInfo unboxPointer;
    [SecurityCriticalAttribute]
private static PropertyInfo useSimpleDictionaryFormatReadProperty;
    [SecurityCriticalAttribute]
private static PropertyInfo useSimpleDictionaryFormatWriteProperty;
    [SecurityCriticalAttribute]
private static MethodInfo writeAttributeStringMethod;
    [SecurityCriticalAttribute]
private static MethodInfo writeEndElementMethod;
    [SecurityCriticalAttribute]
private static MethodInfo writeJsonISerializableMethod;
    [SecurityCriticalAttribute]
private static MethodInfo writeJsonNameWithMappingMethod;
    [SecurityCriticalAttribute]
private static MethodInfo writeJsonValueMethod;
    [SecurityCriticalAttribute]
private static MethodInfo writeStartElementMethod;
    [SecurityCriticalAttribute]
private static MethodInfo writeStartElementStringMethod;
    [SecurityCriticalAttribute]
private static MethodInfo parseEnumMethod;
    [SecurityCriticalAttribute]
private static MethodInfo getJsonMemberNameMethod;
    public static MethodInfo BoxPointer { get; }
    public static PropertyInfo CollectionItemNameProperty { get; }
    public static ConstructorInfo ExtensionDataObjectCtor { get; }
    public static PropertyInfo ExtensionDataProperty { get; }
    public static MethodInfo GetCurrentMethod { get; }
    public static MethodInfo GetItemContractMethod { get; }
    public static MethodInfo GetJsonDataContractMethod { get; }
    public static MethodInfo GetJsonMemberIndexMethod { get; }
    public static MethodInfo GetRevisedItemContractMethod { get; }
    public static MethodInfo GetUninitializedObjectMethod { get; }
    public static MethodInfo IsStartElementMethod0 { get; }
    public static MethodInfo IsStartElementMethod2 { get; }
    public static PropertyInfo LocalNameProperty { get; }
    public static PropertyInfo NamespaceProperty { get; }
    public static MethodInfo MoveNextMethod { get; }
    public static MethodInfo MoveToContentMethod { get; }
    public static PropertyInfo NodeTypeProperty { get; }
    public static MethodInfo OnDeserializationMethod { get; }
    public static MethodInfo ReadJsonValueMethod { get; }
    public static ConstructorInfo SerializationExceptionCtor { get; }
    public static Type[] SerInfoCtorArgs { get; }
    public static MethodInfo ThrowDuplicateMemberExceptionMethod { get; }
    public static MethodInfo ThrowMissingRequiredMembersMethod { get; }
    public static PropertyInfo TypeHandleProperty { get; }
    public static MethodInfo UnboxPointer { get; }
    public static PropertyInfo UseSimpleDictionaryFormatReadProperty { get; }
    public static PropertyInfo UseSimpleDictionaryFormatWriteProperty { get; }
    public static MethodInfo WriteAttributeStringMethod { get; }
    public static MethodInfo WriteEndElementMethod { get; }
    public static MethodInfo WriteJsonISerializableMethod { get; }
    public static MethodInfo WriteJsonNameWithMappingMethod { get; }
    public static MethodInfo WriteJsonValueMethod { get; }
    public static MethodInfo WriteStartElementMethod { get; }
    public static MethodInfo WriteStartElementStringMethod { get; }
    public static MethodInfo ParseEnumMethod { get; }
    public static MethodInfo GetJsonMemberNameMethod { get; }
    [SecuritySafeCriticalAttribute]
public static MethodInfo get_BoxPointer();
    [SecuritySafeCriticalAttribute]
public static PropertyInfo get_CollectionItemNameProperty();
    [SecuritySafeCriticalAttribute]
public static ConstructorInfo get_ExtensionDataObjectCtor();
    [SecuritySafeCriticalAttribute]
public static PropertyInfo get_ExtensionDataProperty();
    [SecuritySafeCriticalAttribute]
public static MethodInfo get_GetCurrentMethod();
    [SecuritySafeCriticalAttribute]
public static MethodInfo get_GetItemContractMethod();
    [SecuritySafeCriticalAttribute]
public static MethodInfo get_GetJsonDataContractMethod();
    [SecuritySafeCriticalAttribute]
public static MethodInfo get_GetJsonMemberIndexMethod();
    [SecuritySafeCriticalAttribute]
public static MethodInfo get_GetRevisedItemContractMethod();
    [SecuritySafeCriticalAttribute]
public static MethodInfo get_GetUninitializedObjectMethod();
    [SecuritySafeCriticalAttribute]
public static MethodInfo get_IsStartElementMethod0();
    [SecuritySafeCriticalAttribute]
public static MethodInfo get_IsStartElementMethod2();
    [SecuritySafeCriticalAttribute]
public static PropertyInfo get_LocalNameProperty();
    [SecuritySafeCriticalAttribute]
public static PropertyInfo get_NamespaceProperty();
    [SecuritySafeCriticalAttribute]
public static MethodInfo get_MoveNextMethod();
    [SecuritySafeCriticalAttribute]
public static MethodInfo get_MoveToContentMethod();
    [SecuritySafeCriticalAttribute]
public static PropertyInfo get_NodeTypeProperty();
    [SecuritySafeCriticalAttribute]
public static MethodInfo get_OnDeserializationMethod();
    [SecuritySafeCriticalAttribute]
public static MethodInfo get_ReadJsonValueMethod();
    [SecuritySafeCriticalAttribute]
public static ConstructorInfo get_SerializationExceptionCtor();
    [SecuritySafeCriticalAttribute]
public static Type[] get_SerInfoCtorArgs();
    [SecuritySafeCriticalAttribute]
public static MethodInfo get_ThrowDuplicateMemberExceptionMethod();
    [SecuritySafeCriticalAttribute]
public static MethodInfo get_ThrowMissingRequiredMembersMethod();
    [SecuritySafeCriticalAttribute]
public static PropertyInfo get_TypeHandleProperty();
    [SecuritySafeCriticalAttribute]
public static MethodInfo get_UnboxPointer();
    [SecuritySafeCriticalAttribute]
public static PropertyInfo get_UseSimpleDictionaryFormatReadProperty();
    [SecuritySafeCriticalAttribute]
public static PropertyInfo get_UseSimpleDictionaryFormatWriteProperty();
    [SecuritySafeCriticalAttribute]
public static MethodInfo get_WriteAttributeStringMethod();
    [SecuritySafeCriticalAttribute]
public static MethodInfo get_WriteEndElementMethod();
    [SecuritySafeCriticalAttribute]
public static MethodInfo get_WriteJsonISerializableMethod();
    [SecuritySafeCriticalAttribute]
public static MethodInfo get_WriteJsonNameWithMappingMethod();
    [SecuritySafeCriticalAttribute]
public static MethodInfo get_WriteJsonValueMethod();
    [SecuritySafeCriticalAttribute]
public static MethodInfo get_WriteStartElementMethod();
    [SecuritySafeCriticalAttribute]
public static MethodInfo get_WriteStartElementStringMethod();
    [SecuritySafeCriticalAttribute]
public static MethodInfo get_ParseEnumMethod();
    [SecuritySafeCriticalAttribute]
public static MethodInfo get_GetJsonMemberNameMethod();
}
[DataContractAttribute]
internal class System.Runtime.Serialization.KeyValue`2 : ValueType {
    private K key;
    private V value;
    [DataMemberAttribute]
public K Key { get; public set; }
    [DataMemberAttribute]
public V Value { get; public set; }
    internal KeyValue`2(K key, V value);
    public K get_Key();
    public void set_Key(K value);
    public V get_Value();
    public void set_Value(V value);
}
[AttributeUsageAttribute("12")]
public class System.Runtime.Serialization.KnownTypeAttribute : Attribute {
    private string methodName;
    private Type type;
    public string MethodName { get; }
    public Type Type { get; }
    public KnownTypeAttribute(Type type);
    public KnownTypeAttribute(string methodName);
    public string get_MethodName();
    public Type get_Type();
}
internal class System.Runtime.Serialization.KnownTypeDataContractResolver : DataContractResolver {
    private XmlObjectSerializerContext context;
    internal KnownTypeDataContractResolver(XmlObjectSerializerContext context);
    public virtual bool TryResolveType(Type type, Type declaredType, DataContractResolver knownTypeResolver, XmlDictionaryString& typeName, XmlDictionaryString& typeNamespace);
    public virtual Type ResolveName(string typeName, string typeNamespace, Type declaredType, DataContractResolver knownTypeResolver);
}
internal class System.Runtime.Serialization.LanguageDataContract : StringDataContract {
}
internal class System.Runtime.Serialization.LongDataContract : PrimitiveDataContract {
    internal string WriteMethodName { get; }
    internal string ReadMethodName { get; }
    internal LongDataContract(XmlDictionaryString name, XmlDictionaryString ns);
    internal virtual string get_WriteMethodName();
    internal virtual string get_ReadMethodName();
    public virtual void WriteXmlValue(XmlWriterDelegator writer, object obj, XmlObjectSerializerWriteContext context);
    public virtual object ReadXmlValue(XmlReaderDelegator reader, XmlObjectSerializerReadContext context);
}
internal class System.Runtime.Serialization.NameDataContract : StringDataContract {
}
internal class System.Runtime.Serialization.NCNameDataContract : StringDataContract {
}
internal class System.Runtime.Serialization.NegativeIntegerDataContract : LongDataContract {
}
public class System.Runtime.Serialization.NetDataContractSerializer : XmlObjectSerializer {
    private XmlDictionaryString rootName;
    private XmlDictionaryString rootNamespace;
    private StreamingContext context;
    private SerializationBinder binder;
    private ISurrogateSelector surrogateSelector;
    private int maxItemsInObjectGraph;
    private bool ignoreExtensionDataObject;
    private FormatterAssemblyStyle assemblyFormat;
    private DataContract cachedDataContract;
    private static Hashtable typeNameCache;
    private static Nullable`1<bool> unsafeTypeForwardingEnabled;
    internal static bool UnsafeTypeForwardingEnabled { get; }
    public StreamingContext Context { get; public set; }
    public SerializationBinder Binder { get; public set; }
    public ISurrogateSelector SurrogateSelector { get; public set; }
    public FormatterAssemblyStyle AssemblyFormat { get; public set; }
    public int MaxItemsInObjectGraph { get; }
    public bool IgnoreExtensionDataObject { get; }
    public NetDataContractSerializer(StreamingContext context);
    public NetDataContractSerializer(StreamingContext context, int maxItemsInObjectGraph, bool ignoreExtensionDataObject, FormatterAssemblyStyle assemblyFormat, ISurrogateSelector surrogateSelector);
    public NetDataContractSerializer(string rootName, string rootNamespace);
    public NetDataContractSerializer(string rootName, string rootNamespace, StreamingContext context, int maxItemsInObjectGraph, bool ignoreExtensionDataObject, FormatterAssemblyStyle assemblyFormat, ISurrogateSelector surrogateSelector);
    public NetDataContractSerializer(XmlDictionaryString rootName, XmlDictionaryString rootNamespace);
    public NetDataContractSerializer(XmlDictionaryString rootName, XmlDictionaryString rootNamespace, StreamingContext context, int maxItemsInObjectGraph, bool ignoreExtensionDataObject, FormatterAssemblyStyle assemblyFormat, ISurrogateSelector surrogateSelector);
    private static NetDataContractSerializer();
    private void Initialize(StreamingContext context, int maxItemsInObjectGraph, bool ignoreExtensionDataObject, FormatterAssemblyStyle assemblyFormat, ISurrogateSelector surrogateSelector);
    private void Initialize(XmlDictionaryString rootName, XmlDictionaryString rootNamespace, StreamingContext context, int maxItemsInObjectGraph, bool ignoreExtensionDataObject, FormatterAssemblyStyle assemblyFormat, ISurrogateSelector surrogateSelector);
    [SecuritySafeCriticalAttribute]
internal static bool get_UnsafeTypeForwardingEnabled();
    public sealed virtual StreamingContext get_Context();
    public sealed virtual void set_Context(StreamingContext value);
    public sealed virtual SerializationBinder get_Binder();
    public sealed virtual void set_Binder(SerializationBinder value);
    public sealed virtual ISurrogateSelector get_SurrogateSelector();
    public sealed virtual void set_SurrogateSelector(ISurrogateSelector value);
    public FormatterAssemblyStyle get_AssemblyFormat();
    public void set_AssemblyFormat(FormatterAssemblyStyle value);
    public int get_MaxItemsInObjectGraph();
    public bool get_IgnoreExtensionDataObject();
    public sealed virtual void Serialize(Stream stream, object graph);
    public sealed virtual object Deserialize(Stream stream);
    internal virtual void InternalWriteObject(XmlWriterDelegator writer, object graph);
    public virtual void WriteObject(XmlWriter writer, object graph);
    public virtual void WriteStartObject(XmlWriter writer, object graph);
    public virtual void WriteObjectContent(XmlWriter writer, object graph);
    public virtual void WriteEndObject(XmlWriter writer);
    public virtual void WriteStartObject(XmlDictionaryWriter writer, object graph);
    internal virtual void InternalWriteStartObject(XmlWriterDelegator writer, object graph);
    private void InternalWriteStartObject(XmlWriterDelegator writer, object graph, DataContract contract);
    public virtual void WriteObjectContent(XmlDictionaryWriter writer, object graph);
    internal virtual void InternalWriteObjectContent(XmlWriterDelegator writer, object graph);
    private void InternalWriteObjectContent(XmlWriterDelegator writer, object graph, DataContract contract, Hashtable surrogateDataContracts);
    internal static void WriteClrTypeInfo(XmlWriterDelegator writer, DataContract dataContract, SerializationBinder binder);
    internal static void WriteClrTypeInfo(XmlWriterDelegator writer, Type dataContractType, SerializationBinder binder, string defaultClrTypeName, string defaultClrAssemblyName);
    internal static void WriteClrTypeInfo(XmlWriterDelegator writer, Type dataContractType, SerializationBinder binder, SerializationInfo serInfo);
    private static void WriteClrTypeInfo(XmlWriterDelegator writer, string clrTypeName, string clrAssemblyName);
    public virtual void WriteEndObject(XmlDictionaryWriter writer);
    internal virtual void InternalWriteEndObject(XmlWriterDelegator writer);
    public virtual object ReadObject(XmlReader reader);
    public virtual object ReadObject(XmlReader reader, bool verifyObjectName);
    public virtual bool IsStartObject(XmlReader reader);
    public virtual object ReadObject(XmlDictionaryReader reader, bool verifyObjectName);
    public virtual bool IsStartObject(XmlDictionaryReader reader);
    internal virtual object InternalReadObject(XmlReaderDelegator xmlReader, bool verifyObjectName);
    internal virtual bool InternalIsStartObject(XmlReaderDelegator reader);
    internal DataContract GetDataContract(object obj, Hashtable& surrogateDataContracts);
    internal DataContract GetDataContract(Type type, Hashtable& surrogateDataContracts);
    internal DataContract GetDataContract(RuntimeTypeHandle typeHandle, Type type, Hashtable& surrogateDataContracts);
    [SecuritySafeCriticalAttribute]
private static ISerializationSurrogate GetSurrogate(Type type, ISurrogateSelector surrogateSelector, StreamingContext context);
    internal static DataContract GetDataContractFromSurrogateSelector(ISurrogateSelector surrogateSelector, StreamingContext context, RuntimeTypeHandle typeHandle, Type type, Hashtable& surrogateDataContracts);
    internal static TypeInformation GetTypeInformation(Type type);
    private static bool IsAssemblyNameForwardingSafe(string originalAssemblyName, string newAssemblyName);
    private static bool IsPublicKeyTokenForwardingSafe(Byte[] sourceToken, Byte[] destinationToken);
}
internal class System.Runtime.Serialization.NMTOKENDataContract : StringDataContract {
}
internal class System.Runtime.Serialization.NMTOKENSDataContract : StringDataContract {
}
internal class System.Runtime.Serialization.NonNegativeIntegerDataContract : LongDataContract {
}
internal class System.Runtime.Serialization.NonPositiveIntegerDataContract : LongDataContract {
}
internal class System.Runtime.Serialization.NormalizedStringDataContract : StringDataContract {
}
internal class System.Runtime.Serialization.ObjectDataContract : PrimitiveDataContract {
    internal string WriteMethodName { get; }
    internal string ReadMethodName { get; }
    internal bool CanContainReferences { get; }
    internal bool IsPrimitive { get; }
    internal virtual string get_WriteMethodName();
    internal virtual string get_ReadMethodName();
    public virtual void WriteXmlValue(XmlWriterDelegator writer, object obj, XmlObjectSerializerWriteContext context);
    public virtual object ReadXmlValue(XmlReaderDelegator reader, XmlObjectSerializerReadContext context);
    internal virtual bool get_CanContainReferences();
    internal virtual bool get_IsPrimitive();
}
internal class System.Runtime.Serialization.ObjectReferenceStack : ValueType {
    private static int MaximumArraySize;
    private static int InitialArraySize;
    private int count;
    private Object[] objectArray;
    private Boolean[] isReferenceArray;
    private Dictionary`2<object, object> objectDictionary;
    internal int Count { get; }
    internal void Push(object obj);
    internal void EnsureSetAsIsReference(object obj);
    internal void Pop(object obj);
    internal bool Contains(object obj);
    internal int get_Count();
}
internal class System.Runtime.Serialization.ObjectToIdCache : object {
    internal int m_currentCount;
    internal Int32[] m_ids;
    internal Object[] m_objs;
    private Boolean[] m_isWrapped;
    internal static Int32[] primes;
    private static ObjectToIdCache();
    public int GetId(object obj, Boolean& newId);
    public int ReassignId(int oldObjId, object oldObj, object newObj);
    private int FindElement(object obj, Boolean& isEmpty, Boolean& isWrapped);
    private void RemoveAt(int position);
    private int ComputeStartPosition(object o);
    private void Rehash();
    private static int GetPrime(int min);
    private static bool IsPrime(int candidate);
}
internal class System.Runtime.Serialization.PositiveIntegerDataContract : LongDataContract {
}
internal abstract class System.Runtime.Serialization.PrimitiveDataContract : DataContract {
    [SecurityCriticalAttribute]
private PrimitiveDataContractCriticalHelper helper;
    internal string WriteMethodName { get; }
    internal string ReadMethodName { get; }
    internal XmlDictionaryString TopLevelElementNamespace { get; internal set; }
    internal bool CanContainReferences { get; }
    internal bool IsPrimitive { get; }
    internal bool IsBuiltInDataContract { get; }
    internal MethodInfo XmlFormatWriterMethod { get; }
    internal MethodInfo XmlFormatContentWriterMethod { get; }
    internal MethodInfo XmlFormatReaderMethod { get; }
    [SecuritySafeCriticalAttribute]
protected PrimitiveDataContract(Type type, XmlDictionaryString name, XmlDictionaryString ns);
    internal static PrimitiveDataContract GetPrimitiveDataContract(Type type);
    internal static PrimitiveDataContract GetPrimitiveDataContract(string name, string ns);
    internal abstract virtual string get_WriteMethodName();
    internal abstract virtual string get_ReadMethodName();
    internal virtual XmlDictionaryString get_TopLevelElementNamespace();
    internal virtual void set_TopLevelElementNamespace(XmlDictionaryString value);
    internal virtual bool get_CanContainReferences();
    internal virtual bool get_IsPrimitive();
    internal virtual bool get_IsBuiltInDataContract();
    [SecuritySafeCriticalAttribute]
internal MethodInfo get_XmlFormatWriterMethod();
    [SecuritySafeCriticalAttribute]
internal MethodInfo get_XmlFormatContentWriterMethod();
    [SecuritySafeCriticalAttribute]
internal MethodInfo get_XmlFormatReaderMethod();
    public virtual void WriteXmlValue(XmlWriterDelegator xmlWriter, object obj, XmlObjectSerializerWriteContext context);
    protected object HandleReadValue(object obj, XmlObjectSerializerReadContext context);
    protected bool TryReadNullAtTopLevel(XmlReaderDelegator reader);
    internal virtual bool Equals(object other, Dictionary`2<DataContractPairKey, object> checkedContracts);
}
internal class System.Runtime.Serialization.QNameDataContract : PrimitiveDataContract {
    internal string WriteMethodName { get; }
    internal string ReadMethodName { get; }
    internal bool IsPrimitive { get; }
    internal virtual string get_WriteMethodName();
    internal virtual string get_ReadMethodName();
    internal virtual bool get_IsPrimitive();
    public virtual void WriteXmlValue(XmlWriterDelegator writer, object obj, XmlObjectSerializerWriteContext context);
    public virtual object ReadXmlValue(XmlReaderDelegator reader, XmlObjectSerializerReadContext context);
    internal virtual void WriteRootElement(XmlWriterDelegator writer, XmlDictionaryString name, XmlDictionaryString ns);
}
internal class System.Runtime.Serialization.SchemaExporter : object {
    private XmlSchemaSet schemas;
    private XmlDocument xmlDoc;
    private DataContractSet dataContractSet;
    [SecurityCriticalAttribute]
private static XmlQualifiedName anytypeQualifiedName;
    [SecurityCriticalAttribute]
private static XmlQualifiedName stringQualifiedName;
    [SecurityCriticalAttribute]
private static XmlQualifiedName defaultEnumBaseTypeName;
    [SecurityCriticalAttribute]
private static XmlQualifiedName enumerationValueAnnotationName;
    [SecurityCriticalAttribute]
private static XmlQualifiedName surrogateDataAnnotationName;
    [SecurityCriticalAttribute]
private static XmlQualifiedName defaultValueAnnotation;
    [SecurityCriticalAttribute]
private static XmlQualifiedName actualTypeAnnotationName;
    [SecurityCriticalAttribute]
private static XmlQualifiedName isDictionaryAnnotationName;
    [SecurityCriticalAttribute]
private static XmlQualifiedName isValueTypeName;
    private XmlSchemaSet Schemas { get; }
    private XmlDocument XmlDoc { get; }
    internal static XmlSchemaSequence ISerializableSequence { get; }
    internal static XmlSchemaAny ISerializableWildcardElement { get; }
    internal static XmlQualifiedName AnytypeQualifiedName { get; }
    internal static XmlQualifiedName StringQualifiedName { get; }
    internal static XmlQualifiedName DefaultEnumBaseTypeName { get; }
    internal static XmlQualifiedName EnumerationValueAnnotationName { get; }
    internal static XmlQualifiedName SurrogateDataAnnotationName { get; }
    internal static XmlQualifiedName DefaultValueAnnotation { get; }
    internal static XmlQualifiedName ActualTypeAnnotationName { get; }
    internal static XmlQualifiedName IsDictionaryAnnotationName { get; }
    internal static XmlQualifiedName IsValueTypeName { get; }
    internal static XmlSchemaAttribute ISerializableFactoryTypeAttribute { get; }
    internal static XmlSchemaAttribute RefAttribute { get; }
    internal static XmlSchemaAttribute IdAttribute { get; }
    internal SchemaExporter(XmlSchemaSet schemas, DataContractSet dataContractSet);
    private XmlSchemaSet get_Schemas();
    private XmlDocument get_XmlDoc();
    internal void Export();
    private void ExportSerializationSchema();
    private void ExportDataContract(DataContract dataContract);
    private XmlSchemaElement ExportTopLevelElement(DataContract dataContract, XmlSchema schema);
    private void ExportClassDataContract(ClassDataContract classDataContract, XmlSchema schema);
    private void AddReferenceAttributes(XmlSchemaObjectCollection attributes, XmlSchema schema);
    private void SetElementType(XmlSchemaElement element, DataContract dataContract, XmlSchema schema);
    private bool CheckIfMemberHasConflict(DataMember dataMember);
    private XmlElement ExportEmitDefaultValue(DataMember dataMember);
    private XmlElement ExportActualType(XmlQualifiedName typeName);
    private static XmlElement ExportActualType(XmlQualifiedName typeName, XmlDocument xmlDoc);
    private XmlElement ExportGenericInfo(Type clrType, string elementName, string elementNs);
    private XmlElement ExportSurrogateData(object key);
    private void ExportCollectionDataContract(CollectionDataContract collectionDataContract, XmlSchema schema);
    private XmlElement ExportIsDictionary();
    private void ExportEnumDataContract(EnumDataContract enumDataContract, XmlSchema schema);
    internal static long GetDefaultEnumValue(bool isFlags, int index);
    private void ExportISerializableDataContract(ClassDataContract dataContract, XmlSchema schema);
    private XmlSchemaComplexContentExtension CreateTypeContent(XmlSchemaComplexType type, XmlQualifiedName baseTypeName, XmlSchema schema);
    private void ExportXmlDataContract(XmlDataContract dataContract);
    private static void ReprocessAll(XmlSchemaSet schemas);
    internal static void GetXmlTypeInfo(Type type, XmlQualifiedName& stableName, XmlSchemaType& xsdType, Boolean& hasRoot);
    private static bool InvokeSchemaProviderMethod(Type clrType, XmlSchemaSet schemas, XmlQualifiedName& stableName, XmlSchemaType& xsdType, Boolean& hasRoot);
    private static void InvokeGetSchemaMethod(Type clrType, XmlSchemaSet schemas, XmlQualifiedName stableName);
    internal static void AddDefaultXmlType(XmlSchemaSet schemas, string localName, string ns);
    private static XmlSchemaComplexType CreateAnyType();
    private static XmlSchemaComplexType CreateAnyElementType();
    internal static bool IsSpecialXmlType(Type type, XmlQualifiedName& typeName, XmlSchemaType& xsdType, Boolean& hasRoot);
    private static void AddDefaultDatasetType(XmlSchemaSet schemas, string localName, string ns);
    private static void AddDefaultTypedDatasetType(XmlSchemaSet schemas, XmlSchema datasetSchema, string localName, string ns);
    private XmlSchemaAnnotation GetSchemaAnnotation(XmlQualifiedName annotationQualifiedName, string innerText, XmlSchema schema);
    private static XmlSchemaAnnotation GetSchemaAnnotation(XmlNode[] nodes);
    private XmlElement GetAnnotationMarkup(XmlQualifiedName annotationQualifiedName, string innerText, XmlSchema schema);
    private XmlSchema GetSchema(string ns);
    internal static XmlSchemaSequence get_ISerializableSequence();
    internal static XmlSchemaAny get_ISerializableWildcardElement();
    [SecuritySafeCriticalAttribute]
internal static XmlQualifiedName get_AnytypeQualifiedName();
    [SecuritySafeCriticalAttribute]
internal static XmlQualifiedName get_StringQualifiedName();
    [SecuritySafeCriticalAttribute]
internal static XmlQualifiedName get_DefaultEnumBaseTypeName();
    [SecuritySafeCriticalAttribute]
internal static XmlQualifiedName get_EnumerationValueAnnotationName();
    [SecuritySafeCriticalAttribute]
internal static XmlQualifiedName get_SurrogateDataAnnotationName();
    [SecuritySafeCriticalAttribute]
internal static XmlQualifiedName get_DefaultValueAnnotation();
    [SecuritySafeCriticalAttribute]
internal static XmlQualifiedName get_ActualTypeAnnotationName();
    [SecuritySafeCriticalAttribute]
internal static XmlQualifiedName get_IsDictionaryAnnotationName();
    [SecuritySafeCriticalAttribute]
internal static XmlQualifiedName get_IsValueTypeName();
    internal static XmlSchemaAttribute get_ISerializableFactoryTypeAttribute();
    internal static XmlSchemaAttribute get_RefAttribute();
    internal static XmlSchemaAttribute get_IdAttribute();
}
internal static class System.Runtime.Serialization.SchemaHelper : object {
    internal static bool NamespacesEqual(string ns1, string ns2);
    internal static XmlSchemaType GetSchemaType(XmlSchemaSet schemas, XmlQualifiedName typeQName, XmlSchema& outSchema);
    internal static XmlSchemaType GetSchemaType(Dictionary`2<XmlQualifiedName, SchemaObjectInfo> schemaInfo, XmlQualifiedName typeName);
    internal static XmlSchema GetSchemaWithType(Dictionary`2<XmlQualifiedName, SchemaObjectInfo> schemaInfo, XmlSchemaSet schemas, XmlQualifiedName typeName);
    internal static XmlSchemaElement GetSchemaElement(XmlSchemaSet schemas, XmlQualifiedName elementQName, XmlSchema& outSchema);
    internal static XmlSchemaElement GetSchemaElement(Dictionary`2<XmlQualifiedName, SchemaObjectInfo> schemaInfo, XmlQualifiedName elementName);
    internal static XmlSchema GetSchema(string ns, XmlSchemaSet schemas);
    private static XmlSchema CreateSchema(string ns, XmlSchemaSet schemas);
    internal static void AddElementForm(XmlSchemaElement element, XmlSchema schema);
    internal static void AddSchemaImport(string ns, XmlSchema schema);
    internal static XmlSchema GetSchemaWithGlobalElementDeclaration(XmlSchemaElement element, XmlSchemaSet schemas);
    internal static XmlQualifiedName GetGlobalElementDeclaration(XmlSchemaSet schemas, XmlQualifiedName typeQName, Boolean& isNullable);
}
internal class System.Runtime.Serialization.SchemaImporter : object {
    private DataContractSet dataContractSet;
    private XmlSchemaSet schemaSet;
    private ICollection`1<XmlQualifiedName> typeNames;
    private ICollection`1<XmlSchemaElement> elements;
    private XmlQualifiedName[] elementTypeNames;
    private bool importXmlDataType;
    private Dictionary`2<XmlQualifiedName, SchemaObjectInfo> schemaObjects;
    private List`1<XmlSchemaRedefine> redefineList;
    private bool needToImportKnownTypesForObject;
    [SecurityCriticalAttribute]
private static Hashtable serializationSchemaElements;
    private Dictionary`2<XmlQualifiedName, SchemaObjectInfo> SchemaObjects { get; }
    private List`1<XmlSchemaRedefine> RedefineList { get; }
    internal SchemaImporter(XmlSchemaSet schemas, ICollection`1<XmlQualifiedName> typeNames, ICollection`1<XmlSchemaElement> elements, XmlQualifiedName[] elementTypeNames, DataContractSet dataContractSet, bool importXmlDataType);
    internal void Import();
    internal static void CompileSchemaSet(XmlSchemaSet schemaSet);
    private Dictionary`2<XmlQualifiedName, SchemaObjectInfo> get_SchemaObjects();
    private List`1<XmlSchemaRedefine> get_RedefineList();
    private void ImportKnownTypes(XmlQualifiedName typeName);
    internal static bool IsObjectContract(DataContract dataContract);
    private void ImportKnownTypesForObject();
    internal Dictionary`2<XmlQualifiedName, SchemaObjectInfo> CreateSchemaObjects();
    private XmlQualifiedName GetBaseTypeName(XmlSchemaType type);
    private List`1<XmlSchemaRedefine> CreateRedefineList();
    [SecuritySafeCriticalAttribute]
private DataContract ImportAnonymousGlobalElement(XmlSchemaElement element, XmlQualifiedName typeQName, string ns);
    private DataContract ImportAnonymousElement(XmlSchemaElement element, XmlQualifiedName typeQName);
    private DataContract ImportType(XmlQualifiedName typeName);
    private DataContract ImportType(XmlSchemaType type);
    private DataContract ImportType(XmlSchemaType type, XmlQualifiedName typeName, bool isAnonymous);
    private void RemoveFailedContract(XmlQualifiedName typeName);
    private bool CheckIfEnum(XmlSchemaSimpleTypeRestriction restriction);
    private bool CheckIfCollection(XmlSchemaSequence rootSequence);
    private bool CheckIfISerializable(XmlSchemaSequence rootSequence, XmlSchemaObjectCollection attributes);
    [SecuritySafeCriticalAttribute]
private void RemoveOptionalUnknownSerializationElements(XmlSchemaObjectCollection items);
    private DataContract ImportType(XmlQualifiedName typeName, XmlSchemaParticle rootParticle, XmlSchemaObjectCollection attributes, XmlSchemaAnyAttribute anyAttribute, XmlQualifiedName baseTypeName, XmlSchemaAnnotation annotation);
    [SecuritySafeCriticalAttribute]
private ClassDataContract ImportClass(XmlQualifiedName typeName, XmlSchemaSequence rootSequence, XmlQualifiedName baseTypeName, XmlSchemaAnnotation annotation, bool isReference);
    [SecuritySafeCriticalAttribute]
private DataContract ImportXmlDataType(XmlQualifiedName typeName, XmlSchemaType xsdType, bool isAnonymous);
    private XmlDataContract ImportSpecialXmlDataType(XmlSchemaType xsdType, bool isAnonymous);
    private bool IsXmlAnyElementType(XmlSchemaComplexType xsdType);
    private bool IsXmlAnyType(XmlSchemaComplexType xsdType);
    private bool IsValueType(XmlQualifiedName typeName, XmlSchemaAnnotation annotation);
    [SecuritySafeCriticalAttribute]
private ClassDataContract ImportISerializable(XmlQualifiedName typeName, XmlSchemaSequence rootSequence, XmlQualifiedName baseTypeName, XmlSchemaObjectCollection attributes, XmlSchemaAnnotation annotation);
    private void CheckISerializableBase(XmlQualifiedName typeName, XmlSchemaSequence rootSequence, XmlSchemaObjectCollection attributes);
    private bool IsISerializableDerived(XmlQualifiedName typeName, XmlSchemaSequence rootSequence);
    [SecuritySafeCriticalAttribute]
private void ImportBaseContract(XmlQualifiedName baseTypeName, ClassDataContract dataContract);
    private void ImportTopLevelElement(XmlQualifiedName typeName);
    private void ImportClassMember(XmlSchemaElement element, ClassDataContract dataContract);
    private Nullable`1<bool> ImportEmitDefaultValue(XmlSchemaAnnotation annotation, XmlQualifiedName typeName);
    internal static XmlQualifiedName ImportActualType(XmlSchemaAnnotation annotation, XmlQualifiedName defaultTypeName, XmlQualifiedName typeName);
    [SecuritySafeCriticalAttribute]
private CollectionDataContract ImportCollection(XmlQualifiedName typeName, XmlSchemaSequence rootSequence, XmlSchemaObjectCollection attributes, XmlSchemaAnnotation annotation, bool isReference);
    private GenericInfo GetGenericInfoForDataMember(DataMember dataMember);
    private bool IsDictionary(XmlQualifiedName typeName, XmlSchemaAnnotation annotation);
    private EnumDataContract ImportFlagsEnum(XmlQualifiedName typeName, XmlSchemaSimpleTypeList list, XmlSchemaAnnotation annotation);
    [SecuritySafeCriticalAttribute]
private EnumDataContract ImportEnum(XmlQualifiedName typeName, XmlSchemaSimpleTypeRestriction restriction, bool isFlags, XmlSchemaAnnotation annotation);
    private DataContract ImportSimpleTypeRestriction(XmlQualifiedName typeName, XmlSchemaSimpleTypeRestriction restriction);
    private void ImportDataContractExtension(XmlSchemaType type, DataContract dataContract);
    [SecuritySafeCriticalAttribute]
private void ImportGenericInfo(XmlSchemaType type, DataContract dataContract);
    private GenericInfo ImportGenericInfo(XmlElement typeElement, XmlSchemaType type);
    private object ImportSurrogateData(XmlElement typeElement, string name, string ns);
    private void CheckComplexType(XmlQualifiedName typeName, XmlSchemaComplexType type);
    private void CheckIfElementUsesUnsupportedConstructs(XmlQualifiedName typeName, XmlSchemaElement element);
    private void ImportAttributes(XmlQualifiedName typeName, XmlSchemaObjectCollection attributes, XmlSchemaAnyAttribute anyAttribute, Boolean& isReference);
    private bool TryCheckIfAttribute(XmlQualifiedName typeName, XmlSchemaAttribute attribute, XmlQualifiedName refName, Boolean& foundAttribute);
    private void AddDataContract(DataContract dataContract);
    private string GetInnerText(XmlQualifiedName typeName, XmlElement xmlElement);
    private static XmlElement ImportAnnotation(XmlSchemaAnnotation annotation, XmlQualifiedName annotationQualifiedName);
    private static void ThrowTypeCannotBeImportedException(string name, string ns, string message);
    private static void ThrowArrayTypeCannotBeImportedException(string name, string ns, string message);
    private static void ThrowEnumTypeCannotBeImportedException(string name, string ns, string message);
    private static void ThrowISerializableTypeCannotBeImportedException(string name, string ns, string message);
    private static void ThrowTypeCannotBeImportedException(string message);
}
internal class System.Runtime.Serialization.SchemaObjectInfo : object {
    internal XmlSchemaType type;
    internal XmlSchemaElement element;
    internal XmlSchema schema;
    internal List`1<XmlSchemaType> knownTypes;
    internal SchemaObjectInfo(XmlSchemaType type, XmlSchemaElement element, XmlSchema schema, List`1<XmlSchemaType> knownTypes);
}
internal class System.Runtime.Serialization.ScopedKnownTypes : ValueType {
    internal Dictionary`2[] dataContractDictionaries;
    private int count;
    internal void Push(Dictionary`2<XmlQualifiedName, DataContract> dataContractDictionary);
    internal void Pop();
    internal DataContract GetDataContract(XmlQualifiedName qname);
}
internal enum System.Runtime.Serialization.SerializationMode : Enum {
    public int value__;
    public static SerializationMode SharedContract;
    public static SerializationMode SharedType;
}
internal static class System.Runtime.Serialization.SerializationTrace : object {
    [SecurityCriticalAttribute]
private static TraceSource codeGen;
    internal static SourceSwitch CodeGenerationSwitch { get; }
    private static TraceSource CodeGenerationTraceSource { get; }
    internal static SourceSwitch get_CodeGenerationSwitch();
    internal static void WriteInstruction(int lineNumber, string instruction);
    internal static void TraceInstruction(string instruction);
    [SecuritySafeCriticalAttribute]
private static TraceSource get_CodeGenerationTraceSource();
}
internal class System.Runtime.Serialization.ShortDataContract : PrimitiveDataContract {
    internal string WriteMethodName { get; }
    internal string ReadMethodName { get; }
    internal virtual string get_WriteMethodName();
    internal virtual string get_ReadMethodName();
    public virtual void WriteXmlValue(XmlWriterDelegator writer, object obj, XmlObjectSerializerWriteContext context);
    public virtual object ReadXmlValue(XmlReaderDelegator reader, XmlObjectSerializerReadContext context);
}
internal class System.Runtime.Serialization.SignedByteDataContract : PrimitiveDataContract {
    internal string WriteMethodName { get; }
    internal string ReadMethodName { get; }
    internal virtual string get_WriteMethodName();
    internal virtual string get_ReadMethodName();
    public virtual void WriteXmlValue(XmlWriterDelegator writer, object obj, XmlObjectSerializerWriteContext context);
    public virtual object ReadXmlValue(XmlReaderDelegator reader, XmlObjectSerializerReadContext context);
}
internal class System.Runtime.Serialization.SpecialTypeDataContract : DataContract {
    [SecurityCriticalAttribute]
private SpecialTypeDataContractCriticalHelper helper;
    internal bool IsBuiltInDataContract { get; }
    [SecuritySafeCriticalAttribute]
public SpecialTypeDataContract(Type type);
    [SecuritySafeCriticalAttribute]
public SpecialTypeDataContract(Type type, XmlDictionaryString name, XmlDictionaryString ns);
    internal virtual bool get_IsBuiltInDataContract();
}
internal static class System.Runtime.Serialization.SR : object {
    public static string ArrayExceededSize;
    public static string ArrayExceededSizeAttribute;
    public static string ArrayTypeIsNotSupported;
    public static string CannotDeserializeRefAtTopLevel;
    public static string CannotLoadMemberType;
    public static string CannotSerializeObjectWithCycles;
    public static string CanOnlyStoreIntoArgOrLocGot0;
    public static string CharIsInvalidPrimitive;
    public static string CallbackMustReturnVoid;
    public static string CallbackParameterInvalid;
    public static string CallbacksCannotBeVirtualMethods;
    public static string CollectionMustHaveAddMethod;
    public static string CollectionMustHaveGetEnumeratorMethod;
    public static string CollectionMustHaveItemType;
    public static string CollectionTypeCannotBeBuiltIn;
    public static string CollectionTypeCannotHaveDataContract;
    public static string CollectionTypeDoesNotHaveAddMethod;
    public static string CollectionTypeDoesNotHaveDefaultCtor;
    public static string CollectionTypeHasMultipleDefinitionsOfInterface;
    public static string CollectionTypeIsNotIEnumerable;
    public static string DataContractCacheOverflow;
    public static string DataContractNamespaceAlreadySet;
    public static string DataContractNamespaceIsNotValid;
    public static string DataContractNamespaceReserved;
    public static string DataMemberOnEnumField;
    public static string DcTypeNotFoundOnDeserialize;
    public static string DcTypeNotFoundOnSerialize;
    public static string DcTypeNotResolvedOnDeserialize;
    public static string DeserializedObjectWithIdNotFound;
    public static string DupContractInKnownTypes;
    public static string DupKeyValueName;
    public static string DupEnumMemberValue;
    public static string DupMemberName;
    public static string DuplicateAttribute;
    public static string DuplicateCallback;
    public static string EncounteredWithNameNamespace;
    public static string EnumTypeCannotHaveIsReference;
    public static string ErrorDeserializing;
    public static string ErrorInLine;
    public static string ErrorIsStartObject;
    public static string ErrorSerializing;
    public static string ErrorTypeInfo;
    public static string ErrorWriteEndObject;
    public static string ErrorWriteStartObject;
    public static string ExceededMaxItemsQuota;
    public static string ExpectingElement;
    public static string ExpectingElementAtDeserialize;
    public static string ExpectingEnd;
    public static string ExpectingState;
    public static string GenericNameBraceMismatch;
    public static string GenericParameterNotValid;
    public static string InconsistentIsReference;
    public static string IndexedPropertyCannotBeSerialized;
    public static string InterfaceTypeCannotBeCreated;
    public static string InvalidCollectionContractItemName;
    public static string InvalidCollectionContractKeyName;
    public static string InvalidCollectionContractKeyNoDictionary;
    public static string InvalidCollectionContractName;
    public static string InvalidCollectionContractNamespace;
    public static string InvalidCollectionContractValueName;
    public static string InvalidCollectionContractValueNoDictionary;
    public static string InvalidCollectionDataContract;
    public static string InvalidCollectionType;
    public static string InvalidDataContractName;
    public static string InvalidDataContractNamespace;
    public static string InvalidDataMemberName;
    public static string InvalidEnumMemberValue;
    public static string InvalidEnumValueOnRead;
    public static string InvalidEnumValueOnWrite;
    public static string InvalidGetSchemaMethod;
    public static string InvalidGlobalDataContractNamespace;
    public static string InvalidMember;
    public static string InvalidNonNullReturnValueByIsAny;
    public static string InvalidPrimitiveType;
    public static string InvalidReturnTypeOnGetSchemaMethod;
    public static string InvalidSizeDefinition;
    public static string InvalidXmlDataContractName;
    public static string InvalidXsIdDefinition;
    public static string InvalidXsRefDefinition;
    public static string IsAnyCannotBeNull;
    public static string IsAnyCannotBeSerializedAsDerivedType;
    public static string IsAnyCannotHaveXmlRoot;
    public static string IsNotAssignableFrom;
    public static string IsRequiredDataMemberOnIsReferenceDataContractType;
    public static string IXmlSerializableCannotHaveCollectionDataContract;
    public static string IXmlSerializableCannotHaveDataContract;
    public static string IXmlSerializableIllegalOperation;
    public static string IXmlSerializableMissingEndElements;
    public static string IXmlSerializableMustHaveDefaultConstructor;
    public static string IXmlSerializableWritePastSubTree;
    public static string KnownTypeAttributeEmptyString;
    public static string KnownTypeAttributeUnknownMethod;
    public static string KnownTypeAttributeReturnType;
    public static string KnownTypeAttributeOneScheme;
    public static string KnownTypeAttributeNoType;
    public static string KnownTypeConfigClosedGenericDeclared;
    public static string KnownTypeAttributeValidMethodTypes;
    public static string KnownTypeAttributeNoData;
    public static string KnownTypeAttributeMethodNull;
    public static string MaxArrayLengthExceeded;
    public static string MissingGetSchemaMethod;
    public static string MultipleIdDefinition;
    public static string NoConversionPossibleTo;
    public static string NoGetMethodForProperty;
    public static string NoSetMethodForProperty;
    public static string NullKnownType;
    public static string NullValueReturnedForGetOnlyCollection;
    public static string ObjectTableOverflow;
    public static string OrderCannotBeNegative;
    public static string ParameterCountMismatch;
    public static string PartialTrustCollectionContractAddMethodNotPublic;
    public static string PartialTrustCollectionContractNoPublicConstructor;
    public static string PartialTrustCollectionContractTypeNotPublic;
    public static string PartialTrustDataContractOnSerializingNotPublic;
    public static string PartialTrustDataContractOnSerializedNotPublic;
    public static string PartialTrustDataContractOnDeserializingNotPublic;
    public static string PartialTrustDataContractOnDeserializedNotPublic;
    public static string PartialTrustDataContractFieldGetNotPublic;
    public static string PartialTrustDataContractFieldSetNotPublic;
    public static string PartialTrustDataContractPropertyGetNotPublic;
    public static string PartialTrustDataContractPropertySetNotPublic;
    public static string PartialTrustDataContractTypeNotPublic;
    public static string PartialTrustNonAttributedSerializableTypeNoPublicConstructor;
    public static string PartialTrustIXmlSerializableTypeNotPublic;
    public static string PartialTrustIXmlSerialzableNoPublicConstructor;
    public static string NonAttributedSerializableTypesMustHaveDefaultConstructor;
    public static string AttributedTypesCannotInheritFromNonAttributedSerializableTypes;
    public static string GetOnlyCollectionsNotSupported;
    public static string QuotaMustBePositive;
    public static string QuotaIsReadOnly;
    public static string QuotaCopyReadOnly;
    public static string RequiredMemberMustBeEmitted;
    public static string ResolveTypeReturnedFalse;
    public static string ResolveTypeReturnedNull;
    public static string SupportForMultidimensionalArraysNotPresent;
    public static string TooManyCollectionContracts;
    public static string TooManyDataContracts;
    public static string TooManyDataMembers;
    public static string TooManyEnumMembers;
    public static string TooManyIgnoreDataMemberAttributes;
    public static string TypeMustBeConcrete;
    public static string TypeNotSerializable;
    public static string UnexpectedContractType;
    public static string UnexpectedElementExpectingElements;
    public static string UnexpectedEndOfFile;
    public static string UnknownConstantType;
    public static string UnsupportedIDictionaryAsDataMemberType;
    public static string ValueMustBeNonNegative;
    public static string ValueTypeCannotBeNull;
    public static string ValueTypeCannotHaveBaseType;
    public static string ValueTypeCannotHaveId;
    public static string ValueTypeCannotHaveIsReference;
    public static string ValueTypeCannotHaveRef;
    public static string XmlElementAttributes;
    public static string XmlForObjectCannotHaveContent;
    public static string XmlInvalidConversion;
    public static string XmlInvalidConversionWithoutValue;
    public static string XmlStartElementExpected;
    public static string XmlWriterMustBeInElement;
    public static string OffsetExceedsBufferSize;
    public static string SizeExceedsRemainingBufferSpace;
    public static string ValueMustBeInRange;
    public static string XmlArrayTooSmallOutput;
    public static string XmlInvalidBase64Length;
    public static string XmlInvalidBase64Sequence;
    public static string XmlInvalidBinHexLength;
    public static string XmlInvalidBinHexSequence;
    public static string XmlInvalidHighSurrogate;
    public static string XmlInvalidLowSurrogate;
    public static string XmlInvalidSurrogate;
    public static string CombinedPrefixNSLength;
    public static string InvalidInclusivePrefixListCollection;
    public static string InvalidLocalNameEmpty;
    public static string XmlArrayTooSmall;
    public static string XmlArrayTooSmallInput;
    public static string XmlBadBOM;
    public static string XmlBase64DataExpected;
    public static string XmlCDATAInvalidAtTopLevel;
    public static string XmlCloseCData;
    public static string XmlConversionOverflow;
    public static string XmlDeclarationRequired;
    public static string XmlDeclMissingVersion;
    public static string XmlDeclMissing;
    public static string XmlDeclNotFirst;
    public static string XmlDictionaryStringIDRange;
    public static string XmlDictionaryStringIDUndefinedSession;
    public static string XmlDictionaryStringIDUndefinedStatic;
    public static string XmlDuplicateAttribute;
    public static string XmlEmptyNamespaceRequiresNullPrefix;
    public static string XmlEncodingMismatch;
    public static string XmlEncodingNotSupported;
    public static string XmlEndElementExpected;
    public static string XmlEndElementNoOpenNodes;
    public static string XmlExpectedEncoding;
    public static string XmlFoundCData;
    public static string XmlFoundComment;
    public static string XmlFoundElement;
    public static string XmlFoundEndElement;
    public static string XmlFoundEndOfFile;
    public static string XmlFoundNodeType;
    public static string XmlFoundText;
    public static string XmlFullStartElementExpected;
    public static string XmlFullStartElementLocalNameNsExpected;
    public static string XmlFullStartElementNameExpected;
    public static string XmlIDDefined;
    public static string XmlKeyAlreadyExists;
    public static string XmlIllegalOutsideRoot;
    public static string XmlInvalidBytes;
    public static string XmlInvalidCharRef;
    public static string XmlInvalidCommentChars;
    public static string XmlInvalidDeclaration;
    public static string XmlInvalidDepth;
    public static string XmlInvalidEncoding;
    public static string XmlInvalidFFFE;
    public static string XmlInvalidFormat;
    public static string XmlInvalidID;
    public static string XmlInvalidOperation;
    public static string XmlInvalidPrefixState;
    public static string XmlInvalidQualifiedName;
    public static string XmlInvalidRootData;
    public static string XmlInvalidStandalone;
    public static string XmlInvalidStream;
    public static string XmlInvalidUniqueId;
    public static string XmlInvalidUTF8Bytes;
    public static string XmlInvalidVersion;
    public static string XmlInvalidWriteState;
    public static string XmlInvalidXmlByte;
    public static string XmlInvalidXmlSpace;
    public static string XmlLineInfo;
    public static string XmlMalformedDecl;
    public static string XmlMaxArrayLengthExceeded;
    public static string XmlMaxNameTableCharCountExceeded;
    public static string XmlMethodNotSupported;
    public static string XmlMissingLowSurrogate;
    public static string XmlMultipleRootElements;
    public static string XmlNamespaceNotFound;
    public static string XmlNestedArraysNotSupported;
    public static string XmlNoRootElement;
    public static string XmlOnlyOneRoot;
    public static string XmlOnlyWhitespace;
    public static string XmlOnlySingleValue;
    public static string XmlPrefixBoundToNamespace;
    public static string XmlProcessingInstructionNotSupported;
    public static string XmlReservedPrefix;
    public static string XmlSpaceBetweenAttributes;
    public static string XmlSpecificBindingNamespace;
    public static string XmlSpecificBindingPrefix;
    public static string XmlStartElementLocalNameNsExpected;
    public static string XmlStartElementNameExpected;
    public static string XmlTagMismatch;
    public static string XmlTokenExpected;
    public static string XmlUndefinedPrefix;
    public static string XmlUnexpectedEndElement;
    public static string XmlUnexpectedEndOfFile;
    public static string XmlWriterClosed;
    public static string Xml_InvalidNmToken;
    public static string AbstractElementNotSupported;
    public static string AbstractTypeNotSupported;
    public static string AmbiguousReferencedCollectionTypes1;
    public static string AmbiguousReferencedCollectionTypes3;
    public static string AmbiguousReferencedTypes1;
    public static string AmbiguousReferencedTypes3;
    public static string AnnotationAttributeNotFound;
    public static string AnonymousTypeNotSupported;
    public static string AnyAttributeNotSupported;
    public static string ArrayItemFormMustBe;
    public static string ArraySizeAttributeIncorrect;
    public static string ArrayTypeCannotBeImported;
    public static string AssemblyNotFound;
    public static string AttributeNotFound;
    public static string BaseTypeNotISerializable;
    public static string CannotComputeUniqueName;
    public static string CannotDeriveFromSealedReferenceType;
    public static string CannotDeserializeForwardedType;
    public static string CannotExportNullAssembly;
    public static string CannotExportNullKnownType;
    public static string CannotExportNullType;
    public static string CannotHaveDuplicateAttributeNames;
    public static string CannotHaveDuplicateElementNames;
    public static string CannotImportInvalidSchemas;
    public static string CannotImportNullDataContractName;
    public static string CannotImportNullSchema;
    public static string CannotSetMembersForReferencedType;
    public static string CannotSetNamespaceForReferencedType;
    public static string CannotUseGenericTypeAsBase;
    public static string ChangingFullTypeNameNotSupported;
    public static string CircularTypeReference;
    public static string ClassDataContractReturnedForGetOnlyCollection;
    public static string CLRNamespaceMappedMultipleTimes;
    public static string ClrTypeNotFound;
    public static string CollectionAssignedToIncompatibleInterface;
    public static string ComplexTypeRestrictionNotSupported;
    public static string ConfigDataContractSerializerSectionLoadError;
    public static string ConfigIndexOutOfRange;
    public static string ConfigMustOnlyAddParamsWithType;
    public static string ConfigMustOnlySetTypeOrIndex;
    public static string ConfigMustSetTypeOrIndex;
    public static string CouldNotReadSerializationSchema;
    public static string DefaultOnElementNotSupported;
    public static string DerivedTypeNotISerializable;
    public static string DupContractInDataContractSet;
    public static string DuplicateExtensionDataSetMethod;
    public static string DupTypeContractInDataContractSet;
    public static string ElementMaxOccursMustBe;
    public static string ElementMinOccursMustBe;
    public static string ElementRefOnLocalElementNotSupported;
    public static string EnumEnumerationFacetsMustHaveValue;
    public static string EnumListInAnonymousTypeNotSupported;
    public static string EnumListMustContainAnonymousType;
    public static string EnumOnlyEnumerationFacetsSupported;
    public static string EnumRestrictionInvalid;
    public static string EnumTypeCannotBeImported;
    public static string EnumTypeNotSupportedByDataContractJsonSerializer;
    public static string EnumUnionInAnonymousTypeNotSupported;
    public static string ExtensionDataSetMustReturnVoid;
    public static string ExtensionDataSetParameterInvalid;
    public static string FactoryObjectContainsSelfReference;
    public static string FactoryTypeNotISerializable;
    public static string FixedOnElementNotSupported;
    public static string FlushBufferAlreadyInUse;
    public static string FormMustBeQualified;
    public static string GenericAnnotationAttributeNotFound;
    public static string GenericAnnotationForNestedLevelMustBeIncreasing;
    public static string GenericAnnotationHasInvalidAttributeValue;
    public static string GenericAnnotationHasInvalidElement;
    public static string GenericTypeNameMismatch;
    public static string GenericTypeNotExportable;
    public static string GetOnlyCollectionMustHaveAddMethod;
    public static string GetRealObjectReturnedNull;
    public static string InvalidAnnotationExpectingText;
    public static string InvalidAssemblyFormat;
    public static string InvalidCharacterEncountered;
    public static string InvalidClassDerivation;
    public static string InvalidClrNameGeneratedForISerializable;
    public static string InvalidClrNamespaceGeneratedForISerializable;
    public static string InvalidDataNode;
    public static string InvalidEmitDefaultAnnotation;
    public static string InvalidEnumBaseType;
    public static string InvalidISerializableDerivation;
    public static string InvalidKeyValueType;
    public static string InvalidKeyValueTypeNamespace;
    public static string InvalidReturnSchemaOnGetSchemaMethod;
    public static string InvalidStateInExtensionDataReader;
    public static string InvalidXmlDeserializingExtensionData;
    public static string IsAnyNotSupportedByNetDataContractSerializer;
    public static string IsDictionaryFormattedIncorrectly;
    public static string ISerializableAssemblyNameSetToZero;
    public static string ISerializableCannotHaveDataContract;
    public static string ISerializableContainsMoreThanOneItems;
    public static string ISerializableDerivedContainsOneOrMoreItems;
    public static string ISerializableDoesNotContainAny;
    public static string ISerializableMustRefFactoryTypeAttribute;
    public static string ISerializableTypeCannotBeImported;
    public static string ISerializableWildcardMaxOccursMustBe;
    public static string ISerializableWildcardMinOccursMustBe;
    public static string ISerializableWildcardNamespaceInvalid;
    public static string ISerializableWildcardProcessContentsInvalid;
    public static string IsReferenceGetOnlyCollectionsNotSupported;
    public static string IsValueTypeFormattedIncorrectly;
    public static string JsonAttributeAlreadyWritten;
    public static string JsonAttributeMustHaveElement;
    public static string JsonCannotWriteStandaloneTextAfterQuotedText;
    public static string JsonCannotWriteTextAfterNonTextAttribute;
    public static string JsonDateTimeOutOfRange;
    public static string JsonDuplicateMemberInInput;
    public static string JsonDuplicateMemberNames;
    public static string JsonEncodingNotSupported;
    public static string JsonEncounteredUnexpectedCharacter;
    public static string JsonEndElementNoOpenNodes;
    public static string JsonExpectedEncoding;
    public static string JsonInvalidBytes;
    public static string JsonInvalidDataTypeSpecifiedForServerType;
    public static string JsonInvalidDateTimeString;
    public static string JsonInvalidFFFE;
    public static string JsonInvalidItemNameForArrayElement;
    public static string JsonInvalidLocalNameEmpty;
    public static string JsonInvalidMethodBetweenStartEndAttribute;
    public static string JsonInvalidRootElementName;
    public static string JsonInvalidStartElementCall;
    public static string JsonInvalidWriteState;
    public static string JsonMethodNotSupported;
    public static string JsonMultipleRootElementsNotAllowedOnWriter;
    public static string JsonMustSpecifyDataType;
    public static string JsonMustUseWriteStringForWritingAttributeValues;
    public static string JsonNamespaceMustBeEmpty;
    public static string JsonNestedArraysNotSupported;
    public static string JsonNodeTypeArrayOrObjectNotSpecified;
    public static string JsonNoMatchingStartAttribute;
    public static string JsonOffsetExceedsBufferSize;
    public static string JsonOneRequiredMemberNotFound;
    public static string JsonOnlyWhitespace;
    public static string JsonOpenAttributeMustBeClosedFirst;
    public static string JsonPrefixMustBeNullOrEmpty;
    public static string JsonRequiredMembersNotFound;
    public static string JsonServerTypeSpecifiedForInvalidDataType;
    public static string JsonSizeExceedsRemainingBufferSpace;
    public static string JsonTypeNotSupportedByDataContractJsonSerializer;
    public static string JsonUnexpectedAttributeLocalName;
    public static string JsonUnexpectedAttributeValue;
    public static string JsonUnexpectedEndOfFile;
    public static string JsonUnsupportedForIsReference;
    public static string JsonWriteArrayNotSupported;
    public static string JsonWriterClosed;
    public static string JsonXmlInvalidDeclaration;
    public static string JsonXmlProcessingInstructionNotSupported;
    public static string KeyTypeCannotBeParsedInSimpleDictionary;
    public static string KnownTypeConfigGenericParamMismatch;
    public static string KnownTypeConfigIndexOutOfBounds;
    public static string KnownTypeConfigIndexOutOfBoundsZero;
    public static string KnownTypeConfigObject;
    public static string MaxMimePartsExceeded;
    public static string MimeContentTypeHeaderInvalid;
    public static string MimeHeaderInvalidCharacter;
    public static string MimeMessageGetContentStreamCalledAlready;
    public static string MimeReaderHeaderAlreadyExists;
    public static string MimeReaderMalformedHeader;
    public static string MimeReaderResetCalledBeforeEOF;
    public static string MimeReaderTruncated;
    public static string MimeVersionHeaderInvalid;
    public static string MimeWriterInvalidStateForClose;
    public static string MimeWriterInvalidStateForContent;
    public static string MimeWriterInvalidStateForHeader;
    public static string MimeWriterInvalidStateForStartPart;
    public static string MimeWriterInvalidStateForStartPreface;
    public static string MissingSchemaType;
    public static string MixedContentNotSupported;
    public static string MtomBoundaryInvalid;
    public static string MtomBufferQuotaExceeded;
    public static string MtomContentTransferEncodingNotPresent;
    public static string MtomContentTransferEncodingNotSupported;
    public static string MtomContentTypeInvalid;
    public static string MtomDataMustNotContainXopInclude;
    public static string MtomExceededMaxSizeInBytes;
    public static string MtomInvalidCIDUri;
    public static string MtomInvalidEmptyURI;
    public static string MtomInvalidStartUri;
    public static string MtomInvalidTransferEncodingForMimePart;
    public static string MtomMessageContentTypeNotFound;
    public static string MtomMessageInvalidContent;
    public static string MtomMessageInvalidContentInMimePart;
    public static string MtomMessageInvalidMimeVersion;
    public static string MtomMessageNotApplicationXopXml;
    public static string MtomMessageNotMultipart;
    public static string MtomMessageRequiredParamNotSpecified;
    public static string MtomMimePartReferencedMoreThanOnce;
    public static string MtomPartNotFound;
    public static string MtomRootContentTypeNotFound;
    public static string MtomRootNotApplicationXopXml;
    public static string MtomRootPartNotFound;
    public static string MtomRootRequiredParamNotSpecified;
    public static string MtomRootUnexpectedCharset;
    public static string MtomRootUnexpectedType;
    public static string MtomXopIncludeHrefNotSpecified;
    public static string MtomXopIncludeInvalidXopAttributes;
    public static string MtomXopIncludeInvalidXopElement;
    public static string MustContainOnlyLocalElements;
    public static string NoAsyncWritePending;
    public static string NonOptionalFieldMemberOnIsReferenceSerializableType;
    public static string OnlyDataContractTypesCanHaveExtensionData;
    public static string PartialTrustISerializableNoPublicConstructor;
    public static string QueryGeneratorPathToMemberNotFound;
    public static string ReadNotSupportedOnStream;
    public static string ReadOnlyClassDeserialization;
    public static string ReadOnlyCollectionDeserialization;
    public static string RecursiveCollectionType;
    public static string RedefineNotSupported;
    public static string ReferencedBaseTypeDoesNotExist;
    public static string ReferencedCollectionTypesCannotContainNull;
    public static string ReferencedTypeDoesNotMatch;
    public static string ReferencedTypeMatchingMessage;
    public static string ReferencedTypeNotMatchingMessage;
    public static string ReferencedTypesCannotContainNull;
    public static string RequiresClassDataContractToSetIsISerializable;
    public static string RootParticleMustBeSequence;
    public static string RootSequenceMaxOccursMustBe;
    public static string RootSequenceMustBeRequired;
    public static string SeekNotSupportedOnStream;
    public static string SerializationInfo_ConstructorNotFound;
    public static string SimpleContentNotSupported;
    public static string SimpleTypeRestrictionDoesNotSpecifyBase;
    public static string SimpleTypeUnionNotSupported;
    public static string SpecifiedTypeNotFoundInSchema;
    public static string SubstitutionGroupOnElementNotSupported;
    public static string SurrogatesWithGetOnlyCollectionsNotSupported;
    public static string SurrogatesWithGetOnlyCollectionsNotSupportedSerDeser;
    public static string TopLevelElementRepresentsDifferentType;
    public static string TraceCodeElementIgnored;
    public static string TraceCodeFactoryTypeNotFound;
    public static string TraceCodeObjectWithLargeDepth;
    public static string TraceCodeReadObjectBegin;
    public static string TraceCodeReadObjectEnd;
    public static string TraceCodeWriteObjectBegin;
    public static string TraceCodeWriteObjectContentBegin;
    public static string TraceCodeWriteObjectContentEnd;
    public static string TraceCodeWriteObjectEnd;
    public static string TraceCodeXsdExportAnnotationFailed;
    public static string TraceCodeXsdExportBegin;
    public static string TraceCodeXsdExportDupItems;
    public static string TraceCodeXsdExportEnd;
    public static string TraceCodeXsdExportError;
    public static string TraceCodeXsdImportAnnotationFailed;
    public static string TraceCodeXsdImportBegin;
    public static string TraceCodeXsdImportEnd;
    public static string TraceCodeXsdImportError;
    public static string TypeCannotBeForwardedFrom;
    public static string TypeCannotBeImported;
    public static string TypeCannotBeImportedHowToFix;
    public static string TypeHasNotBeenImported;
    public static string TypeMustBeIXmlSerializable;
    public static string TypeShouldNotContainAttributes;
    public static string UnknownXmlType;
    public static string WriteBufferOverflow;
    public static string WriteNotSupportedOnStream;
    public static string XmlCanonicalizationNotStarted;
    public static string XmlCanonicalizationStarted;
    public static string XmlMaxArrayLengthOrMaxItemsQuotaExceeded;
    public static string XmlMaxBytesPerReadExceeded;
    public static string XmlMaxDepthExceeded;
    public static string XmlMaxStringContentLengthExceeded;
    public static string XmlObjectAssignedToIncompatibleInterface;
    internal static string GetString(string name, Object[] args);
    internal static string GetString(CultureInfo culture, string name, Object[] args);
    internal static string GetString(string name);
    internal static string GetString(CultureInfo culture, string name);
}
internal class System.Runtime.Serialization.StringDataContract : PrimitiveDataContract {
    internal string WriteMethodName { get; }
    internal string ReadMethodName { get; }
    internal StringDataContract(XmlDictionaryString name, XmlDictionaryString ns);
    internal virtual string get_WriteMethodName();
    internal virtual string get_ReadMethodName();
    public virtual void WriteXmlValue(XmlWriterDelegator writer, object obj, XmlObjectSerializerWriteContext context);
    public virtual object ReadXmlValue(XmlReaderDelegator reader, XmlObjectSerializerReadContext context);
}
internal class System.Runtime.Serialization.SurrogateDataContract : DataContract {
    [SecurityCriticalAttribute]
private SurrogateDataContractCriticalHelper helper;
    internal ISerializationSurrogate SerializationSurrogate { get; }
    [SecuritySafeCriticalAttribute]
internal SurrogateDataContract(Type type, ISerializationSurrogate serializationSurrogate);
    [SecuritySafeCriticalAttribute]
internal ISerializationSurrogate get_SerializationSurrogate();
    public virtual void WriteXmlValue(XmlWriterDelegator xmlWriter, object obj, XmlObjectSerializerWriteContext context);
    [SecuritySafeCriticalAttribute]
private object SerializationSurrogateSetObjectData(object obj, SerializationInfo serInfo, StreamingContext context);
    [SecuritySafeCriticalAttribute]
internal static object GetRealObject(IObjectReference obj, StreamingContext context);
    [SecuritySafeCriticalAttribute]
private object GetUninitializedObject(Type objType);
    [SecuritySafeCriticalAttribute]
private void SerializationSurrogateGetObjectData(object obj, SerializationInfo serInfo, StreamingContext context);
    public virtual object ReadXmlValue(XmlReaderDelegator xmlReader, XmlObjectSerializerReadContext context);
}
internal class System.Runtime.Serialization.TimeDataContract : StringDataContract {
}
internal class System.Runtime.Serialization.TimeSpanDataContract : PrimitiveDataContract {
    internal string WriteMethodName { get; }
    internal string ReadMethodName { get; }
    internal TimeSpanDataContract(XmlDictionaryString name, XmlDictionaryString ns);
    internal virtual string get_WriteMethodName();
    internal virtual string get_ReadMethodName();
    public virtual void WriteXmlValue(XmlWriterDelegator writer, object obj, XmlObjectSerializerWriteContext context);
    public virtual object ReadXmlValue(XmlReaderDelegator reader, XmlObjectSerializerReadContext context);
}
internal class System.Runtime.Serialization.TokenDataContract : StringDataContract {
}
internal class System.Runtime.Serialization.TypeHandleRef : object {
    private RuntimeTypeHandle value;
    public RuntimeTypeHandle Value { get; public set; }
    public TypeHandleRef(RuntimeTypeHandle value);
    public RuntimeTypeHandle get_Value();
    public void set_Value(RuntimeTypeHandle value);
}
internal class System.Runtime.Serialization.TypeHandleRefEqualityComparer : object {
    public sealed virtual bool Equals(TypeHandleRef x, TypeHandleRef y);
    public sealed virtual int GetHashCode(TypeHandleRef obj);
}
internal class System.Runtime.Serialization.TypeInformation : object {
    private string fullTypeName;
    private string assemblyString;
    private bool hasTypeForwardedFrom;
    internal string FullTypeName { get; }
    internal string AssemblyString { get; }
    internal bool HasTypeForwardedFrom { get; }
    internal TypeInformation(string fullTypeName, string assemblyString, bool hasTypeForwardedFrom);
    internal string get_FullTypeName();
    internal string get_AssemblyString();
    internal bool get_HasTypeForwardedFrom();
}
internal class System.Runtime.Serialization.UnsignedByteDataContract : PrimitiveDataContract {
    internal string WriteMethodName { get; }
    internal string ReadMethodName { get; }
    internal virtual string get_WriteMethodName();
    internal virtual string get_ReadMethodName();
    public virtual void WriteXmlValue(XmlWriterDelegator writer, object obj, XmlObjectSerializerWriteContext context);
    public virtual object ReadXmlValue(XmlReaderDelegator reader, XmlObjectSerializerReadContext context);
}
internal class System.Runtime.Serialization.UnsignedIntDataContract : PrimitiveDataContract {
    internal string WriteMethodName { get; }
    internal string ReadMethodName { get; }
    internal virtual string get_WriteMethodName();
    internal virtual string get_ReadMethodName();
    public virtual void WriteXmlValue(XmlWriterDelegator writer, object obj, XmlObjectSerializerWriteContext context);
    public virtual object ReadXmlValue(XmlReaderDelegator reader, XmlObjectSerializerReadContext context);
}
internal class System.Runtime.Serialization.UnsignedLongDataContract : PrimitiveDataContract {
    internal string WriteMethodName { get; }
    internal string ReadMethodName { get; }
    internal virtual string get_WriteMethodName();
    internal virtual string get_ReadMethodName();
    public virtual void WriteXmlValue(XmlWriterDelegator writer, object obj, XmlObjectSerializerWriteContext context);
    public virtual object ReadXmlValue(XmlReaderDelegator reader, XmlObjectSerializerReadContext context);
}
internal class System.Runtime.Serialization.UnsignedShortDataContract : PrimitiveDataContract {
    internal string WriteMethodName { get; }
    internal string ReadMethodName { get; }
    internal virtual string get_WriteMethodName();
    internal virtual string get_ReadMethodName();
    public virtual void WriteXmlValue(XmlWriterDelegator writer, object obj, XmlObjectSerializerWriteContext context);
    public virtual object ReadXmlValue(XmlReaderDelegator reader, XmlObjectSerializerReadContext context);
}
internal class System.Runtime.Serialization.UriDataContract : PrimitiveDataContract {
    internal string WriteMethodName { get; }
    internal string ReadMethodName { get; }
    internal virtual string get_WriteMethodName();
    internal virtual string get_ReadMethodName();
    public virtual void WriteXmlValue(XmlWriterDelegator writer, object obj, XmlObjectSerializerWriteContext context);
    public virtual object ReadXmlValue(XmlReaderDelegator reader, XmlObjectSerializerReadContext context);
}
internal class System.Runtime.Serialization.XmlDataContract : DataContract {
    [SecurityCriticalAttribute]
private XmlDataContractCriticalHelper helper;
    internal Dictionary`2<XmlQualifiedName, DataContract> KnownDataContracts { get; internal set; }
    internal XmlSchemaType XsdType { get; internal set; }
    internal bool IsAnonymous { get; }
    internal bool HasRoot { get; internal set; }
    internal XmlDictionaryString TopLevelElementName { get; internal set; }
    internal XmlDictionaryString TopLevelElementNamespace { get; internal set; }
    internal bool IsTopLevelElementNullable { get; internal set; }
    internal bool IsTypeDefinedOnImport { get; internal set; }
    internal CreateXmlSerializableDelegate CreateXmlSerializableDelegate { get; }
    internal bool CanContainReferences { get; }
    internal bool IsBuiltInDataContract { get; }
    [SecuritySafeCriticalAttribute]
internal XmlDataContract(Type type);
    [SecuritySafeCriticalAttribute]
internal virtual Dictionary`2<XmlQualifiedName, DataContract> get_KnownDataContracts();
    [SecurityCriticalAttribute]
internal virtual void set_KnownDataContracts(Dictionary`2<XmlQualifiedName, DataContract> value);
    [SecuritySafeCriticalAttribute]
internal XmlSchemaType get_XsdType();
    [SecurityCriticalAttribute]
internal void set_XsdType(XmlSchemaType value);
    [SecuritySafeCriticalAttribute]
internal bool get_IsAnonymous();
    [SecuritySafeCriticalAttribute]
internal virtual bool get_HasRoot();
    [SecurityCriticalAttribute]
internal virtual void set_HasRoot(bool value);
    [SecuritySafeCriticalAttribute]
internal virtual XmlDictionaryString get_TopLevelElementName();
    [SecurityCriticalAttribute]
internal virtual void set_TopLevelElementName(XmlDictionaryString value);
    [SecuritySafeCriticalAttribute]
internal virtual XmlDictionaryString get_TopLevelElementNamespace();
    [SecurityCriticalAttribute]
internal virtual void set_TopLevelElementNamespace(XmlDictionaryString value);
    [SecuritySafeCriticalAttribute]
internal bool get_IsTopLevelElementNullable();
    [SecurityCriticalAttribute]
internal void set_IsTopLevelElementNullable(bool value);
    [SecuritySafeCriticalAttribute]
internal bool get_IsTypeDefinedOnImport();
    [SecurityCriticalAttribute]
internal void set_IsTypeDefinedOnImport(bool value);
    [SecuritySafeCriticalAttribute]
internal CreateXmlSerializableDelegate get_CreateXmlSerializableDelegate();
    internal virtual bool get_CanContainReferences();
    internal virtual bool get_IsBuiltInDataContract();
    private ConstructorInfo GetConstructor();
    [SecurityCriticalAttribute]
internal void SetTopLevelElementName(XmlQualifiedName elementName);
    internal virtual bool Equals(object other, Dictionary`2<DataContractPairKey, object> checkedContracts);
    public virtual int GetHashCode();
    public virtual void WriteXmlValue(XmlWriterDelegator xmlWriter, object obj, XmlObjectSerializerWriteContext context);
    public virtual object ReadXmlValue(XmlReaderDelegator xmlReader, XmlObjectSerializerReadContext context);
    internal CreateXmlSerializableDelegate GenerateCreateXmlSerializableDelegate();
    [CompilerGeneratedAttribute]
private IXmlSerializable <GenerateCreateXmlSerializableDelegate>b__39_0();
}
internal class System.Runtime.Serialization.XmlDataContractInterpreter : object {
    private XmlDataContract contract;
    public XmlDataContractInterpreter(XmlDataContract contract);
    public IXmlSerializable CreateXmlSerializable();
    private ConstructorInfo GetConstructor();
}
internal class System.Runtime.Serialization.XmlDataNode : DataNode`1<object> {
    private IList`1<XmlAttribute> xmlAttributes;
    private IList`1<XmlNode> xmlChildNodes;
    private XmlDocument ownerDocument;
    internal IList`1<XmlAttribute> XmlAttributes { get; internal set; }
    internal IList`1<XmlNode> XmlChildNodes { get; internal set; }
    internal XmlDocument OwnerDocument { get; internal set; }
    internal IList`1<XmlAttribute> get_XmlAttributes();
    internal void set_XmlAttributes(IList`1<XmlAttribute> value);
    internal IList`1<XmlNode> get_XmlChildNodes();
    internal void set_XmlChildNodes(IList`1<XmlNode> value);
    internal XmlDocument get_OwnerDocument();
    internal void set_OwnerDocument(XmlDocument value);
    public virtual void Clear();
}
internal class System.Runtime.Serialization.XmlFormatClassReaderDelegate : MulticastDelegate {
    public XmlFormatClassReaderDelegate(object object, IntPtr method);
    public virtual object Invoke(XmlReaderDelegator xmlReader, XmlObjectSerializerReadContext context, XmlDictionaryString[] memberNames, XmlDictionaryString[] memberNamespaces);
    public virtual IAsyncResult BeginInvoke(XmlReaderDelegator xmlReader, XmlObjectSerializerReadContext context, XmlDictionaryString[] memberNames, XmlDictionaryString[] memberNamespaces, AsyncCallback callback, object object);
    public virtual object EndInvoke(IAsyncResult result);
}
internal class System.Runtime.Serialization.XmlFormatClassWriterDelegate : MulticastDelegate {
    public XmlFormatClassWriterDelegate(object object, IntPtr method);
    public virtual void Invoke(XmlWriterDelegator xmlWriter, object obj, XmlObjectSerializerWriteContext context, ClassDataContract dataContract);
    public virtual IAsyncResult BeginInvoke(XmlWriterDelegator xmlWriter, object obj, XmlObjectSerializerWriteContext context, ClassDataContract dataContract, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.Runtime.Serialization.XmlFormatCollectionReaderDelegate : MulticastDelegate {
    public XmlFormatCollectionReaderDelegate(object object, IntPtr method);
    public virtual object Invoke(XmlReaderDelegator xmlReader, XmlObjectSerializerReadContext context, XmlDictionaryString itemName, XmlDictionaryString itemNamespace, CollectionDataContract collectionContract);
    public virtual IAsyncResult BeginInvoke(XmlReaderDelegator xmlReader, XmlObjectSerializerReadContext context, XmlDictionaryString itemName, XmlDictionaryString itemNamespace, CollectionDataContract collectionContract, AsyncCallback callback, object object);
    public virtual object EndInvoke(IAsyncResult result);
}
internal class System.Runtime.Serialization.XmlFormatCollectionWriterDelegate : MulticastDelegate {
    public XmlFormatCollectionWriterDelegate(object object, IntPtr method);
    public virtual void Invoke(XmlWriterDelegator xmlWriter, object obj, XmlObjectSerializerWriteContext context, CollectionDataContract dataContract);
    public virtual IAsyncResult BeginInvoke(XmlWriterDelegator xmlWriter, object obj, XmlObjectSerializerWriteContext context, CollectionDataContract dataContract, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal static class System.Runtime.Serialization.XmlFormatGeneratorStatics : object {
    [SecurityCriticalAttribute]
private static MethodInfo writeStartElementMethod2;
    [SecurityCriticalAttribute]
private static MethodInfo writeStartElementMethod3;
    [SecurityCriticalAttribute]
private static MethodInfo writeEndElementMethod;
    [SecurityCriticalAttribute]
private static MethodInfo writeNamespaceDeclMethod;
    [SecurityCriticalAttribute]
private static PropertyInfo extensionDataProperty;
    [SecurityCriticalAttribute]
private static MethodInfo boxPointer;
    [SecurityCriticalAttribute]
private static ConstructorInfo dictionaryEnumeratorCtor;
    [SecurityCriticalAttribute]
private static MethodInfo ienumeratorMoveNextMethod;
    [SecurityCriticalAttribute]
private static MethodInfo ienumeratorGetCurrentMethod;
    [SecurityCriticalAttribute]
private static MethodInfo getItemContractMethod;
    [SecurityCriticalAttribute]
private static MethodInfo isStartElementMethod2;
    [SecurityCriticalAttribute]
private static MethodInfo isStartElementMethod0;
    [SecurityCriticalAttribute]
private static MethodInfo getUninitializedObjectMethod;
    [SecurityCriticalAttribute]
private static MethodInfo onDeserializationMethod;
    [SecurityCriticalAttribute]
private static MethodInfo unboxPointer;
    [SecurityCriticalAttribute]
private static PropertyInfo nodeTypeProperty;
    [SecurityCriticalAttribute]
private static ConstructorInfo serializationExceptionCtor;
    [SecurityCriticalAttribute]
private static ConstructorInfo extensionDataObjectCtor;
    [SecurityCriticalAttribute]
private static ConstructorInfo hashtableCtor;
    [SecurityCriticalAttribute]
private static MethodInfo getStreamingContextMethod;
    [SecurityCriticalAttribute]
private static MethodInfo getCollectionMemberMethod;
    [SecurityCriticalAttribute]
private static MethodInfo storeCollectionMemberInfoMethod;
    [SecurityCriticalAttribute]
private static MethodInfo storeIsGetOnlyCollectionMethod;
    [SecurityCriticalAttribute]
private static MethodInfo throwNullValueReturnedForGetOnlyCollectionExceptionMethod;
    private static MethodInfo throwArrayExceededSizeExceptionMethod;
    [SecurityCriticalAttribute]
private static MethodInfo incrementItemCountMethod;
    [SecurityCriticalAttribute]
private static MethodInfo demandSerializationFormatterPermissionMethod;
    [SecurityCriticalAttribute]
private static MethodInfo demandMemberAccessPermissionMethod;
    [SecurityCriticalAttribute]
private static MethodInfo internalDeserializeMethod;
    [SecurityCriticalAttribute]
private static MethodInfo moveToNextElementMethod;
    [SecurityCriticalAttribute]
private static MethodInfo getMemberIndexMethod;
    [SecurityCriticalAttribute]
private static MethodInfo getMemberIndexWithRequiredMembersMethod;
    [SecurityCriticalAttribute]
private static MethodInfo throwRequiredMemberMissingExceptionMethod;
    [SecurityCriticalAttribute]
private static MethodInfo skipUnknownElementMethod;
    [SecurityCriticalAttribute]
private static MethodInfo readIfNullOrRefMethod;
    [SecurityCriticalAttribute]
private static MethodInfo readAttributesMethod;
    [SecurityCriticalAttribute]
private static MethodInfo resetAttributesMethod;
    [SecurityCriticalAttribute]
private static MethodInfo getObjectIdMethod;
    [SecurityCriticalAttribute]
private static MethodInfo getArraySizeMethod;
    [SecurityCriticalAttribute]
private static MethodInfo addNewObjectMethod;
    [SecurityCriticalAttribute]
private static MethodInfo addNewObjectWithIdMethod;
    [SecurityCriticalAttribute]
private static MethodInfo replaceDeserializedObjectMethod;
    [SecurityCriticalAttribute]
private static MethodInfo getExistingObjectMethod;
    [SecurityCriticalAttribute]
private static MethodInfo getRealObjectMethod;
    [SecurityCriticalAttribute]
private static MethodInfo readMethod;
    [SecurityCriticalAttribute]
private static MethodInfo ensureArraySizeMethod;
    [SecurityCriticalAttribute]
private static MethodInfo trimArraySizeMethod;
    [SecurityCriticalAttribute]
private static MethodInfo checkEndOfArrayMethod;
    [SecurityCriticalAttribute]
private static MethodInfo getArrayLengthMethod;
    [SecurityCriticalAttribute]
private static MethodInfo readSerializationInfoMethod;
    [SecurityCriticalAttribute]
private static MethodInfo createUnexpectedStateExceptionMethod;
    [SecurityCriticalAttribute]
private static MethodInfo internalSerializeReferenceMethod;
    [SecurityCriticalAttribute]
private static MethodInfo internalSerializeMethod;
    [SecurityCriticalAttribute]
private static MethodInfo writeNullMethod;
    [SecurityCriticalAttribute]
private static MethodInfo incrementArrayCountMethod;
    [SecurityCriticalAttribute]
private static MethodInfo incrementCollectionCountMethod;
    [SecurityCriticalAttribute]
private static MethodInfo incrementCollectionCountGenericMethod;
    [SecurityCriticalAttribute]
private static MethodInfo getDefaultValueMethod;
    [SecurityCriticalAttribute]
private static MethodInfo getNullableValueMethod;
    [SecurityCriticalAttribute]
private static MethodInfo throwRequiredMemberMustBeEmittedMethod;
    [SecurityCriticalAttribute]
private static MethodInfo getHasValueMethod;
    [SecurityCriticalAttribute]
private static MethodInfo writeISerializableMethod;
    [SecurityCriticalAttribute]
private static MethodInfo writeExtensionDataMethod;
    [SecurityCriticalAttribute]
private static MethodInfo writeXmlValueMethod;
    [SecurityCriticalAttribute]
private static MethodInfo readXmlValueMethod;
    [SecurityCriticalAttribute]
private static MethodInfo throwTypeNotSerializableMethod;
    [SecurityCriticalAttribute]
private static PropertyInfo namespaceProperty;
    [SecurityCriticalAttribute]
private static FieldInfo contractNamespacesField;
    [SecurityCriticalAttribute]
private static FieldInfo memberNamesField;
    [SecurityCriticalAttribute]
private static MethodInfo extensionDataSetExplicitMethodInfo;
    [SecurityCriticalAttribute]
private static PropertyInfo childElementNamespacesProperty;
    [SecurityCriticalAttribute]
private static PropertyInfo collectionItemNameProperty;
    [SecurityCriticalAttribute]
private static PropertyInfo childElementNamespaceProperty;
    [SecurityCriticalAttribute]
private static MethodInfo getDateTimeOffsetMethod;
    [SecurityCriticalAttribute]
private static MethodInfo getDateTimeOffsetAdapterMethod;
    [SecurityCriticalAttribute]
private static MethodInfo traceInstructionMethod;
    [SecurityCriticalAttribute]
private static MethodInfo throwInvalidDataContractExceptionMethod;
    [SecurityCriticalAttribute]
private static PropertyInfo serializeReadOnlyTypesProperty;
    [SecurityCriticalAttribute]
private static PropertyInfo classSerializationExceptionMessageProperty;
    [SecurityCriticalAttribute]
private static PropertyInfo collectionSerializationExceptionMessageProperty;
    internal static MethodInfo WriteStartElementMethod2 { get; }
    internal static MethodInfo WriteStartElementMethod3 { get; }
    internal static MethodInfo WriteEndElementMethod { get; }
    internal static MethodInfo WriteNamespaceDeclMethod { get; }
    internal static PropertyInfo ExtensionDataProperty { get; }
    internal static MethodInfo BoxPointer { get; }
    internal static ConstructorInfo DictionaryEnumeratorCtor { get; }
    internal static MethodInfo MoveNextMethod { get; }
    internal static MethodInfo GetCurrentMethod { get; }
    internal static MethodInfo GetItemContractMethod { get; }
    internal static MethodInfo IsStartElementMethod2 { get; }
    internal static MethodInfo IsStartElementMethod0 { get; }
    internal static MethodInfo GetUninitializedObjectMethod { get; }
    internal static MethodInfo OnDeserializationMethod { get; }
    internal static MethodInfo UnboxPointer { get; }
    internal static PropertyInfo NodeTypeProperty { get; }
    internal static ConstructorInfo SerializationExceptionCtor { get; }
    internal static ConstructorInfo ExtensionDataObjectCtor { get; }
    internal static ConstructorInfo HashtableCtor { get; }
    internal static MethodInfo GetStreamingContextMethod { get; }
    internal static MethodInfo GetCollectionMemberMethod { get; }
    internal static MethodInfo StoreCollectionMemberInfoMethod { get; }
    internal static MethodInfo StoreIsGetOnlyCollectionMethod { get; }
    internal static MethodInfo ThrowNullValueReturnedForGetOnlyCollectionExceptionMethod { get; }
    internal static MethodInfo ThrowArrayExceededSizeExceptionMethod { get; }
    internal static MethodInfo IncrementItemCountMethod { get; }
    internal static MethodInfo DemandSerializationFormatterPermissionMethod { get; }
    internal static MethodInfo DemandMemberAccessPermissionMethod { get; }
    internal static MethodInfo InternalDeserializeMethod { get; }
    internal static MethodInfo MoveToNextElementMethod { get; }
    internal static MethodInfo GetMemberIndexMethod { get; }
    internal static MethodInfo GetMemberIndexWithRequiredMembersMethod { get; }
    internal static MethodInfo ThrowRequiredMemberMissingExceptionMethod { get; }
    internal static MethodInfo SkipUnknownElementMethod { get; }
    internal static MethodInfo ReadIfNullOrRefMethod { get; }
    internal static MethodInfo ReadAttributesMethod { get; }
    internal static MethodInfo ResetAttributesMethod { get; }
    internal static MethodInfo GetObjectIdMethod { get; }
    internal static MethodInfo GetArraySizeMethod { get; }
    internal static MethodInfo AddNewObjectMethod { get; }
    internal static MethodInfo AddNewObjectWithIdMethod { get; }
    internal static MethodInfo ReplaceDeserializedObjectMethod { get; }
    internal static MethodInfo GetExistingObjectMethod { get; }
    internal static MethodInfo GetRealObjectMethod { get; }
    internal static MethodInfo ReadMethod { get; }
    internal static MethodInfo EnsureArraySizeMethod { get; }
    internal static MethodInfo TrimArraySizeMethod { get; }
    internal static MethodInfo CheckEndOfArrayMethod { get; }
    internal static MethodInfo GetArrayLengthMethod { get; }
    internal static MethodInfo ReadSerializationInfoMethod { get; }
    internal static MethodInfo CreateUnexpectedStateExceptionMethod { get; }
    internal static MethodInfo InternalSerializeReferenceMethod { get; }
    internal static MethodInfo InternalSerializeMethod { get; }
    internal static MethodInfo WriteNullMethod { get; }
    internal static MethodInfo IncrementArrayCountMethod { get; }
    internal static MethodInfo IncrementCollectionCountMethod { get; }
    internal static MethodInfo IncrementCollectionCountGenericMethod { get; }
    internal static MethodInfo GetDefaultValueMethod { get; }
    internal static MethodInfo GetNullableValueMethod { get; }
    internal static MethodInfo ThrowRequiredMemberMustBeEmittedMethod { get; }
    internal static MethodInfo GetHasValueMethod { get; }
    internal static MethodInfo WriteISerializableMethod { get; }
    internal static MethodInfo WriteExtensionDataMethod { get; }
    internal static MethodInfo WriteXmlValueMethod { get; }
    internal static MethodInfo ReadXmlValueMethod { get; }
    internal static MethodInfo ThrowTypeNotSerializableMethod { get; }
    internal static PropertyInfo NamespaceProperty { get; }
    internal static FieldInfo ContractNamespacesField { get; }
    internal static FieldInfo MemberNamesField { get; }
    internal static MethodInfo ExtensionDataSetExplicitMethodInfo { get; }
    internal static PropertyInfo ChildElementNamespacesProperty { get; }
    internal static PropertyInfo CollectionItemNameProperty { get; }
    internal static PropertyInfo ChildElementNamespaceProperty { get; }
    internal static MethodInfo GetDateTimeOffsetMethod { get; }
    internal static MethodInfo GetDateTimeOffsetAdapterMethod { get; }
    internal static MethodInfo TraceInstructionMethod { get; }
    internal static MethodInfo ThrowInvalidDataContractExceptionMethod { get; }
    internal static PropertyInfo SerializeReadOnlyTypesProperty { get; }
    internal static PropertyInfo ClassSerializationExceptionMessageProperty { get; }
    internal static PropertyInfo CollectionSerializationExceptionMessageProperty { get; }
    [SecuritySafeCriticalAttribute]
internal static MethodInfo get_WriteStartElementMethod2();
    [SecuritySafeCriticalAttribute]
internal static MethodInfo get_WriteStartElementMethod3();
    [SecuritySafeCriticalAttribute]
internal static MethodInfo get_WriteEndElementMethod();
    [SecuritySafeCriticalAttribute]
internal static MethodInfo get_WriteNamespaceDeclMethod();
    [SecuritySafeCriticalAttribute]
internal static PropertyInfo get_ExtensionDataProperty();
    [SecuritySafeCriticalAttribute]
internal static MethodInfo get_BoxPointer();
    [SecuritySafeCriticalAttribute]
internal static ConstructorInfo get_DictionaryEnumeratorCtor();
    [SecuritySafeCriticalAttribute]
internal static MethodInfo get_MoveNextMethod();
    [SecuritySafeCriticalAttribute]
internal static MethodInfo get_GetCurrentMethod();
    [SecuritySafeCriticalAttribute]
internal static MethodInfo get_GetItemContractMethod();
    [SecuritySafeCriticalAttribute]
internal static MethodInfo get_IsStartElementMethod2();
    [SecuritySafeCriticalAttribute]
internal static MethodInfo get_IsStartElementMethod0();
    [SecuritySafeCriticalAttribute]
internal static MethodInfo get_GetUninitializedObjectMethod();
    [SecuritySafeCriticalAttribute]
internal static MethodInfo get_OnDeserializationMethod();
    [SecuritySafeCriticalAttribute]
internal static MethodInfo get_UnboxPointer();
    [SecuritySafeCriticalAttribute]
internal static PropertyInfo get_NodeTypeProperty();
    [SecuritySafeCriticalAttribute]
internal static ConstructorInfo get_SerializationExceptionCtor();
    [SecuritySafeCriticalAttribute]
internal static ConstructorInfo get_ExtensionDataObjectCtor();
    [SecuritySafeCriticalAttribute]
internal static ConstructorInfo get_HashtableCtor();
    [SecuritySafeCriticalAttribute]
internal static MethodInfo get_GetStreamingContextMethod();
    [SecuritySafeCriticalAttribute]
internal static MethodInfo get_GetCollectionMemberMethod();
    [SecuritySafeCriticalAttribute]
internal static MethodInfo get_StoreCollectionMemberInfoMethod();
    [SecuritySafeCriticalAttribute]
internal static MethodInfo get_StoreIsGetOnlyCollectionMethod();
    [SecuritySafeCriticalAttribute]
internal static MethodInfo get_ThrowNullValueReturnedForGetOnlyCollectionExceptionMethod();
    [SecuritySafeCriticalAttribute]
internal static MethodInfo get_ThrowArrayExceededSizeExceptionMethod();
    [SecuritySafeCriticalAttribute]
internal static MethodInfo get_IncrementItemCountMethod();
    [SecuritySafeCriticalAttribute]
internal static MethodInfo get_DemandSerializationFormatterPermissionMethod();
    [SecuritySafeCriticalAttribute]
internal static MethodInfo get_DemandMemberAccessPermissionMethod();
    [SecuritySafeCriticalAttribute]
internal static MethodInfo get_InternalDeserializeMethod();
    [SecuritySafeCriticalAttribute]
internal static MethodInfo get_MoveToNextElementMethod();
    [SecuritySafeCriticalAttribute]
internal static MethodInfo get_GetMemberIndexMethod();
    [SecuritySafeCriticalAttribute]
internal static MethodInfo get_GetMemberIndexWithRequiredMembersMethod();
    [SecuritySafeCriticalAttribute]
internal static MethodInfo get_ThrowRequiredMemberMissingExceptionMethod();
    [SecuritySafeCriticalAttribute]
internal static MethodInfo get_SkipUnknownElementMethod();
    [SecuritySafeCriticalAttribute]
internal static MethodInfo get_ReadIfNullOrRefMethod();
    [SecuritySafeCriticalAttribute]
internal static MethodInfo get_ReadAttributesMethod();
    [SecuritySafeCriticalAttribute]
internal static MethodInfo get_ResetAttributesMethod();
    [SecuritySafeCriticalAttribute]
internal static MethodInfo get_GetObjectIdMethod();
    [SecuritySafeCriticalAttribute]
internal static MethodInfo get_GetArraySizeMethod();
    [SecuritySafeCriticalAttribute]
internal static MethodInfo get_AddNewObjectMethod();
    [SecuritySafeCriticalAttribute]
internal static MethodInfo get_AddNewObjectWithIdMethod();
    [SecuritySafeCriticalAttribute]
internal static MethodInfo get_ReplaceDeserializedObjectMethod();
    [SecuritySafeCriticalAttribute]
internal static MethodInfo get_GetExistingObjectMethod();
    [SecuritySafeCriticalAttribute]
internal static MethodInfo get_GetRealObjectMethod();
    [SecuritySafeCriticalAttribute]
internal static MethodInfo get_ReadMethod();
    [SecuritySafeCriticalAttribute]
internal static MethodInfo get_EnsureArraySizeMethod();
    [SecuritySafeCriticalAttribute]
internal static MethodInfo get_TrimArraySizeMethod();
    [SecuritySafeCriticalAttribute]
internal static MethodInfo get_CheckEndOfArrayMethod();
    [SecuritySafeCriticalAttribute]
internal static MethodInfo get_GetArrayLengthMethod();
    [SecuritySafeCriticalAttribute]
internal static MethodInfo get_ReadSerializationInfoMethod();
    [SecuritySafeCriticalAttribute]
internal static MethodInfo get_CreateUnexpectedStateExceptionMethod();
    [SecuritySafeCriticalAttribute]
internal static MethodInfo get_InternalSerializeReferenceMethod();
    [SecuritySafeCriticalAttribute]
internal static MethodInfo get_InternalSerializeMethod();
    [SecuritySafeCriticalAttribute]
internal static MethodInfo get_WriteNullMethod();
    [SecuritySafeCriticalAttribute]
internal static MethodInfo get_IncrementArrayCountMethod();
    [SecuritySafeCriticalAttribute]
internal static MethodInfo get_IncrementCollectionCountMethod();
    [SecuritySafeCriticalAttribute]
internal static MethodInfo get_IncrementCollectionCountGenericMethod();
    [SecuritySafeCriticalAttribute]
internal static MethodInfo get_GetDefaultValueMethod();
    [SecuritySafeCriticalAttribute]
internal static MethodInfo get_GetNullableValueMethod();
    [SecuritySafeCriticalAttribute]
internal static MethodInfo get_ThrowRequiredMemberMustBeEmittedMethod();
    [SecuritySafeCriticalAttribute]
internal static MethodInfo get_GetHasValueMethod();
    [SecuritySafeCriticalAttribute]
internal static MethodInfo get_WriteISerializableMethod();
    [SecuritySafeCriticalAttribute]
internal static MethodInfo get_WriteExtensionDataMethod();
    [SecuritySafeCriticalAttribute]
internal static MethodInfo get_WriteXmlValueMethod();
    [SecuritySafeCriticalAttribute]
internal static MethodInfo get_ReadXmlValueMethod();
    [SecuritySafeCriticalAttribute]
internal static MethodInfo get_ThrowTypeNotSerializableMethod();
    [SecuritySafeCriticalAttribute]
internal static PropertyInfo get_NamespaceProperty();
    [SecuritySafeCriticalAttribute]
internal static FieldInfo get_ContractNamespacesField();
    [SecuritySafeCriticalAttribute]
internal static FieldInfo get_MemberNamesField();
    [SecuritySafeCriticalAttribute]
internal static MethodInfo get_ExtensionDataSetExplicitMethodInfo();
    [SecuritySafeCriticalAttribute]
internal static PropertyInfo get_ChildElementNamespacesProperty();
    [SecuritySafeCriticalAttribute]
internal static PropertyInfo get_CollectionItemNameProperty();
    [SecuritySafeCriticalAttribute]
internal static PropertyInfo get_ChildElementNamespaceProperty();
    [SecuritySafeCriticalAttribute]
internal static MethodInfo get_GetDateTimeOffsetMethod();
    [SecuritySafeCriticalAttribute]
internal static MethodInfo get_GetDateTimeOffsetAdapterMethod();
    [SecuritySafeCriticalAttribute]
internal static MethodInfo get_TraceInstructionMethod();
    [SecuritySafeCriticalAttribute]
internal static MethodInfo get_ThrowInvalidDataContractExceptionMethod();
    [SecuritySafeCriticalAttribute]
internal static PropertyInfo get_SerializeReadOnlyTypesProperty();
    [SecuritySafeCriticalAttribute]
internal static PropertyInfo get_ClassSerializationExceptionMessageProperty();
    [SecuritySafeCriticalAttribute]
internal static PropertyInfo get_CollectionSerializationExceptionMessageProperty();
}
internal class System.Runtime.Serialization.XmlFormatGetOnlyCollectionReaderDelegate : MulticastDelegate {
    public XmlFormatGetOnlyCollectionReaderDelegate(object object, IntPtr method);
    public virtual void Invoke(XmlReaderDelegator xmlReader, XmlObjectSerializerReadContext context, XmlDictionaryString itemName, XmlDictionaryString itemNamespace, CollectionDataContract collectionContract);
    public virtual IAsyncResult BeginInvoke(XmlReaderDelegator xmlReader, XmlObjectSerializerReadContext context, XmlDictionaryString itemName, XmlDictionaryString itemNamespace, CollectionDataContract collectionContract, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.Runtime.Serialization.XmlFormatReaderGenerator : object {
    [SecurityCriticalAttribute]
private CriticalHelper helper;
    [SecurityCriticalAttribute]
public XmlFormatClassReaderDelegate GenerateClassReader(ClassDataContract classContract);
    [SecurityCriticalAttribute]
public XmlFormatCollectionReaderDelegate GenerateCollectionReader(CollectionDataContract collectionContract);
    [SecurityCriticalAttribute]
public XmlFormatGetOnlyCollectionReaderDelegate GenerateGetOnlyCollectionReader(CollectionDataContract collectionContract);
    [SecuritySafeCriticalAttribute]
internal static object UnsafeGetUninitializedObject(int id);
}
internal class System.Runtime.Serialization.XmlFormatReaderInterpreter : object {
    private bool is_get_only_collection;
    private ClassDataContract classContract;
    private CollectionDataContract collectionContract;
    private object objectLocal;
    private Type objectType;
    private XmlReaderDelegator xmlReader;
    private XmlObjectSerializerReadContext context;
    private XmlDictionaryString[] memberNames;
    private XmlDictionaryString[] memberNamespaces;
    private XmlDictionaryString itemName;
    private XmlDictionaryString itemNamespace;
    public XmlFormatReaderInterpreter(ClassDataContract classContract);
    public XmlFormatReaderInterpreter(CollectionDataContract collectionContract, bool isGetOnly);
    public object ReadFromXml(XmlReaderDelegator xmlReader, XmlObjectSerializerReadContext context, XmlDictionaryString[] memberNames, XmlDictionaryString[] memberNamespaces);
    public object ReadCollectionFromXml(XmlReaderDelegator xmlReader, XmlObjectSerializerReadContext context, XmlDictionaryString itemName, XmlDictionaryString itemNamespace, CollectionDataContract collectionContract);
    public void ReadGetOnlyCollectionFromXml(XmlReaderDelegator xmlReader, XmlObjectSerializerReadContext context, XmlDictionaryString itemName, XmlDictionaryString itemNamespace, CollectionDataContract collectionContract);
    private void CreateObject(ClassDataContract classContract);
    private void InvokeOnDeserializing(ClassDataContract classContract);
    private void InvokeOnDeserialized(ClassDataContract classContract);
    private bool HasFactoryMethod(ClassDataContract classContract);
    private bool InvokeFactoryMethod(ClassDataContract classContract, string objectId);
    private void ReadISerializable(ClassDataContract classContract);
    private void ReadClass(ClassDataContract classContract);
    private void ReadMembers(ClassDataContract classContract, ExtensionDataObject extensionData);
    private int ReadMembers(int index, ClassDataContract classContract, Boolean[] requiredMembers, Int32& memberIndex, Int32& requiredIndex);
    private Boolean[] GetRequiredMembers(ClassDataContract contract, Int32& firstRequiredMember);
    private int GetRequiredMembers(ClassDataContract contract, Boolean[] requiredMembers);
    private object ReadValue(Type type, string name, string ns);
    private object InternalDeserialize(Type type, string name, string ns);
    private object WrapNullableObject(Type innerType, object innerValue, Type outerType, int nullables);
    private void ReadCollection(CollectionDataContract collectionContract);
    private void ReadGetOnlyCollection(CollectionDataContract collectionContract);
    private bool TryReadPrimitiveArray(Type type, Type itemType, int size, Boolean& readResult);
    private object ReadCollectionItem(CollectionDataContract collectionContract, Type itemType, string itemName, string itemNs);
    private void StoreCollectionValue(object collection, Type valueType, object value, CollectionDataContract collectionContract);
    private void HandleUnexpectedItemInCollection(Int32& iterator);
    private bool IsStartElement(XmlDictionaryString name, XmlDictionaryString ns);
    private bool IsStartElement();
    private bool IsEndElement();
}
internal class System.Runtime.Serialization.XmlFormatWriterGenerator : object {
    [SecurityCriticalAttribute]
private CriticalHelper helper;
    [SecurityCriticalAttribute]
internal XmlFormatClassWriterDelegate GenerateClassWriter(ClassDataContract classContract);
    [SecurityCriticalAttribute]
internal XmlFormatCollectionWriterDelegate GenerateCollectionWriter(CollectionDataContract collectionContract);
}
internal class System.Runtime.Serialization.XmlFormatWriterInterpreter : object {
    private ClassDataContract classContract;
    private CollectionDataContract collectionContract;
    private XmlWriterDelegator writer;
    private object obj;
    private XmlObjectSerializerWriteContext ctx;
    private DataContract dataContract;
    private object objLocal;
    private XmlDictionaryString[] contractNamespaces;
    private XmlDictionaryString[] memberNames;
    private XmlDictionaryString[] childElementNamespaces;
    private int typeIndex;
    private int childElementIndex;
    private ClassDataContract classDataContract { get; }
    private CollectionDataContract collectionDataContract { get; }
    public XmlFormatWriterInterpreter(ClassDataContract classContract);
    public XmlFormatWriterInterpreter(CollectionDataContract collectionContract);
    private ClassDataContract get_classDataContract();
    private CollectionDataContract get_collectionDataContract();
    public void WriteToXml(XmlWriterDelegator xmlWriter, object obj, XmlObjectSerializerWriteContext context, ClassDataContract dataContract);
    public void WriteCollectionToXml(XmlWriterDelegator xmlWriter, object obj, XmlObjectSerializerWriteContext context, CollectionDataContract collectionContract);
    private void InitArgs(Type objType);
    private void InvokeOnSerializing(ClassDataContract classContract, object objSerialized, XmlObjectSerializerWriteContext ctx);
    private void InvokeOnSerialized(ClassDataContract classContract, object objSerialized, XmlObjectSerializerWriteContext ctx);
    private void WriteClass(ClassDataContract classContract);
    private void WriteCollection(CollectionDataContract collectionContract);
    private int WriteMembers(ClassDataContract classContract, ExtensionDataObject extensionData, ClassDataContract derivedMostClassContract);
    internal bool IsDefaultValue(Type type, object value);
    internal object GetDefaultValue(Type type);
    private bool CheckIfMemberHasConflict(DataMember member, ClassDataContract classContract, ClassDataContract derivedMostClassContract);
    private bool CheckIfConflictingMembersHaveDifferentTypes(DataMember member);
    private bool NeedsPrefix(Type type, XmlDictionaryString ns);
    private void WriteStartElement(Type type, XmlDictionaryString ns, XmlDictionaryString namespaceLocal, XmlDictionaryString nameLocal, int nameIndex);
    private void WriteEndElement();
    private void WriteValue(Type memberType, object memberValue, bool writeXsiType);
    private object UnwrapNullableObject(Func`1<object> memberValue, Type& memberType, Boolean& isNull);
    private bool TryWritePrimitive(Type type, Func`1<object> value, MemberInfo memberInfo, Nullable`1<int> arrayItemIndex, XmlDictionaryString ns, XmlDictionaryString name, int nameIndex);
    private bool TryWritePrimitiveArray(Type type, Type itemType, Func`1<object> value, XmlDictionaryString itemName, XmlDictionaryString itemNamespace);
    private object LoadMemberValue(DataMember member);
    [CompilerGeneratedAttribute]
private object <WriteCollection>b__24_0();
}
public abstract class System.Runtime.Serialization.XmlObjectSerializer : object {
    [SecurityCriticalAttribute]
private static IFormatterConverter formatterConverter;
    internal Dictionary`2<XmlQualifiedName, DataContract> KnownDataContracts { get; }
    internal static IFormatterConverter FormatterConverter { get; }
    public abstract virtual void WriteStartObject(XmlDictionaryWriter writer, object graph);
    public abstract virtual void WriteObjectContent(XmlDictionaryWriter writer, object graph);
    public abstract virtual void WriteEndObject(XmlDictionaryWriter writer);
    public virtual void WriteObject(Stream stream, object graph);
    public virtual void WriteObject(XmlWriter writer, object graph);
    public virtual void WriteStartObject(XmlWriter writer, object graph);
    public virtual void WriteObjectContent(XmlWriter writer, object graph);
    public virtual void WriteEndObject(XmlWriter writer);
    public virtual void WriteObject(XmlDictionaryWriter writer, object graph);
    internal void WriteObjectHandleExceptions(XmlWriterDelegator writer, object graph);
    internal void WriteObjectHandleExceptions(XmlWriterDelegator writer, object graph, DataContractResolver dataContractResolver);
    internal virtual Dictionary`2<XmlQualifiedName, DataContract> get_KnownDataContracts();
    internal virtual void InternalWriteObject(XmlWriterDelegator writer, object graph);
    internal virtual void InternalWriteObject(XmlWriterDelegator writer, object graph, DataContractResolver dataContractResolver);
    internal virtual void InternalWriteStartObject(XmlWriterDelegator writer, object graph);
    internal virtual void InternalWriteObjectContent(XmlWriterDelegator writer, object graph);
    internal virtual void InternalWriteEndObject(XmlWriterDelegator writer);
    internal void WriteStartObjectHandleExceptions(XmlWriterDelegator writer, object graph);
    internal void WriteObjectContentHandleExceptions(XmlWriterDelegator writer, object graph);
    internal void WriteEndObjectHandleExceptions(XmlWriterDelegator writer);
    internal void WriteRootElement(XmlWriterDelegator writer, DataContract contract, XmlDictionaryString name, XmlDictionaryString ns, bool needsContractNsAtRoot);
    internal bool CheckIfNeedsContractNsAtRoot(XmlDictionaryString name, XmlDictionaryString ns, DataContract contract);
    internal static void WriteNull(XmlWriterDelegator writer);
    internal static bool IsContractDeclared(DataContract contract, DataContract declaredContract);
    public virtual object ReadObject(Stream stream);
    public virtual object ReadObject(XmlReader reader);
    public virtual object ReadObject(XmlDictionaryReader reader);
    public virtual object ReadObject(XmlReader reader, bool verifyObjectName);
    public abstract virtual object ReadObject(XmlDictionaryReader reader, bool verifyObjectName);
    public virtual bool IsStartObject(XmlReader reader);
    public abstract virtual bool IsStartObject(XmlDictionaryReader reader);
    internal virtual object InternalReadObject(XmlReaderDelegator reader, bool verifyObjectName);
    internal virtual object InternalReadObject(XmlReaderDelegator reader, bool verifyObjectName, DataContractResolver dataContractResolver);
    internal virtual bool InternalIsStartObject(XmlReaderDelegator reader);
    internal object ReadObjectHandleExceptions(XmlReaderDelegator reader, bool verifyObjectName);
    internal object ReadObjectHandleExceptions(XmlReaderDelegator reader, bool verifyObjectName, DataContractResolver dataContractResolver);
    internal bool IsStartObjectHandleExceptions(XmlReaderDelegator reader);
    internal bool IsRootXmlAny(XmlDictionaryString rootName, DataContract contract);
    internal bool IsStartElement(XmlReaderDelegator reader);
    internal bool IsRootElement(XmlReaderDelegator reader, DataContract contract, XmlDictionaryString name, XmlDictionaryString ns);
    internal static void CheckNull(object obj, string name);
    internal static string TryAddLineInfo(XmlReaderDelegator reader, string errorMessage);
    internal static Exception CreateSerializationExceptionWithReaderDetails(string errorMessage, XmlReaderDelegator reader);
    internal static SerializationException CreateSerializationException(string errorMessage);
    internal static SerializationException CreateSerializationException(string errorMessage, Exception innerException);
    private static string GetTypeInfo(Type type);
    private static string GetTypeInfoError(string errorMessage, Type type, Exception innerException);
    internal virtual Type GetSerializeType(object graph);
    internal virtual Type GetDeserializeType();
    [SecuritySafeCriticalAttribute]
internal static IFormatterConverter get_FormatterConverter();
}
internal class System.Runtime.Serialization.XmlObjectSerializerContext : object {
    protected XmlObjectSerializer serializer;
    protected DataContract rootTypeDataContract;
    internal ScopedKnownTypes scopedKnownTypes;
    protected Dictionary`2<XmlQualifiedName, DataContract> serializerKnownDataContracts;
    private bool isSerializerKnownDataContractsSetExplicit;
    protected IList`1<Type> serializerKnownTypeList;
    [SecurityCriticalAttribute]
private bool demandedSerializationFormatterPermission;
    [SecurityCriticalAttribute]
private bool demandedMemberAccessPermission;
    private int itemCount;
    private int maxItemsInObjectGraph;
    private StreamingContext streamingContext;
    private bool ignoreExtensionDataObject;
    private DataContractResolver dataContractResolver;
    private KnownTypeDataContractResolver knownTypeResolver;
    private static MethodInfo incrementItemCountMethod;
    internal SerializationMode Mode { get; }
    internal bool IsGetOnlyCollection { get; internal set; }
    internal static MethodInfo IncrementItemCountMethod { get; }
    internal int RemainingItemCount { get; }
    internal bool IgnoreExtensionDataObject { get; }
    protected DataContractResolver DataContractResolver { get; }
    protected KnownTypeDataContractResolver KnownTypeResolver { get; }
    private Dictionary`2<XmlQualifiedName, DataContract> SerializerKnownDataContracts { get; }
    internal XmlObjectSerializerContext(XmlObjectSerializer serializer, int maxItemsInObjectGraph, StreamingContext streamingContext, bool ignoreExtensionDataObject, DataContractResolver dataContractResolver);
    internal XmlObjectSerializerContext(XmlObjectSerializer serializer, int maxItemsInObjectGraph, StreamingContext streamingContext, bool ignoreExtensionDataObject);
    internal XmlObjectSerializerContext(DataContractSerializer serializer, DataContract rootTypeDataContract, DataContractResolver dataContractResolver);
    internal XmlObjectSerializerContext(NetDataContractSerializer serializer);
    internal virtual SerializationMode get_Mode();
    internal virtual bool get_IsGetOnlyCollection();
    internal virtual void set_IsGetOnlyCollection(bool value);
    [SecuritySafeCriticalAttribute]
public void DemandSerializationFormatterPermission();
    [SecuritySafeCriticalAttribute]
public void DemandMemberAccessPermission();
    public StreamingContext GetStreamingContext();
    internal static MethodInfo get_IncrementItemCountMethod();
    public void IncrementItemCount(int count);
    internal int get_RemainingItemCount();
    internal bool get_IgnoreExtensionDataObject();
    protected DataContractResolver get_DataContractResolver();
    protected KnownTypeDataContractResolver get_KnownTypeResolver();
    internal DataContract GetDataContract(Type type);
    internal virtual DataContract GetDataContract(RuntimeTypeHandle typeHandle, Type type);
    internal virtual DataContract GetDataContractSkipValidation(int typeId, RuntimeTypeHandle typeHandle, Type type);
    internal virtual DataContract GetDataContract(int id, RuntimeTypeHandle typeHandle);
    internal virtual void CheckIfTypeSerializable(Type memberType, bool isMemberTypeSerializable);
    internal virtual Type GetSurrogatedType(Type type);
    private Dictionary`2<XmlQualifiedName, DataContract> get_SerializerKnownDataContracts();
    private DataContract GetDataContractFromSerializerKnownTypes(XmlQualifiedName qname);
    internal static Dictionary`2<XmlQualifiedName, DataContract> GetDataContractsForKnownTypes(IList`1<Type> knownTypeList);
    internal bool IsKnownType(DataContract dataContract, Dictionary`2<XmlQualifiedName, DataContract> knownDataContracts, Type declaredType);
    internal bool IsKnownType(DataContract dataContract, Type declaredType);
    private DataContract ResolveDataContractFromKnownTypes(XmlQualifiedName typeName);
    private DataContract ResolveDataContractFromDataContractResolver(XmlQualifiedName typeName, Type declaredType);
    internal Type ResolveNameFromKnownTypes(XmlQualifiedName typeName);
    protected DataContract ResolveDataContractFromKnownTypes(string typeName, string typeNs, DataContract memberTypeContract, Type declaredType);
    protected virtual DataContract ResolveDataContractFromRootDataContract(XmlQualifiedName typeQName);
}
internal class System.Runtime.Serialization.XmlObjectSerializerReadContext : XmlObjectSerializerContext {
    internal Attributes attributes;
    private HybridObjectCache deserializedObjects;
    private XmlSerializableReader xmlSerializableReader;
    private XmlDocument xmlDocument;
    private Attributes attributesInXmlData;
    private XmlReaderDelegator extensionDataReader;
    private object getOnlyCollectionValue;
    private bool isGetOnlyCollection;
    private HybridObjectCache DeserializedObjects { get; }
    private XmlDocument Document { get; }
    internal bool IsGetOnlyCollection { get; internal set; }
    internal XmlObjectSerializerReadContext(XmlObjectSerializer serializer, int maxItemsInObjectGraph, StreamingContext streamingContext, bool ignoreExtensionDataObject);
    internal XmlObjectSerializerReadContext(DataContractSerializer serializer, DataContract rootTypeDataContract, DataContractResolver dataContractResolver);
    protected XmlObjectSerializerReadContext(NetDataContractSerializer serializer);
    private HybridObjectCache get_DeserializedObjects();
    private XmlDocument get_Document();
    internal virtual bool get_IsGetOnlyCollection();
    internal virtual void set_IsGetOnlyCollection(bool value);
    internal object GetCollectionMember();
    internal void StoreCollectionMemberInfo(object collectionMember);
    internal static void ThrowNullValueReturnedForGetOnlyCollectionException(Type type);
    internal static void ThrowArrayExceededSizeException(int arraySize, Type type);
    internal static XmlObjectSerializerReadContext CreateContext(DataContractSerializer serializer, DataContract rootTypeDataContract, DataContractResolver dataContractResolver);
    internal static XmlObjectSerializerReadContext CreateContext(NetDataContractSerializer serializer);
    public virtual object InternalDeserialize(XmlReaderDelegator xmlReader, int id, RuntimeTypeHandle declaredTypeHandle, string name, string ns);
    internal virtual object InternalDeserialize(XmlReaderDelegator xmlReader, Type declaredType, string name, string ns);
    internal virtual object InternalDeserialize(XmlReaderDelegator xmlReader, Type declaredType, DataContract dataContract, string name, string ns);
    protected bool TryHandleNullOrRef(XmlReaderDelegator reader, Type declaredType, string name, string ns, Object& retObj);
    protected object InternalDeserialize(XmlReaderDelegator reader, string name, string ns, Type declaredType, DataContract& dataContract);
    private bool ReplaceScopedKnownTypesTop(Dictionary`2<XmlQualifiedName, DataContract> knownDataContracts, bool knownTypesAddedInCurrentScope);
    public static bool MoveToNextElement(XmlReaderDelegator xmlReader);
    public int GetMemberIndex(XmlReaderDelegator xmlReader, XmlDictionaryString[] memberNames, XmlDictionaryString[] memberNamespaces, int memberIndex, ExtensionDataObject extensionData);
    public int GetMemberIndexWithRequiredMembers(XmlReaderDelegator xmlReader, XmlDictionaryString[] memberNames, XmlDictionaryString[] memberNamespaces, int memberIndex, int requiredIndex, ExtensionDataObject extensionData);
    public static void ThrowRequiredMemberMissingException(XmlReaderDelegator xmlReader, int memberIndex, int requiredIndex, XmlDictionaryString[] memberNames);
    protected void HandleMemberNotFound(XmlReaderDelegator xmlReader, ExtensionDataObject extensionData, int memberIndex);
    internal void HandleUnknownElement(XmlReaderDelegator xmlReader, ExtensionDataObject extensionData, int memberIndex);
    public void SkipUnknownElement(XmlReaderDelegator xmlReader);
    public string ReadIfNullOrRef(XmlReaderDelegator xmlReader, Type memberType, bool isMemberTypeSerializable);
    internal virtual void ReadAttributes(XmlReaderDelegator xmlReader);
    public void ResetAttributes();
    public string GetObjectId();
    internal virtual int GetArraySize();
    public void AddNewObject(object obj);
    public void AddNewObjectWithId(string id, object obj);
    public void ReplaceDeserializedObject(string id, object oldObj, object newObj);
    public object GetExistingObject(string id, Type type, string name, string ns);
    private object GetExistingObjectOrExtensionData(string id);
    public object GetRealObject(IObjectReference obj, string id);
    private object DeserializeFromExtensionData(IDataNode dataNode, Type type, string name, string ns);
    public static void Read(XmlReaderDelegator xmlReader);
    internal static void ParseQualifiedName(string qname, XmlReaderDelegator xmlReader, String& name, String& ns, String& prefix);
    public static T[] EnsureArraySize(T[] array, int index);
    public static T[] TrimArraySize(T[] array, int size);
    public void CheckEndOfArray(XmlReaderDelegator xmlReader, int arraySize, XmlDictionaryString itemName, XmlDictionaryString itemNamespace);
    internal object ReadIXmlSerializable(XmlReaderDelegator xmlReader, XmlDataContract xmlDataContract, bool isMemberType);
    internal static object ReadRootIXmlSerializable(XmlReaderDelegator xmlReader, XmlDataContract xmlDataContract, bool isMemberType);
    internal static object ReadIXmlSerializable(XmlSerializableReader xmlSerializableReader, XmlReaderDelegator xmlReader, XmlDataContract xmlDataContract, bool isMemberType);
    public SerializationInfo ReadSerializationInfo(XmlReaderDelegator xmlReader, Type type);
    protected virtual DataContract ResolveDataContractFromTypeName();
    private ExtensionDataMember ReadExtensionDataMember(XmlReaderDelegator xmlReader, int memberIndex);
    public IDataNode ReadExtensionDataValue(XmlReaderDelegator xmlReader);
    protected virtual void StartReadExtensionDataValue(XmlReaderDelegator xmlReader);
    private IDataNode ReadExtensionDataValue(XmlReaderDelegator xmlReader, string dataContractName, string dataContractNamespace);
    protected virtual IDataNode ReadPrimitiveExtensionDataValue(XmlReaderDelegator xmlReader, string dataContractName, string dataContractNamespace);
    protected void InitializeExtensionDataNode(IDataNode dataNode, string dataContractName, string dataContractNamespace);
    private IDataNode ReadUnknownPrimitiveData(XmlReaderDelegator xmlReader, Type type, string dataContractName, string dataContractNamespace);
    private ClassDataNode ReadUnknownClassData(XmlReaderDelegator xmlReader, string dataContractName, string dataContractNamespace);
    private CollectionDataNode ReadUnknownCollectionData(XmlReaderDelegator xmlReader, string dataContractName, string dataContractNamespace);
    private ISerializableDataNode ReadUnknownISerializableData(XmlReaderDelegator xmlReader, string dataContractName, string dataContractNamespace);
    private IDataNode ReadUnknownXmlData(XmlReaderDelegator xmlReader, string dataContractName, string dataContractNamespace);
    private IDataNode ReadAndResolveUnknownXmlData(XmlReaderDelegator xmlReader, IDictionary`2<string, string> namespaces, string dataContractName, string dataContractNamespace);
    private bool IsContentNode(XmlNodeType nodeType);
    internal XmlReaderDelegator CreateReaderOverChildNodes(IList`1<XmlAttribute> xmlAttributes, IList`1<XmlNode> xmlChildNodes);
    internal static XmlNode CreateWrapperXmlElement(XmlDocument document, IList`1<XmlAttribute> xmlAttributes, IList`1<XmlNode> xmlChildNodes, string prefix, string localName, string ns);
    private XmlAttribute AddNamespaceDeclaration(string prefix, string ns);
    public static Exception CreateUnexpectedStateException(XmlNodeType expectedState, XmlReaderDelegator xmlReader);
    protected virtual object ReadDataContractValue(DataContract dataContract, XmlReaderDelegator reader);
    protected virtual XmlReaderDelegator CreateReaderDelegatorForReader(XmlReader xmlReader);
    protected virtual bool IsReadingCollectionExtensionData(XmlReaderDelegator xmlReader);
    protected virtual bool IsReadingClassExtensionData(XmlReaderDelegator xmlReader);
}
internal class System.Runtime.Serialization.XmlObjectSerializerReadContextComplex : XmlObjectSerializerReadContext {
    private static Hashtable dataContractTypeCache;
    private bool preserveObjectReferences;
    protected IDataContractSurrogate dataContractSurrogate;
    private SerializationMode mode;
    private SerializationBinder binder;
    private ISurrogateSelector surrogateSelector;
    private FormatterAssemblyStyle assemblyFormat;
    private Hashtable surrogateDataContracts;
    internal SerializationMode Mode { get; }
    internal XmlObjectSerializerReadContextComplex(DataContractSerializer serializer, DataContract rootTypeDataContract, DataContractResolver dataContractResolver);
    internal XmlObjectSerializerReadContextComplex(NetDataContractSerializer serializer);
    internal XmlObjectSerializerReadContextComplex(XmlObjectSerializer serializer, int maxItemsInObjectGraph, StreamingContext streamingContext, bool ignoreExtensionDataObject);
    private static XmlObjectSerializerReadContextComplex();
    internal virtual SerializationMode get_Mode();
    internal virtual DataContract GetDataContract(int id, RuntimeTypeHandle typeHandle);
    internal virtual DataContract GetDataContract(RuntimeTypeHandle typeHandle, Type type);
    public virtual object InternalDeserialize(XmlReaderDelegator xmlReader, int declaredTypeID, RuntimeTypeHandle declaredTypeHandle, string name, string ns);
    internal virtual object InternalDeserialize(XmlReaderDelegator xmlReader, Type declaredType, string name, string ns);
    internal virtual object InternalDeserialize(XmlReaderDelegator xmlReader, Type declaredType, DataContract dataContract, string name, string ns);
    private object InternalDeserializeInSharedTypeMode(XmlReaderDelegator xmlReader, int declaredTypeID, Type declaredType, string name, string ns);
    private object InternalDeserializeWithSurrogate(XmlReaderDelegator xmlReader, Type declaredType, DataContract surrogateDataContract, string name, string ns);
    private Type ResolveDataContractTypeInSharedTypeMode(string assemblyName, string typeName, Assembly& assembly);
    private DataContract ResolveDataContractInSharedTypeMode(string assemblyName, string typeName, Assembly& assembly, Type& type);
    protected virtual DataContract ResolveDataContractFromTypeName();
    [SecuritySafeCriticalAttribute]
private bool CheckIfTypeSerializableForSharedTypeMode(Type memberType);
    internal virtual void CheckIfTypeSerializable(Type memberType, bool isMemberTypeSerializable);
    internal virtual Type GetSurrogatedType(Type type);
    internal virtual int GetArraySize();
    private static Assembly ResolveSimpleAssemblyName(AssemblyName assemblyName);
    private static Assembly ResolveSimpleAssemblyName(string assemblyName);
    [SecuritySafeCriticalAttribute]
private static void CheckTypeForwardedTo(Assembly sourceAssembly, Assembly destinationAssembly, Type resolvedType);
}
internal class System.Runtime.Serialization.XmlObjectSerializerWriteContext : XmlObjectSerializerContext {
    private ObjectReferenceStack byValObjectsInScope;
    private XmlSerializableWriter xmlSerializableWriter;
    private static int depthToCheckCyclicReference;
    protected bool preserveObjectReferences;
    private ObjectToIdCache serializedObjects;
    private bool isGetOnlyCollection;
    private bool unsafeTypeForwardingEnabled;
    protected bool serializeReadOnlyTypes;
    protected ObjectToIdCache SerializedObjects { get; }
    internal bool IsGetOnlyCollection { get; internal set; }
    internal bool SerializeReadOnlyTypes { get; }
    internal bool UnsafeTypeForwardingEnabled { get; }
    protected XmlObjectSerializerWriteContext(DataContractSerializer serializer, DataContract rootTypeDataContract, DataContractResolver resolver);
    protected XmlObjectSerializerWriteContext(NetDataContractSerializer serializer);
    internal XmlObjectSerializerWriteContext(XmlObjectSerializer serializer, int maxItemsInObjectGraph, StreamingContext streamingContext, bool ignoreExtensionDataObject);
    internal static XmlObjectSerializerWriteContext CreateContext(DataContractSerializer serializer, DataContract rootTypeDataContract, DataContractResolver dataContractResolver);
    internal static XmlObjectSerializerWriteContext CreateContext(NetDataContractSerializer serializer, Hashtable surrogateDataContracts);
    protected ObjectToIdCache get_SerializedObjects();
    internal virtual bool get_IsGetOnlyCollection();
    internal virtual void set_IsGetOnlyCollection(bool value);
    internal bool get_SerializeReadOnlyTypes();
    internal bool get_UnsafeTypeForwardingEnabled();
    internal void StoreIsGetOnlyCollection();
    public void InternalSerializeReference(XmlWriterDelegator xmlWriter, object obj, bool isDeclaredType, bool writeXsiType, int declaredTypeID, RuntimeTypeHandle declaredTypeHandle);
    public virtual void InternalSerialize(XmlWriterDelegator xmlWriter, object obj, bool isDeclaredType, bool writeXsiType, int declaredTypeID, RuntimeTypeHandle declaredTypeHandle);
    internal void SerializeWithoutXsiType(DataContract dataContract, XmlWriterDelegator xmlWriter, object obj, RuntimeTypeHandle declaredTypeHandle);
    internal virtual void SerializeWithXsiTypeAtTopLevel(DataContract dataContract, XmlWriterDelegator xmlWriter, object obj, RuntimeTypeHandle originalDeclaredTypeHandle, Type graphType);
    protected virtual void SerializeWithXsiType(XmlWriterDelegator xmlWriter, object obj, RuntimeTypeHandle objectTypeHandle, Type objectType, int declaredTypeID, RuntimeTypeHandle declaredTypeHandle, Type declaredType);
    internal bool OnHandleIsReference(XmlWriterDelegator xmlWriter, DataContract contract, object obj);
    protected void SerializeAndVerifyType(DataContract dataContract, XmlWriterDelegator xmlWriter, object obj, bool verifyKnownType, RuntimeTypeHandle declaredTypeHandle, Type declaredType);
    internal virtual bool WriteClrTypeInfo(XmlWriterDelegator xmlWriter, DataContract dataContract);
    internal virtual bool WriteClrTypeInfo(XmlWriterDelegator xmlWriter, Type dataContractType, string clrTypeName, string clrAssemblyName);
    internal virtual bool WriteClrTypeInfo(XmlWriterDelegator xmlWriter, Type dataContractType, SerializationInfo serInfo);
    public virtual void WriteAnyType(XmlWriterDelegator xmlWriter, object value);
    public virtual void WriteString(XmlWriterDelegator xmlWriter, string value);
    public virtual void WriteString(XmlWriterDelegator xmlWriter, string value, XmlDictionaryString name, XmlDictionaryString ns);
    public virtual void WriteBase64(XmlWriterDelegator xmlWriter, Byte[] value);
    public virtual void WriteBase64(XmlWriterDelegator xmlWriter, Byte[] value, XmlDictionaryString name, XmlDictionaryString ns);
    public virtual void WriteUri(XmlWriterDelegator xmlWriter, Uri value);
    public virtual void WriteUri(XmlWriterDelegator xmlWriter, Uri value, XmlDictionaryString name, XmlDictionaryString ns);
    public virtual void WriteQName(XmlWriterDelegator xmlWriter, XmlQualifiedName value);
    public virtual void WriteQName(XmlWriterDelegator xmlWriter, XmlQualifiedName value, XmlDictionaryString name, XmlDictionaryString ns);
    internal void HandleGraphAtTopLevel(XmlWriterDelegator writer, object obj, DataContract contract);
    internal virtual bool OnHandleReference(XmlWriterDelegator xmlWriter, object obj, bool canContainCyclicReference);
    internal virtual void OnEndHandleReference(XmlWriterDelegator xmlWriter, object obj, bool canContainCyclicReference);
    public void WriteNull(XmlWriterDelegator xmlWriter, Type memberType, bool isMemberTypeSerializable);
    internal void WriteNull(XmlWriterDelegator xmlWriter, Type memberType, bool isMemberTypeSerializable, XmlDictionaryString name, XmlDictionaryString ns);
    public void IncrementArrayCount(XmlWriterDelegator xmlWriter, Array array);
    public void IncrementCollectionCount(XmlWriterDelegator xmlWriter, ICollection collection);
    public void IncrementCollectionCountGeneric(XmlWriterDelegator xmlWriter, ICollection`1<T> collection);
    private void IncrementCollectionCount(XmlWriterDelegator xmlWriter, int size);
    internal virtual void WriteArraySize(XmlWriterDelegator xmlWriter, int size);
    public static T GetDefaultValue();
    public static T GetNullableValue(Nullable`1<T> value);
    public static void ThrowRequiredMemberMustBeEmitted(string memberName, Type type);
    public static bool GetHasValue(Nullable`1<T> value);
    internal void WriteIXmlSerializable(XmlWriterDelegator xmlWriter, object obj);
    internal static void WriteRootIXmlSerializable(XmlWriterDelegator xmlWriter, object obj);
    private static void WriteIXmlSerializable(XmlWriterDelegator xmlWriter, object obj, XmlSerializableWriter xmlSerializableWriter);
    [SecuritySafeCriticalAttribute]
internal void GetObjectData(ISerializable obj, SerializationInfo serInfo, StreamingContext context);
    public void WriteISerializable(XmlWriterDelegator xmlWriter, ISerializable obj);
    internal void WriteSerializationInfo(XmlWriterDelegator xmlWriter, Type objType, SerializationInfo serInfo);
    public void WriteExtensionData(XmlWriterDelegator xmlWriter, ExtensionDataObject extensionData, int memberIndex);
    private void WriteExtensionDataMember(XmlWriterDelegator xmlWriter, ExtensionDataMember member);
    internal virtual void WriteExtensionDataTypeInfo(XmlWriterDelegator xmlWriter, IDataNode dataNode);
    internal void WriteExtensionDataValue(XmlWriterDelegator xmlWriter, IDataNode dataNode);
    internal bool TryWriteDeserializedExtensionData(XmlWriterDelegator xmlWriter, IDataNode dataNode);
    private void WriteExtensionClassData(XmlWriterDelegator xmlWriter, ClassDataNode dataNode);
    private void WriteExtensionCollectionData(XmlWriterDelegator xmlWriter, CollectionDataNode dataNode);
    private void WriteExtensionISerializableData(XmlWriterDelegator xmlWriter, ISerializableDataNode dataNode);
    private void WriteExtensionXmlData(XmlWriterDelegator xmlWriter, XmlDataNode dataNode);
    protected virtual void WriteDataContractValue(DataContract dataContract, XmlWriterDelegator xmlWriter, object obj, RuntimeTypeHandle declaredTypeHandle);
    protected virtual void WriteNull(XmlWriterDelegator xmlWriter);
    private void WriteResolvedTypeInfo(XmlWriterDelegator writer, Type objectType, Type declaredType);
    private bool ResolveType(Type objectType, Type declaredType, XmlDictionaryString& typeName, XmlDictionaryString& typeNamespace);
    protected virtual bool WriteTypeInfo(XmlWriterDelegator writer, DataContract contract, DataContract declaredContract);
    protected virtual void WriteTypeInfo(XmlWriterDelegator writer, string dataContractName, string dataContractNamespace);
    protected virtual void WriteTypeInfo(XmlWriterDelegator writer, XmlDictionaryString dataContractName, XmlDictionaryString dataContractNamespace);
}
internal class System.Runtime.Serialization.XmlObjectSerializerWriteContextComplex : XmlObjectSerializerWriteContext {
    protected IDataContractSurrogate dataContractSurrogate;
    private SerializationMode mode;
    private SerializationBinder binder;
    private ISurrogateSelector surrogateSelector;
    private StreamingContext streamingContext;
    private Hashtable surrogateDataContracts;
    internal SerializationMode Mode { get; }
    internal XmlObjectSerializerWriteContextComplex(DataContractSerializer serializer, DataContract rootTypeDataContract, DataContractResolver dataContractResolver);
    internal XmlObjectSerializerWriteContextComplex(NetDataContractSerializer serializer, Hashtable surrogateDataContracts);
    internal XmlObjectSerializerWriteContextComplex(XmlObjectSerializer serializer, int maxItemsInObjectGraph, StreamingContext streamingContext, bool ignoreExtensionDataObject);
    internal virtual SerializationMode get_Mode();
    internal virtual DataContract GetDataContract(RuntimeTypeHandle typeHandle, Type type);
    internal virtual DataContract GetDataContract(int id, RuntimeTypeHandle typeHandle);
    internal virtual DataContract GetDataContractSkipValidation(int typeId, RuntimeTypeHandle typeHandle, Type type);
    internal virtual bool WriteClrTypeInfo(XmlWriterDelegator xmlWriter, DataContract dataContract);
    internal virtual bool WriteClrTypeInfo(XmlWriterDelegator xmlWriter, Type dataContractType, string clrTypeName, string clrAssemblyName);
    internal virtual bool WriteClrTypeInfo(XmlWriterDelegator xmlWriter, Type dataContractType, SerializationInfo serInfo);
    public virtual void WriteAnyType(XmlWriterDelegator xmlWriter, object value);
    public virtual void WriteString(XmlWriterDelegator xmlWriter, string value);
    public virtual void WriteString(XmlWriterDelegator xmlWriter, string value, XmlDictionaryString name, XmlDictionaryString ns);
    public virtual void WriteBase64(XmlWriterDelegator xmlWriter, Byte[] value);
    public virtual void WriteBase64(XmlWriterDelegator xmlWriter, Byte[] value, XmlDictionaryString name, XmlDictionaryString ns);
    public virtual void WriteUri(XmlWriterDelegator xmlWriter, Uri value);
    public virtual void WriteUri(XmlWriterDelegator xmlWriter, Uri value, XmlDictionaryString name, XmlDictionaryString ns);
    public virtual void WriteQName(XmlWriterDelegator xmlWriter, XmlQualifiedName value);
    public virtual void WriteQName(XmlWriterDelegator xmlWriter, XmlQualifiedName value, XmlDictionaryString name, XmlDictionaryString ns);
    public virtual void InternalSerialize(XmlWriterDelegator xmlWriter, object obj, bool isDeclaredType, bool writeXsiType, int declaredTypeID, RuntimeTypeHandle declaredTypeHandle);
    internal virtual bool OnHandleReference(XmlWriterDelegator xmlWriter, object obj, bool canContainCyclicReference);
    internal virtual void OnEndHandleReference(XmlWriterDelegator xmlWriter, object obj, bool canContainCyclicReference);
    [SecuritySafeCriticalAttribute]
private bool CheckIfTypeSerializableForSharedTypeMode(Type memberType);
    internal virtual void CheckIfTypeSerializable(Type memberType, bool isMemberTypeSerializable);
    internal virtual Type GetSurrogatedType(Type type);
    private void InternalSerializeWithSurrogate(XmlWriterDelegator xmlWriter, object obj, bool isDeclaredType, bool writeXsiType, int declaredTypeID, RuntimeTypeHandle declaredTypeHandle);
    internal virtual void WriteArraySize(XmlWriterDelegator xmlWriter, int size);
}
internal class System.Runtime.Serialization.XmlReaderDelegator : object {
    protected XmlReader reader;
    protected XmlDictionaryReader dictionaryReader;
    protected bool isEndOfEmptyElement;
    internal XmlReader UnderlyingReader { get; }
    internal ExtensionDataReader UnderlyingExtensionDataReader { get; }
    internal int AttributeCount { get; }
    internal bool IsEmptyElement { get; }
    public XmlNodeType NodeType { get; }
    internal int LineNumber { get; }
    internal int LinePosition { get; }
    internal bool Normalized { get; internal set; }
    internal WhitespaceHandling WhitespaceHandling { get; internal set; }
    internal string Name { get; }
    public string LocalName { get; }
    internal string NamespaceURI { get; }
    internal string Value { get; }
    internal Type ValueType { get; }
    internal int Depth { get; }
    internal bool EOF { get; }
    public XmlReaderDelegator(XmlReader reader);
    internal XmlReader get_UnderlyingReader();
    internal ExtensionDataReader get_UnderlyingExtensionDataReader();
    internal int get_AttributeCount();
    internal string GetAttribute(string name);
    internal string GetAttribute(string name, string namespaceUri);
    internal string GetAttribute(int i);
    internal bool get_IsEmptyElement();
    internal bool IsNamespaceURI(string ns);
    internal bool IsLocalName(string localName);
    internal bool IsNamespaceUri(XmlDictionaryString ns);
    internal bool IsLocalName(XmlDictionaryString localName);
    internal int IndexOfLocalName(XmlDictionaryString[] localNames, XmlDictionaryString ns);
    public bool IsStartElement();
    internal bool IsStartElement(string localname, string ns);
    public bool IsStartElement(XmlDictionaryString localname, XmlDictionaryString ns);
    internal bool MoveToAttribute(string name);
    internal bool MoveToAttribute(string name, string ns);
    internal void MoveToAttribute(int i);
    internal bool MoveToElement();
    internal bool MoveToFirstAttribute();
    internal bool MoveToNextAttribute();
    public XmlNodeType get_NodeType();
    internal bool Read();
    internal XmlNodeType MoveToContent();
    internal bool ReadAttributeValue();
    public void ReadEndElement();
    private Exception CreateInvalidPrimitiveTypeException(Type type);
    public object ReadElementContentAsAnyType(Type valueType);
    internal object ReadContentAsAnyType(Type valueType);
    internal IDataNode ReadExtensionData(Type valueType);
    private void ThrowConversionException(string value, string type);
    private void ThrowNotAtElement();
    internal virtual char ReadElementContentAsChar();
    internal virtual char ReadContentAsChar();
    private char ToChar(int value);
    public string ReadElementContentAsString();
    internal string ReadContentAsString();
    public bool ReadElementContentAsBoolean();
    internal bool ReadContentAsBoolean();
    public float ReadElementContentAsFloat();
    internal float ReadContentAsSingle();
    public double ReadElementContentAsDouble();
    internal double ReadContentAsDouble();
    public decimal ReadElementContentAsDecimal();
    internal decimal ReadContentAsDecimal();
    internal virtual Byte[] ReadElementContentAsBase64();
    internal virtual Byte[] ReadContentAsBase64();
    internal Byte[] ReadContentAsBase64(string str);
    internal virtual DateTime ReadElementContentAsDateTime();
    internal virtual DateTime ReadContentAsDateTime();
    public int ReadElementContentAsInt();
    internal int ReadContentAsInt();
    public long ReadElementContentAsLong();
    internal long ReadContentAsLong();
    public short ReadElementContentAsShort();
    internal short ReadContentAsShort();
    private short ToShort(int value);
    public byte ReadElementContentAsUnsignedByte();
    internal byte ReadContentAsUnsignedByte();
    private byte ToByte(int value);
    public sbyte ReadElementContentAsSignedByte();
    internal sbyte ReadContentAsSignedByte();
    private sbyte ToSByte(int value);
    public UInt32 ReadElementContentAsUnsignedInt();
    internal UInt32 ReadContentAsUnsignedInt();
    private UInt32 ToUInt32(long value);
    internal virtual ulong ReadElementContentAsUnsignedLong();
    internal virtual ulong ReadContentAsUnsignedLong();
    public ushort ReadElementContentAsUnsignedShort();
    internal ushort ReadContentAsUnsignedShort();
    private ushort ToUInt16(int value);
    public TimeSpan ReadElementContentAsTimeSpan();
    internal TimeSpan ReadContentAsTimeSpan();
    public Guid ReadElementContentAsGuid();
    internal Guid ReadContentAsGuid();
    public Uri ReadElementContentAsUri();
    internal Uri ReadContentAsUri();
    public XmlQualifiedName ReadElementContentAsQName();
    internal virtual XmlQualifiedName ReadContentAsQName();
    private XmlQualifiedName ParseQualifiedName(string str);
    private void CheckExpectedArrayLength(XmlObjectSerializerReadContext context, int arrayLength);
    protected int GetArrayLengthQuota(XmlObjectSerializerReadContext context);
    private void CheckActualArrayLength(int expectedLength, int actualLength, XmlDictionaryString itemName, XmlDictionaryString itemNamespace);
    internal bool TryReadBooleanArray(XmlObjectSerializerReadContext context, XmlDictionaryString itemName, XmlDictionaryString itemNamespace, int arrayLength, Boolean[]& array);
    internal bool TryReadDateTimeArray(XmlObjectSerializerReadContext context, XmlDictionaryString itemName, XmlDictionaryString itemNamespace, int arrayLength, DateTime[]& array);
    internal bool TryReadDecimalArray(XmlObjectSerializerReadContext context, XmlDictionaryString itemName, XmlDictionaryString itemNamespace, int arrayLength, Decimal[]& array);
    internal bool TryReadInt32Array(XmlObjectSerializerReadContext context, XmlDictionaryString itemName, XmlDictionaryString itemNamespace, int arrayLength, Int32[]& array);
    internal bool TryReadInt64Array(XmlObjectSerializerReadContext context, XmlDictionaryString itemName, XmlDictionaryString itemNamespace, int arrayLength, Int64[]& array);
    internal bool TryReadSingleArray(XmlObjectSerializerReadContext context, XmlDictionaryString itemName, XmlDictionaryString itemNamespace, int arrayLength, Single[]& array);
    internal bool TryReadDoubleArray(XmlObjectSerializerReadContext context, XmlDictionaryString itemName, XmlDictionaryString itemNamespace, int arrayLength, Double[]& array);
    internal IDictionary`2<string, string> GetNamespacesInScope(XmlNamespaceScope scope);
    internal bool HasLineInfo();
    internal int get_LineNumber();
    internal int get_LinePosition();
    internal bool get_Normalized();
    internal void set_Normalized(bool value);
    internal WhitespaceHandling get_WhitespaceHandling();
    internal void set_WhitespaceHandling(WhitespaceHandling value);
    internal string get_Name();
    public string get_LocalName();
    internal string get_NamespaceURI();
    internal string get_Value();
    internal Type get_ValueType();
    internal int get_Depth();
    internal string LookupNamespace(string prefix);
    internal bool get_EOF();
    internal void Skip();
}
[DefaultMemberAttribute("Item")]
internal class System.Runtime.Serialization.XmlSerializableReader : XmlReader {
    private XmlReaderDelegator xmlReader;
    private int startDepth;
    private bool isRootEmptyElement;
    private XmlReader innerReader;
    private XmlReader InnerReader { get; }
    public XmlReaderSettings Settings { get; }
    public XmlNodeType NodeType { get; }
    public string Name { get; }
    public string LocalName { get; }
    public string NamespaceURI { get; }
    public string Prefix { get; }
    public bool HasValue { get; }
    public string Value { get; }
    public int Depth { get; }
    public string BaseURI { get; }
    public bool IsEmptyElement { get; }
    public bool IsDefault { get; }
    public char QuoteChar { get; }
    public XmlSpace XmlSpace { get; }
    public string XmlLang { get; }
    public IXmlSchemaInfo SchemaInfo { get; }
    public Type ValueType { get; }
    public int AttributeCount { get; }
    public string Item { get; }
    public string Item { get; }
    public string Item { get; }
    public bool EOF { get; }
    public ReadState ReadState { get; }
    public XmlNameTable NameTable { get; }
    public bool CanResolveEntity { get; }
    public bool CanReadBinaryContent { get; }
    public bool CanReadValueChunk { get; }
    public bool HasAttributes { get; }
    private bool System.Xml.Serialization.IXmlTextParser.Normalized { get; private set; }
    private WhitespaceHandling System.Xml.Serialization.IXmlTextParser.WhitespaceHandling { get; private set; }
    private int System.Xml.IXmlLineInfo.LineNumber { get; }
    private int System.Xml.IXmlLineInfo.LinePosition { get; }
    private XmlReader get_InnerReader();
    internal void BeginRead(XmlReaderDelegator xmlReader);
    internal void EndRead();
    public virtual bool Read();
    public virtual void Close();
    public virtual XmlReaderSettings get_Settings();
    public virtual XmlNodeType get_NodeType();
    public virtual string get_Name();
    public virtual string get_LocalName();
    public virtual string get_NamespaceURI();
    public virtual string get_Prefix();
    public virtual bool get_HasValue();
    public virtual string get_Value();
    public virtual int get_Depth();
    public virtual string get_BaseURI();
    public virtual bool get_IsEmptyElement();
    public virtual bool get_IsDefault();
    public virtual char get_QuoteChar();
    public virtual XmlSpace get_XmlSpace();
    public virtual string get_XmlLang();
    public virtual IXmlSchemaInfo get_SchemaInfo();
    public virtual Type get_ValueType();
    public virtual int get_AttributeCount();
    public virtual string get_Item(int i);
    public virtual string get_Item(string name);
    public virtual string get_Item(string name, string namespaceURI);
    public virtual bool get_EOF();
    public virtual ReadState get_ReadState();
    public virtual XmlNameTable get_NameTable();
    public virtual bool get_CanResolveEntity();
    public virtual bool get_CanReadBinaryContent();
    public virtual bool get_CanReadValueChunk();
    public virtual bool get_HasAttributes();
    public virtual string GetAttribute(string name);
    public virtual string GetAttribute(string name, string namespaceURI);
    public virtual string GetAttribute(int i);
    public virtual bool MoveToAttribute(string name);
    public virtual bool MoveToAttribute(string name, string ns);
    public virtual void MoveToAttribute(int i);
    public virtual bool MoveToFirstAttribute();
    public virtual bool MoveToNextAttribute();
    public virtual bool MoveToElement();
    public virtual string LookupNamespace(string prefix);
    public virtual bool ReadAttributeValue();
    public virtual void ResolveEntity();
    public virtual bool IsStartElement();
    public virtual bool IsStartElement(string name);
    public virtual bool IsStartElement(string localname, string ns);
    public virtual XmlNodeType MoveToContent();
    public virtual object ReadContentAsObject();
    public virtual bool ReadContentAsBoolean();
    public virtual DateTime ReadContentAsDateTime();
    public virtual double ReadContentAsDouble();
    public virtual int ReadContentAsInt();
    public virtual long ReadContentAsLong();
    public virtual string ReadContentAsString();
    public virtual object ReadContentAs(Type returnType, IXmlNamespaceResolver namespaceResolver);
    public virtual int ReadContentAsBase64(Byte[] buffer, int index, int count);
    public virtual int ReadContentAsBinHex(Byte[] buffer, int index, int count);
    public virtual int ReadValueChunk(Char[] buffer, int index, int count);
    public virtual string ReadString();
    private sealed virtual override bool System.Xml.Serialization.IXmlTextParser.get_Normalized();
    private sealed virtual override void System.Xml.Serialization.IXmlTextParser.set_Normalized(bool value);
    private sealed virtual override WhitespaceHandling System.Xml.Serialization.IXmlTextParser.get_WhitespaceHandling();
    private sealed virtual override void System.Xml.Serialization.IXmlTextParser.set_WhitespaceHandling(WhitespaceHandling value);
    private sealed virtual override bool System.Xml.IXmlLineInfo.HasLineInfo();
    private sealed virtual override int System.Xml.IXmlLineInfo.get_LineNumber();
    private sealed virtual override int System.Xml.IXmlLineInfo.get_LinePosition();
}
public static class System.Runtime.Serialization.XmlSerializableServices : object {
    internal static string ReadNodesMethodName;
    internal static string WriteNodesMethodName;
    internal static string AddDefaultSchemaMethodName;
    private static XmlSerializableServices();
    public static XmlNode[] ReadNodes(XmlReader xmlReader);
    private static bool IsValidAttribute(XmlReader xmlReader);
    public static void WriteNodes(XmlWriter xmlWriter, XmlNode[] nodes);
    public static void AddDefaultSchema(XmlSchemaSet schemas, XmlQualifiedName typeQName);
}
internal class System.Runtime.Serialization.XmlSerializableWriter : XmlWriter {
    private XmlWriter xmlWriter;
    private int depth;
    private object obj;
    public WriteState WriteState { get; }
    public XmlSpace XmlSpace { get; }
    public string XmlLang { get; }
    internal void BeginWrite(XmlWriter xmlWriter, object obj);
    internal void EndWrite();
    public virtual void WriteStartDocument();
    public virtual void WriteEndDocument();
    public virtual void WriteStartDocument(bool standalone);
    public virtual void WriteDocType(string name, string pubid, string sysid, string subset);
    public virtual void WriteStartElement(string prefix, string localName, string ns);
    public virtual void WriteEndElement();
    public virtual void WriteFullEndElement();
    public virtual void Close();
    public virtual void WriteStartAttribute(string prefix, string localName, string ns);
    public virtual void WriteEndAttribute();
    public virtual void WriteCData(string text);
    public virtual void WriteComment(string text);
    public virtual void WriteProcessingInstruction(string name, string text);
    public virtual void WriteEntityRef(string name);
    public virtual void WriteCharEntity(char ch);
    public virtual void WriteWhitespace(string ws);
    public virtual void WriteString(string text);
    public virtual void WriteSurrogateCharEntity(char lowChar, char highChar);
    public virtual void WriteChars(Char[] buffer, int index, int count);
    public virtual void WriteRaw(Char[] buffer, int index, int count);
    public virtual void WriteRaw(string data);
    public virtual void WriteBase64(Byte[] buffer, int index, int count);
    public virtual void WriteBinHex(Byte[] buffer, int index, int count);
    public virtual WriteState get_WriteState();
    public virtual void Flush();
    public virtual void WriteName(string name);
    public virtual void WriteQualifiedName(string localName, string ns);
    public virtual string LookupPrefix(string ns);
    public virtual XmlSpace get_XmlSpace();
    public virtual string get_XmlLang();
    public virtual void WriteNmToken(string name);
}
internal class System.Runtime.Serialization.XmlWriterDelegator : object {
    protected XmlWriter writer;
    protected XmlDictionaryWriter dictionaryWriter;
    internal int depth;
    private int prefixes;
    private static int CharChunkSize;
    private static int ByteChunkSize;
    internal XmlWriter Writer { get; }
    internal WriteState WriteState { get; }
    internal string XmlLang { get; }
    internal XmlSpace XmlSpace { get; }
    public XmlWriterDelegator(XmlWriter writer);
    internal XmlWriter get_Writer();
    internal void Flush();
    internal string LookupPrefix(string ns);
    private void WriteEndAttribute();
    public void WriteEndElement();
    internal void WriteRaw(Char[] buffer, int index, int count);
    internal void WriteRaw(string data);
    internal void WriteXmlnsAttribute(XmlDictionaryString ns);
    internal void WriteXmlnsAttribute(string ns);
    internal void WriteXmlnsAttribute(string prefix, XmlDictionaryString ns);
    private void WriteStartAttribute(string prefix, string localName, string ns);
    private void WriteStartAttribute(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    internal void WriteAttributeString(string prefix, string localName, string ns, string value);
    internal void WriteAttributeString(string prefix, XmlDictionaryString attrName, XmlDictionaryString attrNs, string value);
    private void WriteAttributeStringValue(string value);
    internal void WriteAttributeString(string prefix, XmlDictionaryString attrName, XmlDictionaryString attrNs, XmlDictionaryString value);
    private void WriteAttributeStringValue(XmlDictionaryString value);
    internal void WriteAttributeInt(string prefix, XmlDictionaryString attrName, XmlDictionaryString attrNs, int value);
    private void WriteAttributeIntValue(int value);
    internal void WriteAttributeBool(string prefix, XmlDictionaryString attrName, XmlDictionaryString attrNs, bool value);
    private void WriteAttributeBoolValue(bool value);
    internal void WriteAttributeQualifiedName(string attrPrefix, XmlDictionaryString attrName, XmlDictionaryString attrNs, string name, string ns);
    private void WriteAttributeQualifiedNameValue(string name, string ns);
    internal void WriteAttributeQualifiedName(string attrPrefix, XmlDictionaryString attrName, XmlDictionaryString attrNs, XmlDictionaryString name, XmlDictionaryString ns);
    private void WriteAttributeQualifiedNameValue(XmlDictionaryString name, XmlDictionaryString ns);
    internal void WriteStartElement(string localName, string ns);
    internal virtual void WriteStartElement(string prefix, string localName, string ns);
    public void WriteStartElement(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    internal void WriteStartElement(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    internal void WriteStartElementPrimitive(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    internal void WriteEndElementPrimitive();
    internal WriteState get_WriteState();
    internal string get_XmlLang();
    internal XmlSpace get_XmlSpace();
    public void WriteNamespaceDecl(XmlDictionaryString ns);
    private Exception CreateInvalidPrimitiveTypeException(Type type);
    internal void WriteAnyType(object value);
    internal void WriteAnyType(object value, Type valueType);
    internal void WriteExtensionData(IDataNode dataNode);
    internal void WriteString(string value);
    internal virtual void WriteBoolean(bool value);
    public void WriteBoolean(bool value, XmlDictionaryString name, XmlDictionaryString ns);
    internal virtual void WriteDateTime(DateTime value);
    public void WriteDateTime(DateTime value, XmlDictionaryString name, XmlDictionaryString ns);
    internal virtual void WriteDecimal(decimal value);
    public void WriteDecimal(decimal value, XmlDictionaryString name, XmlDictionaryString ns);
    internal virtual void WriteDouble(double value);
    public void WriteDouble(double value, XmlDictionaryString name, XmlDictionaryString ns);
    internal virtual void WriteInt(int value);
    public void WriteInt(int value, XmlDictionaryString name, XmlDictionaryString ns);
    internal virtual void WriteLong(long value);
    public void WriteLong(long value, XmlDictionaryString name, XmlDictionaryString ns);
    internal virtual void WriteFloat(float value);
    public void WriteFloat(float value, XmlDictionaryString name, XmlDictionaryString ns);
    internal virtual void WriteBase64(Byte[] bytes);
    internal virtual void WriteShort(short value);
    public void WriteShort(short value, XmlDictionaryString name, XmlDictionaryString ns);
    internal virtual void WriteUnsignedByte(byte value);
    public void WriteUnsignedByte(byte value, XmlDictionaryString name, XmlDictionaryString ns);
    internal virtual void WriteSignedByte(sbyte value);
    public void WriteSignedByte(sbyte value, XmlDictionaryString name, XmlDictionaryString ns);
    internal virtual void WriteUnsignedInt(UInt32 value);
    public void WriteUnsignedInt(UInt32 value, XmlDictionaryString name, XmlDictionaryString ns);
    internal virtual void WriteUnsignedLong(ulong value);
    public void WriteUnsignedLong(ulong value, XmlDictionaryString name, XmlDictionaryString ns);
    internal virtual void WriteUnsignedShort(ushort value);
    public void WriteUnsignedShort(ushort value, XmlDictionaryString name, XmlDictionaryString ns);
    internal virtual void WriteChar(char value);
    public void WriteChar(char value, XmlDictionaryString name, XmlDictionaryString ns);
    internal void WriteTimeSpan(TimeSpan value);
    public void WriteTimeSpan(TimeSpan value, XmlDictionaryString name, XmlDictionaryString ns);
    internal void WriteGuid(Guid value);
    public void WriteGuid(Guid value, XmlDictionaryString name, XmlDictionaryString ns);
    internal void WriteUri(Uri value);
    internal virtual void WriteQName(XmlQualifiedName value);
    internal void WriteQualifiedName(string localName, string ns);
    internal void WriteQualifiedName(XmlDictionaryString localName, XmlDictionaryString ns);
    public void WriteBooleanArray(Boolean[] value, XmlDictionaryString itemName, XmlDictionaryString itemNamespace);
    public void WriteDateTimeArray(DateTime[] value, XmlDictionaryString itemName, XmlDictionaryString itemNamespace);
    public void WriteDecimalArray(Decimal[] value, XmlDictionaryString itemName, XmlDictionaryString itemNamespace);
    public void WriteInt32Array(Int32[] value, XmlDictionaryString itemName, XmlDictionaryString itemNamespace);
    public void WriteInt64Array(Int64[] value, XmlDictionaryString itemName, XmlDictionaryString itemNamespace);
    public void WriteSingleArray(Single[] value, XmlDictionaryString itemName, XmlDictionaryString itemNamespace);
    public void WriteDoubleArray(Double[] value, XmlDictionaryString itemName, XmlDictionaryString itemNamespace);
}
public static class System.Runtime.Serialization.XPathQueryGenerator : object {
    private static string XPathSeparator;
    private static string NsSeparator;
    public static string CreateFromDataContractSerializer(Type type, MemberInfo[] pathToMember, XmlNamespaceManager& namespaces);
    public static string CreateFromDataContractSerializer(Type type, MemberInfo[] pathToMember, StringBuilder rootElementXpath, XmlNamespaceManager& namespaces);
    private static DataContract ProcessDataContract(DataContract contract, ExportContext context, MemberInfo memberNode);
    private static DataContract ProcessClassDataContract(ClassDataContract contract, ExportContext context, MemberInfo memberNode);
    [IteratorStateMachineAttribute("System.Runtime.Serialization.XPathQueryGenerator/<GetDataMembers>d__6")]
private static IEnumerable`1<DataMember> GetDataMembers(ClassDataContract contract);
}
public class System.Runtime.Serialization.XsdDataContractExporter : object {
    private ExportOptions options;
    private XmlSchemaSet schemas;
    private DataContractSet dataContractSet;
    public ExportOptions Options { get; public set; }
    public XmlSchemaSet Schemas { get; }
    private DataContractSet DataContractSet { get; }
    public XsdDataContractExporter(XmlSchemaSet schemas);
    public ExportOptions get_Options();
    public void set_Options(ExportOptions value);
    public XmlSchemaSet get_Schemas();
    private XmlSchemaSet GetSchemaSet();
    private DataContractSet get_DataContractSet();
    private void TraceExportBegin();
    private void TraceExportEnd();
    private void TraceExportError(Exception exception);
    public void Export(ICollection`1<Assembly> assemblies);
    public void Export(ICollection`1<Type> types);
    public void Export(Type type);
    public XmlQualifiedName GetSchemaTypeName(Type type);
    public XmlSchemaType GetSchemaType(Type type);
    public XmlQualifiedName GetRootElementName(Type type);
    private Type GetSurrogatedType(Type type);
    private void CheckAndAddType(Type type);
    private void AddType(Type type);
    private void Export();
    private void AddKnownTypes();
    public bool CanExport(ICollection`1<Assembly> assemblies);
    public bool CanExport(ICollection`1<Type> types);
    public bool CanExport(Type type);
}
public class System.Runtime.Serialization.XsdDataContractImporter : object {
    private ImportOptions options;
    private CodeCompileUnit codeCompileUnit;
    private DataContractSet dataContractSet;
    private static XmlQualifiedName[] emptyTypeNameArray;
    private static XmlSchemaElement[] emptyElementArray;
    private XmlQualifiedName[] singleTypeNameArray;
    private XmlSchemaElement[] singleElementArray;
    public ImportOptions Options { get; public set; }
    public CodeCompileUnit CodeCompileUnit { get; }
    private DataContractSet DataContractSet { get; }
    private XmlQualifiedName[] SingleTypeNameArray { get; }
    private XmlSchemaElement[] SingleElementArray { get; }
    private bool ImportXmlDataType { get; }
    public XsdDataContractImporter(CodeCompileUnit codeCompileUnit);
    private static XsdDataContractImporter();
    public ImportOptions get_Options();
    public void set_Options(ImportOptions value);
    public CodeCompileUnit get_CodeCompileUnit();
    private CodeCompileUnit GetCodeCompileUnit();
    private DataContractSet get_DataContractSet();
    public void Import(XmlSchemaSet schemas);
    public void Import(XmlSchemaSet schemas, ICollection`1<XmlQualifiedName> typeNames);
    public void Import(XmlSchemaSet schemas, XmlQualifiedName typeName);
    public XmlQualifiedName Import(XmlSchemaSet schemas, XmlSchemaElement element);
    public bool CanImport(XmlSchemaSet schemas);
    public bool CanImport(XmlSchemaSet schemas, ICollection`1<XmlQualifiedName> typeNames);
    public bool CanImport(XmlSchemaSet schemas, XmlQualifiedName typeName);
    public bool CanImport(XmlSchemaSet schemas, XmlSchemaElement element);
    public CodeTypeReference GetCodeTypeReference(XmlQualifiedName typeName);
    public CodeTypeReference GetCodeTypeReference(XmlQualifiedName typeName, XmlSchemaElement element);
    internal DataContract FindDataContract(XmlQualifiedName typeName);
    public ICollection`1<CodeTypeReference> GetKnownTypeReferences(XmlQualifiedName typeName);
    private XmlQualifiedName[] get_SingleTypeNameArray();
    private XmlSchemaElement[] get_SingleElementArray();
    [SecuritySafeCriticalAttribute]
private void InternalImport(XmlSchemaSet schemas, ICollection`1<XmlQualifiedName> typeNames, ICollection`1<XmlSchemaElement> elements, XmlQualifiedName[] elementTypeNames);
    private bool get_ImportXmlDataType();
    private void TraceImportError(Exception exception);
    private bool InternalCanImport(XmlSchemaSet schemas, ICollection`1<XmlQualifiedName> typeNames, ICollection`1<XmlSchemaElement> elements, XmlQualifiedName[] elementTypeNames);
}
internal class System.Runtime.Serialization.XsDurationDataContract : TimeSpanDataContract {
}
internal class System.Text.Base64Encoding : Encoding {
    private static Byte[] char2val;
    private static string val2char;
    private static Byte[] val2byte;
    private static Base64Encoding();
    public virtual int GetMaxByteCount(int charCount);
    private bool IsValidLeadBytes(int v1, int v2, int v3, int v4);
    private bool IsValidTailBytes(int v3, int v4);
    [SecuritySafeCriticalAttribute]
public virtual int GetByteCount(Char[] chars, int index, int count);
    [SecuritySafeCriticalAttribute]
public virtual int GetBytes(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    [SecuritySafeCriticalAttribute]
public virtual int GetBytes(Byte[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    public virtual int GetMaxCharCount(int byteCount);
    public virtual int GetCharCount(Byte[] bytes, int index, int count);
    [SecuritySafeCriticalAttribute]
public virtual int GetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex);
    [SecuritySafeCriticalAttribute]
public int GetChars(Byte[] bytes, int byteIndex, int byteCount, Byte[] chars, int charIndex);
}
internal class System.Text.BinHexEncoding : Encoding {
    private static Byte[] char2val;
    private static string val2char;
    private static BinHexEncoding();
    public virtual int GetMaxByteCount(int charCount);
    public virtual int GetByteCount(Char[] chars, int index, int count);
    [SecuritySafeCriticalAttribute]
public virtual int GetBytes(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    public virtual int GetMaxCharCount(int byteCount);
    public virtual int GetCharCount(Byte[] bytes, int index, int count);
    [SecuritySafeCriticalAttribute]
public virtual int GetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex);
}
internal class System.Text.SurrogateChar : ValueType {
    private char lowChar;
    private char highChar;
    public static int MinValue;
    public static int MaxValue;
    private static char surHighMin;
    private static char surHighMax;
    private static char surLowMin;
    private static char surLowMax;
    public char LowChar { get; }
    public char HighChar { get; }
    public int Char { get; }
    public SurrogateChar(int ch);
    public SurrogateChar(char lowChar, char highChar);
    public char get_LowChar();
    public char get_HighChar();
    public int get_Char();
}
internal abstract class System.Xml.ArrayHelper`2 : object {
    public TArray[] ReadArray(XmlDictionaryReader reader, TArgument localName, TArgument namespaceUri, int maxArrayLength);
    public void WriteArray(XmlDictionaryWriter writer, string prefix, TArgument localName, TArgument namespaceUri, XmlDictionaryReader reader);
    protected abstract virtual int ReadArray(XmlDictionaryReader reader, TArgument localName, TArgument namespaceUri, TArray[] array, int offset, int count);
    protected abstract virtual void WriteArray(XmlDictionaryWriter writer, string prefix, TArgument localName, TArgument namespaceUri, TArray[] array, int offset, int count);
}
internal class System.Xml.BooleanArrayHelperWithDictionaryString : ArrayHelper`2<XmlDictionaryString, bool> {
    public static BooleanArrayHelperWithDictionaryString Instance;
    private static BooleanArrayHelperWithDictionaryString();
    protected virtual int ReadArray(XmlDictionaryReader reader, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Boolean[] array, int offset, int count);
    protected virtual void WriteArray(XmlDictionaryWriter writer, string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Boolean[] array, int offset, int count);
}
internal class System.Xml.BooleanArrayHelperWithString : ArrayHelper`2<string, bool> {
    public static BooleanArrayHelperWithString Instance;
    private static BooleanArrayHelperWithString();
    protected virtual int ReadArray(XmlDictionaryReader reader, string localName, string namespaceUri, Boolean[] array, int offset, int count);
    protected virtual void WriteArray(XmlDictionaryWriter writer, string prefix, string localName, string namespaceUri, Boolean[] array, int offset, int count);
}
internal class System.Xml.BufferedReadStream : Stream {
    private Stream stream;
    private Byte[] storedBuffer;
    private int storedLength;
    private int storedOffset;
    private bool readMore;
    public bool CanWrite { get; }
    public bool CanSeek { get; }
    public bool CanRead { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public BufferedReadStream(Stream stream);
    public BufferedReadStream(Stream stream, bool readMore);
    public virtual bool get_CanWrite();
    public virtual bool get_CanSeek();
    public virtual bool get_CanRead();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual void Close();
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual void EndWrite(IAsyncResult asyncResult);
    public virtual void Flush();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int ReadByte();
    public int ReadBlock(Byte[] buffer, int offset, int count);
    public void Push(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
}
internal class System.Xml.BufferedWrite : object {
    private Byte[] buffer;
    private int offset;
    internal int Length { get; }
    internal BufferedWrite(int initialSize);
    private void EnsureBuffer(int count);
    internal int get_Length();
    internal Byte[] GetBuffer();
    internal void Reset();
    internal void Write(Byte[] value);
    internal void Write(Byte[] value, int index, int count);
    internal void Write(string value);
    internal void Write(string value, int index, int count);
}
internal class System.Xml.ContentIDHeader : MimeHeader {
    public ContentIDHeader(string name, string value);
}
internal enum System.Xml.ContentTransferEncoding : Enum {
    public int value__;
    public static ContentTransferEncoding SevenBit;
    public static ContentTransferEncoding EightBit;
    public static ContentTransferEncoding Binary;
    public static ContentTransferEncoding Other;
    public static ContentTransferEncoding Unspecified;
}
internal class System.Xml.ContentTransferEncodingHeader : MimeHeader {
    private ContentTransferEncoding contentTransferEncoding;
    private string contentTransferEncodingValue;
    public static ContentTransferEncodingHeader Binary;
    public static ContentTransferEncodingHeader EightBit;
    public static ContentTransferEncodingHeader SevenBit;
    public ContentTransferEncoding ContentTransferEncoding { get; }
    public string ContentTransferEncodingValue { get; }
    public ContentTransferEncodingHeader(string value);
    public ContentTransferEncodingHeader(ContentTransferEncoding contentTransferEncoding, string value);
    private static ContentTransferEncodingHeader();
    public ContentTransferEncoding get_ContentTransferEncoding();
    public string get_ContentTransferEncodingValue();
    private void ParseValue();
}
internal class System.Xml.ContentTypeHeader : MimeHeader {
    public static ContentTypeHeader Default;
    private string mediaType;
    private string subType;
    private Dictionary`2<string, string> parameters;
    public string MediaType { get; }
    public string MediaSubtype { get; }
    public Dictionary`2<string, string> Parameters { get; }
    public ContentTypeHeader(string value);
    private static ContentTypeHeader();
    public string get_MediaType();
    public string get_MediaSubtype();
    public Dictionary`2<string, string> get_Parameters();
    private void ParseValue();
}
internal class System.Xml.DateTimeArrayHelperWithDictionaryString : ArrayHelper`2<XmlDictionaryString, DateTime> {
    public static DateTimeArrayHelperWithDictionaryString Instance;
    private static DateTimeArrayHelperWithDictionaryString();
    protected virtual int ReadArray(XmlDictionaryReader reader, XmlDictionaryString localName, XmlDictionaryString namespaceUri, DateTime[] array, int offset, int count);
    protected virtual void WriteArray(XmlDictionaryWriter writer, string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, DateTime[] array, int offset, int count);
}
internal class System.Xml.DateTimeArrayHelperWithString : ArrayHelper`2<string, DateTime> {
    public static DateTimeArrayHelperWithString Instance;
    private static DateTimeArrayHelperWithString();
    protected virtual int ReadArray(XmlDictionaryReader reader, string localName, string namespaceUri, DateTime[] array, int offset, int count);
    protected virtual void WriteArray(XmlDictionaryWriter writer, string prefix, string localName, string namespaceUri, DateTime[] array, int offset, int count);
}
internal class System.Xml.DecimalArrayHelperWithDictionaryString : ArrayHelper`2<XmlDictionaryString, decimal> {
    public static DecimalArrayHelperWithDictionaryString Instance;
    private static DecimalArrayHelperWithDictionaryString();
    protected virtual int ReadArray(XmlDictionaryReader reader, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Decimal[] array, int offset, int count);
    protected virtual void WriteArray(XmlDictionaryWriter writer, string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Decimal[] array, int offset, int count);
}
internal class System.Xml.DecimalArrayHelperWithString : ArrayHelper`2<string, decimal> {
    public static DecimalArrayHelperWithString Instance;
    private static DecimalArrayHelperWithString();
    protected virtual int ReadArray(XmlDictionaryReader reader, string localName, string namespaceUri, Decimal[] array, int offset, int count);
    protected virtual void WriteArray(XmlDictionaryWriter writer, string prefix, string localName, string namespaceUri, Decimal[] array, int offset, int count);
}
internal class System.Xml.DelimittedStreamReader : object {
    private bool canGetNextStream;
    private DelimittedReadStream currentStream;
    private Byte[] delimitter;
    private Byte[] matchBuffer;
    private Byte[] scratch;
    private BufferedReadStream stream;
    public DelimittedStreamReader(Stream stream);
    public void Close();
    private void Close(DelimittedReadStream caller);
    public Stream GetNextStream(Byte[] delimitter);
    private MatchState MatchDelimitter(Byte[] buffer, int start, int end);
    private int ProcessRead(Byte[] buffer, int offset, int read);
    private int Read(DelimittedReadStream caller, Byte[] buffer, int offset, int count);
    private bool MatchRemainder(int start, int count);
    internal void Push(Byte[] buffer, int offset, int count);
}
internal class System.Xml.DoubleArrayHelperWithDictionaryString : ArrayHelper`2<XmlDictionaryString, double> {
    public static DoubleArrayHelperWithDictionaryString Instance;
    private static DoubleArrayHelperWithDictionaryString();
    protected virtual int ReadArray(XmlDictionaryReader reader, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Double[] array, int offset, int count);
    protected virtual void WriteArray(XmlDictionaryWriter writer, string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Double[] array, int offset, int count);
}
internal class System.Xml.DoubleArrayHelperWithString : ArrayHelper`2<string, double> {
    public static DoubleArrayHelperWithString Instance;
    private static DoubleArrayHelperWithString();
    protected virtual int ReadArray(XmlDictionaryReader reader, string localName, string namespaceUri, Double[] array, int offset, int count);
    protected virtual void WriteArray(XmlDictionaryWriter writer, string prefix, string localName, string namespaceUri, Double[] array, int offset, int count);
}
internal class System.Xml.EncodingStreamWrapper : Stream {
    private static UTF8Encoding SafeUTF8;
    private static UnicodeEncoding SafeUTF16;
    private static UnicodeEncoding SafeBEUTF16;
    private static UTF8Encoding ValidatingUTF8;
    private static UnicodeEncoding ValidatingUTF16;
    private static UnicodeEncoding ValidatingBEUTF16;
    private static int BufferLength;
    private static Byte[] encodingAttr;
    private static Byte[] encodingUTF8;
    private static Byte[] encodingUnicode;
    private static Byte[] encodingUnicodeLE;
    private static Byte[] encodingUnicodeBE;
    private SupportedEncoding encodingCode;
    private Encoding encoding;
    private Encoder enc;
    private Decoder dec;
    private bool isReading;
    private Stream stream;
    private Char[] chars;
    private Byte[] bytes;
    private int byteOffset;
    private int byteCount;
    private Byte[] byteBuffer;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Position { get; public set; }
    public bool CanTimeout { get; }
    public long Length { get; }
    public int ReadTimeout { get; public set; }
    public int WriteTimeout { get; public set; }
    public EncodingStreamWrapper(Stream stream, Encoding encoding);
    public EncodingStreamWrapper(Stream stream, Encoding encoding, bool emitBOM);
    private static EncodingStreamWrapper();
    private void SetReadDocumentEncoding(SupportedEncoding e);
    private static Encoding GetEncoding(SupportedEncoding e);
    private static Encoding GetSafeEncoding(SupportedEncoding e);
    private static string GetEncodingName(SupportedEncoding enc);
    private static SupportedEncoding GetSupportedEncoding(Encoding encoding);
    private SupportedEncoding ReadBOMEncoding(bool notOutOfBand);
    private static SupportedEncoding ReadBOMEncoding(byte b1, byte b2, byte b3, byte b4, bool notOutOfBand, Int32& preserve);
    private void FillBuffer(int count);
    private void EnsureBuffers();
    private void EnsureByteBuffer();
    private static void CheckUTF8DeclarationEncoding(Byte[] buffer, int offset, int count, SupportedEncoding e, SupportedEncoding expectedEnc);
    private static bool CompareCaseInsensitive(Byte[] key, Byte[] buffer, int offset);
    private static bool Compare(Byte[] key, Byte[] buffer, int offset);
    private static bool IsWhitespace(byte ch);
    internal static ArraySegment`1<byte> ProcessBuffer(Byte[] buffer, int offset, int count, Encoding encoding);
    private static void ThrowExpectedEncodingMismatch(SupportedEncoding expEnc, SupportedEncoding actualEnc);
    private static void ThrowEncodingMismatch(string declEnc, SupportedEncoding enc);
    private static void ThrowEncodingMismatch(string declEnc, string docEnc);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Close();
    public virtual void Flush();
    public virtual int ReadByte();
    public virtual int Read(Byte[] buffer, int offset, int count);
    private void CleanupCharBreak();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void WriteByte(byte b);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual bool get_CanTimeout();
    public virtual long get_Length();
    public virtual int get_ReadTimeout();
    public virtual void set_ReadTimeout(int value);
    public virtual int get_WriteTimeout();
    public virtual void set_WriteTimeout(int value);
    public virtual void SetLength(long value);
}
internal class System.Xml.GuidArrayHelperWithDictionaryString : ArrayHelper`2<XmlDictionaryString, Guid> {
    public static GuidArrayHelperWithDictionaryString Instance;
    private static GuidArrayHelperWithDictionaryString();
    protected virtual int ReadArray(XmlDictionaryReader reader, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Guid[] array, int offset, int count);
    protected virtual void WriteArray(XmlDictionaryWriter writer, string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Guid[] array, int offset, int count);
}
internal class System.Xml.GuidArrayHelperWithString : ArrayHelper`2<string, Guid> {
    public static GuidArrayHelperWithString Instance;
    private static GuidArrayHelperWithString();
    protected virtual int ReadArray(XmlDictionaryReader reader, string localName, string namespaceUri, Guid[] array, int offset, int count);
    protected virtual void WriteArray(XmlDictionaryWriter writer, string prefix, string localName, string namespaceUri, Guid[] array, int offset, int count);
}
public interface System.Xml.IFragmentCapableXmlDictionaryWriter {
    public bool CanFragment { get; }
    public abstract virtual bool get_CanFragment();
    public abstract virtual void StartFragment(Stream stream, bool generateSelfContainedTextFragment);
    public abstract virtual void EndFragment();
    public abstract virtual void WriteFragment(Byte[] buffer, int offset, int count);
}
internal class System.Xml.Int16ArrayHelperWithDictionaryString : ArrayHelper`2<XmlDictionaryString, short> {
    public static Int16ArrayHelperWithDictionaryString Instance;
    private static Int16ArrayHelperWithDictionaryString();
    protected virtual int ReadArray(XmlDictionaryReader reader, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Int16[] array, int offset, int count);
    protected virtual void WriteArray(XmlDictionaryWriter writer, string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Int16[] array, int offset, int count);
}
internal class System.Xml.Int16ArrayHelperWithString : ArrayHelper`2<string, short> {
    public static Int16ArrayHelperWithString Instance;
    private static Int16ArrayHelperWithString();
    protected virtual int ReadArray(XmlDictionaryReader reader, string localName, string namespaceUri, Int16[] array, int offset, int count);
    protected virtual void WriteArray(XmlDictionaryWriter writer, string prefix, string localName, string namespaceUri, Int16[] array, int offset, int count);
}
internal class System.Xml.Int32ArrayHelperWithDictionaryString : ArrayHelper`2<XmlDictionaryString, int> {
    public static Int32ArrayHelperWithDictionaryString Instance;
    private static Int32ArrayHelperWithDictionaryString();
    protected virtual int ReadArray(XmlDictionaryReader reader, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Int32[] array, int offset, int count);
    protected virtual void WriteArray(XmlDictionaryWriter writer, string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Int32[] array, int offset, int count);
}
internal class System.Xml.Int32ArrayHelperWithString : ArrayHelper`2<string, int> {
    public static Int32ArrayHelperWithString Instance;
    private static Int32ArrayHelperWithString();
    protected virtual int ReadArray(XmlDictionaryReader reader, string localName, string namespaceUri, Int32[] array, int offset, int count);
    protected virtual void WriteArray(XmlDictionaryWriter writer, string prefix, string localName, string namespaceUri, Int32[] array, int offset, int count);
}
internal class System.Xml.Int64ArrayHelperWithDictionaryString : ArrayHelper`2<XmlDictionaryString, long> {
    public static Int64ArrayHelperWithDictionaryString Instance;
    private static Int64ArrayHelperWithDictionaryString();
    protected virtual int ReadArray(XmlDictionaryReader reader, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Int64[] array, int offset, int count);
    protected virtual void WriteArray(XmlDictionaryWriter writer, string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Int64[] array, int offset, int count);
}
internal class System.Xml.Int64ArrayHelperWithString : ArrayHelper`2<string, long> {
    public static Int64ArrayHelperWithString Instance;
    private static Int64ArrayHelperWithString();
    protected virtual int ReadArray(XmlDictionaryReader reader, string localName, string namespaceUri, Int64[] array, int offset, int count);
    protected virtual void WriteArray(XmlDictionaryWriter writer, string prefix, string localName, string namespaceUri, Int64[] array, int offset, int count);
}
public interface System.Xml.IStreamProvider {
    public abstract virtual Stream GetStream();
    public abstract virtual void ReleaseStream(Stream stream);
}
public interface System.Xml.IXmlBinaryReaderInitializer {
    public abstract virtual void SetInput(Byte[] buffer, int offset, int count, IXmlDictionary dictionary, XmlDictionaryReaderQuotas quotas, XmlBinaryReaderSession session, OnXmlDictionaryReaderClose onClose);
    public abstract virtual void SetInput(Stream stream, IXmlDictionary dictionary, XmlDictionaryReaderQuotas quotas, XmlBinaryReaderSession session, OnXmlDictionaryReaderClose onClose);
}
public interface System.Xml.IXmlBinaryWriterInitializer {
    public abstract virtual void SetOutput(Stream stream, IXmlDictionary dictionary, XmlBinaryWriterSession session, bool ownsStream);
}
public interface System.Xml.IXmlDictionary {
    public abstract virtual bool TryLookup(string value, XmlDictionaryString& result);
    public abstract virtual bool TryLookup(int key, XmlDictionaryString& result);
    public abstract virtual bool TryLookup(XmlDictionaryString value, XmlDictionaryString& result);
}
public interface System.Xml.IXmlMtomReaderInitializer {
    public abstract virtual void SetInput(Byte[] buffer, int offset, int count, Encoding[] encodings, string contentType, XmlDictionaryReaderQuotas quotas, int maxBufferSize, OnXmlDictionaryReaderClose onClose);
    public abstract virtual void SetInput(Stream stream, Encoding[] encodings, string contentType, XmlDictionaryReaderQuotas quotas, int maxBufferSize, OnXmlDictionaryReaderClose onClose);
}
public interface System.Xml.IXmlMtomWriterInitializer {
    public abstract virtual void SetOutput(Stream stream, Encoding encoding, int maxSizeInBytes, string startInfo, string boundary, string startUri, bool writeMessageHeaders, bool ownsStream);
}
public interface System.Xml.IXmlTextReaderInitializer {
    public abstract virtual void SetInput(Byte[] buffer, int offset, int count, Encoding encoding, XmlDictionaryReaderQuotas quotas, OnXmlDictionaryReaderClose onClose);
    public abstract virtual void SetInput(Stream stream, Encoding encoding, XmlDictionaryReaderQuotas quotas, OnXmlDictionaryReaderClose onClose);
}
public interface System.Xml.IXmlTextWriterInitializer {
    public abstract virtual void SetOutput(Stream stream, Encoding encoding, bool ownsStream);
}
internal static class System.Xml.MailBnfHelper : object {
    private static Boolean[] s_fqtext;
    private static Boolean[] s_ttext;
    private static Boolean[] s_digits;
    private static Boolean[] s_boundary;
    private static MailBnfHelper();
    public static bool SkipCFWS(string data, Int32& offset);
    public static string ReadQuotedString(string data, Int32& offset, StringBuilder builder);
    public static string ReadParameterAttribute(string data, Int32& offset, StringBuilder builder);
    public static string ReadParameterValue(string data, Int32& offset, StringBuilder builder);
    public static string ReadToken(string data, Int32& offset, StringBuilder builder);
    public static string ReadDigits(string data, Int32& offset, StringBuilder builder);
    public static bool IsValidMimeBoundary(string data);
}
internal static class System.Xml.MimeGlobals : object {
    internal static string MimeVersionHeader;
    internal static string DefaultVersion;
    internal static string ContentIDScheme;
    internal static string ContentIDHeader;
    internal static string ContentTypeHeader;
    internal static string ContentTransferEncodingHeader;
    internal static string EncodingBinary;
    internal static string Encoding8bit;
    internal static Byte[] COLONSPACE;
    internal static Byte[] DASHDASH;
    internal static Byte[] CRLF;
    internal static Byte[] BoundaryPrefix;
    private static MimeGlobals();
}
internal class System.Xml.MimeHeader : object {
    private string name;
    private string value;
    public string Name { get; }
    public string Value { get; }
    public MimeHeader(string name, string value);
    public string get_Name();
    public string get_Value();
}
internal class System.Xml.MimeHeaderReader : object {
    private string value;
    private Byte[] buffer;
    private int maxOffset;
    private string name;
    private int offset;
    private ReadState readState;
    private Stream stream;
    public string Value { get; }
    public string Name { get; }
    public MimeHeaderReader(Stream stream);
    public string get_Value();
    public string get_Name();
    public void Close();
    public bool Read(int maxBuffer, Int32& remaining);
    [SecuritySafeCriticalAttribute]
private bool ProcessBuffer(int maxBuffer, Int32& remaining);
    private bool BufferEnd();
    public void Reset(Stream stream);
    private void AppendValue(string value, int maxBuffer, Int32& remaining);
    private void AppendName(string value, int maxBuffer, Int32& remaining);
}
internal class System.Xml.MimeHeaders : object {
    private Dictionary`2<string, MimeHeader> headers;
    public ContentTypeHeader ContentType { get; }
    public ContentIDHeader ContentID { get; }
    public ContentTransferEncodingHeader ContentTransferEncoding { get; }
    public MimeVersionHeader MimeVersion { get; }
    public ContentTypeHeader get_ContentType();
    public ContentIDHeader get_ContentID();
    public ContentTransferEncodingHeader get_ContentTransferEncoding();
    public MimeVersionHeader get_MimeVersion();
    public void Add(string name, string value, Int32& remaining);
    public void Add(MimeHeader header);
    public void Release(Int32& remaining);
}
internal class System.Xml.MimeMessageReader : object {
    private static Byte[] CRLFCRLF;
    private bool getContentStreamCalled;
    private MimeHeaderReader mimeHeaderReader;
    private DelimittedStreamReader reader;
    public MimeMessageReader(Stream stream);
    private static MimeMessageReader();
    public Stream GetContentStream();
    public MimeHeaders ReadHeaders(int maxBuffer, Int32& remaining);
}
internal class System.Xml.MimeReader : object {
    private static Byte[] CRLFCRLF;
    private Byte[] boundaryBytes;
    private string content;
    private Stream currentStream;
    private MimeHeaderReader mimeHeaderReader;
    private DelimittedStreamReader reader;
    private Byte[] scratch;
    public string Preface { get; }
    public MimeReader(Stream stream, string boundary);
    private static MimeReader();
    public void Close();
    public string get_Preface();
    public Stream GetContentStream();
    public bool ReadNextPart();
    public MimeHeaders ReadHeaders(int maxBuffer, Int32& remaining);
    private int BlockRead(Stream stream, Byte[] buffer, int offset, int count);
}
internal class System.Xml.MimeVersionHeader : MimeHeader {
    public static MimeVersionHeader Default;
    private string version;
    public string Version { get; }
    public MimeVersionHeader(string value);
    private static MimeVersionHeader();
    public string get_Version();
    private void ParseValue();
}
internal class System.Xml.MimeWriter : object {
    private Stream stream;
    private Byte[] boundaryBytes;
    private MimeWriterState state;
    private BufferedWrite bufferedWrite;
    private Stream contentStream;
    internal MimeWriterState WriteState { get; }
    internal MimeWriter(Stream stream, string boundary);
    internal static int GetHeaderSize(string name, string value, int maxSizeInBytes);
    internal static Byte[] GetBoundaryBytes(string boundary);
    internal MimeWriterState get_WriteState();
    internal int GetBoundarySize();
    internal void StartPreface();
    internal void StartPart();
    internal void Close();
    private void Flush();
    internal void WriteHeader(string name, string value);
    internal Stream GetContentStream();
}
internal enum System.Xml.MimeWriterState : Enum {
    public int value__;
    public static MimeWriterState Start;
    public static MimeWriterState StartPreface;
    public static MimeWriterState StartPart;
    public static MimeWriterState Header;
    public static MimeWriterState Content;
    public static MimeWriterState Closed;
}
internal class System.Xml.MtomBinaryData : object {
    internal MtomBinaryDataType type;
    internal IStreamProvider provider;
    internal Byte[] chunk;
    internal long Length { get; }
    internal MtomBinaryData(IStreamProvider provider);
    internal MtomBinaryData(Byte[] buffer, int offset, int count);
    internal long get_Length();
}
internal enum System.Xml.MtomBinaryDataType : Enum {
    public int value__;
    public static MtomBinaryDataType Provider;
    public static MtomBinaryDataType Segment;
}
internal static class System.Xml.MtomGlobals : object {
    internal static string XopIncludeLocalName;
    internal static string XopIncludeNamespace;
    internal static string XopIncludePrefix;
    internal static string XopIncludeHrefLocalName;
    internal static string XopIncludeHrefNamespace;
    internal static string MediaType;
    internal static string MediaSubtype;
    internal static string BoundaryParam;
    internal static string TypeParam;
    internal static string XopMediaType;
    internal static string XopMediaSubtype;
    internal static string XopType;
    internal static string StartParam;
    internal static string StartInfoParam;
    internal static string ActionParam;
    internal static string CharsetParam;
    internal static string MimeContentTypeLocalName;
    internal static string MimeContentTypeNamespace200406;
    internal static string MimeContentTypeNamespace200505;
    internal static string DefaultContentTypeForBinary;
    private static MtomGlobals();
}
public class System.Xml.OnXmlDictionaryReaderClose : MulticastDelegate {
    public OnXmlDictionaryReaderClose(object object, IntPtr method);
    public virtual void Invoke(XmlDictionaryReader reader);
    public virtual IAsyncResult BeginInvoke(XmlDictionaryReader reader, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.Xml.PrefixHandle : object {
    private XmlBufferReader bufferReader;
    private PrefixHandleType type;
    private int offset;
    private int length;
    private static String[] prefixStrings;
    private static Byte[] prefixBuffer;
    public bool IsEmpty { get; }
    public bool IsXmlns { get; }
    public bool IsXml { get; }
    public PrefixHandle(XmlBufferReader bufferReader);
    private static PrefixHandle();
    public void SetValue(PrefixHandleType type);
    public void SetValue(PrefixHandle prefix);
    public void SetValue(int offset, int length);
    public bool get_IsEmpty();
    public bool get_IsXmlns();
    public bool get_IsXml();
    public bool TryGetShortPrefix(PrefixHandleType& type);
    public static string GetString(PrefixHandleType type);
    public static PrefixHandleType GetAlphaPrefix(int index);
    public static Byte[] GetString(PrefixHandleType type, Int32& offset, Int32& length);
    public string GetString(XmlNameTable nameTable);
    public string GetString();
    public Byte[] GetString(Int32& offset, Int32& length);
    public int CompareTo(PrefixHandle that);
    private bool Equals2(PrefixHandle prefix2);
    private bool Equals2(string prefix2);
    private bool Equals2(XmlDictionaryString prefix2);
    public static bool op_Equality(PrefixHandle prefix1, string prefix2);
    public static bool op_Inequality(PrefixHandle prefix1, string prefix2);
    public static bool op_Equality(PrefixHandle prefix1, XmlDictionaryString prefix2);
    public static bool op_Inequality(PrefixHandle prefix1, XmlDictionaryString prefix2);
    public static bool op_Equality(PrefixHandle prefix1, PrefixHandle prefix2);
    public static bool op_Inequality(PrefixHandle prefix1, PrefixHandle prefix2);
    public virtual bool Equals(object obj);
    public virtual string ToString();
    public virtual int GetHashCode();
}
internal enum System.Xml.PrefixHandleType : Enum {
    public int value__;
    public static PrefixHandleType Empty;
    public static PrefixHandleType A;
    public static PrefixHandleType B;
    public static PrefixHandleType C;
    public static PrefixHandleType D;
    public static PrefixHandleType E;
    public static PrefixHandleType F;
    public static PrefixHandleType G;
    public static PrefixHandleType H;
    public static PrefixHandleType I;
    public static PrefixHandleType J;
    public static PrefixHandleType K;
    public static PrefixHandleType L;
    public static PrefixHandleType M;
    public static PrefixHandleType N;
    public static PrefixHandleType O;
    public static PrefixHandleType P;
    public static PrefixHandleType Q;
    public static PrefixHandleType R;
    public static PrefixHandleType S;
    public static PrefixHandleType T;
    public static PrefixHandleType U;
    public static PrefixHandleType V;
    public static PrefixHandleType W;
    public static PrefixHandleType X;
    public static PrefixHandleType Y;
    public static PrefixHandleType Z;
    public static PrefixHandleType Buffer;
    public static PrefixHandleType Max;
}
internal class System.Xml.SingleArrayHelperWithDictionaryString : ArrayHelper`2<XmlDictionaryString, float> {
    public static SingleArrayHelperWithDictionaryString Instance;
    private static SingleArrayHelperWithDictionaryString();
    protected virtual int ReadArray(XmlDictionaryReader reader, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Single[] array, int offset, int count);
    protected virtual void WriteArray(XmlDictionaryWriter writer, string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Single[] array, int offset, int count);
}
internal class System.Xml.SingleArrayHelperWithString : ArrayHelper`2<string, float> {
    public static SingleArrayHelperWithString Instance;
    private static SingleArrayHelperWithString();
    protected virtual int ReadArray(XmlDictionaryReader reader, string localName, string namespaceUri, Single[] array, int offset, int count);
    protected virtual void WriteArray(XmlDictionaryWriter writer, string prefix, string localName, string namespaceUri, Single[] array, int offset, int count);
}
internal class System.Xml.StringHandle : object {
    private XmlBufferReader bufferReader;
    private StringHandleType type;
    private int key;
    private int offset;
    private int length;
    private static String[] constStrings;
    public bool IsEmpty { get; }
    public bool IsXmlns { get; }
    public StringHandle(XmlBufferReader bufferReader);
    private static StringHandle();
    public void SetValue(int offset, int length);
    public void SetConstantValue(StringHandleConstStringType constStringType);
    public void SetValue(int offset, int length, bool escaped);
    public void SetValue(int key);
    public void SetValue(StringHandle value);
    public bool get_IsEmpty();
    public bool get_IsXmlns();
    public void ToPrefixHandle(PrefixHandle prefix);
    public string GetString(XmlNameTable nameTable);
    public string GetString();
    public Byte[] GetString(Int32& offset, Int32& length);
    public bool TryGetDictionaryString(XmlDictionaryString& value);
    public virtual string ToString();
    private bool Equals2(int key2, XmlBufferReader bufferReader2);
    private bool Equals2(XmlDictionaryString xmlString2);
    private bool Equals2(string s2);
    private bool Equals2(int offset2, int length2, XmlBufferReader bufferReader2);
    private bool Equals2(StringHandle s2);
    public static bool op_Equality(StringHandle s1, XmlDictionaryString xmlString2);
    public static bool op_Inequality(StringHandle s1, XmlDictionaryString xmlString2);
    public static bool op_Equality(StringHandle s1, string s2);
    public static bool op_Inequality(StringHandle s1, string s2);
    public static bool op_Equality(StringHandle s1, StringHandle s2);
    public static bool op_Inequality(StringHandle s1, StringHandle s2);
    public int CompareTo(StringHandle that);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal enum System.Xml.StringHandleConstStringType : Enum {
    public int value__;
    public static StringHandleConstStringType Type;
    public static StringHandleConstStringType Root;
    public static StringHandleConstStringType Item;
}
internal class System.Xml.TimeSpanArrayHelperWithDictionaryString : ArrayHelper`2<XmlDictionaryString, TimeSpan> {
    public static TimeSpanArrayHelperWithDictionaryString Instance;
    private static TimeSpanArrayHelperWithDictionaryString();
    protected virtual int ReadArray(XmlDictionaryReader reader, XmlDictionaryString localName, XmlDictionaryString namespaceUri, TimeSpan[] array, int offset, int count);
    protected virtual void WriteArray(XmlDictionaryWriter writer, string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, TimeSpan[] array, int offset, int count);
}
internal class System.Xml.TimeSpanArrayHelperWithString : ArrayHelper`2<string, TimeSpan> {
    public static TimeSpanArrayHelperWithString Instance;
    private static TimeSpanArrayHelperWithString();
    protected virtual int ReadArray(XmlDictionaryReader reader, string localName, string namespaceUri, TimeSpan[] array, int offset, int count);
    protected virtual void WriteArray(XmlDictionaryWriter writer, string prefix, string localName, string namespaceUri, TimeSpan[] array, int offset, int count);
}
public class System.Xml.UniqueId : object {
    private long idLow;
    private long idHigh;
    [SecurityCriticalAttribute]
private string s;
    private static int guidLength;
    private static int uuidLength;
    private static Int16[] char2val;
    private static string val2char;
    public int CharArrayLength { get; }
    public bool IsGuid { get; }
    public UniqueId(Guid guid);
    public UniqueId(Byte[] guid);
    [SecuritySafeCriticalAttribute]
public UniqueId(Byte[] guid, int offset);
    [SecuritySafeCriticalAttribute]
public UniqueId(string value);
    [SecuritySafeCriticalAttribute]
public UniqueId(Char[] chars, int offset, int count);
    private static UniqueId();
    [SecuritySafeCriticalAttribute]
public int get_CharArrayLength();
    [SecurityCriticalAttribute]
private int UnsafeDecode(Int16* char2val, char ch1, char ch2);
    [SecurityCriticalAttribute]
private void UnsafeEncode(Char* val2char, byte b, Char* pch);
    public bool get_IsGuid();
    [SecurityCriticalAttribute]
private void UnsafeParse(Char* chars, int charCount);
    [SecuritySafeCriticalAttribute]
public int ToCharArray(Char[] chars, int offset);
    public bool TryGetGuid(Guid& guid);
    [SecuritySafeCriticalAttribute]
public bool TryGetGuid(Byte[] buffer, int offset);
    [SecuritySafeCriticalAttribute]
public virtual string ToString();
    public static bool op_Equality(UniqueId id1, UniqueId id2);
    public static bool op_Inequality(UniqueId id1, UniqueId id2);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [SecurityCriticalAttribute]
private long UnsafeGetInt64(Byte* pb);
    [SecurityCriticalAttribute]
private int UnsafeGetInt32(Byte* pb);
    [SecurityCriticalAttribute]
private void UnsafeSetInt64(long value, Byte* pb);
    [SecurityCriticalAttribute]
private void UnsafeSetInt32(int value, Byte* pb);
}
internal class System.Xml.ValueHandle : object {
    private XmlBufferReader bufferReader;
    private ValueHandleType type;
    private int offset;
    private int length;
    private static Base64Encoding base64Encoding;
    private static String[] constStrings;
    private static Base64Encoding Base64Encoding { get; }
    public ValueHandle(XmlBufferReader bufferReader);
    private static ValueHandle();
    private static Base64Encoding get_Base64Encoding();
    public void SetConstantValue(ValueHandleConstStringType constStringType);
    public void SetValue(ValueHandleType type);
    public void SetDictionaryValue(int key);
    public void SetCharValue(int ch);
    public void SetQNameValue(int prefix, int key);
    public void SetValue(ValueHandleType type, int offset, int length);
    public bool IsWhitespace();
    public Type ToType();
    public bool ToBoolean();
    public int ToInt();
    public long ToLong();
    public ulong ToULong();
    public float ToSingle();
    public double ToDouble();
    public decimal ToDecimal();
    public DateTime ToDateTime();
    public UniqueId ToUniqueId();
    public TimeSpan ToTimeSpan();
    public Guid ToGuid();
    public virtual string ToString();
    public Byte[] ToByteArray();
    public string GetString();
    public bool Equals2(string str, bool checkLower);
    public void Sign(XmlSigningNodeWriter writer);
    public Object[] ToList();
    public object ToObject();
    public bool TryReadBase64(Byte[] buffer, int offset, int count, Int32& actual);
    public bool TryReadChars(Char[] chars, int offset, int count, Int32& actual);
    private bool TryReadUnicodeChars(Char[] chars, int offset, int count, Int32& actual);
    public bool TryGetDictionaryString(XmlDictionaryString& value);
    public bool TryGetByteArrayLength(Int32& length);
    private string GetCharsText();
    private string GetUnicodeCharsText();
    private string GetEscapedCharsText();
    private string GetCharText();
    private int GetChar();
    private int GetInt8();
    private int GetInt16();
    private int GetInt32();
    private long GetInt64();
    private ulong GetUInt64();
    private float GetSingle();
    private double GetDouble();
    private decimal GetDecimal();
    private UniqueId GetUniqueId();
    private Guid GetGuid();
    private void GetBase64(Byte[] buffer, int offset, int count);
    private XmlDictionaryString GetDictionaryString();
    private string GetQNameDictionaryText();
}
internal enum System.Xml.ValueHandleConstStringType : Enum {
    public int value__;
    public static ValueHandleConstStringType String;
    public static ValueHandleConstStringType Number;
    public static ValueHandleConstStringType Array;
    public static ValueHandleConstStringType Object;
    public static ValueHandleConstStringType Boolean;
    public static ValueHandleConstStringType Null;
}
internal static class System.Xml.ValueHandleLength : object {
    public static int Int8;
    public static int Int16;
    public static int Int32;
    public static int Int64;
    public static int UInt64;
    public static int Single;
    public static int Double;
    public static int Decimal;
    public static int DateTime;
    public static int TimeSpan;
    public static int Guid;
    public static int UniqueId;
}
internal enum System.Xml.ValueHandleType : Enum {
    public int value__;
    public static ValueHandleType Empty;
    public static ValueHandleType True;
    public static ValueHandleType False;
    public static ValueHandleType Zero;
    public static ValueHandleType One;
    public static ValueHandleType Int8;
    public static ValueHandleType Int16;
    public static ValueHandleType Int32;
    public static ValueHandleType Int64;
    public static ValueHandleType UInt64;
    public static ValueHandleType Single;
    public static ValueHandleType Double;
    public static ValueHandleType Decimal;
    public static ValueHandleType DateTime;
    public static ValueHandleType TimeSpan;
    public static ValueHandleType Guid;
    public static ValueHandleType UniqueId;
    public static ValueHandleType UTF8;
    public static ValueHandleType EscapedUTF8;
    public static ValueHandleType Base64;
    public static ValueHandleType Dictionary;
    public static ValueHandleType List;
    public static ValueHandleType Char;
    public static ValueHandleType Unicode;
    public static ValueHandleType QName;
    public static ValueHandleType ConstString;
}
[DefaultMemberAttribute("Item")]
internal abstract class System.Xml.XmlBaseReader : XmlDictionaryReader {
    private XmlBufferReader bufferReader;
    private XmlNode node;
    private NamespaceManager nsMgr;
    private XmlElementNode[] elementNodes;
    private XmlAttributeNode[] attributeNodes;
    private XmlAtomicTextNode atomicTextNode;
    private int depth;
    private int attributeCount;
    private int attributeStart;
    private XmlDictionaryReaderQuotas quotas;
    private XmlNameTable nameTable;
    private XmlDeclarationNode declarationNode;
    private XmlComplexTextNode complexTextNode;
    private XmlWhitespaceTextNode whitespaceTextNode;
    private XmlCDataNode cdataNode;
    private XmlCommentNode commentNode;
    private XmlElementNode rootElementNode;
    private int attributeIndex;
    private Char[] chars;
    private string prefix;
    private string localName;
    private string ns;
    private string value;
    private int trailCharCount;
    private int trailByteCount;
    private Char[] trailChars;
    private Byte[] trailBytes;
    private bool rootElement;
    private bool readingElement;
    private XmlSigningNodeWriter signingWriter;
    private bool signing;
    private AttributeSorter attributeSorter;
    private static XmlInitialNode initialNode;
    private static XmlEndOfFileNode endOfFileNode;
    private static XmlClosedNode closedNode;
    private static BinHexEncoding binhexEncoding;
    private static Base64Encoding base64Encoding;
    private static string xmlns;
    private static string xml;
    private static string xmlnsNamespace;
    private static string xmlNamespace;
    private static BinHexEncoding BinHexEncoding { get; }
    private static Base64Encoding Base64Encoding { get; }
    protected XmlBufferReader BufferReader { get; }
    public XmlDictionaryReaderQuotas Quotas { get; }
    protected XmlNode Node { get; }
    protected XmlElementNode ElementNode { get; }
    protected bool OutsideRootElement { get; }
    public bool CanReadBinaryContent { get; }
    public bool CanReadValueChunk { get; }
    public string BaseURI { get; }
    public bool HasValue { get; }
    public bool IsDefault { get; }
    public string Item { get; }
    public string Item { get; }
    public string Item { get; }
    public int AttributeCount { get; }
    public int Depth { get; }
    public bool EOF { get; }
    public bool IsEmptyElement { get; }
    public string LocalName { get; }
    public string NamespaceURI { get; }
    public XmlNameTable NameTable { get; }
    public XmlNodeType NodeType { get; }
    public string Prefix { get; }
    public char QuoteChar { get; }
    public ReadState ReadState { get; }
    public string Value { get; }
    public Type ValueType { get; }
    public string XmlLang { get; }
    public XmlSpace XmlSpace { get; }
    public bool CanCanonicalize { get; }
    protected bool Signing { get; }
    private static XmlBaseReader();
    private static BinHexEncoding get_BinHexEncoding();
    private static Base64Encoding get_Base64Encoding();
    protected XmlBufferReader get_BufferReader();
    public virtual XmlDictionaryReaderQuotas get_Quotas();
    protected XmlNode get_Node();
    protected void MoveToNode(XmlNode node);
    protected void MoveToInitial(XmlDictionaryReaderQuotas quotas);
    protected XmlDeclarationNode MoveToDeclaration();
    private bool CheckStandalone(int attr);
    private bool CheckDeclAttribute(int index, string localName, string value, bool checkLower, string valueSR);
    protected XmlCommentNode MoveToComment();
    protected XmlCDataNode MoveToCData();
    protected XmlAtomicTextNode MoveToAtomicText();
    protected XmlComplexTextNode MoveToComplexText();
    protected XmlTextNode MoveToWhitespaceText();
    protected XmlElementNode get_ElementNode();
    protected void MoveToEndElement();
    protected void MoveToEndOfFile();
    protected XmlElementNode EnterScope();
    protected void ExitScope();
    private XmlAttributeNode AddAttribute(QNameType qnameType, bool isAtomicValue);
    protected Namespace AddNamespace();
    protected XmlAttributeNode AddAttribute();
    protected XmlAttributeNode AddXmlAttribute();
    protected XmlAttributeNode AddXmlnsAttribute(Namespace ns);
    protected void FixXmlAttribute(XmlAttributeNode attributeNode);
    protected bool get_OutsideRootElement();
    public virtual bool get_CanReadBinaryContent();
    public virtual bool get_CanReadValueChunk();
    public virtual string get_BaseURI();
    public virtual bool get_HasValue();
    public virtual bool get_IsDefault();
    public virtual string get_Item(int index);
    public virtual string get_Item(string name);
    public virtual string get_Item(string localName, string namespaceUri);
    public virtual int get_AttributeCount();
    public virtual void Close();
    public sealed virtual int get_Depth();
    public virtual bool get_EOF();
    private XmlAttributeNode GetAttributeNode(int index);
    private XmlAttributeNode GetAttributeNode(string name);
    private XmlAttributeNode GetAttributeNode(string localName, string namespaceUri);
    private XmlAttributeNode GetAttributeNode(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    public virtual string GetAttribute(int index);
    public virtual string GetAttribute(string name);
    public virtual string GetAttribute(string localName, string namespaceUri);
    public virtual string GetAttribute(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    public sealed virtual bool get_IsEmptyElement();
    public virtual string get_LocalName();
    public virtual string LookupNamespace(string prefix);
    protected Namespace LookupNamespace(PrefixHandleType prefix);
    protected Namespace LookupNamespace(PrefixHandle prefix);
    protected void ProcessAttributes();
    private void ProcessAttributes(XmlAttributeNode[] attributeNodes, int attributeCount);
    private void CheckAttributes(XmlAttributeNode[] attributeNodes, int attributeCount);
    public virtual void MoveToAttribute(int index);
    public virtual bool MoveToAttribute(string name);
    public virtual bool MoveToAttribute(string localName, string namespaceUri);
    public virtual bool MoveToElement();
    public virtual XmlNodeType MoveToContent();
    public virtual bool MoveToFirstAttribute();
    public virtual bool MoveToNextAttribute();
    public virtual string get_NamespaceURI();
    public virtual XmlNameTable get_NameTable();
    public sealed virtual XmlNodeType get_NodeType();
    public virtual string get_Prefix();
    public virtual char get_QuoteChar();
    private string GetLocalName(bool enforceAtomization);
    private string GetNamespaceUri(bool enforceAtomization);
    public virtual void GetNonAtomizedNames(String& localName, String& namespaceUri);
    public virtual bool IsLocalName(string localName);
    public virtual bool IsLocalName(XmlDictionaryString localName);
    public virtual bool IsNamespaceUri(string namespaceUri);
    public virtual bool IsNamespaceUri(XmlDictionaryString namespaceUri);
    public sealed virtual bool IsStartElement();
    public virtual bool IsStartElement(string name);
    public virtual bool IsStartElement(string localName, string namespaceUri);
    public virtual bool IsStartElement(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    public virtual int IndexOfLocalName(String[] localNames, string namespaceUri);
    public virtual int IndexOfLocalName(XmlDictionaryString[] localNames, XmlDictionaryString namespaceUri);
    public virtual int ReadValueChunk(Char[] chars, int offset, int count);
    public virtual int ReadValueAsBase64(Byte[] buffer, int offset, int count);
    public virtual string ReadElementContentAsString();
    public virtual string ReadElementString();
    public virtual string ReadElementString(string name);
    public virtual string ReadElementString(string localName, string namespaceUri);
    public virtual void ReadStartElement();
    public virtual void ReadStartElement(string name);
    public virtual void ReadStartElement(string localName, string namespaceUri);
    public virtual void ReadEndElement();
    public virtual bool ReadAttributeValue();
    public virtual ReadState get_ReadState();
    private void SkipValue(XmlNode node);
    public virtual bool TryGetBase64ContentLength(Int32& length);
    public virtual Byte[] ReadContentAsBase64();
    public virtual int ReadElementContentAsBase64(Byte[] buffer, int offset, int count);
    public virtual int ReadContentAsBase64(Byte[] buffer, int offset, int count);
    public virtual Byte[] ReadContentAsBinHex();
    public virtual int ReadElementContentAsBinHex(Byte[] buffer, int offset, int count);
    public virtual int ReadContentAsBinHex(Byte[] buffer, int offset, int count);
    private int ReadBytes(Encoding encoding, int byteBlock, int charBlock, Byte[] buffer, int offset, int byteCount, bool readContent);
    public virtual string ReadContentAsString();
    public virtual bool ReadContentAsBoolean();
    public virtual long ReadContentAsLong();
    public virtual int ReadContentAsInt();
    public virtual DateTime ReadContentAsDateTime();
    public virtual double ReadContentAsDouble();
    public virtual float ReadContentAsFloat();
    public virtual decimal ReadContentAsDecimal();
    public virtual UniqueId ReadContentAsUniqueId();
    public virtual TimeSpan ReadContentAsTimeSpan();
    public virtual Guid ReadContentAsGuid();
    public virtual object ReadContentAsObject();
    public virtual object ReadContentAs(Type type, IXmlNamespaceResolver namespaceResolver);
    public virtual void ResolveEntity();
    public virtual void Skip();
    public virtual string get_Value();
    public virtual Type get_ValueType();
    public virtual string get_XmlLang();
    public virtual XmlSpace get_XmlSpace();
    public virtual bool TryGetLocalNameAsDictionaryString(XmlDictionaryString& localName);
    public virtual bool TryGetNamespaceUriAsDictionaryString(XmlDictionaryString& localName);
    public virtual bool TryGetValueAsDictionaryString(XmlDictionaryString& value);
    public virtual Int16[] ReadInt16Array(string localName, string namespaceUri);
    public virtual Int16[] ReadInt16Array(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    public virtual Int32[] ReadInt32Array(string localName, string namespaceUri);
    public virtual Int32[] ReadInt32Array(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    public virtual Int64[] ReadInt64Array(string localName, string namespaceUri);
    public virtual Int64[] ReadInt64Array(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    public virtual Single[] ReadSingleArray(string localName, string namespaceUri);
    public virtual Single[] ReadSingleArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    public virtual Double[] ReadDoubleArray(string localName, string namespaceUri);
    public virtual Double[] ReadDoubleArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    public virtual Decimal[] ReadDecimalArray(string localName, string namespaceUri);
    public virtual Decimal[] ReadDecimalArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    public virtual DateTime[] ReadDateTimeArray(string localName, string namespaceUri);
    public virtual DateTime[] ReadDateTimeArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    public virtual Guid[] ReadGuidArray(string localName, string namespaceUri);
    public virtual Guid[] ReadGuidArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    public virtual TimeSpan[] ReadTimeSpanArray(string localName, string namespaceUri);
    public virtual TimeSpan[] ReadTimeSpanArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    public string GetOpenElements();
    private Char[] GetCharBuffer(int count);
    private void SignStartElement(XmlSigningNodeWriter writer);
    private void SignAttribute(XmlSigningNodeWriter writer, XmlAttributeNode attributeNode);
    private void SignEndElement(XmlSigningNodeWriter writer);
    private void SignNode(XmlSigningNodeWriter writer);
    public virtual bool get_CanCanonicalize();
    protected bool get_Signing();
    protected void SignNode();
    public virtual void StartCanonicalization(Stream stream, bool includeComments, String[] inclusivePrefixes);
    public virtual void EndCanonicalization();
    protected abstract virtual XmlSigningNodeWriter CreateSigningNodeWriter();
}
internal abstract class System.Xml.XmlBaseWriter : XmlDictionaryWriter {
    private XmlNodeWriter writer;
    private NamespaceManager nsMgr;
    private Element[] elements;
    private int depth;
    private string attributeLocalName;
    private string attributeValue;
    private bool isXmlAttribute;
    private bool isXmlnsAttribute;
    private WriteState writeState;
    private DocumentState documentState;
    private Byte[] trailBytes;
    private int trailByteCount;
    private XmlStreamNodeWriter nodeWriter;
    private XmlSigningNodeWriter signingWriter;
    private XmlUTF8NodeWriter textFragmentWriter;
    private XmlNodeWriter oldWriter;
    private Stream oldStream;
    private int oldNamespaceBoundary;
    private bool inList;
    private static string xmlnsNamespace;
    private static string xmlNamespace;
    private static BinHexEncoding binhexEncoding;
    private static String[] prefixes;
    private XmlBaseWriterNodeWriterAsyncHelper nodeWriterAsyncHelper;
    protected bool IsClosed { get; }
    private static BinHexEncoding BinHexEncoding { get; }
    public string XmlLang { get; }
    public XmlSpace XmlSpace { get; }
    public WriteState WriteState { get; }
    protected int NamespaceBoundary { get; protected set; }
    public bool CanCanonicalize { get; }
    protected bool Signing { get; }
    public bool CanFragment { get; }
    private static XmlBaseWriter();
    protected void SetOutput(XmlStreamNodeWriter writer);
    public virtual void Flush();
    public virtual void Close();
    protected bool get_IsClosed();
    protected void ThrowClosed();
    private static BinHexEncoding get_BinHexEncoding();
    public virtual string get_XmlLang();
    public virtual XmlSpace get_XmlSpace();
    public virtual WriteState get_WriteState();
    public virtual void WriteXmlnsAttribute(string prefix, string ns);
    public virtual void WriteXmlnsAttribute(string prefix, XmlDictionaryString ns);
    private void StartAttribute(String& prefix, string localName, string ns, XmlDictionaryString xNs);
    public virtual void WriteStartAttribute(string prefix, string localName, string namespaceUri);
    public virtual void WriteStartAttribute(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    public virtual void WriteEndAttribute();
    public virtual void WriteComment(string text);
    public virtual void WriteFullEndElement();
    public virtual void WriteCData(string text);
    public virtual void WriteDocType(string name, string pubid, string sysid, string subset);
    private void StartElement(String& prefix, string localName, string ns, XmlDictionaryString xNs);
    public virtual void WriteStartElement(string prefix, string localName, string namespaceUri);
    public virtual void WriteStartElement(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    public virtual void WriteEndElement();
    private Element EnterScope();
    private void ExitScope();
    protected void FlushElement();
    protected void StartComment();
    protected void EndComment();
    protected void StartContent();
    protected void StartContent(char ch);
    protected void StartContent(string s);
    protected void StartContent(Char[] chars, int offset, int count);
    private void VerifyWhitespace(char ch);
    private void VerifyWhitespace(string s);
    private void VerifyWhitespace(Char[] chars, int offset, int count);
    private bool IsWhitespace(char ch);
    protected void EndContent();
    private void AutoComplete(WriteState writeState);
    private void EndStartElement();
    public virtual string LookupPrefix(string ns);
    internal string LookupNamespace(string prefix);
    private string GetQualifiedNamePrefix(string namespaceUri, XmlDictionaryString xNs);
    public virtual void WriteQualifiedName(string localName, string namespaceUri);
    public virtual void WriteQualifiedName(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    public virtual void WriteStartDocument();
    public virtual void WriteStartDocument(bool standalone);
    public virtual void WriteProcessingInstruction(string name, string text);
    private void FinishDocument();
    public virtual void WriteEndDocument();
    protected int get_NamespaceBoundary();
    protected void set_NamespaceBoundary(int value);
    public virtual void WriteEntityRef(string name);
    public virtual void WriteName(string name);
    public virtual void WriteNmToken(string name);
    public virtual void WriteWhitespace(string whitespace);
    public virtual void WriteString(string value);
    public virtual void WriteString(XmlDictionaryString value);
    public virtual void WriteChars(Char[] chars, int offset, int count);
    public virtual void WriteRaw(string value);
    public virtual void WriteRaw(Char[] chars, int offset, int count);
    public virtual void WriteCharEntity(char ch);
    public virtual void WriteSurrogateCharEntity(char lowChar, char highChar);
    public virtual void WriteValue(object value);
    protected void WritePrimitiveValue(object value);
    public virtual void WriteValue(string value);
    public virtual void WriteValue(int value);
    public virtual void WriteValue(long value);
    private void WriteValue(ulong value);
    public virtual void WriteValue(bool value);
    public virtual void WriteValue(decimal value);
    public virtual void WriteValue(float value);
    public virtual void WriteValue(double value);
    public virtual void WriteValue(XmlDictionaryString value);
    public virtual void WriteValue(DateTime value);
    public virtual void WriteValue(UniqueId value);
    public virtual void WriteValue(Guid value);
    public virtual void WriteValue(TimeSpan value);
    public virtual void WriteBase64(Byte[] buffer, int offset, int count);
    internal virtual IAsyncResult BeginWriteBase64(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    internal virtual void EndWriteBase64(IAsyncResult result);
    internal virtual AsyncCompletionResult WriteBase64Async(AsyncEventArgs`1<XmlWriteBase64AsyncArguments> state);
    public virtual void WriteBinHex(Byte[] buffer, int offset, int count);
    public virtual bool get_CanCanonicalize();
    protected bool get_Signing();
    public virtual void StartCanonicalization(Stream stream, bool includeComments, String[] inclusivePrefixes);
    public virtual void EndCanonicalization();
    protected abstract virtual XmlSigningNodeWriter CreateSigningNodeWriter();
    public virtual bool get_CanFragment();
    public sealed virtual void StartFragment(Stream stream, bool generateSelfContainedTextFragment);
    public sealed virtual void EndFragment();
    public sealed virtual void WriteFragment(Byte[] buffer, int offset, int count);
    private void FlushBase64();
    private void FlushTrailBytes();
    private void WriteValue(Object[] array);
    private void WriteValue(Array array);
    protected void StartArray(int count);
    protected void EndArray();
    private void EnsureBufferBounds(Byte[] buffer, int offset, int count);
    private string GeneratePrefix(string ns, XmlDictionaryString xNs);
    protected void SignScope(XmlCanonicalWriter signingWriter);
    private void WriteAttributeText(string value);
}
internal enum System.Xml.XmlBinaryNodeType : Enum {
    public int value__;
    public static XmlBinaryNodeType EndElement;
    public static XmlBinaryNodeType Comment;
    public static XmlBinaryNodeType Array;
    public static XmlBinaryNodeType MinAttribute;
    public static XmlBinaryNodeType ShortAttribute;
    public static XmlBinaryNodeType Attribute;
    public static XmlBinaryNodeType ShortDictionaryAttribute;
    public static XmlBinaryNodeType DictionaryAttribute;
    public static XmlBinaryNodeType ShortXmlnsAttribute;
    public static XmlBinaryNodeType XmlnsAttribute;
    public static XmlBinaryNodeType ShortDictionaryXmlnsAttribute;
    public static XmlBinaryNodeType DictionaryXmlnsAttribute;
    public static XmlBinaryNodeType PrefixDictionaryAttributeA;
    public static XmlBinaryNodeType PrefixDictionaryAttributeB;
    public static XmlBinaryNodeType PrefixDictionaryAttributeC;
    public static XmlBinaryNodeType PrefixDictionaryAttributeD;
    public static XmlBinaryNodeType PrefixDictionaryAttributeE;
    public static XmlBinaryNodeType PrefixDictionaryAttributeF;
    public static XmlBinaryNodeType PrefixDictionaryAttributeG;
    public static XmlBinaryNodeType PrefixDictionaryAttributeH;
    public static XmlBinaryNodeType PrefixDictionaryAttributeI;
    public static XmlBinaryNodeType PrefixDictionaryAttributeJ;
    public static XmlBinaryNodeType PrefixDictionaryAttributeK;
    public static XmlBinaryNodeType PrefixDictionaryAttributeL;
    public static XmlBinaryNodeType PrefixDictionaryAttributeM;
    public static XmlBinaryNodeType PrefixDictionaryAttributeN;
    public static XmlBinaryNodeType PrefixDictionaryAttributeO;
    public static XmlBinaryNodeType PrefixDictionaryAttributeP;
    public static XmlBinaryNodeType PrefixDictionaryAttributeQ;
    public static XmlBinaryNodeType PrefixDictionaryAttributeR;
    public static XmlBinaryNodeType PrefixDictionaryAttributeS;
    public static XmlBinaryNodeType PrefixDictionaryAttributeT;
    public static XmlBinaryNodeType PrefixDictionaryAttributeU;
    public static XmlBinaryNodeType PrefixDictionaryAttributeV;
    public static XmlBinaryNodeType PrefixDictionaryAttributeW;
    public static XmlBinaryNodeType PrefixDictionaryAttributeX;
    public static XmlBinaryNodeType PrefixDictionaryAttributeY;
    public static XmlBinaryNodeType PrefixDictionaryAttributeZ;
    public static XmlBinaryNodeType PrefixAttributeA;
    public static XmlBinaryNodeType PrefixAttributeB;
    public static XmlBinaryNodeType PrefixAttributeC;
    public static XmlBinaryNodeType PrefixAttributeD;
    public static XmlBinaryNodeType PrefixAttributeE;
    public static XmlBinaryNodeType PrefixAttributeF;
    public static XmlBinaryNodeType PrefixAttributeG;
    public static XmlBinaryNodeType PrefixAttributeH;
    public static XmlBinaryNodeType PrefixAttributeI;
    public static XmlBinaryNodeType PrefixAttributeJ;
    public static XmlBinaryNodeType PrefixAttributeK;
    public static XmlBinaryNodeType PrefixAttributeL;
    public static XmlBinaryNodeType PrefixAttributeM;
    public static XmlBinaryNodeType PrefixAttributeN;
    public static XmlBinaryNodeType PrefixAttributeO;
    public static XmlBinaryNodeType PrefixAttributeP;
    public static XmlBinaryNodeType PrefixAttributeQ;
    public static XmlBinaryNodeType PrefixAttributeR;
    public static XmlBinaryNodeType PrefixAttributeS;
    public static XmlBinaryNodeType PrefixAttributeT;
    public static XmlBinaryNodeType PrefixAttributeU;
    public static XmlBinaryNodeType PrefixAttributeV;
    public static XmlBinaryNodeType PrefixAttributeW;
    public static XmlBinaryNodeType PrefixAttributeX;
    public static XmlBinaryNodeType PrefixAttributeY;
    public static XmlBinaryNodeType PrefixAttributeZ;
    public static XmlBinaryNodeType MaxAttribute;
    public static XmlBinaryNodeType MinElement;
    public static XmlBinaryNodeType ShortElement;
    public static XmlBinaryNodeType Element;
    public static XmlBinaryNodeType ShortDictionaryElement;
    public static XmlBinaryNodeType DictionaryElement;
    public static XmlBinaryNodeType PrefixDictionaryElementA;
    public static XmlBinaryNodeType PrefixDictionaryElementB;
    public static XmlBinaryNodeType PrefixDictionaryElementC;
    public static XmlBinaryNodeType PrefixDictionaryElementD;
    public static XmlBinaryNodeType PrefixDictionaryElementE;
    public static XmlBinaryNodeType PrefixDictionaryElementF;
    public static XmlBinaryNodeType PrefixDictionaryElementG;
    public static XmlBinaryNodeType PrefixDictionaryElementH;
    public static XmlBinaryNodeType PrefixDictionaryElementI;
    public static XmlBinaryNodeType PrefixDictionaryElementJ;
    public static XmlBinaryNodeType PrefixDictionaryElementK;
    public static XmlBinaryNodeType PrefixDictionaryElementL;
    public static XmlBinaryNodeType PrefixDictionaryElementM;
    public static XmlBinaryNodeType PrefixDictionaryElementN;
    public static XmlBinaryNodeType PrefixDictionaryElementO;
    public static XmlBinaryNodeType PrefixDictionaryElementP;
    public static XmlBinaryNodeType PrefixDictionaryElementQ;
    public static XmlBinaryNodeType PrefixDictionaryElementR;
    public static XmlBinaryNodeType PrefixDictionaryElementS;
    public static XmlBinaryNodeType PrefixDictionaryElementT;
    public static XmlBinaryNodeType PrefixDictionaryElementU;
    public static XmlBinaryNodeType PrefixDictionaryElementV;
    public static XmlBinaryNodeType PrefixDictionaryElementW;
    public static XmlBinaryNodeType PrefixDictionaryElementX;
    public static XmlBinaryNodeType PrefixDictionaryElementY;
    public static XmlBinaryNodeType PrefixDictionaryElementZ;
    public static XmlBinaryNodeType PrefixElementA;
    public static XmlBinaryNodeType PrefixElementB;
    public static XmlBinaryNodeType PrefixElementC;
    public static XmlBinaryNodeType PrefixElementD;
    public static XmlBinaryNodeType PrefixElementE;
    public static XmlBinaryNodeType PrefixElementF;
    public static XmlBinaryNodeType PrefixElementG;
    public static XmlBinaryNodeType PrefixElementH;
    public static XmlBinaryNodeType PrefixElementI;
    public static XmlBinaryNodeType PrefixElementJ;
    public static XmlBinaryNodeType PrefixElementK;
    public static XmlBinaryNodeType PrefixElementL;
    public static XmlBinaryNodeType PrefixElementM;
    public static XmlBinaryNodeType PrefixElementN;
    public static XmlBinaryNodeType PrefixElementO;
    public static XmlBinaryNodeType PrefixElementP;
    public static XmlBinaryNodeType PrefixElementQ;
    public static XmlBinaryNodeType PrefixElementR;
    public static XmlBinaryNodeType PrefixElementS;
    public static XmlBinaryNodeType PrefixElementT;
    public static XmlBinaryNodeType PrefixElementU;
    public static XmlBinaryNodeType PrefixElementV;
    public static XmlBinaryNodeType PrefixElementW;
    public static XmlBinaryNodeType PrefixElementX;
    public static XmlBinaryNodeType PrefixElementY;
    public static XmlBinaryNodeType PrefixElementZ;
    public static XmlBinaryNodeType MaxElement;
    public static XmlBinaryNodeType MinText;
    public static XmlBinaryNodeType ZeroText;
    public static XmlBinaryNodeType OneText;
    public static XmlBinaryNodeType FalseText;
    public static XmlBinaryNodeType TrueText;
    public static XmlBinaryNodeType Int8Text;
    public static XmlBinaryNodeType Int16Text;
    public static XmlBinaryNodeType Int32Text;
    public static XmlBinaryNodeType Int64Text;
    public static XmlBinaryNodeType FloatText;
    public static XmlBinaryNodeType DoubleText;
    public static XmlBinaryNodeType DecimalText;
    public static XmlBinaryNodeType DateTimeText;
    public static XmlBinaryNodeType Chars8Text;
    public static XmlBinaryNodeType Chars16Text;
    public static XmlBinaryNodeType Chars32Text;
    public static XmlBinaryNodeType Bytes8Text;
    public static XmlBinaryNodeType Bytes16Text;
    public static XmlBinaryNodeType Bytes32Text;
    public static XmlBinaryNodeType StartListText;
    public static XmlBinaryNodeType EndListText;
    public static XmlBinaryNodeType EmptyText;
    public static XmlBinaryNodeType DictionaryText;
    public static XmlBinaryNodeType UniqueIdText;
    public static XmlBinaryNodeType TimeSpanText;
    public static XmlBinaryNodeType GuidText;
    public static XmlBinaryNodeType UInt64Text;
    public static XmlBinaryNodeType BoolText;
    public static XmlBinaryNodeType UnicodeChars8Text;
    public static XmlBinaryNodeType UnicodeChars16Text;
    public static XmlBinaryNodeType UnicodeChars32Text;
    public static XmlBinaryNodeType QNameDictionaryText;
    public static XmlBinaryNodeType ZeroTextWithEndElement;
    public static XmlBinaryNodeType OneTextWithEndElement;
    public static XmlBinaryNodeType FalseTextWithEndElement;
    public static XmlBinaryNodeType TrueTextWithEndElement;
    public static XmlBinaryNodeType Int8TextWithEndElement;
    public static XmlBinaryNodeType Int16TextWithEndElement;
    public static XmlBinaryNodeType Int32TextWithEndElement;
    public static XmlBinaryNodeType Int64TextWithEndElement;
    public static XmlBinaryNodeType FloatTextWithEndElement;
    public static XmlBinaryNodeType DoubleTextWithEndElement;
    public static XmlBinaryNodeType DecimalTextWithEndElement;
    public static XmlBinaryNodeType DateTimeTextWithEndElement;
    public static XmlBinaryNodeType Chars8TextWithEndElement;
    public static XmlBinaryNodeType Chars16TextWithEndElement;
    public static XmlBinaryNodeType Chars32TextWithEndElement;
    public static XmlBinaryNodeType Bytes8TextWithEndElement;
    public static XmlBinaryNodeType Bytes16TextWithEndElement;
    public static XmlBinaryNodeType Bytes32TextWithEndElement;
    public static XmlBinaryNodeType StartListTextWithEndElement;
    public static XmlBinaryNodeType EndListTextWithEndElement;
    public static XmlBinaryNodeType EmptyTextWithEndElement;
    public static XmlBinaryNodeType DictionaryTextWithEndElement;
    public static XmlBinaryNodeType UniqueIdTextWithEndElement;
    public static XmlBinaryNodeType TimeSpanTextWithEndElement;
    public static XmlBinaryNodeType GuidTextWithEndElement;
    public static XmlBinaryNodeType UInt64TextWithEndElement;
    public static XmlBinaryNodeType BoolTextWithEndElement;
    public static XmlBinaryNodeType UnicodeChars8TextWithEndElement;
    public static XmlBinaryNodeType UnicodeChars16TextWithEndElement;
    public static XmlBinaryNodeType UnicodeChars32TextWithEndElement;
    public static XmlBinaryNodeType QNameDictionaryTextWithEndElement;
    public static XmlBinaryNodeType MaxText;
}
internal class System.Xml.XmlBinaryNodeWriter : XmlStreamNodeWriter {
    private IXmlDictionary dictionary;
    private XmlBinaryWriterSession session;
    private bool inAttribute;
    private bool inList;
    private bool wroteAttributeValue;
    private AttributeValue attributeValue;
    private static int maxBytesPerChar;
    private int textNodeOffset;
    public void SetOutput(Stream stream, IXmlDictionary dictionary, XmlBinaryWriterSession session, bool ownsStream);
    private void WriteNode(XmlBinaryNodeType nodeType);
    private void WroteAttributeValue();
    private void WriteTextNode(XmlBinaryNodeType nodeType);
    private Byte[] GetTextNodeBuffer(int size, Int32& offset);
    private void WriteTextNodeWithLength(XmlBinaryNodeType nodeType, int length);
    private void WriteTextNodeWithInt64(XmlBinaryNodeType nodeType, long value);
    public virtual void WriteDeclaration();
    public virtual void WriteStartElement(string prefix, string localName);
    private void WritePrefixNode(XmlBinaryNodeType nodeType, int ch);
    public virtual void WriteStartElement(string prefix, XmlDictionaryString localName);
    public virtual void WriteEndStartElement(bool isEmpty);
    public virtual void WriteEndElement(string prefix, string localName);
    private void WriteEndElement();
    public virtual void WriteStartAttribute(string prefix, string localName);
    public virtual void WriteStartAttribute(string prefix, XmlDictionaryString localName);
    public virtual void WriteEndAttribute();
    public virtual void WriteXmlnsAttribute(string prefix, string ns);
    public virtual void WriteXmlnsAttribute(string prefix, XmlDictionaryString ns);
    private bool TryGetKey(XmlDictionaryString s, Int32& key);
    private void WriteDictionaryString(XmlDictionaryString s, int key);
    [SecuritySafeCriticalAttribute]
private void WriteName(string s);
    [SecurityCriticalAttribute]
private void UnsafeWriteName(Char* chars, int charCount);
    private void WriteMultiByteInt32(int i);
    public virtual void WriteComment(string value);
    public virtual void WriteCData(string value);
    private void WriteEmptyText();
    public virtual void WriteBoolText(bool value);
    public virtual void WriteInt32Text(int value);
    public virtual void WriteInt64Text(long value);
    public virtual void WriteUInt64Text(ulong value);
    private void WriteInt64(long value);
    public virtual void WriteBase64Text(Byte[] trailBytes, int trailByteCount, Byte[] base64Buffer, int base64Offset, int base64Count);
    public virtual void WriteText(XmlDictionaryString value);
    [SecuritySafeCriticalAttribute]
public virtual void WriteText(string value);
    [SecuritySafeCriticalAttribute]
public virtual void WriteText(Char[] chars, int offset, int count);
    public virtual void WriteText(Byte[] chars, int charOffset, int charCount);
    [SecurityCriticalAttribute]
private void UnsafeWriteText(Char* chars, int charCount);
    public virtual void WriteEscapedText(string value);
    public virtual void WriteEscapedText(XmlDictionaryString value);
    public virtual void WriteEscapedText(Char[] chars, int offset, int count);
    public virtual void WriteEscapedText(Byte[] chars, int offset, int count);
    public virtual void WriteCharEntity(int ch);
    [SecuritySafeCriticalAttribute]
public virtual void WriteFloatText(float f);
    [SecuritySafeCriticalAttribute]
public virtual void WriteDoubleText(double d);
    [SecuritySafeCriticalAttribute]
public virtual void WriteDecimalText(decimal d);
    public virtual void WriteDateTimeText(DateTime dt);
    public virtual void WriteUniqueIdText(UniqueId value);
    public virtual void WriteGuidText(Guid guid);
    public virtual void WriteTimeSpanText(TimeSpan value);
    public virtual void WriteStartListText();
    public virtual void WriteListSeparator();
    public virtual void WriteEndListText();
    public void WriteArrayNode();
    private void WriteArrayInfo(XmlBinaryNodeType nodeType, int count);
    [SecurityCriticalAttribute]
public void UnsafeWriteArray(XmlBinaryNodeType nodeType, int count, Byte* array, Byte* arrayMax);
    [SecurityCriticalAttribute]
private void UnsafeWriteArray(Byte* array, int byteCount);
    public void WriteDateTimeArray(DateTime[] array, int offset, int count);
    public void WriteGuidArray(Guid[] array, int offset, int count);
    public void WriteTimeSpanArray(TimeSpan[] array, int offset, int count);
    public virtual void WriteQualifiedName(string prefix, XmlDictionaryString localName);
    protected virtual void FlushBuffer();
    public virtual void Close();
}
internal class System.Xml.XmlBinaryReader : XmlBaseReader {
    private bool isTextWithEndElement;
    private bool buffered;
    private ArrayState arrayState;
    private int arrayCount;
    private int maxBytesPerRead;
    private XmlBinaryNodeType arrayNodeType;
    private OnXmlDictionaryReaderClose onClose;
    public sealed virtual void SetInput(Byte[] buffer, int offset, int count, IXmlDictionary dictionary, XmlDictionaryReaderQuotas quotas, XmlBinaryReaderSession session, OnXmlDictionaryReaderClose onClose);
    public sealed virtual void SetInput(Stream stream, IXmlDictionary dictionary, XmlDictionaryReaderQuotas quotas, XmlBinaryReaderSession session, OnXmlDictionaryReaderClose onClose);
    private void MoveToInitial(XmlDictionaryReaderQuotas quotas, XmlBinaryReaderSession session, OnXmlDictionaryReaderClose onClose);
    public virtual void Close();
    public virtual string ReadElementContentAsString();
    public virtual bool ReadElementContentAsBoolean();
    public virtual int ReadElementContentAsInt();
    private bool CanOptimizeReadElementContent();
    public virtual float ReadElementContentAsFloat();
    public virtual double ReadElementContentAsDouble();
    public virtual decimal ReadElementContentAsDecimal();
    public virtual DateTime ReadElementContentAsDateTime();
    public virtual TimeSpan ReadElementContentAsTimeSpan();
    public virtual Guid ReadElementContentAsGuid();
    public virtual UniqueId ReadElementContentAsUniqueId();
    public virtual bool TryGetBase64ContentLength(Int32& length);
    private void ReadTextWithEndElement();
    private XmlAtomicTextNode MoveToAtomicTextWithEndElement();
    public virtual bool Read();
    private bool ReadNode();
    private void VerifyWhitespace();
    private void ReadAttributes();
    private void ReadAttributes2();
    private void ReadText(XmlTextNode textNode, ValueHandleType type, int length);
    private void ReadBinaryText(XmlTextNode textNode, int length);
    private void ReadPartialUTF8Text(bool withEndElement, int length);
    private void ReadUnicodeText(bool withEndElement, int length);
    private void ReadPartialUnicodeText(bool withEndElement, int length);
    private void ReadPartialBinaryText(bool withEndElement, int length);
    private void InsertNode(XmlBinaryNodeType nodeType, int length);
    private void ReadAttributeText(XmlAttributeTextNode textNode);
    private void ReadName(ValueHandle value);
    private void ReadName(StringHandle handle);
    private void ReadName(PrefixHandle prefix);
    private void ReadDictionaryName(StringHandle s);
    private XmlBinaryNodeType GetNodeType();
    private void SkipNodeType();
    private int ReadDictionaryKey();
    private int ReadMultiByteUInt31();
    private int ReadUInt8();
    private int ReadUInt16();
    private int ReadUInt31();
    private bool IsValidArrayType(XmlBinaryNodeType nodeType);
    private void ReadArray();
    private void MoveToArrayElement();
    private void SkipArrayElements(int count);
    public virtual bool IsStartArray(Type& type);
    public virtual bool TryGetArrayLength(Int32& count);
    private bool IsStartArray(string localName, string namespaceUri, XmlBinaryNodeType nodeType);
    private bool IsStartArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri, XmlBinaryNodeType nodeType);
    private void CheckArray(Array array, int offset, int count);
    [SecuritySafeCriticalAttribute]
private int ReadArray(Boolean[] array, int offset, int count);
    public virtual int ReadArray(string localName, string namespaceUri, Boolean[] array, int offset, int count);
    public virtual int ReadArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri, Boolean[] array, int offset, int count);
    [SecuritySafeCriticalAttribute]
private int ReadArray(Int16[] array, int offset, int count);
    public virtual int ReadArray(string localName, string namespaceUri, Int16[] array, int offset, int count);
    public virtual int ReadArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri, Int16[] array, int offset, int count);
    [SecuritySafeCriticalAttribute]
private int ReadArray(Int32[] array, int offset, int count);
    public virtual int ReadArray(string localName, string namespaceUri, Int32[] array, int offset, int count);
    public virtual int ReadArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri, Int32[] array, int offset, int count);
    [SecuritySafeCriticalAttribute]
private int ReadArray(Int64[] array, int offset, int count);
    public virtual int ReadArray(string localName, string namespaceUri, Int64[] array, int offset, int count);
    public virtual int ReadArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri, Int64[] array, int offset, int count);
    [SecuritySafeCriticalAttribute]
private int ReadArray(Single[] array, int offset, int count);
    public virtual int ReadArray(string localName, string namespaceUri, Single[] array, int offset, int count);
    public virtual int ReadArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri, Single[] array, int offset, int count);
    [SecuritySafeCriticalAttribute]
private int ReadArray(Double[] array, int offset, int count);
    public virtual int ReadArray(string localName, string namespaceUri, Double[] array, int offset, int count);
    public virtual int ReadArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri, Double[] array, int offset, int count);
    [SecuritySafeCriticalAttribute]
private int ReadArray(Decimal[] array, int offset, int count);
    public virtual int ReadArray(string localName, string namespaceUri, Decimal[] array, int offset, int count);
    public virtual int ReadArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri, Decimal[] array, int offset, int count);
    private int ReadArray(DateTime[] array, int offset, int count);
    public virtual int ReadArray(string localName, string namespaceUri, DateTime[] array, int offset, int count);
    public virtual int ReadArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri, DateTime[] array, int offset, int count);
    private int ReadArray(Guid[] array, int offset, int count);
    public virtual int ReadArray(string localName, string namespaceUri, Guid[] array, int offset, int count);
    public virtual int ReadArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri, Guid[] array, int offset, int count);
    private int ReadArray(TimeSpan[] array, int offset, int count);
    public virtual int ReadArray(string localName, string namespaceUri, TimeSpan[] array, int offset, int count);
    public virtual int ReadArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri, TimeSpan[] array, int offset, int count);
    protected virtual XmlSigningNodeWriter CreateSigningNodeWriter();
}
public class System.Xml.XmlBinaryReaderSession : object {
    private static int MaxArrayEntries;
    private XmlDictionaryString[] strings;
    private Dictionary`2<int, XmlDictionaryString> stringDict;
    public XmlDictionaryString Add(int id, string value);
    public sealed virtual bool TryLookup(int key, XmlDictionaryString& result);
    public sealed virtual bool TryLookup(string value, XmlDictionaryString& result);
    public sealed virtual bool TryLookup(XmlDictionaryString value, XmlDictionaryString& result);
    public void Clear();
}
internal class System.Xml.XmlBinaryWriter : XmlBaseWriter {
    private XmlBinaryNodeWriter writer;
    private Char[] chars;
    private Byte[] bytes;
    public sealed virtual void SetOutput(Stream stream, IXmlDictionary dictionary, XmlBinaryWriterSession session, bool ownsStream);
    protected virtual XmlSigningNodeWriter CreateSigningNodeWriter();
    protected virtual void WriteTextNode(XmlDictionaryReader reader, bool attribute);
    private void WriteStartArray(string prefix, string localName, string namespaceUri, int count);
    private void WriteStartArray(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, int count);
    private void WriteEndArray();
    [SecurityCriticalAttribute]
private void UnsafeWriteArray(string prefix, string localName, string namespaceUri, XmlBinaryNodeType nodeType, int count, Byte* array, Byte* arrayMax);
    [SecurityCriticalAttribute]
private void UnsafeWriteArray(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, XmlBinaryNodeType nodeType, int count, Byte* array, Byte* arrayMax);
    private void CheckArray(Array array, int offset, int count);
    [SecuritySafeCriticalAttribute]
public virtual void WriteArray(string prefix, string localName, string namespaceUri, Boolean[] array, int offset, int count);
    [SecuritySafeCriticalAttribute]
public virtual void WriteArray(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Boolean[] array, int offset, int count);
    [SecuritySafeCriticalAttribute]
public virtual void WriteArray(string prefix, string localName, string namespaceUri, Int16[] array, int offset, int count);
    [SecuritySafeCriticalAttribute]
public virtual void WriteArray(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Int16[] array, int offset, int count);
    [SecuritySafeCriticalAttribute]
public virtual void WriteArray(string prefix, string localName, string namespaceUri, Int32[] array, int offset, int count);
    [SecuritySafeCriticalAttribute]
public virtual void WriteArray(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Int32[] array, int offset, int count);
    [SecuritySafeCriticalAttribute]
public virtual void WriteArray(string prefix, string localName, string namespaceUri, Int64[] array, int offset, int count);
    [SecuritySafeCriticalAttribute]
public virtual void WriteArray(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Int64[] array, int offset, int count);
    [SecuritySafeCriticalAttribute]
public virtual void WriteArray(string prefix, string localName, string namespaceUri, Single[] array, int offset, int count);
    [SecuritySafeCriticalAttribute]
public virtual void WriteArray(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Single[] array, int offset, int count);
    [SecuritySafeCriticalAttribute]
public virtual void WriteArray(string prefix, string localName, string namespaceUri, Double[] array, int offset, int count);
    [SecuritySafeCriticalAttribute]
public virtual void WriteArray(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Double[] array, int offset, int count);
    [SecuritySafeCriticalAttribute]
public virtual void WriteArray(string prefix, string localName, string namespaceUri, Decimal[] array, int offset, int count);
    [SecuritySafeCriticalAttribute]
public virtual void WriteArray(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Decimal[] array, int offset, int count);
    public virtual void WriteArray(string prefix, string localName, string namespaceUri, DateTime[] array, int offset, int count);
    public virtual void WriteArray(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, DateTime[] array, int offset, int count);
    public virtual void WriteArray(string prefix, string localName, string namespaceUri, Guid[] array, int offset, int count);
    public virtual void WriteArray(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Guid[] array, int offset, int count);
    public virtual void WriteArray(string prefix, string localName, string namespaceUri, TimeSpan[] array, int offset, int count);
    public virtual void WriteArray(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, TimeSpan[] array, int offset, int count);
}
public class System.Xml.XmlBinaryWriterSession : object {
    private PriorityDictionary`2<string, int> strings;
    private PriorityDictionary`2<IXmlDictionary, IntArray> maps;
    private int nextKey;
    public virtual bool TryAdd(XmlDictionaryString value, Int32& key);
    private int Add(string s);
    private IntArray AddKeys(IXmlDictionary dictionary, int minCount);
    public void Reset();
    internal bool TryLookup(XmlDictionaryString s, Int32& key);
}
internal class System.Xml.XmlBufferReader : object {
    private XmlDictionaryReader reader;
    private Stream stream;
    private Byte[] streamBuffer;
    private Byte[] buffer;
    private int offsetMin;
    private int offsetMax;
    private IXmlDictionary dictionary;
    private XmlBinaryReaderSession session;
    private Byte[] guid;
    private int offset;
    private static int maxBytesPerChar;
    private Char[] chars;
    private int windowOffset;
    private int windowOffsetMax;
    private ValueHandle listValue;
    private static Byte[] emptyByteArray;
    private static XmlBufferReader empty;
    public static XmlBufferReader Empty { get; }
    public Byte[] Buffer { get; }
    public bool IsStreamed { get; }
    public bool EndOfFile { get; }
    public int Offset { get; public set; }
    public XmlBufferReader(XmlDictionaryReader reader);
    public XmlBufferReader(Byte[] buffer);
    private static XmlBufferReader();
    public static XmlBufferReader get_Empty();
    public Byte[] get_Buffer();
    public bool get_IsStreamed();
    public void SetBuffer(Stream stream, IXmlDictionary dictionary, XmlBinaryReaderSession session);
    public void SetBuffer(Byte[] buffer, int offset, int count, IXmlDictionary dictionary, XmlBinaryReaderSession session);
    private void SetBuffer(Stream stream, Byte[] buffer, int offset, int count, IXmlDictionary dictionary, XmlBinaryReaderSession session);
    public void Close();
    public bool get_EndOfFile();
    public byte GetByte();
    public void SkipByte();
    private byte GetByteHard();
    public Byte[] GetBuffer(int count, Int32& offset);
    public Byte[] GetBuffer(int count, Int32& offset, Int32& offsetMax);
    public Byte[] GetBuffer(Int32& offset, Int32& offsetMax);
    private Byte[] GetBufferHard(int count, Int32& offset);
    private void EnsureByte();
    private bool TryEnsureByte();
    private void EnsureBytes(int count);
    private bool TryEnsureBytes(int count);
    public void Advance(int count);
    public void InsertBytes(Byte[] buffer, int offset, int count);
    public void SetWindow(int windowOffset, int windowLength);
    public int get_Offset();
    public void set_Offset(int value);
    public int ReadBytes(int count);
    public int ReadMultiByteUInt31();
    public int ReadUInt8();
    public int ReadInt8();
    public int ReadUInt16();
    public int ReadInt16();
    public int ReadInt32();
    public int ReadUInt31();
    public long ReadInt64();
    [SecuritySafeCriticalAttribute]
public float ReadSingle();
    [SecuritySafeCriticalAttribute]
public double ReadDouble();
    [SecuritySafeCriticalAttribute]
public decimal ReadDecimal();
    public UniqueId ReadUniqueId();
    public DateTime ReadDateTime();
    public TimeSpan ReadTimeSpan();
    public Guid ReadGuid();
    public string ReadUTF8String(int length);
    [SecurityCriticalAttribute]
public void UnsafeReadArray(Byte* dst, Byte* dstMax);
    [SecurityCriticalAttribute]
private void UnsafeReadArray(Byte* dst, int length);
    private Char[] GetCharBuffer(int count);
    private int GetChars(int offset, int length, Char[] chars);
    private int GetChars(int offset, int length, Char[] chars, int charOffset);
    public string GetString(int offset, int length);
    public string GetUnicodeString(int offset, int length);
    public string GetString(int offset, int length, XmlNameTable nameTable);
    public int GetEscapedChars(int offset, int length, Char[] chars);
    private bool IsAttrChar(int ch);
    public string GetEscapedString(int offset, int length);
    public string GetEscapedString(int offset, int length, XmlNameTable nameTable);
    private int GetLessThanCharEntity(int offset, int length);
    private int GetGreaterThanCharEntity(int offset, int length);
    private int GetQuoteCharEntity(int offset, int length);
    private int GetAmpersandCharEntity(int offset, int length);
    private int GetApostropheCharEntity(int offset, int length);
    private int GetDecimalCharEntity(int offset, int length);
    private int GetHexCharEntity(int offset, int length);
    public int GetCharEntity(int offset, int length);
    public bool IsWhitespaceKey(int key);
    public bool IsWhitespaceUTF8(int offset, int length);
    public bool IsWhitespaceUnicode(int offset, int length);
    public bool Equals2(int key1, int key2, XmlBufferReader bufferReader2);
    public bool Equals2(int key1, XmlDictionaryString xmlString2);
    public bool Equals2(int offset1, int length1, Byte[] buffer2);
    public bool Equals2(int offset1, int length1, XmlBufferReader bufferReader2, int offset2, int length2);
    public bool Equals2(int offset1, int length1, int offset2, int length2);
    [SecuritySafeCriticalAttribute]
public bool Equals2(int offset1, int length1, string s2);
    public int Compare(int offset1, int length1, int offset2, int length2);
    public byte GetByte(int offset);
    public int GetInt8(int offset);
    public int GetInt16(int offset);
    public int GetInt32(int offset);
    public long GetInt64(int offset);
    public ulong GetUInt64(int offset);
    [SecuritySafeCriticalAttribute]
public float GetSingle(int offset);
    [SecuritySafeCriticalAttribute]
public double GetDouble(int offset);
    [SecuritySafeCriticalAttribute]
public decimal GetDecimal(int offset);
    public UniqueId GetUniqueId(int offset);
    public Guid GetGuid(int offset);
    public void GetBase64(int srcOffset, Byte[] buffer, int dstOffset, int count);
    public XmlBinaryNodeType GetNodeType();
    public void SkipNodeType();
    public Object[] GetList(int offset, int count);
    public XmlDictionaryString GetDictionaryString(int key);
    public int ReadDictionaryKey();
    public void ReadValue(XmlBinaryNodeType nodeType, ValueHandle value);
    private void ReadValue(ValueHandle value, ValueHandleType type, int length);
    private void ReadUnicodeValue(ValueHandle value, int length);
    private void ReadList(ValueHandle value);
    public void ReadQName(ValueHandle value);
    public Int32[] GetRows();
}
internal class System.Xml.XmlCanonicalWriter : object {
    private XmlUTF8NodeWriter writer;
    private MemoryStream elementStream;
    private Byte[] elementBuffer;
    private XmlUTF8NodeWriter elementWriter;
    private bool inStartElement;
    private int depth;
    private Scope[] scopes;
    private int xmlnsAttributeCount;
    private XmlnsAttribute[] xmlnsAttributes;
    private int attributeCount;
    private Attribute[] attributes;
    private Attribute attribute;
    private Element element;
    private Byte[] xmlnsBuffer;
    private int xmlnsOffset;
    private static int maxBytesPerChar;
    private int xmlnsStartOffset;
    private bool includeComments;
    private String[] inclusivePrefixes;
    private static string xmlnsNamespace;
    private static Boolean[] isEscapedAttributeChar;
    private static Boolean[] isEscapedElementChar;
    private static XmlCanonicalWriter();
    public void SetOutput(Stream stream, bool includeComments, String[] inclusivePrefixes);
    public void Flush();
    public void Close();
    public void WriteDeclaration();
    public void WriteComment(string value);
    private void StartElement();
    private void EndElement();
    public void WriteStartElement(string prefix, string localName);
    public void WriteStartElement(Byte[] prefixBuffer, int prefixOffset, int prefixLength, Byte[] localNameBuffer, int localNameOffset, int localNameLength);
    private bool IsInclusivePrefix(XmlnsAttribute& xmlnsAttribute);
    public void WriteEndStartElement(bool isEmpty);
    public void WriteEndElement(string prefix, string localName);
    private void EnsureXmlnsBuffer(int byteCount);
    public void WriteXmlnsAttribute(string prefix, string ns);
    public void WriteXmlnsAttribute(Byte[] prefixBuffer, int prefixOffset, int prefixLength, Byte[] nsBuffer, int nsOffset, int nsLength);
    public void WriteStartAttribute(string prefix, string localName);
    public void WriteStartAttribute(Byte[] prefixBuffer, int prefixOffset, int prefixLength, Byte[] localNameBuffer, int localNameOffset, int localNameLength);
    public void WriteEndAttribute();
    public void WriteCharEntity(int ch);
    public void WriteEscapedText(string value);
    public void WriteEscapedText(Byte[] chars, int offset, int count);
    public void WriteEscapedText(Char[] chars, int offset, int count);
    public void WriteText(int ch);
    public void WriteText(Byte[] chars, int offset, int count);
    public void WriteText(string value);
    public void WriteText(Char[] chars, int offset, int count);
    private void ThrowIfClosed();
    private void ThrowClosed();
    private void WriteXmlnsAttribute(XmlnsAttribute& xmlnsAttribute);
    private void SortAttributes();
    private void AddAttribute(Attribute& attribute);
    private void AddXmlnsAttribute(XmlnsAttribute& xmlnsAttribute);
    private void ResolvePrefix(int prefixOffset, int prefixLength, Int32& nsOffset, Int32& nsLength);
    private void ResolvePrefix(Attribute& attribute);
    private void ResolvePrefixes();
    private int Compare(XmlnsAttribute& xmlnsAttribute1, XmlnsAttribute& xmlnsAttribute2);
    private int Compare(Attribute& attribute1, Attribute& attribute2);
    private int Compare(Byte[] buffer, int offset1, int length1, int offset2, int length2);
    private int Compare(Byte[] buffer1, int offset1, int length1, Byte[] buffer2, int offset2, int length2);
    private bool Equals(Byte[] buffer1, int offset1, int length1, Byte[] buffer2, int offset2, int length2);
}
internal static class System.Xml.XmlConverter : object {
    public static int MaxDateTimeChars;
    public static int MaxInt32Chars;
    public static int MaxInt64Chars;
    public static int MaxBoolChars;
    public static int MaxFloatChars;
    public static int MaxDoubleChars;
    public static int MaxDecimalChars;
    public static int MaxUInt64Chars;
    public static int MaxPrimitiveChars;
    private static Char[] whiteSpaceChars;
    private static UTF8Encoding utf8Encoding;
    private static UnicodeEncoding unicodeEncoding;
    private static Base64Encoding base64Encoding;
    public static Base64Encoding Base64Encoding { get; }
    private static UTF8Encoding UTF8Encoding { get; }
    private static UnicodeEncoding UnicodeEncoding { get; }
    private static XmlConverter();
    public static Base64Encoding get_Base64Encoding();
    private static UTF8Encoding get_UTF8Encoding();
    private static UnicodeEncoding get_UnicodeEncoding();
    public static bool ToBoolean(string value);
    public static bool ToBoolean(Byte[] buffer, int offset, int count);
    public static int ToInt32(string value);
    public static int ToInt32(Byte[] buffer, int offset, int count);
    public static long ToInt64(string value);
    public static long ToInt64(Byte[] buffer, int offset, int count);
    public static float ToSingle(string value);
    public static float ToSingle(Byte[] buffer, int offset, int count);
    public static double ToDouble(string value);
    public static double ToDouble(Byte[] buffer, int offset, int count);
    public static decimal ToDecimal(string value);
    public static decimal ToDecimal(Byte[] buffer, int offset, int count);
    public static DateTime ToDateTime(long value);
    public static DateTime ToDateTime(string value);
    public static DateTime ToDateTime(Byte[] buffer, int offset, int count);
    public static UniqueId ToUniqueId(string value);
    public static UniqueId ToUniqueId(Byte[] buffer, int offset, int count);
    public static TimeSpan ToTimeSpan(string value);
    public static TimeSpan ToTimeSpan(Byte[] buffer, int offset, int count);
    public static Guid ToGuid(string value);
    public static Guid ToGuid(Byte[] buffer, int offset, int count);
    public static ulong ToUInt64(string value);
    public static ulong ToUInt64(Byte[] buffer, int offset, int count);
    public static string ToString(Byte[] buffer, int offset, int count);
    public static string ToStringUnicode(Byte[] buffer, int offset, int count);
    public static Byte[] ToBytes(string value);
    public static int ToChars(Byte[] buffer, int offset, int count, Char[] chars, int charOffset);
    public static string ToString(bool value);
    public static string ToString(int value);
    public static string ToString(long value);
    public static string ToString(float value);
    public static string ToString(double value);
    public static string ToString(decimal value);
    public static string ToString(TimeSpan value);
    public static string ToString(UniqueId value);
    public static string ToString(Guid value);
    public static string ToString(ulong value);
    public static string ToString(DateTime value);
    private static string ToString(object value);
    public static string ToString(Object[] objects);
    public static void ToQualifiedName(string qname, String& prefix, String& localName);
    private static bool TryParseInt32(Byte[] chars, int offset, int count, Int32& result);
    private static bool TryParseInt64(Byte[] chars, int offset, int count, Int64& result);
    private static bool TryParseSingle(Byte[] chars, int offset, int count, Single& result);
    private static bool TryParseDouble(Byte[] chars, int offset, int count, Double& result);
    private static int ToInt32D2(Byte[] chars, int offset);
    private static int ToInt32D4(Byte[] chars, int offset, int count);
    private static int ToInt32D7(Byte[] chars, int offset, int count);
    private static bool TryParseDateTime(Byte[] chars, int offset, int count, DateTime& result);
    public static int ToChars(bool value, Byte[] buffer, int offset);
    public static int ToCharsR(int value, Byte[] chars, int offset);
    public static int ToChars(int value, Byte[] chars, int offset);
    public static int ToCharsR(long value, Byte[] chars, int offset);
    public static int ToChars(long value, Byte[] chars, int offset);
    [SecuritySafeCriticalAttribute]
private static bool IsNegativeZero(float value);
    [SecuritySafeCriticalAttribute]
private static bool IsNegativeZero(double value);
    private static int ToInfinity(bool isNegative, Byte[] buffer, int offset);
    private static int ToZero(bool isNegative, Byte[] buffer, int offset);
    public static int ToChars(double value, Byte[] buffer, int offset);
    public static int ToChars(float value, Byte[] buffer, int offset);
    public static int ToChars(decimal value, Byte[] buffer, int offset);
    public static int ToChars(ulong value, Byte[] buffer, int offset);
    private static int ToAsciiChars(string s, Byte[] buffer, int offset);
    private static int ToCharsD2(int value, Byte[] chars, int offset);
    private static int ToCharsD4(int value, Byte[] chars, int offset);
    private static int ToCharsD7(int value, Byte[] chars, int offset);
    public static int ToChars(DateTime value, Byte[] chars, int offset);
    public static bool IsWhitespace(string s);
    public static bool IsWhitespace(char ch);
    public static string StripWhitespace(string s);
    private static string Trim(string s);
}
public class System.Xml.XmlDictionary : object {
    private static IXmlDictionary empty;
    private Dictionary`2<string, XmlDictionaryString> lookup;
    private XmlDictionaryString[] strings;
    private int nextId;
    public static IXmlDictionary Empty { get; }
    public XmlDictionary(int capacity);
    public static IXmlDictionary get_Empty();
    public virtual XmlDictionaryString Add(string value);
    public virtual bool TryLookup(string value, XmlDictionaryString& result);
    public virtual bool TryLookup(int key, XmlDictionaryString& result);
    public virtual bool TryLookup(XmlDictionaryString value, XmlDictionaryString& result);
}
public abstract class System.Xml.XmlDictionaryReader : XmlReader {
    internal static int MaxInitialArrayLength;
    public bool CanCanonicalize { get; }
    public XmlDictionaryReaderQuotas Quotas { get; }
    public static XmlDictionaryReader CreateDictionaryReader(XmlReader reader);
    public static XmlDictionaryReader CreateBinaryReader(Byte[] buffer, XmlDictionaryReaderQuotas quotas);
    public static XmlDictionaryReader CreateBinaryReader(Byte[] buffer, int offset, int count, XmlDictionaryReaderQuotas quotas);
    public static XmlDictionaryReader CreateBinaryReader(Byte[] buffer, int offset, int count, IXmlDictionary dictionary, XmlDictionaryReaderQuotas quotas);
    public static XmlDictionaryReader CreateBinaryReader(Byte[] buffer, int offset, int count, IXmlDictionary dictionary, XmlDictionaryReaderQuotas quotas, XmlBinaryReaderSession session);
    public static XmlDictionaryReader CreateBinaryReader(Byte[] buffer, int offset, int count, IXmlDictionary dictionary, XmlDictionaryReaderQuotas quotas, XmlBinaryReaderSession session, OnXmlDictionaryReaderClose onClose);
    public static XmlDictionaryReader CreateBinaryReader(Stream stream, XmlDictionaryReaderQuotas quotas);
    public static XmlDictionaryReader CreateBinaryReader(Stream stream, IXmlDictionary dictionary, XmlDictionaryReaderQuotas quotas);
    public static XmlDictionaryReader CreateBinaryReader(Stream stream, IXmlDictionary dictionary, XmlDictionaryReaderQuotas quotas, XmlBinaryReaderSession session);
    public static XmlDictionaryReader CreateBinaryReader(Stream stream, IXmlDictionary dictionary, XmlDictionaryReaderQuotas quotas, XmlBinaryReaderSession session, OnXmlDictionaryReaderClose onClose);
    public static XmlDictionaryReader CreateTextReader(Byte[] buffer, XmlDictionaryReaderQuotas quotas);
    public static XmlDictionaryReader CreateTextReader(Byte[] buffer, int offset, int count, XmlDictionaryReaderQuotas quotas);
    public static XmlDictionaryReader CreateTextReader(Byte[] buffer, int offset, int count, Encoding encoding, XmlDictionaryReaderQuotas quotas, OnXmlDictionaryReaderClose onClose);
    public static XmlDictionaryReader CreateTextReader(Stream stream, XmlDictionaryReaderQuotas quotas);
    public static XmlDictionaryReader CreateTextReader(Stream stream, Encoding encoding, XmlDictionaryReaderQuotas quotas, OnXmlDictionaryReaderClose onClose);
    public static XmlDictionaryReader CreateMtomReader(Stream stream, Encoding encoding, XmlDictionaryReaderQuotas quotas);
    public static XmlDictionaryReader CreateMtomReader(Stream stream, Encoding[] encodings, XmlDictionaryReaderQuotas quotas);
    public static XmlDictionaryReader CreateMtomReader(Stream stream, Encoding[] encodings, string contentType, XmlDictionaryReaderQuotas quotas);
    public static XmlDictionaryReader CreateMtomReader(Stream stream, Encoding[] encodings, string contentType, XmlDictionaryReaderQuotas quotas, int maxBufferSize, OnXmlDictionaryReaderClose onClose);
    public static XmlDictionaryReader CreateMtomReader(Byte[] buffer, int offset, int count, Encoding encoding, XmlDictionaryReaderQuotas quotas);
    public static XmlDictionaryReader CreateMtomReader(Byte[] buffer, int offset, int count, Encoding[] encodings, XmlDictionaryReaderQuotas quotas);
    public static XmlDictionaryReader CreateMtomReader(Byte[] buffer, int offset, int count, Encoding[] encodings, string contentType, XmlDictionaryReaderQuotas quotas);
    public static XmlDictionaryReader CreateMtomReader(Byte[] buffer, int offset, int count, Encoding[] encodings, string contentType, XmlDictionaryReaderQuotas quotas, int maxBufferSize, OnXmlDictionaryReaderClose onClose);
    public virtual bool get_CanCanonicalize();
    public virtual XmlDictionaryReaderQuotas get_Quotas();
    public virtual void StartCanonicalization(Stream stream, bool includeComments, String[] inclusivePrefixes);
    public virtual void EndCanonicalization();
    public virtual void MoveToStartElement();
    public virtual void MoveToStartElement(string name);
    public virtual void MoveToStartElement(string localName, string namespaceUri);
    public virtual void MoveToStartElement(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    public virtual bool IsLocalName(string localName);
    public virtual bool IsLocalName(XmlDictionaryString localName);
    public virtual bool IsNamespaceUri(string namespaceUri);
    public virtual bool IsNamespaceUri(XmlDictionaryString namespaceUri);
    public virtual void ReadFullStartElement();
    public virtual void ReadFullStartElement(string name);
    public virtual void ReadFullStartElement(string localName, string namespaceUri);
    public virtual void ReadFullStartElement(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    public virtual void ReadStartElement(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    public virtual bool IsStartElement(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    public virtual int IndexOfLocalName(String[] localNames, string namespaceUri);
    public virtual int IndexOfLocalName(XmlDictionaryString[] localNames, XmlDictionaryString namespaceUri);
    public virtual string GetAttribute(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    public virtual bool TryGetBase64ContentLength(Int32& length);
    public virtual int ReadValueAsBase64(Byte[] buffer, int offset, int count);
    public virtual Byte[] ReadContentAsBase64();
    internal Byte[] ReadContentAsBase64(int maxByteArrayContentLength, int maxInitialCount);
    public virtual string ReadContentAsString();
    protected string ReadContentAsString(int maxStringContentLength);
    public virtual string ReadString();
    protected string ReadString(int maxStringContentLength);
    public virtual Byte[] ReadContentAsBinHex();
    protected Byte[] ReadContentAsBinHex(int maxByteArrayContentLength);
    private Byte[] ReadContentAsBytes(bool base64, int maxByteArrayContentLength);
    protected bool IsTextNode(XmlNodeType nodeType);
    public virtual int ReadContentAsChars(Char[] chars, int offset, int count);
    public virtual object ReadContentAs(Type type, IXmlNamespaceResolver namespaceResolver);
    public virtual string ReadContentAsString(String[] strings, Int32& index);
    public virtual string ReadContentAsString(XmlDictionaryString[] strings, Int32& index);
    public virtual decimal ReadContentAsDecimal();
    public virtual float ReadContentAsFloat();
    public virtual UniqueId ReadContentAsUniqueId();
    public virtual Guid ReadContentAsGuid();
    public virtual TimeSpan ReadContentAsTimeSpan();
    public virtual void ReadContentAsQualifiedName(String& localName, String& namespaceUri);
    public virtual string ReadElementContentAsString();
    public virtual bool ReadElementContentAsBoolean();
    public virtual int ReadElementContentAsInt();
    public virtual long ReadElementContentAsLong();
    public virtual float ReadElementContentAsFloat();
    public virtual double ReadElementContentAsDouble();
    public virtual decimal ReadElementContentAsDecimal();
    public virtual DateTime ReadElementContentAsDateTime();
    public virtual UniqueId ReadElementContentAsUniqueId();
    public virtual Guid ReadElementContentAsGuid();
    public virtual TimeSpan ReadElementContentAsTimeSpan();
    public virtual Byte[] ReadElementContentAsBase64();
    public virtual Byte[] ReadElementContentAsBinHex();
    public virtual void GetNonAtomizedNames(String& localName, String& namespaceUri);
    public virtual bool TryGetLocalNameAsDictionaryString(XmlDictionaryString& localName);
    public virtual bool TryGetNamespaceUriAsDictionaryString(XmlDictionaryString& namespaceUri);
    public virtual bool TryGetValueAsDictionaryString(XmlDictionaryString& value);
    private void CheckArray(Array array, int offset, int count);
    public virtual bool IsStartArray(Type& type);
    public virtual bool TryGetArrayLength(Int32& count);
    public virtual Boolean[] ReadBooleanArray(string localName, string namespaceUri);
    public virtual Boolean[] ReadBooleanArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    public virtual int ReadArray(string localName, string namespaceUri, Boolean[] array, int offset, int count);
    public virtual int ReadArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri, Boolean[] array, int offset, int count);
    public virtual Int16[] ReadInt16Array(string localName, string namespaceUri);
    public virtual Int16[] ReadInt16Array(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    public virtual int ReadArray(string localName, string namespaceUri, Int16[] array, int offset, int count);
    public virtual int ReadArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri, Int16[] array, int offset, int count);
    public virtual Int32[] ReadInt32Array(string localName, string namespaceUri);
    public virtual Int32[] ReadInt32Array(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    public virtual int ReadArray(string localName, string namespaceUri, Int32[] array, int offset, int count);
    public virtual int ReadArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri, Int32[] array, int offset, int count);
    public virtual Int64[] ReadInt64Array(string localName, string namespaceUri);
    public virtual Int64[] ReadInt64Array(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    public virtual int ReadArray(string localName, string namespaceUri, Int64[] array, int offset, int count);
    public virtual int ReadArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri, Int64[] array, int offset, int count);
    public virtual Single[] ReadSingleArray(string localName, string namespaceUri);
    public virtual Single[] ReadSingleArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    public virtual int ReadArray(string localName, string namespaceUri, Single[] array, int offset, int count);
    public virtual int ReadArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri, Single[] array, int offset, int count);
    public virtual Double[] ReadDoubleArray(string localName, string namespaceUri);
    public virtual Double[] ReadDoubleArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    public virtual int ReadArray(string localName, string namespaceUri, Double[] array, int offset, int count);
    public virtual int ReadArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri, Double[] array, int offset, int count);
    public virtual Decimal[] ReadDecimalArray(string localName, string namespaceUri);
    public virtual Decimal[] ReadDecimalArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    public virtual int ReadArray(string localName, string namespaceUri, Decimal[] array, int offset, int count);
    public virtual int ReadArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri, Decimal[] array, int offset, int count);
    public virtual DateTime[] ReadDateTimeArray(string localName, string namespaceUri);
    public virtual DateTime[] ReadDateTimeArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    public virtual int ReadArray(string localName, string namespaceUri, DateTime[] array, int offset, int count);
    public virtual int ReadArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri, DateTime[] array, int offset, int count);
    public virtual Guid[] ReadGuidArray(string localName, string namespaceUri);
    public virtual Guid[] ReadGuidArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    public virtual int ReadArray(string localName, string namespaceUri, Guid[] array, int offset, int count);
    public virtual int ReadArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri, Guid[] array, int offset, int count);
    public virtual TimeSpan[] ReadTimeSpanArray(string localName, string namespaceUri);
    public virtual TimeSpan[] ReadTimeSpanArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    public virtual int ReadArray(string localName, string namespaceUri, TimeSpan[] array, int offset, int count);
    public virtual int ReadArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri, TimeSpan[] array, int offset, int count);
}
public class System.Xml.XmlDictionaryReaderQuotas : object {
    private bool readOnly;
    private int maxStringContentLength;
    private int maxArrayLength;
    private int maxDepth;
    private int maxNameTableCharCount;
    private int maxBytesPerRead;
    private XmlDictionaryReaderQuotaTypes modifiedQuotas;
    private static int DefaultMaxDepth;
    private static int DefaultMaxStringContentLength;
    private static int DefaultMaxArrayLength;
    private static int DefaultMaxBytesPerRead;
    private static int DefaultMaxNameTableCharCount;
    private static XmlDictionaryReaderQuotas defaultQuota;
    private static XmlDictionaryReaderQuotas maxQuota;
    public static XmlDictionaryReaderQuotas Max { get; }
    [DefaultValueAttribute("8192")]
public int MaxStringContentLength { get; public set; }
    [DefaultValueAttribute("16384")]
public int MaxArrayLength { get; public set; }
    [DefaultValueAttribute("4096")]
public int MaxBytesPerRead { get; public set; }
    [DefaultValueAttribute("32")]
public int MaxDepth { get; public set; }
    [DefaultValueAttribute("16384")]
public int MaxNameTableCharCount { get; public set; }
    public XmlDictionaryReaderQuotaTypes ModifiedQuotas { get; }
    private XmlDictionaryReaderQuotas(int maxDepth, int maxStringContentLength, int maxArrayLength, int maxBytesPerRead, int maxNameTableCharCount, XmlDictionaryReaderQuotaTypes modifiedQuotas);
    private static XmlDictionaryReaderQuotas();
    public static XmlDictionaryReaderQuotas get_Max();
    public void CopyTo(XmlDictionaryReaderQuotas quotas);
    internal void InternalCopyTo(XmlDictionaryReaderQuotas quotas);
    public int get_MaxStringContentLength();
    public void set_MaxStringContentLength(int value);
    public int get_MaxArrayLength();
    public void set_MaxArrayLength(int value);
    public int get_MaxBytesPerRead();
    public void set_MaxBytesPerRead(int value);
    public int get_MaxDepth();
    public void set_MaxDepth(int value);
    public int get_MaxNameTableCharCount();
    public void set_MaxNameTableCharCount(int value);
    public XmlDictionaryReaderQuotaTypes get_ModifiedQuotas();
    internal void MakeReadOnly();
}
[FlagsAttribute]
public enum System.Xml.XmlDictionaryReaderQuotaTypes : Enum {
    public int value__;
    public static XmlDictionaryReaderQuotaTypes MaxDepth;
    public static XmlDictionaryReaderQuotaTypes MaxStringContentLength;
    public static XmlDictionaryReaderQuotaTypes MaxArrayLength;
    public static XmlDictionaryReaderQuotaTypes MaxBytesPerRead;
    public static XmlDictionaryReaderQuotaTypes MaxNameTableCharCount;
}
public class System.Xml.XmlDictionaryString : object {
    internal static int MinKey;
    internal static int MaxKey;
    private IXmlDictionary dictionary;
    private string value;
    private int key;
    private Byte[] buffer;
    private static EmptyStringDictionary emptyStringDictionary;
    public static XmlDictionaryString Empty { get; }
    public IXmlDictionary Dictionary { get; }
    public int Key { get; }
    public string Value { get; }
    public XmlDictionaryString(IXmlDictionary dictionary, string value, int key);
    private static XmlDictionaryString();
    internal static string GetString(XmlDictionaryString s);
    public static XmlDictionaryString get_Empty();
    public IXmlDictionary get_Dictionary();
    public int get_Key();
    public string get_Value();
    internal Byte[] ToUTF8();
    public virtual string ToString();
}
public abstract class System.Xml.XmlDictionaryWriter : XmlWriter {
    internal bool FastAsync { get; }
    public bool CanCanonicalize { get; }
    internal virtual bool get_FastAsync();
    internal virtual AsyncCompletionResult WriteBase64Async(AsyncEventArgs`1<XmlWriteBase64AsyncArguments> state);
    public virtual Task WriteBase64Async(Byte[] buffer, int index, int count);
    internal virtual IAsyncResult BeginWriteBase64(Byte[] buffer, int index, int count, AsyncCallback callback, object state);
    internal virtual void EndWriteBase64(IAsyncResult result);
    public static XmlDictionaryWriter CreateBinaryWriter(Stream stream);
    public static XmlDictionaryWriter CreateBinaryWriter(Stream stream, IXmlDictionary dictionary);
    public static XmlDictionaryWriter CreateBinaryWriter(Stream stream, IXmlDictionary dictionary, XmlBinaryWriterSession session);
    public static XmlDictionaryWriter CreateBinaryWriter(Stream stream, IXmlDictionary dictionary, XmlBinaryWriterSession session, bool ownsStream);
    public static XmlDictionaryWriter CreateTextWriter(Stream stream);
    public static XmlDictionaryWriter CreateTextWriter(Stream stream, Encoding encoding);
    public static XmlDictionaryWriter CreateTextWriter(Stream stream, Encoding encoding, bool ownsStream);
    public static XmlDictionaryWriter CreateMtomWriter(Stream stream, Encoding encoding, int maxSizeInBytes, string startInfo);
    public static XmlDictionaryWriter CreateMtomWriter(Stream stream, Encoding encoding, int maxSizeInBytes, string startInfo, string boundary, string startUri, bool writeMessageHeaders, bool ownsStream);
    public static XmlDictionaryWriter CreateDictionaryWriter(XmlWriter writer);
    public void WriteStartElement(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    public virtual void WriteStartElement(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    public void WriteStartAttribute(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    public virtual void WriteStartAttribute(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    public void WriteAttributeString(XmlDictionaryString localName, XmlDictionaryString namespaceUri, string value);
    public virtual void WriteXmlnsAttribute(string prefix, string namespaceUri);
    public virtual void WriteXmlnsAttribute(string prefix, XmlDictionaryString namespaceUri);
    public virtual void WriteXmlAttribute(string localName, string value);
    public virtual void WriteXmlAttribute(XmlDictionaryString localName, XmlDictionaryString value);
    public void WriteAttributeString(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, string value);
    public void WriteElementString(XmlDictionaryString localName, XmlDictionaryString namespaceUri, string value);
    public void WriteElementString(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, string value);
    public virtual void WriteString(XmlDictionaryString value);
    public virtual void WriteQualifiedName(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    public virtual void WriteValue(XmlDictionaryString value);
    public virtual void WriteValue(IStreamProvider value);
    public virtual Task WriteValueAsync(IStreamProvider value);
    internal virtual IAsyncResult BeginWriteValue(IStreamProvider value, AsyncCallback callback, object state);
    internal virtual void EndWriteValue(IAsyncResult result);
    public virtual void WriteValue(UniqueId value);
    public virtual void WriteValue(Guid value);
    public virtual void WriteValue(TimeSpan value);
    public virtual bool get_CanCanonicalize();
    public virtual void StartCanonicalization(Stream stream, bool includeComments, String[] inclusivePrefixes);
    public virtual void EndCanonicalization();
    private void WriteElementNode(XmlDictionaryReader reader, bool defattr);
    private void WriteArrayNode(XmlDictionaryReader reader, string prefix, string localName, string namespaceUri, Type type);
    private void WriteArrayNode(XmlDictionaryReader reader, string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Type type);
    private void WriteArrayNode(XmlDictionaryReader reader, Type type);
    protected virtual void WriteTextNode(XmlDictionaryReader reader, bool isAttribute);
    public virtual void WriteNode(XmlReader reader, bool defattr);
    public virtual void WriteNode(XmlDictionaryReader reader, bool defattr);
    private void CheckArray(Array array, int offset, int count);
    public virtual void WriteArray(string prefix, string localName, string namespaceUri, Boolean[] array, int offset, int count);
    public virtual void WriteArray(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Boolean[] array, int offset, int count);
    public virtual void WriteArray(string prefix, string localName, string namespaceUri, Int16[] array, int offset, int count);
    public virtual void WriteArray(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Int16[] array, int offset, int count);
    public virtual void WriteArray(string prefix, string localName, string namespaceUri, Int32[] array, int offset, int count);
    public virtual void WriteArray(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Int32[] array, int offset, int count);
    public virtual void WriteArray(string prefix, string localName, string namespaceUri, Int64[] array, int offset, int count);
    public virtual void WriteArray(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Int64[] array, int offset, int count);
    public virtual void WriteArray(string prefix, string localName, string namespaceUri, Single[] array, int offset, int count);
    public virtual void WriteArray(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Single[] array, int offset, int count);
    public virtual void WriteArray(string prefix, string localName, string namespaceUri, Double[] array, int offset, int count);
    public virtual void WriteArray(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Double[] array, int offset, int count);
    public virtual void WriteArray(string prefix, string localName, string namespaceUri, Decimal[] array, int offset, int count);
    public virtual void WriteArray(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Decimal[] array, int offset, int count);
    public virtual void WriteArray(string prefix, string localName, string namespaceUri, DateTime[] array, int offset, int count);
    public virtual void WriteArray(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, DateTime[] array, int offset, int count);
    public virtual void WriteArray(string prefix, string localName, string namespaceUri, Guid[] array, int offset, int count);
    public virtual void WriteArray(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Guid[] array, int offset, int count);
    public virtual void WriteArray(string prefix, string localName, string namespaceUri, TimeSpan[] array, int offset, int count);
    public virtual void WriteArray(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, TimeSpan[] array, int offset, int count);
}
internal static class System.Xml.XmlExceptionHelper : object {
    private static void ThrowXmlException(XmlDictionaryReader reader, string res);
    private static void ThrowXmlException(XmlDictionaryReader reader, string res, string arg1);
    private static void ThrowXmlException(XmlDictionaryReader reader, string res, string arg1, string arg2);
    private static void ThrowXmlException(XmlDictionaryReader reader, string res, string arg1, string arg2, string arg3);
    public static void ThrowXmlException(XmlDictionaryReader reader, XmlException exception);
    private static string GetName(string prefix, string localName);
    private static string GetWhatWasFound(XmlDictionaryReader reader);
    public static void ThrowStartElementExpected(XmlDictionaryReader reader);
    public static void ThrowStartElementExpected(XmlDictionaryReader reader, string name);
    public static void ThrowStartElementExpected(XmlDictionaryReader reader, string localName, string ns);
    public static void ThrowStartElementExpected(XmlDictionaryReader reader, XmlDictionaryString localName, XmlDictionaryString ns);
    public static void ThrowFullStartElementExpected(XmlDictionaryReader reader);
    public static void ThrowFullStartElementExpected(XmlDictionaryReader reader, string name);
    public static void ThrowFullStartElementExpected(XmlDictionaryReader reader, string localName, string ns);
    public static void ThrowFullStartElementExpected(XmlDictionaryReader reader, XmlDictionaryString localName, XmlDictionaryString ns);
    public static void ThrowEndElementExpected(XmlDictionaryReader reader, string localName, string ns);
    public static void ThrowMaxStringContentLengthExceeded(XmlDictionaryReader reader, int maxStringContentLength);
    public static void ThrowMaxArrayLengthExceeded(XmlDictionaryReader reader, int maxArrayLength);
    public static void ThrowMaxArrayLengthOrMaxItemsQuotaExceeded(XmlDictionaryReader reader, int maxQuota);
    public static void ThrowMaxDepthExceeded(XmlDictionaryReader reader, int maxDepth);
    public static void ThrowMaxBytesPerReadExceeded(XmlDictionaryReader reader, int maxBytesPerRead);
    public static void ThrowMaxNameTableCharCountExceeded(XmlDictionaryReader reader, int maxNameTableCharCount);
    public static void ThrowBase64DataExpected(XmlDictionaryReader reader);
    public static void ThrowUndefinedPrefix(XmlDictionaryReader reader, string prefix);
    public static void ThrowProcessingInstructionNotSupported(XmlDictionaryReader reader);
    public static void ThrowInvalidXml(XmlDictionaryReader reader, byte b);
    public static void ThrowUnexpectedEndOfFile(XmlDictionaryReader reader);
    public static void ThrowUnexpectedEndElement(XmlDictionaryReader reader);
    public static void ThrowTokenExpected(XmlDictionaryReader reader, string expected, char found);
    public static void ThrowTokenExpected(XmlDictionaryReader reader, string expected, string found);
    public static void ThrowInvalidCharRef(XmlDictionaryReader reader);
    public static void ThrowTagMismatch(XmlDictionaryReader reader, string expectedPrefix, string expectedLocalName, string foundPrefix, string foundLocalName);
    public static void ThrowDuplicateXmlnsAttribute(XmlDictionaryReader reader, string localName, string ns);
    public static void ThrowDuplicateAttribute(XmlDictionaryReader reader, string prefix1, string prefix2, string localName, string ns);
    public static void ThrowInvalidBinaryFormat(XmlDictionaryReader reader);
    public static void ThrowInvalidRootData(XmlDictionaryReader reader);
    public static void ThrowMultipleRootElements(XmlDictionaryReader reader);
    public static void ThrowDeclarationNotFirst(XmlDictionaryReader reader);
    public static void ThrowConversionOverflow(XmlDictionaryReader reader, string value, string type);
    public static void ThrowXmlDictionaryStringIDOutOfRange(XmlDictionaryReader reader);
    public static void ThrowXmlDictionaryStringIDUndefinedStatic(XmlDictionaryReader reader, int key);
    public static void ThrowXmlDictionaryStringIDUndefinedSession(XmlDictionaryReader reader, int key);
    public static void ThrowEmptyNamespace(XmlDictionaryReader reader);
    public static XmlException CreateConversionException(string value, string type, Exception exception);
    public static XmlException CreateEncodingException(Byte[] buffer, int offset, int count, Exception exception);
    public static XmlException CreateEncodingException(string value, Exception exception);
}
[DefaultMemberAttribute("Item")]
internal class System.Xml.XmlMtomReader : XmlDictionaryReader {
    private Encoding[] encodings;
    private XmlDictionaryReader xmlReader;
    private XmlDictionaryReader infosetReader;
    private MimeReader mimeReader;
    private Dictionary`2<string, MimePart> mimeParts;
    private OnXmlDictionaryReaderClose onClose;
    private bool readingBinaryElement;
    private int maxBufferSize;
    private int bufferRemaining;
    private MimePart part;
    public XmlDictionaryReaderQuotas Quotas { get; }
    public int AttributeCount { get; }
    public string BaseURI { get; }
    public bool CanReadBinaryContent { get; }
    public bool CanReadValueChunk { get; }
    public bool CanResolveEntity { get; }
    public int Depth { get; }
    public bool EOF { get; }
    public bool HasAttributes { get; }
    public bool HasValue { get; }
    public bool IsDefault { get; }
    public bool IsEmptyElement { get; }
    public string LocalName { get; }
    public string Name { get; }
    public string NamespaceURI { get; }
    public XmlNameTable NameTable { get; }
    public XmlNodeType NodeType { get; }
    public string Prefix { get; }
    public char QuoteChar { get; }
    public ReadState ReadState { get; }
    public XmlReaderSettings Settings { get; }
    public string Item { get; }
    public string Item { get; }
    public string Item { get; }
    public string Value { get; }
    public Type ValueType { get; }
    public string XmlLang { get; }
    public XmlSpace XmlSpace { get; }
    public int LineNumber { get; }
    public int LinePosition { get; }
    internal static void DecrementBufferQuota(int maxBuffer, Int32& remaining, int size);
    private void SetReadEncodings(Encoding[] encodings);
    private void CheckContentType(string contentType);
    public sealed virtual void SetInput(Byte[] buffer, int offset, int count, Encoding[] encodings, string contentType, XmlDictionaryReaderQuotas quotas, int maxBufferSize, OnXmlDictionaryReaderClose onClose);
    public sealed virtual void SetInput(Stream stream, Encoding[] encodings, string contentType, XmlDictionaryReaderQuotas quotas, int maxBufferSize, OnXmlDictionaryReaderClose onClose);
    private void Initialize(Stream stream, string contentType, XmlDictionaryReaderQuotas quotas, int maxBufferSize);
    public virtual XmlDictionaryReaderQuotas get_Quotas();
    private void ReadMessageMimeVersionHeader(MimeVersionHeader header);
    private void ReadMessageContentTypeHeader(ContentTypeHeader header, String& boundary, String& start, String& startInfo);
    private Encoding ReadRootContentTypeHeader(ContentTypeHeader header, Encoding[] expectedEncodings, string expectedType);
    private void CheckContentTransferEncodingOnRoot(ContentTransferEncodingHeader header);
    private void CheckContentTransferEncodingOnBinaryPart(ContentTransferEncodingHeader header);
    private string GetStartUri(string startUri);
    public virtual bool Read();
    private MimePart ReadMimePart(string uri);
    private MimePart ReadRootMimePart();
    private void AdvanceToContentOnElement();
    public virtual int get_AttributeCount();
    public virtual string get_BaseURI();
    public virtual bool get_CanReadBinaryContent();
    public virtual bool get_CanReadValueChunk();
    public virtual bool get_CanResolveEntity();
    public virtual void Close();
    public virtual int get_Depth();
    public virtual bool get_EOF();
    public virtual string GetAttribute(int index);
    public virtual string GetAttribute(string name);
    public virtual string GetAttribute(string name, string ns);
    public virtual string GetAttribute(XmlDictionaryString localName, XmlDictionaryString ns);
    public virtual bool get_HasAttributes();
    public virtual bool get_HasValue();
    public virtual bool get_IsDefault();
    public virtual bool get_IsEmptyElement();
    public virtual bool IsLocalName(string localName);
    public virtual bool IsLocalName(XmlDictionaryString localName);
    public virtual bool IsNamespaceUri(string ns);
    public virtual bool IsNamespaceUri(XmlDictionaryString ns);
    public virtual bool IsStartElement();
    public virtual bool IsStartElement(string localName);
    public virtual bool IsStartElement(string localName, string ns);
    public virtual bool IsStartElement(XmlDictionaryString localName, XmlDictionaryString ns);
    public virtual string get_LocalName();
    public virtual string LookupNamespace(string ns);
    public virtual void MoveToAttribute(int index);
    public virtual bool MoveToAttribute(string name);
    public virtual bool MoveToAttribute(string name, string ns);
    public virtual bool MoveToElement();
    public virtual bool MoveToFirstAttribute();
    public virtual bool MoveToNextAttribute();
    public virtual string get_Name();
    public virtual string get_NamespaceURI();
    public virtual XmlNameTable get_NameTable();
    public virtual XmlNodeType get_NodeType();
    public virtual string get_Prefix();
    public virtual char get_QuoteChar();
    public virtual bool ReadAttributeValue();
    public virtual object ReadContentAs(Type returnType, IXmlNamespaceResolver namespaceResolver);
    public virtual Byte[] ReadContentAsBase64();
    public virtual int ReadValueAsBase64(Byte[] buffer, int offset, int count);
    public virtual int ReadContentAsBase64(Byte[] buffer, int offset, int count);
    public virtual int ReadElementContentAsBase64(Byte[] buffer, int offset, int count);
    public virtual int ReadElementContentAsBinHex(Byte[] buffer, int offset, int count);
    public virtual int ReadContentAsBinHex(Byte[] buffer, int offset, int count);
    public virtual bool ReadContentAsBoolean();
    public virtual int ReadContentAsChars(Char[] chars, int index, int count);
    public virtual DateTime ReadContentAsDateTime();
    public virtual decimal ReadContentAsDecimal();
    public virtual double ReadContentAsDouble();
    public virtual int ReadContentAsInt();
    public virtual long ReadContentAsLong();
    public virtual object ReadContentAsObject();
    public virtual float ReadContentAsFloat();
    public virtual string ReadContentAsString();
    public virtual string ReadInnerXml();
    public virtual string ReadOuterXml();
    public virtual ReadState get_ReadState();
    public virtual int ReadValueChunk(Char[] buffer, int index, int count);
    public virtual void ResolveEntity();
    public virtual XmlReaderSettings get_Settings();
    public virtual void Skip();
    public virtual string get_Item(int index);
    public virtual string get_Item(string name);
    public virtual string get_Item(string name, string ns);
    public virtual string get_Value();
    public virtual Type get_ValueType();
    public virtual string get_XmlLang();
    public virtual XmlSpace get_XmlSpace();
    public sealed virtual bool HasLineInfo();
    public sealed virtual int get_LineNumber();
    public sealed virtual int get_LinePosition();
}
internal class System.Xml.XmlMtomWriter : XmlDictionaryWriter {
    private static int MaxInlinedBytes;
    private int maxSizeInBytes;
    private XmlDictionaryWriter writer;
    private XmlDictionaryWriter infosetWriter;
    private MimeWriter mimeWriter;
    private Encoding encoding;
    private bool isUTF8;
    private string contentID;
    private string contentType;
    private string initialContentTypeForRootPart;
    private string initialContentTypeForMimeMessage;
    private MemoryStream contentTypeStream;
    private List`1<MimePart> mimeParts;
    private IList`1<MtomBinaryData> binaryDataChunks;
    private int depth;
    private int totalSizeOfMimeParts;
    private int sizeOfBufferedBinaryData;
    private Char[] chars;
    private Byte[] bytes;
    private bool isClosed;
    private bool ownsStream;
    private XmlDictionaryWriter Writer { get; }
    private bool IsInitialized { get; }
    public XmlWriterSettings Settings { get; }
    public WriteState WriteState { get; }
    public string XmlLang { get; }
    public XmlSpace XmlSpace { get; }
    public sealed virtual void SetOutput(Stream stream, Encoding encoding, int maxSizeInBytes, string startInfo, string boundary, string startUri, bool writeMessageHeaders, bool ownsStream);
    private XmlDictionaryWriter get_Writer();
    private bool get_IsInitialized();
    private void Initialize(Stream stream, string startInfo, string boundary, string startUri, bool writeMessageHeaders, bool ownsStream);
    private void Initialize();
    private static string GetBoundaryString();
    internal static bool IsUTF8Encoding(Encoding encoding);
    private static string GetContentTypeForMimeMessage(string boundary, string startUri, string startInfo);
    private static string GetContentTypeForRootMimePart(Encoding encoding, string startInfo);
    private static string CharSet(Encoding enc);
    public virtual void WriteStartElement(string prefix, string localName, string ns);
    public virtual void WriteStartElement(string prefix, XmlDictionaryString localName, XmlDictionaryString ns);
    private void ThrowIfElementIsXOPInclude(string prefix, string localName, string ns);
    public virtual void WriteEndElement();
    public virtual void WriteFullEndElement();
    public virtual void WriteValue(IStreamProvider value);
    public virtual void WriteBase64(Byte[] buffer, int index, int count);
    internal static int ValidateSizeOfMessage(int maxSize, int offset, int size);
    private void WriteBase64InlineIfPresent();
    private void WriteBase64Inline();
    private void WriteXOPInclude();
    public static string GenerateUriForMimePart(int index);
    private void WriteXOPBinaryParts();
    private void WriteMimeHeaders(string contentID, string contentType, string contentTransferEncoding);
    public virtual void Close();
    private void CheckIfStartContentTypeAttribute(string localName, string ns);
    private void CheckIfEndContentTypeAttribute();
    public virtual void Flush();
    public virtual string LookupPrefix(string ns);
    public virtual XmlWriterSettings get_Settings();
    public virtual void WriteAttributes(XmlReader reader, bool defattr);
    public virtual void WriteBinHex(Byte[] buffer, int index, int count);
    public virtual void WriteCData(string text);
    public virtual void WriteCharEntity(char ch);
    public virtual void WriteChars(Char[] buffer, int index, int count);
    public virtual void WriteComment(string text);
    public virtual void WriteDocType(string name, string pubid, string sysid, string subset);
    public virtual void WriteEndAttribute();
    public virtual void WriteEndDocument();
    public virtual void WriteEntityRef(string name);
    public virtual void WriteName(string name);
    public virtual void WriteNmToken(string name);
    protected virtual void WriteTextNode(XmlDictionaryReader reader, bool attribute);
    public virtual void WriteNode(XPathNavigator navigator, bool defattr);
    public virtual void WriteProcessingInstruction(string name, string text);
    public virtual void WriteQualifiedName(string localName, string namespaceUri);
    public virtual void WriteRaw(Char[] buffer, int index, int count);
    public virtual void WriteRaw(string data);
    public virtual void WriteStartAttribute(string prefix, string localName, string ns);
    public virtual void WriteStartAttribute(string prefix, XmlDictionaryString localName, XmlDictionaryString ns);
    public virtual void WriteStartDocument();
    public virtual void WriteStartDocument(bool standalone);
    public virtual WriteState get_WriteState();
    public virtual void WriteString(string text);
    public virtual void WriteString(XmlDictionaryString value);
    public virtual void WriteSurrogateCharEntity(char lowChar, char highChar);
    public virtual void WriteWhitespace(string whitespace);
    public virtual void WriteValue(object value);
    public virtual void WriteValue(string value);
    public virtual void WriteValue(bool value);
    public virtual void WriteValue(DateTime value);
    public virtual void WriteValue(double value);
    public virtual void WriteValue(int value);
    public virtual void WriteValue(long value);
    public virtual void WriteValue(XmlDictionaryString value);
    public virtual void WriteXmlnsAttribute(string prefix, string ns);
    public virtual void WriteXmlnsAttribute(string prefix, XmlDictionaryString ns);
    public virtual string get_XmlLang();
    public virtual XmlSpace get_XmlSpace();
}
internal abstract class System.Xml.XmlNodeWriter : object {
    private static XmlNodeWriter nullNodeWriter;
    public static XmlNodeWriter Null { get; }
    public static XmlNodeWriter get_Null();
    internal virtual AsyncCompletionResult WriteBase64TextAsync(AsyncEventArgs`1<XmlNodeWriterWriteBase64TextArgs> state);
    public virtual IAsyncResult BeginWriteBase64Text(Byte[] trailBuffer, int trailCount, Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual void EndWriteBase64Text(IAsyncResult result);
    public abstract virtual void Flush();
    public abstract virtual void Close();
    public abstract virtual void WriteDeclaration();
    public abstract virtual void WriteComment(string text);
    public abstract virtual void WriteCData(string text);
    public abstract virtual void WriteStartElement(string prefix, string localName);
    public virtual void WriteStartElement(Byte[] prefixBuffer, int prefixOffset, int prefixLength, Byte[] localNameBuffer, int localNameOffset, int localNameLength);
    public abstract virtual void WriteStartElement(string prefix, XmlDictionaryString localName);
    public abstract virtual void WriteEndStartElement(bool isEmpty);
    public abstract virtual void WriteEndElement(string prefix, string localName);
    public virtual void WriteEndElement(Byte[] prefixBuffer, int prefixOffset, int prefixLength, Byte[] localNameBuffer, int localNameOffset, int localNameLength);
    public abstract virtual void WriteXmlnsAttribute(string prefix, string ns);
    public virtual void WriteXmlnsAttribute(Byte[] prefixBuffer, int prefixOffset, int prefixLength, Byte[] nsBuffer, int nsOffset, int nsLength);
    public abstract virtual void WriteXmlnsAttribute(string prefix, XmlDictionaryString ns);
    public abstract virtual void WriteStartAttribute(string prefix, string localName);
    public virtual void WriteStartAttribute(Byte[] prefixBuffer, int prefixOffset, int prefixLength, Byte[] localNameBuffer, int localNameOffset, int localNameLength);
    public abstract virtual void WriteStartAttribute(string prefix, XmlDictionaryString localName);
    public abstract virtual void WriteEndAttribute();
    public abstract virtual void WriteCharEntity(int ch);
    public abstract virtual void WriteEscapedText(string value);
    public abstract virtual void WriteEscapedText(XmlDictionaryString value);
    public abstract virtual void WriteEscapedText(Char[] chars, int offset, int count);
    public abstract virtual void WriteEscapedText(Byte[] buffer, int offset, int count);
    public abstract virtual void WriteText(string value);
    public abstract virtual void WriteText(XmlDictionaryString value);
    public abstract virtual void WriteText(Char[] chars, int offset, int count);
    public abstract virtual void WriteText(Byte[] buffer, int offset, int count);
    public abstract virtual void WriteInt32Text(int value);
    public abstract virtual void WriteInt64Text(long value);
    public abstract virtual void WriteBoolText(bool value);
    public abstract virtual void WriteUInt64Text(ulong value);
    public abstract virtual void WriteFloatText(float value);
    public abstract virtual void WriteDoubleText(double value);
    public abstract virtual void WriteDecimalText(decimal value);
    public abstract virtual void WriteDateTimeText(DateTime value);
    public abstract virtual void WriteUniqueIdText(UniqueId value);
    public abstract virtual void WriteTimeSpanText(TimeSpan value);
    public abstract virtual void WriteGuidText(Guid value);
    public abstract virtual void WriteStartListText();
    public abstract virtual void WriteListSeparator();
    public abstract virtual void WriteEndListText();
    public abstract virtual void WriteBase64Text(Byte[] trailBuffer, int trailCount, Byte[] buffer, int offset, int count);
    public abstract virtual void WriteQualifiedName(string prefix, XmlDictionaryString localName);
}
internal class System.Xml.XmlNodeWriterWriteBase64TextArgs : object {
    [CompilerGeneratedAttribute]
private Byte[] <TrailBuffer>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TrailCount>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <Buffer>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Offset>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Count>k__BackingField;
    internal Byte[] TrailBuffer { get; internal set; }
    internal int TrailCount { get; internal set; }
    internal Byte[] Buffer { get; internal set; }
    internal int Offset { get; internal set; }
    internal int Count { get; internal set; }
    [CompilerGeneratedAttribute]
internal Byte[] get_TrailBuffer();
    [CompilerGeneratedAttribute]
internal void set_TrailBuffer(Byte[] value);
    [CompilerGeneratedAttribute]
internal int get_TrailCount();
    [CompilerGeneratedAttribute]
internal void set_TrailCount(int value);
    [CompilerGeneratedAttribute]
internal Byte[] get_Buffer();
    [CompilerGeneratedAttribute]
internal void set_Buffer(Byte[] value);
    [CompilerGeneratedAttribute]
internal int get_Offset();
    [CompilerGeneratedAttribute]
internal void set_Offset(int value);
    [CompilerGeneratedAttribute]
internal int get_Count();
    [CompilerGeneratedAttribute]
internal void set_Count(int value);
}
internal class System.Xml.XmlSigningNodeWriter : XmlNodeWriter {
    private XmlNodeWriter writer;
    private XmlCanonicalWriter signingWriter;
    private Byte[] chars;
    private Byte[] base64Chars;
    private bool text;
    public XmlNodeWriter NodeWriter { get; public set; }
    public XmlCanonicalWriter CanonicalWriter { get; }
    public XmlSigningNodeWriter(bool text);
    public void SetOutput(XmlNodeWriter writer, Stream stream, bool includeComments, String[] inclusivePrefixes);
    public XmlNodeWriter get_NodeWriter();
    public void set_NodeWriter(XmlNodeWriter value);
    public XmlCanonicalWriter get_CanonicalWriter();
    public virtual void Flush();
    public virtual void Close();
    public virtual void WriteDeclaration();
    public virtual void WriteComment(string text);
    public virtual void WriteCData(string text);
    public virtual void WriteStartElement(string prefix, string localName);
    public virtual void WriteStartElement(Byte[] prefixBuffer, int prefixOffset, int prefixLength, Byte[] localNameBuffer, int localNameOffset, int localNameLength);
    public virtual void WriteStartElement(string prefix, XmlDictionaryString localName);
    public virtual void WriteEndStartElement(bool isEmpty);
    public virtual void WriteEndElement(string prefix, string localName);
    public virtual void WriteXmlnsAttribute(string prefix, string ns);
    public virtual void WriteXmlnsAttribute(Byte[] prefixBuffer, int prefixOffset, int prefixLength, Byte[] nsBuffer, int nsOffset, int nsLength);
    public virtual void WriteXmlnsAttribute(string prefix, XmlDictionaryString ns);
    public virtual void WriteStartAttribute(string prefix, string localName);
    public virtual void WriteStartAttribute(Byte[] prefixBuffer, int prefixOffset, int prefixLength, Byte[] localNameBuffer, int localNameOffset, int localNameLength);
    public virtual void WriteStartAttribute(string prefix, XmlDictionaryString localName);
    public virtual void WriteEndAttribute();
    public virtual void WriteCharEntity(int ch);
    public virtual void WriteEscapedText(string value);
    public virtual void WriteEscapedText(Char[] chars, int offset, int count);
    public virtual void WriteEscapedText(XmlDictionaryString value);
    public virtual void WriteEscapedText(Byte[] chars, int offset, int count);
    public virtual void WriteText(string value);
    public virtual void WriteText(Char[] chars, int offset, int count);
    public virtual void WriteText(Byte[] chars, int offset, int count);
    public virtual void WriteText(XmlDictionaryString value);
    public virtual void WriteInt32Text(int value);
    public virtual void WriteInt64Text(long value);
    public virtual void WriteBoolText(bool value);
    public virtual void WriteUInt64Text(ulong value);
    public virtual void WriteFloatText(float value);
    public virtual void WriteDoubleText(double value);
    public virtual void WriteDecimalText(decimal value);
    public virtual void WriteDateTimeText(DateTime value);
    public virtual void WriteUniqueIdText(UniqueId value);
    public virtual void WriteTimeSpanText(TimeSpan value);
    public virtual void WriteGuidText(Guid value);
    public virtual void WriteStartListText();
    public virtual void WriteListSeparator();
    public virtual void WriteEndListText();
    public virtual void WriteBase64Text(Byte[] trailBytes, int trailByteCount, Byte[] buffer, int offset, int count);
    private void WriteBase64Text(Byte[] buffer, int offset, int count);
    public virtual void WriteQualifiedName(string prefix, XmlDictionaryString localName);
}
internal abstract class System.Xml.XmlStreamNodeWriter : XmlNodeWriter {
    private Stream stream;
    private Byte[] buffer;
    private int offset;
    private bool ownsStream;
    private static int bufferLength;
    private static int maxEntityLength;
    private static int maxBytesPerChar;
    private Encoding encoding;
    private int hasPendingWrite;
    private AsyncEventArgs`1<object> flushBufferState;
    private static UTF8Encoding UTF8Encoding;
    private static AsyncCallback onFlushBufferComplete;
    private static AsyncEventArgsCallback onGetFlushComplete;
    public Stream Stream { get; public set; }
    public Byte[] StreamBuffer { get; }
    public int BufferOffset { get; }
    public int Position { get; }
    private static XmlStreamNodeWriter();
    protected void SetOutput(Stream stream, bool ownsStream, Encoding encoding);
    public Stream get_Stream();
    public void set_Stream(Stream value);
    public Byte[] get_StreamBuffer();
    public int get_BufferOffset();
    public int get_Position();
    protected Byte[] GetBuffer(int count, Int32& offset);
    internal AsyncCompletionResult GetBufferAsync(GetBufferAsyncEventArgs getBufferState);
    private static void GetBufferFlushComplete(IAsyncEventArgs completionState);
    private AsyncCompletionResult FlushBufferAsync(AsyncEventArgs`1<object> state);
    private static void OnFlushBufferCompete(IAsyncResult result);
    protected IAsyncResult BeginGetBuffer(int count, AsyncCallback callback, object state);
    protected Byte[] EndGetBuffer(IAsyncResult result, Int32& offset);
    protected void Advance(int count);
    private void EnsureByte();
    protected void WriteByte(byte b);
    protected void WriteByte(char ch);
    protected void WriteBytes(byte b1, byte b2);
    protected void WriteBytes(char ch1, char ch2);
    public void WriteBytes(Byte[] byteBuffer, int byteOffset, int byteCount);
    public IAsyncResult BeginWriteBytes(Byte[] byteBuffer, int byteOffset, int byteCount, AsyncCallback callback, object state);
    public void EndWriteBytes(IAsyncResult result);
    [SecurityCriticalAttribute]
protected void UnsafeWriteBytes(Byte* bytes, int byteCount);
    [SecuritySafeCriticalAttribute]
protected void WriteUTF8Char(int ch);
    protected void WriteUTF8Chars(Byte[] chars, int charOffset, int charCount);
    [SecuritySafeCriticalAttribute]
protected void WriteUTF8Chars(string value);
    [SecurityCriticalAttribute]
protected void UnsafeWriteUTF8Chars(Char* chars, int charCount);
    [SecurityCriticalAttribute]
protected void UnsafeWriteUnicodeChars(Char* chars, int charCount);
    [SecurityCriticalAttribute]
protected int UnsafeGetUnicodeChars(Char* chars, int charCount, Byte[] buffer, int offset);
    [SecurityCriticalAttribute]
protected int UnsafeGetUTF8Length(Char* chars, int charCount);
    [SecurityCriticalAttribute]
protected int UnsafeGetUTF8Chars(Char* chars, int charCount, Byte[] buffer, int offset);
    protected virtual void FlushBuffer();
    protected virtual IAsyncResult BeginFlushBuffer(AsyncCallback callback, object state);
    protected virtual void EndFlushBuffer(IAsyncResult result);
    public virtual void Flush();
    public virtual void Close();
}
internal class System.Xml.XmlUTF8NodeWriter : XmlStreamNodeWriter {
    private Byte[] entityChars;
    private Boolean[] isEscapedAttributeChar;
    private Boolean[] isEscapedElementChar;
    private bool inAttribute;
    private static int bufferLength;
    private static int maxEntityLength;
    private static int maxBytesPerChar;
    private Encoding encoding;
    private Char[] chars;
    private InternalWriteBase64TextAsyncWriter internalWriteBase64TextAsyncWriter;
    private static Byte[] startDecl;
    private static Byte[] endDecl;
    private static Byte[] utf8Decl;
    private static Byte[] digits;
    private static Boolean[] defaultIsEscapedAttributeChar;
    private static Boolean[] defaultIsEscapedElementChar;
    public Encoding Encoding { get; }
    public XmlUTF8NodeWriter(Boolean[] isEscapedAttributeChar, Boolean[] isEscapedElementChar);
    private static XmlUTF8NodeWriter();
    public void SetOutput(Stream stream, bool ownsStream, Encoding encoding);
    public Encoding get_Encoding();
    private Byte[] GetCharEntityBuffer();
    private Char[] GetCharBuffer(int charCount);
    public virtual void WriteDeclaration();
    public virtual void WriteCData(string text);
    private void WriteStartComment();
    private void WriteEndComment();
    public virtual void WriteComment(string text);
    public virtual void WriteStartElement(string prefix, string localName);
    public virtual void WriteStartElement(string prefix, XmlDictionaryString localName);
    public virtual void WriteStartElement(Byte[] prefixBuffer, int prefixOffset, int prefixLength, Byte[] localNameBuffer, int localNameOffset, int localNameLength);
    public virtual void WriteEndStartElement(bool isEmpty);
    public virtual void WriteEndElement(string prefix, string localName);
    public virtual void WriteEndElement(Byte[] prefixBuffer, int prefixOffset, int prefixLength, Byte[] localNameBuffer, int localNameOffset, int localNameLength);
    private void WriteStartXmlnsAttribute();
    public virtual void WriteXmlnsAttribute(string prefix, string ns);
    public virtual void WriteXmlnsAttribute(string prefix, XmlDictionaryString ns);
    public virtual void WriteXmlnsAttribute(Byte[] prefixBuffer, int prefixOffset, int prefixLength, Byte[] nsBuffer, int nsOffset, int nsLength);
    public virtual void WriteStartAttribute(string prefix, string localName);
    public virtual void WriteStartAttribute(string prefix, XmlDictionaryString localName);
    public virtual void WriteStartAttribute(Byte[] prefixBuffer, int prefixOffset, int prefixLength, Byte[] localNameBuffer, int localNameOffset, int localNameLength);
    public virtual void WriteEndAttribute();
    private void WritePrefix(string prefix);
    private void WritePrefix(Byte[] prefixBuffer, int prefixOffset, int prefixLength);
    private void WriteLocalName(string localName);
    private void WriteLocalName(Byte[] localNameBuffer, int localNameOffset, int localNameLength);
    public virtual void WriteEscapedText(XmlDictionaryString s);
    [SecuritySafeCriticalAttribute]
public virtual void WriteEscapedText(string s);
    [SecuritySafeCriticalAttribute]
public virtual void WriteEscapedText(Char[] s, int offset, int count);
    [SecurityCriticalAttribute]
private void UnsafeWriteEscapedText(Char* chars, int count);
    public virtual void WriteEscapedText(Byte[] chars, int offset, int count);
    public void WriteText(int ch);
    public virtual void WriteText(Byte[] chars, int offset, int count);
    [SecuritySafeCriticalAttribute]
public virtual void WriteText(Char[] chars, int offset, int count);
    public virtual void WriteText(string value);
    public virtual void WriteText(XmlDictionaryString value);
    public void WriteLessThanCharEntity();
    public void WriteGreaterThanCharEntity();
    public void WriteAmpersandCharEntity();
    public void WriteApostropheCharEntity();
    public void WriteQuoteCharEntity();
    private void WriteHexCharEntity(int ch);
    public virtual void WriteCharEntity(int ch);
    private int ToBase16(Byte[] chars, int offset, UInt32 value);
    public virtual void WriteBoolText(bool value);
    public virtual void WriteDecimalText(decimal value);
    public virtual void WriteDoubleText(double value);
    public virtual void WriteFloatText(float value);
    public virtual void WriteDateTimeText(DateTime value);
    public virtual void WriteUniqueIdText(UniqueId value);
    public virtual void WriteInt32Text(int value);
    public virtual void WriteInt64Text(long value);
    public virtual void WriteUInt64Text(ulong value);
    public virtual void WriteGuidText(Guid value);
    public virtual void WriteBase64Text(Byte[] trailBytes, int trailByteCount, Byte[] buffer, int offset, int count);
    private void InternalWriteBase64Text(Byte[] buffer, int offset, int count);
    internal virtual AsyncCompletionResult WriteBase64TextAsync(AsyncEventArgs`1<XmlNodeWriterWriteBase64TextArgs> xmlNodeWriterState);
    public virtual IAsyncResult BeginWriteBase64Text(Byte[] trailBytes, int trailByteCount, Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual void EndWriteBase64Text(IAsyncResult result);
    private IAsyncResult BeginInternalWriteBase64Text(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    private void EndInternalWriteBase64Text(IAsyncResult result);
    public virtual void WriteTimeSpanText(TimeSpan value);
    public virtual void WriteStartListText();
    public virtual void WriteListSeparator();
    public virtual void WriteEndListText();
    public virtual void WriteQualifiedName(string prefix, XmlDictionaryString localName);
}
internal class System.Xml.XmlUTF8TextReader : XmlBaseReader {
    private static int MaxTextChunk;
    private PrefixHandle prefix;
    private StringHandle localName;
    private Int32[] rowOffsets;
    private OnXmlDictionaryReaderClose onClose;
    private bool buffered;
    private int maxBytesPerRead;
    private static Byte[] charType;
    public int LineNumber { get; }
    public int LinePosition { get; }
    private static XmlUTF8TextReader();
    public sealed virtual void SetInput(Byte[] buffer, int offset, int count, Encoding encoding, XmlDictionaryReaderQuotas quotas, OnXmlDictionaryReaderClose onClose);
    public sealed virtual void SetInput(Stream stream, Encoding encoding, XmlDictionaryReaderQuotas quotas, OnXmlDictionaryReaderClose onClose);
    private void MoveToInitial(XmlDictionaryReaderQuotas quotas, OnXmlDictionaryReaderClose onClose);
    public virtual void Close();
    private void SkipWhitespace();
    private void ReadDeclaration();
    private void VerifyNCName(string s);
    private void ReadQualifiedName(PrefixHandle prefix, StringHandle localName);
    private int ReadAttributeText(Byte[] buffer, int offset, int offsetMax);
    private void ReadAttributes();
    private void ReadNonFFFE();
    private bool IsNextCharacterNonFFFE(Byte[] buffer, int offset);
    private void BufferElement();
    private void ReadStartElement();
    private void ReadEndElement();
    private void ReadComment();
    private void ReadCData();
    private int ReadCharRef();
    private void ReadWhitespace();
    private int ReadWhitespace(Byte[] buffer, int offset, int offsetMax);
    private int ReadText(Byte[] buffer, int offset, int offsetMax);
    private int ReadTextAndWatchForInvalidCharacters(Byte[] buffer, int offset, int offsetMax);
    private int BreakText(Byte[] buffer, int offset, int length);
    private void ReadText(bool hasLeadingByteOf0xEF);
    private void ReadEscapedText();
    public virtual bool Read();
    protected virtual XmlSigningNodeWriter CreateSigningNodeWriter();
    public sealed virtual bool HasLineInfo();
    public sealed virtual int get_LineNumber();
    public sealed virtual int get_LinePosition();
    private void GetPosition(Int32& row, Int32& column);
}
internal class System.Xml.XmlUTF8TextWriter : XmlBaseWriter {
    private XmlUTF8NodeWriter writer;
    internal bool FastAsync { get; }
    public bool CanFragment { get; }
    internal virtual bool get_FastAsync();
    public sealed virtual void SetOutput(Stream stream, Encoding encoding, bool ownsStream);
    public virtual bool get_CanFragment();
    protected virtual XmlSigningNodeWriter CreateSigningNodeWriter();
}
internal class System.Xml.XmlWriteBase64AsyncArguments : object {
    [CompilerGeneratedAttribute]
private Byte[] <Buffer>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Index>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Count>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Offset>k__BackingField;
    internal Byte[] Buffer { get; internal set; }
    internal int Index { get; internal set; }
    internal int Count { get; internal set; }
    internal int Offset { get; internal set; }
    [CompilerGeneratedAttribute]
internal Byte[] get_Buffer();
    [CompilerGeneratedAttribute]
internal void set_Buffer(Byte[] value);
    [CompilerGeneratedAttribute]
internal int get_Index();
    [CompilerGeneratedAttribute]
internal void set_Index(int value);
    [CompilerGeneratedAttribute]
internal int get_Count();
    [CompilerGeneratedAttribute]
internal void set_Count(int value);
    [CompilerGeneratedAttribute]
internal int get_Offset();
    [CompilerGeneratedAttribute]
internal void set_Offset(int value);
}
internal class Unity.ThrowStub : ObjectDisposedException {
    public static void ThrowNotSupportedException();
}
