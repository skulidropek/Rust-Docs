public AABB : ValueType {
public Vector3 position
public Vector3 extents
public void .ctor(Vector3 position, Vector3 size)
public bool Contains(Vector3 target)
public Vector3 ClosestPoint(Vector3 target)
}
public ArrayIndexIsEnum : PropertyAttribute {
public Type enumType
}
public ArrayIndexIsEnumRanged : ArrayIndexIsEnum {
public float min
public float max
}
public AssetPool : object {
public Dictionary`2<Type, Pool> storage
public T Get()
public void Free(Mesh& mesh)
private Pool GetPool()
public void Clear()
}
public Capsule : ValueType {
public Vector3 position
public float radius
public float extent
public void .ctor(Vector3 position, float radius, float extent)
public bool Contains(Vector3 target)
public Vector3 ClosestPoint(Vector3 target)
public void Move(Vector3 direction, float distance, int layerMask)
}
public CRC : object {
private Byte[] byteBuffer
private UInt32[] crc32_tab
private UInt64[] crc64_tab
public UInt32 Compute32(UInt32 crc, int i)
public UInt32 Compute32(UInt32 crc, UInt32 u)
public UInt32 Compute32(UInt32 crc, float f)
public UInt32 Compute32(UInt32 crc, long i)
public UInt32 Compute32(UInt32 crc, ulong u)
public UInt32 Compute32(UInt32 crc, double f)
public UInt32 Compute32(UInt32 crc, string str)
public UInt32 Compute32(String[] strs)
public ulong Compute64(ulong crc, int i)
public ulong Compute64(ulong crc, UInt32 u)
public ulong Compute64(ulong crc, float f)
public ulong Compute64(ulong crc, long i)
public ulong Compute64(ulong crc, ulong u)
public ulong Compute64(ulong crc, double f)
public ulong Compute64(ulong crc, string str)
public ulong Compute64(String[] strs)
private int GrowByteBuffer(int count)
private UInt32 CRC32(UInt32 value, Byte[] buf, ulong size)
private ulong CRC64(ulong value, Byte[] buf, ulong size)
}
public Cylinder : ValueType {
public Vector3 position
public float radius
public float extent
public void .ctor(Vector3 position, float radius, float extent)
public bool Contains(Vector3 target)
public Vector3 ClosestPoint(Vector3 target)
}
public Facepunch.GameObjectPool`1 : ObjectPool`1<T> {
private GameObject poolRoot
public void AddToPool(T t)
public void AddChildrenToPool(Transform t)
public T TakeOrInstantiate(GameObject prefabSource)
}
public Facepunch.Instantiate : object {
public GameObject GameObject(GameObject go, Transform parent)
public GameObject GameObject(GameObject go, Vector3 pos, Quaternion rot)
public long WrapStart(GameObject go)
public void WrapEnd(GameObject go, long memory)
}
public Facepunch.ObjectPool`1 : object {
public List`1<T> list
public void AddToPool(T t)
public T TakeFromPool()
}
public Facepunch.Tick : object {
private List Timed
private List Update
private List Late
private List`1<Object> RemoveList
public void AddTimed(Object obj, float minDelay, float maxDelay, Action action, string DebugName)
public void Add(Object obj, Action action, string DebugName)
public void AddLateUpdate(Object obj, Action action, string DebugName)
public void RemoveAll(Object obj)
private void Cleanup()
internal void OnFrame()
internal void OnFrameLate()
}
public Facepunch.TickComponent : MonoBehaviour {
public TickComponent Instance
public void Init()
private void OnEnable()
private void Update()
private void LateUpdate()
}
public HorizontalAttribute : PropertyAttribute {
public int count
public int label
public void .ctor(int count, int label)
}
public Line : ValueType {
public Vector3 point0
public Vector3 point1
public void .ctor(Vector3 point0, Vector3 point1)
public void .ctor(Vector3 origin, Vector3 direction, float length)
public bool Trace(Ray ray, float radius, RaycastHit& hit, float maxDistance)
public Vector3 ClosestPoint(Vector3 pos)
public float Distance(Vector3 pos)
public float SqrDistance(Vector3 pos)
}
public ListEx : object {
public T GetRandom(List`1<T> list)
public T GetRandom(List`1<T> list, UInt32 seed)
public T GetRandom(List`1<T> list, UInt32& seed)
public void Shuffle(List`1<T> list, UInt32 seed)
public void Shuffle(List`1<T> list, UInt32& seed)
public void BubbleSort(List`1<T> list)
public void RemoveUnordered(List`1<T> list, int index)
public double TruncatedAverage(List`1<double> list, float pct)
}
public MaterialReplacement : MonoBehaviour {
private bool initialized
public Material[] Default
public Material[] Override
public Renderer Renderer
public void ReplaceRecursive(GameObject go, Material mat)
public void ReplaceRecursive(GameObject obj, Material[] find, Material[] replace)
public void Reset(GameObject go)
private void Init()
private void Replace(Material mat)
private void Replace(Material find, Material replace)
private void Replace(Material[] find, Material[] replace)
private void Revert()
}
public Mathx : object {
public float Increment(float f)
public float Decrement(float f)
public float Above(float latitude, float lower, float fade)
public float Tween(float latitude, float lower, float upper, float fade)
public float Below(float latitude, float upper, float fade)
public Color Lerp3(float f1, Color c1, float f2, Color c2, float f3, Color c3)
public int Clamp(int v, int min, int max)
public int Sign(int v)
public float SmoothMax(float a, float b, float fade)
public float Discretize01(float v, int steps)
public float Min(float f1, float f2, float f3)
public float Min(float f1, float f2, float f3, float f4)
public int Min(int f1, int f2, int f3)
public int Min(int f1, int f2, int f3, int f4)
public float Max(float f1, float f2, float f3)
public float Max(float f1, float f2, float f3, float f4)
public int Max(int f1, int f2, int f3)
public int Max(int f1, int f2, int f3, int f4)
public UInt32 Min(UInt32 i1, UInt32 i2)
public UInt32 Max(UInt32 i1, UInt32 i2)
public float fsel(float c, float x, float y)
public float RemapValClamped(float val, float A, float B, float C, float D)
}
public OBB : ValueType {
public Quaternion rotation
public Vector3 position
public Vector3 extents
public Vector3 forward
public Vector3 right
public Vector3 up
public float reject
public void .ctor(Transform transform, Bounds bounds)
public void .ctor(Vector3 position, Vector3 scale, Quaternion rotation, Bounds bounds)
public void .ctor(Vector3 position, Quaternion rotation, Bounds bounds)
public void .ctor(Vector3 position, Vector3 size, Quaternion rotation)
public void Transform(Vector3 position, Vector3 scale, Quaternion rotation)
public Vector3 GetPoint(float x, float y, float z)
public Bounds ToBounds()
public bool Contains(Vector3 target)
public bool Intersects(OBB target)
public bool Intersects(Ray ray)
public bool Trace(Ray ray, RaycastHit& hit, float maxDistance)
public Vector3 ClosestPoint(Vector3 target)
public float Distance(OBB other)
}
public ObjectWorkQueue`1 : object {
protected Queue`1<T> queue
protected HashSet`1<T> containerTest
public string queueName
public long warnTime
public long totalProcessed
public double totalTime
public int queueProcessedLast
public double lastMS
public int hashsetMaxLength
public int queueLength
public int get_queueLength()
public void Clear()
public void RunQueue(double maximumMilliseconds)
public void Add(T entity)
public bool Contains(T entity)
protected void SortQueue()
protected bool ShouldAdd(T entity)
protected void RunJob(T entity)
public string Info()
}
public Rust.AmmoTypes : Enum {
public int value__
public AmmoTypes PISTOL_9MM
public AmmoTypes RIFLE_556MM
public AmmoTypes SHOTGUN_12GUAGE
public AmmoTypes BOW_ARROW
public AmmoTypes HANDMADE_SHELL
public AmmoTypes ROCKET
public AmmoTypes NAILS
}
public Rust.Application : object {
public bool isQuitting
public bool isLoading
public bool isReceiving
public bool isLoadingSave
public string installPath
public string dataPath
public void Quit()
public string get_installPath()
public string get_dataPath()
}
public Rust.AsyncTextureLoad : CustomYieldInstruction {
private IntPtr buffer
private int size
private int width
private int height
private int format
private string filename
private string cachename
private bool normal
private bool dither
private bool hqmode
private bool cache
private Action worker
public bool keepWaiting
public bool isDone
public bool isValid
public Texture2D texture
public bool get_keepWaiting()
public bool get_isDone()
public bool get_isValid()
public Texture2D get_texture()
public void LoadIntoTexture(Texture2D tex)
private void FreeTexture(IntPtr& buffer)
private void LoadTextureFromFile(string filename, IntPtr& buffer, Int32& size, Int32& width, Int32& height, Int32& channels, bool normal, bool dither, bool hqmode)
private void LoadTextureFromCache(string filename, IntPtr& buffer, Int32& size, Int32& width, Int32& height, Int32& format)
private void SaveTextureToCache(string filename, IntPtr buffer, int size, int width, int height, int format)
public void .ctor(string filename, bool normal, bool dither, bool hqmode, bool cache)
private bool CanLoadFromCache()
private bool CanSaveToCache()
private void DoWork()
private void Invoke()
private void Callback(IAsyncResult result)
}
public Rust.Components.Camera.DepthOfFieldFocusPoint : ListComponent`1<DepthOfFieldFocusPoint> {
private Renderer renderer
public Vector3 FocusPoint
public Vector3 get_FocusPoint()
protected void OnEnable()
public DepthOfFieldFocusPoint Evaluate(Camera cam)
private float Score(Camera cam)
}
public Rust.Components.Camera.LightingOverride : MonoBehaviour {
public bool overrideAmbientLight
public AmbientMode ambientMode
public Color ambientGroundColor
public Color ambientEquatorColor
public Color ambientLight
public float ambientIntensity
internal Color old_ambientLight
internal Color old_ambientGroundColor
internal Color old_ambientEquatorColor
internal float old_ambientIntensity
internal AmbientMode old_ambientMode
public float aspect
private void OnPreRender()
private void OnPostRender()
}
internal Rust.Components.Utility.OnObjectDisable : MonoBehaviour {
public UnityEvent Action
private void OnDisable()
}
internal Rust.Components.Utility.OnObjectEnable : MonoBehaviour {
public UnityEvent Action
private void OnEnable()
}
public Rust.Global : object {
private Client <SteamClient>k__BackingField
private Server <SteamServer>k__BackingField
public Func`2<string, GameObject> FindPrefab
public Func`2<string, GameObject> CreatePrefab
public Action OpenMainMenu
private MonoBehaviour _runner
private Process _process
public Client SteamClient
public Server SteamServer
public MonoBehaviour Runner
public Process Process
public Client get_SteamClient()
public void set_SteamClient(Client value)
public Server get_SteamServer()
public void set_SteamServer(Server value)
public MonoBehaviour get_Runner()
public Process get_Process()
}
public Rust.IEntity {
public bool IsDestroyed
public bool get_IsDestroyed()
}
public Rust.ImageEffects.IconOutline : MonoBehaviour {
public Material Material
private void OnEnable()
private void OnDisable()
private void OnRenderImage(RenderTexture source, RenderTexture destination)
}
public Rust.Layer : Enum {
public int value__
public Layer Default
public Layer TransparentFX
public Layer Ignore_Raycast
public Layer Reserved1
public Layer Water
public Layer UI
public Layer Reserved2
public Layer Reserved3
public Layer Deployed
public Layer Ragdoll
public Layer Invisible
public Layer AI
public Layer Player_Movement
public Layer Vehicle_Movement
public Layer Game_Trace
public Layer Reflections
public Layer World
public Layer Player_Server
public Layer Trigger
public Layer Player_Model_Rendering
public Layer Unused1
public Layer Construction
public Layer Construction_Socket
public Layer Terrain
public Layer Transparent
public Layer Clutter
public Layer Debris
public Layer Occluder
public Layer Prevent_Movement
public Layer Prevent_Building
public Layer Tree
public Layer Unused2
}
public Rust.Layers : object {
public int Terrain
public int World
public int Ragdolls
public int Construction
public int ConstructionSocket
public int Craters
public int GameTrace
public int Trigger
public int RainFall
public int Deploy
public int DefaultDeployVolumeCheck
public int BuildLineOfSightCheck
public int ProjectileLineOfSightCheck
public int MeleeLineOfSightCheck
public int EyeLineOfSightCheck
public int EntityLineOfSightCheck
public int PlayerBuildings
public int PlannerPlacement
public int Solid
public int VisCulling
}
public Rust.PropRenderer : MonoBehaviour {
public bool HideLowLods
public bool HideUnskinnable
public bool Outline
public Vector3 Rotation
public Vector3 PostRotation
public Vector3 PositionalTweak
public float FieldOfView
public Vector3 LookDirection
public Vector3 UpDirection
public void DebugAlign()
public void PositionCamera(Camera cam)
public void PreRender()
public void PostRender()
public void CreateIcon()
public void CreateRender()
public void CreateScreenshot(string filename, int width, int height, int SuperSampleSize, LightIntensityScale lightIntensityScale)
public void RenderScreenshot(GameObject prefab, string filename, int width, int height, int SuperSampleSize)
}
public Rust.PropRendererDebug : MonoBehaviour {
public void Update()
}
public Rust.Rarity : Enum {
public int value__
public Rarity None
public Rarity Common
public Rarity Uncommon
public Rarity Rare
public Rarity VeryRare
}
public Rust.Registry.Entity : object {
private Dictionary`2<GameObject, IEntity> _dict
public void Register(GameObject obj, IEntity entity)
public IEntity Get(GameObject obj)
public void Unregister(GameObject obj)
}
public SeedEx : object {
public UInt32 Seed(Vector2 v, UInt32 baseSeed)
public UInt32 Seed(Vector3 v, UInt32 baseSeed)
public UInt32 Seed(Vector4 v, UInt32 baseSeed)
}
public SeedRandom : object {
public UInt32 Seed
public void .ctor(UInt32 seed)
public int Range(int min, int max)
public int Range(UInt32 seed, int min, int max)
public int Range(UInt32& seed, int min, int max)
public float Range(float min, float max)
public float Range(UInt32 seed, float min, float max)
public float Range(UInt32& seed, float min, float max)
public int Sign()
public int Sign(UInt32 seed)
public int Sign(UInt32& seed)
public float Value()
public float Value(UInt32 seed)
public float Value(UInt32& seed)
public Vector2 Value2D()
public Vector2 Value2D(UInt32 seed)
public Vector2 Value2D(UInt32& seed)
public UInt32 Wanghash(UInt32& x)
public float Wanghash01(UInt32& x)
public UInt32 Xorshift(UInt32& x)
public float Xorshift01(UInt32& x)
}
public Sphere : ValueType {
public Vector3 position
public float radius
public void .ctor(Vector3 position, float radius)
public bool Contains(Vector3 target)
public Vector3 ClosestPoint(Vector3 target)
public void Move(Vector3 direction, float distance, int layerMask)
public bool Trace(Ray ray, RaycastHit& hit, float maxDistance)
}
public Triangle : ValueType {
public Vector3 point0
public Vector3 point1
public Vector3 point2
public Vector3 Normal
public Vector3 Center
public void .ctor(Vector3 point0, Vector3 point1, Vector3 point2)
public bool Trace(Ray ray, float radius, RaycastHit& hit, float maxDistance)
private bool LineTest(Vector3 a, Vector3 b, Ray ray, float radius, RaycastHit& hit, float maxDistance)
public Vector3 get_Normal()
public Vector3 get_Center()
public Vector3 ClosestPoint(Vector3 pos)
public float Distance(Vector3 pos)
public float SqrDistance(Vector3 pos)
}
public UnityEngine.MathEx : object {
public float SnapTo(float val, float snapValue)
public bool QuadTest(Ray ray, Vector3 planeCenter, Quaternion planeRot, Vector2 planeSize, Vector3& hitPosition, float gridSize)
}
public UnityEngine.Vector2Ex : object {
public Vector2 Parse(string p)
public Vector2 Rotate(Vector2 v, float degrees)
}
public UnityEngine.Vector3Ex : object {
public float Distance2D(Vector3 a, Vector3 b)
public Vector3 Direction2D(Vector3 aimAt, Vector3 aimFrom)
public Vector3 Range(float x, float y)
public Vector3 Scale(Vector3 vector, float x, float y, float z)
public Vector3 SnapTo(Vector3 vector, float snapValue)
public Vector3 Inverse(Vector3 v)
public float SignedAngle(Vector3 v1, Vector3 v2, Vector3 n)
public bool IsNaNOrInfinity(Vector3 v)
public float DotRadians(Vector3 a, Vector3 b)
public float DotDegrees(Vector3 a, Vector3 b)
public float Magnitude2D(Vector3 v)
public float SqrMagnitude2D(Vector3 v)
public float MagnitudeXY(Vector3 v)
public float SqrMagnitudeXY(Vector3 v)
public float MagnitudeXZ(Vector3 v)
public float SqrMagnitudeXZ(Vector3 v)
public float MagnitudeYZ(Vector3 v)
public float SqrMagnitudeYZ(Vector3 v)
public Vector3 XY3D(Vector3 v)
public Vector3 XZ3D(Vector3 v)
public Vector3 YZ3D(Vector3 v)
public Vector2 XY2D(Vector3 v)
public Vector2 XZ2D(Vector3 v)
public Vector2 YZ2D(Vector3 v)
public Vector2 YX2D(Vector3 v)
public Vector2 ZX2D(Vector3 v)
public Vector2 ZY2D(Vector3 v)
public float Max(Vector4 v)
public float Max(Vector3 v)
public float Max(Vector2 v)
public Vector4 Abs(Vector4 v)
public Vector3 Abs(Vector3 v)
public Vector2 Abs(Vector2 v)
public Vector3 Parse(string p)
}
public Vector2b : ValueType {
public Vector2b alltrue
public Vector2b allfalse
public bool x
public bool y
public void .ctor(bool x, bool y)
public bool op_Equality(Vector2b a, Vector2b b)
public bool op_Inequality(Vector2b a, Vector2b b)
public bool Equals(Vector2b o)
public int GetHashCode()
public bool Equals(object o)
public string ToString()
}
public Vector2i : ValueType {
public Vector2i zero
public Vector2i one
public Vector2i left
public Vector2i right
public Vector2i forward
public Vector2i back
public int x
public int y
public void .ctor(int x, int y)
public Vector2i op_RightShift(Vector2i v, int shift)
public Vector2i op_LeftShift(Vector2i v, int shift)
public Vector2i op_UnaryPlus(Vector2i v)
public Vector2i op_UnaryNegation(Vector2i v)
public Vector2i op_Addition(Vector2i a, Vector2i b)
public Vector2i op_Subtraction(Vector2i a, Vector2i b)
public Vector2i op_Multiply(Vector2i v, int multiplier)
public Vector2i op_Division(Vector2i v, int divisor)
public Vector2 op_Multiply(Vector2i v, float multiplier)
public Vector2 op_Division(Vector2i v, float divisor)
public Vector2i op_Modulus(Vector2i v, int mod)
public Vector2 op_Implicit(Vector2i other)
public Vector2i op_Explicit(Vector2 other)
public bool op_Equality(Vector2i a, Vector2i b)
public bool op_Inequality(Vector2i a, Vector2i b)
public bool Equals(Vector2i o)
public int GetHashCode()
public bool Equals(object o)
public string ToString()
}
public Vector3b : ValueType {
public Vector3b alltrue
public Vector3b allfalse
public bool x
public bool y
public bool z
public void .ctor(bool x, bool y, bool z)
public bool op_Equality(Vector3b a, Vector3b b)
public bool op_Inequality(Vector3b a, Vector3b b)
public bool Equals(Vector3b o)
public int GetHashCode()
public bool Equals(object o)
public string ToString()
}
public Vector3i : ValueType {
public Vector3i zero
public Vector3i one
public Vector3i forward
public Vector3i back
public Vector3i up
public Vector3i down
public Vector3i right
public Vector3i left
public int x
public int y
public int z
public void .ctor(int x, int y, int z)
public Vector3i op_RightShift(Vector3i v, int shift)
public Vector3i op_LeftShift(Vector3i v, int shift)
public Vector3i op_UnaryPlus(Vector3i v)
public Vector3i op_UnaryNegation(Vector3i v)
public Vector3i op_Addition(Vector3i a, Vector3i b)
public Vector3i op_Subtraction(Vector3i a, Vector3i b)
public Vector3i op_Multiply(Vector3i v, int multiplier)
public Vector3i op_Division(Vector3i v, int divisor)
public Vector3 op_Multiply(Vector3i v, float multiplier)
public Vector3 op_Division(Vector3i v, float divisor)
public Vector3i op_Modulus(Vector3i v, int mod)
public Vector3 op_Implicit(Vector3i other)
public Vector3i op_Explicit(Vector3 other)
public bool op_Equality(Vector3i a, Vector3i b)
public bool op_Inequality(Vector3i a, Vector3i b)
public bool Equals(Vector3i o)
public int GetHashCode()
public bool Equals(object o)
public string ToString()
}
public WorldSpaceGrid`1 : object {
public T[] Cells
public float CellSize
public float CellSizeHalf
public float CellSizeInverse
public float CellArea
public int CellCount
public int CellCountHalf
public T Item
public T Item
public T Item
public void .ctor(float gridSize, float cellSize)
public T get_Item(Vector3 worldPos)
public void set_Item(Vector3 worldPos, T value)
public T get_Item(Vector2i cellCoords)
public void set_Item(Vector2i cellCoords, T value)
public T get_Item(int x, int y)
public void set_Item(int x, int y, T value)
public Vector2i WorldToGridCoords(Vector3 worldPos)
public Vector3 GridToWorldCoords(Vector2i cellPos)
}
