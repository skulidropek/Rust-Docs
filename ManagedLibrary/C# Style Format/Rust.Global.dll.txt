public AABB : ValueType {
public Vector3 position
public Vector3 extents
public void .ctor(Vector3 position, Vector3 size)
public bool Contains(Vector3 target)
public Vector3 ClosestPoint(Vector3 target)
public bool Trace(Ray ray, RaycastHit& hit, float radius, float maxDistance)
}
public ArrayIndexIsEnum : PropertyAttribute {
public Type enumType
}
public ArrayIndexIsEnumRanged : ArrayIndexIsEnum {
public float min
public float max
}
public AssetPool : object {
public Dictionary`2<Type, Pool> storage
public T Get()
public void Free(Mesh& mesh)
private Pool GetPool()
public void Clear()
}
public Capsule : ValueType {
public Vector3 position
public float radius
public float extent
public void .ctor(Vector3 position, float radius, float extent)
public bool Contains(Vector3 target)
public Vector3 ClosestPoint(Vector3 target)
public void Move(Vector3 direction, float distance, int layerMask)
public bool Trace(Ray ray, RaycastHit& hit, float rayRadius, float maxDistance)
}
public CRC : object {
private Byte[] byteBuffer
private UInt32[] crc32_tab
private UInt64[] crc64_tab
public UInt32 Compute32(UInt32 crc, int i)
public UInt32 Compute32(UInt32 crc, UInt32 u)
public UInt32 Compute32(UInt32 crc, float f)
public UInt32 Compute32(UInt32 crc, long i)
public UInt32 Compute32(UInt32 crc, ulong u)
public UInt32 Compute32(UInt32 crc, double f)
public UInt32 Compute32(UInt32 crc, string str)
public UInt32 Compute32(String[] strs)
public ulong Compute64(ulong crc, int i)
public ulong Compute64(ulong crc, UInt32 u)
public ulong Compute64(ulong crc, float f)
public ulong Compute64(ulong crc, long i)
public ulong Compute64(ulong crc, ulong u)
public ulong Compute64(ulong crc, double f)
public ulong Compute64(ulong crc, string str)
public ulong Compute64(String[] strs)
private int GrowByteBuffer(int count)
private UInt32 CRC32(UInt32 value, Byte[] buf, ulong size)
private ulong CRC64(ulong value, Byte[] buf, ulong size)
}
public Cylinder : ValueType {
public Vector3 position
public float radius
public float extent
public void .ctor(Vector3 position, float radius, float extent)
public bool Contains(Vector3 target)
public Vector3 ClosestPoint(Vector3 target)
}
public Facepunch.GameObjectPool`1 : ObjectPool`1<T> {
private GameObject poolRoot
public void AddToPool(T t)
public void AddChildrenToPool(Transform t)
public T TakeOrInstantiate(GameObject prefabSource)
}
public Facepunch.Instantiate : object {
public GameObject GameObject(GameObject go, Transform parent)
public GameObject GameObject(GameObject go, Vector3 pos, Quaternion rot)
}
public Facepunch.ObjectPool`1 : object {
public List`1<T> list
public void AddToPool(T t)
public T TakeFromPool()
}
public Facepunch.Tick : object {
private List Timed
private List Update
private List Late
private List`1<Object> RemoveList
public void AddTimed(Object obj, float minDelay, float maxDelay, Action action, string DebugName)
public void Add(Object obj, Action action, string DebugName)
public void AddLateUpdate(Object obj, Action action, string DebugName)
public void RemoveAll(Object obj)
private void Cleanup()
internal void OnFrame()
internal void OnFrameLate()
}
public Facepunch.TickComponent : MonoBehaviour {
public TickComponent Instance
public void Init()
private void OnEnable()
private void Update()
private void LateUpdate()
}
public HorizontalAttribute : PropertyAttribute {
public int count
public int label
public void .ctor(int count, int label)
}
public IClientComponentEx {
public void PreClientComponentCull(IPrefabProcessor p)
}
public IPrefabPostProcess {
public void PostProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
}
public IPrefabPreProcess {
public void PreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
}
public IPrefabProcessor {
public void RemoveComponent(Component component)
public void NominateForDeletion(GameObject obj)
}
public IServerComponentEx {
public void PreServerComponentCull(IPrefabProcessor p)
}
public Line : ValueType {
public Vector3 point0
public Vector3 point1
public void .ctor(Vector3 point0, Vector3 point1)
public void .ctor(Vector3 origin, Vector3 direction, float length)
public bool Trace(Ray ray, float radius, RaycastHit& hit, float maxDistance)
public Vector3 ClosestPoint(Vector3 pos)
public Vector3 ClosestPoint2D(Vector3 pos)
public float Distance(Vector3 pos)
public float SqrDistance(Vector3 pos)
}
public ListEx : object {
public T GetRandom(List`1<T> list)
public T GetRandom(List`1<T> list, UInt32 seed)
public T GetRandom(List`1<T> list, UInt32& seed)
public void Shuffle(List`1<T> list, UInt32 seed)
public void Shuffle(List`1<T> list, UInt32& seed)
public void BubbleSort(List`1<T> list)
public void RemoveUnordered(List`1<T> list, int index)
public double TruncatedAverage(List`1<double> list, float pct)
}
public MaterialReplacement : MonoBehaviour {
private bool initialized
public Material[] Default
public Material[] Override
public Renderer Renderer
public void ReplaceRecursive(GameObject go, Material mat)
public void ReplaceRecursive(GameObject obj, Material[] find, Material[] replace)
public void Prepare(GameObject go)
private bool MaterialsContainAny(Material[] source, Material[] find)
public void Reset(GameObject go)
private void Init()
private void Replace(Material mat)
private void Replace(Material find, Material replace)
private void Replace(Material[] find, Material[] replace)
private void Revert()
}
public Mathx : object {
public float Increment(float f)
public float Decrement(float f)
public float Above(float latitude, float lower, float fade)
public float Tween(float latitude, float lower, float upper, float fade)
public float Below(float latitude, float upper, float fade)
public Color Lerp3(float f1, Color c1, float f2, Color c2, float f3, Color c3)
public int Clamp(int v, int min, int max)
public int Sign(int v)
public float SmoothMax(float a, float b, float fade)
public float Discretize01(float v, int steps)
public float Min(float f1, float f2, float f3)
public float Min(float f1, float f2, float f3, float f4)
public int Min(int f1, int f2, int f3)
public int Min(int f1, int f2, int f3, int f4)
public float Max(float f1, float f2, float f3)
public float Max(float f1, float f2, float f3, float f4)
public int Max(int f1, int f2, int f3)
public int Max(int f1, int f2, int f3, int f4)
public UInt32 Min(UInt32 i1, UInt32 i2)
public UInt32 Max(UInt32 i1, UInt32 i2)
public float fsel(float c, float x, float y)
public float RemapValClamped(float val, float A, float B, float C, float D)
}
public OBB : ValueType {
public Quaternion rotation
public Vector3 position
public Vector3 extents
public Vector3 forward
public Vector3 right
public Vector3 up
public float reject
public void .ctor(Transform transform, Bounds bounds)
public void .ctor(Vector3 position, Vector3 scale, Quaternion rotation, Bounds bounds)
public void .ctor(Vector3 position, Quaternion rotation, Bounds bounds)
public void .ctor(Vector3 position, Vector3 size, Quaternion rotation)
public void Transform(Vector3 position, Vector3 scale, Quaternion rotation)
public Vector3 GetPoint(float x, float y, float z)
public Bounds ToBounds()
public bool Contains(Vector3 target)
public bool Intersects(OBB target)
public bool Intersects2D(OBB target)
public bool Intersects(Ray ray)
public bool Trace(Ray ray, RaycastHit& hit, float maxDistance)
public Vector3 ClosestPoint(Vector3 target)
public float Distance(OBB other)
public float Distance(Vector3 position)
public float SqrDistance(OBB other)
public float SqrDistance(Vector3 position)
}
public ObjectWorkQueue`1 : object {
protected Queue`1<T> queue
protected HashSet`1<T> containerTest
public string queueName
public long warnTime
public long totalProcessed
public double totalTime
public int queueProcessedLast
public double lastMS
public int hashsetMaxLength
private Stopwatch stopwatch
public int queueLength
public int get_queueLength()
public void Clear()
public void RunQueue(double maximumMilliseconds)
public void Add(T entity)
public bool Contains(T entity)
protected void SortQueue()
protected bool ShouldAdd(T entity)
protected void RunJob(T entity)
public string Info()
}
public Rust.AmmoTypes : Enum {
public int value__
public AmmoTypes PISTOL_9MM
public AmmoTypes RIFLE_556MM
public AmmoTypes SHOTGUN_12GUAGE
public AmmoTypes BOW_ARROW
public AmmoTypes HANDMADE_SHELL
public AmmoTypes ROCKET
public AmmoTypes NAILS
public AmmoTypes AMMO_40MM
public AmmoTypes SNOWBALL
public AmmoTypes SPEARGUN_BOLT
public AmmoTypes TORPEDO
public AmmoTypes MLRS_ROCKET
}
public Rust.Application : object {
public bool isQuitting
public bool isLoading
public bool isReceiving
public bool isLoadingSave
public bool isLoadingPrefabs
public string installPath
public string dataPath
public void Quit()
public string get_installPath()
public string get_dataPath()
}
public Rust.AsyncTextureLoad : CustomYieldInstruction {
private IntPtr buffer
private int size
private int width
private int height
private int format
public string filename
public bool normal
public bool dither
public bool hqmode
public bool cache
private Action worker
public bool keepWaiting
public bool isDone
public bool isValid
public Texture2D texture
public bool get_keepWaiting()
public bool get_isDone()
public bool get_isValid()
public Texture2D get_texture()
public void LoadIntoTexture(Texture2D tex)
public void WriteToCache(string cachename)
private void FreeTexture(IntPtr& buffer)
private void LoadTextureFromFile(string filename, IntPtr& buffer, Int32& size, Int32& width, Int32& height, Int32& channels, bool normal, bool dither, bool hqmode)
private void LoadTextureFromCache(string filename, IntPtr& buffer, Int32& size, Int32& width, Int32& height, Int32& format)
private void SaveTextureToCache(string filename, IntPtr buffer, int size, int width, int height, int format)
public void .ctor(string filename, bool normal, bool dither, bool hqmode, bool cache)
private void DoWork()
private void Invoke()
private void Callback(IAsyncResult result)
}
public Rust.Components.Camera.DepthOfFieldFocusPoint : ListComponent`1<DepthOfFieldFocusPoint> {
private Renderer cachedRenderer
public Vector3 FocusPoint
public Vector3 get_FocusPoint()
protected void OnEnable()
public DepthOfFieldFocusPoint Evaluate(Camera cam)
private float Score(Camera cam)
}
public Rust.Components.Camera.LightingOverride : MonoBehaviour {
public bool overrideAmbientLight
public AmbientMode ambientMode
public Color ambientGroundColor
public Color ambientEquatorColor
public Color ambientLight
public float ambientIntensity
internal Color old_ambientLight
internal Color old_ambientGroundColor
internal Color old_ambientEquatorColor
internal float old_ambientIntensity
internal AmbientMode old_ambientMode
public float aspect
private void OnPreRender()
private void OnPostRender()
}
internal Rust.Components.Utility.OnObjectDisable : MonoBehaviour {
public UnityEvent Action
private void OnDisable()
}
internal Rust.Components.Utility.OnObjectEnable : MonoBehaviour {
public UnityEvent Action
private void OnEnable()
}
public Rust.Global : object {
public Func`2<string, GameObject> LoadPrefab
public Func`2<string, GameObject> FindPrefab
public Func`2<string, GameObject> CreatePrefab
public Action OpenMainMenu
private MonoBehaviour _runner
private int <LaunchCountThisVersion>k__BackingField
public MonoBehaviour Runner
public int LaunchCountThisVersion
public MonoBehaviour get_Runner()
public int get_LaunchCountThisVersion()
private void set_LaunchCountThisVersion(int value)
public void Init()
}
public Rust.IEntity {
public bool IsDestroyed
public bool get_IsDestroyed()
}
public Rust.ImageEffects.IconOutline : MonoBehaviour {
public Material Material
private void OnEnable()
private void OnDisable()
private void OnRenderImage(RenderTexture source, RenderTexture destination)
}
public Rust.Layer : Enum {
public int value__
public Layer Default
public Layer TransparentFX
public Layer Ignore_Raycast
public Layer Reserved1
public Layer Water
public Layer UI
public Layer Reserved2
public Layer Reserved3
public Layer Deployed
public Layer Ragdoll
public Layer Invisible
public Layer AI
public Layer Player_Movement
public Layer Vehicle_Detailed
public Layer Game_Trace
public Layer Vehicle_World
public Layer World
public Layer Player_Server
public Layer Trigger
public Layer Player_Model_Rendering
public Layer Physics_Projectile
public Layer Construction
public Layer Construction_Socket
public Layer Terrain
public Layer Transparent
public Layer Clutter
public Layer Debris
public Layer Vehicle_Large
public Layer Prevent_Movement
public Layer Prevent_Building
public Layer Tree
public Layer Unused2
}
public Rust.Layers : object {
public int Terrain
public int World
public int Ragdolls
public int Construction
public int ConstructionSocket
public int Craters
public int GameTrace
public int Trigger
public int VehiclesDetailed
public int RainFall
public int Deploy
public int DefaultDeployVolumeCheck
public int BuildLineOfSightCheck
public int ProjectileLineOfSightCheck
public int ProjectileLineOfSightCheckTerrain
public int MeleeLineOfSightCheck
public int MeleeLineOfSightCheckTerrain
public int EyeLineOfSightCheck
public int EyeLineOfSightCheckTerrain
public int EntityLineOfSightCheck
public int PlayerBuildings
public int PlannerPlacement
public int Solid
public int StaticSolid
public int VisCulling
public int HABGroundEffect
public int AILineOfSight
public int DismountCheck
public int AIPlacement
public int WheelRay
public int Water
public int Sprays
}
public Rust.PropRenderer : MonoBehaviour {
public bool HideLowLods
public bool HideUnskinnable
public bool Outline
public Vector3 Rotation
public Vector3 PostRotation
public Vector3 PositionalTweak
public float FieldOfView
public Vector3 LookDirection
public Vector3 UpDirection
public void DebugAlign()
public void PositionCamera(Camera cam)
public void PreRender()
public void PostRender()
public void CreateIcon()
public void CreateRender()
private float DefaultLightIntensityScale(float intensity)
public void CreateScreenshot(string filename, int width, int height, int SuperSampleSize, LightIntensityScale lightIntensityScale)
public bool RenderScreenshot(GameObject prefab, string filename, int width, int height, int SuperSampleSize)
}
public Rust.PropRendererDebug : MonoBehaviour {
public void Update()
}
public Rust.Protocol : object {
public int network
public int save
public int report
public int persistance
public string printable
public string get_printable()
}
public Rust.Rarity : Enum {
public int value__
public Rarity None
public Rarity Common
public Rarity Uncommon
public Rarity Rare
public Rarity VeryRare
}
public Rust.Registry.Entity : object {
private Dictionary`2<Transform, IEntity> _dict
public void Register(Transform t, IEntity entity)
public IEntity Get(Transform t)
public void Unregister(Transform t)
public void Register(GameObject obj, IEntity entity)
public IEntity Get(GameObject obj)
public void Unregister(GameObject obj)
}
public SeedEx : object {
public UInt32 Seed(Vector2 v, UInt32 baseSeed)
public UInt32 Seed(Vector3 v, UInt32 baseSeed)
public UInt32 Seed(Vector4 v, UInt32 baseSeed)
}
public SeedRandom : object {
public UInt32 Seed
public void .ctor(UInt32 seed)
public int Range(int min, int max)
public int Range(UInt32 seed, int min, int max)
public int Range(UInt32& seed, int min, int max)
public float Range(float min, float max)
public float Range(UInt32 seed, float min, float max)
public float Range(UInt32& seed, float min, float max)
public int Sign()
public int Sign(UInt32 seed)
public int Sign(UInt32& seed)
public float Value()
public float Value(UInt32 seed)
public float Value(UInt32& seed)
public Vector2 Value2D()
public Vector2 Value2D(UInt32 seed)
public Vector2 Value2D(UInt32& seed)
public UInt32 Wanghash(UInt32& x)
public float Wanghash01(UInt32& x)
public UInt32 Xorshift(UInt32& x)
public float Xorshift01(UInt32& x)
}
public Sphere : ValueType {
public Vector3 position
public float radius
public void .ctor(Vector3 position, float radius)
public bool Contains(Vector3 target)
public Vector3 ClosestPoint(Vector3 target)
public void Move(Vector3 direction, float distance, int layerMask)
public bool Trace(Ray ray, RaycastHit& hit, float maxDistance)
}
public StringBuilderEx : object {
public void Clear(StringBuilder value)
}
public TextBuffer : object {
private Queue`1<string> buffer
private StringBuilder builder
private string text
private bool dirty
private int curlines
private int maxlines
private int curchars
private int maxchars
public int Count
public int get_Count()
public void .ctor(int maxlines, int maxchars)
public void Add(string text)
public void Remove()
public void Clear()
public string Get(int index)
public string ToString()
}
public TextTable : object {
private List`1<Row> rows
private List`1<Column> columns
private StringBuilder builder
private string text
private bool dirty
public void Clear()
public void AddColumns(String[] values)
public void AddColumn(string title)
public void AddRow(String[] values)
public string ToString()
}
public Triangle : ValueType {
public Vector3 point0
public Vector3 point1
public Vector3 point2
public Vector3 Normal
public Vector3 Center
public void .ctor(Vector3 point0, Vector3 point1, Vector3 point2)
public bool Trace(Ray ray, float radius, RaycastHit& hit, float maxDistance)
private bool LineTest(Vector3 a, Vector3 b, Ray ray, float radius, RaycastHit& hit, float maxDistance)
public Vector3 get_Normal()
public Vector3 get_Center()
public Vector3 ClosestPoint(Vector3 pos)
public float Distance(Vector3 pos)
public float SqrDistance(Vector3 pos)
}
public UnityEngine.MathEx : object {
public float SnapTo(float val, float snapValue)
public bool QuadTest(Ray ray, Vector3 planeCenter, Quaternion planeRot, Vector2 planeSize, Vector3& hitPosition, float gridSize)
public float BiasedLerp(float x, float bias)
public float Bias(float x, float bias)
}
public UnityEngine.StringEx : object {
private Regex regexNumeric
private Regex regexAlphaNumeric
public string Replace(string originalString, string oldValue, string newValue, StringComparison comparisonType)
public bool Contains(string haystack, string needle, CompareOptions options)
public bool IsLower(string str)
public string ToPrintable(string str, int maxLength)
public bool IsNumeric(string str)
public bool IsAlphaNumeric(string str)
public string EscapeRichText(string str)
public IEnumerable`1<string> SplitToLines(string input)
public IEnumerable`1<string> SplitToChunks(string str, int chunkLength)
public UInt32 ManifestHash(string str)
public bool StartsWithAny(string str, String[] values)
}
public UnityEngine.Vector2Ex : object {
public Vector2 WithX(Vector2 v, float x)
public Vector2 WithY(Vector2 v, float y)
public Vector2 Parse(string p)
public Vector2 Rotate(Vector2 v, float degrees)
public float Length(float x, float y)
public float Length(Vector2 vec)
public Vector2 X(Vector2 v, float x)
public Vector2 Y(Vector2 v, float y)
public Vector2 ToCanvas(Vector2 v, RectTransform target, Camera cam)
}
public UnityEngine.Vector3Ex : object {
public Vector3 WithX(Vector3 v, float x)
public Vector3 WithY(Vector3 v, float y)
public Vector3 WithZ(Vector3 v, float z)
public Vector3 XZ(Vector3 v)
public float Distance2D(Vector3 a, Vector3 b)
public float HeightDelta(Vector3 a, Vector3 b)
public Vector3 Direction2D(Vector3 aimAt, Vector3 aimFrom)
public Vector3 Direction(Vector3 aimAt, Vector3 aimFrom)
public Vector3 Range(float x, float y)
public Vector3 Scale(Vector3 vector, float x, float y, float z)
public Vector3 SnapTo(Vector3 vector, float snapValue)
public Vector3 Inverse(Vector3 v)
public float SignedAngle(Vector3 v1, Vector3 v2, Vector3 n)
public void FastRenormalize(Vector3 n, float scale)
public void ToDirectionAndMagnitude(Vector3 value, Vector3& direction, Single& magnitude)
public Vector3 BlendNormals(Vector3 n1, Vector3 n2)
public bool IsNaNOrInfinity(Vector3 v)
public float DotRadians(Vector3 a, Vector3 b)
public float DotDegrees(Vector3 a, Vector3 b)
public float Magnitude2D(Vector3 v)
public float SqrMagnitude2D(Vector3 v)
public float MagnitudeXY(Vector3 v)
public float SqrMagnitudeXY(Vector3 v)
public float MagnitudeXZ(Vector3 v)
public float SqrMagnitudeXZ(Vector3 v)
public float MagnitudeYZ(Vector3 v)
public float SqrMagnitudeYZ(Vector3 v)
public Vector3 XY3D(Vector3 v)
public Vector3 XZ3D(Vector3 v)
public Vector3 YZ3D(Vector3 v)
public Vector2 XY2D(Vector3 v)
public Vector2 XZ2D(Vector3 v)
public Vector2 YZ2D(Vector3 v)
public Vector2 YX2D(Vector3 v)
public Vector2 ZX2D(Vector3 v)
public Vector2 ZY2D(Vector3 v)
public Vector3 XZ3D(Vector2 v)
public float Max(Vector4 v)
public float Max(Vector3 v)
public float Max(Vector2 v)
public Vector4 Abs(Vector4 v)
public Vector3 Abs(Vector3 v)
public Vector2 Abs(Vector2 v)
public Vector3 Parse(string p)
public Vector3 GetWithInaccuracy(Vector3 o, float maxAngle)
}
public WorldSpaceGrid : object {
public Vector3 ClosestGridCell(Vector3 worldPos, float gridSize, float cellSize)
}
public WorldSpaceGrid`1 : object {
public T[] Cells
public float CellSize
public float CellSizeHalf
public float CellSizeInverse
public float CellArea
public int CellCount
public int CellCountHalf
public T Item
public T Item
public T Item
public T Item
public void .ctor(float gridSize, float cellSize)
public T get_Item(Vector3 worldPos)
public void set_Item(Vector3 worldPos, T value)
public T get_Item(Vector2i cellCoords)
public void set_Item(Vector2i cellCoords, T value)
public T get_Item(int x, int y)
public void set_Item(int x, int y, T value)
public T get_Item(int index)
public void set_Item(int index, T value)
public Vector2i IndexToGridCoords(int index)
public Vector3 IndexToWorldCoords(int index)
public Vector2i WorldToGridCoords(Vector3 worldPos)
public Vector3 GridToWorldCoords(Vector2i cellPos)
public void Copy(WorldSpaceGrid`1<T> other)
}
