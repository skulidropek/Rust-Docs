public EasyAntiCheat.Client.ClientAuth.ClientAuth : object {
public void Dispose()
public void WriteChallengeResponse(Byte[] ServerChallenge, Byte[] ClientResponse)
}
internal EasyAntiCheat.Client.ClientAuth.NativeClientAuth : object {
private string DllFileName
private string InterfaceVersion
private IntPtr Instance
private IntPtr dotCreateClientAuth(string InterfaceVersion)
private void dotInitialize(IntPtr Instance)
private void dotDestroy(IntPtr Instance)
private void dotClientWriteChallengeResponse(IntPtr Instance, Byte[] ServerChallenge, Byte[] ClientResponse)
public void Initialize()
public void Dispose()
public void ClientWriteChallengeResponse(Byte[] ServerChallenge, Byte[] ClientResponse)
}
public EasyAntiCheat.Client.ClientIntegrityViolationType : Enum {
public int value__
public ClientIntegrityViolationType IntegrityViolationNone
public ClientIntegrityViolationType EACHashCatalogueFileNotFound
public ClientIntegrityViolationType EACHashCatalogueError
public ClientIntegrityViolationType EACHashCatalogueCertificateRevoked
public ClientIntegrityViolationType UnknownGameFileVersion
public ClientIntegrityViolationType RequiredGameFileNotFound
public ClientIntegrityViolationType UncataloguedGameFileForbidden
public ClientIntegrityViolationType UnknownSystemFileVersion
public ClientIntegrityViolationType ForbiddenModuleLoaded
public ClientIntegrityViolationType CorruptedMemory
public ClientIntegrityViolationType HackToolDetected
public ClientIntegrityViolationType InternalAntiCheatViolation
public ClientIntegrityViolationType CorruptedNetworkMessageFlow
public ClientIntegrityViolationType CannotRunUnderVirtualMachine
public ClientIntegrityViolationType ForbiddenSystemConfiguration
}
public EasyAntiCheat.Client.ConnectionDescriptor : ValueType {
private ConnectionStatus <Status>k__BackingField
private string <StatusMessage>k__BackingField
public bool Connected
public ConnectionStatus Status
public string StatusMessage
internal void .ctor(ConnectionStatus status, string statusMessage)
public bool get_Connected()
public ConnectionStatus get_Status()
private void set_Status(ConnectionStatus value)
public string get_StatusMessage()
private void set_StatusMessage(string value)
}
public EasyAntiCheat.Client.ConnectionStatus : Enum {
public int value__
public ConnectionStatus Disconnected
public ConnectionStatus DomainResolveError
public ConnectionStatus NetworkError
public ConnectionStatus Connected
}
public EasyAntiCheat.Client.Debug : object {
private TextWriter writer
public void SetOut(WriterDelegate writer)
public void SetOut(TextWriter writer)
public void WriteLine(object value)
public void WriteLine(string format, Object[] args)
}
internal EasyAntiCheat.Client.EventHandlerExtensions : object {
public void Raise(EventHandler`1<T> eventHandler, object sender, T eventArgs)
}
public EasyAntiCheat.Client.GameLauncher : object {
private LoadInfo loadInfo
private EventWaitHandle waitHandle
private ThreadSynchronizer eventContext
private LoadResult LoadResultCode
private string LoadResultMsg
private bool LoadCancelled
private int DisposedRef
private EventHandler`1<LoadCompletedEventArgs> Completed
private EventHandler`1<LoadProgressEventArgs> Progress
public LoadInfo Options
public void .ctor(string filename, string arguments, string workingDirectory)
public void .ctor(LoadInfo loadInfo)
public void add_Completed(EventHandler`1<LoadCompletedEventArgs> value)
public void remove_Completed(EventHandler`1<LoadCompletedEventArgs> value)
public void add_Progress(EventHandler`1<LoadProgressEventArgs> value)
public void remove_Progress(EventHandler`1<LoadProgressEventArgs> value)
public LoadInfo get_Options()
public void BeginLoad()
public void CancelLoad()
public void Dispose()
private void Load()
private UInt32 OnLoadProgress(UInt32 Progress, IntPtr CallbackParameter)
private void OnLoadFinished(LoadResult Result, string Message, IntPtr CallbackParameter)
private void RaiseCompleted(LoadResult Result, string Message)
private void RaiseProgress(LoadProgressEventArgs eventArgs)
private void <BeginLoad>b__18_0(object state)
}
public EasyAntiCheat.Client.HostValidationResult : Enum {
public int value__
public HostValidationResult ServerHostValidationSuccess
public HostValidationResult ServerHostValidationFailed
public HostValidationResult ServerHostValidationTimedOut
}
internal EasyAntiCheat.Client.Hydra.NativeClient : object {
private string InterfaceVersion
private INativeModule Module
private IntPtr Instance
private Byte[] StaticMsgBuf
private CallbackProgress nogcOnProgress
private CallbackFinished nogcOnFinished
private CallbackIntegrity nogcOnIntegrityViolation
private CallbackHostValidation nogcOnHostValidation
public bool IsStartedWithEasyAntiCheat()
public bool IsUnity()
public bool IsWindows()
public void Dispose()
public void Initialize(CallbackProgress OnProgress, CallbackFinished OnFinished, CallbackIntegrity OnIntegrityViolation, CallbackHostValidation OnHostValidation)
public void ConnectionReset()
public bool PopNetworkMessage(Byte[]& MessageBuffer, Int32& MessageLength)
public void SetMaxAllowedMessageLength(int MaxMessageLength)
public void PushNetworkMessage(Byte[] MessageBuffer, int MessageLength)
public void PollStatus()
public void ValidateServerHost(UInt32 TimeoutMs)
public IntPtr NetProtect()
}
internal EasyAntiCheat.Client.Hydra.NativeNetProtect : object {
private string DllFileName
private IntPtr Instance
private UInt32 dotProtectMessage(IntPtr Instance, Byte[] Input, UInt32 InputLength, Byte[] Output, UInt32& OutputLength)
private UInt32 dotProtectMessage_RawPtr(IntPtr Instance, IntPtr Input, UInt32 InputLength, IntPtr Output, UInt32& OutputLength)
private UInt32 dotUnprotectMessage(IntPtr Instance, Byte[] Input, UInt32 InputLength, Byte[] Output, UInt32& OutputLength)
private UInt32 dotUnprotectMessage_RawPtr(IntPtr Instance, IntPtr Input, UInt32 InputLength, IntPtr Output, UInt32& OutputLength)
private UInt32 dotGetProtectMessageOutputLength(IntPtr Instance, UInt32 InputLength)
public void SetInstance(IntPtr NetProtectInstance)
public bool ProtectMessage(MemoryStream Input, MemoryStream Output)
public bool ProtectMessage(MemoryStream Input, long InputOffset, MemoryStream Output, long OutputOffset)
public bool UnprotectMessage(MemoryStream Input, MemoryStream Output)
public bool UnprotectMessage(MemoryStream Input, long InputOffset, MemoryStream Output, long OutputOffset)
}
public EasyAntiCheat.Client.Hydra.NetProtect.INetProtect {
public bool ProtectMessage(MemoryStream Input, MemoryStream Output)
public bool ProtectMessage(MemoryStream Input, long InputOffset, MemoryStream Output, long OutputOffset)
public bool UnprotectMessage(MemoryStream Input, MemoryStream Output)
public bool UnprotectMessage(MemoryStream Input, long InputOffset, MemoryStream Output, long OutputOffset)
}
internal EasyAntiCheat.Client.Hydra.NetProtect.NetProtect : object {
public void .ctor(IntPtr Instance)
public bool ProtectMessage(MemoryStream Input, MemoryStream Output)
public bool ProtectMessage(MemoryStream Input, long InputOffset, MemoryStream Output, long OutputOffset)
public bool UnprotectMessage(MemoryStream Input, MemoryStream Output)
public bool UnprotectMessage(MemoryStream Input, long InputOffset, MemoryStream Output, long OutputOffset)
}
public EasyAntiCheat.Client.Hydra.Runtime : object {
private CallbackProgress nogc_AntiCheatProgress
private CallbackFinished nogc_AntiCheatEvent
private bool initializeCalled
private EventHandler`1<StateChangedEventArgs> onStateChanged
private EventHandler`1<LoadCompletedEventArgs> onLoadCompleted
private EventHandler`1<LoadProgressEventArgs> onProgress
private NetProtect _NetProtect
private bool <Initialized>k__BackingField
private IntegrityDescriptor <Integrity>k__BackingField
private HostValidationResult <HostValidation>k__BackingField
public bool Initialized
public IntegrityDescriptor Integrity
public HostValidationResult HostValidation
public INetProtect NetProtect
public bool get_Initialized()
private void set_Initialized(bool value)
public IntegrityDescriptor get_Integrity()
private void set_Integrity(IntegrityDescriptor value)
public HostValidationResult get_HostValidation()
private void set_HostValidation(HostValidationResult value)
public void Initialize(EventHandler`1<StateChangedEventArgs> onStateChanged, EventHandler`1<LoadCompletedEventArgs> onCompleted, EventHandler`1<LoadProgressEventArgs> onProgress)
public bool IsActive()
public void Release()
public void ConnectionReset()
public bool PopNetworkMessage(Byte[]& MessageBuffer, Int32& MessageLength)
public void SetMaxAllowedMessageLength(int MaxMessageLength)
public void PushNetworkMessage(Byte[] MessageBuffer, int MessageLength)
public void PollStatus()
public void ValidateServerHost(UInt32 TimeoutMs)
public INetProtect get_NetProtect()
private UInt32 OnInternalProgress(UInt32 Progress, IntPtr CallbackParameter)
private void OnInternalEvent(LoadResult Result, string Message, IntPtr CallbackParameter)
private UInt32 OnIntegrityViolation(ClientIntegrityViolationType ViolationType, string ViolationCause, string DefaultMessage, IntPtr CallbackParameter)
private bool OnHostValidation(HostValidationResult Result, string Message, IntPtr CallbackParameter)
}
public EasyAntiCheat.Client.InstallerInfo : object {
private bool <Allow>k__BackingField
private string <Filename>k__BackingField
private bool <Visible>k__BackingField
public bool Allow
public string Filename
public bool Visible
internal string FullPath
public bool get_Allow()
public void set_Allow(bool value)
public string get_Filename()
public void set_Filename(string value)
public bool get_Visible()
public void set_Visible(bool value)
internal string get_FullPath()
}
public EasyAntiCheat.Client.IntegrityDescriptor : ValueType {
private bool <Violated>k__BackingField
private string <ViolationMessage>k__BackingField
public bool Violated
public string ViolationMessage
public void .ctor(bool violated, string message)
public bool get_Violated()
private void set_Violated(bool value)
public string get_ViolationMessage()
private void set_ViolationMessage(string value)
}
internal EasyAntiCheat.Client.Legacy.NativeClient : object {
private string InterfaceVersion
private INativeModule Module
private IntPtr Instance
private CallbackProgress nogcOnProgress
private CallbackFinished nogcOnFinished
public bool IsStartedWithEasyAntiCheat()
public bool IsUnity()
public bool IsWindows()
public void Dispose()
public void Initialize(CallbackProgress OnProgress, CallbackFinished OnFinished)
public void SetUserToken(Byte[] UserToken, int SizeOfToken)
}
public EasyAntiCheat.Client.Legacy.Runtime : object {
private CallbackProgress nogc_AntiCheatProgress
private CallbackFinished nogc_AntiCheatEvent
private Byte[] userToken
private bool initializeCalled
private EventHandler`1<LoadProgressEventArgs> onProgress
private EventHandler`1<LoadCompletedEventArgs> onLoadCompleted
private EventHandler`1<StateChangedEventArgs> onStateChanged
private ConnectionDescriptor <Connection>k__BackingField
private bool <Initialized>k__BackingField
private IntegrityDescriptor <Integrity>k__BackingField
public ConnectionDescriptor Connection
public bool Initialized
public IntegrityDescriptor Integrity
public Byte[] UserToken
public ConnectionDescriptor get_Connection()
private void set_Connection(ConnectionDescriptor value)
public bool get_Initialized()
private void set_Initialized(bool value)
public IntegrityDescriptor get_Integrity()
private void set_Integrity(IntegrityDescriptor value)
public Byte[] get_UserToken()
public void set_UserToken(Byte[] value)
public void Initialize(EventHandler`1<LoadCompletedEventArgs> onCompleted, EventHandler`1<LoadProgressEventArgs> onProgress, EventHandler`1<StateChangedEventArgs> onStateChanged)
public bool IsActive()
public void Release()
private UInt32 OnInternalProgress(UInt32 Progress, IntPtr CallbackParameter)
private void OnInternalEvent(LoadResult Result, string Message, IntPtr CallbackParameter)
private void UpdateUserToken()
}
public EasyAntiCheat.Client.LoadCompletedEventArgs : LoadEventArgs {
private LoadResult <Status>k__BackingField
public LoadResult Status
internal void .ctor(LoadResult Result, string Message)
public LoadResult get_Status()
private void set_Status(LoadResult value)
public Process GetGameProcess()
public string ToString()
}
public EasyAntiCheat.Client.LoadEventArgs : EventArgs {
private string <Message>k__BackingField
public string Message
protected internal void .ctor(string message)
public string get_Message()
private void set_Message(string value)
public string ToString()
}
internal EasyAntiCheat.Client.LoadException : Exception {
private LoadResult <ExitCode>k__BackingField
public LoadResult ExitCode
public void .ctor(LoadResult exitCode, string message)
public void .ctor(LoadResult exitCode, string message, Exception innerException)
public LoadResult get_ExitCode()
public void set_ExitCode(LoadResult value)
}
public EasyAntiCheat.Client.LoadInfo : object {
private string <Arguments>k__BackingField
private string <Filename>k__BackingField
private string <WorkingDirectory>k__BackingField
private InstallerInfo <Installer>k__BackingField
public string Arguments
public string Filename
public string WorkingDirectory
public InstallerInfo Installer
public void .ctor(string filename, string arguments, string workingDirectory)
public string get_Arguments()
public void set_Arguments(string value)
public string get_Filename()
public void set_Filename(string value)
public string get_WorkingDirectory()
public void set_WorkingDirectory(string value)
public InstallerInfo get_Installer()
private void set_Installer(InstallerInfo value)
}
public EasyAntiCheat.Client.LoadProgressEventArgs : LoadEventArgs {
private int <Progress>k__BackingField
public int Progress
internal void .ctor(string message, int progress)
public int get_Progress()
private void set_Progress(int value)
}
public EasyAntiCheat.Client.LoadResult : Enum {
public int value__
public LoadResult InitSuccess
public LoadResult LauncherInvalidParameter
public LoadResult LauncherDNSError
public LoadResult LauncherNetworkError
public LoadResult LauncherFailure
public LoadResult LauncherInstallError
public LoadResult LauncherSuccessUnderWine
public LoadResult InitCancelRequested
public LoadResult GameClientConnected
public LoadResult GameClientDisconnected
public LoadResult GameClientAuthenticated
public LoadResult GameClientIntegrityViolation
}
internal EasyAntiCheat.Client.Monitor : object {
private object o
public void .ctor(object o)
public Monitor Enter(object o)
public void Dispose()
}
internal EasyAntiCheat.Client.NativeLauncher : object {
private LauncherProgress nogc_LauncherProgress
private LauncherFinished nogc_LauncherFinished
private string InterfaceVersion
private INativeModule Module
private IntPtr Instance
public void Dispose()
public void StartGame(bool InstallService, string ExecutablePath, string LaunchParameters, string WorkingDirectory, LauncherProgress OnProgress, LauncherFinished OnFinished)
public Process GetGameProcess()
}
internal EasyAntiCheat.Client.P2P.Cerberus.Cerberus`1 : object {
private Runtime`1<TClient> Runtime
internal void .ctor(IntPtr NativeInstance, Runtime`1<TClient> Runtime)
public void BeginFrame()
public void EndFrame()
public void LogGameRoundStart(string MapName)
public void LogGameRoundEnd(int WinningTeamID)
public void LogPlayerSpawn(TClient Player, int TeamID, int CharacterID)
public void LogPlayerDespawn(TClient Player)
public void LogPlayerKill(TClient PlayerVictim, TClient PlayerAttacker)
public void LogPlayerRevive(TClient PlayerRevived, TClient PlayerReviving)
public void LogPlayerTick(TClient Player, PlayerTick EventParams)
public void LogPlayerUseWeapon(TClient Player, PlayerUseWeapon EventParams)
public void LogPlayerTakeDamage(TClient PlayerVictim, TClient PlayerAttacker, PlayerTakeDamage EventParams)
internal void SetNativeInstance(IntPtr NativeInstance)
}
public EasyAntiCheat.Client.P2P.Cerberus.ICerberus`1 {
public void BeginFrame()
public void EndFrame()
public void LogGameRoundStart(string MapName)
public void LogGameRoundEnd(int WinningTeamID)
public void LogPlayerSpawn(TClient Player, int TeamID, int CharacterID)
public void LogPlayerDespawn(TClient Player)
public void LogPlayerKill(TClient ClientVictim, TClient ClientKiller)
public void LogPlayerRevive(TClient PlayerRevived, TClient PlayerReviving)
public void LogPlayerTick(TClient Player, PlayerTick EventParams)
public void LogPlayerUseWeapon(TClient Player, PlayerUseWeapon EventParams)
public void LogPlayerTakeDamage(TClient PlayerVictim, TClient PlayerAttacker, PlayerTakeDamage EventParams)
}
public EasyAntiCheat.Client.P2P.Cerberus.PlayerTakeDamage : ValueType {
public Vector3 VictimPosition
public Vector3 VictimViewAngles
public Vector3 AttackerPosition
public Vector3 AttackerViewAngles
public int AttackerFieldOfView
public int WeaponID
public int HitBoneID
public int DamageTaken
public PlayerTakeDamageFlags DamageFlags
}
public EasyAntiCheat.Client.P2P.Cerberus.PlayerTakeDamageFlags : Enum {
public int value__
public PlayerTakeDamageFlags PlayerTakeDamageNormalHit
public PlayerTakeDamageFlags PlayerTakeDamageCriticalHit
}
public EasyAntiCheat.Client.P2P.Cerberus.PlayerTick : ValueType {
public Vector3 Position
public Vector3 ViewAngles
public int Health
public PlayerTickFlags TickFlags
}
public EasyAntiCheat.Client.P2P.Cerberus.PlayerTickFlags : Enum {
public int value__
public PlayerTickFlags PlayerTickNone
public PlayerTickFlags PlayerTickCrouched
public PlayerTickFlags PlayerTickProned
public PlayerTickFlags PlayerTickMounted
public PlayerTickFlags PlayerTickDormant
public PlayerTickFlags PlayerTickSwimming
public PlayerTickFlags PlayerTickAirborne
public PlayerTickFlags PlayerTickClimbingLadder
}
public EasyAntiCheat.Client.P2P.Cerberus.PlayerUseWeapon : ValueType {
public Vector3 Position
public Vector3 ViewAngles
public int FieldOfView
public int WeaponID
}
public EasyAntiCheat.Client.P2P.Cerberus.Vector3 : ValueType {
public float X
public float Y
public float Z
public void .ctor(float x, float y, float z)
}
internal EasyAntiCheat.Client.P2P.NativeCerberus : object {
private string DllFileName
private IntPtr Instance
private void dotBeginFrame(IntPtr Instance)
private void dotEndFrame(IntPtr Instance)
private void dotGameRoundStart(IntPtr Instance, string MapName)
private void dotGameRoundEnd(IntPtr Instance, UInt32 WinningTeamID)
private void dotPlayerSpawn(IntPtr Instance, IntPtr Player, UInt32 TeamID, UInt32 CharacterID)
private void dotPlayerDespawn(IntPtr Instance, IntPtr Player, UInt32 IsPlayerDeath, IntPtr PlayerAttacker)
private void dotPlayerRevive(IntPtr Instance, IntPtr PlayerRevived, IntPtr PlayerReviving)
private void dotPlayerTick(IntPtr Instance, IntPtr Player, float PositionX, float PositionY, float PositionZ, float ViewAnglesX, float ViewAnglesY, float ViewAnglesZ, UInt32 Health, UInt32 TickFlags)
private void dotPlayerUseWeapon(IntPtr Instance, IntPtr Player, float PositionX, float PositionY, float PositionZ, float ViewAnglesX, float ViewAnglesY, float ViewAnglesZ, UInt32 FieldOfView, UInt32 WeaponID)
private void dotPlayerTakeDamage(IntPtr Instance, IntPtr PlayerVictim, float VictimPositionX, float VictimPositionY, float VictimPositionZ, float VictimViewAnglesX, float VictimViewAnglesY, float VictimViewAnglesZ, IntPtr PlayerAttacker, float AttackerPositionX, float AttackerPositionY, float AttackerPositionZ, float AttackerViewAnglesX, float AttackerViewAnglesY, float AttackerViewAnglesZ, UInt32 AttackerFieldOfView, UInt32 WeaponID, UInt32 HitBoneID, UInt32 DamageTaken, UInt32 DamageFlags)
internal void SetInstance(IntPtr CerberusInstance)
internal void BeginFrame()
internal void EndFrame()
internal void LogGameRoundStart(string MapName)
internal void LogGameRoundEnd(int WinningTeamID)
internal void LogPlayerSpawn(IntPtr PlayerObject, int TeamID, int CharacterID)
internal void LogPlayerDespawn(IntPtr PlayerObject)
internal void LogPlayerKill(IntPtr PlayerVictim, IntPtr PlayerAttacker)
internal void LogPlayerRevive(IntPtr PlayerRevived, IntPtr PlayerReviving)
internal void LogPlayerTick(IntPtr PlayerObject, PlayerTick EventParams)
internal void LogPlayerUseWeapon(IntPtr PlayerObject, PlayerUseWeapon EventParams)
internal void LogPlayerTakeDamage(IntPtr PlayerVictim, IntPtr PlayerAttacker, PlayerTakeDamage EventParams)
}
internal EasyAntiCheat.Client.P2P.NativeClient : object {
private string InterfaceVersion
private INativeModule Module
private IntPtr Instance
private Byte[] StaticMsgBuf
private CallbackProgress nogcOnProgress
private CallbackFinished nogcOnFinished
private LocalIntegrityCallback nogcOnLocalGameClientIntegrityViolation
private RemoteIntegrityCallback OnRemotePeerClientIntegrityProc
private LogEventHandler onLogEvent
public bool IsStartedWithEasyAntiCheat()
public bool IsUnity()
public bool IsWindows()
public bool Initialize(CallbackProgress OnProgress, CallbackFinished OnFinished, LocalIntegrityCallback OnLocalGameClientIntegrityViolation, RemoteIntegrityCallback OnRemotePeerClientIntegrityProc)
public void Dispose()
public void ResetState()
public bool RegisterPeer(IntPtr ClientObject, string PlayerGUID, string PlayerIP, string PlayerName)
public void UnregisterPeer(IntPtr ClientObject)
public bool BeginSession(int RegisterTimeout, string LocalPlayerGUID, string PlatformName, Byte[] AuthTicket, int AuthTicketLength)
public void EndSession()
public bool PollForMessageToPeer(IntPtr& RecipientObject, Byte[]& MessageBuffer, Int32& MessageLength)
public void SetMaxAllowedMessageLength(int MaxMessageLength)
public void ReceiveMessageFromPeer(IntPtr SenderObject, Byte[] MessageBuffer, UInt32 MessageLength)
public void PollStatus()
public void InitLocalization(string Language, string Country)
public IntPtr Cerberus()
public void SetLogCallback(LogEventHandler Callback, LogLevel LogLevel)
public void UpdatePlatformUserAuthTicket(string PlatformName, Byte[] AuthTicket, int AuthTicketLength)
private void OnLogEvent(LogLevel LogLevel, string Message)
}
public EasyAntiCheat.Client.P2P.Runtime`1 : object {
private CallbackProgress nogc_AntiCheatProgress
private CallbackFinished nogc_AntiCheatEvent
private LocalIntegrityCallback nogc_AntiCheatStateChanged
private RemoteIntegrityCallback nogc_AntiCheatPeerIntegrity
private bool initializeCalled
private EventHandler`1<StateChangedEventArgs> onStateChanged
private EventHandler`1<LoadCompletedEventArgs> onLoadCompleted
private EventHandler`1<LoadProgressEventArgs> onProgress
private EventHandler`1<PeerClientIntegrityProcArgs`1<TClient>> onPeerClientIntegrityProc
internal IDictionary`2<TClient, IntPtr> MapClientToInternalObject
internal IDictionary`2<IntPtr, TClient> MapInternalObjectToClient
private IntPtr UniqueClientObjectCounter
private Cerberus`1<TClient> _Cerberus
private String[] PlatformsWithoutAuthTickets
private bool <Initialized>k__BackingField
private IntegrityDescriptor <Integrity>k__BackingField
public bool Initialized
public IntegrityDescriptor Integrity
public ICerberus`1<TClient> Cerberus
public bool get_Initialized()
private void set_Initialized(bool value)
public IntegrityDescriptor get_Integrity()
private void set_Integrity(IntegrityDescriptor value)
public ICerberus`1<TClient> get_Cerberus()
public bool IsActive()
public void Dispose()
public bool Initialize(EventHandler`1<StateChangedEventArgs> onStateChanged, EventHandler`1<LoadCompletedEventArgs> onCompleted, EventHandler`1<PeerClientIntegrityProcArgs`1<TClient>> onPeerClientIntegrityProc, EventHandler`1<LoadProgressEventArgs> onProgress)
public void ResetState()
public bool RegisterPeer(TClient Client, string PlayerGUID)
public bool RegisterPeer(TClient Client, string PlayerGUID, string PlayerIP)
public bool RegisterPeer(TClient Client, string PlayerGUID, string PlayerIP, string PlayerName)
public void UnregisterPeer(TClient Client)
public bool BeginSession(int RegisterTimeout, string LocalPlayerGUID, string PlatformName)
public bool BeginSession(int RegisterTimeout, string LocalPlayerGUID, string PlatformName, Byte[] AuthTicket)
public void EndSession()
public bool PollForMessageToPeer(TClient& RecipientClient, Byte[]& MessageBuffer, Int32& MessageLength)
public bool PollForMessageToPeer(TClient RecipientClient, Byte[]& MessageBuffer, Int32& MessageLength)
public void SetMaxAllowedMessageLength(int MaxMessageLength)
public void ReceiveMessageFromPeer(TClient SenderClient, Byte[] MessageBuffer, int MessageLength)
public void PollStatus()
public void InitLocalization(string Language, string Country)
public void UpdatePlatformUserAuthTicket(string PlatformName, Byte[] AuthTicket)
private UInt32 OnInternalProgress(UInt32 Progress, IntPtr CallbackParameter)
private void OnInternalFinish(LoadResult Result, string Message, IntPtr CallbackParameter)
private UInt32 OnLocalGameClientIntegrityViolation(ClientIntegrityViolationType ViolationType, string ViolationCause, string DefaultMessage, IntPtr CallbackParameter)
private bool OnRemoteGameClientIntegrityViolation(IntPtr ClientObject, PeerIntegrityStatus IntegrityStatus, string StatusCause, string DefaultMessage, IntPtr CallbackParameter)
private IntPtr GetNextClientObject()
}
public EasyAntiCheat.Client.PeerClientIntegrityProcArgs`1 : LoadEventArgs {
private TClient <ClientObject>k__BackingField
private PeerIntegrityStatus <Status>k__BackingField
private string <StatusCause>k__BackingField
public TClient ClientObject
public PeerIntegrityStatus Status
public string StatusCause
internal void .ctor(TClient ClientObject, PeerIntegrityStatus IntegrityStatus, string StatusCause, string Message)
public TClient get_ClientObject()
private void set_ClientObject(TClient value)
public PeerIntegrityStatus get_Status()
private void set_Status(PeerIntegrityStatus value)
public string get_StatusCause()
private void set_StatusCause(string value)
public string ToString()
}
public EasyAntiCheat.Client.PeerIntegrityStatus : Enum {
public int value__
public PeerIntegrityStatus PeerValidationCompleted
public PeerIntegrityStatus PeerAntiCheatValidationFailed
public PeerIntegrityStatus PeerAntiCheatHeartbeatRejected
public PeerIntegrityStatus PeerAntiCheatClientBanned
}
internal EasyAntiCheat.Client.Properties.Resources : object {
private ResourceManager resourceMan
private CultureInfo resourceCulture
internal ResourceManager ResourceManager
internal CultureInfo Culture
internal ResourceManager get_ResourceManager()
internal CultureInfo get_Culture()
internal void set_Culture(CultureInfo value)
}
internal EasyAntiCheat.Client.Properties.Settings : ApplicationSettingsBase {
private Settings defaultInstance
public Settings Default
public Settings get_Default()
}
public EasyAntiCheat.Client.StateChangedEventArgs : EventArgs {
private string <Message>k__BackingField
private StateChangeType <Type>k__BackingField
public string Message
public StateChangeType Type
internal void .ctor(StateChangeType stateChangeType, string message)
public string get_Message()
private void set_Message(string value)
public StateChangeType get_Type()
private void set_Type(StateChangeType value)
public string ToString()
}
public EasyAntiCheat.Client.StateChangeType : Enum {
public int value__
public StateChangeType Connection
public StateChangeType Integrity
public StateChangeType HostValidation
}
internal EasyAntiCheat.Client.ThreadSynchronizer : object {
private Thread thread
private Queue`1<KeyValuePair`2<WaitCallback, object>> tasks
private Semaphore synchronizer
private object syncRoot
private bool enabled
public void Dispose()
public void Invoke(WaitCallback task, object state)
private void Send()
}
public EasyAntiCheat.Log : object {
private LogWriterDelegate doWrite
private StringBuilder stringBuilder
private Mutex stringBuilderMutex
private LogLevel <Level>k__BackingField
private string <Prefix>k__BackingField
private string <TimestampFormat>k__BackingField
public LogLevel Level
public string Prefix
public string TimestampFormat
public LogLevel get_Level()
public void set_Level(LogLevel value)
public string get_Prefix()
public void set_Prefix(string value)
public string get_TimestampFormat()
public void set_TimestampFormat(string value)
public void SetOut(TextWriter writer)
public void SetOut(LogMessageWriterDelegate doWrite)
public void SetOut(LogWriterDelegate doWrite)
internal void WriteLine(LogLevel logLevel, string message)
internal void WriteException(LogLevel logLevel, string message, Exception e, bool includeStack)
}
public EasyAntiCheat.LogLevel : Enum {
public UInt32 value__
public LogLevel NoLogging
public LogLevel Error
public LogLevel Warning
public LogLevel Info
public LogLevel Verbose
public LogLevel VeryVerbose
}
public EasyAntiCheat.LogMessageWriterDelegate : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(string message)
public IAsyncResult BeginInvoke(string message, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public EasyAntiCheat.LogWriterDelegate : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(LogLevel logLevel, string message)
public IAsyncResult BeginInvoke(LogLevel logLevel, string message, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
