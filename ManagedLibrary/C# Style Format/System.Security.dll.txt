internal Internal.Cryptography.CryptoThrowHelper : object {
public CryptographicException ToCryptographicException(int hr)
}
internal Internal.Cryptography.DecryptorPal : object {
private RecipientInfoCollection <RecipientInfos>k__BackingField
public RecipientInfoCollection RecipientInfos
internal void .ctor(RecipientInfoCollection recipientInfos)
public RecipientInfoCollection get_RecipientInfos()
public ContentInfo TryDecrypt(RecipientInfo recipientInfo, X509Certificate2 cert, X509Certificate2Collection originatorCerts, X509Certificate2Collection extraStore, Exception& exception)
public void Dispose()
}
internal Internal.Cryptography.Helpers : object {
internal void AppendData(IncrementalHash hasher, ReadOnlySpan`1<byte> data)
internal HashAlgorithmName GetDigestAlgorithm(Oid oid)
internal HashAlgorithmName GetDigestAlgorithm(string oidValue)
internal string GetOidFromHashAlgorithm(HashAlgorithmName algName)
public Byte[] Resize(Byte[] a, int size)
public void RemoveAt(T[]& arr, int idx)
public T[] NormalizeSet(T[] setItems, Action`1<Byte[]> encodedValueProcessor)
internal Byte[] EncodeContentInfo(T value, string contentType, AsnEncodingRules ruleSet)
public CmsRecipientCollection DeepCopy(CmsRecipientCollection recipients)
public Byte[] UnicodeToOctetString(string s)
public string OctetStringToUnicode(Byte[] octets)
public X509Certificate2Collection GetStoreCertificates(StoreName storeName, StoreLocation storeLocation, bool openExistingOnly)
public X509Certificate2 TryFindMatchingCertificate(X509Certificate2Collection certs, SubjectIdentifier recipientIdentifier)
private bool AreByteArraysEqual(Byte[] ba1, Byte[] ba2)
private Byte[] ToSkiBytes(string skiString)
public string ToSkiString(Byte[] skiBytes)
public string ToBigEndianHex(ReadOnlySpan`1<byte> bytes)
private Byte[] ToSerialBytes(string serialString)
public string ToSerialString(Byte[] serialBytes)
private string ToUpperHexString(ReadOnlySpan`1<byte> ba)
private Byte[] UpperHexStringToByteArray(string normalizedString)
private byte UpperHexCharToNybble(char c)
public Pkcs9AttributeObject CreateBestPkcs9AttributeObjectAvailable(Oid oid, Byte[] encodedAttribute)
private T Upgrade(Pkcs9AttributeObject basicAttribute)
public Byte[] GetSubjectKeyIdentifier(X509Certificate2 certificate)
internal Byte[] OneShot(ICryptoTransform transform, Byte[] data)
internal Byte[] OneShot(ICryptoTransform transform, Byte[] data, int offset, int length)
private ReadOnlyMemory`1<byte> GetSubjectPublicKeyInfo(X509Certificate2 certificate)
}
internal Internal.Cryptography.KeyAgreeRecipientInfoPal : RecipientInfoPal {
public DateTime Date
public SubjectIdentifierOrKey OriginatorIdentifierOrKey
public CryptographicAttributeObject OtherKeyAttribute
public DateTime get_Date()
public SubjectIdentifierOrKey get_OriginatorIdentifierOrKey()
public CryptographicAttributeObject get_OtherKeyAttribute()
}
internal Internal.Cryptography.KeyLengths : object {
public int Rc2_40Bit
public int Rc2_56Bit
public int Rc2_64Bit
public int Rc2_128Bit
public int Rc4Max_128Bit
public int Des_64Bit
public int TripleDes_192Bit
public int DefaultKeyLengthForRc2AndRc4
}
internal Internal.Cryptography.Oids : object {
public string Rc2Cbc
public string Rc4
public string TripleDesCbc
public string DesCbc
public string Aes128Cbc
public string Aes192Cbc
public string Aes256Cbc
public string Rsa
public string RsaOaep
public string RsaPss
public string RsaPkcs1Sha1
public string RsaPkcs1Sha256
public string RsaPkcs1Sha384
public string RsaPkcs1Sha512
public string Esdh
public string SigningTime
public string ContentType
public string DocumentDescription
public string MessageDigest
public string CounterSigner
public string SigningCertificate
public string SigningCertificateV2
public string DocumentName
public string CmsRc2Wrap
public string Cms3DesWrap
public string Pkcs7Data
public string Pkcs7Signed
public string Pkcs7Enveloped
public string Pkcs7SignedEnveloped
public string Pkcs7Hashed
public string Pkcs7Encrypted
public string Md5
public string Sha1
public string Sha256
public string Sha384
public string Sha512
public string DsaPublicKey
public string DsaWithSha1
public string DsaWithSha256
public string DsaWithSha384
public string DsaWithSha512
public string EcPublicKey
public string ECDsaWithSha1
public string ECDsaWithSha256
public string ECDsaWithSha384
public string ECDsaWithSha512
public string Mgf1
public string SubjectKeyIdentifier
public string KeyUsage
public string TstInfo
public string TimeStampingPurpose
}
internal Internal.Cryptography.Pal.AnyOS.AsnHelpers : object {
internal SubjectIdentifierOrKey ToSubjectIdentifierOrKey(OriginatorIdentifierOrKeyAsn originator)
internal AlgorithmIdentifier ToPresentationObject(AlgorithmIdentifierAsn asn)
}
internal Internal.Cryptography.Pal.AnyOS.ManagedPkcsPal : PkcsPal {
private Byte[] s_invalidEmptyOid
private Byte[] s_rsaPkcsParameters
private Byte[] s_rsaOaepSha1Parameters
public Byte[] EncodeOctetString(Byte[] octets)
public Byte[] DecodeOctetString(Byte[] encodedOctets)
public Byte[] EncodeUtcTime(DateTime utcTime)
public DateTime DecodeUtcTime(Byte[] encodedUtcTime)
public string DecodeOid(Byte[] encodedOid)
public Oid GetEncodedMessageType(Byte[] encodedMessage)
public DecryptorPal Decode(Byte[] encodedMessage, Int32& version, ContentInfo& contentInfo, AlgorithmIdentifier& contentEncryptionAlgorithm, X509Certificate2Collection& originatorCerts, CryptographicAttributeObjectCollection& unprotectedAttributes)
public Byte[] Encrypt(CmsRecipientCollection recipients, ContentInfo contentInfo, AlgorithmIdentifier contentEncryptionAlgorithm, X509Certificate2Collection originatorCerts, CryptographicAttributeObjectCollection unprotectedAttributes)
private Byte[] Encrypt(CmsRecipientCollection recipients, ContentInfo contentInfo, AlgorithmIdentifier contentEncryptionAlgorithm, X509Certificate2Collection originatorCerts, CryptographicAttributeObjectCollection unprotectedAttributes, Byte[] encryptedContent, Byte[] cek, Byte[] parameterBytes)
private Byte[] EncryptContent(ContentInfo contentInfo, AlgorithmIdentifier contentEncryptionAlgorithm, Byte[]& cek, Byte[]& parameterBytes)
public Exception CreateRecipientsNotFoundException()
public Exception CreateRecipientInfosAfterEncryptException()
public Exception CreateDecryptAfterEncryptException()
public Exception CreateDecryptTwiceException()
private Exception CreateInvalidMessageTypeException()
private KeyTransRecipientInfoAsn MakeKtri(Byte[] cek, CmsRecipient recipient, Boolean& v0Recipient)
public void AddCertsFromStoreForDecryption(X509Certificate2Collection certs)
public Byte[] GetSubjectKeyIdentifier(X509Certificate2 certificate)
public T GetPrivateKeyForSigning(X509Certificate2 certificate, bool silent)
public T GetPrivateKeyForDecryption(X509Certificate2 certificate, bool silent)
private T GetPrivateKey(X509Certificate2 certificate)
private SymmetricAlgorithm OpenAlgorithm(AlgorithmIdentifierAsn contentEncryptionAlgorithm)
private SymmetricAlgorithm OpenAlgorithm(AlgorithmIdentifier algorithmIdentifier)
private SymmetricAlgorithm OpenAlgorithm(Oid algorithmIdentifier)
}
internal Internal.Cryptography.PkcsPal : object {
private PkcsPal s_instance
public PkcsPal Instance
public Byte[] Encrypt(CmsRecipientCollection recipients, ContentInfo contentInfo, AlgorithmIdentifier contentEncryptionAlgorithm, X509Certificate2Collection originatorCerts, CryptographicAttributeObjectCollection unprotectedAttributes)
public DecryptorPal Decode(Byte[] encodedMessage, Int32& version, ContentInfo& contentInfo, AlgorithmIdentifier& contentEncryptionAlgorithm, X509Certificate2Collection& originatorCerts, CryptographicAttributeObjectCollection& unprotectedAttributes)
public Byte[] EncodeOctetString(Byte[] octets)
public Byte[] DecodeOctetString(Byte[] encodedOctets)
public Byte[] EncodeUtcTime(DateTime utcTime)
public DateTime DecodeUtcTime(Byte[] encodedUtcTime)
public string DecodeOid(Byte[] encodedOid)
public Oid GetEncodedMessageType(Byte[] encodedMessage)
public void AddCertsFromStoreForDecryption(X509Certificate2Collection certs)
public Exception CreateRecipientsNotFoundException()
public Exception CreateRecipientInfosAfterEncryptException()
public Exception CreateDecryptAfterEncryptException()
public Exception CreateDecryptTwiceException()
public Byte[] GetSubjectKeyIdentifier(X509Certificate2 certificate)
public T GetPrivateKeyForSigning(X509Certificate2 certificate, bool silent)
public T GetPrivateKeyForDecryption(X509Certificate2 certificate, bool silent)
public PkcsPal get_Instance()
}
internal Internal.Cryptography.RecipientInfoPal : object {
public Byte[] EncryptedKey
public AlgorithmIdentifier KeyEncryptionAlgorithm
public SubjectIdentifier RecipientIdentifier
public int Version
public Byte[] get_EncryptedKey()
public AlgorithmIdentifier get_KeyEncryptionAlgorithm()
public SubjectIdentifier get_RecipientIdentifier()
public int get_Version()
}
internal System.Security.Cryptography.Asn1.Asn1Tag : ValueType {
private byte ClassMask
private byte ConstructedMask
private byte ControlMask
private byte TagNumberMask
internal Asn1Tag EndOfContents
internal Asn1Tag Boolean
internal Asn1Tag Integer
internal Asn1Tag PrimitiveBitString
internal Asn1Tag ConstructedBitString
internal Asn1Tag PrimitiveOctetString
internal Asn1Tag ConstructedOctetString
internal Asn1Tag Null
internal Asn1Tag ObjectIdentifier
internal Asn1Tag Enumerated
internal Asn1Tag Sequence
internal Asn1Tag SetOf
internal Asn1Tag UtcTime
internal Asn1Tag GeneralizedTime
private byte _controlFlags
private int _tagValue
public TagClass TagClass
public bool IsConstructed
public int TagValue
public TagClass get_TagClass()
public bool get_IsConstructed()
public int get_TagValue()
private void .ctor(byte controlFlags, int tagValue)
public void .ctor(UniversalTagNumber universalTagNumber, bool isConstructed)
public void .ctor(TagClass tagClass, int tagValue, bool isConstructed)
public Asn1Tag AsConstructed()
public Asn1Tag AsPrimitive()
public bool TryParse(ReadOnlySpan`1<byte> source, Asn1Tag& tag, Int32& bytesRead)
public int CalculateEncodedSize()
public bool TryWrite(Span`1<byte> destination, Int32& bytesWritten)
public bool Equals(Asn1Tag other)
public bool Equals(object obj)
public int GetHashCode()
public bool op_Equality(Asn1Tag left, Asn1Tag right)
public bool op_Inequality(Asn1Tag left, Asn1Tag right)
public string ToString()
}
internal System.Security.Cryptography.Asn1.AsnAmbiguousFieldTypeException : AsnSerializationConstraintException {
public void .ctor(FieldInfo fieldInfo, Type ambiguousType)
}
internal System.Security.Cryptography.Asn1.AsnCharacterStringEncodings : object {
private Encoding s_utf8Encoding
private Encoding s_bmpEncoding
private Encoding s_ia5Encoding
private Encoding s_visibleStringEncoding
private Encoding s_printableStringEncoding
internal Encoding GetEncoding(UniversalTagNumber encodingType)
}
internal System.Security.Cryptography.Asn1.AsnEncodingRules : Enum {
public int value__
public AsnEncodingRules BER
public AsnEncodingRules CER
public AsnEncodingRules DER
}
internal System.Security.Cryptography.Asn1.AsnReader : object {
internal int MaxCERSegmentSize
private int EndOfContentsEncodedLength
private ReadOnlyMemory`1<byte> _data
private AsnEncodingRules _ruleSet
private byte HmsState
private byte FracState
private byte SuffixState
public bool HasData
public bool get_HasData()
public void .ctor(ReadOnlyMemory`1<byte> data, AsnEncodingRules ruleSet)
public void ThrowIfNotEmpty()
public bool TryPeekTag(ReadOnlySpan`1<byte> source, Asn1Tag& tag, Int32& bytesRead)
public Asn1Tag PeekTag()
private bool TryReadLength(ReadOnlySpan`1<byte> source, AsnEncodingRules ruleSet, Nullable`1& length, Int32& bytesRead)
internal Asn1Tag ReadTagAndLength(Nullable`1& contentsLength, Int32& bytesRead)
private void ValidateEndOfContents(Asn1Tag tag, Nullable`1<int> length, int headerLength)
private int SeekEndOfContents(ReadOnlyMemory`1<byte> source)
public ReadOnlyMemory`1<byte> PeekEncodedValue()
public ReadOnlyMemory`1<byte> PeekContentBytes()
public ReadOnlyMemory`1<byte> GetEncodedValue()
private bool ReadBooleanValue(ReadOnlySpan`1<byte> source, AsnEncodingRules ruleSet)
public bool ReadBoolean()
public bool ReadBoolean(Asn1Tag expectedTag)
private ReadOnlyMemory`1<byte> GetIntegerContents(Asn1Tag expectedTag, UniversalTagNumber tagNumber, Int32& headerLength)
public ReadOnlyMemory`1<byte> GetIntegerBytes()
public ReadOnlyMemory`1<byte> GetIntegerBytes(Asn1Tag expectedTag)
public BigInteger GetInteger()
public BigInteger GetInteger(Asn1Tag expectedTag)
private bool TryReadSignedInteger(int sizeLimit, Asn1Tag expectedTag, UniversalTagNumber tagNumber, Int64& value)
private bool TryReadUnsignedInteger(int sizeLimit, Asn1Tag expectedTag, UniversalTagNumber tagNumber, UInt64& value)
public bool TryReadInt32(Int32& value)
public bool TryReadInt32(Asn1Tag expectedTag, Int32& value)
public bool TryReadUInt32(UInt32& value)
public bool TryReadUInt32(Asn1Tag expectedTag, UInt32& value)
public bool TryReadInt64(Int64& value)
public bool TryReadInt64(Asn1Tag expectedTag, Int64& value)
public bool TryReadUInt64(UInt64& value)
public bool TryReadUInt64(Asn1Tag expectedTag, UInt64& value)
public bool TryReadInt16(Int16& value)
public bool TryReadInt16(Asn1Tag expectedTag, Int16& value)
public bool TryReadUInt16(UInt16& value)
public bool TryReadUInt16(Asn1Tag expectedTag, UInt16& value)
public bool TryReadInt8(SByte& value)
public bool TryReadInt8(Asn1Tag expectedTag, SByte& value)
public bool TryReadUInt8(Byte& value)
public bool TryReadUInt8(Asn1Tag expectedTag, Byte& value)
private void ParsePrimitiveBitStringContents(ReadOnlyMemory`1<byte> source, Int32& unusedBitCount, ReadOnlyMemory`1& value, Byte& normalizedLastByte)
private void CopyBitStringValue(ReadOnlyMemory`1<byte> value, byte normalizedLastByte, Span`1<byte> destination)
private int CountConstructedBitString(ReadOnlyMemory`1<byte> source, bool isIndefinite)
private void CopyConstructedBitString(ReadOnlyMemory`1<byte> source, Span`1<byte> destination, bool isIndefinite, Int32& unusedBitCount, Int32& bytesRead, Int32& bytesWritten)
private int ProcessConstructedBitString(ReadOnlyMemory`1<byte> source, Span`1<byte> destination, BitStringCopyAction copyAction, bool isIndefinite, Int32& lastUnusedBitCount, Int32& bytesRead)
private bool TryCopyConstructedBitStringValue(ReadOnlyMemory`1<byte> source, Span`1<byte> dest, bool isIndefinite, Int32& unusedBitCount, Int32& bytesRead, Int32& bytesWritten)
private bool TryGetPrimitiveBitStringValue(Asn1Tag expectedTag, Asn1Tag& actualTag, Nullable`1& contentsLength, Int32& headerLength, Int32& unusedBitCount, ReadOnlyMemory`1& value, Byte& normalizedLastByte)
public bool TryGetPrimitiveBitStringValue(Int32& unusedBitCount, ReadOnlyMemory`1& contents)
public bool TryGetPrimitiveBitStringValue(Asn1Tag expectedTag, Int32& unusedBitCount, ReadOnlyMemory`1& value)
public bool TryCopyBitStringBytes(Span`1<byte> destination, Int32& unusedBitCount, Int32& bytesWritten)
public bool TryCopyBitStringBytes(Asn1Tag expectedTag, Span`1<byte> destination, Int32& unusedBitCount, Int32& bytesWritten)
public TFlagsEnum GetNamedBitListValue()
public TFlagsEnum GetNamedBitListValue(Asn1Tag expectedTag)
public Enum GetNamedBitListValue(Type tFlagsEnum)
public Enum GetNamedBitListValue(Asn1Tag expectedTag, Type tFlagsEnum)
private long InterpretNamedBitListReversed(ReadOnlySpan`1<byte> valueSpan)
public ReadOnlyMemory`1<byte> GetEnumeratedBytes()
public ReadOnlyMemory`1<byte> GetEnumeratedBytes(Asn1Tag expectedTag)
public TEnum GetEnumeratedValue()
public TEnum GetEnumeratedValue(Asn1Tag expectedTag)
public Enum GetEnumeratedValue(Type tEnum)
public Enum GetEnumeratedValue(Asn1Tag expectedTag, Type tEnum)
private bool TryGetPrimitiveOctetStringBytes(Asn1Tag expectedTag, Asn1Tag& actualTag, Nullable`1& contentLength, Int32& headerLength, ReadOnlyMemory`1& contents, UniversalTagNumber universalTagNumber)
private bool TryGetPrimitiveOctetStringBytes(Asn1Tag expectedTag, UniversalTagNumber universalTagNumber, ReadOnlyMemory`1& contents)
public bool TryGetPrimitiveOctetStringBytes(ReadOnlyMemory`1& contents)
public bool TryGetPrimitiveOctetStringBytes(Asn1Tag expectedTag, ReadOnlyMemory`1& contents)
private int CountConstructedOctetString(ReadOnlyMemory`1<byte> source, bool isIndefinite)
private void CopyConstructedOctetString(ReadOnlyMemory`1<byte> source, Span`1<byte> destination, bool isIndefinite, Int32& bytesRead, Int32& bytesWritten)
private int CopyConstructedOctetString(ReadOnlyMemory`1<byte> source, Span`1<byte> destination, bool write, bool isIndefinite, Int32& bytesRead)
private bool TryCopyConstructedOctetStringContents(ReadOnlyMemory`1<byte> source, Span`1<byte> dest, bool isIndefinite, Int32& bytesRead, Int32& bytesWritten)
public bool TryCopyOctetStringBytes(Span`1<byte> destination, Int32& bytesWritten)
public bool TryCopyOctetStringBytes(Asn1Tag expectedTag, Span`1<byte> destination, Int32& bytesWritten)
public void ReadNull()
public void ReadNull(Asn1Tag expectedTag)
private void ReadSubIdentifier(ReadOnlySpan`1<byte> source, Int32& bytesRead, Nullable`1& smallValue, Nullable`1& largeValue)
private string ReadObjectIdentifierAsString(Asn1Tag expectedTag, Int32& totalBytesRead)
public string ReadObjectIdentifierAsString()
public string ReadObjectIdentifierAsString(Asn1Tag expectedTag)
public Oid ReadObjectIdentifier(bool skipFriendlyName)
public Oid ReadObjectIdentifier(Asn1Tag expectedTag, bool skipFriendlyName)
private bool TryCopyCharacterStringBytes(Asn1Tag expectedTag, UniversalTagNumber universalTagNumber, Span`1<byte> destination, Int32& bytesRead, Int32& bytesWritten)
private bool TryCopyCharacterString(ReadOnlySpan`1<byte> source, Span`1<char> destination, Encoding encoding, Int32& charsWritten)
private string GetCharacterString(Asn1Tag expectedTag, UniversalTagNumber universalTagNumber, Encoding encoding)
private bool TryCopyCharacterString(Asn1Tag expectedTag, UniversalTagNumber universalTagNumber, Encoding encoding, Span`1<char> destination, Int32& charsWritten)
public bool TryGetPrimitiveCharacterStringBytes(UniversalTagNumber encodingType, ReadOnlyMemory`1& contents)
public bool TryGetPrimitiveCharacterStringBytes(Asn1Tag expectedTag, UniversalTagNumber encodingType, ReadOnlyMemory`1& contents)
public bool TryCopyCharacterStringBytes(UniversalTagNumber encodingType, Span`1<byte> destination, Int32& bytesWritten)
public bool TryCopyCharacterStringBytes(Asn1Tag expectedTag, UniversalTagNumber encodingType, Span`1<byte> destination, Int32& bytesWritten)
public bool TryCopyCharacterString(UniversalTagNumber encodingType, Span`1<char> destination, Int32& charsWritten)
public bool TryCopyCharacterString(Asn1Tag expectedTag, UniversalTagNumber encodingType, Span`1<char> destination, Int32& charsWritten)
public string GetCharacterString(UniversalTagNumber encodingType)
public string GetCharacterString(Asn1Tag expectedTag, UniversalTagNumber encodingType)
public AsnReader ReadSequence()
public AsnReader ReadSequence(Asn1Tag expectedTag)
public AsnReader ReadSetOf(bool skipSortOrderValidation)
public AsnReader ReadSetOf(Asn1Tag expectedTag, bool skipSortOrderValidation)
private int ParseNonNegativeIntAndSlice(ReadOnlySpan`1& data, int bytesToRead)
private int ParseNonNegativeInt(ReadOnlySpan`1<byte> data)
private DateTimeOffset ParseUtcTime(ReadOnlySpan`1<byte> contentOctets, int twoDigitYearMax)
public DateTimeOffset GetUtcTime(int twoDigitYearMax)
public DateTimeOffset GetUtcTime(Asn1Tag expectedTag, int twoDigitYearMax)
private Nullable`1<byte> ParseGeneralizedTime_GetNextState(byte octet)
private DateTimeOffset ParseGeneralizedTime(AsnEncodingRules ruleSet, ReadOnlySpan`1<byte> contentOctets, bool disallowFractions)
public DateTimeOffset GetGeneralizedTime(bool disallowFractions)
public DateTimeOffset GetGeneralizedTime(Asn1Tag expectedTag, bool disallowFractions)
private ReadOnlySpan`1<byte> GetOctetStringContents(Asn1Tag expectedTag, UniversalTagNumber universalTagNumber, Int32& bytesRead, Byte[]& rented, Span`1<byte> tmpSpace)
private ReadOnlySpan`1<byte> SliceAtMost(ReadOnlySpan`1<byte> source, int longestPermitted)
private ReadOnlySpan`1<byte> Slice(ReadOnlySpan`1<byte> source, int offset, int length)
private ReadOnlyMemory`1<byte> Slice(ReadOnlyMemory`1<byte> source, int offset, Nullable`1<int> length)
private void CheckEncodingRules(AsnEncodingRules ruleSet)
private void CheckExpectedTag(Asn1Tag tag, Asn1Tag expectedTag, UniversalTagNumber tagNumber)
private void CheckCharacterStringEncodingType(UniversalTagNumber encodingType)
}
internal System.Security.Cryptography.Asn1.AsnSerializationConstraintException : CryptographicException {
public void .ctor(string message)
public void .ctor(string message, Exception inner)
}
internal System.Security.Cryptography.Asn1.AsnSerializer : object {
private BindingFlags FieldFlags
private ConcurrentDictionary`2<Type, FieldInfo[]> s_orderedFields
private Deserializer TryOrFail(TryDeserializer`1<T> tryDeserializer)
private FieldInfo[] GetOrderedFields(Type typeT)
private ChoiceAttribute GetChoiceAttribute(Type typeT)
private bool CanBeNull(Type t)
private void PopulateChoiceLookup(Dictionary`2<ValueTuple`2<TagClass, int>, LinkedList`1<FieldInfo>> lookup, Type typeT, LinkedList`1<FieldInfo> currentSet)
private void SerializeChoice(Type typeT, object value, AsnWriter writer)
private object DeserializeChoice(AsnReader reader, Type typeT)
private void SerializeCustomType(Type typeT, object value, AsnWriter writer, Asn1Tag tag)
private object DeserializeCustomType(AsnReader reader, Type typeT, Asn1Tag expectedTag)
private Deserializer ExplicitValueDeserializer(Deserializer valueDeserializer, Asn1Tag expectedTag)
private object ExplicitValueDeserializer(AsnReader reader, Deserializer valueDeserializer, Asn1Tag expectedTag)
private Deserializer DefaultValueDeserializer(Deserializer valueDeserializer, bool isOptional, Byte[] defaultContents, Nullable`1<Asn1Tag> expectedTag)
private object DefaultValueDeserializer(AsnReader reader, Nullable`1<Asn1Tag> expectedTag, Deserializer valueDeserializer, Byte[] defaultContents, bool isOptional)
private Serializer GetSerializer(Type typeT, FieldInfo fieldInfo)
private Serializer GetSimpleSerializer(Type typeT, FieldInfo fieldInfo, Byte[]& defaultContents, Boolean& isOptional, Nullable`1& explicitTag)
private Deserializer GetDeserializer(Type typeT, FieldInfo fieldInfo)
private Deserializer GetSimpleDeserializer(Type typeT, FieldInfo fieldInfo, SerializerFieldData& fieldData)
private object DefaultValue(Byte[] defaultContents, Deserializer valueDeserializer)
private void GetFieldInfo(Type typeT, FieldInfo fieldInfo, SerializerFieldData& serializerFieldData)
private Type UnpackIfNullable(Type typeT)
private Deserializer GetPrimitiveDeserializer(Type typeT, Asn1Tag tag)
private Serializer GetPrimitiveSerializer(Type typeT, Asn1Tag primitiveTag)
public T Deserialize(ReadOnlyMemory`1<byte> source, AsnEncodingRules ruleSet)
public T Deserialize(ReadOnlyMemory`1<byte> source, AsnEncodingRules ruleSet, Int32& bytesRead)
public AsnWriter Serialize(T value, AsnEncodingRules ruleSet)
public void Serialize(T value, AsnWriter existingWriter)
}
internal System.Security.Cryptography.Asn1.AsnSerializerInvalidDefaultException : AsnSerializationConstraintException {
internal void .ctor(Exception innerException)
}
internal System.Security.Cryptography.Asn1.AsnWriter : object {
private Byte[] _buffer
private int _offset
private Stack`1<ValueTuple`2<Asn1Tag, int>> _nestingStack
private AsnEncodingRules <RuleSet>k__BackingField
public AsnEncodingRules RuleSet
public AsnEncodingRules get_RuleSet()
public void .ctor(AsnEncodingRules ruleSet)
public void Dispose()
private void EnsureWriteCapacity(int pendingCount)
private void WriteTag(Asn1Tag tag)
private void WriteLength(int length)
private int GetEncodedLengthSubsequentByteCount(int length)
public void WriteEncodedValue(ReadOnlyMemory`1<byte> preEncodedValue)
private void WriteEndOfContents()
public void WriteBoolean(bool value)
public void WriteBoolean(Asn1Tag tag, bool value)
private void WriteBooleanCore(Asn1Tag tag, bool value)
public void WriteInteger(long value)
public void WriteInteger(ulong value)
public void WriteInteger(BigInteger value)
public void WriteInteger(ReadOnlySpan`1<byte> value)
public void WriteInteger(Asn1Tag tag, long value)
private void WriteIntegerCore(Asn1Tag tag, long value)
public void WriteInteger(Asn1Tag tag, ulong value)
private void WriteNonNegativeIntegerCore(Asn1Tag tag, ulong value)
public void WriteInteger(Asn1Tag tag, BigInteger value)
public void WriteInteger(Asn1Tag tag, ReadOnlySpan`1<byte> value)
private void WriteIntegerCore(Asn1Tag tag, ReadOnlySpan`1<byte> value)
private void WriteIntegerCore(Asn1Tag tag, BigInteger value)
public void WriteBitString(ReadOnlySpan`1<byte> bitString, int unusedBitCount)
public void WriteBitString(Asn1Tag tag, ReadOnlySpan`1<byte> bitString, int unusedBitCount)
private void WriteBitStringCore(Asn1Tag tag, ReadOnlySpan`1<byte> bitString, int unusedBitCount)
private void WriteConstructedCerBitString(Asn1Tag tag, ReadOnlySpan`1<byte> payload, int unusedBitCount)
public void WriteNamedBitList(object enumValue)
public void WriteNamedBitList(TEnum enumValue)
public void WriteNamedBitList(Asn1Tag tag, object enumValue)
public void WriteNamedBitList(Asn1Tag tag, TEnum enumValue)
private void WriteNamedBitList(Asn1Tag tag, Type tEnum, object enumValue)
private void WriteNamedBitList(Asn1Tag tag, ulong integralValue)
public void WriteOctetString(ReadOnlySpan`1<byte> octetString)
public void WriteOctetString(Asn1Tag tag, ReadOnlySpan`1<byte> octetString)
private void WriteOctetStringCore(Asn1Tag tag, ReadOnlySpan`1<byte> octetString)
private void WriteConstructedCerOctetString(Asn1Tag tag, ReadOnlySpan`1<byte> payload)
public void WriteNull()
public void WriteNull(Asn1Tag tag)
private void WriteNullCore(Asn1Tag tag)
public void WriteObjectIdentifier(Oid oid)
public void WriteObjectIdentifier(string oidValue)
public void WriteObjectIdentifier(ReadOnlySpan`1<char> oidValue)
public void WriteObjectIdentifier(Asn1Tag tag, Oid oid)
public void WriteObjectIdentifier(Asn1Tag tag, string oidValue)
public void WriteObjectIdentifier(Asn1Tag tag, ReadOnlySpan`1<char> oidValue)
private void WriteObjectIdentifierCore(Asn1Tag tag, ReadOnlySpan`1<char> oidValue)
private BigInteger ParseSubIdentifier(ReadOnlySpan`1& oidValue)
private int AtoI(char c)
private int EncodeSubIdentifier(Span`1<byte> dest, BigInteger& subIdentifier)
public void WriteEnumeratedValue(object enumValue)
public void WriteEnumeratedValue(TEnum value)
public void WriteEnumeratedValue(Asn1Tag tag, object enumValue)
public void WriteEnumeratedValue(Asn1Tag tag, TEnum value)
private void WriteEnumeratedValue(Asn1Tag tag, Type tEnum, object enumValue)
public void PushSequence()
public void PushSequence(Asn1Tag tag)
private void PushSequenceCore(Asn1Tag tag)
public void PopSequence()
public void PopSequence(Asn1Tag tag)
private void PopSequenceCore(Asn1Tag tag)
public void PushSetOf()
public void PushSetOf(Asn1Tag tag)
private void PushSetOfCore(Asn1Tag tag)
public void PopSetOf()
public void PopSetOf(Asn1Tag tag)
private void PopSetOfCore(Asn1Tag tag)
public void WriteUtcTime(DateTimeOffset value)
public void WriteUtcTime(Asn1Tag tag, DateTimeOffset value)
public void WriteUtcTime(DateTimeOffset value, int minLegalYear)
private void WriteUtcTimeCore(Asn1Tag tag, DateTimeOffset value)
public void WriteGeneralizedTime(DateTimeOffset value, bool omitFractionalSeconds)
public void WriteGeneralizedTime(Asn1Tag tag, DateTimeOffset value, bool omitFractionalSeconds)
private void WriteGeneralizedTimeCore(Asn1Tag tag, DateTimeOffset value, bool omitFractionalSeconds)
public bool TryEncode(Span`1<byte> dest, Int32& bytesWritten)
public Byte[] Encode()
public ReadOnlySpan`1<byte> EncodeAsSpan()
private void PushTag(Asn1Tag tag)
private void PopTag(Asn1Tag tag, bool sortContents)
public void WriteCharacterString(UniversalTagNumber encodingType, string str)
public void WriteCharacterString(UniversalTagNumber encodingType, ReadOnlySpan`1<char> str)
public void WriteCharacterString(Asn1Tag tag, UniversalTagNumber encodingType, string str)
public void WriteCharacterString(Asn1Tag tag, UniversalTagNumber encodingType, ReadOnlySpan`1<char> str)
private void WriteCharacterStringCore(Asn1Tag tag, Encoding encoding, ReadOnlySpan`1<char> str)
private void WriteConstructedCerCharacterString(Asn1Tag tag, Encoding encoding, ReadOnlySpan`1<char> str, int size)
private void SortContents(Byte[] buffer, int start, int end)
internal void Reverse(Span`1<byte> span)
private void CheckUniversalTag(Asn1Tag tag, UniversalTagNumber universalTagNumber)
}
internal System.Security.Cryptography.Asn1.BMPEncoding : SpanBasedEncoding {
protected int GetBytes(ReadOnlySpan`1<char> chars, Span`1<byte> bytes, bool write)
protected int GetChars(ReadOnlySpan`1<byte> bytes, Span`1<char> chars, bool write)
public int GetMaxByteCount(int charCount)
public int GetMaxCharCount(int byteCount)
}
internal System.Security.Cryptography.Asn1.ChoiceAttribute : Attribute {
private bool <AllowNull>k__BackingField
public bool AllowNull
public bool get_AllowNull()
public void set_AllowNull(bool value)
}
internal System.Security.Cryptography.Asn1.DefaultValueAttribute : AsnEncodingRuleAttribute {
private Byte[] <EncodedBytes>k__BackingField
internal Byte[] EncodedBytes
public ReadOnlyMemory`1<byte> EncodedValue
internal Byte[] get_EncodedBytes()
public void .ctor(Byte[] encodedValue)
public ReadOnlyMemory`1<byte> get_EncodedValue()
}
internal System.Security.Cryptography.Asn1.ExpectedTagAttribute : Attribute {
private TagClass <TagClass>k__BackingField
private int <TagValue>k__BackingField
private bool <ExplicitTag>k__BackingField
public TagClass TagClass
public int TagValue
public bool ExplicitTag
public TagClass get_TagClass()
public int get_TagValue()
public bool get_ExplicitTag()
public void set_ExplicitTag(bool value)
public void .ctor(int tagValue)
public void .ctor(TagClass tagClass, int tagValue)
}
internal System.Security.Cryptography.Asn1.GeneralizedTimeAttribute : AsnTypeAttribute {
private bool <DisallowFractions>k__BackingField
public bool DisallowFractions
public bool get_DisallowFractions()
public void set_DisallowFractions(bool value)
}
internal System.Security.Cryptography.Asn1.ObjectIdentifierAttribute : AsnTypeAttribute {
private bool <PopulateFriendlyName>k__BackingField
public bool PopulateFriendlyName
public bool get_PopulateFriendlyName()
public void set_PopulateFriendlyName(bool value)
}
internal System.Security.Cryptography.Asn1.RestrictedAsciiStringEncoding : SpanBasedEncoding {
private Boolean[] _isAllowed
protected void .ctor(byte minCharAllowed, byte maxCharAllowed)
protected void .ctor(IEnumerable`1<char> allowedChars)
public int GetMaxByteCount(int charCount)
public int GetMaxCharCount(int byteCount)
protected int GetBytes(ReadOnlySpan`1<char> chars, Span`1<byte> bytes, bool write)
protected int GetChars(ReadOnlySpan`1<byte> bytes, Span`1<char> chars, bool write)
}
internal System.Security.Cryptography.Asn1.SetOfValueComparer : object {
private SetOfValueComparer <Instance>k__BackingField
internal SetOfValueComparer Instance
internal SetOfValueComparer get_Instance()
public int Compare(ReadOnlyMemory`1<byte> x, ReadOnlyMemory`1<byte> y)
}
internal System.Security.Cryptography.Asn1.SpanBasedEncoding : Encoding {
protected int GetBytes(ReadOnlySpan`1<char> chars, Span`1<byte> bytes, bool write)
protected int GetChars(ReadOnlySpan`1<byte> bytes, Span`1<char> chars, bool write)
public int GetByteCount(Char[] chars, int index, int count)
public int GetByteCount(Char* chars, int count)
public int GetByteCount(string s)
public int GetByteCount(ReadOnlySpan`1<char> chars)
public int GetBytes(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex)
public int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount)
public int GetCharCount(Byte[] bytes, int index, int count)
public int GetCharCount(Byte* bytes, int count)
public int GetCharCount(ReadOnlySpan`1<byte> bytes)
public int GetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex)
public int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount)
}
internal System.Security.Cryptography.Asn1.TagClass : Enum {
public byte value__
public TagClass Universal
public TagClass Application
public TagClass ContextSpecific
public TagClass Private
}
internal System.Security.Cryptography.Asn1.UniversalTagNumber : Enum {
public int value__
public UniversalTagNumber EndOfContents
public UniversalTagNumber Boolean
public UniversalTagNumber Integer
public UniversalTagNumber BitString
public UniversalTagNumber OctetString
public UniversalTagNumber Null
public UniversalTagNumber ObjectIdentifier
public UniversalTagNumber ObjectDescriptor
public UniversalTagNumber External
public UniversalTagNumber InstanceOf
public UniversalTagNumber Real
public UniversalTagNumber Enumerated
public UniversalTagNumber Embedded
public UniversalTagNumber UTF8String
public UniversalTagNumber RelativeObjectIdentifier
public UniversalTagNumber Time
public UniversalTagNumber Sequence
public UniversalTagNumber SequenceOf
public UniversalTagNumber Set
public UniversalTagNumber SetOf
public UniversalTagNumber NumericString
public UniversalTagNumber PrintableString
public UniversalTagNumber TeletexString
public UniversalTagNumber T61String
public UniversalTagNumber VideotexString
public UniversalTagNumber IA5String
public UniversalTagNumber UtcTime
public UniversalTagNumber GeneralizedTime
public UniversalTagNumber GraphicString
public UniversalTagNumber VisibleString
public UniversalTagNumber ISO646String
public UniversalTagNumber GeneralString
public UniversalTagNumber UniversalString
public UniversalTagNumber UnrestrictedCharacterString
public UniversalTagNumber BMPString
public UniversalTagNumber Date
public UniversalTagNumber TimeOfDay
public UniversalTagNumber DateTime
public UniversalTagNumber Duration
public UniversalTagNumber ObjectIdentifierIRI
public UniversalTagNumber RelativeObjectIdentifierIRI
}
internal System.Security.Cryptography.Asn1.UtcTimeAttribute : AsnTypeAttribute {
private int <TwoDigitYearMax>k__BackingField
public int TwoDigitYearMax
public int get_TwoDigitYearMax()
public void set_TwoDigitYearMax(int value)
}
public System.Security.Cryptography.CryptographicAttributeObject : object {
private AsnEncodedDataCollection <Values>k__BackingField
private Oid _oid
public Oid Oid
public AsnEncodedDataCollection Values
public void .ctor(Oid oid)
public void .ctor(Oid oid, AsnEncodedDataCollection values)
public Oid get_Oid()
public AsnEncodedDataCollection get_Values()
}
public System.Security.Cryptography.CryptographicAttributeObjectCollection : object {
private List`1<CryptographicAttributeObject> _list
public CryptographicAttributeObject Item
public int Count
public bool IsSynchronized
public object SyncRoot
public void .ctor(CryptographicAttributeObject attribute)
public int Add(AsnEncodedData asnEncodedData)
public int Add(CryptographicAttributeObject attribute)
internal void AddWithoutMerge(CryptographicAttributeObject attribute)
public void Remove(CryptographicAttributeObject attribute)
public CryptographicAttributeObject get_Item(int index)
public int get_Count()
public bool get_IsSynchronized()
public object get_SyncRoot()
public CryptographicAttributeObjectEnumerator GetEnumerator()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
private void System.Collections.ICollection.CopyTo(Array array, int index)
public void CopyTo(CryptographicAttributeObject[] array, int index)
}
public System.Security.Cryptography.CryptographicAttributeObjectEnumerator : object {
private CryptographicAttributeObjectCollection _attributes
private int _current
public CryptographicAttributeObject Current
private object System.Collections.IEnumerator.Current
internal void .ctor(CryptographicAttributeObjectCollection attributes)
public CryptographicAttributeObject get_Current()
private object System.Collections.IEnumerator.get_Current()
public bool MoveNext()
public void Reset()
}
public System.Security.Cryptography.DataProtectionScope : Enum {
public int value__
public DataProtectionScope CurrentUser
public DataProtectionScope LocalMachine
}
public System.Security.Cryptography.DataProtector : object {
private string m_applicationName
private string m_primaryPurpose
private IEnumerable`1<string> m_specificPurposes
private Byte[] modreq(System.Runtime.CompilerServices.IsVolatile) m_hashedPurpose
protected string ApplicationName
protected bool PrependHashedPurposeToPlaintext
protected string PrimaryPurpose
protected IEnumerable`1<string> SpecificPurposes
protected void .ctor(string applicationName, string primaryPurpose, String[] specificPurposes)
protected string get_ApplicationName()
protected bool get_PrependHashedPurposeToPlaintext()
protected Byte[] GetHashedPurpose()
public bool IsReprotectRequired(Byte[] encryptedData)
protected string get_PrimaryPurpose()
protected IEnumerable`1<string> get_SpecificPurposes()
public DataProtector Create(string providerClass, string applicationName, string primaryPurpose, String[] specificPurposes)
public Byte[] Protect(Byte[] userData)
protected Byte[] ProviderProtect(Byte[] userData)
protected Byte[] ProviderUnprotect(Byte[] encryptedData)
public Byte[] Unprotect(Byte[] encryptedData)
}
public System.Security.Cryptography.DpapiDataProtector : DataProtector {
public DataProtectionScope Scope
public void .ctor(string appName, string primaryPurpose, String[] specificPurpose)
public DataProtectionScope get_Scope()
public void set_Scope(DataProtectionScope value)
public bool IsReprotectRequired(Byte[] encryptedData)
protected Byte[] ProviderProtect(Byte[] userData)
protected Byte[] ProviderUnprotect(Byte[] encryptedData)
}
public System.Security.Cryptography.MemoryProtectionScope : Enum {
public int value__
public MemoryProtectionScope SameProcess
public MemoryProtectionScope CrossProcess
public MemoryProtectionScope SameLogon
}
public System.Security.Cryptography.Pkcs.AlgorithmIdentifier : object {
private Oid <Oid>k__BackingField
private int <KeyLength>k__BackingField
private Byte[] <Parameters>k__BackingField
public Oid Oid
public int KeyLength
public Byte[] Parameters
public void .ctor(Oid oid)
public void .ctor(Oid oid, int keyLength)
public Oid get_Oid()
public void set_Oid(Oid value)
public int get_KeyLength()
public void set_KeyLength(int value)
public Byte[] get_Parameters()
public void set_Parameters(Byte[] value)
}
internal System.Security.Cryptography.Pkcs.Asn1.AlgorithmIdentifierAsn : ValueType {
internal ReadOnlyMemory`1<byte> ExplicitDerNull
public Oid Algorithm
public Nullable`1<ReadOnlyMemory`1<byte>> Parameters
internal bool Equals(AlgorithmIdentifierAsn& other)
private bool RepresentsNull(Nullable`1<ReadOnlyMemory`1<byte>> parameters)
}
internal System.Security.Cryptography.Pkcs.Asn1.AttributeAsn : ValueType {
public Oid AttrType
public ReadOnlyMemory`1<byte> AttrValues
}
internal System.Security.Cryptography.Pkcs.Asn1.CadesIssuerSerial : ValueType {
public GeneralName[] Issuer
public ReadOnlyMemory`1<byte> SerialNumber
}
internal System.Security.Cryptography.Pkcs.Asn1.CertificateChoiceAsn : ValueType {
public Nullable`1<ReadOnlyMemory`1<byte>> Certificate
}
internal System.Security.Cryptography.Pkcs.Asn1.ContentInfoAsn : ValueType {
public string ContentType
public ReadOnlyMemory`1<byte> Content
}
internal System.Security.Cryptography.Pkcs.Asn1.DirectoryString : ValueType {
internal Nullable`1<ReadOnlyMemory`1<byte>> TeletexString
internal string PrintableString
internal Nullable`1<ReadOnlyMemory`1<byte>> UniversalString
internal string Utf8String
internal string BMPString
}
internal System.Security.Cryptography.Pkcs.Asn1.EdiPartyName : ValueType {
internal Nullable`1<DirectoryString> NameAssigner
internal DirectoryString PartyName
}
internal System.Security.Cryptography.Pkcs.Asn1.EncapsulatedContentInfoAsn : ValueType {
public string ContentType
public Nullable`1<ReadOnlyMemory`1<byte>> Content
}
internal System.Security.Cryptography.Pkcs.Asn1.EncryptedContentInfoAsn : ValueType {
internal string ContentType
internal AlgorithmIdentifierAsn ContentEncryptionAlgorithm
internal Nullable`1<ReadOnlyMemory`1<byte>> EncryptedContent
}
internal System.Security.Cryptography.Pkcs.Asn1.EnvelopedDataAsn : ValueType {
public int Version
public OriginatorInfoAsn OriginatorInfo
public RecipientInfoAsn[] RecipientInfos
public EncryptedContentInfoAsn EncryptedContentInfo
public AttributeAsn[] UnprotectedAttributes
}
internal System.Security.Cryptography.Pkcs.Asn1.EssCertId : object {
public ReadOnlyMemory`1<byte> Hash
public Nullable`1<CadesIssuerSerial> IssuerSerial
}
internal System.Security.Cryptography.Pkcs.Asn1.EssCertIdV2 : object {
public AlgorithmIdentifierAsn HashAlgorithm
public ReadOnlyMemory`1<byte> Hash
public Nullable`1<CadesIssuerSerial> IssuerSerial
}
internal System.Security.Cryptography.Pkcs.Asn1.GeneralName : ValueType {
internal Nullable`1<OtherName> OtherName
internal string Rfc822Name
internal string DnsName
internal Nullable`1<ReadOnlyMemory`1<byte>> X400Address
internal Nullable`1<ReadOnlyMemory`1<byte>> DirectoryName
internal Nullable`1<EdiPartyName> EdiPartyName
internal string Uri
internal Nullable`1<ReadOnlyMemory`1<byte>> IPAddress
internal string RegisteredId
}
internal System.Security.Cryptography.Pkcs.Asn1.IssuerAndSerialNumberAsn : ValueType {
public ReadOnlyMemory`1<byte> Issuer
public ReadOnlyMemory`1<byte> SerialNumber
}
internal System.Security.Cryptography.Pkcs.Asn1.KeyAgreeRecipientIdentifierAsn : ValueType {
internal Nullable`1<IssuerAndSerialNumberAsn> IssuerAndSerialNumber
internal RecipientKeyIdentifier RKeyId
}
internal System.Security.Cryptography.Pkcs.Asn1.KeyAgreeRecipientInfoAsn : object {
internal int Version
internal OriginatorIdentifierOrKeyAsn Originator
internal Nullable`1<ReadOnlyMemory`1<byte>> Ukm
internal AlgorithmIdentifierAsn KeyEncryptionAlgorithm
internal RecipientEncryptedKeyAsn[] RecipientEncryptedKeys
}
internal System.Security.Cryptography.Pkcs.Asn1.KeyTransRecipientInfoAsn : object {
internal int Version
internal RecipientIdentifierAsn Rid
internal AlgorithmIdentifierAsn KeyEncryptionAlgorithm
internal ReadOnlyMemory`1<byte> EncryptedKey
}
internal System.Security.Cryptography.Pkcs.Asn1.MessageImprint : ValueType {
internal AlgorithmIdentifierAsn HashAlgorithm
internal ReadOnlyMemory`1<byte> HashedMessage
}
internal System.Security.Cryptography.Pkcs.Asn1.OriginatorIdentifierOrKeyAsn : ValueType {
internal Nullable`1<IssuerAndSerialNumberAsn> IssuerAndSerialNumber
internal Nullable`1<ReadOnlyMemory`1<byte>> SubjectKeyIdentifier
internal OriginatorPublicKeyAsn OriginatorKey
}
internal System.Security.Cryptography.Pkcs.Asn1.OriginatorInfoAsn : object {
public CertificateChoiceAsn[] CertificateSet
public Nullable`1<ReadOnlyMemory`1<byte>> RevocationInfoChoices
}
internal System.Security.Cryptography.Pkcs.Asn1.OriginatorPublicKeyAsn : object {
internal AlgorithmIdentifierAsn Algorithm
internal ReadOnlyMemory`1<byte> PublicKey
}
internal System.Security.Cryptography.Pkcs.Asn1.OtherKeyAttributeAsn : ValueType {
internal string KeyAttrId
internal Nullable`1<ReadOnlyMemory`1<byte>> KeyAttr
}
internal System.Security.Cryptography.Pkcs.Asn1.OtherName : ValueType {
internal string TypeId
internal ReadOnlyMemory`1<byte> Value
}
internal System.Security.Cryptography.Pkcs.Asn1.PkiFailureInfo : Enum {
public int value__
public PkiFailureInfo None
public PkiFailureInfo BadAlg
public PkiFailureInfo BadMessageCheck
public PkiFailureInfo BadRequest
public PkiFailureInfo BadTime
public PkiFailureInfo BadCertId
public PkiFailureInfo BadDataFormat
public PkiFailureInfo WrongAuthority
public PkiFailureInfo IncorrectData
public PkiFailureInfo MissingTimeStamp
public PkiFailureInfo BadPop
public PkiFailureInfo CertRevoked
public PkiFailureInfo CertConfirmed
public PkiFailureInfo WrongIntegrity
public PkiFailureInfo BadRecipientNonce
public PkiFailureInfo TimeNotAvailable
public PkiFailureInfo UnacceptedPolicy
public PkiFailureInfo UnacceptedExtension
public PkiFailureInfo AddInfoNotAvailable
public PkiFailureInfo BadSenderNonce
public PkiFailureInfo BadCertTemplate
public PkiFailureInfo SignerNotTrusted
public PkiFailureInfo TransactionIdInUse
public PkiFailureInfo UnsupportedVersion
public PkiFailureInfo NotAuthorized
public PkiFailureInfo SystemUnavail
public PkiFailureInfo SystemFailure
public PkiFailureInfo DuplicateCertReq
}
internal System.Security.Cryptography.Pkcs.Asn1.PkiStatus : Enum {
public int value__
public PkiStatus Granted
public PkiStatus GrantedWithMods
public PkiStatus Rejection
public PkiStatus Waiting
public PkiStatus RevocationWarning
public PkiStatus RevocationNotification
public PkiStatus KeyUpdateWarning
}
internal System.Security.Cryptography.Pkcs.Asn1.PkiStatusInfo : ValueType {
public int Status
public Nullable`1<ReadOnlyMemory`1<byte>> StatusString
public Nullable`1<PkiFailureInfo> FailInfo
}
internal System.Security.Cryptography.Pkcs.Asn1.PolicyInformation : ValueType {
public string PolicyIdentifier
public PolicyQualifierInfo[] PolicyQualifiers
}
internal System.Security.Cryptography.Pkcs.Asn1.PolicyQualifierInfo : ValueType {
public string PolicyQualifierId
public ReadOnlyMemory`1<byte> Qualifier
}
internal System.Security.Cryptography.Pkcs.Asn1.PssParamsAsn : ValueType {
public AlgorithmIdentifierAsn HashAlgorithm
public AlgorithmIdentifierAsn MaskGenAlgorithm
public int SaltLength
public int TrailerField
}
internal System.Security.Cryptography.Pkcs.Asn1.Rc2CbcParameters : ValueType {
private Byte[] s_rc2EkbEncoding
internal int Rc2Version
internal ReadOnlyMemory`1<byte> Iv
internal void .ctor(ReadOnlyMemory`1<byte> iv, int keySize)
internal int GetEffectiveKeyBits()
}
internal System.Security.Cryptography.Pkcs.Asn1.RecipientEncryptedKeyAsn : ValueType {
internal KeyAgreeRecipientIdentifierAsn Rid
internal ReadOnlyMemory`1<byte> EncryptedKey
}
internal System.Security.Cryptography.Pkcs.Asn1.RecipientIdentifierAsn : ValueType {
internal Nullable`1<IssuerAndSerialNumberAsn> IssuerAndSerialNumber
internal Nullable`1<ReadOnlyMemory`1<byte>> SubjectKeyIdentifier
}
internal System.Security.Cryptography.Pkcs.Asn1.RecipientInfoAsn : ValueType {
internal KeyTransRecipientInfoAsn Ktri
internal KeyAgreeRecipientInfoAsn Kari
}
internal System.Security.Cryptography.Pkcs.Asn1.RecipientKeyIdentifier : object {
internal ReadOnlyMemory`1<byte> SubjectKeyIdentifier
internal Nullable`1<DateTimeOffset> Date
internal Nullable`1<OtherKeyAttributeAsn> Other
}
internal System.Security.Cryptography.Pkcs.Asn1.Rfc3161Accuracy : ValueType {
internal Nullable`1<int> Seconds
internal Nullable`1<int> Millis
internal Nullable`1<int> Micros
internal long TotalMicros
internal void .ctor(long accuracyInMicroseconds)
internal long get_TotalMicros()
}
internal System.Security.Cryptography.Pkcs.Asn1.Rfc3161TimeStampReq : ValueType {
public int Version
public MessageImprint MessageImprint
public Oid ReqPolicy
public Nullable`1<ReadOnlyMemory`1<byte>> Nonce
public bool CertReq
internal X509ExtensionAsn[] Extensions
}
internal System.Security.Cryptography.Pkcs.Asn1.Rfc3161TimeStampResp : ValueType {
public PkiStatusInfo Status
public Nullable`1<ReadOnlyMemory`1<byte>> TimeStampToken
}
internal System.Security.Cryptography.Pkcs.Asn1.Rfc3161TstInfo : object {
internal int Version
internal Oid Policy
internal MessageImprint MessageImprint
internal ReadOnlyMemory`1<byte> SerialNumber
internal DateTimeOffset GenTime
internal Nullable`1<Rfc3161Accuracy> Accuracy
internal bool Ordering
internal Nullable`1<ReadOnlyMemory`1<byte>> Nonce
internal Nullable`1<GeneralName> Tsa
internal X509ExtensionAsn[] Extensions
}
internal System.Security.Cryptography.Pkcs.Asn1.SignedAttributesSet : ValueType {
public AttributeAsn[] SignedAttributes
}
internal System.Security.Cryptography.Pkcs.Asn1.SignedDataAsn : ValueType {
public int Version
public AlgorithmIdentifierAsn[] DigestAlgorithms
public EncapsulatedContentInfoAsn EncapContentInfo
public CertificateChoiceAsn[] CertificateSet
public Nullable`1<ReadOnlyMemory`1<byte>> RevocationInfoChoices
public SignerInfoAsn[] SignerInfos
}
internal System.Security.Cryptography.Pkcs.Asn1.SignerIdentifierAsn : ValueType {
public Nullable`1<IssuerAndSerialNumberAsn> IssuerAndSerialNumber
public Nullable`1<ReadOnlyMemory`1<byte>> SubjectKeyIdentifier
}
internal System.Security.Cryptography.Pkcs.Asn1.SignerInfoAsn : ValueType {
public int Version
public SignerIdentifierAsn Sid
public AlgorithmIdentifierAsn DigestAlgorithm
public Nullable`1<ReadOnlyMemory`1<byte>> SignedAttributes
public AlgorithmIdentifierAsn SignatureAlgorithm
public ReadOnlyMemory`1<byte> SignatureValue
public AttributeAsn[] UnsignedAttributes
}
internal System.Security.Cryptography.Pkcs.Asn1.SigningCertificateAsn : ValueType {
public EssCertId[] Certs
public PolicyInformation[] Policies
}
internal System.Security.Cryptography.Pkcs.Asn1.SigningCertificateV2Asn : ValueType {
public EssCertIdV2[] Certs
public PolicyInformation[] Policies
}
internal System.Security.Cryptography.Pkcs.Asn1.X509ExtensionAsn : ValueType {
internal string ExtnId
internal bool Critical
internal ReadOnlyMemory`1<byte> ExtnValue
public void .ctor(X509Extension extension, bool copyValue)
}
public System.Security.Cryptography.Pkcs.CmsRecipient : object {
private SubjectIdentifierType <RecipientIdentifierType>k__BackingField
private X509Certificate2 <Certificate>k__BackingField
public SubjectIdentifierType RecipientIdentifierType
public X509Certificate2 Certificate
public void .ctor(X509Certificate2 certificate)
public void .ctor(SubjectIdentifierType recipientIdentifierType, X509Certificate2 certificate)
public SubjectIdentifierType get_RecipientIdentifierType()
public X509Certificate2 get_Certificate()
}
public System.Security.Cryptography.Pkcs.CmsRecipientCollection : object {
private List`1<CmsRecipient> _recipients
public CmsRecipient Item
public int Count
public bool IsSynchronized
public object SyncRoot
public void .ctor(CmsRecipient recipient)
public void .ctor(SubjectIdentifierType recipientIdentifierType, X509Certificate2Collection certificates)
public CmsRecipient get_Item(int index)
public int get_Count()
public int Add(CmsRecipient recipient)
public void Remove(CmsRecipient recipient)
public CmsRecipientEnumerator GetEnumerator()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
public void CopyTo(Array array, int index)
public void CopyTo(CmsRecipient[] array, int index)
public bool get_IsSynchronized()
public object get_SyncRoot()
}
public System.Security.Cryptography.Pkcs.CmsRecipientEnumerator : object {
private CmsRecipientCollection _recipients
private int _current
public CmsRecipient Current
private object System.Collections.IEnumerator.Current
internal void .ctor(CmsRecipientCollection recipients)
public CmsRecipient get_Current()
private object System.Collections.IEnumerator.get_Current()
public bool MoveNext()
public void Reset()
}
internal System.Security.Cryptography.Pkcs.CmsSignature : object {
private Dictionary`2<string, CmsSignature> s_lookup
private void PrepareRegistrationRsa(Dictionary`2<string, CmsSignature> lookup)
private void PrepareRegistrationDsa(Dictionary`2<string, CmsSignature> lookup)
private void PrepareRegistrationECDsa(Dictionary`2<string, CmsSignature> lookup)
internal bool VerifySignature(Byte[] valueHash, Byte[] signature, string digestAlgorithmOid, HashAlgorithmName digestAlgorithmName, Nullable`1<ReadOnlyMemory`1<byte>> signatureParameters, X509Certificate2 certificate)
protected bool Sign(Byte[] dataHash, HashAlgorithmName hashAlgorithmName, X509Certificate2 certificate, bool silent, Oid& signatureAlgorithm, Byte[]& signatureValue)
internal CmsSignature Resolve(string signatureAlgorithmOid)
internal bool Sign(Byte[] dataHash, HashAlgorithmName hashAlgorithmName, X509Certificate2 certificate, bool silent, Oid& oid, ReadOnlyMemory`1& signatureValue)
private bool DsaDerToIeee(ReadOnlyMemory`1<byte> derSignature, Span`1<byte> ieeeSignature)
private Byte[] DsaIeeeToDer(ReadOnlySpan`1<byte> ieeeSignature)
}
public System.Security.Cryptography.Pkcs.CmsSigner : object {
private Oid s_defaultAlgorithm
private SubjectIdentifierType _signerIdentifierType
private X509Certificate2 <Certificate>k__BackingField
private AsymmetricAlgorithm <PrivateKey>k__BackingField
private X509Certificate2Collection <Certificates>k__BackingField
private Oid <DigestAlgorithm>k__BackingField
private X509IncludeOption <IncludeOption>k__BackingField
private CryptographicAttributeObjectCollection <SignedAttributes>k__BackingField
private CryptographicAttributeObjectCollection <UnsignedAttributes>k__BackingField
public X509Certificate2 Certificate
public AsymmetricAlgorithm PrivateKey
public X509Certificate2Collection Certificates
public Oid DigestAlgorithm
public X509IncludeOption IncludeOption
public CryptographicAttributeObjectCollection SignedAttributes
public CryptographicAttributeObjectCollection UnsignedAttributes
public SubjectIdentifierType SignerIdentifierType
public X509Certificate2 get_Certificate()
public void set_Certificate(X509Certificate2 value)
public AsymmetricAlgorithm get_PrivateKey()
public void set_PrivateKey(AsymmetricAlgorithm value)
public X509Certificate2Collection get_Certificates()
private void set_Certificates(X509Certificate2Collection value)
public Oid get_DigestAlgorithm()
public void set_DigestAlgorithm(Oid value)
public X509IncludeOption get_IncludeOption()
public void set_IncludeOption(X509IncludeOption value)
public CryptographicAttributeObjectCollection get_SignedAttributes()
private void set_SignedAttributes(CryptographicAttributeObjectCollection value)
public CryptographicAttributeObjectCollection get_UnsignedAttributes()
private void set_UnsignedAttributes(CryptographicAttributeObjectCollection value)
public SubjectIdentifierType get_SignerIdentifierType()
public void set_SignerIdentifierType(SubjectIdentifierType value)
public void .ctor(SubjectIdentifierType signerIdentifierType)
public void .ctor(X509Certificate2 certificate)
public void .ctor(CspParameters parameters)
public void .ctor(SubjectIdentifierType signerIdentifierType, X509Certificate2 certificate)
internal void CheckCertificateValue()
internal SignerInfoAsn Sign(ReadOnlyMemory`1<byte> data, string contentTypeOid, bool silent, X509Certificate2Collection& chainCerts)
internal List`1<AttributeAsn> BuildAttributes(CryptographicAttributeObjectCollection attributes)
}
public System.Security.Cryptography.Pkcs.ContentInfo : object {
private Oid <ContentType>k__BackingField
private Byte[] <Content>k__BackingField
public Oid ContentType
public Byte[] Content
public void .ctor(Byte[] content)
public void .ctor(Oid contentType, Byte[] content)
public Oid get_ContentType()
public Byte[] get_Content()
public Oid GetContentType(Byte[] encodedMessage)
}
public System.Security.Cryptography.Pkcs.EnvelopedCms : object {
private int <Version>k__BackingField
private ContentInfo <ContentInfo>k__BackingField
private AlgorithmIdentifier <ContentEncryptionAlgorithm>k__BackingField
private X509Certificate2Collection <Certificates>k__BackingField
private CryptographicAttributeObjectCollection <UnprotectedAttributes>k__BackingField
private DecryptorPal _decryptorPal
private Byte[] _encodedMessage
private LastCall _lastCall
public int Version
public ContentInfo ContentInfo
public AlgorithmIdentifier ContentEncryptionAlgorithm
public X509Certificate2Collection Certificates
public CryptographicAttributeObjectCollection UnprotectedAttributes
public RecipientInfoCollection RecipientInfos
public void .ctor(ContentInfo contentInfo)
public void .ctor(ContentInfo contentInfo, AlgorithmIdentifier encryptionAlgorithm)
public int get_Version()
private void set_Version(int value)
public ContentInfo get_ContentInfo()
private void set_ContentInfo(ContentInfo value)
public AlgorithmIdentifier get_ContentEncryptionAlgorithm()
private void set_ContentEncryptionAlgorithm(AlgorithmIdentifier value)
public X509Certificate2Collection get_Certificates()
private void set_Certificates(X509Certificate2Collection value)
public CryptographicAttributeObjectCollection get_UnprotectedAttributes()
private void set_UnprotectedAttributes(CryptographicAttributeObjectCollection value)
public RecipientInfoCollection get_RecipientInfos()
public void Encrypt(CmsRecipient recipient)
public void Encrypt(CmsRecipientCollection recipients)
public Byte[] Encode()
public void Decode(Byte[] encodedMessage)
public void Decrypt()
public void Decrypt(RecipientInfo recipientInfo)
public void Decrypt(RecipientInfo recipientInfo, X509Certificate2Collection extraStore)
public void Decrypt(X509Certificate2Collection extraStore)
private void DecryptContent(RecipientInfoCollection recipientInfos, X509Certificate2Collection extraStore)
public void .ctor(SubjectIdentifierType recipientIdentifierType, ContentInfo contentInfo)
public void .ctor(SubjectIdentifierType recipientIdentifierType, ContentInfo contentInfo, AlgorithmIdentifier encryptionAlgorithm)
public void Encrypt()
}
public System.Security.Cryptography.Pkcs.KeyAgreeKeyChoice : Enum {
public int value__
public KeyAgreeKeyChoice Unknown
public KeyAgreeKeyChoice EphemeralKey
public KeyAgreeKeyChoice StaticKey
}
public System.Security.Cryptography.Pkcs.KeyAgreeRecipientInfo : RecipientInfo {
private SubjectIdentifier modreq(System.Runtime.CompilerServices.IsVolatile) _lazyRecipientIdentifier
private AlgorithmIdentifier modreq(System.Runtime.CompilerServices.IsVolatile) _lazyKeyEncryptionAlgorithm
private Byte[] modreq(System.Runtime.CompilerServices.IsVolatile) _lazyEncryptedKey
private SubjectIdentifierOrKey modreq(System.Runtime.CompilerServices.IsVolatile) _lazyOriginatorIdentifierKey
private Nullable`1<DateTime> _lazyDate
private CryptographicAttributeObject modreq(System.Runtime.CompilerServices.IsVolatile) _lazyOtherKeyAttribute
public int Version
public SubjectIdentifier RecipientIdentifier
public AlgorithmIdentifier KeyEncryptionAlgorithm
public Byte[] EncryptedKey
public SubjectIdentifierOrKey OriginatorIdentifierOrKey
public DateTime Date
public CryptographicAttributeObject OtherKeyAttribute
private KeyAgreeRecipientInfoPal Pal
internal void .ctor(KeyAgreeRecipientInfoPal pal)
public int get_Version()
public SubjectIdentifier get_RecipientIdentifier()
public AlgorithmIdentifier get_KeyEncryptionAlgorithm()
public Byte[] get_EncryptedKey()
public SubjectIdentifierOrKey get_OriginatorIdentifierOrKey()
public DateTime get_Date()
public CryptographicAttributeObject get_OtherKeyAttribute()
private KeyAgreeRecipientInfoPal get_Pal()
}
public System.Security.Cryptography.Pkcs.KeyTransRecipientInfo : RecipientInfo {
private SubjectIdentifier modreq(System.Runtime.CompilerServices.IsVolatile) _lazyRecipientIdentifier
private AlgorithmIdentifier modreq(System.Runtime.CompilerServices.IsVolatile) _lazyKeyEncryptionAlgorithm
private Byte[] modreq(System.Runtime.CompilerServices.IsVolatile) _lazyEncryptedKey
public int Version
public SubjectIdentifier RecipientIdentifier
public AlgorithmIdentifier KeyEncryptionAlgorithm
public Byte[] EncryptedKey
private KeyTransRecipientInfoPal Pal
internal void .ctor(KeyTransRecipientInfoPal pal)
public int get_Version()
public SubjectIdentifier get_RecipientIdentifier()
public AlgorithmIdentifier get_KeyEncryptionAlgorithm()
public Byte[] get_EncryptedKey()
private KeyTransRecipientInfoPal get_Pal()
}
public System.Security.Cryptography.Pkcs.Pkcs12Builder : object {
public bool IsSealed
public bool get_IsSealed()
public void AddSafeContentsEncrypted(Pkcs12SafeContents safeContents, Byte[] passwordBytes, PbeParameters pbeParameters)
public void AddSafeContentsEncrypted(Pkcs12SafeContents safeContents, ReadOnlySpan`1<byte> passwordBytes, PbeParameters pbeParameters)
public void AddSafeContentsEncrypted(Pkcs12SafeContents safeContents, ReadOnlySpan`1<char> password, PbeParameters pbeParameters)
public void AddSafeContentsEncrypted(Pkcs12SafeContents safeContents, string password, PbeParameters pbeParameters)
public void AddSafeContentsUnencrypted(Pkcs12SafeContents safeContents)
public Byte[] Encode()
public void SealWithMac(ReadOnlySpan`1<char> password, HashAlgorithmName hashAlgorithm, int iterationCount)
public void SealWithMac(string password, HashAlgorithmName hashAlgorithm, int iterationCount)
public void SealWithoutIntegrity()
public bool TryEncode(Span`1<byte> destination, Int32& bytesWritten)
}
public System.Security.Cryptography.Pkcs.Pkcs12CertBag : Pkcs12SafeBag {
public ReadOnlyMemory`1<byte> EncodedCertificate
public bool IsX509Certificate
public ReadOnlyMemory`1<byte> get_EncodedCertificate()
public bool get_IsX509Certificate()
public void .ctor(Oid certificateType, ReadOnlyMemory`1<byte> encodedCertificate)
public X509Certificate2 GetCertificate()
public Oid GetCertificateType()
}
public System.Security.Cryptography.Pkcs.Pkcs12ConfidentialityMode : Enum {
public int value__
public Pkcs12ConfidentialityMode None
public Pkcs12ConfidentialityMode Password
public Pkcs12ConfidentialityMode PublicKey
public Pkcs12ConfidentialityMode Unknown
}
public System.Security.Cryptography.Pkcs.Pkcs12Info : object {
public ReadOnlyCollection`1<Pkcs12SafeContents> AuthenticatedSafe
public Pkcs12IntegrityMode IntegrityMode
public ReadOnlyCollection`1<Pkcs12SafeContents> get_AuthenticatedSafe()
public Pkcs12IntegrityMode get_IntegrityMode()
public Pkcs12Info Decode(ReadOnlyMemory`1<byte> encodedBytes, Int32& bytesConsumed, bool skipCopy)
public bool VerifyMac(ReadOnlySpan`1<char> password)
public bool VerifyMac(string password)
}
public System.Security.Cryptography.Pkcs.Pkcs12IntegrityMode : Enum {
public int value__
public Pkcs12IntegrityMode None
public Pkcs12IntegrityMode Password
public Pkcs12IntegrityMode PublicKey
public Pkcs12IntegrityMode Unknown
}
public System.Security.Cryptography.Pkcs.Pkcs12KeyBag : Pkcs12SafeBag {
public ReadOnlyMemory`1<byte> Pkcs8PrivateKey
public ReadOnlyMemory`1<byte> get_Pkcs8PrivateKey()
public void .ctor(ReadOnlyMemory`1<byte> pkcs8PrivateKey, bool skipCopy)
}
public System.Security.Cryptography.Pkcs.Pkcs12SafeBag : object {
public CryptographicAttributeObjectCollection Attributes
public ReadOnlyMemory`1<byte> EncodedBagValue
public CryptographicAttributeObjectCollection get_Attributes()
public ReadOnlyMemory`1<byte> get_EncodedBagValue()
protected void .ctor(string bagIdValue, ReadOnlyMemory`1<byte> encodedBagValue, bool skipCopy)
public Byte[] Encode()
public Oid GetBagId()
public bool TryEncode(Span`1<byte> destination, Int32& bytesWritten)
}
public System.Security.Cryptography.Pkcs.Pkcs12SafeContents : object {
public Pkcs12ConfidentialityMode ConfidentialityMode
public bool IsReadOnly
public Pkcs12ConfidentialityMode get_ConfidentialityMode()
public bool get_IsReadOnly()
public Pkcs12CertBag AddCertificate(X509Certificate2 certificate)
public Pkcs12KeyBag AddKeyUnencrypted(AsymmetricAlgorithm key)
public Pkcs12SafeContentsBag AddNestedContents(Pkcs12SafeContents safeContents)
public void AddSafeBag(Pkcs12SafeBag safeBag)
public Pkcs12SecretBag AddSecret(Oid secretType, ReadOnlyMemory`1<byte> secretValue)
public Pkcs12ShroudedKeyBag AddShroudedKey(AsymmetricAlgorithm key, Byte[] passwordBytes, PbeParameters pbeParameters)
public Pkcs12ShroudedKeyBag AddShroudedKey(AsymmetricAlgorithm key, ReadOnlySpan`1<byte> passwordBytes, PbeParameters pbeParameters)
public Pkcs12ShroudedKeyBag AddShroudedKey(AsymmetricAlgorithm key, ReadOnlySpan`1<char> password, PbeParameters pbeParameters)
public Pkcs12ShroudedKeyBag AddShroudedKey(AsymmetricAlgorithm key, string password, PbeParameters pbeParameters)
public void Decrypt(Byte[] passwordBytes)
public void Decrypt(ReadOnlySpan`1<byte> passwordBytes)
public void Decrypt(ReadOnlySpan`1<char> password)
public void Decrypt(string password)
public IEnumerable`1<Pkcs12SafeBag> GetBags()
}
public System.Security.Cryptography.Pkcs.Pkcs12SafeContentsBag : Pkcs12SafeBag {
public Pkcs12SafeContents SafeContents
public Pkcs12SafeContents get_SafeContents()
}
public System.Security.Cryptography.Pkcs.Pkcs12SecretBag : Pkcs12SafeBag {
public ReadOnlyMemory`1<byte> SecretValue
public ReadOnlyMemory`1<byte> get_SecretValue()
public Oid GetSecretType()
}
public System.Security.Cryptography.Pkcs.Pkcs12ShroudedKeyBag : Pkcs12SafeBag {
public ReadOnlyMemory`1<byte> EncryptedPkcs8PrivateKey
public ReadOnlyMemory`1<byte> get_EncryptedPkcs8PrivateKey()
public void .ctor(ReadOnlyMemory`1<byte> encryptedPkcs8PrivateKey, bool skipCopy)
}
public System.Security.Cryptography.Pkcs.Pkcs8PrivateKeyInfo : object {
public Oid AlgorithmId
public Nullable`1<ReadOnlyMemory`1<byte>> AlgorithmParameters
public CryptographicAttributeObjectCollection Attributes
public ReadOnlyMemory`1<byte> PrivateKeyBytes
public Oid get_AlgorithmId()
public Nullable`1<ReadOnlyMemory`1<byte>> get_AlgorithmParameters()
public CryptographicAttributeObjectCollection get_Attributes()
public ReadOnlyMemory`1<byte> get_PrivateKeyBytes()
public void .ctor(Oid algorithmId, Nullable`1<ReadOnlyMemory`1<byte>> algorithmParameters, ReadOnlyMemory`1<byte> privateKey, bool skipCopies)
public Pkcs8PrivateKeyInfo Create(AsymmetricAlgorithm privateKey)
public Pkcs8PrivateKeyInfo Decode(ReadOnlyMemory`1<byte> source, Int32& bytesRead, bool skipCopy)
public Pkcs8PrivateKeyInfo DecryptAndDecode(ReadOnlySpan`1<byte> passwordBytes, ReadOnlyMemory`1<byte> source, Int32& bytesRead)
public Pkcs8PrivateKeyInfo DecryptAndDecode(ReadOnlySpan`1<char> password, ReadOnlyMemory`1<byte> source, Int32& bytesRead)
public Byte[] Encode()
public Byte[] Encrypt(ReadOnlySpan`1<byte> passwordBytes, PbeParameters pbeParameters)
public Byte[] Encrypt(ReadOnlySpan`1<char> password, PbeParameters pbeParameters)
public bool TryEncode(Span`1<byte> destination, Int32& bytesWritten)
public bool TryEncrypt(ReadOnlySpan`1<byte> passwordBytes, PbeParameters pbeParameters, Span`1<byte> destination, Int32& bytesWritten)
public bool TryEncrypt(ReadOnlySpan`1<char> password, PbeParameters pbeParameters, Span`1<byte> destination, Int32& bytesWritten)
}
public System.Security.Cryptography.Pkcs.Pkcs9AttributeObject : AsnEncodedData {
public Oid Oid
public void .ctor(string oid, Byte[] encodedData)
public void .ctor(Oid oid, Byte[] encodedData)
public void .ctor(AsnEncodedData asnEncodedData)
internal void .ctor(Oid oid)
public Oid get_Oid()
public void CopyFrom(AsnEncodedData asnEncodedData)
}
public System.Security.Cryptography.Pkcs.Pkcs9ContentType : Pkcs9AttributeObject {
private Oid modreq(System.Runtime.CompilerServices.IsVolatile) _lazyContentType
public Oid ContentType
public Oid get_ContentType()
public void CopyFrom(AsnEncodedData asnEncodedData)
private Oid Decode(Byte[] rawData)
}
public System.Security.Cryptography.Pkcs.Pkcs9DocumentDescription : Pkcs9AttributeObject {
private String modreq(System.Runtime.CompilerServices.IsVolatile) _lazyDocumentDescription
public string DocumentDescription
public void .ctor(string documentDescription)
public void .ctor(Byte[] encodedDocumentDescription)
public string get_DocumentDescription()
public void CopyFrom(AsnEncodedData asnEncodedData)
private string Decode(Byte[] rawData)
private Byte[] Encode(string documentDescription)
}
public System.Security.Cryptography.Pkcs.Pkcs9DocumentName : Pkcs9AttributeObject {
private String modreq(System.Runtime.CompilerServices.IsVolatile) _lazyDocumentName
public string DocumentName
public void .ctor(string documentName)
public void .ctor(Byte[] encodedDocumentName)
public string get_DocumentName()
public void CopyFrom(AsnEncodedData asnEncodedData)
private string Decode(Byte[] rawData)
private Byte[] Encode(string documentName)
}
public System.Security.Cryptography.Pkcs.Pkcs9LocalKeyId : Pkcs9AttributeObject {
public ReadOnlyMemory`1<byte> KeyId
public ReadOnlyMemory`1<byte> get_KeyId()
public void .ctor(Byte[] keyId)
public void .ctor(ReadOnlySpan`1<byte> keyId)
}
public System.Security.Cryptography.Pkcs.Pkcs9MessageDigest : Pkcs9AttributeObject {
private Byte[] modreq(System.Runtime.CompilerServices.IsVolatile) _lazyMessageDigest
public Byte[] MessageDigest
internal void .ctor(ReadOnlySpan`1<byte> signatureDigest)
public Byte[] get_MessageDigest()
public void CopyFrom(AsnEncodedData asnEncodedData)
private Byte[] Decode(Byte[] rawData)
}
public System.Security.Cryptography.Pkcs.Pkcs9SigningTime : Pkcs9AttributeObject {
private Nullable`1<DateTime> _lazySigningTime
public DateTime SigningTime
public void .ctor(DateTime signingTime)
public void .ctor(Byte[] encodedSigningTime)
public DateTime get_SigningTime()
public void CopyFrom(AsnEncodedData asnEncodedData)
private DateTime Decode(Byte[] rawData)
private Byte[] Encode(DateTime signingTime)
}
public System.Security.Cryptography.Pkcs.PublicKeyInfo : object {
private AlgorithmIdentifier <Algorithm>k__BackingField
private Byte[] <KeyValue>k__BackingField
public AlgorithmIdentifier Algorithm
public Byte[] KeyValue
internal void .ctor(AlgorithmIdentifier algorithm, Byte[] keyValue)
public AlgorithmIdentifier get_Algorithm()
public Byte[] get_KeyValue()
}
public System.Security.Cryptography.Pkcs.RecipientInfo : object {
private RecipientInfoType <Type>k__BackingField
private RecipientInfoPal <Pal>k__BackingField
public RecipientInfoType Type
public int Version
public SubjectIdentifier RecipientIdentifier
public AlgorithmIdentifier KeyEncryptionAlgorithm
public Byte[] EncryptedKey
internal RecipientInfoPal Pal
internal void .ctor(RecipientInfoType type, RecipientInfoPal pal)
public RecipientInfoType get_Type()
public int get_Version()
public SubjectIdentifier get_RecipientIdentifier()
public AlgorithmIdentifier get_KeyEncryptionAlgorithm()
public Byte[] get_EncryptedKey()
internal RecipientInfoPal get_Pal()
}
public System.Security.Cryptography.Pkcs.RecipientInfoCollection : object {
private RecipientInfo[] _recipientInfos
public RecipientInfo Item
public int Count
public bool IsSynchronized
public object SyncRoot
internal void .ctor(RecipientInfo recipientInfo)
internal void .ctor(ICollection`1<RecipientInfo> recipientInfos)
public RecipientInfo get_Item(int index)
public int get_Count()
public RecipientInfoEnumerator GetEnumerator()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
public void CopyTo(Array array, int index)
public void CopyTo(RecipientInfo[] array, int index)
public bool get_IsSynchronized()
public object get_SyncRoot()
}
public System.Security.Cryptography.Pkcs.RecipientInfoEnumerator : object {
private RecipientInfoCollection _recipientInfos
private int _current
public RecipientInfo Current
private object System.Collections.IEnumerator.Current
internal void .ctor(RecipientInfoCollection RecipientInfos)
public RecipientInfo get_Current()
private object System.Collections.IEnumerator.get_Current()
public bool MoveNext()
public void Reset()
}
public System.Security.Cryptography.Pkcs.RecipientInfoType : Enum {
public int value__
public RecipientInfoType Unknown
public RecipientInfoType KeyTransport
public RecipientInfoType KeyAgreement
}
public System.Security.Cryptography.Pkcs.Rfc3161TimestampRequest : object {
public bool HasExtensions
public Oid HashAlgorithmId
public Oid RequestedPolicyId
public bool RequestSignerCertificate
public int Version
public bool get_HasExtensions()
public Oid get_HashAlgorithmId()
public Oid get_RequestedPolicyId()
public bool get_RequestSignerCertificate()
public int get_Version()
public Rfc3161TimestampRequest CreateFromData(ReadOnlySpan`1<byte> data, HashAlgorithmName hashAlgorithm, Oid requestedPolicyId, Nullable`1<ReadOnlyMemory`1<byte>> nonce, bool requestSignerCertificates, X509ExtensionCollection extensions)
public Rfc3161TimestampRequest CreateFromHash(ReadOnlyMemory`1<byte> hash, HashAlgorithmName hashAlgorithm, Oid requestedPolicyId, Nullable`1<ReadOnlyMemory`1<byte>> nonce, bool requestSignerCertificates, X509ExtensionCollection extensions)
public Rfc3161TimestampRequest CreateFromHash(ReadOnlyMemory`1<byte> hash, Oid hashAlgorithmId, Oid requestedPolicyId, Nullable`1<ReadOnlyMemory`1<byte>> nonce, bool requestSignerCertificates, X509ExtensionCollection extensions)
public Rfc3161TimestampRequest CreateFromSignerInfo(SignerInfo signerInfo, HashAlgorithmName hashAlgorithm, Oid requestedPolicyId, Nullable`1<ReadOnlyMemory`1<byte>> nonce, bool requestSignerCertificates, X509ExtensionCollection extensions)
public Byte[] Encode()
public X509ExtensionCollection GetExtensions()
public ReadOnlyMemory`1<byte> GetMessageHash()
public Nullable`1<ReadOnlyMemory`1<byte>> GetNonce()
public Rfc3161TimestampToken ProcessResponse(ReadOnlyMemory`1<byte> responseBytes, Int32& bytesConsumed)
public bool TryDecode(ReadOnlyMemory`1<byte> encodedBytes, Rfc3161TimestampRequest& request, Int32& bytesConsumed)
public bool TryEncode(Span`1<byte> destination, Int32& bytesWritten)
}
public System.Security.Cryptography.Pkcs.Rfc3161TimestampToken : object {
public Rfc3161TimestampTokenInfo TokenInfo
public Rfc3161TimestampTokenInfo get_TokenInfo()
public SignedCms AsSignedCms()
public bool TryDecode(ReadOnlyMemory`1<byte> encodedBytes, Rfc3161TimestampToken& token, Int32& bytesConsumed)
public bool VerifySignatureForData(ReadOnlySpan`1<byte> data, X509Certificate2& signerCertificate, X509Certificate2Collection extraCandidates)
public bool VerifySignatureForHash(ReadOnlySpan`1<byte> hash, HashAlgorithmName hashAlgorithm, X509Certificate2& signerCertificate, X509Certificate2Collection extraCandidates)
public bool VerifySignatureForHash(ReadOnlySpan`1<byte> hash, Oid hashAlgorithmId, X509Certificate2& signerCertificate, X509Certificate2Collection extraCandidates)
public bool VerifySignatureForSignerInfo(SignerInfo signerInfo, X509Certificate2& signerCertificate, X509Certificate2Collection extraCandidates)
}
public System.Security.Cryptography.Pkcs.Rfc3161TimestampTokenInfo : object {
public Nullable`1<long> AccuracyInMicroseconds
public bool HasExtensions
public Oid HashAlgorithmId
public bool IsOrdering
public Oid PolicyId
public DateTimeOffset Timestamp
public int Version
public Nullable`1<long> get_AccuracyInMicroseconds()
public bool get_HasExtensions()
public Oid get_HashAlgorithmId()
public bool get_IsOrdering()
public Oid get_PolicyId()
public DateTimeOffset get_Timestamp()
public int get_Version()
public void .ctor(Oid policyId, Oid hashAlgorithmId, ReadOnlyMemory`1<byte> messageHash, ReadOnlyMemory`1<byte> serialNumber, DateTimeOffset timestamp, Nullable`1<long> accuracyInMicroseconds, bool isOrdering, Nullable`1<ReadOnlyMemory`1<byte>> nonce, Nullable`1<ReadOnlyMemory`1<byte>> timestampAuthorityName, X509ExtensionCollection extensions)
public Byte[] Encode()
public X509ExtensionCollection GetExtensions()
public ReadOnlyMemory`1<byte> GetMessageHash()
public Nullable`1<ReadOnlyMemory`1<byte>> GetNonce()
public ReadOnlyMemory`1<byte> GetSerialNumber()
public Nullable`1<ReadOnlyMemory`1<byte>> GetTimestampAuthorityName()
public bool TryDecode(ReadOnlyMemory`1<byte> encodedBytes, Rfc3161TimestampTokenInfo& timestampTokenInfo, Int32& bytesConsumed)
public bool TryEncode(Span`1<byte> destination, Int32& bytesWritten)
}
public System.Security.Cryptography.Pkcs.SignedCms : object {
private Oid s_cmsDataOid
private SignedDataAsn _signedData
private bool _hasData
private Memory`1<byte> _heldData
private Nullable`1<ReadOnlyMemory`1<byte>> _heldContent
private bool _hasPkcs7Content
private string _contentType
private int <Version>k__BackingField
private ContentInfo <ContentInfo>k__BackingField
private bool <Detached>k__BackingField
public int Version
public ContentInfo ContentInfo
public bool Detached
public X509Certificate2Collection Certificates
public SignerInfoCollection SignerInfos
private ContentInfo MakeEmptyContentInfo()
public void .ctor(SubjectIdentifierType signerIdentifierType)
public void .ctor(ContentInfo contentInfo)
public void .ctor(SubjectIdentifierType signerIdentifierType, ContentInfo contentInfo)
public void .ctor(ContentInfo contentInfo, bool detached)
public int get_Version()
private void set_Version(int value)
public ContentInfo get_ContentInfo()
private void set_ContentInfo(ContentInfo value)
public bool get_Detached()
private void set_Detached(bool value)
public void .ctor(SubjectIdentifierType signerIdentifierType, ContentInfo contentInfo, bool detached)
public X509Certificate2Collection get_Certificates()
public SignerInfoCollection get_SignerInfos()
public Byte[] Encode()
public void Decode(Byte[] encodedMessage)
internal void Decode(ReadOnlyMemory`1<byte> encodedMessage)
internal ReadOnlyMemory`1<byte> GetContent(ReadOnlyMemory`1<byte> wrappedContent, string contentType)
public void ComputeSignature()
public void ComputeSignature(CmsSigner signer)
public void ComputeSignature(CmsSigner signer, bool silent)
public void RemoveSignature(int index)
public void RemoveSignature(SignerInfo signerInfo)
internal ReadOnlySpan`1<byte> GetHashableContentSpan()
internal void Reencode()
private void UpdateMetadata()
private void ConsiderDigestAddition(AlgorithmIdentifierAsn candidate)
private void ConsiderDigestRemoval(AlgorithmIdentifierAsn candidate)
internal void UpdateCertificatesFromAddition(X509Certificate2Collection newCerts)
public void CheckSignature(bool verifySignatureOnly)
public void CheckSignature(X509Certificate2Collection extraStore, bool verifySignatureOnly)
private void CheckSignatures(SignerInfoCollection signers, X509Certificate2Collection extraStore, bool verifySignatureOnly)
public void CheckHash()
internal SignedDataAsn& GetRawData()
}
public System.Security.Cryptography.Pkcs.SignerInfo : object {
private int <Version>k__BackingField
private SubjectIdentifier <SignerIdentifier>k__BackingField
private Oid _digestAlgorithm
private AttributeAsn[] _signedAttributes
private Nullable`1<ReadOnlyMemory`1<byte>> _signedAttributesMemory
private Oid _signatureAlgorithm
private Nullable`1<ReadOnlyMemory`1<byte>> _signatureAlgorithmParameters
private ReadOnlyMemory`1<byte> _signature
private AttributeAsn[] _unsignedAttributes
private SignedCms _document
private X509Certificate2 _signerCertificate
private SignerInfo _parentSignerInfo
private CryptographicAttributeObjectCollection _parsedSignedAttrs
private CryptographicAttributeObjectCollection _parsedUnsignedAttrs
public int Version
public SubjectIdentifier SignerIdentifier
public CryptographicAttributeObjectCollection SignedAttributes
public CryptographicAttributeObjectCollection UnsignedAttributes
public X509Certificate2 Certificate
public SignerInfoCollection CounterSignerInfos
public Oid DigestAlgorithm
public Oid SignatureAlgorithm
public int get_Version()
public SubjectIdentifier get_SignerIdentifier()
internal void .ctor(SignerInfoAsn& parsedData, SignedCms ownerDocument)
public CryptographicAttributeObjectCollection get_SignedAttributes()
public CryptographicAttributeObjectCollection get_UnsignedAttributes()
internal ReadOnlyMemory`1<byte> GetSignatureMemory()
public Byte[] GetSignature()
public X509Certificate2 get_Certificate()
public SignerInfoCollection get_CounterSignerInfos()
public Oid get_DigestAlgorithm()
public Oid get_SignatureAlgorithm()
private SignerInfoCollection GetCounterSigners(AttributeAsn[] unsignedAttrs)
public void ComputeCounterSignature()
public void ComputeCounterSignature(CmsSigner signer)
public void RemoveCounterSignature(int index)
public void RemoveCounterSignature(SignerInfo counterSignerInfo)
public void CheckSignature(bool verifySignatureOnly)
public void CheckSignature(X509Certificate2Collection extraStore, bool verifySignatureOnly)
public void CheckHash()
private bool CheckHash(bool compatMode)
private X509Certificate2 FindSignerCertificate()
private X509Certificate2 FindSignerCertificate(SubjectIdentifier signerIdentifier, X509Certificate2Collection extraStore)
private IncrementalHash PrepareDigest(bool compatMode)
private void Verify(X509Certificate2Collection extraStore, X509Certificate2 certificate, bool verifySignatureOnly)
private bool VerifySignature(CmsSignature signatureProcessor, X509Certificate2 certificate, bool compatMode)
private HashAlgorithmName GetDigestAlgorithm()
internal CryptographicAttributeObjectCollection MakeAttributeCollection(AttributeAsn[] attributes)
private CryptographicAttributeObject MakeAttribute(AttributeAsn attribute)
}
public System.Security.Cryptography.Pkcs.SignerInfoCollection : object {
private SignerInfo[] _signerInfos
public SignerInfo Item
public int Count
public bool IsSynchronized
public object SyncRoot
internal void .ctor(SignerInfo[] signerInfos)
internal void .ctor(SignerInfoAsn[] signedDataSignerInfos, SignedCms ownerDocument)
public SignerInfo get_Item(int index)
public int get_Count()
public SignerInfoEnumerator GetEnumerator()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
public void CopyTo(Array array, int index)
public void CopyTo(SignerInfo[] array, int index)
public bool get_IsSynchronized()
public object get_SyncRoot()
internal int FindIndexForSigner(SignerInfo signer)
}
public System.Security.Cryptography.Pkcs.SignerInfoEnumerator : object {
private SignerInfoCollection _signerInfos
private int _position
public SignerInfo Current
private object System.Collections.IEnumerator.Current
internal void .ctor(SignerInfoCollection signerInfos)
public SignerInfo get_Current()
private object System.Collections.IEnumerator.get_Current()
public bool MoveNext()
public void Reset()
}
public System.Security.Cryptography.Pkcs.SubjectIdentifier : object {
private string DummySignerSubjectName
internal Byte[] DummySignerEncodedValue
private SubjectIdentifierType <Type>k__BackingField
private object <Value>k__BackingField
public SubjectIdentifierType Type
public object Value
internal void .ctor(SubjectIdentifierType type, object value)
internal void .ctor(SignerIdentifierAsn signerIdentifierAsn)
internal void .ctor(Nullable`1<IssuerAndSerialNumberAsn> issuerAndSerialNumber, Nullable`1<ReadOnlyMemory`1<byte>> subjectKeyIdentifier)
public SubjectIdentifierType get_Type()
public object get_Value()
}
public System.Security.Cryptography.Pkcs.SubjectIdentifierOrKey : object {
private SubjectIdentifierOrKeyType <Type>k__BackingField
private object <Value>k__BackingField
public SubjectIdentifierOrKeyType Type
public object Value
internal void .ctor(SubjectIdentifierOrKeyType type, object value)
public SubjectIdentifierOrKeyType get_Type()
public object get_Value()
}
public System.Security.Cryptography.Pkcs.SubjectIdentifierOrKeyType : Enum {
public int value__
public SubjectIdentifierOrKeyType Unknown
public SubjectIdentifierOrKeyType IssuerAndSerialNumber
public SubjectIdentifierOrKeyType SubjectKeyIdentifier
public SubjectIdentifierOrKeyType PublicKeyInfo
}
public System.Security.Cryptography.Pkcs.SubjectIdentifierType : Enum {
public int value__
public SubjectIdentifierType Unknown
public SubjectIdentifierType IssuerAndSerialNumber
public SubjectIdentifierType SubjectKeyIdentifier
public SubjectIdentifierType NoSignature
}
public System.Security.Cryptography.ProtectedData : object {
private Byte[] s_nonEmpty
public Byte[] Protect(Byte[] userData, Byte[] optionalEntropy, DataProtectionScope scope)
public Byte[] Unprotect(Byte[] encryptedData, Byte[] optionalEntropy, DataProtectionScope scope)
private Byte[] ProtectOrUnprotect(Byte[] inputData, Byte[] optionalEntropy, DataProtectionScope scope, bool protect)
private bool ErrorMayBeCausedByUnloadedProfile(int errorCode)
}
public System.Security.Cryptography.ProtectedMemory : object {
private int BlockSize
private MemoryProtectionImplementation impl
public void Protect(Byte[] userData, MemoryProtectionScope scope)
public void Unprotect(Byte[] encryptedData, MemoryProtectionScope scope)
private void Detect()
private void Check(int size, MemoryProtectionScope scope)
private int RtlEncryptMemory(Byte[] pData, UInt32 cbData, UInt32 dwFlags)
private int RtlDecryptMemory(Byte[] pData, UInt32 cbData, UInt32 dwFlags)
private bool CryptProtectMemory(Byte[] pData, UInt32 cbData, UInt32 dwFlags)
private bool CryptUnprotectMemory(Byte[] pData, UInt32 cbData, UInt32 dwFlags)
}
internal System.Security.Cryptography.Translation.SR : object {
public string Cryptography_DataProtector_InvalidAppNameOrPurpose
public string Cryptography_DataProtector_InvalidPurpose
public string ArgumentOutOfRange_Index
public string Arg_EmptyOrNullString
public string Cryptography_Partial_Chain
public string Cryptography_Xml_BadWrappedKeySize
public string Cryptography_Xml_CipherValueElementRequired
public string Cryptography_Xml_CreateHashAlgorithmFailed
public string Cryptography_Xml_CreateTransformFailed
public string Cryptography_Xml_CreatedKeyFailed
public string Cryptography_Xml_DigestMethodRequired
public string Cryptography_Xml_DigestValueRequired
public string Cryptography_Xml_EnvelopedSignatureRequiresContext
public string Cryptography_Xml_InvalidElement
public string Cryptography_Xml_InvalidEncryptionProperty
public string Cryptography_Xml_InvalidKeySize
public string Cryptography_Xml_InvalidReference
public string Cryptography_Xml_InvalidSignatureLength
public string Cryptography_Xml_InvalidSignatureLength2
public string Cryptography_Xml_InvalidX509IssuerSerialNumber
public string Cryptography_Xml_KeyInfoRequired
public string Cryptography_Xml_KW_BadKeySize
public string Cryptography_Xml_LoadKeyFailed
public string Cryptography_Xml_MissingAlgorithm
public string Cryptography_Xml_MissingCipherData
public string Cryptography_Xml_MissingDecryptionKey
public string Cryptography_Xml_MissingEncryptionKey
public string Cryptography_Xml_NotSupportedCryptographicTransform
public string Cryptography_Xml_ReferenceElementRequired
public string Cryptography_Xml_ReferenceTypeRequired
public string Cryptography_Xml_SelfReferenceRequiresContext
public string Cryptography_Xml_SignatureDescriptionNotCreated
public string Cryptography_Xml_SignatureMethodKeyMismatch
public string Cryptography_Xml_SignatureMethodRequired
public string Cryptography_Xml_SignatureValueRequired
public string Cryptography_Xml_SignedInfoRequired
public string Cryptography_Xml_TransformIncorrectInputType
public string Cryptography_Xml_IncorrectObjectType
public string Cryptography_Xml_UnknownTransform
public string Cryptography_Xml_UriNotResolved
public string Cryptography_Xml_UriNotSupported
public string Cryptography_Xml_UriRequired
public string Cryptography_Xml_XrmlMissingContext
public string Cryptography_Xml_XrmlMissingIRelDecryptor
public string Cryptography_Xml_XrmlMissingIssuer
public string Cryptography_Xml_XrmlMissingLicence
public string Cryptography_Xml_XrmlUnableToDecryptGrant
public string NotSupported_KeyAlgorithm
public string Log_ActualHashValue
public string Log_BeginCanonicalization
public string Log_BeginSignatureComputation
public string Log_BeginSignatureVerification
public string Log_BuildX509Chain
public string Log_CanonicalizationSettings
public string Log_CanonicalizedOutput
public string Log_CertificateChain
public string Log_CheckSignatureFormat
public string Log_CheckSignedInfo
public string Log_FormatValidationSuccessful
public string Log_FormatValidationNotSuccessful
public string Log_KeyUsages
public string Log_NoNamespacesPropagated
public string Log_PropagatingNamespace
public string Log_RawSignatureValue
public string Log_ReferenceHash
public string Log_RevocationMode
public string Log_RevocationFlag
public string Log_SigningAsymmetric
public string Log_SigningHmac
public string Log_SigningReference
public string Log_TransformedReferenceContents
public string Log_UnsafeCanonicalizationMethod
public string Log_UrlTimeout
public string Log_VerificationFailed
public string Log_VerificationFailed_References
public string Log_VerificationFailed_SignedInfo
public string Log_VerificationFailed_X509Chain
public string Log_VerificationFailed_X509KeyUsage
public string Log_VerificationFlag
public string Log_VerificationTime
public string Log_VerificationWithKeySuccessful
public string Log_VerificationWithKeyNotSuccessful
public string Log_VerifyReference
public string Log_VerifySignedInfoAsymmetric
public string Log_VerifySignedInfoHmac
public string Log_X509ChainError
public string Log_XmlContext
public string Log_SignedXmlRecursionLimit
public string Log_UnsafeTransformMethod
public string Arg_RankMultiDimNotSupported
public string Argument_InvalidOffLen
public string Argument_InvalidOidValue
public string Cryptography_Asn_EnumeratedValueRequiresNonFlagsEnum
public string Cryptography_Asn_NamedBitListRequiresFlagsEnum
public string Cryptography_Asn_NamedBitListValueTooBig
public string Cryptography_Asn_UniversalValueIsFixed
public string Cryptography_Asn_UnusedBitCountRange
public string Cryptography_AsnSerializer_AmbiguousFieldType
public string Cryptography_AsnSerializer_Choice_AllowNullNonNullable
public string Cryptography_AsnSerializer_Choice_ConflictingTagMapping
public string Cryptography_AsnSerializer_Choice_DefaultValueDisallowed
public string Cryptography_AsnSerializer_Choice_NoChoiceWasMade
public string Cryptography_AsnSerializer_Choice_NonNullableField
public string Cryptography_AsnSerializer_Choice_TooManyValues
public string Cryptography_AsnSerializer_Choice_TypeCycle
public string Cryptography_AsnSerializer_MultipleAsnTypeAttributes
public string Cryptography_AsnSerializer_NoJaggedArrays
public string Cryptography_AsnSerializer_NoMultiDimensionalArrays
public string Cryptography_AsnSerializer_NoOpenTypes
public string Cryptography_AsnSerializer_Optional_NonNullableField
public string Cryptography_AsnSerializer_PopulateFriendlyNameOnString
public string Cryptography_AsnSerializer_SetValueException
public string Cryptography_AsnSerializer_SpecificTagChoice
public string Cryptography_AsnSerializer_UnexpectedTypeForAttribute
public string Cryptography_AsnSerializer_UtcTimeTwoDigitYearMaxTooSmall
public string Cryptography_AsnSerializer_UnhandledType
public string Cryptography_AsnWriter_EncodeUnbalancedStack
public string Cryptography_AsnWriter_PopWrongTag
public string Cryptography_BadHashValue
public string Cryptography_BadSignature
public string Cryptography_Cms_CannotDetermineSignatureAlgorithm
public string Cryptography_Cms_IncompleteCertChain
public string Cryptography_Cms_Invalid_Originator_Identifier_Choice
public string Cryptography_Cms_Invalid_Subject_Identifier_Type
public string Cryptography_Cms_InvalidMessageType
public string Cryptography_Cms_InvalidSignerHashForSignatureAlg
public string Cryptography_Cms_Key_Agree_Date_Not_Available
public string Cryptography_Cms_MessageNotEncrypted
public string Cryptography_Cms_MessageNotSigned
public string Cryptography_Cms_MissingAuthenticatedAttribute
public string Cryptography_Cms_NoCounterCounterSigner
public string Cryptography_Cms_NoRecipients
public string Cryptography_Cms_NoSignerCert
public string Cryptography_Cms_NoSignerAtIndex
public string Cryptography_Cms_RecipientNotFound
public string Cryptography_Cms_RecipientType_NotSupported
public string Cryptography_Cms_Sign_Empty_Content
public string Cryptography_Cms_SignerNotFound
public string Cryptography_Cms_Signing_RequiresPrivateKey
public string Cryptography_Cms_TrustFailure
public string Cryptography_Cms_UnknownAlgorithm
public string Cryptography_Cms_UnknownKeySpec
public string Cryptography_Cms_WrongKeyUsage
public string Cryptography_Pkcs_InvalidSignatureParameters
public string Cryptography_Pkcs9_AttributeMismatch
public string Cryptography_Pkcs9_MultipleSigningTimeNotAllowed
public string Cryptography_Pkcs_PssParametersMissing
public string Cryptography_Pkcs_PssParametersHashMismatch
public string Cryptography_Pkcs_PssParametersMgfHashMismatch
public string Cryptography_Pkcs_PssParametersMgfNotSupported
public string Cryptography_Pkcs_PssParametersSaltMismatch
public string Cryptography_TimestampReq_BadNonce
public string Cryptography_TimestampReq_BadResponse
public string Cryptography_TimestampReq_Failure
public string Cryptography_TimestampReq_NoCertFound
public string Cryptography_TimestampReq_UnexpectedCertFound
public string InvalidOperation_DuplicateItemNotAllowed
public string InvalidOperation_WrongOidInAsnCollection
public string PlatformNotSupported_CryptographyPkcs
public string Cryptography_Der_Invalid_Encoding
public string Cryptography_Invalid_IA5String
public string Cryptography_UnknownHashAlgorithm
public string Cryptography_WriteEncodedValue_OneValueAtATime
}
public System.Security.Cryptography.X509Certificates.X509Certificate2UI : object {
public void DisplayCertificate(X509Certificate2 certificate)
public void DisplayCertificate(X509Certificate2 certificate, IntPtr hwndParent)
public X509Certificate2Collection SelectFromCollection(X509Certificate2Collection certificates, string title, string message, X509SelectionFlag selectionFlag)
public X509Certificate2Collection SelectFromCollection(X509Certificate2Collection certificates, string title, string message, X509SelectionFlag selectionFlag, IntPtr hwndParent)
}
public System.Security.Cryptography.X509Certificates.X509SelectionFlag : Enum {
public int value__
public X509SelectionFlag SingleSelection
public X509SelectionFlag MultiSelection
}
internal System.Security.Cryptography.Xml.AncestralNamespaceContextManager : object {
internal ArrayList _ancestorStack
internal NamespaceFrame GetScopeAt(int i)
internal NamespaceFrame GetCurrentScope()
protected XmlAttribute GetNearestRenderedNamespaceWithMatchingPrefix(string nsPrefix, Int32& depth)
protected XmlAttribute GetNearestUnrenderedNamespaceWithMatchingPrefix(string nsPrefix, Int32& depth)
internal void EnterElementContext()
internal void ExitElementContext()
internal void TrackNamespaceNode(XmlAttribute attr, SortedList nsListToRender, Hashtable nsLocallyDeclared)
internal void TrackXmlNamespaceNode(XmlAttribute attr, SortedList nsListToRender, SortedList attrListToRender, Hashtable nsLocallyDeclared)
internal void GetNamespacesToRender(XmlElement element, SortedList attrListToRender, SortedList nsListToRender, Hashtable nsLocallyDeclared)
internal void LoadUnrenderedNamespaces(Hashtable nsLocallyDeclared)
internal void LoadRenderedNamespaces(SortedList nsRenderedList)
internal void AddRendered(XmlAttribute attr)
internal void AddUnrendered(XmlAttribute attr)
}
internal System.Security.Cryptography.Xml.AttributeSortOrder : object {
public int Compare(object a, object b)
}
internal System.Security.Cryptography.Xml.C14NAncestralNamespaceContextManager : AncestralNamespaceContextManager {
private void GetNamespaceToRender(string nsPrefix, SortedList attrListToRender, SortedList nsListToRender, Hashtable nsLocallyDeclared)
internal void GetNamespacesToRender(XmlElement element, SortedList attrListToRender, SortedList nsListToRender, Hashtable nsLocallyDeclared)
internal void TrackNamespaceNode(XmlAttribute attr, SortedList nsListToRender, Hashtable nsLocallyDeclared)
internal void TrackXmlNamespaceNode(XmlAttribute attr, SortedList nsListToRender, SortedList attrListToRender, Hashtable nsLocallyDeclared)
}
internal System.Security.Cryptography.Xml.CanonicalizationDispatcher : object {
public void Write(XmlNode node, StringBuilder strBuilder, DocPosition docPos, AncestralNamespaceContextManager anc)
public void WriteGenericNode(XmlNode node, StringBuilder strBuilder, DocPosition docPos, AncestralNamespaceContextManager anc)
public void WriteHash(XmlNode node, HashAlgorithm hash, DocPosition docPos, AncestralNamespaceContextManager anc)
public void WriteHashGenericNode(XmlNode node, HashAlgorithm hash, DocPosition docPos, AncestralNamespaceContextManager anc)
}
internal System.Security.Cryptography.Xml.CanonicalXml : object {
private CanonicalXmlDocument _c14nDoc
private C14NAncestralNamespaceContextManager _ancMgr
internal void .ctor(Stream inputStream, bool includeComments, XmlResolver resolver, string strBaseUri)
internal void .ctor(XmlDocument document, XmlResolver resolver)
internal void .ctor(XmlDocument document, XmlResolver resolver, bool includeComments)
internal void .ctor(XmlNodeList nodeList, XmlResolver resolver, bool includeComments)
private void MarkNodeAsIncluded(XmlNode node)
private void MarkInclusionStateForNodes(XmlNodeList nodeList, XmlDocument inputRoot, XmlDocument root)
internal Byte[] GetBytes()
internal Byte[] GetDigestedBytes(HashAlgorithm hash)
}
internal System.Security.Cryptography.Xml.CanonicalXmlAttribute : XmlAttribute {
private bool _isInNodeSet
public bool IsInNodeSet
public void .ctor(string prefix, string localName, string namespaceURI, XmlDocument doc, bool defaultNodeSetInclusionState)
public bool get_IsInNodeSet()
public void set_IsInNodeSet(bool value)
public void Write(StringBuilder strBuilder, DocPosition docPos, AncestralNamespaceContextManager anc)
public void WriteHash(HashAlgorithm hash, DocPosition docPos, AncestralNamespaceContextManager anc)
}
internal System.Security.Cryptography.Xml.CanonicalXmlCDataSection : XmlCDataSection {
private bool _isInNodeSet
public bool IsInNodeSet
public void .ctor(string data, XmlDocument doc, bool defaultNodeSetInclusionState)
public bool get_IsInNodeSet()
public void set_IsInNodeSet(bool value)
public void Write(StringBuilder strBuilder, DocPosition docPos, AncestralNamespaceContextManager anc)
public void WriteHash(HashAlgorithm hash, DocPosition docPos, AncestralNamespaceContextManager anc)
}
internal System.Security.Cryptography.Xml.CanonicalXmlComment : XmlComment {
private bool _isInNodeSet
private bool _includeComments
public bool IsInNodeSet
public bool IncludeComments
public void .ctor(string comment, XmlDocument doc, bool defaultNodeSetInclusionState, bool includeComments)
public bool get_IsInNodeSet()
public void set_IsInNodeSet(bool value)
public bool get_IncludeComments()
public void Write(StringBuilder strBuilder, DocPosition docPos, AncestralNamespaceContextManager anc)
public void WriteHash(HashAlgorithm hash, DocPosition docPos, AncestralNamespaceContextManager anc)
}
internal System.Security.Cryptography.Xml.CanonicalXmlDocument : XmlDocument {
private bool _defaultNodeSetInclusionState
private bool _includeComments
private bool _isInNodeSet
public bool IsInNodeSet
public void .ctor(bool defaultNodeSetInclusionState, bool includeComments)
public bool get_IsInNodeSet()
public void set_IsInNodeSet(bool value)
public void Write(StringBuilder strBuilder, DocPosition docPos, AncestralNamespaceContextManager anc)
public void WriteHash(HashAlgorithm hash, DocPosition docPos, AncestralNamespaceContextManager anc)
public XmlElement CreateElement(string prefix, string localName, string namespaceURI)
public XmlAttribute CreateAttribute(string prefix, string localName, string namespaceURI)
protected XmlAttribute CreateDefaultAttribute(string prefix, string localName, string namespaceURI)
public XmlText CreateTextNode(string text)
public XmlWhitespace CreateWhitespace(string prefix)
public XmlSignificantWhitespace CreateSignificantWhitespace(string text)
public XmlProcessingInstruction CreateProcessingInstruction(string target, string data)
public XmlComment CreateComment(string data)
public XmlEntityReference CreateEntityReference(string name)
public XmlCDataSection CreateCDataSection(string data)
}
internal System.Security.Cryptography.Xml.CanonicalXmlElement : XmlElement {
private bool _isInNodeSet
public bool IsInNodeSet
public void .ctor(string prefix, string localName, string namespaceURI, XmlDocument doc, bool defaultNodeSetInclusionState)
public bool get_IsInNodeSet()
public void set_IsInNodeSet(bool value)
public void Write(StringBuilder strBuilder, DocPosition docPos, AncestralNamespaceContextManager anc)
public void WriteHash(HashAlgorithm hash, DocPosition docPos, AncestralNamespaceContextManager anc)
}
internal System.Security.Cryptography.Xml.CanonicalXmlEntityReference : XmlEntityReference {
private bool _isInNodeSet
public bool IsInNodeSet
public void .ctor(string name, XmlDocument doc, bool defaultNodeSetInclusionState)
public bool get_IsInNodeSet()
public void set_IsInNodeSet(bool value)
public void Write(StringBuilder strBuilder, DocPosition docPos, AncestralNamespaceContextManager anc)
public void WriteHash(HashAlgorithm hash, DocPosition docPos, AncestralNamespaceContextManager anc)
}
internal System.Security.Cryptography.Xml.CanonicalXmlNodeList : XmlNodeList {
private ArrayList _nodeArray
public int Count
public bool IsFixedSize
public bool IsReadOnly
private object System.Collections.IList.Item
public object SyncRoot
public bool IsSynchronized
public XmlNode Item(int index)
public IEnumerator GetEnumerator()
public int get_Count()
public int Add(object value)
public void Clear()
public bool Contains(object value)
public int IndexOf(object value)
public void Insert(int index, object value)
public void Remove(object value)
public void RemoveAt(int index)
public bool get_IsFixedSize()
public bool get_IsReadOnly()
private object System.Collections.IList.get_Item(int index)
private void System.Collections.IList.set_Item(int index, object value)
public void CopyTo(Array array, int index)
public object get_SyncRoot()
public bool get_IsSynchronized()
}
internal System.Security.Cryptography.Xml.CanonicalXmlProcessingInstruction : XmlProcessingInstruction {
private bool _isInNodeSet
public bool IsInNodeSet
public void .ctor(string target, string data, XmlDocument doc, bool defaultNodeSetInclusionState)
public bool get_IsInNodeSet()
public void set_IsInNodeSet(bool value)
public void Write(StringBuilder strBuilder, DocPosition docPos, AncestralNamespaceContextManager anc)
public void WriteHash(HashAlgorithm hash, DocPosition docPos, AncestralNamespaceContextManager anc)
}
internal System.Security.Cryptography.Xml.CanonicalXmlSignificantWhitespace : XmlSignificantWhitespace {
private bool _isInNodeSet
public bool IsInNodeSet
public void .ctor(string strData, XmlDocument doc, bool defaultNodeSetInclusionState)
public bool get_IsInNodeSet()
public void set_IsInNodeSet(bool value)
public void Write(StringBuilder strBuilder, DocPosition docPos, AncestralNamespaceContextManager anc)
public void WriteHash(HashAlgorithm hash, DocPosition docPos, AncestralNamespaceContextManager anc)
}
internal System.Security.Cryptography.Xml.CanonicalXmlText : XmlText {
private bool _isInNodeSet
public bool IsInNodeSet
public void .ctor(string strData, XmlDocument doc, bool defaultNodeSetInclusionState)
public bool get_IsInNodeSet()
public void set_IsInNodeSet(bool value)
public void Write(StringBuilder strBuilder, DocPosition docPos, AncestralNamespaceContextManager anc)
public void WriteHash(HashAlgorithm hash, DocPosition docPos, AncestralNamespaceContextManager anc)
}
internal System.Security.Cryptography.Xml.CanonicalXmlWhitespace : XmlWhitespace {
private bool _isInNodeSet
public bool IsInNodeSet
public void .ctor(string strData, XmlDocument doc, bool defaultNodeSetInclusionState)
public bool get_IsInNodeSet()
public void set_IsInNodeSet(bool value)
public void Write(StringBuilder strBuilder, DocPosition docPos, AncestralNamespaceContextManager anc)
public void WriteHash(HashAlgorithm hash, DocPosition docPos, AncestralNamespaceContextManager anc)
}
internal System.Security.Cryptography.Xml.CertUsageType : Enum {
public int value__
public CertUsageType Verification
public CertUsageType Decryption
}
public System.Security.Cryptography.Xml.CipherData : object {
private XmlElement _cachedXml
private CipherReference _cipherReference
private Byte[] _cipherValue
private bool CacheValid
public CipherReference CipherReference
public Byte[] CipherValue
public void .ctor(Byte[] cipherValue)
public void .ctor(CipherReference cipherReference)
private bool get_CacheValid()
public CipherReference get_CipherReference()
public void set_CipherReference(CipherReference value)
public Byte[] get_CipherValue()
public void set_CipherValue(Byte[] value)
public XmlElement GetXml()
internal XmlElement GetXml(XmlDocument document)
public void LoadXml(XmlElement value)
}
public System.Security.Cryptography.Xml.CipherReference : EncryptedReference {
private Byte[] _cipherValue
internal Byte[] CipherValue
public void .ctor(string uri)
public void .ctor(string uri, TransformChain transformChain)
internal Byte[] get_CipherValue()
internal void set_CipherValue(Byte[] value)
public XmlElement GetXml()
internal XmlElement GetXml(XmlDocument document)
public void LoadXml(XmlElement value)
}
internal System.Security.Cryptography.Xml.CryptoHelpers : object {
private Char[] _invalidChars
public object CreateFromKnownName(string name)
public T CreateFromName(string name)
}
public System.Security.Cryptography.Xml.CryptoSignedXmlRecursionException : XmlException {
public void .ctor(string message)
public void .ctor(string message, Exception inner)
protected void .ctor(SerializationInfo info, StreamingContext context)
}
public System.Security.Cryptography.Xml.DataObject : object {
private string _id
private string _mimeType
private string _encoding
private CanonicalXmlNodeList _elData
private XmlElement _cachedXml
public string Id
public string MimeType
public string Encoding
public XmlNodeList Data
private bool CacheValid
public void .ctor(string id, string mimeType, string encoding, XmlElement data)
public string get_Id()
public void set_Id(string value)
public string get_MimeType()
public void set_MimeType(string value)
public string get_Encoding()
public void set_Encoding(string value)
public XmlNodeList get_Data()
public void set_Data(XmlNodeList value)
private bool get_CacheValid()
public XmlElement GetXml()
internal XmlElement GetXml(XmlDocument document)
public void LoadXml(XmlElement value)
}
public System.Security.Cryptography.Xml.DataReference : EncryptedReference {
public void .ctor(string uri)
public void .ctor(string uri, TransformChain transformChain)
}
internal System.Security.Cryptography.Xml.DocPosition : Enum {
public int value__
public DocPosition BeforeRootElement
public DocPosition InRootElement
public DocPosition AfterRootElement
}
public System.Security.Cryptography.Xml.DSAKeyValue : KeyInfoClause {
private DSA _key
private string KeyValueElementName
private string DSAKeyValueElementName
private string PElementName
private string QElementName
private string GElementName
private string JElementName
private string YElementName
private string SeedElementName
private string PgenCounterElementName
public DSA Key
public void .ctor(DSA key)
public DSA get_Key()
public void set_Key(DSA value)
public XmlElement GetXml()
internal XmlElement GetXml(XmlDocument xmlDocument)
public void LoadXml(XmlElement value)
}
internal System.Security.Cryptography.Xml.DSASignatureDescription : SignatureDescription {
private string HashAlgorithm
public AsymmetricSignatureDeformatter CreateDeformatter(AsymmetricAlgorithm key)
public AsymmetricSignatureFormatter CreateFormatter(AsymmetricAlgorithm key)
public HashAlgorithm CreateDigest()
}
public System.Security.Cryptography.Xml.EncryptedData : EncryptedType {
public void LoadXml(XmlElement value)
public XmlElement GetXml()
internal XmlElement GetXml(XmlDocument document)
}
public System.Security.Cryptography.Xml.EncryptedKey : EncryptedType {
private string _recipient
private string _carriedKeyName
private ReferenceList _referenceList
public string Recipient
public string CarriedKeyName
public ReferenceList ReferenceList
public string get_Recipient()
public void set_Recipient(string value)
public string get_CarriedKeyName()
public void set_CarriedKeyName(string value)
public ReferenceList get_ReferenceList()
public void AddReference(DataReference dataReference)
public void AddReference(KeyReference keyReference)
public void LoadXml(XmlElement value)
public XmlElement GetXml()
internal XmlElement GetXml(XmlDocument document)
}
public System.Security.Cryptography.Xml.EncryptedReference : object {
private string _uri
private string _referenceType
private TransformChain _transformChain
internal XmlElement _cachedXml
public string Uri
public TransformChain TransformChain
protected string ReferenceType
protected internal bool CacheValid
protected void .ctor(string uri)
protected void .ctor(string uri, TransformChain transformChain)
public string get_Uri()
public void set_Uri(string value)
public TransformChain get_TransformChain()
public void set_TransformChain(TransformChain value)
public void AddTransform(Transform transform)
protected string get_ReferenceType()
protected void set_ReferenceType(string value)
protected internal bool get_CacheValid()
public XmlElement GetXml()
internal XmlElement GetXml(XmlDocument document)
public void LoadXml(XmlElement value)
}
public System.Security.Cryptography.Xml.EncryptedType : object {
private string _id
private string _type
private string _mimeType
private string _encoding
private EncryptionMethod _encryptionMethod
private CipherData _cipherData
private EncryptionPropertyCollection _props
private KeyInfo _keyInfo
internal XmlElement _cachedXml
internal bool CacheValid
public string Id
public string Type
public string MimeType
public string Encoding
public KeyInfo KeyInfo
public EncryptionMethod EncryptionMethod
public EncryptionPropertyCollection EncryptionProperties
public CipherData CipherData
internal bool get_CacheValid()
public string get_Id()
public void set_Id(string value)
public string get_Type()
public void set_Type(string value)
public string get_MimeType()
public void set_MimeType(string value)
public string get_Encoding()
public void set_Encoding(string value)
public KeyInfo get_KeyInfo()
public void set_KeyInfo(KeyInfo value)
public EncryptionMethod get_EncryptionMethod()
public void set_EncryptionMethod(EncryptionMethod value)
public EncryptionPropertyCollection get_EncryptionProperties()
public void AddProperty(EncryptionProperty ep)
public CipherData get_CipherData()
public void set_CipherData(CipherData value)
public void LoadXml(XmlElement value)
public XmlElement GetXml()
}
public System.Security.Cryptography.Xml.EncryptedXml : object {
public string XmlEncNamespaceUrl
public string XmlEncElementUrl
public string XmlEncElementContentUrl
public string XmlEncEncryptedKeyUrl
public string XmlEncDESUrl
public string XmlEncTripleDESUrl
public string XmlEncAES128Url
public string XmlEncAES256Url
public string XmlEncAES192Url
public string XmlEncRSA15Url
public string XmlEncRSAOAEPUrl
public string XmlEncTripleDESKeyWrapUrl
public string XmlEncAES128KeyWrapUrl
public string XmlEncAES256KeyWrapUrl
public string XmlEncAES192KeyWrapUrl
public string XmlEncSHA256Url
public string XmlEncSHA512Url
private XmlDocument _document
private Evidence _evidence
private XmlResolver _xmlResolver
private int _capacity
private Hashtable _keyNameMapping
private PaddingMode _padding
private CipherMode _mode
private Encoding _encoding
private string _recipient
private int _xmlDsigSearchDepthCounter
private int _xmlDsigSearchDepth
public int XmlDSigSearchDepth
public Evidence DocumentEvidence
public XmlResolver Resolver
public PaddingMode Padding
public CipherMode Mode
public Encoding Encoding
public string Recipient
public void .ctor(XmlDocument document)
public void .ctor(XmlDocument document, Evidence evidence)
private bool IsOverXmlDsigRecursionLimit()
public int get_XmlDSigSearchDepth()
public void set_XmlDSigSearchDepth(int value)
public Evidence get_DocumentEvidence()
public void set_DocumentEvidence(Evidence value)
public XmlResolver get_Resolver()
public void set_Resolver(XmlResolver value)
public PaddingMode get_Padding()
public void set_Padding(PaddingMode value)
public CipherMode get_Mode()
public void set_Mode(CipherMode value)
public Encoding get_Encoding()
public void set_Encoding(Encoding value)
public string get_Recipient()
public void set_Recipient(string value)
private Byte[] GetCipherValue(CipherData cipherData)
public XmlElement GetIdElement(XmlDocument document, string idValue)
public Byte[] GetDecryptionIV(EncryptedData encryptedData, string symmetricAlgorithmUri)
public SymmetricAlgorithm GetDecryptionKey(EncryptedData encryptedData, string symmetricAlgorithmUri)
public Byte[] DecryptEncryptedKey(EncryptedKey encryptedKey)
public void AddKeyNameMapping(string keyName, object keyObject)
public void ClearKeyNameMappings()
public EncryptedData Encrypt(XmlElement inputElement, X509Certificate2 certificate)
public EncryptedData Encrypt(XmlElement inputElement, string keyName)
public void DecryptDocument()
public Byte[] EncryptData(Byte[] plaintext, SymmetricAlgorithm symmetricAlgorithm)
public Byte[] EncryptData(XmlElement inputElement, SymmetricAlgorithm symmetricAlgorithm, bool content)
public Byte[] DecryptData(EncryptedData encryptedData, SymmetricAlgorithm symmetricAlgorithm)
public void ReplaceData(XmlElement inputElement, Byte[] decryptedData)
public void ReplaceElement(XmlElement inputElement, EncryptedData encryptedData, bool content)
public Byte[] EncryptKey(Byte[] keyData, SymmetricAlgorithm symmetricAlgorithm)
public Byte[] EncryptKey(Byte[] keyData, RSA rsa, bool useOAEP)
public Byte[] DecryptKey(Byte[] keyData, SymmetricAlgorithm symmetricAlgorithm)
public Byte[] DecryptKey(Byte[] keyData, RSA rsa, bool useOAEP)
}
public System.Security.Cryptography.Xml.EncryptionMethod : object {
private XmlElement _cachedXml
private int _keySize
private string _algorithm
private bool CacheValid
public int KeySize
public string KeyAlgorithm
public void .ctor(string algorithm)
private bool get_CacheValid()
public int get_KeySize()
public void set_KeySize(int value)
public string get_KeyAlgorithm()
public void set_KeyAlgorithm(string value)
public XmlElement GetXml()
internal XmlElement GetXml(XmlDocument document)
public void LoadXml(XmlElement value)
}
public System.Security.Cryptography.Xml.EncryptionProperty : object {
private string _target
private string _id
private XmlElement _elemProp
private XmlElement _cachedXml
public string Id
public string Target
public XmlElement PropertyElement
private bool CacheValid
public void .ctor(XmlElement elementProperty)
public string get_Id()
public string get_Target()
public XmlElement get_PropertyElement()
public void set_PropertyElement(XmlElement value)
private bool get_CacheValid()
public XmlElement GetXml()
internal XmlElement GetXml(XmlDocument document)
public void LoadXml(XmlElement value)
}
public System.Security.Cryptography.Xml.EncryptionPropertyCollection : object {
private ArrayList _props
public int Count
public bool IsFixedSize
public bool IsReadOnly
public EncryptionProperty ItemOf
private object System.Collections.IList.Item
public object SyncRoot
public bool IsSynchronized
public IEnumerator GetEnumerator()
public int get_Count()
private int System.Collections.IList.Add(object value)
public int Add(EncryptionProperty value)
public void Clear()
private bool System.Collections.IList.Contains(object value)
public bool Contains(EncryptionProperty value)
private int System.Collections.IList.IndexOf(object value)
public int IndexOf(EncryptionProperty value)
private void System.Collections.IList.Insert(int index, object value)
public void Insert(int index, EncryptionProperty value)
private void System.Collections.IList.Remove(object value)
public void Remove(EncryptionProperty value)
public void RemoveAt(int index)
public bool get_IsFixedSize()
public bool get_IsReadOnly()
public EncryptionProperty Item(int index)
public EncryptionProperty get_ItemOf(int index)
public void set_ItemOf(int index, EncryptionProperty value)
private object System.Collections.IList.get_Item(int index)
private void System.Collections.IList.set_Item(int index, object value)
public void CopyTo(Array array, int index)
public void CopyTo(EncryptionProperty[] array, int index)
public object get_SyncRoot()
public bool get_IsSynchronized()
}
internal System.Security.Cryptography.Xml.ExcAncestralNamespaceContextManager : AncestralNamespaceContextManager {
private Hashtable _inclusivePrefixSet
internal void .ctor(string inclusiveNamespacesPrefixList)
private bool HasNonRedundantInclusivePrefix(XmlAttribute attr)
private void GatherNamespaceToRender(string nsPrefix, SortedList nsListToRender, Hashtable nsLocallyDeclared)
internal void GetNamespacesToRender(XmlElement element, SortedList attrListToRender, SortedList nsListToRender, Hashtable nsLocallyDeclared)
internal void TrackNamespaceNode(XmlAttribute attr, SortedList nsListToRender, Hashtable nsLocallyDeclared)
internal void TrackXmlNamespaceNode(XmlAttribute attr, SortedList nsListToRender, SortedList attrListToRender, Hashtable nsLocallyDeclared)
}
internal System.Security.Cryptography.Xml.ExcCanonicalXml : object {
private CanonicalXmlDocument _c14nDoc
private ExcAncestralNamespaceContextManager _ancMgr
internal void .ctor(Stream inputStream, bool includeComments, string inclusiveNamespacesPrefixList, XmlResolver resolver, string strBaseUri)
internal void .ctor(XmlDocument document, bool includeComments, string inclusiveNamespacesPrefixList, XmlResolver resolver)
internal void .ctor(XmlNodeList nodeList, bool includeComments, string inclusiveNamespacesPrefixList, XmlResolver resolver)
internal Byte[] GetBytes()
internal Byte[] GetDigestedBytes(HashAlgorithm hash)
private void MarkInclusionStateForNodes(XmlNodeList nodeList, XmlDocument inputRoot, XmlDocument root)
private void MarkNodeAsIncluded(XmlNode node)
}
internal System.Security.Cryptography.Xml.ICanonicalizableNode {
public bool IsInNodeSet
public bool get_IsInNodeSet()
public void set_IsInNodeSet(bool value)
public void Write(StringBuilder strBuilder, DocPosition docPos, AncestralNamespaceContextManager anc)
public void WriteHash(HashAlgorithm hash, DocPosition docPos, AncestralNamespaceContextManager anc)
}
public System.Security.Cryptography.Xml.IRelDecryptor {
public Stream Decrypt(EncryptionMethod encryptionMethod, KeyInfo keyInfo, Stream toDecrypt)
}
public System.Security.Cryptography.Xml.KeyInfo : object {
private string _id
private ArrayList _keyInfoClauses
public string Id
public int Count
public string get_Id()
public void set_Id(string value)
public XmlElement GetXml()
internal XmlElement GetXml(XmlDocument xmlDocument)
public void LoadXml(XmlElement value)
public int get_Count()
public void AddClause(KeyInfoClause clause)
public IEnumerator GetEnumerator()
public IEnumerator GetEnumerator(Type requestedObjectType)
}
public System.Security.Cryptography.Xml.KeyInfoClause : object {
public XmlElement GetXml()
internal XmlElement GetXml(XmlDocument xmlDocument)
public void LoadXml(XmlElement element)
}
public System.Security.Cryptography.Xml.KeyInfoEncryptedKey : KeyInfoClause {
private EncryptedKey _encryptedKey
public EncryptedKey EncryptedKey
public void .ctor(EncryptedKey encryptedKey)
public EncryptedKey get_EncryptedKey()
public void set_EncryptedKey(EncryptedKey value)
public XmlElement GetXml()
internal XmlElement GetXml(XmlDocument xmlDocument)
public void LoadXml(XmlElement value)
}
public System.Security.Cryptography.Xml.KeyInfoName : KeyInfoClause {
private string _keyName
public string Value
public void .ctor(string keyName)
public string get_Value()
public void set_Value(string value)
public XmlElement GetXml()
internal XmlElement GetXml(XmlDocument xmlDocument)
public void LoadXml(XmlElement value)
}
public System.Security.Cryptography.Xml.KeyInfoNode : KeyInfoClause {
private XmlElement _node
public XmlElement Value
public void .ctor(XmlElement node)
public XmlElement get_Value()
public void set_Value(XmlElement value)
public XmlElement GetXml()
internal XmlElement GetXml(XmlDocument xmlDocument)
public void LoadXml(XmlElement value)
}
public System.Security.Cryptography.Xml.KeyInfoRetrievalMethod : KeyInfoClause {
private string _uri
private string _type
public string Uri
public string Type
public void .ctor(string strUri)
public void .ctor(string strUri, string typeName)
public string get_Uri()
public void set_Uri(string value)
public string get_Type()
public void set_Type(string value)
public XmlElement GetXml()
internal XmlElement GetXml(XmlDocument xmlDocument)
public void LoadXml(XmlElement value)
}
public System.Security.Cryptography.Xml.KeyInfoX509Data : KeyInfoClause {
private ArrayList _certificates
private ArrayList _issuerSerials
private ArrayList _subjectKeyIds
private ArrayList _subjectNames
private Byte[] _CRL
public ArrayList Certificates
public ArrayList SubjectKeyIds
public ArrayList SubjectNames
public ArrayList IssuerSerials
public Byte[] CRL
public void .ctor(Byte[] rgbCert)
public void .ctor(X509Certificate cert)
public void .ctor(X509Certificate cert, X509IncludeOption includeOption)
public ArrayList get_Certificates()
public void AddCertificate(X509Certificate certificate)
public ArrayList get_SubjectKeyIds()
public void AddSubjectKeyId(Byte[] subjectKeyId)
public void AddSubjectKeyId(string subjectKeyId)
public ArrayList get_SubjectNames()
public void AddSubjectName(string subjectName)
public ArrayList get_IssuerSerials()
public void AddIssuerSerial(string issuerName, string serialNumber)
internal void InternalAddIssuerSerial(string issuerName, string serialNumber)
public Byte[] get_CRL()
public void set_CRL(Byte[] value)
private void Clear()
public XmlElement GetXml()
internal XmlElement GetXml(XmlDocument xmlDocument)
public void LoadXml(XmlElement element)
}
public System.Security.Cryptography.Xml.KeyReference : EncryptedReference {
public void .ctor(string uri)
public void .ctor(string uri, TransformChain transformChain)
}
internal System.Security.Cryptography.Xml.MyXmlDocument : XmlDocument {
protected XmlAttribute CreateDefaultAttribute(string prefix, string localName, string namespaceURI)
}
internal System.Security.Cryptography.Xml.NamespaceFrame : object {
private Hashtable _rendered
private Hashtable _unrendered
internal void AddRendered(XmlAttribute attr)
internal XmlAttribute GetRendered(string nsPrefix)
internal void AddUnrendered(XmlAttribute attr)
internal XmlAttribute GetUnrendered(string nsPrefix)
internal Hashtable GetUnrendered()
}
internal System.Security.Cryptography.Xml.NamespaceSortOrder : object {
public int Compare(object a, object b)
}
public System.Security.Cryptography.Xml.Reference : object {
internal string DefaultDigestMethod
private string _id
private string _uri
private string _type
private TransformChain _transformChain
private string _digestMethod
private Byte[] _digestValue
private HashAlgorithm _hashAlgorithm
private object _refTarget
private ReferenceTargetType _refTargetType
private XmlElement _cachedXml
private SignedXml _signedXml
internal CanonicalXmlNodeList _namespaces
public string Id
public string Uri
public string Type
public string DigestMethod
public Byte[] DigestValue
public TransformChain TransformChain
internal bool CacheValid
internal SignedXml SignedXml
internal ReferenceTargetType ReferenceTargetType
public void .ctor(Stream stream)
public void .ctor(string uri)
internal void .ctor(XmlElement element)
public string get_Id()
public void set_Id(string value)
public string get_Uri()
public void set_Uri(string value)
public string get_Type()
public void set_Type(string value)
public string get_DigestMethod()
public void set_DigestMethod(string value)
public Byte[] get_DigestValue()
public void set_DigestValue(Byte[] value)
public TransformChain get_TransformChain()
public void set_TransformChain(TransformChain value)
internal bool get_CacheValid()
internal SignedXml get_SignedXml()
internal void set_SignedXml(SignedXml value)
internal ReferenceTargetType get_ReferenceTargetType()
public XmlElement GetXml()
internal XmlElement GetXml(XmlDocument document)
public void LoadXml(XmlElement value)
public void AddTransform(Transform transform)
internal void UpdateHashValue(XmlDocument document, CanonicalXmlNodeList refList)
internal Byte[] CalculateHashValue(XmlDocument document, CanonicalXmlNodeList refList)
}
public System.Security.Cryptography.Xml.ReferenceList : object {
private ArrayList _references
public int Count
public EncryptedReference ItemOf
private object System.Collections.IList.Item
private bool System.Collections.IList.IsFixedSize
private bool System.Collections.IList.IsReadOnly
public object SyncRoot
public bool IsSynchronized
public IEnumerator GetEnumerator()
public int get_Count()
public int Add(object value)
public void Clear()
public bool Contains(object value)
public int IndexOf(object value)
public void Insert(int index, object value)
public void Remove(object value)
public void RemoveAt(int index)
public EncryptedReference Item(int index)
public EncryptedReference get_ItemOf(int index)
public void set_ItemOf(int index, EncryptedReference value)
private object System.Collections.IList.get_Item(int index)
private void System.Collections.IList.set_Item(int index, object value)
public void CopyTo(Array array, int index)
private bool System.Collections.IList.get_IsFixedSize()
private bool System.Collections.IList.get_IsReadOnly()
public object get_SyncRoot()
public bool get_IsSynchronized()
}
internal System.Security.Cryptography.Xml.ReferenceTargetType : Enum {
public int value__
public ReferenceTargetType Stream
public ReferenceTargetType XmlElement
public ReferenceTargetType UriReference
}
public System.Security.Cryptography.Xml.RSAKeyValue : KeyInfoClause {
private RSA _key
private string KeyValueElementName
private string RSAKeyValueElementName
private string ModulusElementName
private string ExponentElementName
public RSA Key
public void .ctor(RSA key)
public RSA get_Key()
public void set_Key(RSA value)
public XmlElement GetXml()
internal XmlElement GetXml(XmlDocument xmlDocument)
public void LoadXml(XmlElement value)
}
internal System.Security.Cryptography.Xml.RSAPKCS1SHA1SignatureDescription : RSAPKCS1SignatureDescription {
public HashAlgorithm CreateDigest()
}
internal System.Security.Cryptography.Xml.RSAPKCS1SHA256SignatureDescription : RSAPKCS1SignatureDescription {
public HashAlgorithm CreateDigest()
}
internal System.Security.Cryptography.Xml.RSAPKCS1SHA384SignatureDescription : RSAPKCS1SignatureDescription {
public HashAlgorithm CreateDigest()
}
internal System.Security.Cryptography.Xml.RSAPKCS1SHA512SignatureDescription : RSAPKCS1SignatureDescription {
public HashAlgorithm CreateDigest()
}
internal System.Security.Cryptography.Xml.RSAPKCS1SignatureDescription : SignatureDescription {
public void .ctor(string hashAlgorithmName)
public AsymmetricSignatureDeformatter CreateDeformatter(AsymmetricAlgorithm key)
public AsymmetricSignatureFormatter CreateFormatter(AsymmetricAlgorithm key)
public HashAlgorithm CreateDigest()
}
public System.Security.Cryptography.Xml.Signature : object {
private string _id
private SignedInfo _signedInfo
private Byte[] _signatureValue
private string _signatureValueId
private KeyInfo _keyInfo
private IList _embeddedObjects
private CanonicalXmlNodeList _referencedItems
private SignedXml _signedXml
internal SignedXml SignedXml
public string Id
public SignedInfo SignedInfo
public Byte[] SignatureValue
public KeyInfo KeyInfo
public IList ObjectList
internal CanonicalXmlNodeList ReferencedItems
internal SignedXml get_SignedXml()
internal void set_SignedXml(SignedXml value)
public string get_Id()
public void set_Id(string value)
public SignedInfo get_SignedInfo()
public void set_SignedInfo(SignedInfo value)
public Byte[] get_SignatureValue()
public void set_SignatureValue(Byte[] value)
public KeyInfo get_KeyInfo()
public void set_KeyInfo(KeyInfo value)
public IList get_ObjectList()
public void set_ObjectList(IList value)
internal CanonicalXmlNodeList get_ReferencedItems()
public XmlElement GetXml()
internal XmlElement GetXml(XmlDocument document)
public void LoadXml(XmlElement value)
public void AddObject(DataObject dataObject)
}
public System.Security.Cryptography.Xml.SignedInfo : object {
private string _id
private string _canonicalizationMethod
private string _signatureMethod
private string _signatureLength
private ArrayList _references
private XmlElement _cachedXml
private SignedXml _signedXml
private Transform _canonicalizationMethodTransform
internal SignedXml SignedXml
public int Count
public bool IsReadOnly
public bool IsSynchronized
public object SyncRoot
public string Id
public string CanonicalizationMethod
public Transform CanonicalizationMethodObject
public string SignatureMethod
public string SignatureLength
public ArrayList References
internal bool CacheValid
internal SignedXml get_SignedXml()
internal void set_SignedXml(SignedXml value)
public IEnumerator GetEnumerator()
public void CopyTo(Array array, int index)
public int get_Count()
public bool get_IsReadOnly()
public bool get_IsSynchronized()
public object get_SyncRoot()
public string get_Id()
public void set_Id(string value)
public string get_CanonicalizationMethod()
public void set_CanonicalizationMethod(string value)
public Transform get_CanonicalizationMethodObject()
public string get_SignatureMethod()
public void set_SignatureMethod(string value)
public string get_SignatureLength()
public void set_SignatureLength(string value)
public ArrayList get_References()
internal bool get_CacheValid()
public XmlElement GetXml()
internal XmlElement GetXml(XmlDocument document)
public void LoadXml(XmlElement value)
public void AddReference(Reference reference)
}
public System.Security.Cryptography.Xml.SignedXml : object {
protected Signature m_signature
protected string m_strSigningKeyName
private AsymmetricAlgorithm _signingKey
private XmlDocument _containingDocument
private IEnumerator _keyInfoEnum
private X509Certificate2Collection _x509Collection
private IEnumerator _x509Enum
private Boolean[] _refProcessed
private Int32[] _refLevelCache
internal XmlResolver _xmlResolver
internal XmlElement _context
private bool _bResolverSet
private Func`2<SignedXml, bool> _signatureFormatValidator
private Collection`1<string> _safeCanonicalizationMethods
private IList`1<string> s_knownCanonicalizationMethods
private IList`1<string> s_defaultSafeTransformMethods
private string XmlDsigMoreHMACMD5Url
private string XmlDsigMoreHMACSHA256Url
private string XmlDsigMoreHMACSHA384Url
private string XmlDsigMoreHMACSHA512Url
private string XmlDsigMoreHMACRIPEMD160Url
private EncryptedXml _exml
public string XmlDsigNamespaceUrl
public string XmlDsigMinimalCanonicalizationUrl
public string XmlDsigCanonicalizationUrl
public string XmlDsigCanonicalizationWithCommentsUrl
public string XmlDsigSHA1Url
public string XmlDsigDSAUrl
public string XmlDsigRSASHA1Url
public string XmlDsigHMACSHA1Url
public string XmlDsigSHA256Url
public string XmlDsigRSASHA256Url
public string XmlDsigSHA384Url
public string XmlDsigRSASHA384Url
public string XmlDsigSHA512Url
public string XmlDsigRSASHA512Url
public string XmlDsigC14NTransformUrl
public string XmlDsigC14NWithCommentsTransformUrl
public string XmlDsigExcC14NTransformUrl
public string XmlDsigExcC14NWithCommentsTransformUrl
public string XmlDsigBase64TransformUrl
public string XmlDsigXPathTransformUrl
public string XmlDsigXsltTransformUrl
public string XmlDsigEnvelopedSignatureTransformUrl
public string XmlDecryptionTransformUrl
public string XmlLicenseTransformUrl
private bool _bCacheValid
private Byte[] _digestedSignedInfo
public string SigningKeyName
public XmlResolver Resolver
internal bool ResolverSet
public Func`2<SignedXml, bool> SignatureFormatValidator
public Collection`1<string> SafeCanonicalizationMethods
public AsymmetricAlgorithm SigningKey
public EncryptedXml EncryptedXml
public Signature Signature
public SignedInfo SignedInfo
public string SignatureMethod
public string SignatureLength
public Byte[] SignatureValue
public KeyInfo KeyInfo
private IList`1<string> KnownCanonicalizationMethods
private IList`1<string> DefaultSafeTransformMethods
public void .ctor(XmlDocument document)
public void .ctor(XmlElement elem)
private void Initialize(XmlElement element)
public string get_SigningKeyName()
public void set_SigningKeyName(string value)
public void set_Resolver(XmlResolver value)
internal bool get_ResolverSet()
public Func`2<SignedXml, bool> get_SignatureFormatValidator()
public void set_SignatureFormatValidator(Func`2<SignedXml, bool> value)
public Collection`1<string> get_SafeCanonicalizationMethods()
public AsymmetricAlgorithm get_SigningKey()
public void set_SigningKey(AsymmetricAlgorithm value)
public EncryptedXml get_EncryptedXml()
public void set_EncryptedXml(EncryptedXml value)
public Signature get_Signature()
public SignedInfo get_SignedInfo()
public string get_SignatureMethod()
public string get_SignatureLength()
public Byte[] get_SignatureValue()
public KeyInfo get_KeyInfo()
public void set_KeyInfo(KeyInfo value)
public XmlElement GetXml()
public void LoadXml(XmlElement value)
public void AddReference(Reference reference)
public void AddObject(DataObject dataObject)
public bool CheckSignature()
public bool CheckSignatureReturningKey(AsymmetricAlgorithm& signingKey)
public bool CheckSignature(AsymmetricAlgorithm key)
public bool CheckSignature(KeyedHashAlgorithm macAlg)
public bool CheckSignature(X509Certificate2 certificate, bool verifySignatureOnly)
public void ComputeSignature()
public void ComputeSignature(KeyedHashAlgorithm macAlg)
protected AsymmetricAlgorithm GetPublicKey()
private X509Certificate2Collection BuildBagOfCerts()
private AsymmetricAlgorithm GetNextCertificatePublicKey()
public XmlElement GetIdElement(XmlDocument document, string idValue)
internal XmlElement DefaultGetIdElement(XmlDocument document, string idValue)
private bool DefaultSignatureFormatValidator(SignedXml signedXml)
private bool DoesSignatureUseTruncatedHmac()
private bool DoesSignatureUseSafeCanonicalizationMethod()
private bool ReferenceUsesSafeTransformMethods(Reference reference)
private bool IsSafeTransform(string transformAlgorithm)
private IList`1<string> get_KnownCanonicalizationMethods()
private IList`1<string> get_DefaultSafeTransformMethods()
private Byte[] GetC14NDigest(HashAlgorithm hash)
private int GetReferenceLevel(int index, ArrayList references)
private void BuildDigestedReferences()
private bool CheckDigestedReferences()
private bool CryptographicEquals(Byte[] a, Byte[] b)
private bool CheckSignatureFormat()
private bool CheckSignedInfo(AsymmetricAlgorithm key)
private bool CheckSignedInfo(KeyedHashAlgorithm macAlg)
private XmlElement GetSingleReferenceTarget(XmlDocument document, string idAttributeName, string idValue)
private bool IsKeyTheCorrectAlgorithm(AsymmetricAlgorithm key, Type expectedType)
}
internal System.Security.Cryptography.Xml.SignedXmlDebugLog : object {
private string NullString
private TraceSource s_traceSource
private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) s_haveVerboseLogging
private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) s_verboseLogging
private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) s_haveInformationLogging
private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) s_informationLogging
private bool InformationLoggingEnabled
private bool VerboseLoggingEnabled
private bool get_InformationLoggingEnabled()
private bool get_VerboseLoggingEnabled()
private string FormatBytes(Byte[] bytes)
private string GetKeyName(object key)
private string GetObjectId(object o)
private string GetOidName(Oid oid)
internal void LogBeginCanonicalization(SignedXml signedXml, Transform canonicalizationTransform)
internal void LogBeginCheckSignatureFormat(SignedXml signedXml, Func`2<SignedXml, bool> formatValidator)
internal void LogBeginCheckSignedInfo(SignedXml signedXml, SignedInfo signedInfo)
internal void LogBeginSignatureComputation(SignedXml signedXml, XmlElement context)
internal void LogBeginSignatureVerification(SignedXml signedXml, XmlElement context)
internal void LogCanonicalizedOutput(SignedXml signedXml, Transform canonicalizationTransform)
internal void LogFormatValidationResult(SignedXml signedXml, bool result)
internal void LogUnsafeCanonicalizationMethod(SignedXml signedXml, string algorithm, IEnumerable`1<string> validAlgorithms)
internal void LogUnsafeTransformMethod(SignedXml signedXml, string algorithm, IEnumerable`1<string> validC14nAlgorithms, IEnumerable`1<string> validTransformAlgorithms)
internal void LogNamespacePropagation(SignedXml signedXml, XmlNodeList namespaces)
internal Stream LogReferenceData(Reference reference, Stream data)
internal void LogSigning(SignedXml signedXml, object key, SignatureDescription signatureDescription, HashAlgorithm hash, AsymmetricSignatureFormatter asymmetricSignatureFormatter)
internal void LogSigning(SignedXml signedXml, KeyedHashAlgorithm key)
internal void LogSigningReference(SignedXml signedXml, Reference reference)
internal void LogVerificationFailure(SignedXml signedXml, string failureLocation)
internal void LogVerificationResult(SignedXml signedXml, object key, bool verified)
internal void LogVerifyKeyUsage(SignedXml signedXml, X509Certificate certificate, X509KeyUsageExtension keyUsages)
internal void LogVerifyReference(SignedXml signedXml, Reference reference)
internal void LogVerifyReferenceHash(SignedXml signedXml, Reference reference, Byte[] actualHash, Byte[] expectedHash)
internal void LogVerifySignedInfo(SignedXml signedXml, AsymmetricAlgorithm key, SignatureDescription signatureDescription, HashAlgorithm hashAlgorithm, AsymmetricSignatureDeformatter asymmetricSignatureDeformatter, Byte[] actualHashValue, Byte[] signatureValue)
internal void LogVerifySignedInfo(SignedXml signedXml, KeyedHashAlgorithm mac, Byte[] actualHashValue, Byte[] signatureValue)
internal void LogVerifyX509Chain(SignedXml signedXml, X509Chain chain, X509Certificate certificate)
internal void LogSignedXmlRecursionLimit(SignedXml signedXml, Reference reference)
private void WriteLine(object source, TraceEventType eventType, SignedXmlDebugEvent eventId, string data)
}
internal System.Security.Cryptography.Xml.SymmetricKeyWrap : object {
private Byte[] s_rgbTripleDES_KW_IV
private Byte[] s_rgbAES_KW_IV
internal Byte[] TripleDESKeyWrapEncrypt(Byte[] rgbKey, Byte[] rgbWrappedKeyData)
internal Byte[] TripleDESKeyWrapDecrypt(Byte[] rgbKey, Byte[] rgbEncryptedWrappedKeyData)
internal Byte[] AESKeyWrapEncrypt(Byte[] rgbKey, Byte[] rgbWrappedKeyData)
internal Byte[] AESKeyWrapDecrypt(Byte[] rgbKey, Byte[] rgbEncryptedWrappedKeyData)
}
public System.Security.Cryptography.Xml.Transform : object {
private string _algorithm
private string _baseUri
internal XmlResolver _xmlResolver
private bool _bResolverSet
private SignedXml _signedXml
private Reference _reference
private Hashtable _propagatedNamespaces
private XmlElement _context
internal string BaseURI
internal SignedXml SignedXml
internal Reference Reference
public string Algorithm
public XmlResolver Resolver
internal bool ResolverSet
public Type[] InputTypes
public Type[] OutputTypes
public XmlElement Context
public Hashtable PropagatedNamespaces
internal string get_BaseURI()
internal void set_BaseURI(string value)
internal SignedXml get_SignedXml()
internal void set_SignedXml(SignedXml value)
internal Reference get_Reference()
internal void set_Reference(Reference value)
public string get_Algorithm()
public void set_Algorithm(string value)
public void set_Resolver(XmlResolver value)
internal XmlResolver get_Resolver()
internal bool get_ResolverSet()
public Type[] get_InputTypes()
public Type[] get_OutputTypes()
internal bool AcceptsType(Type inputType)
public XmlElement GetXml()
internal XmlElement GetXml(XmlDocument document)
internal XmlElement GetXml(XmlDocument document, string name)
public void LoadInnerXml(XmlNodeList nodeList)
protected XmlNodeList GetInnerXml()
public void LoadInput(object obj)
public object GetOutput()
public object GetOutput(Type type)
public Byte[] GetDigestedOutput(HashAlgorithm hash)
public XmlElement get_Context()
public void set_Context(XmlElement value)
public Hashtable get_PropagatedNamespaces()
}
public System.Security.Cryptography.Xml.TransformChain : object {
private ArrayList _transforms
public int Count
public Transform Item
public void Add(Transform transform)
public IEnumerator GetEnumerator()
public int get_Count()
public Transform get_Item(int index)
internal Stream TransformToOctetStream(object inputObject, Type inputType, XmlResolver resolver, string baseUri)
internal Stream TransformToOctetStream(Stream input, XmlResolver resolver, string baseUri)
internal Stream TransformToOctetStream(XmlDocument document, XmlResolver resolver, string baseUri)
internal XmlElement GetXml(XmlDocument document, string ns)
internal void LoadXml(XmlElement value)
}
internal System.Security.Cryptography.Xml.Utils : object {
internal int MaxCharactersInDocument
internal long MaxCharactersFromEntities
internal int XmlDsigSearchDepth
private Char[] s_hexValues
internal int MaxTransformsPerReference
internal int MaxReferencesPerSignedInfo
private bool HasNamespace(XmlElement element, string prefix, string value)
internal bool IsCommittedNamespace(XmlElement element, string prefix, string value)
internal bool IsRedundantNamespace(XmlElement element, string prefix, string value)
internal string GetAttribute(XmlElement element, string localName, string namespaceURI)
internal bool HasAttribute(XmlElement element, string localName, string namespaceURI)
internal bool VerifyAttributes(XmlElement element, string expectedAttrName)
internal bool VerifyAttributes(XmlElement element, String[] expectedAttrNames)
internal bool IsNamespaceNode(XmlNode n)
internal bool IsXmlNamespaceNode(XmlNode n)
internal bool IsDefaultNamespaceNode(XmlNode n)
internal bool IsEmptyDefaultNamespaceNode(XmlNode n)
internal string GetNamespacePrefix(XmlAttribute a)
internal bool HasNamespacePrefix(XmlAttribute a, string nsPrefix)
internal bool IsNonRedundantNamespaceDecl(XmlAttribute a, XmlAttribute nearestAncestorWithSamePrefix)
internal bool IsXmlPrefixDefinitionNode(XmlAttribute a)
internal string DiscardWhiteSpaces(string inputBuffer)
internal string DiscardWhiteSpaces(string inputBuffer, int inputOffset, int inputCount)
internal void SBReplaceCharWithString(StringBuilder sb, char oldChar, string newString)
internal XmlReader PreProcessStreamInput(Stream inputStream, XmlResolver xmlResolver, string baseUri)
internal XmlReaderSettings GetSecureXmlReaderSettings(XmlResolver xmlResolver)
internal XmlDocument PreProcessDocumentInput(XmlDocument document, XmlResolver xmlResolver, string baseUri)
internal XmlDocument PreProcessElementInput(XmlElement elem, XmlResolver xmlResolver, string baseUri)
internal XmlDocument DiscardComments(XmlDocument document)
internal XmlNodeList AllDescendantNodes(XmlNode node, bool includeComments)
internal bool NodeInList(XmlNode node, XmlNodeList nodeList)
internal string GetIdFromLocalUri(string uri, Boolean& discardComments)
internal string ExtractIdFromLocalUri(string uri)
internal void RemoveAllChildren(XmlElement inputElement)
internal long Pump(Stream input, Stream output)
internal Hashtable TokenizePrefixListString(string s)
internal string EscapeWhitespaceData(string data)
internal string EscapeTextData(string data)
internal string EscapeCData(string data)
internal string EscapeAttributeValue(string value)
internal XmlDocument GetOwnerDocument(XmlNodeList nodeList)
internal void AddNamespaces(XmlElement elem, CanonicalXmlNodeList namespaces)
internal void AddNamespaces(XmlElement elem, Hashtable namespaces)
internal CanonicalXmlNodeList GetPropagatedAttributes(XmlElement elem)
internal Byte[] ConvertIntToByteArray(int dwInput)
internal int ConvertByteArrayToInt(Byte[] input)
internal int GetHexArraySize(Byte[] hex)
internal X509IssuerSerial CreateX509IssuerSerial(string issuerName, string serialNumber)
internal X509Certificate2Collection BuildBagOfCerts(KeyInfoX509Data keyInfoX509Data, CertUsageType certUsageType)
internal string EncodeHexString(Byte[] sArray)
internal string EncodeHexString(Byte[] sArray, UInt32 start, UInt32 end)
internal Byte[] DecodeHexString(string s)
internal byte HexToByte(char val)
internal bool IsSelfSigned(X509Chain chain)
internal AsymmetricAlgorithm GetAnyPublicKey(X509Certificate2 certificate)
}
public System.Security.Cryptography.Xml.X509IssuerSerial : ValueType {
private string <IssuerName>k__BackingField
private string <SerialNumber>k__BackingField
public string IssuerName
public string SerialNumber
internal void .ctor(string issuerName, string serialNumber)
public string get_IssuerName()
public void set_IssuerName(string value)
public string get_SerialNumber()
public void set_SerialNumber(string value)
}
public System.Security.Cryptography.Xml.XmlDecryptionTransform : Transform {
private Type[] _inputTypes
private Type[] _outputTypes
private XmlNodeList _encryptedDataList
private ArrayList _arrayListUri
private EncryptedXml _exml
private XmlDocument _containingDocument
private XmlNamespaceManager _nsm
private string XmlDecryptionTransformNamespaceUrl
private ArrayList ExceptUris
public EncryptedXml EncryptedXml
public Type[] InputTypes
public Type[] OutputTypes
private ArrayList get_ExceptUris()
protected bool IsTargetElement(XmlElement inputElement, string idValue)
public EncryptedXml get_EncryptedXml()
public void set_EncryptedXml(EncryptedXml value)
public Type[] get_InputTypes()
public Type[] get_OutputTypes()
public void AddExceptUri(string uri)
public void LoadInnerXml(XmlNodeList nodeList)
protected XmlNodeList GetInnerXml()
public void LoadInput(object obj)
private void LoadStreamInput(Stream stream)
private void LoadXmlDocumentInput(XmlDocument document)
private void ReplaceEncryptedData(XmlElement encryptedDataElement, Byte[] decrypted)
private bool ProcessEncryptedDataItem(XmlElement encryptedDataElement)
private void ProcessElementRecursively(XmlNodeList encryptedDatas)
public object GetOutput()
public object GetOutput(Type type)
}
public System.Security.Cryptography.Xml.XmlDsigBase64Transform : Transform {
private Type[] _inputTypes
private Type[] _outputTypes
private CryptoStream _cs
public Type[] InputTypes
public Type[] OutputTypes
public Type[] get_InputTypes()
public Type[] get_OutputTypes()
public void LoadInnerXml(XmlNodeList nodeList)
protected XmlNodeList GetInnerXml()
public void LoadInput(object obj)
private void LoadStreamInput(Stream inputStream)
private void LoadXmlNodeListInput(XmlNodeList nodeList)
public object GetOutput()
public object GetOutput(Type type)
}
public System.Security.Cryptography.Xml.XmlDsigC14NTransform : Transform {
private Type[] _inputTypes
private Type[] _outputTypes
private CanonicalXml _cXml
private bool _includeComments
public Type[] InputTypes
public Type[] OutputTypes
public void .ctor(bool includeComments)
public Type[] get_InputTypes()
public Type[] get_OutputTypes()
public void LoadInnerXml(XmlNodeList nodeList)
protected XmlNodeList GetInnerXml()
public void LoadInput(object obj)
public object GetOutput()
public object GetOutput(Type type)
public Byte[] GetDigestedOutput(HashAlgorithm hash)
}
public System.Security.Cryptography.Xml.XmlDsigEnvelopedSignatureTransform : Transform {
private Type[] _inputTypes
private Type[] _outputTypes
private XmlNodeList _inputNodeList
private bool _includeComments
private XmlNamespaceManager _nsm
private XmlDocument _containingDocument
private int _signaturePosition
internal int SignaturePosition
public Type[] InputTypes
public Type[] OutputTypes
internal void set_SignaturePosition(int value)
public void .ctor(bool includeComments)
public Type[] get_InputTypes()
public Type[] get_OutputTypes()
public void LoadInnerXml(XmlNodeList nodeList)
protected XmlNodeList GetInnerXml()
public void LoadInput(object obj)
private void LoadStreamInput(Stream stream)
private void LoadXmlNodeListInput(XmlNodeList nodeList)
private void LoadXmlDocumentInput(XmlDocument doc)
public object GetOutput()
public object GetOutput(Type type)
}
public System.Security.Cryptography.Xml.XmlDsigExcC14NTransform : Transform {
private Type[] _inputTypes
private Type[] _outputTypes
private bool _includeComments
private string _inclusiveNamespacesPrefixList
private ExcCanonicalXml _excCanonicalXml
public string InclusiveNamespacesPrefixList
public Type[] InputTypes
public Type[] OutputTypes
public void .ctor(bool includeComments)
public void .ctor(string inclusiveNamespacesPrefixList)
public void .ctor(bool includeComments, string inclusiveNamespacesPrefixList)
public string get_InclusiveNamespacesPrefixList()
public void set_InclusiveNamespacesPrefixList(string value)
public Type[] get_InputTypes()
public Type[] get_OutputTypes()
public void LoadInnerXml(XmlNodeList nodeList)
public void LoadInput(object obj)
protected XmlNodeList GetInnerXml()
public object GetOutput()
public object GetOutput(Type type)
public Byte[] GetDigestedOutput(HashAlgorithm hash)
}
public System.Security.Cryptography.Xml.XmlDsigExcC14NWithCommentsTransform : XmlDsigExcC14NTransform {
public void .ctor(string inclusiveNamespacesPrefixList)
}
public System.Security.Cryptography.Xml.XmlDsigXPathTransform : Transform {
private Type[] _inputTypes
private Type[] _outputTypes
private string _xpathexpr
private XmlDocument _document
private XmlNamespaceManager _nsm
public Type[] InputTypes
public Type[] OutputTypes
public Type[] get_InputTypes()
public Type[] get_OutputTypes()
public void LoadInnerXml(XmlNodeList nodeList)
protected XmlNodeList GetInnerXml()
public void LoadInput(object obj)
private void LoadStreamInput(Stream stream)
private void LoadXmlNodeListInput(XmlNodeList nodeList)
private void LoadXmlDocumentInput(XmlDocument doc)
public object GetOutput()
public object GetOutput(Type type)
}
public System.Security.Cryptography.Xml.XmlDsigXsltTransform : Transform {
private Type[] _inputTypes
private Type[] _outputTypes
private XmlNodeList _xslNodes
private string _xslFragment
private Stream _inputStream
private bool _includeComments
public Type[] InputTypes
public Type[] OutputTypes
public void .ctor(bool includeComments)
public Type[] get_InputTypes()
public Type[] get_OutputTypes()
public void LoadInnerXml(XmlNodeList nodeList)
protected XmlNodeList GetInnerXml()
public void LoadInput(object obj)
public object GetOutput()
public object GetOutput(Type type)
}
public System.Security.Cryptography.Xml.XmlLicenseTransform : Transform {
private Type[] _inputTypes
private Type[] _outputTypes
private XmlNamespaceManager _namespaceManager
private XmlDocument _license
private IRelDecryptor _relDecryptor
private string ElementIssuer
private string NamespaceUriCore
public Type[] InputTypes
public Type[] OutputTypes
public IRelDecryptor Decryptor
public Type[] get_InputTypes()
public Type[] get_OutputTypes()
public IRelDecryptor get_Decryptor()
public void set_Decryptor(IRelDecryptor value)
private void DecryptEncryptedGrants(XmlNodeList encryptedGrantList, IRelDecryptor decryptor)
protected XmlNodeList GetInnerXml()
public object GetOutput()
public object GetOutput(Type type)
public void LoadInnerXml(XmlNodeList nodeList)
public void LoadInput(object obj)
}
public System.Security.Permissions.DataProtectionPermission : CodeAccessPermission {
private int version
private DataProtectionPermissionFlags _flags
public DataProtectionPermissionFlags Flags
public void .ctor(PermissionState state)
public void .ctor(DataProtectionPermissionFlags flag)
public DataProtectionPermissionFlags get_Flags()
public void set_Flags(DataProtectionPermissionFlags value)
public bool IsUnrestricted()
public IPermission Copy()
public IPermission Intersect(IPermission target)
public IPermission Union(IPermission target)
public bool IsSubsetOf(IPermission target)
public void FromXml(SecurityElement securityElement)
public SecurityElement ToXml()
private DataProtectionPermission Cast(IPermission target)
}
public System.Security.Permissions.DataProtectionPermissionAttribute : CodeAccessSecurityAttribute {
private DataProtectionPermissionFlags _flags
public DataProtectionPermissionFlags Flags
public bool ProtectData
public bool UnprotectData
public bool ProtectMemory
public bool UnprotectMemory
public void .ctor(SecurityAction action)
public DataProtectionPermissionFlags get_Flags()
public void set_Flags(DataProtectionPermissionFlags value)
public bool get_ProtectData()
public void set_ProtectData(bool value)
public bool get_UnprotectData()
public void set_UnprotectData(bool value)
public bool get_ProtectMemory()
public void set_ProtectMemory(bool value)
public bool get_UnprotectMemory()
public void set_UnprotectMemory(bool value)
public IPermission CreatePermission()
}
public System.Security.Permissions.DataProtectionPermissionFlags : Enum {
public int value__
public DataProtectionPermissionFlags NoFlags
public DataProtectionPermissionFlags ProtectData
public DataProtectionPermissionFlags UnprotectData
public DataProtectionPermissionFlags ProtectMemory
public DataProtectionPermissionFlags UnprotectMemory
public DataProtectionPermissionFlags AllFlags
}
internal System.Security.Permissions.PermissionHelper : object {
internal SecurityElement Element(Type type, int version)
internal PermissionState CheckPermissionState(PermissionState state, bool allowUnrestricted)
internal int CheckSecurityElement(SecurityElement se, string parameterName, int minimumVersion, int maximumVersion)
internal bool IsUnrestricted(SecurityElement se)
internal void ThrowInvalidPermission(IPermission target, Type expected)
}
internal Unity.ThrowStub : ObjectDisposedException {
public void ThrowNotSupportedException()
}
