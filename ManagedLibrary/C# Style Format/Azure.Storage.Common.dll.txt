internal Azure.Core.AppContextSwitchHelper : object {
public bool GetConfigValue(string appContexSwitchName, string environmentVariableName)
}
internal Azure.Core.Argument : object {
public void AssertNotNull(T value, string name)
public void AssertNotNull(Nullable`1<T> value, string name)
public void AssertNotNullOrEmpty(IEnumerable`1<T> value, string name)
public void AssertNotNullOrEmpty(string value, string name)
public void AssertNotNullOrWhiteSpace(string value, string name)
public void AssertNotDefault(T& value, string name)
public void AssertInRange(T value, T minimum, T maximum, string name)
public void AssertEnumDefined(Type enumType, object value, string name)
public T CheckNotNull(T value, string name)
public string CheckNotNullOrEmpty(string value, string name)
public void AssertNull(T value, string name, string message)
}
internal Azure.Core.AsyncLockWithValue`1 : object {
private object _syncObj
private Queue`1<TaskCompletionSource`1<LockOrValue<T>>> _waiters
private bool _isLocked
private bool _hasValue
private long _index
private T _value
public bool HasValue
public bool get_HasValue()
public void .ctor(T value)
public bool TryGetValue(T& value)
public ValueTask`1<LockOrValue<T>> GetLockOrValueAsync(bool async, CancellationToken cancellationToken)
private void SetValue(T value, Int64& lockIndex)
private void Reset(Int64& lockIndex)
private void UnlockOrGetNextWaiter(Int64& lockIndex, TaskCompletionSource`1& nextWaiter)
}
internal Azure.Core.AuthorizationChallengeParser : object {
public string GetChallengeParameterFromResponse(Response response, string challengeScheme, string challengeParameter)
internal bool TryGetNextChallenge(ReadOnlySpan`1& headerValue, ReadOnlySpan`1& challengeKey)
internal bool TryGetNextParameter(ReadOnlySpan`1& headerValue, ReadOnlySpan`1& paramKey, ReadOnlySpan`1& paramValue, char separator)
}
internal Azure.Core.CallerShouldAuditAttribute : Attribute {
private string <Reason>k__BackingField
public string Reason
public string get_Reason()
public void set_Reason(string value)
}
internal Azure.Core.ChangeTrackingDictionary`2 : object {
private IDictionary`2<TKey, TValue> _innerDictionary
public bool IsUndefined
public int Count
public bool IsReadOnly
public TValue Item
private IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Keys
private IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Values
public ICollection`1<TKey> Keys
public ICollection`1<TValue> Values
public void .ctor(Optional`1<IReadOnlyDictionary`2<TKey, TValue>> optionalDictionary)
public void .ctor(Optional`1<IDictionary`2<TKey, TValue>> optionalDictionary)
private void .ctor(IDictionary`2<TKey, TValue> dictionary)
private void .ctor(IReadOnlyDictionary`2<TKey, TValue> dictionary)
public bool get_IsUndefined()
public IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
public void Add(KeyValuePair`2<TKey, TValue> item)
public void Clear()
public bool Contains(KeyValuePair`2<TKey, TValue> item)
public void CopyTo(KeyValuePair`2[] array, int arrayIndex)
public bool Remove(KeyValuePair`2<TKey, TValue> item)
public int get_Count()
public bool get_IsReadOnly()
public void Add(TKey key, TValue value)
public bool ContainsKey(TKey key)
public bool Remove(TKey key)
public bool TryGetValue(TKey key, TValue& value)
public TValue get_Item(TKey key)
public void set_Item(TKey key, TValue value)
private IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Keys()
private IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Values()
public ICollection`1<TKey> get_Keys()
public ICollection`1<TValue> get_Values()
private IDictionary`2<TKey, TValue> EnsureDictionary()
internal IEnumerator`1<KeyValuePair`2<TKey, TValue>> <GetEnumerator>g__GetEmptyEnumerator|8_0()
}
internal Azure.Core.ChangeTrackingList`1 : object {
private IList`1<T> _innerList
public bool IsUndefined
public int Count
public bool IsReadOnly
public T Item
public void .ctor(Optional`1<IList`1<T>> optionalList)
public void .ctor(Optional`1<IReadOnlyList`1<T>> optionalList)
private void .ctor(IEnumerable`1<T> innerList)
private void .ctor(IList`1<T> innerList)
public bool get_IsUndefined()
public void Reset()
public IEnumerator`1<T> GetEnumerator()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
public void Add(T item)
public void Clear()
public bool Contains(T item)
public void CopyTo(T[] array, int arrayIndex)
public bool Remove(T item)
public int get_Count()
public bool get_IsReadOnly()
public int IndexOf(T item)
public void Insert(int index, T item)
public void RemoveAt(int index)
public T get_Item(int index)
public void set_Item(int index, T value)
private IList`1<T> EnsureList()
internal IEnumerator`1<T> <GetEnumerator>g__EnumerateEmpty|9_0()
}
internal Azure.Core.FixedDelayWithNoJitterStrategy : DelayStrategy {
private TimeSpan DefaultDelay
private TimeSpan _delay
public void .ctor(Nullable`1<TimeSpan> suggestedDelay)
protected TimeSpan GetNextDelayCore(Response response, int retryNumber)
}
internal Azure.Core.FormUrlEncodedContent : RequestContent {
private List`1<KeyValuePair`2<string, string>> _values
private Encoding Latin1
private Byte[] _bytes
public void Add(string parameter, string value)
private void BuildIfNeeded()
public Task WriteToAsync(Stream stream, CancellationToken cancellation)
public void WriteTo(Stream stream, CancellationToken cancellation)
public bool TryComputeLength(Int64& length)
public void Dispose()
private Byte[] GetContentByteArray(IEnumerable`1<KeyValuePair`2<string, string>> nameValueCollection)
private string Encode(string data)
}
internal Azure.Core.HttpMessageSanitizer : object {
private string LogAllValue
private bool _logAllHeaders
private bool _logFullQueries
private String[] _allowedQueryParameters
private string _redactedPlaceholder
private HashSet`1<string> _allowedHeaders
internal HttpMessageSanitizer Default
public void .ctor(String[] allowedQueryParameters, String[] allowedHeaders, string redactedPlaceholder)
public string SanitizeHeader(string name, string value)
public string SanitizeUrl(string url)
}
internal Azure.Core.HttpPipelineExtensions : object {
public ValueTask`1<Response> ProcessMessageAsync(HttpPipeline pipeline, HttpMessage message, RequestContext requestContext, CancellationToken cancellationToken)
public Response ProcessMessage(HttpPipeline pipeline, HttpMessage message, RequestContext requestContext, CancellationToken cancellationToken)
public ValueTask`1<Response`1<bool>> ProcessHeadAsBoolMessageAsync(HttpPipeline pipeline, HttpMessage message, ClientDiagnostics clientDiagnostics, RequestContext requestContext)
public Response`1<bool> ProcessHeadAsBoolMessage(HttpPipeline pipeline, HttpMessage message, ClientDiagnostics clientDiagnostics, RequestContext requestContext)
private ValueTuple`2<CancellationToken, ErrorOptions> ApplyRequestContext(RequestContext requestContext)
}
internal Azure.Core.IOperation {
public ValueTask`1<OperationState> UpdateStateAsync(bool async, CancellationToken cancellationToken)
}
internal Azure.Core.IOperation`1 {
public ValueTask`1<OperationState`1<T>> UpdateStateAsync(bool async, CancellationToken cancellationToken)
}
internal Azure.Core.IOperationSource`1 {
public T CreateResult(Response response, CancellationToken cancellationToken)
public ValueTask`1<T> CreateResultAsync(Response response, CancellationToken cancellationToken)
}
internal Azure.Core.IUtf8JsonSerializable {
public void Write(Utf8JsonWriter writer)
}
internal Azure.Core.IXmlSerializable {
public void Write(XmlWriter writer, string nameHint)
}
internal Azure.Core.JsonElementExtensions : object {
public object GetObject(JsonElement& element)
public Byte[] GetBytesFromBase64(JsonElement& element, string format)
public DateTimeOffset GetDateTimeOffset(JsonElement& element, string format)
public TimeSpan GetTimeSpan(JsonElement& element, string format)
public char GetChar(JsonElement& element)
public void ThrowNonNullablePropertyIsNull(JsonProperty property)
public string GetRequiredString(JsonElement& element)
}
internal Azure.Core.NextLinkOperationImplementation : object {
private string ApiVersionParam
private String[] FailureStates
private String[] SuccessStates
private HeaderSource _headerSource
private bool _originalResponseHasLocation
private Uri _startRequestUri
private OperationFinalStateVia _finalStateVia
private RequestMethod _requestMethod
private HttpPipeline _pipeline
private string _apiVersion
private string _lastKnownLocation
private string _nextRequestUri
public IOperation Create(HttpPipeline pipeline, RequestMethod requestMethod, Uri startRequestUri, Response response, OperationFinalStateVia finalStateVia, bool skipApiVersionOverride, string apiVersionOverrideValue)
public IOperation`1<T> Create(IOperationSource`1<T> operationSource, HttpPipeline pipeline, RequestMethod requestMethod, Uri startRequestUri, Response response, OperationFinalStateVia finalStateVia, bool skipApiVersionOverride, string apiVersionOverrideValue)
private void .ctor(HttpPipeline pipeline, RequestMethod requestMethod, Uri startRequestUri, string nextRequestUri, HeaderSource headerSource, bool originalResponseHasLocation, string lastKnownLocation, OperationFinalStateVia finalStateVia, string apiVersion)
public ValueTask`1<OperationState> UpdateStateAsync(bool async, CancellationToken cancellationToken)
private OperationState GetOperationStateFromFinalResponse(RequestMethod requestMethod, Response response)
private void UpdateNextRequestUri(ResponseHeaders headers)
internal string AppendOrReplaceApiVersion(string uri, string apiVersion)
internal bool TryGetApiVersion(Uri startRequestUri, ReadOnlySpan`1& apiVersion)
private string GetFinalUri(string resourceLocation)
private ValueTask`1<Response> GetResponseAsync(bool async, string uri, CancellationToken cancellationToken)
private HttpMessage CreateRequest(string uri)
private bool IsFinalState(Response response, HeaderSource headerSource, Nullable`1& failureState, String& resourceLocation)
private bool ShouldIgnoreHeader(RequestMethod method, Response response)
private HeaderSource GetHeaderSource(RequestMethod requestMethod, Uri requestUri, Response response, string apiVersion, String& nextRequestUri)
}
internal Azure.Core.OperationFinalStateVia : Enum {
public int value__
public OperationFinalStateVia AzureAsyncOperation
public OperationFinalStateVia Location
public OperationFinalStateVia OriginalUri
public OperationFinalStateVia OperationLocation
public OperationFinalStateVia LocationOverride
}
internal Azure.Core.OperationHelpers : object {
public T GetValue(T& value)
public T GetValue(Nullable`1& value)
public ValueTask`1<Response`1<TResult>> DefaultWaitForCompletionAsync(Operation`1<TResult> operation, CancellationToken cancellationToken)
public ValueTask`1<Response`1<TResult>> DefaultWaitForCompletionAsync(Operation`1<TResult> operation, TimeSpan pollingInterval, CancellationToken cancellationToken)
public Response`1<TResult> DefaultWaitForCompletion(Operation`1<TResult> operation, CancellationToken cancellationToken)
public Response`1<TResult> DefaultWaitForCompletion(Operation`1<TResult> operation, TimeSpan pollingInterval, CancellationToken cancellationToken)
public ValueTask`1<Response> DefaultWaitForCompletionResponseAsync(Operation operation, CancellationToken cancellationToken)
public ValueTask`1<Response> DefaultWaitForCompletionResponseAsync(Operation operation, TimeSpan pollingInterval, CancellationToken cancellationToken)
public Response DefaultWaitForCompletionResponse(Operation operation, CancellationToken cancellationToken)
public Response DefaultWaitForCompletionResponse(Operation operation, TimeSpan pollingInterval, CancellationToken cancellationToken)
}
internal Azure.Core.OperationInternal : OperationInternalBase {
private OperationInternal`1<VoidValue> _internalOperation
public Response RawResponse
public bool HasCompleted
public OperationInternal Succeeded(Response rawResponse)
public OperationInternal Failed(Response rawResponse, RequestFailedException operationFailedException)
public void .ctor(IOperation operation, ClientDiagnostics clientDiagnostics, Response rawResponse, string operationTypeName, IEnumerable`1<KeyValuePair`2<string, string>> scopeAttributes, DelayStrategy fallbackStrategy)
private void .ctor(OperationState finalState)
public Response get_RawResponse()
public bool get_HasCompleted()
protected ValueTask`1<Response> UpdateStatusAsync(bool async, CancellationToken cancellationToken)
}
internal Azure.Core.OperationInternal`1 : OperationInternalBase {
private IOperation`1<T> _operation
private AsyncLockWithValue`1<OperationState`1<T>> _stateLock
private Response _rawResponse
public Response RawResponse
public bool HasCompleted
public bool HasValue
public T Value
public OperationInternal`1<T> Succeeded(Response rawResponse, T value)
public OperationInternal`1<T> Failed(Response rawResponse, RequestFailedException operationFailedException)
public void .ctor(IOperation`1<T> operation, ClientDiagnostics clientDiagnostics, Response rawResponse, string operationTypeName, IEnumerable`1<KeyValuePair`2<string, string>> scopeAttributes, DelayStrategy fallbackStrategy)
private void .ctor(OperationState`1<T> finalState)
public Response get_RawResponse()
public bool get_HasCompleted()
public bool get_HasValue()
public T get_Value()
public ValueTask`1<Response`1<T>> WaitForCompletionAsync(CancellationToken cancellationToken)
public ValueTask`1<Response`1<T>> WaitForCompletionAsync(TimeSpan pollingInterval, CancellationToken cancellationToken)
public Response`1<T> WaitForCompletion(CancellationToken cancellationToken)
public Response`1<T> WaitForCompletion(TimeSpan pollingInterval, CancellationToken cancellationToken)
private ValueTask`1<Response`1<T>> WaitForCompletionAsync(bool async, Nullable`1<TimeSpan> pollingInterval, CancellationToken cancellationToken)
protected ValueTask`1<Response> UpdateStatusAsync(bool async, CancellationToken cancellationToken)
private Response GetResponseFromState(OperationState`1<T> state)
}
internal Azure.Core.OperationInternalBase : object {
private ClientDiagnostics _diagnostics
private IReadOnlyDictionary`2<string, string> _scopeAttributes
private DelayStrategy _fallbackStrategy
private AsyncLockWithValue`1<Response> _responseLock
private string _waitForCompletionResponseScopeName
protected string _updateStatusScopeName
protected string _waitForCompletionScopeName
public Response RawResponse
public bool HasCompleted
protected void .ctor(Response rawResponse)
protected void .ctor(ClientDiagnostics clientDiagnostics, string operationTypeName, IEnumerable`1<KeyValuePair`2<string, string>> scopeAttributes, DelayStrategy fallbackStrategy)
public Response get_RawResponse()
public bool get_HasCompleted()
public ValueTask`1<Response> UpdateStatusAsync(CancellationToken cancellationToken)
public Response UpdateStatus(CancellationToken cancellationToken)
public ValueTask`1<Response> WaitForCompletionResponseAsync(CancellationToken cancellationToken)
public ValueTask`1<Response> WaitForCompletionResponseAsync(TimeSpan pollingInterval, CancellationToken cancellationToken)
public Response WaitForCompletionResponse(CancellationToken cancellationToken)
public Response WaitForCompletionResponse(TimeSpan pollingInterval, CancellationToken cancellationToken)
protected ValueTask`1<Response> WaitForCompletionResponseAsync(bool async, Nullable`1<TimeSpan> pollingInterval, string scopeName, CancellationToken cancellationToken)
protected ValueTask`1<Response> UpdateStatusAsync(bool async, CancellationToken cancellationToken)
protected DiagnosticScope CreateScope(string scopeName)
}
internal Azure.Core.OperationPoller : object {
private DelayStrategy _delayStrategy
public void .ctor(DelayStrategy strategy)
public ValueTask`1<Response> WaitForCompletionResponseAsync(Operation operation, Nullable`1<TimeSpan> delayHint, CancellationToken cancellationToken)
public Response WaitForCompletionResponse(Operation operation, Nullable`1<TimeSpan> delayHint, CancellationToken cancellationToken)
public ValueTask`1<Response> WaitForCompletionResponseAsync(OperationInternalBase operation, Nullable`1<TimeSpan> delayHint, CancellationToken cancellationToken)
public Response WaitForCompletionResponse(OperationInternalBase operation, Nullable`1<TimeSpan> delayHint, CancellationToken cancellationToken)
public ValueTask`1<Response`1<T>> WaitForCompletionAsync(Operation`1<T> operation, Nullable`1<TimeSpan> delayHint, CancellationToken cancellationToken)
public Response`1<T> WaitForCompletion(Operation`1<T> operation, Nullable`1<TimeSpan> delayHint, CancellationToken cancellationToken)
public ValueTask`1<Response`1<T>> WaitForCompletionAsync(OperationInternal`1<T> operation, Nullable`1<TimeSpan> delayHint, CancellationToken cancellationToken)
public Response`1<T> WaitForCompletion(OperationInternal`1<T> operation, Nullable`1<TimeSpan> delayHint, CancellationToken cancellationToken)
private ValueTask`1<Response> WaitForCompletionAsync(bool async, Operation operation, Nullable`1<TimeSpan> delayHint, CancellationToken cancellationToken)
private ValueTask`1<Response> WaitForCompletionAsync(bool async, OperationInternalBase operation, Nullable`1<TimeSpan> delayHint, CancellationToken cancellationToken)
private ValueTask Delay(bool async, TimeSpan delay, CancellationToken cancellationToken)
}
internal Azure.Core.OperationState : ValueType {
private Response <RawResponse>k__BackingField
private bool <HasCompleted>k__BackingField
private bool <HasSucceeded>k__BackingField
private RequestFailedException <OperationFailedException>k__BackingField
public Response RawResponse
public bool HasCompleted
public bool HasSucceeded
public RequestFailedException OperationFailedException
private void .ctor(Response rawResponse, bool hasCompleted, bool hasSucceeded, RequestFailedException operationFailedException)
public Response get_RawResponse()
public bool get_HasCompleted()
public bool get_HasSucceeded()
public RequestFailedException get_OperationFailedException()
public OperationState Success(Response rawResponse)
public OperationState Failure(Response rawResponse, RequestFailedException operationFailedException)
public OperationState Pending(Response rawResponse)
}
internal Azure.Core.OperationState`1 : ValueType {
private Response <RawResponse>k__BackingField
private bool <HasCompleted>k__BackingField
private bool <HasSucceeded>k__BackingField
private T <Value>k__BackingField
private RequestFailedException <OperationFailedException>k__BackingField
public Response RawResponse
public bool HasCompleted
public bool HasSucceeded
public T Value
public RequestFailedException OperationFailedException
private void .ctor(Response rawResponse, bool hasCompleted, bool hasSucceeded, T value, RequestFailedException operationFailedException)
public Response get_RawResponse()
public bool get_HasCompleted()
public bool get_HasSucceeded()
public T get_Value()
public RequestFailedException get_OperationFailedException()
public OperationState`1<T> Success(Response rawResponse, T value)
public OperationState`1<T> Failure(Response rawResponse, RequestFailedException operationFailedException)
public OperationState`1<T> Pending(Response rawResponse)
}
internal Azure.Core.Optional : object {
public bool IsCollectionDefined(IEnumerable`1<T> collection)
public bool IsCollectionDefined(IReadOnlyDictionary`2<TKey, TValue> collection)
public bool IsCollectionDefined(IDictionary`2<TKey, TValue> collection)
public bool IsDefined(Nullable`1<T> value)
public bool IsDefined(object value)
public bool IsDefined(string value)
public bool IsDefined(JsonElement value)
public IReadOnlyDictionary`2<TKey, TValue> ToDictionary(Optional`1<IReadOnlyDictionary`2<TKey, TValue>> optional)
public IDictionary`2<TKey, TValue> ToDictionary(Optional`1<IDictionary`2<TKey, TValue>> optional)
public IReadOnlyList`1<T> ToList(Optional`1<IReadOnlyList`1<T>> optional)
public IList`1<T> ToList(Optional`1<IList`1<T>> optional)
public Nullable`1<T> ToNullable(Optional`1<T> optional)
public Nullable`1<T> ToNullable(Optional`1<Nullable`1<T>> optional)
}
internal Azure.Core.Optional`1 : ValueType {
private T <Value>k__BackingField
private bool <HasValue>k__BackingField
public T Value
public bool HasValue
public void .ctor(T value)
public T get_Value()
public bool get_HasValue()
public Optional`1<T> op_Implicit(T value)
public T op_Implicit(Optional`1<T> optional)
}
internal Azure.Core.Page : object {
public Page`1<T> FromValues(IEnumerable`1<T> values, string continuationToken, Response response)
}
internal Azure.Core.PageableHelpers : object {
private Byte[] DefaultItemPropertyName
private Byte[] DefaultNextLinkPropertyName
public AsyncPageable`1<T> CreateAsyncPageable(Func`2<Nullable`1<int>, HttpMessage> createFirstPageRequest, Func`3<Nullable`1<int>, string, HttpMessage> createNextPageRequest, Func`2<Response, ValueTuple`2<List`1<T>, string>> responseParser, ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string scopeName, RequestContext requestContext)
public AsyncPageable`1<T> CreateAsyncPageable(Func`2<Nullable`1<int>, HttpMessage> createFirstPageRequest, Func`3<Nullable`1<int>, string, HttpMessage> createNextPageRequest, Func`2<JsonElement, T> valueFactory, ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string scopeName, string itemPropertyName, string nextLinkPropertyName, CancellationToken cancellationToken)
public AsyncPageable`1<T> CreateAsyncPageable(Func`2<Nullable`1<int>, HttpMessage> createFirstPageRequest, Func`3<Nullable`1<int>, string, HttpMessage> createNextPageRequest, Func`2<JsonElement, T> valueFactory, ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string scopeName, string itemPropertyName, string nextLinkPropertyName, RequestContext requestContext)
public AsyncPageable`1<T> CreateAsyncPageable(Response initialResponse, Func`3<Nullable`1<int>, string, HttpMessage> createNextPageRequest, Func`2<JsonElement, T> valueFactory, ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string scopeName, string itemPropertyName, string nextLinkPropertyName, CancellationToken cancellationToken)
public Pageable`1<T> CreatePageable(Func`2<Nullable`1<int>, HttpMessage> createFirstPageRequest, Func`3<Nullable`1<int>, string, HttpMessage> createNextPageRequest, Func`2<Response, ValueTuple`2<List`1<T>, string>> responseParser, ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string scopeName, RequestContext requestContext)
public Pageable`1<T> CreatePageable(Func`2<Nullable`1<int>, HttpMessage> createFirstPageRequest, Func`3<Nullable`1<int>, string, HttpMessage> createNextPageRequest, Func`2<JsonElement, T> valueFactory, ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string scopeName, string itemPropertyName, string nextLinkPropertyName, CancellationToken cancellationToken)
public Pageable`1<T> CreatePageable(Func`2<Nullable`1<int>, HttpMessage> createFirstPageRequest, Func`3<Nullable`1<int>, string, HttpMessage> createNextPageRequest, Func`2<JsonElement, T> valueFactory, ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string scopeName, string itemPropertyName, string nextLinkPropertyName, RequestContext requestContext)
public Pageable`1<T> CreatePageable(Response initialResponse, Func`3<Nullable`1<int>, string, HttpMessage> createNextPageRequest, Func`2<JsonElement, T> valueFactory, ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string scopeName, string itemPropertyName, string nextLinkPropertyName, CancellationToken cancellationToken)
public ValueTask`1<Operation`1<AsyncPageable`1<T>>> CreateAsyncPageable(WaitUntil waitUntil, HttpMessage message, Func`3<Nullable`1<int>, string, HttpMessage> createNextPageMethod, Func`2<JsonElement, T> valueFactory, ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, OperationFinalStateVia finalStateVia, string scopeName, string itemPropertyName, string nextLinkPropertyName, RequestContext requestContext)
public Operation`1<Pageable`1<T>> CreatePageable(WaitUntil waitUntil, HttpMessage message, Func`3<Nullable`1<int>, string, HttpMessage> createNextPageMethod, Func`2<JsonElement, T> valueFactory, ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, OperationFinalStateVia finalStateVia, string scopeName, string itemPropertyName, string nextLinkPropertyName, RequestContext requestContext)
public Pageable`1<T> CreateEnumerable(Func`2<Nullable`1<int>, Page`1<T>> firstPageFunc, Func`3<string, Nullable`1<int>, Page`1<T>> nextPageFunc, Nullable`1<int> pageSize)
public AsyncPageable`1<T> CreateAsyncEnumerable(Func`2<Nullable`1<int>, Task`1<Page`1<T>>> firstPageFunc, Func`3<string, Nullable`1<int>, Task`1<Page`1<T>>> nextPageFunc, Nullable`1<int> pageSize)
private ValueTuple`2<List`1<T>, string> ParseResponseForBinaryData(Response response, Byte[] itemPropertyName, Byte[] nextLinkPropertyName)
internal object <ParseResponseForBinaryData>g__ReadBinaryData|19_0(Utf8JsonReader& r, ReadOnlyMemory`1& content)
}
internal Azure.Core.Pipeline.ActivityExtensions : object {
private bool <SupportsActivitySource>k__BackingField
public bool SupportsActivitySource
public bool get_SupportsActivitySource()
private void set_SupportsActivitySource(bool value)
public void ResetFeatureSwitch()
}
internal Azure.Core.Pipeline.ClientDiagnostics : DiagnosticScopeFactory {
public void .ctor(ClientOptions options, Nullable`1<bool> suppressNestedClientActivities)
public void .ctor(string optionsNamespace, string providerNamespace, DiagnosticsOptions diagnosticsOptions, Nullable`1<bool> suppressNestedClientActivities)
internal HttpMessageSanitizer CreateMessageSanitizer(DiagnosticsOptions diagnostics)
internal string GetResourceProviderNamespace(Assembly assembly)
}
internal Azure.Core.Pipeline.DiagnosticScope : ValueType {
private string AzureSdkScopeLabel
internal string OpenTelemetrySchemaAttribute
internal string OpenTelemetrySchemaVersion
private object AzureSdkScopeValue
private ActivityAdapter _activityAdapter
private bool _suppressNestedClientActivities
private bool <IsEnabled>k__BackingField
public bool IsEnabled
internal void .ctor(string scopeName, DiagnosticListener source, object diagnosticSourceArgs, ActivitySource activitySource, ActivityKind kind, bool suppressNestedClientActivities)
public bool get_IsEnabled()
public void AddAttribute(string name, string value)
public void AddIntegerAttribute(string name, int value)
public void AddAttribute(string name, T value, Func`2<T, string> format)
public void AddLink(string traceparent, string tracestate, IDictionary`2<string, string> attributes)
public void Start()
public void SetDisplayName(string displayName)
public void SetStartTime(DateTime dateTime)
public void SetTraceContext(string traceparent, string tracestate)
public void Dispose()
public void Failed(Exception exception)
public void Failed(string errorCode)
}
internal Azure.Core.Pipeline.DiagnosticScopeFactory : object {
private Dictionary`2<string, DiagnosticListener> _listeners
private string _resourceProviderNamespace
private DiagnosticListener _source
private bool _suppressNestedClientActivities
private bool _isStable
private ConcurrentDictionary`2<string, ActivitySource> ActivitySources
private bool <IsActivityEnabled>k__BackingField
public bool IsActivityEnabled
public void .ctor(string clientNamespace, string resourceProviderNamespace, bool isActivityEnabled, bool suppressNestedClientActivities, bool isStable)
public bool get_IsActivityEnabled()
public DiagnosticScope CreateScope(string name, ActivityKind kind)
private ActivitySource GetActivitySource(string ns, string name)
}
internal Azure.Core.Pipeline.TaskExtensions : object {
public WithCancellationTaskAwaitable AwaitWithCancellation(Task task, CancellationToken cancellationToken)
public WithCancellationTaskAwaitable`1<T> AwaitWithCancellation(Task`1<T> task, CancellationToken cancellationToken)
public WithCancellationValueTaskAwaitable`1<T> AwaitWithCancellation(ValueTask`1<T> task, CancellationToken cancellationToken)
public T EnsureCompleted(Task`1<T> task)
public void EnsureCompleted(Task task)
public T EnsureCompleted(ValueTask`1<T> task)
public void EnsureCompleted(ValueTask task)
public Enumerable`1<T> EnsureSyncEnumerable(IAsyncEnumerable`1<T> asyncEnumerable)
public ConfiguredValueTaskAwaitable`1<T> EnsureCompleted(ConfiguredValueTaskAwaitable`1<T> awaitable, bool async)
public ConfiguredValueTaskAwaitable EnsureCompleted(ConfiguredValueTaskAwaitable awaitable, bool async)
private void VerifyTaskCompleted(bool isCompleted)
}
internal Azure.Core.ProtocolOperation`1 : Operation`1<T> {
private Func`2<Response, T> _resultSelector
private OperationInternal`1<T> _operation
private IOperation _nextLinkOperation
public string Id
public T Value
public bool HasCompleted
public bool HasValue
internal void .ctor(ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, Request request, Response response, OperationFinalStateVia finalStateVia, string scopeName, Func`2<Response, T> resultSelector)
public string get_Id()
public T get_Value()
public bool get_HasCompleted()
public bool get_HasValue()
public Response GetRawResponse()
public Response UpdateStatus(CancellationToken cancellationToken)
public ValueTask`1<Response> UpdateStatusAsync(CancellationToken cancellationToken)
public ValueTask`1<Response`1<T>> WaitForCompletionAsync(CancellationToken cancellationToken)
public ValueTask`1<Response`1<T>> WaitForCompletionAsync(TimeSpan pollingInterval, CancellationToken cancellationToken)
private ValueTask`1<OperationState`1<T>> Azure.Core.IOperation<T>.UpdateStateAsync(bool async, CancellationToken cancellationToken)
}
internal Azure.Core.ProtocolOperationHelpers : object {
public Operation`1<TTo> Convert(Operation`1<TFrom> operation, Func`2<Response, TTo> convertFunc, ClientDiagnostics diagnostics, string scopeName)
public ValueTask`1<Operation`1<VoidValue>> ProcessMessageWithoutResponseValueAsync(HttpPipeline pipeline, HttpMessage message, ClientDiagnostics clientDiagnostics, string scopeName, OperationFinalStateVia finalStateVia, RequestContext requestContext, WaitUntil waitUntil)
public Operation`1<VoidValue> ProcessMessageWithoutResponseValue(HttpPipeline pipeline, HttpMessage message, ClientDiagnostics clientDiagnostics, string scopeName, OperationFinalStateVia finalStateVia, RequestContext requestContext, WaitUntil waitUntil)
public ValueTask`1<Operation`1<BinaryData>> ProcessMessageAsync(HttpPipeline pipeline, HttpMessage message, ClientDiagnostics clientDiagnostics, string scopeName, OperationFinalStateVia finalStateVia, RequestContext requestContext, WaitUntil waitUntil)
public Operation`1<BinaryData> ProcessMessage(HttpPipeline pipeline, HttpMessage message, ClientDiagnostics clientDiagnostics, string scopeName, OperationFinalStateVia finalStateVia, RequestContext requestContext, WaitUntil waitUntil)
public ValueTask`1<Operation`1<T>> ProcessMessageAsync(HttpPipeline pipeline, HttpMessage message, ClientDiagnostics clientDiagnostics, string scopeName, OperationFinalStateVia finalStateVia, RequestContext requestContext, WaitUntil waitUntil, Func`2<Response, T> resultSelector)
public Operation`1<T> ProcessMessage(HttpPipeline pipeline, HttpMessage message, ClientDiagnostics clientDiagnostics, string scopeName, OperationFinalStateVia finalStateVia, RequestContext requestContext, WaitUntil waitUntil, Func`2<Response, T> resultSelector)
}
internal Azure.Core.RawRequestUriBuilder : RequestUriBuilder {
private string SchemeSeparator
private char HostSeparator
private char PortSeparator
private Char[] HostOrPort
private char QueryBeginSeparator
private char QueryContinueSeparator
private char QueryValueSeparator
private Nullable`1<RawWritingPosition> _position
private void GetQueryParts(ReadOnlySpan`1<char> queryUnparsed, ReadOnlySpan`1& name, ReadOnlySpan`1& value)
public void AppendRaw(string value, bool escape)
private void AppendRaw(ReadOnlySpan`1<char> value, bool escape)
public void AppendRawNextLink(string nextLink, bool escape)
}
internal Azure.Core.RequestContentHelper : object {
public RequestContent FromEnumerable(IEnumerable`1<T> enumerable)
public RequestContent FromEnumerable(IEnumerable`1<BinaryData> enumerable)
public RequestContent FromDictionary(IDictionary`2<string, T> dictionary)
public RequestContent FromDictionary(IDictionary`2<string, BinaryData> dictionary)
public RequestContent FromObject(object value)
public RequestContent FromObject(BinaryData value)
}
internal Azure.Core.RequestHeaderExtensions : object {
public void Add(RequestHeaders headers, string name, bool value)
public void Add(RequestHeaders headers, string name, float value)
public void Add(RequestHeaders headers, string name, double value)
public void Add(RequestHeaders headers, string name, int value)
public void Add(RequestHeaders headers, string name, long value)
public void Add(RequestHeaders headers, string name, DateTimeOffset value, string format)
public void Add(RequestHeaders headers, string name, TimeSpan value, string format)
public void Add(RequestHeaders headers, string name, Guid value)
public void Add(RequestHeaders headers, string name, Byte[] value, string format)
public void Add(RequestHeaders headers, string name, BinaryData value, string format)
public void Add(RequestHeaders headers, string prefix, IDictionary`2<string, string> headersToAdd)
public void Add(RequestHeaders headers, string name, ETag value)
public void Add(RequestHeaders headers, MatchConditions conditions)
public void Add(RequestHeaders headers, RequestConditions conditions, string format)
public void AddDelimited(RequestHeaders headers, string name, IEnumerable`1<T> value, string delimiter)
public void AddDelimited(RequestHeaders headers, string name, IEnumerable`1<T> value, string delimiter, string format)
}
internal Azure.Core.RequestUriBuilderExtensions : object {
public void AppendPath(RequestUriBuilder builder, bool value, bool escape)
public void AppendPath(RequestUriBuilder builder, float value, bool escape)
public void AppendPath(RequestUriBuilder builder, double value, bool escape)
public void AppendPath(RequestUriBuilder builder, int value, bool escape)
public void AppendPath(RequestUriBuilder builder, Byte[] value, string format, bool escape)
public void AppendPath(RequestUriBuilder builder, IEnumerable`1<string> value, bool escape)
public void AppendPath(RequestUriBuilder builder, DateTimeOffset value, string format, bool escape)
public void AppendPath(RequestUriBuilder builder, TimeSpan value, string format, bool escape)
public void AppendPath(RequestUriBuilder builder, Guid value, bool escape)
public void AppendPath(RequestUriBuilder builder, long value, bool escape)
public void AppendQuery(RequestUriBuilder builder, string name, bool value, bool escape)
public void AppendQuery(RequestUriBuilder builder, string name, float value, bool escape)
public void AppendQuery(RequestUriBuilder builder, string name, DateTimeOffset value, string format, bool escape)
public void AppendQuery(RequestUriBuilder builder, string name, TimeSpan value, string format, bool escape)
public void AppendQuery(RequestUriBuilder builder, string name, double value, bool escape)
public void AppendQuery(RequestUriBuilder builder, string name, decimal value, bool escape)
public void AppendQuery(RequestUriBuilder builder, string name, int value, bool escape)
public void AppendQuery(RequestUriBuilder builder, string name, long value, bool escape)
public void AppendQuery(RequestUriBuilder builder, string name, TimeSpan value, bool escape)
public void AppendQuery(RequestUriBuilder builder, string name, Byte[] value, string format, bool escape)
public void AppendQuery(RequestUriBuilder builder, string name, Guid value, bool escape)
public void AppendQueryDelimited(RequestUriBuilder builder, string name, IEnumerable`1<T> value, string delimiter, bool escape)
public void AppendQueryDelimited(RequestUriBuilder builder, string name, IEnumerable`1<T> value, string delimiter, string format, bool escape)
}
internal Azure.Core.ResponseHeadersExtensions : object {
private String[] KnownFormats
public bool TryGetValue(ResponseHeaders headers, string name, Byte[]& value)
public bool TryGetValue(ResponseHeaders headers, string name, Nullable`1& value)
public bool TryGetValue(ResponseHeaders headers, string name, Nullable`1& value)
public bool TryGetValue(ResponseHeaders headers, string name, Nullable`1& value)
public bool TryGetValue(ResponseHeaders headers, string name, T& value)
public bool TryGetValue(ResponseHeaders headers, string prefix, IDictionary`2& value)
}
internal Azure.Core.ResponseWithHeaders : object {
public ResponseWithHeaders`2<T, THeaders> FromValue(T value, THeaders headers, Response rawResponse)
public ResponseWithHeaders`1<THeaders> FromValue(THeaders headers, Response rawResponse)
}
internal Azure.Core.ResponseWithHeaders`1 : object {
private Response _rawResponse
private THeaders <Headers>k__BackingField
public THeaders Headers
public void .ctor(THeaders headers, Response rawResponse)
public Response GetRawResponse()
public THeaders get_Headers()
public Response op_Implicit(ResponseWithHeaders`1<THeaders> self)
}
internal Azure.Core.ResponseWithHeaders`2 : Response`1<T> {
private Response _rawResponse
private T <Value>k__BackingField
private THeaders <Headers>k__BackingField
public T Value
public THeaders Headers
public void .ctor(T value, THeaders headers, Response rawResponse)
public Response GetRawResponse()
public T get_Value()
public THeaders get_Headers()
public Response op_Implicit(ResponseWithHeaders`2<T, THeaders> self)
}
internal Azure.Core.SequentialDelayStrategy : DelayStrategy {
private TimeSpan[] _pollingSequence
private TimeSpan _maxDelay
protected TimeSpan GetNextDelayCore(Response response, int retryNumber)
}
internal Azure.Core.StringRequestContent : RequestContent {
private Byte[] _bytes
public void .ctor(string value)
public Task WriteToAsync(Stream stream, CancellationToken cancellation)
public void WriteTo(Stream stream, CancellationToken cancellation)
public bool TryComputeLength(Int64& length)
public void Dispose()
}
internal Azure.Core.TypeFormatters : object {
private string RoundtripZFormat
private string <DefaultNumberFormat>k__BackingField
public string DefaultNumberFormat
public string get_DefaultNumberFormat()
public string ToString(bool value)
public string ToString(DateTime value, string format)
public string ToString(DateTimeOffset value, string format)
public string ToString(TimeSpan value, string format)
public string ToString(Byte[] value, string format)
public string ToBase64UrlString(Byte[] value)
public Byte[] FromBase64UrlString(string value)
private int GetNumBase64PaddingCharsToAddForDecode(int inputLength)
public DateTimeOffset ParseDateTimeOffset(string value, string format)
public TimeSpan ParseTimeSpan(string value, string format)
public string ConvertToString(object value, string format)
}
internal Azure.Core.Utf8JsonRequestContent : RequestContent {
private MemoryStream _stream
private RequestContent _content
private Utf8JsonWriter <JsonWriter>k__BackingField
public Utf8JsonWriter JsonWriter
public Utf8JsonWriter get_JsonWriter()
public Task WriteToAsync(Stream stream, CancellationToken cancellation)
public void WriteTo(Stream stream, CancellationToken cancellation)
public bool TryComputeLength(Int64& length)
public void Dispose()
}
internal Azure.Core.Utf8JsonWriterExtensions : object {
public void WriteStringValue(Utf8JsonWriter writer, DateTimeOffset value, string format)
public void WriteStringValue(Utf8JsonWriter writer, DateTime value, string format)
public void WriteStringValue(Utf8JsonWriter writer, TimeSpan value, string format)
public void WriteStringValue(Utf8JsonWriter writer, char value)
public void WriteNonEmptyArray(Utf8JsonWriter writer, string name, IReadOnlyList`1<string> values)
public void WriteBase64StringValue(Utf8JsonWriter writer, Byte[] value, string format)
public void WriteNumberValue(Utf8JsonWriter writer, DateTimeOffset value, string format)
public void WriteObjectValue(Utf8JsonWriter writer, object value)
}
internal Azure.Core.XElementExtensions : object {
public Byte[] GetBytesFromBase64Value(XElement element, string format)
public DateTimeOffset GetDateTimeOffsetValue(XElement element, string format)
public TimeSpan GetTimeSpanValue(XElement element, string format)
public object GetObjectValue(XElement element, string format)
}
internal Azure.Core.XmlWriterContent : RequestContent {
private MemoryStream _stream
private RequestContent _content
private XmlWriter <XmlWriter>k__BackingField
public XmlWriter XmlWriter
public XmlWriter get_XmlWriter()
public Task WriteToAsync(Stream stream, CancellationToken cancellation)
public void WriteTo(Stream stream, CancellationToken cancellation)
public bool TryComputeLength(Int64& length)
public void Dispose()
}
internal Azure.Core.XmlWriterExtensions : object {
public void WriteObjectValue(XmlWriter writer, object value, string nameHint)
public void WriteValue(XmlWriter writer, DateTimeOffset value, string format)
public void WriteValue(XmlWriter writer, TimeSpan value, string format)
public void WriteValue(XmlWriter writer, Byte[] value, string format)
}
internal Azure.NoBodyResponse`1 : Response`1<T> {
private Response _response
public bool HasValue
public T Value
public void .ctor(Response response)
public bool get_HasValue()
public T get_Value()
public Response GetRawResponse()
public string ToString()
}
internal Azure.Storage.AccountExtensions : object {
internal string ToPermissionsString(AccountSasPermissions permissions)
}
public Azure.Storage.ClientSideEncryptionOptions : object {
private ClientSideEncryptionVersion <EncryptionVersion>k__BackingField
private IKeyEncryptionKey <KeyEncryptionKey>k__BackingField
private IKeyEncryptionKeyResolver <KeyResolver>k__BackingField
private string <KeyWrapAlgorithm>k__BackingField
public ClientSideEncryptionVersion EncryptionVersion
public IKeyEncryptionKey KeyEncryptionKey
public IKeyEncryptionKeyResolver KeyResolver
public string KeyWrapAlgorithm
public ClientSideEncryptionVersion get_EncryptionVersion()
public IKeyEncryptionKey get_KeyEncryptionKey()
public void set_KeyEncryptionKey(IKeyEncryptionKey value)
public IKeyEncryptionKeyResolver get_KeyResolver()
public void set_KeyResolver(IKeyEncryptionKeyResolver value)
public string get_KeyWrapAlgorithm()
public void set_KeyWrapAlgorithm(string value)
public void .ctor(ClientSideEncryptionVersion version)
}
public Azure.Storage.ClientSideEncryptionVersion : Enum {
public int value__
public ClientSideEncryptionVersion V1_0
public ClientSideEncryptionVersion V2_0
}
internal Azure.Storage.Constants : object {
public int KB
public int MB
public int GB
public long TB
public int Base16
public int MaxReliabilityRetries
public int MaxIdleTimeMs
public string DefaultSasVersion
public int MaxHashRequestDownloadRange
public int DefaultBufferSize
public int LargeBufferSize
public int LargeUploadThreshold
public int DefaultStreamingDownloadSize
public int DefaultStreamCopyBufferSize
public int DefaultDownloadCopyBufferSize
public int StorageCrc64SizeInBytes
public int MD5SizeInBytes
public bool DefaultTrimBlobNameSlashes
public string CloseAllHandles
public string Wildcard
public string BlockNameFormat
public string SasTimeFormatSeconds
public string SasTimeFormatSubSeconds
public string SasTimeFormatMinutes
public string SasTimeFormatDays
public string SnapshotParameterName
public string VersionIdParameterName
public string ShareSnapshotParameterName
public string Https
public string Http
public string PercentSign
public string EncodedPercentSign
public string QueryDelimiter
public string PathBackSlashDelimiter
public string FalseName
public string TrueName
public string ErrorCode
public string ErrorMessage
public string CommaString
public char CommaChar
public string ContentTypeApplicationXml
public string ContentTypeApplicationJson
public string ErrorPropertyKey
public string DetailPropertyKey
public string MessagePropertyKey
public string CodePropertyKey
public string Iso8601Format
public string DisableRequestConditionsValidationSwitchName
public string DisableRequestConditionsValidationEnvVar
public string DefaultScope
}
public Azure.Storage.DownloadTransferValidationOptions : object {
private StorageChecksumAlgorithm <ChecksumAlgorithm>k__BackingField
private bool <AutoValidateChecksum>k__BackingField
public StorageChecksumAlgorithm ChecksumAlgorithm
public bool AutoValidateChecksum
public StorageChecksumAlgorithm get_ChecksumAlgorithm()
public void set_ChecksumAlgorithm(StorageChecksumAlgorithm value)
public bool get_AutoValidateChecksum()
public void set_AutoValidateChecksum(bool value)
}
internal Azure.Storage.Errors : object {
public ArgumentException AccountMismatch(string accountNameCredential, string accountNameValue)
public InvalidOperationException AccountSasMissingData()
public ArgumentNullException ArgumentNull(string paramName)
public ArgumentException InvalidArgument(string paramName)
public ArgumentException InvalidResourceType(char s)
public InvalidOperationException TaskIncomplete()
public FormatException InvalidFormat(string err)
public ArgumentException ParsingConnectionStringFailed()
public ArgumentOutOfRangeException InvalidSasProtocol(string protocol, string sasProtocol)
public ArgumentException InvalidService(char s)
public ArgumentException InsufficientStorageTransferOptions(long streamLength, long statedMaxBlockSize, long necessaryMinBlockSize)
public InvalidDataException HashMismatch(string hashHeaderName)
public InvalidDataException ChecksumMismatch(ReadOnlySpan`1<byte> left, ReadOnlySpan`1<byte> right)
public InvalidDataException HashMismatchOnStreamedDownload(string mismatchedRange)
public ArgumentException PrecalculatedHashNotSupportedOnSplit()
public ArgumentException CannotDeferTransactionalHashVerification()
public ArgumentException CannotInitializeWriteStreamWithData()
internal void VerifyStreamPosition(Stream stream, string streamName)
public void ThrowIfParamNull(object obj, string paramName)
internal void CheckCryptKeySize(int keySizeInBytes)
public CryptographicException CryptographyAuthTagMismatch()
public ArgumentException CryptographyPlaintextCiphertextLengthMismatch()
public ArgumentException CryptographyInvalidNonceLength()
public ArgumentException CryptographyInvalidTagLength()
}
internal Azure.Storage.GeoRedundantReadPolicy : HttpPipelineSynchronousPolicy {
private string _secondaryStorageHost
public void .ctor(Uri secondaryStorageUri)
public void OnSendingRequest(HttpMessage message)
}
public Azure.Storage.Sas.AccountSasBuilder : object {
private string <Version>k__BackingField
private SasProtocol <Protocol>k__BackingField
private DateTimeOffset <StartsOn>k__BackingField
private DateTimeOffset <ExpiresOn>k__BackingField
private string <Permissions>k__BackingField
private SasIPRange <IPRange>k__BackingField
private AccountSasServices <Services>k__BackingField
private AccountSasResourceTypes <ResourceTypes>k__BackingField
private string <EncryptionScope>k__BackingField
private List`1<char> s_validPermissionsInOrder
public string Version
public SasProtocol Protocol
public DateTimeOffset StartsOn
public DateTimeOffset ExpiresOn
public string Permissions
public SasIPRange IPRange
public AccountSasServices Services
public AccountSasResourceTypes ResourceTypes
public string EncryptionScope
public string get_Version()
public void set_Version(string value)
public SasProtocol get_Protocol()
public void set_Protocol(SasProtocol value)
public DateTimeOffset get_StartsOn()
public void set_StartsOn(DateTimeOffset value)
public DateTimeOffset get_ExpiresOn()
public void set_ExpiresOn(DateTimeOffset value)
public string get_Permissions()
private void set_Permissions(string value)
public SasIPRange get_IPRange()
public void set_IPRange(SasIPRange value)
public AccountSasServices get_Services()
public void set_Services(AccountSasServices value)
public AccountSasResourceTypes get_ResourceTypes()
public void set_ResourceTypes(AccountSasResourceTypes value)
public string get_EncryptionScope()
public void set_EncryptionScope(string value)
public void .ctor(AccountSasPermissions permissions, DateTimeOffset expiresOn, AccountSasServices services, AccountSasResourceTypes resourceTypes)
public void SetPermissions(AccountSasPermissions permissions)
public void SetPermissions(string rawPermissions)
public SasQueryParameters ToSasQueryParameters(StorageSharedKeyCredential sharedKeyCredential)
public string ToString()
public bool Equals(object obj)
public int GetHashCode()
}
public Azure.Storage.Sas.AccountSasPermissions : Enum {
public int value__
public AccountSasPermissions Read
public AccountSasPermissions Write
public AccountSasPermissions Delete
public AccountSasPermissions List
public AccountSasPermissions Add
public AccountSasPermissions Create
public AccountSasPermissions Update
public AccountSasPermissions Process
public AccountSasPermissions Tag
public AccountSasPermissions Filter
public AccountSasPermissions DeleteVersion
public AccountSasPermissions SetImmutabilityPolicy
public AccountSasPermissions PermanentDelete
public AccountSasPermissions All
}
public Azure.Storage.Sas.AccountSasResourceTypes : Enum {
public int value__
public AccountSasResourceTypes Service
public AccountSasResourceTypes Container
public AccountSasResourceTypes Object
public AccountSasResourceTypes All
}
public Azure.Storage.Sas.AccountSasServices : Enum {
public int value__
public AccountSasServices Blobs
public AccountSasServices Queues
public AccountSasServices Files
public AccountSasServices Tables
public AccountSasServices All
}
internal Azure.Storage.Sas.SasExtensions : object {
private string NoneName
private string HttpsName
private string HttpsAndHttpName
internal string ToPermissionsString(AccountSasResourceTypes resourceTypes)
internal AccountSasResourceTypes ParseResourceTypes(string s)
internal string ToProtocolString(SasProtocol protocol)
public SasProtocol ParseProtocol(string s)
internal string ToPermissionsString(AccountSasServices services)
internal AccountSasServices ParseAccountServices(string s)
internal string FormatTimesForSasSigning(DateTimeOffset time)
internal void AddToBuilder(StringBuilder sb, string key, string value)
internal string ValidateAndSanitizeRawPermissions(string permissions, List`1<char> validPermissionsInOrder)
}
public Azure.Storage.Sas.SasIPRange : ValueType {
private IPAddress <Start>k__BackingField
private IPAddress <End>k__BackingField
public IPAddress Start
public IPAddress End
public IPAddress get_Start()
public IPAddress get_End()
public void .ctor(IPAddress start, IPAddress end)
private bool IsEmpty(IPAddress address)
public string ToString()
public SasIPRange Parse(string s)
public bool Equals(object obj)
public int GetHashCode()
public bool op_Equality(SasIPRange left, SasIPRange right)
public bool op_Inequality(SasIPRange left, SasIPRange right)
public bool Equals(SasIPRange other)
}
public Azure.Storage.Sas.SasProtocol : Enum {
public int value__
public SasProtocol None
public SasProtocol HttpsAndHttp
public SasProtocol Https
}
public Azure.Storage.Sas.SasQueryParameters : object {
public string DefaultSasVersion
private string _version
private ValueTuple`2<Nullable`1<AccountSasServices>, string> _services
private ValueTuple`2<Nullable`1<AccountSasResourceTypes>, string> _resourceTypes
private SasProtocol _protocol
private DateTimeOffset _startTime
private string _startTimeString
private DateTimeOffset _expiryTime
private string _expiryTimeString
private SasIPRange _ipRange
private string _identifier
private string _resource
private string _permissions
private string _signature
private string _preauthorizedAgentObjectId
private string _agentObjectId
private string _correlationId
private Nullable`1<int> _directoryDepth
private string _encryptionScope
private string _cacheControl
private string _contentDisposition
private string _contentEncoding
private string _contentLanguage
private string _contentType
private String[] s_sasTimeFormats
public string Version
public Nullable`1<AccountSasServices> Services
public Nullable`1<AccountSasResourceTypes> ResourceTypes
public SasProtocol Protocol
public DateTimeOffset StartsOn
internal string StartsOnString
public DateTimeOffset ExpiresOn
internal string ExpiresOnString
public SasIPRange IPRange
public string Identifier
public string Resource
public string Permissions
public string CacheControl
public string ContentDisposition
public string ContentEncoding
public string ContentLanguage
public string ContentType
public string PreauthorizedAgentObjectId
public string AgentObjectId
public string CorrelationId
public Nullable`1<int> DirectoryDepth
public string EncryptionScope
public string Signature
public SasQueryParameters Empty
public string get_Version()
public Nullable`1<AccountSasServices> get_Services()
public Nullable`1<AccountSasResourceTypes> get_ResourceTypes()
public SasProtocol get_Protocol()
public DateTimeOffset get_StartsOn()
internal string get_StartsOnString()
public DateTimeOffset get_ExpiresOn()
internal string get_ExpiresOnString()
public SasIPRange get_IPRange()
public string get_Identifier()
public string get_Resource()
public string get_Permissions()
public string get_CacheControl()
public string get_ContentDisposition()
public string get_ContentEncoding()
public string get_ContentLanguage()
public string get_ContentType()
public string get_PreauthorizedAgentObjectId()
public string get_AgentObjectId()
public string get_CorrelationId()
public Nullable`1<int> get_DirectoryDepth()
public string get_EncryptionScope()
public string get_Signature()
public SasQueryParameters get_Empty()
protected void .ctor(IDictionary`2<string, string> values)
protected void .ctor(string version, Nullable`1<AccountSasServices> services, Nullable`1<AccountSasResourceTypes> resourceTypes, SasProtocol protocol, DateTimeOffset startsOn, DateTimeOffset expiresOn, SasIPRange ipRange, string identifier, string resource, string permissions, string signature, string cacheControl, string contentDisposition, string contentEncoding, string contentLanguage, string contentType, string authorizedAadObjectId, string unauthorizedAadObjectId, string correlationId, Nullable`1<int> directoryDepth, string encryptionScope)
protected void .ctor(string version, Nullable`1<AccountSasServices> services, Nullable`1<AccountSasResourceTypes> resourceTypes, SasProtocol protocol, DateTimeOffset startsOn, DateTimeOffset expiresOn, SasIPRange ipRange, string identifier, string resource, string permissions, string signature, string cacheControl, string contentDisposition, string contentEncoding, string contentLanguage, string contentType)
protected void .ctor(string version, Nullable`1<AccountSasServices> services, Nullable`1<AccountSasResourceTypes> resourceTypes, SasProtocol protocol, DateTimeOffset startsOn, DateTimeOffset expiresOn, SasIPRange ipRange, string identifier, string resource, string permissions, string signature, string cacheControl, string contentDisposition, string contentEncoding, string contentLanguage, string contentType, string authorizedAadObjectId, string unauthorizedAadObjectId, string correlationId, Nullable`1<int> directoryDepth)
protected SasQueryParameters Create(IDictionary`2<string, string> values)
protected SasQueryParameters Create(string version, Nullable`1<AccountSasServices> services, Nullable`1<AccountSasResourceTypes> resourceTypes, SasProtocol protocol, DateTimeOffset startsOn, DateTimeOffset expiresOn, SasIPRange ipRange, string identifier, string resource, string permissions, string signature, string cacheControl, string contentDisposition, string contentEncoding, string contentLanguage, string contentType, string authorizedAadObjectId, string unauthorizedAadObjectId, string correlationId, Nullable`1<int> directoryDepth, string encryptionScope)
protected SasQueryParameters Create(string version, Nullable`1<AccountSasServices> services, Nullable`1<AccountSasResourceTypes> resourceTypes, SasProtocol protocol, DateTimeOffset startsOn, DateTimeOffset expiresOn, SasIPRange ipRange, string identifier, string resource, string permissions, string signature, string cacheControl, string contentDisposition, string contentEncoding, string contentLanguage, string contentType)
protected SasQueryParameters Create(string version, Nullable`1<AccountSasServices> services, Nullable`1<AccountSasResourceTypes> resourceTypes, SasProtocol protocol, DateTimeOffset startsOn, DateTimeOffset expiresOn, SasIPRange ipRange, string identifier, string resource, string permissions, string signature, string cacheControl, string contentDisposition, string contentEncoding, string contentLanguage, string contentType, string authorizedAadObjectId, string unauthorizedAadObjectId, string correlationId, Nullable`1<int> directoryDepth)
public string ToString()
protected internal void AppendProperties(StringBuilder stringBuilder)
private DateTimeOffset ParseSasTime(string dateTimeString)
}
internal Azure.Storage.Sas.SasQueryParametersInternals : SasQueryParameters {
private string <DefaultSasVersionInternal>k__BackingField
internal string DefaultSasVersionInternal
internal string get_DefaultSasVersionInternal()
internal void set_DefaultSasVersionInternal(string value)
internal SasQueryParameters Create(IDictionary`2<string, string> values)
internal SasQueryParameters Create(string version, Nullable`1<AccountSasServices> services, Nullable`1<AccountSasResourceTypes> resourceTypes, SasProtocol protocol, DateTimeOffset startsOn, DateTimeOffset expiresOn, SasIPRange ipRange, string identifier, string resource, string permissions, string signature, string cacheControl, string contentDisposition, string contentEncoding, string contentLanguage, string contentType, string authorizedAadObjectId, string unauthorizedAadObjectId, string correlationId, Nullable`1<int> directoryDepth, string encryptionScope)
}
internal Azure.Storage.Shared.ISupportsTenantIdChallenges {
public bool EnableTenantDiscovery
public bool get_EnableTenantDiscovery()
}
internal Azure.Storage.SharedAccessSignatureCredentials : object {
private string <SasToken>k__BackingField
public string SasToken
public string get_SasToken()
public void .ctor(string sasToken)
}
internal Azure.Storage.StorageBearerTokenChallengeAuthorizationPolicy : BearerTokenAuthenticationPolicy {
private String[] modreq(System.Runtime.CompilerServices.IsVolatile) _scopes
private String modreq(System.Runtime.CompilerServices.IsVolatile) tenantId
private bool _enableTenantDiscovery
public void .ctor(TokenCredential credential, string scope, bool enableTenantDiscovery)
public void .ctor(TokenCredential credential, IEnumerable`1<string> scopes, bool enableTenantDiscovery)
protected void AuthorizeRequest(HttpMessage message)
protected ValueTask AuthorizeRequestAsync(HttpMessage message)
private ValueTask AuthorizeRequestInternal(HttpMessage message, bool async)
protected bool AuthorizeRequestOnChallenge(HttpMessage message)
protected ValueTask`1<bool> AuthorizeRequestOnChallengeAsync(HttpMessage message)
private ValueTask`1<bool> AuthorizeRequestOnChallengeInternalAsync(HttpMessage message, bool async)
}
public Azure.Storage.StorageChecksumAlgorithm : Enum {
public int value__
public StorageChecksumAlgorithm Auto
public StorageChecksumAlgorithm None
public StorageChecksumAlgorithm MD5
public StorageChecksumAlgorithm StorageCrc64
}
internal Azure.Storage.StorageConnectionString : object {
private KeyValuePair`2<string, Func`2<string, bool>> s_useDevelopmentStorageSetting
private KeyValuePair`2<string, Func`2<string, bool>> s_developmentStorageProxyUriSetting
private KeyValuePair`2<string, Func`2<string, bool>> s_defaultEndpointsProtocolSetting
private KeyValuePair`2<string, Func`2<string, bool>> s_accountNameSetting
private KeyValuePair`2<string, Func`2<string, bool>> s_accountKeyNameSetting
private KeyValuePair`2<string, Func`2<string, bool>> s_accountKeySetting
private KeyValuePair`2<string, Func`2<string, bool>> s_blobEndpointSetting
private KeyValuePair`2<string, Func`2<string, bool>> s_queueEndpointSetting
private KeyValuePair`2<string, Func`2<string, bool>> s_fileEndpointSetting
private KeyValuePair`2<string, Func`2<string, bool>> s_tableEndpointSetting
private KeyValuePair`2<string, Func`2<string, bool>> s_blobSecondaryEndpointSetting
private KeyValuePair`2<string, Func`2<string, bool>> s_queueSecondaryEndpointSetting
private KeyValuePair`2<string, Func`2<string, bool>> s_fileSecondaryEndpointSetting
private KeyValuePair`2<string, Func`2<string, bool>> s_tableSecondaryEndpointSetting
private KeyValuePair`2<string, Func`2<string, bool>> s_endpointSuffixSetting
private KeyValuePair`2<string, Func`2<string, bool>> s_sharedAccessSignatureSetting
private StorageConnectionString s_devStoreAccount
private bool <IsDevStoreAccount>k__BackingField
private string <EndpointSuffix>k__BackingField
private IDictionary`2<string, string> <Settings>k__BackingField
private bool <DefaultEndpoints>k__BackingField
private ValueTuple`2<Uri, Uri> <BlobStorageUri>k__BackingField
private ValueTuple`2<Uri, Uri> <QueueStorageUri>k__BackingField
private ValueTuple`2<Uri, Uri> <TableStorageUri>k__BackingField
private ValueTuple`2<Uri, Uri> <FileStorageUri>k__BackingField
private object <Credentials>k__BackingField
internal string _accountName
private Func`2<IDictionary`2<string, string>, IDictionary`2<string, string>> s_validCredentials
internal bool UseV1MD5
public StorageConnectionString DevelopmentStorageAccount
internal bool IsDevStoreAccount
internal string EndpointSuffix
internal IDictionary`2<string, string> Settings
internal bool DefaultEndpoints
public Uri BlobEndpoint
public Uri QueueEndpoint
public Uri TableEndpoint
public Uri FileEndpoint
public ValueTuple`2<Uri, Uri> BlobStorageUri
public ValueTuple`2<Uri, Uri> QueueStorageUri
public ValueTuple`2<Uri, Uri> TableStorageUri
public ValueTuple`2<Uri, Uri> FileStorageUri
public object Credentials
internal bool get_UseV1MD5()
public void .ctor(object storageCredentials, ValueTuple`2<Uri, Uri> blobStorageUri, ValueTuple`2<Uri, Uri> queueStorageUri, ValueTuple`2<Uri, Uri> tableStorageUri, ValueTuple`2<Uri, Uri> fileStorageUri)
public StorageConnectionString get_DevelopmentStorageAccount()
internal bool get_IsDevStoreAccount()
internal void set_IsDevStoreAccount(bool value)
internal string get_EndpointSuffix()
internal void set_EndpointSuffix(string value)
internal IDictionary`2<string, string> get_Settings()
internal void set_Settings(IDictionary`2<string, string> value)
internal bool get_DefaultEndpoints()
internal void set_DefaultEndpoints(bool value)
public Uri get_BlobEndpoint()
public Uri get_QueueEndpoint()
public Uri get_TableEndpoint()
public Uri get_FileEndpoint()
public ValueTuple`2<Uri, Uri> get_BlobStorageUri()
public void set_BlobStorageUri(ValueTuple`2<Uri, Uri> value)
public ValueTuple`2<Uri, Uri> get_QueueStorageUri()
public void set_QueueStorageUri(ValueTuple`2<Uri, Uri> value)
public ValueTuple`2<Uri, Uri> get_TableStorageUri()
public void set_TableStorageUri(ValueTuple`2<Uri, Uri> value)
public ValueTuple`2<Uri, Uri> get_FileStorageUri()
public void set_FileStorageUri(ValueTuple`2<Uri, Uri> value)
public object get_Credentials()
public void set_Credentials(object value)
public StorageConnectionString Parse(string connectionString)
public bool TryParse(string connectionString, StorageConnectionString& account)
private StorageConnectionString GetDevelopmentStorageAccount(Uri proxyUri)
internal bool ParseCore(string connectionString, StorageConnectionString& accountInformation, Action`1<string> error)
private IDictionary`2<string, string> ParseStringIntoSettings(string connectionString, Action`1<string> error)
private KeyValuePair`2<string, Func`2<string, bool>> Setting(string name, String[] validValues)
private KeyValuePair`2<string, Func`2<string, bool>> Setting(string name, Func`2<string, bool> isValid)
private bool IsValidBase64String(string settingValue)
private bool IsValidUri(string settingValue)
private bool IsValidDomain(string settingValue)
private Func`2<IDictionary`2<string, string>, IDictionary`2<string, string>> AllRequired(KeyValuePair`2[] requiredSettings)
private Func`2<IDictionary`2<string, string>, IDictionary`2<string, string>> Optional(KeyValuePair`2[] optionalSettings)
private Func`2<IDictionary`2<string, string>, IDictionary`2<string, string>> AtLeastOne(KeyValuePair`2[] atLeastOneSettings)
private Func`2<IDictionary`2<string, string>, IDictionary`2<string, string>> None(KeyValuePair`2[] atLeastOneSettings)
private Func`2<IDictionary`2<string, string>, IDictionary`2<string, string>> MatchesAll(Func`2[] filters)
private Func`2<IDictionary`2<string, string>, IDictionary`2<string, string>> MatchesOne(Func`2[] filters)
private Func`2<IDictionary`2<string, string>, IDictionary`2<string, string>> MatchesExactly(Func`2<IDictionary`2<string, string>, IDictionary`2<string, string>> filter)
private bool MatchesSpecification(IDictionary`2<string, string> settings, Func`2[] constraints)
private object GetCredentials(IDictionary`2<string, string> settings)
private ValueTuple`2<Uri, Uri> ConstructBlobEndpoint(IDictionary`2<string, string> settings)
internal ValueTuple`2<Uri, Uri> ConstructBlobEndpoint(string scheme, string accountName, string endpointSuffix, string sasToken)
private ValueTuple`2<Uri, Uri> ConstructFileEndpoint(IDictionary`2<string, string> settings)
internal ValueTuple`2<Uri, Uri> ConstructFileEndpoint(string scheme, string accountName, string endpointSuffix, string sasToken)
private ValueTuple`2<Uri, Uri> ConstructQueueEndpoint(IDictionary`2<string, string> settings)
internal ValueTuple`2<Uri, Uri> ConstructQueueEndpoint(string scheme, string accountName, string endpointSuffix, string sasToken)
private ValueTuple`2<Uri, Uri> ConstructTableEndpoint(IDictionary`2<string, string> settings)
internal ValueTuple`2<Uri, Uri> ConstructTableEndpoint(string scheme, string accountName, string endpointSuffix, string sasToken)
private ValueTuple`2<Uri, Uri> ConstructUris(string scheme, string accountName, string hostNamePrefix, string endpointSuffix, string sasToken)
internal string <ParseCore>g__settingOrDefault|70_0(string key, <>c__DisplayClass70_0& )
internal bool <ParseCore>g__s_isValidEndpointPair|70_1(string primary, string secondary)
internal ValueTuple`2<Uri, Uri> <ParseCore>g__createStorageUri|70_2(string primary, string secondary, string sasToken, Func`2<IDictionary`2<string, string>, ValueTuple`2<Uri, Uri>> factory, <>c__DisplayClass70_0& )
internal Uri <ParseCore>g__CreateUri|70_3(string endpoint, string sasToken)
}
internal Azure.Storage.StorageCrc64Calculator : object {
private ulong poly
private UInt64[] m_u1
private UInt64[] m_u32
private UInt64[] m_uX2N
private ulong m_uComplement
private int m_uBitWidth
public ulong ComputeSlicedSafe(ReadOnlySpan`1<byte> src, ulong uCrc)
internal ulong Concatenate(ulong uInitialCrcAB, ulong uInitialCrcA, ulong uFinalCrcA, ulong uSizeA, ulong uInitialCrcB, ulong uFinalCrcB, ulong uSizeB)
private ulong MulX_N(ulong a, ulong uSize)
private ulong MulPoly(ulong a, ulong b)
private ulong MulPolyUnrolled(ulong a, ulong b)
}
internal Azure.Storage.StorageCrc64Composer : object {
public Memory`1<byte> Compose(ValueTuple`2[] partitions)
public Memory`1<byte> Compose(IEnumerable`1<ValueTuple`2<Byte[], long>> partitions)
public ulong Compose(IEnumerable`1<ValueTuple`2<ulong, long>> partitions)
}
public Azure.Storage.StorageCrc64HashAlgorithm : NonCryptographicHashAlgorithm {
private ulong _uCRC
private int _hashSizeBytes
private void .ctor(ulong uCrc)
public StorageCrc64HashAlgorithm Create()
public void Reset()
public void Append(ReadOnlySpan`1<byte> source)
protected void GetCurrentHashCore(Span`1<byte> destination)
}
internal Azure.Storage.StorageExceptionExtensions : object {
public string GetErrorCode(Response response, string errorCode)
public bool IsUnavailable(Response`1<T> response)
public Response`1<T> AsNoBodyResponse(Response rawResponse)
}
public Azure.Storage.StorageExtensions : object {
public IDisposable CreateServiceTimeoutScope(Nullable`1<TimeSpan> timeout)
}
internal Azure.Storage.StorageResponseClassifier : ResponseClassifier {
private Uri <SecondaryStorageUri>k__BackingField
public Uri SecondaryStorageUri
public Uri get_SecondaryStorageUri()
public void set_SecondaryStorageUri(Uri value)
public bool IsRetriableResponse(HttpMessage message)
public bool IsErrorResponse(HttpMessage message)
}
public Azure.Storage.StorageSharedKeyCredential : object {
private string <AccountName>k__BackingField
private Byte[] _accountKeyValue
public string AccountName
private Byte[] AccountKeyValue
public string get_AccountName()
private Byte[] get_AccountKeyValue()
private void set_AccountKeyValue(Byte[] value)
public void .ctor(string accountName, string accountKey)
public void SetAccountKey(string accountKey)
internal string ComputeHMACSHA256(string message)
protected string ComputeSasSignature(StorageSharedKeyCredential credential, string message)
}
internal Azure.Storage.StorageSharedKeyCredentialInternals : StorageSharedKeyCredential {
private void .ctor(string accountName, string accountKey)
internal string ComputeSasSignature(StorageSharedKeyCredential credential, string message)
}
internal Azure.Storage.StorageSharedKeyPipelinePolicy : HttpPipelineSynchronousPolicy {
private bool IncludeXMsDate
private StorageSharedKeyCredential _credentials
public void .ctor(StorageSharedKeyCredential credentials)
public void OnSendingRequest(HttpMessage message)
private string BuildStringToSign(HttpMessage message)
private void BuildCanonicalizedHeaders(StringBuilder stringBuilder, HttpMessage message)
private void BuildCanonicalizedResource(StringBuilder stringBuilder, Uri resource)
}
public Azure.Storage.StorageTransferOptions : ValueType {
private Nullable`1<long> <MaximumTransferSize>k__BackingField
private Nullable`1<int> <MaximumConcurrency>k__BackingField
private Nullable`1<long> <InitialTransferSize>k__BackingField
public Nullable`1<int> MaximumTransferLength
public Nullable`1<long> MaximumTransferSize
public Nullable`1<int> MaximumConcurrency
public Nullable`1<int> InitialTransferLength
public Nullable`1<long> InitialTransferSize
public Nullable`1<int> get_MaximumTransferLength()
public void set_MaximumTransferLength(Nullable`1<int> value)
public Nullable`1<long> get_MaximumTransferSize()
public void set_MaximumTransferSize(Nullable`1<long> value)
public Nullable`1<int> get_MaximumConcurrency()
public void set_MaximumConcurrency(Nullable`1<int> value)
public Nullable`1<int> get_InitialTransferLength()
public void set_InitialTransferLength(Nullable`1<int> value)
public Nullable`1<long> get_InitialTransferSize()
public void set_InitialTransferSize(Nullable`1<long> value)
public bool Equals(object obj)
public int GetHashCode()
public bool op_Equality(StorageTransferOptions left, StorageTransferOptions right)
public bool op_Inequality(StorageTransferOptions left, StorageTransferOptions right)
public bool Equals(StorageTransferOptions obj)
}
public Azure.Storage.TransferValidationOptions : object {
private UploadTransferValidationOptions <Upload>k__BackingField
private DownloadTransferValidationOptions <Download>k__BackingField
public UploadTransferValidationOptions Upload
public DownloadTransferValidationOptions Download
public UploadTransferValidationOptions get_Upload()
public DownloadTransferValidationOptions get_Download()
}
internal Azure.Storage.TransferValidationOptionsExtensions : object {
public StorageChecksumAlgorithm ResolveAuto(StorageChecksumAlgorithm checksumAlgorithm)
public UploadTransferValidationOptions ToValidationOptions(Byte[] md5)
public DownloadTransferValidationOptions ToValidationOptions(bool requestTransactionalMD5)
public void CopyTo(TransferValidationOptions source, TransferValidationOptions dest)
public void CopyTo(UploadTransferValidationOptions source, UploadTransferValidationOptions dest)
public void CopyTo(DownloadTransferValidationOptions source, DownloadTransferValidationOptions dest)
}
public Azure.Storage.UploadTransferValidationOptions : object {
private StorageChecksumAlgorithm <ChecksumAlgorithm>k__BackingField
private ReadOnlyMemory`1<byte> <PrecalculatedChecksum>k__BackingField
public StorageChecksumAlgorithm ChecksumAlgorithm
public ReadOnlyMemory`1<byte> PrecalculatedChecksum
public StorageChecksumAlgorithm get_ChecksumAlgorithm()
public void set_ChecksumAlgorithm(StorageChecksumAlgorithm value)
public ReadOnlyMemory`1<byte> get_PrecalculatedChecksum()
public void set_PrecalculatedChecksum(ReadOnlyMemory`1<byte> value)
}
internal Azure.Storage.UriExtensions : object {
public Uri AppendToPath(Uri uri, string segment)
public IDictionary`2<string, string> GetQueryParameters(Uri uri)
public string GetAccountNameFromDomain(Uri uri, string serviceSubDomain)
public string GetAccountNameFromDomain(string host, string serviceSubDomain)
public string GetPath(Uri uri)
public bool IsHostIPEndPointStyle(Uri uri)
internal void AppendQueryParameter(StringBuilder sb, string key, string value)
}
internal Azure.Storage.UriQueryParamsCollection : Dictionary`2<string, string> {
public void .ctor(string encodedQueryParamString)
public string ToString()
}
internal System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembersAttribute : Attribute {
private DynamicallyAccessedMemberTypes <MemberTypes>k__BackingField
public DynamicallyAccessedMemberTypes MemberTypes
public void .ctor(DynamicallyAccessedMemberTypes memberTypes)
public DynamicallyAccessedMemberTypes get_MemberTypes()
}
internal System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes : Enum {
public int value__
public DynamicallyAccessedMemberTypes None
public DynamicallyAccessedMemberTypes PublicParameterlessConstructor
public DynamicallyAccessedMemberTypes PublicConstructors
public DynamicallyAccessedMemberTypes NonPublicConstructors
public DynamicallyAccessedMemberTypes PublicMethods
public DynamicallyAccessedMemberTypes NonPublicMethods
public DynamicallyAccessedMemberTypes PublicFields
public DynamicallyAccessedMemberTypes NonPublicFields
public DynamicallyAccessedMemberTypes PublicNestedTypes
public DynamicallyAccessedMemberTypes NonPublicNestedTypes
public DynamicallyAccessedMemberTypes PublicProperties
public DynamicallyAccessedMemberTypes NonPublicProperties
public DynamicallyAccessedMemberTypes PublicEvents
public DynamicallyAccessedMemberTypes NonPublicEvents
public DynamicallyAccessedMemberTypes Interfaces
public DynamicallyAccessedMemberTypes All
}
internal System.Diagnostics.CodeAnalysis.DynamicDependencyAttribute : Attribute {
private string <MemberSignature>k__BackingField
private DynamicallyAccessedMemberTypes <MemberTypes>k__BackingField
private Type <Type>k__BackingField
private string <TypeName>k__BackingField
private string <AssemblyName>k__BackingField
private string <Condition>k__BackingField
public string MemberSignature
public DynamicallyAccessedMemberTypes MemberTypes
public Type Type
public string TypeName
public string AssemblyName
public string Condition
public void .ctor(string memberSignature)
public void .ctor(string memberSignature, Type type)
public void .ctor(string memberSignature, string typeName, string assemblyName)
public void .ctor(DynamicallyAccessedMemberTypes memberTypes, Type type)
public void .ctor(DynamicallyAccessedMemberTypes memberTypes, string typeName, string assemblyName)
public string get_MemberSignature()
public DynamicallyAccessedMemberTypes get_MemberTypes()
public Type get_Type()
public string get_TypeName()
public string get_AssemblyName()
public string get_Condition()
public void set_Condition(string value)
}
internal System.Diagnostics.CodeAnalysis.RequiresDynamicCodeAttribute : Attribute {
private string <Message>k__BackingField
private string <Url>k__BackingField
public string Message
public string Url
public void .ctor(string message)
public string get_Message()
public string get_Url()
public void set_Url(string value)
}
internal System.Diagnostics.CodeAnalysis.RequiresUnreferencedCodeAttribute : Attribute {
private string <Message>k__BackingField
private string <Url>k__BackingField
public string Message
public string Url
public void .ctor(string message)
public string get_Message()
public string get_Url()
public void set_Url(string value)
}
internal System.Diagnostics.CodeAnalysis.UnconditionalSuppressMessageAttribute : Attribute {
private string <Category>k__BackingField
private string <CheckId>k__BackingField
private string <Scope>k__BackingField
private string <Target>k__BackingField
private string <MessageId>k__BackingField
private string <Justification>k__BackingField
public string Category
public string CheckId
public string Scope
public string Target
public string MessageId
public string Justification
public void .ctor(string category, string checkId)
public string get_Category()
public string get_CheckId()
public string get_Scope()
public void set_Scope(string value)
public string get_Target()
public void set_Target(string value)
public string get_MessageId()
public void set_MessageId(string value)
public string get_Justification()
public void set_Justification(string value)
}
internal System.Runtime.CompilerServices.NullableAttribute : Attribute {
public Byte[] NullableFlags
public void .ctor(byte )
public void .ctor(Byte[] )
}
internal System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
public byte Flag
public void .ctor(byte )
}
internal System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
public int Version
public void .ctor(int )
}
