internal static class AssemblyRef : object {
    internal static string SystemConfiguration;
    internal static string System;
    public static string EcmaPublicKey;
    public static string FrameworkPublicKeyFull;
    public static string FrameworkPublicKeyFull2;
    public static string MicrosoftPublicKey;
    public static string MicrosoftJScript;
    public static string MicrosoftVSDesigner;
    public static string SystemData;
    public static string SystemDesign;
    public static string SystemDrawing;
    public static string SystemWeb;
    public static string SystemWebExtensions;
    public static string SystemWindowsForms;
}
internal static class Consts : object {
    public static string MonoCorlibVersion;
    public static string MonoVersion;
    public static string MonoCompany;
    public static string MonoProduct;
    public static string MonoCopyright;
    public static string FxVersion;
    public static string FxFileVersion;
    public static string EnvironmentVersion;
    public static string VsVersion;
    public static string VsFileVersion;
    private static string PublicKeyToken;
    public static string AssemblyI18N;
    public static string AssemblyMicrosoft_JScript;
    public static string AssemblyMicrosoft_VisualStudio;
    public static string AssemblyMicrosoft_VisualStudio_Web;
    public static string AssemblyMicrosoft_VSDesigner;
    public static string AssemblyMono_Http;
    public static string AssemblyMono_Posix;
    public static string AssemblyMono_Security;
    public static string AssemblyMono_Messaging_RabbitMQ;
    public static string AssemblyCorlib;
    public static string AssemblySystem;
    public static string AssemblySystem_Data;
    public static string AssemblySystem_Design;
    public static string AssemblySystem_DirectoryServices;
    public static string AssemblySystem_Drawing;
    public static string AssemblySystem_Drawing_Design;
    public static string AssemblySystem_Messaging;
    public static string AssemblySystem_Security;
    public static string AssemblySystem_ServiceProcess;
    public static string AssemblySystem_Web;
    public static string AssemblySystem_Windows_Forms;
    public static string AssemblySystem_2_0;
    public static string AssemblySystemCore_3_5;
    public static string AssemblySystem_Core;
    public static string WindowsBase_3_0;
    public static string AssemblyWindowsBase;
    public static string AssemblyPresentationCore_3_5;
    public static string AssemblyPresentationCore_4_0;
    public static string AssemblyPresentationFramework_3_5;
    public static string AssemblySystemServiceModel_3_0;
}
internal class Locale : object {
    public static string GetText(string msg);
    public static string GetText(string fmt, Object[] args);
}
public class Mono.Math.BigInteger : object {
    private UInt32 length;
    private UInt32[] data;
    private static UInt32 DEFAULT_LEN;
    internal static UInt32[] smallPrimes;
    private static string WouldReturnNegVal;
    private static RandomNumberGenerator rng;
    private static RandomNumberGenerator Rng { get; }
    [CLSCompliantAttribute("False")]
public BigInteger(Sign sign, UInt32 len);
    public BigInteger(BigInteger bi);
    [CLSCompliantAttribute("False")]
public BigInteger(BigInteger bi, UInt32 len);
    public BigInteger(Byte[] inData);
    [CLSCompliantAttribute("False")]
public BigInteger(UInt32[] inData);
    [CLSCompliantAttribute("False")]
public BigInteger(UInt32 ui);
    [CLSCompliantAttribute("False")]
public BigInteger(ulong ul);
    private static BigInteger();
    [CLSCompliantAttribute("False")]
public static BigInteger op_Implicit(UInt32 value);
    public static BigInteger op_Implicit(int value);
    [CLSCompliantAttribute("False")]
public static BigInteger op_Implicit(ulong value);
    public static BigInteger Parse(string number);
    public static BigInteger op_Addition(BigInteger bi1, BigInteger bi2);
    public static BigInteger op_Subtraction(BigInteger bi1, BigInteger bi2);
    public static int op_Modulus(BigInteger bi, int i);
    [CLSCompliantAttribute("False")]
public static UInt32 op_Modulus(BigInteger bi, UInt32 ui);
    public static BigInteger op_Modulus(BigInteger bi1, BigInteger bi2);
    public static BigInteger op_Division(BigInteger bi, int i);
    public static BigInteger op_Division(BigInteger bi1, BigInteger bi2);
    public static BigInteger op_Multiply(BigInteger bi1, BigInteger bi2);
    public static BigInteger op_Multiply(BigInteger bi, int i);
    public static BigInteger op_LeftShift(BigInteger bi1, int shiftVal);
    public static BigInteger op_RightShift(BigInteger bi1, int shiftVal);
    public static BigInteger Add(BigInteger bi1, BigInteger bi2);
    public static BigInteger Subtract(BigInteger bi1, BigInteger bi2);
    public static int Modulus(BigInteger bi, int i);
    [CLSCompliantAttribute("False")]
public static UInt32 Modulus(BigInteger bi, UInt32 ui);
    public static BigInteger Modulus(BigInteger bi1, BigInteger bi2);
    public static BigInteger Divid(BigInteger bi, int i);
    public static BigInteger Divid(BigInteger bi1, BigInteger bi2);
    public static BigInteger Multiply(BigInteger bi1, BigInteger bi2);
    public static BigInteger Multiply(BigInteger bi, int i);
    private static RandomNumberGenerator get_Rng();
    public static BigInteger GenerateRandom(int bits, RandomNumberGenerator rng);
    public static BigInteger GenerateRandom(int bits);
    public void Randomize(RandomNumberGenerator rng);
    public void Randomize();
    public int BitCount();
    [CLSCompliantAttribute("False")]
public bool TestBit(UInt32 bitNum);
    public bool TestBit(int bitNum);
    [CLSCompliantAttribute("False")]
public void SetBit(UInt32 bitNum);
    [CLSCompliantAttribute("False")]
public void ClearBit(UInt32 bitNum);
    [CLSCompliantAttribute("False")]
public void SetBit(UInt32 bitNum, bool value);
    public int LowestSetBit();
    public Byte[] GetBytes();
    [CLSCompliantAttribute("False")]
public static bool op_Equality(BigInteger bi1, UInt32 ui);
    [CLSCompliantAttribute("False")]
public static bool op_Inequality(BigInteger bi1, UInt32 ui);
    public static bool op_Equality(BigInteger bi1, BigInteger bi2);
    public static bool op_Inequality(BigInteger bi1, BigInteger bi2);
    public static bool op_GreaterThan(BigInteger bi1, BigInteger bi2);
    public static bool op_LessThan(BigInteger bi1, BigInteger bi2);
    public static bool op_GreaterThanOrEqual(BigInteger bi1, BigInteger bi2);
    public static bool op_LessThanOrEqual(BigInteger bi1, BigInteger bi2);
    public Sign Compare(BigInteger bi);
    [CLSCompliantAttribute("False")]
public string ToString(UInt32 radix);
    [CLSCompliantAttribute("False")]
public string ToString(UInt32 radix, string characterSet);
    private void Normalize();
    public void Clear();
    public virtual int GetHashCode();
    public virtual string ToString();
    public virtual bool Equals(object o);
    public BigInteger GCD(BigInteger bi);
    public BigInteger ModInverse(BigInteger modulus);
    public BigInteger ModPow(BigInteger exp, BigInteger n);
    public bool IsProbablePrime();
    public static BigInteger NextHighestPrime(BigInteger bi);
    public static BigInteger GeneratePseudoPrime(int bits);
    public void Incr2();
}
public enum Mono.Math.Prime.ConfidenceFactor : Enum {
    public int value__;
    public static ConfidenceFactor ExtraLow;
    public static ConfidenceFactor Low;
    public static ConfidenceFactor Medium;
    public static ConfidenceFactor High;
    public static ConfidenceFactor ExtraHigh;
    public static ConfidenceFactor Provable;
}
public class Mono.Math.Prime.Generator.NextPrimeFinder : SequentialSearchPrimeGeneratorBase {
    protected virtual BigInteger GenerateSearchBase(int bits, object Context);
}
public abstract class Mono.Math.Prime.Generator.PrimeGeneratorBase : object {
    public ConfidenceFactor Confidence { get; }
    public PrimalityTest PrimalityTest { get; }
    public int TrialDivisionBounds { get; }
    public virtual ConfidenceFactor get_Confidence();
    public virtual PrimalityTest get_PrimalityTest();
    public virtual int get_TrialDivisionBounds();
    protected bool PostTrialDivisionTests(BigInteger bi);
    public abstract virtual BigInteger GenerateNewPrime(int bits);
}
public class Mono.Math.Prime.Generator.SequentialSearchPrimeGeneratorBase : PrimeGeneratorBase {
    protected virtual BigInteger GenerateSearchBase(int bits, object context);
    public virtual BigInteger GenerateNewPrime(int bits);
    public virtual BigInteger GenerateNewPrime(int bits, object context);
    protected virtual bool IsPrimeAcceptable(BigInteger bi, object context);
}
public class Mono.Math.Prime.PrimalityTest : MulticastDelegate {
    public PrimalityTest(object object, IntPtr method);
    public virtual bool Invoke(BigInteger bi, ConfidenceFactor confidence);
    public virtual IAsyncResult BeginInvoke(BigInteger bi, ConfidenceFactor confidence, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
public class Mono.Math.Prime.PrimalityTests : object {
    private static int GetSPPRounds(BigInteger bi, ConfidenceFactor confidence);
    public static bool Test(BigInteger n, ConfidenceFactor confidence);
    public static bool RabinMillerTest(BigInteger n, ConfidenceFactor confidence);
    public static bool SmallPrimeSppTest(BigInteger bi, ConfidenceFactor confidence);
}
[DefaultMemberAttribute("Item")]
public class Mono.Security.ASN1 : object {
    private byte m_nTag;
    private Byte[] m_aValue;
    private ArrayList elist;
    public int Count { get; }
    public byte Tag { get; }
    public int Length { get; }
    public Byte[] Value { get; public set; }
    public ASN1 Item { get; }
    public ASN1(byte tag);
    public ASN1(byte tag, Byte[] data);
    public ASN1(Byte[] data);
    public int get_Count();
    public byte get_Tag();
    public int get_Length();
    public Byte[] get_Value();
    public void set_Value(Byte[] value);
    private bool CompareArray(Byte[] array1, Byte[] array2);
    public bool Equals(Byte[] asn1);
    public bool CompareValue(Byte[] value);
    public ASN1 Add(ASN1 asn1);
    public virtual Byte[] GetBytes();
    protected void Decode(Byte[] asn1, Int32& anPos, int anLength);
    protected void DecodeTLV(Byte[] asn1, Int32& pos, Byte& tag, Int32& length, Byte[]& content);
    public ASN1 get_Item(int index);
    public ASN1 Element(int index, byte anTag);
    public virtual string ToString();
    public void SaveToFile(string filename);
}
public static class Mono.Security.ASN1Convert : object {
    public static ASN1 FromDateTime(DateTime dt);
    public static ASN1 FromInt32(int value);
    public static ASN1 FromOid(string oid);
    public static ASN1 FromUnsignedBigInteger(Byte[] big);
    public static int ToInt32(ASN1 asn1);
    public static string ToOid(ASN1 asn1);
    public static DateTime ToDateTime(ASN1 time);
}
public class Mono.Security.Authenticode.AuthenticodeBase : object {
    public static string spcIndirectDataContext;
    private Byte[] fileblock;
    private Stream fs;
    private int blockNo;
    private int blockLength;
    private int peOffset;
    private int dirSecurityOffset;
    private int dirSecuritySize;
    private int coffSymbolTableOffset;
    private bool pe64;
    internal bool PE64 { get; }
    internal int PEOffset { get; }
    internal int CoffSymbolTableOffset { get; }
    internal int SecurityOffset { get; }
    internal bool get_PE64();
    internal int get_PEOffset();
    internal int get_CoffSymbolTableOffset();
    internal int get_SecurityOffset();
    internal void Open(string filename);
    internal void Open(Byte[] rawdata);
    internal void Close();
    internal void ReadFirstBlock();
    internal int ProcessFirstBlock();
    internal Byte[] GetSecurityEntry();
    internal Byte[] GetHash(HashAlgorithm hash);
    protected Byte[] HashFile(string fileName, string hashName);
}
public class Mono.Security.Authenticode.AuthenticodeDeformatter : AuthenticodeBase {
    private string filename;
    private Byte[] rawdata;
    private Byte[] hash;
    private X509CertificateCollection coll;
    private ASN1 signedHash;
    private DateTime timestamp;
    private X509Certificate signingCertificate;
    private int reason;
    private bool trustedRoot;
    private bool trustedTimestampRoot;
    private Byte[] entry;
    private X509Chain signerChain;
    private X509Chain timestampChain;
    public string FileName { get; public set; }
    public Byte[] RawData { get; public set; }
    public Byte[] Hash { get; }
    public int Reason { get; }
    public Byte[] Signature { get; }
    public DateTime Timestamp { get; }
    public X509CertificateCollection Certificates { get; }
    public X509Certificate SigningCertificate { get; }
    public AuthenticodeDeformatter(string fileName);
    public AuthenticodeDeformatter(Byte[] rawData);
    public string get_FileName();
    public void set_FileName(string value);
    public Byte[] get_RawData();
    public void set_RawData(Byte[] value);
    public Byte[] get_Hash();
    public int get_Reason();
    public bool IsTrusted();
    public Byte[] get_Signature();
    public DateTime get_Timestamp();
    public X509CertificateCollection get_Certificates();
    public X509Certificate get_SigningCertificate();
    private bool CheckSignature();
    private bool CompareIssuerSerial(string issuer, Byte[] serial, X509Certificate x509);
    private bool VerifySignature(SignedData sd, Byte[] calculatedMessageDigest, HashAlgorithm ha);
    private bool VerifyCounterSignature(SignerInfo cs, Byte[] signature);
    private void Reset();
}
public class Mono.Security.Authenticode.AuthenticodeFormatter : AuthenticodeBase {
    private Authority authority;
    private X509CertificateCollection certs;
    private ArrayList crls;
    private string hash;
    private RSA rsa;
    private Uri timestamp;
    private ASN1 authenticode;
    private SignedData pkcs7;
    private string description;
    private Uri url;
    private static string signedData;
    private static string countersignature;
    private static string spcStatementType;
    private static string spcSpOpusInfo;
    private static string spcPelmageData;
    private static string commercialCodeSigning;
    private static string timestampCountersignature;
    private static Byte[] obsolete;
    public Authority Authority { get; public set; }
    public X509CertificateCollection Certificates { get; }
    public ArrayList Crl { get; }
    public string Hash { get; public set; }
    public RSA RSA { get; public set; }
    public Uri TimestampUrl { get; public set; }
    public string Description { get; public set; }
    public Uri Url { get; public set; }
    private static AuthenticodeFormatter();
    public Authority get_Authority();
    public void set_Authority(Authority value);
    public X509CertificateCollection get_Certificates();
    public ArrayList get_Crl();
    public string get_Hash();
    public void set_Hash(string value);
    public RSA get_RSA();
    public void set_RSA(RSA value);
    public Uri get_TimestampUrl();
    public void set_TimestampUrl(Uri value);
    public string get_Description();
    public void set_Description(string value);
    public Uri get_Url();
    public void set_Url(Uri value);
    private ASN1 AlgorithmIdentifier(string oid);
    private ASN1 Attribute(string oid, ASN1 value);
    private ASN1 Opus(string description, string url);
    private Byte[] Header(Byte[] fileHash, string hashAlgorithm);
    public ASN1 TimestampRequest(Byte[] signature);
    public void ProcessTimestamp(Byte[] response);
    private Byte[] Timestamp(Byte[] signature);
    private bool Save(string fileName, Byte[] asn);
    public bool Sign(string fileName);
    public bool Timestamp(string fileName);
}
public enum Mono.Security.Authenticode.Authority : Enum {
    public int value__;
    public static Authority Individual;
    public static Authority Commercial;
    public static Authority Maximum;
}
public class Mono.Security.Authenticode.PrivateKey : object {
    private static UInt32 magic;
    private bool encrypted;
    private RSA rsa;
    private bool weak;
    private int keyType;
    public bool Encrypted { get; }
    public int KeyType { get; public set; }
    public RSA RSA { get; public set; }
    public bool Weak { get; public set; }
    public PrivateKey(Byte[] data, string password);
    public bool get_Encrypted();
    public int get_KeyType();
    public void set_KeyType(int value);
    public RSA get_RSA();
    public void set_RSA(RSA value);
    public bool get_Weak();
    public void set_Weak(bool value);
    private Byte[] DeriveKey(Byte[] salt, string password);
    private bool Decode(Byte[] pvk, string password);
    public void Save(string filename);
    public void Save(string filename, string password);
    public static PrivateKey CreateFromFile(string filename);
    public static PrivateKey CreateFromFile(string filename, string password);
}
public class Mono.Security.Authenticode.SoftwarePublisherCertificate : object {
    private SignedData pkcs7;
    private static string header;
    private static string footer;
    public X509CertificateCollection Certificates { get; }
    public ArrayList Crls { get; }
    public SoftwarePublisherCertificate(Byte[] data);
    public X509CertificateCollection get_Certificates();
    public ArrayList get_Crls();
    public Byte[] GetBytes();
    public static SoftwarePublisherCertificate CreateFromFile(string filename);
    private static Byte[] PEM(Byte[] data);
}
internal class Mono.Security.BitConverterLE : object {
    private static Byte[] GetUShortBytes(Byte* bytes);
    private static Byte[] GetUIntBytes(Byte* bytes);
    private static Byte[] GetULongBytes(Byte* bytes);
    internal static Byte[] GetBytes(bool value);
    internal static Byte[] GetBytes(char value);
    internal static Byte[] GetBytes(short value);
    internal static Byte[] GetBytes(int value);
    internal static Byte[] GetBytes(long value);
    internal static Byte[] GetBytes(ushort value);
    internal static Byte[] GetBytes(UInt32 value);
    internal static Byte[] GetBytes(ulong value);
    internal static Byte[] GetBytes(float value);
    internal static Byte[] GetBytes(double value);
    private static void UShortFromBytes(Byte* dst, Byte[] src, int startIndex);
    private static void UIntFromBytes(Byte* dst, Byte[] src, int startIndex);
    private static void ULongFromBytes(Byte* dst, Byte[] src, int startIndex);
    internal static bool ToBoolean(Byte[] value, int startIndex);
    internal static char ToChar(Byte[] value, int startIndex);
    internal static short ToInt16(Byte[] value, int startIndex);
    internal static int ToInt32(Byte[] value, int startIndex);
    internal static long ToInt64(Byte[] value, int startIndex);
    internal static ushort ToUInt16(Byte[] value, int startIndex);
    internal static UInt32 ToUInt32(Byte[] value, int startIndex);
    internal static ulong ToUInt64(Byte[] value, int startIndex);
    internal static float ToSingle(Byte[] value, int startIndex);
    internal static double ToDouble(Byte[] value, int startIndex);
}
public class Mono.Security.Cryptography.ARC4Managed : RC4 {
    private Byte[] key;
    private Byte[] state;
    private byte x;
    private byte y;
    private bool m_disposed;
    public Byte[] Key { get; public set; }
    public bool CanReuseTransform { get; }
    public bool CanTransformMultipleBlocks { get; }
    public int InputBlockSize { get; }
    public int OutputBlockSize { get; }
    protected virtual override void Finalize();
    protected virtual void Dispose(bool disposing);
    public virtual Byte[] get_Key();
    public virtual void set_Key(Byte[] value);
    public sealed virtual bool get_CanReuseTransform();
    public virtual ICryptoTransform CreateEncryptor(Byte[] rgbKey, Byte[] rgvIV);
    public virtual ICryptoTransform CreateDecryptor(Byte[] rgbKey, Byte[] rgvIV);
    public virtual void GenerateIV();
    public virtual void GenerateKey();
    public sealed virtual bool get_CanTransformMultipleBlocks();
    public sealed virtual int get_InputBlockSize();
    public sealed virtual int get_OutputBlockSize();
    private void KeySetup(Byte[] key);
    private void CheckInput(Byte[] inputBuffer, int inputOffset, int inputCount);
    public sealed virtual int TransformBlock(Byte[] inputBuffer, int inputOffset, int inputCount, Byte[] outputBuffer, int outputOffset);
    private int InternalTransformBlock(Byte[] inputBuffer, int inputOffset, int inputCount, Byte[] outputBuffer, int outputOffset);
    public sealed virtual Byte[] TransformFinalBlock(Byte[] inputBuffer, int inputOffset, int inputCount);
}
public class Mono.Security.Cryptography.BlockProcessor : object {
    private ICryptoTransform transform;
    private Byte[] block;
    private int blockSize;
    private int blockCount;
    public BlockProcessor(ICryptoTransform transform);
    public BlockProcessor(ICryptoTransform transform, int blockSize);
    protected virtual override void Finalize();
    public void Initialize();
    public void Core(Byte[] rgb);
    public void Core(Byte[] rgb, int ib, int cb);
    public Byte[] Final();
}
public class Mono.Security.Cryptography.CryptoConvert : object {
    private static int ToInt32LE(Byte[] bytes, int offset);
    private static UInt32 ToUInt32LE(Byte[] bytes, int offset);
    private static Byte[] GetBytesLE(int val);
    private static Byte[] Trim(Byte[] array);
    public static RSA FromCapiPrivateKeyBlob(Byte[] blob);
    public static RSA FromCapiPrivateKeyBlob(Byte[] blob, int offset);
    private static RSAParameters GetParametersFromCapiPrivateKeyBlob(Byte[] blob, int offset);
    public static DSA FromCapiPrivateKeyBlobDSA(Byte[] blob);
    public static DSA FromCapiPrivateKeyBlobDSA(Byte[] blob, int offset);
    public static Byte[] ToCapiPrivateKeyBlob(RSA rsa);
    public static Byte[] ToCapiPrivateKeyBlob(DSA dsa);
    public static RSA FromCapiPublicKeyBlob(Byte[] blob);
    public static RSA FromCapiPublicKeyBlob(Byte[] blob, int offset);
    private static RSAParameters GetParametersFromCapiPublicKeyBlob(Byte[] blob, int offset);
    public static DSA FromCapiPublicKeyBlobDSA(Byte[] blob);
    public static DSA FromCapiPublicKeyBlobDSA(Byte[] blob, int offset);
    public static Byte[] ToCapiPublicKeyBlob(RSA rsa);
    public static Byte[] ToCapiPublicKeyBlob(DSA dsa);
    public static RSA FromCapiKeyBlob(Byte[] blob);
    public static RSA FromCapiKeyBlob(Byte[] blob, int offset);
    public static DSA FromCapiKeyBlobDSA(Byte[] blob);
    public static DSA FromCapiKeyBlobDSA(Byte[] blob, int offset);
    public static Byte[] ToCapiKeyBlob(AsymmetricAlgorithm keypair, bool includePrivateKey);
    public static Byte[] ToCapiKeyBlob(RSA rsa, bool includePrivateKey);
    public static Byte[] ToCapiKeyBlob(DSA dsa, bool includePrivateKey);
    public static string ToHex(Byte[] input);
    private static byte FromHexChar(char c);
    public static Byte[] FromHex(string hex);
}
public enum Mono.Security.Cryptography.DHKeyGeneration : Enum {
    public int value__;
    public static DHKeyGeneration Random;
    public static DHKeyGeneration Static;
}
public class Mono.Security.Cryptography.DHParameters : ValueType {
    public Byte[] P;
    public Byte[] G;
    public Byte[] X;
}
public abstract class Mono.Security.Cryptography.DiffieHellman : AsymmetricAlgorithm {
    public static DiffieHellman Create();
    public static DiffieHellman Create(string algName);
    public abstract virtual Byte[] CreateKeyExchange();
    public abstract virtual Byte[] DecryptKeyExchange(Byte[] keyex);
    public abstract virtual DHParameters ExportParameters(bool includePrivate);
    public abstract virtual void ImportParameters(DHParameters parameters);
    private Byte[] GetNamedParam(SecurityElement se, string param);
    public virtual void FromXmlString(string xmlString);
    public virtual string ToXmlString(bool includePrivateParameters);
}
public class Mono.Security.Cryptography.DiffieHellmanManaged : DiffieHellman {
    private BigInteger m_P;
    private BigInteger m_G;
    private BigInteger m_X;
    private bool m_Disposed;
    private static Byte[] m_OAKLEY768;
    private static Byte[] m_OAKLEY1024;
    private static Byte[] m_OAKLEY1536;
    public string KeyExchangeAlgorithm { get; }
    public string SignatureAlgorithm { get; }
    public DiffieHellmanManaged(int bitLength, int l, DHKeyGeneration method);
    public DiffieHellmanManaged(Byte[] p, Byte[] g, Byte[] x);
    public DiffieHellmanManaged(Byte[] p, Byte[] g, int l);
    private static DiffieHellmanManaged();
    private void Initialize(BigInteger p, BigInteger g, BigInteger x, int secretLen, bool checkInput);
    public virtual Byte[] CreateKeyExchange();
    public virtual Byte[] DecryptKeyExchange(Byte[] keyEx);
    public virtual string get_KeyExchangeAlgorithm();
    public virtual string get_SignatureAlgorithm();
    protected virtual void Dispose(bool disposing);
    public virtual DHParameters ExportParameters(bool includePrivateParameters);
    public virtual void ImportParameters(DHParameters parameters);
    protected virtual override void Finalize();
    private void GenerateKey(int bitlen, DHKeyGeneration keygen, BigInteger& p, BigInteger& g);
}
internal class Mono.Security.Cryptography.HMAC : KeyedHashAlgorithm {
    private HashAlgorithm hash;
    private bool hashing;
    private Byte[] innerPad;
    private Byte[] outerPad;
    public Byte[] Key { get; public set; }
    public HMAC(HashAlgorithm ha, Byte[] rgbKey);
    public virtual Byte[] get_Key();
    public virtual void set_Key(Byte[] value);
    public virtual void Initialize();
    protected virtual Byte[] HashFinal();
    protected virtual void HashCore(Byte[] array, int ibStart, int cbSize);
    private void initializePad();
}
public class Mono.Security.Cryptography.KeyBuilder : object {
    private static RandomNumberGenerator rng;
    private static RandomNumberGenerator Rng { get; }
    private static RandomNumberGenerator get_Rng();
    public static Byte[] Key(int size);
    public static Byte[] IV(int size);
}
public class Mono.Security.Cryptography.KeyPairPersistence : object {
    private static bool _userPathExists;
    private static string _userPath;
    private static bool _machinePathExists;
    private static string _machinePath;
    private CspParameters _params;
    private string _keyvalue;
    private string _filename;
    private string _container;
    private static object lockobj;
    public string Filename { get; }
    public string KeyValue { get; public set; }
    public CspParameters Parameters { get; }
    private static string UserPath { get; }
    private static string MachinePath { get; }
    private bool CanChange { get; }
    private bool UseDefaultKeyContainer { get; }
    private bool UseMachineKeyStore { get; }
    private string ContainerName { get; }
    public KeyPairPersistence(CspParameters parameters);
    public KeyPairPersistence(CspParameters parameters, string keyPair);
    private static KeyPairPersistence();
    public string get_Filename();
    public string get_KeyValue();
    public void set_KeyValue(string value);
    public CspParameters get_Parameters();
    public bool Load();
    public void Save();
    public void Remove();
    private static string get_UserPath();
    private static string get_MachinePath();
    internal static bool _CanSecure(Char* root);
    internal static bool _ProtectUser(Char* path);
    internal static bool _ProtectMachine(Char* path);
    internal static bool _IsUserProtected(Char* path);
    internal static bool _IsMachineProtected(Char* path);
    private static bool CanSecure(string path);
    private static bool ProtectUser(string path);
    private static bool ProtectMachine(string path);
    private static bool IsUserProtected(string path);
    private static bool IsMachineProtected(string path);
    private bool get_CanChange();
    private bool get_UseDefaultKeyContainer();
    private bool get_UseMachineKeyStore();
    private string get_ContainerName();
    private CspParameters Copy(CspParameters p);
    private void FromXml(string xml);
    private string ToXml();
}
public abstract class Mono.Security.Cryptography.MD2 : HashAlgorithm {
    public static MD2 Create();
    public static MD2 Create(string hashName);
}
public class Mono.Security.Cryptography.MD2Managed : MD2 {
    private Byte[] state;
    private Byte[] checksum;
    private Byte[] buffer;
    private int count;
    private Byte[] x;
    private static Byte[] PI_SUBST;
    private static MD2Managed();
    private Byte[] Padding(int nLength);
    public virtual void Initialize();
    protected virtual void HashCore(Byte[] array, int ibStart, int cbSize);
    protected virtual Byte[] HashFinal();
    private void MD2Transform(Byte[] state, Byte[] checksum, Byte[] block, int index);
}
public abstract class Mono.Security.Cryptography.MD4 : HashAlgorithm {
    public static MD4 Create();
    public static MD4 Create(string hashName);
}
public class Mono.Security.Cryptography.MD4Managed : MD4 {
    private UInt32[] state;
    private Byte[] buffer;
    private UInt32[] count;
    private UInt32[] x;
    private static int S11;
    private static int S12;
    private static int S13;
    private static int S14;
    private static int S21;
    private static int S22;
    private static int S23;
    private static int S24;
    private static int S31;
    private static int S32;
    private static int S33;
    private static int S34;
    private Byte[] digest;
    public virtual void Initialize();
    protected virtual void HashCore(Byte[] array, int ibStart, int cbSize);
    protected virtual Byte[] HashFinal();
    private Byte[] Padding(int nLength);
    private UInt32 F(UInt32 x, UInt32 y, UInt32 z);
    private UInt32 G(UInt32 x, UInt32 y, UInt32 z);
    private UInt32 H(UInt32 x, UInt32 y, UInt32 z);
    private UInt32 ROL(UInt32 x, byte n);
    private void FF(UInt32& a, UInt32 b, UInt32 c, UInt32 d, UInt32 x, byte s);
    private void GG(UInt32& a, UInt32 b, UInt32 c, UInt32 d, UInt32 x, byte s);
    private void HH(UInt32& a, UInt32 b, UInt32 c, UInt32 d, UInt32 x, byte s);
    private void Encode(Byte[] output, UInt32[] input);
    private void Decode(UInt32[] output, Byte[] input, int index);
    private void MD4Transform(UInt32[] state, Byte[] block, int index);
}
public class Mono.Security.Cryptography.PKCS1 : object {
    private static Byte[] emptySHA1;
    private static Byte[] emptySHA256;
    private static Byte[] emptySHA384;
    private static Byte[] emptySHA512;
    private static PKCS1();
    private static bool Compare(Byte[] array1, Byte[] array2);
    private static Byte[] xor(Byte[] array1, Byte[] array2);
    private static Byte[] GetEmptyHash(HashAlgorithm hash);
    public static Byte[] I2OSP(int x, int size);
    public static Byte[] I2OSP(Byte[] x, int size);
    public static Byte[] OS2IP(Byte[] x);
    public static Byte[] RSAEP(RSA rsa, Byte[] m);
    public static Byte[] RSADP(RSA rsa, Byte[] c);
    public static Byte[] RSASP1(RSA rsa, Byte[] m);
    public static Byte[] RSAVP1(RSA rsa, Byte[] s);
    public static Byte[] Encrypt_OAEP(RSA rsa, HashAlgorithm hash, RandomNumberGenerator rng, Byte[] M);
    public static Byte[] Decrypt_OAEP(RSA rsa, HashAlgorithm hash, Byte[] C);
    public static Byte[] Encrypt_v15(RSA rsa, RandomNumberGenerator rng, Byte[] M);
    public static Byte[] Decrypt_v15(RSA rsa, Byte[] C);
    public static Byte[] Sign_v15(RSA rsa, HashAlgorithm hash, Byte[] hashValue);
    internal static Byte[] Sign_v15(RSA rsa, string hashName, Byte[] hashValue);
    public static bool Verify_v15(RSA rsa, HashAlgorithm hash, Byte[] hashValue, Byte[] signature);
    internal static bool Verify_v15(RSA rsa, string hashName, Byte[] hashValue, Byte[] signature);
    public static bool Verify_v15(RSA rsa, HashAlgorithm hash, Byte[] hashValue, Byte[] signature, bool tryNonStandardEncoding);
    public static Byte[] Encode_v15(HashAlgorithm hash, Byte[] hashValue, int emLength);
    public static Byte[] MGF1(HashAlgorithm hash, Byte[] mgfSeed, int maskLen);
    internal static string HashNameFromOid(string oid, bool throwOnError);
    internal static HashAlgorithm CreateFromOid(string oid);
    internal static HashAlgorithm CreateFromName(string name);
}
public class Mono.Security.Cryptography.PKCS8 : object {
    public static KeyInfo GetType(Byte[] data);
}
public abstract class Mono.Security.Cryptography.RC4 : SymmetricAlgorithm {
    private static KeySizes[] s_legalBlockSizes;
    private static KeySizes[] s_legalKeySizes;
    public Byte[] IV { get; public set; }
    private static RC4();
    public virtual Byte[] get_IV();
    public virtual void set_IV(Byte[] value);
    public static RC4 Create();
    public static RC4 Create(string algName);
}
public class Mono.Security.Cryptography.RSAManaged : RSA {
    private static int defaultKeySize;
    private bool isCRTpossible;
    private bool keyBlinding;
    private bool keypairGenerated;
    private bool m_disposed;
    private BigInteger d;
    private BigInteger p;
    private BigInteger q;
    private BigInteger dp;
    private BigInteger dq;
    private BigInteger qInv;
    private BigInteger n;
    private BigInteger e;
    [CompilerGeneratedAttribute]
private KeyGeneratedEventHandler KeyGenerated;
    public int KeySize { get; }
    public string KeyExchangeAlgorithm { get; }
    public bool PublicOnly { get; }
    public string SignatureAlgorithm { get; }
    public bool UseKeyBlinding { get; public set; }
    public bool IsCrtPossible { get; }
    public RSAManaged(int keySize);
    protected virtual override void Finalize();
    private void GenerateKeyPair();
    public virtual int get_KeySize();
    public virtual string get_KeyExchangeAlgorithm();
    public bool get_PublicOnly();
    public virtual string get_SignatureAlgorithm();
    public virtual Byte[] DecryptValue(Byte[] rgb);
    public virtual Byte[] EncryptValue(Byte[] rgb);
    public virtual RSAParameters ExportParameters(bool includePrivateParameters);
    public virtual void ImportParameters(RSAParameters parameters);
    protected virtual void Dispose(bool disposing);
    [CompilerGeneratedAttribute]
public void add_KeyGenerated(KeyGeneratedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_KeyGenerated(KeyGeneratedEventHandler value);
    public virtual string ToXmlString(bool includePrivateParameters);
    public bool get_UseKeyBlinding();
    public void set_UseKeyBlinding(bool value);
    public bool get_IsCrtPossible();
    private Byte[] GetPaddedValue(BigInteger value, int length);
}
public abstract class Mono.Security.Cryptography.SHA224 : HashAlgorithm {
    public static SHA224 Create();
    public static SHA224 Create(string hashName);
}
public class Mono.Security.Cryptography.SHA224Managed : SHA224 {
    private static int BLOCK_SIZE_BYTES;
    private UInt32[] _H;
    private ulong count;
    private Byte[] _ProcessingBuffer;
    private int _ProcessingBufferCount;
    private UInt32[] buff;
    private UInt32 Ch(UInt32 u, UInt32 v, UInt32 w);
    private UInt32 Maj(UInt32 u, UInt32 v, UInt32 w);
    private UInt32 Ro0(UInt32 x);
    private UInt32 Ro1(UInt32 x);
    private UInt32 Sig0(UInt32 x);
    private UInt32 Sig1(UInt32 x);
    protected virtual void HashCore(Byte[] rgb, int start, int size);
    protected virtual Byte[] HashFinal();
    public virtual void Initialize();
    private void ProcessBlock(Byte[] inputBuffer, int inputOffset);
    private void ProcessFinalBlock(Byte[] inputBuffer, int inputOffset, int inputCount);
    internal void AddLength(ulong length, Byte[] buffer, int position);
}
internal class Mono.Security.Cryptography.SHAConstants : object {
    public static UInt32[] K1;
    private static SHAConstants();
}
internal abstract class Mono.Security.Cryptography.SymmetricTransform : object {
    protected SymmetricAlgorithm algo;
    protected bool encrypt;
    protected int BlockSizeByte;
    protected Byte[] temp;
    protected Byte[] temp2;
    private Byte[] workBuff;
    private Byte[] workout;
    protected PaddingMode padmode;
    protected int FeedBackByte;
    private bool m_disposed;
    protected bool lastBlock;
    private RandomNumberGenerator _rng;
    public bool CanTransformMultipleBlocks { get; }
    public bool CanReuseTransform { get; }
    public int InputBlockSize { get; }
    public int OutputBlockSize { get; }
    private bool KeepLastBlock { get; }
    public SymmetricTransform(SymmetricAlgorithm symmAlgo, bool encryption, Byte[] rgbIV);
    protected virtual override void Finalize();
    private sealed virtual override void System.IDisposable.Dispose();
    protected virtual void Dispose(bool disposing);
    public virtual bool get_CanTransformMultipleBlocks();
    public virtual bool get_CanReuseTransform();
    public virtual int get_InputBlockSize();
    public virtual int get_OutputBlockSize();
    protected virtual void Transform(Byte[] input, Byte[] output);
    protected abstract virtual void ECB(Byte[] input, Byte[] output);
    protected virtual void CBC(Byte[] input, Byte[] output);
    protected virtual void CFB(Byte[] input, Byte[] output);
    protected virtual void OFB(Byte[] input, Byte[] output);
    protected virtual void CTS(Byte[] input, Byte[] output);
    private void CheckInput(Byte[] inputBuffer, int inputOffset, int inputCount);
    public virtual int TransformBlock(Byte[] inputBuffer, int inputOffset, int inputCount, Byte[] outputBuffer, int outputOffset);
    private bool get_KeepLastBlock();
    private int InternalTransformBlock(Byte[] inputBuffer, int inputOffset, int inputCount, Byte[] outputBuffer, int outputOffset);
    private void Random(Byte[] buffer, int start, int length);
    private void ThrowBadPaddingException(PaddingMode padding, int length, int position);
    protected virtual Byte[] FinalEncrypt(Byte[] inputBuffer, int inputOffset, int inputCount);
    protected virtual Byte[] FinalDecrypt(Byte[] inputBuffer, int inputOffset, int inputCount);
    public virtual Byte[] TransformFinalBlock(Byte[] inputBuffer, int inputOffset, int inputCount);
}
public class Mono.Security.Interface.Alert : object {
    private AlertLevel level;
    private AlertDescription description;
    public AlertLevel Level { get; }
    public AlertDescription Description { get; }
    public string Message { get; }
    public bool IsWarning { get; }
    public bool IsCloseNotify { get; }
    public Alert(AlertDescription description);
    public Alert(AlertLevel level, AlertDescription description);
    public AlertLevel get_Level();
    public AlertDescription get_Description();
    public string get_Message();
    public bool get_IsWarning();
    public bool get_IsCloseNotify();
    private void inferAlertLevel();
    public virtual string ToString();
    public static string GetAlertMessage(AlertDescription description);
}
public enum Mono.Security.Interface.AlertDescription : Enum {
    public byte value__;
    public static AlertDescription CloseNotify;
    public static AlertDescription UnexpectedMessage;
    public static AlertDescription BadRecordMAC;
    public static AlertDescription DecryptionFailed_RESERVED;
    public static AlertDescription RecordOverflow;
    public static AlertDescription DecompressionFailure;
    public static AlertDescription HandshakeFailure;
    public static AlertDescription NoCertificate_RESERVED;
    public static AlertDescription BadCertificate;
    public static AlertDescription UnsupportedCertificate;
    public static AlertDescription CertificateRevoked;
    public static AlertDescription CertificateExpired;
    public static AlertDescription CertificateUnknown;
    public static AlertDescription IlegalParameter;
    public static AlertDescription UnknownCA;
    public static AlertDescription AccessDenied;
    public static AlertDescription DecodeError;
    public static AlertDescription DecryptError;
    public static AlertDescription ExportRestriction;
    public static AlertDescription ProtocolVersion;
    public static AlertDescription InsuficientSecurity;
    public static AlertDescription InternalError;
    public static AlertDescription UserCancelled;
    public static AlertDescription NoRenegotiation;
    public static AlertDescription UnsupportedExtension;
}
public enum Mono.Security.Interface.AlertLevel : Enum {
    public byte value__;
    public static AlertLevel Warning;
    public static AlertLevel Fatal;
}
public static class Mono.Security.Interface.CertificateValidationHelper : object {
    private static string SecurityLibrary;
    private static bool noX509Chain;
    private static bool supportsTrustAnchors;
    public static bool SupportsX509Chain { get; }
    public static bool SupportsTrustAnchors { get; }
    private static CertificateValidationHelper();
    public static bool get_SupportsX509Chain();
    public static bool get_SupportsTrustAnchors();
    public static ICertificateValidator GetValidator(MonoTlsSettings settings);
}
public enum Mono.Security.Interface.CipherAlgorithmType : Enum {
    public int value__;
    public static CipherAlgorithmType None;
    public static CipherAlgorithmType Aes128;
    public static CipherAlgorithmType Aes256;
    public static CipherAlgorithmType AesGcm128;
    public static CipherAlgorithmType AesGcm256;
}
[CLSCompliantAttribute("False")]
public enum Mono.Security.Interface.CipherSuiteCode : Enum {
    public ushort value__;
    public static CipherSuiteCode TLS_NULL_WITH_NULL_NULL;
    public static CipherSuiteCode TLS_RSA_WITH_NULL_MD5;
    public static CipherSuiteCode TLS_RSA_WITH_NULL_SHA;
    public static CipherSuiteCode TLS_RSA_EXPORT_WITH_RC4_40_MD5;
    public static CipherSuiteCode TLS_RSA_WITH_RC4_128_MD5;
    public static CipherSuiteCode TLS_RSA_WITH_RC4_128_SHA;
    public static CipherSuiteCode TLS_RSA_EXPORT_WITH_RC2_CBC_40_MD5;
    public static CipherSuiteCode TLS_RSA_WITH_IDEA_CBC_SHA;
    public static CipherSuiteCode TLS_RSA_EXPORT_WITH_DES40_CBC_SHA;
    public static CipherSuiteCode TLS_RSA_WITH_DES_CBC_SHA;
    public static CipherSuiteCode TLS_RSA_WITH_3DES_EDE_CBC_SHA;
    public static CipherSuiteCode TLS_DH_DSS_EXPORT_WITH_DES40_CBC_SHA;
    public static CipherSuiteCode TLS_DH_DSS_WITH_DES_CBC_SHA;
    public static CipherSuiteCode TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA;
    public static CipherSuiteCode TLS_DH_RSA_EXPORT_WITH_DES40_CBC_SHA;
    public static CipherSuiteCode TLS_DH_RSA_WITH_DES_CBC_SHA;
    public static CipherSuiteCode TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA;
    public static CipherSuiteCode TLS_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA;
    public static CipherSuiteCode TLS_DHE_DSS_WITH_DES_CBC_SHA;
    public static CipherSuiteCode TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA;
    public static CipherSuiteCode TLS_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA;
    public static CipherSuiteCode TLS_DHE_RSA_WITH_DES_CBC_SHA;
    public static CipherSuiteCode TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA;
    public static CipherSuiteCode TLS_DH_anon_EXPORT_WITH_RC4_40_MD5;
    public static CipherSuiteCode TLS_DH_anon_WITH_RC4_128_MD5;
    public static CipherSuiteCode TLS_DH_anon_EXPORT_WITH_DES40_CBC_SHA;
    public static CipherSuiteCode TLS_DH_anon_WITH_DES_CBC_SHA;
    public static CipherSuiteCode TLS_DH_anon_WITH_3DES_EDE_CBC_SHA;
    public static CipherSuiteCode TLS_RSA_WITH_AES_128_CBC_SHA;
    public static CipherSuiteCode TLS_DH_DSS_WITH_AES_128_CBC_SHA;
    public static CipherSuiteCode TLS_DH_RSA_WITH_AES_128_CBC_SHA;
    public static CipherSuiteCode TLS_DHE_DSS_WITH_AES_128_CBC_SHA;
    public static CipherSuiteCode TLS_DHE_RSA_WITH_AES_128_CBC_SHA;
    public static CipherSuiteCode TLS_DH_anon_WITH_AES_128_CBC_SHA;
    public static CipherSuiteCode TLS_RSA_WITH_AES_256_CBC_SHA;
    public static CipherSuiteCode TLS_DH_DSS_WITH_AES_256_CBC_SHA;
    public static CipherSuiteCode TLS_DH_RSA_WITH_AES_256_CBC_SHA;
    public static CipherSuiteCode TLS_DHE_DSS_WITH_AES_256_CBC_SHA;
    public static CipherSuiteCode TLS_DHE_RSA_WITH_AES_256_CBC_SHA;
    public static CipherSuiteCode TLS_DH_anon_WITH_AES_256_CBC_SHA;
    public static CipherSuiteCode TLS_RSA_WITH_CAMELLIA_128_CBC_SHA;
    public static CipherSuiteCode TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA;
    public static CipherSuiteCode TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA;
    public static CipherSuiteCode TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA;
    public static CipherSuiteCode TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA;
    public static CipherSuiteCode TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA;
    public static CipherSuiteCode TLS_RSA_WITH_CAMELLIA_256_CBC_SHA;
    public static CipherSuiteCode TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA;
    public static CipherSuiteCode TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA;
    public static CipherSuiteCode TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA;
    public static CipherSuiteCode TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA;
    public static CipherSuiteCode TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA;
    public static CipherSuiteCode TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256;
    public static CipherSuiteCode TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA256;
    public static CipherSuiteCode TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA256;
    public static CipherSuiteCode TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA256;
    public static CipherSuiteCode TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256;
    public static CipherSuiteCode TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA256;
    public static CipherSuiteCode TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256;
    public static CipherSuiteCode TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA256;
    public static CipherSuiteCode TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA256;
    public static CipherSuiteCode TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA256;
    public static CipherSuiteCode TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256;
    public static CipherSuiteCode TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA256;
    public static CipherSuiteCode TLS_RSA_WITH_SEED_CBC_SHA;
    public static CipherSuiteCode TLS_DH_DSS_WITH_SEED_CBC_SHA;
    public static CipherSuiteCode TLS_DH_RSA_WITH_SEED_CBC_SHA;
    public static CipherSuiteCode TLS_DHE_DSS_WITH_SEED_CBC_SHA;
    public static CipherSuiteCode TLS_DHE_RSA_WITH_SEED_CBC_SHA;
    public static CipherSuiteCode TLS_DH_anon_WITH_SEED_CBC_SHA;
    public static CipherSuiteCode TLS_PSK_WITH_RC4_128_SHA;
    public static CipherSuiteCode TLS_PSK_WITH_3DES_EDE_CBC_SHA;
    public static CipherSuiteCode TLS_PSK_WITH_AES_128_CBC_SHA;
    public static CipherSuiteCode TLS_PSK_WITH_AES_256_CBC_SHA;
    public static CipherSuiteCode TLS_DHE_PSK_WITH_RC4_128_SHA;
    public static CipherSuiteCode TLS_DHE_PSK_WITH_3DES_EDE_CBC_SHA;
    public static CipherSuiteCode TLS_DHE_PSK_WITH_AES_128_CBC_SHA;
    public static CipherSuiteCode TLS_DHE_PSK_WITH_AES_256_CBC_SHA;
    public static CipherSuiteCode TLS_RSA_PSK_WITH_RC4_128_SHA;
    public static CipherSuiteCode TLS_RSA_PSK_WITH_3DES_EDE_CBC_SHA;
    public static CipherSuiteCode TLS_RSA_PSK_WITH_AES_128_CBC_SHA;
    public static CipherSuiteCode TLS_RSA_PSK_WITH_AES_256_CBC_SHA;
    public static CipherSuiteCode TLS_ECDH_ECDSA_WITH_NULL_SHA;
    public static CipherSuiteCode TLS_ECDH_ECDSA_WITH_RC4_128_SHA;
    public static CipherSuiteCode TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA;
    public static CipherSuiteCode TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA;
    public static CipherSuiteCode TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA;
    public static CipherSuiteCode TLS_ECDHE_ECDSA_WITH_NULL_SHA;
    public static CipherSuiteCode TLS_ECDHE_ECDSA_WITH_RC4_128_SHA;
    public static CipherSuiteCode TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA;
    public static CipherSuiteCode TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA;
    public static CipherSuiteCode TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA;
    public static CipherSuiteCode TLS_ECDH_RSA_WITH_NULL_SHA;
    public static CipherSuiteCode TLS_ECDH_RSA_WITH_RC4_128_SHA;
    public static CipherSuiteCode TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA;
    public static CipherSuiteCode TLS_ECDH_RSA_WITH_AES_128_CBC_SHA;
    public static CipherSuiteCode TLS_ECDH_RSA_WITH_AES_256_CBC_SHA;
    public static CipherSuiteCode TLS_ECDHE_RSA_WITH_NULL_SHA;
    public static CipherSuiteCode TLS_ECDHE_RSA_WITH_RC4_128_SHA;
    public static CipherSuiteCode TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA;
    public static CipherSuiteCode TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA;
    public static CipherSuiteCode TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA;
    public static CipherSuiteCode TLS_ECDH_anon_WITH_NULL_SHA;
    public static CipherSuiteCode TLS_ECDH_anon_WITH_RC4_128_SHA;
    public static CipherSuiteCode TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA;
    public static CipherSuiteCode TLS_ECDH_anon_WITH_AES_128_CBC_SHA;
    public static CipherSuiteCode TLS_ECDH_anon_WITH_AES_256_CBC_SHA;
    public static CipherSuiteCode TLS_PSK_WITH_NULL_SHA;
    public static CipherSuiteCode TLS_DHE_PSK_WITH_NULL_SHA;
    public static CipherSuiteCode TLS_RSA_PSK_WITH_NULL_SHA;
    public static CipherSuiteCode TLS_SRP_SHA_WITH_3DES_EDE_CBC_SHA;
    public static CipherSuiteCode TLS_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA;
    public static CipherSuiteCode TLS_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA;
    public static CipherSuiteCode TLS_SRP_SHA_WITH_AES_128_CBC_SHA;
    public static CipherSuiteCode TLS_SRP_SHA_RSA_WITH_AES_128_CBC_SHA;
    public static CipherSuiteCode TLS_SRP_SHA_DSS_WITH_AES_128_CBC_SHA;
    public static CipherSuiteCode TLS_SRP_SHA_WITH_AES_256_CBC_SHA;
    public static CipherSuiteCode TLS_SRP_SHA_RSA_WITH_AES_256_CBC_SHA;
    public static CipherSuiteCode TLS_SRP_SHA_DSS_WITH_AES_256_CBC_SHA;
    public static CipherSuiteCode TLS_RSA_WITH_NULL_SHA256;
    public static CipherSuiteCode TLS_RSA_WITH_AES_128_CBC_SHA256;
    public static CipherSuiteCode TLS_RSA_WITH_AES_256_CBC_SHA256;
    public static CipherSuiteCode TLS_DH_DSS_WITH_AES_128_CBC_SHA256;
    public static CipherSuiteCode TLS_DH_RSA_WITH_AES_128_CBC_SHA256;
    public static CipherSuiteCode TLS_DHE_DSS_WITH_AES_128_CBC_SHA256;
    public static CipherSuiteCode TLS_DHE_RSA_WITH_AES_128_CBC_SHA256;
    public static CipherSuiteCode TLS_DH_DSS_WITH_AES_256_CBC_SHA256;
    public static CipherSuiteCode TLS_DH_RSA_WITH_AES_256_CBC_SHA256;
    public static CipherSuiteCode TLS_DHE_DSS_WITH_AES_256_CBC_SHA256;
    public static CipherSuiteCode TLS_DHE_RSA_WITH_AES_256_CBC_SHA256;
    public static CipherSuiteCode TLS_DH_anon_WITH_AES_128_CBC_SHA256;
    public static CipherSuiteCode TLS_DH_anon_WITH_AES_256_CBC_SHA256;
    public static CipherSuiteCode TLS_RSA_WITH_AES_128_GCM_SHA256;
    public static CipherSuiteCode TLS_RSA_WITH_AES_256_GCM_SHA384;
    public static CipherSuiteCode TLS_DHE_RSA_WITH_AES_128_GCM_SHA256;
    public static CipherSuiteCode TLS_DHE_RSA_WITH_AES_256_GCM_SHA384;
    public static CipherSuiteCode TLS_DH_RSA_WITH_AES_128_GCM_SHA256;
    public static CipherSuiteCode TLS_DH_RSA_WITH_AES_256_GCM_SHA384;
    public static CipherSuiteCode TLS_DHE_DSS_WITH_AES_128_GCM_SHA256;
    public static CipherSuiteCode TLS_DHE_DSS_WITH_AES_256_GCM_SHA384;
    public static CipherSuiteCode TLS_DH_DSS_WITH_AES_128_GCM_SHA256;
    public static CipherSuiteCode TLS_DH_DSS_WITH_AES_256_GCM_SHA384;
    public static CipherSuiteCode TLS_DH_anon_WITH_AES_128_GCM_SHA256;
    public static CipherSuiteCode TLS_DH_anon_WITH_AES_256_GCM_SHA384;
    public static CipherSuiteCode TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256;
    public static CipherSuiteCode TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384;
    public static CipherSuiteCode TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256;
    public static CipherSuiteCode TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384;
    public static CipherSuiteCode TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256;
    public static CipherSuiteCode TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384;
    public static CipherSuiteCode TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256;
    public static CipherSuiteCode TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384;
    public static CipherSuiteCode TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256;
    public static CipherSuiteCode TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384;
    public static CipherSuiteCode TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256;
    public static CipherSuiteCode TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384;
    public static CipherSuiteCode TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256;
    public static CipherSuiteCode TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384;
    public static CipherSuiteCode TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256;
    public static CipherSuiteCode TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384;
    public static CipherSuiteCode TLS_PSK_WITH_AES_128_GCM_SHA256;
    public static CipherSuiteCode TLS_PSK_WITH_AES_256_GCM_SHA384;
    public static CipherSuiteCode TLS_DHE_PSK_WITH_AES_128_GCM_SHA256;
    public static CipherSuiteCode TLS_DHE_PSK_WITH_AES_256_GCM_SHA384;
    public static CipherSuiteCode TLS_RSA_PSK_WITH_AES_128_GCM_SHA256;
    public static CipherSuiteCode TLS_RSA_PSK_WITH_AES_256_GCM_SHA384;
    public static CipherSuiteCode TLS_PSK_WITH_AES_128_CBC_SHA256;
    public static CipherSuiteCode TLS_PSK_WITH_AES_256_CBC_SHA384;
    public static CipherSuiteCode TLS_PSK_WITH_NULL_SHA256;
    public static CipherSuiteCode TLS_PSK_WITH_NULL_SHA384;
    public static CipherSuiteCode TLS_DHE_PSK_WITH_AES_128_CBC_SHA256;
    public static CipherSuiteCode TLS_DHE_PSK_WITH_AES_256_CBC_SHA384;
    public static CipherSuiteCode TLS_DHE_PSK_WITH_NULL_SHA256;
    public static CipherSuiteCode TLS_DHE_PSK_WITH_NULL_SHA384;
    public static CipherSuiteCode TLS_RSA_PSK_WITH_AES_128_CBC_SHA256;
    public static CipherSuiteCode TLS_RSA_PSK_WITH_AES_256_CBC_SHA384;
    public static CipherSuiteCode TLS_RSA_PSK_WITH_NULL_SHA256;
    public static CipherSuiteCode TLS_RSA_PSK_WITH_NULL_SHA384;
    public static CipherSuiteCode TLS_ECDHE_PSK_WITH_RC4_128_SHA;
    public static CipherSuiteCode TLS_ECDHE_PSK_WITH_3DES_EDE_CBC_SHA;
    public static CipherSuiteCode TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA;
    public static CipherSuiteCode TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA;
    public static CipherSuiteCode TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA256;
    public static CipherSuiteCode TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA384;
    public static CipherSuiteCode TLS_ECDHE_PSK_WITH_NULL_SHA;
    public static CipherSuiteCode TLS_ECDHE_PSK_WITH_NULL_SHA256;
    public static CipherSuiteCode TLS_ECDHE_PSK_WITH_NULL_SHA384;
    public static CipherSuiteCode TLS_EMPTY_RENEGOTIATION_INFO_SCSV;
    public static CipherSuiteCode TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256;
    public static CipherSuiteCode TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384;
    public static CipherSuiteCode TLS_ECDH_ECDSA_WITH_CAMELLIA_128_CBC_SHA256;
    public static CipherSuiteCode TLS_ECDH_ECDSA_WITH_CAMELLIA_256_CBC_SHA384;
    public static CipherSuiteCode TLS_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256;
    public static CipherSuiteCode TLS_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384;
    public static CipherSuiteCode TLS_ECDH_RSA_WITH_CAMELLIA_128_CBC_SHA256;
    public static CipherSuiteCode TLS_ECDH_RSA_WITH_CAMELLIA_256_CBC_SHA384;
    public static CipherSuiteCode TLS_RSA_WITH_CAMELLIA_128_GCM_SHA256;
    public static CipherSuiteCode TLS_RSA_WITH_CAMELLIA_256_GCM_SHA384;
    public static CipherSuiteCode TLS_DHE_RSA_WITH_CAMELLIA_128_GCM_SHA256;
    public static CipherSuiteCode TLS_DHE_RSA_WITH_CAMELLIA_256_GCM_SHA384;
    public static CipherSuiteCode TLS_DH_RSA_WITH_CAMELLIA_128_GCM_SHA256;
    public static CipherSuiteCode TLS_DH_RSA_WITH_CAMELLIA_256_GCM_SHA384;
    public static CipherSuiteCode TLS_DHE_DSS_WITH_CAMELLIA_128_GCM_SHA256;
    public static CipherSuiteCode TLS_DHE_DSS_WITH_CAMELLIA_256_GCM_SHA384;
    public static CipherSuiteCode TLS_DH_DSS_WITH_CAMELLIA_128_GCM_SHA256;
    public static CipherSuiteCode TLS_DH_DSS_WITH_CAMELLIA_256_GCM_SHA384;
    public static CipherSuiteCode TLS_DH_anon_WITH_CAMELLIA_128_GCM_SHA256;
    public static CipherSuiteCode TLS_DH_anon_WITH_CAMELLIA_256_GCM_SHA384;
    public static CipherSuiteCode TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_GCM_SHA256;
    public static CipherSuiteCode TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_GCM_SHA384;
    public static CipherSuiteCode TLS_ECDH_ECDSA_WITH_CAMELLIA_128_GCM_SHA256;
    public static CipherSuiteCode TLS_ECDH_ECDSA_WITH_CAMELLIA_256_GCM_SHA384;
    public static CipherSuiteCode TLS_ECDHE_RSA_WITH_CAMELLIA_128_GCM_SHA256;
    public static CipherSuiteCode TLS_ECDHE_RSA_WITH_CAMELLIA_256_GCM_SHA384;
    public static CipherSuiteCode TLS_ECDH_RSA_WITH_CAMELLIA_128_GCM_SHA256;
    public static CipherSuiteCode TLS_ECDH_RSA_WITH_CAMELLIA_256_GCM_SHA384;
    public static CipherSuiteCode TLS_PSK_WITH_CAMELLIA_128_GCM_SHA256;
    public static CipherSuiteCode TLS_PSK_WITH_CAMELLIA_256_GCM_SHA384;
    public static CipherSuiteCode TLS_DHE_PSK_WITH_CAMELLIA_128_GCM_SHA256;
    public static CipherSuiteCode TLS_DHE_PSK_WITH_CAMELLIA_256_GCM_SHA384;
    public static CipherSuiteCode TLS_RSA_PSK_WITH_CAMELLIA_128_GCM_SHA256;
    public static CipherSuiteCode TLS_RSA_PSK_WITH_CAMELLIA_256_GCM_SHA384;
    public static CipherSuiteCode TLS_PSK_WITH_CAMELLIA_128_CBC_SHA256;
    public static CipherSuiteCode TLS_PSK_WITH_CAMELLIA_256_CBC_SHA384;
    public static CipherSuiteCode TLS_DHE_PSK_WITH_CAMELLIA_128_CBC_SHA256;
    public static CipherSuiteCode TLS_DHE_PSK_WITH_CAMELLIA_256_CBC_SHA384;
    public static CipherSuiteCode TLS_RSA_PSK_WITH_CAMELLIA_128_CBC_SHA256;
    public static CipherSuiteCode TLS_RSA_PSK_WITH_CAMELLIA_256_CBC_SHA384;
    public static CipherSuiteCode TLS_ECDHE_PSK_WITH_CAMELLIA_128_CBC_SHA256;
    public static CipherSuiteCode TLS_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384;
    public static CipherSuiteCode TLS_RSA_WITH_AES_128_CCM;
    public static CipherSuiteCode TLS_RSA_WITH_AES_256_CCM;
    public static CipherSuiteCode TLS_DHE_RSA_WITH_AES_128_CCM;
    public static CipherSuiteCode TLS_DHE_RSA_WITH_AES_256_CCM;
    public static CipherSuiteCode TLS_RSA_WITH_AES_128_CCM_8;
    public static CipherSuiteCode TLS_RSA_WITH_AES_256_CCM_8;
    public static CipherSuiteCode TLS_DHE_RSA_WITH_AES_128_CCM_8;
    public static CipherSuiteCode TLS_DHE_RSA_WITH_AES_256_CCM_8;
    public static CipherSuiteCode TLS_PSK_WITH_AES_128_CCM;
    public static CipherSuiteCode TLS_PSK_WITH_AES_256_CCM;
    public static CipherSuiteCode TLS_DHE_PSK_WITH_AES_128_CCM;
    public static CipherSuiteCode TLS_DHE_PSK_WITH_AES_256_CCM;
    public static CipherSuiteCode TLS_PSK_WITH_AES_128_CCM_8;
    public static CipherSuiteCode TLS_PSK_WITH_AES_256_CCM_8;
    public static CipherSuiteCode TLS_PSK_DHE_WITH_AES_128_CCM_8;
    public static CipherSuiteCode TLS_PSK_DHE_WITH_AES_256_CCM_8;
    public static CipherSuiteCode TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256;
    public static CipherSuiteCode TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256;
    public static CipherSuiteCode TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256;
    public static CipherSuiteCode TLS_RSA_WITH_ESTREAM_SALSA20_SHA1;
    public static CipherSuiteCode TLS_RSA_WITH_SALSA20_SHA1;
    public static CipherSuiteCode TLS_ECDHE_RSA_WITH_ESTREAM_SALSA20_SHA1;
    public static CipherSuiteCode TLS_ECDHE_RSA_WITH_SALSA20_SHA1;
    public static CipherSuiteCode TLS_ECDHE_ECDSA_WITH_ESTREAM_SALSA20_SHA1;
    public static CipherSuiteCode TLS_ECDHE_ECDSA_WITH_SALSA20_SHA1;
    public static CipherSuiteCode TLS_PSK_WITH_ESTREAM_SALSA20_SHA1;
    public static CipherSuiteCode TLS_PSK_WITH_SALSA20_SHA1;
    public static CipherSuiteCode TLS_ECDHE_PSK_WITH_ESTREAM_SALSA20_SHA1;
    public static CipherSuiteCode TLS_ECDHE_PSK_WITH_SALSA20_SHA1;
    public static CipherSuiteCode TLS_RSA_PSK_WITH_ESTREAM_SALSA20_SHA1;
    public static CipherSuiteCode TLS_RSA_PSK_WITH_SALSA20_SHA1;
    public static CipherSuiteCode TLS_DHE_PSK_WITH_ESTREAM_SALSA20_SHA1;
    public static CipherSuiteCode TLS_DHE_PSK_WITH_SALSA20_SHA1;
    public static CipherSuiteCode TLS_DHE_RSA_WITH_ESTREAM_SALSA20_SHA1;
    public static CipherSuiteCode TLS_DHE_RSA_WITH_SALSA20_SHA1;
    public static CipherSuiteCode TLS_FALLBACK_SCSV;
}
public enum Mono.Security.Interface.ExchangeAlgorithmType : Enum {
    public int value__;
    public static ExchangeAlgorithmType None;
    public static ExchangeAlgorithmType Dhe;
    public static ExchangeAlgorithmType Rsa;
    public static ExchangeAlgorithmType EcDhe;
}
public enum Mono.Security.Interface.HashAlgorithmType : Enum {
    public int value__;
    public static HashAlgorithmType None;
    public static HashAlgorithmType Md5;
    public static HashAlgorithmType Sha1;
    public static HashAlgorithmType Sha224;
    public static HashAlgorithmType Sha256;
    public static HashAlgorithmType Sha384;
    public static HashAlgorithmType Sha512;
    public static HashAlgorithmType Unknown;
    public static HashAlgorithmType Md5Sha1;
}
public interface Mono.Security.Interface.ICertificateValidator {
    public MonoTlsSettings Settings { get; }
    public abstract virtual MonoTlsSettings get_Settings();
    public abstract virtual bool SelectClientCertificate(string targetHost, X509CertificateCollection localCertificates, X509Certificate remoteCertificate, String[] acceptableIssuers, X509Certificate& clientCertificate);
    public abstract virtual ValidationResult ValidateCertificate(string targetHost, bool serverMode, X509CertificateCollection certificates);
}
internal interface Mono.Security.Interface.IMonoAuthenticationOptions {
    public bool AllowRenegotiation { get; public set; }
    public RemoteCertificateValidationCallback RemoteCertificateValidationCallback { get; public set; }
    public SslProtocols EnabledSslProtocols { get; public set; }
    public EncryptionPolicy EncryptionPolicy { get; public set; }
    public X509RevocationMode CertificateRevocationCheckMode { get; public set; }
    public abstract virtual bool get_AllowRenegotiation();
    public abstract virtual void set_AllowRenegotiation(bool value);
    public abstract virtual RemoteCertificateValidationCallback get_RemoteCertificateValidationCallback();
    public abstract virtual void set_RemoteCertificateValidationCallback(RemoteCertificateValidationCallback value);
    public abstract virtual SslProtocols get_EnabledSslProtocols();
    public abstract virtual void set_EnabledSslProtocols(SslProtocols value);
    public abstract virtual EncryptionPolicy get_EncryptionPolicy();
    public abstract virtual void set_EncryptionPolicy(EncryptionPolicy value);
    public abstract virtual X509RevocationMode get_CertificateRevocationCheckMode();
    public abstract virtual void set_CertificateRevocationCheckMode(X509RevocationMode value);
}
internal interface Mono.Security.Interface.IMonoSslClientAuthenticationOptions {
    public LocalCertificateSelectionCallback LocalCertificateSelectionCallback { get; public set; }
    public string TargetHost { get; public set; }
    public X509CertificateCollection ClientCertificates { get; public set; }
    public abstract virtual LocalCertificateSelectionCallback get_LocalCertificateSelectionCallback();
    public abstract virtual void set_LocalCertificateSelectionCallback(LocalCertificateSelectionCallback value);
    public abstract virtual string get_TargetHost();
    public abstract virtual void set_TargetHost(string value);
    public abstract virtual X509CertificateCollection get_ClientCertificates();
    public abstract virtual void set_ClientCertificates(X509CertificateCollection value);
}
internal interface Mono.Security.Interface.IMonoSslServerAuthenticationOptions {
    public bool ClientCertificateRequired { get; public set; }
    public MonoServerCertificateSelectionCallback ServerCertificateSelectionCallback { get; public set; }
    public X509Certificate ServerCertificate { get; public set; }
    public abstract virtual bool get_ClientCertificateRequired();
    public abstract virtual void set_ClientCertificateRequired(bool value);
    public abstract virtual MonoServerCertificateSelectionCallback get_ServerCertificateSelectionCallback();
    public abstract virtual void set_ServerCertificateSelectionCallback(MonoServerCertificateSelectionCallback value);
    public abstract virtual X509Certificate get_ServerCertificate();
    public abstract virtual void set_ServerCertificate(X509Certificate value);
}
public interface Mono.Security.Interface.IMonoSslStream {
    public SslStream SslStream { get; }
    public TransportContext TransportContext { get; }
    public bool IsAuthenticated { get; }
    public bool IsMutuallyAuthenticated { get; }
    public bool IsEncrypted { get; }
    public bool IsSigned { get; }
    public bool IsServer { get; }
    public CipherAlgorithmType CipherAlgorithm { get; }
    public int CipherStrength { get; }
    public HashAlgorithmType HashAlgorithm { get; }
    public int HashStrength { get; }
    public ExchangeAlgorithmType KeyExchangeAlgorithm { get; }
    public int KeyExchangeStrength { get; }
    public bool CanRead { get; }
    public bool CanTimeout { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; }
    public AuthenticatedStream AuthenticatedStream { get; }
    public int ReadTimeout { get; public set; }
    public int WriteTimeout { get; public set; }
    public bool CheckCertRevocationStatus { get; }
    public X509Certificate InternalLocalCertificate { get; }
    public X509Certificate LocalCertificate { get; }
    public X509Certificate RemoteCertificate { get; }
    public SslProtocols SslProtocol { get; }
    public MonoTlsProvider Provider { get; }
    public bool CanRenegotiate { get; }
    public abstract virtual SslStream get_SslStream();
    public abstract virtual Task AuthenticateAsClientAsync(string targetHost, X509CertificateCollection clientCertificates, SslProtocols enabledSslProtocols, bool checkCertificateRevocation);
    public abstract virtual Task AuthenticateAsServerAsync(X509Certificate serverCertificate, bool clientCertificateRequired, SslProtocols enabledSslProtocols, bool checkCertificateRevocation);
    public abstract virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public abstract virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public abstract virtual Task ShutdownAsync();
    public abstract virtual TransportContext get_TransportContext();
    public abstract virtual bool get_IsAuthenticated();
    public abstract virtual bool get_IsMutuallyAuthenticated();
    public abstract virtual bool get_IsEncrypted();
    public abstract virtual bool get_IsSigned();
    public abstract virtual bool get_IsServer();
    public abstract virtual CipherAlgorithmType get_CipherAlgorithm();
    public abstract virtual int get_CipherStrength();
    public abstract virtual HashAlgorithmType get_HashAlgorithm();
    public abstract virtual int get_HashStrength();
    public abstract virtual ExchangeAlgorithmType get_KeyExchangeAlgorithm();
    public abstract virtual int get_KeyExchangeStrength();
    public abstract virtual bool get_CanRead();
    public abstract virtual bool get_CanTimeout();
    public abstract virtual bool get_CanWrite();
    public abstract virtual long get_Length();
    public abstract virtual long get_Position();
    public abstract virtual void SetLength(long value);
    public abstract virtual AuthenticatedStream get_AuthenticatedStream();
    public abstract virtual int get_ReadTimeout();
    public abstract virtual void set_ReadTimeout(int value);
    public abstract virtual int get_WriteTimeout();
    public abstract virtual void set_WriteTimeout(int value);
    public abstract virtual bool get_CheckCertRevocationStatus();
    public abstract virtual X509Certificate get_InternalLocalCertificate();
    public abstract virtual X509Certificate get_LocalCertificate();
    public abstract virtual X509Certificate get_RemoteCertificate();
    public abstract virtual SslProtocols get_SslProtocol();
    public abstract virtual MonoTlsProvider get_Provider();
    public abstract virtual MonoTlsConnectionInfo GetConnectionInfo();
    public abstract virtual bool get_CanRenegotiate();
    public abstract virtual Task RenegotiateAsync(CancellationToken cancellationToken);
}
public enum Mono.Security.Interface.MonoEncryptionPolicy : Enum {
    public int value__;
    public static MonoEncryptionPolicy RequireEncryption;
    public static MonoEncryptionPolicy AllowNoEncryption;
    public static MonoEncryptionPolicy NoEncryption;
}
public class Mono.Security.Interface.MonoLocalCertificateSelectionCallback : MulticastDelegate {
    public MonoLocalCertificateSelectionCallback(object object, IntPtr method);
    public virtual X509Certificate Invoke(string targetHost, X509CertificateCollection localCertificates, X509Certificate remoteCertificate, String[] acceptableIssuers);
    public virtual IAsyncResult BeginInvoke(string targetHost, X509CertificateCollection localCertificates, X509Certificate remoteCertificate, String[] acceptableIssuers, AsyncCallback callback, object object);
    public virtual X509Certificate EndInvoke(IAsyncResult result);
}
public class Mono.Security.Interface.MonoRemoteCertificateValidationCallback : MulticastDelegate {
    public MonoRemoteCertificateValidationCallback(object object, IntPtr method);
    public virtual bool Invoke(string targetHost, X509Certificate certificate, X509Chain chain, MonoSslPolicyErrors sslPolicyErrors);
    public virtual IAsyncResult BeginInvoke(string targetHost, X509Certificate certificate, X509Chain chain, MonoSslPolicyErrors sslPolicyErrors, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
internal class Mono.Security.Interface.MonoServerCertificateSelectionCallback : MulticastDelegate {
    public MonoServerCertificateSelectionCallback(object object, IntPtr method);
    public virtual X509Certificate Invoke(object sender, string hostName);
    public virtual IAsyncResult BeginInvoke(object sender, string hostName, AsyncCallback callback, object object);
    public virtual X509Certificate EndInvoke(IAsyncResult result);
}
[FlagsAttribute]
public enum Mono.Security.Interface.MonoSslPolicyErrors : Enum {
    public int value__;
    public static MonoSslPolicyErrors None;
    public static MonoSslPolicyErrors RemoteCertificateNotAvailable;
    public static MonoSslPolicyErrors RemoteCertificateNameMismatch;
    public static MonoSslPolicyErrors RemoteCertificateChainErrors;
}
public class Mono.Security.Interface.MonoTlsConnectionInfo : object {
    [CompilerGeneratedAttribute]
private CipherSuiteCode <CipherSuiteCode>k__BackingField;
    [CompilerGeneratedAttribute]
private TlsProtocols <ProtocolVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private CipherAlgorithmType <CipherAlgorithmType>k__BackingField;
    [CompilerGeneratedAttribute]
private HashAlgorithmType <HashAlgorithmType>k__BackingField;
    [CompilerGeneratedAttribute]
private ExchangeAlgorithmType <ExchangeAlgorithmType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PeerDomainName>k__BackingField;
    [CLSCompliantAttribute("False")]
public CipherSuiteCode CipherSuiteCode { get; public set; }
    public TlsProtocols ProtocolVersion { get; public set; }
    public CipherAlgorithmType CipherAlgorithmType { get; public set; }
    public HashAlgorithmType HashAlgorithmType { get; public set; }
    public ExchangeAlgorithmType ExchangeAlgorithmType { get; public set; }
    public string PeerDomainName { get; public set; }
    [CompilerGeneratedAttribute]
public CipherSuiteCode get_CipherSuiteCode();
    [CompilerGeneratedAttribute]
public void set_CipherSuiteCode(CipherSuiteCode value);
    [CompilerGeneratedAttribute]
public TlsProtocols get_ProtocolVersion();
    [CompilerGeneratedAttribute]
public void set_ProtocolVersion(TlsProtocols value);
    [CompilerGeneratedAttribute]
public CipherAlgorithmType get_CipherAlgorithmType();
    [CompilerGeneratedAttribute]
public void set_CipherAlgorithmType(CipherAlgorithmType value);
    [CompilerGeneratedAttribute]
public HashAlgorithmType get_HashAlgorithmType();
    [CompilerGeneratedAttribute]
public void set_HashAlgorithmType(HashAlgorithmType value);
    [CompilerGeneratedAttribute]
public ExchangeAlgorithmType get_ExchangeAlgorithmType();
    [CompilerGeneratedAttribute]
public void set_ExchangeAlgorithmType(ExchangeAlgorithmType value);
    [CompilerGeneratedAttribute]
public string get_PeerDomainName();
    [CompilerGeneratedAttribute]
public void set_PeerDomainName(string value);
    public virtual string ToString();
}
public abstract class Mono.Security.Interface.MonoTlsProvider : object {
    public Guid ID { get; }
    public string Name { get; }
    public bool SupportsSslStream { get; }
    public bool SupportsConnectionInfo { get; }
    public bool SupportsMonoExtensions { get; }
    public SslProtocols SupportedProtocols { get; }
    internal bool HasNativeCertificates { get; }
    internal bool SupportsCleanShutdown { get; }
    public abstract virtual Guid get_ID();
    public abstract virtual string get_Name();
    public abstract virtual bool get_SupportsSslStream();
    public abstract virtual bool get_SupportsConnectionInfo();
    public abstract virtual bool get_SupportsMonoExtensions();
    public abstract virtual SslProtocols get_SupportedProtocols();
    public abstract virtual IMonoSslStream CreateSslStream(Stream innerStream, bool leaveInnerStreamOpen, MonoTlsSettings settings);
    internal virtual bool get_HasNativeCertificates();
    internal abstract virtual bool get_SupportsCleanShutdown();
}
public static class Mono.Security.Interface.MonoTlsProviderFactory : object {
    internal static int InternalVersion;
    public static bool IsInitialized { get; }
    public static MonoTlsProvider GetProvider();
    public static bool get_IsInitialized();
    public static void Initialize();
    public static void Initialize(string provider);
    public static bool IsProviderSupported(string provider);
    public static MonoTlsProvider GetProvider(string provider);
    public static HttpWebRequest CreateHttpsRequest(Uri requestUri, MonoTlsProvider provider, MonoTlsSettings settings);
    public static HttpListener CreateHttpListener(X509Certificate certificate, MonoTlsProvider provider, MonoTlsSettings settings);
    public static IMonoSslStream GetMonoSslStream(SslStream stream);
    public static IMonoSslStream GetMonoSslStream(HttpListenerContext context);
}
public class Mono.Security.Interface.MonoTlsSettings : object {
    [CompilerGeneratedAttribute]
private MonoRemoteCertificateValidationCallback <RemoteCertificateValidationCallback>k__BackingField;
    [CompilerGeneratedAttribute]
private MonoLocalCertificateSelectionCallback <ClientCertificateSelectionCallback>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <CertificateValidationTime>k__BackingField;
    [CompilerGeneratedAttribute]
private X509CertificateCollection <TrustAnchors>k__BackingField;
    [CompilerGeneratedAttribute]
private object <UserSettings>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <CertificateSearchPaths>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SendCloseNotify>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <ClientCertificateIssuers>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DisallowUnauthenticatedCertificateRequest>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TlsProtocols> <EnabledProtocols>k__BackingField;
    [CompilerGeneratedAttribute]
private CipherSuiteCode[] <EnabledCiphers>k__BackingField;
    private bool cloned;
    private bool checkCertName;
    private bool checkCertRevocationStatus;
    private Nullable`1<bool> useServicePointManagerCallback;
    private bool skipSystemValidators;
    private bool callbackNeedsChain;
    private ICertificateValidator certificateValidator;
    private static MonoTlsSettings defaultSettings;
    public MonoRemoteCertificateValidationCallback RemoteCertificateValidationCallback { get; public set; }
    public MonoLocalCertificateSelectionCallback ClientCertificateSelectionCallback { get; public set; }
    public bool CheckCertificateName { get; public set; }
    public bool CheckCertificateRevocationStatus { get; public set; }
    public Nullable`1<bool> UseServicePointManagerCallback { get; public set; }
    public bool SkipSystemValidators { get; public set; }
    public bool CallbackNeedsCertificateChain { get; public set; }
    public Nullable`1<DateTime> CertificateValidationTime { get; public set; }
    public X509CertificateCollection TrustAnchors { get; public set; }
    public object UserSettings { get; public set; }
    internal String[] CertificateSearchPaths { get; internal set; }
    internal bool SendCloseNotify { get; internal set; }
    public String[] ClientCertificateIssuers { get; public set; }
    public bool DisallowUnauthenticatedCertificateRequest { get; public set; }
    public Nullable`1<TlsProtocols> EnabledProtocols { get; public set; }
    [CLSCompliantAttribute("False")]
public CipherSuiteCode[] EnabledCiphers { get; public set; }
    public static MonoTlsSettings DefaultSettings { get; public set; }
    [ObsoleteAttribute("Do not use outside System.dll!")]
public ICertificateValidator CertificateValidator { get; }
    private MonoTlsSettings(MonoTlsSettings other);
    [CompilerGeneratedAttribute]
public MonoRemoteCertificateValidationCallback get_RemoteCertificateValidationCallback();
    [CompilerGeneratedAttribute]
public void set_RemoteCertificateValidationCallback(MonoRemoteCertificateValidationCallback value);
    [CompilerGeneratedAttribute]
public MonoLocalCertificateSelectionCallback get_ClientCertificateSelectionCallback();
    [CompilerGeneratedAttribute]
public void set_ClientCertificateSelectionCallback(MonoLocalCertificateSelectionCallback value);
    public bool get_CheckCertificateName();
    public void set_CheckCertificateName(bool value);
    public bool get_CheckCertificateRevocationStatus();
    public void set_CheckCertificateRevocationStatus(bool value);
    public Nullable`1<bool> get_UseServicePointManagerCallback();
    public void set_UseServicePointManagerCallback(Nullable`1<bool> value);
    public bool get_SkipSystemValidators();
    public void set_SkipSystemValidators(bool value);
    public bool get_CallbackNeedsCertificateChain();
    public void set_CallbackNeedsCertificateChain(bool value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_CertificateValidationTime();
    [CompilerGeneratedAttribute]
public void set_CertificateValidationTime(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public X509CertificateCollection get_TrustAnchors();
    [CompilerGeneratedAttribute]
public void set_TrustAnchors(X509CertificateCollection value);
    [CompilerGeneratedAttribute]
public object get_UserSettings();
    [CompilerGeneratedAttribute]
public void set_UserSettings(object value);
    [CompilerGeneratedAttribute]
internal String[] get_CertificateSearchPaths();
    [CompilerGeneratedAttribute]
internal void set_CertificateSearchPaths(String[] value);
    [CompilerGeneratedAttribute]
internal bool get_SendCloseNotify();
    [CompilerGeneratedAttribute]
internal void set_SendCloseNotify(bool value);
    [CompilerGeneratedAttribute]
public String[] get_ClientCertificateIssuers();
    [CompilerGeneratedAttribute]
public void set_ClientCertificateIssuers(String[] value);
    [CompilerGeneratedAttribute]
public bool get_DisallowUnauthenticatedCertificateRequest();
    [CompilerGeneratedAttribute]
public void set_DisallowUnauthenticatedCertificateRequest(bool value);
    [CompilerGeneratedAttribute]
public Nullable`1<TlsProtocols> get_EnabledProtocols();
    [CompilerGeneratedAttribute]
public void set_EnabledProtocols(Nullable`1<TlsProtocols> value);
    [CompilerGeneratedAttribute]
public CipherSuiteCode[] get_EnabledCiphers();
    [CompilerGeneratedAttribute]
public void set_EnabledCiphers(CipherSuiteCode[] value);
    public static MonoTlsSettings get_DefaultSettings();
    public static void set_DefaultSettings(MonoTlsSettings value);
    public static MonoTlsSettings CopyDefaultSettings();
    public ICertificateValidator get_CertificateValidator();
    [ObsoleteAttribute("Do not use outside System.dll!")]
public MonoTlsSettings CloneWithValidator(ICertificateValidator validator);
    public MonoTlsSettings Clone();
}
public class Mono.Security.Interface.TlsException : Exception {
    private Alert alert;
    public Alert Alert { get; }
    public TlsException(Alert alert);
    public TlsException(Alert alert, string message);
    public TlsException(AlertLevel level, AlertDescription description);
    public TlsException(AlertDescription description);
    public TlsException(AlertDescription description, string message);
    public TlsException(AlertDescription description, string format, Object[] args);
    public Alert get_Alert();
}
public enum Mono.Security.Interface.TlsProtocolCode : Enum {
    public short value__;
    public static TlsProtocolCode Tls10;
    public static TlsProtocolCode Tls11;
    public static TlsProtocolCode Tls12;
}
[FlagsAttribute]
public enum Mono.Security.Interface.TlsProtocols : Enum {
    public int value__;
    public static TlsProtocols Zero;
    public static TlsProtocols Tls10Client;
    public static TlsProtocols Tls10Server;
    public static TlsProtocols Tls10;
    public static TlsProtocols Tls11Client;
    public static TlsProtocols Tls11Server;
    public static TlsProtocols Tls11;
    public static TlsProtocols Tls12Client;
    public static TlsProtocols Tls12Server;
    public static TlsProtocols Tls12;
    public static TlsProtocols ClientMask;
    public static TlsProtocols ServerMask;
}
public class Mono.Security.Interface.ValidationResult : object {
    private bool trusted;
    private bool user_denied;
    private int error_code;
    private Nullable`1<MonoSslPolicyErrors> policy_errors;
    public bool Trusted { get; }
    public bool UserDenied { get; }
    public int ErrorCode { get; }
    public Nullable`1<MonoSslPolicyErrors> PolicyErrors { get; }
    public ValidationResult(bool trusted, bool user_denied, int error_code, Nullable`1<MonoSslPolicyErrors> policy_errors);
    internal ValidationResult(bool trusted, bool user_denied, int error_code);
    public bool get_Trusted();
    public bool get_UserDenied();
    public int get_ErrorCode();
    public Nullable`1<MonoSslPolicyErrors> get_PolicyErrors();
}
public class Mono.Security.PKCS7 : object {
    public static ASN1 Attribute(string oid, ASN1 value);
    public static ASN1 AlgorithmIdentifier(string oid);
    public static ASN1 AlgorithmIdentifier(string oid, ASN1 parameters);
    public static ASN1 IssuerAndSerialNumber(X509Certificate x509);
}
[ObsoleteAttribute("Use of this API is highly discouraged, it selects legacy-mode LM/NTLM authentication, which sends your password in very weak encryption over the wire even if the server supports the more secure NTLMv2 / NTLMv2 Session. You need to use the new `Type3Message (Type2Message)' constructor to use the more secure NTLMv2 / NTLMv2 Session authentication modes. These require the Type 2 message from the server to compute the response.")]
public class Mono.Security.Protocol.Ntlm.ChallengeResponse : object {
    private static Byte[] magic;
    private static Byte[] nullEncMagic;
    private bool _disposed;
    private Byte[] _challenge;
    private Byte[] _lmpwd;
    private Byte[] _ntpwd;
    public string Password { get; public set; }
    public Byte[] Challenge { get; public set; }
    public Byte[] LM { get; }
    public Byte[] NT { get; }
    public ChallengeResponse(string password, Byte[] challenge);
    private static ChallengeResponse();
    protected virtual override void Finalize();
    public string get_Password();
    public void set_Password(string value);
    public Byte[] get_Challenge();
    public void set_Challenge(Byte[] value);
    public Byte[] get_LM();
    public Byte[] get_NT();
    public sealed virtual void Dispose();
    private void Dispose(bool disposing);
    private Byte[] GetResponse(Byte[] pwd);
    private Byte[] PrepareDESKey(Byte[] key56bits, int position);
    private Byte[] PasswordToKey(string password, int position);
}
public static class Mono.Security.Protocol.Ntlm.ChallengeResponse2 : object {
    private static Byte[] magic;
    private static Byte[] nullEncMagic;
    private static ChallengeResponse2();
    private static Byte[] Compute_LM(string password, Byte[] challenge);
    private static Byte[] Compute_NTLM_Password(string password);
    private static Byte[] Compute_NTLM(string password, Byte[] challenge);
    private static void Compute_NTLMv2_Session(string password, Byte[] challenge, Byte[]& lm, Byte[]& ntlm);
    private static Byte[] Compute_NTLMv2(Type2Message type2, string username, string password, string domain);
    public static void Compute(Type2Message type2, NtlmAuthLevel level, string username, string password, string domain, Byte[]& lm, Byte[]& ntlm);
    private static Byte[] GetResponse(Byte[] challenge, Byte[] pwd);
    private static Byte[] PrepareDESKey(Byte[] key56bits, int position);
    private static Byte[] PasswordToKey(string password, int position);
}
public abstract class Mono.Security.Protocol.Ntlm.MessageBase : object {
    private static Byte[] header;
    private int _type;
    private NtlmFlags _flags;
    public NtlmFlags Flags { get; public set; }
    public int Type { get; }
    protected MessageBase(int messageType);
    private static MessageBase();
    public NtlmFlags get_Flags();
    public void set_Flags(NtlmFlags value);
    public int get_Type();
    protected Byte[] PrepareMessage(int messageSize);
    protected virtual void Decode(Byte[] message);
    protected bool CheckHeader(Byte[] message);
    public abstract virtual Byte[] GetBytes();
}
public enum Mono.Security.Protocol.Ntlm.NtlmAuthLevel : Enum {
    public int value__;
    public static NtlmAuthLevel LM_and_NTLM;
    public static NtlmAuthLevel LM_and_NTLM_and_try_NTLMv2_Session;
    public static NtlmAuthLevel NTLM_only;
    public static NtlmAuthLevel NTLMv2_only;
}
[FlagsAttribute]
public enum Mono.Security.Protocol.Ntlm.NtlmFlags : Enum {
    public int value__;
    public static NtlmFlags NegotiateUnicode;
    public static NtlmFlags NegotiateOem;
    public static NtlmFlags RequestTarget;
    public static NtlmFlags NegotiateNtlm;
    public static NtlmFlags NegotiateDomainSupplied;
    public static NtlmFlags NegotiateWorkstationSupplied;
    public static NtlmFlags NegotiateAlwaysSign;
    public static NtlmFlags NegotiateNtlm2Key;
    public static NtlmFlags Negotiate128;
    public static NtlmFlags Negotiate56;
}
public static class Mono.Security.Protocol.Ntlm.NtlmSettings : object {
    private static NtlmAuthLevel defaultAuthLevel;
    public static NtlmAuthLevel DefaultAuthLevel { get; public set; }
    private static NtlmSettings();
    public static NtlmAuthLevel get_DefaultAuthLevel();
    public static void set_DefaultAuthLevel(NtlmAuthLevel value);
}
public class Mono.Security.Protocol.Ntlm.Type1Message : MessageBase {
    private string _host;
    private string _domain;
    public string Domain { get; public set; }
    public string Host { get; public set; }
    public Type1Message(Byte[] message);
    public string get_Domain();
    public void set_Domain(string value);
    public string get_Host();
    public void set_Host(string value);
    protected virtual void Decode(Byte[] message);
    public virtual Byte[] GetBytes();
}
public class Mono.Security.Protocol.Ntlm.Type2Message : MessageBase {
    private Byte[] _nonce;
    private string _targetName;
    private Byte[] _targetInfo;
    public Byte[] Nonce { get; public set; }
    public string TargetName { get; }
    public Byte[] TargetInfo { get; }
    public Type2Message(Byte[] message);
    protected virtual override void Finalize();
    public Byte[] get_Nonce();
    public void set_Nonce(Byte[] value);
    public string get_TargetName();
    public Byte[] get_TargetInfo();
    protected virtual void Decode(Byte[] message);
    public virtual Byte[] GetBytes();
}
public class Mono.Security.Protocol.Ntlm.Type3Message : MessageBase {
    private NtlmAuthLevel _level;
    private Byte[] _challenge;
    private string _host;
    private string _domain;
    private string _username;
    private string _password;
    private Type2Message _type2;
    private Byte[] _lm;
    private Byte[] _nt;
    internal static string LegacyAPIWarning;
    [ObsoleteAttribute("Use NtlmSettings.DefaultAuthLevel")]
public static NtlmAuthLevel DefaultAuthLevel { get; public set; }
    public NtlmAuthLevel Level { get; public set; }
    [ObsoleteAttribute("Use of this API is highly discouraged, it selects legacy-mode LM/NTLM authentication, which sends your password in very weak encryption over the wire even if the server supports the more secure NTLMv2 / NTLMv2 Session. You need to use the new `Type3Message (Type2Message)' constructor to use the more secure NTLMv2 / NTLMv2 Session authentication modes. These require the Type 2 message from the server to compute the response.")]
public Byte[] Challenge { get; public set; }
    public string Domain { get; public set; }
    public string Host { get; public set; }
    public string Password { get; public set; }
    public string Username { get; public set; }
    public Byte[] LM { get; }
    public Byte[] NT { get; public set; }
    public Type3Message(Byte[] message);
    public Type3Message(Type2Message type2);
    protected virtual override void Finalize();
    public static NtlmAuthLevel get_DefaultAuthLevel();
    public static void set_DefaultAuthLevel(NtlmAuthLevel value);
    public NtlmAuthLevel get_Level();
    public void set_Level(NtlmAuthLevel value);
    public Byte[] get_Challenge();
    public void set_Challenge(Byte[] value);
    public string get_Domain();
    public void set_Domain(string value);
    public string get_Host();
    public void set_Host(string value);
    public string get_Password();
    public void set_Password(string value);
    public string get_Username();
    public void set_Username(string value);
    public Byte[] get_LM();
    public Byte[] get_NT();
    public void set_NT(Byte[] value);
    protected virtual void Decode(Byte[] message);
    private string DecodeString(Byte[] buffer, int offset, int len);
    private Byte[] EncodeString(string text);
    public virtual Byte[] GetBytes();
}
public class Mono.Security.StrongName : object {
    private RSA rsa;
    private Byte[] publicKey;
    private Byte[] keyToken;
    private string tokenAlgorithm;
    public bool CanSign { get; }
    public RSA RSA { get; public set; }
    public Byte[] PublicKey { get; }
    public Byte[] PublicKeyToken { get; }
    public string TokenAlgorithm { get; public set; }
    public StrongName(int keySize);
    public StrongName(Byte[] data);
    public StrongName(RSA rsa);
    private void InvalidateCache();
    public bool get_CanSign();
    public RSA get_RSA();
    public void set_RSA(RSA value);
    public Byte[] get_PublicKey();
    public Byte[] get_PublicKeyToken();
    private static HashAlgorithm GetHashAlgorithm(string algorithm);
    public string get_TokenAlgorithm();
    public void set_TokenAlgorithm(string value);
    public Byte[] GetBytes();
    private UInt32 RVAtoPosition(UInt32 r, int sections, Byte[] headers);
    private static StrongNameSignature Error(string a);
    private static Byte[] ReadMore(Stream stream, Byte[] a, int newSize);
    internal StrongNameSignature StrongHash(Stream stream, StrongNameOptions options);
    public Byte[] Hash(string fileName);
    public bool Sign(string fileName);
    public bool Verify(string fileName);
    public bool Verify(Stream stream);
    private static bool Verify(RSA rsa, AssemblyHashAlgorithm algorithm, Byte[] hash, Byte[] signature);
}
public class Mono.Security.X509.Extensions.AuthorityKeyIdentifierExtension : X509Extension {
    private Byte[] aki;
    public string Name { get; }
    public Byte[] Identifier { get; public set; }
    public AuthorityKeyIdentifierExtension(ASN1 asn1);
    public AuthorityKeyIdentifierExtension(X509Extension extension);
    protected virtual void Decode();
    protected virtual void Encode();
    public virtual string get_Name();
    public Byte[] get_Identifier();
    public void set_Identifier(Byte[] value);
    public virtual string ToString();
}
public class Mono.Security.X509.Extensions.BasicConstraintsExtension : X509Extension {
    public static int NoPathLengthConstraint;
    private bool cA;
    private int pathLenConstraint;
    public bool CertificateAuthority { get; public set; }
    public string Name { get; }
    public int PathLenConstraint { get; public set; }
    public BasicConstraintsExtension(ASN1 asn1);
    public BasicConstraintsExtension(X509Extension extension);
    protected virtual void Decode();
    protected virtual void Encode();
    public bool get_CertificateAuthority();
    public void set_CertificateAuthority(bool value);
    public virtual string get_Name();
    public int get_PathLenConstraint();
    public void set_PathLenConstraint(int value);
    public virtual string ToString();
}
public class Mono.Security.X509.Extensions.CertificatePoliciesExtension : X509Extension {
    private Hashtable policies;
    public string Name { get; }
    public CertificatePoliciesExtension(ASN1 asn1);
    public CertificatePoliciesExtension(X509Extension extension);
    protected virtual void Decode();
    public virtual string get_Name();
    public virtual string ToString();
}
public class Mono.Security.X509.Extensions.CRLDistributionPointsExtension : X509Extension {
    private List`1<DistributionPoint> dps;
    public string Name { get; }
    public IEnumerable`1<DistributionPoint> DistributionPoints { get; }
    public CRLDistributionPointsExtension(ASN1 asn1);
    public CRLDistributionPointsExtension(X509Extension extension);
    protected virtual void Decode();
    public virtual string get_Name();
    public IEnumerable`1<DistributionPoint> get_DistributionPoints();
    public virtual string ToString();
}
public class Mono.Security.X509.Extensions.ExtendedKeyUsageExtension : X509Extension {
    private ArrayList keyPurpose;
    public ArrayList KeyPurpose { get; }
    public string Name { get; }
    public ExtendedKeyUsageExtension(ASN1 asn1);
    public ExtendedKeyUsageExtension(X509Extension extension);
    protected virtual void Decode();
    protected virtual void Encode();
    public ArrayList get_KeyPurpose();
    public virtual string get_Name();
    public virtual string ToString();
}
internal class Mono.Security.X509.Extensions.GeneralNames : object {
    private ArrayList rfc822Name;
    private ArrayList dnsName;
    private ArrayList directoryNames;
    private ArrayList uris;
    private ArrayList ipAddr;
    private ASN1 asn;
    public String[] RFC822 { get; }
    public String[] DirectoryNames { get; }
    public String[] DNSNames { get; }
    public String[] UniformResourceIdentifiers { get; }
    public String[] IPAddresses { get; }
    public GeneralNames(String[] rfc822s, String[] dnsNames, String[] ipAddresses, String[] uris);
    public GeneralNames(ASN1 sequence);
    public String[] get_RFC822();
    public String[] get_DirectoryNames();
    public String[] get_DNSNames();
    public String[] get_UniformResourceIdentifiers();
    public String[] get_IPAddresses();
    public Byte[] GetBytes();
    public virtual string ToString();
}
public class Mono.Security.X509.Extensions.KeyAttributesExtension : X509Extension {
    private Byte[] keyId;
    private int kubits;
    private DateTime notBefore;
    private DateTime notAfter;
    public Byte[] KeyIdentifier { get; }
    public string Name { get; }
    public DateTime NotAfter { get; }
    public DateTime NotBefore { get; }
    public KeyAttributesExtension(ASN1 asn1);
    public KeyAttributesExtension(X509Extension extension);
    protected virtual void Decode();
    public Byte[] get_KeyIdentifier();
    public virtual string get_Name();
    public DateTime get_NotAfter();
    public DateTime get_NotBefore();
    public bool Support(KeyUsages usage);
    public virtual string ToString();
}
public class Mono.Security.X509.Extensions.KeyUsageExtension : X509Extension {
    private int kubits;
    public KeyUsages KeyUsage { get; public set; }
    public string Name { get; }
    public KeyUsageExtension(ASN1 asn1);
    public KeyUsageExtension(X509Extension extension);
    protected virtual void Decode();
    protected virtual void Encode();
    public KeyUsages get_KeyUsage();
    public void set_KeyUsage(KeyUsages value);
    public virtual string get_Name();
    public bool Support(KeyUsages usage);
    public virtual string ToString();
}
[FlagsAttribute]
public enum Mono.Security.X509.Extensions.KeyUsages : Enum {
    public int value__;
    public static KeyUsages digitalSignature;
    public static KeyUsages nonRepudiation;
    public static KeyUsages keyEncipherment;
    public static KeyUsages dataEncipherment;
    public static KeyUsages keyAgreement;
    public static KeyUsages keyCertSign;
    public static KeyUsages cRLSign;
    public static KeyUsages encipherOnly;
    public static KeyUsages decipherOnly;
    public static KeyUsages none;
}
public class Mono.Security.X509.Extensions.NetscapeCertTypeExtension : X509Extension {
    private int ctbits;
    public string Name { get; }
    public NetscapeCertTypeExtension(ASN1 asn1);
    public NetscapeCertTypeExtension(X509Extension extension);
    protected virtual void Decode();
    public virtual string get_Name();
    public bool Support(CertTypes usage);
    public virtual string ToString();
}
public class Mono.Security.X509.Extensions.PrivateKeyUsagePeriodExtension : X509Extension {
    private DateTime notBefore;
    private DateTime notAfter;
    public string Name { get; }
    public PrivateKeyUsagePeriodExtension(ASN1 asn1);
    public PrivateKeyUsagePeriodExtension(X509Extension extension);
    protected virtual void Decode();
    public virtual string get_Name();
    public virtual string ToString();
}
public class Mono.Security.X509.Extensions.SubjectAltNameExtension : X509Extension {
    private GeneralNames _names;
    public string Name { get; }
    public String[] RFC822 { get; }
    public String[] DNSNames { get; }
    public String[] IPAddresses { get; }
    public String[] UniformResourceIdentifiers { get; }
    public SubjectAltNameExtension(ASN1 asn1);
    public SubjectAltNameExtension(X509Extension extension);
    public SubjectAltNameExtension(String[] rfc822, String[] dnsNames, String[] ipAddresses, String[] uris);
    protected virtual void Decode();
    public virtual string get_Name();
    public String[] get_RFC822();
    public String[] get_DNSNames();
    public String[] get_IPAddresses();
    public String[] get_UniformResourceIdentifiers();
    public virtual string ToString();
}
public class Mono.Security.X509.Extensions.SubjectKeyIdentifierExtension : X509Extension {
    private Byte[] ski;
    public string Name { get; }
    public Byte[] Identifier { get; public set; }
    public SubjectKeyIdentifierExtension(ASN1 asn1);
    public SubjectKeyIdentifierExtension(X509Extension extension);
    protected virtual void Decode();
    protected virtual void Encode();
    public virtual string get_Name();
    public Byte[] get_Identifier();
    public void set_Identifier(Byte[] value);
    public virtual string ToString();
}
public class Mono.Security.X509.PKCS12 : object {
    public static string pbeWithSHAAnd128BitRC4;
    public static string pbeWithSHAAnd40BitRC4;
    public static string pbeWithSHAAnd3KeyTripleDESCBC;
    public static string pbeWithSHAAnd2KeyTripleDESCBC;
    public static string pbeWithSHAAnd128BitRC2CBC;
    public static string pbeWithSHAAnd40BitRC2CBC;
    public static string keyBag;
    public static string pkcs8ShroudedKeyBag;
    public static string certBag;
    public static string crlBag;
    public static string secretBag;
    public static string safeContentsBag;
    public static string x509Certificate;
    public static string sdsiCertificate;
    public static string x509Crl;
    private static int recommendedIterationCount;
    private Byte[] _password;
    private ArrayList _keyBags;
    private ArrayList _secretBags;
    private X509CertificateCollection _certs;
    private bool _keyBagsChanged;
    private bool _secretBagsChanged;
    private bool _certsChanged;
    private int _iterations;
    private ArrayList _safeBags;
    private RandomNumberGenerator _rng;
    public static int CryptoApiPasswordLimit;
    private static int password_max_length;
    unknown string Password {public set; }
    public int IterationCount { get; public set; }
    public ArrayList Keys { get; }
    public ArrayList Secrets { get; }
    public X509CertificateCollection Certificates { get; }
    internal RandomNumberGenerator RNG { get; }
    public static int MaximumPasswordLength { get; public set; }
    public PKCS12(Byte[] data);
    public PKCS12(Byte[] data, string password);
    public PKCS12(Byte[] data, Byte[] password);
    private static PKCS12();
    private void Decode(Byte[] data);
    protected virtual override void Finalize();
    public void set_Password(string value);
    public int get_IterationCount();
    public void set_IterationCount(int value);
    public ArrayList get_Keys();
    public ArrayList get_Secrets();
    public X509CertificateCollection get_Certificates();
    internal RandomNumberGenerator get_RNG();
    private bool Compare(Byte[] expected, Byte[] actual);
    private SymmetricAlgorithm GetSymmetricAlgorithm(string algorithmOid, Byte[] salt, int iterationCount);
    public Byte[] Decrypt(string algorithmOid, Byte[] salt, int iterationCount, Byte[] encryptedData);
    public Byte[] Decrypt(EncryptedData ed);
    public Byte[] Encrypt(string algorithmOid, Byte[] salt, int iterationCount, Byte[] data);
    private DSAParameters GetExistingParameters(Boolean& found);
    private void AddPrivateKey(PrivateKeyInfo pki);
    private void ReadSafeBag(ASN1 safeBag);
    private ASN1 Pkcs8ShroudedKeyBagSafeBag(AsymmetricAlgorithm aa, IDictionary attributes);
    private ASN1 KeyBagSafeBag(AsymmetricAlgorithm aa, IDictionary attributes);
    private ASN1 SecretBagSafeBag(Byte[] secret, IDictionary attributes);
    private ASN1 CertificateSafeBag(X509Certificate x509, IDictionary attributes);
    private Byte[] MAC(Byte[] password, Byte[] salt, int iterations, Byte[] data);
    public Byte[] GetBytes();
    private ContentInfo EncryptedContentInfo(ASN1 safeBags, string algorithmOid);
    public void AddCertificate(X509Certificate cert);
    public void AddCertificate(X509Certificate cert, IDictionary attributes);
    public void RemoveCertificate(X509Certificate cert);
    public void RemoveCertificate(X509Certificate cert, IDictionary attrs);
    private bool CompareAsymmetricAlgorithm(AsymmetricAlgorithm a1, AsymmetricAlgorithm a2);
    public void AddPkcs8ShroudedKeyBag(AsymmetricAlgorithm aa);
    public void AddPkcs8ShroudedKeyBag(AsymmetricAlgorithm aa, IDictionary attributes);
    public void RemovePkcs8ShroudedKeyBag(AsymmetricAlgorithm aa);
    public void AddKeyBag(AsymmetricAlgorithm aa);
    public void AddKeyBag(AsymmetricAlgorithm aa, IDictionary attributes);
    public void RemoveKeyBag(AsymmetricAlgorithm aa);
    public void AddSecretBag(Byte[] secret);
    public void AddSecretBag(Byte[] secret, IDictionary attributes);
    public void RemoveSecretBag(Byte[] secret);
    public AsymmetricAlgorithm GetAsymmetricAlgorithm(IDictionary attrs);
    public Byte[] GetSecret(IDictionary attrs);
    public X509Certificate GetCertificate(IDictionary attrs);
    public IDictionary GetAttributes(AsymmetricAlgorithm aa);
    public IDictionary GetAttributes(X509Certificate cert);
    public void SaveToFile(string filename);
    public sealed virtual object Clone();
    public static int get_MaximumPasswordLength();
    public static void set_MaximumPasswordLength(int value);
    private static Byte[] LoadFile(string filename);
    public static PKCS12 LoadFromFile(string filename);
    public static PKCS12 LoadFromFile(string filename, string password);
}
public class Mono.Security.X509.PKCS5 : object {
    public static string pbeWithMD2AndDESCBC;
    public static string pbeWithMD5AndDESCBC;
    public static string pbeWithMD2AndRC2CBC;
    public static string pbeWithMD5AndRC2CBC;
    public static string pbeWithSHA1AndDESCBC;
    public static string pbeWithSHA1AndRC2CBC;
}
public class Mono.Security.X509.PKCS9 : object {
    public static string friendlyName;
    public static string localKeyId;
}
internal class Mono.Security.X509.SafeBag : object {
    private string _bagOID;
    private ASN1 _asn1;
    public string BagOID { get; }
    public ASN1 ASN1 { get; }
    public SafeBag(string bagOID, ASN1 asn1);
    public string get_BagOID();
    public ASN1 get_ASN1();
}
public class Mono.Security.X509.X501 : object {
    private static Byte[] countryName;
    private static Byte[] organizationName;
    private static Byte[] organizationalUnitName;
    private static Byte[] commonName;
    private static Byte[] localityName;
    private static Byte[] stateOrProvinceName;
    private static Byte[] streetAddress;
    private static Byte[] serialNumber;
    private static Byte[] domainComponent;
    private static Byte[] userid;
    private static Byte[] email;
    private static Byte[] dnQualifier;
    private static Byte[] title;
    private static Byte[] surname;
    private static Byte[] givenName;
    private static Byte[] initial;
    private static X501();
    public static string ToString(ASN1 seq);
    public static string ToString(ASN1 seq, bool reversed, string separator, bool quotes);
    private static void AppendEntry(StringBuilder sb, ASN1 entry, bool quotes);
    private static AttributeTypeAndValue GetAttributeFromOid(string attributeType);
    private static bool IsOid(string oid);
    private static AttributeTypeAndValue ReadAttribute(string value, Int32& pos);
    private static bool IsHex(char c);
    private static string ReadHex(string value, Int32& pos);
    private static int ReadEscaped(StringBuilder sb, string value, int pos);
    private static int ReadQuoted(StringBuilder sb, string value, int pos);
    private static string ReadValue(string value, Int32& pos);
    public static ASN1 FromString(string rdn);
}
public abstract class Mono.Security.X509.X509Builder : object {
    private static string defaultHash;
    private string hashName;
    public string Hash { get; public set; }
    protected abstract virtual ASN1 ToBeSigned(string hashName);
    protected string GetOid(string hashName);
    public string get_Hash();
    public void set_Hash(string value);
    public virtual Byte[] Sign(AsymmetricAlgorithm aa);
    private Byte[] Build(ASN1 tbs, string hashoid, Byte[] signature);
    public virtual Byte[] Sign(RSA key);
    public virtual Byte[] Sign(DSA key);
}
public class Mono.Security.X509.X509Certificate : object {
    private ASN1 decoder;
    private Byte[] m_encodedcert;
    private DateTime m_from;
    private DateTime m_until;
    private ASN1 issuer;
    private string m_issuername;
    private string m_keyalgo;
    private Byte[] m_keyalgoparams;
    private ASN1 subject;
    private string m_subject;
    private Byte[] m_publickey;
    private Byte[] signature;
    private string m_signaturealgo;
    private Byte[] m_signaturealgoparams;
    private Byte[] certhash;
    private RSA _rsa;
    private DSA _dsa;
    internal static string OID_DSA;
    internal static string OID_RSA;
    internal static string OID_ECC;
    private int version;
    private Byte[] serialnumber;
    private Byte[] issuerUniqueID;
    private Byte[] subjectUniqueID;
    private X509ExtensionCollection extensions;
    private static string encoding_error;
    public DSA DSA { get; public set; }
    public X509ExtensionCollection Extensions { get; }
    public Byte[] Hash { get; }
    public string IssuerName { get; }
    public string KeyAlgorithm { get; }
    public Byte[] KeyAlgorithmParameters { get; public set; }
    public Byte[] PublicKey { get; }
    public RSA RSA { get; public set; }
    public Byte[] RawData { get; }
    public Byte[] SerialNumber { get; }
    public Byte[] Signature { get; }
    public string SignatureAlgorithm { get; }
    public Byte[] SignatureAlgorithmParameters { get; }
    public string SubjectName { get; }
    public DateTime ValidFrom { get; }
    public DateTime ValidUntil { get; }
    public int Version { get; }
    public bool IsCurrent { get; }
    public Byte[] IssuerUniqueIdentifier { get; }
    public Byte[] SubjectUniqueIdentifier { get; }
    public bool IsSelfSigned { get; }
    public X509Certificate(Byte[] data);
    protected X509Certificate(SerializationInfo info, StreamingContext context);
    private static X509Certificate();
    private void Parse(Byte[] data);
    private Byte[] GetUnsignedBigInteger(Byte[] integer);
    public DSA get_DSA();
    public void set_DSA(DSA value);
    public X509ExtensionCollection get_Extensions();
    public Byte[] get_Hash();
    public virtual string get_IssuerName();
    public virtual string get_KeyAlgorithm();
    public virtual Byte[] get_KeyAlgorithmParameters();
    public virtual void set_KeyAlgorithmParameters(Byte[] value);
    public virtual Byte[] get_PublicKey();
    public virtual RSA get_RSA();
    public virtual void set_RSA(RSA value);
    public virtual Byte[] get_RawData();
    public virtual Byte[] get_SerialNumber();
    public virtual Byte[] get_Signature();
    public virtual string get_SignatureAlgorithm();
    public virtual Byte[] get_SignatureAlgorithmParameters();
    public virtual string get_SubjectName();
    public virtual DateTime get_ValidFrom();
    public virtual DateTime get_ValidUntil();
    public int get_Version();
    public bool get_IsCurrent();
    public bool WasCurrent(DateTime instant);
    public Byte[] get_IssuerUniqueIdentifier();
    public Byte[] get_SubjectUniqueIdentifier();
    internal bool VerifySignature(DSA dsa);
    internal bool VerifySignature(RSA rsa);
    public bool VerifySignature(AsymmetricAlgorithm aa);
    public bool CheckSignature(Byte[] hash, string hashAlgorithm, Byte[] signature);
    public bool get_IsSelfSigned();
    public ASN1 GetIssuerName();
    public ASN1 GetSubjectName();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    private static Byte[] PEM(string type, Byte[] data);
}
public class Mono.Security.X509.X509CertificateBuilder : X509Builder {
    private byte version;
    private Byte[] sn;
    private string issuer;
    private DateTime notBefore;
    private DateTime notAfter;
    private string subject;
    private AsymmetricAlgorithm aa;
    private Byte[] issuerUniqueID;
    private Byte[] subjectUniqueID;
    private X509ExtensionCollection extensions;
    public byte Version { get; public set; }
    public Byte[] SerialNumber { get; public set; }
    public string IssuerName { get; public set; }
    public DateTime NotBefore { get; public set; }
    public DateTime NotAfter { get; public set; }
    public string SubjectName { get; public set; }
    public AsymmetricAlgorithm SubjectPublicKey { get; public set; }
    public Byte[] IssuerUniqueId { get; public set; }
    public Byte[] SubjectUniqueId { get; public set; }
    public X509ExtensionCollection Extensions { get; }
    public X509CertificateBuilder(byte version);
    public byte get_Version();
    public void set_Version(byte value);
    public Byte[] get_SerialNumber();
    public void set_SerialNumber(Byte[] value);
    public string get_IssuerName();
    public void set_IssuerName(string value);
    public DateTime get_NotBefore();
    public void set_NotBefore(DateTime value);
    public DateTime get_NotAfter();
    public void set_NotAfter(DateTime value);
    public string get_SubjectName();
    public void set_SubjectName(string value);
    public AsymmetricAlgorithm get_SubjectPublicKey();
    public void set_SubjectPublicKey(AsymmetricAlgorithm value);
    public Byte[] get_IssuerUniqueId();
    public void set_IssuerUniqueId(Byte[] value);
    public Byte[] get_SubjectUniqueId();
    public void set_SubjectUniqueId(Byte[] value);
    public X509ExtensionCollection get_Extensions();
    private ASN1 SubjectPublicKeyInfo();
    private Byte[] UniqueIdentifier(Byte[] id);
    protected virtual ASN1 ToBeSigned(string oid);
}
[DefaultMemberAttribute("Item")]
public class Mono.Security.X509.X509CertificateCollection : CollectionBase {
    public X509Certificate Item { get; public set; }
    public X509CertificateCollection(X509Certificate[] value);
    public X509CertificateCollection(X509CertificateCollection value);
    public X509Certificate get_Item(int index);
    public void set_Item(int index, X509Certificate value);
    public int Add(X509Certificate value);
    public void AddRange(X509Certificate[] value);
    public void AddRange(X509CertificateCollection value);
    public bool Contains(X509Certificate value);
    public void CopyTo(X509Certificate[] array, int index);
    public X509CertificateEnumerator GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public virtual int GetHashCode();
    public int IndexOf(X509Certificate value);
    public void Insert(int index, X509Certificate value);
    public void Remove(X509Certificate value);
    private bool Compare(Byte[] array1, Byte[] array2);
}
public class Mono.Security.X509.X509Chain : object {
    private X509CertificateCollection roots;
    private X509CertificateCollection certs;
    private X509Certificate _root;
    private X509CertificateCollection _chain;
    private X509ChainStatusFlags _status;
    public X509CertificateCollection Chain { get; }
    public X509Certificate Root { get; }
    public X509ChainStatusFlags Status { get; }
    public X509CertificateCollection TrustAnchors { get; public set; }
    public X509Chain(X509CertificateCollection chain);
    public X509CertificateCollection get_Chain();
    public X509Certificate get_Root();
    public X509ChainStatusFlags get_Status();
    public X509CertificateCollection get_TrustAnchors();
    public void set_TrustAnchors(X509CertificateCollection value);
    public void LoadCertificate(X509Certificate x509);
    public void LoadCertificates(X509CertificateCollection collection);
    public X509Certificate FindByIssuerName(string issuerName);
    public bool Build(X509Certificate leaf);
    public void Reset();
    private bool IsValid(X509Certificate cert);
    private X509Certificate FindCertificateParent(X509Certificate child);
    private X509Certificate FindCertificateRoot(X509Certificate potentialRoot);
    private bool IsTrusted(X509Certificate potentialTrusted);
    private bool IsParent(X509Certificate child, X509Certificate parent);
}
[FlagsAttribute]
public enum Mono.Security.X509.X509ChainStatusFlags : Enum {
    public int value__;
    public static X509ChainStatusFlags InvalidBasicConstraints;
    public static X509ChainStatusFlags NoError;
    public static X509ChainStatusFlags NotSignatureValid;
    public static X509ChainStatusFlags NotTimeNested;
    public static X509ChainStatusFlags NotTimeValid;
    public static X509ChainStatusFlags PartialChain;
    public static X509ChainStatusFlags UntrustedRoot;
}
[DefaultMemberAttribute("Item")]
public class Mono.Security.X509.X509Crl : object {
    private string issuer;
    private byte version;
    private DateTime thisUpdate;
    private DateTime nextUpdate;
    private ArrayList entries;
    private string signatureOID;
    private Byte[] signature;
    private X509ExtensionCollection extensions;
    private Byte[] encoded;
    private Byte[] hash_value;
    public ArrayList Entries { get; }
    public X509CrlEntry Item { get; }
    public X509CrlEntry Item { get; }
    public X509ExtensionCollection Extensions { get; }
    public Byte[] Hash { get; }
    public string IssuerName { get; }
    public DateTime NextUpdate { get; }
    public DateTime ThisUpdate { get; }
    public string SignatureAlgorithm { get; }
    public Byte[] Signature { get; }
    public Byte[] RawData { get; }
    public byte Version { get; }
    public bool IsCurrent { get; }
    public X509Crl(Byte[] crl);
    private void Parse(Byte[] crl);
    public ArrayList get_Entries();
    public X509CrlEntry get_Item(int index);
    public X509CrlEntry get_Item(Byte[] serialNumber);
    public X509ExtensionCollection get_Extensions();
    public Byte[] get_Hash();
    public string get_IssuerName();
    public DateTime get_NextUpdate();
    public DateTime get_ThisUpdate();
    public string get_SignatureAlgorithm();
    public Byte[] get_Signature();
    public Byte[] get_RawData();
    public byte get_Version();
    public bool get_IsCurrent();
    public bool WasCurrent(DateTime instant);
    public Byte[] GetBytes();
    private bool Compare(Byte[] array1, Byte[] array2);
    public X509CrlEntry GetCrlEntry(X509Certificate x509);
    public X509CrlEntry GetCrlEntry(Byte[] serialNumber);
    public bool VerifySignature(X509Certificate x509);
    internal bool VerifySignature(DSA dsa);
    internal bool VerifySignature(RSA rsa);
    public bool VerifySignature(AsymmetricAlgorithm aa);
    public static X509Crl CreateFromFile(string filename);
}
public class Mono.Security.X509.X509Extension : object {
    protected string extnOid;
    protected bool extnCritical;
    protected ASN1 extnValue;
    public ASN1 ASN1 { get; }
    public string Oid { get; }
    public bool Critical { get; public set; }
    public string Name { get; }
    public ASN1 Value { get; }
    public X509Extension(ASN1 asn1);
    public X509Extension(X509Extension extension);
    protected virtual void Decode();
    protected virtual void Encode();
    public ASN1 get_ASN1();
    public string get_Oid();
    public bool get_Critical();
    public void set_Critical(bool value);
    public virtual string get_Name();
    public ASN1 get_Value();
    public virtual bool Equals(object obj);
    public Byte[] GetBytes();
    public virtual int GetHashCode();
    private void WriteLine(StringBuilder sb, int n, int pos);
    public virtual string ToString();
}
[DefaultMemberAttribute("Item")]
public class Mono.Security.X509.X509ExtensionCollection : CollectionBase {
    private bool readOnly;
    public X509Extension Item { get; }
    public X509Extension Item { get; }
    public X509ExtensionCollection(ASN1 asn1);
    public int Add(X509Extension extension);
    public void AddRange(X509Extension[] extension);
    public void AddRange(X509ExtensionCollection collection);
    public bool Contains(X509Extension extension);
    public bool Contains(string oid);
    public void CopyTo(X509Extension[] extensions, int index);
    public int IndexOf(X509Extension extension);
    public int IndexOf(string oid);
    public void Insert(int index, X509Extension extension);
    public void Remove(X509Extension extension);
    public void Remove(string oid);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public X509Extension get_Item(int index);
    public X509Extension get_Item(string oid);
    public Byte[] GetBytes();
}
public class Mono.Security.X509.X509Store : object {
    private string _storePath;
    private X509CertificateCollection _certificates;
    private ArrayList _crls;
    private bool _crl;
    private bool _newFormat;
    private string _name;
    public X509CertificateCollection Certificates { get; }
    public ArrayList Crls { get; }
    public string Name { get; }
    internal X509Store(string path, bool crl, bool newFormat);
    public X509CertificateCollection get_Certificates();
    public ArrayList get_Crls();
    public string get_Name();
    public void Clear();
    private void ClearCertificates();
    private void ClearCrls();
    public void Import(X509Certificate certificate);
    public void Import(X509Crl crl);
    public void Remove(X509Certificate certificate);
    public void Remove(X509Crl crl);
    private void ImportNewFormat(X509Certificate certificate);
    private void RemoveNewFormat(X509Certificate certificate);
    private string GetUniqueNameWithSerial(X509Certificate certificate);
    private string GetUniqueName(X509Certificate certificate, Byte[] serial);
    private string GetUniqueName(X509Crl crl);
    private Byte[] GetUniqueName(X509ExtensionCollection extensions, Byte[] serial);
    private string GetUniqueName(string method, Byte[] name, string fileExtension);
    private Byte[] Load(string filename);
    private X509Certificate LoadCertificate(string filename);
    private X509Crl LoadCrl(string filename);
    private bool CheckStore(string path, bool throwException);
    private X509CertificateCollection BuildCertificatesCollection(string storeName);
    private ArrayList BuildCrlsCollection(string storeName);
    private void ImportPrivateKey(X509Certificate certificate, CspParameters cspParams);
}
public class Mono.Security.X509.X509StoreManager : object {
    private static string _userPath;
    private static string _localMachinePath;
    private static string _newUserPath;
    private static string _newLocalMachinePath;
    private static X509Stores _userStore;
    private static X509Stores _machineStore;
    private static X509Stores _newUserStore;
    private static X509Stores _newMachineStore;
    internal static string CurrentUserPath { get; }
    internal static string LocalMachinePath { get; }
    internal static string NewCurrentUserPath { get; }
    internal static string NewLocalMachinePath { get; }
    public static X509Stores CurrentUser { get; }
    public static X509Stores LocalMachine { get; }
    public static X509Stores NewCurrentUser { get; }
    public static X509Stores NewLocalMachine { get; }
    public static X509CertificateCollection IntermediateCACertificates { get; }
    public static ArrayList IntermediateCACrls { get; }
    public static X509CertificateCollection TrustedRootCertificates { get; }
    public static ArrayList TrustedRootCACrls { get; }
    public static X509CertificateCollection UntrustedCertificates { get; }
    internal static string get_CurrentUserPath();
    internal static string get_LocalMachinePath();
    internal static string get_NewCurrentUserPath();
    internal static string get_NewLocalMachinePath();
    public static X509Stores get_CurrentUser();
    public static X509Stores get_LocalMachine();
    public static X509Stores get_NewCurrentUser();
    public static X509Stores get_NewLocalMachine();
    public static X509CertificateCollection get_IntermediateCACertificates();
    public static ArrayList get_IntermediateCACrls();
    public static X509CertificateCollection get_TrustedRootCertificates();
    public static ArrayList get_TrustedRootCACrls();
    public static X509CertificateCollection get_UntrustedCertificates();
}
public class Mono.Security.X509.X509Stores : object {
    private string _storePath;
    private bool _newFormat;
    private X509Store _personal;
    private X509Store _other;
    private X509Store _intermediate;
    private X509Store _trusted;
    private X509Store _untrusted;
    public X509Store Personal { get; }
    public X509Store OtherPeople { get; }
    public X509Store IntermediateCA { get; }
    public X509Store TrustedRoot { get; }
    public X509Store Untrusted { get; }
    internal X509Stores(string path, bool newFormat);
    public X509Store get_Personal();
    public X509Store get_OtherPeople();
    public X509Store get_IntermediateCA();
    public X509Store get_TrustedRoot();
    public X509Store get_Untrusted();
    public void Clear();
    public X509Store Open(string storeName, bool create);
}
public class Mono.Security.X509.X520 : object {
}
[CLSCompliantAttribute("False")]
public class Mono.Xml.MiniParser : object {
    private static int INPUT_RANGE;
    private static UInt16[] tbl;
    protected static String[] errors;
    protected int line;
    protected int col;
    protected Int32[] twoCharBuff;
    protected bool splitCData;
    private static MiniParser();
    public void Reset();
    protected static bool StrEquals(string str, StringBuilder sb, int sbStart, int len);
    protected void FatalErr(string descr);
    protected static int Xlat(int charCode, int state);
    public void Parse(IReader reader, IHandler handler);
}
[CLSCompliantAttribute("False")]
public class Mono.Xml.SecurityParser : MiniParser {
    private SecurityElement root;
    private string xmldoc;
    private int pos;
    private SecurityElement current;
    private Stack stack;
    public void LoadXml(string xml);
    public SecurityElement ToXml();
    public sealed virtual int Read();
    public sealed virtual void OnStartParsing(MiniParser parser);
    public sealed virtual void OnStartElement(string name, IAttrList attrs);
    public sealed virtual void OnEndElement(string name);
    public sealed virtual void OnChars(string ch);
    public sealed virtual void OnEndParsing(MiniParser parser);
}
