internal AssemblyRef : object {
internal string SystemConfiguration
internal string System
public string EcmaPublicKey
public string FrameworkPublicKeyFull
public string FrameworkPublicKeyFull2
public string MicrosoftPublicKey
public string MicrosoftJScript
public string MicrosoftVSDesigner
public string SystemData
public string SystemDesign
public string SystemDrawing
public string SystemWeb
public string SystemWebExtensions
public string SystemWindowsForms
}
internal Consts : object {
public string MonoVersion
public string MonoCompany
public string MonoProduct
public string MonoCopyright
public int MonoCorlibVersion
public string FxVersion
public string FxFileVersion
public string EnvironmentVersion
public string VsVersion
public string VsFileVersion
private string PublicKeyToken
public string AssemblyI18N
public string AssemblyMicrosoft_JScript
public string AssemblyMicrosoft_VisualStudio
public string AssemblyMicrosoft_VisualStudio_Web
public string AssemblyMicrosoft_VSDesigner
public string AssemblyMono_Http
public string AssemblyMono_Posix
public string AssemblyMono_Security
public string AssemblyMono_Messaging_RabbitMQ
public string AssemblyCorlib
public string AssemblySystem
public string AssemblySystem_Data
public string AssemblySystem_Design
public string AssemblySystem_DirectoryServices
public string AssemblySystem_Drawing
public string AssemblySystem_Drawing_Design
public string AssemblySystem_Messaging
public string AssemblySystem_Security
public string AssemblySystem_ServiceProcess
public string AssemblySystem_Web
public string AssemblySystem_Windows_Forms
public string AssemblySystem_2_0
public string AssemblySystemCore_3_5
public string AssemblySystem_Core
public string WindowsBase_3_0
public string AssemblyWindowsBase
public string AssemblyPresentationCore_3_5
public string AssemblyPresentationCore_4_0
public string AssemblyPresentationFramework_3_5
public string AssemblySystemServiceModel_3_0
}
internal Locale : object {
public string GetText(string msg)
public string GetText(string fmt, Object[] args)
}
public Mono.Math.BigInteger : object {
private UInt32 length
private UInt32[] data
private UInt32 DEFAULT_LEN
internal UInt32[] smallPrimes
private string WouldReturnNegVal
private RandomNumberGenerator rng
private RandomNumberGenerator Rng
public void .ctor(Sign sign, UInt32 len)
public void .ctor(BigInteger bi)
public void .ctor(BigInteger bi, UInt32 len)
public void .ctor(Byte[] inData)
public void .ctor(UInt32[] inData)
public void .ctor(UInt32 ui)
public void .ctor(ulong ul)
public BigInteger op_Implicit(UInt32 value)
public BigInteger op_Implicit(int value)
public BigInteger op_Implicit(ulong value)
public BigInteger Parse(string number)
public BigInteger op_Addition(BigInteger bi1, BigInteger bi2)
public BigInteger op_Subtraction(BigInteger bi1, BigInteger bi2)
public int op_Modulus(BigInteger bi, int i)
public UInt32 op_Modulus(BigInteger bi, UInt32 ui)
public BigInteger op_Modulus(BigInteger bi1, BigInteger bi2)
public BigInteger op_Division(BigInteger bi, int i)
public BigInteger op_Division(BigInteger bi1, BigInteger bi2)
public BigInteger op_Multiply(BigInteger bi1, BigInteger bi2)
public BigInteger op_Multiply(BigInteger bi, int i)
public BigInteger op_LeftShift(BigInteger bi1, int shiftVal)
public BigInteger op_RightShift(BigInteger bi1, int shiftVal)
public BigInteger Add(BigInteger bi1, BigInteger bi2)
public BigInteger Subtract(BigInteger bi1, BigInteger bi2)
public int Modulus(BigInteger bi, int i)
public UInt32 Modulus(BigInteger bi, UInt32 ui)
public BigInteger Modulus(BigInteger bi1, BigInteger bi2)
public BigInteger Divid(BigInteger bi, int i)
public BigInteger Divid(BigInteger bi1, BigInteger bi2)
public BigInteger Multiply(BigInteger bi1, BigInteger bi2)
public BigInteger Multiply(BigInteger bi, int i)
private RandomNumberGenerator get_Rng()
public BigInteger GenerateRandom(int bits, RandomNumberGenerator rng)
public BigInteger GenerateRandom(int bits)
public void Randomize(RandomNumberGenerator rng)
public void Randomize()
public int BitCount()
public bool TestBit(UInt32 bitNum)
public bool TestBit(int bitNum)
public void SetBit(UInt32 bitNum)
public void ClearBit(UInt32 bitNum)
public void SetBit(UInt32 bitNum, bool value)
public int LowestSetBit()
public Byte[] GetBytes()
public bool op_Equality(BigInteger bi1, UInt32 ui)
public bool op_Inequality(BigInteger bi1, UInt32 ui)
public bool op_Equality(BigInteger bi1, BigInteger bi2)
public bool op_Inequality(BigInteger bi1, BigInteger bi2)
public bool op_GreaterThan(BigInteger bi1, BigInteger bi2)
public bool op_LessThan(BigInteger bi1, BigInteger bi2)
public bool op_GreaterThanOrEqual(BigInteger bi1, BigInteger bi2)
public bool op_LessThanOrEqual(BigInteger bi1, BigInteger bi2)
public Sign Compare(BigInteger bi)
public string ToString(UInt32 radix)
public string ToString(UInt32 radix, string characterSet)
private void Normalize()
public void Clear()
public int GetHashCode()
public string ToString()
public bool Equals(object o)
public BigInteger GCD(BigInteger bi)
public BigInteger ModInverse(BigInteger modulus)
public BigInteger ModPow(BigInteger exp, BigInteger n)
public bool IsProbablePrime()
public BigInteger NextHighestPrime(BigInteger bi)
public BigInteger GeneratePseudoPrime(int bits)
public void Incr2()
}
public Mono.Math.Prime.ConfidenceFactor : Enum {
public int value__
public ConfidenceFactor ExtraLow
public ConfidenceFactor Low
public ConfidenceFactor Medium
public ConfidenceFactor High
public ConfidenceFactor ExtraHigh
public ConfidenceFactor Provable
}
public Mono.Math.Prime.Generator.NextPrimeFinder : SequentialSearchPrimeGeneratorBase {
protected BigInteger GenerateSearchBase(int bits, object Context)
}
public Mono.Math.Prime.Generator.PrimeGeneratorBase : object {
public ConfidenceFactor Confidence
public PrimalityTest PrimalityTest
public int TrialDivisionBounds
public ConfidenceFactor get_Confidence()
public PrimalityTest get_PrimalityTest()
public int get_TrialDivisionBounds()
protected bool PostTrialDivisionTests(BigInteger bi)
public BigInteger GenerateNewPrime(int bits)
}
public Mono.Math.Prime.Generator.SequentialSearchPrimeGeneratorBase : PrimeGeneratorBase {
protected BigInteger GenerateSearchBase(int bits, object context)
public BigInteger GenerateNewPrime(int bits)
public BigInteger GenerateNewPrime(int bits, object context)
protected bool IsPrimeAcceptable(BigInteger bi, object context)
}
public Mono.Math.Prime.PrimalityTest : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public bool Invoke(BigInteger bi, ConfidenceFactor confidence)
public IAsyncResult BeginInvoke(BigInteger bi, ConfidenceFactor confidence, AsyncCallback callback, object object)
public bool EndInvoke(IAsyncResult result)
}
public Mono.Math.Prime.PrimalityTests : object {
private int GetSPPRounds(BigInteger bi, ConfidenceFactor confidence)
public bool Test(BigInteger n, ConfidenceFactor confidence)
public bool RabinMillerTest(BigInteger n, ConfidenceFactor confidence)
public bool SmallPrimeSppTest(BigInteger bi, ConfidenceFactor confidence)
}
public Mono.Security.ASN1 : object {
private byte m_nTag
private Byte[] m_aValue
private ArrayList elist
public int Count
public byte Tag
public int Length
public Byte[] Value
public ASN1 Item
public void .ctor(byte tag)
public void .ctor(byte tag, Byte[] data)
public void .ctor(Byte[] data)
public int get_Count()
public byte get_Tag()
public int get_Length()
public Byte[] get_Value()
public void set_Value(Byte[] value)
private bool CompareArray(Byte[] array1, Byte[] array2)
public bool Equals(Byte[] asn1)
public bool CompareValue(Byte[] value)
public ASN1 Add(ASN1 asn1)
public Byte[] GetBytes()
protected void Decode(Byte[] asn1, Int32& anPos, int anLength)
protected void DecodeTLV(Byte[] asn1, Int32& pos, Byte& tag, Int32& length, Byte[]& content)
public ASN1 get_Item(int index)
public ASN1 Element(int index, byte anTag)
public string ToString()
public void SaveToFile(string filename)
}
public Mono.Security.ASN1Convert : object {
public ASN1 FromDateTime(DateTime dt)
public ASN1 FromInt32(int value)
public ASN1 FromOid(string oid)
public ASN1 FromUnsignedBigInteger(Byte[] big)
public int ToInt32(ASN1 asn1)
public string ToOid(ASN1 asn1)
public DateTime ToDateTime(ASN1 time)
}
public Mono.Security.Authenticode.AuthenticodeBase : object {
public string spcIndirectDataContext
private Byte[] fileblock
private FileStream fs
private int blockNo
private int blockLength
private int peOffset
private int dirSecurityOffset
private int dirSecuritySize
private int coffSymbolTableOffset
internal int PEOffset
internal int CoffSymbolTableOffset
internal int SecurityOffset
internal int get_PEOffset()
internal int get_CoffSymbolTableOffset()
internal int get_SecurityOffset()
internal void Open(string filename)
internal void Close()
internal void ReadFirstBlock()
internal int ProcessFirstBlock()
internal Byte[] GetSecurityEntry()
internal Byte[] GetHash(HashAlgorithm hash)
protected Byte[] HashFile(string fileName, string hashName)
}
public Mono.Security.Authenticode.AuthenticodeDeformatter : AuthenticodeBase {
private string filename
private Byte[] hash
private X509CertificateCollection coll
private ASN1 signedHash
private DateTime timestamp
private X509Certificate signingCertificate
private int reason
private bool trustedRoot
private bool trustedTimestampRoot
private Byte[] entry
private X509Chain signerChain
private X509Chain timestampChain
public string FileName
public Byte[] Hash
public int Reason
public Byte[] Signature
public DateTime Timestamp
public X509CertificateCollection Certificates
public X509Certificate SigningCertificate
public void .ctor(string fileName)
public string get_FileName()
public void set_FileName(string value)
public Byte[] get_Hash()
public int get_Reason()
public bool IsTrusted()
public Byte[] get_Signature()
public DateTime get_Timestamp()
public X509CertificateCollection get_Certificates()
public X509Certificate get_SigningCertificate()
private bool CheckSignature(string fileName)
private bool CompareIssuerSerial(string issuer, Byte[] serial, X509Certificate x509)
private bool VerifySignature(SignedData sd, Byte[] calculatedMessageDigest, HashAlgorithm ha)
private bool VerifyCounterSignature(SignerInfo cs, Byte[] signature)
private void Reset()
}
public Mono.Security.Authenticode.AuthenticodeFormatter : AuthenticodeBase {
private Authority authority
private X509CertificateCollection certs
private ArrayList crls
private string hash
private RSA rsa
private Uri timestamp
private ASN1 authenticode
private SignedData pkcs7
private string description
private Uri url
private string signedData
private string countersignature
private string spcStatementType
private string spcSpOpusInfo
private string spcPelmageData
private string commercialCodeSigning
private string timestampCountersignature
private Byte[] obsolete
public Authority Authority
public X509CertificateCollection Certificates
public ArrayList Crl
public string Hash
public RSA RSA
public Uri TimestampUrl
public string Description
public Uri Url
public Authority get_Authority()
public void set_Authority(Authority value)
public X509CertificateCollection get_Certificates()
public ArrayList get_Crl()
public string get_Hash()
public void set_Hash(string value)
public RSA get_RSA()
public void set_RSA(RSA value)
public Uri get_TimestampUrl()
public void set_TimestampUrl(Uri value)
public string get_Description()
public void set_Description(string value)
public Uri get_Url()
public void set_Url(Uri value)
private ASN1 AlgorithmIdentifier(string oid)
private ASN1 Attribute(string oid, ASN1 value)
private ASN1 Opus(string description, string url)
private Byte[] Header(Byte[] fileHash, string hashAlgorithm)
public ASN1 TimestampRequest(Byte[] signature)
public void ProcessTimestamp(Byte[] response)
private Byte[] Timestamp(Byte[] signature)
private bool Save(string fileName, Byte[] asn)
public bool Sign(string fileName)
public bool Timestamp(string fileName)
}
public Mono.Security.Authenticode.Authority : Enum {
public int value__
public Authority Individual
public Authority Commercial
public Authority Maximum
}
public Mono.Security.Authenticode.PrivateKey : object {
private UInt32 magic
private bool encrypted
private RSA rsa
private bool weak
private int keyType
public bool Encrypted
public int KeyType
public RSA RSA
public bool Weak
public void .ctor(Byte[] data, string password)
public bool get_Encrypted()
public int get_KeyType()
public void set_KeyType(int value)
public RSA get_RSA()
public void set_RSA(RSA value)
public bool get_Weak()
public void set_Weak(bool value)
private Byte[] DeriveKey(Byte[] salt, string password)
private bool Decode(Byte[] pvk, string password)
public void Save(string filename)
public void Save(string filename, string password)
public PrivateKey CreateFromFile(string filename)
public PrivateKey CreateFromFile(string filename, string password)
}
public Mono.Security.Authenticode.SoftwarePublisherCertificate : object {
private SignedData pkcs7
private string header
private string footer
public X509CertificateCollection Certificates
public ArrayList Crls
public void .ctor(Byte[] data)
public X509CertificateCollection get_Certificates()
public ArrayList get_Crls()
public Byte[] GetBytes()
public SoftwarePublisherCertificate CreateFromFile(string filename)
private Byte[] PEM(Byte[] data)
}
internal Mono.Security.BitConverterLE : object {
private Byte[] GetUShortBytes(Byte* bytes)
private Byte[] GetUIntBytes(Byte* bytes)
private Byte[] GetULongBytes(Byte* bytes)
internal Byte[] GetBytes(bool value)
internal Byte[] GetBytes(char value)
internal Byte[] GetBytes(short value)
internal Byte[] GetBytes(int value)
internal Byte[] GetBytes(long value)
internal Byte[] GetBytes(ushort value)
internal Byte[] GetBytes(UInt32 value)
internal Byte[] GetBytes(ulong value)
internal Byte[] GetBytes(float value)
internal Byte[] GetBytes(double value)
private void UShortFromBytes(Byte* dst, Byte[] src, int startIndex)
private void UIntFromBytes(Byte* dst, Byte[] src, int startIndex)
private void ULongFromBytes(Byte* dst, Byte[] src, int startIndex)
internal bool ToBoolean(Byte[] value, int startIndex)
internal char ToChar(Byte[] value, int startIndex)
internal short ToInt16(Byte[] value, int startIndex)
internal int ToInt32(Byte[] value, int startIndex)
internal long ToInt64(Byte[] value, int startIndex)
internal ushort ToUInt16(Byte[] value, int startIndex)
internal UInt32 ToUInt32(Byte[] value, int startIndex)
internal ulong ToUInt64(Byte[] value, int startIndex)
internal float ToSingle(Byte[] value, int startIndex)
internal double ToDouble(Byte[] value, int startIndex)
}
public Mono.Security.Cryptography.ARC4Managed : RC4 {
private Byte[] key
private Byte[] state
private byte x
private byte y
private bool m_disposed
public Byte[] Key
public bool CanReuseTransform
public bool CanTransformMultipleBlocks
public int InputBlockSize
public int OutputBlockSize
protected void Finalize()
protected void Dispose(bool disposing)
public Byte[] get_Key()
public void set_Key(Byte[] value)
public bool get_CanReuseTransform()
public ICryptoTransform CreateEncryptor(Byte[] rgbKey, Byte[] rgvIV)
public ICryptoTransform CreateDecryptor(Byte[] rgbKey, Byte[] rgvIV)
public void GenerateIV()
public void GenerateKey()
public bool get_CanTransformMultipleBlocks()
public int get_InputBlockSize()
public int get_OutputBlockSize()
private void KeySetup(Byte[] key)
private void CheckInput(Byte[] inputBuffer, int inputOffset, int inputCount)
public int TransformBlock(Byte[] inputBuffer, int inputOffset, int inputCount, Byte[] outputBuffer, int outputOffset)
private int InternalTransformBlock(Byte[] inputBuffer, int inputOffset, int inputCount, Byte[] outputBuffer, int outputOffset)
public Byte[] TransformFinalBlock(Byte[] inputBuffer, int inputOffset, int inputCount)
}
public Mono.Security.Cryptography.BlockProcessor : object {
private ICryptoTransform transform
private Byte[] block
private int blockSize
private int blockCount
public void .ctor(ICryptoTransform transform)
public void .ctor(ICryptoTransform transform, int blockSize)
protected void Finalize()
public void Initialize()
public void Core(Byte[] rgb)
public void Core(Byte[] rgb, int ib, int cb)
public Byte[] Final()
}
public Mono.Security.Cryptography.CryptoConvert : object {
private int ToInt32LE(Byte[] bytes, int offset)
private UInt32 ToUInt32LE(Byte[] bytes, int offset)
private Byte[] GetBytesLE(int val)
private Byte[] Trim(Byte[] array)
public RSA FromCapiPrivateKeyBlob(Byte[] blob)
public RSA FromCapiPrivateKeyBlob(Byte[] blob, int offset)
public DSA FromCapiPrivateKeyBlobDSA(Byte[] blob)
public DSA FromCapiPrivateKeyBlobDSA(Byte[] blob, int offset)
public Byte[] ToCapiPrivateKeyBlob(RSA rsa)
public Byte[] ToCapiPrivateKeyBlob(DSA dsa)
public RSA FromCapiPublicKeyBlob(Byte[] blob)
public RSA FromCapiPublicKeyBlob(Byte[] blob, int offset)
public DSA FromCapiPublicKeyBlobDSA(Byte[] blob)
public DSA FromCapiPublicKeyBlobDSA(Byte[] blob, int offset)
public Byte[] ToCapiPublicKeyBlob(RSA rsa)
public Byte[] ToCapiPublicKeyBlob(DSA dsa)
public RSA FromCapiKeyBlob(Byte[] blob)
public RSA FromCapiKeyBlob(Byte[] blob, int offset)
public DSA FromCapiKeyBlobDSA(Byte[] blob)
public DSA FromCapiKeyBlobDSA(Byte[] blob, int offset)
public Byte[] ToCapiKeyBlob(AsymmetricAlgorithm keypair, bool includePrivateKey)
public Byte[] ToCapiKeyBlob(RSA rsa, bool includePrivateKey)
public Byte[] ToCapiKeyBlob(DSA dsa, bool includePrivateKey)
public string ToHex(Byte[] input)
private byte FromHexChar(char c)
public Byte[] FromHex(string hex)
}
public Mono.Security.Cryptography.DHKeyGeneration : Enum {
public int value__
public DHKeyGeneration Random
public DHKeyGeneration Static
}
public Mono.Security.Cryptography.DHParameters : ValueType {
public Byte[] P
public Byte[] G
public Byte[] X
}
public Mono.Security.Cryptography.DiffieHellman : AsymmetricAlgorithm {
public DiffieHellman Create()
public DiffieHellman Create(string algName)
public Byte[] CreateKeyExchange()
public Byte[] DecryptKeyExchange(Byte[] keyex)
public DHParameters ExportParameters(bool includePrivate)
public void ImportParameters(DHParameters parameters)
private Byte[] GetNamedParam(SecurityElement se, string param)
public void FromXmlString(string xmlString)
public string ToXmlString(bool includePrivateParameters)
}
public Mono.Security.Cryptography.DiffieHellmanManaged : DiffieHellman {
private BigInteger m_P
private BigInteger m_G
private BigInteger m_X
private bool m_Disposed
private Byte[] m_OAKLEY768
private Byte[] m_OAKLEY1024
private Byte[] m_OAKLEY1536
public string KeyExchangeAlgorithm
public string SignatureAlgorithm
public void .ctor(int bitLength, int l, DHKeyGeneration method)
public void .ctor(Byte[] p, Byte[] g, Byte[] x)
public void .ctor(Byte[] p, Byte[] g, int l)
private void Initialize(BigInteger p, BigInteger g, BigInteger x, int secretLen, bool checkInput)
public Byte[] CreateKeyExchange()
public Byte[] DecryptKeyExchange(Byte[] keyEx)
public string get_KeyExchangeAlgorithm()
public string get_SignatureAlgorithm()
protected void Dispose(bool disposing)
public DHParameters ExportParameters(bool includePrivateParameters)
public void ImportParameters(DHParameters parameters)
protected void Finalize()
private void GenerateKey(int bitlen, DHKeyGeneration keygen, BigInteger& p, BigInteger& g)
}
internal Mono.Security.Cryptography.HMAC : KeyedHashAlgorithm {
private HashAlgorithm hash
private bool hashing
private Byte[] innerPad
private Byte[] outerPad
public Byte[] Key
public Byte[] get_Key()
public void set_Key(Byte[] value)
public void .ctor(HashAlgorithm ha, Byte[] rgbKey)
public void Initialize()
protected Byte[] HashFinal()
protected void HashCore(Byte[] array, int ibStart, int cbSize)
private void initializePad()
}
public Mono.Security.Cryptography.KeyBuilder : object {
private RandomNumberGenerator rng
private RandomNumberGenerator Rng
private RandomNumberGenerator get_Rng()
public Byte[] Key(int size)
public Byte[] IV(int size)
}
public Mono.Security.Cryptography.KeyPairPersistence : object {
private bool _userPathExists
private string _userPath
private bool _machinePathExists
private string _machinePath
private CspParameters _params
private string _keyvalue
private string _filename
private string _container
private object lockobj
public string Filename
public string KeyValue
public CspParameters Parameters
private string UserPath
private string MachinePath
private bool CanChange
private bool UseDefaultKeyContainer
private bool UseMachineKeyStore
private string ContainerName
public void .ctor(CspParameters parameters)
public void .ctor(CspParameters parameters, string keyPair)
public string get_Filename()
public string get_KeyValue()
public void set_KeyValue(string value)
public CspParameters get_Parameters()
public bool Load()
public void Save()
public void Remove()
private string get_UserPath()
private string get_MachinePath()
internal bool _CanSecure(string root)
internal bool _ProtectUser(string path)
internal bool _ProtectMachine(string path)
internal bool _IsUserProtected(string path)
internal bool _IsMachineProtected(string path)
private bool CanSecure(string path)
private bool ProtectUser(string path)
private bool ProtectMachine(string path)
private bool IsUserProtected(string path)
private bool IsMachineProtected(string path)
private bool get_CanChange()
private bool get_UseDefaultKeyContainer()
private bool get_UseMachineKeyStore()
private string get_ContainerName()
private CspParameters Copy(CspParameters p)
private void FromXml(string xml)
private string ToXml()
}
public Mono.Security.Cryptography.MD2 : HashAlgorithm {
public MD2 Create()
public MD2 Create(string hashName)
}
public Mono.Security.Cryptography.MD2Managed : MD2 {
private Byte[] state
private Byte[] checksum
private Byte[] buffer
private int count
private Byte[] x
private Byte[] PI_SUBST
private Byte[] Padding(int nLength)
public void Initialize()
protected void HashCore(Byte[] array, int ibStart, int cbSize)
protected Byte[] HashFinal()
private void MD2Transform(Byte[] state, Byte[] checksum, Byte[] block, int index)
}
public Mono.Security.Cryptography.MD4 : HashAlgorithm {
public MD4 Create()
public MD4 Create(string hashName)
}
public Mono.Security.Cryptography.MD4Managed : MD4 {
private UInt32[] state
private Byte[] buffer
private UInt32[] count
private UInt32[] x
private int S11
private int S12
private int S13
private int S14
private int S21
private int S22
private int S23
private int S24
private int S31
private int S32
private int S33
private int S34
private Byte[] digest
public void Initialize()
protected void HashCore(Byte[] array, int ibStart, int cbSize)
protected Byte[] HashFinal()
private Byte[] Padding(int nLength)
private UInt32 F(UInt32 x, UInt32 y, UInt32 z)
private UInt32 G(UInt32 x, UInt32 y, UInt32 z)
private UInt32 H(UInt32 x, UInt32 y, UInt32 z)
private UInt32 ROL(UInt32 x, byte n)
private void FF(UInt32& a, UInt32 b, UInt32 c, UInt32 d, UInt32 x, byte s)
private void GG(UInt32& a, UInt32 b, UInt32 c, UInt32 d, UInt32 x, byte s)
private void HH(UInt32& a, UInt32 b, UInt32 c, UInt32 d, UInt32 x, byte s)
private void Encode(Byte[] output, UInt32[] input)
private void Decode(UInt32[] output, Byte[] input, int index)
private void MD4Transform(UInt32[] state, Byte[] block, int index)
}
internal Mono.Security.Cryptography.MD5SHA1 : HashAlgorithm {
private HashAlgorithm md5
private HashAlgorithm sha
private bool hashing
public void Initialize()
protected Byte[] HashFinal()
protected void HashCore(Byte[] array, int ibStart, int cbSize)
public Byte[] CreateSignature(RSA rsa)
public bool VerifySignature(RSA rsa, Byte[] rgbSignature)
}
public Mono.Security.Cryptography.PKCS1 : object {
private Byte[] emptySHA1
private Byte[] emptySHA256
private Byte[] emptySHA384
private Byte[] emptySHA512
private bool Compare(Byte[] array1, Byte[] array2)
private Byte[] xor(Byte[] array1, Byte[] array2)
private Byte[] GetEmptyHash(HashAlgorithm hash)
public Byte[] I2OSP(int x, int size)
public Byte[] I2OSP(Byte[] x, int size)
public Byte[] OS2IP(Byte[] x)
public Byte[] RSAEP(RSA rsa, Byte[] m)
public Byte[] RSADP(RSA rsa, Byte[] c)
public Byte[] RSASP1(RSA rsa, Byte[] m)
public Byte[] RSAVP1(RSA rsa, Byte[] s)
public Byte[] Encrypt_OAEP(RSA rsa, HashAlgorithm hash, RandomNumberGenerator rng, Byte[] M)
public Byte[] Decrypt_OAEP(RSA rsa, HashAlgorithm hash, Byte[] C)
public Byte[] Encrypt_v15(RSA rsa, RandomNumberGenerator rng, Byte[] M)
public Byte[] Decrypt_v15(RSA rsa, Byte[] C)
public Byte[] Sign_v15(RSA rsa, HashAlgorithm hash, Byte[] hashValue)
internal Byte[] Sign_v15(RSA rsa, string hashName, Byte[] hashValue)
public bool Verify_v15(RSA rsa, HashAlgorithm hash, Byte[] hashValue, Byte[] signature)
internal bool Verify_v15(RSA rsa, string hashName, Byte[] hashValue, Byte[] signature)
public bool Verify_v15(RSA rsa, HashAlgorithm hash, Byte[] hashValue, Byte[] signature, bool tryNonStandardEncoding)
public Byte[] Encode_v15(HashAlgorithm hash, Byte[] hashValue, int emLength)
public Byte[] MGF1(HashAlgorithm hash, Byte[] mgfSeed, int maskLen)
internal string HashNameFromOid(string oid, bool throwOnError)
internal HashAlgorithm CreateFromOid(string oid)
internal HashAlgorithm CreateFromName(string name)
}
public Mono.Security.Cryptography.PKCS8 : object {
public KeyInfo GetType(Byte[] data)
}
public Mono.Security.Cryptography.RC4 : SymmetricAlgorithm {
private KeySizes[] s_legalBlockSizes
private KeySizes[] s_legalKeySizes
public Byte[] IV
public Byte[] get_IV()
public void set_IV(Byte[] value)
public RC4 Create()
public RC4 Create(string algName)
}
public Mono.Security.Cryptography.RSAManaged : RSA {
private int defaultKeySize
private bool isCRTpossible
private bool keyBlinding
private bool keypairGenerated
private bool m_disposed
private BigInteger d
private BigInteger p
private BigInteger q
private BigInteger dp
private BigInteger dq
private BigInteger qInv
private BigInteger n
private BigInteger e
private KeyGeneratedEventHandler KeyGenerated
public int KeySize
public string KeyExchangeAlgorithm
public bool PublicOnly
public string SignatureAlgorithm
public bool UseKeyBlinding
public bool IsCrtPossible
public void .ctor(int keySize)
protected void Finalize()
private void GenerateKeyPair()
public int get_KeySize()
public string get_KeyExchangeAlgorithm()
public bool get_PublicOnly()
public string get_SignatureAlgorithm()
public Byte[] DecryptValue(Byte[] rgb)
public Byte[] EncryptValue(Byte[] rgb)
public RSAParameters ExportParameters(bool includePrivateParameters)
public void ImportParameters(RSAParameters parameters)
protected void Dispose(bool disposing)
public void add_KeyGenerated(KeyGeneratedEventHandler value)
public void remove_KeyGenerated(KeyGeneratedEventHandler value)
public string ToXmlString(bool includePrivateParameters)
public bool get_UseKeyBlinding()
public void set_UseKeyBlinding(bool value)
public bool get_IsCrtPossible()
private Byte[] GetPaddedValue(BigInteger value, int length)
}
public Mono.Security.Cryptography.SHA224 : HashAlgorithm {
public SHA224 Create()
public SHA224 Create(string hashName)
}
public Mono.Security.Cryptography.SHA224Managed : SHA224 {
private int BLOCK_SIZE_BYTES
private UInt32[] _H
private ulong count
private Byte[] _ProcessingBuffer
private int _ProcessingBufferCount
private UInt32[] buff
private UInt32 Ch(UInt32 u, UInt32 v, UInt32 w)
private UInt32 Maj(UInt32 u, UInt32 v, UInt32 w)
private UInt32 Ro0(UInt32 x)
private UInt32 Ro1(UInt32 x)
private UInt32 Sig0(UInt32 x)
private UInt32 Sig1(UInt32 x)
protected void HashCore(Byte[] rgb, int start, int size)
protected Byte[] HashFinal()
public void Initialize()
private void ProcessBlock(Byte[] inputBuffer, int inputOffset)
private void ProcessFinalBlock(Byte[] inputBuffer, int inputOffset, int inputCount)
internal void AddLength(ulong length, Byte[] buffer, int position)
}
internal Mono.Security.Cryptography.SHAConstants : object {
public UInt32[] K1
}
internal Mono.Security.Cryptography.SymmetricTransform : object {
protected SymmetricAlgorithm algo
protected bool encrypt
protected int BlockSizeByte
protected Byte[] temp
protected Byte[] temp2
private Byte[] workBuff
private Byte[] workout
protected PaddingMode padmode
protected int FeedBackByte
private bool m_disposed
protected bool lastBlock
private RandomNumberGenerator _rng
public bool CanTransformMultipleBlocks
public bool CanReuseTransform
public int InputBlockSize
public int OutputBlockSize
private bool KeepLastBlock
public void .ctor(SymmetricAlgorithm symmAlgo, bool encryption, Byte[] rgbIV)
protected void Finalize()
private void System.IDisposable.Dispose()
protected void Dispose(bool disposing)
public bool get_CanTransformMultipleBlocks()
public bool get_CanReuseTransform()
public int get_InputBlockSize()
public int get_OutputBlockSize()
protected void Transform(Byte[] input, Byte[] output)
protected void ECB(Byte[] input, Byte[] output)
protected void CBC(Byte[] input, Byte[] output)
protected void CFB(Byte[] input, Byte[] output)
protected void OFB(Byte[] input, Byte[] output)
protected void CTS(Byte[] input, Byte[] output)
private void CheckInput(Byte[] inputBuffer, int inputOffset, int inputCount)
public int TransformBlock(Byte[] inputBuffer, int inputOffset, int inputCount, Byte[] outputBuffer, int outputOffset)
private bool get_KeepLastBlock()
private int InternalTransformBlock(Byte[] inputBuffer, int inputOffset, int inputCount, Byte[] outputBuffer, int outputOffset)
private void Random(Byte[] buffer, int start, int length)
private void ThrowBadPaddingException(PaddingMode padding, int length, int position)
protected Byte[] FinalEncrypt(Byte[] inputBuffer, int inputOffset, int inputCount)
protected Byte[] FinalDecrypt(Byte[] inputBuffer, int inputOffset, int inputCount)
public Byte[] TransformFinalBlock(Byte[] inputBuffer, int inputOffset, int inputCount)
}
public Mono.Security.Interface.Alert : object {
private AlertLevel level
private AlertDescription description
public AlertLevel Level
public AlertDescription Description
public string Message
public bool IsWarning
public bool IsCloseNotify
public AlertLevel get_Level()
public AlertDescription get_Description()
public string get_Message()
public bool get_IsWarning()
public bool get_IsCloseNotify()
public void .ctor(AlertDescription description)
public void .ctor(AlertLevel level, AlertDescription description)
private void inferAlertLevel()
public string ToString()
public string GetAlertMessage(AlertDescription description)
}
public Mono.Security.Interface.AlertDescription : Enum {
public byte value__
public AlertDescription CloseNotify
public AlertDescription UnexpectedMessage
public AlertDescription BadRecordMAC
public AlertDescription DecryptionFailed_RESERVED
public AlertDescription RecordOverflow
public AlertDescription DecompressionFailure
public AlertDescription HandshakeFailure
public AlertDescription NoCertificate_RESERVED
public AlertDescription BadCertificate
public AlertDescription UnsupportedCertificate
public AlertDescription CertificateRevoked
public AlertDescription CertificateExpired
public AlertDescription CertificateUnknown
public AlertDescription IlegalParameter
public AlertDescription UnknownCA
public AlertDescription AccessDenied
public AlertDescription DecodeError
public AlertDescription DecryptError
public AlertDescription ExportRestriction
public AlertDescription ProtocolVersion
public AlertDescription InsuficientSecurity
public AlertDescription InternalError
public AlertDescription UserCancelled
public AlertDescription NoRenegotiation
public AlertDescription UnsupportedExtension
}
public Mono.Security.Interface.AlertLevel : Enum {
public byte value__
public AlertLevel Warning
public AlertLevel Fatal
}
public Mono.Security.Interface.CertificateValidationHelper : object {
private string SecurityLibrary
private bool noX509Chain
private bool supportsTrustAnchors
public bool SupportsX509Chain
public bool SupportsTrustAnchors
public bool get_SupportsX509Chain()
public bool get_SupportsTrustAnchors()
internal ICertificateValidator2 GetInternalValidator(MonoTlsSettings settings, MonoTlsProvider provider)
internal ICertificateValidator2 GetDefaultValidator(MonoTlsSettings settings, MonoTlsProvider provider)
public ICertificateValidator GetValidator(MonoTlsSettings settings)
}
public Mono.Security.Interface.CipherAlgorithmType : Enum {
public int value__
public CipherAlgorithmType None
public CipherAlgorithmType Aes128
public CipherAlgorithmType Aes256
public CipherAlgorithmType AesGcm128
public CipherAlgorithmType AesGcm256
}
public Mono.Security.Interface.CipherSuiteCode : Enum {
public ushort value__
public CipherSuiteCode TLS_NULL_WITH_NULL_NULL
public CipherSuiteCode TLS_RSA_WITH_NULL_MD5
public CipherSuiteCode TLS_RSA_WITH_NULL_SHA
public CipherSuiteCode TLS_RSA_EXPORT_WITH_RC4_40_MD5
public CipherSuiteCode TLS_RSA_WITH_RC4_128_MD5
public CipherSuiteCode TLS_RSA_WITH_RC4_128_SHA
public CipherSuiteCode TLS_RSA_EXPORT_WITH_RC2_CBC_40_MD5
public CipherSuiteCode TLS_RSA_WITH_IDEA_CBC_SHA
public CipherSuiteCode TLS_RSA_EXPORT_WITH_DES40_CBC_SHA
public CipherSuiteCode TLS_RSA_WITH_DES_CBC_SHA
public CipherSuiteCode TLS_RSA_WITH_3DES_EDE_CBC_SHA
public CipherSuiteCode TLS_DH_DSS_EXPORT_WITH_DES40_CBC_SHA
public CipherSuiteCode TLS_DH_DSS_WITH_DES_CBC_SHA
public CipherSuiteCode TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA
public CipherSuiteCode TLS_DH_RSA_EXPORT_WITH_DES40_CBC_SHA
public CipherSuiteCode TLS_DH_RSA_WITH_DES_CBC_SHA
public CipherSuiteCode TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA
public CipherSuiteCode TLS_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA
public CipherSuiteCode TLS_DHE_DSS_WITH_DES_CBC_SHA
public CipherSuiteCode TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA
public CipherSuiteCode TLS_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA
public CipherSuiteCode TLS_DHE_RSA_WITH_DES_CBC_SHA
public CipherSuiteCode TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA
public CipherSuiteCode TLS_DH_anon_EXPORT_WITH_RC4_40_MD5
public CipherSuiteCode TLS_DH_anon_WITH_RC4_128_MD5
public CipherSuiteCode TLS_DH_anon_EXPORT_WITH_DES40_CBC_SHA
public CipherSuiteCode TLS_DH_anon_WITH_DES_CBC_SHA
public CipherSuiteCode TLS_DH_anon_WITH_3DES_EDE_CBC_SHA
public CipherSuiteCode TLS_RSA_WITH_AES_128_CBC_SHA
public CipherSuiteCode TLS_DH_DSS_WITH_AES_128_CBC_SHA
public CipherSuiteCode TLS_DH_RSA_WITH_AES_128_CBC_SHA
public CipherSuiteCode TLS_DHE_DSS_WITH_AES_128_CBC_SHA
public CipherSuiteCode TLS_DHE_RSA_WITH_AES_128_CBC_SHA
public CipherSuiteCode TLS_DH_anon_WITH_AES_128_CBC_SHA
public CipherSuiteCode TLS_RSA_WITH_AES_256_CBC_SHA
public CipherSuiteCode TLS_DH_DSS_WITH_AES_256_CBC_SHA
public CipherSuiteCode TLS_DH_RSA_WITH_AES_256_CBC_SHA
public CipherSuiteCode TLS_DHE_DSS_WITH_AES_256_CBC_SHA
public CipherSuiteCode TLS_DHE_RSA_WITH_AES_256_CBC_SHA
public CipherSuiteCode TLS_DH_anon_WITH_AES_256_CBC_SHA
public CipherSuiteCode TLS_RSA_WITH_CAMELLIA_128_CBC_SHA
public CipherSuiteCode TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA
public CipherSuiteCode TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA
public CipherSuiteCode TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA
public CipherSuiteCode TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA
public CipherSuiteCode TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA
public CipherSuiteCode TLS_RSA_WITH_CAMELLIA_256_CBC_SHA
public CipherSuiteCode TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA
public CipherSuiteCode TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA
public CipherSuiteCode TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA
public CipherSuiteCode TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA
public CipherSuiteCode TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA
public CipherSuiteCode TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256
public CipherSuiteCode TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA256
public CipherSuiteCode TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA256
public CipherSuiteCode TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA256
public CipherSuiteCode TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256
public CipherSuiteCode TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA256
public CipherSuiteCode TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256
public CipherSuiteCode TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA256
public CipherSuiteCode TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA256
public CipherSuiteCode TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA256
public CipherSuiteCode TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256
public CipherSuiteCode TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA256
public CipherSuiteCode TLS_RSA_WITH_SEED_CBC_SHA
public CipherSuiteCode TLS_DH_DSS_WITH_SEED_CBC_SHA
public CipherSuiteCode TLS_DH_RSA_WITH_SEED_CBC_SHA
public CipherSuiteCode TLS_DHE_DSS_WITH_SEED_CBC_SHA
public CipherSuiteCode TLS_DHE_RSA_WITH_SEED_CBC_SHA
public CipherSuiteCode TLS_DH_anon_WITH_SEED_CBC_SHA
public CipherSuiteCode TLS_PSK_WITH_RC4_128_SHA
public CipherSuiteCode TLS_PSK_WITH_3DES_EDE_CBC_SHA
public CipherSuiteCode TLS_PSK_WITH_AES_128_CBC_SHA
public CipherSuiteCode TLS_PSK_WITH_AES_256_CBC_SHA
public CipherSuiteCode TLS_DHE_PSK_WITH_RC4_128_SHA
public CipherSuiteCode TLS_DHE_PSK_WITH_3DES_EDE_CBC_SHA
public CipherSuiteCode TLS_DHE_PSK_WITH_AES_128_CBC_SHA
public CipherSuiteCode TLS_DHE_PSK_WITH_AES_256_CBC_SHA
public CipherSuiteCode TLS_RSA_PSK_WITH_RC4_128_SHA
public CipherSuiteCode TLS_RSA_PSK_WITH_3DES_EDE_CBC_SHA
public CipherSuiteCode TLS_RSA_PSK_WITH_AES_128_CBC_SHA
public CipherSuiteCode TLS_RSA_PSK_WITH_AES_256_CBC_SHA
public CipherSuiteCode TLS_ECDH_ECDSA_WITH_NULL_SHA
public CipherSuiteCode TLS_ECDH_ECDSA_WITH_RC4_128_SHA
public CipherSuiteCode TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA
public CipherSuiteCode TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA
public CipherSuiteCode TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA
public CipherSuiteCode TLS_ECDHE_ECDSA_WITH_NULL_SHA
public CipherSuiteCode TLS_ECDHE_ECDSA_WITH_RC4_128_SHA
public CipherSuiteCode TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA
public CipherSuiteCode TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA
public CipherSuiteCode TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA
public CipherSuiteCode TLS_ECDH_RSA_WITH_NULL_SHA
public CipherSuiteCode TLS_ECDH_RSA_WITH_RC4_128_SHA
public CipherSuiteCode TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA
public CipherSuiteCode TLS_ECDH_RSA_WITH_AES_128_CBC_SHA
public CipherSuiteCode TLS_ECDH_RSA_WITH_AES_256_CBC_SHA
public CipherSuiteCode TLS_ECDHE_RSA_WITH_NULL_SHA
public CipherSuiteCode TLS_ECDHE_RSA_WITH_RC4_128_SHA
public CipherSuiteCode TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA
public CipherSuiteCode TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA
public CipherSuiteCode TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA
public CipherSuiteCode TLS_ECDH_anon_WITH_NULL_SHA
public CipherSuiteCode TLS_ECDH_anon_WITH_RC4_128_SHA
public CipherSuiteCode TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA
public CipherSuiteCode TLS_ECDH_anon_WITH_AES_128_CBC_SHA
public CipherSuiteCode TLS_ECDH_anon_WITH_AES_256_CBC_SHA
public CipherSuiteCode TLS_PSK_WITH_NULL_SHA
public CipherSuiteCode TLS_DHE_PSK_WITH_NULL_SHA
public CipherSuiteCode TLS_RSA_PSK_WITH_NULL_SHA
public CipherSuiteCode TLS_SRP_SHA_WITH_3DES_EDE_CBC_SHA
public CipherSuiteCode TLS_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA
public CipherSuiteCode TLS_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA
public CipherSuiteCode TLS_SRP_SHA_WITH_AES_128_CBC_SHA
public CipherSuiteCode TLS_SRP_SHA_RSA_WITH_AES_128_CBC_SHA
public CipherSuiteCode TLS_SRP_SHA_DSS_WITH_AES_128_CBC_SHA
public CipherSuiteCode TLS_SRP_SHA_WITH_AES_256_CBC_SHA
public CipherSuiteCode TLS_SRP_SHA_RSA_WITH_AES_256_CBC_SHA
public CipherSuiteCode TLS_SRP_SHA_DSS_WITH_AES_256_CBC_SHA
public CipherSuiteCode TLS_RSA_WITH_NULL_SHA256
public CipherSuiteCode TLS_RSA_WITH_AES_128_CBC_SHA256
public CipherSuiteCode TLS_RSA_WITH_AES_256_CBC_SHA256
public CipherSuiteCode TLS_DH_DSS_WITH_AES_128_CBC_SHA256
public CipherSuiteCode TLS_DH_RSA_WITH_AES_128_CBC_SHA256
public CipherSuiteCode TLS_DHE_DSS_WITH_AES_128_CBC_SHA256
public CipherSuiteCode TLS_DHE_RSA_WITH_AES_128_CBC_SHA256
public CipherSuiteCode TLS_DH_DSS_WITH_AES_256_CBC_SHA256
public CipherSuiteCode TLS_DH_RSA_WITH_AES_256_CBC_SHA256
public CipherSuiteCode TLS_DHE_DSS_WITH_AES_256_CBC_SHA256
public CipherSuiteCode TLS_DHE_RSA_WITH_AES_256_CBC_SHA256
public CipherSuiteCode TLS_DH_anon_WITH_AES_128_CBC_SHA256
public CipherSuiteCode TLS_DH_anon_WITH_AES_256_CBC_SHA256
public CipherSuiteCode TLS_RSA_WITH_AES_128_GCM_SHA256
public CipherSuiteCode TLS_RSA_WITH_AES_256_GCM_SHA384
public CipherSuiteCode TLS_DHE_RSA_WITH_AES_128_GCM_SHA256
public CipherSuiteCode TLS_DHE_RSA_WITH_AES_256_GCM_SHA384
public CipherSuiteCode TLS_DH_RSA_WITH_AES_128_GCM_SHA256
public CipherSuiteCode TLS_DH_RSA_WITH_AES_256_GCM_SHA384
public CipherSuiteCode TLS_DHE_DSS_WITH_AES_128_GCM_SHA256
public CipherSuiteCode TLS_DHE_DSS_WITH_AES_256_GCM_SHA384
public CipherSuiteCode TLS_DH_DSS_WITH_AES_128_GCM_SHA256
public CipherSuiteCode TLS_DH_DSS_WITH_AES_256_GCM_SHA384
public CipherSuiteCode TLS_DH_anon_WITH_AES_128_GCM_SHA256
public CipherSuiteCode TLS_DH_anon_WITH_AES_256_GCM_SHA384
public CipherSuiteCode TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256
public CipherSuiteCode TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384
public CipherSuiteCode TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256
public CipherSuiteCode TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384
public CipherSuiteCode TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256
public CipherSuiteCode TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384
public CipherSuiteCode TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256
public CipherSuiteCode TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384
public CipherSuiteCode TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256
public CipherSuiteCode TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384
public CipherSuiteCode TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256
public CipherSuiteCode TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384
public CipherSuiteCode TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256
public CipherSuiteCode TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384
public CipherSuiteCode TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256
public CipherSuiteCode TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384
public CipherSuiteCode TLS_PSK_WITH_AES_128_GCM_SHA256
public CipherSuiteCode TLS_PSK_WITH_AES_256_GCM_SHA384
public CipherSuiteCode TLS_DHE_PSK_WITH_AES_128_GCM_SHA256
public CipherSuiteCode TLS_DHE_PSK_WITH_AES_256_GCM_SHA384
public CipherSuiteCode TLS_RSA_PSK_WITH_AES_128_GCM_SHA256
public CipherSuiteCode TLS_RSA_PSK_WITH_AES_256_GCM_SHA384
public CipherSuiteCode TLS_PSK_WITH_AES_128_CBC_SHA256
public CipherSuiteCode TLS_PSK_WITH_AES_256_CBC_SHA384
public CipherSuiteCode TLS_PSK_WITH_NULL_SHA256
public CipherSuiteCode TLS_PSK_WITH_NULL_SHA384
public CipherSuiteCode TLS_DHE_PSK_WITH_AES_128_CBC_SHA256
public CipherSuiteCode TLS_DHE_PSK_WITH_AES_256_CBC_SHA384
public CipherSuiteCode TLS_DHE_PSK_WITH_NULL_SHA256
public CipherSuiteCode TLS_DHE_PSK_WITH_NULL_SHA384
public CipherSuiteCode TLS_RSA_PSK_WITH_AES_128_CBC_SHA256
public CipherSuiteCode TLS_RSA_PSK_WITH_AES_256_CBC_SHA384
public CipherSuiteCode TLS_RSA_PSK_WITH_NULL_SHA256
public CipherSuiteCode TLS_RSA_PSK_WITH_NULL_SHA384
public CipherSuiteCode TLS_ECDHE_PSK_WITH_RC4_128_SHA
public CipherSuiteCode TLS_ECDHE_PSK_WITH_3DES_EDE_CBC_SHA
public CipherSuiteCode TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA
public CipherSuiteCode TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA
public CipherSuiteCode TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA256
public CipherSuiteCode TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA384
public CipherSuiteCode TLS_ECDHE_PSK_WITH_NULL_SHA
public CipherSuiteCode TLS_ECDHE_PSK_WITH_NULL_SHA256
public CipherSuiteCode TLS_ECDHE_PSK_WITH_NULL_SHA384
public CipherSuiteCode TLS_EMPTY_RENEGOTIATION_INFO_SCSV
public CipherSuiteCode TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256
public CipherSuiteCode TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384
public CipherSuiteCode TLS_ECDH_ECDSA_WITH_CAMELLIA_128_CBC_SHA256
public CipherSuiteCode TLS_ECDH_ECDSA_WITH_CAMELLIA_256_CBC_SHA384
public CipherSuiteCode TLS_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256
public CipherSuiteCode TLS_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384
public CipherSuiteCode TLS_ECDH_RSA_WITH_CAMELLIA_128_CBC_SHA256
public CipherSuiteCode TLS_ECDH_RSA_WITH_CAMELLIA_256_CBC_SHA384
public CipherSuiteCode TLS_RSA_WITH_CAMELLIA_128_GCM_SHA256
public CipherSuiteCode TLS_RSA_WITH_CAMELLIA_256_GCM_SHA384
public CipherSuiteCode TLS_DHE_RSA_WITH_CAMELLIA_128_GCM_SHA256
public CipherSuiteCode TLS_DHE_RSA_WITH_CAMELLIA_256_GCM_SHA384
public CipherSuiteCode TLS_DH_RSA_WITH_CAMELLIA_128_GCM_SHA256
public CipherSuiteCode TLS_DH_RSA_WITH_CAMELLIA_256_GCM_SHA384
public CipherSuiteCode TLS_DHE_DSS_WITH_CAMELLIA_128_GCM_SHA256
public CipherSuiteCode TLS_DHE_DSS_WITH_CAMELLIA_256_GCM_SHA384
public CipherSuiteCode TLS_DH_DSS_WITH_CAMELLIA_128_GCM_SHA256
public CipherSuiteCode TLS_DH_DSS_WITH_CAMELLIA_256_GCM_SHA384
public CipherSuiteCode TLS_DH_anon_WITH_CAMELLIA_128_GCM_SHA256
public CipherSuiteCode TLS_DH_anon_WITH_CAMELLIA_256_GCM_SHA384
public CipherSuiteCode TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_GCM_SHA256
public CipherSuiteCode TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_GCM_SHA384
public CipherSuiteCode TLS_ECDH_ECDSA_WITH_CAMELLIA_128_GCM_SHA256
public CipherSuiteCode TLS_ECDH_ECDSA_WITH_CAMELLIA_256_GCM_SHA384
public CipherSuiteCode TLS_ECDHE_RSA_WITH_CAMELLIA_128_GCM_SHA256
public CipherSuiteCode TLS_ECDHE_RSA_WITH_CAMELLIA_256_GCM_SHA384
public CipherSuiteCode TLS_ECDH_RSA_WITH_CAMELLIA_128_GCM_SHA256
public CipherSuiteCode TLS_ECDH_RSA_WITH_CAMELLIA_256_GCM_SHA384
public CipherSuiteCode TLS_PSK_WITH_CAMELLIA_128_GCM_SHA256
public CipherSuiteCode TLS_PSK_WITH_CAMELLIA_256_GCM_SHA384
public CipherSuiteCode TLS_DHE_PSK_WITH_CAMELLIA_128_GCM_SHA256
public CipherSuiteCode TLS_DHE_PSK_WITH_CAMELLIA_256_GCM_SHA384
public CipherSuiteCode TLS_RSA_PSK_WITH_CAMELLIA_128_GCM_SHA256
public CipherSuiteCode TLS_RSA_PSK_WITH_CAMELLIA_256_GCM_SHA384
public CipherSuiteCode TLS_PSK_WITH_CAMELLIA_128_CBC_SHA256
public CipherSuiteCode TLS_PSK_WITH_CAMELLIA_256_CBC_SHA384
public CipherSuiteCode TLS_DHE_PSK_WITH_CAMELLIA_128_CBC_SHA256
public CipherSuiteCode TLS_DHE_PSK_WITH_CAMELLIA_256_CBC_SHA384
public CipherSuiteCode TLS_RSA_PSK_WITH_CAMELLIA_128_CBC_SHA256
public CipherSuiteCode TLS_RSA_PSK_WITH_CAMELLIA_256_CBC_SHA384
public CipherSuiteCode TLS_ECDHE_PSK_WITH_CAMELLIA_128_CBC_SHA256
public CipherSuiteCode TLS_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384
public CipherSuiteCode TLS_RSA_WITH_AES_128_CCM
public CipherSuiteCode TLS_RSA_WITH_AES_256_CCM
public CipherSuiteCode TLS_DHE_RSA_WITH_AES_128_CCM
public CipherSuiteCode TLS_DHE_RSA_WITH_AES_256_CCM
public CipherSuiteCode TLS_RSA_WITH_AES_128_CCM_8
public CipherSuiteCode TLS_RSA_WITH_AES_256_CCM_8
public CipherSuiteCode TLS_DHE_RSA_WITH_AES_128_CCM_8
public CipherSuiteCode TLS_DHE_RSA_WITH_AES_256_CCM_8
public CipherSuiteCode TLS_PSK_WITH_AES_128_CCM
public CipherSuiteCode TLS_PSK_WITH_AES_256_CCM
public CipherSuiteCode TLS_DHE_PSK_WITH_AES_128_CCM
public CipherSuiteCode TLS_DHE_PSK_WITH_AES_256_CCM
public CipherSuiteCode TLS_PSK_WITH_AES_128_CCM_8
public CipherSuiteCode TLS_PSK_WITH_AES_256_CCM_8
public CipherSuiteCode TLS_PSK_DHE_WITH_AES_128_CCM_8
public CipherSuiteCode TLS_PSK_DHE_WITH_AES_256_CCM_8
public CipherSuiteCode TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256
public CipherSuiteCode TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256
public CipherSuiteCode TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256
public CipherSuiteCode TLS_RSA_WITH_ESTREAM_SALSA20_SHA1
public CipherSuiteCode TLS_RSA_WITH_SALSA20_SHA1
public CipherSuiteCode TLS_ECDHE_RSA_WITH_ESTREAM_SALSA20_SHA1
public CipherSuiteCode TLS_ECDHE_RSA_WITH_SALSA20_SHA1
public CipherSuiteCode TLS_ECDHE_ECDSA_WITH_ESTREAM_SALSA20_SHA1
public CipherSuiteCode TLS_ECDHE_ECDSA_WITH_SALSA20_SHA1
public CipherSuiteCode TLS_PSK_WITH_ESTREAM_SALSA20_SHA1
public CipherSuiteCode TLS_PSK_WITH_SALSA20_SHA1
public CipherSuiteCode TLS_ECDHE_PSK_WITH_ESTREAM_SALSA20_SHA1
public CipherSuiteCode TLS_ECDHE_PSK_WITH_SALSA20_SHA1
public CipherSuiteCode TLS_RSA_PSK_WITH_ESTREAM_SALSA20_SHA1
public CipherSuiteCode TLS_RSA_PSK_WITH_SALSA20_SHA1
public CipherSuiteCode TLS_DHE_PSK_WITH_ESTREAM_SALSA20_SHA1
public CipherSuiteCode TLS_DHE_PSK_WITH_SALSA20_SHA1
public CipherSuiteCode TLS_DHE_RSA_WITH_ESTREAM_SALSA20_SHA1
public CipherSuiteCode TLS_DHE_RSA_WITH_SALSA20_SHA1
public CipherSuiteCode TLS_FALLBACK_SCSV
}
public Mono.Security.Interface.ExchangeAlgorithmType : Enum {
public int value__
public ExchangeAlgorithmType None
public ExchangeAlgorithmType Dhe
public ExchangeAlgorithmType Rsa
public ExchangeAlgorithmType EcDhe
}
public Mono.Security.Interface.HashAlgorithmType : Enum {
public int value__
public HashAlgorithmType None
public HashAlgorithmType Md5
public HashAlgorithmType Sha1
public HashAlgorithmType Sha224
public HashAlgorithmType Sha256
public HashAlgorithmType Sha384
public HashAlgorithmType Sha512
public HashAlgorithmType Unknown
public HashAlgorithmType Md5Sha1
}
public Mono.Security.Interface.ICertificateValidator {
public MonoTlsSettings Settings
public MonoTlsSettings get_Settings()
public bool SelectClientCertificate(string targetHost, X509CertificateCollection localCertificates, X509Certificate remoteCertificate, String[] acceptableIssuers, X509Certificate& clientCertificate)
public ValidationResult ValidateCertificate(string targetHost, bool serverMode, X509CertificateCollection certificates)
}
internal Mono.Security.Interface.ICertificateValidator2 {
public ValidationResult ValidateCertificate(string targetHost, bool serverMode, X509Certificate leaf, X509Chain chain)
}
public Mono.Security.Interface.IMonoSslStream {
public SslStream SslStream
public TransportContext TransportContext
public bool IsAuthenticated
public bool IsMutuallyAuthenticated
public bool IsEncrypted
public bool IsSigned
public bool IsServer
public CipherAlgorithmType CipherAlgorithm
public int CipherStrength
public HashAlgorithmType HashAlgorithm
public int HashStrength
public ExchangeAlgorithmType KeyExchangeAlgorithm
public int KeyExchangeStrength
public bool CanRead
public bool CanTimeout
public bool CanWrite
public long Length
public long Position
public AuthenticatedStream AuthenticatedStream
public int ReadTimeout
public int WriteTimeout
public bool CheckCertRevocationStatus
public X509Certificate InternalLocalCertificate
public X509Certificate LocalCertificate
public X509Certificate RemoteCertificate
public SslProtocols SslProtocol
public MonoTlsProvider Provider
public SslStream get_SslStream()
public void AuthenticateAsClient(string targetHost)
public void AuthenticateAsClient(string targetHost, X509CertificateCollection clientCertificates, SslProtocols enabledSslProtocols, bool checkCertificateRevocation)
public IAsyncResult BeginAuthenticateAsClient(string targetHost, AsyncCallback asyncCallback, object asyncState)
public IAsyncResult BeginAuthenticateAsClient(string targetHost, X509CertificateCollection clientCertificates, SslProtocols enabledSslProtocols, bool checkCertificateRevocation, AsyncCallback asyncCallback, object asyncState)
public void EndAuthenticateAsClient(IAsyncResult asyncResult)
public void AuthenticateAsServer(X509Certificate serverCertificate)
public void AuthenticateAsServer(X509Certificate serverCertificate, bool clientCertificateRequired, SslProtocols enabledSslProtocols, bool checkCertificateRevocation)
public IAsyncResult BeginAuthenticateAsServer(X509Certificate serverCertificate, AsyncCallback asyncCallback, object asyncState)
public IAsyncResult BeginAuthenticateAsServer(X509Certificate serverCertificate, bool clientCertificateRequired, SslProtocols enabledSslProtocols, bool checkCertificateRevocation, AsyncCallback asyncCallback, object asyncState)
public void EndAuthenticateAsServer(IAsyncResult asyncResult)
public Task AuthenticateAsClientAsync(string targetHost)
public Task AuthenticateAsClientAsync(string targetHost, X509CertificateCollection clientCertificates, SslProtocols enabledSslProtocols, bool checkCertificateRevocation)
public Task AuthenticateAsServerAsync(X509Certificate serverCertificate)
public Task AuthenticateAsServerAsync(X509Certificate serverCertificate, bool clientCertificateRequired, SslProtocols enabledSslProtocols, bool checkCertificateRevocation)
public int Read(Byte[] buffer, int offset, int count)
public void Write(Byte[] buffer)
public void Write(Byte[] buffer, int offset, int count)
public IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback asyncCallback, object asyncState)
public int EndRead(IAsyncResult asyncResult)
public IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback asyncCallback, object asyncState)
public void EndWrite(IAsyncResult asyncResult)
public Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken)
public Task ShutdownAsync()
public TransportContext get_TransportContext()
public bool get_IsAuthenticated()
public bool get_IsMutuallyAuthenticated()
public bool get_IsEncrypted()
public bool get_IsSigned()
public bool get_IsServer()
public CipherAlgorithmType get_CipherAlgorithm()
public int get_CipherStrength()
public HashAlgorithmType get_HashAlgorithm()
public int get_HashStrength()
public ExchangeAlgorithmType get_KeyExchangeAlgorithm()
public int get_KeyExchangeStrength()
public bool get_CanRead()
public bool get_CanTimeout()
public bool get_CanWrite()
public long get_Length()
public long get_Position()
public void SetLength(long value)
public AuthenticatedStream get_AuthenticatedStream()
public int get_ReadTimeout()
public void set_ReadTimeout(int value)
public int get_WriteTimeout()
public void set_WriteTimeout(int value)
public bool get_CheckCertRevocationStatus()
public X509Certificate get_InternalLocalCertificate()
public X509Certificate get_LocalCertificate()
public X509Certificate get_RemoteCertificate()
public SslProtocols get_SslProtocol()
public MonoTlsProvider get_Provider()
public MonoTlsConnectionInfo GetConnectionInfo()
}
public Mono.Security.Interface.MonoEncryptionPolicy : Enum {
public int value__
public MonoEncryptionPolicy RequireEncryption
public MonoEncryptionPolicy AllowNoEncryption
public MonoEncryptionPolicy NoEncryption
}
public Mono.Security.Interface.MonoLocalCertificateSelectionCallback : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public X509Certificate Invoke(string targetHost, X509CertificateCollection localCertificates, X509Certificate remoteCertificate, String[] acceptableIssuers)
public IAsyncResult BeginInvoke(string targetHost, X509CertificateCollection localCertificates, X509Certificate remoteCertificate, String[] acceptableIssuers, AsyncCallback callback, object object)
public X509Certificate EndInvoke(IAsyncResult result)
}
public Mono.Security.Interface.MonoRemoteCertificateValidationCallback : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public bool Invoke(string targetHost, X509Certificate certificate, X509Chain chain, MonoSslPolicyErrors sslPolicyErrors)
public IAsyncResult BeginInvoke(string targetHost, X509Certificate certificate, X509Chain chain, MonoSslPolicyErrors sslPolicyErrors, AsyncCallback callback, object object)
public bool EndInvoke(IAsyncResult result)
}
public Mono.Security.Interface.MonoSslPolicyErrors : Enum {
public int value__
public MonoSslPolicyErrors None
public MonoSslPolicyErrors RemoteCertificateNotAvailable
public MonoSslPolicyErrors RemoteCertificateNameMismatch
public MonoSslPolicyErrors RemoteCertificateChainErrors
}
public Mono.Security.Interface.MonoTlsConnectionInfo : object {
private CipherSuiteCode <CipherSuiteCode>k__BackingField
private TlsProtocols <ProtocolVersion>k__BackingField
private CipherAlgorithmType <CipherAlgorithmType>k__BackingField
private HashAlgorithmType <HashAlgorithmType>k__BackingField
private ExchangeAlgorithmType <ExchangeAlgorithmType>k__BackingField
private string <PeerDomainName>k__BackingField
public CipherSuiteCode CipherSuiteCode
public TlsProtocols ProtocolVersion
public CipherAlgorithmType CipherAlgorithmType
public HashAlgorithmType HashAlgorithmType
public ExchangeAlgorithmType ExchangeAlgorithmType
public string PeerDomainName
public CipherSuiteCode get_CipherSuiteCode()
public void set_CipherSuiteCode(CipherSuiteCode value)
public TlsProtocols get_ProtocolVersion()
public void set_ProtocolVersion(TlsProtocols value)
public CipherAlgorithmType get_CipherAlgorithmType()
public void set_CipherAlgorithmType(CipherAlgorithmType value)
public HashAlgorithmType get_HashAlgorithmType()
public void set_HashAlgorithmType(HashAlgorithmType value)
public ExchangeAlgorithmType get_ExchangeAlgorithmType()
public void set_ExchangeAlgorithmType(ExchangeAlgorithmType value)
public string get_PeerDomainName()
public void set_PeerDomainName(string value)
public string ToString()
}
public Mono.Security.Interface.MonoTlsProvider : object {
public Guid ID
public string Name
public bool SupportsSslStream
public bool SupportsConnectionInfo
public bool SupportsMonoExtensions
public SslProtocols SupportedProtocols
internal bool HasNativeCertificates
internal bool SupportsCleanShutdown
public Guid get_ID()
public string get_Name()
public bool get_SupportsSslStream()
public bool get_SupportsConnectionInfo()
public bool get_SupportsMonoExtensions()
public SslProtocols get_SupportedProtocols()
public IMonoSslStream CreateSslStream(Stream innerStream, bool leaveInnerStreamOpen, MonoTlsSettings settings)
internal IMonoSslStream CreateSslStreamInternal(SslStream sslStream, Stream innerStream, bool leaveInnerStreamOpen, MonoTlsSettings settings)
internal bool get_HasNativeCertificates()
internal X509Certificate2Impl GetNativeCertificate(Byte[] data, string password, X509KeyStorageFlags flags)
internal X509Certificate2Impl GetNativeCertificate(X509Certificate certificate)
internal bool ValidateCertificate(ICertificateValidator2 validator, string targetHost, bool serverMode, X509CertificateCollection certificates, bool wantsChain, X509Chain& chain, MonoSslPolicyErrors& errors, Int32& status11)
internal bool get_SupportsCleanShutdown()
}
public Mono.Security.Interface.MonoTlsProviderFactory : object {
internal int InternalVersion
public bool IsInitialized
public MonoTlsProvider GetProvider()
public bool get_IsInitialized()
public void Initialize()
public void Initialize(string provider)
public bool IsProviderSupported(string provider)
public MonoTlsProvider GetProvider(string provider)
public HttpWebRequest CreateHttpsRequest(Uri requestUri, MonoTlsProvider provider, MonoTlsSettings settings)
public HttpListener CreateHttpListener(X509Certificate certificate, MonoTlsProvider provider, MonoTlsSettings settings)
public IMonoSslStream GetMonoSslStream(SslStream stream)
public IMonoSslStream GetMonoSslStream(HttpListenerContext context)
}
public Mono.Security.Interface.MonoTlsSettings : object {
private MonoRemoteCertificateValidationCallback <RemoteCertificateValidationCallback>k__BackingField
private MonoLocalCertificateSelectionCallback <ClientCertificateSelectionCallback>k__BackingField
private Nullable`1<DateTime> <CertificateValidationTime>k__BackingField
private X509CertificateCollection <TrustAnchors>k__BackingField
private object <UserSettings>k__BackingField
private String[] <CertificateSearchPaths>k__BackingField
private bool <SendCloseNotify>k__BackingField
private Nullable`1<TlsProtocols> <EnabledProtocols>k__BackingField
private CipherSuiteCode[] <EnabledCiphers>k__BackingField
private bool cloned
private bool checkCertName
private bool checkCertRevocationStatus
private Nullable`1<bool> useServicePointManagerCallback
private bool skipSystemValidators
private bool callbackNeedsChain
private ICertificateValidator certificateValidator
private MonoTlsSettings defaultSettings
public MonoRemoteCertificateValidationCallback RemoteCertificateValidationCallback
public MonoLocalCertificateSelectionCallback ClientCertificateSelectionCallback
public bool CheckCertificateName
public bool CheckCertificateRevocationStatus
public Nullable`1<bool> UseServicePointManagerCallback
public bool SkipSystemValidators
public bool CallbackNeedsCertificateChain
public Nullable`1<DateTime> CertificateValidationTime
public X509CertificateCollection TrustAnchors
public object UserSettings
internal String[] CertificateSearchPaths
internal bool SendCloseNotify
public Nullable`1<TlsProtocols> EnabledProtocols
public CipherSuiteCode[] EnabledCiphers
public MonoTlsSettings DefaultSettings
public ICertificateValidator CertificateValidator
public MonoRemoteCertificateValidationCallback get_RemoteCertificateValidationCallback()
public void set_RemoteCertificateValidationCallback(MonoRemoteCertificateValidationCallback value)
public MonoLocalCertificateSelectionCallback get_ClientCertificateSelectionCallback()
public void set_ClientCertificateSelectionCallback(MonoLocalCertificateSelectionCallback value)
public bool get_CheckCertificateName()
public void set_CheckCertificateName(bool value)
public bool get_CheckCertificateRevocationStatus()
public void set_CheckCertificateRevocationStatus(bool value)
public Nullable`1<bool> get_UseServicePointManagerCallback()
public void set_UseServicePointManagerCallback(Nullable`1<bool> value)
public bool get_SkipSystemValidators()
public void set_SkipSystemValidators(bool value)
public bool get_CallbackNeedsCertificateChain()
public void set_CallbackNeedsCertificateChain(bool value)
public Nullable`1<DateTime> get_CertificateValidationTime()
public void set_CertificateValidationTime(Nullable`1<DateTime> value)
public X509CertificateCollection get_TrustAnchors()
public void set_TrustAnchors(X509CertificateCollection value)
public object get_UserSettings()
public void set_UserSettings(object value)
internal String[] get_CertificateSearchPaths()
internal void set_CertificateSearchPaths(String[] value)
internal bool get_SendCloseNotify()
internal void set_SendCloseNotify(bool value)
public Nullable`1<TlsProtocols> get_EnabledProtocols()
public void set_EnabledProtocols(Nullable`1<TlsProtocols> value)
public CipherSuiteCode[] get_EnabledCiphers()
public void set_EnabledCiphers(CipherSuiteCode[] value)
public MonoTlsSettings get_DefaultSettings()
public void set_DefaultSettings(MonoTlsSettings value)
public MonoTlsSettings CopyDefaultSettings()
public ICertificateValidator get_CertificateValidator()
public MonoTlsSettings CloneWithValidator(ICertificateValidator validator)
public MonoTlsSettings Clone()
private void .ctor(MonoTlsSettings other)
}
public Mono.Security.Interface.TlsException : Exception {
private Alert alert
public Alert Alert
public Alert get_Alert()
public void .ctor(Alert alert)
public void .ctor(Alert alert, string message)
public void .ctor(AlertLevel level, AlertDescription description)
public void .ctor(AlertDescription description)
public void .ctor(AlertDescription description, string message)
public void .ctor(AlertDescription description, string format, Object[] args)
}
public Mono.Security.Interface.TlsProtocolCode : Enum {
public short value__
public TlsProtocolCode Tls10
public TlsProtocolCode Tls11
public TlsProtocolCode Tls12
}
public Mono.Security.Interface.TlsProtocols : Enum {
public int value__
public TlsProtocols Zero
public TlsProtocols Tls10Client
public TlsProtocols Tls10Server
public TlsProtocols Tls10
public TlsProtocols Tls11Client
public TlsProtocols Tls11Server
public TlsProtocols Tls11
public TlsProtocols Tls12Client
public TlsProtocols Tls12Server
public TlsProtocols Tls12
public TlsProtocols ClientMask
public TlsProtocols ServerMask
}
public Mono.Security.Interface.ValidationResult : object {
private bool trusted
private bool user_denied
private int error_code
private Nullable`1<MonoSslPolicyErrors> policy_errors
public bool Trusted
public bool UserDenied
public int ErrorCode
public Nullable`1<MonoSslPolicyErrors> PolicyErrors
public void .ctor(bool trusted, bool user_denied, int error_code, Nullable`1<MonoSslPolicyErrors> policy_errors)
internal void .ctor(bool trusted, bool user_denied, int error_code)
public bool get_Trusted()
public bool get_UserDenied()
public int get_ErrorCode()
public Nullable`1<MonoSslPolicyErrors> get_PolicyErrors()
}
public Mono.Security.PKCS7 : object {
public ASN1 Attribute(string oid, ASN1 value)
public ASN1 AlgorithmIdentifier(string oid)
public ASN1 AlgorithmIdentifier(string oid, ASN1 parameters)
public ASN1 IssuerAndSerialNumber(X509Certificate x509)
}
public Mono.Security.Protocol.Ntlm.ChallengeResponse : object {
private Byte[] magic
private Byte[] nullEncMagic
private bool _disposed
private Byte[] _challenge
private Byte[] _lmpwd
private Byte[] _ntpwd
public string Password
public Byte[] Challenge
public Byte[] LM
public Byte[] NT
public void .ctor(string password, Byte[] challenge)
protected void Finalize()
public string get_Password()
public void set_Password(string value)
public Byte[] get_Challenge()
public void set_Challenge(Byte[] value)
public Byte[] get_LM()
public Byte[] get_NT()
public void Dispose()
private void Dispose(bool disposing)
private Byte[] GetResponse(Byte[] pwd)
private Byte[] PrepareDESKey(Byte[] key56bits, int position)
private Byte[] PasswordToKey(string password, int position)
}
public Mono.Security.Protocol.Ntlm.ChallengeResponse2 : object {
private Byte[] magic
private Byte[] nullEncMagic
private Byte[] Compute_LM(string password, Byte[] challenge)
private Byte[] Compute_NTLM_Password(string password)
private Byte[] Compute_NTLM(string password, Byte[] challenge)
private void Compute_NTLMv2_Session(string password, Byte[] challenge, Byte[]& lm, Byte[]& ntlm)
private Byte[] Compute_NTLMv2(Type2Message type2, string username, string password, string domain)
public void Compute(Type2Message type2, NtlmAuthLevel level, string username, string password, string domain, Byte[]& lm, Byte[]& ntlm)
private Byte[] GetResponse(Byte[] challenge, Byte[] pwd)
private Byte[] PrepareDESKey(Byte[] key56bits, int position)
private Byte[] PasswordToKey(string password, int position)
}
public Mono.Security.Protocol.Ntlm.MessageBase : object {
private Byte[] header
private int _type
private NtlmFlags _flags
public NtlmFlags Flags
public int Type
protected void .ctor(int messageType)
public NtlmFlags get_Flags()
public void set_Flags(NtlmFlags value)
public int get_Type()
protected Byte[] PrepareMessage(int messageSize)
protected void Decode(Byte[] message)
protected bool CheckHeader(Byte[] message)
public Byte[] GetBytes()
}
public Mono.Security.Protocol.Ntlm.NtlmAuthLevel : Enum {
public int value__
public NtlmAuthLevel LM_and_NTLM
public NtlmAuthLevel LM_and_NTLM_and_try_NTLMv2_Session
public NtlmAuthLevel NTLM_only
public NtlmAuthLevel NTLMv2_only
}
public Mono.Security.Protocol.Ntlm.NtlmFlags : Enum {
public int value__
public NtlmFlags NegotiateUnicode
public NtlmFlags NegotiateOem
public NtlmFlags RequestTarget
public NtlmFlags NegotiateNtlm
public NtlmFlags NegotiateDomainSupplied
public NtlmFlags NegotiateWorkstationSupplied
public NtlmFlags NegotiateAlwaysSign
public NtlmFlags NegotiateNtlm2Key
public NtlmFlags Negotiate128
public NtlmFlags Negotiate56
}
public Mono.Security.Protocol.Ntlm.NtlmSettings : object {
private NtlmAuthLevel defaultAuthLevel
public NtlmAuthLevel DefaultAuthLevel
public NtlmAuthLevel get_DefaultAuthLevel()
public void set_DefaultAuthLevel(NtlmAuthLevel value)
}
public Mono.Security.Protocol.Ntlm.Type1Message : MessageBase {
private string _host
private string _domain
public string Domain
public string Host
public void .ctor(Byte[] message)
public string get_Domain()
public void set_Domain(string value)
public string get_Host()
public void set_Host(string value)
protected void Decode(Byte[] message)
public Byte[] GetBytes()
}
public Mono.Security.Protocol.Ntlm.Type2Message : MessageBase {
private Byte[] _nonce
private string _targetName
private Byte[] _targetInfo
public Byte[] Nonce
public string TargetName
public Byte[] TargetInfo
public void .ctor(Byte[] message)
protected void Finalize()
public Byte[] get_Nonce()
public void set_Nonce(Byte[] value)
public string get_TargetName()
public Byte[] get_TargetInfo()
protected void Decode(Byte[] message)
public Byte[] GetBytes()
}
public Mono.Security.Protocol.Ntlm.Type3Message : MessageBase {
private NtlmAuthLevel _level
private Byte[] _challenge
private string _host
private string _domain
private string _username
private string _password
private Type2Message _type2
private Byte[] _lm
private Byte[] _nt
internal string LegacyAPIWarning
public NtlmAuthLevel DefaultAuthLevel
public NtlmAuthLevel Level
public Byte[] Challenge
public string Domain
public string Host
public string Password
public string Username
public Byte[] LM
public Byte[] NT
public void .ctor(Byte[] message)
public void .ctor(Type2Message type2)
protected void Finalize()
public NtlmAuthLevel get_DefaultAuthLevel()
public void set_DefaultAuthLevel(NtlmAuthLevel value)
public NtlmAuthLevel get_Level()
public void set_Level(NtlmAuthLevel value)
public Byte[] get_Challenge()
public void set_Challenge(Byte[] value)
public string get_Domain()
public void set_Domain(string value)
public string get_Host()
public void set_Host(string value)
public string get_Password()
public void set_Password(string value)
public string get_Username()
public void set_Username(string value)
public Byte[] get_LM()
public Byte[] get_NT()
public void set_NT(Byte[] value)
protected void Decode(Byte[] message)
private string DecodeString(Byte[] buffer, int offset, int len)
private Byte[] EncodeString(string text)
public Byte[] GetBytes()
}
internal Mono.Security.Protocol.Tls.Alert : object {
private AlertLevel level
private AlertDescription description
public AlertLevel Level
public AlertDescription Description
public string Message
public bool IsWarning
public bool IsCloseNotify
public AlertLevel get_Level()
public AlertDescription get_Description()
public string get_Message()
public bool get_IsWarning()
public bool get_IsCloseNotify()
public void .ctor(AlertDescription description)
public void .ctor(AlertLevel level, AlertDescription description)
private AlertLevel inferAlertLevel(AlertDescription description)
public string GetAlertMessage(AlertDescription description)
}
internal Mono.Security.Protocol.Tls.AlertDescription : Enum {
public byte value__
public AlertDescription CloseNotify
public AlertDescription UnexpectedMessage
public AlertDescription BadRecordMAC
public AlertDescription DecryptionFailed
public AlertDescription RecordOverflow
public AlertDescription DecompressionFailiure
public AlertDescription HandshakeFailiure
public AlertDescription NoCertificate
public AlertDescription BadCertificate
public AlertDescription UnsupportedCertificate
public AlertDescription CertificateRevoked
public AlertDescription CertificateExpired
public AlertDescription CertificateUnknown
public AlertDescription IlegalParameter
public AlertDescription UnknownCA
public AlertDescription AccessDenied
public AlertDescription DecodeError
public AlertDescription DecryptError
public AlertDescription ExportRestriction
public AlertDescription ProtocolVersion
public AlertDescription InsuficientSecurity
public AlertDescription InternalError
public AlertDescription UserCancelled
public AlertDescription NoRenegotiation
}
internal Mono.Security.Protocol.Tls.AlertLevel : Enum {
public byte value__
public AlertLevel Warning
public AlertLevel Fatal
}
public Mono.Security.Protocol.Tls.CertificateSelectionCallback : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public X509Certificate Invoke(X509CertificateCollection clientCertificates, X509Certificate serverCertificate, string targetHost, X509CertificateCollection serverRequestedCertificates)
public IAsyncResult BeginInvoke(X509CertificateCollection clientCertificates, X509Certificate serverCertificate, string targetHost, X509CertificateCollection serverRequestedCertificates, AsyncCallback callback, object object)
public X509Certificate EndInvoke(IAsyncResult result)
}
public Mono.Security.Protocol.Tls.CertificateValidationCallback : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public bool Invoke(X509Certificate certificate, Int32[] certificateErrors)
public IAsyncResult BeginInvoke(X509Certificate certificate, Int32[] certificateErrors, AsyncCallback callback, object object)
public bool EndInvoke(IAsyncResult result)
}
public Mono.Security.Protocol.Tls.CertificateValidationCallback2 : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public ValidationResult Invoke(X509CertificateCollection collection)
public IAsyncResult BeginInvoke(X509CertificateCollection collection, AsyncCallback callback, object object)
public ValidationResult EndInvoke(IAsyncResult result)
}
public Mono.Security.Protocol.Tls.CipherAlgorithmType : Enum {
public int value__
public CipherAlgorithmType Des
public CipherAlgorithmType None
public CipherAlgorithmType Rc2
public CipherAlgorithmType Rc4
public CipherAlgorithmType Rijndael
public CipherAlgorithmType SkipJack
public CipherAlgorithmType TripleDes
}
internal Mono.Security.Protocol.Tls.CipherSuite : object {
public Byte[] EmptyArray
private short code
private string name
private CipherAlgorithmType cipherAlgorithmType
private HashAlgorithmType hashAlgorithmType
private ExchangeAlgorithmType exchangeAlgorithmType
private bool isExportable
private CipherMode cipherMode
private byte keyMaterialSize
private int keyBlockSize
private byte expandedKeyMaterialSize
private short effectiveKeyBits
private byte ivSize
private byte blockSize
private Context context
private SymmetricAlgorithm encryptionAlgorithm
private ICryptoTransform encryptionCipher
private SymmetricAlgorithm decryptionAlgorithm
private ICryptoTransform decryptionCipher
private KeyedHashAlgorithm clientHMAC
private KeyedHashAlgorithm serverHMAC
protected ICryptoTransform EncryptionCipher
protected ICryptoTransform DecryptionCipher
protected KeyedHashAlgorithm ClientHMAC
protected KeyedHashAlgorithm ServerHMAC
public CipherAlgorithmType CipherAlgorithmType
public string HashAlgorithmName
public HashAlgorithmType HashAlgorithmType
public int HashSize
public ExchangeAlgorithmType ExchangeAlgorithmType
public CipherMode CipherMode
public short Code
public string Name
public bool IsExportable
public byte KeyMaterialSize
public int KeyBlockSize
public byte ExpandedKeyMaterialSize
public short EffectiveKeyBits
public byte IvSize
public Context Context
protected ICryptoTransform get_EncryptionCipher()
protected ICryptoTransform get_DecryptionCipher()
protected KeyedHashAlgorithm get_ClientHMAC()
protected KeyedHashAlgorithm get_ServerHMAC()
public CipherAlgorithmType get_CipherAlgorithmType()
public string get_HashAlgorithmName()
internal HashAlgorithm CreateHashAlgorithm()
public HashAlgorithmType get_HashAlgorithmType()
public int get_HashSize()
public ExchangeAlgorithmType get_ExchangeAlgorithmType()
public CipherMode get_CipherMode()
public short get_Code()
public string get_Name()
public bool get_IsExportable()
public byte get_KeyMaterialSize()
public int get_KeyBlockSize()
public byte get_ExpandedKeyMaterialSize()
public short get_EffectiveKeyBits()
public byte get_IvSize()
public Context get_Context()
public void set_Context(Context value)
public void .ctor(short code, string name, CipherAlgorithmType cipherAlgorithmType, HashAlgorithmType hashAlgorithmType, ExchangeAlgorithmType exchangeAlgorithmType, bool exportable, bool blockMode, byte keyMaterialSize, byte expandedKeyMaterialSize, short effectiveKeyBits, byte ivSize, byte blockSize)
internal void Write(Byte[] array, int offset, short value)
internal void Write(Byte[] array, int offset, ulong value)
public void InitializeCipher()
public Byte[] EncryptRecord(Byte[] fragment, Byte[] mac)
public void DecryptRecord(Byte[] fragment, Byte[]& dcrFragment, Byte[]& dcrMAC)
public Byte[] ComputeClientRecordMAC(ContentType contentType, Byte[] fragment)
public Byte[] ComputeServerRecordMAC(ContentType contentType, Byte[] fragment)
public void ComputeMasterSecret(Byte[] preMasterSecret)
public void ComputeKeys()
public Byte[] CreatePremasterSecret()
public Byte[] PRF(Byte[] secret, string label, Byte[] data, int length)
public Byte[] Expand(HashAlgorithm hash, Byte[] secret, Byte[] seed, int length)
private void createEncryptionCipher()
private void createDecryptionCipher()
}
internal Mono.Security.Protocol.Tls.CipherSuiteCollection : List`1<CipherSuite> {
private SecurityProtocolType protocol
public CipherSuite Item
public CipherSuite Item
public CipherSuite get_Item(string name)
public CipherSuite get_Item(short code)
public void .ctor(SecurityProtocolType protocol)
public int IndexOf(string name)
public int IndexOf(short code)
public void Add(short code, string name, CipherAlgorithmType cipherType, HashAlgorithmType hashType, ExchangeAlgorithmType exchangeType, bool exportable, bool blockMode, byte keyMaterialSize, byte expandedKeyMaterialSize, short effectiveKeyBytes, byte ivSize, byte blockSize)
public IList`1<string> GetNames()
}
internal Mono.Security.Protocol.Tls.CipherSuiteFactory : object {
public CipherSuiteCollection GetSupportedCiphers(bool server, SecurityProtocolType protocol)
private CipherSuiteCollection GetTls1SupportedCiphers()
private CipherSuiteCollection GetSsl3SupportedCiphers()
}
internal Mono.Security.Protocol.Tls.ClientContext : Context {
private SslClientStream sslStream
private short clientHelloProtocol
public SslClientStream SslStream
public short ClientHelloProtocol
public SslClientStream get_SslStream()
public short get_ClientHelloProtocol()
public void set_ClientHelloProtocol(short value)
public void .ctor(SslClientStream stream, SecurityProtocolType securityProtocolType, string targetHost, X509CertificateCollection clientCertificates)
public void Clear()
}
internal Mono.Security.Protocol.Tls.ClientRecordProtocol : RecordProtocol {
public void .ctor(Stream innerStream, ClientContext context)
public HandshakeMessage GetMessage(HandshakeType type)
protected void ProcessHandshakeMessage(TlsStream handMsg)
private HandshakeMessage createClientHandshakeMessage(HandshakeType type)
private HandshakeMessage createServerHandshakeMessage(HandshakeType type, Byte[] buffer)
}
internal Mono.Security.Protocol.Tls.ClientSessionCache : object {
private Hashtable cache
private object locker
public void Add(string host, Byte[] id)
public Byte[] FromHost(string host)
private ClientSessionInfo FromContext(Context context, bool checkValidity)
public bool SetContextInCache(Context context)
public bool SetContextFromCache(Context context)
}
internal Mono.Security.Protocol.Tls.ClientSessionInfo : object {
private int DefaultValidityInterval
private int ValidityInterval
private bool disposed
private DateTime validuntil
private string host
private Byte[] sid
private Byte[] masterSecret
public string HostName
public Byte[] Id
public bool Valid
public void .ctor(string hostname, Byte[] id)
protected void Finalize()
public string get_HostName()
public Byte[] get_Id()
public bool get_Valid()
public void GetContext(Context context)
public void SetContext(Context context)
public void KeepAlive()
public void Dispose()
private void Dispose(bool disposing)
private void CheckDisposed()
}
internal Mono.Security.Protocol.Tls.ContentType : Enum {
public byte value__
public ContentType ChangeCipherSpec
public ContentType Alert
public ContentType Handshake
public ContentType ApplicationData
}
internal Mono.Security.Protocol.Tls.Context : object {
internal short MAX_FRAGMENT_SIZE
internal short TLS1_PROTOCOL_CODE
internal short SSL3_PROTOCOL_CODE
internal long UNIX_BASE_TICKS
private SecurityProtocolType securityProtocol
private Byte[] sessionId
private SecurityCompressionType compressionMethod
private TlsServerSettings serverSettings
private TlsClientSettings clientSettings
private SecurityParameters current
private SecurityParameters negotiating
private SecurityParameters read
private SecurityParameters write
private CipherSuiteCollection supportedCiphers
private HandshakeType lastHandshakeMsg
private HandshakeState handshakeState
private bool abbreviatedHandshake
private bool receivedConnectionEnd
private bool sentConnectionEnd
private bool protocolNegotiated
private ulong writeSequenceNumber
private ulong readSequenceNumber
private Byte[] clientRandom
private Byte[] serverRandom
private Byte[] randomCS
private Byte[] randomSC
private Byte[] masterSecret
private Byte[] clientWriteKey
private Byte[] serverWriteKey
private Byte[] clientWriteIV
private Byte[] serverWriteIV
private TlsStream handshakeMessages
private RandomNumberGenerator random
private RecordProtocol recordProtocol
private bool <ChangeCipherSpecDone>k__BackingField
public bool AbbreviatedHandshake
public bool ProtocolNegotiated
public bool ChangeCipherSpecDone
public SecurityProtocolType SecurityProtocol
public SecurityProtocolType SecurityProtocolFlags
public short Protocol
public Byte[] SessionId
public SecurityCompressionType CompressionMethod
public TlsServerSettings ServerSettings
public TlsClientSettings ClientSettings
public HandshakeType LastHandshakeMsg
public HandshakeState HandshakeState
public bool ReceivedConnectionEnd
public bool SentConnectionEnd
public CipherSuiteCollection SupportedCiphers
public TlsStream HandshakeMessages
public ulong WriteSequenceNumber
public ulong ReadSequenceNumber
public Byte[] ClientRandom
public Byte[] ServerRandom
public Byte[] RandomCS
public Byte[] RandomSC
public Byte[] MasterSecret
public Byte[] ClientWriteKey
public Byte[] ServerWriteKey
public Byte[] ClientWriteIV
public Byte[] ServerWriteIV
public RecordProtocol RecordProtocol
public SecurityParameters Current
public SecurityParameters Negotiating
public SecurityParameters Read
public SecurityParameters Write
public bool get_AbbreviatedHandshake()
public void set_AbbreviatedHandshake(bool value)
public bool get_ProtocolNegotiated()
public void set_ProtocolNegotiated(bool value)
public bool get_ChangeCipherSpecDone()
public void set_ChangeCipherSpecDone(bool value)
public SecurityProtocolType get_SecurityProtocol()
public void set_SecurityProtocol(SecurityProtocolType value)
public SecurityProtocolType get_SecurityProtocolFlags()
public short get_Protocol()
public Byte[] get_SessionId()
public void set_SessionId(Byte[] value)
public SecurityCompressionType get_CompressionMethod()
public void set_CompressionMethod(SecurityCompressionType value)
public TlsServerSettings get_ServerSettings()
public TlsClientSettings get_ClientSettings()
public HandshakeType get_LastHandshakeMsg()
public void set_LastHandshakeMsg(HandshakeType value)
public HandshakeState get_HandshakeState()
public void set_HandshakeState(HandshakeState value)
public bool get_ReceivedConnectionEnd()
public void set_ReceivedConnectionEnd(bool value)
public bool get_SentConnectionEnd()
public void set_SentConnectionEnd(bool value)
public CipherSuiteCollection get_SupportedCiphers()
public void set_SupportedCiphers(CipherSuiteCollection value)
public TlsStream get_HandshakeMessages()
public ulong get_WriteSequenceNumber()
public void set_WriteSequenceNumber(ulong value)
public ulong get_ReadSequenceNumber()
public void set_ReadSequenceNumber(ulong value)
public Byte[] get_ClientRandom()
public void set_ClientRandom(Byte[] value)
public Byte[] get_ServerRandom()
public void set_ServerRandom(Byte[] value)
public Byte[] get_RandomCS()
public void set_RandomCS(Byte[] value)
public Byte[] get_RandomSC()
public void set_RandomSC(Byte[] value)
public Byte[] get_MasterSecret()
public void set_MasterSecret(Byte[] value)
public Byte[] get_ClientWriteKey()
public void set_ClientWriteKey(Byte[] value)
public Byte[] get_ServerWriteKey()
public void set_ServerWriteKey(Byte[] value)
public Byte[] get_ClientWriteIV()
public void set_ClientWriteIV(Byte[] value)
public Byte[] get_ServerWriteIV()
public void set_ServerWriteIV(Byte[] value)
public RecordProtocol get_RecordProtocol()
public void set_RecordProtocol(RecordProtocol value)
public void .ctor(SecurityProtocolType securityProtocolType)
public int GetUnixTime()
public Byte[] GetSecureRandomBytes(int count)
public void Clear()
public void ClearKeyInfo()
public SecurityProtocolType DecodeProtocolCode(short code, bool allowFallback)
public void ChangeProtocol(short protocol)
public SecurityParameters get_Current()
public SecurityParameters get_Negotiating()
public SecurityParameters get_Read()
public SecurityParameters get_Write()
public void StartSwitchingSecurityParameters(bool client)
public void EndSwitchingSecurityParameters(bool client)
}
internal Mono.Security.Protocol.Tls.DebugHelper : object {
private bool isInitialized
public void Initialize()
public void WriteLine(string format, Object[] args)
public void WriteLine(string message)
public void WriteLine(string message, Byte[] buffer)
public void WriteBuffer(Byte[] buffer)
public void WriteBuffer(Byte[] buffer, int index, int length)
}
public Mono.Security.Protocol.Tls.ExchangeAlgorithmType : Enum {
public int value__
public ExchangeAlgorithmType DiffieHellman
public ExchangeAlgorithmType Fortezza
public ExchangeAlgorithmType None
public ExchangeAlgorithmType RsaKeyX
public ExchangeAlgorithmType RsaSign
}
internal Mono.Security.Protocol.Tls.Handshake.Client.TlsClientCertificate : HandshakeMessage {
private bool clientCertSelected
private X509Certificate clientCert
public X509Certificate ClientCertificate
public void .ctor(Context context)
public X509Certificate get_ClientCertificate()
public void Update()
private void GetClientCertificate()
private void SendCertificates()
protected void ProcessAsSsl3()
protected void ProcessAsTls1()
private X509Certificate FindParentCertificate(X509Certificate cert)
}
internal Mono.Security.Protocol.Tls.Handshake.Client.TlsClientCertificateVerify : HandshakeMessage {
public void .ctor(Context context)
public void Update()
protected void ProcessAsSsl3()
protected void ProcessAsTls1()
private RSA getClientCertRSA(RSA privKey)
private Byte[] getUnsignedBigInteger(Byte[] integer)
}
internal Mono.Security.Protocol.Tls.Handshake.Client.TlsClientFinished : HandshakeMessage {
private Byte[] Ssl3Marker
public void .ctor(Context context)
public void Update()
protected void ProcessAsSsl3()
protected void ProcessAsTls1()
}
internal Mono.Security.Protocol.Tls.Handshake.Client.TlsClientHello : HandshakeMessage {
private Byte[] random
public void .ctor(Context context)
public void Update()
protected void ProcessAsSsl3()
protected void ProcessAsTls1()
}
internal Mono.Security.Protocol.Tls.Handshake.Client.TlsClientKeyExchange : HandshakeMessage {
public void .ctor(Context context)
protected void ProcessAsSsl3()
protected void ProcessAsTls1()
public void ProcessCommon(bool sendLength)
}
internal Mono.Security.Protocol.Tls.Handshake.Client.TlsServerCertificate : HandshakeMessage {
private X509CertificateCollection certificates
public void .ctor(Context context, Byte[] buffer)
public void Update()
protected void ProcessAsSsl3()
protected void ProcessAsTls1()
private bool checkCertificateUsage(X509Certificate cert)
private void validateCertificates(X509CertificateCollection certificates)
private void RemoteValidation(ClientContext context, AlertDescription description)
private void LocalValidation(ClientContext context, AlertDescription description)
private bool checkServerIdentity(X509Certificate cert)
private bool checkDomainName(string subjectName)
private bool Match(string hostname, string pattern)
}
internal Mono.Security.Protocol.Tls.Handshake.Client.TlsServerCertificateRequest : HandshakeMessage {
private ClientCertificateType[] certificateTypes
private String[] distinguisedNames
public void .ctor(Context context, Byte[] buffer)
public void Update()
protected void ProcessAsSsl3()
protected void ProcessAsTls1()
}
internal Mono.Security.Protocol.Tls.Handshake.Client.TlsServerFinished : HandshakeMessage {
private Byte[] Ssl3Marker
public void .ctor(Context context, Byte[] buffer)
public void Update()
protected void ProcessAsSsl3()
protected void ProcessAsTls1()
}
internal Mono.Security.Protocol.Tls.Handshake.Client.TlsServerHello : HandshakeMessage {
private SecurityCompressionType compressionMethod
private Byte[] random
private Byte[] sessionId
private CipherSuite cipherSuite
public void .ctor(Context context, Byte[] buffer)
public void Update()
protected void ProcessAsSsl3()
protected void ProcessAsTls1()
private void processProtocol(short protocol)
}
internal Mono.Security.Protocol.Tls.Handshake.Client.TlsServerHelloDone : HandshakeMessage {
public void .ctor(Context context, Byte[] buffer)
protected void ProcessAsSsl3()
protected void ProcessAsTls1()
}
internal Mono.Security.Protocol.Tls.Handshake.Client.TlsServerKeyExchange : HandshakeMessage {
private RSAParameters rsaParams
private Byte[] signedParams
public void .ctor(Context context, Byte[] buffer)
public void Update()
protected void ProcessAsSsl3()
protected void ProcessAsTls1()
private void verifySignature()
}
internal Mono.Security.Protocol.Tls.Handshake.ClientCertificateType : Enum {
public int value__
public ClientCertificateType RSA
public ClientCertificateType DSS
public ClientCertificateType RSAFixed
public ClientCertificateType DSSFixed
public ClientCertificateType Unknown
}
internal Mono.Security.Protocol.Tls.Handshake.HandshakeMessage : TlsStream {
private Context context
private HandshakeType handshakeType
private ContentType contentType
private Byte[] cache
public Context Context
public HandshakeType HandshakeType
public ContentType ContentType
public Context get_Context()
public HandshakeType get_HandshakeType()
public ContentType get_ContentType()
public void .ctor(Context context, HandshakeType handshakeType)
public void .ctor(Context context, HandshakeType handshakeType, ContentType contentType)
public void .ctor(Context context, HandshakeType handshakeType, Byte[] data)
protected void ProcessAsTls1()
protected void ProcessAsSsl3()
public void Process()
public void Update()
public Byte[] EncodeMessage()
public bool Compare(Byte[] buffer1, Byte[] buffer2)
}
internal Mono.Security.Protocol.Tls.Handshake.HandshakeType : Enum {
public byte value__
public HandshakeType HelloRequest
public HandshakeType ClientHello
public HandshakeType ServerHello
public HandshakeType Certificate
public HandshakeType ServerKeyExchange
public HandshakeType CertificateRequest
public HandshakeType ServerHelloDone
public HandshakeType CertificateVerify
public HandshakeType ClientKeyExchange
public HandshakeType Finished
public HandshakeType None
}
internal Mono.Security.Protocol.Tls.Handshake.Server.TlsClientCertificate : HandshakeMessage {
private X509CertificateCollection clientCertificates
public bool HasCertificate
public void .ctor(Context context, Byte[] buffer)
public void Update()
public bool get_HasCertificate()
protected void ProcessAsSsl3()
protected void ProcessAsTls1()
private bool checkCertificateUsage(X509Certificate cert)
private void validateCertificates(X509CertificateCollection certificates)
}
internal Mono.Security.Protocol.Tls.Handshake.Server.TlsClientCertificateVerify : HandshakeMessage {
public void .ctor(Context context, Byte[] buffer)
protected void ProcessAsSsl3()
protected void ProcessAsTls1()
}
internal Mono.Security.Protocol.Tls.Handshake.Server.TlsClientFinished : HandshakeMessage {
public void .ctor(Context context, Byte[] buffer)
protected void ProcessAsSsl3()
protected void ProcessAsTls1()
}
internal Mono.Security.Protocol.Tls.Handshake.Server.TlsClientHello : HandshakeMessage {
private Byte[] random
private Byte[] sessionId
private Int16[] cipherSuites
private Byte[] compressionMethods
public void .ctor(Context context, Byte[] buffer)
public void Update()
protected void ProcessAsSsl3()
protected void ProcessAsTls1()
private void processProtocol(short protocol)
private void selectCipherSuite()
private void selectCompressionMethod()
}
internal Mono.Security.Protocol.Tls.Handshake.Server.TlsClientKeyExchange : HandshakeMessage {
public void .ctor(Context context, Byte[] buffer)
protected void ProcessAsSsl3()
protected void ProcessAsTls1()
}
internal Mono.Security.Protocol.Tls.Handshake.Server.TlsServerCertificate : HandshakeMessage {
public void .ctor(Context context)
protected void ProcessAsSsl3()
protected void ProcessAsTls1()
}
internal Mono.Security.Protocol.Tls.Handshake.Server.TlsServerCertificateRequest : HandshakeMessage {
public void .ctor(Context context)
protected void ProcessAsSsl3()
protected void ProcessAsTls1()
}
internal Mono.Security.Protocol.Tls.Handshake.Server.TlsServerFinished : HandshakeMessage {
private Byte[] Ssl3Marker
public void .ctor(Context context)
protected void ProcessAsSsl3()
protected void ProcessAsTls1()
}
internal Mono.Security.Protocol.Tls.Handshake.Server.TlsServerHello : HandshakeMessage {
private int unixTime
private Byte[] random
public void .ctor(Context context)
public void Update()
protected void ProcessAsSsl3()
protected void ProcessAsTls1()
}
internal Mono.Security.Protocol.Tls.Handshake.Server.TlsServerHelloDone : HandshakeMessage {
public void .ctor(Context context)
protected void ProcessAsSsl3()
protected void ProcessAsTls1()
}
internal Mono.Security.Protocol.Tls.Handshake.Server.TlsServerKeyExchange : HandshakeMessage {
public void .ctor(Context context)
public void Update()
protected void ProcessAsSsl3()
protected void ProcessAsTls1()
private Byte[] createSignature(RSA rsa, Byte[] buffer)
}
internal Mono.Security.Protocol.Tls.HandshakeState : Enum {
public int value__
public HandshakeState None
public HandshakeState Started
public HandshakeState Finished
}
public Mono.Security.Protocol.Tls.HashAlgorithmType : Enum {
public int value__
public HashAlgorithmType Md5
public HashAlgorithmType None
public HashAlgorithmType Sha1
}
internal Mono.Security.Protocol.Tls.HttpsClientStream : SslClientStream {
private HttpWebRequest _request
private int _status
public bool TrustFailure
public void .ctor(Stream stream, X509CertificateCollection clientCertificates, HttpWebRequest request, Byte[] buffer)
public bool get_TrustFailure()
internal bool RaiseServerCertificateValidation(X509Certificate certificate, Int32[] certificateErrors)
}
public Mono.Security.Protocol.Tls.PrivateKeySelectionCallback : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public AsymmetricAlgorithm Invoke(X509Certificate certificate, string targetHost)
public IAsyncResult BeginInvoke(X509Certificate certificate, string targetHost, AsyncCallback callback, object object)
public AsymmetricAlgorithm EndInvoke(IAsyncResult result)
}
internal Mono.Security.Protocol.Tls.RecordProtocol : object {
private ManualResetEvent record_processing
protected Stream innerStream
protected Context context
public Context Context
public Context get_Context()
public void set_Context(Context value)
public void .ctor(Stream innerStream, Context context)
public void SendRecord(HandshakeType type)
protected void ProcessHandshakeMessage(TlsStream handMsg)
protected void ProcessChangeCipherSpec()
public HandshakeMessage GetMessage(HandshakeType type)
public IAsyncResult BeginReceiveRecord(Stream record, AsyncCallback callback, object state)
private void InternalReceiveRecordCallback(IAsyncResult asyncResult)
public Byte[] EndReceiveRecord(IAsyncResult asyncResult)
public Byte[] ReceiveRecord(Stream record)
private Byte[] ReadRecordBuffer(int contentType, Stream record)
private void ProcessAlert(AlertLevel alertLevel, AlertDescription alertDesc)
internal void SendAlert(Exception& ex)
public void SendAlert(AlertDescription description)
public void SendAlert(AlertLevel level, AlertDescription description)
public void SendAlert(Alert alert)
public void SendChangeCipherSpec()
public void SendChangeCipherSpec(Stream recordStream)
public IAsyncResult BeginSendChangeCipherSpec(AsyncCallback callback, object state)
public void EndSendChangeCipherSpec(IAsyncResult asyncResult)
public IAsyncResult BeginSendRecord(HandshakeType handshakeType, AsyncCallback callback, object state)
private void InternalSendRecordCallback(IAsyncResult ar)
public IAsyncResult BeginSendRecord(ContentType contentType, Byte[] recordData, AsyncCallback callback, object state)
public void EndSendRecord(IAsyncResult asyncResult)
public void SendRecord(ContentType contentType, Byte[] recordData)
public Byte[] EncodeRecord(ContentType contentType, Byte[] recordData)
public Byte[] EncodeRecord(ContentType contentType, Byte[] recordData, int offset, int count)
public Byte[] EncodeHandshakeRecord(HandshakeType handshakeType)
private Byte[] encryptRecordFragment(ContentType contentType, Byte[] fragment)
private Byte[] decryptRecordFragment(ContentType contentType, Byte[] fragment)
private bool Compare(Byte[] array1, Byte[] array2)
}
internal Mono.Security.Protocol.Tls.RSASslSignatureDeformatter : AsymmetricSignatureDeformatter {
private RSA key
private HashAlgorithm hash
public void .ctor(AsymmetricAlgorithm key)
public bool VerifySignature(Byte[] rgbHash, Byte[] rgbSignature)
public void SetHashAlgorithm(string strName)
public void SetKey(AsymmetricAlgorithm key)
}
internal Mono.Security.Protocol.Tls.RSASslSignatureFormatter : AsymmetricSignatureFormatter {
private RSA key
private HashAlgorithm hash
public void .ctor(AsymmetricAlgorithm key)
public Byte[] CreateSignature(Byte[] rgbHash)
public void SetHashAlgorithm(string strName)
public void SetKey(AsymmetricAlgorithm key)
}
public Mono.Security.Protocol.Tls.SecurityCompressionType : Enum {
public int value__
public SecurityCompressionType None
public SecurityCompressionType Zlib
}
internal Mono.Security.Protocol.Tls.SecurityParameters : object {
private CipherSuite cipher
private Byte[] clientWriteMAC
private Byte[] serverWriteMAC
public CipherSuite Cipher
public Byte[] ClientWriteMAC
public Byte[] ServerWriteMAC
public CipherSuite get_Cipher()
public void set_Cipher(CipherSuite value)
public Byte[] get_ClientWriteMAC()
public void set_ClientWriteMAC(Byte[] value)
public Byte[] get_ServerWriteMAC()
public void set_ServerWriteMAC(Byte[] value)
public void Clear()
}
public Mono.Security.Protocol.Tls.SecurityProtocolType : Enum {
public int value__
public SecurityProtocolType Default
public SecurityProtocolType Ssl2
public SecurityProtocolType Ssl3
public SecurityProtocolType Tls
public SecurityProtocolType Tls11
public SecurityProtocolType Tls12
}
internal Mono.Security.Protocol.Tls.ServerContext : Context {
private SslServerStream sslStream
private bool request_client_certificate
private bool clientCertificateRequired
public SslServerStream SslStream
public bool ClientCertificateRequired
public bool RequestClientCertificate
public SslServerStream get_SslStream()
public bool get_ClientCertificateRequired()
public bool get_RequestClientCertificate()
public void .ctor(SslServerStream stream, SecurityProtocolType securityProtocolType, X509Certificate serverCertificate, bool clientCertificateRequired, bool requestClientCertificate)
}
internal Mono.Security.Protocol.Tls.ServerRecordProtocol : RecordProtocol {
private TlsClientCertificate cert
public void .ctor(Stream innerStream, ServerContext context)
public HandshakeMessage GetMessage(HandshakeType type)
protected void ProcessHandshakeMessage(TlsStream handMsg)
private HandshakeMessage createClientHandshakeMessage(HandshakeType type, Byte[] buffer)
private HandshakeMessage createServerHandshakeMessage(HandshakeType type)
}
internal Mono.Security.Protocol.Tls.SslCipherSuite : CipherSuite {
private Byte[] pad1
private Byte[] pad2
private int MacHeaderLength
private Byte[] header
public void .ctor(short code, string name, CipherAlgorithmType cipherAlgorithmType, HashAlgorithmType hashAlgorithmType, ExchangeAlgorithmType exchangeAlgorithmType, bool exportable, bool blockMode, byte keyMaterialSize, byte expandedKeyMaterialSize, short effectiveKeyBytes, byte ivSize, byte blockSize)
public Byte[] ComputeServerRecordMAC(ContentType contentType, Byte[] fragment)
public Byte[] ComputeClientRecordMAC(ContentType contentType, Byte[] fragment)
public void ComputeMasterSecret(Byte[] preMasterSecret)
public void ComputeKeys()
private Byte[] prf(Byte[] secret, string label, Byte[] random)
}
public Mono.Security.Protocol.Tls.SslClientStream : SslStreamBase {
private CertificateValidationCallback ServerCertValidation
private CertificateSelectionCallback ClientCertSelection
private PrivateKeySelectionCallback PrivateKeySelection
private CertificateValidationCallback2 ServerCertValidation2
internal Stream InputBuffer
public X509CertificateCollection ClientCertificates
public X509Certificate SelectedClientCertificate
public CertificateValidationCallback ServerCertValidationDelegate
public CertificateSelectionCallback ClientCertSelectionDelegate
public PrivateKeySelectionCallback PrivateKeyCertSelectionDelegate
internal bool HaveRemoteValidation2Callback
internal void add_ServerCertValidation(CertificateValidationCallback value)
internal void remove_ServerCertValidation(CertificateValidationCallback value)
internal void add_ClientCertSelection(CertificateSelectionCallback value)
internal void remove_ClientCertSelection(CertificateSelectionCallback value)
internal void add_PrivateKeySelection(PrivateKeySelectionCallback value)
internal void remove_PrivateKeySelection(PrivateKeySelectionCallback value)
internal Stream get_InputBuffer()
public X509CertificateCollection get_ClientCertificates()
public X509Certificate get_SelectedClientCertificate()
public CertificateValidationCallback get_ServerCertValidationDelegate()
public void set_ServerCertValidationDelegate(CertificateValidationCallback value)
public CertificateSelectionCallback get_ClientCertSelectionDelegate()
public void set_ClientCertSelectionDelegate(CertificateSelectionCallback value)
public PrivateKeySelectionCallback get_PrivateKeyCertSelectionDelegate()
public void set_PrivateKeyCertSelectionDelegate(PrivateKeySelectionCallback value)
public void add_ServerCertValidation2(CertificateValidationCallback2 value)
public void remove_ServerCertValidation2(CertificateValidationCallback2 value)
public void .ctor(Stream stream, string targetHost, bool ownsStream)
public void .ctor(Stream stream, string targetHost, X509Certificate clientCertificate)
public void .ctor(Stream stream, string targetHost, X509CertificateCollection clientCertificates)
public void .ctor(Stream stream, string targetHost, bool ownsStream, SecurityProtocolType securityProtocolType)
public void .ctor(Stream stream, string targetHost, bool ownsStream, SecurityProtocolType securityProtocolType, X509CertificateCollection clientCertificates)
protected void Finalize()
protected void Dispose(bool disposing)
private void SafeEndReceiveRecord(IAsyncResult ar, bool ignoreEmpty)
internal IAsyncResult BeginNegotiateHandshake(AsyncCallback callback, object state)
internal void EndNegotiateHandshake(IAsyncResult result)
private void NegotiateAsyncWorker(IAsyncResult result)
internal X509Certificate OnLocalCertificateSelection(X509CertificateCollection clientCertificates, X509Certificate serverCertificate, string targetHost, X509CertificateCollection serverRequestedCertificates)
internal bool get_HaveRemoteValidation2Callback()
internal ValidationResult OnRemoteCertificateValidation2(X509CertificateCollection collection)
internal bool OnRemoteCertificateValidation(X509Certificate certificate, Int32[] errors)
internal bool RaiseServerCertificateValidation(X509Certificate certificate, Int32[] certificateErrors)
internal ValidationResult RaiseServerCertificateValidation2(X509CertificateCollection collection)
internal X509Certificate RaiseClientCertificateSelection(X509CertificateCollection clientCertificates, X509Certificate serverCertificate, string targetHost, X509CertificateCollection serverRequestedCertificates)
internal AsymmetricAlgorithm OnLocalPrivateKeySelection(X509Certificate certificate, string targetHost)
internal AsymmetricAlgorithm RaisePrivateKeySelection(X509Certificate certificate, string targetHost)
}
internal Mono.Security.Protocol.Tls.SslHandshakeHash : HashAlgorithm {
private HashAlgorithm md5
private HashAlgorithm sha
private bool hashing
private Byte[] secret
private Byte[] innerPadMD5
private Byte[] outerPadMD5
private Byte[] innerPadSHA
private Byte[] outerPadSHA
public void .ctor(Byte[] secret)
public void Initialize()
protected Byte[] HashFinal()
protected void HashCore(Byte[] array, int ibStart, int cbSize)
public Byte[] CreateSignature(RSA rsa)
public bool VerifySignature(RSA rsa, Byte[] rgbSignature)
private void initializePad()
}
public Mono.Security.Protocol.Tls.SslServerStream : SslStreamBase {
private CertificateValidationCallback ClientCertValidation
private PrivateKeySelectionCallback PrivateKeySelection
private CertificateValidationCallback2 ClientCertValidation2
public X509Certificate ClientCertificate
public CertificateValidationCallback ClientCertValidationDelegate
public PrivateKeySelectionCallback PrivateKeyCertSelectionDelegate
internal bool HaveRemoteValidation2Callback
internal void add_ClientCertValidation(CertificateValidationCallback value)
internal void remove_ClientCertValidation(CertificateValidationCallback value)
internal void add_PrivateKeySelection(PrivateKeySelectionCallback value)
internal void remove_PrivateKeySelection(PrivateKeySelectionCallback value)
public X509Certificate get_ClientCertificate()
public CertificateValidationCallback get_ClientCertValidationDelegate()
public void set_ClientCertValidationDelegate(CertificateValidationCallback value)
public PrivateKeySelectionCallback get_PrivateKeyCertSelectionDelegate()
public void set_PrivateKeyCertSelectionDelegate(PrivateKeySelectionCallback value)
public void add_ClientCertValidation2(CertificateValidationCallback2 value)
public void remove_ClientCertValidation2(CertificateValidationCallback2 value)
public void .ctor(Stream stream, X509Certificate serverCertificate)
public void .ctor(Stream stream, X509Certificate serverCertificate, bool clientCertificateRequired, bool ownsStream)
public void .ctor(Stream stream, X509Certificate serverCertificate, bool clientCertificateRequired, bool requestClientCertificate, bool ownsStream)
public void .ctor(Stream stream, X509Certificate serverCertificate, bool clientCertificateRequired, bool ownsStream, SecurityProtocolType securityProtocolType)
public void .ctor(Stream stream, X509Certificate serverCertificate, bool clientCertificateRequired, bool requestClientCertificate, bool ownsStream, SecurityProtocolType securityProtocolType)
protected void Finalize()
protected void Dispose(bool disposing)
internal IAsyncResult BeginNegotiateHandshake(AsyncCallback callback, object state)
internal void EndNegotiateHandshake(IAsyncResult asyncResult)
internal X509Certificate OnLocalCertificateSelection(X509CertificateCollection clientCertificates, X509Certificate serverCertificate, string targetHost, X509CertificateCollection serverRequestedCertificates)
internal bool OnRemoteCertificateValidation(X509Certificate certificate, Int32[] errors)
internal bool get_HaveRemoteValidation2Callback()
internal ValidationResult OnRemoteCertificateValidation2(X509CertificateCollection collection)
internal bool RaiseClientCertificateValidation(X509Certificate certificate, Int32[] certificateErrors)
internal AsymmetricAlgorithm OnLocalPrivateKeySelection(X509Certificate certificate, string targetHost)
internal AsymmetricAlgorithm RaisePrivateKeySelection(X509Certificate certificate, string targetHost)
}
public Mono.Security.Protocol.Tls.SslStreamBase : Stream {
private ManualResetEvent record_processing
internal Stream innerStream
internal MemoryStream inputBuffer
internal Context context
internal RecordProtocol protocol
internal bool ownsStream
private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) disposed
private bool checkCertRevocationStatus
private object negotiate
private object read
private object write
private ManualResetEvent negotiationComplete
private Byte[] recbuf
private MemoryStream recordStream
internal bool MightNeedHandshake
internal bool HaveRemoteValidation2Callback
public bool CheckCertRevocationStatus
public CipherAlgorithmType CipherAlgorithm
public int CipherStrength
public HashAlgorithmType HashAlgorithm
public int HashStrength
public int KeyExchangeStrength
public ExchangeAlgorithmType KeyExchangeAlgorithm
public SecurityProtocolType SecurityProtocol
public X509Certificate ServerCertificate
internal X509CertificateCollection ServerCertificates
public bool CanRead
public bool CanSeek
public bool CanWrite
public long Length
public long Position
protected void .ctor(Stream stream, bool ownsStream)
private void AsyncHandshakeCallback(IAsyncResult asyncResult)
internal bool get_MightNeedHandshake()
internal void NegotiateHandshake()
internal IAsyncResult BeginNegotiateHandshake(AsyncCallback callback, object state)
internal void EndNegotiateHandshake(IAsyncResult result)
internal X509Certificate OnLocalCertificateSelection(X509CertificateCollection clientCertificates, X509Certificate serverCertificate, string targetHost, X509CertificateCollection serverRequestedCertificates)
internal bool OnRemoteCertificateValidation(X509Certificate certificate, Int32[] errors)
internal ValidationResult OnRemoteCertificateValidation2(X509CertificateCollection collection)
internal bool get_HaveRemoteValidation2Callback()
internal AsymmetricAlgorithm OnLocalPrivateKeySelection(X509Certificate certificate, string targetHost)
internal X509Certificate RaiseLocalCertificateSelection(X509CertificateCollection certificates, X509Certificate remoteCertificate, string targetHost, X509CertificateCollection requestedCertificates)
internal bool RaiseRemoteCertificateValidation(X509Certificate certificate, Int32[] errors)
internal ValidationResult RaiseRemoteCertificateValidation2(X509CertificateCollection collection)
internal AsymmetricAlgorithm RaiseLocalPrivateKeySelection(X509Certificate certificate, string targetHost)
public bool get_CheckCertRevocationStatus()
public void set_CheckCertRevocationStatus(bool value)
public CipherAlgorithmType get_CipherAlgorithm()
public int get_CipherStrength()
public HashAlgorithmType get_HashAlgorithm()
public int get_HashStrength()
public int get_KeyExchangeStrength()
public ExchangeAlgorithmType get_KeyExchangeAlgorithm()
public SecurityProtocolType get_SecurityProtocol()
public X509Certificate get_ServerCertificate()
internal X509CertificateCollection get_ServerCertificates()
private bool BeginNegotiateHandshake(InternalAsyncResult asyncResult)
private void EndNegotiateHandshake(InternalAsyncResult asyncResult)
public IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state)
private void InternalBeginRead(InternalAsyncResult asyncResult)
private void InternalReadCallback(IAsyncResult result)
private void InternalReadCallback_inner(InternalAsyncResult internalResult, Byte[] recbuf, Object[] state, bool didRead, int n)
private void InternalBeginWrite(InternalAsyncResult asyncResult)
private void InternalWriteCallback(IAsyncResult ar)
public IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state)
public int EndRead(IAsyncResult asyncResult)
public void EndWrite(IAsyncResult asyncResult)
public void Close()
public void Flush()
public int Read(Byte[] buffer)
public int Read(Byte[] buffer, int offset, int count)
public long Seek(long offset, SeekOrigin origin)
public void SetLength(long value)
public void Write(Byte[] buffer)
public void Write(Byte[] buffer, int offset, int count)
public bool get_CanRead()
public bool get_CanSeek()
public bool get_CanWrite()
public long get_Length()
public long get_Position()
public void set_Position(long value)
protected void Finalize()
protected void Dispose(bool disposing)
private void resetBuffer()
internal void checkDisposed()
}
internal Mono.Security.Protocol.Tls.TlsCipherSuite : CipherSuite {
private int MacHeaderLength
private Byte[] header
private object headerLock
public void .ctor(short code, string name, CipherAlgorithmType cipherAlgorithmType, HashAlgorithmType hashAlgorithmType, ExchangeAlgorithmType exchangeAlgorithmType, bool exportable, bool blockMode, byte keyMaterialSize, byte expandedKeyMaterialSize, short effectiveKeyBytes, byte ivSize, byte blockSize)
public Byte[] ComputeServerRecordMAC(ContentType contentType, Byte[] fragment)
public Byte[] ComputeClientRecordMAC(ContentType contentType, Byte[] fragment)
public void ComputeMasterSecret(Byte[] preMasterSecret)
public void ComputeKeys()
}
internal Mono.Security.Protocol.Tls.TlsClientSettings : object {
private string targetHost
private X509CertificateCollection certificates
private X509Certificate clientCertificate
private RSAManaged certificateRSA
public string TargetHost
public X509CertificateCollection Certificates
public X509Certificate ClientCertificate
public RSAManaged CertificateRSA
public string get_TargetHost()
public void set_TargetHost(string value)
public X509CertificateCollection get_Certificates()
public void set_Certificates(X509CertificateCollection value)
public X509Certificate get_ClientCertificate()
public void set_ClientCertificate(X509Certificate value)
public RSAManaged get_CertificateRSA()
public void UpdateCertificateRSA()
}
internal Mono.Security.Protocol.Tls.TlsException : Exception {
private Alert alert
public Alert Alert
public Alert get_Alert()
internal void .ctor(string message)
internal void .ctor(SerializationInfo info, StreamingContext context)
internal void .ctor(string message, Exception ex)
internal void .ctor(AlertLevel level, AlertDescription description)
internal void .ctor(AlertLevel level, AlertDescription description, string message)
internal void .ctor(AlertDescription description)
internal void .ctor(AlertDescription description, string message)
}
internal Mono.Security.Protocol.Tls.TlsServerSettings : object {
private X509CertificateCollection certificates
private RSA certificateRSA
private RSAParameters rsaParameters
private Byte[] signedParams
private String[] distinguisedNames
private bool serverKeyExchange
private bool certificateRequest
private ClientCertificateType[] certificateTypes
public bool ServerKeyExchange
public X509CertificateCollection Certificates
public RSA CertificateRSA
public RSAParameters RsaParameters
public Byte[] SignedParams
public bool CertificateRequest
public ClientCertificateType[] CertificateTypes
public String[] DistinguisedNames
public bool get_ServerKeyExchange()
public void set_ServerKeyExchange(bool value)
public X509CertificateCollection get_Certificates()
public void set_Certificates(X509CertificateCollection value)
public RSA get_CertificateRSA()
public RSAParameters get_RsaParameters()
public void set_RsaParameters(RSAParameters value)
public Byte[] get_SignedParams()
public void set_SignedParams(Byte[] value)
public bool get_CertificateRequest()
public void set_CertificateRequest(bool value)
public ClientCertificateType[] get_CertificateTypes()
public void set_CertificateTypes(ClientCertificateType[] value)
public String[] get_DistinguisedNames()
public void set_DistinguisedNames(String[] value)
public void UpdateCertificateRSA()
}
internal Mono.Security.Protocol.Tls.TlsStream : Stream {
private bool canRead
private bool canWrite
private MemoryStream buffer
private Byte[] temp
private int temp_size
public bool EOF
public bool CanWrite
public bool CanRead
public bool CanSeek
public long Position
public long Length
public bool get_EOF()
public bool get_CanWrite()
public bool get_CanRead()
public bool get_CanSeek()
public long get_Position()
public void set_Position(long value)
public long get_Length()
public void .ctor(Byte[] data)
private Byte[] ReadSmallValue(int length)
public byte ReadByte()
public short ReadInt16()
public int ReadInt24()
public int ReadInt32()
public Byte[] ReadBytes(int count)
public void Write(byte value)
public void Write(short value)
public void WriteInt24(int value)
public void Write(int value)
public void Write(ulong value)
public void Write(Byte[] buffer)
public void Reset()
public Byte[] ToArray()
public void Flush()
public void SetLength(long length)
public long Seek(long offset, SeekOrigin loc)
public int Read(Byte[] buffer, int offset, int count)
public void Write(Byte[] buffer, int offset, int count)
}
public Mono.Security.StrongName : object {
private RSA rsa
private Byte[] publicKey
private Byte[] keyToken
private string tokenAlgorithm
public bool CanSign
public RSA RSA
public Byte[] PublicKey
public Byte[] PublicKeyToken
public string TokenAlgorithm
public void .ctor(int keySize)
public void .ctor(Byte[] data)
public void .ctor(RSA rsa)
private void InvalidateCache()
public bool get_CanSign()
public RSA get_RSA()
public void set_RSA(RSA value)
public Byte[] get_PublicKey()
public Byte[] get_PublicKeyToken()
public string get_TokenAlgorithm()
public void set_TokenAlgorithm(string value)
public Byte[] GetBytes()
private UInt32 RVAtoPosition(UInt32 r, int sections, Byte[] headers)
internal StrongNameSignature StrongHash(Stream stream, StrongNameOptions options)
public Byte[] Hash(string fileName)
public bool Sign(string fileName)
public bool Verify(string fileName)
public bool Verify(Stream stream)
private bool Verify(RSA rsa, AssemblyHashAlgorithm algorithm, Byte[] hash, Byte[] signature)
}
public Mono.Security.X509.Extensions.AuthorityKeyIdentifierExtension : X509Extension {
private Byte[] aki
public string Name
public Byte[] Identifier
public void .ctor(ASN1 asn1)
public void .ctor(X509Extension extension)
protected void Decode()
protected void Encode()
public string get_Name()
public Byte[] get_Identifier()
public void set_Identifier(Byte[] value)
public string ToString()
}
public Mono.Security.X509.Extensions.BasicConstraintsExtension : X509Extension {
public int NoPathLengthConstraint
private bool cA
private int pathLenConstraint
public bool CertificateAuthority
public string Name
public int PathLenConstraint
public void .ctor(ASN1 asn1)
public void .ctor(X509Extension extension)
protected void Decode()
protected void Encode()
public bool get_CertificateAuthority()
public void set_CertificateAuthority(bool value)
public string get_Name()
public int get_PathLenConstraint()
public void set_PathLenConstraint(int value)
public string ToString()
}
public Mono.Security.X509.Extensions.CertificatePoliciesExtension : X509Extension {
private Hashtable policies
public string Name
public void .ctor(ASN1 asn1)
public void .ctor(X509Extension extension)
protected void Decode()
public string get_Name()
public string ToString()
}
public Mono.Security.X509.Extensions.CRLDistributionPointsExtension : X509Extension {
private List`1<DistributionPoint> dps
public string Name
public IEnumerable`1<DistributionPoint> DistributionPoints
public void .ctor(ASN1 asn1)
public void .ctor(X509Extension extension)
protected void Decode()
public string get_Name()
public IEnumerable`1<DistributionPoint> get_DistributionPoints()
public string ToString()
}
public Mono.Security.X509.Extensions.ExtendedKeyUsageExtension : X509Extension {
private ArrayList keyPurpose
public ArrayList KeyPurpose
public string Name
public void .ctor(ASN1 asn1)
public void .ctor(X509Extension extension)
protected void Decode()
protected void Encode()
public ArrayList get_KeyPurpose()
public string get_Name()
public string ToString()
}
internal Mono.Security.X509.Extensions.GeneralNames : object {
private ArrayList rfc822Name
private ArrayList dnsName
private ArrayList directoryNames
private ArrayList uris
private ArrayList ipAddr
private ASN1 asn
public String[] RFC822
public String[] DirectoryNames
public String[] DNSNames
public String[] UniformResourceIdentifiers
public String[] IPAddresses
public void .ctor(String[] rfc822s, String[] dnsNames, String[] ipAddresses, String[] uris)
public void .ctor(ASN1 sequence)
public String[] get_RFC822()
public String[] get_DirectoryNames()
public String[] get_DNSNames()
public String[] get_UniformResourceIdentifiers()
public String[] get_IPAddresses()
public Byte[] GetBytes()
public string ToString()
}
public Mono.Security.X509.Extensions.KeyAttributesExtension : X509Extension {
private Byte[] keyId
private int kubits
private DateTime notBefore
private DateTime notAfter
public Byte[] KeyIdentifier
public string Name
public DateTime NotAfter
public DateTime NotBefore
public void .ctor(ASN1 asn1)
public void .ctor(X509Extension extension)
protected void Decode()
public Byte[] get_KeyIdentifier()
public string get_Name()
public DateTime get_NotAfter()
public DateTime get_NotBefore()
public bool Support(KeyUsages usage)
public string ToString()
}
public Mono.Security.X509.Extensions.KeyUsageExtension : X509Extension {
private int kubits
public KeyUsages KeyUsage
public string Name
public void .ctor(ASN1 asn1)
public void .ctor(X509Extension extension)
protected void Decode()
protected void Encode()
public KeyUsages get_KeyUsage()
public void set_KeyUsage(KeyUsages value)
public string get_Name()
public bool Support(KeyUsages usage)
public string ToString()
}
public Mono.Security.X509.Extensions.KeyUsages : Enum {
public int value__
public KeyUsages digitalSignature
public KeyUsages nonRepudiation
public KeyUsages keyEncipherment
public KeyUsages dataEncipherment
public KeyUsages keyAgreement
public KeyUsages keyCertSign
public KeyUsages cRLSign
public KeyUsages encipherOnly
public KeyUsages decipherOnly
public KeyUsages none
}
public Mono.Security.X509.Extensions.NetscapeCertTypeExtension : X509Extension {
private int ctbits
public string Name
public void .ctor(ASN1 asn1)
public void .ctor(X509Extension extension)
protected void Decode()
public string get_Name()
public bool Support(CertTypes usage)
public string ToString()
}
public Mono.Security.X509.Extensions.PrivateKeyUsagePeriodExtension : X509Extension {
private DateTime notBefore
private DateTime notAfter
public string Name
public void .ctor(ASN1 asn1)
public void .ctor(X509Extension extension)
protected void Decode()
public string get_Name()
public string ToString()
}
public Mono.Security.X509.Extensions.SubjectAltNameExtension : X509Extension {
private GeneralNames _names
public string Name
public String[] RFC822
public String[] DNSNames
public String[] IPAddresses
public String[] UniformResourceIdentifiers
public void .ctor(ASN1 asn1)
public void .ctor(X509Extension extension)
public void .ctor(String[] rfc822, String[] dnsNames, String[] ipAddresses, String[] uris)
protected void Decode()
public string get_Name()
public String[] get_RFC822()
public String[] get_DNSNames()
public String[] get_IPAddresses()
public String[] get_UniformResourceIdentifiers()
public string ToString()
}
public Mono.Security.X509.Extensions.SubjectKeyIdentifierExtension : X509Extension {
private Byte[] ski
public string Name
public Byte[] Identifier
public void .ctor(ASN1 asn1)
public void .ctor(X509Extension extension)
protected void Decode()
protected void Encode()
public string get_Name()
public Byte[] get_Identifier()
public void set_Identifier(Byte[] value)
public string ToString()
}
public Mono.Security.X509.PKCS12 : object {
public string pbeWithSHAAnd128BitRC4
public string pbeWithSHAAnd40BitRC4
public string pbeWithSHAAnd3KeyTripleDESCBC
public string pbeWithSHAAnd2KeyTripleDESCBC
public string pbeWithSHAAnd128BitRC2CBC
public string pbeWithSHAAnd40BitRC2CBC
public string keyBag
public string pkcs8ShroudedKeyBag
public string certBag
public string crlBag
public string secretBag
public string safeContentsBag
public string x509Certificate
public string sdsiCertificate
public string x509Crl
private int recommendedIterationCount
private Byte[] _password
private ArrayList _keyBags
private ArrayList _secretBags
private X509CertificateCollection _certs
private bool _keyBagsChanged
private bool _secretBagsChanged
private bool _certsChanged
private int _iterations
private ArrayList _safeBags
private RandomNumberGenerator _rng
public int CryptoApiPasswordLimit
private int password_max_length
public string Password
public int IterationCount
public ArrayList Keys
public ArrayList Secrets
public X509CertificateCollection Certificates
internal RandomNumberGenerator RNG
public int MaximumPasswordLength
public void .ctor(Byte[] data)
public void .ctor(Byte[] data, string password)
public void .ctor(Byte[] data, Byte[] password)
private void Decode(Byte[] data)
protected void Finalize()
public void set_Password(string value)
public int get_IterationCount()
public void set_IterationCount(int value)
public ArrayList get_Keys()
public ArrayList get_Secrets()
public X509CertificateCollection get_Certificates()
internal RandomNumberGenerator get_RNG()
private bool Compare(Byte[] expected, Byte[] actual)
private SymmetricAlgorithm GetSymmetricAlgorithm(string algorithmOid, Byte[] salt, int iterationCount)
public Byte[] Decrypt(string algorithmOid, Byte[] salt, int iterationCount, Byte[] encryptedData)
public Byte[] Decrypt(EncryptedData ed)
public Byte[] Encrypt(string algorithmOid, Byte[] salt, int iterationCount, Byte[] data)
private DSAParameters GetExistingParameters(Boolean& found)
private void AddPrivateKey(PrivateKeyInfo pki)
private void ReadSafeBag(ASN1 safeBag)
private ASN1 Pkcs8ShroudedKeyBagSafeBag(AsymmetricAlgorithm aa, IDictionary attributes)
private ASN1 KeyBagSafeBag(AsymmetricAlgorithm aa, IDictionary attributes)
private ASN1 SecretBagSafeBag(Byte[] secret, IDictionary attributes)
private ASN1 CertificateSafeBag(X509Certificate x509, IDictionary attributes)
private Byte[] MAC(Byte[] password, Byte[] salt, int iterations, Byte[] data)
public Byte[] GetBytes()
private ContentInfo EncryptedContentInfo(ASN1 safeBags, string algorithmOid)
public void AddCertificate(X509Certificate cert)
public void AddCertificate(X509Certificate cert, IDictionary attributes)
public void RemoveCertificate(X509Certificate cert)
public void RemoveCertificate(X509Certificate cert, IDictionary attrs)
private bool CompareAsymmetricAlgorithm(AsymmetricAlgorithm a1, AsymmetricAlgorithm a2)
public void AddPkcs8ShroudedKeyBag(AsymmetricAlgorithm aa)
public void AddPkcs8ShroudedKeyBag(AsymmetricAlgorithm aa, IDictionary attributes)
public void RemovePkcs8ShroudedKeyBag(AsymmetricAlgorithm aa)
public void AddKeyBag(AsymmetricAlgorithm aa)
public void AddKeyBag(AsymmetricAlgorithm aa, IDictionary attributes)
public void RemoveKeyBag(AsymmetricAlgorithm aa)
public void AddSecretBag(Byte[] secret)
public void AddSecretBag(Byte[] secret, IDictionary attributes)
public void RemoveSecretBag(Byte[] secret)
public AsymmetricAlgorithm GetAsymmetricAlgorithm(IDictionary attrs)
public Byte[] GetSecret(IDictionary attrs)
public X509Certificate GetCertificate(IDictionary attrs)
public IDictionary GetAttributes(AsymmetricAlgorithm aa)
public IDictionary GetAttributes(X509Certificate cert)
public void SaveToFile(string filename)
public object Clone()
public int get_MaximumPasswordLength()
public void set_MaximumPasswordLength(int value)
private Byte[] LoadFile(string filename)
public PKCS12 LoadFromFile(string filename)
public PKCS12 LoadFromFile(string filename, string password)
}
public Mono.Security.X509.PKCS5 : object {
public string pbeWithMD2AndDESCBC
public string pbeWithMD5AndDESCBC
public string pbeWithMD2AndRC2CBC
public string pbeWithMD5AndRC2CBC
public string pbeWithSHA1AndDESCBC
public string pbeWithSHA1AndRC2CBC
}
public Mono.Security.X509.PKCS9 : object {
public string friendlyName
public string localKeyId
}
internal Mono.Security.X509.SafeBag : object {
private string _bagOID
private ASN1 _asn1
public string BagOID
public ASN1 ASN1
public void .ctor(string bagOID, ASN1 asn1)
public string get_BagOID()
public ASN1 get_ASN1()
}
public Mono.Security.X509.X501 : object {
private Byte[] countryName
private Byte[] organizationName
private Byte[] organizationalUnitName
private Byte[] commonName
private Byte[] localityName
private Byte[] stateOrProvinceName
private Byte[] streetAddress
private Byte[] domainComponent
private Byte[] userid
private Byte[] email
private Byte[] dnQualifier
private Byte[] title
private Byte[] surname
private Byte[] givenName
private Byte[] initial
public string ToString(ASN1 seq)
public string ToString(ASN1 seq, bool reversed, string separator, bool quotes)
private void AppendEntry(StringBuilder sb, ASN1 entry, bool quotes)
private AttributeTypeAndValue GetAttributeFromOid(string attributeType)
private bool IsOid(string oid)
private AttributeTypeAndValue ReadAttribute(string value, Int32& pos)
private bool IsHex(char c)
private string ReadHex(string value, Int32& pos)
private int ReadEscaped(StringBuilder sb, string value, int pos)
private int ReadQuoted(StringBuilder sb, string value, int pos)
private string ReadValue(string value, Int32& pos)
public ASN1 FromString(string rdn)
}
public Mono.Security.X509.X509Builder : object {
private string defaultHash
private string hashName
public string Hash
protected ASN1 ToBeSigned(string hashName)
protected string GetOid(string hashName)
public string get_Hash()
public void set_Hash(string value)
public Byte[] Sign(AsymmetricAlgorithm aa)
private Byte[] Build(ASN1 tbs, string hashoid, Byte[] signature)
public Byte[] Sign(RSA key)
public Byte[] Sign(DSA key)
}
public Mono.Security.X509.X509Certificate : object {
private ASN1 decoder
private Byte[] m_encodedcert
private DateTime m_from
private DateTime m_until
private ASN1 issuer
private string m_issuername
private string m_keyalgo
private Byte[] m_keyalgoparams
private ASN1 subject
private string m_subject
private Byte[] m_publickey
private Byte[] signature
private string m_signaturealgo
private Byte[] m_signaturealgoparams
private Byte[] certhash
private RSA _rsa
private DSA _dsa
private string OID_DSA
private string OID_RSA
private int version
private Byte[] serialnumber
private Byte[] issuerUniqueID
private Byte[] subjectUniqueID
private X509ExtensionCollection extensions
private string encoding_error
public DSA DSA
public X509ExtensionCollection Extensions
public Byte[] Hash
public string IssuerName
public string KeyAlgorithm
public Byte[] KeyAlgorithmParameters
public Byte[] PublicKey
public RSA RSA
public Byte[] RawData
public Byte[] SerialNumber
public Byte[] Signature
public string SignatureAlgorithm
public Byte[] SignatureAlgorithmParameters
public string SubjectName
public DateTime ValidFrom
public DateTime ValidUntil
public int Version
public bool IsCurrent
public Byte[] IssuerUniqueIdentifier
public Byte[] SubjectUniqueIdentifier
public bool IsSelfSigned
private void Parse(Byte[] data)
public void .ctor(Byte[] data)
private Byte[] GetUnsignedBigInteger(Byte[] integer)
public DSA get_DSA()
public void set_DSA(DSA value)
public X509ExtensionCollection get_Extensions()
public Byte[] get_Hash()
public string get_IssuerName()
public string get_KeyAlgorithm()
public Byte[] get_KeyAlgorithmParameters()
public void set_KeyAlgorithmParameters(Byte[] value)
public Byte[] get_PublicKey()
public RSA get_RSA()
public void set_RSA(RSA value)
public Byte[] get_RawData()
public Byte[] get_SerialNumber()
public Byte[] get_Signature()
public string get_SignatureAlgorithm()
public Byte[] get_SignatureAlgorithmParameters()
public string get_SubjectName()
public DateTime get_ValidFrom()
public DateTime get_ValidUntil()
public int get_Version()
public bool get_IsCurrent()
public bool WasCurrent(DateTime instant)
public Byte[] get_IssuerUniqueIdentifier()
public Byte[] get_SubjectUniqueIdentifier()
internal bool VerifySignature(DSA dsa)
internal bool VerifySignature(RSA rsa)
public bool VerifySignature(AsymmetricAlgorithm aa)
public bool CheckSignature(Byte[] hash, string hashAlgorithm, Byte[] signature)
public bool get_IsSelfSigned()
public ASN1 GetIssuerName()
public ASN1 GetSubjectName()
protected void .ctor(SerializationInfo info, StreamingContext context)
public void GetObjectData(SerializationInfo info, StreamingContext context)
private Byte[] PEM(string type, Byte[] data)
}
public Mono.Security.X509.X509CertificateBuilder : X509Builder {
private byte version
private Byte[] sn
private string issuer
private DateTime notBefore
private DateTime notAfter
private string subject
private AsymmetricAlgorithm aa
private Byte[] issuerUniqueID
private Byte[] subjectUniqueID
private X509ExtensionCollection extensions
public byte Version
public Byte[] SerialNumber
public string IssuerName
public DateTime NotBefore
public DateTime NotAfter
public string SubjectName
public AsymmetricAlgorithm SubjectPublicKey
public Byte[] IssuerUniqueId
public Byte[] SubjectUniqueId
public X509ExtensionCollection Extensions
public void .ctor(byte version)
public byte get_Version()
public void set_Version(byte value)
public Byte[] get_SerialNumber()
public void set_SerialNumber(Byte[] value)
public string get_IssuerName()
public void set_IssuerName(string value)
public DateTime get_NotBefore()
public void set_NotBefore(DateTime value)
public DateTime get_NotAfter()
public void set_NotAfter(DateTime value)
public string get_SubjectName()
public void set_SubjectName(string value)
public AsymmetricAlgorithm get_SubjectPublicKey()
public void set_SubjectPublicKey(AsymmetricAlgorithm value)
public Byte[] get_IssuerUniqueId()
public void set_IssuerUniqueId(Byte[] value)
public Byte[] get_SubjectUniqueId()
public void set_SubjectUniqueId(Byte[] value)
public X509ExtensionCollection get_Extensions()
private ASN1 SubjectPublicKeyInfo()
private Byte[] UniqueIdentifier(Byte[] id)
protected ASN1 ToBeSigned(string oid)
}
public Mono.Security.X509.X509CertificateCollection : CollectionBase {
public X509Certificate Item
public void .ctor(X509Certificate[] value)
public void .ctor(X509CertificateCollection value)
public X509Certificate get_Item(int index)
public void set_Item(int index, X509Certificate value)
public int Add(X509Certificate value)
public void AddRange(X509Certificate[] value)
public void AddRange(X509CertificateCollection value)
public bool Contains(X509Certificate value)
public void CopyTo(X509Certificate[] array, int index)
public X509CertificateEnumerator GetEnumerator()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
public int GetHashCode()
public int IndexOf(X509Certificate value)
public void Insert(int index, X509Certificate value)
public void Remove(X509Certificate value)
private bool Compare(Byte[] array1, Byte[] array2)
}
public Mono.Security.X509.X509Chain : object {
private X509CertificateCollection roots
private X509CertificateCollection certs
private X509Certificate _root
private X509CertificateCollection _chain
private X509ChainStatusFlags _status
public X509CertificateCollection Chain
public X509Certificate Root
public X509ChainStatusFlags Status
public X509CertificateCollection TrustAnchors
public void .ctor(X509CertificateCollection chain)
public X509CertificateCollection get_Chain()
public X509Certificate get_Root()
public X509ChainStatusFlags get_Status()
public X509CertificateCollection get_TrustAnchors()
public void set_TrustAnchors(X509CertificateCollection value)
public void LoadCertificate(X509Certificate x509)
public void LoadCertificates(X509CertificateCollection collection)
public X509Certificate FindByIssuerName(string issuerName)
public bool Build(X509Certificate leaf)
public void Reset()
private bool IsValid(X509Certificate cert)
private X509Certificate FindCertificateParent(X509Certificate child)
private X509Certificate FindCertificateRoot(X509Certificate potentialRoot)
private bool IsTrusted(X509Certificate potentialTrusted)
private bool IsParent(X509Certificate child, X509Certificate parent)
}
public Mono.Security.X509.X509ChainStatusFlags : Enum {
public int value__
public X509ChainStatusFlags InvalidBasicConstraints
public X509ChainStatusFlags NoError
public X509ChainStatusFlags NotSignatureValid
public X509ChainStatusFlags NotTimeNested
public X509ChainStatusFlags NotTimeValid
public X509ChainStatusFlags PartialChain
public X509ChainStatusFlags UntrustedRoot
}
public Mono.Security.X509.X509Crl : object {
private string issuer
private byte version
private DateTime thisUpdate
private DateTime nextUpdate
private ArrayList entries
private string signatureOID
private Byte[] signature
private X509ExtensionCollection extensions
private Byte[] encoded
private Byte[] hash_value
public ArrayList Entries
public X509CrlEntry Item
public X509CrlEntry Item
public X509ExtensionCollection Extensions
public Byte[] Hash
public string IssuerName
public DateTime NextUpdate
public DateTime ThisUpdate
public string SignatureAlgorithm
public Byte[] Signature
public Byte[] RawData
public byte Version
public bool IsCurrent
public void .ctor(Byte[] crl)
private void Parse(Byte[] crl)
public ArrayList get_Entries()
public X509CrlEntry get_Item(int index)
public X509CrlEntry get_Item(Byte[] serialNumber)
public X509ExtensionCollection get_Extensions()
public Byte[] get_Hash()
public string get_IssuerName()
public DateTime get_NextUpdate()
public DateTime get_ThisUpdate()
public string get_SignatureAlgorithm()
public Byte[] get_Signature()
public Byte[] get_RawData()
public byte get_Version()
public bool get_IsCurrent()
public bool WasCurrent(DateTime instant)
public Byte[] GetBytes()
private bool Compare(Byte[] array1, Byte[] array2)
public X509CrlEntry GetCrlEntry(X509Certificate x509)
public X509CrlEntry GetCrlEntry(Byte[] serialNumber)
public bool VerifySignature(X509Certificate x509)
internal bool VerifySignature(DSA dsa)
internal bool VerifySignature(RSA rsa)
public bool VerifySignature(AsymmetricAlgorithm aa)
public X509Crl CreateFromFile(string filename)
}
public Mono.Security.X509.X509Extension : object {
protected string extnOid
protected bool extnCritical
protected ASN1 extnValue
public ASN1 ASN1
public string Oid
public bool Critical
public string Name
public ASN1 Value
public void .ctor(ASN1 asn1)
public void .ctor(X509Extension extension)
protected void Decode()
protected void Encode()
public ASN1 get_ASN1()
public string get_Oid()
public bool get_Critical()
public void set_Critical(bool value)
public string get_Name()
public ASN1 get_Value()
public bool Equals(object obj)
public Byte[] GetBytes()
public int GetHashCode()
private void WriteLine(StringBuilder sb, int n, int pos)
public string ToString()
}
public Mono.Security.X509.X509ExtensionCollection : CollectionBase {
private bool readOnly
public X509Extension Item
public X509Extension Item
public void .ctor(ASN1 asn1)
public int Add(X509Extension extension)
public void AddRange(X509Extension[] extension)
public void AddRange(X509ExtensionCollection collection)
public bool Contains(X509Extension extension)
public bool Contains(string oid)
public void CopyTo(X509Extension[] extensions, int index)
public int IndexOf(X509Extension extension)
public int IndexOf(string oid)
public void Insert(int index, X509Extension extension)
public void Remove(X509Extension extension)
public void Remove(string oid)
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
public X509Extension get_Item(int index)
public X509Extension get_Item(string oid)
public Byte[] GetBytes()
}
public Mono.Security.X509.X509Store : object {
private string _storePath
private X509CertificateCollection _certificates
private ArrayList _crls
private bool _crl
private bool _newFormat
private string _name
public X509CertificateCollection Certificates
public ArrayList Crls
public string Name
internal void .ctor(string path, bool crl, bool newFormat)
public X509CertificateCollection get_Certificates()
public ArrayList get_Crls()
public string get_Name()
public void Clear()
private void ClearCertificates()
private void ClearCrls()
public void Import(X509Certificate certificate)
public void Import(X509Crl crl)
public void Remove(X509Certificate certificate)
public void Remove(X509Crl crl)
private void ImportNewFormat(X509Certificate certificate)
private void RemoveNewFormat(X509Certificate certificate)
private string GetUniqueNameWithSerial(X509Certificate certificate)
private string GetUniqueName(X509Certificate certificate, Byte[] serial)
private string GetUniqueName(X509Crl crl)
private Byte[] GetUniqueName(X509ExtensionCollection extensions, Byte[] serial)
private string GetUniqueName(string method, Byte[] name, string fileExtension)
private Byte[] Load(string filename)
private X509Certificate LoadCertificate(string filename)
private X509Crl LoadCrl(string filename)
private bool CheckStore(string path, bool throwException)
private X509CertificateCollection BuildCertificatesCollection(string storeName)
private ArrayList BuildCrlsCollection(string storeName)
private void ImportPrivateKey(X509Certificate certificate, CspParameters cspParams)
}
public Mono.Security.X509.X509StoreManager : object {
private string _userPath
private string _localMachinePath
private string _newUserPath
private string _newLocalMachinePath
private X509Stores _userStore
private X509Stores _machineStore
private X509Stores _newUserStore
private X509Stores _newMachineStore
internal string CurrentUserPath
internal string LocalMachinePath
internal string NewCurrentUserPath
internal string NewLocalMachinePath
public X509Stores CurrentUser
public X509Stores LocalMachine
public X509Stores NewCurrentUser
public X509Stores NewLocalMachine
public X509CertificateCollection IntermediateCACertificates
public ArrayList IntermediateCACrls
public X509CertificateCollection TrustedRootCertificates
public ArrayList TrustedRootCACrls
public X509CertificateCollection UntrustedCertificates
internal string get_CurrentUserPath()
internal string get_LocalMachinePath()
internal string get_NewCurrentUserPath()
internal string get_NewLocalMachinePath()
public X509Stores get_CurrentUser()
public X509Stores get_LocalMachine()
public X509Stores get_NewCurrentUser()
public X509Stores get_NewLocalMachine()
public X509CertificateCollection get_IntermediateCACertificates()
public ArrayList get_IntermediateCACrls()
public X509CertificateCollection get_TrustedRootCertificates()
public ArrayList get_TrustedRootCACrls()
public X509CertificateCollection get_UntrustedCertificates()
}
public Mono.Security.X509.X509Stores : object {
private string _storePath
private bool _newFormat
private X509Store _personal
private X509Store _other
private X509Store _intermediate
private X509Store _trusted
private X509Store _untrusted
public X509Store Personal
public X509Store OtherPeople
public X509Store IntermediateCA
public X509Store TrustedRoot
public X509Store Untrusted
internal void .ctor(string path, bool newFormat)
public X509Store get_Personal()
public X509Store get_OtherPeople()
public X509Store get_IntermediateCA()
public X509Store get_TrustedRoot()
public X509Store get_Untrusted()
public void Clear()
public X509Store Open(string storeName, bool create)
}
public Mono.Xml.MiniParser : object {
private int INPUT_RANGE
private UInt16[] tbl
protected String[] errors
protected int line
protected int col
protected Int32[] twoCharBuff
protected bool splitCData
public void Reset()
protected bool StrEquals(string str, StringBuilder sb, int sbStart, int len)
protected void FatalErr(string descr)
protected int Xlat(int charCode, int state)
public void Parse(IReader reader, IHandler handler)
}
public Mono.Xml.SecurityParser : MiniParser {
private SecurityElement root
private string xmldoc
private int pos
private SecurityElement current
private Stack stack
public void LoadXml(string xml)
public SecurityElement ToXml()
public int Read()
public void OnStartParsing(MiniParser parser)
public void OnStartElement(string name, IAttrList attrs)
public void OnEndElement(string name)
public void OnChars(string ch)
public void OnEndParsing(MiniParser parser)
}
