public Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle : SafeHandleZeroOrMinusOneIsInvalid {
public void .ctor(IntPtr preexistingHandle, bool ownsHandle)
protected bool ReleaseHandle()
}
public Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle : SafeBuffer {
private IntPtr mmap_handle
internal void .ctor(IntPtr mmap_handle, IntPtr base_address, long size)
internal void Flush()
protected bool ReleaseHandle()
}
public Microsoft.Win32.SafeHandles.SafeNCryptHandle : SafeHandleZeroOrMinusOneIsInvalid {
public bool IsInvalid
protected void .ctor(IntPtr handle, SafeHandle parentHandle)
public bool get_IsInvalid()
protected bool ReleaseHandle()
protected bool ReleaseNativeHandle()
}
public Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle : SafeNCryptHandle {
public void .ctor(IntPtr handle, SafeHandle parentHandle)
protected bool ReleaseNativeHandle()
}
public Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle : SafeNCryptHandle {
protected bool ReleaseNativeHandle()
}
public Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle : SafeNCryptHandle {
protected bool ReleaseNativeHandle()
}
public Microsoft.Win32.SafeHandles.SafePipeHandle : SafeHandleZeroOrMinusOneIsInvalid {
public void .ctor(IntPtr preexistingHandle, bool ownsHandle)
protected bool ReleaseHandle()
}
internal SR : object {
public string ArgumentOutOfRange_NeedNonNegNum
public string Argument_WrongAsyncResult
public string Argument_InvalidOffLen
public string Argument_NeedNonemptyPipeName
public string Argument_EmptyServerName
public string Argument_NonContainerInvalidAnyFlag
public string Argument_InvalidHandle
public string ArgumentNull_Buffer
public string ArgumentNull_ServerName
public string ArgumentOutOfRange_AdditionalAccessLimited
public string ArgumentOutOfRange_AnonymousReserved
public string ArgumentOutOfRange_TransmissionModeByteOrMsg
public string ArgumentOutOfRange_DirectionModeInOrOut
public string ArgumentOutOfRange_DirectionModeInOutOrInOut
public string ArgumentOutOfRange_ImpersonationInvalid
public string ArgumentOutOfRange_ImpersonationOptionsInvalid
public string ArgumentOutOfRange_OptionsInvalid
public string ArgumentOutOfRange_HandleInheritabilityNoneOrInheritable
public string ArgumentOutOfRange_InvalidPipeAccessRights
public string ArgumentOutOfRange_InvalidTimeout
public string ArgumentOutOfRange_MaxNumServerInstances
public string ArgumentOutOfRange_NeedValidPipeAccessRights
public string IndexOutOfRange_IORaceCondition
public string InvalidOperation_EndReadCalledMultiple
public string InvalidOperation_EndWriteCalledMultiple
public string InvalidOperation_EndWaitForConnectionCalledMultiple
public string InvalidOperation_PipeNotYetConnected
public string InvalidOperation_PipeDisconnected
public string InvalidOperation_PipeHandleNotSet
public string InvalidOperation_PipeNotAsync
public string InvalidOperation_PipeReadModeNotMessage
public string InvalidOperation_PipeMessageTypeNotSupported
public string InvalidOperation_PipeAlreadyConnected
public string InvalidOperation_PipeAlreadyDisconnected
public string InvalidOperation_PipeClosed
public string IO_FileTooLongOrHandleNotSync
public string IO_EOF_ReadBeyondEOF
public string IO_FileNotFound
public string IO_FileNotFound_FileName
public string IO_IO_AlreadyExists_Name
public string IO_IO_BindHandleFailed
public string IO_IO_FileExists_Name
public string IO_IO_NoPermissionToDirectoryName
public string IO_IO_SharingViolation_File
public string IO_IO_SharingViolation_NoFileName
public string IO_IO_PipeBroken
public string IO_IO_InvalidPipeHandle
public string IO_OperationAborted
public string IO_DriveNotFound_Drive
public string IO_PathNotFound_Path
public string IO_PathNotFound_NoPathName
public string IO_PathTooLong
public string NotSupported_MemStreamNotExpandable
public string NotSupported_UnreadableStream
public string NotSupported_UnseekableStream
public string NotSupported_UnwritableStream
public string NotSupported_AnonymousPipeUnidirectional
public string NotSupported_AnonymousPipeMessagesNotSupported
public string ObjectDisposed_FileClosed
public string ObjectDisposed_PipeClosed
public string ObjectDisposed_ReaderClosed
public string ObjectDisposed_StreamClosed
public string ObjectDisposed_WriterClosed
public string PlatformNotSupported_NamedPipeServers
public string UnauthorizedAccess_IODenied_Path
public string UnauthorizedAccess_IODenied_NoPathName
public string TraceAsTraceSource
public string ArgumentOutOfRange_NeedValidLogRetention
public string ArgumentOutOfRange_NeedMaxFileSizeGEBufferSize
public string ArgumentOutOfRange_NeedValidMaxNumFiles
public string ArgumentOutOfRange_NeedValidId
public string ArgumentOutOfRange_MaxArgExceeded
public string ArgumentOutOfRange_MaxStringsExceeded
public string NotSupported_DownLevelVista
public string Argument_NeedNonemptyDelimiter
public string NotSupported_SetTextWriter
public string Perflib_PlatformNotSupported
public string Perflib_Argument_CounterSetAlreadyRegister
public string Perflib_Argument_InvalidCounterType
public string Perflib_Argument_InvalidCounterSetInstanceType
public string Perflib_Argument_InstanceAlreadyExists
public string Perflib_Argument_CounterAlreadyExists
public string Perflib_Argument_CounterNameAlreadyExists
public string Perflib_Argument_ProviderNotFound
public string Perflib_Argument_InvalidInstance
public string Perflib_Argument_EmptyInstanceName
public string Perflib_Argument_EmptyCounterName
public string Perflib_InsufficientMemory_InstanceCounterBlock
public string Perflib_InsufficientMemory_CounterSetTemplate
public string Perflib_InvalidOperation_CounterRefValue
public string Perflib_InvalidOperation_CounterSetNotInstalled
public string Perflib_InvalidOperation_InstanceNotFound
public string Perflib_InvalidOperation_AddCounterAfterInstance
public string Perflib_InvalidOperation_NoActiveProvider
public string Perflib_InvalidOperation_CounterSetContainsNoCounter
public string Arg_ArrayPlusOffTooSmall
public string Arg_HSCapacityOverflow
public string InvalidOperation_EnumFailedVersion
public string InvalidOperation_EnumOpCantHappen
public string Serialization_MissingKeys
public string LockRecursionException_RecursiveReadNotAllowed
public string LockRecursionException_RecursiveWriteNotAllowed
public string LockRecursionException_RecursiveUpgradeNotAllowed
public string LockRecursionException_ReadAfterWriteNotAllowed
public string LockRecursionException_WriteAfterReadNotAllowed
public string LockRecursionException_UpgradeAfterReadNotAllowed
public string LockRecursionException_UpgradeAfterWriteNotAllowed
public string SynchronizationLockException_MisMatchedRead
public string SynchronizationLockException_MisMatchedWrite
public string SynchronizationLockException_MisMatchedUpgrade
public string SynchronizationLockException_IncorrectDispose
public string Cryptography_ArgECDHKeySizeMismatch
public string Cryptography_ArgECDHRequiresECDHKey
public string Cryptography_ArgECDsaRequiresECDsaKey
public string Cryptography_ArgExpectedECDiffieHellmanCngPublicKey
public string Cryptography_ArgMustBeCngAlgorithm
public string Cryptography_ArgMustBeCngAlgorithmGroup
public string Cryptography_ArgMustBeCngKeyBlobFormat
public string Cryptography_ArgMustBeCngProvider
public string Cryptography_DecryptWithNoKey
public string Cryptography_ECXmlSerializationFormatRequired
public string Cryptography_InvalidAlgorithmGroup
public string Cryptography_InvalidAlgorithmName
public string Cryptography_InvalidCipherMode
public string Cryptography_InvalidIVSize
public string Cryptography_InvalidKeyBlobFormat
public string Cryptography_InvalidKeySize
public string Cryptography_InvalidPadding
public string Cryptography_InvalidProviderName
public string Cryptography_MissingDomainParameters
public string Cryptography_MissingPublicKey
public string Cryptography_MissingIV
public string Cryptography_MustTransformWholeBlock
public string Cryptography_NonCompliantFIPSAlgorithm
public string Cryptography_OpenInvalidHandle
public string Cryptography_OpenEphemeralKeyHandleWithoutEphemeralFlag
public string Cryptography_PartialBlock
public string Cryptography_PlatformNotSupported
public string Cryptography_TlsRequiresLabelAndSeed
public string Cryptography_TransformBeyondEndOfBuffer
public string Cryptography_UnknownEllipticCurve
public string Cryptography_UnknownEllipticCurveAlgorithm
public string Cryptography_UnknownPaddingMode
public string Cryptography_UnexpectedXmlNamespace
public string ArgumentException_RangeMinRangeMaxRangeType
public string ArgumentException_RangeNotIComparable
public string ArgumentException_RangeMaxRangeSmallerThanMinRange
public string ArgumentException_CountMaxLengthSmallerThanMinLength
public string ArgumentException_LengthMaxLengthSmallerThanMinLength
public string ArgumentException_UnregisteredParameterName
public string ArgumentException_InvalidParameterName
public string ArgumentException_DuplicateName
public string ArgumentException_DuplicatePosition
public string ArgumentException_NoParametersFound
public string ArgumentException_HelpMessageBaseNameNullOrEmpty
public string ArgumentException_HelpMessageResourceIdNullOrEmpty
public string ArgumentException_HelpMessageNullOrEmpty
public string ArgumentException_RegexPatternNullOrEmpty
public string ArgumentException_RequiredPositionalAfterOptionalPositional
public string ArgumentException_DuplicateParameterAttribute
public string ArgumentException_MissingBaseNameOrResourceId
public string ArgumentException_DuplicateRemainingArgumets
public string ArgumentException_TypeMismatchForRemainingArguments
public string ArgumentException_ValidationParameterTypeMismatch
public string ArgumentException_ParserBuiltWithValueType
public string InvalidOperationException_GetParameterTypeMismatch
public string InvalidOperationException_GetParameterValueBeforeParse
public string InvalidOperationException_SetRemainingArgumentsParameterAfterParse
public string InvalidOperationException_AddParameterAfterParse
public string InvalidOperationException_BindAfterBind
public string InvalidOperationException_GetRemainingArgumentsNotAllowed
public string InvalidOperationException_ParameterSetBeforeParse
public string CommandLineParser_Aliases
public string CommandLineParser_ErrorMessagePrefix
public string CommandLineParser_HelpMessagePrefix
public string ParameterBindingException_AmbiguousParameterName
public string ParameterBindingException_ParameterValueAlreadySpecified
public string ParameterBindingException_UnknownParameteName
public string ParameterBindingException_RequiredParameterMissingCommandLineValue
public string ParameterBindingException_UnboundCommandLineArguments
public string ParameterBindingException_UnboundMandatoryParameter
public string ParameterBindingException_ResponseFileException
public string ParameterBindingException_ValididationError
public string ParameterBindingException_TransformationError
public string ParameterBindingException_AmbiguousParameterSet
public string ParameterBindingException_UnknownParameterSet
public string ParameterBindingException_NestedResponseFiles
public string ValidateMetadataException_RangeGreaterThanMaxRangeFailure
public string ValidateMetadataException_RangeSmallerThanMinRangeFailure
public string ValidateMetadataException_PatternFailure
public string ValidateMetadataException_CountMinLengthFailure
public string ValidateMetadataException_CountMaxLengthFailure
public string ValidateMetadataException_LengthMinLengthFailure
public string ValidateMetadataException_LengthMaxLengthFailure
public string Argument_MapNameEmptyString
public string Argument_EmptyFile
public string Argument_NewMMFWriteAccessNotAllowed
public string Argument_ReadAccessWithLargeCapacity
public string Argument_NewMMFAppendModeNotAllowed
public string ArgumentNull_MapName
public string ArgumentNull_FileStream
public string ArgumentOutOfRange_CapacityLargerThanLogicalAddressSpaceNotAllowed
public string ArgumentOutOfRange_NeedPositiveNumber
public string ArgumentOutOfRange_PositiveOrDefaultCapacityRequired
public string ArgumentOutOfRange_PositiveOrDefaultSizeRequired
public string ArgumentOutOfRange_PositionLessThanCapacityRequired
public string ArgumentOutOfRange_CapacityGEFileSizeRequired
public string IO_NotEnoughMemory
public string InvalidOperation_CalledTwice
public string InvalidOperation_CantCreateFileMapping
public string InvalidOperation_ViewIsNull
public string NotSupported_DelayAllocateFileBackedNotAllowed
public string NotSupported_MMViewStreamsFixedLength
public string ObjectDisposed_ViewAccessorClosed
public string ObjectDisposed_StreamIsClosed
public string NotSupported_Method
public string NotSupported_SubclassOverride
public string Cryptography_ArgDSARequiresDSAKey
public string Cryptography_ArgRSAaRequiresRSAKey
public string Cryptography_CngKeyWrongAlgorithm
public string Cryptography_DSA_HashTooShort
public string Cryptography_HashAlgorithmNameNullOrEmpty
public string Cryptography_InvalidDsaParameters_MissingFields
public string Cryptography_InvalidDsaParameters_MismatchedPGY
public string Cryptography_InvalidDsaParameters_MismatchedQX
public string Cryptography_InvalidDsaParameters_MismatchedPJ
public string Cryptography_InvalidDsaParameters_SeedRestriction_ShortKey
public string Cryptography_InvalidDsaParameters_QRestriction_ShortKey
public string Cryptography_InvalidDsaParameters_QRestriction_LargeKey
public string Cryptography_InvalidRsaParameters
public string Cryptography_InvalidSignatureAlgorithm
public string Cryptography_KeyBlobParsingError
public string Cryptography_NotSupportedKeyAlgorithm
public string Cryptography_NotValidPublicOrPrivateKey
public string Cryptography_NotValidPrivateKey
public string Cryptography_UnexpectedTransformTruncation
public string Cryptography_UnsupportedPaddingMode
public string Cryptography_WeakKey
public string Cryptography_CurveNotSupported
public string Cryptography_InvalidCurve
public string Cryptography_InvalidCurveOid
public string Cryptography_InvalidCurveKeyParameters
public string Cryptography_InvalidECCharacteristic2Curve
public string Cryptography_InvalidECPrimeCurve
public string Cryptography_InvalidECNamedCurve
public string Cryptography_UnknownHashAlgorithm
public string ReducibleMustOverrideReduce
public string MustReduceToDifferent
public string ReducedNotCompatible
public string SetterHasNoParams
public string PropertyCannotHaveRefType
public string IndexesOfSetGetMustMatch
public string AccessorsCannotHaveVarArgs
public string AccessorsCannotHaveByRefArgs
public string BoundsCannotBeLessThanOne
public string TypeMustNotBeByRef
public string TypeMustNotBePointer
public string TypeDoesNotHaveConstructorForTheSignature
public string SetterMustBeVoid
public string PropertyTypeMustMatchGetter
public string PropertyTypeMustMatchSetter
public string BothAccessorsMustBeStatic
public string OnlyStaticFieldsHaveNullInstance
public string OnlyStaticPropertiesHaveNullInstance
public string OnlyStaticMethodsHaveNullInstance
public string PropertyTypeCannotBeVoid
public string InvalidUnboxType
public string ExpressionMustBeWriteable
public string ArgumentMustNotHaveValueType
public string MustBeReducible
public string AllTestValuesMustHaveSameType
public string AllCaseBodiesMustHaveSameType
public string DefaultBodyMustBeSupplied
public string LabelMustBeVoidOrHaveExpression
public string LabelTypeMustBeVoid
public string QuotedExpressionMustBeLambda
public string VariableMustNotBeByRef
public string DuplicateVariable
public string StartEndMustBeOrdered
public string FaultCannotHaveCatchOrFinally
public string TryMustHaveCatchFinallyOrFault
public string BodyOfCatchMustHaveSameTypeAsBodyOfTry
public string ExtensionNodeMustOverrideProperty
public string UserDefinedOperatorMustBeStatic
public string UserDefinedOperatorMustNotBeVoid
public string CoercionOperatorNotDefined
public string UnaryOperatorNotDefined
public string BinaryOperatorNotDefined
public string ReferenceEqualityNotDefined
public string OperandTypesDoNotMatchParameters
public string OverloadOperatorTypeDoesNotMatchConversionType
public string ConversionIsNotSupportedForArithmeticTypes
public string ArgumentMustBeArray
public string ArgumentMustBeBoolean
public string EqualityMustReturnBoolean
public string ArgumentMustBeFieldInfoOrPropertyInfo
public string ArgumentMustBeFieldInfoOrPropertyInfoOrMethod
public string ArgumentMustBeInstanceMember
public string ArgumentMustBeInteger
public string ArgumentMustBeArrayIndexType
public string ArgumentMustBeSingleDimensionalArrayType
public string ArgumentTypesMustMatch
public string CannotAutoInitializeValueTypeElementThroughProperty
public string CannotAutoInitializeValueTypeMemberThroughProperty
public string IncorrectTypeForTypeAs
public string CoalesceUsedOnNonNullType
public string ExpressionTypeCannotInitializeArrayType
public string ArgumentTypeDoesNotMatchMember
public string ArgumentMemberNotDeclOnType
public string ExpressionTypeDoesNotMatchReturn
public string ExpressionTypeDoesNotMatchAssignment
public string ExpressionTypeDoesNotMatchLabel
public string ExpressionTypeNotInvocable
public string FieldNotDefinedForType
public string InstanceFieldNotDefinedForType
public string FieldInfoNotDefinedForType
public string IncorrectNumberOfIndexes
public string IncorrectNumberOfLambdaDeclarationParameters
public string IncorrectNumberOfMembersForGivenConstructor
public string IncorrectNumberOfArgumentsForMembers
public string LambdaTypeMustBeDerivedFromSystemDelegate
public string MemberNotFieldOrProperty
public string MethodContainsGenericParameters
public string MethodIsGeneric
public string MethodNotPropertyAccessor
public string PropertyDoesNotHaveGetter
public string PropertyDoesNotHaveSetter
public string PropertyDoesNotHaveAccessor
public string NotAMemberOfType
public string NotAMemberOfAnyType
public string ExpressionNotSupportedForType
public string UnsupportedExpressionType
public string ParameterExpressionNotValidAsDelegate
public string PropertyNotDefinedForType
public string InstancePropertyNotDefinedForType
public string InstancePropertyWithoutParameterNotDefinedForType
public string InstancePropertyWithSpecifiedParametersNotDefinedForType
public string InstanceAndMethodTypeMismatch
public string TypeContainsGenericParameters
public string TypeIsGeneric
public string TypeMissingDefaultConstructor
public string ElementInitializerMethodNotAdd
public string ElementInitializerMethodNoRefOutParam
public string ElementInitializerMethodWithZeroArgs
public string ElementInitializerMethodStatic
public string TypeNotIEnumerable
public string UnexpectedCoalesceOperator
public string InvalidCast
public string UnhandledBinary
public string UnhandledBinding
public string UnhandledBindingType
public string UnhandledConvert
public string UnhandledUnary
public string UnknownBindingType
public string UserDefinedOpMustHaveConsistentTypes
public string UserDefinedOpMustHaveValidReturnType
public string LogicalOperatorMustHaveBooleanOperators
public string MethodWithArgsDoesNotExistOnType
public string GenericMethodWithArgsDoesNotExistOnType
public string MethodWithMoreThanOneMatch
public string PropertyWithMoreThanOneMatch
public string IncorrectNumberOfTypeArgsForFunc
public string IncorrectNumberOfTypeArgsForAction
public string ArgumentCannotBeOfTypeVoid
public string OutOfRange
public string LabelTargetAlreadyDefined
public string LabelTargetUndefined
public string ControlCannotLeaveFinally
public string ControlCannotLeaveFilterTest
public string AmbiguousJump
public string ControlCannotEnterTry
public string ControlCannotEnterExpression
public string NonLocalJumpWithValue
public string ExtensionNotReduced
public string CannotCompileConstant
public string CannotCompileDynamic
public string InvalidLvalue
public string UnknownLiftType
public string UndefinedVariable
public string CannotCloseOverByRef
public string UnexpectedVarArgsCall
public string RethrowRequiresCatch
public string TryNotAllowedInFilter
public string MustRewriteToSameNode
public string MustRewriteChildToSameType
public string MustRewriteWithoutMethod
public string InvalidNullValue
public string InvalidObjectType
public string TryNotSupportedForMethodsWithRefArgs
public string TryNotSupportedForValueTypeInstances
public string EnumerationIsDone
public string TestValueTypeDoesNotMatchComparisonMethodParameter
public string SwitchValueTypeDoesNotMatchComparisonMethodParameter
public string PdbGeneratorNeedsExpressionCompiler
public string InvalidArgumentValue
public string NonEmptyCollectionRequired
public string CollectionModifiedWhileEnumerating
public string ExpressionMustBeReadable
public string ExpressionTypeDoesNotMatchMethodParameter
public string ExpressionTypeDoesNotMatchParameter
public string ExpressionTypeDoesNotMatchConstructorParameter
public string IncorrectNumberOfMethodCallArguments
public string IncorrectNumberOfLambdaArguments
public string IncorrectNumberOfConstructorArguments
public string OperatorNotImplementedForType
public string NonStaticConstructorRequired
public string NonAbstractConstructorRequired
public string FirstArgumentMustBeCallSite
public string NoOrInvalidRuleProduced
public string TypeMustBeDerivedFromSystemDelegate
public string TypeParameterIsNotDelegate
public string ArgumentTypeCannotBeVoid
public string ArgCntMustBeGreaterThanNameCnt
public string BinderNotCompatibleWithCallSite
public string BindingCannotBeNull
public string DynamicBinderResultNotAssignable
public string DynamicBindingNeedsRestrictions
public string DynamicObjectResultNotAssignable
public string InvalidMetaObjectCreated
public string AmbiguousMatchInExpandoObject
public string CollectionReadOnly
public string KeyDoesNotExistInExpando
public string SameKeyExistsInExpando
public string EmptyEnumerable
public string MoreThanOneElement
public string MoreThanOneMatch
public string NoElements
public string NoMatch
public string ParallelPartitionable_NullReturn
public string ParallelPartitionable_IncorretElementCount
public string ParallelPartitionable_NullElement
public string PLINQ_CommonEnumerator_Current_NotStarted
public string PLINQ_ExternalCancellationRequested
public string PLINQ_DisposeRequested
public string ParallelQuery_DuplicateTaskScheduler
public string ParallelQuery_DuplicateDOP
public string ParallelQuery_DuplicateExecutionMode
public string PartitionerQueryOperator_NullPartitionList
public string PartitionerQueryOperator_WrongNumberOfPartitions
public string PartitionerQueryOperator_NullPartition
public string ParallelQuery_DuplicateWithCancellation
public string ParallelQuery_DuplicateMergeOptions
public string PLINQ_EnumerationPreviouslyFailed
public string ParallelQuery_PartitionerNotOrderable
public string ParallelQuery_InvalidAsOrderedCall
public string ParallelQuery_InvalidNonGenericAsOrderedCall
public string ParallelEnumerable_BinaryOpMustUseAsParallel
public string ParallelEnumerable_WithQueryExecutionMode_InvalidMode
public string ParallelEnumerable_WithMergeOptions_InvalidOptions
public string ArgumentNotIEnumerableGeneric
public string ArgumentNotValid
public string NoMethodOnType
public string NoMethodOnTypeMatchingArguments
public string EnumeratingNullEnumerableExpression
public string MethodBuilderDoesNotHaveTypeBuilder
internal string GetString(string name, Object[] args)
internal string GetString(CultureInfo culture, string name, Object[] args)
internal string GetString(string name)
internal string GetString(CultureInfo culture, string name)
internal string Format(string resourceFormat, Object[] args)
internal string Format(string resourceFormat, object p1)
internal string Format(string resourceFormat, object p1, object p2)
internal string Format(string resourceFormat, object p1, object p2, object p3)
}
public System.Action`10 : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10)
public IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.Action`11 : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11)
public IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.Action`12 : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12)
public IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.Action`13 : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13)
public IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.Action`14 : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14)
public IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.Action`15 : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15)
public IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.Action`16 : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15, T16 arg16)
public IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15, T16 arg16, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.Action`9 : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9)
public IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
internal System.Collections.Generic.ArrayBuilder`1 : ValueType {
private int DefaultCapacity
private int MaxCoreClrArrayLength
private T[] _array
private int _count
public int Capacity
public int Count
public T Item
public void .ctor(int capacity)
public int get_Capacity()
public int get_Count()
public T get_Item(int index)
public void set_Item(int index, T value)
public void Add(T item)
public T First()
public T Last()
public T[] ToArray()
public void UncheckedAdd(T item)
private void EnsureCapacity(int minimum)
}
internal System.Collections.Generic.BitHelper : object {
private byte MarkedBitFlag
private byte IntSize
private int _length
private Int32* _arrayPtr
private Int32[] _array
private bool _useStackAlloc
internal void .ctor(Int32* bitArrayPtr, int length)
internal void .ctor(Int32[] bitArray, int length)
internal void MarkBit(int bitPosition)
internal bool IsMarked(int bitPosition)
internal int ToIntArrayLength(int n)
}
internal System.Collections.Generic.CopyPosition : ValueType {
private int <Row>k__BackingField
private int <Column>k__BackingField
public CopyPosition Start
internal int Row
internal int Column
private string DebuggerDisplay
internal void .ctor(int row, int column)
public CopyPosition get_Start()
internal int get_Row()
internal int get_Column()
public CopyPosition Normalize(int endColumn)
private string get_DebuggerDisplay()
}
internal System.Collections.Generic.EnumerableHelpers : object {
internal bool TryGetCount(IEnumerable`1<T> source, Int32& count)
internal void Copy(IEnumerable`1<T> source, T[] array, int arrayIndex, int count)
internal void IterativeCopy(IEnumerable`1<T> source, T[] array, int arrayIndex, int count)
internal T[] ToArray(IEnumerable`1<T> source)
internal T[] ToArray(IEnumerable`1<T> source, Int32& length)
}
public System.Collections.Generic.HashSet`1 : object {
private int Lower31BitMask
private int StackAllocThreshold
private int ShrinkThreshold
private string CapacityName
private string ElementsName
private string ComparerName
private string VersionName
private Int32[] _buckets
private Slot[] _slots
private int _count
private int _lastIndex
private int _freeList
private IEqualityComparer`1<T> _comparer
private int _version
private SerializationInfo _siInfo
public int Count
private bool System.Collections.Generic.ICollection<T>.IsReadOnly
public IEqualityComparer`1<T> Comparer
public void .ctor(IEqualityComparer`1<T> comparer)
public void .ctor(int capacity)
public void .ctor(IEnumerable`1<T> collection)
public void .ctor(IEnumerable`1<T> collection, IEqualityComparer`1<T> comparer)
protected void .ctor(SerializationInfo info, StreamingContext context)
private void CopyFrom(HashSet`1<T> source)
public void .ctor(int capacity, IEqualityComparer`1<T> comparer)
private void System.Collections.Generic.ICollection<T>.Add(T item)
public void Clear()
public bool Contains(T item)
public void CopyTo(T[] array, int arrayIndex)
public bool Remove(T item)
public int get_Count()
private bool System.Collections.Generic.ICollection<T>.get_IsReadOnly()
public Enumerator<T> GetEnumerator()
private IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
public void GetObjectData(SerializationInfo info, StreamingContext context)
public void OnDeserialization(object sender)
public bool Add(T item)
public bool TryGetValue(T equalValue, T& actualValue)
public void UnionWith(IEnumerable`1<T> other)
public void IntersectWith(IEnumerable`1<T> other)
public void ExceptWith(IEnumerable`1<T> other)
public void SymmetricExceptWith(IEnumerable`1<T> other)
public bool IsSubsetOf(IEnumerable`1<T> other)
public bool IsProperSubsetOf(IEnumerable`1<T> other)
public bool IsSupersetOf(IEnumerable`1<T> other)
public bool IsProperSupersetOf(IEnumerable`1<T> other)
public bool Overlaps(IEnumerable`1<T> other)
public bool SetEquals(IEnumerable`1<T> other)
public void CopyTo(T[] array)
public void CopyTo(T[] array, int arrayIndex, int count)
public int RemoveWhere(Predicate`1<T> match)
public IEqualityComparer`1<T> get_Comparer()
public void TrimExcess()
public IEqualityComparer`1<HashSet`1<T>> CreateSetComparer()
private void Initialize(int capacity)
private void IncreaseCapacity()
private void SetCapacity(int newSize)
private bool AddIfNotPresent(T value)
private void AddValue(int index, int hashCode, T value)
private bool ContainsAllElements(IEnumerable`1<T> other)
private bool IsSubsetOfHashSetWithSameEC(HashSet`1<T> other)
private void IntersectWithHashSetWithSameEC(HashSet`1<T> other)
private void IntersectWithEnumerable(IEnumerable`1<T> other)
private int InternalIndexOf(T item)
private void SymmetricExceptWithUniqueHashSet(HashSet`1<T> other)
private void SymmetricExceptWithEnumerable(IEnumerable`1<T> other)
private bool AddOrGetLocation(T value, Int32& location)
private ElementCount<T> CheckUniqueAndUnfoundElements(IEnumerable`1<T> other, bool returnIfUnfound)
internal bool HashSetEquals(HashSet`1<T> set1, HashSet`1<T> set2, IEqualityComparer`1<T> comparer)
private bool AreEqualityComparersEqual(HashSet`1<T> set1, HashSet`1<T> set2)
private int InternalGetHashCode(T item)
}
internal System.Collections.Generic.HashSetEqualityComparer`1 : object {
private IEqualityComparer`1<T> _comparer
public bool Equals(HashSet`1<T> x, HashSet`1<T> y)
public int GetHashCode(HashSet`1<T> obj)
public bool Equals(object obj)
public int GetHashCode()
}
internal System.Collections.Generic.ICollectionDebugView`1 : object {
private ICollection`1<T> _collection
public T[] Items
public void .ctor(ICollection`1<T> collection)
public T[] get_Items()
}
internal System.Collections.Generic.LargeArrayBuilder`1 : ValueType {
private int StartingCapacity
private int ResizeLimit
private int _maxCapacity
private T[] _first
private ArrayBuilder`1<T[]> _buffers
private T[] _current
private int _index
private int _count
public int Count
public void .ctor(bool initialize)
public void .ctor(int maxCapacity)
public int get_Count()
public void Add(T item)
public void AddRange(IEnumerable`1<T> items)
public void CopyTo(T[] array, int arrayIndex, int count)
public CopyPosition CopyTo(CopyPosition position, T[] array, int arrayIndex, int count)
public T[] GetBuffer(int index)
public void SlowAdd(T item)
public T[] ToArray()
public bool TryMove(T[]& array)
private void AllocateBuffer()
internal int <CopyTo>g__CopyToCore|15_0(T[] sourceBuffer, int sourceIndex, <>c__DisplayClass15_0& )
}
internal System.Collections.Generic.Marker : ValueType {
private int <Count>k__BackingField
private int <Index>k__BackingField
public int Count
public int Index
private string DebuggerDisplay
public void .ctor(int count, int index)
public int get_Count()
public int get_Index()
private string get_DebuggerDisplay()
}
internal System.Collections.Generic.ReferenceEqualityComparer`1 : object {
internal ReferenceEqualityComparer`1<T> Instance
public bool Equals(T x, T y)
public int GetHashCode(T obj)
}
internal System.Collections.Generic.SparseArrayBuilder`1 : ValueType {
private LargeArrayBuilder`1<T> _builder
private ArrayBuilder`1<Marker> _markers
private int _reservedCount
public int Count
public ArrayBuilder`1<Marker> Markers
public void .ctor(bool initialize)
public int get_Count()
public ArrayBuilder`1<Marker> get_Markers()
public void Add(T item)
public void AddRange(IEnumerable`1<T> items)
public void CopyTo(T[] array, int arrayIndex, int count)
public void Reserve(int count)
public bool ReserveOrAdd(IEnumerable`1<T> items)
public T[] ToArray()
}
public System.Diagnostics.Eventing.EventDescriptor : ValueType {
public byte Channel
public int EventId
public long Keywords
public byte Level
public byte Opcode
public int Task
public byte Version
public void .ctor(int id, byte version, byte channel, byte level, byte opcode, int task, long keywords)
public byte get_Channel()
public int get_EventId()
public long get_Keywords()
public byte get_Level()
public byte get_Opcode()
public int get_Task()
public byte get_Version()
}
public System.Diagnostics.Eventing.EventProvider : object {
public void .ctor(Guid providerGuid)
public void Close()
public Guid CreateActivityId()
public void Dispose()
public WriteEventErrorCode GetLastWriteEventError()
public bool IsEnabled()
public bool IsEnabled(byte level, long keywords)
public void SetActivityId(Guid& id)
public bool WriteEvent(EventDescriptor& eventDescriptor, Object[] eventPayload)
public bool WriteEvent(EventDescriptor& eventDescriptor, string data)
public bool WriteMessageEvent(string eventMessage)
public bool WriteMessageEvent(string eventMessage, byte eventLevel, long eventKeywords)
public bool WriteTransferEvent(EventDescriptor& eventDescriptor, Guid relatedActivityId, Object[] eventPayload)
}
public System.Diagnostics.Eventing.EventProviderTraceListener : TraceListener {
public string Delimiter
public void .ctor(string providerId)
public void .ctor(string providerId, string name)
public void .ctor(string providerId, string name, string delimiter)
public string get_Delimiter()
public void set_Delimiter(string value)
public void Write(string message)
public void WriteLine(string message)
}
public System.Diagnostics.Eventing.Reader.EventBookmark : object {
private void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context)
}
public System.Diagnostics.Eventing.Reader.EventKeyword : object {
public string DisplayName
public string Name
public long Value
public string get_DisplayName()
public string get_Name()
public long get_Value()
}
public System.Diagnostics.Eventing.Reader.EventLevel : object {
public string DisplayName
public string Name
public int Value
public string get_DisplayName()
public string get_Name()
public int get_Value()
}
public System.Diagnostics.Eventing.Reader.EventLogConfiguration : object {
public bool IsClassicLog
public bool IsEnabled
public string LogFilePath
public EventLogIsolation LogIsolation
public EventLogMode LogMode
public string LogName
public EventLogType LogType
public long MaximumSizeInBytes
public string OwningProviderName
public Nullable`1<int> ProviderBufferSize
public Nullable`1<Guid> ProviderControlGuid
public Nullable`1<long> ProviderKeywords
public Nullable`1<int> ProviderLatency
public Nullable`1<int> ProviderLevel
public Nullable`1<int> ProviderMaximumNumberOfBuffers
public Nullable`1<int> ProviderMinimumNumberOfBuffers
public IEnumerable`1<string> ProviderNames
public string SecurityDescriptor
public void .ctor(string logName)
public void .ctor(string logName, EventLogSession session)
public bool get_IsClassicLog()
public bool get_IsEnabled()
public void set_IsEnabled(bool value)
public string get_LogFilePath()
public void set_LogFilePath(string value)
public EventLogIsolation get_LogIsolation()
public EventLogMode get_LogMode()
public void set_LogMode(EventLogMode value)
public string get_LogName()
public EventLogType get_LogType()
public long get_MaximumSizeInBytes()
public void set_MaximumSizeInBytes(long value)
public string get_OwningProviderName()
public Nullable`1<int> get_ProviderBufferSize()
public Nullable`1<Guid> get_ProviderControlGuid()
public Nullable`1<long> get_ProviderKeywords()
public void set_ProviderKeywords(Nullable`1<long> value)
public Nullable`1<int> get_ProviderLatency()
public Nullable`1<int> get_ProviderLevel()
public void set_ProviderLevel(Nullable`1<int> value)
public Nullable`1<int> get_ProviderMaximumNumberOfBuffers()
public Nullable`1<int> get_ProviderMinimumNumberOfBuffers()
public IEnumerable`1<string> get_ProviderNames()
public string get_SecurityDescriptor()
public void set_SecurityDescriptor(string value)
public void Dispose()
public void SaveChanges()
}
public System.Diagnostics.Eventing.Reader.EventLogException : Exception {
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
}
public System.Diagnostics.Eventing.Reader.EventLogInformation : object {
public Nullable`1<int> Attributes
public Nullable`1<DateTime> CreationTime
public Nullable`1<long> FileSize
public Nullable`1<bool> IsLogFull
public Nullable`1<DateTime> LastAccessTime
public Nullable`1<DateTime> LastWriteTime
public Nullable`1<long> OldestRecordNumber
public Nullable`1<long> RecordCount
public Nullable`1<int> get_Attributes()
public Nullable`1<DateTime> get_CreationTime()
public Nullable`1<long> get_FileSize()
public Nullable`1<bool> get_IsLogFull()
public Nullable`1<DateTime> get_LastAccessTime()
public Nullable`1<DateTime> get_LastWriteTime()
public Nullable`1<long> get_OldestRecordNumber()
public Nullable`1<long> get_RecordCount()
}
public System.Diagnostics.Eventing.Reader.EventLogInvalidDataException : EventLogException {
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
}
public System.Diagnostics.Eventing.Reader.EventLogIsolation : Enum {
public int value__
public EventLogIsolation Application
public EventLogIsolation Custom
public EventLogIsolation System
}
public System.Diagnostics.Eventing.Reader.EventLogLink : object {
public string DisplayName
public bool IsImported
public string LogName
public string get_DisplayName()
public bool get_IsImported()
public string get_LogName()
}
public System.Diagnostics.Eventing.Reader.EventLogMode : Enum {
public int value__
public EventLogMode AutoBackup
public EventLogMode Circular
public EventLogMode Retain
}
public System.Diagnostics.Eventing.Reader.EventLogNotFoundException : EventLogException {
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
}
public System.Diagnostics.Eventing.Reader.EventLogPropertySelector : object {
public void .ctor(IEnumerable`1<string> propertyQueries)
public void Dispose()
}
public System.Diagnostics.Eventing.Reader.EventLogProviderDisabledException : EventLogException {
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
}
public System.Diagnostics.Eventing.Reader.EventLogQuery : object {
public bool ReverseDirection
public EventLogSession Session
public bool TolerateQueryErrors
public void .ctor(string path, PathType pathType)
public void .ctor(string path, PathType pathType, string query)
public bool get_ReverseDirection()
public void set_ReverseDirection(bool value)
public EventLogSession get_Session()
public void set_Session(EventLogSession value)
public bool get_TolerateQueryErrors()
public void set_TolerateQueryErrors(bool value)
}
public System.Diagnostics.Eventing.Reader.EventLogReader : object {
public int BatchSize
public IList`1<EventLogStatus> LogStatus
public void .ctor(EventLogQuery eventQuery)
public void .ctor(EventLogQuery eventQuery, EventBookmark bookmark)
public void .ctor(string path)
public void .ctor(string path, PathType pathType)
public int get_BatchSize()
public void set_BatchSize(int value)
public IList`1<EventLogStatus> get_LogStatus()
public void CancelReading()
public void Dispose()
public EventRecord ReadEvent()
public EventRecord ReadEvent(TimeSpan timeout)
public void Seek(EventBookmark bookmark)
public void Seek(EventBookmark bookmark, long offset)
public void Seek(SeekOrigin origin, long offset)
}
public System.Diagnostics.Eventing.Reader.EventLogReadingException : EventLogException {
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
}
public System.Diagnostics.Eventing.Reader.EventLogRecord : EventRecord {
public Nullable`1<Guid> ActivityId
public EventBookmark Bookmark
public string ContainerLog
public int Id
public Nullable`1<long> Keywords
public IEnumerable`1<string> KeywordsDisplayNames
public Nullable`1<byte> Level
public string LevelDisplayName
public string LogName
public string MachineName
public IEnumerable`1<int> MatchedQueryIds
public Nullable`1<short> Opcode
public string OpcodeDisplayName
public Nullable`1<int> ProcessId
public IList`1<EventProperty> Properties
public Nullable`1<Guid> ProviderId
public string ProviderName
public Nullable`1<int> Qualifiers
public Nullable`1<long> RecordId
public Nullable`1<Guid> RelatedActivityId
public Nullable`1<int> Task
public string TaskDisplayName
public Nullable`1<int> ThreadId
public Nullable`1<DateTime> TimeCreated
public SecurityIdentifier UserId
public Nullable`1<byte> Version
public Nullable`1<Guid> get_ActivityId()
public EventBookmark get_Bookmark()
public string get_ContainerLog()
public int get_Id()
public Nullable`1<long> get_Keywords()
public IEnumerable`1<string> get_KeywordsDisplayNames()
public Nullable`1<byte> get_Level()
public string get_LevelDisplayName()
public string get_LogName()
public string get_MachineName()
public IEnumerable`1<int> get_MatchedQueryIds()
public Nullable`1<short> get_Opcode()
public string get_OpcodeDisplayName()
public Nullable`1<int> get_ProcessId()
public IList`1<EventProperty> get_Properties()
public Nullable`1<Guid> get_ProviderId()
public string get_ProviderName()
public Nullable`1<int> get_Qualifiers()
public Nullable`1<long> get_RecordId()
public Nullable`1<Guid> get_RelatedActivityId()
public Nullable`1<int> get_Task()
public string get_TaskDisplayName()
public Nullable`1<int> get_ThreadId()
public Nullable`1<DateTime> get_TimeCreated()
public SecurityIdentifier get_UserId()
public Nullable`1<byte> get_Version()
protected void Dispose(bool disposing)
public string FormatDescription()
public string FormatDescription(IEnumerable`1<object> values)
public IList`1<object> GetPropertyValues(EventLogPropertySelector propertySelector)
public string ToXml()
}
public System.Diagnostics.Eventing.Reader.EventLogSession : object {
public EventLogSession GlobalSession
public void .ctor(string server)
public void .ctor(string server, string domain, string user, SecureString password, SessionAuthentication logOnType)
public EventLogSession get_GlobalSession()
public void CancelCurrentOperations()
public void ClearLog(string logName)
public void ClearLog(string logName, string backupPath)
public void Dispose()
public void ExportLog(string path, PathType pathType, string query, string targetFilePath)
public void ExportLog(string path, PathType pathType, string query, string targetFilePath, bool tolerateQueryErrors)
public void ExportLogAndMessages(string path, PathType pathType, string query, string targetFilePath)
public void ExportLogAndMessages(string path, PathType pathType, string query, string targetFilePath, bool tolerateQueryErrors, CultureInfo targetCultureInfo)
public EventLogInformation GetLogInformation(string logName, PathType pathType)
public IEnumerable`1<string> GetLogNames()
public IEnumerable`1<string> GetProviderNames()
}
public System.Diagnostics.Eventing.Reader.EventLogStatus : object {
public string LogName
public int StatusCode
public string get_LogName()
public int get_StatusCode()
}
public System.Diagnostics.Eventing.Reader.EventLogType : Enum {
public int value__
public EventLogType Administrative
public EventLogType Analytical
public EventLogType Debug
public EventLogType Operational
}
public System.Diagnostics.Eventing.Reader.EventLogWatcher : object {
public bool Enabled
public void .ctor(EventLogQuery eventQuery)
public void .ctor(EventLogQuery eventQuery, EventBookmark bookmark)
public void .ctor(EventLogQuery eventQuery, EventBookmark bookmark, bool readExistingEvents)
public void .ctor(string path)
public bool get_Enabled()
public void set_Enabled(bool value)
public void add_EventRecordWritten(EventHandler`1<EventRecordWrittenEventArgs> value)
public void remove_EventRecordWritten(EventHandler`1<EventRecordWrittenEventArgs> value)
public void Dispose()
}
public System.Diagnostics.Eventing.Reader.EventMetadata : object {
public string Description
public long Id
public IEnumerable`1<EventKeyword> Keywords
public EventLevel Level
public EventLogLink LogLink
public EventOpcode Opcode
public EventTask Task
public string Template
public byte Version
public string get_Description()
public long get_Id()
public IEnumerable`1<EventKeyword> get_Keywords()
public EventLevel get_Level()
public EventLogLink get_LogLink()
public EventOpcode get_Opcode()
public EventTask get_Task()
public string get_Template()
public byte get_Version()
}
public System.Diagnostics.Eventing.Reader.EventOpcode : object {
public string DisplayName
public string Name
public int Value
public string get_DisplayName()
public string get_Name()
public int get_Value()
}
public System.Diagnostics.Eventing.Reader.EventProperty : object {
public object Value
public object get_Value()
}
public System.Diagnostics.Eventing.Reader.EventRecord : object {
public Nullable`1<Guid> ActivityId
public EventBookmark Bookmark
public int Id
public Nullable`1<long> Keywords
public IEnumerable`1<string> KeywordsDisplayNames
public Nullable`1<byte> Level
public string LevelDisplayName
public string LogName
public string MachineName
public Nullable`1<short> Opcode
public string OpcodeDisplayName
public Nullable`1<int> ProcessId
public IList`1<EventProperty> Properties
public Nullable`1<Guid> ProviderId
public string ProviderName
public Nullable`1<int> Qualifiers
public Nullable`1<long> RecordId
public Nullable`1<Guid> RelatedActivityId
public Nullable`1<int> Task
public string TaskDisplayName
public Nullable`1<int> ThreadId
public Nullable`1<DateTime> TimeCreated
public SecurityIdentifier UserId
public Nullable`1<byte> Version
public Nullable`1<Guid> get_ActivityId()
public EventBookmark get_Bookmark()
public int get_Id()
public Nullable`1<long> get_Keywords()
public IEnumerable`1<string> get_KeywordsDisplayNames()
public Nullable`1<byte> get_Level()
public string get_LevelDisplayName()
public string get_LogName()
public string get_MachineName()
public Nullable`1<short> get_Opcode()
public string get_OpcodeDisplayName()
public Nullable`1<int> get_ProcessId()
public IList`1<EventProperty> get_Properties()
public Nullable`1<Guid> get_ProviderId()
public string get_ProviderName()
public Nullable`1<int> get_Qualifiers()
public Nullable`1<long> get_RecordId()
public Nullable`1<Guid> get_RelatedActivityId()
public Nullable`1<int> get_Task()
public string get_TaskDisplayName()
public Nullable`1<int> get_ThreadId()
public Nullable`1<DateTime> get_TimeCreated()
public SecurityIdentifier get_UserId()
public Nullable`1<byte> get_Version()
public void Dispose()
public string FormatDescription()
public string FormatDescription(IEnumerable`1<object> values)
public string ToXml()
}
public System.Diagnostics.Eventing.Reader.EventRecordWrittenEventArgs : EventArgs {
public Exception EventException
public EventRecord EventRecord
public Exception get_EventException()
public EventRecord get_EventRecord()
}
public System.Diagnostics.Eventing.Reader.EventTask : object {
public string DisplayName
public Guid EventGuid
public string Name
public int Value
public string get_DisplayName()
public Guid get_EventGuid()
public string get_Name()
public int get_Value()
}
public System.Diagnostics.Eventing.Reader.PathType : Enum {
public int value__
public PathType FilePath
public PathType LogName
}
public System.Diagnostics.Eventing.Reader.ProviderMetadata : object {
public string DisplayName
public IEnumerable`1<EventMetadata> Events
public Uri HelpLink
public Guid Id
public IList`1<EventKeyword> Keywords
public IList`1<EventLevel> Levels
public IList`1<EventLogLink> LogLinks
public string MessageFilePath
public string Name
public IList`1<EventOpcode> Opcodes
public string ParameterFilePath
public string ResourceFilePath
public IList`1<EventTask> Tasks
public void .ctor(string providerName)
public void .ctor(string providerName, EventLogSession session, CultureInfo targetCultureInfo)
public string get_DisplayName()
public IEnumerable`1<EventMetadata> get_Events()
public Uri get_HelpLink()
public Guid get_Id()
public IList`1<EventKeyword> get_Keywords()
public IList`1<EventLevel> get_Levels()
public IList`1<EventLogLink> get_LogLinks()
public string get_MessageFilePath()
public string get_Name()
public IList`1<EventOpcode> get_Opcodes()
public string get_ParameterFilePath()
public string get_ResourceFilePath()
public IList`1<EventTask> get_Tasks()
public void Dispose()
}
public System.Diagnostics.Eventing.Reader.SessionAuthentication : Enum {
public int value__
public SessionAuthentication Default
public SessionAuthentication Kerberos
public SessionAuthentication Negotiate
public SessionAuthentication Ntlm
}
public System.Diagnostics.Eventing.Reader.StandardEventKeywords : Enum {
public long value__
public StandardEventKeywords AuditFailure
public StandardEventKeywords AuditSuccess
public StandardEventKeywords CorrelationHint
public StandardEventKeywords CorrelationHint2
public StandardEventKeywords EventLogClassic
public StandardEventKeywords None
public StandardEventKeywords ResponseTime
public StandardEventKeywords Sqm
public StandardEventKeywords WdiContext
public StandardEventKeywords WdiDiagnostic
}
public System.Diagnostics.Eventing.Reader.StandardEventLevel : Enum {
public int value__
public StandardEventLevel Critical
public StandardEventLevel Error
public StandardEventLevel Informational
public StandardEventLevel LogAlways
public StandardEventLevel Verbose
public StandardEventLevel Warning
}
public System.Diagnostics.Eventing.Reader.StandardEventOpcode : Enum {
public int value__
public StandardEventOpcode DataCollectionStart
public StandardEventOpcode DataCollectionStop
public StandardEventOpcode Extension
public StandardEventOpcode Info
public StandardEventOpcode Receive
public StandardEventOpcode Reply
public StandardEventOpcode Resume
public StandardEventOpcode Send
public StandardEventOpcode Start
public StandardEventOpcode Stop
public StandardEventOpcode Suspend
}
public System.Diagnostics.Eventing.Reader.StandardEventTask : Enum {
public int value__
public StandardEventTask None
}
public System.Diagnostics.EventSchemaTraceListener : TextWriterTraceListener {
public int BufferSize
public long MaximumFileSize
public int MaximumNumberOfFiles
public TraceLogRetentionOption TraceLogRetentionOption
public void .ctor(string fileName)
public void .ctor(string fileName, string name)
public void .ctor(string fileName, string name, int bufferSize)
public void .ctor(string fileName, string name, int bufferSize, TraceLogRetentionOption logRetentionOption)
public void .ctor(string fileName, string name, int bufferSize, TraceLogRetentionOption logRetentionOption, long maximumFileSize)
public void .ctor(string fileName, string name, int bufferSize, TraceLogRetentionOption logRetentionOption, long maximumFileSize, int maximumNumberOfFiles)
public int get_BufferSize()
public long get_MaximumFileSize()
public int get_MaximumNumberOfFiles()
public TraceLogRetentionOption get_TraceLogRetentionOption()
}
public System.Diagnostics.PerformanceData.CounterData : object {
public long RawValue
public long Value
public long get_RawValue()
public void set_RawValue(long value)
public long get_Value()
public void set_Value(long value)
public void Decrement()
public void Increment()
public void IncrementBy(long value)
}
public System.Diagnostics.PerformanceData.CounterSet : object {
public void .ctor(Guid providerGuid, Guid counterSetGuid, CounterSetInstanceType instanceType)
public void AddCounter(int counterId, CounterType counterType)
public void AddCounter(int counterId, CounterType counterType, string counterName)
public CounterSetInstance CreateCounterSetInstance(string instanceName)
public void Dispose()
}
public System.Diagnostics.PerformanceData.CounterSetInstance : object {
public CounterSetInstanceCounterDataSet Counters
public CounterSetInstanceCounterDataSet get_Counters()
public void Dispose()
}
public System.Diagnostics.PerformanceData.CounterSetInstanceCounterDataSet : object {
public CounterData Item
public CounterData get_Item(int counterId)
public CounterData get_Item(string counterName)
public void Dispose()
}
public System.Diagnostics.PerformanceData.CounterSetInstanceType : Enum {
public int value__
public CounterSetInstanceType GlobalAggregate
public CounterSetInstanceType GlobalAggregateWithHistory
public CounterSetInstanceType InstanceAggregate
public CounterSetInstanceType Multiple
public CounterSetInstanceType MultipleAggregate
public CounterSetInstanceType Single
}
public System.Diagnostics.PerformanceData.CounterType : Enum {
public int value__
public CounterType AverageBase
public CounterType AverageCount64
public CounterType AverageTimer32
public CounterType Delta32
public CounterType Delta64
public CounterType ElapsedTime
public CounterType LargeQueueLength
public CounterType MultiTimerBase
public CounterType MultiTimerPercentageActive
public CounterType MultiTimerPercentageActive100Ns
public CounterType MultiTimerPercentageNotActive
public CounterType MultiTimerPercentageNotActive100Ns
public CounterType ObjectSpecificTimer
public CounterType PercentageActive
public CounterType PercentageActive100Ns
public CounterType PercentageNotActive
public CounterType PercentageNotActive100Ns
public CounterType PrecisionObjectSpecificTimer
public CounterType PrecisionSystemTimer
public CounterType PrecisionTimer100Ns
public CounterType QueueLength
public CounterType QueueLength100Ns
public CounterType QueueLengthObjectTime
public CounterType RateOfCountPerSecond32
public CounterType RateOfCountPerSecond64
public CounterType RawBase32
public CounterType RawBase64
public CounterType RawData32
public CounterType RawData64
public CounterType RawDataHex32
public CounterType RawDataHex64
public CounterType RawFraction32
public CounterType RawFraction64
public CounterType SampleBase
public CounterType SampleCounter
public CounterType SampleFraction
}
public System.Diagnostics.TraceLogRetentionOption : Enum {
public int value__
public TraceLogRetentionOption LimitedCircularFiles
public TraceLogRetentionOption LimitedSequentialFiles
public TraceLogRetentionOption SingleFileBoundedSize
public TraceLogRetentionOption SingleFileUnboundedSize
public TraceLogRetentionOption UnlimitedSequentialFiles
}
public System.Diagnostics.UnescapedXmlDiagnosticData : object {
public string UnescapedXml
public void .ctor(string xmlPayload)
public string get_UnescapedXml()
public void set_UnescapedXml(string value)
}
public System.Dynamic.BinaryOperationBinder : DynamicMetaObjectBinder {
private ExpressionType <Operation>k__BackingField
public Type ReturnType
public ExpressionType Operation
internal bool IsStandardBinder
protected void .ctor(ExpressionType operation)
public Type get_ReturnType()
public ExpressionType get_Operation()
public DynamicMetaObject FallbackBinaryOperation(DynamicMetaObject target, DynamicMetaObject arg)
public DynamicMetaObject FallbackBinaryOperation(DynamicMetaObject target, DynamicMetaObject arg, DynamicMetaObject errorSuggestion)
public DynamicMetaObject Bind(DynamicMetaObject target, DynamicMetaObject[] args)
internal bool get_IsStandardBinder()
internal bool OperationIsValid(ExpressionType operation)
}
public System.Dynamic.BindingRestrictions : object {
public BindingRestrictions Empty
private int TypeRestrictionHash
private int InstanceRestrictionHash
private int CustomRestrictionHash
private string DebugView
internal Expression GetExpression()
public BindingRestrictions Merge(BindingRestrictions restrictions)
public BindingRestrictions GetTypeRestriction(Expression expression, Type type)
internal BindingRestrictions GetTypeRestriction(DynamicMetaObject obj)
public BindingRestrictions GetInstanceRestriction(Expression expression, object instance)
public BindingRestrictions GetExpressionRestriction(Expression expression)
public BindingRestrictions Combine(IList`1<DynamicMetaObject> contributingObjects)
public Expression ToExpression()
private string get_DebugView()
}
public System.Dynamic.CallInfo : object {
private int <ArgumentCount>k__BackingField
private ReadOnlyCollection`1<string> <ArgumentNames>k__BackingField
public int ArgumentCount
public ReadOnlyCollection`1<string> ArgumentNames
public void .ctor(int argCount, String[] argNames)
public void .ctor(int argCount, IEnumerable`1<string> argNames)
public int get_ArgumentCount()
public ReadOnlyCollection`1<string> get_ArgumentNames()
public int GetHashCode()
public bool Equals(object obj)
}
public System.Dynamic.ConvertBinder : DynamicMetaObjectBinder {
private Type <Type>k__BackingField
private bool <Explicit>k__BackingField
public Type Type
public bool Explicit
internal bool IsStandardBinder
public Type ReturnType
protected void .ctor(Type type, bool explicit)
public Type get_Type()
public bool get_Explicit()
public DynamicMetaObject FallbackConvert(DynamicMetaObject target)
public DynamicMetaObject FallbackConvert(DynamicMetaObject target, DynamicMetaObject errorSuggestion)
public DynamicMetaObject Bind(DynamicMetaObject target, DynamicMetaObject[] args)
internal bool get_IsStandardBinder()
public Type get_ReturnType()
}
public System.Dynamic.CreateInstanceBinder : DynamicMetaObjectBinder {
private CallInfo <CallInfo>k__BackingField
public Type ReturnType
public CallInfo CallInfo
internal bool IsStandardBinder
protected void .ctor(CallInfo callInfo)
public Type get_ReturnType()
public CallInfo get_CallInfo()
public DynamicMetaObject FallbackCreateInstance(DynamicMetaObject target, DynamicMetaObject[] args)
public DynamicMetaObject FallbackCreateInstance(DynamicMetaObject target, DynamicMetaObject[] args, DynamicMetaObject errorSuggestion)
public DynamicMetaObject Bind(DynamicMetaObject target, DynamicMetaObject[] args)
internal bool get_IsStandardBinder()
}
public System.Dynamic.DeleteIndexBinder : DynamicMetaObjectBinder {
private CallInfo <CallInfo>k__BackingField
public Type ReturnType
public CallInfo CallInfo
internal bool IsStandardBinder
protected void .ctor(CallInfo callInfo)
public Type get_ReturnType()
public CallInfo get_CallInfo()
public DynamicMetaObject Bind(DynamicMetaObject target, DynamicMetaObject[] args)
internal bool get_IsStandardBinder()
public DynamicMetaObject FallbackDeleteIndex(DynamicMetaObject target, DynamicMetaObject[] indexes)
public DynamicMetaObject FallbackDeleteIndex(DynamicMetaObject target, DynamicMetaObject[] indexes, DynamicMetaObject errorSuggestion)
}
public System.Dynamic.DeleteMemberBinder : DynamicMetaObjectBinder {
private string <Name>k__BackingField
private bool <IgnoreCase>k__BackingField
public string Name
public bool IgnoreCase
public Type ReturnType
internal bool IsStandardBinder
protected void .ctor(string name, bool ignoreCase)
public string get_Name()
public bool get_IgnoreCase()
public Type get_ReturnType()
public DynamicMetaObject FallbackDeleteMember(DynamicMetaObject target)
public DynamicMetaObject FallbackDeleteMember(DynamicMetaObject target, DynamicMetaObject errorSuggestion)
public DynamicMetaObject Bind(DynamicMetaObject target, DynamicMetaObject[] args)
internal bool get_IsStandardBinder()
}
public System.Dynamic.DynamicMetaObject : object {
public DynamicMetaObject[] EmptyMetaObjects
private Expression <Expression>k__BackingField
private BindingRestrictions <Restrictions>k__BackingField
private object <Value>k__BackingField
private bool <HasValue>k__BackingField
public Expression Expression
public BindingRestrictions Restrictions
public object Value
public bool HasValue
public Type RuntimeType
public Type LimitType
public void .ctor(Expression expression, BindingRestrictions restrictions)
public void .ctor(Expression expression, BindingRestrictions restrictions, object value)
public Expression get_Expression()
public BindingRestrictions get_Restrictions()
public object get_Value()
public bool get_HasValue()
public Type get_RuntimeType()
public Type get_LimitType()
public DynamicMetaObject BindConvert(ConvertBinder binder)
public DynamicMetaObject BindGetMember(GetMemberBinder binder)
public DynamicMetaObject BindSetMember(SetMemberBinder binder, DynamicMetaObject value)
public DynamicMetaObject BindDeleteMember(DeleteMemberBinder binder)
public DynamicMetaObject BindGetIndex(GetIndexBinder binder, DynamicMetaObject[] indexes)
public DynamicMetaObject BindSetIndex(SetIndexBinder binder, DynamicMetaObject[] indexes, DynamicMetaObject value)
public DynamicMetaObject BindDeleteIndex(DeleteIndexBinder binder, DynamicMetaObject[] indexes)
public DynamicMetaObject BindInvokeMember(InvokeMemberBinder binder, DynamicMetaObject[] args)
public DynamicMetaObject BindInvoke(InvokeBinder binder, DynamicMetaObject[] args)
public DynamicMetaObject BindCreateInstance(CreateInstanceBinder binder, DynamicMetaObject[] args)
public DynamicMetaObject BindUnaryOperation(UnaryOperationBinder binder)
public DynamicMetaObject BindBinaryOperation(BinaryOperationBinder binder, DynamicMetaObject arg)
public IEnumerable`1<string> GetDynamicMemberNames()
internal Expression[] GetExpressions(DynamicMetaObject[] objects)
public DynamicMetaObject Create(object value, Expression expression)
}
public System.Dynamic.DynamicMetaObjectBinder : CallSiteBinder {
public Type ReturnType
internal bool IsStandardBinder
public Type get_ReturnType()
public Expression Bind(Object[] args, ReadOnlyCollection`1<ParameterExpression> parameters, LabelTarget returnLabel)
private DynamicMetaObject[] CreateArgumentMetaObjects(Object[] args, ReadOnlyCollection`1<ParameterExpression> parameters)
public DynamicMetaObject Bind(DynamicMetaObject target, DynamicMetaObject[] args)
public Expression GetUpdateExpression(Type type)
public DynamicMetaObject Defer(DynamicMetaObject target, DynamicMetaObject[] args)
public DynamicMetaObject Defer(DynamicMetaObject[] args)
private DynamicMetaObject MakeDeferred(BindingRestrictions rs, DynamicMetaObject[] args)
internal bool get_IsStandardBinder()
}
public System.Dynamic.DynamicObject : object {
public bool TryGetMember(GetMemberBinder binder, Object& result)
public bool TrySetMember(SetMemberBinder binder, object value)
public bool TryDeleteMember(DeleteMemberBinder binder)
public bool TryInvokeMember(InvokeMemberBinder binder, Object[] args, Object& result)
public bool TryConvert(ConvertBinder binder, Object& result)
public bool TryCreateInstance(CreateInstanceBinder binder, Object[] args, Object& result)
public bool TryInvoke(InvokeBinder binder, Object[] args, Object& result)
public bool TryBinaryOperation(BinaryOperationBinder binder, object arg, Object& result)
public bool TryUnaryOperation(UnaryOperationBinder binder, Object& result)
public bool TryGetIndex(GetIndexBinder binder, Object[] indexes, Object& result)
public bool TrySetIndex(SetIndexBinder binder, Object[] indexes, object value)
public bool TryDeleteIndex(DeleteIndexBinder binder, Object[] indexes)
public IEnumerable`1<string> GetDynamicMemberNames()
public DynamicMetaObject GetMetaObject(Expression parameter)
}
internal System.Dynamic.ExpandoClass : object {
private String[] _keys
private int _hashCode
private Dictionary`2<int, List`1<WeakReference>> _transitions
private int EmptyHashCode
internal ExpandoClass Empty
internal String[] Keys
internal void .ctor(String[] keys, int hashCode)
internal ExpandoClass FindNewClass(string newKey)
private List`1<WeakReference> GetTransitionList(int hashCode)
internal int GetValueIndex(string name, bool caseInsensitive, ExpandoObject obj)
internal int GetValueIndexCaseSensitive(string name)
private int GetValueIndexCaseInsensitive(string name, ExpandoObject obj)
internal String[] get_Keys()
}
public System.Dynamic.ExpandoObject : object {
private MethodInfo ExpandoTryGetValue
private MethodInfo ExpandoTrySetValue
private MethodInfo ExpandoTryDeleteValue
private MethodInfo ExpandoPromoteClass
private MethodInfo ExpandoCheckVersion
internal object LockObject
private ExpandoData _data
private int _count
internal object Uninitialized
internal int AmbiguousMatchFound
internal int NoMatch
private PropertyChangedEventHandler _propertyChanged
internal ExpandoClass Class
private ICollection`1<string> System.Collections.Generic.IDictionary<System.String,System.Object>.Keys
private ICollection`1<object> System.Collections.Generic.IDictionary<System.String,System.Object>.Values
private object System.Collections.Generic.IDictionary<System.String,System.Object>.Item
private int System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.Count
private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.IsReadOnly
internal bool TryGetValue(object indexClass, int index, string name, bool ignoreCase, Object& value)
internal void TrySetValue(object indexClass, int index, object value, string name, bool ignoreCase, bool add)
internal bool TryDeleteValue(object indexClass, int index, string name, bool ignoreCase, object deleteValue)
internal bool IsDeletedMember(int index)
internal ExpandoClass get_Class()
private ExpandoData PromoteClassCore(ExpandoClass oldClass, ExpandoClass newClass)
internal void PromoteClass(object oldClass, object newClass)
private DynamicMetaObject System.Dynamic.IDynamicMetaObjectProvider.GetMetaObject(Expression parameter)
private void TryAddMember(string key, object value)
private bool TryGetValueForKey(string key, Object& value)
private bool ExpandoContainsKey(string key)
private ICollection`1<string> System.Collections.Generic.IDictionary<System.String,System.Object>.get_Keys()
private ICollection`1<object> System.Collections.Generic.IDictionary<System.String,System.Object>.get_Values()
private object System.Collections.Generic.IDictionary<System.String,System.Object>.get_Item(string key)
private void System.Collections.Generic.IDictionary<System.String,System.Object>.set_Item(string key, object value)
private void System.Collections.Generic.IDictionary<System.String,System.Object>.Add(string key, object value)
private bool System.Collections.Generic.IDictionary<System.String,System.Object>.ContainsKey(string key)
private bool System.Collections.Generic.IDictionary<System.String,System.Object>.Remove(string key)
private bool System.Collections.Generic.IDictionary<System.String,System.Object>.TryGetValue(string key, Object& value)
private int System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.get_Count()
private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.get_IsReadOnly()
private void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.Add(KeyValuePair`2<string, object> item)
private void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.Clear()
private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.Contains(KeyValuePair`2<string, object> item)
private void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.CopyTo(KeyValuePair`2[] array, int arrayIndex)
private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.Remove(KeyValuePair`2<string, object> item)
private IEnumerator`1<KeyValuePair`2<string, object>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.GetEnumerator()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
private IEnumerator`1<KeyValuePair`2<string, object>> GetExpandoEnumerator(ExpandoData data, int version)
private void System.ComponentModel.INotifyPropertyChanged.add_PropertyChanged(PropertyChangedEventHandler value)
private void System.ComponentModel.INotifyPropertyChanged.remove_PropertyChanged(PropertyChangedEventHandler value)
}
public System.Dynamic.GetIndexBinder : DynamicMetaObjectBinder {
private CallInfo <CallInfo>k__BackingField
public Type ReturnType
public CallInfo CallInfo
internal bool IsStandardBinder
protected void .ctor(CallInfo callInfo)
public Type get_ReturnType()
public CallInfo get_CallInfo()
public DynamicMetaObject Bind(DynamicMetaObject target, DynamicMetaObject[] args)
internal bool get_IsStandardBinder()
public DynamicMetaObject FallbackGetIndex(DynamicMetaObject target, DynamicMetaObject[] indexes)
public DynamicMetaObject FallbackGetIndex(DynamicMetaObject target, DynamicMetaObject[] indexes, DynamicMetaObject errorSuggestion)
}
public System.Dynamic.GetMemberBinder : DynamicMetaObjectBinder {
private string <Name>k__BackingField
private bool <IgnoreCase>k__BackingField
public Type ReturnType
public string Name
public bool IgnoreCase
internal bool IsStandardBinder
protected void .ctor(string name, bool ignoreCase)
public Type get_ReturnType()
public string get_Name()
public bool get_IgnoreCase()
public DynamicMetaObject FallbackGetMember(DynamicMetaObject target)
public DynamicMetaObject FallbackGetMember(DynamicMetaObject target, DynamicMetaObject errorSuggestion)
public DynamicMetaObject Bind(DynamicMetaObject target, DynamicMetaObject[] args)
internal bool get_IsStandardBinder()
}
public System.Dynamic.IDynamicMetaObjectProvider {
public DynamicMetaObject GetMetaObject(Expression parameter)
}
public System.Dynamic.IInvokeOnGetBinder {
public bool InvokeOnGet
public bool get_InvokeOnGet()
}
public System.Dynamic.InvokeBinder : DynamicMetaObjectBinder {
private CallInfo <CallInfo>k__BackingField
public Type ReturnType
public CallInfo CallInfo
internal bool IsStandardBinder
protected void .ctor(CallInfo callInfo)
public Type get_ReturnType()
public CallInfo get_CallInfo()
public DynamicMetaObject FallbackInvoke(DynamicMetaObject target, DynamicMetaObject[] args)
public DynamicMetaObject FallbackInvoke(DynamicMetaObject target, DynamicMetaObject[] args, DynamicMetaObject errorSuggestion)
public DynamicMetaObject Bind(DynamicMetaObject target, DynamicMetaObject[] args)
internal bool get_IsStandardBinder()
}
public System.Dynamic.InvokeMemberBinder : DynamicMetaObjectBinder {
private string <Name>k__BackingField
private bool <IgnoreCase>k__BackingField
private CallInfo <CallInfo>k__BackingField
public Type ReturnType
public string Name
public bool IgnoreCase
public CallInfo CallInfo
internal bool IsStandardBinder
protected void .ctor(string name, bool ignoreCase, CallInfo callInfo)
public Type get_ReturnType()
public string get_Name()
public bool get_IgnoreCase()
public CallInfo get_CallInfo()
public DynamicMetaObject Bind(DynamicMetaObject target, DynamicMetaObject[] args)
internal bool get_IsStandardBinder()
public DynamicMetaObject FallbackInvokeMember(DynamicMetaObject target, DynamicMetaObject[] args)
public DynamicMetaObject FallbackInvokeMember(DynamicMetaObject target, DynamicMetaObject[] args, DynamicMetaObject errorSuggestion)
public DynamicMetaObject FallbackInvoke(DynamicMetaObject target, DynamicMetaObject[] args, DynamicMetaObject errorSuggestion)
}
public System.Dynamic.SetIndexBinder : DynamicMetaObjectBinder {
private CallInfo <CallInfo>k__BackingField
public Type ReturnType
public CallInfo CallInfo
internal bool IsStandardBinder
protected void .ctor(CallInfo callInfo)
public Type get_ReturnType()
public CallInfo get_CallInfo()
public DynamicMetaObject Bind(DynamicMetaObject target, DynamicMetaObject[] args)
internal bool get_IsStandardBinder()
public DynamicMetaObject FallbackSetIndex(DynamicMetaObject target, DynamicMetaObject[] indexes, DynamicMetaObject value)
public DynamicMetaObject FallbackSetIndex(DynamicMetaObject target, DynamicMetaObject[] indexes, DynamicMetaObject value, DynamicMetaObject errorSuggestion)
}
public System.Dynamic.SetMemberBinder : DynamicMetaObjectBinder {
private string <Name>k__BackingField
private bool <IgnoreCase>k__BackingField
public Type ReturnType
public string Name
public bool IgnoreCase
internal bool IsStandardBinder
protected void .ctor(string name, bool ignoreCase)
public Type get_ReturnType()
public string get_Name()
public bool get_IgnoreCase()
public DynamicMetaObject Bind(DynamicMetaObject target, DynamicMetaObject[] args)
internal bool get_IsStandardBinder()
public DynamicMetaObject FallbackSetMember(DynamicMetaObject target, DynamicMetaObject value)
public DynamicMetaObject FallbackSetMember(DynamicMetaObject target, DynamicMetaObject value, DynamicMetaObject errorSuggestion)
}
public System.Dynamic.UnaryOperationBinder : DynamicMetaObjectBinder {
private ExpressionType <Operation>k__BackingField
public Type ReturnType
public ExpressionType Operation
internal bool IsStandardBinder
protected void .ctor(ExpressionType operation)
public Type get_ReturnType()
public ExpressionType get_Operation()
public DynamicMetaObject FallbackUnaryOperation(DynamicMetaObject target)
public DynamicMetaObject FallbackUnaryOperation(DynamicMetaObject target, DynamicMetaObject errorSuggestion)
public DynamicMetaObject Bind(DynamicMetaObject target, DynamicMetaObject[] args)
internal bool get_IsStandardBinder()
internal bool OperationIsValid(ExpressionType operation)
}
internal System.Dynamic.UpdateDelegates : object {
internal TRet UpdateAndExecute0(CallSite site)
internal TRet NoMatch0(CallSite site)
internal TRet UpdateAndExecute1(CallSite site, T0 arg0)
internal TRet NoMatch1(CallSite site, T0 arg0)
internal TRet UpdateAndExecute2(CallSite site, T0 arg0, T1 arg1)
internal TRet NoMatch2(CallSite site, T0 arg0, T1 arg1)
internal TRet UpdateAndExecute3(CallSite site, T0 arg0, T1 arg1, T2 arg2)
internal TRet NoMatch3(CallSite site, T0 arg0, T1 arg1, T2 arg2)
internal TRet UpdateAndExecute4(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3)
internal TRet NoMatch4(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3)
internal TRet UpdateAndExecute5(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4)
internal TRet NoMatch5(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4)
internal TRet UpdateAndExecute6(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5)
internal TRet NoMatch6(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5)
internal TRet UpdateAndExecute7(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6)
internal TRet NoMatch7(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6)
internal TRet UpdateAndExecute8(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7)
internal TRet NoMatch8(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7)
internal TRet UpdateAndExecute9(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8)
internal TRet NoMatch9(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8)
internal TRet UpdateAndExecute10(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9)
internal TRet NoMatch10(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9)
internal void UpdateAndExecuteVoid1(CallSite site, T0 arg0)
internal void NoMatchVoid1(CallSite site, T0 arg0)
internal void UpdateAndExecuteVoid2(CallSite site, T0 arg0, T1 arg1)
internal void NoMatchVoid2(CallSite site, T0 arg0, T1 arg1)
internal void UpdateAndExecuteVoid3(CallSite site, T0 arg0, T1 arg1, T2 arg2)
internal void NoMatchVoid3(CallSite site, T0 arg0, T1 arg1, T2 arg2)
internal void UpdateAndExecuteVoid4(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3)
internal void NoMatchVoid4(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3)
internal void UpdateAndExecuteVoid5(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4)
internal void NoMatchVoid5(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4)
internal void UpdateAndExecuteVoid6(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5)
internal void NoMatchVoid6(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5)
internal void UpdateAndExecuteVoid7(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6)
internal void NoMatchVoid7(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6)
internal void UpdateAndExecuteVoid8(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7)
internal void NoMatchVoid8(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7)
internal void UpdateAndExecuteVoid9(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8)
internal void NoMatchVoid9(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8)
internal void UpdateAndExecuteVoid10(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9)
internal void NoMatchVoid10(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9)
}
internal System.Dynamic.Utils.CacheDict`2 : object {
private int _mask
private Entry[] _entries
internal TValue Item
internal void .ctor(int size)
private int AlignSize(int size)
internal bool TryGetValue(TKey key, TValue& value)
internal void Add(TKey key, TValue value)
internal void set_Item(TKey key, TValue value)
}
internal System.Dynamic.Utils.CollectionExtensions : object {
public TrueReadOnlyCollection`1<T> AddFirst(ReadOnlyCollection`1<T> list, T item)
public T[] AddFirst(T[] array, T item)
public T[] AddLast(T[] array, T item)
public T[] RemoveFirst(T[] array)
public T[] RemoveLast(T[] array)
public ReadOnlyCollection`1<T> ToReadOnly(IEnumerable`1<T> enumerable)
public int ListHashCode(ReadOnlyCollection`1<T> list)
public bool ListEquals(ReadOnlyCollection`1<T> first, ReadOnlyCollection`1<T> second)
}
internal System.Dynamic.Utils.ContractUtils : object {
public Exception Unreachable
public Exception get_Unreachable()
public void Requires(bool precondition, string paramName)
public void RequiresNotNull(object value, string paramName)
public void RequiresNotNull(object value, string paramName, int index)
public void RequiresNotEmpty(ICollection`1<T> collection, string paramName)
public void RequiresNotNullItems(IList`1<T> array, string arrayName)
public void AssertLockHeld(object lockObject)
private string GetParamName(string paramName, int index)
public void RequiresArrayRange(IList`1<T> array, int offset, int count, string offsetName, string countName)
}
internal System.Dynamic.Utils.EmptyReadOnlyCollection`1 : object {
public ReadOnlyCollection`1<T> Instance
}
internal System.Dynamic.Utils.ExpressionUtils : object {
public ReadOnlyCollection`1<ParameterExpression> ReturnReadOnly(IParameterProvider provider, Object& collection)
public ReadOnlyCollection`1<T> ReturnReadOnly(IReadOnlyList`1& collection)
public ReadOnlyCollection`1<Expression> ReturnReadOnly(IArgumentProvider provider, Object& collection)
public T ReturnObject(object collectionOrT)
public void ValidateArgumentTypes(MethodBase method, ExpressionType nodeKind, ReadOnlyCollection`1& arguments, string methodParamName)
public void ValidateArgumentCount(MethodBase method, ExpressionType nodeKind, int count, ParameterInfo[] pis)
public Expression ValidateOneArgument(MethodBase method, ExpressionType nodeKind, Expression arguments, ParameterInfo pi, string methodParamName, string argumentParamName, int index)
public void RequiresCanRead(Expression expression, string paramName)
public void RequiresCanRead(Expression expression, string paramName, int idx)
public bool TryQuote(Type parameterType, Expression& argument)
internal ParameterInfo[] GetParametersForValidation(MethodBase method, ExpressionType nodeKind)
internal bool SameElements(ICollection`1<T> replacement, IReadOnlyList`1<T> current)
internal bool SameElements(IEnumerable`1& replacement, IReadOnlyList`1<T> current)
private bool SameElementsInCollection(ICollection`1<T> replacement, IReadOnlyList`1<T> current)
}
internal System.Dynamic.Utils.ExpressionVisitorUtils : object {
public Expression[] VisitBlockExpressions(ExpressionVisitor visitor, BlockExpression block)
public ParameterExpression[] VisitParameters(ExpressionVisitor visitor, IParameterProvider nodes, string callerName)
public Expression[] VisitArguments(ExpressionVisitor visitor, IArgumentProvider nodes)
}
internal System.Dynamic.Utils.Helpers : object {
internal T CommonNode(T first, T second, Func`2<T, T> parent)
internal void IncrementCount(T key, Dictionary`2<T, int> dict)
}
internal System.Dynamic.Utils.ListArgumentProvider : ListProvider`1<Expression> {
private IArgumentProvider _provider
private Expression _arg0
protected Expression First
protected int ElementCount
internal void .ctor(IArgumentProvider provider, Expression arg0)
protected Expression get_First()
protected int get_ElementCount()
protected Expression GetElement(int index)
}
internal System.Dynamic.Utils.ListParameterProvider : ListProvider`1<ParameterExpression> {
private IParameterProvider _provider
private ParameterExpression _arg0
protected ParameterExpression First
protected int ElementCount
internal void .ctor(IParameterProvider provider, ParameterExpression arg0)
protected ParameterExpression get_First()
protected int get_ElementCount()
protected ParameterExpression GetElement(int index)
}
internal System.Dynamic.Utils.ListProvider`1 : object {
protected T First
protected int ElementCount
public T Item
public int Count
public bool IsReadOnly
protected T get_First()
protected int get_ElementCount()
protected T GetElement(int index)
public int IndexOf(T item)
public void Insert(int index, T item)
public void RemoveAt(int index)
public T get_Item(int index)
public void set_Item(int index, T value)
public void Add(T item)
public void Clear()
public bool Contains(T item)
public void CopyTo(T[] array, int index)
public int get_Count()
public bool get_IsReadOnly()
public bool Remove(T item)
public IEnumerator`1<T> GetEnumerator()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
}
internal System.Dynamic.Utils.TypeExtensions : object {
private CacheDict`2<MethodBase, ParameterInfo[]> s_paramInfoCache
public MethodInfo GetAnyStaticMethodValidated(Type type, string name, Type[] types)
private bool MatchesArgumentTypes(MethodInfo mi, Type[] argTypes)
public Type GetReturnType(MethodBase mi)
public TypeCode GetTypeCode(Type type)
internal ParameterInfo[] GetParametersCached(MethodBase method)
internal bool IsByRefParameter(ParameterInfo pi)
}
internal System.Dynamic.Utils.TypeUtils : object {
private Assembly s_mscorlib
private Assembly MsCorLib
public Type GetNonNullableType(Type type)
public Type GetNullableType(Type type)
public bool IsNullableType(Type type)
public bool IsNullableOrReferenceType(Type type)
public bool IsBool(Type type)
public bool IsNumeric(Type type)
public bool IsInteger(Type type)
public bool IsInteger64(Type type)
public bool IsArithmetic(Type type)
public bool IsUnsignedInt(Type type)
public bool IsIntegerOrBool(Type type)
public bool IsNumericOrBool(Type type)
public bool IsValidInstanceType(MemberInfo member, Type instanceType)
public bool HasIdentityPrimitiveOrNullableConversionTo(Type source, Type dest)
public bool HasReferenceConversionTo(Type source, Type dest)
private bool IsCovariant(Type t)
private bool IsContravariant(Type t)
private bool IsInvariant(Type t)
private bool IsDelegate(Type t)
public bool IsLegalExplicitVariantDelegateConversion(Type source, Type dest)
public bool IsConvertible(Type type)
public bool HasReferenceEquality(Type left, Type right)
public bool HasBuiltInEqualityOperator(Type left, Type right)
public bool IsImplicitlyConvertibleTo(Type source, Type destination)
public MethodInfo GetUserDefinedCoercionMethod(Type convertFrom, Type convertToType)
private MethodInfo FindConversionOperator(MethodInfo[] methods, Type typeFrom, Type typeTo)
private bool IsImplicitNumericConversion(Type source, Type destination)
private bool IsImplicitReferenceConversion(Type source, Type destination)
private bool IsImplicitBoxingConversion(Type source, Type destination)
private bool IsImplicitNullableConversion(Type source, Type destination)
public Type FindGenericType(Type definition, Type type)
public MethodInfo GetBooleanOperator(Type type, string name)
public Type GetNonRefType(Type type)
public bool AreEquivalent(Type t1, Type t2)
public bool AreReferenceAssignable(Type dest, Type src)
public bool IsSameOrSubclass(Type type, Type subType)
public void ValidateType(Type type, string paramName)
public void ValidateType(Type type, string paramName, bool allowByRef, bool allowPointer)
public bool ValidateType(Type type, string paramName, int index)
private Assembly get_MsCorLib()
public bool CanCache(Type t)
public MethodInfo GetInvokeMethod(Type delegateType)
internal bool IsUnsigned(Type type)
internal bool IsUnsigned(TypeCode typeCode)
internal bool IsFloatingPoint(Type type)
internal bool IsFloatingPoint(TypeCode typeCode)
}
public System.Func`10 : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9)
public IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, AsyncCallback callback, object object)
public TResult EndInvoke(IAsyncResult result)
}
public System.Func`11 : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10)
public IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, AsyncCallback callback, object object)
public TResult EndInvoke(IAsyncResult result)
}
public System.Func`12 : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11)
public IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, AsyncCallback callback, object object)
public TResult EndInvoke(IAsyncResult result)
}
public System.Func`13 : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12)
public IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, AsyncCallback callback, object object)
public TResult EndInvoke(IAsyncResult result)
}
public System.Func`14 : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13)
public IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, AsyncCallback callback, object object)
public TResult EndInvoke(IAsyncResult result)
}
public System.Func`15 : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14)
public IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, AsyncCallback callback, object object)
public TResult EndInvoke(IAsyncResult result)
}
public System.Func`16 : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15)
public IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15, AsyncCallback callback, object object)
public TResult EndInvoke(IAsyncResult result)
}
public System.Func`17 : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15, T16 arg16)
public IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15, T16 arg16, AsyncCallback callback, object object)
public TResult EndInvoke(IAsyncResult result)
}
public System.IO.HandleInheritability : Enum {
public int value__
public HandleInheritability None
public HandleInheritability Inheritable
}
internal System.IO.MemoryMappedFiles.MemoryMapImpl : object {
private IntPtr OpenFileInternal(string path, FileMode mode, string mapName, Int64& capacity, MemoryMappedFileAccess access, MemoryMappedFileOptions options, Int32& error)
private IntPtr OpenHandleInternal(IntPtr handle, string mapName, Int64& capacity, MemoryMappedFileAccess access, MemoryMappedFileOptions options, Int32& error)
internal void CloseMapping(IntPtr handle)
internal void Flush(IntPtr file_handle)
internal void ConfigureHandleInheritability(IntPtr handle, HandleInheritability inheritability)
internal bool Unmap(IntPtr mmap_handle)
private int MapInternal(IntPtr handle, long offset, Int64& size, MemoryMappedFileAccess access, IntPtr& mmap_handle, IntPtr& base_address)
internal void Map(IntPtr handle, long offset, Int64& size, MemoryMappedFileAccess access, IntPtr& mmap_handle, IntPtr& base_address)
private Exception CreateException(int error, string path)
internal IntPtr OpenFile(string path, FileMode mode, string mapName, Int64& capacity, MemoryMappedFileAccess access, MemoryMappedFileOptions options)
internal IntPtr OpenHandle(IntPtr handle, string mapName, Int64& capacity, MemoryMappedFileAccess access, MemoryMappedFileOptions options)
}
public System.IO.MemoryMappedFiles.MemoryMappedFile : object {
private FileStream stream
private bool keepOpen
private SafeMemoryMappedFileHandle handle
public SafeMemoryMappedFileHandle SafeMemoryMappedFileHandle
public MemoryMappedFile CreateFromFile(string path)
public MemoryMappedFile CreateFromFile(string path, FileMode mode)
public MemoryMappedFile CreateFromFile(string path, FileMode mode, string mapName)
public MemoryMappedFile CreateFromFile(string path, FileMode mode, string mapName, long capacity)
public MemoryMappedFile CreateFromFile(string path, FileMode mode, string mapName, long capacity, MemoryMappedFileAccess access)
public MemoryMappedFile CreateFromFile(FileStream fileStream, string mapName, long capacity, MemoryMappedFileAccess access, HandleInheritability inheritability, bool leaveOpen)
public MemoryMappedFile CreateFromFile(FileStream fileStream, string mapName, long capacity, MemoryMappedFileAccess access, MemoryMappedFileSecurity memoryMappedFileSecurity, HandleInheritability inheritability, bool leaveOpen)
private MemoryMappedFile CoreShmCreate(string mapName, long capacity, MemoryMappedFileAccess access, MemoryMappedFileOptions options, MemoryMappedFileSecurity memoryMappedFileSecurity, HandleInheritability inheritability, FileMode mode)
public MemoryMappedFile CreateNew(string mapName, long capacity)
public MemoryMappedFile CreateNew(string mapName, long capacity, MemoryMappedFileAccess access)
public MemoryMappedFile CreateNew(string mapName, long capacity, MemoryMappedFileAccess access, MemoryMappedFileOptions options, HandleInheritability inheritability)
public MemoryMappedFile CreateNew(string mapName, long capacity, MemoryMappedFileAccess access, MemoryMappedFileOptions options, MemoryMappedFileSecurity memoryMappedFileSecurity, HandleInheritability inheritability)
public MemoryMappedFile CreateOrOpen(string mapName, long capacity)
public MemoryMappedFile CreateOrOpen(string mapName, long capacity, MemoryMappedFileAccess access)
public MemoryMappedFile CreateOrOpen(string mapName, long capacity, MemoryMappedFileAccess access, MemoryMappedFileOptions options, HandleInheritability inheritability)
public MemoryMappedFile CreateOrOpen(string mapName, long capacity, MemoryMappedFileAccess access, MemoryMappedFileOptions options, MemoryMappedFileSecurity memoryMappedFileSecurity, HandleInheritability inheritability)
public MemoryMappedFile OpenExisting(string mapName)
public MemoryMappedFile OpenExisting(string mapName, MemoryMappedFileRights desiredAccessRights)
public MemoryMappedFile OpenExisting(string mapName, MemoryMappedFileRights desiredAccessRights, HandleInheritability inheritability)
public MemoryMappedViewStream CreateViewStream()
public MemoryMappedViewStream CreateViewStream(long offset, long size)
public MemoryMappedViewStream CreateViewStream(long offset, long size, MemoryMappedFileAccess access)
public MemoryMappedViewAccessor CreateViewAccessor()
public MemoryMappedViewAccessor CreateViewAccessor(long offset, long size)
public MemoryMappedViewAccessor CreateViewAccessor(long offset, long size, MemoryMappedFileAccess access)
public void Dispose()
protected void Dispose(bool disposing)
public MemoryMappedFileSecurity GetAccessControl()
public void SetAccessControl(MemoryMappedFileSecurity memoryMappedFileSecurity)
public SafeMemoryMappedFileHandle get_SafeMemoryMappedFileHandle()
internal FileAccess GetFileAccess(MemoryMappedFileAccess access)
}
public System.IO.MemoryMappedFiles.MemoryMappedFileAccess : Enum {
public int value__
public MemoryMappedFileAccess ReadWrite
public MemoryMappedFileAccess Read
public MemoryMappedFileAccess Write
public MemoryMappedFileAccess CopyOnWrite
public MemoryMappedFileAccess ReadExecute
public MemoryMappedFileAccess ReadWriteExecute
}
public System.IO.MemoryMappedFiles.MemoryMappedFileOptions : Enum {
public int value__
public MemoryMappedFileOptions None
public MemoryMappedFileOptions DelayAllocatePages
}
public System.IO.MemoryMappedFiles.MemoryMappedFileRights : Enum {
public int value__
public MemoryMappedFileRights CopyOnWrite
public MemoryMappedFileRights Write
public MemoryMappedFileRights Read
public MemoryMappedFileRights Execute
public MemoryMappedFileRights Delete
public MemoryMappedFileRights ReadPermissions
public MemoryMappedFileRights ChangePermissions
public MemoryMappedFileRights TakeOwnership
public MemoryMappedFileRights ReadWrite
public MemoryMappedFileRights ReadExecute
public MemoryMappedFileRights ReadWriteExecute
public MemoryMappedFileRights FullControl
public MemoryMappedFileRights AccessSystemSecurity
}
public System.IO.MemoryMappedFiles.MemoryMappedFileSecurity : ObjectSecurity`1<MemoryMappedFileRights> {
internal void .ctor(SafeMemoryMappedFileHandle safeHandle, AccessControlSections includeSections)
internal void PersistHandle(SafeHandle handle)
}
internal System.IO.MemoryMappedFiles.MemoryMappedView : object {
private SafeMemoryMappedViewHandle m_viewHandle
private long m_pointerOffset
private long m_size
private MemoryMappedFileAccess m_access
internal SafeMemoryMappedViewHandle ViewHandle
internal long PointerOffset
internal long Size
internal MemoryMappedFileAccess Access
internal bool IsClosed
private void .ctor(SafeMemoryMappedViewHandle viewHandle, long pointerOffset, long size, MemoryMappedFileAccess access)
internal SafeMemoryMappedViewHandle get_ViewHandle()
internal long get_PointerOffset()
internal long get_Size()
internal MemoryMappedFileAccess get_Access()
internal MemoryMappedView Create(IntPtr handle, long offset, long size, MemoryMappedFileAccess access)
public void Flush(IntPtr capacity)
protected void Dispose(bool disposing)
public void Dispose()
internal bool get_IsClosed()
}
public System.IO.MemoryMappedFiles.MemoryMappedViewAccessor : UnmanagedMemoryAccessor {
private MemoryMappedView m_view
public SafeMemoryMappedViewHandle SafeMemoryMappedViewHandle
public long PointerOffset
internal void .ctor(MemoryMappedView view)
public SafeMemoryMappedViewHandle get_SafeMemoryMappedViewHandle()
public long get_PointerOffset()
protected void Dispose(bool disposing)
public void Flush()
}
public System.IO.MemoryMappedFiles.MemoryMappedViewStream : UnmanagedMemoryStream {
private MemoryMappedView m_view
public SafeMemoryMappedViewHandle SafeMemoryMappedViewHandle
public long PointerOffset
internal void .ctor(MemoryMappedView view)
public SafeMemoryMappedViewHandle get_SafeMemoryMappedViewHandle()
public void SetLength(long value)
public long get_PointerOffset()
protected void Dispose(bool disposing)
public void Flush()
}
public System.IO.Pipes.AnonymousPipeClientStream : PipeStream {
public PipeTransmissionMode ReadMode
public PipeTransmissionMode TransmissionMode
private SafePipeHandle ToSafePipeHandle(string pipeHandleAsString)
public void .ctor(string pipeHandleAsString)
public void .ctor(PipeDirection direction, string pipeHandleAsString)
public void .ctor(PipeDirection direction, SafePipeHandle safePipeHandle)
protected void Finalize()
public void set_ReadMode(PipeTransmissionMode value)
public PipeTransmissionMode get_TransmissionMode()
}
public System.IO.Pipes.AnonymousPipeServerStream : PipeStream {
private IAnonymousPipeServer impl
private SafePipeHandle <ClientSafePipeHandle>k__BackingField
public SafePipeHandle ClientSafePipeHandle
public PipeTransmissionMode ReadMode
public PipeTransmissionMode TransmissionMode
public void .ctor(PipeDirection direction)
public void .ctor(PipeDirection direction, HandleInheritability inheritability)
public void .ctor(PipeDirection direction, HandleInheritability inheritability, int bufferSize)
public void .ctor(PipeDirection direction, HandleInheritability inheritability, int bufferSize, PipeSecurity pipeSecurity)
public void .ctor(PipeDirection direction, SafePipeHandle serverSafePipeHandle, SafePipeHandle clientSafePipeHandle)
protected void Finalize()
public SafePipeHandle get_ClientSafePipeHandle()
private void set_ClientSafePipeHandle(SafePipeHandle value)
public void set_ReadMode(PipeTransmissionMode value)
public PipeTransmissionMode get_TransmissionMode()
public void DisposeLocalCopyOfClientHandle()
public string GetClientHandleAsString()
}
internal System.IO.Pipes.IAnonymousPipeServer {
public SafePipeHandle ClientHandle
public SafePipeHandle get_ClientHandle()
public void DisposeLocalCopyOfClientHandle()
}
internal System.IO.Pipes.INamedPipeClient {
public int NumberOfServerInstances
public bool IsAsync
public void Connect()
public void Connect(int timeout)
public int get_NumberOfServerInstances()
public bool get_IsAsync()
}
internal System.IO.Pipes.INamedPipeServer {
public void Disconnect()
public void WaitForConnection()
}
internal System.IO.Pipes.IPipe {
public SafePipeHandle Handle
public SafePipeHandle get_Handle()
public void WaitForPipeDrain()
}
public System.IO.Pipes.NamedPipeClientStream : PipeStream {
private INamedPipeClient impl
public int NumberOfServerInstances
public void .ctor(string pipeName)
public void .ctor(string serverName, string pipeName)
public void .ctor(string serverName, string pipeName, PipeDirection direction)
public void .ctor(string serverName, string pipeName, PipeDirection direction, PipeOptions options)
public void .ctor(string serverName, string pipeName, PipeDirection direction, PipeOptions options, TokenImpersonationLevel impersonationLevel)
public void .ctor(string serverName, string pipeName, PipeDirection direction, PipeOptions options, TokenImpersonationLevel impersonationLevel, HandleInheritability inheritability)
public void .ctor(PipeDirection direction, bool isAsync, bool isConnected, SafePipeHandle safePipeHandle)
public void .ctor(string serverName, string pipeName, PipeAccessRights desiredAccessRights, PipeOptions options, TokenImpersonationLevel impersonationLevel, HandleInheritability inheritability)
protected void Finalize()
public void Connect()
public void Connect(int timeout)
public Task ConnectAsync()
public Task ConnectAsync(int timeout)
public Task ConnectAsync(CancellationToken cancellationToken)
public Task ConnectAsync(int timeout, CancellationToken cancellationToken)
protected internal void CheckPipePropertyOperations()
public int get_NumberOfServerInstances()
}
public System.IO.Pipes.NamedPipeServerStream : PipeStream {
public int MaxAllowedServerInstances
private INamedPipeServer impl
private Action wait_connect_delegate
public void .ctor(string pipeName)
public void .ctor(string pipeName, PipeDirection direction)
public void .ctor(string pipeName, PipeDirection direction, int maxNumberOfServerInstances)
public void .ctor(string pipeName, PipeDirection direction, int maxNumberOfServerInstances, PipeTransmissionMode transmissionMode)
public void .ctor(string pipeName, PipeDirection direction, int maxNumberOfServerInstances, PipeTransmissionMode transmissionMode, PipeOptions options)
public void .ctor(string pipeName, PipeDirection direction, int maxNumberOfServerInstances, PipeTransmissionMode transmissionMode, PipeOptions options, int inBufferSize, int outBufferSize)
public void .ctor(string pipeName, PipeDirection direction, int maxNumberOfServerInstances, PipeTransmissionMode transmissionMode, PipeOptions options, int inBufferSize, int outBufferSize, PipeSecurity pipeSecurity)
public void .ctor(string pipeName, PipeDirection direction, int maxNumberOfServerInstances, PipeTransmissionMode transmissionMode, PipeOptions options, int inBufferSize, int outBufferSize, PipeSecurity pipeSecurity, HandleInheritability inheritability)
public void .ctor(string pipeName, PipeDirection direction, int maxNumberOfServerInstances, PipeTransmissionMode transmissionMode, PipeOptions options, int inBufferSize, int outBufferSize, PipeSecurity pipeSecurity, HandleInheritability inheritability, PipeAccessRights additionalAccessRights)
public void .ctor(PipeDirection direction, bool isAsync, bool isConnected, SafePipeHandle safePipeHandle)
protected void Finalize()
public void Disconnect()
public void RunAsClient(PipeStreamImpersonationWorker impersonationWorker)
public void WaitForConnection()
public Task WaitForConnectionAsync()
public Task WaitForConnectionAsync(CancellationToken cancellationToken)
public string GetImpersonationUserName()
public IAsyncResult BeginWaitForConnection(AsyncCallback callback, object state)
public void EndWaitForConnection(IAsyncResult asyncResult)
}
public System.IO.Pipes.PipeAccessRights : Enum {
public int value__
public PipeAccessRights ReadData
public PipeAccessRights WriteData
public PipeAccessRights CreateNewInstance
public PipeAccessRights ReadExtendedAttributes
public PipeAccessRights WriteExtendedAttributes
public PipeAccessRights ReadAttributes
public PipeAccessRights WriteAttributes
public PipeAccessRights Delete
public PipeAccessRights ReadPermissions
public PipeAccessRights ChangePermissions
public PipeAccessRights TakeOwnership
public PipeAccessRights Synchronize
public PipeAccessRights AccessSystemSecurity
public PipeAccessRights Read
public PipeAccessRights Write
public PipeAccessRights ReadWrite
public PipeAccessRights FullControl
}
public System.IO.Pipes.PipeAccessRule : AccessRule {
public PipeAccessRights PipeAccessRights
public void .ctor(IdentityReference identity, PipeAccessRights rights, AccessControlType type)
public void .ctor(string identity, PipeAccessRights rights, AccessControlType type)
public PipeAccessRights get_PipeAccessRights()
}
public System.IO.Pipes.PipeAuditRule : AuditRule {
public PipeAccessRights PipeAccessRights
public void .ctor(IdentityReference identity, PipeAccessRights rights, AuditFlags flags)
public void .ctor(string identity, PipeAccessRights rights, AuditFlags flags)
public PipeAccessRights get_PipeAccessRights()
}
public System.IO.Pipes.PipeDirection : Enum {
public int value__
public PipeDirection In
public PipeDirection Out
public PipeDirection InOut
}
public System.IO.Pipes.PipeOptions : Enum {
public int value__
public PipeOptions None
public PipeOptions WriteThrough
public PipeOptions Asynchronous
}
public System.IO.Pipes.PipeSecurity : NativeObjectSecurity {
public Type AccessRightType
public Type AccessRuleType
public Type AuditRuleType
internal void .ctor(SafeHandle handle, AccessControlSections includeSections)
public Type get_AccessRightType()
public Type get_AccessRuleType()
public Type get_AuditRuleType()
public AccessRule AccessRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AccessControlType type)
public void AddAccessRule(PipeAccessRule rule)
public void AddAuditRule(PipeAuditRule rule)
public AuditRule AuditRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags flags)
protected internal void Persist(SafeHandle handle)
protected internal void Persist(string name)
public bool RemoveAccessRule(PipeAccessRule rule)
public void RemoveAccessRuleSpecific(PipeAccessRule rule)
public bool RemoveAuditRule(PipeAuditRule rule)
public void RemoveAuditRuleAll(PipeAuditRule rule)
public void RemoveAuditRuleSpecific(PipeAuditRule rule)
public void ResetAccessRule(PipeAccessRule rule)
public void SetAccessRule(PipeAccessRule rule)
public void SetAuditRule(PipeAuditRule rule)
}
public System.IO.Pipes.PipeStream : Stream {
internal int DefaultBufferSize
private PipeDirection direction
private PipeTransmissionMode transmission_mode
private PipeTransmissionMode read_trans_mode
private int buffer_size
private SafePipeHandle handle
private Stream stream
private bool <IsAsync>k__BackingField
private bool <IsConnected>k__BackingField
private bool <IsHandleExposed>k__BackingField
private bool <IsMessageComplete>k__BackingField
private Func`4<Byte[], int, int, int> read_delegate
private Action`3<Byte[], int, int> write_delegate
internal bool IsWindows
public bool CanRead
public bool CanSeek
public bool CanWrite
public int InBufferSize
public bool IsAsync
public bool IsConnected
internal Stream Stream
protected bool IsHandleExposed
public bool IsMessageComplete
public int OutBufferSize
public PipeTransmissionMode ReadMode
public SafePipeHandle SafePipeHandle
public PipeTransmissionMode TransmissionMode
public long Length
public long Position
internal bool get_IsWindows()
internal Exception ThrowACLException()
internal PipeAccessRights ToAccessRights(PipeDirection direction)
internal PipeDirection ToDirection(PipeAccessRights rights)
protected void .ctor(PipeDirection direction, int bufferSize)
protected void .ctor(PipeDirection direction, PipeTransmissionMode transmissionMode, int outBufferSize)
public bool get_CanRead()
public bool get_CanSeek()
public bool get_CanWrite()
public int get_InBufferSize()
public bool get_IsAsync()
private void set_IsAsync(bool value)
public bool get_IsConnected()
protected void set_IsConnected(bool value)
internal Stream get_Stream()
internal void set_Stream(Stream value)
protected bool get_IsHandleExposed()
private void set_IsHandleExposed(bool value)
public bool get_IsMessageComplete()
private void set_IsMessageComplete(bool value)
public int get_OutBufferSize()
public PipeTransmissionMode get_ReadMode()
public void set_ReadMode(PipeTransmissionMode value)
public SafePipeHandle get_SafePipeHandle()
public PipeTransmissionMode get_TransmissionMode()
protected internal void CheckPipePropertyOperations()
protected internal void CheckReadOperations()
protected internal void CheckWriteOperations()
protected void InitializeHandle(SafePipeHandle handle, bool isExposed, bool isAsync)
protected void Dispose(bool disposing)
public long get_Length()
public long get_Position()
public void set_Position(long value)
public void SetLength(long value)
public long Seek(long offset, SeekOrigin origin)
public PipeSecurity GetAccessControl()
public void SetAccessControl(PipeSecurity pipeSecurity)
public void WaitForPipeDrain()
public int Read(Byte[] buffer, int offset, int count)
public int ReadByte()
public void Write(Byte[] buffer, int offset, int count)
public void WriteByte(byte value)
public void Flush()
public IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state)
public IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state)
public int EndRead(IAsyncResult asyncResult)
public void EndWrite(IAsyncResult asyncResult)
}
public System.IO.Pipes.PipeStreamImpersonationWorker : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke()
public IAsyncResult BeginInvoke(AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.IO.Pipes.PipeTransmissionMode : Enum {
public int value__
public PipeTransmissionMode Byte
public PipeTransmissionMode Message
}
internal System.IO.Pipes.SecurityAttributes : ValueType {
public int Length
public IntPtr SecurityDescriptor
public bool Inheritable
public void .ctor(HandleInheritability inheritability, IntPtr securityDescriptor)
}
internal System.IO.Pipes.UnixAnonymousPipe : object {
public SafePipeHandle Handle
public SafePipeHandle get_Handle()
public void WaitForPipeDrain()
}
internal System.IO.Pipes.UnixAnonymousPipeClient : UnixAnonymousPipe {
private SafePipeHandle handle
public SafePipeHandle Handle
public void .ctor(AnonymousPipeClientStream owner, SafePipeHandle handle)
public SafePipeHandle get_Handle()
}
internal System.IO.Pipes.UnixAnonymousPipeServer : UnixAnonymousPipe {
private SafePipeHandle server_handle
private SafePipeHandle client_handle
public SafePipeHandle Handle
public SafePipeHandle ClientHandle
public void .ctor(AnonymousPipeServerStream owner, PipeDirection direction, HandleInheritability inheritability, int bufferSize)
public void .ctor(AnonymousPipeServerStream owner, SafePipeHandle serverHandle, SafePipeHandle clientHandle)
public SafePipeHandle get_Handle()
public SafePipeHandle get_ClientHandle()
public void DisposeLocalCopyOfClientHandle()
}
internal System.IO.Pipes.UnixNamedPipe : object {
public SafePipeHandle Handle
public SafePipeHandle get_Handle()
public void WaitForPipeDrain()
public void EnsureTargetFile(string name)
protected void ValidateOptions(PipeOptions options, PipeTransmissionMode mode)
protected string RightsToAccess(PipeAccessRights rights)
protected FileAccess RightsToFileAccess(PipeAccessRights rights)
}
internal System.IO.Pipes.UnixNamedPipeClient : UnixNamedPipe {
private NamedPipeClientStream owner
private SafePipeHandle handle
private Action opener
public SafePipeHandle Handle
public bool IsAsync
public int NumberOfServerInstances
public void .ctor(NamedPipeClientStream owner, SafePipeHandle safePipeHandle)
public void .ctor(NamedPipeClientStream owner, string serverName, string pipeName, PipeAccessRights desiredAccessRights, PipeOptions options, HandleInheritability inheritability)
public SafePipeHandle get_Handle()
public void Connect()
public void Connect(int timeout)
public bool get_IsAsync()
public int get_NumberOfServerInstances()
}
internal System.IO.Pipes.UnixNamedPipeServer : UnixNamedPipe {
private SafePipeHandle handle
private bool should_close_handle
public SafePipeHandle Handle
public void .ctor(NamedPipeServerStream owner, SafePipeHandle safePipeHandle)
public void .ctor(NamedPipeServerStream owner, string pipeName, int maxNumberOfServerInstances, PipeTransmissionMode transmissionMode, PipeAccessRights rights, PipeOptions options, int inBufferSize, int outBufferSize, HandleInheritability inheritability)
public SafePipeHandle get_Handle()
public void Disconnect()
public void WaitForConnection()
}
internal System.IO.Pipes.Win32AnonymousPipe : object {
public SafePipeHandle Handle
public SafePipeHandle get_Handle()
public void WaitForPipeDrain()
}
internal System.IO.Pipes.Win32AnonymousPipeClient : Win32AnonymousPipe {
private SafePipeHandle handle
public SafePipeHandle Handle
public void .ctor(AnonymousPipeClientStream owner, SafePipeHandle handle)
public SafePipeHandle get_Handle()
}
internal System.IO.Pipes.Win32AnonymousPipeServer : Win32AnonymousPipe {
private SafePipeHandle server_handle
private SafePipeHandle client_handle
public SafePipeHandle Handle
public SafePipeHandle ClientHandle
public void .ctor(AnonymousPipeServerStream owner, PipeDirection direction, HandleInheritability inheritability, int bufferSize, PipeSecurity pipeSecurity)
public void .ctor(AnonymousPipeServerStream owner, SafePipeHandle serverHandle, SafePipeHandle clientHandle)
public SafePipeHandle get_Handle()
public SafePipeHandle get_ClientHandle()
public void DisposeLocalCopyOfClientHandle()
}
internal System.IO.Pipes.Win32Marshal : object {
internal bool IsWindows
internal bool get_IsWindows()
internal bool CreatePipe(IntPtr& readHandle, IntPtr& writeHandle, SecurityAttributes& pipeAtts, int size)
internal IntPtr CreateNamedPipe(string name, UInt32 openMode, int pipeMode, int maxInstances, int outBufferSize, int inBufferSize, int defaultTimeout, SecurityAttributes& securityAttributes, IntPtr atts)
internal bool ConnectNamedPipe(SafePipeHandle handle, IntPtr overlapped)
internal bool DisconnectNamedPipe(SafePipeHandle handle)
internal bool GetNamedPipeHandleState(SafePipeHandle handle, Int32& state, Int32& curInstances, Int32& maxCollectionCount, Int32& collectDateTimeout, Byte[] userName, int maxUserNameSize)
internal bool WaitNamedPipe(string name, int timeout)
internal IntPtr CreateFile(string name, PipeAccessRights desiredAccess, FileShare fileShare, SecurityAttributes& atts, int creationDisposition, int flags, IntPtr templateHandle)
}
internal System.IO.Pipes.Win32NamedPipe : object {
private string name_cache
public string Name
public SafePipeHandle Handle
public string get_Name()
public SafePipeHandle get_Handle()
public void WaitForPipeDrain()
}
internal System.IO.Pipes.Win32NamedPipeClient : Win32NamedPipe {
private NamedPipeClientStream owner
private Func`1<SafePipeHandle> opener
private bool is_async
private string name
private SafePipeHandle handle
public SafePipeHandle Handle
public bool IsAsync
public int NumberOfServerInstances
public void .ctor(NamedPipeClientStream owner, SafePipeHandle safePipeHandle)
public void .ctor(NamedPipeClientStream owner, string serverName, string pipeName, PipeAccessRights desiredAccessRights, PipeOptions options, HandleInheritability inheritability)
public SafePipeHandle get_Handle()
public bool get_IsAsync()
public void Connect()
public void Connect(int timeout)
public int get_NumberOfServerInstances()
}
internal System.IO.Pipes.Win32NamedPipeServer : Win32NamedPipe {
private SafePipeHandle handle
public SafePipeHandle Handle
public void .ctor(NamedPipeServerStream owner, SafePipeHandle safePipeHandle)
public void .ctor(NamedPipeServerStream owner, string pipeName, int maxNumberOfServerInstances, PipeTransmissionMode transmissionMode, PipeAccessRights rights, PipeOptions options, int inBufferSize, int outBufferSize, PipeSecurity pipeSecurity, HandleInheritability inheritability)
public SafePipeHandle get_Handle()
public void Disconnect()
public void WaitForConnection()
}
internal System.IO.Pipes.Win32PipeError : object {
public Exception GetException()
public Exception GetException(int errorCode)
}
internal System.Linq.AggregationMinMaxHelpers`1 : object {
private T Reduce(IEnumerable`1<T> source, int sign)
internal T ReduceMin(IEnumerable`1<T> source)
internal T ReduceMax(IEnumerable`1<T> source)
private Func`3<Pair`2<bool, T>, T, Pair`2<bool, T>> MakeIntermediateReduceFunction(int sign)
private Func`3<Pair`2<bool, T>, Pair`2<bool, T>, Pair`2<bool, T>> MakeFinalReduceFunction(int sign)
private Func`2<Pair`2<bool, T>, T> MakeResultSelectorFunction()
}
internal System.Linq.Buffer`1 : ValueType {
internal TElement[] _items
internal int _count
internal void .ctor(IEnumerable`1<TElement> source)
}
internal System.Linq.CachedReflectionInfo : object {
private MethodInfo s_Aggregate_TSource_2
private MethodInfo s_Aggregate_TSource_TAccumulate_3
private MethodInfo s_Aggregate_TSource_TAccumulate_TResult_4
private MethodInfo s_All_TSource_2
private MethodInfo s_Any_TSource_1
private MethodInfo s_Any_TSource_2
private MethodInfo s_Average_Int32_1
private MethodInfo s_Average_NullableInt32_1
private MethodInfo s_Average_Int64_1
private MethodInfo s_Average_NullableInt64_1
private MethodInfo s_Average_Single_1
private MethodInfo s_Average_NullableSingle_1
private MethodInfo s_Average_Double_1
private MethodInfo s_Average_NullableDouble_1
private MethodInfo s_Average_Decimal_1
private MethodInfo s_Average_NullableDecimal_1
private MethodInfo s_Average_Int32_TSource_2
private MethodInfo s_Average_NullableInt32_TSource_2
private MethodInfo s_Average_Single_TSource_2
private MethodInfo s_Average_NullableSingle_TSource_2
private MethodInfo s_Average_Int64_TSource_2
private MethodInfo s_Average_NullableInt64_TSource_2
private MethodInfo s_Average_Double_TSource_2
private MethodInfo s_Average_NullableDouble_TSource_2
private MethodInfo s_Average_Decimal_TSource_2
private MethodInfo s_Average_NullableDecimal_TSource_2
private MethodInfo s_Cast_TResult_1
private MethodInfo s_Concat_TSource_2
private MethodInfo s_Contains_TSource_2
private MethodInfo s_Contains_TSource_3
private MethodInfo s_Count_TSource_1
private MethodInfo s_Count_TSource_2
private MethodInfo s_DefaultIfEmpty_TSource_1
private MethodInfo s_DefaultIfEmpty_TSource_2
private MethodInfo s_Distinct_TSource_1
private MethodInfo s_Distinct_TSource_2
private MethodInfo s_ElementAt_TSource_2
private MethodInfo s_ElementAtOrDefault_TSource_2
private MethodInfo s_Except_TSource_2
private MethodInfo s_Except_TSource_3
private MethodInfo s_First_TSource_1
private MethodInfo s_First_TSource_2
private MethodInfo s_FirstOrDefault_TSource_1
private MethodInfo s_FirstOrDefault_TSource_2
private MethodInfo s_GroupBy_TSource_TKey_2
private MethodInfo s_GroupBy_TSource_TKey_3
private MethodInfo s_GroupBy_TSource_TKey_TElement_3
private MethodInfo s_GroupBy_TSource_TKey_TElement_4
private MethodInfo s_GroupBy_TSource_TKey_TResult_3
private MethodInfo s_GroupBy_TSource_TKey_TResult_4
private MethodInfo s_GroupBy_TSource_TKey_TElement_TResult_4
private MethodInfo s_GroupBy_TSource_TKey_TElement_TResult_5
private MethodInfo s_GroupJoin_TOuter_TInner_TKey_TResult_5
private MethodInfo s_GroupJoin_TOuter_TInner_TKey_TResult_6
private MethodInfo s_Intersect_TSource_2
private MethodInfo s_Intersect_TSource_3
private MethodInfo s_Join_TOuter_TInner_TKey_TResult_5
private MethodInfo s_Join_TOuter_TInner_TKey_TResult_6
private MethodInfo s_Last_TSource_1
private MethodInfo s_Last_TSource_2
private MethodInfo s_LastOrDefault_TSource_1
private MethodInfo s_LastOrDefault_TSource_2
private MethodInfo s_LongCount_TSource_1
private MethodInfo s_LongCount_TSource_2
private MethodInfo s_Max_TSource_1
private MethodInfo s_Max_TSource_TResult_2
private MethodInfo s_Min_TSource_1
private MethodInfo s_Min_TSource_TResult_2
private MethodInfo s_OfType_TResult_1
private MethodInfo s_OrderBy_TSource_TKey_2
private MethodInfo s_OrderBy_TSource_TKey_3
private MethodInfo s_OrderByDescending_TSource_TKey_2
private MethodInfo s_OrderByDescending_TSource_TKey_3
private MethodInfo s_Reverse_TSource_1
private MethodInfo s_Select_TSource_TResult_2
private MethodInfo s_Select_Index_TSource_TResult_2
private MethodInfo s_SelectMany_TSource_TResult_2
private MethodInfo s_SelectMany_Index_TSource_TResult_2
private MethodInfo s_SelectMany_Index_TSource_TCollection_TResult_3
private MethodInfo s_SelectMany_TSource_TCollection_TResult_3
private MethodInfo s_SequenceEqual_TSource_2
private MethodInfo s_SequenceEqual_TSource_3
private MethodInfo s_Single_TSource_1
private MethodInfo s_Single_TSource_2
private MethodInfo s_SingleOrDefault_TSource_1
private MethodInfo s_SingleOrDefault_TSource_2
private MethodInfo s_Skip_TSource_2
private MethodInfo s_SkipWhile_TSource_2
private MethodInfo s_SkipWhile_Index_TSource_2
private MethodInfo s_Sum_Int32_1
private MethodInfo s_Sum_NullableInt32_1
private MethodInfo s_Sum_Int64_1
private MethodInfo s_Sum_NullableInt64_1
private MethodInfo s_Sum_Single_1
private MethodInfo s_Sum_NullableSingle_1
private MethodInfo s_Sum_Double_1
private MethodInfo s_Sum_NullableDouble_1
private MethodInfo s_Sum_Decimal_1
private MethodInfo s_Sum_NullableDecimal_1
private MethodInfo s_Sum_NullableDecimal_TSource_2
private MethodInfo s_Sum_Int32_TSource_2
private MethodInfo s_Sum_NullableInt32_TSource_2
private MethodInfo s_Sum_Int64_TSource_2
private MethodInfo s_Sum_NullableInt64_TSource_2
private MethodInfo s_Sum_Single_TSource_2
private MethodInfo s_Sum_NullableSingle_TSource_2
private MethodInfo s_Sum_Double_TSource_2
private MethodInfo s_Sum_NullableDouble_TSource_2
private MethodInfo s_Sum_Decimal_TSource_2
private MethodInfo s_Take_TSource_2
private MethodInfo s_TakeWhile_TSource_2
private MethodInfo s_TakeWhile_Index_TSource_2
private MethodInfo s_ThenBy_TSource_TKey_2
private MethodInfo s_ThenBy_TSource_TKey_3
private MethodInfo s_ThenByDescending_TSource_TKey_2
private MethodInfo s_ThenByDescending_TSource_TKey_3
private MethodInfo s_Union_TSource_2
private MethodInfo s_Union_TSource_3
private MethodInfo s_Where_TSource_2
private MethodInfo s_Where_Index_TSource_2
private MethodInfo s_Zip_TFirst_TSecond_TResult_3
private MethodInfo s_SkipLast_TSource_2
private MethodInfo s_TakeLast_TSource_2
private MethodInfo s_Append_TSource_2
private MethodInfo s_Prepend_TSource_2
public MethodInfo Average_Int32_1
public MethodInfo Average_NullableInt32_1
public MethodInfo Average_Int64_1
public MethodInfo Average_NullableInt64_1
public MethodInfo Average_Single_1
public MethodInfo Average_NullableSingle_1
public MethodInfo Average_Double_1
public MethodInfo Average_NullableDouble_1
public MethodInfo Average_Decimal_1
public MethodInfo Average_NullableDecimal_1
public MethodInfo Sum_Int32_1
public MethodInfo Sum_NullableInt32_1
public MethodInfo Sum_Int64_1
public MethodInfo Sum_NullableInt64_1
public MethodInfo Sum_Single_1
public MethodInfo Sum_NullableSingle_1
public MethodInfo Sum_Double_1
public MethodInfo Sum_NullableDouble_1
public MethodInfo Sum_Decimal_1
public MethodInfo Sum_NullableDecimal_1
public MethodInfo Aggregate_TSource_2(Type TSource)
public MethodInfo Aggregate_TSource_TAccumulate_3(Type TSource, Type TAccumulate)
public MethodInfo Aggregate_TSource_TAccumulate_TResult_4(Type TSource, Type TAccumulate, Type TResult)
public MethodInfo All_TSource_2(Type TSource)
public MethodInfo Any_TSource_1(Type TSource)
public MethodInfo Any_TSource_2(Type TSource)
public MethodInfo get_Average_Int32_1()
public MethodInfo get_Average_NullableInt32_1()
public MethodInfo get_Average_Int64_1()
public MethodInfo get_Average_NullableInt64_1()
public MethodInfo get_Average_Single_1()
public MethodInfo get_Average_NullableSingle_1()
public MethodInfo get_Average_Double_1()
public MethodInfo get_Average_NullableDouble_1()
public MethodInfo get_Average_Decimal_1()
public MethodInfo get_Average_NullableDecimal_1()
public MethodInfo Average_Int32_TSource_2(Type TSource)
public MethodInfo Average_NullableInt32_TSource_2(Type TSource)
public MethodInfo Average_Single_TSource_2(Type TSource)
public MethodInfo Average_NullableSingle_TSource_2(Type TSource)
public MethodInfo Average_Int64_TSource_2(Type TSource)
public MethodInfo Average_NullableInt64_TSource_2(Type TSource)
public MethodInfo Average_Double_TSource_2(Type TSource)
public MethodInfo Average_NullableDouble_TSource_2(Type TSource)
public MethodInfo Average_Decimal_TSource_2(Type TSource)
public MethodInfo Average_NullableDecimal_TSource_2(Type TSource)
public MethodInfo Cast_TResult_1(Type TResult)
public MethodInfo Concat_TSource_2(Type TSource)
public MethodInfo Contains_TSource_2(Type TSource)
public MethodInfo Contains_TSource_3(Type TSource)
public MethodInfo Count_TSource_1(Type TSource)
public MethodInfo Count_TSource_2(Type TSource)
public MethodInfo DefaultIfEmpty_TSource_1(Type TSource)
public MethodInfo DefaultIfEmpty_TSource_2(Type TSource)
public MethodInfo Distinct_TSource_1(Type TSource)
public MethodInfo Distinct_TSource_2(Type TSource)
public MethodInfo ElementAt_TSource_2(Type TSource)
public MethodInfo ElementAtOrDefault_TSource_2(Type TSource)
public MethodInfo Except_TSource_2(Type TSource)
public MethodInfo Except_TSource_3(Type TSource)
public MethodInfo First_TSource_1(Type TSource)
public MethodInfo First_TSource_2(Type TSource)
public MethodInfo FirstOrDefault_TSource_1(Type TSource)
public MethodInfo FirstOrDefault_TSource_2(Type TSource)
public MethodInfo GroupBy_TSource_TKey_2(Type TSource, Type TKey)
public MethodInfo GroupBy_TSource_TKey_3(Type TSource, Type TKey)
public MethodInfo GroupBy_TSource_TKey_TElement_3(Type TSource, Type TKey, Type TElement)
public MethodInfo GroupBy_TSource_TKey_TElement_4(Type TSource, Type TKey, Type TElement)
public MethodInfo GroupBy_TSource_TKey_TResult_3(Type TSource, Type TKey, Type TResult)
public MethodInfo GroupBy_TSource_TKey_TResult_4(Type TSource, Type TKey, Type TResult)
public MethodInfo GroupBy_TSource_TKey_TElement_TResult_4(Type TSource, Type TKey, Type TElement, Type TResult)
public MethodInfo GroupBy_TSource_TKey_TElement_TResult_5(Type TSource, Type TKey, Type TElement, Type TResult)
public MethodInfo GroupJoin_TOuter_TInner_TKey_TResult_5(Type TOuter, Type TInner, Type TKey, Type TResult)
public MethodInfo GroupJoin_TOuter_TInner_TKey_TResult_6(Type TOuter, Type TInner, Type TKey, Type TResult)
public MethodInfo Intersect_TSource_2(Type TSource)
public MethodInfo Intersect_TSource_3(Type TSource)
public MethodInfo Join_TOuter_TInner_TKey_TResult_5(Type TOuter, Type TInner, Type TKey, Type TResult)
public MethodInfo Join_TOuter_TInner_TKey_TResult_6(Type TOuter, Type TInner, Type TKey, Type TResult)
public MethodInfo Last_TSource_1(Type TSource)
public MethodInfo Last_TSource_2(Type TSource)
public MethodInfo LastOrDefault_TSource_1(Type TSource)
public MethodInfo LastOrDefault_TSource_2(Type TSource)
public MethodInfo LongCount_TSource_1(Type TSource)
public MethodInfo LongCount_TSource_2(Type TSource)
public MethodInfo Max_TSource_1(Type TSource)
public MethodInfo Max_TSource_TResult_2(Type TSource, Type TResult)
public MethodInfo Min_TSource_1(Type TSource)
public MethodInfo Min_TSource_TResult_2(Type TSource, Type TResult)
public MethodInfo OfType_TResult_1(Type TResult)
public MethodInfo OrderBy_TSource_TKey_2(Type TSource, Type TKey)
public MethodInfo OrderBy_TSource_TKey_3(Type TSource, Type TKey)
public MethodInfo OrderByDescending_TSource_TKey_2(Type TSource, Type TKey)
public MethodInfo OrderByDescending_TSource_TKey_3(Type TSource, Type TKey)
public MethodInfo Reverse_TSource_1(Type TSource)
public MethodInfo Select_TSource_TResult_2(Type TSource, Type TResult)
public MethodInfo Select_Index_TSource_TResult_2(Type TSource, Type TResult)
public MethodInfo SelectMany_TSource_TResult_2(Type TSource, Type TResult)
public MethodInfo SelectMany_Index_TSource_TResult_2(Type TSource, Type TResult)
public MethodInfo SelectMany_Index_TSource_TCollection_TResult_3(Type TSource, Type TCollection, Type TResult)
public MethodInfo SelectMany_TSource_TCollection_TResult_3(Type TSource, Type TCollection, Type TResult)
public MethodInfo SequenceEqual_TSource_2(Type TSource)
public MethodInfo SequenceEqual_TSource_3(Type TSource)
public MethodInfo Single_TSource_1(Type TSource)
public MethodInfo Single_TSource_2(Type TSource)
public MethodInfo SingleOrDefault_TSource_1(Type TSource)
public MethodInfo SingleOrDefault_TSource_2(Type TSource)
public MethodInfo Skip_TSource_2(Type TSource)
public MethodInfo SkipWhile_TSource_2(Type TSource)
public MethodInfo SkipWhile_Index_TSource_2(Type TSource)
public MethodInfo get_Sum_Int32_1()
public MethodInfo get_Sum_NullableInt32_1()
public MethodInfo get_Sum_Int64_1()
public MethodInfo get_Sum_NullableInt64_1()
public MethodInfo get_Sum_Single_1()
public MethodInfo get_Sum_NullableSingle_1()
public MethodInfo get_Sum_Double_1()
public MethodInfo get_Sum_NullableDouble_1()
public MethodInfo get_Sum_Decimal_1()
public MethodInfo get_Sum_NullableDecimal_1()
public MethodInfo Sum_NullableDecimal_TSource_2(Type TSource)
public MethodInfo Sum_Int32_TSource_2(Type TSource)
public MethodInfo Sum_NullableInt32_TSource_2(Type TSource)
public MethodInfo Sum_Int64_TSource_2(Type TSource)
public MethodInfo Sum_NullableInt64_TSource_2(Type TSource)
public MethodInfo Sum_Single_TSource_2(Type TSource)
public MethodInfo Sum_NullableSingle_TSource_2(Type TSource)
public MethodInfo Sum_Double_TSource_2(Type TSource)
public MethodInfo Sum_NullableDouble_TSource_2(Type TSource)
public MethodInfo Sum_Decimal_TSource_2(Type TSource)
public MethodInfo Take_TSource_2(Type TSource)
public MethodInfo TakeWhile_TSource_2(Type TSource)
public MethodInfo TakeWhile_Index_TSource_2(Type TSource)
public MethodInfo ThenBy_TSource_TKey_2(Type TSource, Type TKey)
public MethodInfo ThenBy_TSource_TKey_3(Type TSource, Type TKey)
public MethodInfo ThenByDescending_TSource_TKey_2(Type TSource, Type TKey)
public MethodInfo ThenByDescending_TSource_TKey_3(Type TSource, Type TKey)
public MethodInfo Union_TSource_2(Type TSource)
public MethodInfo Union_TSource_3(Type TSource)
public MethodInfo Where_TSource_2(Type TSource)
public MethodInfo Where_Index_TSource_2(Type TSource)
public MethodInfo Zip_TFirst_TSecond_TResult_3(Type TFirst, Type TSecond, Type TResult)
public MethodInfo SkipLast_TSource_2(Type TSource)
public MethodInfo TakeLast_TSource_2(Type TSource)
public MethodInfo Append_TSource_2(Type TSource)
public MethodInfo Prepend_TSource_2(Type TSource)
}
internal System.Linq.CachingComparer`1 : object {
internal int Compare(TElement element, bool cacheLower)
internal void SetElement(TElement element)
}
internal System.Linq.CachingComparer`2 : CachingComparer`1<TElement> {
protected Func`2<TElement, TKey> _keySelector
protected IComparer`1<TKey> _comparer
protected bool _descending
protected TKey _lastKey
public void .ctor(Func`2<TElement, TKey> keySelector, IComparer`1<TKey> comparer, bool descending)
internal int Compare(TElement element, bool cacheLower)
internal void SetElement(TElement element)
}
internal System.Linq.CachingComparerWithChild`2 : CachingComparer`2<TElement, TKey> {
private CachingComparer`1<TElement> _child
public void .ctor(Func`2<TElement, TKey> keySelector, IComparer`1<TKey> comparer, bool descending, CachingComparer`1<TElement> child)
internal int Compare(TElement element, bool cacheLower)
internal void SetElement(TElement element)
}
internal System.Linq.EmptyPartition`1 : object {
public IPartition`1<TElement> Instance
public TElement Current
private object System.Collections.IEnumerator.Current
public IEnumerator`1<TElement> GetEnumerator()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
public bool MoveNext()
public TElement get_Current()
private object System.Collections.IEnumerator.get_Current()
private void System.Collections.IEnumerator.Reset()
private void System.IDisposable.Dispose()
public IPartition`1<TElement> Skip(int count)
public IPartition`1<TElement> Take(int count)
public TElement TryGetElementAt(int index, Boolean& found)
public TElement TryGetFirst(Boolean& found)
public TElement TryGetLast(Boolean& found)
public TElement[] ToArray()
public List`1<TElement> ToList()
public int GetCount(bool onlyIfCheap)
}
public System.Linq.Enumerable : object {
public TSource Aggregate(IEnumerable`1<TSource> source, Func`3<TSource, TSource, TSource> func)
public TAccumulate Aggregate(IEnumerable`1<TSource> source, TAccumulate seed, Func`3<TAccumulate, TSource, TAccumulate> func)
public TResult Aggregate(IEnumerable`1<TSource> source, TAccumulate seed, Func`3<TAccumulate, TSource, TAccumulate> func, Func`2<TAccumulate, TResult> resultSelector)
public bool Any(IEnumerable`1<TSource> source)
public bool Any(IEnumerable`1<TSource> source, Func`2<TSource, bool> predicate)
public bool All(IEnumerable`1<TSource> source, Func`2<TSource, bool> predicate)
public IEnumerable`1<TSource> Append(IEnumerable`1<TSource> source, TSource element)
public IEnumerable`1<TSource> Prepend(IEnumerable`1<TSource> source, TSource element)
public double Average(IEnumerable`1<int> source)
public Nullable`1<double> Average(IEnumerable`1<Nullable`1<int>> source)
public double Average(IEnumerable`1<long> source)
public Nullable`1<double> Average(IEnumerable`1<Nullable`1<long>> source)
public float Average(IEnumerable`1<float> source)
public Nullable`1<float> Average(IEnumerable`1<Nullable`1<float>> source)
public double Average(IEnumerable`1<double> source)
public Nullable`1<double> Average(IEnumerable`1<Nullable`1<double>> source)
public decimal Average(IEnumerable`1<decimal> source)
public Nullable`1<decimal> Average(IEnumerable`1<Nullable`1<decimal>> source)
public double Average(IEnumerable`1<TSource> source, Func`2<TSource, int> selector)
public Nullable`1<double> Average(IEnumerable`1<TSource> source, Func`2<TSource, Nullable`1<int>> selector)
public double Average(IEnumerable`1<TSource> source, Func`2<TSource, long> selector)
public Nullable`1<double> Average(IEnumerable`1<TSource> source, Func`2<TSource, Nullable`1<long>> selector)
public float Average(IEnumerable`1<TSource> source, Func`2<TSource, float> selector)
public Nullable`1<float> Average(IEnumerable`1<TSource> source, Func`2<TSource, Nullable`1<float>> selector)
public double Average(IEnumerable`1<TSource> source, Func`2<TSource, double> selector)
public Nullable`1<double> Average(IEnumerable`1<TSource> source, Func`2<TSource, Nullable`1<double>> selector)
public decimal Average(IEnumerable`1<TSource> source, Func`2<TSource, decimal> selector)
public Nullable`1<decimal> Average(IEnumerable`1<TSource> source, Func`2<TSource, Nullable`1<decimal>> selector)
public IEnumerable`1<TResult> OfType(IEnumerable source)
private IEnumerable`1<TResult> OfTypeIterator(IEnumerable source)
public IEnumerable`1<TResult> Cast(IEnumerable source)
private IEnumerable`1<TResult> CastIterator(IEnumerable source)
public IEnumerable`1<TSource> Concat(IEnumerable`1<TSource> first, IEnumerable`1<TSource> second)
public bool Contains(IEnumerable`1<TSource> source, TSource value)
public bool Contains(IEnumerable`1<TSource> source, TSource value, IEqualityComparer`1<TSource> comparer)
public int Count(IEnumerable`1<TSource> source)
public int Count(IEnumerable`1<TSource> source, Func`2<TSource, bool> predicate)
public long LongCount(IEnumerable`1<TSource> source)
public long LongCount(IEnumerable`1<TSource> source, Func`2<TSource, bool> predicate)
public IEnumerable`1<TSource> DefaultIfEmpty(IEnumerable`1<TSource> source)
public IEnumerable`1<TSource> DefaultIfEmpty(IEnumerable`1<TSource> source, TSource defaultValue)
public IEnumerable`1<TSource> Distinct(IEnumerable`1<TSource> source)
public IEnumerable`1<TSource> Distinct(IEnumerable`1<TSource> source, IEqualityComparer`1<TSource> comparer)
public TSource ElementAt(IEnumerable`1<TSource> source, int index)
public TSource ElementAtOrDefault(IEnumerable`1<TSource> source, int index)
public IEnumerable`1<TSource> AsEnumerable(IEnumerable`1<TSource> source)
public IEnumerable`1<TResult> Empty()
public IEnumerable`1<TSource> Except(IEnumerable`1<TSource> first, IEnumerable`1<TSource> second)
public IEnumerable`1<TSource> Except(IEnumerable`1<TSource> first, IEnumerable`1<TSource> second, IEqualityComparer`1<TSource> comparer)
private IEnumerable`1<TSource> ExceptIterator(IEnumerable`1<TSource> first, IEnumerable`1<TSource> second, IEqualityComparer`1<TSource> comparer)
public TSource First(IEnumerable`1<TSource> source)
public TSource First(IEnumerable`1<TSource> source, Func`2<TSource, bool> predicate)
public TSource FirstOrDefault(IEnumerable`1<TSource> source)
public TSource FirstOrDefault(IEnumerable`1<TSource> source, Func`2<TSource, bool> predicate)
private TSource TryGetFirst(IEnumerable`1<TSource> source, Boolean& found)
private TSource TryGetFirst(IEnumerable`1<TSource> source, Func`2<TSource, bool> predicate, Boolean& found)
public IEnumerable`1<TResult> GroupJoin(IEnumerable`1<TOuter> outer, IEnumerable`1<TInner> inner, Func`2<TOuter, TKey> outerKeySelector, Func`2<TInner, TKey> innerKeySelector, Func`3<TOuter, IEnumerable`1<TInner>, TResult> resultSelector)
public IEnumerable`1<TResult> GroupJoin(IEnumerable`1<TOuter> outer, IEnumerable`1<TInner> inner, Func`2<TOuter, TKey> outerKeySelector, Func`2<TInner, TKey> innerKeySelector, Func`3<TOuter, IEnumerable`1<TInner>, TResult> resultSelector, IEqualityComparer`1<TKey> comparer)
private IEnumerable`1<TResult> GroupJoinIterator(IEnumerable`1<TOuter> outer, IEnumerable`1<TInner> inner, Func`2<TOuter, TKey> outerKeySelector, Func`2<TInner, TKey> innerKeySelector, Func`3<TOuter, IEnumerable`1<TInner>, TResult> resultSelector, IEqualityComparer`1<TKey> comparer)
public IEnumerable`1<IGrouping`2<TKey, TSource>> GroupBy(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector)
public IEnumerable`1<IGrouping`2<TKey, TSource>> GroupBy(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, IEqualityComparer`1<TKey> comparer)
public IEnumerable`1<IGrouping`2<TKey, TElement>> GroupBy(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`2<TSource, TElement> elementSelector)
public IEnumerable`1<IGrouping`2<TKey, TElement>> GroupBy(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`2<TSource, TElement> elementSelector, IEqualityComparer`1<TKey> comparer)
public IEnumerable`1<TResult> GroupBy(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`3<TKey, IEnumerable`1<TSource>, TResult> resultSelector)
public IEnumerable`1<TResult> GroupBy(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`2<TSource, TElement> elementSelector, Func`3<TKey, IEnumerable`1<TElement>, TResult> resultSelector)
public IEnumerable`1<TResult> GroupBy(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`3<TKey, IEnumerable`1<TSource>, TResult> resultSelector, IEqualityComparer`1<TKey> comparer)
public IEnumerable`1<TResult> GroupBy(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`2<TSource, TElement> elementSelector, Func`3<TKey, IEnumerable`1<TElement>, TResult> resultSelector, IEqualityComparer`1<TKey> comparer)
public IEnumerable`1<TSource> Intersect(IEnumerable`1<TSource> first, IEnumerable`1<TSource> second)
public IEnumerable`1<TSource> Intersect(IEnumerable`1<TSource> first, IEnumerable`1<TSource> second, IEqualityComparer`1<TSource> comparer)
private IEnumerable`1<TSource> IntersectIterator(IEnumerable`1<TSource> first, IEnumerable`1<TSource> second, IEqualityComparer`1<TSource> comparer)
public IEnumerable`1<TResult> Join(IEnumerable`1<TOuter> outer, IEnumerable`1<TInner> inner, Func`2<TOuter, TKey> outerKeySelector, Func`2<TInner, TKey> innerKeySelector, Func`3<TOuter, TInner, TResult> resultSelector)
public IEnumerable`1<TResult> Join(IEnumerable`1<TOuter> outer, IEnumerable`1<TInner> inner, Func`2<TOuter, TKey> outerKeySelector, Func`2<TInner, TKey> innerKeySelector, Func`3<TOuter, TInner, TResult> resultSelector, IEqualityComparer`1<TKey> comparer)
private IEnumerable`1<TResult> JoinIterator(IEnumerable`1<TOuter> outer, IEnumerable`1<TInner> inner, Func`2<TOuter, TKey> outerKeySelector, Func`2<TInner, TKey> innerKeySelector, Func`3<TOuter, TInner, TResult> resultSelector, IEqualityComparer`1<TKey> comparer)
public TSource Last(IEnumerable`1<TSource> source)
public TSource Last(IEnumerable`1<TSource> source, Func`2<TSource, bool> predicate)
public TSource LastOrDefault(IEnumerable`1<TSource> source)
public TSource LastOrDefault(IEnumerable`1<TSource> source, Func`2<TSource, bool> predicate)
private TSource TryGetLast(IEnumerable`1<TSource> source, Boolean& found)
private TSource TryGetLast(IEnumerable`1<TSource> source, Func`2<TSource, bool> predicate, Boolean& found)
public ILookup`2<TKey, TSource> ToLookup(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector)
public ILookup`2<TKey, TSource> ToLookup(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, IEqualityComparer`1<TKey> comparer)
public ILookup`2<TKey, TElement> ToLookup(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`2<TSource, TElement> elementSelector)
public ILookup`2<TKey, TElement> ToLookup(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`2<TSource, TElement> elementSelector, IEqualityComparer`1<TKey> comparer)
public int Max(IEnumerable`1<int> source)
public Nullable`1<int> Max(IEnumerable`1<Nullable`1<int>> source)
public long Max(IEnumerable`1<long> source)
public Nullable`1<long> Max(IEnumerable`1<Nullable`1<long>> source)
public double Max(IEnumerable`1<double> source)
public Nullable`1<double> Max(IEnumerable`1<Nullable`1<double>> source)
public float Max(IEnumerable`1<float> source)
public Nullable`1<float> Max(IEnumerable`1<Nullable`1<float>> source)
public decimal Max(IEnumerable`1<decimal> source)
public Nullable`1<decimal> Max(IEnumerable`1<Nullable`1<decimal>> source)
public TSource Max(IEnumerable`1<TSource> source)
public int Max(IEnumerable`1<TSource> source, Func`2<TSource, int> selector)
public Nullable`1<int> Max(IEnumerable`1<TSource> source, Func`2<TSource, Nullable`1<int>> selector)
public long Max(IEnumerable`1<TSource> source, Func`2<TSource, long> selector)
public Nullable`1<long> Max(IEnumerable`1<TSource> source, Func`2<TSource, Nullable`1<long>> selector)
public float Max(IEnumerable`1<TSource> source, Func`2<TSource, float> selector)
public Nullable`1<float> Max(IEnumerable`1<TSource> source, Func`2<TSource, Nullable`1<float>> selector)
public double Max(IEnumerable`1<TSource> source, Func`2<TSource, double> selector)
public Nullable`1<double> Max(IEnumerable`1<TSource> source, Func`2<TSource, Nullable`1<double>> selector)
public decimal Max(IEnumerable`1<TSource> source, Func`2<TSource, decimal> selector)
public Nullable`1<decimal> Max(IEnumerable`1<TSource> source, Func`2<TSource, Nullable`1<decimal>> selector)
public TResult Max(IEnumerable`1<TSource> source, Func`2<TSource, TResult> selector)
public int Min(IEnumerable`1<int> source)
public Nullable`1<int> Min(IEnumerable`1<Nullable`1<int>> source)
public long Min(IEnumerable`1<long> source)
public Nullable`1<long> Min(IEnumerable`1<Nullable`1<long>> source)
public float Min(IEnumerable`1<float> source)
public Nullable`1<float> Min(IEnumerable`1<Nullable`1<float>> source)
public double Min(IEnumerable`1<double> source)
public Nullable`1<double> Min(IEnumerable`1<Nullable`1<double>> source)
public decimal Min(IEnumerable`1<decimal> source)
public Nullable`1<decimal> Min(IEnumerable`1<Nullable`1<decimal>> source)
public TSource Min(IEnumerable`1<TSource> source)
public int Min(IEnumerable`1<TSource> source, Func`2<TSource, int> selector)
public Nullable`1<int> Min(IEnumerable`1<TSource> source, Func`2<TSource, Nullable`1<int>> selector)
public long Min(IEnumerable`1<TSource> source, Func`2<TSource, long> selector)
public Nullable`1<long> Min(IEnumerable`1<TSource> source, Func`2<TSource, Nullable`1<long>> selector)
public float Min(IEnumerable`1<TSource> source, Func`2<TSource, float> selector)
public Nullable`1<float> Min(IEnumerable`1<TSource> source, Func`2<TSource, Nullable`1<float>> selector)
public double Min(IEnumerable`1<TSource> source, Func`2<TSource, double> selector)
public Nullable`1<double> Min(IEnumerable`1<TSource> source, Func`2<TSource, Nullable`1<double>> selector)
public decimal Min(IEnumerable`1<TSource> source, Func`2<TSource, decimal> selector)
public Nullable`1<decimal> Min(IEnumerable`1<TSource> source, Func`2<TSource, Nullable`1<decimal>> selector)
public TResult Min(IEnumerable`1<TSource> source, Func`2<TSource, TResult> selector)
public IOrderedEnumerable`1<TSource> OrderBy(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector)
public IOrderedEnumerable`1<TSource> OrderBy(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> comparer)
public IOrderedEnumerable`1<TSource> OrderByDescending(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector)
public IOrderedEnumerable`1<TSource> OrderByDescending(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> comparer)
public IOrderedEnumerable`1<TSource> ThenBy(IOrderedEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector)
public IOrderedEnumerable`1<TSource> ThenBy(IOrderedEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> comparer)
public IOrderedEnumerable`1<TSource> ThenByDescending(IOrderedEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector)
public IOrderedEnumerable`1<TSource> ThenByDescending(IOrderedEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> comparer)
public IEnumerable`1<int> Range(int start, int count)
public IEnumerable`1<TResult> Repeat(TResult element, int count)
public IEnumerable`1<TSource> Reverse(IEnumerable`1<TSource> source)
public IEnumerable`1<TResult> Select(IEnumerable`1<TSource> source, Func`2<TSource, TResult> selector)
public IEnumerable`1<TResult> Select(IEnumerable`1<TSource> source, Func`3<TSource, int, TResult> selector)
private IEnumerable`1<TResult> SelectIterator(IEnumerable`1<TSource> source, Func`3<TSource, int, TResult> selector)
public IEnumerable`1<TResult> SelectMany(IEnumerable`1<TSource> source, Func`2<TSource, IEnumerable`1<TResult>> selector)
public IEnumerable`1<TResult> SelectMany(IEnumerable`1<TSource> source, Func`3<TSource, int, IEnumerable`1<TResult>> selector)
private IEnumerable`1<TResult> SelectManyIterator(IEnumerable`1<TSource> source, Func`3<TSource, int, IEnumerable`1<TResult>> selector)
public IEnumerable`1<TResult> SelectMany(IEnumerable`1<TSource> source, Func`3<TSource, int, IEnumerable`1<TCollection>> collectionSelector, Func`3<TSource, TCollection, TResult> resultSelector)
private IEnumerable`1<TResult> SelectManyIterator(IEnumerable`1<TSource> source, Func`3<TSource, int, IEnumerable`1<TCollection>> collectionSelector, Func`3<TSource, TCollection, TResult> resultSelector)
public IEnumerable`1<TResult> SelectMany(IEnumerable`1<TSource> source, Func`2<TSource, IEnumerable`1<TCollection>> collectionSelector, Func`3<TSource, TCollection, TResult> resultSelector)
private IEnumerable`1<TResult> SelectManyIterator(IEnumerable`1<TSource> source, Func`2<TSource, IEnumerable`1<TCollection>> collectionSelector, Func`3<TSource, TCollection, TResult> resultSelector)
public bool SequenceEqual(IEnumerable`1<TSource> first, IEnumerable`1<TSource> second)
public bool SequenceEqual(IEnumerable`1<TSource> first, IEnumerable`1<TSource> second, IEqualityComparer`1<TSource> comparer)
public TSource Single(IEnumerable`1<TSource> source)
public TSource Single(IEnumerable`1<TSource> source, Func`2<TSource, bool> predicate)
public TSource SingleOrDefault(IEnumerable`1<TSource> source)
public TSource SingleOrDefault(IEnumerable`1<TSource> source, Func`2<TSource, bool> predicate)
public IEnumerable`1<TSource> Skip(IEnumerable`1<TSource> source, int count)
public IEnumerable`1<TSource> SkipWhile(IEnumerable`1<TSource> source, Func`2<TSource, bool> predicate)
private IEnumerable`1<TSource> SkipWhileIterator(IEnumerable`1<TSource> source, Func`2<TSource, bool> predicate)
public IEnumerable`1<TSource> SkipWhile(IEnumerable`1<TSource> source, Func`3<TSource, int, bool> predicate)
private IEnumerable`1<TSource> SkipWhileIterator(IEnumerable`1<TSource> source, Func`3<TSource, int, bool> predicate)
public IEnumerable`1<TSource> SkipLast(IEnumerable`1<TSource> source, int count)
private IEnumerable`1<TSource> SkipLastIterator(IEnumerable`1<TSource> source, int count)
public int Sum(IEnumerable`1<int> source)
public Nullable`1<int> Sum(IEnumerable`1<Nullable`1<int>> source)
public long Sum(IEnumerable`1<long> source)
public Nullable`1<long> Sum(IEnumerable`1<Nullable`1<long>> source)
public float Sum(IEnumerable`1<float> source)
public Nullable`1<float> Sum(IEnumerable`1<Nullable`1<float>> source)
public double Sum(IEnumerable`1<double> source)
public Nullable`1<double> Sum(IEnumerable`1<Nullable`1<double>> source)
public decimal Sum(IEnumerable`1<decimal> source)
public Nullable`1<decimal> Sum(IEnumerable`1<Nullable`1<decimal>> source)
public int Sum(IEnumerable`1<TSource> source, Func`2<TSource, int> selector)
public Nullable`1<int> Sum(IEnumerable`1<TSource> source, Func`2<TSource, Nullable`1<int>> selector)
public long Sum(IEnumerable`1<TSource> source, Func`2<TSource, long> selector)
public Nullable`1<long> Sum(IEnumerable`1<TSource> source, Func`2<TSource, Nullable`1<long>> selector)
public float Sum(IEnumerable`1<TSource> source, Func`2<TSource, float> selector)
public Nullable`1<float> Sum(IEnumerable`1<TSource> source, Func`2<TSource, Nullable`1<float>> selector)
public double Sum(IEnumerable`1<TSource> source, Func`2<TSource, double> selector)
public Nullable`1<double> Sum(IEnumerable`1<TSource> source, Func`2<TSource, Nullable`1<double>> selector)
public decimal Sum(IEnumerable`1<TSource> source, Func`2<TSource, decimal> selector)
public Nullable`1<decimal> Sum(IEnumerable`1<TSource> source, Func`2<TSource, Nullable`1<decimal>> selector)
public IEnumerable`1<TSource> Take(IEnumerable`1<TSource> source, int count)
public IEnumerable`1<TSource> TakeWhile(IEnumerable`1<TSource> source, Func`2<TSource, bool> predicate)
private IEnumerable`1<TSource> TakeWhileIterator(IEnumerable`1<TSource> source, Func`2<TSource, bool> predicate)
public IEnumerable`1<TSource> TakeWhile(IEnumerable`1<TSource> source, Func`3<TSource, int, bool> predicate)
private IEnumerable`1<TSource> TakeWhileIterator(IEnumerable`1<TSource> source, Func`3<TSource, int, bool> predicate)
public IEnumerable`1<TSource> TakeLast(IEnumerable`1<TSource> source, int count)
private IEnumerable`1<TSource> TakeLastIterator(IEnumerable`1<TSource> source, int count)
public TSource[] ToArray(IEnumerable`1<TSource> source)
public List`1<TSource> ToList(IEnumerable`1<TSource> source)
public Dictionary`2<TKey, TSource> ToDictionary(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector)
public Dictionary`2<TKey, TSource> ToDictionary(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, IEqualityComparer`1<TKey> comparer)
private Dictionary`2<TKey, TSource> ToDictionary(TSource[] source, Func`2<TSource, TKey> keySelector, IEqualityComparer`1<TKey> comparer)
private Dictionary`2<TKey, TSource> ToDictionary(List`1<TSource> source, Func`2<TSource, TKey> keySelector, IEqualityComparer`1<TKey> comparer)
public Dictionary`2<TKey, TElement> ToDictionary(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`2<TSource, TElement> elementSelector)
public Dictionary`2<TKey, TElement> ToDictionary(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`2<TSource, TElement> elementSelector, IEqualityComparer`1<TKey> comparer)
private Dictionary`2<TKey, TElement> ToDictionary(TSource[] source, Func`2<TSource, TKey> keySelector, Func`2<TSource, TElement> elementSelector, IEqualityComparer`1<TKey> comparer)
private Dictionary`2<TKey, TElement> ToDictionary(List`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`2<TSource, TElement> elementSelector, IEqualityComparer`1<TKey> comparer)
public HashSet`1<TSource> ToHashSet(IEnumerable`1<TSource> source)
public HashSet`1<TSource> ToHashSet(IEnumerable`1<TSource> source, IEqualityComparer`1<TSource> comparer)
public IEnumerable`1<TSource> Union(IEnumerable`1<TSource> first, IEnumerable`1<TSource> second)
public IEnumerable`1<TSource> Union(IEnumerable`1<TSource> first, IEnumerable`1<TSource> second, IEqualityComparer`1<TSource> comparer)
public IEnumerable`1<TSource> Where(IEnumerable`1<TSource> source, Func`2<TSource, bool> predicate)
public IEnumerable`1<TSource> Where(IEnumerable`1<TSource> source, Func`3<TSource, int, bool> predicate)
private IEnumerable`1<TSource> WhereIterator(IEnumerable`1<TSource> source, Func`3<TSource, int, bool> predicate)
public IEnumerable`1<TResult> Zip(IEnumerable`1<TFirst> first, IEnumerable`1<TSecond> second, Func`3<TFirst, TSecond, TResult> resultSelector)
private IEnumerable`1<TResult> ZipIterator(IEnumerable`1<TFirst> first, IEnumerable`1<TSecond> second, Func`3<TFirst, TSecond, TResult> resultSelector)
}
public System.Linq.EnumerableExecutor : object {
internal object ExecuteBoxed()
internal EnumerableExecutor Create(Expression expression)
}
public System.Linq.EnumerableExecutor`1 : EnumerableExecutor {
private Expression _expression
public void .ctor(Expression expression)
internal object ExecuteBoxed()
internal T Execute()
}
public System.Linq.EnumerableQuery : object {
internal Expression Expression
internal IEnumerable Enumerable
internal Expression get_Expression()
internal IEnumerable get_Enumerable()
internal IQueryable Create(Type elementType, IEnumerable sequence)
internal IQueryable Create(Type elementType, Expression expression)
}
public System.Linq.EnumerableQuery`1 : EnumerableQuery {
private Expression _expression
private IEnumerable`1<T> _enumerable
private IQueryProvider System.Linq.IQueryable.Provider
internal Expression Expression
internal IEnumerable Enumerable
private Expression System.Linq.IQueryable.Expression
private Type System.Linq.IQueryable.ElementType
private IQueryProvider System.Linq.IQueryable.get_Provider()
public void .ctor(IEnumerable`1<T> enumerable)
public void .ctor(Expression expression)
internal Expression get_Expression()
internal IEnumerable get_Enumerable()
private Expression System.Linq.IQueryable.get_Expression()
private Type System.Linq.IQueryable.get_ElementType()
private IQueryable System.Linq.IQueryProvider.CreateQuery(Expression expression)
private IQueryable`1<TElement> System.Linq.IQueryProvider.CreateQuery(Expression expression)
private object System.Linq.IQueryProvider.Execute(Expression expression)
private TElement System.Linq.IQueryProvider.Execute(Expression expression)
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
private IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator()
private IEnumerator`1<T> GetEnumerator()
public string ToString()
}
internal System.Linq.EnumerableRewriter : ExpressionVisitor {
private Dictionary`2<LabelTarget, LabelTarget> _targetCache
private Dictionary`2<Type, Type> _equivalentTypeCache
private ILookup`2<string, MethodInfo> s_seqMethods
protected internal Expression VisitMethodCall(MethodCallExpression m)
private ReadOnlyCollection`1<Expression> FixupQuotedArgs(MethodInfo mi, ReadOnlyCollection`1<Expression> argList)
private Expression FixupQuotedExpression(Type type, Expression expression)
protected internal Expression VisitLambda(Expression`1<T> node)
private Type GetPublicType(Type t)
private Type GetEquivalentType(Type type)
protected internal Expression VisitConstant(ConstantExpression c)
private MethodInfo FindEnumerableMethod(string name, ReadOnlyCollection`1<Expression> args, Type[] typeArgs)
private MethodInfo FindMethod(Type type, string name, ReadOnlyCollection`1<Expression> args, Type[] typeArgs)
private bool ArgsMatch(MethodInfo m, ReadOnlyCollection`1<Expression> args, Type[] typeArgs)
private Type StripExpression(Type type)
protected internal Expression VisitConditional(ConditionalExpression c)
protected internal Expression VisitBlock(BlockExpression node)
protected internal Expression VisitGoto(GotoExpression node)
protected LabelTarget VisitLabelTarget(LabelTarget node)
}
internal System.Linq.EnumerableSorter`1 : object {
internal void ComputeKeys(TElement[] elements, int count)
internal int CompareAnyKeys(int index1, int index2)
private Int32[] ComputeMap(TElement[] elements, int count)
internal Int32[] Sort(TElement[] elements, int count)
internal Int32[] Sort(TElement[] elements, int count, int minIdx, int maxIdx)
internal TElement ElementAt(TElement[] elements, int count, int idx)
protected void QuickSort(Int32[] map, int left, int right)
protected void PartialQuickSort(Int32[] map, int left, int right, int minIdx, int maxIdx)
protected int QuickSelect(Int32[] map, int right, int idx)
}
internal System.Linq.EnumerableSorter`2 : EnumerableSorter`1<TElement> {
private Func`2<TElement, TKey> _keySelector
private IComparer`1<TKey> _comparer
private bool _descending
private EnumerableSorter`1<TElement> _next
private TKey[] _keys
internal void .ctor(Func`2<TElement, TKey> keySelector, IComparer`1<TKey> comparer, bool descending, EnumerableSorter`1<TElement> next)
internal void ComputeKeys(TElement[] elements, int count)
internal int CompareAnyKeys(int index1, int index2)
private int CompareKeys(int index1, int index2)
protected void QuickSort(Int32[] keys, int lo, int hi)
protected void PartialQuickSort(Int32[] map, int left, int right, int minIdx, int maxIdx)
protected int QuickSelect(Int32[] map, int right, int idx)
}
internal System.Linq.Error : object {
internal Exception ArgumentNotIEnumerableGeneric(string message)
internal Exception ArgumentNotValid(string message)
internal Exception NoMethodOnType(string name, object type)
internal Exception NoMethodOnTypeMatchingArguments(string name, object type)
internal Exception EnumeratingNullEnumerableExpression()
internal Exception ArgumentNull(string s)
internal Exception ArgumentOutOfRange(string s)
internal Exception MoreThanOneElement()
internal Exception MoreThanOneMatch()
internal Exception NoElements()
internal Exception NoMatch()
internal Exception NotSupported()
}
internal System.Linq.Expressions.AnalyzeTypeIsResult : Enum {
public int value__
public AnalyzeTypeIsResult KnownFalse
public AnalyzeTypeIsResult KnownTrue
public AnalyzeTypeIsResult KnownAssignable
public AnalyzeTypeIsResult Unknown
}
internal System.Linq.Expressions.ArrayBuilderExtensions : object {
public ReadOnlyCollection`1<T> ToReadOnly(ArrayBuilder`1<T> builder)
}
internal System.Linq.Expressions.AssignBinaryExpression : BinaryExpression {
internal bool IsByRef
public Type Type
public ExpressionType NodeType
internal void .ctor(Expression left, Expression right)
public AssignBinaryExpression Make(Expression left, Expression right, bool byRef)
internal bool get_IsByRef()
public Type get_Type()
public ExpressionType get_NodeType()
}
public System.Linq.Expressions.BinaryExpression : Expression {
private Expression <Right>k__BackingField
private Expression <Left>k__BackingField
public bool CanReduce
public Expression Right
public Expression Left
public MethodInfo Method
public LambdaExpression Conversion
public bool IsLifted
public bool IsLiftedToNull
internal bool IsLiftedLogical
internal bool IsReferenceComparison
internal void .ctor(Expression left, Expression right)
public bool get_CanReduce()
private bool IsOpAssignment(ExpressionType op)
public Expression get_Right()
public Expression get_Left()
public MethodInfo get_Method()
internal MethodInfo GetMethod()
public BinaryExpression Update(Expression left, LambdaExpression conversion, Expression right)
public Expression Reduce()
private ExpressionType GetBinaryOpFromAssignmentOp(ExpressionType op)
private Expression ReduceVariable()
private Expression ReduceMember()
private Expression ReduceIndex()
public LambdaExpression get_Conversion()
internal LambdaExpression GetConversion()
public bool get_IsLifted()
public bool get_IsLiftedToNull()
protected internal Expression Accept(ExpressionVisitor visitor)
internal BinaryExpression Create(ExpressionType nodeType, Expression left, Expression right, Type type, MethodInfo method, LambdaExpression conversion)
internal bool get_IsLiftedLogical()
internal bool get_IsReferenceComparison()
internal Expression ReduceUserdefinedLifted()
}
internal System.Linq.Expressions.Block2 : BlockExpression {
private object _arg0
private Expression _arg1
internal int ExpressionCount
internal void .ctor(Expression arg0, Expression arg1)
internal Expression GetExpression(int index)
internal bool SameExpressions(ICollection`1<Expression> expressions)
internal int get_ExpressionCount()
internal ReadOnlyCollection`1<Expression> GetOrMakeExpressions()
internal BlockExpression Rewrite(ReadOnlyCollection`1<ParameterExpression> variables, Expression[] args)
}
internal System.Linq.Expressions.Block3 : BlockExpression {
private object _arg0
private Expression _arg1
private Expression _arg2
internal int ExpressionCount
internal void .ctor(Expression arg0, Expression arg1, Expression arg2)
internal bool SameExpressions(ICollection`1<Expression> expressions)
internal Expression GetExpression(int index)
internal int get_ExpressionCount()
internal ReadOnlyCollection`1<Expression> GetOrMakeExpressions()
internal BlockExpression Rewrite(ReadOnlyCollection`1<ParameterExpression> variables, Expression[] args)
}
internal System.Linq.Expressions.Block4 : BlockExpression {
private object _arg0
private Expression _arg1
private Expression _arg2
private Expression _arg3
internal int ExpressionCount
internal void .ctor(Expression arg0, Expression arg1, Expression arg2, Expression arg3)
internal bool SameExpressions(ICollection`1<Expression> expressions)
internal Expression GetExpression(int index)
internal int get_ExpressionCount()
internal ReadOnlyCollection`1<Expression> GetOrMakeExpressions()
internal BlockExpression Rewrite(ReadOnlyCollection`1<ParameterExpression> variables, Expression[] args)
}
internal System.Linq.Expressions.Block5 : BlockExpression {
private object _arg0
private Expression _arg1
private Expression _arg2
private Expression _arg3
private Expression _arg4
internal int ExpressionCount
internal void .ctor(Expression arg0, Expression arg1, Expression arg2, Expression arg3, Expression arg4)
internal Expression GetExpression(int index)
internal bool SameExpressions(ICollection`1<Expression> expressions)
internal int get_ExpressionCount()
internal ReadOnlyCollection`1<Expression> GetOrMakeExpressions()
internal BlockExpression Rewrite(ReadOnlyCollection`1<ParameterExpression> variables, Expression[] args)
}
public System.Linq.Expressions.BlockExpression : Expression {
public ReadOnlyCollection`1<Expression> Expressions
public ReadOnlyCollection`1<ParameterExpression> Variables
public Expression Result
public ExpressionType NodeType
public Type Type
internal int ExpressionCount
public ReadOnlyCollection`1<Expression> get_Expressions()
public ReadOnlyCollection`1<ParameterExpression> get_Variables()
public Expression get_Result()
protected internal Expression Accept(ExpressionVisitor visitor)
public ExpressionType get_NodeType()
public Type get_Type()
public BlockExpression Update(IEnumerable`1<ParameterExpression> variables, IEnumerable`1<Expression> expressions)
internal bool SameVariables(ICollection`1<ParameterExpression> variables)
internal bool SameExpressions(ICollection`1<Expression> expressions)
internal Expression GetExpression(int index)
internal int get_ExpressionCount()
internal ReadOnlyCollection`1<Expression> GetOrMakeExpressions()
internal ReadOnlyCollection`1<ParameterExpression> GetOrMakeVariables()
internal BlockExpression Rewrite(ReadOnlyCollection`1<ParameterExpression> variables, Expression[] args)
internal ReadOnlyCollection`1<Expression> ReturnReadOnlyExpressions(BlockExpression provider, Object& collection)
}
internal System.Linq.Expressions.BlockExpressionList : object {
private BlockExpression _block
private Expression _arg0
public Expression Item
public int Count
public bool IsReadOnly
internal void .ctor(BlockExpression provider, Expression arg0)
public int IndexOf(Expression item)
public void Insert(int index, Expression item)
public void RemoveAt(int index)
public Expression get_Item(int index)
public void set_Item(int index, Expression value)
public void Add(Expression item)
public void Clear()
public bool Contains(Expression item)
public void CopyTo(Expression[] array, int index)
public int get_Count()
public bool get_IsReadOnly()
public bool Remove(Expression item)
public IEnumerator`1<Expression> GetEnumerator()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
}
internal System.Linq.Expressions.BlockN : BlockExpression {
private IReadOnlyList`1<Expression> _expressions
internal int ExpressionCount
internal void .ctor(IReadOnlyList`1<Expression> expressions)
internal bool SameExpressions(ICollection`1<Expression> expressions)
internal Expression GetExpression(int index)
internal int get_ExpressionCount()
internal ReadOnlyCollection`1<Expression> GetOrMakeExpressions()
internal BlockExpression Rewrite(ReadOnlyCollection`1<ParameterExpression> variables, Expression[] args)
}
internal System.Linq.Expressions.ByRefAssignBinaryExpression : AssignBinaryExpression {
internal bool IsByRef
internal void .ctor(Expression left, Expression right)
internal bool get_IsByRef()
}
internal System.Linq.Expressions.ByRefParameterExpression : TypedParameterExpression {
internal void .ctor(Type type, string name)
internal bool GetIsByRef()
}
internal System.Linq.Expressions.CachedReflectionInfo : object {
private MethodInfo s_String_Format_String_ObjectArray
private ConstructorInfo s_InvalidCastException_Ctor_String
private MethodInfo s_CallSiteOps_SetNotMatched
private MethodInfo s_CallSiteOps_CreateMatchmaker
private MethodInfo s_CallSiteOps_GetMatch
private MethodInfo s_CallSiteOps_ClearMatch
private MethodInfo s_CallSiteOps_UpdateRules
private MethodInfo s_CallSiteOps_GetRules
private MethodInfo s_CallSiteOps_GetRuleCache
private MethodInfo s_CallSiteOps_GetCachedRules
private MethodInfo s_CallSiteOps_AddRule
private MethodInfo s_CallSiteOps_MoveRule
private MethodInfo s_CallSiteOps_Bind
private MethodInfo s_DynamicObject_TryGetMember
private MethodInfo s_DynamicObject_TrySetMember
private MethodInfo s_DynamicObject_TryDeleteMember
private MethodInfo s_DynamicObject_TryGetIndex
private MethodInfo s_DynamicObject_TrySetIndex
private MethodInfo s_DynamicObject_TryDeleteIndex
private MethodInfo s_DynamicObject_TryConvert
private MethodInfo s_DynamicObject_TryInvoke
private MethodInfo s_DynamicObject_TryInvokeMember
private MethodInfo s_DynamicObject_TryBinaryOperation
private MethodInfo s_DynamicObject_TryUnaryOperation
private MethodInfo s_DynamicObject_TryCreateInstance
private ConstructorInfo s_Nullable_Boolean_Ctor
private ConstructorInfo s_Decimal_Ctor_Int32
private ConstructorInfo s_Decimal_Ctor_UInt32
private ConstructorInfo s_Decimal_Ctor_Int64
private ConstructorInfo s_Decimal_Ctor_UInt64
private ConstructorInfo s_Decimal_Ctor_Int32_Int32_Int32_Bool_Byte
private FieldInfo s_Decimal_One
private FieldInfo s_Decimal_MinusOne
private FieldInfo s_Decimal_MinValue
private FieldInfo s_Decimal_MaxValue
private FieldInfo s_Decimal_Zero
private FieldInfo s_DateTime_MinValue
private MethodInfo s_MethodBase_GetMethodFromHandle_RuntimeMethodHandle
private MethodInfo s_MethodBase_GetMethodFromHandle_RuntimeMethodHandle_RuntimeTypeHandle
private MethodInfo s_MethodInfo_CreateDelegate_Type_Object
private MethodInfo s_String_op_Equality_String_String
private MethodInfo s_String_Equals_String_String
private MethodInfo s_DictionaryOfStringInt32_Add_String_Int32
private ConstructorInfo s_DictionaryOfStringInt32_Ctor_Int32
private MethodInfo s_Type_GetTypeFromHandle
private MethodInfo s_Object_GetType
private MethodInfo s_Decimal_op_Implicit_Byte
private MethodInfo s_Decimal_op_Implicit_SByte
private MethodInfo s_Decimal_op_Implicit_Int16
private MethodInfo s_Decimal_op_Implicit_UInt16
private MethodInfo s_Decimal_op_Implicit_Int32
private MethodInfo s_Decimal_op_Implicit_UInt32
private MethodInfo s_Decimal_op_Implicit_Int64
private MethodInfo s_Decimal_op_Implicit_UInt64
private MethodInfo s_Decimal_op_Implicit_Char
private MethodInfo s_Math_Pow_Double_Double
private ConstructorInfo s_Closure_ObjectArray_ObjectArray
private FieldInfo s_Closure_Constants
private FieldInfo s_Closure_Locals
private MethodInfo s_RuntimeOps_CreateRuntimeVariables_ObjectArray_Int64Array
private MethodInfo s_RuntimeOps_CreateRuntimeVariables
private MethodInfo s_RuntimeOps_MergeRuntimeVariables
private MethodInfo s_RuntimeOps_Quote
public MethodInfo String_Format_String_ObjectArray
public ConstructorInfo InvalidCastException_Ctor_String
public MethodInfo CallSiteOps_SetNotMatched
public MethodInfo CallSiteOps_CreateMatchmaker
public MethodInfo CallSiteOps_GetMatch
public MethodInfo CallSiteOps_ClearMatch
public MethodInfo CallSiteOps_UpdateRules
public MethodInfo CallSiteOps_GetRules
public MethodInfo CallSiteOps_GetRuleCache
public MethodInfo CallSiteOps_GetCachedRules
public MethodInfo CallSiteOps_AddRule
public MethodInfo CallSiteOps_MoveRule
public MethodInfo CallSiteOps_Bind
public MethodInfo DynamicObject_TryGetMember
public MethodInfo DynamicObject_TrySetMember
public MethodInfo DynamicObject_TryDeleteMember
public MethodInfo DynamicObject_TryGetIndex
public MethodInfo DynamicObject_TrySetIndex
public MethodInfo DynamicObject_TryDeleteIndex
public MethodInfo DynamicObject_TryConvert
public MethodInfo DynamicObject_TryInvoke
public MethodInfo DynamicObject_TryInvokeMember
public MethodInfo DynamicObject_TryBinaryOperation
public MethodInfo DynamicObject_TryUnaryOperation
public MethodInfo DynamicObject_TryCreateInstance
public ConstructorInfo Nullable_Boolean_Ctor
public ConstructorInfo Decimal_Ctor_Int32
public ConstructorInfo Decimal_Ctor_UInt32
public ConstructorInfo Decimal_Ctor_Int64
public ConstructorInfo Decimal_Ctor_UInt64
public ConstructorInfo Decimal_Ctor_Int32_Int32_Int32_Bool_Byte
public FieldInfo Decimal_One
public FieldInfo Decimal_MinusOne
public FieldInfo Decimal_MinValue
public FieldInfo Decimal_MaxValue
public FieldInfo Decimal_Zero
public FieldInfo DateTime_MinValue
public MethodInfo MethodBase_GetMethodFromHandle_RuntimeMethodHandle
public MethodInfo MethodBase_GetMethodFromHandle_RuntimeMethodHandle_RuntimeTypeHandle
public MethodInfo MethodInfo_CreateDelegate_Type_Object
public MethodInfo String_op_Equality_String_String
public MethodInfo String_Equals_String_String
public MethodInfo DictionaryOfStringInt32_Add_String_Int32
public ConstructorInfo DictionaryOfStringInt32_Ctor_Int32
public MethodInfo Type_GetTypeFromHandle
public MethodInfo Object_GetType
public MethodInfo Decimal_op_Implicit_Byte
public MethodInfo Decimal_op_Implicit_SByte
public MethodInfo Decimal_op_Implicit_Int16
public MethodInfo Decimal_op_Implicit_UInt16
public MethodInfo Decimal_op_Implicit_Int32
public MethodInfo Decimal_op_Implicit_UInt32
public MethodInfo Decimal_op_Implicit_Int64
public MethodInfo Decimal_op_Implicit_UInt64
public MethodInfo Decimal_op_Implicit_Char
public MethodInfo Math_Pow_Double_Double
public ConstructorInfo Closure_ObjectArray_ObjectArray
public FieldInfo Closure_Constants
public FieldInfo Closure_Locals
public MethodInfo RuntimeOps_CreateRuntimeVariables_ObjectArray_Int64Array
public MethodInfo RuntimeOps_CreateRuntimeVariables
public MethodInfo RuntimeOps_MergeRuntimeVariables
public MethodInfo RuntimeOps_Quote
public MethodInfo get_String_Format_String_ObjectArray()
public ConstructorInfo get_InvalidCastException_Ctor_String()
public MethodInfo get_CallSiteOps_SetNotMatched()
public MethodInfo get_CallSiteOps_CreateMatchmaker()
public MethodInfo get_CallSiteOps_GetMatch()
public MethodInfo get_CallSiteOps_ClearMatch()
public MethodInfo get_CallSiteOps_UpdateRules()
public MethodInfo get_CallSiteOps_GetRules()
public MethodInfo get_CallSiteOps_GetRuleCache()
public MethodInfo get_CallSiteOps_GetCachedRules()
public MethodInfo get_CallSiteOps_AddRule()
public MethodInfo get_CallSiteOps_MoveRule()
public MethodInfo get_CallSiteOps_Bind()
public MethodInfo get_DynamicObject_TryGetMember()
public MethodInfo get_DynamicObject_TrySetMember()
public MethodInfo get_DynamicObject_TryDeleteMember()
public MethodInfo get_DynamicObject_TryGetIndex()
public MethodInfo get_DynamicObject_TrySetIndex()
public MethodInfo get_DynamicObject_TryDeleteIndex()
public MethodInfo get_DynamicObject_TryConvert()
public MethodInfo get_DynamicObject_TryInvoke()
public MethodInfo get_DynamicObject_TryInvokeMember()
public MethodInfo get_DynamicObject_TryBinaryOperation()
public MethodInfo get_DynamicObject_TryUnaryOperation()
public MethodInfo get_DynamicObject_TryCreateInstance()
public ConstructorInfo get_Nullable_Boolean_Ctor()
public ConstructorInfo get_Decimal_Ctor_Int32()
public ConstructorInfo get_Decimal_Ctor_UInt32()
public ConstructorInfo get_Decimal_Ctor_Int64()
public ConstructorInfo get_Decimal_Ctor_UInt64()
public ConstructorInfo get_Decimal_Ctor_Int32_Int32_Int32_Bool_Byte()
public FieldInfo get_Decimal_One()
public FieldInfo get_Decimal_MinusOne()
public FieldInfo get_Decimal_MinValue()
public FieldInfo get_Decimal_MaxValue()
public FieldInfo get_Decimal_Zero()
public FieldInfo get_DateTime_MinValue()
public MethodInfo get_MethodBase_GetMethodFromHandle_RuntimeMethodHandle()
public MethodInfo get_MethodBase_GetMethodFromHandle_RuntimeMethodHandle_RuntimeTypeHandle()
public MethodInfo get_MethodInfo_CreateDelegate_Type_Object()
public MethodInfo get_String_op_Equality_String_String()
public MethodInfo get_String_Equals_String_String()
public MethodInfo get_DictionaryOfStringInt32_Add_String_Int32()
public ConstructorInfo get_DictionaryOfStringInt32_Ctor_Int32()
public MethodInfo get_Type_GetTypeFromHandle()
public MethodInfo get_Object_GetType()
public MethodInfo get_Decimal_op_Implicit_Byte()
public MethodInfo get_Decimal_op_Implicit_SByte()
public MethodInfo get_Decimal_op_Implicit_Int16()
public MethodInfo get_Decimal_op_Implicit_UInt16()
public MethodInfo get_Decimal_op_Implicit_Int32()
public MethodInfo get_Decimal_op_Implicit_UInt32()
public MethodInfo get_Decimal_op_Implicit_Int64()
public MethodInfo get_Decimal_op_Implicit_UInt64()
public MethodInfo get_Decimal_op_Implicit_Char()
public MethodInfo get_Math_Pow_Double_Double()
public ConstructorInfo get_Closure_ObjectArray_ObjectArray()
public FieldInfo get_Closure_Constants()
public FieldInfo get_Closure_Locals()
public MethodInfo get_RuntimeOps_CreateRuntimeVariables_ObjectArray_Int64Array()
public MethodInfo get_RuntimeOps_CreateRuntimeVariables()
public MethodInfo get_RuntimeOps_MergeRuntimeVariables()
public MethodInfo get_RuntimeOps_Quote()
}
public System.Linq.Expressions.CatchBlock : object {
private ParameterExpression <Variable>k__BackingField
private Type <Test>k__BackingField
private Expression <Body>k__BackingField
private Expression <Filter>k__BackingField
public ParameterExpression Variable
public Type Test
public Expression Body
public Expression Filter
internal void .ctor(Type test, ParameterExpression variable, Expression body, Expression filter)
public ParameterExpression get_Variable()
public Type get_Test()
public Expression get_Body()
public Expression get_Filter()
public string ToString()
public CatchBlock Update(ParameterExpression variable, Expression filter, Expression body)
}
internal System.Linq.Expressions.ClearDebugInfoExpression : DebugInfoExpression {
public bool IsClear
public int StartLine
public int StartColumn
public int EndLine
public int EndColumn
internal void .ctor(SymbolDocumentInfo document)
public bool get_IsClear()
public int get_StartLine()
public int get_StartColumn()
public int get_EndLine()
public int get_EndColumn()
}
internal System.Linq.Expressions.CoalesceConversionBinaryExpression : BinaryExpression {
private LambdaExpression _conversion
public ExpressionType NodeType
public Type Type
internal void .ctor(Expression left, Expression right, LambdaExpression conversion)
internal LambdaExpression GetConversion()
public ExpressionType get_NodeType()
public Type get_Type()
}
internal System.Linq.Expressions.Compiler.AnalyzedTree : object {
internal Dictionary`2<object, CompilerScope> Scopes
internal Dictionary`2<LambdaExpression, BoundConstants> Constants
}
internal System.Linq.Expressions.Compiler.AssemblyGen : object {
private AssemblyGen s_assembly
private ModuleBuilder _myModule
private int _index
private AssemblyGen Assembly
private AssemblyGen get_Assembly()
private TypeBuilder DefineType(string name, Type parent, TypeAttributes attr)
internal TypeBuilder DefineDelegateType(string name)
}
internal System.Linq.Expressions.Compiler.BoundConstants : object {
private List`1<object> _values
private Dictionary`2<object, int> _indexes
private Dictionary`2<TypedConstant, int> _references
private Dictionary`2<TypedConstant, LocalBuilder> _cache
internal int Count
internal int get_Count()
internal Object[] ToArray()
internal void AddReference(object value, Type type)
internal void EmitConstant(LambdaCompiler lc, object value, Type type)
internal void EmitCacheConstants(LambdaCompiler lc)
private bool ShouldCache(int refCount)
private void EmitConstantsArray(LambdaCompiler lc)
private void EmitConstantFromArray(LambdaCompiler lc, object value, Type type)
}
internal System.Linq.Expressions.Compiler.CompilerScope : object {
private CompilerScope _parent
internal object Node
internal bool IsMethod
internal bool NeedsClosure
internal Dictionary`2<ParameterExpression, VariableStorageKind> Definitions
internal Dictionary`2<ParameterExpression, int> ReferenceCount
internal HashSet`1<BlockExpression> MergedScopes
private HoistedLocals _hoistedLocals
private HoistedLocals _closureHoistedLocals
private Dictionary`2<ParameterExpression, Storage> _locals
internal HoistedLocals NearestHoistedLocals
private string CurrentLambdaName
internal void .ctor(object node, bool isMethod)
internal HoistedLocals get_NearestHoistedLocals()
internal CompilerScope Enter(LambdaCompiler lc, CompilerScope parent)
internal CompilerScope Exit()
internal void EmitVariableAccess(LambdaCompiler lc, ReadOnlyCollection`1<ParameterExpression> vars)
internal void AddLocal(LambdaCompiler gen, ParameterExpression variable)
internal void EmitGet(ParameterExpression variable)
internal void EmitSet(ParameterExpression variable)
internal void EmitAddressOf(ParameterExpression variable)
private Storage ResolveVariable(ParameterExpression variable)
private Storage ResolveVariable(ParameterExpression variable, HoistedLocals hoistedLocals)
private void SetParent(LambdaCompiler lc, CompilerScope parent)
private void EmitNewHoistedLocals(LambdaCompiler lc)
private void EmitCachedVariables()
private bool ShouldCache(ParameterExpression v, int refCount)
private bool ShouldCache(ParameterExpression v)
private void CacheBoxToLocal(LambdaCompiler lc, ParameterExpression v)
private void EmitClosureAccess(LambdaCompiler lc, HoistedLocals locals)
private void EmitClosureToVariable(LambdaCompiler lc, HoistedLocals locals)
private void AllocateLocals(LambdaCompiler lc)
private IEnumerable`1<ParameterExpression> GetVariables()
private IEnumerable`1<ParameterExpression> GetVariablesIncludingMerged()
private IReadOnlyList`1<ParameterExpression> GetVariables(object scope)
private string get_CurrentLambdaName()
private bool <SetParent>b__27_0(ParameterExpression p)
}
internal System.Linq.Expressions.Compiler.DelegateHelpers : object {
private TypeInfo _DelegateCache
private int MaximumArity
private MethodAttributes CtorAttributes
private MethodImplAttributes ImplAttributes
private MethodAttributes InvokeAttributes
private Type[] s_delegateCtorSignature
internal Type MakeDelegateType(Type[] types)
internal TypeInfo NextTypeInfo(Type initialArg)
internal TypeInfo GetNextTypeInfo(Type initialArg, TypeInfo curTypeInfo)
private TypeInfo NextTypeInfo(Type initialArg, TypeInfo curTypeInfo)
internal Type MakeNewDelegate(Type[] types)
internal Type GetFuncType(Type[] types)
internal Type GetActionType(Type[] types)
internal Type MakeCallSiteDelegate(ReadOnlyCollection`1<Expression> types, Type returnType)
internal Type MakeDeferredSiteDelegate(DynamicMetaObject[] args, Type returnType)
private bool IsByRef(DynamicMetaObject mo)
private Type MakeNewCustomDelegate(Type[] types)
}
internal System.Linq.Expressions.Compiler.HoistedLocals : object {
internal HoistedLocals Parent
internal ReadOnlyDictionary`2<Expression, int> Indexes
internal ReadOnlyCollection`1<ParameterExpression> Variables
internal ParameterExpression SelfVariable
internal ParameterExpression ParentVariable
internal void .ctor(HoistedLocals parent, ReadOnlyCollection`1<ParameterExpression> vars)
internal ParameterExpression get_ParentVariable()
internal Object[] GetParent(Object[] locals)
}
internal System.Linq.Expressions.Compiler.ILGen : object {
internal void Emit(ILGenerator il, OpCode opcode, MethodBase methodBase)
internal void EmitLoadArg(ILGenerator il, int index)
internal void EmitLoadArgAddress(ILGenerator il, int index)
internal void EmitStoreArg(ILGenerator il, int index)
internal void EmitLoadValueIndirect(ILGenerator il, Type type)
internal void EmitStoreValueIndirect(ILGenerator il, Type type)
internal void EmitLoadElement(ILGenerator il, Type type)
internal void EmitStoreElement(ILGenerator il, Type type)
internal void EmitType(ILGenerator il, Type type)
internal void EmitFieldAddress(ILGenerator il, FieldInfo fi)
internal void EmitFieldGet(ILGenerator il, FieldInfo fi)
internal void EmitFieldSet(ILGenerator il, FieldInfo fi)
internal void EmitNew(ILGenerator il, ConstructorInfo ci)
internal void EmitNull(ILGenerator il)
internal void EmitString(ILGenerator il, string value)
internal void EmitPrimitive(ILGenerator il, bool value)
internal void EmitPrimitive(ILGenerator il, int value)
private void EmitPrimitive(ILGenerator il, UInt32 value)
private void EmitPrimitive(ILGenerator il, long value)
private void EmitPrimitive(ILGenerator il, ulong value)
private void EmitPrimitive(ILGenerator il, double value)
private void EmitPrimitive(ILGenerator il, float value)
internal bool CanEmitConstant(object value, Type type)
private bool CanEmitILConstant(Type type)
internal bool TryEmitConstant(ILGenerator il, object value, Type type, ILocalCache locals)
private bool ShouldLdtoken(Type t)
internal bool ShouldLdtoken(MethodBase mb)
private bool TryEmitILConstant(ILGenerator il, object value, Type type)
internal void EmitConvertToType(ILGenerator il, Type typeFrom, Type typeTo, bool isChecked, ILocalCache locals)
private void EmitCastToType(ILGenerator il, Type typeFrom, Type typeTo)
private void EmitNumericConversion(ILGenerator il, Type typeFrom, Type typeTo, bool isChecked)
private void EmitNullableToNullableConversion(ILGenerator il, Type typeFrom, Type typeTo, bool isChecked, ILocalCache locals)
private void EmitNonNullableToNullableConversion(ILGenerator il, Type typeFrom, Type typeTo, bool isChecked, ILocalCache locals)
private void EmitNullableToNonNullableConversion(ILGenerator il, Type typeFrom, Type typeTo, bool isChecked, ILocalCache locals)
private void EmitNullableToNonNullableStructConversion(ILGenerator il, Type typeFrom, Type typeTo, bool isChecked, ILocalCache locals)
private void EmitNullableToReferenceConversion(ILGenerator il, Type typeFrom)
private void EmitNullableConversion(ILGenerator il, Type typeFrom, Type typeTo, bool isChecked, ILocalCache locals)
internal void EmitHasValue(ILGenerator il, Type nullableType)
internal void EmitGetValue(ILGenerator il, Type nullableType)
internal void EmitGetValueOrDefault(ILGenerator il, Type nullableType)
internal void EmitArray(ILGenerator il, T[] items, ILocalCache locals)
internal void EmitArray(ILGenerator il, Type elementType, int count)
internal void EmitArray(ILGenerator il, Type arrayType)
private void EmitDecimal(ILGenerator il, decimal value)
internal void EmitDefault(ILGenerator il, Type type, ILocalCache locals)
}
internal System.Linq.Expressions.Compiler.ILocalCache {
public LocalBuilder GetLocal(Type type)
public void FreeLocal(LocalBuilder local)
}
internal System.Linq.Expressions.Compiler.KeyedStack`2 : object {
private Dictionary`2<TKey, Stack`1<TValue>> _data
internal void Push(TKey key, TValue value)
internal TValue TryPop(TKey key)
}
internal System.Linq.Expressions.Compiler.LabelInfo : object {
private LabelTarget _node
private Label _label
private bool _labelDefined
private LocalBuilder _value
private HashSet`1<LabelScopeInfo> _definitions
private List`1<LabelScopeInfo> _references
private bool _canReturn
private bool _acrossBlockJump
private OpCode _opCode
private ILGenerator _ilg
internal Label Label
internal bool CanReturn
internal bool CanBranch
internal Label get_Label()
internal void .ctor(ILGenerator il, LabelTarget node, bool canReturn)
internal bool get_CanReturn()
internal bool get_CanBranch()
internal void Reference(LabelScopeInfo block)
internal void Define(LabelScopeInfo block)
private void ValidateJump(LabelScopeInfo reference)
internal void ValidateFinish()
internal void EmitJump()
private void StoreValue()
internal void Mark()
internal void MarkWithEmptyStack()
private void EnsureLabelAndValue()
}
internal System.Linq.Expressions.Compiler.LabelScopeInfo : object {
private Dictionary`2<LabelTarget, LabelInfo> _labels
internal LabelScopeKind Kind
internal LabelScopeInfo Parent
internal bool CanJumpInto
internal void .ctor(LabelScopeInfo parent, LabelScopeKind kind)
internal bool get_CanJumpInto()
internal bool ContainsTarget(LabelTarget target)
internal bool TryGetLabelInfo(LabelTarget target, LabelInfo& info)
internal void AddLabelInfo(LabelTarget target, LabelInfo info)
}
internal System.Linq.Expressions.Compiler.LabelScopeKind : Enum {
public int value__
public LabelScopeKind Statement
public LabelScopeKind Block
public LabelScopeKind Switch
public LabelScopeKind Lambda
public LabelScopeKind Try
public LabelScopeKind Catch
public LabelScopeKind Finally
public LabelScopeKind Filter
public LabelScopeKind Expression
}
internal System.Linq.Expressions.Compiler.LambdaCompiler : object {
private StackGuard _guard
private int s_counter
private AnalyzedTree _tree
private ILGenerator _ilg
private TypeBuilder _typeBuilder
private MethodInfo _method
private LabelScopeInfo _labelBlock
private Dictionary`2<LabelTarget, LabelInfo> _labelInfo
private CompilerScope _scope
private LambdaExpression _lambda
private bool _hasClosureArgument
private BoundConstants _boundConstants
private KeyedStack`2<Type, LocalBuilder> _freeLocals
internal ILGenerator IL
internal IParameterProvider Parameters
internal bool CanEmitBoundConstants
private void EmitAddress(Expression node, Type type)
private void EmitAddress(Expression node, Type type, CompilationFlags flags)
private void AddressOf(BinaryExpression node, Type type)
private void AddressOf(ParameterExpression node, Type type)
private void AddressOf(MemberExpression node, Type type)
private void EmitMemberAddress(MemberInfo member, Type objectType)
private void AddressOf(MethodCallExpression node, Type type)
private void AddressOf(IndexExpression node, Type type)
private void AddressOf(UnaryExpression node, Type type)
private void EmitExpressionAddress(Expression node, Type type)
private WriteBack EmitAddressWriteBack(Expression node, Type type)
private WriteBack AddressOfWriteBack(MemberExpression node)
private WriteBack AddressOfWriteBackCore(MemberExpression node)
private WriteBack AddressOfWriteBack(IndexExpression node)
private WriteBack AddressOfWriteBackCore(IndexExpression node)
private LocalBuilder GetInstanceLocal(Type type)
private void EmitBinaryExpression(Expression expr)
private void EmitBinaryExpression(Expression expr, CompilationFlags flags)
private void EmitNullEquality(ExpressionType op, Expression e, bool isLiftedToNull)
private void EmitBinaryMethod(BinaryExpression b, CompilationFlags flags)
private void EmitBinaryOperator(ExpressionType op, Type leftType, Type rightType, Type resultType, bool liftedToNull)
private void EmitUnliftedBinaryOp(ExpressionType op, Type leftType, Type rightType)
private void EmitShiftMask(Type leftType)
private void EmitConvertArithmeticResult(ExpressionType op, Type resultType)
private void EmitLiftedBinaryOp(ExpressionType op, Type leftType, Type rightType, Type resultType, bool liftedToNull)
private void EmitLiftedRelational(ExpressionType op, Type type)
private void EmitLiftedToNullRelational(ExpressionType op, Type type)
private void EmitLiftedBinaryArithmetic(ExpressionType op, Type leftType, Type rightType, Type resultType)
private void EmitLiftedBooleanAnd()
private void EmitLiftedBooleanOr()
private LabelInfo EnsureLabel(LabelTarget node)
private LabelInfo ReferenceLabel(LabelTarget node)
private LabelInfo DefineLabel(LabelTarget node)
private void PushLabelBlock(LabelScopeKind type)
private void PopLabelBlock(LabelScopeKind kind)
private void EmitLabelExpression(Expression expr, CompilationFlags flags)
private void EmitGotoExpression(Expression expr, CompilationFlags flags)
private void EmitUnreachable(Expression node, CompilationFlags flags)
private bool TryPushLabelBlock(Expression node)
private void DefineBlockLabels(Expression node)
private void AddReturnLabel(LambdaExpression lambda)
private CompilationFlags UpdateEmitAsTailCallFlag(CompilationFlags flags, CompilationFlags newValue)
private CompilationFlags UpdateEmitExpressionStartFlag(CompilationFlags flags, CompilationFlags newValue)
private CompilationFlags UpdateEmitAsTypeFlag(CompilationFlags flags, CompilationFlags newValue)
internal void EmitExpression(Expression node)
private void EmitExpressionAsVoid(Expression node)
private void EmitExpressionAsVoid(Expression node, CompilationFlags flags)
private void EmitExpressionAsType(Expression node, Type type, CompilationFlags flags)
private CompilationFlags EmitExpressionStart(Expression node)
private void EmitExpressionEnd(CompilationFlags flags)
private void EmitInvocationExpression(Expression expr, CompilationFlags flags)
private void EmitInlinedInvoke(InvocationExpression invoke, CompilationFlags flags)
private void EmitIndexExpression(Expression expr)
private void EmitIndexAssignment(AssignBinaryExpression node, CompilationFlags flags)
private void EmitGetIndexCall(IndexExpression node, Type objectType)
private void EmitGetArrayElement(Type arrayType)
private void EmitSetIndexCall(IndexExpression node, Type objectType)
private void EmitSetArrayElement(Type arrayType)
private void EmitMethodCallExpression(Expression expr, CompilationFlags flags)
private void EmitMethodCallExpression(Expression expr)
private void EmitMethodCall(Expression obj, MethodInfo method, IArgumentProvider methodCallExpr)
private void EmitMethodCall(Expression obj, MethodInfo method, IArgumentProvider methodCallExpr, CompilationFlags flags)
private void EmitMethodCall(MethodInfo mi, IArgumentProvider args, Type objectType)
private void EmitMethodCall(MethodInfo mi, IArgumentProvider args, Type objectType, CompilationFlags flags)
private bool MethodHasByRefParameter(MethodInfo mi)
private void EmitCall(Type objectType, MethodInfo method)
private bool UseVirtual(MethodInfo mi)
private List`1<WriteBack> EmitArguments(MethodBase method, IArgumentProvider args)
private List`1<WriteBack> EmitArguments(MethodBase method, IArgumentProvider args, int skipParameters)
private void EmitWriteBack(List`1<WriteBack> writeBacks)
private void EmitConstantExpression(Expression expr)
private void EmitConstant(object value)
private void EmitConstant(object value, Type type)
private void EmitDynamicExpression(Expression expr)
private void EmitNewExpression(Expression expr)
private void EmitTypeBinaryExpression(Expression expr)
private void EmitVariableAssignment(AssignBinaryExpression node, CompilationFlags flags)
private void EmitAssignBinaryExpression(Expression expr)
private void EmitAssign(AssignBinaryExpression node, CompilationFlags emitAs)
private void EmitParameterExpression(Expression expr)
private void EmitLambdaExpression(Expression expr)
private void EmitRuntimeVariablesExpression(Expression expr)
private void EmitMemberAssignment(AssignBinaryExpression node, CompilationFlags flags)
private void EmitMemberExpression(Expression expr)
private void EmitMemberGet(MemberInfo member, Type objectType)
private void EmitInstance(Expression instance, Type& type)
private void EmitNewArrayExpression(Expression expr)
private void EmitDebugInfoExpression(Expression expr)
private void EmitListInitExpression(Expression expr)
private void EmitMemberInitExpression(Expression expr)
private void EmitBinding(MemberBinding binding, Type objectType)
private void EmitMemberAssignment(MemberAssignment binding, Type objectType)
private void EmitMemberMemberBinding(MemberMemberBinding binding)
private void EmitMemberListBinding(MemberListBinding binding)
private void EmitMemberInit(MemberInitExpression init)
private void EmitMemberInit(ReadOnlyCollection`1<MemberBinding> bindings, bool keepOnStack, Type objectType)
private void EmitListInit(ListInitExpression init)
private void EmitListInit(ReadOnlyCollection`1<ElementInit> initializers, bool keepOnStack, Type objectType)
private Type GetMemberType(MemberInfo member)
private void EmitLift(ExpressionType nodeType, Type resultType, MethodCallExpression mc, ParameterExpression[] paramList, Expression[] argList)
private void EmitExpression(Expression node, CompilationFlags flags)
private bool IsChecked(ExpressionType op)
internal void EmitConstantArray(T[] array)
private void EmitClosureCreation(LambdaCompiler inner)
private void EmitDelegateConstruction(LambdaCompiler inner)
private void EmitDelegateConstruction(LambdaExpression lambda)
private Type[] GetParameterTypes(LambdaExpression lambda, Type firstType)
private string GetUniqueMethodName()
private void EmitLambdaBody()
private void EmitLambdaBody(CompilerScope parent, bool inlined, CompilationFlags flags)
private void EmitConditionalExpression(Expression expr, CompilationFlags flags)
private bool NotEmpty(Expression node)
private bool Significant(Expression node)
private void EmitCoalesceBinaryExpression(Expression expr)
private void EmitNullableCoalesce(BinaryExpression b)
private void EmitLambdaReferenceCoalesce(BinaryExpression b)
private void EmitReferenceCoalesceWithoutConversion(BinaryExpression b)
private void EmitLiftedAndAlso(BinaryExpression b)
private void EmitMethodAndAlso(BinaryExpression b, CompilationFlags flags)
private void EmitUnliftedAndAlso(BinaryExpression b)
private void EmitAndAlsoBinaryExpression(Expression expr, CompilationFlags flags)
private void EmitLiftedOrElse(BinaryExpression b)
private void EmitUnliftedOrElse(BinaryExpression b)
private void EmitMethodOrElse(BinaryExpression b, CompilationFlags flags)
private void EmitOrElseBinaryExpression(Expression expr, CompilationFlags flags)
private void EmitExpressionAndBranch(bool branchValue, Expression node, Label label)
private void EmitBranchOp(bool branch, Label label)
private void EmitBranchNot(bool branch, UnaryExpression node, Label label)
private void EmitBranchComparison(bool branch, BinaryExpression node, Label label)
private Expression GetEqualityOperand(Expression expression)
private void EmitBranchLogical(bool branch, BinaryExpression node, Label label)
private void EmitBranchAnd(bool branch, BinaryExpression node, Label label)
private void EmitBranchOr(bool branch, BinaryExpression node, Label label)
private void EmitBranchBlock(bool branch, BlockExpression node, Label label)
private void EmitBlockExpression(Expression expr, CompilationFlags flags)
private void Emit(BlockExpression node, CompilationFlags flags)
private void EnterScope(object node)
private bool HasVariables(object node)
private void ExitScope(object node)
private void EmitDefaultExpression(Expression expr)
private void EmitLoopExpression(Expression expr)
private void EmitSwitchExpression(Expression expr, CompilationFlags flags)
private Type GetTestValueType(SwitchExpression node)
private bool FitsInBucket(List`1<SwitchLabel> buckets, decimal key, int count)
private void MergeBuckets(List`1<List`1<SwitchLabel>> buckets)
private void AddToBuckets(List`1<List`1<SwitchLabel>> buckets, SwitchLabel key)
private bool CanOptimizeSwitchType(Type valueType)
private bool TryEmitSwitchInstruction(SwitchExpression node, CompilationFlags flags)
private decimal ConvertSwitchValue(object value)
private void DefineSwitchCaseLabel(SwitchCase case, Label& label, Boolean& isGoto)
private void EmitSwitchCases(SwitchExpression node, Label[] labels, Boolean[] isGoto, Label default, Label end, CompilationFlags flags)
private void EmitSwitchBuckets(SwitchInfo info, List`1<List`1<SwitchLabel>> buckets, int first, int last)
private void EmitSwitchBucket(SwitchInfo info, List`1<SwitchLabel> bucket)
private bool TryEmitHashtableSwitch(SwitchExpression node, CompilationFlags flags)
private void CheckRethrow()
private void CheckTry()
private void EmitSaveExceptionOrPop(CatchBlock cb)
private void EmitTryExpression(Expression expr)
private void EmitCatchStart(CatchBlock cb)
private void EmitQuoteUnaryExpression(Expression expr)
private void EmitQuote(UnaryExpression quote)
private void EmitThrowUnaryExpression(Expression expr)
private void EmitThrow(UnaryExpression expr, CompilationFlags flags)
private void EmitUnaryExpression(Expression expr, CompilationFlags flags)
private void EmitUnary(UnaryExpression node, CompilationFlags flags)
private void EmitUnaryOperator(ExpressionType op, Type operandType, Type resultType)
private void EmitConstantOne(Type type)
private void EmitUnboxUnaryExpression(Expression expr)
private void EmitConvertUnaryExpression(Expression expr, CompilationFlags flags)
private void EmitConvert(UnaryExpression node, CompilationFlags flags)
private void EmitUnaryMethod(UnaryExpression node, CompilationFlags flags)
private void .ctor(AnalyzedTree tree, LambdaExpression lambda)
private void .ctor(AnalyzedTree tree, LambdaExpression lambda, MethodBuilder method)
private void .ctor(LambdaCompiler parent, LambdaExpression lambda, InvocationExpression invocation)
private void InitializeMethod()
internal ILGenerator get_IL()
internal IParameterProvider get_Parameters()
internal bool get_CanEmitBoundConstants()
internal Delegate Compile(LambdaExpression lambda)
internal void Compile(LambdaExpression lambda, MethodBuilder method)
private AnalyzedTree AnalyzeLambda(LambdaExpression& lambda)
public LocalBuilder GetLocal(Type type)
public void FreeLocal(LocalBuilder local)
internal int GetLambdaArgument(int index)
internal void EmitLambdaArgument(int index)
internal void EmitClosureArgument()
private Delegate CreateDelegate()
private FieldBuilder CreateStaticField(string name, Type type)
private MemberExpression CreateLazyInitializedField(string name)
}
internal System.Linq.Expressions.Compiler.ParameterList : object {
private IParameterProvider _provider
public ParameterExpression Item
public int Count
public void .ctor(IParameterProvider provider)
public ParameterExpression get_Item(int index)
public int get_Count()
public IEnumerator`1<ParameterExpression> GetEnumerator()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
}
internal System.Linq.Expressions.Compiler.ParameterProviderExtensions : object {
public int IndexOf(IParameterProvider provider, ParameterExpression parameter)
public bool Contains(IParameterProvider provider, ParameterExpression parameter)
}
internal System.Linq.Expressions.Compiler.SpilledExpressionBlock : BlockN {
internal void .ctor(IReadOnlyList`1<Expression> expressions)
internal BlockExpression Rewrite(ReadOnlyCollection`1<ParameterExpression> variables, Expression[] args)
}
internal System.Linq.Expressions.Compiler.StackSpiller : object {
private StackGuard _guard
private TempMaker _tm
private Stack _startingStack
private RewriteAction _lambdaRewrite
private Result RewriteExpression(Expression node, Stack stack)
private Expression MakeBlock(ArrayBuilder`1<Expression> expressions)
private Expression MakeBlock(Expression[] expressions)
private Expression MakeBlock(IReadOnlyList`1<Expression> expressions)
private ParameterExpression MakeTemp(Type type)
private int Mark()
private void Free(int mark)
private void VerifyTemps()
private ParameterExpression ToTemp(Expression expression, Expression& save, bool byRef)
internal LambdaExpression AnalyzeLambda(LambdaExpression lambda)
private void .ctor(Stack stack)
internal Expression`1<T> Rewrite(Expression`1<T> lambda)
private void VerifyRewrite(Result result, Expression node)
private Result RewriteExpressionFreeTemps(Expression expression, Stack stack)
private Result RewriteDynamicExpression(Expression expr)
private Result RewriteIndexAssignment(BinaryExpression node, Stack stack)
private Result RewriteLogicalBinaryExpression(Expression expr, Stack stack)
private Result RewriteReducibleExpression(Expression expr, Stack stack)
private Result RewriteBinaryExpression(Expression expr, Stack stack)
private Result RewriteVariableAssignment(BinaryExpression node, Stack stack)
private Result RewriteAssignBinaryExpression(Expression expr, Stack stack)
private Result RewriteExtensionAssignment(BinaryExpression node, Stack stack)
private Result RewriteLambdaExpression(Expression expr)
private Result RewriteConditionalExpression(Expression expr, Stack stack)
private Result RewriteMemberAssignment(BinaryExpression node, Stack stack)
private Result RewriteMemberExpression(Expression expr, Stack stack)
private Result RewriteIndexExpression(Expression expr, Stack stack)
private Result RewriteMethodCallExpression(Expression expr, Stack stack)
private Result RewriteNewArrayExpression(Expression expr, Stack stack)
private Result RewriteInvocationExpression(Expression expr, Stack stack)
private Result RewriteNewExpression(Expression expr, Stack stack)
private Result RewriteTypeBinaryExpression(Expression expr, Stack stack)
private Result RewriteThrowUnaryExpression(Expression expr, Stack stack)
private Result RewriteUnaryExpression(Expression expr, Stack stack)
private Result RewriteListInitExpression(Expression expr, Stack stack)
private Result RewriteMemberInitExpression(Expression expr, Stack stack)
private Result RewriteBlockExpression(Expression expr, Stack stack)
private Result RewriteLabelExpression(Expression expr, Stack stack)
private Result RewriteLoopExpression(Expression expr, Stack stack)
private Result RewriteGotoExpression(Expression expr, Stack stack)
private Result RewriteSwitchExpression(Expression expr, Stack stack)
private Result RewriteTryExpression(Expression expr, Stack stack)
private Result RewriteExtensionExpression(Expression expr, Stack stack)
private T[] Clone(ReadOnlyCollection`1<T> original, int max)
private void RequireNoRefArgs(MethodBase method)
private void RequireNotRefInstance(Expression instance)
private bool IsRefInstance(Expression instance)
}
internal System.Linq.Expressions.Compiler.TypeInfoExtensions : object {
public Type MakeDelegateType(TypeInfo info, Type retType, Expression[] args)
public Type MakeDelegateType(TypeInfo info, Type retType, IList`1<Expression> args)
}
internal System.Linq.Expressions.Compiler.VariableBinder : ExpressionVisitor {
private AnalyzedTree _tree
private Stack`1<CompilerScope> _scopes
private Stack`1<BoundConstants> _constants
private StackGuard _guard
private bool _inQuote
private string CurrentLambdaName
internal AnalyzedTree Bind(LambdaExpression lambda)
public Expression Visit(Expression node)
protected internal Expression VisitConstant(ConstantExpression node)
protected internal Expression VisitUnary(UnaryExpression node)
protected internal Expression VisitLambda(Expression`1<T> node)
protected internal Expression VisitInvocation(InvocationExpression node)
protected internal Expression VisitBlock(BlockExpression node)
protected CatchBlock VisitCatchBlock(CatchBlock node)
private ReadOnlyCollection`1<Expression> MergeScopes(Expression node)
protected internal Expression VisitParameter(ParameterExpression node)
protected internal Expression VisitRuntimeVariables(RuntimeVariablesExpression node)
private void Reference(ParameterExpression node, VariableStorageKind storage)
private string get_CurrentLambdaName()
}
internal System.Linq.Expressions.Compiler.VariableStorageKind : Enum {
public int value__
public VariableStorageKind Local
public VariableStorageKind Hoisted
}
public System.Linq.Expressions.ConditionalExpression : Expression {
private Expression <Test>k__BackingField
private Expression <IfTrue>k__BackingField
public ExpressionType NodeType
public Type Type
public Expression Test
public Expression IfTrue
public Expression IfFalse
internal void .ctor(Expression test, Expression ifTrue)
internal ConditionalExpression Make(Expression test, Expression ifTrue, Expression ifFalse, Type type)
public ExpressionType get_NodeType()
public Type get_Type()
public Expression get_Test()
public Expression get_IfTrue()
public Expression get_IfFalse()
internal Expression GetFalse()
protected internal Expression Accept(ExpressionVisitor visitor)
public ConditionalExpression Update(Expression test, Expression ifTrue, Expression ifFalse)
}
internal System.Linq.Expressions.ConstantCheck : object {
internal bool IsNull(Expression e)
internal AnalyzeTypeIsResult AnalyzeTypeIs(TypeBinaryExpression typeIs)
private AnalyzeTypeIsResult AnalyzeTypeIs(Expression operand, Type testType)
}
public System.Linq.Expressions.ConstantExpression : Expression {
private object <Value>k__BackingField
public Type Type
public ExpressionType NodeType
public object Value
internal void .ctor(object value)
public Type get_Type()
public ExpressionType get_NodeType()
public object get_Value()
protected internal Expression Accept(ExpressionVisitor visitor)
}
public System.Linq.Expressions.DebugInfoExpression : Expression {
private SymbolDocumentInfo <Document>k__BackingField
public Type Type
public ExpressionType NodeType
public int StartLine
public int StartColumn
public int EndLine
public int EndColumn
public SymbolDocumentInfo Document
public bool IsClear
internal void .ctor(SymbolDocumentInfo document)
public Type get_Type()
public ExpressionType get_NodeType()
public int get_StartLine()
public int get_StartColumn()
public int get_EndLine()
public int get_EndColumn()
public SymbolDocumentInfo get_Document()
public bool get_IsClear()
protected internal Expression Accept(ExpressionVisitor visitor)
}
internal System.Linq.Expressions.DebugViewWriter : ExpressionVisitor {
private int Tab
private int MaxColumn
private TextWriter _out
private int _column
private Stack`1<int> _stack
private int _delta
private Flow _flow
private Queue`1<LambdaExpression> _lambdas
private Dictionary`2<LambdaExpression, int> _lambdaIds
private Dictionary`2<ParameterExpression, int> _paramIds
private Dictionary`2<LabelTarget, int> _labelIds
private int Base
private int Delta
private int Depth
private void .ctor(TextWriter file)
private int get_Base()
private int get_Delta()
private int get_Depth()
private void Indent()
private void Dedent()
private void NewLine()
private int GetId(T e, Dictionary`2& ids)
private int GetLambdaId(LambdaExpression le)
private int GetParamId(ParameterExpression p)
private int GetLabelTargetId(LabelTarget target)
internal void WriteTo(Expression node, TextWriter writer)
private void WriteTo(Expression node)
private void Out(string s)
private void Out(Flow before, string s)
private void Out(string s, Flow after)
private void Out(Flow before, string s, Flow after)
private void WriteLine()
private void Write(string s)
private Flow GetFlow(Flow flow)
private Flow CheckBreak(Flow flow)
private void VisitExpressions(char open, IReadOnlyList`1<T> expressions)
private void VisitExpressions(char open, char separator, IReadOnlyList`1<T> expressions)
private void VisitDeclarations(IReadOnlyList`1<ParameterExpression> expressions)
private void VisitExpressions(char open, char separator, IReadOnlyList`1<T> expressions, Action`1<T> visit)
protected internal Expression VisitBinary(BinaryExpression node)
protected internal Expression VisitParameter(ParameterExpression node)
protected internal Expression VisitLambda(Expression`1<T> node)
private bool IsSimpleExpression(Expression node)
protected internal Expression VisitConditional(ConditionalExpression node)
protected internal Expression VisitConstant(ConstantExpression node)
private string GetConstantValueSuffix(Type type)
protected internal Expression VisitRuntimeVariables(RuntimeVariablesExpression node)
private void OutMember(Expression node, Expression instance, MemberInfo member)
protected internal Expression VisitMember(MemberExpression node)
protected internal Expression VisitInvocation(InvocationExpression node)
private bool NeedsParentheses(Expression parent, Expression child)
private int GetOperatorPrecedence(Expression node)
private void ParenthesizedVisit(Expression parent, Expression nodeToVisit)
protected internal Expression VisitMethodCall(MethodCallExpression node)
protected internal Expression VisitNewArray(NewArrayExpression node)
protected internal Expression VisitNew(NewExpression node)
protected ElementInit VisitElementInit(ElementInit node)
protected internal Expression VisitListInit(ListInitExpression node)
protected MemberAssignment VisitMemberAssignment(MemberAssignment assignment)
protected MemberListBinding VisitMemberListBinding(MemberListBinding binding)
protected MemberMemberBinding VisitMemberMemberBinding(MemberMemberBinding binding)
protected internal Expression VisitMemberInit(MemberInitExpression node)
protected internal Expression VisitTypeBinary(TypeBinaryExpression node)
protected internal Expression VisitUnary(UnaryExpression node)
protected internal Expression VisitBlock(BlockExpression node)
protected internal Expression VisitDefault(DefaultExpression node)
protected internal Expression VisitLabel(LabelExpression node)
protected internal Expression VisitGoto(GotoExpression node)
protected internal Expression VisitLoop(LoopExpression node)
protected SwitchCase VisitSwitchCase(SwitchCase node)
protected internal Expression VisitSwitch(SwitchExpression node)
protected CatchBlock VisitCatchBlock(CatchBlock node)
protected internal Expression VisitTry(TryExpression node)
protected internal Expression VisitIndex(IndexExpression node)
protected internal Expression VisitExtension(Expression node)
protected internal Expression VisitDebugInfo(DebugInfoExpression node)
private void DumpLabel(LabelTarget target)
private string GetLabelTargetName(LabelTarget target)
private void WriteLambda(LambdaExpression lambda)
private string GetLambdaName(LambdaExpression lambda)
private bool ContainsWhiteSpace(string name)
private string QuoteName(string name)
private string GetDisplayName(string name)
private void <VisitExpressions>b__37_0(T e)
private void <VisitDeclarations>b__38_0(ParameterExpression variable)
private void <VisitListInit>b__58_0(ElementInit e)
private void <VisitMemberListBinding>b__60_0(ElementInit e)
private void <VisitMemberMemberBinding>b__61_0(MemberBinding e)
private void <VisitMemberInit>b__62_0(MemberBinding e)
}
public System.Linq.Expressions.DefaultExpression : Expression {
private Type <Type>k__BackingField
public Type Type
public ExpressionType NodeType
internal void .ctor(Type type)
public Type get_Type()
public ExpressionType get_NodeType()
protected internal Expression Accept(ExpressionVisitor visitor)
}
public System.Linq.Expressions.DynamicExpression : Expression {
private CallSiteBinder <Binder>k__BackingField
private Type <DelegateType>k__BackingField
public bool CanReduce
public Type Type
public ExpressionType NodeType
public CallSiteBinder Binder
public Type DelegateType
public ReadOnlyCollection`1<Expression> Arguments
private int System.Linq.Expressions.IArgumentProvider.ArgumentCount
internal void .ctor(Type delegateType, CallSiteBinder binder)
public bool get_CanReduce()
public Expression Reduce()
internal DynamicExpression Make(Type returnType, Type delegateType, CallSiteBinder binder, ReadOnlyCollection`1<Expression> arguments)
internal DynamicExpression Make(Type returnType, Type delegateType, CallSiteBinder binder, Expression arg0)
internal DynamicExpression Make(Type returnType, Type delegateType, CallSiteBinder binder, Expression arg0, Expression arg1)
internal DynamicExpression Make(Type returnType, Type delegateType, CallSiteBinder binder, Expression arg0, Expression arg1, Expression arg2)
internal DynamicExpression Make(Type returnType, Type delegateType, CallSiteBinder binder, Expression arg0, Expression arg1, Expression arg2, Expression arg3)
public Type get_Type()
public ExpressionType get_NodeType()
public CallSiteBinder get_Binder()
public Type get_DelegateType()
public ReadOnlyCollection`1<Expression> get_Arguments()
internal ReadOnlyCollection`1<Expression> GetOrMakeArguments()
protected internal Expression Accept(ExpressionVisitor visitor)
internal DynamicExpression Rewrite(Expression[] args)
public DynamicExpression Update(IEnumerable`1<Expression> arguments)
internal bool SameArguments(ICollection`1<Expression> arguments)
private Expression System.Linq.Expressions.IArgumentProvider.GetArgument(int index)
private int System.Linq.Expressions.IArgumentProvider.get_ArgumentCount()
public DynamicExpression Dynamic(CallSiteBinder binder, Type returnType, Expression[] arguments)
public DynamicExpression Dynamic(CallSiteBinder binder, Type returnType, IEnumerable`1<Expression> arguments)
public DynamicExpression Dynamic(CallSiteBinder binder, Type returnType, Expression arg0)
public DynamicExpression Dynamic(CallSiteBinder binder, Type returnType, Expression arg0, Expression arg1)
public DynamicExpression Dynamic(CallSiteBinder binder, Type returnType, Expression arg0, Expression arg1, Expression arg2)
public DynamicExpression Dynamic(CallSiteBinder binder, Type returnType, Expression arg0, Expression arg1, Expression arg2, Expression arg3)
public DynamicExpression MakeDynamic(Type delegateType, CallSiteBinder binder, IEnumerable`1<Expression> arguments)
public DynamicExpression MakeDynamic(Type delegateType, CallSiteBinder binder, Expression[] arguments)
public DynamicExpression MakeDynamic(Type delegateType, CallSiteBinder binder, Expression arg0)
public DynamicExpression MakeDynamic(Type delegateType, CallSiteBinder binder, Expression arg0, Expression arg1)
public DynamicExpression MakeDynamic(Type delegateType, CallSiteBinder binder, Expression arg0, Expression arg1, Expression arg2)
public DynamicExpression MakeDynamic(Type delegateType, CallSiteBinder binder, Expression arg0, Expression arg1, Expression arg2, Expression arg3)
private Expression System.Linq.Expressions.IDynamicExpression.Rewrite(Expression[] args)
private object System.Linq.Expressions.IDynamicExpression.CreateCallSite()
}
internal System.Linq.Expressions.DynamicExpression1 : DynamicExpression {
private object _arg0
private int System.Linq.Expressions.IArgumentProvider.ArgumentCount
internal void .ctor(Type delegateType, CallSiteBinder binder, Expression arg0)
private Expression System.Linq.Expressions.IArgumentProvider.GetArgument(int index)
private int System.Linq.Expressions.IArgumentProvider.get_ArgumentCount()
internal bool SameArguments(ICollection`1<Expression> arguments)
internal ReadOnlyCollection`1<Expression> GetOrMakeArguments()
internal DynamicExpression Rewrite(Expression[] args)
}
internal System.Linq.Expressions.DynamicExpression2 : DynamicExpression {
private object _arg0
private Expression _arg1
private int System.Linq.Expressions.IArgumentProvider.ArgumentCount
internal void .ctor(Type delegateType, CallSiteBinder binder, Expression arg0, Expression arg1)
private Expression System.Linq.Expressions.IArgumentProvider.GetArgument(int index)
private int System.Linq.Expressions.IArgumentProvider.get_ArgumentCount()
internal bool SameArguments(ICollection`1<Expression> arguments)
internal ReadOnlyCollection`1<Expression> GetOrMakeArguments()
internal DynamicExpression Rewrite(Expression[] args)
}
internal System.Linq.Expressions.DynamicExpression3 : DynamicExpression {
private object _arg0
private Expression _arg1
private Expression _arg2
private int System.Linq.Expressions.IArgumentProvider.ArgumentCount
internal void .ctor(Type delegateType, CallSiteBinder binder, Expression arg0, Expression arg1, Expression arg2)
private Expression System.Linq.Expressions.IArgumentProvider.GetArgument(int index)
private int System.Linq.Expressions.IArgumentProvider.get_ArgumentCount()
internal bool SameArguments(ICollection`1<Expression> arguments)
internal ReadOnlyCollection`1<Expression> GetOrMakeArguments()
internal DynamicExpression Rewrite(Expression[] args)
}
internal System.Linq.Expressions.DynamicExpression4 : DynamicExpression {
private object _arg0
private Expression _arg1
private Expression _arg2
private Expression _arg3
private int System.Linq.Expressions.IArgumentProvider.ArgumentCount
internal void .ctor(Type delegateType, CallSiteBinder binder, Expression arg0, Expression arg1, Expression arg2, Expression arg3)
private Expression System.Linq.Expressions.IArgumentProvider.GetArgument(int index)
private int System.Linq.Expressions.IArgumentProvider.get_ArgumentCount()
internal bool SameArguments(ICollection`1<Expression> arguments)
internal ReadOnlyCollection`1<Expression> GetOrMakeArguments()
internal DynamicExpression Rewrite(Expression[] args)
}
internal System.Linq.Expressions.DynamicExpressionN : DynamicExpression {
private IReadOnlyList`1<Expression> _arguments
private int System.Linq.Expressions.IArgumentProvider.ArgumentCount
internal void .ctor(Type delegateType, CallSiteBinder binder, IReadOnlyList`1<Expression> arguments)
private Expression System.Linq.Expressions.IArgumentProvider.GetArgument(int index)
internal bool SameArguments(ICollection`1<Expression> arguments)
private int System.Linq.Expressions.IArgumentProvider.get_ArgumentCount()
internal ReadOnlyCollection`1<Expression> GetOrMakeArguments()
internal DynamicExpression Rewrite(Expression[] args)
}
public System.Linq.Expressions.DynamicExpressionVisitor : ExpressionVisitor {
protected internal Expression VisitDynamic(DynamicExpression node)
}
public System.Linq.Expressions.ElementInit : object {
private MethodInfo <AddMethod>k__BackingField
private ReadOnlyCollection`1<Expression> <Arguments>k__BackingField
public MethodInfo AddMethod
public ReadOnlyCollection`1<Expression> Arguments
public int ArgumentCount
internal void .ctor(MethodInfo addMethod, ReadOnlyCollection`1<Expression> arguments)
public MethodInfo get_AddMethod()
public ReadOnlyCollection`1<Expression> get_Arguments()
public Expression GetArgument(int index)
public int get_ArgumentCount()
public string ToString()
public ElementInit Update(IEnumerable`1<Expression> arguments)
}
internal System.Linq.Expressions.Error : object {
internal Exception ReducibleMustOverrideReduce()
internal Exception ArgCntMustBeGreaterThanNameCnt()
internal Exception InvalidMetaObjectCreated(object p0)
internal Exception AmbiguousMatchInExpandoObject(object p0)
internal Exception SameKeyExistsInExpando(object key)
internal Exception KeyDoesNotExistInExpando(object p0)
internal Exception CollectionModifiedWhileEnumerating()
internal Exception CollectionReadOnly()
internal Exception MustReduceToDifferent()
internal Exception BinderNotCompatibleWithCallSite(object p0, object p1, object p2)
internal Exception DynamicBindingNeedsRestrictions(object p0, object p1)
internal Exception DynamicObjectResultNotAssignable(object p0, object p1, object p2, object p3)
internal Exception DynamicBinderResultNotAssignable(object p0, object p1, object p2)
internal Exception BindingCannotBeNull()
internal Exception ReducedNotCompatible()
internal Exception SetterHasNoParams(string paramName)
internal Exception PropertyCannotHaveRefType(string paramName)
internal Exception IndexesOfSetGetMustMatch(string paramName)
internal Exception TypeParameterIsNotDelegate(object p0)
internal Exception FirstArgumentMustBeCallSite()
internal Exception AccessorsCannotHaveVarArgs(string paramName)
private Exception AccessorsCannotHaveByRefArgs(string paramName)
internal Exception AccessorsCannotHaveByRefArgs(string paramName, int index)
internal Exception TypeMustBeDerivedFromSystemDelegate()
internal Exception NoOrInvalidRuleProduced()
internal Exception BoundsCannotBeLessThanOne(string paramName)
internal Exception TypeMustNotBeByRef(string paramName)
internal Exception TypeMustNotBePointer(string paramName)
internal Exception SetterMustBeVoid(string paramName)
internal Exception PropertyTypeMustMatchGetter(string paramName)
internal Exception PropertyTypeMustMatchSetter(string paramName)
internal Exception BothAccessorsMustBeStatic(string paramName)
internal Exception OnlyStaticFieldsHaveNullInstance(string paramName)
internal Exception OnlyStaticPropertiesHaveNullInstance(string paramName)
internal Exception OnlyStaticMethodsHaveNullInstance()
internal Exception PropertyTypeCannotBeVoid(string paramName)
internal Exception InvalidUnboxType(string paramName)
internal Exception ExpressionMustBeWriteable(string paramName)
internal Exception ArgumentMustNotHaveValueType(string paramName)
internal Exception MustBeReducible()
internal Exception AllTestValuesMustHaveSameType(string paramName)
internal Exception AllCaseBodiesMustHaveSameType(string paramName)
internal Exception DefaultBodyMustBeSupplied(string paramName)
internal Exception LabelMustBeVoidOrHaveExpression(string paramName)
internal Exception LabelTypeMustBeVoid(string paramName)
internal Exception QuotedExpressionMustBeLambda(string paramName)
internal Exception VariableMustNotBeByRef(object p0, object p1, string paramName)
internal Exception VariableMustNotBeByRef(object p0, object p1, string paramName, int index)
private Exception DuplicateVariable(object p0, string paramName)
internal Exception DuplicateVariable(object p0, string paramName, int index)
internal Exception StartEndMustBeOrdered()
internal Exception FaultCannotHaveCatchOrFinally(string paramName)
internal Exception TryMustHaveCatchFinallyOrFault()
internal Exception BodyOfCatchMustHaveSameTypeAsBodyOfTry()
internal Exception ExtensionNodeMustOverrideProperty(object p0)
internal Exception UserDefinedOperatorMustBeStatic(object p0, string paramName)
internal Exception UserDefinedOperatorMustNotBeVoid(object p0, string paramName)
internal Exception CoercionOperatorNotDefined(object p0, object p1)
internal Exception UnaryOperatorNotDefined(object p0, object p1)
internal Exception BinaryOperatorNotDefined(object p0, object p1, object p2)
internal Exception ReferenceEqualityNotDefined(object p0, object p1)
internal Exception OperandTypesDoNotMatchParameters(object p0, object p1)
internal Exception OverloadOperatorTypeDoesNotMatchConversionType(object p0, object p1)
internal Exception ConversionIsNotSupportedForArithmeticTypes()
internal Exception ArgumentTypeCannotBeVoid()
internal Exception ArgumentMustBeArray(string paramName)
internal Exception ArgumentMustBeBoolean(string paramName)
internal Exception EqualityMustReturnBoolean(object p0, string paramName)
internal Exception ArgumentMustBeFieldInfoOrPropertyInfo(string paramName)
private Exception ArgumentMustBeFieldInfoOrPropertyInfoOrMethod(string paramName)
internal Exception ArgumentMustBeFieldInfoOrPropertyInfoOrMethod(string paramName, int index)
private Exception ArgumentMustBeInstanceMember(string paramName)
internal Exception ArgumentMustBeInstanceMember(string paramName, int index)
private Exception ArgumentMustBeInteger(string paramName)
internal Exception ArgumentMustBeInteger(string paramName, int index)
internal Exception ArgumentMustBeArrayIndexType(string paramName)
internal Exception ArgumentMustBeArrayIndexType(string paramName, int index)
internal Exception ArgumentMustBeSingleDimensionalArrayType(string paramName)
internal Exception ArgumentTypesMustMatch()
internal Exception ArgumentTypesMustMatch(string paramName)
internal Exception CannotAutoInitializeValueTypeElementThroughProperty(object p0)
internal Exception CannotAutoInitializeValueTypeMemberThroughProperty(object p0)
internal Exception IncorrectTypeForTypeAs(object p0, string paramName)
internal Exception CoalesceUsedOnNonNullType()
internal Exception ExpressionTypeCannotInitializeArrayType(object p0, object p1)
private Exception ArgumentTypeDoesNotMatchMember(object p0, object p1, string paramName)
internal Exception ArgumentTypeDoesNotMatchMember(object p0, object p1, string paramName, int index)
private Exception ArgumentMemberNotDeclOnType(object p0, object p1, string paramName)
internal Exception ArgumentMemberNotDeclOnType(object p0, object p1, string paramName, int index)
internal Exception ExpressionTypeDoesNotMatchReturn(object p0, object p1)
internal Exception ExpressionTypeDoesNotMatchAssignment(object p0, object p1)
internal Exception ExpressionTypeDoesNotMatchLabel(object p0, object p1)
internal Exception ExpressionTypeNotInvocable(object p0, string paramName)
internal Exception FieldNotDefinedForType(object p0, object p1)
internal Exception InstanceFieldNotDefinedForType(object p0, object p1)
internal Exception FieldInfoNotDefinedForType(object p0, object p1, object p2)
internal Exception IncorrectNumberOfIndexes()
internal Exception IncorrectNumberOfLambdaDeclarationParameters()
internal Exception IncorrectNumberOfMembersForGivenConstructor()
internal Exception IncorrectNumberOfArgumentsForMembers()
internal Exception LambdaTypeMustBeDerivedFromSystemDelegate(string paramName)
internal Exception MemberNotFieldOrProperty(object p0, string paramName)
internal Exception MethodContainsGenericParameters(object p0, string paramName)
internal Exception MethodIsGeneric(object p0, string paramName)
private Exception MethodNotPropertyAccessor(object p0, object p1, string paramName)
internal Exception MethodNotPropertyAccessor(object p0, object p1, string paramName, int index)
internal Exception PropertyDoesNotHaveGetter(object p0, string paramName)
internal Exception PropertyDoesNotHaveGetter(object p0, string paramName, int index)
internal Exception PropertyDoesNotHaveSetter(object p0, string paramName)
internal Exception PropertyDoesNotHaveAccessor(object p0, string paramName)
internal Exception NotAMemberOfType(object p0, object p1, string paramName)
internal Exception NotAMemberOfType(object p0, object p1, string paramName, int index)
internal Exception NotAMemberOfAnyType(object p0, string paramName)
internal Exception ParameterExpressionNotValidAsDelegate(object p0, object p1)
internal Exception PropertyNotDefinedForType(object p0, object p1, string paramName)
internal Exception InstancePropertyNotDefinedForType(object p0, object p1, string paramName)
internal Exception InstancePropertyWithoutParameterNotDefinedForType(object p0, object p1)
internal Exception InstancePropertyWithSpecifiedParametersNotDefinedForType(object p0, object p1, object p2, string paramName)
internal Exception InstanceAndMethodTypeMismatch(object p0, object p1, object p2)
internal Exception TypeMissingDefaultConstructor(object p0, string paramName)
internal Exception ElementInitializerMethodNotAdd(string paramName)
internal Exception ElementInitializerMethodNoRefOutParam(object p0, object p1, string paramName)
internal Exception ElementInitializerMethodWithZeroArgs(string paramName)
internal Exception ElementInitializerMethodStatic(string paramName)
internal Exception TypeNotIEnumerable(object p0, string paramName)
internal Exception UnhandledBinary(object p0, string paramName)
internal Exception UnhandledBinding()
internal Exception UnhandledBindingType(object p0)
internal Exception UnhandledUnary(object p0, string paramName)
internal Exception UnknownBindingType(int index)
internal Exception UserDefinedOpMustHaveConsistentTypes(object p0, object p1)
internal Exception UserDefinedOpMustHaveValidReturnType(object p0, object p1)
internal Exception LogicalOperatorMustHaveBooleanOperators(object p0, object p1)
internal Exception MethodWithArgsDoesNotExistOnType(object p0, object p1)
internal Exception GenericMethodWithArgsDoesNotExistOnType(object p0, object p1)
internal Exception MethodWithMoreThanOneMatch(object p0, object p1)
internal Exception PropertyWithMoreThanOneMatch(object p0, object p1)
internal Exception IncorrectNumberOfTypeArgsForFunc(string paramName)
internal Exception IncorrectNumberOfTypeArgsForAction(string paramName)
internal Exception ArgumentCannotBeOfTypeVoid(string paramName)
internal Exception OutOfRange(string paramName, object p1)
internal Exception LabelTargetAlreadyDefined(object p0)
internal Exception LabelTargetUndefined(object p0)
internal Exception ControlCannotLeaveFinally()
internal Exception ControlCannotLeaveFilterTest()
internal Exception AmbiguousJump(object p0)
internal Exception ControlCannotEnterTry()
internal Exception ControlCannotEnterExpression()
internal Exception NonLocalJumpWithValue(object p0)
internal Exception CannotCompileConstant(object p0)
internal Exception CannotCompileDynamic()
internal Exception MethodBuilderDoesNotHaveTypeBuilder()
internal Exception InvalidLvalue(ExpressionType p0)
internal Exception UndefinedVariable(object p0, object p1, object p2)
internal Exception CannotCloseOverByRef(object p0, object p1)
internal Exception UnexpectedVarArgsCall(object p0)
internal Exception RethrowRequiresCatch()
internal Exception TryNotAllowedInFilter()
internal Exception MustRewriteToSameNode(object p0, object p1, object p2)
internal Exception MustRewriteChildToSameType(object p0, object p1, object p2)
internal Exception MustRewriteWithoutMethod(object p0, object p1)
internal Exception TryNotSupportedForMethodsWithRefArgs(object p0)
internal Exception TryNotSupportedForValueTypeInstances(object p0)
internal Exception TestValueTypeDoesNotMatchComparisonMethodParameter(object p0, object p1)
internal Exception SwitchValueTypeDoesNotMatchComparisonMethodParameter(object p0, object p1)
internal Exception PdbGeneratorNeedsExpressionCompiler()
internal Exception ArgumentOutOfRange(string paramName)
internal Exception NotSupported()
internal Exception NonStaticConstructorRequired(string paramName)
internal Exception NonAbstractConstructorRequired()
internal Exception InvalidProgram()
internal Exception EnumerationIsDone()
private Exception TypeContainsGenericParameters(object p0, string paramName)
internal Exception TypeContainsGenericParameters(object p0, string paramName, int index)
internal Exception TypeIsGeneric(object p0, string paramName)
internal Exception TypeIsGeneric(object p0, string paramName, int index)
internal Exception IncorrectNumberOfConstructorArguments()
internal Exception ExpressionTypeDoesNotMatchMethodParameter(object p0, object p1, object p2, string paramName)
internal Exception ExpressionTypeDoesNotMatchMethodParameter(object p0, object p1, object p2, string paramName, int index)
internal Exception ExpressionTypeDoesNotMatchParameter(object p0, object p1, string paramName)
internal Exception ExpressionTypeDoesNotMatchParameter(object p0, object p1, string paramName, int index)
internal Exception IncorrectNumberOfLambdaArguments()
internal Exception IncorrectNumberOfMethodCallArguments(object p0, string paramName)
internal Exception ExpressionTypeDoesNotMatchConstructorParameter(object p0, object p1, string paramName)
internal Exception ExpressionTypeDoesNotMatchConstructorParameter(object p0, object p1, string paramName, int index)
internal Exception ExpressionMustBeReadable(string paramName)
internal Exception ExpressionMustBeReadable(string paramName, int index)
internal Exception InvalidArgumentValue(string paramName)
internal Exception NonEmptyCollectionRequired(string paramName)
internal Exception InvalidNullValue(Type type, string paramName)
internal Exception InvalidTypeException(object value, Type type, string paramName)
private string GetParamName(string paramName, int index)
}
public System.Linq.Expressions.Expression : object {
private CacheDict`2<Type, MethodInfo> s_lambdaDelegateCache
private CacheDict`2 modreq(System.Runtime.CompilerServices.IsVolatile) s_lambdaFactories
private ConditionalWeakTable`2<Expression, ExtensionInfo> s_legacyCtorSupportTable
public ExpressionType NodeType
public Type Type
public bool CanReduce
private string DebugView
public BinaryExpression Assign(Expression left, Expression right)
private BinaryExpression GetUserDefinedBinaryOperator(ExpressionType binaryType, string name, Expression left, Expression right, bool liftToNull)
private BinaryExpression GetMethodBasedBinaryOperator(ExpressionType binaryType, Expression left, Expression right, MethodInfo method, bool liftToNull)
private BinaryExpression GetMethodBasedAssignOperator(ExpressionType binaryType, Expression left, Expression right, MethodInfo method, LambdaExpression conversion, bool liftToNull)
private BinaryExpression GetUserDefinedBinaryOperatorOrThrow(ExpressionType binaryType, string name, Expression left, Expression right, bool liftToNull)
private BinaryExpression GetUserDefinedAssignOperatorOrThrow(ExpressionType binaryType, string name, Expression left, Expression right, LambdaExpression conversion, bool liftToNull)
private MethodInfo GetUserDefinedBinaryOperator(ExpressionType binaryType, Type leftType, Type rightType, string name)
private bool IsLiftingConditionalLogicalOperator(Type left, Type right, MethodInfo method, ExpressionType binaryType)
internal bool ParameterIsAssignable(ParameterInfo pi, Type argType)
private void ValidateParamswithOperandsOrThrow(Type paramType, Type operandType, ExpressionType exprType, string name)
private void ValidateOperator(MethodInfo method)
private void ValidateMethodInfo(MethodInfo method, string paramName)
private bool IsNullComparison(Expression left, Expression right)
private bool IsNullConstant(Expression e)
private void ValidateUserDefinedConditionalLogicOperator(ExpressionType nodeType, Type left, Type right, MethodInfo method)
private void VerifyOpTrueFalse(ExpressionType nodeType, Type left, MethodInfo opTrue, string paramName)
private bool IsValidLiftedConditionalLogicalOperator(Type left, Type right, ParameterInfo[] pms)
public BinaryExpression MakeBinary(ExpressionType binaryType, Expression left, Expression right)
public BinaryExpression MakeBinary(ExpressionType binaryType, Expression left, Expression right, bool liftToNull, MethodInfo method)
public BinaryExpression MakeBinary(ExpressionType binaryType, Expression left, Expression right, bool liftToNull, MethodInfo method, LambdaExpression conversion)
public BinaryExpression Equal(Expression left, Expression right)
public BinaryExpression Equal(Expression left, Expression right, bool liftToNull, MethodInfo method)
public BinaryExpression ReferenceEqual(Expression left, Expression right)
public BinaryExpression NotEqual(Expression left, Expression right)
public BinaryExpression NotEqual(Expression left, Expression right, bool liftToNull, MethodInfo method)
public BinaryExpression ReferenceNotEqual(Expression left, Expression right)
private BinaryExpression GetEqualityComparisonOperator(ExpressionType binaryType, string opName, Expression left, Expression right, bool liftToNull)
public BinaryExpression GreaterThan(Expression left, Expression right)
public BinaryExpression GreaterThan(Expression left, Expression right, bool liftToNull, MethodInfo method)
public BinaryExpression LessThan(Expression left, Expression right)
public BinaryExpression LessThan(Expression left, Expression right, bool liftToNull, MethodInfo method)
public BinaryExpression GreaterThanOrEqual(Expression left, Expression right)
public BinaryExpression GreaterThanOrEqual(Expression left, Expression right, bool liftToNull, MethodInfo method)
public BinaryExpression LessThanOrEqual(Expression left, Expression right)
public BinaryExpression LessThanOrEqual(Expression left, Expression right, bool liftToNull, MethodInfo method)
private BinaryExpression GetComparisonOperator(ExpressionType binaryType, string opName, Expression left, Expression right, bool liftToNull)
public BinaryExpression AndAlso(Expression left, Expression right)
public BinaryExpression AndAlso(Expression left, Expression right, MethodInfo method)
public BinaryExpression OrElse(Expression left, Expression right)
public BinaryExpression OrElse(Expression left, Expression right, MethodInfo method)
public BinaryExpression Coalesce(Expression left, Expression right)
public BinaryExpression Coalesce(Expression left, Expression right, LambdaExpression conversion)
private Type ValidateCoalesceArgTypes(Type left, Type right)
public BinaryExpression Add(Expression left, Expression right)
public BinaryExpression Add(Expression left, Expression right, MethodInfo method)
public BinaryExpression AddAssign(Expression left, Expression right)
public BinaryExpression AddAssign(Expression left, Expression right, MethodInfo method)
public BinaryExpression AddAssign(Expression left, Expression right, MethodInfo method, LambdaExpression conversion)
private void ValidateOpAssignConversionLambda(LambdaExpression conversion, Expression left, MethodInfo method, ExpressionType nodeType)
public BinaryExpression AddAssignChecked(Expression left, Expression right)
public BinaryExpression AddAssignChecked(Expression left, Expression right, MethodInfo method)
public BinaryExpression AddAssignChecked(Expression left, Expression right, MethodInfo method, LambdaExpression conversion)
public BinaryExpression AddChecked(Expression left, Expression right)
public BinaryExpression AddChecked(Expression left, Expression right, MethodInfo method)
public BinaryExpression Subtract(Expression left, Expression right)
public BinaryExpression Subtract(Expression left, Expression right, MethodInfo method)
public BinaryExpression SubtractAssign(Expression left, Expression right)
public BinaryExpression SubtractAssign(Expression left, Expression right, MethodInfo method)
public BinaryExpression SubtractAssign(Expression left, Expression right, MethodInfo method, LambdaExpression conversion)
public BinaryExpression SubtractAssignChecked(Expression left, Expression right)
public BinaryExpression SubtractAssignChecked(Expression left, Expression right, MethodInfo method)
public BinaryExpression SubtractAssignChecked(Expression left, Expression right, MethodInfo method, LambdaExpression conversion)
public BinaryExpression SubtractChecked(Expression left, Expression right)
public BinaryExpression SubtractChecked(Expression left, Expression right, MethodInfo method)
public BinaryExpression Divide(Expression left, Expression right)
public BinaryExpression Divide(Expression left, Expression right, MethodInfo method)
public BinaryExpression DivideAssign(Expression left, Expression right)
public BinaryExpression DivideAssign(Expression left, Expression right, MethodInfo method)
public BinaryExpression DivideAssign(Expression left, Expression right, MethodInfo method, LambdaExpression conversion)
public BinaryExpression Modulo(Expression left, Expression right)
public BinaryExpression Modulo(Expression left, Expression right, MethodInfo method)
public BinaryExpression ModuloAssign(Expression left, Expression right)
public BinaryExpression ModuloAssign(Expression left, Expression right, MethodInfo method)
public BinaryExpression ModuloAssign(Expression left, Expression right, MethodInfo method, LambdaExpression conversion)
public BinaryExpression Multiply(Expression left, Expression right)
public BinaryExpression Multiply(Expression left, Expression right, MethodInfo method)
public BinaryExpression MultiplyAssign(Expression left, Expression right)
public BinaryExpression MultiplyAssign(Expression left, Expression right, MethodInfo method)
public BinaryExpression MultiplyAssign(Expression left, Expression right, MethodInfo method, LambdaExpression conversion)
public BinaryExpression MultiplyAssignChecked(Expression left, Expression right)
public BinaryExpression MultiplyAssignChecked(Expression left, Expression right, MethodInfo method)
public BinaryExpression MultiplyAssignChecked(Expression left, Expression right, MethodInfo method, LambdaExpression conversion)
public BinaryExpression MultiplyChecked(Expression left, Expression right)
public BinaryExpression MultiplyChecked(Expression left, Expression right, MethodInfo method)
private bool IsSimpleShift(Type left, Type right)
private Type GetResultTypeOfShift(Type left, Type right)
public BinaryExpression LeftShift(Expression left, Expression right)
public BinaryExpression LeftShift(Expression left, Expression right, MethodInfo method)
public BinaryExpression LeftShiftAssign(Expression left, Expression right)
public BinaryExpression LeftShiftAssign(Expression left, Expression right, MethodInfo method)
public BinaryExpression LeftShiftAssign(Expression left, Expression right, MethodInfo method, LambdaExpression conversion)
public BinaryExpression RightShift(Expression left, Expression right)
public BinaryExpression RightShift(Expression left, Expression right, MethodInfo method)
public BinaryExpression RightShiftAssign(Expression left, Expression right)
public BinaryExpression RightShiftAssign(Expression left, Expression right, MethodInfo method)
public BinaryExpression RightShiftAssign(Expression left, Expression right, MethodInfo method, LambdaExpression conversion)
public BinaryExpression And(Expression left, Expression right)
public BinaryExpression And(Expression left, Expression right, MethodInfo method)
public BinaryExpression AndAssign(Expression left, Expression right)
public BinaryExpression AndAssign(Expression left, Expression right, MethodInfo method)
public BinaryExpression AndAssign(Expression left, Expression right, MethodInfo method, LambdaExpression conversion)
public BinaryExpression Or(Expression left, Expression right)
public BinaryExpression Or(Expression left, Expression right, MethodInfo method)
public BinaryExpression OrAssign(Expression left, Expression right)
public BinaryExpression OrAssign(Expression left, Expression right, MethodInfo method)
public BinaryExpression OrAssign(Expression left, Expression right, MethodInfo method, LambdaExpression conversion)
public BinaryExpression ExclusiveOr(Expression left, Expression right)
public BinaryExpression ExclusiveOr(Expression left, Expression right, MethodInfo method)
public BinaryExpression ExclusiveOrAssign(Expression left, Expression right)
public BinaryExpression ExclusiveOrAssign(Expression left, Expression right, MethodInfo method)
public BinaryExpression ExclusiveOrAssign(Expression left, Expression right, MethodInfo method, LambdaExpression conversion)
public BinaryExpression Power(Expression left, Expression right)
public BinaryExpression Power(Expression left, Expression right, MethodInfo method)
public BinaryExpression PowerAssign(Expression left, Expression right)
public BinaryExpression PowerAssign(Expression left, Expression right, MethodInfo method)
public BinaryExpression PowerAssign(Expression left, Expression right, MethodInfo method, LambdaExpression conversion)
public BinaryExpression ArrayIndex(Expression array, Expression index)
public BlockExpression Block(Expression arg0, Expression arg1)
public BlockExpression Block(Expression arg0, Expression arg1, Expression arg2)
public BlockExpression Block(Expression arg0, Expression arg1, Expression arg2, Expression arg3)
public BlockExpression Block(Expression arg0, Expression arg1, Expression arg2, Expression arg3, Expression arg4)
public BlockExpression Block(Expression[] expressions)
public BlockExpression Block(IEnumerable`1<Expression> expressions)
public BlockExpression Block(Type type, Expression[] expressions)
public BlockExpression Block(Type type, IEnumerable`1<Expression> expressions)
public BlockExpression Block(IEnumerable`1<ParameterExpression> variables, Expression[] expressions)
public BlockExpression Block(Type type, IEnumerable`1<ParameterExpression> variables, Expression[] expressions)
public BlockExpression Block(IEnumerable`1<ParameterExpression> variables, IEnumerable`1<Expression> expressions)
public BlockExpression Block(Type type, IEnumerable`1<ParameterExpression> variables, IEnumerable`1<Expression> expressions)
private BlockExpression BlockCore(Type type, ReadOnlyCollection`1<ParameterExpression> variables, ReadOnlyCollection`1<Expression> expressions)
internal void ValidateVariables(ReadOnlyCollection`1<ParameterExpression> varList, string collectionName)
private BlockExpression GetOptimizedBlockExpression(IReadOnlyList`1<Expression> expressions)
public CatchBlock Catch(Type type, Expression body)
public CatchBlock Catch(ParameterExpression variable, Expression body)
public CatchBlock Catch(Type type, Expression body, Expression filter)
public CatchBlock Catch(ParameterExpression variable, Expression body, Expression filter)
public CatchBlock MakeCatchBlock(Type type, ParameterExpression variable, Expression body, Expression filter)
public ConditionalExpression Condition(Expression test, Expression ifTrue, Expression ifFalse)
public ConditionalExpression Condition(Expression test, Expression ifTrue, Expression ifFalse, Type type)
public ConditionalExpression IfThen(Expression test, Expression ifTrue)
public ConditionalExpression IfThenElse(Expression test, Expression ifTrue, Expression ifFalse)
public ConstantExpression Constant(object value)
public ConstantExpression Constant(object value, Type type)
public DebugInfoExpression DebugInfo(SymbolDocumentInfo document, int startLine, int startColumn, int endLine, int endColumn)
public DebugInfoExpression ClearDebugInfo(SymbolDocumentInfo document)
private void ValidateSpan(int startLine, int startColumn, int endLine, int endColumn)
public DefaultExpression Empty()
public DefaultExpression Default(Type type)
public ElementInit ElementInit(MethodInfo addMethod, Expression[] arguments)
public ElementInit ElementInit(MethodInfo addMethod, IEnumerable`1<Expression> arguments)
private void ValidateElementInitAddMethodInfo(MethodInfo addMethod, string paramName)
protected void .ctor(ExpressionType nodeType, Type type)
public ExpressionType get_NodeType()
public Type get_Type()
public bool get_CanReduce()
public Expression Reduce()
protected internal Expression VisitChildren(ExpressionVisitor visitor)
protected internal Expression Accept(ExpressionVisitor visitor)
public Expression ReduceAndCheck()
public Expression ReduceExtensions()
public string ToString()
private string get_DebugView()
private void RequiresCanRead(IReadOnlyList`1<Expression> items, string paramName)
private void RequiresCanWrite(Expression expression, string paramName)
public DynamicExpression Dynamic(CallSiteBinder binder, Type returnType, IEnumerable`1<Expression> arguments)
public DynamicExpression Dynamic(CallSiteBinder binder, Type returnType, Expression arg0)
public DynamicExpression Dynamic(CallSiteBinder binder, Type returnType, Expression arg0, Expression arg1)
public DynamicExpression Dynamic(CallSiteBinder binder, Type returnType, Expression arg0, Expression arg1, Expression arg2)
public DynamicExpression Dynamic(CallSiteBinder binder, Type returnType, Expression arg0, Expression arg1, Expression arg2, Expression arg3)
public DynamicExpression Dynamic(CallSiteBinder binder, Type returnType, Expression[] arguments)
public DynamicExpression MakeDynamic(Type delegateType, CallSiteBinder binder, IEnumerable`1<Expression> arguments)
public DynamicExpression MakeDynamic(Type delegateType, CallSiteBinder binder, Expression arg0)
public DynamicExpression MakeDynamic(Type delegateType, CallSiteBinder binder, Expression arg0, Expression arg1)
public DynamicExpression MakeDynamic(Type delegateType, CallSiteBinder binder, Expression arg0, Expression arg1, Expression arg2)
public DynamicExpression MakeDynamic(Type delegateType, CallSiteBinder binder, Expression arg0, Expression arg1, Expression arg2, Expression arg3)
public DynamicExpression MakeDynamic(Type delegateType, CallSiteBinder binder, Expression[] arguments)
public GotoExpression Break(LabelTarget target)
public GotoExpression Break(LabelTarget target, Expression value)
public GotoExpression Break(LabelTarget target, Type type)
public GotoExpression Break(LabelTarget target, Expression value, Type type)
public GotoExpression Continue(LabelTarget target)
public GotoExpression Continue(LabelTarget target, Type type)
public GotoExpression Return(LabelTarget target)
public GotoExpression Return(LabelTarget target, Type type)
public GotoExpression Return(LabelTarget target, Expression value)
public GotoExpression Return(LabelTarget target, Expression value, Type type)
public GotoExpression Goto(LabelTarget target)
public GotoExpression Goto(LabelTarget target, Type type)
public GotoExpression Goto(LabelTarget target, Expression value)
public GotoExpression Goto(LabelTarget target, Expression value, Type type)
public GotoExpression MakeGoto(GotoExpressionKind kind, LabelTarget target, Expression value, Type type)
private void ValidateGoto(LabelTarget target, Expression& value, string targetParameter, string valueParameter, Type type)
private void ValidateGotoType(Type expectedType, Expression& value, string paramName)
public IndexExpression MakeIndex(Expression instance, PropertyInfo indexer, IEnumerable`1<Expression> arguments)
public IndexExpression ArrayAccess(Expression array, Expression[] indexes)
public IndexExpression ArrayAccess(Expression array, IEnumerable`1<Expression> indexes)
public IndexExpression Property(Expression instance, string propertyName, Expression[] arguments)
private PropertyInfo FindInstanceProperty(Type type, string propertyName, Expression[] arguments)
private string GetArgTypesString(Expression[] arguments)
private PropertyInfo FindProperty(Type type, string propertyName, Expression[] arguments, BindingFlags flags)
private bool IsCompatible(PropertyInfo pi, Expression[] args)
public IndexExpression Property(Expression instance, PropertyInfo indexer, Expression[] arguments)
public IndexExpression Property(Expression instance, PropertyInfo indexer, IEnumerable`1<Expression> arguments)
private IndexExpression MakeIndexProperty(Expression instance, PropertyInfo indexer, string paramName, ReadOnlyCollection`1<Expression> argList)
private void ValidateIndexedProperty(Expression instance, PropertyInfo indexer, string paramName, ReadOnlyCollection`1& argList)
private void ValidateAccessor(Expression instance, MethodInfo method, ParameterInfo[] indexes, ReadOnlyCollection`1& arguments, string paramName)
private void ValidateAccessorArgumentTypes(MethodInfo method, ParameterInfo[] indexes, ReadOnlyCollection`1& arguments, string paramName)
internal InvocationExpression Invoke(Expression expression)
internal InvocationExpression Invoke(Expression expression, Expression arg0)
internal InvocationExpression Invoke(Expression expression, Expression arg0, Expression arg1)
internal InvocationExpression Invoke(Expression expression, Expression arg0, Expression arg1, Expression arg2)
internal InvocationExpression Invoke(Expression expression, Expression arg0, Expression arg1, Expression arg2, Expression arg3)
internal InvocationExpression Invoke(Expression expression, Expression arg0, Expression arg1, Expression arg2, Expression arg3, Expression arg4)
public InvocationExpression Invoke(Expression expression, Expression[] arguments)
public InvocationExpression Invoke(Expression expression, IEnumerable`1<Expression> arguments)
internal MethodInfo GetInvokeMethod(Expression expression)
public LabelExpression Label(LabelTarget target)
public LabelExpression Label(LabelTarget target, Expression defaultValue)
public LabelTarget Label()
public LabelTarget Label(string name)
public LabelTarget Label(Type type)
public LabelTarget Label(Type type, string name)
internal LambdaExpression CreateLambda(Type delegateType, Expression body, string name, bool tailCall, ReadOnlyCollection`1<ParameterExpression> parameters)
public Expression`1<TDelegate> Lambda(Expression body, ParameterExpression[] parameters)
public Expression`1<TDelegate> Lambda(Expression body, bool tailCall, ParameterExpression[] parameters)
public Expression`1<TDelegate> Lambda(Expression body, IEnumerable`1<ParameterExpression> parameters)
public Expression`1<TDelegate> Lambda(Expression body, bool tailCall, IEnumerable`1<ParameterExpression> parameters)
public Expression`1<TDelegate> Lambda(Expression body, string name, IEnumerable`1<ParameterExpression> parameters)
public Expression`1<TDelegate> Lambda(Expression body, string name, bool tailCall, IEnumerable`1<ParameterExpression> parameters)
public LambdaExpression Lambda(Expression body, ParameterExpression[] parameters)
public LambdaExpression Lambda(Expression body, bool tailCall, ParameterExpression[] parameters)
public LambdaExpression Lambda(Expression body, IEnumerable`1<ParameterExpression> parameters)
public LambdaExpression Lambda(Expression body, bool tailCall, IEnumerable`1<ParameterExpression> parameters)
public LambdaExpression Lambda(Type delegateType, Expression body, ParameterExpression[] parameters)
public LambdaExpression Lambda(Type delegateType, Expression body, bool tailCall, ParameterExpression[] parameters)
public LambdaExpression Lambda(Type delegateType, Expression body, IEnumerable`1<ParameterExpression> parameters)
public LambdaExpression Lambda(Type delegateType, Expression body, bool tailCall, IEnumerable`1<ParameterExpression> parameters)
public LambdaExpression Lambda(Expression body, string name, IEnumerable`1<ParameterExpression> parameters)
public LambdaExpression Lambda(Expression body, string name, bool tailCall, IEnumerable`1<ParameterExpression> parameters)
public LambdaExpression Lambda(Type delegateType, Expression body, string name, IEnumerable`1<ParameterExpression> parameters)
public LambdaExpression Lambda(Type delegateType, Expression body, string name, bool tailCall, IEnumerable`1<ParameterExpression> parameters)
private void ValidateLambdaArgs(Type delegateType, Expression& body, ReadOnlyCollection`1<ParameterExpression> parameters, string paramName)
private TryGetFuncActionArgsResult ValidateTryGetFuncActionArgs(Type[] typeArgs)
public Type GetFuncType(Type[] typeArgs)
public bool TryGetFuncType(Type[] typeArgs, Type& funcType)
public Type GetActionType(Type[] typeArgs)
public bool TryGetActionType(Type[] typeArgs, Type& actionType)
public Type GetDelegateType(Type[] typeArgs)
public ListInitExpression ListInit(NewExpression newExpression, Expression[] initializers)
public ListInitExpression ListInit(NewExpression newExpression, IEnumerable`1<Expression> initializers)
public ListInitExpression ListInit(NewExpression newExpression, MethodInfo addMethod, Expression[] initializers)
public ListInitExpression ListInit(NewExpression newExpression, MethodInfo addMethod, IEnumerable`1<Expression> initializers)
public ListInitExpression ListInit(NewExpression newExpression, ElementInit[] initializers)
public ListInitExpression ListInit(NewExpression newExpression, IEnumerable`1<ElementInit> initializers)
public LoopExpression Loop(Expression body)
public LoopExpression Loop(Expression body, LabelTarget break)
public LoopExpression Loop(Expression body, LabelTarget break, LabelTarget continue)
public MemberAssignment Bind(MemberInfo member, Expression expression)
public MemberAssignment Bind(MethodInfo propertyAccessor, Expression expression)
private void ValidateSettableFieldOrPropertyMember(MemberInfo member, Type& memberType)
public MemberExpression Field(Expression expression, FieldInfo field)
public MemberExpression Field(Expression expression, string fieldName)
public MemberExpression Field(Expression expression, Type type, string fieldName)
public MemberExpression Property(Expression expression, string propertyName)
public MemberExpression Property(Expression expression, Type type, string propertyName)
public MemberExpression Property(Expression expression, PropertyInfo property)
public MemberExpression Property(Expression expression, MethodInfo propertyAccessor)
private PropertyInfo GetProperty(MethodInfo mi, string paramName, int index)
private bool CheckMethod(MethodInfo method, MethodInfo propertyMethod)
public MemberExpression PropertyOrField(Expression expression, string propertyOrFieldName)
public MemberExpression MakeMemberAccess(Expression expression, MemberInfo member)
public MemberInitExpression MemberInit(NewExpression newExpression, MemberBinding[] bindings)
public MemberInitExpression MemberInit(NewExpression newExpression, IEnumerable`1<MemberBinding> bindings)
public MemberListBinding ListBind(MemberInfo member, ElementInit[] initializers)
public MemberListBinding ListBind(MemberInfo member, IEnumerable`1<ElementInit> initializers)
public MemberListBinding ListBind(MethodInfo propertyAccessor, ElementInit[] initializers)
public MemberListBinding ListBind(MethodInfo propertyAccessor, IEnumerable`1<ElementInit> initializers)
private void ValidateListInitArgs(Type listType, ReadOnlyCollection`1<ElementInit> initializers, string listTypeParamName)
public MemberMemberBinding MemberBind(MemberInfo member, MemberBinding[] bindings)
public MemberMemberBinding MemberBind(MemberInfo member, IEnumerable`1<MemberBinding> bindings)
public MemberMemberBinding MemberBind(MethodInfo propertyAccessor, MemberBinding[] bindings)
public MemberMemberBinding MemberBind(MethodInfo propertyAccessor, IEnumerable`1<MemberBinding> bindings)
private void ValidateGettableFieldOrPropertyMember(MemberInfo member, Type& memberType)
private void ValidateMemberInitArgs(Type type, ReadOnlyCollection`1<MemberBinding> bindings)
internal MethodCallExpression Call(MethodInfo method)
public MethodCallExpression Call(MethodInfo method, Expression arg0)
public MethodCallExpression Call(MethodInfo method, Expression arg0, Expression arg1)
public MethodCallExpression Call(MethodInfo method, Expression arg0, Expression arg1, Expression arg2)
public MethodCallExpression Call(MethodInfo method, Expression arg0, Expression arg1, Expression arg2, Expression arg3)
public MethodCallExpression Call(MethodInfo method, Expression arg0, Expression arg1, Expression arg2, Expression arg3, Expression arg4)
public MethodCallExpression Call(MethodInfo method, Expression[] arguments)
public MethodCallExpression Call(MethodInfo method, IEnumerable`1<Expression> arguments)
public MethodCallExpression Call(Expression instance, MethodInfo method)
public MethodCallExpression Call(Expression instance, MethodInfo method, Expression[] arguments)
internal MethodCallExpression Call(Expression instance, MethodInfo method, Expression arg0)
public MethodCallExpression Call(Expression instance, MethodInfo method, Expression arg0, Expression arg1)
public MethodCallExpression Call(Expression instance, MethodInfo method, Expression arg0, Expression arg1, Expression arg2)
public MethodCallExpression Call(Expression instance, string methodName, Type[] typeArguments, Expression[] arguments)
public MethodCallExpression Call(Type type, string methodName, Type[] typeArguments, Expression[] arguments)
public MethodCallExpression Call(Expression instance, MethodInfo method, IEnumerable`1<Expression> arguments)
private ParameterInfo[] ValidateMethodAndGetParameters(Expression instance, MethodInfo method)
private void ValidateStaticOrInstanceMethod(Expression instance, MethodInfo method)
private void ValidateCallInstanceType(Type instanceType, MethodInfo method)
private void ValidateArgumentTypes(MethodBase method, ExpressionType nodeKind, ReadOnlyCollection`1& arguments, string methodParamName)
private ParameterInfo[] GetParametersForValidation(MethodBase method, ExpressionType nodeKind)
private void ValidateArgumentCount(MethodBase method, ExpressionType nodeKind, int count, ParameterInfo[] pis)
private Expression ValidateOneArgument(MethodBase method, ExpressionType nodeKind, Expression arg, ParameterInfo pi, string methodParamName, string argumentParamName)
private bool TryQuote(Type parameterType, Expression& argument)
private MethodInfo FindMethod(Type type, string methodName, Type[] typeArgs, Expression[] args, BindingFlags flags)
private bool IsCompatible(MethodBase m, Expression[] arguments)
private MethodInfo ApplyTypeArgs(MethodInfo m, Type[] typeArgs)
public MethodCallExpression ArrayIndex(Expression array, Expression[] indexes)
public MethodCallExpression ArrayIndex(Expression array, IEnumerable`1<Expression> indexes)
public NewArrayExpression NewArrayInit(Type type, Expression[] initializers)
public NewArrayExpression NewArrayInit(Type type, IEnumerable`1<Expression> initializers)
public NewArrayExpression NewArrayBounds(Type type, Expression[] bounds)
public NewArrayExpression NewArrayBounds(Type type, IEnumerable`1<Expression> bounds)
public NewExpression New(ConstructorInfo constructor)
public NewExpression New(ConstructorInfo constructor, Expression[] arguments)
public NewExpression New(ConstructorInfo constructor, IEnumerable`1<Expression> arguments)
public NewExpression New(ConstructorInfo constructor, IEnumerable`1<Expression> arguments, IEnumerable`1<MemberInfo> members)
public NewExpression New(ConstructorInfo constructor, IEnumerable`1<Expression> arguments, MemberInfo[] members)
public NewExpression New(Type type)
private void ValidateNewArgs(ConstructorInfo constructor, ReadOnlyCollection`1& arguments, ReadOnlyCollection`1& members)
private void ValidateAnonymousTypeMember(MemberInfo& member, Type& memberType, string paramName, int index)
private void ValidateConstructor(ConstructorInfo constructor, string paramName)
public ParameterExpression Parameter(Type type)
public ParameterExpression Variable(Type type)
public ParameterExpression Parameter(Type type, string name)
public ParameterExpression Variable(Type type, string name)
private void Validate(Type type, bool allowByRef)
public RuntimeVariablesExpression RuntimeVariables(ParameterExpression[] variables)
public RuntimeVariablesExpression RuntimeVariables(IEnumerable`1<ParameterExpression> variables)
public SwitchCase SwitchCase(Expression body, Expression[] testValues)
public SwitchCase SwitchCase(Expression body, IEnumerable`1<Expression> testValues)
public SwitchExpression Switch(Expression switchValue, SwitchCase[] cases)
public SwitchExpression Switch(Expression switchValue, Expression defaultBody, SwitchCase[] cases)
public SwitchExpression Switch(Expression switchValue, Expression defaultBody, MethodInfo comparison, SwitchCase[] cases)
public SwitchExpression Switch(Type type, Expression switchValue, Expression defaultBody, MethodInfo comparison, SwitchCase[] cases)
public SwitchExpression Switch(Expression switchValue, Expression defaultBody, MethodInfo comparison, IEnumerable`1<SwitchCase> cases)
public SwitchExpression Switch(Type type, Expression switchValue, Expression defaultBody, MethodInfo comparison, IEnumerable`1<SwitchCase> cases)
private void ValidateSwitchCaseType(Expression case, bool customType, Type resultType, string parameterName)
public SymbolDocumentInfo SymbolDocument(string fileName)
public SymbolDocumentInfo SymbolDocument(string fileName, Guid language)
public SymbolDocumentInfo SymbolDocument(string fileName, Guid language, Guid languageVendor)
public SymbolDocumentInfo SymbolDocument(string fileName, Guid language, Guid languageVendor, Guid documentType)
public TryExpression TryFault(Expression body, Expression fault)
public TryExpression TryFinally(Expression body, Expression finally)
public TryExpression TryCatch(Expression body, CatchBlock[] handlers)
public TryExpression TryCatchFinally(Expression body, Expression finally, CatchBlock[] handlers)
public TryExpression MakeTry(Type type, Expression body, Expression finally, Expression fault, IEnumerable`1<CatchBlock> handlers)
private void ValidateTryAndCatchHaveSameType(Type type, Expression tryBody, ReadOnlyCollection`1<CatchBlock> handlers)
public TypeBinaryExpression TypeIs(Expression expression, Type type)
public TypeBinaryExpression TypeEqual(Expression expression, Type type)
public UnaryExpression MakeUnary(ExpressionType unaryType, Expression operand, Type type)
public UnaryExpression MakeUnary(ExpressionType unaryType, Expression operand, Type type, MethodInfo method)
private UnaryExpression GetUserDefinedUnaryOperatorOrThrow(ExpressionType unaryType, string name, Expression operand)
private UnaryExpression GetUserDefinedUnaryOperator(ExpressionType unaryType, string name, Expression operand)
private UnaryExpression GetMethodBasedUnaryOperator(ExpressionType unaryType, Expression operand, MethodInfo method)
private UnaryExpression GetUserDefinedCoercionOrThrow(ExpressionType coercionType, Expression expression, Type convertToType)
private UnaryExpression GetUserDefinedCoercion(ExpressionType coercionType, Expression expression, Type convertToType)
private UnaryExpression GetMethodBasedCoercionOperator(ExpressionType unaryType, Expression operand, Type convertToType, MethodInfo method)
public UnaryExpression Negate(Expression expression)
public UnaryExpression Negate(Expression expression, MethodInfo method)
public UnaryExpression UnaryPlus(Expression expression)
public UnaryExpression UnaryPlus(Expression expression, MethodInfo method)
public UnaryExpression NegateChecked(Expression expression)
public UnaryExpression NegateChecked(Expression expression, MethodInfo method)
public UnaryExpression Not(Expression expression)
public UnaryExpression Not(Expression expression, MethodInfo method)
public UnaryExpression IsFalse(Expression expression)
public UnaryExpression IsFalse(Expression expression, MethodInfo method)
public UnaryExpression IsTrue(Expression expression)
public UnaryExpression IsTrue(Expression expression, MethodInfo method)
public UnaryExpression OnesComplement(Expression expression)
public UnaryExpression OnesComplement(Expression expression, MethodInfo method)
public UnaryExpression TypeAs(Expression expression, Type type)
public UnaryExpression Unbox(Expression expression, Type type)
public UnaryExpression Convert(Expression expression, Type type)
public UnaryExpression Convert(Expression expression, Type type, MethodInfo method)
public UnaryExpression ConvertChecked(Expression expression, Type type)
public UnaryExpression ConvertChecked(Expression expression, Type type, MethodInfo method)
public UnaryExpression ArrayLength(Expression array)
public UnaryExpression Quote(Expression expression)
public UnaryExpression Rethrow()
public UnaryExpression Rethrow(Type type)
public UnaryExpression Throw(Expression value)
public UnaryExpression Throw(Expression value, Type type)
public UnaryExpression Increment(Expression expression)
public UnaryExpression Increment(Expression expression, MethodInfo method)
public UnaryExpression Decrement(Expression expression)
public UnaryExpression Decrement(Expression expression, MethodInfo method)
public UnaryExpression PreIncrementAssign(Expression expression)
public UnaryExpression PreIncrementAssign(Expression expression, MethodInfo method)
public UnaryExpression PreDecrementAssign(Expression expression)
public UnaryExpression PreDecrementAssign(Expression expression, MethodInfo method)
public UnaryExpression PostIncrementAssign(Expression expression)
public UnaryExpression PostIncrementAssign(Expression expression, MethodInfo method)
public UnaryExpression PostDecrementAssign(Expression expression)
public UnaryExpression PostDecrementAssign(Expression expression, MethodInfo method)
private UnaryExpression MakeOpAssignUnary(ExpressionType kind, Expression expression, MethodInfo method)
}
public System.Linq.Expressions.Expression`1 : LambdaExpression {
internal Type TypeCore
internal Type PublicType
internal void .ctor(Expression body)
internal Type get_TypeCore()
internal Type get_PublicType()
public TDelegate Compile()
public TDelegate Compile(bool preferInterpretation)
public Expression`1<TDelegate> Update(Expression body, IEnumerable`1<ParameterExpression> parameters)
internal bool SameParameters(ICollection`1<ParameterExpression> parameters)
internal Expression`1<TDelegate> Rewrite(Expression body, ParameterExpression[] parameters)
protected internal Expression Accept(ExpressionVisitor visitor)
internal LambdaExpression Accept(StackSpiller spiller)
internal Expression`1<TDelegate> Create(Expression body, string name, bool tailCall, IReadOnlyList`1<ParameterExpression> parameters)
public TDelegate Compile(DebugInfoGenerator debugInfoGenerator)
}
internal System.Linq.Expressions.Expression0`1 : Expression`1<TDelegate> {
internal int ParameterCount
public void .ctor(Expression body)
internal int get_ParameterCount()
internal bool SameParameters(ICollection`1<ParameterExpression> parameters)
internal ParameterExpression GetParameter(int index)
internal ReadOnlyCollection`1<ParameterExpression> GetOrMakeParameters()
internal Expression`1<TDelegate> Rewrite(Expression body, ParameterExpression[] parameters)
}
internal System.Linq.Expressions.Expression1`1 : Expression`1<TDelegate> {
private object _par0
internal int ParameterCount
public void .ctor(Expression body, ParameterExpression par0)
internal int get_ParameterCount()
internal ParameterExpression GetParameter(int index)
internal bool SameParameters(ICollection`1<ParameterExpression> parameters)
internal ReadOnlyCollection`1<ParameterExpression> GetOrMakeParameters()
internal Expression`1<TDelegate> Rewrite(Expression body, ParameterExpression[] parameters)
}
internal System.Linq.Expressions.Expression2`1 : Expression`1<TDelegate> {
private object _par0
private ParameterExpression _par1
internal int ParameterCount
public void .ctor(Expression body, ParameterExpression par0, ParameterExpression par1)
internal int get_ParameterCount()
internal ParameterExpression GetParameter(int index)
internal bool SameParameters(ICollection`1<ParameterExpression> parameters)
internal ReadOnlyCollection`1<ParameterExpression> GetOrMakeParameters()
internal Expression`1<TDelegate> Rewrite(Expression body, ParameterExpression[] parameters)
}
internal System.Linq.Expressions.Expression3`1 : Expression`1<TDelegate> {
private object _par0
private ParameterExpression _par1
private ParameterExpression _par2
internal int ParameterCount
public void .ctor(Expression body, ParameterExpression par0, ParameterExpression par1, ParameterExpression par2)
internal int get_ParameterCount()
internal ParameterExpression GetParameter(int index)
internal bool SameParameters(ICollection`1<ParameterExpression> parameters)
internal ReadOnlyCollection`1<ParameterExpression> GetOrMakeParameters()
internal Expression`1<TDelegate> Rewrite(Expression body, ParameterExpression[] parameters)
}
internal System.Linq.Expressions.ExpressionExtension : object {
public DynamicExpression MakeDynamic(Type delegateType, CallSiteBinder binder, Expression[] arguments)
public DynamicExpression MakeDynamic(Type delegateType, CallSiteBinder binder, IEnumerable`1<Expression> arguments)
public DynamicExpression MakeDynamic(Type delegateType, CallSiteBinder binder, Expression arg0)
public DynamicExpression MakeDynamic(Type delegateType, CallSiteBinder binder, Expression arg0, Expression arg1)
public DynamicExpression MakeDynamic(Type delegateType, CallSiteBinder binder, Expression arg0, Expression arg1, Expression arg2)
public DynamicExpression MakeDynamic(Type delegateType, CallSiteBinder binder, Expression arg0, Expression arg1, Expression arg2, Expression arg3)
private MethodInfo GetValidMethodForDynamic(Type delegateType)
public DynamicExpression Dynamic(CallSiteBinder binder, Type returnType, Expression[] arguments)
public DynamicExpression Dynamic(CallSiteBinder binder, Type returnType, Expression arg0)
public DynamicExpression Dynamic(CallSiteBinder binder, Type returnType, Expression arg0, Expression arg1)
public DynamicExpression Dynamic(CallSiteBinder binder, Type returnType, Expression arg0, Expression arg1, Expression arg2)
public DynamicExpression Dynamic(CallSiteBinder binder, Type returnType, Expression arg0, Expression arg1, Expression arg2, Expression arg3)
public DynamicExpression Dynamic(CallSiteBinder binder, Type returnType, IEnumerable`1<Expression> arguments)
private DynamicExpression MakeDynamic(CallSiteBinder binder, Type returnType, ReadOnlyCollection`1<Expression> arguments)
private void ValidateDynamicArgument(Expression arg, string paramName)
private void ValidateDynamicArgument(Expression arg, string paramName, int index)
}
internal System.Linq.Expressions.ExpressionN`1 : Expression`1<TDelegate> {
private IReadOnlyList`1<ParameterExpression> _parameters
internal int ParameterCount
public void .ctor(Expression body, IReadOnlyList`1<ParameterExpression> parameters)
internal int get_ParameterCount()
internal ParameterExpression GetParameter(int index)
internal bool SameParameters(ICollection`1<ParameterExpression> parameters)
internal ReadOnlyCollection`1<ParameterExpression> GetOrMakeParameters()
internal Expression`1<TDelegate> Rewrite(Expression body, ParameterExpression[] parameters)
}
internal System.Linq.Expressions.ExpressionStringBuilder : ExpressionVisitor {
private StringBuilder _out
private Dictionary`2<object, int> _ids
public string ToString()
private int GetLabelId(LabelTarget label)
private int GetParamId(ParameterExpression p)
private int GetId(object o)
private void Out(string s)
private void Out(char c)
internal string ExpressionToString(Expression node)
internal string CatchBlockToString(CatchBlock node)
internal string SwitchCaseToString(SwitchCase node)
internal string MemberBindingToString(MemberBinding node)
internal string ElementInitBindingToString(ElementInit node)
private void VisitExpressions(char open, ReadOnlyCollection`1<T> expressions, char close)
private void VisitExpressions(char open, ReadOnlyCollection`1<T> expressions, char close, string seperator)
protected internal Expression VisitBinary(BinaryExpression node)
protected internal Expression VisitParameter(ParameterExpression node)
protected internal Expression VisitLambda(Expression`1<T> node)
protected internal Expression VisitListInit(ListInitExpression node)
protected internal Expression VisitConditional(ConditionalExpression node)
protected internal Expression VisitConstant(ConstantExpression node)
protected internal Expression VisitDebugInfo(DebugInfoExpression node)
protected internal Expression VisitRuntimeVariables(RuntimeVariablesExpression node)
private void OutMember(Expression instance, MemberInfo member)
protected internal Expression VisitMember(MemberExpression node)
protected internal Expression VisitMemberInit(MemberInitExpression node)
protected MemberAssignment VisitMemberAssignment(MemberAssignment assignment)
protected MemberListBinding VisitMemberListBinding(MemberListBinding binding)
protected MemberMemberBinding VisitMemberMemberBinding(MemberMemberBinding binding)
protected ElementInit VisitElementInit(ElementInit initializer)
protected internal Expression VisitInvocation(InvocationExpression node)
protected internal Expression VisitMethodCall(MethodCallExpression node)
protected internal Expression VisitNewArray(NewArrayExpression node)
protected internal Expression VisitNew(NewExpression node)
protected internal Expression VisitTypeBinary(TypeBinaryExpression node)
protected internal Expression VisitUnary(UnaryExpression node)
protected internal Expression VisitBlock(BlockExpression node)
protected internal Expression VisitDefault(DefaultExpression node)
protected internal Expression VisitLabel(LabelExpression node)
protected internal Expression VisitGoto(GotoExpression node)
protected internal Expression VisitLoop(LoopExpression node)
protected SwitchCase VisitSwitchCase(SwitchCase node)
protected internal Expression VisitSwitch(SwitchExpression node)
protected CatchBlock VisitCatchBlock(CatchBlock node)
protected internal Expression VisitTry(TryExpression node)
protected internal Expression VisitIndex(IndexExpression node)
protected internal Expression VisitExtension(Expression node)
private void DumpLabel(LabelTarget target)
private bool IsBool(Expression node)
}
public System.Linq.Expressions.ExpressionType : Enum {
public int value__
public ExpressionType Add
public ExpressionType AddChecked
public ExpressionType And
public ExpressionType AndAlso
public ExpressionType ArrayLength
public ExpressionType ArrayIndex
public ExpressionType Call
public ExpressionType Coalesce
public ExpressionType Conditional
public ExpressionType Constant
public ExpressionType Convert
public ExpressionType ConvertChecked
public ExpressionType Divide
public ExpressionType Equal
public ExpressionType ExclusiveOr
public ExpressionType GreaterThan
public ExpressionType GreaterThanOrEqual
public ExpressionType Invoke
public ExpressionType Lambda
public ExpressionType LeftShift
public ExpressionType LessThan
public ExpressionType LessThanOrEqual
public ExpressionType ListInit
public ExpressionType MemberAccess
public ExpressionType MemberInit
public ExpressionType Modulo
public ExpressionType Multiply
public ExpressionType MultiplyChecked
public ExpressionType Negate
public ExpressionType UnaryPlus
public ExpressionType NegateChecked
public ExpressionType New
public ExpressionType NewArrayInit
public ExpressionType NewArrayBounds
public ExpressionType Not
public ExpressionType NotEqual
public ExpressionType Or
public ExpressionType OrElse
public ExpressionType Parameter
public ExpressionType Power
public ExpressionType Quote
public ExpressionType RightShift
public ExpressionType Subtract
public ExpressionType SubtractChecked
public ExpressionType TypeAs
public ExpressionType TypeIs
public ExpressionType Assign
public ExpressionType Block
public ExpressionType DebugInfo
public ExpressionType Decrement
public ExpressionType Dynamic
public ExpressionType Default
public ExpressionType Extension
public ExpressionType Goto
public ExpressionType Increment
public ExpressionType Index
public ExpressionType Label
public ExpressionType RuntimeVariables
public ExpressionType Loop
public ExpressionType Switch
public ExpressionType Throw
public ExpressionType Try
public ExpressionType Unbox
public ExpressionType AddAssign
public ExpressionType AndAssign
public ExpressionType DivideAssign
public ExpressionType ExclusiveOrAssign
public ExpressionType LeftShiftAssign
public ExpressionType ModuloAssign
public ExpressionType MultiplyAssign
public ExpressionType OrAssign
public ExpressionType PowerAssign
public ExpressionType RightShiftAssign
public ExpressionType SubtractAssign
public ExpressionType AddAssignChecked
public ExpressionType MultiplyAssignChecked
public ExpressionType SubtractAssignChecked
public ExpressionType PreIncrementAssign
public ExpressionType PreDecrementAssign
public ExpressionType PostIncrementAssign
public ExpressionType PostDecrementAssign
public ExpressionType TypeEqual
public ExpressionType OnesComplement
public ExpressionType IsTrue
public ExpressionType IsFalse
}
public System.Linq.Expressions.ExpressionVisitor : object {
public Expression Visit(Expression node)
public ReadOnlyCollection`1<Expression> Visit(ReadOnlyCollection`1<Expression> nodes)
private Expression[] VisitArguments(IArgumentProvider nodes)
private ParameterExpression[] VisitParameters(IParameterProvider nodes, string callerName)
public ReadOnlyCollection`1<T> Visit(ReadOnlyCollection`1<T> nodes, Func`2<T, T> elementVisitor)
public T VisitAndConvert(T node, string callerName)
public ReadOnlyCollection`1<T> VisitAndConvert(ReadOnlyCollection`1<T> nodes, string callerName)
protected internal Expression VisitBinary(BinaryExpression node)
protected internal Expression VisitBlock(BlockExpression node)
protected internal Expression VisitConditional(ConditionalExpression node)
protected internal Expression VisitConstant(ConstantExpression node)
protected internal Expression VisitDebugInfo(DebugInfoExpression node)
protected internal Expression VisitDefault(DefaultExpression node)
protected internal Expression VisitExtension(Expression node)
protected internal Expression VisitGoto(GotoExpression node)
protected internal Expression VisitInvocation(InvocationExpression node)
protected LabelTarget VisitLabelTarget(LabelTarget node)
protected internal Expression VisitLabel(LabelExpression node)
protected internal Expression VisitLambda(Expression`1<T> node)
protected internal Expression VisitLoop(LoopExpression node)
protected internal Expression VisitMember(MemberExpression node)
protected internal Expression VisitIndex(IndexExpression node)
protected internal Expression VisitMethodCall(MethodCallExpression node)
protected internal Expression VisitNewArray(NewArrayExpression node)
protected internal Expression VisitNew(NewExpression node)
protected internal Expression VisitParameter(ParameterExpression node)
protected internal Expression VisitRuntimeVariables(RuntimeVariablesExpression node)
protected SwitchCase VisitSwitchCase(SwitchCase node)
protected internal Expression VisitSwitch(SwitchExpression node)
protected CatchBlock VisitCatchBlock(CatchBlock node)
protected internal Expression VisitTry(TryExpression node)
protected internal Expression VisitTypeBinary(TypeBinaryExpression node)
protected internal Expression VisitUnary(UnaryExpression node)
protected internal Expression VisitMemberInit(MemberInitExpression node)
protected internal Expression VisitListInit(ListInitExpression node)
protected ElementInit VisitElementInit(ElementInit node)
protected MemberBinding VisitMemberBinding(MemberBinding node)
protected MemberAssignment VisitMemberAssignment(MemberAssignment node)
protected MemberMemberBinding VisitMemberMemberBinding(MemberMemberBinding node)
protected MemberListBinding VisitMemberListBinding(MemberListBinding node)
private UnaryExpression ValidateUnary(UnaryExpression before, UnaryExpression after)
private BinaryExpression ValidateBinary(BinaryExpression before, BinaryExpression after)
private SwitchExpression ValidateSwitch(SwitchExpression before, SwitchExpression after)
private void ValidateChildType(Type before, Type after, string methodName)
protected internal Expression VisitDynamic(DynamicExpression node)
}
internal System.Linq.Expressions.FieldExpression : MemberExpression {
private FieldInfo _field
public Type Type
public void .ctor(Expression expression, FieldInfo member)
internal MemberInfo GetMember()
public Type get_Type()
}
internal System.Linq.Expressions.FullConditionalExpression : ConditionalExpression {
private Expression _false
internal void .ctor(Expression test, Expression ifTrue, Expression ifFalse)
internal Expression GetFalse()
}
internal System.Linq.Expressions.FullConditionalExpressionWithType : FullConditionalExpression {
private Type <Type>k__BackingField
public Type Type
internal void .ctor(Expression test, Expression ifTrue, Expression ifFalse, Type type)
public Type get_Type()
}
internal System.Linq.Expressions.FullExpression`1 : ExpressionN`1<TDelegate> {
private string <NameCore>k__BackingField
private bool <TailCallCore>k__BackingField
internal string NameCore
internal bool TailCallCore
public void .ctor(Expression body, string name, bool tailCall, IReadOnlyList`1<ParameterExpression> parameters)
internal string get_NameCore()
internal bool get_TailCallCore()
}
public System.Linq.Expressions.GotoExpression : Expression {
private Type <Type>k__BackingField
private Expression <Value>k__BackingField
private LabelTarget <Target>k__BackingField
private GotoExpressionKind <Kind>k__BackingField
public Type Type
public ExpressionType NodeType
public Expression Value
public LabelTarget Target
public GotoExpressionKind Kind
internal void .ctor(GotoExpressionKind kind, LabelTarget target, Expression value, Type type)
public Type get_Type()
public ExpressionType get_NodeType()
public Expression get_Value()
public LabelTarget get_Target()
public GotoExpressionKind get_Kind()
protected internal Expression Accept(ExpressionVisitor visitor)
public GotoExpression Update(LabelTarget target, Expression value)
}
public System.Linq.Expressions.GotoExpressionKind : Enum {
public int value__
public GotoExpressionKind Goto
public GotoExpressionKind Return
public GotoExpressionKind Break
public GotoExpressionKind Continue
}
public System.Linq.Expressions.IArgumentProvider {
public int ArgumentCount
public Expression GetArgument(int index)
public int get_ArgumentCount()
}
public System.Linq.Expressions.IDynamicExpression {
public Type DelegateType
public Type get_DelegateType()
public Expression Rewrite(Expression[] args)
public object CreateCallSite()
}
public System.Linq.Expressions.IndexExpression : Expression {
private IReadOnlyList`1<Expression> _arguments
private Expression <Object>k__BackingField
private PropertyInfo <Indexer>k__BackingField
public ExpressionType NodeType
public Type Type
public Expression Object
public PropertyInfo Indexer
public ReadOnlyCollection`1<Expression> Arguments
public int ArgumentCount
internal void .ctor(Expression instance, PropertyInfo indexer, IReadOnlyList`1<Expression> arguments)
public ExpressionType get_NodeType()
public Type get_Type()
public Expression get_Object()
public PropertyInfo get_Indexer()
public ReadOnlyCollection`1<Expression> get_Arguments()
public IndexExpression Update(Expression object, IEnumerable`1<Expression> arguments)
public Expression GetArgument(int index)
public int get_ArgumentCount()
protected internal Expression Accept(ExpressionVisitor visitor)
internal Expression Rewrite(Expression instance, Expression[] arguments)
}
internal System.Linq.Expressions.InstanceMethodCallExpression : MethodCallExpression {
private Expression _instance
public void .ctor(MethodInfo method, Expression instance)
internal Expression GetInstance()
}
internal System.Linq.Expressions.InstanceMethodCallExpression0 : InstanceMethodCallExpression {
public int ArgumentCount
public void .ctor(MethodInfo method, Expression instance)
public Expression GetArgument(int index)
public int get_ArgumentCount()
internal ReadOnlyCollection`1<Expression> GetOrMakeArguments()
internal bool SameArguments(ICollection`1<Expression> arguments)
internal MethodCallExpression Rewrite(Expression instance, IReadOnlyList`1<Expression> args)
}
internal System.Linq.Expressions.InstanceMethodCallExpression1 : InstanceMethodCallExpression {
private object _arg0
public int ArgumentCount
public void .ctor(MethodInfo method, Expression instance, Expression arg0)
public Expression GetArgument(int index)
public int get_ArgumentCount()
internal bool SameArguments(ICollection`1<Expression> arguments)
internal ReadOnlyCollection`1<Expression> GetOrMakeArguments()
internal MethodCallExpression Rewrite(Expression instance, IReadOnlyList`1<Expression> args)
}
internal System.Linq.Expressions.InstanceMethodCallExpression2 : InstanceMethodCallExpression {
private object _arg0
private Expression _arg1
public int ArgumentCount
public void .ctor(MethodInfo method, Expression instance, Expression arg0, Expression arg1)
public Expression GetArgument(int index)
public int get_ArgumentCount()
internal bool SameArguments(ICollection`1<Expression> arguments)
internal ReadOnlyCollection`1<Expression> GetOrMakeArguments()
internal MethodCallExpression Rewrite(Expression instance, IReadOnlyList`1<Expression> args)
}
internal System.Linq.Expressions.InstanceMethodCallExpression3 : InstanceMethodCallExpression {
private object _arg0
private Expression _arg1
private Expression _arg2
public int ArgumentCount
public void .ctor(MethodInfo method, Expression instance, Expression arg0, Expression arg1, Expression arg2)
public Expression GetArgument(int index)
public int get_ArgumentCount()
internal bool SameArguments(ICollection`1<Expression> arguments)
internal ReadOnlyCollection`1<Expression> GetOrMakeArguments()
internal MethodCallExpression Rewrite(Expression instance, IReadOnlyList`1<Expression> args)
}
internal System.Linq.Expressions.InstanceMethodCallExpressionN : InstanceMethodCallExpression {
private IReadOnlyList`1<Expression> _arguments
public int ArgumentCount
public void .ctor(MethodInfo method, Expression instance, IReadOnlyList`1<Expression> args)
public Expression GetArgument(int index)
public int get_ArgumentCount()
internal bool SameArguments(ICollection`1<Expression> arguments)
internal ReadOnlyCollection`1<Expression> GetOrMakeArguments()
internal MethodCallExpression Rewrite(Expression instance, IReadOnlyList`1<Expression> args)
}
public System.Linq.Expressions.InvocationExpression : Expression {
private Type <Type>k__BackingField
private Expression <Expression>k__BackingField
public Type Type
public ExpressionType NodeType
public Expression Expression
public ReadOnlyCollection`1<Expression> Arguments
public int ArgumentCount
internal LambdaExpression LambdaOperand
internal void .ctor(Expression expression, Type returnType)
public Type get_Type()
public ExpressionType get_NodeType()
public Expression get_Expression()
public ReadOnlyCollection`1<Expression> get_Arguments()
public InvocationExpression Update(Expression expression, IEnumerable`1<Expression> arguments)
internal ReadOnlyCollection`1<Expression> GetOrMakeArguments()
public Expression GetArgument(int index)
public int get_ArgumentCount()
protected internal Expression Accept(ExpressionVisitor visitor)
internal InvocationExpression Rewrite(Expression lambda, Expression[] arguments)
internal LambdaExpression get_LambdaOperand()
}
internal System.Linq.Expressions.InvocationExpression0 : InvocationExpression {
public int ArgumentCount
public void .ctor(Expression lambda, Type returnType)
internal ReadOnlyCollection`1<Expression> GetOrMakeArguments()
public Expression GetArgument(int index)
public int get_ArgumentCount()
internal InvocationExpression Rewrite(Expression lambda, Expression[] arguments)
}
internal System.Linq.Expressions.InvocationExpression1 : InvocationExpression {
private object _arg0
public int ArgumentCount
public void .ctor(Expression lambda, Type returnType, Expression arg0)
internal ReadOnlyCollection`1<Expression> GetOrMakeArguments()
public Expression GetArgument(int index)
public int get_ArgumentCount()
internal InvocationExpression Rewrite(Expression lambda, Expression[] arguments)
}
internal System.Linq.Expressions.InvocationExpression2 : InvocationExpression {
private object _arg0
private Expression _arg1
public int ArgumentCount
public void .ctor(Expression lambda, Type returnType, Expression arg0, Expression arg1)
internal ReadOnlyCollection`1<Expression> GetOrMakeArguments()
public Expression GetArgument(int index)
public int get_ArgumentCount()
internal InvocationExpression Rewrite(Expression lambda, Expression[] arguments)
}
internal System.Linq.Expressions.InvocationExpression3 : InvocationExpression {
private object _arg0
private Expression _arg1
private Expression _arg2
public int ArgumentCount
public void .ctor(Expression lambda, Type returnType, Expression arg0, Expression arg1, Expression arg2)
internal ReadOnlyCollection`1<Expression> GetOrMakeArguments()
public Expression GetArgument(int index)
public int get_ArgumentCount()
internal InvocationExpression Rewrite(Expression lambda, Expression[] arguments)
}
internal System.Linq.Expressions.InvocationExpression4 : InvocationExpression {
private object _arg0
private Expression _arg1
private Expression _arg2
private Expression _arg3
public int ArgumentCount
public void .ctor(Expression lambda, Type returnType, Expression arg0, Expression arg1, Expression arg2, Expression arg3)
internal ReadOnlyCollection`1<Expression> GetOrMakeArguments()
public Expression GetArgument(int index)
public int get_ArgumentCount()
internal InvocationExpression Rewrite(Expression lambda, Expression[] arguments)
}
internal System.Linq.Expressions.InvocationExpression5 : InvocationExpression {
private object _arg0
private Expression _arg1
private Expression _arg2
private Expression _arg3
private Expression _arg4
public int ArgumentCount
public void .ctor(Expression lambda, Type returnType, Expression arg0, Expression arg1, Expression arg2, Expression arg3, Expression arg4)
internal ReadOnlyCollection`1<Expression> GetOrMakeArguments()
public Expression GetArgument(int index)
public int get_ArgumentCount()
internal InvocationExpression Rewrite(Expression lambda, Expression[] arguments)
}
internal System.Linq.Expressions.InvocationExpressionN : InvocationExpression {
private IReadOnlyList`1<Expression> _arguments
public int ArgumentCount
public void .ctor(Expression lambda, IReadOnlyList`1<Expression> arguments, Type returnType)
internal ReadOnlyCollection`1<Expression> GetOrMakeArguments()
public Expression GetArgument(int index)
public int get_ArgumentCount()
internal InvocationExpression Rewrite(Expression lambda, Expression[] arguments)
}
internal System.Linq.Expressions.IParameterProvider {
public int ParameterCount
public ParameterExpression GetParameter(int index)
public int get_ParameterCount()
}
public System.Linq.Expressions.LabelExpression : Expression {
private LabelTarget <Target>k__BackingField
private Expression <DefaultValue>k__BackingField
public Type Type
public ExpressionType NodeType
public LabelTarget Target
public Expression DefaultValue
internal void .ctor(LabelTarget label, Expression defaultValue)
public Type get_Type()
public ExpressionType get_NodeType()
public LabelTarget get_Target()
public Expression get_DefaultValue()
protected internal Expression Accept(ExpressionVisitor visitor)
public LabelExpression Update(LabelTarget target, Expression defaultValue)
}
public System.Linq.Expressions.LabelTarget : object {
private string <Name>k__BackingField
private Type <Type>k__BackingField
public string Name
public Type Type
internal void .ctor(Type type, string name)
public string get_Name()
public Type get_Type()
public string ToString()
}
public System.Linq.Expressions.LambdaExpression : Expression {
private Expression _body
public Type Type
internal Type TypeCore
internal Type PublicType
public ExpressionType NodeType
public ReadOnlyCollection`1<ParameterExpression> Parameters
public string Name
internal string NameCore
public Expression Body
public Type ReturnType
public bool TailCall
internal bool TailCallCore
private int System.Linq.Expressions.IParameterProvider.ParameterCount
internal int ParameterCount
internal void .ctor(Expression body)
public Type get_Type()
internal Type get_TypeCore()
internal Type get_PublicType()
public ExpressionType get_NodeType()
public ReadOnlyCollection`1<ParameterExpression> get_Parameters()
public string get_Name()
internal string get_NameCore()
public Expression get_Body()
public Type get_ReturnType()
public bool get_TailCall()
internal bool get_TailCallCore()
internal ReadOnlyCollection`1<ParameterExpression> GetOrMakeParameters()
private ParameterExpression System.Linq.Expressions.IParameterProvider.GetParameter(int index)
internal ParameterExpression GetParameter(int index)
private int System.Linq.Expressions.IParameterProvider.get_ParameterCount()
internal int get_ParameterCount()
public Delegate Compile()
public Delegate Compile(bool preferInterpretation)
public void CompileToMethod(MethodBuilder method)
internal LambdaExpression Accept(StackSpiller spiller)
public Delegate Compile(DebugInfoGenerator debugInfoGenerator)
public void CompileToMethod(MethodBuilder method, DebugInfoGenerator debugInfoGenerator)
}
public System.Linq.Expressions.ListInitExpression : Expression {
private NewExpression <NewExpression>k__BackingField
private ReadOnlyCollection`1<ElementInit> <Initializers>k__BackingField
public ExpressionType NodeType
public Type Type
public bool CanReduce
public NewExpression NewExpression
public ReadOnlyCollection`1<ElementInit> Initializers
internal void .ctor(NewExpression newExpression, ReadOnlyCollection`1<ElementInit> initializers)
public ExpressionType get_NodeType()
public Type get_Type()
public bool get_CanReduce()
public NewExpression get_NewExpression()
public ReadOnlyCollection`1<ElementInit> get_Initializers()
protected internal Expression Accept(ExpressionVisitor visitor)
public Expression Reduce()
public ListInitExpression Update(NewExpression newExpression, IEnumerable`1<ElementInit> initializers)
}
internal System.Linq.Expressions.LogicalBinaryExpression : BinaryExpression {
private ExpressionType <NodeType>k__BackingField
public Type Type
public ExpressionType NodeType
internal void .ctor(ExpressionType nodeType, Expression left, Expression right)
public Type get_Type()
public ExpressionType get_NodeType()
}
public System.Linq.Expressions.LoopExpression : Expression {
private Expression <Body>k__BackingField
private LabelTarget <BreakLabel>k__BackingField
private LabelTarget <ContinueLabel>k__BackingField
public Type Type
public ExpressionType NodeType
public Expression Body
public LabelTarget BreakLabel
public LabelTarget ContinueLabel
internal void .ctor(Expression body, LabelTarget break, LabelTarget continue)
public Type get_Type()
public ExpressionType get_NodeType()
public Expression get_Body()
public LabelTarget get_BreakLabel()
public LabelTarget get_ContinueLabel()
protected internal Expression Accept(ExpressionVisitor visitor)
public LoopExpression Update(LabelTarget breakLabel, LabelTarget continueLabel, Expression body)
}
public System.Linq.Expressions.MemberAssignment : MemberBinding {
private Expression _expression
public Expression Expression
internal void .ctor(MemberInfo member, Expression expression)
public Expression get_Expression()
public MemberAssignment Update(Expression expression)
internal void ValidateAsDefinedHere(int index)
}
public System.Linq.Expressions.MemberBinding : object {
private MemberBindingType <BindingType>k__BackingField
private MemberInfo <Member>k__BackingField
public MemberBindingType BindingType
public MemberInfo Member
protected void .ctor(MemberBindingType type, MemberInfo member)
public MemberBindingType get_BindingType()
public MemberInfo get_Member()
public string ToString()
internal void ValidateAsDefinedHere(int index)
}
public System.Linq.Expressions.MemberBindingType : Enum {
public int value__
public MemberBindingType Assignment
public MemberBindingType MemberBinding
public MemberBindingType ListBinding
}
public System.Linq.Expressions.MemberExpression : Expression {
private Expression <Expression>k__BackingField
public MemberInfo Member
public Expression Expression
public ExpressionType NodeType
public MemberInfo get_Member()
public Expression get_Expression()
internal void .ctor(Expression expression)
internal PropertyExpression Make(Expression expression, PropertyInfo property)
internal FieldExpression Make(Expression expression, FieldInfo field)
internal MemberExpression Make(Expression expression, MemberInfo member)
public ExpressionType get_NodeType()
internal MemberInfo GetMember()
protected internal Expression Accept(ExpressionVisitor visitor)
public MemberExpression Update(Expression expression)
}
public System.Linq.Expressions.MemberInitExpression : Expression {
private NewExpression <NewExpression>k__BackingField
private ReadOnlyCollection`1<MemberBinding> <Bindings>k__BackingField
public Type Type
public bool CanReduce
public ExpressionType NodeType
public NewExpression NewExpression
public ReadOnlyCollection`1<MemberBinding> Bindings
internal void .ctor(NewExpression newExpression, ReadOnlyCollection`1<MemberBinding> bindings)
public Type get_Type()
public bool get_CanReduce()
public ExpressionType get_NodeType()
public NewExpression get_NewExpression()
public ReadOnlyCollection`1<MemberBinding> get_Bindings()
protected internal Expression Accept(ExpressionVisitor visitor)
public Expression Reduce()
private Expression ReduceMemberInit(Expression objExpression, ReadOnlyCollection`1<MemberBinding> bindings, bool keepOnStack)
internal Expression ReduceListInit(Expression listExpression, ReadOnlyCollection`1<ElementInit> initializers, bool keepOnStack)
internal Expression ReduceMemberBinding(ParameterExpression objVar, MemberBinding binding)
public MemberInitExpression Update(NewExpression newExpression, IEnumerable`1<MemberBinding> bindings)
}
public System.Linq.Expressions.MemberListBinding : MemberBinding {
private ReadOnlyCollection`1<ElementInit> <Initializers>k__BackingField
public ReadOnlyCollection`1<ElementInit> Initializers
internal void .ctor(MemberInfo member, ReadOnlyCollection`1<ElementInit> initializers)
public ReadOnlyCollection`1<ElementInit> get_Initializers()
public MemberListBinding Update(IEnumerable`1<ElementInit> initializers)
internal void ValidateAsDefinedHere(int index)
}
public System.Linq.Expressions.MemberMemberBinding : MemberBinding {
private ReadOnlyCollection`1<MemberBinding> <Bindings>k__BackingField
public ReadOnlyCollection`1<MemberBinding> Bindings
internal void .ctor(MemberInfo member, ReadOnlyCollection`1<MemberBinding> bindings)
public ReadOnlyCollection`1<MemberBinding> get_Bindings()
public MemberMemberBinding Update(IEnumerable`1<MemberBinding> bindings)
internal void ValidateAsDefinedHere(int index)
}
internal System.Linq.Expressions.MethodBinaryExpression : SimpleBinaryExpression {
private MethodInfo _method
internal void .ctor(ExpressionType nodeType, Expression left, Expression right, Type type, MethodInfo method)
internal MethodInfo GetMethod()
}
public System.Linq.Expressions.MethodCallExpression : Expression {
private MethodInfo <Method>k__BackingField
public ExpressionType NodeType
public Type Type
public MethodInfo Method
public Expression Object
public ReadOnlyCollection`1<Expression> Arguments
public int ArgumentCount
internal void .ctor(MethodInfo method)
internal Expression GetInstance()
public ExpressionType get_NodeType()
public Type get_Type()
public MethodInfo get_Method()
public Expression get_Object()
public ReadOnlyCollection`1<Expression> get_Arguments()
public MethodCallExpression Update(Expression object, IEnumerable`1<Expression> arguments)
internal bool SameArguments(ICollection`1<Expression> arguments)
internal ReadOnlyCollection`1<Expression> GetOrMakeArguments()
protected internal Expression Accept(ExpressionVisitor visitor)
internal MethodCallExpression Rewrite(Expression instance, IReadOnlyList`1<Expression> args)
public Expression GetArgument(int index)
public int get_ArgumentCount()
}
internal System.Linq.Expressions.MethodCallExpression0 : MethodCallExpression {
public int ArgumentCount
public void .ctor(MethodInfo method)
public Expression GetArgument(int index)
public int get_ArgumentCount()
internal ReadOnlyCollection`1<Expression> GetOrMakeArguments()
internal bool SameArguments(ICollection`1<Expression> arguments)
internal MethodCallExpression Rewrite(Expression instance, IReadOnlyList`1<Expression> args)
}
internal System.Linq.Expressions.MethodCallExpression1 : MethodCallExpression {
private object _arg0
public int ArgumentCount
public void .ctor(MethodInfo method, Expression arg0)
public Expression GetArgument(int index)
public int get_ArgumentCount()
internal ReadOnlyCollection`1<Expression> GetOrMakeArguments()
internal bool SameArguments(ICollection`1<Expression> arguments)
internal MethodCallExpression Rewrite(Expression instance, IReadOnlyList`1<Expression> args)
}
internal System.Linq.Expressions.MethodCallExpression2 : MethodCallExpression {
private object _arg0
private Expression _arg1
public int ArgumentCount
public void .ctor(MethodInfo method, Expression arg0, Expression arg1)
public Expression GetArgument(int index)
public int get_ArgumentCount()
internal bool SameArguments(ICollection`1<Expression> arguments)
internal ReadOnlyCollection`1<Expression> GetOrMakeArguments()
internal MethodCallExpression Rewrite(Expression instance, IReadOnlyList`1<Expression> args)
}
internal System.Linq.Expressions.MethodCallExpression3 : MethodCallExpression {
private object _arg0
private Expression _arg1
private Expression _arg2
public int ArgumentCount
public void .ctor(MethodInfo method, Expression arg0, Expression arg1, Expression arg2)
public Expression GetArgument(int index)
public int get_ArgumentCount()
internal bool SameArguments(ICollection`1<Expression> arguments)
internal ReadOnlyCollection`1<Expression> GetOrMakeArguments()
internal MethodCallExpression Rewrite(Expression instance, IReadOnlyList`1<Expression> args)
}
internal System.Linq.Expressions.MethodCallExpression4 : MethodCallExpression {
private object _arg0
private Expression _arg1
private Expression _arg2
private Expression _arg3
public int ArgumentCount
public void .ctor(MethodInfo method, Expression arg0, Expression arg1, Expression arg2, Expression arg3)
public Expression GetArgument(int index)
public int get_ArgumentCount()
internal bool SameArguments(ICollection`1<Expression> arguments)
internal ReadOnlyCollection`1<Expression> GetOrMakeArguments()
internal MethodCallExpression Rewrite(Expression instance, IReadOnlyList`1<Expression> args)
}
internal System.Linq.Expressions.MethodCallExpression5 : MethodCallExpression {
private object _arg0
private Expression _arg1
private Expression _arg2
private Expression _arg3
private Expression _arg4
public int ArgumentCount
public void .ctor(MethodInfo method, Expression arg0, Expression arg1, Expression arg2, Expression arg3, Expression arg4)
public Expression GetArgument(int index)
public int get_ArgumentCount()
internal bool SameArguments(ICollection`1<Expression> arguments)
internal ReadOnlyCollection`1<Expression> GetOrMakeArguments()
internal MethodCallExpression Rewrite(Expression instance, IReadOnlyList`1<Expression> args)
}
internal System.Linq.Expressions.MethodCallExpressionN : MethodCallExpression {
private IReadOnlyList`1<Expression> _arguments
public int ArgumentCount
public void .ctor(MethodInfo method, IReadOnlyList`1<Expression> args)
public Expression GetArgument(int index)
public int get_ArgumentCount()
internal ReadOnlyCollection`1<Expression> GetOrMakeArguments()
internal bool SameArguments(ICollection`1<Expression> arguments)
internal MethodCallExpression Rewrite(Expression instance, IReadOnlyList`1<Expression> args)
}
internal System.Linq.Expressions.NewArrayBoundsExpression : NewArrayExpression {
public ExpressionType NodeType
internal void .ctor(Type type, ReadOnlyCollection`1<Expression> expressions)
public ExpressionType get_NodeType()
}
public System.Linq.Expressions.NewArrayExpression : Expression {
private Type <Type>k__BackingField
private ReadOnlyCollection`1<Expression> <Expressions>k__BackingField
public Type Type
public ReadOnlyCollection`1<Expression> Expressions
internal void .ctor(Type type, ReadOnlyCollection`1<Expression> expressions)
internal NewArrayExpression Make(ExpressionType nodeType, Type type, ReadOnlyCollection`1<Expression> expressions)
public Type get_Type()
public ReadOnlyCollection`1<Expression> get_Expressions()
protected internal Expression Accept(ExpressionVisitor visitor)
public NewArrayExpression Update(IEnumerable`1<Expression> expressions)
}
internal System.Linq.Expressions.NewArrayInitExpression : NewArrayExpression {
public ExpressionType NodeType
internal void .ctor(Type type, ReadOnlyCollection`1<Expression> expressions)
public ExpressionType get_NodeType()
}
public System.Linq.Expressions.NewExpression : Expression {
private IReadOnlyList`1<Expression> _arguments
private ConstructorInfo <Constructor>k__BackingField
private ReadOnlyCollection`1<MemberInfo> <Members>k__BackingField
public Type Type
public ExpressionType NodeType
public ConstructorInfo Constructor
public ReadOnlyCollection`1<Expression> Arguments
public int ArgumentCount
public ReadOnlyCollection`1<MemberInfo> Members
internal void .ctor(ConstructorInfo constructor, IReadOnlyList`1<Expression> arguments, ReadOnlyCollection`1<MemberInfo> members)
public Type get_Type()
public ExpressionType get_NodeType()
public ConstructorInfo get_Constructor()
public ReadOnlyCollection`1<Expression> get_Arguments()
public Expression GetArgument(int index)
public int get_ArgumentCount()
public ReadOnlyCollection`1<MemberInfo> get_Members()
protected internal Expression Accept(ExpressionVisitor visitor)
public NewExpression Update(IEnumerable`1<Expression> arguments)
}
internal System.Linq.Expressions.NewValueTypeExpression : NewExpression {
private Type <Type>k__BackingField
public Type Type
internal void .ctor(Type type, ReadOnlyCollection`1<Expression> arguments, ReadOnlyCollection`1<MemberInfo> members)
public Type get_Type()
}
internal System.Linq.Expressions.OpAssignMethodConversionBinaryExpression : MethodBinaryExpression {
private LambdaExpression _conversion
internal void .ctor(ExpressionType nodeType, Expression left, Expression right, Type type, MethodInfo method, LambdaExpression conversion)
internal LambdaExpression GetConversion()
}
public System.Linq.Expressions.ParameterExpression : Expression {
private string <Name>k__BackingField
public Type Type
public ExpressionType NodeType
public string Name
public bool IsByRef
internal void .ctor(string name)
internal ParameterExpression Make(Type type, string name, bool isByRef)
public Type get_Type()
public ExpressionType get_NodeType()
public string get_Name()
public bool get_IsByRef()
internal bool GetIsByRef()
protected internal Expression Accept(ExpressionVisitor visitor)
}
internal System.Linq.Expressions.PrimitiveParameterExpression`1 : ParameterExpression {
public Type Type
internal void .ctor(string name)
public Type get_Type()
}
internal System.Linq.Expressions.PropertyExpression : MemberExpression {
private PropertyInfo _property
public Type Type
public void .ctor(Expression expression, PropertyInfo member)
internal MemberInfo GetMember()
public Type get_Type()
}
public System.Linq.Expressions.RuntimeVariablesExpression : Expression {
private ReadOnlyCollection`1<ParameterExpression> <Variables>k__BackingField
public Type Type
public ExpressionType NodeType
public ReadOnlyCollection`1<ParameterExpression> Variables
internal void .ctor(ReadOnlyCollection`1<ParameterExpression> variables)
public Type get_Type()
public ExpressionType get_NodeType()
public ReadOnlyCollection`1<ParameterExpression> get_Variables()
protected internal Expression Accept(ExpressionVisitor visitor)
public RuntimeVariablesExpression Update(IEnumerable`1<ParameterExpression> variables)
}
internal System.Linq.Expressions.Scope1 : ScopeExpression {
private object _body
internal int ExpressionCount
internal void .ctor(IReadOnlyList`1<ParameterExpression> variables, Expression body)
private void .ctor(IReadOnlyList`1<ParameterExpression> variables, object body)
internal bool SameExpressions(ICollection`1<Expression> expressions)
internal Expression GetExpression(int index)
internal int get_ExpressionCount()
internal ReadOnlyCollection`1<Expression> GetOrMakeExpressions()
internal BlockExpression Rewrite(ReadOnlyCollection`1<ParameterExpression> variables, Expression[] args)
}
internal System.Linq.Expressions.ScopeExpression : BlockExpression {
private IReadOnlyList`1<ParameterExpression> _variables
protected IReadOnlyList`1<ParameterExpression> VariablesList
internal void .ctor(IReadOnlyList`1<ParameterExpression> variables)
internal bool SameVariables(ICollection`1<ParameterExpression> variables)
internal ReadOnlyCollection`1<ParameterExpression> GetOrMakeVariables()
protected IReadOnlyList`1<ParameterExpression> get_VariablesList()
internal IReadOnlyList`1<ParameterExpression> ReuseOrValidateVariables(ReadOnlyCollection`1<ParameterExpression> variables)
}
internal System.Linq.Expressions.ScopeN : ScopeExpression {
private IReadOnlyList`1<Expression> _body
protected IReadOnlyList`1<Expression> Body
internal int ExpressionCount
internal void .ctor(IReadOnlyList`1<ParameterExpression> variables, IReadOnlyList`1<Expression> body)
internal bool SameExpressions(ICollection`1<Expression> expressions)
protected IReadOnlyList`1<Expression> get_Body()
internal Expression GetExpression(int index)
internal int get_ExpressionCount()
internal ReadOnlyCollection`1<Expression> GetOrMakeExpressions()
internal BlockExpression Rewrite(ReadOnlyCollection`1<ParameterExpression> variables, Expression[] args)
}
internal System.Linq.Expressions.ScopeWithType : ScopeN {
private Type <Type>k__BackingField
public Type Type
internal void .ctor(IReadOnlyList`1<ParameterExpression> variables, IReadOnlyList`1<Expression> expressions, Type type)
public Type get_Type()
internal BlockExpression Rewrite(ReadOnlyCollection`1<ParameterExpression> variables, Expression[] args)
}
internal System.Linq.Expressions.SimpleBinaryExpression : BinaryExpression {
private ExpressionType <NodeType>k__BackingField
private Type <Type>k__BackingField
public ExpressionType NodeType
public Type Type
internal void .ctor(ExpressionType nodeType, Expression left, Expression right, Type type)
public ExpressionType get_NodeType()
public Type get_Type()
}
internal System.Linq.Expressions.SpanDebugInfoExpression : DebugInfoExpression {
private int _startLine
private int _startColumn
private int _endLine
private int _endColumn
public int StartLine
public int StartColumn
public int EndLine
public int EndColumn
public bool IsClear
internal void .ctor(SymbolDocumentInfo document, int startLine, int startColumn, int endLine, int endColumn)
public int get_StartLine()
public int get_StartColumn()
public int get_EndLine()
public int get_EndColumn()
public bool get_IsClear()
protected internal Expression Accept(ExpressionVisitor visitor)
}
internal System.Linq.Expressions.StackGuard : object {
private int MaxExecutionStackCount
private int _executionStackCount
public bool TryEnterOnCurrentStack()
public void RunOnEmptyStack(Action`2<T1, T2> action, T1 arg1, T2 arg2)
public void RunOnEmptyStack(Action`3<T1, T2, T3> action, T1 arg1, T2 arg2, T3 arg3)
public R RunOnEmptyStack(Func`3<T1, T2, R> action, T1 arg1, T2 arg2)
public R RunOnEmptyStack(Func`4<T1, T2, T3, R> action, T1 arg1, T2 arg2, T3 arg3)
private R RunOnEmptyStackCore(Func`2<object, R> action, object state)
}
internal System.Linq.Expressions.Strings : object {
internal string ReducibleMustOverrideReduce
internal string MustReduceToDifferent
internal string ReducedNotCompatible
internal string SetterHasNoParams
internal string PropertyCannotHaveRefType
internal string IndexesOfSetGetMustMatch
internal string AccessorsCannotHaveVarArgs
internal string AccessorsCannotHaveByRefArgs
internal string BoundsCannotBeLessThanOne
internal string TypeMustNotBeByRef
internal string TypeMustNotBePointer
internal string SetterMustBeVoid
internal string PropertyTypeMustMatchGetter
internal string PropertyTypeMustMatchSetter
internal string BothAccessorsMustBeStatic
internal string OnlyStaticFieldsHaveNullInstance
internal string OnlyStaticPropertiesHaveNullInstance
internal string OnlyStaticMethodsHaveNullInstance
internal string PropertyTypeCannotBeVoid
internal string InvalidUnboxType
internal string ExpressionMustBeWriteable
internal string ArgumentMustNotHaveValueType
internal string MustBeReducible
internal string AllTestValuesMustHaveSameType
internal string AllCaseBodiesMustHaveSameType
internal string DefaultBodyMustBeSupplied
internal string LabelMustBeVoidOrHaveExpression
internal string LabelTypeMustBeVoid
internal string QuotedExpressionMustBeLambda
internal string CollectionModifiedWhileEnumerating
internal string CollectionReadOnly
internal string ArgCntMustBeGreaterThanNameCnt
internal string BindingCannotBeNull
internal string ArgumentTypeCannotBeVoid
internal string NoOrInvalidRuleProduced
internal string TypeMustBeDerivedFromSystemDelegate
internal string FirstArgumentMustBeCallSite
internal string StartEndMustBeOrdered
internal string FaultCannotHaveCatchOrFinally
internal string TryMustHaveCatchFinallyOrFault
internal string BodyOfCatchMustHaveSameTypeAsBodyOfTry
internal string ConversionIsNotSupportedForArithmeticTypes
internal string ArgumentMustBeArray
internal string ArgumentMustBeBoolean
internal string ArgumentMustBeFieldInfoOrPropertyInfo
internal string ArgumentMustBeFieldInfoOrPropertyInfoOrMethod
internal string ArgumentMustBeInstanceMember
internal string ArgumentMustBeInteger
internal string ArgumentMustBeArrayIndexType
internal string ArgumentMustBeSingleDimensionalArrayType
internal string ArgumentTypesMustMatch
internal string CoalesceUsedOnNonNullType
internal string IncorrectNumberOfIndexes
internal string IncorrectNumberOfLambdaDeclarationParameters
internal string IncorrectNumberOfMembersForGivenConstructor
internal string IncorrectNumberOfArgumentsForMembers
internal string LambdaTypeMustBeDerivedFromSystemDelegate
internal string ElementInitializerMethodNotAdd
internal string ElementInitializerMethodWithZeroArgs
internal string ElementInitializerMethodStatic
internal string UnhandledBinding
internal string UnknownBindingType
internal string IncorrectNumberOfTypeArgsForFunc
internal string IncorrectNumberOfTypeArgsForAction
internal string ArgumentCannotBeOfTypeVoid
internal string ControlCannotLeaveFinally
internal string ControlCannotLeaveFilterTest
internal string ControlCannotEnterTry
internal string ControlCannotEnterExpression
internal string CannotCompileDynamic
internal string MethodBuilderDoesNotHaveTypeBuilder
internal string RethrowRequiresCatch
internal string TryNotAllowedInFilter
internal string PdbGeneratorNeedsExpressionCompiler
internal string NonStaticConstructorRequired
internal string NonAbstractConstructorRequired
internal string ExpressionMustBeReadable
internal string EnumerationIsDone
internal string InvalidArgumentValue
internal string NonEmptyCollectionRequired
internal string IncorrectNumberOfLambdaArguments
internal string IncorrectNumberOfConstructorArguments
internal string get_ReducibleMustOverrideReduce()
internal string get_MustReduceToDifferent()
internal string get_ReducedNotCompatible()
internal string get_SetterHasNoParams()
internal string get_PropertyCannotHaveRefType()
internal string get_IndexesOfSetGetMustMatch()
internal string get_AccessorsCannotHaveVarArgs()
internal string get_AccessorsCannotHaveByRefArgs()
internal string get_BoundsCannotBeLessThanOne()
internal string get_TypeMustNotBeByRef()
internal string get_TypeMustNotBePointer()
internal string get_SetterMustBeVoid()
internal string get_PropertyTypeMustMatchGetter()
internal string get_PropertyTypeMustMatchSetter()
internal string get_BothAccessorsMustBeStatic()
internal string get_OnlyStaticFieldsHaveNullInstance()
internal string get_OnlyStaticPropertiesHaveNullInstance()
internal string get_OnlyStaticMethodsHaveNullInstance()
internal string get_PropertyTypeCannotBeVoid()
internal string get_InvalidUnboxType()
internal string get_ExpressionMustBeWriteable()
internal string get_ArgumentMustNotHaveValueType()
internal string get_MustBeReducible()
internal string get_AllTestValuesMustHaveSameType()
internal string get_AllCaseBodiesMustHaveSameType()
internal string get_DefaultBodyMustBeSupplied()
internal string get_LabelMustBeVoidOrHaveExpression()
internal string get_LabelTypeMustBeVoid()
internal string get_QuotedExpressionMustBeLambda()
internal string get_CollectionModifiedWhileEnumerating()
internal string VariableMustNotBeByRef(object p0, object p1)
internal string get_CollectionReadOnly()
internal string AmbiguousMatchInExpandoObject(object p0)
internal string SameKeyExistsInExpando(object p0)
internal string KeyDoesNotExistInExpando(object p0)
internal string get_ArgCntMustBeGreaterThanNameCnt()
internal string InvalidMetaObjectCreated(object p0)
internal string BinderNotCompatibleWithCallSite(object p0, object p1, object p2)
internal string DynamicBindingNeedsRestrictions(object p0, object p1)
internal string DynamicObjectResultNotAssignable(object p0, object p1, object p2, object p3)
internal string DynamicBinderResultNotAssignable(object p0, object p1, object p2)
internal string get_BindingCannotBeNull()
internal string DuplicateVariable(object p0)
internal string get_ArgumentTypeCannotBeVoid()
internal string TypeParameterIsNotDelegate(object p0)
internal string get_NoOrInvalidRuleProduced()
internal string get_TypeMustBeDerivedFromSystemDelegate()
internal string get_FirstArgumentMustBeCallSite()
internal string get_StartEndMustBeOrdered()
internal string get_FaultCannotHaveCatchOrFinally()
internal string get_TryMustHaveCatchFinallyOrFault()
internal string get_BodyOfCatchMustHaveSameTypeAsBodyOfTry()
internal string ExtensionNodeMustOverrideProperty(object p0)
internal string UserDefinedOperatorMustBeStatic(object p0)
internal string UserDefinedOperatorMustNotBeVoid(object p0)
internal string CoercionOperatorNotDefined(object p0, object p1)
internal string UnaryOperatorNotDefined(object p0, object p1)
internal string BinaryOperatorNotDefined(object p0, object p1, object p2)
internal string ReferenceEqualityNotDefined(object p0, object p1)
internal string OperandTypesDoNotMatchParameters(object p0, object p1)
internal string OverloadOperatorTypeDoesNotMatchConversionType(object p0, object p1)
internal string get_ConversionIsNotSupportedForArithmeticTypes()
internal string get_ArgumentMustBeArray()
internal string get_ArgumentMustBeBoolean()
internal string EqualityMustReturnBoolean(object p0)
internal string get_ArgumentMustBeFieldInfoOrPropertyInfo()
internal string get_ArgumentMustBeFieldInfoOrPropertyInfoOrMethod()
internal string get_ArgumentMustBeInstanceMember()
internal string get_ArgumentMustBeInteger()
internal string get_ArgumentMustBeArrayIndexType()
internal string get_ArgumentMustBeSingleDimensionalArrayType()
internal string get_ArgumentTypesMustMatch()
internal string CannotAutoInitializeValueTypeElementThroughProperty(object p0)
internal string CannotAutoInitializeValueTypeMemberThroughProperty(object p0)
internal string IncorrectTypeForTypeAs(object p0)
internal string get_CoalesceUsedOnNonNullType()
internal string ExpressionTypeCannotInitializeArrayType(object p0, object p1)
internal string ArgumentTypeDoesNotMatchMember(object p0, object p1)
internal string ArgumentMemberNotDeclOnType(object p0, object p1)
internal string ExpressionTypeDoesNotMatchReturn(object p0, object p1)
internal string ExpressionTypeDoesNotMatchAssignment(object p0, object p1)
internal string ExpressionTypeDoesNotMatchLabel(object p0, object p1)
internal string ExpressionTypeNotInvocable(object p0)
internal string FieldNotDefinedForType(object p0, object p1)
internal string InstanceFieldNotDefinedForType(object p0, object p1)
internal string FieldInfoNotDefinedForType(object p0, object p1, object p2)
internal string get_IncorrectNumberOfIndexes()
internal string get_IncorrectNumberOfLambdaDeclarationParameters()
internal string get_IncorrectNumberOfMembersForGivenConstructor()
internal string get_IncorrectNumberOfArgumentsForMembers()
internal string get_LambdaTypeMustBeDerivedFromSystemDelegate()
internal string MemberNotFieldOrProperty(object p0)
internal string MethodContainsGenericParameters(object p0)
internal string MethodIsGeneric(object p0)
internal string MethodNotPropertyAccessor(object p0, object p1)
internal string PropertyDoesNotHaveGetter(object p0)
internal string PropertyDoesNotHaveSetter(object p0)
internal string PropertyDoesNotHaveAccessor(object p0)
internal string NotAMemberOfType(object p0, object p1)
internal string NotAMemberOfAnyType(object p0)
internal string ParameterExpressionNotValidAsDelegate(object p0, object p1)
internal string PropertyNotDefinedForType(object p0, object p1)
internal string InstancePropertyNotDefinedForType(object p0, object p1)
internal string InstancePropertyWithoutParameterNotDefinedForType(object p0, object p1)
internal string InstancePropertyWithSpecifiedParametersNotDefinedForType(object p0, object p1, object p2)
internal string InstanceAndMethodTypeMismatch(object p0, object p1, object p2)
internal string TypeMissingDefaultConstructor(object p0)
internal string get_ElementInitializerMethodNotAdd()
internal string ElementInitializerMethodNoRefOutParam(object p0, object p1)
internal string get_ElementInitializerMethodWithZeroArgs()
internal string get_ElementInitializerMethodStatic()
internal string TypeNotIEnumerable(object p0)
internal string UnhandledBinary(object p0)
internal string get_UnhandledBinding()
internal string UnhandledBindingType(object p0)
internal string UnhandledUnary(object p0)
internal string get_UnknownBindingType()
internal string UserDefinedOpMustHaveConsistentTypes(object p0, object p1)
internal string UserDefinedOpMustHaveValidReturnType(object p0, object p1)
internal string LogicalOperatorMustHaveBooleanOperators(object p0, object p1)
internal string MethodWithArgsDoesNotExistOnType(object p0, object p1)
internal string GenericMethodWithArgsDoesNotExistOnType(object p0, object p1)
internal string MethodWithMoreThanOneMatch(object p0, object p1)
internal string PropertyWithMoreThanOneMatch(object p0, object p1)
internal string get_IncorrectNumberOfTypeArgsForFunc()
internal string get_IncorrectNumberOfTypeArgsForAction()
internal string get_ArgumentCannotBeOfTypeVoid()
internal string OutOfRange(object p0, object p1)
internal string LabelTargetAlreadyDefined(object p0)
internal string LabelTargetUndefined(object p0)
internal string get_ControlCannotLeaveFinally()
internal string get_ControlCannotLeaveFilterTest()
internal string AmbiguousJump(object p0)
internal string get_ControlCannotEnterTry()
internal string get_ControlCannotEnterExpression()
internal string NonLocalJumpWithValue(object p0)
internal string CannotCompileConstant(object p0)
internal string get_CannotCompileDynamic()
internal string get_MethodBuilderDoesNotHaveTypeBuilder()
internal string InvalidLvalue(object p0)
internal string UndefinedVariable(object p0, object p1, object p2)
internal string CannotCloseOverByRef(object p0, object p1)
internal string UnexpectedVarArgsCall(object p0)
internal string get_RethrowRequiresCatch()
internal string get_TryNotAllowedInFilter()
internal string MustRewriteToSameNode(object p0, object p1, object p2)
internal string MustRewriteChildToSameType(object p0, object p1, object p2)
internal string MustRewriteWithoutMethod(object p0, object p1)
internal string TryNotSupportedForMethodsWithRefArgs(object p0)
internal string TryNotSupportedForValueTypeInstances(object p0)
internal string TestValueTypeDoesNotMatchComparisonMethodParameter(object p0, object p1)
internal string SwitchValueTypeDoesNotMatchComparisonMethodParameter(object p0, object p1)
internal string get_PdbGeneratorNeedsExpressionCompiler()
internal string get_NonStaticConstructorRequired()
internal string get_NonAbstractConstructorRequired()
internal string get_ExpressionMustBeReadable()
internal string ExpressionTypeDoesNotMatchConstructorParameter(object p0, object p1)
internal string get_EnumerationIsDone()
internal string TypeContainsGenericParameters(object p0)
internal string TypeIsGeneric(object p0)
internal string get_InvalidArgumentValue()
internal string get_NonEmptyCollectionRequired()
internal string InvalidNullValue(object p0)
internal string InvalidObjectType(object p0, object p1)
internal string ExpressionTypeDoesNotMatchMethodParameter(object p0, object p1, object p2)
internal string ExpressionTypeDoesNotMatchParameter(object p0, object p1)
internal string IncorrectNumberOfMethodCallArguments(object p0)
internal string get_IncorrectNumberOfLambdaArguments()
internal string get_IncorrectNumberOfConstructorArguments()
}
public System.Linq.Expressions.SwitchCase : object {
private ReadOnlyCollection`1<Expression> <TestValues>k__BackingField
private Expression <Body>k__BackingField
public ReadOnlyCollection`1<Expression> TestValues
public Expression Body
internal void .ctor(Expression body, ReadOnlyCollection`1<Expression> testValues)
public ReadOnlyCollection`1<Expression> get_TestValues()
public Expression get_Body()
public string ToString()
public SwitchCase Update(IEnumerable`1<Expression> testValues, Expression body)
}
public System.Linq.Expressions.SwitchExpression : Expression {
private Type <Type>k__BackingField
private Expression <SwitchValue>k__BackingField
private ReadOnlyCollection`1<SwitchCase> <Cases>k__BackingField
private Expression <DefaultBody>k__BackingField
private MethodInfo <Comparison>k__BackingField
public Type Type
public ExpressionType NodeType
public Expression SwitchValue
public ReadOnlyCollection`1<SwitchCase> Cases
public Expression DefaultBody
public MethodInfo Comparison
internal bool IsLifted
internal void .ctor(Type type, Expression switchValue, Expression defaultBody, MethodInfo comparison, ReadOnlyCollection`1<SwitchCase> cases)
public Type get_Type()
public ExpressionType get_NodeType()
public Expression get_SwitchValue()
public ReadOnlyCollection`1<SwitchCase> get_Cases()
public Expression get_DefaultBody()
public MethodInfo get_Comparison()
protected internal Expression Accept(ExpressionVisitor visitor)
internal bool get_IsLifted()
public SwitchExpression Update(Expression switchValue, IEnumerable`1<SwitchCase> cases, Expression defaultBody)
}
public System.Linq.Expressions.SymbolDocumentInfo : object {
private string <FileName>k__BackingField
internal Guid DocumentType_Text
public string FileName
public Guid Language
public Guid LanguageVendor
public Guid DocumentType
internal void .ctor(string fileName)
public string get_FileName()
public Guid get_Language()
public Guid get_LanguageVendor()
public Guid get_DocumentType()
}
internal System.Linq.Expressions.SymbolDocumentWithGuids : SymbolDocumentInfo {
private Guid <Language>k__BackingField
private Guid <LanguageVendor>k__BackingField
private Guid <DocumentType>k__BackingField
public Guid Language
public Guid LanguageVendor
public Guid DocumentType
internal void .ctor(string fileName, Guid& language)
internal void .ctor(string fileName, Guid& language, Guid& vendor)
internal void .ctor(string fileName, Guid& language, Guid& vendor, Guid& documentType)
public Guid get_Language()
public Guid get_LanguageVendor()
public Guid get_DocumentType()
}
public System.Linq.Expressions.TryExpression : Expression {
private Type <Type>k__BackingField
private Expression <Body>k__BackingField
private ReadOnlyCollection`1<CatchBlock> <Handlers>k__BackingField
private Expression <Finally>k__BackingField
private Expression <Fault>k__BackingField
public Type Type
public ExpressionType NodeType
public Expression Body
public ReadOnlyCollection`1<CatchBlock> Handlers
public Expression Finally
public Expression Fault
internal void .ctor(Type type, Expression body, Expression finally, Expression fault, ReadOnlyCollection`1<CatchBlock> handlers)
public Type get_Type()
public ExpressionType get_NodeType()
public Expression get_Body()
public ReadOnlyCollection`1<CatchBlock> get_Handlers()
public Expression get_Finally()
public Expression get_Fault()
protected internal Expression Accept(ExpressionVisitor visitor)
public TryExpression Update(Expression body, IEnumerable`1<CatchBlock> handlers, Expression finally, Expression fault)
}
public System.Linq.Expressions.TypeBinaryExpression : Expression {
private ExpressionType <NodeType>k__BackingField
private Expression <Expression>k__BackingField
private Type <TypeOperand>k__BackingField
public Type Type
public ExpressionType NodeType
public Expression Expression
public Type TypeOperand
internal void .ctor(Expression expression, Type typeOperand, ExpressionType nodeType)
public Type get_Type()
public ExpressionType get_NodeType()
public Expression get_Expression()
public Type get_TypeOperand()
internal Expression ReduceTypeEqual()
private Expression ByValParameterTypeEqual(ParameterExpression value)
private Expression ReduceConstantTypeEqual()
protected internal Expression Accept(ExpressionVisitor visitor)
public TypeBinaryExpression Update(Expression expression)
}
internal System.Linq.Expressions.TypedConstantExpression : ConstantExpression {
private Type <Type>k__BackingField
public Type Type
internal void .ctor(object value, Type type)
public Type get_Type()
}
internal System.Linq.Expressions.TypedDynamicExpression1 : DynamicExpression1 {
private Type <Type>k__BackingField
public Type Type
internal void .ctor(Type retType, Type delegateType, CallSiteBinder binder, Expression arg0)
public Type get_Type()
}
internal System.Linq.Expressions.TypedDynamicExpression2 : DynamicExpression2 {
private Type <Type>k__BackingField
public Type Type
internal void .ctor(Type retType, Type delegateType, CallSiteBinder binder, Expression arg0, Expression arg1)
public Type get_Type()
}
internal System.Linq.Expressions.TypedDynamicExpression3 : DynamicExpression3 {
private Type <Type>k__BackingField
public Type Type
internal void .ctor(Type retType, Type delegateType, CallSiteBinder binder, Expression arg0, Expression arg1, Expression arg2)
public Type get_Type()
}
internal System.Linq.Expressions.TypedDynamicExpression4 : DynamicExpression4 {
private Type <Type>k__BackingField
public Type Type
internal void .ctor(Type retType, Type delegateType, CallSiteBinder binder, Expression arg0, Expression arg1, Expression arg2, Expression arg3)
public Type get_Type()
}
internal System.Linq.Expressions.TypedDynamicExpressionN : DynamicExpressionN {
private Type <Type>k__BackingField
public Type Type
internal void .ctor(Type returnType, Type delegateType, CallSiteBinder binder, IReadOnlyList`1<Expression> arguments)
public Type get_Type()
}
internal System.Linq.Expressions.TypedParameterExpression : ParameterExpression {
private Type <Type>k__BackingField
public Type Type
internal void .ctor(Type type, string name)
public Type get_Type()
}
public System.Linq.Expressions.UnaryExpression : Expression {
private Type <Type>k__BackingField
private ExpressionType <NodeType>k__BackingField
private Expression <Operand>k__BackingField
private MethodInfo <Method>k__BackingField
public Type Type
public ExpressionType NodeType
public Expression Operand
public MethodInfo Method
public bool IsLifted
public bool IsLiftedToNull
public bool CanReduce
private bool IsPrefix
internal void .ctor(ExpressionType nodeType, Expression expression, Type type, MethodInfo method)
public Type get_Type()
public ExpressionType get_NodeType()
public Expression get_Operand()
public MethodInfo get_Method()
public bool get_IsLifted()
public bool get_IsLiftedToNull()
protected internal Expression Accept(ExpressionVisitor visitor)
public bool get_CanReduce()
public Expression Reduce()
private bool get_IsPrefix()
private UnaryExpression FunctionalOp(Expression operand)
private Expression ReduceVariable()
private Expression ReduceMember()
private Expression ReduceIndex()
public UnaryExpression Update(Expression operand)
}
internal System.Linq.Expressions.Utils : object {
public object BoxedFalse
public object BoxedTrue
public object BoxedIntM1
public object BoxedInt0
public object BoxedInt1
public object BoxedInt2
public object BoxedInt3
public object BoxedDefaultSByte
public object BoxedDefaultChar
public object BoxedDefaultInt16
public object BoxedDefaultInt64
public object BoxedDefaultByte
public object BoxedDefaultUInt16
public object BoxedDefaultUInt32
public object BoxedDefaultUInt64
public object BoxedDefaultSingle
public object BoxedDefaultDouble
public object BoxedDefaultDecimal
public object BoxedDefaultDateTime
private ConstantExpression s_true
private ConstantExpression s_false
private ConstantExpression s_m1
private ConstantExpression s_0
private ConstantExpression s_1
private ConstantExpression s_2
private ConstantExpression s_3
public DefaultExpression Empty
public ConstantExpression Null
public ConstantExpression Constant(bool value)
public ConstantExpression Constant(int value)
}
internal System.Linq.GroupedEnumerable`2 : object {
private IEnumerable`1<TSource> _source
private Func`2<TSource, TKey> _keySelector
private IEqualityComparer`1<TKey> _comparer
public void .ctor(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, IEqualityComparer`1<TKey> comparer)
public IEnumerator`1<IGrouping`2<TKey, TSource>> GetEnumerator()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
public IGrouping`2[] ToArray()
public List`1<IGrouping`2<TKey, TSource>> ToList()
public int GetCount(bool onlyIfCheap)
}
internal System.Linq.GroupedEnumerable`3 : object {
private IEnumerable`1<TSource> _source
private Func`2<TSource, TKey> _keySelector
private Func`2<TSource, TElement> _elementSelector
private IEqualityComparer`1<TKey> _comparer
public void .ctor(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`2<TSource, TElement> elementSelector, IEqualityComparer`1<TKey> comparer)
public IEnumerator`1<IGrouping`2<TKey, TElement>> GetEnumerator()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
public IGrouping`2[] ToArray()
public List`1<IGrouping`2<TKey, TElement>> ToList()
public int GetCount(bool onlyIfCheap)
}
internal System.Linq.GroupedResultEnumerable`3 : object {
private IEnumerable`1<TSource> _source
private Func`2<TSource, TKey> _keySelector
private IEqualityComparer`1<TKey> _comparer
private Func`3<TKey, IEnumerable`1<TSource>, TResult> _resultSelector
public void .ctor(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`3<TKey, IEnumerable`1<TSource>, TResult> resultSelector, IEqualityComparer`1<TKey> comparer)
public IEnumerator`1<TResult> GetEnumerator()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
public TResult[] ToArray()
public List`1<TResult> ToList()
public int GetCount(bool onlyIfCheap)
}
internal System.Linq.GroupedResultEnumerable`4 : object {
private IEnumerable`1<TSource> _source
private Func`2<TSource, TKey> _keySelector
private Func`2<TSource, TElement> _elementSelector
private IEqualityComparer`1<TKey> _comparer
private Func`3<TKey, IEnumerable`1<TElement>, TResult> _resultSelector
public void .ctor(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`2<TSource, TElement> elementSelector, Func`3<TKey, IEnumerable`1<TElement>, TResult> resultSelector, IEqualityComparer`1<TKey> comparer)
public IEnumerator`1<TResult> GetEnumerator()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
public TResult[] ToArray()
public List`1<TResult> ToList()
public int GetCount(bool onlyIfCheap)
}
internal System.Linq.Grouping`2 : object {
internal TKey _key
internal int _hashCode
internal TElement[] _elements
internal int _count
internal Grouping`2<TKey, TElement> _hashNext
internal Grouping`2<TKey, TElement> _next
public TKey Key
private int System.Collections.Generic.ICollection<TElement>.Count
private bool System.Collections.Generic.ICollection<TElement>.IsReadOnly
private TElement System.Collections.Generic.IList<TElement>.Item
internal void Add(TElement element)
internal void Trim()
public IEnumerator`1<TElement> GetEnumerator()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
public TKey get_Key()
private int System.Collections.Generic.ICollection<TElement>.get_Count()
private bool System.Collections.Generic.ICollection<TElement>.get_IsReadOnly()
private void System.Collections.Generic.ICollection<TElement>.Add(TElement item)
private void System.Collections.Generic.ICollection<TElement>.Clear()
private bool System.Collections.Generic.ICollection<TElement>.Contains(TElement item)
private void System.Collections.Generic.ICollection<TElement>.CopyTo(TElement[] array, int arrayIndex)
private bool System.Collections.Generic.ICollection<TElement>.Remove(TElement item)
private int System.Collections.Generic.IList<TElement>.IndexOf(TElement item)
private void System.Collections.Generic.IList<TElement>.Insert(int index, TElement item)
private void System.Collections.Generic.IList<TElement>.RemoveAt(int index)
private TElement System.Collections.Generic.IList<TElement>.get_Item(int index)
private void System.Collections.Generic.IList<TElement>.set_Item(int index, TElement value)
}
public System.Linq.IGrouping`2 {
public TKey Key
public TKey get_Key()
}
internal System.Linq.IIListProvider`1 {
public TElement[] ToArray()
public List`1<TElement> ToList()
public int GetCount(bool onlyIfCheap)
}
public System.Linq.ILookup`2 {
public int Count
public IEnumerable`1<TElement> Item
public int get_Count()
public IEnumerable`1<TElement> get_Item(TKey key)
public bool Contains(TKey key)
}
public System.Linq.IOrderedEnumerable`1 {
public IOrderedEnumerable`1<TElement> CreateOrderedEnumerable(Func`2<TElement, TKey> keySelector, IComparer`1<TKey> comparer, bool descending)
}
internal System.Linq.IPartition`1 {
public IPartition`1<TElement> Skip(int count)
public IPartition`1<TElement> Take(int count)
public TElement TryGetElementAt(int index, Boolean& found)
public TElement TryGetFirst(Boolean& found)
public TElement TryGetLast(Boolean& found)
}
public System.Linq.IQueryable {
public Expression Expression
public Type ElementType
public IQueryProvider Provider
public Expression get_Expression()
public Type get_ElementType()
public IQueryProvider get_Provider()
}
public System.Linq.IQueryProvider {
public IQueryable CreateQuery(Expression expression)
public IQueryable`1<TElement> CreateQuery(Expression expression)
public object Execute(Expression expression)
public TResult Execute(Expression expression)
}
public System.Linq.Lookup`2 : object {
private IEqualityComparer`1<TKey> _comparer
private Grouping`2[] _groupings
private Grouping`2<TKey, TElement> _lastGrouping
private int _count
public int Count
public IEnumerable`1<TElement> Item
internal Lookup`2<TKey, TElement> Create(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`2<TSource, TElement> elementSelector, IEqualityComparer`1<TKey> comparer)
internal Lookup`2<TKey, TElement> Create(IEnumerable`1<TElement> source, Func`2<TElement, TKey> keySelector, IEqualityComparer`1<TKey> comparer)
internal Lookup`2<TKey, TElement> CreateForJoin(IEnumerable`1<TElement> source, Func`2<TElement, TKey> keySelector, IEqualityComparer`1<TKey> comparer)
private void .ctor(IEqualityComparer`1<TKey> comparer)
public int get_Count()
public IEnumerable`1<TElement> get_Item(TKey key)
public bool Contains(TKey key)
public IEnumerator`1<IGrouping`2<TKey, TElement>> GetEnumerator()
private IGrouping`2[] System.Linq.IIListProvider<System.Linq.IGrouping<TKey,TElement>>.ToArray()
internal TResult[] ToArray(Func`3<TKey, IEnumerable`1<TElement>, TResult> resultSelector)
private List`1<IGrouping`2<TKey, TElement>> System.Linq.IIListProvider<System.Linq.IGrouping<TKey,TElement>>.ToList()
internal List`1<TResult> ToList(Func`3<TKey, IEnumerable`1<TElement>, TResult> resultSelector)
private int System.Linq.IIListProvider<System.Linq.IGrouping<TKey,TElement>>.GetCount(bool onlyIfCheap)
public IEnumerable`1<TResult> ApplyResultSelector(Func`3<TKey, IEnumerable`1<TElement>, TResult> resultSelector)
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
private int InternalGetHashCode(TKey key)
internal Grouping`2<TKey, TElement> GetGrouping(TKey key, bool create)
private void Resize()
}
internal System.Linq.OrderedEnumerable`1 : object {
internal IEnumerable`1<TElement> _source
private Int32[] SortedMap(Buffer`1<TElement> buffer)
private Int32[] SortedMap(Buffer`1<TElement> buffer, int minIdx, int maxIdx)
public IEnumerator`1<TElement> GetEnumerator()
public TElement[] ToArray()
public List`1<TElement> ToList()
public int GetCount(bool onlyIfCheap)
internal IEnumerator`1<TElement> GetEnumerator(int minIdx, int maxIdx)
internal TElement[] ToArray(int minIdx, int maxIdx)
internal List`1<TElement> ToList(int minIdx, int maxIdx)
internal int GetCount(int minIdx, int maxIdx, bool onlyIfCheap)
private EnumerableSorter`1<TElement> GetEnumerableSorter()
internal EnumerableSorter`1<TElement> GetEnumerableSorter(EnumerableSorter`1<TElement> next)
private CachingComparer`1<TElement> GetComparer()
internal CachingComparer`1<TElement> GetComparer(CachingComparer`1<TElement> childComparer)
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
private IOrderedEnumerable`1<TElement> System.Linq.IOrderedEnumerable<TElement>.CreateOrderedEnumerable(Func`2<TElement, TKey> keySelector, IComparer`1<TKey> comparer, bool descending)
public IPartition`1<TElement> Skip(int count)
public IPartition`1<TElement> Take(int count)
public TElement TryGetElementAt(int index, Boolean& found)
public TElement TryGetFirst(Boolean& found)
public TElement TryGetFirst(Func`2<TElement, bool> predicate, Boolean& found)
public TElement TryGetLast(Boolean& found)
public TElement TryGetLast(int minIdx, int maxIdx, Boolean& found)
private TElement Last(Buffer`1<TElement> buffer)
public TElement TryGetLast(Func`2<TElement, bool> predicate, Boolean& found)
}
internal System.Linq.OrderedEnumerable`2 : OrderedEnumerable`1<TElement> {
private OrderedEnumerable`1<TElement> _parent
private Func`2<TElement, TKey> _keySelector
private IComparer`1<TKey> _comparer
private bool _descending
internal void .ctor(IEnumerable`1<TElement> source, Func`2<TElement, TKey> keySelector, IComparer`1<TKey> comparer, bool descending, OrderedEnumerable`1<TElement> parent)
internal EnumerableSorter`1<TElement> GetEnumerableSorter(EnumerableSorter`1<TElement> next)
internal CachingComparer`1<TElement> GetComparer(CachingComparer`1<TElement> childComparer)
}
public System.Linq.OrderedParallelQuery`1 : ParallelQuery`1<TSource> {
private QueryOperator`1<TSource> _sortOp
internal QueryOperator`1<TSource> SortOperator
internal IOrderedEnumerable`1<TSource> OrderedEnumerable
internal void .ctor(QueryOperator`1<TSource> sortOp)
internal QueryOperator`1<TSource> get_SortOperator()
internal IOrderedEnumerable`1<TSource> get_OrderedEnumerable()
public IEnumerator`1<TSource> GetEnumerator()
}
internal System.Linq.OrderedPartition`1 : object {
private OrderedEnumerable`1<TElement> _source
private int _minIndexInclusive
private int _maxIndexInclusive
public void .ctor(OrderedEnumerable`1<TElement> source, int minIdxInclusive, int maxIdxInclusive)
public IEnumerator`1<TElement> GetEnumerator()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
public IPartition`1<TElement> Skip(int count)
public IPartition`1<TElement> Take(int count)
public TElement TryGetElementAt(int index, Boolean& found)
public TElement TryGetFirst(Boolean& found)
public TElement TryGetLast(Boolean& found)
public TElement[] ToArray()
public List`1<TElement> ToList()
public int GetCount(bool onlyIfCheap)
}
internal System.Linq.Parallel.AnyAllSearchOperator`1 : UnaryQueryOperator`2<TInput, bool> {
private Func`2<TInput, bool> _predicate
private bool _qualification
internal bool LimitsParallelism
internal void .ctor(IEnumerable`1<TInput> child, bool qualification, Func`2<TInput, bool> predicate)
internal bool Aggregate()
internal QueryResults`1<bool> Open(QuerySettings settings, bool preferStriping)
internal void WrapPartitionedStream(PartitionedStream`2<TInput, TKey> inputStream, IPartitionedStreamRecipient`1<bool> recipient, bool preferStriping, QuerySettings settings)
internal IEnumerable`1<bool> AsSequentialQuery(CancellationToken token)
internal bool get_LimitsParallelism()
}
internal System.Linq.Parallel.ArrayMergeHelper`1 : object {
private QueryResults`1<TInputOutput> _queryResults
private TInputOutput[] _outputArray
private QuerySettings _settings
public void .ctor(QuerySettings settings, QueryResults`1<TInputOutput> queryResults)
private void ToArrayElement(int index)
public void Execute()
public IEnumerator`1<TInputOutput> GetEnumerator()
public TInputOutput[] GetResultsAsArray()
}
internal System.Linq.Parallel.AssociativeAggregationOperator`3 : UnaryQueryOperator`2<TInput, TIntermediate> {
private TIntermediate _seed
private bool _seedIsSpecified
private bool _throwIfEmpty
private Func`3<TIntermediate, TInput, TIntermediate> _intermediateReduce
private Func`3<TIntermediate, TIntermediate, TIntermediate> _finalReduce
private Func`2<TIntermediate, TOutput> _resultSelector
private Func`1<TIntermediate> _seedFactory
internal bool LimitsParallelism
internal void .ctor(IEnumerable`1<TInput> child, TIntermediate seed, Func`1<TIntermediate> seedFactory, bool seedIsSpecified, Func`3<TIntermediate, TInput, TIntermediate> intermediateReduce, Func`3<TIntermediate, TIntermediate, TIntermediate> finalReduce, Func`2<TIntermediate, TOutput> resultSelector, bool throwIfEmpty, QueryAggregationOptions options)
internal TOutput Aggregate()
internal QueryResults`1<TIntermediate> Open(QuerySettings settings, bool preferStriping)
internal void WrapPartitionedStream(PartitionedStream`2<TInput, TKey> inputStream, IPartitionedStreamRecipient`1<TIntermediate> recipient, bool preferStriping, QuerySettings settings)
internal IEnumerable`1<TIntermediate> AsSequentialQuery(CancellationToken token)
internal bool get_LimitsParallelism()
}
internal System.Linq.Parallel.AsynchronousChannel`1 : object {
private T[][] _buffer
private int _index
private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) _producerBufferIndex
private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) _consumerBufferIndex
private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _done
private T[] _producerChunk
private int _producerChunkIndex
private T[] _consumerChunk
private int _consumerChunkIndex
private int _chunkSize
private ManualResetEventSlim _producerEvent
private IntValueEvent _consumerEvent
private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) _producerIsWaiting
private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) _consumerIsWaiting
private CancellationToken _cancellationToken
internal bool IsFull
internal bool IsChunkBufferEmpty
internal bool IsDone
internal void .ctor(int index, int chunkSize, CancellationToken cancellationToken, IntValueEvent consumerEvent)
internal void .ctor(int index, int capacity, int chunkSize, CancellationToken cancellationToken, IntValueEvent consumerEvent)
internal bool get_IsFull()
internal bool get_IsChunkBufferEmpty()
internal bool get_IsDone()
internal void FlushBuffers()
internal void SetDone()
internal void Enqueue(T item)
private void EnqueueChunk(T[] chunk)
private void WaitUntilNonFull()
private void FlushCachedChunk()
internal bool TryDequeue(T& item)
private bool TryDequeueChunk(T[]& chunk)
internal bool TryDequeue(T& item, Boolean& isDone)
private bool TryDequeueChunk(T[]& chunk, Boolean& isDone)
private T[] InternalDequeueChunk()
internal void DoneWithDequeueWait()
public void Dispose()
}
internal System.Linq.Parallel.AsynchronousChannelMergeEnumerator`1 : MergeEnumerator`1<T> {
private AsynchronousChannel`1[] _channels
private IntValueEvent _consumerEvent
private Boolean[] _done
private int _channelIndex
private T _currentElement
public T Current
internal void .ctor(QueryTaskGroupState taskGroupState, AsynchronousChannel`1[] channels, IntValueEvent consumerEvent)
public T get_Current()
public bool MoveNext()
private bool MoveNextSlowPath()
public void Dispose()
}
internal System.Linq.Parallel.BinaryQueryOperator`3 : QueryOperator`1<TOutput> {
private QueryOperator`1<TLeftInput> _leftChild
private QueryOperator`1<TRightInput> _rightChild
private OrdinalIndexState _indexState
internal QueryOperator`1<TLeftInput> LeftChild
internal QueryOperator`1<TRightInput> RightChild
internal OrdinalIndexState OrdinalIndexState
internal void .ctor(ParallelQuery`1<TLeftInput> leftChild, ParallelQuery`1<TRightInput> rightChild)
internal void .ctor(QueryOperator`1<TLeftInput> leftChild, QueryOperator`1<TRightInput> rightChild)
internal QueryOperator`1<TLeftInput> get_LeftChild()
internal QueryOperator`1<TRightInput> get_RightChild()
internal OrdinalIndexState get_OrdinalIndexState()
protected void SetOrdinalIndex(OrdinalIndexState indexState)
public void WrapPartitionedStream(PartitionedStream`2<TLeftInput, TLeftKey> leftPartitionedStream, PartitionedStream`2<TRightInput, TRightKey> rightPartitionedStream, IPartitionedStreamRecipient`1<TOutput> outputRecipient, bool preferStriping, QuerySettings settings)
}
internal System.Linq.Parallel.CancellableEnumerable : object {
internal IEnumerable`1<TElement> Wrap(IEnumerable`1<TElement> source, CancellationToken token)
}
internal System.Linq.Parallel.CancellationState : object {
internal CancellationTokenSource InternalCancellationTokenSource
internal CancellationToken ExternalCancellationToken
internal CancellationTokenSource MergedCancellationTokenSource
internal Shared`1<bool> TopLevelDisposedFlag
internal int POLL_INTERVAL
internal CancellationToken MergedCancellationToken
internal CancellationToken get_MergedCancellationToken()
internal void .ctor(CancellationToken externalCancellationToken)
internal void ThrowIfCanceled(CancellationToken token)
internal void ThrowWithStandardMessageIfCanceled(CancellationToken externalCancellationToken)
}
internal System.Linq.Parallel.ConcatKey`2 : ValueType {
private TLeftKey _leftKey
private TRightKey _rightKey
private bool _isLeft
private void .ctor(TLeftKey leftKey, TRightKey rightKey, bool isLeft)
internal ConcatKey`2<TLeftKey, TRightKey> MakeLeft(TLeftKey leftKey)
internal ConcatKey`2<TLeftKey, TRightKey> MakeRight(TRightKey rightKey)
internal IComparer`1<ConcatKey`2<TLeftKey, TRightKey>> MakeComparer(IComparer`1<TLeftKey> leftComparer, IComparer`1<TRightKey> rightComparer)
}
internal System.Linq.Parallel.ConcatQueryOperator`1 : BinaryQueryOperator`3<TSource, TSource, TSource> {
private bool _prematureMergeLeft
private bool _prematureMergeRight
internal bool LimitsParallelism
internal void .ctor(ParallelQuery`1<TSource> firstChild, ParallelQuery`1<TSource> secondChild)
internal QueryResults`1<TSource> Open(QuerySettings settings, bool preferStriping)
public void WrapPartitionedStream(PartitionedStream`2<TSource, TLeftKey> leftStream, PartitionedStream`2<TSource, TRightKey> rightStream, IPartitionedStreamRecipient`1<TSource> outputRecipient, bool preferStriping, QuerySettings settings)
private void WrapHelper(PartitionedStream`2<TSource, TLeftKey> leftStreamInc, PartitionedStream`2<TSource, TRightKey> rightStream, IPartitionedStreamRecipient`1<TSource> outputRecipient, QuerySettings settings, bool preferStriping)
private void WrapHelper2(PartitionedStream`2<TSource, TLeftKey> leftStreamInc, PartitionedStream`2<TSource, TRightKey> rightStreamInc, IPartitionedStreamRecipient`1<TSource> outputRecipient)
internal IEnumerable`1<TSource> AsSequentialQuery(CancellationToken token)
internal bool get_LimitsParallelism()
}
internal System.Linq.Parallel.ContainsSearchOperator`1 : UnaryQueryOperator`2<TInput, bool> {
private TInput _searchValue
private IEqualityComparer`1<TInput> _comparer
internal bool LimitsParallelism
internal void .ctor(IEnumerable`1<TInput> child, TInput searchValue, IEqualityComparer`1<TInput> comparer)
internal bool Aggregate()
internal QueryResults`1<bool> Open(QuerySettings settings, bool preferStriping)
internal void WrapPartitionedStream(PartitionedStream`2<TInput, TKey> inputStream, IPartitionedStreamRecipient`1<bool> recipient, bool preferStriping, QuerySettings settings)
internal IEnumerable`1<bool> AsSequentialQuery(CancellationToken token)
internal bool get_LimitsParallelism()
}
internal System.Linq.Parallel.CountAggregationOperator`1 : InlinedAggregationOperator`3<TSource, int, int> {
internal void .ctor(IEnumerable`1<TSource> child)
protected int InternalAggregate(Exception& singularExceptionToThrow)
protected QueryOperatorEnumerator`2<int, int> CreateEnumerator(int index, int count, QueryOperatorEnumerator`2<TSource, TKey> source, object sharedData, CancellationToken cancellationToken)
}
internal System.Linq.Parallel.DecimalAverageAggregationOperator : InlinedAggregationOperator`3<decimal, Pair`2<decimal, long>, decimal> {
internal void .ctor(IEnumerable`1<decimal> child)
protected decimal InternalAggregate(Exception& singularExceptionToThrow)
protected QueryOperatorEnumerator`2<Pair`2<decimal, long>, int> CreateEnumerator(int index, int count, QueryOperatorEnumerator`2<decimal, TKey> source, object sharedData, CancellationToken cancellationToken)
}
internal System.Linq.Parallel.DecimalMinMaxAggregationOperator : InlinedAggregationOperator`3<decimal, decimal, decimal> {
private int _sign
internal void .ctor(IEnumerable`1<decimal> child, int sign)
protected decimal InternalAggregate(Exception& singularExceptionToThrow)
protected QueryOperatorEnumerator`2<decimal, int> CreateEnumerator(int index, int count, QueryOperatorEnumerator`2<decimal, TKey> source, object sharedData, CancellationToken cancellationToken)
}
internal System.Linq.Parallel.DecimalSumAggregationOperator : InlinedAggregationOperator`3<decimal, decimal, decimal> {
internal void .ctor(IEnumerable`1<decimal> child)
protected decimal InternalAggregate(Exception& singularExceptionToThrow)
protected QueryOperatorEnumerator`2<decimal, int> CreateEnumerator(int index, int count, QueryOperatorEnumerator`2<decimal, TKey> source, object sharedData, CancellationToken cancellationToken)
}
internal System.Linq.Parallel.DefaultIfEmptyQueryOperator`1 : UnaryQueryOperator`2<TSource, TSource> {
private TSource _defaultValue
internal bool LimitsParallelism
internal void .ctor(IEnumerable`1<TSource> child, TSource defaultValue)
internal QueryResults`1<TSource> Open(QuerySettings settings, bool preferStriping)
internal void WrapPartitionedStream(PartitionedStream`2<TSource, TKey> inputStream, IPartitionedStreamRecipient`1<TSource> recipient, bool preferStriping, QuerySettings settings)
internal IEnumerable`1<TSource> AsSequentialQuery(CancellationToken token)
internal bool get_LimitsParallelism()
}
internal System.Linq.Parallel.DefaultMergeHelper`2 : object {
private QueryTaskGroupState _taskGroupState
private PartitionedStream`2<TInputOutput, TIgnoreKey> _partitions
private AsynchronousChannel`1[] _asyncChannels
private SynchronousChannel`1[] _syncChannels
private IEnumerator`1<TInputOutput> _channelEnumerator
private TaskScheduler _taskScheduler
private bool _ignoreOutput
internal void .ctor(PartitionedStream`2<TInputOutput, TIgnoreKey> partitions, bool ignoreOutput, ParallelMergeOptions options, TaskScheduler taskScheduler, CancellationState cancellationState, int queryId)
private void System.Linq.Parallel.IMergeHelper<TInputOutput>.Execute()
private IEnumerator`1<TInputOutput> System.Linq.Parallel.IMergeHelper<TInputOutput>.GetEnumerator()
public TInputOutput[] GetResultsAsArray()
}
internal System.Linq.Parallel.DistinctQueryOperator`1 : UnaryQueryOperator`2<TInputOutput, TInputOutput> {
private IEqualityComparer`1<TInputOutput> _comparer
internal bool LimitsParallelism
internal void .ctor(IEnumerable`1<TInputOutput> source, IEqualityComparer`1<TInputOutput> comparer)
internal QueryResults`1<TInputOutput> Open(QuerySettings settings, bool preferStriping)
internal void WrapPartitionedStream(PartitionedStream`2<TInputOutput, TKey> inputStream, IPartitionedStreamRecipient`1<TInputOutput> recipient, bool preferStriping, QuerySettings settings)
private void WrapPartitionedStreamHelper(PartitionedStream`2<Pair`2<TInputOutput, NoKeyMemoizationRequired>, TKey> hashStream, IPartitionedStreamRecipient`1<TInputOutput> recipient, CancellationToken cancellationToken)
internal bool get_LimitsParallelism()
internal IEnumerable`1<TInputOutput> AsSequentialQuery(CancellationToken token)
}
internal System.Linq.Parallel.DoubleAverageAggregationOperator : InlinedAggregationOperator`3<double, Pair`2<double, long>, double> {
internal void .ctor(IEnumerable`1<double> child)
protected double InternalAggregate(Exception& singularExceptionToThrow)
protected QueryOperatorEnumerator`2<Pair`2<double, long>, int> CreateEnumerator(int index, int count, QueryOperatorEnumerator`2<double, TKey> source, object sharedData, CancellationToken cancellationToken)
}
internal System.Linq.Parallel.DoubleMinMaxAggregationOperator : InlinedAggregationOperator`3<double, double, double> {
private int _sign
internal void .ctor(IEnumerable`1<double> child, int sign)
protected double InternalAggregate(Exception& singularExceptionToThrow)
protected QueryOperatorEnumerator`2<double, int> CreateEnumerator(int index, int count, QueryOperatorEnumerator`2<double, TKey> source, object sharedData, CancellationToken cancellationToken)
}
internal System.Linq.Parallel.DoubleSumAggregationOperator : InlinedAggregationOperator`3<double, double, double> {
internal void .ctor(IEnumerable`1<double> child)
protected double InternalAggregate(Exception& singularExceptionToThrow)
protected QueryOperatorEnumerator`2<double, int> CreateEnumerator(int index, int count, QueryOperatorEnumerator`2<double, TKey> source, object sharedData, CancellationToken cancellationToken)
}
internal System.Linq.Parallel.ElementAtQueryOperator`1 : UnaryQueryOperator`2<TSource, TSource> {
private int _index
private bool _prematureMerge
private bool _limitsParallelism
internal bool LimitsParallelism
internal void .ctor(IEnumerable`1<TSource> child, int index)
internal QueryResults`1<TSource> Open(QuerySettings settings, bool preferStriping)
internal void WrapPartitionedStream(PartitionedStream`2<TSource, TKey> inputStream, IPartitionedStreamRecipient`1<TSource> recipient, bool preferStriping, QuerySettings settings)
internal IEnumerable`1<TSource> AsSequentialQuery(CancellationToken token)
internal bool get_LimitsParallelism()
internal bool Aggregate(TSource& result, bool withDefaultValue)
}
internal System.Linq.Parallel.EmptyEnumerable`1 : ParallelQuery`1<T> {
private EmptyEnumerable`1 modreq(System.Runtime.CompilerServices.IsVolatile) s_instance
private EmptyEnumerator`1 modreq(System.Runtime.CompilerServices.IsVolatile) s_enumeratorInstance
internal EmptyEnumerable`1<T> Instance
internal EmptyEnumerable`1<T> get_Instance()
public IEnumerator`1<T> GetEnumerator()
}
internal System.Linq.Parallel.EmptyEnumerator`1 : QueryOperatorEnumerator`2<T, int> {
public T Current
private object System.Collections.IEnumerator.Current
internal bool MoveNext(T& currentElement, Int32& currentKey)
public T get_Current()
private object System.Collections.IEnumerator.get_Current()
public bool MoveNext()
private void System.Collections.IEnumerator.Reset()
}
internal System.Linq.Parallel.EnumerableWrapperWeakToStrong : object {
private IEnumerable _wrappedEnumerable
internal void .ctor(IEnumerable wrappedEnumerable)
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
public IEnumerator`1<object> GetEnumerator()
}
internal System.Linq.Parallel.ExceptionAggregator : object {
internal IEnumerable`1<TElement> WrapEnumerable(IEnumerable`1<TElement> source, CancellationState cancellationState)
internal IEnumerable`1<TElement> WrapQueryEnumerator(QueryOperatorEnumerator`2<TElement, TIgnoreKey> source, CancellationState cancellationState)
internal void ThrowOCEorAggregateException(Exception ex, CancellationState cancellationState)
internal Func`2<T, U> WrapFunc(Func`2<T, U> f, CancellationState cancellationState)
private bool ThrowAnOCE(Exception ex, CancellationState cancellationState)
}
internal System.Linq.Parallel.ExceptQueryOperator`1 : BinaryQueryOperator`3<TInputOutput, TInputOutput, TInputOutput> {
private IEqualityComparer`1<TInputOutput> _comparer
internal bool LimitsParallelism
internal void .ctor(ParallelQuery`1<TInputOutput> left, ParallelQuery`1<TInputOutput> right, IEqualityComparer`1<TInputOutput> comparer)
internal QueryResults`1<TInputOutput> Open(QuerySettings settings, bool preferStriping)
public void WrapPartitionedStream(PartitionedStream`2<TInputOutput, TLeftKey> leftStream, PartitionedStream`2<TInputOutput, TRightKey> rightStream, IPartitionedStreamRecipient`1<TInputOutput> outputRecipient, bool preferStriping, QuerySettings settings)
private void WrapPartitionedStreamHelper(PartitionedStream`2<Pair`2<TInputOutput, NoKeyMemoizationRequired>, TLeftKey> leftHashStream, PartitionedStream`2<TInputOutput, TRightKey> rightPartitionedStream, IPartitionedStreamRecipient`1<TInputOutput> outputRecipient, CancellationToken cancellationToken)
internal IEnumerable`1<TInputOutput> AsSequentialQuery(CancellationToken token)
internal bool get_LimitsParallelism()
}
internal System.Linq.Parallel.ExchangeUtilities : object {
internal PartitionedStream`2<T, int> PartitionDataSource(IEnumerable`1<T> source, int partitionCount, bool useStriping)
internal PartitionedStream`2<Pair`2<TElement, THashKey>, int> HashRepartition(PartitionedStream`2<TElement, TIgnoreKey> source, Func`2<TElement, THashKey> keySelector, IEqualityComparer`1<THashKey> keyComparer, IEqualityComparer`1<TElement> elementComparer, CancellationToken cancellationToken)
internal PartitionedStream`2<Pair`2<TElement, THashKey>, TOrderKey> HashRepartitionOrdered(PartitionedStream`2<TElement, TOrderKey> source, Func`2<TElement, THashKey> keySelector, IEqualityComparer`1<THashKey> keyComparer, IEqualityComparer`1<TElement> elementComparer, CancellationToken cancellationToken)
internal OrdinalIndexState Worse(OrdinalIndexState state1, OrdinalIndexState state2)
internal bool IsWorseThan(OrdinalIndexState state1, OrdinalIndexState state2)
}
internal System.Linq.Parallel.FirstQueryOperator`1 : UnaryQueryOperator`2<TSource, TSource> {
private Func`2<TSource, bool> _predicate
private bool _prematureMergeNeeded
internal bool LimitsParallelism
internal void .ctor(IEnumerable`1<TSource> child, Func`2<TSource, bool> predicate)
internal QueryResults`1<TSource> Open(QuerySettings settings, bool preferStriping)
internal void WrapPartitionedStream(PartitionedStream`2<TSource, TKey> inputStream, IPartitionedStreamRecipient`1<TSource> recipient, bool preferStriping, QuerySettings settings)
private void WrapHelper(PartitionedStream`2<TSource, TKey> inputStream, IPartitionedStreamRecipient`1<TSource> recipient, QuerySettings settings)
internal IEnumerable`1<TSource> AsSequentialQuery(CancellationToken token)
internal bool get_LimitsParallelism()
}
internal System.Linq.Parallel.FixedMaxHeap`1 : object {
private TElement[] _elements
private int _count
private IComparer`1<TElement> _comparer
internal int Count
internal int Size
internal TElement MaxValue
internal void .ctor(int maximumSize)
internal void .ctor(int maximumSize, IComparer`1<TElement> comparer)
internal int get_Count()
internal int get_Size()
internal TElement get_MaxValue()
internal void Clear()
internal bool Insert(TElement e)
internal void ReplaceMax(TElement newValue)
internal void RemoveMax()
private void Swap(int i, int j)
private void HeapifyRoot()
private void HeapifyLastLeaf()
}
internal System.Linq.Parallel.FloatAverageAggregationOperator : InlinedAggregationOperator`3<float, Pair`2<double, long>, float> {
internal void .ctor(IEnumerable`1<float> child)
protected float InternalAggregate(Exception& singularExceptionToThrow)
protected QueryOperatorEnumerator`2<Pair`2<double, long>, int> CreateEnumerator(int index, int count, QueryOperatorEnumerator`2<float, TKey> source, object sharedData, CancellationToken cancellationToken)
}
internal System.Linq.Parallel.FloatMinMaxAggregationOperator : InlinedAggregationOperator`3<float, float, float> {
private int _sign
internal void .ctor(IEnumerable`1<float> child, int sign)
protected float InternalAggregate(Exception& singularExceptionToThrow)
protected QueryOperatorEnumerator`2<float, int> CreateEnumerator(int index, int count, QueryOperatorEnumerator`2<float, TKey> source, object sharedData, CancellationToken cancellationToken)
}
internal System.Linq.Parallel.FloatSumAggregationOperator : InlinedAggregationOperator`3<float, double, float> {
internal void .ctor(IEnumerable`1<float> child)
protected float InternalAggregate(Exception& singularExceptionToThrow)
protected QueryOperatorEnumerator`2<double, int> CreateEnumerator(int index, int count, QueryOperatorEnumerator`2<float, TKey> source, object sharedData, CancellationToken cancellationToken)
}
internal System.Linq.Parallel.ForAllOperator`1 : UnaryQueryOperator`2<TInput, TInput> {
private Action`1<TInput> _elementAction
internal bool LimitsParallelism
internal void .ctor(IEnumerable`1<TInput> child, Action`1<TInput> elementAction)
internal void RunSynchronously()
internal QueryResults`1<TInput> Open(QuerySettings settings, bool preferStriping)
internal void WrapPartitionedStream(PartitionedStream`2<TInput, TKey> inputStream, IPartitionedStreamRecipient`1<TInput> recipient, bool preferStriping, QuerySettings settings)
internal IEnumerable`1<TInput> AsSequentialQuery(CancellationToken token)
internal bool get_LimitsParallelism()
}
internal System.Linq.Parallel.ForAllSpoolingTask`2 : SpoolingTaskBase {
private QueryOperatorEnumerator`2<TInputOutput, TIgnoreKey> _source
internal void .ctor(int taskIndex, QueryTaskGroupState groupState, QueryOperatorEnumerator`2<TInputOutput, TIgnoreKey> source)
protected void SpoolingWork()
protected void SpoolingFinally()
}
internal System.Linq.Parallel.GroupByElementSelectorQueryOperatorEnumerator`4 : GroupByQueryOperatorEnumerator`4<TSource, TGroupKey, TElement, TOrderKey> {
private Func`2<TSource, TElement> _elementSelector
internal void .ctor(QueryOperatorEnumerator`2<Pair`2<TSource, TGroupKey>, TOrderKey> source, IEqualityComparer`1<TGroupKey> keyComparer, Func`2<TSource, TElement> elementSelector, CancellationToken cancellationToken)
protected HashLookup`2<Wrapper`1<TGroupKey>, ListChunk`1<TElement>> BuildHashLookup()
}
internal System.Linq.Parallel.GroupByGrouping`2 : object {
private KeyValuePair`2<Wrapper`1<TGroupKey>, ListChunk`1<TElement>> _keyValues
private TGroupKey System.Linq.IGrouping<TGroupKey,TElement>.Key
internal void .ctor(KeyValuePair`2<Wrapper`1<TGroupKey>, ListChunk`1<TElement>> keyValues)
private TGroupKey System.Linq.IGrouping<TGroupKey,TElement>.get_Key()
private IEnumerator`1<TElement> System.Collections.Generic.IEnumerable<TElement>.GetEnumerator()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
}
internal System.Linq.Parallel.GroupByIdentityQueryOperatorEnumerator`3 : GroupByQueryOperatorEnumerator`4<TSource, TGroupKey, TSource, TOrderKey> {
internal void .ctor(QueryOperatorEnumerator`2<Pair`2<TSource, TGroupKey>, TOrderKey> source, IEqualityComparer`1<TGroupKey> keyComparer, CancellationToken cancellationToken)
protected HashLookup`2<Wrapper`1<TGroupKey>, ListChunk`1<TSource>> BuildHashLookup()
}
internal System.Linq.Parallel.GroupByQueryOperator`3 : UnaryQueryOperator`2<TSource, IGrouping`2<TGroupKey, TElement>> {
private Func`2<TSource, TGroupKey> _keySelector
private Func`2<TSource, TElement> _elementSelector
private IEqualityComparer`1<TGroupKey> _keyComparer
internal bool LimitsParallelism
internal void .ctor(IEnumerable`1<TSource> child, Func`2<TSource, TGroupKey> keySelector, Func`2<TSource, TElement> elementSelector, IEqualityComparer`1<TGroupKey> keyComparer)
internal void WrapPartitionedStream(PartitionedStream`2<TSource, TKey> inputStream, IPartitionedStreamRecipient`1<IGrouping`2<TGroupKey, TElement>> recipient, bool preferStriping, QuerySettings settings)
private void WrapPartitionedStreamHelper(PartitionedStream`2<Pair`2<TSource, TGroupKey>, TKey> hashStream, IPartitionedStreamRecipient`1<IGrouping`2<TGroupKey, TElement>> recipient, CancellationToken cancellationToken)
private void WrapPartitionedStreamHelperOrdered(PartitionedStream`2<Pair`2<TSource, TGroupKey>, TKey> hashStream, IPartitionedStreamRecipient`1<IGrouping`2<TGroupKey, TElement>> recipient, CancellationToken cancellationToken)
internal QueryResults`1<IGrouping`2<TGroupKey, TElement>> Open(QuerySettings settings, bool preferStriping)
internal IEnumerable`1<IGrouping`2<TGroupKey, TElement>> AsSequentialQuery(CancellationToken token)
internal bool get_LimitsParallelism()
}
internal System.Linq.Parallel.GroupByQueryOperatorEnumerator`4 : QueryOperatorEnumerator`2<IGrouping`2<TGroupKey, TElement>, TOrderKey> {
protected QueryOperatorEnumerator`2<Pair`2<TSource, TGroupKey>, TOrderKey> _source
protected IEqualityComparer`1<TGroupKey> _keyComparer
protected CancellationToken _cancellationToken
private Mutables<TSource, TGroupKey, TElement, TOrderKey> _mutables
protected void .ctor(QueryOperatorEnumerator`2<Pair`2<TSource, TGroupKey>, TOrderKey> source, IEqualityComparer`1<TGroupKey> keyComparer, CancellationToken cancellationToken)
internal bool MoveNext(IGrouping`2& currentElement, TOrderKey& currentKey)
protected HashLookup`2<Wrapper`1<TGroupKey>, ListChunk`1<TElement>> BuildHashLookup()
protected void Dispose(bool disposing)
}
internal System.Linq.Parallel.GroupJoinQueryOperator`4 : BinaryQueryOperator`3<TLeftInput, TRightInput, TOutput> {
private Func`2<TLeftInput, TKey> _leftKeySelector
private Func`2<TRightInput, TKey> _rightKeySelector
private Func`3<TLeftInput, IEnumerable`1<TRightInput>, TOutput> _resultSelector
private IEqualityComparer`1<TKey> _keyComparer
internal bool LimitsParallelism
internal void .ctor(ParallelQuery`1<TLeftInput> left, ParallelQuery`1<TRightInput> right, Func`2<TLeftInput, TKey> leftKeySelector, Func`2<TRightInput, TKey> rightKeySelector, Func`3<TLeftInput, IEnumerable`1<TRightInput>, TOutput> resultSelector, IEqualityComparer`1<TKey> keyComparer)
internal QueryResults`1<TOutput> Open(QuerySettings settings, bool preferStriping)
public void WrapPartitionedStream(PartitionedStream`2<TLeftInput, TLeftKey> leftStream, PartitionedStream`2<TRightInput, TRightKey> rightStream, IPartitionedStreamRecipient`1<TOutput> outputRecipient, bool preferStriping, QuerySettings settings)
private void WrapPartitionedStreamHelper(PartitionedStream`2<Pair`2<TLeftInput, TKey>, TLeftKey> leftHashStream, PartitionedStream`2<TRightInput, TRightKey> rightPartitionedStream, IPartitionedStreamRecipient`1<TOutput> outputRecipient, int partitionCount, CancellationToken cancellationToken)
internal IEnumerable`1<TOutput> AsSequentialQuery(CancellationToken token)
internal bool get_LimitsParallelism()
}
internal System.Linq.Parallel.GrowingArray`1 : object {
private T[] _array
private int _count
private int DEFAULT_ARRAY_SIZE
internal T[] InternalArray
internal int Count
internal T[] get_InternalArray()
internal int get_Count()
internal void Add(T element)
private void GrowArray(int newSize)
internal void CopyFrom(T[] otherArray, int otherCount)
}
internal System.Linq.Parallel.HashJoinQueryOperatorEnumerator`5 : QueryOperatorEnumerator`2<TOutput, TLeftKey> {
private QueryOperatorEnumerator`2<Pair`2<TLeftInput, THashKey>, TLeftKey> _leftSource
private QueryOperatorEnumerator`2<Pair`2<TRightInput, THashKey>, int> _rightSource
private Func`3<TLeftInput, TRightInput, TOutput> _singleResultSelector
private Func`3<TLeftInput, IEnumerable`1<TRightInput>, TOutput> _groupResultSelector
private IEqualityComparer`1<THashKey> _keyComparer
private CancellationToken _cancellationToken
private Mutables<TLeftInput, TLeftKey, TRightInput, THashKey, TOutput> _mutables
internal void .ctor(QueryOperatorEnumerator`2<Pair`2<TLeftInput, THashKey>, TLeftKey> leftSource, QueryOperatorEnumerator`2<Pair`2<TRightInput, THashKey>, int> rightSource, Func`3<TLeftInput, TRightInput, TOutput> singleResultSelector, Func`3<TLeftInput, IEnumerable`1<TRightInput>, TOutput> groupResultSelector, IEqualityComparer`1<THashKey> keyComparer, CancellationToken cancellationToken)
internal bool MoveNext(TOutput& currentElement, TLeftKey& currentKey)
protected void Dispose(bool disposing)
}
internal System.Linq.Parallel.HashLookup`2 : object {
private Int32[] buckets
private Slot[] slots
private int count
private int freeList
private IEqualityComparer`1<TKey> comparer
private int HashCodeMask
internal TValue Item
internal int Count
internal KeyValuePair`2<TKey, TValue> Item
internal void .ctor(IEqualityComparer`1<TKey> comparer)
internal bool Add(TKey key, TValue value)
internal bool TryGetValue(TKey key, TValue& value)
internal void set_Item(TKey key, TValue value)
private int GetKeyHashCode(TKey key)
private bool AreKeysEqual(TKey key1, TKey key2)
private bool Find(TKey key, bool add, bool set, TValue& value)
private void Resize()
internal int get_Count()
internal KeyValuePair`2<TKey, TValue> get_Item(int index)
}
internal System.Linq.Parallel.HashRepartitionEnumerator`3 : QueryOperatorEnumerator`2<Pair`2<TInputOutput, THashKey>, int> {
private int ENUMERATION_NOT_STARTED
private int _partitionCount
private int _partitionIndex
private Func`2<TInputOutput, THashKey> _keySelector
private HashRepartitionStream`3<TInputOutput, THashKey, int> _repartitionStream
private ListChunk`1[][] _valueExchangeMatrix
private QueryOperatorEnumerator`2<TInputOutput, TIgnoreKey> _source
private CountdownEvent _barrier
private CancellationToken _cancellationToken
private Mutables<TInputOutput, THashKey, TIgnoreKey> _mutables
internal void .ctor(QueryOperatorEnumerator`2<TInputOutput, TIgnoreKey> source, int partitionCount, int partitionIndex, Func`2<TInputOutput, THashKey> keySelector, HashRepartitionStream`3<TInputOutput, THashKey, int> repartitionStream, CountdownEvent barrier, ListChunk`1[][] valueExchangeMatrix, CancellationToken cancellationToken)
internal bool MoveNext(Pair`2& currentElement, Int32& currentKey)
private void EnumerateAndRedistributeElements()
protected void Dispose(bool disposed)
}
internal System.Linq.Parallel.HashRepartitionStream`3 : PartitionedStream`2<Pair`2<TInputOutput, THashKey>, TOrderKey> {
private IEqualityComparer`1<THashKey> _keyComparer
private IEqualityComparer`1<TInputOutput> _elementComparer
private int _distributionMod
private int NULL_ELEMENT_HASH_CODE
private int HashCodeMask
internal void .ctor(int partitionsCount, IComparer`1<TOrderKey> orderKeyComparer, IEqualityComparer`1<THashKey> hashKeyComparer, IEqualityComparer`1<TInputOutput> elementComparer)
internal int GetHashCode(TInputOutput element)
internal int GetHashCode(THashKey key)
}
internal System.Linq.Parallel.IMergeHelper`1 {
public void Execute()
public IEnumerator`1<TInputOutput> GetEnumerator()
public TInputOutput[] GetResultsAsArray()
}
internal System.Linq.Parallel.IndexedSelectQueryOperator`2 : UnaryQueryOperator`2<TInput, TOutput> {
private Func`3<TInput, int, TOutput> _selector
private bool _prematureMerge
private bool _limitsParallelism
internal bool LimitsParallelism
internal void .ctor(IEnumerable`1<TInput> child, Func`3<TInput, int, TOutput> selector)
private void InitOrdinalIndexState()
internal QueryResults`1<TOutput> Open(QuerySettings settings, bool preferStriping)
internal void WrapPartitionedStream(PartitionedStream`2<TInput, TKey> inputStream, IPartitionedStreamRecipient`1<TOutput> recipient, bool preferStriping, QuerySettings settings)
internal bool get_LimitsParallelism()
internal IEnumerable`1<TOutput> AsSequentialQuery(CancellationToken token)
}
internal System.Linq.Parallel.IndexedWhereQueryOperator`1 : UnaryQueryOperator`2<TInputOutput, TInputOutput> {
private Func`3<TInputOutput, int, bool> _predicate
private bool _prematureMerge
private bool _limitsParallelism
internal bool LimitsParallelism
internal void .ctor(IEnumerable`1<TInputOutput> child, Func`3<TInputOutput, int, bool> predicate)
private void InitOrdinalIndexState()
internal QueryResults`1<TInputOutput> Open(QuerySettings settings, bool preferStriping)
internal void WrapPartitionedStream(PartitionedStream`2<TInputOutput, TKey> inputStream, IPartitionedStreamRecipient`1<TInputOutput> recipient, bool preferStriping, QuerySettings settings)
internal IEnumerable`1<TInputOutput> AsSequentialQuery(CancellationToken token)
internal bool get_LimitsParallelism()
}
internal System.Linq.Parallel.InlinedAggregationOperator`3 : UnaryQueryOperator`2<TSource, TIntermediate> {
internal bool LimitsParallelism
internal void .ctor(IEnumerable`1<TSource> child)
internal TResult Aggregate()
protected TResult InternalAggregate(Exception& singularExceptionToThrow)
internal QueryResults`1<TIntermediate> Open(QuerySettings settings, bool preferStriping)
internal void WrapPartitionedStream(PartitionedStream`2<TSource, TKey> inputStream, IPartitionedStreamRecipient`1<TIntermediate> recipient, bool preferStriping, QuerySettings settings)
protected QueryOperatorEnumerator`2<TIntermediate, int> CreateEnumerator(int index, int count, QueryOperatorEnumerator`2<TSource, TKey> source, object sharedData, CancellationToken cancellationToken)
internal IEnumerable`1<TIntermediate> AsSequentialQuery(CancellationToken token)
internal bool get_LimitsParallelism()
}
internal System.Linq.Parallel.InlinedAggregationOperatorEnumerator`1 : QueryOperatorEnumerator`2<TIntermediate, int> {
private int _partitionIndex
private bool _done
protected CancellationToken _cancellationToken
internal void .ctor(int partitionIndex, CancellationToken cancellationToken)
internal bool MoveNext(TIntermediate& currentElement, Int32& currentKey)
protected bool MoveNextCore(TIntermediate& currentElement)
}
internal System.Linq.Parallel.IntAverageAggregationOperator : InlinedAggregationOperator`3<int, Pair`2<long, long>, double> {
internal void .ctor(IEnumerable`1<int> child)
protected double InternalAggregate(Exception& singularExceptionToThrow)
protected QueryOperatorEnumerator`2<Pair`2<long, long>, int> CreateEnumerator(int index, int count, QueryOperatorEnumerator`2<int, TKey> source, object sharedData, CancellationToken cancellationToken)
}
internal System.Linq.Parallel.IntersectQueryOperator`1 : BinaryQueryOperator`3<TInputOutput, TInputOutput, TInputOutput> {
private IEqualityComparer`1<TInputOutput> _comparer
internal bool LimitsParallelism
internal void .ctor(ParallelQuery`1<TInputOutput> left, ParallelQuery`1<TInputOutput> right, IEqualityComparer`1<TInputOutput> comparer)
internal QueryResults`1<TInputOutput> Open(QuerySettings settings, bool preferStriping)
public void WrapPartitionedStream(PartitionedStream`2<TInputOutput, TLeftKey> leftPartitionedStream, PartitionedStream`2<TInputOutput, TRightKey> rightPartitionedStream, IPartitionedStreamRecipient`1<TInputOutput> outputRecipient, bool preferStriping, QuerySettings settings)
private void WrapPartitionedStreamHelper(PartitionedStream`2<Pair`2<TInputOutput, NoKeyMemoizationRequired>, TLeftKey> leftHashStream, PartitionedStream`2<TInputOutput, TRightKey> rightPartitionedStream, IPartitionedStreamRecipient`1<TInputOutput> outputRecipient, CancellationToken cancellationToken)
internal bool get_LimitsParallelism()
internal IEnumerable`1<TInputOutput> AsSequentialQuery(CancellationToken token)
}
internal System.Linq.Parallel.IntMinMaxAggregationOperator : InlinedAggregationOperator`3<int, int, int> {
private int _sign
internal void .ctor(IEnumerable`1<int> child, int sign)
protected int InternalAggregate(Exception& singularExceptionToThrow)
protected QueryOperatorEnumerator`2<int, int> CreateEnumerator(int index, int count, QueryOperatorEnumerator`2<int, TKey> source, object sharedData, CancellationToken cancellationToken)
}
internal System.Linq.Parallel.IntSumAggregationOperator : InlinedAggregationOperator`3<int, int, int> {
internal void .ctor(IEnumerable`1<int> child)
protected int InternalAggregate(Exception& singularExceptionToThrow)
protected QueryOperatorEnumerator`2<int, int> CreateEnumerator(int index, int count, QueryOperatorEnumerator`2<int, TKey> source, object sharedData, CancellationToken cancellationToken)
}
internal System.Linq.Parallel.IntValueEvent : ManualResetEventSlim {
internal int Value
internal void Set(int index)
}
internal System.Linq.Parallel.IParallelPartitionable`1 {
public QueryOperatorEnumerator`2[] GetPartitions(int partitionCount)
}
internal System.Linq.Parallel.IPartitionedStreamRecipient`1 {
public void Receive(PartitionedStream`2<TElement, TKey> partitionedStream)
}
internal System.Linq.Parallel.JaggedArray`1 : object {
public TElement[][] Allocate(int size1, int size2)
}
internal System.Linq.Parallel.JoinQueryOperator`4 : BinaryQueryOperator`3<TLeftInput, TRightInput, TOutput> {
private Func`2<TLeftInput, TKey> _leftKeySelector
private Func`2<TRightInput, TKey> _rightKeySelector
private Func`3<TLeftInput, TRightInput, TOutput> _resultSelector
private IEqualityComparer`1<TKey> _keyComparer
internal bool LimitsParallelism
internal void .ctor(ParallelQuery`1<TLeftInput> left, ParallelQuery`1<TRightInput> right, Func`2<TLeftInput, TKey> leftKeySelector, Func`2<TRightInput, TKey> rightKeySelector, Func`3<TLeftInput, TRightInput, TOutput> resultSelector, IEqualityComparer`1<TKey> keyComparer)
public void WrapPartitionedStream(PartitionedStream`2<TLeftInput, TLeftKey> leftStream, PartitionedStream`2<TRightInput, TRightKey> rightStream, IPartitionedStreamRecipient`1<TOutput> outputRecipient, bool preferStriping, QuerySettings settings)
private void WrapPartitionedStreamHelper(PartitionedStream`2<Pair`2<TLeftInput, TKey>, TLeftKey> leftHashStream, PartitionedStream`2<TRightInput, TRightKey> rightPartitionedStream, IPartitionedStreamRecipient`1<TOutput> outputRecipient, CancellationToken cancellationToken)
internal QueryResults`1<TOutput> Open(QuerySettings settings, bool preferStriping)
internal IEnumerable`1<TOutput> AsSequentialQuery(CancellationToken token)
internal bool get_LimitsParallelism()
}
internal System.Linq.Parallel.LastQueryOperator`1 : UnaryQueryOperator`2<TSource, TSource> {
private Func`2<TSource, bool> _predicate
private bool _prematureMergeNeeded
internal bool LimitsParallelism
internal void .ctor(IEnumerable`1<TSource> child, Func`2<TSource, bool> predicate)
internal QueryResults`1<TSource> Open(QuerySettings settings, bool preferStriping)
internal void WrapPartitionedStream(PartitionedStream`2<TSource, TKey> inputStream, IPartitionedStreamRecipient`1<TSource> recipient, bool preferStriping, QuerySettings settings)
private void WrapHelper(PartitionedStream`2<TSource, TKey> inputStream, IPartitionedStreamRecipient`1<TSource> recipient, QuerySettings settings)
internal IEnumerable`1<TSource> AsSequentialQuery(CancellationToken token)
internal bool get_LimitsParallelism()
}
internal System.Linq.Parallel.ListChunk`1 : object {
internal TInputOutput[] _chunk
private int _chunkCount
private ListChunk`1<TInputOutput> _nextChunk
private ListChunk`1<TInputOutput> _tailChunk
internal ListChunk`1<TInputOutput> Next
internal int Count
internal void .ctor(int size)
internal void Add(TInputOutput e)
internal ListChunk`1<TInputOutput> get_Next()
internal int get_Count()
public IEnumerator`1<TInputOutput> GetEnumerator()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
}
internal System.Linq.Parallel.ListQueryResults`1 : QueryResults`1<T> {
private IList`1<T> _source
private int _partitionCount
private bool _useStriping
internal bool IsIndexible
internal int ElementsCount
internal void .ctor(IList`1<T> source, int partitionCount, bool useStriping)
internal void GivePartitionedStream(IPartitionedStreamRecipient`1<T> recipient)
internal bool get_IsIndexible()
internal int get_ElementsCount()
internal T GetElement(int index)
internal PartitionedStream`2<T, int> GetPartitionedStream()
}
internal System.Linq.Parallel.LongAverageAggregationOperator : InlinedAggregationOperator`3<long, Pair`2<long, long>, double> {
internal void .ctor(IEnumerable`1<long> child)
protected double InternalAggregate(Exception& singularExceptionToThrow)
protected QueryOperatorEnumerator`2<Pair`2<long, long>, int> CreateEnumerator(int index, int count, QueryOperatorEnumerator`2<long, TKey> source, object sharedData, CancellationToken cancellationToken)
}
internal System.Linq.Parallel.LongCountAggregationOperator`1 : InlinedAggregationOperator`3<TSource, long, long> {
internal void .ctor(IEnumerable`1<TSource> child)
protected long InternalAggregate(Exception& singularExceptionToThrow)
protected QueryOperatorEnumerator`2<long, int> CreateEnumerator(int index, int count, QueryOperatorEnumerator`2<TSource, TKey> source, object sharedData, CancellationToken cancellationToken)
}
internal System.Linq.Parallel.LongMinMaxAggregationOperator : InlinedAggregationOperator`3<long, long, long> {
private int _sign
internal void .ctor(IEnumerable`1<long> child, int sign)
protected long InternalAggregate(Exception& singularExceptionToThrow)
protected QueryOperatorEnumerator`2<long, int> CreateEnumerator(int index, int count, QueryOperatorEnumerator`2<long, TKey> source, object sharedData, CancellationToken cancellationToken)
}
internal System.Linq.Parallel.LongSumAggregationOperator : InlinedAggregationOperator`3<long, long, long> {
internal void .ctor(IEnumerable`1<long> child)
protected long InternalAggregate(Exception& singularExceptionToThrow)
protected QueryOperatorEnumerator`2<long, int> CreateEnumerator(int index, int count, QueryOperatorEnumerator`2<long, TKey> source, object sharedData, CancellationToken cancellationToken)
}
internal System.Linq.Parallel.Lookup`2 : object {
private IDictionary`2<TKey, IGrouping`2<TKey, TElement>> _dict
private IEqualityComparer`1<TKey> _comparer
private IGrouping`2<TKey, TElement> _defaultKeyGrouping
public int Count
public IEnumerable`1<TElement> Item
internal void .ctor(IEqualityComparer`1<TKey> comparer)
public int get_Count()
public IEnumerable`1<TElement> get_Item(TKey key)
public bool Contains(TKey key)
internal void Add(IGrouping`2<TKey, TElement> grouping)
public IEnumerator`1<IGrouping`2<TKey, TElement>> GetEnumerator()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
}
internal System.Linq.Parallel.MergeEnumerator`1 : object {
protected QueryTaskGroupState _taskGroupState
public TInputOutput Current
private object System.Collections.IEnumerator.Current
protected void .ctor(QueryTaskGroupState taskGroupState)
public TInputOutput get_Current()
public bool MoveNext()
private object System.Collections.IEnumerator.get_Current()
public void Reset()
public void Dispose()
}
internal System.Linq.Parallel.MergeExecutor`1 : object {
private IMergeHelper`1<TInputOutput> _mergeHelper
internal MergeExecutor`1<TInputOutput> Execute(PartitionedStream`2<TInputOutput, TKey> partitions, bool ignoreOutput, ParallelMergeOptions options, TaskScheduler taskScheduler, bool isOrdered, CancellationState cancellationState, int queryId)
private void Execute()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
public IEnumerator`1<TInputOutput> GetEnumerator()
internal TInputOutput[] GetResultsAsArray()
internal AsynchronousChannel`1[] MakeAsynchronousChannels(int partitionCount, ParallelMergeOptions options, IntValueEvent consumerEvent, CancellationToken cancellationToken)
internal SynchronousChannel`1[] MakeSynchronousChannels(int partitionCount)
}
internal System.Linq.Parallel.NullableDecimalAverageAggregationOperator : InlinedAggregationOperator`3<Nullable`1<decimal>, Pair`2<decimal, long>, Nullable`1<decimal>> {
internal void .ctor(IEnumerable`1<Nullable`1<decimal>> child)
protected Nullable`1<decimal> InternalAggregate(Exception& singularExceptionToThrow)
protected QueryOperatorEnumerator`2<Pair`2<decimal, long>, int> CreateEnumerator(int index, int count, QueryOperatorEnumerator`2<Nullable`1<decimal>, TKey> source, object sharedData, CancellationToken cancellationToken)
}
internal System.Linq.Parallel.NullableDecimalMinMaxAggregationOperator : InlinedAggregationOperator`3<Nullable`1<decimal>, Nullable`1<decimal>, Nullable`1<decimal>> {
private int _sign
internal void .ctor(IEnumerable`1<Nullable`1<decimal>> child, int sign)
protected Nullable`1<decimal> InternalAggregate(Exception& singularExceptionToThrow)
protected QueryOperatorEnumerator`2<Nullable`1<decimal>, int> CreateEnumerator(int index, int count, QueryOperatorEnumerator`2<Nullable`1<decimal>, TKey> source, object sharedData, CancellationToken cancellationToken)
}
internal System.Linq.Parallel.NullableDecimalSumAggregationOperator : InlinedAggregationOperator`3<Nullable`1<decimal>, Nullable`1<decimal>, Nullable`1<decimal>> {
internal void .ctor(IEnumerable`1<Nullable`1<decimal>> child)
protected Nullable`1<decimal> InternalAggregate(Exception& singularExceptionToThrow)
protected QueryOperatorEnumerator`2<Nullable`1<decimal>, int> CreateEnumerator(int index, int count, QueryOperatorEnumerator`2<Nullable`1<decimal>, TKey> source, object sharedData, CancellationToken cancellationToken)
}
internal System.Linq.Parallel.NullableDoubleAverageAggregationOperator : InlinedAggregationOperator`3<Nullable`1<double>, Pair`2<double, long>, Nullable`1<double>> {
internal void .ctor(IEnumerable`1<Nullable`1<double>> child)
protected Nullable`1<double> InternalAggregate(Exception& singularExceptionToThrow)
protected QueryOperatorEnumerator`2<Pair`2<double, long>, int> CreateEnumerator(int index, int count, QueryOperatorEnumerator`2<Nullable`1<double>, TKey> source, object sharedData, CancellationToken cancellationToken)
}
internal System.Linq.Parallel.NullableDoubleMinMaxAggregationOperator : InlinedAggregationOperator`3<Nullable`1<double>, Nullable`1<double>, Nullable`1<double>> {
private int _sign
internal void .ctor(IEnumerable`1<Nullable`1<double>> child, int sign)
protected Nullable`1<double> InternalAggregate(Exception& singularExceptionToThrow)
protected QueryOperatorEnumerator`2<Nullable`1<double>, int> CreateEnumerator(int index, int count, QueryOperatorEnumerator`2<Nullable`1<double>, TKey> source, object sharedData, CancellationToken cancellationToken)
}
internal System.Linq.Parallel.NullableDoubleSumAggregationOperator : InlinedAggregationOperator`3<Nullable`1<double>, Nullable`1<double>, Nullable`1<double>> {
internal void .ctor(IEnumerable`1<Nullable`1<double>> child)
protected Nullable`1<double> InternalAggregate(Exception& singularExceptionToThrow)
protected QueryOperatorEnumerator`2<Nullable`1<double>, int> CreateEnumerator(int index, int count, QueryOperatorEnumerator`2<Nullable`1<double>, TKey> source, object sharedData, CancellationToken cancellationToken)
}
internal System.Linq.Parallel.NullableFloatAverageAggregationOperator : InlinedAggregationOperator`3<Nullable`1<float>, Pair`2<double, long>, Nullable`1<float>> {
internal void .ctor(IEnumerable`1<Nullable`1<float>> child)
protected Nullable`1<float> InternalAggregate(Exception& singularExceptionToThrow)
protected QueryOperatorEnumerator`2<Pair`2<double, long>, int> CreateEnumerator(int index, int count, QueryOperatorEnumerator`2<Nullable`1<float>, TKey> source, object sharedData, CancellationToken cancellationToken)
}
internal System.Linq.Parallel.NullableFloatMinMaxAggregationOperator : InlinedAggregationOperator`3<Nullable`1<float>, Nullable`1<float>, Nullable`1<float>> {
private int _sign
internal void .ctor(IEnumerable`1<Nullable`1<float>> child, int sign)
protected Nullable`1<float> InternalAggregate(Exception& singularExceptionToThrow)
protected QueryOperatorEnumerator`2<Nullable`1<float>, int> CreateEnumerator(int index, int count, QueryOperatorEnumerator`2<Nullable`1<float>, TKey> source, object sharedData, CancellationToken cancellationToken)
}
internal System.Linq.Parallel.NullableFloatSumAggregationOperator : InlinedAggregationOperator`3<Nullable`1<float>, Nullable`1<double>, Nullable`1<float>> {
internal void .ctor(IEnumerable`1<Nullable`1<float>> child)
protected Nullable`1<float> InternalAggregate(Exception& singularExceptionToThrow)
protected QueryOperatorEnumerator`2<Nullable`1<double>, int> CreateEnumerator(int index, int count, QueryOperatorEnumerator`2<Nullable`1<float>, TKey> source, object sharedData, CancellationToken cancellationToken)
}
internal System.Linq.Parallel.NullableIntAverageAggregationOperator : InlinedAggregationOperator`3<Nullable`1<int>, Pair`2<long, long>, Nullable`1<double>> {
internal void .ctor(IEnumerable`1<Nullable`1<int>> child)
protected Nullable`1<double> InternalAggregate(Exception& singularExceptionToThrow)
protected QueryOperatorEnumerator`2<Pair`2<long, long>, int> CreateEnumerator(int index, int count, QueryOperatorEnumerator`2<Nullable`1<int>, TKey> source, object sharedData, CancellationToken cancellationToken)
}
internal System.Linq.Parallel.NullableIntMinMaxAggregationOperator : InlinedAggregationOperator`3<Nullable`1<int>, Nullable`1<int>, Nullable`1<int>> {
private int _sign
internal void .ctor(IEnumerable`1<Nullable`1<int>> child, int sign)
protected Nullable`1<int> InternalAggregate(Exception& singularExceptionToThrow)
protected QueryOperatorEnumerator`2<Nullable`1<int>, int> CreateEnumerator(int index, int count, QueryOperatorEnumerator`2<Nullable`1<int>, TKey> source, object sharedData, CancellationToken cancellationToken)
}
internal System.Linq.Parallel.NullableIntSumAggregationOperator : InlinedAggregationOperator`3<Nullable`1<int>, Nullable`1<int>, Nullable`1<int>> {
internal void .ctor(IEnumerable`1<Nullable`1<int>> child)
protected Nullable`1<int> InternalAggregate(Exception& singularExceptionToThrow)
protected QueryOperatorEnumerator`2<Nullable`1<int>, int> CreateEnumerator(int index, int count, QueryOperatorEnumerator`2<Nullable`1<int>, TKey> source, object sharedData, CancellationToken cancellationToken)
}
internal System.Linq.Parallel.NullableLongAverageAggregationOperator : InlinedAggregationOperator`3<Nullable`1<long>, Pair`2<long, long>, Nullable`1<double>> {
internal void .ctor(IEnumerable`1<Nullable`1<long>> child)
protected Nullable`1<double> InternalAggregate(Exception& singularExceptionToThrow)
protected QueryOperatorEnumerator`2<Pair`2<long, long>, int> CreateEnumerator(int index, int count, QueryOperatorEnumerator`2<Nullable`1<long>, TKey> source, object sharedData, CancellationToken cancellationToken)
}
internal System.Linq.Parallel.NullableLongMinMaxAggregationOperator : InlinedAggregationOperator`3<Nullable`1<long>, Nullable`1<long>, Nullable`1<long>> {
private int _sign
internal void .ctor(IEnumerable`1<Nullable`1<long>> child, int sign)
protected Nullable`1<long> InternalAggregate(Exception& singularExceptionToThrow)
protected QueryOperatorEnumerator`2<Nullable`1<long>, int> CreateEnumerator(int index, int count, QueryOperatorEnumerator`2<Nullable`1<long>, TKey> source, object sharedData, CancellationToken cancellationToken)
}
internal System.Linq.Parallel.NullableLongSumAggregationOperator : InlinedAggregationOperator`3<Nullable`1<long>, Nullable`1<long>, Nullable`1<long>> {
internal void .ctor(IEnumerable`1<Nullable`1<long>> child)
protected Nullable`1<long> InternalAggregate(Exception& singularExceptionToThrow)
protected QueryOperatorEnumerator`2<Nullable`1<long>, int> CreateEnumerator(int index, int count, QueryOperatorEnumerator`2<Nullable`1<long>, TKey> source, object sharedData, CancellationToken cancellationToken)
}
internal System.Linq.Parallel.OrderedGroupByElementSelectorQueryOperatorEnumerator`4 : OrderedGroupByQueryOperatorEnumerator`4<TSource, TGroupKey, TElement, TOrderKey> {
private Func`2<TSource, TElement> _elementSelector
internal void .ctor(QueryOperatorEnumerator`2<Pair`2<TSource, TGroupKey>, TOrderKey> source, Func`2<TSource, TGroupKey> keySelector, Func`2<TSource, TElement> elementSelector, IEqualityComparer`1<TGroupKey> keyComparer, IComparer`1<TOrderKey> orderComparer, CancellationToken cancellationToken)
protected HashLookup`2<Wrapper`1<TGroupKey>, GroupKeyData<TSource, TGroupKey, TElement, TOrderKey>> BuildHashLookup()
}
internal System.Linq.Parallel.OrderedGroupByGrouping`3 : object {
private TGroupKey _groupKey
private GrowingArray`1<TElement> _values
private GrowingArray`1<TOrderKey> _orderKeys
private IComparer`1<TOrderKey> _orderComparer
private KeyAndValuesComparer<TGroupKey, TOrderKey, TElement> _wrappedComparer
private TGroupKey System.Linq.IGrouping<TGroupKey,TElement>.Key
internal void .ctor(TGroupKey groupKey, IComparer`1<TOrderKey> orderComparer)
private TGroupKey System.Linq.IGrouping<TGroupKey,TElement>.get_Key()
private IEnumerator`1<TElement> System.Collections.Generic.IEnumerable<TElement>.GetEnumerator()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
internal void Add(TElement value, TOrderKey orderKey)
internal void DoneAdding()
}
internal System.Linq.Parallel.OrderedGroupByIdentityQueryOperatorEnumerator`3 : OrderedGroupByQueryOperatorEnumerator`4<TSource, TGroupKey, TSource, TOrderKey> {
internal void .ctor(QueryOperatorEnumerator`2<Pair`2<TSource, TGroupKey>, TOrderKey> source, Func`2<TSource, TGroupKey> keySelector, IEqualityComparer`1<TGroupKey> keyComparer, IComparer`1<TOrderKey> orderComparer, CancellationToken cancellationToken)
protected HashLookup`2<Wrapper`1<TGroupKey>, GroupKeyData<TSource, TGroupKey, TSource, TOrderKey>> BuildHashLookup()
}
internal System.Linq.Parallel.OrderedGroupByQueryOperatorEnumerator`4 : QueryOperatorEnumerator`2<IGrouping`2<TGroupKey, TElement>, TOrderKey> {
protected QueryOperatorEnumerator`2<Pair`2<TSource, TGroupKey>, TOrderKey> _source
private Func`2<TSource, TGroupKey> _keySelector
protected IEqualityComparer`1<TGroupKey> _keyComparer
protected IComparer`1<TOrderKey> _orderComparer
protected CancellationToken _cancellationToken
private Mutables<TSource, TGroupKey, TElement, TOrderKey> _mutables
protected void .ctor(QueryOperatorEnumerator`2<Pair`2<TSource, TGroupKey>, TOrderKey> source, Func`2<TSource, TGroupKey> keySelector, IEqualityComparer`1<TGroupKey> keyComparer, IComparer`1<TOrderKey> orderComparer, CancellationToken cancellationToken)
internal bool MoveNext(IGrouping`2& currentElement, TOrderKey& currentKey)
protected HashLookup`2<Wrapper`1<TGroupKey>, GroupKeyData<TSource, TGroupKey, TElement, TOrderKey>> BuildHashLookup()
protected void Dispose(bool disposing)
}
internal System.Linq.Parallel.OrderedHashRepartitionEnumerator`3 : QueryOperatorEnumerator`2<Pair`2<TInputOutput, THashKey>, TOrderKey> {
private int ENUMERATION_NOT_STARTED
private int _partitionCount
private int _partitionIndex
private Func`2<TInputOutput, THashKey> _keySelector
private HashRepartitionStream`3<TInputOutput, THashKey, TOrderKey> _repartitionStream
private ListChunk`1[][] _valueExchangeMatrix
private ListChunk`1[][] _keyExchangeMatrix
private QueryOperatorEnumerator`2<TInputOutput, TOrderKey> _source
private CountdownEvent _barrier
private CancellationToken _cancellationToken
private Mutables<TInputOutput, THashKey, TOrderKey> _mutables
internal void .ctor(QueryOperatorEnumerator`2<TInputOutput, TOrderKey> source, int partitionCount, int partitionIndex, Func`2<TInputOutput, THashKey> keySelector, OrderedHashRepartitionStream`3<TInputOutput, THashKey, TOrderKey> repartitionStream, CountdownEvent barrier, ListChunk`1[][] valueExchangeMatrix, ListChunk`1[][] keyExchangeMatrix, CancellationToken cancellationToken)
internal bool MoveNext(Pair`2& currentElement, TOrderKey& currentKey)
private void EnumerateAndRedistributeElements()
protected void Dispose(bool disposing)
}
internal System.Linq.Parallel.OrderedHashRepartitionStream`3 : HashRepartitionStream`3<TInputOutput, THashKey, TOrderKey> {
internal void .ctor(PartitionedStream`2<TInputOutput, TOrderKey> inputStream, Func`2<TInputOutput, THashKey> hashKeySelector, IEqualityComparer`1<THashKey> hashKeyComparer, IEqualityComparer`1<TInputOutput> elementComparer, CancellationToken cancellationToken)
}
internal System.Linq.Parallel.OrderingQueryOperator`1 : QueryOperator`1<TSource> {
private QueryOperator`1<TSource> _child
private OrdinalIndexState _ordinalIndexState
internal bool LimitsParallelism
internal OrdinalIndexState OrdinalIndexState
public void .ctor(QueryOperator`1<TSource> child, bool orderOn)
internal QueryResults`1<TSource> Open(QuerySettings settings, bool preferStriping)
internal IEnumerator`1<TSource> GetEnumerator(Nullable`1<ParallelMergeOptions> mergeOptions, bool suppressOrderPreservation)
internal IEnumerable`1<TSource> AsSequentialQuery(CancellationToken token)
internal bool get_LimitsParallelism()
internal OrdinalIndexState get_OrdinalIndexState()
}
internal System.Linq.Parallel.OrderPreservingMergeHelper`2 : object {
private QueryTaskGroupState _taskGroupState
private PartitionedStream`2<TInputOutput, TKey> _partitions
private Shared`1<TInputOutput[]> _results
private TaskScheduler _taskScheduler
internal void .ctor(PartitionedStream`2<TInputOutput, TKey> partitions, TaskScheduler taskScheduler, CancellationState cancellationState, int queryId)
private void System.Linq.Parallel.IMergeHelper<TInputOutput>.Execute()
private IEnumerator`1<TInputOutput> System.Linq.Parallel.IMergeHelper<TInputOutput>.GetEnumerator()
public TInputOutput[] GetResultsAsArray()
}
internal System.Linq.Parallel.OrderPreservingPipeliningMergeHelper`2 : object {
private QueryTaskGroupState _taskGroupState
private PartitionedStream`2<TOutput, TKey> _partitions
private TaskScheduler _taskScheduler
private bool _autoBuffered
private Queue`1[] _buffers
private Boolean[] _producerDone
private Boolean[] _producerWaiting
private Boolean[] _consumerWaiting
private Object[] _bufferLocks
private IComparer`1<Producer`1<TKey>> _producerComparer
internal int INITIAL_BUFFER_SIZE
internal int STEAL_BUFFER_SIZE
internal int MAX_BUFFER_SIZE
internal void .ctor(PartitionedStream`2<TOutput, TKey> partitions, TaskScheduler taskScheduler, CancellationState cancellationState, bool autoBuffered, int queryId, IComparer`1<TKey> keyComparer)
private void System.Linq.Parallel.IMergeHelper<TOutput>.Execute()
private IEnumerator`1<TOutput> System.Linq.Parallel.IMergeHelper<TOutput>.GetEnumerator()
public TOutput[] GetResultsAsArray()
}
internal System.Linq.Parallel.OrderPreservingPipeliningSpoolingTask`2 : SpoolingTaskBase {
private QueryTaskGroupState _taskGroupState
private QueryOperatorEnumerator`2<TOutput, TKey> _partition
private Boolean[] _consumerWaiting
private Boolean[] _producerWaiting
private Boolean[] _producerDone
private int _partitionIndex
private Queue`1[] _buffers
private object _bufferLock
private bool _autoBuffered
private int PRODUCER_BUFFER_AUTO_SIZE
internal void .ctor(QueryOperatorEnumerator`2<TOutput, TKey> partition, QueryTaskGroupState taskGroupState, Boolean[] consumerWaiting, Boolean[] producerWaiting, Boolean[] producerDone, int partitionIndex, Queue`1[] buffers, object bufferLock, bool autoBuffered)
protected void SpoolingWork()
public void Spool(QueryTaskGroupState groupState, PartitionedStream`2<TOutput, TKey> partitions, Boolean[] consumerWaiting, Boolean[] producerWaiting, Boolean[] producerDone, Queue`1[] buffers, Object[] bufferLocks, TaskScheduler taskScheduler, bool autoBuffered)
protected void SpoolingFinally()
}
internal System.Linq.Parallel.OrderPreservingSpoolingTask`2 : SpoolingTaskBase {
private Shared`1<TInputOutput[]> _results
private SortHelper`1<TInputOutput> _sortHelper
private void .ctor(int taskIndex, QueryTaskGroupState groupState, Shared`1<TInputOutput[]> results, SortHelper`1<TInputOutput> sortHelper)
internal void Spool(QueryTaskGroupState groupState, PartitionedStream`2<TInputOutput, TKey> partitions, Shared`1<TInputOutput[]> results, TaskScheduler taskScheduler)
protected void SpoolingWork()
}
internal System.Linq.Parallel.OrdinalIndexState : Enum {
public byte value__
public OrdinalIndexState Indexable
public OrdinalIndexState Correct
public OrdinalIndexState Increasing
public OrdinalIndexState Shuffled
}
internal System.Linq.Parallel.Pair`2 : ValueType {
internal T _first
internal U _second
public T First
public U Second
public void .ctor(T first, U second)
public T get_First()
public void set_First(T value)
public U get_Second()
public void set_Second(U value)
}
internal System.Linq.Parallel.PairComparer`2 : object {
private IComparer`1<T> _comparer1
private IComparer`1<U> _comparer2
public void .ctor(IComparer`1<T> comparer1, IComparer`1<U> comparer2)
public int Compare(Pair`2<T, U> x, Pair`2<T, U> y)
}
internal System.Linq.Parallel.ParallelEnumerableWrapper : ParallelQuery`1<object> {
private IEnumerable _source
internal void .ctor(IEnumerable source)
internal IEnumerator GetEnumeratorUntyped()
public IEnumerator`1<object> GetEnumerator()
}
internal System.Linq.Parallel.ParallelEnumerableWrapper`1 : ParallelQuery`1<T> {
private IEnumerable`1<T> _wrappedEnumerable
internal IEnumerable`1<T> WrappedEnumerable
internal void .ctor(IEnumerable`1<T> wrappedEnumerable)
internal IEnumerable`1<T> get_WrappedEnumerable()
public IEnumerator`1<T> GetEnumerator()
}
internal System.Linq.Parallel.PartitionedDataSource`1 : PartitionedStream`2<T, int> {
internal void .ctor(IEnumerable`1<T> source, int partitionCount, bool useStriping)
private void InitializePartitions(IEnumerable`1<T> source, int partitionCount, bool useStriping)
private QueryOperatorEnumerator`2[] MakePartitions(IEnumerator`1<T> source, int partitionCount)
}
internal System.Linq.Parallel.PartitionedStream`2 : object {
protected QueryOperatorEnumerator`2[] _partitions
private IComparer`1<TKey> _keyComparer
private OrdinalIndexState _indexState
internal QueryOperatorEnumerator`2<TElement, TKey> Item
public int PartitionCount
internal IComparer`1<TKey> KeyComparer
internal OrdinalIndexState OrdinalIndexState
internal void .ctor(int partitionCount, IComparer`1<TKey> keyComparer, OrdinalIndexState indexState)
internal QueryOperatorEnumerator`2<TElement, TKey> get_Item(int index)
internal void set_Item(int index, QueryOperatorEnumerator`2<TElement, TKey> value)
public int get_PartitionCount()
internal IComparer`1<TKey> get_KeyComparer()
internal OrdinalIndexState get_OrdinalIndexState()
}
internal System.Linq.Parallel.PartitionedStreamMerger`1 : object {
private bool _forEffectMerge
private ParallelMergeOptions _mergeOptions
private bool _isOrdered
private MergeExecutor`1<TOutput> _mergeExecutor
private TaskScheduler _taskScheduler
private int _queryId
private CancellationState _cancellationState
internal MergeExecutor`1<TOutput> MergeExecutor
internal MergeExecutor`1<TOutput> get_MergeExecutor()
internal void .ctor(bool forEffectMerge, ParallelMergeOptions mergeOptions, TaskScheduler taskScheduler, bool outputOrdered, CancellationState cancellationState, int queryId)
public void Receive(PartitionedStream`2<TOutput, TKey> partitionedStream)
}
internal System.Linq.Parallel.PartitionerQueryOperator`1 : QueryOperator`1<TElement> {
private Partitioner`1<TElement> _partitioner
internal bool Orderable
internal OrdinalIndexState OrdinalIndexState
internal bool LimitsParallelism
internal void .ctor(Partitioner`1<TElement> partitioner)
internal bool get_Orderable()
internal QueryResults`1<TElement> Open(QuerySettings settings, bool preferStriping)
internal IEnumerable`1<TElement> AsSequentialQuery(CancellationToken token)
internal OrdinalIndexState get_OrdinalIndexState()
internal OrdinalIndexState GetOrdinalIndexState(Partitioner`1<TElement> partitioner)
internal bool get_LimitsParallelism()
}
internal System.Linq.Parallel.PipelineSpoolingTask`2 : SpoolingTaskBase {
private QueryOperatorEnumerator`2<TInputOutput, TIgnoreKey> _source
private AsynchronousChannel`1<TInputOutput> _destination
internal void .ctor(int taskIndex, QueryTaskGroupState groupState, QueryOperatorEnumerator`2<TInputOutput, TIgnoreKey> source, AsynchronousChannel`1<TInputOutput> destination)
protected void SpoolingWork()
protected void SpoolingFinally()
}
internal System.Linq.Parallel.PlinqEtwProvider : EventSource {
internal PlinqEtwProvider Log
private int s_defaultSchedulerId
private int s_queryId
private EventKeywords ALL_KEYWORDS
private int PARALLELQUERYBEGIN_EVENTID
private int PARALLELQUERYEND_EVENTID
private int PARALLELQUERYFORK_EVENTID
private int PARALLELQUERYJOIN_EVENTID
internal int NextQueryId()
internal void ParallelQueryBegin(int queryId)
private void ParallelQueryBegin(int taskSchedulerId, int taskId, int queryId)
internal void ParallelQueryEnd(int queryId)
private void ParallelQueryEnd(int taskSchedulerId, int taskId, int queryId)
internal void ParallelQueryFork(int queryId)
private void ParallelQueryFork(int taskSchedulerId, int taskId, int queryId)
internal void ParallelQueryJoin(int queryId)
private void ParallelQueryJoin(int taskSchedulerId, int taskId, int queryId)
}
internal System.Linq.Parallel.Producer`1 : ValueType {
internal TKey MaxKey
internal int ProducerIndex
internal void .ctor(TKey maxKey, int producerIndex)
}
internal System.Linq.Parallel.ProducerComparerInt : object {
public int Compare(Producer`1<int> x, Producer`1<int> y)
}
internal System.Linq.Parallel.QueryAggregationOptions : Enum {
public int value__
public QueryAggregationOptions None
public QueryAggregationOptions Associative
public QueryAggregationOptions Commutative
public QueryAggregationOptions AssociativeCommutative
}
internal System.Linq.Parallel.QueryAggregationOptionsExtensions : object {
public bool IsValidQueryAggregationOption(QueryAggregationOptions value)
}
internal System.Linq.Parallel.QueryExecutionOption`1 : QueryOperator`1<TSource> {
private QueryOperator`1<TSource> _child
private OrdinalIndexState _indexState
internal OrdinalIndexState OrdinalIndexState
internal bool LimitsParallelism
internal void .ctor(QueryOperator`1<TSource> source, QuerySettings settings)
internal QueryResults`1<TSource> Open(QuerySettings settings, bool preferStriping)
internal IEnumerable`1<TSource> AsSequentialQuery(CancellationToken token)
internal OrdinalIndexState get_OrdinalIndexState()
internal bool get_LimitsParallelism()
}
internal System.Linq.Parallel.QueryLifecycle : object {
internal void LogicalQueryExecutionBegin(int queryID)
internal void LogicalQueryExecutionEnd(int queryID)
}
internal System.Linq.Parallel.QueryOpeningEnumerator`1 : object {
private QueryOperator`1<TOutput> _queryOperator
private IEnumerator`1<TOutput> _openedQueryEnumerator
private QuerySettings _querySettings
private Nullable`1<ParallelMergeOptions> _mergeOptions
private bool _suppressOrderPreservation
private int _moveNextIteration
private bool _hasQueryOpeningFailed
private Shared`1<bool> _topLevelDisposedFlag
private CancellationTokenSource _topLevelCancellationTokenSource
public TOutput Current
private object System.Collections.IEnumerator.Current
internal void .ctor(QueryOperator`1<TOutput> queryOperator, Nullable`1<ParallelMergeOptions> mergeOptions, bool suppressOrderPreservation)
public TOutput get_Current()
public void Dispose()
private object System.Collections.IEnumerator.get_Current()
public bool MoveNext()
private void OpenQuery()
public void Reset()
}
internal System.Linq.Parallel.QueryOperator`1 : ParallelQuery`1<TOutput> {
protected bool _outputOrdered
internal bool OutputOrdered
internal bool LimitsParallelism
internal OrdinalIndexState OrdinalIndexState
internal void .ctor(QuerySettings settings)
internal void .ctor(bool isOrdered, QuerySettings settings)
internal QueryResults`1<TOutput> Open(QuerySettings settings, bool preferStriping)
public IEnumerator`1<TOutput> GetEnumerator()
public IEnumerator`1<TOutput> GetEnumerator(Nullable`1<ParallelMergeOptions> mergeOptions)
internal bool get_OutputOrdered()
internal IEnumerator`1<TOutput> GetEnumerator(Nullable`1<ParallelMergeOptions> mergeOptions, bool suppressOrderPreservation)
internal IEnumerator`1<TOutput> GetOpenedEnumerator(Nullable`1<ParallelMergeOptions> mergeOptions, bool suppressOrder, bool forEffect, QuerySettings querySettings)
private QueryResults`1<TOutput> GetQueryResults(QuerySettings querySettings)
internal TOutput[] ExecuteAndGetResultsAsArray()
internal IEnumerable`1<TOutput> AsSequentialQuery(CancellationToken token)
internal bool get_LimitsParallelism()
internal OrdinalIndexState get_OrdinalIndexState()
internal ListQueryResults`1<TOutput> ExecuteAndCollectResults(PartitionedStream`2<TOutput, TKey> openedChild, int partitionCount, bool outputOrdered, bool useStriping, QuerySettings settings)
internal QueryOperator`1<TOutput> AsQueryOperator(IEnumerable`1<TOutput> source)
}
internal System.Linq.Parallel.QueryOperatorEnumerator`2 : object {
internal bool MoveNext(TElement& currentElement, TKey& currentKey)
public void Dispose()
protected void Dispose(bool disposing)
internal void Reset()
internal IEnumerator`1<TElement> AsClassicEnumerator()
}
internal System.Linq.Parallel.QueryResults`1 : object {
internal bool IsIndexible
internal int ElementsCount
public T Item
public int Count
private bool System.Collections.Generic.ICollection<T>.IsReadOnly
internal void GivePartitionedStream(IPartitionedStreamRecipient`1<T> recipient)
internal bool get_IsIndexible()
internal T GetElement(int index)
internal int get_ElementsCount()
private int System.Collections.Generic.IList<T>.IndexOf(T item)
private void System.Collections.Generic.IList<T>.Insert(int index, T item)
private void System.Collections.Generic.IList<T>.RemoveAt(int index)
public T get_Item(int index)
public void set_Item(int index, T value)
private void System.Collections.Generic.ICollection<T>.Add(T item)
private void System.Collections.Generic.ICollection<T>.Clear()
private bool System.Collections.Generic.ICollection<T>.Contains(T item)
private void System.Collections.Generic.ICollection<T>.CopyTo(T[] array, int arrayIndex)
public int get_Count()
private bool System.Collections.Generic.ICollection<T>.get_IsReadOnly()
private bool System.Collections.Generic.ICollection<T>.Remove(T item)
private IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
}
internal System.Linq.Parallel.QuerySettings : ValueType {
private TaskScheduler _taskScheduler
private Nullable`1<int> _degreeOfParallelism
private CancellationState _cancellationState
private Nullable`1<ParallelExecutionMode> _executionMode
private Nullable`1<ParallelMergeOptions> _mergeOptions
private int _queryId
internal CancellationState CancellationState
internal TaskScheduler TaskScheduler
internal Nullable`1<int> DegreeOfParallelism
internal Nullable`1<ParallelExecutionMode> ExecutionMode
internal Nullable`1<ParallelMergeOptions> MergeOptions
internal int QueryId
internal QuerySettings Empty
internal CancellationState get_CancellationState()
internal void set_CancellationState(CancellationState value)
internal TaskScheduler get_TaskScheduler()
internal void set_TaskScheduler(TaskScheduler value)
internal Nullable`1<int> get_DegreeOfParallelism()
internal void set_DegreeOfParallelism(Nullable`1<int> value)
internal Nullable`1<ParallelExecutionMode> get_ExecutionMode()
internal void set_ExecutionMode(Nullable`1<ParallelExecutionMode> value)
internal Nullable`1<ParallelMergeOptions> get_MergeOptions()
internal void set_MergeOptions(Nullable`1<ParallelMergeOptions> value)
internal int get_QueryId()
internal void .ctor(TaskScheduler taskScheduler, Nullable`1<int> degreeOfParallelism, CancellationToken externalCancellationToken, Nullable`1<ParallelExecutionMode> executionMode, Nullable`1<ParallelMergeOptions> mergeOptions)
internal QuerySettings Merge(QuerySettings settings2)
internal QuerySettings WithPerExecutionSettings()
internal QuerySettings WithPerExecutionSettings(CancellationTokenSource topLevelCancellationTokenSource, Shared`1<bool> topLevelDisposedFlag)
internal QuerySettings WithDefaults()
internal QuerySettings get_Empty()
public void CleanStateAtQueryEnd()
}
internal System.Linq.Parallel.QueryTask : object {
protected int _taskIndex
protected QueryTaskGroupState _groupState
private Action`1<object> s_runTaskSynchronouslyDelegate
private Action`1<object> s_baseWorkDelegate
protected void .ctor(int taskIndex, QueryTaskGroupState groupState)
private void RunTaskSynchronously(object o)
internal Task RunSynchronously(TaskScheduler taskScheduler)
internal Task RunAsynchronously(TaskScheduler taskScheduler)
private void BaseWork(object unused)
protected void Work()
}
internal System.Linq.Parallel.QueryTaskGroupState : object {
private Task _rootTask
private int _alreadyEnded
private CancellationState _cancellationState
private int _queryId
internal bool IsAlreadyEnded
internal CancellationState CancellationState
internal int QueryId
internal void .ctor(CancellationState cancellationState, int queryId)
internal bool get_IsAlreadyEnded()
internal CancellationState get_CancellationState()
internal int get_QueryId()
internal void QueryBegin(Task rootTask)
internal void QueryEnd(bool userInitiatedDispose)
}
internal System.Linq.Parallel.RangeEnumerable : ParallelQuery`1<int> {
private int _from
private int _count
internal void .ctor(int from, int count)
public QueryOperatorEnumerator`2[] GetPartitions(int partitionCount)
public IEnumerator`1<int> GetEnumerator()
}
internal System.Linq.Parallel.RepeatEnumerable`1 : ParallelQuery`1<TResult> {
private TResult _element
private int _count
internal void .ctor(TResult element, int count)
public QueryOperatorEnumerator`2[] GetPartitions(int partitionCount)
public IEnumerator`1<TResult> GetEnumerator()
}
internal System.Linq.Parallel.ReverseComparer`1 : object {
private IComparer`1<T> _comparer
internal void .ctor(IComparer`1<T> comparer)
public int Compare(T x, T y)
}
internal System.Linq.Parallel.ReverseQueryOperator`1 : UnaryQueryOperator`2<TSource, TSource> {
internal bool LimitsParallelism
internal void .ctor(IEnumerable`1<TSource> child)
internal void WrapPartitionedStream(PartitionedStream`2<TSource, TKey> inputStream, IPartitionedStreamRecipient`1<TSource> recipient, bool preferStriping, QuerySettings settings)
internal QueryResults`1<TSource> Open(QuerySettings settings, bool preferStriping)
internal IEnumerable`1<TSource> AsSequentialQuery(CancellationToken token)
internal bool get_LimitsParallelism()
}
internal System.Linq.Parallel.ScanQueryOperator`1 : QueryOperator`1<TElement> {
private IEnumerable`1<TElement> _data
public IEnumerable`1<TElement> Data
internal OrdinalIndexState OrdinalIndexState
internal bool LimitsParallelism
internal void .ctor(IEnumerable`1<TElement> data)
public IEnumerable`1<TElement> get_Data()
internal QueryResults`1<TElement> Open(QuerySettings settings, bool preferStriping)
internal IEnumerator`1<TElement> GetEnumerator(Nullable`1<ParallelMergeOptions> mergeOptions, bool suppressOrderPreservation)
internal IEnumerable`1<TElement> AsSequentialQuery(CancellationToken token)
internal OrdinalIndexState get_OrdinalIndexState()
internal bool get_LimitsParallelism()
}
internal System.Linq.Parallel.Scheduling : object {
internal bool DefaultPreserveOrder
internal int DefaultDegreeOfParallelism
internal int DEFAULT_BOUNDED_BUFFER_CAPACITY
internal int DEFAULT_BYTES_PER_CHUNK
internal int ZOMBIED_PRODUCER_TIMEOUT
internal int MAX_SUPPORTED_DOP
internal int GetDefaultDegreeOfParallelism()
internal int GetDefaultChunkSize()
}
internal System.Linq.Parallel.SelectManyQueryOperator`3 : UnaryQueryOperator`2<TLeftInput, TOutput> {
private Func`2<TLeftInput, IEnumerable`1<TRightInput>> _rightChildSelector
private Func`3<TLeftInput, int, IEnumerable`1<TRightInput>> _indexedRightChildSelector
private Func`3<TLeftInput, TRightInput, TOutput> _resultSelector
private bool _prematureMerge
private bool _limitsParallelism
internal bool LimitsParallelism
internal void .ctor(IEnumerable`1<TLeftInput> leftChild, Func`2<TLeftInput, IEnumerable`1<TRightInput>> rightChildSelector, Func`3<TLeftInput, int, IEnumerable`1<TRightInput>> indexedRightChildSelector, Func`3<TLeftInput, TRightInput, TOutput> resultSelector)
private void InitOrderIndex()
internal void WrapPartitionedStream(PartitionedStream`2<TLeftInput, TLeftKey> inputStream, IPartitionedStreamRecipient`1<TOutput> recipient, bool preferStriping, QuerySettings settings)
private void WrapPartitionedStreamNotIndexed(PartitionedStream`2<TLeftInput, TLeftKey> inputStream, IPartitionedStreamRecipient`1<TOutput> recipient, QuerySettings settings)
private void WrapPartitionedStreamIndexed(PartitionedStream`2<TLeftInput, int> inputStream, IPartitionedStreamRecipient`1<TOutput> recipient, QuerySettings settings)
internal QueryResults`1<TOutput> Open(QuerySettings settings, bool preferStriping)
internal IEnumerable`1<TOutput> AsSequentialQuery(CancellationToken token)
internal bool get_LimitsParallelism()
}
internal System.Linq.Parallel.SelectQueryOperator`2 : UnaryQueryOperator`2<TInput, TOutput> {
private Func`2<TInput, TOutput> _selector
internal bool LimitsParallelism
internal void .ctor(IEnumerable`1<TInput> child, Func`2<TInput, TOutput> selector)
internal void WrapPartitionedStream(PartitionedStream`2<TInput, TKey> inputStream, IPartitionedStreamRecipient`1<TOutput> recipient, bool preferStriping, QuerySettings settings)
internal QueryResults`1<TOutput> Open(QuerySettings settings, bool preferStriping)
internal IEnumerable`1<TOutput> AsSequentialQuery(CancellationToken token)
internal bool get_LimitsParallelism()
}
internal System.Linq.Parallel.Set`1 : object {
private Int32[] _buckets
private Slot[] _slots
private int _count
private IEqualityComparer`1<TElement> _comparer
private int InitialSize
private int HashCodeMask
public void .ctor(IEqualityComparer`1<TElement> comparer)
public bool Add(TElement value)
public bool Contains(TElement value)
public bool Remove(TElement value)
private bool Find(TElement value, bool add)
private void Resize()
internal int InternalGetHashCode(TElement value)
}
internal System.Linq.Parallel.Shared`1 : object {
internal T Value
internal void .ctor(T value)
}
internal System.Linq.Parallel.SingleQueryOperator`1 : UnaryQueryOperator`2<TSource, TSource> {
private Func`2<TSource, bool> _predicate
internal bool LimitsParallelism
internal void .ctor(IEnumerable`1<TSource> child, Func`2<TSource, bool> predicate)
internal QueryResults`1<TSource> Open(QuerySettings settings, bool preferStriping)
internal void WrapPartitionedStream(PartitionedStream`2<TSource, TKey> inputStream, IPartitionedStreamRecipient`1<TSource> recipient, bool preferStriping, QuerySettings settings)
internal IEnumerable`1<TSource> AsSequentialQuery(CancellationToken token)
internal bool get_LimitsParallelism()
}
internal System.Linq.Parallel.SortHelper`1 : object {
internal TInputOutput[] Sort()
}
internal System.Linq.Parallel.SortHelper`2 : SortHelper`1<TInputOutput> {
private QueryOperatorEnumerator`2<TInputOutput, TKey> _source
private int _partitionCount
private int _partitionIndex
private QueryTaskGroupState _groupState
private Int32[][] _sharedIndices
private GrowingArray`1[] _sharedKeys
private TInputOutput[][] _sharedValues
private Barrier[][] _sharedBarriers
private OrdinalIndexState _indexState
private IComparer`1<TKey> _keyComparer
private void .ctor(QueryOperatorEnumerator`2<TInputOutput, TKey> source, int partitionCount, int partitionIndex, QueryTaskGroupState groupState, Int32[][] sharedIndices, OrdinalIndexState indexState, IComparer`1<TKey> keyComparer, GrowingArray`1[] sharedkeys, TInputOutput[][] sharedValues, Barrier[][] sharedBarriers)
internal SortHelper`2[] GenerateSortHelpers(PartitionedStream`2<TInputOutput, TKey> partitions, QueryTaskGroupState groupState)
public void Dispose()
internal TInputOutput[] Sort()
private void BuildKeysFromSource(GrowingArray`1& keys, List`1& values)
private void QuickSortIndicesInPlace(GrowingArray`1<TKey> keys, List`1<TInputOutput> values, OrdinalIndexState ordinalIndexState)
private void MergeSortCooperatively()
private int ComputePartnerIndex(int phase)
private void QuickSort(int left, int right, TKey[] keys, Int32[] indices, CancellationToken cancelToken)
}
internal System.Linq.Parallel.SortQueryOperator`2 : UnaryQueryOperator`2<TInputOutput, TInputOutput> {
private Func`2<TInputOutput, TSortKey> _keySelector
private IComparer`1<TSortKey> _comparer
internal bool LimitsParallelism
internal void .ctor(IEnumerable`1<TInputOutput> source, Func`2<TInputOutput, TSortKey> keySelector, IComparer`1<TSortKey> comparer, bool descending)
private IOrderedEnumerable`1<TInputOutput> System.Linq.IOrderedEnumerable<TInputOutput>.CreateOrderedEnumerable(Func`2<TInputOutput, TKey2> key2Selector, IComparer`1<TKey2> key2Comparer, bool descending)
internal QueryResults`1<TInputOutput> Open(QuerySettings settings, bool preferStriping)
internal void WrapPartitionedStream(PartitionedStream`2<TInputOutput, TKey> inputStream, IPartitionedStreamRecipient`1<TInputOutput> recipient, bool preferStriping, QuerySettings settings)
internal IEnumerable`1<TInputOutput> AsSequentialQuery(CancellationToken token)
internal bool get_LimitsParallelism()
}
internal System.Linq.Parallel.SortQueryOperatorEnumerator`3 : QueryOperatorEnumerator`2<TInputOutput, TSortKey> {
private QueryOperatorEnumerator`2<TInputOutput, TKey> _source
private Func`2<TInputOutput, TSortKey> _keySelector
internal void .ctor(QueryOperatorEnumerator`2<TInputOutput, TKey> source, Func`2<TInputOutput, TSortKey> keySelector)
internal bool MoveNext(TInputOutput& currentElement, TSortKey& currentKey)
protected void Dispose(bool disposing)
}
internal System.Linq.Parallel.SortQueryOperatorResults`2 : QueryResults`1<TInputOutput> {
protected QueryResults`1<TInputOutput> _childQueryResults
private SortQueryOperator`2<TInputOutput, TSortKey> _op
private QuerySettings _settings
internal bool IsIndexible
internal void .ctor(QueryResults`1<TInputOutput> childQueryResults, SortQueryOperator`2<TInputOutput, TSortKey> op, QuerySettings settings)
internal bool get_IsIndexible()
internal void GivePartitionedStream(IPartitionedStreamRecipient`1<TInputOutput> recipient)
}
internal System.Linq.Parallel.SpoolingTask : object {
internal void SpoolStopAndGo(QueryTaskGroupState groupState, PartitionedStream`2<TInputOutput, TIgnoreKey> partitions, SynchronousChannel`1[] channels, TaskScheduler taskScheduler)
internal void SpoolPipeline(QueryTaskGroupState groupState, PartitionedStream`2<TInputOutput, TIgnoreKey> partitions, AsynchronousChannel`1[] channels, TaskScheduler taskScheduler)
internal void SpoolForAll(QueryTaskGroupState groupState, PartitionedStream`2<TInputOutput, TIgnoreKey> partitions, TaskScheduler taskScheduler)
}
internal System.Linq.Parallel.SpoolingTaskBase : QueryTask {
protected void .ctor(int taskIndex, QueryTaskGroupState groupState)
protected void Work()
protected void SpoolingWork()
protected void SpoolingFinally()
}
internal System.Linq.Parallel.StopAndGoSpoolingTask`2 : SpoolingTaskBase {
private QueryOperatorEnumerator`2<TInputOutput, TIgnoreKey> _source
private SynchronousChannel`1<TInputOutput> _destination
internal void .ctor(int taskIndex, QueryTaskGroupState groupState, QueryOperatorEnumerator`2<TInputOutput, TIgnoreKey> source, SynchronousChannel`1<TInputOutput> destination)
protected void SpoolingWork()
protected void SpoolingFinally()
}
internal System.Linq.Parallel.SynchronousChannel`1 : object {
private Queue`1<T> _queue
internal int Count
internal void Init()
internal void Enqueue(T item)
internal T Dequeue()
internal void SetDone()
internal void CopyTo(T[] array, int arrayIndex)
internal int get_Count()
}
internal System.Linq.Parallel.SynchronousChannelMergeEnumerator`1 : MergeEnumerator`1<T> {
private SynchronousChannel`1[] _channels
private int _channelIndex
private T _currentElement
public T Current
internal void .ctor(QueryTaskGroupState taskGroupState, SynchronousChannel`1[] channels)
public T get_Current()
public bool MoveNext()
}
internal System.Linq.Parallel.TakeOrSkipQueryOperator`1 : UnaryQueryOperator`2<TResult, TResult> {
private int _count
private bool _take
private bool _prematureMerge
internal bool LimitsParallelism
internal void .ctor(IEnumerable`1<TResult> child, int count, bool take)
private OrdinalIndexState OutputOrdinalIndexState()
internal void WrapPartitionedStream(PartitionedStream`2<TResult, TKey> inputStream, IPartitionedStreamRecipient`1<TResult> recipient, bool preferStriping, QuerySettings settings)
private void WrapHelper(PartitionedStream`2<TResult, TKey> inputStream, IPartitionedStreamRecipient`1<TResult> recipient, QuerySettings settings)
internal QueryResults`1<TResult> Open(QuerySettings settings, bool preferStriping)
internal bool get_LimitsParallelism()
internal IEnumerable`1<TResult> AsSequentialQuery(CancellationToken token)
}
internal System.Linq.Parallel.TakeOrSkipWhileQueryOperator`1 : UnaryQueryOperator`2<TResult, TResult> {
private Func`2<TResult, bool> _predicate
private Func`3<TResult, int, bool> _indexedPredicate
private bool _take
private bool _prematureMerge
private bool _limitsParallelism
internal bool LimitsParallelism
internal void .ctor(IEnumerable`1<TResult> child, Func`2<TResult, bool> predicate, Func`3<TResult, int, bool> indexedPredicate, bool take)
private void InitOrderIndexState()
internal void WrapPartitionedStream(PartitionedStream`2<TResult, TKey> inputStream, IPartitionedStreamRecipient`1<TResult> recipient, bool preferStriping, QuerySettings settings)
private void WrapHelper(PartitionedStream`2<TResult, TKey> inputStream, IPartitionedStreamRecipient`1<TResult> recipient, QuerySettings settings)
internal QueryResults`1<TResult> Open(QuerySettings settings, bool preferStriping)
internal IEnumerable`1<TResult> AsSequentialQuery(CancellationToken token)
internal bool get_LimitsParallelism()
}
internal System.Linq.Parallel.TraceHelpers : object {
internal void TraceInfo(string msg, Object[] args)
}
internal System.Linq.Parallel.UnaryQueryOperator`2 : QueryOperator`1<TOutput> {
private QueryOperator`1<TInput> _child
private OrdinalIndexState _indexState
internal QueryOperator`1<TInput> Child
internal OrdinalIndexState OrdinalIndexState
internal void .ctor(IEnumerable`1<TInput> child)
internal void .ctor(IEnumerable`1<TInput> child, bool outputOrdered)
private void .ctor(QueryOperator`1<TInput> child)
internal void .ctor(QueryOperator`1<TInput> child, bool outputOrdered)
private void .ctor(QueryOperator`1<TInput> child, bool outputOrdered, QuerySettings settings)
internal QueryOperator`1<TInput> get_Child()
internal OrdinalIndexState get_OrdinalIndexState()
protected void SetOrdinalIndexState(OrdinalIndexState indexState)
internal void WrapPartitionedStream(PartitionedStream`2<TInput, TKey> inputStream, IPartitionedStreamRecipient`1<TOutput> recipient, bool preferStriping, QuerySettings settings)
}
internal System.Linq.Parallel.UnionQueryOperator`1 : BinaryQueryOperator`3<TInputOutput, TInputOutput, TInputOutput> {
private IEqualityComparer`1<TInputOutput> _comparer
internal bool LimitsParallelism
internal void .ctor(ParallelQuery`1<TInputOutput> left, ParallelQuery`1<TInputOutput> right, IEqualityComparer`1<TInputOutput> comparer)
internal QueryResults`1<TInputOutput> Open(QuerySettings settings, bool preferStriping)
public void WrapPartitionedStream(PartitionedStream`2<TInputOutput, TLeftKey> leftStream, PartitionedStream`2<TInputOutput, TRightKey> rightStream, IPartitionedStreamRecipient`1<TInputOutput> outputRecipient, bool preferStriping, QuerySettings settings)
private void WrapPartitionedStreamFixedLeftType(PartitionedStream`2<Pair`2<TInputOutput, NoKeyMemoizationRequired>, TLeftKey> leftHashStream, PartitionedStream`2<TInputOutput, TRightKey> rightStream, IPartitionedStreamRecipient`1<TInputOutput> outputRecipient, int partitionCount, CancellationToken cancellationToken)
private void WrapPartitionedStreamFixedBothTypes(PartitionedStream`2<Pair`2<TInputOutput, NoKeyMemoizationRequired>, TLeftKey> leftHashStream, PartitionedStream`2<Pair`2<TInputOutput, NoKeyMemoizationRequired>, TRightKey> rightHashStream, IPartitionedStreamRecipient`1<TInputOutput> outputRecipient, int partitionCount, CancellationToken cancellationToken)
internal IEnumerable`1<TInputOutput> AsSequentialQuery(CancellationToken token)
internal bool get_LimitsParallelism()
}
internal System.Linq.Parallel.UnorderedHashRepartitionStream`3 : HashRepartitionStream`3<TInputOutput, THashKey, int> {
internal void .ctor(PartitionedStream`2<TInputOutput, TIgnoreKey> inputStream, Func`2<TInputOutput, THashKey> keySelector, IEqualityComparer`1<THashKey> keyComparer, IEqualityComparer`1<TInputOutput> elementComparer, CancellationToken cancellationToken)
}
internal System.Linq.Parallel.Util : object {
private FastIntComparer s_fastIntComparer
private FastLongComparer s_fastLongComparer
private FastFloatComparer s_fastFloatComparer
private FastDoubleComparer s_fastDoubleComparer
private FastDateTimeComparer s_fastDateTimeComparer
internal int Sign(int x)
internal Comparer`1<TKey> GetDefaultComparer()
}
internal System.Linq.Parallel.WhereQueryOperator`1 : UnaryQueryOperator`2<TInputOutput, TInputOutput> {
private Func`2<TInputOutput, bool> _predicate
internal bool LimitsParallelism
internal void .ctor(IEnumerable`1<TInputOutput> child, Func`2<TInputOutput, bool> predicate)
internal void WrapPartitionedStream(PartitionedStream`2<TInputOutput, TKey> inputStream, IPartitionedStreamRecipient`1<TInputOutput> recipient, bool preferStriping, QuerySettings settings)
internal QueryResults`1<TInputOutput> Open(QuerySettings settings, bool preferStriping)
internal IEnumerable`1<TInputOutput> AsSequentialQuery(CancellationToken token)
internal bool get_LimitsParallelism()
}
internal System.Linq.Parallel.Wrapper`1 : ValueType {
internal T Value
internal void .ctor(T value)
}
internal System.Linq.Parallel.WrapperEqualityComparer`1 : ValueType {
private IEqualityComparer`1<T> _comparer
internal void .ctor(IEqualityComparer`1<T> comparer)
public bool Equals(Wrapper`1<T> x, Wrapper`1<T> y)
public int GetHashCode(Wrapper`1<T> x)
}
internal System.Linq.Parallel.ZipQueryOperator`3 : QueryOperator`1<TOutput> {
private Func`3<TLeftInput, TRightInput, TOutput> _resultSelector
private QueryOperator`1<TLeftInput> _leftChild
private QueryOperator`1<TRightInput> _rightChild
private bool _prematureMergeLeft
private bool _prematureMergeRight
private bool _limitsParallelism
internal OrdinalIndexState OrdinalIndexState
internal bool LimitsParallelism
internal void .ctor(ParallelQuery`1<TLeftInput> leftChildSource, ParallelQuery`1<TRightInput> rightChildSource, Func`3<TLeftInput, TRightInput, TOutput> resultSelector)
private void .ctor(QueryOperator`1<TLeftInput> left, QueryOperator`1<TRightInput> right, Func`3<TLeftInput, TRightInput, TOutput> resultSelector)
internal QueryResults`1<TOutput> Open(QuerySettings settings, bool preferStriping)
internal IEnumerable`1<TOutput> AsSequentialQuery(CancellationToken token)
internal OrdinalIndexState get_OrdinalIndexState()
internal bool get_LimitsParallelism()
}
public System.Linq.ParallelEnumerable : object {
private string RIGHT_SOURCE_NOT_PARALLEL_STR
public ParallelQuery`1<TSource> AsParallel(IEnumerable`1<TSource> source)
public ParallelQuery`1<TSource> AsParallel(Partitioner`1<TSource> source)
public ParallelQuery`1<TSource> AsOrdered(ParallelQuery`1<TSource> source)
public ParallelQuery AsOrdered(ParallelQuery source)
public ParallelQuery`1<TSource> AsUnordered(ParallelQuery`1<TSource> source)
public ParallelQuery AsParallel(IEnumerable source)
public IEnumerable`1<TSource> AsSequential(ParallelQuery`1<TSource> source)
public ParallelQuery`1<TSource> WithDegreeOfParallelism(ParallelQuery`1<TSource> source, int degreeOfParallelism)
public ParallelQuery`1<TSource> WithCancellation(ParallelQuery`1<TSource> source, CancellationToken cancellationToken)
public ParallelQuery`1<TSource> WithExecutionMode(ParallelQuery`1<TSource> source, ParallelExecutionMode executionMode)
public ParallelQuery`1<TSource> WithMergeOptions(ParallelQuery`1<TSource> source, ParallelMergeOptions mergeOptions)
public ParallelQuery`1<int> Range(int start, int count)
public ParallelQuery`1<TResult> Repeat(TResult element, int count)
public ParallelQuery`1<TResult> Empty()
public void ForAll(ParallelQuery`1<TSource> source, Action`1<TSource> action)
public ParallelQuery`1<TSource> Where(ParallelQuery`1<TSource> source, Func`2<TSource, bool> predicate)
public ParallelQuery`1<TSource> Where(ParallelQuery`1<TSource> source, Func`3<TSource, int, bool> predicate)
public ParallelQuery`1<TResult> Select(ParallelQuery`1<TSource> source, Func`2<TSource, TResult> selector)
public ParallelQuery`1<TResult> Select(ParallelQuery`1<TSource> source, Func`3<TSource, int, TResult> selector)
public ParallelQuery`1<TResult> Zip(ParallelQuery`1<TFirst> first, ParallelQuery`1<TSecond> second, Func`3<TFirst, TSecond, TResult> resultSelector)
public ParallelQuery`1<TResult> Zip(ParallelQuery`1<TFirst> first, IEnumerable`1<TSecond> second, Func`3<TFirst, TSecond, TResult> resultSelector)
public ParallelQuery`1<TResult> Join(ParallelQuery`1<TOuter> outer, ParallelQuery`1<TInner> inner, Func`2<TOuter, TKey> outerKeySelector, Func`2<TInner, TKey> innerKeySelector, Func`3<TOuter, TInner, TResult> resultSelector)
public ParallelQuery`1<TResult> Join(ParallelQuery`1<TOuter> outer, IEnumerable`1<TInner> inner, Func`2<TOuter, TKey> outerKeySelector, Func`2<TInner, TKey> innerKeySelector, Func`3<TOuter, TInner, TResult> resultSelector)
public ParallelQuery`1<TResult> Join(ParallelQuery`1<TOuter> outer, ParallelQuery`1<TInner> inner, Func`2<TOuter, TKey> outerKeySelector, Func`2<TInner, TKey> innerKeySelector, Func`3<TOuter, TInner, TResult> resultSelector, IEqualityComparer`1<TKey> comparer)
public ParallelQuery`1<TResult> Join(ParallelQuery`1<TOuter> outer, IEnumerable`1<TInner> inner, Func`2<TOuter, TKey> outerKeySelector, Func`2<TInner, TKey> innerKeySelector, Func`3<TOuter, TInner, TResult> resultSelector, IEqualityComparer`1<TKey> comparer)
public ParallelQuery`1<TResult> GroupJoin(ParallelQuery`1<TOuter> outer, ParallelQuery`1<TInner> inner, Func`2<TOuter, TKey> outerKeySelector, Func`2<TInner, TKey> innerKeySelector, Func`3<TOuter, IEnumerable`1<TInner>, TResult> resultSelector)
public ParallelQuery`1<TResult> GroupJoin(ParallelQuery`1<TOuter> outer, IEnumerable`1<TInner> inner, Func`2<TOuter, TKey> outerKeySelector, Func`2<TInner, TKey> innerKeySelector, Func`3<TOuter, IEnumerable`1<TInner>, TResult> resultSelector)
public ParallelQuery`1<TResult> GroupJoin(ParallelQuery`1<TOuter> outer, ParallelQuery`1<TInner> inner, Func`2<TOuter, TKey> outerKeySelector, Func`2<TInner, TKey> innerKeySelector, Func`3<TOuter, IEnumerable`1<TInner>, TResult> resultSelector, IEqualityComparer`1<TKey> comparer)
public ParallelQuery`1<TResult> GroupJoin(ParallelQuery`1<TOuter> outer, IEnumerable`1<TInner> inner, Func`2<TOuter, TKey> outerKeySelector, Func`2<TInner, TKey> innerKeySelector, Func`3<TOuter, IEnumerable`1<TInner>, TResult> resultSelector, IEqualityComparer`1<TKey> comparer)
public ParallelQuery`1<TResult> SelectMany(ParallelQuery`1<TSource> source, Func`2<TSource, IEnumerable`1<TResult>> selector)
public ParallelQuery`1<TResult> SelectMany(ParallelQuery`1<TSource> source, Func`3<TSource, int, IEnumerable`1<TResult>> selector)
public ParallelQuery`1<TResult> SelectMany(ParallelQuery`1<TSource> source, Func`2<TSource, IEnumerable`1<TCollection>> collectionSelector, Func`3<TSource, TCollection, TResult> resultSelector)
public ParallelQuery`1<TResult> SelectMany(ParallelQuery`1<TSource> source, Func`3<TSource, int, IEnumerable`1<TCollection>> collectionSelector, Func`3<TSource, TCollection, TResult> resultSelector)
public OrderedParallelQuery`1<TSource> OrderBy(ParallelQuery`1<TSource> source, Func`2<TSource, TKey> keySelector)
public OrderedParallelQuery`1<TSource> OrderBy(ParallelQuery`1<TSource> source, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> comparer)
public OrderedParallelQuery`1<TSource> OrderByDescending(ParallelQuery`1<TSource> source, Func`2<TSource, TKey> keySelector)
public OrderedParallelQuery`1<TSource> OrderByDescending(ParallelQuery`1<TSource> source, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> comparer)
public OrderedParallelQuery`1<TSource> ThenBy(OrderedParallelQuery`1<TSource> source, Func`2<TSource, TKey> keySelector)
public OrderedParallelQuery`1<TSource> ThenBy(OrderedParallelQuery`1<TSource> source, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> comparer)
public OrderedParallelQuery`1<TSource> ThenByDescending(OrderedParallelQuery`1<TSource> source, Func`2<TSource, TKey> keySelector)
public OrderedParallelQuery`1<TSource> ThenByDescending(OrderedParallelQuery`1<TSource> source, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> comparer)
public ParallelQuery`1<IGrouping`2<TKey, TSource>> GroupBy(ParallelQuery`1<TSource> source, Func`2<TSource, TKey> keySelector)
public ParallelQuery`1<IGrouping`2<TKey, TSource>> GroupBy(ParallelQuery`1<TSource> source, Func`2<TSource, TKey> keySelector, IEqualityComparer`1<TKey> comparer)
public ParallelQuery`1<IGrouping`2<TKey, TElement>> GroupBy(ParallelQuery`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`2<TSource, TElement> elementSelector)
public ParallelQuery`1<IGrouping`2<TKey, TElement>> GroupBy(ParallelQuery`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`2<TSource, TElement> elementSelector, IEqualityComparer`1<TKey> comparer)
public ParallelQuery`1<TResult> GroupBy(ParallelQuery`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`3<TKey, IEnumerable`1<TSource>, TResult> resultSelector)
public ParallelQuery`1<TResult> GroupBy(ParallelQuery`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`3<TKey, IEnumerable`1<TSource>, TResult> resultSelector, IEqualityComparer`1<TKey> comparer)
public ParallelQuery`1<TResult> GroupBy(ParallelQuery`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`2<TSource, TElement> elementSelector, Func`3<TKey, IEnumerable`1<TElement>, TResult> resultSelector)
public ParallelQuery`1<TResult> GroupBy(ParallelQuery`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`2<TSource, TElement> elementSelector, Func`3<TKey, IEnumerable`1<TElement>, TResult> resultSelector, IEqualityComparer`1<TKey> comparer)
private T PerformAggregation(ParallelQuery`1<T> source, Func`3<T, T, T> reduce, T seed, bool seedIsSpecified, bool throwIfEmpty, QueryAggregationOptions options)
private TAccumulate PerformSequentialAggregation(ParallelQuery`1<TSource> source, TAccumulate seed, bool seedIsSpecified, Func`3<TAccumulate, TSource, TAccumulate> func)
public TSource Aggregate(ParallelQuery`1<TSource> source, Func`3<TSource, TSource, TSource> func)
internal TSource Aggregate(ParallelQuery`1<TSource> source, Func`3<TSource, TSource, TSource> func, QueryAggregationOptions options)
public TAccumulate Aggregate(ParallelQuery`1<TSource> source, TAccumulate seed, Func`3<TAccumulate, TSource, TAccumulate> func)
internal TAccumulate Aggregate(ParallelQuery`1<TSource> source, TAccumulate seed, Func`3<TAccumulate, TSource, TAccumulate> func, QueryAggregationOptions options)
public TResult Aggregate(ParallelQuery`1<TSource> source, TAccumulate seed, Func`3<TAccumulate, TSource, TAccumulate> func, Func`2<TAccumulate, TResult> resultSelector)
public TResult Aggregate(ParallelQuery`1<TSource> source, TAccumulate seed, Func`3<TAccumulate, TSource, TAccumulate> updateAccumulatorFunc, Func`3<TAccumulate, TAccumulate, TAccumulate> combineAccumulatorsFunc, Func`2<TAccumulate, TResult> resultSelector)
public TResult Aggregate(ParallelQuery`1<TSource> source, Func`1<TAccumulate> seedFactory, Func`3<TAccumulate, TSource, TAccumulate> updateAccumulatorFunc, Func`3<TAccumulate, TAccumulate, TAccumulate> combineAccumulatorsFunc, Func`2<TAccumulate, TResult> resultSelector)
public int Count(ParallelQuery`1<TSource> source)
public int Count(ParallelQuery`1<TSource> source, Func`2<TSource, bool> predicate)
public long LongCount(ParallelQuery`1<TSource> source)
public long LongCount(ParallelQuery`1<TSource> source, Func`2<TSource, bool> predicate)
public int Sum(ParallelQuery`1<int> source)
public Nullable`1<int> Sum(ParallelQuery`1<Nullable`1<int>> source)
public long Sum(ParallelQuery`1<long> source)
public Nullable`1<long> Sum(ParallelQuery`1<Nullable`1<long>> source)
public float Sum(ParallelQuery`1<float> source)
public Nullable`1<float> Sum(ParallelQuery`1<Nullable`1<float>> source)
public double Sum(ParallelQuery`1<double> source)
public Nullable`1<double> Sum(ParallelQuery`1<Nullable`1<double>> source)
public decimal Sum(ParallelQuery`1<decimal> source)
public Nullable`1<decimal> Sum(ParallelQuery`1<Nullable`1<decimal>> source)
public int Sum(ParallelQuery`1<TSource> source, Func`2<TSource, int> selector)
public Nullable`1<int> Sum(ParallelQuery`1<TSource> source, Func`2<TSource, Nullable`1<int>> selector)
public long Sum(ParallelQuery`1<TSource> source, Func`2<TSource, long> selector)
public Nullable`1<long> Sum(ParallelQuery`1<TSource> source, Func`2<TSource, Nullable`1<long>> selector)
public float Sum(ParallelQuery`1<TSource> source, Func`2<TSource, float> selector)
public Nullable`1<float> Sum(ParallelQuery`1<TSource> source, Func`2<TSource, Nullable`1<float>> selector)
public double Sum(ParallelQuery`1<TSource> source, Func`2<TSource, double> selector)
public Nullable`1<double> Sum(ParallelQuery`1<TSource> source, Func`2<TSource, Nullable`1<double>> selector)
public decimal Sum(ParallelQuery`1<TSource> source, Func`2<TSource, decimal> selector)
public Nullable`1<decimal> Sum(ParallelQuery`1<TSource> source, Func`2<TSource, Nullable`1<decimal>> selector)
public int Min(ParallelQuery`1<int> source)
public Nullable`1<int> Min(ParallelQuery`1<Nullable`1<int>> source)
public long Min(ParallelQuery`1<long> source)
public Nullable`1<long> Min(ParallelQuery`1<Nullable`1<long>> source)
public float Min(ParallelQuery`1<float> source)
public Nullable`1<float> Min(ParallelQuery`1<Nullable`1<float>> source)
public double Min(ParallelQuery`1<double> source)
public Nullable`1<double> Min(ParallelQuery`1<Nullable`1<double>> source)
public decimal Min(ParallelQuery`1<decimal> source)
public Nullable`1<decimal> Min(ParallelQuery`1<Nullable`1<decimal>> source)
public TSource Min(ParallelQuery`1<TSource> source)
public int Min(ParallelQuery`1<TSource> source, Func`2<TSource, int> selector)
public Nullable`1<int> Min(ParallelQuery`1<TSource> source, Func`2<TSource, Nullable`1<int>> selector)
public long Min(ParallelQuery`1<TSource> source, Func`2<TSource, long> selector)
public Nullable`1<long> Min(ParallelQuery`1<TSource> source, Func`2<TSource, Nullable`1<long>> selector)
public float Min(ParallelQuery`1<TSource> source, Func`2<TSource, float> selector)
public Nullable`1<float> Min(ParallelQuery`1<TSource> source, Func`2<TSource, Nullable`1<float>> selector)
public double Min(ParallelQuery`1<TSource> source, Func`2<TSource, double> selector)
public Nullable`1<double> Min(ParallelQuery`1<TSource> source, Func`2<TSource, Nullable`1<double>> selector)
public decimal Min(ParallelQuery`1<TSource> source, Func`2<TSource, decimal> selector)
public Nullable`1<decimal> Min(ParallelQuery`1<TSource> source, Func`2<TSource, Nullable`1<decimal>> selector)
public TResult Min(ParallelQuery`1<TSource> source, Func`2<TSource, TResult> selector)
public int Max(ParallelQuery`1<int> source)
public Nullable`1<int> Max(ParallelQuery`1<Nullable`1<int>> source)
public long Max(ParallelQuery`1<long> source)
public Nullable`1<long> Max(ParallelQuery`1<Nullable`1<long>> source)
public float Max(ParallelQuery`1<float> source)
public Nullable`1<float> Max(ParallelQuery`1<Nullable`1<float>> source)
public double Max(ParallelQuery`1<double> source)
public Nullable`1<double> Max(ParallelQuery`1<Nullable`1<double>> source)
public decimal Max(ParallelQuery`1<decimal> source)
public Nullable`1<decimal> Max(ParallelQuery`1<Nullable`1<decimal>> source)
public TSource Max(ParallelQuery`1<TSource> source)
public int Max(ParallelQuery`1<TSource> source, Func`2<TSource, int> selector)
public Nullable`1<int> Max(ParallelQuery`1<TSource> source, Func`2<TSource, Nullable`1<int>> selector)
public long Max(ParallelQuery`1<TSource> source, Func`2<TSource, long> selector)
public Nullable`1<long> Max(ParallelQuery`1<TSource> source, Func`2<TSource, Nullable`1<long>> selector)
public float Max(ParallelQuery`1<TSource> source, Func`2<TSource, float> selector)
public Nullable`1<float> Max(ParallelQuery`1<TSource> source, Func`2<TSource, Nullable`1<float>> selector)
public double Max(ParallelQuery`1<TSource> source, Func`2<TSource, double> selector)
public Nullable`1<double> Max(ParallelQuery`1<TSource> source, Func`2<TSource, Nullable`1<double>> selector)
public decimal Max(ParallelQuery`1<TSource> source, Func`2<TSource, decimal> selector)
public Nullable`1<decimal> Max(ParallelQuery`1<TSource> source, Func`2<TSource, Nullable`1<decimal>> selector)
public TResult Max(ParallelQuery`1<TSource> source, Func`2<TSource, TResult> selector)
public double Average(ParallelQuery`1<int> source)
public Nullable`1<double> Average(ParallelQuery`1<Nullable`1<int>> source)
public double Average(ParallelQuery`1<long> source)
public Nullable`1<double> Average(ParallelQuery`1<Nullable`1<long>> source)
public float Average(ParallelQuery`1<float> source)
public Nullable`1<float> Average(ParallelQuery`1<Nullable`1<float>> source)
public double Average(ParallelQuery`1<double> source)
public Nullable`1<double> Average(ParallelQuery`1<Nullable`1<double>> source)
public decimal Average(ParallelQuery`1<decimal> source)
public Nullable`1<decimal> Average(ParallelQuery`1<Nullable`1<decimal>> source)
public double Average(ParallelQuery`1<TSource> source, Func`2<TSource, int> selector)
public Nullable`1<double> Average(ParallelQuery`1<TSource> source, Func`2<TSource, Nullable`1<int>> selector)
public double Average(ParallelQuery`1<TSource> source, Func`2<TSource, long> selector)
public Nullable`1<double> Average(ParallelQuery`1<TSource> source, Func`2<TSource, Nullable`1<long>> selector)
public float Average(ParallelQuery`1<TSource> source, Func`2<TSource, float> selector)
public Nullable`1<float> Average(ParallelQuery`1<TSource> source, Func`2<TSource, Nullable`1<float>> selector)
public double Average(ParallelQuery`1<TSource> source, Func`2<TSource, double> selector)
public Nullable`1<double> Average(ParallelQuery`1<TSource> source, Func`2<TSource, Nullable`1<double>> selector)
public decimal Average(ParallelQuery`1<TSource> source, Func`2<TSource, decimal> selector)
public Nullable`1<decimal> Average(ParallelQuery`1<TSource> source, Func`2<TSource, Nullable`1<decimal>> selector)
public bool Any(ParallelQuery`1<TSource> source, Func`2<TSource, bool> predicate)
public bool Any(ParallelQuery`1<TSource> source)
public bool All(ParallelQuery`1<TSource> source, Func`2<TSource, bool> predicate)
public bool Contains(ParallelQuery`1<TSource> source, TSource value)
public bool Contains(ParallelQuery`1<TSource> source, TSource value, IEqualityComparer`1<TSource> comparer)
public ParallelQuery`1<TSource> Take(ParallelQuery`1<TSource> source, int count)
public ParallelQuery`1<TSource> TakeWhile(ParallelQuery`1<TSource> source, Func`2<TSource, bool> predicate)
public ParallelQuery`1<TSource> TakeWhile(ParallelQuery`1<TSource> source, Func`3<TSource, int, bool> predicate)
public ParallelQuery`1<TSource> Skip(ParallelQuery`1<TSource> source, int count)
public ParallelQuery`1<TSource> SkipWhile(ParallelQuery`1<TSource> source, Func`2<TSource, bool> predicate)
public ParallelQuery`1<TSource> SkipWhile(ParallelQuery`1<TSource> source, Func`3<TSource, int, bool> predicate)
public ParallelQuery`1<TSource> Concat(ParallelQuery`1<TSource> first, ParallelQuery`1<TSource> second)
public ParallelQuery`1<TSource> Concat(ParallelQuery`1<TSource> first, IEnumerable`1<TSource> second)
public bool SequenceEqual(ParallelQuery`1<TSource> first, ParallelQuery`1<TSource> second)
public bool SequenceEqual(ParallelQuery`1<TSource> first, IEnumerable`1<TSource> second)
public bool SequenceEqual(ParallelQuery`1<TSource> first, ParallelQuery`1<TSource> second, IEqualityComparer`1<TSource> comparer)
private void DisposeEnumerator(IEnumerator`1<TSource> e, CancellationState cancelState)
public bool SequenceEqual(ParallelQuery`1<TSource> first, IEnumerable`1<TSource> second, IEqualityComparer`1<TSource> comparer)
public ParallelQuery`1<TSource> Distinct(ParallelQuery`1<TSource> source)
public ParallelQuery`1<TSource> Distinct(ParallelQuery`1<TSource> source, IEqualityComparer`1<TSource> comparer)
public ParallelQuery`1<TSource> Union(ParallelQuery`1<TSource> first, ParallelQuery`1<TSource> second)
public ParallelQuery`1<TSource> Union(ParallelQuery`1<TSource> first, IEnumerable`1<TSource> second)
public ParallelQuery`1<TSource> Union(ParallelQuery`1<TSource> first, ParallelQuery`1<TSource> second, IEqualityComparer`1<TSource> comparer)
public ParallelQuery`1<TSource> Union(ParallelQuery`1<TSource> first, IEnumerable`1<TSource> second, IEqualityComparer`1<TSource> comparer)
public ParallelQuery`1<TSource> Intersect(ParallelQuery`1<TSource> first, ParallelQuery`1<TSource> second)
public ParallelQuery`1<TSource> Intersect(ParallelQuery`1<TSource> first, IEnumerable`1<TSource> second)
public ParallelQuery`1<TSource> Intersect(ParallelQuery`1<TSource> first, ParallelQuery`1<TSource> second, IEqualityComparer`1<TSource> comparer)
public ParallelQuery`1<TSource> Intersect(ParallelQuery`1<TSource> first, IEnumerable`1<TSource> second, IEqualityComparer`1<TSource> comparer)
public ParallelQuery`1<TSource> Except(ParallelQuery`1<TSource> first, ParallelQuery`1<TSource> second)
public ParallelQuery`1<TSource> Except(ParallelQuery`1<TSource> first, IEnumerable`1<TSource> second)
public ParallelQuery`1<TSource> Except(ParallelQuery`1<TSource> first, ParallelQuery`1<TSource> second, IEqualityComparer`1<TSource> comparer)
public ParallelQuery`1<TSource> Except(ParallelQuery`1<TSource> first, IEnumerable`1<TSource> second, IEqualityComparer`1<TSource> comparer)
public IEnumerable`1<TSource> AsEnumerable(ParallelQuery`1<TSource> source)
public TSource[] ToArray(ParallelQuery`1<TSource> source)
public List`1<TSource> ToList(ParallelQuery`1<TSource> source)
public Dictionary`2<TKey, TSource> ToDictionary(ParallelQuery`1<TSource> source, Func`2<TSource, TKey> keySelector)
public Dictionary`2<TKey, TSource> ToDictionary(ParallelQuery`1<TSource> source, Func`2<TSource, TKey> keySelector, IEqualityComparer`1<TKey> comparer)
public Dictionary`2<TKey, TElement> ToDictionary(ParallelQuery`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`2<TSource, TElement> elementSelector)
public Dictionary`2<TKey, TElement> ToDictionary(ParallelQuery`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`2<TSource, TElement> elementSelector, IEqualityComparer`1<TKey> comparer)
public ILookup`2<TKey, TSource> ToLookup(ParallelQuery`1<TSource> source, Func`2<TSource, TKey> keySelector)
public ILookup`2<TKey, TSource> ToLookup(ParallelQuery`1<TSource> source, Func`2<TSource, TKey> keySelector, IEqualityComparer`1<TKey> comparer)
public ILookup`2<TKey, TElement> ToLookup(ParallelQuery`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`2<TSource, TElement> elementSelector)
public ILookup`2<TKey, TElement> ToLookup(ParallelQuery`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`2<TSource, TElement> elementSelector, IEqualityComparer`1<TKey> comparer)
public ParallelQuery`1<TSource> Reverse(ParallelQuery`1<TSource> source)
public ParallelQuery`1<TResult> OfType(ParallelQuery source)
public ParallelQuery`1<TResult> Cast(ParallelQuery source)
private TSource GetOneWithPossibleDefault(QueryOperator`1<TSource> queryOp, bool throwIfTwo, bool defaultIfEmpty)
public TSource First(ParallelQuery`1<TSource> source)
public TSource First(ParallelQuery`1<TSource> source, Func`2<TSource, bool> predicate)
public TSource FirstOrDefault(ParallelQuery`1<TSource> source)
public TSource FirstOrDefault(ParallelQuery`1<TSource> source, Func`2<TSource, bool> predicate)
public TSource Last(ParallelQuery`1<TSource> source)
public TSource Last(ParallelQuery`1<TSource> source, Func`2<TSource, bool> predicate)
public TSource LastOrDefault(ParallelQuery`1<TSource> source)
public TSource LastOrDefault(ParallelQuery`1<TSource> source, Func`2<TSource, bool> predicate)
public TSource Single(ParallelQuery`1<TSource> source)
public TSource Single(ParallelQuery`1<TSource> source, Func`2<TSource, bool> predicate)
public TSource SingleOrDefault(ParallelQuery`1<TSource> source)
public TSource SingleOrDefault(ParallelQuery`1<TSource> source, Func`2<TSource, bool> predicate)
public ParallelQuery`1<TSource> DefaultIfEmpty(ParallelQuery`1<TSource> source)
public ParallelQuery`1<TSource> DefaultIfEmpty(ParallelQuery`1<TSource> source, TSource defaultValue)
public TSource ElementAt(ParallelQuery`1<TSource> source, int index)
public TSource ElementAtOrDefault(ParallelQuery`1<TSource> source, int index)
}
public System.Linq.ParallelExecutionMode : Enum {
public int value__
public ParallelExecutionMode Default
public ParallelExecutionMode ForceParallelism
}
public System.Linq.ParallelMergeOptions : Enum {
public int value__
public ParallelMergeOptions Default
public ParallelMergeOptions NotBuffered
public ParallelMergeOptions AutoBuffered
public ParallelMergeOptions FullyBuffered
}
public System.Linq.ParallelQuery : object {
private QuerySettings _specifiedSettings
internal QuerySettings SpecifiedQuerySettings
internal void .ctor(QuerySettings specifiedSettings)
internal QuerySettings get_SpecifiedQuerySettings()
internal ParallelQuery`1<TCastTo> Cast()
internal ParallelQuery`1<TCastTo> OfType()
internal IEnumerator GetEnumeratorUntyped()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
}
public System.Linq.ParallelQuery`1 : ParallelQuery {
internal void .ctor(QuerySettings settings)
internal ParallelQuery`1<TCastTo> Cast()
internal ParallelQuery`1<TCastTo> OfType()
internal IEnumerator GetEnumeratorUntyped()
public IEnumerator`1<TSource> GetEnumerator()
}
public System.Linq.Queryable : object {
public IQueryable`1<TElement> AsQueryable(IEnumerable`1<TElement> source)
public IQueryable AsQueryable(IEnumerable source)
public IQueryable`1<TSource> Where(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, bool>> predicate)
public IQueryable`1<TSource> Where(IQueryable`1<TSource> source, Expression`1<Func`3<TSource, int, bool>> predicate)
public IQueryable`1<TResult> OfType(IQueryable source)
public IQueryable`1<TResult> Cast(IQueryable source)
public IQueryable`1<TResult> Select(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, TResult>> selector)
public IQueryable`1<TResult> Select(IQueryable`1<TSource> source, Expression`1<Func`3<TSource, int, TResult>> selector)
public IQueryable`1<TResult> SelectMany(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, IEnumerable`1<TResult>>> selector)
public IQueryable`1<TResult> SelectMany(IQueryable`1<TSource> source, Expression`1<Func`3<TSource, int, IEnumerable`1<TResult>>> selector)
public IQueryable`1<TResult> SelectMany(IQueryable`1<TSource> source, Expression`1<Func`3<TSource, int, IEnumerable`1<TCollection>>> collectionSelector, Expression`1<Func`3<TSource, TCollection, TResult>> resultSelector)
public IQueryable`1<TResult> SelectMany(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, IEnumerable`1<TCollection>>> collectionSelector, Expression`1<Func`3<TSource, TCollection, TResult>> resultSelector)
private Expression GetSourceExpression(IEnumerable`1<TSource> source)
public IQueryable`1<TResult> Join(IQueryable`1<TOuter> outer, IEnumerable`1<TInner> inner, Expression`1<Func`2<TOuter, TKey>> outerKeySelector, Expression`1<Func`2<TInner, TKey>> innerKeySelector, Expression`1<Func`3<TOuter, TInner, TResult>> resultSelector)
public IQueryable`1<TResult> Join(IQueryable`1<TOuter> outer, IEnumerable`1<TInner> inner, Expression`1<Func`2<TOuter, TKey>> outerKeySelector, Expression`1<Func`2<TInner, TKey>> innerKeySelector, Expression`1<Func`3<TOuter, TInner, TResult>> resultSelector, IEqualityComparer`1<TKey> comparer)
public IQueryable`1<TResult> GroupJoin(IQueryable`1<TOuter> outer, IEnumerable`1<TInner> inner, Expression`1<Func`2<TOuter, TKey>> outerKeySelector, Expression`1<Func`2<TInner, TKey>> innerKeySelector, Expression`1<Func`3<TOuter, IEnumerable`1<TInner>, TResult>> resultSelector)
public IQueryable`1<TResult> GroupJoin(IQueryable`1<TOuter> outer, IEnumerable`1<TInner> inner, Expression`1<Func`2<TOuter, TKey>> outerKeySelector, Expression`1<Func`2<TInner, TKey>> innerKeySelector, Expression`1<Func`3<TOuter, IEnumerable`1<TInner>, TResult>> resultSelector, IEqualityComparer`1<TKey> comparer)
public IOrderedQueryable`1<TSource> OrderBy(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, TKey>> keySelector)
public IOrderedQueryable`1<TSource> OrderBy(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, TKey>> keySelector, IComparer`1<TKey> comparer)
public IOrderedQueryable`1<TSource> OrderByDescending(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, TKey>> keySelector)
public IOrderedQueryable`1<TSource> OrderByDescending(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, TKey>> keySelector, IComparer`1<TKey> comparer)
public IOrderedQueryable`1<TSource> ThenBy(IOrderedQueryable`1<TSource> source, Expression`1<Func`2<TSource, TKey>> keySelector)
public IOrderedQueryable`1<TSource> ThenBy(IOrderedQueryable`1<TSource> source, Expression`1<Func`2<TSource, TKey>> keySelector, IComparer`1<TKey> comparer)
public IOrderedQueryable`1<TSource> ThenByDescending(IOrderedQueryable`1<TSource> source, Expression`1<Func`2<TSource, TKey>> keySelector)
public IOrderedQueryable`1<TSource> ThenByDescending(IOrderedQueryable`1<TSource> source, Expression`1<Func`2<TSource, TKey>> keySelector, IComparer`1<TKey> comparer)
public IQueryable`1<TSource> Take(IQueryable`1<TSource> source, int count)
public IQueryable`1<TSource> TakeWhile(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, bool>> predicate)
public IQueryable`1<TSource> TakeWhile(IQueryable`1<TSource> source, Expression`1<Func`3<TSource, int, bool>> predicate)
public IQueryable`1<TSource> Skip(IQueryable`1<TSource> source, int count)
public IQueryable`1<TSource> SkipWhile(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, bool>> predicate)
public IQueryable`1<TSource> SkipWhile(IQueryable`1<TSource> source, Expression`1<Func`3<TSource, int, bool>> predicate)
public IQueryable`1<IGrouping`2<TKey, TSource>> GroupBy(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, TKey>> keySelector)
public IQueryable`1<IGrouping`2<TKey, TElement>> GroupBy(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, TKey>> keySelector, Expression`1<Func`2<TSource, TElement>> elementSelector)
public IQueryable`1<IGrouping`2<TKey, TSource>> GroupBy(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, TKey>> keySelector, IEqualityComparer`1<TKey> comparer)
public IQueryable`1<IGrouping`2<TKey, TElement>> GroupBy(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, TKey>> keySelector, Expression`1<Func`2<TSource, TElement>> elementSelector, IEqualityComparer`1<TKey> comparer)
public IQueryable`1<TResult> GroupBy(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, TKey>> keySelector, Expression`1<Func`2<TSource, TElement>> elementSelector, Expression`1<Func`3<TKey, IEnumerable`1<TElement>, TResult>> resultSelector)
public IQueryable`1<TResult> GroupBy(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, TKey>> keySelector, Expression`1<Func`3<TKey, IEnumerable`1<TSource>, TResult>> resultSelector)
public IQueryable`1<TResult> GroupBy(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, TKey>> keySelector, Expression`1<Func`3<TKey, IEnumerable`1<TSource>, TResult>> resultSelector, IEqualityComparer`1<TKey> comparer)
public IQueryable`1<TResult> GroupBy(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, TKey>> keySelector, Expression`1<Func`2<TSource, TElement>> elementSelector, Expression`1<Func`3<TKey, IEnumerable`1<TElement>, TResult>> resultSelector, IEqualityComparer`1<TKey> comparer)
public IQueryable`1<TSource> Distinct(IQueryable`1<TSource> source)
public IQueryable`1<TSource> Distinct(IQueryable`1<TSource> source, IEqualityComparer`1<TSource> comparer)
public IQueryable`1<TSource> Concat(IQueryable`1<TSource> source1, IEnumerable`1<TSource> source2)
public IQueryable`1<TResult> Zip(IQueryable`1<TFirst> source1, IEnumerable`1<TSecond> source2, Expression`1<Func`3<TFirst, TSecond, TResult>> resultSelector)
public IQueryable`1<TSource> Union(IQueryable`1<TSource> source1, IEnumerable`1<TSource> source2)
public IQueryable`1<TSource> Union(IQueryable`1<TSource> source1, IEnumerable`1<TSource> source2, IEqualityComparer`1<TSource> comparer)
public IQueryable`1<TSource> Intersect(IQueryable`1<TSource> source1, IEnumerable`1<TSource> source2)
public IQueryable`1<TSource> Intersect(IQueryable`1<TSource> source1, IEnumerable`1<TSource> source2, IEqualityComparer`1<TSource> comparer)
public IQueryable`1<TSource> Except(IQueryable`1<TSource> source1, IEnumerable`1<TSource> source2)
public IQueryable`1<TSource> Except(IQueryable`1<TSource> source1, IEnumerable`1<TSource> source2, IEqualityComparer`1<TSource> comparer)
public TSource First(IQueryable`1<TSource> source)
public TSource First(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, bool>> predicate)
public TSource FirstOrDefault(IQueryable`1<TSource> source)
public TSource FirstOrDefault(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, bool>> predicate)
public TSource Last(IQueryable`1<TSource> source)
public TSource Last(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, bool>> predicate)
public TSource LastOrDefault(IQueryable`1<TSource> source)
public TSource LastOrDefault(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, bool>> predicate)
public TSource Single(IQueryable`1<TSource> source)
public TSource Single(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, bool>> predicate)
public TSource SingleOrDefault(IQueryable`1<TSource> source)
public TSource SingleOrDefault(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, bool>> predicate)
public TSource ElementAt(IQueryable`1<TSource> source, int index)
public TSource ElementAtOrDefault(IQueryable`1<TSource> source, int index)
public IQueryable`1<TSource> DefaultIfEmpty(IQueryable`1<TSource> source)
public IQueryable`1<TSource> DefaultIfEmpty(IQueryable`1<TSource> source, TSource defaultValue)
public bool Contains(IQueryable`1<TSource> source, TSource item)
public bool Contains(IQueryable`1<TSource> source, TSource item, IEqualityComparer`1<TSource> comparer)
public IQueryable`1<TSource> Reverse(IQueryable`1<TSource> source)
public bool SequenceEqual(IQueryable`1<TSource> source1, IEnumerable`1<TSource> source2)
public bool SequenceEqual(IQueryable`1<TSource> source1, IEnumerable`1<TSource> source2, IEqualityComparer`1<TSource> comparer)
public bool Any(IQueryable`1<TSource> source)
public bool Any(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, bool>> predicate)
public bool All(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, bool>> predicate)
public int Count(IQueryable`1<TSource> source)
public int Count(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, bool>> predicate)
public long LongCount(IQueryable`1<TSource> source)
public long LongCount(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, bool>> predicate)
public TSource Min(IQueryable`1<TSource> source)
public TResult Min(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, TResult>> selector)
public TSource Max(IQueryable`1<TSource> source)
public TResult Max(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, TResult>> selector)
public int Sum(IQueryable`1<int> source)
public Nullable`1<int> Sum(IQueryable`1<Nullable`1<int>> source)
public long Sum(IQueryable`1<long> source)
public Nullable`1<long> Sum(IQueryable`1<Nullable`1<long>> source)
public float Sum(IQueryable`1<float> source)
public Nullable`1<float> Sum(IQueryable`1<Nullable`1<float>> source)
public double Sum(IQueryable`1<double> source)
public Nullable`1<double> Sum(IQueryable`1<Nullable`1<double>> source)
public decimal Sum(IQueryable`1<decimal> source)
public Nullable`1<decimal> Sum(IQueryable`1<Nullable`1<decimal>> source)
public int Sum(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, int>> selector)
public Nullable`1<int> Sum(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, Nullable`1<int>>> selector)
public long Sum(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, long>> selector)
public Nullable`1<long> Sum(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, Nullable`1<long>>> selector)
public float Sum(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, float>> selector)
public Nullable`1<float> Sum(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, Nullable`1<float>>> selector)
public double Sum(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, double>> selector)
public Nullable`1<double> Sum(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, Nullable`1<double>>> selector)
public decimal Sum(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, decimal>> selector)
public Nullable`1<decimal> Sum(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, Nullable`1<decimal>>> selector)
public double Average(IQueryable`1<int> source)
public Nullable`1<double> Average(IQueryable`1<Nullable`1<int>> source)
public double Average(IQueryable`1<long> source)
public Nullable`1<double> Average(IQueryable`1<Nullable`1<long>> source)
public float Average(IQueryable`1<float> source)
public Nullable`1<float> Average(IQueryable`1<Nullable`1<float>> source)
public double Average(IQueryable`1<double> source)
public Nullable`1<double> Average(IQueryable`1<Nullable`1<double>> source)
public decimal Average(IQueryable`1<decimal> source)
public Nullable`1<decimal> Average(IQueryable`1<Nullable`1<decimal>> source)
public double Average(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, int>> selector)
public Nullable`1<double> Average(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, Nullable`1<int>>> selector)
public float Average(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, float>> selector)
public Nullable`1<float> Average(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, Nullable`1<float>>> selector)
public double Average(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, long>> selector)
public Nullable`1<double> Average(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, Nullable`1<long>>> selector)
public double Average(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, double>> selector)
public Nullable`1<double> Average(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, Nullable`1<double>>> selector)
public decimal Average(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, decimal>> selector)
public Nullable`1<decimal> Average(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, Nullable`1<decimal>>> selector)
public TSource Aggregate(IQueryable`1<TSource> source, Expression`1<Func`3<TSource, TSource, TSource>> func)
public TAccumulate Aggregate(IQueryable`1<TSource> source, TAccumulate seed, Expression`1<Func`3<TAccumulate, TSource, TAccumulate>> func)
public TResult Aggregate(IQueryable`1<TSource> source, TAccumulate seed, Expression`1<Func`3<TAccumulate, TSource, TAccumulate>> func, Expression`1<Func`2<TAccumulate, TResult>> selector)
public IQueryable`1<TSource> SkipLast(IQueryable`1<TSource> source, int count)
public IQueryable`1<TSource> TakeLast(IQueryable`1<TSource> source, int count)
public IQueryable`1<TSource> Append(IQueryable`1<TSource> source, TSource element)
public IQueryable`1<TSource> Prepend(IQueryable`1<TSource> source, TSource element)
}
internal System.Linq.Set`1 : object {
private IEqualityComparer`1<TElement> _comparer
private Int32[] _buckets
private Slot[] _slots
private int _count
public int Count
public void .ctor(IEqualityComparer`1<TElement> comparer)
public bool Add(TElement value)
public bool Remove(TElement value)
private void Resize()
public TElement[] ToArray()
public List`1<TElement> ToList()
public int get_Count()
public void UnionWith(IEnumerable`1<TElement> other)
private int InternalGetHashCode(TElement value)
}
internal System.Linq.SingleLinkedNode`1 : object {
private TSource <Item>k__BackingField
private SingleLinkedNode`1<TSource> <Linked>k__BackingField
public TSource Item
public SingleLinkedNode`1<TSource> Linked
public void .ctor(TSource item)
private void .ctor(SingleLinkedNode`1<TSource> linked, TSource item)
public TSource get_Item()
public SingleLinkedNode`1<TSource> get_Linked()
public SingleLinkedNode`1<TSource> Add(TSource item)
public int GetCount()
public IEnumerator`1<TSource> GetEnumerator(int count)
public SingleLinkedNode`1<TSource> GetNode(int index)
private TSource[] ToArray(int count)
}
internal System.Linq.Strings : object {
internal string ArgumentNotIEnumerableGeneric(string message)
internal string ArgumentNotValid(string message)
internal string NoMethodOnType(string name, object type)
internal string NoMethodOnTypeMatchingArguments(string name, object type)
internal string EnumeratingNullEnumerableExpression()
}
internal System.Linq.SystemCore_EnumerableDebugView : object {
private IEnumerable _enumerable
public Object[] Items
public void .ctor(IEnumerable enumerable)
public Object[] get_Items()
}
internal System.Linq.SystemCore_EnumerableDebugView`1 : object {
private IEnumerable`1<T> _enumerable
public T[] Items
public void .ctor(IEnumerable`1<T> enumerable)
public T[] get_Items()
}
internal System.Linq.SystemCore_EnumerableDebugViewEmptyException : Exception {
public string Empty
public string get_Empty()
}
internal System.Linq.SystemLinq_GroupingDebugView`2 : object {
private Grouping`2<TKey, TElement> _grouping
private TElement[] _cachedValues
public TKey Key
public TElement[] Values
public void .ctor(Grouping`2<TKey, TElement> grouping)
public TKey get_Key()
public TElement[] get_Values()
}
internal System.Linq.SystemLinq_LookupDebugView`2 : object {
private Lookup`2<TKey, TElement> _lookup
private IGrouping`2[] _cachedGroupings
public IGrouping`2[] Groupings
public void .ctor(Lookup`2<TKey, TElement> lookup)
public IGrouping`2[] get_Groupings()
}
internal System.Linq.TypeHelper : object {
internal Type FindGenericType(Type definition, Type type)
internal IEnumerable`1<MethodInfo> GetStaticMethods(Type type)
}
internal System.Linq.Utilities : object {
public bool AreEqualityComparersEqual(IEqualityComparer`1<TSource> left, IEqualityComparer`1<TSource> right)
public Func`2<TSource, bool> CombinePredicates(Func`2<TSource, bool> predicate1, Func`2<TSource, bool> predicate2)
public Func`2<TSource, TResult> CombineSelectors(Func`2<TSource, TMiddle> selector1, Func`2<TMiddle, TResult> selector2)
}
public System.Management.Instrumentation.InstanceNotFoundException : InstrumentationException {
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
}
public System.Management.Instrumentation.InstrumentationBaseException : Exception {
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
}
public System.Management.Instrumentation.InstrumentationException : InstrumentationBaseException {
public void .ctor(Exception innerException)
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
}
public System.Management.Instrumentation.ManagementBindAttribute : ManagementNewInstanceAttribute {
public Type Schema
public Type get_Schema()
public void set_Schema(Type value)
}
public System.Management.Instrumentation.ManagementConfigurationAttribute : ManagementMemberAttribute {
public ManagementConfigurationType Mode
public Type Schema
public ManagementConfigurationType get_Mode()
public void set_Mode(ManagementConfigurationType value)
public Type get_Schema()
public void set_Schema(Type value)
}
public System.Management.Instrumentation.ManagementConfigurationType : Enum {
public int value__
public ManagementConfigurationType Apply
public ManagementConfigurationType OnCommit
}
public System.Management.Instrumentation.ManagementEntityAttribute : Attribute {
public bool External
public string Name
public bool Singleton
public bool get_External()
public void set_External(bool value)
public string get_Name()
public void set_Name(string value)
public bool get_Singleton()
public void set_Singleton(bool value)
}
public System.Management.Instrumentation.ManagementEnumeratorAttribute : ManagementNewInstanceAttribute {
public Type Schema
public Type get_Schema()
public void set_Schema(Type value)
}
public System.Management.Instrumentation.ManagementHostingModel : Enum {
public int value__
public ManagementHostingModel Decoupled
public ManagementHostingModel LocalService
public ManagementHostingModel LocalSystem
public ManagementHostingModel NetworkService
}
public System.Management.Instrumentation.ManagementMemberAttribute : Attribute {
public string Name
public string get_Name()
public void set_Name(string value)
}
public System.Management.Instrumentation.ManagementNameAttribute : Attribute {
public string Name
public void .ctor(string name)
public string get_Name()
}
public System.Management.Instrumentation.ManagementProbeAttribute : ManagementMemberAttribute {
public Type Schema
public Type get_Schema()
public void set_Schema(Type value)
}
public System.Management.Instrumentation.ManagementReferenceAttribute : Attribute {
public string Type
public string get_Type()
public void set_Type(string value)
}
public System.Management.Instrumentation.ManagementRemoveAttribute : ManagementMemberAttribute {
public Type Schema
public Type get_Schema()
public void set_Schema(Type value)
}
public System.Management.Instrumentation.ManagementTaskAttribute : ManagementMemberAttribute {
public Type Schema
public Type get_Schema()
public void set_Schema(Type value)
}
public System.Management.Instrumentation.WmiConfigurationAttribute : Attribute {
public string HostingGroup
public ManagementHostingModel HostingModel
public bool IdentifyLevel
public string NamespaceSecurity
public string Scope
public string SecurityRestriction
public void .ctor(string scope)
public string get_HostingGroup()
public void set_HostingGroup(string value)
public ManagementHostingModel get_HostingModel()
public void set_HostingModel(ManagementHostingModel value)
public bool get_IdentifyLevel()
public void set_IdentifyLevel(bool value)
public string get_NamespaceSecurity()
public void set_NamespaceSecurity(string value)
public string get_Scope()
public string get_SecurityRestriction()
public void set_SecurityRestriction(string value)
}
internal System.MonoDocumentationNoteAttribute : MonoTODOAttribute {
public void .ctor(string comment)
}
internal System.MonoExtensionAttribute : MonoTODOAttribute {
public void .ctor(string comment)
}
internal System.MonoInternalNoteAttribute : MonoTODOAttribute {
public void .ctor(string comment)
}
internal System.MonoLimitationAttribute : MonoTODOAttribute {
public void .ctor(string comment)
}
internal System.MonoNotSupportedAttribute : MonoTODOAttribute {
public void .ctor(string comment)
}
internal System.MonoTODOAttribute : Attribute {
private string comment
public string Comment
public void .ctor(string comment)
public string get_Comment()
}
internal System.MonoUtil : object {
public bool IsUnix
}
internal System.NotImplemented : object {
internal Exception ByDesign
internal Exception get_ByDesign()
internal Exception ByDesignWithMessage(string message)
internal Exception ActiveIssue(string issue)
}
public System.Runtime.CompilerServices.CallSite : object {
internal string CallSiteTargetMethodName
private CacheDict`2 modreq(System.Runtime.CompilerServices.IsVolatile) s_siteCtors
internal CallSiteBinder _binder
internal bool _match
public CallSiteBinder Binder
internal void .ctor(CallSiteBinder binder)
public CallSiteBinder get_Binder()
public CallSite Create(Type delegateType, CallSiteBinder binder)
}
public System.Runtime.CompilerServices.CallSite`1 : CallSite {
public T Target
internal T[] Rules
private T s_cachedUpdate
private T modreq(System.Runtime.CompilerServices.IsVolatile) s_cachedNoMatch
private int MaxRules
public T Update
public T get_Update()
private void .ctor(CallSiteBinder binder)
internal CallSite`1<T> CreateMatchMaker()
public CallSite`1<T> Create(CallSiteBinder binder)
private T GetUpdateDelegate()
private T GetUpdateDelegate(T& addr)
private void ClearRuleCache()
internal void AddRule(T newRule)
internal void MoveRule(int i)
internal T MakeUpdateDelegate()
private Delegate CreateDelegateHelper(Type delegateType, MethodInfo method)
private bool IsSimpleSignature(MethodInfo invoke, Type[]& sig)
private T CreateCustomUpdateDelegate(MethodInfo invoke)
private T CreateCustomNoMatchDelegate(MethodInfo invoke)
private Expression Convert(Expression arg, Type type)
}
public System.Runtime.CompilerServices.CallSiteBinder : object {
internal Dictionary`2<Type, object> Cache
private LabelTarget <UpdateLabel>k__BackingField
public LabelTarget UpdateLabel
public LabelTarget get_UpdateLabel()
public Expression Bind(Object[] args, ReadOnlyCollection`1<ParameterExpression> parameters, LabelTarget returnLabel)
public T BindDelegate(CallSite`1<T> site, Object[] args)
internal T BindCore(CallSite`1<T> site, Object[] args)
protected void CacheTarget(T target)
private Expression`1<T> Stitch(Expression binding, LambdaSignature`1<T> signature)
internal RuleCache`1<T> GetRuleCache()
}
public System.Runtime.CompilerServices.CallSiteHelpers : object {
private Type s_knownNonDynamicMethodType
public bool IsInternalFrame(MethodBase mb)
}
public System.Runtime.CompilerServices.CallSiteOps : object {
public CallSite`1<T> CreateMatchmaker(CallSite`1<T> site)
public bool SetNotMatched(CallSite site)
public bool GetMatch(CallSite site)
public void ClearMatch(CallSite site)
public void AddRule(CallSite`1<T> site, T rule)
public void UpdateRules(CallSite`1<T> this, int matched)
public T[] GetRules(CallSite`1<T> site)
public RuleCache`1<T> GetRuleCache(CallSite`1<T> site)
public void MoveRule(RuleCache`1<T> cache, T rule, int i)
public T[] GetCachedRules(RuleCache`1<T> cache)
public T Bind(CallSiteBinder binder, CallSite`1<T> site, Object[] args)
}
public System.Runtime.CompilerServices.Closure : object {
public Object[] Constants
public Object[] Locals
public void .ctor(Object[] constants, Object[] locals)
}
public System.Runtime.CompilerServices.DebugInfoGenerator : object {
public DebugInfoGenerator CreatePdbGenerator()
public void MarkSequencePoint(LambdaExpression method, int ilOffset, DebugInfoExpression sequencePoint)
internal void MarkSequencePoint(LambdaExpression method, MethodBase methodBase, ILGenerator ilg, DebugInfoExpression sequencePoint)
internal void SetLocalName(LocalBuilder localBuilder, string name)
}
public System.Runtime.CompilerServices.DynamicAttribute : Attribute {
private Boolean[] _transformFlags
public IList`1<bool> TransformFlags
public void .ctor(Boolean[] transformFlags)
public IList`1<bool> get_TransformFlags()
}
public System.Runtime.CompilerServices.ExecutionScope : object {
public ExecutionScope Parent
public Object[] Globals
public Object[] Locals
public Object[] CreateHoistedLocals()
public Delegate CreateDelegate(int indexLambda, Object[] locals)
public Expression IsolateExpression(Expression expression, Object[] locals)
}
public System.Runtime.CompilerServices.IRuntimeVariables {
public int Count
public object Item
public int get_Count()
public object get_Item(int index)
public void set_Item(int index, object value)
}
public System.Runtime.CompilerServices.IStrongBox {
public object Value
public object get_Value()
public void set_Value(object value)
}
public System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1 : object {
private int DefaultCapacity
private T[] _items
private int _size
private int _version
public int Capacity
public int Count
public T Item
private bool System.Collections.Generic.ICollection<T>.IsReadOnly
private bool System.Collections.IList.IsReadOnly
private bool System.Collections.IList.IsFixedSize
private object System.Collections.IList.Item
private bool System.Collections.ICollection.IsSynchronized
private object System.Collections.ICollection.SyncRoot
public void .ctor(int capacity)
public void .ctor(IEnumerable`1<T> collection)
public int get_Capacity()
public void set_Capacity(int value)
public int get_Count()
public int IndexOf(T item)
public void Insert(int index, T item)
public void RemoveAt(int index)
public T get_Item(int index)
public void set_Item(int index, T value)
public void Add(T item)
public void Clear()
public bool Contains(T item)
public void CopyTo(T[] array, int arrayIndex)
private bool System.Collections.Generic.ICollection<T>.get_IsReadOnly()
public bool Remove(T item)
public IEnumerator`1<T> GetEnumerator()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
private bool System.Collections.IList.get_IsReadOnly()
private int System.Collections.IList.Add(object value)
private bool System.Collections.IList.Contains(object value)
private int System.Collections.IList.IndexOf(object value)
private void System.Collections.IList.Insert(int index, object value)
private bool System.Collections.IList.get_IsFixedSize()
private void System.Collections.IList.Remove(object value)
private object System.Collections.IList.get_Item(int index)
private void System.Collections.IList.set_Item(int index, object value)
private void System.Collections.ICollection.CopyTo(Array array, int index)
private bool System.Collections.ICollection.get_IsSynchronized()
private object System.Collections.ICollection.get_SyncRoot()
public void Reverse()
public void Reverse(int index, int count)
public T[] ToArray()
public ReadOnlyCollection`1<T> ToReadOnlyCollection()
private void EnsureCapacity(int min)
private bool IsCompatibleObject(object value)
private void ValidateNullValue(object value, string argument)
}
public System.Runtime.CompilerServices.RuleCache`1 : object {
private T[] _rules
private object _cacheLock
private int MaxRules
private int InsertPosition
internal T[] GetRules()
internal void MoveRule(T rule, int i)
internal void AddRule(T newRule)
internal void ReplaceRule(T oldRule, T newRule)
private T[] AddOrInsert(T[] rules, T item)
}
public System.Runtime.CompilerServices.RuntimeOps : object {
public bool ExpandoTryGetValue(ExpandoObject expando, object indexClass, int index, string name, bool ignoreCase, Object& value)
public object ExpandoTrySetValue(ExpandoObject expando, object indexClass, int index, object value, string name, bool ignoreCase)
public bool ExpandoTryDeleteValue(ExpandoObject expando, object indexClass, int index, string name, bool ignoreCase)
public bool ExpandoCheckVersion(ExpandoObject expando, object version)
public void ExpandoPromoteClass(ExpandoObject expando, object oldClass, object newClass)
public Expression Quote(Expression expression, object hoistedLocals, Object[] locals)
public IRuntimeVariables MergeRuntimeVariables(IRuntimeVariables first, IRuntimeVariables second, Int32[] indexes)
public IRuntimeVariables CreateRuntimeVariables(Object[] data, Int64[] indexes)
public IRuntimeVariables CreateRuntimeVariables()
}
public System.Runtime.CompilerServices.StrongBox`1 : object {
public T Value
private object System.Runtime.CompilerServices.IStrongBox.Value
public void .ctor(T value)
private object System.Runtime.CompilerServices.IStrongBox.get_Value()
private void System.Runtime.CompilerServices.IStrongBox.set_Value(object value)
}
internal System.Runtime.CompilerServices.TrueReadOnlyCollection`1 : ReadOnlyCollection`1<T> {
public void .ctor(T[] list)
}
public System.Runtime.InteropServices.ComAwareEventInfo : EventInfo {
public EventAttributes Attributes
public Type DeclaringType
public string Name
public Type ReflectedType
public EventAttributes get_Attributes()
public Type get_DeclaringType()
public string get_Name()
public void .ctor(Type type, string eventName)
public void AddEventHandler(object target, Delegate handler)
public void RemoveEventHandler(object target, Delegate handler)
public MethodInfo GetAddMethod(bool nonPublic)
public MethodInfo GetRaiseMethod(bool nonPublic)
public MethodInfo GetRemoveMethod(bool nonPublic)
public Object[] GetCustomAttributes(Type attributeType, bool inherit)
public Object[] GetCustomAttributes(bool inherit)
public bool IsDefined(Type attributeType, bool inherit)
public Type get_ReflectedType()
}
public System.Security.Cryptography.AesCng : Aes {
public Byte[] Key
public int KeySize
public void .ctor(string keyName)
public void .ctor(string keyName, CngProvider provider)
public void .ctor(string keyName, CngProvider provider, CngKeyOpenOptions openOptions)
public Byte[] get_Key()
public void set_Key(Byte[] value)
public int get_KeySize()
public void set_KeySize(int value)
public ICryptoTransform CreateDecryptor()
public ICryptoTransform CreateDecryptor(Byte[] rgbKey, Byte[] rgbIV)
public ICryptoTransform CreateEncryptor()
public ICryptoTransform CreateEncryptor(Byte[] rgbKey, Byte[] rgbIV)
protected void Dispose(bool disposing)
public void GenerateIV()
public void GenerateKey()
}
public System.Security.Cryptography.AesCryptoServiceProvider : Aes {
public Byte[] IV
public Byte[] Key
public int KeySize
public int FeedbackSize
public CipherMode Mode
public PaddingMode Padding
public void GenerateIV()
public void GenerateKey()
public ICryptoTransform CreateDecryptor(Byte[] key, Byte[] iv)
public ICryptoTransform CreateEncryptor(Byte[] key, Byte[] iv)
public Byte[] get_IV()
public void set_IV(Byte[] value)
public Byte[] get_Key()
public void set_Key(Byte[] value)
public int get_KeySize()
public void set_KeySize(int value)
public int get_FeedbackSize()
public void set_FeedbackSize(int value)
public CipherMode get_Mode()
public void set_Mode(CipherMode value)
public PaddingMode get_Padding()
public void set_Padding(PaddingMode value)
public ICryptoTransform CreateDecryptor()
public ICryptoTransform CreateEncryptor()
protected void Dispose(bool disposing)
}
public System.Security.Cryptography.AesManaged : Aes {
private RijndaelManaged m_rijndael
public int FeedbackSize
public Byte[] IV
public Byte[] Key
public int KeySize
public CipherMode Mode
public PaddingMode Padding
public int get_FeedbackSize()
public void set_FeedbackSize(int value)
public Byte[] get_IV()
public void set_IV(Byte[] value)
public Byte[] get_Key()
public void set_Key(Byte[] value)
public int get_KeySize()
public void set_KeySize(int value)
public CipherMode get_Mode()
public void set_Mode(CipherMode value)
public PaddingMode get_Padding()
public void set_Padding(PaddingMode value)
public ICryptoTransform CreateDecryptor()
public ICryptoTransform CreateDecryptor(Byte[] key, Byte[] iv)
public ICryptoTransform CreateEncryptor()
public ICryptoTransform CreateEncryptor(Byte[] key, Byte[] iv)
protected void Dispose(bool disposing)
public void GenerateIV()
public void GenerateKey()
}
internal System.Security.Cryptography.AesTransform : SymmetricTransform {
private UInt32[] expandedKey
private int Nb
private int Nk
private int Nr
private UInt32[] Rcon
private Byte[] SBox
private Byte[] iSBox
private UInt32[] T0
private UInt32[] T1
private UInt32[] T2
private UInt32[] T3
private UInt32[] iT0
private UInt32[] iT1
private UInt32[] iT2
private UInt32[] iT3
public void .ctor(Aes algo, bool encryption, Byte[] key, Byte[] iv)
public void Clear()
protected void ECB(Byte[] input, Byte[] output)
private UInt32 SubByte(UInt32 a)
private void Encrypt128(Byte[] indata, Byte[] outdata, UInt32[] ekey)
private void Decrypt128(Byte[] indata, Byte[] outdata, UInt32[] ekey)
}
internal System.Security.Cryptography.AsymmetricPaddingMode : Enum {
public int value__
public AsymmetricPaddingMode None
public AsymmetricPaddingMode Pkcs1
public AsymmetricPaddingMode Oaep
public AsymmetricPaddingMode Pss
}
public System.Security.Cryptography.CngAlgorithm : object {
private CngAlgorithm modreq(System.Runtime.CompilerServices.IsVolatile) s_ecdh
private CngAlgorithm modreq(System.Runtime.CompilerServices.IsVolatile) s_ecdhp256
private CngAlgorithm modreq(System.Runtime.CompilerServices.IsVolatile) s_ecdhp384
private CngAlgorithm modreq(System.Runtime.CompilerServices.IsVolatile) s_ecdhp521
private CngAlgorithm modreq(System.Runtime.CompilerServices.IsVolatile) s_ecdsa
private CngAlgorithm modreq(System.Runtime.CompilerServices.IsVolatile) s_ecdsap256
private CngAlgorithm modreq(System.Runtime.CompilerServices.IsVolatile) s_ecdsap384
private CngAlgorithm modreq(System.Runtime.CompilerServices.IsVolatile) s_ecdsap521
private CngAlgorithm modreq(System.Runtime.CompilerServices.IsVolatile) s_md5
private CngAlgorithm modreq(System.Runtime.CompilerServices.IsVolatile) s_sha1
private CngAlgorithm modreq(System.Runtime.CompilerServices.IsVolatile) s_sha256
private CngAlgorithm modreq(System.Runtime.CompilerServices.IsVolatile) s_sha384
private CngAlgorithm modreq(System.Runtime.CompilerServices.IsVolatile) s_sha512
private CngAlgorithm modreq(System.Runtime.CompilerServices.IsVolatile) s_rsa
private string m_algorithm
public string Algorithm
public CngAlgorithm Rsa
public CngAlgorithm ECDiffieHellman
public CngAlgorithm ECDiffieHellmanP256
public CngAlgorithm ECDiffieHellmanP384
public CngAlgorithm ECDiffieHellmanP521
public CngAlgorithm ECDsa
public CngAlgorithm ECDsaP256
public CngAlgorithm ECDsaP384
public CngAlgorithm ECDsaP521
public CngAlgorithm MD5
public CngAlgorithm Sha1
public CngAlgorithm Sha256
public CngAlgorithm Sha384
public CngAlgorithm Sha512
public void .ctor(string algorithm)
public string get_Algorithm()
public bool op_Equality(CngAlgorithm left, CngAlgorithm right)
public bool op_Inequality(CngAlgorithm left, CngAlgorithm right)
public bool Equals(object obj)
public bool Equals(CngAlgorithm other)
public int GetHashCode()
public string ToString()
public CngAlgorithm get_Rsa()
public CngAlgorithm get_ECDiffieHellman()
public CngAlgorithm get_ECDiffieHellmanP256()
public CngAlgorithm get_ECDiffieHellmanP384()
public CngAlgorithm get_ECDiffieHellmanP521()
public CngAlgorithm get_ECDsa()
public CngAlgorithm get_ECDsaP256()
public CngAlgorithm get_ECDsaP384()
public CngAlgorithm get_ECDsaP521()
public CngAlgorithm get_MD5()
public CngAlgorithm get_Sha1()
public CngAlgorithm get_Sha256()
public CngAlgorithm get_Sha384()
public CngAlgorithm get_Sha512()
}
public System.Security.Cryptography.CngAlgorithmGroup : object {
private CngAlgorithmGroup modreq(System.Runtime.CompilerServices.IsVolatile) s_dh
private CngAlgorithmGroup modreq(System.Runtime.CompilerServices.IsVolatile) s_dsa
private CngAlgorithmGroup modreq(System.Runtime.CompilerServices.IsVolatile) s_ecdh
private CngAlgorithmGroup modreq(System.Runtime.CompilerServices.IsVolatile) s_ecdsa
private CngAlgorithmGroup modreq(System.Runtime.CompilerServices.IsVolatile) s_rsa
private string m_algorithmGroup
public string AlgorithmGroup
public CngAlgorithmGroup DiffieHellman
public CngAlgorithmGroup Dsa
public CngAlgorithmGroup ECDiffieHellman
public CngAlgorithmGroup ECDsa
public CngAlgorithmGroup Rsa
public void .ctor(string algorithmGroup)
public string get_AlgorithmGroup()
public bool op_Equality(CngAlgorithmGroup left, CngAlgorithmGroup right)
public bool op_Inequality(CngAlgorithmGroup left, CngAlgorithmGroup right)
public bool Equals(object obj)
public bool Equals(CngAlgorithmGroup other)
public int GetHashCode()
public string ToString()
public CngAlgorithmGroup get_DiffieHellman()
public CngAlgorithmGroup get_Dsa()
public CngAlgorithmGroup get_ECDiffieHellman()
public CngAlgorithmGroup get_ECDsa()
public CngAlgorithmGroup get_Rsa()
}
public System.Security.Cryptography.CngExportPolicies : Enum {
public int value__
public CngExportPolicies None
public CngExportPolicies AllowExport
public CngExportPolicies AllowPlaintextExport
public CngExportPolicies AllowArchiving
public CngExportPolicies AllowPlaintextArchiving
}
public System.Security.Cryptography.CngKey : object {
public CngAlgorithmGroup AlgorithmGroup
public CngAlgorithm Algorithm
public CngExportPolicies ExportPolicy
public SafeNCryptKeyHandle Handle
public bool IsEphemeral
public bool IsMachineKey
public string KeyName
public int KeySize
public CngKeyUsages KeyUsage
public IntPtr ParentWindowHandle
public CngProvider Provider
public SafeNCryptProviderHandle ProviderHandle
public string UniqueName
public CngUIPolicy UIPolicy
public CngAlgorithmGroup get_AlgorithmGroup()
public CngAlgorithm get_Algorithm()
public CngExportPolicies get_ExportPolicy()
public SafeNCryptKeyHandle get_Handle()
public bool get_IsEphemeral()
private void set_IsEphemeral(bool value)
public bool get_IsMachineKey()
public string get_KeyName()
public int get_KeySize()
public CngKeyUsages get_KeyUsage()
public IntPtr get_ParentWindowHandle()
public void set_ParentWindowHandle(IntPtr value)
public CngProvider get_Provider()
public SafeNCryptProviderHandle get_ProviderHandle()
public string get_UniqueName()
public CngUIPolicy get_UIPolicy()
public CngKey Create(CngAlgorithm algorithm)
public CngKey Create(CngAlgorithm algorithm, string keyName)
public CngKey Create(CngAlgorithm algorithm, string keyName, CngKeyCreationParameters creationParameters)
public void Delete()
public void Dispose()
public bool Exists(string keyName)
public bool Exists(string keyName, CngProvider provider)
public bool Exists(string keyName, CngProvider provider, CngKeyOpenOptions options)
public CngKey Import(Byte[] keyBlob, CngKeyBlobFormat format)
public CngKey Import(Byte[] keyBlob, CngKeyBlobFormat format, CngProvider provider)
public Byte[] Export(CngKeyBlobFormat format)
public CngProperty GetProperty(string name, CngPropertyOptions options)
public bool HasProperty(string name, CngPropertyOptions options)
public CngKey Open(string keyName)
public CngKey Open(string keyName, CngProvider provider)
public CngKey Open(string keyName, CngProvider provider, CngKeyOpenOptions openOptions)
public CngKey Open(SafeNCryptKeyHandle keyHandle, CngKeyHandleOpenOptions keyHandleOpenOptions)
public void SetProperty(CngProperty property)
}
public System.Security.Cryptography.CngKeyBlobFormat : object {
private CngKeyBlobFormat modreq(System.Runtime.CompilerServices.IsVolatile) s_eccPrivate
private CngKeyBlobFormat modreq(System.Runtime.CompilerServices.IsVolatile) s_eccPublic
private CngKeyBlobFormat modreq(System.Runtime.CompilerServices.IsVolatile) s_eccFullPrivate
private CngKeyBlobFormat modreq(System.Runtime.CompilerServices.IsVolatile) s_eccFullPublic
private CngKeyBlobFormat modreq(System.Runtime.CompilerServices.IsVolatile) s_genericPrivate
private CngKeyBlobFormat modreq(System.Runtime.CompilerServices.IsVolatile) s_genericPublic
private CngKeyBlobFormat modreq(System.Runtime.CompilerServices.IsVolatile) s_opaqueTransport
private CngKeyBlobFormat modreq(System.Runtime.CompilerServices.IsVolatile) s_pkcs8Private
private string m_format
public string Format
public CngKeyBlobFormat EccPrivateBlob
public CngKeyBlobFormat EccPublicBlob
public CngKeyBlobFormat EccFullPrivateBlob
public CngKeyBlobFormat EccFullPublicBlob
public CngKeyBlobFormat GenericPrivateBlob
public CngKeyBlobFormat GenericPublicBlob
public CngKeyBlobFormat OpaqueTransportBlob
public CngKeyBlobFormat Pkcs8PrivateBlob
public void .ctor(string format)
public string get_Format()
public bool op_Equality(CngKeyBlobFormat left, CngKeyBlobFormat right)
public bool op_Inequality(CngKeyBlobFormat left, CngKeyBlobFormat right)
public bool Equals(object obj)
public bool Equals(CngKeyBlobFormat other)
public int GetHashCode()
public string ToString()
public CngKeyBlobFormat get_EccPrivateBlob()
public CngKeyBlobFormat get_EccPublicBlob()
public CngKeyBlobFormat get_EccFullPrivateBlob()
public CngKeyBlobFormat get_EccFullPublicBlob()
public CngKeyBlobFormat get_GenericPrivateBlob()
public CngKeyBlobFormat get_GenericPublicBlob()
public CngKeyBlobFormat get_OpaqueTransportBlob()
public CngKeyBlobFormat get_Pkcs8PrivateBlob()
}
public System.Security.Cryptography.CngKeyCreationOptions : Enum {
public int value__
public CngKeyCreationOptions None
public CngKeyCreationOptions MachineKey
public CngKeyCreationOptions OverwriteExistingKey
}
public System.Security.Cryptography.CngKeyCreationParameters : object {
private Nullable`1<CngExportPolicies> m_exportPolicy
private CngKeyCreationOptions m_keyCreationOptions
private Nullable`1<CngKeyUsages> m_keyUsage
private CngPropertyCollection m_parameters
private IntPtr m_parentWindowHandle
private CngProvider m_provider
private CngUIPolicy m_uiPolicy
public Nullable`1<CngExportPolicies> ExportPolicy
public CngKeyCreationOptions KeyCreationOptions
public Nullable`1<CngKeyUsages> KeyUsage
public IntPtr ParentWindowHandle
public CngPropertyCollection Parameters
internal CngPropertyCollection ParametersNoDemand
public CngProvider Provider
public CngUIPolicy UIPolicy
public Nullable`1<CngExportPolicies> get_ExportPolicy()
public void set_ExportPolicy(Nullable`1<CngExportPolicies> value)
public CngKeyCreationOptions get_KeyCreationOptions()
public void set_KeyCreationOptions(CngKeyCreationOptions value)
public Nullable`1<CngKeyUsages> get_KeyUsage()
public void set_KeyUsage(Nullable`1<CngKeyUsages> value)
public IntPtr get_ParentWindowHandle()
public void set_ParentWindowHandle(IntPtr value)
public CngPropertyCollection get_Parameters()
internal CngPropertyCollection get_ParametersNoDemand()
public CngProvider get_Provider()
public void set_Provider(CngProvider value)
public CngUIPolicy get_UIPolicy()
public void set_UIPolicy(CngUIPolicy value)
}
public System.Security.Cryptography.CngKeyHandleOpenOptions : Enum {
public int value__
public CngKeyHandleOpenOptions None
public CngKeyHandleOpenOptions EphemeralKey
}
public System.Security.Cryptography.CngKeyOpenOptions : Enum {
public int value__
public CngKeyOpenOptions None
public CngKeyOpenOptions UserKey
public CngKeyOpenOptions MachineKey
public CngKeyOpenOptions Silent
}
internal System.Security.Cryptography.CngKeyTypes : Enum {
public int value__
public CngKeyTypes None
public CngKeyTypes MachineKey
}
public System.Security.Cryptography.CngKeyUsages : Enum {
public int value__
public CngKeyUsages None
public CngKeyUsages Decryption
public CngKeyUsages Signing
public CngKeyUsages KeyAgreement
public CngKeyUsages AllUsages
}
public System.Security.Cryptography.CngProperty : ValueType {
private string m_name
private CngPropertyOptions m_propertyOptions
private Byte[] m_value
private Nullable`1<int> m_hashCode
public string Name
public CngPropertyOptions Options
internal Byte[] Value
public void .ctor(string name, Byte[] value, CngPropertyOptions options)
public string get_Name()
public CngPropertyOptions get_Options()
internal Byte[] get_Value()
public Byte[] GetValue()
public bool op_Equality(CngProperty left, CngProperty right)
public bool op_Inequality(CngProperty left, CngProperty right)
public bool Equals(object obj)
public bool Equals(CngProperty other)
public int GetHashCode()
}
public System.Security.Cryptography.CngPropertyOptions : Enum {
public int value__
public CngPropertyOptions None
public CngPropertyOptions CustomProperty
public CngPropertyOptions Persist
}
public System.Security.Cryptography.CngProvider : object {
private CngProvider modreq(System.Runtime.CompilerServices.IsVolatile) s_msSmartCardKsp
private CngProvider modreq(System.Runtime.CompilerServices.IsVolatile) s_msSoftwareKsp
private string m_provider
public string Provider
public CngProvider MicrosoftSmartCardKeyStorageProvider
public CngProvider MicrosoftSoftwareKeyStorageProvider
public void .ctor(string provider)
public string get_Provider()
public bool op_Equality(CngProvider left, CngProvider right)
public bool op_Inequality(CngProvider left, CngProvider right)
public bool Equals(object obj)
public bool Equals(CngProvider other)
public int GetHashCode()
public string ToString()
public CngProvider get_MicrosoftSmartCardKeyStorageProvider()
public CngProvider get_MicrosoftSoftwareKeyStorageProvider()
}
public System.Security.Cryptography.CngUIPolicy : object {
private string m_creationTitle
private string m_description
private string m_friendlyName
private CngUIProtectionLevels m_protectionLevel
private string m_useContext
public string CreationTitle
public string Description
public string FriendlyName
public CngUIProtectionLevels ProtectionLevel
public string UseContext
public void .ctor(CngUIProtectionLevels protectionLevel)
public void .ctor(CngUIProtectionLevels protectionLevel, string friendlyName)
public void .ctor(CngUIProtectionLevels protectionLevel, string friendlyName, string description)
public void .ctor(CngUIProtectionLevels protectionLevel, string friendlyName, string description, string useContext)
public void .ctor(CngUIProtectionLevels protectionLevel, string friendlyName, string description, string useContext, string creationTitle)
public string get_CreationTitle()
public string get_Description()
public string get_FriendlyName()
public CngUIProtectionLevels get_ProtectionLevel()
public string get_UseContext()
}
public System.Security.Cryptography.CngUIProtectionLevels : Enum {
public int value__
public CngUIProtectionLevels None
public CngUIProtectionLevels ProtectKey
public CngUIProtectionLevels ForceHighProtection
}
public System.Security.Cryptography.DSACng : DSA {
public CngKey Key
public void .ctor(int keySize)
public void .ctor(CngKey key)
public CngKey get_Key()
public Byte[] CreateSignature(Byte[] rgbHash)
public DSAParameters ExportParameters(bool includePrivateParameters)
public void ImportParameters(DSAParameters parameters)
public bool VerifySignature(Byte[] rgbHash, Byte[] rgbSignature)
}
internal System.Security.Cryptography.DSAFIPSVERSION_ENUM : Enum {
public int value__
public DSAFIPSVERSION_ENUM DSA_FIPS186_2
public DSAFIPSVERSION_ENUM DSA_FIPS186_3
}
public System.Security.Cryptography.ECCurve : ValueType {
public Byte[] A
public Byte[] B
public Byte[] Cofactor
public ECCurveType CurveType
public ECPoint G
public Nullable`1<HashAlgorithmName> Hash
public Byte[] Order
public Byte[] Polynomial
public Byte[] Prime
public Byte[] Seed
public bool IsCharacteristic2
public bool IsExplicit
public bool IsNamed
public bool IsPrime
public Oid Oid
public bool get_IsCharacteristic2()
public bool get_IsExplicit()
public bool get_IsNamed()
public bool get_IsPrime()
public Oid get_Oid()
public ECCurve CreateFromFriendlyName(string oidFriendlyName)
public ECCurve CreateFromOid(Oid curveOid)
public ECCurve CreateFromValue(string oidValue)
public void Validate()
}
public System.Security.Cryptography.ECDiffieHellman : AsymmetricAlgorithm {
public string KeyExchangeAlgorithm
public string SignatureAlgorithm
public ECDiffieHellmanPublicKey PublicKey
public string get_KeyExchangeAlgorithm()
public string get_SignatureAlgorithm()
public ECDiffieHellman Create()
public ECDiffieHellman Create(string algorithm)
public ECDiffieHellman Create(ECCurve curve)
public ECDiffieHellman Create(ECParameters parameters)
public ECDiffieHellmanPublicKey get_PublicKey()
public Byte[] DeriveKeyMaterial(ECDiffieHellmanPublicKey otherPartyPublicKey)
public Byte[] DeriveKeyFromHash(ECDiffieHellmanPublicKey otherPartyPublicKey, HashAlgorithmName hashAlgorithm)
public Byte[] DeriveKeyFromHash(ECDiffieHellmanPublicKey otherPartyPublicKey, HashAlgorithmName hashAlgorithm, Byte[] secretPrepend, Byte[] secretAppend)
public Byte[] DeriveKeyFromHmac(ECDiffieHellmanPublicKey otherPartyPublicKey, HashAlgorithmName hashAlgorithm, Byte[] hmacKey)
public Byte[] DeriveKeyFromHmac(ECDiffieHellmanPublicKey otherPartyPublicKey, HashAlgorithmName hashAlgorithm, Byte[] hmacKey, Byte[] secretPrepend, Byte[] secretAppend)
public Byte[] DeriveKeyTls(ECDiffieHellmanPublicKey otherPartyPublicKey, Byte[] prfLabel, Byte[] prfSeed)
private Exception DerivedClassMustOverride()
public ECParameters ExportParameters(bool includePrivateParameters)
public ECParameters ExportExplicitParameters(bool includePrivateParameters)
public void ImportParameters(ECParameters parameters)
public void GenerateKey(ECCurve curve)
}
public System.Security.Cryptography.ECDiffieHellmanCng : ECDiffieHellman {
public CngAlgorithm HashAlgorithm
public Byte[] HmacKey
public CngKey Key
public ECDiffieHellmanKeyDerivationFunction KeyDerivationFunction
public Byte[] Label
public ECDiffieHellmanPublicKey PublicKey
public Byte[] SecretAppend
public Byte[] SecretPrepend
public Byte[] Seed
public bool UseSecretAgreementAsHmacKey
public void .ctor(int keySize)
public void .ctor(CngKey key)
public void .ctor(ECCurve curve)
public CngAlgorithm get_HashAlgorithm()
public void set_HashAlgorithm(CngAlgorithm value)
public Byte[] get_HmacKey()
public void set_HmacKey(Byte[] value)
public CngKey get_Key()
public ECDiffieHellmanKeyDerivationFunction get_KeyDerivationFunction()
public void set_KeyDerivationFunction(ECDiffieHellmanKeyDerivationFunction value)
public Byte[] get_Label()
public void set_Label(Byte[] value)
public ECDiffieHellmanPublicKey get_PublicKey()
public Byte[] get_SecretAppend()
public void set_SecretAppend(Byte[] value)
public Byte[] get_SecretPrepend()
public void set_SecretPrepend(Byte[] value)
public Byte[] get_Seed()
public void set_Seed(Byte[] value)
public bool get_UseSecretAgreementAsHmacKey()
public Byte[] DeriveKeyMaterial(CngKey otherPartyPublicKey)
public SafeNCryptSecretHandle DeriveSecretAgreementHandle(CngKey otherPartyPublicKey)
public SafeNCryptSecretHandle DeriveSecretAgreementHandle(ECDiffieHellmanPublicKey otherPartyPublicKey)
public void FromXmlString(string xml, ECKeyXmlFormat format)
public string ToXmlString(ECKeyXmlFormat format)
}
public System.Security.Cryptography.ECDiffieHellmanCngPublicKey : ECDiffieHellmanPublicKey {
public CngKeyBlobFormat BlobFormat
public CngKeyBlobFormat get_BlobFormat()
public ECDiffieHellmanPublicKey FromByteArray(Byte[] publicKeyBlob, CngKeyBlobFormat format)
public ECDiffieHellmanCngPublicKey FromXmlString(string xml)
public CngKey Import()
}
public System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction : Enum {
public int value__
public ECDiffieHellmanKeyDerivationFunction Hash
public ECDiffieHellmanKeyDerivationFunction Hmac
public ECDiffieHellmanKeyDerivationFunction Tls
}
public System.Security.Cryptography.ECDiffieHellmanPublicKey : object {
private Byte[] m_keyBlob
protected void .ctor(Byte[] keyBlob)
public void Dispose()
protected void Dispose(bool disposing)
public Byte[] ToByteArray()
public string ToXmlString()
public ECParameters ExportParameters()
public ECParameters ExportExplicitParameters()
}
public System.Security.Cryptography.ECDsa : AsymmetricAlgorithm {
public string KeyExchangeAlgorithm
public string SignatureAlgorithm
public string get_KeyExchangeAlgorithm()
public string get_SignatureAlgorithm()
public ECDsa Create()
public ECDsa Create(string algorithm)
public ECDsa Create(ECCurve curve)
public ECDsa Create(ECParameters parameters)
public Byte[] SignHash(Byte[] hash)
public bool VerifyHash(Byte[] hash, Byte[] signature)
protected Byte[] HashData(Byte[] data, int offset, int count, HashAlgorithmName hashAlgorithm)
protected Byte[] HashData(Stream data, HashAlgorithmName hashAlgorithm)
public Byte[] SignData(Byte[] data, HashAlgorithmName hashAlgorithm)
public Byte[] SignData(Byte[] data, int offset, int count, HashAlgorithmName hashAlgorithm)
public Byte[] SignData(Stream data, HashAlgorithmName hashAlgorithm)
public bool VerifyData(Byte[] data, Byte[] signature, HashAlgorithmName hashAlgorithm)
public bool VerifyData(Byte[] data, int offset, int count, Byte[] signature, HashAlgorithmName hashAlgorithm)
public bool VerifyData(Stream data, Byte[] signature, HashAlgorithmName hashAlgorithm)
public ECParameters ExportParameters(bool includePrivateParameters)
public ECParameters ExportExplicitParameters(bool includePrivateParameters)
public void ImportParameters(ECParameters parameters)
public void GenerateKey(ECCurve curve)
private Exception DerivedClassMustOverride()
internal Exception HashAlgorithmNameNullOrEmpty()
}
public System.Security.Cryptography.ECDsaCng : ECDsa {
private CngAlgorithm <HashAlgorithm>k__BackingField
public CngAlgorithm HashAlgorithm
public CngKey Key
public void .ctor(int keySize)
public void .ctor(CngKey key)
public void .ctor(ECCurve curve)
public CngAlgorithm get_HashAlgorithm()
public void set_HashAlgorithm(CngAlgorithm value)
public CngKey get_Key()
private void set_Key(CngKey value)
public Byte[] SignHash(Byte[] hash)
public bool VerifyHash(Byte[] hash, Byte[] signature)
public void FromXmlString(string xml, ECKeyXmlFormat format)
public Byte[] SignData(Byte[] data)
public Byte[] SignData(Stream data)
public Byte[] SignData(Byte[] data, int offset, int count)
public string ToXmlString(ECKeyXmlFormat format)
public bool VerifyData(Byte[] data, Byte[] signature)
public bool VerifyData(Stream data, Byte[] signature)
public bool VerifyData(Byte[] data, int offset, int count, Byte[] signature)
}
public System.Security.Cryptography.ECKeyXmlFormat : Enum {
public int value__
public ECKeyXmlFormat Rfc4050
}
public System.Security.Cryptography.ECParameters : ValueType {
public ECCurve Curve
public Byte[] D
public ECPoint Q
public void Validate()
}
public System.Security.Cryptography.ECPoint : ValueType {
public Byte[] X
public Byte[] Y
}
internal System.Security.Cryptography.HASHALGORITHM_ENUM : Enum {
public int value__
public HASHALGORITHM_ENUM DSA_HASH_ALGORITHM_SHA1
public HASHALGORITHM_ENUM DSA_HASH_ALGORITHM_SHA256
public HASHALGORITHM_ENUM DSA_HASH_ALGORITHM_SHA512
}
public System.Security.Cryptography.IncrementalHash : object {
private int NTE_BAD_ALGID
private HashAlgorithmName _algorithmName
private HashAlgorithm _hash
private bool _disposed
private bool _resetPending
public HashAlgorithmName AlgorithmName
private void .ctor(HashAlgorithmName name, HashAlgorithm hash)
public HashAlgorithmName get_AlgorithmName()
public void AppendData(Byte[] data)
public void AppendData(Byte[] data, int offset, int count)
public Byte[] GetHashAndReset()
public void Dispose()
public IncrementalHash CreateHash(HashAlgorithmName hashAlgorithm)
public IncrementalHash CreateHMAC(HashAlgorithmName hashAlgorithm, Byte[] key)
private HashAlgorithm GetHashAlgorithm(HashAlgorithmName hashAlgorithm)
private HashAlgorithm GetHMAC(HashAlgorithmName hashAlgorithm, Byte[] key)
}
public System.Security.Cryptography.ManifestSignatureInformation : object {
public AuthenticodeSignatureInformation AuthenticodeSignature
public ManifestKinds Manifest
public StrongNameSignatureInformation StrongNameSignature
public AuthenticodeSignatureInformation get_AuthenticodeSignature()
public ManifestKinds get_Manifest()
public StrongNameSignatureInformation get_StrongNameSignature()
public ManifestSignatureInformationCollection VerifySignature(ActivationContext application)
public ManifestSignatureInformationCollection VerifySignature(ActivationContext application, ManifestKinds manifests)
public ManifestSignatureInformationCollection VerifySignature(ActivationContext application, ManifestKinds manifests, X509RevocationFlag revocationFlag, X509RevocationMode revocationMode)
}
public System.Security.Cryptography.MD5Cng : MD5 {
private Byte[] Empty
private MD5 hash
public void Initialize()
protected void HashCore(Byte[] array, int ibStart, int cbSize)
protected Byte[] HashFinal()
protected void Dispose(bool disposing)
}
public System.Security.Cryptography.RSACng : RSA {
public CngKey Key
public void .ctor(int keySize)
public void .ctor(CngKey key)
public CngKey get_Key()
private void set_Key(CngKey value)
public RSAParameters ExportParameters(bool includePrivateParameters)
public void ImportParameters(RSAParameters parameters)
}
public System.Security.Cryptography.SHA1Cng : SHA1 {
private Byte[] Empty
private SHA1 hash
public void Initialize()
protected void HashCore(Byte[] array, int ibStart, int cbSize)
protected Byte[] HashFinal()
protected void Dispose(bool disposing)
}
public System.Security.Cryptography.SHA256Cng : SHA256 {
private Byte[] Empty
private SHA256 hash
public void Initialize()
protected void HashCore(Byte[] array, int ibStart, int cbSize)
protected Byte[] HashFinal()
protected void Dispose(bool disposing)
}
public System.Security.Cryptography.SHA256CryptoServiceProvider : SHA256 {
private Byte[] Empty
private SHA256 hash
public void Initialize()
protected void HashCore(Byte[] array, int ibStart, int cbSize)
protected Byte[] HashFinal()
protected void Dispose(bool disposing)
}
public System.Security.Cryptography.SHA384Cng : SHA384 {
private Byte[] Empty
private SHA384 hash
public void Initialize()
protected void HashCore(Byte[] array, int ibStart, int cbSize)
protected Byte[] HashFinal()
protected void Dispose(bool disposing)
}
public System.Security.Cryptography.SHA384CryptoServiceProvider : SHA384 {
private Byte[] Empty
private SHA384 hash
public void Initialize()
protected void HashCore(Byte[] array, int ibStart, int cbSize)
protected Byte[] HashFinal()
protected void Dispose(bool disposing)
}
public System.Security.Cryptography.SHA512Cng : SHA512 {
private Byte[] Empty
private SHA512 hash
public void Initialize()
protected void HashCore(Byte[] array, int ibStart, int cbSize)
protected Byte[] HashFinal()
protected void Dispose(bool disposing)
}
public System.Security.Cryptography.SHA512CryptoServiceProvider : SHA512 {
private Byte[] Empty
private SHA512 hash
public void Initialize()
protected void HashCore(Byte[] array, int ibStart, int cbSize)
protected Byte[] HashFinal()
protected void Dispose(bool disposing)
}
public System.Security.Cryptography.SignatureVerificationResult : Enum {
public int value__
public SignatureVerificationResult AssemblyIdentityMismatch
public SignatureVerificationResult BadDigest
public SignatureVerificationResult BadSignatureFormat
public SignatureVerificationResult BasicConstraintsNotObserved
public SignatureVerificationResult CertificateExpired
public SignatureVerificationResult CertificateExplicitlyDistrusted
public SignatureVerificationResult CertificateMalformed
public SignatureVerificationResult CertificateNotExplicitlyTrusted
public SignatureVerificationResult CertificateRevoked
public SignatureVerificationResult CertificateUsageNotAllowed
public SignatureVerificationResult ContainingSignatureInvalid
public SignatureVerificationResult CouldNotBuildChain
public SignatureVerificationResult GenericTrustFailure
public SignatureVerificationResult InvalidCertificateName
public SignatureVerificationResult InvalidCertificatePolicy
public SignatureVerificationResult InvalidCertificateRole
public SignatureVerificationResult InvalidCertificateSignature
public SignatureVerificationResult InvalidCertificateUsage
public SignatureVerificationResult InvalidCountersignature
public SignatureVerificationResult InvalidSignerCertificate
public SignatureVerificationResult InvalidTimePeriodNesting
public SignatureVerificationResult InvalidTimestamp
public SignatureVerificationResult IssuerChainingError
public SignatureVerificationResult MissingSignature
public SignatureVerificationResult PathLengthConstraintViolated
public SignatureVerificationResult PublicKeyTokenMismatch
public SignatureVerificationResult PublisherMismatch
public SignatureVerificationResult RevocationCheckFailure
public SignatureVerificationResult SystemError
public SignatureVerificationResult UnknownCriticalExtension
public SignatureVerificationResult UnknownTrustProvider
public SignatureVerificationResult UnknownVerificationAction
public SignatureVerificationResult UntrustedCertificationAuthority
public SignatureVerificationResult UntrustedRootCertificate
public SignatureVerificationResult UntrustedTestRootCertificate
public SignatureVerificationResult Valid
}
public System.Security.Cryptography.StrongNameSignatureInformation : object {
public string HashAlgorithm
public int HResult
public bool IsValid
public AsymmetricAlgorithm PublicKey
public SignatureVerificationResult VerificationResult
public string get_HashAlgorithm()
public int get_HResult()
public bool get_IsValid()
public AsymmetricAlgorithm get_PublicKey()
public SignatureVerificationResult get_VerificationResult()
}
public System.Security.Cryptography.TripleDESCng : TripleDES {
public Byte[] Key
public int KeySize
public void .ctor(string keyName)
public void .ctor(string keyName, CngProvider provider)
public void .ctor(string keyName, CngProvider provider, CngKeyOpenOptions openOptions)
public Byte[] get_Key()
public void set_Key(Byte[] value)
public int get_KeySize()
public void set_KeySize(int value)
public ICryptoTransform CreateDecryptor()
public ICryptoTransform CreateDecryptor(Byte[] rgbKey, Byte[] rgbIV)
public ICryptoTransform CreateEncryptor()
public ICryptoTransform CreateEncryptor(Byte[] rgbKey, Byte[] rgbIV)
protected void Dispose(bool disposing)
public void GenerateIV()
public void GenerateKey()
}
public System.Security.Cryptography.X509Certificates.AuthenticodeSignatureInformation : object {
public string Description
public Uri DescriptionUrl
public string HashAlgorithm
public int HResult
public X509Chain SignatureChain
public X509Certificate2 SigningCertificate
public TimestampInformation Timestamp
public TrustStatus TrustStatus
public SignatureVerificationResult VerificationResult
public string get_Description()
public Uri get_DescriptionUrl()
public string get_HashAlgorithm()
public int get_HResult()
public X509Chain get_SignatureChain()
public X509Certificate2 get_SigningCertificate()
public TimestampInformation get_Timestamp()
public TrustStatus get_TrustStatus()
public SignatureVerificationResult get_VerificationResult()
}
public System.Security.Cryptography.X509Certificates.DSACertificateExtensions : object {
public DSA GetDSAPrivateKey(X509Certificate2 certificate)
public DSA GetDSAPublicKey(X509Certificate2 certificate)
}
public System.Security.Cryptography.X509Certificates.ECDsaCertificateExtensions : object {
public ECDsa GetECDsaPrivateKey(X509Certificate2 certificate)
public ECDsa GetECDsaPublicKey(X509Certificate2 certificate)
}
public System.Security.Cryptography.X509Certificates.RSACertificateExtensions : object {
public RSA GetRSAPrivateKey(X509Certificate2 certificate)
public RSA GetRSAPublicKey(X509Certificate2 certificate)
}
public System.Security.Cryptography.X509Certificates.TimestampInformation : object {
public string HashAlgorithm
public int HResult
public bool IsValid
public X509Chain SignatureChain
public X509Certificate2 SigningCertificate
public DateTime Timestamp
public SignatureVerificationResult VerificationResult
public string get_HashAlgorithm()
public int get_HResult()
public bool get_IsValid()
public X509Chain get_SignatureChain()
public X509Certificate2 get_SigningCertificate()
public DateTime get_Timestamp()
public SignatureVerificationResult get_VerificationResult()
}
public System.Security.Cryptography.X509Certificates.TrustStatus : Enum {
public int value__
public TrustStatus Untrusted
public TrustStatus UnknownIdentity
public TrustStatus KnownIdentity
public TrustStatus Trusted
}
public System.Security.ManifestKinds : Enum {
public int value__
public ManifestKinds Application
public ManifestKinds ApplicationAndDeployment
public ManifestKinds Deployment
public ManifestKinds None
}
public System.Threading.LockRecursionPolicy : Enum {
public int value__
public LockRecursionPolicy NoRecursion
public LockRecursionPolicy SupportsRecursion
}
internal System.Threading.ReaderWriterCount : object {
public long lockID
public int readercount
public int writercount
public int upgradecount
public ReaderWriterCount next
}
public System.Threading.ReaderWriterLockSlim : object {
private bool fIsReentrant
private int myLock
private int LockSpinCycles
private int LockSpinCount
private int LockSleep0Count
private UInt32 numWriteWaiters
private UInt32 numReadWaiters
private UInt32 numWriteUpgradeWaiters
private UInt32 numUpgradeWaiters
private bool fNoWaiters
private int upgradeLockOwnerId
private int writeLockOwnerId
private EventWaitHandle writeEvent
private EventWaitHandle readEvent
private EventWaitHandle upgradeEvent
private EventWaitHandle waitUpgradeEvent
private long s_nextLockID
private long lockID
private ReaderWriterCount t_rwc
private bool fUpgradeThreadHoldingRead
private int MaxSpinCount
private UInt32 owners
private UInt32 WRITER_HELD
private UInt32 WAITING_WRITERS
private UInt32 WAITING_UPGRADER
private UInt32 MAX_READER
private UInt32 READER_MASK
private bool fDisposed
public bool IsReadLockHeld
public bool IsUpgradeableReadLockHeld
public bool IsWriteLockHeld
public LockRecursionPolicy RecursionPolicy
public int CurrentReadCount
public int RecursiveReadCount
public int RecursiveUpgradeCount
public int RecursiveWriteCount
public int WaitingReadCount
public int WaitingUpgradeCount
public int WaitingWriteCount
private void InitializeThreadCounts()
public void .ctor(LockRecursionPolicy recursionPolicy)
private bool IsRWEntryEmpty(ReaderWriterCount rwc)
private bool IsRwHashEntryChanged(ReaderWriterCount lrwc)
private ReaderWriterCount GetThreadRWCount(bool dontAllocate)
public void EnterReadLock()
public bool TryEnterReadLock(TimeSpan timeout)
public bool TryEnterReadLock(int millisecondsTimeout)
private bool TryEnterReadLock(TimeoutTracker timeout)
private bool TryEnterReadLockCore(TimeoutTracker timeout)
public void EnterWriteLock()
public bool TryEnterWriteLock(TimeSpan timeout)
public bool TryEnterWriteLock(int millisecondsTimeout)
private bool TryEnterWriteLock(TimeoutTracker timeout)
private bool TryEnterWriteLockCore(TimeoutTracker timeout)
public void EnterUpgradeableReadLock()
public bool TryEnterUpgradeableReadLock(TimeSpan timeout)
public bool TryEnterUpgradeableReadLock(int millisecondsTimeout)
private bool TryEnterUpgradeableReadLock(TimeoutTracker timeout)
private bool TryEnterUpgradeableReadLockCore(TimeoutTracker timeout)
public void ExitReadLock()
public void ExitWriteLock()
public void ExitUpgradeableReadLock()
private void LazyCreateEvent(EventWaitHandle& waitEvent, bool makeAutoResetEvent)
private bool WaitOnEvent(EventWaitHandle waitEvent, UInt32& numWaiters, TimeoutTracker timeout, bool isWriteWaiter)
private void ExitAndWakeUpAppropriateWaiters()
private void ExitAndWakeUpAppropriateWaitersPreferringWriters()
private void ExitAndWakeUpAppropriateReadWaiters()
private bool IsWriterAcquired()
private void SetWriterAcquired()
private void ClearWriterAcquired()
private void SetWritersWaiting()
private void ClearWritersWaiting()
private void SetUpgraderWaiting()
private void ClearUpgraderWaiting()
private UInt32 GetNumReaders()
private void EnterMyLock()
private void EnterMyLockSpin()
private void ExitMyLock()
private void SpinWait(int SpinCount)
public void Dispose()
private void Dispose(bool disposing)
public bool get_IsReadLockHeld()
public bool get_IsUpgradeableReadLockHeld()
public bool get_IsWriteLockHeld()
public LockRecursionPolicy get_RecursionPolicy()
public int get_CurrentReadCount()
public int get_RecursiveReadCount()
public int get_RecursiveUpgradeCount()
public int get_RecursiveWriteCount()
public int get_WaitingReadCount()
public int get_WaitingUpgradeCount()
public int get_WaitingWriteCount()
}
public System.Threading.Tasks.TaskExtensions : object {
public Task Unwrap(Task`1<Task> task)
public Task`1<TResult> Unwrap(Task`1<Task`1<TResult>> task)
}
internal Unity.ThrowStub : ObjectDisposedException {
public void ThrowNotSupportedException()
}
