internal Consts : object {
public string MonoVersion
public string MonoCompany
public string MonoProduct
public string MonoCopyright
public string FxVersion
public string FxFileVersion
public string VsVersion
public string AssemblyI18N
public string AssemblyMicrosoft_VisualStudio
public string AssemblyMicrosoft_VisualStudio_Web
public string AssemblyMicrosoft_VSDesigner
public string AssemblyMono_Http
public string AssemblyMono_Posix
public string AssemblyMono_Security
public string AssemblyMono_Messaging_RabbitMQ
public string AssemblyCorlib
public string AssemblySystem
public string AssemblySystem_Data
public string AssemblySystem_Design
public string AssemblySystem_DirectoryServices
public string AssemblySystem_Drawing
public string AssemblySystem_Drawing_Design
public string AssemblySystem_Messaging
public string AssemblySystem_Security
public string AssemblySystem_ServiceProcess
public string AssemblySystem_Web
public string AssemblySystem_Windows_Forms
public string AssemblySystem_Core
}
internal Locale : object {
public string GetText(string msg)
public string GetText(string fmt, Object[] args)
}
public Microsoft.Win32.SafeHandles.SafePipeHandle : SafeHandleZeroOrMinusOneIsInvalid {
public void .ctor(IntPtr preexistingHandle, bool ownsHandle)
protected bool ReleaseHandle()
}
public Mono.Security.Cryptography.BlockProcessor : object {
private ICryptoTransform transform
private Byte[] block
private int blockSize
private int blockCount
public void .ctor(ICryptoTransform transform)
public void .ctor(ICryptoTransform transform, int blockSize)
protected void Finalize()
public void Initialize()
public void Core(Byte[] rgb)
public void Core(Byte[] rgb, int ib, int cb)
public Byte[] Final()
}
public Mono.Security.Cryptography.KeyBuilder : object {
private RandomNumberGenerator rng
private RandomNumberGenerator Rng
private RandomNumberGenerator get_Rng()
public Byte[] Key(int size)
public Byte[] IV(int size)
}
internal Mono.Security.Cryptography.SymmetricTransform : object {
protected SymmetricAlgorithm algo
protected bool encrypt
private int BlockSizeByte
private Byte[] temp
private Byte[] temp2
private Byte[] workBuff
private Byte[] workout
private int FeedBackByte
private int FeedBackIter
private bool m_disposed
private bool lastBlock
private RandomNumberGenerator _rng
public bool CanTransformMultipleBlocks
public bool CanReuseTransform
public int InputBlockSize
public int OutputBlockSize
private bool KeepLastBlock
public void .ctor(SymmetricAlgorithm symmAlgo, bool encryption, Byte[] rgbIV)
private void System.IDisposable.Dispose()
protected void Finalize()
protected void Dispose(bool disposing)
public bool get_CanTransformMultipleBlocks()
public bool get_CanReuseTransform()
public int get_InputBlockSize()
public int get_OutputBlockSize()
protected void Transform(Byte[] input, Byte[] output)
protected void ECB(Byte[] input, Byte[] output)
protected void CBC(Byte[] input, Byte[] output)
protected void CFB(Byte[] input, Byte[] output)
protected void OFB(Byte[] input, Byte[] output)
protected void CTS(Byte[] input, Byte[] output)
private void CheckInput(Byte[] inputBuffer, int inputOffset, int inputCount)
public int TransformBlock(Byte[] inputBuffer, int inputOffset, int inputCount, Byte[] outputBuffer, int outputOffset)
private bool get_KeepLastBlock()
private int InternalTransformBlock(Byte[] inputBuffer, int inputOffset, int inputCount, Byte[] outputBuffer, int outputOffset)
private void Random(Byte[] buffer, int start, int length)
private void ThrowBadPaddingException(PaddingMode padding, int length, int position)
private Byte[] FinalEncrypt(Byte[] inputBuffer, int inputOffset, int inputCount)
private Byte[] FinalDecrypt(Byte[] inputBuffer, int inputOffset, int inputCount)
public Byte[] TransformFinalBlock(Byte[] inputBuffer, int inputOffset, int inputCount)
}
public System.Action : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke()
public IAsyncResult BeginInvoke(AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.Action`2 : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(T1 arg1, T2 arg2)
public IAsyncResult BeginInvoke(T1 arg1, T2 arg2, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.Action`3 : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(T1 arg1, T2 arg2, T3 arg3)
public IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.Action`4 : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4)
public IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.Collections.Generic.HashSet`1 : object {
private int INITIAL_SIZE
private float DEFAULT_LOAD_FACTOR
private int NO_SLOT
private int HASH_FLAG
private Int32[] table
private Link[] links
private T[] slots
private int touched
private int empty_slot
private int count
private int threshold
private IEqualityComparer`1<T> comparer
private SerializationInfo si
private int generation
private bool System.Collections.Generic.ICollection<T>.IsReadOnly
public int Count
public IEqualityComparer`1<T> Comparer
public void .ctor(IEqualityComparer`1<T> comparer)
public void .ctor(IEnumerable`1<T> collection)
public void .ctor(IEnumerable`1<T> collection, IEqualityComparer`1<T> comparer)
protected void .ctor(SerializationInfo info, StreamingContext context)
private IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator()
private bool System.Collections.Generic.ICollection<T>.get_IsReadOnly()
private void System.Collections.Generic.ICollection<T>.CopyTo(T[] array, int index)
private void System.Collections.Generic.ICollection<T>.Add(T item)
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
public int get_Count()
private void Init(int capacity, IEqualityComparer`1<T> comparer)
private void InitArrays(int size)
private bool SlotsContainsAt(int index, int hash, T item)
public void CopyTo(T[] array)
public void CopyTo(T[] array, int index)
public void CopyTo(T[] array, int index, int count)
private void Resize()
private int GetLinkHashCode(int index)
private int GetItemHashCode(T item)
public bool Add(T item)
public IEqualityComparer`1<T> get_Comparer()
public void Clear()
public bool Contains(T item)
public bool Remove(T item)
public int RemoveWhere(Predicate`1<T> predicate)
public void TrimExcess()
public void IntersectWith(IEnumerable`1<T> other)
public void ExceptWith(IEnumerable`1<T> other)
public bool Overlaps(IEnumerable`1<T> other)
public bool SetEquals(IEnumerable`1<T> other)
public void SymmetricExceptWith(IEnumerable`1<T> other)
public void UnionWith(IEnumerable`1<T> other)
private bool CheckIsSubsetOf(IEnumerable`1<T> other)
public bool IsSubsetOf(IEnumerable`1<T> other)
public bool IsProperSubsetOf(IEnumerable`1<T> other)
private bool CheckIsSupersetOf(IEnumerable`1<T> other)
public bool IsSupersetOf(IEnumerable`1<T> other)
public bool IsProperSupersetOf(IEnumerable`1<T> other)
public IEqualityComparer`1<HashSet`1<T>> CreateSetComparer()
public void GetObjectData(SerializationInfo info, StreamingContext context)
public void OnDeserialization(object sender)
public Enumerator<T> GetEnumerator()
}
public System.Func`1 : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public TResult Invoke()
public IAsyncResult BeginInvoke(AsyncCallback callback, object object)
public TResult EndInvoke(IAsyncResult result)
}
public System.Func`2 : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public TResult Invoke(T arg1)
public IAsyncResult BeginInvoke(T arg1, AsyncCallback callback, object object)
public TResult EndInvoke(IAsyncResult result)
}
public System.Func`3 : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public TResult Invoke(T1 arg1, T2 arg2)
public IAsyncResult BeginInvoke(T1 arg1, T2 arg2, AsyncCallback callback, object object)
public TResult EndInvoke(IAsyncResult result)
}
public System.Func`4 : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public TResult Invoke(T1 arg1, T2 arg2, T3 arg3)
public IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, AsyncCallback callback, object object)
public TResult EndInvoke(IAsyncResult result)
}
public System.Func`5 : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4)
public IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, AsyncCallback callback, object object)
public TResult EndInvoke(IAsyncResult result)
}
public System.InvalidTimeZoneException : Exception {
public void .ctor(string message)
public void .ctor(string message, Exception e)
protected void .ctor(SerializationInfo info, StreamingContext sc)
}
public System.IO.HandleInheritability : Enum {
public int value__
public HandleInheritability None
public HandleInheritability Inheritable
}
public System.IO.Pipes.AnonymousPipeClientStream : PipeStream {
public PipeTransmissionMode ReadMode
public PipeTransmissionMode TransmissionMode
public void .ctor(string pipeHandleAsString)
public void .ctor(PipeDirection direction, string pipeHandleAsString)
public void .ctor(PipeDirection direction, SafePipeHandle safePipeHandle)
private SafePipeHandle ToSafePipeHandle(string pipeHandleAsString)
public void set_ReadMode(PipeTransmissionMode value)
public PipeTransmissionMode get_TransmissionMode()
}
public System.IO.Pipes.AnonymousPipeServerStream : PipeStream {
private IAnonymousPipeServer impl
private SafePipeHandle <ClientSafePipeHandle>k__BackingField
public SafePipeHandle ClientSafePipeHandle
public PipeTransmissionMode ReadMode
public PipeTransmissionMode TransmissionMode
public void .ctor(PipeDirection direction)
public void .ctor(PipeDirection direction, HandleInheritability inheritability)
public void .ctor(PipeDirection direction, HandleInheritability inheritability, int bufferSize)
public void .ctor(PipeDirection direction, HandleInheritability inheritability, int bufferSize, PipeSecurity pipeSecurity)
public void .ctor(PipeDirection direction, SafePipeHandle serverSafePipeHandle, SafePipeHandle clientSafePipeHandle)
public SafePipeHandle get_ClientSafePipeHandle()
private void set_ClientSafePipeHandle(SafePipeHandle value)
public void set_ReadMode(PipeTransmissionMode value)
public PipeTransmissionMode get_TransmissionMode()
public void DisposeLocalCopyOfClientHandle()
public string GetClientHandleAsString()
}
internal System.IO.Pipes.IAnonymousPipeServer {
public SafePipeHandle ClientHandle
public SafePipeHandle get_ClientHandle()
public void DisposeLocalCopyOfClientHandle()
}
internal System.IO.Pipes.INamedPipeClient {
public int NumberOfServerInstances
public bool IsAsync
public void Connect()
public void Connect(int timeout)
public int get_NumberOfServerInstances()
public bool get_IsAsync()
}
internal System.IO.Pipes.INamedPipeServer {
public void Disconnect()
public void WaitForConnection()
}
internal System.IO.Pipes.IPipe {
public SafePipeHandle Handle
public SafePipeHandle get_Handle()
public void WaitForPipeDrain()
}
public System.IO.Pipes.NamedPipeClientStream : PipeStream {
private INamedPipeClient impl
public int NumberOfServerInstances
public void .ctor(string pipeName)
public void .ctor(string serverName, string pipeName)
public void .ctor(string serverName, string pipeName, PipeDirection direction)
public void .ctor(string serverName, string pipeName, PipeDirection direction, PipeOptions options)
public void .ctor(string serverName, string pipeName, PipeDirection direction, PipeOptions options, TokenImpersonationLevel impersonationLevel)
public void .ctor(string serverName, string pipeName, PipeDirection direction, PipeOptions options, TokenImpersonationLevel impersonationLevel, HandleInheritability inheritability)
public void .ctor(PipeDirection direction, bool isAsync, bool isConnected, SafePipeHandle safePipeHandle)
public void .ctor(string serverName, string pipeName, PipeAccessRights desiredAccessRights, PipeOptions options, TokenImpersonationLevel impersonationLevel, HandleInheritability inheritability)
public void Connect()
public void Connect(int timeout)
public int get_NumberOfServerInstances()
}
public System.IO.Pipes.NamedPipeServerStream : PipeStream {
public int MaxAllowedServerInstances
private INamedPipeServer impl
private Action wait_connect_delegate
public void .ctor(string pipeName)
public void .ctor(string pipeName, PipeDirection direction)
public void .ctor(string pipeName, PipeDirection direction, int maxNumberOfServerInstances)
public void .ctor(string pipeName, PipeDirection direction, int maxNumberOfServerInstances, PipeTransmissionMode transmissionMode)
public void .ctor(string pipeName, PipeDirection direction, int maxNumberOfServerInstances, PipeTransmissionMode transmissionMode, PipeOptions options)
public void .ctor(string pipeName, PipeDirection direction, int maxNumberOfServerInstances, PipeTransmissionMode transmissionMode, PipeOptions options, int inBufferSize, int outBufferSize)
public void .ctor(string pipeName, PipeDirection direction, int maxNumberOfServerInstances, PipeTransmissionMode transmissionMode, PipeOptions options, int inBufferSize, int outBufferSize, PipeSecurity pipeSecurity)
public void .ctor(string pipeName, PipeDirection direction, int maxNumberOfServerInstances, PipeTransmissionMode transmissionMode, PipeOptions options, int inBufferSize, int outBufferSize, PipeSecurity pipeSecurity, HandleInheritability inheritability)
public void .ctor(string pipeName, PipeDirection direction, int maxNumberOfServerInstances, PipeTransmissionMode transmissionMode, PipeOptions options, int inBufferSize, int outBufferSize, PipeSecurity pipeSecurity, HandleInheritability inheritability, PipeAccessRights additionalAccessRights)
public void .ctor(PipeDirection direction, bool isAsync, bool isConnected, SafePipeHandle safePipeHandle)
public void Disconnect()
public void RunAsClient(PipeStreamImpersonationWorker impersonationWorker)
public void WaitForConnection()
public string GetImpersonationUserName()
public IAsyncResult BeginWaitForConnection(AsyncCallback callback, object state)
public void EndWaitForConnection(IAsyncResult asyncResult)
}
public System.IO.Pipes.PipeAccessRights : Enum {
public int value__
public PipeAccessRights ReadData
public PipeAccessRights WriteData
public PipeAccessRights ReadAttributes
public PipeAccessRights WriteAttributes
public PipeAccessRights ReadExtendedAttributes
public PipeAccessRights WriteExtendedAttributes
public PipeAccessRights CreateNewInstance
public PipeAccessRights Delete
public PipeAccessRights ReadPermissions
public PipeAccessRights ChangePermissions
public PipeAccessRights TakeOwnership
public PipeAccessRights Synchronize
public PipeAccessRights FullControl
public PipeAccessRights Read
public PipeAccessRights Write
public PipeAccessRights ReadWrite
public PipeAccessRights AccessSystemSecurity
}
public System.IO.Pipes.PipeAccessRule : AccessRule {
private PipeAccessRights <PipeAccessRights>k__BackingField
public PipeAccessRights PipeAccessRights
public void .ctor(IdentityReference identity, PipeAccessRights rights, AccessControlType type)
public void .ctor(string identity, PipeAccessRights rights, AccessControlType type)
public PipeAccessRights get_PipeAccessRights()
private void set_PipeAccessRights(PipeAccessRights value)
}
public System.IO.Pipes.PipeAuditRule : AuditRule {
private PipeAccessRights <PipeAccessRights>k__BackingField
public PipeAccessRights PipeAccessRights
public void .ctor(IdentityReference identity, PipeAccessRights rights, AuditFlags flags)
public void .ctor(string identity, PipeAccessRights rights, AuditFlags flags)
public PipeAccessRights get_PipeAccessRights()
private void set_PipeAccessRights(PipeAccessRights value)
}
public System.IO.Pipes.PipeDirection : Enum {
public int value__
public PipeDirection In
public PipeDirection Out
public PipeDirection InOut
}
public System.IO.Pipes.PipeOptions : Enum {
public int value__
public PipeOptions None
public PipeOptions WriteThrough
public PipeOptions Asynchronous
}
public System.IO.Pipes.PipeSecurity : NativeObjectSecurity {
public Type AccessRightType
public Type AccessRuleType
public Type AuditRuleType
public Type get_AccessRightType()
public Type get_AccessRuleType()
public Type get_AuditRuleType()
public AccessRule AccessRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AccessControlType type)
public void AddAccessRule(PipeAccessRule rule)
public void AddAuditRule(PipeAuditRule rule)
public AuditRule AuditRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags flags)
protected internal void Persist(SafeHandle handle)
protected internal void Persist(string name)
public bool RemoveAccessRule(PipeAccessRule rule)
public void RemoveAccessRuleSpecific(PipeAccessRule rule)
public bool RemoveAuditRule(PipeAuditRule rule)
public void RemoveAuditRuleAll(PipeAuditRule rule)
public void RemoveAuditRuleSpecific(PipeAuditRule rule)
public void ResetAccessRule(PipeAccessRule rule)
public void SetAccessRule(PipeAccessRule rule)
public void SetAuditRule(PipeAuditRule rule)
}
public System.IO.Pipes.PipeStream : Stream {
internal int DefaultBufferSize
private PipeDirection direction
private PipeTransmissionMode transmission_mode
private PipeTransmissionMode read_trans_mode
private int buffer_size
private SafePipeHandle handle
private Stream stream
private Func`4<Byte[], int, int, int> read_delegate
private Action`3<Byte[], int, int> write_delegate
private bool <IsAsync>k__BackingField
private bool <IsConnected>k__BackingField
private bool <IsHandleExposed>k__BackingField
private bool <IsMessageComplete>k__BackingField
internal bool IsWindows
public bool CanRead
public bool CanSeek
public bool CanWrite
public int InBufferSize
public bool IsAsync
public bool IsConnected
internal Stream Stream
protected bool IsHandleExposed
public bool IsMessageComplete
public int OutBufferSize
public PipeTransmissionMode ReadMode
public SafePipeHandle SafePipeHandle
public PipeTransmissionMode TransmissionMode
public long Length
public long Position
protected void .ctor(PipeDirection direction, int bufferSize)
protected void .ctor(PipeDirection direction, PipeTransmissionMode transmissionMode, int outBufferSize)
internal bool get_IsWindows()
internal Exception ThrowACLException()
internal PipeAccessRights ToAccessRights(PipeDirection direction)
internal PipeDirection ToDirection(PipeAccessRights rights)
public bool get_CanRead()
public bool get_CanSeek()
public bool get_CanWrite()
public int get_InBufferSize()
public bool get_IsAsync()
private void set_IsAsync(bool value)
public bool get_IsConnected()
protected void set_IsConnected(bool value)
internal Stream get_Stream()
internal void set_Stream(Stream value)
protected bool get_IsHandleExposed()
private void set_IsHandleExposed(bool value)
public bool get_IsMessageComplete()
private void set_IsMessageComplete(bool value)
public int get_OutBufferSize()
public PipeTransmissionMode get_ReadMode()
public void set_ReadMode(PipeTransmissionMode value)
public SafePipeHandle get_SafePipeHandle()
public PipeTransmissionMode get_TransmissionMode()
protected internal void CheckPipePropertyOperations()
protected internal void CheckReadOperations()
protected internal void CheckWriteOperations()
protected void InitializeHandle(SafePipeHandle handle, bool isExposed, bool isAsync)
protected void Dispose(bool disposing)
public long get_Length()
public long get_Position()
public void set_Position(long value)
public void SetLength(long value)
public long Seek(long offset, SeekOrigin origin)
public PipeSecurity GetAccessControl()
public void SetAccessControl(PipeSecurity pipeSecurity)
public void WaitForPipeDrain()
public int Read(Byte[] buffer, int offset, int count)
public int ReadByte()
public void Write(Byte[] buffer, int offset, int count)
public void WriteByte(byte value)
public void Flush()
public IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state)
public IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state)
public int EndRead(IAsyncResult asyncResult)
public void EndWrite(IAsyncResult asyncResult)
}
public System.IO.Pipes.PipeStreamImpersonationWorker : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke()
public IAsyncResult BeginInvoke(AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.IO.Pipes.PipeTransmissionMode : Enum {
public int value__
public PipeTransmissionMode Byte
public PipeTransmissionMode Message
}
internal System.IO.Pipes.SecurityAttributesHack : ValueType {
public int Length
public IntPtr SecurityDescriptor
public bool Inheritable
public void .ctor(bool inheritable)
}
internal System.IO.Pipes.UnixAnonymousPipe : object {
public SafePipeHandle Handle
public SafePipeHandle get_Handle()
public void WaitForPipeDrain()
}
internal System.IO.Pipes.UnixAnonymousPipeClient : UnixAnonymousPipe {
private SafePipeHandle handle
public SafePipeHandle Handle
public void .ctor(AnonymousPipeClientStream owner, SafePipeHandle handle)
public SafePipeHandle get_Handle()
}
internal System.IO.Pipes.UnixAnonymousPipeServer : UnixAnonymousPipe {
private SafePipeHandle server_handle
private SafePipeHandle client_handle
public SafePipeHandle Handle
public SafePipeHandle ClientHandle
public void .ctor(AnonymousPipeServerStream owner, PipeDirection direction, HandleInheritability inheritability, int bufferSize)
public void .ctor(AnonymousPipeServerStream owner, SafePipeHandle serverHandle, SafePipeHandle clientHandle)
public SafePipeHandle get_Handle()
public SafePipeHandle get_ClientHandle()
public void DisposeLocalCopyOfClientHandle()
}
internal System.IO.Pipes.UnixNamedPipe : object {
public SafePipeHandle Handle
public SafePipeHandle get_Handle()
public void WaitForPipeDrain()
public void EnsureTargetFile(string name)
protected void ValidateOptions(PipeOptions options, PipeTransmissionMode mode)
protected string RightsToAccess(PipeAccessRights rights)
protected FileAccess RightsToFileAccess(PipeAccessRights rights)
}
internal System.IO.Pipes.UnixNamedPipeClient : UnixNamedPipe {
private NamedPipeClientStream owner
private bool is_async
private SafePipeHandle handle
private Action opener
public SafePipeHandle Handle
public bool IsAsync
public int NumberOfServerInstances
public void .ctor(NamedPipeClientStream owner, SafePipeHandle safePipeHandle)
public void .ctor(NamedPipeClientStream owner, string serverName, string pipeName, PipeAccessRights desiredAccessRights, PipeOptions options, HandleInheritability inheritability)
public SafePipeHandle get_Handle()
public void Connect()
public void Connect(int timeout)
public bool get_IsAsync()
public int get_NumberOfServerInstances()
}
internal System.IO.Pipes.UnixNamedPipeServer : UnixNamedPipe {
private SafePipeHandle handle
private bool should_close_handle
public SafePipeHandle Handle
public void .ctor(NamedPipeServerStream owner, SafePipeHandle safePipeHandle)
public void .ctor(NamedPipeServerStream owner, string pipeName, int maxNumberOfServerInstances, PipeTransmissionMode transmissionMode, PipeAccessRights rights, PipeOptions options, int inBufferSize, int outBufferSize, HandleInheritability inheritability)
public SafePipeHandle get_Handle()
public void Disconnect()
public void WaitForConnection()
}
internal System.IO.Pipes.Win32AnonymousPipe : object {
public SafePipeHandle Handle
public SafePipeHandle get_Handle()
public void WaitForPipeDrain()
}
internal System.IO.Pipes.Win32AnonymousPipeClient : Win32AnonymousPipe {
private SafePipeHandle handle
public SafePipeHandle Handle
public void .ctor(AnonymousPipeClientStream owner, SafePipeHandle handle)
public SafePipeHandle get_Handle()
}
internal System.IO.Pipes.Win32AnonymousPipeServer : Win32AnonymousPipe {
private SafePipeHandle server_handle
private SafePipeHandle client_handle
public SafePipeHandle Handle
public SafePipeHandle ClientHandle
public void .ctor(AnonymousPipeServerStream owner, PipeDirection direction, HandleInheritability inheritability, int bufferSize)
public void .ctor(AnonymousPipeServerStream owner, SafePipeHandle serverHandle, SafePipeHandle clientHandle)
public SafePipeHandle get_Handle()
public SafePipeHandle get_ClientHandle()
public void DisposeLocalCopyOfClientHandle()
}
internal System.IO.Pipes.Win32Marshal : object {
internal bool IsWindows
internal bool get_IsWindows()
internal bool CreatePipe(IntPtr& readHandle, IntPtr& writeHandle, SecurityAttributesHack& pipeAtts, int size)
internal IntPtr CreateNamedPipe(string name, UInt32 openMode, int pipeMode, int maxInstances, int outBufferSize, int inBufferSize, int defaultTimeout, SecurityAttributesHack& securityAttributes, IntPtr atts)
internal bool ConnectNamedPipe(SafePipeHandle handle, IntPtr overlapped)
internal bool DisconnectNamedPipe(SafePipeHandle handle)
internal bool GetNamedPipeHandleState(SafePipeHandle handle, Int32& state, Int32& curInstances, Int32& maxCollectionCount, Int32& collectDateTimeout, Byte[] userName, int maxUserNameSize)
internal bool WaitNamedPipe(string name, int timeout)
internal IntPtr CreateFile(string name, PipeAccessRights desiredAccess, FileShare fileShare, SecurityAttributesHack& atts, int creationDisposition, int flags, IntPtr templateHandle)
}
internal System.IO.Pipes.Win32NamedPipe : object {
private string name_cache
public string Name
public SafePipeHandle Handle
public string get_Name()
public SafePipeHandle get_Handle()
public void WaitForPipeDrain()
}
internal System.IO.Pipes.Win32NamedPipeClient : Win32NamedPipe {
private NamedPipeClientStream owner
private Func`1<SafePipeHandle> opener
private bool is_async
private string name
private SafePipeHandle handle
public SafePipeHandle Handle
public bool IsAsync
public int NumberOfServerInstances
public void .ctor(NamedPipeClientStream owner, SafePipeHandle safePipeHandle)
public void .ctor(NamedPipeClientStream owner, string serverName, string pipeName, PipeAccessRights desiredAccessRights, PipeOptions options, HandleInheritability inheritability)
public SafePipeHandle get_Handle()
public bool get_IsAsync()
public void Connect()
public void Connect(int timeout)
public int get_NumberOfServerInstances()
}
internal System.IO.Pipes.Win32NamedPipeServer : Win32NamedPipe {
private SafePipeHandle handle
public SafePipeHandle Handle
public void .ctor(NamedPipeServerStream owner, SafePipeHandle safePipeHandle)
public void .ctor(NamedPipeServerStream owner, string pipeName, int maxNumberOfServerInstances, PipeTransmissionMode transmissionMode, PipeAccessRights rights, PipeOptions options, int inBufferSize, int outBufferSize, HandleInheritability inheritability)
public SafePipeHandle get_Handle()
public void Disconnect()
public void WaitForConnection()
}
internal System.Linq.Check : object {
public void Source(object source)
public void Source1AndSource2(object source1, object source2)
public void SourceAndFuncAndSelector(object source, object func, object selector)
public void SourceAndFunc(object source, object func)
public void SourceAndSelector(object source, object selector)
public void SourceAndPredicate(object source, object predicate)
public void FirstAndSecond(object first, object second)
public void SourceAndKeySelector(object source, object keySelector)
public void SourceAndKeyElementSelectors(object source, object keySelector, object elementSelector)
public void SourceAndKeyResultSelectors(object source, object keySelector, object resultSelector)
public void SourceAndCollectionSelectorAndResultSelector(object source, object collectionSelector, object resultSelector)
public void SourceAndCollectionSelectors(object source, object collectionSelector, object selector)
public void JoinSelectors(object outer, object inner, object outerKeySelector, object innerKeySelector, object resultSelector)
public void GroupBySelectors(object source, object keySelector, object elementSelector, object resultSelector)
}
public System.Linq.Enumerable : object {
private Func`3<int, int, int> <>f__am$cache0
private Func`3<long, long, long> <>f__am$cache1
private Func`3<double, double, double> <>f__am$cache2
private Func`3<float, float, float> <>f__am$cache3
private Func`3<decimal, decimal, decimal> <>f__am$cache4
private Func`3<int, int, int> <>f__am$cache5
private Func`3<long, long, long> <>f__am$cache6
private Func`3<double, double, double> <>f__am$cache7
private Func`3<float, float, float> <>f__am$cache8
private Func`3<decimal, decimal, decimal> <>f__am$cache9
private Func`3<int, int, int> <>f__am$cacheA
private Func`3<long, long, long> <>f__am$cacheB
private Func`3<double, double, double> <>f__am$cacheC
private Func`3<float, float, float> <>f__am$cacheD
private Func`3<decimal, decimal, decimal> <>f__am$cacheE
private Func`3<int, int, int> <>f__am$cacheF
private Func`3<long, long, long> <>f__am$cache10
private Func`3<double, double, double> <>f__am$cache11
private Func`3<float, float, float> <>f__am$cache12
private Func`3<decimal, decimal, decimal> <>f__am$cache13
private Func`3<int, int, int> <>f__am$cache14
private Func`3<Nullable`1<int>, Nullable`1<int>, Nullable`1<int>> <>f__am$cache15
private Func`3<long, long, long> <>f__am$cache16
private Func`3<Nullable`1<long>, Nullable`1<long>, Nullable`1<long>> <>f__am$cache17
private Func`3<double, double, double> <>f__am$cache18
private Func`3<Nullable`1<double>, Nullable`1<double>, Nullable`1<double>> <>f__am$cache19
private Func`3<float, float, float> <>f__am$cache1A
private Func`3<Nullable`1<float>, Nullable`1<float>, Nullable`1<float>> <>f__am$cache1B
private Func`3<decimal, decimal, decimal> <>f__am$cache1C
private Func`3<Nullable`1<decimal>, Nullable`1<decimal>, Nullable`1<decimal>> <>f__am$cache1D
public TSource Aggregate(IEnumerable`1<TSource> source, Func`3<TSource, TSource, TSource> func)
public TAccumulate Aggregate(IEnumerable`1<TSource> source, TAccumulate seed, Func`3<TAccumulate, TSource, TAccumulate> func)
public TResult Aggregate(IEnumerable`1<TSource> source, TAccumulate seed, Func`3<TAccumulate, TSource, TAccumulate> func, Func`2<TAccumulate, TResult> resultSelector)
public bool All(IEnumerable`1<TSource> source, Func`2<TSource, bool> predicate)
public bool Any(IEnumerable`1<TSource> source)
public bool Any(IEnumerable`1<TSource> source, Func`2<TSource, bool> predicate)
public IEnumerable`1<TSource> AsEnumerable(IEnumerable`1<TSource> source)
public double Average(IEnumerable`1<int> source)
public double Average(IEnumerable`1<long> source)
public double Average(IEnumerable`1<double> source)
public float Average(IEnumerable`1<float> source)
public decimal Average(IEnumerable`1<decimal> source)
public Nullable`1<double> Average(IEnumerable`1<Nullable`1<int>> source)
public Nullable`1<double> Average(IEnumerable`1<Nullable`1<long>> source)
public Nullable`1<double> Average(IEnumerable`1<Nullable`1<double>> source)
public Nullable`1<decimal> Average(IEnumerable`1<Nullable`1<decimal>> source)
public Nullable`1<float> Average(IEnumerable`1<Nullable`1<float>> source)
public double Average(IEnumerable`1<TSource> source, Func`2<TSource, int> selector)
public Nullable`1<double> Average(IEnumerable`1<TSource> source, Func`2<TSource, Nullable`1<int>> selector)
public double Average(IEnumerable`1<TSource> source, Func`2<TSource, long> selector)
public Nullable`1<double> Average(IEnumerable`1<TSource> source, Func`2<TSource, Nullable`1<long>> selector)
public double Average(IEnumerable`1<TSource> source, Func`2<TSource, double> selector)
public Nullable`1<double> Average(IEnumerable`1<TSource> source, Func`2<TSource, Nullable`1<double>> selector)
public float Average(IEnumerable`1<TSource> source, Func`2<TSource, float> selector)
public Nullable`1<float> Average(IEnumerable`1<TSource> source, Func`2<TSource, Nullable`1<float>> selector)
public decimal Average(IEnumerable`1<TSource> source, Func`2<TSource, decimal> selector)
public Nullable`1<decimal> Average(IEnumerable`1<TSource> source, Func`2<TSource, Nullable`1<decimal>> selector)
public IEnumerable`1<TResult> Cast(IEnumerable source)
private IEnumerable`1<TResult> CreateCastIterator(IEnumerable source)
public IEnumerable`1<TSource> Concat(IEnumerable`1<TSource> first, IEnumerable`1<TSource> second)
private IEnumerable`1<TSource> CreateConcatIterator(IEnumerable`1<TSource> first, IEnumerable`1<TSource> second)
public bool Contains(IEnumerable`1<TSource> source, TSource value)
public bool Contains(IEnumerable`1<TSource> source, TSource value, IEqualityComparer`1<TSource> comparer)
public int Count(IEnumerable`1<TSource> source)
public int Count(IEnumerable`1<TSource> source, Func`2<TSource, bool> selector)
public IEnumerable`1<TSource> DefaultIfEmpty(IEnumerable`1<TSource> source)
public IEnumerable`1<TSource> DefaultIfEmpty(IEnumerable`1<TSource> source, TSource defaultValue)
private IEnumerable`1<TSource> CreateDefaultIfEmptyIterator(IEnumerable`1<TSource> source, TSource defaultValue)
public IEnumerable`1<TSource> Distinct(IEnumerable`1<TSource> source)
public IEnumerable`1<TSource> Distinct(IEnumerable`1<TSource> source, IEqualityComparer`1<TSource> comparer)
private IEnumerable`1<TSource> CreateDistinctIterator(IEnumerable`1<TSource> source, IEqualityComparer`1<TSource> comparer)
private TSource ElementAt(IEnumerable`1<TSource> source, int index, Fallback fallback)
public TSource ElementAt(IEnumerable`1<TSource> source, int index)
public TSource ElementAtOrDefault(IEnumerable`1<TSource> source, int index)
public IEnumerable`1<TResult> Empty()
public IEnumerable`1<TSource> Except(IEnumerable`1<TSource> first, IEnumerable`1<TSource> second)
public IEnumerable`1<TSource> Except(IEnumerable`1<TSource> first, IEnumerable`1<TSource> second, IEqualityComparer`1<TSource> comparer)
private IEnumerable`1<TSource> CreateExceptIterator(IEnumerable`1<TSource> first, IEnumerable`1<TSource> second, IEqualityComparer`1<TSource> comparer)
private TSource First(IEnumerable`1<TSource> source, Func`2<TSource, bool> predicate, Fallback fallback)
public TSource First(IEnumerable`1<TSource> source)
public TSource First(IEnumerable`1<TSource> source, Func`2<TSource, bool> predicate)
public TSource FirstOrDefault(IEnumerable`1<TSource> source)
public TSource FirstOrDefault(IEnumerable`1<TSource> source, Func`2<TSource, bool> predicate)
private List`1<T> ContainsGroup(Dictionary`2<K, List`1<T>> items, K key, IEqualityComparer`1<K> comparer)
public IEnumerable`1<IGrouping`2<TKey, TSource>> GroupBy(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector)
public IEnumerable`1<IGrouping`2<TKey, TSource>> GroupBy(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, IEqualityComparer`1<TKey> comparer)
private IEnumerable`1<IGrouping`2<TKey, TSource>> CreateGroupByIterator(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, IEqualityComparer`1<TKey> comparer)
public IEnumerable`1<IGrouping`2<TKey, TElement>> GroupBy(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`2<TSource, TElement> elementSelector)
public IEnumerable`1<IGrouping`2<TKey, TElement>> GroupBy(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`2<TSource, TElement> elementSelector, IEqualityComparer`1<TKey> comparer)
private IEnumerable`1<IGrouping`2<TKey, TElement>> CreateGroupByIterator(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`2<TSource, TElement> elementSelector, IEqualityComparer`1<TKey> comparer)
public IEnumerable`1<TResult> GroupBy(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`2<TSource, TElement> elementSelector, Func`3<TKey, IEnumerable`1<TElement>, TResult> resultSelector)
public IEnumerable`1<TResult> GroupBy(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`2<TSource, TElement> elementSelector, Func`3<TKey, IEnumerable`1<TElement>, TResult> resultSelector, IEqualityComparer`1<TKey> comparer)
private IEnumerable`1<TResult> CreateGroupByIterator(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`2<TSource, TElement> elementSelector, Func`3<TKey, IEnumerable`1<TElement>, TResult> resultSelector, IEqualityComparer`1<TKey> comparer)
public IEnumerable`1<TResult> GroupBy(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`3<TKey, IEnumerable`1<TSource>, TResult> resultSelector)
public IEnumerable`1<TResult> GroupBy(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`3<TKey, IEnumerable`1<TSource>, TResult> resultSelector, IEqualityComparer`1<TKey> comparer)
private IEnumerable`1<TResult> CreateGroupByIterator(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`3<TKey, IEnumerable`1<TSource>, TResult> resultSelector, IEqualityComparer`1<TKey> comparer)
public IEnumerable`1<TResult> GroupJoin(IEnumerable`1<TOuter> outer, IEnumerable`1<TInner> inner, Func`2<TOuter, TKey> outerKeySelector, Func`2<TInner, TKey> innerKeySelector, Func`3<TOuter, IEnumerable`1<TInner>, TResult> resultSelector)
public IEnumerable`1<TResult> GroupJoin(IEnumerable`1<TOuter> outer, IEnumerable`1<TInner> inner, Func`2<TOuter, TKey> outerKeySelector, Func`2<TInner, TKey> innerKeySelector, Func`3<TOuter, IEnumerable`1<TInner>, TResult> resultSelector, IEqualityComparer`1<TKey> comparer)
private IEnumerable`1<TResult> CreateGroupJoinIterator(IEnumerable`1<TOuter> outer, IEnumerable`1<TInner> inner, Func`2<TOuter, TKey> outerKeySelector, Func`2<TInner, TKey> innerKeySelector, Func`3<TOuter, IEnumerable`1<TInner>, TResult> resultSelector, IEqualityComparer`1<TKey> comparer)
public IEnumerable`1<TSource> Intersect(IEnumerable`1<TSource> first, IEnumerable`1<TSource> second)
public IEnumerable`1<TSource> Intersect(IEnumerable`1<TSource> first, IEnumerable`1<TSource> second, IEqualityComparer`1<TSource> comparer)
private IEnumerable`1<TSource> CreateIntersectIterator(IEnumerable`1<TSource> first, IEnumerable`1<TSource> second, IEqualityComparer`1<TSource> comparer)
public IEnumerable`1<TResult> Join(IEnumerable`1<TOuter> outer, IEnumerable`1<TInner> inner, Func`2<TOuter, TKey> outerKeySelector, Func`2<TInner, TKey> innerKeySelector, Func`3<TOuter, TInner, TResult> resultSelector, IEqualityComparer`1<TKey> comparer)
private IEnumerable`1<TResult> CreateJoinIterator(IEnumerable`1<TOuter> outer, IEnumerable`1<TInner> inner, Func`2<TOuter, TKey> outerKeySelector, Func`2<TInner, TKey> innerKeySelector, Func`3<TOuter, TInner, TResult> resultSelector, IEqualityComparer`1<TKey> comparer)
public IEnumerable`1<TResult> Join(IEnumerable`1<TOuter> outer, IEnumerable`1<TInner> inner, Func`2<TOuter, TKey> outerKeySelector, Func`2<TInner, TKey> innerKeySelector, Func`3<TOuter, TInner, TResult> resultSelector)
private TSource Last(IEnumerable`1<TSource> source, Func`2<TSource, bool> predicate, Fallback fallback)
public TSource Last(IEnumerable`1<TSource> source)
public TSource Last(IEnumerable`1<TSource> source, Func`2<TSource, bool> predicate)
public TSource LastOrDefault(IEnumerable`1<TSource> source)
public TSource LastOrDefault(IEnumerable`1<TSource> source, Func`2<TSource, bool> predicate)
public long LongCount(IEnumerable`1<TSource> source)
public long LongCount(IEnumerable`1<TSource> source, Func`2<TSource, bool> selector)
public int Max(IEnumerable`1<int> source)
public long Max(IEnumerable`1<long> source)
public double Max(IEnumerable`1<double> source)
public float Max(IEnumerable`1<float> source)
public decimal Max(IEnumerable`1<decimal> source)
public Nullable`1<int> Max(IEnumerable`1<Nullable`1<int>> source)
public Nullable`1<long> Max(IEnumerable`1<Nullable`1<long>> source)
public Nullable`1<double> Max(IEnumerable`1<Nullable`1<double>> source)
public Nullable`1<float> Max(IEnumerable`1<Nullable`1<float>> source)
public Nullable`1<decimal> Max(IEnumerable`1<Nullable`1<decimal>> source)
private Nullable`1<T> IterateNullable(IEnumerable`1<Nullable`1<T>> source, Func`3<T, T, T> selector)
private Nullable`1<TRet> IterateNullable(IEnumerable`1<TSource> source, Func`2<TSource, Nullable`1<TRet>> source_selector, Func`3<Nullable`1<TRet>, Nullable`1<TRet>, bool> selector)
private TSource IterateNullable(IEnumerable`1<TSource> source, Func`3<TSource, TSource, bool> selector)
private TSource IterateNonNullable(IEnumerable`1<TSource> source, Func`3<TSource, TSource, bool> selector)
public TSource Max(IEnumerable`1<TSource> source)
public int Max(IEnumerable`1<TSource> source, Func`2<TSource, int> selector)
public long Max(IEnumerable`1<TSource> source, Func`2<TSource, long> selector)
public double Max(IEnumerable`1<TSource> source, Func`2<TSource, double> selector)
public float Max(IEnumerable`1<TSource> source, Func`2<TSource, float> selector)
public decimal Max(IEnumerable`1<TSource> source, Func`2<TSource, decimal> selector)
private U Iterate(IEnumerable`1<T> source, U initValue, Func`3<T, U, U> selector)
public Nullable`1<int> Max(IEnumerable`1<TSource> source, Func`2<TSource, Nullable`1<int>> selector)
public Nullable`1<long> Max(IEnumerable`1<TSource> source, Func`2<TSource, Nullable`1<long>> selector)
public Nullable`1<double> Max(IEnumerable`1<TSource> source, Func`2<TSource, Nullable`1<double>> selector)
public Nullable`1<float> Max(IEnumerable`1<TSource> source, Func`2<TSource, Nullable`1<float>> selector)
public Nullable`1<decimal> Max(IEnumerable`1<TSource> source, Func`2<TSource, Nullable`1<decimal>> selector)
public TResult Max(IEnumerable`1<TSource> source, Func`2<TSource, TResult> selector)
public int Min(IEnumerable`1<int> source)
public long Min(IEnumerable`1<long> source)
public double Min(IEnumerable`1<double> source)
public float Min(IEnumerable`1<float> source)
public decimal Min(IEnumerable`1<decimal> source)
public Nullable`1<int> Min(IEnumerable`1<Nullable`1<int>> source)
public Nullable`1<long> Min(IEnumerable`1<Nullable`1<long>> source)
public Nullable`1<double> Min(IEnumerable`1<Nullable`1<double>> source)
public Nullable`1<float> Min(IEnumerable`1<Nullable`1<float>> source)
public Nullable`1<decimal> Min(IEnumerable`1<Nullable`1<decimal>> source)
public TSource Min(IEnumerable`1<TSource> source)
public int Min(IEnumerable`1<TSource> source, Func`2<TSource, int> selector)
public long Min(IEnumerable`1<TSource> source, Func`2<TSource, long> selector)
public double Min(IEnumerable`1<TSource> source, Func`2<TSource, double> selector)
public float Min(IEnumerable`1<TSource> source, Func`2<TSource, float> selector)
public decimal Min(IEnumerable`1<TSource> source, Func`2<TSource, decimal> selector)
public Nullable`1<int> Min(IEnumerable`1<TSource> source, Func`2<TSource, Nullable`1<int>> selector)
public Nullable`1<long> Min(IEnumerable`1<TSource> source, Func`2<TSource, Nullable`1<long>> selector)
public Nullable`1<float> Min(IEnumerable`1<TSource> source, Func`2<TSource, Nullable`1<float>> selector)
public Nullable`1<double> Min(IEnumerable`1<TSource> source, Func`2<TSource, Nullable`1<double>> selector)
public Nullable`1<decimal> Min(IEnumerable`1<TSource> source, Func`2<TSource, Nullable`1<decimal>> selector)
public TResult Min(IEnumerable`1<TSource> source, Func`2<TSource, TResult> selector)
public IEnumerable`1<TResult> OfType(IEnumerable source)
private IEnumerable`1<TResult> CreateOfTypeIterator(IEnumerable source)
public IOrderedEnumerable`1<TSource> OrderBy(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector)
public IOrderedEnumerable`1<TSource> OrderBy(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> comparer)
public IOrderedEnumerable`1<TSource> OrderByDescending(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector)
public IOrderedEnumerable`1<TSource> OrderByDescending(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> comparer)
public IEnumerable`1<int> Range(int start, int count)
private IEnumerable`1<int> CreateRangeIterator(int start, int upto)
public IEnumerable`1<TResult> Repeat(TResult element, int count)
private IEnumerable`1<TResult> CreateRepeatIterator(TResult element, int count)
public IEnumerable`1<TSource> Reverse(IEnumerable`1<TSource> source)
private IEnumerable`1<TSource> CreateReverseIterator(IEnumerable`1<TSource> source)
public IEnumerable`1<TResult> Select(IEnumerable`1<TSource> source, Func`2<TSource, TResult> selector)
private IEnumerable`1<TResult> CreateSelectIterator(IEnumerable`1<TSource> source, Func`2<TSource, TResult> selector)
public IEnumerable`1<TResult> Select(IEnumerable`1<TSource> source, Func`3<TSource, int, TResult> selector)
private IEnumerable`1<TResult> CreateSelectIterator(IEnumerable`1<TSource> source, Func`3<TSource, int, TResult> selector)
public IEnumerable`1<TResult> SelectMany(IEnumerable`1<TSource> source, Func`2<TSource, IEnumerable`1<TResult>> selector)
private IEnumerable`1<TResult> CreateSelectManyIterator(IEnumerable`1<TSource> source, Func`2<TSource, IEnumerable`1<TResult>> selector)
public IEnumerable`1<TResult> SelectMany(IEnumerable`1<TSource> source, Func`3<TSource, int, IEnumerable`1<TResult>> selector)
private IEnumerable`1<TResult> CreateSelectManyIterator(IEnumerable`1<TSource> source, Func`3<TSource, int, IEnumerable`1<TResult>> selector)
public IEnumerable`1<TResult> SelectMany(IEnumerable`1<TSource> source, Func`2<TSource, IEnumerable`1<TCollection>> collectionSelector, Func`3<TSource, TCollection, TResult> selector)
private IEnumerable`1<TResult> CreateSelectManyIterator(IEnumerable`1<TSource> source, Func`2<TSource, IEnumerable`1<TCollection>> collectionSelector, Func`3<TSource, TCollection, TResult> selector)
public IEnumerable`1<TResult> SelectMany(IEnumerable`1<TSource> source, Func`3<TSource, int, IEnumerable`1<TCollection>> collectionSelector, Func`3<TSource, TCollection, TResult> selector)
private IEnumerable`1<TResult> CreateSelectManyIterator(IEnumerable`1<TSource> source, Func`3<TSource, int, IEnumerable`1<TCollection>> collectionSelector, Func`3<TSource, TCollection, TResult> selector)
private TSource Single(IEnumerable`1<TSource> source, Func`2<TSource, bool> predicate, Fallback fallback)
public TSource Single(IEnumerable`1<TSource> source)
public TSource Single(IEnumerable`1<TSource> source, Func`2<TSource, bool> predicate)
public TSource SingleOrDefault(IEnumerable`1<TSource> source)
public TSource SingleOrDefault(IEnumerable`1<TSource> source, Func`2<TSource, bool> predicate)
public IEnumerable`1<TSource> Skip(IEnumerable`1<TSource> source, int count)
private IEnumerable`1<TSource> CreateSkipIterator(IEnumerable`1<TSource> source, int count)
public IEnumerable`1<TSource> SkipWhile(IEnumerable`1<TSource> source, Func`2<TSource, bool> predicate)
private IEnumerable`1<TSource> CreateSkipWhileIterator(IEnumerable`1<TSource> source, Func`2<TSource, bool> predicate)
public IEnumerable`1<TSource> SkipWhile(IEnumerable`1<TSource> source, Func`3<TSource, int, bool> predicate)
private IEnumerable`1<TSource> CreateSkipWhileIterator(IEnumerable`1<TSource> source, Func`3<TSource, int, bool> predicate)
public int Sum(IEnumerable`1<int> source)
public Nullable`1<int> Sum(IEnumerable`1<Nullable`1<int>> source)
public int Sum(IEnumerable`1<TSource> source, Func`2<TSource, int> selector)
public Nullable`1<int> Sum(IEnumerable`1<TSource> source, Func`2<TSource, Nullable`1<int>> selector)
public long Sum(IEnumerable`1<long> source)
public Nullable`1<long> Sum(IEnumerable`1<Nullable`1<long>> source)
public long Sum(IEnumerable`1<TSource> source, Func`2<TSource, long> selector)
public Nullable`1<long> Sum(IEnumerable`1<TSource> source, Func`2<TSource, Nullable`1<long>> selector)
public double Sum(IEnumerable`1<double> source)
public Nullable`1<double> Sum(IEnumerable`1<Nullable`1<double>> source)
public double Sum(IEnumerable`1<TSource> source, Func`2<TSource, double> selector)
public Nullable`1<double> Sum(IEnumerable`1<TSource> source, Func`2<TSource, Nullable`1<double>> selector)
public float Sum(IEnumerable`1<float> source)
public Nullable`1<float> Sum(IEnumerable`1<Nullable`1<float>> source)
public float Sum(IEnumerable`1<TSource> source, Func`2<TSource, float> selector)
public Nullable`1<float> Sum(IEnumerable`1<TSource> source, Func`2<TSource, Nullable`1<float>> selector)
public decimal Sum(IEnumerable`1<decimal> source)
public Nullable`1<decimal> Sum(IEnumerable`1<Nullable`1<decimal>> source)
public decimal Sum(IEnumerable`1<TSource> source, Func`2<TSource, decimal> selector)
public Nullable`1<decimal> Sum(IEnumerable`1<TSource> source, Func`2<TSource, Nullable`1<decimal>> selector)
private TR Sum(IEnumerable`1<TA> source, Func`3<TR, TA, TR> selector)
private TR SumNullable(IEnumerable`1<TA> source, TR zero, Func`3<TR, TA, TR> selector)
public IEnumerable`1<TSource> Take(IEnumerable`1<TSource> source, int count)
private IEnumerable`1<TSource> CreateTakeIterator(IEnumerable`1<TSource> source, int count)
public IEnumerable`1<TSource> TakeWhile(IEnumerable`1<TSource> source, Func`2<TSource, bool> predicate)
private IEnumerable`1<TSource> CreateTakeWhileIterator(IEnumerable`1<TSource> source, Func`2<TSource, bool> predicate)
public IEnumerable`1<TSource> TakeWhile(IEnumerable`1<TSource> source, Func`3<TSource, int, bool> predicate)
private IEnumerable`1<TSource> CreateTakeWhileIterator(IEnumerable`1<TSource> source, Func`3<TSource, int, bool> predicate)
public IOrderedEnumerable`1<TSource> ThenBy(IOrderedEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector)
public IOrderedEnumerable`1<TSource> ThenBy(IOrderedEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> comparer)
public IOrderedEnumerable`1<TSource> ThenByDescending(IOrderedEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector)
public IOrderedEnumerable`1<TSource> ThenByDescending(IOrderedEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> comparer)
public TSource[] ToArray(IEnumerable`1<TSource> source)
public Dictionary`2<TKey, TElement> ToDictionary(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`2<TSource, TElement> elementSelector)
public Dictionary`2<TKey, TElement> ToDictionary(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`2<TSource, TElement> elementSelector, IEqualityComparer`1<TKey> comparer)
public Dictionary`2<TKey, TSource> ToDictionary(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector)
public Dictionary`2<TKey, TSource> ToDictionary(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, IEqualityComparer`1<TKey> comparer)
public List`1<TSource> ToList(IEnumerable`1<TSource> source)
public ILookup`2<TKey, TSource> ToLookup(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector)
public ILookup`2<TKey, TSource> ToLookup(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, IEqualityComparer`1<TKey> comparer)
public ILookup`2<TKey, TElement> ToLookup(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`2<TSource, TElement> elementSelector)
public ILookup`2<TKey, TElement> ToLookup(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`2<TSource, TElement> elementSelector, IEqualityComparer`1<TKey> comparer)
public bool SequenceEqual(IEnumerable`1<TSource> first, IEnumerable`1<TSource> second)
public bool SequenceEqual(IEnumerable`1<TSource> first, IEnumerable`1<TSource> second, IEqualityComparer`1<TSource> comparer)
public IEnumerable`1<TSource> Union(IEnumerable`1<TSource> first, IEnumerable`1<TSource> second)
public IEnumerable`1<TSource> Union(IEnumerable`1<TSource> first, IEnumerable`1<TSource> second, IEqualityComparer`1<TSource> comparer)
private IEnumerable`1<TSource> CreateUnionIterator(IEnumerable`1<TSource> first, IEnumerable`1<TSource> second, IEqualityComparer`1<TSource> comparer)
public IEnumerable`1<TSource> Where(IEnumerable`1<TSource> source, Func`2<TSource, bool> predicate)
private IEnumerable`1<TSource> CreateWhereIterator(IEnumerable`1<TSource> source, Func`2<TSource, bool> predicate)
public IEnumerable`1<TSource> Where(IEnumerable`1<TSource> source, Func`3<TSource, int, bool> predicate)
private IEnumerable`1<TSource> CreateWhereIterator(IEnumerable`1<TSource> source, Func`3<TSource, int, bool> predicate)
internal ReadOnlyCollection`1<TSource> ToReadOnlyCollection(IEnumerable`1<TSource> source)
private int <Max>m__C(int a, int b)
private long <Max>m__D(long a, long b)
private double <Max>m__E(double a, double b)
private float <Max>m__F(float a, float b)
private decimal <Max>m__10(decimal a, decimal b)
private int <Max>m__11(int a, int b)
private long <Max>m__12(long a, long b)
private double <Max>m__13(double a, double b)
private float <Max>m__14(float a, float b)
private decimal <Max>m__15(decimal a, decimal b)
private bool <Max`1>m__1C(Nullable`1<int> a, Nullable`1<int> b)
private bool <Max`1>m__1D(Nullable`1<long> a, Nullable`1<long> b)
private bool <Max`1>m__1E(Nullable`1<double> a, Nullable`1<double> b)
private bool <Max`1>m__1F(Nullable`1<float> a, Nullable`1<float> b)
private bool <Max`1>m__20(Nullable`1<decimal> a, Nullable`1<decimal> b)
private int <Min>m__21(int a, int b)
private long <Min>m__22(long a, long b)
private double <Min>m__23(double a, double b)
private float <Min>m__24(float a, float b)
private decimal <Min>m__25(decimal a, decimal b)
private int <Min>m__26(int a, int b)
private long <Min>m__27(long a, long b)
private double <Min>m__28(double a, double b)
private float <Min>m__29(float a, float b)
private decimal <Min>m__2A(decimal a, decimal b)
private bool <Min`1>m__31(Nullable`1<int> a, Nullable`1<int> b)
private bool <Min`1>m__32(Nullable`1<long> a, Nullable`1<long> b)
private bool <Min`1>m__33(Nullable`1<float> a, Nullable`1<float> b)
private bool <Min`1>m__34(Nullable`1<double> a, Nullable`1<double> b)
private bool <Min`1>m__35(Nullable`1<decimal> a, Nullable`1<decimal> b)
private int <Sum>m__36(int a, int b)
private Nullable`1<int> <Sum>m__37(Nullable`1<int> total, Nullable`1<int> element)
private long <Sum>m__39(long a, long b)
private Nullable`1<long> <Sum>m__3A(Nullable`1<long> total, Nullable`1<long> element)
private double <Sum>m__3C(double a, double b)
private Nullable`1<double> <Sum>m__3D(Nullable`1<double> total, Nullable`1<double> element)
private float <Sum>m__3F(float a, float b)
private Nullable`1<float> <Sum>m__40(Nullable`1<float> total, Nullable`1<float> element)
private decimal <Sum>m__42(decimal a, decimal b)
private Nullable`1<decimal> <Sum>m__43(Nullable`1<decimal> total, Nullable`1<decimal> element)
private TSource <ToLookup`2>m__45(TSource element)
}
public System.Linq.Expressions.BinaryExpression : Expression {
private Expression left
private Expression right
private LambdaExpression conversion
private MethodInfo method
private bool lift_to_null
private bool is_lifted
public Expression Left
public Expression Right
public MethodInfo Method
public bool IsLifted
public bool IsLiftedToNull
public LambdaExpression Conversion
internal void .ctor(ExpressionType node_type, Type type, Expression left, Expression right)
internal void .ctor(ExpressionType node_type, Type type, Expression left, Expression right, MethodInfo method)
internal void .ctor(ExpressionType node_type, Type type, Expression left, Expression right, bool lift_to_null, bool is_lifted, MethodInfo method, LambdaExpression conversion)
public Expression get_Left()
public Expression get_Right()
public MethodInfo get_Method()
public bool get_IsLifted()
public bool get_IsLiftedToNull()
public LambdaExpression get_Conversion()
private void EmitArrayAccess(EmitContext ec)
private void EmitLogicalBinary(EmitContext ec)
private void EmitLogical(EmitContext ec)
private void EmitLiftedLogical(EmitContext ec)
private void EmitLogicalShortCircuit(EmitContext ec)
private MethodInfo GetFalseOperator()
private MethodInfo GetTrueOperator()
private void EmitUserDefinedLogicalShortCircuit(EmitContext ec)
private void EmitLiftedLogicalShortCircuit(EmitContext ec)
private void EmitCoalesce(EmitContext ec)
private void EmitConvertedCoalesce(EmitContext ec)
private bool IsInt32OrInt64(Type type)
private bool IsSingleOrDouble(Type type)
private void EmitBinaryOperator(EmitContext ec)
private bool IsLeftLiftedBinary()
private void EmitLeftLiftedToNullBinary(EmitContext ec)
private void EmitLiftedArithmeticBinary(EmitContext ec)
private void EmitLiftedToNullBinary(EmitContext ec)
private void EmitLiftedRelationalBinary(EmitContext ec)
private void EmitArithmeticBinary(EmitContext ec)
private void EmitNonLiftedBinary(EmitContext ec)
private void EmitRelationalBinary(EmitContext ec)
private void EmitLiftedUserDefinedOperator(EmitContext ec)
private void EmitLiftedToNullUserDefinedOperator(EmitContext ec)
private void EmitUserDefinedLiftedLogicalShortCircuit(EmitContext ec)
private void EmitUserDefinedOperator(EmitContext ec)
internal void Emit(EmitContext ec)
}
internal System.Linq.Expressions.CompilationContext : object {
private List`1<object> globals
private List`1<EmitContext> units
private Dictionary`2<LambdaExpression, List`1<ParameterExpression>> hoisted_map
public int AddGlobal(object global)
public Object[] GetGlobals()
private int AddItemToList(T item, IList`1<T> list)
public int AddCompilationUnit(LambdaExpression lambda)
public int AddCompilationUnit(EmitContext parent, LambdaExpression lambda)
private void DetectHoistedVariables(LambdaExpression lambda)
public List`1<ParameterExpression> GetHoistedLocals(LambdaExpression lambda)
public Object[] CreateHoistedLocals(int unit)
public Expression IsolateExpression(ExecutionScope scope, Object[] locals, Expression expression)
public Delegate CreateDelegate()
public Delegate CreateDelegate(int unit, ExecutionScope scope)
}
public System.Linq.Expressions.ConditionalExpression : Expression {
private Expression test
private Expression if_true
private Expression if_false
public Expression Test
public Expression IfTrue
public Expression IfFalse
internal void .ctor(Expression test, Expression if_true, Expression if_false)
public Expression get_Test()
public Expression get_IfTrue()
public Expression get_IfFalse()
internal void Emit(EmitContext ec)
}
public System.Linq.Expressions.ConstantExpression : Expression {
private object value
public object Value
internal void .ctor(object value, Type type)
public object get_Value()
internal void Emit(EmitContext ec)
private void EmitNullableConstant(EmitContext ec, Type type, object value)
private void EmitConstant(EmitContext ec, Type type, object value)
private void EmitIfNotNull(EmitContext ec, Action`1<EmitContext> emit)
}
public System.Linq.Expressions.ElementInit : object {
private MethodInfo add_method
private ReadOnlyCollection`1<Expression> arguments
public MethodInfo AddMethod
public ReadOnlyCollection`1<Expression> Arguments
internal void .ctor(MethodInfo add_method, ReadOnlyCollection`1<Expression> arguments)
public MethodInfo get_AddMethod()
public ReadOnlyCollection`1<Expression> get_Arguments()
public string ToString()
private void EmitPopIfNeeded(EmitContext ec)
internal void Emit(EmitContext ec, LocalBuilder local)
}
internal System.Linq.Expressions.EmitContext : object {
private CompilationContext context
private EmitContext parent
private LambdaExpression lambda
private DynamicMethod method
private LocalBuilder hoisted_store
private List`1<ParameterExpression> hoisted
public ILGenerator ig
public bool HasHoistedLocals
public LambdaExpression Lambda
public void .ctor(CompilationContext context, EmitContext parent, LambdaExpression lambda)
public bool get_HasHoistedLocals()
public LambdaExpression get_Lambda()
public void Emit()
private Type[] CreateParameterTypes(IList`1<ParameterExpression> parameters)
public bool IsLocalParameter(ParameterExpression parameter, Int32& position)
public Delegate CreateDelegate(ExecutionScope scope)
public void Emit(Expression expression)
public LocalBuilder EmitStored(Expression expression)
public void EmitLoadAddress(Expression expression)
public void EmitLoadSubject(Expression expression)
public void EmitLoadSubject(LocalBuilder local)
public void EmitLoadAddress(LocalBuilder local)
public void EmitLoad(LocalBuilder local)
public void EmitCall(LocalBuilder local, IList`1<Expression> arguments, MethodInfo method)
public void EmitCall(LocalBuilder local, MethodInfo method)
public void EmitCall(Expression expression, MethodInfo method)
public void EmitCall(Expression expression, IList`1<Expression> arguments, MethodInfo method)
private void EmitArguments(MethodInfo method, IList`1<Expression> arguments)
public void EmitCall(MethodInfo method)
public void EmitNullableHasValue(LocalBuilder local)
public void EmitNullableInitialize(LocalBuilder local)
public void EmitNullableGetValue(LocalBuilder local)
public void EmitNullableGetValueOrDefault(LocalBuilder local)
private void EmitCall(LocalBuilder local, string method_name)
public void EmitNullableNew(Type of)
public void EmitCollection(IEnumerable`1<T> collection)
public void EmitCollection(IEnumerable`1<ElementInit> initializers, LocalBuilder local)
public void EmitCollection(IEnumerable`1<MemberBinding> bindings, LocalBuilder local)
public void EmitIsInst(Expression expression, Type candidate)
public void EmitScope()
public void EmitReadGlobal(object global)
public void EmitLoadGlobals()
public void EmitReadGlobal(object global, Type type)
public void EmitLoadStrongBoxValue(Type type)
private int AddGlobal(object value, Type type)
public void EmitCreateDelegate(LambdaExpression lambda)
private void EmitStoreHoistedLocals()
private void EmitStoreHoistedLocal(int position, ParameterExpression parameter)
public void EmitLoadHoistedLocalsStore()
private void EmitCreateStrongBox(Type type)
private void EmitHoistedLocalsStore()
public void EmitLoadLocals()
public void EmitParentScope()
public void EmitIsolateExpression()
public int IndexOfHoistedLocal(ParameterExpression parameter)
public bool IsHoistedLocal(ParameterExpression parameter, Int32& level, Int32& position)
private int AddChildContext(LambdaExpression lambda)
private object CreateStrongBox(object value, Type type)
}
public System.Linq.Expressions.Expression : object {
internal BindingFlags PublicInstance
internal BindingFlags NonPublicInstance
internal BindingFlags PublicStatic
internal BindingFlags AllInstance
internal BindingFlags AllStatic
internal BindingFlags All
private ExpressionType node_type
private Type type
private Func`2<Expression, Type> <>f__am$cache2
private Func`2<ParameterExpression, Type> <>f__am$cache3
private Action`1<FieldInfo> <>f__am$cache4
private Action`1<PropertyInfo> <>f__am$cache5
private Func`2<FieldInfo, Type> <>f__am$cache6
private Func`2<PropertyInfo, Type> <>f__am$cache7
private Func`2<Type, bool> <>f__am$cache8
private Func`2<Type, bool> <>f__am$cache9
private Func`2<Type, bool> <>f__am$cacheA
private Func`2<Type, bool> <>f__am$cacheB
public ExpressionType NodeType
public Type Type
protected void .ctor(ExpressionType node_type, Type type)
public ExpressionType get_NodeType()
public Type get_Type()
public string ToString()
private MethodInfo GetUnaryOperator(string oper_name, Type declaring, Type param)
private MethodInfo GetUnaryOperator(string oper_name, Type declaring, Type param, Type ret)
internal MethodInfo GetTrueOperator(Type self)
internal MethodInfo GetFalseOperator(Type self)
private MethodInfo GetBooleanOperator(string op, Type self)
private bool IsAssignableToParameterType(Type type, ParameterInfo param)
private MethodInfo CheckUnaryMethod(MethodInfo method, Type param)
private MethodInfo UnaryCoreCheck(string oper_name, Expression expression, MethodInfo method, Func`2<Type, bool> validator)
private MethodInfo GetBinaryOperator(string oper_name, Type on_type, Expression left, Expression right)
private MethodInfo BinaryCoreCheck(string oper_name, Expression left, Expression right, MethodInfo method)
private MethodInfo BinaryBitwiseCoreCheck(string oper_name, Expression left, Expression right, MethodInfo method)
private BinaryExpression MakeSimpleBinary(ExpressionType et, Expression left, Expression right, MethodInfo method)
private bool IsAssignableToOperatorParameter(Expression expression, ParameterInfo parameter)
private UnaryExpression MakeSimpleUnary(ExpressionType et, Expression expression, MethodInfo method)
private BinaryExpression MakeBoolBinary(ExpressionType et, Expression left, Expression right, bool liftToNull, MethodInfo method)
public BinaryExpression Add(Expression left, Expression right)
public BinaryExpression Add(Expression left, Expression right, MethodInfo method)
public BinaryExpression AddChecked(Expression left, Expression right)
public BinaryExpression AddChecked(Expression left, Expression right, MethodInfo method)
public BinaryExpression Subtract(Expression left, Expression right)
public BinaryExpression Subtract(Expression left, Expression right, MethodInfo method)
public BinaryExpression SubtractChecked(Expression left, Expression right)
public BinaryExpression SubtractChecked(Expression left, Expression right, MethodInfo method)
public BinaryExpression Modulo(Expression left, Expression right)
public BinaryExpression Modulo(Expression left, Expression right, MethodInfo method)
public BinaryExpression Multiply(Expression left, Expression right)
public BinaryExpression Multiply(Expression left, Expression right, MethodInfo method)
public BinaryExpression MultiplyChecked(Expression left, Expression right)
public BinaryExpression MultiplyChecked(Expression left, Expression right, MethodInfo method)
public BinaryExpression Divide(Expression left, Expression right)
public BinaryExpression Divide(Expression left, Expression right, MethodInfo method)
public BinaryExpression Power(Expression left, Expression right)
public BinaryExpression Power(Expression left, Expression right, MethodInfo method)
public BinaryExpression And(Expression left, Expression right)
public BinaryExpression And(Expression left, Expression right, MethodInfo method)
public BinaryExpression Or(Expression left, Expression right)
public BinaryExpression Or(Expression left, Expression right, MethodInfo method)
public BinaryExpression ExclusiveOr(Expression left, Expression right)
public BinaryExpression ExclusiveOr(Expression left, Expression right, MethodInfo method)
public BinaryExpression LeftShift(Expression left, Expression right)
public BinaryExpression LeftShift(Expression left, Expression right, MethodInfo method)
public BinaryExpression RightShift(Expression left, Expression right)
public BinaryExpression RightShift(Expression left, Expression right, MethodInfo method)
public BinaryExpression AndAlso(Expression left, Expression right)
public BinaryExpression AndAlso(Expression left, Expression right, MethodInfo method)
private MethodInfo ConditionalBinaryCheck(string oper, Expression left, Expression right, MethodInfo method)
public BinaryExpression OrElse(Expression left, Expression right)
public BinaryExpression OrElse(Expression left, Expression right, MethodInfo method)
public BinaryExpression Equal(Expression left, Expression right)
public BinaryExpression Equal(Expression left, Expression right, bool liftToNull, MethodInfo method)
public BinaryExpression NotEqual(Expression left, Expression right)
public BinaryExpression NotEqual(Expression left, Expression right, bool liftToNull, MethodInfo method)
public BinaryExpression GreaterThan(Expression left, Expression right)
public BinaryExpression GreaterThan(Expression left, Expression right, bool liftToNull, MethodInfo method)
public BinaryExpression GreaterThanOrEqual(Expression left, Expression right)
public BinaryExpression GreaterThanOrEqual(Expression left, Expression right, bool liftToNull, MethodInfo method)
public BinaryExpression LessThan(Expression left, Expression right)
public BinaryExpression LessThan(Expression left, Expression right, bool liftToNull, MethodInfo method)
public BinaryExpression LessThanOrEqual(Expression left, Expression right)
public BinaryExpression LessThanOrEqual(Expression left, Expression right, bool liftToNull, MethodInfo method)
private void CheckArray(Expression array)
public BinaryExpression ArrayIndex(Expression array, Expression index)
public BinaryExpression Coalesce(Expression left, Expression right)
private BinaryExpression MakeCoalesce(Expression left, Expression right)
private BinaryExpression MakeConvertedCoalesce(Expression left, Expression right, LambdaExpression conversion)
public BinaryExpression Coalesce(Expression left, Expression right, LambdaExpression conversion)
public BinaryExpression MakeBinary(ExpressionType binaryType, Expression left, Expression right)
public BinaryExpression MakeBinary(ExpressionType binaryType, Expression left, Expression right, bool liftToNull, MethodInfo method)
public BinaryExpression MakeBinary(ExpressionType binaryType, Expression left, Expression right, bool liftToNull, MethodInfo method, LambdaExpression conversion)
public MethodCallExpression ArrayIndex(Expression array, Expression[] indexes)
public MethodCallExpression ArrayIndex(Expression array, IEnumerable`1<Expression> indexes)
public UnaryExpression ArrayLength(Expression array)
public MemberAssignment Bind(MemberInfo member, Expression expression)
public MemberAssignment Bind(MethodInfo propertyAccessor, Expression expression)
public MethodCallExpression Call(Expression instance, MethodInfo method)
public MethodCallExpression Call(MethodInfo method, Expression[] arguments)
public MethodCallExpression Call(Expression instance, MethodInfo method, Expression[] arguments)
public MethodCallExpression Call(Expression instance, MethodInfo method, IEnumerable`1<Expression> arguments)
private Type[] CollectTypes(IEnumerable`1<Expression> expressions)
private MethodInfo TryMakeGeneric(MethodInfo method, Type[] args)
public MethodCallExpression Call(Expression instance, string methodName, Type[] typeArguments, Expression[] arguments)
private bool MethodMatch(MethodInfo method, string name, Type[] parameterTypes, Type[] argumentTypes)
private bool IsExpressionOfParameter(Type type, Type ptype)
private MethodInfo TryGetMethod(Type type, string methodName, BindingFlags flags, Type[] parameterTypes, Type[] argumentTypes)
public MethodCallExpression Call(Type type, string methodName, Type[] typeArguments, Expression[] arguments)
public ConditionalExpression Condition(Expression test, Expression ifTrue, Expression ifFalse)
public ConstantExpression Constant(object value)
public ConstantExpression Constant(object value, Type type)
private bool IsConvertiblePrimitive(Type type)
internal bool IsPrimitiveConversion(Type type, Type target)
internal bool IsReferenceConversion(Type type, Type target)
public UnaryExpression Convert(Expression expression, Type type)
private MethodInfo GetUserConversionMethod(Type type, Type target)
public UnaryExpression Convert(Expression expression, Type type, MethodInfo method)
private bool IsConvertNodeLifted(MethodInfo method, Expression operand, Type target)
private bool ParameterMatch(MethodInfo method, Type type)
private bool ReturnTypeMatch(MethodInfo method, Type type)
public UnaryExpression ConvertChecked(Expression expression, Type type)
public UnaryExpression ConvertChecked(Expression expression, Type type, MethodInfo method)
public ElementInit ElementInit(MethodInfo addMethod, Expression[] arguments)
public ElementInit ElementInit(MethodInfo addMethod, IEnumerable`1<Expression> arguments)
public MemberExpression Field(Expression expression, FieldInfo field)
public MemberExpression Field(Expression expression, string fieldName)
public Type GetActionType(Type[] typeArgs)
public Type GetFuncType(Type[] typeArgs)
public InvocationExpression Invoke(Expression expression, Expression[] arguments)
private Type GetInvokableType(Type t)
private Type GetGenericType(Type t, Type def)
public InvocationExpression Invoke(Expression expression, IEnumerable`1<Expression> arguments)
private bool CanAssign(Type target, Type source)
private Expression CheckLambda(Type delegateType, Expression body, ReadOnlyCollection`1<ParameterExpression> parameters)
public Expression`1<TDelegate> Lambda(Expression body, ParameterExpression[] parameters)
public Expression`1<TDelegate> Lambda(Expression body, IEnumerable`1<ParameterExpression> parameters)
public LambdaExpression Lambda(Expression body, ParameterExpression[] parameters)
private Type GetDelegateType(Type return_type, ParameterExpression[] parameters)
public LambdaExpression Lambda(Type delegateType, Expression body, ParameterExpression[] parameters)
private LambdaExpression CreateExpressionOf(Type type, Expression body, ReadOnlyCollection`1<ParameterExpression> parameters)
public LambdaExpression Lambda(Type delegateType, Expression body, IEnumerable`1<ParameterExpression> parameters)
public MemberListBinding ListBind(MemberInfo member, ElementInit[] initializers)
private void CheckIsAssignableToIEnumerable(Type t)
public MemberListBinding ListBind(MemberInfo member, IEnumerable`1<ElementInit> initializers)
public MemberListBinding ListBind(MethodInfo propertyAccessor, ElementInit[] initializers)
private void CheckForNull(ReadOnlyCollection`1<T> collection, string name)
public MemberListBinding ListBind(MethodInfo propertyAccessor, IEnumerable`1<ElementInit> initializers)
public ListInitExpression ListInit(NewExpression newExpression, ElementInit[] initializers)
public ListInitExpression ListInit(NewExpression newExpression, IEnumerable`1<ElementInit> initializers)
public ListInitExpression ListInit(NewExpression newExpression, Expression[] initializers)
public ListInitExpression ListInit(NewExpression newExpression, IEnumerable`1<Expression> initializers)
private ReadOnlyCollection`1<ElementInit> CreateInitializers(MethodInfo add_method, ReadOnlyCollection`1<Expression> initializers)
private MethodInfo GetAddMethod(Type type, Type arg)
public ListInitExpression ListInit(NewExpression newExpression, MethodInfo addMethod, Expression[] initializers)
private ReadOnlyCollection`1<T> CheckListInit(NewExpression newExpression, IEnumerable`1<T> initializers)
public ListInitExpression ListInit(NewExpression newExpression, MethodInfo addMethod, IEnumerable`1<Expression> initializers)
public MemberExpression MakeMemberAccess(Expression expression, MemberInfo member)
public UnaryExpression MakeUnary(ExpressionType unaryType, Expression operand, Type type)
public UnaryExpression MakeUnary(ExpressionType unaryType, Expression operand, Type type, MethodInfo method)
public MemberMemberBinding MemberBind(MemberInfo member, MemberBinding[] bindings)
public MemberMemberBinding MemberBind(MemberInfo member, IEnumerable`1<MemberBinding> bindings)
public MemberMemberBinding MemberBind(MethodInfo propertyAccessor, MemberBinding[] bindings)
public MemberMemberBinding MemberBind(MethodInfo propertyAccessor, IEnumerable`1<MemberBinding> bindings)
private ReadOnlyCollection`1<MemberBinding> CheckMemberBindings(Type type, IEnumerable`1<MemberBinding> bindings)
public MemberInitExpression MemberInit(NewExpression newExpression, MemberBinding[] bindings)
public MemberInitExpression MemberInit(NewExpression newExpression, IEnumerable`1<MemberBinding> bindings)
public UnaryExpression Negate(Expression expression)
public UnaryExpression Negate(Expression expression, MethodInfo method)
public UnaryExpression NegateChecked(Expression expression)
public UnaryExpression NegateChecked(Expression expression, MethodInfo method)
public NewExpression New(ConstructorInfo constructor)
public NewExpression New(Type type)
public NewExpression New(ConstructorInfo constructor, Expression[] arguments)
public NewExpression New(ConstructorInfo constructor, IEnumerable`1<Expression> arguments)
private IList`1<Expression> CreateArgumentList(IEnumerable`1<Expression> arguments)
private void CheckNonGenericMethod(MethodBase method)
private ReadOnlyCollection`1<Expression> CheckMethodArguments(MethodBase method, IEnumerable`1<Expression> args)
public NewExpression New(ConstructorInfo constructor, IEnumerable`1<Expression> arguments, MemberInfo[] members)
public NewExpression New(ConstructorInfo constructor, IEnumerable`1<Expression> arguments, IEnumerable`1<MemberInfo> members)
public NewArrayExpression NewArrayBounds(Type type, Expression[] bounds)
public NewArrayExpression NewArrayBounds(Type type, IEnumerable`1<Expression> bounds)
public NewArrayExpression NewArrayInit(Type type, Expression[] initializers)
public NewArrayExpression NewArrayInit(Type type, IEnumerable`1<Expression> initializers)
public UnaryExpression Not(Expression expression)
public UnaryExpression Not(Expression expression, MethodInfo method)
private void CheckNotVoid(Type type)
public ParameterExpression Parameter(Type type, string name)
public MemberExpression Property(Expression expression, MethodInfo propertyAccessor)
private PropertyInfo GetAssociatedProperty(MethodInfo method)
public MemberExpression Property(Expression expression, PropertyInfo property)
public MemberExpression Property(Expression expression, string propertyName)
public MemberExpression PropertyOrField(Expression expression, string propertyOrFieldName)
public UnaryExpression Quote(Expression expression)
public UnaryExpression TypeAs(Expression expression, Type type)
public TypeBinaryExpression TypeIs(Expression expression, Type type)
public UnaryExpression UnaryPlus(Expression expression)
public UnaryExpression UnaryPlus(Expression expression, MethodInfo method)
private bool IsInt(Type t)
private bool IsIntOrBool(Type t)
private bool IsNumber(Type t)
private bool IsSignedNumber(Type t)
internal bool IsUnsigned(Type t)
internal void Emit(EmitContext ec)
private Type <CollectTypes>m__0(Expression arg)
private Type <GetDelegateType>m__2(ParameterExpression p)
private void <ListBind>m__3(FieldInfo field)
private void <ListBind>m__4(PropertyInfo prop)
private Type <MemberBind>m__6(FieldInfo field)
private Type <MemberBind>m__7(PropertyInfo prop)
private bool <Negate>m__8(Type type)
private bool <NegateChecked>m__9(Type type)
private bool <Not>m__A(Type type)
private bool <UnaryPlus>m__B(Type type)
}
public System.Linq.Expressions.Expression`1 : LambdaExpression {
internal void .ctor(Expression body, ReadOnlyCollection`1<ParameterExpression> parameters)
public TDelegate Compile()
}
internal System.Linq.Expressions.ExpressionPrinter : ExpressionVisitor {
private string ListSeparator
private StringBuilder builder
private void .ctor(StringBuilder builder)
public string ToString(Expression expression)
public string ToString(ElementInit init)
public string ToString(MemberBinding binding)
private void Print(string str)
private void Print(object obj)
private void Print(string str, Object[] objs)
protected void VisitElementInitializer(ElementInit initializer)
protected void VisitUnary(UnaryExpression unary)
private string OperatorToString(BinaryExpression binary)
private bool IsBoolean(Expression expression)
private void PrintArrayIndex(BinaryExpression index)
protected void VisitBinary(BinaryExpression binary)
protected void VisitTypeIs(TypeBinaryExpression type)
protected void VisitConstant(ConstantExpression constant)
private bool HasStringRepresentation(object obj)
protected void VisitConditional(ConditionalExpression conditional)
protected void VisitParameter(ParameterExpression parameter)
protected void VisitMemberAccess(MemberExpression access)
protected void VisitMethodCall(MethodCallExpression call)
protected void VisitMemberAssignment(MemberAssignment assignment)
protected void VisitMemberMemberBinding(MemberMemberBinding binding)
protected void VisitMemberListBinding(MemberListBinding binding)
protected void VisitList(ReadOnlyCollection`1<T> list, Action`1<T> visitor)
protected void VisitLambda(LambdaExpression lambda)
protected void VisitNew(NewExpression nex)
protected void VisitMemberInit(MemberInitExpression init)
protected void VisitListInit(ListInitExpression init)
protected void VisitNewArray(NewArrayExpression newArray)
protected void VisitInvocation(InvocationExpression invocation)
}
internal System.Linq.Expressions.ExpressionTransformer : object {
public Expression Transform(Expression expression)
protected Expression Visit(Expression exp)
protected MemberBinding VisitBinding(MemberBinding binding)
protected ElementInit VisitElementInitializer(ElementInit initializer)
protected Expression VisitUnary(UnaryExpression u)
protected Expression VisitBinary(BinaryExpression b)
protected Expression VisitTypeIs(TypeBinaryExpression b)
protected Expression VisitConstant(ConstantExpression c)
protected Expression VisitConditional(ConditionalExpression c)
protected Expression VisitParameter(ParameterExpression p)
protected Expression VisitMemberAccess(MemberExpression m)
protected Expression VisitMethodCall(MethodCallExpression m)
protected ReadOnlyCollection`1<Expression> VisitExpressionList(ReadOnlyCollection`1<Expression> original)
protected MemberAssignment VisitMemberAssignment(MemberAssignment assignment)
protected MemberMemberBinding VisitMemberMemberBinding(MemberMemberBinding binding)
protected MemberListBinding VisitMemberListBinding(MemberListBinding binding)
protected IEnumerable`1<MemberBinding> VisitBindingList(ReadOnlyCollection`1<MemberBinding> original)
protected IEnumerable`1<ElementInit> VisitElementInitializerList(ReadOnlyCollection`1<ElementInit> original)
private IList`1<TElement> VisitList(ReadOnlyCollection`1<TElement> original, Func`2<TElement, TElement> visit)
protected Expression VisitLambda(LambdaExpression lambda)
protected NewExpression VisitNew(NewExpression nex)
protected Expression VisitMemberInit(MemberInitExpression init)
protected Expression VisitListInit(ListInitExpression init)
protected Expression VisitNewArray(NewArrayExpression na)
protected Expression VisitInvocation(InvocationExpression iv)
}
public System.Linq.Expressions.ExpressionType : Enum {
public int value__
public ExpressionType Add
public ExpressionType AddChecked
public ExpressionType And
public ExpressionType AndAlso
public ExpressionType ArrayLength
public ExpressionType ArrayIndex
public ExpressionType Call
public ExpressionType Coalesce
public ExpressionType Conditional
public ExpressionType Constant
public ExpressionType Convert
public ExpressionType ConvertChecked
public ExpressionType Divide
public ExpressionType Equal
public ExpressionType ExclusiveOr
public ExpressionType GreaterThan
public ExpressionType GreaterThanOrEqual
public ExpressionType Invoke
public ExpressionType Lambda
public ExpressionType LeftShift
public ExpressionType LessThan
public ExpressionType LessThanOrEqual
public ExpressionType ListInit
public ExpressionType MemberAccess
public ExpressionType MemberInit
public ExpressionType Modulo
public ExpressionType Multiply
public ExpressionType MultiplyChecked
public ExpressionType Negate
public ExpressionType UnaryPlus
public ExpressionType NegateChecked
public ExpressionType New
public ExpressionType NewArrayInit
public ExpressionType NewArrayBounds
public ExpressionType Not
public ExpressionType NotEqual
public ExpressionType Or
public ExpressionType OrElse
public ExpressionType Parameter
public ExpressionType Power
public ExpressionType Quote
public ExpressionType RightShift
public ExpressionType Subtract
public ExpressionType SubtractChecked
public ExpressionType TypeAs
public ExpressionType TypeIs
}
internal System.Linq.Expressions.ExpressionVisitor : object {
protected void Visit(Expression expression)
protected void VisitBinding(MemberBinding binding)
protected void VisitElementInitializer(ElementInit initializer)
protected void VisitUnary(UnaryExpression unary)
protected void VisitBinary(BinaryExpression binary)
protected void VisitTypeIs(TypeBinaryExpression type)
protected void VisitConstant(ConstantExpression constant)
protected void VisitConditional(ConditionalExpression conditional)
protected void VisitParameter(ParameterExpression parameter)
protected void VisitMemberAccess(MemberExpression member)
protected void VisitMethodCall(MethodCallExpression methodCall)
protected void VisitList(ReadOnlyCollection`1<T> list, Action`1<T> visitor)
protected void VisitExpressionList(ReadOnlyCollection`1<Expression> list)
protected void VisitMemberAssignment(MemberAssignment assignment)
protected void VisitMemberMemberBinding(MemberMemberBinding binding)
protected void VisitMemberListBinding(MemberListBinding binding)
protected void VisitBindingList(ReadOnlyCollection`1<MemberBinding> list)
protected void VisitElementInitializerList(ReadOnlyCollection`1<ElementInit> list)
protected void VisitLambda(LambdaExpression lambda)
protected void VisitNew(NewExpression nex)
protected void VisitMemberInit(MemberInitExpression init)
protected void VisitListInit(ListInitExpression init)
protected void VisitNewArray(NewArrayExpression newArray)
protected void VisitInvocation(InvocationExpression invocation)
}
internal System.Linq.Expressions.Extensions : object {
public bool IsGenericInstanceOf(Type self, Type type)
public bool IsNullable(Type self)
public bool IsExpression(Type self)
public bool IsGenericImplementationOf(Type self, Type type)
public bool IsAssignableTo(Type self, Type type)
public Type GetFirstGenericArgument(Type self)
public Type MakeGenericTypeFrom(Type self, Type type)
public Type MakeNullableType(Type self)
public Type GetNotNullableType(Type self)
public MethodInfo GetInvokeMethod(Type self)
public MethodInfo MakeGenericMethodFrom(MethodInfo self, MethodInfo method)
public Type[] GetParameterTypes(MethodBase self)
private bool ArrayTypeIsAssignableTo(Type type, Type candidate)
public void OnFieldOrProperty(MemberInfo self, Action`1<FieldInfo> onfield, Action`1<PropertyInfo> onprop)
public T OnFieldOrProperty(MemberInfo self, Func`2<FieldInfo, T> onfield, Func`2<PropertyInfo, T> onprop)
public Type MakeStrongBoxType(Type self)
}
public System.Linq.Expressions.InvocationExpression : Expression {
private Expression expression
private ReadOnlyCollection`1<Expression> arguments
public Expression Expression
public ReadOnlyCollection`1<Expression> Arguments
internal void .ctor(Expression expression, Type type, ReadOnlyCollection`1<Expression> arguments)
public Expression get_Expression()
public ReadOnlyCollection`1<Expression> get_Arguments()
internal void Emit(EmitContext ec)
}
public System.Linq.Expressions.LambdaExpression : Expression {
private Expression body
private ReadOnlyCollection`1<ParameterExpression> parameters
public Expression Body
public ReadOnlyCollection`1<ParameterExpression> Parameters
internal void .ctor(Type delegateType, Expression body, ReadOnlyCollection`1<ParameterExpression> parameters)
public Expression get_Body()
public ReadOnlyCollection`1<ParameterExpression> get_Parameters()
private void EmitPopIfNeeded(EmitContext ec)
internal void Emit(EmitContext ec)
internal void EmitBody(EmitContext ec)
internal Type GetReturnType()
public Delegate Compile()
}
public System.Linq.Expressions.ListInitExpression : Expression {
private NewExpression new_expression
private ReadOnlyCollection`1<ElementInit> initializers
public NewExpression NewExpression
public ReadOnlyCollection`1<ElementInit> Initializers
internal void .ctor(NewExpression new_expression, ReadOnlyCollection`1<ElementInit> initializers)
public NewExpression get_NewExpression()
public ReadOnlyCollection`1<ElementInit> get_Initializers()
internal void Emit(EmitContext ec)
}
public System.Linq.Expressions.MemberAssignment : MemberBinding {
private Expression expression
public Expression Expression
internal void .ctor(MemberInfo member, Expression expression)
public Expression get_Expression()
internal void Emit(EmitContext ec, LocalBuilder local)
private void EmitFieldAssignment(EmitContext ec, FieldInfo field, LocalBuilder local)
private void EmitPropertyAssignment(EmitContext ec, PropertyInfo property, LocalBuilder local)
}
public System.Linq.Expressions.MemberBinding : object {
private MemberBindingType binding_type
private MemberInfo member
public MemberBindingType BindingType
public MemberInfo Member
protected void .ctor(MemberBindingType binding_type, MemberInfo member)
public MemberBindingType get_BindingType()
public MemberInfo get_Member()
public string ToString()
internal void Emit(EmitContext ec, LocalBuilder local)
internal LocalBuilder EmitLoadMember(EmitContext ec, LocalBuilder local)
private LocalBuilder EmitLoadProperty(EmitContext ec, PropertyInfo property)
private LocalBuilder EmitLoadField(EmitContext ec, FieldInfo field)
}
public System.Linq.Expressions.MemberBindingType : Enum {
public int value__
public MemberBindingType Assignment
public MemberBindingType MemberBinding
public MemberBindingType ListBinding
}
public System.Linq.Expressions.MemberExpression : Expression {
private Expression expression
private MemberInfo member
public Expression Expression
public MemberInfo Member
internal void .ctor(Expression expression, MemberInfo member, Type type)
public Expression get_Expression()
public MemberInfo get_Member()
internal void Emit(EmitContext ec)
private void EmitPropertyAccess(EmitContext ec, PropertyInfo property)
private void EmitFieldAccess(EmitContext ec, FieldInfo field)
}
public System.Linq.Expressions.MemberInitExpression : Expression {
private NewExpression new_expression
private ReadOnlyCollection`1<MemberBinding> bindings
public NewExpression NewExpression
public ReadOnlyCollection`1<MemberBinding> Bindings
internal void .ctor(NewExpression new_expression, ReadOnlyCollection`1<MemberBinding> bindings)
public NewExpression get_NewExpression()
public ReadOnlyCollection`1<MemberBinding> get_Bindings()
internal void Emit(EmitContext ec)
}
public System.Linq.Expressions.MemberListBinding : MemberBinding {
private ReadOnlyCollection`1<ElementInit> initializers
public ReadOnlyCollection`1<ElementInit> Initializers
internal void .ctor(MemberInfo member, ReadOnlyCollection`1<ElementInit> initializers)
public ReadOnlyCollection`1<ElementInit> get_Initializers()
internal void Emit(EmitContext ec, LocalBuilder local)
}
public System.Linq.Expressions.MemberMemberBinding : MemberBinding {
private ReadOnlyCollection`1<MemberBinding> bindings
public ReadOnlyCollection`1<MemberBinding> Bindings
internal void .ctor(MemberInfo member, ReadOnlyCollection`1<MemberBinding> bindings)
public ReadOnlyCollection`1<MemberBinding> get_Bindings()
internal void Emit(EmitContext ec, LocalBuilder local)
}
public System.Linq.Expressions.MethodCallExpression : Expression {
private Expression obj
private MethodInfo method
private ReadOnlyCollection`1<Expression> arguments
public Expression Object
public MethodInfo Method
public ReadOnlyCollection`1<Expression> Arguments
internal void .ctor(MethodInfo method, ReadOnlyCollection`1<Expression> arguments)
internal void .ctor(Expression obj, MethodInfo method, ReadOnlyCollection`1<Expression> arguments)
public Expression get_Object()
public MethodInfo get_Method()
public ReadOnlyCollection`1<Expression> get_Arguments()
internal void Emit(EmitContext ec)
}
public System.Linq.Expressions.NewArrayExpression : Expression {
private ReadOnlyCollection`1<Expression> expressions
public ReadOnlyCollection`1<Expression> Expressions
internal void .ctor(ExpressionType et, Type type, ReadOnlyCollection`1<Expression> expressions)
public ReadOnlyCollection`1<Expression> get_Expressions()
private void EmitNewArrayInit(EmitContext ec, Type type)
private void EmitNewArrayBounds(EmitContext ec, Type type)
private ConstructorInfo GetArrayConstructor(Type type, int rank)
private Type[] CreateTypeParameters(int rank)
private Type CreateArray(Type type, int rank)
internal void Emit(EmitContext ec)
}
public System.Linq.Expressions.NewExpression : Expression {
private ConstructorInfo constructor
private ReadOnlyCollection`1<Expression> arguments
private ReadOnlyCollection`1<MemberInfo> members
public ConstructorInfo Constructor
public ReadOnlyCollection`1<Expression> Arguments
public ReadOnlyCollection`1<MemberInfo> Members
internal void .ctor(Type type, ReadOnlyCollection`1<Expression> arguments)
internal void .ctor(ConstructorInfo constructor, ReadOnlyCollection`1<Expression> arguments, ReadOnlyCollection`1<MemberInfo> members)
public ConstructorInfo get_Constructor()
public ReadOnlyCollection`1<Expression> get_Arguments()
public ReadOnlyCollection`1<MemberInfo> get_Members()
internal void Emit(EmitContext ec)
private ConstructorInfo GetDefaultConstructor(Type type)
}
public System.Linq.Expressions.ParameterExpression : Expression {
private string name
public string Name
internal void .ctor(Type type, string name)
public string get_Name()
private void EmitLocalParameter(EmitContext ec, int position)
private void EmitHoistedLocal(EmitContext ec, int level, int position)
internal void Emit(EmitContext ec)
}
public System.Linq.Expressions.TypeBinaryExpression : Expression {
private Expression expression
private Type type_operand
public Expression Expression
public Type TypeOperand
internal void .ctor(ExpressionType node_type, Expression expression, Type type_operand, Type type)
public Expression get_Expression()
public Type get_TypeOperand()
internal void Emit(EmitContext ec)
}
public System.Linq.Expressions.UnaryExpression : Expression {
private Expression operand
private MethodInfo method
private bool is_lifted
public Expression Operand
public MethodInfo Method
public bool IsLifted
public bool IsLiftedToNull
internal void .ctor(ExpressionType node_type, Expression operand, Type type)
internal void .ctor(ExpressionType node_type, Expression operand, Type type, MethodInfo method, bool is_lifted)
public Expression get_Operand()
public MethodInfo get_Method()
public bool get_IsLifted()
public bool get_IsLiftedToNull()
private void EmitArrayLength(EmitContext ec)
private void EmitTypeAs(EmitContext ec)
private void EmitLiftedUnary(EmitContext ec)
private void EmitUnaryOperator(EmitContext ec)
private void EmitConvert(EmitContext ec)
private void EmitConvertFromNullableToNullable(EmitContext ec)
private void EmitConvertToNullable(EmitContext ec)
private void EmitConvertFromNullable(EmitContext ec)
private bool IsBoxing()
private void EmitBox(EmitContext ec)
private bool IsUnBoxing()
private void EmitUnbox(EmitContext ec)
private void EmitCast(EmitContext ec)
private void EmitPrimitiveConversion(EmitContext ec, bool is_unsigned, OpCode signed, OpCode unsigned, OpCode signed_checked, OpCode unsigned_checked)
private void EmitPrimitiveConversion(EmitContext ec)
private void EmitPrimitiveConversion(EmitContext ec, Type from, Type to)
private void EmitArithmeticUnary(EmitContext ec)
private void EmitUserDefinedLiftedToNullOperator(EmitContext ec)
private void EmitUserDefinedLiftedOperator(EmitContext ec)
private void EmitUserDefinedOperator(EmitContext ec)
private void EmitQuote(EmitContext ec)
internal void Emit(EmitContext ec)
}
internal System.Linq.Grouping`2 : object {
private K key
private IEnumerable`1<T> group
public K Key
public void .ctor(K key, IEnumerable`1<T> group)
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
public K get_Key()
public void set_Key(K value)
public IEnumerator`1<T> GetEnumerator()
}
public System.Linq.IGrouping`2 {
public TKey Key
public TKey get_Key()
}
public System.Linq.ILookup`2 {
public int Count
public IEnumerable`1<TElement> Item
public int get_Count()
public IEnumerable`1<TElement> get_Item(TKey key)
public bool Contains(TKey key)
}
public System.Linq.IOrderedEnumerable`1 {
public IOrderedEnumerable`1<TElement> CreateOrderedEnumerable(Func`2<TElement, TKey> selector, IComparer`1<TKey> comparer, bool descending)
}
public System.Linq.IQueryable {
public Type ElementType
public Expression Expression
public IQueryProvider Provider
public Type get_ElementType()
public Expression get_Expression()
public IQueryProvider get_Provider()
}
internal System.Linq.IQueryableEnumerable {
public IEnumerable GetEnumerable()
}
public System.Linq.IQueryProvider {
public IQueryable CreateQuery(Expression expression)
public object Execute(Expression expression)
public IQueryable`1<TElement> CreateQuery(Expression expression)
public TResult Execute(Expression expression)
}
public System.Linq.Lookup`2 : object {
private IGrouping`2<TKey, TElement> nullGrouping
private Dictionary`2<TKey, IGrouping`2<TKey, TElement>> groups
public int Count
public IEnumerable`1<TElement> Item
internal void .ctor(Dictionary`2<TKey, List`1<TElement>> lookup, IEnumerable`1<TElement> nullKeyElements)
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
public int get_Count()
public IEnumerable`1<TElement> get_Item(TKey key)
public IEnumerable`1<TResult> ApplyResultSelector(Func`3<TKey, IEnumerable`1<TElement>, TResult> selector)
public bool Contains(TKey key)
public IEnumerator`1<IGrouping`2<TKey, TElement>> GetEnumerator()
}
internal System.Linq.OrderedEnumerable`1 : object {
private IEnumerable`1<TElement> source
protected void .ctor(IEnumerable`1<TElement> source)
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
public IEnumerator`1<TElement> GetEnumerator()
public SortContext`1<TElement> CreateContext(SortContext`1<TElement> current)
protected IEnumerable`1<TElement> Sort(IEnumerable`1<TElement> source)
public IOrderedEnumerable`1<TElement> CreateOrderedEnumerable(Func`2<TElement, TKey> selector, IComparer`1<TKey> comparer, bool descending)
}
internal System.Linq.OrderedSequence`2 : OrderedEnumerable`1<TElement> {
private OrderedEnumerable`1<TElement> parent
private Func`2<TElement, TKey> selector
private IComparer`1<TKey> comparer
private SortDirection direction
internal void .ctor(IEnumerable`1<TElement> source, Func`2<TElement, TKey> key_selector, IComparer`1<TKey> comparer, SortDirection direction)
internal void .ctor(OrderedEnumerable`1<TElement> parent, IEnumerable`1<TElement> source, Func`2<TElement, TKey> keySelector, IComparer`1<TKey> comparer, SortDirection direction)
public SortContext`1<TElement> CreateContext(SortContext`1<TElement> current)
protected IEnumerable`1<TElement> Sort(IEnumerable`1<TElement> source)
}
public System.Linq.Queryable : object {
private MethodInfo MakeGeneric(MethodBase method, Type[] parameters)
private Expression StaticCall(MethodInfo method, Expression[] expressions)
private TRet Execute(IQueryable`1<TSource> source, MethodBase current)
public TSource Aggregate(IQueryable`1<TSource> source, Expression`1<Func`3<TSource, TSource, TSource>> func)
public TAccumulate Aggregate(IQueryable`1<TSource> source, TAccumulate seed, Expression`1<Func`3<TAccumulate, TSource, TAccumulate>> func)
public TResult Aggregate(IQueryable`1<TSource> source, TAccumulate seed, Expression`1<Func`3<TAccumulate, TSource, TAccumulate>> func, Expression`1<Func`2<TAccumulate, TResult>> selector)
public bool All(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, bool>> predicate)
public bool Any(IQueryable`1<TSource> source)
public bool Any(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, bool>> predicate)
public IQueryable`1<TElement> AsQueryable(IEnumerable`1<TElement> source)
public IQueryable AsQueryable(IEnumerable source)
public double Average(IQueryable`1<int> source)
public Nullable`1<double> Average(IQueryable`1<Nullable`1<int>> source)
public double Average(IQueryable`1<long> source)
public Nullable`1<double> Average(IQueryable`1<Nullable`1<long>> source)
public float Average(IQueryable`1<float> source)
public Nullable`1<float> Average(IQueryable`1<Nullable`1<float>> source)
public double Average(IQueryable`1<double> source)
public Nullable`1<double> Average(IQueryable`1<Nullable`1<double>> source)
public decimal Average(IQueryable`1<decimal> source)
public Nullable`1<decimal> Average(IQueryable`1<Nullable`1<decimal>> source)
public double Average(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, int>> selector)
public Nullable`1<double> Average(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, Nullable`1<int>>> selector)
public double Average(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, long>> selector)
public Nullable`1<double> Average(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, Nullable`1<long>>> selector)
public float Average(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, float>> selector)
public Nullable`1<float> Average(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, Nullable`1<float>>> selector)
public double Average(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, double>> selector)
public Nullable`1<double> Average(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, Nullable`1<double>>> selector)
public decimal Average(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, decimal>> selector)
public Nullable`1<decimal> Average(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, Nullable`1<decimal>>> selector)
public IQueryable`1<TResult> Cast(IQueryable source)
public IQueryable`1<TSource> Concat(IQueryable`1<TSource> source1, IEnumerable`1<TSource> source2)
public bool Contains(IQueryable`1<TSource> source, TSource item)
public bool Contains(IQueryable`1<TSource> source, TSource item, IEqualityComparer`1<TSource> comparer)
public int Count(IQueryable`1<TSource> source)
public int Count(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, bool>> predicate)
public IQueryable`1<TSource> DefaultIfEmpty(IQueryable`1<TSource> source)
public IQueryable`1<TSource> DefaultIfEmpty(IQueryable`1<TSource> source, TSource defaultValue)
public IQueryable`1<TSource> Distinct(IQueryable`1<TSource> source)
public IQueryable`1<TSource> Distinct(IQueryable`1<TSource> source, IEqualityComparer`1<TSource> comparer)
public TSource ElementAt(IQueryable`1<TSource> source, int index)
public TSource ElementAtOrDefault(IQueryable`1<TSource> source, int index)
public IQueryable`1<TSource> Except(IQueryable`1<TSource> source1, IEnumerable`1<TSource> source2)
public IQueryable`1<TSource> Except(IQueryable`1<TSource> source1, IEnumerable`1<TSource> source2, IEqualityComparer`1<TSource> comparer)
public TSource First(IQueryable`1<TSource> source)
public TSource First(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, bool>> predicate)
public TSource FirstOrDefault(IQueryable`1<TSource> source)
public TSource FirstOrDefault(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, bool>> predicate)
public IQueryable`1<IGrouping`2<TKey, TSource>> GroupBy(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, TKey>> keySelector)
public IQueryable`1<IGrouping`2<TKey, TSource>> GroupBy(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, TKey>> keySelector, IEqualityComparer`1<TKey> comparer)
public IQueryable`1<IGrouping`2<TKey, TElement>> GroupBy(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, TKey>> keySelector, Expression`1<Func`2<TSource, TElement>> elementSelector)
public IQueryable`1<TResult> GroupBy(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, TKey>> keySelector, Expression`1<Func`3<TKey, IEnumerable`1<TSource>, TResult>> resultSelector)
public IQueryable`1<IGrouping`2<TKey, TElement>> GroupBy(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, TKey>> keySelector, Expression`1<Func`2<TSource, TElement>> elementSelector, IEqualityComparer`1<TKey> comparer)
public IQueryable`1<TResult> GroupBy(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, TKey>> keySelector, Expression`1<Func`2<TSource, TElement>> elementSelector, Expression`1<Func`3<TKey, IEnumerable`1<TElement>, TResult>> resultSelector)
public IQueryable`1<TResult> GroupBy(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, TKey>> keySelector, Expression`1<Func`3<TKey, IEnumerable`1<TSource>, TResult>> resultSelector, IEqualityComparer`1<TKey> comparer)
public IQueryable`1<TResult> GroupBy(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, TKey>> keySelector, Expression`1<Func`2<TSource, TElement>> elementSelector, Expression`1<Func`3<TKey, IEnumerable`1<TElement>, TResult>> resultSelector, IEqualityComparer`1<TKey> comparer)
public IQueryable`1<TResult> GroupJoin(IQueryable`1<TOuter> outer, IEnumerable`1<TInner> inner, Expression`1<Func`2<TOuter, TKey>> outerKeySelector, Expression`1<Func`2<TInner, TKey>> innerKeySelector, Expression`1<Func`3<TOuter, IEnumerable`1<TInner>, TResult>> resultSelector)
public IQueryable`1<TResult> GroupJoin(IQueryable`1<TOuter> outer, IEnumerable`1<TInner> inner, Expression`1<Func`2<TOuter, TKey>> outerKeySelector, Expression`1<Func`2<TInner, TKey>> innerKeySelector, Expression`1<Func`3<TOuter, IEnumerable`1<TInner>, TResult>> resultSelector, IEqualityComparer`1<TKey> comparer)
public IQueryable`1<TSource> Intersect(IQueryable`1<TSource> source1, IEnumerable`1<TSource> source2)
public IQueryable`1<TSource> Intersect(IQueryable`1<TSource> source1, IEnumerable`1<TSource> source2, IEqualityComparer`1<TSource> comparer)
public IQueryable`1<TResult> Join(IQueryable`1<TOuter> outer, IEnumerable`1<TInner> inner, Expression`1<Func`2<TOuter, TKey>> outerKeySelector, Expression`1<Func`2<TInner, TKey>> innerKeySelector, Expression`1<Func`3<TOuter, TInner, TResult>> resultSelector)
public IQueryable`1<TResult> Join(IQueryable`1<TOuter> outer, IEnumerable`1<TInner> inner, Expression`1<Func`2<TOuter, TKey>> outerKeySelector, Expression`1<Func`2<TInner, TKey>> innerKeySelector, Expression`1<Func`3<TOuter, TInner, TResult>> resultSelector, IEqualityComparer`1<TKey> comparer)
public TSource Last(IQueryable`1<TSource> source)
public TSource Last(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, bool>> predicate)
public TSource LastOrDefault(IQueryable`1<TSource> source)
public TSource LastOrDefault(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, bool>> predicate)
public long LongCount(IQueryable`1<TSource> source)
public long LongCount(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, bool>> predicate)
public TSource Max(IQueryable`1<TSource> source)
public TResult Max(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, TResult>> selector)
public TSource Min(IQueryable`1<TSource> source)
public TResult Min(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, TResult>> selector)
public IQueryable`1<TResult> OfType(IQueryable source)
public IOrderedQueryable`1<TSource> OrderBy(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, TKey>> keySelector)
public IOrderedQueryable`1<TSource> OrderBy(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, TKey>> keySelector, IComparer`1<TKey> comparer)
public IOrderedQueryable`1<TSource> OrderByDescending(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, TKey>> keySelector)
public IOrderedQueryable`1<TSource> OrderByDescending(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, TKey>> keySelector, IComparer`1<TKey> comparer)
public IQueryable`1<TSource> Reverse(IQueryable`1<TSource> source)
public IQueryable`1<TResult> Select(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, TResult>> selector)
public IQueryable`1<TResult> Select(IQueryable`1<TSource> source, Expression`1<Func`3<TSource, int, TResult>> selector)
public IQueryable`1<TResult> SelectMany(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, IEnumerable`1<TResult>>> selector)
public IQueryable`1<TResult> SelectMany(IQueryable`1<TSource> source, Expression`1<Func`3<TSource, int, IEnumerable`1<TResult>>> selector)
public IQueryable`1<TResult> SelectMany(IQueryable`1<TSource> source, Expression`1<Func`3<TSource, int, IEnumerable`1<TCollection>>> collectionSelector, Expression`1<Func`3<TSource, TCollection, TResult>> resultSelector)
public IQueryable`1<TResult> SelectMany(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, IEnumerable`1<TCollection>>> collectionSelector, Expression`1<Func`3<TSource, TCollection, TResult>> resultSelector)
public bool SequenceEqual(IQueryable`1<TSource> source1, IEnumerable`1<TSource> source2)
public bool SequenceEqual(IQueryable`1<TSource> source1, IEnumerable`1<TSource> source2, IEqualityComparer`1<TSource> comparer)
public TSource Single(IQueryable`1<TSource> source)
public TSource Single(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, bool>> predicate)
public TSource SingleOrDefault(IQueryable`1<TSource> source)
public TSource SingleOrDefault(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, bool>> predicate)
public IQueryable`1<TSource> Skip(IQueryable`1<TSource> source, int count)
public IQueryable`1<TSource> SkipWhile(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, bool>> predicate)
public IQueryable`1<TSource> SkipWhile(IQueryable`1<TSource> source, Expression`1<Func`3<TSource, int, bool>> predicate)
public int Sum(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, int>> selector)
public Nullable`1<int> Sum(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, Nullable`1<int>>> selector)
public long Sum(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, long>> selector)
public Nullable`1<long> Sum(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, Nullable`1<long>>> selector)
public float Sum(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, float>> selector)
public Nullable`1<float> Sum(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, Nullable`1<float>>> selector)
public double Sum(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, double>> selector)
public Nullable`1<double> Sum(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, Nullable`1<double>>> selector)
public decimal Sum(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, decimal>> selector)
public Nullable`1<decimal> Sum(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, Nullable`1<decimal>>> selector)
public int Sum(IQueryable`1<int> source)
public Nullable`1<int> Sum(IQueryable`1<Nullable`1<int>> source)
public long Sum(IQueryable`1<long> source)
public Nullable`1<long> Sum(IQueryable`1<Nullable`1<long>> source)
public float Sum(IQueryable`1<float> source)
public Nullable`1<float> Sum(IQueryable`1<Nullable`1<float>> source)
public double Sum(IQueryable`1<double> source)
public Nullable`1<double> Sum(IQueryable`1<Nullable`1<double>> source)
public decimal Sum(IQueryable`1<decimal> source)
public Nullable`1<decimal> Sum(IQueryable`1<Nullable`1<decimal>> source)
public IQueryable`1<TSource> Take(IQueryable`1<TSource> source, int count)
public IQueryable`1<TSource> TakeWhile(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, bool>> predicate)
public IQueryable`1<TSource> TakeWhile(IQueryable`1<TSource> source, Expression`1<Func`3<TSource, int, bool>> predicate)
public IOrderedQueryable`1<TSource> ThenBy(IOrderedQueryable`1<TSource> source, Expression`1<Func`2<TSource, TKey>> keySelector)
public IOrderedQueryable`1<TSource> ThenBy(IOrderedQueryable`1<TSource> source, Expression`1<Func`2<TSource, TKey>> keySelector, IComparer`1<TKey> comparer)
public IOrderedQueryable`1<TSource> ThenByDescending(IOrderedQueryable`1<TSource> source, Expression`1<Func`2<TSource, TKey>> keySelector)
public IOrderedQueryable`1<TSource> ThenByDescending(IOrderedQueryable`1<TSource> source, Expression`1<Func`2<TSource, TKey>> keySelector, IComparer`1<TKey> comparer)
public IQueryable`1<TSource> Union(IQueryable`1<TSource> source1, IEnumerable`1<TSource> source2)
public IQueryable`1<TSource> Union(IQueryable`1<TSource> source1, IEnumerable`1<TSource> source2, IEqualityComparer`1<TSource> comparer)
public IQueryable`1<TSource> Where(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, bool>> predicate)
public IQueryable`1<TSource> Where(IQueryable`1<TSource> source, Expression`1<Func`3<TSource, int, bool>> predicate)
}
internal System.Linq.QueryableEnumerable`1 : object {
private Expression expression
private IEnumerable`1<TElement> enumerable
public Type ElementType
public Expression Expression
public IQueryProvider Provider
public void .ctor(IEnumerable`1<TElement> enumerable)
public void .ctor(Expression expression)
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
public Type get_ElementType()
public Expression get_Expression()
public IQueryProvider get_Provider()
public IEnumerable GetEnumerable()
public IEnumerator`1<TElement> GetEnumerator()
public IQueryable CreateQuery(Expression expression)
public object Execute(Expression expression)
private Expression TransformQueryable(Expression expression)
public IQueryable`1<TElem> CreateQuery(Expression expression)
public TResult Execute(Expression expression)
}
internal System.Linq.QueryableTransformer : ExpressionTransformer {
protected Expression VisitMethodCall(MethodCallExpression methodCall)
protected Expression VisitLambda(LambdaExpression lambda)
protected Expression VisitConstant(ConstantExpression constant)
private bool IsQueryableExtension(MethodInfo method)
private bool HasExtensionAttribute(MethodInfo method)
private MethodCallExpression ReplaceQueryableMethod(MethodCallExpression old)
private Expression UnquoteIfNeeded(Expression expression, Type delegateType)
private Type GetTargetDeclaringType(MethodInfo method)
private MethodInfo ReplaceQueryableMethod(MethodInfo method)
private MethodInfo GetMatchingMethod(MethodInfo method, Type declaring)
private bool MethodMatch(MethodInfo candidate, MethodInfo method)
private bool TypeMatch(Type candidate, Type type)
private Type GetComparableType(Type type)
}
internal System.Linq.QuickSort`1 : object {
private TElement[] elements
private Int32[] indexes
private SortContext`1<TElement> context
private void .ctor(IEnumerable`1<TElement> source, SortContext`1<TElement> context)
private Int32[] CreateIndexes(int length)
private void PerformSort()
private int CompareItems(int first_index, int second_index)
private int MedianOfThree(int left, int right)
private void Sort(int left, int right)
private void InsertionSort(int left, int right)
private void Swap(int left, int right)
public IEnumerable`1<TElement> Sort(IEnumerable`1<TElement> source, SortContext`1<TElement> context)
}
internal System.Linq.SortContext`1 : object {
protected SortDirection direction
protected SortContext`1<TElement> child_context
protected void .ctor(SortDirection direction, SortContext`1<TElement> child_context)
public void Initialize(TElement[] elements)
public int Compare(int first_index, int second_index)
}
internal System.Linq.SortDirection : Enum {
public int value__
public SortDirection Ascending
public SortDirection Descending
}
internal System.Linq.SortSequenceContext`2 : SortContext`1<TElement> {
private Func`2<TElement, TKey> selector
private IComparer`1<TKey> comparer
private TKey[] keys
public void .ctor(Func`2<TElement, TKey> selector, IComparer`1<TKey> comparer, SortDirection direction, SortContext`1<TElement> child_context)
public void Initialize(TElement[] elements)
public int Compare(int first_index, int second_index)
}
internal System.MonoDocumentationNoteAttribute : MonoTODOAttribute {
public void .ctor(string comment)
}
internal System.MonoExtensionAttribute : MonoTODOAttribute {
public void .ctor(string comment)
}
internal System.MonoInternalNoteAttribute : MonoTODOAttribute {
public void .ctor(string comment)
}
internal System.MonoLimitationAttribute : MonoTODOAttribute {
public void .ctor(string comment)
}
internal System.MonoNotSupportedAttribute : MonoTODOAttribute {
public void .ctor(string comment)
}
internal System.MonoTODOAttribute : Attribute {
private string comment
public string Comment
public void .ctor(string comment)
public string get_Comment()
}
public System.Runtime.CompilerServices.ExecutionScope : object {
public Object[] Globals
public Object[] Locals
public ExecutionScope Parent
internal CompilationContext context
internal int compilation_unit
private void .ctor(CompilationContext context, int compilation_unit)
internal void .ctor(CompilationContext context)
internal void .ctor(CompilationContext context, int compilation_unit, ExecutionScope parent, Object[] locals)
public Delegate CreateDelegate(int indexLambda, Object[] locals)
public Object[] CreateHoistedLocals()
public Expression IsolateExpression(Expression expression, Object[] locals)
}
public System.Runtime.CompilerServices.IStrongBox {
public object Value
public object get_Value()
public void set_Value(object value)
}
public System.Runtime.CompilerServices.StrongBox`1 : object {
public T Value
private object System.Runtime.CompilerServices.IStrongBox.Value
public void .ctor(T value)
private object System.Runtime.CompilerServices.IStrongBox.get_Value()
private void System.Runtime.CompilerServices.IStrongBox.set_Value(object value)
}
public System.Security.Cryptography.Aes : SymmetricAlgorithm {
public Aes Create()
public Aes Create(string algName)
}
public System.Security.Cryptography.AesCryptoServiceProvider : Aes {
public Byte[] IV
public Byte[] Key
public int KeySize
public void GenerateIV()
public void GenerateKey()
public ICryptoTransform CreateDecryptor(Byte[] rgbKey, Byte[] rgbIV)
public ICryptoTransform CreateEncryptor(Byte[] rgbKey, Byte[] rgbIV)
public Byte[] get_IV()
public void set_IV(Byte[] value)
public Byte[] get_Key()
public void set_Key(Byte[] value)
public int get_KeySize()
public void set_KeySize(int value)
public ICryptoTransform CreateDecryptor()
public ICryptoTransform CreateEncryptor()
protected void Dispose(bool disposing)
}
public System.Security.Cryptography.AesManaged : Aes {
public Byte[] IV
public Byte[] Key
public int KeySize
public void GenerateIV()
public void GenerateKey()
public ICryptoTransform CreateDecryptor(Byte[] rgbKey, Byte[] rgbIV)
public ICryptoTransform CreateEncryptor(Byte[] rgbKey, Byte[] rgbIV)
public Byte[] get_IV()
public void set_IV(Byte[] value)
public Byte[] get_Key()
public void set_Key(Byte[] value)
public int get_KeySize()
public void set_KeySize(int value)
public ICryptoTransform CreateDecryptor()
public ICryptoTransform CreateEncryptor()
protected void Dispose(bool disposing)
}
internal System.Security.Cryptography.AesTransform : SymmetricTransform {
private int Nb
private UInt32[] expandedKey
private int Nk
private int Nr
private UInt32[] Rcon
private Byte[] SBox
private Byte[] iSBox
private UInt32[] T0
private UInt32[] T1
private UInt32[] T2
private UInt32[] T3
private UInt32[] iT0
private UInt32[] iT1
private UInt32[] iT2
private UInt32[] iT3
public void .ctor(Aes algo, bool encryption, Byte[] key, Byte[] iv)
public void Clear()
protected void ECB(Byte[] input, Byte[] output)
private UInt32 SubByte(UInt32 a)
private void Encrypt128(Byte[] indata, Byte[] outdata, UInt32[] ekey)
private void Decrypt128(Byte[] indata, Byte[] outdata, UInt32[] ekey)
}
public System.Security.Cryptography.CngAlgorithm : object {
private string algo
private CngAlgorithm dh256
private CngAlgorithm dh384
private CngAlgorithm dh521
private CngAlgorithm dsa256
private CngAlgorithm dsa384
private CngAlgorithm dsa521
private CngAlgorithm md5
private CngAlgorithm sha1
private CngAlgorithm sha256
private CngAlgorithm sha384
private CngAlgorithm sha512
public string Algorithm
public CngAlgorithm ECDiffieHellmanP256
public CngAlgorithm ECDiffieHellmanP384
public CngAlgorithm ECDiffieHellmanP521
public CngAlgorithm ECDsaP256
public CngAlgorithm ECDsaP384
public CngAlgorithm ECDsaP521
public CngAlgorithm MD5
public CngAlgorithm Sha1
public CngAlgorithm Sha256
public CngAlgorithm Sha384
public CngAlgorithm Sha512
public void .ctor(string algorithm)
public string get_Algorithm()
public bool Equals(CngAlgorithm other)
public bool Equals(object obj)
public int GetHashCode()
public string ToString()
public CngAlgorithm get_ECDiffieHellmanP256()
public CngAlgorithm get_ECDiffieHellmanP384()
public CngAlgorithm get_ECDiffieHellmanP521()
public CngAlgorithm get_ECDsaP256()
public CngAlgorithm get_ECDsaP384()
public CngAlgorithm get_ECDsaP521()
public CngAlgorithm get_MD5()
public CngAlgorithm get_Sha1()
public CngAlgorithm get_Sha256()
public CngAlgorithm get_Sha384()
public CngAlgorithm get_Sha512()
public bool op_Equality(CngAlgorithm left, CngAlgorithm right)
public bool op_Inequality(CngAlgorithm left, CngAlgorithm right)
}
public System.Security.Cryptography.CngAlgorithmGroup : object {
private string group
private CngAlgorithmGroup dh
private CngAlgorithmGroup dsa
private CngAlgorithmGroup ecdh
private CngAlgorithmGroup ecdsa
private CngAlgorithmGroup rsa
public string AlgorithmGroup
public CngAlgorithmGroup DiffieHellman
public CngAlgorithmGroup Dsa
public CngAlgorithmGroup ECDiffieHellman
public CngAlgorithmGroup ECDsa
public CngAlgorithmGroup Rsa
public void .ctor(string algorithmGroup)
public string get_AlgorithmGroup()
public bool Equals(CngAlgorithmGroup other)
public bool Equals(object obj)
public int GetHashCode()
public string ToString()
public CngAlgorithmGroup get_DiffieHellman()
public CngAlgorithmGroup get_Dsa()
public CngAlgorithmGroup get_ECDiffieHellman()
public CngAlgorithmGroup get_ECDsa()
public CngAlgorithmGroup get_Rsa()
public bool op_Equality(CngAlgorithmGroup left, CngAlgorithmGroup right)
public bool op_Inequality(CngAlgorithmGroup left, CngAlgorithmGroup right)
}
public System.Security.Cryptography.MD5Cng : MD5 {
private Byte[] Empty
private MD5 hash
public void Initialize()
protected void HashCore(Byte[] array, int ibStart, int cbSize)
protected Byte[] HashFinal()
protected void Dispose(bool disposing)
}
public System.Security.Cryptography.SHA1Cng : SHA1 {
private Byte[] Empty
private SHA1 hash
public void Initialize()
protected void HashCore(Byte[] array, int ibStart, int cbSize)
protected Byte[] HashFinal()
protected void Dispose(bool disposing)
}
public System.Security.Cryptography.SHA256Cng : SHA256 {
private Byte[] Empty
private SHA256 hash
public void Initialize()
protected void HashCore(Byte[] array, int ibStart, int cbSize)
protected Byte[] HashFinal()
protected void Dispose(bool disposing)
}
public System.Security.Cryptography.SHA256CryptoServiceProvider : SHA256 {
private Byte[] Empty
private SHA256 hash
public void Initialize()
protected void HashCore(Byte[] array, int ibStart, int cbSize)
protected Byte[] HashFinal()
protected void Dispose(bool disposing)
}
public System.Security.Cryptography.SHA384Cng : SHA384 {
private Byte[] Empty
private SHA384 hash
public void Initialize()
protected void HashCore(Byte[] array, int ibStart, int cbSize)
protected Byte[] HashFinal()
protected void Dispose(bool disposing)
}
public System.Security.Cryptography.SHA384CryptoServiceProvider : SHA384 {
private Byte[] Empty
private SHA384 hash
public void Initialize()
protected void HashCore(Byte[] array, int ibStart, int cbSize)
protected Byte[] HashFinal()
protected void Dispose(bool disposing)
}
public System.Security.Cryptography.SHA512Cng : SHA512 {
private Byte[] Empty
private SHA512 hash
public void Initialize()
protected void HashCore(Byte[] array, int ibStart, int cbSize)
protected Byte[] HashFinal()
protected void Dispose(bool disposing)
}
public System.Security.Cryptography.SHA512CryptoServiceProvider : SHA512 {
private Byte[] Empty
private SHA512 hash
public void Initialize()
protected void HashCore(Byte[] array, int ibStart, int cbSize)
protected Byte[] HashFinal()
protected void Dispose(bool disposing)
}
public System.Threading.LockRecursionException : Exception {
public void .ctor(string message)
public void .ctor(string message, Exception e)
protected void .ctor(SerializationInfo info, StreamingContext sc)
}
public System.Threading.LockRecursionPolicy : Enum {
public int value__
public LockRecursionPolicy NoRecursion
public LockRecursionPolicy SupportsRecursion
}
public System.Threading.ReaderWriterLockSlim : object {
private bool smp
private int myLock
private int owners
private Thread upgradable_thread
private Thread write_thread
private UInt32 numWriteWaiters
private UInt32 numReadWaiters
private UInt32 numUpgradeWaiters
private EventWaitHandle writeEvent
private EventWaitHandle readEvent
private EventWaitHandle upgradeEvent
private LockRecursionPolicy recursionPolicy
private LockDetails[] read_locks
public bool IsReadLockHeld
public bool IsWriteLockHeld
public bool IsUpgradeableReadLockHeld
public int CurrentReadCount
public int RecursiveReadCount
public int RecursiveUpgradeCount
public int RecursiveWriteCount
public int WaitingReadCount
public int WaitingUpgradeCount
public int WaitingWriteCount
public LockRecursionPolicy RecursionPolicy
private bool MyLockHeld
public void .ctor(LockRecursionPolicy recursionPolicy)
public void EnterReadLock()
public bool TryEnterReadLock(int millisecondsTimeout)
public bool TryEnterReadLock(TimeSpan timeout)
public void ExitReadLock()
public void EnterWriteLock()
public bool TryEnterWriteLock(int millisecondsTimeout)
public bool TryEnterWriteLock(TimeSpan timeout)
public void ExitWriteLock()
public void EnterUpgradeableReadLock()
public bool TryEnterUpgradeableReadLock(int millisecondsTimeout)
public bool TryEnterUpgradeableReadLock(TimeSpan timeout)
public void ExitUpgradeableReadLock()
public void Dispose()
public bool get_IsReadLockHeld()
public bool get_IsWriteLockHeld()
public bool get_IsUpgradeableReadLockHeld()
public int get_CurrentReadCount()
public int get_RecursiveReadCount()
public int get_RecursiveUpgradeCount()
public int get_RecursiveWriteCount()
public int get_WaitingReadCount()
public int get_WaitingUpgradeCount()
public int get_WaitingWriteCount()
public LockRecursionPolicy get_RecursionPolicy()
private void EnterMyLock()
private void EnterMyLockSpin()
private void ExitMyLock()
private bool get_MyLockHeld()
private void ExitAndWakeUpAppropriateWaiters()
private void LazyCreateEvent(EventWaitHandle& waitEvent, bool makeAutoResetEvent)
private bool WaitOnEvent(EventWaitHandle waitEvent, UInt32& numWaiters, int millisecondsTimeout)
private int CheckTimeout(TimeSpan timeout)
private LockDetails GetReadLockDetails(int threadId, bool create)
}
public System.TimeZoneInfo : object {
private int BUFFER_SIZE
private TimeSpan baseUtcOffset
private string daylightDisplayName
private string displayName
private string id
private TimeZoneInfo local
private string standardDisplayName
private bool disableDaylightSavingTime
private TimeZoneInfo utc
private string timeZoneDirectory
private AdjustmentRule[] adjustmentRules
private List`1<TimeZoneInfo> systemTimeZones
public TimeSpan BaseUtcOffset
public string DaylightName
public string DisplayName
public string Id
public TimeZoneInfo Local
public string StandardName
public bool SupportsDaylightSavingTime
public TimeZoneInfo Utc
private string TimeZoneDirectory
private void .ctor(string id, TimeSpan baseUtcOffset, string displayName, string standardDisplayName, string daylightDisplayName, AdjustmentRule[] adjustmentRules, bool disableDaylightSavingTime)
public TimeSpan get_BaseUtcOffset()
public string get_DaylightName()
public string get_DisplayName()
public string get_Id()
public TimeZoneInfo get_Local()
public string get_StandardName()
public bool get_SupportsDaylightSavingTime()
public TimeZoneInfo get_Utc()
private string get_TimeZoneDirectory()
private void set_TimeZoneDirectory(string value)
public void ClearCachedData()
public DateTime ConvertTime(DateTime dateTime, TimeZoneInfo destinationTimeZone)
public DateTime ConvertTime(DateTime dateTime, TimeZoneInfo sourceTimeZone, TimeZoneInfo destinationTimeZone)
public DateTimeOffset ConvertTime(DateTimeOffset dateTimeOffset, TimeZoneInfo destinationTimeZone)
public DateTime ConvertTimeBySystemTimeZoneId(DateTime dateTime, string destinationTimeZoneId)
public DateTime ConvertTimeBySystemTimeZoneId(DateTime dateTime, string sourceTimeZoneId, string destinationTimeZoneId)
public DateTimeOffset ConvertTimeBySystemTimeZoneId(DateTimeOffset dateTimeOffset, string destinationTimeZoneId)
private DateTime ConvertTimeFromUtc(DateTime dateTime)
public DateTime ConvertTimeFromUtc(DateTime dateTime, TimeZoneInfo destinationTimeZone)
public DateTime ConvertTimeToUtc(DateTime dateTime)
public DateTime ConvertTimeToUtc(DateTime dateTime, TimeZoneInfo sourceTimeZone)
public TimeZoneInfo CreateCustomTimeZone(string id, TimeSpan baseUtcOffset, string displayName, string standardDisplayName)
public TimeZoneInfo CreateCustomTimeZone(string id, TimeSpan baseUtcOffset, string displayName, string standardDisplayName, string daylightDisplayName, AdjustmentRule[] adjustmentRules)
public TimeZoneInfo CreateCustomTimeZone(string id, TimeSpan baseUtcOffset, string displayName, string standardDisplayName, string daylightDisplayName, AdjustmentRule[] adjustmentRules, bool disableDaylightSavingTime)
public bool Equals(TimeZoneInfo other)
public TimeZoneInfo FindSystemTimeZoneById(string id)
private TimeZoneInfo FindSystemTimeZoneByFileName(string id, string filepath)
public TimeZoneInfo FromSerializedString(string source)
public AdjustmentRule[] GetAdjustmentRules()
public TimeSpan[] GetAmbiguousTimeOffsets(DateTime dateTime)
public TimeSpan[] GetAmbiguousTimeOffsets(DateTimeOffset dateTimeOffset)
public int GetHashCode()
public void GetObjectData(SerializationInfo info, StreamingContext context)
public ReadOnlyCollection`1<TimeZoneInfo> GetSystemTimeZones()
public TimeSpan GetUtcOffset(DateTime dateTime)
public TimeSpan GetUtcOffset(DateTimeOffset dateTimeOffset)
public bool HasSameRules(TimeZoneInfo other)
public bool IsAmbiguousTime(DateTime dateTime)
public bool IsAmbiguousTime(DateTimeOffset dateTimeOffset)
public bool IsDaylightSavingTime(DateTime dateTime)
public bool IsDaylightSavingTime(DateTimeOffset dateTimeOffset)
public bool IsInvalidTime(DateTime dateTime)
public void OnDeserialization(object sender)
public string ToSerializedString()
public string ToString()
private AdjustmentRule GetApplicableRule(DateTime dateTime)
private DateTime TransitionPoint(TransitionTime transition, int year)
private bool ValidTZFile(Byte[] buffer, int length)
private int SwapInt32(int i)
private int ReadBigEndianInt32(Byte[] buffer, int start)
private TimeZoneInfo ParseTZBuffer(string id, Byte[] buffer, int length)
private List`1<AdjustmentRule> ValidateRules(List`1<AdjustmentRule> adjustmentRules)
private Dictionary`2<int, string> ParseAbbreviations(Byte[] buffer, int index, int count)
private Dictionary`2<int, TimeType> ParseTimesTypes(Byte[] buffer, int index, int count, Dictionary`2<int, string> abbreviations)
private List`1<KeyValuePair`2<DateTime, TimeType>> ParseTransitions(Byte[] buffer, int index, int count, Dictionary`2<int, TimeType> time_types)
private DateTime DateTimeFromUnixTime(long unix_time)
}
public System.TimeZoneNotFoundException : Exception {
public void .ctor(string message)
public void .ctor(string message, Exception e)
protected void .ctor(SerializationInfo info, StreamingContext sc)
}
