internal static class Consts : object {
    public static string MonoCorlibVersion;
    public static string MonoVersion;
    public static string MonoCompany;
    public static string MonoProduct;
    public static string MonoCopyright;
    public static string FxVersion;
    public static string FxFileVersion;
    public static string EnvironmentVersion;
    public static string VsVersion;
    public static string VsFileVersion;
    private static string PublicKeyToken;
    public static string AssemblyI18N;
    public static string AssemblyMicrosoft_JScript;
    public static string AssemblyMicrosoft_VisualStudio;
    public static string AssemblyMicrosoft_VisualStudio_Web;
    public static string AssemblyMicrosoft_VSDesigner;
    public static string AssemblyMono_Http;
    public static string AssemblyMono_Posix;
    public static string AssemblyMono_Security;
    public static string AssemblyMono_Messaging_RabbitMQ;
    public static string AssemblyCorlib;
    public static string AssemblySystem;
    public static string AssemblySystem_Data;
    public static string AssemblySystem_Design;
    public static string AssemblySystem_DirectoryServices;
    public static string AssemblySystem_Drawing;
    public static string AssemblySystem_Drawing_Design;
    public static string AssemblySystem_Messaging;
    public static string AssemblySystem_Security;
    public static string AssemblySystem_ServiceProcess;
    public static string AssemblySystem_Web;
    public static string AssemblySystem_Windows_Forms;
    public static string AssemblySystem_2_0;
    public static string AssemblySystemCore_3_5;
    public static string AssemblySystem_Core;
    public static string WindowsBase_3_0;
    public static string AssemblyWindowsBase;
    public static string AssemblyPresentationCore_3_5;
    public static string AssemblyPresentationCore_4_0;
    public static string AssemblyPresentationFramework_3_5;
    public static string AssemblySystemServiceModel_3_0;
}
internal static class Interop : object {
}
public class Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle : SafeHandleZeroOrMinusOneIsInvalid {
    public SafeMemoryMappedFileHandle(IntPtr preexistingHandle, bool ownsHandle);
    protected virtual bool ReleaseHandle();
}
public class Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle : SafeBuffer {
    private IntPtr mmap_handle;
    internal SafeMemoryMappedViewHandle(IntPtr mmap_handle, IntPtr base_address, long size);
    internal void Flush();
    protected virtual bool ReleaseHandle();
}
public abstract class Microsoft.Win32.SafeHandles.SafeNCryptHandle : SafeHandleZeroOrMinusOneIsInvalid {
    public bool IsInvalid { get; }
    protected SafeNCryptHandle(IntPtr handle, SafeHandle parentHandle);
    public virtual bool get_IsInvalid();
    protected virtual bool ReleaseHandle();
    protected abstract virtual bool ReleaseNativeHandle();
}
public class Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle : SafeNCryptHandle {
    public SafeNCryptKeyHandle(IntPtr handle, SafeHandle parentHandle);
    protected virtual bool ReleaseNativeHandle();
}
public class Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle : SafeNCryptHandle {
    protected virtual bool ReleaseNativeHandle();
}
public class Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle : SafeNCryptHandle {
    protected virtual bool ReleaseNativeHandle();
}
public class Microsoft.Win32.SafeHandles.SafePipeHandle : SafeHandleZeroOrMinusOneIsInvalid {
    private static int DefaultInvalidHandle;
    public SafePipeHandle(IntPtr preexistingHandle, bool ownsHandle);
    protected virtual bool ReleaseHandle();
    internal void SetHandle(int descriptor);
}
internal static class SR : object {
    public static string ReducibleMustOverrideReduce;
    public static string MustReduceToDifferent;
    public static string ReducedNotCompatible;
    public static string SetterHasNoParams;
    public static string PropertyCannotHaveRefType;
    public static string IndexesOfSetGetMustMatch;
    public static string AccessorsCannotHaveVarArgs;
    public static string AccessorsCannotHaveByRefArgs;
    public static string BoundsCannotBeLessThanOne;
    public static string TypeMustNotBeByRef;
    public static string TypeMustNotBePointer;
    public static string SetterMustBeVoid;
    public static string PropertyTypeMustMatchGetter;
    public static string PropertyTypeMustMatchSetter;
    public static string BothAccessorsMustBeStatic;
    public static string OnlyStaticFieldsHaveNullInstance;
    public static string OnlyStaticPropertiesHaveNullInstance;
    public static string OnlyStaticMethodsHaveNullInstance;
    public static string PropertyTypeCannotBeVoid;
    public static string InvalidUnboxType;
    public static string ExpressionMustBeWriteable;
    public static string ArgumentMustNotHaveValueType;
    public static string MustBeReducible;
    public static string AllTestValuesMustHaveSameType;
    public static string AllCaseBodiesMustHaveSameType;
    public static string DefaultBodyMustBeSupplied;
    public static string LabelMustBeVoidOrHaveExpression;
    public static string LabelTypeMustBeVoid;
    public static string QuotedExpressionMustBeLambda;
    public static string VariableMustNotBeByRef;
    public static string DuplicateVariable;
    public static string StartEndMustBeOrdered;
    public static string FaultCannotHaveCatchOrFinally;
    public static string TryMustHaveCatchFinallyOrFault;
    public static string BodyOfCatchMustHaveSameTypeAsBodyOfTry;
    public static string ExtensionNodeMustOverrideProperty;
    public static string UserDefinedOperatorMustBeStatic;
    public static string UserDefinedOperatorMustNotBeVoid;
    public static string CoercionOperatorNotDefined;
    public static string UnaryOperatorNotDefined;
    public static string BinaryOperatorNotDefined;
    public static string ReferenceEqualityNotDefined;
    public static string OperandTypesDoNotMatchParameters;
    public static string OverloadOperatorTypeDoesNotMatchConversionType;
    public static string ConversionIsNotSupportedForArithmeticTypes;
    public static string ArgumentMustBeArray;
    public static string ArgumentMustBeBoolean;
    public static string EqualityMustReturnBoolean;
    public static string ArgumentMustBeFieldInfoOrPropertyInfo;
    public static string ArgumentMustBeFieldInfoOrPropertyInfoOrMethod;
    public static string ArgumentMustBeInstanceMember;
    public static string ArgumentMustBeInteger;
    public static string ArgumentMustBeArrayIndexType;
    public static string ArgumentMustBeSingleDimensionalArrayType;
    public static string ArgumentTypesMustMatch;
    public static string CannotAutoInitializeValueTypeElementThroughProperty;
    public static string CannotAutoInitializeValueTypeMemberThroughProperty;
    public static string IncorrectTypeForTypeAs;
    public static string CoalesceUsedOnNonNullType;
    public static string ExpressionTypeCannotInitializeArrayType;
    public static string ArgumentTypeDoesNotMatchMember;
    public static string ArgumentMemberNotDeclOnType;
    public static string ExpressionTypeDoesNotMatchReturn;
    public static string ExpressionTypeDoesNotMatchAssignment;
    public static string ExpressionTypeDoesNotMatchLabel;
    public static string ExpressionTypeNotInvocable;
    public static string FieldNotDefinedForType;
    public static string InstanceFieldNotDefinedForType;
    public static string FieldInfoNotDefinedForType;
    public static string IncorrectNumberOfIndexes;
    public static string IncorrectNumberOfLambdaDeclarationParameters;
    public static string IncorrectNumberOfMembersForGivenConstructor;
    public static string IncorrectNumberOfArgumentsForMembers;
    public static string LambdaTypeMustBeDerivedFromSystemDelegate;
    public static string MemberNotFieldOrProperty;
    public static string MethodContainsGenericParameters;
    public static string MethodIsGeneric;
    public static string MethodNotPropertyAccessor;
    public static string PropertyDoesNotHaveGetter;
    public static string PropertyDoesNotHaveSetter;
    public static string PropertyDoesNotHaveAccessor;
    public static string NotAMemberOfType;
    public static string NotAMemberOfAnyType;
    public static string UnsupportedExpressionType;
    public static string ParameterExpressionNotValidAsDelegate;
    public static string PropertyNotDefinedForType;
    public static string InstancePropertyNotDefinedForType;
    public static string InstancePropertyWithoutParameterNotDefinedForType;
    public static string InstancePropertyWithSpecifiedParametersNotDefinedForType;
    public static string InstanceAndMethodTypeMismatch;
    public static string TypeContainsGenericParameters;
    public static string TypeIsGeneric;
    public static string TypeMissingDefaultConstructor;
    public static string ElementInitializerMethodNotAdd;
    public static string ElementInitializerMethodNoRefOutParam;
    public static string ElementInitializerMethodWithZeroArgs;
    public static string ElementInitializerMethodStatic;
    public static string TypeNotIEnumerable;
    public static string UnhandledBinary;
    public static string UnhandledBinding;
    public static string UnhandledBindingType;
    public static string UnhandledUnary;
    public static string UnknownBindingType;
    public static string UserDefinedOpMustHaveConsistentTypes;
    public static string UserDefinedOpMustHaveValidReturnType;
    public static string LogicalOperatorMustHaveBooleanOperators;
    public static string MethodWithArgsDoesNotExistOnType;
    public static string GenericMethodWithArgsDoesNotExistOnType;
    public static string MethodWithMoreThanOneMatch;
    public static string PropertyWithMoreThanOneMatch;
    public static string IncorrectNumberOfTypeArgsForFunc;
    public static string IncorrectNumberOfTypeArgsForAction;
    public static string ArgumentCannotBeOfTypeVoid;
    public static string OutOfRange;
    public static string LabelTargetAlreadyDefined;
    public static string LabelTargetUndefined;
    public static string ControlCannotLeaveFinally;
    public static string ControlCannotLeaveFilterTest;
    public static string AmbiguousJump;
    public static string ControlCannotEnterTry;
    public static string ControlCannotEnterExpression;
    public static string NonLocalJumpWithValue;
    public static string CannotCompileConstant;
    public static string CannotCompileDynamic;
    public static string InvalidLvalue;
    public static string UndefinedVariable;
    public static string CannotCloseOverByRef;
    public static string UnexpectedVarArgsCall;
    public static string RethrowRequiresCatch;
    public static string TryNotAllowedInFilter;
    public static string MustRewriteToSameNode;
    public static string MustRewriteChildToSameType;
    public static string MustRewriteWithoutMethod;
    public static string InvalidNullValue;
    public static string InvalidObjectType;
    public static string TryNotSupportedForMethodsWithRefArgs;
    public static string TryNotSupportedForValueTypeInstances;
    public static string EnumerationIsDone;
    public static string TestValueTypeDoesNotMatchComparisonMethodParameter;
    public static string SwitchValueTypeDoesNotMatchComparisonMethodParameter;
    public static string PdbGeneratorNeedsExpressionCompiler;
    public static string InvalidArgumentValue;
    public static string NonEmptyCollectionRequired;
    public static string CollectionModifiedWhileEnumerating;
    public static string ExpressionMustBeReadable;
    public static string ExpressionTypeDoesNotMatchMethodParameter;
    public static string ExpressionTypeDoesNotMatchParameter;
    public static string ExpressionTypeDoesNotMatchConstructorParameter;
    public static string IncorrectNumberOfMethodCallArguments;
    public static string IncorrectNumberOfLambdaArguments;
    public static string IncorrectNumberOfConstructorArguments;
    public static string NonStaticConstructorRequired;
    public static string NonAbstractConstructorRequired;
    public static string FirstArgumentMustBeCallSite;
    public static string NoOrInvalidRuleProduced;
    public static string TypeMustBeDerivedFromSystemDelegate;
    public static string TypeParameterIsNotDelegate;
    public static string ArgumentTypeCannotBeVoid;
    public static string ArgCntMustBeGreaterThanNameCnt;
    public static string BinderNotCompatibleWithCallSite;
    public static string BindingCannotBeNull;
    public static string DynamicBinderResultNotAssignable;
    public static string DynamicBindingNeedsRestrictions;
    public static string DynamicObjectResultNotAssignable;
    public static string InvalidMetaObjectCreated;
    public static string AmbiguousMatchInExpandoObject;
    public static string CollectionReadOnly;
    public static string KeyDoesNotExistInExpando;
    public static string SameKeyExistsInExpando;
    public static string Arg_KeyNotFoundWithKey;
    public static string EmptyEnumerable;
    public static string MoreThanOneElement;
    public static string MoreThanOneMatch;
    public static string NoElements;
    public static string NoMatch;
    public static string ParallelPartitionable_NullReturn;
    public static string ParallelPartitionable_IncorretElementCount;
    public static string ParallelPartitionable_NullElement;
    public static string PLINQ_CommonEnumerator_Current_NotStarted;
    public static string PLINQ_ExternalCancellationRequested;
    public static string PLINQ_DisposeRequested;
    public static string ParallelQuery_DuplicateTaskScheduler;
    public static string ParallelQuery_DuplicateDOP;
    public static string ParallelQuery_DuplicateExecutionMode;
    public static string PartitionerQueryOperator_NullPartitionList;
    public static string PartitionerQueryOperator_WrongNumberOfPartitions;
    public static string PartitionerQueryOperator_NullPartition;
    public static string ParallelQuery_DuplicateWithCancellation;
    public static string ParallelQuery_DuplicateMergeOptions;
    public static string PLINQ_EnumerationPreviouslyFailed;
    public static string ParallelQuery_PartitionerNotOrderable;
    public static string ParallelQuery_InvalidAsOrderedCall;
    public static string ParallelQuery_InvalidNonGenericAsOrderedCall;
    public static string ParallelEnumerable_BinaryOpMustUseAsParallel;
    public static string ParallelEnumerable_WithQueryExecutionMode_InvalidMode;
    public static string ParallelEnumerable_WithMergeOptions_InvalidOptions;
    public static string ArgumentNotIEnumerableGeneric;
    public static string ArgumentNotValid;
    public static string NoMethodOnType;
    public static string NoMethodOnTypeMatchingArguments;
    public static string EnumeratingNullEnumerableExpression;
    public static string ArgumentOutOfRange_NeedNonNegNum;
    public static string ArgumentOutOfRange_NeedValidPipeAccessRights;
    public static string Argument_InvalidOffLen;
    public static string Argument_NeedNonemptyPipeName;
    public static string Argument_NonContainerInvalidAnyFlag;
    public static string Argument_EmptyServerName;
    public static string Argument_InvalidHandle;
    public static string ArgumentNull_Buffer;
    public static string ArgumentNull_ServerName;
    public static string ArgumentOutOfRange_AnonymousReserved;
    public static string ArgumentOutOfRange_TransmissionModeByteOrMsg;
    public static string ArgumentOutOfRange_DirectionModeInOutOrInOut;
    public static string ArgumentOutOfRange_ImpersonationInvalid;
    public static string ArgumentOutOfRange_OptionsInvalid;
    public static string ArgumentOutOfRange_HandleInheritabilityNoneOrInheritable;
    public static string ArgumentOutOfRange_InvalidTimeout;
    public static string ArgumentOutOfRange_MaxNumServerInstances;
    public static string ArgumentOutOfRange_NeedPosNum;
    public static string InvalidOperation_PipeNotYetConnected;
    public static string InvalidOperation_PipeDisconnected;
    public static string InvalidOperation_PipeHandleNotSet;
    public static string InvalidOperation_PipeNotAsync;
    public static string InvalidOperation_PipeReadModeNotMessage;
    public static string InvalidOperation_PipeAlreadyConnected;
    public static string InvalidOperation_PipeAlreadyDisconnected;
    public static string IO_EOF_ReadBeyondEOF;
    public static string IO_FileNotFound;
    public static string IO_FileNotFound_FileName;
    public static string IO_AlreadyExists_Name;
    public static string IO_FileExists_Name;
    public static string IO_IO_PipeBroken;
    public static string IO_OperationAborted;
    public static string IO_SharingViolation_File;
    public static string IO_SharingViolation_NoFileName;
    public static string IO_PipeBroken;
    public static string IO_InvalidPipeHandle;
    public static string IO_PathNotFound_Path;
    public static string IO_PathNotFound_NoPathName;
    public static string IO_PathTooLong;
    public static string NotSupported_UnreadableStream;
    public static string NotSupported_UnseekableStream;
    public static string NotSupported_UnwritableStream;
    public static string NotSupported_AnonymousPipeUnidirectional;
    public static string NotSupported_AnonymousPipeMessagesNotSupported;
    public static string ObjectDisposed_PipeClosed;
    public static string UnauthorizedAccess_IODenied_Path;
    public static string UnauthorizedAccess_IODenied_NoPathName;
    public static string ArgumentOutOfRange_FileLengthTooBig;
    public static string PlatformNotSupported_MessageTransmissionMode;
    public static string PlatformNotSupported_RemotePipes;
    public static string PlatformNotSupported_InvalidPipeNameChars;
    public static string ObjectDisposed_StreamClosed;
    public static string PlatformNotSupported_OperatingSystemError;
    public static string IO_AllPipeInstancesAreBusy;
    public static string IO_PathTooLong_Path;
    public static string UnauthorizedAccess_NotOwnedByCurrentUser;
    public static string UnauthorizedAccess_ClientIsNotCurrentUser;
    public static string net_invalidversion;
    public static string net_noseek;
    public static string net_invasync;
    public static string net_io_timeout_use_gt_zero;
    public static string net_notconnected;
    public static string net_notstream;
    public static string net_stopped;
    public static string net_udpconnected;
    public static string net_readonlystream;
    public static string net_writeonlystream;
    public static string net_InvalidAddressFamily;
    public static string net_InvalidEndPointAddressFamily;
    public static string net_InvalidSocketAddressSize;
    public static string net_invalidAddressList;
    public static string net_completed_result;
    public static string net_protocol_invalid_family;
    public static string net_protocol_invalid_multicast_family;
    public static string net_sockets_zerolist;
    public static string net_sockets_blocking;
    public static string net_sockets_useblocking;
    public static string net_sockets_select;
    public static string net_sockets_toolarge_select;
    public static string net_sockets_empty_select;
    public static string net_sockets_mustbind;
    public static string net_sockets_mustlisten;
    public static string net_sockets_mustnotlisten;
    public static string net_sockets_mustnotbebound;
    public static string net_sockets_namedmustnotbebound;
    public static string net_sockets_invalid_ipaddress_length;
    public static string net_sockets_invalid_optionValue;
    public static string net_sockets_invalid_optionValue_all;
    public static string net_sockets_invalid_dnsendpoint;
    public static string net_sockets_disconnectedConnect;
    public static string net_sockets_disconnectedAccept;
    public static string net_tcplistener_mustbestopped;
    public static string net_socketopinprogress;
    public static string net_buffercounttoosmall;
    public static string net_multibuffernotsupported;
    public static string net_ambiguousbuffers;
    public static string net_io_writefailure;
    public static string net_io_readfailure;
    public static string net_io_invalidasyncresult;
    public static string net_io_invalidendcall;
    public static string net_value_cannot_be_negative;
    public static string ArgumentOutOfRange_Bounds_Lower_Upper;
    public static string net_sockets_connect_multiconnect_notsupported;
    public static string net_sockets_dualmode_receivefrom_notsupported;
    public static string net_sockets_accept_receive_notsupported;
    public static string net_sockets_duplicateandclose_notsupported;
    public static string net_sockets_transmitfileoptions_notsupported;
    public static string ArgumentOutOfRange_PathLengthInvalid;
    public static string net_io_readwritefailure;
    public static string PlatformNotSupported_AcceptSocket;
    public static string PlatformNotSupported_IOControl;
    public static string PlatformNotSupported_IPProtectionLevel;
    public static string InvalidOperation_BufferNotExplicitArray;
    public static string InvalidOperation_IncorrectToken;
    public static string InvalidOperation_MultipleContinuations;
    public static string Argument_InvalidOidValue;
    public static string Argument_InvalidValue;
    public static string Arg_CryptographyException;
    public static string Cryptography_ArgECDHKeySizeMismatch;
    public static string Cryptography_ArgECDHRequiresECDHKey;
    public static string Cryptography_TlsRequiresLabelAndSeed;
    public static string Cryptography_TlsRequires64ByteSeed;
    public static string Cryptography_BadHashSize_ForAlgorithm;
    public static string Cryptography_Config_EncodedOIDError;
    public static string Cryptography_CSP_NoPrivateKey;
    public static string Cryptography_Der_Invalid_Encoding;
    public static string Cryptography_DSA_KeyGenNotSupported;
    public static string Cryptography_Encryption_MessageTooLong;
    public static string Cryptography_ECXmlSerializationFormatRequired;
    public static string Cryptography_ECC_NamedCurvesOnly;
    public static string Cryptography_HashAlgorithmNameNullOrEmpty;
    public static string Cryptography_InvalidOID;
    public static string Cryptography_CurveNotSupported;
    public static string Cryptography_InvalidCurveOid;
    public static string Cryptography_InvalidCurveKeyParameters;
    public static string Cryptography_InvalidDsaParameters_MissingFields;
    public static string Cryptography_InvalidDsaParameters_MismatchedPGY;
    public static string Cryptography_InvalidDsaParameters_MismatchedQX;
    public static string Cryptography_InvalidDsaParameters_MismatchedPJ;
    public static string Cryptography_InvalidDsaParameters_SeedRestriction_ShortKey;
    public static string Cryptography_InvalidDsaParameters_QRestriction_ShortKey;
    public static string Cryptography_InvalidDsaParameters_QRestriction_LargeKey;
    public static string Cryptography_InvalidECCharacteristic2Curve;
    public static string Cryptography_InvalidECPrimeCurve;
    public static string Cryptography_InvalidECNamedCurve;
    public static string Cryptography_InvalidKeySize;
    public static string Cryptography_InvalidKey_SemiWeak;
    public static string Cryptography_InvalidKey_Weak;
    public static string Cryptography_InvalidIVSize;
    public static string Cryptography_InvalidOperation;
    public static string Cryptography_InvalidPadding;
    public static string Cryptography_InvalidRsaParameters;
    public static string Cryptography_InvalidPaddingMode;
    public static string Cryptography_Invalid_IA5String;
    public static string Cryptography_KeyTooSmall;
    public static string Cryptography_MissingIV;
    public static string Cryptography_MissingKey;
    public static string Cryptography_MissingOID;
    public static string Cryptography_MustTransformWholeBlock;
    public static string Cryptography_NotValidPrivateKey;
    public static string Cryptography_NotValidPublicOrPrivateKey;
    public static string Cryptography_OAEP_Decryption_Failed;
    public static string Cryptography_OpenInvalidHandle;
    public static string Cryptography_PartialBlock;
    public static string Cryptography_PasswordDerivedBytes_FewBytesSalt;
    public static string Cryptography_RC2_EKS40;
    public static string Cryptography_RC2_EKSKS;
    public static string Cryptography_RC2_EKSKS2;
    public static string Cryptography_Rijndael_BlockSize;
    public static string Cryptography_RSA_DecryptWrongSize;
    public static string Cryptography_SignHash_WrongSize;
    public static string Cryptography_TransformBeyondEndOfBuffer;
    public static string Cryptography_CipherModeNotSupported;
    public static string Cryptography_UnknownHashAlgorithm;
    public static string Cryptography_UnknownPaddingMode;
    public static string Cryptography_UnexpectedTransformTruncation;
    public static string Cryptography_Unmapped_System_Typed_Error;
    public static string Cryptography_UnsupportedPaddingMode;
    public static string NotSupported_Method;
    public static string NotSupported_SubclassOverride;
    public static string Cryptography_AlgorithmTypesMustBeVisible;
    public static string Cryptography_AddNullOrEmptyName;
    public static string Argument_Invalid_SafeHandleInvalidOrClosed;
    public static string Cryptography_ArgExpectedECDiffieHellmanCngPublicKey;
    public static string Cryptography_ArgDSARequiresDSAKey;
    public static string Cryptography_ArgECDsaRequiresECDsaKey;
    public static string Cryptography_ArgRSARequiresRSAKey;
    public static string Cryptography_CngKeyWrongAlgorithm;
    public static string Cryptography_InvalidAlgorithmGroup;
    public static string Cryptography_InvalidAlgorithmName;
    public static string Cryptography_InvalidCipherMode;
    public static string Cryptography_InvalidKeyBlobFormat;
    public static string Cryptography_InvalidProviderName;
    public static string Cryptography_KeyBlobParsingError;
    public static string Cryptography_OpenEphemeralKeyHandleWithoutEphemeralFlag;
    public static string Cryptography_WeakKey;
    public static string PlatformNotSupported_CryptographyCng;
    public static string CountdownEvent_Increment_AlreadyZero;
    public static string CountdownEvent_Increment_AlreadyMax;
    public static string CountdownEvent_Decrement_BelowZero;
    public static string Common_OperationCanceled;
    public static string Barrier_Dispose;
    public static string Barrier_SignalAndWait_InvalidOperation_ZeroTotal;
    public static string Barrier_SignalAndWait_ArgumentOutOfRange;
    public static string Barrier_RemoveParticipants_InvalidOperation;
    public static string Barrier_RemoveParticipants_ArgumentOutOfRange;
    public static string Barrier_RemoveParticipants_NonPositive_ArgumentOutOfRange;
    public static string Barrier_InvalidOperation_CalledFromPHA;
    public static string Barrier_AddParticipants_NonPositive_ArgumentOutOfRange;
    public static string Barrier_SignalAndWait_InvalidOperation_ThreadsExceeded;
    public static string BarrierPostPhaseException;
    public static string Barrier_ctor_ArgumentOutOfRange;
    public static string Barrier_AddParticipants_Overflow_ArgumentOutOfRange;
    public static string SynchronizationLockException_IncorrectDispose;
    public static string SynchronizationLockException_MisMatchedWrite;
    public static string LockRecursionException_UpgradeAfterReadNotAllowed;
    public static string LockRecursionException_UpgradeAfterWriteNotAllowed;
    public static string SynchronizationLockException_MisMatchedUpgrade;
    public static string SynchronizationLockException_MisMatchedRead;
    public static string LockRecursionException_WriteAfterReadNotAllowed;
    public static string LockRecursionException_RecursiveWriteNotAllowed;
    public static string LockRecursionException_ReadAfterWriteNotAllowed;
    public static string LockRecursionException_RecursiveUpgradeNotAllowed;
    public static string LockRecursionException_RecursiveReadNotAllowed;
    public static string Overflow_UInt16;
    public static string ReaderWriterLock_Timeout;
    public static string ArgumentOutOfRange_TimeoutMilliseconds;
    public static string ReaderWriterLock_NotOwner;
    public static string ExceptionFromHResult;
    public static string ReaderWriterLock_InvalidLockCookie;
    public static string ReaderWriterLock_RestoreLockWithOwnedLocks;
    public static string HostExecutionContextManager_InvalidOperation_NotNewCaptureContext;
    public static string HostExecutionContextManager_InvalidOperation_CannotOverrideSetWithoutRevert;
    public static string HostExecutionContextManager_InvalidOperation_CannotUseSwitcherOtherThread;
    public static string Arg_NonZeroLowerBound;
    public static string Arg_WrongType;
    public static string Arg_ArrayPlusOffTooSmall;
    public static string ArgumentOutOfRange_SmallCapacity;
    public static string Argument_AddingDuplicate;
    public static string InvalidOperation_ConcurrentOperationsNotSupported;
    public static string InvalidOperation_EmptyQueue;
    public static string InvalidOperation_EnumOpCantHappen;
    public static string InvalidOperation_EnumFailedVersion;
    public static string InvalidOperation_EmptyStack;
    public static string InvalidOperation_EnumNotStarted;
    public static string InvalidOperation_EnumEnded;
    public static string NotSupported_KeyCollectionSet;
    public static string NotSupported_ValueCollectionSet;
    public static string Arg_ArrayLengthsDiffer;
    public static string Arg_BitArrayTypeUnsupported;
    public static string Arg_HSCapacityOverflow;
    public static string Arg_HTCapacityOverflow;
    public static string Arg_InsufficientSpace;
    public static string Arg_RankMultiDimNotSupported;
    public static string Argument_ArrayTooLarge;
    public static string Argument_InvalidArrayType;
    public static string ArgumentOutOfRange_BiggerThanCollection;
    public static string ArgumentOutOfRange_Index;
    public static string ExternalLinkedListNode;
    public static string LinkedListEmpty;
    public static string LinkedListNodeIsAttached;
    public static string NotSupported_SortedListNestedWrite;
    public static string SortedSet_LowerValueGreaterThanUpperValue;
    public static string Serialization_InvalidOnDeser;
    public static string Serialization_MismatchedCount;
    public static string Serialization_MissingKeys;
    public static string Serialization_MissingValues;
    public static string Argument_MapNameEmptyString;
    public static string Argument_EmptyFile;
    public static string Argument_NewMMFWriteAccessNotAllowed;
    public static string Argument_ReadAccessWithLargeCapacity;
    public static string Argument_NewMMFAppendModeNotAllowed;
    public static string Argument_NewMMFTruncateModeNotAllowed;
    public static string ArgumentNull_MapName;
    public static string ArgumentNull_FileStream;
    public static string ArgumentOutOfRange_CapacityLargerThanLogicalAddressSpaceNotAllowed;
    public static string ArgumentOutOfRange_NeedPositiveNumber;
    public static string ArgumentOutOfRange_PositiveOrDefaultCapacityRequired;
    public static string ArgumentOutOfRange_PositiveOrDefaultSizeRequired;
    public static string ArgumentOutOfRange_CapacityGEFileSizeRequired;
    public static string IO_NotEnoughMemory;
    public static string InvalidOperation_CantCreateFileMapping;
    public static string NotSupported_MMViewStreamsFixedLength;
    public static string ObjectDisposed_ViewAccessorClosed;
    public static string ObjectDisposed_StreamIsClosed;
    public static string PlatformNotSupported_NamedMaps;
    public static string MethodBuilderDoesNotHaveTypeBuilder;
    public static string Cryptography_NonCompliantFIPSAlgorithm;
    public static string InvalidOperation_ViewIsNull;
    public static string ArgumentOutOfRange_InvalidPipeAccessRights;
    public static string ArgumentOutOfRange_AdditionalAccessLimited;
    public static string InterfaceType_Must_Be_Interface;
    public static string BaseType_Cannot_Be_Sealed;
    public static string BaseType_Cannot_Be_Abstract;
    public static string BaseType_Must_Have_Default_Ctor;
    public static string Cryptography_Cert_AlreadyHasPrivateKey;
    public static string Cryptography_PrivateKey_WrongAlgorithm;
    public static string Cryptography_PrivateKey_DoesNotMatch;
    internal static string GetString(string name, Object[] args);
    internal static string GetString(CultureInfo culture, string name, Object[] args);
    internal static string GetString(string name);
    internal static string GetString(CultureInfo culture, string name);
    internal static string Format(string resourceFormat, Object[] args);
    internal static string Format(string resourceFormat, object p1);
    internal static string Format(string resourceFormat, object p1, object p2);
    internal static string Format(CultureInfo ci, string resourceFormat, object p1, object p2);
    internal static string Format(string resourceFormat, object p1, object p2, object p3);
    internal static string GetResourceString(string str);
}
public class System.Action`10 : MulticastDelegate {
    public Action`10(object object, IntPtr method);
    public virtual void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Action`11 : MulticastDelegate {
    public Action`11(object object, IntPtr method);
    public virtual void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Action`12 : MulticastDelegate {
    public Action`12(object object, IntPtr method);
    public virtual void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Action`13 : MulticastDelegate {
    public Action`13(object object, IntPtr method);
    public virtual void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Action`14 : MulticastDelegate {
    public Action`14(object object, IntPtr method);
    public virtual void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Action`15 : MulticastDelegate {
    public Action`15(object object, IntPtr method);
    public virtual void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Action`16 : MulticastDelegate {
    public Action`16(object object, IntPtr method);
    public virtual void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15, T16 arg16);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15, T16 arg16, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Action`9 : MulticastDelegate {
    public Action`9(object object, IntPtr method);
    public virtual void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[DefaultMemberAttribute("Item")]
internal class System.Collections.Generic.ArrayBuilder`1 : ValueType {
    private static int DefaultCapacity;
    private static int MaxCoreClrArrayLength;
    private T[] _array;
    private int _count;
    public int Capacity { get; }
    public int Count { get; }
    public T Item { get; public set; }
    public ArrayBuilder`1(int capacity);
    public int get_Capacity();
    public int get_Count();
    public T get_Item(int index);
    public void set_Item(int index, T value);
    public void Add(T item);
    public T First();
    public T Last();
    public T[] ToArray();
    public void UncheckedAdd(T item);
    private void EnsureCapacity(int minimum);
}
internal class System.Collections.Generic.BitHelper : object {
    private static byte MarkedBitFlag;
    private static byte IntSize;
    private int _length;
    private Int32* _arrayPtr;
    private Int32[] _array;
    private bool _useStackAlloc;
    internal BitHelper(Int32* bitArrayPtr, int length);
    internal BitHelper(Int32[] bitArray, int length);
    internal void MarkBit(int bitPosition);
    internal bool IsMarked(int bitPosition);
    internal static int ToIntArrayLength(int n);
}
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
[IsReadOnlyAttribute]
internal class System.Collections.Generic.CopyPosition : ValueType {
    [CompilerGeneratedAttribute]
private int <Row>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Column>k__BackingField;
    public static CopyPosition Start { get; }
    internal int Row { get; }
    internal int Column { get; }
    private string DebuggerDisplay { get; }
    internal CopyPosition(int row, int column);
    public static CopyPosition get_Start();
    [CompilerGeneratedAttribute]
internal int get_Row();
    [CompilerGeneratedAttribute]
internal int get_Column();
    public CopyPosition Normalize(int endColumn);
    private string get_DebuggerDisplay();
}
internal static class System.Collections.Generic.EnumerableHelpers : object {
    internal static bool TryGetCount(IEnumerable`1<T> source, Int32& count);
    internal static void Copy(IEnumerable`1<T> source, T[] array, int arrayIndex, int count);
    internal static void IterativeCopy(IEnumerable`1<T> source, T[] array, int arrayIndex, int count);
    internal static T[] ToArray(IEnumerable`1<T> source);
    internal static T[] ToArray(IEnumerable`1<T> source, Int32& length);
}
[DebuggerTypeProxyAttribute("System.Collections.Generic.ICollectionDebugView`1")]
[DebuggerDisplayAttribute("Count = {Count}")]
public class System.Collections.Generic.HashSet`1 : object {
    private static int Lower31BitMask;
    private static int StackAllocThreshold;
    private static int ShrinkThreshold;
    private static string CapacityName;
    private static string ElementsName;
    private static string ComparerName;
    private static string VersionName;
    private Int32[] _buckets;
    private Slot[] _slots;
    private int _count;
    private int _lastIndex;
    private int _freeList;
    private IEqualityComparer`1<T> _comparer;
    private int _version;
    private SerializationInfo _siInfo;
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    public IEqualityComparer`1<T> Comparer { get; }
    public HashSet`1(IEqualityComparer`1<T> comparer);
    public HashSet`1(int capacity);
    public HashSet`1(IEnumerable`1<T> collection);
    public HashSet`1(IEnumerable`1<T> collection, IEqualityComparer`1<T> comparer);
    protected HashSet`1(SerializationInfo info, StreamingContext context);
    public HashSet`1(int capacity, IEqualityComparer`1<T> comparer);
    private void CopyFrom(HashSet`1<T> source);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual bool Remove(T item);
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    public Enumerator<T> GetEnumerator();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual void OnDeserialization(object sender);
    public sealed virtual bool Add(T item);
    public bool TryGetValue(T equalValue, T& actualValue);
    public sealed virtual void UnionWith(IEnumerable`1<T> other);
    public sealed virtual void IntersectWith(IEnumerable`1<T> other);
    public sealed virtual void ExceptWith(IEnumerable`1<T> other);
    public sealed virtual void SymmetricExceptWith(IEnumerable`1<T> other);
    public sealed virtual bool IsSubsetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsProperSubsetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsSupersetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsProperSupersetOf(IEnumerable`1<T> other);
    public sealed virtual bool Overlaps(IEnumerable`1<T> other);
    public sealed virtual bool SetEquals(IEnumerable`1<T> other);
    public void CopyTo(T[] array);
    public void CopyTo(T[] array, int arrayIndex, int count);
    public int RemoveWhere(Predicate`1<T> match);
    public IEqualityComparer`1<T> get_Comparer();
    public int EnsureCapacity(int capacity);
    public void TrimExcess();
    public static IEqualityComparer`1<HashSet`1<T>> CreateSetComparer();
    private int Initialize(int capacity);
    private void IncreaseCapacity();
    private void SetCapacity(int newSize);
    private bool AddIfNotPresent(T value);
    private void AddValue(int index, int hashCode, T value);
    private bool ContainsAllElements(IEnumerable`1<T> other);
    private bool IsSubsetOfHashSetWithSameEC(HashSet`1<T> other);
    private void IntersectWithHashSetWithSameEC(HashSet`1<T> other);
    private void IntersectWithEnumerable(IEnumerable`1<T> other);
    private int InternalIndexOf(T item);
    private void SymmetricExceptWithUniqueHashSet(HashSet`1<T> other);
    private void SymmetricExceptWithEnumerable(IEnumerable`1<T> other);
    private bool AddOrGetLocation(T value, Int32& location);
    private ElementCount<T> CheckUniqueAndUnfoundElements(IEnumerable`1<T> other, bool returnIfUnfound);
    internal static bool HashSetEquals(HashSet`1<T> set1, HashSet`1<T> set2, IEqualityComparer`1<T> comparer);
    private static bool AreEqualityComparersEqual(HashSet`1<T> set1, HashSet`1<T> set2);
    private int InternalGetHashCode(T item);
}
internal class System.Collections.Generic.HashSetEqualityComparer`1 : object {
    private IEqualityComparer`1<T> _comparer;
    public sealed virtual bool Equals(HashSet`1<T> x, HashSet`1<T> y);
    public sealed virtual int GetHashCode(HashSet`1<T> obj);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class System.Collections.Generic.ICollectionDebugView`1 : object {
    private ICollection`1<T> _collection;
    [DebuggerBrowsableAttribute("3")]
public T[] Items { get; }
    public ICollectionDebugView`1(ICollection`1<T> collection);
    public T[] get_Items();
}
internal class System.Collections.Generic.LargeArrayBuilder`1 : ValueType {
    private static int StartingCapacity;
    private static int ResizeLimit;
    private int _maxCapacity;
    private T[] _first;
    private ArrayBuilder`1<T[]> _buffers;
    private T[] _current;
    private int _index;
    private int _count;
    public int Count { get; }
    public LargeArrayBuilder`1(bool initialize);
    public LargeArrayBuilder`1(int maxCapacity);
    public int get_Count();
    public void Add(T item);
    private void AddWithBufferAllocation(T item);
    public void AddRange(IEnumerable`1<T> items);
    private void AddWithBufferAllocation(T item, T[]& destination, Int32& index);
    public void CopyTo(T[] array, int arrayIndex, int count);
    public CopyPosition CopyTo(CopyPosition position, T[] array, int arrayIndex, int count);
    public T[] GetBuffer(int index);
    public void SlowAdd(T item);
    public T[] ToArray();
    public bool TryMove(T[]& array);
    private void AllocateBuffer();
    [CompilerGeneratedAttribute]
internal static int <CopyTo>g__CopyToCore|17_0(T[] sourceBuffer, int sourceIndex, <>c__DisplayClass17_0& );
}
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
[IsReadOnlyAttribute]
internal class System.Collections.Generic.Marker : ValueType {
    [CompilerGeneratedAttribute]
private int <Count>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Index>k__BackingField;
    public int Count { get; }
    public int Index { get; }
    private string DebuggerDisplay { get; }
    public Marker(int count, int index);
    [CompilerGeneratedAttribute]
public int get_Count();
    [CompilerGeneratedAttribute]
public int get_Index();
    private string get_DebuggerDisplay();
}
internal class System.Collections.Generic.ReferenceEqualityComparer`1 : object {
    internal static ReferenceEqualityComparer`1<T> Instance;
    private static ReferenceEqualityComparer`1();
    public sealed virtual bool Equals(T x, T y);
    public sealed virtual int GetHashCode(T obj);
}
internal class System.Collections.Generic.SparseArrayBuilder`1 : ValueType {
    private LargeArrayBuilder`1<T> _builder;
    private ArrayBuilder`1<Marker> _markers;
    private int _reservedCount;
    public int Count { get; }
    public ArrayBuilder`1<Marker> Markers { get; }
    public SparseArrayBuilder`1(bool initialize);
    public int get_Count();
    public ArrayBuilder`1<Marker> get_Markers();
    public void Add(T item);
    public void AddRange(IEnumerable`1<T> items);
    public void CopyTo(T[] array, int arrayIndex, int count);
    public void Reserve(int count);
    public bool ReserveOrAdd(IEnumerable`1<T> items);
    public T[] ToArray();
}
public class System.Diagnostics.Eventing.EventDescriptor : ValueType {
    public byte Channel { get; }
    public int EventId { get; }
    public long Keywords { get; }
    public byte Level { get; }
    public byte Opcode { get; }
    public int Task { get; }
    public byte Version { get; }
    public EventDescriptor(int id, byte version, byte channel, byte level, byte opcode, int task, long keywords);
    public byte get_Channel();
    public int get_EventId();
    public long get_Keywords();
    public byte get_Level();
    public byte get_Opcode();
    public int get_Task();
    public byte get_Version();
}
public class System.Diagnostics.Eventing.EventProvider : object {
    [SecuritySafeCriticalAttribute]
public EventProvider(Guid providerGuid);
    public virtual void Close();
    [SecurityCriticalAttribute]
public static Guid CreateActivityId();
    public sealed virtual void Dispose();
    [SecuritySafeCriticalAttribute]
protected virtual void Dispose(bool disposing);
    public static WriteEventErrorCode GetLastWriteEventError();
    public bool IsEnabled();
    public bool IsEnabled(byte level, long keywords);
    [SecurityCriticalAttribute]
public static void SetActivityId(Guid& id);
    [SecurityCriticalAttribute]
protected bool WriteEvent(EventDescriptor& eventDescriptor, int dataCount, IntPtr data);
    public bool WriteEvent(EventDescriptor& eventDescriptor, Object[] eventPayload);
    [SecurityCriticalAttribute]
public bool WriteEvent(EventDescriptor& eventDescriptor, string data);
    public bool WriteMessageEvent(string eventMessage);
    [SecurityCriticalAttribute]
public bool WriteMessageEvent(string eventMessage, byte eventLevel, long eventKeywords);
    [SecurityCriticalAttribute]
protected bool WriteTransferEvent(EventDescriptor& eventDescriptor, Guid relatedActivityId, int dataCount, IntPtr data);
    [SecurityCriticalAttribute]
public bool WriteTransferEvent(EventDescriptor& eventDescriptor, Guid relatedActivityId, Object[] eventPayload);
}
public class System.Diagnostics.Eventing.EventProviderTraceListener : TraceListener {
    public string Delimiter { get; public set; }
    public EventProviderTraceListener(string providerId);
    public EventProviderTraceListener(string providerId, string name);
    public EventProviderTraceListener(string providerId, string name, string delimiter);
    public string get_Delimiter();
    public void set_Delimiter(string value);
    public sealed virtual void Write(string message);
    public sealed virtual void WriteLine(string message);
}
public class System.Diagnostics.Eventing.Reader.EventBookmark : object {
    protected EventBookmark(SerializationInfo info, StreamingContext context);
    [SecurityCriticalAttribute]
protected virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    [SecurityCriticalAttribute]
private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
}
public class System.Diagnostics.Eventing.Reader.EventKeyword : object {
    public string DisplayName { get; }
    public string Name { get; }
    public long Value { get; }
    public string get_DisplayName();
    public string get_Name();
    public long get_Value();
}
public class System.Diagnostics.Eventing.Reader.EventLevel : object {
    public string DisplayName { get; }
    public string Name { get; }
    public int Value { get; }
    public string get_DisplayName();
    public string get_Name();
    public int get_Value();
}
public class System.Diagnostics.Eventing.Reader.EventLogConfiguration : object {
    public bool IsClassicLog { get; }
    public bool IsEnabled { get; public set; }
    public string LogFilePath { get; public set; }
    public EventLogIsolation LogIsolation { get; }
    public EventLogMode LogMode { get; public set; }
    public string LogName { get; }
    public EventLogType LogType { get; }
    public long MaximumSizeInBytes { get; public set; }
    public string OwningProviderName { get; }
    public Nullable`1<int> ProviderBufferSize { get; }
    public Nullable`1<Guid> ProviderControlGuid { get; }
    public Nullable`1<long> ProviderKeywords { get; public set; }
    public Nullable`1<int> ProviderLatency { get; }
    public Nullable`1<int> ProviderLevel { get; public set; }
    public Nullable`1<int> ProviderMaximumNumberOfBuffers { get; }
    public Nullable`1<int> ProviderMinimumNumberOfBuffers { get; }
    public IEnumerable`1<string> ProviderNames { get; }
    public string SecurityDescriptor { get; public set; }
    public EventLogConfiguration(string logName);
    [SecurityCriticalAttribute]
public EventLogConfiguration(string logName, EventLogSession session);
    public bool get_IsClassicLog();
    public bool get_IsEnabled();
    public void set_IsEnabled(bool value);
    public string get_LogFilePath();
    public void set_LogFilePath(string value);
    public EventLogIsolation get_LogIsolation();
    public EventLogMode get_LogMode();
    public void set_LogMode(EventLogMode value);
    public string get_LogName();
    public EventLogType get_LogType();
    public long get_MaximumSizeInBytes();
    public void set_MaximumSizeInBytes(long value);
    public string get_OwningProviderName();
    public Nullable`1<int> get_ProviderBufferSize();
    public Nullable`1<Guid> get_ProviderControlGuid();
    public Nullable`1<long> get_ProviderKeywords();
    public void set_ProviderKeywords(Nullable`1<long> value);
    public Nullable`1<int> get_ProviderLatency();
    public Nullable`1<int> get_ProviderLevel();
    public void set_ProviderLevel(Nullable`1<int> value);
    public Nullable`1<int> get_ProviderMaximumNumberOfBuffers();
    public Nullable`1<int> get_ProviderMinimumNumberOfBuffers();
    public IEnumerable`1<string> get_ProviderNames();
    public string get_SecurityDescriptor();
    public void set_SecurityDescriptor(string value);
    public sealed virtual void Dispose();
    [SecuritySafeCriticalAttribute]
protected virtual void Dispose(bool disposing);
    public void SaveChanges();
}
public class System.Diagnostics.Eventing.Reader.EventLogException : Exception {
    protected EventLogException(int errorCode);
    protected EventLogException(SerializationInfo serializationInfo, StreamingContext streamingContext);
    public EventLogException(string message);
    public EventLogException(string message, Exception innerException);
}
public class System.Diagnostics.Eventing.Reader.EventLogInformation : object {
    public Nullable`1<int> Attributes { get; }
    public Nullable`1<DateTime> CreationTime { get; }
    public Nullable`1<long> FileSize { get; }
    public Nullable`1<bool> IsLogFull { get; }
    public Nullable`1<DateTime> LastAccessTime { get; }
    public Nullable`1<DateTime> LastWriteTime { get; }
    public Nullable`1<long> OldestRecordNumber { get; }
    public Nullable`1<long> RecordCount { get; }
    public Nullable`1<int> get_Attributes();
    public Nullable`1<DateTime> get_CreationTime();
    public Nullable`1<long> get_FileSize();
    public Nullable`1<bool> get_IsLogFull();
    public Nullable`1<DateTime> get_LastAccessTime();
    public Nullable`1<DateTime> get_LastWriteTime();
    public Nullable`1<long> get_OldestRecordNumber();
    public Nullable`1<long> get_RecordCount();
}
public class System.Diagnostics.Eventing.Reader.EventLogInvalidDataException : EventLogException {
    protected EventLogInvalidDataException(SerializationInfo serializationInfo, StreamingContext streamingContext);
    public EventLogInvalidDataException(string message);
    public EventLogInvalidDataException(string message, Exception innerException);
}
public enum System.Diagnostics.Eventing.Reader.EventLogIsolation : Enum {
    public int value__;
    public static EventLogIsolation Application;
    public static EventLogIsolation Custom;
    public static EventLogIsolation System;
}
public class System.Diagnostics.Eventing.Reader.EventLogLink : object {
    public string DisplayName { get; }
    public bool IsImported { get; }
    public string LogName { get; }
    public string get_DisplayName();
    public bool get_IsImported();
    public string get_LogName();
}
public enum System.Diagnostics.Eventing.Reader.EventLogMode : Enum {
    public int value__;
    public static EventLogMode AutoBackup;
    public static EventLogMode Circular;
    public static EventLogMode Retain;
}
public class System.Diagnostics.Eventing.Reader.EventLogNotFoundException : EventLogException {
    protected EventLogNotFoundException(SerializationInfo serializationInfo, StreamingContext streamingContext);
    public EventLogNotFoundException(string message);
    public EventLogNotFoundException(string message, Exception innerException);
}
public class System.Diagnostics.Eventing.Reader.EventLogPropertySelector : object {
    [SecurityCriticalAttribute]
public EventLogPropertySelector(IEnumerable`1<string> propertyQueries);
    public sealed virtual void Dispose();
    [SecuritySafeCriticalAttribute]
protected virtual void Dispose(bool disposing);
}
public class System.Diagnostics.Eventing.Reader.EventLogProviderDisabledException : EventLogException {
    protected EventLogProviderDisabledException(SerializationInfo serializationInfo, StreamingContext streamingContext);
    public EventLogProviderDisabledException(string message);
    public EventLogProviderDisabledException(string message, Exception innerException);
}
public class System.Diagnostics.Eventing.Reader.EventLogQuery : object {
    public bool ReverseDirection { get; public set; }
    public EventLogSession Session { get; public set; }
    public bool TolerateQueryErrors { get; public set; }
    public EventLogQuery(string path, PathType pathType);
    public EventLogQuery(string path, PathType pathType, string query);
    public bool get_ReverseDirection();
    public void set_ReverseDirection(bool value);
    public EventLogSession get_Session();
    public void set_Session(EventLogSession value);
    public bool get_TolerateQueryErrors();
    public void set_TolerateQueryErrors(bool value);
}
public class System.Diagnostics.Eventing.Reader.EventLogReader : object {
    public int BatchSize { get; public set; }
    public IList`1<EventLogStatus> LogStatus { get; }
    public EventLogReader(EventLogQuery eventQuery);
    [SecurityCriticalAttribute]
public EventLogReader(EventLogQuery eventQuery, EventBookmark bookmark);
    public EventLogReader(string path);
    public EventLogReader(string path, PathType pathType);
    public int get_BatchSize();
    public void set_BatchSize(int value);
    [SecurityCriticalAttribute]
public IList`1<EventLogStatus> get_LogStatus();
    public void CancelReading();
    public sealed virtual void Dispose();
    [SecuritySafeCriticalAttribute]
protected virtual void Dispose(bool disposing);
    public EventRecord ReadEvent();
    [SecurityCriticalAttribute]
public EventRecord ReadEvent(TimeSpan timeout);
    public void Seek(EventBookmark bookmark);
    [SecurityCriticalAttribute]
public void Seek(EventBookmark bookmark, long offset);
    [SecurityCriticalAttribute]
public void Seek(SeekOrigin origin, long offset);
}
public class System.Diagnostics.Eventing.Reader.EventLogReadingException : EventLogException {
    protected EventLogReadingException(SerializationInfo serializationInfo, StreamingContext streamingContext);
    public EventLogReadingException(string message);
    public EventLogReadingException(string message, Exception innerException);
}
public class System.Diagnostics.Eventing.Reader.EventLogRecord : EventRecord {
    public Nullable`1<Guid> ActivityId { get; }
    public EventBookmark Bookmark { get; }
    public string ContainerLog { get; }
    public int Id { get; }
    public Nullable`1<long> Keywords { get; }
    public IEnumerable`1<string> KeywordsDisplayNames { get; }
    public Nullable`1<byte> Level { get; }
    public string LevelDisplayName { get; }
    public string LogName { get; }
    public string MachineName { get; }
    public IEnumerable`1<int> MatchedQueryIds { get; }
    public Nullable`1<short> Opcode { get; }
    public string OpcodeDisplayName { get; }
    public Nullable`1<int> ProcessId { get; }
    public IList`1<EventProperty> Properties { get; }
    public Nullable`1<Guid> ProviderId { get; }
    public string ProviderName { get; }
    public Nullable`1<int> Qualifiers { get; }
    public Nullable`1<long> RecordId { get; }
    public Nullable`1<Guid> RelatedActivityId { get; }
    public Nullable`1<int> Task { get; }
    public string TaskDisplayName { get; }
    public Nullable`1<int> ThreadId { get; }
    public Nullable`1<DateTime> TimeCreated { get; }
    public SecurityIdentifier UserId { get; }
    public Nullable`1<byte> Version { get; }
    public virtual Nullable`1<Guid> get_ActivityId();
    [SecuritySafeCriticalAttribute]
public virtual EventBookmark get_Bookmark();
    public string get_ContainerLog();
    public virtual int get_Id();
    public virtual Nullable`1<long> get_Keywords();
    public virtual IEnumerable`1<string> get_KeywordsDisplayNames();
    public virtual Nullable`1<byte> get_Level();
    public virtual string get_LevelDisplayName();
    public virtual string get_LogName();
    public virtual string get_MachineName();
    public IEnumerable`1<int> get_MatchedQueryIds();
    public virtual Nullable`1<short> get_Opcode();
    public virtual string get_OpcodeDisplayName();
    public virtual Nullable`1<int> get_ProcessId();
    public virtual IList`1<EventProperty> get_Properties();
    public virtual Nullable`1<Guid> get_ProviderId();
    public virtual string get_ProviderName();
    public virtual Nullable`1<int> get_Qualifiers();
    public virtual Nullable`1<long> get_RecordId();
    public virtual Nullable`1<Guid> get_RelatedActivityId();
    public virtual Nullable`1<int> get_Task();
    public virtual string get_TaskDisplayName();
    public virtual Nullable`1<int> get_ThreadId();
    public virtual Nullable`1<DateTime> get_TimeCreated();
    public virtual SecurityIdentifier get_UserId();
    public virtual Nullable`1<byte> get_Version();
    [SecuritySafeCriticalAttribute]
protected virtual void Dispose(bool disposing);
    public virtual string FormatDescription();
    public virtual string FormatDescription(IEnumerable`1<object> values);
    public IList`1<object> GetPropertyValues(EventLogPropertySelector propertySelector);
    [SecuritySafeCriticalAttribute]
public virtual string ToXml();
}
public class System.Diagnostics.Eventing.Reader.EventLogSession : object {
    public static EventLogSession GlobalSession { get; }
    public EventLogSession(string server);
    [SecurityCriticalAttribute]
public EventLogSession(string server, string domain, string user, SecureString password, SessionAuthentication logOnType);
    public static EventLogSession get_GlobalSession();
    public void CancelCurrentOperations();
    public void ClearLog(string logName);
    public void ClearLog(string logName, string backupPath);
    public sealed virtual void Dispose();
    [SecuritySafeCriticalAttribute]
protected virtual void Dispose(bool disposing);
    public void ExportLog(string path, PathType pathType, string query, string targetFilePath);
    public void ExportLog(string path, PathType pathType, string query, string targetFilePath, bool tolerateQueryErrors);
    public void ExportLogAndMessages(string path, PathType pathType, string query, string targetFilePath);
    public void ExportLogAndMessages(string path, PathType pathType, string query, string targetFilePath, bool tolerateQueryErrors, CultureInfo targetCultureInfo);
    public EventLogInformation GetLogInformation(string logName, PathType pathType);
    [SecurityCriticalAttribute]
public IEnumerable`1<string> GetLogNames();
    [SecurityCriticalAttribute]
public IEnumerable`1<string> GetProviderNames();
}
public class System.Diagnostics.Eventing.Reader.EventLogStatus : object {
    public string LogName { get; }
    public int StatusCode { get; }
    public string get_LogName();
    public int get_StatusCode();
}
public enum System.Diagnostics.Eventing.Reader.EventLogType : Enum {
    public int value__;
    public static EventLogType Administrative;
    public static EventLogType Analytical;
    public static EventLogType Debug;
    public static EventLogType Operational;
}
public class System.Diagnostics.Eventing.Reader.EventLogWatcher : object {
    public bool Enabled { get; public set; }
    public EventLogWatcher(EventLogQuery eventQuery);
    public EventLogWatcher(EventLogQuery eventQuery, EventBookmark bookmark);
    public EventLogWatcher(EventLogQuery eventQuery, EventBookmark bookmark, bool readExistingEvents);
    public EventLogWatcher(string path);
    public bool get_Enabled();
    public void set_Enabled(bool value);
    public void add_EventRecordWritten(EventHandler`1<EventRecordWrittenEventArgs> value);
    public void remove_EventRecordWritten(EventHandler`1<EventRecordWrittenEventArgs> value);
    public sealed virtual void Dispose();
    [SecuritySafeCriticalAttribute]
protected virtual void Dispose(bool disposing);
}
public class System.Diagnostics.Eventing.Reader.EventMetadata : object {
    public string Description { get; }
    public long Id { get; }
    public IEnumerable`1<EventKeyword> Keywords { get; }
    public EventLevel Level { get; }
    public EventLogLink LogLink { get; }
    public EventOpcode Opcode { get; }
    public EventTask Task { get; }
    public string Template { get; }
    public byte Version { get; }
    public string get_Description();
    public long get_Id();
    public IEnumerable`1<EventKeyword> get_Keywords();
    public EventLevel get_Level();
    public EventLogLink get_LogLink();
    public EventOpcode get_Opcode();
    public EventTask get_Task();
    public string get_Template();
    public byte get_Version();
}
public class System.Diagnostics.Eventing.Reader.EventOpcode : object {
    public string DisplayName { get; }
    public string Name { get; }
    public int Value { get; }
    public string get_DisplayName();
    public string get_Name();
    public int get_Value();
}
public class System.Diagnostics.Eventing.Reader.EventProperty : object {
    public object Value { get; }
    public object get_Value();
}
public abstract class System.Diagnostics.Eventing.Reader.EventRecord : object {
    public Nullable`1<Guid> ActivityId { get; }
    public EventBookmark Bookmark { get; }
    public int Id { get; }
    public Nullable`1<long> Keywords { get; }
    public IEnumerable`1<string> KeywordsDisplayNames { get; }
    public Nullable`1<byte> Level { get; }
    public string LevelDisplayName { get; }
    public string LogName { get; }
    public string MachineName { get; }
    public Nullable`1<short> Opcode { get; }
    public string OpcodeDisplayName { get; }
    public Nullable`1<int> ProcessId { get; }
    public IList`1<EventProperty> Properties { get; }
    public Nullable`1<Guid> ProviderId { get; }
    public string ProviderName { get; }
    public Nullable`1<int> Qualifiers { get; }
    public Nullable`1<long> RecordId { get; }
    public Nullable`1<Guid> RelatedActivityId { get; }
    public Nullable`1<int> Task { get; }
    public string TaskDisplayName { get; }
    public Nullable`1<int> ThreadId { get; }
    public Nullable`1<DateTime> TimeCreated { get; }
    public SecurityIdentifier UserId { get; }
    public Nullable`1<byte> Version { get; }
    public abstract virtual Nullable`1<Guid> get_ActivityId();
    public abstract virtual EventBookmark get_Bookmark();
    public abstract virtual int get_Id();
    public abstract virtual Nullable`1<long> get_Keywords();
    public abstract virtual IEnumerable`1<string> get_KeywordsDisplayNames();
    public abstract virtual Nullable`1<byte> get_Level();
    public abstract virtual string get_LevelDisplayName();
    public abstract virtual string get_LogName();
    public abstract virtual string get_MachineName();
    public abstract virtual Nullable`1<short> get_Opcode();
    public abstract virtual string get_OpcodeDisplayName();
    public abstract virtual Nullable`1<int> get_ProcessId();
    public abstract virtual IList`1<EventProperty> get_Properties();
    public abstract virtual Nullable`1<Guid> get_ProviderId();
    public abstract virtual string get_ProviderName();
    public abstract virtual Nullable`1<int> get_Qualifiers();
    public abstract virtual Nullable`1<long> get_RecordId();
    public abstract virtual Nullable`1<Guid> get_RelatedActivityId();
    public abstract virtual Nullable`1<int> get_Task();
    public abstract virtual string get_TaskDisplayName();
    public abstract virtual Nullable`1<int> get_ThreadId();
    public abstract virtual Nullable`1<DateTime> get_TimeCreated();
    public abstract virtual SecurityIdentifier get_UserId();
    public abstract virtual Nullable`1<byte> get_Version();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public abstract virtual string FormatDescription();
    public abstract virtual string FormatDescription(IEnumerable`1<object> values);
    public abstract virtual string ToXml();
}
public class System.Diagnostics.Eventing.Reader.EventRecordWrittenEventArgs : EventArgs {
    public Exception EventException { get; }
    public EventRecord EventRecord { get; }
    public Exception get_EventException();
    public EventRecord get_EventRecord();
}
public class System.Diagnostics.Eventing.Reader.EventTask : object {
    public string DisplayName { get; }
    public Guid EventGuid { get; }
    public string Name { get; }
    public int Value { get; }
    public string get_DisplayName();
    public Guid get_EventGuid();
    public string get_Name();
    public int get_Value();
}
public enum System.Diagnostics.Eventing.Reader.PathType : Enum {
    public int value__;
    public static PathType FilePath;
    public static PathType LogName;
}
public class System.Diagnostics.Eventing.Reader.ProviderMetadata : object {
    public string DisplayName { get; }
    public IEnumerable`1<EventMetadata> Events { get; }
    public Uri HelpLink { get; }
    public Guid Id { get; }
    public IList`1<EventKeyword> Keywords { get; }
    public IList`1<EventLevel> Levels { get; }
    public IList`1<EventLogLink> LogLinks { get; }
    public string MessageFilePath { get; }
    public string Name { get; }
    public IList`1<EventOpcode> Opcodes { get; }
    public string ParameterFilePath { get; }
    public string ResourceFilePath { get; }
    public IList`1<EventTask> Tasks { get; }
    public ProviderMetadata(string providerName);
    public ProviderMetadata(string providerName, EventLogSession session, CultureInfo targetCultureInfo);
    [SecurityCriticalAttribute]
public string get_DisplayName();
    [SecurityCriticalAttribute]
public IEnumerable`1<EventMetadata> get_Events();
    public Uri get_HelpLink();
    public Guid get_Id();
    public IList`1<EventKeyword> get_Keywords();
    public IList`1<EventLevel> get_Levels();
    [SecurityCriticalAttribute]
public IList`1<EventLogLink> get_LogLinks();
    public string get_MessageFilePath();
    public string get_Name();
    public IList`1<EventOpcode> get_Opcodes();
    public string get_ParameterFilePath();
    public string get_ResourceFilePath();
    public IList`1<EventTask> get_Tasks();
    public sealed virtual void Dispose();
    [SecuritySafeCriticalAttribute]
protected virtual void Dispose(bool disposing);
}
public enum System.Diagnostics.Eventing.Reader.SessionAuthentication : Enum {
    public int value__;
    public static SessionAuthentication Default;
    public static SessionAuthentication Kerberos;
    public static SessionAuthentication Negotiate;
    public static SessionAuthentication Ntlm;
}
[FlagsAttribute]
public enum System.Diagnostics.Eventing.Reader.StandardEventKeywords : Enum {
    public long value__;
    public static StandardEventKeywords AuditFailure;
    public static StandardEventKeywords AuditSuccess;
    [ObsoleteAttribute("Incorrect value: use CorrelationHint2 instead", "False")]
public static StandardEventKeywords CorrelationHint;
    public static StandardEventKeywords CorrelationHint2;
    public static StandardEventKeywords EventLogClassic;
    public static StandardEventKeywords None;
    public static StandardEventKeywords ResponseTime;
    public static StandardEventKeywords Sqm;
    public static StandardEventKeywords WdiContext;
    public static StandardEventKeywords WdiDiagnostic;
}
public enum System.Diagnostics.Eventing.Reader.StandardEventLevel : Enum {
    public int value__;
    public static StandardEventLevel Critical;
    public static StandardEventLevel Error;
    public static StandardEventLevel Informational;
    public static StandardEventLevel LogAlways;
    public static StandardEventLevel Verbose;
    public static StandardEventLevel Warning;
}
public enum System.Diagnostics.Eventing.Reader.StandardEventOpcode : Enum {
    public int value__;
    public static StandardEventOpcode DataCollectionStart;
    public static StandardEventOpcode DataCollectionStop;
    public static StandardEventOpcode Extension;
    public static StandardEventOpcode Info;
    public static StandardEventOpcode Receive;
    public static StandardEventOpcode Reply;
    public static StandardEventOpcode Resume;
    public static StandardEventOpcode Send;
    public static StandardEventOpcode Start;
    public static StandardEventOpcode Stop;
    public static StandardEventOpcode Suspend;
}
public enum System.Diagnostics.Eventing.Reader.StandardEventTask : Enum {
    public int value__;
    public static StandardEventTask None;
}
public class System.Diagnostics.EventSchemaTraceListener : TextWriterTraceListener {
    public int BufferSize { get; }
    public long MaximumFileSize { get; }
    public int MaximumNumberOfFiles { get; }
    public TraceLogRetentionOption TraceLogRetentionOption { get; }
    public EventSchemaTraceListener(string fileName);
    public EventSchemaTraceListener(string fileName, string name);
    public EventSchemaTraceListener(string fileName, string name, int bufferSize);
    public EventSchemaTraceListener(string fileName, string name, int bufferSize, TraceLogRetentionOption logRetentionOption);
    public EventSchemaTraceListener(string fileName, string name, int bufferSize, TraceLogRetentionOption logRetentionOption, long maximumFileSize);
    public EventSchemaTraceListener(string fileName, string name, int bufferSize, TraceLogRetentionOption logRetentionOption, long maximumFileSize, int maximumNumberOfFiles);
    public int get_BufferSize();
    public long get_MaximumFileSize();
    public int get_MaximumNumberOfFiles();
    public TraceLogRetentionOption get_TraceLogRetentionOption();
}
public class System.Diagnostics.PerformanceData.CounterData : object {
    public long RawValue { get; public set; }
    public long Value { get; public set; }
    [SecurityCriticalAttribute]
public long get_RawValue();
    [SecurityCriticalAttribute]
public void set_RawValue(long value);
    [SecurityCriticalAttribute]
public long get_Value();
    [SecurityCriticalAttribute]
public void set_Value(long value);
    [SecurityCriticalAttribute]
public void Decrement();
    [SecurityCriticalAttribute]
public void Increment();
    [SecurityCriticalAttribute]
public void IncrementBy(long value);
}
public class System.Diagnostics.PerformanceData.CounterSet : object {
    [SecuritySafeCriticalAttribute]
public CounterSet(Guid providerGuid, Guid counterSetGuid, CounterSetInstanceType instanceType);
    public void AddCounter(int counterId, CounterType counterType);
    public void AddCounter(int counterId, CounterType counterType, string counterName);
    [SecuritySafeCriticalAttribute]
public CounterSetInstance CreateCounterSetInstance(string instanceName);
    public sealed virtual void Dispose();
    [SecuritySafeCriticalAttribute]
protected virtual void Dispose(bool disposing);
}
public class System.Diagnostics.PerformanceData.CounterSetInstance : object {
    public CounterSetInstanceCounterDataSet Counters { get; }
    public CounterSetInstanceCounterDataSet get_Counters();
    [SecurityCriticalAttribute]
public sealed virtual void Dispose();
}
[DefaultMemberAttribute("Item")]
public class System.Diagnostics.PerformanceData.CounterSetInstanceCounterDataSet : object {
    public CounterData Item { get; }
    public CounterData get_Item(int counterId);
    public CounterData get_Item(string counterName);
    [SecurityCriticalAttribute]
public sealed virtual void Dispose();
}
public enum System.Diagnostics.PerformanceData.CounterSetInstanceType : Enum {
    public int value__;
    public static CounterSetInstanceType GlobalAggregate;
    public static CounterSetInstanceType GlobalAggregateWithHistory;
    public static CounterSetInstanceType InstanceAggregate;
    public static CounterSetInstanceType Multiple;
    public static CounterSetInstanceType MultipleAggregate;
    public static CounterSetInstanceType Single;
}
public enum System.Diagnostics.PerformanceData.CounterType : Enum {
    public int value__;
    public static CounterType AverageBase;
    public static CounterType AverageCount64;
    public static CounterType AverageTimer32;
    public static CounterType Delta32;
    public static CounterType Delta64;
    public static CounterType ElapsedTime;
    public static CounterType LargeQueueLength;
    public static CounterType MultiTimerBase;
    public static CounterType MultiTimerPercentageActive;
    public static CounterType MultiTimerPercentageActive100Ns;
    public static CounterType MultiTimerPercentageNotActive;
    public static CounterType MultiTimerPercentageNotActive100Ns;
    public static CounterType ObjectSpecificTimer;
    public static CounterType PercentageActive;
    public static CounterType PercentageActive100Ns;
    public static CounterType PercentageNotActive;
    public static CounterType PercentageNotActive100Ns;
    public static CounterType PrecisionObjectSpecificTimer;
    public static CounterType PrecisionSystemTimer;
    public static CounterType PrecisionTimer100Ns;
    public static CounterType QueueLength;
    public static CounterType QueueLength100Ns;
    public static CounterType QueueLengthObjectTime;
    public static CounterType RateOfCountPerSecond32;
    public static CounterType RateOfCountPerSecond64;
    public static CounterType RawBase32;
    public static CounterType RawBase64;
    public static CounterType RawData32;
    public static CounterType RawData64;
    public static CounterType RawDataHex32;
    public static CounterType RawDataHex64;
    public static CounterType RawFraction32;
    public static CounterType RawFraction64;
    public static CounterType SampleBase;
    public static CounterType SampleCounter;
    public static CounterType SampleFraction;
}
public enum System.Diagnostics.TraceLogRetentionOption : Enum {
    public int value__;
    public static TraceLogRetentionOption LimitedCircularFiles;
    public static TraceLogRetentionOption LimitedSequentialFiles;
    public static TraceLogRetentionOption SingleFileBoundedSize;
    public static TraceLogRetentionOption SingleFileUnboundedSize;
    public static TraceLogRetentionOption UnlimitedSequentialFiles;
}
public class System.Diagnostics.UnescapedXmlDiagnosticData : object {
    public string UnescapedXml { get; public set; }
    public UnescapedXmlDiagnosticData(string xmlPayload);
    public string get_UnescapedXml();
    public void set_UnescapedXml(string value);
}
public abstract class System.Dynamic.BinaryOperationBinder : DynamicMetaObjectBinder {
    [CompilerGeneratedAttribute]
private ExpressionType <Operation>k__BackingField;
    public Type ReturnType { get; }
    public ExpressionType Operation { get; }
    internal bool IsStandardBinder { get; }
    protected BinaryOperationBinder(ExpressionType operation);
    public sealed virtual Type get_ReturnType();
    [CompilerGeneratedAttribute]
public ExpressionType get_Operation();
    public DynamicMetaObject FallbackBinaryOperation(DynamicMetaObject target, DynamicMetaObject arg);
    public abstract virtual DynamicMetaObject FallbackBinaryOperation(DynamicMetaObject target, DynamicMetaObject arg, DynamicMetaObject errorSuggestion);
    public sealed virtual DynamicMetaObject Bind(DynamicMetaObject target, DynamicMetaObject[] args);
    internal sealed virtual bool get_IsStandardBinder();
    internal static bool OperationIsValid(ExpressionType operation);
}
[DebuggerTypeProxyAttribute("System.Dynamic.BindingRestrictions/BindingRestrictionsProxy")]
[DebuggerDisplayAttribute("{DebugView}")]
public abstract class System.Dynamic.BindingRestrictions : object {
    public static BindingRestrictions Empty;
    private static int TypeRestrictionHash;
    private static int InstanceRestrictionHash;
    private static int CustomRestrictionHash;
    private string DebugView { get; }
    private static BindingRestrictions();
    internal abstract virtual Expression GetExpression();
    public BindingRestrictions Merge(BindingRestrictions restrictions);
    public static BindingRestrictions GetTypeRestriction(Expression expression, Type type);
    internal static BindingRestrictions GetTypeRestriction(DynamicMetaObject obj);
    public static BindingRestrictions GetInstanceRestriction(Expression expression, object instance);
    public static BindingRestrictions GetExpressionRestriction(Expression expression);
    public static BindingRestrictions Combine(IList`1<DynamicMetaObject> contributingObjects);
    public Expression ToExpression();
    private string get_DebugView();
}
public class System.Dynamic.CallInfo : object {
    [CompilerGeneratedAttribute]
private int <ArgumentCount>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadOnlyCollection`1<string> <ArgumentNames>k__BackingField;
    public int ArgumentCount { get; }
    public ReadOnlyCollection`1<string> ArgumentNames { get; }
    public CallInfo(int argCount, String[] argNames);
    public CallInfo(int argCount, IEnumerable`1<string> argNames);
    [CompilerGeneratedAttribute]
public int get_ArgumentCount();
    [CompilerGeneratedAttribute]
public ReadOnlyCollection`1<string> get_ArgumentNames();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
}
public abstract class System.Dynamic.ConvertBinder : DynamicMetaObjectBinder {
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Explicit>k__BackingField;
    public Type Type { get; }
    public bool Explicit { get; }
    internal bool IsStandardBinder { get; }
    public Type ReturnType { get; }
    protected ConvertBinder(Type type, bool explicit);
    [CompilerGeneratedAttribute]
public Type get_Type();
    [CompilerGeneratedAttribute]
public bool get_Explicit();
    public DynamicMetaObject FallbackConvert(DynamicMetaObject target);
    public abstract virtual DynamicMetaObject FallbackConvert(DynamicMetaObject target, DynamicMetaObject errorSuggestion);
    public sealed virtual DynamicMetaObject Bind(DynamicMetaObject target, DynamicMetaObject[] args);
    internal sealed virtual bool get_IsStandardBinder();
    public sealed virtual Type get_ReturnType();
}
public abstract class System.Dynamic.CreateInstanceBinder : DynamicMetaObjectBinder {
    [CompilerGeneratedAttribute]
private CallInfo <CallInfo>k__BackingField;
    public Type ReturnType { get; }
    public CallInfo CallInfo { get; }
    internal bool IsStandardBinder { get; }
    protected CreateInstanceBinder(CallInfo callInfo);
    public sealed virtual Type get_ReturnType();
    [CompilerGeneratedAttribute]
public CallInfo get_CallInfo();
    public DynamicMetaObject FallbackCreateInstance(DynamicMetaObject target, DynamicMetaObject[] args);
    public abstract virtual DynamicMetaObject FallbackCreateInstance(DynamicMetaObject target, DynamicMetaObject[] args, DynamicMetaObject errorSuggestion);
    public sealed virtual DynamicMetaObject Bind(DynamicMetaObject target, DynamicMetaObject[] args);
    internal sealed virtual bool get_IsStandardBinder();
}
public abstract class System.Dynamic.DeleteIndexBinder : DynamicMetaObjectBinder {
    [CompilerGeneratedAttribute]
private CallInfo <CallInfo>k__BackingField;
    public Type ReturnType { get; }
    public CallInfo CallInfo { get; }
    internal bool IsStandardBinder { get; }
    protected DeleteIndexBinder(CallInfo callInfo);
    public sealed virtual Type get_ReturnType();
    [CompilerGeneratedAttribute]
public CallInfo get_CallInfo();
    public sealed virtual DynamicMetaObject Bind(DynamicMetaObject target, DynamicMetaObject[] args);
    internal sealed virtual bool get_IsStandardBinder();
    public DynamicMetaObject FallbackDeleteIndex(DynamicMetaObject target, DynamicMetaObject[] indexes);
    public abstract virtual DynamicMetaObject FallbackDeleteIndex(DynamicMetaObject target, DynamicMetaObject[] indexes, DynamicMetaObject errorSuggestion);
}
public abstract class System.Dynamic.DeleteMemberBinder : DynamicMetaObjectBinder {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreCase>k__BackingField;
    public string Name { get; }
    public bool IgnoreCase { get; }
    public Type ReturnType { get; }
    internal bool IsStandardBinder { get; }
    protected DeleteMemberBinder(string name, bool ignoreCase);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public bool get_IgnoreCase();
    public sealed virtual Type get_ReturnType();
    public DynamicMetaObject FallbackDeleteMember(DynamicMetaObject target);
    public abstract virtual DynamicMetaObject FallbackDeleteMember(DynamicMetaObject target, DynamicMetaObject errorSuggestion);
    public sealed virtual DynamicMetaObject Bind(DynamicMetaObject target, DynamicMetaObject[] args);
    internal sealed virtual bool get_IsStandardBinder();
}
public class System.Dynamic.DynamicMetaObject : object {
    public static DynamicMetaObject[] EmptyMetaObjects;
    private static object s_noValueSentinel;
    private object _value;
    [CompilerGeneratedAttribute]
private Expression <Expression>k__BackingField;
    [CompilerGeneratedAttribute]
private BindingRestrictions <Restrictions>k__BackingField;
    public Expression Expression { get; }
    public BindingRestrictions Restrictions { get; }
    public object Value { get; }
    public bool HasValue { get; }
    public Type RuntimeType { get; }
    public Type LimitType { get; }
    public DynamicMetaObject(Expression expression, BindingRestrictions restrictions);
    public DynamicMetaObject(Expression expression, BindingRestrictions restrictions, object value);
    private static DynamicMetaObject();
    [CompilerGeneratedAttribute]
public Expression get_Expression();
    [CompilerGeneratedAttribute]
public BindingRestrictions get_Restrictions();
    public object get_Value();
    public bool get_HasValue();
    public Type get_RuntimeType();
    public Type get_LimitType();
    public virtual DynamicMetaObject BindConvert(ConvertBinder binder);
    public virtual DynamicMetaObject BindGetMember(GetMemberBinder binder);
    public virtual DynamicMetaObject BindSetMember(SetMemberBinder binder, DynamicMetaObject value);
    public virtual DynamicMetaObject BindDeleteMember(DeleteMemberBinder binder);
    public virtual DynamicMetaObject BindGetIndex(GetIndexBinder binder, DynamicMetaObject[] indexes);
    public virtual DynamicMetaObject BindSetIndex(SetIndexBinder binder, DynamicMetaObject[] indexes, DynamicMetaObject value);
    public virtual DynamicMetaObject BindDeleteIndex(DeleteIndexBinder binder, DynamicMetaObject[] indexes);
    public virtual DynamicMetaObject BindInvokeMember(InvokeMemberBinder binder, DynamicMetaObject[] args);
    public virtual DynamicMetaObject BindInvoke(InvokeBinder binder, DynamicMetaObject[] args);
    public virtual DynamicMetaObject BindCreateInstance(CreateInstanceBinder binder, DynamicMetaObject[] args);
    public virtual DynamicMetaObject BindUnaryOperation(UnaryOperationBinder binder);
    public virtual DynamicMetaObject BindBinaryOperation(BinaryOperationBinder binder, DynamicMetaObject arg);
    public virtual IEnumerable`1<string> GetDynamicMemberNames();
    internal static Expression[] GetExpressions(DynamicMetaObject[] objects);
    public static DynamicMetaObject Create(object value, Expression expression);
}
public abstract class System.Dynamic.DynamicMetaObjectBinder : CallSiteBinder {
    public Type ReturnType { get; }
    internal bool IsStandardBinder { get; }
    public virtual Type get_ReturnType();
    public sealed virtual Expression Bind(Object[] args, ReadOnlyCollection`1<ParameterExpression> parameters, LabelTarget returnLabel);
    private static DynamicMetaObject[] CreateArgumentMetaObjects(Object[] args, ReadOnlyCollection`1<ParameterExpression> parameters);
    public abstract virtual DynamicMetaObject Bind(DynamicMetaObject target, DynamicMetaObject[] args);
    public Expression GetUpdateExpression(Type type);
    public DynamicMetaObject Defer(DynamicMetaObject target, DynamicMetaObject[] args);
    public DynamicMetaObject Defer(DynamicMetaObject[] args);
    private DynamicMetaObject MakeDeferred(BindingRestrictions rs, DynamicMetaObject[] args);
    internal virtual bool get_IsStandardBinder();
}
public class System.Dynamic.DynamicObject : object {
    public virtual bool TryGetMember(GetMemberBinder binder, Object& result);
    public virtual bool TrySetMember(SetMemberBinder binder, object value);
    public virtual bool TryDeleteMember(DeleteMemberBinder binder);
    public virtual bool TryInvokeMember(InvokeMemberBinder binder, Object[] args, Object& result);
    public virtual bool TryConvert(ConvertBinder binder, Object& result);
    public virtual bool TryCreateInstance(CreateInstanceBinder binder, Object[] args, Object& result);
    public virtual bool TryInvoke(InvokeBinder binder, Object[] args, Object& result);
    public virtual bool TryBinaryOperation(BinaryOperationBinder binder, object arg, Object& result);
    public virtual bool TryUnaryOperation(UnaryOperationBinder binder, Object& result);
    public virtual bool TryGetIndex(GetIndexBinder binder, Object[] indexes, Object& result);
    public virtual bool TrySetIndex(SetIndexBinder binder, Object[] indexes, object value);
    public virtual bool TryDeleteIndex(DeleteIndexBinder binder, Object[] indexes);
    public virtual IEnumerable`1<string> GetDynamicMemberNames();
    public virtual DynamicMetaObject GetMetaObject(Expression parameter);
}
internal class System.Dynamic.ExpandoClass : object {
    private String[] _keys;
    private int _hashCode;
    private Dictionary`2<int, List`1<WeakReference>> _transitions;
    private static int EmptyHashCode;
    internal static ExpandoClass Empty;
    internal String[] Keys { get; }
    internal ExpandoClass(String[] keys, int hashCode);
    private static ExpandoClass();
    internal ExpandoClass FindNewClass(string newKey);
    private List`1<WeakReference> GetTransitionList(int hashCode);
    internal int GetValueIndex(string name, bool caseInsensitive, ExpandoObject obj);
    internal int GetValueIndexCaseSensitive(string name);
    private int GetValueIndexCaseInsensitive(string name, ExpandoObject obj);
    internal String[] get_Keys();
}
public class System.Dynamic.ExpandoObject : object {
    private static MethodInfo s_expandoTryGetValue;
    private static MethodInfo s_expandoTrySetValue;
    private static MethodInfo s_expandoTryDeleteValue;
    private static MethodInfo s_expandoPromoteClass;
    private static MethodInfo s_expandoCheckVersion;
    internal object LockObject;
    private ExpandoData _data;
    private int _count;
    internal static object Uninitialized;
    internal static int AmbiguousMatchFound;
    internal static int NoMatch;
    private PropertyChangedEventHandler _propertyChanged;
    internal ExpandoClass Class { get; }
    private ICollection`1<string> System.Collections.Generic.IDictionary<System.String,System.Object>.Keys { get; }
    private ICollection`1<object> System.Collections.Generic.IDictionary<System.String,System.Object>.Values { get; }
    private object System.Collections.Generic.IDictionary<System.String,System.Object>.Item { get; private set; }
    private int System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.Count { get; }
    private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.IsReadOnly { get; }
    private static ExpandoObject();
    internal bool TryGetValue(object indexClass, int index, string name, bool ignoreCase, Object& value);
    internal void TrySetValue(object indexClass, int index, object value, string name, bool ignoreCase, bool add);
    internal bool TryDeleteValue(object indexClass, int index, string name, bool ignoreCase, object deleteValue);
    internal bool IsDeletedMember(int index);
    internal ExpandoClass get_Class();
    private ExpandoData PromoteClassCore(ExpandoClass oldClass, ExpandoClass newClass);
    internal void PromoteClass(object oldClass, object newClass);
    private sealed virtual override DynamicMetaObject System.Dynamic.IDynamicMetaObjectProvider.GetMetaObject(Expression parameter);
    private void TryAddMember(string key, object value);
    private bool TryGetValueForKey(string key, Object& value);
    private bool ExpandoContainsKey(string key);
    private sealed virtual override ICollection`1<string> System.Collections.Generic.IDictionary<System.String,System.Object>.get_Keys();
    private sealed virtual override ICollection`1<object> System.Collections.Generic.IDictionary<System.String,System.Object>.get_Values();
    private sealed virtual override object System.Collections.Generic.IDictionary<System.String,System.Object>.get_Item(string key);
    private sealed virtual override void System.Collections.Generic.IDictionary<System.String,System.Object>.set_Item(string key, object value);
    private sealed virtual override void System.Collections.Generic.IDictionary<System.String,System.Object>.Add(string key, object value);
    private sealed virtual override bool System.Collections.Generic.IDictionary<System.String,System.Object>.ContainsKey(string key);
    private sealed virtual override bool System.Collections.Generic.IDictionary<System.String,System.Object>.Remove(string key);
    private sealed virtual override bool System.Collections.Generic.IDictionary<System.String,System.Object>.TryGetValue(string key, Object& value);
    private sealed virtual override int System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.get_Count();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.get_IsReadOnly();
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.Add(KeyValuePair`2<string, object> item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.Contains(KeyValuePair`2<string, object> item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.CopyTo(KeyValuePair`2[] array, int arrayIndex);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.Remove(KeyValuePair`2<string, object> item);
    private sealed virtual override IEnumerator`1<KeyValuePair`2<string, object>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [IteratorStateMachineAttribute("System.Dynamic.ExpandoObject/<GetExpandoEnumerator>d__51")]
private IEnumerator`1<KeyValuePair`2<string, object>> GetExpandoEnumerator(ExpandoData data, int version);
    private sealed virtual override void System.ComponentModel.INotifyPropertyChanged.add_PropertyChanged(PropertyChangedEventHandler value);
    private sealed virtual override void System.ComponentModel.INotifyPropertyChanged.remove_PropertyChanged(PropertyChangedEventHandler value);
}
public abstract class System.Dynamic.GetIndexBinder : DynamicMetaObjectBinder {
    [CompilerGeneratedAttribute]
private CallInfo <CallInfo>k__BackingField;
    public Type ReturnType { get; }
    public CallInfo CallInfo { get; }
    internal bool IsStandardBinder { get; }
    protected GetIndexBinder(CallInfo callInfo);
    public sealed virtual Type get_ReturnType();
    [CompilerGeneratedAttribute]
public CallInfo get_CallInfo();
    public sealed virtual DynamicMetaObject Bind(DynamicMetaObject target, DynamicMetaObject[] args);
    internal sealed virtual bool get_IsStandardBinder();
    public DynamicMetaObject FallbackGetIndex(DynamicMetaObject target, DynamicMetaObject[] indexes);
    public abstract virtual DynamicMetaObject FallbackGetIndex(DynamicMetaObject target, DynamicMetaObject[] indexes, DynamicMetaObject errorSuggestion);
}
public abstract class System.Dynamic.GetMemberBinder : DynamicMetaObjectBinder {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreCase>k__BackingField;
    public Type ReturnType { get; }
    public string Name { get; }
    public bool IgnoreCase { get; }
    internal bool IsStandardBinder { get; }
    protected GetMemberBinder(string name, bool ignoreCase);
    public sealed virtual Type get_ReturnType();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public bool get_IgnoreCase();
    public DynamicMetaObject FallbackGetMember(DynamicMetaObject target);
    public abstract virtual DynamicMetaObject FallbackGetMember(DynamicMetaObject target, DynamicMetaObject errorSuggestion);
    public sealed virtual DynamicMetaObject Bind(DynamicMetaObject target, DynamicMetaObject[] args);
    internal sealed virtual bool get_IsStandardBinder();
}
public interface System.Dynamic.IDynamicMetaObjectProvider {
    public abstract virtual DynamicMetaObject GetMetaObject(Expression parameter);
}
public interface System.Dynamic.IInvokeOnGetBinder {
    public bool InvokeOnGet { get; }
    public abstract virtual bool get_InvokeOnGet();
}
public abstract class System.Dynamic.InvokeBinder : DynamicMetaObjectBinder {
    [CompilerGeneratedAttribute]
private CallInfo <CallInfo>k__BackingField;
    public Type ReturnType { get; }
    public CallInfo CallInfo { get; }
    internal bool IsStandardBinder { get; }
    protected InvokeBinder(CallInfo callInfo);
    public sealed virtual Type get_ReturnType();
    [CompilerGeneratedAttribute]
public CallInfo get_CallInfo();
    public DynamicMetaObject FallbackInvoke(DynamicMetaObject target, DynamicMetaObject[] args);
    public abstract virtual DynamicMetaObject FallbackInvoke(DynamicMetaObject target, DynamicMetaObject[] args, DynamicMetaObject errorSuggestion);
    public sealed virtual DynamicMetaObject Bind(DynamicMetaObject target, DynamicMetaObject[] args);
    internal sealed virtual bool get_IsStandardBinder();
}
public abstract class System.Dynamic.InvokeMemberBinder : DynamicMetaObjectBinder {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreCase>k__BackingField;
    [CompilerGeneratedAttribute]
private CallInfo <CallInfo>k__BackingField;
    public Type ReturnType { get; }
    public string Name { get; }
    public bool IgnoreCase { get; }
    public CallInfo CallInfo { get; }
    internal bool IsStandardBinder { get; }
    protected InvokeMemberBinder(string name, bool ignoreCase, CallInfo callInfo);
    public sealed virtual Type get_ReturnType();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public bool get_IgnoreCase();
    [CompilerGeneratedAttribute]
public CallInfo get_CallInfo();
    public sealed virtual DynamicMetaObject Bind(DynamicMetaObject target, DynamicMetaObject[] args);
    internal sealed virtual bool get_IsStandardBinder();
    public DynamicMetaObject FallbackInvokeMember(DynamicMetaObject target, DynamicMetaObject[] args);
    public abstract virtual DynamicMetaObject FallbackInvokeMember(DynamicMetaObject target, DynamicMetaObject[] args, DynamicMetaObject errorSuggestion);
    public abstract virtual DynamicMetaObject FallbackInvoke(DynamicMetaObject target, DynamicMetaObject[] args, DynamicMetaObject errorSuggestion);
}
public abstract class System.Dynamic.SetIndexBinder : DynamicMetaObjectBinder {
    [CompilerGeneratedAttribute]
private CallInfo <CallInfo>k__BackingField;
    public Type ReturnType { get; }
    public CallInfo CallInfo { get; }
    internal bool IsStandardBinder { get; }
    protected SetIndexBinder(CallInfo callInfo);
    public sealed virtual Type get_ReturnType();
    [CompilerGeneratedAttribute]
public CallInfo get_CallInfo();
    public sealed virtual DynamicMetaObject Bind(DynamicMetaObject target, DynamicMetaObject[] args);
    internal sealed virtual bool get_IsStandardBinder();
    public DynamicMetaObject FallbackSetIndex(DynamicMetaObject target, DynamicMetaObject[] indexes, DynamicMetaObject value);
    public abstract virtual DynamicMetaObject FallbackSetIndex(DynamicMetaObject target, DynamicMetaObject[] indexes, DynamicMetaObject value, DynamicMetaObject errorSuggestion);
}
public abstract class System.Dynamic.SetMemberBinder : DynamicMetaObjectBinder {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreCase>k__BackingField;
    public Type ReturnType { get; }
    public string Name { get; }
    public bool IgnoreCase { get; }
    internal bool IsStandardBinder { get; }
    protected SetMemberBinder(string name, bool ignoreCase);
    public sealed virtual Type get_ReturnType();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public bool get_IgnoreCase();
    public sealed virtual DynamicMetaObject Bind(DynamicMetaObject target, DynamicMetaObject[] args);
    internal sealed virtual bool get_IsStandardBinder();
    public DynamicMetaObject FallbackSetMember(DynamicMetaObject target, DynamicMetaObject value);
    public abstract virtual DynamicMetaObject FallbackSetMember(DynamicMetaObject target, DynamicMetaObject value, DynamicMetaObject errorSuggestion);
}
public abstract class System.Dynamic.UnaryOperationBinder : DynamicMetaObjectBinder {
    [CompilerGeneratedAttribute]
private ExpressionType <Operation>k__BackingField;
    public Type ReturnType { get; }
    public ExpressionType Operation { get; }
    internal bool IsStandardBinder { get; }
    protected UnaryOperationBinder(ExpressionType operation);
    public sealed virtual Type get_ReturnType();
    [CompilerGeneratedAttribute]
public ExpressionType get_Operation();
    public DynamicMetaObject FallbackUnaryOperation(DynamicMetaObject target);
    public abstract virtual DynamicMetaObject FallbackUnaryOperation(DynamicMetaObject target, DynamicMetaObject errorSuggestion);
    public sealed virtual DynamicMetaObject Bind(DynamicMetaObject target, DynamicMetaObject[] args);
    internal sealed virtual bool get_IsStandardBinder();
    internal static bool OperationIsValid(ExpressionType operation);
}
internal static class System.Dynamic.UpdateDelegates : object {
    [ObsoleteAttribute("pregenerated CallSite<T>.Update delegate", "True")]
internal static TRet UpdateAndExecute1(CallSite site, T0 arg0);
    [ObsoleteAttribute("pregenerated CallSite<T>.Update delegate", "True")]
internal static TRet NoMatch1(CallSite site, T0 arg0);
    [ObsoleteAttribute("pregenerated CallSite<T>.Update delegate", "True")]
internal static TRet UpdateAndExecute2(CallSite site, T0 arg0, T1 arg1);
    [ObsoleteAttribute("pregenerated CallSite<T>.Update delegate", "True")]
internal static TRet NoMatch2(CallSite site, T0 arg0, T1 arg1);
    [ObsoleteAttribute("pregenerated CallSite<T>.Update delegate", "True")]
internal static TRet UpdateAndExecute3(CallSite site, T0 arg0, T1 arg1, T2 arg2);
    [ObsoleteAttribute("pregenerated CallSite<T>.Update delegate", "True")]
internal static TRet NoMatch3(CallSite site, T0 arg0, T1 arg1, T2 arg2);
    [ObsoleteAttribute("pregenerated CallSite<T>.Update delegate", "True")]
internal static TRet UpdateAndExecute4(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3);
    [ObsoleteAttribute("pregenerated CallSite<T>.Update delegate", "True")]
internal static TRet NoMatch4(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3);
    [ObsoleteAttribute("pregenerated CallSite<T>.Update delegate", "True")]
internal static TRet UpdateAndExecute5(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4);
    [ObsoleteAttribute("pregenerated CallSite<T>.Update delegate", "True")]
internal static TRet NoMatch5(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4);
    [ObsoleteAttribute("pregenerated CallSite<T>.Update delegate", "True")]
internal static TRet UpdateAndExecute6(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5);
    [ObsoleteAttribute("pregenerated CallSite<T>.Update delegate", "True")]
internal static TRet NoMatch6(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5);
    [ObsoleteAttribute("pregenerated CallSite<T>.Update delegate", "True")]
internal static TRet UpdateAndExecute7(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6);
    [ObsoleteAttribute("pregenerated CallSite<T>.Update delegate", "True")]
internal static TRet NoMatch7(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6);
    [ObsoleteAttribute("pregenerated CallSite<T>.Update delegate", "True")]
internal static TRet UpdateAndExecute8(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7);
    [ObsoleteAttribute("pregenerated CallSite<T>.Update delegate", "True")]
internal static TRet NoMatch8(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7);
    [ObsoleteAttribute("pregenerated CallSite<T>.Update delegate", "True")]
internal static TRet UpdateAndExecute9(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8);
    [ObsoleteAttribute("pregenerated CallSite<T>.Update delegate", "True")]
internal static TRet NoMatch9(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8);
    [ObsoleteAttribute("pregenerated CallSite<T>.Update delegate", "True")]
internal static TRet UpdateAndExecute10(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9);
    [ObsoleteAttribute("pregenerated CallSite<T>.Update delegate", "True")]
internal static TRet NoMatch10(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9);
    [ObsoleteAttribute("pregenerated CallSite<T>.Update delegate", "True")]
internal static void UpdateAndExecuteVoid1(CallSite site, T0 arg0);
    [ObsoleteAttribute("pregenerated CallSite<T>.Update delegate", "True")]
internal static void NoMatchVoid1(CallSite site, T0 arg0);
    [ObsoleteAttribute("pregenerated CallSite<T>.Update delegate", "True")]
internal static void UpdateAndExecuteVoid2(CallSite site, T0 arg0, T1 arg1);
    [ObsoleteAttribute("pregenerated CallSite<T>.Update delegate", "True")]
internal static void NoMatchVoid2(CallSite site, T0 arg0, T1 arg1);
    [ObsoleteAttribute("pregenerated CallSite<T>.Update delegate", "True")]
internal static void UpdateAndExecuteVoid3(CallSite site, T0 arg0, T1 arg1, T2 arg2);
    [ObsoleteAttribute("pregenerated CallSite<T>.Update delegate", "True")]
internal static void NoMatchVoid3(CallSite site, T0 arg0, T1 arg1, T2 arg2);
    [ObsoleteAttribute("pregenerated CallSite<T>.Update delegate", "True")]
internal static void UpdateAndExecuteVoid4(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3);
    [ObsoleteAttribute("pregenerated CallSite<T>.Update delegate", "True")]
internal static void NoMatchVoid4(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3);
    [ObsoleteAttribute("pregenerated CallSite<T>.Update delegate", "True")]
internal static void UpdateAndExecuteVoid5(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4);
    [ObsoleteAttribute("pregenerated CallSite<T>.Update delegate", "True")]
internal static void NoMatchVoid5(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4);
    [ObsoleteAttribute("pregenerated CallSite<T>.Update delegate", "True")]
internal static void UpdateAndExecuteVoid6(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5);
    [ObsoleteAttribute("pregenerated CallSite<T>.Update delegate", "True")]
internal static void NoMatchVoid6(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5);
    [ObsoleteAttribute("pregenerated CallSite<T>.Update delegate", "True")]
internal static void UpdateAndExecuteVoid7(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6);
    [ObsoleteAttribute("pregenerated CallSite<T>.Update delegate", "True")]
internal static void NoMatchVoid7(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6);
    [ObsoleteAttribute("pregenerated CallSite<T>.Update delegate", "True")]
internal static void UpdateAndExecuteVoid8(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7);
    [ObsoleteAttribute("pregenerated CallSite<T>.Update delegate", "True")]
internal static void NoMatchVoid8(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7);
    [ObsoleteAttribute("pregenerated CallSite<T>.Update delegate", "True")]
internal static void UpdateAndExecuteVoid9(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8);
    [ObsoleteAttribute("pregenerated CallSite<T>.Update delegate", "True")]
internal static void NoMatchVoid9(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8);
    [ObsoleteAttribute("pregenerated CallSite<T>.Update delegate", "True")]
internal static void UpdateAndExecuteVoid10(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9);
    [ObsoleteAttribute("pregenerated CallSite<T>.Update delegate", "True")]
internal static void NoMatchVoid10(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9);
}
[DefaultMemberAttribute("Item")]
internal class System.Dynamic.Utils.CacheDict`2 : object {
    private int _mask;
    private Entry[] _entries;
    unknown TValue Item {internal set; }
    internal CacheDict`2(int size);
    private static int AlignSize(int size);
    internal bool TryGetValue(TKey key, TValue& value);
    internal void Add(TKey key, TValue value);
    internal void set_Item(TKey key, TValue value);
}
[ExtensionAttribute]
internal static class System.Dynamic.Utils.CollectionExtensions : object {
    [ExtensionAttribute]
public static TrueReadOnlyCollection`1<T> AddFirst(ReadOnlyCollection`1<T> list, T item);
    [ExtensionAttribute]
public static T[] AddFirst(T[] array, T item);
    [ExtensionAttribute]
public static T[] AddLast(T[] array, T item);
    [ExtensionAttribute]
public static T[] RemoveFirst(T[] array);
    [ExtensionAttribute]
public static T[] RemoveLast(T[] array);
    [ExtensionAttribute]
public static ReadOnlyCollection`1<T> ToReadOnly(IEnumerable`1<T> enumerable);
    [ExtensionAttribute]
public static int ListHashCode(ReadOnlyCollection`1<T> list);
    [ExtensionAttribute]
public static bool ListEquals(ReadOnlyCollection`1<T> first, ReadOnlyCollection`1<T> second);
}
internal static class System.Dynamic.Utils.ContractUtils : object {
    [ExcludeFromCodeCoverageAttribute]
public static Exception Unreachable { get; }
    public static Exception get_Unreachable();
    public static void Requires(bool precondition, string paramName);
    public static void RequiresNotNull(object value, string paramName);
    public static void RequiresNotNull(object value, string paramName, int index);
    public static void RequiresNotEmpty(ICollection`1<T> collection, string paramName);
    public static void RequiresNotNullItems(IList`1<T> array, string arrayName);
    [ConditionalAttribute("DEBUG")]
public static void AssertLockHeld(object lockObject);
    private static string GetParamName(string paramName, int index);
    public static void RequiresArrayRange(IList`1<T> array, int offset, int count, string offsetName, string countName);
}
internal static class System.Dynamic.Utils.EmptyReadOnlyCollection`1 : object {
    public static ReadOnlyCollection`1<T> Instance;
    private static EmptyReadOnlyCollection`1();
}
[ExtensionAttribute]
internal static class System.Dynamic.Utils.ExpressionUtils : object {
    public static ReadOnlyCollection`1<ParameterExpression> ReturnReadOnly(IParameterProvider provider, Object& collection);
    public static ReadOnlyCollection`1<T> ReturnReadOnly(IReadOnlyList`1& collection);
    public static ReadOnlyCollection`1<Expression> ReturnReadOnly(IArgumentProvider provider, Object& collection);
    public static T ReturnObject(object collectionOrT);
    public static void ValidateArgumentTypes(MethodBase method, ExpressionType nodeKind, ReadOnlyCollection`1& arguments, string methodParamName);
    public static void ValidateArgumentCount(MethodBase method, ExpressionType nodeKind, int count, ParameterInfo[] pis);
    public static Expression ValidateOneArgument(MethodBase method, ExpressionType nodeKind, Expression arguments, ParameterInfo pi, string methodParamName, string argumentParamName, int index);
    public static void RequiresCanRead(Expression expression, string paramName);
    public static void RequiresCanRead(Expression expression, string paramName, int idx);
    public static bool TryQuote(Type parameterType, Expression& argument);
    internal static ParameterInfo[] GetParametersForValidation(MethodBase method, ExpressionType nodeKind);
    internal static bool SameElements(ICollection`1<T> replacement, IReadOnlyList`1<T> current);
    internal static bool SameElements(IEnumerable`1& replacement, IReadOnlyList`1<T> current);
    private static bool SameElementsInCollection(ICollection`1<T> replacement, IReadOnlyList`1<T> current);
    [ExtensionAttribute]
public static void ValidateArgumentCount(LambdaExpression lambda);
}
internal static class System.Dynamic.Utils.ExpressionVisitorUtils : object {
    public static Expression[] VisitBlockExpressions(ExpressionVisitor visitor, BlockExpression block);
    public static ParameterExpression[] VisitParameters(ExpressionVisitor visitor, IParameterProvider nodes, string callerName);
    public static Expression[] VisitArguments(ExpressionVisitor visitor, IArgumentProvider nodes);
}
internal static class System.Dynamic.Utils.Helpers : object {
    internal static T CommonNode(T first, T second, Func`2<T, T> parent);
    internal static void IncrementCount(T key, Dictionary`2<T, int> dict);
}
internal class System.Dynamic.Utils.ListArgumentProvider : ListProvider`1<Expression> {
    private IArgumentProvider _provider;
    private Expression _arg0;
    protected Expression First { get; }
    protected int ElementCount { get; }
    internal ListArgumentProvider(IArgumentProvider provider, Expression arg0);
    protected virtual Expression get_First();
    protected virtual int get_ElementCount();
    protected virtual Expression GetElement(int index);
}
internal class System.Dynamic.Utils.ListParameterProvider : ListProvider`1<ParameterExpression> {
    private IParameterProvider _provider;
    private ParameterExpression _arg0;
    protected ParameterExpression First { get; }
    protected int ElementCount { get; }
    internal ListParameterProvider(IParameterProvider provider, ParameterExpression arg0);
    protected virtual ParameterExpression get_First();
    protected virtual int get_ElementCount();
    protected virtual ParameterExpression GetElement(int index);
}
[DefaultMemberAttribute("Item")]
internal abstract class System.Dynamic.Utils.ListProvider`1 : object {
    protected T First { get; }
    protected int ElementCount { get; }
    public T Item { get; public set; }
    public int Count { get; }
    [ExcludeFromCodeCoverageAttribute]
public bool IsReadOnly { get; }
    protected abstract virtual T get_First();
    protected abstract virtual int get_ElementCount();
    protected abstract virtual T GetElement(int index);
    public sealed virtual int IndexOf(T item);
    [ExcludeFromCodeCoverageAttribute]
public sealed virtual void Insert(int index, T item);
    [ExcludeFromCodeCoverageAttribute]
public sealed virtual void RemoveAt(int index);
    public sealed virtual T get_Item(int index);
    [ExcludeFromCodeCoverageAttribute]
public sealed virtual void set_Item(int index, T value);
    [ExcludeFromCodeCoverageAttribute]
public sealed virtual void Add(T item);
    [ExcludeFromCodeCoverageAttribute]
public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int index);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    [ExcludeFromCodeCoverageAttribute]
public sealed virtual bool Remove(T item);
    [IteratorStateMachineAttribute("System.Dynamic.Utils.ListProvider`1/<GetEnumerator>d__20")]
public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[ExtensionAttribute]
internal static class System.Dynamic.Utils.TypeExtensions : object {
    private static CacheDict`2<MethodBase, ParameterInfo[]> s_paramInfoCache;
    private static TypeExtensions();
    [ExtensionAttribute]
public static MethodInfo GetAnyStaticMethodValidated(Type type, string name, Type[] types);
    [ExtensionAttribute]
private static bool MatchesArgumentTypes(MethodInfo mi, Type[] argTypes);
    [ExtensionAttribute]
public static Type GetReturnType(MethodBase mi);
    [ExtensionAttribute]
public static TypeCode GetTypeCode(Type type);
    [ExtensionAttribute]
internal static ParameterInfo[] GetParametersCached(MethodBase method);
    [ExtensionAttribute]
internal static bool IsByRefParameter(ParameterInfo pi);
}
[ExtensionAttribute]
internal static class System.Dynamic.Utils.TypeUtils : object {
    private static Type[] s_arrayAssignableInterfaces;
    private static TypeUtils();
    [ExtensionAttribute]
public static Type GetNonNullableType(Type type);
    [ExtensionAttribute]
public static Type GetNullableType(Type type);
    [ExtensionAttribute]
public static bool IsNullableType(Type type);
    [ExtensionAttribute]
public static bool IsNullableOrReferenceType(Type type);
    [ExtensionAttribute]
public static bool IsBool(Type type);
    [ExtensionAttribute]
public static bool IsNumeric(Type type);
    [ExtensionAttribute]
public static bool IsInteger(Type type);
    [ExtensionAttribute]
public static bool IsInteger64(Type type);
    [ExtensionAttribute]
public static bool IsArithmetic(Type type);
    [ExtensionAttribute]
public static bool IsUnsignedInt(Type type);
    [ExtensionAttribute]
public static bool IsIntegerOrBool(Type type);
    [ExtensionAttribute]
public static bool IsNumericOrBool(Type type);
    public static bool IsValidInstanceType(MemberInfo member, Type instanceType);
    [ExtensionAttribute]
public static bool HasIdentityPrimitiveOrNullableConversionTo(Type source, Type dest);
    [ExtensionAttribute]
public static bool HasReferenceConversionTo(Type source, Type dest);
    [ExtensionAttribute]
private static bool StrictHasReferenceConversionTo(Type source, Type dest, bool skipNonArray);
    private static bool HasArrayToInterfaceConversion(Type source, Type dest);
    private static bool HasInterfaceToArrayConversion(Type source, Type dest);
    private static bool IsCovariant(Type t);
    private static bool IsContravariant(Type t);
    private static bool IsInvariant(Type t);
    private static bool IsDelegate(Type t);
    public static bool IsLegalExplicitVariantDelegateConversion(Type source, Type dest);
    [ExtensionAttribute]
public static bool IsConvertible(Type type);
    public static bool HasReferenceEquality(Type left, Type right);
    public static bool HasBuiltInEqualityOperator(Type left, Type right);
    [ExtensionAttribute]
public static bool IsImplicitlyConvertibleTo(Type source, Type destination);
    public static MethodInfo GetUserDefinedCoercionMethod(Type convertFrom, Type convertToType);
    private static MethodInfo FindConversionOperator(MethodInfo[] methods, Type typeFrom, Type typeTo);
    private static bool IsImplicitNumericConversion(Type source, Type destination);
    private static bool IsImplicitReferenceConversion(Type source, Type destination);
    private static bool IsImplicitBoxingConversion(Type source, Type destination);
    private static bool IsImplicitNullableConversion(Type source, Type destination);
    public static Type FindGenericType(Type definition, Type type);
    public static MethodInfo GetBooleanOperator(Type type, string name);
    [ExtensionAttribute]
public static Type GetNonRefType(Type type);
    public static bool AreEquivalent(Type t1, Type t2);
    public static bool AreReferenceAssignable(Type dest, Type src);
    public static bool IsSameOrSubclass(Type type, Type subType);
    public static void ValidateType(Type type, string paramName);
    public static void ValidateType(Type type, string paramName, bool allowByRef, bool allowPointer);
    public static bool ValidateType(Type type, string paramName, int index);
    [ExtensionAttribute]
public static MethodInfo GetInvokeMethod(Type delegateType);
    [ExtensionAttribute]
internal static bool IsUnsigned(Type type);
    [ExtensionAttribute]
internal static bool IsUnsigned(TypeCode typeCode);
    [ExtensionAttribute]
internal static bool IsFloatingPoint(Type type);
    [ExtensionAttribute]
internal static bool IsFloatingPoint(TypeCode typeCode);
}
public class System.Func`10 : MulticastDelegate {
    public Func`10(object object, IntPtr method);
    public virtual TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
public class System.Func`11 : MulticastDelegate {
    public Func`11(object object, IntPtr method);
    public virtual TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
public class System.Func`12 : MulticastDelegate {
    public Func`12(object object, IntPtr method);
    public virtual TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
public class System.Func`13 : MulticastDelegate {
    public Func`13(object object, IntPtr method);
    public virtual TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
public class System.Func`14 : MulticastDelegate {
    public Func`14(object object, IntPtr method);
    public virtual TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
public class System.Func`15 : MulticastDelegate {
    public Func`15(object object, IntPtr method);
    public virtual TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
public class System.Func`16 : MulticastDelegate {
    public Func`16(object object, IntPtr method);
    public virtual TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15, AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
public class System.Func`17 : MulticastDelegate {
    public Func`17(object object, IntPtr method);
    public virtual TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15, T16 arg16);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15, T16 arg16, AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
internal static class System.IO.Error : object {
    internal static Exception GetEndOfFile();
    internal static Exception GetPipeNotOpen();
    internal static Exception GetReadNotSupported();
    internal static Exception GetSeekNotSupported();
    internal static Exception GetWriteNotSupported();
    internal static Exception GetOperationAborted();
}
public enum System.IO.HandleInheritability : Enum {
    public int value__;
    public static HandleInheritability None;
    public static HandleInheritability Inheritable;
}
internal static class System.IO.MemoryMappedFiles.MemoryMapImpl : object {
    private static IntPtr OpenFileInternal(Char* path, int path_length, FileMode mode, Char* mapName, int mapName_length, Int64& capacity, MemoryMappedFileAccess access, MemoryMappedFileOptions options, Int32& error);
    private static IntPtr OpenHandleInternal(IntPtr handle, Char* mapName, int mapName_length, Int64& capacity, MemoryMappedFileAccess access, MemoryMappedFileOptions options, Int32& error);
    internal static void CloseMapping(IntPtr handle);
    internal static void Flush(IntPtr file_handle);
    internal static void ConfigureHandleInheritability(IntPtr handle, HandleInheritability inheritability);
    internal static bool Unmap(IntPtr mmap_handle);
    private static int MapInternal(IntPtr handle, long offset, Int64& size, MemoryMappedFileAccess access, IntPtr& mmap_handle, IntPtr& base_address);
    internal static void Map(IntPtr handle, long offset, Int64& size, MemoryMappedFileAccess access, IntPtr& mmap_handle, IntPtr& base_address);
    private static Exception CreateException(int error, string path);
    private static int StringLength(string a);
    private static void CheckString(string name, string value);
    internal static IntPtr OpenFile(string path, FileMode mode, string mapName, Int64& capacity, MemoryMappedFileAccess access, MemoryMappedFileOptions options);
    internal static IntPtr OpenHandle(IntPtr handle, string mapName, Int64& capacity, MemoryMappedFileAccess access, MemoryMappedFileOptions options);
}
public class System.IO.MemoryMappedFiles.MemoryMappedFile : object {
    private FileStream stream;
    private bool keepOpen;
    private SafeMemoryMappedFileHandle handle;
    public SafeMemoryMappedFileHandle SafeMemoryMappedFileHandle { get; }
    public static MemoryMappedFile CreateFromFile(string path);
    public static MemoryMappedFile CreateFromFile(string path, FileMode mode);
    public static MemoryMappedFile CreateFromFile(string path, FileMode mode, string mapName);
    public static MemoryMappedFile CreateFromFile(string path, FileMode mode, string mapName, long capacity);
    public static MemoryMappedFile CreateFromFile(string path, FileMode mode, string mapName, long capacity, MemoryMappedFileAccess access);
    public static MemoryMappedFile CreateFromFile(FileStream fileStream, string mapName, long capacity, MemoryMappedFileAccess access, HandleInheritability inheritability, bool leaveOpen);
    [MonoLimitationAttribute("memoryMappedFileSecurity is currently ignored")]
public static MemoryMappedFile CreateFromFile(FileStream fileStream, string mapName, long capacity, MemoryMappedFileAccess access, MemoryMappedFileSecurity memoryMappedFileSecurity, HandleInheritability inheritability, bool leaveOpen);
    private static MemoryMappedFile CoreShmCreate(string mapName, long capacity, MemoryMappedFileAccess access, MemoryMappedFileOptions options, MemoryMappedFileSecurity memoryMappedFileSecurity, HandleInheritability inheritability, FileMode mode);
    [MonoLimitationAttribute("Named mappings scope is process local")]
public static MemoryMappedFile CreateNew(string mapName, long capacity);
    [MonoLimitationAttribute("Named mappings scope is process local")]
public static MemoryMappedFile CreateNew(string mapName, long capacity, MemoryMappedFileAccess access);
    [MonoLimitationAttribute("Named mappings scope is process local; options is ignored")]
public static MemoryMappedFile CreateNew(string mapName, long capacity, MemoryMappedFileAccess access, MemoryMappedFileOptions options, HandleInheritability inheritability);
    [MonoLimitationAttribute("Named mappings scope is process local; options and memoryMappedFileSecurity are ignored")]
public static MemoryMappedFile CreateNew(string mapName, long capacity, MemoryMappedFileAccess access, MemoryMappedFileOptions options, MemoryMappedFileSecurity memoryMappedFileSecurity, HandleInheritability inheritability);
    [MonoLimitationAttribute("Named mappings scope is process local")]
public static MemoryMappedFile CreateOrOpen(string mapName, long capacity);
    [MonoLimitationAttribute("Named mappings scope is process local")]
public static MemoryMappedFile CreateOrOpen(string mapName, long capacity, MemoryMappedFileAccess access);
    [MonoLimitationAttribute("Named mappings scope is process local")]
public static MemoryMappedFile CreateOrOpen(string mapName, long capacity, MemoryMappedFileAccess access, MemoryMappedFileOptions options, HandleInheritability inheritability);
    [MonoLimitationAttribute("Named mappings scope is process local")]
public static MemoryMappedFile CreateOrOpen(string mapName, long capacity, MemoryMappedFileAccess access, MemoryMappedFileOptions options, MemoryMappedFileSecurity memoryMappedFileSecurity, HandleInheritability inheritability);
    [MonoLimitationAttribute("Named mappings scope is process local")]
public static MemoryMappedFile OpenExisting(string mapName);
    [MonoLimitationAttribute("Named mappings scope is process local")]
public static MemoryMappedFile OpenExisting(string mapName, MemoryMappedFileRights desiredAccessRights);
    [MonoLimitationAttribute("Named mappings scope is process local")]
public static MemoryMappedFile OpenExisting(string mapName, MemoryMappedFileRights desiredAccessRights, HandleInheritability inheritability);
    public MemoryMappedViewStream CreateViewStream();
    public MemoryMappedViewStream CreateViewStream(long offset, long size);
    public MemoryMappedViewStream CreateViewStream(long offset, long size, MemoryMappedFileAccess access);
    public MemoryMappedViewAccessor CreateViewAccessor();
    public MemoryMappedViewAccessor CreateViewAccessor(long offset, long size);
    public MemoryMappedViewAccessor CreateViewAccessor(long offset, long size, MemoryMappedFileAccess access);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    [MonoTODOAttribute]
public MemoryMappedFileSecurity GetAccessControl();
    [MonoTODOAttribute]
public void SetAccessControl(MemoryMappedFileSecurity memoryMappedFileSecurity);
    public SafeMemoryMappedFileHandle get_SafeMemoryMappedFileHandle();
    internal static FileAccess GetFileAccess(MemoryMappedFileAccess access);
}
public enum System.IO.MemoryMappedFiles.MemoryMappedFileAccess : Enum {
    public int value__;
    public static MemoryMappedFileAccess ReadWrite;
    public static MemoryMappedFileAccess Read;
    public static MemoryMappedFileAccess Write;
    public static MemoryMappedFileAccess CopyOnWrite;
    public static MemoryMappedFileAccess ReadExecute;
    public static MemoryMappedFileAccess ReadWriteExecute;
}
[FlagsAttribute]
public enum System.IO.MemoryMappedFiles.MemoryMappedFileOptions : Enum {
    public int value__;
    public static MemoryMappedFileOptions None;
    public static MemoryMappedFileOptions DelayAllocatePages;
}
[FlagsAttribute]
public enum System.IO.MemoryMappedFiles.MemoryMappedFileRights : Enum {
    public int value__;
    public static MemoryMappedFileRights CopyOnWrite;
    public static MemoryMappedFileRights Write;
    public static MemoryMappedFileRights Read;
    public static MemoryMappedFileRights Execute;
    public static MemoryMappedFileRights Delete;
    public static MemoryMappedFileRights ReadPermissions;
    public static MemoryMappedFileRights ChangePermissions;
    public static MemoryMappedFileRights TakeOwnership;
    public static MemoryMappedFileRights ReadWrite;
    public static MemoryMappedFileRights ReadExecute;
    public static MemoryMappedFileRights ReadWriteExecute;
    public static MemoryMappedFileRights FullControl;
    public static MemoryMappedFileRights AccessSystemSecurity;
}
public class System.IO.MemoryMappedFiles.MemoryMappedFileSecurity : ObjectSecurity`1<MemoryMappedFileRights> {
    [SecuritySafeCriticalAttribute]
internal MemoryMappedFileSecurity(SafeMemoryMappedFileHandle safeHandle, AccessControlSections includeSections);
    [SecuritySafeCriticalAttribute]
internal void PersistHandle(SafeHandle handle);
}
internal class System.IO.MemoryMappedFiles.MemoryMappedView : object {
    private SafeMemoryMappedViewHandle m_viewHandle;
    private long m_pointerOffset;
    private long m_size;
    private MemoryMappedFileAccess m_access;
    internal SafeMemoryMappedViewHandle ViewHandle { get; }
    internal long PointerOffset { get; }
    internal long Size { get; }
    internal MemoryMappedFileAccess Access { get; }
    internal bool IsClosed { get; }
    [SecurityCriticalAttribute]
private MemoryMappedView(SafeMemoryMappedViewHandle viewHandle, long pointerOffset, long size, MemoryMappedFileAccess access);
    [SecurityCriticalAttribute]
internal SafeMemoryMappedViewHandle get_ViewHandle();
    internal long get_PointerOffset();
    internal long get_Size();
    internal MemoryMappedFileAccess get_Access();
    internal static MemoryMappedView Create(IntPtr handle, long offset, long size, MemoryMappedFileAccess access);
    public void Flush(IntPtr capacity);
    protected virtual void Dispose(bool disposing);
    public sealed virtual void Dispose();
    internal bool get_IsClosed();
}
public class System.IO.MemoryMappedFiles.MemoryMappedViewAccessor : UnmanagedMemoryAccessor {
    private MemoryMappedView m_view;
    public SafeMemoryMappedViewHandle SafeMemoryMappedViewHandle { get; }
    public long PointerOffset { get; }
    [SecurityCriticalAttribute]
internal MemoryMappedViewAccessor(MemoryMappedView view);
    [SecurityCriticalAttribute]
public SafeMemoryMappedViewHandle get_SafeMemoryMappedViewHandle();
    public long get_PointerOffset();
    [SecuritySafeCriticalAttribute]
protected virtual void Dispose(bool disposing);
    [SecurityCriticalAttribute]
public void Flush();
}
public class System.IO.MemoryMappedFiles.MemoryMappedViewStream : UnmanagedMemoryStream {
    private MemoryMappedView m_view;
    public SafeMemoryMappedViewHandle SafeMemoryMappedViewHandle { get; }
    public long PointerOffset { get; }
    [SecurityCriticalAttribute]
internal MemoryMappedViewStream(MemoryMappedView view);
    [SecurityCriticalAttribute]
public SafeMemoryMappedViewHandle get_SafeMemoryMappedViewHandle();
    public virtual void SetLength(long value);
    public long get_PointerOffset();
    [SecuritySafeCriticalAttribute]
protected virtual void Dispose(bool disposing);
    [SecurityCriticalAttribute]
public virtual void Flush();
}
public class System.IO.Pipes.AnonymousPipeClientStream : PipeStream {
    public PipeTransmissionMode TransmissionMode { get; }
    unknown PipeTransmissionMode ReadMode {public set; }
    public AnonymousPipeClientStream(string pipeHandleAsString);
    public AnonymousPipeClientStream(PipeDirection direction, string pipeHandleAsString);
    public AnonymousPipeClientStream(PipeDirection direction, SafePipeHandle safePipeHandle);
    private void Init(PipeDirection direction, SafePipeHandle safePipeHandle);
    protected virtual override void Finalize();
    public virtual PipeTransmissionMode get_TransmissionMode();
    public virtual void set_ReadMode(PipeTransmissionMode value);
}
public class System.IO.Pipes.AnonymousPipeServerStream : PipeStream {
    private SafePipeHandle _clientHandle;
    private bool _clientHandleExposed;
    public SafePipeHandle ClientSafePipeHandle { get; }
    public PipeTransmissionMode TransmissionMode { get; }
    unknown PipeTransmissionMode ReadMode {public set; }
    public AnonymousPipeServerStream(PipeDirection direction);
    public AnonymousPipeServerStream(PipeDirection direction, HandleInheritability inheritability);
    public AnonymousPipeServerStream(PipeDirection direction, SafePipeHandle serverSafePipeHandle, SafePipeHandle clientSafePipeHandle);
    public AnonymousPipeServerStream(PipeDirection direction, HandleInheritability inheritability, int bufferSize);
    public AnonymousPipeServerStream(PipeDirection direction, HandleInheritability inheritability, int bufferSize, PipeSecurity pipeSecurity);
    private void Create(PipeDirection direction, HandleInheritability inheritability, int bufferSize);
    private void Create(PipeDirection direction, HandleInheritability inheritability, int bufferSize, PipeSecurity pipeSecurity);
    protected virtual override void Finalize();
    public string GetClientHandleAsString();
    public SafePipeHandle get_ClientSafePipeHandle();
    public void DisposeLocalCopyOfClientHandle();
    protected virtual void Dispose(bool disposing);
    public virtual PipeTransmissionMode get_TransmissionMode();
    public virtual void set_ReadMode(PipeTransmissionMode value);
}
internal class System.IO.Pipes.ConnectionCompletionSource : PipeCompletionSource`1<VoidResult> {
    private NamedPipeServerStream _serverStream;
    internal ConnectionCompletionSource(NamedPipeServerStream server);
    internal virtual void SetCompletedSynchronously();
    protected virtual void AsyncCallback(UInt32 errorCode, UInt32 numBytes);
    protected virtual void HandleError(int errorCode);
    protected virtual void HandleUnexpectedCancellation();
}
public class System.IO.Pipes.NamedPipeClientStream : PipeStream {
    private static int CancellationCheckInterval;
    private string _normalizedPipePath;
    private TokenImpersonationLevel _impersonationLevel;
    private PipeOptions _pipeOptions;
    private HandleInheritability _inheritability;
    private PipeDirection _direction;
    private int _access;
    public int NumberOfServerInstances { get; }
    public NamedPipeClientStream(string pipeName);
    public NamedPipeClientStream(string serverName, string pipeName);
    public NamedPipeClientStream(string serverName, string pipeName, PipeDirection direction);
    public NamedPipeClientStream(string serverName, string pipeName, PipeDirection direction, PipeOptions options);
    public NamedPipeClientStream(string serverName, string pipeName, PipeDirection direction, PipeOptions options, TokenImpersonationLevel impersonationLevel);
    public NamedPipeClientStream(string serverName, string pipeName, PipeDirection direction, PipeOptions options, TokenImpersonationLevel impersonationLevel, HandleInheritability inheritability);
    public NamedPipeClientStream(PipeDirection direction, bool isAsync, bool isConnected, SafePipeHandle safePipeHandle);
    public NamedPipeClientStream(string serverName, string pipeName, PipeAccessRights desiredAccessRights, PipeOptions options, TokenImpersonationLevel impersonationLevel, HandleInheritability inheritability);
    private bool TryConnect(int timeout, CancellationToken cancellationToken);
    public int get_NumberOfServerInstances();
    private void ValidateRemotePipeUser();
    protected virtual override void Finalize();
    public void Connect();
    public void Connect(int timeout);
    private void ConnectInternal(int timeout, CancellationToken cancellationToken, int startTime);
    public Task ConnectAsync();
    public Task ConnectAsync(int timeout);
    public Task ConnectAsync(CancellationToken cancellationToken);
    public Task ConnectAsync(int timeout, CancellationToken cancellationToken);
    protected internal virtual void CheckPipePropertyOperations();
    private void CheckConnectOperationsClient();
}
public class System.IO.Pipes.NamedPipeServerStream : PipeStream {
    private static TryCode tryCode;
    private static CleanupCode cleanupCode;
    public static int MaxAllowedServerInstances;
    public NamedPipeServerStream(string pipeName);
    public NamedPipeServerStream(string pipeName, PipeDirection direction);
    public NamedPipeServerStream(string pipeName, PipeDirection direction, int maxNumberOfServerInstances);
    public NamedPipeServerStream(string pipeName, PipeDirection direction, int maxNumberOfServerInstances, PipeTransmissionMode transmissionMode);
    public NamedPipeServerStream(string pipeName, PipeDirection direction, int maxNumberOfServerInstances, PipeTransmissionMode transmissionMode, PipeOptions options);
    public NamedPipeServerStream(string pipeName, PipeDirection direction, int maxNumberOfServerInstances, PipeTransmissionMode transmissionMode, PipeOptions options, int inBufferSize, int outBufferSize);
    private NamedPipeServerStream(string pipeName, PipeDirection direction, int maxNumberOfServerInstances, PipeTransmissionMode transmissionMode, PipeOptions options, int inBufferSize, int outBufferSize, HandleInheritability inheritability);
    public NamedPipeServerStream(PipeDirection direction, bool isAsync, bool isConnected, SafePipeHandle safePipeHandle);
    public NamedPipeServerStream(string pipeName, PipeDirection direction, int maxNumberOfServerInstances, PipeTransmissionMode transmissionMode, PipeOptions options, int inBufferSize, int outBufferSize, PipeSecurity pipeSecurity);
    public NamedPipeServerStream(string pipeName, PipeDirection direction, int maxNumberOfServerInstances, PipeTransmissionMode transmissionMode, PipeOptions options, int inBufferSize, int outBufferSize, PipeSecurity pipeSecurity, HandleInheritability inheritability);
    public NamedPipeServerStream(string pipeName, PipeDirection direction, int maxNumberOfServerInstances, PipeTransmissionMode transmissionMode, PipeOptions options, int inBufferSize, int outBufferSize, PipeSecurity pipeSecurity, HandleInheritability inheritability, PipeAccessRights additionalAccessRights);
    private static NamedPipeServerStream();
    private void Create(string pipeName, PipeDirection direction, int maxNumberOfServerInstances, PipeTransmissionMode transmissionMode, PipeOptions options, int inBufferSize, int outBufferSize, HandleInheritability inheritability);
    private void Create(string pipeName, PipeDirection direction, int maxNumberOfServerInstances, PipeTransmissionMode transmissionMode, PipeOptions options, int inBufferSize, int outBufferSize, PipeSecurity pipeSecurity, HandleInheritability inheritability, PipeAccessRights additionalAccessRights);
    public void WaitForConnection();
    public Task WaitForConnectionAsync(CancellationToken cancellationToken);
    public void Disconnect();
    public string GetImpersonationUserName();
    public void RunAsClient(PipeStreamImpersonationWorker impersonationWorker);
    private static void ImpersonateAndTryCode(object helper);
    private static void RevertImpersonationOnBackout(object helper, bool exceptionThrown);
    private Task WaitForConnectionCoreAsync(CancellationToken cancellationToken);
    private void CheckConnectOperationsServerWithHandle();
    protected virtual override void Finalize();
    public Task WaitForConnectionAsync();
    public IAsyncResult BeginWaitForConnection(AsyncCallback callback, object state);
    public void EndWaitForConnection(IAsyncResult asyncResult);
    private void CheckConnectOperationsServer();
    private void CheckDisconnectOperations();
}
[FlagsAttribute]
public enum System.IO.Pipes.PipeAccessRights : Enum {
    public int value__;
    public static PipeAccessRights ReadData;
    public static PipeAccessRights WriteData;
    public static PipeAccessRights ReadAttributes;
    public static PipeAccessRights WriteAttributes;
    public static PipeAccessRights ReadExtendedAttributes;
    public static PipeAccessRights WriteExtendedAttributes;
    public static PipeAccessRights CreateNewInstance;
    public static PipeAccessRights Delete;
    public static PipeAccessRights ReadPermissions;
    public static PipeAccessRights ChangePermissions;
    public static PipeAccessRights TakeOwnership;
    public static PipeAccessRights Synchronize;
    public static PipeAccessRights FullControl;
    public static PipeAccessRights Read;
    public static PipeAccessRights Write;
    public static PipeAccessRights ReadWrite;
    public static PipeAccessRights AccessSystemSecurity;
}
public class System.IO.Pipes.PipeAccessRule : AccessRule {
    public PipeAccessRights PipeAccessRights { get; }
    public PipeAccessRule(string identity, PipeAccessRights rights, AccessControlType type);
    public PipeAccessRule(IdentityReference identity, PipeAccessRights rights, AccessControlType type);
    internal PipeAccessRule(IdentityReference identity, int accessMask, bool isInherited, AccessControlType type);
    public PipeAccessRights get_PipeAccessRights();
    internal static int AccessMaskFromRights(PipeAccessRights rights, AccessControlType controlType);
    internal static PipeAccessRights RightsFromAccessMask(int accessMask);
}
public class System.IO.Pipes.PipeAuditRule : AuditRule {
    public PipeAccessRights PipeAccessRights { get; }
    public PipeAuditRule(IdentityReference identity, PipeAccessRights rights, AuditFlags flags);
    public PipeAuditRule(string identity, PipeAccessRights rights, AuditFlags flags);
    internal PipeAuditRule(IdentityReference identity, int accessMask, bool isInherited, AuditFlags flags);
    private static int AccessMaskFromRights(PipeAccessRights rights);
    public PipeAccessRights get_PipeAccessRights();
}
internal abstract class System.IO.Pipes.PipeCompletionSource`1 : TaskCompletionSource`1<TResult> {
    private static int NoResult;
    private static int ResultSuccess;
    private static int ResultError;
    private static int RegisteringCancellation;
    private static int CompletedCallback;
    private ThreadPoolBoundHandle _threadPoolBinding;
    private CancellationTokenRegistration _cancellationRegistration;
    private int _errorCode;
    private NativeOverlapped* _overlapped;
    private MemoryHandle _pinnedMemory;
    private int _state;
    internal NativeOverlapped* Overlapped { get; }
    protected PipeCompletionSource`1(ThreadPoolBoundHandle handle, ReadOnlyMemory`1<byte> bufferToPin);
    internal NativeOverlapped* get_Overlapped();
    internal void RegisterForCancellation(CancellationToken cancellationToken);
    internal void ReleaseResources();
    internal abstract virtual void SetCompletedSynchronously();
    protected virtual void AsyncCallback(UInt32 errorCode, UInt32 numBytes);
    protected abstract virtual void HandleError(int errorCode);
    private void Cancel();
    protected virtual void HandleUnexpectedCancellation();
    private void CompleteCallback(int resultState);
}
public enum System.IO.Pipes.PipeDirection : Enum {
    public int value__;
    public static PipeDirection In;
    public static PipeDirection Out;
    public static PipeDirection InOut;
}
[FlagsAttribute]
public enum System.IO.Pipes.PipeOptions : Enum {
    public int value__;
    public static PipeOptions None;
    public static PipeOptions WriteThrough;
    public static PipeOptions Asynchronous;
    public static PipeOptions CurrentUserOnly;
}
public class System.IO.Pipes.PipeSecurity : NativeObjectSecurity {
    public Type AccessRightType { get; }
    public Type AccessRuleType { get; }
    public Type AuditRuleType { get; }
    internal PipeSecurity(SafePipeHandle safeHandle, AccessControlSections includeSections);
    public void AddAccessRule(PipeAccessRule rule);
    public void SetAccessRule(PipeAccessRule rule);
    public void ResetAccessRule(PipeAccessRule rule);
    public bool RemoveAccessRule(PipeAccessRule rule);
    public void RemoveAccessRuleSpecific(PipeAccessRule rule);
    public void AddAuditRule(PipeAuditRule rule);
    public void SetAuditRule(PipeAuditRule rule);
    public bool RemoveAuditRule(PipeAuditRule rule);
    public void RemoveAuditRuleAll(PipeAuditRule rule);
    public void RemoveAuditRuleSpecific(PipeAuditRule rule);
    public virtual AccessRule AccessRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AccessControlType type);
    public sealed virtual AuditRule AuditRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags flags);
    private AccessControlSections GetAccessControlSectionsFromChanges();
    protected internal void Persist(SafeHandle handle);
    protected internal void Persist(string name);
    public virtual Type get_AccessRightType();
    public virtual Type get_AccessRuleType();
    public virtual Type get_AuditRuleType();
}
internal enum System.IO.Pipes.PipeState : Enum {
    public int value__;
    public static PipeState WaitingToConnect;
    public static PipeState Connected;
    public static PipeState Broken;
    public static PipeState Disconnected;
    public static PipeState Closed;
}
public abstract class System.IO.Pipes.PipeStream : Stream {
    internal static bool CheckOperationsRequiresSetHandle;
    internal ThreadPoolBoundHandle _threadPoolBinding;
    internal static string AnonymousPipeName;
    private static Task`1<int> s_zeroTask;
    private SafePipeHandle _handle;
    private bool _canRead;
    private bool _canWrite;
    private bool _isAsync;
    private bool _isCurrentUserOnly;
    private bool _isMessageComplete;
    private bool _isFromExistingHandle;
    private bool _isHandleExposed;
    private PipeTransmissionMode _readMode;
    private PipeTransmissionMode _transmissionMode;
    private PipeDirection _pipeDirection;
    private int _outBufferSize;
    private PipeState _state;
    public PipeTransmissionMode TransmissionMode { get; }
    public int InBufferSize { get; }
    public int OutBufferSize { get; }
    public PipeTransmissionMode ReadMode { get; public set; }
    public bool IsConnected { get; protected set; }
    public bool IsAsync { get; }
    public bool IsMessageComplete { get; }
    public SafePipeHandle SafePipeHandle { get; }
    internal SafePipeHandle InternalHandle { get; }
    protected bool IsHandleExposed { get; }
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public bool CanSeek { get; }
    public long Length { get; }
    public long Position { get; public set; }
    internal PipeState State { get; internal set; }
    internal bool IsCurrentUserOnly { get; internal set; }
    protected PipeStream(PipeDirection direction, int bufferSize);
    protected PipeStream(PipeDirection direction, PipeTransmissionMode transmissionMode, int outBufferSize);
    private static PipeStream();
    internal static string GetPipePath(string serverName, string pipeName);
    internal void ValidateHandleIsPipe(SafePipeHandle safePipeHandle);
    private void InitializeAsyncHandle(SafePipeHandle handle);
    private void DisposeCore(bool disposing);
    private int ReadCore(Span`1<byte> buffer);
    private Task`1<int> ReadAsyncCore(Memory`1<byte> buffer, CancellationToken cancellationToken);
    private void WriteCore(ReadOnlySpan`1<byte> buffer);
    private Task WriteAsyncCore(ReadOnlyMemory`1<byte> buffer, CancellationToken cancellationToken);
    public void WaitForPipeDrain();
    public virtual PipeTransmissionMode get_TransmissionMode();
    public virtual int get_InBufferSize();
    public virtual int get_OutBufferSize();
    public virtual PipeTransmissionMode get_ReadMode();
    public virtual void set_ReadMode(PipeTransmissionMode value);
    private int ReadFileNative(SafePipeHandle handle, Span`1<byte> buffer, NativeOverlapped* overlapped, Int32& errorCode);
    private int WriteFileNative(SafePipeHandle handle, ReadOnlySpan`1<byte> buffer, NativeOverlapped* overlapped, Int32& errorCode);
    internal static SECURITY_ATTRIBUTES GetSecAttrs(HandleInheritability inheritability);
    internal static SECURITY_ATTRIBUTES GetSecAttrs(HandleInheritability inheritability, PipeSecurity pipeSecurity, GCHandle& pinningHandle);
    private void UpdateReadMode();
    internal Exception WinIOError(int errorCode);
    private void Init(PipeDirection direction, PipeTransmissionMode transmissionMode, int outBufferSize);
    protected void InitializeHandle(SafePipeHandle handle, bool isExposed, bool isAsync);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int Read(Span`1<byte> buffer);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual ValueTask`1<int> ReadAsync(Memory`1<byte> buffer, CancellationToken cancellationToken);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void Write(ReadOnlySpan`1<byte> buffer);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual ValueTask WriteAsync(ReadOnlyMemory`1<byte> buffer, CancellationToken cancellationToken);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual void EndWrite(IAsyncResult asyncResult);
    private void CheckReadWriteArgs(Byte[] buffer, int offset, int count);
    [ConditionalAttribute("DEBUG")]
private static void DebugAssertHandleValid(SafePipeHandle handle);
    [ConditionalAttribute("DEBUG")]
private static void DebugAssertReadWriteArgs(Byte[] buffer, int offset, int count, SafePipeHandle handle);
    public virtual int ReadByte();
    public virtual void WriteByte(byte value);
    public virtual void Flush();
    protected virtual void Dispose(bool disposing);
    public bool get_IsConnected();
    protected void set_IsConnected(bool value);
    public bool get_IsAsync();
    public bool get_IsMessageComplete();
    internal void UpdateMessageCompletion(bool completion);
    public SafePipeHandle get_SafePipeHandle();
    internal SafePipeHandle get_InternalHandle();
    protected bool get_IsHandleExposed();
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
    public virtual bool get_CanSeek();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void SetLength(long value);
    public virtual long Seek(long offset, SeekOrigin origin);
    protected internal virtual void CheckPipePropertyOperations();
    protected internal void CheckReadOperations();
    protected internal void CheckWriteOperations();
    internal PipeState get_State();
    internal void set_State(PipeState value);
    internal bool get_IsCurrentUserOnly();
    internal void set_IsCurrentUserOnly(bool value);
    public PipeSecurity GetAccessControl();
    public void SetAccessControl(PipeSecurity pipeSecurity);
}
public class System.IO.Pipes.PipeStreamImpersonationWorker : MulticastDelegate {
    public PipeStreamImpersonationWorker(object object, IntPtr method);
    public virtual void Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public enum System.IO.Pipes.PipeTransmissionMode : Enum {
    public int value__;
    public static PipeTransmissionMode Byte;
    public static PipeTransmissionMode Message;
}
internal class System.IO.Pipes.ReadWriteCompletionSource : PipeCompletionSource`1<int> {
    private bool _isWrite;
    private PipeStream _pipeStream;
    private bool _isMessageComplete;
    private int _numBytes;
    internal ReadWriteCompletionSource(PipeStream stream, ReadOnlyMemory`1<byte> bufferToPin, bool isWrite);
    internal virtual void SetCompletedSynchronously();
    protected virtual void AsyncCallback(UInt32 errorCode, UInt32 numBytes);
    protected virtual void HandleError(int errorCode);
}
internal class System.IO.Pipes.VoidResult : ValueType {
}
internal static class System.Linq.AggregationMinMaxHelpers`1 : object {
    private static T Reduce(IEnumerable`1<T> source, int sign);
    internal static T ReduceMin(IEnumerable`1<T> source);
    internal static T ReduceMax(IEnumerable`1<T> source);
    private static Func`3<Pair`2<bool, T>, T, Pair`2<bool, T>> MakeIntermediateReduceFunction(int sign);
    private static Func`3<Pair`2<bool, T>, Pair`2<bool, T>, Pair`2<bool, T>> MakeFinalReduceFunction(int sign);
    private static Func`2<Pair`2<bool, T>, T> MakeResultSelectorFunction();
}
[IsReadOnlyAttribute]
internal class System.Linq.Buffer`1 : ValueType {
    internal TElement[] _items;
    internal int _count;
    internal Buffer`1(IEnumerable`1<TElement> source);
}
internal static class System.Linq.CachedReflectionInfo : object {
    private static MethodInfo s_Aggregate_TSource_2;
    private static MethodInfo s_Aggregate_TSource_TAccumulate_3;
    private static MethodInfo s_Aggregate_TSource_TAccumulate_TResult_4;
    private static MethodInfo s_All_TSource_2;
    private static MethodInfo s_Any_TSource_1;
    private static MethodInfo s_Any_TSource_2;
    private static MethodInfo s_Average_Int32_1;
    private static MethodInfo s_Average_NullableInt32_1;
    private static MethodInfo s_Average_Int64_1;
    private static MethodInfo s_Average_NullableInt64_1;
    private static MethodInfo s_Average_Single_1;
    private static MethodInfo s_Average_NullableSingle_1;
    private static MethodInfo s_Average_Double_1;
    private static MethodInfo s_Average_NullableDouble_1;
    private static MethodInfo s_Average_Decimal_1;
    private static MethodInfo s_Average_NullableDecimal_1;
    private static MethodInfo s_Average_Int32_TSource_2;
    private static MethodInfo s_Average_NullableInt32_TSource_2;
    private static MethodInfo s_Average_Single_TSource_2;
    private static MethodInfo s_Average_NullableSingle_TSource_2;
    private static MethodInfo s_Average_Int64_TSource_2;
    private static MethodInfo s_Average_NullableInt64_TSource_2;
    private static MethodInfo s_Average_Double_TSource_2;
    private static MethodInfo s_Average_NullableDouble_TSource_2;
    private static MethodInfo s_Average_Decimal_TSource_2;
    private static MethodInfo s_Average_NullableDecimal_TSource_2;
    private static MethodInfo s_Cast_TResult_1;
    private static MethodInfo s_Concat_TSource_2;
    private static MethodInfo s_Contains_TSource_2;
    private static MethodInfo s_Contains_TSource_3;
    private static MethodInfo s_Count_TSource_1;
    private static MethodInfo s_Count_TSource_2;
    private static MethodInfo s_DefaultIfEmpty_TSource_1;
    private static MethodInfo s_DefaultIfEmpty_TSource_2;
    private static MethodInfo s_Distinct_TSource_1;
    private static MethodInfo s_Distinct_TSource_2;
    private static MethodInfo s_ElementAt_TSource_2;
    private static MethodInfo s_ElementAtOrDefault_TSource_2;
    private static MethodInfo s_Except_TSource_2;
    private static MethodInfo s_Except_TSource_3;
    private static MethodInfo s_First_TSource_1;
    private static MethodInfo s_First_TSource_2;
    private static MethodInfo s_FirstOrDefault_TSource_1;
    private static MethodInfo s_FirstOrDefault_TSource_2;
    private static MethodInfo s_GroupBy_TSource_TKey_2;
    private static MethodInfo s_GroupBy_TSource_TKey_3;
    private static MethodInfo s_GroupBy_TSource_TKey_TElement_3;
    private static MethodInfo s_GroupBy_TSource_TKey_TElement_4;
    private static MethodInfo s_GroupBy_TSource_TKey_TResult_3;
    private static MethodInfo s_GroupBy_TSource_TKey_TResult_4;
    private static MethodInfo s_GroupBy_TSource_TKey_TElement_TResult_4;
    private static MethodInfo s_GroupBy_TSource_TKey_TElement_TResult_5;
    private static MethodInfo s_GroupJoin_TOuter_TInner_TKey_TResult_5;
    private static MethodInfo s_GroupJoin_TOuter_TInner_TKey_TResult_6;
    private static MethodInfo s_Intersect_TSource_2;
    private static MethodInfo s_Intersect_TSource_3;
    private static MethodInfo s_Join_TOuter_TInner_TKey_TResult_5;
    private static MethodInfo s_Join_TOuter_TInner_TKey_TResult_6;
    private static MethodInfo s_Last_TSource_1;
    private static MethodInfo s_Last_TSource_2;
    private static MethodInfo s_LastOrDefault_TSource_1;
    private static MethodInfo s_LastOrDefault_TSource_2;
    private static MethodInfo s_LongCount_TSource_1;
    private static MethodInfo s_LongCount_TSource_2;
    private static MethodInfo s_Max_TSource_1;
    private static MethodInfo s_Max_TSource_TResult_2;
    private static MethodInfo s_Min_TSource_1;
    private static MethodInfo s_Min_TSource_TResult_2;
    private static MethodInfo s_OfType_TResult_1;
    private static MethodInfo s_OrderBy_TSource_TKey_2;
    private static MethodInfo s_OrderBy_TSource_TKey_3;
    private static MethodInfo s_OrderByDescending_TSource_TKey_2;
    private static MethodInfo s_OrderByDescending_TSource_TKey_3;
    private static MethodInfo s_Reverse_TSource_1;
    private static MethodInfo s_Select_TSource_TResult_2;
    private static MethodInfo s_Select_Index_TSource_TResult_2;
    private static MethodInfo s_SelectMany_TSource_TResult_2;
    private static MethodInfo s_SelectMany_Index_TSource_TResult_2;
    private static MethodInfo s_SelectMany_Index_TSource_TCollection_TResult_3;
    private static MethodInfo s_SelectMany_TSource_TCollection_TResult_3;
    private static MethodInfo s_SequenceEqual_TSource_2;
    private static MethodInfo s_SequenceEqual_TSource_3;
    private static MethodInfo s_Single_TSource_1;
    private static MethodInfo s_Single_TSource_2;
    private static MethodInfo s_SingleOrDefault_TSource_1;
    private static MethodInfo s_SingleOrDefault_TSource_2;
    private static MethodInfo s_Skip_TSource_2;
    private static MethodInfo s_SkipWhile_TSource_2;
    private static MethodInfo s_SkipWhile_Index_TSource_2;
    private static MethodInfo s_Sum_Int32_1;
    private static MethodInfo s_Sum_NullableInt32_1;
    private static MethodInfo s_Sum_Int64_1;
    private static MethodInfo s_Sum_NullableInt64_1;
    private static MethodInfo s_Sum_Single_1;
    private static MethodInfo s_Sum_NullableSingle_1;
    private static MethodInfo s_Sum_Double_1;
    private static MethodInfo s_Sum_NullableDouble_1;
    private static MethodInfo s_Sum_Decimal_1;
    private static MethodInfo s_Sum_NullableDecimal_1;
    private static MethodInfo s_Sum_NullableDecimal_TSource_2;
    private static MethodInfo s_Sum_Int32_TSource_2;
    private static MethodInfo s_Sum_NullableInt32_TSource_2;
    private static MethodInfo s_Sum_Int64_TSource_2;
    private static MethodInfo s_Sum_NullableInt64_TSource_2;
    private static MethodInfo s_Sum_Single_TSource_2;
    private static MethodInfo s_Sum_NullableSingle_TSource_2;
    private static MethodInfo s_Sum_Double_TSource_2;
    private static MethodInfo s_Sum_NullableDouble_TSource_2;
    private static MethodInfo s_Sum_Decimal_TSource_2;
    private static MethodInfo s_Take_TSource_2;
    private static MethodInfo s_TakeWhile_TSource_2;
    private static MethodInfo s_TakeWhile_Index_TSource_2;
    private static MethodInfo s_ThenBy_TSource_TKey_2;
    private static MethodInfo s_ThenBy_TSource_TKey_3;
    private static MethodInfo s_ThenByDescending_TSource_TKey_2;
    private static MethodInfo s_ThenByDescending_TSource_TKey_3;
    private static MethodInfo s_Union_TSource_2;
    private static MethodInfo s_Union_TSource_3;
    private static MethodInfo s_Where_TSource_2;
    private static MethodInfo s_Where_Index_TSource_2;
    private static MethodInfo s_Zip_TFirst_TSecond_TResult_3;
    private static MethodInfo s_SkipLast_TSource_2;
    private static MethodInfo s_TakeLast_TSource_2;
    private static MethodInfo s_Append_TSource_2;
    private static MethodInfo s_Prepend_TSource_2;
    public static MethodInfo Average_Int32_1 { get; }
    public static MethodInfo Average_NullableInt32_1 { get; }
    public static MethodInfo Average_Int64_1 { get; }
    public static MethodInfo Average_NullableInt64_1 { get; }
    public static MethodInfo Average_Single_1 { get; }
    public static MethodInfo Average_NullableSingle_1 { get; }
    public static MethodInfo Average_Double_1 { get; }
    public static MethodInfo Average_NullableDouble_1 { get; }
    public static MethodInfo Average_Decimal_1 { get; }
    public static MethodInfo Average_NullableDecimal_1 { get; }
    public static MethodInfo Sum_Int32_1 { get; }
    public static MethodInfo Sum_NullableInt32_1 { get; }
    public static MethodInfo Sum_Int64_1 { get; }
    public static MethodInfo Sum_NullableInt64_1 { get; }
    public static MethodInfo Sum_Single_1 { get; }
    public static MethodInfo Sum_NullableSingle_1 { get; }
    public static MethodInfo Sum_Double_1 { get; }
    public static MethodInfo Sum_NullableDouble_1 { get; }
    public static MethodInfo Sum_Decimal_1 { get; }
    public static MethodInfo Sum_NullableDecimal_1 { get; }
    public static MethodInfo Aggregate_TSource_2(Type TSource);
    public static MethodInfo Aggregate_TSource_TAccumulate_3(Type TSource, Type TAccumulate);
    public static MethodInfo Aggregate_TSource_TAccumulate_TResult_4(Type TSource, Type TAccumulate, Type TResult);
    public static MethodInfo All_TSource_2(Type TSource);
    public static MethodInfo Any_TSource_1(Type TSource);
    public static MethodInfo Any_TSource_2(Type TSource);
    public static MethodInfo get_Average_Int32_1();
    public static MethodInfo get_Average_NullableInt32_1();
    public static MethodInfo get_Average_Int64_1();
    public static MethodInfo get_Average_NullableInt64_1();
    public static MethodInfo get_Average_Single_1();
    public static MethodInfo get_Average_NullableSingle_1();
    public static MethodInfo get_Average_Double_1();
    public static MethodInfo get_Average_NullableDouble_1();
    public static MethodInfo get_Average_Decimal_1();
    public static MethodInfo get_Average_NullableDecimal_1();
    public static MethodInfo Average_Int32_TSource_2(Type TSource);
    public static MethodInfo Average_NullableInt32_TSource_2(Type TSource);
    public static MethodInfo Average_Single_TSource_2(Type TSource);
    public static MethodInfo Average_NullableSingle_TSource_2(Type TSource);
    public static MethodInfo Average_Int64_TSource_2(Type TSource);
    public static MethodInfo Average_NullableInt64_TSource_2(Type TSource);
    public static MethodInfo Average_Double_TSource_2(Type TSource);
    public static MethodInfo Average_NullableDouble_TSource_2(Type TSource);
    public static MethodInfo Average_Decimal_TSource_2(Type TSource);
    public static MethodInfo Average_NullableDecimal_TSource_2(Type TSource);
    public static MethodInfo Cast_TResult_1(Type TResult);
    public static MethodInfo Concat_TSource_2(Type TSource);
    public static MethodInfo Contains_TSource_2(Type TSource);
    public static MethodInfo Contains_TSource_3(Type TSource);
    public static MethodInfo Count_TSource_1(Type TSource);
    public static MethodInfo Count_TSource_2(Type TSource);
    public static MethodInfo DefaultIfEmpty_TSource_1(Type TSource);
    public static MethodInfo DefaultIfEmpty_TSource_2(Type TSource);
    public static MethodInfo Distinct_TSource_1(Type TSource);
    public static MethodInfo Distinct_TSource_2(Type TSource);
    public static MethodInfo ElementAt_TSource_2(Type TSource);
    public static MethodInfo ElementAtOrDefault_TSource_2(Type TSource);
    public static MethodInfo Except_TSource_2(Type TSource);
    public static MethodInfo Except_TSource_3(Type TSource);
    public static MethodInfo First_TSource_1(Type TSource);
    public static MethodInfo First_TSource_2(Type TSource);
    public static MethodInfo FirstOrDefault_TSource_1(Type TSource);
    public static MethodInfo FirstOrDefault_TSource_2(Type TSource);
    public static MethodInfo GroupBy_TSource_TKey_2(Type TSource, Type TKey);
    public static MethodInfo GroupBy_TSource_TKey_3(Type TSource, Type TKey);
    public static MethodInfo GroupBy_TSource_TKey_TElement_3(Type TSource, Type TKey, Type TElement);
    public static MethodInfo GroupBy_TSource_TKey_TElement_4(Type TSource, Type TKey, Type TElement);
    public static MethodInfo GroupBy_TSource_TKey_TResult_3(Type TSource, Type TKey, Type TResult);
    public static MethodInfo GroupBy_TSource_TKey_TResult_4(Type TSource, Type TKey, Type TResult);
    public static MethodInfo GroupBy_TSource_TKey_TElement_TResult_4(Type TSource, Type TKey, Type TElement, Type TResult);
    public static MethodInfo GroupBy_TSource_TKey_TElement_TResult_5(Type TSource, Type TKey, Type TElement, Type TResult);
    public static MethodInfo GroupJoin_TOuter_TInner_TKey_TResult_5(Type TOuter, Type TInner, Type TKey, Type TResult);
    public static MethodInfo GroupJoin_TOuter_TInner_TKey_TResult_6(Type TOuter, Type TInner, Type TKey, Type TResult);
    public static MethodInfo Intersect_TSource_2(Type TSource);
    public static MethodInfo Intersect_TSource_3(Type TSource);
    public static MethodInfo Join_TOuter_TInner_TKey_TResult_5(Type TOuter, Type TInner, Type TKey, Type TResult);
    public static MethodInfo Join_TOuter_TInner_TKey_TResult_6(Type TOuter, Type TInner, Type TKey, Type TResult);
    public static MethodInfo Last_TSource_1(Type TSource);
    public static MethodInfo Last_TSource_2(Type TSource);
    public static MethodInfo LastOrDefault_TSource_1(Type TSource);
    public static MethodInfo LastOrDefault_TSource_2(Type TSource);
    public static MethodInfo LongCount_TSource_1(Type TSource);
    public static MethodInfo LongCount_TSource_2(Type TSource);
    public static MethodInfo Max_TSource_1(Type TSource);
    public static MethodInfo Max_TSource_TResult_2(Type TSource, Type TResult);
    public static MethodInfo Min_TSource_1(Type TSource);
    public static MethodInfo Min_TSource_TResult_2(Type TSource, Type TResult);
    public static MethodInfo OfType_TResult_1(Type TResult);
    public static MethodInfo OrderBy_TSource_TKey_2(Type TSource, Type TKey);
    public static MethodInfo OrderBy_TSource_TKey_3(Type TSource, Type TKey);
    public static MethodInfo OrderByDescending_TSource_TKey_2(Type TSource, Type TKey);
    public static MethodInfo OrderByDescending_TSource_TKey_3(Type TSource, Type TKey);
    public static MethodInfo Reverse_TSource_1(Type TSource);
    public static MethodInfo Select_TSource_TResult_2(Type TSource, Type TResult);
    public static MethodInfo Select_Index_TSource_TResult_2(Type TSource, Type TResult);
    public static MethodInfo SelectMany_TSource_TResult_2(Type TSource, Type TResult);
    public static MethodInfo SelectMany_Index_TSource_TResult_2(Type TSource, Type TResult);
    public static MethodInfo SelectMany_Index_TSource_TCollection_TResult_3(Type TSource, Type TCollection, Type TResult);
    public static MethodInfo SelectMany_TSource_TCollection_TResult_3(Type TSource, Type TCollection, Type TResult);
    public static MethodInfo SequenceEqual_TSource_2(Type TSource);
    public static MethodInfo SequenceEqual_TSource_3(Type TSource);
    public static MethodInfo Single_TSource_1(Type TSource);
    public static MethodInfo Single_TSource_2(Type TSource);
    public static MethodInfo SingleOrDefault_TSource_1(Type TSource);
    public static MethodInfo SingleOrDefault_TSource_2(Type TSource);
    public static MethodInfo Skip_TSource_2(Type TSource);
    public static MethodInfo SkipWhile_TSource_2(Type TSource);
    public static MethodInfo SkipWhile_Index_TSource_2(Type TSource);
    public static MethodInfo get_Sum_Int32_1();
    public static MethodInfo get_Sum_NullableInt32_1();
    public static MethodInfo get_Sum_Int64_1();
    public static MethodInfo get_Sum_NullableInt64_1();
    public static MethodInfo get_Sum_Single_1();
    public static MethodInfo get_Sum_NullableSingle_1();
    public static MethodInfo get_Sum_Double_1();
    public static MethodInfo get_Sum_NullableDouble_1();
    public static MethodInfo get_Sum_Decimal_1();
    public static MethodInfo get_Sum_NullableDecimal_1();
    public static MethodInfo Sum_NullableDecimal_TSource_2(Type TSource);
    public static MethodInfo Sum_Int32_TSource_2(Type TSource);
    public static MethodInfo Sum_NullableInt32_TSource_2(Type TSource);
    public static MethodInfo Sum_Int64_TSource_2(Type TSource);
    public static MethodInfo Sum_NullableInt64_TSource_2(Type TSource);
    public static MethodInfo Sum_Single_TSource_2(Type TSource);
    public static MethodInfo Sum_NullableSingle_TSource_2(Type TSource);
    public static MethodInfo Sum_Double_TSource_2(Type TSource);
    public static MethodInfo Sum_NullableDouble_TSource_2(Type TSource);
    public static MethodInfo Sum_Decimal_TSource_2(Type TSource);
    public static MethodInfo Take_TSource_2(Type TSource);
    public static MethodInfo TakeWhile_TSource_2(Type TSource);
    public static MethodInfo TakeWhile_Index_TSource_2(Type TSource);
    public static MethodInfo ThenBy_TSource_TKey_2(Type TSource, Type TKey);
    public static MethodInfo ThenBy_TSource_TKey_3(Type TSource, Type TKey);
    public static MethodInfo ThenByDescending_TSource_TKey_2(Type TSource, Type TKey);
    public static MethodInfo ThenByDescending_TSource_TKey_3(Type TSource, Type TKey);
    public static MethodInfo Union_TSource_2(Type TSource);
    public static MethodInfo Union_TSource_3(Type TSource);
    public static MethodInfo Where_TSource_2(Type TSource);
    public static MethodInfo Where_Index_TSource_2(Type TSource);
    public static MethodInfo Zip_TFirst_TSecond_TResult_3(Type TFirst, Type TSecond, Type TResult);
    public static MethodInfo SkipLast_TSource_2(Type TSource);
    public static MethodInfo TakeLast_TSource_2(Type TSource);
    public static MethodInfo Append_TSource_2(Type TSource);
    public static MethodInfo Prepend_TSource_2(Type TSource);
}
internal abstract class System.Linq.CachingComparer`1 : object {
    internal abstract virtual int Compare(TElement element, bool cacheLower);
    internal abstract virtual void SetElement(TElement element);
}
internal class System.Linq.CachingComparer`2 : CachingComparer`1<TElement> {
    protected Func`2<TElement, TKey> _keySelector;
    protected IComparer`1<TKey> _comparer;
    protected bool _descending;
    protected TKey _lastKey;
    public CachingComparer`2(Func`2<TElement, TKey> keySelector, IComparer`1<TKey> comparer, bool descending);
    internal virtual int Compare(TElement element, bool cacheLower);
    internal virtual void SetElement(TElement element);
}
internal class System.Linq.CachingComparerWithChild`2 : CachingComparer`2<TElement, TKey> {
    private CachingComparer`1<TElement> _child;
    public CachingComparerWithChild`2(Func`2<TElement, TKey> keySelector, IComparer`1<TKey> comparer, bool descending, CachingComparer`1<TElement> child);
    internal virtual int Compare(TElement element, bool cacheLower);
    internal virtual void SetElement(TElement element);
}
internal class System.Linq.EmptyPartition`1 : object {
    public static IPartition`1<TElement> Instance;
    [ExcludeFromCodeCoverageAttribute]
public TElement Current { get; }
    [ExcludeFromCodeCoverageAttribute]
private object System.Collections.IEnumerator.Current { get; }
    private static EmptyPartition`1();
    public sealed virtual IEnumerator`1<TElement> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual bool MoveNext();
    public sealed virtual TElement get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    private sealed virtual override void System.Collections.IEnumerator.Reset();
    private sealed virtual override void System.IDisposable.Dispose();
    public sealed virtual IPartition`1<TElement> Skip(int count);
    public sealed virtual IPartition`1<TElement> Take(int count);
    public sealed virtual TElement TryGetElementAt(int index, Boolean& found);
    public sealed virtual TElement TryGetFirst(Boolean& found);
    public sealed virtual TElement TryGetLast(Boolean& found);
    public sealed virtual TElement[] ToArray();
    public sealed virtual List`1<TElement> ToList();
    public sealed virtual int GetCount(bool onlyIfCheap);
}
[ExtensionAttribute]
public static class System.Linq.Enumerable : object {
    [ExtensionAttribute]
public static TSource Aggregate(IEnumerable`1<TSource> source, Func`3<TSource, TSource, TSource> func);
    [ExtensionAttribute]
public static TAccumulate Aggregate(IEnumerable`1<TSource> source, TAccumulate seed, Func`3<TAccumulate, TSource, TAccumulate> func);
    [ExtensionAttribute]
public static TResult Aggregate(IEnumerable`1<TSource> source, TAccumulate seed, Func`3<TAccumulate, TSource, TAccumulate> func, Func`2<TAccumulate, TResult> resultSelector);
    [ExtensionAttribute]
public static bool Any(IEnumerable`1<TSource> source);
    [ExtensionAttribute]
public static bool Any(IEnumerable`1<TSource> source, Func`2<TSource, bool> predicate);
    [ExtensionAttribute]
public static bool All(IEnumerable`1<TSource> source, Func`2<TSource, bool> predicate);
    [ExtensionAttribute]
public static IEnumerable`1<TSource> Append(IEnumerable`1<TSource> source, TSource element);
    [ExtensionAttribute]
public static IEnumerable`1<TSource> Prepend(IEnumerable`1<TSource> source, TSource element);
    [ExtensionAttribute]
public static double Average(IEnumerable`1<int> source);
    [ExtensionAttribute]
public static Nullable`1<double> Average(IEnumerable`1<Nullable`1<int>> source);
    [ExtensionAttribute]
public static double Average(IEnumerable`1<long> source);
    [ExtensionAttribute]
public static Nullable`1<double> Average(IEnumerable`1<Nullable`1<long>> source);
    [ExtensionAttribute]
public static float Average(IEnumerable`1<float> source);
    [ExtensionAttribute]
public static Nullable`1<float> Average(IEnumerable`1<Nullable`1<float>> source);
    [ExtensionAttribute]
public static double Average(IEnumerable`1<double> source);
    [ExtensionAttribute]
public static Nullable`1<double> Average(IEnumerable`1<Nullable`1<double>> source);
    [ExtensionAttribute]
public static decimal Average(IEnumerable`1<decimal> source);
    [ExtensionAttribute]
public static Nullable`1<decimal> Average(IEnumerable`1<Nullable`1<decimal>> source);
    [ExtensionAttribute]
public static double Average(IEnumerable`1<TSource> source, Func`2<TSource, int> selector);
    [ExtensionAttribute]
public static Nullable`1<double> Average(IEnumerable`1<TSource> source, Func`2<TSource, Nullable`1<int>> selector);
    [ExtensionAttribute]
public static double Average(IEnumerable`1<TSource> source, Func`2<TSource, long> selector);
    [ExtensionAttribute]
public static Nullable`1<double> Average(IEnumerable`1<TSource> source, Func`2<TSource, Nullable`1<long>> selector);
    [ExtensionAttribute]
public static float Average(IEnumerable`1<TSource> source, Func`2<TSource, float> selector);
    [ExtensionAttribute]
public static Nullable`1<float> Average(IEnumerable`1<TSource> source, Func`2<TSource, Nullable`1<float>> selector);
    [ExtensionAttribute]
public static double Average(IEnumerable`1<TSource> source, Func`2<TSource, double> selector);
    [ExtensionAttribute]
public static Nullable`1<double> Average(IEnumerable`1<TSource> source, Func`2<TSource, Nullable`1<double>> selector);
    [ExtensionAttribute]
public static decimal Average(IEnumerable`1<TSource> source, Func`2<TSource, decimal> selector);
    [ExtensionAttribute]
public static Nullable`1<decimal> Average(IEnumerable`1<TSource> source, Func`2<TSource, Nullable`1<decimal>> selector);
    [ExtensionAttribute]
public static IEnumerable`1<TResult> OfType(IEnumerable source);
    [IteratorStateMachineAttribute("System.Linq.Enumerable/<OfTypeIterator>d__32`1")]
private static IEnumerable`1<TResult> OfTypeIterator(IEnumerable source);
    [ExtensionAttribute]
public static IEnumerable`1<TResult> Cast(IEnumerable source);
    [IteratorStateMachineAttribute("System.Linq.Enumerable/<CastIterator>d__34`1")]
private static IEnumerable`1<TResult> CastIterator(IEnumerable source);
    [ExtensionAttribute]
public static IEnumerable`1<TSource> Concat(IEnumerable`1<TSource> first, IEnumerable`1<TSource> second);
    [ExtensionAttribute]
public static bool Contains(IEnumerable`1<TSource> source, TSource value);
    [ExtensionAttribute]
public static bool Contains(IEnumerable`1<TSource> source, TSource value, IEqualityComparer`1<TSource> comparer);
    [ExtensionAttribute]
public static int Count(IEnumerable`1<TSource> source);
    [ExtensionAttribute]
public static int Count(IEnumerable`1<TSource> source, Func`2<TSource, bool> predicate);
    [ExtensionAttribute]
public static long LongCount(IEnumerable`1<TSource> source);
    [ExtensionAttribute]
public static long LongCount(IEnumerable`1<TSource> source, Func`2<TSource, bool> predicate);
    [ExtensionAttribute]
public static IEnumerable`1<TSource> DefaultIfEmpty(IEnumerable`1<TSource> source);
    [ExtensionAttribute]
public static IEnumerable`1<TSource> DefaultIfEmpty(IEnumerable`1<TSource> source, TSource defaultValue);
    [ExtensionAttribute]
public static IEnumerable`1<TSource> Distinct(IEnumerable`1<TSource> source);
    [ExtensionAttribute]
public static IEnumerable`1<TSource> Distinct(IEnumerable`1<TSource> source, IEqualityComparer`1<TSource> comparer);
    [ExtensionAttribute]
public static TSource ElementAt(IEnumerable`1<TSource> source, int index);
    [ExtensionAttribute]
public static TSource ElementAtOrDefault(IEnumerable`1<TSource> source, int index);
    [ExtensionAttribute]
public static IEnumerable`1<TSource> AsEnumerable(IEnumerable`1<TSource> source);
    public static IEnumerable`1<TResult> Empty();
    [ExtensionAttribute]
public static IEnumerable`1<TSource> Except(IEnumerable`1<TSource> first, IEnumerable`1<TSource> second);
    [ExtensionAttribute]
public static IEnumerable`1<TSource> Except(IEnumerable`1<TSource> first, IEnumerable`1<TSource> second, IEqualityComparer`1<TSource> comparer);
    [IteratorStateMachineAttribute("System.Linq.Enumerable/<ExceptIterator>d__57`1")]
private static IEnumerable`1<TSource> ExceptIterator(IEnumerable`1<TSource> first, IEnumerable`1<TSource> second, IEqualityComparer`1<TSource> comparer);
    [ExtensionAttribute]
public static TSource First(IEnumerable`1<TSource> source);
    [ExtensionAttribute]
public static TSource First(IEnumerable`1<TSource> source, Func`2<TSource, bool> predicate);
    [ExtensionAttribute]
public static TSource FirstOrDefault(IEnumerable`1<TSource> source);
    [ExtensionAttribute]
public static TSource FirstOrDefault(IEnumerable`1<TSource> source, Func`2<TSource, bool> predicate);
    [ExtensionAttribute]
private static TSource TryGetFirst(IEnumerable`1<TSource> source, Boolean& found);
    [ExtensionAttribute]
private static TSource TryGetFirst(IEnumerable`1<TSource> source, Func`2<TSource, bool> predicate, Boolean& found);
    [ExtensionAttribute]
public static IEnumerable`1<TResult> GroupJoin(IEnumerable`1<TOuter> outer, IEnumerable`1<TInner> inner, Func`2<TOuter, TKey> outerKeySelector, Func`2<TInner, TKey> innerKeySelector, Func`3<TOuter, IEnumerable`1<TInner>, TResult> resultSelector);
    [ExtensionAttribute]
public static IEnumerable`1<TResult> GroupJoin(IEnumerable`1<TOuter> outer, IEnumerable`1<TInner> inner, Func`2<TOuter, TKey> outerKeySelector, Func`2<TInner, TKey> innerKeySelector, Func`3<TOuter, IEnumerable`1<TInner>, TResult> resultSelector, IEqualityComparer`1<TKey> comparer);
    [IteratorStateMachineAttribute("System.Linq.Enumerable/<GroupJoinIterator>d__66`4")]
private static IEnumerable`1<TResult> GroupJoinIterator(IEnumerable`1<TOuter> outer, IEnumerable`1<TInner> inner, Func`2<TOuter, TKey> outerKeySelector, Func`2<TInner, TKey> innerKeySelector, Func`3<TOuter, IEnumerable`1<TInner>, TResult> resultSelector, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static IEnumerable`1<IGrouping`2<TKey, TSource>> GroupBy(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector);
    [ExtensionAttribute]
public static IEnumerable`1<IGrouping`2<TKey, TSource>> GroupBy(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static IEnumerable`1<IGrouping`2<TKey, TElement>> GroupBy(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`2<TSource, TElement> elementSelector);
    [ExtensionAttribute]
public static IEnumerable`1<IGrouping`2<TKey, TElement>> GroupBy(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`2<TSource, TElement> elementSelector, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static IEnumerable`1<TResult> GroupBy(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`3<TKey, IEnumerable`1<TSource>, TResult> resultSelector);
    [ExtensionAttribute]
public static IEnumerable`1<TResult> GroupBy(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`2<TSource, TElement> elementSelector, Func`3<TKey, IEnumerable`1<TElement>, TResult> resultSelector);
    [ExtensionAttribute]
public static IEnumerable`1<TResult> GroupBy(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`3<TKey, IEnumerable`1<TSource>, TResult> resultSelector, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static IEnumerable`1<TResult> GroupBy(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`2<TSource, TElement> elementSelector, Func`3<TKey, IEnumerable`1<TElement>, TResult> resultSelector, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static IEnumerable`1<TSource> Intersect(IEnumerable`1<TSource> first, IEnumerable`1<TSource> second);
    [ExtensionAttribute]
public static IEnumerable`1<TSource> Intersect(IEnumerable`1<TSource> first, IEnumerable`1<TSource> second, IEqualityComparer`1<TSource> comparer);
    [IteratorStateMachineAttribute("System.Linq.Enumerable/<IntersectIterator>d__77`1")]
private static IEnumerable`1<TSource> IntersectIterator(IEnumerable`1<TSource> first, IEnumerable`1<TSource> second, IEqualityComparer`1<TSource> comparer);
    [ExtensionAttribute]
public static IEnumerable`1<TResult> Join(IEnumerable`1<TOuter> outer, IEnumerable`1<TInner> inner, Func`2<TOuter, TKey> outerKeySelector, Func`2<TInner, TKey> innerKeySelector, Func`3<TOuter, TInner, TResult> resultSelector);
    [ExtensionAttribute]
public static IEnumerable`1<TResult> Join(IEnumerable`1<TOuter> outer, IEnumerable`1<TInner> inner, Func`2<TOuter, TKey> outerKeySelector, Func`2<TInner, TKey> innerKeySelector, Func`3<TOuter, TInner, TResult> resultSelector, IEqualityComparer`1<TKey> comparer);
    [IteratorStateMachineAttribute("System.Linq.Enumerable/<JoinIterator>d__81`4")]
private static IEnumerable`1<TResult> JoinIterator(IEnumerable`1<TOuter> outer, IEnumerable`1<TInner> inner, Func`2<TOuter, TKey> outerKeySelector, Func`2<TInner, TKey> innerKeySelector, Func`3<TOuter, TInner, TResult> resultSelector, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static TSource Last(IEnumerable`1<TSource> source);
    [ExtensionAttribute]
public static TSource Last(IEnumerable`1<TSource> source, Func`2<TSource, bool> predicate);
    [ExtensionAttribute]
public static TSource LastOrDefault(IEnumerable`1<TSource> source);
    [ExtensionAttribute]
public static TSource LastOrDefault(IEnumerable`1<TSource> source, Func`2<TSource, bool> predicate);
    [ExtensionAttribute]
private static TSource TryGetLast(IEnumerable`1<TSource> source, Boolean& found);
    [ExtensionAttribute]
private static TSource TryGetLast(IEnumerable`1<TSource> source, Func`2<TSource, bool> predicate, Boolean& found);
    [ExtensionAttribute]
public static ILookup`2<TKey, TSource> ToLookup(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector);
    [ExtensionAttribute]
public static ILookup`2<TKey, TSource> ToLookup(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static ILookup`2<TKey, TElement> ToLookup(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`2<TSource, TElement> elementSelector);
    [ExtensionAttribute]
public static ILookup`2<TKey, TElement> ToLookup(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`2<TSource, TElement> elementSelector, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static int Max(IEnumerable`1<int> source);
    [ExtensionAttribute]
public static Nullable`1<int> Max(IEnumerable`1<Nullable`1<int>> source);
    [ExtensionAttribute]
public static long Max(IEnumerable`1<long> source);
    [ExtensionAttribute]
public static Nullable`1<long> Max(IEnumerable`1<Nullable`1<long>> source);
    [ExtensionAttribute]
public static double Max(IEnumerable`1<double> source);
    [ExtensionAttribute]
public static Nullable`1<double> Max(IEnumerable`1<Nullable`1<double>> source);
    [ExtensionAttribute]
public static float Max(IEnumerable`1<float> source);
    [ExtensionAttribute]
public static Nullable`1<float> Max(IEnumerable`1<Nullable`1<float>> source);
    [ExtensionAttribute]
public static decimal Max(IEnumerable`1<decimal> source);
    [ExtensionAttribute]
public static Nullable`1<decimal> Max(IEnumerable`1<Nullable`1<decimal>> source);
    [ExtensionAttribute]
public static TSource Max(IEnumerable`1<TSource> source);
    [ExtensionAttribute]
public static int Max(IEnumerable`1<TSource> source, Func`2<TSource, int> selector);
    [ExtensionAttribute]
public static Nullable`1<int> Max(IEnumerable`1<TSource> source, Func`2<TSource, Nullable`1<int>> selector);
    [ExtensionAttribute]
public static long Max(IEnumerable`1<TSource> source, Func`2<TSource, long> selector);
    [ExtensionAttribute]
public static Nullable`1<long> Max(IEnumerable`1<TSource> source, Func`2<TSource, Nullable`1<long>> selector);
    [ExtensionAttribute]
public static float Max(IEnumerable`1<TSource> source, Func`2<TSource, float> selector);
    [ExtensionAttribute]
public static Nullable`1<float> Max(IEnumerable`1<TSource> source, Func`2<TSource, Nullable`1<float>> selector);
    [ExtensionAttribute]
public static double Max(IEnumerable`1<TSource> source, Func`2<TSource, double> selector);
    [ExtensionAttribute]
public static Nullable`1<double> Max(IEnumerable`1<TSource> source, Func`2<TSource, Nullable`1<double>> selector);
    [ExtensionAttribute]
public static decimal Max(IEnumerable`1<TSource> source, Func`2<TSource, decimal> selector);
    [ExtensionAttribute]
public static Nullable`1<decimal> Max(IEnumerable`1<TSource> source, Func`2<TSource, Nullable`1<decimal>> selector);
    [ExtensionAttribute]
public static TResult Max(IEnumerable`1<TSource> source, Func`2<TSource, TResult> selector);
    [ExtensionAttribute]
public static int Min(IEnumerable`1<int> source);
    [ExtensionAttribute]
public static Nullable`1<int> Min(IEnumerable`1<Nullable`1<int>> source);
    [ExtensionAttribute]
public static long Min(IEnumerable`1<long> source);
    [ExtensionAttribute]
public static Nullable`1<long> Min(IEnumerable`1<Nullable`1<long>> source);
    [ExtensionAttribute]
public static float Min(IEnumerable`1<float> source);
    [ExtensionAttribute]
public static Nullable`1<float> Min(IEnumerable`1<Nullable`1<float>> source);
    [ExtensionAttribute]
public static double Min(IEnumerable`1<double> source);
    [ExtensionAttribute]
public static Nullable`1<double> Min(IEnumerable`1<Nullable`1<double>> source);
    [ExtensionAttribute]
public static decimal Min(IEnumerable`1<decimal> source);
    [ExtensionAttribute]
public static Nullable`1<decimal> Min(IEnumerable`1<Nullable`1<decimal>> source);
    [ExtensionAttribute]
public static TSource Min(IEnumerable`1<TSource> source);
    [ExtensionAttribute]
public static int Min(IEnumerable`1<TSource> source, Func`2<TSource, int> selector);
    [ExtensionAttribute]
public static Nullable`1<int> Min(IEnumerable`1<TSource> source, Func`2<TSource, Nullable`1<int>> selector);
    [ExtensionAttribute]
public static long Min(IEnumerable`1<TSource> source, Func`2<TSource, long> selector);
    [ExtensionAttribute]
public static Nullable`1<long> Min(IEnumerable`1<TSource> source, Func`2<TSource, Nullable`1<long>> selector);
    [ExtensionAttribute]
public static float Min(IEnumerable`1<TSource> source, Func`2<TSource, float> selector);
    [ExtensionAttribute]
public static Nullable`1<float> Min(IEnumerable`1<TSource> source, Func`2<TSource, Nullable`1<float>> selector);
    [ExtensionAttribute]
public static double Min(IEnumerable`1<TSource> source, Func`2<TSource, double> selector);
    [ExtensionAttribute]
public static Nullable`1<double> Min(IEnumerable`1<TSource> source, Func`2<TSource, Nullable`1<double>> selector);
    [ExtensionAttribute]
public static decimal Min(IEnumerable`1<TSource> source, Func`2<TSource, decimal> selector);
    [ExtensionAttribute]
public static Nullable`1<decimal> Min(IEnumerable`1<TSource> source, Func`2<TSource, Nullable`1<decimal>> selector);
    [ExtensionAttribute]
public static TResult Min(IEnumerable`1<TSource> source, Func`2<TSource, TResult> selector);
    [ExtensionAttribute]
public static IOrderedEnumerable`1<TSource> OrderBy(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector);
    [ExtensionAttribute]
public static IOrderedEnumerable`1<TSource> OrderBy(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static IOrderedEnumerable`1<TSource> OrderByDescending(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector);
    [ExtensionAttribute]
public static IOrderedEnumerable`1<TSource> OrderByDescending(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static IOrderedEnumerable`1<TSource> ThenBy(IOrderedEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector);
    [ExtensionAttribute]
public static IOrderedEnumerable`1<TSource> ThenBy(IOrderedEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static IOrderedEnumerable`1<TSource> ThenByDescending(IOrderedEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector);
    [ExtensionAttribute]
public static IOrderedEnumerable`1<TSource> ThenByDescending(IOrderedEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> comparer);
    public static IEnumerable`1<int> Range(int start, int count);
    public static IEnumerable`1<TResult> Repeat(TResult element, int count);
    [ExtensionAttribute]
public static IEnumerable`1<TSource> Reverse(IEnumerable`1<TSource> source);
    [ExtensionAttribute]
public static IEnumerable`1<TResult> Select(IEnumerable`1<TSource> source, Func`2<TSource, TResult> selector);
    [ExtensionAttribute]
public static IEnumerable`1<TResult> Select(IEnumerable`1<TSource> source, Func`3<TSource, int, TResult> selector);
    [IteratorStateMachineAttribute("System.Linq.Enumerable/<SelectIterator>d__154`2")]
private static IEnumerable`1<TResult> SelectIterator(IEnumerable`1<TSource> source, Func`3<TSource, int, TResult> selector);
    [ExtensionAttribute]
public static IEnumerable`1<TResult> SelectMany(IEnumerable`1<TSource> source, Func`2<TSource, IEnumerable`1<TResult>> selector);
    [ExtensionAttribute]
public static IEnumerable`1<TResult> SelectMany(IEnumerable`1<TSource> source, Func`3<TSource, int, IEnumerable`1<TResult>> selector);
    [IteratorStateMachineAttribute("System.Linq.Enumerable/<SelectManyIterator>d__163`2")]
private static IEnumerable`1<TResult> SelectManyIterator(IEnumerable`1<TSource> source, Func`3<TSource, int, IEnumerable`1<TResult>> selector);
    [ExtensionAttribute]
public static IEnumerable`1<TResult> SelectMany(IEnumerable`1<TSource> source, Func`3<TSource, int, IEnumerable`1<TCollection>> collectionSelector, Func`3<TSource, TCollection, TResult> resultSelector);
    [IteratorStateMachineAttribute("System.Linq.Enumerable/<SelectManyIterator>d__165`3")]
private static IEnumerable`1<TResult> SelectManyIterator(IEnumerable`1<TSource> source, Func`3<TSource, int, IEnumerable`1<TCollection>> collectionSelector, Func`3<TSource, TCollection, TResult> resultSelector);
    [ExtensionAttribute]
public static IEnumerable`1<TResult> SelectMany(IEnumerable`1<TSource> source, Func`2<TSource, IEnumerable`1<TCollection>> collectionSelector, Func`3<TSource, TCollection, TResult> resultSelector);
    [IteratorStateMachineAttribute("System.Linq.Enumerable/<SelectManyIterator>d__167`3")]
private static IEnumerable`1<TResult> SelectManyIterator(IEnumerable`1<TSource> source, Func`2<TSource, IEnumerable`1<TCollection>> collectionSelector, Func`3<TSource, TCollection, TResult> resultSelector);
    [ExtensionAttribute]
public static bool SequenceEqual(IEnumerable`1<TSource> first, IEnumerable`1<TSource> second);
    [ExtensionAttribute]
public static bool SequenceEqual(IEnumerable`1<TSource> first, IEnumerable`1<TSource> second, IEqualityComparer`1<TSource> comparer);
    [ExtensionAttribute]
public static TSource Single(IEnumerable`1<TSource> source);
    [ExtensionAttribute]
public static TSource Single(IEnumerable`1<TSource> source, Func`2<TSource, bool> predicate);
    [ExtensionAttribute]
public static TSource SingleOrDefault(IEnumerable`1<TSource> source);
    [ExtensionAttribute]
public static TSource SingleOrDefault(IEnumerable`1<TSource> source, Func`2<TSource, bool> predicate);
    [ExtensionAttribute]
public static IEnumerable`1<TSource> Skip(IEnumerable`1<TSource> source, int count);
    [ExtensionAttribute]
public static IEnumerable`1<TSource> SkipWhile(IEnumerable`1<TSource> source, Func`2<TSource, bool> predicate);
    [IteratorStateMachineAttribute("System.Linq.Enumerable/<SkipWhileIterator>d__177`1")]
private static IEnumerable`1<TSource> SkipWhileIterator(IEnumerable`1<TSource> source, Func`2<TSource, bool> predicate);
    [ExtensionAttribute]
public static IEnumerable`1<TSource> SkipWhile(IEnumerable`1<TSource> source, Func`3<TSource, int, bool> predicate);
    [IteratorStateMachineAttribute("System.Linq.Enumerable/<SkipWhileIterator>d__179`1")]
private static IEnumerable`1<TSource> SkipWhileIterator(IEnumerable`1<TSource> source, Func`3<TSource, int, bool> predicate);
    [ExtensionAttribute]
public static IEnumerable`1<TSource> SkipLast(IEnumerable`1<TSource> source, int count);
    [IteratorStateMachineAttribute("System.Linq.Enumerable/<SkipLastIterator>d__181`1")]
private static IEnumerable`1<TSource> SkipLastIterator(IEnumerable`1<TSource> source, int count);
    [ExtensionAttribute]
public static int Sum(IEnumerable`1<int> source);
    [ExtensionAttribute]
public static Nullable`1<int> Sum(IEnumerable`1<Nullable`1<int>> source);
    [ExtensionAttribute]
public static long Sum(IEnumerable`1<long> source);
    [ExtensionAttribute]
public static Nullable`1<long> Sum(IEnumerable`1<Nullable`1<long>> source);
    [ExtensionAttribute]
public static float Sum(IEnumerable`1<float> source);
    [ExtensionAttribute]
public static Nullable`1<float> Sum(IEnumerable`1<Nullable`1<float>> source);
    [ExtensionAttribute]
public static double Sum(IEnumerable`1<double> source);
    [ExtensionAttribute]
public static Nullable`1<double> Sum(IEnumerable`1<Nullable`1<double>> source);
    [ExtensionAttribute]
public static decimal Sum(IEnumerable`1<decimal> source);
    [ExtensionAttribute]
public static Nullable`1<decimal> Sum(IEnumerable`1<Nullable`1<decimal>> source);
    [ExtensionAttribute]
public static int Sum(IEnumerable`1<TSource> source, Func`2<TSource, int> selector);
    [ExtensionAttribute]
public static Nullable`1<int> Sum(IEnumerable`1<TSource> source, Func`2<TSource, Nullable`1<int>> selector);
    [ExtensionAttribute]
public static long Sum(IEnumerable`1<TSource> source, Func`2<TSource, long> selector);
    [ExtensionAttribute]
public static Nullable`1<long> Sum(IEnumerable`1<TSource> source, Func`2<TSource, Nullable`1<long>> selector);
    [ExtensionAttribute]
public static float Sum(IEnumerable`1<TSource> source, Func`2<TSource, float> selector);
    [ExtensionAttribute]
public static Nullable`1<float> Sum(IEnumerable`1<TSource> source, Func`2<TSource, Nullable`1<float>> selector);
    [ExtensionAttribute]
public static double Sum(IEnumerable`1<TSource> source, Func`2<TSource, double> selector);
    [ExtensionAttribute]
public static Nullable`1<double> Sum(IEnumerable`1<TSource> source, Func`2<TSource, Nullable`1<double>> selector);
    [ExtensionAttribute]
public static decimal Sum(IEnumerable`1<TSource> source, Func`2<TSource, decimal> selector);
    [ExtensionAttribute]
public static Nullable`1<decimal> Sum(IEnumerable`1<TSource> source, Func`2<TSource, Nullable`1<decimal>> selector);
    [ExtensionAttribute]
public static IEnumerable`1<TSource> Take(IEnumerable`1<TSource> source, int count);
    [ExtensionAttribute]
public static IEnumerable`1<TSource> TakeWhile(IEnumerable`1<TSource> source, Func`2<TSource, bool> predicate);
    [IteratorStateMachineAttribute("System.Linq.Enumerable/<TakeWhileIterator>d__204`1")]
private static IEnumerable`1<TSource> TakeWhileIterator(IEnumerable`1<TSource> source, Func`2<TSource, bool> predicate);
    [ExtensionAttribute]
public static IEnumerable`1<TSource> TakeWhile(IEnumerable`1<TSource> source, Func`3<TSource, int, bool> predicate);
    [IteratorStateMachineAttribute("System.Linq.Enumerable/<TakeWhileIterator>d__206`1")]
private static IEnumerable`1<TSource> TakeWhileIterator(IEnumerable`1<TSource> source, Func`3<TSource, int, bool> predicate);
    [ExtensionAttribute]
public static IEnumerable`1<TSource> TakeLast(IEnumerable`1<TSource> source, int count);
    [IteratorStateMachineAttribute("System.Linq.Enumerable/<TakeLastIterator>d__208`1")]
private static IEnumerable`1<TSource> TakeLastIterator(IEnumerable`1<TSource> source, int count);
    [ExtensionAttribute]
public static TSource[] ToArray(IEnumerable`1<TSource> source);
    [ExtensionAttribute]
public static List`1<TSource> ToList(IEnumerable`1<TSource> source);
    [ExtensionAttribute]
public static Dictionary`2<TKey, TSource> ToDictionary(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector);
    [ExtensionAttribute]
public static Dictionary`2<TKey, TSource> ToDictionary(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, IEqualityComparer`1<TKey> comparer);
    private static Dictionary`2<TKey, TSource> ToDictionary(TSource[] source, Func`2<TSource, TKey> keySelector, IEqualityComparer`1<TKey> comparer);
    private static Dictionary`2<TKey, TSource> ToDictionary(List`1<TSource> source, Func`2<TSource, TKey> keySelector, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static Dictionary`2<TKey, TElement> ToDictionary(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`2<TSource, TElement> elementSelector);
    [ExtensionAttribute]
public static Dictionary`2<TKey, TElement> ToDictionary(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`2<TSource, TElement> elementSelector, IEqualityComparer`1<TKey> comparer);
    private static Dictionary`2<TKey, TElement> ToDictionary(TSource[] source, Func`2<TSource, TKey> keySelector, Func`2<TSource, TElement> elementSelector, IEqualityComparer`1<TKey> comparer);
    private static Dictionary`2<TKey, TElement> ToDictionary(List`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`2<TSource, TElement> elementSelector, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static HashSet`1<TSource> ToHashSet(IEnumerable`1<TSource> source);
    [ExtensionAttribute]
public static HashSet`1<TSource> ToHashSet(IEnumerable`1<TSource> source, IEqualityComparer`1<TSource> comparer);
    [ExtensionAttribute]
public static IEnumerable`1<TSource> Union(IEnumerable`1<TSource> first, IEnumerable`1<TSource> second);
    [ExtensionAttribute]
public static IEnumerable`1<TSource> Union(IEnumerable`1<TSource> first, IEnumerable`1<TSource> second, IEqualityComparer`1<TSource> comparer);
    [ExtensionAttribute]
public static IEnumerable`1<TSource> Where(IEnumerable`1<TSource> source, Func`2<TSource, bool> predicate);
    [ExtensionAttribute]
public static IEnumerable`1<TSource> Where(IEnumerable`1<TSource> source, Func`3<TSource, int, bool> predicate);
    [IteratorStateMachineAttribute("System.Linq.Enumerable/<WhereIterator>d__228`1")]
private static IEnumerable`1<TSource> WhereIterator(IEnumerable`1<TSource> source, Func`3<TSource, int, bool> predicate);
    [ExtensionAttribute]
public static IEnumerable`1<TResult> Zip(IEnumerable`1<TFirst> first, IEnumerable`1<TSecond> second, Func`3<TFirst, TSecond, TResult> resultSelector);
    [IteratorStateMachineAttribute("System.Linq.Enumerable/<ZipIterator>d__236`3")]
private static IEnumerable`1<TResult> ZipIterator(IEnumerable`1<TFirst> first, IEnumerable`1<TSecond> second, Func`3<TFirst, TSecond, TResult> resultSelector);
}
public abstract class System.Linq.EnumerableExecutor : object {
    internal abstract virtual object ExecuteBoxed();
    internal static EnumerableExecutor Create(Expression expression);
}
public class System.Linq.EnumerableExecutor`1 : EnumerableExecutor {
    private Expression _expression;
    public EnumerableExecutor`1(Expression expression);
    internal virtual object ExecuteBoxed();
    internal T Execute();
}
public abstract class System.Linq.EnumerableQuery : object {
    internal Expression Expression { get; }
    internal IEnumerable Enumerable { get; }
    internal abstract virtual Expression get_Expression();
    internal abstract virtual IEnumerable get_Enumerable();
    internal static IQueryable Create(Type elementType, IEnumerable sequence);
    internal static IQueryable Create(Type elementType, Expression expression);
}
public class System.Linq.EnumerableQuery`1 : EnumerableQuery {
    private Expression _expression;
    private IEnumerable`1<T> _enumerable;
    private IQueryProvider System.Linq.IQueryable.Provider { get; }
    internal Expression Expression { get; }
    internal IEnumerable Enumerable { get; }
    private Expression System.Linq.IQueryable.Expression { get; }
    private Type System.Linq.IQueryable.ElementType { get; }
    public EnumerableQuery`1(IEnumerable`1<T> enumerable);
    public EnumerableQuery`1(Expression expression);
    private sealed virtual override IQueryProvider System.Linq.IQueryable.get_Provider();
    internal virtual Expression get_Expression();
    internal virtual IEnumerable get_Enumerable();
    private sealed virtual override Expression System.Linq.IQueryable.get_Expression();
    private sealed virtual override Type System.Linq.IQueryable.get_ElementType();
    private sealed virtual override IQueryable System.Linq.IQueryProvider.CreateQuery(Expression expression);
    private sealed virtual override IQueryable`1<TElement> System.Linq.IQueryProvider.CreateQuery(Expression expression);
    private sealed virtual override object System.Linq.IQueryProvider.Execute(Expression expression);
    private sealed virtual override TElement System.Linq.IQueryProvider.Execute(Expression expression);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private IEnumerator`1<T> GetEnumerator();
    public virtual string ToString();
}
internal class System.Linq.EnumerableRewriter : ExpressionVisitor {
    private Dictionary`2<LabelTarget, LabelTarget> _targetCache;
    private Dictionary`2<Type, Type> _equivalentTypeCache;
    private static ILookup`2<string, MethodInfo> s_seqMethods;
    protected internal virtual Expression VisitMethodCall(MethodCallExpression m);
    private ReadOnlyCollection`1<Expression> FixupQuotedArgs(MethodInfo mi, ReadOnlyCollection`1<Expression> argList);
    private Expression FixupQuotedExpression(Type type, Expression expression);
    protected internal virtual Expression VisitLambda(Expression`1<T> node);
    private static Type GetPublicType(Type t);
    private Type GetEquivalentType(Type type);
    protected internal virtual Expression VisitConstant(ConstantExpression c);
    [PreserveDependencyAttribute("DefaultIfEmpty`1", "System.Linq.Enumerable")]
[PreserveDependencyAttribute("Count`1", "System.Linq.Enumerable")]
[PreserveDependencyAttribute("Contains`1", "System.Linq.Enumerable")]
[PreserveDependencyAttribute("Concat`1", "System.Linq.Enumerable")]
[PreserveDependencyAttribute("Cast`1", "System.Linq.Enumerable")]
[PreserveDependencyAttribute("Average`1", "System.Linq.Enumerable")]
[PreserveDependencyAttribute("Aggregate`1", "System.Linq.Enumerable")]
[PreserveDependencyAttribute("Append`1", "System.Linq.Enumerable")]
[PreserveDependencyAttribute("Any`1", "System.Linq.Enumerable")]
[PreserveDependencyAttribute("All`1", "System.Linq.Enumerable")]
[PreserveDependencyAttribute("Aggregate`3", "System.Linq.Enumerable")]
[PreserveDependencyAttribute("Aggregate`2", "System.Linq.Enumerable")]
[PreserveDependencyAttribute("GroupJoin`4", "System.Linq.Enumerable")]
[PreserveDependencyAttribute("Average", "System.Linq.Enumerable")]
[PreserveDependencyAttribute("Distinct`1", "System.Linq.Enumerable")]
[PreserveDependencyAttribute("Intersect`1", "System.Linq.Enumerable")]
[PreserveDependencyAttribute("Sum", "System.Linq.Enumerable")]
[PreserveDependencyAttribute("SkipWhile`1", "System.Linq.Enumerable")]
[PreserveDependencyAttribute("Except`1", "System.Linq.Enumerable")]
[PreserveDependencyAttribute("Sum`1", "System.Linq.Enumerable")]
[PreserveDependencyAttribute("Take`1", "System.Linq.Enumerable")]
[PreserveDependencyAttribute("TakeLast`1", "System.Linq.Enumerable")]
[PreserveDependencyAttribute("TakeWhile`1", "System.Linq.Enumerable")]
[PreserveDependencyAttribute("ThenBy`2", "System.Linq.Enumerable")]
[PreserveDependencyAttribute("ThenByDescending`2", "System.Linq.Enumerable")]
[PreserveDependencyAttribute("Union`1", "System.Linq.Enumerable")]
[PreserveDependencyAttribute("Where`1", "System.Linq.Enumerable")]
[PreserveDependencyAttribute("Zip`3", "System.Linq.Enumerable")]
[PreserveDependencyAttribute("GroupBy`4", "System.Linq.Enumerable")]
[PreserveDependencyAttribute("GroupBy`3", "System.Linq.Enumerable")]
[PreserveDependencyAttribute("GroupBy`2", "System.Linq.Enumerable")]
[PreserveDependencyAttribute("FirstOrDefault`1", "System.Linq.Enumerable")]
[PreserveDependencyAttribute("ElementAt`1", "System.Linq.Enumerable")]
[PreserveDependencyAttribute("First`1", "System.Linq.Enumerable")]
[PreserveDependencyAttribute("SkipLast`1", "System.Linq.Enumerable")]
[PreserveDependencyAttribute("Skip`1", "System.Linq.Enumerable")]
[PreserveDependencyAttribute("ElementAtOrDefault`1", "System.Linq.Enumerable")]
[PreserveDependencyAttribute("Single`1", "System.Linq.Enumerable")]
[PreserveDependencyAttribute("Join`4", "System.Linq.Enumerable")]
[PreserveDependencyAttribute("Last`1", "System.Linq.Enumerable")]
[PreserveDependencyAttribute("LastOrDefault`1", "System.Linq.Enumerable")]
[PreserveDependencyAttribute("LongCount`1", "System.Linq.Enumerable")]
[PreserveDependencyAttribute("SingleOrDefault`1", "System.Linq.Enumerable")]
[PreserveDependencyAttribute("Max`2", "System.Linq.Enumerable")]
[PreserveDependencyAttribute("Min`1", "System.Linq.Enumerable")]
[PreserveDependencyAttribute("Min`2", "System.Linq.Enumerable")]
[PreserveDependencyAttribute("Max`1", "System.Linq.Enumerable")]
[PreserveDependencyAttribute("OrderBy`2", "System.Linq.Enumerable")]
[PreserveDependencyAttribute("OrderByDescending`2", "System.Linq.Enumerable")]
[PreserveDependencyAttribute("Prepend`1", "System.Linq.Enumerable")]
[PreserveDependencyAttribute("Reverse`1", "System.Linq.Enumerable")]
[PreserveDependencyAttribute("Select`2", "System.Linq.Enumerable")]
[PreserveDependencyAttribute("SequenceEqual`1", "System.Linq.Enumerable")]
[PreserveDependencyAttribute("SelectMany`3", "System.Linq.Enumerable")]
[PreserveDependencyAttribute("SelectMany`2", "System.Linq.Enumerable")]
[PreserveDependencyAttribute("OfType`1", "System.Linq.Enumerable")]
private static MethodInfo FindEnumerableMethod(string name, ReadOnlyCollection`1<Expression> args, Type[] typeArgs);
    private static MethodInfo FindMethod(Type type, string name, ReadOnlyCollection`1<Expression> args, Type[] typeArgs);
    private static bool ArgsMatch(MethodInfo m, ReadOnlyCollection`1<Expression> args, Type[] typeArgs);
    private static Type StripExpression(Type type);
    protected internal virtual Expression VisitConditional(ConditionalExpression c);
    protected internal virtual Expression VisitBlock(BlockExpression node);
    protected internal virtual Expression VisitGoto(GotoExpression node);
    protected virtual LabelTarget VisitLabelTarget(LabelTarget node);
}
internal abstract class System.Linq.EnumerableSorter`1 : object {
    internal abstract virtual void ComputeKeys(TElement[] elements, int count);
    internal abstract virtual int CompareAnyKeys(int index1, int index2);
    private Int32[] ComputeMap(TElement[] elements, int count);
    internal Int32[] Sort(TElement[] elements, int count);
    internal Int32[] Sort(TElement[] elements, int count, int minIdx, int maxIdx);
    internal TElement ElementAt(TElement[] elements, int count, int idx);
    protected abstract virtual void QuickSort(Int32[] map, int left, int right);
    protected abstract virtual void PartialQuickSort(Int32[] map, int left, int right, int minIdx, int maxIdx);
    protected abstract virtual int QuickSelect(Int32[] map, int right, int idx);
}
internal class System.Linq.EnumerableSorter`2 : EnumerableSorter`1<TElement> {
    private Func`2<TElement, TKey> _keySelector;
    private IComparer`1<TKey> _comparer;
    private bool _descending;
    private EnumerableSorter`1<TElement> _next;
    private TKey[] _keys;
    internal EnumerableSorter`2(Func`2<TElement, TKey> keySelector, IComparer`1<TKey> comparer, bool descending, EnumerableSorter`1<TElement> next);
    internal virtual void ComputeKeys(TElement[] elements, int count);
    internal virtual int CompareAnyKeys(int index1, int index2);
    private int CompareKeys(int index1, int index2);
    protected virtual void QuickSort(Int32[] keys, int lo, int hi);
    protected virtual void PartialQuickSort(Int32[] map, int left, int right, int minIdx, int maxIdx);
    protected virtual int QuickSelect(Int32[] map, int right, int idx);
}
internal static class System.Linq.Error : object {
    internal static Exception ArgumentNotIEnumerableGeneric(string message);
    internal static Exception ArgumentNotValid(string message);
    internal static Exception NoMethodOnType(string name, object type);
    internal static Exception NoMethodOnTypeMatchingArguments(string name, object type);
    internal static Exception EnumeratingNullEnumerableExpression();
    internal static Exception ArgumentNull(string s);
    internal static Exception ArgumentOutOfRange(string s);
    internal static Exception MoreThanOneElement();
    internal static Exception MoreThanOneMatch();
    internal static Exception NoElements();
    internal static Exception NoMatch();
    internal static Exception NotSupported();
}
internal enum System.Linq.Expressions.AnalyzeTypeIsResult : Enum {
    public int value__;
    public static AnalyzeTypeIsResult KnownFalse;
    public static AnalyzeTypeIsResult KnownTrue;
    public static AnalyzeTypeIsResult KnownAssignable;
    public static AnalyzeTypeIsResult Unknown;
}
[ExtensionAttribute]
internal static class System.Linq.Expressions.ArrayBuilderExtensions : object {
    [ExtensionAttribute]
public static ReadOnlyCollection`1<T> ToReadOnly(ArrayBuilder`1<T> builder);
}
internal class System.Linq.Expressions.AssignBinaryExpression : BinaryExpression {
    internal bool IsByRef { get; }
    public Type Type { get; }
    public ExpressionType NodeType { get; }
    internal AssignBinaryExpression(Expression left, Expression right);
    public static AssignBinaryExpression Make(Expression left, Expression right, bool byRef);
    internal virtual bool get_IsByRef();
    public sealed virtual Type get_Type();
    public sealed virtual ExpressionType get_NodeType();
}
[DebuggerTypeProxyAttribute("System.Linq.Expressions.Expression/BinaryExpressionProxy")]
public class System.Linq.Expressions.BinaryExpression : Expression {
    [CompilerGeneratedAttribute]
private Expression <Right>k__BackingField;
    [CompilerGeneratedAttribute]
private Expression <Left>k__BackingField;
    public bool CanReduce { get; }
    public Expression Right { get; }
    public Expression Left { get; }
    public MethodInfo Method { get; }
    public LambdaExpression Conversion { get; }
    public bool IsLifted { get; }
    public bool IsLiftedToNull { get; }
    internal bool IsLiftedLogical { get; }
    internal bool IsReferenceComparison { get; }
    internal BinaryExpression(Expression left, Expression right);
    public virtual bool get_CanReduce();
    private static bool IsOpAssignment(ExpressionType op);
    [CompilerGeneratedAttribute]
public Expression get_Right();
    [CompilerGeneratedAttribute]
public Expression get_Left();
    public MethodInfo get_Method();
    internal virtual MethodInfo GetMethod();
    public BinaryExpression Update(Expression left, LambdaExpression conversion, Expression right);
    public virtual Expression Reduce();
    private static ExpressionType GetBinaryOpFromAssignmentOp(ExpressionType op);
    private Expression ReduceVariable();
    private Expression ReduceMember();
    private Expression ReduceIndex();
    public LambdaExpression get_Conversion();
    internal virtual LambdaExpression GetConversion();
    public bool get_IsLifted();
    public bool get_IsLiftedToNull();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
    internal static BinaryExpression Create(ExpressionType nodeType, Expression left, Expression right, Type type, MethodInfo method, LambdaExpression conversion);
    internal bool get_IsLiftedLogical();
    internal bool get_IsReferenceComparison();
    internal Expression ReduceUserdefinedLifted();
}
internal class System.Linq.Expressions.Block2 : BlockExpression {
    private object _arg0;
    private Expression _arg1;
    internal int ExpressionCount { get; }
    internal Block2(Expression arg0, Expression arg1);
    internal virtual Expression GetExpression(int index);
    internal virtual bool SameExpressions(ICollection`1<Expression> expressions);
    internal virtual int get_ExpressionCount();
    internal virtual ReadOnlyCollection`1<Expression> GetOrMakeExpressions();
    internal virtual BlockExpression Rewrite(ReadOnlyCollection`1<ParameterExpression> variables, Expression[] args);
}
internal class System.Linq.Expressions.Block3 : BlockExpression {
    private object _arg0;
    private Expression _arg1;
    private Expression _arg2;
    internal int ExpressionCount { get; }
    internal Block3(Expression arg0, Expression arg1, Expression arg2);
    internal virtual bool SameExpressions(ICollection`1<Expression> expressions);
    internal virtual Expression GetExpression(int index);
    internal virtual int get_ExpressionCount();
    internal virtual ReadOnlyCollection`1<Expression> GetOrMakeExpressions();
    internal virtual BlockExpression Rewrite(ReadOnlyCollection`1<ParameterExpression> variables, Expression[] args);
}
internal class System.Linq.Expressions.Block4 : BlockExpression {
    private object _arg0;
    private Expression _arg1;
    private Expression _arg2;
    private Expression _arg3;
    internal int ExpressionCount { get; }
    internal Block4(Expression arg0, Expression arg1, Expression arg2, Expression arg3);
    internal virtual bool SameExpressions(ICollection`1<Expression> expressions);
    internal virtual Expression GetExpression(int index);
    internal virtual int get_ExpressionCount();
    internal virtual ReadOnlyCollection`1<Expression> GetOrMakeExpressions();
    internal virtual BlockExpression Rewrite(ReadOnlyCollection`1<ParameterExpression> variables, Expression[] args);
}
internal class System.Linq.Expressions.Block5 : BlockExpression {
    private object _arg0;
    private Expression _arg1;
    private Expression _arg2;
    private Expression _arg3;
    private Expression _arg4;
    internal int ExpressionCount { get; }
    internal Block5(Expression arg0, Expression arg1, Expression arg2, Expression arg3, Expression arg4);
    internal virtual Expression GetExpression(int index);
    internal virtual bool SameExpressions(ICollection`1<Expression> expressions);
    internal virtual int get_ExpressionCount();
    internal virtual ReadOnlyCollection`1<Expression> GetOrMakeExpressions();
    internal virtual BlockExpression Rewrite(ReadOnlyCollection`1<ParameterExpression> variables, Expression[] args);
}
[DebuggerTypeProxyAttribute("System.Linq.Expressions.Expression/BlockExpressionProxy")]
public class System.Linq.Expressions.BlockExpression : Expression {
    public ReadOnlyCollection`1<Expression> Expressions { get; }
    public ReadOnlyCollection`1<ParameterExpression> Variables { get; }
    public Expression Result { get; }
    public ExpressionType NodeType { get; }
    public Type Type { get; }
    [ExcludeFromCodeCoverageAttribute]
internal int ExpressionCount { get; }
    public ReadOnlyCollection`1<Expression> get_Expressions();
    public ReadOnlyCollection`1<ParameterExpression> get_Variables();
    public Expression get_Result();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
    public sealed virtual ExpressionType get_NodeType();
    public virtual Type get_Type();
    public BlockExpression Update(IEnumerable`1<ParameterExpression> variables, IEnumerable`1<Expression> expressions);
    internal virtual bool SameVariables(ICollection`1<ParameterExpression> variables);
    [ExcludeFromCodeCoverageAttribute]
internal virtual bool SameExpressions(ICollection`1<Expression> expressions);
    [ExcludeFromCodeCoverageAttribute]
internal virtual Expression GetExpression(int index);
    internal virtual int get_ExpressionCount();
    [ExcludeFromCodeCoverageAttribute]
internal virtual ReadOnlyCollection`1<Expression> GetOrMakeExpressions();
    internal virtual ReadOnlyCollection`1<ParameterExpression> GetOrMakeVariables();
    [ExcludeFromCodeCoverageAttribute]
internal virtual BlockExpression Rewrite(ReadOnlyCollection`1<ParameterExpression> variables, Expression[] args);
    internal static ReadOnlyCollection`1<Expression> ReturnReadOnlyExpressions(BlockExpression provider, Object& collection);
}
[DefaultMemberAttribute("Item")]
internal class System.Linq.Expressions.BlockExpressionList : object {
    private BlockExpression _block;
    private Expression _arg0;
    public Expression Item { get; public set; }
    public int Count { get; }
    [ExcludeFromCodeCoverageAttribute]
public bool IsReadOnly { get; }
    internal BlockExpressionList(BlockExpression provider, Expression arg0);
    public sealed virtual int IndexOf(Expression item);
    [ExcludeFromCodeCoverageAttribute]
public sealed virtual void Insert(int index, Expression item);
    [ExcludeFromCodeCoverageAttribute]
public sealed virtual void RemoveAt(int index);
    public sealed virtual Expression get_Item(int index);
    [ExcludeFromCodeCoverageAttribute]
public sealed virtual void set_Item(int index, Expression value);
    [ExcludeFromCodeCoverageAttribute]
public sealed virtual void Add(Expression item);
    [ExcludeFromCodeCoverageAttribute]
public sealed virtual void Clear();
    public sealed virtual bool Contains(Expression item);
    public sealed virtual void CopyTo(Expression[] array, int index);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    [ExcludeFromCodeCoverageAttribute]
public sealed virtual bool Remove(Expression item);
    [IteratorStateMachineAttribute("System.Linq.Expressions.BlockExpressionList/<GetEnumerator>d__18")]
public sealed virtual IEnumerator`1<Expression> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal class System.Linq.Expressions.BlockN : BlockExpression {
    private IReadOnlyList`1<Expression> _expressions;
    internal int ExpressionCount { get; }
    internal BlockN(IReadOnlyList`1<Expression> expressions);
    internal virtual bool SameExpressions(ICollection`1<Expression> expressions);
    internal virtual Expression GetExpression(int index);
    internal virtual int get_ExpressionCount();
    internal virtual ReadOnlyCollection`1<Expression> GetOrMakeExpressions();
    internal virtual BlockExpression Rewrite(ReadOnlyCollection`1<ParameterExpression> variables, Expression[] args);
}
internal class System.Linq.Expressions.ByRefAssignBinaryExpression : AssignBinaryExpression {
    internal bool IsByRef { get; }
    internal ByRefAssignBinaryExpression(Expression left, Expression right);
    internal virtual bool get_IsByRef();
}
internal class System.Linq.Expressions.ByRefParameterExpression : TypedParameterExpression {
    internal ByRefParameterExpression(Type type, string name);
    internal virtual bool GetIsByRef();
}
internal static class System.Linq.Expressions.CachedReflectionInfo : object {
    private static MethodInfo s_String_Format_String_ObjectArray;
    private static ConstructorInfo s_InvalidCastException_Ctor_String;
    private static MethodInfo s_CallSiteOps_SetNotMatched;
    private static MethodInfo s_CallSiteOps_CreateMatchmaker;
    private static MethodInfo s_CallSiteOps_GetMatch;
    private static MethodInfo s_CallSiteOps_ClearMatch;
    private static MethodInfo s_CallSiteOps_UpdateRules;
    private static MethodInfo s_CallSiteOps_GetRules;
    private static MethodInfo s_CallSiteOps_GetRuleCache;
    private static MethodInfo s_CallSiteOps_GetCachedRules;
    private static MethodInfo s_CallSiteOps_AddRule;
    private static MethodInfo s_CallSiteOps_MoveRule;
    private static MethodInfo s_CallSiteOps_Bind;
    private static MethodInfo s_DynamicObject_TryGetMember;
    private static MethodInfo s_DynamicObject_TrySetMember;
    private static MethodInfo s_DynamicObject_TryDeleteMember;
    private static MethodInfo s_DynamicObject_TryGetIndex;
    private static MethodInfo s_DynamicObject_TrySetIndex;
    private static MethodInfo s_DynamicObject_TryDeleteIndex;
    private static MethodInfo s_DynamicObject_TryConvert;
    private static MethodInfo s_DynamicObject_TryInvoke;
    private static MethodInfo s_DynamicObject_TryInvokeMember;
    private static MethodInfo s_DynamicObject_TryBinaryOperation;
    private static MethodInfo s_DynamicObject_TryUnaryOperation;
    private static MethodInfo s_DynamicObject_TryCreateInstance;
    private static ConstructorInfo s_Nullable_Boolean_Ctor;
    private static ConstructorInfo s_Decimal_Ctor_Int32;
    private static ConstructorInfo s_Decimal_Ctor_UInt32;
    private static ConstructorInfo s_Decimal_Ctor_Int64;
    private static ConstructorInfo s_Decimal_Ctor_UInt64;
    private static ConstructorInfo s_Decimal_Ctor_Int32_Int32_Int32_Bool_Byte;
    private static FieldInfo s_Decimal_One;
    private static FieldInfo s_Decimal_MinusOne;
    private static FieldInfo s_Decimal_MinValue;
    private static FieldInfo s_Decimal_MaxValue;
    private static FieldInfo s_Decimal_Zero;
    private static FieldInfo s_DateTime_MinValue;
    private static MethodInfo s_MethodBase_GetMethodFromHandle_RuntimeMethodHandle;
    private static MethodInfo s_MethodBase_GetMethodFromHandle_RuntimeMethodHandle_RuntimeTypeHandle;
    private static MethodInfo s_MethodInfo_CreateDelegate_Type_Object;
    private static MethodInfo s_String_op_Equality_String_String;
    private static MethodInfo s_String_Equals_String_String;
    private static MethodInfo s_DictionaryOfStringInt32_Add_String_Int32;
    private static ConstructorInfo s_DictionaryOfStringInt32_Ctor_Int32;
    private static MethodInfo s_Type_GetTypeFromHandle;
    private static MethodInfo s_Object_GetType;
    private static MethodInfo s_Decimal_op_Implicit_Byte;
    private static MethodInfo s_Decimal_op_Implicit_SByte;
    private static MethodInfo s_Decimal_op_Implicit_Int16;
    private static MethodInfo s_Decimal_op_Implicit_UInt16;
    private static MethodInfo s_Decimal_op_Implicit_Int32;
    private static MethodInfo s_Decimal_op_Implicit_UInt32;
    private static MethodInfo s_Decimal_op_Implicit_Int64;
    private static MethodInfo s_Decimal_op_Implicit_UInt64;
    private static MethodInfo s_Decimal_op_Implicit_Char;
    private static MethodInfo s_Math_Pow_Double_Double;
    private static ConstructorInfo s_Closure_ObjectArray_ObjectArray;
    private static FieldInfo s_Closure_Constants;
    private static FieldInfo s_Closure_Locals;
    private static MethodInfo s_RuntimeOps_CreateRuntimeVariables_ObjectArray_Int64Array;
    private static MethodInfo s_RuntimeOps_CreateRuntimeVariables;
    private static MethodInfo s_RuntimeOps_MergeRuntimeVariables;
    private static MethodInfo s_RuntimeOps_Quote;
    public static MethodInfo String_Format_String_ObjectArray { get; }
    public static ConstructorInfo InvalidCastException_Ctor_String { get; }
    public static MethodInfo CallSiteOps_SetNotMatched { get; }
    public static MethodInfo CallSiteOps_CreateMatchmaker { get; }
    public static MethodInfo CallSiteOps_GetMatch { get; }
    public static MethodInfo CallSiteOps_ClearMatch { get; }
    public static MethodInfo CallSiteOps_UpdateRules { get; }
    public static MethodInfo CallSiteOps_GetRules { get; }
    public static MethodInfo CallSiteOps_GetRuleCache { get; }
    public static MethodInfo CallSiteOps_GetCachedRules { get; }
    public static MethodInfo CallSiteOps_AddRule { get; }
    public static MethodInfo CallSiteOps_MoveRule { get; }
    public static MethodInfo CallSiteOps_Bind { get; }
    public static MethodInfo DynamicObject_TryGetMember { get; }
    public static MethodInfo DynamicObject_TrySetMember { get; }
    public static MethodInfo DynamicObject_TryDeleteMember { get; }
    public static MethodInfo DynamicObject_TryGetIndex { get; }
    public static MethodInfo DynamicObject_TrySetIndex { get; }
    public static MethodInfo DynamicObject_TryDeleteIndex { get; }
    public static MethodInfo DynamicObject_TryConvert { get; }
    public static MethodInfo DynamicObject_TryInvoke { get; }
    public static MethodInfo DynamicObject_TryInvokeMember { get; }
    public static MethodInfo DynamicObject_TryBinaryOperation { get; }
    public static MethodInfo DynamicObject_TryUnaryOperation { get; }
    public static MethodInfo DynamicObject_TryCreateInstance { get; }
    public static ConstructorInfo Nullable_Boolean_Ctor { get; }
    public static ConstructorInfo Decimal_Ctor_Int32 { get; }
    public static ConstructorInfo Decimal_Ctor_UInt32 { get; }
    public static ConstructorInfo Decimal_Ctor_Int64 { get; }
    public static ConstructorInfo Decimal_Ctor_UInt64 { get; }
    public static ConstructorInfo Decimal_Ctor_Int32_Int32_Int32_Bool_Byte { get; }
    public static FieldInfo Decimal_One { get; }
    public static FieldInfo Decimal_MinusOne { get; }
    public static FieldInfo Decimal_MinValue { get; }
    public static FieldInfo Decimal_MaxValue { get; }
    public static FieldInfo Decimal_Zero { get; }
    public static FieldInfo DateTime_MinValue { get; }
    public static MethodInfo MethodBase_GetMethodFromHandle_RuntimeMethodHandle { get; }
    public static MethodInfo MethodBase_GetMethodFromHandle_RuntimeMethodHandle_RuntimeTypeHandle { get; }
    public static MethodInfo MethodInfo_CreateDelegate_Type_Object { get; }
    public static MethodInfo String_op_Equality_String_String { get; }
    public static MethodInfo String_Equals_String_String { get; }
    public static MethodInfo DictionaryOfStringInt32_Add_String_Int32 { get; }
    public static ConstructorInfo DictionaryOfStringInt32_Ctor_Int32 { get; }
    public static MethodInfo Type_GetTypeFromHandle { get; }
    public static MethodInfo Object_GetType { get; }
    public static MethodInfo Decimal_op_Implicit_Byte { get; }
    public static MethodInfo Decimal_op_Implicit_SByte { get; }
    public static MethodInfo Decimal_op_Implicit_Int16 { get; }
    public static MethodInfo Decimal_op_Implicit_UInt16 { get; }
    public static MethodInfo Decimal_op_Implicit_Int32 { get; }
    public static MethodInfo Decimal_op_Implicit_UInt32 { get; }
    public static MethodInfo Decimal_op_Implicit_Int64 { get; }
    public static MethodInfo Decimal_op_Implicit_UInt64 { get; }
    public static MethodInfo Decimal_op_Implicit_Char { get; }
    public static MethodInfo Math_Pow_Double_Double { get; }
    public static ConstructorInfo Closure_ObjectArray_ObjectArray { get; }
    public static FieldInfo Closure_Constants { get; }
    public static FieldInfo Closure_Locals { get; }
    public static MethodInfo RuntimeOps_CreateRuntimeVariables_ObjectArray_Int64Array { get; }
    public static MethodInfo RuntimeOps_CreateRuntimeVariables { get; }
    public static MethodInfo RuntimeOps_MergeRuntimeVariables { get; }
    public static MethodInfo RuntimeOps_Quote { get; }
    public static MethodInfo get_String_Format_String_ObjectArray();
    public static ConstructorInfo get_InvalidCastException_Ctor_String();
    public static MethodInfo get_CallSiteOps_SetNotMatched();
    public static MethodInfo get_CallSiteOps_CreateMatchmaker();
    public static MethodInfo get_CallSiteOps_GetMatch();
    public static MethodInfo get_CallSiteOps_ClearMatch();
    public static MethodInfo get_CallSiteOps_UpdateRules();
    public static MethodInfo get_CallSiteOps_GetRules();
    public static MethodInfo get_CallSiteOps_GetRuleCache();
    public static MethodInfo get_CallSiteOps_GetCachedRules();
    public static MethodInfo get_CallSiteOps_AddRule();
    public static MethodInfo get_CallSiteOps_MoveRule();
    public static MethodInfo get_CallSiteOps_Bind();
    public static MethodInfo get_DynamicObject_TryGetMember();
    public static MethodInfo get_DynamicObject_TrySetMember();
    public static MethodInfo get_DynamicObject_TryDeleteMember();
    public static MethodInfo get_DynamicObject_TryGetIndex();
    public static MethodInfo get_DynamicObject_TrySetIndex();
    public static MethodInfo get_DynamicObject_TryDeleteIndex();
    public static MethodInfo get_DynamicObject_TryConvert();
    public static MethodInfo get_DynamicObject_TryInvoke();
    public static MethodInfo get_DynamicObject_TryInvokeMember();
    public static MethodInfo get_DynamicObject_TryBinaryOperation();
    public static MethodInfo get_DynamicObject_TryUnaryOperation();
    public static MethodInfo get_DynamicObject_TryCreateInstance();
    public static ConstructorInfo get_Nullable_Boolean_Ctor();
    public static ConstructorInfo get_Decimal_Ctor_Int32();
    public static ConstructorInfo get_Decimal_Ctor_UInt32();
    public static ConstructorInfo get_Decimal_Ctor_Int64();
    public static ConstructorInfo get_Decimal_Ctor_UInt64();
    public static ConstructorInfo get_Decimal_Ctor_Int32_Int32_Int32_Bool_Byte();
    public static FieldInfo get_Decimal_One();
    public static FieldInfo get_Decimal_MinusOne();
    public static FieldInfo get_Decimal_MinValue();
    public static FieldInfo get_Decimal_MaxValue();
    public static FieldInfo get_Decimal_Zero();
    public static FieldInfo get_DateTime_MinValue();
    public static MethodInfo get_MethodBase_GetMethodFromHandle_RuntimeMethodHandle();
    public static MethodInfo get_MethodBase_GetMethodFromHandle_RuntimeMethodHandle_RuntimeTypeHandle();
    public static MethodInfo get_MethodInfo_CreateDelegate_Type_Object();
    public static MethodInfo get_String_op_Equality_String_String();
    public static MethodInfo get_String_Equals_String_String();
    public static MethodInfo get_DictionaryOfStringInt32_Add_String_Int32();
    public static ConstructorInfo get_DictionaryOfStringInt32_Ctor_Int32();
    public static MethodInfo get_Type_GetTypeFromHandle();
    public static MethodInfo get_Object_GetType();
    public static MethodInfo get_Decimal_op_Implicit_Byte();
    public static MethodInfo get_Decimal_op_Implicit_SByte();
    public static MethodInfo get_Decimal_op_Implicit_Int16();
    public static MethodInfo get_Decimal_op_Implicit_UInt16();
    public static MethodInfo get_Decimal_op_Implicit_Int32();
    public static MethodInfo get_Decimal_op_Implicit_UInt32();
    public static MethodInfo get_Decimal_op_Implicit_Int64();
    public static MethodInfo get_Decimal_op_Implicit_UInt64();
    public static MethodInfo get_Decimal_op_Implicit_Char();
    public static MethodInfo get_Math_Pow_Double_Double();
    public static ConstructorInfo get_Closure_ObjectArray_ObjectArray();
    public static FieldInfo get_Closure_Constants();
    public static FieldInfo get_Closure_Locals();
    public static MethodInfo get_RuntimeOps_CreateRuntimeVariables_ObjectArray_Int64Array();
    public static MethodInfo get_RuntimeOps_CreateRuntimeVariables();
    public static MethodInfo get_RuntimeOps_MergeRuntimeVariables();
    public static MethodInfo get_RuntimeOps_Quote();
}
[DebuggerTypeProxyAttribute("System.Linq.Expressions.Expression/CatchBlockProxy")]
public class System.Linq.Expressions.CatchBlock : object {
    [CompilerGeneratedAttribute]
private ParameterExpression <Variable>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <Test>k__BackingField;
    [CompilerGeneratedAttribute]
private Expression <Body>k__BackingField;
    [CompilerGeneratedAttribute]
private Expression <Filter>k__BackingField;
    public ParameterExpression Variable { get; }
    public Type Test { get; }
    public Expression Body { get; }
    public Expression Filter { get; }
    internal CatchBlock(Type test, ParameterExpression variable, Expression body, Expression filter);
    [CompilerGeneratedAttribute]
public ParameterExpression get_Variable();
    [CompilerGeneratedAttribute]
public Type get_Test();
    [CompilerGeneratedAttribute]
public Expression get_Body();
    [CompilerGeneratedAttribute]
public Expression get_Filter();
    public virtual string ToString();
    public CatchBlock Update(ParameterExpression variable, Expression filter, Expression body);
}
internal class System.Linq.Expressions.ClearDebugInfoExpression : DebugInfoExpression {
    public bool IsClear { get; }
    public int StartLine { get; }
    public int StartColumn { get; }
    public int EndLine { get; }
    public int EndColumn { get; }
    internal ClearDebugInfoExpression(SymbolDocumentInfo document);
    public virtual bool get_IsClear();
    public virtual int get_StartLine();
    public virtual int get_StartColumn();
    public virtual int get_EndLine();
    public virtual int get_EndColumn();
}
internal class System.Linq.Expressions.CoalesceConversionBinaryExpression : BinaryExpression {
    private LambdaExpression _conversion;
    public ExpressionType NodeType { get; }
    public Type Type { get; }
    internal CoalesceConversionBinaryExpression(Expression left, Expression right, LambdaExpression conversion);
    internal virtual LambdaExpression GetConversion();
    public sealed virtual ExpressionType get_NodeType();
    public sealed virtual Type get_Type();
}
internal class System.Linq.Expressions.Compiler.AnalyzedTree : object {
    internal Dictionary`2<object, CompilerScope> Scopes;
    internal Dictionary`2<LambdaExpression, BoundConstants> Constants;
}
internal class System.Linq.Expressions.Compiler.AssemblyGen : object {
    private static AssemblyGen s_assembly;
    private ModuleBuilder _myModule;
    private int _index;
    private static AssemblyGen Assembly { get; }
    private static AssemblyGen get_Assembly();
    private TypeBuilder DefineType(string name, Type parent, TypeAttributes attr);
    internal static TypeBuilder DefineDelegateType(string name);
}
internal class System.Linq.Expressions.Compiler.BoundConstants : object {
    private List`1<object> _values;
    private Dictionary`2<object, int> _indexes;
    private Dictionary`2<TypedConstant, int> _references;
    private Dictionary`2<TypedConstant, LocalBuilder> _cache;
    internal int Count { get; }
    internal int get_Count();
    internal Object[] ToArray();
    internal void AddReference(object value, Type type);
    internal void EmitConstant(LambdaCompiler lc, object value, Type type);
    internal void EmitCacheConstants(LambdaCompiler lc);
    private static bool ShouldCache(int refCount);
    private static void EmitConstantsArray(LambdaCompiler lc);
    private void EmitConstantFromArray(LambdaCompiler lc, object value, Type type);
}
internal class System.Linq.Expressions.Compiler.CompilerScope : object {
    private CompilerScope _parent;
    internal object Node;
    internal bool IsMethod;
    internal bool NeedsClosure;
    internal Dictionary`2<ParameterExpression, VariableStorageKind> Definitions;
    internal Dictionary`2<ParameterExpression, int> ReferenceCount;
    internal HashSet`1<BlockExpression> MergedScopes;
    private HoistedLocals _hoistedLocals;
    private HoistedLocals _closureHoistedLocals;
    private Dictionary`2<ParameterExpression, Storage> _locals;
    internal HoistedLocals NearestHoistedLocals { get; }
    private string CurrentLambdaName { get; }
    internal CompilerScope(object node, bool isMethod);
    internal HoistedLocals get_NearestHoistedLocals();
    internal CompilerScope Enter(LambdaCompiler lc, CompilerScope parent);
    internal CompilerScope Exit();
    internal void EmitVariableAccess(LambdaCompiler lc, ReadOnlyCollection`1<ParameterExpression> vars);
    internal void AddLocal(LambdaCompiler gen, ParameterExpression variable);
    internal void EmitGet(ParameterExpression variable);
    internal void EmitSet(ParameterExpression variable);
    internal void EmitAddressOf(ParameterExpression variable);
    private Storage ResolveVariable(ParameterExpression variable);
    private Storage ResolveVariable(ParameterExpression variable, HoistedLocals hoistedLocals);
    private void SetParent(LambdaCompiler lc, CompilerScope parent);
    private void EmitNewHoistedLocals(LambdaCompiler lc);
    private void EmitCachedVariables();
    private bool ShouldCache(ParameterExpression v, int refCount);
    private bool ShouldCache(ParameterExpression v);
    private void CacheBoxToLocal(LambdaCompiler lc, ParameterExpression v);
    private void EmitClosureAccess(LambdaCompiler lc, HoistedLocals locals);
    private void EmitClosureToVariable(LambdaCompiler lc, HoistedLocals locals);
    private void AllocateLocals(LambdaCompiler lc);
    private IEnumerable`1<ParameterExpression> GetVariables();
    [IteratorStateMachineAttribute("System.Linq.Expressions.Compiler.CompilerScope/<GetVariablesIncludingMerged>d__37")]
private IEnumerable`1<ParameterExpression> GetVariablesIncludingMerged();
    private static IReadOnlyList`1<ParameterExpression> GetVariables(object scope);
    private string get_CurrentLambdaName();
    [CompilerGeneratedAttribute]
private bool <SetParent>b__27_0(ParameterExpression p);
}
internal static class System.Linq.Expressions.Compiler.DelegateHelpers : object {
    private static TypeInfo _DelegateCache;
    private static int MaximumArity;
    private static MethodAttributes CtorAttributes;
    private static MethodImplAttributes ImplAttributes;
    private static MethodAttributes InvokeAttributes;
    private static Type[] s_delegateCtorSignature;
    private static DelegateHelpers();
    internal static Type MakeDelegateType(Type[] types);
    internal static TypeInfo NextTypeInfo(Type initialArg);
    internal static TypeInfo GetNextTypeInfo(Type initialArg, TypeInfo curTypeInfo);
    private static TypeInfo NextTypeInfo(Type initialArg, TypeInfo curTypeInfo);
    internal static Type MakeNewDelegate(Type[] types);
    internal static Type GetFuncType(Type[] types);
    internal static Type GetActionType(Type[] types);
    internal static Type MakeCallSiteDelegate(ReadOnlyCollection`1<Expression> types, Type returnType);
    internal static Type MakeDeferredSiteDelegate(DynamicMetaObject[] args, Type returnType);
    private static bool IsByRef(DynamicMetaObject mo);
    private static Type MakeNewCustomDelegate(Type[] types);
}
internal class System.Linq.Expressions.Compiler.HoistedLocals : object {
    internal HoistedLocals Parent;
    internal ReadOnlyDictionary`2<Expression, int> Indexes;
    internal ReadOnlyCollection`1<ParameterExpression> Variables;
    internal ParameterExpression SelfVariable;
    internal ParameterExpression ParentVariable { get; }
    internal HoistedLocals(HoistedLocals parent, ReadOnlyCollection`1<ParameterExpression> vars);
    internal ParameterExpression get_ParentVariable();
    internal static Object[] GetParent(Object[] locals);
}
[ExtensionAttribute]
internal static class System.Linq.Expressions.Compiler.ILGen : object {
    [ExtensionAttribute]
internal static void Emit(ILGenerator il, OpCode opcode, MethodBase methodBase);
    [ExtensionAttribute]
internal static void EmitLoadArg(ILGenerator il, int index);
    [ExtensionAttribute]
internal static void EmitLoadArgAddress(ILGenerator il, int index);
    [ExtensionAttribute]
internal static void EmitStoreArg(ILGenerator il, int index);
    [ExtensionAttribute]
internal static void EmitLoadValueIndirect(ILGenerator il, Type type);
    [ExtensionAttribute]
internal static void EmitStoreValueIndirect(ILGenerator il, Type type);
    [ExtensionAttribute]
internal static void EmitLoadElement(ILGenerator il, Type type);
    [ExtensionAttribute]
internal static void EmitStoreElement(ILGenerator il, Type type);
    [ExtensionAttribute]
internal static void EmitType(ILGenerator il, Type type);
    [ExtensionAttribute]
internal static void EmitFieldAddress(ILGenerator il, FieldInfo fi);
    [ExtensionAttribute]
internal static void EmitFieldGet(ILGenerator il, FieldInfo fi);
    [ExtensionAttribute]
internal static void EmitFieldSet(ILGenerator il, FieldInfo fi);
    [ExtensionAttribute]
internal static void EmitNew(ILGenerator il, ConstructorInfo ci);
    [ExtensionAttribute]
internal static void EmitNull(ILGenerator il);
    [ExtensionAttribute]
internal static void EmitString(ILGenerator il, string value);
    [ExtensionAttribute]
internal static void EmitPrimitive(ILGenerator il, bool value);
    [ExtensionAttribute]
internal static void EmitPrimitive(ILGenerator il, int value);
    [ExtensionAttribute]
private static void EmitPrimitive(ILGenerator il, UInt32 value);
    [ExtensionAttribute]
private static void EmitPrimitive(ILGenerator il, long value);
    [ExtensionAttribute]
private static void EmitPrimitive(ILGenerator il, ulong value);
    [ExtensionAttribute]
private static void EmitPrimitive(ILGenerator il, double value);
    [ExtensionAttribute]
private static void EmitPrimitive(ILGenerator il, float value);
    internal static bool CanEmitConstant(object value, Type type);
    private static bool CanEmitILConstant(Type type);
    [ExtensionAttribute]
internal static bool TryEmitConstant(ILGenerator il, object value, Type type, ILocalCache locals);
    private static bool ShouldLdtoken(Type t);
    internal static bool ShouldLdtoken(MethodBase mb);
    [ExtensionAttribute]
private static bool TryEmitILConstant(ILGenerator il, object value, Type type);
    [ExtensionAttribute]
internal static void EmitConvertToType(ILGenerator il, Type typeFrom, Type typeTo, bool isChecked, ILocalCache locals);
    [ExtensionAttribute]
private static void EmitCastToType(ILGenerator il, Type typeFrom, Type typeTo);
    [ExtensionAttribute]
private static void EmitNumericConversion(ILGenerator il, Type typeFrom, Type typeTo, bool isChecked);
    [ExtensionAttribute]
private static void EmitNullableToNullableConversion(ILGenerator il, Type typeFrom, Type typeTo, bool isChecked, ILocalCache locals);
    [ExtensionAttribute]
private static void EmitNonNullableToNullableConversion(ILGenerator il, Type typeFrom, Type typeTo, bool isChecked, ILocalCache locals);
    [ExtensionAttribute]
private static void EmitNullableToNonNullableConversion(ILGenerator il, Type typeFrom, Type typeTo, bool isChecked, ILocalCache locals);
    [ExtensionAttribute]
private static void EmitNullableToNonNullableStructConversion(ILGenerator il, Type typeFrom, Type typeTo, bool isChecked, ILocalCache locals);
    [ExtensionAttribute]
private static void EmitNullableToReferenceConversion(ILGenerator il, Type typeFrom);
    [ExtensionAttribute]
private static void EmitNullableConversion(ILGenerator il, Type typeFrom, Type typeTo, bool isChecked, ILocalCache locals);
    [ExtensionAttribute]
internal static void EmitHasValue(ILGenerator il, Type nullableType);
    [ExtensionAttribute]
internal static void EmitGetValue(ILGenerator il, Type nullableType);
    [ExtensionAttribute]
internal static void EmitGetValueOrDefault(ILGenerator il, Type nullableType);
    [ExtensionAttribute]
internal static void EmitArray(ILGenerator il, T[] items, ILocalCache locals);
    [ExtensionAttribute]
internal static void EmitArray(ILGenerator il, Type elementType, int count);
    [ExtensionAttribute]
internal static void EmitArray(ILGenerator il, Type arrayType);
    [ExtensionAttribute]
private static void EmitDecimal(ILGenerator il, decimal value);
    [ExtensionAttribute]
internal static void EmitDefault(ILGenerator il, Type type, ILocalCache locals);
}
internal interface System.Linq.Expressions.Compiler.ILocalCache {
    public abstract virtual LocalBuilder GetLocal(Type type);
    public abstract virtual void FreeLocal(LocalBuilder local);
}
internal class System.Linq.Expressions.Compiler.KeyedStack`2 : object {
    private Dictionary`2<TKey, Stack`1<TValue>> _data;
    internal void Push(TKey key, TValue value);
    internal TValue TryPop(TKey key);
}
internal class System.Linq.Expressions.Compiler.LabelInfo : object {
    private LabelTarget _node;
    private Label _label;
    private bool _labelDefined;
    private LocalBuilder _value;
    private HashSet`1<LabelScopeInfo> _definitions;
    private List`1<LabelScopeInfo> _references;
    private bool _canReturn;
    private bool _acrossBlockJump;
    private OpCode _opCode;
    private ILGenerator _ilg;
    internal Label Label { get; }
    internal bool CanReturn { get; }
    internal bool CanBranch { get; }
    internal LabelInfo(ILGenerator il, LabelTarget node, bool canReturn);
    internal Label get_Label();
    internal bool get_CanReturn();
    internal bool get_CanBranch();
    internal void Reference(LabelScopeInfo block);
    internal void Define(LabelScopeInfo block);
    private void ValidateJump(LabelScopeInfo reference);
    internal void ValidateFinish();
    internal void EmitJump();
    private void StoreValue();
    internal void Mark();
    internal void MarkWithEmptyStack();
    private void EnsureLabelAndValue();
}
internal class System.Linq.Expressions.Compiler.LabelScopeInfo : object {
    private Dictionary`2<LabelTarget, LabelInfo> _labels;
    internal LabelScopeKind Kind;
    internal LabelScopeInfo Parent;
    internal bool CanJumpInto { get; }
    internal LabelScopeInfo(LabelScopeInfo parent, LabelScopeKind kind);
    internal bool get_CanJumpInto();
    internal bool ContainsTarget(LabelTarget target);
    internal bool TryGetLabelInfo(LabelTarget target, LabelInfo& info);
    internal void AddLabelInfo(LabelTarget target, LabelInfo info);
}
internal enum System.Linq.Expressions.Compiler.LabelScopeKind : Enum {
    public int value__;
    public static LabelScopeKind Statement;
    public static LabelScopeKind Block;
    public static LabelScopeKind Switch;
    public static LabelScopeKind Lambda;
    public static LabelScopeKind Try;
    public static LabelScopeKind Catch;
    public static LabelScopeKind Finally;
    public static LabelScopeKind Filter;
    public static LabelScopeKind Expression;
}
internal class System.Linq.Expressions.Compiler.LambdaCompiler : object {
    private StackGuard _guard;
    private static int s_counter;
    private AnalyzedTree _tree;
    private ILGenerator _ilg;
    private TypeBuilder _typeBuilder;
    private MethodInfo _method;
    private LabelScopeInfo _labelBlock;
    private Dictionary`2<LabelTarget, LabelInfo> _labelInfo;
    private CompilerScope _scope;
    private LambdaExpression _lambda;
    private bool _hasClosureArgument;
    private BoundConstants _boundConstants;
    private KeyedStack`2<Type, LocalBuilder> _freeLocals;
    internal ILGenerator IL { get; }
    internal IParameterProvider Parameters { get; }
    internal bool CanEmitBoundConstants { get; }
    private LambdaCompiler(AnalyzedTree tree, LambdaExpression lambda);
    private LambdaCompiler(AnalyzedTree tree, LambdaExpression lambda, MethodBuilder method);
    private LambdaCompiler(LambdaCompiler parent, LambdaExpression lambda, InvocationExpression invocation);
    private void EmitAddress(Expression node, Type type);
    private void EmitAddress(Expression node, Type type, CompilationFlags flags);
    private void AddressOf(BinaryExpression node, Type type);
    private void AddressOf(ParameterExpression node, Type type);
    private void AddressOf(MemberExpression node, Type type);
    private void EmitMemberAddress(MemberInfo member, Type objectType);
    private void AddressOf(MethodCallExpression node, Type type);
    private void AddressOf(IndexExpression node, Type type);
    private void AddressOf(UnaryExpression node, Type type);
    private void EmitExpressionAddress(Expression node, Type type);
    private WriteBack EmitAddressWriteBack(Expression node, Type type);
    private WriteBack AddressOfWriteBack(MemberExpression node);
    private WriteBack AddressOfWriteBackCore(MemberExpression node);
    private WriteBack AddressOfWriteBack(IndexExpression node);
    private WriteBack AddressOfWriteBackCore(IndexExpression node);
    private LocalBuilder GetInstanceLocal(Type type);
    private void EmitBinaryExpression(Expression expr);
    private void EmitBinaryExpression(Expression expr, CompilationFlags flags);
    private void EmitNullEquality(ExpressionType op, Expression e, bool isLiftedToNull);
    private void EmitBinaryMethod(BinaryExpression b, CompilationFlags flags);
    private void EmitBinaryOperator(ExpressionType op, Type leftType, Type rightType, Type resultType, bool liftedToNull);
    private void EmitUnliftedBinaryOp(ExpressionType op, Type leftType, Type rightType);
    private void EmitShiftMask(Type leftType);
    private void EmitConvertArithmeticResult(ExpressionType op, Type resultType);
    private void EmitLiftedBinaryOp(ExpressionType op, Type leftType, Type rightType, Type resultType, bool liftedToNull);
    private void EmitLiftedRelational(ExpressionType op, Type type);
    private void EmitLiftedToNullRelational(ExpressionType op, Type type);
    private void EmitLiftedBinaryArithmetic(ExpressionType op, Type leftType, Type rightType, Type resultType);
    private void EmitLiftedBooleanAnd();
    private void EmitLiftedBooleanOr();
    private LabelInfo EnsureLabel(LabelTarget node);
    private LabelInfo ReferenceLabel(LabelTarget node);
    private LabelInfo DefineLabel(LabelTarget node);
    private void PushLabelBlock(LabelScopeKind type);
    private void PopLabelBlock(LabelScopeKind kind);
    private void EmitLabelExpression(Expression expr, CompilationFlags flags);
    private void EmitGotoExpression(Expression expr, CompilationFlags flags);
    private void EmitUnreachable(Expression node, CompilationFlags flags);
    private bool TryPushLabelBlock(Expression node);
    private void DefineBlockLabels(Expression node);
    private void AddReturnLabel(LambdaExpression lambda);
    private static CompilationFlags UpdateEmitAsTailCallFlag(CompilationFlags flags, CompilationFlags newValue);
    private static CompilationFlags UpdateEmitExpressionStartFlag(CompilationFlags flags, CompilationFlags newValue);
    private static CompilationFlags UpdateEmitAsTypeFlag(CompilationFlags flags, CompilationFlags newValue);
    internal void EmitExpression(Expression node);
    private void EmitExpressionAsVoid(Expression node);
    private void EmitExpressionAsVoid(Expression node, CompilationFlags flags);
    private void EmitExpressionAsType(Expression node, Type type, CompilationFlags flags);
    private CompilationFlags EmitExpressionStart(Expression node);
    private void EmitExpressionEnd(CompilationFlags flags);
    private void EmitInvocationExpression(Expression expr, CompilationFlags flags);
    private void EmitInlinedInvoke(InvocationExpression invoke, CompilationFlags flags);
    private void EmitIndexExpression(Expression expr);
    private void EmitIndexAssignment(AssignBinaryExpression node, CompilationFlags flags);
    private void EmitGetIndexCall(IndexExpression node, Type objectType);
    private void EmitGetArrayElement(Type arrayType);
    private void EmitSetIndexCall(IndexExpression node, Type objectType);
    private void EmitSetArrayElement(Type arrayType);
    private void EmitMethodCallExpression(Expression expr, CompilationFlags flags);
    private void EmitMethodCallExpression(Expression expr);
    private void EmitMethodCall(Expression obj, MethodInfo method, IArgumentProvider methodCallExpr);
    private void EmitMethodCall(Expression obj, MethodInfo method, IArgumentProvider methodCallExpr, CompilationFlags flags);
    private void EmitMethodCall(MethodInfo mi, IArgumentProvider args, Type objectType);
    private void EmitMethodCall(MethodInfo mi, IArgumentProvider args, Type objectType, CompilationFlags flags);
    private static bool MethodHasByRefParameter(MethodInfo mi);
    private void EmitCall(Type objectType, MethodInfo method);
    private static bool UseVirtual(MethodInfo mi);
    private List`1<WriteBack> EmitArguments(MethodBase method, IArgumentProvider args);
    private List`1<WriteBack> EmitArguments(MethodBase method, IArgumentProvider args, int skipParameters);
    private void EmitWriteBack(List`1<WriteBack> writeBacks);
    private void EmitConstantExpression(Expression expr);
    private void EmitConstant(object value);
    private void EmitConstant(object value, Type type);
    private void EmitDynamicExpression(Expression expr);
    private void EmitNewExpression(Expression expr);
    private void EmitTypeBinaryExpression(Expression expr);
    private void EmitVariableAssignment(AssignBinaryExpression node, CompilationFlags flags);
    private void EmitAssignBinaryExpression(Expression expr);
    private void EmitAssign(AssignBinaryExpression node, CompilationFlags emitAs);
    private void EmitParameterExpression(Expression expr);
    private void EmitLambdaExpression(Expression expr);
    private void EmitRuntimeVariablesExpression(Expression expr);
    private void EmitMemberAssignment(AssignBinaryExpression node, CompilationFlags flags);
    private void EmitMemberExpression(Expression expr);
    private void EmitMemberGet(MemberInfo member, Type objectType);
    private void EmitInstance(Expression instance, Type& type);
    private void EmitNewArrayExpression(Expression expr);
    private void EmitDebugInfoExpression(Expression expr);
    private void EmitListInitExpression(Expression expr);
    private void EmitMemberInitExpression(Expression expr);
    private void EmitBinding(MemberBinding binding, Type objectType);
    private void EmitMemberAssignment(MemberAssignment binding, Type objectType);
    private void EmitMemberMemberBinding(MemberMemberBinding binding);
    private void EmitMemberListBinding(MemberListBinding binding);
    private void EmitMemberInit(MemberInitExpression init);
    private void EmitMemberInit(ReadOnlyCollection`1<MemberBinding> bindings, bool keepOnStack, Type objectType);
    private void EmitListInit(ListInitExpression init);
    private void EmitListInit(ReadOnlyCollection`1<ElementInit> initializers, bool keepOnStack, Type objectType);
    private static Type GetMemberType(MemberInfo member);
    private void EmitLift(ExpressionType nodeType, Type resultType, MethodCallExpression mc, ParameterExpression[] paramList, Expression[] argList);
    private void EmitExpression(Expression node, CompilationFlags flags);
    private static bool IsChecked(ExpressionType op);
    internal void EmitConstantArray(T[] array);
    private void EmitClosureCreation(LambdaCompiler inner);
    private void EmitDelegateConstruction(LambdaCompiler inner);
    private void EmitDelegateConstruction(LambdaExpression lambda);
    private static Type[] GetParameterTypes(LambdaExpression lambda, Type firstType);
    private static string GetUniqueMethodName();
    private void EmitLambdaBody();
    private void EmitLambdaBody(CompilerScope parent, bool inlined, CompilationFlags flags);
    private void EmitConditionalExpression(Expression expr, CompilationFlags flags);
    private static bool NotEmpty(Expression node);
    private static bool Significant(Expression node);
    private void EmitCoalesceBinaryExpression(Expression expr);
    private void EmitNullableCoalesce(BinaryExpression b);
    private void EmitLambdaReferenceCoalesce(BinaryExpression b);
    private void EmitReferenceCoalesceWithoutConversion(BinaryExpression b);
    private void EmitLiftedAndAlso(BinaryExpression b);
    private void EmitMethodAndAlso(BinaryExpression b, CompilationFlags flags);
    private void EmitUnliftedAndAlso(BinaryExpression b);
    private void EmitAndAlsoBinaryExpression(Expression expr, CompilationFlags flags);
    private void EmitLiftedOrElse(BinaryExpression b);
    private void EmitUnliftedOrElse(BinaryExpression b);
    private void EmitMethodOrElse(BinaryExpression b, CompilationFlags flags);
    private void EmitOrElseBinaryExpression(Expression expr, CompilationFlags flags);
    private void EmitExpressionAndBranch(bool branchValue, Expression node, Label label);
    private void EmitBranchOp(bool branch, Label label);
    private void EmitBranchNot(bool branch, UnaryExpression node, Label label);
    private void EmitBranchComparison(bool branch, BinaryExpression node, Label label);
    private static Expression GetEqualityOperand(Expression expression);
    private void EmitBranchLogical(bool branch, BinaryExpression node, Label label);
    private void EmitBranchAnd(bool branch, BinaryExpression node, Label label);
    private void EmitBranchOr(bool branch, BinaryExpression node, Label label);
    private void EmitBranchBlock(bool branch, BlockExpression node, Label label);
    private void EmitBlockExpression(Expression expr, CompilationFlags flags);
    private void Emit(BlockExpression node, CompilationFlags flags);
    private void EnterScope(object node);
    private static bool HasVariables(object node);
    private void ExitScope(object node);
    private void EmitDefaultExpression(Expression expr);
    private void EmitLoopExpression(Expression expr);
    private void EmitSwitchExpression(Expression expr, CompilationFlags flags);
    private static Type GetTestValueType(SwitchExpression node);
    private static bool FitsInBucket(List`1<SwitchLabel> buckets, decimal key, int count);
    private static void MergeBuckets(List`1<List`1<SwitchLabel>> buckets);
    private static void AddToBuckets(List`1<List`1<SwitchLabel>> buckets, SwitchLabel key);
    private static bool CanOptimizeSwitchType(Type valueType);
    private bool TryEmitSwitchInstruction(SwitchExpression node, CompilationFlags flags);
    private static decimal ConvertSwitchValue(object value);
    private void DefineSwitchCaseLabel(SwitchCase case, Label& label, Boolean& isGoto);
    private void EmitSwitchCases(SwitchExpression node, Label[] labels, Boolean[] isGoto, Label default, Label end, CompilationFlags flags);
    private void EmitSwitchBuckets(SwitchInfo info, List`1<List`1<SwitchLabel>> buckets, int first, int last);
    private void EmitSwitchBucket(SwitchInfo info, List`1<SwitchLabel> bucket);
    private bool TryEmitHashtableSwitch(SwitchExpression node, CompilationFlags flags);
    private void CheckRethrow();
    private void CheckTry();
    private void EmitSaveExceptionOrPop(CatchBlock cb);
    private void EmitTryExpression(Expression expr);
    private void EmitCatchStart(CatchBlock cb);
    private void EmitQuoteUnaryExpression(Expression expr);
    private void EmitQuote(UnaryExpression quote);
    private void EmitThrowUnaryExpression(Expression expr);
    private void EmitThrow(UnaryExpression expr, CompilationFlags flags);
    private void EmitUnaryExpression(Expression expr, CompilationFlags flags);
    private void EmitUnary(UnaryExpression node, CompilationFlags flags);
    private void EmitUnaryOperator(ExpressionType op, Type operandType, Type resultType);
    private void EmitConstantOne(Type type);
    private void EmitUnboxUnaryExpression(Expression expr);
    private void EmitConvertUnaryExpression(Expression expr, CompilationFlags flags);
    private void EmitConvert(UnaryExpression node, CompilationFlags flags);
    private void EmitUnaryMethod(UnaryExpression node, CompilationFlags flags);
    private void InitializeMethod();
    internal ILGenerator get_IL();
    internal IParameterProvider get_Parameters();
    internal bool get_CanEmitBoundConstants();
    internal static Delegate Compile(LambdaExpression lambda);
    internal static void Compile(LambdaExpression lambda, MethodBuilder method);
    private static AnalyzedTree AnalyzeLambda(LambdaExpression& lambda);
    public sealed virtual LocalBuilder GetLocal(Type type);
    public sealed virtual void FreeLocal(LocalBuilder local);
    internal int GetLambdaArgument(int index);
    internal void EmitLambdaArgument(int index);
    internal void EmitClosureArgument();
    private Delegate CreateDelegate();
    private FieldBuilder CreateStaticField(string name, Type type);
    private MemberExpression CreateLazyInitializedField(string name);
}
[DefaultMemberAttribute("Item")]
internal class System.Linq.Expressions.Compiler.ParameterList : object {
    private IParameterProvider _provider;
    public ParameterExpression Item { get; }
    public int Count { get; }
    public ParameterList(IParameterProvider provider);
    public sealed virtual ParameterExpression get_Item(int index);
    public sealed virtual int get_Count();
    [IteratorStateMachineAttribute("System.Linq.Expressions.Compiler.ParameterList/<GetEnumerator>d__6")]
public sealed virtual IEnumerator`1<ParameterExpression> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[ExtensionAttribute]
internal static class System.Linq.Expressions.Compiler.ParameterProviderExtensions : object {
    [ExtensionAttribute]
public static int IndexOf(IParameterProvider provider, ParameterExpression parameter);
    [ExtensionAttribute]
public static bool Contains(IParameterProvider provider, ParameterExpression parameter);
}
internal class System.Linq.Expressions.Compiler.SpilledExpressionBlock : BlockN {
    internal SpilledExpressionBlock(IReadOnlyList`1<Expression> expressions);
    [ExcludeFromCodeCoverageAttribute]
internal virtual BlockExpression Rewrite(ReadOnlyCollection`1<ParameterExpression> variables, Expression[] args);
}
internal class System.Linq.Expressions.Compiler.StackSpiller : object {
    private StackGuard _guard;
    private TempMaker _tm;
    private Stack _startingStack;
    private RewriteAction _lambdaRewrite;
    private StackSpiller(Stack stack);
    private Result RewriteExpression(Expression node, Stack stack);
    private static Expression MakeBlock(ArrayBuilder`1<Expression> expressions);
    private static Expression MakeBlock(Expression[] expressions);
    private static Expression MakeBlock(IReadOnlyList`1<Expression> expressions);
    private ParameterExpression MakeTemp(Type type);
    private int Mark();
    private void Free(int mark);
    [ConditionalAttribute("DEBUG")]
private void VerifyTemps();
    private ParameterExpression ToTemp(Expression expression, Expression& save, bool byRef);
    internal static LambdaExpression AnalyzeLambda(LambdaExpression lambda);
    internal Expression`1<T> Rewrite(Expression`1<T> lambda);
    [ConditionalAttribute("DEBUG")]
private static void VerifyRewrite(Result result, Expression node);
    private Result RewriteExpressionFreeTemps(Expression expression, Stack stack);
    private Result RewriteDynamicExpression(Expression expr);
    private Result RewriteIndexAssignment(BinaryExpression node, Stack stack);
    private Result RewriteLogicalBinaryExpression(Expression expr, Stack stack);
    private Result RewriteReducibleExpression(Expression expr, Stack stack);
    private Result RewriteBinaryExpression(Expression expr, Stack stack);
    private Result RewriteVariableAssignment(BinaryExpression node, Stack stack);
    private Result RewriteAssignBinaryExpression(Expression expr, Stack stack);
    private Result RewriteExtensionAssignment(BinaryExpression node, Stack stack);
    private static Result RewriteLambdaExpression(Expression expr);
    private Result RewriteConditionalExpression(Expression expr, Stack stack);
    private Result RewriteMemberAssignment(BinaryExpression node, Stack stack);
    private Result RewriteMemberExpression(Expression expr, Stack stack);
    private Result RewriteIndexExpression(Expression expr, Stack stack);
    private Result RewriteMethodCallExpression(Expression expr, Stack stack);
    private Result RewriteNewArrayExpression(Expression expr, Stack stack);
    private Result RewriteInvocationExpression(Expression expr, Stack stack);
    private Result RewriteNewExpression(Expression expr, Stack stack);
    private Result RewriteTypeBinaryExpression(Expression expr, Stack stack);
    private Result RewriteThrowUnaryExpression(Expression expr, Stack stack);
    private Result RewriteUnaryExpression(Expression expr, Stack stack);
    private Result RewriteListInitExpression(Expression expr, Stack stack);
    private Result RewriteMemberInitExpression(Expression expr, Stack stack);
    private Result RewriteBlockExpression(Expression expr, Stack stack);
    private Result RewriteLabelExpression(Expression expr, Stack stack);
    private Result RewriteLoopExpression(Expression expr, Stack stack);
    private Result RewriteGotoExpression(Expression expr, Stack stack);
    private Result RewriteSwitchExpression(Expression expr, Stack stack);
    private Result RewriteTryExpression(Expression expr, Stack stack);
    private Result RewriteExtensionExpression(Expression expr, Stack stack);
    private static T[] Clone(ReadOnlyCollection`1<T> original, int max);
    private static void RequireNoRefArgs(MethodBase method);
    private static void RequireNotRefInstance(Expression instance);
    private static bool IsRefInstance(Expression instance);
}
[ExtensionAttribute]
internal static class System.Linq.Expressions.Compiler.TypeInfoExtensions : object {
    [ExtensionAttribute]
public static Type MakeDelegateType(TypeInfo info, Type retType, Expression[] args);
    [ExtensionAttribute]
public static Type MakeDelegateType(TypeInfo info, Type retType, IList`1<Expression> args);
}
internal class System.Linq.Expressions.Compiler.VariableBinder : ExpressionVisitor {
    private AnalyzedTree _tree;
    private Stack`1<CompilerScope> _scopes;
    private Stack`1<BoundConstants> _constants;
    private StackGuard _guard;
    private bool _inQuote;
    private string CurrentLambdaName { get; }
    internal static AnalyzedTree Bind(LambdaExpression lambda);
    public virtual Expression Visit(Expression node);
    protected internal virtual Expression VisitConstant(ConstantExpression node);
    protected internal virtual Expression VisitUnary(UnaryExpression node);
    protected internal virtual Expression VisitLambda(Expression`1<T> node);
    protected internal virtual Expression VisitInvocation(InvocationExpression node);
    protected internal virtual Expression VisitBlock(BlockExpression node);
    protected virtual CatchBlock VisitCatchBlock(CatchBlock node);
    private ReadOnlyCollection`1<Expression> MergeScopes(Expression node);
    protected internal virtual Expression VisitParameter(ParameterExpression node);
    protected internal virtual Expression VisitRuntimeVariables(RuntimeVariablesExpression node);
    private void Reference(ParameterExpression node, VariableStorageKind storage);
    private string get_CurrentLambdaName();
}
internal enum System.Linq.Expressions.Compiler.VariableStorageKind : Enum {
    public int value__;
    public static VariableStorageKind Local;
    public static VariableStorageKind Hoisted;
}
[DebuggerTypeProxyAttribute("System.Linq.Expressions.Expression/ConditionalExpressionProxy")]
public class System.Linq.Expressions.ConditionalExpression : Expression {
    [CompilerGeneratedAttribute]
private Expression <Test>k__BackingField;
    [CompilerGeneratedAttribute]
private Expression <IfTrue>k__BackingField;
    public ExpressionType NodeType { get; }
    public Type Type { get; }
    public Expression Test { get; }
    public Expression IfTrue { get; }
    public Expression IfFalse { get; }
    internal ConditionalExpression(Expression test, Expression ifTrue);
    internal static ConditionalExpression Make(Expression test, Expression ifTrue, Expression ifFalse, Type type);
    public sealed virtual ExpressionType get_NodeType();
    public virtual Type get_Type();
    [CompilerGeneratedAttribute]
public Expression get_Test();
    [CompilerGeneratedAttribute]
public Expression get_IfTrue();
    public Expression get_IfFalse();
    internal virtual Expression GetFalse();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
    public ConditionalExpression Update(Expression test, Expression ifTrue, Expression ifFalse);
}
internal static class System.Linq.Expressions.ConstantCheck : object {
    internal static bool IsNull(Expression e);
    internal static AnalyzeTypeIsResult AnalyzeTypeIs(TypeBinaryExpression typeIs);
    private static AnalyzeTypeIsResult AnalyzeTypeIs(Expression operand, Type testType);
}
[DebuggerTypeProxyAttribute("System.Linq.Expressions.Expression/ConstantExpressionProxy")]
public class System.Linq.Expressions.ConstantExpression : Expression {
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    public Type Type { get; }
    public ExpressionType NodeType { get; }
    public object Value { get; }
    internal ConstantExpression(object value);
    public virtual Type get_Type();
    public sealed virtual ExpressionType get_NodeType();
    [CompilerGeneratedAttribute]
public object get_Value();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
}
[DebuggerTypeProxyAttribute("System.Linq.Expressions.Expression/DebugInfoExpressionProxy")]
public class System.Linq.Expressions.DebugInfoExpression : Expression {
    [CompilerGeneratedAttribute]
private SymbolDocumentInfo <Document>k__BackingField;
    public Type Type { get; }
    public ExpressionType NodeType { get; }
    [ExcludeFromCodeCoverageAttribute]
public int StartLine { get; }
    [ExcludeFromCodeCoverageAttribute]
public int StartColumn { get; }
    [ExcludeFromCodeCoverageAttribute]
public int EndLine { get; }
    [ExcludeFromCodeCoverageAttribute]
public int EndColumn { get; }
    public SymbolDocumentInfo Document { get; }
    [ExcludeFromCodeCoverageAttribute]
public bool IsClear { get; }
    internal DebugInfoExpression(SymbolDocumentInfo document);
    public sealed virtual Type get_Type();
    public sealed virtual ExpressionType get_NodeType();
    public virtual int get_StartLine();
    public virtual int get_StartColumn();
    public virtual int get_EndLine();
    public virtual int get_EndColumn();
    [CompilerGeneratedAttribute]
public SymbolDocumentInfo get_Document();
    public virtual bool get_IsClear();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
}
internal class System.Linq.Expressions.DebugViewWriter : ExpressionVisitor {
    private static int Tab;
    private static int MaxColumn;
    private TextWriter _out;
    private int _column;
    private Stack`1<int> _stack;
    private int _delta;
    private Flow _flow;
    private Queue`1<LambdaExpression> _lambdas;
    private Dictionary`2<LambdaExpression, int> _lambdaIds;
    private Dictionary`2<ParameterExpression, int> _paramIds;
    private Dictionary`2<LabelTarget, int> _labelIds;
    private int Base { get; }
    private int Delta { get; }
    private int Depth { get; }
    private DebugViewWriter(TextWriter file);
    private int get_Base();
    private int get_Delta();
    private int get_Depth();
    private void Indent();
    private void Dedent();
    private void NewLine();
    private static int GetId(T e, Dictionary`2& ids);
    private int GetLambdaId(LambdaExpression le);
    private int GetParamId(ParameterExpression p);
    private int GetLabelTargetId(LabelTarget target);
    internal static void WriteTo(Expression node, TextWriter writer);
    private void WriteTo(Expression node);
    private void Out(string s);
    private void Out(Flow before, string s);
    private void Out(string s, Flow after);
    private void Out(Flow before, string s, Flow after);
    private void WriteLine();
    private void Write(string s);
    private Flow GetFlow(Flow flow);
    private Flow CheckBreak(Flow flow);
    private void VisitExpressions(char open, IReadOnlyList`1<T> expressions);
    private void VisitExpressions(char open, char separator, IReadOnlyList`1<T> expressions);
    private void VisitDeclarations(IReadOnlyList`1<ParameterExpression> expressions);
    private void VisitExpressions(char open, char separator, IReadOnlyList`1<T> expressions, Action`1<T> visit);
    protected internal virtual Expression VisitBinary(BinaryExpression node);
    protected internal virtual Expression VisitParameter(ParameterExpression node);
    protected internal virtual Expression VisitLambda(Expression`1<T> node);
    private static bool IsSimpleExpression(Expression node);
    protected internal virtual Expression VisitConditional(ConditionalExpression node);
    protected internal virtual Expression VisitConstant(ConstantExpression node);
    private static string GetConstantValueSuffix(Type type);
    protected internal virtual Expression VisitRuntimeVariables(RuntimeVariablesExpression node);
    private void OutMember(Expression node, Expression instance, MemberInfo member);
    protected internal virtual Expression VisitMember(MemberExpression node);
    protected internal virtual Expression VisitInvocation(InvocationExpression node);
    private static bool NeedsParentheses(Expression parent, Expression child);
    private static int GetOperatorPrecedence(Expression node);
    private void ParenthesizedVisit(Expression parent, Expression nodeToVisit);
    protected internal virtual Expression VisitMethodCall(MethodCallExpression node);
    protected internal virtual Expression VisitNewArray(NewArrayExpression node);
    protected internal virtual Expression VisitNew(NewExpression node);
    protected virtual ElementInit VisitElementInit(ElementInit node);
    protected internal virtual Expression VisitListInit(ListInitExpression node);
    protected virtual MemberAssignment VisitMemberAssignment(MemberAssignment assignment);
    protected virtual MemberListBinding VisitMemberListBinding(MemberListBinding binding);
    protected virtual MemberMemberBinding VisitMemberMemberBinding(MemberMemberBinding binding);
    protected internal virtual Expression VisitMemberInit(MemberInitExpression node);
    protected internal virtual Expression VisitTypeBinary(TypeBinaryExpression node);
    protected internal virtual Expression VisitUnary(UnaryExpression node);
    protected internal virtual Expression VisitBlock(BlockExpression node);
    protected internal virtual Expression VisitDefault(DefaultExpression node);
    protected internal virtual Expression VisitLabel(LabelExpression node);
    protected internal virtual Expression VisitGoto(GotoExpression node);
    protected internal virtual Expression VisitLoop(LoopExpression node);
    protected virtual SwitchCase VisitSwitchCase(SwitchCase node);
    protected internal virtual Expression VisitSwitch(SwitchExpression node);
    protected virtual CatchBlock VisitCatchBlock(CatchBlock node);
    protected internal virtual Expression VisitTry(TryExpression node);
    protected internal virtual Expression VisitIndex(IndexExpression node);
    protected internal virtual Expression VisitExtension(Expression node);
    protected internal virtual Expression VisitDebugInfo(DebugInfoExpression node);
    private void DumpLabel(LabelTarget target);
    private string GetLabelTargetName(LabelTarget target);
    private void WriteLambda(LambdaExpression lambda);
    private string GetLambdaName(LambdaExpression lambda);
    private static bool ContainsWhiteSpace(string name);
    private static string QuoteName(string name);
    private static string GetDisplayName(string name);
    [CompilerGeneratedAttribute]
private void <VisitExpressions>b__37_0(T e);
    [CompilerGeneratedAttribute]
private void <VisitDeclarations>b__38_0(ParameterExpression variable);
    [CompilerGeneratedAttribute]
private void <VisitListInit>b__58_0(ElementInit e);
    [CompilerGeneratedAttribute]
private void <VisitMemberListBinding>b__60_0(ElementInit e);
    [CompilerGeneratedAttribute]
private void <VisitMemberMemberBinding>b__61_0(MemberBinding e);
    [CompilerGeneratedAttribute]
private void <VisitMemberInit>b__62_0(MemberBinding e);
}
[DebuggerTypeProxyAttribute("System.Linq.Expressions.Expression/DefaultExpressionProxy")]
public class System.Linq.Expressions.DefaultExpression : Expression {
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    public Type Type { get; }
    public ExpressionType NodeType { get; }
    internal DefaultExpression(Type type);
    [CompilerGeneratedAttribute]
public sealed virtual Type get_Type();
    public sealed virtual ExpressionType get_NodeType();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
}
public class System.Linq.Expressions.DynamicExpression : Expression {
    [CompilerGeneratedAttribute]
private CallSiteBinder <Binder>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <DelegateType>k__BackingField;
    public bool CanReduce { get; }
    public Type Type { get; }
    public ExpressionType NodeType { get; }
    public CallSiteBinder Binder { get; }
    public Type DelegateType { get; }
    public ReadOnlyCollection`1<Expression> Arguments { get; }
    [ExcludeFromCodeCoverageAttribute]
private int System.Linq.Expressions.IArgumentProvider.ArgumentCount { get; }
    internal DynamicExpression(Type delegateType, CallSiteBinder binder);
    public virtual bool get_CanReduce();
    public virtual Expression Reduce();
    internal static DynamicExpression Make(Type returnType, Type delegateType, CallSiteBinder binder, ReadOnlyCollection`1<Expression> arguments);
    internal static DynamicExpression Make(Type returnType, Type delegateType, CallSiteBinder binder, Expression arg0);
    internal static DynamicExpression Make(Type returnType, Type delegateType, CallSiteBinder binder, Expression arg0, Expression arg1);
    internal static DynamicExpression Make(Type returnType, Type delegateType, CallSiteBinder binder, Expression arg0, Expression arg1, Expression arg2);
    internal static DynamicExpression Make(Type returnType, Type delegateType, CallSiteBinder binder, Expression arg0, Expression arg1, Expression arg2, Expression arg3);
    public virtual Type get_Type();
    public sealed virtual ExpressionType get_NodeType();
    [CompilerGeneratedAttribute]
public CallSiteBinder get_Binder();
    [CompilerGeneratedAttribute]
public sealed virtual Type get_DelegateType();
    public ReadOnlyCollection`1<Expression> get_Arguments();
    [ExcludeFromCodeCoverageAttribute]
internal virtual ReadOnlyCollection`1<Expression> GetOrMakeArguments();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
    [ExcludeFromCodeCoverageAttribute]
internal virtual DynamicExpression Rewrite(Expression[] args);
    public DynamicExpression Update(IEnumerable`1<Expression> arguments);
    [ExcludeFromCodeCoverageAttribute]
internal virtual bool SameArguments(ICollection`1<Expression> arguments);
    [ExcludeFromCodeCoverageAttribute]
private sealed virtual override Expression System.Linq.Expressions.IArgumentProvider.GetArgument(int index);
    private sealed virtual override int System.Linq.Expressions.IArgumentProvider.get_ArgumentCount();
    public static DynamicExpression Dynamic(CallSiteBinder binder, Type returnType, Expression[] arguments);
    public static DynamicExpression Dynamic(CallSiteBinder binder, Type returnType, IEnumerable`1<Expression> arguments);
    public static DynamicExpression Dynamic(CallSiteBinder binder, Type returnType, Expression arg0);
    public static DynamicExpression Dynamic(CallSiteBinder binder, Type returnType, Expression arg0, Expression arg1);
    public static DynamicExpression Dynamic(CallSiteBinder binder, Type returnType, Expression arg0, Expression arg1, Expression arg2);
    public static DynamicExpression Dynamic(CallSiteBinder binder, Type returnType, Expression arg0, Expression arg1, Expression arg2, Expression arg3);
    public static DynamicExpression MakeDynamic(Type delegateType, CallSiteBinder binder, IEnumerable`1<Expression> arguments);
    public static DynamicExpression MakeDynamic(Type delegateType, CallSiteBinder binder, Expression[] arguments);
    public static DynamicExpression MakeDynamic(Type delegateType, CallSiteBinder binder, Expression arg0);
    public static DynamicExpression MakeDynamic(Type delegateType, CallSiteBinder binder, Expression arg0, Expression arg1);
    public static DynamicExpression MakeDynamic(Type delegateType, CallSiteBinder binder, Expression arg0, Expression arg1, Expression arg2);
    public static DynamicExpression MakeDynamic(Type delegateType, CallSiteBinder binder, Expression arg0, Expression arg1, Expression arg2, Expression arg3);
    private sealed virtual override Expression System.Linq.Expressions.IDynamicExpression.Rewrite(Expression[] args);
    private sealed virtual override object System.Linq.Expressions.IDynamicExpression.CreateCallSite();
}
internal class System.Linq.Expressions.DynamicExpression1 : DynamicExpression {
    private object _arg0;
    private int System.Linq.Expressions.IArgumentProvider.ArgumentCount { get; }
    internal DynamicExpression1(Type delegateType, CallSiteBinder binder, Expression arg0);
    private sealed virtual override Expression System.Linq.Expressions.IArgumentProvider.GetArgument(int index);
    private sealed virtual override int System.Linq.Expressions.IArgumentProvider.get_ArgumentCount();
    internal virtual bool SameArguments(ICollection`1<Expression> arguments);
    internal virtual ReadOnlyCollection`1<Expression> GetOrMakeArguments();
    internal virtual DynamicExpression Rewrite(Expression[] args);
}
internal class System.Linq.Expressions.DynamicExpression2 : DynamicExpression {
    private object _arg0;
    private Expression _arg1;
    private int System.Linq.Expressions.IArgumentProvider.ArgumentCount { get; }
    internal DynamicExpression2(Type delegateType, CallSiteBinder binder, Expression arg0, Expression arg1);
    private sealed virtual override Expression System.Linq.Expressions.IArgumentProvider.GetArgument(int index);
    private sealed virtual override int System.Linq.Expressions.IArgumentProvider.get_ArgumentCount();
    internal virtual bool SameArguments(ICollection`1<Expression> arguments);
    internal virtual ReadOnlyCollection`1<Expression> GetOrMakeArguments();
    internal virtual DynamicExpression Rewrite(Expression[] args);
}
internal class System.Linq.Expressions.DynamicExpression3 : DynamicExpression {
    private object _arg0;
    private Expression _arg1;
    private Expression _arg2;
    private int System.Linq.Expressions.IArgumentProvider.ArgumentCount { get; }
    internal DynamicExpression3(Type delegateType, CallSiteBinder binder, Expression arg0, Expression arg1, Expression arg2);
    private sealed virtual override Expression System.Linq.Expressions.IArgumentProvider.GetArgument(int index);
    private sealed virtual override int System.Linq.Expressions.IArgumentProvider.get_ArgumentCount();
    internal virtual bool SameArguments(ICollection`1<Expression> arguments);
    internal virtual ReadOnlyCollection`1<Expression> GetOrMakeArguments();
    internal virtual DynamicExpression Rewrite(Expression[] args);
}
internal class System.Linq.Expressions.DynamicExpression4 : DynamicExpression {
    private object _arg0;
    private Expression _arg1;
    private Expression _arg2;
    private Expression _arg3;
    private int System.Linq.Expressions.IArgumentProvider.ArgumentCount { get; }
    internal DynamicExpression4(Type delegateType, CallSiteBinder binder, Expression arg0, Expression arg1, Expression arg2, Expression arg3);
    private sealed virtual override Expression System.Linq.Expressions.IArgumentProvider.GetArgument(int index);
    private sealed virtual override int System.Linq.Expressions.IArgumentProvider.get_ArgumentCount();
    internal virtual bool SameArguments(ICollection`1<Expression> arguments);
    internal virtual ReadOnlyCollection`1<Expression> GetOrMakeArguments();
    internal virtual DynamicExpression Rewrite(Expression[] args);
}
internal class System.Linq.Expressions.DynamicExpressionN : DynamicExpression {
    private IReadOnlyList`1<Expression> _arguments;
    private int System.Linq.Expressions.IArgumentProvider.ArgumentCount { get; }
    internal DynamicExpressionN(Type delegateType, CallSiteBinder binder, IReadOnlyList`1<Expression> arguments);
    private sealed virtual override Expression System.Linq.Expressions.IArgumentProvider.GetArgument(int index);
    internal virtual bool SameArguments(ICollection`1<Expression> arguments);
    private sealed virtual override int System.Linq.Expressions.IArgumentProvider.get_ArgumentCount();
    internal virtual ReadOnlyCollection`1<Expression> GetOrMakeArguments();
    internal virtual DynamicExpression Rewrite(Expression[] args);
}
public class System.Linq.Expressions.DynamicExpressionVisitor : ExpressionVisitor {
    protected internal virtual Expression VisitDynamic(DynamicExpression node);
}
public class System.Linq.Expressions.ElementInit : object {
    [CompilerGeneratedAttribute]
private MethodInfo <AddMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadOnlyCollection`1<Expression> <Arguments>k__BackingField;
    public MethodInfo AddMethod { get; }
    public ReadOnlyCollection`1<Expression> Arguments { get; }
    public int ArgumentCount { get; }
    internal ElementInit(MethodInfo addMethod, ReadOnlyCollection`1<Expression> arguments);
    [CompilerGeneratedAttribute]
public MethodInfo get_AddMethod();
    [CompilerGeneratedAttribute]
public ReadOnlyCollection`1<Expression> get_Arguments();
    public sealed virtual Expression GetArgument(int index);
    public sealed virtual int get_ArgumentCount();
    public virtual string ToString();
    public ElementInit Update(IEnumerable`1<Expression> arguments);
}
internal static class System.Linq.Expressions.Error : object {
    internal static Exception ReducibleMustOverrideReduce();
    internal static Exception ArgCntMustBeGreaterThanNameCnt();
    internal static Exception InvalidMetaObjectCreated(object p0);
    internal static Exception AmbiguousMatchInExpandoObject(object p0);
    internal static Exception SameKeyExistsInExpando(object key);
    internal static Exception KeyDoesNotExistInExpando(object p0);
    internal static Exception CollectionModifiedWhileEnumerating();
    internal static Exception CollectionReadOnly();
    internal static Exception MustReduceToDifferent();
    internal static Exception BinderNotCompatibleWithCallSite(object p0, object p1, object p2);
    internal static Exception DynamicBindingNeedsRestrictions(object p0, object p1);
    internal static Exception DynamicObjectResultNotAssignable(object p0, object p1, object p2, object p3);
    internal static Exception DynamicBinderResultNotAssignable(object p0, object p1, object p2);
    internal static Exception BindingCannotBeNull();
    internal static Exception ReducedNotCompatible();
    internal static Exception SetterHasNoParams(string paramName);
    internal static Exception PropertyCannotHaveRefType(string paramName);
    internal static Exception IndexesOfSetGetMustMatch(string paramName);
    internal static Exception TypeParameterIsNotDelegate(object p0);
    internal static Exception FirstArgumentMustBeCallSite();
    internal static Exception AccessorsCannotHaveVarArgs(string paramName);
    private static Exception AccessorsCannotHaveByRefArgs(string paramName);
    internal static Exception AccessorsCannotHaveByRefArgs(string paramName, int index);
    internal static Exception TypeMustBeDerivedFromSystemDelegate();
    internal static Exception NoOrInvalidRuleProduced();
    internal static Exception BoundsCannotBeLessThanOne(string paramName);
    internal static Exception TypeMustNotBeByRef(string paramName);
    internal static Exception TypeMustNotBePointer(string paramName);
    internal static Exception SetterMustBeVoid(string paramName);
    internal static Exception PropertyTypeMustMatchGetter(string paramName);
    internal static Exception PropertyTypeMustMatchSetter(string paramName);
    internal static Exception BothAccessorsMustBeStatic(string paramName);
    internal static Exception OnlyStaticFieldsHaveNullInstance(string paramName);
    internal static Exception OnlyStaticPropertiesHaveNullInstance(string paramName);
    internal static Exception OnlyStaticMethodsHaveNullInstance();
    internal static Exception PropertyTypeCannotBeVoid(string paramName);
    internal static Exception InvalidUnboxType(string paramName);
    internal static Exception ExpressionMustBeWriteable(string paramName);
    internal static Exception ArgumentMustNotHaveValueType(string paramName);
    internal static Exception MustBeReducible();
    internal static Exception AllTestValuesMustHaveSameType(string paramName);
    internal static Exception AllCaseBodiesMustHaveSameType(string paramName);
    internal static Exception DefaultBodyMustBeSupplied(string paramName);
    internal static Exception LabelMustBeVoidOrHaveExpression(string paramName);
    internal static Exception LabelTypeMustBeVoid(string paramName);
    internal static Exception QuotedExpressionMustBeLambda(string paramName);
    internal static Exception VariableMustNotBeByRef(object p0, object p1, string paramName);
    internal static Exception VariableMustNotBeByRef(object p0, object p1, string paramName, int index);
    private static Exception DuplicateVariable(object p0, string paramName);
    internal static Exception DuplicateVariable(object p0, string paramName, int index);
    internal static Exception StartEndMustBeOrdered();
    internal static Exception FaultCannotHaveCatchOrFinally(string paramName);
    internal static Exception TryMustHaveCatchFinallyOrFault();
    internal static Exception BodyOfCatchMustHaveSameTypeAsBodyOfTry();
    internal static Exception ExtensionNodeMustOverrideProperty(object p0);
    internal static Exception UserDefinedOperatorMustBeStatic(object p0, string paramName);
    internal static Exception UserDefinedOperatorMustNotBeVoid(object p0, string paramName);
    internal static Exception CoercionOperatorNotDefined(object p0, object p1);
    internal static Exception UnaryOperatorNotDefined(object p0, object p1);
    internal static Exception BinaryOperatorNotDefined(object p0, object p1, object p2);
    internal static Exception ReferenceEqualityNotDefined(object p0, object p1);
    internal static Exception OperandTypesDoNotMatchParameters(object p0, object p1);
    internal static Exception OverloadOperatorTypeDoesNotMatchConversionType(object p0, object p1);
    internal static Exception ConversionIsNotSupportedForArithmeticTypes();
    internal static Exception ArgumentTypeCannotBeVoid();
    internal static Exception ArgumentMustBeArray(string paramName);
    internal static Exception ArgumentMustBeBoolean(string paramName);
    internal static Exception EqualityMustReturnBoolean(object p0, string paramName);
    internal static Exception ArgumentMustBeFieldInfoOrPropertyInfo(string paramName);
    private static Exception ArgumentMustBeFieldInfoOrPropertyInfoOrMethod(string paramName);
    internal static Exception ArgumentMustBeFieldInfoOrPropertyInfoOrMethod(string paramName, int index);
    private static Exception ArgumentMustBeInstanceMember(string paramName);
    internal static Exception ArgumentMustBeInstanceMember(string paramName, int index);
    private static Exception ArgumentMustBeInteger(string paramName);
    internal static Exception ArgumentMustBeInteger(string paramName, int index);
    internal static Exception ArgumentMustBeArrayIndexType(string paramName);
    internal static Exception ArgumentMustBeArrayIndexType(string paramName, int index);
    internal static Exception ArgumentMustBeSingleDimensionalArrayType(string paramName);
    internal static Exception ArgumentTypesMustMatch();
    internal static Exception ArgumentTypesMustMatch(string paramName);
    internal static Exception CannotAutoInitializeValueTypeElementThroughProperty(object p0);
    internal static Exception CannotAutoInitializeValueTypeMemberThroughProperty(object p0);
    internal static Exception IncorrectTypeForTypeAs(object p0, string paramName);
    internal static Exception CoalesceUsedOnNonNullType();
    internal static Exception ExpressionTypeCannotInitializeArrayType(object p0, object p1);
    private static Exception ArgumentTypeDoesNotMatchMember(object p0, object p1, string paramName);
    internal static Exception ArgumentTypeDoesNotMatchMember(object p0, object p1, string paramName, int index);
    private static Exception ArgumentMemberNotDeclOnType(object p0, object p1, string paramName);
    internal static Exception ArgumentMemberNotDeclOnType(object p0, object p1, string paramName, int index);
    internal static Exception ExpressionTypeDoesNotMatchReturn(object p0, object p1);
    internal static Exception ExpressionTypeDoesNotMatchAssignment(object p0, object p1);
    internal static Exception ExpressionTypeDoesNotMatchLabel(object p0, object p1);
    internal static Exception ExpressionTypeNotInvocable(object p0, string paramName);
    internal static Exception FieldNotDefinedForType(object p0, object p1);
    internal static Exception InstanceFieldNotDefinedForType(object p0, object p1);
    internal static Exception FieldInfoNotDefinedForType(object p0, object p1, object p2);
    internal static Exception IncorrectNumberOfIndexes();
    internal static Exception IncorrectNumberOfLambdaDeclarationParameters();
    internal static Exception IncorrectNumberOfMembersForGivenConstructor();
    internal static Exception IncorrectNumberOfArgumentsForMembers();
    internal static Exception LambdaTypeMustBeDerivedFromSystemDelegate(string paramName);
    internal static Exception MemberNotFieldOrProperty(object p0, string paramName);
    internal static Exception MethodContainsGenericParameters(object p0, string paramName);
    internal static Exception MethodIsGeneric(object p0, string paramName);
    private static Exception MethodNotPropertyAccessor(object p0, object p1, string paramName);
    internal static Exception MethodNotPropertyAccessor(object p0, object p1, string paramName, int index);
    internal static Exception PropertyDoesNotHaveGetter(object p0, string paramName);
    internal static Exception PropertyDoesNotHaveGetter(object p0, string paramName, int index);
    internal static Exception PropertyDoesNotHaveSetter(object p0, string paramName);
    internal static Exception PropertyDoesNotHaveAccessor(object p0, string paramName);
    internal static Exception NotAMemberOfType(object p0, object p1, string paramName);
    internal static Exception NotAMemberOfType(object p0, object p1, string paramName, int index);
    internal static Exception NotAMemberOfAnyType(object p0, string paramName);
    internal static Exception ParameterExpressionNotValidAsDelegate(object p0, object p1);
    internal static Exception PropertyNotDefinedForType(object p0, object p1, string paramName);
    internal static Exception InstancePropertyNotDefinedForType(object p0, object p1, string paramName);
    internal static Exception InstancePropertyWithoutParameterNotDefinedForType(object p0, object p1);
    internal static Exception InstancePropertyWithSpecifiedParametersNotDefinedForType(object p0, object p1, object p2, string paramName);
    internal static Exception InstanceAndMethodTypeMismatch(object p0, object p1, object p2);
    internal static Exception TypeMissingDefaultConstructor(object p0, string paramName);
    internal static Exception ElementInitializerMethodNotAdd(string paramName);
    internal static Exception ElementInitializerMethodNoRefOutParam(object p0, object p1, string paramName);
    internal static Exception ElementInitializerMethodWithZeroArgs(string paramName);
    internal static Exception ElementInitializerMethodStatic(string paramName);
    internal static Exception TypeNotIEnumerable(object p0, string paramName);
    internal static Exception UnhandledBinary(object p0, string paramName);
    internal static Exception UnhandledBinding();
    internal static Exception UnhandledBindingType(object p0);
    internal static Exception UnhandledUnary(object p0, string paramName);
    internal static Exception UnknownBindingType(int index);
    internal static Exception UserDefinedOpMustHaveConsistentTypes(object p0, object p1);
    internal static Exception UserDefinedOpMustHaveValidReturnType(object p0, object p1);
    internal static Exception LogicalOperatorMustHaveBooleanOperators(object p0, object p1);
    internal static Exception MethodWithArgsDoesNotExistOnType(object p0, object p1);
    internal static Exception GenericMethodWithArgsDoesNotExistOnType(object p0, object p1);
    internal static Exception MethodWithMoreThanOneMatch(object p0, object p1);
    internal static Exception PropertyWithMoreThanOneMatch(object p0, object p1);
    internal static Exception IncorrectNumberOfTypeArgsForFunc(string paramName);
    internal static Exception IncorrectNumberOfTypeArgsForAction(string paramName);
    internal static Exception ArgumentCannotBeOfTypeVoid(string paramName);
    internal static Exception OutOfRange(string paramName, object p1);
    internal static Exception LabelTargetAlreadyDefined(object p0);
    internal static Exception LabelTargetUndefined(object p0);
    internal static Exception ControlCannotLeaveFinally();
    internal static Exception ControlCannotLeaveFilterTest();
    internal static Exception AmbiguousJump(object p0);
    internal static Exception ControlCannotEnterTry();
    internal static Exception ControlCannotEnterExpression();
    internal static Exception NonLocalJumpWithValue(object p0);
    internal static Exception CannotCompileConstant(object p0);
    internal static Exception CannotCompileDynamic();
    internal static Exception MethodBuilderDoesNotHaveTypeBuilder();
    internal static Exception InvalidLvalue(ExpressionType p0);
    internal static Exception UndefinedVariable(object p0, object p1, object p2);
    internal static Exception CannotCloseOverByRef(object p0, object p1);
    internal static Exception UnexpectedVarArgsCall(object p0);
    internal static Exception RethrowRequiresCatch();
    internal static Exception TryNotAllowedInFilter();
    internal static Exception MustRewriteToSameNode(object p0, object p1, object p2);
    internal static Exception MustRewriteChildToSameType(object p0, object p1, object p2);
    internal static Exception MustRewriteWithoutMethod(object p0, object p1);
    internal static Exception TryNotSupportedForMethodsWithRefArgs(object p0);
    internal static Exception TryNotSupportedForValueTypeInstances(object p0);
    internal static Exception TestValueTypeDoesNotMatchComparisonMethodParameter(object p0, object p1);
    internal static Exception SwitchValueTypeDoesNotMatchComparisonMethodParameter(object p0, object p1);
    internal static Exception ArgumentOutOfRange(string paramName);
    internal static Exception NotSupported();
    internal static Exception NonStaticConstructorRequired(string paramName);
    internal static Exception NonAbstractConstructorRequired();
    internal static Exception InvalidProgram();
    internal static Exception EnumerationIsDone();
    private static Exception TypeContainsGenericParameters(object p0, string paramName);
    internal static Exception TypeContainsGenericParameters(object p0, string paramName, int index);
    internal static Exception TypeIsGeneric(object p0, string paramName);
    internal static Exception TypeIsGeneric(object p0, string paramName, int index);
    internal static Exception IncorrectNumberOfConstructorArguments();
    internal static Exception ExpressionTypeDoesNotMatchMethodParameter(object p0, object p1, object p2, string paramName);
    internal static Exception ExpressionTypeDoesNotMatchMethodParameter(object p0, object p1, object p2, string paramName, int index);
    internal static Exception ExpressionTypeDoesNotMatchParameter(object p0, object p1, string paramName);
    internal static Exception ExpressionTypeDoesNotMatchParameter(object p0, object p1, string paramName, int index);
    internal static Exception IncorrectNumberOfLambdaArguments();
    internal static Exception IncorrectNumberOfMethodCallArguments(object p0, string paramName);
    internal static Exception ExpressionTypeDoesNotMatchConstructorParameter(object p0, object p1, string paramName);
    internal static Exception ExpressionTypeDoesNotMatchConstructorParameter(object p0, object p1, string paramName, int index);
    internal static Exception ExpressionMustBeReadable(string paramName);
    internal static Exception ExpressionMustBeReadable(string paramName, int index);
    internal static Exception InvalidArgumentValue(string paramName);
    internal static Exception NonEmptyCollectionRequired(string paramName);
    internal static Exception InvalidNullValue(Type type, string paramName);
    internal static Exception InvalidTypeException(object value, Type type, string paramName);
    private static string GetParamName(string paramName, int index);
}
public abstract class System.Linq.Expressions.Expression : object {
    private static CacheDict`2<Type, MethodInfo> s_lambdaDelegateCache;
    private static CacheDict`2 modreq(System.Runtime.CompilerServices.IsVolatile) s_lambdaFactories;
    private static ConditionalWeakTable`2<Expression, ExtensionInfo> s_legacyCtorSupportTable;
    public ExpressionType NodeType { get; }
    public Type Type { get; }
    public bool CanReduce { get; }
    private string DebugView { get; }
    [ObsoleteAttribute("use a different constructor that does not take ExpressionType. Then override NodeType and Type properties to provide the values that would be specified to this constructor.")]
protected Expression(ExpressionType nodeType, Type type);
    private static Expression();
    public static BinaryExpression Assign(Expression left, Expression right);
    private static BinaryExpression GetUserDefinedBinaryOperator(ExpressionType binaryType, string name, Expression left, Expression right, bool liftToNull);
    private static BinaryExpression GetMethodBasedBinaryOperator(ExpressionType binaryType, Expression left, Expression right, MethodInfo method, bool liftToNull);
    private static BinaryExpression GetMethodBasedAssignOperator(ExpressionType binaryType, Expression left, Expression right, MethodInfo method, LambdaExpression conversion, bool liftToNull);
    private static BinaryExpression GetUserDefinedBinaryOperatorOrThrow(ExpressionType binaryType, string name, Expression left, Expression right, bool liftToNull);
    private static BinaryExpression GetUserDefinedAssignOperatorOrThrow(ExpressionType binaryType, string name, Expression left, Expression right, LambdaExpression conversion, bool liftToNull);
    private static MethodInfo GetUserDefinedBinaryOperator(ExpressionType binaryType, Type leftType, Type rightType, string name);
    private static bool IsLiftingConditionalLogicalOperator(Type left, Type right, MethodInfo method, ExpressionType binaryType);
    internal static bool ParameterIsAssignable(ParameterInfo pi, Type argType);
    private static void ValidateParamswithOperandsOrThrow(Type paramType, Type operandType, ExpressionType exprType, string name);
    private static void ValidateOperator(MethodInfo method);
    private static void ValidateMethodInfo(MethodInfo method, string paramName);
    private static bool IsNullComparison(Expression left, Expression right);
    private static bool IsNullConstant(Expression e);
    private static void ValidateUserDefinedConditionalLogicOperator(ExpressionType nodeType, Type left, Type right, MethodInfo method);
    private static void VerifyOpTrueFalse(ExpressionType nodeType, Type left, MethodInfo opTrue, string paramName);
    private static bool IsValidLiftedConditionalLogicalOperator(Type left, Type right, ParameterInfo[] pms);
    public static BinaryExpression MakeBinary(ExpressionType binaryType, Expression left, Expression right);
    public static BinaryExpression MakeBinary(ExpressionType binaryType, Expression left, Expression right, bool liftToNull, MethodInfo method);
    public static BinaryExpression MakeBinary(ExpressionType binaryType, Expression left, Expression right, bool liftToNull, MethodInfo method, LambdaExpression conversion);
    public static BinaryExpression Equal(Expression left, Expression right);
    public static BinaryExpression Equal(Expression left, Expression right, bool liftToNull, MethodInfo method);
    public static BinaryExpression ReferenceEqual(Expression left, Expression right);
    public static BinaryExpression NotEqual(Expression left, Expression right);
    public static BinaryExpression NotEqual(Expression left, Expression right, bool liftToNull, MethodInfo method);
    public static BinaryExpression ReferenceNotEqual(Expression left, Expression right);
    private static BinaryExpression GetEqualityComparisonOperator(ExpressionType binaryType, string opName, Expression left, Expression right, bool liftToNull);
    public static BinaryExpression GreaterThan(Expression left, Expression right);
    public static BinaryExpression GreaterThan(Expression left, Expression right, bool liftToNull, MethodInfo method);
    public static BinaryExpression LessThan(Expression left, Expression right);
    public static BinaryExpression LessThan(Expression left, Expression right, bool liftToNull, MethodInfo method);
    public static BinaryExpression GreaterThanOrEqual(Expression left, Expression right);
    public static BinaryExpression GreaterThanOrEqual(Expression left, Expression right, bool liftToNull, MethodInfo method);
    public static BinaryExpression LessThanOrEqual(Expression left, Expression right);
    public static BinaryExpression LessThanOrEqual(Expression left, Expression right, bool liftToNull, MethodInfo method);
    private static BinaryExpression GetComparisonOperator(ExpressionType binaryType, string opName, Expression left, Expression right, bool liftToNull);
    public static BinaryExpression AndAlso(Expression left, Expression right);
    public static BinaryExpression AndAlso(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression OrElse(Expression left, Expression right);
    public static BinaryExpression OrElse(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression Coalesce(Expression left, Expression right);
    public static BinaryExpression Coalesce(Expression left, Expression right, LambdaExpression conversion);
    private static Type ValidateCoalesceArgTypes(Type left, Type right);
    public static BinaryExpression Add(Expression left, Expression right);
    public static BinaryExpression Add(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression AddAssign(Expression left, Expression right);
    public static BinaryExpression AddAssign(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression AddAssign(Expression left, Expression right, MethodInfo method, LambdaExpression conversion);
    private static void ValidateOpAssignConversionLambda(LambdaExpression conversion, Expression left, MethodInfo method, ExpressionType nodeType);
    public static BinaryExpression AddAssignChecked(Expression left, Expression right);
    public static BinaryExpression AddAssignChecked(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression AddAssignChecked(Expression left, Expression right, MethodInfo method, LambdaExpression conversion);
    public static BinaryExpression AddChecked(Expression left, Expression right);
    public static BinaryExpression AddChecked(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression Subtract(Expression left, Expression right);
    public static BinaryExpression Subtract(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression SubtractAssign(Expression left, Expression right);
    public static BinaryExpression SubtractAssign(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression SubtractAssign(Expression left, Expression right, MethodInfo method, LambdaExpression conversion);
    public static BinaryExpression SubtractAssignChecked(Expression left, Expression right);
    public static BinaryExpression SubtractAssignChecked(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression SubtractAssignChecked(Expression left, Expression right, MethodInfo method, LambdaExpression conversion);
    public static BinaryExpression SubtractChecked(Expression left, Expression right);
    public static BinaryExpression SubtractChecked(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression Divide(Expression left, Expression right);
    public static BinaryExpression Divide(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression DivideAssign(Expression left, Expression right);
    public static BinaryExpression DivideAssign(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression DivideAssign(Expression left, Expression right, MethodInfo method, LambdaExpression conversion);
    public static BinaryExpression Modulo(Expression left, Expression right);
    public static BinaryExpression Modulo(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression ModuloAssign(Expression left, Expression right);
    public static BinaryExpression ModuloAssign(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression ModuloAssign(Expression left, Expression right, MethodInfo method, LambdaExpression conversion);
    public static BinaryExpression Multiply(Expression left, Expression right);
    public static BinaryExpression Multiply(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression MultiplyAssign(Expression left, Expression right);
    public static BinaryExpression MultiplyAssign(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression MultiplyAssign(Expression left, Expression right, MethodInfo method, LambdaExpression conversion);
    public static BinaryExpression MultiplyAssignChecked(Expression left, Expression right);
    public static BinaryExpression MultiplyAssignChecked(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression MultiplyAssignChecked(Expression left, Expression right, MethodInfo method, LambdaExpression conversion);
    public static BinaryExpression MultiplyChecked(Expression left, Expression right);
    public static BinaryExpression MultiplyChecked(Expression left, Expression right, MethodInfo method);
    private static bool IsSimpleShift(Type left, Type right);
    private static Type GetResultTypeOfShift(Type left, Type right);
    public static BinaryExpression LeftShift(Expression left, Expression right);
    public static BinaryExpression LeftShift(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression LeftShiftAssign(Expression left, Expression right);
    public static BinaryExpression LeftShiftAssign(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression LeftShiftAssign(Expression left, Expression right, MethodInfo method, LambdaExpression conversion);
    public static BinaryExpression RightShift(Expression left, Expression right);
    public static BinaryExpression RightShift(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression RightShiftAssign(Expression left, Expression right);
    public static BinaryExpression RightShiftAssign(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression RightShiftAssign(Expression left, Expression right, MethodInfo method, LambdaExpression conversion);
    public static BinaryExpression And(Expression left, Expression right);
    public static BinaryExpression And(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression AndAssign(Expression left, Expression right);
    public static BinaryExpression AndAssign(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression AndAssign(Expression left, Expression right, MethodInfo method, LambdaExpression conversion);
    public static BinaryExpression Or(Expression left, Expression right);
    public static BinaryExpression Or(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression OrAssign(Expression left, Expression right);
    public static BinaryExpression OrAssign(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression OrAssign(Expression left, Expression right, MethodInfo method, LambdaExpression conversion);
    public static BinaryExpression ExclusiveOr(Expression left, Expression right);
    public static BinaryExpression ExclusiveOr(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression ExclusiveOrAssign(Expression left, Expression right);
    public static BinaryExpression ExclusiveOrAssign(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression ExclusiveOrAssign(Expression left, Expression right, MethodInfo method, LambdaExpression conversion);
    public static BinaryExpression Power(Expression left, Expression right);
    public static BinaryExpression Power(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression PowerAssign(Expression left, Expression right);
    public static BinaryExpression PowerAssign(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression PowerAssign(Expression left, Expression right, MethodInfo method, LambdaExpression conversion);
    public static BinaryExpression ArrayIndex(Expression array, Expression index);
    public static BlockExpression Block(Expression arg0, Expression arg1);
    public static BlockExpression Block(Expression arg0, Expression arg1, Expression arg2);
    public static BlockExpression Block(Expression arg0, Expression arg1, Expression arg2, Expression arg3);
    public static BlockExpression Block(Expression arg0, Expression arg1, Expression arg2, Expression arg3, Expression arg4);
    public static BlockExpression Block(Expression[] expressions);
    public static BlockExpression Block(IEnumerable`1<Expression> expressions);
    public static BlockExpression Block(Type type, Expression[] expressions);
    public static BlockExpression Block(Type type, IEnumerable`1<Expression> expressions);
    public static BlockExpression Block(IEnumerable`1<ParameterExpression> variables, Expression[] expressions);
    public static BlockExpression Block(Type type, IEnumerable`1<ParameterExpression> variables, Expression[] expressions);
    public static BlockExpression Block(IEnumerable`1<ParameterExpression> variables, IEnumerable`1<Expression> expressions);
    public static BlockExpression Block(Type type, IEnumerable`1<ParameterExpression> variables, IEnumerable`1<Expression> expressions);
    private static BlockExpression BlockCore(Type type, ReadOnlyCollection`1<ParameterExpression> variables, ReadOnlyCollection`1<Expression> expressions);
    internal static void ValidateVariables(ReadOnlyCollection`1<ParameterExpression> varList, string collectionName);
    private static BlockExpression GetOptimizedBlockExpression(IReadOnlyList`1<Expression> expressions);
    public static CatchBlock Catch(Type type, Expression body);
    public static CatchBlock Catch(ParameterExpression variable, Expression body);
    public static CatchBlock Catch(Type type, Expression body, Expression filter);
    public static CatchBlock Catch(ParameterExpression variable, Expression body, Expression filter);
    public static CatchBlock MakeCatchBlock(Type type, ParameterExpression variable, Expression body, Expression filter);
    public static ConditionalExpression Condition(Expression test, Expression ifTrue, Expression ifFalse);
    public static ConditionalExpression Condition(Expression test, Expression ifTrue, Expression ifFalse, Type type);
    public static ConditionalExpression IfThen(Expression test, Expression ifTrue);
    public static ConditionalExpression IfThenElse(Expression test, Expression ifTrue, Expression ifFalse);
    public static ConstantExpression Constant(object value);
    public static ConstantExpression Constant(object value, Type type);
    public static DebugInfoExpression DebugInfo(SymbolDocumentInfo document, int startLine, int startColumn, int endLine, int endColumn);
    public static DebugInfoExpression ClearDebugInfo(SymbolDocumentInfo document);
    private static void ValidateSpan(int startLine, int startColumn, int endLine, int endColumn);
    public static DefaultExpression Empty();
    public static DefaultExpression Default(Type type);
    public static ElementInit ElementInit(MethodInfo addMethod, Expression[] arguments);
    public static ElementInit ElementInit(MethodInfo addMethod, IEnumerable`1<Expression> arguments);
    private static void ValidateElementInitAddMethodInfo(MethodInfo addMethod, string paramName);
    public virtual ExpressionType get_NodeType();
    public virtual Type get_Type();
    public virtual bool get_CanReduce();
    public virtual Expression Reduce();
    protected internal virtual Expression VisitChildren(ExpressionVisitor visitor);
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
    public Expression ReduceAndCheck();
    public Expression ReduceExtensions();
    public virtual string ToString();
    private string get_DebugView();
    private static void RequiresCanRead(IReadOnlyList`1<Expression> items, string paramName);
    private static void RequiresCanWrite(Expression expression, string paramName);
    public static DynamicExpression Dynamic(CallSiteBinder binder, Type returnType, IEnumerable`1<Expression> arguments);
    public static DynamicExpression Dynamic(CallSiteBinder binder, Type returnType, Expression arg0);
    public static DynamicExpression Dynamic(CallSiteBinder binder, Type returnType, Expression arg0, Expression arg1);
    public static DynamicExpression Dynamic(CallSiteBinder binder, Type returnType, Expression arg0, Expression arg1, Expression arg2);
    public static DynamicExpression Dynamic(CallSiteBinder binder, Type returnType, Expression arg0, Expression arg1, Expression arg2, Expression arg3);
    public static DynamicExpression Dynamic(CallSiteBinder binder, Type returnType, Expression[] arguments);
    public static DynamicExpression MakeDynamic(Type delegateType, CallSiteBinder binder, IEnumerable`1<Expression> arguments);
    public static DynamicExpression MakeDynamic(Type delegateType, CallSiteBinder binder, Expression arg0);
    public static DynamicExpression MakeDynamic(Type delegateType, CallSiteBinder binder, Expression arg0, Expression arg1);
    public static DynamicExpression MakeDynamic(Type delegateType, CallSiteBinder binder, Expression arg0, Expression arg1, Expression arg2);
    public static DynamicExpression MakeDynamic(Type delegateType, CallSiteBinder binder, Expression arg0, Expression arg1, Expression arg2, Expression arg3);
    public static DynamicExpression MakeDynamic(Type delegateType, CallSiteBinder binder, Expression[] arguments);
    public static GotoExpression Break(LabelTarget target);
    public static GotoExpression Break(LabelTarget target, Expression value);
    public static GotoExpression Break(LabelTarget target, Type type);
    public static GotoExpression Break(LabelTarget target, Expression value, Type type);
    public static GotoExpression Continue(LabelTarget target);
    public static GotoExpression Continue(LabelTarget target, Type type);
    public static GotoExpression Return(LabelTarget target);
    public static GotoExpression Return(LabelTarget target, Type type);
    public static GotoExpression Return(LabelTarget target, Expression value);
    public static GotoExpression Return(LabelTarget target, Expression value, Type type);
    public static GotoExpression Goto(LabelTarget target);
    public static GotoExpression Goto(LabelTarget target, Type type);
    public static GotoExpression Goto(LabelTarget target, Expression value);
    public static GotoExpression Goto(LabelTarget target, Expression value, Type type);
    public static GotoExpression MakeGoto(GotoExpressionKind kind, LabelTarget target, Expression value, Type type);
    private static void ValidateGoto(LabelTarget target, Expression& value, string targetParameter, string valueParameter, Type type);
    private static void ValidateGotoType(Type expectedType, Expression& value, string paramName);
    public static IndexExpression MakeIndex(Expression instance, PropertyInfo indexer, IEnumerable`1<Expression> arguments);
    public static IndexExpression ArrayAccess(Expression array, Expression[] indexes);
    public static IndexExpression ArrayAccess(Expression array, IEnumerable`1<Expression> indexes);
    public static IndexExpression Property(Expression instance, string propertyName, Expression[] arguments);
    private static PropertyInfo FindInstanceProperty(Type type, string propertyName, Expression[] arguments);
    private static string GetArgTypesString(Expression[] arguments);
    private static PropertyInfo FindProperty(Type type, string propertyName, Expression[] arguments, BindingFlags flags);
    private static bool IsCompatible(PropertyInfo pi, Expression[] args);
    public static IndexExpression Property(Expression instance, PropertyInfo indexer, Expression[] arguments);
    public static IndexExpression Property(Expression instance, PropertyInfo indexer, IEnumerable`1<Expression> arguments);
    private static IndexExpression MakeIndexProperty(Expression instance, PropertyInfo indexer, string paramName, ReadOnlyCollection`1<Expression> argList);
    private static void ValidateIndexedProperty(Expression instance, PropertyInfo indexer, string paramName, ReadOnlyCollection`1& argList);
    private static void ValidateAccessor(Expression instance, MethodInfo method, ParameterInfo[] indexes, ReadOnlyCollection`1& arguments, string paramName);
    private static void ValidateAccessorArgumentTypes(MethodInfo method, ParameterInfo[] indexes, ReadOnlyCollection`1& arguments, string paramName);
    internal static InvocationExpression Invoke(Expression expression);
    internal static InvocationExpression Invoke(Expression expression, Expression arg0);
    internal static InvocationExpression Invoke(Expression expression, Expression arg0, Expression arg1);
    internal static InvocationExpression Invoke(Expression expression, Expression arg0, Expression arg1, Expression arg2);
    internal static InvocationExpression Invoke(Expression expression, Expression arg0, Expression arg1, Expression arg2, Expression arg3);
    internal static InvocationExpression Invoke(Expression expression, Expression arg0, Expression arg1, Expression arg2, Expression arg3, Expression arg4);
    public static InvocationExpression Invoke(Expression expression, Expression[] arguments);
    public static InvocationExpression Invoke(Expression expression, IEnumerable`1<Expression> arguments);
    internal static MethodInfo GetInvokeMethod(Expression expression);
    public static LabelExpression Label(LabelTarget target);
    public static LabelExpression Label(LabelTarget target, Expression defaultValue);
    public static LabelTarget Label();
    public static LabelTarget Label(string name);
    public static LabelTarget Label(Type type);
    public static LabelTarget Label(Type type, string name);
    internal static LambdaExpression CreateLambda(Type delegateType, Expression body, string name, bool tailCall, ReadOnlyCollection`1<ParameterExpression> parameters);
    public static Expression`1<TDelegate> Lambda(Expression body, ParameterExpression[] parameters);
    public static Expression`1<TDelegate> Lambda(Expression body, bool tailCall, ParameterExpression[] parameters);
    public static Expression`1<TDelegate> Lambda(Expression body, IEnumerable`1<ParameterExpression> parameters);
    public static Expression`1<TDelegate> Lambda(Expression body, bool tailCall, IEnumerable`1<ParameterExpression> parameters);
    public static Expression`1<TDelegate> Lambda(Expression body, string name, IEnumerable`1<ParameterExpression> parameters);
    public static Expression`1<TDelegate> Lambda(Expression body, string name, bool tailCall, IEnumerable`1<ParameterExpression> parameters);
    public static LambdaExpression Lambda(Expression body, ParameterExpression[] parameters);
    public static LambdaExpression Lambda(Expression body, bool tailCall, ParameterExpression[] parameters);
    public static LambdaExpression Lambda(Expression body, IEnumerable`1<ParameterExpression> parameters);
    public static LambdaExpression Lambda(Expression body, bool tailCall, IEnumerable`1<ParameterExpression> parameters);
    public static LambdaExpression Lambda(Type delegateType, Expression body, ParameterExpression[] parameters);
    public static LambdaExpression Lambda(Type delegateType, Expression body, bool tailCall, ParameterExpression[] parameters);
    public static LambdaExpression Lambda(Type delegateType, Expression body, IEnumerable`1<ParameterExpression> parameters);
    public static LambdaExpression Lambda(Type delegateType, Expression body, bool tailCall, IEnumerable`1<ParameterExpression> parameters);
    public static LambdaExpression Lambda(Expression body, string name, IEnumerable`1<ParameterExpression> parameters);
    public static LambdaExpression Lambda(Expression body, string name, bool tailCall, IEnumerable`1<ParameterExpression> parameters);
    public static LambdaExpression Lambda(Type delegateType, Expression body, string name, IEnumerable`1<ParameterExpression> parameters);
    public static LambdaExpression Lambda(Type delegateType, Expression body, string name, bool tailCall, IEnumerable`1<ParameterExpression> parameters);
    private static void ValidateLambdaArgs(Type delegateType, Expression& body, ReadOnlyCollection`1<ParameterExpression> parameters, string paramName);
    private static TryGetFuncActionArgsResult ValidateTryGetFuncActionArgs(Type[] typeArgs);
    public static Type GetFuncType(Type[] typeArgs);
    public static bool TryGetFuncType(Type[] typeArgs, Type& funcType);
    public static Type GetActionType(Type[] typeArgs);
    public static bool TryGetActionType(Type[] typeArgs, Type& actionType);
    public static Type GetDelegateType(Type[] typeArgs);
    public static ListInitExpression ListInit(NewExpression newExpression, Expression[] initializers);
    public static ListInitExpression ListInit(NewExpression newExpression, IEnumerable`1<Expression> initializers);
    public static ListInitExpression ListInit(NewExpression newExpression, MethodInfo addMethod, Expression[] initializers);
    public static ListInitExpression ListInit(NewExpression newExpression, MethodInfo addMethod, IEnumerable`1<Expression> initializers);
    public static ListInitExpression ListInit(NewExpression newExpression, ElementInit[] initializers);
    public static ListInitExpression ListInit(NewExpression newExpression, IEnumerable`1<ElementInit> initializers);
    public static LoopExpression Loop(Expression body);
    public static LoopExpression Loop(Expression body, LabelTarget break);
    public static LoopExpression Loop(Expression body, LabelTarget break, LabelTarget continue);
    public static MemberAssignment Bind(MemberInfo member, Expression expression);
    public static MemberAssignment Bind(MethodInfo propertyAccessor, Expression expression);
    private static void ValidateSettableFieldOrPropertyMember(MemberInfo member, Type& memberType);
    public static MemberExpression Field(Expression expression, FieldInfo field);
    public static MemberExpression Field(Expression expression, string fieldName);
    public static MemberExpression Field(Expression expression, Type type, string fieldName);
    public static MemberExpression Property(Expression expression, string propertyName);
    public static MemberExpression Property(Expression expression, Type type, string propertyName);
    public static MemberExpression Property(Expression expression, PropertyInfo property);
    public static MemberExpression Property(Expression expression, MethodInfo propertyAccessor);
    private static PropertyInfo GetProperty(MethodInfo mi, string paramName, int index);
    private static bool CheckMethod(MethodInfo method, MethodInfo propertyMethod);
    public static MemberExpression PropertyOrField(Expression expression, string propertyOrFieldName);
    public static MemberExpression MakeMemberAccess(Expression expression, MemberInfo member);
    public static MemberInitExpression MemberInit(NewExpression newExpression, MemberBinding[] bindings);
    public static MemberInitExpression MemberInit(NewExpression newExpression, IEnumerable`1<MemberBinding> bindings);
    public static MemberListBinding ListBind(MemberInfo member, ElementInit[] initializers);
    public static MemberListBinding ListBind(MemberInfo member, IEnumerable`1<ElementInit> initializers);
    public static MemberListBinding ListBind(MethodInfo propertyAccessor, ElementInit[] initializers);
    public static MemberListBinding ListBind(MethodInfo propertyAccessor, IEnumerable`1<ElementInit> initializers);
    private static void ValidateListInitArgs(Type listType, ReadOnlyCollection`1<ElementInit> initializers, string listTypeParamName);
    public static MemberMemberBinding MemberBind(MemberInfo member, MemberBinding[] bindings);
    public static MemberMemberBinding MemberBind(MemberInfo member, IEnumerable`1<MemberBinding> bindings);
    public static MemberMemberBinding MemberBind(MethodInfo propertyAccessor, MemberBinding[] bindings);
    public static MemberMemberBinding MemberBind(MethodInfo propertyAccessor, IEnumerable`1<MemberBinding> bindings);
    private static void ValidateGettableFieldOrPropertyMember(MemberInfo member, Type& memberType);
    private static void ValidateMemberInitArgs(Type type, ReadOnlyCollection`1<MemberBinding> bindings);
    internal static MethodCallExpression Call(MethodInfo method);
    public static MethodCallExpression Call(MethodInfo method, Expression arg0);
    public static MethodCallExpression Call(MethodInfo method, Expression arg0, Expression arg1);
    public static MethodCallExpression Call(MethodInfo method, Expression arg0, Expression arg1, Expression arg2);
    public static MethodCallExpression Call(MethodInfo method, Expression arg0, Expression arg1, Expression arg2, Expression arg3);
    public static MethodCallExpression Call(MethodInfo method, Expression arg0, Expression arg1, Expression arg2, Expression arg3, Expression arg4);
    public static MethodCallExpression Call(MethodInfo method, Expression[] arguments);
    public static MethodCallExpression Call(MethodInfo method, IEnumerable`1<Expression> arguments);
    public static MethodCallExpression Call(Expression instance, MethodInfo method);
    public static MethodCallExpression Call(Expression instance, MethodInfo method, Expression[] arguments);
    internal static MethodCallExpression Call(Expression instance, MethodInfo method, Expression arg0);
    public static MethodCallExpression Call(Expression instance, MethodInfo method, Expression arg0, Expression arg1);
    public static MethodCallExpression Call(Expression instance, MethodInfo method, Expression arg0, Expression arg1, Expression arg2);
    public static MethodCallExpression Call(Expression instance, string methodName, Type[] typeArguments, Expression[] arguments);
    public static MethodCallExpression Call(Type type, string methodName, Type[] typeArguments, Expression[] arguments);
    public static MethodCallExpression Call(Expression instance, MethodInfo method, IEnumerable`1<Expression> arguments);
    private static ParameterInfo[] ValidateMethodAndGetParameters(Expression instance, MethodInfo method);
    private static void ValidateStaticOrInstanceMethod(Expression instance, MethodInfo method);
    private static void ValidateCallInstanceType(Type instanceType, MethodInfo method);
    private static void ValidateArgumentTypes(MethodBase method, ExpressionType nodeKind, ReadOnlyCollection`1& arguments, string methodParamName);
    private static ParameterInfo[] GetParametersForValidation(MethodBase method, ExpressionType nodeKind);
    private static void ValidateArgumentCount(MethodBase method, ExpressionType nodeKind, int count, ParameterInfo[] pis);
    private static Expression ValidateOneArgument(MethodBase method, ExpressionType nodeKind, Expression arg, ParameterInfo pi, string methodParamName, string argumentParamName);
    private static bool TryQuote(Type parameterType, Expression& argument);
    private static MethodInfo FindMethod(Type type, string methodName, Type[] typeArgs, Expression[] args, BindingFlags flags);
    private static bool IsCompatible(MethodBase m, Expression[] arguments);
    private static MethodInfo ApplyTypeArgs(MethodInfo m, Type[] typeArgs);
    public static MethodCallExpression ArrayIndex(Expression array, Expression[] indexes);
    public static MethodCallExpression ArrayIndex(Expression array, IEnumerable`1<Expression> indexes);
    public static NewArrayExpression NewArrayInit(Type type, Expression[] initializers);
    public static NewArrayExpression NewArrayInit(Type type, IEnumerable`1<Expression> initializers);
    public static NewArrayExpression NewArrayBounds(Type type, Expression[] bounds);
    public static NewArrayExpression NewArrayBounds(Type type, IEnumerable`1<Expression> bounds);
    public static NewExpression New(ConstructorInfo constructor);
    public static NewExpression New(ConstructorInfo constructor, Expression[] arguments);
    public static NewExpression New(ConstructorInfo constructor, IEnumerable`1<Expression> arguments);
    public static NewExpression New(ConstructorInfo constructor, IEnumerable`1<Expression> arguments, IEnumerable`1<MemberInfo> members);
    public static NewExpression New(ConstructorInfo constructor, IEnumerable`1<Expression> arguments, MemberInfo[] members);
    public static NewExpression New(Type type);
    private static void ValidateNewArgs(ConstructorInfo constructor, ReadOnlyCollection`1& arguments, ReadOnlyCollection`1& members);
    private static void ValidateAnonymousTypeMember(MemberInfo& member, Type& memberType, string paramName, int index);
    private static void ValidateConstructor(ConstructorInfo constructor, string paramName);
    public static ParameterExpression Parameter(Type type);
    public static ParameterExpression Variable(Type type);
    public static ParameterExpression Parameter(Type type, string name);
    public static ParameterExpression Variable(Type type, string name);
    private static void Validate(Type type, bool allowByRef);
    public static RuntimeVariablesExpression RuntimeVariables(ParameterExpression[] variables);
    public static RuntimeVariablesExpression RuntimeVariables(IEnumerable`1<ParameterExpression> variables);
    public static SwitchCase SwitchCase(Expression body, Expression[] testValues);
    public static SwitchCase SwitchCase(Expression body, IEnumerable`1<Expression> testValues);
    public static SwitchExpression Switch(Expression switchValue, SwitchCase[] cases);
    public static SwitchExpression Switch(Expression switchValue, Expression defaultBody, SwitchCase[] cases);
    public static SwitchExpression Switch(Expression switchValue, Expression defaultBody, MethodInfo comparison, SwitchCase[] cases);
    public static SwitchExpression Switch(Type type, Expression switchValue, Expression defaultBody, MethodInfo comparison, SwitchCase[] cases);
    public static SwitchExpression Switch(Expression switchValue, Expression defaultBody, MethodInfo comparison, IEnumerable`1<SwitchCase> cases);
    public static SwitchExpression Switch(Type type, Expression switchValue, Expression defaultBody, MethodInfo comparison, IEnumerable`1<SwitchCase> cases);
    private static void ValidateSwitchCaseType(Expression case, bool customType, Type resultType, string parameterName);
    public static SymbolDocumentInfo SymbolDocument(string fileName);
    public static SymbolDocumentInfo SymbolDocument(string fileName, Guid language);
    public static SymbolDocumentInfo SymbolDocument(string fileName, Guid language, Guid languageVendor);
    public static SymbolDocumentInfo SymbolDocument(string fileName, Guid language, Guid languageVendor, Guid documentType);
    public static TryExpression TryFault(Expression body, Expression fault);
    public static TryExpression TryFinally(Expression body, Expression finally);
    public static TryExpression TryCatch(Expression body, CatchBlock[] handlers);
    public static TryExpression TryCatchFinally(Expression body, Expression finally, CatchBlock[] handlers);
    public static TryExpression MakeTry(Type type, Expression body, Expression finally, Expression fault, IEnumerable`1<CatchBlock> handlers);
    private static void ValidateTryAndCatchHaveSameType(Type type, Expression tryBody, ReadOnlyCollection`1<CatchBlock> handlers);
    public static TypeBinaryExpression TypeIs(Expression expression, Type type);
    public static TypeBinaryExpression TypeEqual(Expression expression, Type type);
    public static UnaryExpression MakeUnary(ExpressionType unaryType, Expression operand, Type type);
    public static UnaryExpression MakeUnary(ExpressionType unaryType, Expression operand, Type type, MethodInfo method);
    private static UnaryExpression GetUserDefinedUnaryOperatorOrThrow(ExpressionType unaryType, string name, Expression operand);
    private static UnaryExpression GetUserDefinedUnaryOperator(ExpressionType unaryType, string name, Expression operand);
    private static UnaryExpression GetMethodBasedUnaryOperator(ExpressionType unaryType, Expression operand, MethodInfo method);
    private static UnaryExpression GetUserDefinedCoercionOrThrow(ExpressionType coercionType, Expression expression, Type convertToType);
    private static UnaryExpression GetUserDefinedCoercion(ExpressionType coercionType, Expression expression, Type convertToType);
    private static UnaryExpression GetMethodBasedCoercionOperator(ExpressionType unaryType, Expression operand, Type convertToType, MethodInfo method);
    public static UnaryExpression Negate(Expression expression);
    public static UnaryExpression Negate(Expression expression, MethodInfo method);
    public static UnaryExpression UnaryPlus(Expression expression);
    public static UnaryExpression UnaryPlus(Expression expression, MethodInfo method);
    public static UnaryExpression NegateChecked(Expression expression);
    public static UnaryExpression NegateChecked(Expression expression, MethodInfo method);
    public static UnaryExpression Not(Expression expression);
    public static UnaryExpression Not(Expression expression, MethodInfo method);
    public static UnaryExpression IsFalse(Expression expression);
    public static UnaryExpression IsFalse(Expression expression, MethodInfo method);
    public static UnaryExpression IsTrue(Expression expression);
    public static UnaryExpression IsTrue(Expression expression, MethodInfo method);
    public static UnaryExpression OnesComplement(Expression expression);
    public static UnaryExpression OnesComplement(Expression expression, MethodInfo method);
    public static UnaryExpression TypeAs(Expression expression, Type type);
    public static UnaryExpression Unbox(Expression expression, Type type);
    public static UnaryExpression Convert(Expression expression, Type type);
    public static UnaryExpression Convert(Expression expression, Type type, MethodInfo method);
    public static UnaryExpression ConvertChecked(Expression expression, Type type);
    public static UnaryExpression ConvertChecked(Expression expression, Type type, MethodInfo method);
    public static UnaryExpression ArrayLength(Expression array);
    public static UnaryExpression Quote(Expression expression);
    public static UnaryExpression Rethrow();
    public static UnaryExpression Rethrow(Type type);
    public static UnaryExpression Throw(Expression value);
    public static UnaryExpression Throw(Expression value, Type type);
    public static UnaryExpression Increment(Expression expression);
    public static UnaryExpression Increment(Expression expression, MethodInfo method);
    public static UnaryExpression Decrement(Expression expression);
    public static UnaryExpression Decrement(Expression expression, MethodInfo method);
    public static UnaryExpression PreIncrementAssign(Expression expression);
    public static UnaryExpression PreIncrementAssign(Expression expression, MethodInfo method);
    public static UnaryExpression PreDecrementAssign(Expression expression);
    public static UnaryExpression PreDecrementAssign(Expression expression, MethodInfo method);
    public static UnaryExpression PostIncrementAssign(Expression expression);
    public static UnaryExpression PostIncrementAssign(Expression expression, MethodInfo method);
    public static UnaryExpression PostDecrementAssign(Expression expression);
    public static UnaryExpression PostDecrementAssign(Expression expression, MethodInfo method);
    private static UnaryExpression MakeOpAssignUnary(ExpressionType kind, Expression expression, MethodInfo method);
}
public class System.Linq.Expressions.Expression`1 : LambdaExpression {
    internal Type TypeCore { get; }
    internal Type PublicType { get; }
    internal Expression`1(Expression body);
    internal sealed virtual Type get_TypeCore();
    internal virtual Type get_PublicType();
    public TDelegate Compile();
    public TDelegate Compile(bool preferInterpretation);
    public Expression`1<TDelegate> Update(Expression body, IEnumerable`1<ParameterExpression> parameters);
    [ExcludeFromCodeCoverageAttribute]
internal virtual bool SameParameters(ICollection`1<ParameterExpression> parameters);
    [ExcludeFromCodeCoverageAttribute]
internal virtual Expression`1<TDelegate> Rewrite(Expression body, ParameterExpression[] parameters);
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
    internal virtual LambdaExpression Accept(StackSpiller spiller);
    internal static Expression`1<TDelegate> Create(Expression body, string name, bool tailCall, IReadOnlyList`1<ParameterExpression> parameters);
    public TDelegate Compile(DebugInfoGenerator debugInfoGenerator);
}
internal class System.Linq.Expressions.Expression0`1 : Expression`1<TDelegate> {
    internal int ParameterCount { get; }
    public Expression0`1(Expression body);
    internal virtual int get_ParameterCount();
    internal virtual bool SameParameters(ICollection`1<ParameterExpression> parameters);
    internal virtual ParameterExpression GetParameter(int index);
    internal virtual ReadOnlyCollection`1<ParameterExpression> GetOrMakeParameters();
    internal virtual Expression`1<TDelegate> Rewrite(Expression body, ParameterExpression[] parameters);
}
internal class System.Linq.Expressions.Expression1`1 : Expression`1<TDelegate> {
    private object _par0;
    internal int ParameterCount { get; }
    public Expression1`1(Expression body, ParameterExpression par0);
    internal virtual int get_ParameterCount();
    internal virtual ParameterExpression GetParameter(int index);
    internal virtual bool SameParameters(ICollection`1<ParameterExpression> parameters);
    internal virtual ReadOnlyCollection`1<ParameterExpression> GetOrMakeParameters();
    internal virtual Expression`1<TDelegate> Rewrite(Expression body, ParameterExpression[] parameters);
}
internal class System.Linq.Expressions.Expression2`1 : Expression`1<TDelegate> {
    private object _par0;
    private ParameterExpression _par1;
    internal int ParameterCount { get; }
    public Expression2`1(Expression body, ParameterExpression par0, ParameterExpression par1);
    internal virtual int get_ParameterCount();
    internal virtual ParameterExpression GetParameter(int index);
    internal virtual bool SameParameters(ICollection`1<ParameterExpression> parameters);
    internal virtual ReadOnlyCollection`1<ParameterExpression> GetOrMakeParameters();
    internal virtual Expression`1<TDelegate> Rewrite(Expression body, ParameterExpression[] parameters);
}
internal class System.Linq.Expressions.Expression3`1 : Expression`1<TDelegate> {
    private object _par0;
    private ParameterExpression _par1;
    private ParameterExpression _par2;
    internal int ParameterCount { get; }
    public Expression3`1(Expression body, ParameterExpression par0, ParameterExpression par1, ParameterExpression par2);
    internal virtual int get_ParameterCount();
    internal virtual ParameterExpression GetParameter(int index);
    internal virtual bool SameParameters(ICollection`1<ParameterExpression> parameters);
    internal virtual ReadOnlyCollection`1<ParameterExpression> GetOrMakeParameters();
    internal virtual Expression`1<TDelegate> Rewrite(Expression body, ParameterExpression[] parameters);
}
internal static class System.Linq.Expressions.ExpressionExtension : object {
    public static DynamicExpression MakeDynamic(Type delegateType, CallSiteBinder binder, Expression[] arguments);
    public static DynamicExpression MakeDynamic(Type delegateType, CallSiteBinder binder, IEnumerable`1<Expression> arguments);
    public static DynamicExpression MakeDynamic(Type delegateType, CallSiteBinder binder, Expression arg0);
    public static DynamicExpression MakeDynamic(Type delegateType, CallSiteBinder binder, Expression arg0, Expression arg1);
    public static DynamicExpression MakeDynamic(Type delegateType, CallSiteBinder binder, Expression arg0, Expression arg1, Expression arg2);
    public static DynamicExpression MakeDynamic(Type delegateType, CallSiteBinder binder, Expression arg0, Expression arg1, Expression arg2, Expression arg3);
    private static MethodInfo GetValidMethodForDynamic(Type delegateType);
    public static DynamicExpression Dynamic(CallSiteBinder binder, Type returnType, Expression[] arguments);
    public static DynamicExpression Dynamic(CallSiteBinder binder, Type returnType, Expression arg0);
    public static DynamicExpression Dynamic(CallSiteBinder binder, Type returnType, Expression arg0, Expression arg1);
    public static DynamicExpression Dynamic(CallSiteBinder binder, Type returnType, Expression arg0, Expression arg1, Expression arg2);
    public static DynamicExpression Dynamic(CallSiteBinder binder, Type returnType, Expression arg0, Expression arg1, Expression arg2, Expression arg3);
    public static DynamicExpression Dynamic(CallSiteBinder binder, Type returnType, IEnumerable`1<Expression> arguments);
    private static DynamicExpression MakeDynamic(CallSiteBinder binder, Type returnType, ReadOnlyCollection`1<Expression> arguments);
    private static void ValidateDynamicArgument(Expression arg, string paramName);
    private static void ValidateDynamicArgument(Expression arg, string paramName, int index);
}
internal class System.Linq.Expressions.ExpressionN`1 : Expression`1<TDelegate> {
    private IReadOnlyList`1<ParameterExpression> _parameters;
    internal int ParameterCount { get; }
    public ExpressionN`1(Expression body, IReadOnlyList`1<ParameterExpression> parameters);
    internal virtual int get_ParameterCount();
    internal virtual ParameterExpression GetParameter(int index);
    internal virtual bool SameParameters(ICollection`1<ParameterExpression> parameters);
    internal virtual ReadOnlyCollection`1<ParameterExpression> GetOrMakeParameters();
    internal virtual Expression`1<TDelegate> Rewrite(Expression body, ParameterExpression[] parameters);
}
internal class System.Linq.Expressions.ExpressionStringBuilder : ExpressionVisitor {
    private StringBuilder _out;
    private Dictionary`2<object, int> _ids;
    public virtual string ToString();
    private int GetLabelId(LabelTarget label);
    private int GetParamId(ParameterExpression p);
    private int GetId(object o);
    private void Out(string s);
    private void Out(char c);
    internal static string ExpressionToString(Expression node);
    internal static string CatchBlockToString(CatchBlock node);
    internal static string SwitchCaseToString(SwitchCase node);
    internal static string MemberBindingToString(MemberBinding node);
    internal static string ElementInitBindingToString(ElementInit node);
    private void VisitExpressions(char open, ReadOnlyCollection`1<T> expressions, char close);
    private void VisitExpressions(char open, ReadOnlyCollection`1<T> expressions, char close, string seperator);
    protected internal virtual Expression VisitBinary(BinaryExpression node);
    protected internal virtual Expression VisitParameter(ParameterExpression node);
    protected internal virtual Expression VisitLambda(Expression`1<T> node);
    protected internal virtual Expression VisitListInit(ListInitExpression node);
    protected internal virtual Expression VisitConditional(ConditionalExpression node);
    protected internal virtual Expression VisitConstant(ConstantExpression node);
    protected internal virtual Expression VisitDebugInfo(DebugInfoExpression node);
    protected internal virtual Expression VisitRuntimeVariables(RuntimeVariablesExpression node);
    private void OutMember(Expression instance, MemberInfo member);
    protected internal virtual Expression VisitMember(MemberExpression node);
    protected internal virtual Expression VisitMemberInit(MemberInitExpression node);
    protected virtual MemberAssignment VisitMemberAssignment(MemberAssignment assignment);
    protected virtual MemberListBinding VisitMemberListBinding(MemberListBinding binding);
    protected virtual MemberMemberBinding VisitMemberMemberBinding(MemberMemberBinding binding);
    protected virtual ElementInit VisitElementInit(ElementInit initializer);
    protected internal virtual Expression VisitInvocation(InvocationExpression node);
    protected internal virtual Expression VisitMethodCall(MethodCallExpression node);
    protected internal virtual Expression VisitNewArray(NewArrayExpression node);
    protected internal virtual Expression VisitNew(NewExpression node);
    protected internal virtual Expression VisitTypeBinary(TypeBinaryExpression node);
    protected internal virtual Expression VisitUnary(UnaryExpression node);
    protected internal virtual Expression VisitBlock(BlockExpression node);
    protected internal virtual Expression VisitDefault(DefaultExpression node);
    protected internal virtual Expression VisitLabel(LabelExpression node);
    protected internal virtual Expression VisitGoto(GotoExpression node);
    protected internal virtual Expression VisitLoop(LoopExpression node);
    protected virtual SwitchCase VisitSwitchCase(SwitchCase node);
    protected internal virtual Expression VisitSwitch(SwitchExpression node);
    protected virtual CatchBlock VisitCatchBlock(CatchBlock node);
    protected internal virtual Expression VisitTry(TryExpression node);
    protected internal virtual Expression VisitIndex(IndexExpression node);
    protected internal virtual Expression VisitExtension(Expression node);
    private void DumpLabel(LabelTarget target);
    private static bool IsBool(Expression node);
}
public enum System.Linq.Expressions.ExpressionType : Enum {
    public int value__;
    public static ExpressionType Add;
    public static ExpressionType AddChecked;
    public static ExpressionType And;
    public static ExpressionType AndAlso;
    public static ExpressionType ArrayLength;
    public static ExpressionType ArrayIndex;
    public static ExpressionType Call;
    public static ExpressionType Coalesce;
    public static ExpressionType Conditional;
    public static ExpressionType Constant;
    public static ExpressionType Convert;
    public static ExpressionType ConvertChecked;
    public static ExpressionType Divide;
    public static ExpressionType Equal;
    public static ExpressionType ExclusiveOr;
    public static ExpressionType GreaterThan;
    public static ExpressionType GreaterThanOrEqual;
    public static ExpressionType Invoke;
    public static ExpressionType Lambda;
    public static ExpressionType LeftShift;
    public static ExpressionType LessThan;
    public static ExpressionType LessThanOrEqual;
    public static ExpressionType ListInit;
    public static ExpressionType MemberAccess;
    public static ExpressionType MemberInit;
    public static ExpressionType Modulo;
    public static ExpressionType Multiply;
    public static ExpressionType MultiplyChecked;
    public static ExpressionType Negate;
    public static ExpressionType UnaryPlus;
    public static ExpressionType NegateChecked;
    public static ExpressionType New;
    public static ExpressionType NewArrayInit;
    public static ExpressionType NewArrayBounds;
    public static ExpressionType Not;
    public static ExpressionType NotEqual;
    public static ExpressionType Or;
    public static ExpressionType OrElse;
    public static ExpressionType Parameter;
    public static ExpressionType Power;
    public static ExpressionType Quote;
    public static ExpressionType RightShift;
    public static ExpressionType Subtract;
    public static ExpressionType SubtractChecked;
    public static ExpressionType TypeAs;
    public static ExpressionType TypeIs;
    public static ExpressionType Assign;
    public static ExpressionType Block;
    public static ExpressionType DebugInfo;
    public static ExpressionType Decrement;
    public static ExpressionType Dynamic;
    public static ExpressionType Default;
    public static ExpressionType Extension;
    public static ExpressionType Goto;
    public static ExpressionType Increment;
    public static ExpressionType Index;
    public static ExpressionType Label;
    public static ExpressionType RuntimeVariables;
    public static ExpressionType Loop;
    public static ExpressionType Switch;
    public static ExpressionType Throw;
    public static ExpressionType Try;
    public static ExpressionType Unbox;
    public static ExpressionType AddAssign;
    public static ExpressionType AndAssign;
    public static ExpressionType DivideAssign;
    public static ExpressionType ExclusiveOrAssign;
    public static ExpressionType LeftShiftAssign;
    public static ExpressionType ModuloAssign;
    public static ExpressionType MultiplyAssign;
    public static ExpressionType OrAssign;
    public static ExpressionType PowerAssign;
    public static ExpressionType RightShiftAssign;
    public static ExpressionType SubtractAssign;
    public static ExpressionType AddAssignChecked;
    public static ExpressionType MultiplyAssignChecked;
    public static ExpressionType SubtractAssignChecked;
    public static ExpressionType PreIncrementAssign;
    public static ExpressionType PreDecrementAssign;
    public static ExpressionType PostIncrementAssign;
    public static ExpressionType PostDecrementAssign;
    public static ExpressionType TypeEqual;
    public static ExpressionType OnesComplement;
    public static ExpressionType IsTrue;
    public static ExpressionType IsFalse;
}
public abstract class System.Linq.Expressions.ExpressionVisitor : object {
    public virtual Expression Visit(Expression node);
    public ReadOnlyCollection`1<Expression> Visit(ReadOnlyCollection`1<Expression> nodes);
    private Expression[] VisitArguments(IArgumentProvider nodes);
    private ParameterExpression[] VisitParameters(IParameterProvider nodes, string callerName);
    public static ReadOnlyCollection`1<T> Visit(ReadOnlyCollection`1<T> nodes, Func`2<T, T> elementVisitor);
    public T VisitAndConvert(T node, string callerName);
    public ReadOnlyCollection`1<T> VisitAndConvert(ReadOnlyCollection`1<T> nodes, string callerName);
    protected internal virtual Expression VisitBinary(BinaryExpression node);
    protected internal virtual Expression VisitBlock(BlockExpression node);
    protected internal virtual Expression VisitConditional(ConditionalExpression node);
    protected internal virtual Expression VisitConstant(ConstantExpression node);
    protected internal virtual Expression VisitDebugInfo(DebugInfoExpression node);
    protected internal virtual Expression VisitDefault(DefaultExpression node);
    protected internal virtual Expression VisitExtension(Expression node);
    protected internal virtual Expression VisitGoto(GotoExpression node);
    protected internal virtual Expression VisitInvocation(InvocationExpression node);
    protected virtual LabelTarget VisitLabelTarget(LabelTarget node);
    protected internal virtual Expression VisitLabel(LabelExpression node);
    protected internal virtual Expression VisitLambda(Expression`1<T> node);
    protected internal virtual Expression VisitLoop(LoopExpression node);
    protected internal virtual Expression VisitMember(MemberExpression node);
    protected internal virtual Expression VisitIndex(IndexExpression node);
    protected internal virtual Expression VisitMethodCall(MethodCallExpression node);
    protected internal virtual Expression VisitNewArray(NewArrayExpression node);
    protected internal virtual Expression VisitNew(NewExpression node);
    protected internal virtual Expression VisitParameter(ParameterExpression node);
    protected internal virtual Expression VisitRuntimeVariables(RuntimeVariablesExpression node);
    protected virtual SwitchCase VisitSwitchCase(SwitchCase node);
    protected internal virtual Expression VisitSwitch(SwitchExpression node);
    protected virtual CatchBlock VisitCatchBlock(CatchBlock node);
    protected internal virtual Expression VisitTry(TryExpression node);
    protected internal virtual Expression VisitTypeBinary(TypeBinaryExpression node);
    protected internal virtual Expression VisitUnary(UnaryExpression node);
    protected internal virtual Expression VisitMemberInit(MemberInitExpression node);
    protected internal virtual Expression VisitListInit(ListInitExpression node);
    protected virtual ElementInit VisitElementInit(ElementInit node);
    protected virtual MemberBinding VisitMemberBinding(MemberBinding node);
    protected virtual MemberAssignment VisitMemberAssignment(MemberAssignment node);
    protected virtual MemberMemberBinding VisitMemberMemberBinding(MemberMemberBinding node);
    protected virtual MemberListBinding VisitMemberListBinding(MemberListBinding node);
    private static UnaryExpression ValidateUnary(UnaryExpression before, UnaryExpression after);
    private static BinaryExpression ValidateBinary(BinaryExpression before, BinaryExpression after);
    private static SwitchExpression ValidateSwitch(SwitchExpression before, SwitchExpression after);
    private static void ValidateChildType(Type before, Type after, string methodName);
    protected internal virtual Expression VisitDynamic(DynamicExpression node);
}
internal class System.Linq.Expressions.FieldExpression : MemberExpression {
    private FieldInfo _field;
    public Type Type { get; }
    public FieldExpression(Expression expression, FieldInfo member);
    internal virtual MemberInfo GetMember();
    public sealed virtual Type get_Type();
}
internal class System.Linq.Expressions.FullConditionalExpression : ConditionalExpression {
    private Expression _false;
    internal FullConditionalExpression(Expression test, Expression ifTrue, Expression ifFalse);
    internal virtual Expression GetFalse();
}
internal class System.Linq.Expressions.FullConditionalExpressionWithType : FullConditionalExpression {
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    public Type Type { get; }
    internal FullConditionalExpressionWithType(Expression test, Expression ifTrue, Expression ifFalse, Type type);
    [CompilerGeneratedAttribute]
public sealed virtual Type get_Type();
}
internal class System.Linq.Expressions.FullExpression`1 : ExpressionN`1<TDelegate> {
    [CompilerGeneratedAttribute]
private string <NameCore>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <TailCallCore>k__BackingField;
    internal string NameCore { get; }
    internal bool TailCallCore { get; }
    public FullExpression`1(Expression body, string name, bool tailCall, IReadOnlyList`1<ParameterExpression> parameters);
    [CompilerGeneratedAttribute]
internal virtual string get_NameCore();
    [CompilerGeneratedAttribute]
internal virtual bool get_TailCallCore();
}
[DebuggerTypeProxyAttribute("System.Linq.Expressions.Expression/GotoExpressionProxy")]
public class System.Linq.Expressions.GotoExpression : Expression {
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private Expression <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private LabelTarget <Target>k__BackingField;
    [CompilerGeneratedAttribute]
private GotoExpressionKind <Kind>k__BackingField;
    public Type Type { get; }
    public ExpressionType NodeType { get; }
    public Expression Value { get; }
    public LabelTarget Target { get; }
    public GotoExpressionKind Kind { get; }
    internal GotoExpression(GotoExpressionKind kind, LabelTarget target, Expression value, Type type);
    [CompilerGeneratedAttribute]
public sealed virtual Type get_Type();
    public sealed virtual ExpressionType get_NodeType();
    [CompilerGeneratedAttribute]
public Expression get_Value();
    [CompilerGeneratedAttribute]
public LabelTarget get_Target();
    [CompilerGeneratedAttribute]
public GotoExpressionKind get_Kind();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
    public GotoExpression Update(LabelTarget target, Expression value);
}
public enum System.Linq.Expressions.GotoExpressionKind : Enum {
    public int value__;
    public static GotoExpressionKind Goto;
    public static GotoExpressionKind Return;
    public static GotoExpressionKind Break;
    public static GotoExpressionKind Continue;
}
public interface System.Linq.Expressions.IArgumentProvider {
    public int ArgumentCount { get; }
    public abstract virtual Expression GetArgument(int index);
    public abstract virtual int get_ArgumentCount();
}
public interface System.Linq.Expressions.IDynamicExpression {
    public Type DelegateType { get; }
    public abstract virtual Type get_DelegateType();
    public abstract virtual Expression Rewrite(Expression[] args);
    public abstract virtual object CreateCallSite();
}
[DebuggerTypeProxyAttribute("System.Linq.Expressions.Expression/IndexExpressionProxy")]
public class System.Linq.Expressions.IndexExpression : Expression {
    private IReadOnlyList`1<Expression> _arguments;
    [CompilerGeneratedAttribute]
private Expression <Object>k__BackingField;
    [CompilerGeneratedAttribute]
private PropertyInfo <Indexer>k__BackingField;
    public ExpressionType NodeType { get; }
    public Type Type { get; }
    public Expression Object { get; }
    public PropertyInfo Indexer { get; }
    public ReadOnlyCollection`1<Expression> Arguments { get; }
    public int ArgumentCount { get; }
    internal IndexExpression(Expression instance, PropertyInfo indexer, IReadOnlyList`1<Expression> arguments);
    public sealed virtual ExpressionType get_NodeType();
    public sealed virtual Type get_Type();
    [CompilerGeneratedAttribute]
public Expression get_Object();
    [CompilerGeneratedAttribute]
public PropertyInfo get_Indexer();
    public ReadOnlyCollection`1<Expression> get_Arguments();
    public IndexExpression Update(Expression object, IEnumerable`1<Expression> arguments);
    public sealed virtual Expression GetArgument(int index);
    public sealed virtual int get_ArgumentCount();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
    internal Expression Rewrite(Expression instance, Expression[] arguments);
}
internal class System.Linq.Expressions.InstanceMethodCallExpression : MethodCallExpression {
    private Expression _instance;
    public InstanceMethodCallExpression(MethodInfo method, Expression instance);
    internal virtual Expression GetInstance();
}
internal class System.Linq.Expressions.InstanceMethodCallExpression0 : InstanceMethodCallExpression {
    public int ArgumentCount { get; }
    public InstanceMethodCallExpression0(MethodInfo method, Expression instance);
    public virtual Expression GetArgument(int index);
    public virtual int get_ArgumentCount();
    internal virtual ReadOnlyCollection`1<Expression> GetOrMakeArguments();
    internal virtual bool SameArguments(ICollection`1<Expression> arguments);
    internal virtual MethodCallExpression Rewrite(Expression instance, IReadOnlyList`1<Expression> args);
}
internal class System.Linq.Expressions.InstanceMethodCallExpression1 : InstanceMethodCallExpression {
    private object _arg0;
    public int ArgumentCount { get; }
    public InstanceMethodCallExpression1(MethodInfo method, Expression instance, Expression arg0);
    public virtual Expression GetArgument(int index);
    public virtual int get_ArgumentCount();
    internal virtual bool SameArguments(ICollection`1<Expression> arguments);
    internal virtual ReadOnlyCollection`1<Expression> GetOrMakeArguments();
    internal virtual MethodCallExpression Rewrite(Expression instance, IReadOnlyList`1<Expression> args);
}
internal class System.Linq.Expressions.InstanceMethodCallExpression2 : InstanceMethodCallExpression {
    private object _arg0;
    private Expression _arg1;
    public int ArgumentCount { get; }
    public InstanceMethodCallExpression2(MethodInfo method, Expression instance, Expression arg0, Expression arg1);
    public virtual Expression GetArgument(int index);
    public virtual int get_ArgumentCount();
    internal virtual bool SameArguments(ICollection`1<Expression> arguments);
    internal virtual ReadOnlyCollection`1<Expression> GetOrMakeArguments();
    internal virtual MethodCallExpression Rewrite(Expression instance, IReadOnlyList`1<Expression> args);
}
internal class System.Linq.Expressions.InstanceMethodCallExpression3 : InstanceMethodCallExpression {
    private object _arg0;
    private Expression _arg1;
    private Expression _arg2;
    public int ArgumentCount { get; }
    public InstanceMethodCallExpression3(MethodInfo method, Expression instance, Expression arg0, Expression arg1, Expression arg2);
    public virtual Expression GetArgument(int index);
    public virtual int get_ArgumentCount();
    internal virtual bool SameArguments(ICollection`1<Expression> arguments);
    internal virtual ReadOnlyCollection`1<Expression> GetOrMakeArguments();
    internal virtual MethodCallExpression Rewrite(Expression instance, IReadOnlyList`1<Expression> args);
}
internal class System.Linq.Expressions.InstanceMethodCallExpressionN : InstanceMethodCallExpression {
    private IReadOnlyList`1<Expression> _arguments;
    public int ArgumentCount { get; }
    public InstanceMethodCallExpressionN(MethodInfo method, Expression instance, IReadOnlyList`1<Expression> args);
    public virtual Expression GetArgument(int index);
    public virtual int get_ArgumentCount();
    internal virtual bool SameArguments(ICollection`1<Expression> arguments);
    internal virtual ReadOnlyCollection`1<Expression> GetOrMakeArguments();
    internal virtual MethodCallExpression Rewrite(Expression instance, IReadOnlyList`1<Expression> args);
}
[DebuggerTypeProxyAttribute("System.Linq.Expressions.Expression/InvocationExpressionProxy")]
public class System.Linq.Expressions.InvocationExpression : Expression {
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private Expression <Expression>k__BackingField;
    public Type Type { get; }
    public ExpressionType NodeType { get; }
    public Expression Expression { get; }
    public ReadOnlyCollection`1<Expression> Arguments { get; }
    [ExcludeFromCodeCoverageAttribute]
public int ArgumentCount { get; }
    internal LambdaExpression LambdaOperand { get; }
    internal InvocationExpression(Expression expression, Type returnType);
    [CompilerGeneratedAttribute]
public sealed virtual Type get_Type();
    public sealed virtual ExpressionType get_NodeType();
    [CompilerGeneratedAttribute]
public Expression get_Expression();
    public ReadOnlyCollection`1<Expression> get_Arguments();
    public InvocationExpression Update(Expression expression, IEnumerable`1<Expression> arguments);
    [ExcludeFromCodeCoverageAttribute]
internal virtual ReadOnlyCollection`1<Expression> GetOrMakeArguments();
    [ExcludeFromCodeCoverageAttribute]
public virtual Expression GetArgument(int index);
    public virtual int get_ArgumentCount();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
    [ExcludeFromCodeCoverageAttribute]
internal virtual InvocationExpression Rewrite(Expression lambda, Expression[] arguments);
    internal LambdaExpression get_LambdaOperand();
}
internal class System.Linq.Expressions.InvocationExpression0 : InvocationExpression {
    public int ArgumentCount { get; }
    public InvocationExpression0(Expression lambda, Type returnType);
    internal virtual ReadOnlyCollection`1<Expression> GetOrMakeArguments();
    public virtual Expression GetArgument(int index);
    public virtual int get_ArgumentCount();
    internal virtual InvocationExpression Rewrite(Expression lambda, Expression[] arguments);
}
internal class System.Linq.Expressions.InvocationExpression1 : InvocationExpression {
    private object _arg0;
    public int ArgumentCount { get; }
    public InvocationExpression1(Expression lambda, Type returnType, Expression arg0);
    internal virtual ReadOnlyCollection`1<Expression> GetOrMakeArguments();
    public virtual Expression GetArgument(int index);
    public virtual int get_ArgumentCount();
    internal virtual InvocationExpression Rewrite(Expression lambda, Expression[] arguments);
}
internal class System.Linq.Expressions.InvocationExpression2 : InvocationExpression {
    private object _arg0;
    private Expression _arg1;
    public int ArgumentCount { get; }
    public InvocationExpression2(Expression lambda, Type returnType, Expression arg0, Expression arg1);
    internal virtual ReadOnlyCollection`1<Expression> GetOrMakeArguments();
    public virtual Expression GetArgument(int index);
    public virtual int get_ArgumentCount();
    internal virtual InvocationExpression Rewrite(Expression lambda, Expression[] arguments);
}
internal class System.Linq.Expressions.InvocationExpression3 : InvocationExpression {
    private object _arg0;
    private Expression _arg1;
    private Expression _arg2;
    public int ArgumentCount { get; }
    public InvocationExpression3(Expression lambda, Type returnType, Expression arg0, Expression arg1, Expression arg2);
    internal virtual ReadOnlyCollection`1<Expression> GetOrMakeArguments();
    public virtual Expression GetArgument(int index);
    public virtual int get_ArgumentCount();
    internal virtual InvocationExpression Rewrite(Expression lambda, Expression[] arguments);
}
internal class System.Linq.Expressions.InvocationExpression4 : InvocationExpression {
    private object _arg0;
    private Expression _arg1;
    private Expression _arg2;
    private Expression _arg3;
    public int ArgumentCount { get; }
    public InvocationExpression4(Expression lambda, Type returnType, Expression arg0, Expression arg1, Expression arg2, Expression arg3);
    internal virtual ReadOnlyCollection`1<Expression> GetOrMakeArguments();
    public virtual Expression GetArgument(int index);
    public virtual int get_ArgumentCount();
    internal virtual InvocationExpression Rewrite(Expression lambda, Expression[] arguments);
}
internal class System.Linq.Expressions.InvocationExpression5 : InvocationExpression {
    private object _arg0;
    private Expression _arg1;
    private Expression _arg2;
    private Expression _arg3;
    private Expression _arg4;
    public int ArgumentCount { get; }
    public InvocationExpression5(Expression lambda, Type returnType, Expression arg0, Expression arg1, Expression arg2, Expression arg3, Expression arg4);
    internal virtual ReadOnlyCollection`1<Expression> GetOrMakeArguments();
    public virtual Expression GetArgument(int index);
    public virtual int get_ArgumentCount();
    internal virtual InvocationExpression Rewrite(Expression lambda, Expression[] arguments);
}
internal class System.Linq.Expressions.InvocationExpressionN : InvocationExpression {
    private IReadOnlyList`1<Expression> _arguments;
    public int ArgumentCount { get; }
    public InvocationExpressionN(Expression lambda, IReadOnlyList`1<Expression> arguments, Type returnType);
    internal virtual ReadOnlyCollection`1<Expression> GetOrMakeArguments();
    public virtual Expression GetArgument(int index);
    public virtual int get_ArgumentCount();
    internal virtual InvocationExpression Rewrite(Expression lambda, Expression[] arguments);
}
internal interface System.Linq.Expressions.IParameterProvider {
    public int ParameterCount { get; }
    public abstract virtual ParameterExpression GetParameter(int index);
    public abstract virtual int get_ParameterCount();
}
[DebuggerTypeProxyAttribute("System.Linq.Expressions.Expression/LabelExpressionProxy")]
public class System.Linq.Expressions.LabelExpression : Expression {
    [CompilerGeneratedAttribute]
private LabelTarget <Target>k__BackingField;
    [CompilerGeneratedAttribute]
private Expression <DefaultValue>k__BackingField;
    public Type Type { get; }
    public ExpressionType NodeType { get; }
    public LabelTarget Target { get; }
    public Expression DefaultValue { get; }
    internal LabelExpression(LabelTarget label, Expression defaultValue);
    public sealed virtual Type get_Type();
    public sealed virtual ExpressionType get_NodeType();
    [CompilerGeneratedAttribute]
public LabelTarget get_Target();
    [CompilerGeneratedAttribute]
public Expression get_DefaultValue();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
    public LabelExpression Update(LabelTarget target, Expression defaultValue);
}
public class System.Linq.Expressions.LabelTarget : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    public string Name { get; }
    public Type Type { get; }
    internal LabelTarget(Type type, string name);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public Type get_Type();
    public virtual string ToString();
}
[DebuggerTypeProxyAttribute("System.Linq.Expressions.Expression/LambdaExpressionProxy")]
public abstract class System.Linq.Expressions.LambdaExpression : Expression {
    private Expression _body;
    public Type Type { get; }
    internal Type TypeCore { get; }
    internal Type PublicType { get; }
    public ExpressionType NodeType { get; }
    public ReadOnlyCollection`1<ParameterExpression> Parameters { get; }
    public string Name { get; }
    internal string NameCore { get; }
    public Expression Body { get; }
    public Type ReturnType { get; }
    public bool TailCall { get; }
    internal bool TailCallCore { get; }
    [ExcludeFromCodeCoverageAttribute]
private int System.Linq.Expressions.IParameterProvider.ParameterCount { get; }
    [ExcludeFromCodeCoverageAttribute]
internal int ParameterCount { get; }
    internal LambdaExpression(Expression body);
    public sealed virtual Type get_Type();
    internal abstract virtual Type get_TypeCore();
    internal abstract virtual Type get_PublicType();
    public sealed virtual ExpressionType get_NodeType();
    public ReadOnlyCollection`1<ParameterExpression> get_Parameters();
    public string get_Name();
    internal virtual string get_NameCore();
    public Expression get_Body();
    public Type get_ReturnType();
    public bool get_TailCall();
    internal virtual bool get_TailCallCore();
    [ExcludeFromCodeCoverageAttribute]
internal virtual ReadOnlyCollection`1<ParameterExpression> GetOrMakeParameters();
    [ExcludeFromCodeCoverageAttribute]
private sealed virtual override ParameterExpression System.Linq.Expressions.IParameterProvider.GetParameter(int index);
    [ExcludeFromCodeCoverageAttribute]
internal virtual ParameterExpression GetParameter(int index);
    private sealed virtual override int System.Linq.Expressions.IParameterProvider.get_ParameterCount();
    internal virtual int get_ParameterCount();
    public Delegate Compile();
    public Delegate Compile(bool preferInterpretation);
    public void CompileToMethod(MethodBuilder method);
    internal abstract virtual LambdaExpression Accept(StackSpiller spiller);
    public Delegate Compile(DebugInfoGenerator debugInfoGenerator);
    public void CompileToMethod(MethodBuilder method, DebugInfoGenerator debugInfoGenerator);
}
[DebuggerTypeProxyAttribute("System.Linq.Expressions.Expression/ListInitExpressionProxy")]
public class System.Linq.Expressions.ListInitExpression : Expression {
    [CompilerGeneratedAttribute]
private NewExpression <NewExpression>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadOnlyCollection`1<ElementInit> <Initializers>k__BackingField;
    public ExpressionType NodeType { get; }
    public Type Type { get; }
    public bool CanReduce { get; }
    public NewExpression NewExpression { get; }
    public ReadOnlyCollection`1<ElementInit> Initializers { get; }
    internal ListInitExpression(NewExpression newExpression, ReadOnlyCollection`1<ElementInit> initializers);
    public sealed virtual ExpressionType get_NodeType();
    public sealed virtual Type get_Type();
    public virtual bool get_CanReduce();
    [CompilerGeneratedAttribute]
public NewExpression get_NewExpression();
    [CompilerGeneratedAttribute]
public ReadOnlyCollection`1<ElementInit> get_Initializers();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
    public virtual Expression Reduce();
    public ListInitExpression Update(NewExpression newExpression, IEnumerable`1<ElementInit> initializers);
}
internal class System.Linq.Expressions.LogicalBinaryExpression : BinaryExpression {
    [CompilerGeneratedAttribute]
private ExpressionType <NodeType>k__BackingField;
    public Type Type { get; }
    public ExpressionType NodeType { get; }
    internal LogicalBinaryExpression(ExpressionType nodeType, Expression left, Expression right);
    public sealed virtual Type get_Type();
    [CompilerGeneratedAttribute]
public sealed virtual ExpressionType get_NodeType();
}
[DebuggerTypeProxyAttribute("System.Linq.Expressions.Expression/LoopExpressionProxy")]
public class System.Linq.Expressions.LoopExpression : Expression {
    [CompilerGeneratedAttribute]
private Expression <Body>k__BackingField;
    [CompilerGeneratedAttribute]
private LabelTarget <BreakLabel>k__BackingField;
    [CompilerGeneratedAttribute]
private LabelTarget <ContinueLabel>k__BackingField;
    public Type Type { get; }
    public ExpressionType NodeType { get; }
    public Expression Body { get; }
    public LabelTarget BreakLabel { get; }
    public LabelTarget ContinueLabel { get; }
    internal LoopExpression(Expression body, LabelTarget break, LabelTarget continue);
    public sealed virtual Type get_Type();
    public sealed virtual ExpressionType get_NodeType();
    [CompilerGeneratedAttribute]
public Expression get_Body();
    [CompilerGeneratedAttribute]
public LabelTarget get_BreakLabel();
    [CompilerGeneratedAttribute]
public LabelTarget get_ContinueLabel();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
    public LoopExpression Update(LabelTarget breakLabel, LabelTarget continueLabel, Expression body);
}
public class System.Linq.Expressions.MemberAssignment : MemberBinding {
    private Expression _expression;
    public Expression Expression { get; }
    internal MemberAssignment(MemberInfo member, Expression expression);
    public Expression get_Expression();
    public MemberAssignment Update(Expression expression);
    internal virtual void ValidateAsDefinedHere(int index);
}
public abstract class System.Linq.Expressions.MemberBinding : object {
    [CompilerGeneratedAttribute]
private MemberBindingType <BindingType>k__BackingField;
    [CompilerGeneratedAttribute]
private MemberInfo <Member>k__BackingField;
    public MemberBindingType BindingType { get; }
    public MemberInfo Member { get; }
    [ObsoleteAttribute("Do not use this constructor. It will be removed in future releases.")]
protected MemberBinding(MemberBindingType type, MemberInfo member);
    [CompilerGeneratedAttribute]
public MemberBindingType get_BindingType();
    [CompilerGeneratedAttribute]
public MemberInfo get_Member();
    public virtual string ToString();
    internal virtual void ValidateAsDefinedHere(int index);
}
public enum System.Linq.Expressions.MemberBindingType : Enum {
    public int value__;
    public static MemberBindingType Assignment;
    public static MemberBindingType MemberBinding;
    public static MemberBindingType ListBinding;
}
[DebuggerTypeProxyAttribute("System.Linq.Expressions.Expression/MemberExpressionProxy")]
public class System.Linq.Expressions.MemberExpression : Expression {
    [CompilerGeneratedAttribute]
private Expression <Expression>k__BackingField;
    public MemberInfo Member { get; }
    public Expression Expression { get; }
    public ExpressionType NodeType { get; }
    internal MemberExpression(Expression expression);
    public MemberInfo get_Member();
    [CompilerGeneratedAttribute]
public Expression get_Expression();
    internal static PropertyExpression Make(Expression expression, PropertyInfo property);
    internal static FieldExpression Make(Expression expression, FieldInfo field);
    internal static MemberExpression Make(Expression expression, MemberInfo member);
    public sealed virtual ExpressionType get_NodeType();
    [ExcludeFromCodeCoverageAttribute]
internal virtual MemberInfo GetMember();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
    public MemberExpression Update(Expression expression);
}
[DebuggerTypeProxyAttribute("System.Linq.Expressions.Expression/MemberInitExpressionProxy")]
public class System.Linq.Expressions.MemberInitExpression : Expression {
    [CompilerGeneratedAttribute]
private NewExpression <NewExpression>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadOnlyCollection`1<MemberBinding> <Bindings>k__BackingField;
    public Type Type { get; }
    public bool CanReduce { get; }
    public ExpressionType NodeType { get; }
    public NewExpression NewExpression { get; }
    public ReadOnlyCollection`1<MemberBinding> Bindings { get; }
    internal MemberInitExpression(NewExpression newExpression, ReadOnlyCollection`1<MemberBinding> bindings);
    public sealed virtual Type get_Type();
    public virtual bool get_CanReduce();
    public sealed virtual ExpressionType get_NodeType();
    [CompilerGeneratedAttribute]
public NewExpression get_NewExpression();
    [CompilerGeneratedAttribute]
public ReadOnlyCollection`1<MemberBinding> get_Bindings();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
    public virtual Expression Reduce();
    private static Expression ReduceMemberInit(Expression objExpression, ReadOnlyCollection`1<MemberBinding> bindings, bool keepOnStack);
    internal static Expression ReduceListInit(Expression listExpression, ReadOnlyCollection`1<ElementInit> initializers, bool keepOnStack);
    internal static Expression ReduceMemberBinding(ParameterExpression objVar, MemberBinding binding);
    public MemberInitExpression Update(NewExpression newExpression, IEnumerable`1<MemberBinding> bindings);
}
public class System.Linq.Expressions.MemberListBinding : MemberBinding {
    [CompilerGeneratedAttribute]
private ReadOnlyCollection`1<ElementInit> <Initializers>k__BackingField;
    public ReadOnlyCollection`1<ElementInit> Initializers { get; }
    internal MemberListBinding(MemberInfo member, ReadOnlyCollection`1<ElementInit> initializers);
    [CompilerGeneratedAttribute]
public ReadOnlyCollection`1<ElementInit> get_Initializers();
    public MemberListBinding Update(IEnumerable`1<ElementInit> initializers);
    internal virtual void ValidateAsDefinedHere(int index);
}
public class System.Linq.Expressions.MemberMemberBinding : MemberBinding {
    [CompilerGeneratedAttribute]
private ReadOnlyCollection`1<MemberBinding> <Bindings>k__BackingField;
    public ReadOnlyCollection`1<MemberBinding> Bindings { get; }
    internal MemberMemberBinding(MemberInfo member, ReadOnlyCollection`1<MemberBinding> bindings);
    [CompilerGeneratedAttribute]
public ReadOnlyCollection`1<MemberBinding> get_Bindings();
    public MemberMemberBinding Update(IEnumerable`1<MemberBinding> bindings);
    internal virtual void ValidateAsDefinedHere(int index);
}
internal class System.Linq.Expressions.MethodBinaryExpression : SimpleBinaryExpression {
    private MethodInfo _method;
    internal MethodBinaryExpression(ExpressionType nodeType, Expression left, Expression right, Type type, MethodInfo method);
    internal virtual MethodInfo GetMethod();
}
[DebuggerTypeProxyAttribute("System.Linq.Expressions.Expression/MethodCallExpressionProxy")]
public class System.Linq.Expressions.MethodCallExpression : Expression {
    [CompilerGeneratedAttribute]
private MethodInfo <Method>k__BackingField;
    public ExpressionType NodeType { get; }
    public Type Type { get; }
    public MethodInfo Method { get; }
    public Expression Object { get; }
    public ReadOnlyCollection`1<Expression> Arguments { get; }
    [ExcludeFromCodeCoverageAttribute]
public int ArgumentCount { get; }
    internal MethodCallExpression(MethodInfo method);
    internal virtual Expression GetInstance();
    public sealed virtual ExpressionType get_NodeType();
    public sealed virtual Type get_Type();
    [CompilerGeneratedAttribute]
public MethodInfo get_Method();
    public Expression get_Object();
    public ReadOnlyCollection`1<Expression> get_Arguments();
    public MethodCallExpression Update(Expression object, IEnumerable`1<Expression> arguments);
    [ExcludeFromCodeCoverageAttribute]
internal virtual bool SameArguments(ICollection`1<Expression> arguments);
    [ExcludeFromCodeCoverageAttribute]
internal virtual ReadOnlyCollection`1<Expression> GetOrMakeArguments();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
    [ExcludeFromCodeCoverageAttribute]
internal virtual MethodCallExpression Rewrite(Expression instance, IReadOnlyList`1<Expression> args);
    [ExcludeFromCodeCoverageAttribute]
public virtual Expression GetArgument(int index);
    public virtual int get_ArgumentCount();
}
internal class System.Linq.Expressions.MethodCallExpression0 : MethodCallExpression {
    public int ArgumentCount { get; }
    public MethodCallExpression0(MethodInfo method);
    public virtual Expression GetArgument(int index);
    public virtual int get_ArgumentCount();
    internal virtual ReadOnlyCollection`1<Expression> GetOrMakeArguments();
    internal virtual bool SameArguments(ICollection`1<Expression> arguments);
    internal virtual MethodCallExpression Rewrite(Expression instance, IReadOnlyList`1<Expression> args);
}
internal class System.Linq.Expressions.MethodCallExpression1 : MethodCallExpression {
    private object _arg0;
    public int ArgumentCount { get; }
    public MethodCallExpression1(MethodInfo method, Expression arg0);
    public virtual Expression GetArgument(int index);
    public virtual int get_ArgumentCount();
    internal virtual ReadOnlyCollection`1<Expression> GetOrMakeArguments();
    internal virtual bool SameArguments(ICollection`1<Expression> arguments);
    internal virtual MethodCallExpression Rewrite(Expression instance, IReadOnlyList`1<Expression> args);
}
internal class System.Linq.Expressions.MethodCallExpression2 : MethodCallExpression {
    private object _arg0;
    private Expression _arg1;
    public int ArgumentCount { get; }
    public MethodCallExpression2(MethodInfo method, Expression arg0, Expression arg1);
    public virtual Expression GetArgument(int index);
    public virtual int get_ArgumentCount();
    internal virtual bool SameArguments(ICollection`1<Expression> arguments);
    internal virtual ReadOnlyCollection`1<Expression> GetOrMakeArguments();
    internal virtual MethodCallExpression Rewrite(Expression instance, IReadOnlyList`1<Expression> args);
}
internal class System.Linq.Expressions.MethodCallExpression3 : MethodCallExpression {
    private object _arg0;
    private Expression _arg1;
    private Expression _arg2;
    public int ArgumentCount { get; }
    public MethodCallExpression3(MethodInfo method, Expression arg0, Expression arg1, Expression arg2);
    public virtual Expression GetArgument(int index);
    public virtual int get_ArgumentCount();
    internal virtual bool SameArguments(ICollection`1<Expression> arguments);
    internal virtual ReadOnlyCollection`1<Expression> GetOrMakeArguments();
    internal virtual MethodCallExpression Rewrite(Expression instance, IReadOnlyList`1<Expression> args);
}
internal class System.Linq.Expressions.MethodCallExpression4 : MethodCallExpression {
    private object _arg0;
    private Expression _arg1;
    private Expression _arg2;
    private Expression _arg3;
    public int ArgumentCount { get; }
    public MethodCallExpression4(MethodInfo method, Expression arg0, Expression arg1, Expression arg2, Expression arg3);
    public virtual Expression GetArgument(int index);
    public virtual int get_ArgumentCount();
    internal virtual bool SameArguments(ICollection`1<Expression> arguments);
    internal virtual ReadOnlyCollection`1<Expression> GetOrMakeArguments();
    internal virtual MethodCallExpression Rewrite(Expression instance, IReadOnlyList`1<Expression> args);
}
internal class System.Linq.Expressions.MethodCallExpression5 : MethodCallExpression {
    private object _arg0;
    private Expression _arg1;
    private Expression _arg2;
    private Expression _arg3;
    private Expression _arg4;
    public int ArgumentCount { get; }
    public MethodCallExpression5(MethodInfo method, Expression arg0, Expression arg1, Expression arg2, Expression arg3, Expression arg4);
    public virtual Expression GetArgument(int index);
    public virtual int get_ArgumentCount();
    internal virtual bool SameArguments(ICollection`1<Expression> arguments);
    internal virtual ReadOnlyCollection`1<Expression> GetOrMakeArguments();
    internal virtual MethodCallExpression Rewrite(Expression instance, IReadOnlyList`1<Expression> args);
}
internal class System.Linq.Expressions.MethodCallExpressionN : MethodCallExpression {
    private IReadOnlyList`1<Expression> _arguments;
    public int ArgumentCount { get; }
    public MethodCallExpressionN(MethodInfo method, IReadOnlyList`1<Expression> args);
    public virtual Expression GetArgument(int index);
    public virtual int get_ArgumentCount();
    internal virtual ReadOnlyCollection`1<Expression> GetOrMakeArguments();
    internal virtual bool SameArguments(ICollection`1<Expression> arguments);
    internal virtual MethodCallExpression Rewrite(Expression instance, IReadOnlyList`1<Expression> args);
}
internal class System.Linq.Expressions.NewArrayBoundsExpression : NewArrayExpression {
    public ExpressionType NodeType { get; }
    internal NewArrayBoundsExpression(Type type, ReadOnlyCollection`1<Expression> expressions);
    public sealed virtual ExpressionType get_NodeType();
}
[DebuggerTypeProxyAttribute("System.Linq.Expressions.Expression/NewArrayExpressionProxy")]
public class System.Linq.Expressions.NewArrayExpression : Expression {
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadOnlyCollection`1<Expression> <Expressions>k__BackingField;
    public Type Type { get; }
    public ReadOnlyCollection`1<Expression> Expressions { get; }
    internal NewArrayExpression(Type type, ReadOnlyCollection`1<Expression> expressions);
    internal static NewArrayExpression Make(ExpressionType nodeType, Type type, ReadOnlyCollection`1<Expression> expressions);
    [CompilerGeneratedAttribute]
public sealed virtual Type get_Type();
    [CompilerGeneratedAttribute]
public ReadOnlyCollection`1<Expression> get_Expressions();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
    public NewArrayExpression Update(IEnumerable`1<Expression> expressions);
}
internal class System.Linq.Expressions.NewArrayInitExpression : NewArrayExpression {
    public ExpressionType NodeType { get; }
    internal NewArrayInitExpression(Type type, ReadOnlyCollection`1<Expression> expressions);
    public sealed virtual ExpressionType get_NodeType();
}
[DebuggerTypeProxyAttribute("System.Linq.Expressions.Expression/NewExpressionProxy")]
public class System.Linq.Expressions.NewExpression : Expression {
    private IReadOnlyList`1<Expression> _arguments;
    [CompilerGeneratedAttribute]
private ConstructorInfo <Constructor>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadOnlyCollection`1<MemberInfo> <Members>k__BackingField;
    public Type Type { get; }
    public ExpressionType NodeType { get; }
    public ConstructorInfo Constructor { get; }
    public ReadOnlyCollection`1<Expression> Arguments { get; }
    public int ArgumentCount { get; }
    public ReadOnlyCollection`1<MemberInfo> Members { get; }
    internal NewExpression(ConstructorInfo constructor, IReadOnlyList`1<Expression> arguments, ReadOnlyCollection`1<MemberInfo> members);
    public virtual Type get_Type();
    public sealed virtual ExpressionType get_NodeType();
    [CompilerGeneratedAttribute]
public ConstructorInfo get_Constructor();
    public ReadOnlyCollection`1<Expression> get_Arguments();
    public sealed virtual Expression GetArgument(int index);
    public sealed virtual int get_ArgumentCount();
    [CompilerGeneratedAttribute]
public ReadOnlyCollection`1<MemberInfo> get_Members();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
    public NewExpression Update(IEnumerable`1<Expression> arguments);
}
internal class System.Linq.Expressions.NewValueTypeExpression : NewExpression {
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    public Type Type { get; }
    internal NewValueTypeExpression(Type type, ReadOnlyCollection`1<Expression> arguments, ReadOnlyCollection`1<MemberInfo> members);
    [CompilerGeneratedAttribute]
public sealed virtual Type get_Type();
}
internal class System.Linq.Expressions.OpAssignMethodConversionBinaryExpression : MethodBinaryExpression {
    private LambdaExpression _conversion;
    internal OpAssignMethodConversionBinaryExpression(ExpressionType nodeType, Expression left, Expression right, Type type, MethodInfo method, LambdaExpression conversion);
    internal virtual LambdaExpression GetConversion();
}
[DebuggerTypeProxyAttribute("System.Linq.Expressions.Expression/ParameterExpressionProxy")]
public class System.Linq.Expressions.ParameterExpression : Expression {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public Type Type { get; }
    public ExpressionType NodeType { get; }
    public string Name { get; }
    public bool IsByRef { get; }
    internal ParameterExpression(string name);
    internal static ParameterExpression Make(Type type, string name, bool isByRef);
    public virtual Type get_Type();
    public sealed virtual ExpressionType get_NodeType();
    [CompilerGeneratedAttribute]
public string get_Name();
    public bool get_IsByRef();
    internal virtual bool GetIsByRef();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
}
internal class System.Linq.Expressions.PrimitiveParameterExpression`1 : ParameterExpression {
    public Type Type { get; }
    internal PrimitiveParameterExpression`1(string name);
    public sealed virtual Type get_Type();
}
internal class System.Linq.Expressions.PropertyExpression : MemberExpression {
    private PropertyInfo _property;
    public Type Type { get; }
    public PropertyExpression(Expression expression, PropertyInfo member);
    internal virtual MemberInfo GetMember();
    public sealed virtual Type get_Type();
}
[DebuggerTypeProxyAttribute("System.Linq.Expressions.Expression/RuntimeVariablesExpressionProxy")]
public class System.Linq.Expressions.RuntimeVariablesExpression : Expression {
    [CompilerGeneratedAttribute]
private ReadOnlyCollection`1<ParameterExpression> <Variables>k__BackingField;
    public Type Type { get; }
    public ExpressionType NodeType { get; }
    public ReadOnlyCollection`1<ParameterExpression> Variables { get; }
    internal RuntimeVariablesExpression(ReadOnlyCollection`1<ParameterExpression> variables);
    public sealed virtual Type get_Type();
    public sealed virtual ExpressionType get_NodeType();
    [CompilerGeneratedAttribute]
public ReadOnlyCollection`1<ParameterExpression> get_Variables();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
    public RuntimeVariablesExpression Update(IEnumerable`1<ParameterExpression> variables);
}
internal class System.Linq.Expressions.Scope1 : ScopeExpression {
    private object _body;
    internal int ExpressionCount { get; }
    internal Scope1(IReadOnlyList`1<ParameterExpression> variables, Expression body);
    private Scope1(IReadOnlyList`1<ParameterExpression> variables, object body);
    internal virtual bool SameExpressions(ICollection`1<Expression> expressions);
    internal virtual Expression GetExpression(int index);
    internal virtual int get_ExpressionCount();
    internal virtual ReadOnlyCollection`1<Expression> GetOrMakeExpressions();
    internal virtual BlockExpression Rewrite(ReadOnlyCollection`1<ParameterExpression> variables, Expression[] args);
}
internal class System.Linq.Expressions.ScopeExpression : BlockExpression {
    private IReadOnlyList`1<ParameterExpression> _variables;
    protected IReadOnlyList`1<ParameterExpression> VariablesList { get; }
    internal ScopeExpression(IReadOnlyList`1<ParameterExpression> variables);
    internal virtual bool SameVariables(ICollection`1<ParameterExpression> variables);
    internal virtual ReadOnlyCollection`1<ParameterExpression> GetOrMakeVariables();
    protected IReadOnlyList`1<ParameterExpression> get_VariablesList();
    internal IReadOnlyList`1<ParameterExpression> ReuseOrValidateVariables(ReadOnlyCollection`1<ParameterExpression> variables);
}
internal class System.Linq.Expressions.ScopeN : ScopeExpression {
    private IReadOnlyList`1<Expression> _body;
    protected IReadOnlyList`1<Expression> Body { get; }
    internal int ExpressionCount { get; }
    internal ScopeN(IReadOnlyList`1<ParameterExpression> variables, IReadOnlyList`1<Expression> body);
    internal virtual bool SameExpressions(ICollection`1<Expression> expressions);
    protected IReadOnlyList`1<Expression> get_Body();
    internal virtual Expression GetExpression(int index);
    internal virtual int get_ExpressionCount();
    internal virtual ReadOnlyCollection`1<Expression> GetOrMakeExpressions();
    internal virtual BlockExpression Rewrite(ReadOnlyCollection`1<ParameterExpression> variables, Expression[] args);
}
internal class System.Linq.Expressions.ScopeWithType : ScopeN {
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    public Type Type { get; }
    internal ScopeWithType(IReadOnlyList`1<ParameterExpression> variables, IReadOnlyList`1<Expression> expressions, Type type);
    [CompilerGeneratedAttribute]
public sealed virtual Type get_Type();
    internal virtual BlockExpression Rewrite(ReadOnlyCollection`1<ParameterExpression> variables, Expression[] args);
}
internal class System.Linq.Expressions.SimpleBinaryExpression : BinaryExpression {
    [CompilerGeneratedAttribute]
private ExpressionType <NodeType>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    public ExpressionType NodeType { get; }
    public Type Type { get; }
    internal SimpleBinaryExpression(ExpressionType nodeType, Expression left, Expression right, Type type);
    [CompilerGeneratedAttribute]
public sealed virtual ExpressionType get_NodeType();
    [CompilerGeneratedAttribute]
public sealed virtual Type get_Type();
}
internal class System.Linq.Expressions.SpanDebugInfoExpression : DebugInfoExpression {
    private int _startLine;
    private int _startColumn;
    private int _endLine;
    private int _endColumn;
    public int StartLine { get; }
    public int StartColumn { get; }
    public int EndLine { get; }
    public int EndColumn { get; }
    public bool IsClear { get; }
    internal SpanDebugInfoExpression(SymbolDocumentInfo document, int startLine, int startColumn, int endLine, int endColumn);
    public virtual int get_StartLine();
    public virtual int get_StartColumn();
    public virtual int get_EndLine();
    public virtual int get_EndColumn();
    public virtual bool get_IsClear();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
}
internal class System.Linq.Expressions.StackGuard : object {
    private static int MaxExecutionStackCount;
    private int _executionStackCount;
    public bool TryEnterOnCurrentStack();
    public void RunOnEmptyStack(Action`2<T1, T2> action, T1 arg1, T2 arg2);
    public void RunOnEmptyStack(Action`3<T1, T2, T3> action, T1 arg1, T2 arg2, T3 arg3);
    public R RunOnEmptyStack(Func`3<T1, T2, R> action, T1 arg1, T2 arg2);
    public R RunOnEmptyStack(Func`4<T1, T2, T3, R> action, T1 arg1, T2 arg2, T3 arg3);
    private R RunOnEmptyStackCore(Func`2<object, R> action, object state);
}
internal static class System.Linq.Expressions.Strings : object {
    internal static string ReducibleMustOverrideReduce { get; }
    internal static string MustReduceToDifferent { get; }
    internal static string ReducedNotCompatible { get; }
    internal static string SetterHasNoParams { get; }
    internal static string PropertyCannotHaveRefType { get; }
    internal static string IndexesOfSetGetMustMatch { get; }
    internal static string AccessorsCannotHaveVarArgs { get; }
    internal static string AccessorsCannotHaveByRefArgs { get; }
    internal static string BoundsCannotBeLessThanOne { get; }
    internal static string TypeMustNotBeByRef { get; }
    internal static string TypeMustNotBePointer { get; }
    internal static string SetterMustBeVoid { get; }
    internal static string PropertyTypeMustMatchGetter { get; }
    internal static string PropertyTypeMustMatchSetter { get; }
    internal static string BothAccessorsMustBeStatic { get; }
    internal static string OnlyStaticFieldsHaveNullInstance { get; }
    internal static string OnlyStaticPropertiesHaveNullInstance { get; }
    internal static string OnlyStaticMethodsHaveNullInstance { get; }
    internal static string PropertyTypeCannotBeVoid { get; }
    internal static string InvalidUnboxType { get; }
    internal static string ExpressionMustBeWriteable { get; }
    internal static string ArgumentMustNotHaveValueType { get; }
    internal static string MustBeReducible { get; }
    internal static string AllTestValuesMustHaveSameType { get; }
    internal static string AllCaseBodiesMustHaveSameType { get; }
    internal static string DefaultBodyMustBeSupplied { get; }
    internal static string LabelMustBeVoidOrHaveExpression { get; }
    internal static string LabelTypeMustBeVoid { get; }
    internal static string QuotedExpressionMustBeLambda { get; }
    internal static string CollectionModifiedWhileEnumerating { get; }
    internal static string CollectionReadOnly { get; }
    internal static string ArgCntMustBeGreaterThanNameCnt { get; }
    internal static string BindingCannotBeNull { get; }
    internal static string ArgumentTypeCannotBeVoid { get; }
    internal static string NoOrInvalidRuleProduced { get; }
    internal static string TypeMustBeDerivedFromSystemDelegate { get; }
    internal static string FirstArgumentMustBeCallSite { get; }
    internal static string StartEndMustBeOrdered { get; }
    internal static string FaultCannotHaveCatchOrFinally { get; }
    internal static string TryMustHaveCatchFinallyOrFault { get; }
    internal static string BodyOfCatchMustHaveSameTypeAsBodyOfTry { get; }
    internal static string ConversionIsNotSupportedForArithmeticTypes { get; }
    internal static string ArgumentMustBeArray { get; }
    internal static string ArgumentMustBeBoolean { get; }
    internal static string ArgumentMustBeFieldInfoOrPropertyInfo { get; }
    internal static string ArgumentMustBeFieldInfoOrPropertyInfoOrMethod { get; }
    internal static string ArgumentMustBeInstanceMember { get; }
    internal static string ArgumentMustBeInteger { get; }
    internal static string ArgumentMustBeArrayIndexType { get; }
    internal static string ArgumentMustBeSingleDimensionalArrayType { get; }
    internal static string ArgumentTypesMustMatch { get; }
    internal static string CoalesceUsedOnNonNullType { get; }
    internal static string IncorrectNumberOfIndexes { get; }
    internal static string IncorrectNumberOfLambdaDeclarationParameters { get; }
    internal static string IncorrectNumberOfMembersForGivenConstructor { get; }
    internal static string IncorrectNumberOfArgumentsForMembers { get; }
    internal static string LambdaTypeMustBeDerivedFromSystemDelegate { get; }
    internal static string ElementInitializerMethodNotAdd { get; }
    internal static string ElementInitializerMethodWithZeroArgs { get; }
    internal static string ElementInitializerMethodStatic { get; }
    internal static string UnhandledBinding { get; }
    internal static string UnknownBindingType { get; }
    internal static string IncorrectNumberOfTypeArgsForFunc { get; }
    internal static string IncorrectNumberOfTypeArgsForAction { get; }
    internal static string ArgumentCannotBeOfTypeVoid { get; }
    internal static string ControlCannotLeaveFinally { get; }
    internal static string ControlCannotLeaveFilterTest { get; }
    internal static string ControlCannotEnterTry { get; }
    internal static string ControlCannotEnterExpression { get; }
    internal static string CannotCompileDynamic { get; }
    internal static string MethodBuilderDoesNotHaveTypeBuilder { get; }
    internal static string RethrowRequiresCatch { get; }
    internal static string TryNotAllowedInFilter { get; }
    internal static string NonStaticConstructorRequired { get; }
    internal static string NonAbstractConstructorRequired { get; }
    internal static string ExpressionMustBeReadable { get; }
    internal static string EnumerationIsDone { get; }
    internal static string InvalidArgumentValue { get; }
    internal static string NonEmptyCollectionRequired { get; }
    internal static string IncorrectNumberOfLambdaArguments { get; }
    internal static string IncorrectNumberOfConstructorArguments { get; }
    internal static string get_ReducibleMustOverrideReduce();
    internal static string get_MustReduceToDifferent();
    internal static string get_ReducedNotCompatible();
    internal static string get_SetterHasNoParams();
    internal static string get_PropertyCannotHaveRefType();
    internal static string get_IndexesOfSetGetMustMatch();
    internal static string get_AccessorsCannotHaveVarArgs();
    internal static string get_AccessorsCannotHaveByRefArgs();
    internal static string get_BoundsCannotBeLessThanOne();
    internal static string get_TypeMustNotBeByRef();
    internal static string get_TypeMustNotBePointer();
    internal static string get_SetterMustBeVoid();
    internal static string get_PropertyTypeMustMatchGetter();
    internal static string get_PropertyTypeMustMatchSetter();
    internal static string get_BothAccessorsMustBeStatic();
    internal static string get_OnlyStaticFieldsHaveNullInstance();
    internal static string get_OnlyStaticPropertiesHaveNullInstance();
    internal static string get_OnlyStaticMethodsHaveNullInstance();
    internal static string get_PropertyTypeCannotBeVoid();
    internal static string get_InvalidUnboxType();
    internal static string get_ExpressionMustBeWriteable();
    internal static string get_ArgumentMustNotHaveValueType();
    internal static string get_MustBeReducible();
    internal static string get_AllTestValuesMustHaveSameType();
    internal static string get_AllCaseBodiesMustHaveSameType();
    internal static string get_DefaultBodyMustBeSupplied();
    internal static string get_LabelMustBeVoidOrHaveExpression();
    internal static string get_LabelTypeMustBeVoid();
    internal static string get_QuotedExpressionMustBeLambda();
    internal static string get_CollectionModifiedWhileEnumerating();
    internal static string VariableMustNotBeByRef(object p0, object p1);
    internal static string get_CollectionReadOnly();
    internal static string AmbiguousMatchInExpandoObject(object p0);
    internal static string SameKeyExistsInExpando(object p0);
    internal static string KeyDoesNotExistInExpando(object p0);
    internal static string get_ArgCntMustBeGreaterThanNameCnt();
    internal static string InvalidMetaObjectCreated(object p0);
    internal static string BinderNotCompatibleWithCallSite(object p0, object p1, object p2);
    internal static string DynamicBindingNeedsRestrictions(object p0, object p1);
    internal static string DynamicObjectResultNotAssignable(object p0, object p1, object p2, object p3);
    internal static string DynamicBinderResultNotAssignable(object p0, object p1, object p2);
    internal static string get_BindingCannotBeNull();
    internal static string DuplicateVariable(object p0);
    internal static string get_ArgumentTypeCannotBeVoid();
    internal static string TypeParameterIsNotDelegate(object p0);
    internal static string get_NoOrInvalidRuleProduced();
    internal static string get_TypeMustBeDerivedFromSystemDelegate();
    internal static string get_FirstArgumentMustBeCallSite();
    internal static string get_StartEndMustBeOrdered();
    internal static string get_FaultCannotHaveCatchOrFinally();
    internal static string get_TryMustHaveCatchFinallyOrFault();
    internal static string get_BodyOfCatchMustHaveSameTypeAsBodyOfTry();
    internal static string ExtensionNodeMustOverrideProperty(object p0);
    internal static string UserDefinedOperatorMustBeStatic(object p0);
    internal static string UserDefinedOperatorMustNotBeVoid(object p0);
    internal static string CoercionOperatorNotDefined(object p0, object p1);
    internal static string UnaryOperatorNotDefined(object p0, object p1);
    internal static string BinaryOperatorNotDefined(object p0, object p1, object p2);
    internal static string ReferenceEqualityNotDefined(object p0, object p1);
    internal static string OperandTypesDoNotMatchParameters(object p0, object p1);
    internal static string OverloadOperatorTypeDoesNotMatchConversionType(object p0, object p1);
    internal static string get_ConversionIsNotSupportedForArithmeticTypes();
    internal static string get_ArgumentMustBeArray();
    internal static string get_ArgumentMustBeBoolean();
    internal static string EqualityMustReturnBoolean(object p0);
    internal static string get_ArgumentMustBeFieldInfoOrPropertyInfo();
    internal static string get_ArgumentMustBeFieldInfoOrPropertyInfoOrMethod();
    internal static string get_ArgumentMustBeInstanceMember();
    internal static string get_ArgumentMustBeInteger();
    internal static string get_ArgumentMustBeArrayIndexType();
    internal static string get_ArgumentMustBeSingleDimensionalArrayType();
    internal static string get_ArgumentTypesMustMatch();
    internal static string CannotAutoInitializeValueTypeElementThroughProperty(object p0);
    internal static string CannotAutoInitializeValueTypeMemberThroughProperty(object p0);
    internal static string IncorrectTypeForTypeAs(object p0);
    internal static string get_CoalesceUsedOnNonNullType();
    internal static string ExpressionTypeCannotInitializeArrayType(object p0, object p1);
    internal static string ArgumentTypeDoesNotMatchMember(object p0, object p1);
    internal static string ArgumentMemberNotDeclOnType(object p0, object p1);
    internal static string ExpressionTypeDoesNotMatchReturn(object p0, object p1);
    internal static string ExpressionTypeDoesNotMatchAssignment(object p0, object p1);
    internal static string ExpressionTypeDoesNotMatchLabel(object p0, object p1);
    internal static string ExpressionTypeNotInvocable(object p0);
    internal static string FieldNotDefinedForType(object p0, object p1);
    internal static string InstanceFieldNotDefinedForType(object p0, object p1);
    internal static string FieldInfoNotDefinedForType(object p0, object p1, object p2);
    internal static string get_IncorrectNumberOfIndexes();
    internal static string get_IncorrectNumberOfLambdaDeclarationParameters();
    internal static string get_IncorrectNumberOfMembersForGivenConstructor();
    internal static string get_IncorrectNumberOfArgumentsForMembers();
    internal static string get_LambdaTypeMustBeDerivedFromSystemDelegate();
    internal static string MemberNotFieldOrProperty(object p0);
    internal static string MethodContainsGenericParameters(object p0);
    internal static string MethodIsGeneric(object p0);
    internal static string MethodNotPropertyAccessor(object p0, object p1);
    internal static string PropertyDoesNotHaveGetter(object p0);
    internal static string PropertyDoesNotHaveSetter(object p0);
    internal static string PropertyDoesNotHaveAccessor(object p0);
    internal static string NotAMemberOfType(object p0, object p1);
    internal static string NotAMemberOfAnyType(object p0);
    internal static string ParameterExpressionNotValidAsDelegate(object p0, object p1);
    internal static string PropertyNotDefinedForType(object p0, object p1);
    internal static string InstancePropertyNotDefinedForType(object p0, object p1);
    internal static string InstancePropertyWithoutParameterNotDefinedForType(object p0, object p1);
    internal static string InstancePropertyWithSpecifiedParametersNotDefinedForType(object p0, object p1, object p2);
    internal static string InstanceAndMethodTypeMismatch(object p0, object p1, object p2);
    internal static string TypeMissingDefaultConstructor(object p0);
    internal static string get_ElementInitializerMethodNotAdd();
    internal static string ElementInitializerMethodNoRefOutParam(object p0, object p1);
    internal static string get_ElementInitializerMethodWithZeroArgs();
    internal static string get_ElementInitializerMethodStatic();
    internal static string TypeNotIEnumerable(object p0);
    internal static string UnhandledBinary(object p0);
    internal static string get_UnhandledBinding();
    internal static string UnhandledBindingType(object p0);
    internal static string UnhandledUnary(object p0);
    internal static string get_UnknownBindingType();
    internal static string UserDefinedOpMustHaveConsistentTypes(object p0, object p1);
    internal static string UserDefinedOpMustHaveValidReturnType(object p0, object p1);
    internal static string LogicalOperatorMustHaveBooleanOperators(object p0, object p1);
    internal static string MethodWithArgsDoesNotExistOnType(object p0, object p1);
    internal static string GenericMethodWithArgsDoesNotExistOnType(object p0, object p1);
    internal static string MethodWithMoreThanOneMatch(object p0, object p1);
    internal static string PropertyWithMoreThanOneMatch(object p0, object p1);
    internal static string get_IncorrectNumberOfTypeArgsForFunc();
    internal static string get_IncorrectNumberOfTypeArgsForAction();
    internal static string get_ArgumentCannotBeOfTypeVoid();
    internal static string OutOfRange(object p0, object p1);
    internal static string LabelTargetAlreadyDefined(object p0);
    internal static string LabelTargetUndefined(object p0);
    internal static string get_ControlCannotLeaveFinally();
    internal static string get_ControlCannotLeaveFilterTest();
    internal static string AmbiguousJump(object p0);
    internal static string get_ControlCannotEnterTry();
    internal static string get_ControlCannotEnterExpression();
    internal static string NonLocalJumpWithValue(object p0);
    internal static string CannotCompileConstant(object p0);
    internal static string get_CannotCompileDynamic();
    internal static string get_MethodBuilderDoesNotHaveTypeBuilder();
    internal static string InvalidLvalue(object p0);
    internal static string UndefinedVariable(object p0, object p1, object p2);
    internal static string CannotCloseOverByRef(object p0, object p1);
    internal static string UnexpectedVarArgsCall(object p0);
    internal static string get_RethrowRequiresCatch();
    internal static string get_TryNotAllowedInFilter();
    internal static string MustRewriteToSameNode(object p0, object p1, object p2);
    internal static string MustRewriteChildToSameType(object p0, object p1, object p2);
    internal static string MustRewriteWithoutMethod(object p0, object p1);
    internal static string TryNotSupportedForMethodsWithRefArgs(object p0);
    internal static string TryNotSupportedForValueTypeInstances(object p0);
    internal static string TestValueTypeDoesNotMatchComparisonMethodParameter(object p0, object p1);
    internal static string SwitchValueTypeDoesNotMatchComparisonMethodParameter(object p0, object p1);
    internal static string get_NonStaticConstructorRequired();
    internal static string get_NonAbstractConstructorRequired();
    internal static string get_ExpressionMustBeReadable();
    internal static string ExpressionTypeDoesNotMatchConstructorParameter(object p0, object p1);
    internal static string get_EnumerationIsDone();
    internal static string TypeContainsGenericParameters(object p0);
    internal static string TypeIsGeneric(object p0);
    internal static string get_InvalidArgumentValue();
    internal static string get_NonEmptyCollectionRequired();
    internal static string InvalidNullValue(object p0);
    internal static string InvalidObjectType(object p0, object p1);
    internal static string ExpressionTypeDoesNotMatchMethodParameter(object p0, object p1, object p2);
    internal static string ExpressionTypeDoesNotMatchParameter(object p0, object p1);
    internal static string IncorrectNumberOfMethodCallArguments(object p0);
    internal static string get_IncorrectNumberOfLambdaArguments();
    internal static string get_IncorrectNumberOfConstructorArguments();
}
[DebuggerTypeProxyAttribute("System.Linq.Expressions.Expression/SwitchCaseProxy")]
public class System.Linq.Expressions.SwitchCase : object {
    [CompilerGeneratedAttribute]
private ReadOnlyCollection`1<Expression> <TestValues>k__BackingField;
    [CompilerGeneratedAttribute]
private Expression <Body>k__BackingField;
    public ReadOnlyCollection`1<Expression> TestValues { get; }
    public Expression Body { get; }
    internal SwitchCase(Expression body, ReadOnlyCollection`1<Expression> testValues);
    [CompilerGeneratedAttribute]
public ReadOnlyCollection`1<Expression> get_TestValues();
    [CompilerGeneratedAttribute]
public Expression get_Body();
    public virtual string ToString();
    public SwitchCase Update(IEnumerable`1<Expression> testValues, Expression body);
}
[DebuggerTypeProxyAttribute("System.Linq.Expressions.Expression/SwitchExpressionProxy")]
public class System.Linq.Expressions.SwitchExpression : Expression {
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private Expression <SwitchValue>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadOnlyCollection`1<SwitchCase> <Cases>k__BackingField;
    [CompilerGeneratedAttribute]
private Expression <DefaultBody>k__BackingField;
    [CompilerGeneratedAttribute]
private MethodInfo <Comparison>k__BackingField;
    public Type Type { get; }
    public ExpressionType NodeType { get; }
    public Expression SwitchValue { get; }
    public ReadOnlyCollection`1<SwitchCase> Cases { get; }
    public Expression DefaultBody { get; }
    public MethodInfo Comparison { get; }
    internal bool IsLifted { get; }
    internal SwitchExpression(Type type, Expression switchValue, Expression defaultBody, MethodInfo comparison, ReadOnlyCollection`1<SwitchCase> cases);
    [CompilerGeneratedAttribute]
public sealed virtual Type get_Type();
    public sealed virtual ExpressionType get_NodeType();
    [CompilerGeneratedAttribute]
public Expression get_SwitchValue();
    [CompilerGeneratedAttribute]
public ReadOnlyCollection`1<SwitchCase> get_Cases();
    [CompilerGeneratedAttribute]
public Expression get_DefaultBody();
    [CompilerGeneratedAttribute]
public MethodInfo get_Comparison();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
    internal bool get_IsLifted();
    public SwitchExpression Update(Expression switchValue, IEnumerable`1<SwitchCase> cases, Expression defaultBody);
}
public class System.Linq.Expressions.SymbolDocumentInfo : object {
    [CompilerGeneratedAttribute]
private string <FileName>k__BackingField;
    internal static Guid DocumentType_Text;
    public string FileName { get; }
    public Guid Language { get; }
    public Guid LanguageVendor { get; }
    public Guid DocumentType { get; }
    internal SymbolDocumentInfo(string fileName);
    private static SymbolDocumentInfo();
    [CompilerGeneratedAttribute]
public string get_FileName();
    public virtual Guid get_Language();
    public virtual Guid get_LanguageVendor();
    public virtual Guid get_DocumentType();
}
internal class System.Linq.Expressions.SymbolDocumentWithGuids : SymbolDocumentInfo {
    [CompilerGeneratedAttribute]
private Guid <Language>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <LanguageVendor>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <DocumentType>k__BackingField;
    public Guid Language { get; }
    public Guid LanguageVendor { get; }
    public Guid DocumentType { get; }
    internal SymbolDocumentWithGuids(string fileName, Guid& language);
    internal SymbolDocumentWithGuids(string fileName, Guid& language, Guid& vendor);
    internal SymbolDocumentWithGuids(string fileName, Guid& language, Guid& vendor, Guid& documentType);
    [CompilerGeneratedAttribute]
public virtual Guid get_Language();
    [CompilerGeneratedAttribute]
public virtual Guid get_LanguageVendor();
    [CompilerGeneratedAttribute]
public virtual Guid get_DocumentType();
}
[DebuggerTypeProxyAttribute("System.Linq.Expressions.Expression/TryExpressionProxy")]
public class System.Linq.Expressions.TryExpression : Expression {
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private Expression <Body>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadOnlyCollection`1<CatchBlock> <Handlers>k__BackingField;
    [CompilerGeneratedAttribute]
private Expression <Finally>k__BackingField;
    [CompilerGeneratedAttribute]
private Expression <Fault>k__BackingField;
    public Type Type { get; }
    public ExpressionType NodeType { get; }
    public Expression Body { get; }
    public ReadOnlyCollection`1<CatchBlock> Handlers { get; }
    public Expression Finally { get; }
    public Expression Fault { get; }
    internal TryExpression(Type type, Expression body, Expression finally, Expression fault, ReadOnlyCollection`1<CatchBlock> handlers);
    [CompilerGeneratedAttribute]
public sealed virtual Type get_Type();
    public sealed virtual ExpressionType get_NodeType();
    [CompilerGeneratedAttribute]
public Expression get_Body();
    [CompilerGeneratedAttribute]
public ReadOnlyCollection`1<CatchBlock> get_Handlers();
    [CompilerGeneratedAttribute]
public Expression get_Finally();
    [CompilerGeneratedAttribute]
public Expression get_Fault();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
    public TryExpression Update(Expression body, IEnumerable`1<CatchBlock> handlers, Expression finally, Expression fault);
}
[DebuggerTypeProxyAttribute("System.Linq.Expressions.Expression/TypeBinaryExpressionProxy")]
public class System.Linq.Expressions.TypeBinaryExpression : Expression {
    [CompilerGeneratedAttribute]
private ExpressionType <NodeType>k__BackingField;
    [CompilerGeneratedAttribute]
private Expression <Expression>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <TypeOperand>k__BackingField;
    public Type Type { get; }
    public ExpressionType NodeType { get; }
    public Expression Expression { get; }
    public Type TypeOperand { get; }
    internal TypeBinaryExpression(Expression expression, Type typeOperand, ExpressionType nodeType);
    public sealed virtual Type get_Type();
    [CompilerGeneratedAttribute]
public sealed virtual ExpressionType get_NodeType();
    [CompilerGeneratedAttribute]
public Expression get_Expression();
    [CompilerGeneratedAttribute]
public Type get_TypeOperand();
    internal Expression ReduceTypeEqual();
    private Expression ByValParameterTypeEqual(ParameterExpression value);
    private Expression ReduceConstantTypeEqual();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
    public TypeBinaryExpression Update(Expression expression);
}
internal class System.Linq.Expressions.TypedConstantExpression : ConstantExpression {
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    public Type Type { get; }
    internal TypedConstantExpression(object value, Type type);
    [CompilerGeneratedAttribute]
public sealed virtual Type get_Type();
}
internal class System.Linq.Expressions.TypedDynamicExpression1 : DynamicExpression1 {
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    public Type Type { get; }
    internal TypedDynamicExpression1(Type retType, Type delegateType, CallSiteBinder binder, Expression arg0);
    [CompilerGeneratedAttribute]
public sealed virtual Type get_Type();
}
internal class System.Linq.Expressions.TypedDynamicExpression2 : DynamicExpression2 {
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    public Type Type { get; }
    internal TypedDynamicExpression2(Type retType, Type delegateType, CallSiteBinder binder, Expression arg0, Expression arg1);
    [CompilerGeneratedAttribute]
public sealed virtual Type get_Type();
}
internal class System.Linq.Expressions.TypedDynamicExpression3 : DynamicExpression3 {
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    public Type Type { get; }
    internal TypedDynamicExpression3(Type retType, Type delegateType, CallSiteBinder binder, Expression arg0, Expression arg1, Expression arg2);
    [CompilerGeneratedAttribute]
public sealed virtual Type get_Type();
}
internal class System.Linq.Expressions.TypedDynamicExpression4 : DynamicExpression4 {
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    public Type Type { get; }
    internal TypedDynamicExpression4(Type retType, Type delegateType, CallSiteBinder binder, Expression arg0, Expression arg1, Expression arg2, Expression arg3);
    [CompilerGeneratedAttribute]
public sealed virtual Type get_Type();
}
internal class System.Linq.Expressions.TypedDynamicExpressionN : DynamicExpressionN {
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    public Type Type { get; }
    internal TypedDynamicExpressionN(Type returnType, Type delegateType, CallSiteBinder binder, IReadOnlyList`1<Expression> arguments);
    [CompilerGeneratedAttribute]
public sealed virtual Type get_Type();
}
internal class System.Linq.Expressions.TypedParameterExpression : ParameterExpression {
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    public Type Type { get; }
    internal TypedParameterExpression(Type type, string name);
    [CompilerGeneratedAttribute]
public sealed virtual Type get_Type();
}
[DebuggerTypeProxyAttribute("System.Linq.Expressions.Expression/UnaryExpressionProxy")]
public class System.Linq.Expressions.UnaryExpression : Expression {
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private ExpressionType <NodeType>k__BackingField;
    [CompilerGeneratedAttribute]
private Expression <Operand>k__BackingField;
    [CompilerGeneratedAttribute]
private MethodInfo <Method>k__BackingField;
    public Type Type { get; }
    public ExpressionType NodeType { get; }
    public Expression Operand { get; }
    public MethodInfo Method { get; }
    public bool IsLifted { get; }
    public bool IsLiftedToNull { get; }
    public bool CanReduce { get; }
    private bool IsPrefix { get; }
    internal UnaryExpression(ExpressionType nodeType, Expression expression, Type type, MethodInfo method);
    [CompilerGeneratedAttribute]
public sealed virtual Type get_Type();
    [CompilerGeneratedAttribute]
public sealed virtual ExpressionType get_NodeType();
    [CompilerGeneratedAttribute]
public Expression get_Operand();
    [CompilerGeneratedAttribute]
public MethodInfo get_Method();
    public bool get_IsLifted();
    public bool get_IsLiftedToNull();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
    public virtual bool get_CanReduce();
    public virtual Expression Reduce();
    private bool get_IsPrefix();
    private UnaryExpression FunctionalOp(Expression operand);
    private Expression ReduceVariable();
    private Expression ReduceMember();
    private Expression ReduceIndex();
    public UnaryExpression Update(Expression operand);
}
internal static class System.Linq.Expressions.Utils : object {
    public static object BoxedFalse;
    public static object BoxedTrue;
    public static object BoxedIntM1;
    public static object BoxedInt0;
    public static object BoxedInt1;
    public static object BoxedInt2;
    public static object BoxedInt3;
    public static object BoxedDefaultSByte;
    public static object BoxedDefaultChar;
    public static object BoxedDefaultInt16;
    public static object BoxedDefaultInt64;
    public static object BoxedDefaultByte;
    public static object BoxedDefaultUInt16;
    public static object BoxedDefaultUInt32;
    public static object BoxedDefaultUInt64;
    public static object BoxedDefaultSingle;
    public static object BoxedDefaultDouble;
    public static object BoxedDefaultDecimal;
    public static object BoxedDefaultDateTime;
    private static ConstantExpression s_true;
    private static ConstantExpression s_false;
    private static ConstantExpression s_m1;
    private static ConstantExpression s_0;
    private static ConstantExpression s_1;
    private static ConstantExpression s_2;
    private static ConstantExpression s_3;
    public static DefaultExpression Empty;
    public static ConstantExpression Null;
    private static Utils();
    public static ConstantExpression Constant(bool value);
    public static ConstantExpression Constant(int value);
}
internal class System.Linq.GroupedEnumerable`2 : object {
    private IEnumerable`1<TSource> _source;
    private Func`2<TSource, TKey> _keySelector;
    private IEqualityComparer`1<TKey> _comparer;
    public GroupedEnumerable`2(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, IEqualityComparer`1<TKey> comparer);
    public sealed virtual IEnumerator`1<IGrouping`2<TKey, TSource>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual IGrouping`2[] ToArray();
    public sealed virtual List`1<IGrouping`2<TKey, TSource>> ToList();
    public sealed virtual int GetCount(bool onlyIfCheap);
}
internal class System.Linq.GroupedEnumerable`3 : object {
    private IEnumerable`1<TSource> _source;
    private Func`2<TSource, TKey> _keySelector;
    private Func`2<TSource, TElement> _elementSelector;
    private IEqualityComparer`1<TKey> _comparer;
    public GroupedEnumerable`3(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`2<TSource, TElement> elementSelector, IEqualityComparer`1<TKey> comparer);
    public sealed virtual IEnumerator`1<IGrouping`2<TKey, TElement>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual IGrouping`2[] ToArray();
    public sealed virtual List`1<IGrouping`2<TKey, TElement>> ToList();
    public sealed virtual int GetCount(bool onlyIfCheap);
}
internal class System.Linq.GroupedResultEnumerable`3 : object {
    private IEnumerable`1<TSource> _source;
    private Func`2<TSource, TKey> _keySelector;
    private IEqualityComparer`1<TKey> _comparer;
    private Func`3<TKey, IEnumerable`1<TSource>, TResult> _resultSelector;
    public GroupedResultEnumerable`3(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`3<TKey, IEnumerable`1<TSource>, TResult> resultSelector, IEqualityComparer`1<TKey> comparer);
    public sealed virtual IEnumerator`1<TResult> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual TResult[] ToArray();
    public sealed virtual List`1<TResult> ToList();
    public sealed virtual int GetCount(bool onlyIfCheap);
}
internal class System.Linq.GroupedResultEnumerable`4 : object {
    private IEnumerable`1<TSource> _source;
    private Func`2<TSource, TKey> _keySelector;
    private Func`2<TSource, TElement> _elementSelector;
    private IEqualityComparer`1<TKey> _comparer;
    private Func`3<TKey, IEnumerable`1<TElement>, TResult> _resultSelector;
    public GroupedResultEnumerable`4(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`2<TSource, TElement> elementSelector, Func`3<TKey, IEnumerable`1<TElement>, TResult> resultSelector, IEqualityComparer`1<TKey> comparer);
    public sealed virtual IEnumerator`1<TResult> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual TResult[] ToArray();
    public sealed virtual List`1<TResult> ToList();
    public sealed virtual int GetCount(bool onlyIfCheap);
}
[DebuggerDisplayAttribute("Key = {Key}")]
[DebuggerTypeProxyAttribute("System.Linq.SystemLinq_GroupingDebugView`2")]
internal class System.Linq.Grouping`2 : object {
    internal TKey _key;
    internal int _hashCode;
    internal TElement[] _elements;
    internal int _count;
    internal Grouping`2<TKey, TElement> _hashNext;
    internal Grouping`2<TKey, TElement> _next;
    public TKey Key { get; }
    private int System.Collections.Generic.ICollection<TElement>.Count { get; }
    private bool System.Collections.Generic.ICollection<TElement>.IsReadOnly { get; }
    private TElement System.Collections.Generic.IList<TElement>.Item { get; private set; }
    internal void Add(TElement element);
    internal void Trim();
    [IteratorStateMachineAttribute("System.Linq.Grouping`2/<GetEnumerator>d__9")]
public sealed virtual IEnumerator`1<TElement> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual TKey get_Key();
    private sealed virtual override int System.Collections.Generic.ICollection<TElement>.get_Count();
    private sealed virtual override bool System.Collections.Generic.ICollection<TElement>.get_IsReadOnly();
    private sealed virtual override void System.Collections.Generic.ICollection<TElement>.Add(TElement item);
    private sealed virtual override void System.Collections.Generic.ICollection<TElement>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<TElement>.Contains(TElement item);
    private sealed virtual override void System.Collections.Generic.ICollection<TElement>.CopyTo(TElement[] array, int arrayIndex);
    private sealed virtual override bool System.Collections.Generic.ICollection<TElement>.Remove(TElement item);
    private sealed virtual override int System.Collections.Generic.IList<TElement>.IndexOf(TElement item);
    private sealed virtual override void System.Collections.Generic.IList<TElement>.Insert(int index, TElement item);
    private sealed virtual override void System.Collections.Generic.IList<TElement>.RemoveAt(int index);
    private sealed virtual override TElement System.Collections.Generic.IList<TElement>.get_Item(int index);
    private sealed virtual override void System.Collections.Generic.IList<TElement>.set_Item(int index, TElement value);
}
public interface System.Linq.IGrouping`2 {
    public TKey Key { get; }
    public abstract virtual TKey get_Key();
}
internal interface System.Linq.IIListProvider`1 {
    public abstract virtual TElement[] ToArray();
    public abstract virtual List`1<TElement> ToList();
    public abstract virtual int GetCount(bool onlyIfCheap);
}
[DefaultMemberAttribute("Item")]
public interface System.Linq.ILookup`2 {
    public int Count { get; }
    public IEnumerable`1<TElement> Item { get; }
    public abstract virtual int get_Count();
    public abstract virtual IEnumerable`1<TElement> get_Item(TKey key);
    public abstract virtual bool Contains(TKey key);
}
public interface System.Linq.IOrderedEnumerable`1 {
    public abstract virtual IOrderedEnumerable`1<TElement> CreateOrderedEnumerable(Func`2<TElement, TKey> keySelector, IComparer`1<TKey> comparer, bool descending);
}
public interface System.Linq.IOrderedQueryable {
}
public interface System.Linq.IOrderedQueryable`1 {
}
internal interface System.Linq.IPartition`1 {
    public abstract virtual IPartition`1<TElement> Skip(int count);
    public abstract virtual IPartition`1<TElement> Take(int count);
    public abstract virtual TElement TryGetElementAt(int index, Boolean& found);
    public abstract virtual TElement TryGetFirst(Boolean& found);
    public abstract virtual TElement TryGetLast(Boolean& found);
}
public interface System.Linq.IQueryable {
    public Expression Expression { get; }
    public Type ElementType { get; }
    public IQueryProvider Provider { get; }
    public abstract virtual Expression get_Expression();
    public abstract virtual Type get_ElementType();
    public abstract virtual IQueryProvider get_Provider();
}
public interface System.Linq.IQueryable`1 {
}
public interface System.Linq.IQueryProvider {
    public abstract virtual IQueryable CreateQuery(Expression expression);
    public abstract virtual IQueryable`1<TElement> CreateQuery(Expression expression);
    public abstract virtual object Execute(Expression expression);
    public abstract virtual TResult Execute(Expression expression);
}
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("Count = {Count}")]
[DebuggerTypeProxyAttribute("System.Linq.SystemLinq_LookupDebugView`2")]
public class System.Linq.Lookup`2 : object {
    private IEqualityComparer`1<TKey> _comparer;
    private Grouping`2[] _groupings;
    private Grouping`2<TKey, TElement> _lastGrouping;
    private int _count;
    public int Count { get; }
    public IEnumerable`1<TElement> Item { get; }
    private Lookup`2(IEqualityComparer`1<TKey> comparer);
    internal static Lookup`2<TKey, TElement> Create(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`2<TSource, TElement> elementSelector, IEqualityComparer`1<TKey> comparer);
    internal static Lookup`2<TKey, TElement> Create(IEnumerable`1<TElement> source, Func`2<TElement, TKey> keySelector, IEqualityComparer`1<TKey> comparer);
    internal static Lookup`2<TKey, TElement> CreateForJoin(IEnumerable`1<TElement> source, Func`2<TElement, TKey> keySelector, IEqualityComparer`1<TKey> comparer);
    public sealed virtual int get_Count();
    public sealed virtual IEnumerable`1<TElement> get_Item(TKey key);
    public sealed virtual bool Contains(TKey key);
    [IteratorStateMachineAttribute("System.Linq.Lookup`2/<GetEnumerator>d__13")]
public sealed virtual IEnumerator`1<IGrouping`2<TKey, TElement>> GetEnumerator();
    private sealed virtual override IGrouping`2[] System.Linq.IIListProvider<System.Linq.IGrouping<TKey,TElement>>.ToArray();
    internal TResult[] ToArray(Func`3<TKey, IEnumerable`1<TElement>, TResult> resultSelector);
    private sealed virtual override List`1<IGrouping`2<TKey, TElement>> System.Linq.IIListProvider<System.Linq.IGrouping<TKey,TElement>>.ToList();
    internal List`1<TResult> ToList(Func`3<TKey, IEnumerable`1<TElement>, TResult> resultSelector);
    private sealed virtual override int System.Linq.IIListProvider<System.Linq.IGrouping<TKey,TElement>>.GetCount(bool onlyIfCheap);
    [IteratorStateMachineAttribute("System.Linq.Lookup`2/<ApplyResultSelector>d__19`1")]
public IEnumerable`1<TResult> ApplyResultSelector(Func`3<TKey, IEnumerable`1<TElement>, TResult> resultSelector);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private int InternalGetHashCode(TKey key);
    internal Grouping`2<TKey, TElement> GetGrouping(TKey key, bool create);
    private void Resize();
}
internal abstract class System.Linq.OrderedEnumerable`1 : object {
    internal IEnumerable`1<TElement> _source;
    private Int32[] SortedMap(Buffer`1<TElement> buffer);
    private Int32[] SortedMap(Buffer`1<TElement> buffer, int minIdx, int maxIdx);
    [IteratorStateMachineAttribute("System.Linq.OrderedEnumerable`1/<GetEnumerator>d__3")]
public sealed virtual IEnumerator`1<TElement> GetEnumerator();
    public sealed virtual TElement[] ToArray();
    public sealed virtual List`1<TElement> ToList();
    public sealed virtual int GetCount(bool onlyIfCheap);
    [IteratorStateMachineAttribute("System.Linq.OrderedEnumerable`1/<GetEnumerator>d__7")]
internal IEnumerator`1<TElement> GetEnumerator(int minIdx, int maxIdx);
    internal TElement[] ToArray(int minIdx, int maxIdx);
    internal List`1<TElement> ToList(int minIdx, int maxIdx);
    internal int GetCount(int minIdx, int maxIdx, bool onlyIfCheap);
    private EnumerableSorter`1<TElement> GetEnumerableSorter();
    internal abstract virtual EnumerableSorter`1<TElement> GetEnumerableSorter(EnumerableSorter`1<TElement> next);
    private CachingComparer`1<TElement> GetComparer();
    internal abstract virtual CachingComparer`1<TElement> GetComparer(CachingComparer`1<TElement> childComparer);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override IOrderedEnumerable`1<TElement> System.Linq.IOrderedEnumerable<TElement>.CreateOrderedEnumerable(Func`2<TElement, TKey> keySelector, IComparer`1<TKey> comparer, bool descending);
    public sealed virtual IPartition`1<TElement> Skip(int count);
    public sealed virtual IPartition`1<TElement> Take(int count);
    public sealed virtual TElement TryGetElementAt(int index, Boolean& found);
    public sealed virtual TElement TryGetFirst(Boolean& found);
    public TElement TryGetFirst(Func`2<TElement, bool> predicate, Boolean& found);
    public sealed virtual TElement TryGetLast(Boolean& found);
    public TElement TryGetLast(int minIdx, int maxIdx, Boolean& found);
    private TElement Last(Buffer`1<TElement> buffer);
    public TElement TryGetLast(Func`2<TElement, bool> predicate, Boolean& found);
}
internal class System.Linq.OrderedEnumerable`2 : OrderedEnumerable`1<TElement> {
    private OrderedEnumerable`1<TElement> _parent;
    private Func`2<TElement, TKey> _keySelector;
    private IComparer`1<TKey> _comparer;
    private bool _descending;
    internal OrderedEnumerable`2(IEnumerable`1<TElement> source, Func`2<TElement, TKey> keySelector, IComparer`1<TKey> comparer, bool descending, OrderedEnumerable`1<TElement> parent);
    internal virtual EnumerableSorter`1<TElement> GetEnumerableSorter(EnumerableSorter`1<TElement> next);
    internal virtual CachingComparer`1<TElement> GetComparer(CachingComparer`1<TElement> childComparer);
}
public class System.Linq.OrderedParallelQuery`1 : ParallelQuery`1<TSource> {
    private QueryOperator`1<TSource> _sortOp;
    internal QueryOperator`1<TSource> SortOperator { get; }
    internal IOrderedEnumerable`1<TSource> OrderedEnumerable { get; }
    internal OrderedParallelQuery`1(QueryOperator`1<TSource> sortOp);
    internal QueryOperator`1<TSource> get_SortOperator();
    internal IOrderedEnumerable`1<TSource> get_OrderedEnumerable();
    public virtual IEnumerator`1<TSource> GetEnumerator();
}
internal class System.Linq.OrderedPartition`1 : object {
    private OrderedEnumerable`1<TElement> _source;
    private int _minIndexInclusive;
    private int _maxIndexInclusive;
    public OrderedPartition`1(OrderedEnumerable`1<TElement> source, int minIdxInclusive, int maxIdxInclusive);
    public sealed virtual IEnumerator`1<TElement> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual IPartition`1<TElement> Skip(int count);
    public sealed virtual IPartition`1<TElement> Take(int count);
    public sealed virtual TElement TryGetElementAt(int index, Boolean& found);
    public sealed virtual TElement TryGetFirst(Boolean& found);
    public sealed virtual TElement TryGetLast(Boolean& found);
    public sealed virtual TElement[] ToArray();
    public sealed virtual List`1<TElement> ToList();
    public sealed virtual int GetCount(bool onlyIfCheap);
}
internal class System.Linq.Parallel.AnyAllSearchOperator`1 : UnaryQueryOperator`2<TInput, bool> {
    private Func`2<TInput, bool> _predicate;
    private bool _qualification;
    internal bool LimitsParallelism { get; }
    internal AnyAllSearchOperator`1(IEnumerable`1<TInput> child, bool qualification, Func`2<TInput, bool> predicate);
    internal bool Aggregate();
    internal virtual QueryResults`1<bool> Open(QuerySettings settings, bool preferStriping);
    internal virtual void WrapPartitionedStream(PartitionedStream`2<TInput, TKey> inputStream, IPartitionedStreamRecipient`1<bool> recipient, bool preferStriping, QuerySettings settings);
    [ExcludeFromCodeCoverageAttribute]
internal virtual IEnumerable`1<bool> AsSequentialQuery(CancellationToken token);
    internal virtual bool get_LimitsParallelism();
}
internal class System.Linq.Parallel.ArrayMergeHelper`1 : object {
    private QueryResults`1<TInputOutput> _queryResults;
    private TInputOutput[] _outputArray;
    private QuerySettings _settings;
    public ArrayMergeHelper`1(QuerySettings settings, QueryResults`1<TInputOutput> queryResults);
    private void ToArrayElement(int index);
    public sealed virtual void Execute();
    [ExcludeFromCodeCoverageAttribute]
public sealed virtual IEnumerator`1<TInputOutput> GetEnumerator();
    public sealed virtual TInputOutput[] GetResultsAsArray();
}
internal class System.Linq.Parallel.AssociativeAggregationOperator`3 : UnaryQueryOperator`2<TInput, TIntermediate> {
    private TIntermediate _seed;
    private bool _seedIsSpecified;
    private bool _throwIfEmpty;
    private Func`3<TIntermediate, TInput, TIntermediate> _intermediateReduce;
    private Func`3<TIntermediate, TIntermediate, TIntermediate> _finalReduce;
    private Func`2<TIntermediate, TOutput> _resultSelector;
    private Func`1<TIntermediate> _seedFactory;
    internal bool LimitsParallelism { get; }
    internal AssociativeAggregationOperator`3(IEnumerable`1<TInput> child, TIntermediate seed, Func`1<TIntermediate> seedFactory, bool seedIsSpecified, Func`3<TIntermediate, TInput, TIntermediate> intermediateReduce, Func`3<TIntermediate, TIntermediate, TIntermediate> finalReduce, Func`2<TIntermediate, TOutput> resultSelector, bool throwIfEmpty, QueryAggregationOptions options);
    internal TOutput Aggregate();
    internal virtual QueryResults`1<TIntermediate> Open(QuerySettings settings, bool preferStriping);
    internal virtual void WrapPartitionedStream(PartitionedStream`2<TInput, TKey> inputStream, IPartitionedStreamRecipient`1<TIntermediate> recipient, bool preferStriping, QuerySettings settings);
    [ExcludeFromCodeCoverageAttribute]
internal virtual IEnumerable`1<TIntermediate> AsSequentialQuery(CancellationToken token);
    internal virtual bool get_LimitsParallelism();
}
internal class System.Linq.Parallel.AsynchronousChannel`1 : object {
    private T[][] _buffer;
    private int _index;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) _producerBufferIndex;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) _consumerBufferIndex;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _done;
    private T[] _producerChunk;
    private int _producerChunkIndex;
    private T[] _consumerChunk;
    private int _consumerChunkIndex;
    private int _chunkSize;
    private ManualResetEventSlim _producerEvent;
    private IntValueEvent _consumerEvent;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) _producerIsWaiting;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) _consumerIsWaiting;
    private CancellationToken _cancellationToken;
    internal bool IsFull { get; }
    internal bool IsChunkBufferEmpty { get; }
    internal bool IsDone { get; }
    internal AsynchronousChannel`1(int index, int chunkSize, CancellationToken cancellationToken, IntValueEvent consumerEvent);
    internal AsynchronousChannel`1(int index, int capacity, int chunkSize, CancellationToken cancellationToken, IntValueEvent consumerEvent);
    internal bool get_IsFull();
    internal bool get_IsChunkBufferEmpty();
    internal bool get_IsDone();
    internal void FlushBuffers();
    internal void SetDone();
    internal void Enqueue(T item);
    private void EnqueueChunk(T[] chunk);
    private void WaitUntilNonFull();
    private void FlushCachedChunk();
    internal bool TryDequeue(T& item);
    private bool TryDequeueChunk(T[]& chunk);
    internal bool TryDequeue(T& item, Boolean& isDone);
    private bool TryDequeueChunk(T[]& chunk, Boolean& isDone);
    private T[] InternalDequeueChunk();
    internal void DoneWithDequeueWait();
    public sealed virtual void Dispose();
}
internal class System.Linq.Parallel.AsynchronousChannelMergeEnumerator`1 : MergeEnumerator`1<T> {
    private AsynchronousChannel`1[] _channels;
    private IntValueEvent _consumerEvent;
    private Boolean[] _done;
    private int _channelIndex;
    private T _currentElement;
    public T Current { get; }
    internal AsynchronousChannelMergeEnumerator`1(QueryTaskGroupState taskGroupState, AsynchronousChannel`1[] channels, IntValueEvent consumerEvent);
    public virtual T get_Current();
    public virtual bool MoveNext();
    private bool MoveNextSlowPath();
    public virtual void Dispose();
}
internal abstract class System.Linq.Parallel.BinaryQueryOperator`3 : QueryOperator`1<TOutput> {
    private QueryOperator`1<TLeftInput> _leftChild;
    private QueryOperator`1<TRightInput> _rightChild;
    private OrdinalIndexState _indexState;
    internal QueryOperator`1<TLeftInput> LeftChild { get; }
    internal QueryOperator`1<TRightInput> RightChild { get; }
    internal OrdinalIndexState OrdinalIndexState { get; }
    internal BinaryQueryOperator`3(ParallelQuery`1<TLeftInput> leftChild, ParallelQuery`1<TRightInput> rightChild);
    internal BinaryQueryOperator`3(QueryOperator`1<TLeftInput> leftChild, QueryOperator`1<TRightInput> rightChild);
    internal QueryOperator`1<TLeftInput> get_LeftChild();
    internal QueryOperator`1<TRightInput> get_RightChild();
    internal sealed virtual OrdinalIndexState get_OrdinalIndexState();
    protected void SetOrdinalIndex(OrdinalIndexState indexState);
    public abstract virtual void WrapPartitionedStream(PartitionedStream`2<TLeftInput, TLeftKey> leftPartitionedStream, PartitionedStream`2<TRightInput, TRightKey> rightPartitionedStream, IPartitionedStreamRecipient`1<TOutput> outputRecipient, bool preferStriping, QuerySettings settings);
}
internal static class System.Linq.Parallel.CancellableEnumerable : object {
    [IteratorStateMachineAttribute("System.Linq.Parallel.CancellableEnumerable/<Wrap>d__0`1")]
internal static IEnumerable`1<TElement> Wrap(IEnumerable`1<TElement> source, CancellationToken token);
}
internal class System.Linq.Parallel.CancellationState : object {
    internal CancellationTokenSource InternalCancellationTokenSource;
    internal CancellationToken ExternalCancellationToken;
    internal CancellationTokenSource MergedCancellationTokenSource;
    internal Shared`1<bool> TopLevelDisposedFlag;
    internal static int POLL_INTERVAL;
    internal CancellationToken MergedCancellationToken { get; }
    internal CancellationState(CancellationToken externalCancellationToken);
    internal CancellationToken get_MergedCancellationToken();
    internal static void ThrowIfCanceled(CancellationToken token);
    internal static void ThrowWithStandardMessageIfCanceled(CancellationToken externalCancellationToken);
}
internal class System.Linq.Parallel.ConcatKey`2 : ValueType {
    private TLeftKey _leftKey;
    private TRightKey _rightKey;
    private bool _isLeft;
    private ConcatKey`2(TLeftKey leftKey, TRightKey rightKey, bool isLeft);
    internal static ConcatKey`2<TLeftKey, TRightKey> MakeLeft(TLeftKey leftKey);
    internal static ConcatKey`2<TLeftKey, TRightKey> MakeRight(TRightKey rightKey);
    internal static IComparer`1<ConcatKey`2<TLeftKey, TRightKey>> MakeComparer(IComparer`1<TLeftKey> leftComparer, IComparer`1<TRightKey> rightComparer);
}
internal class System.Linq.Parallel.ConcatQueryOperator`1 : BinaryQueryOperator`3<TSource, TSource, TSource> {
    private bool _prematureMergeLeft;
    private bool _prematureMergeRight;
    internal bool LimitsParallelism { get; }
    internal ConcatQueryOperator`1(ParallelQuery`1<TSource> firstChild, ParallelQuery`1<TSource> secondChild);
    internal virtual QueryResults`1<TSource> Open(QuerySettings settings, bool preferStriping);
    public virtual void WrapPartitionedStream(PartitionedStream`2<TSource, TLeftKey> leftStream, PartitionedStream`2<TSource, TRightKey> rightStream, IPartitionedStreamRecipient`1<TSource> outputRecipient, bool preferStriping, QuerySettings settings);
    private void WrapHelper(PartitionedStream`2<TSource, TLeftKey> leftStreamInc, PartitionedStream`2<TSource, TRightKey> rightStream, IPartitionedStreamRecipient`1<TSource> outputRecipient, QuerySettings settings, bool preferStriping);
    private void WrapHelper2(PartitionedStream`2<TSource, TLeftKey> leftStreamInc, PartitionedStream`2<TSource, TRightKey> rightStreamInc, IPartitionedStreamRecipient`1<TSource> outputRecipient);
    internal virtual IEnumerable`1<TSource> AsSequentialQuery(CancellationToken token);
    internal virtual bool get_LimitsParallelism();
}
internal class System.Linq.Parallel.ContainsSearchOperator`1 : UnaryQueryOperator`2<TInput, bool> {
    private TInput _searchValue;
    private IEqualityComparer`1<TInput> _comparer;
    internal bool LimitsParallelism { get; }
    internal ContainsSearchOperator`1(IEnumerable`1<TInput> child, TInput searchValue, IEqualityComparer`1<TInput> comparer);
    internal bool Aggregate();
    internal virtual QueryResults`1<bool> Open(QuerySettings settings, bool preferStriping);
    internal virtual void WrapPartitionedStream(PartitionedStream`2<TInput, TKey> inputStream, IPartitionedStreamRecipient`1<bool> recipient, bool preferStriping, QuerySettings settings);
    [ExcludeFromCodeCoverageAttribute]
internal virtual IEnumerable`1<bool> AsSequentialQuery(CancellationToken token);
    internal virtual bool get_LimitsParallelism();
}
internal class System.Linq.Parallel.CountAggregationOperator`1 : InlinedAggregationOperator`3<TSource, int, int> {
    internal CountAggregationOperator`1(IEnumerable`1<TSource> child);
    protected virtual int InternalAggregate(Exception& singularExceptionToThrow);
    protected virtual QueryOperatorEnumerator`2<int, int> CreateEnumerator(int index, int count, QueryOperatorEnumerator`2<TSource, TKey> source, object sharedData, CancellationToken cancellationToken);
}
internal class System.Linq.Parallel.DecimalAverageAggregationOperator : InlinedAggregationOperator`3<decimal, Pair`2<decimal, long>, decimal> {
    internal DecimalAverageAggregationOperator(IEnumerable`1<decimal> child);
    protected virtual decimal InternalAggregate(Exception& singularExceptionToThrow);
    protected virtual QueryOperatorEnumerator`2<Pair`2<decimal, long>, int> CreateEnumerator(int index, int count, QueryOperatorEnumerator`2<decimal, TKey> source, object sharedData, CancellationToken cancellationToken);
}
internal class System.Linq.Parallel.DecimalMinMaxAggregationOperator : InlinedAggregationOperator`3<decimal, decimal, decimal> {
    private int _sign;
    internal DecimalMinMaxAggregationOperator(IEnumerable`1<decimal> child, int sign);
    protected virtual decimal InternalAggregate(Exception& singularExceptionToThrow);
    protected virtual QueryOperatorEnumerator`2<decimal, int> CreateEnumerator(int index, int count, QueryOperatorEnumerator`2<decimal, TKey> source, object sharedData, CancellationToken cancellationToken);
}
internal class System.Linq.Parallel.DecimalSumAggregationOperator : InlinedAggregationOperator`3<decimal, decimal, decimal> {
    internal DecimalSumAggregationOperator(IEnumerable`1<decimal> child);
    protected virtual decimal InternalAggregate(Exception& singularExceptionToThrow);
    protected virtual QueryOperatorEnumerator`2<decimal, int> CreateEnumerator(int index, int count, QueryOperatorEnumerator`2<decimal, TKey> source, object sharedData, CancellationToken cancellationToken);
}
internal class System.Linq.Parallel.DefaultIfEmptyQueryOperator`1 : UnaryQueryOperator`2<TSource, TSource> {
    private TSource _defaultValue;
    internal bool LimitsParallelism { get; }
    internal DefaultIfEmptyQueryOperator`1(IEnumerable`1<TSource> child, TSource defaultValue);
    internal virtual QueryResults`1<TSource> Open(QuerySettings settings, bool preferStriping);
    internal virtual void WrapPartitionedStream(PartitionedStream`2<TSource, TKey> inputStream, IPartitionedStreamRecipient`1<TSource> recipient, bool preferStriping, QuerySettings settings);
    internal virtual IEnumerable`1<TSource> AsSequentialQuery(CancellationToken token);
    internal virtual bool get_LimitsParallelism();
}
internal class System.Linq.Parallel.DefaultMergeHelper`2 : object {
    private QueryTaskGroupState _taskGroupState;
    private PartitionedStream`2<TInputOutput, TIgnoreKey> _partitions;
    private AsynchronousChannel`1[] _asyncChannels;
    private SynchronousChannel`1[] _syncChannels;
    private IEnumerator`1<TInputOutput> _channelEnumerator;
    private TaskScheduler _taskScheduler;
    private bool _ignoreOutput;
    internal DefaultMergeHelper`2(PartitionedStream`2<TInputOutput, TIgnoreKey> partitions, bool ignoreOutput, ParallelMergeOptions options, TaskScheduler taskScheduler, CancellationState cancellationState, int queryId);
    private sealed virtual override void System.Linq.Parallel.IMergeHelper<TInputOutput>.Execute();
    private sealed virtual override IEnumerator`1<TInputOutput> System.Linq.Parallel.IMergeHelper<TInputOutput>.GetEnumerator();
    public sealed virtual TInputOutput[] GetResultsAsArray();
}
internal class System.Linq.Parallel.DistinctQueryOperator`1 : UnaryQueryOperator`2<TInputOutput, TInputOutput> {
    private IEqualityComparer`1<TInputOutput> _comparer;
    internal bool LimitsParallelism { get; }
    internal DistinctQueryOperator`1(IEnumerable`1<TInputOutput> source, IEqualityComparer`1<TInputOutput> comparer);
    internal virtual QueryResults`1<TInputOutput> Open(QuerySettings settings, bool preferStriping);
    internal virtual void WrapPartitionedStream(PartitionedStream`2<TInputOutput, TKey> inputStream, IPartitionedStreamRecipient`1<TInputOutput> recipient, bool preferStriping, QuerySettings settings);
    private void WrapPartitionedStreamHelper(PartitionedStream`2<Pair`2<TInputOutput, NoKeyMemoizationRequired>, TKey> hashStream, IPartitionedStreamRecipient`1<TInputOutput> recipient, CancellationToken cancellationToken);
    internal virtual bool get_LimitsParallelism();
    internal virtual IEnumerable`1<TInputOutput> AsSequentialQuery(CancellationToken token);
}
internal class System.Linq.Parallel.DoubleAverageAggregationOperator : InlinedAggregationOperator`3<double, Pair`2<double, long>, double> {
    internal DoubleAverageAggregationOperator(IEnumerable`1<double> child);
    protected virtual double InternalAggregate(Exception& singularExceptionToThrow);
    protected virtual QueryOperatorEnumerator`2<Pair`2<double, long>, int> CreateEnumerator(int index, int count, QueryOperatorEnumerator`2<double, TKey> source, object sharedData, CancellationToken cancellationToken);
}
internal class System.Linq.Parallel.DoubleMinMaxAggregationOperator : InlinedAggregationOperator`3<double, double, double> {
    private int _sign;
    internal DoubleMinMaxAggregationOperator(IEnumerable`1<double> child, int sign);
    protected virtual double InternalAggregate(Exception& singularExceptionToThrow);
    protected virtual QueryOperatorEnumerator`2<double, int> CreateEnumerator(int index, int count, QueryOperatorEnumerator`2<double, TKey> source, object sharedData, CancellationToken cancellationToken);
}
internal class System.Linq.Parallel.DoubleSumAggregationOperator : InlinedAggregationOperator`3<double, double, double> {
    internal DoubleSumAggregationOperator(IEnumerable`1<double> child);
    protected virtual double InternalAggregate(Exception& singularExceptionToThrow);
    protected virtual QueryOperatorEnumerator`2<double, int> CreateEnumerator(int index, int count, QueryOperatorEnumerator`2<double, TKey> source, object sharedData, CancellationToken cancellationToken);
}
internal class System.Linq.Parallel.ElementAtQueryOperator`1 : UnaryQueryOperator`2<TSource, TSource> {
    private int _index;
    private bool _prematureMerge;
    private bool _limitsParallelism;
    internal bool LimitsParallelism { get; }
    internal ElementAtQueryOperator`1(IEnumerable`1<TSource> child, int index);
    internal virtual QueryResults`1<TSource> Open(QuerySettings settings, bool preferStriping);
    internal virtual void WrapPartitionedStream(PartitionedStream`2<TSource, TKey> inputStream, IPartitionedStreamRecipient`1<TSource> recipient, bool preferStriping, QuerySettings settings);
    [ExcludeFromCodeCoverageAttribute]
internal virtual IEnumerable`1<TSource> AsSequentialQuery(CancellationToken token);
    internal virtual bool get_LimitsParallelism();
    internal bool Aggregate(TSource& result, bool withDefaultValue);
}
internal class System.Linq.Parallel.EmptyEnumerable`1 : ParallelQuery`1<T> {
    private static EmptyEnumerable`1 modreq(System.Runtime.CompilerServices.IsVolatile) s_instance;
    private static EmptyEnumerator`1 modreq(System.Runtime.CompilerServices.IsVolatile) s_enumeratorInstance;
    internal static EmptyEnumerable`1<T> Instance { get; }
    internal static EmptyEnumerable`1<T> get_Instance();
    public virtual IEnumerator`1<T> GetEnumerator();
}
internal class System.Linq.Parallel.EmptyEnumerator`1 : QueryOperatorEnumerator`2<T, int> {
    public T Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    internal virtual bool MoveNext(T& currentElement, Int32& currentKey);
    public sealed virtual T get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual bool MoveNext();
    private sealed virtual override void System.Collections.IEnumerator.Reset();
}
internal class System.Linq.Parallel.EnumerableWrapperWeakToStrong : object {
    private IEnumerable _wrappedEnumerable;
    internal EnumerableWrapperWeakToStrong(IEnumerable wrappedEnumerable);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual IEnumerator`1<object> GetEnumerator();
}
internal static class System.Linq.Parallel.ExceptionAggregator : object {
    [IteratorStateMachineAttribute("System.Linq.Parallel.ExceptionAggregator/<WrapEnumerable>d__0`1")]
internal static IEnumerable`1<TElement> WrapEnumerable(IEnumerable`1<TElement> source, CancellationState cancellationState);
    [IteratorStateMachineAttribute("System.Linq.Parallel.ExceptionAggregator/<WrapQueryEnumerator>d__1`2")]
internal static IEnumerable`1<TElement> WrapQueryEnumerator(QueryOperatorEnumerator`2<TElement, TIgnoreKey> source, CancellationState cancellationState);
    internal static void ThrowOCEorAggregateException(Exception ex, CancellationState cancellationState);
    internal static Func`2<T, U> WrapFunc(Func`2<T, U> f, CancellationState cancellationState);
    private static bool ThrowAnOCE(Exception ex, CancellationState cancellationState);
}
internal class System.Linq.Parallel.ExceptQueryOperator`1 : BinaryQueryOperator`3<TInputOutput, TInputOutput, TInputOutput> {
    private IEqualityComparer`1<TInputOutput> _comparer;
    internal bool LimitsParallelism { get; }
    internal ExceptQueryOperator`1(ParallelQuery`1<TInputOutput> left, ParallelQuery`1<TInputOutput> right, IEqualityComparer`1<TInputOutput> comparer);
    internal virtual QueryResults`1<TInputOutput> Open(QuerySettings settings, bool preferStriping);
    public virtual void WrapPartitionedStream(PartitionedStream`2<TInputOutput, TLeftKey> leftStream, PartitionedStream`2<TInputOutput, TRightKey> rightStream, IPartitionedStreamRecipient`1<TInputOutput> outputRecipient, bool preferStriping, QuerySettings settings);
    private void WrapPartitionedStreamHelper(PartitionedStream`2<Pair`2<TInputOutput, NoKeyMemoizationRequired>, TLeftKey> leftHashStream, PartitionedStream`2<TInputOutput, TRightKey> rightPartitionedStream, IPartitionedStreamRecipient`1<TInputOutput> outputRecipient, CancellationToken cancellationToken);
    internal virtual IEnumerable`1<TInputOutput> AsSequentialQuery(CancellationToken token);
    internal virtual bool get_LimitsParallelism();
}
[ExtensionAttribute]
internal static class System.Linq.Parallel.ExchangeUtilities : object {
    internal static PartitionedStream`2<T, int> PartitionDataSource(IEnumerable`1<T> source, int partitionCount, bool useStriping);
    internal static PartitionedStream`2<Pair`2<TElement, THashKey>, int> HashRepartition(PartitionedStream`2<TElement, TIgnoreKey> source, Func`2<TElement, THashKey> keySelector, IEqualityComparer`1<THashKey> keyComparer, IEqualityComparer`1<TElement> elementComparer, CancellationToken cancellationToken);
    internal static PartitionedStream`2<Pair`2<TElement, THashKey>, TOrderKey> HashRepartitionOrdered(PartitionedStream`2<TElement, TOrderKey> source, Func`2<TElement, THashKey> keySelector, IEqualityComparer`1<THashKey> keyComparer, IEqualityComparer`1<TElement> elementComparer, CancellationToken cancellationToken);
    [ExtensionAttribute]
internal static OrdinalIndexState Worse(OrdinalIndexState state1, OrdinalIndexState state2);
    [ExtensionAttribute]
internal static bool IsWorseThan(OrdinalIndexState state1, OrdinalIndexState state2);
}
internal class System.Linq.Parallel.FirstQueryOperator`1 : UnaryQueryOperator`2<TSource, TSource> {
    private Func`2<TSource, bool> _predicate;
    private bool _prematureMergeNeeded;
    internal bool LimitsParallelism { get; }
    internal FirstQueryOperator`1(IEnumerable`1<TSource> child, Func`2<TSource, bool> predicate);
    internal virtual QueryResults`1<TSource> Open(QuerySettings settings, bool preferStriping);
    internal virtual void WrapPartitionedStream(PartitionedStream`2<TSource, TKey> inputStream, IPartitionedStreamRecipient`1<TSource> recipient, bool preferStriping, QuerySettings settings);
    private void WrapHelper(PartitionedStream`2<TSource, TKey> inputStream, IPartitionedStreamRecipient`1<TSource> recipient, QuerySettings settings);
    [ExcludeFromCodeCoverageAttribute]
internal virtual IEnumerable`1<TSource> AsSequentialQuery(CancellationToken token);
    internal virtual bool get_LimitsParallelism();
}
internal class System.Linq.Parallel.FixedMaxHeap`1 : object {
    private TElement[] _elements;
    private int _count;
    private IComparer`1<TElement> _comparer;
    internal int Count { get; }
    internal int Size { get; }
    internal TElement MaxValue { get; }
    internal FixedMaxHeap`1(int maximumSize);
    internal FixedMaxHeap`1(int maximumSize, IComparer`1<TElement> comparer);
    internal int get_Count();
    internal int get_Size();
    internal TElement get_MaxValue();
    internal void Clear();
    internal bool Insert(TElement e);
    internal void ReplaceMax(TElement newValue);
    internal void RemoveMax();
    private void Swap(int i, int j);
    private void HeapifyRoot();
    private void HeapifyLastLeaf();
}
internal class System.Linq.Parallel.FloatAverageAggregationOperator : InlinedAggregationOperator`3<float, Pair`2<double, long>, float> {
    internal FloatAverageAggregationOperator(IEnumerable`1<float> child);
    protected virtual float InternalAggregate(Exception& singularExceptionToThrow);
    protected virtual QueryOperatorEnumerator`2<Pair`2<double, long>, int> CreateEnumerator(int index, int count, QueryOperatorEnumerator`2<float, TKey> source, object sharedData, CancellationToken cancellationToken);
}
internal class System.Linq.Parallel.FloatMinMaxAggregationOperator : InlinedAggregationOperator`3<float, float, float> {
    private int _sign;
    internal FloatMinMaxAggregationOperator(IEnumerable`1<float> child, int sign);
    protected virtual float InternalAggregate(Exception& singularExceptionToThrow);
    protected virtual QueryOperatorEnumerator`2<float, int> CreateEnumerator(int index, int count, QueryOperatorEnumerator`2<float, TKey> source, object sharedData, CancellationToken cancellationToken);
}
internal class System.Linq.Parallel.FloatSumAggregationOperator : InlinedAggregationOperator`3<float, double, float> {
    internal FloatSumAggregationOperator(IEnumerable`1<float> child);
    protected virtual float InternalAggregate(Exception& singularExceptionToThrow);
    protected virtual QueryOperatorEnumerator`2<double, int> CreateEnumerator(int index, int count, QueryOperatorEnumerator`2<float, TKey> source, object sharedData, CancellationToken cancellationToken);
}
internal class System.Linq.Parallel.ForAllOperator`1 : UnaryQueryOperator`2<TInput, TInput> {
    private Action`1<TInput> _elementAction;
    internal bool LimitsParallelism { get; }
    internal ForAllOperator`1(IEnumerable`1<TInput> child, Action`1<TInput> elementAction);
    internal void RunSynchronously();
    internal virtual QueryResults`1<TInput> Open(QuerySettings settings, bool preferStriping);
    internal virtual void WrapPartitionedStream(PartitionedStream`2<TInput, TKey> inputStream, IPartitionedStreamRecipient`1<TInput> recipient, bool preferStriping, QuerySettings settings);
    [ExcludeFromCodeCoverageAttribute]
internal virtual IEnumerable`1<TInput> AsSequentialQuery(CancellationToken token);
    internal virtual bool get_LimitsParallelism();
}
internal class System.Linq.Parallel.ForAllSpoolingTask`2 : SpoolingTaskBase {
    private QueryOperatorEnumerator`2<TInputOutput, TIgnoreKey> _source;
    internal ForAllSpoolingTask`2(int taskIndex, QueryTaskGroupState groupState, QueryOperatorEnumerator`2<TInputOutput, TIgnoreKey> source);
    protected virtual void SpoolingWork();
    protected virtual void SpoolingFinally();
}
internal class System.Linq.Parallel.GroupByElementSelectorQueryOperatorEnumerator`4 : GroupByQueryOperatorEnumerator`4<TSource, TGroupKey, TElement, TOrderKey> {
    private Func`2<TSource, TElement> _elementSelector;
    internal GroupByElementSelectorQueryOperatorEnumerator`4(QueryOperatorEnumerator`2<Pair`2<TSource, TGroupKey>, TOrderKey> source, IEqualityComparer`1<TGroupKey> keyComparer, Func`2<TSource, TElement> elementSelector, CancellationToken cancellationToken);
    protected virtual HashLookup`2<Wrapper`1<TGroupKey>, ListChunk`1<TElement>> BuildHashLookup();
}
internal class System.Linq.Parallel.GroupByGrouping`2 : object {
    private KeyValuePair`2<Wrapper`1<TGroupKey>, ListChunk`1<TElement>> _keyValues;
    private TGroupKey System.Linq.IGrouping<TGroupKey,TElement>.Key { get; }
    internal GroupByGrouping`2(KeyValuePair`2<Wrapper`1<TGroupKey>, ListChunk`1<TElement>> keyValues);
    private sealed virtual override TGroupKey System.Linq.IGrouping<TGroupKey,TElement>.get_Key();
    private sealed virtual override IEnumerator`1<TElement> System.Collections.Generic.IEnumerable<TElement>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal class System.Linq.Parallel.GroupByIdentityQueryOperatorEnumerator`3 : GroupByQueryOperatorEnumerator`4<TSource, TGroupKey, TSource, TOrderKey> {
    internal GroupByIdentityQueryOperatorEnumerator`3(QueryOperatorEnumerator`2<Pair`2<TSource, TGroupKey>, TOrderKey> source, IEqualityComparer`1<TGroupKey> keyComparer, CancellationToken cancellationToken);
    protected virtual HashLookup`2<Wrapper`1<TGroupKey>, ListChunk`1<TSource>> BuildHashLookup();
}
internal class System.Linq.Parallel.GroupByQueryOperator`3 : UnaryQueryOperator`2<TSource, IGrouping`2<TGroupKey, TElement>> {
    private Func`2<TSource, TGroupKey> _keySelector;
    private Func`2<TSource, TElement> _elementSelector;
    private IEqualityComparer`1<TGroupKey> _keyComparer;
    internal bool LimitsParallelism { get; }
    internal GroupByQueryOperator`3(IEnumerable`1<TSource> child, Func`2<TSource, TGroupKey> keySelector, Func`2<TSource, TElement> elementSelector, IEqualityComparer`1<TGroupKey> keyComparer);
    internal virtual void WrapPartitionedStream(PartitionedStream`2<TSource, TKey> inputStream, IPartitionedStreamRecipient`1<IGrouping`2<TGroupKey, TElement>> recipient, bool preferStriping, QuerySettings settings);
    private void WrapPartitionedStreamHelper(PartitionedStream`2<Pair`2<TSource, TGroupKey>, TKey> hashStream, IPartitionedStreamRecipient`1<IGrouping`2<TGroupKey, TElement>> recipient, CancellationToken cancellationToken);
    private void WrapPartitionedStreamHelperOrdered(PartitionedStream`2<Pair`2<TSource, TGroupKey>, TKey> hashStream, IPartitionedStreamRecipient`1<IGrouping`2<TGroupKey, TElement>> recipient, CancellationToken cancellationToken);
    internal virtual QueryResults`1<IGrouping`2<TGroupKey, TElement>> Open(QuerySettings settings, bool preferStriping);
    internal virtual IEnumerable`1<IGrouping`2<TGroupKey, TElement>> AsSequentialQuery(CancellationToken token);
    internal virtual bool get_LimitsParallelism();
}
internal abstract class System.Linq.Parallel.GroupByQueryOperatorEnumerator`4 : QueryOperatorEnumerator`2<IGrouping`2<TGroupKey, TElement>, TOrderKey> {
    protected QueryOperatorEnumerator`2<Pair`2<TSource, TGroupKey>, TOrderKey> _source;
    protected IEqualityComparer`1<TGroupKey> _keyComparer;
    protected CancellationToken _cancellationToken;
    private Mutables<TSource, TGroupKey, TElement, TOrderKey> _mutables;
    protected GroupByQueryOperatorEnumerator`4(QueryOperatorEnumerator`2<Pair`2<TSource, TGroupKey>, TOrderKey> source, IEqualityComparer`1<TGroupKey> keyComparer, CancellationToken cancellationToken);
    internal virtual bool MoveNext(IGrouping`2& currentElement, TOrderKey& currentKey);
    protected abstract virtual HashLookup`2<Wrapper`1<TGroupKey>, ListChunk`1<TElement>> BuildHashLookup();
    protected virtual void Dispose(bool disposing);
}
internal class System.Linq.Parallel.GroupJoinQueryOperator`4 : BinaryQueryOperator`3<TLeftInput, TRightInput, TOutput> {
    private Func`2<TLeftInput, TKey> _leftKeySelector;
    private Func`2<TRightInput, TKey> _rightKeySelector;
    private Func`3<TLeftInput, IEnumerable`1<TRightInput>, TOutput> _resultSelector;
    private IEqualityComparer`1<TKey> _keyComparer;
    internal bool LimitsParallelism { get; }
    internal GroupJoinQueryOperator`4(ParallelQuery`1<TLeftInput> left, ParallelQuery`1<TRightInput> right, Func`2<TLeftInput, TKey> leftKeySelector, Func`2<TRightInput, TKey> rightKeySelector, Func`3<TLeftInput, IEnumerable`1<TRightInput>, TOutput> resultSelector, IEqualityComparer`1<TKey> keyComparer);
    internal virtual QueryResults`1<TOutput> Open(QuerySettings settings, bool preferStriping);
    public virtual void WrapPartitionedStream(PartitionedStream`2<TLeftInput, TLeftKey> leftStream, PartitionedStream`2<TRightInput, TRightKey> rightStream, IPartitionedStreamRecipient`1<TOutput> outputRecipient, bool preferStriping, QuerySettings settings);
    private void WrapPartitionedStreamHelper(PartitionedStream`2<Pair`2<TLeftInput, TKey>, TLeftKey> leftHashStream, PartitionedStream`2<TRightInput, TRightKey> rightPartitionedStream, IPartitionedStreamRecipient`1<TOutput> outputRecipient, int partitionCount, CancellationToken cancellationToken);
    internal virtual IEnumerable`1<TOutput> AsSequentialQuery(CancellationToken token);
    internal virtual bool get_LimitsParallelism();
}
internal class System.Linq.Parallel.GrowingArray`1 : object {
    private T[] _array;
    private int _count;
    private static int DEFAULT_ARRAY_SIZE;
    internal T[] InternalArray { get; }
    internal int Count { get; }
    internal T[] get_InternalArray();
    internal int get_Count();
    internal void Add(T element);
    private void GrowArray(int newSize);
    internal void CopyFrom(T[] otherArray, int otherCount);
}
internal class System.Linq.Parallel.HashJoinQueryOperatorEnumerator`5 : QueryOperatorEnumerator`2<TOutput, TLeftKey> {
    private QueryOperatorEnumerator`2<Pair`2<TLeftInput, THashKey>, TLeftKey> _leftSource;
    private QueryOperatorEnumerator`2<Pair`2<TRightInput, THashKey>, int> _rightSource;
    private Func`3<TLeftInput, TRightInput, TOutput> _singleResultSelector;
    private Func`3<TLeftInput, IEnumerable`1<TRightInput>, TOutput> _groupResultSelector;
    private IEqualityComparer`1<THashKey> _keyComparer;
    private CancellationToken _cancellationToken;
    private Mutables<TLeftInput, TLeftKey, TRightInput, THashKey, TOutput> _mutables;
    internal HashJoinQueryOperatorEnumerator`5(QueryOperatorEnumerator`2<Pair`2<TLeftInput, THashKey>, TLeftKey> leftSource, QueryOperatorEnumerator`2<Pair`2<TRightInput, THashKey>, int> rightSource, Func`3<TLeftInput, TRightInput, TOutput> singleResultSelector, Func`3<TLeftInput, IEnumerable`1<TRightInput>, TOutput> groupResultSelector, IEqualityComparer`1<THashKey> keyComparer, CancellationToken cancellationToken);
    internal virtual bool MoveNext(TOutput& currentElement, TLeftKey& currentKey);
    protected virtual void Dispose(bool disposing);
}
[DefaultMemberAttribute("Item")]
internal class System.Linq.Parallel.HashLookup`2 : object {
    private Int32[] buckets;
    private Slot[] slots;
    private int count;
    private int freeList;
    private IEqualityComparer`1<TKey> comparer;
    private static int HashCodeMask;
    unknown TValue Item {internal set; }
    internal int Count { get; }
    internal KeyValuePair`2<TKey, TValue> Item { get; }
    internal HashLookup`2(IEqualityComparer`1<TKey> comparer);
    internal bool Add(TKey key, TValue value);
    internal bool TryGetValue(TKey key, TValue& value);
    internal void set_Item(TKey key, TValue value);
    private int GetKeyHashCode(TKey key);
    private bool AreKeysEqual(TKey key1, TKey key2);
    private bool Find(TKey key, bool add, bool set, TValue& value);
    private void Resize();
    internal int get_Count();
    internal KeyValuePair`2<TKey, TValue> get_Item(int index);
}
internal class System.Linq.Parallel.HashRepartitionEnumerator`3 : QueryOperatorEnumerator`2<Pair`2<TInputOutput, THashKey>, int> {
    private static int ENUMERATION_NOT_STARTED;
    private int _partitionCount;
    private int _partitionIndex;
    private Func`2<TInputOutput, THashKey> _keySelector;
    private HashRepartitionStream`3<TInputOutput, THashKey, int> _repartitionStream;
    private ListChunk`1[][] _valueExchangeMatrix;
    private QueryOperatorEnumerator`2<TInputOutput, TIgnoreKey> _source;
    private CountdownEvent _barrier;
    private CancellationToken _cancellationToken;
    private Mutables<TInputOutput, THashKey, TIgnoreKey> _mutables;
    internal HashRepartitionEnumerator`3(QueryOperatorEnumerator`2<TInputOutput, TIgnoreKey> source, int partitionCount, int partitionIndex, Func`2<TInputOutput, THashKey> keySelector, HashRepartitionStream`3<TInputOutput, THashKey, int> repartitionStream, CountdownEvent barrier, ListChunk`1[][] valueExchangeMatrix, CancellationToken cancellationToken);
    internal virtual bool MoveNext(Pair`2& currentElement, Int32& currentKey);
    private void EnumerateAndRedistributeElements();
    protected virtual void Dispose(bool disposed);
}
internal abstract class System.Linq.Parallel.HashRepartitionStream`3 : PartitionedStream`2<Pair`2<TInputOutput, THashKey>, TOrderKey> {
    private IEqualityComparer`1<THashKey> _keyComparer;
    private IEqualityComparer`1<TInputOutput> _elementComparer;
    private int _distributionMod;
    private static int NULL_ELEMENT_HASH_CODE;
    private static int HashCodeMask;
    internal HashRepartitionStream`3(int partitionsCount, IComparer`1<TOrderKey> orderKeyComparer, IEqualityComparer`1<THashKey> hashKeyComparer, IEqualityComparer`1<TInputOutput> elementComparer);
    internal int GetHashCode(TInputOutput element);
    internal int GetHashCode(THashKey key);
}
internal interface System.Linq.Parallel.IMergeHelper`1 {
    public abstract virtual void Execute();
    public abstract virtual IEnumerator`1<TInputOutput> GetEnumerator();
    public abstract virtual TInputOutput[] GetResultsAsArray();
}
internal class System.Linq.Parallel.IndexedSelectQueryOperator`2 : UnaryQueryOperator`2<TInput, TOutput> {
    private Func`3<TInput, int, TOutput> _selector;
    private bool _prematureMerge;
    private bool _limitsParallelism;
    internal bool LimitsParallelism { get; }
    internal IndexedSelectQueryOperator`2(IEnumerable`1<TInput> child, Func`3<TInput, int, TOutput> selector);
    private void InitOrdinalIndexState();
    internal virtual QueryResults`1<TOutput> Open(QuerySettings settings, bool preferStriping);
    internal virtual void WrapPartitionedStream(PartitionedStream`2<TInput, TKey> inputStream, IPartitionedStreamRecipient`1<TOutput> recipient, bool preferStriping, QuerySettings settings);
    internal virtual bool get_LimitsParallelism();
    internal virtual IEnumerable`1<TOutput> AsSequentialQuery(CancellationToken token);
}
internal class System.Linq.Parallel.IndexedWhereQueryOperator`1 : UnaryQueryOperator`2<TInputOutput, TInputOutput> {
    private Func`3<TInputOutput, int, bool> _predicate;
    private bool _prematureMerge;
    private bool _limitsParallelism;
    internal bool LimitsParallelism { get; }
    internal IndexedWhereQueryOperator`1(IEnumerable`1<TInputOutput> child, Func`3<TInputOutput, int, bool> predicate);
    private void InitOrdinalIndexState();
    internal virtual QueryResults`1<TInputOutput> Open(QuerySettings settings, bool preferStriping);
    internal virtual void WrapPartitionedStream(PartitionedStream`2<TInputOutput, TKey> inputStream, IPartitionedStreamRecipient`1<TInputOutput> recipient, bool preferStriping, QuerySettings settings);
    internal virtual IEnumerable`1<TInputOutput> AsSequentialQuery(CancellationToken token);
    internal virtual bool get_LimitsParallelism();
}
internal abstract class System.Linq.Parallel.InlinedAggregationOperator`3 : UnaryQueryOperator`2<TSource, TIntermediate> {
    internal bool LimitsParallelism { get; }
    internal InlinedAggregationOperator`3(IEnumerable`1<TSource> child);
    internal TResult Aggregate();
    protected abstract virtual TResult InternalAggregate(Exception& singularExceptionToThrow);
    internal virtual QueryResults`1<TIntermediate> Open(QuerySettings settings, bool preferStriping);
    internal virtual void WrapPartitionedStream(PartitionedStream`2<TSource, TKey> inputStream, IPartitionedStreamRecipient`1<TIntermediate> recipient, bool preferStriping, QuerySettings settings);
    protected abstract virtual QueryOperatorEnumerator`2<TIntermediate, int> CreateEnumerator(int index, int count, QueryOperatorEnumerator`2<TSource, TKey> source, object sharedData, CancellationToken cancellationToken);
    [ExcludeFromCodeCoverageAttribute]
internal virtual IEnumerable`1<TIntermediate> AsSequentialQuery(CancellationToken token);
    internal virtual bool get_LimitsParallelism();
}
internal abstract class System.Linq.Parallel.InlinedAggregationOperatorEnumerator`1 : QueryOperatorEnumerator`2<TIntermediate, int> {
    private int _partitionIndex;
    private bool _done;
    protected CancellationToken _cancellationToken;
    internal InlinedAggregationOperatorEnumerator`1(int partitionIndex, CancellationToken cancellationToken);
    internal sealed virtual bool MoveNext(TIntermediate& currentElement, Int32& currentKey);
    protected abstract virtual bool MoveNextCore(TIntermediate& currentElement);
}
internal class System.Linq.Parallel.IntAverageAggregationOperator : InlinedAggregationOperator`3<int, Pair`2<long, long>, double> {
    internal IntAverageAggregationOperator(IEnumerable`1<int> child);
    protected virtual double InternalAggregate(Exception& singularExceptionToThrow);
    protected virtual QueryOperatorEnumerator`2<Pair`2<long, long>, int> CreateEnumerator(int index, int count, QueryOperatorEnumerator`2<int, TKey> source, object sharedData, CancellationToken cancellationToken);
}
internal class System.Linq.Parallel.IntersectQueryOperator`1 : BinaryQueryOperator`3<TInputOutput, TInputOutput, TInputOutput> {
    private IEqualityComparer`1<TInputOutput> _comparer;
    internal bool LimitsParallelism { get; }
    internal IntersectQueryOperator`1(ParallelQuery`1<TInputOutput> left, ParallelQuery`1<TInputOutput> right, IEqualityComparer`1<TInputOutput> comparer);
    internal virtual QueryResults`1<TInputOutput> Open(QuerySettings settings, bool preferStriping);
    public virtual void WrapPartitionedStream(PartitionedStream`2<TInputOutput, TLeftKey> leftPartitionedStream, PartitionedStream`2<TInputOutput, TRightKey> rightPartitionedStream, IPartitionedStreamRecipient`1<TInputOutput> outputRecipient, bool preferStriping, QuerySettings settings);
    private void WrapPartitionedStreamHelper(PartitionedStream`2<Pair`2<TInputOutput, NoKeyMemoizationRequired>, TLeftKey> leftHashStream, PartitionedStream`2<TInputOutput, TRightKey> rightPartitionedStream, IPartitionedStreamRecipient`1<TInputOutput> outputRecipient, CancellationToken cancellationToken);
    internal virtual bool get_LimitsParallelism();
    internal virtual IEnumerable`1<TInputOutput> AsSequentialQuery(CancellationToken token);
}
internal class System.Linq.Parallel.IntMinMaxAggregationOperator : InlinedAggregationOperator`3<int, int, int> {
    private int _sign;
    internal IntMinMaxAggregationOperator(IEnumerable`1<int> child, int sign);
    protected virtual int InternalAggregate(Exception& singularExceptionToThrow);
    protected virtual QueryOperatorEnumerator`2<int, int> CreateEnumerator(int index, int count, QueryOperatorEnumerator`2<int, TKey> source, object sharedData, CancellationToken cancellationToken);
}
internal class System.Linq.Parallel.IntSumAggregationOperator : InlinedAggregationOperator`3<int, int, int> {
    internal IntSumAggregationOperator(IEnumerable`1<int> child);
    protected virtual int InternalAggregate(Exception& singularExceptionToThrow);
    protected virtual QueryOperatorEnumerator`2<int, int> CreateEnumerator(int index, int count, QueryOperatorEnumerator`2<int, TKey> source, object sharedData, CancellationToken cancellationToken);
}
internal class System.Linq.Parallel.IntValueEvent : ManualResetEventSlim {
    internal int Value;
    internal void Set(int index);
}
internal interface System.Linq.Parallel.IParallelPartitionable`1 {
    public abstract virtual QueryOperatorEnumerator`2[] GetPartitions(int partitionCount);
}
internal interface System.Linq.Parallel.IPartitionedStreamRecipient`1 {
    public abstract virtual void Receive(PartitionedStream`2<TElement, TKey> partitionedStream);
}
internal class System.Linq.Parallel.JaggedArray`1 : object {
    public static TElement[][] Allocate(int size1, int size2);
}
internal class System.Linq.Parallel.JoinQueryOperator`4 : BinaryQueryOperator`3<TLeftInput, TRightInput, TOutput> {
    private Func`2<TLeftInput, TKey> _leftKeySelector;
    private Func`2<TRightInput, TKey> _rightKeySelector;
    private Func`3<TLeftInput, TRightInput, TOutput> _resultSelector;
    private IEqualityComparer`1<TKey> _keyComparer;
    internal bool LimitsParallelism { get; }
    internal JoinQueryOperator`4(ParallelQuery`1<TLeftInput> left, ParallelQuery`1<TRightInput> right, Func`2<TLeftInput, TKey> leftKeySelector, Func`2<TRightInput, TKey> rightKeySelector, Func`3<TLeftInput, TRightInput, TOutput> resultSelector, IEqualityComparer`1<TKey> keyComparer);
    public virtual void WrapPartitionedStream(PartitionedStream`2<TLeftInput, TLeftKey> leftStream, PartitionedStream`2<TRightInput, TRightKey> rightStream, IPartitionedStreamRecipient`1<TOutput> outputRecipient, bool preferStriping, QuerySettings settings);
    private void WrapPartitionedStreamHelper(PartitionedStream`2<Pair`2<TLeftInput, TKey>, TLeftKey> leftHashStream, PartitionedStream`2<TRightInput, TRightKey> rightPartitionedStream, IPartitionedStreamRecipient`1<TOutput> outputRecipient, CancellationToken cancellationToken);
    internal virtual QueryResults`1<TOutput> Open(QuerySettings settings, bool preferStriping);
    internal virtual IEnumerable`1<TOutput> AsSequentialQuery(CancellationToken token);
    internal virtual bool get_LimitsParallelism();
}
internal class System.Linq.Parallel.LastQueryOperator`1 : UnaryQueryOperator`2<TSource, TSource> {
    private Func`2<TSource, bool> _predicate;
    private bool _prematureMergeNeeded;
    internal bool LimitsParallelism { get; }
    internal LastQueryOperator`1(IEnumerable`1<TSource> child, Func`2<TSource, bool> predicate);
    internal virtual QueryResults`1<TSource> Open(QuerySettings settings, bool preferStriping);
    internal virtual void WrapPartitionedStream(PartitionedStream`2<TSource, TKey> inputStream, IPartitionedStreamRecipient`1<TSource> recipient, bool preferStriping, QuerySettings settings);
    private void WrapHelper(PartitionedStream`2<TSource, TKey> inputStream, IPartitionedStreamRecipient`1<TSource> recipient, QuerySettings settings);
    [ExcludeFromCodeCoverageAttribute]
internal virtual IEnumerable`1<TSource> AsSequentialQuery(CancellationToken token);
    internal virtual bool get_LimitsParallelism();
}
internal class System.Linq.Parallel.ListChunk`1 : object {
    internal TInputOutput[] _chunk;
    private int _chunkCount;
    private ListChunk`1<TInputOutput> _nextChunk;
    private ListChunk`1<TInputOutput> _tailChunk;
    internal ListChunk`1<TInputOutput> Next { get; }
    internal int Count { get; }
    internal ListChunk`1(int size);
    internal void Add(TInputOutput e);
    internal ListChunk`1<TInputOutput> get_Next();
    internal int get_Count();
    [IteratorStateMachineAttribute("System.Linq.Parallel.ListChunk`1/<GetEnumerator>d__10")]
public sealed virtual IEnumerator`1<TInputOutput> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal class System.Linq.Parallel.ListQueryResults`1 : QueryResults`1<T> {
    private IList`1<T> _source;
    private int _partitionCount;
    private bool _useStriping;
    internal bool IsIndexible { get; }
    internal int ElementsCount { get; }
    internal ListQueryResults`1(IList`1<T> source, int partitionCount, bool useStriping);
    internal virtual void GivePartitionedStream(IPartitionedStreamRecipient`1<T> recipient);
    internal virtual bool get_IsIndexible();
    internal virtual int get_ElementsCount();
    internal virtual T GetElement(int index);
    internal PartitionedStream`2<T, int> GetPartitionedStream();
}
internal class System.Linq.Parallel.LongAverageAggregationOperator : InlinedAggregationOperator`3<long, Pair`2<long, long>, double> {
    internal LongAverageAggregationOperator(IEnumerable`1<long> child);
    protected virtual double InternalAggregate(Exception& singularExceptionToThrow);
    protected virtual QueryOperatorEnumerator`2<Pair`2<long, long>, int> CreateEnumerator(int index, int count, QueryOperatorEnumerator`2<long, TKey> source, object sharedData, CancellationToken cancellationToken);
}
internal class System.Linq.Parallel.LongCountAggregationOperator`1 : InlinedAggregationOperator`3<TSource, long, long> {
    internal LongCountAggregationOperator`1(IEnumerable`1<TSource> child);
    protected virtual long InternalAggregate(Exception& singularExceptionToThrow);
    protected virtual QueryOperatorEnumerator`2<long, int> CreateEnumerator(int index, int count, QueryOperatorEnumerator`2<TSource, TKey> source, object sharedData, CancellationToken cancellationToken);
}
internal class System.Linq.Parallel.LongMinMaxAggregationOperator : InlinedAggregationOperator`3<long, long, long> {
    private int _sign;
    internal LongMinMaxAggregationOperator(IEnumerable`1<long> child, int sign);
    protected virtual long InternalAggregate(Exception& singularExceptionToThrow);
    protected virtual QueryOperatorEnumerator`2<long, int> CreateEnumerator(int index, int count, QueryOperatorEnumerator`2<long, TKey> source, object sharedData, CancellationToken cancellationToken);
}
internal class System.Linq.Parallel.LongSumAggregationOperator : InlinedAggregationOperator`3<long, long, long> {
    internal LongSumAggregationOperator(IEnumerable`1<long> child);
    protected virtual long InternalAggregate(Exception& singularExceptionToThrow);
    protected virtual QueryOperatorEnumerator`2<long, int> CreateEnumerator(int index, int count, QueryOperatorEnumerator`2<long, TKey> source, object sharedData, CancellationToken cancellationToken);
}
[DefaultMemberAttribute("Item")]
internal class System.Linq.Parallel.Lookup`2 : object {
    private IDictionary`2<TKey, IGrouping`2<TKey, TElement>> _dict;
    private IEqualityComparer`1<TKey> _comparer;
    private IGrouping`2<TKey, TElement> _defaultKeyGrouping;
    public int Count { get; }
    public IEnumerable`1<TElement> Item { get; }
    internal Lookup`2(IEqualityComparer`1<TKey> comparer);
    public sealed virtual int get_Count();
    public sealed virtual IEnumerable`1<TElement> get_Item(TKey key);
    public sealed virtual bool Contains(TKey key);
    internal void Add(IGrouping`2<TKey, TElement> grouping);
    [IteratorStateMachineAttribute("System.Linq.Parallel.Lookup`2/<GetEnumerator>d__10")]
public sealed virtual IEnumerator`1<IGrouping`2<TKey, TElement>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal abstract class System.Linq.Parallel.MergeEnumerator`1 : object {
    protected QueryTaskGroupState _taskGroupState;
    public TInputOutput Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    protected MergeEnumerator`1(QueryTaskGroupState taskGroupState);
    public abstract virtual TInputOutput get_Current();
    public abstract virtual bool MoveNext();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public virtual void Reset();
    public virtual void Dispose();
}
internal class System.Linq.Parallel.MergeExecutor`1 : object {
    private IMergeHelper`1<TInputOutput> _mergeHelper;
    internal static MergeExecutor`1<TInputOutput> Execute(PartitionedStream`2<TInputOutput, TKey> partitions, bool ignoreOutput, ParallelMergeOptions options, TaskScheduler taskScheduler, bool isOrdered, CancellationState cancellationState, int queryId);
    private void Execute();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual IEnumerator`1<TInputOutput> GetEnumerator();
    internal TInputOutput[] GetResultsAsArray();
    internal static AsynchronousChannel`1[] MakeAsynchronousChannels(int partitionCount, ParallelMergeOptions options, IntValueEvent consumerEvent, CancellationToken cancellationToken);
    internal static SynchronousChannel`1[] MakeSynchronousChannels(int partitionCount);
}
internal class System.Linq.Parallel.NoKeyMemoizationRequired : ValueType {
}
internal class System.Linq.Parallel.NullableDecimalAverageAggregationOperator : InlinedAggregationOperator`3<Nullable`1<decimal>, Pair`2<decimal, long>, Nullable`1<decimal>> {
    internal NullableDecimalAverageAggregationOperator(IEnumerable`1<Nullable`1<decimal>> child);
    protected virtual Nullable`1<decimal> InternalAggregate(Exception& singularExceptionToThrow);
    protected virtual QueryOperatorEnumerator`2<Pair`2<decimal, long>, int> CreateEnumerator(int index, int count, QueryOperatorEnumerator`2<Nullable`1<decimal>, TKey> source, object sharedData, CancellationToken cancellationToken);
}
internal class System.Linq.Parallel.NullableDecimalMinMaxAggregationOperator : InlinedAggregationOperator`3<Nullable`1<decimal>, Nullable`1<decimal>, Nullable`1<decimal>> {
    private int _sign;
    internal NullableDecimalMinMaxAggregationOperator(IEnumerable`1<Nullable`1<decimal>> child, int sign);
    protected virtual Nullable`1<decimal> InternalAggregate(Exception& singularExceptionToThrow);
    protected virtual QueryOperatorEnumerator`2<Nullable`1<decimal>, int> CreateEnumerator(int index, int count, QueryOperatorEnumerator`2<Nullable`1<decimal>, TKey> source, object sharedData, CancellationToken cancellationToken);
}
internal class System.Linq.Parallel.NullableDecimalSumAggregationOperator : InlinedAggregationOperator`3<Nullable`1<decimal>, Nullable`1<decimal>, Nullable`1<decimal>> {
    internal NullableDecimalSumAggregationOperator(IEnumerable`1<Nullable`1<decimal>> child);
    protected virtual Nullable`1<decimal> InternalAggregate(Exception& singularExceptionToThrow);
    protected virtual QueryOperatorEnumerator`2<Nullable`1<decimal>, int> CreateEnumerator(int index, int count, QueryOperatorEnumerator`2<Nullable`1<decimal>, TKey> source, object sharedData, CancellationToken cancellationToken);
}
internal class System.Linq.Parallel.NullableDoubleAverageAggregationOperator : InlinedAggregationOperator`3<Nullable`1<double>, Pair`2<double, long>, Nullable`1<double>> {
    internal NullableDoubleAverageAggregationOperator(IEnumerable`1<Nullable`1<double>> child);
    protected virtual Nullable`1<double> InternalAggregate(Exception& singularExceptionToThrow);
    protected virtual QueryOperatorEnumerator`2<Pair`2<double, long>, int> CreateEnumerator(int index, int count, QueryOperatorEnumerator`2<Nullable`1<double>, TKey> source, object sharedData, CancellationToken cancellationToken);
}
internal class System.Linq.Parallel.NullableDoubleMinMaxAggregationOperator : InlinedAggregationOperator`3<Nullable`1<double>, Nullable`1<double>, Nullable`1<double>> {
    private int _sign;
    internal NullableDoubleMinMaxAggregationOperator(IEnumerable`1<Nullable`1<double>> child, int sign);
    protected virtual Nullable`1<double> InternalAggregate(Exception& singularExceptionToThrow);
    protected virtual QueryOperatorEnumerator`2<Nullable`1<double>, int> CreateEnumerator(int index, int count, QueryOperatorEnumerator`2<Nullable`1<double>, TKey> source, object sharedData, CancellationToken cancellationToken);
}
internal class System.Linq.Parallel.NullableDoubleSumAggregationOperator : InlinedAggregationOperator`3<Nullable`1<double>, Nullable`1<double>, Nullable`1<double>> {
    internal NullableDoubleSumAggregationOperator(IEnumerable`1<Nullable`1<double>> child);
    protected virtual Nullable`1<double> InternalAggregate(Exception& singularExceptionToThrow);
    protected virtual QueryOperatorEnumerator`2<Nullable`1<double>, int> CreateEnumerator(int index, int count, QueryOperatorEnumerator`2<Nullable`1<double>, TKey> source, object sharedData, CancellationToken cancellationToken);
}
internal class System.Linq.Parallel.NullableFloatAverageAggregationOperator : InlinedAggregationOperator`3<Nullable`1<float>, Pair`2<double, long>, Nullable`1<float>> {
    internal NullableFloatAverageAggregationOperator(IEnumerable`1<Nullable`1<float>> child);
    protected virtual Nullable`1<float> InternalAggregate(Exception& singularExceptionToThrow);
    protected virtual QueryOperatorEnumerator`2<Pair`2<double, long>, int> CreateEnumerator(int index, int count, QueryOperatorEnumerator`2<Nullable`1<float>, TKey> source, object sharedData, CancellationToken cancellationToken);
}
internal class System.Linq.Parallel.NullableFloatMinMaxAggregationOperator : InlinedAggregationOperator`3<Nullable`1<float>, Nullable`1<float>, Nullable`1<float>> {
    private int _sign;
    internal NullableFloatMinMaxAggregationOperator(IEnumerable`1<Nullable`1<float>> child, int sign);
    protected virtual Nullable`1<float> InternalAggregate(Exception& singularExceptionToThrow);
    protected virtual QueryOperatorEnumerator`2<Nullable`1<float>, int> CreateEnumerator(int index, int count, QueryOperatorEnumerator`2<Nullable`1<float>, TKey> source, object sharedData, CancellationToken cancellationToken);
}
internal class System.Linq.Parallel.NullableFloatSumAggregationOperator : InlinedAggregationOperator`3<Nullable`1<float>, Nullable`1<double>, Nullable`1<float>> {
    internal NullableFloatSumAggregationOperator(IEnumerable`1<Nullable`1<float>> child);
    protected virtual Nullable`1<float> InternalAggregate(Exception& singularExceptionToThrow);
    protected virtual QueryOperatorEnumerator`2<Nullable`1<double>, int> CreateEnumerator(int index, int count, QueryOperatorEnumerator`2<Nullable`1<float>, TKey> source, object sharedData, CancellationToken cancellationToken);
}
internal class System.Linq.Parallel.NullableIntAverageAggregationOperator : InlinedAggregationOperator`3<Nullable`1<int>, Pair`2<long, long>, Nullable`1<double>> {
    internal NullableIntAverageAggregationOperator(IEnumerable`1<Nullable`1<int>> child);
    protected virtual Nullable`1<double> InternalAggregate(Exception& singularExceptionToThrow);
    protected virtual QueryOperatorEnumerator`2<Pair`2<long, long>, int> CreateEnumerator(int index, int count, QueryOperatorEnumerator`2<Nullable`1<int>, TKey> source, object sharedData, CancellationToken cancellationToken);
}
internal class System.Linq.Parallel.NullableIntMinMaxAggregationOperator : InlinedAggregationOperator`3<Nullable`1<int>, Nullable`1<int>, Nullable`1<int>> {
    private int _sign;
    internal NullableIntMinMaxAggregationOperator(IEnumerable`1<Nullable`1<int>> child, int sign);
    protected virtual Nullable`1<int> InternalAggregate(Exception& singularExceptionToThrow);
    protected virtual QueryOperatorEnumerator`2<Nullable`1<int>, int> CreateEnumerator(int index, int count, QueryOperatorEnumerator`2<Nullable`1<int>, TKey> source, object sharedData, CancellationToken cancellationToken);
}
internal class System.Linq.Parallel.NullableIntSumAggregationOperator : InlinedAggregationOperator`3<Nullable`1<int>, Nullable`1<int>, Nullable`1<int>> {
    internal NullableIntSumAggregationOperator(IEnumerable`1<Nullable`1<int>> child);
    protected virtual Nullable`1<int> InternalAggregate(Exception& singularExceptionToThrow);
    protected virtual QueryOperatorEnumerator`2<Nullable`1<int>, int> CreateEnumerator(int index, int count, QueryOperatorEnumerator`2<Nullable`1<int>, TKey> source, object sharedData, CancellationToken cancellationToken);
}
internal class System.Linq.Parallel.NullableLongAverageAggregationOperator : InlinedAggregationOperator`3<Nullable`1<long>, Pair`2<long, long>, Nullable`1<double>> {
    internal NullableLongAverageAggregationOperator(IEnumerable`1<Nullable`1<long>> child);
    protected virtual Nullable`1<double> InternalAggregate(Exception& singularExceptionToThrow);
    protected virtual QueryOperatorEnumerator`2<Pair`2<long, long>, int> CreateEnumerator(int index, int count, QueryOperatorEnumerator`2<Nullable`1<long>, TKey> source, object sharedData, CancellationToken cancellationToken);
}
internal class System.Linq.Parallel.NullableLongMinMaxAggregationOperator : InlinedAggregationOperator`3<Nullable`1<long>, Nullable`1<long>, Nullable`1<long>> {
    private int _sign;
    internal NullableLongMinMaxAggregationOperator(IEnumerable`1<Nullable`1<long>> child, int sign);
    protected virtual Nullable`1<long> InternalAggregate(Exception& singularExceptionToThrow);
    protected virtual QueryOperatorEnumerator`2<Nullable`1<long>, int> CreateEnumerator(int index, int count, QueryOperatorEnumerator`2<Nullable`1<long>, TKey> source, object sharedData, CancellationToken cancellationToken);
}
internal class System.Linq.Parallel.NullableLongSumAggregationOperator : InlinedAggregationOperator`3<Nullable`1<long>, Nullable`1<long>, Nullable`1<long>> {
    internal NullableLongSumAggregationOperator(IEnumerable`1<Nullable`1<long>> child);
    protected virtual Nullable`1<long> InternalAggregate(Exception& singularExceptionToThrow);
    protected virtual QueryOperatorEnumerator`2<Nullable`1<long>, int> CreateEnumerator(int index, int count, QueryOperatorEnumerator`2<Nullable`1<long>, TKey> source, object sharedData, CancellationToken cancellationToken);
}
internal class System.Linq.Parallel.OrderedGroupByElementSelectorQueryOperatorEnumerator`4 : OrderedGroupByQueryOperatorEnumerator`4<TSource, TGroupKey, TElement, TOrderKey> {
    private Func`2<TSource, TElement> _elementSelector;
    internal OrderedGroupByElementSelectorQueryOperatorEnumerator`4(QueryOperatorEnumerator`2<Pair`2<TSource, TGroupKey>, TOrderKey> source, Func`2<TSource, TGroupKey> keySelector, Func`2<TSource, TElement> elementSelector, IEqualityComparer`1<TGroupKey> keyComparer, IComparer`1<TOrderKey> orderComparer, CancellationToken cancellationToken);
    protected virtual HashLookup`2<Wrapper`1<TGroupKey>, GroupKeyData<TSource, TGroupKey, TElement, TOrderKey>> BuildHashLookup();
}
internal class System.Linq.Parallel.OrderedGroupByGrouping`3 : object {
    private TGroupKey _groupKey;
    private GrowingArray`1<TElement> _values;
    private GrowingArray`1<TOrderKey> _orderKeys;
    private IComparer`1<TOrderKey> _orderComparer;
    private KeyAndValuesComparer<TGroupKey, TOrderKey, TElement> _wrappedComparer;
    private TGroupKey System.Linq.IGrouping<TGroupKey,TElement>.Key { get; }
    internal OrderedGroupByGrouping`3(TGroupKey groupKey, IComparer`1<TOrderKey> orderComparer);
    private sealed virtual override TGroupKey System.Linq.IGrouping<TGroupKey,TElement>.get_Key();
    [IteratorStateMachineAttribute("System.Linq.Parallel.OrderedGroupByGrouping`3/<System-Collections-Generic-IEnumerable<TElement>-GetEnumerator>d__8")]
private sealed virtual override IEnumerator`1<TElement> System.Collections.Generic.IEnumerable<TElement>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    internal void Add(TElement value, TOrderKey orderKey);
    internal void DoneAdding();
}
internal class System.Linq.Parallel.OrderedGroupByIdentityQueryOperatorEnumerator`3 : OrderedGroupByQueryOperatorEnumerator`4<TSource, TGroupKey, TSource, TOrderKey> {
    internal OrderedGroupByIdentityQueryOperatorEnumerator`3(QueryOperatorEnumerator`2<Pair`2<TSource, TGroupKey>, TOrderKey> source, Func`2<TSource, TGroupKey> keySelector, IEqualityComparer`1<TGroupKey> keyComparer, IComparer`1<TOrderKey> orderComparer, CancellationToken cancellationToken);
    protected virtual HashLookup`2<Wrapper`1<TGroupKey>, GroupKeyData<TSource, TGroupKey, TSource, TOrderKey>> BuildHashLookup();
}
internal abstract class System.Linq.Parallel.OrderedGroupByQueryOperatorEnumerator`4 : QueryOperatorEnumerator`2<IGrouping`2<TGroupKey, TElement>, TOrderKey> {
    protected QueryOperatorEnumerator`2<Pair`2<TSource, TGroupKey>, TOrderKey> _source;
    private Func`2<TSource, TGroupKey> _keySelector;
    protected IEqualityComparer`1<TGroupKey> _keyComparer;
    protected IComparer`1<TOrderKey> _orderComparer;
    protected CancellationToken _cancellationToken;
    private Mutables<TSource, TGroupKey, TElement, TOrderKey> _mutables;
    protected OrderedGroupByQueryOperatorEnumerator`4(QueryOperatorEnumerator`2<Pair`2<TSource, TGroupKey>, TOrderKey> source, Func`2<TSource, TGroupKey> keySelector, IEqualityComparer`1<TGroupKey> keyComparer, IComparer`1<TOrderKey> orderComparer, CancellationToken cancellationToken);
    internal virtual bool MoveNext(IGrouping`2& currentElement, TOrderKey& currentKey);
    protected abstract virtual HashLookup`2<Wrapper`1<TGroupKey>, GroupKeyData<TSource, TGroupKey, TElement, TOrderKey>> BuildHashLookup();
    protected virtual void Dispose(bool disposing);
}
internal class System.Linq.Parallel.OrderedHashRepartitionEnumerator`3 : QueryOperatorEnumerator`2<Pair`2<TInputOutput, THashKey>, TOrderKey> {
    private static int ENUMERATION_NOT_STARTED;
    private int _partitionCount;
    private int _partitionIndex;
    private Func`2<TInputOutput, THashKey> _keySelector;
    private HashRepartitionStream`3<TInputOutput, THashKey, TOrderKey> _repartitionStream;
    private ListChunk`1[][] _valueExchangeMatrix;
    private ListChunk`1[][] _keyExchangeMatrix;
    private QueryOperatorEnumerator`2<TInputOutput, TOrderKey> _source;
    private CountdownEvent _barrier;
    private CancellationToken _cancellationToken;
    private Mutables<TInputOutput, THashKey, TOrderKey> _mutables;
    internal OrderedHashRepartitionEnumerator`3(QueryOperatorEnumerator`2<TInputOutput, TOrderKey> source, int partitionCount, int partitionIndex, Func`2<TInputOutput, THashKey> keySelector, OrderedHashRepartitionStream`3<TInputOutput, THashKey, TOrderKey> repartitionStream, CountdownEvent barrier, ListChunk`1[][] valueExchangeMatrix, ListChunk`1[][] keyExchangeMatrix, CancellationToken cancellationToken);
    internal virtual bool MoveNext(Pair`2& currentElement, TOrderKey& currentKey);
    private void EnumerateAndRedistributeElements();
    protected virtual void Dispose(bool disposing);
}
internal class System.Linq.Parallel.OrderedHashRepartitionStream`3 : HashRepartitionStream`3<TInputOutput, THashKey, TOrderKey> {
    internal OrderedHashRepartitionStream`3(PartitionedStream`2<TInputOutput, TOrderKey> inputStream, Func`2<TInputOutput, THashKey> hashKeySelector, IEqualityComparer`1<THashKey> hashKeyComparer, IEqualityComparer`1<TInputOutput> elementComparer, CancellationToken cancellationToken);
}
internal class System.Linq.Parallel.OrderingQueryOperator`1 : QueryOperator`1<TSource> {
    private QueryOperator`1<TSource> _child;
    private OrdinalIndexState _ordinalIndexState;
    internal bool LimitsParallelism { get; }
    internal OrdinalIndexState OrdinalIndexState { get; }
    public OrderingQueryOperator`1(QueryOperator`1<TSource> child, bool orderOn);
    internal virtual QueryResults`1<TSource> Open(QuerySettings settings, bool preferStriping);
    internal virtual IEnumerator`1<TSource> GetEnumerator(Nullable`1<ParallelMergeOptions> mergeOptions, bool suppressOrderPreservation);
    internal virtual IEnumerable`1<TSource> AsSequentialQuery(CancellationToken token);
    internal virtual bool get_LimitsParallelism();
    internal virtual OrdinalIndexState get_OrdinalIndexState();
}
internal class System.Linq.Parallel.OrderPreservingMergeHelper`2 : object {
    private QueryTaskGroupState _taskGroupState;
    private PartitionedStream`2<TInputOutput, TKey> _partitions;
    private Shared`1<TInputOutput[]> _results;
    private TaskScheduler _taskScheduler;
    internal OrderPreservingMergeHelper`2(PartitionedStream`2<TInputOutput, TKey> partitions, TaskScheduler taskScheduler, CancellationState cancellationState, int queryId);
    private sealed virtual override void System.Linq.Parallel.IMergeHelper<TInputOutput>.Execute();
    private sealed virtual override IEnumerator`1<TInputOutput> System.Linq.Parallel.IMergeHelper<TInputOutput>.GetEnumerator();
    public sealed virtual TInputOutput[] GetResultsAsArray();
}
internal class System.Linq.Parallel.OrderPreservingPipeliningMergeHelper`2 : object {
    private QueryTaskGroupState _taskGroupState;
    private PartitionedStream`2<TOutput, TKey> _partitions;
    private TaskScheduler _taskScheduler;
    private bool _autoBuffered;
    private Queue`1[] _buffers;
    private Boolean[] _producerDone;
    private Boolean[] _producerWaiting;
    private Boolean[] _consumerWaiting;
    private Object[] _bufferLocks;
    private IComparer`1<Producer`1<TKey>> _producerComparer;
    internal static int INITIAL_BUFFER_SIZE;
    internal static int STEAL_BUFFER_SIZE;
    internal static int MAX_BUFFER_SIZE;
    internal OrderPreservingPipeliningMergeHelper`2(PartitionedStream`2<TOutput, TKey> partitions, TaskScheduler taskScheduler, CancellationState cancellationState, bool autoBuffered, int queryId, IComparer`1<TKey> keyComparer);
    private sealed virtual override void System.Linq.Parallel.IMergeHelper<TOutput>.Execute();
    private sealed virtual override IEnumerator`1<TOutput> System.Linq.Parallel.IMergeHelper<TOutput>.GetEnumerator();
    [ExcludeFromCodeCoverageAttribute]
public sealed virtual TOutput[] GetResultsAsArray();
}
internal class System.Linq.Parallel.OrderPreservingPipeliningSpoolingTask`2 : SpoolingTaskBase {
    private QueryTaskGroupState _taskGroupState;
    private QueryOperatorEnumerator`2<TOutput, TKey> _partition;
    private Boolean[] _consumerWaiting;
    private Boolean[] _producerWaiting;
    private Boolean[] _producerDone;
    private int _partitionIndex;
    private Queue`1[] _buffers;
    private object _bufferLock;
    private bool _autoBuffered;
    private static int PRODUCER_BUFFER_AUTO_SIZE;
    internal OrderPreservingPipeliningSpoolingTask`2(QueryOperatorEnumerator`2<TOutput, TKey> partition, QueryTaskGroupState taskGroupState, Boolean[] consumerWaiting, Boolean[] producerWaiting, Boolean[] producerDone, int partitionIndex, Queue`1[] buffers, object bufferLock, bool autoBuffered);
    protected virtual void SpoolingWork();
    public static void Spool(QueryTaskGroupState groupState, PartitionedStream`2<TOutput, TKey> partitions, Boolean[] consumerWaiting, Boolean[] producerWaiting, Boolean[] producerDone, Queue`1[] buffers, Object[] bufferLocks, TaskScheduler taskScheduler, bool autoBuffered);
    protected virtual void SpoolingFinally();
}
internal class System.Linq.Parallel.OrderPreservingSpoolingTask`2 : SpoolingTaskBase {
    private Shared`1<TInputOutput[]> _results;
    private SortHelper`1<TInputOutput> _sortHelper;
    private OrderPreservingSpoolingTask`2(int taskIndex, QueryTaskGroupState groupState, Shared`1<TInputOutput[]> results, SortHelper`1<TInputOutput> sortHelper);
    internal static void Spool(QueryTaskGroupState groupState, PartitionedStream`2<TInputOutput, TKey> partitions, Shared`1<TInputOutput[]> results, TaskScheduler taskScheduler);
    protected virtual void SpoolingWork();
}
internal enum System.Linq.Parallel.OrdinalIndexState : Enum {
    public byte value__;
    public static OrdinalIndexState Indexable;
    public static OrdinalIndexState Correct;
    public static OrdinalIndexState Increasing;
    public static OrdinalIndexState Shuffled;
}
internal class System.Linq.Parallel.Pair`2 : ValueType {
    internal T _first;
    internal U _second;
    public T First { get; public set; }
    public U Second { get; public set; }
    public Pair`2(T first, U second);
    public T get_First();
    public void set_First(T value);
    public U get_Second();
    public void set_Second(U value);
}
internal class System.Linq.Parallel.PairComparer`2 : object {
    private IComparer`1<T> _comparer1;
    private IComparer`1<U> _comparer2;
    public PairComparer`2(IComparer`1<T> comparer1, IComparer`1<U> comparer2);
    public sealed virtual int Compare(Pair`2<T, U> x, Pair`2<T, U> y);
}
internal class System.Linq.Parallel.ParallelEnumerableWrapper : ParallelQuery`1<object> {
    private IEnumerable _source;
    internal ParallelEnumerableWrapper(IEnumerable source);
    internal virtual IEnumerator GetEnumeratorUntyped();
    public virtual IEnumerator`1<object> GetEnumerator();
}
internal class System.Linq.Parallel.ParallelEnumerableWrapper`1 : ParallelQuery`1<T> {
    private IEnumerable`1<T> _wrappedEnumerable;
    internal IEnumerable`1<T> WrappedEnumerable { get; }
    internal ParallelEnumerableWrapper`1(IEnumerable`1<T> wrappedEnumerable);
    internal IEnumerable`1<T> get_WrappedEnumerable();
    public virtual IEnumerator`1<T> GetEnumerator();
}
internal class System.Linq.Parallel.PartitionedDataSource`1 : PartitionedStream`2<T, int> {
    internal PartitionedDataSource`1(IEnumerable`1<T> source, int partitionCount, bool useStriping);
    private void InitializePartitions(IEnumerable`1<T> source, int partitionCount, bool useStriping);
    private static QueryOperatorEnumerator`2[] MakePartitions(IEnumerator`1<T> source, int partitionCount);
}
[DefaultMemberAttribute("Item")]
internal class System.Linq.Parallel.PartitionedStream`2 : object {
    protected QueryOperatorEnumerator`2[] _partitions;
    private IComparer`1<TKey> _keyComparer;
    private OrdinalIndexState _indexState;
    internal QueryOperatorEnumerator`2<TElement, TKey> Item { get; internal set; }
    public int PartitionCount { get; }
    internal IComparer`1<TKey> KeyComparer { get; }
    internal OrdinalIndexState OrdinalIndexState { get; }
    internal PartitionedStream`2(int partitionCount, IComparer`1<TKey> keyComparer, OrdinalIndexState indexState);
    internal QueryOperatorEnumerator`2<TElement, TKey> get_Item(int index);
    internal void set_Item(int index, QueryOperatorEnumerator`2<TElement, TKey> value);
    public int get_PartitionCount();
    internal IComparer`1<TKey> get_KeyComparer();
    internal OrdinalIndexState get_OrdinalIndexState();
}
internal class System.Linq.Parallel.PartitionedStreamMerger`1 : object {
    private bool _forEffectMerge;
    private ParallelMergeOptions _mergeOptions;
    private bool _isOrdered;
    private MergeExecutor`1<TOutput> _mergeExecutor;
    private TaskScheduler _taskScheduler;
    private int _queryId;
    private CancellationState _cancellationState;
    internal MergeExecutor`1<TOutput> MergeExecutor { get; }
    internal PartitionedStreamMerger`1(bool forEffectMerge, ParallelMergeOptions mergeOptions, TaskScheduler taskScheduler, bool outputOrdered, CancellationState cancellationState, int queryId);
    internal MergeExecutor`1<TOutput> get_MergeExecutor();
    public sealed virtual void Receive(PartitionedStream`2<TOutput, TKey> partitionedStream);
}
internal class System.Linq.Parallel.PartitionerQueryOperator`1 : QueryOperator`1<TElement> {
    private Partitioner`1<TElement> _partitioner;
    internal bool Orderable { get; }
    internal OrdinalIndexState OrdinalIndexState { get; }
    internal bool LimitsParallelism { get; }
    internal PartitionerQueryOperator`1(Partitioner`1<TElement> partitioner);
    internal bool get_Orderable();
    internal virtual QueryResults`1<TElement> Open(QuerySettings settings, bool preferStriping);
    [IteratorStateMachineAttribute("System.Linq.Parallel.PartitionerQueryOperator`1/<AsSequentialQuery>d__5")]
internal virtual IEnumerable`1<TElement> AsSequentialQuery(CancellationToken token);
    internal virtual OrdinalIndexState get_OrdinalIndexState();
    internal static OrdinalIndexState GetOrdinalIndexState(Partitioner`1<TElement> partitioner);
    internal virtual bool get_LimitsParallelism();
}
internal class System.Linq.Parallel.PipelineSpoolingTask`2 : SpoolingTaskBase {
    private QueryOperatorEnumerator`2<TInputOutput, TIgnoreKey> _source;
    private AsynchronousChannel`1<TInputOutput> _destination;
    internal PipelineSpoolingTask`2(int taskIndex, QueryTaskGroupState groupState, QueryOperatorEnumerator`2<TInputOutput, TIgnoreKey> source, AsynchronousChannel`1<TInputOutput> destination);
    protected virtual void SpoolingWork();
    protected virtual void SpoolingFinally();
}
[EventSourceAttribute]
internal class System.Linq.Parallel.PlinqEtwProvider : EventSource {
    internal static PlinqEtwProvider Log;
    private static int s_defaultSchedulerId;
    private static int s_queryId;
    private static EventKeywords ALL_KEYWORDS;
    private static int PARALLELQUERYBEGIN_EVENTID;
    private static int PARALLELQUERYEND_EVENTID;
    private static int PARALLELQUERYFORK_EVENTID;
    private static int PARALLELQUERYJOIN_EVENTID;
    private static PlinqEtwProvider();
    [NonEventAttribute]
internal static int NextQueryId();
    [NonEventAttribute]
internal void ParallelQueryBegin(int queryId);
    [EventAttribute("1")]
private void ParallelQueryBegin(int taskSchedulerId, int taskId, int queryId);
    [NonEventAttribute]
internal void ParallelQueryEnd(int queryId);
    [EventAttribute("2")]
private void ParallelQueryEnd(int taskSchedulerId, int taskId, int queryId);
    [NonEventAttribute]
internal void ParallelQueryFork(int queryId);
    [EventAttribute("3")]
private void ParallelQueryFork(int taskSchedulerId, int taskId, int queryId);
    [NonEventAttribute]
internal void ParallelQueryJoin(int queryId);
    [EventAttribute("4")]
private void ParallelQueryJoin(int taskSchedulerId, int taskId, int queryId);
}
[IsReadOnlyAttribute]
internal class System.Linq.Parallel.Producer`1 : ValueType {
    internal TKey MaxKey;
    internal int ProducerIndex;
    internal Producer`1(TKey maxKey, int producerIndex);
}
internal class System.Linq.Parallel.ProducerComparerInt : object {
    public sealed virtual int Compare(Producer`1<int> x, Producer`1<int> y);
}
[FlagsAttribute]
internal enum System.Linq.Parallel.QueryAggregationOptions : Enum {
    public int value__;
    public static QueryAggregationOptions None;
    public static QueryAggregationOptions Associative;
    public static QueryAggregationOptions Commutative;
    public static QueryAggregationOptions AssociativeCommutative;
}
[ExtensionAttribute]
internal static class System.Linq.Parallel.QueryAggregationOptionsExtensions : object {
    [ExtensionAttribute]
public static bool IsValidQueryAggregationOption(QueryAggregationOptions value);
}
internal class System.Linq.Parallel.QueryExecutionOption`1 : QueryOperator`1<TSource> {
    private QueryOperator`1<TSource> _child;
    private OrdinalIndexState _indexState;
    internal OrdinalIndexState OrdinalIndexState { get; }
    internal bool LimitsParallelism { get; }
    internal QueryExecutionOption`1(QueryOperator`1<TSource> source, QuerySettings settings);
    internal virtual QueryResults`1<TSource> Open(QuerySettings settings, bool preferStriping);
    internal virtual IEnumerable`1<TSource> AsSequentialQuery(CancellationToken token);
    internal virtual OrdinalIndexState get_OrdinalIndexState();
    internal virtual bool get_LimitsParallelism();
}
internal static class System.Linq.Parallel.QueryLifecycle : object {
    internal static void LogicalQueryExecutionBegin(int queryID);
    internal static void LogicalQueryExecutionEnd(int queryID);
}
internal class System.Linq.Parallel.QueryOpeningEnumerator`1 : object {
    private QueryOperator`1<TOutput> _queryOperator;
    private IEnumerator`1<TOutput> _openedQueryEnumerator;
    private QuerySettings _querySettings;
    private Nullable`1<ParallelMergeOptions> _mergeOptions;
    private bool _suppressOrderPreservation;
    private int _moveNextIteration;
    private bool _hasQueryOpeningFailed;
    private Shared`1<bool> _topLevelDisposedFlag;
    private CancellationTokenSource _topLevelCancellationTokenSource;
    public TOutput Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    internal QueryOpeningEnumerator`1(QueryOperator`1<TOutput> queryOperator, Nullable`1<ParallelMergeOptions> mergeOptions, bool suppressOrderPreservation);
    public sealed virtual TOutput get_Current();
    public sealed virtual void Dispose();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual bool MoveNext();
    private void OpenQuery();
    public sealed virtual void Reset();
}
internal abstract class System.Linq.Parallel.QueryOperator`1 : ParallelQuery`1<TOutput> {
    protected bool _outputOrdered;
    internal bool OutputOrdered { get; }
    internal bool LimitsParallelism { get; }
    internal OrdinalIndexState OrdinalIndexState { get; }
    internal QueryOperator`1(QuerySettings settings);
    internal QueryOperator`1(bool isOrdered, QuerySettings settings);
    internal abstract virtual QueryResults`1<TOutput> Open(QuerySettings settings, bool preferStriping);
    public virtual IEnumerator`1<TOutput> GetEnumerator();
    public IEnumerator`1<TOutput> GetEnumerator(Nullable`1<ParallelMergeOptions> mergeOptions);
    internal bool get_OutputOrdered();
    internal virtual IEnumerator`1<TOutput> GetEnumerator(Nullable`1<ParallelMergeOptions> mergeOptions, bool suppressOrderPreservation);
    internal IEnumerator`1<TOutput> GetOpenedEnumerator(Nullable`1<ParallelMergeOptions> mergeOptions, bool suppressOrder, bool forEffect, QuerySettings querySettings);
    private QueryResults`1<TOutput> GetQueryResults(QuerySettings querySettings);
    internal TOutput[] ExecuteAndGetResultsAsArray();
    internal abstract virtual IEnumerable`1<TOutput> AsSequentialQuery(CancellationToken token);
    internal abstract virtual bool get_LimitsParallelism();
    internal abstract virtual OrdinalIndexState get_OrdinalIndexState();
    internal static ListQueryResults`1<TOutput> ExecuteAndCollectResults(PartitionedStream`2<TOutput, TKey> openedChild, int partitionCount, bool outputOrdered, bool useStriping, QuerySettings settings);
    internal static QueryOperator`1<TOutput> AsQueryOperator(IEnumerable`1<TOutput> source);
}
internal abstract class System.Linq.Parallel.QueryOperatorEnumerator`2 : object {
    internal abstract virtual bool MoveNext(TElement& currentElement, TKey& currentKey);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    internal virtual void Reset();
    internal IEnumerator`1<TElement> AsClassicEnumerator();
}
[DefaultMemberAttribute("Item")]
internal abstract class System.Linq.Parallel.QueryResults`1 : object {
    internal bool IsIndexible { get; }
    internal int ElementsCount { get; }
    public T Item { get; public set; }
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    internal abstract virtual void GivePartitionedStream(IPartitionedStreamRecipient`1<T> recipient);
    internal virtual bool get_IsIndexible();
    internal virtual T GetElement(int index);
    internal virtual int get_ElementsCount();
    private sealed virtual override int System.Collections.Generic.IList<T>.IndexOf(T item);
    private sealed virtual override void System.Collections.Generic.IList<T>.Insert(int index, T item);
    private sealed virtual override void System.Collections.Generic.IList<T>.RemoveAt(int index);
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T item);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.Contains(T item);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.CopyTo(T[] array, int arrayIndex);
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.Remove(T item);
    [IteratorStateMachineAttribute("System.Linq.Parallel.QueryResults`1/<System-Collections-Generic-IEnumerable<T>-GetEnumerator>d__21")]
private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal class System.Linq.Parallel.QuerySettings : ValueType {
    private TaskScheduler _taskScheduler;
    private Nullable`1<int> _degreeOfParallelism;
    private CancellationState _cancellationState;
    private Nullable`1<ParallelExecutionMode> _executionMode;
    private Nullable`1<ParallelMergeOptions> _mergeOptions;
    private int _queryId;
    internal CancellationState CancellationState { get; internal set; }
    internal TaskScheduler TaskScheduler { get; internal set; }
    internal Nullable`1<int> DegreeOfParallelism { get; internal set; }
    internal Nullable`1<ParallelExecutionMode> ExecutionMode { get; internal set; }
    internal Nullable`1<ParallelMergeOptions> MergeOptions { get; internal set; }
    internal int QueryId { get; }
    internal static QuerySettings Empty { get; }
    internal QuerySettings(TaskScheduler taskScheduler, Nullable`1<int> degreeOfParallelism, CancellationToken externalCancellationToken, Nullable`1<ParallelExecutionMode> executionMode, Nullable`1<ParallelMergeOptions> mergeOptions);
    internal CancellationState get_CancellationState();
    internal void set_CancellationState(CancellationState value);
    internal TaskScheduler get_TaskScheduler();
    internal void set_TaskScheduler(TaskScheduler value);
    internal Nullable`1<int> get_DegreeOfParallelism();
    internal void set_DegreeOfParallelism(Nullable`1<int> value);
    internal Nullable`1<ParallelExecutionMode> get_ExecutionMode();
    internal void set_ExecutionMode(Nullable`1<ParallelExecutionMode> value);
    internal Nullable`1<ParallelMergeOptions> get_MergeOptions();
    internal void set_MergeOptions(Nullable`1<ParallelMergeOptions> value);
    internal int get_QueryId();
    internal QuerySettings Merge(QuerySettings settings2);
    internal QuerySettings WithPerExecutionSettings();
    internal QuerySettings WithPerExecutionSettings(CancellationTokenSource topLevelCancellationTokenSource, Shared`1<bool> topLevelDisposedFlag);
    internal QuerySettings WithDefaults();
    internal static QuerySettings get_Empty();
    public void CleanStateAtQueryEnd();
}
internal abstract class System.Linq.Parallel.QueryTask : object {
    protected int _taskIndex;
    protected QueryTaskGroupState _groupState;
    private static Action`1<object> s_runTaskSynchronouslyDelegate;
    private static Action`1<object> s_baseWorkDelegate;
    protected QueryTask(int taskIndex, QueryTaskGroupState groupState);
    private static QueryTask();
    private static void RunTaskSynchronously(object o);
    internal Task RunSynchronously(TaskScheduler taskScheduler);
    internal Task RunAsynchronously(TaskScheduler taskScheduler);
    private void BaseWork(object unused);
    protected abstract virtual void Work();
}
internal class System.Linq.Parallel.QueryTaskGroupState : object {
    private Task _rootTask;
    private int _alreadyEnded;
    private CancellationState _cancellationState;
    private int _queryId;
    internal bool IsAlreadyEnded { get; }
    internal CancellationState CancellationState { get; }
    internal int QueryId { get; }
    internal QueryTaskGroupState(CancellationState cancellationState, int queryId);
    internal bool get_IsAlreadyEnded();
    internal CancellationState get_CancellationState();
    internal int get_QueryId();
    internal void QueryBegin(Task rootTask);
    internal void QueryEnd(bool userInitiatedDispose);
}
internal class System.Linq.Parallel.RangeEnumerable : ParallelQuery`1<int> {
    private int _from;
    private int _count;
    internal RangeEnumerable(int from, int count);
    public sealed virtual QueryOperatorEnumerator`2[] GetPartitions(int partitionCount);
    public virtual IEnumerator`1<int> GetEnumerator();
}
internal class System.Linq.Parallel.RepeatEnumerable`1 : ParallelQuery`1<TResult> {
    private TResult _element;
    private int _count;
    internal RepeatEnumerable`1(TResult element, int count);
    public sealed virtual QueryOperatorEnumerator`2[] GetPartitions(int partitionCount);
    public virtual IEnumerator`1<TResult> GetEnumerator();
}
internal class System.Linq.Parallel.ReverseComparer`1 : object {
    private IComparer`1<T> _comparer;
    internal ReverseComparer`1(IComparer`1<T> comparer);
    public sealed virtual int Compare(T x, T y);
}
internal class System.Linq.Parallel.ReverseQueryOperator`1 : UnaryQueryOperator`2<TSource, TSource> {
    internal bool LimitsParallelism { get; }
    internal ReverseQueryOperator`1(IEnumerable`1<TSource> child);
    internal virtual void WrapPartitionedStream(PartitionedStream`2<TSource, TKey> inputStream, IPartitionedStreamRecipient`1<TSource> recipient, bool preferStriping, QuerySettings settings);
    internal virtual QueryResults`1<TSource> Open(QuerySettings settings, bool preferStriping);
    internal virtual IEnumerable`1<TSource> AsSequentialQuery(CancellationToken token);
    internal virtual bool get_LimitsParallelism();
}
internal class System.Linq.Parallel.ScanQueryOperator`1 : QueryOperator`1<TElement> {
    private IEnumerable`1<TElement> _data;
    public IEnumerable`1<TElement> Data { get; }
    internal OrdinalIndexState OrdinalIndexState { get; }
    internal bool LimitsParallelism { get; }
    internal ScanQueryOperator`1(IEnumerable`1<TElement> data);
    public IEnumerable`1<TElement> get_Data();
    internal virtual QueryResults`1<TElement> Open(QuerySettings settings, bool preferStriping);
    internal virtual IEnumerator`1<TElement> GetEnumerator(Nullable`1<ParallelMergeOptions> mergeOptions, bool suppressOrderPreservation);
    internal virtual IEnumerable`1<TElement> AsSequentialQuery(CancellationToken token);
    internal virtual OrdinalIndexState get_OrdinalIndexState();
    internal virtual bool get_LimitsParallelism();
}
internal static class System.Linq.Parallel.Scheduling : object {
    internal static bool DefaultPreserveOrder;
    internal static int DefaultDegreeOfParallelism;
    internal static int DEFAULT_BOUNDED_BUFFER_CAPACITY;
    internal static int DEFAULT_BYTES_PER_CHUNK;
    internal static int ZOMBIED_PRODUCER_TIMEOUT;
    internal static int MAX_SUPPORTED_DOP;
    private static Scheduling();
    internal static int GetDefaultDegreeOfParallelism();
    internal static int GetDefaultChunkSize();
}
internal class System.Linq.Parallel.SelectManyQueryOperator`3 : UnaryQueryOperator`2<TLeftInput, TOutput> {
    private Func`2<TLeftInput, IEnumerable`1<TRightInput>> _rightChildSelector;
    private Func`3<TLeftInput, int, IEnumerable`1<TRightInput>> _indexedRightChildSelector;
    private Func`3<TLeftInput, TRightInput, TOutput> _resultSelector;
    private bool _prematureMerge;
    private bool _limitsParallelism;
    internal bool LimitsParallelism { get; }
    internal SelectManyQueryOperator`3(IEnumerable`1<TLeftInput> leftChild, Func`2<TLeftInput, IEnumerable`1<TRightInput>> rightChildSelector, Func`3<TLeftInput, int, IEnumerable`1<TRightInput>> indexedRightChildSelector, Func`3<TLeftInput, TRightInput, TOutput> resultSelector);
    private void InitOrderIndex();
    internal virtual void WrapPartitionedStream(PartitionedStream`2<TLeftInput, TLeftKey> inputStream, IPartitionedStreamRecipient`1<TOutput> recipient, bool preferStriping, QuerySettings settings);
    private void WrapPartitionedStreamNotIndexed(PartitionedStream`2<TLeftInput, TLeftKey> inputStream, IPartitionedStreamRecipient`1<TOutput> recipient, QuerySettings settings);
    private void WrapPartitionedStreamIndexed(PartitionedStream`2<TLeftInput, int> inputStream, IPartitionedStreamRecipient`1<TOutput> recipient, QuerySettings settings);
    internal virtual QueryResults`1<TOutput> Open(QuerySettings settings, bool preferStriping);
    internal virtual IEnumerable`1<TOutput> AsSequentialQuery(CancellationToken token);
    internal virtual bool get_LimitsParallelism();
}
internal class System.Linq.Parallel.SelectQueryOperator`2 : UnaryQueryOperator`2<TInput, TOutput> {
    private Func`2<TInput, TOutput> _selector;
    internal bool LimitsParallelism { get; }
    internal SelectQueryOperator`2(IEnumerable`1<TInput> child, Func`2<TInput, TOutput> selector);
    internal virtual void WrapPartitionedStream(PartitionedStream`2<TInput, TKey> inputStream, IPartitionedStreamRecipient`1<TOutput> recipient, bool preferStriping, QuerySettings settings);
    internal virtual QueryResults`1<TOutput> Open(QuerySettings settings, bool preferStriping);
    internal virtual IEnumerable`1<TOutput> AsSequentialQuery(CancellationToken token);
    internal virtual bool get_LimitsParallelism();
}
internal class System.Linq.Parallel.Set`1 : object {
    private Int32[] _buckets;
    private Slot[] _slots;
    private int _count;
    private IEqualityComparer`1<TElement> _comparer;
    private static int InitialSize;
    private static int HashCodeMask;
    public Set`1(IEqualityComparer`1<TElement> comparer);
    public bool Add(TElement value);
    public bool Contains(TElement value);
    public bool Remove(TElement value);
    private bool Find(TElement value, bool add);
    private void Resize();
    internal int InternalGetHashCode(TElement value);
}
internal class System.Linq.Parallel.Shared`1 : object {
    internal T Value;
    internal Shared`1(T value);
}
internal class System.Linq.Parallel.SingleQueryOperator`1 : UnaryQueryOperator`2<TSource, TSource> {
    private Func`2<TSource, bool> _predicate;
    internal bool LimitsParallelism { get; }
    internal SingleQueryOperator`1(IEnumerable`1<TSource> child, Func`2<TSource, bool> predicate);
    internal virtual QueryResults`1<TSource> Open(QuerySettings settings, bool preferStriping);
    internal virtual void WrapPartitionedStream(PartitionedStream`2<TSource, TKey> inputStream, IPartitionedStreamRecipient`1<TSource> recipient, bool preferStriping, QuerySettings settings);
    [ExcludeFromCodeCoverageAttribute]
internal virtual IEnumerable`1<TSource> AsSequentialQuery(CancellationToken token);
    internal virtual bool get_LimitsParallelism();
}
internal abstract class System.Linq.Parallel.SortHelper`1 : object {
    internal abstract virtual TInputOutput[] Sort();
}
internal class System.Linq.Parallel.SortHelper`2 : SortHelper`1<TInputOutput> {
    private QueryOperatorEnumerator`2<TInputOutput, TKey> _source;
    private int _partitionCount;
    private int _partitionIndex;
    private QueryTaskGroupState _groupState;
    private Int32[][] _sharedIndices;
    private GrowingArray`1[] _sharedKeys;
    private TInputOutput[][] _sharedValues;
    private Barrier[][] _sharedBarriers;
    private OrdinalIndexState _indexState;
    private IComparer`1<TKey> _keyComparer;
    private SortHelper`2(QueryOperatorEnumerator`2<TInputOutput, TKey> source, int partitionCount, int partitionIndex, QueryTaskGroupState groupState, Int32[][] sharedIndices, OrdinalIndexState indexState, IComparer`1<TKey> keyComparer, GrowingArray`1[] sharedkeys, TInputOutput[][] sharedValues, Barrier[][] sharedBarriers);
    internal static SortHelper`2[] GenerateSortHelpers(PartitionedStream`2<TInputOutput, TKey> partitions, QueryTaskGroupState groupState);
    public sealed virtual void Dispose();
    internal virtual TInputOutput[] Sort();
    private void BuildKeysFromSource(GrowingArray`1& keys, List`1& values);
    private void QuickSortIndicesInPlace(GrowingArray`1<TKey> keys, List`1<TInputOutput> values, OrdinalIndexState ordinalIndexState);
    private void MergeSortCooperatively();
    private int ComputePartnerIndex(int phase);
    private void QuickSort(int left, int right, TKey[] keys, Int32[] indices, CancellationToken cancelToken);
}
internal class System.Linq.Parallel.SortQueryOperator`2 : UnaryQueryOperator`2<TInputOutput, TInputOutput> {
    private Func`2<TInputOutput, TSortKey> _keySelector;
    private IComparer`1<TSortKey> _comparer;
    internal bool LimitsParallelism { get; }
    internal SortQueryOperator`2(IEnumerable`1<TInputOutput> source, Func`2<TInputOutput, TSortKey> keySelector, IComparer`1<TSortKey> comparer, bool descending);
    private sealed virtual override IOrderedEnumerable`1<TInputOutput> System.Linq.IOrderedEnumerable<TInputOutput>.CreateOrderedEnumerable(Func`2<TInputOutput, TKey2> key2Selector, IComparer`1<TKey2> key2Comparer, bool descending);
    internal virtual QueryResults`1<TInputOutput> Open(QuerySettings settings, bool preferStriping);
    internal virtual void WrapPartitionedStream(PartitionedStream`2<TInputOutput, TKey> inputStream, IPartitionedStreamRecipient`1<TInputOutput> recipient, bool preferStriping, QuerySettings settings);
    internal virtual IEnumerable`1<TInputOutput> AsSequentialQuery(CancellationToken token);
    internal virtual bool get_LimitsParallelism();
}
internal class System.Linq.Parallel.SortQueryOperatorEnumerator`3 : QueryOperatorEnumerator`2<TInputOutput, TSortKey> {
    private QueryOperatorEnumerator`2<TInputOutput, TKey> _source;
    private Func`2<TInputOutput, TSortKey> _keySelector;
    internal SortQueryOperatorEnumerator`3(QueryOperatorEnumerator`2<TInputOutput, TKey> source, Func`2<TInputOutput, TSortKey> keySelector);
    internal virtual bool MoveNext(TInputOutput& currentElement, TSortKey& currentKey);
    protected virtual void Dispose(bool disposing);
}
internal class System.Linq.Parallel.SortQueryOperatorResults`2 : QueryResults`1<TInputOutput> {
    protected QueryResults`1<TInputOutput> _childQueryResults;
    private SortQueryOperator`2<TInputOutput, TSortKey> _op;
    private QuerySettings _settings;
    internal bool IsIndexible { get; }
    internal SortQueryOperatorResults`2(QueryResults`1<TInputOutput> childQueryResults, SortQueryOperator`2<TInputOutput, TSortKey> op, QuerySettings settings);
    internal virtual bool get_IsIndexible();
    internal virtual void GivePartitionedStream(IPartitionedStreamRecipient`1<TInputOutput> recipient);
}
internal static class System.Linq.Parallel.SpoolingTask : object {
    internal static void SpoolStopAndGo(QueryTaskGroupState groupState, PartitionedStream`2<TInputOutput, TIgnoreKey> partitions, SynchronousChannel`1[] channels, TaskScheduler taskScheduler);
    internal static void SpoolPipeline(QueryTaskGroupState groupState, PartitionedStream`2<TInputOutput, TIgnoreKey> partitions, AsynchronousChannel`1[] channels, TaskScheduler taskScheduler);
    internal static void SpoolForAll(QueryTaskGroupState groupState, PartitionedStream`2<TInputOutput, TIgnoreKey> partitions, TaskScheduler taskScheduler);
}
internal abstract class System.Linq.Parallel.SpoolingTaskBase : QueryTask {
    protected SpoolingTaskBase(int taskIndex, QueryTaskGroupState groupState);
    protected virtual void Work();
    protected abstract virtual void SpoolingWork();
    protected virtual void SpoolingFinally();
}
internal class System.Linq.Parallel.StopAndGoSpoolingTask`2 : SpoolingTaskBase {
    private QueryOperatorEnumerator`2<TInputOutput, TIgnoreKey> _source;
    private SynchronousChannel`1<TInputOutput> _destination;
    internal StopAndGoSpoolingTask`2(int taskIndex, QueryTaskGroupState groupState, QueryOperatorEnumerator`2<TInputOutput, TIgnoreKey> source, SynchronousChannel`1<TInputOutput> destination);
    protected virtual void SpoolingWork();
    protected virtual void SpoolingFinally();
}
internal class System.Linq.Parallel.SynchronousChannel`1 : object {
    private Queue`1<T> _queue;
    internal int Count { get; }
    internal void Init();
    internal void Enqueue(T item);
    internal T Dequeue();
    internal void SetDone();
    internal void CopyTo(T[] array, int arrayIndex);
    internal int get_Count();
}
internal class System.Linq.Parallel.SynchronousChannelMergeEnumerator`1 : MergeEnumerator`1<T> {
    private SynchronousChannel`1[] _channels;
    private int _channelIndex;
    private T _currentElement;
    public T Current { get; }
    internal SynchronousChannelMergeEnumerator`1(QueryTaskGroupState taskGroupState, SynchronousChannel`1[] channels);
    public virtual T get_Current();
    public virtual bool MoveNext();
}
internal class System.Linq.Parallel.TakeOrSkipQueryOperator`1 : UnaryQueryOperator`2<TResult, TResult> {
    private int _count;
    private bool _take;
    private bool _prematureMerge;
    internal bool LimitsParallelism { get; }
    internal TakeOrSkipQueryOperator`1(IEnumerable`1<TResult> child, int count, bool take);
    private OrdinalIndexState OutputOrdinalIndexState();
    internal virtual void WrapPartitionedStream(PartitionedStream`2<TResult, TKey> inputStream, IPartitionedStreamRecipient`1<TResult> recipient, bool preferStriping, QuerySettings settings);
    private void WrapHelper(PartitionedStream`2<TResult, TKey> inputStream, IPartitionedStreamRecipient`1<TResult> recipient, QuerySettings settings);
    internal virtual QueryResults`1<TResult> Open(QuerySettings settings, bool preferStriping);
    internal virtual bool get_LimitsParallelism();
    internal virtual IEnumerable`1<TResult> AsSequentialQuery(CancellationToken token);
}
internal class System.Linq.Parallel.TakeOrSkipWhileQueryOperator`1 : UnaryQueryOperator`2<TResult, TResult> {
    private Func`2<TResult, bool> _predicate;
    private Func`3<TResult, int, bool> _indexedPredicate;
    private bool _take;
    private bool _prematureMerge;
    private bool _limitsParallelism;
    internal bool LimitsParallelism { get; }
    internal TakeOrSkipWhileQueryOperator`1(IEnumerable`1<TResult> child, Func`2<TResult, bool> predicate, Func`3<TResult, int, bool> indexedPredicate, bool take);
    private void InitOrderIndexState();
    internal virtual void WrapPartitionedStream(PartitionedStream`2<TResult, TKey> inputStream, IPartitionedStreamRecipient`1<TResult> recipient, bool preferStriping, QuerySettings settings);
    private void WrapHelper(PartitionedStream`2<TResult, TKey> inputStream, IPartitionedStreamRecipient`1<TResult> recipient, QuerySettings settings);
    internal virtual QueryResults`1<TResult> Open(QuerySettings settings, bool preferStriping);
    internal virtual IEnumerable`1<TResult> AsSequentialQuery(CancellationToken token);
    internal virtual bool get_LimitsParallelism();
}
internal static class System.Linq.Parallel.TraceHelpers : object {
    [ConditionalAttribute("PFXTRACE")]
internal static void TraceInfo(string msg, Object[] args);
}
internal abstract class System.Linq.Parallel.UnaryQueryOperator`2 : QueryOperator`1<TOutput> {
    private QueryOperator`1<TInput> _child;
    private OrdinalIndexState _indexState;
    internal QueryOperator`1<TInput> Child { get; }
    internal OrdinalIndexState OrdinalIndexState { get; }
    internal UnaryQueryOperator`2(IEnumerable`1<TInput> child);
    internal UnaryQueryOperator`2(IEnumerable`1<TInput> child, bool outputOrdered);
    private UnaryQueryOperator`2(QueryOperator`1<TInput> child);
    internal UnaryQueryOperator`2(QueryOperator`1<TInput> child, bool outputOrdered);
    private UnaryQueryOperator`2(QueryOperator`1<TInput> child, bool outputOrdered, QuerySettings settings);
    internal QueryOperator`1<TInput> get_Child();
    internal sealed virtual OrdinalIndexState get_OrdinalIndexState();
    protected void SetOrdinalIndexState(OrdinalIndexState indexState);
    internal abstract virtual void WrapPartitionedStream(PartitionedStream`2<TInput, TKey> inputStream, IPartitionedStreamRecipient`1<TOutput> recipient, bool preferStriping, QuerySettings settings);
}
internal class System.Linq.Parallel.UnionQueryOperator`1 : BinaryQueryOperator`3<TInputOutput, TInputOutput, TInputOutput> {
    private IEqualityComparer`1<TInputOutput> _comparer;
    internal bool LimitsParallelism { get; }
    internal UnionQueryOperator`1(ParallelQuery`1<TInputOutput> left, ParallelQuery`1<TInputOutput> right, IEqualityComparer`1<TInputOutput> comparer);
    internal virtual QueryResults`1<TInputOutput> Open(QuerySettings settings, bool preferStriping);
    public virtual void WrapPartitionedStream(PartitionedStream`2<TInputOutput, TLeftKey> leftStream, PartitionedStream`2<TInputOutput, TRightKey> rightStream, IPartitionedStreamRecipient`1<TInputOutput> outputRecipient, bool preferStriping, QuerySettings settings);
    private void WrapPartitionedStreamFixedLeftType(PartitionedStream`2<Pair`2<TInputOutput, NoKeyMemoizationRequired>, TLeftKey> leftHashStream, PartitionedStream`2<TInputOutput, TRightKey> rightStream, IPartitionedStreamRecipient`1<TInputOutput> outputRecipient, int partitionCount, CancellationToken cancellationToken);
    private void WrapPartitionedStreamFixedBothTypes(PartitionedStream`2<Pair`2<TInputOutput, NoKeyMemoizationRequired>, TLeftKey> leftHashStream, PartitionedStream`2<Pair`2<TInputOutput, NoKeyMemoizationRequired>, TRightKey> rightHashStream, IPartitionedStreamRecipient`1<TInputOutput> outputRecipient, int partitionCount, CancellationToken cancellationToken);
    internal virtual IEnumerable`1<TInputOutput> AsSequentialQuery(CancellationToken token);
    internal virtual bool get_LimitsParallelism();
}
internal class System.Linq.Parallel.UnorderedHashRepartitionStream`3 : HashRepartitionStream`3<TInputOutput, THashKey, int> {
    internal UnorderedHashRepartitionStream`3(PartitionedStream`2<TInputOutput, TIgnoreKey> inputStream, Func`2<TInputOutput, THashKey> keySelector, IEqualityComparer`1<THashKey> keyComparer, IEqualityComparer`1<TInputOutput> elementComparer, CancellationToken cancellationToken);
}
internal static class System.Linq.Parallel.Util : object {
    private static FastIntComparer s_fastIntComparer;
    private static FastLongComparer s_fastLongComparer;
    private static FastFloatComparer s_fastFloatComparer;
    private static FastDoubleComparer s_fastDoubleComparer;
    private static FastDateTimeComparer s_fastDateTimeComparer;
    private static Util();
    internal static int Sign(int x);
    internal static Comparer`1<TKey> GetDefaultComparer();
}
internal class System.Linq.Parallel.WhereQueryOperator`1 : UnaryQueryOperator`2<TInputOutput, TInputOutput> {
    private Func`2<TInputOutput, bool> _predicate;
    internal bool LimitsParallelism { get; }
    internal WhereQueryOperator`1(IEnumerable`1<TInputOutput> child, Func`2<TInputOutput, bool> predicate);
    internal virtual void WrapPartitionedStream(PartitionedStream`2<TInputOutput, TKey> inputStream, IPartitionedStreamRecipient`1<TInputOutput> recipient, bool preferStriping, QuerySettings settings);
    internal virtual QueryResults`1<TInputOutput> Open(QuerySettings settings, bool preferStriping);
    internal virtual IEnumerable`1<TInputOutput> AsSequentialQuery(CancellationToken token);
    internal virtual bool get_LimitsParallelism();
}
internal class System.Linq.Parallel.Wrapper`1 : ValueType {
    internal T Value;
    internal Wrapper`1(T value);
}
internal class System.Linq.Parallel.WrapperEqualityComparer`1 : ValueType {
    private IEqualityComparer`1<T> _comparer;
    internal WrapperEqualityComparer`1(IEqualityComparer`1<T> comparer);
    public sealed virtual bool Equals(Wrapper`1<T> x, Wrapper`1<T> y);
    public sealed virtual int GetHashCode(Wrapper`1<T> x);
}
internal class System.Linq.Parallel.ZipQueryOperator`3 : QueryOperator`1<TOutput> {
    private Func`3<TLeftInput, TRightInput, TOutput> _resultSelector;
    private QueryOperator`1<TLeftInput> _leftChild;
    private QueryOperator`1<TRightInput> _rightChild;
    private bool _prematureMergeLeft;
    private bool _prematureMergeRight;
    private bool _limitsParallelism;
    internal OrdinalIndexState OrdinalIndexState { get; }
    internal bool LimitsParallelism { get; }
    internal ZipQueryOperator`3(ParallelQuery`1<TLeftInput> leftChildSource, ParallelQuery`1<TRightInput> rightChildSource, Func`3<TLeftInput, TRightInput, TOutput> resultSelector);
    private ZipQueryOperator`3(QueryOperator`1<TLeftInput> left, QueryOperator`1<TRightInput> right, Func`3<TLeftInput, TRightInput, TOutput> resultSelector);
    internal virtual QueryResults`1<TOutput> Open(QuerySettings settings, bool preferStriping);
    [IteratorStateMachineAttribute("System.Linq.Parallel.ZipQueryOperator`3/<AsSequentialQuery>d__9")]
internal virtual IEnumerable`1<TOutput> AsSequentialQuery(CancellationToken token);
    internal virtual OrdinalIndexState get_OrdinalIndexState();
    internal virtual bool get_LimitsParallelism();
}
[ExtensionAttribute]
public static class System.Linq.ParallelEnumerable : object {
    private static string RIGHT_SOURCE_NOT_PARALLEL_STR;
    [ExtensionAttribute]
public static ParallelQuery`1<TSource> AsParallel(IEnumerable`1<TSource> source);
    [ExtensionAttribute]
public static ParallelQuery`1<TSource> AsParallel(Partitioner`1<TSource> source);
    [ExtensionAttribute]
public static ParallelQuery`1<TSource> AsOrdered(ParallelQuery`1<TSource> source);
    [ExtensionAttribute]
public static ParallelQuery AsOrdered(ParallelQuery source);
    [ExtensionAttribute]
public static ParallelQuery`1<TSource> AsUnordered(ParallelQuery`1<TSource> source);
    [ExtensionAttribute]
public static ParallelQuery AsParallel(IEnumerable source);
    [ExtensionAttribute]
public static IEnumerable`1<TSource> AsSequential(ParallelQuery`1<TSource> source);
    [ExtensionAttribute]
public static ParallelQuery`1<TSource> WithDegreeOfParallelism(ParallelQuery`1<TSource> source, int degreeOfParallelism);
    [ExtensionAttribute]
public static ParallelQuery`1<TSource> WithCancellation(ParallelQuery`1<TSource> source, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ParallelQuery`1<TSource> WithExecutionMode(ParallelQuery`1<TSource> source, ParallelExecutionMode executionMode);
    [ExtensionAttribute]
public static ParallelQuery`1<TSource> WithMergeOptions(ParallelQuery`1<TSource> source, ParallelMergeOptions mergeOptions);
    public static ParallelQuery`1<int> Range(int start, int count);
    public static ParallelQuery`1<TResult> Repeat(TResult element, int count);
    public static ParallelQuery`1<TResult> Empty();
    [ExtensionAttribute]
public static void ForAll(ParallelQuery`1<TSource> source, Action`1<TSource> action);
    [ExtensionAttribute]
public static ParallelQuery`1<TSource> Where(ParallelQuery`1<TSource> source, Func`2<TSource, bool> predicate);
    [ExtensionAttribute]
public static ParallelQuery`1<TSource> Where(ParallelQuery`1<TSource> source, Func`3<TSource, int, bool> predicate);
    [ExtensionAttribute]
public static ParallelQuery`1<TResult> Select(ParallelQuery`1<TSource> source, Func`2<TSource, TResult> selector);
    [ExtensionAttribute]
public static ParallelQuery`1<TResult> Select(ParallelQuery`1<TSource> source, Func`3<TSource, int, TResult> selector);
    [ExtensionAttribute]
public static ParallelQuery`1<TResult> Zip(ParallelQuery`1<TFirst> first, ParallelQuery`1<TSecond> second, Func`3<TFirst, TSecond, TResult> resultSelector);
    [ObsoleteAttribute("The second data source of a binary operator must be of type System.Linq.ParallelQuery<T> rather than System.Collections.Generic.IEnumerable<T>. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery<T>.")]
[ExtensionAttribute]
public static ParallelQuery`1<TResult> Zip(ParallelQuery`1<TFirst> first, IEnumerable`1<TSecond> second, Func`3<TFirst, TSecond, TResult> resultSelector);
    [ExtensionAttribute]
public static ParallelQuery`1<TResult> Join(ParallelQuery`1<TOuter> outer, ParallelQuery`1<TInner> inner, Func`2<TOuter, TKey> outerKeySelector, Func`2<TInner, TKey> innerKeySelector, Func`3<TOuter, TInner, TResult> resultSelector);
    [ObsoleteAttribute("The second data source of a binary operator must be of type System.Linq.ParallelQuery<T> rather than System.Collections.Generic.IEnumerable<T>. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery<T>.")]
[ExtensionAttribute]
public static ParallelQuery`1<TResult> Join(ParallelQuery`1<TOuter> outer, IEnumerable`1<TInner> inner, Func`2<TOuter, TKey> outerKeySelector, Func`2<TInner, TKey> innerKeySelector, Func`3<TOuter, TInner, TResult> resultSelector);
    [ExtensionAttribute]
public static ParallelQuery`1<TResult> Join(ParallelQuery`1<TOuter> outer, ParallelQuery`1<TInner> inner, Func`2<TOuter, TKey> outerKeySelector, Func`2<TInner, TKey> innerKeySelector, Func`3<TOuter, TInner, TResult> resultSelector, IEqualityComparer`1<TKey> comparer);
    [ObsoleteAttribute("The second data source of a binary operator must be of type System.Linq.ParallelQuery<T> rather than System.Collections.Generic.IEnumerable<T>. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery<T>.")]
[ExtensionAttribute]
public static ParallelQuery`1<TResult> Join(ParallelQuery`1<TOuter> outer, IEnumerable`1<TInner> inner, Func`2<TOuter, TKey> outerKeySelector, Func`2<TInner, TKey> innerKeySelector, Func`3<TOuter, TInner, TResult> resultSelector, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static ParallelQuery`1<TResult> GroupJoin(ParallelQuery`1<TOuter> outer, ParallelQuery`1<TInner> inner, Func`2<TOuter, TKey> outerKeySelector, Func`2<TInner, TKey> innerKeySelector, Func`3<TOuter, IEnumerable`1<TInner>, TResult> resultSelector);
    [ObsoleteAttribute("The second data source of a binary operator must be of type System.Linq.ParallelQuery<T> rather than System.Collections.Generic.IEnumerable<T>. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery<T>.")]
[ExtensionAttribute]
public static ParallelQuery`1<TResult> GroupJoin(ParallelQuery`1<TOuter> outer, IEnumerable`1<TInner> inner, Func`2<TOuter, TKey> outerKeySelector, Func`2<TInner, TKey> innerKeySelector, Func`3<TOuter, IEnumerable`1<TInner>, TResult> resultSelector);
    [ExtensionAttribute]
public static ParallelQuery`1<TResult> GroupJoin(ParallelQuery`1<TOuter> outer, ParallelQuery`1<TInner> inner, Func`2<TOuter, TKey> outerKeySelector, Func`2<TInner, TKey> innerKeySelector, Func`3<TOuter, IEnumerable`1<TInner>, TResult> resultSelector, IEqualityComparer`1<TKey> comparer);
    [ObsoleteAttribute("The second data source of a binary operator must be of type System.Linq.ParallelQuery<T> rather than System.Collections.Generic.IEnumerable<T>. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery<T>.")]
[ExtensionAttribute]
public static ParallelQuery`1<TResult> GroupJoin(ParallelQuery`1<TOuter> outer, IEnumerable`1<TInner> inner, Func`2<TOuter, TKey> outerKeySelector, Func`2<TInner, TKey> innerKeySelector, Func`3<TOuter, IEnumerable`1<TInner>, TResult> resultSelector, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static ParallelQuery`1<TResult> SelectMany(ParallelQuery`1<TSource> source, Func`2<TSource, IEnumerable`1<TResult>> selector);
    [ExtensionAttribute]
public static ParallelQuery`1<TResult> SelectMany(ParallelQuery`1<TSource> source, Func`3<TSource, int, IEnumerable`1<TResult>> selector);
    [ExtensionAttribute]
public static ParallelQuery`1<TResult> SelectMany(ParallelQuery`1<TSource> source, Func`2<TSource, IEnumerable`1<TCollection>> collectionSelector, Func`3<TSource, TCollection, TResult> resultSelector);
    [ExtensionAttribute]
public static ParallelQuery`1<TResult> SelectMany(ParallelQuery`1<TSource> source, Func`3<TSource, int, IEnumerable`1<TCollection>> collectionSelector, Func`3<TSource, TCollection, TResult> resultSelector);
    [ExtensionAttribute]
public static OrderedParallelQuery`1<TSource> OrderBy(ParallelQuery`1<TSource> source, Func`2<TSource, TKey> keySelector);
    [ExtensionAttribute]
public static OrderedParallelQuery`1<TSource> OrderBy(ParallelQuery`1<TSource> source, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static OrderedParallelQuery`1<TSource> OrderByDescending(ParallelQuery`1<TSource> source, Func`2<TSource, TKey> keySelector);
    [ExtensionAttribute]
public static OrderedParallelQuery`1<TSource> OrderByDescending(ParallelQuery`1<TSource> source, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static OrderedParallelQuery`1<TSource> ThenBy(OrderedParallelQuery`1<TSource> source, Func`2<TSource, TKey> keySelector);
    [ExtensionAttribute]
public static OrderedParallelQuery`1<TSource> ThenBy(OrderedParallelQuery`1<TSource> source, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static OrderedParallelQuery`1<TSource> ThenByDescending(OrderedParallelQuery`1<TSource> source, Func`2<TSource, TKey> keySelector);
    [ExtensionAttribute]
public static OrderedParallelQuery`1<TSource> ThenByDescending(OrderedParallelQuery`1<TSource> source, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static ParallelQuery`1<IGrouping`2<TKey, TSource>> GroupBy(ParallelQuery`1<TSource> source, Func`2<TSource, TKey> keySelector);
    [ExtensionAttribute]
public static ParallelQuery`1<IGrouping`2<TKey, TSource>> GroupBy(ParallelQuery`1<TSource> source, Func`2<TSource, TKey> keySelector, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static ParallelQuery`1<IGrouping`2<TKey, TElement>> GroupBy(ParallelQuery`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`2<TSource, TElement> elementSelector);
    [ExtensionAttribute]
public static ParallelQuery`1<IGrouping`2<TKey, TElement>> GroupBy(ParallelQuery`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`2<TSource, TElement> elementSelector, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static ParallelQuery`1<TResult> GroupBy(ParallelQuery`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`3<TKey, IEnumerable`1<TSource>, TResult> resultSelector);
    [ExtensionAttribute]
public static ParallelQuery`1<TResult> GroupBy(ParallelQuery`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`3<TKey, IEnumerable`1<TSource>, TResult> resultSelector, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static ParallelQuery`1<TResult> GroupBy(ParallelQuery`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`2<TSource, TElement> elementSelector, Func`3<TKey, IEnumerable`1<TElement>, TResult> resultSelector);
    [ExtensionAttribute]
public static ParallelQuery`1<TResult> GroupBy(ParallelQuery`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`2<TSource, TElement> elementSelector, Func`3<TKey, IEnumerable`1<TElement>, TResult> resultSelector, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
private static T PerformAggregation(ParallelQuery`1<T> source, Func`3<T, T, T> reduce, T seed, bool seedIsSpecified, bool throwIfEmpty, QueryAggregationOptions options);
    [ExtensionAttribute]
private static TAccumulate PerformSequentialAggregation(ParallelQuery`1<TSource> source, TAccumulate seed, bool seedIsSpecified, Func`3<TAccumulate, TSource, TAccumulate> func);
    [ExtensionAttribute]
public static TSource Aggregate(ParallelQuery`1<TSource> source, Func`3<TSource, TSource, TSource> func);
    [ExtensionAttribute]
internal static TSource Aggregate(ParallelQuery`1<TSource> source, Func`3<TSource, TSource, TSource> func, QueryAggregationOptions options);
    [ExtensionAttribute]
public static TAccumulate Aggregate(ParallelQuery`1<TSource> source, TAccumulate seed, Func`3<TAccumulate, TSource, TAccumulate> func);
    [ExtensionAttribute]
internal static TAccumulate Aggregate(ParallelQuery`1<TSource> source, TAccumulate seed, Func`3<TAccumulate, TSource, TAccumulate> func, QueryAggregationOptions options);
    [ExtensionAttribute]
public static TResult Aggregate(ParallelQuery`1<TSource> source, TAccumulate seed, Func`3<TAccumulate, TSource, TAccumulate> func, Func`2<TAccumulate, TResult> resultSelector);
    [ExtensionAttribute]
public static TResult Aggregate(ParallelQuery`1<TSource> source, TAccumulate seed, Func`3<TAccumulate, TSource, TAccumulate> updateAccumulatorFunc, Func`3<TAccumulate, TAccumulate, TAccumulate> combineAccumulatorsFunc, Func`2<TAccumulate, TResult> resultSelector);
    [ExtensionAttribute]
public static TResult Aggregate(ParallelQuery`1<TSource> source, Func`1<TAccumulate> seedFactory, Func`3<TAccumulate, TSource, TAccumulate> updateAccumulatorFunc, Func`3<TAccumulate, TAccumulate, TAccumulate> combineAccumulatorsFunc, Func`2<TAccumulate, TResult> resultSelector);
    [ExtensionAttribute]
public static int Count(ParallelQuery`1<TSource> source);
    [ExtensionAttribute]
public static int Count(ParallelQuery`1<TSource> source, Func`2<TSource, bool> predicate);
    [ExtensionAttribute]
public static long LongCount(ParallelQuery`1<TSource> source);
    [ExtensionAttribute]
public static long LongCount(ParallelQuery`1<TSource> source, Func`2<TSource, bool> predicate);
    [ExtensionAttribute]
public static int Sum(ParallelQuery`1<int> source);
    [ExtensionAttribute]
public static Nullable`1<int> Sum(ParallelQuery`1<Nullable`1<int>> source);
    [ExtensionAttribute]
public static long Sum(ParallelQuery`1<long> source);
    [ExtensionAttribute]
public static Nullable`1<long> Sum(ParallelQuery`1<Nullable`1<long>> source);
    [ExtensionAttribute]
public static float Sum(ParallelQuery`1<float> source);
    [ExtensionAttribute]
public static Nullable`1<float> Sum(ParallelQuery`1<Nullable`1<float>> source);
    [ExtensionAttribute]
public static double Sum(ParallelQuery`1<double> source);
    [ExtensionAttribute]
public static Nullable`1<double> Sum(ParallelQuery`1<Nullable`1<double>> source);
    [ExtensionAttribute]
public static decimal Sum(ParallelQuery`1<decimal> source);
    [ExtensionAttribute]
public static Nullable`1<decimal> Sum(ParallelQuery`1<Nullable`1<decimal>> source);
    [ExtensionAttribute]
public static int Sum(ParallelQuery`1<TSource> source, Func`2<TSource, int> selector);
    [ExtensionAttribute]
public static Nullable`1<int> Sum(ParallelQuery`1<TSource> source, Func`2<TSource, Nullable`1<int>> selector);
    [ExtensionAttribute]
public static long Sum(ParallelQuery`1<TSource> source, Func`2<TSource, long> selector);
    [ExtensionAttribute]
public static Nullable`1<long> Sum(ParallelQuery`1<TSource> source, Func`2<TSource, Nullable`1<long>> selector);
    [ExtensionAttribute]
public static float Sum(ParallelQuery`1<TSource> source, Func`2<TSource, float> selector);
    [ExtensionAttribute]
public static Nullable`1<float> Sum(ParallelQuery`1<TSource> source, Func`2<TSource, Nullable`1<float>> selector);
    [ExtensionAttribute]
public static double Sum(ParallelQuery`1<TSource> source, Func`2<TSource, double> selector);
    [ExtensionAttribute]
public static Nullable`1<double> Sum(ParallelQuery`1<TSource> source, Func`2<TSource, Nullable`1<double>> selector);
    [ExtensionAttribute]
public static decimal Sum(ParallelQuery`1<TSource> source, Func`2<TSource, decimal> selector);
    [ExtensionAttribute]
public static Nullable`1<decimal> Sum(ParallelQuery`1<TSource> source, Func`2<TSource, Nullable`1<decimal>> selector);
    [ExtensionAttribute]
public static int Min(ParallelQuery`1<int> source);
    [ExtensionAttribute]
public static Nullable`1<int> Min(ParallelQuery`1<Nullable`1<int>> source);
    [ExtensionAttribute]
public static long Min(ParallelQuery`1<long> source);
    [ExtensionAttribute]
public static Nullable`1<long> Min(ParallelQuery`1<Nullable`1<long>> source);
    [ExtensionAttribute]
public static float Min(ParallelQuery`1<float> source);
    [ExtensionAttribute]
public static Nullable`1<float> Min(ParallelQuery`1<Nullable`1<float>> source);
    [ExtensionAttribute]
public static double Min(ParallelQuery`1<double> source);
    [ExtensionAttribute]
public static Nullable`1<double> Min(ParallelQuery`1<Nullable`1<double>> source);
    [ExtensionAttribute]
public static decimal Min(ParallelQuery`1<decimal> source);
    [ExtensionAttribute]
public static Nullable`1<decimal> Min(ParallelQuery`1<Nullable`1<decimal>> source);
    [ExtensionAttribute]
public static TSource Min(ParallelQuery`1<TSource> source);
    [ExtensionAttribute]
public static int Min(ParallelQuery`1<TSource> source, Func`2<TSource, int> selector);
    [ExtensionAttribute]
public static Nullable`1<int> Min(ParallelQuery`1<TSource> source, Func`2<TSource, Nullable`1<int>> selector);
    [ExtensionAttribute]
public static long Min(ParallelQuery`1<TSource> source, Func`2<TSource, long> selector);
    [ExtensionAttribute]
public static Nullable`1<long> Min(ParallelQuery`1<TSource> source, Func`2<TSource, Nullable`1<long>> selector);
    [ExtensionAttribute]
public static float Min(ParallelQuery`1<TSource> source, Func`2<TSource, float> selector);
    [ExtensionAttribute]
public static Nullable`1<float> Min(ParallelQuery`1<TSource> source, Func`2<TSource, Nullable`1<float>> selector);
    [ExtensionAttribute]
public static double Min(ParallelQuery`1<TSource> source, Func`2<TSource, double> selector);
    [ExtensionAttribute]
public static Nullable`1<double> Min(ParallelQuery`1<TSource> source, Func`2<TSource, Nullable`1<double>> selector);
    [ExtensionAttribute]
public static decimal Min(ParallelQuery`1<TSource> source, Func`2<TSource, decimal> selector);
    [ExtensionAttribute]
public static Nullable`1<decimal> Min(ParallelQuery`1<TSource> source, Func`2<TSource, Nullable`1<decimal>> selector);
    [ExtensionAttribute]
public static TResult Min(ParallelQuery`1<TSource> source, Func`2<TSource, TResult> selector);
    [ExtensionAttribute]
public static int Max(ParallelQuery`1<int> source);
    [ExtensionAttribute]
public static Nullable`1<int> Max(ParallelQuery`1<Nullable`1<int>> source);
    [ExtensionAttribute]
public static long Max(ParallelQuery`1<long> source);
    [ExtensionAttribute]
public static Nullable`1<long> Max(ParallelQuery`1<Nullable`1<long>> source);
    [ExtensionAttribute]
public static float Max(ParallelQuery`1<float> source);
    [ExtensionAttribute]
public static Nullable`1<float> Max(ParallelQuery`1<Nullable`1<float>> source);
    [ExtensionAttribute]
public static double Max(ParallelQuery`1<double> source);
    [ExtensionAttribute]
public static Nullable`1<double> Max(ParallelQuery`1<Nullable`1<double>> source);
    [ExtensionAttribute]
public static decimal Max(ParallelQuery`1<decimal> source);
    [ExtensionAttribute]
public static Nullable`1<decimal> Max(ParallelQuery`1<Nullable`1<decimal>> source);
    [ExtensionAttribute]
public static TSource Max(ParallelQuery`1<TSource> source);
    [ExtensionAttribute]
public static int Max(ParallelQuery`1<TSource> source, Func`2<TSource, int> selector);
    [ExtensionAttribute]
public static Nullable`1<int> Max(ParallelQuery`1<TSource> source, Func`2<TSource, Nullable`1<int>> selector);
    [ExtensionAttribute]
public static long Max(ParallelQuery`1<TSource> source, Func`2<TSource, long> selector);
    [ExtensionAttribute]
public static Nullable`1<long> Max(ParallelQuery`1<TSource> source, Func`2<TSource, Nullable`1<long>> selector);
    [ExtensionAttribute]
public static float Max(ParallelQuery`1<TSource> source, Func`2<TSource, float> selector);
    [ExtensionAttribute]
public static Nullable`1<float> Max(ParallelQuery`1<TSource> source, Func`2<TSource, Nullable`1<float>> selector);
    [ExtensionAttribute]
public static double Max(ParallelQuery`1<TSource> source, Func`2<TSource, double> selector);
    [ExtensionAttribute]
public static Nullable`1<double> Max(ParallelQuery`1<TSource> source, Func`2<TSource, Nullable`1<double>> selector);
    [ExtensionAttribute]
public static decimal Max(ParallelQuery`1<TSource> source, Func`2<TSource, decimal> selector);
    [ExtensionAttribute]
public static Nullable`1<decimal> Max(ParallelQuery`1<TSource> source, Func`2<TSource, Nullable`1<decimal>> selector);
    [ExtensionAttribute]
public static TResult Max(ParallelQuery`1<TSource> source, Func`2<TSource, TResult> selector);
    [ExtensionAttribute]
public static double Average(ParallelQuery`1<int> source);
    [ExtensionAttribute]
public static Nullable`1<double> Average(ParallelQuery`1<Nullable`1<int>> source);
    [ExtensionAttribute]
public static double Average(ParallelQuery`1<long> source);
    [ExtensionAttribute]
public static Nullable`1<double> Average(ParallelQuery`1<Nullable`1<long>> source);
    [ExtensionAttribute]
public static float Average(ParallelQuery`1<float> source);
    [ExtensionAttribute]
public static Nullable`1<float> Average(ParallelQuery`1<Nullable`1<float>> source);
    [ExtensionAttribute]
public static double Average(ParallelQuery`1<double> source);
    [ExtensionAttribute]
public static Nullable`1<double> Average(ParallelQuery`1<Nullable`1<double>> source);
    [ExtensionAttribute]
public static decimal Average(ParallelQuery`1<decimal> source);
    [ExtensionAttribute]
public static Nullable`1<decimal> Average(ParallelQuery`1<Nullable`1<decimal>> source);
    [ExtensionAttribute]
public static double Average(ParallelQuery`1<TSource> source, Func`2<TSource, int> selector);
    [ExtensionAttribute]
public static Nullable`1<double> Average(ParallelQuery`1<TSource> source, Func`2<TSource, Nullable`1<int>> selector);
    [ExtensionAttribute]
public static double Average(ParallelQuery`1<TSource> source, Func`2<TSource, long> selector);
    [ExtensionAttribute]
public static Nullable`1<double> Average(ParallelQuery`1<TSource> source, Func`2<TSource, Nullable`1<long>> selector);
    [ExtensionAttribute]
public static float Average(ParallelQuery`1<TSource> source, Func`2<TSource, float> selector);
    [ExtensionAttribute]
public static Nullable`1<float> Average(ParallelQuery`1<TSource> source, Func`2<TSource, Nullable`1<float>> selector);
    [ExtensionAttribute]
public static double Average(ParallelQuery`1<TSource> source, Func`2<TSource, double> selector);
    [ExtensionAttribute]
public static Nullable`1<double> Average(ParallelQuery`1<TSource> source, Func`2<TSource, Nullable`1<double>> selector);
    [ExtensionAttribute]
public static decimal Average(ParallelQuery`1<TSource> source, Func`2<TSource, decimal> selector);
    [ExtensionAttribute]
public static Nullable`1<decimal> Average(ParallelQuery`1<TSource> source, Func`2<TSource, Nullable`1<decimal>> selector);
    [ExtensionAttribute]
public static bool Any(ParallelQuery`1<TSource> source, Func`2<TSource, bool> predicate);
    [ExtensionAttribute]
public static bool Any(ParallelQuery`1<TSource> source);
    [ExtensionAttribute]
public static bool All(ParallelQuery`1<TSource> source, Func`2<TSource, bool> predicate);
    [ExtensionAttribute]
public static bool Contains(ParallelQuery`1<TSource> source, TSource value);
    [ExtensionAttribute]
public static bool Contains(ParallelQuery`1<TSource> source, TSource value, IEqualityComparer`1<TSource> comparer);
    [ExtensionAttribute]
public static ParallelQuery`1<TSource> Take(ParallelQuery`1<TSource> source, int count);
    [ExtensionAttribute]
public static ParallelQuery`1<TSource> TakeWhile(ParallelQuery`1<TSource> source, Func`2<TSource, bool> predicate);
    [ExtensionAttribute]
public static ParallelQuery`1<TSource> TakeWhile(ParallelQuery`1<TSource> source, Func`3<TSource, int, bool> predicate);
    [ExtensionAttribute]
public static ParallelQuery`1<TSource> Skip(ParallelQuery`1<TSource> source, int count);
    [ExtensionAttribute]
public static ParallelQuery`1<TSource> SkipWhile(ParallelQuery`1<TSource> source, Func`2<TSource, bool> predicate);
    [ExtensionAttribute]
public static ParallelQuery`1<TSource> SkipWhile(ParallelQuery`1<TSource> source, Func`3<TSource, int, bool> predicate);
    [ExtensionAttribute]
public static ParallelQuery`1<TSource> Concat(ParallelQuery`1<TSource> first, ParallelQuery`1<TSource> second);
    [ObsoleteAttribute("The second data source of a binary operator must be of type System.Linq.ParallelQuery<T> rather than System.Collections.Generic.IEnumerable<T>. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery<T>.")]
[ExtensionAttribute]
public static ParallelQuery`1<TSource> Concat(ParallelQuery`1<TSource> first, IEnumerable`1<TSource> second);
    [ExtensionAttribute]
public static bool SequenceEqual(ParallelQuery`1<TSource> first, ParallelQuery`1<TSource> second);
    [ObsoleteAttribute("The second data source of a binary operator must be of type System.Linq.ParallelQuery<T> rather than System.Collections.Generic.IEnumerable<T>. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery<T>.")]
[ExtensionAttribute]
public static bool SequenceEqual(ParallelQuery`1<TSource> first, IEnumerable`1<TSource> second);
    [ExtensionAttribute]
public static bool SequenceEqual(ParallelQuery`1<TSource> first, ParallelQuery`1<TSource> second, IEqualityComparer`1<TSource> comparer);
    private static void DisposeEnumerator(IEnumerator`1<TSource> e, CancellationState cancelState);
    [ObsoleteAttribute("The second data source of a binary operator must be of type System.Linq.ParallelQuery<T> rather than System.Collections.Generic.IEnumerable<T>. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery<T>.")]
[ExtensionAttribute]
public static bool SequenceEqual(ParallelQuery`1<TSource> first, IEnumerable`1<TSource> second, IEqualityComparer`1<TSource> comparer);
    [ExtensionAttribute]
public static ParallelQuery`1<TSource> Distinct(ParallelQuery`1<TSource> source);
    [ExtensionAttribute]
public static ParallelQuery`1<TSource> Distinct(ParallelQuery`1<TSource> source, IEqualityComparer`1<TSource> comparer);
    [ExtensionAttribute]
public static ParallelQuery`1<TSource> Union(ParallelQuery`1<TSource> first, ParallelQuery`1<TSource> second);
    [ExtensionAttribute]
[ObsoleteAttribute("The second data source of a binary operator must be of type System.Linq.ParallelQuery<T> rather than System.Collections.Generic.IEnumerable<T>. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery<T>.")]
public static ParallelQuery`1<TSource> Union(ParallelQuery`1<TSource> first, IEnumerable`1<TSource> second);
    [ExtensionAttribute]
public static ParallelQuery`1<TSource> Union(ParallelQuery`1<TSource> first, ParallelQuery`1<TSource> second, IEqualityComparer`1<TSource> comparer);
    [ObsoleteAttribute("The second data source of a binary operator must be of type System.Linq.ParallelQuery<T> rather than System.Collections.Generic.IEnumerable<T>. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery<T>.")]
[ExtensionAttribute]
public static ParallelQuery`1<TSource> Union(ParallelQuery`1<TSource> first, IEnumerable`1<TSource> second, IEqualityComparer`1<TSource> comparer);
    [ExtensionAttribute]
public static ParallelQuery`1<TSource> Intersect(ParallelQuery`1<TSource> first, ParallelQuery`1<TSource> second);
    [ObsoleteAttribute("The second data source of a binary operator must be of type System.Linq.ParallelQuery<T> rather than System.Collections.Generic.IEnumerable<T>. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery<T>.")]
[ExtensionAttribute]
public static ParallelQuery`1<TSource> Intersect(ParallelQuery`1<TSource> first, IEnumerable`1<TSource> second);
    [ExtensionAttribute]
public static ParallelQuery`1<TSource> Intersect(ParallelQuery`1<TSource> first, ParallelQuery`1<TSource> second, IEqualityComparer`1<TSource> comparer);
    [ExtensionAttribute]
[ObsoleteAttribute("The second data source of a binary operator must be of type System.Linq.ParallelQuery<T> rather than System.Collections.Generic.IEnumerable<T>. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery<T>.")]
public static ParallelQuery`1<TSource> Intersect(ParallelQuery`1<TSource> first, IEnumerable`1<TSource> second, IEqualityComparer`1<TSource> comparer);
    [ExtensionAttribute]
public static ParallelQuery`1<TSource> Except(ParallelQuery`1<TSource> first, ParallelQuery`1<TSource> second);
    [ExtensionAttribute]
[ObsoleteAttribute("The second data source of a binary operator must be of type System.Linq.ParallelQuery<T> rather than System.Collections.Generic.IEnumerable<T>. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery<T>.")]
public static ParallelQuery`1<TSource> Except(ParallelQuery`1<TSource> first, IEnumerable`1<TSource> second);
    [ExtensionAttribute]
public static ParallelQuery`1<TSource> Except(ParallelQuery`1<TSource> first, ParallelQuery`1<TSource> second, IEqualityComparer`1<TSource> comparer);
    [ExtensionAttribute]
[ObsoleteAttribute("The second data source of a binary operator must be of type System.Linq.ParallelQuery<T> rather than System.Collections.Generic.IEnumerable<T>. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery<T>.")]
public static ParallelQuery`1<TSource> Except(ParallelQuery`1<TSource> first, IEnumerable`1<TSource> second, IEqualityComparer`1<TSource> comparer);
    [ExtensionAttribute]
public static IEnumerable`1<TSource> AsEnumerable(ParallelQuery`1<TSource> source);
    [ExtensionAttribute]
public static TSource[] ToArray(ParallelQuery`1<TSource> source);
    [ExtensionAttribute]
public static List`1<TSource> ToList(ParallelQuery`1<TSource> source);
    [ExtensionAttribute]
public static Dictionary`2<TKey, TSource> ToDictionary(ParallelQuery`1<TSource> source, Func`2<TSource, TKey> keySelector);
    [ExtensionAttribute]
public static Dictionary`2<TKey, TSource> ToDictionary(ParallelQuery`1<TSource> source, Func`2<TSource, TKey> keySelector, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static Dictionary`2<TKey, TElement> ToDictionary(ParallelQuery`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`2<TSource, TElement> elementSelector);
    [ExtensionAttribute]
public static Dictionary`2<TKey, TElement> ToDictionary(ParallelQuery`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`2<TSource, TElement> elementSelector, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static ILookup`2<TKey, TSource> ToLookup(ParallelQuery`1<TSource> source, Func`2<TSource, TKey> keySelector);
    [ExtensionAttribute]
public static ILookup`2<TKey, TSource> ToLookup(ParallelQuery`1<TSource> source, Func`2<TSource, TKey> keySelector, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static ILookup`2<TKey, TElement> ToLookup(ParallelQuery`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`2<TSource, TElement> elementSelector);
    [ExtensionAttribute]
public static ILookup`2<TKey, TElement> ToLookup(ParallelQuery`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`2<TSource, TElement> elementSelector, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static ParallelQuery`1<TSource> Reverse(ParallelQuery`1<TSource> source);
    [ExtensionAttribute]
public static ParallelQuery`1<TResult> OfType(ParallelQuery source);
    [ExtensionAttribute]
public static ParallelQuery`1<TResult> Cast(ParallelQuery source);
    private static TSource GetOneWithPossibleDefault(QueryOperator`1<TSource> queryOp, bool throwIfTwo, bool defaultIfEmpty);
    [ExtensionAttribute]
public static TSource First(ParallelQuery`1<TSource> source);
    [ExtensionAttribute]
public static TSource First(ParallelQuery`1<TSource> source, Func`2<TSource, bool> predicate);
    [ExtensionAttribute]
public static TSource FirstOrDefault(ParallelQuery`1<TSource> source);
    [ExtensionAttribute]
public static TSource FirstOrDefault(ParallelQuery`1<TSource> source, Func`2<TSource, bool> predicate);
    [ExtensionAttribute]
public static TSource Last(ParallelQuery`1<TSource> source);
    [ExtensionAttribute]
public static TSource Last(ParallelQuery`1<TSource> source, Func`2<TSource, bool> predicate);
    [ExtensionAttribute]
public static TSource LastOrDefault(ParallelQuery`1<TSource> source);
    [ExtensionAttribute]
public static TSource LastOrDefault(ParallelQuery`1<TSource> source, Func`2<TSource, bool> predicate);
    [ExtensionAttribute]
public static TSource Single(ParallelQuery`1<TSource> source);
    [ExtensionAttribute]
public static TSource Single(ParallelQuery`1<TSource> source, Func`2<TSource, bool> predicate);
    [ExtensionAttribute]
public static TSource SingleOrDefault(ParallelQuery`1<TSource> source);
    [ExtensionAttribute]
public static TSource SingleOrDefault(ParallelQuery`1<TSource> source, Func`2<TSource, bool> predicate);
    [ExtensionAttribute]
public static ParallelQuery`1<TSource> DefaultIfEmpty(ParallelQuery`1<TSource> source);
    [ExtensionAttribute]
public static ParallelQuery`1<TSource> DefaultIfEmpty(ParallelQuery`1<TSource> source, TSource defaultValue);
    [ExtensionAttribute]
public static TSource ElementAt(ParallelQuery`1<TSource> source, int index);
    [ExtensionAttribute]
public static TSource ElementAtOrDefault(ParallelQuery`1<TSource> source, int index);
}
public enum System.Linq.ParallelExecutionMode : Enum {
    public int value__;
    public static ParallelExecutionMode Default;
    public static ParallelExecutionMode ForceParallelism;
}
public enum System.Linq.ParallelMergeOptions : Enum {
    public int value__;
    public static ParallelMergeOptions Default;
    public static ParallelMergeOptions NotBuffered;
    public static ParallelMergeOptions AutoBuffered;
    public static ParallelMergeOptions FullyBuffered;
}
public class System.Linq.ParallelQuery : object {
    private QuerySettings _specifiedSettings;
    internal QuerySettings SpecifiedQuerySettings { get; }
    internal ParallelQuery(QuerySettings specifiedSettings);
    internal QuerySettings get_SpecifiedQuerySettings();
    [ExcludeFromCodeCoverageAttribute]
internal virtual ParallelQuery`1<TCastTo> Cast();
    [ExcludeFromCodeCoverageAttribute]
internal virtual ParallelQuery`1<TCastTo> OfType();
    [ExcludeFromCodeCoverageAttribute]
internal virtual IEnumerator GetEnumeratorUntyped();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class System.Linq.ParallelQuery`1 : ParallelQuery {
    internal ParallelQuery`1(QuerySettings settings);
    internal sealed virtual ParallelQuery`1<TCastTo> Cast();
    internal sealed virtual ParallelQuery`1<TCastTo> OfType();
    internal virtual IEnumerator GetEnumeratorUntyped();
    public virtual IEnumerator`1<TSource> GetEnumerator();
}
[ExtensionAttribute]
public static class System.Linq.Queryable : object {
    [ExtensionAttribute]
public static IQueryable`1<TElement> AsQueryable(IEnumerable`1<TElement> source);
    [ExtensionAttribute]
public static IQueryable AsQueryable(IEnumerable source);
    [ExtensionAttribute]
public static IQueryable`1<TSource> Where(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, bool>> predicate);
    [ExtensionAttribute]
public static IQueryable`1<TSource> Where(IQueryable`1<TSource> source, Expression`1<Func`3<TSource, int, bool>> predicate);
    [ExtensionAttribute]
public static IQueryable`1<TResult> OfType(IQueryable source);
    [ExtensionAttribute]
public static IQueryable`1<TResult> Cast(IQueryable source);
    [ExtensionAttribute]
public static IQueryable`1<TResult> Select(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, TResult>> selector);
    [ExtensionAttribute]
public static IQueryable`1<TResult> Select(IQueryable`1<TSource> source, Expression`1<Func`3<TSource, int, TResult>> selector);
    [ExtensionAttribute]
public static IQueryable`1<TResult> SelectMany(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, IEnumerable`1<TResult>>> selector);
    [ExtensionAttribute]
public static IQueryable`1<TResult> SelectMany(IQueryable`1<TSource> source, Expression`1<Func`3<TSource, int, IEnumerable`1<TResult>>> selector);
    [ExtensionAttribute]
public static IQueryable`1<TResult> SelectMany(IQueryable`1<TSource> source, Expression`1<Func`3<TSource, int, IEnumerable`1<TCollection>>> collectionSelector, Expression`1<Func`3<TSource, TCollection, TResult>> resultSelector);
    [ExtensionAttribute]
public static IQueryable`1<TResult> SelectMany(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, IEnumerable`1<TCollection>>> collectionSelector, Expression`1<Func`3<TSource, TCollection, TResult>> resultSelector);
    private static Expression GetSourceExpression(IEnumerable`1<TSource> source);
    [ExtensionAttribute]
public static IQueryable`1<TResult> Join(IQueryable`1<TOuter> outer, IEnumerable`1<TInner> inner, Expression`1<Func`2<TOuter, TKey>> outerKeySelector, Expression`1<Func`2<TInner, TKey>> innerKeySelector, Expression`1<Func`3<TOuter, TInner, TResult>> resultSelector);
    [ExtensionAttribute]
public static IQueryable`1<TResult> Join(IQueryable`1<TOuter> outer, IEnumerable`1<TInner> inner, Expression`1<Func`2<TOuter, TKey>> outerKeySelector, Expression`1<Func`2<TInner, TKey>> innerKeySelector, Expression`1<Func`3<TOuter, TInner, TResult>> resultSelector, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static IQueryable`1<TResult> GroupJoin(IQueryable`1<TOuter> outer, IEnumerable`1<TInner> inner, Expression`1<Func`2<TOuter, TKey>> outerKeySelector, Expression`1<Func`2<TInner, TKey>> innerKeySelector, Expression`1<Func`3<TOuter, IEnumerable`1<TInner>, TResult>> resultSelector);
    [ExtensionAttribute]
public static IQueryable`1<TResult> GroupJoin(IQueryable`1<TOuter> outer, IEnumerable`1<TInner> inner, Expression`1<Func`2<TOuter, TKey>> outerKeySelector, Expression`1<Func`2<TInner, TKey>> innerKeySelector, Expression`1<Func`3<TOuter, IEnumerable`1<TInner>, TResult>> resultSelector, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static IOrderedQueryable`1<TSource> OrderBy(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, TKey>> keySelector);
    [ExtensionAttribute]
public static IOrderedQueryable`1<TSource> OrderBy(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, TKey>> keySelector, IComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static IOrderedQueryable`1<TSource> OrderByDescending(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, TKey>> keySelector);
    [ExtensionAttribute]
public static IOrderedQueryable`1<TSource> OrderByDescending(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, TKey>> keySelector, IComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static IOrderedQueryable`1<TSource> ThenBy(IOrderedQueryable`1<TSource> source, Expression`1<Func`2<TSource, TKey>> keySelector);
    [ExtensionAttribute]
public static IOrderedQueryable`1<TSource> ThenBy(IOrderedQueryable`1<TSource> source, Expression`1<Func`2<TSource, TKey>> keySelector, IComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static IOrderedQueryable`1<TSource> ThenByDescending(IOrderedQueryable`1<TSource> source, Expression`1<Func`2<TSource, TKey>> keySelector);
    [ExtensionAttribute]
public static IOrderedQueryable`1<TSource> ThenByDescending(IOrderedQueryable`1<TSource> source, Expression`1<Func`2<TSource, TKey>> keySelector, IComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static IQueryable`1<TSource> Take(IQueryable`1<TSource> source, int count);
    [ExtensionAttribute]
public static IQueryable`1<TSource> TakeWhile(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, bool>> predicate);
    [ExtensionAttribute]
public static IQueryable`1<TSource> TakeWhile(IQueryable`1<TSource> source, Expression`1<Func`3<TSource, int, bool>> predicate);
    [ExtensionAttribute]
public static IQueryable`1<TSource> Skip(IQueryable`1<TSource> source, int count);
    [ExtensionAttribute]
public static IQueryable`1<TSource> SkipWhile(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, bool>> predicate);
    [ExtensionAttribute]
public static IQueryable`1<TSource> SkipWhile(IQueryable`1<TSource> source, Expression`1<Func`3<TSource, int, bool>> predicate);
    [ExtensionAttribute]
public static IQueryable`1<IGrouping`2<TKey, TSource>> GroupBy(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, TKey>> keySelector);
    [ExtensionAttribute]
public static IQueryable`1<IGrouping`2<TKey, TElement>> GroupBy(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, TKey>> keySelector, Expression`1<Func`2<TSource, TElement>> elementSelector);
    [ExtensionAttribute]
public static IQueryable`1<IGrouping`2<TKey, TSource>> GroupBy(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, TKey>> keySelector, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static IQueryable`1<IGrouping`2<TKey, TElement>> GroupBy(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, TKey>> keySelector, Expression`1<Func`2<TSource, TElement>> elementSelector, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static IQueryable`1<TResult> GroupBy(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, TKey>> keySelector, Expression`1<Func`2<TSource, TElement>> elementSelector, Expression`1<Func`3<TKey, IEnumerable`1<TElement>, TResult>> resultSelector);
    [ExtensionAttribute]
public static IQueryable`1<TResult> GroupBy(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, TKey>> keySelector, Expression`1<Func`3<TKey, IEnumerable`1<TSource>, TResult>> resultSelector);
    [ExtensionAttribute]
public static IQueryable`1<TResult> GroupBy(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, TKey>> keySelector, Expression`1<Func`3<TKey, IEnumerable`1<TSource>, TResult>> resultSelector, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static IQueryable`1<TResult> GroupBy(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, TKey>> keySelector, Expression`1<Func`2<TSource, TElement>> elementSelector, Expression`1<Func`3<TKey, IEnumerable`1<TElement>, TResult>> resultSelector, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static IQueryable`1<TSource> Distinct(IQueryable`1<TSource> source);
    [ExtensionAttribute]
public static IQueryable`1<TSource> Distinct(IQueryable`1<TSource> source, IEqualityComparer`1<TSource> comparer);
    [ExtensionAttribute]
public static IQueryable`1<TSource> Concat(IQueryable`1<TSource> source1, IEnumerable`1<TSource> source2);
    [ExtensionAttribute]
public static IQueryable`1<TResult> Zip(IQueryable`1<TFirst> source1, IEnumerable`1<TSecond> source2, Expression`1<Func`3<TFirst, TSecond, TResult>> resultSelector);
    [ExtensionAttribute]
public static IQueryable`1<TSource> Union(IQueryable`1<TSource> source1, IEnumerable`1<TSource> source2);
    [ExtensionAttribute]
public static IQueryable`1<TSource> Union(IQueryable`1<TSource> source1, IEnumerable`1<TSource> source2, IEqualityComparer`1<TSource> comparer);
    [ExtensionAttribute]
public static IQueryable`1<TSource> Intersect(IQueryable`1<TSource> source1, IEnumerable`1<TSource> source2);
    [ExtensionAttribute]
public static IQueryable`1<TSource> Intersect(IQueryable`1<TSource> source1, IEnumerable`1<TSource> source2, IEqualityComparer`1<TSource> comparer);
    [ExtensionAttribute]
public static IQueryable`1<TSource> Except(IQueryable`1<TSource> source1, IEnumerable`1<TSource> source2);
    [ExtensionAttribute]
public static IQueryable`1<TSource> Except(IQueryable`1<TSource> source1, IEnumerable`1<TSource> source2, IEqualityComparer`1<TSource> comparer);
    [ExtensionAttribute]
public static TSource First(IQueryable`1<TSource> source);
    [ExtensionAttribute]
public static TSource First(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, bool>> predicate);
    [ExtensionAttribute]
public static TSource FirstOrDefault(IQueryable`1<TSource> source);
    [ExtensionAttribute]
public static TSource FirstOrDefault(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, bool>> predicate);
    [ExtensionAttribute]
public static TSource Last(IQueryable`1<TSource> source);
    [ExtensionAttribute]
public static TSource Last(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, bool>> predicate);
    [ExtensionAttribute]
public static TSource LastOrDefault(IQueryable`1<TSource> source);
    [ExtensionAttribute]
public static TSource LastOrDefault(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, bool>> predicate);
    [ExtensionAttribute]
public static TSource Single(IQueryable`1<TSource> source);
    [ExtensionAttribute]
public static TSource Single(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, bool>> predicate);
    [ExtensionAttribute]
public static TSource SingleOrDefault(IQueryable`1<TSource> source);
    [ExtensionAttribute]
public static TSource SingleOrDefault(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, bool>> predicate);
    [ExtensionAttribute]
public static TSource ElementAt(IQueryable`1<TSource> source, int index);
    [ExtensionAttribute]
public static TSource ElementAtOrDefault(IQueryable`1<TSource> source, int index);
    [ExtensionAttribute]
public static IQueryable`1<TSource> DefaultIfEmpty(IQueryable`1<TSource> source);
    [ExtensionAttribute]
public static IQueryable`1<TSource> DefaultIfEmpty(IQueryable`1<TSource> source, TSource defaultValue);
    [ExtensionAttribute]
public static bool Contains(IQueryable`1<TSource> source, TSource item);
    [ExtensionAttribute]
public static bool Contains(IQueryable`1<TSource> source, TSource item, IEqualityComparer`1<TSource> comparer);
    [ExtensionAttribute]
public static IQueryable`1<TSource> Reverse(IQueryable`1<TSource> source);
    [ExtensionAttribute]
public static bool SequenceEqual(IQueryable`1<TSource> source1, IEnumerable`1<TSource> source2);
    [ExtensionAttribute]
public static bool SequenceEqual(IQueryable`1<TSource> source1, IEnumerable`1<TSource> source2, IEqualityComparer`1<TSource> comparer);
    [ExtensionAttribute]
public static bool Any(IQueryable`1<TSource> source);
    [ExtensionAttribute]
public static bool Any(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, bool>> predicate);
    [ExtensionAttribute]
public static bool All(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, bool>> predicate);
    [ExtensionAttribute]
public static int Count(IQueryable`1<TSource> source);
    [ExtensionAttribute]
public static int Count(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, bool>> predicate);
    [ExtensionAttribute]
public static long LongCount(IQueryable`1<TSource> source);
    [ExtensionAttribute]
public static long LongCount(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, bool>> predicate);
    [ExtensionAttribute]
public static TSource Min(IQueryable`1<TSource> source);
    [ExtensionAttribute]
public static TResult Min(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, TResult>> selector);
    [ExtensionAttribute]
public static TSource Max(IQueryable`1<TSource> source);
    [ExtensionAttribute]
public static TResult Max(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, TResult>> selector);
    [ExtensionAttribute]
public static int Sum(IQueryable`1<int> source);
    [ExtensionAttribute]
public static Nullable`1<int> Sum(IQueryable`1<Nullable`1<int>> source);
    [ExtensionAttribute]
public static long Sum(IQueryable`1<long> source);
    [ExtensionAttribute]
public static Nullable`1<long> Sum(IQueryable`1<Nullable`1<long>> source);
    [ExtensionAttribute]
public static float Sum(IQueryable`1<float> source);
    [ExtensionAttribute]
public static Nullable`1<float> Sum(IQueryable`1<Nullable`1<float>> source);
    [ExtensionAttribute]
public static double Sum(IQueryable`1<double> source);
    [ExtensionAttribute]
public static Nullable`1<double> Sum(IQueryable`1<Nullable`1<double>> source);
    [ExtensionAttribute]
public static decimal Sum(IQueryable`1<decimal> source);
    [ExtensionAttribute]
public static Nullable`1<decimal> Sum(IQueryable`1<Nullable`1<decimal>> source);
    [ExtensionAttribute]
public static int Sum(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, int>> selector);
    [ExtensionAttribute]
public static Nullable`1<int> Sum(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, Nullable`1<int>>> selector);
    [ExtensionAttribute]
public static long Sum(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, long>> selector);
    [ExtensionAttribute]
public static Nullable`1<long> Sum(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, Nullable`1<long>>> selector);
    [ExtensionAttribute]
public static float Sum(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, float>> selector);
    [ExtensionAttribute]
public static Nullable`1<float> Sum(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, Nullable`1<float>>> selector);
    [ExtensionAttribute]
public static double Sum(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, double>> selector);
    [ExtensionAttribute]
public static Nullable`1<double> Sum(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, Nullable`1<double>>> selector);
    [ExtensionAttribute]
public static decimal Sum(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, decimal>> selector);
    [ExtensionAttribute]
public static Nullable`1<decimal> Sum(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, Nullable`1<decimal>>> selector);
    [ExtensionAttribute]
public static double Average(IQueryable`1<int> source);
    [ExtensionAttribute]
public static Nullable`1<double> Average(IQueryable`1<Nullable`1<int>> source);
    [ExtensionAttribute]
public static double Average(IQueryable`1<long> source);
    [ExtensionAttribute]
public static Nullable`1<double> Average(IQueryable`1<Nullable`1<long>> source);
    [ExtensionAttribute]
public static float Average(IQueryable`1<float> source);
    [ExtensionAttribute]
public static Nullable`1<float> Average(IQueryable`1<Nullable`1<float>> source);
    [ExtensionAttribute]
public static double Average(IQueryable`1<double> source);
    [ExtensionAttribute]
public static Nullable`1<double> Average(IQueryable`1<Nullable`1<double>> source);
    [ExtensionAttribute]
public static decimal Average(IQueryable`1<decimal> source);
    [ExtensionAttribute]
public static Nullable`1<decimal> Average(IQueryable`1<Nullable`1<decimal>> source);
    [ExtensionAttribute]
public static double Average(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, int>> selector);
    [ExtensionAttribute]
public static Nullable`1<double> Average(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, Nullable`1<int>>> selector);
    [ExtensionAttribute]
public static float Average(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, float>> selector);
    [ExtensionAttribute]
public static Nullable`1<float> Average(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, Nullable`1<float>>> selector);
    [ExtensionAttribute]
public static double Average(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, long>> selector);
    [ExtensionAttribute]
public static Nullable`1<double> Average(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, Nullable`1<long>>> selector);
    [ExtensionAttribute]
public static double Average(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, double>> selector);
    [ExtensionAttribute]
public static Nullable`1<double> Average(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, Nullable`1<double>>> selector);
    [ExtensionAttribute]
public static decimal Average(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, decimal>> selector);
    [ExtensionAttribute]
public static Nullable`1<decimal> Average(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, Nullable`1<decimal>>> selector);
    [ExtensionAttribute]
public static TSource Aggregate(IQueryable`1<TSource> source, Expression`1<Func`3<TSource, TSource, TSource>> func);
    [ExtensionAttribute]
public static TAccumulate Aggregate(IQueryable`1<TSource> source, TAccumulate seed, Expression`1<Func`3<TAccumulate, TSource, TAccumulate>> func);
    [ExtensionAttribute]
public static TResult Aggregate(IQueryable`1<TSource> source, TAccumulate seed, Expression`1<Func`3<TAccumulate, TSource, TAccumulate>> func, Expression`1<Func`2<TAccumulate, TResult>> selector);
    [ExtensionAttribute]
public static IQueryable`1<TSource> SkipLast(IQueryable`1<TSource> source, int count);
    [ExtensionAttribute]
public static IQueryable`1<TSource> TakeLast(IQueryable`1<TSource> source, int count);
    [ExtensionAttribute]
public static IQueryable`1<TSource> Append(IQueryable`1<TSource> source, TSource element);
    [ExtensionAttribute]
public static IQueryable`1<TSource> Prepend(IQueryable`1<TSource> source, TSource element);
}
internal class System.Linq.Set`1 : object {
    private IEqualityComparer`1<TElement> _comparer;
    private Int32[] _buckets;
    private Slot[] _slots;
    private int _count;
    public int Count { get; }
    public Set`1(IEqualityComparer`1<TElement> comparer);
    public bool Add(TElement value);
    public bool Remove(TElement value);
    private void Resize();
    public TElement[] ToArray();
    public List`1<TElement> ToList();
    public int get_Count();
    public void UnionWith(IEnumerable`1<TElement> other);
    private int InternalGetHashCode(TElement value);
}
internal class System.Linq.SingleLinkedNode`1 : object {
    [CompilerGeneratedAttribute]
private TSource <Item>k__BackingField;
    [CompilerGeneratedAttribute]
private SingleLinkedNode`1<TSource> <Linked>k__BackingField;
    public TSource Item { get; }
    public SingleLinkedNode`1<TSource> Linked { get; }
    public SingleLinkedNode`1(TSource item);
    private SingleLinkedNode`1(SingleLinkedNode`1<TSource> linked, TSource item);
    [CompilerGeneratedAttribute]
public TSource get_Item();
    [CompilerGeneratedAttribute]
public SingleLinkedNode`1<TSource> get_Linked();
    public SingleLinkedNode`1<TSource> Add(TSource item);
    public int GetCount();
    public IEnumerator`1<TSource> GetEnumerator(int count);
    public SingleLinkedNode`1<TSource> GetNode(int index);
    private TSource[] ToArray(int count);
}
internal static class System.Linq.Strings : object {
    internal static string ArgumentNotIEnumerableGeneric(string message);
    internal static string ArgumentNotValid(string message);
    internal static string NoMethodOnType(string name, object type);
    internal static string NoMethodOnTypeMatchingArguments(string name, object type);
    internal static string EnumeratingNullEnumerableExpression();
}
internal class System.Linq.SystemCore_EnumerableDebugView : object {
    [DebuggerBrowsableAttribute("0")]
private IEnumerable _enumerable;
    [DebuggerBrowsableAttribute("3")]
public Object[] Items { get; }
    public SystemCore_EnumerableDebugView(IEnumerable enumerable);
    public Object[] get_Items();
}
internal class System.Linq.SystemCore_EnumerableDebugView`1 : object {
    [DebuggerBrowsableAttribute("0")]
private IEnumerable`1<T> _enumerable;
    [DebuggerBrowsableAttribute("3")]
public T[] Items { get; }
    public SystemCore_EnumerableDebugView`1(IEnumerable`1<T> enumerable);
    public T[] get_Items();
}
internal class System.Linq.SystemCore_EnumerableDebugViewEmptyException : Exception {
    public string Empty { get; }
    public string get_Empty();
}
internal class System.Linq.SystemLinq_GroupingDebugView`2 : object {
    private Grouping`2<TKey, TElement> _grouping;
    private TElement[] _cachedValues;
    public TKey Key { get; }
    [DebuggerBrowsableAttribute("3")]
public TElement[] Values { get; }
    public SystemLinq_GroupingDebugView`2(Grouping`2<TKey, TElement> grouping);
    public TKey get_Key();
    public TElement[] get_Values();
}
internal class System.Linq.SystemLinq_LookupDebugView`2 : object {
    private Lookup`2<TKey, TElement> _lookup;
    private IGrouping`2[] _cachedGroupings;
    [DebuggerBrowsableAttribute("3")]
public IGrouping`2[] Groupings { get; }
    public SystemLinq_LookupDebugView`2(Lookup`2<TKey, TElement> lookup);
    public IGrouping`2[] get_Groupings();
}
[ExtensionAttribute]
internal static class System.Linq.TypeHelper : object {
    internal static Type FindGenericType(Type definition, Type type);
    [ExtensionAttribute]
internal static IEnumerable`1<MethodInfo> GetStaticMethods(Type type);
}
internal static class System.Linq.Utilities : object {
    public static bool AreEqualityComparersEqual(IEqualityComparer`1<TSource> left, IEqualityComparer`1<TSource> right);
    public static Func`2<TSource, bool> CombinePredicates(Func`2<TSource, bool> predicate1, Func`2<TSource, bool> predicate2);
    public static Func`2<TSource, TResult> CombineSelectors(Func`2<TSource, TMiddle> selector1, Func`2<TMiddle, TResult> selector2);
}
public class System.Management.Instrumentation.InstanceNotFoundException : InstrumentationException {
    protected InstanceNotFoundException(SerializationInfo info, StreamingContext context);
    public InstanceNotFoundException(string message);
    public InstanceNotFoundException(string message, Exception innerException);
}
public class System.Management.Instrumentation.InstrumentationBaseException : Exception {
    protected InstrumentationBaseException(SerializationInfo info, StreamingContext context);
    public InstrumentationBaseException(string message);
    public InstrumentationBaseException(string message, Exception innerException);
}
public class System.Management.Instrumentation.InstrumentationException : InstrumentationBaseException {
    public InstrumentationException(Exception innerException);
    protected InstrumentationException(SerializationInfo info, StreamingContext context);
    public InstrumentationException(string message);
    public InstrumentationException(string message, Exception innerException);
}
[AttributeUsageAttribute("96")]
public class System.Management.Instrumentation.ManagementBindAttribute : ManagementNewInstanceAttribute {
    public Type Schema { get; public set; }
    public Type get_Schema();
    public void set_Schema(Type value);
}
[AttributeUsageAttribute("64")]
public class System.Management.Instrumentation.ManagementCommitAttribute : ManagementMemberAttribute {
}
[AttributeUsageAttribute("384")]
public class System.Management.Instrumentation.ManagementConfigurationAttribute : ManagementMemberAttribute {
    public ManagementConfigurationType Mode { get; public set; }
    public Type Schema { get; public set; }
    public ManagementConfigurationType get_Mode();
    public void set_Mode(ManagementConfigurationType value);
    public Type get_Schema();
    public void set_Schema(Type value);
}
public enum System.Management.Instrumentation.ManagementConfigurationType : Enum {
    public int value__;
    public static ManagementConfigurationType Apply;
    public static ManagementConfigurationType OnCommit;
}
[AttributeUsageAttribute("96")]
public class System.Management.Instrumentation.ManagementCreateAttribute : ManagementNewInstanceAttribute {
}
[AttributeUsageAttribute("4")]
public class System.Management.Instrumentation.ManagementEntityAttribute : Attribute {
    public bool External { get; public set; }
    public string Name { get; public set; }
    public bool Singleton { get; public set; }
    public bool get_External();
    public void set_External(bool value);
    public string get_Name();
    public void set_Name(string value);
    public bool get_Singleton();
    public void set_Singleton(bool value);
}
[AttributeUsageAttribute("96")]
public class System.Management.Instrumentation.ManagementEnumeratorAttribute : ManagementNewInstanceAttribute {
    public Type Schema { get; public set; }
    public Type get_Schema();
    public void set_Schema(Type value);
}
public enum System.Management.Instrumentation.ManagementHostingModel : Enum {
    public int value__;
    public static ManagementHostingModel Decoupled;
    public static ManagementHostingModel LocalService;
    public static ManagementHostingModel LocalSystem;
    public static ManagementHostingModel NetworkService;
}
[AttributeUsageAttribute("384")]
public class System.Management.Instrumentation.ManagementKeyAttribute : ManagementMemberAttribute {
}
[AttributeUsageAttribute("32767")]
public abstract class System.Management.Instrumentation.ManagementMemberAttribute : Attribute {
    public string Name { get; public set; }
    public string get_Name();
    public void set_Name(string value);
}
[AttributeUsageAttribute("2048")]
public class System.Management.Instrumentation.ManagementNameAttribute : Attribute {
    public string Name { get; }
    public ManagementNameAttribute(string name);
    public string get_Name();
}
[AttributeUsageAttribute("96")]
public abstract class System.Management.Instrumentation.ManagementNewInstanceAttribute : ManagementMemberAttribute {
}
[AttributeUsageAttribute("384")]
public class System.Management.Instrumentation.ManagementProbeAttribute : ManagementMemberAttribute {
    public Type Schema { get; public set; }
    public Type get_Schema();
    public void set_Schema(Type value);
}
[AttributeUsageAttribute("2432")]
public class System.Management.Instrumentation.ManagementReferenceAttribute : Attribute {
    public string Type { get; public set; }
    public string get_Type();
    public void set_Type(string value);
}
[AttributeUsageAttribute("64")]
public class System.Management.Instrumentation.ManagementRemoveAttribute : ManagementMemberAttribute {
    public Type Schema { get; public set; }
    public Type get_Schema();
    public void set_Schema(Type value);
}
[AttributeUsageAttribute("64")]
public class System.Management.Instrumentation.ManagementTaskAttribute : ManagementMemberAttribute {
    public Type Schema { get; public set; }
    public Type get_Schema();
    public void set_Schema(Type value);
}
[AttributeUsageAttribute("1")]
public class System.Management.Instrumentation.WmiConfigurationAttribute : Attribute {
    public string HostingGroup { get; public set; }
    public ManagementHostingModel HostingModel { get; public set; }
    public bool IdentifyLevel { get; public set; }
    public string NamespaceSecurity { get; public set; }
    public string Scope { get; }
    public string SecurityRestriction { get; public set; }
    public WmiConfigurationAttribute(string scope);
    public string get_HostingGroup();
    public void set_HostingGroup(string value);
    public ManagementHostingModel get_HostingModel();
    public void set_HostingModel(ManagementHostingModel value);
    public bool get_IdentifyLevel();
    public void set_IdentifyLevel(bool value);
    public string get_NamespaceSecurity();
    public void set_NamespaceSecurity(string value);
    public string get_Scope();
    public string get_SecurityRestriction();
    public void set_SecurityRestriction(string value);
}
[AttributeUsageAttribute("32767")]
internal class System.MonoDocumentationNoteAttribute : MonoTODOAttribute {
    public MonoDocumentationNoteAttribute(string comment);
}
[AttributeUsageAttribute("32767")]
internal class System.MonoExtensionAttribute : MonoTODOAttribute {
    public MonoExtensionAttribute(string comment);
}
[AttributeUsageAttribute("32767")]
internal class System.MonoInternalNoteAttribute : MonoTODOAttribute {
    public MonoInternalNoteAttribute(string comment);
}
[AttributeUsageAttribute("32767")]
internal class System.MonoLimitationAttribute : MonoTODOAttribute {
    public MonoLimitationAttribute(string comment);
}
[AttributeUsageAttribute("32767")]
internal class System.MonoNotSupportedAttribute : MonoTODOAttribute {
    public MonoNotSupportedAttribute(string comment);
}
[AttributeUsageAttribute("32767")]
internal class System.MonoTODOAttribute : Attribute {
    private string comment;
    public string Comment { get; }
    public MonoTODOAttribute(string comment);
    public string get_Comment();
}
internal static class System.MonoUtil : object {
    public static bool IsUnix;
    private static MonoUtil();
}
public class System.Net.Sockets.UnixDomainSocketEndPoint : EndPoint {
    private static int s_nativePathOffset;
    private static int s_nativePathLength;
    private static int s_nativeAddressSize;
    private static AddressFamily EndPointAddressFamily;
    private static Encoding s_pathEncoding;
    private static Lazy`1<bool> s_udsSupported;
    private string _path;
    private Byte[] _encodedPath;
    public AddressFamily AddressFamily { get; }
    public UnixDomainSocketEndPoint(string path);
    internal UnixDomainSocketEndPoint(SocketAddress socketAddress);
    private static UnixDomainSocketEndPoint();
    private SocketAddress CreateSocketAddressForSerialize();
    public virtual SocketAddress Serialize();
    public virtual EndPoint Create(SocketAddress socketAddress);
    public virtual AddressFamily get_AddressFamily();
    public virtual string ToString();
    private static bool IsAbstract(string path);
    private static bool IsAbstract(Byte[] encodedPath);
}
internal static class System.NotImplemented : object {
    internal static Exception ByDesign { get; }
    internal static Exception get_ByDesign();
    internal static Exception ByDesignWithMessage(string message);
    internal static Exception ActiveIssue(string issue);
}
public abstract class System.Reflection.DispatchProxy : object {
    protected abstract virtual object Invoke(MethodInfo targetMethod, Object[] args);
    public static T Create();
}
internal static class System.Reflection.DispatchProxyGenerator : object {
    private static int InvokeActionFieldAndCtorParameterIndex;
    private static Dictionary`2<Type, Dictionary`2<Type, Type>> s_baseTypeAndInterfaceToGeneratedProxyType;
    private static ProxyAssembly s_proxyAssembly;
    private static MethodInfo s_dispatchProxyInvokeMethod;
    private static DispatchProxyGenerator();
    internal static object CreateProxyInstance(Type baseType, Type interfaceType);
    private static Type GetProxyType(Type baseType, Type interfaceType);
    private static Type GenerateProxyType(Type baseType, Type interfaceType);
    private static void Invoke(Object[] args);
}
public class System.Runtime.CompilerServices.CallSite : object {
    internal static string CallSiteTargetMethodName;
    private static CacheDict`2 modreq(System.Runtime.CompilerServices.IsVolatile) s_siteCtors;
    internal CallSiteBinder _binder;
    internal bool _match;
    public CallSiteBinder Binder { get; }
    internal CallSite(CallSiteBinder binder);
    public CallSiteBinder get_Binder();
    public static CallSite Create(Type delegateType, CallSiteBinder binder);
}
public class System.Runtime.CompilerServices.CallSite`1 : CallSite {
    public T Target;
    internal T[] Rules;
    internal CallSite _cachedMatchmaker;
    private static T s_cachedUpdate;
    private static T modreq(System.Runtime.CompilerServices.IsVolatile) s_cachedNoMatch;
    private static int MaxRules;
    public T Update { get; }
    private CallSite`1(CallSiteBinder binder);
    public T get_Update();
    internal CallSite`1<T> CreateMatchMaker();
    internal CallSite GetMatchmaker();
    internal void ReleaseMatchmaker(CallSite matchMaker);
    public static CallSite`1<T> Create(CallSiteBinder binder);
    private T GetUpdateDelegate();
    private T GetUpdateDelegate(T& addr);
    private void ClearRuleCache();
    internal void AddRule(T newRule);
    internal void MoveRule(int i);
    internal T MakeUpdateDelegate();
    private static bool IsSimpleSignature(MethodInfo invoke, Type[]& sig);
    private T CreateCustomUpdateDelegate(MethodInfo invoke);
    private T CreateCustomNoMatchDelegate(MethodInfo invoke);
    private static Expression Convert(Expression arg, Type type);
}
public abstract class System.Runtime.CompilerServices.CallSiteBinder : object {
    internal Dictionary`2<Type, object> Cache;
    [CompilerGeneratedAttribute]
private static LabelTarget <UpdateLabel>k__BackingField;
    public static LabelTarget UpdateLabel { get; }
    private static CallSiteBinder();
    [CompilerGeneratedAttribute]
public static LabelTarget get_UpdateLabel();
    public abstract virtual Expression Bind(Object[] args, ReadOnlyCollection`1<ParameterExpression> parameters, LabelTarget returnLabel);
    public virtual T BindDelegate(CallSite`1<T> site, Object[] args);
    internal T BindCore(CallSite`1<T> site, Object[] args);
    protected void CacheTarget(T target);
    private static Expression`1<T> Stitch(Expression binding, LambdaSignature`1<T> signature);
    internal RuleCache`1<T> GetRuleCache();
}
public static class System.Runtime.CompilerServices.CallSiteHelpers : object {
    private static Type s_knownNonDynamicMethodType;
    private static CallSiteHelpers();
    public static bool IsInternalFrame(MethodBase mb);
}
[DebuggerStepThroughAttribute]
[EditorBrowsableAttribute("1")]
public static class System.Runtime.CompilerServices.CallSiteOps : object {
    [ObsoleteAttribute("do not use this method", "True")]
[EditorBrowsableAttribute("1")]
public static CallSite`1<T> CreateMatchmaker(CallSite`1<T> site);
    [ObsoleteAttribute("do not use this method", "True")]
[EditorBrowsableAttribute("1")]
public static bool SetNotMatched(CallSite site);
    [ObsoleteAttribute("do not use this method", "True")]
[EditorBrowsableAttribute("1")]
public static bool GetMatch(CallSite site);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("do not use this method", "True")]
public static void ClearMatch(CallSite site);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("do not use this method", "True")]
public static void AddRule(CallSite`1<T> site, T rule);
    [ObsoleteAttribute("do not use this method", "True")]
[EditorBrowsableAttribute("1")]
public static void UpdateRules(CallSite`1<T> this, int matched);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("do not use this method", "True")]
public static T[] GetRules(CallSite`1<T> site);
    [ObsoleteAttribute("do not use this method", "True")]
[EditorBrowsableAttribute("1")]
public static RuleCache`1<T> GetRuleCache(CallSite`1<T> site);
    [ObsoleteAttribute("do not use this method", "True")]
[EditorBrowsableAttribute("1")]
public static void MoveRule(RuleCache`1<T> cache, T rule, int i);
    [ObsoleteAttribute("do not use this method", "True")]
[EditorBrowsableAttribute("1")]
public static T[] GetCachedRules(RuleCache`1<T> cache);
    [ObsoleteAttribute("do not use this method", "True")]
[EditorBrowsableAttribute("1")]
public static T Bind(CallSiteBinder binder, CallSite`1<T> site, Object[] args);
}
[EditorBrowsableAttribute("1")]
[DebuggerStepThroughAttribute]
public class System.Runtime.CompilerServices.Closure : object {
    public Object[] Constants;
    public Object[] Locals;
    public Closure(Object[] constants, Object[] locals);
}
public abstract class System.Runtime.CompilerServices.DebugInfoGenerator : object {
    public static DebugInfoGenerator CreatePdbGenerator();
    public abstract virtual void MarkSequencePoint(LambdaExpression method, int ilOffset, DebugInfoExpression sequencePoint);
    internal virtual void MarkSequencePoint(LambdaExpression method, MethodBase methodBase, ILGenerator ilg, DebugInfoExpression sequencePoint);
    internal virtual void SetLocalName(LocalBuilder localBuilder, string name);
}
[AttributeUsageAttribute("10636")]
public class System.Runtime.CompilerServices.DynamicAttribute : Attribute {
    private Boolean[] _transformFlags;
    public IList`1<bool> TransformFlags { get; }
    public DynamicAttribute(Boolean[] transformFlags);
    public IList`1<bool> get_TransformFlags();
}
[ObsoleteAttribute("do not use this type", "True")]
public class System.Runtime.CompilerServices.ExecutionScope : object {
    public ExecutionScope Parent;
    public Object[] Globals;
    public Object[] Locals;
    public Object[] CreateHoistedLocals();
    public Delegate CreateDelegate(int indexLambda, Object[] locals);
    public Expression IsolateExpression(Expression expression, Object[] locals);
}
internal class System.Runtime.CompilerServices.FriendAccessAllowedAttribute : Attribute {
}
[DefaultMemberAttribute("Item")]
public interface System.Runtime.CompilerServices.IRuntimeVariables {
    public int Count { get; }
    public object Item { get; public set; }
    public abstract virtual int get_Count();
    public abstract virtual object get_Item(int index);
    public abstract virtual void set_Item(int index, object value);
}
public interface System.Runtime.CompilerServices.IStrongBox {
    public object Value { get; public set; }
    public abstract virtual object get_Value();
    public abstract virtual void set_Value(object value);
}
[AttributeUsageAttribute("352")]
internal class System.Runtime.CompilerServices.PreserveDependencyAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Condition>k__BackingField;
    public string Condition { get; public set; }
    public PreserveDependencyAttribute(string memberSignature);
    public PreserveDependencyAttribute(string memberSignature, string typeName);
    public PreserveDependencyAttribute(string memberSignature, string typeName, string assembly);
    [CompilerGeneratedAttribute]
public string get_Condition();
    [CompilerGeneratedAttribute]
public void set_Condition(string value);
}
[DefaultMemberAttribute("Item")]
public class System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1 : object {
    private static int DefaultCapacity;
    private T[] _items;
    private int _size;
    private int _version;
    public int Capacity { get; public set; }
    public int Count { get; }
    public T Item { get; public set; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private object System.Collections.IList.Item { get; private set; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public ReadOnlyCollectionBuilder`1(int capacity);
    public ReadOnlyCollectionBuilder`1(IEnumerable`1<T> collection);
    public int get_Capacity();
    public void set_Capacity(int value);
    public sealed virtual int get_Count();
    public sealed virtual int IndexOf(T item);
    public sealed virtual void Insert(int index, T item);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
    public sealed virtual void Add(T item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    public sealed virtual bool Remove(T item);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    public void Reverse();
    public void Reverse(int index, int count);
    public T[] ToArray();
    public ReadOnlyCollection`1<T> ToReadOnlyCollection();
    private void EnsureCapacity(int min);
    private static bool IsCompatibleObject(object value);
    private static void ValidateNullValue(object value, string argument);
}
[DebuggerStepThroughAttribute]
[EditorBrowsableAttribute("1")]
public class System.Runtime.CompilerServices.RuleCache`1 : object {
    private T[] _rules;
    private object _cacheLock;
    private static int MaxRules;
    private static int InsertPosition;
    internal T[] GetRules();
    internal void MoveRule(T rule, int i);
    internal void AddRule(T newRule);
    internal void ReplaceRule(T oldRule, T newRule);
    private static T[] AddOrInsert(T[] rules, T item);
}
[EditorBrowsableAttribute("1")]
[DebuggerStepThroughAttribute]
public static class System.Runtime.CompilerServices.RuntimeOps : object {
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("do not use this method", "True")]
public static bool ExpandoTryGetValue(ExpandoObject expando, object indexClass, int index, string name, bool ignoreCase, Object& value);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("do not use this method", "True")]
public static object ExpandoTrySetValue(ExpandoObject expando, object indexClass, int index, object value, string name, bool ignoreCase);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("do not use this method", "True")]
public static bool ExpandoTryDeleteValue(ExpandoObject expando, object indexClass, int index, string name, bool ignoreCase);
    [ObsoleteAttribute("do not use this method", "True")]
[EditorBrowsableAttribute("1")]
public static bool ExpandoCheckVersion(ExpandoObject expando, object version);
    [ObsoleteAttribute("do not use this method", "True")]
[EditorBrowsableAttribute("1")]
public static void ExpandoPromoteClass(ExpandoObject expando, object oldClass, object newClass);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("do not use this method", "True")]
public static Expression Quote(Expression expression, object hoistedLocals, Object[] locals);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("do not use this method", "True")]
public static IRuntimeVariables MergeRuntimeVariables(IRuntimeVariables first, IRuntimeVariables second, Int32[] indexes);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("do not use this method", "True")]
public static IRuntimeVariables CreateRuntimeVariables(Object[] data, Int64[] indexes);
    [ObsoleteAttribute("do not use this method", "True")]
[EditorBrowsableAttribute("1")]
public static IRuntimeVariables CreateRuntimeVariables();
}
public class System.Runtime.CompilerServices.StrongBox`1 : object {
    public T Value;
    private object System.Runtime.CompilerServices.IStrongBox.Value { get; private set; }
    public StrongBox`1(T value);
    private sealed virtual override object System.Runtime.CompilerServices.IStrongBox.get_Value();
    private sealed virtual override void System.Runtime.CompilerServices.IStrongBox.set_Value(object value);
}
internal class System.Runtime.CompilerServices.TrueReadOnlyCollection`1 : ReadOnlyCollection`1<T> {
    public TrueReadOnlyCollection`1(T[] list);
}
public class System.Runtime.InteropServices.ComAwareEventInfo : EventInfo {
    [MonoTODOAttribute]
public EventAttributes Attributes { get; }
    [MonoTODOAttribute]
public Type DeclaringType { get; }
    [MonoTODOAttribute]
public string Name { get; }
    [MonoTODOAttribute]
public Type ReflectedType { get; }
    [MonoTODOAttribute]
public ComAwareEventInfo(Type type, string eventName);
    public virtual EventAttributes get_Attributes();
    public virtual Type get_DeclaringType();
    public virtual string get_Name();
    [MonoTODOAttribute]
public virtual void AddEventHandler(object target, Delegate handler);
    [MonoTODOAttribute]
public virtual void RemoveEventHandler(object target, Delegate handler);
    [MonoTODOAttribute]
public virtual MethodInfo GetAddMethod(bool nonPublic);
    [MonoTODOAttribute]
public virtual MethodInfo GetRaiseMethod(bool nonPublic);
    [MonoTODOAttribute]
public virtual MethodInfo GetRemoveMethod(bool nonPublic);
    [MonoTODOAttribute]
public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    [MonoTODOAttribute]
public virtual Object[] GetCustomAttributes(bool inherit);
    [MonoTODOAttribute]
public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual Type get_ReflectedType();
}
public class System.Security.Cryptography.AesCng : Aes {
    public Byte[] Key { get; public set; }
    public int KeySize { get; public set; }
    public AesCng(string keyName);
    public AesCng(string keyName, CngProvider provider);
    public AesCng(string keyName, CngProvider provider, CngKeyOpenOptions openOptions);
    public virtual Byte[] get_Key();
    public virtual void set_Key(Byte[] value);
    public virtual int get_KeySize();
    public virtual void set_KeySize(int value);
    public virtual ICryptoTransform CreateDecryptor();
    public virtual ICryptoTransform CreateDecryptor(Byte[] rgbKey, Byte[] rgbIV);
    public virtual ICryptoTransform CreateEncryptor();
    public virtual ICryptoTransform CreateEncryptor(Byte[] rgbKey, Byte[] rgbIV);
    protected virtual void Dispose(bool disposing);
    public virtual void GenerateIV();
    public virtual void GenerateKey();
}
public class System.Security.Cryptography.AesCryptoServiceProvider : Aes {
    public Byte[] IV { get; public set; }
    public Byte[] Key { get; public set; }
    public int KeySize { get; public set; }
    public int FeedbackSize { get; public set; }
    public CipherMode Mode { get; public set; }
    public PaddingMode Padding { get; public set; }
    public virtual void GenerateIV();
    public virtual void GenerateKey();
    public virtual ICryptoTransform CreateDecryptor(Byte[] key, Byte[] iv);
    public virtual ICryptoTransform CreateEncryptor(Byte[] key, Byte[] iv);
    public virtual Byte[] get_IV();
    public virtual void set_IV(Byte[] value);
    public virtual Byte[] get_Key();
    public virtual void set_Key(Byte[] value);
    public virtual int get_KeySize();
    public virtual void set_KeySize(int value);
    public virtual int get_FeedbackSize();
    public virtual void set_FeedbackSize(int value);
    public virtual CipherMode get_Mode();
    public virtual void set_Mode(CipherMode value);
    public virtual PaddingMode get_Padding();
    public virtual void set_Padding(PaddingMode value);
    public virtual ICryptoTransform CreateDecryptor();
    public virtual ICryptoTransform CreateEncryptor();
    protected virtual void Dispose(bool disposing);
}
public class System.Security.Cryptography.AesManaged : Aes {
    private RijndaelManaged m_rijndael;
    public int FeedbackSize { get; public set; }
    public Byte[] IV { get; public set; }
    public Byte[] Key { get; public set; }
    public int KeySize { get; public set; }
    public CipherMode Mode { get; public set; }
    public PaddingMode Padding { get; public set; }
    public virtual int get_FeedbackSize();
    public virtual void set_FeedbackSize(int value);
    public virtual Byte[] get_IV();
    public virtual void set_IV(Byte[] value);
    public virtual Byte[] get_Key();
    public virtual void set_Key(Byte[] value);
    public virtual int get_KeySize();
    public virtual void set_KeySize(int value);
    public virtual CipherMode get_Mode();
    public virtual void set_Mode(CipherMode value);
    public virtual PaddingMode get_Padding();
    public virtual void set_Padding(PaddingMode value);
    public virtual ICryptoTransform CreateDecryptor();
    public virtual ICryptoTransform CreateDecryptor(Byte[] key, Byte[] iv);
    public virtual ICryptoTransform CreateEncryptor();
    public virtual ICryptoTransform CreateEncryptor(Byte[] key, Byte[] iv);
    protected virtual void Dispose(bool disposing);
    public virtual void GenerateIV();
    public virtual void GenerateKey();
}
internal class System.Security.Cryptography.AesTransform : SymmetricTransform {
    private UInt32[] expandedKey;
    private static int Nb;
    private int Nk;
    private int Nr;
    private static UInt32[] Rcon;
    private static Byte[] SBox;
    private static Byte[] iSBox;
    private static UInt32[] T0;
    private static UInt32[] T1;
    private static UInt32[] T2;
    private static UInt32[] T3;
    private static UInt32[] iT0;
    private static UInt32[] iT1;
    private static UInt32[] iT2;
    private static UInt32[] iT3;
    public AesTransform(Aes algo, bool encryption, Byte[] key, Byte[] iv);
    private static AesTransform();
    public void Clear();
    protected virtual void ECB(Byte[] input, Byte[] output);
    private UInt32 SubByte(UInt32 a);
    private void Encrypt128(Byte[] indata, Byte[] outdata, UInt32[] ekey);
    private void Decrypt128(Byte[] indata, Byte[] outdata, UInt32[] ekey);
}
internal enum System.Security.Cryptography.AsymmetricPaddingMode : Enum {
    public int value__;
    public static AsymmetricPaddingMode None;
    public static AsymmetricPaddingMode Pkcs1;
    public static AsymmetricPaddingMode Oaep;
    public static AsymmetricPaddingMode Pss;
}
internal static class System.Security.Cryptography.BCryptNative : object {
}
public class System.Security.Cryptography.CngAlgorithm : object {
    private static CngAlgorithm modreq(System.Runtime.CompilerServices.IsVolatile) s_ecdh;
    private static CngAlgorithm modreq(System.Runtime.CompilerServices.IsVolatile) s_ecdhp256;
    private static CngAlgorithm modreq(System.Runtime.CompilerServices.IsVolatile) s_ecdhp384;
    private static CngAlgorithm modreq(System.Runtime.CompilerServices.IsVolatile) s_ecdhp521;
    private static CngAlgorithm modreq(System.Runtime.CompilerServices.IsVolatile) s_ecdsa;
    private static CngAlgorithm modreq(System.Runtime.CompilerServices.IsVolatile) s_ecdsap256;
    private static CngAlgorithm modreq(System.Runtime.CompilerServices.IsVolatile) s_ecdsap384;
    private static CngAlgorithm modreq(System.Runtime.CompilerServices.IsVolatile) s_ecdsap521;
    private static CngAlgorithm modreq(System.Runtime.CompilerServices.IsVolatile) s_md5;
    private static CngAlgorithm modreq(System.Runtime.CompilerServices.IsVolatile) s_sha1;
    private static CngAlgorithm modreq(System.Runtime.CompilerServices.IsVolatile) s_sha256;
    private static CngAlgorithm modreq(System.Runtime.CompilerServices.IsVolatile) s_sha384;
    private static CngAlgorithm modreq(System.Runtime.CompilerServices.IsVolatile) s_sha512;
    private static CngAlgorithm modreq(System.Runtime.CompilerServices.IsVolatile) s_rsa;
    private string m_algorithm;
    public string Algorithm { get; }
    public static CngAlgorithm Rsa { get; }
    public static CngAlgorithm ECDiffieHellman { get; }
    public static CngAlgorithm ECDiffieHellmanP256 { get; }
    public static CngAlgorithm ECDiffieHellmanP384 { get; }
    public static CngAlgorithm ECDiffieHellmanP521 { get; }
    public static CngAlgorithm ECDsa { get; }
    public static CngAlgorithm ECDsaP256 { get; }
    public static CngAlgorithm ECDsaP384 { get; }
    public static CngAlgorithm ECDsaP521 { get; }
    public static CngAlgorithm MD5 { get; }
    public static CngAlgorithm Sha1 { get; }
    public static CngAlgorithm Sha256 { get; }
    public static CngAlgorithm Sha384 { get; }
    public static CngAlgorithm Sha512 { get; }
    public CngAlgorithm(string algorithm);
    public string get_Algorithm();
    public static bool op_Equality(CngAlgorithm left, CngAlgorithm right);
    public static bool op_Inequality(CngAlgorithm left, CngAlgorithm right);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(CngAlgorithm other);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static CngAlgorithm get_Rsa();
    public static CngAlgorithm get_ECDiffieHellman();
    public static CngAlgorithm get_ECDiffieHellmanP256();
    public static CngAlgorithm get_ECDiffieHellmanP384();
    public static CngAlgorithm get_ECDiffieHellmanP521();
    public static CngAlgorithm get_ECDsa();
    public static CngAlgorithm get_ECDsaP256();
    public static CngAlgorithm get_ECDsaP384();
    public static CngAlgorithm get_ECDsaP521();
    public static CngAlgorithm get_MD5();
    public static CngAlgorithm get_Sha1();
    public static CngAlgorithm get_Sha256();
    public static CngAlgorithm get_Sha384();
    public static CngAlgorithm get_Sha512();
}
public class System.Security.Cryptography.CngAlgorithmGroup : object {
    private static CngAlgorithmGroup modreq(System.Runtime.CompilerServices.IsVolatile) s_dh;
    private static CngAlgorithmGroup modreq(System.Runtime.CompilerServices.IsVolatile) s_dsa;
    private static CngAlgorithmGroup modreq(System.Runtime.CompilerServices.IsVolatile) s_ecdh;
    private static CngAlgorithmGroup modreq(System.Runtime.CompilerServices.IsVolatile) s_ecdsa;
    private static CngAlgorithmGroup modreq(System.Runtime.CompilerServices.IsVolatile) s_rsa;
    private string m_algorithmGroup;
    public string AlgorithmGroup { get; }
    public static CngAlgorithmGroup DiffieHellman { get; }
    public static CngAlgorithmGroup Dsa { get; }
    public static CngAlgorithmGroup ECDiffieHellman { get; }
    public static CngAlgorithmGroup ECDsa { get; }
    public static CngAlgorithmGroup Rsa { get; }
    public CngAlgorithmGroup(string algorithmGroup);
    public string get_AlgorithmGroup();
    public static bool op_Equality(CngAlgorithmGroup left, CngAlgorithmGroup right);
    public static bool op_Inequality(CngAlgorithmGroup left, CngAlgorithmGroup right);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(CngAlgorithmGroup other);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static CngAlgorithmGroup get_DiffieHellman();
    public static CngAlgorithmGroup get_Dsa();
    public static CngAlgorithmGroup get_ECDiffieHellman();
    public static CngAlgorithmGroup get_ECDsa();
    public static CngAlgorithmGroup get_Rsa();
}
[FlagsAttribute]
public enum System.Security.Cryptography.CngExportPolicies : Enum {
    public int value__;
    public static CngExportPolicies None;
    public static CngExportPolicies AllowExport;
    public static CngExportPolicies AllowPlaintextExport;
    public static CngExportPolicies AllowArchiving;
    public static CngExportPolicies AllowPlaintextArchiving;
}
public class System.Security.Cryptography.CngKey : object {
    public CngAlgorithmGroup AlgorithmGroup { get; }
    public CngAlgorithm Algorithm { get; }
    public CngExportPolicies ExportPolicy { get; }
    public SafeNCryptKeyHandle Handle { get; }
    public bool IsEphemeral { get; private set; }
    public bool IsMachineKey { get; }
    public string KeyName { get; }
    public int KeySize { get; }
    public CngKeyUsages KeyUsage { get; }
    public IntPtr ParentWindowHandle { get; public set; }
    public CngProvider Provider { get; }
    public SafeNCryptProviderHandle ProviderHandle { get; }
    public string UniqueName { get; }
    public CngUIPolicy UIPolicy { get; }
    [SecuritySafeCriticalAttribute]
public CngAlgorithmGroup get_AlgorithmGroup();
    [SecuritySafeCriticalAttribute]
public CngAlgorithm get_Algorithm();
    [SecuritySafeCriticalAttribute]
public CngExportPolicies get_ExportPolicy();
    [SecurityCriticalAttribute]
public SafeNCryptKeyHandle get_Handle();
    [SecuritySafeCriticalAttribute]
public bool get_IsEphemeral();
    [SecurityCriticalAttribute]
private void set_IsEphemeral(bool value);
    [SecuritySafeCriticalAttribute]
public bool get_IsMachineKey();
    [SecuritySafeCriticalAttribute]
public string get_KeyName();
    [SecuritySafeCriticalAttribute]
public int get_KeySize();
    [SecuritySafeCriticalAttribute]
public CngKeyUsages get_KeyUsage();
    [SecuritySafeCriticalAttribute]
public IntPtr get_ParentWindowHandle();
    [SecuritySafeCriticalAttribute]
public void set_ParentWindowHandle(IntPtr value);
    [SecuritySafeCriticalAttribute]
public CngProvider get_Provider();
    [SecurityCriticalAttribute]
public SafeNCryptProviderHandle get_ProviderHandle();
    [SecuritySafeCriticalAttribute]
public string get_UniqueName();
    [SecuritySafeCriticalAttribute]
public CngUIPolicy get_UIPolicy();
    public static CngKey Create(CngAlgorithm algorithm);
    public static CngKey Create(CngAlgorithm algorithm, string keyName);
    [SecuritySafeCriticalAttribute]
public static CngKey Create(CngAlgorithm algorithm, string keyName, CngKeyCreationParameters creationParameters);
    [SecuritySafeCriticalAttribute]
public void Delete();
    [SecuritySafeCriticalAttribute]
public sealed virtual void Dispose();
    public static bool Exists(string keyName);
    public static bool Exists(string keyName, CngProvider provider);
    [SecuritySafeCriticalAttribute]
public static bool Exists(string keyName, CngProvider provider, CngKeyOpenOptions options);
    public static CngKey Import(Byte[] keyBlob, CngKeyBlobFormat format);
    [SecuritySafeCriticalAttribute]
public static CngKey Import(Byte[] keyBlob, CngKeyBlobFormat format, CngProvider provider);
    [SecuritySafeCriticalAttribute]
public Byte[] Export(CngKeyBlobFormat format);
    [SecuritySafeCriticalAttribute]
public CngProperty GetProperty(string name, CngPropertyOptions options);
    [SecuritySafeCriticalAttribute]
public bool HasProperty(string name, CngPropertyOptions options);
    public static CngKey Open(string keyName);
    public static CngKey Open(string keyName, CngProvider provider);
    [SecuritySafeCriticalAttribute]
public static CngKey Open(string keyName, CngProvider provider, CngKeyOpenOptions openOptions);
    [SecurityCriticalAttribute]
public static CngKey Open(SafeNCryptKeyHandle keyHandle, CngKeyHandleOpenOptions keyHandleOpenOptions);
    [SecuritySafeCriticalAttribute]
public void SetProperty(CngProperty property);
}
public class System.Security.Cryptography.CngKeyBlobFormat : object {
    private static CngKeyBlobFormat modreq(System.Runtime.CompilerServices.IsVolatile) s_eccPrivate;
    private static CngKeyBlobFormat modreq(System.Runtime.CompilerServices.IsVolatile) s_eccPublic;
    private static CngKeyBlobFormat modreq(System.Runtime.CompilerServices.IsVolatile) s_eccFullPrivate;
    private static CngKeyBlobFormat modreq(System.Runtime.CompilerServices.IsVolatile) s_eccFullPublic;
    private static CngKeyBlobFormat modreq(System.Runtime.CompilerServices.IsVolatile) s_genericPrivate;
    private static CngKeyBlobFormat modreq(System.Runtime.CompilerServices.IsVolatile) s_genericPublic;
    private static CngKeyBlobFormat modreq(System.Runtime.CompilerServices.IsVolatile) s_opaqueTransport;
    private static CngKeyBlobFormat modreq(System.Runtime.CompilerServices.IsVolatile) s_pkcs8Private;
    private string m_format;
    public string Format { get; }
    public static CngKeyBlobFormat EccPrivateBlob { get; }
    public static CngKeyBlobFormat EccPublicBlob { get; }
    public static CngKeyBlobFormat EccFullPrivateBlob { get; }
    public static CngKeyBlobFormat EccFullPublicBlob { get; }
    public static CngKeyBlobFormat GenericPrivateBlob { get; }
    public static CngKeyBlobFormat GenericPublicBlob { get; }
    public static CngKeyBlobFormat OpaqueTransportBlob { get; }
    public static CngKeyBlobFormat Pkcs8PrivateBlob { get; }
    public CngKeyBlobFormat(string format);
    public string get_Format();
    public static bool op_Equality(CngKeyBlobFormat left, CngKeyBlobFormat right);
    public static bool op_Inequality(CngKeyBlobFormat left, CngKeyBlobFormat right);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(CngKeyBlobFormat other);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static CngKeyBlobFormat get_EccPrivateBlob();
    public static CngKeyBlobFormat get_EccPublicBlob();
    public static CngKeyBlobFormat get_EccFullPrivateBlob();
    public static CngKeyBlobFormat get_EccFullPublicBlob();
    public static CngKeyBlobFormat get_GenericPrivateBlob();
    public static CngKeyBlobFormat get_GenericPublicBlob();
    public static CngKeyBlobFormat get_OpaqueTransportBlob();
    public static CngKeyBlobFormat get_Pkcs8PrivateBlob();
}
[FlagsAttribute]
public enum System.Security.Cryptography.CngKeyCreationOptions : Enum {
    public int value__;
    public static CngKeyCreationOptions None;
    public static CngKeyCreationOptions MachineKey;
    public static CngKeyCreationOptions OverwriteExistingKey;
}
public class System.Security.Cryptography.CngKeyCreationParameters : object {
    private Nullable`1<CngExportPolicies> m_exportPolicy;
    private CngKeyCreationOptions m_keyCreationOptions;
    private Nullable`1<CngKeyUsages> m_keyUsage;
    private CngPropertyCollection m_parameters;
    private IntPtr m_parentWindowHandle;
    private CngProvider m_provider;
    private CngUIPolicy m_uiPolicy;
    public Nullable`1<CngExportPolicies> ExportPolicy { get; public set; }
    public CngKeyCreationOptions KeyCreationOptions { get; public set; }
    public Nullable`1<CngKeyUsages> KeyUsage { get; public set; }
    public IntPtr ParentWindowHandle { get; public set; }
    public CngPropertyCollection Parameters { get; }
    internal CngPropertyCollection ParametersNoDemand { get; }
    public CngProvider Provider { get; public set; }
    public CngUIPolicy UIPolicy { get; public set; }
    public Nullable`1<CngExportPolicies> get_ExportPolicy();
    public void set_ExportPolicy(Nullable`1<CngExportPolicies> value);
    public CngKeyCreationOptions get_KeyCreationOptions();
    public void set_KeyCreationOptions(CngKeyCreationOptions value);
    public Nullable`1<CngKeyUsages> get_KeyUsage();
    public void set_KeyUsage(Nullable`1<CngKeyUsages> value);
    public IntPtr get_ParentWindowHandle();
    [SecuritySafeCriticalAttribute]
public void set_ParentWindowHandle(IntPtr value);
    [SecuritySafeCriticalAttribute]
public CngPropertyCollection get_Parameters();
    internal CngPropertyCollection get_ParametersNoDemand();
    public CngProvider get_Provider();
    public void set_Provider(CngProvider value);
    public CngUIPolicy get_UIPolicy();
    [SecuritySafeCriticalAttribute]
public void set_UIPolicy(CngUIPolicy value);
}
[FlagsAttribute]
public enum System.Security.Cryptography.CngKeyHandleOpenOptions : Enum {
    public int value__;
    public static CngKeyHandleOpenOptions None;
    public static CngKeyHandleOpenOptions EphemeralKey;
}
[FlagsAttribute]
public enum System.Security.Cryptography.CngKeyOpenOptions : Enum {
    public int value__;
    public static CngKeyOpenOptions None;
    public static CngKeyOpenOptions UserKey;
    public static CngKeyOpenOptions MachineKey;
    public static CngKeyOpenOptions Silent;
}
[FlagsAttribute]
internal enum System.Security.Cryptography.CngKeyTypes : Enum {
    public int value__;
    public static CngKeyTypes None;
    public static CngKeyTypes MachineKey;
}
[FlagsAttribute]
public enum System.Security.Cryptography.CngKeyUsages : Enum {
    public int value__;
    public static CngKeyUsages None;
    public static CngKeyUsages Decryption;
    public static CngKeyUsages Signing;
    public static CngKeyUsages KeyAgreement;
    public static CngKeyUsages AllUsages;
}
public class System.Security.Cryptography.CngProperty : ValueType {
    private string m_name;
    private CngPropertyOptions m_propertyOptions;
    private Byte[] m_value;
    private Nullable`1<int> m_hashCode;
    public string Name { get; }
    public CngPropertyOptions Options { get; }
    internal Byte[] Value { get; }
    public CngProperty(string name, Byte[] value, CngPropertyOptions options);
    public string get_Name();
    public CngPropertyOptions get_Options();
    internal Byte[] get_Value();
    public Byte[] GetValue();
    public static bool op_Equality(CngProperty left, CngProperty right);
    public static bool op_Inequality(CngProperty left, CngProperty right);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(CngProperty other);
    public virtual int GetHashCode();
}
public class System.Security.Cryptography.CngPropertyCollection : Collection`1<CngProperty> {
}
[FlagsAttribute]
public enum System.Security.Cryptography.CngPropertyOptions : Enum {
    public int value__;
    public static CngPropertyOptions None;
    public static CngPropertyOptions CustomProperty;
    public static CngPropertyOptions Persist;
}
public class System.Security.Cryptography.CngProvider : object {
    private static CngProvider modreq(System.Runtime.CompilerServices.IsVolatile) s_msSmartCardKsp;
    private static CngProvider modreq(System.Runtime.CompilerServices.IsVolatile) s_msSoftwareKsp;
    private string m_provider;
    public string Provider { get; }
    public static CngProvider MicrosoftSmartCardKeyStorageProvider { get; }
    public static CngProvider MicrosoftSoftwareKeyStorageProvider { get; }
    public CngProvider(string provider);
    public string get_Provider();
    public static bool op_Equality(CngProvider left, CngProvider right);
    public static bool op_Inequality(CngProvider left, CngProvider right);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(CngProvider other);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static CngProvider get_MicrosoftSmartCardKeyStorageProvider();
    public static CngProvider get_MicrosoftSoftwareKeyStorageProvider();
}
public class System.Security.Cryptography.CngUIPolicy : object {
    private string m_creationTitle;
    private string m_description;
    private string m_friendlyName;
    private CngUIProtectionLevels m_protectionLevel;
    private string m_useContext;
    public string CreationTitle { get; }
    public string Description { get; }
    public string FriendlyName { get; }
    public CngUIProtectionLevels ProtectionLevel { get; }
    public string UseContext { get; }
    public CngUIPolicy(CngUIProtectionLevels protectionLevel);
    public CngUIPolicy(CngUIProtectionLevels protectionLevel, string friendlyName);
    public CngUIPolicy(CngUIProtectionLevels protectionLevel, string friendlyName, string description);
    public CngUIPolicy(CngUIProtectionLevels protectionLevel, string friendlyName, string description, string useContext);
    public CngUIPolicy(CngUIProtectionLevels protectionLevel, string friendlyName, string description, string useContext, string creationTitle);
    public string get_CreationTitle();
    public string get_Description();
    public string get_FriendlyName();
    public CngUIProtectionLevels get_ProtectionLevel();
    public string get_UseContext();
}
[FlagsAttribute]
public enum System.Security.Cryptography.CngUIProtectionLevels : Enum {
    public int value__;
    public static CngUIProtectionLevels None;
    public static CngUIProtectionLevels ProtectKey;
    public static CngUIProtectionLevels ForceHighProtection;
}
public class System.Security.Cryptography.DSACng : DSA {
    public CngKey Key { get; }
    public DSACng(int keySize);
    [SecuritySafeCriticalAttribute]
public DSACng(CngKey key);
    [SecuritySafeCriticalAttribute]
public CngKey get_Key();
    [SecuritySafeCriticalAttribute]
public virtual Byte[] CreateSignature(Byte[] rgbHash);
    public virtual DSAParameters ExportParameters(bool includePrivateParameters);
    public virtual void ImportParameters(DSAParameters parameters);
    [SecuritySafeCriticalAttribute]
public virtual bool VerifySignature(Byte[] rgbHash, Byte[] rgbSignature);
}
internal enum System.Security.Cryptography.DSAFIPSVERSION_ENUM : Enum {
    public int value__;
    public static DSAFIPSVERSION_ENUM DSA_FIPS186_2;
    public static DSAFIPSVERSION_ENUM DSA_FIPS186_3;
}
[DebuggerDisplayAttribute("ECCurve: {Oid}")]
public class System.Security.Cryptography.ECCurve : ValueType {
    public Byte[] A;
    public Byte[] B;
    public ECPoint G;
    public Byte[] Order;
    public Byte[] Cofactor;
    public Byte[] Seed;
    public ECCurveType CurveType;
    public Nullable`1<HashAlgorithmName> Hash;
    public Byte[] Polynomial;
    public Byte[] Prime;
    private Oid _oid;
    public Oid Oid { get; private set; }
    public bool IsPrime { get; }
    public bool IsCharacteristic2 { get; }
    public bool IsExplicit { get; }
    public bool IsNamed { get; }
    public Oid get_Oid();
    private void set_Oid(Oid value);
    private static ECCurve Create(Oid oid);
    public static ECCurve CreateFromOid(Oid curveOid);
    public static ECCurve CreateFromFriendlyName(string oidFriendlyName);
    public static ECCurve CreateFromValue(string oidValue);
    private static ECCurve CreateFromValueAndName(string oidValue, string oidFriendlyName);
    public bool get_IsPrime();
    public bool get_IsCharacteristic2();
    public bool get_IsExplicit();
    public bool get_IsNamed();
    public void Validate();
    private bool HasAnyExplicitParameters();
}
public abstract class System.Security.Cryptography.ECDiffieHellman : AsymmetricAlgorithm {
    public string KeyExchangeAlgorithm { get; }
    public string SignatureAlgorithm { get; }
    public ECDiffieHellmanPublicKey PublicKey { get; }
    public virtual string get_KeyExchangeAlgorithm();
    public virtual string get_SignatureAlgorithm();
    public static ECDiffieHellman Create();
    public static ECDiffieHellman Create(string algorithm);
    public static ECDiffieHellman Create(ECCurve curve);
    public static ECDiffieHellman Create(ECParameters parameters);
    public abstract virtual ECDiffieHellmanPublicKey get_PublicKey();
    public virtual Byte[] DeriveKeyMaterial(ECDiffieHellmanPublicKey otherPartyPublicKey);
    public Byte[] DeriveKeyFromHash(ECDiffieHellmanPublicKey otherPartyPublicKey, HashAlgorithmName hashAlgorithm);
    public virtual Byte[] DeriveKeyFromHash(ECDiffieHellmanPublicKey otherPartyPublicKey, HashAlgorithmName hashAlgorithm, Byte[] secretPrepend, Byte[] secretAppend);
    public Byte[] DeriveKeyFromHmac(ECDiffieHellmanPublicKey otherPartyPublicKey, HashAlgorithmName hashAlgorithm, Byte[] hmacKey);
    public virtual Byte[] DeriveKeyFromHmac(ECDiffieHellmanPublicKey otherPartyPublicKey, HashAlgorithmName hashAlgorithm, Byte[] hmacKey, Byte[] secretPrepend, Byte[] secretAppend);
    public virtual Byte[] DeriveKeyTls(ECDiffieHellmanPublicKey otherPartyPublicKey, Byte[] prfLabel, Byte[] prfSeed);
    private static Exception DerivedClassMustOverride();
    public virtual ECParameters ExportParameters(bool includePrivateParameters);
    public virtual ECParameters ExportExplicitParameters(bool includePrivateParameters);
    public virtual void ImportParameters(ECParameters parameters);
    public virtual void GenerateKey(ECCurve curve);
    public virtual Byte[] ExportECPrivateKey();
    public virtual bool TryExportECPrivateKey(Span`1<byte> destination, Int32& bytesWritten);
    public virtual void ImportECPrivateKey(ReadOnlySpan`1<byte> source, Int32& bytesRead);
}
public class System.Security.Cryptography.ECDiffieHellmanCng : ECDiffieHellman {
    public CngAlgorithm HashAlgorithm { get; public set; }
    public Byte[] HmacKey { get; public set; }
    public CngKey Key { get; }
    public ECDiffieHellmanKeyDerivationFunction KeyDerivationFunction { get; public set; }
    public Byte[] Label { get; public set; }
    public ECDiffieHellmanPublicKey PublicKey { get; }
    public Byte[] SecretAppend { get; public set; }
    public Byte[] SecretPrepend { get; public set; }
    public Byte[] Seed { get; public set; }
    public bool UseSecretAgreementAsHmacKey { get; }
    public ECDiffieHellmanCng(int keySize);
    [SecuritySafeCriticalAttribute]
public ECDiffieHellmanCng(CngKey key);
    public ECDiffieHellmanCng(ECCurve curve);
    public CngAlgorithm get_HashAlgorithm();
    public void set_HashAlgorithm(CngAlgorithm value);
    public Byte[] get_HmacKey();
    public void set_HmacKey(Byte[] value);
    public CngKey get_Key();
    public ECDiffieHellmanKeyDerivationFunction get_KeyDerivationFunction();
    public void set_KeyDerivationFunction(ECDiffieHellmanKeyDerivationFunction value);
    public Byte[] get_Label();
    public void set_Label(Byte[] value);
    public virtual ECDiffieHellmanPublicKey get_PublicKey();
    public Byte[] get_SecretAppend();
    public void set_SecretAppend(Byte[] value);
    public Byte[] get_SecretPrepend();
    public void set_SecretPrepend(Byte[] value);
    public Byte[] get_Seed();
    public void set_Seed(Byte[] value);
    public bool get_UseSecretAgreementAsHmacKey();
    [SecuritySafeCriticalAttribute]
public Byte[] DeriveKeyMaterial(CngKey otherPartyPublicKey);
    [SecurityCriticalAttribute]
public SafeNCryptSecretHandle DeriveSecretAgreementHandle(CngKey otherPartyPublicKey);
    public SafeNCryptSecretHandle DeriveSecretAgreementHandle(ECDiffieHellmanPublicKey otherPartyPublicKey);
    public void FromXmlString(string xml, ECKeyXmlFormat format);
    public string ToXmlString(ECKeyXmlFormat format);
}
public class System.Security.Cryptography.ECDiffieHellmanCngPublicKey : ECDiffieHellmanPublicKey {
    public CngKeyBlobFormat BlobFormat { get; }
    public CngKeyBlobFormat get_BlobFormat();
    [SecuritySafeCriticalAttribute]
public static ECDiffieHellmanPublicKey FromByteArray(Byte[] publicKeyBlob, CngKeyBlobFormat format);
    [SecuritySafeCriticalAttribute]
public static ECDiffieHellmanCngPublicKey FromXmlString(string xml);
    public CngKey Import();
}
public enum System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction : Enum {
    public int value__;
    public static ECDiffieHellmanKeyDerivationFunction Hash;
    public static ECDiffieHellmanKeyDerivationFunction Hmac;
    public static ECDiffieHellmanKeyDerivationFunction Tls;
}
public abstract class System.Security.Cryptography.ECDiffieHellmanPublicKey : object {
    private Byte[] m_keyBlob;
    protected ECDiffieHellmanPublicKey(Byte[] keyBlob);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public virtual Byte[] ToByteArray();
    public virtual string ToXmlString();
    public virtual ECParameters ExportParameters();
    public virtual ECParameters ExportExplicitParameters();
}
public abstract class System.Security.Cryptography.ECDsa : AsymmetricAlgorithm {
    public string KeyExchangeAlgorithm { get; }
    public string SignatureAlgorithm { get; }
    public virtual string get_KeyExchangeAlgorithm();
    public virtual string get_SignatureAlgorithm();
    public static ECDsa Create();
    public static ECDsa Create(string algorithm);
    public static ECDsa Create(ECCurve curve);
    public static ECDsa Create(ECParameters parameters);
    public abstract virtual Byte[] SignHash(Byte[] hash);
    public abstract virtual bool VerifyHash(Byte[] hash, Byte[] signature);
    protected virtual Byte[] HashData(Byte[] data, int offset, int count, HashAlgorithmName hashAlgorithm);
    protected virtual Byte[] HashData(Stream data, HashAlgorithmName hashAlgorithm);
    public virtual Byte[] SignData(Byte[] data, HashAlgorithmName hashAlgorithm);
    public virtual Byte[] SignData(Byte[] data, int offset, int count, HashAlgorithmName hashAlgorithm);
    public virtual Byte[] SignData(Stream data, HashAlgorithmName hashAlgorithm);
    public bool VerifyData(Byte[] data, Byte[] signature, HashAlgorithmName hashAlgorithm);
    public virtual bool VerifyData(Byte[] data, int offset, int count, Byte[] signature, HashAlgorithmName hashAlgorithm);
    public bool VerifyData(Stream data, Byte[] signature, HashAlgorithmName hashAlgorithm);
    public virtual ECParameters ExportParameters(bool includePrivateParameters);
    public virtual ECParameters ExportExplicitParameters(bool includePrivateParameters);
    public virtual void ImportParameters(ECParameters parameters);
    public virtual void GenerateKey(ECCurve curve);
    private static Exception DerivedClassMustOverride();
    internal static Exception HashAlgorithmNameNullOrEmpty();
    protected virtual bool TryHashData(ReadOnlySpan`1<byte> data, Span`1<byte> destination, HashAlgorithmName hashAlgorithm, Int32& bytesWritten);
    public virtual bool TrySignHash(ReadOnlySpan`1<byte> hash, Span`1<byte> destination, Int32& bytesWritten);
    public virtual bool VerifyHash(ReadOnlySpan`1<byte> hash, ReadOnlySpan`1<byte> signature);
    public virtual bool TrySignData(ReadOnlySpan`1<byte> data, Span`1<byte> destination, HashAlgorithmName hashAlgorithm, Int32& bytesWritten);
    public virtual bool VerifyData(ReadOnlySpan`1<byte> data, ReadOnlySpan`1<byte> signature, HashAlgorithmName hashAlgorithm);
    public virtual Byte[] ExportECPrivateKey();
    public virtual bool TryExportECPrivateKey(Span`1<byte> destination, Int32& bytesWritten);
    public virtual void ImportECPrivateKey(ReadOnlySpan`1<byte> source, Int32& bytesRead);
}
public class System.Security.Cryptography.ECDsaCng : ECDsa {
    [CompilerGeneratedAttribute]
private CngAlgorithm <HashAlgorithm>k__BackingField;
    public CngAlgorithm HashAlgorithm { get; public set; }
    public CngKey Key { get; private set; }
    public ECDsaCng(int keySize);
    [SecuritySafeCriticalAttribute]
public ECDsaCng(CngKey key);
    public ECDsaCng(ECCurve curve);
    [CompilerGeneratedAttribute]
public CngAlgorithm get_HashAlgorithm();
    [CompilerGeneratedAttribute]
public void set_HashAlgorithm(CngAlgorithm value);
    public CngKey get_Key();
    private void set_Key(CngKey value);
    public virtual Byte[] SignHash(Byte[] hash);
    public virtual bool VerifyHash(Byte[] hash, Byte[] signature);
    public void FromXmlString(string xml, ECKeyXmlFormat format);
    public Byte[] SignData(Byte[] data);
    public Byte[] SignData(Stream data);
    public Byte[] SignData(Byte[] data, int offset, int count);
    public string ToXmlString(ECKeyXmlFormat format);
    public bool VerifyData(Byte[] data, Byte[] signature);
    public bool VerifyData(Stream data, Byte[] signature);
    public bool VerifyData(Byte[] data, int offset, int count, Byte[] signature);
}
public enum System.Security.Cryptography.ECKeyXmlFormat : Enum {
    public int value__;
    public static ECKeyXmlFormat Rfc4050;
}
public class System.Security.Cryptography.ECParameters : ValueType {
    public ECPoint Q;
    public Byte[] D;
    public ECCurve Curve;
    public void Validate();
}
public class System.Security.Cryptography.ECPoint : ValueType {
    public Byte[] X;
    public Byte[] Y;
}
internal enum System.Security.Cryptography.HASHALGORITHM_ENUM : Enum {
    public int value__;
    public static HASHALGORITHM_ENUM DSA_HASH_ALGORITHM_SHA1;
    public static HASHALGORITHM_ENUM DSA_HASH_ALGORITHM_SHA256;
    public static HASHALGORITHM_ENUM DSA_HASH_ALGORITHM_SHA512;
}
public class System.Security.Cryptography.IncrementalHash : object {
    private static int NTE_BAD_ALGID;
    private HashAlgorithmName _algorithmName;
    private HashAlgorithm _hash;
    private bool _disposed;
    private bool _resetPending;
    public HashAlgorithmName AlgorithmName { get; }
    private IncrementalHash(HashAlgorithmName name, HashAlgorithm hash);
    public HashAlgorithmName get_AlgorithmName();
    public void AppendData(Byte[] data);
    public void AppendData(Byte[] data, int offset, int count);
    public Byte[] GetHashAndReset();
    public sealed virtual void Dispose();
    public static IncrementalHash CreateHash(HashAlgorithmName hashAlgorithm);
    public static IncrementalHash CreateHMAC(HashAlgorithmName hashAlgorithm, Byte[] key);
    private static HashAlgorithm GetHashAlgorithm(HashAlgorithmName hashAlgorithm);
    private static HashAlgorithm GetHMAC(HashAlgorithmName hashAlgorithm, Byte[] key);
    public void AppendData(ReadOnlySpan`1<byte> data);
    public bool TryGetHashAndReset(Span`1<byte> destination, Int32& bytesWritten);
}
public class System.Security.Cryptography.ManifestSignatureInformation : object {
    public AuthenticodeSignatureInformation AuthenticodeSignature { get; }
    public ManifestKinds Manifest { get; }
    public StrongNameSignatureInformation StrongNameSignature { get; }
    public AuthenticodeSignatureInformation get_AuthenticodeSignature();
    public ManifestKinds get_Manifest();
    public StrongNameSignatureInformation get_StrongNameSignature();
    public static ManifestSignatureInformationCollection VerifySignature(ActivationContext application);
    public static ManifestSignatureInformationCollection VerifySignature(ActivationContext application, ManifestKinds manifests);
    [SecuritySafeCriticalAttribute]
public static ManifestSignatureInformationCollection VerifySignature(ActivationContext application, ManifestKinds manifests, X509RevocationFlag revocationFlag, X509RevocationMode revocationMode);
}
public class System.Security.Cryptography.ManifestSignatureInformationCollection : ReadOnlyCollection`1<ManifestSignatureInformation> {
}
public class System.Security.Cryptography.MD5Cng : MD5 {
    private static Byte[] Empty;
    private MD5 hash;
    private static MD5Cng();
    [SecurityCriticalAttribute]
public virtual void Initialize();
    [SecurityCriticalAttribute]
protected virtual void HashCore(Byte[] array, int ibStart, int cbSize);
    [SecurityCriticalAttribute]
protected virtual Byte[] HashFinal();
    [SecurityCriticalAttribute]
protected virtual void Dispose(bool disposing);
}
public class System.Security.Cryptography.RSACng : RSA {
    public CngKey Key { get; private set; }
    public RSACng(int keySize);
    public RSACng(CngKey key);
    [SecuritySafeCriticalAttribute]
public CngKey get_Key();
    private void set_Key(CngKey value);
    public virtual RSAParameters ExportParameters(bool includePrivateParameters);
    public virtual void ImportParameters(RSAParameters parameters);
}
public class System.Security.Cryptography.SHA1Cng : SHA1 {
    private static Byte[] Empty;
    private SHA1 hash;
    private static SHA1Cng();
    [SecurityCriticalAttribute]
public virtual void Initialize();
    [SecurityCriticalAttribute]
protected virtual void HashCore(Byte[] array, int ibStart, int cbSize);
    [SecurityCriticalAttribute]
protected virtual Byte[] HashFinal();
    [SecurityCriticalAttribute]
protected virtual void Dispose(bool disposing);
}
public class System.Security.Cryptography.SHA256Cng : SHA256 {
    private static Byte[] Empty;
    private SHA256 hash;
    private static SHA256Cng();
    [SecurityCriticalAttribute]
public virtual void Initialize();
    [SecurityCriticalAttribute]
protected virtual void HashCore(Byte[] array, int ibStart, int cbSize);
    [SecurityCriticalAttribute]
protected virtual Byte[] HashFinal();
    [SecurityCriticalAttribute]
protected virtual void Dispose(bool disposing);
}
public class System.Security.Cryptography.SHA256CryptoServiceProvider : SHA256 {
    private static Byte[] Empty;
    private SHA256 hash;
    private static SHA256CryptoServiceProvider();
    [SecurityCriticalAttribute]
public virtual void Initialize();
    [SecurityCriticalAttribute]
protected virtual void HashCore(Byte[] array, int ibStart, int cbSize);
    [SecurityCriticalAttribute]
protected virtual Byte[] HashFinal();
    [SecurityCriticalAttribute]
protected virtual void Dispose(bool disposing);
}
public class System.Security.Cryptography.SHA384Cng : SHA384 {
    private static Byte[] Empty;
    private SHA384 hash;
    private static SHA384Cng();
    [SecurityCriticalAttribute]
public virtual void Initialize();
    [SecurityCriticalAttribute]
protected virtual void HashCore(Byte[] array, int ibStart, int cbSize);
    [SecurityCriticalAttribute]
protected virtual Byte[] HashFinal();
    [SecurityCriticalAttribute]
protected virtual void Dispose(bool disposing);
}
public class System.Security.Cryptography.SHA384CryptoServiceProvider : SHA384 {
    private static Byte[] Empty;
    private SHA384 hash;
    private static SHA384CryptoServiceProvider();
    [SecurityCriticalAttribute]
public virtual void Initialize();
    [SecurityCriticalAttribute]
protected virtual void HashCore(Byte[] array, int ibStart, int cbSize);
    [SecurityCriticalAttribute]
protected virtual Byte[] HashFinal();
    [SecurityCriticalAttribute]
protected virtual void Dispose(bool disposing);
}
public class System.Security.Cryptography.SHA512Cng : SHA512 {
    private static Byte[] Empty;
    private SHA512 hash;
    private static SHA512Cng();
    [SecurityCriticalAttribute]
public virtual void Initialize();
    [SecurityCriticalAttribute]
protected virtual void HashCore(Byte[] array, int ibStart, int cbSize);
    [SecurityCriticalAttribute]
protected virtual Byte[] HashFinal();
    [SecurityCriticalAttribute]
protected virtual void Dispose(bool disposing);
}
public class System.Security.Cryptography.SHA512CryptoServiceProvider : SHA512 {
    private static Byte[] Empty;
    private SHA512 hash;
    private static SHA512CryptoServiceProvider();
    [SecurityCriticalAttribute]
public virtual void Initialize();
    [SecurityCriticalAttribute]
protected virtual void HashCore(Byte[] array, int ibStart, int cbSize);
    [SecurityCriticalAttribute]
protected virtual Byte[] HashFinal();
    [SecurityCriticalAttribute]
protected virtual void Dispose(bool disposing);
}
public enum System.Security.Cryptography.SignatureVerificationResult : Enum {
    public int value__;
    public static SignatureVerificationResult AssemblyIdentityMismatch;
    public static SignatureVerificationResult BadDigest;
    public static SignatureVerificationResult BadSignatureFormat;
    public static SignatureVerificationResult BasicConstraintsNotObserved;
    public static SignatureVerificationResult CertificateExpired;
    public static SignatureVerificationResult CertificateExplicitlyDistrusted;
    public static SignatureVerificationResult CertificateMalformed;
    public static SignatureVerificationResult CertificateNotExplicitlyTrusted;
    public static SignatureVerificationResult CertificateRevoked;
    public static SignatureVerificationResult CertificateUsageNotAllowed;
    public static SignatureVerificationResult ContainingSignatureInvalid;
    public static SignatureVerificationResult CouldNotBuildChain;
    public static SignatureVerificationResult GenericTrustFailure;
    public static SignatureVerificationResult InvalidCertificateName;
    public static SignatureVerificationResult InvalidCertificatePolicy;
    public static SignatureVerificationResult InvalidCertificateRole;
    public static SignatureVerificationResult InvalidCertificateSignature;
    public static SignatureVerificationResult InvalidCertificateUsage;
    public static SignatureVerificationResult InvalidCountersignature;
    public static SignatureVerificationResult InvalidSignerCertificate;
    public static SignatureVerificationResult InvalidTimePeriodNesting;
    public static SignatureVerificationResult InvalidTimestamp;
    public static SignatureVerificationResult IssuerChainingError;
    public static SignatureVerificationResult MissingSignature;
    public static SignatureVerificationResult PathLengthConstraintViolated;
    public static SignatureVerificationResult PublicKeyTokenMismatch;
    public static SignatureVerificationResult PublisherMismatch;
    public static SignatureVerificationResult RevocationCheckFailure;
    public static SignatureVerificationResult SystemError;
    public static SignatureVerificationResult UnknownCriticalExtension;
    public static SignatureVerificationResult UnknownTrustProvider;
    public static SignatureVerificationResult UnknownVerificationAction;
    public static SignatureVerificationResult UntrustedCertificationAuthority;
    public static SignatureVerificationResult UntrustedRootCertificate;
    public static SignatureVerificationResult UntrustedTestRootCertificate;
    public static SignatureVerificationResult Valid;
}
public class System.Security.Cryptography.StrongNameSignatureInformation : object {
    public string HashAlgorithm { get; }
    public int HResult { get; }
    public bool IsValid { get; }
    public AsymmetricAlgorithm PublicKey { get; }
    public SignatureVerificationResult VerificationResult { get; }
    public string get_HashAlgorithm();
    public int get_HResult();
    public bool get_IsValid();
    public AsymmetricAlgorithm get_PublicKey();
    public SignatureVerificationResult get_VerificationResult();
}
public class System.Security.Cryptography.TripleDESCng : TripleDES {
    public Byte[] Key { get; public set; }
    public int KeySize { get; public set; }
    public TripleDESCng(string keyName);
    public TripleDESCng(string keyName, CngProvider provider);
    public TripleDESCng(string keyName, CngProvider provider, CngKeyOpenOptions openOptions);
    public virtual Byte[] get_Key();
    public virtual void set_Key(Byte[] value);
    public virtual int get_KeySize();
    public virtual void set_KeySize(int value);
    public virtual ICryptoTransform CreateDecryptor();
    public virtual ICryptoTransform CreateDecryptor(Byte[] rgbKey, Byte[] rgbIV);
    public virtual ICryptoTransform CreateEncryptor();
    public virtual ICryptoTransform CreateEncryptor(Byte[] rgbKey, Byte[] rgbIV);
    protected virtual void Dispose(bool disposing);
    public virtual void GenerateIV();
    public virtual void GenerateKey();
}
public class System.Security.Cryptography.X509Certificates.AuthenticodeSignatureInformation : object {
    public string Description { get; }
    public Uri DescriptionUrl { get; }
    public string HashAlgorithm { get; }
    public int HResult { get; }
    public X509Chain SignatureChain { get; }
    public X509Certificate2 SigningCertificate { get; }
    public TimestampInformation Timestamp { get; }
    public TrustStatus TrustStatus { get; }
    public SignatureVerificationResult VerificationResult { get; }
    public string get_Description();
    public Uri get_DescriptionUrl();
    public string get_HashAlgorithm();
    public int get_HResult();
    [SecuritySafeCriticalAttribute]
public X509Chain get_SignatureChain();
    [SecuritySafeCriticalAttribute]
public X509Certificate2 get_SigningCertificate();
    public TimestampInformation get_Timestamp();
    public TrustStatus get_TrustStatus();
    public SignatureVerificationResult get_VerificationResult();
}
[ExtensionAttribute]
public static class System.Security.Cryptography.X509Certificates.DSACertificateExtensions : object {
    [ExtensionAttribute]
public static DSA GetDSAPublicKey(X509Certificate2 certificate);
    [ExtensionAttribute]
public static DSA GetDSAPrivateKey(X509Certificate2 certificate);
    [ExtensionAttribute]
[MonoTODOAttribute]
public static X509Certificate2 CopyWithPrivateKey(X509Certificate2 certificate, DSA privateKey);
}
[ExtensionAttribute]
public static class System.Security.Cryptography.X509Certificates.ECDsaCertificateExtensions : object {
    [MonoTODOAttribute]
[ExtensionAttribute]
public static ECDsa GetECDsaPrivateKey(X509Certificate2 certificate);
    [MonoTODOAttribute]
[ExtensionAttribute]
public static ECDsa GetECDsaPublicKey(X509Certificate2 certificate);
    [MonoTODOAttribute]
[ExtensionAttribute]
public static X509Certificate2 CopyWithPrivateKey(X509Certificate2 certificate, ECDsa privateKey);
}
[ExtensionAttribute]
public static class System.Security.Cryptography.X509Certificates.RSACertificateExtensions : object {
    [ExtensionAttribute]
public static RSA GetRSAPrivateKey(X509Certificate2 certificate);
    [ExtensionAttribute]
public static RSA GetRSAPublicKey(X509Certificate2 certificate);
    [ExtensionAttribute]
public static X509Certificate2 CopyWithPrivateKey(X509Certificate2 certificate, RSA privateKey);
}
public class System.Security.Cryptography.X509Certificates.TimestampInformation : object {
    public string HashAlgorithm { get; }
    public int HResult { get; }
    public bool IsValid { get; }
    public X509Chain SignatureChain { get; }
    public X509Certificate2 SigningCertificate { get; }
    public DateTime Timestamp { get; }
    public SignatureVerificationResult VerificationResult { get; }
    public string get_HashAlgorithm();
    public int get_HResult();
    public bool get_IsValid();
    [SecuritySafeCriticalAttribute]
public X509Chain get_SignatureChain();
    [SecuritySafeCriticalAttribute]
public X509Certificate2 get_SigningCertificate();
    public DateTime get_Timestamp();
    public SignatureVerificationResult get_VerificationResult();
}
public enum System.Security.Cryptography.X509Certificates.TrustStatus : Enum {
    public int value__;
    public static TrustStatus Untrusted;
    public static TrustStatus UnknownIdentity;
    public static TrustStatus KnownIdentity;
    public static TrustStatus Trusted;
}
[FlagsAttribute]
public enum System.Security.ManifestKinds : Enum {
    public int value__;
    public static ManifestKinds Application;
    public static ManifestKinds ApplicationAndDeployment;
    public static ManifestKinds Deployment;
    public static ManifestKinds None;
}
public enum System.Threading.LockRecursionPolicy : Enum {
    public int value__;
    public static LockRecursionPolicy NoRecursion;
    public static LockRecursionPolicy SupportsRecursion;
}
internal class System.Threading.ReaderWriterCount : object {
    public long lockID;
    public int readercount;
    public int writercount;
    public int upgradecount;
    public ReaderWriterCount next;
}
public class System.Threading.ReaderWriterLockSlim : object {
    private bool fIsReentrant;
    private int myLock;
    private static int LockSpinCycles;
    private static int LockSpinCount;
    private static int LockSleep0Count;
    private UInt32 numWriteWaiters;
    private UInt32 numReadWaiters;
    private UInt32 numWriteUpgradeWaiters;
    private UInt32 numUpgradeWaiters;
    private bool fNoWaiters;
    private int upgradeLockOwnerId;
    private int writeLockOwnerId;
    private EventWaitHandle writeEvent;
    private EventWaitHandle readEvent;
    private EventWaitHandle upgradeEvent;
    private EventWaitHandle waitUpgradeEvent;
    private static long s_nextLockID;
    private long lockID;
    [ThreadStaticAttribute]
private static ReaderWriterCount t_rwc;
    private bool fUpgradeThreadHoldingRead;
    private static int MaxSpinCount;
    private UInt32 owners;
    private static UInt32 WRITER_HELD;
    private static UInt32 WAITING_WRITERS;
    private static UInt32 WAITING_UPGRADER;
    private static UInt32 MAX_READER;
    private static UInt32 READER_MASK;
    private bool fDisposed;
    public bool IsReadLockHeld { get; }
    public bool IsUpgradeableReadLockHeld { get; }
    public bool IsWriteLockHeld { get; }
    public LockRecursionPolicy RecursionPolicy { get; }
    public int CurrentReadCount { get; }
    public int RecursiveReadCount { get; }
    public int RecursiveUpgradeCount { get; }
    public int RecursiveWriteCount { get; }
    public int WaitingReadCount { get; }
    public int WaitingUpgradeCount { get; }
    public int WaitingWriteCount { get; }
    public ReaderWriterLockSlim(LockRecursionPolicy recursionPolicy);
    private void InitializeThreadCounts();
    private static bool IsRWEntryEmpty(ReaderWriterCount rwc);
    private bool IsRwHashEntryChanged(ReaderWriterCount lrwc);
    private ReaderWriterCount GetThreadRWCount(bool dontAllocate);
    public void EnterReadLock();
    public bool TryEnterReadLock(TimeSpan timeout);
    public bool TryEnterReadLock(int millisecondsTimeout);
    private bool TryEnterReadLock(TimeoutTracker timeout);
    private bool TryEnterReadLockCore(TimeoutTracker timeout);
    public void EnterWriteLock();
    public bool TryEnterWriteLock(TimeSpan timeout);
    public bool TryEnterWriteLock(int millisecondsTimeout);
    private bool TryEnterWriteLock(TimeoutTracker timeout);
    private bool TryEnterWriteLockCore(TimeoutTracker timeout);
    public void EnterUpgradeableReadLock();
    public bool TryEnterUpgradeableReadLock(TimeSpan timeout);
    public bool TryEnterUpgradeableReadLock(int millisecondsTimeout);
    private bool TryEnterUpgradeableReadLock(TimeoutTracker timeout);
    private bool TryEnterUpgradeableReadLockCore(TimeoutTracker timeout);
    public void ExitReadLock();
    public void ExitWriteLock();
    public void ExitUpgradeableReadLock();
    private void LazyCreateEvent(EventWaitHandle& waitEvent, bool makeAutoResetEvent);
    private bool WaitOnEvent(EventWaitHandle waitEvent, UInt32& numWaiters, TimeoutTracker timeout, bool isWriteWaiter);
    private void ExitAndWakeUpAppropriateWaiters();
    private void ExitAndWakeUpAppropriateWaitersPreferringWriters();
    private void ExitAndWakeUpAppropriateReadWaiters();
    private bool IsWriterAcquired();
    private void SetWriterAcquired();
    private void ClearWriterAcquired();
    private void SetWritersWaiting();
    private void ClearWritersWaiting();
    private void SetUpgraderWaiting();
    private void ClearUpgraderWaiting();
    private UInt32 GetNumReaders();
    private void EnterMyLock();
    private void EnterMyLockSpin();
    private void ExitMyLock();
    private static void SpinWait(int SpinCount);
    public sealed virtual void Dispose();
    private void Dispose(bool disposing);
    public bool get_IsReadLockHeld();
    public bool get_IsUpgradeableReadLockHeld();
    public bool get_IsWriteLockHeld();
    public LockRecursionPolicy get_RecursionPolicy();
    public int get_CurrentReadCount();
    public int get_RecursiveReadCount();
    public int get_RecursiveUpgradeCount();
    public int get_RecursiveWriteCount();
    public int get_WaitingReadCount();
    public int get_WaitingUpgradeCount();
    public int get_WaitingWriteCount();
}
[ExtensionAttribute]
public static class System.Threading.Tasks.TaskExtensions : object {
    [ExtensionAttribute]
public static Task Unwrap(Task`1<Task> task);
    [ExtensionAttribute]
public static Task`1<TResult> Unwrap(Task`1<Task`1<TResult>> task);
}
internal class Unity.ThrowStub : ObjectDisposedException {
    public static void ThrowNotSupportedException();
}
