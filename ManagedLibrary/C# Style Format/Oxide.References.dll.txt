internal Consts : object {
public string MonoVersion
public string MonoCompany
public string MonoProduct
public string MonoCopyright
public string FxVersion
public string VsVersion
public string FxFileVersion
public string VsFileVersion
public string AssemblyI18N
public string AssemblyMicrosoft_VisualStudio
public string AssemblyMicrosoft_VisualStudio_Web
public string AssemblyMicrosoft_VSDesigner
public string AssemblyMono_Http
public string AssemblyMono_Posix
public string AssemblyMono_Security
public string AssemblyMono_Messaging_RabbitMQ
public string AssemblyCorlib
public string AssemblySystem
public string AssemblySystem_Data
public string AssemblySystem_Design
public string AssemblySystem_DirectoryServices
public string AssemblySystem_Drawing
public string AssemblySystem_Drawing_Design
public string AssemblySystem_Messaging
public string AssemblySystem_Security
public string AssemblySystem_ServiceProcess
public string AssemblySystem_Web
public string AssemblySystem_Windows_Forms
public string AssemblySystem_Core
}
internal Locale : object {
public string GetText(string msg)
public string GetText(string fmt, Object[] args)
}
internal MapAttribute : Attribute {
private string nativeType
private string suppressFlags
public string NativeType
public string SuppressFlags
public void .ctor(string nativeType)
public string get_NativeType()
public string get_SuppressFlags()
public void set_SuppressFlags(string value)
}
public Mono.Cecil.ArrayDimension : ValueType {
private Nullable`1<int> lower_bound
private Nullable`1<int> upper_bound
public Nullable`1<int> LowerBound
public Nullable`1<int> UpperBound
public bool IsSized
public Nullable`1<int> get_LowerBound()
public void set_LowerBound(Nullable`1<int> value)
public Nullable`1<int> get_UpperBound()
public void set_UpperBound(Nullable`1<int> value)
public bool get_IsSized()
public void .ctor(Nullable`1<int> lowerBound, Nullable`1<int> upperBound)
public string ToString()
}
public Mono.Cecil.ArrayMarshalInfo : MarshalInfo {
internal NativeType element_type
internal int size_parameter_index
internal int size
internal int size_parameter_multiplier
public NativeType ElementType
public int SizeParameterIndex
public int Size
public int SizeParameterMultiplier
public NativeType get_ElementType()
public void set_ElementType(NativeType value)
public int get_SizeParameterIndex()
public void set_SizeParameterIndex(int value)
public int get_Size()
public void set_Size(int value)
public int get_SizeParameterMultiplier()
public void set_SizeParameterMultiplier(int value)
}
public Mono.Cecil.ArrayType : TypeSpecification {
private Collection`1<ArrayDimension> dimensions
public Collection`1<ArrayDimension> Dimensions
public int Rank
public bool IsVector
public bool IsValueType
public string Name
public string FullName
private string Suffix
public bool IsArray
public Collection`1<ArrayDimension> get_Dimensions()
public int get_Rank()
public bool get_IsVector()
public bool get_IsValueType()
public void set_IsValueType(bool value)
public string get_Name()
public string get_FullName()
private string get_Suffix()
public bool get_IsArray()
public void .ctor(TypeReference type)
public void .ctor(TypeReference type, int rank)
}
public Mono.Cecil.AssemblyAttributes : Enum {
public UInt32 value__
public AssemblyAttributes PublicKey
public AssemblyAttributes SideBySideCompatible
public AssemblyAttributes Retargetable
public AssemblyAttributes WindowsRuntime
public AssemblyAttributes DisableJITCompileOptimizer
public AssemblyAttributes EnableJITCompileTracking
}
public Mono.Cecil.AssemblyDefinition : object {
private AssemblyNameDefinition name
internal ModuleDefinition main_module
private Collection`1<ModuleDefinition> modules
private Collection`1<CustomAttribute> custom_attributes
private Collection`1<SecurityDeclaration> security_declarations
public AssemblyNameDefinition Name
public string FullName
public MetadataToken MetadataToken
public Collection`1<ModuleDefinition> Modules
public ModuleDefinition MainModule
public MethodDefinition EntryPoint
public bool HasCustomAttributes
public Collection`1<CustomAttribute> CustomAttributes
public bool HasSecurityDeclarations
public Collection`1<SecurityDeclaration> SecurityDeclarations
public AssemblyNameDefinition get_Name()
public void set_Name(AssemblyNameDefinition value)
public string get_FullName()
public MetadataToken get_MetadataToken()
public void set_MetadataToken(MetadataToken value)
public Collection`1<ModuleDefinition> get_Modules()
public ModuleDefinition get_MainModule()
public MethodDefinition get_EntryPoint()
public void set_EntryPoint(MethodDefinition value)
public bool get_HasCustomAttributes()
public Collection`1<CustomAttribute> get_CustomAttributes()
public bool get_HasSecurityDeclarations()
public Collection`1<SecurityDeclaration> get_SecurityDeclarations()
public AssemblyDefinition CreateAssembly(AssemblyNameDefinition assemblyName, string moduleName, ModuleKind kind)
public AssemblyDefinition CreateAssembly(AssemblyNameDefinition assemblyName, string moduleName, ModuleParameters parameters)
public AssemblyDefinition ReadAssembly(string fileName)
public AssemblyDefinition ReadAssembly(string fileName, ReaderParameters parameters)
public AssemblyDefinition ReadAssembly(Stream stream)
public AssemblyDefinition ReadAssembly(Stream stream, ReaderParameters parameters)
private AssemblyDefinition ReadAssembly(ModuleDefinition module)
public void Write(string fileName)
public void Write(Stream stream)
public void Write(string fileName, WriterParameters parameters)
public void Write(Stream stream, WriterParameters parameters)
public string ToString()
}
public Mono.Cecil.AssemblyHashAlgorithm : Enum {
public UInt32 value__
public AssemblyHashAlgorithm None
public AssemblyHashAlgorithm Reserved
public AssemblyHashAlgorithm SHA1
}
public Mono.Cecil.AssemblyLinkedResource : Resource {
private AssemblyNameReference reference
public AssemblyNameReference Assembly
public ResourceType ResourceType
public AssemblyNameReference get_Assembly()
public void set_Assembly(AssemblyNameReference value)
public ResourceType get_ResourceType()
public void .ctor(string name, ManifestResourceAttributes flags)
public void .ctor(string name, ManifestResourceAttributes flags, AssemblyNameReference reference)
}
public Mono.Cecil.AssemblyNameDefinition : AssemblyNameReference {
public Byte[] Hash
public Byte[] get_Hash()
public void .ctor(string name, Version version)
}
public Mono.Cecil.AssemblyNameReference : object {
private string name
private string culture
private Version version
private UInt32 attributes
private Byte[] public_key
private Byte[] public_key_token
private AssemblyHashAlgorithm hash_algorithm
private Byte[] hash
internal MetadataToken token
private string full_name
public string Name
public string Culture
public Version Version
public AssemblyAttributes Attributes
public bool HasPublicKey
public bool IsSideBySideCompatible
public bool IsRetargetable
public bool IsWindowsRuntime
public Byte[] PublicKey
public Byte[] PublicKeyToken
public MetadataScopeType MetadataScopeType
public string FullName
public AssemblyHashAlgorithm HashAlgorithm
public Byte[] Hash
public MetadataToken MetadataToken
public string get_Name()
public void set_Name(string value)
public string get_Culture()
public void set_Culture(string value)
public Version get_Version()
public void set_Version(Version value)
public AssemblyAttributes get_Attributes()
public void set_Attributes(AssemblyAttributes value)
public bool get_HasPublicKey()
public void set_HasPublicKey(bool value)
public bool get_IsSideBySideCompatible()
public void set_IsSideBySideCompatible(bool value)
public bool get_IsRetargetable()
public void set_IsRetargetable(bool value)
public bool get_IsWindowsRuntime()
public void set_IsWindowsRuntime(bool value)
public Byte[] get_PublicKey()
public void set_PublicKey(Byte[] value)
public Byte[] get_PublicKeyToken()
public void set_PublicKeyToken(Byte[] value)
private Byte[] HashPublicKey()
public MetadataScopeType get_MetadataScopeType()
public string get_FullName()
public AssemblyNameReference Parse(string fullName)
public AssemblyHashAlgorithm get_HashAlgorithm()
public void set_HashAlgorithm(AssemblyHashAlgorithm value)
public Byte[] get_Hash()
public void set_Hash(Byte[] value)
public MetadataToken get_MetadataToken()
public void set_MetadataToken(MetadataToken value)
public void .ctor(string name, Version version)
public string ToString()
}
internal Mono.Cecil.AssemblyRefTable : MetadataTable`1<Row`9<ushort, ushort, ushort, ushort, AssemblyAttributes, UInt32, UInt32, UInt32, UInt32>> {
public void Write(TableHeapBuffer buffer)
}
public Mono.Cecil.AssemblyResolutionException : FileNotFoundException {
private AssemblyNameReference reference
public AssemblyNameReference AssemblyReference
public AssemblyNameReference get_AssemblyReference()
public void .ctor(AssemblyNameReference reference)
protected void .ctor(SerializationInfo info, StreamingContext context)
}
public Mono.Cecil.AssemblyResolveEventArgs : EventArgs {
private AssemblyNameReference reference
public AssemblyNameReference AssemblyReference
public AssemblyNameReference get_AssemblyReference()
public void .ctor(AssemblyNameReference reference)
}
public Mono.Cecil.AssemblyResolveEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public AssemblyDefinition Invoke(object sender, AssemblyNameReference reference)
public IAsyncResult BeginInvoke(object sender, AssemblyNameReference reference, AsyncCallback callback, object object)
public AssemblyDefinition EndInvoke(IAsyncResult result)
}
internal Mono.Cecil.AssemblyTable : OneRowTable`1<Row`9<AssemblyHashAlgorithm, ushort, ushort, ushort, ushort, AssemblyAttributes, UInt32, UInt32, UInt32>> {
public void Write(TableHeapBuffer buffer)
}
public Mono.Cecil.BaseAssemblyResolver : object {
private bool on_mono
private Collection`1<string> directories
private Collection`1<string> gac_paths
private AssemblyResolveEventHandler ResolveFailure
public void AddSearchDirectory(string directory)
public void RemoveSearchDirectory(string directory)
public String[] GetSearchDirectories()
public AssemblyDefinition Resolve(string fullName)
public AssemblyDefinition Resolve(string fullName, ReaderParameters parameters)
public void add_ResolveFailure(AssemblyResolveEventHandler value)
public void remove_ResolveFailure(AssemblyResolveEventHandler value)
private AssemblyDefinition GetAssembly(string file, ReaderParameters parameters)
public AssemblyDefinition Resolve(AssemblyNameReference name)
public AssemblyDefinition Resolve(AssemblyNameReference name, ReaderParameters parameters)
private AssemblyDefinition SearchDirectory(AssemblyNameReference name, IEnumerable`1<string> directories, ReaderParameters parameters)
private bool IsZero(Version version)
private AssemblyDefinition GetCorlib(AssemblyNameReference reference, ReaderParameters parameters)
private Collection`1<string> GetGacPaths()
private Collection`1<string> GetDefaultMonoGacPaths()
private string GetCurrentMonoGac()
private AssemblyDefinition GetAssemblyInGac(AssemblyNameReference reference, ReaderParameters parameters)
private AssemblyDefinition GetAssemblyInMonoGac(AssemblyNameReference reference, ReaderParameters parameters)
private AssemblyDefinition GetAssemblyInNetGac(AssemblyNameReference reference, ReaderParameters parameters)
private string GetAssemblyFile(AssemblyNameReference reference, string prefix, string gac)
}
public Mono.Cecil.ByReferenceType : TypeSpecification {
public string Name
public string FullName
public bool IsValueType
public bool IsByReference
public string get_Name()
public string get_FullName()
public bool get_IsValueType()
public void set_IsValueType(bool value)
public bool get_IsByReference()
public void .ctor(TypeReference type)
}
public Mono.Cecil.CallSite : object {
private MethodReference signature
public bool HasThis
public bool ExplicitThis
public MethodCallingConvention CallingConvention
public bool HasParameters
public Collection`1<ParameterDefinition> Parameters
public TypeReference ReturnType
public MethodReturnType MethodReturnType
public string Name
public string Namespace
public ModuleDefinition Module
public IMetadataScope Scope
public MetadataToken MetadataToken
public string FullName
public bool get_HasThis()
public void set_HasThis(bool value)
public bool get_ExplicitThis()
public void set_ExplicitThis(bool value)
public MethodCallingConvention get_CallingConvention()
public void set_CallingConvention(MethodCallingConvention value)
public bool get_HasParameters()
public Collection`1<ParameterDefinition> get_Parameters()
public TypeReference get_ReturnType()
public void set_ReturnType(TypeReference value)
public MethodReturnType get_MethodReturnType()
public string get_Name()
public void set_Name(string value)
public string get_Namespace()
public void set_Namespace(string value)
public ModuleDefinition get_Module()
public IMetadataScope get_Scope()
public MetadataToken get_MetadataToken()
public void set_MetadataToken(MetadataToken value)
public string get_FullName()
public void .ctor(TypeReference returnType)
public string ToString()
}
public Mono.Cecil.Cil.Code : Enum {
public int value__
public Code Nop
public Code Break
public Code Ldarg_0
public Code Ldarg_1
public Code Ldarg_2
public Code Ldarg_3
public Code Ldloc_0
public Code Ldloc_1
public Code Ldloc_2
public Code Ldloc_3
public Code Stloc_0
public Code Stloc_1
public Code Stloc_2
public Code Stloc_3
public Code Ldarg_S
public Code Ldarga_S
public Code Starg_S
public Code Ldloc_S
public Code Ldloca_S
public Code Stloc_S
public Code Ldnull
public Code Ldc_I4_M1
public Code Ldc_I4_0
public Code Ldc_I4_1
public Code Ldc_I4_2
public Code Ldc_I4_3
public Code Ldc_I4_4
public Code Ldc_I4_5
public Code Ldc_I4_6
public Code Ldc_I4_7
public Code Ldc_I4_8
public Code Ldc_I4_S
public Code Ldc_I4
public Code Ldc_I8
public Code Ldc_R4
public Code Ldc_R8
public Code Dup
public Code Pop
public Code Jmp
public Code Call
public Code Calli
public Code Ret
public Code Br_S
public Code Brfalse_S
public Code Brtrue_S
public Code Beq_S
public Code Bge_S
public Code Bgt_S
public Code Ble_S
public Code Blt_S
public Code Bne_Un_S
public Code Bge_Un_S
public Code Bgt_Un_S
public Code Ble_Un_S
public Code Blt_Un_S
public Code Br
public Code Brfalse
public Code Brtrue
public Code Beq
public Code Bge
public Code Bgt
public Code Ble
public Code Blt
public Code Bne_Un
public Code Bge_Un
public Code Bgt_Un
public Code Ble_Un
public Code Blt_Un
public Code Switch
public Code Ldind_I1
public Code Ldind_U1
public Code Ldind_I2
public Code Ldind_U2
public Code Ldind_I4
public Code Ldind_U4
public Code Ldind_I8
public Code Ldind_I
public Code Ldind_R4
public Code Ldind_R8
public Code Ldind_Ref
public Code Stind_Ref
public Code Stind_I1
public Code Stind_I2
public Code Stind_I4
public Code Stind_I8
public Code Stind_R4
public Code Stind_R8
public Code Add
public Code Sub
public Code Mul
public Code Div
public Code Div_Un
public Code Rem
public Code Rem_Un
public Code And
public Code Or
public Code Xor
public Code Shl
public Code Shr
public Code Shr_Un
public Code Neg
public Code Not
public Code Conv_I1
public Code Conv_I2
public Code Conv_I4
public Code Conv_I8
public Code Conv_R4
public Code Conv_R8
public Code Conv_U4
public Code Conv_U8
public Code Callvirt
public Code Cpobj
public Code Ldobj
public Code Ldstr
public Code Newobj
public Code Castclass
public Code Isinst
public Code Conv_R_Un
public Code Unbox
public Code Throw
public Code Ldfld
public Code Ldflda
public Code Stfld
public Code Ldsfld
public Code Ldsflda
public Code Stsfld
public Code Stobj
public Code Conv_Ovf_I1_Un
public Code Conv_Ovf_I2_Un
public Code Conv_Ovf_I4_Un
public Code Conv_Ovf_I8_Un
public Code Conv_Ovf_U1_Un
public Code Conv_Ovf_U2_Un
public Code Conv_Ovf_U4_Un
public Code Conv_Ovf_U8_Un
public Code Conv_Ovf_I_Un
public Code Conv_Ovf_U_Un
public Code Box
public Code Newarr
public Code Ldlen
public Code Ldelema
public Code Ldelem_I1
public Code Ldelem_U1
public Code Ldelem_I2
public Code Ldelem_U2
public Code Ldelem_I4
public Code Ldelem_U4
public Code Ldelem_I8
public Code Ldelem_I
public Code Ldelem_R4
public Code Ldelem_R8
public Code Ldelem_Ref
public Code Stelem_I
public Code Stelem_I1
public Code Stelem_I2
public Code Stelem_I4
public Code Stelem_I8
public Code Stelem_R4
public Code Stelem_R8
public Code Stelem_Ref
public Code Ldelem_Any
public Code Stelem_Any
public Code Unbox_Any
public Code Conv_Ovf_I1
public Code Conv_Ovf_U1
public Code Conv_Ovf_I2
public Code Conv_Ovf_U2
public Code Conv_Ovf_I4
public Code Conv_Ovf_U4
public Code Conv_Ovf_I8
public Code Conv_Ovf_U8
public Code Refanyval
public Code Ckfinite
public Code Mkrefany
public Code Ldtoken
public Code Conv_U2
public Code Conv_U1
public Code Conv_I
public Code Conv_Ovf_I
public Code Conv_Ovf_U
public Code Add_Ovf
public Code Add_Ovf_Un
public Code Mul_Ovf
public Code Mul_Ovf_Un
public Code Sub_Ovf
public Code Sub_Ovf_Un
public Code Endfinally
public Code Leave
public Code Leave_S
public Code Stind_I
public Code Conv_U
public Code Arglist
public Code Ceq
public Code Cgt
public Code Cgt_Un
public Code Clt
public Code Clt_Un
public Code Ldftn
public Code Ldvirtftn
public Code Ldarg
public Code Ldarga
public Code Starg
public Code Ldloc
public Code Ldloca
public Code Stloc
public Code Localloc
public Code Endfilter
public Code Unaligned
public Code Volatile
public Code Tail
public Code Initobj
public Code Constrained
public Code Cpblk
public Code Initblk
public Code No
public Code Rethrow
public Code Sizeof
public Code Refanytype
public Code Readonly
}
internal Mono.Cecil.Cil.CodeReader : ByteBuffer {
internal MetadataReader reader
private int start
private Section code_section
private MethodDefinition method
private MethodBody body
private int Offset
private int get_Offset()
public void .ctor(Section section, MetadataReader reader)
public MethodBody ReadMethodBody(MethodDefinition method)
public void MoveTo(int rva)
private bool IsInSection(int rva)
private void ReadMethodBody()
private void ReadFatMethod()
public VariableDefinitionCollection ReadVariables(MetadataToken local_var_token)
private void ReadCode()
private OpCode ReadOpCode()
private object ReadOperand(Instruction instruction)
public string GetString(MetadataToken token)
public ParameterDefinition GetParameter(int index)
public VariableDefinition GetVariable(int index)
public CallSite GetCallSite(MetadataToken token)
private void ResolveBranches(Collection`1<Instruction> instructions)
private Instruction GetInstruction(int offset)
private Instruction GetInstruction(Collection`1<Instruction> instructions, int offset)
private void ReadSection()
private void ReadSmallSection()
private void ReadFatSection()
private void ReadExceptionHandlers(int count, Func`1<int> read_entry, Func`1<int> read_length)
private void ReadExceptionHandlerSpecific(ExceptionHandler handler)
private void Align(int align)
public MetadataToken ReadToken()
public ByteBuffer PatchRawMethodBody(MethodDefinition method, CodeWriter writer, MethodSymbols& symbols)
private void PatchRawFatMethod(ByteBuffer buffer, MethodSymbols symbols, CodeWriter writer, MetadataToken& local_var_token)
private MetadataToken GetOriginalToken(MetadataBuilder metadata, MethodDefinition method)
private void PatchRawCode(ByteBuffer buffer, int code_size, CodeWriter writer)
private void PatchRawSection(ByteBuffer buffer, MetadataBuilder metadata)
private void PatchRawSmallSection(ByteBuffer buffer, MetadataBuilder metadata)
private void PatchRawFatSection(ByteBuffer buffer, MetadataBuilder metadata)
private void PatchRawExceptionHandlers(ByteBuffer buffer, MetadataBuilder metadata, int count, bool fat_entry)
private int <ReadSmallSection>b__25_0()
private int <ReadSmallSection>b__25_1()
}
internal Mono.Cecil.Cil.CodeWriter : ByteBuffer {
private UInt32 code_base
internal MetadataBuilder metadata
private Dictionary`2<UInt32, MetadataToken> standalone_signatures
private UInt32 current
private MethodBody body
public void .ctor(MetadataBuilder metadata)
public UInt32 WriteMethodBody(MethodDefinition method)
private bool IsEmptyMethodBody(MethodBody body)
private bool IsUnresolved(MethodDefinition method)
private void WriteUnresolvedMethodBody(MethodDefinition method)
private MetadataToken GetLocalVarToken(ByteBuffer buffer, MethodSymbols symbols)
private void WriteResolvedMethodBody(MethodDefinition method)
private void WriteFatHeader()
private void WriteInstructions()
private void WriteOpCode(OpCode opcode)
private void WriteOperand(Instruction instruction)
private int GetTargetOffset(Instruction instruction)
private UInt32 GetUserStringIndex(string string)
private int GetVariableIndex(VariableDefinition variable)
private int GetParameterIndex(ParameterDefinition parameter)
private bool RequiresFatHeader()
private void ComputeHeader()
private void ComputeExceptionHandlerStackSize(Dictionary`2& stack_sizes)
private void AddExceptionStackSize(Instruction handler_start, Dictionary`2& stack_sizes)
private void ComputeStackSize(Instruction instruction, Dictionary`2& stack_sizes, Int32& stack_size, Int32& max_stack)
private void CopyBranchStackSize(Instruction instruction, Dictionary`2& stack_sizes, int stack_size)
private void CopyBranchStackSize(Dictionary`2& stack_sizes, Instruction target, int stack_size)
private void ComputeStackSize(Instruction instruction, Int32& stack_size)
private void ComputeStackDelta(Instruction instruction, Int32& stack_size)
private void ComputePopDelta(StackBehaviour pop_behavior, Int32& stack_size)
private void ComputePushDelta(StackBehaviour push_behaviour, Int32& stack_size)
private void WriteExceptionHandlers()
private bool RequiresFatSection(Collection`1<ExceptionHandler> handlers)
private bool IsFatRange(Instruction start, Instruction end)
private void WriteSmallSection(Collection`1<ExceptionHandler> handlers)
private void WriteFatSection(Collection`1<ExceptionHandler> handlers)
private void WriteExceptionHandlers(Collection`1<ExceptionHandler> handlers, Action`1<int> write_entry, Action`1<int> write_length)
private void WriteExceptionHandlerSpecific(ExceptionHandler handler)
public MetadataToken GetStandAloneSignature(Collection`1<VariableDefinition> variables)
public MetadataToken GetStandAloneSignature(CallSite call_site)
private MetadataToken GetStandAloneSignatureToken(UInt32 signature)
private UInt32 BeginMethod()
private void WriteMetadataToken(MetadataToken token)
private void Align(int align)
private void EndMethod()
private void <WriteSmallSection>b__34_0(int i)
private void <WriteSmallSection>b__34_1(int i)
}
public Mono.Cecil.Cil.Document : object {
private string url
private byte type
private byte hash_algorithm
private byte language
private byte language_vendor
private Byte[] hash
public string Url
public DocumentType Type
public DocumentHashAlgorithm HashAlgorithm
public DocumentLanguage Language
public DocumentLanguageVendor LanguageVendor
public Byte[] Hash
public string get_Url()
public void set_Url(string value)
public DocumentType get_Type()
public void set_Type(DocumentType value)
public DocumentHashAlgorithm get_HashAlgorithm()
public void set_HashAlgorithm(DocumentHashAlgorithm value)
public DocumentLanguage get_Language()
public void set_Language(DocumentLanguage value)
public DocumentLanguageVendor get_LanguageVendor()
public void set_LanguageVendor(DocumentLanguageVendor value)
public Byte[] get_Hash()
public void set_Hash(Byte[] value)
public void .ctor(string url)
}
public Mono.Cecil.Cil.DocumentHashAlgorithm : Enum {
public int value__
public DocumentHashAlgorithm None
public DocumentHashAlgorithm MD5
public DocumentHashAlgorithm SHA1
}
public Mono.Cecil.Cil.DocumentLanguage : Enum {
public int value__
public DocumentLanguage Other
public DocumentLanguage C
public DocumentLanguage Cpp
public DocumentLanguage CSharp
public DocumentLanguage Basic
public DocumentLanguage Java
public DocumentLanguage Cobol
public DocumentLanguage Pascal
public DocumentLanguage Cil
public DocumentLanguage JScript
public DocumentLanguage Smc
public DocumentLanguage MCpp
public DocumentLanguage FSharp
}
public Mono.Cecil.Cil.DocumentLanguageVendor : Enum {
public int value__
public DocumentLanguageVendor Other
public DocumentLanguageVendor Microsoft
}
public Mono.Cecil.Cil.DocumentType : Enum {
public int value__
public DocumentType Other
public DocumentType Text
}
public Mono.Cecil.Cil.ExceptionHandler : object {
private Instruction try_start
private Instruction try_end
private Instruction filter_start
private Instruction handler_start
private Instruction handler_end
private TypeReference catch_type
private ExceptionHandlerType handler_type
public Instruction TryStart
public Instruction TryEnd
public Instruction FilterStart
public Instruction HandlerStart
public Instruction HandlerEnd
public TypeReference CatchType
public ExceptionHandlerType HandlerType
public Instruction get_TryStart()
public void set_TryStart(Instruction value)
public Instruction get_TryEnd()
public void set_TryEnd(Instruction value)
public Instruction get_FilterStart()
public void set_FilterStart(Instruction value)
public Instruction get_HandlerStart()
public void set_HandlerStart(Instruction value)
public Instruction get_HandlerEnd()
public void set_HandlerEnd(Instruction value)
public TypeReference get_CatchType()
public void set_CatchType(TypeReference value)
public ExceptionHandlerType get_HandlerType()
public void set_HandlerType(ExceptionHandlerType value)
public void .ctor(ExceptionHandlerType handlerType)
}
public Mono.Cecil.Cil.ExceptionHandlerType : Enum {
public int value__
public ExceptionHandlerType Catch
public ExceptionHandlerType Filter
public ExceptionHandlerType Finally
public ExceptionHandlerType Fault
}
public Mono.Cecil.Cil.FlowControl : Enum {
public int value__
public FlowControl Branch
public FlowControl Break
public FlowControl Call
public FlowControl Cond_Branch
public FlowControl Meta
public FlowControl Next
public FlowControl Phi
public FlowControl Return
public FlowControl Throw
}
public Mono.Cecil.Cil.ILProcessor : object {
private MethodBody body
private Collection`1<Instruction> instructions
public MethodBody Body
public MethodBody get_Body()
internal void .ctor(MethodBody body)
public Instruction Create(OpCode opcode)
public Instruction Create(OpCode opcode, TypeReference type)
public Instruction Create(OpCode opcode, CallSite site)
public Instruction Create(OpCode opcode, MethodReference method)
public Instruction Create(OpCode opcode, FieldReference field)
public Instruction Create(OpCode opcode, string value)
public Instruction Create(OpCode opcode, sbyte value)
public Instruction Create(OpCode opcode, byte value)
public Instruction Create(OpCode opcode, int value)
public Instruction Create(OpCode opcode, long value)
public Instruction Create(OpCode opcode, float value)
public Instruction Create(OpCode opcode, double value)
public Instruction Create(OpCode opcode, Instruction target)
public Instruction Create(OpCode opcode, Instruction[] targets)
public Instruction Create(OpCode opcode, VariableDefinition variable)
public Instruction Create(OpCode opcode, ParameterDefinition parameter)
public void Emit(OpCode opcode)
public void Emit(OpCode opcode, TypeReference type)
public void Emit(OpCode opcode, MethodReference method)
public void Emit(OpCode opcode, CallSite site)
public void Emit(OpCode opcode, FieldReference field)
public void Emit(OpCode opcode, string value)
public void Emit(OpCode opcode, byte value)
public void Emit(OpCode opcode, sbyte value)
public void Emit(OpCode opcode, int value)
public void Emit(OpCode opcode, long value)
public void Emit(OpCode opcode, float value)
public void Emit(OpCode opcode, double value)
public void Emit(OpCode opcode, Instruction target)
public void Emit(OpCode opcode, Instruction[] targets)
public void Emit(OpCode opcode, VariableDefinition variable)
public void Emit(OpCode opcode, ParameterDefinition parameter)
public void InsertBefore(Instruction target, Instruction instruction)
public void InsertAfter(Instruction target, Instruction instruction)
public void Append(Instruction instruction)
public void Replace(Instruction target, Instruction instruction)
public void Remove(Instruction instruction)
}
public Mono.Cecil.Cil.ImageDebugDirectory : ValueType {
public int Characteristics
public int TimeDateStamp
public short MajorVersion
public short MinorVersion
public int Type
public int SizeOfData
public int AddressOfRawData
public int PointerToRawData
}
public Mono.Cecil.Cil.Instruction : object {
internal int offset
internal OpCode opcode
internal object operand
internal Instruction previous
internal Instruction next
private SequencePoint sequence_point
public int Offset
public OpCode OpCode
public object Operand
public Instruction Previous
public Instruction Next
public SequencePoint SequencePoint
public int get_Offset()
public void set_Offset(int value)
public OpCode get_OpCode()
public void set_OpCode(OpCode value)
public object get_Operand()
public void set_Operand(object value)
public Instruction get_Previous()
public void set_Previous(Instruction value)
public Instruction get_Next()
public void set_Next(Instruction value)
public SequencePoint get_SequencePoint()
public void set_SequencePoint(SequencePoint value)
internal void .ctor(int offset, OpCode opCode)
internal void .ctor(OpCode opcode, object operand)
public int GetSize()
public string ToString()
private void AppendLabel(StringBuilder builder, Instruction instruction)
public Instruction Create(OpCode opcode)
public Instruction Create(OpCode opcode, TypeReference type)
public Instruction Create(OpCode opcode, CallSite site)
public Instruction Create(OpCode opcode, MethodReference method)
public Instruction Create(OpCode opcode, FieldReference field)
public Instruction Create(OpCode opcode, string value)
public Instruction Create(OpCode opcode, sbyte value)
public Instruction Create(OpCode opcode, byte value)
public Instruction Create(OpCode opcode, int value)
public Instruction Create(OpCode opcode, long value)
public Instruction Create(OpCode opcode, float value)
public Instruction Create(OpCode opcode, double value)
public Instruction Create(OpCode opcode, Instruction target)
public Instruction Create(OpCode opcode, Instruction[] targets)
public Instruction Create(OpCode opcode, VariableDefinition variable)
public Instruction Create(OpCode opcode, ParameterDefinition parameter)
}
internal Mono.Cecil.Cil.InstructionCollection : Collection`1<Instruction> {
internal void .ctor(int capacity)
protected void OnAdd(Instruction item, int index)
protected void OnInsert(Instruction item, int index)
protected void OnSet(Instruction item, int index)
protected void OnRemove(Instruction item, int index)
}
public Mono.Cecil.Cil.InstructionMapper : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public Instruction Invoke(int offset)
public IAsyncResult BeginInvoke(int offset, AsyncCallback callback, object object)
public Instruction EndInvoke(IAsyncResult result)
}
public Mono.Cecil.Cil.InstructionSymbol : ValueType {
public int Offset
public SequencePoint SequencePoint
public void .ctor(int offset, SequencePoint sequencePoint)
}
public Mono.Cecil.Cil.ISymbolReader {
public bool ProcessDebugHeader(ImageDebugDirectory directory, Byte[] header)
public void Read(MethodBody body, InstructionMapper mapper)
public void Read(MethodSymbols symbols)
}
public Mono.Cecil.Cil.ISymbolReaderProvider {
public ISymbolReader GetSymbolReader(ModuleDefinition module, string fileName)
public ISymbolReader GetSymbolReader(ModuleDefinition module, Stream symbolStream)
}
public Mono.Cecil.Cil.ISymbolWriter {
public bool GetDebugHeader(ImageDebugDirectory& directory, Byte[]& header)
public void Write(MethodBody body)
public void Write(MethodSymbols symbols)
}
public Mono.Cecil.Cil.ISymbolWriterProvider {
public ISymbolWriter GetSymbolWriter(ModuleDefinition module, string fileName)
public ISymbolWriter GetSymbolWriter(ModuleDefinition module, Stream symbolStream)
}
public Mono.Cecil.Cil.IVariableDefinitionProvider {
public bool HasVariables
public Collection`1<VariableDefinition> Variables
public bool get_HasVariables()
public Collection`1<VariableDefinition> get_Variables()
}
public Mono.Cecil.Cil.MethodBody : object {
internal MethodDefinition method
internal ParameterDefinition this_parameter
internal int max_stack_size
internal int code_size
internal bool init_locals
internal MetadataToken local_var_token
internal Collection`1<Instruction> instructions
internal Collection`1<ExceptionHandler> exceptions
internal Collection`1<VariableDefinition> variables
private Scope scope
public MethodDefinition Method
public int MaxStackSize
public int CodeSize
public bool InitLocals
public MetadataToken LocalVarToken
public Collection`1<Instruction> Instructions
public bool HasExceptionHandlers
public Collection`1<ExceptionHandler> ExceptionHandlers
public bool HasVariables
public Collection`1<VariableDefinition> Variables
public Scope Scope
public ParameterDefinition ThisParameter
public MethodDefinition get_Method()
public int get_MaxStackSize()
public void set_MaxStackSize(int value)
public int get_CodeSize()
public bool get_InitLocals()
public void set_InitLocals(bool value)
public MetadataToken get_LocalVarToken()
public void set_LocalVarToken(MetadataToken value)
public Collection`1<Instruction> get_Instructions()
public bool get_HasExceptionHandlers()
public Collection`1<ExceptionHandler> get_ExceptionHandlers()
public bool get_HasVariables()
public Collection`1<VariableDefinition> get_Variables()
public Scope get_Scope()
public void set_Scope(Scope value)
public ParameterDefinition get_ThisParameter()
private ParameterDefinition CreateThisParameter(MethodDefinition method)
public void .ctor(MethodDefinition method)
public ILProcessor GetILProcessor()
}
public Mono.Cecil.Cil.MethodSymbols : object {
internal int code_size
internal string method_name
internal MetadataToken method_token
internal MetadataToken local_var_token
internal Collection`1<VariableDefinition> variables
internal Collection`1<InstructionSymbol> instructions
public bool HasVariables
public Collection`1<VariableDefinition> Variables
public Collection`1<InstructionSymbol> Instructions
public int CodeSize
public string MethodName
public MetadataToken MethodToken
public MetadataToken LocalVarToken
public bool get_HasVariables()
public Collection`1<VariableDefinition> get_Variables()
public Collection`1<InstructionSymbol> get_Instructions()
public int get_CodeSize()
public string get_MethodName()
public MetadataToken get_MethodToken()
public MetadataToken get_LocalVarToken()
internal void .ctor(string methodName)
public void .ctor(MetadataToken methodToken)
}
public Mono.Cecil.Cil.OpCode : ValueType {
private byte op1
private byte op2
private byte code
private byte flow_control
private byte opcode_type
private byte operand_type
private byte stack_behavior_pop
private byte stack_behavior_push
public string Name
public int Size
public byte Op1
public byte Op2
public short Value
public Code Code
public FlowControl FlowControl
public OpCodeType OpCodeType
public OperandType OperandType
public StackBehaviour StackBehaviourPop
public StackBehaviour StackBehaviourPush
public string get_Name()
public int get_Size()
public byte get_Op1()
public byte get_Op2()
public short get_Value()
public Code get_Code()
public FlowControl get_FlowControl()
public OpCodeType get_OpCodeType()
public OperandType get_OperandType()
public StackBehaviour get_StackBehaviourPop()
public StackBehaviour get_StackBehaviourPush()
internal void .ctor(int x, int y)
public int GetHashCode()
public bool Equals(object obj)
public bool Equals(OpCode opcode)
public bool op_Equality(OpCode one, OpCode other)
public bool op_Inequality(OpCode one, OpCode other)
public string ToString()
}
internal Mono.Cecil.Cil.OpCodeNames : object {
internal String[] names
}
public Mono.Cecil.Cil.OpCodes : object {
internal OpCode[] OneByteOpCode
internal OpCode[] TwoBytesOpCode
public OpCode Nop
public OpCode Break
public OpCode Ldarg_0
public OpCode Ldarg_1
public OpCode Ldarg_2
public OpCode Ldarg_3
public OpCode Ldloc_0
public OpCode Ldloc_1
public OpCode Ldloc_2
public OpCode Ldloc_3
public OpCode Stloc_0
public OpCode Stloc_1
public OpCode Stloc_2
public OpCode Stloc_3
public OpCode Ldarg_S
public OpCode Ldarga_S
public OpCode Starg_S
public OpCode Ldloc_S
public OpCode Ldloca_S
public OpCode Stloc_S
public OpCode Ldnull
public OpCode Ldc_I4_M1
public OpCode Ldc_I4_0
public OpCode Ldc_I4_1
public OpCode Ldc_I4_2
public OpCode Ldc_I4_3
public OpCode Ldc_I4_4
public OpCode Ldc_I4_5
public OpCode Ldc_I4_6
public OpCode Ldc_I4_7
public OpCode Ldc_I4_8
public OpCode Ldc_I4_S
public OpCode Ldc_I4
public OpCode Ldc_I8
public OpCode Ldc_R4
public OpCode Ldc_R8
public OpCode Dup
public OpCode Pop
public OpCode Jmp
public OpCode Call
public OpCode Calli
public OpCode Ret
public OpCode Br_S
public OpCode Brfalse_S
public OpCode Brtrue_S
public OpCode Beq_S
public OpCode Bge_S
public OpCode Bgt_S
public OpCode Ble_S
public OpCode Blt_S
public OpCode Bne_Un_S
public OpCode Bge_Un_S
public OpCode Bgt_Un_S
public OpCode Ble_Un_S
public OpCode Blt_Un_S
public OpCode Br
public OpCode Brfalse
public OpCode Brtrue
public OpCode Beq
public OpCode Bge
public OpCode Bgt
public OpCode Ble
public OpCode Blt
public OpCode Bne_Un
public OpCode Bge_Un
public OpCode Bgt_Un
public OpCode Ble_Un
public OpCode Blt_Un
public OpCode Switch
public OpCode Ldind_I1
public OpCode Ldind_U1
public OpCode Ldind_I2
public OpCode Ldind_U2
public OpCode Ldind_I4
public OpCode Ldind_U4
public OpCode Ldind_I8
public OpCode Ldind_I
public OpCode Ldind_R4
public OpCode Ldind_R8
public OpCode Ldind_Ref
public OpCode Stind_Ref
public OpCode Stind_I1
public OpCode Stind_I2
public OpCode Stind_I4
public OpCode Stind_I8
public OpCode Stind_R4
public OpCode Stind_R8
public OpCode Add
public OpCode Sub
public OpCode Mul
public OpCode Div
public OpCode Div_Un
public OpCode Rem
public OpCode Rem_Un
public OpCode And
public OpCode Or
public OpCode Xor
public OpCode Shl
public OpCode Shr
public OpCode Shr_Un
public OpCode Neg
public OpCode Not
public OpCode Conv_I1
public OpCode Conv_I2
public OpCode Conv_I4
public OpCode Conv_I8
public OpCode Conv_R4
public OpCode Conv_R8
public OpCode Conv_U4
public OpCode Conv_U8
public OpCode Callvirt
public OpCode Cpobj
public OpCode Ldobj
public OpCode Ldstr
public OpCode Newobj
public OpCode Castclass
public OpCode Isinst
public OpCode Conv_R_Un
public OpCode Unbox
public OpCode Throw
public OpCode Ldfld
public OpCode Ldflda
public OpCode Stfld
public OpCode Ldsfld
public OpCode Ldsflda
public OpCode Stsfld
public OpCode Stobj
public OpCode Conv_Ovf_I1_Un
public OpCode Conv_Ovf_I2_Un
public OpCode Conv_Ovf_I4_Un
public OpCode Conv_Ovf_I8_Un
public OpCode Conv_Ovf_U1_Un
public OpCode Conv_Ovf_U2_Un
public OpCode Conv_Ovf_U4_Un
public OpCode Conv_Ovf_U8_Un
public OpCode Conv_Ovf_I_Un
public OpCode Conv_Ovf_U_Un
public OpCode Box
public OpCode Newarr
public OpCode Ldlen
public OpCode Ldelema
public OpCode Ldelem_I1
public OpCode Ldelem_U1
public OpCode Ldelem_I2
public OpCode Ldelem_U2
public OpCode Ldelem_I4
public OpCode Ldelem_U4
public OpCode Ldelem_I8
public OpCode Ldelem_I
public OpCode Ldelem_R4
public OpCode Ldelem_R8
public OpCode Ldelem_Ref
public OpCode Stelem_I
public OpCode Stelem_I1
public OpCode Stelem_I2
public OpCode Stelem_I4
public OpCode Stelem_I8
public OpCode Stelem_R4
public OpCode Stelem_R8
public OpCode Stelem_Ref
public OpCode Ldelem_Any
public OpCode Stelem_Any
public OpCode Unbox_Any
public OpCode Conv_Ovf_I1
public OpCode Conv_Ovf_U1
public OpCode Conv_Ovf_I2
public OpCode Conv_Ovf_U2
public OpCode Conv_Ovf_I4
public OpCode Conv_Ovf_U4
public OpCode Conv_Ovf_I8
public OpCode Conv_Ovf_U8
public OpCode Refanyval
public OpCode Ckfinite
public OpCode Mkrefany
public OpCode Ldtoken
public OpCode Conv_U2
public OpCode Conv_U1
public OpCode Conv_I
public OpCode Conv_Ovf_I
public OpCode Conv_Ovf_U
public OpCode Add_Ovf
public OpCode Add_Ovf_Un
public OpCode Mul_Ovf
public OpCode Mul_Ovf_Un
public OpCode Sub_Ovf
public OpCode Sub_Ovf_Un
public OpCode Endfinally
public OpCode Leave
public OpCode Leave_S
public OpCode Stind_I
public OpCode Conv_U
public OpCode Arglist
public OpCode Ceq
public OpCode Cgt
public OpCode Cgt_Un
public OpCode Clt
public OpCode Clt_Un
public OpCode Ldftn
public OpCode Ldvirtftn
public OpCode Ldarg
public OpCode Ldarga
public OpCode Starg
public OpCode Ldloc
public OpCode Ldloca
public OpCode Stloc
public OpCode Localloc
public OpCode Endfilter
public OpCode Unaligned
public OpCode Volatile
public OpCode Tail
public OpCode Initobj
public OpCode Constrained
public OpCode Cpblk
public OpCode Initblk
public OpCode No
public OpCode Rethrow
public OpCode Sizeof
public OpCode Refanytype
public OpCode Readonly
}
public Mono.Cecil.Cil.OpCodeType : Enum {
public int value__
public OpCodeType Annotation
public OpCodeType Macro
public OpCodeType Nternal
public OpCodeType Objmodel
public OpCodeType Prefix
public OpCodeType Primitive
}
public Mono.Cecil.Cil.OperandType : Enum {
public int value__
public OperandType InlineBrTarget
public OperandType InlineField
public OperandType InlineI
public OperandType InlineI8
public OperandType InlineMethod
public OperandType InlineNone
public OperandType InlinePhi
public OperandType InlineR
public OperandType InlineSig
public OperandType InlineString
public OperandType InlineSwitch
public OperandType InlineTok
public OperandType InlineType
public OperandType InlineVar
public OperandType InlineArg
public OperandType ShortInlineBrTarget
public OperandType ShortInlineI
public OperandType ShortInlineR
public OperandType ShortInlineVar
public OperandType ShortInlineArg
}
public Mono.Cecil.Cil.Scope : object {
private Instruction start
private Instruction end
private Collection`1<Scope> scopes
private Collection`1<VariableDefinition> variables
public Instruction Start
public Instruction End
public bool HasScopes
public Collection`1<Scope> Scopes
public bool HasVariables
public Collection`1<VariableDefinition> Variables
public Instruction get_Start()
public void set_Start(Instruction value)
public Instruction get_End()
public void set_End(Instruction value)
public bool get_HasScopes()
public Collection`1<Scope> get_Scopes()
public bool get_HasVariables()
public Collection`1<VariableDefinition> get_Variables()
}
public Mono.Cecil.Cil.SequencePoint : object {
private Document document
private int start_line
private int start_column
private int end_line
private int end_column
public int StartLine
public int StartColumn
public int EndLine
public int EndColumn
public Document Document
public int get_StartLine()
public void set_StartLine(int value)
public int get_StartColumn()
public void set_StartColumn(int value)
public int get_EndLine()
public void set_EndLine(int value)
public int get_EndColumn()
public void set_EndColumn(int value)
public Document get_Document()
public void set_Document(Document value)
public void .ctor(Document document)
}
public Mono.Cecil.Cil.StackBehaviour : Enum {
public int value__
public StackBehaviour Pop0
public StackBehaviour Pop1
public StackBehaviour Pop1_pop1
public StackBehaviour Popi
public StackBehaviour Popi_pop1
public StackBehaviour Popi_popi
public StackBehaviour Popi_popi8
public StackBehaviour Popi_popi_popi
public StackBehaviour Popi_popr4
public StackBehaviour Popi_popr8
public StackBehaviour Popref
public StackBehaviour Popref_pop1
public StackBehaviour Popref_popi
public StackBehaviour Popref_popi_popi
public StackBehaviour Popref_popi_popi8
public StackBehaviour Popref_popi_popr4
public StackBehaviour Popref_popi_popr8
public StackBehaviour Popref_popi_popref
public StackBehaviour PopAll
public StackBehaviour Push0
public StackBehaviour Push1
public StackBehaviour Push1_push1
public StackBehaviour Pushi
public StackBehaviour Pushi8
public StackBehaviour Pushr4
public StackBehaviour Pushr8
public StackBehaviour Pushref
public StackBehaviour Varpop
public StackBehaviour Varpush
}
internal Mono.Cecil.Cil.SymbolProvider : object {
private string symbol_kind
private ISymbolReaderProvider reader_provider
private ISymbolWriterProvider writer_provider
private AssemblyName GetPlatformSymbolAssemblyName()
private Type GetPlatformType(string fullname)
public ISymbolReaderProvider GetPlatformReaderProvider()
private string GetProviderTypeName(string name)
public ISymbolWriterProvider GetPlatformWriterProvider()
}
public Mono.Cecil.Cil.VariableDefinition : VariableReference {
public bool IsPinned
public bool get_IsPinned()
public void .ctor(TypeReference variableType)
public void .ctor(string name, TypeReference variableType)
public VariableDefinition Resolve()
}
internal Mono.Cecil.Cil.VariableDefinitionCollection : Collection`1<VariableDefinition> {
internal void .ctor(int capacity)
protected void OnAdd(VariableDefinition item, int index)
protected void OnInsert(VariableDefinition item, int index)
protected void OnSet(VariableDefinition item, int index)
protected void OnRemove(VariableDefinition item, int index)
}
public Mono.Cecil.Cil.VariableReference : object {
private string name
internal int index
protected TypeReference variable_type
public string Name
public TypeReference VariableType
public int Index
public string get_Name()
public void set_Name(string value)
public TypeReference get_VariableType()
public void set_VariableType(TypeReference value)
public int get_Index()
internal void .ctor(TypeReference variable_type)
internal void .ctor(string name, TypeReference variable_type)
public VariableDefinition Resolve()
public string ToString()
}
internal Mono.Cecil.ClassLayoutTable : SortedTable`1<Row`3<ushort, UInt32, UInt32>> {
public void Write(TableHeapBuffer buffer)
public int Compare(Row`3<ushort, UInt32, UInt32> x, Row`3<ushort, UInt32, UInt32> y)
}
internal Mono.Cecil.ConstantTable : SortedTable`1<Row`3<ElementType, UInt32, UInt32>> {
public void Write(TableHeapBuffer buffer)
public int Compare(Row`3<ElementType, UInt32, UInt32> x, Row`3<ElementType, UInt32, UInt32> y)
}
internal Mono.Cecil.CryptoService : object {
public void StrongName(Stream stream, ImageWriter writer, StrongNameKeyPair key_pair)
private void PatchStrongName(Stream stream, int strong_name_pointer, Byte[] strong_name)
private Byte[] CreateStrongName(StrongNameKeyPair key_pair, Byte[] hash)
private Byte[] HashStream(Stream stream, ImageWriter writer, Int32& strong_name_pointer)
private void CopyStreamChunk(Stream stream, Stream dest_stream, Byte[] buffer, int length)
public Byte[] ComputeHash(string file)
}
public Mono.Cecil.CustomAttribute : object {
internal UInt32 signature
internal bool resolved
private MethodReference constructor
private Byte[] blob
internal Collection`1<CustomAttributeArgument> arguments
internal Collection`1<CustomAttributeNamedArgument> fields
internal Collection`1<CustomAttributeNamedArgument> properties
public MethodReference Constructor
public TypeReference AttributeType
public bool IsResolved
public bool HasConstructorArguments
public Collection`1<CustomAttributeArgument> ConstructorArguments
public bool HasFields
public Collection`1<CustomAttributeNamedArgument> Fields
public bool HasProperties
public Collection`1<CustomAttributeNamedArgument> Properties
internal bool HasImage
internal ModuleDefinition Module
public MethodReference get_Constructor()
public void set_Constructor(MethodReference value)
public TypeReference get_AttributeType()
public bool get_IsResolved()
public bool get_HasConstructorArguments()
public Collection`1<CustomAttributeArgument> get_ConstructorArguments()
public bool get_HasFields()
public Collection`1<CustomAttributeNamedArgument> get_Fields()
public bool get_HasProperties()
public Collection`1<CustomAttributeNamedArgument> get_Properties()
internal bool get_HasImage()
internal ModuleDefinition get_Module()
internal void .ctor(UInt32 signature, MethodReference constructor)
public void .ctor(MethodReference constructor)
public void .ctor(MethodReference constructor, Byte[] blob)
public Byte[] GetBlob()
private void Resolve()
private CustomAttribute <Resolve>b__34_0(CustomAttribute attribute, MetadataReader reader)
}
public Mono.Cecil.CustomAttributeArgument : ValueType {
private TypeReference type
private object value
public TypeReference Type
public object Value
public TypeReference get_Type()
public object get_Value()
public void .ctor(TypeReference type, object value)
}
public Mono.Cecil.CustomAttributeNamedArgument : ValueType {
private string name
private CustomAttributeArgument argument
public string Name
public CustomAttributeArgument Argument
public string get_Name()
public CustomAttributeArgument get_Argument()
public void .ctor(string name, CustomAttributeArgument argument)
}
internal Mono.Cecil.CustomAttributeTable : SortedTable`1<Row`3<UInt32, UInt32, UInt32>> {
public void Write(TableHeapBuffer buffer)
public int Compare(Row`3<UInt32, UInt32, UInt32> x, Row`3<UInt32, UInt32, UInt32> y)
}
public Mono.Cecil.CustomMarshalInfo : MarshalInfo {
internal Guid guid
internal string unmanaged_type
internal TypeReference managed_type
internal string cookie
public Guid Guid
public string UnmanagedType
public TypeReference ManagedType
public string Cookie
public Guid get_Guid()
public void set_Guid(Guid value)
public string get_UnmanagedType()
public void set_UnmanagedType(string value)
public TypeReference get_ManagedType()
public void set_ManagedType(TypeReference value)
public string get_Cookie()
public void set_Cookie(string value)
}
internal Mono.Cecil.DeclSecurityTable : SortedTable`1<Row`3<SecurityAction, UInt32, UInt32>> {
public void Write(TableHeapBuffer buffer)
public int Compare(Row`3<SecurityAction, UInt32, UInt32> x, Row`3<SecurityAction, UInt32, UInt32> y)
}
public Mono.Cecil.DefaultAssemblyResolver : BaseAssemblyResolver {
private IDictionary`2<string, AssemblyDefinition> cache
public AssemblyDefinition Resolve(AssemblyNameReference name)
protected void RegisterAssembly(AssemblyDefinition assembly)
}
internal Mono.Cecil.DeferredModuleReader : ModuleReader {
public void .ctor(Image image)
protected void ReadModule()
private ModuleDefinition <ReadModule>b__1_0(ModuleDefinition module, MetadataReader reader)
}
public Mono.Cecil.EmbeddedResource : Resource {
private MetadataReader reader
private Nullable`1<UInt32> offset
private Byte[] data
private Stream stream
public ResourceType ResourceType
public ResourceType get_ResourceType()
public void .ctor(string name, ManifestResourceAttributes attributes, Byte[] data)
public void .ctor(string name, ManifestResourceAttributes attributes, Stream stream)
internal void .ctor(string name, ManifestResourceAttributes attributes, UInt32 offset, MetadataReader reader)
public Stream GetResourceStream()
public Byte[] GetResourceData()
private Byte[] ReadStream(Stream stream)
}
public Mono.Cecil.EventAttributes : Enum {
public ushort value__
public EventAttributes None
public EventAttributes SpecialName
public EventAttributes RTSpecialName
}
public Mono.Cecil.EventDefinition : EventReference {
private ushort attributes
private Collection`1<CustomAttribute> custom_attributes
internal MethodDefinition add_method
internal MethodDefinition invoke_method
internal MethodDefinition remove_method
internal Collection`1<MethodDefinition> other_methods
public EventAttributes Attributes
public MethodDefinition AddMethod
public MethodDefinition InvokeMethod
public MethodDefinition RemoveMethod
public bool HasOtherMethods
public Collection`1<MethodDefinition> OtherMethods
public bool HasCustomAttributes
public Collection`1<CustomAttribute> CustomAttributes
public bool IsSpecialName
public bool IsRuntimeSpecialName
public TypeDefinition DeclaringType
public bool IsDefinition
public EventAttributes get_Attributes()
public void set_Attributes(EventAttributes value)
public MethodDefinition get_AddMethod()
public void set_AddMethod(MethodDefinition value)
public MethodDefinition get_InvokeMethod()
public void set_InvokeMethod(MethodDefinition value)
public MethodDefinition get_RemoveMethod()
public void set_RemoveMethod(MethodDefinition value)
public bool get_HasOtherMethods()
public Collection`1<MethodDefinition> get_OtherMethods()
public bool get_HasCustomAttributes()
public Collection`1<CustomAttribute> get_CustomAttributes()
public bool get_IsSpecialName()
public void set_IsSpecialName(bool value)
public bool get_IsRuntimeSpecialName()
public void set_IsRuntimeSpecialName(bool value)
public TypeDefinition get_DeclaringType()
public void set_DeclaringType(TypeDefinition value)
public bool get_IsDefinition()
public void .ctor(string name, EventAttributes attributes, TypeReference eventType)
private void InitializeMethods()
public EventDefinition Resolve()
}
internal Mono.Cecil.EventMapTable : MetadataTable`1<Row`2<UInt32, UInt32>> {
public void Write(TableHeapBuffer buffer)
}
public Mono.Cecil.EventReference : MemberReference {
private TypeReference event_type
public TypeReference EventType
public string FullName
public TypeReference get_EventType()
public void set_EventType(TypeReference value)
public string get_FullName()
protected void .ctor(string name, TypeReference eventType)
public EventDefinition Resolve()
}
internal Mono.Cecil.EventTable : MetadataTable`1<Row`3<EventAttributes, UInt32, UInt32>> {
public void Write(TableHeapBuffer buffer)
}
public Mono.Cecil.ExportedType : object {
private string namespace
private string name
private UInt32 attributes
private IMetadataScope scope
private ModuleDefinition module
private int identifier
private ExportedType declaring_type
internal MetadataToken token
public string Namespace
public string Name
public TypeAttributes Attributes
public IMetadataScope Scope
public ExportedType DeclaringType
public MetadataToken MetadataToken
public int Identifier
public bool IsNotPublic
public bool IsPublic
public bool IsNestedPublic
public bool IsNestedPrivate
public bool IsNestedFamily
public bool IsNestedAssembly
public bool IsNestedFamilyAndAssembly
public bool IsNestedFamilyOrAssembly
public bool IsAutoLayout
public bool IsSequentialLayout
public bool IsExplicitLayout
public bool IsClass
public bool IsInterface
public bool IsAbstract
public bool IsSealed
public bool IsSpecialName
public bool IsImport
public bool IsSerializable
public bool IsAnsiClass
public bool IsUnicodeClass
public bool IsAutoClass
public bool IsBeforeFieldInit
public bool IsRuntimeSpecialName
public bool HasSecurity
public bool IsForwarder
public string FullName
public string get_Namespace()
public void set_Namespace(string value)
public string get_Name()
public void set_Name(string value)
public TypeAttributes get_Attributes()
public void set_Attributes(TypeAttributes value)
public IMetadataScope get_Scope()
public ExportedType get_DeclaringType()
public void set_DeclaringType(ExportedType value)
public MetadataToken get_MetadataToken()
public void set_MetadataToken(MetadataToken value)
public int get_Identifier()
public void set_Identifier(int value)
public bool get_IsNotPublic()
public void set_IsNotPublic(bool value)
public bool get_IsPublic()
public void set_IsPublic(bool value)
public bool get_IsNestedPublic()
public void set_IsNestedPublic(bool value)
public bool get_IsNestedPrivate()
public void set_IsNestedPrivate(bool value)
public bool get_IsNestedFamily()
public void set_IsNestedFamily(bool value)
public bool get_IsNestedAssembly()
public void set_IsNestedAssembly(bool value)
public bool get_IsNestedFamilyAndAssembly()
public void set_IsNestedFamilyAndAssembly(bool value)
public bool get_IsNestedFamilyOrAssembly()
public void set_IsNestedFamilyOrAssembly(bool value)
public bool get_IsAutoLayout()
public void set_IsAutoLayout(bool value)
public bool get_IsSequentialLayout()
public void set_IsSequentialLayout(bool value)
public bool get_IsExplicitLayout()
public void set_IsExplicitLayout(bool value)
public bool get_IsClass()
public void set_IsClass(bool value)
public bool get_IsInterface()
public void set_IsInterface(bool value)
public bool get_IsAbstract()
public void set_IsAbstract(bool value)
public bool get_IsSealed()
public void set_IsSealed(bool value)
public bool get_IsSpecialName()
public void set_IsSpecialName(bool value)
public bool get_IsImport()
public void set_IsImport(bool value)
public bool get_IsSerializable()
public void set_IsSerializable(bool value)
public bool get_IsAnsiClass()
public void set_IsAnsiClass(bool value)
public bool get_IsUnicodeClass()
public void set_IsUnicodeClass(bool value)
public bool get_IsAutoClass()
public void set_IsAutoClass(bool value)
public bool get_IsBeforeFieldInit()
public void set_IsBeforeFieldInit(bool value)
public bool get_IsRuntimeSpecialName()
public void set_IsRuntimeSpecialName(bool value)
public bool get_HasSecurity()
public void set_HasSecurity(bool value)
public bool get_IsForwarder()
public void set_IsForwarder(bool value)
public string get_FullName()
public void .ctor(string namespace, string name, ModuleDefinition module, IMetadataScope scope)
public string ToString()
public TypeDefinition Resolve()
internal TypeReference CreateReference()
}
internal Mono.Cecil.ExportedTypeTable : MetadataTable`1<Row`5<TypeAttributes, UInt32, UInt32, UInt32, UInt32>> {
public void Write(TableHeapBuffer buffer)
}
public Mono.Cecil.FieldAttributes : Enum {
public ushort value__
public FieldAttributes FieldAccessMask
public FieldAttributes CompilerControlled
public FieldAttributes Private
public FieldAttributes FamANDAssem
public FieldAttributes Assembly
public FieldAttributes Family
public FieldAttributes FamORAssem
public FieldAttributes Public
public FieldAttributes Static
public FieldAttributes InitOnly
public FieldAttributes Literal
public FieldAttributes NotSerialized
public FieldAttributes SpecialName
public FieldAttributes PInvokeImpl
public FieldAttributes RTSpecialName
public FieldAttributes HasFieldMarshal
public FieldAttributes HasDefault
public FieldAttributes HasFieldRVA
}
public Mono.Cecil.FieldDefinition : FieldReference {
private ushort attributes
private Collection`1<CustomAttribute> custom_attributes
private int offset
internal int rva
private Byte[] initial_value
private object constant
private MarshalInfo marshal_info
public bool HasLayoutInfo
public int Offset
public int RVA
public Byte[] InitialValue
public FieldAttributes Attributes
public bool HasConstant
public object Constant
public bool HasCustomAttributes
public Collection`1<CustomAttribute> CustomAttributes
public bool HasMarshalInfo
public MarshalInfo MarshalInfo
public bool IsCompilerControlled
public bool IsPrivate
public bool IsFamilyAndAssembly
public bool IsAssembly
public bool IsFamily
public bool IsFamilyOrAssembly
public bool IsPublic
public bool IsStatic
public bool IsInitOnly
public bool IsLiteral
public bool IsNotSerialized
public bool IsSpecialName
public bool IsPInvokeImpl
public bool IsRuntimeSpecialName
public bool HasDefault
public bool IsDefinition
public TypeDefinition DeclaringType
private void ResolveLayout()
public bool get_HasLayoutInfo()
public int get_Offset()
public void set_Offset(int value)
private void ResolveRVA()
public int get_RVA()
public Byte[] get_InitialValue()
public void set_InitialValue(Byte[] value)
public FieldAttributes get_Attributes()
public void set_Attributes(FieldAttributes value)
public bool get_HasConstant()
public void set_HasConstant(bool value)
public object get_Constant()
public void set_Constant(object value)
public bool get_HasCustomAttributes()
public Collection`1<CustomAttribute> get_CustomAttributes()
public bool get_HasMarshalInfo()
public MarshalInfo get_MarshalInfo()
public void set_MarshalInfo(MarshalInfo value)
public bool get_IsCompilerControlled()
public void set_IsCompilerControlled(bool value)
public bool get_IsPrivate()
public void set_IsPrivate(bool value)
public bool get_IsFamilyAndAssembly()
public void set_IsFamilyAndAssembly(bool value)
public bool get_IsAssembly()
public void set_IsAssembly(bool value)
public bool get_IsFamily()
public void set_IsFamily(bool value)
public bool get_IsFamilyOrAssembly()
public void set_IsFamilyOrAssembly(bool value)
public bool get_IsPublic()
public void set_IsPublic(bool value)
public bool get_IsStatic()
public void set_IsStatic(bool value)
public bool get_IsInitOnly()
public void set_IsInitOnly(bool value)
public bool get_IsLiteral()
public void set_IsLiteral(bool value)
public bool get_IsNotSerialized()
public void set_IsNotSerialized(bool value)
public bool get_IsSpecialName()
public void set_IsSpecialName(bool value)
public bool get_IsPInvokeImpl()
public void set_IsPInvokeImpl(bool value)
public bool get_IsRuntimeSpecialName()
public void set_IsRuntimeSpecialName(bool value)
public bool get_HasDefault()
public void set_HasDefault(bool value)
public bool get_IsDefinition()
public TypeDefinition get_DeclaringType()
public void set_DeclaringType(TypeDefinition value)
public void .ctor(string name, FieldAttributes attributes, TypeReference fieldType)
public FieldDefinition Resolve()
}
internal Mono.Cecil.FieldLayoutTable : SortedTable`1<Row`2<UInt32, UInt32>> {
public void Write(TableHeapBuffer buffer)
public int Compare(Row`2<UInt32, UInt32> x, Row`2<UInt32, UInt32> y)
}
internal Mono.Cecil.FieldMarshalTable : SortedTable`1<Row`2<UInt32, UInt32>> {
public void Write(TableHeapBuffer buffer)
public int Compare(Row`2<UInt32, UInt32> x, Row`2<UInt32, UInt32> y)
}
public Mono.Cecil.FieldReference : MemberReference {
private TypeReference field_type
public TypeReference FieldType
public string FullName
public bool ContainsGenericParameter
public TypeReference get_FieldType()
public void set_FieldType(TypeReference value)
public string get_FullName()
public bool get_ContainsGenericParameter()
public void .ctor(string name, TypeReference fieldType)
public void .ctor(string name, TypeReference fieldType, TypeReference declaringType)
public FieldDefinition Resolve()
}
internal Mono.Cecil.FieldRVATable : SortedTable`1<Row`2<UInt32, UInt32>> {
internal int position
public void Write(TableHeapBuffer buffer)
public int Compare(Row`2<UInt32, UInt32> x, Row`2<UInt32, UInt32> y)
}
internal Mono.Cecil.FieldTable : MetadataTable`1<Row`3<FieldAttributes, UInt32, UInt32>> {
public void Write(TableHeapBuffer buffer)
}
internal Mono.Cecil.FileAttributes : Enum {
public UInt32 value__
public FileAttributes ContainsMetaData
public FileAttributes ContainsNoMetaData
}
internal Mono.Cecil.FileTable : MetadataTable`1<Row`3<FileAttributes, UInt32, UInt32>> {
public void Write(TableHeapBuffer buffer)
}
public Mono.Cecil.FixedArrayMarshalInfo : MarshalInfo {
internal NativeType element_type
internal int size
public NativeType ElementType
public int Size
public NativeType get_ElementType()
public void set_ElementType(NativeType value)
public int get_Size()
public void set_Size(int value)
}
public Mono.Cecil.FixedSysStringMarshalInfo : MarshalInfo {
internal int size
public int Size
public int get_Size()
public void set_Size(int value)
}
public Mono.Cecil.FunctionPointerType : TypeSpecification {
private MethodReference function
public bool HasThis
public bool ExplicitThis
public MethodCallingConvention CallingConvention
public bool HasParameters
public Collection`1<ParameterDefinition> Parameters
public TypeReference ReturnType
public MethodReturnType MethodReturnType
public string Name
public string Namespace
public ModuleDefinition Module
public IMetadataScope Scope
public bool IsFunctionPointer
public bool ContainsGenericParameter
public string FullName
public bool get_HasThis()
public void set_HasThis(bool value)
public bool get_ExplicitThis()
public void set_ExplicitThis(bool value)
public MethodCallingConvention get_CallingConvention()
public void set_CallingConvention(MethodCallingConvention value)
public bool get_HasParameters()
public Collection`1<ParameterDefinition> get_Parameters()
public TypeReference get_ReturnType()
public void set_ReturnType(TypeReference value)
public MethodReturnType get_MethodReturnType()
public string get_Name()
public void set_Name(string value)
public string get_Namespace()
public void set_Namespace(string value)
public ModuleDefinition get_Module()
public IMetadataScope get_Scope()
public void set_Scope(IMetadataScope value)
public bool get_IsFunctionPointer()
public bool get_ContainsGenericParameter()
public string get_FullName()
public TypeDefinition Resolve()
public TypeReference GetElementType()
}
public Mono.Cecil.GenericInstanceMethod : MethodSpecification {
private Collection`1<TypeReference> arguments
public bool HasGenericArguments
public Collection`1<TypeReference> GenericArguments
public bool IsGenericInstance
private IGenericParameterProvider Mono.Cecil.IGenericContext.Method
private IGenericParameterProvider Mono.Cecil.IGenericContext.Type
public bool ContainsGenericParameter
public string FullName
public bool get_HasGenericArguments()
public Collection`1<TypeReference> get_GenericArguments()
public bool get_IsGenericInstance()
private IGenericParameterProvider Mono.Cecil.IGenericContext.get_Method()
private IGenericParameterProvider Mono.Cecil.IGenericContext.get_Type()
public bool get_ContainsGenericParameter()
public string get_FullName()
public void .ctor(MethodReference method)
}
public Mono.Cecil.GenericInstanceType : TypeSpecification {
private Collection`1<TypeReference> arguments
public bool HasGenericArguments
public Collection`1<TypeReference> GenericArguments
public TypeReference DeclaringType
public string FullName
public bool IsGenericInstance
public bool ContainsGenericParameter
private IGenericParameterProvider Mono.Cecil.IGenericContext.Type
public bool get_HasGenericArguments()
public Collection`1<TypeReference> get_GenericArguments()
public TypeReference get_DeclaringType()
public void set_DeclaringType(TypeReference value)
public string get_FullName()
public bool get_IsGenericInstance()
public bool get_ContainsGenericParameter()
private IGenericParameterProvider Mono.Cecil.IGenericContext.get_Type()
public void .ctor(TypeReference type)
}
internal Mono.Cecil.GenericParamConstraintTable : MetadataTable`1<Row`2<UInt32, UInt32>> {
public void Write(TableHeapBuffer buffer)
}
public Mono.Cecil.GenericParameter : TypeReference {
internal int position
internal GenericParameterType type
internal IGenericParameterProvider owner
private ushort attributes
private Collection`1<TypeReference> constraints
private Collection`1<CustomAttribute> custom_attributes
public GenericParameterAttributes Attributes
public int Position
public GenericParameterType Type
public IGenericParameterProvider Owner
public bool HasConstraints
public Collection`1<TypeReference> Constraints
public bool HasCustomAttributes
public Collection`1<CustomAttribute> CustomAttributes
public IMetadataScope Scope
public TypeReference DeclaringType
public MethodReference DeclaringMethod
public ModuleDefinition Module
public string Name
public string Namespace
public string FullName
public bool IsGenericParameter
public bool ContainsGenericParameter
public MetadataType MetadataType
public bool IsNonVariant
public bool IsCovariant
public bool IsContravariant
public bool HasReferenceTypeConstraint
public bool HasNotNullableValueTypeConstraint
public bool HasDefaultConstructorConstraint
public GenericParameterAttributes get_Attributes()
public void set_Attributes(GenericParameterAttributes value)
public int get_Position()
public GenericParameterType get_Type()
public IGenericParameterProvider get_Owner()
public bool get_HasConstraints()
public Collection`1<TypeReference> get_Constraints()
public bool get_HasCustomAttributes()
public Collection`1<CustomAttribute> get_CustomAttributes()
public IMetadataScope get_Scope()
public void set_Scope(IMetadataScope value)
public TypeReference get_DeclaringType()
public void set_DeclaringType(TypeReference value)
public MethodReference get_DeclaringMethod()
public ModuleDefinition get_Module()
public string get_Name()
public string get_Namespace()
public void set_Namespace(string value)
public string get_FullName()
public bool get_IsGenericParameter()
public bool get_ContainsGenericParameter()
public MetadataType get_MetadataType()
public bool get_IsNonVariant()
public void set_IsNonVariant(bool value)
public bool get_IsCovariant()
public void set_IsCovariant(bool value)
public bool get_IsContravariant()
public void set_IsContravariant(bool value)
public bool get_HasReferenceTypeConstraint()
public void set_HasReferenceTypeConstraint(bool value)
public bool get_HasNotNullableValueTypeConstraint()
public void set_HasNotNullableValueTypeConstraint(bool value)
public bool get_HasDefaultConstructorConstraint()
public void set_HasDefaultConstructorConstraint(bool value)
public void .ctor(IGenericParameterProvider owner)
public void .ctor(string name, IGenericParameterProvider owner)
internal void .ctor(int position, GenericParameterType type, ModuleDefinition module)
private ElementType ConvertGenericParameterType(GenericParameterType type)
public TypeDefinition Resolve()
}
public Mono.Cecil.GenericParameterAttributes : Enum {
public ushort value__
public GenericParameterAttributes VarianceMask
public GenericParameterAttributes NonVariant
public GenericParameterAttributes Covariant
public GenericParameterAttributes Contravariant
public GenericParameterAttributes SpecialConstraintMask
public GenericParameterAttributes ReferenceTypeConstraint
public GenericParameterAttributes NotNullableValueTypeConstraint
public GenericParameterAttributes DefaultConstructorConstraint
}
internal Mono.Cecil.GenericParameterCollection : Collection`1<GenericParameter> {
private IGenericParameterProvider owner
internal void .ctor(IGenericParameterProvider owner)
internal void .ctor(IGenericParameterProvider owner, int capacity)
protected void OnAdd(GenericParameter item, int index)
protected void OnInsert(GenericParameter item, int index)
protected void OnSet(GenericParameter item, int index)
private void UpdateGenericParameter(GenericParameter item, int index)
protected void OnRemove(GenericParameter item, int index)
}
public Mono.Cecil.GenericParameterType : Enum {
public int value__
public GenericParameterType Type
public GenericParameterType Method
}
internal Mono.Cecil.GenericParamTable : MetadataTable`1<Row`4<ushort, GenericParameterAttributes, UInt32, UInt32>> {
public void Write(TableHeapBuffer buffer)
}
public Mono.Cecil.IAssemblyResolver {
public AssemblyDefinition Resolve(AssemblyNameReference name)
public AssemblyDefinition Resolve(AssemblyNameReference name, ReaderParameters parameters)
public AssemblyDefinition Resolve(string fullName)
public AssemblyDefinition Resolve(string fullName, ReaderParameters parameters)
}
public Mono.Cecil.IConstantProvider {
public bool HasConstant
public object Constant
public bool get_HasConstant()
public void set_HasConstant(bool value)
public object get_Constant()
public void set_Constant(object value)
}
public Mono.Cecil.ICustomAttribute {
public TypeReference AttributeType
public bool HasFields
public bool HasProperties
public Collection`1<CustomAttributeNamedArgument> Fields
public Collection`1<CustomAttributeNamedArgument> Properties
public TypeReference get_AttributeType()
public bool get_HasFields()
public bool get_HasProperties()
public Collection`1<CustomAttributeNamedArgument> get_Fields()
public Collection`1<CustomAttributeNamedArgument> get_Properties()
}
public Mono.Cecil.ICustomAttributeProvider {
public Collection`1<CustomAttribute> CustomAttributes
public bool HasCustomAttributes
public Collection`1<CustomAttribute> get_CustomAttributes()
public bool get_HasCustomAttributes()
}
internal Mono.Cecil.IGenericContext {
public bool IsDefinition
public IGenericParameterProvider Type
public IGenericParameterProvider Method
public bool get_IsDefinition()
public IGenericParameterProvider get_Type()
public IGenericParameterProvider get_Method()
}
public Mono.Cecil.IGenericInstance {
public bool HasGenericArguments
public Collection`1<TypeReference> GenericArguments
public bool get_HasGenericArguments()
public Collection`1<TypeReference> get_GenericArguments()
}
public Mono.Cecil.IGenericParameterProvider {
public bool HasGenericParameters
public bool IsDefinition
public ModuleDefinition Module
public Collection`1<GenericParameter> GenericParameters
public GenericParameterType GenericParameterType
public bool get_HasGenericParameters()
public bool get_IsDefinition()
public ModuleDefinition get_Module()
public Collection`1<GenericParameter> get_GenericParameters()
public GenericParameterType get_GenericParameterType()
}
public Mono.Cecil.IMarshalInfoProvider {
public bool HasMarshalInfo
public MarshalInfo MarshalInfo
public bool get_HasMarshalInfo()
public MarshalInfo get_MarshalInfo()
public void set_MarshalInfo(MarshalInfo value)
}
public Mono.Cecil.IMemberDefinition {
public string Name
public string FullName
public bool IsSpecialName
public bool IsRuntimeSpecialName
public TypeDefinition DeclaringType
public string get_Name()
public void set_Name(string value)
public string get_FullName()
public bool get_IsSpecialName()
public void set_IsSpecialName(bool value)
public bool get_IsRuntimeSpecialName()
public void set_IsRuntimeSpecialName(bool value)
public TypeDefinition get_DeclaringType()
public void set_DeclaringType(TypeDefinition value)
}
public Mono.Cecil.IMetadataResolver {
public TypeDefinition Resolve(TypeReference type)
public FieldDefinition Resolve(FieldReference field)
public MethodDefinition Resolve(MethodReference method)
}
public Mono.Cecil.IMetadataScope {
public MetadataScopeType MetadataScopeType
public string Name
public MetadataScopeType get_MetadataScopeType()
public string get_Name()
public void set_Name(string value)
}
public Mono.Cecil.IMetadataTokenProvider {
public MetadataToken MetadataToken
public MetadataToken get_MetadataToken()
public void set_MetadataToken(MetadataToken value)
}
public Mono.Cecil.IMethodSignature {
public bool HasThis
public bool ExplicitThis
public MethodCallingConvention CallingConvention
public bool HasParameters
public Collection`1<ParameterDefinition> Parameters
public TypeReference ReturnType
public MethodReturnType MethodReturnType
public bool get_HasThis()
public void set_HasThis(bool value)
public bool get_ExplicitThis()
public void set_ExplicitThis(bool value)
public MethodCallingConvention get_CallingConvention()
public void set_CallingConvention(MethodCallingConvention value)
public bool get_HasParameters()
public Collection`1<ParameterDefinition> get_Parameters()
public TypeReference get_ReturnType()
public void set_ReturnType(TypeReference value)
public MethodReturnType get_MethodReturnType()
}
internal Mono.Cecil.ImmediateModuleReader : ModuleReader {
public void .ctor(Image image)
protected void ReadModule()
public void ReadModule(ModuleDefinition module)
private void ReadTypes(Collection`1<TypeDefinition> types)
private void ReadType(TypeDefinition type)
private void ReadGenericParameters(IGenericParameterProvider provider)
private void ReadSecurityDeclarations(ISecurityDeclarationProvider provider)
private void ReadCustomAttributes(ICustomAttributeProvider provider)
private void ReadFields(TypeDefinition type)
private void ReadMethods(TypeDefinition type)
private void ReadParameters(MethodDefinition method)
private void ReadProperties(TypeDefinition type)
private void ReadEvents(TypeDefinition type)
private void Read(object collection)
private ModuleDefinition <ReadModule>b__1_0(ModuleDefinition module, MetadataReader reader)
}
public Mono.Cecil.IModifierType {
public TypeReference ModifierType
public TypeReference ElementType
public TypeReference get_ModifierType()
public TypeReference get_ElementType()
}
internal Mono.Cecil.ImplMapTable : SortedTable`1<Row`4<PInvokeAttributes, UInt32, UInt32, UInt32>> {
public void Write(TableHeapBuffer buffer)
public int Compare(Row`4<PInvokeAttributes, UInt32, UInt32, UInt32> x, Row`4<PInvokeAttributes, UInt32, UInt32, UInt32> y)
}
internal Mono.Cecil.ImportGenericContext : ValueType {
private Collection`1<IGenericParameterProvider> stack
public bool IsEmpty
public bool get_IsEmpty()
public void .ctor(IGenericParameterProvider provider)
public void Push(IGenericParameterProvider provider)
public void Pop()
public TypeReference MethodParameter(string method, int position)
public string NormalizeMethodName(MethodReference method)
public TypeReference TypeParameter(string type, int position)
private TypeReference GenericTypeFor(IGenericParameterProvider context)
}
internal Mono.Cecil.ImportGenericKind : Enum {
public int value__
public ImportGenericKind Definition
public ImportGenericKind Open
}
internal Mono.Cecil.InterfaceImplTable : MetadataTable`1<Row`2<UInt32, UInt32>> {
public void Write(TableHeapBuffer buffer)
}
public Mono.Cecil.ISecurityDeclarationProvider {
public bool HasSecurityDeclarations
public Collection`1<SecurityDeclaration> SecurityDeclarations
public bool get_HasSecurityDeclarations()
public Collection`1<SecurityDeclaration> get_SecurityDeclarations()
}
public Mono.Cecil.LinkedResource : Resource {
internal Byte[] hash
private string file
public Byte[] Hash
public string File
public ResourceType ResourceType
public Byte[] get_Hash()
public string get_File()
public void set_File(string value)
public ResourceType get_ResourceType()
public void .ctor(string name, ManifestResourceAttributes flags)
public void .ctor(string name, ManifestResourceAttributes flags, string file)
}
public Mono.Cecil.ManifestResourceAttributes : Enum {
public UInt32 value__
public ManifestResourceAttributes VisibilityMask
public ManifestResourceAttributes Public
public ManifestResourceAttributes Private
}
internal Mono.Cecil.ManifestResourceTable : MetadataTable`1<Row`4<UInt32, ManifestResourceAttributes, UInt32, UInt32>> {
public void Write(TableHeapBuffer buffer)
}
public Mono.Cecil.MarshalInfo : object {
internal NativeType native
public NativeType NativeType
public NativeType get_NativeType()
public void set_NativeType(NativeType value)
public void .ctor(NativeType native)
}
internal Mono.Cecil.MemberDefinitionCollection`1 : Collection`1<T> {
private TypeDefinition container
internal void .ctor(TypeDefinition container)
internal void .ctor(TypeDefinition container, int capacity)
protected void OnAdd(T item, int index)
protected void OnSet(T item, int index)
protected void OnInsert(T item, int index)
protected void OnRemove(T item, int index)
protected void OnClear()
private void Attach(T element)
private void Detach(T element)
}
public Mono.Cecil.MemberReference : object {
private string name
private TypeReference declaring_type
internal MetadataToken token
public string Name
public string FullName
public TypeReference DeclaringType
public MetadataToken MetadataToken
internal bool HasImage
public ModuleDefinition Module
public bool IsDefinition
public bool ContainsGenericParameter
public string get_Name()
public void set_Name(string value)
public string get_FullName()
public TypeReference get_DeclaringType()
public void set_DeclaringType(TypeReference value)
public MetadataToken get_MetadataToken()
public void set_MetadataToken(MetadataToken value)
internal bool get_HasImage()
public ModuleDefinition get_Module()
public bool get_IsDefinition()
public bool get_ContainsGenericParameter()
internal void .ctor(string name)
internal string MemberFullName()
public string ToString()
}
internal Mono.Cecil.MemberRefTable : MetadataTable`1<Row`3<UInt32, UInt32, UInt32>> {
public void Write(TableHeapBuffer buffer)
}
internal Mono.Cecil.Metadata.BlobHeap : Heap {
public void .ctor(Section section, UInt32 start, UInt32 size)
public Byte[] Read(UInt32 index)
}
internal Mono.Cecil.Metadata.BlobHeapBuffer : HeapBuffer {
private Dictionary`2<ByteBuffer, UInt32> blobs
public bool IsEmpty
public bool get_IsEmpty()
public UInt32 GetBlobIndex(ByteBuffer blob)
private void WriteBlob(ByteBuffer blob)
}
internal Mono.Cecil.Metadata.CodedIndex : Enum {
public int value__
public CodedIndex TypeDefOrRef
public CodedIndex HasConstant
public CodedIndex HasCustomAttribute
public CodedIndex HasFieldMarshal
public CodedIndex HasDeclSecurity
public CodedIndex MemberRefParent
public CodedIndex HasSemantics
public CodedIndex MethodDefOrRef
public CodedIndex MemberForwarded
public CodedIndex Implementation
public CodedIndex CustomAttributeType
public CodedIndex ResolutionScope
public CodedIndex TypeOrMethodDef
}
internal Mono.Cecil.Metadata.DataBuffer : ByteBuffer {
public UInt32 AddData(Byte[] data)
}
internal Mono.Cecil.Metadata.ElementType : Enum {
public byte value__
public ElementType None
public ElementType Void
public ElementType Boolean
public ElementType Char
public ElementType I1
public ElementType U1
public ElementType I2
public ElementType U2
public ElementType I4
public ElementType U4
public ElementType I8
public ElementType U8
public ElementType R4
public ElementType R8
public ElementType String
public ElementType Ptr
public ElementType ByRef
public ElementType ValueType
public ElementType Class
public ElementType Var
public ElementType Array
public ElementType GenericInst
public ElementType TypedByRef
public ElementType I
public ElementType U
public ElementType FnPtr
public ElementType Object
public ElementType SzArray
public ElementType MVar
public ElementType CModReqD
public ElementType CModOpt
public ElementType Internal
public ElementType Modifier
public ElementType Sentinel
public ElementType Pinned
public ElementType Type
public ElementType Boxed
public ElementType Enum
}
internal Mono.Cecil.Metadata.GuidHeap : Heap {
public void .ctor(Section section, UInt32 start, UInt32 size)
public Guid Read(UInt32 index)
}
internal Mono.Cecil.Metadata.Heap : object {
public int IndexSize
public Section Section
public UInt32 Offset
public UInt32 Size
protected void .ctor(Section section, UInt32 offset, UInt32 size)
}
internal Mono.Cecil.Metadata.HeapBuffer : ByteBuffer {
public bool IsLarge
public bool IsEmpty
public bool get_IsLarge()
public bool get_IsEmpty()
protected void .ctor(int length)
}
internal Mono.Cecil.Metadata.ResourceBuffer : ByteBuffer {
public UInt32 AddResource(Byte[] resource)
}
internal Mono.Cecil.Metadata.Row`2 : ValueType {
internal T1 Col1
internal T2 Col2
public void .ctor(T1 col1, T2 col2)
}
internal Mono.Cecil.Metadata.Row`3 : ValueType {
internal T1 Col1
internal T2 Col2
internal T3 Col3
public void .ctor(T1 col1, T2 col2, T3 col3)
}
internal Mono.Cecil.Metadata.Row`4 : ValueType {
internal T1 Col1
internal T2 Col2
internal T3 Col3
internal T4 Col4
public void .ctor(T1 col1, T2 col2, T3 col3, T4 col4)
}
internal Mono.Cecil.Metadata.Row`5 : ValueType {
internal T1 Col1
internal T2 Col2
internal T3 Col3
internal T4 Col4
internal T5 Col5
public void .ctor(T1 col1, T2 col2, T3 col3, T4 col4, T5 col5)
}
internal Mono.Cecil.Metadata.Row`6 : ValueType {
internal T1 Col1
internal T2 Col2
internal T3 Col3
internal T4 Col4
internal T5 Col5
internal T6 Col6
public void .ctor(T1 col1, T2 col2, T3 col3, T4 col4, T5 col5, T6 col6)
}
internal Mono.Cecil.Metadata.Row`9 : ValueType {
internal T1 Col1
internal T2 Col2
internal T3 Col3
internal T4 Col4
internal T5 Col5
internal T6 Col6
internal T7 Col7
internal T8 Col8
internal T9 Col9
public void .ctor(T1 col1, T2 col2, T3 col3, T4 col4, T5 col5, T6 col6, T7 col7, T8 col8, T9 col9)
}
internal Mono.Cecil.Metadata.RowEqualityComparer : object {
public bool Equals(Row`2<string, string> x, Row`2<string, string> y)
public int GetHashCode(Row`2<string, string> obj)
public bool Equals(Row`2<UInt32, UInt32> x, Row`2<UInt32, UInt32> y)
public int GetHashCode(Row`2<UInt32, UInt32> obj)
public bool Equals(Row`3<UInt32, UInt32, UInt32> x, Row`3<UInt32, UInt32, UInt32> y)
public int GetHashCode(Row`3<UInt32, UInt32, UInt32> obj)
}
internal Mono.Cecil.Metadata.StringHeap : Heap {
private Dictionary`2<UInt32, string> strings
public void .ctor(Section section, UInt32 start, UInt32 size)
public string Read(UInt32 index)
protected string ReadStringAt(UInt32 index)
}
internal Mono.Cecil.Metadata.StringHeapBuffer : HeapBuffer {
private Dictionary`2<string, UInt32> strings
public bool IsEmpty
public bool get_IsEmpty()
public UInt32 GetStringIndex(string string)
protected void WriteString(string string)
}
internal Mono.Cecil.Metadata.Table : Enum {
public byte value__
public Table Module
public Table TypeRef
public Table TypeDef
public Table FieldPtr
public Table Field
public Table MethodPtr
public Table Method
public Table ParamPtr
public Table Param
public Table InterfaceImpl
public Table MemberRef
public Table Constant
public Table CustomAttribute
public Table FieldMarshal
public Table DeclSecurity
public Table ClassLayout
public Table FieldLayout
public Table StandAloneSig
public Table EventMap
public Table EventPtr
public Table Event
public Table PropertyMap
public Table PropertyPtr
public Table Property
public Table MethodSemantics
public Table MethodImpl
public Table ModuleRef
public Table TypeSpec
public Table ImplMap
public Table FieldRVA
public Table EncLog
public Table EncMap
public Table Assembly
public Table AssemblyProcessor
public Table AssemblyOS
public Table AssemblyRef
public Table AssemblyRefProcessor
public Table AssemblyRefOS
public Table File
public Table ExportedType
public Table ManifestResource
public Table NestedClass
public Table GenericParam
public Table MethodSpec
public Table GenericParamConstraint
}
internal Mono.Cecil.Metadata.TableHeap : Heap {
public long Valid
public long Sorted
public int TableCount
public TableInformation[] Tables
public TableInformation Item
public TableInformation get_Item(Table table)
public void .ctor(Section section, UInt32 start, UInt32 size)
public bool HasTable(Table table)
}
internal Mono.Cecil.Metadata.TableHeapBuffer : HeapBuffer {
private ModuleDefinition module
private MetadataBuilder metadata
internal MetadataTable[] tables
private bool large_string
private bool large_blob
private Int32[] coded_index_sizes
private Func`2<Table, int> counter
public bool IsEmpty
public bool get_IsEmpty()
public void .ctor(ModuleDefinition module, MetadataBuilder metadata)
private int GetTableLength(Table table)
public TTable GetTable(Table table)
public void WriteBySize(UInt32 value, int size)
public void WriteBySize(UInt32 value, bool large)
public void WriteString(UInt32 string)
public void WriteBlob(UInt32 blob)
public void WriteRID(UInt32 rid, Table table)
private int GetCodedIndexSize(CodedIndex coded_index)
public void WriteCodedRID(UInt32 rid, CodedIndex coded_index)
public void WriteTableHeap()
private void WriteRowCount()
private void WriteTables()
private ulong GetValid()
private byte GetHeapSizes()
private byte GetTableHeapVersion()
public void FixupData(UInt32 data_rva)
}
internal Mono.Cecil.Metadata.TableInformation : ValueType {
public UInt32 Offset
public UInt32 Length
public UInt32 RowSize
}
internal Mono.Cecil.Metadata.UserStringHeap : StringHeap {
public void .ctor(Section section, UInt32 start, UInt32 size)
protected string ReadStringAt(UInt32 index)
}
internal Mono.Cecil.Metadata.UserStringHeapBuffer : StringHeapBuffer {
protected void WriteString(string string)
}
internal Mono.Cecil.MetadataBuilder : object {
internal ModuleDefinition module
internal ISymbolWriterProvider symbol_writer_provider
internal ISymbolWriter symbol_writer
internal TextMap text_map
internal string fq_name
private Dictionary`2<Row`3<UInt32, UInt32, UInt32>, MetadataToken> type_ref_map
private Dictionary`2<UInt32, MetadataToken> type_spec_map
private Dictionary`2<Row`3<UInt32, UInt32, UInt32>, MetadataToken> member_ref_map
private Dictionary`2<Row`2<UInt32, UInt32>, MetadataToken> method_spec_map
private Collection`1<GenericParameter> generic_parameters
private Dictionary`2<MetadataToken, MetadataToken> method_def_map
internal CodeWriter code
internal DataBuffer data
internal ResourceBuffer resources
internal StringHeapBuffer string_heap
internal UserStringHeapBuffer user_string_heap
internal BlobHeapBuffer blob_heap
internal TableHeapBuffer table_heap
internal MetadataToken entry_point
private UInt32 type_rid
private UInt32 field_rid
private UInt32 method_rid
private UInt32 param_rid
private UInt32 property_rid
private UInt32 event_rid
private TypeRefTable type_ref_table
private TypeDefTable type_def_table
private FieldTable field_table
private MethodTable method_table
private ParamTable param_table
private InterfaceImplTable iface_impl_table
private MemberRefTable member_ref_table
private ConstantTable constant_table
private CustomAttributeTable custom_attribute_table
private DeclSecurityTable declsec_table
private StandAloneSigTable standalone_sig_table
private EventMapTable event_map_table
private EventTable event_table
private PropertyMapTable property_map_table
private PropertyTable property_table
private TypeSpecTable typespec_table
private MethodSpecTable method_spec_table
internal bool write_symbols
public void .ctor(ModuleDefinition module, string fq_name, ISymbolWriterProvider symbol_writer_provider, ISymbolWriter symbol_writer)
private TextMap CreateTextMap()
private TTable GetTable(Table table)
private UInt32 GetStringIndex(string string)
private UInt32 GetBlobIndex(ByteBuffer blob)
private UInt32 GetBlobIndex(Byte[] blob)
public void BuildMetadata()
private void BuildModule()
private void BuildAssembly()
private void BuildModules()
private string GetModuleFileName(string name)
private void AddAssemblyReferences()
private void AddModuleReferences()
private void AddResources()
private UInt32 AddLinkedResource(LinkedResource resource)
private UInt32 AddEmbeddedResource(EmbeddedResource resource)
private void AddExportedTypes()
private MetadataToken GetExportedTypeScope(ExportedType exported_type)
private void BuildTypes()
private void AttachTokens()
private void AttachTypeDefToken(TypeDefinition type)
private void AttachNestedTypesDefToken(TypeDefinition type)
private void AttachFieldsDefToken(TypeDefinition type)
private void AttachMethodsDefToken(TypeDefinition type)
public bool TryGetOriginalMethodToken(MetadataToken new_token, MetadataToken& original)
private MetadataToken GetTypeToken(TypeReference type)
private MetadataToken GetTypeSpecToken(TypeReference type)
private MetadataToken AddTypeSpecification(TypeReference type, UInt32 row)
private MetadataToken GetTypeRefToken(TypeReference type)
private Row`3<UInt32, UInt32, UInt32> CreateTypeRefRow(TypeReference type)
private MetadataToken GetScopeToken(TypeReference type)
private UInt32 MakeCodedRID(IMetadataTokenProvider provider, CodedIndex index)
private UInt32 MakeCodedRID(MetadataToken token, CodedIndex index)
private MetadataToken AddTypeReference(TypeReference type, Row`3<UInt32, UInt32, UInt32> row)
private void AddTypeDefs()
private void AddType(TypeDefinition type)
private void AddGenericParameters(IGenericParameterProvider owner)
private void AddGenericParameters()
private void AddConstraints(GenericParameter generic_parameter, GenericParamConstraintTable table)
private void AddInterfaces(TypeDefinition type)
private void AddLayoutInfo(TypeDefinition type)
private void AddNestedTypes(TypeDefinition type)
private void AddFields(TypeDefinition type)
private void AddField(FieldDefinition field)
private void AddFieldRVA(FieldDefinition field)
private void AddFieldLayout(FieldDefinition field)
private void AddMethods(TypeDefinition type)
private void AddMethod(MethodDefinition method)
private void AddParameters(MethodDefinition method)
private void AddPInvokeInfo(MethodDefinition method)
private void AddOverrides(MethodDefinition method)
private bool RequiresParameterRow(ParameterDefinition parameter)
private void AddParameter(ushort sequence, ParameterDefinition parameter, ParamTable table)
private void AddMarshalInfo(IMarshalInfoProvider owner)
private void AddProperties(TypeDefinition type)
private void AddProperty(PropertyDefinition property)
private void AddOtherSemantic(IMetadataTokenProvider owner, Collection`1<MethodDefinition> others)
private void AddEvents(TypeDefinition type)
private void AddEvent(EventDefinition event)
private void AddSemantic(MethodSemanticsAttributes semantics, IMetadataTokenProvider provider, MethodDefinition method)
private void AddConstant(IConstantProvider owner, TypeReference type)
private ElementType GetConstantType(TypeReference constant_type, object constant)
private ElementType GetConstantType(Type type)
private void AddCustomAttributes(ICustomAttributeProvider owner)
private void AddSecurityDeclarations(ISecurityDeclarationProvider owner)
private MetadataToken GetMemberRefToken(MemberReference member)
private Row`3<UInt32, UInt32, UInt32> CreateMemberRefRow(MemberReference member)
private void AddMemberReference(MemberReference member, Row`3<UInt32, UInt32, UInt32> row)
private MetadataToken GetMethodSpecToken(MethodSpecification method_spec)
private void AddMethodSpecification(MethodSpecification method_spec, Row`2<UInt32, UInt32> row)
private Row`2<UInt32, UInt32> CreateMethodSpecRow(MethodSpecification method_spec)
private SignatureWriter CreateSignatureWriter()
private SignatureWriter GetMethodSpecSignature(MethodSpecification method_spec)
public UInt32 AddStandAloneSignature(UInt32 signature)
public UInt32 GetLocalVariableBlobIndex(Collection`1<VariableDefinition> variables)
public UInt32 GetCallSiteBlobIndex(CallSite call_site)
private SignatureWriter GetVariablesSignature(Collection`1<VariableDefinition> variables)
private SignatureWriter GetFieldSignature(FieldReference field)
private SignatureWriter GetMethodSignature(IMethodSignature method)
private SignatureWriter GetMemberRefSignature(MemberReference member)
private SignatureWriter GetPropertySignature(PropertyDefinition property)
private SignatureWriter GetTypeSpecSignature(TypeReference type)
private SignatureWriter GetConstantSignature(ElementType type, object value)
private SignatureWriter GetCustomAttributeSignature(CustomAttribute attribute)
private SignatureWriter GetSecurityDeclarationSignature(SecurityDeclaration declaration)
private SignatureWriter GetMarshalInfoSignature(IMarshalInfoProvider owner)
private Exception CreateForeignMemberException(MemberReference member)
public MetadataToken LookupToken(IMetadataTokenProvider provider)
}
internal Mono.Cecil.MetadataImporter : object {
private ModuleDefinition module
private Dictionary`2<Type, ElementType> type_etype_mapping
public void .ctor(ModuleDefinition module)
public TypeReference ImportType(Type type, ImportGenericContext context)
public TypeReference ImportType(Type type, ImportGenericContext context, ImportGenericKind import_kind)
private bool ImportOpenGenericType(Type type, ImportGenericKind import_kind)
private bool ImportOpenGenericMethod(MethodBase method, ImportGenericKind import_kind)
private bool IsNestedType(Type type)
private TypeReference ImportTypeSpecification(Type type, ImportGenericContext context)
private TypeReference ImportGenericParameter(Type type, ImportGenericContext context)
private string NormalizeMethodName(MethodBase method)
private string NormalizeTypeFullName(Type type)
private TypeReference ImportGenericInstance(Type type, ImportGenericContext context)
private bool IsTypeSpecification(Type type)
private bool IsGenericInstance(Type type)
private ElementType ImportElementType(Type type)
private AssemblyNameReference ImportScope(Assembly assembly)
private bool TryGetAssemblyNameReference(AssemblyName name, AssemblyNameReference& assembly_reference)
public FieldReference ImportField(FieldInfo field, ImportGenericContext context)
private FieldInfo ResolveFieldDefinition(FieldInfo field)
public MethodReference ImportMethod(MethodBase method, ImportGenericContext context, ImportGenericKind import_kind)
private void ImportGenericParameters(IGenericParameterProvider provider, Type[] arguments)
private bool IsMethodSpecification(MethodBase method)
private MethodReference ImportMethodSpecification(MethodBase method, ImportGenericContext context)
private bool HasCallingConvention(MethodBase method, CallingConventions conventions)
public TypeReference ImportType(TypeReference type, ImportGenericContext context)
private IMetadataScope ImportScope(IMetadataScope scope)
private AssemblyNameReference ImportAssemblyName(AssemblyNameReference name)
private bool TryGetAssemblyNameReference(AssemblyNameReference name_reference, AssemblyNameReference& assembly_reference)
private void ImportGenericParameters(IGenericParameterProvider imported, IGenericParameterProvider original)
private TypeReference ImportTypeSpecification(TypeReference type, ImportGenericContext context)
public FieldReference ImportField(FieldReference field, ImportGenericContext context)
public MethodReference ImportMethod(MethodReference method, ImportGenericContext context)
private MethodSpecification ImportMethodSpecification(MethodReference method, ImportGenericContext context)
}
internal Mono.Cecil.MetadataReader : ByteBuffer {
internal Image image
internal ModuleDefinition module
internal MetadataSystem metadata
internal IGenericContext context
internal CodeReader code
private UInt32 Position
private UInt32 get_Position()
private void set_Position(UInt32 value)
public void .ctor(ModuleDefinition module)
private int GetCodedIndexSize(CodedIndex index)
private UInt32 ReadByIndexSize(int size)
private Byte[] ReadBlob()
private Byte[] ReadBlob(UInt32 signature)
private UInt32 ReadBlobIndex()
private string ReadString()
private UInt32 ReadStringIndex()
private UInt32 ReadTableIndex(Table table)
private MetadataToken ReadMetadataToken(CodedIndex index)
private int MoveTo(Table table)
private bool MoveTo(Table table, UInt32 row)
public AssemblyNameDefinition ReadAssemblyNameDefinition()
public ModuleDefinition Populate(ModuleDefinition module)
private void InitializeAssemblyReferences()
public Collection`1<AssemblyNameReference> ReadAssemblyReferences()
public MethodDefinition ReadEntryPoint()
public Collection`1<ModuleDefinition> ReadModules()
private string GetModuleFileName(string name)
private void InitializeModuleReferences()
public Collection`1<ModuleReference> ReadModuleReferences()
public bool HasFileResource()
public Collection`1<Resource> ReadResources()
private Row`3<FileAttributes, string, UInt32> ReadFileRecord(UInt32 rid)
public MemoryStream GetManagedResourceStream(UInt32 offset)
private void PopulateVersionAndFlags(AssemblyNameReference name)
private void PopulateNameAndCulture(AssemblyNameReference name)
public TypeDefinitionCollection ReadTypes()
private void CompleteTypes()
private void InitializeTypeDefinitions()
private bool IsNested(TypeAttributes attributes)
public bool HasNestedTypes(TypeDefinition type)
public Collection`1<TypeDefinition> ReadNestedTypes(TypeDefinition type)
private void InitializeNestedTypes()
private void AddNestedMapping(UInt32 declaring, UInt32 nested)
private TValue[] AddMapping(Dictionary`2<TKey, TValue[]> cache, TKey key, TValue value)
private TypeDefinition ReadType(UInt32 rid)
private TypeDefinition GetNestedTypeDeclaringType(TypeDefinition type)
private Range ReadFieldsRange(UInt32 type_index)
private Range ReadMethodsRange(UInt32 type_index)
private Range ReadListRange(UInt32 current_index, Table current, Table target)
public Row`2<short, int> ReadTypeLayout(TypeDefinition type)
private void InitializeTypeLayouts()
public TypeReference GetTypeDefOrRef(MetadataToken token)
public TypeDefinition GetTypeDefinition(UInt32 rid)
private TypeDefinition ReadTypeDefinition(UInt32 rid)
private void InitializeTypeReferences()
public TypeReference GetTypeReference(string scope, string full_name)
private TypeReference GetTypeReference(UInt32 rid)
private TypeReference ReadTypeReference(UInt32 rid)
private IMetadataScope GetTypeReferenceScope(MetadataToken scope)
public IEnumerable`1<TypeReference> GetTypeReferences()
private TypeReference GetTypeSpecification(UInt32 rid)
private SignatureReader ReadSignature(UInt32 signature)
public bool HasInterfaces(TypeDefinition type)
public Collection`1<TypeReference> ReadInterfaces(TypeDefinition type)
private void InitializeInterfaces()
private void AddInterfaceMapping(UInt32 type, MetadataToken interface)
public Collection`1<FieldDefinition> ReadFields(TypeDefinition type)
private void ReadField(UInt32 field_rid, Collection`1<FieldDefinition> fields)
private void InitializeFields()
private TypeReference ReadFieldType(UInt32 signature)
public int ReadFieldRVA(FieldDefinition field)
private Byte[] GetFieldInitializeValue(int size, UInt32 rva)
private int GetFieldTypeSize(TypeReference type)
private void InitializeFieldRVAs()
public int ReadFieldLayout(FieldDefinition field)
private void InitializeFieldLayouts()
public bool HasEvents(TypeDefinition type)
public Collection`1<EventDefinition> ReadEvents(TypeDefinition type)
private void ReadEvent(UInt32 event_rid, Collection`1<EventDefinition> events)
private void InitializeEvents()
private Range ReadEventsRange(UInt32 rid)
public bool HasProperties(TypeDefinition type)
public Collection`1<PropertyDefinition> ReadProperties(TypeDefinition type)
private void ReadProperty(UInt32 property_rid, Collection`1<PropertyDefinition> properties)
private void InitializeProperties()
private Range ReadPropertiesRange(UInt32 rid)
private MethodSemanticsAttributes ReadMethodSemantics(MethodDefinition method)
private EventDefinition GetEvent(TypeDefinition type, MetadataToken token)
private PropertyDefinition GetProperty(TypeDefinition type, MetadataToken token)
private TMember GetMember(Collection`1<TMember> members, MetadataToken token)
private void InitializeMethodSemantics()
public PropertyDefinition ReadMethods(PropertyDefinition property)
public EventDefinition ReadMethods(EventDefinition event)
public MethodSemanticsAttributes ReadAllSemantics(MethodDefinition method)
private void ReadAllSemantics(TypeDefinition type)
private Range ReadParametersRange(UInt32 method_rid)
public Collection`1<MethodDefinition> ReadMethods(TypeDefinition type)
private void ReadPointers(Table ptr, Table table, Range range, Collection`1<TMember> members, Action`2<UInt32, Collection`1<TMember>> reader)
private bool IsDeleted(IMemberDefinition member)
private void InitializeMethods()
private void ReadMethod(UInt32 method_rid, Collection`1<MethodDefinition> methods)
private void ReadParameters(MethodDefinition method, Range param_range)
private void ReadParameterPointers(MethodDefinition method, Range range)
private void ReadParameter(UInt32 param_rid, MethodDefinition method)
private void ReadMethodSignature(UInt32 signature, IMethodSignature method)
public PInvokeInfo ReadPInvokeInfo(MethodDefinition method)
private void InitializePInvokes()
public bool HasGenericParameters(IGenericParameterProvider provider)
public Collection`1<GenericParameter> ReadGenericParameters(IGenericParameterProvider provider)
private void ReadGenericParametersRange(Range range, IGenericParameterProvider provider, GenericParameterCollection generic_parameters)
private void InitializeGenericParameters()
private Dictionary`2<MetadataToken, Range[]> InitializeRanges(Table table, Func`1<MetadataToken> get_next)
private void AddRange(Dictionary`2<MetadataToken, Range[]> ranges, MetadataToken owner, Range range)
public bool HasGenericConstraints(GenericParameter generic_parameter)
public Collection`1<TypeReference> ReadGenericConstraints(GenericParameter generic_parameter)
private void InitializeGenericConstraints()
private void AddGenericConstraintMapping(UInt32 generic_parameter, MetadataToken constraint)
public bool HasOverrides(MethodDefinition method)
public Collection`1<MethodReference> ReadOverrides(MethodDefinition method)
private void InitializeOverrides()
private void AddOverrideMapping(UInt32 method_rid, MetadataToken override)
public MethodBody ReadMethodBody(MethodDefinition method)
public CallSite ReadCallSite(MetadataToken token)
public VariableDefinitionCollection ReadVariables(MetadataToken local_var_token)
public IMetadataTokenProvider LookupToken(MetadataToken token)
public FieldDefinition GetFieldDefinition(UInt32 rid)
private FieldDefinition LookupField(UInt32 rid)
public MethodDefinition GetMethodDefinition(UInt32 rid)
private MethodDefinition LookupMethod(UInt32 rid)
private MethodSpecification GetMethodSpecification(UInt32 rid)
private MethodSpecification ReadMethodSpecSignature(UInt32 signature, MethodReference method)
private MemberReference GetMemberReference(UInt32 rid)
private MemberReference ReadMemberReference(UInt32 rid)
private MemberReference ReadTypeMemberReference(MetadataToken type, string name, UInt32 signature)
private MemberReference ReadMemberReferenceSignature(UInt32 signature, TypeReference declaring_type)
private MemberReference ReadMethodMemberReference(MetadataToken token, string name, UInt32 signature)
private void InitializeMemberReferences()
public IEnumerable`1<MemberReference> GetMemberReferences()
private void InitializeConstants()
public object ReadConstant(IConstantProvider owner)
private string ReadConstantString(Byte[] blob)
private object ReadConstantPrimitive(ElementType type, UInt32 signature)
private void InitializeCustomAttributes()
public bool HasCustomAttributes(ICustomAttributeProvider owner)
public Collection`1<CustomAttribute> ReadCustomAttributes(ICustomAttributeProvider owner)
private void ReadCustomAttributeRange(Range range, Collection`1<CustomAttribute> custom_attributes)
private int RangesSize(Range[] ranges)
public Byte[] ReadCustomAttributeBlob(UInt32 signature)
public void ReadCustomAttributeSignature(CustomAttribute attribute)
private void InitializeMarshalInfos()
public bool HasMarshalInfo(IMarshalInfoProvider owner)
public MarshalInfo ReadMarshalInfo(IMarshalInfoProvider owner)
private void InitializeSecurityDeclarations()
public bool HasSecurityDeclarations(ISecurityDeclarationProvider owner)
public Collection`1<SecurityDeclaration> ReadSecurityDeclarations(ISecurityDeclarationProvider owner)
private void ReadSecurityDeclarationRange(Range range, Collection`1<SecurityDeclaration> security_declarations)
public Byte[] ReadSecurityDeclarationBlob(UInt32 signature)
public void ReadSecurityDeclarationSignature(SecurityDeclaration declaration)
private void ReadXmlSecurityDeclaration(UInt32 signature, SecurityDeclaration declaration)
public Collection`1<ExportedType> ReadExportedTypes()
private IMetadataScope GetExportedTypeScope(MetadataToken token)
private ModuleReference GetModuleReferenceFromFile(MetadataToken token)
private void InitializeCollection(object o)
private MetadataToken <InitializeGenericParameters>b__110_0()
private MetadataToken <InitializeCustomAttributes>b__142_0()
private MetadataToken <InitializeSecurityDeclarations>b__152_0()
}
public Mono.Cecil.MetadataResolver : object {
private IAssemblyResolver assembly_resolver
public IAssemblyResolver AssemblyResolver
public IAssemblyResolver get_AssemblyResolver()
public void .ctor(IAssemblyResolver assemblyResolver)
public TypeDefinition Resolve(TypeReference type)
private TypeDefinition GetType(ModuleDefinition module, TypeReference reference)
private TypeDefinition GetTypeDefinition(ModuleDefinition module, TypeReference type)
public FieldDefinition Resolve(FieldReference field)
private FieldDefinition GetField(TypeDefinition type, FieldReference reference)
private FieldDefinition GetField(Collection`1<FieldDefinition> fields, FieldReference reference)
public MethodDefinition Resolve(MethodReference method)
private MethodDefinition GetMethod(TypeDefinition type, MethodReference reference)
public MethodDefinition GetMethod(Collection`1<MethodDefinition> methods, MethodReference reference)
private bool AreSame(Collection`1<ParameterDefinition> a, Collection`1<ParameterDefinition> b)
private bool AreSame(TypeSpecification a, TypeSpecification b)
private bool AreSame(ArrayType a, ArrayType b)
private bool AreSame(IModifierType a, IModifierType b)
private bool AreSame(GenericInstanceType a, GenericInstanceType b)
private bool AreSame(GenericParameter a, GenericParameter b)
private bool AreSame(TypeReference a, TypeReference b)
}
public Mono.Cecil.MetadataScopeType : Enum {
public int value__
public MetadataScopeType AssemblyNameReference
public MetadataScopeType ModuleReference
public MetadataScopeType ModuleDefinition
}
internal Mono.Cecil.MetadataSystem : object {
internal AssemblyNameReference[] AssemblyReferences
internal ModuleReference[] ModuleReferences
internal TypeDefinition[] Types
internal TypeReference[] TypeReferences
internal FieldDefinition[] Fields
internal MethodDefinition[] Methods
internal MemberReference[] MemberReferences
internal Dictionary`2<UInt32, UInt32[]> NestedTypes
internal Dictionary`2<UInt32, UInt32> ReverseNestedTypes
internal Dictionary`2<UInt32, MetadataToken[]> Interfaces
internal Dictionary`2<UInt32, Row`2<ushort, UInt32>> ClassLayouts
internal Dictionary`2<UInt32, UInt32> FieldLayouts
internal Dictionary`2<UInt32, UInt32> FieldRVAs
internal Dictionary`2<MetadataToken, UInt32> FieldMarshals
internal Dictionary`2<MetadataToken, Row`2<ElementType, UInt32>> Constants
internal Dictionary`2<UInt32, MetadataToken[]> Overrides
internal Dictionary`2<MetadataToken, Range[]> CustomAttributes
internal Dictionary`2<MetadataToken, Range[]> SecurityDeclarations
internal Dictionary`2<UInt32, Range> Events
internal Dictionary`2<UInt32, Range> Properties
internal Dictionary`2<UInt32, Row`2<MethodSemanticsAttributes, MetadataToken>> Semantics
internal Dictionary`2<UInt32, Row`3<PInvokeAttributes, UInt32, UInt32>> PInvokes
internal Dictionary`2<MetadataToken, Range[]> GenericParameters
internal Dictionary`2<UInt32, MetadataToken[]> GenericConstraints
private Dictionary`2<string, Row`2<ElementType, bool>> primitive_value_types
private void InitializePrimitives()
public void TryProcessPrimitiveTypeReference(TypeReference type)
public bool TryGetPrimitiveElementType(TypeDefinition type, ElementType& etype)
private bool TryGetPrimitiveData(TypeReference type, Row`2& primitive_data)
public void Clear()
public TypeDefinition GetTypeDefinition(UInt32 rid)
public void AddTypeDefinition(TypeDefinition type)
public TypeReference GetTypeReference(UInt32 rid)
public void AddTypeReference(TypeReference type)
public FieldDefinition GetFieldDefinition(UInt32 rid)
public void AddFieldDefinition(FieldDefinition field)
public MethodDefinition GetMethodDefinition(UInt32 rid)
public void AddMethodDefinition(MethodDefinition method)
public MemberReference GetMemberReference(UInt32 rid)
public void AddMemberReference(MemberReference member)
public bool TryGetNestedTypeMapping(TypeDefinition type, UInt32[]& mapping)
public void SetNestedTypeMapping(UInt32 type_rid, UInt32[] mapping)
public void RemoveNestedTypeMapping(TypeDefinition type)
public bool TryGetReverseNestedTypeMapping(TypeDefinition type, UInt32& declaring)
public void SetReverseNestedTypeMapping(UInt32 nested, UInt32 declaring)
public void RemoveReverseNestedTypeMapping(TypeDefinition type)
public bool TryGetInterfaceMapping(TypeDefinition type, MetadataToken[]& mapping)
public void SetInterfaceMapping(UInt32 type_rid, MetadataToken[] mapping)
public void RemoveInterfaceMapping(TypeDefinition type)
public void AddPropertiesRange(UInt32 type_rid, Range range)
public bool TryGetPropertiesRange(TypeDefinition type, Range& range)
public void RemovePropertiesRange(TypeDefinition type)
public void AddEventsRange(UInt32 type_rid, Range range)
public bool TryGetEventsRange(TypeDefinition type, Range& range)
public void RemoveEventsRange(TypeDefinition type)
public bool TryGetGenericParameterRanges(IGenericParameterProvider owner, Range[]& ranges)
public void RemoveGenericParameterRange(IGenericParameterProvider owner)
public bool TryGetCustomAttributeRanges(ICustomAttributeProvider owner, Range[]& ranges)
public void RemoveCustomAttributeRange(ICustomAttributeProvider owner)
public bool TryGetSecurityDeclarationRanges(ISecurityDeclarationProvider owner, Range[]& ranges)
public void RemoveSecurityDeclarationRange(ISecurityDeclarationProvider owner)
public bool TryGetGenericConstraintMapping(GenericParameter generic_parameter, MetadataToken[]& mapping)
public void SetGenericConstraintMapping(UInt32 gp_rid, MetadataToken[] mapping)
public void RemoveGenericConstraintMapping(GenericParameter generic_parameter)
public bool TryGetOverrideMapping(MethodDefinition method, MetadataToken[]& mapping)
public void SetOverrideMapping(UInt32 rid, MetadataToken[] mapping)
public void RemoveOverrideMapping(MethodDefinition method)
public TypeDefinition GetFieldDeclaringType(UInt32 field_rid)
public TypeDefinition GetMethodDeclaringType(UInt32 method_rid)
private TypeDefinition BinaryRangeSearch(TypeDefinition[] types, UInt32 rid, bool field)
}
internal Mono.Cecil.MetadataTable : object {
public int Length
public bool IsLarge
public int get_Length()
public bool get_IsLarge()
public void Write(TableHeapBuffer buffer)
public void Sort()
}
internal Mono.Cecil.MetadataTable`1 : MetadataTable {
internal TRow[] rows
internal int length
public int Length
public int get_Length()
public int AddRow(TRow row)
private void Grow()
public void Sort()
}
public Mono.Cecil.MetadataToken : ValueType {
private UInt32 token
public MetadataToken Zero
public UInt32 RID
public TokenType TokenType
public UInt32 get_RID()
public TokenType get_TokenType()
public void .ctor(UInt32 token)
public void .ctor(TokenType type)
public void .ctor(TokenType type, UInt32 rid)
public void .ctor(TokenType type, int rid)
public int ToInt32()
public UInt32 ToUInt32()
public int GetHashCode()
public bool Equals(object obj)
public bool op_Equality(MetadataToken one, MetadataToken other)
public bool op_Inequality(MetadataToken one, MetadataToken other)
public string ToString()
}
public Mono.Cecil.MetadataType : Enum {
public byte value__
public MetadataType Void
public MetadataType Boolean
public MetadataType Char
public MetadataType SByte
public MetadataType Byte
public MetadataType Int16
public MetadataType UInt16
public MetadataType Int32
public MetadataType UInt32
public MetadataType Int64
public MetadataType UInt64
public MetadataType Single
public MetadataType Double
public MetadataType String
public MetadataType Pointer
public MetadataType ByReference
public MetadataType ValueType
public MetadataType Class
public MetadataType Var
public MetadataType Array
public MetadataType GenericInstance
public MetadataType TypedByReference
public MetadataType IntPtr
public MetadataType UIntPtr
public MetadataType FunctionPointer
public MetadataType Object
public MetadataType MVar
public MetadataType RequiredModifier
public MetadataType OptionalModifier
public MetadataType Sentinel
public MetadataType Pinned
}
public Mono.Cecil.MethodAttributes : Enum {
public ushort value__
public MethodAttributes MemberAccessMask
public MethodAttributes CompilerControlled
public MethodAttributes Private
public MethodAttributes FamANDAssem
public MethodAttributes Assembly
public MethodAttributes Family
public MethodAttributes FamORAssem
public MethodAttributes Public
public MethodAttributes Static
public MethodAttributes Final
public MethodAttributes Virtual
public MethodAttributes HideBySig
public MethodAttributes VtableLayoutMask
public MethodAttributes ReuseSlot
public MethodAttributes NewSlot
public MethodAttributes CheckAccessOnOverride
public MethodAttributes Abstract
public MethodAttributes SpecialName
public MethodAttributes PInvokeImpl
public MethodAttributes UnmanagedExport
public MethodAttributes RTSpecialName
public MethodAttributes HasSecurity
public MethodAttributes RequireSecObject
}
public Mono.Cecil.MethodCallingConvention : Enum {
public byte value__
public MethodCallingConvention Default
public MethodCallingConvention C
public MethodCallingConvention StdCall
public MethodCallingConvention ThisCall
public MethodCallingConvention FastCall
public MethodCallingConvention VarArg
public MethodCallingConvention Generic
}
public Mono.Cecil.MethodDefinition : MethodReference {
private ushort attributes
private ushort impl_attributes
internal Boolean modreq(System.Runtime.CompilerServices.IsVolatile) sem_attrs_ready
internal MethodSemanticsAttributes sem_attrs
private Collection`1<CustomAttribute> custom_attributes
private Collection`1<SecurityDeclaration> security_declarations
internal UInt32 rva
internal PInvokeInfo pinvoke
private Collection`1<MethodReference> overrides
internal MethodBody body
public MethodAttributes Attributes
public MethodImplAttributes ImplAttributes
public MethodSemanticsAttributes SemanticsAttributes
public bool HasSecurityDeclarations
public Collection`1<SecurityDeclaration> SecurityDeclarations
public bool HasCustomAttributes
public Collection`1<CustomAttribute> CustomAttributes
public int RVA
public bool HasBody
public MethodBody Body
public bool HasPInvokeInfo
public PInvokeInfo PInvokeInfo
public bool HasOverrides
public Collection`1<MethodReference> Overrides
public bool HasGenericParameters
public Collection`1<GenericParameter> GenericParameters
public bool IsCompilerControlled
public bool IsPrivate
public bool IsFamilyAndAssembly
public bool IsAssembly
public bool IsFamily
public bool IsFamilyOrAssembly
public bool IsPublic
public bool IsStatic
public bool IsFinal
public bool IsVirtual
public bool IsHideBySig
public bool IsReuseSlot
public bool IsNewSlot
public bool IsCheckAccessOnOverride
public bool IsAbstract
public bool IsSpecialName
public bool IsPInvokeImpl
public bool IsUnmanagedExport
public bool IsRuntimeSpecialName
public bool HasSecurity
public bool IsIL
public bool IsNative
public bool IsRuntime
public bool IsUnmanaged
public bool IsManaged
public bool IsForwardRef
public bool IsPreserveSig
public bool IsInternalCall
public bool IsSynchronized
public bool NoInlining
public bool NoOptimization
public bool IsSetter
public bool IsGetter
public bool IsOther
public bool IsAddOn
public bool IsRemoveOn
public bool IsFire
public TypeDefinition DeclaringType
public bool IsConstructor
public bool IsDefinition
public MethodAttributes get_Attributes()
public void set_Attributes(MethodAttributes value)
public MethodImplAttributes get_ImplAttributes()
public void set_ImplAttributes(MethodImplAttributes value)
public MethodSemanticsAttributes get_SemanticsAttributes()
public void set_SemanticsAttributes(MethodSemanticsAttributes value)
internal void ReadSemantics()
public bool get_HasSecurityDeclarations()
public Collection`1<SecurityDeclaration> get_SecurityDeclarations()
public bool get_HasCustomAttributes()
public Collection`1<CustomAttribute> get_CustomAttributes()
public int get_RVA()
public bool get_HasBody()
public MethodBody get_Body()
public void set_Body(MethodBody value)
public bool get_HasPInvokeInfo()
public PInvokeInfo get_PInvokeInfo()
public void set_PInvokeInfo(PInvokeInfo value)
public bool get_HasOverrides()
public Collection`1<MethodReference> get_Overrides()
public bool get_HasGenericParameters()
public Collection`1<GenericParameter> get_GenericParameters()
public bool get_IsCompilerControlled()
public void set_IsCompilerControlled(bool value)
public bool get_IsPrivate()
public void set_IsPrivate(bool value)
public bool get_IsFamilyAndAssembly()
public void set_IsFamilyAndAssembly(bool value)
public bool get_IsAssembly()
public void set_IsAssembly(bool value)
public bool get_IsFamily()
public void set_IsFamily(bool value)
public bool get_IsFamilyOrAssembly()
public void set_IsFamilyOrAssembly(bool value)
public bool get_IsPublic()
public void set_IsPublic(bool value)
public bool get_IsStatic()
public void set_IsStatic(bool value)
public bool get_IsFinal()
public void set_IsFinal(bool value)
public bool get_IsVirtual()
public void set_IsVirtual(bool value)
public bool get_IsHideBySig()
public void set_IsHideBySig(bool value)
public bool get_IsReuseSlot()
public void set_IsReuseSlot(bool value)
public bool get_IsNewSlot()
public void set_IsNewSlot(bool value)
public bool get_IsCheckAccessOnOverride()
public void set_IsCheckAccessOnOverride(bool value)
public bool get_IsAbstract()
public void set_IsAbstract(bool value)
public bool get_IsSpecialName()
public void set_IsSpecialName(bool value)
public bool get_IsPInvokeImpl()
public void set_IsPInvokeImpl(bool value)
public bool get_IsUnmanagedExport()
public void set_IsUnmanagedExport(bool value)
public bool get_IsRuntimeSpecialName()
public void set_IsRuntimeSpecialName(bool value)
public bool get_HasSecurity()
public void set_HasSecurity(bool value)
public bool get_IsIL()
public void set_IsIL(bool value)
public bool get_IsNative()
public void set_IsNative(bool value)
public bool get_IsRuntime()
public void set_IsRuntime(bool value)
public bool get_IsUnmanaged()
public void set_IsUnmanaged(bool value)
public bool get_IsManaged()
public void set_IsManaged(bool value)
public bool get_IsForwardRef()
public void set_IsForwardRef(bool value)
public bool get_IsPreserveSig()
public void set_IsPreserveSig(bool value)
public bool get_IsInternalCall()
public void set_IsInternalCall(bool value)
public bool get_IsSynchronized()
public void set_IsSynchronized(bool value)
public bool get_NoInlining()
public void set_NoInlining(bool value)
public bool get_NoOptimization()
public void set_NoOptimization(bool value)
public bool get_IsSetter()
public void set_IsSetter(bool value)
public bool get_IsGetter()
public void set_IsGetter(bool value)
public bool get_IsOther()
public void set_IsOther(bool value)
public bool get_IsAddOn()
public void set_IsAddOn(bool value)
public bool get_IsRemoveOn()
public void set_IsRemoveOn(bool value)
public bool get_IsFire()
public void set_IsFire(bool value)
public TypeDefinition get_DeclaringType()
public void set_DeclaringType(TypeDefinition value)
public bool get_IsConstructor()
public bool get_IsDefinition()
public void .ctor(string name, MethodAttributes attributes, TypeReference returnType)
public MethodDefinition Resolve()
}
public Mono.Cecil.MethodImplAttributes : Enum {
public ushort value__
public MethodImplAttributes CodeTypeMask
public MethodImplAttributes IL
public MethodImplAttributes Native
public MethodImplAttributes OPTIL
public MethodImplAttributes Runtime
public MethodImplAttributes ManagedMask
public MethodImplAttributes Unmanaged
public MethodImplAttributes Managed
public MethodImplAttributes ForwardRef
public MethodImplAttributes PreserveSig
public MethodImplAttributes InternalCall
public MethodImplAttributes Synchronized
public MethodImplAttributes NoOptimization
public MethodImplAttributes NoInlining
}
internal Mono.Cecil.MethodImplTable : MetadataTable`1<Row`3<UInt32, UInt32, UInt32>> {
public void Write(TableHeapBuffer buffer)
}
public Mono.Cecil.MethodReference : MemberReference {
internal ParameterDefinitionCollection parameters
private MethodReturnType return_type
private bool has_this
private bool explicit_this
private MethodCallingConvention calling_convention
internal Collection`1<GenericParameter> generic_parameters
public bool HasThis
public bool ExplicitThis
public MethodCallingConvention CallingConvention
public bool HasParameters
public Collection`1<ParameterDefinition> Parameters
private IGenericParameterProvider Mono.Cecil.IGenericContext.Type
private IGenericParameterProvider Mono.Cecil.IGenericContext.Method
private GenericParameterType Mono.Cecil.IGenericParameterProvider.GenericParameterType
public bool HasGenericParameters
public Collection`1<GenericParameter> GenericParameters
public TypeReference ReturnType
public MethodReturnType MethodReturnType
public string FullName
public bool IsGenericInstance
public bool ContainsGenericParameter
public bool get_HasThis()
public void set_HasThis(bool value)
public bool get_ExplicitThis()
public void set_ExplicitThis(bool value)
public MethodCallingConvention get_CallingConvention()
public void set_CallingConvention(MethodCallingConvention value)
public bool get_HasParameters()
public Collection`1<ParameterDefinition> get_Parameters()
private IGenericParameterProvider Mono.Cecil.IGenericContext.get_Type()
private IGenericParameterProvider Mono.Cecil.IGenericContext.get_Method()
private GenericParameterType Mono.Cecil.IGenericParameterProvider.get_GenericParameterType()
public bool get_HasGenericParameters()
public Collection`1<GenericParameter> get_GenericParameters()
public TypeReference get_ReturnType()
public void set_ReturnType(TypeReference value)
public MethodReturnType get_MethodReturnType()
public void set_MethodReturnType(MethodReturnType value)
public string get_FullName()
public bool get_IsGenericInstance()
public bool get_ContainsGenericParameter()
public void .ctor(string name, TypeReference returnType)
public void .ctor(string name, TypeReference returnType, TypeReference declaringType)
public MethodReference GetElementMethod()
public MethodDefinition Resolve()
}
public Mono.Cecil.MethodReturnType : object {
internal IMethodSignature method
internal ParameterDefinition parameter
private TypeReference return_type
public IMethodSignature Method
public TypeReference ReturnType
internal ParameterDefinition Parameter
public MetadataToken MetadataToken
public ParameterAttributes Attributes
public bool HasCustomAttributes
public Collection`1<CustomAttribute> CustomAttributes
public bool HasDefault
public bool HasConstant
public object Constant
public bool HasFieldMarshal
public bool HasMarshalInfo
public MarshalInfo MarshalInfo
public IMethodSignature get_Method()
public TypeReference get_ReturnType()
public void set_ReturnType(TypeReference value)
internal ParameterDefinition get_Parameter()
public MetadataToken get_MetadataToken()
public void set_MetadataToken(MetadataToken value)
public ParameterAttributes get_Attributes()
public void set_Attributes(ParameterAttributes value)
public bool get_HasCustomAttributes()
public Collection`1<CustomAttribute> get_CustomAttributes()
public bool get_HasDefault()
public void set_HasDefault(bool value)
public bool get_HasConstant()
public void set_HasConstant(bool value)
public object get_Constant()
public void set_Constant(object value)
public bool get_HasFieldMarshal()
public void set_HasFieldMarshal(bool value)
public bool get_HasMarshalInfo()
public MarshalInfo get_MarshalInfo()
public void set_MarshalInfo(MarshalInfo value)
public void .ctor(IMethodSignature method)
}
public Mono.Cecil.MethodSemanticsAttributes : Enum {
public ushort value__
public MethodSemanticsAttributes None
public MethodSemanticsAttributes Setter
public MethodSemanticsAttributes Getter
public MethodSemanticsAttributes Other
public MethodSemanticsAttributes AddOn
public MethodSemanticsAttributes RemoveOn
public MethodSemanticsAttributes Fire
}
internal Mono.Cecil.MethodSemanticsTable : SortedTable`1<Row`3<MethodSemanticsAttributes, UInt32, UInt32>> {
public void Write(TableHeapBuffer buffer)
public int Compare(Row`3<MethodSemanticsAttributes, UInt32, UInt32> x, Row`3<MethodSemanticsAttributes, UInt32, UInt32> y)
}
public Mono.Cecil.MethodSpecification : MethodReference {
private MethodReference method
public MethodReference ElementMethod
public string Name
public MethodCallingConvention CallingConvention
public bool HasThis
public bool ExplicitThis
public MethodReturnType MethodReturnType
public TypeReference DeclaringType
public ModuleDefinition Module
public bool HasParameters
public Collection`1<ParameterDefinition> Parameters
public bool ContainsGenericParameter
public MethodReference get_ElementMethod()
public string get_Name()
public void set_Name(string value)
public MethodCallingConvention get_CallingConvention()
public void set_CallingConvention(MethodCallingConvention value)
public bool get_HasThis()
public void set_HasThis(bool value)
public bool get_ExplicitThis()
public void set_ExplicitThis(bool value)
public MethodReturnType get_MethodReturnType()
public void set_MethodReturnType(MethodReturnType value)
public TypeReference get_DeclaringType()
public void set_DeclaringType(TypeReference value)
public ModuleDefinition get_Module()
public bool get_HasParameters()
public Collection`1<ParameterDefinition> get_Parameters()
public bool get_ContainsGenericParameter()
internal void .ctor(MethodReference method)
public MethodReference GetElementMethod()
}
internal Mono.Cecil.MethodSpecTable : MetadataTable`1<Row`2<UInt32, UInt32>> {
public void Write(TableHeapBuffer buffer)
}
internal Mono.Cecil.MethodTable : MetadataTable`1<Row`6<UInt32, MethodImplAttributes, MethodAttributes, UInt32, UInt32, UInt32>> {
public void Write(TableHeapBuffer buffer)
}
internal Mono.Cecil.Mixin : object {
internal object NoValue
internal object NotResolved
public int NotResolvedMarker
public int NoDataMarker
public UInt32 ReadCompressedUInt32(Byte[] data, Int32& position)
public MetadataToken GetMetadataToken(CodedIndex self, UInt32 data)
public UInt32 CompressMetadataToken(CodedIndex self, MetadataToken token)
public int GetSize(CodedIndex self, Func`2<Table, int> counter)
public bool GetHasSecurityDeclarations(ISecurityDeclarationProvider self, ModuleDefinition module)
public Collection`1<SecurityDeclaration> GetSecurityDeclarations(ISecurityDeclarationProvider self, Collection`1& variable, ModuleDefinition module)
public void CheckName(string name)
public void ResolveConstant(IConstantProvider self, Object& constant, ModuleDefinition module)
public bool GetHasCustomAttributes(ICustomAttributeProvider self, ModuleDefinition module)
public Collection`1<CustomAttribute> GetCustomAttributes(ICustomAttributeProvider self, Collection`1& variable, ModuleDefinition module)
public bool ContainsGenericParameter(IGenericInstance self)
public void GenericInstanceFullName(IGenericInstance self, StringBuilder builder)
public bool GetHasGenericParameters(IGenericParameterProvider self, ModuleDefinition module)
public Collection`1<GenericParameter> GetGenericParameters(IGenericParameterProvider self, Collection`1& collection, ModuleDefinition module)
public bool GetHasMarshalInfo(IMarshalInfoProvider self, ModuleDefinition module)
public MarshalInfo GetMarshalInfo(IMarshalInfoProvider self, MarshalInfo& variable, ModuleDefinition module)
public void CheckModifier(TypeReference modifierType, TypeReference type)
public bool HasImplicitThis(IMethodSignature self)
public void MethodSignatureFullName(IMethodSignature self, StringBuilder builder)
public bool GetAttributes(UInt32 self, UInt32 attributes)
public UInt32 SetAttributes(UInt32 self, UInt32 attributes, bool value)
public bool GetMaskedAttributes(UInt32 self, UInt32 mask, UInt32 attributes)
public UInt32 SetMaskedAttributes(UInt32 self, UInt32 mask, UInt32 attributes, bool value)
public bool GetAttributes(ushort self, ushort attributes)
public ushort SetAttributes(ushort self, ushort attributes, bool value)
public bool GetMaskedAttributes(ushort self, ushort mask, UInt32 attributes)
public ushort SetMaskedAttributes(ushort self, ushort mask, UInt32 attributes, bool value)
public ParameterDefinition GetParameter(MethodBody self, int index)
public VariableDefinition GetVariable(MethodBody self, int index)
public bool GetSemantics(MethodDefinition self, MethodSemanticsAttributes semantics)
public void SetSemantics(MethodDefinition self, MethodSemanticsAttributes semantics, bool value)
public bool IsVarArg(IMethodSignature self)
public int GetSentinelPosition(IMethodSignature self)
public void CheckParameters(object parameters)
public bool HasImage(ModuleDefinition self)
public bool IsCorlib(ModuleDefinition module)
public string GetFullyQualifiedName(Stream self)
public TargetRuntime ParseRuntime(string self)
public string RuntimeVersionString(TargetRuntime runtime)
public TypeReference GetEnumUnderlyingType(TypeDefinition self)
public TypeDefinition GetNestedType(TypeDefinition self, string fullname)
public bool IsPrimitive(ElementType self)
public string TypeFullName(TypeReference self)
public bool IsTypeOf(TypeReference self, string namespace, string name)
public bool IsTypeSpecification(TypeReference type)
public TypeDefinition CheckedResolve(TypeReference self)
public void CheckType(TypeReference type)
public RSA CreateRSA(StrongNameKeyPair key_pair)
private bool TryGetKeyContainer(ISerializable key_pair, Byte[]& key, String& key_container)
public bool IsNullOrEmpty(T[] self)
public bool IsNullOrEmpty(Collection`1<T> self)
public T[] Resize(T[] self, int length)
}
public Mono.Cecil.ModuleAttributes : Enum {
public int value__
public ModuleAttributes ILOnly
public ModuleAttributes Required32Bit
public ModuleAttributes StrongNameSigned
public ModuleAttributes Preferred32Bit
}
public Mono.Cecil.ModuleCharacteristics : Enum {
public int value__
public ModuleCharacteristics HighEntropyVA
public ModuleCharacteristics DynamicBase
public ModuleCharacteristics NoSEH
public ModuleCharacteristics NXCompat
public ModuleCharacteristics AppContainer
public ModuleCharacteristics TerminalServerAware
}
public Mono.Cecil.ModuleDefinition : ModuleReference {
internal Image Image
internal MetadataSystem MetadataSystem
internal ReadingMode ReadingMode
internal ISymbolReaderProvider SymbolReaderProvider
internal ISymbolReader symbol_reader
internal IAssemblyResolver assembly_resolver
internal IMetadataResolver metadata_resolver
internal TypeSystem type_system
private MetadataReader reader
private string fq_name
internal string runtime_version
internal ModuleKind kind
private TargetRuntime runtime
private TargetArchitecture architecture
private ModuleAttributes attributes
private ModuleCharacteristics characteristics
private Guid mvid
internal AssemblyDefinition assembly
private MethodDefinition entry_point
private MetadataImporter importer
private Collection`1<CustomAttribute> custom_attributes
private Collection`1<AssemblyNameReference> references
private Collection`1<ModuleReference> modules
private Collection`1<Resource> resources
private Collection`1<ExportedType> exported_types
private TypeDefinitionCollection types
private object module_lock
public bool IsMain
public ModuleKind Kind
public TargetRuntime Runtime
public string RuntimeVersion
public TargetArchitecture Architecture
public ModuleAttributes Attributes
public ModuleCharacteristics Characteristics
public string FullyQualifiedName
public Guid Mvid
internal bool HasImage
public bool HasSymbols
public ISymbolReader SymbolReader
public MetadataScopeType MetadataScopeType
public AssemblyDefinition Assembly
internal MetadataImporter MetadataImporter
public IAssemblyResolver AssemblyResolver
public IMetadataResolver MetadataResolver
public TypeSystem TypeSystem
public bool HasAssemblyReferences
public Collection`1<AssemblyNameReference> AssemblyReferences
public bool HasModuleReferences
public Collection`1<ModuleReference> ModuleReferences
public bool HasResources
public Collection`1<Resource> Resources
public bool HasCustomAttributes
public Collection`1<CustomAttribute> CustomAttributes
public bool HasTypes
public Collection`1<TypeDefinition> Types
public bool HasExportedTypes
public Collection`1<ExportedType> ExportedTypes
public MethodDefinition EntryPoint
internal object SyncRoot
public bool HasDebugHeader
public bool get_IsMain()
public ModuleKind get_Kind()
public void set_Kind(ModuleKind value)
public TargetRuntime get_Runtime()
public void set_Runtime(TargetRuntime value)
public string get_RuntimeVersion()
public void set_RuntimeVersion(string value)
public TargetArchitecture get_Architecture()
public void set_Architecture(TargetArchitecture value)
public ModuleAttributes get_Attributes()
public void set_Attributes(ModuleAttributes value)
public ModuleCharacteristics get_Characteristics()
public void set_Characteristics(ModuleCharacteristics value)
public string get_FullyQualifiedName()
public Guid get_Mvid()
public void set_Mvid(Guid value)
internal bool get_HasImage()
public bool get_HasSymbols()
public ISymbolReader get_SymbolReader()
public MetadataScopeType get_MetadataScopeType()
public AssemblyDefinition get_Assembly()
internal MetadataImporter get_MetadataImporter()
public IAssemblyResolver get_AssemblyResolver()
public IMetadataResolver get_MetadataResolver()
public TypeSystem get_TypeSystem()
public bool get_HasAssemblyReferences()
public Collection`1<AssemblyNameReference> get_AssemblyReferences()
public bool get_HasModuleReferences()
public Collection`1<ModuleReference> get_ModuleReferences()
public bool get_HasResources()
public Collection`1<Resource> get_Resources()
public bool get_HasCustomAttributes()
public Collection`1<CustomAttribute> get_CustomAttributes()
public bool get_HasTypes()
public Collection`1<TypeDefinition> get_Types()
public bool get_HasExportedTypes()
public Collection`1<ExportedType> get_ExportedTypes()
public MethodDefinition get_EntryPoint()
public void set_EntryPoint(MethodDefinition value)
internal void .ctor(Image image)
public bool HasTypeReference(string fullName)
public bool HasTypeReference(string scope, string fullName)
public bool TryGetTypeReference(string fullName, TypeReference& type)
public bool TryGetTypeReference(string scope, string fullName, TypeReference& type)
private TypeReference GetTypeReference(string scope, string fullname)
public IEnumerable`1<TypeReference> GetTypeReferences()
public IEnumerable`1<MemberReference> GetMemberReferences()
public TypeReference GetType(string fullName, bool runtimeName)
public TypeDefinition GetType(string fullName)
public TypeDefinition GetType(string namespace, string name)
public IEnumerable`1<TypeDefinition> GetTypes()
private IEnumerable`1<TypeDefinition> GetTypes(Collection`1<TypeDefinition> types)
private void CheckFullName(string fullName)
private TypeDefinition GetNestedType(string fullname)
internal FieldDefinition Resolve(FieldReference field)
internal MethodDefinition Resolve(MethodReference method)
internal TypeDefinition Resolve(TypeReference type)
private void CheckType(object type)
private void CheckField(object field)
private void CheckMethod(object method)
private void CheckContext(IGenericParameterProvider context, ModuleDefinition module)
private ImportGenericContext GenericContextFor(IGenericParameterProvider context)
public TypeReference Import(Type type)
public TypeReference Import(Type type, IGenericParameterProvider context)
public FieldReference Import(FieldInfo field)
public FieldReference Import(FieldInfo field, IGenericParameterProvider context)
public MethodReference Import(MethodBase method)
public MethodReference Import(MethodBase method, IGenericParameterProvider context)
public TypeReference Import(TypeReference type)
public TypeReference Import(TypeReference type, IGenericParameterProvider context)
public FieldReference Import(FieldReference field)
public FieldReference Import(FieldReference field, IGenericParameterProvider context)
public MethodReference Import(MethodReference method)
public MethodReference Import(MethodReference method, IGenericParameterProvider context)
public IMetadataTokenProvider LookupToken(int token)
public IMetadataTokenProvider LookupToken(MetadataToken token)
internal object get_SyncRoot()
internal TRet Read(TItem item, Func`3<TItem, MetadataReader, TRet> read)
internal TRet Read(TRet& variable, TItem item, Func`3<TItem, MetadataReader, TRet> read)
public bool get_HasDebugHeader()
public ImageDebugDirectory GetDebugHeader(Byte[]& header)
private void ProcessDebugHeader()
public ModuleDefinition CreateModule(string name, ModuleKind kind)
public ModuleDefinition CreateModule(string name, ModuleParameters parameters)
private AssemblyNameDefinition CreateAssemblyName(string name)
public void ReadSymbols()
public void ReadSymbols(ISymbolReader reader)
public ModuleDefinition ReadModule(string fileName)
public ModuleDefinition ReadModule(Stream stream)
public ModuleDefinition ReadModule(string fileName, ReaderParameters parameters)
private void CheckStream(object stream)
public ModuleDefinition ReadModule(Stream stream, ReaderParameters parameters)
private Stream GetFileStream(string fileName, FileMode mode, FileAccess access, FileShare share)
public void Write(string fileName)
public void Write(Stream stream)
public void Write(string fileName, WriterParameters parameters)
public void Write(Stream stream, WriterParameters parameters)
}
public Mono.Cecil.ModuleKind : Enum {
public int value__
public ModuleKind Dll
public ModuleKind Console
public ModuleKind Windows
public ModuleKind NetModule
}
public Mono.Cecil.ModuleParameters : object {
private ModuleKind kind
private TargetRuntime runtime
private TargetArchitecture architecture
private IAssemblyResolver assembly_resolver
private IMetadataResolver metadata_resolver
public ModuleKind Kind
public TargetRuntime Runtime
public TargetArchitecture Architecture
public IAssemblyResolver AssemblyResolver
public IMetadataResolver MetadataResolver
public ModuleKind get_Kind()
public void set_Kind(ModuleKind value)
public TargetRuntime get_Runtime()
public void set_Runtime(TargetRuntime value)
public TargetArchitecture get_Architecture()
public void set_Architecture(TargetArchitecture value)
public IAssemblyResolver get_AssemblyResolver()
public void set_AssemblyResolver(IAssemblyResolver value)
public IMetadataResolver get_MetadataResolver()
public void set_MetadataResolver(IMetadataResolver value)
private TargetRuntime GetCurrentRuntime()
}
internal Mono.Cecil.ModuleReader : object {
protected Image image
protected ModuleDefinition module
protected void .ctor(Image image, ReadingMode mode)
protected void ReadModule()
protected void ReadModuleManifest(MetadataReader reader)
private void ReadAssembly(MetadataReader reader)
public ModuleDefinition CreateModuleFrom(Image image, ReaderParameters parameters)
private void ReadSymbols(ModuleDefinition module, ReaderParameters parameters)
private ModuleReader CreateModuleReader(Image image, ReadingMode mode)
}
public Mono.Cecil.ModuleReference : object {
private string name
internal MetadataToken token
public string Name
public MetadataScopeType MetadataScopeType
public MetadataToken MetadataToken
public string get_Name()
public void set_Name(string value)
public MetadataScopeType get_MetadataScopeType()
public MetadataToken get_MetadataToken()
public void set_MetadataToken(MetadataToken value)
public void .ctor(string name)
public string ToString()
}
internal Mono.Cecil.ModuleRefTable : MetadataTable`1<UInt32> {
public void Write(TableHeapBuffer buffer)
}
internal Mono.Cecil.ModuleTable : OneRowTable`1<UInt32> {
public void Write(TableHeapBuffer buffer)
}
internal Mono.Cecil.ModuleWriter : object {
public void WriteModuleTo(ModuleDefinition module, Stream stream, WriterParameters parameters)
private void BuildMetadata(ModuleDefinition module, MetadataBuilder metadata)
private ISymbolWriter GetSymbolWriter(ModuleDefinition module, string fq_name, ISymbolWriterProvider symbol_writer_provider)
}
public Mono.Cecil.NativeType : Enum {
public int value__
public NativeType None
public NativeType Boolean
public NativeType I1
public NativeType U1
public NativeType I2
public NativeType U2
public NativeType I4
public NativeType U4
public NativeType I8
public NativeType U8
public NativeType R4
public NativeType R8
public NativeType LPStr
public NativeType Int
public NativeType UInt
public NativeType Func
public NativeType Array
public NativeType Currency
public NativeType BStr
public NativeType LPWStr
public NativeType LPTStr
public NativeType FixedSysString
public NativeType IUnknown
public NativeType IDispatch
public NativeType Struct
public NativeType IntF
public NativeType SafeArray
public NativeType FixedArray
public NativeType ByValStr
public NativeType ANSIBStr
public NativeType TBStr
public NativeType VariantBool
public NativeType ASAny
public NativeType LPStruct
public NativeType CustomMarshaler
public NativeType Error
public NativeType Max
}
internal Mono.Cecil.NestedClassTable : SortedTable`1<Row`2<UInt32, UInt32>> {
public void Write(TableHeapBuffer buffer)
public int Compare(Row`2<UInt32, UInt32> x, Row`2<UInt32, UInt32> y)
}
internal Mono.Cecil.OneRowTable`1 : MetadataTable {
internal TRow row
public int Length
public int get_Length()
public void Sort()
}
public Mono.Cecil.OptionalModifierType : TypeSpecification {
private TypeReference modifier_type
public TypeReference ModifierType
public string Name
public string FullName
private string Suffix
public bool IsValueType
public bool IsOptionalModifier
public bool ContainsGenericParameter
public TypeReference get_ModifierType()
public void set_ModifierType(TypeReference value)
public string get_Name()
public string get_FullName()
private string get_Suffix()
public bool get_IsValueType()
public void set_IsValueType(bool value)
public bool get_IsOptionalModifier()
public bool get_ContainsGenericParameter()
public void .ctor(TypeReference modifierType, TypeReference type)
}
public Mono.Cecil.ParameterAttributes : Enum {
public ushort value__
public ParameterAttributes None
public ParameterAttributes In
public ParameterAttributes Out
public ParameterAttributes Lcid
public ParameterAttributes Retval
public ParameterAttributes Optional
public ParameterAttributes HasDefault
public ParameterAttributes HasFieldMarshal
public ParameterAttributes Unused
}
public Mono.Cecil.ParameterDefinition : ParameterReference {
private ushort attributes
internal IMethodSignature method
private object constant
private Collection`1<CustomAttribute> custom_attributes
private MarshalInfo marshal_info
public ParameterAttributes Attributes
public IMethodSignature Method
public int Sequence
public bool HasConstant
public object Constant
public bool HasCustomAttributes
public Collection`1<CustomAttribute> CustomAttributes
public bool HasMarshalInfo
public MarshalInfo MarshalInfo
public bool IsIn
public bool IsOut
public bool IsLcid
public bool IsReturnValue
public bool IsOptional
public bool HasDefault
public bool HasFieldMarshal
public ParameterAttributes get_Attributes()
public void set_Attributes(ParameterAttributes value)
public IMethodSignature get_Method()
public int get_Sequence()
public bool get_HasConstant()
public void set_HasConstant(bool value)
public object get_Constant()
public void set_Constant(object value)
public bool get_HasCustomAttributes()
public Collection`1<CustomAttribute> get_CustomAttributes()
public bool get_HasMarshalInfo()
public MarshalInfo get_MarshalInfo()
public void set_MarshalInfo(MarshalInfo value)
public bool get_IsIn()
public void set_IsIn(bool value)
public bool get_IsOut()
public void set_IsOut(bool value)
public bool get_IsLcid()
public void set_IsLcid(bool value)
public bool get_IsReturnValue()
public void set_IsReturnValue(bool value)
public bool get_IsOptional()
public void set_IsOptional(bool value)
public bool get_HasDefault()
public void set_HasDefault(bool value)
public bool get_HasFieldMarshal()
public void set_HasFieldMarshal(bool value)
internal void .ctor(TypeReference parameterType, IMethodSignature method)
public void .ctor(TypeReference parameterType)
public void .ctor(string name, ParameterAttributes attributes, TypeReference parameterType)
public ParameterDefinition Resolve()
}
internal Mono.Cecil.ParameterDefinitionCollection : Collection`1<ParameterDefinition> {
private IMethodSignature method
internal void .ctor(IMethodSignature method)
internal void .ctor(IMethodSignature method, int capacity)
protected void OnAdd(ParameterDefinition item, int index)
protected void OnInsert(ParameterDefinition item, int index)
protected void OnSet(ParameterDefinition item, int index)
protected void OnRemove(ParameterDefinition item, int index)
}
public Mono.Cecil.ParameterReference : object {
private string name
internal int index
protected TypeReference parameter_type
internal MetadataToken token
public string Name
public int Index
public TypeReference ParameterType
public MetadataToken MetadataToken
public string get_Name()
public void set_Name(string value)
public int get_Index()
public TypeReference get_ParameterType()
public void set_ParameterType(TypeReference value)
public MetadataToken get_MetadataToken()
public void set_MetadataToken(MetadataToken value)
internal void .ctor(string name, TypeReference parameterType)
public string ToString()
public ParameterDefinition Resolve()
}
internal Mono.Cecil.ParamTable : MetadataTable`1<Row`3<ParameterAttributes, ushort, UInt32>> {
public void Write(TableHeapBuffer buffer)
}
internal Mono.Cecil.PE.BinaryStreamReader : BinaryReader {
public void .ctor(Stream stream)
protected void Advance(int bytes)
protected DataDirectory ReadDataDirectory()
}
internal Mono.Cecil.PE.BinaryStreamWriter : BinaryWriter {
public void .ctor(Stream stream)
public void WriteByte(byte value)
public void WriteUInt16(ushort value)
public void WriteInt16(short value)
public void WriteUInt32(UInt32 value)
public void WriteInt32(int value)
public void WriteUInt64(ulong value)
public void WriteBytes(Byte[] bytes)
public void WriteDataDirectory(DataDirectory directory)
public void WriteBuffer(ByteBuffer buffer)
protected void Advance(int bytes)
}
internal Mono.Cecil.PE.ByteBuffer : object {
internal Byte[] buffer
internal int length
internal int position
public void .ctor(int length)
public void .ctor(Byte[] buffer)
public void Reset(Byte[] buffer)
public void Advance(int length)
public byte ReadByte()
public sbyte ReadSByte()
public Byte[] ReadBytes(int length)
public ushort ReadUInt16()
public short ReadInt16()
public UInt32 ReadUInt32()
public int ReadInt32()
public ulong ReadUInt64()
public long ReadInt64()
public UInt32 ReadCompressedUInt32()
public int ReadCompressedInt32()
public float ReadSingle()
public double ReadDouble()
public void WriteByte(byte value)
public void WriteSByte(sbyte value)
public void WriteUInt16(ushort value)
public void WriteInt16(short value)
public void WriteUInt32(UInt32 value)
public void WriteInt32(int value)
public void WriteUInt64(ulong value)
public void WriteInt64(long value)
public void WriteCompressedUInt32(UInt32 value)
public void WriteCompressedInt32(int value)
public void WriteBytes(Byte[] bytes)
public void WriteBytes(int length)
public void WriteBytes(ByteBuffer buffer)
public void WriteSingle(float value)
public void WriteDouble(double value)
private void Grow(int desired)
}
internal Mono.Cecil.PE.ByteBufferEqualityComparer : object {
public bool Equals(ByteBuffer x, ByteBuffer y)
public int GetHashCode(ByteBuffer buffer)
}
internal Mono.Cecil.PE.DataDirectory : ValueType {
public UInt32 VirtualAddress
public UInt32 Size
public bool IsZero
public bool get_IsZero()
public void .ctor(UInt32 rva, UInt32 size)
}
internal Mono.Cecil.PE.Image : object {
public ModuleKind Kind
public string RuntimeVersion
public TargetArchitecture Architecture
public ModuleCharacteristics Characteristics
public string FileName
public Section[] Sections
public Section MetadataSection
public UInt32 EntryPointToken
public ModuleAttributes Attributes
public DataDirectory Debug
public DataDirectory Resources
public DataDirectory StrongName
public StringHeap StringHeap
public BlobHeap BlobHeap
public UserStringHeap UserStringHeap
public GuidHeap GuidHeap
public TableHeap TableHeap
private Int32[] coded_index_sizes
private Func`2<Table, int> counter
public bool HasTable(Table table)
public int GetTableLength(Table table)
public int GetTableIndexSize(Table table)
public int GetCodedIndexSize(CodedIndex coded_index)
public UInt32 ResolveVirtualAddress(UInt32 rva)
public UInt32 ResolveVirtualAddressInSection(UInt32 rva, Section section)
public Section GetSection(string name)
public Section GetSectionAtVirtualAddress(UInt32 rva)
public ImageDebugDirectory GetDebugHeader(Byte[]& header)
}
internal Mono.Cecil.PE.ImageReader : BinaryStreamReader {
private Image image
private DataDirectory cli
private DataDirectory metadata
public void .ctor(Stream stream)
private void MoveTo(DataDirectory directory)
private void MoveTo(UInt32 position)
private void ReadImage()
private TargetArchitecture ReadArchitecture()
private ModuleKind GetModuleKind(ushort characteristics, ushort subsystem)
private void ReadOptionalHeaders(UInt16& subsystem, UInt16& dll_characteristics)
private string ReadAlignedString(int length)
private string ReadZeroTerminatedString(int length)
private void ReadSections(ushort count)
private void ReadSectionData(Section section)
private void ReadCLIHeader()
private void ReadMetadata()
private void ReadMetadataStream(Section section)
private void ReadTableHeap()
private void SetIndexSize(Heap heap, UInt32 sizes, byte flag)
private int GetTableIndexSize(Table table)
private int GetCodedIndexSize(CodedIndex index)
private void ComputeTableInformations()
public Image ReadImageFrom(Stream stream)
}
internal Mono.Cecil.PE.ImageWriter : BinaryStreamWriter {
private ModuleDefinition module
private MetadataBuilder metadata
private TextMap text_map
private ImageDebugDirectory debug_directory
private Byte[] debug_data
private ByteBuffer win32_resources
private UInt32 pe_header_size
private UInt32 section_header_size
private UInt32 file_alignment
private UInt32 section_alignment
private ulong image_base
internal UInt32 text_rva
private bool pe64
private bool has_reloc
private UInt32 time_stamp
internal Section text
internal Section rsrc
internal Section reloc
private ushort sections
private void .ctor(ModuleDefinition module, MetadataBuilder metadata, Stream stream)
private void GetDebugHeader()
private void GetWin32Resources()
private Section GetImageResourceSection()
public ImageWriter CreateWriter(ModuleDefinition module, MetadataBuilder metadata, Stream stream)
private void BuildSections()
private Section CreateSection(string name, UInt32 size, Section previous)
private UInt32 Align(UInt32 value, UInt32 align)
private void WriteDOSHeader()
private ushort SizeOfOptionalHeader()
private void WritePEFileHeader()
private ushort GetMachine()
private Section LastSection()
private void WriteOptionalHeaders()
private void WriteZeroDataDirectory()
private ushort GetSubSystem()
private void WriteSectionHeaders()
private void WriteSection(Section section, UInt32 characteristics)
private void MoveTo(UInt32 pointer)
private void MoveToRVA(Section section, UInt32 rva)
private void MoveToRVA(TextSegment segment)
private void WriteRVA(UInt32 rva)
private void PrepareSection(Section section)
private void WriteText()
private UInt32 GetMetadataLength()
private void WriteMetadataHeader()
private ushort GetStreamCount()
private void WriteStreamHeader(UInt32& offset, TextSegment heap, string name)
private Byte[] GetZeroTerminatedString(string string)
private Byte[] GetSimpleString(string string)
private Byte[] GetString(string string, int length)
private void WriteMetadata()
private void WriteHeap(TextSegment heap, HeapBuffer buffer)
private void WriteGuidHeap()
private void WriteDebugDirectory()
private void WriteImportDirectory()
private Byte[] GetRuntimeMain()
private void WriteStartupStub()
private void WriteRsrc()
private void WriteReloc()
public void WriteImage()
private TextMap BuildTextMap()
private UInt32 GetStartupStubLength()
private int GetMetadataHeaderLength()
private int GetStrongNameLength()
public DataDirectory GetStrongNameSignatureDirectory()
public UInt32 GetHeaderSize()
private void PatchWin32Resources(ByteBuffer resources)
private void PatchResourceDirectoryTable(ByteBuffer resources)
private void PatchResourceDirectoryEntry(ByteBuffer resources)
private void PatchResourceDataEntry(ByteBuffer resources)
}
internal Mono.Cecil.PE.Section : object {
public string Name
public UInt32 VirtualAddress
public UInt32 VirtualSize
public UInt32 SizeOfRawData
public UInt32 PointerToRawData
public Byte[] Data
}
internal Mono.Cecil.PE.TextMap : object {
private Range[] map
public void AddMap(TextSegment segment, int length)
public void AddMap(TextSegment segment, int length, int align)
public void AddMap(TextSegment segment, Range range)
public Range GetRange(TextSegment segment)
public DataDirectory GetDataDirectory(TextSegment segment)
public UInt32 GetRVA(TextSegment segment)
public UInt32 GetNextRVA(TextSegment segment)
public int GetLength(TextSegment segment)
private UInt32 GetStart(TextSegment segment)
private UInt32 ComputeStart(int index)
public UInt32 GetLength()
}
internal Mono.Cecil.PE.TextSegment : Enum {
public int value__
public TextSegment ImportAddressTable
public TextSegment CLIHeader
public TextSegment Code
public TextSegment Resources
public TextSegment Data
public TextSegment StrongNameSignature
public TextSegment MetadataHeader
public TextSegment TableHeap
public TextSegment StringHeap
public TextSegment UserStringHeap
public TextSegment GuidHeap
public TextSegment BlobHeap
public TextSegment DebugDirectory
public TextSegment ImportDirectory
public TextSegment ImportHintNameTable
public TextSegment StartupStub
}
public Mono.Cecil.PinnedType : TypeSpecification {
public bool IsValueType
public bool IsPinned
public bool get_IsValueType()
public void set_IsValueType(bool value)
public bool get_IsPinned()
public void .ctor(TypeReference type)
}
public Mono.Cecil.PInvokeAttributes : Enum {
public ushort value__
public PInvokeAttributes NoMangle
public PInvokeAttributes CharSetMask
public PInvokeAttributes CharSetNotSpec
public PInvokeAttributes CharSetAnsi
public PInvokeAttributes CharSetUnicode
public PInvokeAttributes CharSetAuto
public PInvokeAttributes SupportsLastError
public PInvokeAttributes CallConvMask
public PInvokeAttributes CallConvWinapi
public PInvokeAttributes CallConvCdecl
public PInvokeAttributes CallConvStdCall
public PInvokeAttributes CallConvThiscall
public PInvokeAttributes CallConvFastcall
public PInvokeAttributes BestFitMask
public PInvokeAttributes BestFitEnabled
public PInvokeAttributes BestFitDisabled
public PInvokeAttributes ThrowOnUnmappableCharMask
public PInvokeAttributes ThrowOnUnmappableCharEnabled
public PInvokeAttributes ThrowOnUnmappableCharDisabled
}
public Mono.Cecil.PInvokeInfo : object {
private ushort attributes
private string entry_point
private ModuleReference module
public PInvokeAttributes Attributes
public string EntryPoint
public ModuleReference Module
public bool IsNoMangle
public bool IsCharSetNotSpec
public bool IsCharSetAnsi
public bool IsCharSetUnicode
public bool IsCharSetAuto
public bool SupportsLastError
public bool IsCallConvWinapi
public bool IsCallConvCdecl
public bool IsCallConvStdCall
public bool IsCallConvThiscall
public bool IsCallConvFastcall
public bool IsBestFitEnabled
public bool IsBestFitDisabled
public bool IsThrowOnUnmappableCharEnabled
public bool IsThrowOnUnmappableCharDisabled
public PInvokeAttributes get_Attributes()
public void set_Attributes(PInvokeAttributes value)
public string get_EntryPoint()
public void set_EntryPoint(string value)
public ModuleReference get_Module()
public void set_Module(ModuleReference value)
public bool get_IsNoMangle()
public void set_IsNoMangle(bool value)
public bool get_IsCharSetNotSpec()
public void set_IsCharSetNotSpec(bool value)
public bool get_IsCharSetAnsi()
public void set_IsCharSetAnsi(bool value)
public bool get_IsCharSetUnicode()
public void set_IsCharSetUnicode(bool value)
public bool get_IsCharSetAuto()
public void set_IsCharSetAuto(bool value)
public bool get_SupportsLastError()
public void set_SupportsLastError(bool value)
public bool get_IsCallConvWinapi()
public void set_IsCallConvWinapi(bool value)
public bool get_IsCallConvCdecl()
public void set_IsCallConvCdecl(bool value)
public bool get_IsCallConvStdCall()
public void set_IsCallConvStdCall(bool value)
public bool get_IsCallConvThiscall()
public void set_IsCallConvThiscall(bool value)
public bool get_IsCallConvFastcall()
public void set_IsCallConvFastcall(bool value)
public bool get_IsBestFitEnabled()
public void set_IsBestFitEnabled(bool value)
public bool get_IsBestFitDisabled()
public void set_IsBestFitDisabled(bool value)
public bool get_IsThrowOnUnmappableCharEnabled()
public void set_IsThrowOnUnmappableCharEnabled(bool value)
public bool get_IsThrowOnUnmappableCharDisabled()
public void set_IsThrowOnUnmappableCharDisabled(bool value)
public void .ctor(PInvokeAttributes attributes, string entryPoint, ModuleReference module)
}
public Mono.Cecil.PointerType : TypeSpecification {
public string Name
public string FullName
public bool IsValueType
public bool IsPointer
public string get_Name()
public string get_FullName()
public bool get_IsValueType()
public void set_IsValueType(bool value)
public bool get_IsPointer()
public void .ctor(TypeReference type)
}
public Mono.Cecil.PropertyAttributes : Enum {
public ushort value__
public PropertyAttributes None
public PropertyAttributes SpecialName
public PropertyAttributes RTSpecialName
public PropertyAttributes HasDefault
public PropertyAttributes Unused
}
public Mono.Cecil.PropertyDefinition : PropertyReference {
private Nullable`1<bool> has_this
private ushort attributes
private Collection`1<CustomAttribute> custom_attributes
internal MethodDefinition get_method
internal MethodDefinition set_method
internal Collection`1<MethodDefinition> other_methods
private object constant
public PropertyAttributes Attributes
public bool HasThis
public bool HasCustomAttributes
public Collection`1<CustomAttribute> CustomAttributes
public MethodDefinition GetMethod
public MethodDefinition SetMethod
public bool HasOtherMethods
public Collection`1<MethodDefinition> OtherMethods
public bool HasParameters
public Collection`1<ParameterDefinition> Parameters
public bool HasConstant
public object Constant
public bool IsSpecialName
public bool IsRuntimeSpecialName
public bool HasDefault
public TypeDefinition DeclaringType
public bool IsDefinition
public string FullName
public PropertyAttributes get_Attributes()
public void set_Attributes(PropertyAttributes value)
public bool get_HasThis()
public void set_HasThis(bool value)
public bool get_HasCustomAttributes()
public Collection`1<CustomAttribute> get_CustomAttributes()
public MethodDefinition get_GetMethod()
public void set_GetMethod(MethodDefinition value)
public MethodDefinition get_SetMethod()
public void set_SetMethod(MethodDefinition value)
public bool get_HasOtherMethods()
public Collection`1<MethodDefinition> get_OtherMethods()
public bool get_HasParameters()
public Collection`1<ParameterDefinition> get_Parameters()
private Collection`1<ParameterDefinition> MirrorParameters(MethodDefinition method, int bound)
public bool get_HasConstant()
public void set_HasConstant(bool value)
public object get_Constant()
public void set_Constant(object value)
public bool get_IsSpecialName()
public void set_IsSpecialName(bool value)
public bool get_IsRuntimeSpecialName()
public void set_IsRuntimeSpecialName(bool value)
public bool get_HasDefault()
public void set_HasDefault(bool value)
public TypeDefinition get_DeclaringType()
public void set_DeclaringType(TypeDefinition value)
public bool get_IsDefinition()
public string get_FullName()
public void .ctor(string name, PropertyAttributes attributes, TypeReference propertyType)
private void InitializeMethods()
public PropertyDefinition Resolve()
}
internal Mono.Cecil.PropertyMapTable : MetadataTable`1<Row`2<UInt32, UInt32>> {
public void Write(TableHeapBuffer buffer)
}
public Mono.Cecil.PropertyReference : MemberReference {
private TypeReference property_type
public TypeReference PropertyType
public Collection`1<ParameterDefinition> Parameters
public TypeReference get_PropertyType()
public void set_PropertyType(TypeReference value)
public Collection`1<ParameterDefinition> get_Parameters()
internal void .ctor(string name, TypeReference propertyType)
public PropertyDefinition Resolve()
}
internal Mono.Cecil.PropertyTable : MetadataTable`1<Row`3<PropertyAttributes, UInt32, UInt32>> {
public void Write(TableHeapBuffer buffer)
}
internal Mono.Cecil.Range : ValueType {
public UInt32 Start
public UInt32 Length
public void .ctor(UInt32 index, UInt32 length)
}
public Mono.Cecil.ReaderParameters : object {
private ReadingMode reading_mode
private IAssemblyResolver assembly_resolver
private IMetadataResolver metadata_resolver
private Stream symbol_stream
private ISymbolReaderProvider symbol_reader_provider
private bool read_symbols
public ReadingMode ReadingMode
public IAssemblyResolver AssemblyResolver
public IMetadataResolver MetadataResolver
public Stream SymbolStream
public ISymbolReaderProvider SymbolReaderProvider
public bool ReadSymbols
public ReadingMode get_ReadingMode()
public void set_ReadingMode(ReadingMode value)
public IAssemblyResolver get_AssemblyResolver()
public void set_AssemblyResolver(IAssemblyResolver value)
public IMetadataResolver get_MetadataResolver()
public void set_MetadataResolver(IMetadataResolver value)
public Stream get_SymbolStream()
public void set_SymbolStream(Stream value)
public ISymbolReaderProvider get_SymbolReaderProvider()
public void set_SymbolReaderProvider(ISymbolReaderProvider value)
public bool get_ReadSymbols()
public void set_ReadSymbols(bool value)
public void .ctor(ReadingMode readingMode)
}
public Mono.Cecil.ReadingMode : Enum {
public int value__
public ReadingMode Immediate
public ReadingMode Deferred
}
public Mono.Cecil.RequiredModifierType : TypeSpecification {
private TypeReference modifier_type
public TypeReference ModifierType
public string Name
public string FullName
private string Suffix
public bool IsValueType
public bool IsRequiredModifier
public bool ContainsGenericParameter
public TypeReference get_ModifierType()
public void set_ModifierType(TypeReference value)
public string get_Name()
public string get_FullName()
private string get_Suffix()
public bool get_IsValueType()
public void set_IsValueType(bool value)
public bool get_IsRequiredModifier()
public bool get_ContainsGenericParameter()
public void .ctor(TypeReference modifierType, TypeReference type)
}
public Mono.Cecil.ResolutionException : Exception {
private MemberReference member
public MemberReference Member
public IMetadataScope Scope
public MemberReference get_Member()
public IMetadataScope get_Scope()
public void .ctor(MemberReference member)
protected void .ctor(SerializationInfo info, StreamingContext context)
}
public Mono.Cecil.Resource : object {
private string name
private UInt32 attributes
public string Name
public ManifestResourceAttributes Attributes
public ResourceType ResourceType
public bool IsPublic
public bool IsPrivate
public string get_Name()
public void set_Name(string value)
public ManifestResourceAttributes get_Attributes()
public void set_Attributes(ManifestResourceAttributes value)
public ResourceType get_ResourceType()
public bool get_IsPublic()
public void set_IsPublic(bool value)
public bool get_IsPrivate()
public void set_IsPrivate(bool value)
internal void .ctor(string name, ManifestResourceAttributes attributes)
}
public Mono.Cecil.ResourceType : Enum {
public int value__
public ResourceType Linked
public ResourceType Embedded
public ResourceType AssemblyLinked
}
internal Mono.Cecil.Rocks.Functional : object {
public Func`2<A, R> Y(Func`2<Func`2<A, R>, Func`2<A, R>> f)
public IEnumerable`1<TSource> Prepend(IEnumerable`1<TSource> source, TSource element)
private IEnumerable`1<TSource> PrependIterator(IEnumerable`1<TSource> source, TSource element)
}
public Mono.Cecil.Rocks.IILVisitor {
public void OnInlineNone(OpCode opcode)
public void OnInlineSByte(OpCode opcode, sbyte value)
public void OnInlineByte(OpCode opcode, byte value)
public void OnInlineInt32(OpCode opcode, int value)
public void OnInlineInt64(OpCode opcode, long value)
public void OnInlineSingle(OpCode opcode, float value)
public void OnInlineDouble(OpCode opcode, double value)
public void OnInlineString(OpCode opcode, string value)
public void OnInlineBranch(OpCode opcode, int offset)
public void OnInlineSwitch(OpCode opcode, Int32[] offsets)
public void OnInlineVariable(OpCode opcode, VariableDefinition variable)
public void OnInlineArgument(OpCode opcode, ParameterDefinition parameter)
public void OnInlineSignature(OpCode opcode, CallSite callSite)
public void OnInlineType(OpCode opcode, TypeReference type)
public void OnInlineField(OpCode opcode, FieldReference field)
public void OnInlineMethod(OpCode opcode, MethodReference method)
}
public Mono.Cecil.Rocks.ILParser : object {
public void Parse(MethodDefinition method, IILVisitor visitor)
private ParseContext CreateContext(MethodDefinition method, IILVisitor visitor)
private void ParseFatMethod(ParseContext context)
private void ParseCode(int code_size, ParseContext context)
private VariableDefinition GetVariable(ParseContext context, int index)
}
public Mono.Cecil.Rocks.MethodBodyRocks : object {
public void SimplifyMacros(MethodBody self)
private void ExpandMacro(Instruction instruction, OpCode opcode, object operand)
private void MakeMacro(Instruction instruction, OpCode opcode)
public void OptimizeMacros(MethodBody self)
private void OptimizeBranches(MethodBody body)
private bool OptimizeBranch(Instruction instruction)
private void ComputeOffsets(MethodBody body)
}
public Mono.Cecil.Rocks.MethodDefinitionRocks : object {
public MethodDefinition GetBaseMethod(MethodDefinition self)
public MethodDefinition GetOriginalBaseMethod(MethodDefinition self)
private TypeDefinition ResolveBaseType(TypeDefinition type)
private MethodDefinition GetMatchingMethod(TypeDefinition type, MethodDefinition method)
}
public Mono.Cecil.Rocks.ModuleDefinitionRocks : object {
public IEnumerable`1<TypeDefinition> GetAllTypes(ModuleDefinition self)
}
public Mono.Cecil.Rocks.SecurityDeclarationRocks : object {
public PermissionSet ToPermissionSet(SecurityDeclaration self)
private bool TryProcessPermissionSetAttribute(SecurityDeclaration declaration, PermissionSet& set)
private PermissionSet CreatePermissionSet(SecurityDeclaration declaration)
private IPermission CreatePermission(SecurityDeclaration declaration, SecurityAttribute attribute)
private void CompleteSecurityAttribute(SecurityAttribute security_attribute, SecurityAttribute attribute)
private void CompleteSecurityAttributeFields(SecurityAttribute security_attribute, SecurityAttribute attribute)
private void CompleteSecurityAttributeProperties(SecurityAttribute security_attribute, SecurityAttribute attribute)
private SecurityAttribute CreateSecurityAttribute(Type attribute_type, SecurityDeclaration declaration)
public SecurityDeclaration ToSecurityDeclaration(PermissionSet self, SecurityAction action, ModuleDefinition module)
}
public Mono.Cecil.Rocks.TypeDefinitionRocks : object {
public IEnumerable`1<MethodDefinition> GetConstructors(TypeDefinition self)
public MethodDefinition GetStaticConstructor(TypeDefinition self)
public IEnumerable`1<MethodDefinition> GetMethods(TypeDefinition self)
public TypeReference GetEnumUnderlyingType(TypeDefinition self)
}
public Mono.Cecil.Rocks.TypeReferenceRocks : object {
public ArrayType MakeArrayType(TypeReference self)
public ArrayType MakeArrayType(TypeReference self, int rank)
public PointerType MakePointerType(TypeReference self)
public ByReferenceType MakeByReferenceType(TypeReference self)
public OptionalModifierType MakeOptionalModifierType(TypeReference self, TypeReference modifierType)
public RequiredModifierType MakeRequiredModifierType(TypeReference self, TypeReference modifierType)
public GenericInstanceType MakeGenericInstanceType(TypeReference self, TypeReference[] arguments)
public PinnedType MakePinnedType(TypeReference self)
public SentinelType MakeSentinelType(TypeReference self)
}
public Mono.Cecil.SafeArrayMarshalInfo : MarshalInfo {
internal VariantType element_type
public VariantType ElementType
public VariantType get_ElementType()
public void set_ElementType(VariantType value)
}
public Mono.Cecil.SecurityAction : Enum {
public ushort value__
public SecurityAction Request
public SecurityAction Demand
public SecurityAction Assert
public SecurityAction Deny
public SecurityAction PermitOnly
public SecurityAction LinkDemand
public SecurityAction InheritDemand
public SecurityAction RequestMinimum
public SecurityAction RequestOptional
public SecurityAction RequestRefuse
public SecurityAction PreJitGrant
public SecurityAction PreJitDeny
public SecurityAction NonCasDemand
public SecurityAction NonCasLinkDemand
public SecurityAction NonCasInheritance
}
public Mono.Cecil.SecurityAttribute : object {
private TypeReference attribute_type
internal Collection`1<CustomAttributeNamedArgument> fields
internal Collection`1<CustomAttributeNamedArgument> properties
public TypeReference AttributeType
public bool HasFields
public Collection`1<CustomAttributeNamedArgument> Fields
public bool HasProperties
public Collection`1<CustomAttributeNamedArgument> Properties
public TypeReference get_AttributeType()
public void set_AttributeType(TypeReference value)
public bool get_HasFields()
public Collection`1<CustomAttributeNamedArgument> get_Fields()
public bool get_HasProperties()
public Collection`1<CustomAttributeNamedArgument> get_Properties()
public void .ctor(TypeReference attributeType)
}
public Mono.Cecil.SecurityDeclaration : object {
internal UInt32 signature
private Byte[] blob
private ModuleDefinition module
internal bool resolved
private SecurityAction action
internal Collection`1<SecurityAttribute> security_attributes
public SecurityAction Action
public bool HasSecurityAttributes
public Collection`1<SecurityAttribute> SecurityAttributes
internal bool HasImage
public SecurityAction get_Action()
public void set_Action(SecurityAction value)
public bool get_HasSecurityAttributes()
public Collection`1<SecurityAttribute> get_SecurityAttributes()
internal bool get_HasImage()
internal void .ctor(SecurityAction action, UInt32 signature, ModuleDefinition module)
public void .ctor(SecurityAction action)
public void .ctor(SecurityAction action, Byte[] blob)
public Byte[] GetBlob()
private void Resolve()
private SecurityDeclaration <Resolve>b__19_0(SecurityDeclaration declaration, MetadataReader reader)
}
public Mono.Cecil.SentinelType : TypeSpecification {
public bool IsValueType
public bool IsSentinel
public bool get_IsValueType()
public void set_IsValueType(bool value)
public bool get_IsSentinel()
public void .ctor(TypeReference type)
}
internal Mono.Cecil.SignatureReader : ByteBuffer {
private MetadataReader reader
private UInt32 start
private UInt32 sig_length
private TypeSystem TypeSystem
private TypeSystem get_TypeSystem()
public void .ctor(UInt32 blob, MetadataReader reader)
private void MoveToBlob(UInt32 blob)
private MetadataToken ReadTypeTokenSignature()
private GenericParameter GetGenericParameter(GenericParameterType type, UInt32 var)
private GenericParameter GetUnboundGenericParameter(GenericParameterType type, int index)
private void CheckGenericContext(IGenericParameterProvider owner, int index)
public void ReadGenericInstanceSignature(IGenericParameterProvider provider, IGenericInstance instance)
private ArrayType ReadArrayTypeSignature()
private TypeReference GetTypeDefOrRef(MetadataToken token)
public TypeReference ReadTypeSignature()
private TypeReference ReadTypeSignature(ElementType etype)
public void ReadMethodSignature(IMethodSignature method)
public object ReadConstantSignature(ElementType type)
public void ReadCustomAttributeConstructorArguments(CustomAttribute attribute, Collection`1<ParameterDefinition> parameters)
private CustomAttributeArgument ReadCustomAttributeFixedArgument(TypeReference type)
public void ReadCustomAttributeNamedArguments(ushort count, Collection`1& fields, Collection`1& properties)
private void ReadCustomAttributeNamedArgument(Collection`1& fields, Collection`1& properties)
private Collection`1<CustomAttributeNamedArgument> GetCustomAttributeNamedArgumentCollection(Collection`1& collection)
private CustomAttributeArgument ReadCustomAttributeFixedArrayArgument(ArrayType type)
private CustomAttributeArgument ReadCustomAttributeElement(TypeReference type)
private object ReadCustomAttributeElementValue(TypeReference type)
private object ReadPrimitiveValue(ElementType type)
private TypeReference GetPrimitiveType(ElementType etype)
private TypeReference ReadCustomAttributeFieldOrPropType()
public TypeReference ReadTypeReference()
private object ReadCustomAttributeEnum(TypeReference enum_type)
public SecurityAttribute ReadSecurityAttribute()
public MarshalInfo ReadMarshalInfo()
private NativeType ReadNativeType()
private VariantType ReadVariantType()
private string ReadUTF8String()
public bool CanReadMore()
}
internal Mono.Cecil.SignatureWriter : ByteBuffer {
private MetadataBuilder metadata
public void .ctor(MetadataBuilder metadata)
public void WriteElementType(ElementType element_type)
public void WriteUTF8String(string string)
public void WriteMethodSignature(IMethodSignature method)
private UInt32 MakeTypeDefOrRefCodedRID(TypeReference type)
public void WriteTypeSignature(TypeReference type)
private void WriteArrayTypeSignature(ArrayType array)
public void WriteGenericInstanceSignature(IGenericInstance instance)
private void WriteModifierSignature(ElementType element_type, IModifierType type)
private bool TryWriteElementType(TypeReference type)
public void WriteConstantString(string value)
public void WriteConstantPrimitive(object value)
public void WriteCustomAttributeConstructorArguments(CustomAttribute attribute)
private void WriteCustomAttributeFixedArgument(TypeReference type, CustomAttributeArgument argument)
private void WriteCustomAttributeFixedArrayArgument(ArrayType type, CustomAttributeArgument argument)
private void WriteCustomAttributeElement(TypeReference type, CustomAttributeArgument argument)
private void WriteCustomAttributeValue(TypeReference type, object value)
private void WritePrimitiveValue(object value)
private void WriteCustomAttributeEnumValue(TypeReference enum_type, object value)
private void WriteCustomAttributeFieldOrPropType(TypeReference type)
public void WriteCustomAttributeNamedArguments(CustomAttribute attribute)
private int GetNamedArgumentCount(ICustomAttribute attribute)
private void WriteICustomAttributeNamedArguments(ICustomAttribute attribute)
private void WriteCustomAttributeNamedArguments(byte kind, Collection`1<CustomAttributeNamedArgument> named_arguments)
private void WriteCustomAttributeNamedArgument(byte kind, CustomAttributeNamedArgument named_argument)
private void WriteSecurityAttribute(SecurityAttribute attribute)
public void WriteSecurityDeclaration(SecurityDeclaration declaration)
public void WriteXmlSecurityDeclaration(SecurityDeclaration declaration)
private string GetXmlSecurityDeclaration(SecurityDeclaration declaration)
private void WriteTypeReference(TypeReference type)
public void WriteMarshalInfo(MarshalInfo marshal_info)
private void WriteNativeType(NativeType native)
private void WriteVariantType(VariantType variant)
}
internal Mono.Cecil.SortedTable`1 : MetadataTable`1<TRow> {
public void Sort()
protected int Compare(UInt32 x, UInt32 y)
public int Compare(TRow x, TRow y)
}
internal Mono.Cecil.StandAloneSigTable : MetadataTable`1<UInt32> {
public void Write(TableHeapBuffer buffer)
}
public Mono.Cecil.TargetArchitecture : Enum {
public int value__
public TargetArchitecture I386
public TargetArchitecture AMD64
public TargetArchitecture IA64
public TargetArchitecture ARMv7
}
public Mono.Cecil.TargetRuntime : Enum {
public int value__
public TargetRuntime Net_1_0
public TargetRuntime Net_1_1
public TargetRuntime Net_2_0
public TargetRuntime Net_4_0
}
public Mono.Cecil.TokenType : Enum {
public UInt32 value__
public TokenType Module
public TokenType TypeRef
public TokenType TypeDef
public TokenType Field
public TokenType Method
public TokenType Param
public TokenType InterfaceImpl
public TokenType MemberRef
public TokenType CustomAttribute
public TokenType Permission
public TokenType Signature
public TokenType Event
public TokenType Property
public TokenType ModuleRef
public TokenType TypeSpec
public TokenType Assembly
public TokenType AssemblyRef
public TokenType File
public TokenType ExportedType
public TokenType ManifestResource
public TokenType GenericParam
public TokenType MethodSpec
public TokenType String
}
public Mono.Cecil.TypeAttributes : Enum {
public UInt32 value__
public TypeAttributes VisibilityMask
public TypeAttributes NotPublic
public TypeAttributes Public
public TypeAttributes NestedPublic
public TypeAttributes NestedPrivate
public TypeAttributes NestedFamily
public TypeAttributes NestedAssembly
public TypeAttributes NestedFamANDAssem
public TypeAttributes NestedFamORAssem
public TypeAttributes LayoutMask
public TypeAttributes AutoLayout
public TypeAttributes SequentialLayout
public TypeAttributes ExplicitLayout
public TypeAttributes ClassSemanticMask
public TypeAttributes Class
public TypeAttributes Interface
public TypeAttributes Abstract
public TypeAttributes Sealed
public TypeAttributes SpecialName
public TypeAttributes Import
public TypeAttributes Serializable
public TypeAttributes WindowsRuntime
public TypeAttributes StringFormatMask
public TypeAttributes AnsiClass
public TypeAttributes UnicodeClass
public TypeAttributes AutoClass
public TypeAttributes BeforeFieldInit
public TypeAttributes RTSpecialName
public TypeAttributes HasSecurity
public TypeAttributes Forwarder
}
public Mono.Cecil.TypeDefinition : TypeReference {
private UInt32 attributes
private TypeReference base_type
internal Range fields_range
internal Range methods_range
private short packing_size
private int class_size
private Collection`1<TypeReference> interfaces
private Collection`1<TypeDefinition> nested_types
private Collection`1<MethodDefinition> methods
private Collection`1<FieldDefinition> fields
private Collection`1<EventDefinition> events
private Collection`1<PropertyDefinition> properties
private Collection`1<CustomAttribute> custom_attributes
private Collection`1<SecurityDeclaration> security_declarations
public TypeAttributes Attributes
public TypeReference BaseType
public bool HasLayoutInfo
public short PackingSize
public int ClassSize
public bool HasInterfaces
public Collection`1<TypeReference> Interfaces
public bool HasNestedTypes
public Collection`1<TypeDefinition> NestedTypes
public bool HasMethods
public Collection`1<MethodDefinition> Methods
public bool HasFields
public Collection`1<FieldDefinition> Fields
public bool HasEvents
public Collection`1<EventDefinition> Events
public bool HasProperties
public Collection`1<PropertyDefinition> Properties
public bool HasSecurityDeclarations
public Collection`1<SecurityDeclaration> SecurityDeclarations
public bool HasCustomAttributes
public Collection`1<CustomAttribute> CustomAttributes
public bool HasGenericParameters
public Collection`1<GenericParameter> GenericParameters
public bool IsNotPublic
public bool IsPublic
public bool IsNestedPublic
public bool IsNestedPrivate
public bool IsNestedFamily
public bool IsNestedAssembly
public bool IsNestedFamilyAndAssembly
public bool IsNestedFamilyOrAssembly
public bool IsAutoLayout
public bool IsSequentialLayout
public bool IsExplicitLayout
public bool IsClass
public bool IsInterface
public bool IsAbstract
public bool IsSealed
public bool IsSpecialName
public bool IsImport
public bool IsSerializable
public bool IsWindowsRuntime
public bool IsAnsiClass
public bool IsUnicodeClass
public bool IsAutoClass
public bool IsBeforeFieldInit
public bool IsRuntimeSpecialName
public bool HasSecurity
public bool IsEnum
public bool IsValueType
public bool IsPrimitive
public MetadataType MetadataType
public bool IsDefinition
public TypeDefinition DeclaringType
public TypeAttributes get_Attributes()
public void set_Attributes(TypeAttributes value)
public TypeReference get_BaseType()
public void set_BaseType(TypeReference value)
private void ResolveLayout()
public bool get_HasLayoutInfo()
public short get_PackingSize()
public void set_PackingSize(short value)
public int get_ClassSize()
public void set_ClassSize(int value)
public bool get_HasInterfaces()
public Collection`1<TypeReference> get_Interfaces()
public bool get_HasNestedTypes()
public Collection`1<TypeDefinition> get_NestedTypes()
public bool get_HasMethods()
public Collection`1<MethodDefinition> get_Methods()
public bool get_HasFields()
public Collection`1<FieldDefinition> get_Fields()
public bool get_HasEvents()
public Collection`1<EventDefinition> get_Events()
public bool get_HasProperties()
public Collection`1<PropertyDefinition> get_Properties()
public bool get_HasSecurityDeclarations()
public Collection`1<SecurityDeclaration> get_SecurityDeclarations()
public bool get_HasCustomAttributes()
public Collection`1<CustomAttribute> get_CustomAttributes()
public bool get_HasGenericParameters()
public Collection`1<GenericParameter> get_GenericParameters()
public bool get_IsNotPublic()
public void set_IsNotPublic(bool value)
public bool get_IsPublic()
public void set_IsPublic(bool value)
public bool get_IsNestedPublic()
public void set_IsNestedPublic(bool value)
public bool get_IsNestedPrivate()
public void set_IsNestedPrivate(bool value)
public bool get_IsNestedFamily()
public void set_IsNestedFamily(bool value)
public bool get_IsNestedAssembly()
public void set_IsNestedAssembly(bool value)
public bool get_IsNestedFamilyAndAssembly()
public void set_IsNestedFamilyAndAssembly(bool value)
public bool get_IsNestedFamilyOrAssembly()
public void set_IsNestedFamilyOrAssembly(bool value)
public bool get_IsAutoLayout()
public void set_IsAutoLayout(bool value)
public bool get_IsSequentialLayout()
public void set_IsSequentialLayout(bool value)
public bool get_IsExplicitLayout()
public void set_IsExplicitLayout(bool value)
public bool get_IsClass()
public void set_IsClass(bool value)
public bool get_IsInterface()
public void set_IsInterface(bool value)
public bool get_IsAbstract()
public void set_IsAbstract(bool value)
public bool get_IsSealed()
public void set_IsSealed(bool value)
public bool get_IsSpecialName()
public void set_IsSpecialName(bool value)
public bool get_IsImport()
public void set_IsImport(bool value)
public bool get_IsSerializable()
public void set_IsSerializable(bool value)
public bool get_IsWindowsRuntime()
public void set_IsWindowsRuntime(bool value)
public bool get_IsAnsiClass()
public void set_IsAnsiClass(bool value)
public bool get_IsUnicodeClass()
public void set_IsUnicodeClass(bool value)
public bool get_IsAutoClass()
public void set_IsAutoClass(bool value)
public bool get_IsBeforeFieldInit()
public void set_IsBeforeFieldInit(bool value)
public bool get_IsRuntimeSpecialName()
public void set_IsRuntimeSpecialName(bool value)
public bool get_HasSecurity()
public void set_HasSecurity(bool value)
public bool get_IsEnum()
public bool get_IsValueType()
public bool get_IsPrimitive()
public MetadataType get_MetadataType()
public bool get_IsDefinition()
public TypeDefinition get_DeclaringType()
public void set_DeclaringType(TypeDefinition value)
public void .ctor(string namespace, string name, TypeAttributes attributes)
public void .ctor(string namespace, string name, TypeAttributes attributes, TypeReference baseType)
public TypeDefinition Resolve()
}
internal Mono.Cecil.TypeDefinitionCollection : Collection`1<TypeDefinition> {
private ModuleDefinition container
private Dictionary`2<Row`2<string, string>, TypeDefinition> name_cache
internal void .ctor(ModuleDefinition container)
internal void .ctor(ModuleDefinition container, int capacity)
protected void OnAdd(TypeDefinition item, int index)
protected void OnSet(TypeDefinition item, int index)
protected void OnInsert(TypeDefinition item, int index)
protected void OnRemove(TypeDefinition item, int index)
protected void OnClear()
private void Attach(TypeDefinition type)
private void Detach(TypeDefinition type)
public TypeDefinition GetType(string fullname)
public TypeDefinition GetType(string namespace, string name)
}
internal Mono.Cecil.TypeDefTable : MetadataTable`1<Row`6<TypeAttributes, UInt32, UInt32, UInt32, UInt32, UInt32>> {
public void Write(TableHeapBuffer buffer)
}
internal Mono.Cecil.TypeParser : object {
private string fullname
private int length
private int position
private void .ctor(string fullname)
private Type ParseType(bool fq_name)
private bool TryGetArity(Type type)
private bool TryGetArity(string name, Int32& arity)
private bool ParseInt32(string value, Int32& result)
private void TryAddArity(string name, Int32& arity)
private string ParsePart()
private bool IsDelimiter(char chr)
private void TryParseWhiteSpace()
private String[] ParseNestedNames()
private bool TryParse(char chr)
private void Add(T[]& array, T item)
private Int32[] ParseSpecs()
private Type[] ParseGenericArguments(int arity)
private string ParseAssemblyName()
public TypeReference ParseType(ModuleDefinition module, string fullname)
private TypeReference GetTypeReference(ModuleDefinition module, Type type_info)
private TypeReference CreateSpecs(TypeReference type, Type type_info)
private TypeReference TryCreateGenericInstanceType(TypeReference type, Type type_info)
public void SplitFullName(string fullname, String& namespace, String& name)
private TypeReference CreateReference(Type type_info, ModuleDefinition module, IMetadataScope scope)
private void AdjustGenericParameters(TypeReference type)
private IMetadataScope GetMetadataScope(ModuleDefinition module, Type type_info)
private AssemblyNameReference MatchReference(ModuleDefinition module, AssemblyNameReference pattern)
private bool TryGetDefinition(ModuleDefinition module, Type type_info, TypeReference& type)
private bool TryCurrentModule(ModuleDefinition module, Type type_info)
public string ToParseable(TypeReference type)
private void AppendNamePart(string part, StringBuilder name)
private void AppendType(TypeReference type, StringBuilder name, bool fq_name, bool top_level)
private string GetScopeFullName(TypeReference type)
private void AppendTypeSpecification(TypeSpecification type, StringBuilder name)
private bool RequiresFullyQualifiedName(TypeReference type, bool top_level)
}
public Mono.Cecil.TypeReference : MemberReference {
private string namespace
private bool value_type
internal IMetadataScope scope
internal ModuleDefinition module
internal ElementType etype
private string fullname
protected Collection`1<GenericParameter> generic_parameters
public string Name
public string Namespace
public bool IsValueType
public ModuleDefinition Module
private IGenericParameterProvider Mono.Cecil.IGenericContext.Type
private IGenericParameterProvider Mono.Cecil.IGenericContext.Method
private GenericParameterType Mono.Cecil.IGenericParameterProvider.GenericParameterType
public bool HasGenericParameters
public Collection`1<GenericParameter> GenericParameters
public IMetadataScope Scope
public bool IsNested
public TypeReference DeclaringType
public string FullName
public bool IsByReference
public bool IsPointer
public bool IsSentinel
public bool IsArray
public bool IsGenericParameter
public bool IsGenericInstance
public bool IsRequiredModifier
public bool IsOptionalModifier
public bool IsPinned
public bool IsFunctionPointer
public bool IsPrimitive
public MetadataType MetadataType
public string get_Name()
public void set_Name(string value)
public string get_Namespace()
public void set_Namespace(string value)
public bool get_IsValueType()
public void set_IsValueType(bool value)
public ModuleDefinition get_Module()
private IGenericParameterProvider Mono.Cecil.IGenericContext.get_Type()
private IGenericParameterProvider Mono.Cecil.IGenericContext.get_Method()
private GenericParameterType Mono.Cecil.IGenericParameterProvider.get_GenericParameterType()
public bool get_HasGenericParameters()
public Collection`1<GenericParameter> get_GenericParameters()
public IMetadataScope get_Scope()
public void set_Scope(IMetadataScope value)
public bool get_IsNested()
public TypeReference get_DeclaringType()
public void set_DeclaringType(TypeReference value)
public string get_FullName()
public bool get_IsByReference()
public bool get_IsPointer()
public bool get_IsSentinel()
public bool get_IsArray()
public bool get_IsGenericParameter()
public bool get_IsGenericInstance()
public bool get_IsRequiredModifier()
public bool get_IsOptionalModifier()
public bool get_IsPinned()
public bool get_IsFunctionPointer()
public bool get_IsPrimitive()
public MetadataType get_MetadataType()
protected void .ctor(string namespace, string name)
public void .ctor(string namespace, string name, ModuleDefinition module, IMetadataScope scope)
public void .ctor(string namespace, string name, ModuleDefinition module, IMetadataScope scope, bool valueType)
public TypeReference GetElementType()
public TypeDefinition Resolve()
}
internal Mono.Cecil.TypeRefTable : MetadataTable`1<Row`3<UInt32, UInt32, UInt32>> {
public void Write(TableHeapBuffer buffer)
}
public Mono.Cecil.TypeSpecification : TypeReference {
private TypeReference element_type
public TypeReference ElementType
public string Name
public string Namespace
public IMetadataScope Scope
public ModuleDefinition Module
public string FullName
public bool ContainsGenericParameter
public MetadataType MetadataType
public TypeReference get_ElementType()
public string get_Name()
public void set_Name(string value)
public string get_Namespace()
public void set_Namespace(string value)
public IMetadataScope get_Scope()
public void set_Scope(IMetadataScope value)
public ModuleDefinition get_Module()
public string get_FullName()
public bool get_ContainsGenericParameter()
public MetadataType get_MetadataType()
internal void .ctor(TypeReference type)
public TypeReference GetElementType()
}
internal Mono.Cecil.TypeSpecTable : MetadataTable`1<UInt32> {
public void Write(TableHeapBuffer buffer)
}
public Mono.Cecil.TypeSystem : object {
private ModuleDefinition module
private TypeReference type_object
private TypeReference type_void
private TypeReference type_bool
private TypeReference type_char
private TypeReference type_sbyte
private TypeReference type_byte
private TypeReference type_int16
private TypeReference type_uint16
private TypeReference type_int32
private TypeReference type_uint32
private TypeReference type_int64
private TypeReference type_uint64
private TypeReference type_single
private TypeReference type_double
private TypeReference type_intptr
private TypeReference type_uintptr
private TypeReference type_string
private TypeReference type_typedref
public IMetadataScope Corlib
public TypeReference Object
public TypeReference Void
public TypeReference Boolean
public TypeReference Char
public TypeReference SByte
public TypeReference Byte
public TypeReference Int16
public TypeReference UInt16
public TypeReference Int32
public TypeReference UInt32
public TypeReference Int64
public TypeReference UInt64
public TypeReference Single
public TypeReference Double
public TypeReference IntPtr
public TypeReference UIntPtr
public TypeReference String
public TypeReference TypedReference
private void .ctor(ModuleDefinition module)
internal TypeSystem CreateTypeSystem(ModuleDefinition module)
internal TypeReference LookupType(string namespace, string name)
private TypeReference LookupSystemType(TypeReference& reference, string name, ElementType element_type)
private TypeReference LookupSystemValueType(TypeReference& typeRef, string name, ElementType element_type)
public IMetadataScope get_Corlib()
public TypeReference get_Object()
public TypeReference get_Void()
public TypeReference get_Boolean()
public TypeReference get_Char()
public TypeReference get_SByte()
public TypeReference get_Byte()
public TypeReference get_Int16()
public TypeReference get_UInt16()
public TypeReference get_Int32()
public TypeReference get_UInt32()
public TypeReference get_Int64()
public TypeReference get_UInt64()
public TypeReference get_Single()
public TypeReference get_Double()
public TypeReference get_IntPtr()
public TypeReference get_UIntPtr()
public TypeReference get_String()
public TypeReference get_TypedReference()
}
public Mono.Cecil.VariantType : Enum {
public int value__
public VariantType None
public VariantType I2
public VariantType I4
public VariantType R4
public VariantType R8
public VariantType CY
public VariantType Date
public VariantType BStr
public VariantType Dispatch
public VariantType Error
public VariantType Bool
public VariantType Variant
public VariantType Unknown
public VariantType Decimal
public VariantType I1
public VariantType UI1
public VariantType UI2
public VariantType UI4
public VariantType Int
public VariantType UInt
}
public Mono.Cecil.WriterParameters : object {
private Stream symbol_stream
private ISymbolWriterProvider symbol_writer_provider
private bool write_symbols
private StrongNameKeyPair key_pair
public Stream SymbolStream
public ISymbolWriterProvider SymbolWriterProvider
public bool WriteSymbols
public StrongNameKeyPair StrongNameKeyPair
public Stream get_SymbolStream()
public void set_SymbolStream(Stream value)
public ISymbolWriterProvider get_SymbolWriterProvider()
public void set_SymbolWriterProvider(ISymbolWriterProvider value)
public bool get_WriteSymbols()
public void set_WriteSymbols(bool value)
public StrongNameKeyPair get_StrongNameKeyPair()
public void set_StrongNameKeyPair(StrongNameKeyPair value)
}
public Mono.Collections.Generic.Collection`1 : object {
internal T[] items
internal int size
private int version
public int Count
public T Item
public int Capacity
private bool System.Collections.Generic.ICollection<T>.IsReadOnly
private bool System.Collections.IList.IsFixedSize
private bool System.Collections.IList.IsReadOnly
private object System.Collections.IList.Item
private int System.Collections.ICollection.Count
private bool System.Collections.ICollection.IsSynchronized
private object System.Collections.ICollection.SyncRoot
public int get_Count()
public T get_Item(int index)
public void set_Item(int index, T value)
public int get_Capacity()
public void set_Capacity(int value)
private bool System.Collections.Generic.ICollection<T>.get_IsReadOnly()
private bool System.Collections.IList.get_IsFixedSize()
private bool System.Collections.IList.get_IsReadOnly()
private object System.Collections.IList.get_Item(int index)
private void System.Collections.IList.set_Item(int index, object value)
private int System.Collections.ICollection.get_Count()
private bool System.Collections.ICollection.get_IsSynchronized()
private object System.Collections.ICollection.get_SyncRoot()
public void .ctor(int capacity)
public void .ctor(ICollection`1<T> items)
public void Add(T item)
public bool Contains(T item)
public int IndexOf(T item)
public void Insert(int index, T item)
public void RemoveAt(int index)
public bool Remove(T item)
public void Clear()
public void CopyTo(T[] array, int arrayIndex)
public T[] ToArray()
private void CheckIndex(int index)
private void Shift(int start, int delta)
protected void OnAdd(T item, int index)
protected void OnInsert(T item, int index)
protected void OnSet(T item, int index)
protected void OnRemove(T item, int index)
protected void OnClear()
internal void Grow(int desired)
protected void Resize(int new_size)
private int System.Collections.IList.Add(object value)
private void System.Collections.IList.Clear()
private bool System.Collections.IList.Contains(object value)
private int System.Collections.IList.IndexOf(object value)
private void System.Collections.IList.Insert(int index, object value)
private void System.Collections.IList.Remove(object value)
private void System.Collections.IList.RemoveAt(int index)
private void System.Collections.ICollection.CopyTo(Array array, int index)
public Enumerator<T> GetEnumerator()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
private IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator()
}
public Mono.Collections.Generic.ReadOnlyCollection`1 : Collection`1<T> {
private ReadOnlyCollection`1<T> empty
public ReadOnlyCollection`1<T> Empty
private bool System.Collections.Generic.ICollection<T>.IsReadOnly
private bool System.Collections.IList.IsFixedSize
private bool System.Collections.IList.IsReadOnly
public ReadOnlyCollection`1<T> get_Empty()
private bool System.Collections.Generic.ICollection<T>.get_IsReadOnly()
private bool System.Collections.IList.get_IsFixedSize()
private bool System.Collections.IList.get_IsReadOnly()
public void .ctor(T[] array)
public void .ctor(Collection`1<T> collection)
private void Initialize(T[] items, int size)
internal void Grow(int desired)
protected void OnAdd(T item, int index)
protected void OnClear()
protected void OnInsert(T item, int index)
protected void OnRemove(T item, int index)
protected void OnSet(T item, int index)
}
internal Mono.Empty`1 : object {
public T[] Array
}
public Mono.Posix.AccessMode : Enum {
public int value__
public AccessMode R_OK
public AccessMode W_OK
public AccessMode X_OK
public AccessMode F_OK
}
public Mono.Posix.Catalog : object {
private IntPtr bindtextdomain(IntPtr domainname, IntPtr dirname)
private IntPtr bind_textdomain_codeset(IntPtr domainname, IntPtr codeset)
private IntPtr textdomain(IntPtr domainname)
public void Init(string package, string localedir)
private IntPtr gettext(IntPtr instring)
public string GetString(string s)
private IntPtr ngettext(IntPtr singular, IntPtr plural, int n)
public string GetPluralString(string s, string p, int n)
}
public Mono.Posix.FileMode : Enum {
public int value__
public FileMode S_ISUID
public FileMode S_ISGID
public FileMode S_ISVTX
public FileMode S_IRUSR
public FileMode S_IWUSR
public FileMode S_IXUSR
public FileMode S_IRGRP
public FileMode S_IWGRP
public FileMode S_IXGRP
public FileMode S_IROTH
public FileMode S_IWOTH
public FileMode S_IXOTH
}
public Mono.Posix.OpenFlags : Enum {
public int value__
public OpenFlags O_RDONLY
public OpenFlags O_WRONLY
public OpenFlags O_RDWR
public OpenFlags O_CREAT
public OpenFlags O_EXCL
public OpenFlags O_NOCTTY
public OpenFlags O_TRUNC
public OpenFlags O_APPEND
public OpenFlags O_NONBLOCK
public OpenFlags O_SYNC
}
public Mono.Posix.PeerCred : object {
private int so_peercred
private PeerCredData data
public int ProcessID
public int UserID
public int GroupID
public void .ctor(Socket sock)
public int get_ProcessID()
public int get_UserID()
public int get_GroupID()
}
internal Mono.Posix.PeerCredData : ValueType {
public int pid
public int uid
public int gid
}
public Mono.Posix.Signals : Enum {
public int value__
public Signals SIGHUP
public Signals SIGINT
public Signals SIGQUIT
public Signals SIGILL
public Signals SIGTRAP
public Signals SIGABRT
public Signals SIGBUS
public Signals SIGFPE
public Signals SIGKILL
public Signals SIGUSR1
public Signals SIGSEGV
public Signals SIGUSR2
public Signals SIGPIPE
public Signals SIGALRM
public Signals SIGTERM
public Signals SIGCHLD
public Signals SIGCONT
public Signals SIGSTOP
public Signals SIGTSTP
public Signals SIGTTIN
public Signals SIGTTOU
public Signals SIGURG
public Signals SIGXCPU
public Signals SIGXFSZ
public Signals SIGVTALRM
public Signals SIGPROF
public Signals SIGWINCH
public Signals SIGIO
public Signals SIGSYS
}
public Mono.Posix.Stat : ValueType {
public int Device
public int INode
public StatMode Mode
public int NLinks
public int Uid
public int Gid
public long DeviceType
public long Size
public long BlockSize
public long Blocks
public DateTime ATime
public DateTime MTime
public DateTime CTime
public DateTime UnixEpoch
internal void .ctor(int device, int inode, int mode, int nlinks, int uid, int gid, int rdev, long size, long blksize, long blocks, long atime, long mtime, long ctime)
public DateTime UnixToDateTime(long unix)
}
public Mono.Posix.StatMode : Enum {
public int value__
public StatMode Socket
public StatMode SymLink
public StatMode Regular
public StatMode BlockDevice
public StatMode Directory
public StatMode CharDevice
public StatMode FIFO
public StatMode SUid
public StatMode SGid
public StatMode Sticky
public StatMode OwnerRead
public StatMode OwnerWrite
public StatMode OwnerExecute
public StatMode GroupRead
public StatMode GroupWrite
public StatMode GroupExecute
public StatMode OthersRead
public StatMode OthersWrite
public StatMode OthersExecute
}
public Mono.Posix.StatModeMasks : Enum {
public int value__
public StatModeMasks TypeMask
public StatModeMasks OwnerMask
public StatModeMasks GroupMask
public StatModeMasks OthersMask
}
public Mono.Posix.Syscall : object {
public int exit(int status)
public int fork()
public IntPtr read(int fileDescriptor, Void* buf, IntPtr count)
public IntPtr write(int fileDescriptor, Void* buf, IntPtr count)
internal int syscall_open(string pathname, int flags, int mode)
internal int map_Mono_Posix_OpenFlags(OpenFlags flags)
internal int map_Mono_Posix_FileMode(FileMode mode)
public int open(string pathname, OpenFlags flags)
public int open(string pathname, OpenFlags flags, FileMode mode)
public int close(int fileDescriptor)
internal int syscall_waitpid(int pid, Int32* status, int options)
internal int map_Mono_Posix_WaitOptions(WaitOptions wait_options)
public int waitpid(int pid, Int32& status, WaitOptions options)
public int waitpid(int pid, WaitOptions options)
public int WIFEXITED(int status)
public int WEXITSTATUS(int status)
public int WIFSIGNALED(int status)
public int WTERMSIG(int status)
public int WIFSTOPPED(int status)
public int WSTOPSIG(int status)
internal int syscall_creat(string pathname, int flags)
public int creat(string pathname, FileMode flags)
public int link(string oldPath, string newPath)
public int unlink(string path)
public int symlink(string oldpath, string newpath)
public int chdir(string path)
internal int syscall_chmod(string path, int mode)
public int chmod(string path, FileMode mode)
public int chown(string path, int owner, int group)
public int lchown(string path, int owner, int group)
public int lseek(int fileDescriptor, int offset, int whence)
public int getpid()
public int setuid(int uid)
public int getuid()
public UInt32 alarm(UInt32 seconds)
public int pause()
internal int syscall_access(string pathname, int mode)
internal int map_Mono_Posix_AccessMode(AccessMode mode)
public int access(string pathname, AccessMode mode)
public int nice(int increment)
public void sync()
public void kill(int pid, int sig)
public int rename(string oldPath, string newPath)
internal int syscall_mkdir(string pathname, int mode)
public int mkdir(string pathname, FileMode mode)
public int rmdir(string path)
public int dup(int fileDescriptor)
public int setgid(int gid)
public int getgid()
public int signal(int signum, sighandler_t handler)
public int geteuid()
public int getegid()
public int setpgid(int pid, int pgid)
public int umask(int umask)
public int chroot(string path)
public int dup2(int oldFileDescriptor, int newFileDescriptor)
public int getppid()
public int getpgrp()
public int setsid()
public int setreuid(int ruid, int euid)
public int setregid(int rgid, int egid)
private string helper_Mono_Posix_GetUserName(int uid)
private string helper_Mono_Posix_GetGroupName(int gid)
public string getusername(int uid)
public string getgroupname(int gid)
private int syscall_gethostname(Byte[] p, int len)
public string GetHostName()
public string gethostname()
private int syscall_isatty(int desc)
public bool isatty(int desc)
internal int helper_Mono_Posix_Stat(string filename, bool dereference, Int32& device, Int32& inode, Int32& mode, Int32& nlinks, Int32& uid, Int32& gid, Int32& rdev, Int64& size, Int64& blksize, Int64& blocks, Int64& atime, Int64& mtime, Int64& ctime)
private int stat2(string filename, bool dereference, Stat& stat)
public int stat(string filename, Stat& stat)
public int lstat(string filename, Stat& stat)
private int readlink(string path, Byte[] buffer, int buflen)
public string readlink(string path)
private IntPtr _strerror(int errnum)
public string strerror(int errnum)
public IntPtr opendir(string path)
public int closedir(IntPtr dir)
public string readdir(IntPtr dir)
}
public Mono.Posix.UnixEndPoint : EndPoint {
private string filename
public string Filename
public AddressFamily AddressFamily
public void .ctor(string filename)
public string get_Filename()
public void set_Filename(string value)
public AddressFamily get_AddressFamily()
public EndPoint Create(SocketAddress socketAddress)
public SocketAddress Serialize()
public string ToString()
public int GetHashCode()
public bool Equals(object o)
}
public Mono.Posix.WaitOptions : Enum {
public int value__
public WaitOptions WNOHANG
public WaitOptions WUNTRACED
}
internal Mono.Remoting.Channels.Unix.ClientConnection : object {
private Socket _client
private UnixServerTransportSink _sink
private Stream _stream
private UnixServerChannel _serverChannel
private Byte[] _buffer
public Socket Client
public Byte[] Buffer
public bool IsLocal
public void .ctor(UnixServerChannel serverChannel, Socket client, UnixServerTransportSink sink)
public Socket get_Client()
public Byte[] get_Buffer()
public void ProcessMessages()
public bool get_IsLocal()
}
internal Mono.Remoting.Channels.Unix.HostConnectionPool : object {
private ArrayList _pool
private int _activeConnections
private string _path
public void .ctor(string path)
public UnixConnection GetConnection()
private UnixConnection CreateConnection()
public void ReleaseConnection(UnixConnection entry)
private void CancelConnection(UnixConnection entry)
public void PurgeConnections()
}
internal Mono.Remoting.Channels.Unix.MessageStatus : Enum {
public int value__
public MessageStatus MethodMessage
public MessageStatus CancelSignal
public MessageStatus Unknown
}
internal Mono.Remoting.Channels.Unix.MethodCallHeaderHandler : object {
private string _uri
public void .ctor(string uri)
public object HandleHeaders(Header[] headers)
}
internal Mono.Remoting.Channels.Unix.ReusableUnixClient : UnixClient {
public bool IsAlive
public void .ctor(string path)
public bool get_IsAlive()
}
internal Mono.Remoting.Channels.Unix.SimpleBinder : SerializationBinder {
public SimpleBinder Instance
public Type BindToType(string assemblyName, string typeName)
}
internal Mono.Remoting.Channels.Unix.UnixBinaryClientFormatterSink : object {
private UnixBinaryCore _binaryCore
private IClientChannelSink _nextInChain
internal UnixBinaryCore BinaryCore
public IClientChannelSink NextChannelSink
public IMessageSink NextSink
public IDictionary Properties
public void .ctor(IClientChannelSink nextSink)
internal UnixBinaryCore get_BinaryCore()
internal void set_BinaryCore(UnixBinaryCore value)
public IClientChannelSink get_NextChannelSink()
public IMessageSink get_NextSink()
public IDictionary get_Properties()
public void AsyncProcessRequest(IClientChannelSinkStack sinkStack, IMessage msg, ITransportHeaders headers, Stream stream)
public void AsyncProcessResponse(IClientResponseChannelSinkStack sinkStack, object state, ITransportHeaders headers, Stream stream)
public Stream GetRequestStream(IMessage msg, ITransportHeaders headers)
public void ProcessMessage(IMessage msg, ITransportHeaders requestHeaders, Stream requestStream, ITransportHeaders& responseHeaders, Stream& responseStream)
public IMessageCtrl AsyncProcessMessage(IMessage msg, IMessageSink replySink)
public IMessage SyncProcessMessage(IMessage msg)
}
internal Mono.Remoting.Channels.Unix.UnixBinaryClientFormatterSinkProvider : object {
private IClientChannelSinkProvider next
private UnixBinaryCore _binaryCore
private String[] allowedProperties
public IClientChannelSinkProvider Next
public void .ctor(IDictionary properties, ICollection providerData)
public IClientChannelSinkProvider get_Next()
public void set_Next(IClientChannelSinkProvider value)
public IClientChannelSink CreateSink(IChannelSender channel, string url, object remoteChannelData)
}
internal Mono.Remoting.Channels.Unix.UnixBinaryCore : object {
private BinaryFormatter _serializationFormatter
private BinaryFormatter _deserializationFormatter
private bool _includeVersions
private bool _strictBinding
private IDictionary _properties
public UnixBinaryCore DefaultInstance
private Dictionary`2<string, int> <>f__switch$map0
public BinaryFormatter Serializer
public BinaryFormatter Deserializer
public IDictionary Properties
public void .ctor(object owner, IDictionary properties, String[] allowedProperties)
public void Init()
public BinaryFormatter get_Serializer()
public BinaryFormatter get_Deserializer()
public IDictionary get_Properties()
}
internal Mono.Remoting.Channels.Unix.UnixBinaryServerFormatterSink : object {
private UnixBinaryCore _binaryCore
private IServerChannelSink next_sink
private IChannelReceiver receiver
internal UnixBinaryCore BinaryCore
public IServerChannelSink NextChannelSink
public IDictionary Properties
public void .ctor(IServerChannelSink nextSink, IChannelReceiver receiver)
internal UnixBinaryCore get_BinaryCore()
internal void set_BinaryCore(UnixBinaryCore value)
public IServerChannelSink get_NextChannelSink()
public IDictionary get_Properties()
public void AsyncProcessResponse(IServerResponseChannelSinkStack sinkStack, object state, IMessage message, ITransportHeaders headers, Stream stream)
public Stream GetResponseStream(IServerResponseChannelSinkStack sinkStack, object state, IMessage msg, ITransportHeaders headers)
public ServerProcessing ProcessMessage(IServerChannelSinkStack sinkStack, IMessage requestMsg, ITransportHeaders requestHeaders, Stream requestStream, IMessage& responseMsg, ITransportHeaders& responseHeaders, Stream& responseStream)
}
internal Mono.Remoting.Channels.Unix.UnixBinaryServerFormatterSinkProvider : object {
private IServerChannelSinkProvider next
private UnixBinaryCore _binaryCore
internal String[] AllowedProperties
public IServerChannelSinkProvider Next
public void .ctor(IDictionary properties, ICollection providerData)
public IServerChannelSinkProvider get_Next()
public void set_Next(IServerChannelSinkProvider value)
public IServerChannelSink CreateSink(IChannelReceiver channel)
public void GetChannelData(IChannelDataStore channelData)
}
public Mono.Remoting.Channels.Unix.UnixChannel : object {
private UnixClientChannel _clientChannel
private UnixServerChannel _serverChannel
private string _name
private int _priority
public string ChannelName
public int ChannelPriority
public object ChannelData
public void .ctor(string path)
public void .ctor(IDictionary properties, IClientChannelSinkProvider clientSinkProvider, IServerChannelSinkProvider serverSinkProvider)
private void Init(IDictionary properties, IClientChannelSinkProvider clientSink, IServerChannelSinkProvider serverSink)
public IMessageSink CreateMessageSink(string url, object remoteChannelData, String& objectURI)
public string get_ChannelName()
public int get_ChannelPriority()
public void StartListening(object data)
public void StopListening(object data)
public String[] GetUrlsForUri(string uri)
public object get_ChannelData()
public string Parse(string url, String& objectURI)
internal string ParseUnixURL(string url, String& objectURI)
}
public Mono.Remoting.Channels.Unix.UnixClientChannel : object {
private int priority
private string name
private IClientChannelSinkProvider _sinkProvider
public string ChannelName
public int ChannelPriority
public void .ctor(IDictionary properties, IClientChannelSinkProvider sinkProvider)
public void .ctor(string name, IClientChannelSinkProvider sinkProvider)
public string get_ChannelName()
public int get_ChannelPriority()
public IMessageSink CreateMessageSink(string url, object remoteChannelData, String& objectURI)
public string Parse(string url, String& objectURI)
}
internal Mono.Remoting.Channels.Unix.UnixClientTransportSink : object {
private string _path
public IDictionary Properties
public IClientChannelSink NextChannelSink
public void .ctor(string url)
public IDictionary get_Properties()
public IClientChannelSink get_NextChannelSink()
public void AsyncProcessRequest(IClientChannelSinkStack sinkStack, IMessage msg, ITransportHeaders headers, Stream requestStream)
private void ReadAsyncUnixMessage(object data)
public void AsyncProcessResponse(IClientResponseChannelSinkStack sinkStack, object state, ITransportHeaders headers, Stream stream)
public Stream GetRequestStream(IMessage msg, ITransportHeaders headers)
public void ProcessMessage(IMessage msg, ITransportHeaders requestHeaders, Stream requestStream, ITransportHeaders& responseHeaders, Stream& responseStream)
}
internal Mono.Remoting.Channels.Unix.UnixClientTransportSinkProvider : object {
public IClientChannelSinkProvider Next
public IClientChannelSinkProvider get_Next()
public void set_Next(IClientChannelSinkProvider value)
public IClientChannelSink CreateSink(IChannelSender channel, string url, object remoteChannelData)
}
internal Mono.Remoting.Channels.Unix.UnixConnection : object {
private DateTime _controlTime
private Stream _stream
private ReusableUnixClient _client
private HostConnectionPool _pool
private Byte[] _buffer
public Stream Stream
public DateTime ControlTime
public bool IsAlive
public Byte[] Buffer
public void .ctor(HostConnectionPool pool, ReusableUnixClient client)
public Stream get_Stream()
public DateTime get_ControlTime()
public void set_ControlTime(DateTime value)
public bool get_IsAlive()
public Byte[] get_Buffer()
public void Release()
public void Close()
}
internal Mono.Remoting.Channels.Unix.UnixConnectionPool : object {
private Hashtable _pools
private int _maxOpenConnections
private int _keepAliveSeconds
private Thread _poolThread
public int MaxOpenConnections
public int KeepAliveSeconds
public void Shutdown()
public int get_MaxOpenConnections()
public void set_MaxOpenConnections(int value)
public int get_KeepAliveSeconds()
public void set_KeepAliveSeconds(int value)
public UnixConnection GetConnection(string path)
private void ConnectionCollector()
}
internal Mono.Remoting.Channels.Unix.UnixMessageIO : object {
private Byte[][] _msgHeaders
public int DefaultStreamBufferSize
private Byte[] msgUriTransportKey
private Byte[] msgContentTypeTransportKey
private Byte[] msgDefaultTransportKey
private Byte[] msgHeaderTerminator
private Dictionary`2<string, int> <>f__switch$map1
public MessageStatus ReceiveMessageStatus(Stream networkStream, Byte[] buffer)
private bool StreamRead(Stream networkStream, Byte[] buffer, int count)
public void SendMessageStream(Stream networkStream, Stream data, ITransportHeaders requestHeaders, Byte[] buffer)
private void SendHeaders(Stream networkStream, ITransportHeaders requestHeaders, Byte[] buffer)
public ITransportHeaders ReceiveHeaders(Stream networkStream, Byte[] buffer)
public Stream ReceiveMessageStream(Stream networkStream, ITransportHeaders& headers, Byte[] buffer)
private void SendString(Stream networkStream, string str, Byte[] buffer)
private string ReceiveString(Stream networkStream, Byte[] buffer)
}
public Mono.Remoting.Channels.Unix.UnixServerChannel : object {
private string path
private string name
private int priority
private bool supressChannelData
private Thread server_thread
private UnixListener listener
private UnixServerTransportSink sink
private ChannelDataStore channel_data
private int _maxConcurrentConnections
private ArrayList _activeConnections
private Dictionary`2<string, int> <>f__switch$map2
public object ChannelData
public string ChannelName
public int ChannelPriority
public void .ctor(string path)
public void .ctor(IDictionary properties, IServerChannelSinkProvider serverSinkProvider)
public void .ctor(string name, string path, IServerChannelSinkProvider serverSinkProvider)
public void .ctor(string name, string path)
private void Init(IServerChannelSinkProvider serverSinkProvider)
public object get_ChannelData()
public string get_ChannelName()
public int get_ChannelPriority()
public string GetChannelUri()
public String[] GetUrlsForUri(string uri)
public string Parse(string url, String& objectURI)
private void WaitForConnections()
internal void CreateListenerConnection(Socket client)
internal void ReleaseConnection(Thread thread)
public void StartListening(object data)
public void StopListening(object data)
}
internal Mono.Remoting.Channels.Unix.UnixServerTransportSink : object {
private IServerChannelSink next_sink
public IServerChannelSink NextChannelSink
public IDictionary Properties
public void .ctor(IServerChannelSink next)
public IServerChannelSink get_NextChannelSink()
public IDictionary get_Properties()
public void AsyncProcessResponse(IServerResponseChannelSinkStack sinkStack, object state, IMessage msg, ITransportHeaders headers, Stream responseStream)
public Stream GetResponseStream(IServerResponseChannelSinkStack sinkStack, object state, IMessage msg, ITransportHeaders headers)
public ServerProcessing ProcessMessage(IServerChannelSinkStack sinkStack, IMessage requestMsg, ITransportHeaders requestHeaders, Stream requestStream, IMessage& responseMsg, ITransportHeaders& responseHeaders, Stream& responseStream)
internal void InternalProcessMessage(ClientConnection connection, Stream stream)
}
internal Mono.Security.Cryptography.CryptoConvert : object {
private int ToInt32LE(Byte[] bytes, int offset)
private UInt32 ToUInt32LE(Byte[] bytes, int offset)
private Byte[] Trim(Byte[] array)
private RSA FromCapiPrivateKeyBlob(Byte[] blob, int offset)
private RSA FromCapiPublicKeyBlob(Byte[] blob, int offset)
public RSA FromCapiKeyBlob(Byte[] blob)
public RSA FromCapiKeyBlob(Byte[] blob, int offset)
}
public Mono.Unix.AbstractUnixEndPoint : EndPoint {
private string path
public string Path
public AddressFamily AddressFamily
public void .ctor(string path)
public string get_Path()
public void set_Path(string value)
public AddressFamily get_AddressFamily()
public EndPoint Create(SocketAddress socketAddress)
public SocketAddress Serialize()
public string ToString()
public int GetHashCode()
public bool Equals(object o)
}
public Mono.Unix.Catalog : object {
private IntPtr bindtextdomain(IntPtr domainname, IntPtr dirname)
private IntPtr bind_textdomain_codeset(IntPtr domainname, IntPtr codeset)
private IntPtr textdomain(IntPtr domainname)
public void Init(string package, string localedir)
private void MarshalStrings(string s1, IntPtr& p1, string s2, IntPtr& p2, string s3, IntPtr& p3)
private IntPtr gettext(IntPtr instring)
public string GetString(string s)
private IntPtr ngettext(IntPtr singular, IntPtr plural, int n)
public string GetPluralString(string s, string p, int n)
}
internal Mono.Unix.ErrorMarshal : object {
internal ErrorTranslator Translate
private string strerror(Errno errno)
private string strerror_r(Errno errno)
}
public Mono.Unix.FileAccessPattern : Enum {
public int value__
public FileAccessPattern Normal
public FileAccessPattern Sequential
public FileAccessPattern Random
public FileAccessPattern NoReuse
public FileAccessPattern PreLoad
public FileAccessPattern FlushCache
}
public Mono.Unix.FileAccessPermissions : Enum {
public int value__
public FileAccessPermissions UserReadWriteExecute
public FileAccessPermissions UserRead
public FileAccessPermissions UserWrite
public FileAccessPermissions UserExecute
public FileAccessPermissions GroupReadWriteExecute
public FileAccessPermissions GroupRead
public FileAccessPermissions GroupWrite
public FileAccessPermissions GroupExecute
public FileAccessPermissions OtherReadWriteExecute
public FileAccessPermissions OtherRead
public FileAccessPermissions OtherWrite
public FileAccessPermissions OtherExecute
public FileAccessPermissions DefaultPermissions
public FileAccessPermissions AllPermissions
}
public Mono.Unix.FileHandleOperations : object {
public void AdviseFileAccessPattern(int fd, FileAccessPattern pattern, long offset, long len)
public void AdviseFileAccessPattern(int fd, FileAccessPattern pattern)
public void AdviseFileAccessPattern(FileStream file, FileAccessPattern pattern, long offset, long len)
public void AdviseFileAccessPattern(FileStream file, FileAccessPattern pattern)
public void AdviseFileAccessPattern(UnixStream stream, FileAccessPattern pattern, long offset, long len)
public void AdviseFileAccessPattern(UnixStream stream, FileAccessPattern pattern)
}
public Mono.Unix.FileSpecialAttributes : Enum {
public int value__
public FileSpecialAttributes SetUserId
public FileSpecialAttributes SetGroupId
public FileSpecialAttributes Sticky
}
public Mono.Unix.FileTypes : Enum {
public int value__
public FileTypes Directory
public FileTypes CharacterDevice
public FileTypes BlockDevice
public FileTypes RegularFile
public FileTypes Fifo
public FileTypes SymbolicLink
public FileTypes Socket
}
public Mono.Unix.Native.AccessModes : Enum {
public int value__
public AccessModes R_OK
public AccessModes W_OK
public AccessModes X_OK
public AccessModes F_OK
}
public Mono.Unix.Native.CdeclFunction : object {
private string library
private string method
private Type returnType
private AssemblyName assemblyName
private AssemblyBuilder assemblyBuilder
private ModuleBuilder moduleBuilder
private Hashtable overloads
public void .ctor(string library, string method)
public void .ctor(string library, string method, Type returnType)
public object Invoke(Object[] parameters)
private MethodInfo CreateMethod(Type[] parameterTypes)
private TypeBuilder CreateType(string typeName)
private Type GetMarshalType(Type t)
private string GetTypeName(Type[] parameterTypes)
private Type[] GetParameterTypes(Object[] parameters)
}
public Mono.Unix.Native.ConfstrName : Enum {
public int value__
public ConfstrName _CS_PATH
public ConfstrName _CS_V6_WIDTH_RESTRICTED_ENVS
public ConfstrName _CS_GNU_LIBC_VERSION
public ConfstrName _CS_GNU_LIBPTHREAD_VERSION
public ConfstrName _CS_LFS_CFLAGS
public ConfstrName _CS_LFS_LDFLAGS
public ConfstrName _CS_LFS_LIBS
public ConfstrName _CS_LFS_LINTFLAGS
public ConfstrName _CS_LFS64_CFLAGS
public ConfstrName _CS_LFS64_LDFLAGS
public ConfstrName _CS_LFS64_LIBS
public ConfstrName _CS_LFS64_LINTFLAGS
public ConfstrName _CS_XBS5_ILP32_OFF32_CFLAGS
public ConfstrName _CS_XBS5_ILP32_OFF32_LDFLAGS
public ConfstrName _CS_XBS5_ILP32_OFF32_LIBS
public ConfstrName _CS_XBS5_ILP32_OFF32_LINTFLAGS
public ConfstrName _CS_XBS5_ILP32_OFFBIG_CFLAGS
public ConfstrName _CS_XBS5_ILP32_OFFBIG_LDFLAGS
public ConfstrName _CS_XBS5_ILP32_OFFBIG_LIBS
public ConfstrName _CS_XBS5_ILP32_OFFBIG_LINTFLAGS
public ConfstrName _CS_XBS5_LP64_OFF64_CFLAGS
public ConfstrName _CS_XBS5_LP64_OFF64_LDFLAGS
public ConfstrName _CS_XBS5_LP64_OFF64_LIBS
public ConfstrName _CS_XBS5_LP64_OFF64_LINTFLAGS
public ConfstrName _CS_XBS5_LPBIG_OFFBIG_CFLAGS
public ConfstrName _CS_XBS5_LPBIG_OFFBIG_LDFLAGS
public ConfstrName _CS_XBS5_LPBIG_OFFBIG_LIBS
public ConfstrName _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS
public ConfstrName _CS_POSIX_V6_ILP32_OFF32_CFLAGS
public ConfstrName _CS_POSIX_V6_ILP32_OFF32_LDFLAGS
public ConfstrName _CS_POSIX_V6_ILP32_OFF32_LIBS
public ConfstrName _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS
public ConfstrName _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS
public ConfstrName _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS
public ConfstrName _CS_POSIX_V6_ILP32_OFFBIG_LIBS
public ConfstrName _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS
public ConfstrName _CS_POSIX_V6_LP64_OFF64_CFLAGS
public ConfstrName _CS_POSIX_V6_LP64_OFF64_LDFLAGS
public ConfstrName _CS_POSIX_V6_LP64_OFF64_LIBS
public ConfstrName _CS_POSIX_V6_LP64_OFF64_LINTFLAGS
public ConfstrName _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS
public ConfstrName _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS
public ConfstrName _CS_POSIX_V6_LPBIG_OFFBIG_LIBS
public ConfstrName _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS
}
public Mono.Unix.Native.DirectoryNotifyFlags : Enum {
public int value__
public DirectoryNotifyFlags DN_ACCESS
public DirectoryNotifyFlags DN_MODIFY
public DirectoryNotifyFlags DN_CREATE
public DirectoryNotifyFlags DN_DELETE
public DirectoryNotifyFlags DN_RENAME
public DirectoryNotifyFlags DN_ATTRIB
public DirectoryNotifyFlags DN_MULTISHOT
}
public Mono.Unix.Native.Dirent : object {
public ulong d_ino
public long d_off
public ushort d_reclen
public byte d_type
public string d_name
public int GetHashCode()
public bool Equals(object obj)
public bool Equals(Dirent value)
public string ToString()
public bool op_Equality(Dirent lhs, Dirent rhs)
public bool op_Inequality(Dirent lhs, Dirent rhs)
}
public Mono.Unix.Native.Errno : Enum {
public int value__
public Errno EPERM
public Errno ENOENT
public Errno ESRCH
public Errno EINTR
public Errno EIO
public Errno ENXIO
public Errno E2BIG
public Errno ENOEXEC
public Errno EBADF
public Errno ECHILD
public Errno EAGAIN
public Errno ENOMEM
public Errno EACCES
public Errno EFAULT
public Errno ENOTBLK
public Errno EBUSY
public Errno EEXIST
public Errno EXDEV
public Errno ENODEV
public Errno ENOTDIR
public Errno EISDIR
public Errno EINVAL
public Errno ENFILE
public Errno EMFILE
public Errno ENOTTY
public Errno ETXTBSY
public Errno EFBIG
public Errno ENOSPC
public Errno ESPIPE
public Errno EROFS
public Errno EMLINK
public Errno EPIPE
public Errno EDOM
public Errno ERANGE
public Errno EDEADLK
public Errno ENAMETOOLONG
public Errno ENOLCK
public Errno ENOSYS
public Errno ENOTEMPTY
public Errno ELOOP
public Errno EWOULDBLOCK
public Errno ENOMSG
public Errno EIDRM
public Errno ECHRNG
public Errno EL2NSYNC
public Errno EL3HLT
public Errno EL3RST
public Errno ELNRNG
public Errno EUNATCH
public Errno ENOCSI
public Errno EL2HLT
public Errno EBADE
public Errno EBADR
public Errno EXFULL
public Errno ENOANO
public Errno EBADRQC
public Errno EBADSLT
public Errno EDEADLOCK
public Errno EBFONT
public Errno ENOSTR
public Errno ENODATA
public Errno ETIME
public Errno ENOSR
public Errno ENONET
public Errno ENOPKG
public Errno EREMOTE
public Errno ENOLINK
public Errno EADV
public Errno ESRMNT
public Errno ECOMM
public Errno EPROTO
public Errno EMULTIHOP
public Errno EDOTDOT
public Errno EBADMSG
public Errno EOVERFLOW
public Errno ENOTUNIQ
public Errno EBADFD
public Errno EREMCHG
public Errno ELIBACC
public Errno ELIBBAD
public Errno ELIBSCN
public Errno ELIBMAX
public Errno ELIBEXEC
public Errno EILSEQ
public Errno ERESTART
public Errno ESTRPIPE
public Errno EUSERS
public Errno ENOTSOCK
public Errno EDESTADDRREQ
public Errno EMSGSIZE
public Errno EPROTOTYPE
public Errno ENOPROTOOPT
public Errno EPROTONOSUPPORT
public Errno ESOCKTNOSUPPORT
public Errno EOPNOTSUPP
public Errno EPFNOSUPPORT
public Errno EAFNOSUPPORT
public Errno EADDRINUSE
public Errno EADDRNOTAVAIL
public Errno ENETDOWN
public Errno ENETUNREACH
public Errno ENETRESET
public Errno ECONNABORTED
public Errno ECONNRESET
public Errno ENOBUFS
public Errno EISCONN
public Errno ENOTCONN
public Errno ESHUTDOWN
public Errno ETOOMANYREFS
public Errno ETIMEDOUT
public Errno ECONNREFUSED
public Errno EHOSTDOWN
public Errno EHOSTUNREACH
public Errno EALREADY
public Errno EINPROGRESS
public Errno ESTALE
public Errno EUCLEAN
public Errno ENOTNAM
public Errno ENAVAIL
public Errno EISNAM
public Errno EREMOTEIO
public Errno EDQUOT
public Errno ENOMEDIUM
public Errno EMEDIUMTYPE
}
public Mono.Unix.Native.FcntlCommand : Enum {
public int value__
public FcntlCommand F_DUPFD
public FcntlCommand F_GETFD
public FcntlCommand F_SETFD
public FcntlCommand F_GETFL
public FcntlCommand F_SETFL
public FcntlCommand F_GETLK
public FcntlCommand F_SETLK
public FcntlCommand F_SETLKW
public FcntlCommand F_SETOWN
public FcntlCommand F_GETOWN
public FcntlCommand F_SETSIG
public FcntlCommand F_GETSIG
public FcntlCommand F_SETLEASE
public FcntlCommand F_GETLEASE
public FcntlCommand F_NOTIFY
}
internal Mono.Unix.Native.FileNameMarshaler : object {
private FileNameMarshaler Instance
public ICustomMarshaler GetInstance(string s)
public void CleanUpManagedData(object o)
public void CleanUpNativeData(IntPtr pNativeData)
public int GetNativeDataSize()
public IntPtr MarshalManagedToNative(object obj)
public object MarshalNativeToManaged(IntPtr pNativeData)
}
public Mono.Unix.Native.FilePermissions : Enum {
public UInt32 value__
public FilePermissions S_ISUID
public FilePermissions S_ISGID
public FilePermissions S_ISVTX
public FilePermissions S_IRUSR
public FilePermissions S_IWUSR
public FilePermissions S_IXUSR
public FilePermissions S_IRGRP
public FilePermissions S_IWGRP
public FilePermissions S_IXGRP
public FilePermissions S_IROTH
public FilePermissions S_IWOTH
public FilePermissions S_IXOTH
public FilePermissions S_IRWXG
public FilePermissions S_IRWXU
public FilePermissions S_IRWXO
public FilePermissions ACCESSPERMS
public FilePermissions ALLPERMS
public FilePermissions DEFFILEMODE
public FilePermissions S_IFMT
public FilePermissions S_IFDIR
public FilePermissions S_IFCHR
public FilePermissions S_IFBLK
public FilePermissions S_IFREG
public FilePermissions S_IFIFO
public FilePermissions S_IFLNK
public FilePermissions S_IFSOCK
}
public Mono.Unix.Native.FilePosition : MarshalByRefObject {
private int FilePositionDumpSize
private HandleRef pos
internal HandleRef Handle
internal HandleRef get_Handle()
public void Dispose()
private void Cleanup()
public string ToString()
private string GetDump()
public bool Equals(object obj)
public bool Equals(FilePosition value)
public int GetHashCode()
protected void Finalize()
public bool op_Equality(FilePosition lhs, FilePosition rhs)
public bool op_Inequality(FilePosition lhs, FilePosition rhs)
}
public Mono.Unix.Native.Flock : ValueType {
public LockType l_type
public SeekFlags l_whence
public long l_start
public long l_len
public int l_pid
public int GetHashCode()
public bool Equals(object obj)
public bool Equals(Flock value)
public bool op_Equality(Flock lhs, Flock rhs)
public bool op_Inequality(Flock lhs, Flock rhs)
}
public Mono.Unix.Native.Fstab : object {
public string fs_spec
public string fs_file
public string fs_vfstype
public string fs_mntops
public string fs_type
public int fs_freq
public int fs_passno
public int GetHashCode()
public bool Equals(object obj)
public bool Equals(Fstab value)
public string ToString()
public bool op_Equality(Fstab lhs, Fstab rhs)
public bool op_Inequality(Fstab lhs, Fstab rhs)
}
public Mono.Unix.Native.Group : object {
public string gr_name
public string gr_passwd
public UInt32 gr_gid
public String[] gr_mem
public int GetHashCode()
public bool Equals(object obj)
public bool Equals(Group value)
public string ToString()
private void GetMembers(StringBuilder sb, String[] members)
public bool op_Equality(Group lhs, Group rhs)
public bool op_Inequality(Group lhs, Group rhs)
}
public Mono.Unix.Native.LockfCommand : Enum {
public int value__
public LockfCommand F_ULOCK
public LockfCommand F_LOCK
public LockfCommand F_TLOCK
public LockfCommand F_TEST
}
public Mono.Unix.Native.LockType : Enum {
public short value__
public LockType F_RDLCK
public LockType F_WRLCK
public LockType F_UNLCK
}
public Mono.Unix.Native.MlockallFlags : Enum {
public int value__
public MlockallFlags MCL_CURRENT
public MlockallFlags MCL_FUTURE
}
public Mono.Unix.Native.MmapFlags : Enum {
public int value__
public MmapFlags MAP_SHARED
public MmapFlags MAP_PRIVATE
public MmapFlags MAP_TYPE
public MmapFlags MAP_FIXED
public MmapFlags MAP_FILE
public MmapFlags MAP_ANONYMOUS
public MmapFlags MAP_ANON
public MmapFlags MAP_GROWSDOWN
public MmapFlags MAP_DENYWRITE
public MmapFlags MAP_EXECUTABLE
public MmapFlags MAP_LOCKED
public MmapFlags MAP_NORESERVE
public MmapFlags MAP_POPULATE
public MmapFlags MAP_NONBLOCK
}
public Mono.Unix.Native.MmapProts : Enum {
public int value__
public MmapProts PROT_READ
public MmapProts PROT_WRITE
public MmapProts PROT_EXEC
public MmapProts PROT_NONE
public MmapProts PROT_GROWSDOWN
public MmapProts PROT_GROWSUP
}
public Mono.Unix.Native.MountFlags : Enum {
public ulong value__
public MountFlags ST_RDONLY
public MountFlags ST_NOSUID
public MountFlags ST_NODEV
public MountFlags ST_NOEXEC
public MountFlags ST_SYNCHRONOUS
public MountFlags ST_REMOUNT
public MountFlags ST_MANDLOCK
public MountFlags ST_WRITE
public MountFlags ST_APPEND
public MountFlags ST_IMMUTABLE
public MountFlags ST_NOATIME
public MountFlags ST_NODIRATIME
public MountFlags ST_BIND
}
public Mono.Unix.Native.MremapFlags : Enum {
public ulong value__
public MremapFlags MREMAP_MAYMOVE
}
public Mono.Unix.Native.MsyncFlags : Enum {
public int value__
public MsyncFlags MS_ASYNC
public MsyncFlags MS_SYNC
public MsyncFlags MS_INVALIDATE
}
public Mono.Unix.Native.NativeConvert : object {
private string LIB
public DateTime LocalUnixEpoch
public TimeSpan LocalUtcOffset
private String[][] fopen_modes
private int FromRealTimeSignum(int offset, Int32& rval)
public int FromRealTimeSignum(RealTimeSignum sig)
public RealTimeSignum ToRealTimeSignum(int offset)
public FilePermissions FromOctalPermissionString(string value)
public string ToOctalPermissionString(FilePermissions value)
public FilePermissions FromUnixPermissionString(string value)
private FilePermissions GetUnixPermissionDevice(char value)
private FilePermissions GetUnixPermissionGroup(char read, FilePermissions readb, char write, FilePermissions writeb, char exec, FilePermissions execb, char xboth, char xbitonly, FilePermissions xbit)
public string ToUnixPermissionString(FilePermissions value)
private void SetUnixPermissionGroup(FilePermissions value, Char[] access, int index, FilePermissions read, FilePermissions write, FilePermissions exec, char both, char setonly, FilePermissions setxbit)
private char GetSymbolicMode(FilePermissions value, FilePermissions xbit, char both, char setonly, FilePermissions setxbit)
public DateTime ToDateTime(long time)
public long FromDateTime(DateTime time)
public DateTime FromTimeT(long time)
public long ToTimeT(DateTime time)
public OpenFlags ToOpenFlags(FileMode mode, FileAccess access)
public string ToFopenMode(FileAccess access)
public string ToFopenMode(FileMode mode)
public string ToFopenMode(FileMode mode, FileAccess access)
private int FromStatvfs(Statvfs& source, IntPtr destination)
public bool TryCopy(Statvfs& source, IntPtr destination)
private int ToStatvfs(IntPtr source, Statvfs& destination)
public bool TryCopy(IntPtr source, Statvfs& destination)
private void ThrowArgumentException(object value)
private int FromAccessModes(AccessModes value, Int32& rval)
public bool TryFromAccessModes(AccessModes value, Int32& rval)
public int FromAccessModes(AccessModes value)
private int ToAccessModes(int value, AccessModes& rval)
public bool TryToAccessModes(int value, AccessModes& rval)
public AccessModes ToAccessModes(int value)
private int FromConfstrName(ConfstrName value, Int32& rval)
public bool TryFromConfstrName(ConfstrName value, Int32& rval)
public int FromConfstrName(ConfstrName value)
private int ToConfstrName(int value, ConfstrName& rval)
public bool TryToConfstrName(int value, ConfstrName& rval)
public ConfstrName ToConfstrName(int value)
private int FromDirectoryNotifyFlags(DirectoryNotifyFlags value, Int32& rval)
public bool TryFromDirectoryNotifyFlags(DirectoryNotifyFlags value, Int32& rval)
public int FromDirectoryNotifyFlags(DirectoryNotifyFlags value)
private int ToDirectoryNotifyFlags(int value, DirectoryNotifyFlags& rval)
public bool TryToDirectoryNotifyFlags(int value, DirectoryNotifyFlags& rval)
public DirectoryNotifyFlags ToDirectoryNotifyFlags(int value)
private int FromErrno(Errno value, Int32& rval)
public bool TryFromErrno(Errno value, Int32& rval)
public int FromErrno(Errno value)
private int ToErrno(int value, Errno& rval)
public bool TryToErrno(int value, Errno& rval)
public Errno ToErrno(int value)
private int FromFcntlCommand(FcntlCommand value, Int32& rval)
public bool TryFromFcntlCommand(FcntlCommand value, Int32& rval)
public int FromFcntlCommand(FcntlCommand value)
private int ToFcntlCommand(int value, FcntlCommand& rval)
public bool TryToFcntlCommand(int value, FcntlCommand& rval)
public FcntlCommand ToFcntlCommand(int value)
private int FromFilePermissions(FilePermissions value, UInt32& rval)
public bool TryFromFilePermissions(FilePermissions value, UInt32& rval)
public UInt32 FromFilePermissions(FilePermissions value)
private int ToFilePermissions(UInt32 value, FilePermissions& rval)
public bool TryToFilePermissions(UInt32 value, FilePermissions& rval)
public FilePermissions ToFilePermissions(UInt32 value)
private int FromFlock(Flock& source, IntPtr destination)
public bool TryCopy(Flock& source, IntPtr destination)
private int ToFlock(IntPtr source, Flock& destination)
public bool TryCopy(IntPtr source, Flock& destination)
private int FromLockType(LockType value, Int16& rval)
public bool TryFromLockType(LockType value, Int16& rval)
public short FromLockType(LockType value)
private int ToLockType(short value, LockType& rval)
public bool TryToLockType(short value, LockType& rval)
public LockType ToLockType(short value)
private int FromLockfCommand(LockfCommand value, Int32& rval)
public bool TryFromLockfCommand(LockfCommand value, Int32& rval)
public int FromLockfCommand(LockfCommand value)
private int ToLockfCommand(int value, LockfCommand& rval)
public bool TryToLockfCommand(int value, LockfCommand& rval)
public LockfCommand ToLockfCommand(int value)
private int FromMlockallFlags(MlockallFlags value, Int32& rval)
public bool TryFromMlockallFlags(MlockallFlags value, Int32& rval)
public int FromMlockallFlags(MlockallFlags value)
private int ToMlockallFlags(int value, MlockallFlags& rval)
public bool TryToMlockallFlags(int value, MlockallFlags& rval)
public MlockallFlags ToMlockallFlags(int value)
private int FromMmapFlags(MmapFlags value, Int32& rval)
public bool TryFromMmapFlags(MmapFlags value, Int32& rval)
public int FromMmapFlags(MmapFlags value)
private int ToMmapFlags(int value, MmapFlags& rval)
public bool TryToMmapFlags(int value, MmapFlags& rval)
public MmapFlags ToMmapFlags(int value)
private int FromMmapProts(MmapProts value, Int32& rval)
public bool TryFromMmapProts(MmapProts value, Int32& rval)
public int FromMmapProts(MmapProts value)
private int ToMmapProts(int value, MmapProts& rval)
public bool TryToMmapProts(int value, MmapProts& rval)
public MmapProts ToMmapProts(int value)
private int FromMountFlags(MountFlags value, UInt64& rval)
public bool TryFromMountFlags(MountFlags value, UInt64& rval)
public ulong FromMountFlags(MountFlags value)
private int ToMountFlags(ulong value, MountFlags& rval)
public bool TryToMountFlags(ulong value, MountFlags& rval)
public MountFlags ToMountFlags(ulong value)
private int FromMremapFlags(MremapFlags value, UInt64& rval)
public bool TryFromMremapFlags(MremapFlags value, UInt64& rval)
public ulong FromMremapFlags(MremapFlags value)
private int ToMremapFlags(ulong value, MremapFlags& rval)
public bool TryToMremapFlags(ulong value, MremapFlags& rval)
public MremapFlags ToMremapFlags(ulong value)
private int FromMsyncFlags(MsyncFlags value, Int32& rval)
public bool TryFromMsyncFlags(MsyncFlags value, Int32& rval)
public int FromMsyncFlags(MsyncFlags value)
private int ToMsyncFlags(int value, MsyncFlags& rval)
public bool TryToMsyncFlags(int value, MsyncFlags& rval)
public MsyncFlags ToMsyncFlags(int value)
private int FromOpenFlags(OpenFlags value, Int32& rval)
public bool TryFromOpenFlags(OpenFlags value, Int32& rval)
public int FromOpenFlags(OpenFlags value)
private int ToOpenFlags(int value, OpenFlags& rval)
public bool TryToOpenFlags(int value, OpenFlags& rval)
public OpenFlags ToOpenFlags(int value)
private int FromPathconfName(PathconfName value, Int32& rval)
public bool TryFromPathconfName(PathconfName value, Int32& rval)
public int FromPathconfName(PathconfName value)
private int ToPathconfName(int value, PathconfName& rval)
public bool TryToPathconfName(int value, PathconfName& rval)
public PathconfName ToPathconfName(int value)
private int FromPollEvents(PollEvents value, Int16& rval)
public bool TryFromPollEvents(PollEvents value, Int16& rval)
public short FromPollEvents(PollEvents value)
private int ToPollEvents(short value, PollEvents& rval)
public bool TryToPollEvents(short value, PollEvents& rval)
public PollEvents ToPollEvents(short value)
private int FromPollfd(Pollfd& source, IntPtr destination)
public bool TryCopy(Pollfd& source, IntPtr destination)
private int ToPollfd(IntPtr source, Pollfd& destination)
public bool TryCopy(IntPtr source, Pollfd& destination)
private int FromPosixFadviseAdvice(PosixFadviseAdvice value, Int32& rval)
public bool TryFromPosixFadviseAdvice(PosixFadviseAdvice value, Int32& rval)
public int FromPosixFadviseAdvice(PosixFadviseAdvice value)
private int ToPosixFadviseAdvice(int value, PosixFadviseAdvice& rval)
public bool TryToPosixFadviseAdvice(int value, PosixFadviseAdvice& rval)
public PosixFadviseAdvice ToPosixFadviseAdvice(int value)
private int FromPosixMadviseAdvice(PosixMadviseAdvice value, Int32& rval)
public bool TryFromPosixMadviseAdvice(PosixMadviseAdvice value, Int32& rval)
public int FromPosixMadviseAdvice(PosixMadviseAdvice value)
private int ToPosixMadviseAdvice(int value, PosixMadviseAdvice& rval)
public bool TryToPosixMadviseAdvice(int value, PosixMadviseAdvice& rval)
public PosixMadviseAdvice ToPosixMadviseAdvice(int value)
private int FromSeekFlags(SeekFlags value, Int16& rval)
public bool TryFromSeekFlags(SeekFlags value, Int16& rval)
public short FromSeekFlags(SeekFlags value)
private int ToSeekFlags(short value, SeekFlags& rval)
public bool TryToSeekFlags(short value, SeekFlags& rval)
public SeekFlags ToSeekFlags(short value)
private int FromSignum(Signum value, Int32& rval)
public bool TryFromSignum(Signum value, Int32& rval)
public int FromSignum(Signum value)
private int ToSignum(int value, Signum& rval)
public bool TryToSignum(int value, Signum& rval)
public Signum ToSignum(int value)
private int FromStat(Stat& source, IntPtr destination)
public bool TryCopy(Stat& source, IntPtr destination)
private int ToStat(IntPtr source, Stat& destination)
public bool TryCopy(IntPtr source, Stat& destination)
private int FromSysconfName(SysconfName value, Int32& rval)
public bool TryFromSysconfName(SysconfName value, Int32& rval)
public int FromSysconfName(SysconfName value)
private int ToSysconfName(int value, SysconfName& rval)
public bool TryToSysconfName(int value, SysconfName& rval)
public SysconfName ToSysconfName(int value)
private int FromSyslogFacility(SyslogFacility value, Int32& rval)
public bool TryFromSyslogFacility(SyslogFacility value, Int32& rval)
public int FromSyslogFacility(SyslogFacility value)
private int ToSyslogFacility(int value, SyslogFacility& rval)
public bool TryToSyslogFacility(int value, SyslogFacility& rval)
public SyslogFacility ToSyslogFacility(int value)
private int FromSyslogLevel(SyslogLevel value, Int32& rval)
public bool TryFromSyslogLevel(SyslogLevel value, Int32& rval)
public int FromSyslogLevel(SyslogLevel value)
private int ToSyslogLevel(int value, SyslogLevel& rval)
public bool TryToSyslogLevel(int value, SyslogLevel& rval)
public SyslogLevel ToSyslogLevel(int value)
private int FromSyslogOptions(SyslogOptions value, Int32& rval)
public bool TryFromSyslogOptions(SyslogOptions value, Int32& rval)
public int FromSyslogOptions(SyslogOptions value)
private int ToSyslogOptions(int value, SyslogOptions& rval)
public bool TryToSyslogOptions(int value, SyslogOptions& rval)
public SyslogOptions ToSyslogOptions(int value)
private int FromTimespec(Timespec& source, IntPtr destination)
public bool TryCopy(Timespec& source, IntPtr destination)
private int ToTimespec(IntPtr source, Timespec& destination)
public bool TryCopy(IntPtr source, Timespec& destination)
private int FromTimeval(Timeval& source, IntPtr destination)
public bool TryCopy(Timeval& source, IntPtr destination)
private int ToTimeval(IntPtr source, Timeval& destination)
public bool TryCopy(IntPtr source, Timeval& destination)
private int FromTimezone(Timezone& source, IntPtr destination)
public bool TryCopy(Timezone& source, IntPtr destination)
private int ToTimezone(IntPtr source, Timezone& destination)
public bool TryCopy(IntPtr source, Timezone& destination)
private int FromUtimbuf(Utimbuf& source, IntPtr destination)
public bool TryCopy(Utimbuf& source, IntPtr destination)
private int ToUtimbuf(IntPtr source, Utimbuf& destination)
public bool TryCopy(IntPtr source, Utimbuf& destination)
private int FromWaitOptions(WaitOptions value, Int32& rval)
public bool TryFromWaitOptions(WaitOptions value, Int32& rval)
public int FromWaitOptions(WaitOptions value)
private int ToWaitOptions(int value, WaitOptions& rval)
public bool TryToWaitOptions(int value, WaitOptions& rval)
public WaitOptions ToWaitOptions(int value)
private int FromXattrFlags(XattrFlags value, Int32& rval)
public bool TryFromXattrFlags(XattrFlags value, Int32& rval)
public int FromXattrFlags(XattrFlags value)
private int ToXattrFlags(int value, XattrFlags& rval)
public bool TryToXattrFlags(int value, XattrFlags& rval)
public XattrFlags ToXattrFlags(int value)
}
public Mono.Unix.Native.OpenFlags : Enum {
public int value__
public OpenFlags O_RDONLY
public OpenFlags O_WRONLY
public OpenFlags O_RDWR
public OpenFlags O_CREAT
public OpenFlags O_EXCL
public OpenFlags O_NOCTTY
public OpenFlags O_TRUNC
public OpenFlags O_APPEND
public OpenFlags O_NONBLOCK
public OpenFlags O_SYNC
public OpenFlags O_NOFOLLOW
public OpenFlags O_DIRECTORY
public OpenFlags O_DIRECT
public OpenFlags O_ASYNC
public OpenFlags O_LARGEFILE
}
public Mono.Unix.Native.Passwd : object {
public string pw_name
public string pw_passwd
public UInt32 pw_uid
public UInt32 pw_gid
public string pw_gecos
public string pw_dir
public string pw_shell
public int GetHashCode()
public bool Equals(object obj)
public bool Equals(Passwd value)
public string ToString()
public bool op_Equality(Passwd lhs, Passwd rhs)
public bool op_Inequality(Passwd lhs, Passwd rhs)
}
public Mono.Unix.Native.PathconfName : Enum {
public int value__
public PathconfName _PC_LINK_MAX
public PathconfName _PC_MAX_CANON
public PathconfName _PC_MAX_INPUT
public PathconfName _PC_NAME_MAX
public PathconfName _PC_PATH_MAX
public PathconfName _PC_PIPE_BUF
public PathconfName _PC_CHOWN_RESTRICTED
public PathconfName _PC_NO_TRUNC
public PathconfName _PC_VDISABLE
public PathconfName _PC_SYNC_IO
public PathconfName _PC_ASYNC_IO
public PathconfName _PC_PRIO_IO
public PathconfName _PC_SOCK_MAXBUF
public PathconfName _PC_FILESIZEBITS
public PathconfName _PC_REC_INCR_XFER_SIZE
public PathconfName _PC_REC_MAX_XFER_SIZE
public PathconfName _PC_REC_MIN_XFER_SIZE
public PathconfName _PC_REC_XFER_ALIGN
public PathconfName _PC_ALLOC_SIZE_MIN
public PathconfName _PC_SYMLINK_MAX
public PathconfName _PC_2_SYMLINKS
}
public Mono.Unix.Native.PollEvents : Enum {
public short value__
public PollEvents POLLIN
public PollEvents POLLPRI
public PollEvents POLLOUT
public PollEvents POLLERR
public PollEvents POLLHUP
public PollEvents POLLNVAL
public PollEvents POLLRDNORM
public PollEvents POLLRDBAND
public PollEvents POLLWRNORM
public PollEvents POLLWRBAND
}
public Mono.Unix.Native.Pollfd : ValueType {
public int fd
public PollEvents events
public PollEvents revents
public int GetHashCode()
public bool Equals(object obj)
public bool Equals(Pollfd value)
public bool op_Equality(Pollfd lhs, Pollfd rhs)
public bool op_Inequality(Pollfd lhs, Pollfd rhs)
}
public Mono.Unix.Native.PosixFadviseAdvice : Enum {
public int value__
public PosixFadviseAdvice POSIX_FADV_NORMAL
public PosixFadviseAdvice POSIX_FADV_RANDOM
public PosixFadviseAdvice POSIX_FADV_SEQUENTIAL
public PosixFadviseAdvice POSIX_FADV_WILLNEED
public PosixFadviseAdvice POSIX_FADV_DONTNEED
public PosixFadviseAdvice POSIX_FADV_NOREUSE
}
public Mono.Unix.Native.PosixMadviseAdvice : Enum {
public int value__
public PosixMadviseAdvice POSIX_MADV_NORMAL
public PosixMadviseAdvice POSIX_MADV_RANDOM
public PosixMadviseAdvice POSIX_MADV_SEQUENTIAL
public PosixMadviseAdvice POSIX_MADV_WILLNEED
public PosixMadviseAdvice POSIX_MADV_DONTNEED
}
public Mono.Unix.Native.RealTimeSignum : ValueType {
private int rt_offset
private int MaxOffset
public RealTimeSignum MinValue
public RealTimeSignum MaxValue
public int Offset
public void .ctor(int offset)
public int get_Offset()
public int GetHashCode()
public bool Equals(object obj)
public bool Equals(RealTimeSignum value)
public bool op_Equality(RealTimeSignum lhs, RealTimeSignum rhs)
public bool op_Inequality(RealTimeSignum lhs, RealTimeSignum rhs)
}
public Mono.Unix.Native.SeekFlags : Enum {
public short value__
public SeekFlags SEEK_SET
public SeekFlags SEEK_CUR
public SeekFlags SEEK_END
public SeekFlags L_SET
public SeekFlags L_INCR
public SeekFlags L_XTND
}
public Mono.Unix.Native.SignalAction : Enum {
public int value__
public SignalAction Default
public SignalAction Ignore
public SignalAction Error
}
public Mono.Unix.Native.SignalHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(int signal)
public IAsyncResult BeginInvoke(int signal, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public Mono.Unix.Native.Signum : Enum {
public int value__
public Signum SIGHUP
public Signum SIGINT
public Signum SIGQUIT
public Signum SIGILL
public Signum SIGTRAP
public Signum SIGABRT
public Signum SIGIOT
public Signum SIGBUS
public Signum SIGFPE
public Signum SIGKILL
public Signum SIGUSR1
public Signum SIGSEGV
public Signum SIGUSR2
public Signum SIGPIPE
public Signum SIGALRM
public Signum SIGTERM
public Signum SIGSTKFLT
public Signum SIGCLD
public Signum SIGCHLD
public Signum SIGCONT
public Signum SIGSTOP
public Signum SIGTSTP
public Signum SIGTTIN
public Signum SIGTTOU
public Signum SIGURG
public Signum SIGXCPU
public Signum SIGXFSZ
public Signum SIGVTALRM
public Signum SIGPROF
public Signum SIGWINCH
public Signum SIGPOLL
public Signum SIGIO
public Signum SIGPWR
public Signum SIGSYS
public Signum SIGUNUSED
}
public Mono.Unix.Native.Stat : ValueType {
public ulong st_dev
public ulong st_ino
public FilePermissions st_mode
private UInt32 _padding_
public ulong st_nlink
public UInt32 st_uid
public UInt32 st_gid
public ulong st_rdev
public long st_size
public long st_blksize
public long st_blocks
public long st_atime
public long st_mtime
public long st_ctime
public int GetHashCode()
public bool Equals(object obj)
public bool Equals(Stat value)
public bool op_Equality(Stat lhs, Stat rhs)
public bool op_Inequality(Stat lhs, Stat rhs)
}
public Mono.Unix.Native.Statvfs : ValueType {
public ulong f_bsize
public ulong f_frsize
public ulong f_blocks
public ulong f_bfree
public ulong f_bavail
public ulong f_files
public ulong f_ffree
public ulong f_favail
public ulong f_fsid
public MountFlags f_flag
public ulong f_namemax
public int GetHashCode()
public bool Equals(object obj)
public bool Equals(Statvfs value)
public bool op_Equality(Statvfs lhs, Statvfs rhs)
public bool op_Inequality(Statvfs lhs, Statvfs rhs)
}
public Mono.Unix.Native.Stdlib : object {
internal string LIBC
internal string MPH
private IntPtr _SIG_DFL
private IntPtr _SIG_ERR
private IntPtr _SIG_IGN
public SignalHandler SIG_DFL
public SignalHandler SIG_ERR
public SignalHandler SIG_IGN
private SignalHandler[] registered_signals
public int _IOFBF
public int _IOLBF
public int _IONBF
public int BUFSIZ
public int EOF
public int FOPEN_MAX
public int FILENAME_MAX
public int L_tmpnam
public IntPtr stderr
public IntPtr stdin
public IntPtr stdout
public int TMP_MAX
private object tmpnam_lock
public int EXIT_FAILURE
public int EXIT_SUCCESS
public int MB_CUR_MAX
public int RAND_MAX
private object strerror_lock
public Errno GetLastError()
private void SetLastError(int error)
protected void SetLastError(Errno error)
internal void InvokeSignalHandler(int signum, IntPtr handler)
private IntPtr GetDefaultSignal()
private IntPtr GetErrorSignal()
private IntPtr GetIgnoreSignal()
private void _ErrorHandler(int signum)
private void _DefaultHandler(int signum)
private void _IgnoreHandler(int signum)
private IntPtr sys_signal(int signum, SignalHandler handler)
private IntPtr sys_signal(int signum, IntPtr handler)
public SignalHandler signal(Signum signum, SignalHandler handler)
private SignalHandler TranslateHandler(IntPtr handler)
public int SetSignalAction(Signum signal, SignalAction action)
public int SetSignalAction(RealTimeSignum rts, SignalAction action)
private int SetSignalAction(int signum, SignalAction action)
private int sys_raise(int sig)
public int raise(Signum sig)
public int raise(RealTimeSignum rts)
private int GetFullyBuffered()
private int GetLineBuffered()
private int GetNonBuffered()
private int GetBufferSize()
internal IntPtr CreateFilePosition()
internal int DumpFilePosition(StringBuilder buf, HandleRef handle, int len)
private int GetEOF()
private int GetFilenameMax()
private int GetFopenMax()
private int GetTmpnamLength()
private IntPtr GetStandardInput()
private IntPtr GetStandardOutput()
private IntPtr GetStandardError()
private int GetTmpMax()
public int remove(string filename)
public int rename(string oldpath, string newpath)
public IntPtr tmpfile()
private IntPtr sys_tmpnam(StringBuilder s)
public string tmpnam(StringBuilder s)
public string tmpnam()
public int fclose(IntPtr stream)
public int fflush(IntPtr stream)
public IntPtr fopen(string path, string mode)
public IntPtr freopen(string path, string mode, IntPtr stream)
public int setbuf(IntPtr stream, IntPtr buf)
public int setbuf(IntPtr stream, Byte* buf)
public int setvbuf(IntPtr stream, IntPtr buf, int mode, ulong size)
public int setvbuf(IntPtr stream, Byte* buf, int mode, ulong size)
private int sys_fprintf(IntPtr stream, string format, string message)
public int fprintf(IntPtr stream, string message)
public int fprintf(IntPtr stream, string format, Object[] parameters)
private int sys_printf(string format, string message)
public int printf(string message)
public int printf(string format, Object[] parameters)
private int sys_snprintf(StringBuilder s, ulong n, string format, string message)
public int snprintf(StringBuilder s, ulong n, string message)
public int snprintf(StringBuilder s, string message)
public int snprintf(StringBuilder s, ulong n, string format, Object[] parameters)
public int snprintf(StringBuilder s, string format, Object[] parameters)
public int fgetc(IntPtr stream)
private IntPtr sys_fgets(StringBuilder sb, int size, IntPtr stream)
public StringBuilder fgets(StringBuilder sb, int size, IntPtr stream)
public StringBuilder fgets(StringBuilder sb, IntPtr stream)
public int fputc(int c, IntPtr stream)
public int fputs(string s, IntPtr stream)
public int getc(IntPtr stream)
public int getchar()
public int putc(int c, IntPtr stream)
public int putchar(int c)
public int puts(string s)
public int ungetc(int c, IntPtr stream)
public ulong fread(IntPtr ptr, ulong size, ulong nmemb, IntPtr stream)
public ulong fread(Void* ptr, ulong size, ulong nmemb, IntPtr stream)
private ulong sys_fread(Byte[] ptr, ulong size, ulong nmemb, IntPtr stream)
public ulong fread(Byte[] ptr, ulong size, ulong nmemb, IntPtr stream)
public ulong fread(Byte[] ptr, IntPtr stream)
public ulong fwrite(IntPtr ptr, ulong size, ulong nmemb, IntPtr stream)
public ulong fwrite(Void* ptr, ulong size, ulong nmemb, IntPtr stream)
private ulong sys_fwrite(Byte[] ptr, ulong size, ulong nmemb, IntPtr stream)
public ulong fwrite(Byte[] ptr, ulong size, ulong nmemb, IntPtr stream)
public ulong fwrite(Byte[] ptr, IntPtr stream)
private int sys_fgetpos(IntPtr stream, HandleRef pos)
public int fgetpos(IntPtr stream, FilePosition pos)
private int sys_fseek(IntPtr stream, long offset, int origin)
public int fseek(IntPtr stream, long offset, SeekFlags origin)
private int sys_fsetpos(IntPtr stream, HandleRef pos)
public int fsetpos(IntPtr stream, FilePosition pos)
public long ftell(IntPtr stream)
public int rewind(IntPtr stream)
public int clearerr(IntPtr stream)
public int feof(IntPtr stream)
public int ferror(IntPtr stream)
private int perror(string s, int err)
public int perror(string s)
private int GetExitFailure()
private int GetExitSuccess()
private int GetMbCurMax()
private int GetRandMax()
public int rand()
public void srand(UInt32 seed)
public IntPtr calloc(ulong nmemb, ulong size)
public void free(IntPtr ptr)
public IntPtr malloc(ulong size)
public IntPtr realloc(IntPtr ptr, ulong size)
public void abort()
public void exit(int status)
public void _Exit(int status)
private IntPtr sys_getenv(string name)
public string getenv(string name)
public int system(string string)
private IntPtr sys_strerror(int errnum)
public string strerror(Errno errnum)
public ulong strlen(IntPtr s)
}
public Mono.Unix.Native.Syscall : Stdlib {
internal string LIBC
internal object readdir_lock
internal object fstab_lock
internal object grp_lock
internal object pwd_lock
private object signal_lock
public int L_ctermid
public int L_cuserid
internal object getlogin_lock
public IntPtr MAP_FAILED
private object tty_lock
internal object usershell_lock
public int setxattr(string path, string name, Byte[] value, ulong size, XattrFlags flags)
public int setxattr(string path, string name, Byte[] value, ulong size)
public int setxattr(string path, string name, Byte[] value, XattrFlags flags)
public int setxattr(string path, string name, Byte[] value)
public int lsetxattr(string path, string name, Byte[] value, ulong size, XattrFlags flags)
public int lsetxattr(string path, string name, Byte[] value, ulong size)
public int lsetxattr(string path, string name, Byte[] value, XattrFlags flags)
public int lsetxattr(string path, string name, Byte[] value)
public int fsetxattr(int fd, string name, Byte[] value, ulong size, XattrFlags flags)
public int fsetxattr(int fd, string name, Byte[] value, ulong size)
public int fsetxattr(int fd, string name, Byte[] value, XattrFlags flags)
public int fsetxattr(int fd, string name, Byte[] value)
public long getxattr(string path, string name, Byte[] value, ulong size)
public long getxattr(string path, string name, Byte[] value)
public long getxattr(string path, string name, Byte[]& value)
public long lgetxattr(string path, string name, Byte[] value, ulong size)
public long lgetxattr(string path, string name, Byte[] value)
public long lgetxattr(string path, string name, Byte[]& value)
public long fgetxattr(int fd, string name, Byte[] value, ulong size)
public long fgetxattr(int fd, string name, Byte[] value)
public long fgetxattr(int fd, string name, Byte[]& value)
public long listxattr(string path, Byte[] list, ulong size)
public long listxattr(string path, Encoding encoding, String[]& values)
public long listxattr(string path, String[]& values)
private void GetValues(Byte[] list, Encoding encoding, String[]& values)
public long llistxattr(string path, Byte[] list, ulong size)
public long llistxattr(string path, Encoding encoding, String[]& values)
public long llistxattr(string path, String[]& values)
public long flistxattr(int fd, Byte[] list, ulong size)
public long flistxattr(int fd, Encoding encoding, String[]& values)
public long flistxattr(int fd, String[]& values)
public int removexattr(string path, string name)
public int lremovexattr(string path, string name)
public int fremovexattr(int fd, string name)
public IntPtr opendir(string name)
public int closedir(IntPtr dir)
public int seekdir(IntPtr dir, long offset)
public long telldir(IntPtr dir)
public int rewinddir(IntPtr dir)
private void CopyDirent(Dirent to, _Dirent& from)
private int sys_readdir(IntPtr dir, _Dirent& dentry)
public Dirent readdir(IntPtr dir)
private int sys_readdir_r(IntPtr dirp, _Dirent& entry, IntPtr& result)
public int readdir_r(IntPtr dirp, Dirent entry, IntPtr& result)
public int dirfd(IntPtr dir)
public int fcntl(int fd, FcntlCommand cmd)
public int fcntl(int fd, FcntlCommand cmd, long arg)
public int fcntl(int fd, FcntlCommand cmd, DirectoryNotifyFlags arg)
public int fcntl(int fd, FcntlCommand cmd, Flock& lock)
public int open(string pathname, OpenFlags flags)
public int open(string pathname, OpenFlags flags, FilePermissions mode)
public int creat(string pathname, FilePermissions mode)
public int posix_fadvise(int fd, long offset, long len, PosixFadviseAdvice advice)
public int posix_fallocate(int fd, long offset, ulong len)
private void CopyFstab(Fstab to, _Fstab& from)
private int sys_endfsent()
public int endfsent()
private int sys_getfsent(_Fstab& fs)
public Fstab getfsent()
private int sys_getfsfile(string mount_point, _Fstab& fs)
public Fstab getfsfile(string mount_point)
private int sys_getfsspec(string special_file, _Fstab& fs)
public Fstab getfsspec(string special_file)
private int sys_setfsent()
public int setfsent()
public int setgroups(ulong size, UInt32[] list)
public int setgroups(UInt32[] list)
private void CopyGroup(Group to, _Group& from)
private int sys_getgrnam(string name, _Group& group)
public Group getgrnam(string name)
private int sys_getgrgid(UInt32 uid, _Group& group)
public Group getgrgid(UInt32 uid)
private int sys_getgrnam_r(string name, _Group& grbuf, IntPtr& grbufp)
public int getgrnam_r(string name, Group grbuf, Group& grbufp)
private int sys_getgrgid_r(UInt32 uid, _Group& grbuf, IntPtr& grbufp)
public int getgrgid_r(UInt32 uid, Group grbuf, Group& grbufp)
private int sys_getgrent(_Group& grbuf)
public Group getgrent()
private int sys_setgrent()
public int setgrent()
private int sys_endgrent()
public int endgrent()
private int sys_fgetgrent(IntPtr stream, _Group& grbuf)
public Group fgetgrent(IntPtr stream)
private void CopyPasswd(Passwd to, _Passwd& from)
private int sys_getpwnam(string name, _Passwd& passwd)
public Passwd getpwnam(string name)
private int sys_getpwuid(UInt32 uid, _Passwd& passwd)
public Passwd getpwuid(UInt32 uid)
private int sys_getpwnam_r(string name, _Passwd& pwbuf, IntPtr& pwbufp)
public int getpwnam_r(string name, Passwd pwbuf, Passwd& pwbufp)
private int sys_getpwuid_r(UInt32 uid, _Passwd& pwbuf, IntPtr& pwbufp)
public int getpwuid_r(UInt32 uid, Passwd pwbuf, Passwd& pwbufp)
private int sys_getpwent(_Passwd& pwbuf)
public Passwd getpwent()
private int sys_setpwent()
public int setpwent()
private int sys_endpwent()
public int endpwent()
private int sys_fgetpwent(IntPtr stream, _Passwd& pwbuf)
public Passwd fgetpwent(IntPtr stream)
private int psignal(int sig, string s)
public int psignal(Signum sig, string s)
private int sys_kill(int pid, int sig)
public int kill(int pid, Signum sig)
private IntPtr sys_strsignal(int sig)
public string strsignal(Signum sig)
private int _L_ctermid()
private int _L_cuserid()
private IntPtr sys_cuserid(StringBuilder string)
public string cuserid(StringBuilder string)
public int mkstemp(StringBuilder template)
public int ttyslot()
public int setkey(string key)
private int sys_strerror_r(int errnum, StringBuilder buf, ulong n)
public int strerror_r(Errno errnum, StringBuilder buf, ulong n)
public int strerror_r(Errno errnum, StringBuilder buf)
public int posix_madvise(IntPtr addr, ulong len, PosixMadviseAdvice advice)
public IntPtr mmap(IntPtr start, ulong length, MmapProts prot, MmapFlags flags, int fd, long offset)
public int munmap(IntPtr start, ulong length)
public int mprotect(IntPtr start, ulong len, MmapProts prot)
public int msync(IntPtr start, ulong len, MsyncFlags flags)
public int mlock(IntPtr start, ulong len)
public int munlock(IntPtr start, ulong len)
private int sys_mlockall(int flags)
public int mlockall(MlockallFlags flags)
public int munlockall()
public IntPtr mremap(IntPtr old_address, ulong old_size, ulong new_size, MremapFlags flags)
public int mincore(IntPtr start, ulong length, Byte[] vec)
public int remap_file_pages(IntPtr start, ulong size, MmapProts prot, long pgoff, MmapFlags flags)
private int sys_poll(_pollfd[] ufds, UInt32 nfds, int timeout)
public int poll(Pollfd[] fds, UInt32 nfds, int timeout)
public int poll(Pollfd[] fds, int timeout)
public long sendfile(int out_fd, int in_fd, Int64& offset, ulong count)
public int stat(string file_name, Stat& buf)
public int fstat(int filedes, Stat& buf)
public int lstat(string file_name, Stat& buf)
private int sys_chmod(string path, UInt32 mode)
public int chmod(string path, FilePermissions mode)
private int sys_fchmod(int filedes, UInt32 mode)
public int fchmod(int filedes, FilePermissions mode)
private UInt32 sys_umask(UInt32 mask)
public FilePermissions umask(FilePermissions mask)
private int sys_mkdir(string oldpath, UInt32 mode)
public int mkdir(string oldpath, FilePermissions mode)
public int mknod(string pathname, FilePermissions mode, ulong dev)
private int sys_mkfifo(string pathname, UInt32 mode)
public int mkfifo(string pathname, FilePermissions mode)
public int statvfs(string path, Statvfs& buf)
public int fstatvfs(int fd, Statvfs& buf)
public int gettimeofday(Timeval& tv, Timezone& tz)
private int gettimeofday(Timeval& tv, IntPtr ignore)
public int gettimeofday(Timeval& tv)
private int gettimeofday(IntPtr ignore, Timezone& tz)
public int gettimeofday(Timezone& tz)
public int settimeofday(Timeval& tv, Timezone& tz)
private int settimeofday(Timeval& tv, IntPtr ignore)
public int settimeofday(Timeval& tv)
private int sys_utimes(string filename, Timeval[] tvp)
public int utimes(string filename, Timeval[] tvp)
private int sys_lutimes(string filename, Timeval[] tvp)
public int lutimes(string filename, Timeval[] tvp)
private int sys_futimes(int fd, Timeval[] tvp)
public int futimes(int fd, Timeval[] tvp)
private void CopyUtsname(Utsname& to, _Utsname& from)
private int sys_uname(_Utsname& buf)
public int uname(Utsname& buf)
public int wait(Int32& status)
private int waitpid(int pid, Int32& status, int options)
public int waitpid(int pid, Int32& status, WaitOptions options)
private int _WIFEXITED(int status)
public bool WIFEXITED(int status)
public int WEXITSTATUS(int status)
private int _WIFSIGNALED(int status)
public bool WIFSIGNALED(int status)
private int _WTERMSIG(int status)
public Signum WTERMSIG(int status)
private int _WIFSTOPPED(int status)
public bool WIFSTOPPED(int status)
private int _WSTOPSIG(int status)
public Signum WSTOPSIG(int status)
private int sys_openlog(IntPtr ident, int option, int facility)
public int openlog(IntPtr ident, SyslogOptions option, SyslogFacility defaultFacility)
private int sys_syslog(int priority, string message)
public int syslog(SyslogFacility facility, SyslogLevel level, string message)
public int syslog(SyslogLevel level, string message)
private string GetSyslogMessage(string message)
public int syslog(SyslogFacility facility, SyslogLevel level, string format, Object[] parameters)
public int syslog(SyslogLevel level, string format, Object[] parameters)
public int closelog()
private int sys_setlogmask(int mask)
public int setlogmask(SyslogLevel mask)
public int nanosleep(Timespec& req, Timespec& rem)
public int stime(Int64& t)
public long time(Int64& t)
private int sys_access(string pathname, int mode)
public int access(string pathname, AccessModes mode)
private long sys_lseek(int fd, long offset, int whence)
public long lseek(int fd, long offset, SeekFlags whence)
public int close(int fd)
public long read(int fd, IntPtr buf, ulong count)
public long read(int fd, Void* buf, ulong count)
public long write(int fd, IntPtr buf, ulong count)
public long write(int fd, Void* buf, ulong count)
public long pread(int fd, IntPtr buf, ulong count, long offset)
public long pread(int fd, Void* buf, ulong count, long offset)
public long pwrite(int fd, IntPtr buf, ulong count, long offset)
public long pwrite(int fd, Void* buf, ulong count, long offset)
public int pipe(Int32& reading, Int32& writing)
public int pipe(Int32[] filedes)
public UInt32 alarm(UInt32 seconds)
public UInt32 sleep(UInt32 seconds)
public UInt32 ualarm(UInt32 usecs, UInt32 interval)
public int pause()
public int chown(string path, UInt32 owner, UInt32 group)
public int fchown(int fd, UInt32 owner, UInt32 group)
public int lchown(string path, UInt32 owner, UInt32 group)
public int chdir(string path)
public int fchdir(int fd)
public IntPtr getcwd(StringBuilder buf, ulong size)
public StringBuilder getcwd(StringBuilder buf)
public int dup(int fd)
public int dup2(int fd, int fd2)
public int execve(string path, String[] argv, String[] envp)
public int fexecve(int fd, String[] argv, String[] envp)
public int execv(string path, String[] argv)
public int execvp(string path, String[] argv)
public int nice(int inc)
public int _exit(int status)
public long fpathconf(int filedes, PathconfName name, Errno defaultError)
public long fpathconf(int filedes, PathconfName name)
public long pathconf(string path, PathconfName name, Errno defaultError)
public long pathconf(string path, PathconfName name)
public long sysconf(SysconfName name, Errno defaultError)
public long sysconf(SysconfName name)
public ulong confstr(ConfstrName name, StringBuilder buf, ulong len)
public int getpid()
public int getppid()
public int setpgid(int pid, int pgid)
public int getpgid(int pid)
public int setpgrp()
public int getpgrp()
public int setsid()
public int getsid(int pid)
public UInt32 getuid()
public UInt32 geteuid()
public UInt32 getgid()
public UInt32 getegid()
public int getgroups(int size, UInt32[] list)
public int getgroups(UInt32[] list)
public int setuid(UInt32 uid)
public int setreuid(UInt32 ruid, UInt32 euid)
public int setregid(UInt32 rgid, UInt32 egid)
public int seteuid(UInt32 euid)
public int setegid(UInt32 uid)
public int setgid(UInt32 gid)
public int getresuid(UInt32& ruid, UInt32& euid, UInt32& suid)
public int getresgid(UInt32& rgid, UInt32& egid, UInt32& sgid)
public int setresuid(UInt32 ruid, UInt32 euid, UInt32 suid)
public int setresgid(UInt32 rgid, UInt32 egid, UInt32 sgid)
private IntPtr sys_ttyname(int fd)
public string ttyname(int fd)
public int ttyname_r(int fd, StringBuilder buf, ulong buflen)
public int ttyname_r(int fd, StringBuilder buf)
private int sys_isatty(int fd)
public bool isatty(int fd)
public int link(string oldpath, string newpath)
public int symlink(string oldpath, string newpath)
public int readlink(string path, StringBuilder buf, ulong bufsiz)
public int readlink(string path, StringBuilder buf)
public int unlink(string pathname)
public int rmdir(string pathname)
public int tcgetpgrp(int fd)
public int tcsetpgrp(int fd, int pgrp)
private IntPtr sys_getlogin()
public string getlogin()
public int getlogin_r(StringBuilder name, ulong bufsize)
public int getlogin_r(StringBuilder name)
public int setlogin(string name)
public int gethostname(StringBuilder name, ulong len)
public int gethostname(StringBuilder name)
public int sethostname(string name, ulong len)
public int sethostname(string name)
public long gethostid()
public int sethostid(long hostid)
public int getdomainname(StringBuilder name, ulong len)
public int getdomainname(StringBuilder name)
public int setdomainname(string name, ulong len)
public int setdomainname(string name)
public int vhangup()
public int revoke(string file)
public int acct(string filename)
private IntPtr sys_getusershell()
public string getusershell()
private int sys_setusershell()
public int setusershell()
private int sys_endusershell()
public int endusershell()
public int chroot(string path)
public int fsync(int fd)
public int fdatasync(int fd)
public int sync()
public int getpagesize()
public int truncate(string path, long length)
public int ftruncate(int fd, long length)
public int getdtablesize()
public int brk(IntPtr end_data_segment)
public IntPtr sbrk(IntPtr increment)
public int lockf(int fd, LockfCommand cmd, long len)
public string crypt(string key, string salt)
public int encrypt(Byte[] block, bool decode)
public int swab(IntPtr from, IntPtr to, long n)
public void swab(Void* from, Void* to, long n)
private int sys_utime(string filename, Utimbuf& buf, int use_buf)
public int utime(string filename, Utimbuf& buf)
public int utime(string filename)
}
public Mono.Unix.Native.SysconfName : Enum {
public int value__
public SysconfName _SC_ARG_MAX
public SysconfName _SC_CHILD_MAX
public SysconfName _SC_CLK_TCK
public SysconfName _SC_NGROUPS_MAX
public SysconfName _SC_OPEN_MAX
public SysconfName _SC_STREAM_MAX
public SysconfName _SC_TZNAME_MAX
public SysconfName _SC_JOB_CONTROL
public SysconfName _SC_SAVED_IDS
public SysconfName _SC_REALTIME_SIGNALS
public SysconfName _SC_PRIORITY_SCHEDULING
public SysconfName _SC_TIMERS
public SysconfName _SC_ASYNCHRONOUS_IO
public SysconfName _SC_PRIORITIZED_IO
public SysconfName _SC_SYNCHRONIZED_IO
public SysconfName _SC_FSYNC
public SysconfName _SC_MAPPED_FILES
public SysconfName _SC_MEMLOCK
public SysconfName _SC_MEMLOCK_RANGE
public SysconfName _SC_MEMORY_PROTECTION
public SysconfName _SC_MESSAGE_PASSING
public SysconfName _SC_SEMAPHORES
public SysconfName _SC_SHARED_MEMORY_OBJECTS
public SysconfName _SC_AIO_LISTIO_MAX
public SysconfName _SC_AIO_MAX
public SysconfName _SC_AIO_PRIO_DELTA_MAX
public SysconfName _SC_DELAYTIMER_MAX
public SysconfName _SC_MQ_OPEN_MAX
public SysconfName _SC_MQ_PRIO_MAX
public SysconfName _SC_VERSION
public SysconfName _SC_PAGESIZE
public SysconfName _SC_RTSIG_MAX
public SysconfName _SC_SEM_NSEMS_MAX
public SysconfName _SC_SEM_VALUE_MAX
public SysconfName _SC_SIGQUEUE_MAX
public SysconfName _SC_TIMER_MAX
public SysconfName _SC_BC_BASE_MAX
public SysconfName _SC_BC_DIM_MAX
public SysconfName _SC_BC_SCALE_MAX
public SysconfName _SC_BC_STRING_MAX
public SysconfName _SC_COLL_WEIGHTS_MAX
public SysconfName _SC_EQUIV_CLASS_MAX
public SysconfName _SC_EXPR_NEST_MAX
public SysconfName _SC_LINE_MAX
public SysconfName _SC_RE_DUP_MAX
public SysconfName _SC_CHARCLASS_NAME_MAX
public SysconfName _SC_2_VERSION
public SysconfName _SC_2_C_BIND
public SysconfName _SC_2_C_DEV
public SysconfName _SC_2_FORT_DEV
public SysconfName _SC_2_FORT_RUN
public SysconfName _SC_2_SW_DEV
public SysconfName _SC_2_LOCALEDEF
public SysconfName _SC_PII
public SysconfName _SC_PII_XTI
public SysconfName _SC_PII_SOCKET
public SysconfName _SC_PII_INTERNET
public SysconfName _SC_PII_OSI
public SysconfName _SC_POLL
public SysconfName _SC_SELECT
public SysconfName _SC_UIO_MAXIOV
public SysconfName _SC_IOV_MAX
public SysconfName _SC_PII_INTERNET_STREAM
public SysconfName _SC_PII_INTERNET_DGRAM
public SysconfName _SC_PII_OSI_COTS
public SysconfName _SC_PII_OSI_CLTS
public SysconfName _SC_PII_OSI_M
public SysconfName _SC_T_IOV_MAX
public SysconfName _SC_THREADS
public SysconfName _SC_THREAD_SAFE_FUNCTIONS
public SysconfName _SC_GETGR_R_SIZE_MAX
public SysconfName _SC_GETPW_R_SIZE_MAX
public SysconfName _SC_LOGIN_NAME_MAX
public SysconfName _SC_TTY_NAME_MAX
public SysconfName _SC_THREAD_DESTRUCTOR_ITERATIONS
public SysconfName _SC_THREAD_KEYS_MAX
public SysconfName _SC_THREAD_STACK_MIN
public SysconfName _SC_THREAD_THREADS_MAX
public SysconfName _SC_THREAD_ATTR_STACKADDR
public SysconfName _SC_THREAD_ATTR_STACKSIZE
public SysconfName _SC_THREAD_PRIORITY_SCHEDULING
public SysconfName _SC_THREAD_PRIO_INHERIT
public SysconfName _SC_THREAD_PRIO_PROTECT
public SysconfName _SC_THREAD_PROCESS_SHARED
public SysconfName _SC_NPROCESSORS_CONF
public SysconfName _SC_NPROCESSORS_ONLN
public SysconfName _SC_PHYS_PAGES
public SysconfName _SC_AVPHYS_PAGES
public SysconfName _SC_ATEXIT_MAX
public SysconfName _SC_PASS_MAX
public SysconfName _SC_XOPEN_VERSION
public SysconfName _SC_XOPEN_XCU_VERSION
public SysconfName _SC_XOPEN_UNIX
public SysconfName _SC_XOPEN_CRYPT
public SysconfName _SC_XOPEN_ENH_I18N
public SysconfName _SC_XOPEN_SHM
public SysconfName _SC_2_CHAR_TERM
public SysconfName _SC_2_C_VERSION
public SysconfName _SC_2_UPE
public SysconfName _SC_XOPEN_XPG2
public SysconfName _SC_XOPEN_XPG3
public SysconfName _SC_XOPEN_XPG4
public SysconfName _SC_CHAR_BIT
public SysconfName _SC_CHAR_MAX
public SysconfName _SC_CHAR_MIN
public SysconfName _SC_INT_MAX
public SysconfName _SC_INT_MIN
public SysconfName _SC_LONG_BIT
public SysconfName _SC_WORD_BIT
public SysconfName _SC_MB_LEN_MAX
public SysconfName _SC_NZERO
public SysconfName _SC_SSIZE_MAX
public SysconfName _SC_SCHAR_MAX
public SysconfName _SC_SCHAR_MIN
public SysconfName _SC_SHRT_MAX
public SysconfName _SC_SHRT_MIN
public SysconfName _SC_UCHAR_MAX
public SysconfName _SC_UINT_MAX
public SysconfName _SC_ULONG_MAX
public SysconfName _SC_USHRT_MAX
public SysconfName _SC_NL_ARGMAX
public SysconfName _SC_NL_LANGMAX
public SysconfName _SC_NL_MSGMAX
public SysconfName _SC_NL_NMAX
public SysconfName _SC_NL_SETMAX
public SysconfName _SC_NL_TEXTMAX
public SysconfName _SC_XBS5_ILP32_OFF32
public SysconfName _SC_XBS5_ILP32_OFFBIG
public SysconfName _SC_XBS5_LP64_OFF64
public SysconfName _SC_XBS5_LPBIG_OFFBIG
public SysconfName _SC_XOPEN_LEGACY
public SysconfName _SC_XOPEN_REALTIME
public SysconfName _SC_XOPEN_REALTIME_THREADS
public SysconfName _SC_ADVISORY_INFO
public SysconfName _SC_BARRIERS
public SysconfName _SC_BASE
public SysconfName _SC_C_LANG_SUPPORT
public SysconfName _SC_C_LANG_SUPPORT_R
public SysconfName _SC_CLOCK_SELECTION
public SysconfName _SC_CPUTIME
public SysconfName _SC_THREAD_CPUTIME
public SysconfName _SC_DEVICE_IO
public SysconfName _SC_DEVICE_SPECIFIC
public SysconfName _SC_DEVICE_SPECIFIC_R
public SysconfName _SC_FD_MGMT
public SysconfName _SC_FIFO
public SysconfName _SC_PIPE
public SysconfName _SC_FILE_ATTRIBUTES
public SysconfName _SC_FILE_LOCKING
public SysconfName _SC_FILE_SYSTEM
public SysconfName _SC_MONOTONIC_CLOCK
public SysconfName _SC_MULTI_PROCESS
public SysconfName _SC_SINGLE_PROCESS
public SysconfName _SC_NETWORKING
public SysconfName _SC_READER_WRITER_LOCKS
public SysconfName _SC_SPIN_LOCKS
public SysconfName _SC_REGEXP
public SysconfName _SC_REGEX_VERSION
public SysconfName _SC_SHELL
public SysconfName _SC_SIGNALS
public SysconfName _SC_SPAWN
public SysconfName _SC_SPORADIC_SERVER
public SysconfName _SC_THREAD_SPORADIC_SERVER
public SysconfName _SC_SYSTEM_DATABASE
public SysconfName _SC_SYSTEM_DATABASE_R
public SysconfName _SC_TIMEOUTS
public SysconfName _SC_TYPED_MEMORY_OBJECTS
public SysconfName _SC_USER_GROUPS
public SysconfName _SC_USER_GROUPS_R
public SysconfName _SC_2_PBS
public SysconfName _SC_2_PBS_ACCOUNTING
public SysconfName _SC_2_PBS_LOCATE
public SysconfName _SC_2_PBS_MESSAGE
public SysconfName _SC_2_PBS_TRACK
public SysconfName _SC_SYMLOOP_MAX
public SysconfName _SC_STREAMS
public SysconfName _SC_2_PBS_CHECKPOINT
public SysconfName _SC_V6_ILP32_OFF32
public SysconfName _SC_V6_ILP32_OFFBIG
public SysconfName _SC_V6_LP64_OFF64
public SysconfName _SC_V6_LPBIG_OFFBIG
public SysconfName _SC_HOST_NAME_MAX
public SysconfName _SC_TRACE
public SysconfName _SC_TRACE_EVENT_FILTER
public SysconfName _SC_TRACE_INHERIT
public SysconfName _SC_TRACE_LOG
public SysconfName _SC_LEVEL1_ICACHE_SIZE
public SysconfName _SC_LEVEL1_ICACHE_ASSOC
public SysconfName _SC_LEVEL1_ICACHE_LINESIZE
public SysconfName _SC_LEVEL1_DCACHE_SIZE
public SysconfName _SC_LEVEL1_DCACHE_ASSOC
public SysconfName _SC_LEVEL1_DCACHE_LINESIZE
public SysconfName _SC_LEVEL2_CACHE_SIZE
public SysconfName _SC_LEVEL2_CACHE_ASSOC
public SysconfName _SC_LEVEL2_CACHE_LINESIZE
public SysconfName _SC_LEVEL3_CACHE_SIZE
public SysconfName _SC_LEVEL3_CACHE_ASSOC
public SysconfName _SC_LEVEL3_CACHE_LINESIZE
public SysconfName _SC_LEVEL4_CACHE_SIZE
public SysconfName _SC_LEVEL4_CACHE_ASSOC
public SysconfName _SC_LEVEL4_CACHE_LINESIZE
}
public Mono.Unix.Native.SyslogFacility : Enum {
public int value__
public SyslogFacility LOG_KERN
public SyslogFacility LOG_USER
public SyslogFacility LOG_MAIL
public SyslogFacility LOG_DAEMON
public SyslogFacility LOG_AUTH
public SyslogFacility LOG_SYSLOG
public SyslogFacility LOG_LPR
public SyslogFacility LOG_NEWS
public SyslogFacility LOG_UUCP
public SyslogFacility LOG_CRON
public SyslogFacility LOG_AUTHPRIV
public SyslogFacility LOG_FTP
public SyslogFacility LOG_LOCAL0
public SyslogFacility LOG_LOCAL1
public SyslogFacility LOG_LOCAL2
public SyslogFacility LOG_LOCAL3
public SyslogFacility LOG_LOCAL4
public SyslogFacility LOG_LOCAL5
public SyslogFacility LOG_LOCAL6
public SyslogFacility LOG_LOCAL7
}
public Mono.Unix.Native.SyslogLevel : Enum {
public int value__
public SyslogLevel LOG_EMERG
public SyslogLevel LOG_ALERT
public SyslogLevel LOG_CRIT
public SyslogLevel LOG_ERR
public SyslogLevel LOG_WARNING
public SyslogLevel LOG_NOTICE
public SyslogLevel LOG_INFO
public SyslogLevel LOG_DEBUG
}
public Mono.Unix.Native.SyslogOptions : Enum {
public int value__
public SyslogOptions LOG_PID
public SyslogOptions LOG_CONS
public SyslogOptions LOG_ODELAY
public SyslogOptions LOG_NDELAY
public SyslogOptions LOG_NOWAIT
public SyslogOptions LOG_PERROR
}
public Mono.Unix.Native.Timespec : ValueType {
public long tv_sec
public long tv_nsec
public int GetHashCode()
public bool Equals(object obj)
public bool Equals(Timespec value)
public bool op_Equality(Timespec lhs, Timespec rhs)
public bool op_Inequality(Timespec lhs, Timespec rhs)
}
public Mono.Unix.Native.Timeval : ValueType {
public long tv_sec
public long tv_usec
public int GetHashCode()
public bool Equals(object obj)
public bool Equals(Timeval value)
public bool op_Equality(Timeval lhs, Timeval rhs)
public bool op_Inequality(Timeval lhs, Timeval rhs)
}
public Mono.Unix.Native.Timezone : ValueType {
public int tz_minuteswest
private int tz_dsttime
public int GetHashCode()
public bool Equals(object obj)
public bool Equals(Timezone value)
public bool op_Equality(Timezone lhs, Timezone rhs)
public bool op_Inequality(Timezone lhs, Timezone rhs)
}
public Mono.Unix.Native.Utimbuf : ValueType {
public long actime
public long modtime
public int GetHashCode()
public bool Equals(object obj)
public bool Equals(Utimbuf value)
public bool op_Equality(Utimbuf lhs, Utimbuf rhs)
public bool op_Inequality(Utimbuf lhs, Utimbuf rhs)
}
public Mono.Unix.Native.Utsname : object {
public string sysname
public string nodename
public string release
public string version
public string machine
public string domainname
public int GetHashCode()
public bool Equals(object obj)
public bool Equals(Utsname value)
public string ToString()
public bool op_Equality(Utsname lhs, Utsname rhs)
public bool op_Inequality(Utsname lhs, Utsname rhs)
}
public Mono.Unix.Native.WaitOptions : Enum {
public int value__
public WaitOptions WNOHANG
public WaitOptions WUNTRACED
}
public Mono.Unix.Native.XattrFlags : Enum {
public int value__
public XattrFlags XATTR_AUTO
public XattrFlags XATTR_CREATE
public XattrFlags XATTR_REPLACE
}
internal Mono.Unix.Native.XPrintfFunctions : object {
internal XPrintf printf
internal XPrintf fprintf
internal XPrintf snprintf
internal XPrintf syslog
}
public Mono.Unix.PeerCred : object {
private int so_peercred
private PeerCredData data
public int ProcessID
public int UserID
public int GroupID
public void .ctor(Socket sock)
public int get_ProcessID()
public int get_UserID()
public int get_GroupID()
}
public Mono.Unix.StdioFileStream : Stream {
public IntPtr InvalidFileStream
public IntPtr StandardInput
public IntPtr StandardOutput
public IntPtr StandardError
private bool canSeek
private bool canRead
private bool canWrite
private bool owner
private IntPtr file
public IntPtr Handle
public bool CanRead
public bool CanSeek
public bool CanWrite
public long Length
public long Position
public void .ctor(IntPtr fileStream)
public void .ctor(IntPtr fileStream, bool ownsHandle)
public void .ctor(IntPtr fileStream, FileAccess access)
public void .ctor(IntPtr fileStream, FileAccess access, bool ownsHandle)
public void .ctor(string path)
public void .ctor(string path, string mode)
public void .ctor(string path, FileMode mode)
public void .ctor(string path, FileAccess access)
public void .ctor(string path, FileMode mode, FileAccess access)
private IntPtr Fopen(string path, string mode)
private void InitStream(IntPtr fileStream, bool ownsHandle)
private void InitCanReadWrite(FileAccess access)
private string ToFopenMode(string file, FileMode mode)
private string ToFopenMode(string file, FileAccess access)
private string ToFopenMode(string file, FileMode mode, FileAccess access)
private bool AssertFileMode(string file, FileMode mode)
private bool FileExists(string file)
private void AssertNotDisposed()
public IntPtr get_Handle()
public bool get_CanRead()
public bool get_CanSeek()
public bool get_CanWrite()
public long get_Length()
public long get_Position()
public void set_Position(long value)
public void SaveFilePosition(FilePosition pos)
public void RestoreFilePosition(FilePosition pos)
public void Flush()
public int Read(Byte[] buffer, int offset, int count)
private void AssertValidBuffer(Byte[] buffer, int offset, int count)
public void Rewind()
public long Seek(long offset, SeekOrigin origin)
public void SetLength(long value)
public void Write(Byte[] buffer, int offset, int count)
protected void Finalize()
public void Close()
}
public Mono.Unix.UnixClient : MarshalByRefObject {
private NetworkStream stream
private Socket client
private bool disposed
public Socket Client
public PeerCred PeerCredential
public LingerOption LingerState
public int ReceiveBufferSize
public int ReceiveTimeout
public int SendBufferSize
public int SendTimeout
public void .ctor(string path)
public void .ctor(UnixEndPoint ep)
internal void .ctor(Socket sock)
public Socket get_Client()
public void set_Client(Socket value)
public PeerCred get_PeerCredential()
public LingerOption get_LingerState()
public void set_LingerState(LingerOption value)
public int get_ReceiveBufferSize()
public void set_ReceiveBufferSize(int value)
public int get_ReceiveTimeout()
public void set_ReceiveTimeout(int value)
public int get_SendBufferSize()
public void set_SendBufferSize(int value)
public int get_SendTimeout()
public void set_SendTimeout(int value)
public void Close()
public void Connect(UnixEndPoint remoteEndPoint)
public void Connect(string path)
public void Dispose()
protected void Dispose(bool disposing)
public NetworkStream GetStream()
private void CheckDisposed()
protected void Finalize()
}
public Mono.Unix.UnixDirectoryInfo : UnixFileSystemInfo {
public string Name
public UnixDirectoryInfo Parent
public UnixDirectoryInfo Root
public void .ctor(string path)
internal void .ctor(string path, Stat stat)
public string get_Name()
public UnixDirectoryInfo get_Parent()
public UnixDirectoryInfo get_Root()
public void Create(FilePermissions mode)
public void Create(FileAccessPermissions mode)
public void Create()
public void Delete()
public void Delete(bool recursive)
public Dirent[] GetEntries()
private Dirent[] GetEntries(IntPtr dirp)
public Dirent[] GetEntries(Regex regex)
private Dirent[] GetEntries(IntPtr dirp, Regex regex)
public Dirent[] GetEntries(string regex)
public UnixFileSystemInfo[] GetFileSystemEntries()
private UnixFileSystemInfo[] GetFileSystemEntries(Dirent[] dentries)
public UnixFileSystemInfo[] GetFileSystemEntries(Regex regex)
public UnixFileSystemInfo[] GetFileSystemEntries(string regex)
public string GetCurrentDirectory()
public void SetCurrentDirectory(string path)
}
public Mono.Unix.UnixDriveInfo : object {
private Statvfs stat
private string fstype
private string mount_point
private string block_device
public long AvailableFreeSpace
public string DriveFormat
public UnixDriveType DriveType
public bool IsReady
public string Name
public UnixDirectoryInfo RootDirectory
public long TotalFreeSpace
public long TotalSize
public string VolumeLabel
public long MaximumFilenameLength
public void .ctor(string mountPoint)
private void .ctor(Fstab fstab)
private void FromFstab(Fstab fstab)
public UnixDriveInfo GetForSpecialFile(string specialFile)
public long get_AvailableFreeSpace()
public string get_DriveFormat()
public UnixDriveType get_DriveType()
public bool get_IsReady()
public string get_Name()
public UnixDirectoryInfo get_RootDirectory()
public long get_TotalFreeSpace()
public long get_TotalSize()
public string get_VolumeLabel()
public long get_MaximumFilenameLength()
public UnixDriveInfo[] GetDrives()
public string ToString()
private void Refresh()
private bool Refresh(bool throwException)
}
public Mono.Unix.UnixDriveType : Enum {
public int value__
public UnixDriveType Unknown
public UnixDriveType NoRootDirectory
public UnixDriveType Removable
public UnixDriveType Fixed
public UnixDriveType Network
public UnixDriveType CDRom
public UnixDriveType Ram
}
public Mono.Unix.UnixEncoding : Encoding {
public Encoding Instance
public char EscapeByte
private int InternalGetByteCount(Char[] chars, int index, int count, UInt32 leftOver, bool flush)
public int GetByteCount(Char[] chars, int index, int count)
public int GetByteCount(string s)
private int InternalGetBytes(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex, UInt32& leftOver, bool flush)
public int GetBytes(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex)
public int GetBytes(string s, int charIndex, int charCount, Byte[] bytes, int byteIndex)
private int InternalGetCharCount(Byte[] bytes, int index, int count, UInt32 leftOverBits, UInt32 leftOverCount, bool throwOnInvalid, bool flush)
public int GetCharCount(Byte[] bytes, int index, int count)
private int InternalGetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex, UInt32& leftOverBits, UInt32& leftOverCount, bool throwOnInvalid, bool flush)
private void CopyRaw(Byte[] raw, Int32& next_raw, Char[] chars, Int32& posn, int length)
public int GetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex)
public int GetMaxByteCount(int charCount)
public int GetMaxCharCount(int byteCount)
public Decoder GetDecoder()
public Encoder GetEncoder()
public Byte[] GetPreamble()
public bool Equals(object value)
public int GetHashCode()
public Byte[] GetBytes(string s)
private string _(string arg)
}
public Mono.Unix.UnixEndPoint : EndPoint {
private string filename
public string Filename
public AddressFamily AddressFamily
public void .ctor(string filename)
public string get_Filename()
public void set_Filename(string value)
public AddressFamily get_AddressFamily()
public EndPoint Create(SocketAddress socketAddress)
public SocketAddress Serialize()
public string ToString()
public int GetHashCode()
public bool Equals(object o)
}
public Mono.Unix.UnixEnvironment : object {
public string CurrentDirectory
public string MachineName
public string UserName
public UnixGroupInfo RealGroup
public long RealGroupId
public UnixUserInfo RealUser
public long RealUserId
public UnixGroupInfo EffectiveGroup
public long EffectiveGroupId
public UnixUserInfo EffectiveUser
public long EffectiveUserId
public string Login
public string get_CurrentDirectory()
public void set_CurrentDirectory(string value)
public string get_MachineName()
public void set_MachineName(string value)
public string get_UserName()
public UnixGroupInfo get_RealGroup()
public long get_RealGroupId()
public UnixUserInfo get_RealUser()
public long get_RealUserId()
public UnixGroupInfo get_EffectiveGroup()
public void set_EffectiveGroup(UnixGroupInfo value)
public long get_EffectiveGroupId()
public void set_EffectiveGroupId(long value)
public UnixUserInfo get_EffectiveUser()
public void set_EffectiveUser(UnixUserInfo value)
public long get_EffectiveUserId()
public void set_EffectiveUserId(long value)
public string get_Login()
public long GetConfigurationValue(SysconfName name)
public string GetConfigurationString(ConfstrName name)
public void SetNiceValue(int inc)
public int CreateSession()
public void SetProcessGroup()
public int GetProcessGroup()
public UnixGroupInfo[] GetSupplementaryGroups()
private UInt32[] _GetSupplementaryGroupIds()
public void SetSupplementaryGroups(UnixGroupInfo[] groups)
public Int64[] GetSupplementaryGroupIds()
public void SetSupplementaryGroupIds(Int64[] list)
public int GetParentProcessId()
public UnixProcess GetParentProcess()
public String[] GetUserShells()
}
public Mono.Unix.UnixFileInfo : UnixFileSystemInfo {
public string Name
public string DirectoryName
public UnixDirectoryInfo Directory
public void .ctor(string path)
internal void .ctor(string path, Stat stat)
public string get_Name()
public string get_DirectoryName()
public UnixDirectoryInfo get_Directory()
public void Delete()
public UnixStream Create()
public UnixStream Create(FilePermissions mode)
public UnixStream Create(FileAccessPermissions mode)
public UnixStream Open(OpenFlags flags)
public UnixStream Open(OpenFlags flags, FilePermissions mode)
public UnixStream Open(FileMode mode)
public UnixStream Open(FileMode mode, FileAccess access)
public UnixStream Open(FileMode mode, FileAccess access, FilePermissions perms)
public UnixStream OpenRead()
public UnixStream OpenWrite()
}
public Mono.Unix.UnixFileSystemInfo : object {
internal FileSpecialAttributes AllSpecialAttributes
internal FileTypes AllFileTypes
private Stat stat
private string fullPath
private string originalPath
private bool valid
protected string FullPath
protected string OriginalPath
public string FullName
public string Name
public bool Exists
public long Device
public long Inode
public FilePermissions Protection
public FileTypes FileType
public FileAccessPermissions FileAccessPermissions
public FileSpecialAttributes FileSpecialAttributes
public long LinkCount
public UnixUserInfo OwnerUser
public long OwnerUserId
public UnixGroupInfo OwnerGroup
public long OwnerGroupId
public long DeviceType
public long Length
public long BlockSize
public long BlocksAllocated
public DateTime LastAccessTime
public DateTime LastAccessTimeUtc
public DateTime LastWriteTime
public DateTime LastWriteTimeUtc
public DateTime LastStatusChangeTime
public DateTime LastStatusChangeTimeUtc
public bool IsDirectory
public bool IsCharacterDevice
public bool IsBlockDevice
public bool IsRegularFile
public bool IsFifo
public bool IsSymbolicLink
public bool IsSocket
public bool IsSetUser
public bool IsSetGroup
public bool IsSticky
protected void .ctor(string path)
internal void .ctor(string path, Stat stat)
protected string get_FullPath()
protected void set_FullPath(string value)
protected string get_OriginalPath()
protected void set_OriginalPath(string value)
private void AssertValid()
public string get_FullName()
public string get_Name()
public bool get_Exists()
public long get_Device()
public long get_Inode()
public FilePermissions get_Protection()
public void set_Protection(FilePermissions value)
public FileTypes get_FileType()
public FileAccessPermissions get_FileAccessPermissions()
public void set_FileAccessPermissions(FileAccessPermissions value)
public FileSpecialAttributes get_FileSpecialAttributes()
public void set_FileSpecialAttributes(FileSpecialAttributes value)
public long get_LinkCount()
public UnixUserInfo get_OwnerUser()
public long get_OwnerUserId()
public UnixGroupInfo get_OwnerGroup()
public long get_OwnerGroupId()
public long get_DeviceType()
public long get_Length()
public long get_BlockSize()
public long get_BlocksAllocated()
public DateTime get_LastAccessTime()
public DateTime get_LastAccessTimeUtc()
public DateTime get_LastWriteTime()
public DateTime get_LastWriteTimeUtc()
public DateTime get_LastStatusChangeTime()
public DateTime get_LastStatusChangeTimeUtc()
public bool get_IsDirectory()
public bool get_IsCharacterDevice()
public bool get_IsBlockDevice()
public bool get_IsRegularFile()
public bool get_IsFifo()
public bool get_IsSymbolicLink()
public bool get_IsSocket()
public bool get_IsSetUser()
public bool get_IsSetGroup()
public bool get_IsSticky()
internal bool IsFileType(FilePermissions mode, FilePermissions type)
internal bool IsSet(FilePermissions mode, FilePermissions type)
public bool CanAccess(AccessModes mode)
public UnixFileSystemInfo CreateLink(string path)
public UnixSymbolicLinkInfo CreateSymbolicLink(string path)
public void Delete()
public long GetConfigurationValue(PathconfName name)
public void Refresh()
internal void Refresh(bool force)
protected bool GetFileStatus(string path, Stat& stat)
public void SetLength(long length)
public void SetOwner(long owner, long group)
public void SetOwner(string owner)
public void SetOwner(string owner, string group)
public void SetOwner(UnixUserInfo owner)
public void SetOwner(UnixUserInfo owner, UnixGroupInfo group)
public string ToString()
public Stat ToStat()
public UnixFileSystemInfo GetFileSystemEntry(string path)
}
public Mono.Unix.UnixGroupInfo : object {
private Group group
public string GroupName
public string Password
public long GroupId
public void .ctor(string group)
public void .ctor(long group)
public void .ctor(Group group)
private Group CopyGroup(Group group)
public string get_GroupName()
public string get_Password()
public long get_GroupId()
public UnixUserInfo[] GetMembers()
public String[] GetMemberNames()
public int GetHashCode()
public bool Equals(object obj)
public string ToString()
public Group ToGroup()
public UnixGroupInfo[] GetLocalGroups()
}
public Mono.Unix.UnixIOException : IOException {
private int errno
public int NativeErrorCode
public Errno ErrorCode
public void .ctor(int errno)
public void .ctor(int errno, Exception inner)
public void .ctor(Errno errno)
public void .ctor(Errno errno, Exception inner)
public void .ctor(string message)
public void .ctor(string message, Exception inner)
protected void .ctor(SerializationInfo info, StreamingContext context)
public int get_NativeErrorCode()
public Errno get_ErrorCode()
private string GetMessage(Errno errno)
}
public Mono.Unix.UnixListener : MarshalByRefObject {
private bool disposed
private bool listening
private Socket server
private EndPoint savedEP
public EndPoint LocalEndpoint
protected Socket Server
public void .ctor(string path)
public void .ctor(UnixEndPoint localEndPoint)
private void Init(UnixEndPoint ep)
public EndPoint get_LocalEndpoint()
protected Socket get_Server()
public Socket AcceptSocket()
public UnixClient AcceptUnixClient()
protected void Finalize()
public bool Pending()
public void Start()
public void Start(int backlog)
public void Stop()
public void Dispose()
protected void Dispose(bool disposing)
private void CheckDisposed()
}
public Mono.Unix.UnixMarshal : object {
public string GetErrorDescription(Errno errno)
public IntPtr AllocHeap(long size)
public IntPtr ReAllocHeap(IntPtr ptr, long size)
public void FreeHeap(IntPtr ptr)
public string PtrToStringUnix(IntPtr p)
public string PtrToString(IntPtr p)
public string PtrToString(IntPtr p, Encoding encoding)
private int GetStringByteLength(IntPtr p, Encoding encoding)
private int GetInt16BufferLength(IntPtr p)
private int GetInt32BufferLength(IntPtr p)
private int GetRandomBufferLength(IntPtr p, int nullLength)
public String[] PtrToStringArray(IntPtr stringArray)
public String[] PtrToStringArray(IntPtr stringArray, Encoding encoding)
private int CountStrings(IntPtr stringArray)
public String[] PtrToStringArray(int count, IntPtr stringArray)
public String[] PtrToStringArray(int count, IntPtr stringArray, Encoding encoding)
public IntPtr StringToHeap(string s)
public IntPtr StringToHeap(string s, Encoding encoding)
public IntPtr StringToHeap(string s, int index, int count)
public IntPtr StringToHeap(string s, int index, int count, Encoding encoding)
public bool ShouldRetrySyscall(int r)
public bool ShouldRetrySyscall(int r, Errno& errno)
internal string EscapeFormatString(string message, Char[] permitted)
private bool IsCharPresent(Char[] array, char c)
internal Exception CreateExceptionForError(Errno errno)
internal Exception CreateExceptionForLastError()
public void ThrowExceptionForError(Errno errno)
public void ThrowExceptionForLastError()
public void ThrowExceptionForErrorIf(int retval, Errno errno)
public void ThrowExceptionForLastErrorIf(int retval)
}
public Mono.Unix.UnixPath : object {
public char DirectorySeparatorChar
public char AltDirectorySeparatorChar
public char PathSeparator
public char VolumeSeparatorChar
private Char[] _InvalidPathChars
public Char[] GetInvalidPathChars()
public string Combine(string path1, String[] paths)
private void Combine(StringBuilder path, string part)
public string GetDirectoryName(string path)
public string GetFileName(string path)
public string GetFullPath(string path)
private string _GetFullPath(string path)
public string GetCanonicalPath(string path)
private void GetPathComponents(string path, String[]& components, Int32& lastIndex)
public string GetPathRoot(string path)
public string GetCompleteRealPath(string path)
public string GetRealPath(string path)
internal string ReadSymbolicLink(string path)
private string ReadSymbolicLink(string path, Errno& errno)
public string TryReadLink(string path)
public string ReadLink(string path)
public bool IsPathRooted(string path)
internal void CheckPath(string path)
}
public Mono.Unix.UnixPipes : ValueType {
public UnixStream Reading
public UnixStream Writing
public void .ctor(UnixStream reading, UnixStream writing)
public UnixPipes CreatePipes()
public bool Equals(object value)
public bool Equals(UnixPipes value)
public int GetHashCode()
public bool op_Equality(UnixPipes lhs, UnixPipes rhs)
public bool op_Inequality(UnixPipes lhs, UnixPipes rhs)
}
public Mono.Unix.UnixProcess : object {
private int pid
public int Id
public bool HasExited
public int ExitCode
public bool HasSignaled
public Signum TerminationSignal
public bool HasStopped
public Signum StopSignal
public int ProcessGroupId
public int SessionId
internal void .ctor(int pid)
public int get_Id()
public bool get_HasExited()
private int GetProcessStatus()
public int get_ExitCode()
public bool get_HasSignaled()
public Signum get_TerminationSignal()
public bool get_HasStopped()
public Signum get_StopSignal()
public int get_ProcessGroupId()
public void set_ProcessGroupId(int value)
public int get_SessionId()
public UnixProcess GetCurrentProcess()
public int GetCurrentProcessId()
public void Kill()
public void Signal(Signum signal)
public void WaitForExit()
}
public Mono.Unix.UnixSignal : WaitHandle {
private int signum
private IntPtr signal_info
private Mono_Posix_RuntimeIsShuttingDown <>f__am$cache2
public Signum Signum
public RealTimeSignum RealTimeSignum
public bool IsRealTimeSignal
private SignalInfo* Info
public bool IsSet
public int Count
public void .ctor(Signum signum)
public void .ctor(RealTimeSignum rtsig)
public Signum get_Signum()
public RealTimeSignum get_RealTimeSignum()
public bool get_IsRealTimeSignal()
private IntPtr install(int signum)
private int uninstall(IntPtr info)
private int WaitAny(IntPtr[] infos, int count, int timeout, Mono_Posix_RuntimeIsShuttingDown shutting_down)
internal int GetSIGRTMIN()
internal int GetSIGRTMAX()
private void AssertValid()
private SignalInfo* get_Info()
public bool get_IsSet()
public bool Reset()
public int get_Count()
public void set_Count(int value)
protected void Dispose(bool disposing)
public bool WaitOne()
public bool WaitOne(TimeSpan timeout, bool exitContext)
public bool WaitOne(int millisecondsTimeout, bool exitContext)
public int WaitAny(UnixSignal[] signals)
public int WaitAny(UnixSignal[] signals, TimeSpan timeout)
public int WaitAny(UnixSignal[] signals, int millisecondsTimeout)
private int <WaitAny>m__0()
}
public Mono.Unix.UnixStream : Stream {
public int InvalidFileDescriptor
public int StandardInputFileDescriptor
public int StandardOutputFileDescriptor
public int StandardErrorFileDescriptor
private bool canSeek
private bool canRead
private bool canWrite
private bool owner
private int fileDescriptor
private Stat stat
public int Handle
public bool CanRead
public bool CanSeek
public bool CanWrite
public long Length
public long Position
public FilePermissions Protection
public FileTypes FileType
public FileAccessPermissions FileAccessPermissions
public FileSpecialAttributes FileSpecialAttributes
public UnixUserInfo OwnerUser
public long OwnerUserId
public UnixGroupInfo OwnerGroup
public long OwnerGroupId
public void .ctor(int fileDescriptor)
public void .ctor(int fileDescriptor, bool ownsHandle)
private void System.IDisposable.Dispose()
private void AssertNotDisposed()
public int get_Handle()
public bool get_CanRead()
public bool get_CanSeek()
public bool get_CanWrite()
public long get_Length()
public long get_Position()
public void set_Position(long value)
public FilePermissions get_Protection()
public void set_Protection(FilePermissions value)
public FileTypes get_FileType()
public FileAccessPermissions get_FileAccessPermissions()
public void set_FileAccessPermissions(FileAccessPermissions value)
public FileSpecialAttributes get_FileSpecialAttributes()
public void set_FileSpecialAttributes(FileSpecialAttributes value)
public UnixUserInfo get_OwnerUser()
public long get_OwnerUserId()
public UnixGroupInfo get_OwnerGroup()
public long get_OwnerGroupId()
private void RefreshStat()
public void AdviseFileAccessPattern(FileAccessPattern pattern, long offset, long len)
public void AdviseFileAccessPattern(FileAccessPattern pattern)
public void Flush()
public int Read(Byte[] buffer, int offset, int count)
private void AssertValidBuffer(Byte[] buffer, int offset, int count)
public int ReadAtOffset(Byte[] buffer, int offset, int count, long fileOffset)
public long Seek(long offset, SeekOrigin origin)
public void SetLength(long value)
public void Write(Byte[] buffer, int offset, int count)
public void WriteAtOffset(Byte[] buffer, int offset, int count, long fileOffset)
public void SendTo(UnixStream output)
public void SendTo(UnixStream output, ulong count)
public void SendTo(int out_fd, ulong count)
public void SetOwner(long user, long group)
public void SetOwner(string user, string group)
public void SetOwner(string user)
public long GetConfigurationValue(PathconfName name)
protected void Finalize()
public void Close()
}
public Mono.Unix.UnixSymbolicLinkInfo : UnixFileSystemInfo {
public string Name
public UnixFileSystemInfo Contents
public string ContentsPath
public bool HasContents
public void .ctor(string path)
internal void .ctor(string path, Stat stat)
public string get_Name()
public UnixFileSystemInfo get_Contents()
public string get_ContentsPath()
public bool get_HasContents()
public UnixFileSystemInfo GetContents()
public void CreateSymbolicLinkTo(string path)
public void CreateSymbolicLinkTo(UnixFileSystemInfo path)
public void Delete()
public void SetOwner(long owner, long group)
protected bool GetFileStatus(string path, Stat& stat)
private string ReadLink()
private string TryReadLink()
}
public Mono.Unix.UnixUserInfo : object {
private Passwd passwd
public string UserName
public string Password
public long UserId
public UnixGroupInfo Group
public long GroupId
public string GroupName
public string RealName
public string HomeDirectory
public string ShellProgram
public void .ctor(string user)
public void .ctor(UInt32 user)
public void .ctor(long user)
public void .ctor(Passwd passwd)
private Passwd CopyPasswd(Passwd pw)
public string get_UserName()
public string get_Password()
public long get_UserId()
public UnixGroupInfo get_Group()
public long get_GroupId()
public string get_GroupName()
public string get_RealName()
public string get_HomeDirectory()
public string get_ShellProgram()
public int GetHashCode()
public bool Equals(object obj)
public string ToString()
public UnixUserInfo GetRealUser()
public long GetRealUserId()
public string GetLoginName()
public Passwd ToPasswd()
public UnixUserInfo[] GetLocalUsers()
}
internal Newtonsoft.Json.Bson.BsonArray : BsonToken {
private List`1<BsonToken> _children
public BsonType Type
public void Add(BsonToken token)
public BsonType get_Type()
public IEnumerator`1<BsonToken> GetEnumerator()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
}
internal Newtonsoft.Json.Bson.BsonBinary : BsonValue {
private BsonBinaryType <BinaryType>k__BackingField
public BsonBinaryType BinaryType
public BsonBinaryType get_BinaryType()
public void set_BinaryType(BsonBinaryType value)
public void .ctor(Byte[] value, BsonBinaryType binaryType)
}
internal Newtonsoft.Json.Bson.BsonBinaryType : Enum {
public byte value__
public BsonBinaryType Binary
public BsonBinaryType Function
public BsonBinaryType BinaryOld
public BsonBinaryType UuidOld
public BsonBinaryType Uuid
public BsonBinaryType Md5
public BsonBinaryType UserDefined
}
internal Newtonsoft.Json.Bson.BsonBinaryWriter : object {
private Encoding Encoding
private BinaryWriter _writer
private Byte[] _largeByteBuffer
private DateTimeKind <DateTimeKindHandling>k__BackingField
public DateTimeKind DateTimeKindHandling
public DateTimeKind get_DateTimeKindHandling()
public void set_DateTimeKindHandling(DateTimeKind value)
public void .ctor(BinaryWriter writer)
public void Flush()
public void Close()
public void WriteToken(BsonToken t)
private void WriteTokenInternal(BsonToken t)
private void WriteString(string s, int byteCount, Nullable`1<int> calculatedlengthPrefix)
public void WriteUtf8Bytes(string s, int byteCount)
private int CalculateSize(int stringByteCount)
private int CalculateSizeWithLength(int stringByteCount, bool includeSize)
private int CalculateSize(BsonToken t)
}
internal Newtonsoft.Json.Bson.BsonObject : BsonToken {
private List`1<BsonProperty> _children
public BsonType Type
public void Add(string name, BsonToken token)
public BsonType get_Type()
public IEnumerator`1<BsonProperty> GetEnumerator()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
}
public Newtonsoft.Json.Bson.BsonObjectId : object {
private Byte[] <Value>k__BackingField
public Byte[] Value
public Byte[] get_Value()
private void set_Value(Byte[] value)
public void .ctor(Byte[] value)
}
internal Newtonsoft.Json.Bson.BsonProperty : object {
private BsonString <Name>k__BackingField
private BsonToken <Value>k__BackingField
public BsonString Name
public BsonToken Value
public BsonString get_Name()
public void set_Name(BsonString value)
public BsonToken get_Value()
public void set_Value(BsonToken value)
}
public Newtonsoft.Json.Bson.BsonReader : JsonReader {
private int MaxCharBytesSize
private Byte[] SeqRange1
private Byte[] SeqRange2
private Byte[] SeqRange3
private Byte[] SeqRange4
private BinaryReader _reader
private List`1<ContainerContext> _stack
private Byte[] _byteBuffer
private Char[] _charBuffer
private BsonType _currentElementType
private BsonReaderState _bsonReaderState
private ContainerContext _currentContext
private bool _readRootValueAsArray
private bool _jsonNet35BinaryCompatibility
private DateTimeKind _dateTimeKindHandling
public bool JsonNet35BinaryCompatibility
public bool ReadRootValueAsArray
public DateTimeKind DateTimeKindHandling
public bool get_JsonNet35BinaryCompatibility()
public void set_JsonNet35BinaryCompatibility(bool value)
public bool get_ReadRootValueAsArray()
public void set_ReadRootValueAsArray(bool value)
public DateTimeKind get_DateTimeKindHandling()
public void set_DateTimeKindHandling(DateTimeKind value)
public void .ctor(Stream stream)
public void .ctor(BinaryReader reader)
public void .ctor(Stream stream, bool readRootValueAsArray, DateTimeKind dateTimeKindHandling)
public void .ctor(BinaryReader reader, bool readRootValueAsArray, DateTimeKind dateTimeKindHandling)
private string ReadElement()
public bool Read()
public void Close()
private bool ReadCodeWScope()
private bool ReadReference()
private bool ReadNormal()
private void PopContext()
private void PushContext(ContainerContext newContext)
private byte ReadByte()
private void ReadType(BsonType type)
private Byte[] ReadBinary(BsonBinaryType& binaryType)
private string ReadString()
private string ReadLengthString()
private string GetString(int length)
private int GetLastFullCharStop(int start)
private int BytesInSequence(byte b)
private void EnsureBuffers()
private double ReadDouble()
private int ReadInt32()
private long ReadInt64()
private BsonType ReadType()
private void MovePosition(int count)
private Byte[] ReadBytes(int count)
}
internal Newtonsoft.Json.Bson.BsonRegex : BsonToken {
private BsonString <Pattern>k__BackingField
private BsonString <Options>k__BackingField
public BsonString Pattern
public BsonString Options
public BsonType Type
public BsonString get_Pattern()
public void set_Pattern(BsonString value)
public BsonString get_Options()
public void set_Options(BsonString value)
public void .ctor(string pattern, string options)
public BsonType get_Type()
}
internal Newtonsoft.Json.Bson.BsonString : BsonValue {
private int <ByteCount>k__BackingField
private bool <IncludeLength>k__BackingField
public int ByteCount
public bool IncludeLength
public int get_ByteCount()
public void set_ByteCount(int value)
public bool get_IncludeLength()
public void set_IncludeLength(bool value)
public void .ctor(object value, bool includeLength)
}
internal Newtonsoft.Json.Bson.BsonToken : object {
private BsonToken <Parent>k__BackingField
private int <CalculatedSize>k__BackingField
public BsonType Type
public BsonToken Parent
public int CalculatedSize
public BsonType get_Type()
public BsonToken get_Parent()
public void set_Parent(BsonToken value)
public int get_CalculatedSize()
public void set_CalculatedSize(int value)
}
internal Newtonsoft.Json.Bson.BsonType : Enum {
public sbyte value__
public BsonType Number
public BsonType String
public BsonType Object
public BsonType Array
public BsonType Binary
public BsonType Undefined
public BsonType Oid
public BsonType Boolean
public BsonType Date
public BsonType Null
public BsonType Regex
public BsonType Reference
public BsonType Code
public BsonType Symbol
public BsonType CodeWScope
public BsonType Integer
public BsonType TimeStamp
public BsonType Long
public BsonType MinKey
public BsonType MaxKey
}
internal Newtonsoft.Json.Bson.BsonValue : BsonToken {
private object _value
private BsonType _type
public object Value
public BsonType Type
public void .ctor(object value, BsonType type)
public object get_Value()
public BsonType get_Type()
}
public Newtonsoft.Json.Bson.BsonWriter : JsonWriter {
private BsonBinaryWriter _writer
private BsonToken _root
private BsonToken _parent
private string _propertyName
public DateTimeKind DateTimeKindHandling
public DateTimeKind get_DateTimeKindHandling()
public void set_DateTimeKindHandling(DateTimeKind value)
public void .ctor(Stream stream)
public void .ctor(BinaryWriter writer)
public void Flush()
protected void WriteEnd(JsonToken token)
public void WriteComment(string text)
public void WriteStartConstructor(string name)
public void WriteRaw(string json)
public void WriteRawValue(string json)
public void WriteStartArray()
public void WriteStartObject()
public void WritePropertyName(string name)
public void Close()
private void AddParent(BsonToken container)
private void RemoveParent()
private void AddValue(object value, BsonType type)
internal void AddToken(BsonToken token)
public void WriteValue(object value)
public void WriteNull()
public void WriteUndefined()
public void WriteValue(string value)
public void WriteValue(int value)
public void WriteValue(UInt32 value)
public void WriteValue(long value)
public void WriteValue(ulong value)
public void WriteValue(float value)
public void WriteValue(double value)
public void WriteValue(bool value)
public void WriteValue(short value)
public void WriteValue(ushort value)
public void WriteValue(char value)
public void WriteValue(byte value)
public void WriteValue(sbyte value)
public void WriteValue(decimal value)
public void WriteValue(DateTime value)
public void WriteValue(DateTimeOffset value)
public void WriteValue(Byte[] value)
public void WriteValue(Guid value)
public void WriteValue(TimeSpan value)
public void WriteValue(Uri value)
public void WriteObjectId(Byte[] value)
public void WriteRegex(string pattern, string options)
}
public Newtonsoft.Json.ConstructorHandling : Enum {
public int value__
public ConstructorHandling Default
public ConstructorHandling AllowNonPublicDefaultConstructor
}
public Newtonsoft.Json.Converters.BinaryConverter : JsonConverter {
private string BinaryTypeName
private string BinaryToArrayName
private ReflectionObject _reflectionObject
public void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
private Byte[] GetByteArray(object value)
private void EnsureReflectionObject(Type t)
public object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
private Byte[] ReadByteArray(JsonReader reader)
public bool CanConvert(Type objectType)
}
public Newtonsoft.Json.Converters.BsonObjectIdConverter : JsonConverter {
public void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
public object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
public bool CanConvert(Type objectType)
}
public Newtonsoft.Json.Converters.CustomCreationConverter`1 : JsonConverter {
public bool CanWrite
public void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
public object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
public T Create(Type objectType)
public bool CanConvert(Type objectType)
public bool get_CanWrite()
}
public Newtonsoft.Json.Converters.DataSetConverter : JsonConverter {
public void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
public object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
public bool CanConvert(Type valueType)
}
public Newtonsoft.Json.Converters.DataTableConverter : JsonConverter {
public void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
public object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
private void CreateRow(JsonReader reader, DataTable dt, JsonSerializer serializer)
private Type GetColumnDataType(JsonReader reader)
public bool CanConvert(Type valueType)
}
public Newtonsoft.Json.Converters.DateTimeConverterBase : JsonConverter {
public bool CanConvert(Type objectType)
}
public Newtonsoft.Json.Converters.EntityKeyMemberConverter : JsonConverter {
private string EntityKeyMemberFullTypeName
private string KeyPropertyName
private string TypePropertyName
private string ValuePropertyName
private ReflectionObject _reflectionObject
public void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
private void ReadAndAssertProperty(JsonReader reader, string propertyName)
public object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
private void EnsureReflectionObject(Type objectType)
public bool CanConvert(Type objectType)
}
public Newtonsoft.Json.Converters.IsoDateTimeConverter : DateTimeConverterBase {
private string DefaultDateTimeFormat
private DateTimeStyles _dateTimeStyles
private string _dateTimeFormat
private CultureInfo _culture
public DateTimeStyles DateTimeStyles
public string DateTimeFormat
public CultureInfo Culture
public DateTimeStyles get_DateTimeStyles()
public void set_DateTimeStyles(DateTimeStyles value)
public string get_DateTimeFormat()
public void set_DateTimeFormat(string value)
public CultureInfo get_Culture()
public void set_Culture(CultureInfo value)
public void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
public object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
}
internal Newtonsoft.Json.Converters.IXmlDeclaration {
public string Version
public string Encoding
public string Standalone
public string get_Version()
public string get_Encoding()
public void set_Encoding(string value)
public string get_Standalone()
public void set_Standalone(string value)
}
internal Newtonsoft.Json.Converters.IXmlDocument {
public IXmlElement DocumentElement
public IXmlNode CreateComment(string text)
public IXmlNode CreateTextNode(string text)
public IXmlNode CreateCDataSection(string data)
public IXmlNode CreateWhitespace(string text)
public IXmlNode CreateSignificantWhitespace(string text)
public IXmlNode CreateXmlDeclaration(string version, string encoding, string standalone)
public IXmlNode CreateXmlDocumentType(string name, string publicId, string systemId, string internalSubset)
public IXmlNode CreateProcessingInstruction(string target, string data)
public IXmlElement CreateElement(string elementName)
public IXmlElement CreateElement(string qualifiedName, string namespaceUri)
public IXmlNode CreateAttribute(string name, string value)
public IXmlNode CreateAttribute(string qualifiedName, string namespaceUri, string value)
public IXmlElement get_DocumentElement()
}
internal Newtonsoft.Json.Converters.IXmlDocumentType {
public string Name
public string System
public string Public
public string InternalSubset
public string get_Name()
public string get_System()
public string get_Public()
public string get_InternalSubset()
}
internal Newtonsoft.Json.Converters.IXmlElement {
public bool IsEmpty
public void SetAttributeNode(IXmlNode attribute)
public string GetPrefixOfNamespace(string namespaceUri)
public bool get_IsEmpty()
}
internal Newtonsoft.Json.Converters.IXmlNode {
public XmlNodeType NodeType
public string LocalName
public IList`1<IXmlNode> ChildNodes
public IList`1<IXmlNode> Attributes
public IXmlNode ParentNode
public string Value
public string NamespaceUri
public object WrappedNode
public XmlNodeType get_NodeType()
public string get_LocalName()
public IList`1<IXmlNode> get_ChildNodes()
public IList`1<IXmlNode> get_Attributes()
public IXmlNode get_ParentNode()
public string get_Value()
public void set_Value(string value)
public IXmlNode AppendChild(IXmlNode newChild)
public string get_NamespaceUri()
public object get_WrappedNode()
}
public Newtonsoft.Json.Converters.JavaScriptDateTimeConverter : DateTimeConverterBase {
public void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
public object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
}
public Newtonsoft.Json.Converters.KeyValuePairConverter : JsonConverter {
private string KeyName
private string ValueName
private ThreadSafeStore`2<Type, ReflectionObject> ReflectionObjectPerType
private ReflectionObject InitializeReflectionObject(Type t)
public void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
public object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
public bool CanConvert(Type objectType)
}
public Newtonsoft.Json.Converters.RegexConverter : JsonConverter {
private string PatternName
private string OptionsName
public void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
private bool HasFlag(RegexOptions options, RegexOptions flag)
private void WriteBson(BsonWriter writer, Regex regex)
private void WriteJson(JsonWriter writer, Regex regex, JsonSerializer serializer)
public object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
private object ReadRegexString(JsonReader reader)
private Regex ReadRegexObject(JsonReader reader, JsonSerializer serializer)
public bool CanConvert(Type objectType)
}
public Newtonsoft.Json.Converters.StringEnumConverter : JsonConverter {
private bool <CamelCaseText>k__BackingField
private bool <AllowIntegerValues>k__BackingField
public bool CamelCaseText
public bool AllowIntegerValues
public bool get_CamelCaseText()
public void set_CamelCaseText(bool value)
public bool get_AllowIntegerValues()
public void set_AllowIntegerValues(bool value)
public void .ctor(bool camelCaseText)
public void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
public object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
public bool CanConvert(Type objectType)
}
public Newtonsoft.Json.Converters.VersionConverter : JsonConverter {
public void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
public object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
public bool CanConvert(Type objectType)
}
internal Newtonsoft.Json.Converters.XAttributeWrapper : XObjectWrapper {
private XAttribute Attribute
public string Value
public string LocalName
public string NamespaceUri
public IXmlNode ParentNode
private XAttribute get_Attribute()
public void .ctor(XAttribute attribute)
public string get_Value()
public void set_Value(string value)
public string get_LocalName()
public string get_NamespaceUri()
public IXmlNode get_ParentNode()
}
internal Newtonsoft.Json.Converters.XCommentWrapper : XObjectWrapper {
private XComment Text
public string Value
public IXmlNode ParentNode
private XComment get_Text()
public void .ctor(XComment text)
public string get_Value()
public void set_Value(string value)
public IXmlNode get_ParentNode()
}
internal Newtonsoft.Json.Converters.XContainerWrapper : XObjectWrapper {
private IList`1<IXmlNode> _childNodes
private XContainer Container
public IList`1<IXmlNode> ChildNodes
public IXmlNode ParentNode
private XContainer get_Container()
public void .ctor(XContainer container)
public IList`1<IXmlNode> get_ChildNodes()
public IXmlNode get_ParentNode()
internal IXmlNode WrapNode(XObject node)
public IXmlNode AppendChild(IXmlNode newChild)
}
internal Newtonsoft.Json.Converters.XDeclarationWrapper : XObjectWrapper {
private XDeclaration <Declaration>k__BackingField
internal XDeclaration Declaration
public XmlNodeType NodeType
public string Version
public string Encoding
public string Standalone
internal XDeclaration get_Declaration()
private void set_Declaration(XDeclaration value)
public void .ctor(XDeclaration declaration)
public XmlNodeType get_NodeType()
public string get_Version()
public string get_Encoding()
public void set_Encoding(string value)
public string get_Standalone()
public void set_Standalone(string value)
}
internal Newtonsoft.Json.Converters.XDocumentTypeWrapper : XObjectWrapper {
private XDocumentType _documentType
public string Name
public string System
public string Public
public string InternalSubset
public string LocalName
public void .ctor(XDocumentType documentType)
public string get_Name()
public string get_System()
public string get_Public()
public string get_InternalSubset()
public string get_LocalName()
}
internal Newtonsoft.Json.Converters.XDocumentWrapper : XContainerWrapper {
private XDocument Document
public IList`1<IXmlNode> ChildNodes
public IXmlElement DocumentElement
private XDocument get_Document()
public void .ctor(XDocument document)
public IList`1<IXmlNode> get_ChildNodes()
public IXmlNode CreateComment(string text)
public IXmlNode CreateTextNode(string text)
public IXmlNode CreateCDataSection(string data)
public IXmlNode CreateWhitespace(string text)
public IXmlNode CreateSignificantWhitespace(string text)
public IXmlNode CreateXmlDeclaration(string version, string encoding, string standalone)
public IXmlNode CreateXmlDocumentType(string name, string publicId, string systemId, string internalSubset)
public IXmlNode CreateProcessingInstruction(string target, string data)
public IXmlElement CreateElement(string elementName)
public IXmlElement CreateElement(string qualifiedName, string namespaceUri)
public IXmlNode CreateAttribute(string name, string value)
public IXmlNode CreateAttribute(string qualifiedName, string namespaceUri, string value)
public IXmlElement get_DocumentElement()
public IXmlNode AppendChild(IXmlNode newChild)
}
internal Newtonsoft.Json.Converters.XElementWrapper : XContainerWrapper {
private XElement Element
public IList`1<IXmlNode> Attributes
public string Value
public string LocalName
public string NamespaceUri
public bool IsEmpty
private XElement get_Element()
public void .ctor(XElement element)
public void SetAttributeNode(IXmlNode attribute)
public IList`1<IXmlNode> get_Attributes()
public string get_Value()
public void set_Value(string value)
public string get_LocalName()
public string get_NamespaceUri()
public string GetPrefixOfNamespace(string namespaceUri)
public bool get_IsEmpty()
}
internal Newtonsoft.Json.Converters.XmlDeclarationWrapper : XmlNodeWrapper {
private XmlDeclaration _declaration
public string Version
public string Encoding
public string Standalone
public void .ctor(XmlDeclaration declaration)
public string get_Version()
public string get_Encoding()
public void set_Encoding(string value)
public string get_Standalone()
public void set_Standalone(string value)
}
internal Newtonsoft.Json.Converters.XmlDocumentTypeWrapper : XmlNodeWrapper {
private XmlDocumentType _documentType
public string Name
public string System
public string Public
public string InternalSubset
public string LocalName
public void .ctor(XmlDocumentType documentType)
public string get_Name()
public string get_System()
public string get_Public()
public string get_InternalSubset()
public string get_LocalName()
}
internal Newtonsoft.Json.Converters.XmlDocumentWrapper : XmlNodeWrapper {
private XmlDocument _document
public IXmlElement DocumentElement
public void .ctor(XmlDocument document)
public IXmlNode CreateComment(string data)
public IXmlNode CreateTextNode(string text)
public IXmlNode CreateCDataSection(string data)
public IXmlNode CreateWhitespace(string text)
public IXmlNode CreateSignificantWhitespace(string text)
public IXmlNode CreateXmlDeclaration(string version, string encoding, string standalone)
public IXmlNode CreateXmlDocumentType(string name, string publicId, string systemId, string internalSubset)
public IXmlNode CreateProcessingInstruction(string target, string data)
public IXmlElement CreateElement(string elementName)
public IXmlElement CreateElement(string qualifiedName, string namespaceUri)
public IXmlNode CreateAttribute(string name, string value)
public IXmlNode CreateAttribute(string qualifiedName, string namespaceUri, string value)
public IXmlElement get_DocumentElement()
}
internal Newtonsoft.Json.Converters.XmlElementWrapper : XmlNodeWrapper {
private XmlElement _element
public bool IsEmpty
public void .ctor(XmlElement element)
public void SetAttributeNode(IXmlNode attribute)
public string GetPrefixOfNamespace(string namespaceUri)
public bool get_IsEmpty()
}
public Newtonsoft.Json.Converters.XmlNodeConverter : JsonConverter {
private string TextName
private string CommentName
private string CDataName
private string WhitespaceName
private string SignificantWhitespaceName
private string DeclarationName
private string JsonNamespaceUri
private string <DeserializeRootElementName>k__BackingField
private bool <WriteArrayAttribute>k__BackingField
private bool <OmitRootObject>k__BackingField
public string DeserializeRootElementName
public bool WriteArrayAttribute
public bool OmitRootObject
public string get_DeserializeRootElementName()
public void set_DeserializeRootElementName(string value)
public bool get_WriteArrayAttribute()
public void set_WriteArrayAttribute(bool value)
public bool get_OmitRootObject()
public void set_OmitRootObject(bool value)
public void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
private IXmlNode WrapXml(object value)
private void PushParentNamespaces(IXmlNode node, XmlNamespaceManager manager)
private string ResolveFullName(IXmlNode node, XmlNamespaceManager manager)
private string GetPropertyName(IXmlNode node, XmlNamespaceManager manager)
private bool IsArray(IXmlNode node)
private void SerializeGroupedNodes(JsonWriter writer, IXmlNode node, XmlNamespaceManager manager, bool writePropertyName)
private void SerializeNode(JsonWriter writer, IXmlNode node, XmlNamespaceManager manager, bool writePropertyName)
public object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
private void DeserializeValue(JsonReader reader, IXmlDocument document, XmlNamespaceManager manager, string propertyName, IXmlNode currentNode)
private void ReadElement(JsonReader reader, IXmlDocument document, IXmlNode currentNode, string propertyName, XmlNamespaceManager manager)
private void CreateElement(JsonReader reader, IXmlDocument document, IXmlNode currentNode, string elementName, XmlNamespaceManager manager, string elementPrefix, Dictionary`2<string, string> attributeNameValues)
private void AddAttribute(JsonReader reader, IXmlDocument document, IXmlNode currentNode, string attributeName, XmlNamespaceManager manager, string attributePrefix)
private string ConvertTokenToXmlValue(JsonReader reader)
private void ReadArrayElements(JsonReader reader, IXmlDocument document, string propertyName, IXmlNode currentNode, XmlNamespaceManager manager)
private void AddJsonArrayAttribute(IXmlElement element, IXmlDocument document)
private Dictionary`2<string, string> ReadAttributeElements(JsonReader reader, XmlNamespaceManager manager)
private void CreateInstruction(JsonReader reader, IXmlDocument document, IXmlNode currentNode, string propertyName)
private void CreateDocumentType(JsonReader reader, IXmlDocument document, IXmlNode currentNode)
private IXmlElement CreateElement(string elementName, IXmlDocument document, string elementPrefix, XmlNamespaceManager manager)
private void DeserializeNode(JsonReader reader, IXmlDocument document, XmlNamespaceManager manager, IXmlNode currentNode)
private bool IsNamespaceAttribute(string attributeName, String& prefix)
private IEnumerable`1<IXmlNode> ValueAttributes(IEnumerable`1<IXmlNode> c)
public bool CanConvert(Type valueType)
}
internal Newtonsoft.Json.Converters.XmlNodeWrapper : object {
private XmlNode _node
private IList`1<IXmlNode> _childNodes
public object WrappedNode
public XmlNodeType NodeType
public string LocalName
public IList`1<IXmlNode> ChildNodes
public IList`1<IXmlNode> Attributes
public IXmlNode ParentNode
public string Value
public string NamespaceUri
public void .ctor(XmlNode node)
public object get_WrappedNode()
public XmlNodeType get_NodeType()
public string get_LocalName()
public IList`1<IXmlNode> get_ChildNodes()
internal IXmlNode WrapNode(XmlNode node)
public IList`1<IXmlNode> get_Attributes()
public IXmlNode get_ParentNode()
public string get_Value()
public void set_Value(string value)
public IXmlNode AppendChild(IXmlNode newChild)
public string get_NamespaceUri()
}
internal Newtonsoft.Json.Converters.XObjectWrapper : object {
private XObject _xmlObject
public object WrappedNode
public XmlNodeType NodeType
public string LocalName
public IList`1<IXmlNode> ChildNodes
public IList`1<IXmlNode> Attributes
public IXmlNode ParentNode
public string Value
public string NamespaceUri
public void .ctor(XObject xmlObject)
public object get_WrappedNode()
public XmlNodeType get_NodeType()
public string get_LocalName()
public IList`1<IXmlNode> get_ChildNodes()
public IList`1<IXmlNode> get_Attributes()
public IXmlNode get_ParentNode()
public string get_Value()
public void set_Value(string value)
public IXmlNode AppendChild(IXmlNode newChild)
public string get_NamespaceUri()
}
internal Newtonsoft.Json.Converters.XProcessingInstructionWrapper : XObjectWrapper {
private XProcessingInstruction ProcessingInstruction
public string LocalName
public string Value
private XProcessingInstruction get_ProcessingInstruction()
public void .ctor(XProcessingInstruction processingInstruction)
public string get_LocalName()
public string get_Value()
public void set_Value(string value)
}
internal Newtonsoft.Json.Converters.XTextWrapper : XObjectWrapper {
private XText Text
public string Value
public IXmlNode ParentNode
private XText get_Text()
public void .ctor(XText text)
public string get_Value()
public void set_Value(string value)
public IXmlNode get_ParentNode()
}
public Newtonsoft.Json.DateFormatHandling : Enum {
public int value__
public DateFormatHandling IsoDateFormat
public DateFormatHandling MicrosoftDateFormat
}
public Newtonsoft.Json.DateParseHandling : Enum {
public int value__
public DateParseHandling None
public DateParseHandling DateTime
public DateParseHandling DateTimeOffset
}
public Newtonsoft.Json.DateTimeZoneHandling : Enum {
public int value__
public DateTimeZoneHandling Local
public DateTimeZoneHandling Utc
public DateTimeZoneHandling Unspecified
public DateTimeZoneHandling RoundtripKind
}
public Newtonsoft.Json.DefaultValueHandling : Enum {
public int value__
public DefaultValueHandling Include
public DefaultValueHandling Ignore
public DefaultValueHandling Populate
public DefaultValueHandling IgnoreAndPopulate
}
public Newtonsoft.Json.FloatFormatHandling : Enum {
public int value__
public FloatFormatHandling String
public FloatFormatHandling Symbol
public FloatFormatHandling DefaultValue
}
public Newtonsoft.Json.FloatParseHandling : Enum {
public int value__
public FloatParseHandling Double
public FloatParseHandling Decimal
}
public Newtonsoft.Json.Formatting : Enum {
public int value__
public Formatting None
public Formatting Indented
}
public Newtonsoft.Json.IArrayPool`1 {
public T[] Rent(int minimumLength)
public void Return(T[] array)
}
public Newtonsoft.Json.IJsonLineInfo {
public int LineNumber
public int LinePosition
public bool HasLineInfo()
public int get_LineNumber()
public int get_LinePosition()
}
public Newtonsoft.Json.JsonArrayAttribute : JsonContainerAttribute {
private bool _allowNullItems
public bool AllowNullItems
public bool get_AllowNullItems()
public void set_AllowNullItems(bool value)
public void .ctor(bool allowNullItems)
public void .ctor(string id)
}
public Newtonsoft.Json.JsonContainerAttribute : Attribute {
private string <Id>k__BackingField
private string <Title>k__BackingField
private string <Description>k__BackingField
private Type <ItemConverterType>k__BackingField
private Object[] <ItemConverterParameters>k__BackingField
internal Nullable`1<bool> _isReference
internal Nullable`1<bool> _itemIsReference
internal Nullable`1<ReferenceLoopHandling> _itemReferenceLoopHandling
internal Nullable`1<TypeNameHandling> _itemTypeNameHandling
public string Id
public string Title
public string Description
public Type ItemConverterType
public Object[] ItemConverterParameters
public bool IsReference
public bool ItemIsReference
public ReferenceLoopHandling ItemReferenceLoopHandling
public TypeNameHandling ItemTypeNameHandling
public string get_Id()
public void set_Id(string value)
public string get_Title()
public void set_Title(string value)
public string get_Description()
public void set_Description(string value)
public Type get_ItemConverterType()
public void set_ItemConverterType(Type value)
public Object[] get_ItemConverterParameters()
public void set_ItemConverterParameters(Object[] value)
public bool get_IsReference()
public void set_IsReference(bool value)
public bool get_ItemIsReference()
public void set_ItemIsReference(bool value)
public ReferenceLoopHandling get_ItemReferenceLoopHandling()
public void set_ItemReferenceLoopHandling(ReferenceLoopHandling value)
public TypeNameHandling get_ItemTypeNameHandling()
public void set_ItemTypeNameHandling(TypeNameHandling value)
protected void .ctor(string id)
}
internal Newtonsoft.Json.JsonContainerType : Enum {
public int value__
public JsonContainerType None
public JsonContainerType Object
public JsonContainerType Array
public JsonContainerType Constructor
}
public Newtonsoft.Json.JsonConvert : object {
private Func`1<JsonSerializerSettings> <DefaultSettings>k__BackingField
public string True
public string False
public string Null
public string Undefined
public string PositiveInfinity
public string NegativeInfinity
public string NaN
public Func`1<JsonSerializerSettings> DefaultSettings
public Func`1<JsonSerializerSettings> get_DefaultSettings()
public void set_DefaultSettings(Func`1<JsonSerializerSettings> value)
public string ToString(DateTime value)
public string ToString(DateTime value, DateFormatHandling format, DateTimeZoneHandling timeZoneHandling)
public string ToString(DateTimeOffset value)
public string ToString(DateTimeOffset value, DateFormatHandling format)
public string ToString(bool value)
public string ToString(char value)
public string ToString(Enum value)
public string ToString(int value)
public string ToString(short value)
public string ToString(ushort value)
public string ToString(UInt32 value)
public string ToString(long value)
public string ToString(ulong value)
public string ToString(float value)
internal string ToString(float value, FloatFormatHandling floatFormatHandling, char quoteChar, bool nullable)
private string EnsureFloatFormat(double value, string text, FloatFormatHandling floatFormatHandling, char quoteChar, bool nullable)
public string ToString(double value)
internal string ToString(double value, FloatFormatHandling floatFormatHandling, char quoteChar, bool nullable)
private string EnsureDecimalPlace(double value, string text)
private string EnsureDecimalPlace(string text)
public string ToString(byte value)
public string ToString(sbyte value)
public string ToString(decimal value)
public string ToString(Guid value)
internal string ToString(Guid value, char quoteChar)
public string ToString(TimeSpan value)
internal string ToString(TimeSpan value, char quoteChar)
public string ToString(Uri value)
internal string ToString(Uri value, char quoteChar)
public string ToString(string value)
public string ToString(string value, char delimiter)
public string ToString(string value, char delimiter, StringEscapeHandling stringEscapeHandling)
public string ToString(object value)
public string SerializeObject(object value)
public string SerializeObject(object value, Formatting formatting)
public string SerializeObject(object value, JsonConverter[] converters)
public string SerializeObject(object value, Formatting formatting, JsonConverter[] converters)
public string SerializeObject(object value, JsonSerializerSettings settings)
public string SerializeObject(object value, Type type, JsonSerializerSettings settings)
public string SerializeObject(object value, Formatting formatting, JsonSerializerSettings settings)
public string SerializeObject(object value, Type type, Formatting formatting, JsonSerializerSettings settings)
private string SerializeObjectInternal(object value, Type type, JsonSerializer jsonSerializer)
public object DeserializeObject(string value)
public object DeserializeObject(string value, JsonSerializerSettings settings)
public object DeserializeObject(string value, Type type)
public T DeserializeObject(string value)
public T DeserializeAnonymousType(string value, T anonymousTypeObject)
public T DeserializeAnonymousType(string value, T anonymousTypeObject, JsonSerializerSettings settings)
public T DeserializeObject(string value, JsonConverter[] converters)
public T DeserializeObject(string value, JsonSerializerSettings settings)
public object DeserializeObject(string value, Type type, JsonConverter[] converters)
public object DeserializeObject(string value, Type type, JsonSerializerSettings settings)
public void PopulateObject(string value, object target)
public void PopulateObject(string value, object target, JsonSerializerSettings settings)
public string SerializeXmlNode(XmlNode node)
public string SerializeXmlNode(XmlNode node, Formatting formatting)
public string SerializeXmlNode(XmlNode node, Formatting formatting, bool omitRootObject)
public XmlDocument DeserializeXmlNode(string value)
public XmlDocument DeserializeXmlNode(string value, string deserializeRootElementName)
public XmlDocument DeserializeXmlNode(string value, string deserializeRootElementName, bool writeArrayAttribute)
public string SerializeXNode(XObject node)
public string SerializeXNode(XObject node, Formatting formatting)
public string SerializeXNode(XObject node, Formatting formatting, bool omitRootObject)
public XDocument DeserializeXNode(string value)
public XDocument DeserializeXNode(string value, string deserializeRootElementName)
public XDocument DeserializeXNode(string value, string deserializeRootElementName, bool writeArrayAttribute)
}
public Newtonsoft.Json.JsonConverter : object {
public bool CanRead
public bool CanWrite
public void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
public object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
public bool CanConvert(Type objectType)
public JsonSchema GetSchema()
public bool get_CanRead()
public bool get_CanWrite()
}
public Newtonsoft.Json.JsonConverterAttribute : Attribute {
private Type _converterType
private Object[] <ConverterParameters>k__BackingField
public Type ConverterType
public Object[] ConverterParameters
public Type get_ConverterType()
public Object[] get_ConverterParameters()
private void set_ConverterParameters(Object[] value)
public void .ctor(Type converterType)
public void .ctor(Type converterType, Object[] converterParameters)
}
public Newtonsoft.Json.JsonDictionaryAttribute : JsonContainerAttribute {
public void .ctor(string id)
}
public Newtonsoft.Json.JsonException : Exception {
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
public void .ctor(SerializationInfo info, StreamingContext context)
internal JsonException Create(IJsonLineInfo lineInfo, string path, string message)
}
public Newtonsoft.Json.JsonExtensionDataAttribute : Attribute {
private bool <WriteData>k__BackingField
private bool <ReadData>k__BackingField
public bool WriteData
public bool ReadData
public bool get_WriteData()
public void set_WriteData(bool value)
public bool get_ReadData()
public void set_ReadData(bool value)
}
public Newtonsoft.Json.JsonObjectAttribute : JsonContainerAttribute {
private MemberSerialization _memberSerialization
internal Nullable`1<Required> _itemRequired
public MemberSerialization MemberSerialization
public Required ItemRequired
public MemberSerialization get_MemberSerialization()
public void set_MemberSerialization(MemberSerialization value)
public Required get_ItemRequired()
public void set_ItemRequired(Required value)
public void .ctor(MemberSerialization memberSerialization)
public void .ctor(string id)
}
internal Newtonsoft.Json.JsonPosition : ValueType {
private Char[] SpecialCharacters
internal JsonContainerType Type
internal int Position
internal string PropertyName
internal bool HasIndex
public void .ctor(JsonContainerType type)
internal int CalculateLength()
internal void WriteTo(StringBuilder sb)
internal bool TypeHasIndex(JsonContainerType type)
internal string BuildPath(List`1<JsonPosition> positions, Nullable`1<JsonPosition> currentPosition)
internal string FormatMessage(IJsonLineInfo lineInfo, string path, string message)
}
public Newtonsoft.Json.JsonPropertyAttribute : Attribute {
internal Nullable`1<NullValueHandling> _nullValueHandling
internal Nullable`1<DefaultValueHandling> _defaultValueHandling
internal Nullable`1<ReferenceLoopHandling> _referenceLoopHandling
internal Nullable`1<ObjectCreationHandling> _objectCreationHandling
internal Nullable`1<TypeNameHandling> _typeNameHandling
internal Nullable`1<bool> _isReference
internal Nullable`1<int> _order
internal Nullable`1<Required> _required
internal Nullable`1<bool> _itemIsReference
internal Nullable`1<ReferenceLoopHandling> _itemReferenceLoopHandling
internal Nullable`1<TypeNameHandling> _itemTypeNameHandling
private Type <ItemConverterType>k__BackingField
private Object[] <ItemConverterParameters>k__BackingField
private string <PropertyName>k__BackingField
public Type ItemConverterType
public Object[] ItemConverterParameters
public NullValueHandling NullValueHandling
public DefaultValueHandling DefaultValueHandling
public ReferenceLoopHandling ReferenceLoopHandling
public ObjectCreationHandling ObjectCreationHandling
public TypeNameHandling TypeNameHandling
public bool IsReference
public int Order
public Required Required
public string PropertyName
public ReferenceLoopHandling ItemReferenceLoopHandling
public TypeNameHandling ItemTypeNameHandling
public bool ItemIsReference
public Type get_ItemConverterType()
public void set_ItemConverterType(Type value)
public Object[] get_ItemConverterParameters()
public void set_ItemConverterParameters(Object[] value)
public NullValueHandling get_NullValueHandling()
public void set_NullValueHandling(NullValueHandling value)
public DefaultValueHandling get_DefaultValueHandling()
public void set_DefaultValueHandling(DefaultValueHandling value)
public ReferenceLoopHandling get_ReferenceLoopHandling()
public void set_ReferenceLoopHandling(ReferenceLoopHandling value)
public ObjectCreationHandling get_ObjectCreationHandling()
public void set_ObjectCreationHandling(ObjectCreationHandling value)
public TypeNameHandling get_TypeNameHandling()
public void set_TypeNameHandling(TypeNameHandling value)
public bool get_IsReference()
public void set_IsReference(bool value)
public int get_Order()
public void set_Order(int value)
public Required get_Required()
public void set_Required(Required value)
public string get_PropertyName()
public void set_PropertyName(string value)
public ReferenceLoopHandling get_ItemReferenceLoopHandling()
public void set_ItemReferenceLoopHandling(ReferenceLoopHandling value)
public TypeNameHandling get_ItemTypeNameHandling()
public void set_ItemTypeNameHandling(TypeNameHandling value)
public bool get_ItemIsReference()
public void set_ItemIsReference(bool value)
public void .ctor(string propertyName)
}
public Newtonsoft.Json.JsonReader : object {
private JsonToken _tokenType
private object _value
internal char _quoteChar
internal State _currentState
private JsonPosition _currentPosition
private CultureInfo _culture
private DateTimeZoneHandling _dateTimeZoneHandling
private Nullable`1<int> _maxDepth
private bool _hasExceededMaxDepth
internal DateParseHandling _dateParseHandling
internal FloatParseHandling _floatParseHandling
private string _dateFormatString
private List`1<JsonPosition> _stack
private bool <CloseInput>k__BackingField
private bool <SupportMultipleContent>k__BackingField
protected State CurrentState
public bool CloseInput
public bool SupportMultipleContent
public char QuoteChar
public DateTimeZoneHandling DateTimeZoneHandling
public DateParseHandling DateParseHandling
public FloatParseHandling FloatParseHandling
public string DateFormatString
public Nullable`1<int> MaxDepth
public JsonToken TokenType
public object Value
public Type ValueType
public int Depth
public string Path
public CultureInfo Culture
protected State get_CurrentState()
public bool get_CloseInput()
public void set_CloseInput(bool value)
public bool get_SupportMultipleContent()
public void set_SupportMultipleContent(bool value)
public char get_QuoteChar()
protected internal void set_QuoteChar(char value)
public DateTimeZoneHandling get_DateTimeZoneHandling()
public void set_DateTimeZoneHandling(DateTimeZoneHandling value)
public DateParseHandling get_DateParseHandling()
public void set_DateParseHandling(DateParseHandling value)
public FloatParseHandling get_FloatParseHandling()
public void set_FloatParseHandling(FloatParseHandling value)
public string get_DateFormatString()
public void set_DateFormatString(string value)
public Nullable`1<int> get_MaxDepth()
public void set_MaxDepth(Nullable`1<int> value)
public JsonToken get_TokenType()
public object get_Value()
public Type get_ValueType()
public int get_Depth()
public string get_Path()
public CultureInfo get_Culture()
public void set_Culture(CultureInfo value)
internal JsonPosition GetPosition(int depth)
private void Push(JsonContainerType value)
private JsonContainerType Pop()
private JsonContainerType Peek()
public bool Read()
public Nullable`1<int> ReadAsInt32()
internal Nullable`1<int> ReadInt32String(string s)
public string ReadAsString()
public Byte[] ReadAsBytes()
internal Byte[] ReadArrayIntoByteArray()
public Nullable`1<double> ReadAsDouble()
internal Nullable`1<double> ReadDoubleString(string s)
public Nullable`1<bool> ReadAsBoolean()
internal Nullable`1<bool> ReadBooleanString(string s)
public Nullable`1<decimal> ReadAsDecimal()
internal Nullable`1<decimal> ReadDecimalString(string s)
public Nullable`1<DateTime> ReadAsDateTime()
internal Nullable`1<DateTime> ReadDateTimeString(string s)
public Nullable`1<DateTimeOffset> ReadAsDateTimeOffset()
internal Nullable`1<DateTimeOffset> ReadDateTimeOffsetString(string s)
internal void ReaderReadAndAssert()
internal JsonReaderException CreateUnexpectedEndException()
internal void ReadIntoWrappedTypeObject()
public void Skip()
protected void SetToken(JsonToken newToken)
protected void SetToken(JsonToken newToken, object value)
internal void SetToken(JsonToken newToken, object value, bool updateIndex)
internal void SetPostValueState(bool updateIndex)
private void UpdateScopeWithFinishedValue()
private void ValidateEnd(JsonToken endToken)
protected void SetStateBasedOnCurrent()
private void SetFinished()
private JsonContainerType GetTypeForCloseToken(JsonToken token)
private void System.IDisposable.Dispose()
protected void Dispose(bool disposing)
public void Close()
internal void ReadAndAssert()
internal bool ReadAndMoveToContent()
internal bool MoveToContent()
private JsonToken GetContentToken()
}
public Newtonsoft.Json.JsonReaderException : JsonException {
private int <LineNumber>k__BackingField
private int <LinePosition>k__BackingField
private string <Path>k__BackingField
public int LineNumber
public int LinePosition
public string Path
public int get_LineNumber()
private void set_LineNumber(int value)
public int get_LinePosition()
private void set_LinePosition(int value)
public string get_Path()
private void set_Path(string value)
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
public void .ctor(SerializationInfo info, StreamingContext context)
internal void .ctor(string message, Exception innerException, string path, int lineNumber, int linePosition)
internal JsonReaderException Create(JsonReader reader, string message)
internal JsonReaderException Create(JsonReader reader, string message, Exception ex)
internal JsonReaderException Create(IJsonLineInfo lineInfo, string path, string message, Exception ex)
}
public Newtonsoft.Json.JsonSerializationException : JsonException {
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
public void .ctor(SerializationInfo info, StreamingContext context)
internal JsonSerializationException Create(JsonReader reader, string message)
internal JsonSerializationException Create(JsonReader reader, string message, Exception ex)
internal JsonSerializationException Create(IJsonLineInfo lineInfo, string path, string message, Exception ex)
}
public Newtonsoft.Json.JsonSerializer : object {
internal TypeNameHandling _typeNameHandling
internal FormatterAssemblyStyle _typeNameAssemblyFormat
internal PreserveReferencesHandling _preserveReferencesHandling
internal ReferenceLoopHandling _referenceLoopHandling
internal MissingMemberHandling _missingMemberHandling
internal ObjectCreationHandling _objectCreationHandling
internal NullValueHandling _nullValueHandling
internal DefaultValueHandling _defaultValueHandling
internal ConstructorHandling _constructorHandling
internal MetadataPropertyHandling _metadataPropertyHandling
internal JsonConverterCollection _converters
internal IContractResolver _contractResolver
internal ITraceWriter _traceWriter
internal IEqualityComparer _equalityComparer
internal SerializationBinder _binder
internal StreamingContext _context
private IReferenceResolver _referenceResolver
private Nullable`1<Formatting> _formatting
private Nullable`1<DateFormatHandling> _dateFormatHandling
private Nullable`1<DateTimeZoneHandling> _dateTimeZoneHandling
private Nullable`1<DateParseHandling> _dateParseHandling
private Nullable`1<FloatFormatHandling> _floatFormatHandling
private Nullable`1<FloatParseHandling> _floatParseHandling
private Nullable`1<StringEscapeHandling> _stringEscapeHandling
private CultureInfo _culture
private Nullable`1<int> _maxDepth
private bool _maxDepthSet
private Nullable`1<bool> _checkAdditionalContent
private string _dateFormatString
private bool _dateFormatStringSet
private EventHandler`1<ErrorEventArgs> Error
public IReferenceResolver ReferenceResolver
public SerializationBinder Binder
public ITraceWriter TraceWriter
public IEqualityComparer EqualityComparer
public TypeNameHandling TypeNameHandling
public FormatterAssemblyStyle TypeNameAssemblyFormat
public PreserveReferencesHandling PreserveReferencesHandling
public ReferenceLoopHandling ReferenceLoopHandling
public MissingMemberHandling MissingMemberHandling
public NullValueHandling NullValueHandling
public DefaultValueHandling DefaultValueHandling
public ObjectCreationHandling ObjectCreationHandling
public ConstructorHandling ConstructorHandling
public MetadataPropertyHandling MetadataPropertyHandling
public JsonConverterCollection Converters
public IContractResolver ContractResolver
public StreamingContext Context
public Formatting Formatting
public DateFormatHandling DateFormatHandling
public DateTimeZoneHandling DateTimeZoneHandling
public DateParseHandling DateParseHandling
public FloatParseHandling FloatParseHandling
public FloatFormatHandling FloatFormatHandling
public StringEscapeHandling StringEscapeHandling
public string DateFormatString
public CultureInfo Culture
public Nullable`1<int> MaxDepth
public bool CheckAdditionalContent
public void add_Error(EventHandler`1<ErrorEventArgs> value)
public void remove_Error(EventHandler`1<ErrorEventArgs> value)
public IReferenceResolver get_ReferenceResolver()
public void set_ReferenceResolver(IReferenceResolver value)
public SerializationBinder get_Binder()
public void set_Binder(SerializationBinder value)
public ITraceWriter get_TraceWriter()
public void set_TraceWriter(ITraceWriter value)
public IEqualityComparer get_EqualityComparer()
public void set_EqualityComparer(IEqualityComparer value)
public TypeNameHandling get_TypeNameHandling()
public void set_TypeNameHandling(TypeNameHandling value)
public FormatterAssemblyStyle get_TypeNameAssemblyFormat()
public void set_TypeNameAssemblyFormat(FormatterAssemblyStyle value)
public PreserveReferencesHandling get_PreserveReferencesHandling()
public void set_PreserveReferencesHandling(PreserveReferencesHandling value)
public ReferenceLoopHandling get_ReferenceLoopHandling()
public void set_ReferenceLoopHandling(ReferenceLoopHandling value)
public MissingMemberHandling get_MissingMemberHandling()
public void set_MissingMemberHandling(MissingMemberHandling value)
public NullValueHandling get_NullValueHandling()
public void set_NullValueHandling(NullValueHandling value)
public DefaultValueHandling get_DefaultValueHandling()
public void set_DefaultValueHandling(DefaultValueHandling value)
public ObjectCreationHandling get_ObjectCreationHandling()
public void set_ObjectCreationHandling(ObjectCreationHandling value)
public ConstructorHandling get_ConstructorHandling()
public void set_ConstructorHandling(ConstructorHandling value)
public MetadataPropertyHandling get_MetadataPropertyHandling()
public void set_MetadataPropertyHandling(MetadataPropertyHandling value)
public JsonConverterCollection get_Converters()
public IContractResolver get_ContractResolver()
public void set_ContractResolver(IContractResolver value)
public StreamingContext get_Context()
public void set_Context(StreamingContext value)
public Formatting get_Formatting()
public void set_Formatting(Formatting value)
public DateFormatHandling get_DateFormatHandling()
public void set_DateFormatHandling(DateFormatHandling value)
public DateTimeZoneHandling get_DateTimeZoneHandling()
public void set_DateTimeZoneHandling(DateTimeZoneHandling value)
public DateParseHandling get_DateParseHandling()
public void set_DateParseHandling(DateParseHandling value)
public FloatParseHandling get_FloatParseHandling()
public void set_FloatParseHandling(FloatParseHandling value)
public FloatFormatHandling get_FloatFormatHandling()
public void set_FloatFormatHandling(FloatFormatHandling value)
public StringEscapeHandling get_StringEscapeHandling()
public void set_StringEscapeHandling(StringEscapeHandling value)
public string get_DateFormatString()
public void set_DateFormatString(string value)
public CultureInfo get_Culture()
public void set_Culture(CultureInfo value)
public Nullable`1<int> get_MaxDepth()
public void set_MaxDepth(Nullable`1<int> value)
public bool get_CheckAdditionalContent()
public void set_CheckAdditionalContent(bool value)
internal bool IsCheckAdditionalContentSet()
public JsonSerializer Create()
public JsonSerializer Create(JsonSerializerSettings settings)
public JsonSerializer CreateDefault()
public JsonSerializer CreateDefault(JsonSerializerSettings settings)
private void ApplySerializerSettings(JsonSerializer serializer, JsonSerializerSettings settings)
public void Populate(TextReader reader, object target)
public void Populate(JsonReader reader, object target)
internal void PopulateInternal(JsonReader reader, object target)
public object Deserialize(JsonReader reader)
public object Deserialize(TextReader reader, Type objectType)
public T Deserialize(JsonReader reader)
public object Deserialize(JsonReader reader, Type objectType)
internal object DeserializeInternal(JsonReader reader, Type objectType)
private void SetupReader(JsonReader reader, CultureInfo& previousCulture, Nullable`1& previousDateTimeZoneHandling, Nullable`1& previousDateParseHandling, Nullable`1& previousFloatParseHandling, Nullable`1& previousMaxDepth, String& previousDateFormatString)
private void ResetReader(JsonReader reader, CultureInfo previousCulture, Nullable`1<DateTimeZoneHandling> previousDateTimeZoneHandling, Nullable`1<DateParseHandling> previousDateParseHandling, Nullable`1<FloatParseHandling> previousFloatParseHandling, Nullable`1<int> previousMaxDepth, string previousDateFormatString)
public void Serialize(TextWriter textWriter, object value)
public void Serialize(JsonWriter jsonWriter, object value, Type objectType)
public void Serialize(TextWriter textWriter, object value, Type objectType)
public void Serialize(JsonWriter jsonWriter, object value)
internal void SerializeInternal(JsonWriter jsonWriter, object value, Type objectType)
internal IReferenceResolver GetReferenceResolver()
internal JsonConverter GetMatchingConverter(Type type)
internal JsonConverter GetMatchingConverter(IList`1<JsonConverter> converters, Type objectType)
internal void OnError(ErrorEventArgs e)
}
public Newtonsoft.Json.JsonSerializerSettings : object {
internal ReferenceLoopHandling DefaultReferenceLoopHandling
internal MissingMemberHandling DefaultMissingMemberHandling
internal NullValueHandling DefaultNullValueHandling
internal DefaultValueHandling DefaultDefaultValueHandling
internal ObjectCreationHandling DefaultObjectCreationHandling
internal PreserveReferencesHandling DefaultPreserveReferencesHandling
internal ConstructorHandling DefaultConstructorHandling
internal TypeNameHandling DefaultTypeNameHandling
internal MetadataPropertyHandling DefaultMetadataPropertyHandling
internal FormatterAssemblyStyle DefaultTypeNameAssemblyFormat
internal StreamingContext DefaultContext
internal Formatting DefaultFormatting
internal DateFormatHandling DefaultDateFormatHandling
internal DateTimeZoneHandling DefaultDateTimeZoneHandling
internal DateParseHandling DefaultDateParseHandling
internal FloatParseHandling DefaultFloatParseHandling
internal FloatFormatHandling DefaultFloatFormatHandling
internal StringEscapeHandling DefaultStringEscapeHandling
internal FormatterAssemblyStyle DefaultFormatterAssemblyStyle
internal CultureInfo DefaultCulture
internal bool DefaultCheckAdditionalContent
internal string DefaultDateFormatString
internal Nullable`1<Formatting> _formatting
internal Nullable`1<DateFormatHandling> _dateFormatHandling
internal Nullable`1<DateTimeZoneHandling> _dateTimeZoneHandling
internal Nullable`1<DateParseHandling> _dateParseHandling
internal Nullable`1<FloatFormatHandling> _floatFormatHandling
internal Nullable`1<FloatParseHandling> _floatParseHandling
internal Nullable`1<StringEscapeHandling> _stringEscapeHandling
internal CultureInfo _culture
internal Nullable`1<bool> _checkAdditionalContent
internal Nullable`1<int> _maxDepth
internal bool _maxDepthSet
internal string _dateFormatString
internal bool _dateFormatStringSet
internal Nullable`1<FormatterAssemblyStyle> _typeNameAssemblyFormat
internal Nullable`1<DefaultValueHandling> _defaultValueHandling
internal Nullable`1<PreserveReferencesHandling> _preserveReferencesHandling
internal Nullable`1<NullValueHandling> _nullValueHandling
internal Nullable`1<ObjectCreationHandling> _objectCreationHandling
internal Nullable`1<MissingMemberHandling> _missingMemberHandling
internal Nullable`1<ReferenceLoopHandling> _referenceLoopHandling
internal Nullable`1<StreamingContext> _context
internal Nullable`1<ConstructorHandling> _constructorHandling
internal Nullable`1<TypeNameHandling> _typeNameHandling
internal Nullable`1<MetadataPropertyHandling> _metadataPropertyHandling
private IList`1<JsonConverter> <Converters>k__BackingField
private IContractResolver <ContractResolver>k__BackingField
private IEqualityComparer <EqualityComparer>k__BackingField
private Func`1<IReferenceResolver> <ReferenceResolverProvider>k__BackingField
private ITraceWriter <TraceWriter>k__BackingField
private SerializationBinder <Binder>k__BackingField
private EventHandler`1<ErrorEventArgs> <Error>k__BackingField
public ReferenceLoopHandling ReferenceLoopHandling
public MissingMemberHandling MissingMemberHandling
public ObjectCreationHandling ObjectCreationHandling
public NullValueHandling NullValueHandling
public DefaultValueHandling DefaultValueHandling
public IList`1<JsonConverter> Converters
public PreserveReferencesHandling PreserveReferencesHandling
public TypeNameHandling TypeNameHandling
public MetadataPropertyHandling MetadataPropertyHandling
public FormatterAssemblyStyle TypeNameAssemblyFormat
public ConstructorHandling ConstructorHandling
public IContractResolver ContractResolver
public IEqualityComparer EqualityComparer
public IReferenceResolver ReferenceResolver
public Func`1<IReferenceResolver> ReferenceResolverProvider
public ITraceWriter TraceWriter
public SerializationBinder Binder
public EventHandler`1<ErrorEventArgs> Error
public StreamingContext Context
public string DateFormatString
public Nullable`1<int> MaxDepth
public Formatting Formatting
public DateFormatHandling DateFormatHandling
public DateTimeZoneHandling DateTimeZoneHandling
public DateParseHandling DateParseHandling
public FloatFormatHandling FloatFormatHandling
public FloatParseHandling FloatParseHandling
public StringEscapeHandling StringEscapeHandling
public CultureInfo Culture
public bool CheckAdditionalContent
public ReferenceLoopHandling get_ReferenceLoopHandling()
public void set_ReferenceLoopHandling(ReferenceLoopHandling value)
public MissingMemberHandling get_MissingMemberHandling()
public void set_MissingMemberHandling(MissingMemberHandling value)
public ObjectCreationHandling get_ObjectCreationHandling()
public void set_ObjectCreationHandling(ObjectCreationHandling value)
public NullValueHandling get_NullValueHandling()
public void set_NullValueHandling(NullValueHandling value)
public DefaultValueHandling get_DefaultValueHandling()
public void set_DefaultValueHandling(DefaultValueHandling value)
public IList`1<JsonConverter> get_Converters()
public void set_Converters(IList`1<JsonConverter> value)
public PreserveReferencesHandling get_PreserveReferencesHandling()
public void set_PreserveReferencesHandling(PreserveReferencesHandling value)
public TypeNameHandling get_TypeNameHandling()
public void set_TypeNameHandling(TypeNameHandling value)
public MetadataPropertyHandling get_MetadataPropertyHandling()
public void set_MetadataPropertyHandling(MetadataPropertyHandling value)
public FormatterAssemblyStyle get_TypeNameAssemblyFormat()
public void set_TypeNameAssemblyFormat(FormatterAssemblyStyle value)
public ConstructorHandling get_ConstructorHandling()
public void set_ConstructorHandling(ConstructorHandling value)
public IContractResolver get_ContractResolver()
public void set_ContractResolver(IContractResolver value)
public IEqualityComparer get_EqualityComparer()
public void set_EqualityComparer(IEqualityComparer value)
public IReferenceResolver get_ReferenceResolver()
public void set_ReferenceResolver(IReferenceResolver value)
public Func`1<IReferenceResolver> get_ReferenceResolverProvider()
public void set_ReferenceResolverProvider(Func`1<IReferenceResolver> value)
public ITraceWriter get_TraceWriter()
public void set_TraceWriter(ITraceWriter value)
public SerializationBinder get_Binder()
public void set_Binder(SerializationBinder value)
public EventHandler`1<ErrorEventArgs> get_Error()
public void set_Error(EventHandler`1<ErrorEventArgs> value)
public StreamingContext get_Context()
public void set_Context(StreamingContext value)
public string get_DateFormatString()
public void set_DateFormatString(string value)
public Nullable`1<int> get_MaxDepth()
public void set_MaxDepth(Nullable`1<int> value)
public Formatting get_Formatting()
public void set_Formatting(Formatting value)
public DateFormatHandling get_DateFormatHandling()
public void set_DateFormatHandling(DateFormatHandling value)
public DateTimeZoneHandling get_DateTimeZoneHandling()
public void set_DateTimeZoneHandling(DateTimeZoneHandling value)
public DateParseHandling get_DateParseHandling()
public void set_DateParseHandling(DateParseHandling value)
public FloatFormatHandling get_FloatFormatHandling()
public void set_FloatFormatHandling(FloatFormatHandling value)
public FloatParseHandling get_FloatParseHandling()
public void set_FloatParseHandling(FloatParseHandling value)
public StringEscapeHandling get_StringEscapeHandling()
public void set_StringEscapeHandling(StringEscapeHandling value)
public CultureInfo get_Culture()
public void set_Culture(CultureInfo value)
public bool get_CheckAdditionalContent()
public void set_CheckAdditionalContent(bool value)
}
public Newtonsoft.Json.JsonTextReader : JsonReader {
private char UnicodeReplacementChar
private int MaximumJavascriptIntegerCharacterLength
private TextReader _reader
private Char[] _chars
private int _charsUsed
private int _charPos
private int _lineStartPos
private int _lineNumber
private bool _isEndOfFile
private StringBuffer _stringBuffer
private StringReference _stringReference
private IArrayPool`1<char> _arrayPool
internal PropertyNameTable NameTable
public IArrayPool`1<char> ArrayPool
public int LineNumber
public int LinePosition
public void .ctor(TextReader reader)
public IArrayPool`1<char> get_ArrayPool()
public void set_ArrayPool(IArrayPool`1<char> value)
private void EnsureBufferNotEmpty()
private void OnNewLine(int pos)
private void ParseString(char quote, ReadType readType)
private void BlockCopyChars(Char[] src, int srcOffset, Char[] dst, int dstOffset, int count)
private void ShiftBufferIfNeeded()
private int ReadData(bool append)
private int ReadData(bool append, int charsRequired)
private bool EnsureChars(int relativePosition, bool append)
private bool ReadChars(int relativePosition, bool append)
public bool Read()
public Nullable`1<int> ReadAsInt32()
public Nullable`1<DateTime> ReadAsDateTime()
public string ReadAsString()
public Byte[] ReadAsBytes()
private object ReadStringValue(ReadType readType)
private JsonReaderException CreateUnexpectedCharacterException(char c)
public Nullable`1<bool> ReadAsBoolean()
private void ProcessValueComma()
private object ReadNumberValue(ReadType readType)
public Nullable`1<DateTimeOffset> ReadAsDateTimeOffset()
public Nullable`1<decimal> ReadAsDecimal()
public Nullable`1<double> ReadAsDouble()
private void HandleNull()
private void ReadFinished()
private bool ReadNullChar()
private void EnsureBuffer()
private void ReadStringIntoBuffer(char quote)
private void WriteCharToBuffer(char writeChar, int lastWritePosition, int writeToPosition)
private char ParseUnicode()
private void ReadNumberIntoBuffer()
private void ClearRecentString()
private bool ParsePostValue()
private bool ParseObject()
private bool ParseProperty()
private bool ValidIdentifierChar(char value)
private void ParseUnquotedProperty()
private bool ParseValue()
private void ProcessLineFeed()
private void ProcessCarriageReturn(bool append)
private bool EatWhitespace(bool oneOrMore)
private void ParseConstructor()
private void ParseNumber(ReadType readType)
private void ParseComment(bool setToken)
private void EndComment(bool setToken, int initialPosition, int endPosition)
private bool MatchValue(string value)
private bool MatchValueWithTrailingSeparator(string value)
private bool IsSeparator(char c)
private void ParseTrue()
private void ParseNull()
private void ParseUndefined()
private void ParseFalse()
private void ParseNumberNegativeInfinity()
private void ParseNumberPositiveInfinity()
private void ParseNumberNaN()
public void Close()
public bool HasLineInfo()
public int get_LineNumber()
public int get_LinePosition()
}
public Newtonsoft.Json.JsonTextWriter : JsonWriter {
private TextWriter _writer
private Base64Encoder _base64Encoder
private char _indentChar
private int _indentation
private char _quoteChar
private bool _quoteName
private Boolean[] _charEscapeFlags
private Char[] _writeBuffer
private IArrayPool`1<char> _arrayPool
private Char[] _indentChars
private Base64Encoder Base64Encoder
public IArrayPool`1<char> ArrayPool
public int Indentation
public char QuoteChar
public char IndentChar
public bool QuoteName
private Base64Encoder get_Base64Encoder()
public IArrayPool`1<char> get_ArrayPool()
public void set_ArrayPool(IArrayPool`1<char> value)
public int get_Indentation()
public void set_Indentation(int value)
public char get_QuoteChar()
public void set_QuoteChar(char value)
public char get_IndentChar()
public void set_IndentChar(char value)
public bool get_QuoteName()
public void set_QuoteName(bool value)
public void .ctor(TextWriter textWriter)
public void Flush()
public void Close()
public void WriteStartObject()
public void WriteStartArray()
public void WriteStartConstructor(string name)
protected void WriteEnd(JsonToken token)
public void WritePropertyName(string name)
public void WritePropertyName(string name, bool escape)
internal void OnStringEscapeHandlingChanged()
private void UpdateCharEscapeFlags()
protected void WriteIndent()
protected void WriteValueDelimiter()
protected void WriteIndentSpace()
private void WriteValueInternal(string value, JsonToken token)
public void WriteValue(object value)
public void WriteNull()
public void WriteUndefined()
public void WriteRaw(string json)
public void WriteValue(string value)
private void WriteEscapedString(string value, bool quote)
public void WriteValue(int value)
public void WriteValue(UInt32 value)
public void WriteValue(long value)
public void WriteValue(ulong value)
public void WriteValue(float value)
public void WriteValue(Nullable`1<float> value)
public void WriteValue(double value)
public void WriteValue(Nullable`1<double> value)
public void WriteValue(bool value)
public void WriteValue(short value)
public void WriteValue(ushort value)
public void WriteValue(char value)
public void WriteValue(byte value)
public void WriteValue(sbyte value)
public void WriteValue(decimal value)
public void WriteValue(DateTime value)
public void WriteValue(Byte[] value)
public void WriteValue(DateTimeOffset value)
public void WriteValue(Guid value)
public void WriteValue(TimeSpan value)
public void WriteValue(Uri value)
public void WriteComment(string text)
public void WriteWhitespace(string ws)
private void EnsureWriteBuffer()
private void WriteIntegerValue(long value)
private void WriteIntegerValue(ulong uvalue)
}
public Newtonsoft.Json.JsonToken : Enum {
public int value__
public JsonToken None
public JsonToken StartObject
public JsonToken StartArray
public JsonToken StartConstructor
public JsonToken PropertyName
public JsonToken Comment
public JsonToken Raw
public JsonToken Integer
public JsonToken Float
public JsonToken String
public JsonToken Boolean
public JsonToken Null
public JsonToken Undefined
public JsonToken EndObject
public JsonToken EndArray
public JsonToken EndConstructor
public JsonToken Date
public JsonToken Bytes
}
public Newtonsoft.Json.JsonValidatingReader : JsonReader {
private JsonReader _reader
private Stack`1<SchemaScope> _stack
private JsonSchema _schema
private JsonSchemaModel _model
private SchemaScope _currentScope
private ValidationEventHandler ValidationEventHandler
private IList`1<JsonSchemaModel> EmptySchemaList
public object Value
public int Depth
public string Path
public char QuoteChar
public JsonToken TokenType
public Type ValueType
private IList`1<JsonSchemaModel> CurrentSchemas
private IList`1<JsonSchemaModel> CurrentMemberSchemas
public JsonSchema Schema
public JsonReader Reader
private int Newtonsoft.Json.IJsonLineInfo.LineNumber
private int Newtonsoft.Json.IJsonLineInfo.LinePosition
public void add_ValidationEventHandler(ValidationEventHandler value)
public void remove_ValidationEventHandler(ValidationEventHandler value)
public object get_Value()
public int get_Depth()
public string get_Path()
public char get_QuoteChar()
protected internal void set_QuoteChar(char value)
public JsonToken get_TokenType()
public Type get_ValueType()
private void Push(SchemaScope scope)
private SchemaScope Pop()
private IList`1<JsonSchemaModel> get_CurrentSchemas()
private IList`1<JsonSchemaModel> get_CurrentMemberSchemas()
private void RaiseError(string message, JsonSchemaModel schema)
private void OnValidationEvent(JsonSchemaException exception)
public void .ctor(JsonReader reader)
public JsonSchema get_Schema()
public void set_Schema(JsonSchema value)
public JsonReader get_Reader()
private void ValidateNotDisallowed(JsonSchemaModel schema)
private Nullable`1<JsonSchemaType> GetCurrentNodeSchemaType()
public Nullable`1<int> ReadAsInt32()
public Byte[] ReadAsBytes()
public Nullable`1<decimal> ReadAsDecimal()
public Nullable`1<double> ReadAsDouble()
public Nullable`1<bool> ReadAsBoolean()
public string ReadAsString()
public Nullable`1<DateTime> ReadAsDateTime()
public Nullable`1<DateTimeOffset> ReadAsDateTimeOffset()
public bool Read()
private void ValidateCurrentToken()
private void WriteToken(IList`1<JsonSchemaModel> schemas)
private void ValidateEndObject(JsonSchemaModel schema)
private void ValidateEndArray(JsonSchemaModel schema)
private void ValidateNull(JsonSchemaModel schema)
private void ValidateBoolean(JsonSchemaModel schema)
private void ValidateString(JsonSchemaModel schema)
private void ValidateInteger(JsonSchemaModel schema)
private void ProcessValue()
private void ValidateFloat(JsonSchemaModel schema)
private double FloatingPointRemainder(double dividend, double divisor)
private bool IsZero(double value)
private void ValidatePropertyName(JsonSchemaModel schema)
private bool IsPropertyDefinied(JsonSchemaModel schema, string propertyName)
private bool ValidateArray(JsonSchemaModel schema)
private bool ValidateObject(JsonSchemaModel schema)
private bool TestType(JsonSchemaModel currentSchema, JsonSchemaType currentType)
private bool Newtonsoft.Json.IJsonLineInfo.HasLineInfo()
private int Newtonsoft.Json.IJsonLineInfo.get_LineNumber()
private int Newtonsoft.Json.IJsonLineInfo.get_LinePosition()
}
public Newtonsoft.Json.JsonWriter : object {
private State[][] StateArray
internal State[][] StateArrayTempate
private List`1<JsonPosition> _stack
private JsonPosition _currentPosition
private State _currentState
private Formatting _formatting
private bool <CloseOutput>k__BackingField
private DateFormatHandling _dateFormatHandling
private DateTimeZoneHandling _dateTimeZoneHandling
private StringEscapeHandling _stringEscapeHandling
private FloatFormatHandling _floatFormatHandling
private string _dateFormatString
private CultureInfo _culture
public bool CloseOutput
protected internal int Top
public WriteState WriteState
internal string ContainerPath
public string Path
public Formatting Formatting
public DateFormatHandling DateFormatHandling
public DateTimeZoneHandling DateTimeZoneHandling
public StringEscapeHandling StringEscapeHandling
public FloatFormatHandling FloatFormatHandling
public string DateFormatString
public CultureInfo Culture
internal State[][] BuildStateArray()
public bool get_CloseOutput()
public void set_CloseOutput(bool value)
protected internal int get_Top()
public WriteState get_WriteState()
internal string get_ContainerPath()
public string get_Path()
public Formatting get_Formatting()
public void set_Formatting(Formatting value)
public DateFormatHandling get_DateFormatHandling()
public void set_DateFormatHandling(DateFormatHandling value)
public DateTimeZoneHandling get_DateTimeZoneHandling()
public void set_DateTimeZoneHandling(DateTimeZoneHandling value)
public StringEscapeHandling get_StringEscapeHandling()
public void set_StringEscapeHandling(StringEscapeHandling value)
internal void OnStringEscapeHandlingChanged()
public FloatFormatHandling get_FloatFormatHandling()
public void set_FloatFormatHandling(FloatFormatHandling value)
public string get_DateFormatString()
public void set_DateFormatString(string value)
public CultureInfo get_Culture()
public void set_Culture(CultureInfo value)
internal void UpdateScopeWithFinishedValue()
private void Push(JsonContainerType value)
private JsonContainerType Pop()
private JsonContainerType Peek()
public void Flush()
public void Close()
public void WriteStartObject()
public void WriteEndObject()
public void WriteStartArray()
public void WriteEndArray()
public void WriteStartConstructor(string name)
public void WriteEndConstructor()
public void WritePropertyName(string name)
public void WritePropertyName(string name, bool escape)
public void WriteEnd()
public void WriteToken(JsonReader reader)
public void WriteToken(JsonReader reader, bool writeChildren)
public void WriteToken(JsonToken token, object value)
public void WriteToken(JsonToken token)
internal void WriteToken(JsonReader reader, bool writeChildren, bool writeDateConstructorAsDate, bool writeComments)
internal void WriteToken(JsonReader reader, int initialDepth, bool writeChildren, bool writeDateConstructorAsDate, bool writeComments)
private void WriteConstructorDate(JsonReader reader)
private void WriteEnd(JsonContainerType type)
private void AutoCompleteAll()
private JsonToken GetCloseTokenForType(JsonContainerType type)
private void AutoCompleteClose(JsonContainerType type)
protected void WriteEnd(JsonToken token)
protected void WriteIndent()
protected void WriteValueDelimiter()
protected void WriteIndentSpace()
internal void AutoComplete(JsonToken tokenBeingWritten)
public void WriteNull()
public void WriteUndefined()
public void WriteRaw(string json)
public void WriteRawValue(string json)
public void WriteValue(string value)
public void WriteValue(int value)
public void WriteValue(UInt32 value)
public void WriteValue(long value)
public void WriteValue(ulong value)
public void WriteValue(float value)
public void WriteValue(double value)
public void WriteValue(bool value)
public void WriteValue(short value)
public void WriteValue(ushort value)
public void WriteValue(char value)
public void WriteValue(byte value)
public void WriteValue(sbyte value)
public void WriteValue(decimal value)
public void WriteValue(DateTime value)
public void WriteValue(DateTimeOffset value)
public void WriteValue(Guid value)
public void WriteValue(TimeSpan value)
public void WriteValue(Nullable`1<int> value)
public void WriteValue(Nullable`1<UInt32> value)
public void WriteValue(Nullable`1<long> value)
public void WriteValue(Nullable`1<ulong> value)
public void WriteValue(Nullable`1<float> value)
public void WriteValue(Nullable`1<double> value)
public void WriteValue(Nullable`1<bool> value)
public void WriteValue(Nullable`1<short> value)
public void WriteValue(Nullable`1<ushort> value)
public void WriteValue(Nullable`1<char> value)
public void WriteValue(Nullable`1<byte> value)
public void WriteValue(Nullable`1<sbyte> value)
public void WriteValue(Nullable`1<decimal> value)
public void WriteValue(Nullable`1<DateTime> value)
public void WriteValue(Nullable`1<DateTimeOffset> value)
public void WriteValue(Nullable`1<Guid> value)
public void WriteValue(Nullable`1<TimeSpan> value)
public void WriteValue(Byte[] value)
public void WriteValue(Uri value)
public void WriteValue(object value)
public void WriteComment(string text)
public void WriteWhitespace(string ws)
private void System.IDisposable.Dispose()
protected void Dispose(bool disposing)
internal void WriteValue(JsonWriter writer, PrimitiveTypeCode typeCode, object value)
private JsonWriterException CreateUnsupportedTypeException(JsonWriter writer, object value)
protected void SetWriteState(JsonToken token, object value)
internal void InternalWriteEnd(JsonContainerType container)
internal void InternalWritePropertyName(string name)
internal void InternalWriteRaw()
internal void InternalWriteStart(JsonToken token, JsonContainerType container)
internal void InternalWriteValue(JsonToken token)
internal void InternalWriteWhitespace(string ws)
internal void InternalWriteComment()
}
public Newtonsoft.Json.JsonWriterException : JsonException {
private string <Path>k__BackingField
public string Path
public string get_Path()
private void set_Path(string value)
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
public void .ctor(SerializationInfo info, StreamingContext context)
internal void .ctor(string message, Exception innerException, string path)
internal JsonWriterException Create(JsonWriter writer, string message, Exception ex)
internal JsonWriterException Create(string path, string message, Exception ex)
}
public Newtonsoft.Json.Linq.CommentHandling : Enum {
public int value__
public CommentHandling Ignore
public CommentHandling Load
}
public Newtonsoft.Json.Linq.Extensions : object {
public IJEnumerable`1<JToken> Ancestors(IEnumerable`1<T> source)
public IJEnumerable`1<JToken> AncestorsAndSelf(IEnumerable`1<T> source)
public IJEnumerable`1<JToken> Descendants(IEnumerable`1<T> source)
public IJEnumerable`1<JToken> DescendantsAndSelf(IEnumerable`1<T> source)
public IJEnumerable`1<JProperty> Properties(IEnumerable`1<JObject> source)
public IJEnumerable`1<JToken> Values(IEnumerable`1<JToken> source, object key)
public IJEnumerable`1<JToken> Values(IEnumerable`1<JToken> source)
public IEnumerable`1<U> Values(IEnumerable`1<JToken> source, object key)
public IEnumerable`1<U> Values(IEnumerable`1<JToken> source)
public U Value(IEnumerable`1<JToken> value)
public U Value(IEnumerable`1<T> value)
internal IEnumerable`1<U> Values(IEnumerable`1<T> source, object key)
public IJEnumerable`1<JToken> Children(IEnumerable`1<T> source)
public IEnumerable`1<U> Children(IEnumerable`1<T> source)
internal IEnumerable`1<U> Convert(IEnumerable`1<T> source)
internal U Convert(T token)
public IJEnumerable`1<JToken> AsJEnumerable(IEnumerable`1<JToken> source)
public IJEnumerable`1<T> AsJEnumerable(IEnumerable`1<T> source)
}
public Newtonsoft.Json.Linq.IJEnumerable`1 {
public IJEnumerable`1<JToken> Item
public IJEnumerable`1<JToken> get_Item(object key)
}
public Newtonsoft.Json.Linq.JArray : JContainer {
private List`1<JToken> _values
protected IList`1<JToken> ChildrenTokens
public JTokenType Type
public JToken Item
public JToken Item
public bool IsReadOnly
protected IList`1<JToken> get_ChildrenTokens()
public JTokenType get_Type()
public void .ctor(JArray other)
public void .ctor(Object[] content)
public void .ctor(object content)
internal bool DeepEquals(JToken node)
internal JToken CloneToken()
public JArray Load(JsonReader reader)
public JArray Load(JsonReader reader, JsonLoadSettings settings)
public JArray Parse(string json)
public JArray Parse(string json, JsonLoadSettings settings)
public JArray FromObject(object o)
public JArray FromObject(object o, JsonSerializer jsonSerializer)
public void WriteTo(JsonWriter writer, JsonConverter[] converters)
public JToken get_Item(object key)
public void set_Item(object key, JToken value)
public JToken get_Item(int index)
public void set_Item(int index, JToken value)
internal void MergeItem(object content, JsonMergeSettings settings)
public int IndexOf(JToken item)
public void Insert(int index, JToken item)
public void RemoveAt(int index)
public IEnumerator`1<JToken> GetEnumerator()
public void Add(JToken item)
public void Clear()
public bool Contains(JToken item)
public void CopyTo(JToken[] array, int arrayIndex)
public bool get_IsReadOnly()
public bool Remove(JToken item)
internal int GetDeepHashCode()
}
public Newtonsoft.Json.Linq.JConstructor : JContainer {
private string _name
private List`1<JToken> _values
protected IList`1<JToken> ChildrenTokens
public string Name
public JTokenType Type
public JToken Item
protected IList`1<JToken> get_ChildrenTokens()
internal void MergeItem(object content, JsonMergeSettings settings)
public string get_Name()
public void set_Name(string value)
public JTokenType get_Type()
public void .ctor(JConstructor other)
public void .ctor(string name, Object[] content)
public void .ctor(string name, object content)
public void .ctor(string name)
internal bool DeepEquals(JToken node)
internal JToken CloneToken()
public void WriteTo(JsonWriter writer, JsonConverter[] converters)
public JToken get_Item(object key)
public void set_Item(object key, JToken value)
internal int GetDeepHashCode()
public JConstructor Load(JsonReader reader)
public JConstructor Load(JsonReader reader, JsonLoadSettings settings)
}
public Newtonsoft.Json.Linq.JContainer : JToken {
internal ListChangedEventHandler _listChanged
internal AddingNewEventHandler _addingNew
private object _syncRoot
private bool _busy
protected IList`1<JToken> ChildrenTokens
public bool HasValues
public JToken First
public JToken Last
private JToken System.Collections.Generic.IList<Newtonsoft.Json.Linq.JToken>.Item
private bool System.Collections.Generic.ICollection<Newtonsoft.Json.Linq.JToken>.IsReadOnly
private bool System.Collections.IList.IsFixedSize
private bool System.Collections.IList.IsReadOnly
private object System.Collections.IList.Item
public int Count
private bool System.Collections.ICollection.IsSynchronized
private object System.Collections.ICollection.SyncRoot
private bool System.ComponentModel.IBindingList.AllowEdit
private bool System.ComponentModel.IBindingList.AllowNew
private bool System.ComponentModel.IBindingList.AllowRemove
private bool System.ComponentModel.IBindingList.IsSorted
private ListSortDirection System.ComponentModel.IBindingList.SortDirection
private PropertyDescriptor System.ComponentModel.IBindingList.SortProperty
private bool System.ComponentModel.IBindingList.SupportsChangeNotification
private bool System.ComponentModel.IBindingList.SupportsSearching
private bool System.ComponentModel.IBindingList.SupportsSorting
public void add_ListChanged(ListChangedEventHandler value)
public void remove_ListChanged(ListChangedEventHandler value)
public void add_AddingNew(AddingNewEventHandler value)
public void remove_AddingNew(AddingNewEventHandler value)
protected IList`1<JToken> get_ChildrenTokens()
internal void .ctor(JContainer other)
internal void CheckReentrancy()
internal IList`1<JToken> CreateChildrenCollection()
protected void OnAddingNew(AddingNewEventArgs e)
protected void OnListChanged(ListChangedEventArgs e)
public bool get_HasValues()
internal bool ContentsEqual(JContainer container)
public JToken get_First()
public JToken get_Last()
public JEnumerable`1<JToken> Children()
public IEnumerable`1<T> Values()
public IEnumerable`1<JToken> Descendants()
public IEnumerable`1<JToken> DescendantsAndSelf()
internal IEnumerable`1<JToken> GetDescendants(bool self)
internal bool IsMultiContent(object content)
internal JToken EnsureParentToken(JToken item, bool skipParentCheck)
internal int IndexOfItem(JToken item)
internal void InsertItem(int index, JToken item, bool skipParentCheck)
internal void RemoveItemAt(int index)
internal bool RemoveItem(JToken item)
internal JToken GetItem(int index)
internal void SetItem(int index, JToken item)
internal void ClearItems()
internal void ReplaceItem(JToken existing, JToken replacement)
internal bool ContainsItem(JToken item)
internal void CopyItemsTo(Array array, int arrayIndex)
internal bool IsTokenUnchanged(JToken currentValue, JToken newValue)
internal void ValidateToken(JToken o, JToken existing)
public void Add(object content)
internal void AddAndSkipParentCheck(JToken token)
public void AddFirst(object content)
internal void AddInternal(int index, object content, bool skipParentCheck)
internal JToken CreateFromContent(object content)
public JsonWriter CreateWriter()
public void ReplaceAll(object content)
public void RemoveAll()
internal void MergeItem(object content, JsonMergeSettings settings)
public void Merge(object content)
public void Merge(object content, JsonMergeSettings settings)
internal void ReadTokenFrom(JsonReader reader, JsonLoadSettings options)
internal void ReadContentFrom(JsonReader r, JsonLoadSettings settings)
internal int ContentsHashCode()
private string System.ComponentModel.ITypedList.GetListName(PropertyDescriptor[] listAccessors)
private PropertyDescriptorCollection System.ComponentModel.ITypedList.GetItemProperties(PropertyDescriptor[] listAccessors)
private int System.Collections.Generic.IList<Newtonsoft.Json.Linq.JToken>.IndexOf(JToken item)
private void System.Collections.Generic.IList<Newtonsoft.Json.Linq.JToken>.Insert(int index, JToken item)
private void System.Collections.Generic.IList<Newtonsoft.Json.Linq.JToken>.RemoveAt(int index)
private JToken System.Collections.Generic.IList<Newtonsoft.Json.Linq.JToken>.get_Item(int index)
private void System.Collections.Generic.IList<Newtonsoft.Json.Linq.JToken>.set_Item(int index, JToken value)
private void System.Collections.Generic.ICollection<Newtonsoft.Json.Linq.JToken>.Add(JToken item)
private void System.Collections.Generic.ICollection<Newtonsoft.Json.Linq.JToken>.Clear()
private bool System.Collections.Generic.ICollection<Newtonsoft.Json.Linq.JToken>.Contains(JToken item)
private void System.Collections.Generic.ICollection<Newtonsoft.Json.Linq.JToken>.CopyTo(JToken[] array, int arrayIndex)
private bool System.Collections.Generic.ICollection<Newtonsoft.Json.Linq.JToken>.get_IsReadOnly()
private bool System.Collections.Generic.ICollection<Newtonsoft.Json.Linq.JToken>.Remove(JToken item)
private JToken EnsureValue(object value)
private int System.Collections.IList.Add(object value)
private void System.Collections.IList.Clear()
private bool System.Collections.IList.Contains(object value)
private int System.Collections.IList.IndexOf(object value)
private void System.Collections.IList.Insert(int index, object value)
private bool System.Collections.IList.get_IsFixedSize()
private bool System.Collections.IList.get_IsReadOnly()
private void System.Collections.IList.Remove(object value)
private void System.Collections.IList.RemoveAt(int index)
private object System.Collections.IList.get_Item(int index)
private void System.Collections.IList.set_Item(int index, object value)
private void System.Collections.ICollection.CopyTo(Array array, int index)
public int get_Count()
private bool System.Collections.ICollection.get_IsSynchronized()
private object System.Collections.ICollection.get_SyncRoot()
private void System.ComponentModel.IBindingList.AddIndex(PropertyDescriptor property)
private object System.ComponentModel.IBindingList.AddNew()
private bool System.ComponentModel.IBindingList.get_AllowEdit()
private bool System.ComponentModel.IBindingList.get_AllowNew()
private bool System.ComponentModel.IBindingList.get_AllowRemove()
private void System.ComponentModel.IBindingList.ApplySort(PropertyDescriptor property, ListSortDirection direction)
private int System.ComponentModel.IBindingList.Find(PropertyDescriptor property, object key)
private bool System.ComponentModel.IBindingList.get_IsSorted()
private void System.ComponentModel.IBindingList.RemoveIndex(PropertyDescriptor property)
private void System.ComponentModel.IBindingList.RemoveSort()
private ListSortDirection System.ComponentModel.IBindingList.get_SortDirection()
private PropertyDescriptor System.ComponentModel.IBindingList.get_SortProperty()
private bool System.ComponentModel.IBindingList.get_SupportsChangeNotification()
private bool System.ComponentModel.IBindingList.get_SupportsSearching()
private bool System.ComponentModel.IBindingList.get_SupportsSorting()
internal void MergeEnumerableContent(JContainer target, IEnumerable content, JsonMergeSettings settings)
}
public Newtonsoft.Json.Linq.JEnumerable`1 : ValueType {
public JEnumerable`1<T> Empty
private IEnumerable`1<T> _enumerable
public IJEnumerable`1<JToken> Item
public void .ctor(IEnumerable`1<T> enumerable)
public IEnumerator`1<T> GetEnumerator()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
public IJEnumerable`1<JToken> get_Item(object key)
public bool Equals(JEnumerable`1<T> other)
public bool Equals(object obj)
public int GetHashCode()
}
public Newtonsoft.Json.Linq.JObject : JContainer {
private JPropertyKeyedCollection _properties
private PropertyChangedEventHandler PropertyChanged
private PropertyChangingEventHandler PropertyChanging
protected IList`1<JToken> ChildrenTokens
public JTokenType Type
public JToken Item
public JToken Item
private ICollection`1<string> System.Collections.Generic.IDictionary<System.String,Newtonsoft.Json.Linq.JToken>.Keys
private ICollection`1<JToken> System.Collections.Generic.IDictionary<System.String,Newtonsoft.Json.Linq.JToken>.Values
private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,Newtonsoft.Json.Linq.JToken>>.IsReadOnly
protected IList`1<JToken> get_ChildrenTokens()
public void add_PropertyChanged(PropertyChangedEventHandler value)
public void remove_PropertyChanged(PropertyChangedEventHandler value)
public void add_PropertyChanging(PropertyChangingEventHandler value)
public void remove_PropertyChanging(PropertyChangingEventHandler value)
public void .ctor(JObject other)
public void .ctor(Object[] content)
public void .ctor(object content)
internal bool DeepEquals(JToken node)
internal void InsertItem(int index, JToken item, bool skipParentCheck)
internal void ValidateToken(JToken o, JToken existing)
internal void MergeItem(object content, JsonMergeSettings settings)
internal void InternalPropertyChanged(JProperty childProperty)
internal void InternalPropertyChanging(JProperty childProperty)
internal JToken CloneToken()
public JTokenType get_Type()
public IEnumerable`1<JProperty> Properties()
public JProperty Property(string name)
public JEnumerable`1<JToken> PropertyValues()
public JToken get_Item(object key)
public void set_Item(object key, JToken value)
public JToken get_Item(string propertyName)
public void set_Item(string propertyName, JToken value)
public JObject Load(JsonReader reader)
public JObject Load(JsonReader reader, JsonLoadSettings settings)
public JObject Parse(string json)
public JObject Parse(string json, JsonLoadSettings settings)
public JObject FromObject(object o)
public JObject FromObject(object o, JsonSerializer jsonSerializer)
public void WriteTo(JsonWriter writer, JsonConverter[] converters)
public JToken GetValue(string propertyName)
public JToken GetValue(string propertyName, StringComparison comparison)
public bool TryGetValue(string propertyName, StringComparison comparison, JToken& value)
public void Add(string propertyName, JToken value)
private bool System.Collections.Generic.IDictionary<System.String,Newtonsoft.Json.Linq.JToken>.ContainsKey(string key)
private ICollection`1<string> System.Collections.Generic.IDictionary<System.String,Newtonsoft.Json.Linq.JToken>.get_Keys()
public bool Remove(string propertyName)
public bool TryGetValue(string propertyName, JToken& value)
private ICollection`1<JToken> System.Collections.Generic.IDictionary<System.String,Newtonsoft.Json.Linq.JToken>.get_Values()
private void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,Newtonsoft.Json.Linq.JToken>>.Add(KeyValuePair`2<string, JToken> item)
private void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,Newtonsoft.Json.Linq.JToken>>.Clear()
private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,Newtonsoft.Json.Linq.JToken>>.Contains(KeyValuePair`2<string, JToken> item)
private void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,Newtonsoft.Json.Linq.JToken>>.CopyTo(KeyValuePair`2[] array, int arrayIndex)
private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,Newtonsoft.Json.Linq.JToken>>.get_IsReadOnly()
private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,Newtonsoft.Json.Linq.JToken>>.Remove(KeyValuePair`2<string, JToken> item)
internal int GetDeepHashCode()
public IEnumerator`1<KeyValuePair`2<string, JToken>> GetEnumerator()
protected void OnPropertyChanged(string propertyName)
protected void OnPropertyChanging(string propertyName)
private PropertyDescriptorCollection System.ComponentModel.ICustomTypeDescriptor.GetProperties()
private PropertyDescriptorCollection System.ComponentModel.ICustomTypeDescriptor.GetProperties(Attribute[] attributes)
private AttributeCollection System.ComponentModel.ICustomTypeDescriptor.GetAttributes()
private string System.ComponentModel.ICustomTypeDescriptor.GetClassName()
private string System.ComponentModel.ICustomTypeDescriptor.GetComponentName()
private TypeConverter System.ComponentModel.ICustomTypeDescriptor.GetConverter()
private EventDescriptor System.ComponentModel.ICustomTypeDescriptor.GetDefaultEvent()
private PropertyDescriptor System.ComponentModel.ICustomTypeDescriptor.GetDefaultProperty()
private object System.ComponentModel.ICustomTypeDescriptor.GetEditor(Type editorBaseType)
private EventDescriptorCollection System.ComponentModel.ICustomTypeDescriptor.GetEvents(Attribute[] attributes)
private EventDescriptorCollection System.ComponentModel.ICustomTypeDescriptor.GetEvents()
private object System.ComponentModel.ICustomTypeDescriptor.GetPropertyOwner(PropertyDescriptor pd)
}
public Newtonsoft.Json.Linq.JProperty : JContainer {
private JPropertyList _content
private string _name
protected IList`1<JToken> ChildrenTokens
public string Name
public JToken Value
public JTokenType Type
protected IList`1<JToken> get_ChildrenTokens()
public string get_Name()
public JToken get_Value()
public void set_Value(JToken value)
public void .ctor(JProperty other)
internal JToken GetItem(int index)
internal void SetItem(int index, JToken item)
internal bool RemoveItem(JToken item)
internal void RemoveItemAt(int index)
internal void InsertItem(int index, JToken item, bool skipParentCheck)
internal bool ContainsItem(JToken item)
internal void MergeItem(object content, JsonMergeSettings settings)
internal void ClearItems()
internal bool DeepEquals(JToken node)
internal JToken CloneToken()
public JTokenType get_Type()
internal void .ctor(string name)
public void .ctor(string name, Object[] content)
public void .ctor(string name, object content)
public void WriteTo(JsonWriter writer, JsonConverter[] converters)
internal int GetDeepHashCode()
public JProperty Load(JsonReader reader)
public JProperty Load(JsonReader reader, JsonLoadSettings settings)
}
public Newtonsoft.Json.Linq.JPropertyDescriptor : PropertyDescriptor {
public Type ComponentType
public bool IsReadOnly
public Type PropertyType
protected int NameHashCode
public void .ctor(string name)
private JObject CastInstance(object instance)
public bool CanResetValue(object component)
public object GetValue(object component)
public void ResetValue(object component)
public void SetValue(object component, object value)
public bool ShouldSerializeValue(object component)
public Type get_ComponentType()
public bool get_IsReadOnly()
public Type get_PropertyType()
protected int get_NameHashCode()
}
internal Newtonsoft.Json.Linq.JPropertyKeyedCollection : Collection`1<JToken> {
private IEqualityComparer`1<string> Comparer
private Dictionary`2<string, JToken> _dictionary
public JToken Item
public ICollection`1<string> Keys
public ICollection`1<JToken> Values
private void AddKey(string key, JToken item)
protected void ChangeItemKey(JToken item, string newKey)
protected void ClearItems()
public bool Contains(string key)
private bool ContainsItem(JToken item)
private void EnsureDictionary()
private string GetKeyForItem(JToken item)
protected void InsertItem(int index, JToken item)
public bool Remove(string key)
protected void RemoveItem(int index)
private void RemoveKey(string key)
protected void SetItem(int index, JToken item)
public JToken get_Item(string key)
public bool TryGetValue(string key, JToken& value)
public ICollection`1<string> get_Keys()
public ICollection`1<JToken> get_Values()
public bool Compare(JPropertyKeyedCollection other)
}
public Newtonsoft.Json.Linq.JRaw : JValue {
public void .ctor(JRaw other)
public void .ctor(object rawJson)
public JRaw Create(JsonReader reader)
internal JToken CloneToken()
}
public Newtonsoft.Json.Linq.JsonLoadSettings : object {
private CommentHandling _commentHandling
private LineInfoHandling _lineInfoHandling
public CommentHandling CommentHandling
public LineInfoHandling LineInfoHandling
public CommentHandling get_CommentHandling()
public void set_CommentHandling(CommentHandling value)
public LineInfoHandling get_LineInfoHandling()
public void set_LineInfoHandling(LineInfoHandling value)
}
public Newtonsoft.Json.Linq.JsonMergeSettings : object {
private MergeArrayHandling _mergeArrayHandling
private MergeNullValueHandling _mergeNullValueHandling
public MergeArrayHandling MergeArrayHandling
public MergeNullValueHandling MergeNullValueHandling
public MergeArrayHandling get_MergeArrayHandling()
public void set_MergeArrayHandling(MergeArrayHandling value)
public MergeNullValueHandling get_MergeNullValueHandling()
public void set_MergeNullValueHandling(MergeNullValueHandling value)
}
internal Newtonsoft.Json.Linq.JsonPath.ArrayIndexFilter : PathFilter {
private Nullable`1<int> <Index>k__BackingField
public Nullable`1<int> Index
public Nullable`1<int> get_Index()
public void set_Index(Nullable`1<int> value)
public IEnumerable`1<JToken> ExecuteFilter(IEnumerable`1<JToken> current, bool errorWhenNoMatch)
}
internal Newtonsoft.Json.Linq.JsonPath.ArrayMultipleIndexFilter : PathFilter {
private List`1<int> <Indexes>k__BackingField
public List`1<int> Indexes
public List`1<int> get_Indexes()
public void set_Indexes(List`1<int> value)
public IEnumerable`1<JToken> ExecuteFilter(IEnumerable`1<JToken> current, bool errorWhenNoMatch)
}
internal Newtonsoft.Json.Linq.JsonPath.ArraySliceFilter : PathFilter {
private Nullable`1<int> <Start>k__BackingField
private Nullable`1<int> <End>k__BackingField
private Nullable`1<int> <Step>k__BackingField
public Nullable`1<int> Start
public Nullable`1<int> End
public Nullable`1<int> Step
public Nullable`1<int> get_Start()
public void set_Start(Nullable`1<int> value)
public Nullable`1<int> get_End()
public void set_End(Nullable`1<int> value)
public Nullable`1<int> get_Step()
public void set_Step(Nullable`1<int> value)
public IEnumerable`1<JToken> ExecuteFilter(IEnumerable`1<JToken> current, bool errorWhenNoMatch)
private bool IsValid(int index, int stopIndex, bool positiveStep)
}
internal Newtonsoft.Json.Linq.JsonPath.BooleanQueryExpression : QueryExpression {
private List`1<PathFilter> <Path>k__BackingField
private JValue <Value>k__BackingField
public List`1<PathFilter> Path
public JValue Value
public List`1<PathFilter> get_Path()
public void set_Path(List`1<PathFilter> value)
public JValue get_Value()
public void set_Value(JValue value)
public bool IsMatch(JToken t)
private bool EqualsWithStringCoercion(JValue value, JValue queryValue)
}
internal Newtonsoft.Json.Linq.JsonPath.CompositeExpression : QueryExpression {
private List`1<QueryExpression> <Expressions>k__BackingField
public List`1<QueryExpression> Expressions
public List`1<QueryExpression> get_Expressions()
public void set_Expressions(List`1<QueryExpression> value)
public bool IsMatch(JToken t)
}
internal Newtonsoft.Json.Linq.JsonPath.FieldFilter : PathFilter {
private string <Name>k__BackingField
public string Name
public string get_Name()
public void set_Name(string value)
public IEnumerable`1<JToken> ExecuteFilter(IEnumerable`1<JToken> current, bool errorWhenNoMatch)
}
internal Newtonsoft.Json.Linq.JsonPath.FieldMultipleFilter : PathFilter {
private List`1<string> <Names>k__BackingField
public List`1<string> Names
public List`1<string> get_Names()
public void set_Names(List`1<string> value)
public IEnumerable`1<JToken> ExecuteFilter(IEnumerable`1<JToken> current, bool errorWhenNoMatch)
}
internal Newtonsoft.Json.Linq.JsonPath.JPath : object {
private string _expression
private List`1<PathFilter> <Filters>k__BackingField
private int _currentIndex
public List`1<PathFilter> Filters
public List`1<PathFilter> get_Filters()
private void set_Filters(List`1<PathFilter> value)
public void .ctor(string expression)
private void ParseMain()
private bool ParsePath(List`1<PathFilter> filters, int currentPartStartIndex, bool query)
private PathFilter ParseIndexer(char indexerOpenChar)
private PathFilter ParseArrayIndexer(char indexerCloseChar)
private void EatWhitespace()
private PathFilter ParseQuery(char indexerCloseChar)
private QueryExpression ParseExpression()
private object ParseValue()
private string ReadQuotedString()
private bool Match(string s)
private QueryOperator ParseOperator()
private PathFilter ParseQuotedField(char indexerCloseChar)
private void EnsureLength(string message)
internal IEnumerable`1<JToken> Evaluate(JToken t, bool errorWhenNoMatch)
internal IEnumerable`1<JToken> Evaluate(List`1<PathFilter> filters, JToken t, bool errorWhenNoMatch)
}
internal Newtonsoft.Json.Linq.JsonPath.PathFilter : object {
public IEnumerable`1<JToken> ExecuteFilter(IEnumerable`1<JToken> current, bool errorWhenNoMatch)
protected JToken GetTokenIndex(JToken t, bool errorWhenNoMatch, int index)
}
internal Newtonsoft.Json.Linq.JsonPath.QueryExpression : object {
private QueryOperator <Operator>k__BackingField
public QueryOperator Operator
public QueryOperator get_Operator()
public void set_Operator(QueryOperator value)
public bool IsMatch(JToken t)
}
internal Newtonsoft.Json.Linq.JsonPath.QueryFilter : PathFilter {
private QueryExpression <Expression>k__BackingField
public QueryExpression Expression
public QueryExpression get_Expression()
public void set_Expression(QueryExpression value)
public IEnumerable`1<JToken> ExecuteFilter(IEnumerable`1<JToken> current, bool errorWhenNoMatch)
}
internal Newtonsoft.Json.Linq.JsonPath.QueryOperator : Enum {
public int value__
public QueryOperator None
public QueryOperator Equals
public QueryOperator NotEquals
public QueryOperator Exists
public QueryOperator LessThan
public QueryOperator LessThanOrEquals
public QueryOperator GreaterThan
public QueryOperator GreaterThanOrEquals
public QueryOperator And
public QueryOperator Or
}
internal Newtonsoft.Json.Linq.JsonPath.ScanFilter : PathFilter {
private string <Name>k__BackingField
public string Name
public string get_Name()
public void set_Name(string value)
public IEnumerable`1<JToken> ExecuteFilter(IEnumerable`1<JToken> current, bool errorWhenNoMatch)
}
public Newtonsoft.Json.Linq.JToken : object {
private JTokenEqualityComparer _equalityComparer
private JContainer _parent
private JToken _previous
private JToken _next
private object _annotations
private JTokenType[] BooleanTypes
private JTokenType[] NumberTypes
private JTokenType[] StringTypes
private JTokenType[] GuidTypes
private JTokenType[] TimeSpanTypes
private JTokenType[] UriTypes
private JTokenType[] CharTypes
private JTokenType[] DateTimeTypes
private JTokenType[] BytesTypes
public JTokenEqualityComparer EqualityComparer
public JContainer Parent
public JToken Root
public JTokenType Type
public bool HasValues
public JToken Next
public JToken Previous
public string Path
public JToken Item
public JToken First
public JToken Last
private IJEnumerable`1<JToken> Newtonsoft.Json.Linq.IJEnumerable<Newtonsoft.Json.Linq.JToken>.Item
private int Newtonsoft.Json.IJsonLineInfo.LineNumber
private int Newtonsoft.Json.IJsonLineInfo.LinePosition
public JTokenEqualityComparer get_EqualityComparer()
public JContainer get_Parent()
internal void set_Parent(JContainer value)
public JToken get_Root()
internal JToken CloneToken()
internal bool DeepEquals(JToken node)
public JTokenType get_Type()
public bool get_HasValues()
public bool DeepEquals(JToken t1, JToken t2)
public JToken get_Next()
internal void set_Next(JToken value)
public JToken get_Previous()
internal void set_Previous(JToken value)
public string get_Path()
public void AddAfterSelf(object content)
public void AddBeforeSelf(object content)
public IEnumerable`1<JToken> Ancestors()
public IEnumerable`1<JToken> AncestorsAndSelf()
internal IEnumerable`1<JToken> GetAncestors(bool self)
public IEnumerable`1<JToken> AfterSelf()
public IEnumerable`1<JToken> BeforeSelf()
public JToken get_Item(object key)
public void set_Item(object key, JToken value)
public T Value(object key)
public JToken get_First()
public JToken get_Last()
public JEnumerable`1<JToken> Children()
public JEnumerable`1<T> Children()
public IEnumerable`1<T> Values()
public void Remove()
public void Replace(JToken value)
public void WriteTo(JsonWriter writer, JsonConverter[] converters)
public string ToString()
public string ToString(Formatting formatting, JsonConverter[] converters)
private JValue EnsureValue(JToken value)
private string GetType(JToken token)
private bool ValidateToken(JToken o, JTokenType[] validTypes, bool nullable)
public bool op_Explicit(JToken value)
public DateTimeOffset op_Explicit(JToken value)
public Nullable`1<bool> op_Explicit(JToken value)
public long op_Explicit(JToken value)
public Nullable`1<DateTime> op_Explicit(JToken value)
public Nullable`1<DateTimeOffset> op_Explicit(JToken value)
public Nullable`1<decimal> op_Explicit(JToken value)
public Nullable`1<double> op_Explicit(JToken value)
public Nullable`1<char> op_Explicit(JToken value)
public int op_Explicit(JToken value)
public short op_Explicit(JToken value)
public ushort op_Explicit(JToken value)
public char op_Explicit(JToken value)
public byte op_Explicit(JToken value)
public sbyte op_Explicit(JToken value)
public Nullable`1<int> op_Explicit(JToken value)
public Nullable`1<short> op_Explicit(JToken value)
public Nullable`1<ushort> op_Explicit(JToken value)
public Nullable`1<byte> op_Explicit(JToken value)
public Nullable`1<sbyte> op_Explicit(JToken value)
public DateTime op_Explicit(JToken value)
public Nullable`1<long> op_Explicit(JToken value)
public Nullable`1<float> op_Explicit(JToken value)
public decimal op_Explicit(JToken value)
public Nullable`1<UInt32> op_Explicit(JToken value)
public Nullable`1<ulong> op_Explicit(JToken value)
public double op_Explicit(JToken value)
public float op_Explicit(JToken value)
public string op_Explicit(JToken value)
public UInt32 op_Explicit(JToken value)
public ulong op_Explicit(JToken value)
public Byte[] op_Explicit(JToken value)
public Guid op_Explicit(JToken value)
public Nullable`1<Guid> op_Explicit(JToken value)
public TimeSpan op_Explicit(JToken value)
public Nullable`1<TimeSpan> op_Explicit(JToken value)
public Uri op_Explicit(JToken value)
public JToken op_Implicit(bool value)
public JToken op_Implicit(DateTimeOffset value)
public JToken op_Implicit(byte value)
public JToken op_Implicit(Nullable`1<byte> value)
public JToken op_Implicit(sbyte value)
public JToken op_Implicit(Nullable`1<sbyte> value)
public JToken op_Implicit(Nullable`1<bool> value)
public JToken op_Implicit(long value)
public JToken op_Implicit(Nullable`1<DateTime> value)
public JToken op_Implicit(Nullable`1<DateTimeOffset> value)
public JToken op_Implicit(Nullable`1<decimal> value)
public JToken op_Implicit(Nullable`1<double> value)
public JToken op_Implicit(short value)
public JToken op_Implicit(ushort value)
public JToken op_Implicit(int value)
public JToken op_Implicit(Nullable`1<int> value)
public JToken op_Implicit(DateTime value)
public JToken op_Implicit(Nullable`1<long> value)
public JToken op_Implicit(Nullable`1<float> value)
public JToken op_Implicit(decimal value)
public JToken op_Implicit(Nullable`1<short> value)
public JToken op_Implicit(Nullable`1<ushort> value)
public JToken op_Implicit(Nullable`1<UInt32> value)
public JToken op_Implicit(Nullable`1<ulong> value)
public JToken op_Implicit(double value)
public JToken op_Implicit(float value)
public JToken op_Implicit(string value)
public JToken op_Implicit(UInt32 value)
public JToken op_Implicit(ulong value)
public JToken op_Implicit(Byte[] value)
public JToken op_Implicit(Uri value)
public JToken op_Implicit(TimeSpan value)
public JToken op_Implicit(Nullable`1<TimeSpan> value)
public JToken op_Implicit(Guid value)
public JToken op_Implicit(Nullable`1<Guid> value)
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
private IEnumerator`1<JToken> System.Collections.Generic.IEnumerable<Newtonsoft.Json.Linq.JToken>.GetEnumerator()
internal int GetDeepHashCode()
private IJEnumerable`1<JToken> Newtonsoft.Json.Linq.IJEnumerable<Newtonsoft.Json.Linq.JToken>.get_Item(object key)
public JsonReader CreateReader()
internal JToken FromObjectInternal(object o, JsonSerializer jsonSerializer)
public JToken FromObject(object o)
public JToken FromObject(object o, JsonSerializer jsonSerializer)
public T ToObject()
public object ToObject(Type objectType)
public T ToObject(JsonSerializer jsonSerializer)
public object ToObject(Type objectType, JsonSerializer jsonSerializer)
public JToken ReadFrom(JsonReader reader)
public JToken ReadFrom(JsonReader reader, JsonLoadSettings settings)
public JToken Parse(string json)
public JToken Parse(string json, JsonLoadSettings settings)
public JToken Load(JsonReader reader, JsonLoadSettings settings)
public JToken Load(JsonReader reader)
internal void SetLineInfo(IJsonLineInfo lineInfo, JsonLoadSettings settings)
internal void SetLineInfo(int lineNumber, int linePosition)
private bool Newtonsoft.Json.IJsonLineInfo.HasLineInfo()
private int Newtonsoft.Json.IJsonLineInfo.get_LineNumber()
private int Newtonsoft.Json.IJsonLineInfo.get_LinePosition()
public JToken SelectToken(string path)
public JToken SelectToken(string path, bool errorWhenNoMatch)
public IEnumerable`1<JToken> SelectTokens(string path)
public IEnumerable`1<JToken> SelectTokens(string path, bool errorWhenNoMatch)
private object System.ICloneable.Clone()
public JToken DeepClone()
public void AddAnnotation(object annotation)
public T Annotation()
public object Annotation(Type type)
public IEnumerable`1<T> Annotations()
public IEnumerable`1<object> Annotations(Type type)
public void RemoveAnnotations()
public void RemoveAnnotations(Type type)
}
public Newtonsoft.Json.Linq.JTokenEqualityComparer : object {
public bool Equals(JToken x, JToken y)
public int GetHashCode(JToken obj)
}
public Newtonsoft.Json.Linq.JTokenReader : JsonReader {
private string _initialPath
private JToken _root
private JToken _parent
private JToken _current
public JToken CurrentToken
private int Newtonsoft.Json.IJsonLineInfo.LineNumber
private int Newtonsoft.Json.IJsonLineInfo.LinePosition
public string Path
public JToken get_CurrentToken()
public void .ctor(JToken token)
internal void .ctor(JToken token, string initialPath)
public bool Read()
private bool ReadOver(JToken t)
private bool ReadToEnd()
private Nullable`1<JsonToken> GetEndToken(JContainer c)
private bool ReadInto(JContainer c)
private bool SetEnd(JContainer c)
private void SetToken(JToken token)
private string SafeToString(object value)
private bool Newtonsoft.Json.IJsonLineInfo.HasLineInfo()
private int Newtonsoft.Json.IJsonLineInfo.get_LineNumber()
private int Newtonsoft.Json.IJsonLineInfo.get_LinePosition()
public string get_Path()
}
public Newtonsoft.Json.Linq.JTokenType : Enum {
public int value__
public JTokenType None
public JTokenType Object
public JTokenType Array
public JTokenType Constructor
public JTokenType Property
public JTokenType Comment
public JTokenType Integer
public JTokenType Float
public JTokenType String
public JTokenType Boolean
public JTokenType Null
public JTokenType Undefined
public JTokenType Date
public JTokenType Raw
public JTokenType Bytes
public JTokenType Guid
public JTokenType Uri
public JTokenType TimeSpan
}
public Newtonsoft.Json.Linq.JTokenWriter : JsonWriter {
private JContainer _token
private JContainer _parent
private JValue _value
private JToken _current
public JToken CurrentToken
public JToken Token
public JToken get_CurrentToken()
public JToken get_Token()
public void .ctor(JContainer container)
public void Flush()
public void Close()
public void WriteStartObject()
private void AddParent(JContainer container)
private void RemoveParent()
public void WriteStartArray()
public void WriteStartConstructor(string name)
protected void WriteEnd(JsonToken token)
public void WritePropertyName(string name)
private void AddValue(object value, JsonToken token)
internal void AddValue(JValue value, JsonToken token)
public void WriteValue(object value)
public void WriteNull()
public void WriteUndefined()
public void WriteRaw(string json)
public void WriteComment(string text)
public void WriteValue(string value)
public void WriteValue(int value)
public void WriteValue(UInt32 value)
public void WriteValue(long value)
public void WriteValue(ulong value)
public void WriteValue(float value)
public void WriteValue(double value)
public void WriteValue(bool value)
public void WriteValue(short value)
public void WriteValue(ushort value)
public void WriteValue(char value)
public void WriteValue(byte value)
public void WriteValue(sbyte value)
public void WriteValue(decimal value)
public void WriteValue(DateTime value)
public void WriteValue(DateTimeOffset value)
public void WriteValue(Byte[] value)
public void WriteValue(TimeSpan value)
public void WriteValue(Guid value)
public void WriteValue(Uri value)
}
public Newtonsoft.Json.Linq.JValue : JToken {
private JTokenType _valueType
private object _value
public bool HasValues
public JTokenType Type
public object Value
internal void .ctor(object value, JTokenType type)
public void .ctor(JValue other)
public void .ctor(long value)
public void .ctor(decimal value)
public void .ctor(char value)
public void .ctor(ulong value)
public void .ctor(double value)
public void .ctor(float value)
public void .ctor(DateTime value)
public void .ctor(DateTimeOffset value)
public void .ctor(bool value)
public void .ctor(string value)
public void .ctor(Guid value)
public void .ctor(Uri value)
public void .ctor(TimeSpan value)
public void .ctor(object value)
internal bool DeepEquals(JToken node)
public bool get_HasValues()
internal int Compare(JTokenType valueType, object objA, object objB)
private int CompareFloat(object objA, object objB)
internal JToken CloneToken()
public JValue CreateComment(string value)
public JValue CreateString(string value)
public JValue CreateNull()
public JValue CreateUndefined()
private JTokenType GetValueType(Nullable`1<JTokenType> current, object value)
private JTokenType GetStringValueType(Nullable`1<JTokenType> current)
public JTokenType get_Type()
public object get_Value()
public void set_Value(object value)
public void WriteTo(JsonWriter writer, JsonConverter[] converters)
internal int GetDeepHashCode()
private bool ValuesEquals(JValue v1, JValue v2)
public bool Equals(JValue other)
public bool Equals(object obj)
public int GetHashCode()
public string ToString()
public string ToString(string format)
public string ToString(IFormatProvider formatProvider)
public string ToString(string format, IFormatProvider formatProvider)
private int System.IComparable.CompareTo(object obj)
public int CompareTo(JValue obj)
private TypeCode System.IConvertible.GetTypeCode()
private bool System.IConvertible.ToBoolean(IFormatProvider provider)
private char System.IConvertible.ToChar(IFormatProvider provider)
private sbyte System.IConvertible.ToSByte(IFormatProvider provider)
private byte System.IConvertible.ToByte(IFormatProvider provider)
private short System.IConvertible.ToInt16(IFormatProvider provider)
private ushort System.IConvertible.ToUInt16(IFormatProvider provider)
private int System.IConvertible.ToInt32(IFormatProvider provider)
private UInt32 System.IConvertible.ToUInt32(IFormatProvider provider)
private long System.IConvertible.ToInt64(IFormatProvider provider)
private ulong System.IConvertible.ToUInt64(IFormatProvider provider)
private float System.IConvertible.ToSingle(IFormatProvider provider)
private double System.IConvertible.ToDouble(IFormatProvider provider)
private decimal System.IConvertible.ToDecimal(IFormatProvider provider)
private DateTime System.IConvertible.ToDateTime(IFormatProvider provider)
private object System.IConvertible.ToType(Type conversionType, IFormatProvider provider)
}
public Newtonsoft.Json.Linq.LineInfoHandling : Enum {
public int value__
public LineInfoHandling Ignore
public LineInfoHandling Load
}
public Newtonsoft.Json.Linq.MergeArrayHandling : Enum {
public int value__
public MergeArrayHandling Concat
public MergeArrayHandling Union
public MergeArrayHandling Replace
public MergeArrayHandling Merge
}
public Newtonsoft.Json.Linq.MergeNullValueHandling : Enum {
public int value__
public MergeNullValueHandling Ignore
public MergeNullValueHandling Merge
}
public Newtonsoft.Json.MemberSerialization : Enum {
public int value__
public MemberSerialization OptOut
public MemberSerialization OptIn
public MemberSerialization Fields
}
public Newtonsoft.Json.MetadataPropertyHandling : Enum {
public int value__
public MetadataPropertyHandling Default
public MetadataPropertyHandling ReadAhead
public MetadataPropertyHandling Ignore
}
public Newtonsoft.Json.MissingMemberHandling : Enum {
public int value__
public MissingMemberHandling Ignore
public MissingMemberHandling Error
}
public Newtonsoft.Json.NullValueHandling : Enum {
public int value__
public NullValueHandling Include
public NullValueHandling Ignore
}
public Newtonsoft.Json.ObjectCreationHandling : Enum {
public int value__
public ObjectCreationHandling Auto
public ObjectCreationHandling Reuse
public ObjectCreationHandling Replace
}
public Newtonsoft.Json.PreserveReferencesHandling : Enum {
public int value__
public PreserveReferencesHandling None
public PreserveReferencesHandling Objects
public PreserveReferencesHandling Arrays
public PreserveReferencesHandling All
}
internal Newtonsoft.Json.ReadType : Enum {
public int value__
public ReadType Read
public ReadType ReadAsInt32
public ReadType ReadAsBytes
public ReadType ReadAsString
public ReadType ReadAsDecimal
public ReadType ReadAsDateTime
public ReadType ReadAsDateTimeOffset
public ReadType ReadAsDouble
public ReadType ReadAsBoolean
}
public Newtonsoft.Json.ReferenceLoopHandling : Enum {
public int value__
public ReferenceLoopHandling Error
public ReferenceLoopHandling Ignore
public ReferenceLoopHandling Serialize
}
public Newtonsoft.Json.Required : Enum {
public int value__
public Required Default
public Required AllowNull
public Required Always
public Required DisallowNull
}
public Newtonsoft.Json.Schema.Extensions : object {
public bool IsValid(JToken source, JsonSchema schema)
public bool IsValid(JToken source, JsonSchema schema, IList`1& errorMessages)
public void Validate(JToken source, JsonSchema schema)
public void Validate(JToken source, JsonSchema schema, ValidationEventHandler validationEventHandler)
}
public Newtonsoft.Json.Schema.JsonSchema : object {
private string <Id>k__BackingField
private string <Title>k__BackingField
private Nullable`1<bool> <Required>k__BackingField
private Nullable`1<bool> <ReadOnly>k__BackingField
private Nullable`1<bool> <Hidden>k__BackingField
private Nullable`1<bool> <Transient>k__BackingField
private string <Description>k__BackingField
private Nullable`1<JsonSchemaType> <Type>k__BackingField
private string <Pattern>k__BackingField
private Nullable`1<int> <MinimumLength>k__BackingField
private Nullable`1<int> <MaximumLength>k__BackingField
private Nullable`1<double> <DivisibleBy>k__BackingField
private Nullable`1<double> <Minimum>k__BackingField
private Nullable`1<double> <Maximum>k__BackingField
private Nullable`1<bool> <ExclusiveMinimum>k__BackingField
private Nullable`1<bool> <ExclusiveMaximum>k__BackingField
private Nullable`1<int> <MinimumItems>k__BackingField
private Nullable`1<int> <MaximumItems>k__BackingField
private IList`1<JsonSchema> <Items>k__BackingField
private bool <PositionalItemsValidation>k__BackingField
private JsonSchema <AdditionalItems>k__BackingField
private bool <AllowAdditionalItems>k__BackingField
private bool <UniqueItems>k__BackingField
private IDictionary`2<string, JsonSchema> <Properties>k__BackingField
private JsonSchema <AdditionalProperties>k__BackingField
private IDictionary`2<string, JsonSchema> <PatternProperties>k__BackingField
private bool <AllowAdditionalProperties>k__BackingField
private string <Requires>k__BackingField
private IList`1<JToken> <Enum>k__BackingField
private Nullable`1<JsonSchemaType> <Disallow>k__BackingField
private JToken <Default>k__BackingField
private IList`1<JsonSchema> <Extends>k__BackingField
private string <Format>k__BackingField
private string <Location>k__BackingField
private string _internalId
private string <DeferredReference>k__BackingField
private bool <ReferencesResolved>k__BackingField
public string Id
public string Title
public Nullable`1<bool> Required
public Nullable`1<bool> ReadOnly
public Nullable`1<bool> Hidden
public Nullable`1<bool> Transient
public string Description
public Nullable`1<JsonSchemaType> Type
public string Pattern
public Nullable`1<int> MinimumLength
public Nullable`1<int> MaximumLength
public Nullable`1<double> DivisibleBy
public Nullable`1<double> Minimum
public Nullable`1<double> Maximum
public Nullable`1<bool> ExclusiveMinimum
public Nullable`1<bool> ExclusiveMaximum
public Nullable`1<int> MinimumItems
public Nullable`1<int> MaximumItems
public IList`1<JsonSchema> Items
public bool PositionalItemsValidation
public JsonSchema AdditionalItems
public bool AllowAdditionalItems
public bool UniqueItems
public IDictionary`2<string, JsonSchema> Properties
public JsonSchema AdditionalProperties
public IDictionary`2<string, JsonSchema> PatternProperties
public bool AllowAdditionalProperties
public string Requires
public IList`1<JToken> Enum
public Nullable`1<JsonSchemaType> Disallow
public JToken Default
public IList`1<JsonSchema> Extends
public string Format
internal string Location
internal string InternalId
internal string DeferredReference
internal bool ReferencesResolved
public string get_Id()
public void set_Id(string value)
public string get_Title()
public void set_Title(string value)
public Nullable`1<bool> get_Required()
public void set_Required(Nullable`1<bool> value)
public Nullable`1<bool> get_ReadOnly()
public void set_ReadOnly(Nullable`1<bool> value)
public Nullable`1<bool> get_Hidden()
public void set_Hidden(Nullable`1<bool> value)
public Nullable`1<bool> get_Transient()
public void set_Transient(Nullable`1<bool> value)
public string get_Description()
public void set_Description(string value)
public Nullable`1<JsonSchemaType> get_Type()
public void set_Type(Nullable`1<JsonSchemaType> value)
public string get_Pattern()
public void set_Pattern(string value)
public Nullable`1<int> get_MinimumLength()
public void set_MinimumLength(Nullable`1<int> value)
public Nullable`1<int> get_MaximumLength()
public void set_MaximumLength(Nullable`1<int> value)
public Nullable`1<double> get_DivisibleBy()
public void set_DivisibleBy(Nullable`1<double> value)
public Nullable`1<double> get_Minimum()
public void set_Minimum(Nullable`1<double> value)
public Nullable`1<double> get_Maximum()
public void set_Maximum(Nullable`1<double> value)
public Nullable`1<bool> get_ExclusiveMinimum()
public void set_ExclusiveMinimum(Nullable`1<bool> value)
public Nullable`1<bool> get_ExclusiveMaximum()
public void set_ExclusiveMaximum(Nullable`1<bool> value)
public Nullable`1<int> get_MinimumItems()
public void set_MinimumItems(Nullable`1<int> value)
public Nullable`1<int> get_MaximumItems()
public void set_MaximumItems(Nullable`1<int> value)
public IList`1<JsonSchema> get_Items()
public void set_Items(IList`1<JsonSchema> value)
public bool get_PositionalItemsValidation()
public void set_PositionalItemsValidation(bool value)
public JsonSchema get_AdditionalItems()
public void set_AdditionalItems(JsonSchema value)
public bool get_AllowAdditionalItems()
public void set_AllowAdditionalItems(bool value)
public bool get_UniqueItems()
public void set_UniqueItems(bool value)
public IDictionary`2<string, JsonSchema> get_Properties()
public void set_Properties(IDictionary`2<string, JsonSchema> value)
public JsonSchema get_AdditionalProperties()
public void set_AdditionalProperties(JsonSchema value)
public IDictionary`2<string, JsonSchema> get_PatternProperties()
public void set_PatternProperties(IDictionary`2<string, JsonSchema> value)
public bool get_AllowAdditionalProperties()
public void set_AllowAdditionalProperties(bool value)
public string get_Requires()
public void set_Requires(string value)
public IList`1<JToken> get_Enum()
public void set_Enum(IList`1<JToken> value)
public Nullable`1<JsonSchemaType> get_Disallow()
public void set_Disallow(Nullable`1<JsonSchemaType> value)
public JToken get_Default()
public void set_Default(JToken value)
public IList`1<JsonSchema> get_Extends()
public void set_Extends(IList`1<JsonSchema> value)
public string get_Format()
public void set_Format(string value)
internal string get_Location()
internal void set_Location(string value)
internal string get_InternalId()
internal string get_DeferredReference()
internal void set_DeferredReference(string value)
internal bool get_ReferencesResolved()
internal void set_ReferencesResolved(bool value)
public JsonSchema Read(JsonReader reader)
public JsonSchema Read(JsonReader reader, JsonSchemaResolver resolver)
public JsonSchema Parse(string json)
public JsonSchema Parse(string json, JsonSchemaResolver resolver)
public void WriteTo(JsonWriter writer)
public void WriteTo(JsonWriter writer, JsonSchemaResolver resolver)
public string ToString()
}
internal Newtonsoft.Json.Schema.JsonSchemaBuilder : object {
private IList`1<JsonSchema> _stack
private JsonSchemaResolver _resolver
private IDictionary`2<string, JsonSchema> _documentSchemas
private JsonSchema _currentSchema
private JObject _rootSchema
private JsonSchema CurrentSchema
public void .ctor(JsonSchemaResolver resolver)
private void Push(JsonSchema value)
private JsonSchema Pop()
private JsonSchema get_CurrentSchema()
internal JsonSchema Read(JsonReader reader)
private string UnescapeReference(string reference)
private JsonSchema ResolveReferences(JsonSchema schema)
private JsonSchema BuildSchema(JToken token)
private void ProcessSchemaProperties(JObject schemaObject)
private void ProcessExtends(JToken token)
private void ProcessEnum(JToken token)
private void ProcessAdditionalProperties(JToken token)
private void ProcessAdditionalItems(JToken token)
private IDictionary`2<string, JsonSchema> ProcessProperties(JToken token)
private void ProcessItems(JToken token)
private Nullable`1<JsonSchemaType> ProcessType(JToken token)
internal JsonSchemaType MapType(string type)
internal string MapType(JsonSchemaType type)
}
internal Newtonsoft.Json.Schema.JsonSchemaConstants : object {
public string TypePropertyName
public string PropertiesPropertyName
public string ItemsPropertyName
public string AdditionalItemsPropertyName
public string RequiredPropertyName
public string PatternPropertiesPropertyName
public string AdditionalPropertiesPropertyName
public string RequiresPropertyName
public string MinimumPropertyName
public string MaximumPropertyName
public string ExclusiveMinimumPropertyName
public string ExclusiveMaximumPropertyName
public string MinimumItemsPropertyName
public string MaximumItemsPropertyName
public string PatternPropertyName
public string MaximumLengthPropertyName
public string MinimumLengthPropertyName
public string EnumPropertyName
public string ReadOnlyPropertyName
public string TitlePropertyName
public string DescriptionPropertyName
public string FormatPropertyName
public string DefaultPropertyName
public string TransientPropertyName
public string DivisibleByPropertyName
public string HiddenPropertyName
public string DisallowPropertyName
public string ExtendsPropertyName
public string IdPropertyName
public string UniqueItemsPropertyName
public string OptionValuePropertyName
public string OptionLabelPropertyName
public IDictionary`2<string, JsonSchemaType> JsonSchemaTypeMapping
}
public Newtonsoft.Json.Schema.JsonSchemaException : JsonException {
private int <LineNumber>k__BackingField
private int <LinePosition>k__BackingField
private string <Path>k__BackingField
public int LineNumber
public int LinePosition
public string Path
public int get_LineNumber()
private void set_LineNumber(int value)
public int get_LinePosition()
private void set_LinePosition(int value)
public string get_Path()
private void set_Path(string value)
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
public void .ctor(SerializationInfo info, StreamingContext context)
internal void .ctor(string message, Exception innerException, string path, int lineNumber, int linePosition)
}
public Newtonsoft.Json.Schema.JsonSchemaGenerator : object {
private UndefinedSchemaIdHandling <UndefinedSchemaIdHandling>k__BackingField
private IContractResolver _contractResolver
private JsonSchemaResolver _resolver
private IList`1<TypeSchema> _stack
private JsonSchema _currentSchema
public UndefinedSchemaIdHandling UndefinedSchemaIdHandling
public IContractResolver ContractResolver
private JsonSchema CurrentSchema
public UndefinedSchemaIdHandling get_UndefinedSchemaIdHandling()
public void set_UndefinedSchemaIdHandling(UndefinedSchemaIdHandling value)
public IContractResolver get_ContractResolver()
public void set_ContractResolver(IContractResolver value)
private JsonSchema get_CurrentSchema()
private void Push(TypeSchema typeSchema)
private TypeSchema Pop()
public JsonSchema Generate(Type type)
public JsonSchema Generate(Type type, JsonSchemaResolver resolver)
public JsonSchema Generate(Type type, bool rootSchemaNullable)
public JsonSchema Generate(Type type, JsonSchemaResolver resolver, bool rootSchemaNullable)
private string GetTitle(Type type)
private string GetDescription(Type type)
private string GetTypeId(Type type, bool explicitOnly)
private JsonSchema GenerateInternal(Type type, Required valueRequired, bool required)
private JsonSchemaType AddNullType(JsonSchemaType type, Required valueRequired)
private bool HasFlag(DefaultValueHandling value, DefaultValueHandling flag)
private void GenerateObjectSchema(Type type, JsonObjectContract contract)
private void GenerateISerializableContract(Type type, JsonISerializableContract contract)
internal bool HasFlag(Nullable`1<JsonSchemaType> value, JsonSchemaType flag)
private JsonSchemaType GetJsonSchemaType(Type type, Required valueRequired)
}
internal Newtonsoft.Json.Schema.JsonSchemaModel : object {
private bool <Required>k__BackingField
private JsonSchemaType <Type>k__BackingField
private Nullable`1<int> <MinimumLength>k__BackingField
private Nullable`1<int> <MaximumLength>k__BackingField
private Nullable`1<double> <DivisibleBy>k__BackingField
private Nullable`1<double> <Minimum>k__BackingField
private Nullable`1<double> <Maximum>k__BackingField
private bool <ExclusiveMinimum>k__BackingField
private bool <ExclusiveMaximum>k__BackingField
private Nullable`1<int> <MinimumItems>k__BackingField
private Nullable`1<int> <MaximumItems>k__BackingField
private IList`1<string> <Patterns>k__BackingField
private IList`1<JsonSchemaModel> <Items>k__BackingField
private IDictionary`2<string, JsonSchemaModel> <Properties>k__BackingField
private IDictionary`2<string, JsonSchemaModel> <PatternProperties>k__BackingField
private JsonSchemaModel <AdditionalProperties>k__BackingField
private JsonSchemaModel <AdditionalItems>k__BackingField
private bool <PositionalItemsValidation>k__BackingField
private bool <AllowAdditionalProperties>k__BackingField
private bool <AllowAdditionalItems>k__BackingField
private bool <UniqueItems>k__BackingField
private IList`1<JToken> <Enum>k__BackingField
private JsonSchemaType <Disallow>k__BackingField
public bool Required
public JsonSchemaType Type
public Nullable`1<int> MinimumLength
public Nullable`1<int> MaximumLength
public Nullable`1<double> DivisibleBy
public Nullable`1<double> Minimum
public Nullable`1<double> Maximum
public bool ExclusiveMinimum
public bool ExclusiveMaximum
public Nullable`1<int> MinimumItems
public Nullable`1<int> MaximumItems
public IList`1<string> Patterns
public IList`1<JsonSchemaModel> Items
public IDictionary`2<string, JsonSchemaModel> Properties
public IDictionary`2<string, JsonSchemaModel> PatternProperties
public JsonSchemaModel AdditionalProperties
public JsonSchemaModel AdditionalItems
public bool PositionalItemsValidation
public bool AllowAdditionalProperties
public bool AllowAdditionalItems
public bool UniqueItems
public IList`1<JToken> Enum
public JsonSchemaType Disallow
public bool get_Required()
public void set_Required(bool value)
public JsonSchemaType get_Type()
public void set_Type(JsonSchemaType value)
public Nullable`1<int> get_MinimumLength()
public void set_MinimumLength(Nullable`1<int> value)
public Nullable`1<int> get_MaximumLength()
public void set_MaximumLength(Nullable`1<int> value)
public Nullable`1<double> get_DivisibleBy()
public void set_DivisibleBy(Nullable`1<double> value)
public Nullable`1<double> get_Minimum()
public void set_Minimum(Nullable`1<double> value)
public Nullable`1<double> get_Maximum()
public void set_Maximum(Nullable`1<double> value)
public bool get_ExclusiveMinimum()
public void set_ExclusiveMinimum(bool value)
public bool get_ExclusiveMaximum()
public void set_ExclusiveMaximum(bool value)
public Nullable`1<int> get_MinimumItems()
public void set_MinimumItems(Nullable`1<int> value)
public Nullable`1<int> get_MaximumItems()
public void set_MaximumItems(Nullable`1<int> value)
public IList`1<string> get_Patterns()
public void set_Patterns(IList`1<string> value)
public IList`1<JsonSchemaModel> get_Items()
public void set_Items(IList`1<JsonSchemaModel> value)
public IDictionary`2<string, JsonSchemaModel> get_Properties()
public void set_Properties(IDictionary`2<string, JsonSchemaModel> value)
public IDictionary`2<string, JsonSchemaModel> get_PatternProperties()
public void set_PatternProperties(IDictionary`2<string, JsonSchemaModel> value)
public JsonSchemaModel get_AdditionalProperties()
public void set_AdditionalProperties(JsonSchemaModel value)
public JsonSchemaModel get_AdditionalItems()
public void set_AdditionalItems(JsonSchemaModel value)
public bool get_PositionalItemsValidation()
public void set_PositionalItemsValidation(bool value)
public bool get_AllowAdditionalProperties()
public void set_AllowAdditionalProperties(bool value)
public bool get_AllowAdditionalItems()
public void set_AllowAdditionalItems(bool value)
public bool get_UniqueItems()
public void set_UniqueItems(bool value)
public IList`1<JToken> get_Enum()
public void set_Enum(IList`1<JToken> value)
public JsonSchemaType get_Disallow()
public void set_Disallow(JsonSchemaType value)
public JsonSchemaModel Create(IList`1<JsonSchema> schemata)
private void Combine(JsonSchemaModel model, JsonSchema schema)
}
internal Newtonsoft.Json.Schema.JsonSchemaModelBuilder : object {
private JsonSchemaNodeCollection _nodes
private Dictionary`2<JsonSchemaNode, JsonSchemaModel> _nodeModels
private JsonSchemaNode _node
public JsonSchemaModel Build(JsonSchema schema)
public JsonSchemaNode AddSchema(JsonSchemaNode existingNode, JsonSchema schema)
public void AddProperties(IDictionary`2<string, JsonSchema> source, IDictionary`2<string, JsonSchemaNode> target)
public void AddProperty(IDictionary`2<string, JsonSchemaNode> target, string propertyName, JsonSchema schema)
public void AddItem(JsonSchemaNode parentNode, int index, JsonSchema schema)
public void AddAdditionalProperties(JsonSchemaNode parentNode, JsonSchema schema)
public void AddAdditionalItems(JsonSchemaNode parentNode, JsonSchema schema)
private JsonSchemaModel BuildNodeModel(JsonSchemaNode node)
}
internal Newtonsoft.Json.Schema.JsonSchemaNode : object {
private string <Id>k__BackingField
private ReadOnlyCollection`1<JsonSchema> <Schemas>k__BackingField
private Dictionary`2<string, JsonSchemaNode> <Properties>k__BackingField
private Dictionary`2<string, JsonSchemaNode> <PatternProperties>k__BackingField
private List`1<JsonSchemaNode> <Items>k__BackingField
private JsonSchemaNode <AdditionalProperties>k__BackingField
private JsonSchemaNode <AdditionalItems>k__BackingField
public string Id
public ReadOnlyCollection`1<JsonSchema> Schemas
public Dictionary`2<string, JsonSchemaNode> Properties
public Dictionary`2<string, JsonSchemaNode> PatternProperties
public List`1<JsonSchemaNode> Items
public JsonSchemaNode AdditionalProperties
public JsonSchemaNode AdditionalItems
public string get_Id()
private void set_Id(string value)
public ReadOnlyCollection`1<JsonSchema> get_Schemas()
private void set_Schemas(ReadOnlyCollection`1<JsonSchema> value)
public Dictionary`2<string, JsonSchemaNode> get_Properties()
private void set_Properties(Dictionary`2<string, JsonSchemaNode> value)
public Dictionary`2<string, JsonSchemaNode> get_PatternProperties()
private void set_PatternProperties(Dictionary`2<string, JsonSchemaNode> value)
public List`1<JsonSchemaNode> get_Items()
private void set_Items(List`1<JsonSchemaNode> value)
public JsonSchemaNode get_AdditionalProperties()
public void set_AdditionalProperties(JsonSchemaNode value)
public JsonSchemaNode get_AdditionalItems()
public void set_AdditionalItems(JsonSchemaNode value)
public void .ctor(JsonSchema schema)
private void .ctor(JsonSchemaNode source, JsonSchema schema)
public JsonSchemaNode Combine(JsonSchema schema)
public string GetId(IEnumerable`1<JsonSchema> schemata)
}
internal Newtonsoft.Json.Schema.JsonSchemaNodeCollection : KeyedCollection`2<string, JsonSchemaNode> {
protected string GetKeyForItem(JsonSchemaNode item)
}
public Newtonsoft.Json.Schema.JsonSchemaResolver : object {
private IList`1<JsonSchema> <LoadedSchemas>k__BackingField
public IList`1<JsonSchema> LoadedSchemas
public IList`1<JsonSchema> get_LoadedSchemas()
protected void set_LoadedSchemas(IList`1<JsonSchema> value)
public JsonSchema GetSchema(string reference)
}
public Newtonsoft.Json.Schema.JsonSchemaType : Enum {
public int value__
public JsonSchemaType None
public JsonSchemaType String
public JsonSchemaType Float
public JsonSchemaType Integer
public JsonSchemaType Boolean
public JsonSchemaType Object
public JsonSchemaType Array
public JsonSchemaType Null
public JsonSchemaType Any
}
internal Newtonsoft.Json.Schema.JsonSchemaWriter : object {
private JsonWriter _writer
private JsonSchemaResolver _resolver
public void .ctor(JsonWriter writer, JsonSchemaResolver resolver)
private void ReferenceOrWriteSchema(JsonSchema schema)
public void WriteSchema(JsonSchema schema)
private void WriteSchemaDictionaryIfNotNull(JsonWriter writer, string propertyName, IDictionary`2<string, JsonSchema> properties)
private void WriteItems(JsonSchema schema)
private void WriteType(string propertyName, JsonWriter writer, JsonSchemaType type)
private void WritePropertyIfNotNull(JsonWriter writer, string propertyName, object value)
}
public Newtonsoft.Json.Schema.UndefinedSchemaIdHandling : Enum {
public int value__
public UndefinedSchemaIdHandling None
public UndefinedSchemaIdHandling UseTypeName
public UndefinedSchemaIdHandling UseAssemblyQualifiedName
}
public Newtonsoft.Json.Schema.ValidationEventArgs : EventArgs {
private JsonSchemaException _ex
public JsonSchemaException Exception
public string Path
public string Message
internal void .ctor(JsonSchemaException ex)
public JsonSchemaException get_Exception()
public string get_Path()
public string get_Message()
}
public Newtonsoft.Json.Schema.ValidationEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, ValidationEventArgs e)
public IAsyncResult BeginInvoke(object sender, ValidationEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
internal Newtonsoft.Json.Serialization.CachedAttributeGetter`1 : object {
private ThreadSafeStore`2<object, T> TypeAttributeCache
public T GetAttribute(object type)
}
public Newtonsoft.Json.Serialization.CamelCasePropertyNamesContractResolver : DefaultContractResolver {
protected string ResolvePropertyName(string propertyName)
}
public Newtonsoft.Json.Serialization.DefaultContractResolver : object {
private IContractResolver _instance
private JsonConverter[] BuiltInConverters
private object TypeContractCacheLock
private DefaultContractResolverState _sharedState
private DefaultContractResolverState _instanceState
private bool _sharedCache
private BindingFlags <DefaultMembersSearchFlags>k__BackingField
private bool <SerializeCompilerGeneratedMembers>k__BackingField
private bool <IgnoreSerializableInterface>k__BackingField
private bool <IgnoreSerializableAttribute>k__BackingField
internal IContractResolver Instance
public bool DynamicCodeGeneration
public BindingFlags DefaultMembersSearchFlags
public bool SerializeCompilerGeneratedMembers
public bool IgnoreSerializableInterface
public bool IgnoreSerializableAttribute
internal IContractResolver get_Instance()
public bool get_DynamicCodeGeneration()
public BindingFlags get_DefaultMembersSearchFlags()
public void set_DefaultMembersSearchFlags(BindingFlags value)
public bool get_SerializeCompilerGeneratedMembers()
public void set_SerializeCompilerGeneratedMembers(bool value)
public bool get_IgnoreSerializableInterface()
public void set_IgnoreSerializableInterface(bool value)
public bool get_IgnoreSerializableAttribute()
public void set_IgnoreSerializableAttribute(bool value)
public void .ctor(bool shareCache)
internal DefaultContractResolverState GetState()
public JsonContract ResolveContract(Type type)
protected List`1<MemberInfo> GetSerializableMembers(Type objectType)
private bool ShouldSerializeEntityMember(MemberInfo memberInfo)
protected JsonObjectContract CreateObjectContract(Type objectType)
private MemberInfo GetExtensionDataMemberForType(Type type)
private void SetExtensionDataDelegates(JsonObjectContract contract, MemberInfo member)
private ConstructorInfo GetAttributeConstructor(Type objectType)
private ConstructorInfo GetParameterizedConstructor(Type objectType)
protected IList`1<JsonProperty> CreateConstructorParameters(ConstructorInfo constructor, JsonPropertyCollection memberProperties)
protected JsonProperty CreatePropertyFromConstructorParameter(JsonProperty matchingMemberProperty, ParameterInfo parameterInfo)
protected JsonConverter ResolveContractConverter(Type objectType)
private Func`1<object> GetDefaultCreator(Type createdType)
private void InitializeContract(JsonContract contract)
private void ResolveCallbackMethods(JsonContract contract, Type t)
private void GetCallbackMethodsForType(Type type, List`1& onSerializing, List`1& onSerialized, List`1& onDeserializing, List`1& onDeserialized, List`1& onError)
private bool ShouldSkipDeserialized(Type t)
private bool ShouldSkipSerializing(Type t)
private List`1<Type> GetClassHierarchyForType(Type type)
protected JsonDictionaryContract CreateDictionaryContract(Type objectType)
protected JsonArrayContract CreateArrayContract(Type objectType)
protected JsonPrimitiveContract CreatePrimitiveContract(Type objectType)
protected JsonLinqContract CreateLinqContract(Type objectType)
protected JsonISerializableContract CreateISerializableContract(Type objectType)
protected JsonStringContract CreateStringContract(Type objectType)
protected JsonContract CreateContract(Type objectType)
internal bool IsJsonPrimitiveType(Type t)
internal bool IsIConvertible(Type t)
internal bool CanConvertToString(Type type)
private bool IsValidCallback(MethodInfo method, ParameterInfo[] parameters, Type attributeType, MethodInfo currentCallback, Type& prevAttributeType)
internal string GetClrTypeFullName(Type type)
protected IList`1<JsonProperty> CreateProperties(Type type, MemberSerialization memberSerialization)
protected IValueProvider CreateMemberValueProvider(MemberInfo member)
protected JsonProperty CreateProperty(MemberInfo member, MemberSerialization memberSerialization)
private void SetPropertySettingsFromAttributes(JsonProperty property, object attributeProvider, string name, Type declaringType, MemberSerialization memberSerialization, Boolean& allowNonPublicAccess)
private Predicate`1<object> CreateShouldSerializeTest(MemberInfo member)
private void SetIsSpecifiedActions(JsonProperty property, MemberInfo member, bool allowNonPublicAccess)
protected string ResolvePropertyName(string propertyName)
protected string ResolveDictionaryKey(string dictionaryKey)
public string GetResolvedPropertyName(string propertyName)
}
internal Newtonsoft.Json.Serialization.DefaultContractResolverState : object {
public Dictionary`2<ResolverContractKey, JsonContract> ContractCache
public PropertyNameTable NameTable
}
internal Newtonsoft.Json.Serialization.DefaultReferenceResolver : object {
private int _referenceCount
private BidirectionalDictionary`2<string, object> GetMappings(object context)
public object ResolveReference(object context, string reference)
public string GetReference(object context, object value)
public void AddReference(object context, string reference, object value)
public bool IsReferenced(object context, object value)
}
public Newtonsoft.Json.Serialization.DefaultSerializationBinder : SerializationBinder {
internal DefaultSerializationBinder Instance
private ThreadSafeStore`2<TypeNameKey, Type> _typeCache
private Type GetTypeFromTypeNameKey(TypeNameKey typeNameKey)
public Type BindToType(string assemblyName, string typeName)
}
public Newtonsoft.Json.Serialization.DiagnosticsTraceWriter : object {
private TraceLevel <LevelFilter>k__BackingField
public TraceLevel LevelFilter
public TraceLevel get_LevelFilter()
public void set_LevelFilter(TraceLevel value)
private TraceEventType GetTraceEventType(TraceLevel level)
public void Trace(TraceLevel level, string message, Exception ex)
}
public Newtonsoft.Json.Serialization.DynamicValueProvider : object {
private MemberInfo _memberInfo
private Func`2<object, object> _getter
private Action`2<object, object> _setter
public void .ctor(MemberInfo memberInfo)
public void SetValue(object target, object value)
public object GetValue(object target)
}
public Newtonsoft.Json.Serialization.ErrorContext : object {
private bool <Traced>k__BackingField
private Exception <Error>k__BackingField
private object <OriginalObject>k__BackingField
private object <Member>k__BackingField
private string <Path>k__BackingField
private bool <Handled>k__BackingField
internal bool Traced
public Exception Error
public object OriginalObject
public object Member
public string Path
public bool Handled
internal void .ctor(object originalObject, object member, string path, Exception error)
internal bool get_Traced()
internal void set_Traced(bool value)
public Exception get_Error()
private void set_Error(Exception value)
public object get_OriginalObject()
private void set_OriginalObject(object value)
public object get_Member()
private void set_Member(object value)
public string get_Path()
private void set_Path(string value)
public bool get_Handled()
public void set_Handled(bool value)
}
public Newtonsoft.Json.Serialization.ErrorEventArgs : EventArgs {
private object <CurrentObject>k__BackingField
private ErrorContext <ErrorContext>k__BackingField
public object CurrentObject
public ErrorContext ErrorContext
public object get_CurrentObject()
private void set_CurrentObject(object value)
public ErrorContext get_ErrorContext()
private void set_ErrorContext(ErrorContext value)
public void .ctor(object currentObject, ErrorContext errorContext)
}
public Newtonsoft.Json.Serialization.ExtensionDataGetter : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public IEnumerable`1<KeyValuePair`2<object, object>> Invoke(object o)
public IAsyncResult BeginInvoke(object o, AsyncCallback callback, object object)
public IEnumerable`1<KeyValuePair`2<object, object>> EndInvoke(IAsyncResult result)
}
public Newtonsoft.Json.Serialization.ExtensionDataSetter : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object o, string key, object value)
public IAsyncResult BeginInvoke(object o, string key, object value, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public Newtonsoft.Json.Serialization.IAttributeProvider {
public IList`1<Attribute> GetAttributes(bool inherit)
public IList`1<Attribute> GetAttributes(Type attributeType, bool inherit)
}
public Newtonsoft.Json.Serialization.IContractResolver {
public JsonContract ResolveContract(Type type)
}
public Newtonsoft.Json.Serialization.IReferenceResolver {
public object ResolveReference(object context, string reference)
public string GetReference(object context, object value)
public bool IsReferenced(object context, object value)
public void AddReference(object context, string reference, object value)
}
public Newtonsoft.Json.Serialization.ITraceWriter {
public TraceLevel LevelFilter
public TraceLevel get_LevelFilter()
public void Trace(TraceLevel level, string message, Exception ex)
}
public Newtonsoft.Json.Serialization.IValueProvider {
public void SetValue(object target, object value)
public object GetValue(object target)
}
public Newtonsoft.Json.Serialization.JsonArrayContract : JsonContainerContract {
private Type <CollectionItemType>k__BackingField
private bool <IsMultidimensionalArray>k__BackingField
private Type _genericCollectionDefinitionType
private Type _genericWrapperType
private ObjectConstructor`1<object> _genericWrapperCreator
private Func`1<object> _genericTemporaryCollectionCreator
private bool <IsArray>k__BackingField
private bool <ShouldCreateWrapper>k__BackingField
private bool <CanDeserialize>k__BackingField
private ConstructorInfo _parameterizedConstructor
private ObjectConstructor`1<object> _parameterizedCreator
private ObjectConstructor`1<object> _overrideCreator
private bool <HasParameterizedCreator>k__BackingField
public Type CollectionItemType
public bool IsMultidimensionalArray
internal bool IsArray
internal bool ShouldCreateWrapper
internal bool CanDeserialize
internal ObjectConstructor`1<object> ParameterizedCreator
public ObjectConstructor`1<object> OverrideCreator
public bool HasParameterizedCreator
internal bool HasParameterizedCreatorInternal
public Type get_CollectionItemType()
private void set_CollectionItemType(Type value)
public bool get_IsMultidimensionalArray()
private void set_IsMultidimensionalArray(bool value)
internal bool get_IsArray()
private void set_IsArray(bool value)
internal bool get_ShouldCreateWrapper()
private void set_ShouldCreateWrapper(bool value)
internal bool get_CanDeserialize()
private void set_CanDeserialize(bool value)
internal ObjectConstructor`1<object> get_ParameterizedCreator()
public ObjectConstructor`1<object> get_OverrideCreator()
public void set_OverrideCreator(ObjectConstructor`1<object> value)
public bool get_HasParameterizedCreator()
public void set_HasParameterizedCreator(bool value)
internal bool get_HasParameterizedCreatorInternal()
public void .ctor(Type underlyingType)
internal IWrappedCollection CreateWrapper(object list)
internal IList CreateTemporaryCollection()
}
public Newtonsoft.Json.Serialization.JsonContainerContract : JsonContract {
private JsonContract _itemContract
private JsonContract _finalItemContract
private JsonConverter <ItemConverter>k__BackingField
private Nullable`1<bool> <ItemIsReference>k__BackingField
private Nullable`1<ReferenceLoopHandling> <ItemReferenceLoopHandling>k__BackingField
private Nullable`1<TypeNameHandling> <ItemTypeNameHandling>k__BackingField
internal JsonContract ItemContract
internal JsonContract FinalItemContract
public JsonConverter ItemConverter
public Nullable`1<bool> ItemIsReference
public Nullable`1<ReferenceLoopHandling> ItemReferenceLoopHandling
public Nullable`1<TypeNameHandling> ItemTypeNameHandling
internal JsonContract get_ItemContract()
internal void set_ItemContract(JsonContract value)
internal JsonContract get_FinalItemContract()
public JsonConverter get_ItemConverter()
public void set_ItemConverter(JsonConverter value)
public Nullable`1<bool> get_ItemIsReference()
public void set_ItemIsReference(Nullable`1<bool> value)
public Nullable`1<ReferenceLoopHandling> get_ItemReferenceLoopHandling()
public void set_ItemReferenceLoopHandling(Nullable`1<ReferenceLoopHandling> value)
public Nullable`1<TypeNameHandling> get_ItemTypeNameHandling()
public void set_ItemTypeNameHandling(Nullable`1<TypeNameHandling> value)
internal void .ctor(Type underlyingType)
}
public Newtonsoft.Json.Serialization.JsonContract : object {
internal bool IsNullable
internal bool IsConvertable
internal bool IsEnum
internal Type NonNullableUnderlyingType
internal ReadType InternalReadType
internal JsonContractType ContractType
internal bool IsReadOnlyOrFixedSize
internal bool IsSealed
internal bool IsInstantiable
private List`1<SerializationCallback> _onDeserializedCallbacks
private IList`1<SerializationCallback> _onDeserializingCallbacks
private IList`1<SerializationCallback> _onSerializedCallbacks
private IList`1<SerializationCallback> _onSerializingCallbacks
private IList`1<SerializationErrorCallback> _onErrorCallbacks
private Type _createdType
private Type <UnderlyingType>k__BackingField
private Nullable`1<bool> <IsReference>k__BackingField
private JsonConverter <Converter>k__BackingField
private JsonConverter <InternalConverter>k__BackingField
private Func`1<object> <DefaultCreator>k__BackingField
private bool <DefaultCreatorNonPublic>k__BackingField
public Type UnderlyingType
public Type CreatedType
public Nullable`1<bool> IsReference
public JsonConverter Converter
internal JsonConverter InternalConverter
public IList`1<SerializationCallback> OnDeserializedCallbacks
public IList`1<SerializationCallback> OnDeserializingCallbacks
public IList`1<SerializationCallback> OnSerializedCallbacks
public IList`1<SerializationCallback> OnSerializingCallbacks
public IList`1<SerializationErrorCallback> OnErrorCallbacks
public MethodInfo OnDeserialized
public MethodInfo OnDeserializing
public MethodInfo OnSerialized
public MethodInfo OnSerializing
public MethodInfo OnError
public Func`1<object> DefaultCreator
public bool DefaultCreatorNonPublic
public Type get_UnderlyingType()
private void set_UnderlyingType(Type value)
public Type get_CreatedType()
public void set_CreatedType(Type value)
public Nullable`1<bool> get_IsReference()
public void set_IsReference(Nullable`1<bool> value)
public JsonConverter get_Converter()
public void set_Converter(JsonConverter value)
internal JsonConverter get_InternalConverter()
internal void set_InternalConverter(JsonConverter value)
public IList`1<SerializationCallback> get_OnDeserializedCallbacks()
public IList`1<SerializationCallback> get_OnDeserializingCallbacks()
public IList`1<SerializationCallback> get_OnSerializedCallbacks()
public IList`1<SerializationCallback> get_OnSerializingCallbacks()
public IList`1<SerializationErrorCallback> get_OnErrorCallbacks()
public MethodInfo get_OnDeserialized()
public void set_OnDeserialized(MethodInfo value)
public MethodInfo get_OnDeserializing()
public void set_OnDeserializing(MethodInfo value)
public MethodInfo get_OnSerialized()
public void set_OnSerialized(MethodInfo value)
public MethodInfo get_OnSerializing()
public void set_OnSerializing(MethodInfo value)
public MethodInfo get_OnError()
public void set_OnError(MethodInfo value)
public Func`1<object> get_DefaultCreator()
public void set_DefaultCreator(Func`1<object> value)
public bool get_DefaultCreatorNonPublic()
public void set_DefaultCreatorNonPublic(bool value)
internal void .ctor(Type underlyingType)
internal void InvokeOnSerializing(object o, StreamingContext context)
internal void InvokeOnSerialized(object o, StreamingContext context)
internal void InvokeOnDeserializing(object o, StreamingContext context)
internal void InvokeOnDeserialized(object o, StreamingContext context)
internal void InvokeOnError(object o, StreamingContext context, ErrorContext errorContext)
internal SerializationCallback CreateSerializationCallback(MethodInfo callbackMethodInfo)
internal SerializationErrorCallback CreateSerializationErrorCallback(MethodInfo callbackMethodInfo)
}
internal Newtonsoft.Json.Serialization.JsonContractType : Enum {
public int value__
public JsonContractType None
public JsonContractType Object
public JsonContractType Array
public JsonContractType Primitive
public JsonContractType String
public JsonContractType Dictionary
public JsonContractType Dynamic
public JsonContractType Serializable
public JsonContractType Linq
}
public Newtonsoft.Json.Serialization.JsonDictionaryContract : JsonContainerContract {
private Func`2<string, string> <DictionaryKeyResolver>k__BackingField
private Type <DictionaryKeyType>k__BackingField
private Type <DictionaryValueType>k__BackingField
private JsonContract <KeyContract>k__BackingField
private Type _genericCollectionDefinitionType
private Type _genericWrapperType
private ObjectConstructor`1<object> _genericWrapperCreator
private Func`1<object> _genericTemporaryDictionaryCreator
private bool <ShouldCreateWrapper>k__BackingField
private ConstructorInfo _parameterizedConstructor
private ObjectConstructor`1<object> _overrideCreator
private ObjectConstructor`1<object> _parameterizedCreator
private bool <HasParameterizedCreator>k__BackingField
public Func`2<string, string> PropertyNameResolver
public Func`2<string, string> DictionaryKeyResolver
public Type DictionaryKeyType
public Type DictionaryValueType
internal JsonContract KeyContract
internal bool ShouldCreateWrapper
internal ObjectConstructor`1<object> ParameterizedCreator
public ObjectConstructor`1<object> OverrideCreator
public bool HasParameterizedCreator
internal bool HasParameterizedCreatorInternal
public Func`2<string, string> get_PropertyNameResolver()
public void set_PropertyNameResolver(Func`2<string, string> value)
public Func`2<string, string> get_DictionaryKeyResolver()
public void set_DictionaryKeyResolver(Func`2<string, string> value)
public Type get_DictionaryKeyType()
private void set_DictionaryKeyType(Type value)
public Type get_DictionaryValueType()
private void set_DictionaryValueType(Type value)
internal JsonContract get_KeyContract()
internal void set_KeyContract(JsonContract value)
internal bool get_ShouldCreateWrapper()
private void set_ShouldCreateWrapper(bool value)
internal ObjectConstructor`1<object> get_ParameterizedCreator()
public ObjectConstructor`1<object> get_OverrideCreator()
public void set_OverrideCreator(ObjectConstructor`1<object> value)
public bool get_HasParameterizedCreator()
public void set_HasParameterizedCreator(bool value)
internal bool get_HasParameterizedCreatorInternal()
public void .ctor(Type underlyingType)
internal IWrappedDictionary CreateWrapper(object dictionary)
internal IDictionary CreateTemporaryDictionary()
}
internal Newtonsoft.Json.Serialization.JsonFormatterConverter : object {
private JsonSerializerInternalReader _reader
private JsonISerializableContract _contract
private JsonProperty _member
public void .ctor(JsonSerializerInternalReader reader, JsonISerializableContract contract, JsonProperty member)
private T GetTokenValue(object value)
public object Convert(object value, Type type)
public object Convert(object value, TypeCode typeCode)
public bool ToBoolean(object value)
public byte ToByte(object value)
public char ToChar(object value)
public DateTime ToDateTime(object value)
public decimal ToDecimal(object value)
public double ToDouble(object value)
public short ToInt16(object value)
public int ToInt32(object value)
public long ToInt64(object value)
public sbyte ToSByte(object value)
public float ToSingle(object value)
public string ToString(object value)
public ushort ToUInt16(object value)
public UInt32 ToUInt32(object value)
public ulong ToUInt64(object value)
}
public Newtonsoft.Json.Serialization.JsonISerializableContract : JsonContainerContract {
private ObjectConstructor`1<object> <ISerializableCreator>k__BackingField
public ObjectConstructor`1<object> ISerializableCreator
public ObjectConstructor`1<object> get_ISerializableCreator()
public void set_ISerializableCreator(ObjectConstructor`1<object> value)
public void .ctor(Type underlyingType)
}
public Newtonsoft.Json.Serialization.JsonLinqContract : JsonContract {
public void .ctor(Type underlyingType)
}
public Newtonsoft.Json.Serialization.JsonObjectContract : JsonContainerContract {
private MemberSerialization <MemberSerialization>k__BackingField
private Nullable`1<Required> <ItemRequired>k__BackingField
private JsonPropertyCollection <Properties>k__BackingField
private ExtensionDataSetter <ExtensionDataSetter>k__BackingField
private ExtensionDataGetter <ExtensionDataGetter>k__BackingField
internal bool ExtensionDataIsJToken
private Nullable`1<bool> _hasRequiredOrDefaultValueProperties
private ConstructorInfo _parametrizedConstructor
private ConstructorInfo _overrideConstructor
private ObjectConstructor`1<object> _overrideCreator
private ObjectConstructor`1<object> _parameterizedCreator
private JsonPropertyCollection _creatorParameters
private Type _extensionDataValueType
public MemberSerialization MemberSerialization
public Nullable`1<Required> ItemRequired
public JsonPropertyCollection Properties
public JsonPropertyCollection ConstructorParameters
public JsonPropertyCollection CreatorParameters
public ConstructorInfo OverrideConstructor
public ConstructorInfo ParametrizedConstructor
public ObjectConstructor`1<object> OverrideCreator
internal ObjectConstructor`1<object> ParameterizedCreator
public ExtensionDataSetter ExtensionDataSetter
public ExtensionDataGetter ExtensionDataGetter
public Type ExtensionDataValueType
internal bool HasRequiredOrDefaultValueProperties
public MemberSerialization get_MemberSerialization()
public void set_MemberSerialization(MemberSerialization value)
public Nullable`1<Required> get_ItemRequired()
public void set_ItemRequired(Nullable`1<Required> value)
public JsonPropertyCollection get_Properties()
private void set_Properties(JsonPropertyCollection value)
public JsonPropertyCollection get_ConstructorParameters()
public JsonPropertyCollection get_CreatorParameters()
public ConstructorInfo get_OverrideConstructor()
public void set_OverrideConstructor(ConstructorInfo value)
public ConstructorInfo get_ParametrizedConstructor()
public void set_ParametrizedConstructor(ConstructorInfo value)
public ObjectConstructor`1<object> get_OverrideCreator()
public void set_OverrideCreator(ObjectConstructor`1<object> value)
internal ObjectConstructor`1<object> get_ParameterizedCreator()
public ExtensionDataSetter get_ExtensionDataSetter()
public void set_ExtensionDataSetter(ExtensionDataSetter value)
public ExtensionDataGetter get_ExtensionDataGetter()
public void set_ExtensionDataGetter(ExtensionDataGetter value)
public Type get_ExtensionDataValueType()
public void set_ExtensionDataValueType(Type value)
internal bool get_HasRequiredOrDefaultValueProperties()
public void .ctor(Type underlyingType)
internal object GetUninitializedObject()
}
public Newtonsoft.Json.Serialization.JsonPrimitiveContract : JsonContract {
private PrimitiveTypeCode <TypeCode>k__BackingField
private Dictionary`2<Type, ReadType> ReadTypeMap
internal PrimitiveTypeCode TypeCode
internal PrimitiveTypeCode get_TypeCode()
internal void set_TypeCode(PrimitiveTypeCode value)
public void .ctor(Type underlyingType)
}
public Newtonsoft.Json.Serialization.JsonProperty : object {
internal Nullable`1<Required> _required
internal bool _hasExplicitDefaultValue
private object _defaultValue
private bool _hasGeneratedDefaultValue
private string _propertyName
internal bool _skipPropertyNameEscape
private Type _propertyType
private JsonContract <PropertyContract>k__BackingField
private Type <DeclaringType>k__BackingField
private Nullable`1<int> <Order>k__BackingField
private string <UnderlyingName>k__BackingField
private IValueProvider <ValueProvider>k__BackingField
private IAttributeProvider <AttributeProvider>k__BackingField
private JsonConverter <Converter>k__BackingField
private JsonConverter <MemberConverter>k__BackingField
private bool <Ignored>k__BackingField
private bool <Readable>k__BackingField
private bool <Writable>k__BackingField
private bool <HasMemberAttribute>k__BackingField
private Nullable`1<bool> <IsReference>k__BackingField
private Nullable`1<NullValueHandling> <NullValueHandling>k__BackingField
private Nullable`1<DefaultValueHandling> <DefaultValueHandling>k__BackingField
private Nullable`1<ReferenceLoopHandling> <ReferenceLoopHandling>k__BackingField
private Nullable`1<ObjectCreationHandling> <ObjectCreationHandling>k__BackingField
private Nullable`1<TypeNameHandling> <TypeNameHandling>k__BackingField
private Predicate`1<object> <ShouldSerialize>k__BackingField
private Predicate`1<object> <ShouldDeserialize>k__BackingField
private Predicate`1<object> <GetIsSpecified>k__BackingField
private Action`2<object, object> <SetIsSpecified>k__BackingField
private JsonConverter <ItemConverter>k__BackingField
private Nullable`1<bool> <ItemIsReference>k__BackingField
private Nullable`1<TypeNameHandling> <ItemTypeNameHandling>k__BackingField
private Nullable`1<ReferenceLoopHandling> <ItemReferenceLoopHandling>k__BackingField
internal JsonContract PropertyContract
public string PropertyName
public Type DeclaringType
public Nullable`1<int> Order
public string UnderlyingName
public IValueProvider ValueProvider
public IAttributeProvider AttributeProvider
public Type PropertyType
public JsonConverter Converter
public JsonConverter MemberConverter
public bool Ignored
public bool Readable
public bool Writable
public bool HasMemberAttribute
public object DefaultValue
public Required Required
public Nullable`1<bool> IsReference
public Nullable`1<NullValueHandling> NullValueHandling
public Nullable`1<DefaultValueHandling> DefaultValueHandling
public Nullable`1<ReferenceLoopHandling> ReferenceLoopHandling
public Nullable`1<ObjectCreationHandling> ObjectCreationHandling
public Nullable`1<TypeNameHandling> TypeNameHandling
public Predicate`1<object> ShouldSerialize
public Predicate`1<object> ShouldDeserialize
public Predicate`1<object> GetIsSpecified
public Action`2<object, object> SetIsSpecified
public JsonConverter ItemConverter
public Nullable`1<bool> ItemIsReference
public Nullable`1<TypeNameHandling> ItemTypeNameHandling
public Nullable`1<ReferenceLoopHandling> ItemReferenceLoopHandling
internal JsonContract get_PropertyContract()
internal void set_PropertyContract(JsonContract value)
public string get_PropertyName()
public void set_PropertyName(string value)
public Type get_DeclaringType()
public void set_DeclaringType(Type value)
public Nullable`1<int> get_Order()
public void set_Order(Nullable`1<int> value)
public string get_UnderlyingName()
public void set_UnderlyingName(string value)
public IValueProvider get_ValueProvider()
public void set_ValueProvider(IValueProvider value)
public IAttributeProvider get_AttributeProvider()
public void set_AttributeProvider(IAttributeProvider value)
public Type get_PropertyType()
public void set_PropertyType(Type value)
public JsonConverter get_Converter()
public void set_Converter(JsonConverter value)
public JsonConverter get_MemberConverter()
public void set_MemberConverter(JsonConverter value)
public bool get_Ignored()
public void set_Ignored(bool value)
public bool get_Readable()
public void set_Readable(bool value)
public bool get_Writable()
public void set_Writable(bool value)
public bool get_HasMemberAttribute()
public void set_HasMemberAttribute(bool value)
public object get_DefaultValue()
public void set_DefaultValue(object value)
internal object GetResolvedDefaultValue()
public Required get_Required()
public void set_Required(Required value)
public Nullable`1<bool> get_IsReference()
public void set_IsReference(Nullable`1<bool> value)
public Nullable`1<NullValueHandling> get_NullValueHandling()
public void set_NullValueHandling(Nullable`1<NullValueHandling> value)
public Nullable`1<DefaultValueHandling> get_DefaultValueHandling()
public void set_DefaultValueHandling(Nullable`1<DefaultValueHandling> value)
public Nullable`1<ReferenceLoopHandling> get_ReferenceLoopHandling()
public void set_ReferenceLoopHandling(Nullable`1<ReferenceLoopHandling> value)
public Nullable`1<ObjectCreationHandling> get_ObjectCreationHandling()
public void set_ObjectCreationHandling(Nullable`1<ObjectCreationHandling> value)
public Nullable`1<TypeNameHandling> get_TypeNameHandling()
public void set_TypeNameHandling(Nullable`1<TypeNameHandling> value)
public Predicate`1<object> get_ShouldSerialize()
public void set_ShouldSerialize(Predicate`1<object> value)
public Predicate`1<object> get_ShouldDeserialize()
public void set_ShouldDeserialize(Predicate`1<object> value)
public Predicate`1<object> get_GetIsSpecified()
public void set_GetIsSpecified(Predicate`1<object> value)
public Action`2<object, object> get_SetIsSpecified()
public void set_SetIsSpecified(Action`2<object, object> value)
public string ToString()
public JsonConverter get_ItemConverter()
public void set_ItemConverter(JsonConverter value)
public Nullable`1<bool> get_ItemIsReference()
public void set_ItemIsReference(Nullable`1<bool> value)
public Nullable`1<TypeNameHandling> get_ItemTypeNameHandling()
public void set_ItemTypeNameHandling(Nullable`1<TypeNameHandling> value)
public Nullable`1<ReferenceLoopHandling> get_ItemReferenceLoopHandling()
public void set_ItemReferenceLoopHandling(Nullable`1<ReferenceLoopHandling> value)
internal void WritePropertyName(JsonWriter writer)
}
public Newtonsoft.Json.Serialization.JsonPropertyCollection : KeyedCollection`2<string, JsonProperty> {
private Type _type
private List`1<JsonProperty> _list
public void .ctor(Type type)
protected string GetKeyForItem(JsonProperty item)
public void AddProperty(JsonProperty property)
public JsonProperty GetClosestMatchProperty(string propertyName)
private bool TryGetValue(string key, JsonProperty& item)
public JsonProperty GetProperty(string propertyName, StringComparison comparisonType)
}
internal Newtonsoft.Json.Serialization.JsonSerializerInternalBase : object {
private ErrorContext _currentErrorContext
private BidirectionalDictionary`2<string, object> _mappings
internal JsonSerializer Serializer
internal ITraceWriter TraceWriter
protected JsonSerializerProxy InternalSerializer
internal BidirectionalDictionary`2<string, object> DefaultReferenceMappings
protected void .ctor(JsonSerializer serializer)
internal BidirectionalDictionary`2<string, object> get_DefaultReferenceMappings()
private ErrorContext GetErrorContext(object currentObject, object member, string path, Exception error)
protected void ClearErrorContext()
protected bool IsErrorHandled(object currentObject, JsonContract contract, object keyValue, IJsonLineInfo lineInfo, string path, Exception ex)
}
internal Newtonsoft.Json.Serialization.JsonSerializerInternalReader : JsonSerializerInternalBase {
public void .ctor(JsonSerializer serializer)
public void Populate(JsonReader reader, object target)
private JsonContract GetContractSafe(Type type)
public object Deserialize(JsonReader reader, Type objectType, bool checkAdditionalContent)
private JsonSerializerProxy GetInternalSerializer()
private JToken CreateJToken(JsonReader reader, JsonContract contract)
private JToken CreateJObject(JsonReader reader)
private object CreateValueInternal(JsonReader reader, Type objectType, JsonContract contract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerMember, object existingValue)
private bool CoerceEmptyStringToNull(Type objectType, JsonContract contract, string s)
internal string GetExpectedDescription(JsonContract contract)
private JsonConverter GetConverter(JsonContract contract, JsonConverter memberConverter, JsonContainerContract containerContract, JsonProperty containerProperty)
private object CreateObject(JsonReader reader, Type objectType, JsonContract contract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerMember, object existingValue)
private bool ReadMetadataPropertiesToken(JTokenReader reader, Type& objectType, JsonContract& contract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerMember, object existingValue, Object& newValue, String& id)
private bool ReadMetadataProperties(JsonReader reader, Type& objectType, JsonContract& contract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerMember, object existingValue, Object& newValue, String& id)
private void ResolveTypeName(JsonReader reader, Type& objectType, JsonContract& contract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerMember, string qualifiedTypeName)
private JsonArrayContract EnsureArrayContract(JsonReader reader, Type objectType, JsonContract contract)
private object CreateList(JsonReader reader, Type objectType, JsonContract contract, JsonProperty member, object existingValue, string id)
private bool HasNoDefinedType(JsonContract contract)
private object EnsureType(JsonReader reader, object value, CultureInfo culture, JsonContract contract, Type targetType)
private bool SetPropertyValue(JsonProperty property, JsonConverter propertyConverter, JsonContainerContract containerContract, JsonProperty containerProperty, JsonReader reader, object target)
private bool CalculatePropertyDetails(JsonProperty property, JsonConverter& propertyConverter, JsonContainerContract containerContract, JsonProperty containerProperty, JsonReader reader, object target, Boolean& useExistingValue, Object& currentValue, JsonContract& propertyContract, Boolean& gottenCurrentValue)
private void AddReference(JsonReader reader, string id, object value)
private bool HasFlag(DefaultValueHandling value, DefaultValueHandling flag)
private bool ShouldSetPropertyValue(JsonProperty property, object value)
private IList CreateNewList(JsonReader reader, JsonArrayContract contract, Boolean& createdFromNonDefaultCreator)
private IDictionary CreateNewDictionary(JsonReader reader, JsonDictionaryContract contract, Boolean& createdFromNonDefaultCreator)
private void OnDeserializing(JsonReader reader, JsonContract contract, object value)
private void OnDeserialized(JsonReader reader, JsonContract contract, object value)
private object PopulateDictionary(IDictionary dictionary, JsonReader reader, JsonDictionaryContract contract, JsonProperty containerProperty, string id)
private object PopulateMultidimensionalArray(IList list, JsonReader reader, JsonArrayContract contract, JsonProperty containerProperty, string id)
private void ThrowUnexpectedEndException(JsonReader reader, JsonContract contract, object currentObject, string message)
private object PopulateList(IList list, JsonReader reader, JsonArrayContract contract, JsonProperty containerProperty, string id)
private object CreateISerializable(JsonReader reader, JsonISerializableContract contract, JsonProperty member, string id)
internal object CreateISerializableItem(JToken token, Type type, JsonISerializableContract contract, JsonProperty member)
private object CreateObjectUsingCreatorWithParameters(JsonReader reader, JsonObjectContract contract, JsonProperty containerProperty, ObjectConstructor`1<object> creator, string id)
private object DeserializeConvertable(JsonConverter converter, JsonReader reader, Type objectType, object existingValue)
private List`1<CreatorPropertyContext> ResolvePropertyAndCreatorValues(JsonObjectContract contract, JsonProperty containerProperty, JsonReader reader, Type objectType)
private bool ReadForType(JsonReader reader, JsonContract contract, bool hasConverter)
public object CreateNewObject(JsonReader reader, JsonObjectContract objectContract, JsonProperty containerMember, JsonProperty containerProperty, string id, Boolean& createdFromNonDefaultCreator)
private object PopulateObject(object newObject, JsonReader reader, JsonObjectContract contract, JsonProperty member, string id)
private bool ShouldDeserialize(JsonReader reader, JsonProperty property, object target)
private bool CheckPropertyName(JsonReader reader, string memberName)
private void SetExtensionData(JsonObjectContract contract, JsonProperty member, JsonReader reader, string memberName, object o)
private object ReadExtensionDataValue(JsonObjectContract contract, JsonProperty member, JsonReader reader)
private void EndProcessProperty(object newObject, JsonReader reader, JsonObjectContract contract, int initialDepth, JsonProperty property, PropertyPresence presence, bool setDefaultValue)
private void SetPropertyPresence(JsonReader reader, JsonProperty property, Dictionary`2<JsonProperty, PropertyPresence> requiredProperties)
private void HandleError(JsonReader reader, bool readPastError, int initialDepth)
}
internal Newtonsoft.Json.Serialization.JsonSerializerInternalWriter : JsonSerializerInternalBase {
private Type _rootType
private int _rootLevel
private List`1<object> _serializeStack
public void .ctor(JsonSerializer serializer)
public void Serialize(JsonWriter jsonWriter, object value, Type objectType)
private JsonSerializerProxy GetInternalSerializer()
private JsonContract GetContractSafe(object value)
private void SerializePrimitive(JsonWriter writer, object value, JsonPrimitiveContract contract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerProperty)
private void SerializeValue(JsonWriter writer, object value, JsonContract valueContract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerProperty)
private Nullable`1<bool> ResolveIsReference(JsonContract contract, JsonProperty property, JsonContainerContract collectionContract, JsonProperty containerProperty)
private bool ShouldWriteReference(object value, JsonProperty property, JsonContract valueContract, JsonContainerContract collectionContract, JsonProperty containerProperty)
private bool ShouldWriteProperty(object memberValue, JsonProperty property)
private bool CheckForCircularReference(JsonWriter writer, object value, JsonProperty property, JsonContract contract, JsonContainerContract containerContract, JsonProperty containerProperty)
private void WriteReference(JsonWriter writer, object value)
private string GetReference(JsonWriter writer, object value)
internal bool TryConvertToString(object value, Type type, String& s)
private void SerializeString(JsonWriter writer, object value, JsonStringContract contract)
private void OnSerializing(JsonWriter writer, JsonContract contract, object value)
private void OnSerialized(JsonWriter writer, JsonContract contract, object value)
private void SerializeObject(JsonWriter writer, object value, JsonObjectContract contract, JsonProperty member, JsonContainerContract collectionContract, JsonProperty containerProperty)
private bool CalculatePropertyValues(JsonWriter writer, object value, JsonContainerContract contract, JsonProperty member, JsonProperty property, JsonContract& memberContract, Object& memberValue)
private void WriteObjectStart(JsonWriter writer, object value, JsonContract contract, JsonProperty member, JsonContainerContract collectionContract, JsonProperty containerProperty)
private void WriteReferenceIdProperty(JsonWriter writer, Type type, object value)
private void WriteTypeProperty(JsonWriter writer, Type type)
private bool HasFlag(DefaultValueHandling value, DefaultValueHandling flag)
private bool HasFlag(PreserveReferencesHandling value, PreserveReferencesHandling flag)
private bool HasFlag(TypeNameHandling value, TypeNameHandling flag)
private void SerializeConvertable(JsonWriter writer, JsonConverter converter, object value, JsonContract contract, JsonContainerContract collectionContract, JsonProperty containerProperty)
private void SerializeList(JsonWriter writer, IEnumerable values, JsonArrayContract contract, JsonProperty member, JsonContainerContract collectionContract, JsonProperty containerProperty)
private void SerializeMultidimensionalArray(JsonWriter writer, Array values, JsonArrayContract contract, JsonProperty member, JsonContainerContract collectionContract, JsonProperty containerProperty)
private void SerializeMultidimensionalArray(JsonWriter writer, Array values, JsonArrayContract contract, JsonProperty member, int initialDepth, Int32[] indices)
private bool WriteStartArray(JsonWriter writer, object values, JsonArrayContract contract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerProperty)
private void SerializeISerializable(JsonWriter writer, ISerializable value, JsonISerializableContract contract, JsonProperty member, JsonContainerContract collectionContract, JsonProperty containerProperty)
private bool ShouldWriteDynamicProperty(object memberValue)
private bool ShouldWriteType(TypeNameHandling typeNameHandlingFlag, JsonContract contract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerProperty)
private void SerializeDictionary(JsonWriter writer, IDictionary values, JsonDictionaryContract contract, JsonProperty member, JsonContainerContract collectionContract, JsonProperty containerProperty)
private string GetPropertyName(JsonWriter writer, object name, JsonContract contract, Boolean& escape)
private void HandleError(JsonWriter writer, int initialDepth)
private bool ShouldSerialize(JsonWriter writer, JsonProperty property, object target)
private bool IsSpecified(JsonWriter writer, JsonProperty property, object target)
}
internal Newtonsoft.Json.Serialization.JsonSerializerProxy : JsonSerializer {
private JsonSerializerInternalReader _serializerReader
private JsonSerializerInternalWriter _serializerWriter
private JsonSerializer _serializer
public IReferenceResolver ReferenceResolver
public ITraceWriter TraceWriter
public IEqualityComparer EqualityComparer
public JsonConverterCollection Converters
public DefaultValueHandling DefaultValueHandling
public IContractResolver ContractResolver
public MissingMemberHandling MissingMemberHandling
public NullValueHandling NullValueHandling
public ObjectCreationHandling ObjectCreationHandling
public ReferenceLoopHandling ReferenceLoopHandling
public PreserveReferencesHandling PreserveReferencesHandling
public TypeNameHandling TypeNameHandling
public MetadataPropertyHandling MetadataPropertyHandling
public FormatterAssemblyStyle TypeNameAssemblyFormat
public ConstructorHandling ConstructorHandling
public SerializationBinder Binder
public StreamingContext Context
public Formatting Formatting
public DateFormatHandling DateFormatHandling
public DateTimeZoneHandling DateTimeZoneHandling
public DateParseHandling DateParseHandling
public FloatFormatHandling FloatFormatHandling
public FloatParseHandling FloatParseHandling
public StringEscapeHandling StringEscapeHandling
public string DateFormatString
public CultureInfo Culture
public Nullable`1<int> MaxDepth
public bool CheckAdditionalContent
public void add_Error(EventHandler`1<ErrorEventArgs> value)
public void remove_Error(EventHandler`1<ErrorEventArgs> value)
public IReferenceResolver get_ReferenceResolver()
public void set_ReferenceResolver(IReferenceResolver value)
public ITraceWriter get_TraceWriter()
public void set_TraceWriter(ITraceWriter value)
public IEqualityComparer get_EqualityComparer()
public void set_EqualityComparer(IEqualityComparer value)
public JsonConverterCollection get_Converters()
public DefaultValueHandling get_DefaultValueHandling()
public void set_DefaultValueHandling(DefaultValueHandling value)
public IContractResolver get_ContractResolver()
public void set_ContractResolver(IContractResolver value)
public MissingMemberHandling get_MissingMemberHandling()
public void set_MissingMemberHandling(MissingMemberHandling value)
public NullValueHandling get_NullValueHandling()
public void set_NullValueHandling(NullValueHandling value)
public ObjectCreationHandling get_ObjectCreationHandling()
public void set_ObjectCreationHandling(ObjectCreationHandling value)
public ReferenceLoopHandling get_ReferenceLoopHandling()
public void set_ReferenceLoopHandling(ReferenceLoopHandling value)
public PreserveReferencesHandling get_PreserveReferencesHandling()
public void set_PreserveReferencesHandling(PreserveReferencesHandling value)
public TypeNameHandling get_TypeNameHandling()
public void set_TypeNameHandling(TypeNameHandling value)
public MetadataPropertyHandling get_MetadataPropertyHandling()
public void set_MetadataPropertyHandling(MetadataPropertyHandling value)
public FormatterAssemblyStyle get_TypeNameAssemblyFormat()
public void set_TypeNameAssemblyFormat(FormatterAssemblyStyle value)
public ConstructorHandling get_ConstructorHandling()
public void set_ConstructorHandling(ConstructorHandling value)
public SerializationBinder get_Binder()
public void set_Binder(SerializationBinder value)
public StreamingContext get_Context()
public void set_Context(StreamingContext value)
public Formatting get_Formatting()
public void set_Formatting(Formatting value)
public DateFormatHandling get_DateFormatHandling()
public void set_DateFormatHandling(DateFormatHandling value)
public DateTimeZoneHandling get_DateTimeZoneHandling()
public void set_DateTimeZoneHandling(DateTimeZoneHandling value)
public DateParseHandling get_DateParseHandling()
public void set_DateParseHandling(DateParseHandling value)
public FloatFormatHandling get_FloatFormatHandling()
public void set_FloatFormatHandling(FloatFormatHandling value)
public FloatParseHandling get_FloatParseHandling()
public void set_FloatParseHandling(FloatParseHandling value)
public StringEscapeHandling get_StringEscapeHandling()
public void set_StringEscapeHandling(StringEscapeHandling value)
public string get_DateFormatString()
public void set_DateFormatString(string value)
public CultureInfo get_Culture()
public void set_Culture(CultureInfo value)
public Nullable`1<int> get_MaxDepth()
public void set_MaxDepth(Nullable`1<int> value)
public bool get_CheckAdditionalContent()
public void set_CheckAdditionalContent(bool value)
internal JsonSerializerInternalBase GetInternalSerializer()
public void .ctor(JsonSerializerInternalReader serializerReader)
public void .ctor(JsonSerializerInternalWriter serializerWriter)
internal object DeserializeInternal(JsonReader reader, Type objectType)
internal void PopulateInternal(JsonReader reader, object target)
internal void SerializeInternal(JsonWriter jsonWriter, object value, Type rootType)
}
public Newtonsoft.Json.Serialization.JsonStringContract : JsonPrimitiveContract {
public void .ctor(Type underlyingType)
}
internal Newtonsoft.Json.Serialization.JsonTypeReflector : object {
private Nullable`1<bool> _dynamicCodeGeneration
private Nullable`1<bool> _fullyTrusted
public string IdPropertyName
public string RefPropertyName
public string TypePropertyName
public string ValuePropertyName
public string ArrayValuesPropertyName
public string ShouldSerializePrefix
public string SpecifiedPostfix
private ThreadSafeStore`2<Type, Func`2<Object[], JsonConverter>> JsonConverterCreatorCache
private ThreadSafeStore`2<Type, Type> AssociatedMetadataTypesCache
private ReflectionObject _metadataTypeAttributeReflectionObject
public bool DynamicCodeGeneration
public bool FullyTrusted
public ReflectionDelegateFactory ReflectionDelegateFactory
public T GetCachedAttribute(object attributeProvider)
public DataContractAttribute GetDataContractAttribute(Type type)
public DataMemberAttribute GetDataMemberAttribute(MemberInfo memberInfo)
public MemberSerialization GetObjectMemberSerialization(Type objectType, bool ignoreSerializableAttribute)
public JsonConverter GetJsonConverter(object attributeProvider)
public JsonConverter CreateJsonConverterInstance(Type converterType, Object[] converterArgs)
private Func`2<Object[], JsonConverter> GetJsonConverterCreator(Type converterType)
public TypeConverter GetTypeConverter(Type type)
private Type GetAssociatedMetadataType(Type type)
private Type GetAssociateMetadataTypeFromAttribute(Type type)
private T GetAttribute(Type type)
private T GetAttribute(MemberInfo memberInfo)
public T GetAttribute(object provider)
public bool get_DynamicCodeGeneration()
public bool get_FullyTrusted()
public ReflectionDelegateFactory get_ReflectionDelegateFactory()
}
public Newtonsoft.Json.Serialization.MemoryTraceWriter : object {
private Queue`1<string> _traceMessages
private TraceLevel <LevelFilter>k__BackingField
public TraceLevel LevelFilter
public TraceLevel get_LevelFilter()
public void set_LevelFilter(TraceLevel value)
public void Trace(TraceLevel level, string message, Exception ex)
public IEnumerable`1<string> GetTraceMessages()
public string ToString()
}
public Newtonsoft.Json.Serialization.ObjectConstructor`1 : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public object Invoke(Object[] args)
public IAsyncResult BeginInvoke(Object[] args, AsyncCallback callback, object object)
public object EndInvoke(IAsyncResult result)
}
public Newtonsoft.Json.Serialization.ReflectionAttributeProvider : object {
private object _attributeProvider
public void .ctor(object attributeProvider)
public IList`1<Attribute> GetAttributes(bool inherit)
public IList`1<Attribute> GetAttributes(Type attributeType, bool inherit)
}
public Newtonsoft.Json.Serialization.ReflectionValueProvider : object {
private MemberInfo _memberInfo
public void .ctor(MemberInfo memberInfo)
public void SetValue(object target, object value)
public object GetValue(object target)
}
internal Newtonsoft.Json.Serialization.ResolverContractKey : ValueType {
private Type _resolverType
private Type _contractType
public void .ctor(Type resolverType, Type contractType)
public int GetHashCode()
public bool Equals(object obj)
public bool Equals(ResolverContractKey other)
}
public Newtonsoft.Json.Serialization.SerializationCallback : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object o, StreamingContext context)
public IAsyncResult BeginInvoke(object o, StreamingContext context, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public Newtonsoft.Json.Serialization.SerializationErrorCallback : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object o, StreamingContext context, ErrorContext errorContext)
public IAsyncResult BeginInvoke(object o, StreamingContext context, ErrorContext errorContext, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
internal Newtonsoft.Json.Serialization.TraceJsonReader : JsonReader {
private JsonReader _innerReader
private JsonTextWriter _textWriter
private StringWriter _sw
public int Depth
public string Path
public char QuoteChar
public JsonToken TokenType
public object Value
public Type ValueType
private int Newtonsoft.Json.IJsonLineInfo.LineNumber
private int Newtonsoft.Json.IJsonLineInfo.LinePosition
public void .ctor(JsonReader innerReader)
public string GetDeserializedJsonMessage()
public bool Read()
public Nullable`1<int> ReadAsInt32()
public string ReadAsString()
public Byte[] ReadAsBytes()
public Nullable`1<decimal> ReadAsDecimal()
public Nullable`1<double> ReadAsDouble()
public Nullable`1<bool> ReadAsBoolean()
public Nullable`1<DateTime> ReadAsDateTime()
public Nullable`1<DateTimeOffset> ReadAsDateTimeOffset()
public int get_Depth()
public string get_Path()
public char get_QuoteChar()
protected internal void set_QuoteChar(char value)
public JsonToken get_TokenType()
public object get_Value()
public Type get_ValueType()
public void Close()
private bool Newtonsoft.Json.IJsonLineInfo.HasLineInfo()
private int Newtonsoft.Json.IJsonLineInfo.get_LineNumber()
private int Newtonsoft.Json.IJsonLineInfo.get_LinePosition()
}
internal Newtonsoft.Json.Serialization.TraceJsonWriter : JsonWriter {
private JsonWriter _innerWriter
private JsonTextWriter _textWriter
private StringWriter _sw
public void .ctor(JsonWriter innerWriter)
public string GetSerializedJsonMessage()
public void WriteValue(decimal value)
public void WriteValue(bool value)
public void WriteValue(byte value)
public void WriteValue(Nullable`1<byte> value)
public void WriteValue(char value)
public void WriteValue(Byte[] value)
public void WriteValue(DateTime value)
public void WriteValue(DateTimeOffset value)
public void WriteValue(double value)
public void WriteUndefined()
public void WriteNull()
public void WriteValue(float value)
public void WriteValue(Guid value)
public void WriteValue(int value)
public void WriteValue(long value)
public void WriteValue(object value)
public void WriteValue(sbyte value)
public void WriteValue(short value)
public void WriteValue(string value)
public void WriteValue(TimeSpan value)
public void WriteValue(UInt32 value)
public void WriteValue(ulong value)
public void WriteValue(Uri value)
public void WriteValue(ushort value)
public void WriteWhitespace(string ws)
public void WriteComment(string text)
public void WriteStartArray()
public void WriteEndArray()
public void WriteStartConstructor(string name)
public void WriteEndConstructor()
public void WritePropertyName(string name)
public void WritePropertyName(string name, bool escape)
public void WriteStartObject()
public void WriteEndObject()
public void WriteRawValue(string json)
public void WriteRaw(string json)
public void Close()
public void Flush()
}
public Newtonsoft.Json.StringEscapeHandling : Enum {
public int value__
public StringEscapeHandling Default
public StringEscapeHandling EscapeNonAscii
public StringEscapeHandling EscapeHtml
}
public Newtonsoft.Json.TypeNameHandling : Enum {
public int value__
public TypeNameHandling None
public TypeNameHandling Objects
public TypeNameHandling Arrays
public TypeNameHandling All
public TypeNameHandling Auto
}
internal Newtonsoft.Json.Utilities.Base64Encoder : object {
private int Base64LineSize
private int LineSizeInBytes
private Char[] _charsLine
private TextWriter _writer
private Byte[] _leftOverBytes
private int _leftOverBytesCount
public void .ctor(TextWriter writer)
public void Encode(Byte[] buffer, int index, int count)
public void Flush()
private void WriteChars(Char[] chars, int index, int count)
}
internal Newtonsoft.Json.Utilities.BidirectionalDictionary`2 : object {
private IDictionary`2<TFirst, TSecond> _firstToSecond
private IDictionary`2<TSecond, TFirst> _secondToFirst
private string _duplicateFirstErrorMessage
private string _duplicateSecondErrorMessage
public void .ctor(IEqualityComparer`1<TFirst> firstEqualityComparer, IEqualityComparer`1<TSecond> secondEqualityComparer)
public void .ctor(IEqualityComparer`1<TFirst> firstEqualityComparer, IEqualityComparer`1<TSecond> secondEqualityComparer, string duplicateFirstErrorMessage, string duplicateSecondErrorMessage)
public void Set(TFirst first, TSecond second)
public bool TryGetByFirst(TFirst first, TSecond& second)
public bool TryGetBySecond(TSecond second, TFirst& first)
}
internal Newtonsoft.Json.Utilities.BufferUtils : object {
public Char[] RentBuffer(IArrayPool`1<char> bufferPool, int minSize)
public void ReturnBuffer(IArrayPool`1<char> bufferPool, Char[] buffer)
public Char[] EnsureBufferSize(IArrayPool`1<char> bufferPool, int size, Char[] buffer)
}
internal Newtonsoft.Json.Utilities.CollectionUtils : object {
public bool IsNullOrEmpty(ICollection`1<T> collection)
public void AddRange(IList`1<T> initial, IEnumerable`1<T> collection)
public void AddRange(IList`1<T> initial, IEnumerable collection)
public bool IsDictionaryType(Type type)
public ConstructorInfo ResolveEnumerableCollectionConstructor(Type collectionType, Type collectionItemType)
public bool AddDistinct(IList`1<T> list, T value)
public bool AddDistinct(IList`1<T> list, T value, IEqualityComparer`1<T> comparer)
public bool ContainsValue(IEnumerable`1<TSource> source, TSource value, IEqualityComparer`1<TSource> comparer)
public bool AddRangeDistinct(IList`1<T> list, IEnumerable`1<T> values, IEqualityComparer`1<T> comparer)
public int IndexOf(IEnumerable`1<T> collection, Func`2<T, bool> predicate)
public bool Contains(IEnumerable list, object value, IEqualityComparer comparer)
public int IndexOf(IEnumerable`1<TSource> list, TSource value, IEqualityComparer`1<TSource> comparer)
private IList`1<int> GetDimensions(IList values, int dimensionsCount)
private void CopyFromJaggedToMultidimensionalArray(IList values, Array multidimensionalArray, Int32[] indices)
private object JaggedArrayGetValue(IList values, Int32[] indices)
public Array ToMultidimensionalArray(IList values, Type type, int rank)
}
internal Newtonsoft.Json.Utilities.CollectionWrapper`1 : object {
private IList _list
private ICollection`1<T> _genericCollection
private object _syncRoot
public int Count
public bool IsReadOnly
private bool System.Collections.IList.IsFixedSize
private object System.Collections.IList.Item
private bool System.Collections.ICollection.IsSynchronized
private object System.Collections.ICollection.SyncRoot
public object UnderlyingCollection
public void .ctor(IList list)
public void .ctor(ICollection`1<T> list)
public void Add(T item)
public void Clear()
public bool Contains(T item)
public void CopyTo(T[] array, int arrayIndex)
public int get_Count()
public bool get_IsReadOnly()
public bool Remove(T item)
public IEnumerator`1<T> GetEnumerator()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
private int System.Collections.IList.Add(object value)
private bool System.Collections.IList.Contains(object value)
private int System.Collections.IList.IndexOf(object value)
private void System.Collections.IList.RemoveAt(int index)
private void System.Collections.IList.Insert(int index, object value)
private bool System.Collections.IList.get_IsFixedSize()
private void System.Collections.IList.Remove(object value)
private object System.Collections.IList.get_Item(int index)
private void System.Collections.IList.set_Item(int index, object value)
private void System.Collections.ICollection.CopyTo(Array array, int arrayIndex)
private bool System.Collections.ICollection.get_IsSynchronized()
private object System.Collections.ICollection.get_SyncRoot()
private void VerifyValueType(object value)
private bool IsCompatibleObject(object value)
public object get_UnderlyingCollection()
}
internal Newtonsoft.Json.Utilities.ConvertUtils : object {
private Dictionary`2<Type, PrimitiveTypeCode> TypeCodeMap
private TypeInformation[] PrimitiveTypeCodes
private ThreadSafeStore`2<TypeConvertKey, Func`2<object, object>> CastConverters
public PrimitiveTypeCode GetTypeCode(Type t)
public PrimitiveTypeCode GetTypeCode(Type t, Boolean& isEnum)
public TypeInformation GetTypeInformation(IConvertible convertable)
public bool IsConvertible(Type t)
public TimeSpan ParseTimeSpan(string input)
private Func`2<object, object> CreateCastConverter(TypeConvertKey t)
public object Convert(object initialValue, CultureInfo culture, Type targetType)
private bool TryConvert(object initialValue, CultureInfo culture, Type targetType, Object& value)
private ConvertResult TryConvertInternal(object initialValue, CultureInfo culture, Type targetType, Object& value)
public object ConvertOrCast(object initialValue, CultureInfo culture, Type targetType)
private object EnsureTypeAssignable(object value, Type initialType, Type targetType)
public object ToValue(INullable nullableValue)
internal TypeConverter GetConverter(Type t)
public bool VersionTryParse(string input, Version& result)
public bool IsInteger(object value)
public ParseResult Int32TryParse(Char[] chars, int start, int length, Int32& value)
public ParseResult Int64TryParse(Char[] chars, int start, int length, Int64& value)
public bool TryConvertGuid(string s, Guid& g)
public int HexTextToInt(Char[] text, int start, int end)
private int HexCharToInt(char ch)
}
internal Newtonsoft.Json.Utilities.Creator`1 : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public T Invoke()
public IAsyncResult BeginInvoke(AsyncCallback callback, object object)
public T EndInvoke(IAsyncResult result)
}
internal Newtonsoft.Json.Utilities.DateTimeParser : ValueType {
public int Year
public int Month
public int Day
public int Hour
public int Minute
public int Second
public int Fraction
public int ZoneHour
public int ZoneMinute
public ParserTimeZone Zone
private Char[] _text
private int _end
private Int32[] Power10
private int Lzyyyy
private int Lzyyyy_
private int Lzyyyy_MM
private int Lzyyyy_MM_
private int Lzyyyy_MM_dd
private int Lzyyyy_MM_ddT
private int LzHH
private int LzHH_
private int LzHH_mm
private int LzHH_mm_
private int LzHH_mm_ss
private int Lz_
private int Lz_zz
private short MaxFractionDigits
public bool Parse(Char[] text, int startIndex, int length)
private bool ParseDate(int start)
private bool ParseTimeAndZoneAndWhitespace(int start)
private bool ParseTime(Int32& start)
private bool ParseZone(int start)
private bool Parse4Digit(int start, Int32& num)
private bool Parse2Digit(int start, Int32& num)
private bool ParseChar(int start, char ch)
}
internal Newtonsoft.Json.Utilities.DateTimeUtils : object {
internal long InitialJavaScriptDateTicks
private string IsoDateFormat
private int DaysPer100Years
private int DaysPer400Years
private int DaysPer4Years
private int DaysPerYear
private long TicksPerDay
private Int32[] DaysToMonth365
private Int32[] DaysToMonth366
public TimeSpan GetUtcOffset(DateTime d)
public XmlDateTimeSerializationMode ToSerializationMode(DateTimeKind kind)
internal DateTime EnsureDateTime(DateTime value, DateTimeZoneHandling timeZone)
private DateTime SwitchToLocalTime(DateTime value)
private DateTime SwitchToUtcTime(DateTime value)
private long ToUniversalTicks(DateTime dateTime)
private long ToUniversalTicks(DateTime dateTime, TimeSpan offset)
internal long ConvertDateTimeToJavaScriptTicks(DateTime dateTime, TimeSpan offset)
internal long ConvertDateTimeToJavaScriptTicks(DateTime dateTime)
internal long ConvertDateTimeToJavaScriptTicks(DateTime dateTime, bool convertToUtc)
private long UniversialTicksToJavaScriptTicks(long universialTicks)
internal DateTime ConvertJavaScriptTicksToDateTime(long javaScriptTicks)
internal bool TryParseDateTimeIso(StringReference text, DateTimeZoneHandling dateTimeZoneHandling, DateTime& dt)
internal bool TryParseDateTimeOffsetIso(StringReference text, DateTimeOffset& dt)
private DateTime CreateDateTime(DateTimeParser dateTimeParser)
internal bool TryParseDateTime(StringReference s, DateTimeZoneHandling dateTimeZoneHandling, string dateFormatString, CultureInfo culture, DateTime& dt)
internal bool TryParseDateTime(string s, DateTimeZoneHandling dateTimeZoneHandling, string dateFormatString, CultureInfo culture, DateTime& dt)
internal bool TryParseDateTimeOffset(StringReference s, string dateFormatString, CultureInfo culture, DateTimeOffset& dt)
internal bool TryParseDateTimeOffset(string s, string dateFormatString, CultureInfo culture, DateTimeOffset& dt)
private bool TryParseMicrosoftDate(StringReference text, Int64& ticks, TimeSpan& offset, DateTimeKind& kind)
private bool TryParseDateTimeMicrosoft(StringReference text, DateTimeZoneHandling dateTimeZoneHandling, DateTime& dt)
private bool TryParseDateTimeExact(string text, DateTimeZoneHandling dateTimeZoneHandling, string dateFormatString, CultureInfo culture, DateTime& dt)
private bool TryParseDateTimeOffsetMicrosoft(StringReference text, DateTimeOffset& dt)
private bool TryParseDateTimeOffsetExact(string text, string dateFormatString, CultureInfo culture, DateTimeOffset& dt)
private bool TryReadOffset(StringReference offsetText, int startIndex, TimeSpan& offset)
internal void WriteDateTimeString(TextWriter writer, DateTime value, DateFormatHandling format, string formatString, CultureInfo culture)
internal int WriteDateTimeString(Char[] chars, int start, DateTime value, Nullable`1<TimeSpan> offset, DateTimeKind kind, DateFormatHandling format)
internal int WriteDefaultIsoDate(Char[] chars, int start, DateTime dt)
private void CopyIntToCharArray(Char[] chars, int start, int value, int digits)
internal int WriteDateTimeOffset(Char[] chars, int start, TimeSpan offset, DateFormatHandling format)
internal void WriteDateTimeOffsetString(TextWriter writer, DateTimeOffset value, DateFormatHandling format, string formatString, CultureInfo culture)
private void GetDateValues(DateTime td, Int32& year, Int32& month, Int32& day)
}
internal Newtonsoft.Json.Utilities.DictionaryWrapper`2 : object {
private IDictionary _dictionary
private IDictionary`2<TKey, TValue> _genericDictionary
private object _syncRoot
public ICollection`1<TKey> Keys
public ICollection`1<TValue> Values
public TValue Item
public int Count
public bool IsReadOnly
private object System.Collections.IDictionary.Item
private bool System.Collections.IDictionary.IsFixedSize
private ICollection System.Collections.IDictionary.Keys
private ICollection System.Collections.IDictionary.Values
private bool System.Collections.ICollection.IsSynchronized
private object System.Collections.ICollection.SyncRoot
public object UnderlyingDictionary
public void .ctor(IDictionary dictionary)
public void .ctor(IDictionary`2<TKey, TValue> dictionary)
public void Add(TKey key, TValue value)
public bool ContainsKey(TKey key)
public ICollection`1<TKey> get_Keys()
public bool Remove(TKey key)
public bool TryGetValue(TKey key, TValue& value)
public ICollection`1<TValue> get_Values()
public TValue get_Item(TKey key)
public void set_Item(TKey key, TValue value)
public void Add(KeyValuePair`2<TKey, TValue> item)
public void Clear()
public bool Contains(KeyValuePair`2<TKey, TValue> item)
public void CopyTo(KeyValuePair`2[] array, int arrayIndex)
public int get_Count()
public bool get_IsReadOnly()
public bool Remove(KeyValuePair`2<TKey, TValue> item)
public IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
private void System.Collections.IDictionary.Add(object key, object value)
private object System.Collections.IDictionary.get_Item(object key)
private void System.Collections.IDictionary.set_Item(object key, object value)
private IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator()
private bool System.Collections.IDictionary.Contains(object key)
private bool System.Collections.IDictionary.get_IsFixedSize()
private ICollection System.Collections.IDictionary.get_Keys()
public void Remove(object key)
private ICollection System.Collections.IDictionary.get_Values()
private void System.Collections.ICollection.CopyTo(Array array, int index)
private bool System.Collections.ICollection.get_IsSynchronized()
private object System.Collections.ICollection.get_SyncRoot()
public object get_UnderlyingDictionary()
}
internal Newtonsoft.Json.Utilities.DynamicReflectionDelegateFactory : ReflectionDelegateFactory {
public DynamicReflectionDelegateFactory Instance
private DynamicMethod CreateDynamicMethod(string name, Type returnType, Type[] parameterTypes, Type owner)
public ObjectConstructor`1<object> CreateParameterizedConstructor(MethodBase method)
public MethodCall`2<T, object> CreateMethodCall(MethodBase method)
private void GenerateCreateMethodCallIL(MethodBase method, ILGenerator generator, int argsIndex)
public Func`1<T> CreateDefaultConstructor(Type type)
private void GenerateCreateDefaultConstructorIL(Type type, ILGenerator generator)
public Func`2<T, object> CreateGet(PropertyInfo propertyInfo)
private void GenerateCreateGetPropertyIL(PropertyInfo propertyInfo, ILGenerator generator)
public Func`2<T, object> CreateGet(FieldInfo fieldInfo)
private void GenerateCreateGetFieldIL(FieldInfo fieldInfo, ILGenerator generator)
public Action`2<T, object> CreateSet(FieldInfo fieldInfo)
internal void GenerateCreateSetFieldIL(FieldInfo fieldInfo, ILGenerator generator)
public Action`2<T, object> CreateSet(PropertyInfo propertyInfo)
internal void GenerateCreateSetPropertyIL(PropertyInfo propertyInfo, ILGenerator generator)
}
internal Newtonsoft.Json.Utilities.EnumUtils : object {
private ThreadSafeStore`2<Type, BidirectionalDictionary`2<string, string>> EnumMemberNamesPerType
private BidirectionalDictionary`2<string, string> InitializeEnumType(Type type)
public IList`1<T> GetFlagsValues(T value)
public IList`1<EnumValue`1<ulong>> GetNamesAndValues()
public IList`1<EnumValue`1<TUnderlyingType>> GetNamesAndValues(Type enumType)
public IList`1<object> GetValues(Type enumType)
public IList`1<string> GetNames(Type enumType)
public object ParseEnumName(string enumText, bool isNullable, Type t)
public string ToEnumName(Type enumType, string enumText, bool camelCaseText)
private string ResolvedEnumName(BidirectionalDictionary`2<string, string> map, string enumText)
}
internal Newtonsoft.Json.Utilities.EnumValue`1 : object {
private string _name
private T _value
public string Name
public T Value
public string get_Name()
public T get_Value()
public void .ctor(string name, T value)
}
internal Newtonsoft.Json.Utilities.ILGeneratorExtensions : object {
public void PushInstance(ILGenerator generator, Type type)
public void PushArrayInstance(ILGenerator generator, int argsIndex, int arrayIndex)
public void BoxIfNeeded(ILGenerator generator, Type type)
public void UnboxIfNeeded(ILGenerator generator, Type type)
public void CallMethod(ILGenerator generator, MethodInfo methodInfo)
public void Return(ILGenerator generator)
}
internal Newtonsoft.Json.Utilities.IWrappedCollection {
public object UnderlyingCollection
public object get_UnderlyingCollection()
}
internal Newtonsoft.Json.Utilities.IWrappedDictionary {
public object UnderlyingDictionary
public object get_UnderlyingDictionary()
}
internal Newtonsoft.Json.Utilities.JavaScriptUtils : object {
internal Boolean[] SingleQuoteCharEscapeFlags
internal Boolean[] DoubleQuoteCharEscapeFlags
internal Boolean[] HtmlCharEscapeFlags
private int UnicodeTextLength
private string EscapedUnicodeText
public Boolean[] GetCharEscapeFlags(StringEscapeHandling stringEscapeHandling, char quoteChar)
public bool ShouldEscapeJavaScriptString(string s, Boolean[] charEscapeFlags)
public void WriteEscapedJavaScriptString(TextWriter writer, string s, char delimiter, bool appendDelimiters, Boolean[] charEscapeFlags, StringEscapeHandling stringEscapeHandling, IArrayPool`1<char> bufferPool, Char[]& writeBuffer)
public string ToEscapedJavaScriptString(string value, char delimiter, bool appendDelimiters, StringEscapeHandling stringEscapeHandling)
}
internal Newtonsoft.Json.Utilities.JsonTokenUtils : object {
internal bool IsEndToken(JsonToken token)
internal bool IsStartToken(JsonToken token)
internal bool IsPrimitiveToken(JsonToken token)
}
internal Newtonsoft.Json.Utilities.LateBoundReflectionDelegateFactory : ReflectionDelegateFactory {
private LateBoundReflectionDelegateFactory _instance
internal ReflectionDelegateFactory Instance
internal ReflectionDelegateFactory get_Instance()
public ObjectConstructor`1<object> CreateParameterizedConstructor(MethodBase method)
public MethodCall`2<T, object> CreateMethodCall(MethodBase method)
public Func`1<T> CreateDefaultConstructor(Type type)
public Func`2<T, object> CreateGet(PropertyInfo propertyInfo)
public Func`2<T, object> CreateGet(FieldInfo fieldInfo)
public Action`2<T, object> CreateSet(FieldInfo fieldInfo)
public Action`2<T, object> CreateSet(PropertyInfo propertyInfo)
}
internal Newtonsoft.Json.Utilities.MathUtils : object {
public int IntLength(ulong i)
public char IntToHex(int n)
public Nullable`1<int> Min(Nullable`1<int> val1, Nullable`1<int> val2)
public Nullable`1<int> Max(Nullable`1<int> val1, Nullable`1<int> val2)
public Nullable`1<double> Max(Nullable`1<double> val1, Nullable`1<double> val2)
public bool ApproxEquals(double d1, double d2)
}
internal Newtonsoft.Json.Utilities.MethodCall`2 : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public TResult Invoke(T target, Object[] args)
public IAsyncResult BeginInvoke(T target, Object[] args, AsyncCallback callback, object object)
public TResult EndInvoke(IAsyncResult result)
}
internal Newtonsoft.Json.Utilities.MiscellaneousUtils : object {
public bool ValueEquals(object objA, object objB)
public ArgumentOutOfRangeException CreateArgumentOutOfRangeException(string paramName, object actualValue, string message)
public string ToString(object value)
public int ByteArrayCompare(Byte[] a1, Byte[] a2)
public string GetPrefix(string qualifiedName)
public string GetLocalName(string qualifiedName)
public void GetQualifiedNameParts(string qualifiedName, String& prefix, String& localName)
internal string FormatValueForPrint(object value)
}
internal Newtonsoft.Json.Utilities.ParseResult : Enum {
public int value__
public ParseResult None
public ParseResult Success
public ParseResult Overflow
public ParseResult Invalid
}
internal Newtonsoft.Json.Utilities.ParserTimeZone : Enum {
public int value__
public ParserTimeZone Unspecified
public ParserTimeZone Utc
public ParserTimeZone LocalWestOfUtc
public ParserTimeZone LocalEastOfUtc
}
internal Newtonsoft.Json.Utilities.PrimitiveTypeCode : Enum {
public int value__
public PrimitiveTypeCode Empty
public PrimitiveTypeCode Object
public PrimitiveTypeCode Char
public PrimitiveTypeCode CharNullable
public PrimitiveTypeCode Boolean
public PrimitiveTypeCode BooleanNullable
public PrimitiveTypeCode SByte
public PrimitiveTypeCode SByteNullable
public PrimitiveTypeCode Int16
public PrimitiveTypeCode Int16Nullable
public PrimitiveTypeCode UInt16
public PrimitiveTypeCode UInt16Nullable
public PrimitiveTypeCode Int32
public PrimitiveTypeCode Int32Nullable
public PrimitiveTypeCode Byte
public PrimitiveTypeCode ByteNullable
public PrimitiveTypeCode UInt32
public PrimitiveTypeCode UInt32Nullable
public PrimitiveTypeCode Int64
public PrimitiveTypeCode Int64Nullable
public PrimitiveTypeCode UInt64
public PrimitiveTypeCode UInt64Nullable
public PrimitiveTypeCode Single
public PrimitiveTypeCode SingleNullable
public PrimitiveTypeCode Double
public PrimitiveTypeCode DoubleNullable
public PrimitiveTypeCode DateTime
public PrimitiveTypeCode DateTimeNullable
public PrimitiveTypeCode DateTimeOffset
public PrimitiveTypeCode DateTimeOffsetNullable
public PrimitiveTypeCode Decimal
public PrimitiveTypeCode DecimalNullable
public PrimitiveTypeCode Guid
public PrimitiveTypeCode GuidNullable
public PrimitiveTypeCode TimeSpan
public PrimitiveTypeCode TimeSpanNullable
public PrimitiveTypeCode BigInteger
public PrimitiveTypeCode BigIntegerNullable
public PrimitiveTypeCode Uri
public PrimitiveTypeCode String
public PrimitiveTypeCode Bytes
public PrimitiveTypeCode DBNull
}
internal Newtonsoft.Json.Utilities.PropertyNameTable : object {
private int HashCodeRandomizer
private int _count
private Entry[] _entries
private int _mask
public string Get(Char[] key, int start, int length)
public string Add(string key)
private string AddEntry(string str, int hashCode)
private void Grow()
private bool TextEquals(string str1, Char[] str2, int str2Start, int str2Length)
}
internal Newtonsoft.Json.Utilities.ReflectionDelegateFactory : object {
public Func`2<T, object> CreateGet(MemberInfo memberInfo)
public Action`2<T, object> CreateSet(MemberInfo memberInfo)
public MethodCall`2<T, object> CreateMethodCall(MethodBase method)
public ObjectConstructor`1<object> CreateParameterizedConstructor(MethodBase method)
public Func`1<T> CreateDefaultConstructor(Type type)
public Func`2<T, object> CreateGet(PropertyInfo propertyInfo)
public Func`2<T, object> CreateGet(FieldInfo fieldInfo)
public Action`2<T, object> CreateSet(FieldInfo fieldInfo)
public Action`2<T, object> CreateSet(PropertyInfo propertyInfo)
}
internal Newtonsoft.Json.Utilities.ReflectionMember : object {
private Type <MemberType>k__BackingField
private Func`2<object, object> <Getter>k__BackingField
private Action`2<object, object> <Setter>k__BackingField
public Type MemberType
public Func`2<object, object> Getter
public Action`2<object, object> Setter
public Type get_MemberType()
public void set_MemberType(Type value)
public Func`2<object, object> get_Getter()
public void set_Getter(Func`2<object, object> value)
public Action`2<object, object> get_Setter()
public void set_Setter(Action`2<object, object> value)
}
internal Newtonsoft.Json.Utilities.ReflectionObject : object {
private ObjectConstructor`1<object> <Creator>k__BackingField
private IDictionary`2<string, ReflectionMember> <Members>k__BackingField
public ObjectConstructor`1<object> Creator
public IDictionary`2<string, ReflectionMember> Members
public ObjectConstructor`1<object> get_Creator()
private void set_Creator(ObjectConstructor`1<object> value)
public IDictionary`2<string, ReflectionMember> get_Members()
private void set_Members(IDictionary`2<string, ReflectionMember> value)
public object GetValue(object target, string member)
public void SetValue(object target, string member, object value)
public Type GetType(string member)
public ReflectionObject Create(Type t, String[] memberNames)
public ReflectionObject Create(Type t, MethodBase creator, String[] memberNames)
}
internal Newtonsoft.Json.Utilities.ReflectionUtils : object {
public Type[] EmptyTypes
public bool IsVirtual(PropertyInfo propertyInfo)
public MethodInfo GetBaseDefinition(PropertyInfo propertyInfo)
public bool IsPublic(PropertyInfo property)
public Type GetObjectType(object v)
public string GetTypeName(Type t, FormatterAssemblyStyle assemblyFormat, SerializationBinder binder)
private string RemoveAssemblyDetails(string fullyQualifiedTypeName)
public bool HasDefaultConstructor(Type t, bool nonPublic)
public ConstructorInfo GetDefaultConstructor(Type t)
public ConstructorInfo GetDefaultConstructor(Type t, bool nonPublic)
public bool IsNullable(Type t)
public bool IsNullableType(Type t)
public Type EnsureNotNullableType(Type t)
public bool IsGenericDefinition(Type type, Type genericInterfaceDefinition)
public bool ImplementsGenericDefinition(Type type, Type genericInterfaceDefinition)
public bool ImplementsGenericDefinition(Type type, Type genericInterfaceDefinition, Type& implementingType)
public bool InheritsGenericDefinition(Type type, Type genericClassDefinition)
public bool InheritsGenericDefinition(Type type, Type genericClassDefinition, Type& implementingType)
private bool InheritsGenericDefinitionInternal(Type currentType, Type genericClassDefinition, Type& implementingType)
public Type GetCollectionItemType(Type type)
public void GetDictionaryKeyValueTypes(Type dictionaryType, Type& keyType, Type& valueType)
public Type GetMemberUnderlyingType(MemberInfo member)
public bool IsIndexedProperty(MemberInfo member)
public bool IsIndexedProperty(PropertyInfo property)
public object GetMemberValue(MemberInfo member, object target)
public void SetMemberValue(MemberInfo member, object target, object value)
public bool CanReadMemberValue(MemberInfo member, bool nonPublic)
public bool CanSetMemberValue(MemberInfo member, bool nonPublic, bool canSetReadOnly)
public List`1<MemberInfo> GetFieldsAndProperties(Type type, BindingFlags bindingAttr)
private bool IsOverridenGenericMember(MemberInfo memberInfo, BindingFlags bindingAttr)
public T GetAttribute(object attributeProvider)
public T GetAttribute(object attributeProvider, bool inherit)
public T[] GetAttributes(object attributeProvider, bool inherit)
public Attribute[] GetAttributes(object attributeProvider, Type attributeType, bool inherit)
public void SplitFullyQualifiedTypeName(string fullyQualifiedTypeName, String& typeName, String& assemblyName)
private Nullable`1<int> GetAssemblyDelimiterIndex(string fullyQualifiedTypeName)
public MemberInfo GetMemberInfoFromType(Type targetType, MemberInfo memberInfo)
public IEnumerable`1<FieldInfo> GetFields(Type targetType, BindingFlags bindingAttr)
private void GetChildPrivateFields(IList`1<MemberInfo> initialFields, Type targetType, BindingFlags bindingAttr)
public IEnumerable`1<PropertyInfo> GetProperties(Type targetType, BindingFlags bindingAttr)
public BindingFlags RemoveFlag(BindingFlags bindingAttr, BindingFlags flag)
private void GetChildPrivateProperties(IList`1<PropertyInfo> initialProperties, Type targetType, BindingFlags bindingAttr)
public bool IsMethodOverridden(Type currentType, Type methodDeclaringType, string method)
public object GetDefaultValue(Type type)
}
internal Newtonsoft.Json.Utilities.StringBuffer : ValueType {
private Char[] _buffer
private int _position
public int Position
public bool IsEmpty
public Char[] InternalBuffer
public int get_Position()
public void set_Position(int value)
public bool get_IsEmpty()
public void .ctor(IArrayPool`1<char> bufferPool, int initalSize)
private void .ctor(Char[] buffer)
public void Append(IArrayPool`1<char> bufferPool, char value)
public void Append(IArrayPool`1<char> bufferPool, Char[] buffer, int startIndex, int count)
public void Clear(IArrayPool`1<char> bufferPool)
private void EnsureSize(IArrayPool`1<char> bufferPool, int appendLength)
public string ToString()
public string ToString(int start, int length)
public Char[] get_InternalBuffer()
}
internal Newtonsoft.Json.Utilities.StringReference : ValueType {
private Char[] _chars
private int _startIndex
private int _length
public char Item
public Char[] Chars
public int StartIndex
public int Length
public char get_Item(int i)
public Char[] get_Chars()
public int get_StartIndex()
public int get_Length()
public void .ctor(Char[] chars, int startIndex, int length)
public string ToString()
}
internal Newtonsoft.Json.Utilities.StringReferenceExtensions : object {
public int IndexOf(StringReference s, char c, int startIndex, int length)
public bool StartsWith(StringReference s, string text)
public bool EndsWith(StringReference s, string text)
}
internal Newtonsoft.Json.Utilities.StringUtils : object {
public string CarriageReturnLineFeed
public string Empty
public char CarriageReturn
public char LineFeed
public char Tab
public string FormatWith(string format, IFormatProvider provider, object arg0)
public string FormatWith(string format, IFormatProvider provider, object arg0, object arg1)
public string FormatWith(string format, IFormatProvider provider, object arg0, object arg1, object arg2)
public string FormatWith(string format, IFormatProvider provider, object arg0, object arg1, object arg2, object arg3)
private string FormatWith(string format, IFormatProvider provider, Object[] args)
public bool IsWhiteSpace(string s)
public string NullEmptyString(string s)
public StringWriter CreateStringWriter(int capacity)
public Nullable`1<int> GetLength(string value)
public void ToCharAsUnicode(char c, Char[] buffer)
public TSource ForgivingCaseSensitiveFind(IEnumerable`1<TSource> source, Func`2<TSource, string> valueSelector, string testValue)
public string ToCamelCase(string s)
public bool IsHighSurrogate(char c)
public bool IsLowSurrogate(char c)
public bool StartsWith(string source, char value)
public bool EndsWith(string source, char value)
}
internal Newtonsoft.Json.Utilities.ThreadSafeStore`2 : object {
private object _lock
private Dictionary`2<TKey, TValue> _store
private Func`2<TKey, TValue> _creator
public void .ctor(Func`2<TKey, TValue> creator)
public TValue Get(TKey key)
private TValue AddValue(TKey key)
}
internal Newtonsoft.Json.Utilities.TypeExtensions : object {
public MethodInfo Method(Delegate d)
public MemberTypes MemberType(MemberInfo memberInfo)
public bool ContainsGenericParameters(Type type)
public bool IsInterface(Type type)
public bool IsGenericType(Type type)
public bool IsGenericTypeDefinition(Type type)
public Type BaseType(Type type)
public Assembly Assembly(Type type)
public bool IsEnum(Type type)
public bool IsClass(Type type)
public bool IsSealed(Type type)
public bool IsAbstract(Type type)
public bool IsVisible(Type type)
public bool IsValueType(Type type)
public bool AssignableToTypeName(Type type, string fullTypeName, Type& match)
public bool AssignableToTypeName(Type type, string fullTypeName)
public bool ImplementInterface(Type type, Type interfaceType)
}
internal Newtonsoft.Json.Utilities.TypeInformation : object {
private Type <Type>k__BackingField
private PrimitiveTypeCode <TypeCode>k__BackingField
public Type Type
public PrimitiveTypeCode TypeCode
public Type get_Type()
public void set_Type(Type value)
public PrimitiveTypeCode get_TypeCode()
public void set_TypeCode(PrimitiveTypeCode value)
}
internal Newtonsoft.Json.Utilities.ValidationUtils : object {
public void ArgumentNotNull(object value, string parameterName)
}
public Newtonsoft.Json.WriteState : Enum {
public int value__
public WriteState Error
public WriteState Closed
public WriteState Object
public WriteState Array
public WriteState Constructor
public WriteState Property
public WriteState Start
}
public ProtoBuf.BclHelpers : object {
private int FieldTimeSpanValue
private int FieldTimeSpanScale
private int FieldDecimalLow
private int FieldDecimalHigh
private int FieldDecimalSignScale
private int FieldGuidLow
private int FieldGuidHigh
private int FieldExistingObjectKey
private int FieldNewObjectKey
private int FieldExistingTypeKey
private int FieldNewTypeKey
private int FieldTypeName
private int FieldObject
internal DateTime EpochOrigin
public object GetUninitializedObject(Type type)
public void WriteTimeSpan(TimeSpan timeSpan, ProtoWriter dest)
public TimeSpan ReadTimeSpan(ProtoReader source)
public DateTime ReadDateTime(ProtoReader source)
public void WriteDateTime(DateTime value, ProtoWriter dest)
private long ReadTimeSpanTicks(ProtoReader source)
public decimal ReadDecimal(ProtoReader reader)
public void WriteDecimal(decimal value, ProtoWriter writer)
public void WriteGuid(Guid value, ProtoWriter dest)
public Guid ReadGuid(ProtoReader source)
public object ReadNetObject(object value, ProtoReader source, int key, Type type, NetObjectOptions options)
public void WriteNetObject(object value, ProtoWriter dest, int key, NetObjectOptions options)
}
public ProtoBuf.BufferExtension : object {
private Byte[] buffer
private int ProtoBuf.IExtension.GetLength()
private Stream ProtoBuf.IExtension.BeginAppend()
private void ProtoBuf.IExtension.EndAppend(Stream stream, bool commit)
private Stream ProtoBuf.IExtension.BeginQuery()
private void ProtoBuf.IExtension.EndQuery(Stream stream)
}
internal ProtoBuf.BufferPool : object {
private int PoolSize
internal int BufferLength
private Object[] pool
internal void Flush()
internal Byte[] GetBuffer()
internal void ResizeAndFlushLeft(Byte[]& buffer, int toFitAtLeastBytes, int copyFromIndex, int copyBytes)
internal void ReleaseBufferToPool(Byte[]& buffer)
}
internal ProtoBuf.Compiler.CodeLabel : ValueType {
public Label Value
public int Index
public void .ctor(Label value, int index)
}
internal ProtoBuf.Compiler.CompilerContext : object {
private DynamicMethod method
private int next
private bool isStatic
private SerializerPair[] methodPairs
private bool isWriter
private bool nonPublic
private Local inputValue
private string assemblyName
private ILGenerator il
private MutableList locals
private int nextLabel
private BasicList knownTrustedAssemblies
private BasicList knownUntrustedAssemblies
private TypeModel model
private ILVersion metadataVersion
public TypeModel Model
internal bool NonPublic
public Local InputValue
public ILVersion MetadataVersion
public TypeModel get_Model()
internal CodeLabel DefineLabel()
internal void MarkLabel(CodeLabel label)
public ProtoSerializer BuildSerializer(IProtoSerializer head, TypeModel model)
public ProtoDeserializer BuildDeserializer(IProtoSerializer head, TypeModel model)
internal void Return()
private bool IsObject(Type type)
internal void CastToObject(Type type)
internal void CastFromObject(Type type)
internal MethodBuilder GetDedicatedMethod(int metaKey, bool read)
internal int MapMetaKeyToCompiledKey(int metaKey)
internal bool get_NonPublic()
public Local get_InputValue()
internal void .ctor(ILGenerator il, bool isStatic, bool isWriter, SerializerPair[] methodPairs, TypeModel model, ILVersion metadataVersion, string assemblyName, Type inputType)
private void .ctor(Type associatedType, bool isWriter, bool isStatic, TypeModel model, Type inputType)
private void Emit(OpCode opcode)
public void LoadValue(string value)
public void LoadValue(float value)
public void LoadValue(double value)
public void LoadValue(long value)
public void LoadValue(int value)
internal LocalBuilder GetFromPool(Type type)
internal void ReleaseToPool(LocalBuilder value)
public void LoadReaderWriter()
public void StoreValue(Local local)
public void LoadValue(Local local)
public Local GetLocalWithValue(Type type, Local fromValue)
internal void EmitBasicRead(string methodName, Type expectedType)
internal void EmitBasicRead(Type helperType, string methodName, Type expectedType)
internal void EmitBasicWrite(string methodName, Local fromValue)
private MethodInfo GetWriterMethod(string methodName)
internal void EmitWrite(Type helperType, string methodName, Local valueFrom)
public void EmitCall(MethodInfo method)
public void LoadNullRef()
internal void WriteNullCheckedTail(Type type, IProtoSerializer tail, Local valueFrom)
internal void ReadNullCheckedTail(Type type, IProtoSerializer tail, Local valueFrom)
public void EmitCtor(Type type)
public void EmitCtor(ConstructorInfo ctor)
public void EmitCtor(Type type, Type[] parameterTypes)
private bool InternalsVisible(Assembly assembly)
internal void CheckAccessibility(MemberInfo member)
public void LoadValue(FieldInfo field)
public void StoreValue(FieldInfo field)
public void LoadValue(PropertyInfo property)
public void StoreValue(PropertyInfo property)
internal void LoadValue(ILGenerator il, int value)
private bool UseShortForm(Local local)
internal void LoadAddress(Local local, Type type)
internal void Branch(CodeLabel label, bool short)
internal void BranchIfFalse(CodeLabel label, bool short)
internal void BranchIfTrue(CodeLabel label, bool short)
internal void BranchIfEqual(CodeLabel label, bool short)
internal void CopyValue()
internal void BranchIfGreater(CodeLabel label, bool short)
internal void BranchIfLess(CodeLabel label, bool short)
internal void DiscardValue()
public void Subtract()
public void Switch(CodeLabel[] jumpTable)
internal void EndFinally()
internal void BeginFinally()
internal void EndTry(CodeLabel label, bool short)
internal CodeLabel BeginTry()
internal void Constrain(Type type)
internal void TryCast(Type type)
internal void Cast(Type type)
public IDisposable Using(Local local)
internal void Add()
internal void LoadLength(Local arr, bool zeroIfNull)
internal void CreateArray(Type elementType, Local length)
internal void LoadArrayValue(Local arr, Local i)
internal void LoadValue(Type type)
internal void ConvertToInt32(ProtoTypeCode typeCode, bool uint32Overflow)
internal void ConvertFromInt32(ProtoTypeCode typeCode, bool uint32Overflow)
internal void LoadValue(decimal value)
internal void LoadValue(Guid value)
internal void LoadSerializationContext()
internal Type MapType(Type type)
public ILVersion get_MetadataVersion()
internal bool AllowInternal(PropertyInfo property)
}
internal ProtoBuf.Compiler.Local : object {
private LocalBuilder value
private CompilerContext ctx
private Type type
public Type Type
internal LocalBuilder Value
public Type get_Type()
public Local AsCopy()
internal LocalBuilder get_Value()
public void Dispose()
private void .ctor(LocalBuilder value, Type type)
internal void .ctor(CompilerContext ctx, Type type)
internal bool IsSame(Local other)
}
internal ProtoBuf.Compiler.ProtoDeserializer : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public object Invoke(object value, ProtoReader source)
public IAsyncResult BeginInvoke(object value, ProtoReader source, AsyncCallback callback, object object)
public object EndInvoke(IAsyncResult result)
}
internal ProtoBuf.Compiler.ProtoSerializer : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object value, ProtoWriter dest)
public IAsyncResult BeginInvoke(object value, ProtoWriter dest, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public ProtoBuf.DataFormat : Enum {
public int value__
public DataFormat Default
public DataFormat ZigZag
public DataFormat TwosComplement
public DataFormat FixedSize
public DataFormat Group
}
public ProtoBuf.Extensible : object {
private IExtension extensionObject
private IExtension ProtoBuf.IExtensible.GetExtensionObject(bool createIfMissing)
protected IExtension GetExtensionObject(bool createIfMissing)
public IExtension GetExtensionObject(IExtension& extensionObject, bool createIfMissing)
public void AppendValue(IExtensible instance, int tag, TValue value)
public void AppendValue(IExtensible instance, int tag, DataFormat format, TValue value)
public TValue GetValue(IExtensible instance, int tag)
public TValue GetValue(IExtensible instance, int tag, DataFormat format)
public bool TryGetValue(IExtensible instance, int tag, TValue& value)
public bool TryGetValue(IExtensible instance, int tag, DataFormat format, TValue& value)
public bool TryGetValue(IExtensible instance, int tag, DataFormat format, bool allowDefinedTag, TValue& value)
public IEnumerable`1<TValue> GetValues(IExtensible instance, int tag)
public IEnumerable`1<TValue> GetValues(IExtensible instance, int tag, DataFormat format)
public bool TryGetValue(TypeModel model, Type type, IExtensible instance, int tag, DataFormat format, bool allowDefinedTag, Object& value)
public IEnumerable GetValues(TypeModel model, Type type, IExtensible instance, int tag, DataFormat format)
public void AppendValue(TypeModel model, IExtensible instance, int tag, DataFormat format, object value)
}
internal ProtoBuf.ExtensibleUtil : object {
internal IEnumerable`1<TValue> GetExtendedValues(IExtensible instance, int tag, DataFormat format, bool singleton, bool allowDefinedTag)
internal IEnumerable GetExtendedValues(TypeModel model, Type type, IExtensible instance, int tag, DataFormat format, bool singleton, bool allowDefinedTag)
internal void AppendExtendValue(TypeModel model, IExtensible instance, int tag, DataFormat format, object value)
}
internal ProtoBuf.Helpers : object {
public Type[] EmptyTypes
public StringBuilder AppendLine(StringBuilder builder)
public bool IsNullOrEmpty(string value)
public void DebugWriteLine(string message, object obj)
public void DebugWriteLine(string message)
public void TraceWriteLine(string message)
public void DebugAssert(bool condition, string message)
public void DebugAssert(bool condition, string message, Object[] args)
public void DebugAssert(bool condition)
public void Sort(Int32[] keys, Object[] values)
public void BlockCopy(Byte[] from, int fromIndex, Byte[] to, int toIndex, int count)
public bool IsInfinity(float value)
internal MethodInfo GetInstanceMethod(Type declaringType, string name)
internal MethodInfo GetStaticMethod(Type declaringType, string name)
internal MethodInfo GetInstanceMethod(Type declaringType, string name, Type[] types)
internal bool IsSubclassOf(Type type, Type baseClass)
public bool IsInfinity(double value)
public ProtoTypeCode GetTypeCode(Type type)
internal Type GetUnderlyingType(Type type)
internal bool IsValueType(Type type)
internal bool IsEnum(Type type)
internal MethodInfo GetGetMethod(PropertyInfo property, bool nonPublic, bool allowInternal)
internal MethodInfo GetSetMethod(PropertyInfo property, bool nonPublic, bool allowInternal)
internal ConstructorInfo GetConstructor(Type type, Type[] parameterTypes, bool nonPublic)
internal ConstructorInfo[] GetConstructors(Type type, bool nonPublic)
internal PropertyInfo GetProperty(Type type, string name, bool nonPublic)
internal object ParseEnum(Type type, string value)
internal MemberInfo[] GetInstanceFieldsAndProperties(Type type, bool publicOnly)
internal Type GetMemberType(MemberInfo member)
internal bool IsAssignableFrom(Type target, Type type)
}
public ProtoBuf.IExtensible {
public IExtension GetExtensionObject(bool createIfMissing)
}
public ProtoBuf.IExtension {
public Stream BeginAppend()
public void EndAppend(Stream stream, bool commit)
public Stream BeginQuery()
public void EndQuery(Stream stream)
public int GetLength()
}
public ProtoBuf.ImplicitFields : Enum {
public int value__
public ImplicitFields None
public ImplicitFields AllPublic
public ImplicitFields AllFields
}
public ProtoBuf.MemberSerializationOptions : Enum {
public int value__
public MemberSerializationOptions None
public MemberSerializationOptions Packed
public MemberSerializationOptions Required
public MemberSerializationOptions AsReference
public MemberSerializationOptions DynamicType
public MemberSerializationOptions OverwriteList
public MemberSerializationOptions AsReferenceHasValue
}
internal ProtoBuf.Meta.AttributeMap : object {
public Type AttributeType
public object Target
public bool TryGet(string key, bool publicOnly, Object& value)
public bool TryGet(string key, Object& value)
public Type get_AttributeType()
public AttributeMap[] Create(TypeModel model, Type type, bool inherit)
public AttributeMap[] Create(TypeModel model, MemberInfo member, bool inherit)
public AttributeMap[] Create(TypeModel model, Assembly assembly)
public object get_Target()
}
internal ProtoBuf.Meta.BasicList : object {
private Node nil
protected Node head
public object Item
public int Count
public void CopyTo(Array array, int offset)
public int Add(object value)
public object get_Item(int index)
public void Trim()
public int get_Count()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
public NodeEnumerator GetEnumerator()
internal int IndexOf(MatchPredicate predicate, object ctx)
internal int IndexOfString(string value)
internal int IndexOfReference(object instance)
internal bool Contains(object value)
internal BasicList GetContiguousGroups(Int32[] keys, Object[] values)
}
public ProtoBuf.Meta.CallbackSet : object {
private MetaType metaType
private MethodInfo beforeSerialize
private MethodInfo afterSerialize
private MethodInfo beforeDeserialize
private MethodInfo afterDeserialize
internal MethodInfo Item
public MethodInfo BeforeSerialize
public MethodInfo BeforeDeserialize
public MethodInfo AfterSerialize
public MethodInfo AfterDeserialize
public bool NonTrivial
internal void .ctor(MetaType metaType)
internal MethodInfo get_Item(CallbackType callbackType)
internal bool CheckCallbackParameters(TypeModel model, MethodInfo method)
private MethodInfo SanityCheckCallback(TypeModel model, MethodInfo callback)
internal Exception CreateInvalidCallbackSignature(MethodInfo method)
public MethodInfo get_BeforeSerialize()
public void set_BeforeSerialize(MethodInfo value)
public MethodInfo get_BeforeDeserialize()
public void set_BeforeDeserialize(MethodInfo value)
public MethodInfo get_AfterSerialize()
public void set_AfterSerialize(MethodInfo value)
public MethodInfo get_AfterDeserialize()
public void set_AfterDeserialize(MethodInfo value)
public bool get_NonTrivial()
}
public ProtoBuf.Meta.LockContentedEventArgs : EventArgs {
private string ownerStackTrace
public string OwnerStackTrace
internal void .ctor(string ownerStackTrace)
public string get_OwnerStackTrace()
}
public ProtoBuf.Meta.LockContentedEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, LockContentedEventArgs args)
public IAsyncResult BeginInvoke(object sender, LockContentedEventArgs args, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public ProtoBuf.Meta.MetaType : object {
private byte OPTIONS_Pending
private byte OPTIONS_EnumPassThru
private byte OPTIONS_Frozen
private byte OPTIONS_PrivateOnApi
private byte OPTIONS_SkipConstructor
private byte OPTIONS_AsReferenceDefault
private byte OPTIONS_AutoTuple
private byte OPTIONS_IgnoreListHandling
private MetaType baseType
private BasicList subTypes
internal Type ienumerable
private CallbackSet callbacks
private string name
private MethodInfo factory
private RuntimeTypeModel model
private Type type
private IProtoTypeSerializer serializer
private Type constructType
private Type surrogate
private BasicList fields
private Byte modreq(System.Runtime.CompilerServices.IsVolatile) flags
private IProtoSerializer ProtoBuf.Serializers.ISerializerProxy.Serializer
public MetaType BaseType
internal TypeModel Model
public bool IncludeSerializerMethod
public bool AsReferenceDefault
public bool HasCallbacks
public bool HasSubtypes
public CallbackSet Callbacks
private bool IsValueType
public string Name
public Type Type
internal IProtoTypeSerializer Serializer
internal bool IsList
public bool UseConstructor
public Type ConstructType
public ValueMember Item
public ValueMember Item
public bool EnumPassthru
public bool IgnoreListHandling
internal bool Pending
internal IEnumerable Fields
internal bool IsAutoTuple
public string ToString()
private IProtoSerializer ProtoBuf.Serializers.ISerializerProxy.get_Serializer()
public MetaType get_BaseType()
internal TypeModel get_Model()
public bool get_IncludeSerializerMethod()
public void set_IncludeSerializerMethod(bool value)
public bool get_AsReferenceDefault()
public void set_AsReferenceDefault(bool value)
private bool IsValidSubType(Type subType)
public MetaType AddSubType(int fieldNumber, Type derivedType)
public MetaType AddSubType(int fieldNumber, Type derivedType, DataFormat dataFormat)
private void SetBaseType(MetaType baseType)
public bool get_HasCallbacks()
public bool get_HasSubtypes()
public CallbackSet get_Callbacks()
private bool get_IsValueType()
public MetaType SetCallbacks(MethodInfo beforeSerialize, MethodInfo afterSerialize, MethodInfo beforeDeserialize, MethodInfo afterDeserialize)
public MetaType SetCallbacks(string beforeSerialize, string afterSerialize, string beforeDeserialize, string afterDeserialize)
internal string GetSchemaTypeName()
public string get_Name()
public void set_Name(string value)
public MetaType SetFactory(MethodInfo factory)
public MetaType SetFactory(string factory)
private MethodInfo ResolveMethod(string name, bool instance)
internal Exception InbuiltType(Type type)
internal void .ctor(RuntimeTypeModel model, Type type, MethodInfo factory)
protected internal void ThrowIfFrozen()
public Type get_Type()
internal IProtoTypeSerializer get_Serializer()
internal bool get_IsList()
private IProtoTypeSerializer BuildSerializer()
private Type GetBaseType(MetaType type)
internal bool GetAsReferenceDefault(RuntimeTypeModel model, Type type)
internal void ApplyDefaultBehaviour()
private void ApplyDefaultBehaviour_AddMembers(TypeModel model, AttributeFamily family, bool isEnum, BasicList partialMembers, int dataMemberOffset, bool inferTagByName, ImplicitFields implicitMode, BasicList members, MemberInfo member, Boolean& forced, bool isPublic, bool isField, Type& effectiveType)
private MethodInfo Coalesce(MethodInfo[] arr, int x, int y)
internal AttributeFamily GetContractFamily(RuntimeTypeModel model, Type type, AttributeMap[] attributes)
internal ConstructorInfo ResolveTupleConstructor(Type type, MemberInfo[]& mappedMembers)
private void CheckForCallback(MethodInfo method, AttributeMap[] attributes, string callbackTypeName, MethodInfo[]& callbacks, int index)
private bool HasFamily(AttributeFamily value, AttributeFamily required)
private ProtoMemberAttribute NormalizeProtoMember(TypeModel model, MemberInfo member, AttributeFamily family, bool forced, bool isEnum, BasicList partialMembers, int dataMemberOffset, bool inferByTagName)
private ValueMember ApplyDefaultBehaviour(bool isEnum, ProtoMemberAttribute normalizedAttribute)
private void GetDataFormat(DataFormat& value, AttributeMap attrib, string memberName)
private void GetIgnore(Boolean& ignore, AttributeMap attrib, AttributeMap[] attribs, string fullName)
private void GetFieldBoolean(Boolean& value, AttributeMap attrib, string memberName)
private bool GetFieldBoolean(Boolean& value, AttributeMap attrib, string memberName, bool publicOnly)
private void GetFieldNumber(Int32& value, AttributeMap attrib, string memberName)
private void GetFieldName(String& name, AttributeMap attrib, string memberName)
private AttributeMap GetAttribute(AttributeMap[] attribs, string fullName)
public MetaType Add(int fieldNumber, string memberName)
public ValueMember AddField(int fieldNumber, string memberName)
public bool get_UseConstructor()
public void set_UseConstructor(bool value)
public Type get_ConstructType()
public void set_ConstructType(Type value)
public MetaType Add(string memberName)
public void SetSurrogate(Type surrogateType)
internal MetaType GetSurrogateOrSelf()
internal MetaType GetSurrogateOrBaseOrSelf(bool deep)
private int GetNextFieldNumber()
public MetaType Add(String[] memberNames)
public MetaType Add(int fieldNumber, string memberName, object defaultValue)
public MetaType Add(int fieldNumber, string memberName, Type itemType, Type defaultType)
public ValueMember AddField(int fieldNumber, string memberName, Type itemType, Type defaultType)
private ValueMember AddField(int fieldNumber, string memberName, Type itemType, Type defaultType, object defaultValue)
internal void ResolveListTypes(TypeModel model, Type type, Type& itemType, Type& defaultType)
private void Add(ValueMember member)
public ValueMember get_Item(int fieldNumber)
public ValueMember get_Item(MemberInfo member)
public ValueMember[] GetFields()
public SubType[] GetSubtypes()
public void CompileInPlace()
internal bool IsDefined(int fieldNumber)
internal int GetKey(bool demand, bool getBaseKey)
internal EnumPair[] GetEnumMap()
public bool get_EnumPassthru()
public void set_EnumPassthru(bool value)
public bool get_IgnoreListHandling()
public void set_IgnoreListHandling(bool value)
internal bool get_Pending()
internal void set_Pending(bool value)
private bool HasFlag(byte flag)
private void SetFlag(byte flag, bool value, bool throwIfFrozen)
internal MetaType GetRootType(MetaType source)
internal bool IsPrepared()
internal IEnumerable get_Fields()
internal StringBuilder NewLine(StringBuilder builder, int indent)
internal bool get_IsAutoTuple()
internal void WriteSchema(StringBuilder builder, int indent, Boolean& requiresBclImport)
}
internal ProtoBuf.Meta.MutableList : BasicList {
public object Item
public object get_Item(int index)
public void set_Item(int index, object value)
public void RemoveLast()
public void Clear()
}
public ProtoBuf.Meta.RuntimeTypeModel : TypeModel {
private byte OPTIONS_InferTagFromNameDefault
private byte OPTIONS_IsDefaultModel
private byte OPTIONS_Frozen
private byte OPTIONS_AutoAddMissingTypes
private byte OPTIONS_AutoCompile
private byte OPTIONS_UseImplicitZeroDefaults
private byte OPTIONS_AllowParseableTypes
private byte OPTIONS_AutoAddProtoContractTypesOnly
private int KnownTypes_Array
private int KnownTypes_Dictionary
private int KnownTypes_Hashtable
private int KnownTypes_ArrayCutoff
private byte options
private MatchPredicate MetaTypeFinder
private MatchPredicate BasicTypeFinder
private BasicList basicTypes
private BasicList types
private int metadataTimeoutMilliseconds
private int contentionCounter
private object contentionLock
private LockContentedEventHandler LockContended
private MethodInfo defaultFactory
public bool InferTagFromNameDefault
public bool AutoAddProtoContractTypesOnly
public bool UseImplicitZeroDefaults
public bool AllowParseableTypes
public RuntimeTypeModel Default
public MetaType Item
public bool AutoCompile
public bool AutoAddMissingTypes
public int MetadataTimeoutMilliseconds
private bool GetOption(byte option)
private void SetOption(byte option, bool value)
public bool get_InferTagFromNameDefault()
public void set_InferTagFromNameDefault(bool value)
public bool get_AutoAddProtoContractTypesOnly()
public void set_AutoAddProtoContractTypesOnly(bool value)
public bool get_UseImplicitZeroDefaults()
public void set_UseImplicitZeroDefaults(bool value)
public bool get_AllowParseableTypes()
public void set_AllowParseableTypes(bool value)
public RuntimeTypeModel get_Default()
public IEnumerable GetTypes()
public string GetSchema(Type type)
private void CascadeDependents(BasicList list, MetaType metaType)
internal void .ctor(bool isDefault)
public MetaType get_Item(Type type)
internal MetaType FindWithoutAdd(Type type)
private bool MetaTypeFinderImpl(object value, object ctx)
private bool BasicTypeFinderImpl(object value, object ctx)
private void WaitOnLock(MetaType type)
internal IProtoSerializer TryGetBasicTypeSerializer(Type type)
internal int FindOrAddAuto(Type type, bool demand, bool addWithContractOnly, bool addEvenIfAutoDisabled)
private MetaType RecogniseCommonTypes(Type type)
private MetaType Create(Type type)
public MetaType Add(Type type, bool applyDefaultBehaviour)
public bool get_AutoCompile()
public void set_AutoCompile(bool value)
public bool get_AutoAddMissingTypes()
public void set_AutoAddMissingTypes(bool value)
private void ThrowIfFrozen()
public void Freeze()
protected int GetKeyImpl(Type type)
internal int GetKey(Type type, bool demand, bool getBaseKey)
protected internal void Serialize(int key, object value, ProtoWriter dest)
protected internal object Deserialize(int key, object value, ProtoReader source)
internal ProtoSerializer GetSerializer(IProtoSerializer serializer, bool compiled)
public void CompileInPlace()
private void BuildAllSerializers()
public TypeModel Compile()
private ILGenerator Override(TypeBuilder type, string name)
public TypeModel Compile(string name, string path)
public TypeModel Compile(CompilerOptions options)
private void WriteConstructors(TypeBuilder type, Int32& index, SerializerPair[] methodPairs, ILGenerator& il, int knownTypesCategory, FieldBuilder knownTypes, Type knownTypesLookupType, CompilerContext ctx)
private CompilerContext WriteSerializeDeserialize(string assemblyName, TypeBuilder type, SerializerPair[] methodPairs, ILVersion ilVersion, ILGenerator& il)
private void WriteGetKeyImpl(TypeBuilder type, bool hasInheritance, SerializerPair[] methodPairs, ILVersion ilVersion, string assemblyName, ILGenerator& il, Int32& knownTypesCategory, FieldBuilder& knownTypes, Type& knownTypesLookupType)
private void WriteSerializers(CompilerOptions options, string assemblyName, TypeBuilder type, Int32& index, Boolean& hasInheritance, SerializerPair[]& methodPairs, ILVersion& ilVersion)
private TypeBuilder WriteBasicTypeModel(CompilerOptions options, string typeName, ModuleBuilder module)
private void WriteAssemblyAttributes(CompilerOptions options, string assemblyName, AssemblyBuilder asm)
private MethodBuilder EmitBoxedSerializer(TypeBuilder type, int i, Type valueType, SerializerPair[] methodPairs, TypeModel model, ILVersion ilVersion, string assemblyName)
internal bool IsPrepared(Type type)
internal EnumPair[] GetEnumMap(Type type)
public int get_MetadataTimeoutMilliseconds()
public void set_MetadataTimeoutMilliseconds(int value)
internal void TakeLock(Int32& opaqueToken)
private int GetContention()
private void AddContention()
internal void ReleaseLock(int opaqueToken)
public void add_LockContended(LockContentedEventHandler value)
public void remove_LockContended(LockContentedEventHandler value)
internal void ResolveListTypes(Type type, Type& itemType, Type& defaultType)
internal string GetSchemaTypeName(Type effectiveType, DataFormat dataFormat, bool asReference, bool dynamicType, Boolean& requiresBclImport)
public void SetDefaultFactory(MethodInfo methodInfo)
internal void VerifyFactory(MethodInfo factory, Type type)
}
public ProtoBuf.Meta.SubType : object {
private int fieldNumber
private MetaType derivedType
private DataFormat dataFormat
private IProtoSerializer serializer
public int FieldNumber
public MetaType DerivedType
internal IProtoSerializer Serializer
public int get_FieldNumber()
public MetaType get_DerivedType()
public void .ctor(int fieldNumber, MetaType derivedType, DataFormat format)
internal IProtoSerializer get_Serializer()
private IProtoSerializer BuildSerializer()
}
public ProtoBuf.Meta.TypeFormatEventArgs : EventArgs {
private Type type
private string formattedName
private bool typeFixed
public Type Type
public string FormattedName
public Type get_Type()
public void set_Type(Type value)
public string get_FormattedName()
public void set_FormattedName(string value)
internal void .ctor(string formattedName)
internal void .ctor(Type type)
}
public ProtoBuf.Meta.TypeFormatEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, TypeFormatEventArgs args)
public IAsyncResult BeginInvoke(object sender, TypeFormatEventArgs args, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public ProtoBuf.Meta.TypeModel : object {
private Type ilist
private TypeFormatEventHandler DynamicTypeFormatting
protected internal Type MapType(Type type)
protected internal Type MapType(Type type, bool demand)
private WireType GetWireType(ProtoTypeCode code, DataFormat format, Type& type, Int32& modelKey)
internal bool TrySerializeAuxiliaryType(ProtoWriter writer, Type type, DataFormat format, int tag, object value, bool isInsideList)
private void SerializeCore(ProtoWriter writer, object value)
public void Serialize(Stream dest, object value)
public void Serialize(Stream dest, object value, SerializationContext context)
public void Serialize(ProtoWriter dest, object value)
public object DeserializeWithLengthPrefix(Stream source, object value, Type type, PrefixStyle style, int fieldNumber)
public object DeserializeWithLengthPrefix(Stream source, object value, Type type, PrefixStyle style, int expectedField, TypeResolver resolver)
public object DeserializeWithLengthPrefix(Stream source, object value, Type type, PrefixStyle style, int expectedField, TypeResolver resolver, Int32& bytesRead)
private object DeserializeWithLengthPrefix(Stream source, object value, Type type, PrefixStyle style, int expectedField, TypeResolver resolver, Int32& bytesRead, Boolean& haveObject, SerializationContext context)
public IEnumerable DeserializeItems(Stream source, Type type, PrefixStyle style, int expectedField, TypeResolver resolver)
public IEnumerable DeserializeItems(Stream source, Type type, PrefixStyle style, int expectedField, TypeResolver resolver, SerializationContext context)
public IEnumerable`1<T> DeserializeItems(Stream source, PrefixStyle style, int expectedField)
public IEnumerable`1<T> DeserializeItems(Stream source, PrefixStyle style, int expectedField, SerializationContext context)
public void SerializeWithLengthPrefix(Stream dest, object value, Type type, PrefixStyle style, int fieldNumber)
public void SerializeWithLengthPrefix(Stream dest, object value, Type type, PrefixStyle style, int fieldNumber, SerializationContext context)
public object Deserialize(Stream source, object value, Type type)
public object Deserialize(Stream source, object value, Type type, SerializationContext context)
private bool PrepareDeserialize(object value, Type& type)
public object Deserialize(Stream source, object value, Type type, int length)
public object Deserialize(Stream source, object value, Type type, int length, SerializationContext context)
public object Deserialize(ProtoReader source, object value, Type type)
private object DeserializeCore(ProtoReader reader, Type type, object value, bool noAutoCreate)
internal MethodInfo ResolveListAdd(TypeModel model, Type listType, Type itemType, Boolean& isList)
internal Type GetListItemType(TypeModel model, Type listType)
private void TestEnumerableListPatterns(TypeModel model, BasicList candidates, Type iType)
private bool CheckDictionaryAccessors(TypeModel model, Type pair, Type value)
private bool TryDeserializeList(TypeModel model, ProtoReader reader, DataFormat format, int tag, Type listType, Type itemType, Object& value)
private object CreateListInstance(Type listType, Type itemType)
internal bool TryDeserializeAuxiliaryType(ProtoReader reader, DataFormat format, int tag, Type type, Object& value, bool skipOtherFields, bool asListItem, bool autoCreate, bool insideList)
public RuntimeTypeModel Create()
protected internal Type ResolveProxies(Type type)
public bool IsDefined(Type type)
protected internal int GetKey(Type& type)
protected int GetKeyImpl(Type type)
protected internal void Serialize(int key, object value, ProtoWriter dest)
protected internal object Deserialize(int key, object value, ProtoReader source)
public object DeepClone(object value)
protected internal void ThrowUnexpectedSubtype(Type expected, Type actual)
protected internal void ThrowUnexpectedType(Type type)
internal Exception CreateNestedListsNotSupported()
public void ThrowCannotCreateInstance(Type type)
internal string SerializeType(TypeModel model, Type type)
internal Type DeserializeType(TypeModel model, string value)
public bool CanSerializeContractType(Type type)
public bool CanSerialize(Type type)
public bool CanSerializeBasicType(Type type)
private bool CanSerialize(Type type, bool allowBasic, bool allowContract, bool allowLists)
public string GetSchema(Type type)
public void add_DynamicTypeFormatting(TypeFormatEventHandler value)
public void remove_DynamicTypeFormatting(TypeFormatEventHandler value)
public IFormatter CreateFormatter(Type type)
internal Type GetType(string fullName, Assembly context)
internal Type ResolveKnownType(string name, TypeModel model, Assembly assembly)
}
public ProtoBuf.Meta.ValueMember : object {
private byte OPTIONS_IsStrict
private byte OPTIONS_IsPacked
private byte OPTIONS_IsRequired
private byte OPTIONS_OverwriteList
private byte OPTIONS_SupportNull
private int fieldNumber
private MemberInfo member
private Type parentType
private Type itemType
private Type defaultType
private Type memberType
private object defaultValue
private RuntimeTypeModel model
private IProtoSerializer serializer
private DataFormat dataFormat
private bool asReference
private bool dynamicType
private MethodInfo getSpecified
private MethodInfo setSpecified
private string name
private byte flags
public int FieldNumber
public MemberInfo Member
public Type ItemType
public Type MemberType
public Type DefaultType
public Type ParentType
public object DefaultValue
internal IProtoSerializer Serializer
public DataFormat DataFormat
public bool IsStrict
public bool IsPacked
public bool OverwriteList
public bool IsRequired
public bool AsReference
public bool DynamicType
public string Name
public bool SupportNull
public int get_FieldNumber()
public MemberInfo get_Member()
public Type get_ItemType()
public Type get_MemberType()
public Type get_DefaultType()
public Type get_ParentType()
public object get_DefaultValue()
public void set_DefaultValue(object value)
public void .ctor(RuntimeTypeModel model, Type parentType, int fieldNumber, MemberInfo member, Type memberType, Type itemType, Type defaultType, DataFormat dataFormat, object defaultValue)
internal void .ctor(RuntimeTypeModel model, int fieldNumber, Type memberType, Type itemType, Type defaultType, DataFormat dataFormat)
internal object GetRawEnumValue()
private object ParseDefaultValue(Type type, object value)
internal IProtoSerializer get_Serializer()
public DataFormat get_DataFormat()
public void set_DataFormat(DataFormat value)
public bool get_IsStrict()
public void set_IsStrict(bool value)
public bool get_IsPacked()
public void set_IsPacked(bool value)
public bool get_OverwriteList()
public void set_OverwriteList(bool value)
public bool get_IsRequired()
public void set_IsRequired(bool value)
public bool get_AsReference()
public void set_AsReference(bool value)
public bool get_DynamicType()
public void set_DynamicType(bool value)
public void SetSpecified(MethodInfo getSpecified, MethodInfo setSpecified)
private void ThrowIfFrozen()
private IProtoSerializer BuildSerializer()
private WireType GetIntWireType(DataFormat format, int width)
private WireType GetDateTimeWireType(DataFormat format)
internal IProtoSerializer TryGetCoreSerializer(RuntimeTypeModel model, DataFormat dataFormat, Type type, WireType& defaultWireType, bool asReference, bool dynamicType, bool overwriteList, bool allowComplexTypes)
internal void SetName(string name)
public string get_Name()
private bool HasFlag(byte flag)
private void SetFlag(byte flag, bool value, bool throwIfFrozen)
public bool get_SupportNull()
public void set_SupportNull(bool value)
internal string GetSchemaTypeName(bool applyNetObjectProxy, Boolean& requiresBclImport)
}
internal ProtoBuf.NetObjectCache : object {
internal int Root
private MutableList underlyingList
private object rootObject
private int trapStartIndex
private Dictionary`2<string, int> stringKeys
private Dictionary`2<object, int> objectKeys
private MutableList List
private MutableList get_List()
internal object GetKeyedObject(int key)
internal void SetKeyedObject(int key, object value)
internal int AddObjectKey(object value, Boolean& existing)
internal void RegisterTrappedObject(object value)
internal void Clear()
}
public ProtoBuf.PrefixStyle : Enum {
public int value__
public PrefixStyle None
public PrefixStyle Base128
public PrefixStyle Fixed32
public PrefixStyle Fixed32BigEndian
}
public ProtoBuf.ProtoContractAttribute : Attribute {
private byte OPTIONS_InferTagFromName
private byte OPTIONS_InferTagFromNameHasValue
private byte OPTIONS_UseProtoMembersOnly
private byte OPTIONS_SkipConstructor
private byte OPTIONS_IgnoreListHandling
private byte OPTIONS_AsReferenceDefault
private byte OPTIONS_EnumPassthru
private byte OPTIONS_EnumPassthruHasValue
private string name
private int implicitFirstTag
private ImplicitFields implicitFields
private int dataMemberOffset
private byte flags
public string Name
public int ImplicitFirstTag
public bool UseProtoMembersOnly
public bool IgnoreListHandling
public ImplicitFields ImplicitFields
public bool InferTagFromName
internal bool InferTagFromNameHasValue
public int DataMemberOffset
public bool SkipConstructor
public bool AsReferenceDefault
public bool EnumPassthru
internal bool EnumPassthruHasValue
public string get_Name()
public void set_Name(string value)
public int get_ImplicitFirstTag()
public void set_ImplicitFirstTag(int value)
public bool get_UseProtoMembersOnly()
public void set_UseProtoMembersOnly(bool value)
public bool get_IgnoreListHandling()
public void set_IgnoreListHandling(bool value)
public ImplicitFields get_ImplicitFields()
public void set_ImplicitFields(ImplicitFields value)
public bool get_InferTagFromName()
public void set_InferTagFromName(bool value)
internal bool get_InferTagFromNameHasValue()
public int get_DataMemberOffset()
public void set_DataMemberOffset(int value)
public bool get_SkipConstructor()
public void set_SkipConstructor(bool value)
public bool get_AsReferenceDefault()
public void set_AsReferenceDefault(bool value)
private bool HasFlag(byte flag)
private void SetFlag(byte flag, bool value)
public bool get_EnumPassthru()
public void set_EnumPassthru(bool value)
internal bool get_EnumPassthruHasValue()
}
public ProtoBuf.ProtoEnumAttribute : Attribute {
private bool hasValue
private int enumValue
private string name
public int Value
public string Name
public int get_Value()
public void set_Value(int value)
public bool HasValue()
public string get_Name()
public void set_Name(string value)
}
public ProtoBuf.ProtoException : Exception {
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
protected void .ctor(SerializationInfo info, StreamingContext context)
}
public ProtoBuf.ProtoIncludeAttribute : Attribute {
private int tag
private string knownTypeName
private DataFormat dataFormat
public int Tag
public string KnownTypeName
public Type KnownType
public DataFormat DataFormat
public void .ctor(int tag, Type knownType)
public void .ctor(int tag, string knownTypeName)
public int get_Tag()
public string get_KnownTypeName()
public Type get_KnownType()
public DataFormat get_DataFormat()
public void set_DataFormat(DataFormat value)
}
public ProtoBuf.ProtoMemberAttribute : Attribute {
internal MemberInfo Member
internal bool TagIsPinned
private string name
private DataFormat dataFormat
private int tag
private MemberSerializationOptions options
public string Name
public DataFormat DataFormat
public int Tag
public bool IsRequired
public bool IsPacked
public bool OverwriteList
public bool AsReference
internal bool AsReferenceHasValue
public bool DynamicType
public MemberSerializationOptions Options
public int CompareTo(object other)
public int CompareTo(ProtoMemberAttribute other)
public void .ctor(int tag)
internal void .ctor(int tag, bool forced)
public string get_Name()
public void set_Name(string value)
public DataFormat get_DataFormat()
public void set_DataFormat(DataFormat value)
public int get_Tag()
internal void Rebase(int tag)
public bool get_IsRequired()
public void set_IsRequired(bool value)
public bool get_IsPacked()
public void set_IsPacked(bool value)
public bool get_OverwriteList()
public void set_OverwriteList(bool value)
public bool get_AsReference()
public void set_AsReference(bool value)
internal bool get_AsReferenceHasValue()
internal void set_AsReferenceHasValue(bool value)
public bool get_DynamicType()
public void set_DynamicType(bool value)
public MemberSerializationOptions get_Options()
public void set_Options(MemberSerializationOptions value)
}
public ProtoBuf.ProtoPartialIgnoreAttribute : ProtoIgnoreAttribute {
private string memberName
public string MemberName
public void .ctor(string memberName)
public string get_MemberName()
}
public ProtoBuf.ProtoPartialMemberAttribute : ProtoMemberAttribute {
private string memberName
public string MemberName
public void .ctor(int tag, string memberName)
public string get_MemberName()
}
public ProtoBuf.ProtoReader : object {
internal int TO_EOF
private long Int64Msb
private int Int32Msb
private Stream source
private Byte[] ioBuffer
private TypeModel model
private int fieldNumber
private int depth
private int dataRemaining
private int ioIndex
private int position
private int available
private int blockEnd
private WireType wireType
private bool isFixedLength
private bool internStrings
private NetObjectCache netCache
private UInt32 trapCount
private SerializationContext context
private Dictionary`2<string, string> stringInterner
private UTF8Encoding encoding
private Byte[] EmptyBlob
private ProtoReader lastReader
public int FieldNumber
public WireType WireType
public bool InternStrings
public SerializationContext Context
public int Position
public TypeModel Model
internal NetObjectCache NetCache
public int get_FieldNumber()
public WireType get_WireType()
public void .ctor(Stream source, TypeModel model, SerializationContext context)
public bool get_InternStrings()
public void set_InternStrings(bool value)
public void .ctor(Stream source, TypeModel model, SerializationContext context, int length)
private void Init(ProtoReader reader, Stream source, TypeModel model, SerializationContext context, int length)
public SerializationContext get_Context()
public void Dispose()
internal int TryReadUInt32VariantWithoutMoving(bool trimNegative, UInt32& value)
private UInt32 ReadUInt32Variant(bool trimNegative)
private bool TryReadUInt32Variant(UInt32& value)
public UInt32 ReadUInt32()
public int get_Position()
internal void Ensure(int count, bool strict)
public short ReadInt16()
public ushort ReadUInt16()
public byte ReadByte()
public sbyte ReadSByte()
public int ReadInt32()
private int Zag(UInt32 ziggedValue)
private long Zag(ulong ziggedValue)
public long ReadInt64()
private int TryReadUInt64VariantWithoutMoving(UInt64& value)
private ulong ReadUInt64Variant()
private string Intern(string value)
public string ReadString()
public void ThrowEnumException(Type type, int value)
private Exception CreateWireTypeException()
private Exception CreateException(string message)
public double ReadDouble()
public object ReadObject(object value, int key, ProtoReader reader)
internal object ReadTypedObject(object value, int key, ProtoReader reader, Type type)
public void EndSubItem(SubItemToken token, ProtoReader reader)
public SubItemToken StartSubItem(ProtoReader reader)
public int ReadFieldHeader()
public bool TryReadFieldHeader(int field)
public TypeModel get_Model()
public void Hint(WireType wireType)
public void Assert(WireType wireType)
public void SkipField()
public ulong ReadUInt64()
public float ReadSingle()
public bool ReadBoolean()
public Byte[] AppendBytes(Byte[] value, ProtoReader reader)
private int ReadByteOrThrow(Stream source)
public int ReadLengthPrefix(Stream source, bool expectHeader, PrefixStyle style, Int32& fieldNumber)
public int DirectReadLittleEndianInt32(Stream source)
public int DirectReadBigEndianInt32(Stream source)
public int DirectReadVarintInt32(Stream source)
public void DirectReadBytes(Stream source, Byte[] buffer, int offset, int count)
public Byte[] DirectReadBytes(Stream source, int count)
public string DirectReadString(Stream source, int length)
public int ReadLengthPrefix(Stream source, bool expectHeader, PrefixStyle style, Int32& fieldNumber, Int32& bytesRead)
private int TryReadUInt32Variant(Stream source, UInt32& value)
internal void Seek(Stream source, int count, Byte[] buffer)
internal Exception AddErrorData(Exception exception, ProtoReader source)
private Exception EoF(ProtoReader source)
public void AppendExtensionData(IExtensible instance)
private void AppendExtensionField(ProtoWriter writer)
public bool HasSubValue(WireType wireType, ProtoReader source)
internal int GetTypeKey(Type& type)
internal NetObjectCache get_NetCache()
internal Type DeserializeType(string value)
internal void SetRootObject(object value)
public void NoteObject(object value, ProtoReader reader)
public Type ReadType()
internal void TrapNextObject(int newObjectKey)
internal void CheckFullyConsumed()
public object Merge(ProtoReader parent, object from, object to)
internal ProtoReader Create(Stream source, TypeModel model, SerializationContext context, int len)
private ProtoReader GetRecycled()
internal void Recycle(ProtoReader reader)
}
internal ProtoBuf.ProtoTypeCode : Enum {
public int value__
public ProtoTypeCode Empty
public ProtoTypeCode Unknown
public ProtoTypeCode Boolean
public ProtoTypeCode Char
public ProtoTypeCode SByte
public ProtoTypeCode Byte
public ProtoTypeCode Int16
public ProtoTypeCode UInt16
public ProtoTypeCode Int32
public ProtoTypeCode UInt32
public ProtoTypeCode Int64
public ProtoTypeCode UInt64
public ProtoTypeCode Single
public ProtoTypeCode Double
public ProtoTypeCode Decimal
public ProtoTypeCode DateTime
public ProtoTypeCode String
public ProtoTypeCode TimeSpan
public ProtoTypeCode ByteArray
public ProtoTypeCode Guid
public ProtoTypeCode Uri
public ProtoTypeCode Type
}
public ProtoBuf.ProtoWriter : object {
private int RecursionCheckDepth
private Stream dest
private TypeModel model
private NetObjectCache netCache
private int fieldNumber
private int flushLock
private WireType wireType
private int depth
private MutableList recursionStack
private SerializationContext context
private Byte[] ioBuffer
private int ioIndex
private int position
private UTF8Encoding encoding
private int packedFieldNumber
internal NetObjectCache NetCache
internal WireType WireType
public SerializationContext Context
public TypeModel Model
public void WriteObject(object value, int key, ProtoWriter writer)
public void WriteRecursionSafeObject(object value, int key, ProtoWriter writer)
internal void WriteObject(object value, int key, ProtoWriter writer, PrefixStyle style, int fieldNumber)
internal int GetTypeKey(Type& type)
internal NetObjectCache get_NetCache()
internal WireType get_WireType()
public void WriteFieldHeader(int fieldNumber, WireType wireType, ProtoWriter writer)
internal void WriteHeaderCore(int fieldNumber, WireType wireType, ProtoWriter writer)
public void WriteBytes(Byte[] data, ProtoWriter writer)
public void WriteBytes(Byte[] data, int offset, int length, ProtoWriter writer)
private void CopyRawFromStream(Stream source, ProtoWriter writer)
private void IncrementedAndReset(int length, ProtoWriter writer)
public SubItemToken StartSubItem(object instance, ProtoWriter writer)
private void CheckRecursionStackAndPush(object instance)
private void PopRecursionStack()
private SubItemToken StartSubItem(object instance, ProtoWriter writer, bool allowFixed)
public void EndSubItem(SubItemToken token, ProtoWriter writer)
private void EndSubItem(SubItemToken token, ProtoWriter writer, PrefixStyle style)
public void .ctor(Stream dest, TypeModel model, SerializationContext context)
public SerializationContext get_Context()
private void System.IDisposable.Dispose()
private void Dispose()
internal int GetPosition(ProtoWriter writer)
private void DemandSpace(int required, ProtoWriter writer)
public void Close()
internal void CheckDepthFlushlock()
public TypeModel get_Model()
internal void Flush(ProtoWriter writer)
private void WriteUInt32Variant(UInt32 value, ProtoWriter writer)
internal UInt32 Zig(int value)
internal ulong Zig(long value)
private void WriteUInt64Variant(ulong value, ProtoWriter writer)
public void WriteString(string value, ProtoWriter writer)
public void WriteUInt64(ulong value, ProtoWriter writer)
public void WriteInt64(long value, ProtoWriter writer)
public void WriteUInt32(UInt32 value, ProtoWriter writer)
public void WriteInt16(short value, ProtoWriter writer)
public void WriteUInt16(ushort value, ProtoWriter writer)
public void WriteByte(byte value, ProtoWriter writer)
public void WriteSByte(sbyte value, ProtoWriter writer)
private void WriteInt32ToBuffer(int value, Byte[] buffer, int index)
public void WriteInt32(int value, ProtoWriter writer)
public void WriteDouble(double value, ProtoWriter writer)
public void WriteSingle(float value, ProtoWriter writer)
public void ThrowEnumException(ProtoWriter writer, object enumValue)
internal Exception CreateException(ProtoWriter writer)
public void WriteBoolean(bool value, ProtoWriter writer)
public void AppendExtensionData(IExtensible instance, ProtoWriter writer)
public void SetPackedField(int fieldNumber, ProtoWriter writer)
internal string SerializeType(Type type)
public void SetRootObject(object value)
public void WriteType(Type value, ProtoWriter writer)
}
public ProtoBuf.SerializationContext : object {
private bool frozen
private object context
private SerializationContext default
private StreamingContextStates state
public object Context
internal SerializationContext Default
public StreamingContextStates State
internal void Freeze()
private void ThrowIfFrozen()
public object get_Context()
public void set_Context(object value)
internal SerializationContext get_Default()
public StreamingContextStates get_State()
public void set_State(StreamingContextStates value)
public StreamingContext op_Implicit(SerializationContext ctx)
public SerializationContext op_Implicit(StreamingContext ctx)
}
public ProtoBuf.Serializer : object {
private string ProtoBinaryField
public int ListItemTag
public string GetProto()
public T DeepClone(T instance)
public T Merge(Stream source, T instance)
public T Deserialize(Stream source)
public void Serialize(Stream destination, T instance)
public TTo ChangeType(TFrom instance)
public void Serialize(SerializationInfo info, T instance)
public void Serialize(SerializationInfo info, StreamingContext context, T instance)
public void Serialize(XmlWriter writer, T instance)
public void Merge(XmlReader reader, T instance)
public void Merge(SerializationInfo info, T instance)
public void Merge(SerializationInfo info, StreamingContext context, T instance)
public void PrepareSerializer()
public IFormatter CreateFormatter()
public IEnumerable`1<T> DeserializeItems(Stream source, PrefixStyle style, int fieldNumber)
public T DeserializeWithLengthPrefix(Stream source, PrefixStyle style)
public T DeserializeWithLengthPrefix(Stream source, PrefixStyle style, int fieldNumber)
public T MergeWithLengthPrefix(Stream source, T instance, PrefixStyle style)
public void SerializeWithLengthPrefix(Stream destination, T instance, PrefixStyle style)
public void SerializeWithLengthPrefix(Stream destination, T instance, PrefixStyle style, int fieldNumber)
public bool TryReadLengthPrefix(Stream source, PrefixStyle style, Int32& length)
public bool TryReadLengthPrefix(Byte[] buffer, int index, int count, PrefixStyle style, Int32& length)
public void FlushPool()
}
internal ProtoBuf.Serializers.ArrayDecorator : ProtoDecoratorBase {
private byte OPTIONS_WritePacked
private byte OPTIONS_OverwriteList
private byte OPTIONS_SupportNull
private int fieldNumber
private byte options
private WireType packedWireType
private Type arrayType
private Type itemType
public Type ExpectedType
public bool RequiresOldValue
public bool ReturnsValue
private bool AppendToCollection
private bool SupportNull
public void .ctor(TypeModel model, IProtoSerializer tail, int fieldNumber, bool writePacked, WireType packedWireType, Type arrayType, bool overwriteList, bool supportNull)
public Type get_ExpectedType()
public bool get_RequiresOldValue()
public bool get_ReturnsValue()
protected void EmitWrite(CompilerContext ctx, Local valueFrom)
private void EmitWriteArrayLoop(CompilerContext ctx, Local i, Local arr)
private bool get_AppendToCollection()
private bool get_SupportNull()
public void Write(object value, ProtoWriter dest)
public object Read(object value, ProtoReader source)
protected void EmitRead(CompilerContext ctx, Local valueFrom)
}
internal ProtoBuf.Serializers.BlobSerializer : object {
private Type expectedType
private bool overwriteList
public Type ExpectedType
private bool ProtoBuf.Serializers.IProtoSerializer.RequiresOldValue
private bool ProtoBuf.Serializers.IProtoSerializer.ReturnsValue
public Type get_ExpectedType()
public void .ctor(TypeModel model, bool overwriteList)
public object Read(object value, ProtoReader source)
public void Write(object value, ProtoWriter dest)
private bool ProtoBuf.Serializers.IProtoSerializer.get_RequiresOldValue()
private bool ProtoBuf.Serializers.IProtoSerializer.get_ReturnsValue()
private void ProtoBuf.Serializers.IProtoSerializer.EmitWrite(CompilerContext ctx, Local valueFrom)
private void ProtoBuf.Serializers.IProtoSerializer.EmitRead(CompilerContext ctx, Local valueFrom)
}
internal ProtoBuf.Serializers.BooleanSerializer : object {
private Type expectedType
public Type ExpectedType
private bool ProtoBuf.Serializers.IProtoSerializer.RequiresOldValue
private bool ProtoBuf.Serializers.IProtoSerializer.ReturnsValue
public void .ctor(TypeModel model)
public Type get_ExpectedType()
public void Write(object value, ProtoWriter dest)
public object Read(object value, ProtoReader source)
private bool ProtoBuf.Serializers.IProtoSerializer.get_RequiresOldValue()
private bool ProtoBuf.Serializers.IProtoSerializer.get_ReturnsValue()
private void ProtoBuf.Serializers.IProtoSerializer.EmitWrite(CompilerContext ctx, Local valueFrom)
private void ProtoBuf.Serializers.IProtoSerializer.EmitRead(CompilerContext ctx, Local valueFrom)
}
internal ProtoBuf.Serializers.ByteSerializer : object {
private Type expectedType
public Type ExpectedType
private bool ProtoBuf.Serializers.IProtoSerializer.RequiresOldValue
private bool ProtoBuf.Serializers.IProtoSerializer.ReturnsValue
public Type get_ExpectedType()
public void .ctor(TypeModel model)
private bool ProtoBuf.Serializers.IProtoSerializer.get_RequiresOldValue()
private bool ProtoBuf.Serializers.IProtoSerializer.get_ReturnsValue()
public void Write(object value, ProtoWriter dest)
public object Read(object value, ProtoReader source)
private void ProtoBuf.Serializers.IProtoSerializer.EmitWrite(CompilerContext ctx, Local valueFrom)
private void ProtoBuf.Serializers.IProtoSerializer.EmitRead(CompilerContext ctx, Local valueFrom)
}
internal ProtoBuf.Serializers.CharSerializer : UInt16Serializer {
private Type expectedType
public Type ExpectedType
public void .ctor(TypeModel model)
public Type get_ExpectedType()
public void Write(object value, ProtoWriter dest)
public object Read(object value, ProtoReader source)
}
internal ProtoBuf.Serializers.CompiledSerializer : object {
private IProtoTypeSerializer head
private ProtoSerializer serializer
private ProtoDeserializer deserializer
private bool ProtoBuf.Serializers.IProtoSerializer.RequiresOldValue
private bool ProtoBuf.Serializers.IProtoSerializer.ReturnsValue
private Type ProtoBuf.Serializers.IProtoSerializer.ExpectedType
private bool ProtoBuf.Serializers.IProtoTypeSerializer.HasCallbacks(CallbackType callbackType)
private bool ProtoBuf.Serializers.IProtoTypeSerializer.CanCreateInstance()
private object ProtoBuf.Serializers.IProtoTypeSerializer.CreateInstance(ProtoReader source)
public void Callback(object value, CallbackType callbackType, SerializationContext context)
public CompiledSerializer Wrap(IProtoTypeSerializer head, TypeModel model)
private void .ctor(IProtoTypeSerializer head, TypeModel model)
private bool ProtoBuf.Serializers.IProtoSerializer.get_RequiresOldValue()
private bool ProtoBuf.Serializers.IProtoSerializer.get_ReturnsValue()
private Type ProtoBuf.Serializers.IProtoSerializer.get_ExpectedType()
private void ProtoBuf.Serializers.IProtoSerializer.Write(object value, ProtoWriter dest)
private object ProtoBuf.Serializers.IProtoSerializer.Read(object value, ProtoReader source)
private void ProtoBuf.Serializers.IProtoSerializer.EmitWrite(CompilerContext ctx, Local valueFrom)
private void ProtoBuf.Serializers.IProtoSerializer.EmitRead(CompilerContext ctx, Local valueFrom)
private void ProtoBuf.Serializers.IProtoTypeSerializer.EmitCallback(CompilerContext ctx, Local valueFrom, CallbackType callbackType)
private void ProtoBuf.Serializers.IProtoTypeSerializer.EmitCreateInstance(CompilerContext ctx)
}
internal ProtoBuf.Serializers.DateTimeSerializer : object {
private Type expectedType
public Type ExpectedType
private bool ProtoBuf.Serializers.IProtoSerializer.RequiresOldValue
private bool ProtoBuf.Serializers.IProtoSerializer.ReturnsValue
public Type get_ExpectedType()
private bool ProtoBuf.Serializers.IProtoSerializer.get_RequiresOldValue()
private bool ProtoBuf.Serializers.IProtoSerializer.get_ReturnsValue()
public void .ctor(TypeModel model)
public object Read(object value, ProtoReader source)
public void Write(object value, ProtoWriter dest)
private void ProtoBuf.Serializers.IProtoSerializer.EmitWrite(CompilerContext ctx, Local valueFrom)
private void ProtoBuf.Serializers.IProtoSerializer.EmitRead(CompilerContext ctx, Local valueFrom)
}
internal ProtoBuf.Serializers.DecimalSerializer : object {
private Type expectedType
public Type ExpectedType
private bool ProtoBuf.Serializers.IProtoSerializer.RequiresOldValue
private bool ProtoBuf.Serializers.IProtoSerializer.ReturnsValue
public void .ctor(TypeModel model)
public Type get_ExpectedType()
private bool ProtoBuf.Serializers.IProtoSerializer.get_RequiresOldValue()
private bool ProtoBuf.Serializers.IProtoSerializer.get_ReturnsValue()
public object Read(object value, ProtoReader source)
public void Write(object value, ProtoWriter dest)
private void ProtoBuf.Serializers.IProtoSerializer.EmitWrite(CompilerContext ctx, Local valueFrom)
private void ProtoBuf.Serializers.IProtoSerializer.EmitRead(CompilerContext ctx, Local valueFrom)
}
internal ProtoBuf.Serializers.DefaultValueDecorator : ProtoDecoratorBase {
private object defaultValue
public Type ExpectedType
public bool RequiresOldValue
public bool ReturnsValue
public Type get_ExpectedType()
public bool get_RequiresOldValue()
public bool get_ReturnsValue()
public void .ctor(TypeModel model, object defaultValue, IProtoSerializer tail)
public void Write(object value, ProtoWriter dest)
public object Read(object value, ProtoReader source)
protected void EmitWrite(CompilerContext ctx, Local valueFrom)
private void EmitBeq(CompilerContext ctx, CodeLabel label, Type type)
private void EmitBranchIfDefaultValue(CompilerContext ctx, CodeLabel label)
protected void EmitRead(CompilerContext ctx, Local valueFrom)
}
internal ProtoBuf.Serializers.DoubleSerializer : object {
private Type expectedType
public Type ExpectedType
private bool ProtoBuf.Serializers.IProtoSerializer.RequiresOldValue
private bool ProtoBuf.Serializers.IProtoSerializer.ReturnsValue
public void .ctor(TypeModel model)
public Type get_ExpectedType()
private bool ProtoBuf.Serializers.IProtoSerializer.get_RequiresOldValue()
private bool ProtoBuf.Serializers.IProtoSerializer.get_ReturnsValue()
public object Read(object value, ProtoReader source)
public void Write(object value, ProtoWriter dest)
private void ProtoBuf.Serializers.IProtoSerializer.EmitWrite(CompilerContext ctx, Local valueFrom)
private void ProtoBuf.Serializers.IProtoSerializer.EmitRead(CompilerContext ctx, Local valueFrom)
}
internal ProtoBuf.Serializers.EnumSerializer : object {
private Type enumType
private EnumPair[] map
public Type ExpectedType
private bool ProtoBuf.Serializers.IProtoSerializer.RequiresOldValue
private bool ProtoBuf.Serializers.IProtoSerializer.ReturnsValue
public void .ctor(Type enumType, EnumPair[] map)
private ProtoTypeCode GetTypeCode()
public Type get_ExpectedType()
private bool ProtoBuf.Serializers.IProtoSerializer.get_RequiresOldValue()
private bool ProtoBuf.Serializers.IProtoSerializer.get_ReturnsValue()
private int EnumToWire(object value)
private object WireToEnum(int value)
public object Read(object value, ProtoReader source)
public void Write(object value, ProtoWriter dest)
private void ProtoBuf.Serializers.IProtoSerializer.EmitWrite(CompilerContext ctx, Local valueFrom)
private void ProtoBuf.Serializers.IProtoSerializer.EmitRead(CompilerContext ctx, Local valueFrom)
private void WriteEnumValue(CompilerContext ctx, ProtoTypeCode typeCode, object value)
private void WriteEnumValue(CompilerContext ctx, ProtoTypeCode typeCode, CodeLabel handler, CodeLabel continue, object value, Local local)
}
internal ProtoBuf.Serializers.FieldDecorator : ProtoDecoratorBase {
private FieldInfo field
private Type forType
public Type ExpectedType
public bool RequiresOldValue
public bool ReturnsValue
public Type get_ExpectedType()
public bool get_RequiresOldValue()
public bool get_ReturnsValue()
public void .ctor(Type forType, FieldInfo field, IProtoSerializer tail)
public void Write(object value, ProtoWriter dest)
public object Read(object value, ProtoReader source)
protected void EmitWrite(CompilerContext ctx, Local valueFrom)
protected void EmitRead(CompilerContext ctx, Local valueFrom)
}
internal ProtoBuf.Serializers.GuidSerializer : object {
private Type expectedType
public Type ExpectedType
private bool ProtoBuf.Serializers.IProtoSerializer.RequiresOldValue
private bool ProtoBuf.Serializers.IProtoSerializer.ReturnsValue
public void .ctor(TypeModel model)
public Type get_ExpectedType()
private bool ProtoBuf.Serializers.IProtoSerializer.get_RequiresOldValue()
private bool ProtoBuf.Serializers.IProtoSerializer.get_ReturnsValue()
public void Write(object value, ProtoWriter dest)
public object Read(object value, ProtoReader source)
private void ProtoBuf.Serializers.IProtoSerializer.EmitWrite(CompilerContext ctx, Local valueFrom)
private void ProtoBuf.Serializers.IProtoSerializer.EmitRead(CompilerContext ctx, Local valueFrom)
}
internal ProtoBuf.Serializers.ImmutableCollectionDecorator : ListDecorator {
private MethodInfo builderFactory
private MethodInfo add
private MethodInfo addRange
private MethodInfo finish
protected bool RequireAdd
protected bool get_RequireAdd()
private Type ResolveIReadOnlyCollection(Type declaredType, Type t)
internal bool IdentifyImmutable(TypeModel model, Type declaredType, MethodInfo& builderFactory, MethodInfo& add, MethodInfo& addRange, MethodInfo& finish)
internal void .ctor(TypeModel model, Type declaredType, Type concreteType, IProtoSerializer tail, int fieldNumber, bool writePacked, WireType packedWireType, bool returnList, bool overwriteList, bool supportNull, MethodInfo builderFactory, MethodInfo add, MethodInfo addRange, MethodInfo finish)
public object Read(object value, ProtoReader source)
protected void EmitRead(CompilerContext ctx, Local valueFrom)
}
internal ProtoBuf.Serializers.Int16Serializer : object {
private Type expectedType
public Type ExpectedType
private bool ProtoBuf.Serializers.IProtoSerializer.RequiresOldValue
private bool ProtoBuf.Serializers.IProtoSerializer.ReturnsValue
public void .ctor(TypeModel model)
public Type get_ExpectedType()
private bool ProtoBuf.Serializers.IProtoSerializer.get_RequiresOldValue()
private bool ProtoBuf.Serializers.IProtoSerializer.get_ReturnsValue()
public object Read(object value, ProtoReader source)
public void Write(object value, ProtoWriter dest)
private void ProtoBuf.Serializers.IProtoSerializer.EmitWrite(CompilerContext ctx, Local valueFrom)
private void ProtoBuf.Serializers.IProtoSerializer.EmitRead(CompilerContext ctx, Local valueFrom)
}
internal ProtoBuf.Serializers.Int32Serializer : object {
private Type expectedType
public Type ExpectedType
private bool ProtoBuf.Serializers.IProtoSerializer.RequiresOldValue
private bool ProtoBuf.Serializers.IProtoSerializer.ReturnsValue
public void .ctor(TypeModel model)
public Type get_ExpectedType()
private bool ProtoBuf.Serializers.IProtoSerializer.get_RequiresOldValue()
private bool ProtoBuf.Serializers.IProtoSerializer.get_ReturnsValue()
public object Read(object value, ProtoReader source)
public void Write(object value, ProtoWriter dest)
private void ProtoBuf.Serializers.IProtoSerializer.EmitWrite(CompilerContext ctx, Local valueFrom)
private void ProtoBuf.Serializers.IProtoSerializer.EmitRead(CompilerContext ctx, Local valueFrom)
}
internal ProtoBuf.Serializers.Int64Serializer : object {
private Type expectedType
public Type ExpectedType
private bool ProtoBuf.Serializers.IProtoSerializer.RequiresOldValue
private bool ProtoBuf.Serializers.IProtoSerializer.ReturnsValue
public void .ctor(TypeModel model)
public Type get_ExpectedType()
private bool ProtoBuf.Serializers.IProtoSerializer.get_RequiresOldValue()
private bool ProtoBuf.Serializers.IProtoSerializer.get_ReturnsValue()
public object Read(object value, ProtoReader source)
public void Write(object value, ProtoWriter dest)
private void ProtoBuf.Serializers.IProtoSerializer.EmitWrite(CompilerContext ctx, Local valueFrom)
private void ProtoBuf.Serializers.IProtoSerializer.EmitRead(CompilerContext ctx, Local valueFrom)
}
internal ProtoBuf.Serializers.IProtoSerializer {
public Type ExpectedType
public bool RequiresOldValue
public bool ReturnsValue
public Type get_ExpectedType()
public void Write(object value, ProtoWriter dest)
public object Read(object value, ProtoReader source)
public bool get_RequiresOldValue()
public bool get_ReturnsValue()
public void EmitWrite(CompilerContext ctx, Local valueFrom)
public void EmitRead(CompilerContext ctx, Local entity)
}
internal ProtoBuf.Serializers.IProtoTypeSerializer {
public bool HasCallbacks(CallbackType callbackType)
public bool CanCreateInstance()
public object CreateInstance(ProtoReader source)
public void Callback(object value, CallbackType callbackType, SerializationContext context)
public void EmitCallback(CompilerContext ctx, Local valueFrom, CallbackType callbackType)
public void EmitCreateInstance(CompilerContext ctx)
}
internal ProtoBuf.Serializers.ISerializerProxy {
public IProtoSerializer Serializer
public IProtoSerializer get_Serializer()
}
internal ProtoBuf.Serializers.ListDecorator : ProtoDecoratorBase {
private byte OPTIONS_IsList
private byte OPTIONS_SuppressIList
private byte OPTIONS_WritePacked
private byte OPTIONS_ReturnList
private byte OPTIONS_OverwriteList
private byte OPTIONS_SupportNull
private byte options
private Type declaredType
private Type concreteType
private MethodInfo add
private int fieldNumber
protected WireType packedWireType
private Type ienumeratorType
private Type ienumerableType
private bool IsList
private bool SuppressIList
private bool WritePacked
private bool SupportNull
private bool ReturnList
protected bool RequireAdd
public Type ExpectedType
public bool RequiresOldValue
public bool ReturnsValue
protected bool AppendToCollection
internal bool CanPack(WireType wireType)
private bool get_IsList()
private bool get_SuppressIList()
private bool get_WritePacked()
private bool get_SupportNull()
private bool get_ReturnList()
internal ListDecorator Create(TypeModel model, Type declaredType, Type concreteType, IProtoSerializer tail, int fieldNumber, bool writePacked, WireType packedWireType, bool returnList, bool overwriteList, bool supportNull)
protected void .ctor(TypeModel model, Type declaredType, Type concreteType, IProtoSerializer tail, int fieldNumber, bool writePacked, WireType packedWireType, bool returnList, bool overwriteList, bool supportNull)
protected bool get_RequireAdd()
public Type get_ExpectedType()
public bool get_RequiresOldValue()
public bool get_ReturnsValue()
protected bool get_AppendToCollection()
protected void EmitRead(CompilerContext ctx, Local valueFrom)
internal void EmitReadList(CompilerContext ctx, Local list, IProtoSerializer tail, MethodInfo add, WireType packedWireType, bool castListForAdd)
private void EmitReadAndAddItem(CompilerContext ctx, Local list, IProtoSerializer tail, MethodInfo add, bool castListForAdd)
protected MethodInfo GetEnumeratorInfo(TypeModel model, MethodInfo& moveNext, MethodInfo& current)
protected void EmitWrite(CompilerContext ctx, Local valueFrom)
public void Write(object value, ProtoWriter dest)
public object Read(object value, ProtoReader source)
}
internal ProtoBuf.Serializers.MemberSpecifiedDecorator : ProtoDecoratorBase {
private MethodInfo getSpecified
private MethodInfo setSpecified
public Type ExpectedType
public bool RequiresOldValue
public bool ReturnsValue
public Type get_ExpectedType()
public bool get_RequiresOldValue()
public bool get_ReturnsValue()
public void .ctor(MethodInfo getSpecified, MethodInfo setSpecified, IProtoSerializer tail)
public void Write(object value, ProtoWriter dest)
public object Read(object value, ProtoReader source)
protected void EmitWrite(CompilerContext ctx, Local valueFrom)
protected void EmitRead(CompilerContext ctx, Local valueFrom)
}
internal ProtoBuf.Serializers.NetObjectSerializer : object {
private int key
private Type type
private NetObjectOptions options
public Type ExpectedType
public bool ReturnsValue
public bool RequiresOldValue
public void .ctor(TypeModel model, Type type, int key, NetObjectOptions options)
public Type get_ExpectedType()
public bool get_ReturnsValue()
public bool get_RequiresOldValue()
public object Read(object value, ProtoReader source)
public void Write(object value, ProtoWriter dest)
public void EmitRead(CompilerContext ctx, Local valueFrom)
public void EmitWrite(CompilerContext ctx, Local valueFrom)
}
internal ProtoBuf.Serializers.NullDecorator : ProtoDecoratorBase {
public int Tag
private Type expectedType
public Type ExpectedType
public bool ReturnsValue
public bool RequiresOldValue
public void .ctor(TypeModel model, IProtoSerializer tail)
public Type get_ExpectedType()
public bool get_ReturnsValue()
public bool get_RequiresOldValue()
protected void EmitRead(CompilerContext ctx, Local valueFrom)
protected void EmitWrite(CompilerContext ctx, Local valueFrom)
public object Read(object value, ProtoReader source)
public void Write(object value, ProtoWriter dest)
}
internal ProtoBuf.Serializers.ParseableSerializer : object {
private MethodInfo parse
public Type ExpectedType
private bool ProtoBuf.Serializers.IProtoSerializer.RequiresOldValue
private bool ProtoBuf.Serializers.IProtoSerializer.ReturnsValue
public ParseableSerializer TryCreate(Type type, TypeModel model)
private MethodInfo GetCustomToString(Type type)
private void .ctor(MethodInfo parse)
public Type get_ExpectedType()
private bool ProtoBuf.Serializers.IProtoSerializer.get_RequiresOldValue()
private bool ProtoBuf.Serializers.IProtoSerializer.get_ReturnsValue()
public object Read(object value, ProtoReader source)
public void Write(object value, ProtoWriter dest)
private void ProtoBuf.Serializers.IProtoSerializer.EmitWrite(CompilerContext ctx, Local valueFrom)
private void ProtoBuf.Serializers.IProtoSerializer.EmitRead(CompilerContext ctx, Local valueFrom)
}
internal ProtoBuf.Serializers.PropertyDecorator : ProtoDecoratorBase {
private PropertyInfo property
private Type forType
private bool readOptionsWriteValue
private MethodInfo shadowSetter
public Type ExpectedType
public bool RequiresOldValue
public bool ReturnsValue
public Type get_ExpectedType()
public bool get_RequiresOldValue()
public bool get_ReturnsValue()
public void .ctor(TypeModel model, Type forType, PropertyInfo property, IProtoSerializer tail)
private void SanityCheck(TypeModel model, PropertyInfo property, IProtoSerializer tail, Boolean& writeValue, bool nonPublic, bool allowInternal)
private MethodInfo GetShadowSetter(TypeModel model, PropertyInfo property)
public void Write(object value, ProtoWriter dest)
public object Read(object value, ProtoReader source)
protected void EmitWrite(CompilerContext ctx, Local valueFrom)
protected void EmitRead(CompilerContext ctx, Local valueFrom)
internal bool CanWrite(TypeModel model, MemberInfo member)
}
internal ProtoBuf.Serializers.ProtoDecoratorBase : object {
protected IProtoSerializer Tail
public Type ExpectedType
public bool ReturnsValue
public bool RequiresOldValue
public Type get_ExpectedType()
protected void .ctor(IProtoSerializer tail)
public bool get_ReturnsValue()
public bool get_RequiresOldValue()
public void Write(object value, ProtoWriter dest)
public object Read(object value, ProtoReader source)
private void ProtoBuf.Serializers.IProtoSerializer.EmitWrite(CompilerContext ctx, Local valueFrom)
protected void EmitWrite(CompilerContext ctx, Local valueFrom)
private void ProtoBuf.Serializers.IProtoSerializer.EmitRead(CompilerContext ctx, Local valueFrom)
protected void EmitRead(CompilerContext ctx, Local valueFrom)
}
internal ProtoBuf.Serializers.SByteSerializer : object {
private Type expectedType
public Type ExpectedType
private bool ProtoBuf.Serializers.IProtoSerializer.RequiresOldValue
private bool ProtoBuf.Serializers.IProtoSerializer.ReturnsValue
public void .ctor(TypeModel model)
public Type get_ExpectedType()
private bool ProtoBuf.Serializers.IProtoSerializer.get_RequiresOldValue()
private bool ProtoBuf.Serializers.IProtoSerializer.get_ReturnsValue()
public object Read(object value, ProtoReader source)
public void Write(object value, ProtoWriter dest)
private void ProtoBuf.Serializers.IProtoSerializer.EmitWrite(CompilerContext ctx, Local valueFrom)
private void ProtoBuf.Serializers.IProtoSerializer.EmitRead(CompilerContext ctx, Local valueFrom)
}
internal ProtoBuf.Serializers.SingleSerializer : object {
private Type expectedType
public Type ExpectedType
private bool ProtoBuf.Serializers.IProtoSerializer.RequiresOldValue
private bool ProtoBuf.Serializers.IProtoSerializer.ReturnsValue
public Type get_ExpectedType()
public void .ctor(TypeModel model)
private bool ProtoBuf.Serializers.IProtoSerializer.get_RequiresOldValue()
private bool ProtoBuf.Serializers.IProtoSerializer.get_ReturnsValue()
public object Read(object value, ProtoReader source)
public void Write(object value, ProtoWriter dest)
private void ProtoBuf.Serializers.IProtoSerializer.EmitWrite(CompilerContext ctx, Local valueFrom)
private void ProtoBuf.Serializers.IProtoSerializer.EmitRead(CompilerContext ctx, Local valueFrom)
}
internal ProtoBuf.Serializers.StringSerializer : object {
private Type expectedType
public Type ExpectedType
private bool ProtoBuf.Serializers.IProtoSerializer.RequiresOldValue
private bool ProtoBuf.Serializers.IProtoSerializer.ReturnsValue
public void .ctor(TypeModel model)
public Type get_ExpectedType()
public void Write(object value, ProtoWriter dest)
private bool ProtoBuf.Serializers.IProtoSerializer.get_RequiresOldValue()
private bool ProtoBuf.Serializers.IProtoSerializer.get_ReturnsValue()
public object Read(object value, ProtoReader source)
private void ProtoBuf.Serializers.IProtoSerializer.EmitWrite(CompilerContext ctx, Local valueFrom)
private void ProtoBuf.Serializers.IProtoSerializer.EmitRead(CompilerContext ctx, Local valueFrom)
}
internal ProtoBuf.Serializers.SubItemSerializer : object {
private int key
private Type type
private ISerializerProxy proxy
private bool recursionCheck
private Type ProtoBuf.Serializers.IProtoSerializer.ExpectedType
private bool ProtoBuf.Serializers.IProtoSerializer.RequiresOldValue
private bool ProtoBuf.Serializers.IProtoSerializer.ReturnsValue
private bool ProtoBuf.Serializers.IProtoTypeSerializer.HasCallbacks(CallbackType callbackType)
private bool ProtoBuf.Serializers.IProtoTypeSerializer.CanCreateInstance()
private void ProtoBuf.Serializers.IProtoTypeSerializer.EmitCallback(CompilerContext ctx, Local valueFrom, CallbackType callbackType)
private void ProtoBuf.Serializers.IProtoTypeSerializer.EmitCreateInstance(CompilerContext ctx)
private void ProtoBuf.Serializers.IProtoTypeSerializer.Callback(object value, CallbackType callbackType, SerializationContext context)
private object ProtoBuf.Serializers.IProtoTypeSerializer.CreateInstance(ProtoReader source)
public void .ctor(Type type, int key, ISerializerProxy proxy, bool recursionCheck)
private Type ProtoBuf.Serializers.IProtoSerializer.get_ExpectedType()
private bool ProtoBuf.Serializers.IProtoSerializer.get_RequiresOldValue()
private bool ProtoBuf.Serializers.IProtoSerializer.get_ReturnsValue()
private void ProtoBuf.Serializers.IProtoSerializer.Write(object value, ProtoWriter dest)
private object ProtoBuf.Serializers.IProtoSerializer.Read(object value, ProtoReader source)
private bool EmitDedicatedMethod(CompilerContext ctx, Local valueFrom, bool read)
private void ProtoBuf.Serializers.IProtoSerializer.EmitWrite(CompilerContext ctx, Local valueFrom)
private void ProtoBuf.Serializers.IProtoSerializer.EmitRead(CompilerContext ctx, Local valueFrom)
}
internal ProtoBuf.Serializers.SurrogateSerializer : object {
private Type forType
private Type declaredType
private MethodInfo toTail
private MethodInfo fromTail
private IProtoTypeSerializer rootTail
public bool ReturnsValue
public bool RequiresOldValue
public Type ExpectedType
private bool ProtoBuf.Serializers.IProtoTypeSerializer.HasCallbacks(CallbackType callbackType)
private void ProtoBuf.Serializers.IProtoTypeSerializer.EmitCallback(CompilerContext ctx, Local valueFrom, CallbackType callbackType)
private void ProtoBuf.Serializers.IProtoTypeSerializer.EmitCreateInstance(CompilerContext ctx)
private bool ProtoBuf.Serializers.IProtoTypeSerializer.CanCreateInstance()
private object ProtoBuf.Serializers.IProtoTypeSerializer.CreateInstance(ProtoReader source)
private void ProtoBuf.Serializers.IProtoTypeSerializer.Callback(object value, CallbackType callbackType, SerializationContext context)
public bool get_ReturnsValue()
public bool get_RequiresOldValue()
public Type get_ExpectedType()
public void .ctor(Type forType, Type declaredType, IProtoTypeSerializer rootTail)
private bool HasCast(Type type, Type from, Type to, MethodInfo& op)
public MethodInfo GetConversion(bool toTail)
public void Write(object value, ProtoWriter writer)
public object Read(object value, ProtoReader source)
private void ProtoBuf.Serializers.IProtoSerializer.EmitRead(CompilerContext ctx, Local valueFrom)
private void ProtoBuf.Serializers.IProtoSerializer.EmitWrite(CompilerContext ctx, Local valueFrom)
}
internal ProtoBuf.Serializers.SystemTypeSerializer : object {
private Type expectedType
public Type ExpectedType
private bool ProtoBuf.Serializers.IProtoSerializer.RequiresOldValue
private bool ProtoBuf.Serializers.IProtoSerializer.ReturnsValue
public void .ctor(TypeModel model)
public Type get_ExpectedType()
private void ProtoBuf.Serializers.IProtoSerializer.Write(object value, ProtoWriter dest)
private object ProtoBuf.Serializers.IProtoSerializer.Read(object value, ProtoReader source)
private bool ProtoBuf.Serializers.IProtoSerializer.get_RequiresOldValue()
private bool ProtoBuf.Serializers.IProtoSerializer.get_ReturnsValue()
private void ProtoBuf.Serializers.IProtoSerializer.EmitWrite(CompilerContext ctx, Local valueFrom)
private void ProtoBuf.Serializers.IProtoSerializer.EmitRead(CompilerContext ctx, Local valueFrom)
}
internal ProtoBuf.Serializers.TagDecorator : ProtoDecoratorBase {
private bool strict
private int fieldNumber
private WireType wireType
public Type ExpectedType
public bool RequiresOldValue
public bool ReturnsValue
private bool NeedsHint
public bool HasCallbacks(CallbackType callbackType)
public bool CanCreateInstance()
public object CreateInstance(ProtoReader source)
public void Callback(object value, CallbackType callbackType, SerializationContext context)
public void EmitCallback(CompilerContext ctx, Local valueFrom, CallbackType callbackType)
public void EmitCreateInstance(CompilerContext ctx)
public Type get_ExpectedType()
public void .ctor(int fieldNumber, WireType wireType, bool strict, IProtoSerializer tail)
public bool get_RequiresOldValue()
public bool get_ReturnsValue()
private bool get_NeedsHint()
public object Read(object value, ProtoReader source)
public void Write(object value, ProtoWriter dest)
protected void EmitWrite(CompilerContext ctx, Local valueFrom)
protected void EmitRead(CompilerContext ctx, Local valueFrom)
}
internal ProtoBuf.Serializers.TimeSpanSerializer : object {
private Type expectedType
public Type ExpectedType
private bool ProtoBuf.Serializers.IProtoSerializer.RequiresOldValue
private bool ProtoBuf.Serializers.IProtoSerializer.ReturnsValue
public void .ctor(TypeModel model)
public Type get_ExpectedType()
private bool ProtoBuf.Serializers.IProtoSerializer.get_RequiresOldValue()
private bool ProtoBuf.Serializers.IProtoSerializer.get_ReturnsValue()
public object Read(object value, ProtoReader source)
public void Write(object value, ProtoWriter dest)
private void ProtoBuf.Serializers.IProtoSerializer.EmitWrite(CompilerContext ctx, Local valueFrom)
private void ProtoBuf.Serializers.IProtoSerializer.EmitRead(CompilerContext ctx, Local valueFrom)
}
internal ProtoBuf.Serializers.TupleSerializer : object {
private MemberInfo[] members
private ConstructorInfo ctor
private IProtoSerializer[] tails
public Type ExpectedType
public bool RequiresOldValue
public bool ReturnsValue
public void .ctor(RuntimeTypeModel model, ConstructorInfo ctor, MemberInfo[] members)
public bool HasCallbacks(CallbackType callbackType)
public void EmitCallback(CompilerContext ctx, Local valueFrom, CallbackType callbackType)
public Type get_ExpectedType()
private void ProtoBuf.Serializers.IProtoTypeSerializer.Callback(object value, CallbackType callbackType, SerializationContext context)
private object ProtoBuf.Serializers.IProtoTypeSerializer.CreateInstance(ProtoReader source)
private object GetValue(object obj, int index)
public object Read(object value, ProtoReader source)
public void Write(object value, ProtoWriter dest)
public bool get_RequiresOldValue()
public bool get_ReturnsValue()
private Type GetMemberType(int index)
private bool ProtoBuf.Serializers.IProtoTypeSerializer.CanCreateInstance()
public void EmitWrite(CompilerContext ctx, Local valueFrom)
private void ProtoBuf.Serializers.IProtoTypeSerializer.EmitCreateInstance(CompilerContext ctx)
public void EmitRead(CompilerContext ctx, Local incoming)
}
internal ProtoBuf.Serializers.TypeSerializer : object {
private Type forType
private Type constructType
private IProtoSerializer[] serializers
private Int32[] fieldNumbers
private bool isRootType
private bool useConstructor
private bool isExtensible
private bool hasConstructor
private CallbackSet callbacks
private MethodInfo[] baseCtorCallbacks
private MethodInfo factory
private Type iextensible
public Type ExpectedType
private bool CanHaveInheritance
private bool ProtoBuf.Serializers.IProtoSerializer.RequiresOldValue
private bool ProtoBuf.Serializers.IProtoSerializer.ReturnsValue
public bool HasCallbacks(CallbackType callbackType)
public Type get_ExpectedType()
public void .ctor(TypeModel model, Type forType, Int32[] fieldNumbers, IProtoSerializer[] serializers, MethodInfo[] baseCtorCallbacks, bool isRootType, bool useConstructor, CallbackSet callbacks, Type constructType, MethodInfo factory)
private bool get_CanHaveInheritance()
private bool ProtoBuf.Serializers.IProtoTypeSerializer.CanCreateInstance()
private object ProtoBuf.Serializers.IProtoTypeSerializer.CreateInstance(ProtoReader source)
public void Callback(object value, CallbackType callbackType, SerializationContext context)
private IProtoSerializer GetMoreSpecificSerializer(object value)
public void Write(object value, ProtoWriter dest)
public object Read(object value, ProtoReader source)
private object InvokeCallback(MethodInfo method, object obj, SerializationContext context)
private object CreateInstance(ProtoReader source, bool includeLocalCallback)
private bool ProtoBuf.Serializers.IProtoSerializer.get_RequiresOldValue()
private bool ProtoBuf.Serializers.IProtoSerializer.get_ReturnsValue()
private void ProtoBuf.Serializers.IProtoSerializer.EmitWrite(CompilerContext ctx, Local valueFrom)
private void EmitInvokeCallback(CompilerContext ctx, MethodInfo method, bool copyValue, Type constructType, Type type)
private void EmitCallbackIfNeeded(CompilerContext ctx, Local valueFrom, CallbackType callbackType)
private void ProtoBuf.Serializers.IProtoTypeSerializer.EmitCallback(CompilerContext ctx, Local valueFrom, CallbackType callbackType)
private void ProtoBuf.Serializers.IProtoSerializer.EmitRead(CompilerContext ctx, Local valueFrom)
private void WriteFieldHandler(CompilerContext ctx, Type expected, Local loc, CodeLabel handler, CodeLabel continue, IProtoSerializer serializer)
private void ProtoBuf.Serializers.IProtoTypeSerializer.EmitCreateInstance(CompilerContext ctx)
private void EmitCreateIfNull(CompilerContext ctx, Local storage)
}
internal ProtoBuf.Serializers.UInt16Serializer : object {
private Type expectedType
public Type ExpectedType
private bool ProtoBuf.Serializers.IProtoSerializer.RequiresOldValue
private bool ProtoBuf.Serializers.IProtoSerializer.ReturnsValue
public void .ctor(TypeModel model)
public Type get_ExpectedType()
private bool ProtoBuf.Serializers.IProtoSerializer.get_RequiresOldValue()
private bool ProtoBuf.Serializers.IProtoSerializer.get_ReturnsValue()
public object Read(object value, ProtoReader source)
public void Write(object value, ProtoWriter dest)
private void ProtoBuf.Serializers.IProtoSerializer.EmitWrite(CompilerContext ctx, Local valueFrom)
private void ProtoBuf.Serializers.IProtoSerializer.EmitRead(CompilerContext ctx, Local valueFrom)
}
internal ProtoBuf.Serializers.UInt32Serializer : object {
private Type expectedType
public Type ExpectedType
private bool ProtoBuf.Serializers.IProtoSerializer.RequiresOldValue
private bool ProtoBuf.Serializers.IProtoSerializer.ReturnsValue
public void .ctor(TypeModel model)
public Type get_ExpectedType()
private bool ProtoBuf.Serializers.IProtoSerializer.get_RequiresOldValue()
private bool ProtoBuf.Serializers.IProtoSerializer.get_ReturnsValue()
public object Read(object value, ProtoReader source)
public void Write(object value, ProtoWriter dest)
private void ProtoBuf.Serializers.IProtoSerializer.EmitWrite(CompilerContext ctx, Local valueFrom)
private void ProtoBuf.Serializers.IProtoSerializer.EmitRead(CompilerContext ctx, Local valueFrom)
}
internal ProtoBuf.Serializers.UInt64Serializer : object {
private Type expectedType
public Type ExpectedType
private bool ProtoBuf.Serializers.IProtoSerializer.RequiresOldValue
private bool ProtoBuf.Serializers.IProtoSerializer.ReturnsValue
public void .ctor(TypeModel model)
public Type get_ExpectedType()
private bool ProtoBuf.Serializers.IProtoSerializer.get_RequiresOldValue()
private bool ProtoBuf.Serializers.IProtoSerializer.get_ReturnsValue()
public object Read(object value, ProtoReader source)
public void Write(object value, ProtoWriter dest)
private void ProtoBuf.Serializers.IProtoSerializer.EmitWrite(CompilerContext ctx, Local valueFrom)
private void ProtoBuf.Serializers.IProtoSerializer.EmitRead(CompilerContext ctx, Local valueFrom)
}
internal ProtoBuf.Serializers.UriDecorator : ProtoDecoratorBase {
private Type expectedType
public Type ExpectedType
public bool RequiresOldValue
public bool ReturnsValue
public void .ctor(TypeModel model, IProtoSerializer tail)
public Type get_ExpectedType()
public bool get_RequiresOldValue()
public bool get_ReturnsValue()
public void Write(object value, ProtoWriter dest)
public object Read(object value, ProtoReader source)
protected void EmitWrite(CompilerContext ctx, Local valueFrom)
protected void EmitRead(CompilerContext ctx, Local valueFrom)
}
public ProtoBuf.SubItemToken : ValueType {
internal int value
internal void .ctor(int value)
}
internal ProtoBuf.TimeSpanScale : Enum {
public int value__
public TimeSpanScale Days
public TimeSpanScale Hours
public TimeSpanScale Minutes
public TimeSpanScale Seconds
public TimeSpanScale Milliseconds
public TimeSpanScale Ticks
public TimeSpanScale MinMax
}
public ProtoBuf.WireType : Enum {
public int value__
public WireType None
public WireType Variant
public WireType Fixed64
public WireType String
public WireType StartGroup
public WireType EndGroup
public WireType Fixed32
public WireType SignedVariant
}
public WebSocketSharp.ByteOrder : Enum {
public int value__
public ByteOrder Little
public ByteOrder Big
}
public WebSocketSharp.CloseEventArgs : EventArgs {
private bool _clean
private PayloadData _payloadData
internal PayloadData PayloadData
public ushort Code
public string Reason
public bool WasClean
internal void .ctor(ushort code)
internal void .ctor(CloseStatusCode code)
internal void .ctor(PayloadData payloadData)
internal void .ctor(ushort code, string reason)
internal void .ctor(CloseStatusCode code, string reason)
internal PayloadData get_PayloadData()
public ushort get_Code()
public string get_Reason()
public bool get_WasClean()
internal void set_WasClean(bool value)
}
public WebSocketSharp.CloseStatusCode : Enum {
public ushort value__
public CloseStatusCode Normal
public CloseStatusCode Away
public CloseStatusCode ProtocolError
public CloseStatusCode UnsupportedData
public CloseStatusCode Undefined
public CloseStatusCode NoStatus
public CloseStatusCode Abnormal
public CloseStatusCode InvalidData
public CloseStatusCode PolicyViolation
public CloseStatusCode TooBig
public CloseStatusCode MandatoryExtension
public CloseStatusCode ServerError
public CloseStatusCode TlsHandshakeFailure
}
public WebSocketSharp.CompressionMethod : Enum {
public byte value__
public CompressionMethod None
public CompressionMethod Deflate
}
public WebSocketSharp.ErrorEventArgs : EventArgs {
private Exception _exception
private string _message
public Exception Exception
public string Message
internal void .ctor(string message)
internal void .ctor(string message, Exception exception)
public Exception get_Exception()
public string get_Message()
}
public WebSocketSharp.Ext : object {
private Byte[] _last
private int _retry
private string _tspecials
private Byte[] compress(Byte[] data)
private MemoryStream compress(Stream stream)
private Byte[] compressToArray(Stream stream)
private Byte[] decompress(Byte[] data)
private MemoryStream decompress(Stream stream)
private Byte[] decompressToArray(Stream stream)
private void times(ulong n, Action action)
internal Byte[] Append(ushort code, string reason)
internal string CheckIfAvailable(ServerState state, bool ready, bool start, bool shutting)
internal string CheckIfAvailable(WebSocketState state, bool connecting, bool open, bool closing, bool closed)
internal string CheckIfValidProtocols(String[] protocols)
internal string CheckIfValidServicePath(string path)
internal string CheckIfValidSessionID(string id)
internal string CheckIfValidWaitTime(TimeSpan time)
internal bool CheckWaitTime(TimeSpan time, String& message)
internal void Close(HttpListenerResponse response, HttpStatusCode code)
internal void CloseWithAuthChallenge(HttpListenerResponse response, string challenge)
internal Byte[] Compress(Byte[] data, CompressionMethod method)
internal Stream Compress(Stream stream, CompressionMethod method)
internal Byte[] CompressToArray(Stream stream, CompressionMethod method)
internal bool Contains(IEnumerable`1<T> source, Func`2<T, bool> condition)
internal bool ContainsTwice(String[] values)
internal T[] Copy(T[] source, long length)
internal void CopyTo(Stream source, Stream destination, int bufferLength)
internal void CopyToAsync(Stream source, Stream destination, int bufferLength, Action completed, Action`1<Exception> error)
internal Byte[] Decompress(Byte[] data, CompressionMethod method)
internal Stream Decompress(Stream stream, CompressionMethod method)
internal Byte[] DecompressToArray(Stream stream, CompressionMethod method)
internal bool EqualsWith(int value, char c, Action`1<int> action)
internal string GetAbsolutePath(Uri uri)
internal string GetMessage(CloseStatusCode code)
internal string GetName(string nameAndValue, char separator)
internal string GetValue(string nameAndValue, char separator)
internal string GetValue(string nameAndValue, char separator, bool unquote)
internal TcpListenerWebSocketContext GetWebSocketContext(TcpClient tcpClient, string protocol, bool secure, ServerSslConfiguration sslConfig, Logger logger)
internal Byte[] InternalToByteArray(ushort value, ByteOrder order)
internal Byte[] InternalToByteArray(ulong value, ByteOrder order)
internal bool IsCompressionExtension(string value, CompressionMethod method)
internal bool IsControl(byte opcode)
internal bool IsControl(Opcode opcode)
internal bool IsData(byte opcode)
internal bool IsData(Opcode opcode)
internal bool IsPortNumber(int value)
internal bool IsReserved(ushort code)
internal bool IsReserved(CloseStatusCode code)
internal bool IsSupported(byte opcode)
internal bool IsText(string value)
internal bool IsToken(string value)
internal string Quote(string value)
internal Byte[] ReadBytes(Stream stream, int length)
internal Byte[] ReadBytes(Stream stream, long length, int bufferLength)
internal void ReadBytesAsync(Stream stream, int length, Action`1<Byte[]> completed, Action`1<Exception> error)
internal void ReadBytesAsync(Stream stream, long length, int bufferLength, Action`1<Byte[]> completed, Action`1<Exception> error)
internal string RemovePrefix(string value, String[] prefixes)
internal T[] Reverse(T[] array)
internal IEnumerable`1<string> SplitHeaderValue(string value, Char[] separators)
internal Byte[] ToByteArray(Stream stream)
internal CompressionMethod ToCompressionMethod(string value)
internal string ToExtensionString(CompressionMethod method, String[] parameters)
internal IPAddress ToIPAddress(string hostnameOrAddress)
internal List`1<TSource> ToList(IEnumerable`1<TSource> source)
internal ushort ToUInt16(Byte[] source, ByteOrder sourceOrder)
internal ulong ToUInt64(Byte[] source, ByteOrder sourceOrder)
internal string TrimEndSlash(string value)
internal bool TryCreateWebSocketUri(string uriString, Uri& result, String& message)
internal string Unquote(string value)
internal string UTF8Decode(Byte[] bytes)
internal Byte[] UTF8Encode(string s)
internal void WriteBytes(Stream stream, Byte[] bytes, int bufferLength)
internal void WriteBytesAsync(Stream stream, Byte[] bytes, int bufferLength, Action completed, Action`1<Exception> error)
public bool Contains(string value, Char[] chars)
public bool Contains(NameValueCollection collection, string name)
public bool Contains(NameValueCollection collection, string name, string value)
public void Emit(EventHandler eventHandler, object sender, EventArgs e)
public void Emit(EventHandler`1<TEventArgs> eventHandler, object sender, TEventArgs e)
public CookieCollection GetCookies(NameValueCollection headers, bool response)
public string GetDescription(HttpStatusCode code)
public string GetStatusDescription(int code)
public bool IsCloseStatusCode(ushort value)
public bool IsEnclosedIn(string value, char c)
public bool IsHostOrder(ByteOrder order)
public bool IsLocal(IPAddress address)
public bool IsNullOrEmpty(string value)
public bool IsPredefinedScheme(string value)
public bool IsUpgradeTo(HttpListenerRequest request, string protocol)
public bool MaybeUri(string value)
public T[] SubArray(T[] array, int startIndex, int length)
public T[] SubArray(T[] array, long startIndex, long length)
public void Times(int n, Action action)
public void Times(long n, Action action)
public void Times(UInt32 n, Action action)
public void Times(ulong n, Action action)
public void Times(int n, Action`1<int> action)
public void Times(long n, Action`1<long> action)
public void Times(UInt32 n, Action`1<UInt32> action)
public void Times(ulong n, Action`1<ulong> action)
public T To(Byte[] source, ByteOrder sourceOrder)
public Byte[] ToByteArray(T value, ByteOrder order)
public Byte[] ToHostOrder(Byte[] source, ByteOrder sourceOrder)
public string ToString(T[] array, string separator)
public Uri ToUri(string uriString)
public string UrlDecode(string value)
public string UrlEncode(string value)
public void WriteContent(HttpListenerResponse response, Byte[] content)
}
internal WebSocketSharp.Fin : Enum {
public byte value__
public Fin More
public Fin Final
}
internal WebSocketSharp.HttpBase : object {
private NameValueCollection _headers
private int _headersMaxLength
private Version _version
internal Byte[] EntityBodyData
protected string CrLf
public string EntityBody
public NameValueCollection Headers
public Version ProtocolVersion
protected void .ctor(Version version, NameValueCollection headers)
public string get_EntityBody()
public NameValueCollection get_Headers()
public Version get_ProtocolVersion()
private Byte[] readEntityBody(Stream stream, string length)
private String[] readHeaders(Stream stream, int maxLength)
protected T Read(Stream stream, Func`2<String[], T> parser, int millisecondsTimeout)
public Byte[] ToByteArray()
}
internal WebSocketSharp.HttpRequest : HttpBase {
private string _method
private string _uri
private bool _websocketRequest
private bool _websocketRequestSet
public AuthenticationResponse AuthenticationResponse
public CookieCollection Cookies
public string HttpMethod
public bool IsWebSocketRequest
public string RequestUri
private void .ctor(string method, string uri, Version version, NameValueCollection headers)
internal void .ctor(string method, string uri)
public AuthenticationResponse get_AuthenticationResponse()
public CookieCollection get_Cookies()
public string get_HttpMethod()
public bool get_IsWebSocketRequest()
public string get_RequestUri()
internal HttpRequest CreateConnectRequest(Uri uri)
internal HttpRequest CreateWebSocketRequest(Uri uri)
internal HttpResponse GetResponse(Stream stream, int millisecondsTimeout)
internal HttpRequest Parse(String[] headerParts)
internal HttpRequest Read(Stream stream, int millisecondsTimeout)
public void SetCookies(CookieCollection cookies)
public string ToString()
}
internal WebSocketSharp.HttpResponse : HttpBase {
private string _code
private string _reason
public CookieCollection Cookies
public bool HasConnectionClose
public bool IsProxyAuthenticationRequired
public bool IsRedirect
public bool IsUnauthorized
public bool IsWebSocketResponse
public string Reason
public string StatusCode
private void .ctor(string code, string reason, Version version, NameValueCollection headers)
internal void .ctor(HttpStatusCode code)
internal void .ctor(HttpStatusCode code, string reason)
public CookieCollection get_Cookies()
public bool get_HasConnectionClose()
public bool get_IsProxyAuthenticationRequired()
public bool get_IsRedirect()
public bool get_IsUnauthorized()
public bool get_IsWebSocketResponse()
public string get_Reason()
public string get_StatusCode()
internal HttpResponse CreateCloseResponse(HttpStatusCode code)
internal HttpResponse CreateUnauthorizedResponse(string challenge)
internal HttpResponse CreateWebSocketResponse()
internal HttpResponse Parse(String[] headerParts)
internal HttpResponse Read(Stream stream, int millisecondsTimeout)
public void SetCookies(CookieCollection cookies)
public string ToString()
}
public WebSocketSharp.LogData : object {
private StackFrame _caller
private DateTime _date
private LogLevel _level
private string _message
public StackFrame Caller
public DateTime Date
public LogLevel Level
public string Message
internal void .ctor(LogLevel level, StackFrame caller, string message)
public StackFrame get_Caller()
public DateTime get_Date()
public LogLevel get_Level()
public string get_Message()
public string ToString()
}
public WebSocketSharp.Logger : object {
private String modreq(System.Runtime.CompilerServices.IsVolatile) _file
private LogLevel modreq(System.Runtime.CompilerServices.IsVolatile) _level
private Action`2<LogData, string> _output
private object _sync
public string File
public LogLevel Level
public Action`2<LogData, string> Output
public void .ctor(LogLevel level)
public void .ctor(LogLevel level, string file, Action`2<LogData, string> output)
public string get_File()
public void set_File(string value)
public LogLevel get_Level()
public void set_Level(LogLevel value)
public Action`2<LogData, string> get_Output()
public void set_Output(Action`2<LogData, string> value)
private void defaultOutput(LogData data, string path)
private void output(string message, LogLevel level)
private void writeToFile(string value, string path)
public void Debug(string message)
public void Error(string message)
public void Fatal(string message)
public void Info(string message)
public void Trace(string message)
public void Warn(string message)
}
public WebSocketSharp.LogLevel : Enum {
public int value__
public LogLevel Trace
public LogLevel Debug
public LogLevel Info
public LogLevel Warn
public LogLevel Error
public LogLevel Fatal
}
internal WebSocketSharp.Mask : Enum {
public byte value__
public Mask Off
public Mask On
}
public WebSocketSharp.MessageEventArgs : EventArgs {
private string _data
private bool _dataSet
private Opcode _opcode
private Byte[] _rawData
internal Opcode Opcode
public string Data
public bool IsBinary
public bool IsPing
public bool IsText
public bool IsClose
public Byte[] RawData
internal void .ctor(WebSocketFrame frame)
internal void .ctor(Opcode opcode, Byte[] rawData)
internal Opcode get_Opcode()
public string get_Data()
public bool get_IsBinary()
public bool get_IsPing()
public bool get_IsText()
public bool get_IsClose()
public Byte[] get_RawData()
}
internal WebSocketSharp.Net.AuthenticationBase : object {
private AuthenticationSchemes _scheme
internal NameValueCollection Parameters
public string Algorithm
public string Nonce
public string Opaque
public string Qop
public string Realm
public AuthenticationSchemes Scheme
protected void .ctor(AuthenticationSchemes scheme, NameValueCollection parameters)
public string get_Algorithm()
public string get_Nonce()
public string get_Opaque()
public string get_Qop()
public string get_Realm()
public AuthenticationSchemes get_Scheme()
internal string CreateNonceValue()
internal NameValueCollection ParseParameters(string value)
internal string ToBasicString()
internal string ToDigestString()
public string ToString()
}
internal WebSocketSharp.Net.AuthenticationChallenge : AuthenticationBase {
public string Domain
public string Stale
private void .ctor(AuthenticationSchemes scheme, NameValueCollection parameters)
internal void .ctor(AuthenticationSchemes scheme, string realm)
public string get_Domain()
public string get_Stale()
internal AuthenticationChallenge CreateBasicChallenge(string realm)
internal AuthenticationChallenge CreateDigestChallenge(string realm)
internal AuthenticationChallenge Parse(string value)
internal string ToBasicString()
internal string ToDigestString()
}
internal WebSocketSharp.Net.AuthenticationResponse : AuthenticationBase {
private UInt32 _nonceCount
internal UInt32 NonceCount
public string Cnonce
public string Nc
public string Password
public string Response
public string Uri
public string UserName
private void .ctor(AuthenticationSchemes scheme, NameValueCollection parameters)
internal void .ctor(NetworkCredential credentials)
internal void .ctor(AuthenticationChallenge challenge, NetworkCredential credentials, UInt32 nonceCount)
internal void .ctor(AuthenticationSchemes scheme, NameValueCollection parameters, NetworkCredential credentials, UInt32 nonceCount)
internal UInt32 get_NonceCount()
public string get_Cnonce()
public string get_Nc()
public string get_Password()
public string get_Response()
public string get_Uri()
public string get_UserName()
private string createA1(string username, string password, string realm)
private string createA1(string username, string password, string realm, string nonce, string cnonce)
private string createA2(string method, string uri)
private string createA2(string method, string uri, string entity)
private string hash(string value)
private void initAsDigest()
internal string CreateRequestDigest(NameValueCollection parameters)
internal AuthenticationResponse Parse(string value)
internal NameValueCollection ParseBasicCredentials(string value)
internal string ToBasicString()
internal string ToDigestString()
public IIdentity ToIdentity()
}
public WebSocketSharp.Net.AuthenticationSchemes : Enum {
public int value__
public AuthenticationSchemes None
public AuthenticationSchemes Digest
public AuthenticationSchemes Basic
public AuthenticationSchemes Anonymous
}
internal WebSocketSharp.Net.Chunk : object {
private Byte[] _data
private int _offset
public int ReadLeft
public void .ctor(Byte[] data)
public int get_ReadLeft()
public int Read(Byte[] buffer, int offset, int count)
}
internal WebSocketSharp.Net.ChunkedRequestStream : RequestStream {
private int _bufferLength
private HttpListenerContext _context
private ChunkStream _decoder
private bool _disposed
private bool _noMoreData
internal ChunkStream Decoder
internal void .ctor(Stream stream, Byte[] buffer, int offset, int count, HttpListenerContext context)
internal ChunkStream get_Decoder()
internal void set_Decoder(ChunkStream value)
private void onRead(IAsyncResult asyncResult)
public IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state)
public void Close()
public int EndRead(IAsyncResult asyncResult)
public int Read(Byte[] buffer, int offset, int count)
}
internal WebSocketSharp.Net.ChunkStream : object {
private int _chunkRead
private int _chunkSize
private List`1<Chunk> _chunks
private bool _gotIt
private WebHeaderCollection _headers
private StringBuilder _saved
private bool _sawCr
private InputChunkState _state
private int _trailerState
internal WebHeaderCollection Headers
public int ChunkLeft
public bool WantMore
public void .ctor(WebHeaderCollection headers)
public void .ctor(Byte[] buffer, int offset, int count, WebHeaderCollection headers)
internal WebHeaderCollection get_Headers()
public int get_ChunkLeft()
public bool get_WantMore()
private int read(Byte[] buffer, int offset, int count)
private string removeChunkExtension(string value)
private InputChunkState seekCrLf(Byte[] buffer, Int32& offset, int length)
private InputChunkState setChunkSize(Byte[] buffer, Int32& offset, int length)
private InputChunkState setTrailer(Byte[] buffer, Int32& offset, int length)
private void throwProtocolViolation(string message)
private void write(Byte[] buffer, Int32& offset, int length)
private InputChunkState writeData(Byte[] buffer, Int32& offset, int length)
internal void ResetBuffer()
internal int WriteAndReadBack(Byte[] buffer, int offset, int writeCount, int readCount)
public int Read(Byte[] buffer, int offset, int count)
public void Write(Byte[] buffer, int offset, int count)
}
public WebSocketSharp.Net.ClientSslConfiguration : SslConfiguration {
private X509CertificateCollection _certs
private string _host
public X509CertificateCollection ClientCertificates
public LocalCertificateSelectionCallback ClientCertificateSelectionCallback
public RemoteCertificateValidationCallback ServerCertificateValidationCallback
public string TargetHost
public void .ctor(string targetHost)
public void .ctor(string targetHost, X509CertificateCollection clientCertificates, SslProtocols enabledSslProtocols, bool checkCertificateRevocation)
public X509CertificateCollection get_ClientCertificates()
public void set_ClientCertificates(X509CertificateCollection value)
public LocalCertificateSelectionCallback get_ClientCertificateSelectionCallback()
public void set_ClientCertificateSelectionCallback(LocalCertificateSelectionCallback value)
public RemoteCertificateValidationCallback get_ServerCertificateValidationCallback()
public void set_ServerCertificateValidationCallback(RemoteCertificateValidationCallback value)
public string get_TargetHost()
public void set_TargetHost(string value)
}
public WebSocketSharp.Net.Cookie : object {
private string _comment
private Uri _commentUri
private bool _discard
private string _domain
private DateTime _expires
private bool _httpOnly
private string _name
private string _path
private string _port
private Int32[] _ports
private Char[] _reservedCharsForName
private Char[] _reservedCharsForValue
private bool _secure
private DateTime _timestamp
private string _value
private int _version
private bool <ExactDomain>k__BackingField
internal bool ExactDomain
internal int MaxAge
internal Int32[] Ports
public string Comment
public Uri CommentUri
public bool Discard
public string Domain
public bool Expired
public DateTime Expires
public bool HttpOnly
public string Name
public string Path
public string Port
public bool Secure
public DateTime TimeStamp
public string Value
public int Version
public void .ctor(string name, string value)
public void .ctor(string name, string value, string path)
public void .ctor(string name, string value, string path, string domain)
internal bool get_ExactDomain()
internal void set_ExactDomain(bool value)
internal int get_MaxAge()
internal Int32[] get_Ports()
public string get_Comment()
public void set_Comment(string value)
public Uri get_CommentUri()
public void set_CommentUri(Uri value)
public bool get_Discard()
public void set_Discard(bool value)
public string get_Domain()
public void set_Domain(string value)
public bool get_Expired()
public void set_Expired(bool value)
public DateTime get_Expires()
public void set_Expires(DateTime value)
public bool get_HttpOnly()
public void set_HttpOnly(bool value)
public string get_Name()
public void set_Name(string value)
public string get_Path()
public void set_Path(string value)
public string get_Port()
public void set_Port(string value)
public bool get_Secure()
public void set_Secure(bool value)
public DateTime get_TimeStamp()
public string get_Value()
public void set_Value(string value)
public int get_Version()
public void set_Version(int value)
private bool canSetName(string name, String& message)
private bool canSetValue(string value, String& message)
private int hash(int i, int j, int k, int l, int m)
private string toResponseStringVersion0()
private string toResponseStringVersion1()
private bool tryCreatePorts(string value, Int32[]& result, String& parseError)
internal string ToRequestString(Uri uri)
internal string ToResponseString()
public bool Equals(object comparand)
public int GetHashCode()
public string ToString()
}
public WebSocketSharp.Net.CookieCollection : object {
private List`1<Cookie> _list
private object _sync
internal IList`1<Cookie> List
internal IEnumerable`1<Cookie> Sorted
public int Count
public bool IsReadOnly
public bool IsSynchronized
public Cookie Item
public Cookie Item
public object SyncRoot
internal IList`1<Cookie> get_List()
internal IEnumerable`1<Cookie> get_Sorted()
public int get_Count()
public bool get_IsReadOnly()
public bool get_IsSynchronized()
public Cookie get_Item(int index)
public Cookie get_Item(string name)
public object get_SyncRoot()
private int compareCookieWithinSort(Cookie x, Cookie y)
private int compareCookieWithinSorted(Cookie x, Cookie y)
private CookieCollection parseRequest(string value)
private CookieCollection parseResponse(string value)
private int searchCookie(Cookie cookie)
private String[] splitCookieHeaderValue(string value)
internal CookieCollection Parse(string value, bool response)
internal void SetOrRemove(Cookie cookie)
internal void SetOrRemove(CookieCollection cookies)
internal void Sort()
public void Add(Cookie cookie)
public void Add(CookieCollection cookies)
public void CopyTo(Array array, int index)
public void CopyTo(Cookie[] array, int index)
public IEnumerator GetEnumerator()
}
public WebSocketSharp.Net.CookieException : FormatException {
internal void .ctor(string message)
internal void .ctor(string message, Exception innerException)
protected void .ctor(SerializationInfo serializationInfo, StreamingContext streamingContext)
public void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext)
private void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext)
}
internal WebSocketSharp.Net.EndPointListener : object {
private List`1<HttpListenerPrefix> _all
private string _defaultCertFolderPath
private IPEndPoint _endpoint
private Dictionary`2<HttpListenerPrefix, HttpListener> _prefixes
private bool _secure
private Socket _socket
private ServerSslConfiguration _sslConfig
private List`1<HttpListenerPrefix> _unhandled
private Dictionary`2<HttpConnection, HttpConnection> _unregistered
private object _unregisteredSync
public IPAddress Address
public bool IsSecure
public int Port
public ServerSslConfiguration SslConfiguration
internal void .ctor(IPEndPoint endpoint, bool secure, string certificateFolderPath, ServerSslConfiguration sslConfig, bool reuseAddress)
public IPAddress get_Address()
public bool get_IsSecure()
public int get_Port()
public ServerSslConfiguration get_SslConfiguration()
private void addSpecial(List`1<HttpListenerPrefix> prefixes, HttpListenerPrefix prefix)
private RSACryptoServiceProvider createRSAFromFile(string filename)
private X509Certificate2 getCertificate(int port, string folderPath, X509Certificate2 defaultCertificate)
private void leaveIfNoPrefix()
private void onAccept(IAsyncResult asyncResult)
private void processAccepted(Socket socket, EndPointListener listener)
private bool removeSpecial(List`1<HttpListenerPrefix> prefixes, HttpListenerPrefix prefix)
private HttpListener searchHttpListenerFromSpecial(string path, List`1<HttpListenerPrefix> prefixes)
internal bool CertificateExists(int port, string folderPath)
internal void RemoveConnection(HttpConnection connection)
internal bool TrySearchHttpListener(Uri uri, HttpListener& listener)
public void AddPrefix(HttpListenerPrefix prefix, HttpListener listener)
public void Close()
public void RemovePrefix(HttpListenerPrefix prefix, HttpListener listener)
}
internal WebSocketSharp.Net.EndPointManager : object {
private Dictionary`2<IPEndPoint, EndPointListener> _endpoints
private void addPrefix(string uriPrefix, HttpListener listener)
private IPAddress convertToIPAddress(string hostname)
private void removePrefix(string uriPrefix, HttpListener listener)
internal bool RemoveEndPoint(IPEndPoint endpoint)
public void AddListener(HttpListener listener)
public void AddPrefix(string uriPrefix, HttpListener listener)
public void RemoveListener(HttpListener listener)
public void RemovePrefix(string uriPrefix, HttpListener listener)
}
public WebSocketSharp.Net.HttpBasicIdentity : GenericIdentity {
private string _password
public string Password
internal void .ctor(string username, string password)
public string get_Password()
}
internal WebSocketSharp.Net.HttpConnection : object {
private Byte[] _buffer
private int _bufferLength
private HttpListenerContext _context
private bool _contextRegistered
private StringBuilder _currentLine
private InputState _inputState
private RequestStream _inputStream
private HttpListener _lastListener
private LineState _lineState
private EndPointListener _listener
private ResponseStream _outputStream
private int _position
private MemoryStream _requestBuffer
private int _reuses
private bool _secure
private Socket _socket
private Stream _stream
private object _sync
private int _timeout
private Dictionary`2<int, bool> _timeoutCanceled
private Timer _timer
public bool IsClosed
public bool IsSecure
public IPEndPoint LocalEndPoint
public IPEndPoint RemoteEndPoint
public int Reuses
public Stream Stream
internal void .ctor(Socket socket, EndPointListener listener)
public bool get_IsClosed()
public bool get_IsSecure()
public IPEndPoint get_LocalEndPoint()
public IPEndPoint get_RemoteEndPoint()
public int get_Reuses()
public Stream get_Stream()
private void close()
private void closeSocket()
private void disposeRequestBuffer()
private void disposeStream()
private void disposeTimer()
private void init()
private void onRead(IAsyncResult asyncResult)
private void onTimeout(object state)
private bool processInput(Byte[] data, int length)
private string readLineFrom(Byte[] buffer, int offset, int length, Int32& read)
private void removeConnection()
private void unregisterContext()
internal void Close(bool force)
public void BeginReadRequest()
public void Close()
public RequestStream GetRequestStream(long contentLength, bool chunked)
public ResponseStream GetResponseStream()
public void SendError()
public void SendError(string message, int status)
}
public WebSocketSharp.Net.HttpDigestIdentity : GenericIdentity {
private NameValueCollection _parameters
public string Algorithm
public string Cnonce
public string Nc
public string Nonce
public string Opaque
public string Qop
public string Realm
public string Response
public string Uri
internal void .ctor(NameValueCollection parameters)
public string get_Algorithm()
public string get_Cnonce()
public string get_Nc()
public string get_Nonce()
public string get_Opaque()
public string get_Qop()
public string get_Realm()
public string get_Response()
public string get_Uri()
internal bool IsValid(string password, string realm, string method, string entity)
}
internal WebSocketSharp.Net.HttpHeaderInfo : object {
private string _name
private HttpHeaderType _type
internal bool IsMultiValueInRequest
internal bool IsMultiValueInResponse
public bool IsRequest
public bool IsResponse
public string Name
public HttpHeaderType Type
internal void .ctor(string name, HttpHeaderType type)
internal bool get_IsMultiValueInRequest()
internal bool get_IsMultiValueInResponse()
public bool get_IsRequest()
public bool get_IsResponse()
public string get_Name()
public HttpHeaderType get_Type()
public bool IsMultiValue(bool response)
public bool IsRestricted(bool response)
}
internal WebSocketSharp.Net.HttpHeaderType : Enum {
public int value__
public HttpHeaderType Unspecified
public HttpHeaderType Request
public HttpHeaderType Response
public HttpHeaderType Restricted
public HttpHeaderType MultiValue
public HttpHeaderType MultiValueInRequest
public HttpHeaderType MultiValueInResponse
}
public WebSocketSharp.Net.HttpListener : object {
private AuthenticationSchemes _authSchemes
private Func`2<HttpListenerRequest, AuthenticationSchemes> _authSchemeSelector
private string _certFolderPath
private Dictionary`2<HttpConnection, HttpConnection> _connections
private object _connectionsSync
private List`1<HttpListenerContext> _ctxQueue
private object _ctxQueueSync
private Dictionary`2<HttpListenerContext, HttpListenerContext> _ctxRegistry
private object _ctxRegistrySync
private string _defaultRealm
private bool _disposed
private bool _ignoreWriteExceptions
private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _listening
private Logger _logger
private HttpListenerPrefixCollection _prefixes
private string _realm
private bool _reuseAddress
private ServerSslConfiguration _sslConfig
private Func`2<IIdentity, NetworkCredential> _userCredFinder
private List`1<HttpListenerAsyncResult> _waitQueue
private object _waitQueueSync
internal bool IsDisposed
internal bool ReuseAddress
public AuthenticationSchemes AuthenticationSchemes
public Func`2<HttpListenerRequest, AuthenticationSchemes> AuthenticationSchemeSelector
public string CertificateFolderPath
public bool IgnoreWriteExceptions
public bool IsListening
public bool IsSupported
public Logger Log
public HttpListenerPrefixCollection Prefixes
public string Realm
public ServerSslConfiguration SslConfiguration
public bool UnsafeConnectionNtlmAuthentication
public Func`2<IIdentity, NetworkCredential> UserCredentialsFinder
internal bool get_IsDisposed()
internal bool get_ReuseAddress()
internal void set_ReuseAddress(bool value)
public AuthenticationSchemes get_AuthenticationSchemes()
public void set_AuthenticationSchemes(AuthenticationSchemes value)
public Func`2<HttpListenerRequest, AuthenticationSchemes> get_AuthenticationSchemeSelector()
public void set_AuthenticationSchemeSelector(Func`2<HttpListenerRequest, AuthenticationSchemes> value)
public string get_CertificateFolderPath()
public void set_CertificateFolderPath(string value)
public bool get_IgnoreWriteExceptions()
public void set_IgnoreWriteExceptions(bool value)
public bool get_IsListening()
public bool get_IsSupported()
public Logger get_Log()
public HttpListenerPrefixCollection get_Prefixes()
public string get_Realm()
public void set_Realm(string value)
public ServerSslConfiguration get_SslConfiguration()
public void set_SslConfiguration(ServerSslConfiguration value)
public bool get_UnsafeConnectionNtlmAuthentication()
public void set_UnsafeConnectionNtlmAuthentication(bool value)
public Func`2<IIdentity, NetworkCredential> get_UserCredentialsFinder()
public void set_UserCredentialsFinder(Func`2<IIdentity, NetworkCredential> value)
private void cleanupConnections()
private void cleanupContextQueue(bool sendServiceUnavailable)
private void cleanupContextRegistry()
private void cleanupWaitQueue(Exception exception)
private void close(bool force)
private HttpListenerAsyncResult getAsyncResultFromQueue()
private HttpListenerContext getContextFromQueue()
internal bool AddConnection(HttpConnection connection)
internal HttpListenerAsyncResult BeginGetContext(HttpListenerAsyncResult asyncResult)
internal void CheckDisposed()
internal string GetRealm()
internal Func`2<IIdentity, NetworkCredential> GetUserCredentialsFinder()
internal bool RegisterContext(HttpListenerContext context)
internal void RemoveConnection(HttpConnection connection)
internal AuthenticationSchemes SelectAuthenticationScheme(HttpListenerRequest request)
internal void UnregisterContext(HttpListenerContext context)
public void Abort()
public IAsyncResult BeginGetContext(AsyncCallback callback, object state)
public void Close()
public HttpListenerContext EndGetContext(IAsyncResult asyncResult)
public HttpListenerContext GetContext()
public void Start()
public void Stop()
private void System.IDisposable.Dispose()
}
internal WebSocketSharp.Net.HttpListenerAsyncResult : object {
private AsyncCallback _callback
private bool _completed
private HttpListenerContext _context
private bool _endCalled
private Exception _exception
private bool _inGet
private object _state
private object _sync
private bool _syncCompleted
private ManualResetEvent _waitHandle
internal bool EndCalled
internal bool InGet
public object AsyncState
public WaitHandle AsyncWaitHandle
public bool CompletedSynchronously
public bool IsCompleted
internal void .ctor(AsyncCallback callback, object state)
internal bool get_EndCalled()
internal void set_EndCalled(bool value)
internal bool get_InGet()
internal void set_InGet(bool value)
public object get_AsyncState()
public WaitHandle get_AsyncWaitHandle()
public bool get_CompletedSynchronously()
public bool get_IsCompleted()
private void complete(HttpListenerAsyncResult asyncResult)
internal void Complete(Exception exception)
internal void Complete(HttpListenerContext context)
internal void Complete(HttpListenerContext context, bool syncCompleted)
internal HttpListenerContext GetContext()
}
public WebSocketSharp.Net.HttpListenerContext : object {
private HttpConnection _connection
private string _error
private int _errorStatus
private HttpListener _listener
private HttpListenerRequest _request
private HttpListenerResponse _response
private IPrincipal _user
private HttpListenerWebSocketContext _websocketContext
internal HttpConnection Connection
internal string ErrorMessage
internal int ErrorStatus
internal bool HasError
internal HttpListener Listener
public HttpListenerRequest Request
public HttpListenerResponse Response
public IPrincipal User
internal void .ctor(HttpConnection connection)
internal HttpConnection get_Connection()
internal string get_ErrorMessage()
internal void set_ErrorMessage(string value)
internal int get_ErrorStatus()
internal void set_ErrorStatus(int value)
internal bool get_HasError()
internal HttpListener get_Listener()
internal void set_Listener(HttpListener value)
public HttpListenerRequest get_Request()
public HttpListenerResponse get_Response()
public IPrincipal get_User()
internal bool Authenticate()
internal bool Register()
internal void Unregister()
public HttpListenerWebSocketContext AcceptWebSocket(string protocol)
}
public WebSocketSharp.Net.HttpListenerException : Win32Exception {
public int ErrorCode
protected void .ctor(SerializationInfo serializationInfo, StreamingContext streamingContext)
public void .ctor(int errorCode)
public void .ctor(int errorCode, string message)
public int get_ErrorCode()
}
internal WebSocketSharp.Net.HttpListenerPrefix : object {
private string _host
private HttpListener _listener
private string _original
private string _path
private string _port
private string _prefix
private bool _secure
public string Host
public bool IsSecure
public HttpListener Listener
public string Original
public string Path
public string Port
internal void .ctor(string uriPrefix)
public string get_Host()
public bool get_IsSecure()
public HttpListener get_Listener()
public void set_Listener(HttpListener value)
public string get_Original()
public string get_Path()
public string get_Port()
private void parse(string uriPrefix)
public void CheckPrefix(string uriPrefix)
public bool Equals(object obj)
public int GetHashCode()
public string ToString()
}
public WebSocketSharp.Net.HttpListenerPrefixCollection : object {
private HttpListener _listener
private List`1<string> _prefixes
public int Count
public bool IsReadOnly
public bool IsSynchronized
internal void .ctor(HttpListener listener)
public int get_Count()
public bool get_IsReadOnly()
public bool get_IsSynchronized()
public void Add(string uriPrefix)
public void Clear()
public bool Contains(string uriPrefix)
public void CopyTo(Array array, int offset)
public void CopyTo(String[] array, int offset)
public IEnumerator`1<string> GetEnumerator()
public bool Remove(string uriPrefix)
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
}
public WebSocketSharp.Net.HttpListenerRequest : object {
private Byte[] _100continue
private String[] _acceptTypes
private bool _chunked
private Encoding _contentEncoding
private long _contentLength
private bool _contentLengthSet
private HttpListenerContext _context
private CookieCollection _cookies
private WebHeaderCollection _headers
private Guid _identifier
private Stream _inputStream
private bool _keepAlive
private bool _keepAliveSet
private string _method
private NameValueCollection _queryString
private Uri _referer
private string _uri
private Uri _url
private String[] _userLanguages
private Version _version
private bool _websocketRequest
private bool _websocketRequestSet
public String[] AcceptTypes
public int ClientCertificateError
public Encoding ContentEncoding
public long ContentLength64
public string ContentType
public CookieCollection Cookies
public bool HasEntityBody
public NameValueCollection Headers
public string HttpMethod
public Stream InputStream
public bool IsAuthenticated
public bool IsLocal
public bool IsSecureConnection
public bool IsWebSocketRequest
public bool KeepAlive
public IPEndPoint LocalEndPoint
public Version ProtocolVersion
public NameValueCollection QueryString
public string RawUrl
public IPEndPoint RemoteEndPoint
public Guid RequestTraceIdentifier
public Uri Url
public Uri UrlReferrer
public string UserAgent
public string UserHostAddress
public string UserHostName
public String[] UserLanguages
internal void .ctor(HttpListenerContext context)
public String[] get_AcceptTypes()
public int get_ClientCertificateError()
public Encoding get_ContentEncoding()
public long get_ContentLength64()
public string get_ContentType()
public CookieCollection get_Cookies()
public bool get_HasEntityBody()
public NameValueCollection get_Headers()
public string get_HttpMethod()
public Stream get_InputStream()
public bool get_IsAuthenticated()
public bool get_IsLocal()
public bool get_IsSecureConnection()
public bool get_IsWebSocketRequest()
public bool get_KeepAlive()
public IPEndPoint get_LocalEndPoint()
public Version get_ProtocolVersion()
public NameValueCollection get_QueryString()
public string get_RawUrl()
public IPEndPoint get_RemoteEndPoint()
public Guid get_RequestTraceIdentifier()
public Uri get_Url()
public Uri get_UrlReferrer()
public string get_UserAgent()
public string get_UserHostAddress()
public string get_UserHostName()
public String[] get_UserLanguages()
private bool tryCreateVersion(string version, Version& result)
internal void AddHeader(string header)
internal void FinishInitialization()
internal bool FlushInput()
internal void SetRequestLine(string requestLine)
public IAsyncResult BeginGetClientCertificate(AsyncCallback requestCallback, object state)
public X509Certificate2 EndGetClientCertificate(IAsyncResult asyncResult)
public X509Certificate2 GetClientCertificate()
public string ToString()
}
public WebSocketSharp.Net.HttpListenerResponse : object {
private bool _closeConnection
private Encoding _contentEncoding
private long _contentLength
private string _contentType
private HttpListenerContext _context
private CookieCollection _cookies
private bool _disposed
private WebHeaderCollection _headers
private bool _headersSent
private bool _keepAlive
private string _location
private ResponseStream _outputStream
private bool _sendChunked
private int _statusCode
private string _statusDescription
private Version _version
internal bool CloseConnection
internal bool HeadersSent
public Encoding ContentEncoding
public long ContentLength64
public string ContentType
public CookieCollection Cookies
public WebHeaderCollection Headers
public bool KeepAlive
public Stream OutputStream
public Version ProtocolVersion
public string RedirectLocation
public bool SendChunked
public int StatusCode
public string StatusDescription
internal void .ctor(HttpListenerContext context)
internal bool get_CloseConnection()
internal void set_CloseConnection(bool value)
internal bool get_HeadersSent()
internal void set_HeadersSent(bool value)
public Encoding get_ContentEncoding()
public void set_ContentEncoding(Encoding value)
public long get_ContentLength64()
public void set_ContentLength64(long value)
public string get_ContentType()
public void set_ContentType(string value)
public CookieCollection get_Cookies()
public void set_Cookies(CookieCollection value)
public WebHeaderCollection get_Headers()
public void set_Headers(WebHeaderCollection value)
public bool get_KeepAlive()
public void set_KeepAlive(bool value)
public Stream get_OutputStream()
public Version get_ProtocolVersion()
public void set_ProtocolVersion(Version value)
public string get_RedirectLocation()
public void set_RedirectLocation(string value)
public bool get_SendChunked()
public void set_SendChunked(bool value)
public int get_StatusCode()
public void set_StatusCode(int value)
public string get_StatusDescription()
public void set_StatusDescription(string value)
private bool canAddOrUpdate(Cookie cookie)
private void checkDisposed()
private void checkDisposedOrHeadersSent()
private void close(bool force)
private IEnumerable`1<Cookie> findCookie(Cookie cookie)
internal WebHeaderCollection WriteHeadersTo(MemoryStream destination)
public void Abort()
public void AddHeader(string name, string value)
public void AppendCookie(Cookie cookie)
public void AppendHeader(string name, string value)
public void Close()
public void Close(Byte[] responseEntity, bool willBlock)
public void CopyFrom(HttpListenerResponse templateResponse)
public void Redirect(string url)
public void SetCookie(Cookie cookie)
private void System.IDisposable.Dispose()
}
public WebSocketSharp.Net.HttpRequestHeader : Enum {
public int value__
public HttpRequestHeader CacheControl
public HttpRequestHeader Connection
public HttpRequestHeader Date
public HttpRequestHeader KeepAlive
public HttpRequestHeader Pragma
public HttpRequestHeader Trailer
public HttpRequestHeader TransferEncoding
public HttpRequestHeader Upgrade
public HttpRequestHeader Via
public HttpRequestHeader Warning
public HttpRequestHeader Allow
public HttpRequestHeader ContentLength
public HttpRequestHeader ContentType
public HttpRequestHeader ContentEncoding
public HttpRequestHeader ContentLanguage
public HttpRequestHeader ContentLocation
public HttpRequestHeader ContentMd5
public HttpRequestHeader ContentRange
public HttpRequestHeader Expires
public HttpRequestHeader LastModified
public HttpRequestHeader Accept
public HttpRequestHeader AcceptCharset
public HttpRequestHeader AcceptEncoding
public HttpRequestHeader AcceptLanguage
public HttpRequestHeader Authorization
public HttpRequestHeader Cookie
public HttpRequestHeader Expect
public HttpRequestHeader From
public HttpRequestHeader Host
public HttpRequestHeader IfMatch
public HttpRequestHeader IfModifiedSince
public HttpRequestHeader IfNoneMatch
public HttpRequestHeader IfRange
public HttpRequestHeader IfUnmodifiedSince
public HttpRequestHeader MaxForwards
public HttpRequestHeader ProxyAuthorization
public HttpRequestHeader Referer
public HttpRequestHeader Range
public HttpRequestHeader Te
public HttpRequestHeader Translate
public HttpRequestHeader UserAgent
public HttpRequestHeader SecWebSocketKey
public HttpRequestHeader SecWebSocketExtensions
public HttpRequestHeader SecWebSocketProtocol
public HttpRequestHeader SecWebSocketVersion
}
public WebSocketSharp.Net.HttpResponseHeader : Enum {
public int value__
public HttpResponseHeader CacheControl
public HttpResponseHeader Connection
public HttpResponseHeader Date
public HttpResponseHeader KeepAlive
public HttpResponseHeader Pragma
public HttpResponseHeader Trailer
public HttpResponseHeader TransferEncoding
public HttpResponseHeader Upgrade
public HttpResponseHeader Via
public HttpResponseHeader Warning
public HttpResponseHeader Allow
public HttpResponseHeader ContentLength
public HttpResponseHeader ContentType
public HttpResponseHeader ContentEncoding
public HttpResponseHeader ContentLanguage
public HttpResponseHeader ContentLocation
public HttpResponseHeader ContentMd5
public HttpResponseHeader ContentRange
public HttpResponseHeader Expires
public HttpResponseHeader LastModified
public HttpResponseHeader AcceptRanges
public HttpResponseHeader Age
public HttpResponseHeader ETag
public HttpResponseHeader Location
public HttpResponseHeader ProxyAuthenticate
public HttpResponseHeader RetryAfter
public HttpResponseHeader Server
public HttpResponseHeader SetCookie
public HttpResponseHeader Vary
public HttpResponseHeader WwwAuthenticate
public HttpResponseHeader SecWebSocketExtensions
public HttpResponseHeader SecWebSocketAccept
public HttpResponseHeader SecWebSocketProtocol
public HttpResponseHeader SecWebSocketVersion
}
public WebSocketSharp.Net.HttpStatusCode : Enum {
public int value__
public HttpStatusCode Continue
public HttpStatusCode SwitchingProtocols
public HttpStatusCode OK
public HttpStatusCode Created
public HttpStatusCode Accepted
public HttpStatusCode NonAuthoritativeInformation
public HttpStatusCode NoContent
public HttpStatusCode ResetContent
public HttpStatusCode PartialContent
public HttpStatusCode MultipleChoices
public HttpStatusCode Ambiguous
public HttpStatusCode MovedPermanently
public HttpStatusCode Moved
public HttpStatusCode Found
public HttpStatusCode Redirect
public HttpStatusCode SeeOther
public HttpStatusCode RedirectMethod
public HttpStatusCode NotModified
public HttpStatusCode UseProxy
public HttpStatusCode Unused
public HttpStatusCode TemporaryRedirect
public HttpStatusCode RedirectKeepVerb
public HttpStatusCode BadRequest
public HttpStatusCode Unauthorized
public HttpStatusCode PaymentRequired
public HttpStatusCode Forbidden
public HttpStatusCode NotFound
public HttpStatusCode MethodNotAllowed
public HttpStatusCode NotAcceptable
public HttpStatusCode ProxyAuthenticationRequired
public HttpStatusCode RequestTimeout
public HttpStatusCode Conflict
public HttpStatusCode Gone
public HttpStatusCode LengthRequired
public HttpStatusCode PreconditionFailed
public HttpStatusCode RequestEntityTooLarge
public HttpStatusCode RequestUriTooLong
public HttpStatusCode UnsupportedMediaType
public HttpStatusCode RequestedRangeNotSatisfiable
public HttpStatusCode ExpectationFailed
public HttpStatusCode InternalServerError
public HttpStatusCode NotImplemented
public HttpStatusCode BadGateway
public HttpStatusCode ServiceUnavailable
public HttpStatusCode GatewayTimeout
public HttpStatusCode HttpVersionNotSupported
}
internal WebSocketSharp.Net.HttpStreamAsyncResult : object {
private Byte[] _buffer
private AsyncCallback _callback
private bool _completed
private int _count
private Exception _exception
private int _offset
private object _state
private object _sync
private int _syncRead
private ManualResetEvent _waitHandle
internal Byte[] Buffer
internal int Count
internal Exception Exception
internal bool HasException
internal int Offset
internal int SyncRead
public object AsyncState
public WaitHandle AsyncWaitHandle
public bool CompletedSynchronously
public bool IsCompleted
internal void .ctor(AsyncCallback callback, object state)
internal Byte[] get_Buffer()
internal void set_Buffer(Byte[] value)
internal int get_Count()
internal void set_Count(int value)
internal Exception get_Exception()
internal bool get_HasException()
internal int get_Offset()
internal void set_Offset(int value)
internal int get_SyncRead()
internal void set_SyncRead(int value)
public object get_AsyncState()
public WaitHandle get_AsyncWaitHandle()
public bool get_CompletedSynchronously()
public bool get_IsCompleted()
internal void Complete()
internal void Complete(Exception exception)
private void <Complete>b__35_0(IAsyncResult ar)
}
internal WebSocketSharp.Net.HttpUtility : object {
private Dictionary`2<string, char> _entities
private Char[] _hexChars
private object _sync
private int getChar(Byte[] bytes, int offset, int length)
private int getChar(string s, int offset, int length)
private Char[] getChars(MemoryStream buffer, Encoding encoding)
private Dictionary`2<string, char> getEntities()
private int getInt(byte b)
private void initEntities()
private bool notEncoded(char c)
private void urlEncode(char c, Stream result, bool unicode)
private void urlPathEncode(char c, Stream result)
private void writeCharBytes(char c, IList buffer, Encoding encoding)
internal Uri CreateRequestUrl(string requestUri, string host, bool websocketRequest, bool secure)
internal IPrincipal CreateUser(string response, AuthenticationSchemes scheme, string realm, string method, Func`2<IIdentity, NetworkCredential> credentialsFinder)
internal Encoding GetEncoding(string contentType)
internal NameValueCollection InternalParseQueryString(string query, Encoding encoding)
internal string InternalUrlDecode(Byte[] bytes, int offset, int count, Encoding encoding)
internal Byte[] InternalUrlDecodeToBytes(Byte[] bytes, int offset, int count)
internal Byte[] InternalUrlEncodeToBytes(Byte[] bytes, int offset, int count)
internal Byte[] InternalUrlEncodeUnicodeToBytes(string s)
public string HtmlAttributeEncode(string s)
public void HtmlAttributeEncode(string s, TextWriter output)
public string HtmlDecode(string s)
public void HtmlDecode(string s, TextWriter output)
public string HtmlEncode(string s)
public void HtmlEncode(string s, TextWriter output)
public NameValueCollection ParseQueryString(string query)
public NameValueCollection ParseQueryString(string query, Encoding encoding)
public string UrlDecode(string s)
public string UrlDecode(string s, Encoding encoding)
public string UrlDecode(Byte[] bytes, Encoding encoding)
public string UrlDecode(Byte[] bytes, int offset, int count, Encoding encoding)
public Byte[] UrlDecodeToBytes(Byte[] bytes)
public Byte[] UrlDecodeToBytes(string s)
public Byte[] UrlDecodeToBytes(string s, Encoding encoding)
public Byte[] UrlDecodeToBytes(Byte[] bytes, int offset, int count)
public string UrlEncode(Byte[] bytes)
public string UrlEncode(string s)
public string UrlEncode(string s, Encoding encoding)
public string UrlEncode(Byte[] bytes, int offset, int count)
public Byte[] UrlEncodeToBytes(Byte[] bytes)
public Byte[] UrlEncodeToBytes(string s)
public Byte[] UrlEncodeToBytes(string s, Encoding encoding)
public Byte[] UrlEncodeToBytes(Byte[] bytes, int offset, int count)
public string UrlEncodeUnicode(string s)
public Byte[] UrlEncodeUnicodeToBytes(string s)
public string UrlPathEncode(string s)
}
public WebSocketSharp.Net.HttpVersion : object {
public Version Version10
public Version Version11
}
internal WebSocketSharp.Net.InputChunkState : Enum {
public int value__
public InputChunkState None
public InputChunkState Data
public InputChunkState DataEnded
public InputChunkState Trailer
public InputChunkState End
}
internal WebSocketSharp.Net.InputState : Enum {
public int value__
public InputState RequestLine
public InputState Headers
}
internal WebSocketSharp.Net.LineState : Enum {
public int value__
public LineState None
public LineState Cr
public LineState Lf
}
public WebSocketSharp.Net.NetworkCredential : object {
private string _domain
private string _password
private String[] _roles
private string _userName
public string Domain
public string Password
public String[] Roles
public string UserName
public void .ctor(string userName, string password)
public void .ctor(string userName, string password, string domain, String[] roles)
public string get_Domain()
internal void set_Domain(string value)
public string get_Password()
internal void set_Password(string value)
public String[] get_Roles()
internal void set_Roles(String[] value)
public string get_UserName()
internal void set_UserName(string value)
}
internal WebSocketSharp.Net.QueryStringCollection : NameValueCollection {
public string ToString()
}
internal WebSocketSharp.Net.ReadBufferState : object {
private HttpStreamAsyncResult _asyncResult
private Byte[] _buffer
private int _count
private int _initialCount
private int _offset
public HttpStreamAsyncResult AsyncResult
public Byte[] Buffer
public int Count
public int InitialCount
public int Offset
public void .ctor(Byte[] buffer, int offset, int count, HttpStreamAsyncResult asyncResult)
public HttpStreamAsyncResult get_AsyncResult()
public void set_AsyncResult(HttpStreamAsyncResult value)
public Byte[] get_Buffer()
public void set_Buffer(Byte[] value)
public int get_Count()
public void set_Count(int value)
public int get_InitialCount()
public void set_InitialCount(int value)
public int get_Offset()
public void set_Offset(int value)
}
internal WebSocketSharp.Net.RequestStream : Stream {
private long _bodyLeft
private Byte[] _buffer
private int _count
private bool _disposed
private int _offset
private Stream _stream
public bool CanRead
public bool CanSeek
public bool CanWrite
public long Length
public long Position
internal void .ctor(Stream stream, Byte[] buffer, int offset, int count)
internal void .ctor(Stream stream, Byte[] buffer, int offset, int count, long contentLength)
public bool get_CanRead()
public bool get_CanSeek()
public bool get_CanWrite()
public long get_Length()
public long get_Position()
public void set_Position(long value)
private int fillFromBuffer(Byte[] buffer, int offset, int count)
public IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state)
public IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state)
public void Close()
public int EndRead(IAsyncResult asyncResult)
public void EndWrite(IAsyncResult asyncResult)
public void Flush()
public int Read(Byte[] buffer, int offset, int count)
public long Seek(long offset, SeekOrigin origin)
public void SetLength(long value)
public void Write(Byte[] buffer, int offset, int count)
}
internal WebSocketSharp.Net.ResponseStream : Stream {
private MemoryStream _body
private Byte[] _crlf
private bool _disposed
private HttpListenerResponse _response
private bool _sendChunked
private Stream _stream
private Action`3<Byte[], int, int> _write
private Action`3<Byte[], int, int> _writeBody
private Action`3<Byte[], int, int> _writeChunked
public bool CanRead
public bool CanSeek
public bool CanWrite
public long Length
public long Position
internal void .ctor(Stream stream, HttpListenerResponse response, bool ignoreWriteExceptions)
public bool get_CanRead()
public bool get_CanSeek()
public bool get_CanWrite()
public long get_Length()
public long get_Position()
public void set_Position(long value)
private bool flush(bool closing)
private void flushBody(bool closing)
private bool flushHeaders(bool closing)
private Byte[] getChunkSizeBytes(int size, bool final)
private void writeChunked(Byte[] buffer, int offset, int count)
private void writeChunkedWithoutThrowingException(Byte[] buffer, int offset, int count)
private void writeWithoutThrowingException(Byte[] buffer, int offset, int count)
internal void Close(bool force)
internal void InternalWrite(Byte[] buffer, int offset, int count)
public IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state)
public IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state)
public void Close()
protected void Dispose(bool disposing)
public int EndRead(IAsyncResult asyncResult)
public void EndWrite(IAsyncResult asyncResult)
public void Flush()
public int Read(Byte[] buffer, int offset, int count)
public long Seek(long offset, SeekOrigin origin)
public void SetLength(long value)
public void Write(Byte[] buffer, int offset, int count)
}
public WebSocketSharp.Net.ServerSslConfiguration : SslConfiguration {
private X509Certificate2 _cert
private bool _clientCertRequired
public bool ClientCertificateRequired
public RemoteCertificateValidationCallback ClientCertificateValidationCallback
public X509Certificate2 ServerCertificate
public void .ctor(X509Certificate2 serverCertificate)
public void .ctor(X509Certificate2 serverCertificate, bool clientCertificateRequired, SslProtocols enabledSslProtocols, bool checkCertificateRevocation)
public bool get_ClientCertificateRequired()
public void set_ClientCertificateRequired(bool value)
public RemoteCertificateValidationCallback get_ClientCertificateValidationCallback()
public void set_ClientCertificateValidationCallback(RemoteCertificateValidationCallback value)
public X509Certificate2 get_ServerCertificate()
public void set_ServerCertificate(X509Certificate2 value)
}
public WebSocketSharp.Net.SslConfiguration : object {
private LocalCertificateSelectionCallback _certSelectionCallback
private RemoteCertificateValidationCallback _certValidationCallback
private bool _checkCertRevocation
private SslProtocols _enabledProtocols
protected LocalCertificateSelectionCallback CertificateSelectionCallback
protected RemoteCertificateValidationCallback CertificateValidationCallback
public bool CheckCertificateRevocation
public SslProtocols EnabledSslProtocols
protected void .ctor(SslProtocols enabledSslProtocols, bool checkCertificateRevocation)
protected LocalCertificateSelectionCallback get_CertificateSelectionCallback()
protected void set_CertificateSelectionCallback(LocalCertificateSelectionCallback value)
protected RemoteCertificateValidationCallback get_CertificateValidationCallback()
protected void set_CertificateValidationCallback(RemoteCertificateValidationCallback value)
public bool get_CheckCertificateRevocation()
public void set_CheckCertificateRevocation(bool value)
public SslProtocols get_EnabledSslProtocols()
public void set_EnabledSslProtocols(SslProtocols value)
}
public WebSocketSharp.Net.WebHeaderCollection : NameValueCollection {
private Dictionary`2<string, HttpHeaderInfo> _headers
private bool _internallyUsed
private HttpHeaderType _state
internal HttpHeaderType State
public String[] AllKeys
public int Count
public string Item
public string Item
public KeysCollection Keys
internal void .ctor(HttpHeaderType state, bool internallyUsed)
protected void .ctor(SerializationInfo serializationInfo, StreamingContext streamingContext)
internal HttpHeaderType get_State()
public String[] get_AllKeys()
public int get_Count()
public string get_Item(HttpRequestHeader header)
public void set_Item(HttpRequestHeader header, string value)
public string get_Item(HttpResponseHeader header)
public void set_Item(HttpResponseHeader header, string value)
public KeysCollection get_Keys()
private void add(string name, string value, bool ignoreRestricted)
private void addWithoutCheckingName(string name, string value)
private void addWithoutCheckingNameAndRestricted(string name, string value)
private int checkColonSeparated(string header)
private HttpHeaderType checkHeaderType(string name)
private string checkName(string name)
private void checkRestricted(string name)
private void checkState(bool response)
private string checkValue(string value)
private string convert(string key)
private void doWithCheckingState(Action`2<string, string> action, string name, string value, bool setState)
private void doWithCheckingState(Action`2<string, string> action, string name, string value, bool response, bool setState)
private void doWithoutCheckingName(Action`2<string, string> action, string name, string value)
private HttpHeaderInfo getHeaderInfo(string name)
private bool isRestricted(string name, bool response)
private void removeWithoutCheckingName(string name, string unuse)
private void setWithoutCheckingName(string name, string value)
internal string Convert(HttpRequestHeader header)
internal string Convert(HttpResponseHeader header)
internal void InternalRemove(string name)
internal void InternalSet(string header, bool response)
internal void InternalSet(string name, string value, bool response)
internal bool IsHeaderName(string name)
internal bool IsHeaderValue(string value)
internal bool IsMultiValue(string headerName, bool response)
internal string ToStringMultiValue(bool response)
protected void AddWithoutValidate(string headerName, string headerValue)
public void Add(string header)
public void Add(HttpRequestHeader header, string value)
public void Add(HttpResponseHeader header, string value)
public void Add(string name, string value)
public void Clear()
public string Get(int index)
public string Get(string name)
public IEnumerator GetEnumerator()
public string GetKey(int index)
public String[] GetValues(int index)
public String[] GetValues(string header)
public void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext)
public bool IsRestricted(string headerName)
public bool IsRestricted(string headerName, bool response)
public void OnDeserialization(object sender)
public void Remove(HttpRequestHeader header)
public void Remove(HttpResponseHeader header)
public void Remove(string name)
public void Set(HttpRequestHeader header, string value)
public void Set(HttpResponseHeader header, string value)
public void Set(string name, string value)
public Byte[] ToByteArray()
public string ToString()
private void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext)
}
public WebSocketSharp.Net.WebSockets.HttpListenerWebSocketContext : WebSocketContext {
private HttpListenerContext _context
private WebSocket _websocket
internal Logger Log
internal Stream Stream
public CookieCollection CookieCollection
public NameValueCollection Headers
public string Host
public bool IsAuthenticated
public bool IsLocal
public bool IsSecureConnection
public bool IsWebSocketRequest
public string Origin
public NameValueCollection QueryString
public Uri RequestUri
public string SecWebSocketKey
public IEnumerable`1<string> SecWebSocketProtocols
public string SecWebSocketVersion
public IPEndPoint ServerEndPoint
public IPrincipal User
public IPEndPoint UserEndPoint
public WebSocket WebSocket
internal void .ctor(HttpListenerContext context, string protocol)
internal Logger get_Log()
internal Stream get_Stream()
public CookieCollection get_CookieCollection()
public NameValueCollection get_Headers()
public string get_Host()
public bool get_IsAuthenticated()
public bool get_IsLocal()
public bool get_IsSecureConnection()
public bool get_IsWebSocketRequest()
public string get_Origin()
public NameValueCollection get_QueryString()
public Uri get_RequestUri()
public string get_SecWebSocketKey()
public IEnumerable`1<string> get_SecWebSocketProtocols()
public string get_SecWebSocketVersion()
public IPEndPoint get_ServerEndPoint()
public IPrincipal get_User()
public IPEndPoint get_UserEndPoint()
public WebSocket get_WebSocket()
internal void Close()
internal void Close(HttpStatusCode code)
public string ToString()
}
internal WebSocketSharp.Net.WebSockets.TcpListenerWebSocketContext : WebSocketContext {
private CookieCollection _cookies
private Logger _logger
private NameValueCollection _queryString
private HttpRequest _request
private bool _secure
private Stream _stream
private TcpClient _tcpClient
private Uri _uri
private IPrincipal _user
private WebSocket _websocket
internal Logger Log
internal Stream Stream
public CookieCollection CookieCollection
public NameValueCollection Headers
public string Host
public bool IsAuthenticated
public bool IsLocal
public bool IsSecureConnection
public bool IsWebSocketRequest
public string Origin
public NameValueCollection QueryString
public Uri RequestUri
public string SecWebSocketKey
public IEnumerable`1<string> SecWebSocketProtocols
public string SecWebSocketVersion
public IPEndPoint ServerEndPoint
public IPrincipal User
public IPEndPoint UserEndPoint
public WebSocket WebSocket
internal void .ctor(TcpClient tcpClient, string protocol, bool secure, ServerSslConfiguration sslConfig, Logger logger)
internal Logger get_Log()
internal Stream get_Stream()
public CookieCollection get_CookieCollection()
public NameValueCollection get_Headers()
public string get_Host()
public bool get_IsAuthenticated()
public bool get_IsLocal()
public bool get_IsSecureConnection()
public bool get_IsWebSocketRequest()
public string get_Origin()
public NameValueCollection get_QueryString()
public Uri get_RequestUri()
public string get_SecWebSocketKey()
public IEnumerable`1<string> get_SecWebSocketProtocols()
public string get_SecWebSocketVersion()
public IPEndPoint get_ServerEndPoint()
public IPrincipal get_User()
public IPEndPoint get_UserEndPoint()
public WebSocket get_WebSocket()
internal bool Authenticate(AuthenticationSchemes scheme, string realm, Func`2<IIdentity, NetworkCredential> credentialsFinder)
internal void Close()
internal void Close(HttpStatusCode code)
internal void SendAuthenticationChallenge(string challenge)
public string ToString()
}
public WebSocketSharp.Net.WebSockets.WebSocketContext : object {
public CookieCollection CookieCollection
public NameValueCollection Headers
public string Host
public bool IsAuthenticated
public bool IsLocal
public bool IsSecureConnection
public bool IsWebSocketRequest
public string Origin
public NameValueCollection QueryString
public Uri RequestUri
public string SecWebSocketKey
public IEnumerable`1<string> SecWebSocketProtocols
public string SecWebSocketVersion
public IPEndPoint ServerEndPoint
public IPrincipal User
public IPEndPoint UserEndPoint
public WebSocket WebSocket
public CookieCollection get_CookieCollection()
public NameValueCollection get_Headers()
public string get_Host()
public bool get_IsAuthenticated()
public bool get_IsLocal()
public bool get_IsSecureConnection()
public bool get_IsWebSocketRequest()
public string get_Origin()
public NameValueCollection get_QueryString()
public Uri get_RequestUri()
public string get_SecWebSocketKey()
public IEnumerable`1<string> get_SecWebSocketProtocols()
public string get_SecWebSocketVersion()
public IPEndPoint get_ServerEndPoint()
public IPrincipal get_User()
public IPEndPoint get_UserEndPoint()
public WebSocket get_WebSocket()
}
public WebSocketSharp.Opcode : Enum {
public byte value__
public Opcode Cont
public Opcode Text
public Opcode Binary
public Opcode Close
public Opcode Ping
public Opcode Pong
}
internal WebSocketSharp.PayloadData : object {
private ushort _code
private bool _codeSet
private Byte[] _data
private long _extDataLength
private long _length
private string _reason
private bool _reasonSet
public PayloadData Empty
public ulong MaxLength
internal ushort Code
internal long ExtensionDataLength
internal bool HasReservedCode
internal string Reason
public Byte[] ApplicationData
public Byte[] ExtensionData
public ulong Length
internal void .ctor(Byte[] data)
internal void .ctor(Byte[] data, long length)
internal void .ctor(ushort code, string reason)
internal ushort get_Code()
internal long get_ExtensionDataLength()
internal void set_ExtensionDataLength(long value)
internal bool get_HasReservedCode()
internal string get_Reason()
public Byte[] get_ApplicationData()
public Byte[] get_ExtensionData()
public ulong get_Length()
internal void Mask(Byte[] key)
public IEnumerator`1<byte> GetEnumerator()
public Byte[] ToArray()
public string ToString()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
}
internal WebSocketSharp.Rsv : Enum {
public byte value__
public Rsv Off
public Rsv On
}
public WebSocketSharp.Server.HttpRequestEventArgs : EventArgs {
private HttpListenerRequest _request
private HttpListenerResponse _response
public HttpListenerRequest Request
public HttpListenerResponse Response
internal void .ctor(HttpListenerContext context)
public HttpListenerRequest get_Request()
public HttpListenerResponse get_Response()
}
public WebSocketSharp.Server.HttpServer : object {
private IPAddress _address
private string _hostname
private HttpListener _listener
private Logger _logger
private int _port
private Thread _receiveThread
private string _rootPath
private bool _secure
private WebSocketServiceManager _services
private ServerState modreq(System.Runtime.CompilerServices.IsVolatile) _state
private object _sync
private bool _windows
private EventHandler`1<HttpRequestEventArgs> OnConnect
private EventHandler`1<HttpRequestEventArgs> OnDelete
private EventHandler`1<HttpRequestEventArgs> OnGet
private EventHandler`1<HttpRequestEventArgs> OnHead
private EventHandler`1<HttpRequestEventArgs> OnOptions
private EventHandler`1<HttpRequestEventArgs> OnPatch
private EventHandler`1<HttpRequestEventArgs> OnPost
private EventHandler`1<HttpRequestEventArgs> OnPut
private EventHandler`1<HttpRequestEventArgs> OnTrace
public IPAddress Address
public AuthenticationSchemes AuthenticationSchemes
public bool IsListening
public bool IsSecure
public bool KeepClean
public Logger Log
public int Port
public string Realm
public bool ReuseAddress
public string RootPath
public ServerSslConfiguration SslConfiguration
public Func`2<IIdentity, NetworkCredential> UserCredentialsFinder
public TimeSpan WaitTime
public WebSocketServiceManager WebSocketServices
public void .ctor(int port)
public void .ctor(string url)
public void .ctor(int port, bool secure)
public void .ctor(IPAddress address, int port)
public void .ctor(IPAddress address, int port, bool secure)
public IPAddress get_Address()
public AuthenticationSchemes get_AuthenticationSchemes()
public void set_AuthenticationSchemes(AuthenticationSchemes value)
public bool get_IsListening()
public bool get_IsSecure()
public bool get_KeepClean()
public void set_KeepClean(bool value)
public Logger get_Log()
public int get_Port()
public string get_Realm()
public void set_Realm(string value)
public bool get_ReuseAddress()
public void set_ReuseAddress(bool value)
public string get_RootPath()
public void set_RootPath(string value)
public ServerSslConfiguration get_SslConfiguration()
public void set_SslConfiguration(ServerSslConfiguration value)
public Func`2<IIdentity, NetworkCredential> get_UserCredentialsFinder()
public void set_UserCredentialsFinder(Func`2<IIdentity, NetworkCredential> value)
public TimeSpan get_WaitTime()
public void set_WaitTime(TimeSpan value)
public WebSocketServiceManager get_WebSocketServices()
public void add_OnConnect(EventHandler`1<HttpRequestEventArgs> value)
public void remove_OnConnect(EventHandler`1<HttpRequestEventArgs> value)
public void add_OnDelete(EventHandler`1<HttpRequestEventArgs> value)
public void remove_OnDelete(EventHandler`1<HttpRequestEventArgs> value)
public void add_OnGet(EventHandler`1<HttpRequestEventArgs> value)
public void remove_OnGet(EventHandler`1<HttpRequestEventArgs> value)
public void add_OnHead(EventHandler`1<HttpRequestEventArgs> value)
public void remove_OnHead(EventHandler`1<HttpRequestEventArgs> value)
public void add_OnOptions(EventHandler`1<HttpRequestEventArgs> value)
public void remove_OnOptions(EventHandler`1<HttpRequestEventArgs> value)
public void add_OnPatch(EventHandler`1<HttpRequestEventArgs> value)
public void remove_OnPatch(EventHandler`1<HttpRequestEventArgs> value)
public void add_OnPost(EventHandler`1<HttpRequestEventArgs> value)
public void remove_OnPost(EventHandler`1<HttpRequestEventArgs> value)
public void add_OnPut(EventHandler`1<HttpRequestEventArgs> value)
public void remove_OnPut(EventHandler`1<HttpRequestEventArgs> value)
public void add_OnTrace(EventHandler`1<HttpRequestEventArgs> value)
public void remove_OnTrace(EventHandler`1<HttpRequestEventArgs> value)
private void abort()
private bool checkIfAvailable(bool ready, bool start, bool shutting, bool stop, String& message)
private string checkIfCertificateExists()
private string convertToString(IPAddress address)
private string getHost(Uri uri)
private void init(string hostname, IPAddress address, int port, bool secure)
private void processRequest(HttpListenerContext context)
private void processRequest(HttpListenerWebSocketContext context)
private void receiveRequest()
private void startReceiving()
private void stopReceiving(int millisecondsTimeout)
private bool tryCreateUri(string uriString, Uri& result, String& message)
public void AddWebSocketService(string path, Func`1<TBehavior> initializer)
public void AddWebSocketService(string path)
public Byte[] GetFile(string path)
public bool RemoveWebSocketService(string path)
public void Start()
public void Stop()
public void Stop(ushort code, string reason)
public void Stop(CloseStatusCode code, string reason)
}
public WebSocketSharp.Server.IWebSocketSession {
public WebSocketContext Context
public string ID
public string Protocol
public DateTime StartTime
public WebSocketState State
public WebSocketContext get_Context()
public string get_ID()
public string get_Protocol()
public DateTime get_StartTime()
public WebSocketState get_State()
}
internal WebSocketSharp.Server.ServerState : Enum {
public int value__
public ServerState Ready
public ServerState Start
public ServerState ShuttingDown
public ServerState Stop
}
public WebSocketSharp.Server.WebSocketBehavior : object {
private WebSocketContext _context
private Func`3<CookieCollection, CookieCollection, bool> _cookiesValidator
private bool _emitOnPing
private string _id
private bool _ignoreExtensions
private Func`2<string, bool> _originValidator
private string _protocol
private WebSocketSessionManager _sessions
private DateTime _startTime
private WebSocket _websocket
protected Logger Log
protected WebSocketSessionManager Sessions
public WebSocketContext Context
public Func`3<CookieCollection, CookieCollection, bool> CookiesValidator
public bool EmitOnPing
public string ID
public bool IgnoreExtensions
public Func`2<string, bool> OriginValidator
public string Protocol
public DateTime StartTime
public WebSocketState State
protected Logger get_Log()
protected WebSocketSessionManager get_Sessions()
public WebSocketContext get_Context()
public Func`3<CookieCollection, CookieCollection, bool> get_CookiesValidator()
public void set_CookiesValidator(Func`3<CookieCollection, CookieCollection, bool> value)
public bool get_EmitOnPing()
public void set_EmitOnPing(bool value)
public string get_ID()
public bool get_IgnoreExtensions()
public void set_IgnoreExtensions(bool value)
public Func`2<string, bool> get_OriginValidator()
public void set_OriginValidator(Func`2<string, bool> value)
public string get_Protocol()
public void set_Protocol(string value)
public DateTime get_StartTime()
public WebSocketState get_State()
private string checkHandshakeRequest(WebSocketContext context)
private void onClose(object sender, CloseEventArgs e)
private void onError(object sender, ErrorEventArgs e)
private void onMessage(object sender, MessageEventArgs e)
private void onOpen(object sender, EventArgs e)
internal void Start(WebSocketContext context, WebSocketSessionManager sessions)
protected void Error(string message, Exception exception)
protected void OnClose(CloseEventArgs e)
protected void OnError(ErrorEventArgs e)
protected void OnMessage(MessageEventArgs e)
protected void OnOpen()
protected void Send(Byte[] data)
protected void Send(FileInfo file)
protected void Send(string data)
protected void SendAsync(Byte[] data, Action`1<bool> completed)
protected void SendAsync(FileInfo file, Action`1<bool> completed)
protected void SendAsync(string data, Action`1<bool> completed)
protected void SendAsync(Stream stream, int length, Action`1<bool> completed)
}
public WebSocketSharp.Server.WebSocketServer : object {
private IPAddress _address
private AuthenticationSchemes _authSchemes
private string _defaultRealm
private bool _dnsStyle
private string _hostname
private TcpListener _listener
private Logger _logger
private int _port
private string _realm
private Thread _receiveThread
private bool _reuseAddress
private bool _secure
private WebSocketServiceManager _services
private ServerSslConfiguration _sslConfig
private ServerState modreq(System.Runtime.CompilerServices.IsVolatile) _state
private object _sync
private Func`2<IIdentity, NetworkCredential> _userCredFinder
public IPAddress Address
public AuthenticationSchemes AuthenticationSchemes
public bool IsListening
public bool IsSecure
public bool KeepClean
public Logger Log
public int Port
public string Realm
public bool ReuseAddress
public ServerSslConfiguration SslConfiguration
public Func`2<IIdentity, NetworkCredential> UserCredentialsFinder
public TimeSpan WaitTime
public WebSocketServiceManager WebSocketServices
public void .ctor(int port)
public void .ctor(string url)
public void .ctor(int port, bool secure)
public void .ctor(IPAddress address, int port)
public void .ctor(IPAddress address, int port, bool secure)
public IPAddress get_Address()
public AuthenticationSchemes get_AuthenticationSchemes()
public void set_AuthenticationSchemes(AuthenticationSchemes value)
public bool get_IsListening()
public bool get_IsSecure()
public bool get_KeepClean()
public void set_KeepClean(bool value)
public Logger get_Log()
public int get_Port()
public string get_Realm()
public void set_Realm(string value)
public bool get_ReuseAddress()
public void set_ReuseAddress(bool value)
public ServerSslConfiguration get_SslConfiguration()
public void set_SslConfiguration(ServerSslConfiguration value)
public Func`2<IIdentity, NetworkCredential> get_UserCredentialsFinder()
public void set_UserCredentialsFinder(Func`2<IIdentity, NetworkCredential> value)
public TimeSpan get_WaitTime()
public void set_WaitTime(TimeSpan value)
public WebSocketServiceManager get_WebSocketServices()
private void abort()
private bool checkIfAvailable(bool ready, bool start, bool shutting, bool stop, String& message)
private string checkIfCertificateExists()
private string getRealm()
private void init(string hostname, IPAddress address, int port, bool secure)
private void processRequest(TcpListenerWebSocketContext context)
private void receiveRequest()
private void startReceiving()
private void stopReceiving(int millisecondsTimeout)
private bool tryCreateUri(string uriString, Uri& result, String& message)
public void AddWebSocketService(string path, Func`1<TBehavior> initializer)
public void AddWebSocketService(string path)
public bool RemoveWebSocketService(string path)
public void Start()
public void Stop()
public void Stop(ushort code, string reason)
public void Stop(CloseStatusCode code, string reason)
}
public WebSocketSharp.Server.WebSocketServiceHost : object {
internal ServerState State
public bool KeepClean
public string Path
public WebSocketSessionManager Sessions
public Type Type
public TimeSpan WaitTime
internal ServerState get_State()
public bool get_KeepClean()
public void set_KeepClean(bool value)
public string get_Path()
public WebSocketSessionManager get_Sessions()
public Type get_Type()
public TimeSpan get_WaitTime()
public void set_WaitTime(TimeSpan value)
internal void Start()
internal void StartSession(WebSocketContext context)
internal void Stop(ushort code, string reason)
protected WebSocketBehavior CreateSession()
}
internal WebSocketSharp.Server.WebSocketServiceHost`1 : WebSocketServiceHost {
private Func`1<TBehavior> _initializer
private Logger _logger
private string _path
private WebSocketSessionManager _sessions
public bool KeepClean
public string Path
public WebSocketSessionManager Sessions
public Type Type
public TimeSpan WaitTime
internal void .ctor(string path, Func`1<TBehavior> initializer, Logger logger)
public bool get_KeepClean()
public void set_KeepClean(bool value)
public string get_Path()
public WebSocketSessionManager get_Sessions()
public Type get_Type()
public TimeSpan get_WaitTime()
public void set_WaitTime(TimeSpan value)
protected WebSocketBehavior CreateSession()
}
public WebSocketSharp.Server.WebSocketServiceManager : object {
private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _clean
private Dictionary`2<string, WebSocketServiceHost> _hosts
private Logger _logger
private ServerState modreq(System.Runtime.CompilerServices.IsVolatile) _state
private object _sync
private TimeSpan _waitTime
public int Count
public IEnumerable`1<WebSocketServiceHost> Hosts
public WebSocketServiceHost Item
public bool KeepClean
public IEnumerable`1<string> Paths
public int SessionCount
public TimeSpan WaitTime
internal void .ctor(Logger logger)
public int get_Count()
public IEnumerable`1<WebSocketServiceHost> get_Hosts()
public WebSocketServiceHost get_Item(string path)
public bool get_KeepClean()
internal void set_KeepClean(bool value)
public IEnumerable`1<string> get_Paths()
public int get_SessionCount()
public TimeSpan get_WaitTime()
internal void set_WaitTime(TimeSpan value)
private void broadcast(Opcode opcode, Byte[] data, Action completed)
private void broadcast(Opcode opcode, Stream stream, Action completed)
private void broadcastAsync(Opcode opcode, Byte[] data, Action completed)
private void broadcastAsync(Opcode opcode, Stream stream, Action completed)
private Dictionary`2<string, Dictionary`2<string, bool>> broadping(Byte[] frameAsBytes, TimeSpan timeout)
internal void Add(string path, Func`1<TBehavior> initializer)
internal bool InternalTryGetServiceHost(string path, WebSocketServiceHost& host)
internal bool Remove(string path)
internal void Start()
internal void Stop(CloseEventArgs e, bool send, bool receive)
public void Broadcast(Byte[] data)
public void Broadcast(string data)
public void BroadcastAsync(Byte[] data, Action completed)
public void BroadcastAsync(string data, Action completed)
public void BroadcastAsync(Stream stream, int length, Action completed)
public Dictionary`2<string, Dictionary`2<string, bool>> Broadping()
public Dictionary`2<string, Dictionary`2<string, bool>> Broadping(string message)
public bool TryGetServiceHost(string path, WebSocketServiceHost& host)
private void <BroadcastAsync>b__38_1(Exception ex)
}
public WebSocketSharp.Server.WebSocketSessionManager : object {
private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _clean
private object _forSweep
private Logger _logger
private Dictionary`2<string, IWebSocketSession> _sessions
private ServerState modreq(System.Runtime.CompilerServices.IsVolatile) _state
private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _sweeping
private Timer _sweepTimer
private object _sync
private TimeSpan _waitTime
internal ServerState State
public IEnumerable`1<string> ActiveIDs
public int Count
public IEnumerable`1<string> IDs
public IEnumerable`1<string> InactiveIDs
public IWebSocketSession Item
public bool KeepClean
public IEnumerable`1<IWebSocketSession> Sessions
public TimeSpan WaitTime
internal void .ctor(Logger logger)
internal ServerState get_State()
public IEnumerable`1<string> get_ActiveIDs()
public int get_Count()
public IEnumerable`1<string> get_IDs()
public IEnumerable`1<string> get_InactiveIDs()
public IWebSocketSession get_Item(string id)
public bool get_KeepClean()
internal void set_KeepClean(bool value)
public IEnumerable`1<IWebSocketSession> get_Sessions()
public TimeSpan get_WaitTime()
internal void set_WaitTime(TimeSpan value)
private void broadcast(Opcode opcode, Byte[] data, Action completed)
private void broadcast(Opcode opcode, Stream stream, Action completed)
private void broadcastAsync(Opcode opcode, Byte[] data, Action completed)
private void broadcastAsync(Opcode opcode, Stream stream, Action completed)
private string createID()
private void setSweepTimer(double interval)
private bool tryGetSession(string id, IWebSocketSession& session)
internal string Add(IWebSocketSession session)
internal void Broadcast(Opcode opcode, Byte[] data, Dictionary`2<CompressionMethod, Byte[]> cache)
internal void Broadcast(Opcode opcode, Stream stream, Dictionary`2<CompressionMethod, Stream> cache)
internal Dictionary`2<string, bool> Broadping(Byte[] frameAsBytes, TimeSpan timeout)
internal bool Remove(string id)
internal void Start()
internal void Stop(CloseEventArgs e, Byte[] frameAsBytes, bool receive)
public void Broadcast(Byte[] data)
public void Broadcast(string data)
public void BroadcastAsync(Byte[] data, Action completed)
public void BroadcastAsync(string data, Action completed)
public void BroadcastAsync(Stream stream, int length, Action completed)
public Dictionary`2<string, bool> Broadping()
public Dictionary`2<string, bool> Broadping(string message)
public void CloseSession(string id)
public void CloseSession(string id, ushort code, string reason)
public void CloseSession(string id, CloseStatusCode code, string reason)
public bool PingTo(string id)
public bool PingTo(string message, string id)
public void SendTo(Byte[] data, string id)
public void SendTo(string data, string id)
public void SendToAsync(Byte[] data, string id, Action`1<bool> completed)
public void SendToAsync(string data, string id, Action`1<bool> completed)
public void SendToAsync(Stream stream, int length, string id, Action`1<bool> completed)
public void Sweep()
public bool TryGetSession(string id, IWebSocketSession& session)
private void <setSweepTimer>b__36_0(object sender, ElapsedEventArgs e)
private void <BroadcastAsync>b__49_1(Exception ex)
}
public WebSocketSharp.WebSocket : object {
private AuthenticationChallenge _authChallenge
private string _base64Key
private bool _client
private Action _closeContext
private CompressionMethod _compression
private WebSocketContext _context
private CookieCollection _cookies
private NetworkCredential _credentials
private bool _emitOnPing
private bool _enableRedirection
private AutoResetEvent _exitReceiving
private string _extensions
private bool _extensionsRequested
private object _forMessageEventQueue
private object _forSend
private object _forState
private MemoryStream _fragmentsBuffer
private bool _fragmentsCompressed
private Opcode _fragmentsOpcode
private string _guid
private Func`2<WebSocketContext, string> _handshakeRequestChecker
private bool _ignoreExtensions
private bool _inContinuation
private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _inMessage
private Logger modreq(System.Runtime.CompilerServices.IsVolatile) _logger
private Action`1<MessageEventArgs> _message
private Queue`1<MessageEventArgs> _messageEventQueue
private UInt32 _nonceCount
private string _origin
private bool _preAuth
private string _protocol
private String[] _protocols
private bool _protocolsRequested
private NetworkCredential _proxyCredentials
private Uri _proxyUri
private WebSocketState modreq(System.Runtime.CompilerServices.IsVolatile) _readyState
private AutoResetEvent _receivePong
private bool _secure
private ClientSslConfiguration _sslConfig
private Stream _stream
private TcpClient _tcpClient
private Uri _uri
private string _version
private TimeSpan _waitTime
internal Byte[] EmptyBytes
internal int FragmentLength
internal RandomNumberGenerator RandomNumber
private EventHandler`1<CloseEventArgs> OnClose
private EventHandler`1<ErrorEventArgs> OnError
private EventHandler`1<MessageEventArgs> OnMessage
private EventHandler OnOpen
internal CookieCollection CookieCollection
internal Func`2<WebSocketContext, string> CustomHandshakeRequestChecker
internal bool HasMessage
internal bool IgnoreExtensions
internal bool IsConnected
public CompressionMethod Compression
public IEnumerable`1<Cookie> Cookies
public NetworkCredential Credentials
public bool EmitOnPing
public bool EnableRedirection
public string Extensions
public bool IsAlive
public bool IsSecure
public Logger Log
public string Origin
public string Protocol
public WebSocketState ReadyState
public ClientSslConfiguration SslConfiguration
public Uri Url
public TimeSpan WaitTime
internal void .ctor(HttpListenerWebSocketContext context, string protocol)
internal void .ctor(TcpListenerWebSocketContext context, string protocol)
public void .ctor(string url, String[] protocols)
internal CookieCollection get_CookieCollection()
internal Func`2<WebSocketContext, string> get_CustomHandshakeRequestChecker()
internal void set_CustomHandshakeRequestChecker(Func`2<WebSocketContext, string> value)
internal bool get_HasMessage()
internal bool get_IgnoreExtensions()
internal void set_IgnoreExtensions(bool value)
internal bool get_IsConnected()
public CompressionMethod get_Compression()
public void set_Compression(CompressionMethod value)
public IEnumerable`1<Cookie> get_Cookies()
public NetworkCredential get_Credentials()
public bool get_EmitOnPing()
public void set_EmitOnPing(bool value)
public bool get_EnableRedirection()
public void set_EnableRedirection(bool value)
public string get_Extensions()
public bool get_IsAlive()
public bool get_IsSecure()
public Logger get_Log()
internal void set_Log(Logger value)
public string get_Origin()
public void set_Origin(string value)
public string get_Protocol()
internal void set_Protocol(string value)
public WebSocketState get_ReadyState()
public ClientSslConfiguration get_SslConfiguration()
public void set_SslConfiguration(ClientSslConfiguration value)
public Uri get_Url()
public TimeSpan get_WaitTime()
public void set_WaitTime(TimeSpan value)
public void add_OnClose(EventHandler`1<CloseEventArgs> value)
public void remove_OnClose(EventHandler`1<CloseEventArgs> value)
public void add_OnError(EventHandler`1<ErrorEventArgs> value)
public void remove_OnError(EventHandler`1<ErrorEventArgs> value)
public void add_OnMessage(EventHandler`1<MessageEventArgs> value)
public void remove_OnMessage(EventHandler`1<MessageEventArgs> value)
public void add_OnOpen(EventHandler value)
public void remove_OnOpen(EventHandler value)
private bool accept()
private bool acceptHandshake()
private bool checkHandshakeRequest(WebSocketContext context, String& message)
private bool checkHandshakeResponse(HttpResponse response, String& message)
private bool checkIfAvailable(bool connecting, bool open, bool closing, bool closed, String& message)
private bool checkIfAvailable(bool client, bool server, bool connecting, bool open, bool closing, bool closed, String& message)
private bool checkParametersForSetCredentials(string username, string password, String& message)
private bool checkParametersForSetProxy(string url, string username, string password, String& message)
private bool checkReceivedFrame(WebSocketFrame frame, String& message)
private void close(ushort code, string reason)
private void close(CloseEventArgs e, bool send, bool receive, bool received)
private void closeAsync(ushort code, string reason)
private void closeAsync(CloseEventArgs e, bool send, bool receive, bool received)
private bool closeHandshake(Byte[] frameAsBytes, bool receive, bool received)
private bool connect()
private string createExtensions()
private HttpResponse createHandshakeFailureResponse(HttpStatusCode code)
private HttpRequest createHandshakeRequest()
private HttpResponse createHandshakeResponse()
private bool customCheckHandshakeRequest(WebSocketContext context, String& message)
private MessageEventArgs dequeueFromMessageEventQueue()
private bool doHandshake()
private void enqueueToMessageEventQueue(MessageEventArgs e)
private void error(string message, Exception exception)
private void fatal(string message, Exception exception)
private void fatal(string message, CloseStatusCode code)
private void init()
private void message()
private void messagec(MessageEventArgs e)
private void messages(MessageEventArgs e)
private void open()
private bool processCloseFrame(WebSocketFrame frame)
private void processCookies(CookieCollection cookies)
private bool processDataFrame(WebSocketFrame frame)
private bool processFragmentFrame(WebSocketFrame frame)
private bool processPingFrame(WebSocketFrame frame)
private bool processPongFrame(WebSocketFrame frame)
private bool processReceivedFrame(WebSocketFrame frame)
private void processSecWebSocketExtensionsClientHeader(string value)
private void processSecWebSocketExtensionsServerHeader(string value)
private void processSecWebSocketProtocolHeader(IEnumerable`1<string> values)
private bool processUnsupportedFrame(WebSocketFrame frame)
private void releaseClientResources()
private void releaseCommonResources()
private void releaseResources()
private void releaseServerResources()
private bool send(Byte[] frameAsBytes)
private bool send(Opcode opcode, Stream stream)
private bool send(Opcode opcode, Stream stream, bool compressed)
private bool send(Fin fin, Opcode opcode, Byte[] data, bool compressed)
private void sendAsync(Opcode opcode, Stream stream, Action`1<bool> completed)
private bool sendBytes(Byte[] bytes)
private HttpResponse sendHandshakeRequest()
private HttpResponse sendHttpRequest(HttpRequest request, int millisecondsTimeout)
private bool sendHttpResponse(HttpResponse response)
private void sendProxyConnectRequest()
private void setClientStream()
private void startReceiving()
private bool validateSecWebSocketAcceptHeader(string value)
private bool validateSecWebSocketExtensionsClientHeader(string value)
private bool validateSecWebSocketExtensionsServerHeader(string value)
private bool validateSecWebSocketKeyHeader(string value)
private bool validateSecWebSocketProtocolClientHeader(string value)
private bool validateSecWebSocketProtocolServerHeader(string value)
private bool validateSecWebSocketVersionClientHeader(string value)
private bool validateSecWebSocketVersionServerHeader(string value)
internal bool CheckParametersForClose(ushort code, string reason, bool client, String& message)
internal bool CheckParametersForClose(CloseStatusCode code, string reason, bool client, String& message)
internal string CheckPingParameter(string message, Byte[]& bytes)
internal string CheckSendParameter(Byte[] data)
internal string CheckSendParameter(FileInfo file)
internal string CheckSendParameter(string data)
internal string CheckSendParameters(Stream stream, int length)
internal void Close(HttpResponse response)
internal void Close(HttpStatusCode code)
internal void Close(CloseEventArgs e, Byte[] frameAsBytes, bool receive)
internal string CreateBase64Key()
internal string CreateResponseKey(string base64Key)
internal void InternalAccept()
internal bool Ping(Byte[] frameAsBytes, TimeSpan timeout)
internal void Send(Opcode opcode, Byte[] data, Dictionary`2<CompressionMethod, Byte[]> cache)
internal void Send(Opcode opcode, Stream stream, Dictionary`2<CompressionMethod, Stream> cache)
public void Accept()
public void AcceptAsync()
public void Close()
public void Close(ushort code)
public void Close(CloseStatusCode code)
public void Close(ushort code, string reason)
public void Close(CloseStatusCode code, string reason)
public void CloseAsync()
public void CloseAsync(ushort code)
public void CloseAsync(CloseStatusCode code)
public void CloseAsync(ushort code, string reason)
public void CloseAsync(CloseStatusCode code, string reason)
public void Connect()
public void ConnectAsync()
public bool Ping()
public bool Ping(string message)
public void Send(Byte[] data)
public void Send(FileInfo file)
public void Send(string data)
public void SendAsync(Byte[] data, Action`1<bool> completed)
public void SendAsync(FileInfo file, Action`1<bool> completed)
public void SendAsync(string data, Action`1<bool> completed)
public void SendAsync(Stream stream, int length, Action`1<bool> completed)
public void SetCookie(Cookie cookie)
public void SetCredentials(string username, string password, bool preAuth)
public void SetProxy(string url, string username, string password)
private void System.IDisposable.Dispose()
private void <open>b__143_0(IAsyncResult ar)
private bool <processSecWebSocketProtocolHeader>b__153_0(string p)
private void <startReceiving>b__170_2(Exception ex)
private void <SendAsync>b__217_1(Exception ex)
}
public WebSocketSharp.WebSocketException : Exception {
private CloseStatusCode _code
public CloseStatusCode Code
internal void .ctor(Exception innerException)
internal void .ctor(string message)
internal void .ctor(CloseStatusCode code)
internal void .ctor(string message, Exception innerException)
internal void .ctor(CloseStatusCode code, Exception innerException)
internal void .ctor(CloseStatusCode code, string message)
internal void .ctor(CloseStatusCode code, string message, Exception innerException)
public CloseStatusCode get_Code()
}
internal WebSocketSharp.WebSocketFrame : object {
private Byte[] _extPayloadLength
private Fin _fin
private Mask _mask
private Byte[] _maskingKey
private Opcode _opcode
private PayloadData _payloadData
private byte _payloadLength
private Rsv _rsv1
private Rsv _rsv2
private Rsv _rsv3
internal Byte[] EmptyPingBytes
internal int ExtendedPayloadLengthCount
internal ulong FullPayloadLength
public Byte[] ExtendedPayloadLength
public Fin Fin
public bool IsBinary
public bool IsClose
public bool IsCompressed
public bool IsContinuation
public bool IsControl
public bool IsData
public bool IsFinal
public bool IsFragment
public bool IsMasked
public bool IsPing
public bool IsPong
public bool IsText
public ulong Length
public Mask Mask
public Byte[] MaskingKey
public Opcode Opcode
public PayloadData PayloadData
public byte PayloadLength
public Rsv Rsv1
public Rsv Rsv2
public Rsv Rsv3
internal void .ctor(Opcode opcode, PayloadData payloadData, bool mask)
internal void .ctor(Fin fin, Opcode opcode, Byte[] data, bool compressed, bool mask)
internal void .ctor(Fin fin, Opcode opcode, PayloadData payloadData, bool compressed, bool mask)
internal int get_ExtendedPayloadLengthCount()
internal ulong get_FullPayloadLength()
public Byte[] get_ExtendedPayloadLength()
public Fin get_Fin()
public bool get_IsBinary()
public bool get_IsClose()
public bool get_IsCompressed()
public bool get_IsContinuation()
public bool get_IsControl()
public bool get_IsData()
public bool get_IsFinal()
public bool get_IsFragment()
public bool get_IsMasked()
public bool get_IsPing()
public bool get_IsPong()
public bool get_IsText()
public ulong get_Length()
public Mask get_Mask()
public Byte[] get_MaskingKey()
public Opcode get_Opcode()
public PayloadData get_PayloadData()
public byte get_PayloadLength()
public Rsv get_Rsv1()
public Rsv get_Rsv2()
public Rsv get_Rsv3()
private Byte[] createMaskingKey()
private string dump(WebSocketFrame frame)
private string print(WebSocketFrame frame)
private WebSocketFrame processHeader(Byte[] header)
private WebSocketFrame readExtendedPayloadLength(Stream stream, WebSocketFrame frame)
private void readExtendedPayloadLengthAsync(Stream stream, WebSocketFrame frame, Action`1<WebSocketFrame> completed, Action`1<Exception> error)
private WebSocketFrame readHeader(Stream stream)
private void readHeaderAsync(Stream stream, Action`1<WebSocketFrame> completed, Action`1<Exception> error)
private WebSocketFrame readMaskingKey(Stream stream, WebSocketFrame frame)
private void readMaskingKeyAsync(Stream stream, WebSocketFrame frame, Action`1<WebSocketFrame> completed, Action`1<Exception> error)
private WebSocketFrame readPayloadData(Stream stream, WebSocketFrame frame)
private void readPayloadDataAsync(Stream stream, WebSocketFrame frame, Action`1<WebSocketFrame> completed, Action`1<Exception> error)
internal WebSocketFrame CreateCloseFrame(PayloadData payloadData, bool mask)
internal WebSocketFrame CreatePingFrame(bool mask)
internal WebSocketFrame CreatePingFrame(Byte[] data, bool mask)
internal WebSocketFrame ReadFrame(Stream stream, bool unmask)
internal void ReadFrameAsync(Stream stream, bool unmask, Action`1<WebSocketFrame> completed, Action`1<Exception> error)
internal void Unmask()
public IEnumerator`1<byte> GetEnumerator()
public void Print(bool dumped)
public string PrintToString(bool dumped)
public Byte[] ToArray()
public string ToString()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
}
public WebSocketSharp.WebSocketState : Enum {
public ushort value__
public WebSocketState Connecting
public WebSocketState Open
public WebSocketState Closing
public WebSocketState Closed
}
