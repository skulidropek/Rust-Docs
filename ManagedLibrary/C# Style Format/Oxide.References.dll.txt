internal static class Consts : object {
    public static string MonoVersion;
    public static string MonoCompany;
    public static string MonoProduct;
    public static string MonoCopyright;
    public static string FxVersion;
    public static string VsVersion;
    public static string FxFileVersion;
    public static string VsFileVersion;
    public static string AssemblyI18N;
    public static string AssemblyMicrosoft_VisualStudio;
    public static string AssemblyMicrosoft_VisualStudio_Web;
    public static string AssemblyMicrosoft_VSDesigner;
    public static string AssemblyMono_Http;
    public static string AssemblyMono_Posix;
    public static string AssemblyMono_Security;
    public static string AssemblyMono_Messaging_RabbitMQ;
    public static string AssemblyCorlib;
    public static string AssemblySystem;
    public static string AssemblySystem_Data;
    public static string AssemblySystem_Design;
    public static string AssemblySystem_DirectoryServices;
    public static string AssemblySystem_Drawing;
    public static string AssemblySystem_Drawing_Design;
    public static string AssemblySystem_Messaging;
    public static string AssemblySystem_Security;
    public static string AssemblySystem_ServiceProcess;
    public static string AssemblySystem_Web;
    public static string AssemblySystem_Windows_Forms;
    public static string AssemblySystem_Core;
}
internal class Locale : object {
    public static string GetText(string msg);
    public static string GetText(string fmt, Object[] args);
}
[AttributeUsageAttribute("4380")]
internal class MapAttribute : Attribute {
    private string nativeType;
    private string suppressFlags;
    public string NativeType { get; }
    public string SuppressFlags { get; public set; }
    public MapAttribute(string nativeType);
    public string get_NativeType();
    public string get_SuppressFlags();
    public void set_SuppressFlags(string value);
}
public class Mono.Cecil.ArrayDimension : ValueType {
    private Nullable`1<int> lower_bound;
    private Nullable`1<int> upper_bound;
    public Nullable`1<int> LowerBound { get; public set; }
    public Nullable`1<int> UpperBound { get; public set; }
    public bool IsSized { get; }
    public ArrayDimension(Nullable`1<int> lowerBound, Nullable`1<int> upperBound);
    public Nullable`1<int> get_LowerBound();
    public void set_LowerBound(Nullable`1<int> value);
    public Nullable`1<int> get_UpperBound();
    public void set_UpperBound(Nullable`1<int> value);
    public bool get_IsSized();
    public virtual string ToString();
}
public class Mono.Cecil.ArrayMarshalInfo : MarshalInfo {
    internal NativeType element_type;
    internal int size_parameter_index;
    internal int size;
    internal int size_parameter_multiplier;
    public NativeType ElementType { get; public set; }
    public int SizeParameterIndex { get; public set; }
    public int Size { get; public set; }
    public int SizeParameterMultiplier { get; public set; }
    public NativeType get_ElementType();
    public void set_ElementType(NativeType value);
    public int get_SizeParameterIndex();
    public void set_SizeParameterIndex(int value);
    public int get_Size();
    public void set_Size(int value);
    public int get_SizeParameterMultiplier();
    public void set_SizeParameterMultiplier(int value);
}
public class Mono.Cecil.ArrayType : TypeSpecification {
    private Collection`1<ArrayDimension> dimensions;
    public Collection`1<ArrayDimension> Dimensions { get; }
    public int Rank { get; }
    public bool IsVector { get; }
    public bool IsValueType { get; public set; }
    public string Name { get; }
    public string FullName { get; }
    private string Suffix { get; }
    public bool IsArray { get; }
    public ArrayType(TypeReference type);
    public ArrayType(TypeReference type, int rank);
    public Collection`1<ArrayDimension> get_Dimensions();
    public int get_Rank();
    public bool get_IsVector();
    public virtual bool get_IsValueType();
    public virtual void set_IsValueType(bool value);
    public virtual string get_Name();
    public virtual string get_FullName();
    private string get_Suffix();
    public virtual bool get_IsArray();
}
[FlagsAttribute]
public enum Mono.Cecil.AssemblyAttributes : Enum {
    public UInt32 value__;
    public static AssemblyAttributes PublicKey;
    public static AssemblyAttributes SideBySideCompatible;
    public static AssemblyAttributes Retargetable;
    public static AssemblyAttributes WindowsRuntime;
    public static AssemblyAttributes DisableJITCompileOptimizer;
    public static AssemblyAttributes EnableJITCompileTracking;
}
public class Mono.Cecil.AssemblyDefinition : object {
    private AssemblyNameDefinition name;
    internal ModuleDefinition main_module;
    private Collection`1<ModuleDefinition> modules;
    private Collection`1<CustomAttribute> custom_attributes;
    private Collection`1<SecurityDeclaration> security_declarations;
    public AssemblyNameDefinition Name { get; public set; }
    public string FullName { get; }
    public MetadataToken MetadataToken { get; public set; }
    public Collection`1<ModuleDefinition> Modules { get; }
    public ModuleDefinition MainModule { get; }
    public MethodDefinition EntryPoint { get; public set; }
    public bool HasCustomAttributes { get; }
    public Collection`1<CustomAttribute> CustomAttributes { get; }
    public bool HasSecurityDeclarations { get; }
    public Collection`1<SecurityDeclaration> SecurityDeclarations { get; }
    public AssemblyNameDefinition get_Name();
    public void set_Name(AssemblyNameDefinition value);
    public string get_FullName();
    public sealed virtual MetadataToken get_MetadataToken();
    public sealed virtual void set_MetadataToken(MetadataToken value);
    public Collection`1<ModuleDefinition> get_Modules();
    public ModuleDefinition get_MainModule();
    public MethodDefinition get_EntryPoint();
    public void set_EntryPoint(MethodDefinition value);
    public sealed virtual bool get_HasCustomAttributes();
    public sealed virtual Collection`1<CustomAttribute> get_CustomAttributes();
    public sealed virtual bool get_HasSecurityDeclarations();
    public sealed virtual Collection`1<SecurityDeclaration> get_SecurityDeclarations();
    public static AssemblyDefinition CreateAssembly(AssemblyNameDefinition assemblyName, string moduleName, ModuleKind kind);
    public static AssemblyDefinition CreateAssembly(AssemblyNameDefinition assemblyName, string moduleName, ModuleParameters parameters);
    public static AssemblyDefinition ReadAssembly(string fileName);
    public static AssemblyDefinition ReadAssembly(string fileName, ReaderParameters parameters);
    public static AssemblyDefinition ReadAssembly(Stream stream);
    public static AssemblyDefinition ReadAssembly(Stream stream, ReaderParameters parameters);
    private static AssemblyDefinition ReadAssembly(ModuleDefinition module);
    public void Write(string fileName);
    public void Write(Stream stream);
    public void Write(string fileName, WriterParameters parameters);
    public void Write(Stream stream, WriterParameters parameters);
    public virtual string ToString();
}
public enum Mono.Cecil.AssemblyHashAlgorithm : Enum {
    public UInt32 value__;
    public static AssemblyHashAlgorithm None;
    public static AssemblyHashAlgorithm Reserved;
    public static AssemblyHashAlgorithm SHA1;
}
public class Mono.Cecil.AssemblyLinkedResource : Resource {
    private AssemblyNameReference reference;
    public AssemblyNameReference Assembly { get; public set; }
    public ResourceType ResourceType { get; }
    public AssemblyLinkedResource(string name, ManifestResourceAttributes flags);
    public AssemblyLinkedResource(string name, ManifestResourceAttributes flags, AssemblyNameReference reference);
    public AssemblyNameReference get_Assembly();
    public void set_Assembly(AssemblyNameReference value);
    public virtual ResourceType get_ResourceType();
}
public class Mono.Cecil.AssemblyNameDefinition : AssemblyNameReference {
    public Byte[] Hash { get; }
    public AssemblyNameDefinition(string name, Version version);
    public virtual Byte[] get_Hash();
}
public class Mono.Cecil.AssemblyNameReference : object {
    private string name;
    private string culture;
    private Version version;
    private UInt32 attributes;
    private Byte[] public_key;
    private Byte[] public_key_token;
    private AssemblyHashAlgorithm hash_algorithm;
    private Byte[] hash;
    internal MetadataToken token;
    private string full_name;
    public string Name { get; public set; }
    public string Culture { get; public set; }
    public Version Version { get; public set; }
    public AssemblyAttributes Attributes { get; public set; }
    public bool HasPublicKey { get; public set; }
    public bool IsSideBySideCompatible { get; public set; }
    public bool IsRetargetable { get; public set; }
    public bool IsWindowsRuntime { get; public set; }
    public Byte[] PublicKey { get; public set; }
    public Byte[] PublicKeyToken { get; public set; }
    public MetadataScopeType MetadataScopeType { get; }
    public string FullName { get; }
    public AssemblyHashAlgorithm HashAlgorithm { get; public set; }
    public Byte[] Hash { get; public set; }
    public MetadataToken MetadataToken { get; public set; }
    public AssemblyNameReference(string name, Version version);
    public sealed virtual string get_Name();
    public sealed virtual void set_Name(string value);
    public string get_Culture();
    public void set_Culture(string value);
    public Version get_Version();
    public void set_Version(Version value);
    public AssemblyAttributes get_Attributes();
    public void set_Attributes(AssemblyAttributes value);
    public bool get_HasPublicKey();
    public void set_HasPublicKey(bool value);
    public bool get_IsSideBySideCompatible();
    public void set_IsSideBySideCompatible(bool value);
    public bool get_IsRetargetable();
    public void set_IsRetargetable(bool value);
    public bool get_IsWindowsRuntime();
    public void set_IsWindowsRuntime(bool value);
    public Byte[] get_PublicKey();
    public void set_PublicKey(Byte[] value);
    public Byte[] get_PublicKeyToken();
    public void set_PublicKeyToken(Byte[] value);
    private Byte[] HashPublicKey();
    public virtual MetadataScopeType get_MetadataScopeType();
    public string get_FullName();
    public static AssemblyNameReference Parse(string fullName);
    public AssemblyHashAlgorithm get_HashAlgorithm();
    public void set_HashAlgorithm(AssemblyHashAlgorithm value);
    public virtual Byte[] get_Hash();
    public virtual void set_Hash(Byte[] value);
    public sealed virtual MetadataToken get_MetadataToken();
    public sealed virtual void set_MetadataToken(MetadataToken value);
    public virtual string ToString();
}
internal class Mono.Cecil.AssemblyRefTable : MetadataTable`1<Row`9<ushort, ushort, ushort, ushort, AssemblyAttributes, UInt32, UInt32, UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
}
public class Mono.Cecil.AssemblyResolutionException : FileNotFoundException {
    private AssemblyNameReference reference;
    public AssemblyNameReference AssemblyReference { get; }
    public AssemblyResolutionException(AssemblyNameReference reference);
    protected AssemblyResolutionException(SerializationInfo info, StreamingContext context);
    public AssemblyNameReference get_AssemblyReference();
}
public class Mono.Cecil.AssemblyResolveEventArgs : EventArgs {
    private AssemblyNameReference reference;
    public AssemblyNameReference AssemblyReference { get; }
    public AssemblyResolveEventArgs(AssemblyNameReference reference);
    public AssemblyNameReference get_AssemblyReference();
}
public class Mono.Cecil.AssemblyResolveEventHandler : MulticastDelegate {
    public AssemblyResolveEventHandler(object object, IntPtr method);
    public virtual AssemblyDefinition Invoke(object sender, AssemblyNameReference reference);
    public virtual IAsyncResult BeginInvoke(object sender, AssemblyNameReference reference, AsyncCallback callback, object object);
    public virtual AssemblyDefinition EndInvoke(IAsyncResult result);
}
internal class Mono.Cecil.AssemblyTable : OneRowTable`1<Row`9<AssemblyHashAlgorithm, ushort, ushort, ushort, ushort, AssemblyAttributes, UInt32, UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
}
public abstract class Mono.Cecil.BaseAssemblyResolver : object {
    private static bool on_mono;
    private Collection`1<string> directories;
    private Collection`1<string> gac_paths;
    [CompilerGeneratedAttribute]
private AssemblyResolveEventHandler ResolveFailure;
    private static BaseAssemblyResolver();
    public void AddSearchDirectory(string directory);
    public void RemoveSearchDirectory(string directory);
    public String[] GetSearchDirectories();
    public virtual AssemblyDefinition Resolve(string fullName);
    public virtual AssemblyDefinition Resolve(string fullName, ReaderParameters parameters);
    [CompilerGeneratedAttribute]
public void add_ResolveFailure(AssemblyResolveEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_ResolveFailure(AssemblyResolveEventHandler value);
    private AssemblyDefinition GetAssembly(string file, ReaderParameters parameters);
    public virtual AssemblyDefinition Resolve(AssemblyNameReference name);
    public virtual AssemblyDefinition Resolve(AssemblyNameReference name, ReaderParameters parameters);
    private AssemblyDefinition SearchDirectory(AssemblyNameReference name, IEnumerable`1<string> directories, ReaderParameters parameters);
    private static bool IsZero(Version version);
    private AssemblyDefinition GetCorlib(AssemblyNameReference reference, ReaderParameters parameters);
    private static Collection`1<string> GetGacPaths();
    private static Collection`1<string> GetDefaultMonoGacPaths();
    private static string GetCurrentMonoGac();
    private AssemblyDefinition GetAssemblyInGac(AssemblyNameReference reference, ReaderParameters parameters);
    private AssemblyDefinition GetAssemblyInMonoGac(AssemblyNameReference reference, ReaderParameters parameters);
    private AssemblyDefinition GetAssemblyInNetGac(AssemblyNameReference reference, ReaderParameters parameters);
    private static string GetAssemblyFile(AssemblyNameReference reference, string prefix, string gac);
}
public class Mono.Cecil.ByReferenceType : TypeSpecification {
    public string Name { get; }
    public string FullName { get; }
    public bool IsValueType { get; public set; }
    public bool IsByReference { get; }
    public ByReferenceType(TypeReference type);
    public virtual string get_Name();
    public virtual string get_FullName();
    public virtual bool get_IsValueType();
    public virtual void set_IsValueType(bool value);
    public virtual bool get_IsByReference();
}
public class Mono.Cecil.CallSite : object {
    private MethodReference signature;
    public bool HasThis { get; public set; }
    public bool ExplicitThis { get; public set; }
    public MethodCallingConvention CallingConvention { get; public set; }
    public bool HasParameters { get; }
    public Collection`1<ParameterDefinition> Parameters { get; }
    public TypeReference ReturnType { get; public set; }
    public MethodReturnType MethodReturnType { get; }
    public string Name { get; public set; }
    public string Namespace { get; public set; }
    public ModuleDefinition Module { get; }
    public IMetadataScope Scope { get; }
    public MetadataToken MetadataToken { get; public set; }
    public string FullName { get; }
    public CallSite(TypeReference returnType);
    public sealed virtual bool get_HasThis();
    public sealed virtual void set_HasThis(bool value);
    public sealed virtual bool get_ExplicitThis();
    public sealed virtual void set_ExplicitThis(bool value);
    public sealed virtual MethodCallingConvention get_CallingConvention();
    public sealed virtual void set_CallingConvention(MethodCallingConvention value);
    public sealed virtual bool get_HasParameters();
    public sealed virtual Collection`1<ParameterDefinition> get_Parameters();
    public sealed virtual TypeReference get_ReturnType();
    public sealed virtual void set_ReturnType(TypeReference value);
    public sealed virtual MethodReturnType get_MethodReturnType();
    public string get_Name();
    public void set_Name(string value);
    public string get_Namespace();
    public void set_Namespace(string value);
    public ModuleDefinition get_Module();
    public IMetadataScope get_Scope();
    public sealed virtual MetadataToken get_MetadataToken();
    public sealed virtual void set_MetadataToken(MetadataToken value);
    public string get_FullName();
    public virtual string ToString();
}
public enum Mono.Cecil.Cil.Code : Enum {
    public int value__;
    public static Code Nop;
    public static Code Break;
    public static Code Ldarg_0;
    public static Code Ldarg_1;
    public static Code Ldarg_2;
    public static Code Ldarg_3;
    public static Code Ldloc_0;
    public static Code Ldloc_1;
    public static Code Ldloc_2;
    public static Code Ldloc_3;
    public static Code Stloc_0;
    public static Code Stloc_1;
    public static Code Stloc_2;
    public static Code Stloc_3;
    public static Code Ldarg_S;
    public static Code Ldarga_S;
    public static Code Starg_S;
    public static Code Ldloc_S;
    public static Code Ldloca_S;
    public static Code Stloc_S;
    public static Code Ldnull;
    public static Code Ldc_I4_M1;
    public static Code Ldc_I4_0;
    public static Code Ldc_I4_1;
    public static Code Ldc_I4_2;
    public static Code Ldc_I4_3;
    public static Code Ldc_I4_4;
    public static Code Ldc_I4_5;
    public static Code Ldc_I4_6;
    public static Code Ldc_I4_7;
    public static Code Ldc_I4_8;
    public static Code Ldc_I4_S;
    public static Code Ldc_I4;
    public static Code Ldc_I8;
    public static Code Ldc_R4;
    public static Code Ldc_R8;
    public static Code Dup;
    public static Code Pop;
    public static Code Jmp;
    public static Code Call;
    public static Code Calli;
    public static Code Ret;
    public static Code Br_S;
    public static Code Brfalse_S;
    public static Code Brtrue_S;
    public static Code Beq_S;
    public static Code Bge_S;
    public static Code Bgt_S;
    public static Code Ble_S;
    public static Code Blt_S;
    public static Code Bne_Un_S;
    public static Code Bge_Un_S;
    public static Code Bgt_Un_S;
    public static Code Ble_Un_S;
    public static Code Blt_Un_S;
    public static Code Br;
    public static Code Brfalse;
    public static Code Brtrue;
    public static Code Beq;
    public static Code Bge;
    public static Code Bgt;
    public static Code Ble;
    public static Code Blt;
    public static Code Bne_Un;
    public static Code Bge_Un;
    public static Code Bgt_Un;
    public static Code Ble_Un;
    public static Code Blt_Un;
    public static Code Switch;
    public static Code Ldind_I1;
    public static Code Ldind_U1;
    public static Code Ldind_I2;
    public static Code Ldind_U2;
    public static Code Ldind_I4;
    public static Code Ldind_U4;
    public static Code Ldind_I8;
    public static Code Ldind_I;
    public static Code Ldind_R4;
    public static Code Ldind_R8;
    public static Code Ldind_Ref;
    public static Code Stind_Ref;
    public static Code Stind_I1;
    public static Code Stind_I2;
    public static Code Stind_I4;
    public static Code Stind_I8;
    public static Code Stind_R4;
    public static Code Stind_R8;
    public static Code Add;
    public static Code Sub;
    public static Code Mul;
    public static Code Div;
    public static Code Div_Un;
    public static Code Rem;
    public static Code Rem_Un;
    public static Code And;
    public static Code Or;
    public static Code Xor;
    public static Code Shl;
    public static Code Shr;
    public static Code Shr_Un;
    public static Code Neg;
    public static Code Not;
    public static Code Conv_I1;
    public static Code Conv_I2;
    public static Code Conv_I4;
    public static Code Conv_I8;
    public static Code Conv_R4;
    public static Code Conv_R8;
    public static Code Conv_U4;
    public static Code Conv_U8;
    public static Code Callvirt;
    public static Code Cpobj;
    public static Code Ldobj;
    public static Code Ldstr;
    public static Code Newobj;
    public static Code Castclass;
    public static Code Isinst;
    public static Code Conv_R_Un;
    public static Code Unbox;
    public static Code Throw;
    public static Code Ldfld;
    public static Code Ldflda;
    public static Code Stfld;
    public static Code Ldsfld;
    public static Code Ldsflda;
    public static Code Stsfld;
    public static Code Stobj;
    public static Code Conv_Ovf_I1_Un;
    public static Code Conv_Ovf_I2_Un;
    public static Code Conv_Ovf_I4_Un;
    public static Code Conv_Ovf_I8_Un;
    public static Code Conv_Ovf_U1_Un;
    public static Code Conv_Ovf_U2_Un;
    public static Code Conv_Ovf_U4_Un;
    public static Code Conv_Ovf_U8_Un;
    public static Code Conv_Ovf_I_Un;
    public static Code Conv_Ovf_U_Un;
    public static Code Box;
    public static Code Newarr;
    public static Code Ldlen;
    public static Code Ldelema;
    public static Code Ldelem_I1;
    public static Code Ldelem_U1;
    public static Code Ldelem_I2;
    public static Code Ldelem_U2;
    public static Code Ldelem_I4;
    public static Code Ldelem_U4;
    public static Code Ldelem_I8;
    public static Code Ldelem_I;
    public static Code Ldelem_R4;
    public static Code Ldelem_R8;
    public static Code Ldelem_Ref;
    public static Code Stelem_I;
    public static Code Stelem_I1;
    public static Code Stelem_I2;
    public static Code Stelem_I4;
    public static Code Stelem_I8;
    public static Code Stelem_R4;
    public static Code Stelem_R8;
    public static Code Stelem_Ref;
    public static Code Ldelem_Any;
    public static Code Stelem_Any;
    public static Code Unbox_Any;
    public static Code Conv_Ovf_I1;
    public static Code Conv_Ovf_U1;
    public static Code Conv_Ovf_I2;
    public static Code Conv_Ovf_U2;
    public static Code Conv_Ovf_I4;
    public static Code Conv_Ovf_U4;
    public static Code Conv_Ovf_I8;
    public static Code Conv_Ovf_U8;
    public static Code Refanyval;
    public static Code Ckfinite;
    public static Code Mkrefany;
    public static Code Ldtoken;
    public static Code Conv_U2;
    public static Code Conv_U1;
    public static Code Conv_I;
    public static Code Conv_Ovf_I;
    public static Code Conv_Ovf_U;
    public static Code Add_Ovf;
    public static Code Add_Ovf_Un;
    public static Code Mul_Ovf;
    public static Code Mul_Ovf_Un;
    public static Code Sub_Ovf;
    public static Code Sub_Ovf_Un;
    public static Code Endfinally;
    public static Code Leave;
    public static Code Leave_S;
    public static Code Stind_I;
    public static Code Conv_U;
    public static Code Arglist;
    public static Code Ceq;
    public static Code Cgt;
    public static Code Cgt_Un;
    public static Code Clt;
    public static Code Clt_Un;
    public static Code Ldftn;
    public static Code Ldvirtftn;
    public static Code Ldarg;
    public static Code Ldarga;
    public static Code Starg;
    public static Code Ldloc;
    public static Code Ldloca;
    public static Code Stloc;
    public static Code Localloc;
    public static Code Endfilter;
    public static Code Unaligned;
    public static Code Volatile;
    public static Code Tail;
    public static Code Initobj;
    public static Code Constrained;
    public static Code Cpblk;
    public static Code Initblk;
    public static Code No;
    public static Code Rethrow;
    public static Code Sizeof;
    public static Code Refanytype;
    public static Code Readonly;
}
internal class Mono.Cecil.Cil.CodeReader : ByteBuffer {
    internal MetadataReader reader;
    private int start;
    private Section code_section;
    private MethodDefinition method;
    private MethodBody body;
    private int Offset { get; }
    public CodeReader(Section section, MetadataReader reader);
    private int get_Offset();
    public MethodBody ReadMethodBody(MethodDefinition method);
    public void MoveTo(int rva);
    private bool IsInSection(int rva);
    private void ReadMethodBody();
    private void ReadFatMethod();
    public VariableDefinitionCollection ReadVariables(MetadataToken local_var_token);
    private void ReadCode();
    private OpCode ReadOpCode();
    private object ReadOperand(Instruction instruction);
    public string GetString(MetadataToken token);
    public ParameterDefinition GetParameter(int index);
    public VariableDefinition GetVariable(int index);
    public CallSite GetCallSite(MetadataToken token);
    private void ResolveBranches(Collection`1<Instruction> instructions);
    private Instruction GetInstruction(int offset);
    private static Instruction GetInstruction(Collection`1<Instruction> instructions, int offset);
    private void ReadSection();
    private void ReadSmallSection();
    private void ReadFatSection();
    private void ReadExceptionHandlers(int count, Func`1<int> read_entry, Func`1<int> read_length);
    private void ReadExceptionHandlerSpecific(ExceptionHandler handler);
    private void Align(int align);
    public MetadataToken ReadToken();
    public ByteBuffer PatchRawMethodBody(MethodDefinition method, CodeWriter writer, MethodSymbols& symbols);
    private void PatchRawFatMethod(ByteBuffer buffer, MethodSymbols symbols, CodeWriter writer, MetadataToken& local_var_token);
    private static MetadataToken GetOriginalToken(MetadataBuilder metadata, MethodDefinition method);
    private void PatchRawCode(ByteBuffer buffer, int code_size, CodeWriter writer);
    private void PatchRawSection(ByteBuffer buffer, MetadataBuilder metadata);
    private void PatchRawSmallSection(ByteBuffer buffer, MetadataBuilder metadata);
    private void PatchRawFatSection(ByteBuffer buffer, MetadataBuilder metadata);
    private void PatchRawExceptionHandlers(ByteBuffer buffer, MetadataBuilder metadata, int count, bool fat_entry);
    [CompilerGeneratedAttribute]
private int <ReadSmallSection>b__25_0();
    [CompilerGeneratedAttribute]
private int <ReadSmallSection>b__25_1();
}
internal class Mono.Cecil.Cil.CodeWriter : ByteBuffer {
    private UInt32 code_base;
    internal MetadataBuilder metadata;
    private Dictionary`2<UInt32, MetadataToken> standalone_signatures;
    private UInt32 current;
    private MethodBody body;
    public CodeWriter(MetadataBuilder metadata);
    public UInt32 WriteMethodBody(MethodDefinition method);
    private static bool IsEmptyMethodBody(MethodBody body);
    private static bool IsUnresolved(MethodDefinition method);
    private void WriteUnresolvedMethodBody(MethodDefinition method);
    private static MetadataToken GetLocalVarToken(ByteBuffer buffer, MethodSymbols symbols);
    private void WriteResolvedMethodBody(MethodDefinition method);
    private void WriteFatHeader();
    private void WriteInstructions();
    private void WriteOpCode(OpCode opcode);
    private void WriteOperand(Instruction instruction);
    private int GetTargetOffset(Instruction instruction);
    private UInt32 GetUserStringIndex(string string);
    private static int GetVariableIndex(VariableDefinition variable);
    private int GetParameterIndex(ParameterDefinition parameter);
    private bool RequiresFatHeader();
    private void ComputeHeader();
    private void ComputeExceptionHandlerStackSize(Dictionary`2& stack_sizes);
    private static void AddExceptionStackSize(Instruction handler_start, Dictionary`2& stack_sizes);
    private static void ComputeStackSize(Instruction instruction, Dictionary`2& stack_sizes, Int32& stack_size, Int32& max_stack);
    private static void CopyBranchStackSize(Instruction instruction, Dictionary`2& stack_sizes, int stack_size);
    private static void CopyBranchStackSize(Dictionary`2& stack_sizes, Instruction target, int stack_size);
    private static void ComputeStackSize(Instruction instruction, Int32& stack_size);
    private static void ComputeStackDelta(Instruction instruction, Int32& stack_size);
    private static void ComputePopDelta(StackBehaviour pop_behavior, Int32& stack_size);
    private static void ComputePushDelta(StackBehaviour push_behaviour, Int32& stack_size);
    private void WriteExceptionHandlers();
    private static bool RequiresFatSection(Collection`1<ExceptionHandler> handlers);
    private static bool IsFatRange(Instruction start, Instruction end);
    private void WriteSmallSection(Collection`1<ExceptionHandler> handlers);
    private void WriteFatSection(Collection`1<ExceptionHandler> handlers);
    private void WriteExceptionHandlers(Collection`1<ExceptionHandler> handlers, Action`1<int> write_entry, Action`1<int> write_length);
    private void WriteExceptionHandlerSpecific(ExceptionHandler handler);
    public MetadataToken GetStandAloneSignature(Collection`1<VariableDefinition> variables);
    public MetadataToken GetStandAloneSignature(CallSite call_site);
    private MetadataToken GetStandAloneSignatureToken(UInt32 signature);
    private UInt32 BeginMethod();
    private void WriteMetadataToken(MetadataToken token);
    private void Align(int align);
    private void EndMethod();
    [CompilerGeneratedAttribute]
private void <WriteSmallSection>b__34_0(int i);
    [CompilerGeneratedAttribute]
private void <WriteSmallSection>b__34_1(int i);
}
public class Mono.Cecil.Cil.Document : object {
    private string url;
    private byte type;
    private byte hash_algorithm;
    private byte language;
    private byte language_vendor;
    private Byte[] hash;
    public string Url { get; public set; }
    public DocumentType Type { get; public set; }
    public DocumentHashAlgorithm HashAlgorithm { get; public set; }
    public DocumentLanguage Language { get; public set; }
    public DocumentLanguageVendor LanguageVendor { get; public set; }
    public Byte[] Hash { get; public set; }
    public Document(string url);
    public string get_Url();
    public void set_Url(string value);
    public DocumentType get_Type();
    public void set_Type(DocumentType value);
    public DocumentHashAlgorithm get_HashAlgorithm();
    public void set_HashAlgorithm(DocumentHashAlgorithm value);
    public DocumentLanguage get_Language();
    public void set_Language(DocumentLanguage value);
    public DocumentLanguageVendor get_LanguageVendor();
    public void set_LanguageVendor(DocumentLanguageVendor value);
    public Byte[] get_Hash();
    public void set_Hash(Byte[] value);
}
public enum Mono.Cecil.Cil.DocumentHashAlgorithm : Enum {
    public int value__;
    public static DocumentHashAlgorithm None;
    public static DocumentHashAlgorithm MD5;
    public static DocumentHashAlgorithm SHA1;
}
public enum Mono.Cecil.Cil.DocumentLanguage : Enum {
    public int value__;
    public static DocumentLanguage Other;
    public static DocumentLanguage C;
    public static DocumentLanguage Cpp;
    public static DocumentLanguage CSharp;
    public static DocumentLanguage Basic;
    public static DocumentLanguage Java;
    public static DocumentLanguage Cobol;
    public static DocumentLanguage Pascal;
    public static DocumentLanguage Cil;
    public static DocumentLanguage JScript;
    public static DocumentLanguage Smc;
    public static DocumentLanguage MCpp;
    public static DocumentLanguage FSharp;
}
public enum Mono.Cecil.Cil.DocumentLanguageVendor : Enum {
    public int value__;
    public static DocumentLanguageVendor Other;
    public static DocumentLanguageVendor Microsoft;
}
public enum Mono.Cecil.Cil.DocumentType : Enum {
    public int value__;
    public static DocumentType Other;
    public static DocumentType Text;
}
public class Mono.Cecil.Cil.ExceptionHandler : object {
    private Instruction try_start;
    private Instruction try_end;
    private Instruction filter_start;
    private Instruction handler_start;
    private Instruction handler_end;
    private TypeReference catch_type;
    private ExceptionHandlerType handler_type;
    public Instruction TryStart { get; public set; }
    public Instruction TryEnd { get; public set; }
    public Instruction FilterStart { get; public set; }
    public Instruction HandlerStart { get; public set; }
    public Instruction HandlerEnd { get; public set; }
    public TypeReference CatchType { get; public set; }
    public ExceptionHandlerType HandlerType { get; public set; }
    public ExceptionHandler(ExceptionHandlerType handlerType);
    public Instruction get_TryStart();
    public void set_TryStart(Instruction value);
    public Instruction get_TryEnd();
    public void set_TryEnd(Instruction value);
    public Instruction get_FilterStart();
    public void set_FilterStart(Instruction value);
    public Instruction get_HandlerStart();
    public void set_HandlerStart(Instruction value);
    public Instruction get_HandlerEnd();
    public void set_HandlerEnd(Instruction value);
    public TypeReference get_CatchType();
    public void set_CatchType(TypeReference value);
    public ExceptionHandlerType get_HandlerType();
    public void set_HandlerType(ExceptionHandlerType value);
}
public enum Mono.Cecil.Cil.ExceptionHandlerType : Enum {
    public int value__;
    public static ExceptionHandlerType Catch;
    public static ExceptionHandlerType Filter;
    public static ExceptionHandlerType Finally;
    public static ExceptionHandlerType Fault;
}
public enum Mono.Cecil.Cil.FlowControl : Enum {
    public int value__;
    public static FlowControl Branch;
    public static FlowControl Break;
    public static FlowControl Call;
    public static FlowControl Cond_Branch;
    public static FlowControl Meta;
    public static FlowControl Next;
    public static FlowControl Phi;
    public static FlowControl Return;
    public static FlowControl Throw;
}
public class Mono.Cecil.Cil.ILProcessor : object {
    private MethodBody body;
    private Collection`1<Instruction> instructions;
    public MethodBody Body { get; }
    internal ILProcessor(MethodBody body);
    public MethodBody get_Body();
    public Instruction Create(OpCode opcode);
    public Instruction Create(OpCode opcode, TypeReference type);
    public Instruction Create(OpCode opcode, CallSite site);
    public Instruction Create(OpCode opcode, MethodReference method);
    public Instruction Create(OpCode opcode, FieldReference field);
    public Instruction Create(OpCode opcode, string value);
    public Instruction Create(OpCode opcode, sbyte value);
    public Instruction Create(OpCode opcode, byte value);
    public Instruction Create(OpCode opcode, int value);
    public Instruction Create(OpCode opcode, long value);
    public Instruction Create(OpCode opcode, float value);
    public Instruction Create(OpCode opcode, double value);
    public Instruction Create(OpCode opcode, Instruction target);
    public Instruction Create(OpCode opcode, Instruction[] targets);
    public Instruction Create(OpCode opcode, VariableDefinition variable);
    public Instruction Create(OpCode opcode, ParameterDefinition parameter);
    public void Emit(OpCode opcode);
    public void Emit(OpCode opcode, TypeReference type);
    public void Emit(OpCode opcode, MethodReference method);
    public void Emit(OpCode opcode, CallSite site);
    public void Emit(OpCode opcode, FieldReference field);
    public void Emit(OpCode opcode, string value);
    public void Emit(OpCode opcode, byte value);
    public void Emit(OpCode opcode, sbyte value);
    public void Emit(OpCode opcode, int value);
    public void Emit(OpCode opcode, long value);
    public void Emit(OpCode opcode, float value);
    public void Emit(OpCode opcode, double value);
    public void Emit(OpCode opcode, Instruction target);
    public void Emit(OpCode opcode, Instruction[] targets);
    public void Emit(OpCode opcode, VariableDefinition variable);
    public void Emit(OpCode opcode, ParameterDefinition parameter);
    public void InsertBefore(Instruction target, Instruction instruction);
    public void InsertAfter(Instruction target, Instruction instruction);
    public void Append(Instruction instruction);
    public void Replace(Instruction target, Instruction instruction);
    public void Remove(Instruction instruction);
}
public class Mono.Cecil.Cil.ImageDebugDirectory : ValueType {
    public int Characteristics;
    public int TimeDateStamp;
    public short MajorVersion;
    public short MinorVersion;
    public int Type;
    public int SizeOfData;
    public int AddressOfRawData;
    public int PointerToRawData;
}
public class Mono.Cecil.Cil.Instruction : object {
    internal int offset;
    internal OpCode opcode;
    internal object operand;
    internal Instruction previous;
    internal Instruction next;
    private SequencePoint sequence_point;
    public int Offset { get; public set; }
    public OpCode OpCode { get; public set; }
    public object Operand { get; public set; }
    public Instruction Previous { get; public set; }
    public Instruction Next { get; public set; }
    public SequencePoint SequencePoint { get; public set; }
    internal Instruction(int offset, OpCode opCode);
    internal Instruction(OpCode opcode, object operand);
    public int get_Offset();
    public void set_Offset(int value);
    public OpCode get_OpCode();
    public void set_OpCode(OpCode value);
    public object get_Operand();
    public void set_Operand(object value);
    public Instruction get_Previous();
    public void set_Previous(Instruction value);
    public Instruction get_Next();
    public void set_Next(Instruction value);
    public SequencePoint get_SequencePoint();
    public void set_SequencePoint(SequencePoint value);
    public int GetSize();
    public virtual string ToString();
    private static void AppendLabel(StringBuilder builder, Instruction instruction);
    public static Instruction Create(OpCode opcode);
    public static Instruction Create(OpCode opcode, TypeReference type);
    public static Instruction Create(OpCode opcode, CallSite site);
    public static Instruction Create(OpCode opcode, MethodReference method);
    public static Instruction Create(OpCode opcode, FieldReference field);
    public static Instruction Create(OpCode opcode, string value);
    public static Instruction Create(OpCode opcode, sbyte value);
    public static Instruction Create(OpCode opcode, byte value);
    public static Instruction Create(OpCode opcode, int value);
    public static Instruction Create(OpCode opcode, long value);
    public static Instruction Create(OpCode opcode, float value);
    public static Instruction Create(OpCode opcode, double value);
    public static Instruction Create(OpCode opcode, Instruction target);
    public static Instruction Create(OpCode opcode, Instruction[] targets);
    public static Instruction Create(OpCode opcode, VariableDefinition variable);
    public static Instruction Create(OpCode opcode, ParameterDefinition parameter);
}
internal class Mono.Cecil.Cil.InstructionCollection : Collection`1<Instruction> {
    internal InstructionCollection(int capacity);
    protected virtual void OnAdd(Instruction item, int index);
    protected virtual void OnInsert(Instruction item, int index);
    protected virtual void OnSet(Instruction item, int index);
    protected virtual void OnRemove(Instruction item, int index);
}
public class Mono.Cecil.Cil.InstructionMapper : MulticastDelegate {
    public InstructionMapper(object object, IntPtr method);
    public virtual Instruction Invoke(int offset);
    public virtual IAsyncResult BeginInvoke(int offset, AsyncCallback callback, object object);
    public virtual Instruction EndInvoke(IAsyncResult result);
}
public class Mono.Cecil.Cil.InstructionSymbol : ValueType {
    public int Offset;
    public SequencePoint SequencePoint;
    public InstructionSymbol(int offset, SequencePoint sequencePoint);
}
public interface Mono.Cecil.Cil.ISymbolReader {
    public abstract virtual bool ProcessDebugHeader(ImageDebugDirectory directory, Byte[] header);
    public abstract virtual void Read(MethodBody body, InstructionMapper mapper);
    public abstract virtual void Read(MethodSymbols symbols);
}
public interface Mono.Cecil.Cil.ISymbolReaderProvider {
    public abstract virtual ISymbolReader GetSymbolReader(ModuleDefinition module, string fileName);
    public abstract virtual ISymbolReader GetSymbolReader(ModuleDefinition module, Stream symbolStream);
}
public interface Mono.Cecil.Cil.ISymbolWriter {
    public abstract virtual bool GetDebugHeader(ImageDebugDirectory& directory, Byte[]& header);
    public abstract virtual void Write(MethodBody body);
    public abstract virtual void Write(MethodSymbols symbols);
}
public interface Mono.Cecil.Cil.ISymbolWriterProvider {
    public abstract virtual ISymbolWriter GetSymbolWriter(ModuleDefinition module, string fileName);
    public abstract virtual ISymbolWriter GetSymbolWriter(ModuleDefinition module, Stream symbolStream);
}
public interface Mono.Cecil.Cil.IVariableDefinitionProvider {
    public bool HasVariables { get; }
    public Collection`1<VariableDefinition> Variables { get; }
    public abstract virtual bool get_HasVariables();
    public abstract virtual Collection`1<VariableDefinition> get_Variables();
}
public class Mono.Cecil.Cil.MethodBody : object {
    internal MethodDefinition method;
    internal ParameterDefinition this_parameter;
    internal int max_stack_size;
    internal int code_size;
    internal bool init_locals;
    internal MetadataToken local_var_token;
    internal Collection`1<Instruction> instructions;
    internal Collection`1<ExceptionHandler> exceptions;
    internal Collection`1<VariableDefinition> variables;
    private Scope scope;
    public MethodDefinition Method { get; }
    public int MaxStackSize { get; public set; }
    public int CodeSize { get; }
    public bool InitLocals { get; public set; }
    public MetadataToken LocalVarToken { get; public set; }
    public Collection`1<Instruction> Instructions { get; }
    public bool HasExceptionHandlers { get; }
    public Collection`1<ExceptionHandler> ExceptionHandlers { get; }
    public bool HasVariables { get; }
    public Collection`1<VariableDefinition> Variables { get; }
    public Scope Scope { get; public set; }
    public ParameterDefinition ThisParameter { get; }
    public MethodBody(MethodDefinition method);
    public MethodDefinition get_Method();
    public int get_MaxStackSize();
    public void set_MaxStackSize(int value);
    public int get_CodeSize();
    public bool get_InitLocals();
    public void set_InitLocals(bool value);
    public MetadataToken get_LocalVarToken();
    public void set_LocalVarToken(MetadataToken value);
    public Collection`1<Instruction> get_Instructions();
    public bool get_HasExceptionHandlers();
    public Collection`1<ExceptionHandler> get_ExceptionHandlers();
    public sealed virtual bool get_HasVariables();
    public sealed virtual Collection`1<VariableDefinition> get_Variables();
    public Scope get_Scope();
    public void set_Scope(Scope value);
    public ParameterDefinition get_ThisParameter();
    private static ParameterDefinition CreateThisParameter(MethodDefinition method);
    public ILProcessor GetILProcessor();
}
public class Mono.Cecil.Cil.MethodSymbols : object {
    internal int code_size;
    internal string method_name;
    internal MetadataToken method_token;
    internal MetadataToken local_var_token;
    internal Collection`1<VariableDefinition> variables;
    internal Collection`1<InstructionSymbol> instructions;
    public bool HasVariables { get; }
    public Collection`1<VariableDefinition> Variables { get; }
    public Collection`1<InstructionSymbol> Instructions { get; }
    public int CodeSize { get; }
    public string MethodName { get; }
    public MetadataToken MethodToken { get; }
    public MetadataToken LocalVarToken { get; }
    internal MethodSymbols(string methodName);
    public MethodSymbols(MetadataToken methodToken);
    public bool get_HasVariables();
    public Collection`1<VariableDefinition> get_Variables();
    public Collection`1<InstructionSymbol> get_Instructions();
    public int get_CodeSize();
    public string get_MethodName();
    public MetadataToken get_MethodToken();
    public MetadataToken get_LocalVarToken();
}
public class Mono.Cecil.Cil.OpCode : ValueType {
    private byte op1;
    private byte op2;
    private byte code;
    private byte flow_control;
    private byte opcode_type;
    private byte operand_type;
    private byte stack_behavior_pop;
    private byte stack_behavior_push;
    public string Name { get; }
    public int Size { get; }
    public byte Op1 { get; }
    public byte Op2 { get; }
    public short Value { get; }
    public Code Code { get; }
    public FlowControl FlowControl { get; }
    public OpCodeType OpCodeType { get; }
    public OperandType OperandType { get; }
    public StackBehaviour StackBehaviourPop { get; }
    public StackBehaviour StackBehaviourPush { get; }
    internal OpCode(int x, int y);
    public string get_Name();
    public int get_Size();
    public byte get_Op1();
    public byte get_Op2();
    public short get_Value();
    public Code get_Code();
    public FlowControl get_FlowControl();
    public OpCodeType get_OpCodeType();
    public OperandType get_OperandType();
    public StackBehaviour get_StackBehaviourPop();
    public StackBehaviour get_StackBehaviourPush();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public bool Equals(OpCode opcode);
    public static bool op_Equality(OpCode one, OpCode other);
    public static bool op_Inequality(OpCode one, OpCode other);
    public virtual string ToString();
}
internal static class Mono.Cecil.Cil.OpCodeNames : object {
    internal static String[] names;
    private static OpCodeNames();
}
public static class Mono.Cecil.Cil.OpCodes : object {
    internal static OpCode[] OneByteOpCode;
    internal static OpCode[] TwoBytesOpCode;
    public static OpCode Nop;
    public static OpCode Break;
    public static OpCode Ldarg_0;
    public static OpCode Ldarg_1;
    public static OpCode Ldarg_2;
    public static OpCode Ldarg_3;
    public static OpCode Ldloc_0;
    public static OpCode Ldloc_1;
    public static OpCode Ldloc_2;
    public static OpCode Ldloc_3;
    public static OpCode Stloc_0;
    public static OpCode Stloc_1;
    public static OpCode Stloc_2;
    public static OpCode Stloc_3;
    public static OpCode Ldarg_S;
    public static OpCode Ldarga_S;
    public static OpCode Starg_S;
    public static OpCode Ldloc_S;
    public static OpCode Ldloca_S;
    public static OpCode Stloc_S;
    public static OpCode Ldnull;
    public static OpCode Ldc_I4_M1;
    public static OpCode Ldc_I4_0;
    public static OpCode Ldc_I4_1;
    public static OpCode Ldc_I4_2;
    public static OpCode Ldc_I4_3;
    public static OpCode Ldc_I4_4;
    public static OpCode Ldc_I4_5;
    public static OpCode Ldc_I4_6;
    public static OpCode Ldc_I4_7;
    public static OpCode Ldc_I4_8;
    public static OpCode Ldc_I4_S;
    public static OpCode Ldc_I4;
    public static OpCode Ldc_I8;
    public static OpCode Ldc_R4;
    public static OpCode Ldc_R8;
    public static OpCode Dup;
    public static OpCode Pop;
    public static OpCode Jmp;
    public static OpCode Call;
    public static OpCode Calli;
    public static OpCode Ret;
    public static OpCode Br_S;
    public static OpCode Brfalse_S;
    public static OpCode Brtrue_S;
    public static OpCode Beq_S;
    public static OpCode Bge_S;
    public static OpCode Bgt_S;
    public static OpCode Ble_S;
    public static OpCode Blt_S;
    public static OpCode Bne_Un_S;
    public static OpCode Bge_Un_S;
    public static OpCode Bgt_Un_S;
    public static OpCode Ble_Un_S;
    public static OpCode Blt_Un_S;
    public static OpCode Br;
    public static OpCode Brfalse;
    public static OpCode Brtrue;
    public static OpCode Beq;
    public static OpCode Bge;
    public static OpCode Bgt;
    public static OpCode Ble;
    public static OpCode Blt;
    public static OpCode Bne_Un;
    public static OpCode Bge_Un;
    public static OpCode Bgt_Un;
    public static OpCode Ble_Un;
    public static OpCode Blt_Un;
    public static OpCode Switch;
    public static OpCode Ldind_I1;
    public static OpCode Ldind_U1;
    public static OpCode Ldind_I2;
    public static OpCode Ldind_U2;
    public static OpCode Ldind_I4;
    public static OpCode Ldind_U4;
    public static OpCode Ldind_I8;
    public static OpCode Ldind_I;
    public static OpCode Ldind_R4;
    public static OpCode Ldind_R8;
    public static OpCode Ldind_Ref;
    public static OpCode Stind_Ref;
    public static OpCode Stind_I1;
    public static OpCode Stind_I2;
    public static OpCode Stind_I4;
    public static OpCode Stind_I8;
    public static OpCode Stind_R4;
    public static OpCode Stind_R8;
    public static OpCode Add;
    public static OpCode Sub;
    public static OpCode Mul;
    public static OpCode Div;
    public static OpCode Div_Un;
    public static OpCode Rem;
    public static OpCode Rem_Un;
    public static OpCode And;
    public static OpCode Or;
    public static OpCode Xor;
    public static OpCode Shl;
    public static OpCode Shr;
    public static OpCode Shr_Un;
    public static OpCode Neg;
    public static OpCode Not;
    public static OpCode Conv_I1;
    public static OpCode Conv_I2;
    public static OpCode Conv_I4;
    public static OpCode Conv_I8;
    public static OpCode Conv_R4;
    public static OpCode Conv_R8;
    public static OpCode Conv_U4;
    public static OpCode Conv_U8;
    public static OpCode Callvirt;
    public static OpCode Cpobj;
    public static OpCode Ldobj;
    public static OpCode Ldstr;
    public static OpCode Newobj;
    public static OpCode Castclass;
    public static OpCode Isinst;
    public static OpCode Conv_R_Un;
    public static OpCode Unbox;
    public static OpCode Throw;
    public static OpCode Ldfld;
    public static OpCode Ldflda;
    public static OpCode Stfld;
    public static OpCode Ldsfld;
    public static OpCode Ldsflda;
    public static OpCode Stsfld;
    public static OpCode Stobj;
    public static OpCode Conv_Ovf_I1_Un;
    public static OpCode Conv_Ovf_I2_Un;
    public static OpCode Conv_Ovf_I4_Un;
    public static OpCode Conv_Ovf_I8_Un;
    public static OpCode Conv_Ovf_U1_Un;
    public static OpCode Conv_Ovf_U2_Un;
    public static OpCode Conv_Ovf_U4_Un;
    public static OpCode Conv_Ovf_U8_Un;
    public static OpCode Conv_Ovf_I_Un;
    public static OpCode Conv_Ovf_U_Un;
    public static OpCode Box;
    public static OpCode Newarr;
    public static OpCode Ldlen;
    public static OpCode Ldelema;
    public static OpCode Ldelem_I1;
    public static OpCode Ldelem_U1;
    public static OpCode Ldelem_I2;
    public static OpCode Ldelem_U2;
    public static OpCode Ldelem_I4;
    public static OpCode Ldelem_U4;
    public static OpCode Ldelem_I8;
    public static OpCode Ldelem_I;
    public static OpCode Ldelem_R4;
    public static OpCode Ldelem_R8;
    public static OpCode Ldelem_Ref;
    public static OpCode Stelem_I;
    public static OpCode Stelem_I1;
    public static OpCode Stelem_I2;
    public static OpCode Stelem_I4;
    public static OpCode Stelem_I8;
    public static OpCode Stelem_R4;
    public static OpCode Stelem_R8;
    public static OpCode Stelem_Ref;
    public static OpCode Ldelem_Any;
    public static OpCode Stelem_Any;
    public static OpCode Unbox_Any;
    public static OpCode Conv_Ovf_I1;
    public static OpCode Conv_Ovf_U1;
    public static OpCode Conv_Ovf_I2;
    public static OpCode Conv_Ovf_U2;
    public static OpCode Conv_Ovf_I4;
    public static OpCode Conv_Ovf_U4;
    public static OpCode Conv_Ovf_I8;
    public static OpCode Conv_Ovf_U8;
    public static OpCode Refanyval;
    public static OpCode Ckfinite;
    public static OpCode Mkrefany;
    public static OpCode Ldtoken;
    public static OpCode Conv_U2;
    public static OpCode Conv_U1;
    public static OpCode Conv_I;
    public static OpCode Conv_Ovf_I;
    public static OpCode Conv_Ovf_U;
    public static OpCode Add_Ovf;
    public static OpCode Add_Ovf_Un;
    public static OpCode Mul_Ovf;
    public static OpCode Mul_Ovf_Un;
    public static OpCode Sub_Ovf;
    public static OpCode Sub_Ovf_Un;
    public static OpCode Endfinally;
    public static OpCode Leave;
    public static OpCode Leave_S;
    public static OpCode Stind_I;
    public static OpCode Conv_U;
    public static OpCode Arglist;
    public static OpCode Ceq;
    public static OpCode Cgt;
    public static OpCode Cgt_Un;
    public static OpCode Clt;
    public static OpCode Clt_Un;
    public static OpCode Ldftn;
    public static OpCode Ldvirtftn;
    public static OpCode Ldarg;
    public static OpCode Ldarga;
    public static OpCode Starg;
    public static OpCode Ldloc;
    public static OpCode Ldloca;
    public static OpCode Stloc;
    public static OpCode Localloc;
    public static OpCode Endfilter;
    public static OpCode Unaligned;
    public static OpCode Volatile;
    public static OpCode Tail;
    public static OpCode Initobj;
    public static OpCode Constrained;
    public static OpCode Cpblk;
    public static OpCode Initblk;
    public static OpCode No;
    public static OpCode Rethrow;
    public static OpCode Sizeof;
    public static OpCode Refanytype;
    public static OpCode Readonly;
    private static OpCodes();
}
public enum Mono.Cecil.Cil.OpCodeType : Enum {
    public int value__;
    public static OpCodeType Annotation;
    public static OpCodeType Macro;
    public static OpCodeType Nternal;
    public static OpCodeType Objmodel;
    public static OpCodeType Prefix;
    public static OpCodeType Primitive;
}
public enum Mono.Cecil.Cil.OperandType : Enum {
    public int value__;
    public static OperandType InlineBrTarget;
    public static OperandType InlineField;
    public static OperandType InlineI;
    public static OperandType InlineI8;
    public static OperandType InlineMethod;
    public static OperandType InlineNone;
    public static OperandType InlinePhi;
    public static OperandType InlineR;
    public static OperandType InlineSig;
    public static OperandType InlineString;
    public static OperandType InlineSwitch;
    public static OperandType InlineTok;
    public static OperandType InlineType;
    public static OperandType InlineVar;
    public static OperandType InlineArg;
    public static OperandType ShortInlineBrTarget;
    public static OperandType ShortInlineI;
    public static OperandType ShortInlineR;
    public static OperandType ShortInlineVar;
    public static OperandType ShortInlineArg;
}
public class Mono.Cecil.Cil.Scope : object {
    private Instruction start;
    private Instruction end;
    private Collection`1<Scope> scopes;
    private Collection`1<VariableDefinition> variables;
    public Instruction Start { get; public set; }
    public Instruction End { get; public set; }
    public bool HasScopes { get; }
    public Collection`1<Scope> Scopes { get; }
    public bool HasVariables { get; }
    public Collection`1<VariableDefinition> Variables { get; }
    public Instruction get_Start();
    public void set_Start(Instruction value);
    public Instruction get_End();
    public void set_End(Instruction value);
    public bool get_HasScopes();
    public Collection`1<Scope> get_Scopes();
    public sealed virtual bool get_HasVariables();
    public sealed virtual Collection`1<VariableDefinition> get_Variables();
}
public class Mono.Cecil.Cil.SequencePoint : object {
    private Document document;
    private int start_line;
    private int start_column;
    private int end_line;
    private int end_column;
    public int StartLine { get; public set; }
    public int StartColumn { get; public set; }
    public int EndLine { get; public set; }
    public int EndColumn { get; public set; }
    public Document Document { get; public set; }
    public SequencePoint(Document document);
    public int get_StartLine();
    public void set_StartLine(int value);
    public int get_StartColumn();
    public void set_StartColumn(int value);
    public int get_EndLine();
    public void set_EndLine(int value);
    public int get_EndColumn();
    public void set_EndColumn(int value);
    public Document get_Document();
    public void set_Document(Document value);
}
public enum Mono.Cecil.Cil.StackBehaviour : Enum {
    public int value__;
    public static StackBehaviour Pop0;
    public static StackBehaviour Pop1;
    public static StackBehaviour Pop1_pop1;
    public static StackBehaviour Popi;
    public static StackBehaviour Popi_pop1;
    public static StackBehaviour Popi_popi;
    public static StackBehaviour Popi_popi8;
    public static StackBehaviour Popi_popi_popi;
    public static StackBehaviour Popi_popr4;
    public static StackBehaviour Popi_popr8;
    public static StackBehaviour Popref;
    public static StackBehaviour Popref_pop1;
    public static StackBehaviour Popref_popi;
    public static StackBehaviour Popref_popi_popi;
    public static StackBehaviour Popref_popi_popi8;
    public static StackBehaviour Popref_popi_popr4;
    public static StackBehaviour Popref_popi_popr8;
    public static StackBehaviour Popref_popi_popref;
    public static StackBehaviour PopAll;
    public static StackBehaviour Push0;
    public static StackBehaviour Push1;
    public static StackBehaviour Push1_push1;
    public static StackBehaviour Pushi;
    public static StackBehaviour Pushi8;
    public static StackBehaviour Pushr4;
    public static StackBehaviour Pushr8;
    public static StackBehaviour Pushref;
    public static StackBehaviour Varpop;
    public static StackBehaviour Varpush;
}
internal static class Mono.Cecil.Cil.SymbolProvider : object {
    private static string symbol_kind;
    private static ISymbolReaderProvider reader_provider;
    private static ISymbolWriterProvider writer_provider;
    private static SymbolProvider();
    private static AssemblyName GetPlatformSymbolAssemblyName();
    private static Type GetPlatformType(string fullname);
    public static ISymbolReaderProvider GetPlatformReaderProvider();
    private static string GetProviderTypeName(string name);
    public static ISymbolWriterProvider GetPlatformWriterProvider();
}
public class Mono.Cecil.Cil.VariableDefinition : VariableReference {
    public bool IsPinned { get; }
    public VariableDefinition(TypeReference variableType);
    public VariableDefinition(string name, TypeReference variableType);
    public bool get_IsPinned();
    public virtual VariableDefinition Resolve();
}
internal class Mono.Cecil.Cil.VariableDefinitionCollection : Collection`1<VariableDefinition> {
    internal VariableDefinitionCollection(int capacity);
    protected virtual void OnAdd(VariableDefinition item, int index);
    protected virtual void OnInsert(VariableDefinition item, int index);
    protected virtual void OnSet(VariableDefinition item, int index);
    protected virtual void OnRemove(VariableDefinition item, int index);
}
public abstract class Mono.Cecil.Cil.VariableReference : object {
    private string name;
    internal int index;
    protected TypeReference variable_type;
    public string Name { get; public set; }
    public TypeReference VariableType { get; public set; }
    public int Index { get; }
    internal VariableReference(TypeReference variable_type);
    internal VariableReference(string name, TypeReference variable_type);
    public string get_Name();
    public void set_Name(string value);
    public TypeReference get_VariableType();
    public void set_VariableType(TypeReference value);
    public int get_Index();
    public abstract virtual VariableDefinition Resolve();
    public virtual string ToString();
}
internal class Mono.Cecil.ClassLayoutTable : SortedTable`1<Row`3<ushort, UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
    public virtual int Compare(Row`3<ushort, UInt32, UInt32> x, Row`3<ushort, UInt32, UInt32> y);
}
internal class Mono.Cecil.ConstantTable : SortedTable`1<Row`3<ElementType, UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
    public virtual int Compare(Row`3<ElementType, UInt32, UInt32> x, Row`3<ElementType, UInt32, UInt32> y);
}
internal static class Mono.Cecil.CryptoService : object {
    public static void StrongName(Stream stream, ImageWriter writer, StrongNameKeyPair key_pair);
    private static void PatchStrongName(Stream stream, int strong_name_pointer, Byte[] strong_name);
    private static Byte[] CreateStrongName(StrongNameKeyPair key_pair, Byte[] hash);
    private static Byte[] HashStream(Stream stream, ImageWriter writer, Int32& strong_name_pointer);
    private static void CopyStreamChunk(Stream stream, Stream dest_stream, Byte[] buffer, int length);
    public static Byte[] ComputeHash(string file);
}
public class Mono.Cecil.CustomAttribute : object {
    internal UInt32 signature;
    internal bool resolved;
    private MethodReference constructor;
    private Byte[] blob;
    internal Collection`1<CustomAttributeArgument> arguments;
    internal Collection`1<CustomAttributeNamedArgument> fields;
    internal Collection`1<CustomAttributeNamedArgument> properties;
    public MethodReference Constructor { get; public set; }
    public TypeReference AttributeType { get; }
    public bool IsResolved { get; }
    public bool HasConstructorArguments { get; }
    public Collection`1<CustomAttributeArgument> ConstructorArguments { get; }
    public bool HasFields { get; }
    public Collection`1<CustomAttributeNamedArgument> Fields { get; }
    public bool HasProperties { get; }
    public Collection`1<CustomAttributeNamedArgument> Properties { get; }
    internal bool HasImage { get; }
    internal ModuleDefinition Module { get; }
    internal CustomAttribute(UInt32 signature, MethodReference constructor);
    public CustomAttribute(MethodReference constructor);
    public CustomAttribute(MethodReference constructor, Byte[] blob);
    public MethodReference get_Constructor();
    public void set_Constructor(MethodReference value);
    public sealed virtual TypeReference get_AttributeType();
    public bool get_IsResolved();
    public bool get_HasConstructorArguments();
    public Collection`1<CustomAttributeArgument> get_ConstructorArguments();
    public sealed virtual bool get_HasFields();
    public sealed virtual Collection`1<CustomAttributeNamedArgument> get_Fields();
    public sealed virtual bool get_HasProperties();
    public sealed virtual Collection`1<CustomAttributeNamedArgument> get_Properties();
    internal bool get_HasImage();
    internal ModuleDefinition get_Module();
    public Byte[] GetBlob();
    private void Resolve();
    [CompilerGeneratedAttribute]
private CustomAttribute <Resolve>b__34_0(CustomAttribute attribute, MetadataReader reader);
}
public class Mono.Cecil.CustomAttributeArgument : ValueType {
    private TypeReference type;
    private object value;
    public TypeReference Type { get; }
    public object Value { get; }
    public CustomAttributeArgument(TypeReference type, object value);
    public TypeReference get_Type();
    public object get_Value();
}
public class Mono.Cecil.CustomAttributeNamedArgument : ValueType {
    private string name;
    private CustomAttributeArgument argument;
    public string Name { get; }
    public CustomAttributeArgument Argument { get; }
    public CustomAttributeNamedArgument(string name, CustomAttributeArgument argument);
    public string get_Name();
    public CustomAttributeArgument get_Argument();
}
internal class Mono.Cecil.CustomAttributeTable : SortedTable`1<Row`3<UInt32, UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
    public virtual int Compare(Row`3<UInt32, UInt32, UInt32> x, Row`3<UInt32, UInt32, UInt32> y);
}
public class Mono.Cecil.CustomMarshalInfo : MarshalInfo {
    internal Guid guid;
    internal string unmanaged_type;
    internal TypeReference managed_type;
    internal string cookie;
    public Guid Guid { get; public set; }
    public string UnmanagedType { get; public set; }
    public TypeReference ManagedType { get; public set; }
    public string Cookie { get; public set; }
    public Guid get_Guid();
    public void set_Guid(Guid value);
    public string get_UnmanagedType();
    public void set_UnmanagedType(string value);
    public TypeReference get_ManagedType();
    public void set_ManagedType(TypeReference value);
    public string get_Cookie();
    public void set_Cookie(string value);
}
internal class Mono.Cecil.DeclSecurityTable : SortedTable`1<Row`3<SecurityAction, UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
    public virtual int Compare(Row`3<SecurityAction, UInt32, UInt32> x, Row`3<SecurityAction, UInt32, UInt32> y);
}
public class Mono.Cecil.DefaultAssemblyResolver : BaseAssemblyResolver {
    private IDictionary`2<string, AssemblyDefinition> cache;
    public virtual AssemblyDefinition Resolve(AssemblyNameReference name);
    protected void RegisterAssembly(AssemblyDefinition assembly);
}
internal class Mono.Cecil.DeferredModuleReader : ModuleReader {
    public DeferredModuleReader(Image image);
    protected virtual void ReadModule();
    [CompilerGeneratedAttribute]
private ModuleDefinition <ReadModule>b__1_0(ModuleDefinition module, MetadataReader reader);
}
public class Mono.Cecil.EmbeddedResource : Resource {
    private MetadataReader reader;
    private Nullable`1<UInt32> offset;
    private Byte[] data;
    private Stream stream;
    public ResourceType ResourceType { get; }
    public EmbeddedResource(string name, ManifestResourceAttributes attributes, Byte[] data);
    public EmbeddedResource(string name, ManifestResourceAttributes attributes, Stream stream);
    internal EmbeddedResource(string name, ManifestResourceAttributes attributes, UInt32 offset, MetadataReader reader);
    public virtual ResourceType get_ResourceType();
    public Stream GetResourceStream();
    public Byte[] GetResourceData();
    private static Byte[] ReadStream(Stream stream);
}
[FlagsAttribute]
public enum Mono.Cecil.EventAttributes : Enum {
    public ushort value__;
    public static EventAttributes None;
    public static EventAttributes SpecialName;
    public static EventAttributes RTSpecialName;
}
public class Mono.Cecil.EventDefinition : EventReference {
    private ushort attributes;
    private Collection`1<CustomAttribute> custom_attributes;
    internal MethodDefinition add_method;
    internal MethodDefinition invoke_method;
    internal MethodDefinition remove_method;
    internal Collection`1<MethodDefinition> other_methods;
    public EventAttributes Attributes { get; public set; }
    public MethodDefinition AddMethod { get; public set; }
    public MethodDefinition InvokeMethod { get; public set; }
    public MethodDefinition RemoveMethod { get; public set; }
    public bool HasOtherMethods { get; }
    public Collection`1<MethodDefinition> OtherMethods { get; }
    public bool HasCustomAttributes { get; }
    public Collection`1<CustomAttribute> CustomAttributes { get; }
    public bool IsSpecialName { get; public set; }
    public bool IsRuntimeSpecialName { get; public set; }
    public TypeDefinition DeclaringType { get; public set; }
    public bool IsDefinition { get; }
    public EventDefinition(string name, EventAttributes attributes, TypeReference eventType);
    public EventAttributes get_Attributes();
    public void set_Attributes(EventAttributes value);
    public MethodDefinition get_AddMethod();
    public void set_AddMethod(MethodDefinition value);
    public MethodDefinition get_InvokeMethod();
    public void set_InvokeMethod(MethodDefinition value);
    public MethodDefinition get_RemoveMethod();
    public void set_RemoveMethod(MethodDefinition value);
    public bool get_HasOtherMethods();
    public Collection`1<MethodDefinition> get_OtherMethods();
    public sealed virtual bool get_HasCustomAttributes();
    public sealed virtual Collection`1<CustomAttribute> get_CustomAttributes();
    public sealed virtual bool get_IsSpecialName();
    public sealed virtual void set_IsSpecialName(bool value);
    public sealed virtual bool get_IsRuntimeSpecialName();
    public sealed virtual void set_IsRuntimeSpecialName(bool value);
    public sealed virtual TypeDefinition get_DeclaringType();
    public sealed virtual void set_DeclaringType(TypeDefinition value);
    public virtual bool get_IsDefinition();
    private void InitializeMethods();
    public virtual EventDefinition Resolve();
}
internal class Mono.Cecil.EventMapTable : MetadataTable`1<Row`2<UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
}
public abstract class Mono.Cecil.EventReference : MemberReference {
    private TypeReference event_type;
    public TypeReference EventType { get; public set; }
    public string FullName { get; }
    protected EventReference(string name, TypeReference eventType);
    public TypeReference get_EventType();
    public void set_EventType(TypeReference value);
    public virtual string get_FullName();
    public abstract virtual EventDefinition Resolve();
}
internal class Mono.Cecil.EventTable : MetadataTable`1<Row`3<EventAttributes, UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
}
public class Mono.Cecil.ExportedType : object {
    private string namespace;
    private string name;
    private UInt32 attributes;
    private IMetadataScope scope;
    private ModuleDefinition module;
    private int identifier;
    private ExportedType declaring_type;
    internal MetadataToken token;
    public string Namespace { get; public set; }
    public string Name { get; public set; }
    public TypeAttributes Attributes { get; public set; }
    public IMetadataScope Scope { get; }
    public ExportedType DeclaringType { get; public set; }
    public MetadataToken MetadataToken { get; public set; }
    public int Identifier { get; public set; }
    public bool IsNotPublic { get; public set; }
    public bool IsPublic { get; public set; }
    public bool IsNestedPublic { get; public set; }
    public bool IsNestedPrivate { get; public set; }
    public bool IsNestedFamily { get; public set; }
    public bool IsNestedAssembly { get; public set; }
    public bool IsNestedFamilyAndAssembly { get; public set; }
    public bool IsNestedFamilyOrAssembly { get; public set; }
    public bool IsAutoLayout { get; public set; }
    public bool IsSequentialLayout { get; public set; }
    public bool IsExplicitLayout { get; public set; }
    public bool IsClass { get; public set; }
    public bool IsInterface { get; public set; }
    public bool IsAbstract { get; public set; }
    public bool IsSealed { get; public set; }
    public bool IsSpecialName { get; public set; }
    public bool IsImport { get; public set; }
    public bool IsSerializable { get; public set; }
    public bool IsAnsiClass { get; public set; }
    public bool IsUnicodeClass { get; public set; }
    public bool IsAutoClass { get; public set; }
    public bool IsBeforeFieldInit { get; public set; }
    public bool IsRuntimeSpecialName { get; public set; }
    public bool HasSecurity { get; public set; }
    public bool IsForwarder { get; public set; }
    public string FullName { get; }
    public ExportedType(string namespace, string name, ModuleDefinition module, IMetadataScope scope);
    public string get_Namespace();
    public void set_Namespace(string value);
    public string get_Name();
    public void set_Name(string value);
    public TypeAttributes get_Attributes();
    public void set_Attributes(TypeAttributes value);
    public IMetadataScope get_Scope();
    public ExportedType get_DeclaringType();
    public void set_DeclaringType(ExportedType value);
    public sealed virtual MetadataToken get_MetadataToken();
    public sealed virtual void set_MetadataToken(MetadataToken value);
    public int get_Identifier();
    public void set_Identifier(int value);
    public bool get_IsNotPublic();
    public void set_IsNotPublic(bool value);
    public bool get_IsPublic();
    public void set_IsPublic(bool value);
    public bool get_IsNestedPublic();
    public void set_IsNestedPublic(bool value);
    public bool get_IsNestedPrivate();
    public void set_IsNestedPrivate(bool value);
    public bool get_IsNestedFamily();
    public void set_IsNestedFamily(bool value);
    public bool get_IsNestedAssembly();
    public void set_IsNestedAssembly(bool value);
    public bool get_IsNestedFamilyAndAssembly();
    public void set_IsNestedFamilyAndAssembly(bool value);
    public bool get_IsNestedFamilyOrAssembly();
    public void set_IsNestedFamilyOrAssembly(bool value);
    public bool get_IsAutoLayout();
    public void set_IsAutoLayout(bool value);
    public bool get_IsSequentialLayout();
    public void set_IsSequentialLayout(bool value);
    public bool get_IsExplicitLayout();
    public void set_IsExplicitLayout(bool value);
    public bool get_IsClass();
    public void set_IsClass(bool value);
    public bool get_IsInterface();
    public void set_IsInterface(bool value);
    public bool get_IsAbstract();
    public void set_IsAbstract(bool value);
    public bool get_IsSealed();
    public void set_IsSealed(bool value);
    public bool get_IsSpecialName();
    public void set_IsSpecialName(bool value);
    public bool get_IsImport();
    public void set_IsImport(bool value);
    public bool get_IsSerializable();
    public void set_IsSerializable(bool value);
    public bool get_IsAnsiClass();
    public void set_IsAnsiClass(bool value);
    public bool get_IsUnicodeClass();
    public void set_IsUnicodeClass(bool value);
    public bool get_IsAutoClass();
    public void set_IsAutoClass(bool value);
    public bool get_IsBeforeFieldInit();
    public void set_IsBeforeFieldInit(bool value);
    public bool get_IsRuntimeSpecialName();
    public void set_IsRuntimeSpecialName(bool value);
    public bool get_HasSecurity();
    public void set_HasSecurity(bool value);
    public bool get_IsForwarder();
    public void set_IsForwarder(bool value);
    public string get_FullName();
    public virtual string ToString();
    public TypeDefinition Resolve();
    internal TypeReference CreateReference();
}
internal class Mono.Cecil.ExportedTypeTable : MetadataTable`1<Row`5<TypeAttributes, UInt32, UInt32, UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
}
[FlagsAttribute]
public enum Mono.Cecil.FieldAttributes : Enum {
    public ushort value__;
    public static FieldAttributes FieldAccessMask;
    public static FieldAttributes CompilerControlled;
    public static FieldAttributes Private;
    public static FieldAttributes FamANDAssem;
    public static FieldAttributes Assembly;
    public static FieldAttributes Family;
    public static FieldAttributes FamORAssem;
    public static FieldAttributes Public;
    public static FieldAttributes Static;
    public static FieldAttributes InitOnly;
    public static FieldAttributes Literal;
    public static FieldAttributes NotSerialized;
    public static FieldAttributes SpecialName;
    public static FieldAttributes PInvokeImpl;
    public static FieldAttributes RTSpecialName;
    public static FieldAttributes HasFieldMarshal;
    public static FieldAttributes HasDefault;
    public static FieldAttributes HasFieldRVA;
}
public class Mono.Cecil.FieldDefinition : FieldReference {
    private ushort attributes;
    private Collection`1<CustomAttribute> custom_attributes;
    private int offset;
    internal int rva;
    private Byte[] initial_value;
    private object constant;
    private MarshalInfo marshal_info;
    public bool HasLayoutInfo { get; }
    public int Offset { get; public set; }
    public int RVA { get; }
    public Byte[] InitialValue { get; public set; }
    public FieldAttributes Attributes { get; public set; }
    public bool HasConstant { get; public set; }
    public object Constant { get; public set; }
    public bool HasCustomAttributes { get; }
    public Collection`1<CustomAttribute> CustomAttributes { get; }
    public bool HasMarshalInfo { get; }
    public MarshalInfo MarshalInfo { get; public set; }
    public bool IsCompilerControlled { get; public set; }
    public bool IsPrivate { get; public set; }
    public bool IsFamilyAndAssembly { get; public set; }
    public bool IsAssembly { get; public set; }
    public bool IsFamily { get; public set; }
    public bool IsFamilyOrAssembly { get; public set; }
    public bool IsPublic { get; public set; }
    public bool IsStatic { get; public set; }
    public bool IsInitOnly { get; public set; }
    public bool IsLiteral { get; public set; }
    public bool IsNotSerialized { get; public set; }
    public bool IsSpecialName { get; public set; }
    public bool IsPInvokeImpl { get; public set; }
    public bool IsRuntimeSpecialName { get; public set; }
    public bool HasDefault { get; public set; }
    public bool IsDefinition { get; }
    public TypeDefinition DeclaringType { get; public set; }
    public FieldDefinition(string name, FieldAttributes attributes, TypeReference fieldType);
    private void ResolveLayout();
    public bool get_HasLayoutInfo();
    public int get_Offset();
    public void set_Offset(int value);
    private void ResolveRVA();
    public int get_RVA();
    public Byte[] get_InitialValue();
    public void set_InitialValue(Byte[] value);
    public FieldAttributes get_Attributes();
    public void set_Attributes(FieldAttributes value);
    public sealed virtual bool get_HasConstant();
    public sealed virtual void set_HasConstant(bool value);
    public sealed virtual object get_Constant();
    public sealed virtual void set_Constant(object value);
    public sealed virtual bool get_HasCustomAttributes();
    public sealed virtual Collection`1<CustomAttribute> get_CustomAttributes();
    public sealed virtual bool get_HasMarshalInfo();
    public sealed virtual MarshalInfo get_MarshalInfo();
    public sealed virtual void set_MarshalInfo(MarshalInfo value);
    public bool get_IsCompilerControlled();
    public void set_IsCompilerControlled(bool value);
    public bool get_IsPrivate();
    public void set_IsPrivate(bool value);
    public bool get_IsFamilyAndAssembly();
    public void set_IsFamilyAndAssembly(bool value);
    public bool get_IsAssembly();
    public void set_IsAssembly(bool value);
    public bool get_IsFamily();
    public void set_IsFamily(bool value);
    public bool get_IsFamilyOrAssembly();
    public void set_IsFamilyOrAssembly(bool value);
    public bool get_IsPublic();
    public void set_IsPublic(bool value);
    public bool get_IsStatic();
    public void set_IsStatic(bool value);
    public bool get_IsInitOnly();
    public void set_IsInitOnly(bool value);
    public bool get_IsLiteral();
    public void set_IsLiteral(bool value);
    public bool get_IsNotSerialized();
    public void set_IsNotSerialized(bool value);
    public sealed virtual bool get_IsSpecialName();
    public sealed virtual void set_IsSpecialName(bool value);
    public bool get_IsPInvokeImpl();
    public void set_IsPInvokeImpl(bool value);
    public sealed virtual bool get_IsRuntimeSpecialName();
    public sealed virtual void set_IsRuntimeSpecialName(bool value);
    public bool get_HasDefault();
    public void set_HasDefault(bool value);
    public virtual bool get_IsDefinition();
    public sealed virtual TypeDefinition get_DeclaringType();
    public sealed virtual void set_DeclaringType(TypeDefinition value);
    public virtual FieldDefinition Resolve();
}
internal class Mono.Cecil.FieldLayoutTable : SortedTable`1<Row`2<UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
    public virtual int Compare(Row`2<UInt32, UInt32> x, Row`2<UInt32, UInt32> y);
}
internal class Mono.Cecil.FieldMarshalTable : SortedTable`1<Row`2<UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
    public virtual int Compare(Row`2<UInt32, UInt32> x, Row`2<UInt32, UInt32> y);
}
public class Mono.Cecil.FieldReference : MemberReference {
    private TypeReference field_type;
    public TypeReference FieldType { get; public set; }
    public string FullName { get; }
    public bool ContainsGenericParameter { get; }
    public FieldReference(string name, TypeReference fieldType);
    public FieldReference(string name, TypeReference fieldType, TypeReference declaringType);
    public TypeReference get_FieldType();
    public void set_FieldType(TypeReference value);
    public virtual string get_FullName();
    public virtual bool get_ContainsGenericParameter();
    public virtual FieldDefinition Resolve();
}
internal class Mono.Cecil.FieldRVATable : SortedTable`1<Row`2<UInt32, UInt32>> {
    internal int position;
    public virtual void Write(TableHeapBuffer buffer);
    public virtual int Compare(Row`2<UInt32, UInt32> x, Row`2<UInt32, UInt32> y);
}
internal class Mono.Cecil.FieldTable : MetadataTable`1<Row`3<FieldAttributes, UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
}
internal enum Mono.Cecil.FileAttributes : Enum {
    public UInt32 value__;
    public static FileAttributes ContainsMetaData;
    public static FileAttributes ContainsNoMetaData;
}
internal class Mono.Cecil.FileTable : MetadataTable`1<Row`3<FileAttributes, UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
}
public class Mono.Cecil.FixedArrayMarshalInfo : MarshalInfo {
    internal NativeType element_type;
    internal int size;
    public NativeType ElementType { get; public set; }
    public int Size { get; public set; }
    public NativeType get_ElementType();
    public void set_ElementType(NativeType value);
    public int get_Size();
    public void set_Size(int value);
}
public class Mono.Cecil.FixedSysStringMarshalInfo : MarshalInfo {
    internal int size;
    public int Size { get; public set; }
    public int get_Size();
    public void set_Size(int value);
}
public class Mono.Cecil.FunctionPointerType : TypeSpecification {
    private MethodReference function;
    public bool HasThis { get; public set; }
    public bool ExplicitThis { get; public set; }
    public MethodCallingConvention CallingConvention { get; public set; }
    public bool HasParameters { get; }
    public Collection`1<ParameterDefinition> Parameters { get; }
    public TypeReference ReturnType { get; public set; }
    public MethodReturnType MethodReturnType { get; }
    public string Name { get; public set; }
    public string Namespace { get; public set; }
    public ModuleDefinition Module { get; }
    public IMetadataScope Scope { get; public set; }
    public bool IsFunctionPointer { get; }
    public bool ContainsGenericParameter { get; }
    public string FullName { get; }
    public sealed virtual bool get_HasThis();
    public sealed virtual void set_HasThis(bool value);
    public sealed virtual bool get_ExplicitThis();
    public sealed virtual void set_ExplicitThis(bool value);
    public sealed virtual MethodCallingConvention get_CallingConvention();
    public sealed virtual void set_CallingConvention(MethodCallingConvention value);
    public sealed virtual bool get_HasParameters();
    public sealed virtual Collection`1<ParameterDefinition> get_Parameters();
    public sealed virtual TypeReference get_ReturnType();
    public sealed virtual void set_ReturnType(TypeReference value);
    public sealed virtual MethodReturnType get_MethodReturnType();
    public virtual string get_Name();
    public virtual void set_Name(string value);
    public virtual string get_Namespace();
    public virtual void set_Namespace(string value);
    public virtual ModuleDefinition get_Module();
    public virtual IMetadataScope get_Scope();
    public virtual void set_Scope(IMetadataScope value);
    public virtual bool get_IsFunctionPointer();
    public virtual bool get_ContainsGenericParameter();
    public virtual string get_FullName();
    public virtual TypeDefinition Resolve();
    public virtual TypeReference GetElementType();
}
public class Mono.Cecil.GenericInstanceMethod : MethodSpecification {
    private Collection`1<TypeReference> arguments;
    public bool HasGenericArguments { get; }
    public Collection`1<TypeReference> GenericArguments { get; }
    public bool IsGenericInstance { get; }
    private IGenericParameterProvider Mono.Cecil.IGenericContext.Method { get; }
    private IGenericParameterProvider Mono.Cecil.IGenericContext.Type { get; }
    public bool ContainsGenericParameter { get; }
    public string FullName { get; }
    public GenericInstanceMethod(MethodReference method);
    public sealed virtual bool get_HasGenericArguments();
    public sealed virtual Collection`1<TypeReference> get_GenericArguments();
    public virtual bool get_IsGenericInstance();
    private sealed virtual override IGenericParameterProvider Mono.Cecil.IGenericContext.get_Method();
    private sealed virtual override IGenericParameterProvider Mono.Cecil.IGenericContext.get_Type();
    public virtual bool get_ContainsGenericParameter();
    public virtual string get_FullName();
}
public class Mono.Cecil.GenericInstanceType : TypeSpecification {
    private Collection`1<TypeReference> arguments;
    public bool HasGenericArguments { get; }
    public Collection`1<TypeReference> GenericArguments { get; }
    public TypeReference DeclaringType { get; public set; }
    public string FullName { get; }
    public bool IsGenericInstance { get; }
    public bool ContainsGenericParameter { get; }
    private IGenericParameterProvider Mono.Cecil.IGenericContext.Type { get; }
    public GenericInstanceType(TypeReference type);
    public sealed virtual bool get_HasGenericArguments();
    public sealed virtual Collection`1<TypeReference> get_GenericArguments();
    public virtual TypeReference get_DeclaringType();
    public virtual void set_DeclaringType(TypeReference value);
    public virtual string get_FullName();
    public virtual bool get_IsGenericInstance();
    public virtual bool get_ContainsGenericParameter();
    private sealed virtual override IGenericParameterProvider Mono.Cecil.IGenericContext.get_Type();
}
internal class Mono.Cecil.GenericParamConstraintTable : MetadataTable`1<Row`2<UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
}
public class Mono.Cecil.GenericParameter : TypeReference {
    internal int position;
    internal GenericParameterType type;
    internal IGenericParameterProvider owner;
    private ushort attributes;
    private Collection`1<TypeReference> constraints;
    private Collection`1<CustomAttribute> custom_attributes;
    public GenericParameterAttributes Attributes { get; public set; }
    public int Position { get; }
    public GenericParameterType Type { get; }
    public IGenericParameterProvider Owner { get; }
    public bool HasConstraints { get; }
    public Collection`1<TypeReference> Constraints { get; }
    public bool HasCustomAttributes { get; }
    public Collection`1<CustomAttribute> CustomAttributes { get; }
    public IMetadataScope Scope { get; public set; }
    public TypeReference DeclaringType { get; public set; }
    public MethodReference DeclaringMethod { get; }
    public ModuleDefinition Module { get; }
    public string Name { get; }
    public string Namespace { get; public set; }
    public string FullName { get; }
    public bool IsGenericParameter { get; }
    public bool ContainsGenericParameter { get; }
    public MetadataType MetadataType { get; }
    public bool IsNonVariant { get; public set; }
    public bool IsCovariant { get; public set; }
    public bool IsContravariant { get; public set; }
    public bool HasReferenceTypeConstraint { get; public set; }
    public bool HasNotNullableValueTypeConstraint { get; public set; }
    public bool HasDefaultConstructorConstraint { get; public set; }
    public GenericParameter(IGenericParameterProvider owner);
    public GenericParameter(string name, IGenericParameterProvider owner);
    internal GenericParameter(int position, GenericParameterType type, ModuleDefinition module);
    public GenericParameterAttributes get_Attributes();
    public void set_Attributes(GenericParameterAttributes value);
    public int get_Position();
    public GenericParameterType get_Type();
    public IGenericParameterProvider get_Owner();
    public bool get_HasConstraints();
    public Collection`1<TypeReference> get_Constraints();
    public sealed virtual bool get_HasCustomAttributes();
    public sealed virtual Collection`1<CustomAttribute> get_CustomAttributes();
    public virtual IMetadataScope get_Scope();
    public virtual void set_Scope(IMetadataScope value);
    public virtual TypeReference get_DeclaringType();
    public virtual void set_DeclaringType(TypeReference value);
    public MethodReference get_DeclaringMethod();
    public virtual ModuleDefinition get_Module();
    public virtual string get_Name();
    public virtual string get_Namespace();
    public virtual void set_Namespace(string value);
    public virtual string get_FullName();
    public virtual bool get_IsGenericParameter();
    public virtual bool get_ContainsGenericParameter();
    public virtual MetadataType get_MetadataType();
    public bool get_IsNonVariant();
    public void set_IsNonVariant(bool value);
    public bool get_IsCovariant();
    public void set_IsCovariant(bool value);
    public bool get_IsContravariant();
    public void set_IsContravariant(bool value);
    public bool get_HasReferenceTypeConstraint();
    public void set_HasReferenceTypeConstraint(bool value);
    public bool get_HasNotNullableValueTypeConstraint();
    public void set_HasNotNullableValueTypeConstraint(bool value);
    public bool get_HasDefaultConstructorConstraint();
    public void set_HasDefaultConstructorConstraint(bool value);
    private static ElementType ConvertGenericParameterType(GenericParameterType type);
    public virtual TypeDefinition Resolve();
}
[FlagsAttribute]
public enum Mono.Cecil.GenericParameterAttributes : Enum {
    public ushort value__;
    public static GenericParameterAttributes VarianceMask;
    public static GenericParameterAttributes NonVariant;
    public static GenericParameterAttributes Covariant;
    public static GenericParameterAttributes Contravariant;
    public static GenericParameterAttributes SpecialConstraintMask;
    public static GenericParameterAttributes ReferenceTypeConstraint;
    public static GenericParameterAttributes NotNullableValueTypeConstraint;
    public static GenericParameterAttributes DefaultConstructorConstraint;
}
internal class Mono.Cecil.GenericParameterCollection : Collection`1<GenericParameter> {
    private IGenericParameterProvider owner;
    internal GenericParameterCollection(IGenericParameterProvider owner);
    internal GenericParameterCollection(IGenericParameterProvider owner, int capacity);
    protected virtual void OnAdd(GenericParameter item, int index);
    protected virtual void OnInsert(GenericParameter item, int index);
    protected virtual void OnSet(GenericParameter item, int index);
    private void UpdateGenericParameter(GenericParameter item, int index);
    protected virtual void OnRemove(GenericParameter item, int index);
}
public enum Mono.Cecil.GenericParameterType : Enum {
    public int value__;
    public static GenericParameterType Type;
    public static GenericParameterType Method;
}
internal class Mono.Cecil.GenericParamTable : MetadataTable`1<Row`4<ushort, GenericParameterAttributes, UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
}
public interface Mono.Cecil.IAssemblyResolver {
    public abstract virtual AssemblyDefinition Resolve(AssemblyNameReference name);
    public abstract virtual AssemblyDefinition Resolve(AssemblyNameReference name, ReaderParameters parameters);
    public abstract virtual AssemblyDefinition Resolve(string fullName);
    public abstract virtual AssemblyDefinition Resolve(string fullName, ReaderParameters parameters);
}
public interface Mono.Cecil.IConstantProvider {
    public bool HasConstant { get; public set; }
    public object Constant { get; public set; }
    public abstract virtual bool get_HasConstant();
    public abstract virtual void set_HasConstant(bool value);
    public abstract virtual object get_Constant();
    public abstract virtual void set_Constant(object value);
}
public interface Mono.Cecil.ICustomAttribute {
    public TypeReference AttributeType { get; }
    public bool HasFields { get; }
    public bool HasProperties { get; }
    public Collection`1<CustomAttributeNamedArgument> Fields { get; }
    public Collection`1<CustomAttributeNamedArgument> Properties { get; }
    public abstract virtual TypeReference get_AttributeType();
    public abstract virtual bool get_HasFields();
    public abstract virtual bool get_HasProperties();
    public abstract virtual Collection`1<CustomAttributeNamedArgument> get_Fields();
    public abstract virtual Collection`1<CustomAttributeNamedArgument> get_Properties();
}
public interface Mono.Cecil.ICustomAttributeProvider {
    public Collection`1<CustomAttribute> CustomAttributes { get; }
    public bool HasCustomAttributes { get; }
    public abstract virtual Collection`1<CustomAttribute> get_CustomAttributes();
    public abstract virtual bool get_HasCustomAttributes();
}
internal interface Mono.Cecil.IGenericContext {
    public bool IsDefinition { get; }
    public IGenericParameterProvider Type { get; }
    public IGenericParameterProvider Method { get; }
    public abstract virtual bool get_IsDefinition();
    public abstract virtual IGenericParameterProvider get_Type();
    public abstract virtual IGenericParameterProvider get_Method();
}
public interface Mono.Cecil.IGenericInstance {
    public bool HasGenericArguments { get; }
    public Collection`1<TypeReference> GenericArguments { get; }
    public abstract virtual bool get_HasGenericArguments();
    public abstract virtual Collection`1<TypeReference> get_GenericArguments();
}
public interface Mono.Cecil.IGenericParameterProvider {
    public bool HasGenericParameters { get; }
    public bool IsDefinition { get; }
    public ModuleDefinition Module { get; }
    public Collection`1<GenericParameter> GenericParameters { get; }
    public GenericParameterType GenericParameterType { get; }
    public abstract virtual bool get_HasGenericParameters();
    public abstract virtual bool get_IsDefinition();
    public abstract virtual ModuleDefinition get_Module();
    public abstract virtual Collection`1<GenericParameter> get_GenericParameters();
    public abstract virtual GenericParameterType get_GenericParameterType();
}
public interface Mono.Cecil.IMarshalInfoProvider {
    public bool HasMarshalInfo { get; }
    public MarshalInfo MarshalInfo { get; public set; }
    public abstract virtual bool get_HasMarshalInfo();
    public abstract virtual MarshalInfo get_MarshalInfo();
    public abstract virtual void set_MarshalInfo(MarshalInfo value);
}
public interface Mono.Cecil.IMemberDefinition {
    public string Name { get; public set; }
    public string FullName { get; }
    public bool IsSpecialName { get; public set; }
    public bool IsRuntimeSpecialName { get; public set; }
    public TypeDefinition DeclaringType { get; public set; }
    public abstract virtual string get_Name();
    public abstract virtual void set_Name(string value);
    public abstract virtual string get_FullName();
    public abstract virtual bool get_IsSpecialName();
    public abstract virtual void set_IsSpecialName(bool value);
    public abstract virtual bool get_IsRuntimeSpecialName();
    public abstract virtual void set_IsRuntimeSpecialName(bool value);
    public abstract virtual TypeDefinition get_DeclaringType();
    public abstract virtual void set_DeclaringType(TypeDefinition value);
}
public interface Mono.Cecil.IMetadataResolver {
    public abstract virtual TypeDefinition Resolve(TypeReference type);
    public abstract virtual FieldDefinition Resolve(FieldReference field);
    public abstract virtual MethodDefinition Resolve(MethodReference method);
}
public interface Mono.Cecil.IMetadataScope {
    public MetadataScopeType MetadataScopeType { get; }
    public string Name { get; public set; }
    public abstract virtual MetadataScopeType get_MetadataScopeType();
    public abstract virtual string get_Name();
    public abstract virtual void set_Name(string value);
}
public interface Mono.Cecil.IMetadataTokenProvider {
    public MetadataToken MetadataToken { get; public set; }
    public abstract virtual MetadataToken get_MetadataToken();
    public abstract virtual void set_MetadataToken(MetadataToken value);
}
public interface Mono.Cecil.IMethodSignature {
    public bool HasThis { get; public set; }
    public bool ExplicitThis { get; public set; }
    public MethodCallingConvention CallingConvention { get; public set; }
    public bool HasParameters { get; }
    public Collection`1<ParameterDefinition> Parameters { get; }
    public TypeReference ReturnType { get; public set; }
    public MethodReturnType MethodReturnType { get; }
    public abstract virtual bool get_HasThis();
    public abstract virtual void set_HasThis(bool value);
    public abstract virtual bool get_ExplicitThis();
    public abstract virtual void set_ExplicitThis(bool value);
    public abstract virtual MethodCallingConvention get_CallingConvention();
    public abstract virtual void set_CallingConvention(MethodCallingConvention value);
    public abstract virtual bool get_HasParameters();
    public abstract virtual Collection`1<ParameterDefinition> get_Parameters();
    public abstract virtual TypeReference get_ReturnType();
    public abstract virtual void set_ReturnType(TypeReference value);
    public abstract virtual MethodReturnType get_MethodReturnType();
}
internal class Mono.Cecil.ImmediateModuleReader : ModuleReader {
    public ImmediateModuleReader(Image image);
    protected virtual void ReadModule();
    public static void ReadModule(ModuleDefinition module);
    private static void ReadTypes(Collection`1<TypeDefinition> types);
    private static void ReadType(TypeDefinition type);
    private static void ReadGenericParameters(IGenericParameterProvider provider);
    private static void ReadSecurityDeclarations(ISecurityDeclarationProvider provider);
    private static void ReadCustomAttributes(ICustomAttributeProvider provider);
    private static void ReadFields(TypeDefinition type);
    private static void ReadMethods(TypeDefinition type);
    private static void ReadParameters(MethodDefinition method);
    private static void ReadProperties(TypeDefinition type);
    private static void ReadEvents(TypeDefinition type);
    private static void Read(object collection);
    [CompilerGeneratedAttribute]
private ModuleDefinition <ReadModule>b__1_0(ModuleDefinition module, MetadataReader reader);
}
public interface Mono.Cecil.IModifierType {
    public TypeReference ModifierType { get; }
    public TypeReference ElementType { get; }
    public abstract virtual TypeReference get_ModifierType();
    public abstract virtual TypeReference get_ElementType();
}
internal class Mono.Cecil.ImplMapTable : SortedTable`1<Row`4<PInvokeAttributes, UInt32, UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
    public virtual int Compare(Row`4<PInvokeAttributes, UInt32, UInt32, UInt32> x, Row`4<PInvokeAttributes, UInt32, UInt32, UInt32> y);
}
internal class Mono.Cecil.ImportGenericContext : ValueType {
    private Collection`1<IGenericParameterProvider> stack;
    public bool IsEmpty { get; }
    public ImportGenericContext(IGenericParameterProvider provider);
    public bool get_IsEmpty();
    public void Push(IGenericParameterProvider provider);
    public void Pop();
    public TypeReference MethodParameter(string method, int position);
    public string NormalizeMethodName(MethodReference method);
    public TypeReference TypeParameter(string type, int position);
    private static TypeReference GenericTypeFor(IGenericParameterProvider context);
}
internal enum Mono.Cecil.ImportGenericKind : Enum {
    public int value__;
    public static ImportGenericKind Definition;
    public static ImportGenericKind Open;
}
internal class Mono.Cecil.InterfaceImplTable : MetadataTable`1<Row`2<UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
}
public interface Mono.Cecil.ISecurityDeclarationProvider {
    public bool HasSecurityDeclarations { get; }
    public Collection`1<SecurityDeclaration> SecurityDeclarations { get; }
    public abstract virtual bool get_HasSecurityDeclarations();
    public abstract virtual Collection`1<SecurityDeclaration> get_SecurityDeclarations();
}
public class Mono.Cecil.LinkedResource : Resource {
    internal Byte[] hash;
    private string file;
    public Byte[] Hash { get; }
    public string File { get; public set; }
    public ResourceType ResourceType { get; }
    public LinkedResource(string name, ManifestResourceAttributes flags);
    public LinkedResource(string name, ManifestResourceAttributes flags, string file);
    public Byte[] get_Hash();
    public string get_File();
    public void set_File(string value);
    public virtual ResourceType get_ResourceType();
}
[FlagsAttribute]
public enum Mono.Cecil.ManifestResourceAttributes : Enum {
    public UInt32 value__;
    public static ManifestResourceAttributes VisibilityMask;
    public static ManifestResourceAttributes Public;
    public static ManifestResourceAttributes Private;
}
internal class Mono.Cecil.ManifestResourceTable : MetadataTable`1<Row`4<UInt32, ManifestResourceAttributes, UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
}
public class Mono.Cecil.MarshalInfo : object {
    internal NativeType native;
    public NativeType NativeType { get; public set; }
    public MarshalInfo(NativeType native);
    public NativeType get_NativeType();
    public void set_NativeType(NativeType value);
}
internal class Mono.Cecil.MemberDefinitionCollection`1 : Collection`1<T> {
    private TypeDefinition container;
    internal MemberDefinitionCollection`1(TypeDefinition container);
    internal MemberDefinitionCollection`1(TypeDefinition container, int capacity);
    protected virtual void OnAdd(T item, int index);
    protected sealed virtual void OnSet(T item, int index);
    protected sealed virtual void OnInsert(T item, int index);
    protected sealed virtual void OnRemove(T item, int index);
    protected sealed virtual void OnClear();
    private void Attach(T element);
    private static void Detach(T element);
}
public abstract class Mono.Cecil.MemberReference : object {
    private string name;
    private TypeReference declaring_type;
    internal MetadataToken token;
    public string Name { get; public set; }
    public string FullName { get; }
    public TypeReference DeclaringType { get; public set; }
    public MetadataToken MetadataToken { get; public set; }
    internal bool HasImage { get; }
    public ModuleDefinition Module { get; }
    public bool IsDefinition { get; }
    public bool ContainsGenericParameter { get; }
    internal MemberReference(string name);
    public virtual string get_Name();
    public virtual void set_Name(string value);
    public abstract virtual string get_FullName();
    public virtual TypeReference get_DeclaringType();
    public virtual void set_DeclaringType(TypeReference value);
    public sealed virtual MetadataToken get_MetadataToken();
    public sealed virtual void set_MetadataToken(MetadataToken value);
    internal bool get_HasImage();
    public virtual ModuleDefinition get_Module();
    public virtual bool get_IsDefinition();
    public virtual bool get_ContainsGenericParameter();
    internal string MemberFullName();
    public virtual string ToString();
}
internal class Mono.Cecil.MemberRefTable : MetadataTable`1<Row`3<UInt32, UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
}
internal class Mono.Cecil.Metadata.BlobHeap : Heap {
    public BlobHeap(Section section, UInt32 start, UInt32 size);
    public Byte[] Read(UInt32 index);
}
internal class Mono.Cecil.Metadata.BlobHeapBuffer : HeapBuffer {
    private Dictionary`2<ByteBuffer, UInt32> blobs;
    public bool IsEmpty { get; }
    public virtual bool get_IsEmpty();
    public UInt32 GetBlobIndex(ByteBuffer blob);
    private void WriteBlob(ByteBuffer blob);
}
internal enum Mono.Cecil.Metadata.CodedIndex : Enum {
    public int value__;
    public static CodedIndex TypeDefOrRef;
    public static CodedIndex HasConstant;
    public static CodedIndex HasCustomAttribute;
    public static CodedIndex HasFieldMarshal;
    public static CodedIndex HasDeclSecurity;
    public static CodedIndex MemberRefParent;
    public static CodedIndex HasSemantics;
    public static CodedIndex MethodDefOrRef;
    public static CodedIndex MemberForwarded;
    public static CodedIndex Implementation;
    public static CodedIndex CustomAttributeType;
    public static CodedIndex ResolutionScope;
    public static CodedIndex TypeOrMethodDef;
}
internal class Mono.Cecil.Metadata.DataBuffer : ByteBuffer {
    public UInt32 AddData(Byte[] data);
}
internal enum Mono.Cecil.Metadata.ElementType : Enum {
    public byte value__;
    public static ElementType None;
    public static ElementType Void;
    public static ElementType Boolean;
    public static ElementType Char;
    public static ElementType I1;
    public static ElementType U1;
    public static ElementType I2;
    public static ElementType U2;
    public static ElementType I4;
    public static ElementType U4;
    public static ElementType I8;
    public static ElementType U8;
    public static ElementType R4;
    public static ElementType R8;
    public static ElementType String;
    public static ElementType Ptr;
    public static ElementType ByRef;
    public static ElementType ValueType;
    public static ElementType Class;
    public static ElementType Var;
    public static ElementType Array;
    public static ElementType GenericInst;
    public static ElementType TypedByRef;
    public static ElementType I;
    public static ElementType U;
    public static ElementType FnPtr;
    public static ElementType Object;
    public static ElementType SzArray;
    public static ElementType MVar;
    public static ElementType CModReqD;
    public static ElementType CModOpt;
    public static ElementType Internal;
    public static ElementType Modifier;
    public static ElementType Sentinel;
    public static ElementType Pinned;
    public static ElementType Type;
    public static ElementType Boxed;
    public static ElementType Enum;
}
internal class Mono.Cecil.Metadata.GuidHeap : Heap {
    public GuidHeap(Section section, UInt32 start, UInt32 size);
    public Guid Read(UInt32 index);
}
internal abstract class Mono.Cecil.Metadata.Heap : object {
    public int IndexSize;
    public Section Section;
    public UInt32 Offset;
    public UInt32 Size;
    protected Heap(Section section, UInt32 offset, UInt32 size);
}
internal abstract class Mono.Cecil.Metadata.HeapBuffer : ByteBuffer {
    public bool IsLarge { get; }
    public bool IsEmpty { get; }
    protected HeapBuffer(int length);
    public bool get_IsLarge();
    public abstract virtual bool get_IsEmpty();
}
internal class Mono.Cecil.Metadata.ResourceBuffer : ByteBuffer {
    public UInt32 AddResource(Byte[] resource);
}
internal class Mono.Cecil.Metadata.Row`2 : ValueType {
    internal T1 Col1;
    internal T2 Col2;
    public Row`2(T1 col1, T2 col2);
}
internal class Mono.Cecil.Metadata.Row`3 : ValueType {
    internal T1 Col1;
    internal T2 Col2;
    internal T3 Col3;
    public Row`3(T1 col1, T2 col2, T3 col3);
}
internal class Mono.Cecil.Metadata.Row`4 : ValueType {
    internal T1 Col1;
    internal T2 Col2;
    internal T3 Col3;
    internal T4 Col4;
    public Row`4(T1 col1, T2 col2, T3 col3, T4 col4);
}
internal class Mono.Cecil.Metadata.Row`5 : ValueType {
    internal T1 Col1;
    internal T2 Col2;
    internal T3 Col3;
    internal T4 Col4;
    internal T5 Col5;
    public Row`5(T1 col1, T2 col2, T3 col3, T4 col4, T5 col5);
}
internal class Mono.Cecil.Metadata.Row`6 : ValueType {
    internal T1 Col1;
    internal T2 Col2;
    internal T3 Col3;
    internal T4 Col4;
    internal T5 Col5;
    internal T6 Col6;
    public Row`6(T1 col1, T2 col2, T3 col3, T4 col4, T5 col5, T6 col6);
}
internal class Mono.Cecil.Metadata.Row`9 : ValueType {
    internal T1 Col1;
    internal T2 Col2;
    internal T3 Col3;
    internal T4 Col4;
    internal T5 Col5;
    internal T6 Col6;
    internal T7 Col7;
    internal T8 Col8;
    internal T9 Col9;
    public Row`9(T1 col1, T2 col2, T3 col3, T4 col4, T5 col5, T6 col6, T7 col7, T8 col8, T9 col9);
}
internal class Mono.Cecil.Metadata.RowEqualityComparer : object {
    public sealed virtual bool Equals(Row`2<string, string> x, Row`2<string, string> y);
    public sealed virtual int GetHashCode(Row`2<string, string> obj);
    public sealed virtual bool Equals(Row`2<UInt32, UInt32> x, Row`2<UInt32, UInt32> y);
    public sealed virtual int GetHashCode(Row`2<UInt32, UInt32> obj);
    public sealed virtual bool Equals(Row`3<UInt32, UInt32, UInt32> x, Row`3<UInt32, UInt32, UInt32> y);
    public sealed virtual int GetHashCode(Row`3<UInt32, UInt32, UInt32> obj);
}
internal class Mono.Cecil.Metadata.StringHeap : Heap {
    private Dictionary`2<UInt32, string> strings;
    public StringHeap(Section section, UInt32 start, UInt32 size);
    public string Read(UInt32 index);
    protected virtual string ReadStringAt(UInt32 index);
}
internal class Mono.Cecil.Metadata.StringHeapBuffer : HeapBuffer {
    private Dictionary`2<string, UInt32> strings;
    public bool IsEmpty { get; }
    public sealed virtual bool get_IsEmpty();
    public UInt32 GetStringIndex(string string);
    protected virtual void WriteString(string string);
}
internal enum Mono.Cecil.Metadata.Table : Enum {
    public byte value__;
    public static Table Module;
    public static Table TypeRef;
    public static Table TypeDef;
    public static Table FieldPtr;
    public static Table Field;
    public static Table MethodPtr;
    public static Table Method;
    public static Table ParamPtr;
    public static Table Param;
    public static Table InterfaceImpl;
    public static Table MemberRef;
    public static Table Constant;
    public static Table CustomAttribute;
    public static Table FieldMarshal;
    public static Table DeclSecurity;
    public static Table ClassLayout;
    public static Table FieldLayout;
    public static Table StandAloneSig;
    public static Table EventMap;
    public static Table EventPtr;
    public static Table Event;
    public static Table PropertyMap;
    public static Table PropertyPtr;
    public static Table Property;
    public static Table MethodSemantics;
    public static Table MethodImpl;
    public static Table ModuleRef;
    public static Table TypeSpec;
    public static Table ImplMap;
    public static Table FieldRVA;
    public static Table EncLog;
    public static Table EncMap;
    public static Table Assembly;
    public static Table AssemblyProcessor;
    public static Table AssemblyOS;
    public static Table AssemblyRef;
    public static Table AssemblyRefProcessor;
    public static Table AssemblyRefOS;
    public static Table File;
    public static Table ExportedType;
    public static Table ManifestResource;
    public static Table NestedClass;
    public static Table GenericParam;
    public static Table MethodSpec;
    public static Table GenericParamConstraint;
}
[DefaultMemberAttribute("Item")]
internal class Mono.Cecil.Metadata.TableHeap : Heap {
    public long Valid;
    public long Sorted;
    public static int TableCount;
    public TableInformation[] Tables;
    public TableInformation Item { get; }
    public TableHeap(Section section, UInt32 start, UInt32 size);
    public TableInformation get_Item(Table table);
    public bool HasTable(Table table);
}
internal class Mono.Cecil.Metadata.TableHeapBuffer : HeapBuffer {
    private ModuleDefinition module;
    private MetadataBuilder metadata;
    internal MetadataTable[] tables;
    private bool large_string;
    private bool large_blob;
    private Int32[] coded_index_sizes;
    private Func`2<Table, int> counter;
    public bool IsEmpty { get; }
    public TableHeapBuffer(ModuleDefinition module, MetadataBuilder metadata);
    public virtual bool get_IsEmpty();
    private int GetTableLength(Table table);
    public TTable GetTable(Table table);
    public void WriteBySize(UInt32 value, int size);
    public void WriteBySize(UInt32 value, bool large);
    public void WriteString(UInt32 string);
    public void WriteBlob(UInt32 blob);
    public void WriteRID(UInt32 rid, Table table);
    private int GetCodedIndexSize(CodedIndex coded_index);
    public void WriteCodedRID(UInt32 rid, CodedIndex coded_index);
    public void WriteTableHeap();
    private void WriteRowCount();
    private void WriteTables();
    private ulong GetValid();
    private byte GetHeapSizes();
    private byte GetTableHeapVersion();
    public void FixupData(UInt32 data_rva);
}
internal class Mono.Cecil.Metadata.TableInformation : ValueType {
    public UInt32 Offset;
    public UInt32 Length;
    public UInt32 RowSize;
}
internal class Mono.Cecil.Metadata.UserStringHeap : StringHeap {
    public UserStringHeap(Section section, UInt32 start, UInt32 size);
    protected virtual string ReadStringAt(UInt32 index);
}
internal class Mono.Cecil.Metadata.UserStringHeapBuffer : StringHeapBuffer {
    protected virtual void WriteString(string string);
}
internal class Mono.Cecil.MetadataBuilder : object {
    internal ModuleDefinition module;
    internal ISymbolWriterProvider symbol_writer_provider;
    internal ISymbolWriter symbol_writer;
    internal TextMap text_map;
    internal string fq_name;
    private Dictionary`2<Row`3<UInt32, UInt32, UInt32>, MetadataToken> type_ref_map;
    private Dictionary`2<UInt32, MetadataToken> type_spec_map;
    private Dictionary`2<Row`3<UInt32, UInt32, UInt32>, MetadataToken> member_ref_map;
    private Dictionary`2<Row`2<UInt32, UInt32>, MetadataToken> method_spec_map;
    private Collection`1<GenericParameter> generic_parameters;
    private Dictionary`2<MetadataToken, MetadataToken> method_def_map;
    internal CodeWriter code;
    internal DataBuffer data;
    internal ResourceBuffer resources;
    internal StringHeapBuffer string_heap;
    internal UserStringHeapBuffer user_string_heap;
    internal BlobHeapBuffer blob_heap;
    internal TableHeapBuffer table_heap;
    internal MetadataToken entry_point;
    private UInt32 type_rid;
    private UInt32 field_rid;
    private UInt32 method_rid;
    private UInt32 param_rid;
    private UInt32 property_rid;
    private UInt32 event_rid;
    private TypeRefTable type_ref_table;
    private TypeDefTable type_def_table;
    private FieldTable field_table;
    private MethodTable method_table;
    private ParamTable param_table;
    private InterfaceImplTable iface_impl_table;
    private MemberRefTable member_ref_table;
    private ConstantTable constant_table;
    private CustomAttributeTable custom_attribute_table;
    private DeclSecurityTable declsec_table;
    private StandAloneSigTable standalone_sig_table;
    private EventMapTable event_map_table;
    private EventTable event_table;
    private PropertyMapTable property_map_table;
    private PropertyTable property_table;
    private TypeSpecTable typespec_table;
    private MethodSpecTable method_spec_table;
    internal bool write_symbols;
    public MetadataBuilder(ModuleDefinition module, string fq_name, ISymbolWriterProvider symbol_writer_provider, ISymbolWriter symbol_writer);
    private TextMap CreateTextMap();
    private TTable GetTable(Table table);
    private UInt32 GetStringIndex(string string);
    private UInt32 GetBlobIndex(ByteBuffer blob);
    private UInt32 GetBlobIndex(Byte[] blob);
    public void BuildMetadata();
    private void BuildModule();
    private void BuildAssembly();
    private void BuildModules();
    private string GetModuleFileName(string name);
    private void AddAssemblyReferences();
    private void AddModuleReferences();
    private void AddResources();
    private UInt32 AddLinkedResource(LinkedResource resource);
    private UInt32 AddEmbeddedResource(EmbeddedResource resource);
    private void AddExportedTypes();
    private MetadataToken GetExportedTypeScope(ExportedType exported_type);
    private void BuildTypes();
    private void AttachTokens();
    private void AttachTypeDefToken(TypeDefinition type);
    private void AttachNestedTypesDefToken(TypeDefinition type);
    private void AttachFieldsDefToken(TypeDefinition type);
    private void AttachMethodsDefToken(TypeDefinition type);
    public bool TryGetOriginalMethodToken(MetadataToken new_token, MetadataToken& original);
    private MetadataToken GetTypeToken(TypeReference type);
    private MetadataToken GetTypeSpecToken(TypeReference type);
    private MetadataToken AddTypeSpecification(TypeReference type, UInt32 row);
    private MetadataToken GetTypeRefToken(TypeReference type);
    private Row`3<UInt32, UInt32, UInt32> CreateTypeRefRow(TypeReference type);
    private MetadataToken GetScopeToken(TypeReference type);
    private static UInt32 MakeCodedRID(IMetadataTokenProvider provider, CodedIndex index);
    private static UInt32 MakeCodedRID(MetadataToken token, CodedIndex index);
    private MetadataToken AddTypeReference(TypeReference type, Row`3<UInt32, UInt32, UInt32> row);
    private void AddTypeDefs();
    private void AddType(TypeDefinition type);
    private void AddGenericParameters(IGenericParameterProvider owner);
    private void AddGenericParameters();
    private void AddConstraints(GenericParameter generic_parameter, GenericParamConstraintTable table);
    private void AddInterfaces(TypeDefinition type);
    private void AddLayoutInfo(TypeDefinition type);
    private void AddNestedTypes(TypeDefinition type);
    private void AddFields(TypeDefinition type);
    private void AddField(FieldDefinition field);
    private void AddFieldRVA(FieldDefinition field);
    private void AddFieldLayout(FieldDefinition field);
    private void AddMethods(TypeDefinition type);
    private void AddMethod(MethodDefinition method);
    private void AddParameters(MethodDefinition method);
    private void AddPInvokeInfo(MethodDefinition method);
    private void AddOverrides(MethodDefinition method);
    private static bool RequiresParameterRow(ParameterDefinition parameter);
    private void AddParameter(ushort sequence, ParameterDefinition parameter, ParamTable table);
    private void AddMarshalInfo(IMarshalInfoProvider owner);
    private void AddProperties(TypeDefinition type);
    private void AddProperty(PropertyDefinition property);
    private void AddOtherSemantic(IMetadataTokenProvider owner, Collection`1<MethodDefinition> others);
    private void AddEvents(TypeDefinition type);
    private void AddEvent(EventDefinition event);
    private void AddSemantic(MethodSemanticsAttributes semantics, IMetadataTokenProvider provider, MethodDefinition method);
    private void AddConstant(IConstantProvider owner, TypeReference type);
    private static ElementType GetConstantType(TypeReference constant_type, object constant);
    private static ElementType GetConstantType(Type type);
    private void AddCustomAttributes(ICustomAttributeProvider owner);
    private void AddSecurityDeclarations(ISecurityDeclarationProvider owner);
    private MetadataToken GetMemberRefToken(MemberReference member);
    private Row`3<UInt32, UInt32, UInt32> CreateMemberRefRow(MemberReference member);
    private void AddMemberReference(MemberReference member, Row`3<UInt32, UInt32, UInt32> row);
    private MetadataToken GetMethodSpecToken(MethodSpecification method_spec);
    private void AddMethodSpecification(MethodSpecification method_spec, Row`2<UInt32, UInt32> row);
    private Row`2<UInt32, UInt32> CreateMethodSpecRow(MethodSpecification method_spec);
    private SignatureWriter CreateSignatureWriter();
    private SignatureWriter GetMethodSpecSignature(MethodSpecification method_spec);
    public UInt32 AddStandAloneSignature(UInt32 signature);
    public UInt32 GetLocalVariableBlobIndex(Collection`1<VariableDefinition> variables);
    public UInt32 GetCallSiteBlobIndex(CallSite call_site);
    private SignatureWriter GetVariablesSignature(Collection`1<VariableDefinition> variables);
    private SignatureWriter GetFieldSignature(FieldReference field);
    private SignatureWriter GetMethodSignature(IMethodSignature method);
    private SignatureWriter GetMemberRefSignature(MemberReference member);
    private SignatureWriter GetPropertySignature(PropertyDefinition property);
    private SignatureWriter GetTypeSpecSignature(TypeReference type);
    private SignatureWriter GetConstantSignature(ElementType type, object value);
    private SignatureWriter GetCustomAttributeSignature(CustomAttribute attribute);
    private SignatureWriter GetSecurityDeclarationSignature(SecurityDeclaration declaration);
    private SignatureWriter GetMarshalInfoSignature(IMarshalInfoProvider owner);
    private static Exception CreateForeignMemberException(MemberReference member);
    public MetadataToken LookupToken(IMetadataTokenProvider provider);
}
internal class Mono.Cecil.MetadataImporter : object {
    private ModuleDefinition module;
    private static Dictionary`2<Type, ElementType> type_etype_mapping;
    public MetadataImporter(ModuleDefinition module);
    private static MetadataImporter();
    public TypeReference ImportType(Type type, ImportGenericContext context);
    public TypeReference ImportType(Type type, ImportGenericContext context, ImportGenericKind import_kind);
    private static bool ImportOpenGenericType(Type type, ImportGenericKind import_kind);
    private static bool ImportOpenGenericMethod(MethodBase method, ImportGenericKind import_kind);
    private static bool IsNestedType(Type type);
    private TypeReference ImportTypeSpecification(Type type, ImportGenericContext context);
    private static TypeReference ImportGenericParameter(Type type, ImportGenericContext context);
    private static string NormalizeMethodName(MethodBase method);
    private static string NormalizeTypeFullName(Type type);
    private TypeReference ImportGenericInstance(Type type, ImportGenericContext context);
    private static bool IsTypeSpecification(Type type);
    private static bool IsGenericInstance(Type type);
    private static ElementType ImportElementType(Type type);
    private AssemblyNameReference ImportScope(Assembly assembly);
    private bool TryGetAssemblyNameReference(AssemblyName name, AssemblyNameReference& assembly_reference);
    public FieldReference ImportField(FieldInfo field, ImportGenericContext context);
    private static FieldInfo ResolveFieldDefinition(FieldInfo field);
    public MethodReference ImportMethod(MethodBase method, ImportGenericContext context, ImportGenericKind import_kind);
    private static void ImportGenericParameters(IGenericParameterProvider provider, Type[] arguments);
    private static bool IsMethodSpecification(MethodBase method);
    private MethodReference ImportMethodSpecification(MethodBase method, ImportGenericContext context);
    private static bool HasCallingConvention(MethodBase method, CallingConventions conventions);
    public TypeReference ImportType(TypeReference type, ImportGenericContext context);
    private IMetadataScope ImportScope(IMetadataScope scope);
    private AssemblyNameReference ImportAssemblyName(AssemblyNameReference name);
    private bool TryGetAssemblyNameReference(AssemblyNameReference name_reference, AssemblyNameReference& assembly_reference);
    private static void ImportGenericParameters(IGenericParameterProvider imported, IGenericParameterProvider original);
    private TypeReference ImportTypeSpecification(TypeReference type, ImportGenericContext context);
    public FieldReference ImportField(FieldReference field, ImportGenericContext context);
    public MethodReference ImportMethod(MethodReference method, ImportGenericContext context);
    private MethodSpecification ImportMethodSpecification(MethodReference method, ImportGenericContext context);
}
internal class Mono.Cecil.MetadataReader : ByteBuffer {
    internal Image image;
    internal ModuleDefinition module;
    internal MetadataSystem metadata;
    internal IGenericContext context;
    internal CodeReader code;
    private UInt32 Position { get; private set; }
    public MetadataReader(ModuleDefinition module);
    private UInt32 get_Position();
    private void set_Position(UInt32 value);
    private int GetCodedIndexSize(CodedIndex index);
    private UInt32 ReadByIndexSize(int size);
    private Byte[] ReadBlob();
    private Byte[] ReadBlob(UInt32 signature);
    private UInt32 ReadBlobIndex();
    private string ReadString();
    private UInt32 ReadStringIndex();
    private UInt32 ReadTableIndex(Table table);
    private MetadataToken ReadMetadataToken(CodedIndex index);
    private int MoveTo(Table table);
    private bool MoveTo(Table table, UInt32 row);
    public AssemblyNameDefinition ReadAssemblyNameDefinition();
    public ModuleDefinition Populate(ModuleDefinition module);
    private void InitializeAssemblyReferences();
    public Collection`1<AssemblyNameReference> ReadAssemblyReferences();
    public MethodDefinition ReadEntryPoint();
    public Collection`1<ModuleDefinition> ReadModules();
    private string GetModuleFileName(string name);
    private void InitializeModuleReferences();
    public Collection`1<ModuleReference> ReadModuleReferences();
    public bool HasFileResource();
    public Collection`1<Resource> ReadResources();
    private Row`3<FileAttributes, string, UInt32> ReadFileRecord(UInt32 rid);
    public MemoryStream GetManagedResourceStream(UInt32 offset);
    private void PopulateVersionAndFlags(AssemblyNameReference name);
    private void PopulateNameAndCulture(AssemblyNameReference name);
    public TypeDefinitionCollection ReadTypes();
    private void CompleteTypes();
    private void InitializeTypeDefinitions();
    private static bool IsNested(TypeAttributes attributes);
    public bool HasNestedTypes(TypeDefinition type);
    public Collection`1<TypeDefinition> ReadNestedTypes(TypeDefinition type);
    private void InitializeNestedTypes();
    private void AddNestedMapping(UInt32 declaring, UInt32 nested);
    private static TValue[] AddMapping(Dictionary`2<TKey, TValue[]> cache, TKey key, TValue value);
    private TypeDefinition ReadType(UInt32 rid);
    private TypeDefinition GetNestedTypeDeclaringType(TypeDefinition type);
    private Range ReadFieldsRange(UInt32 type_index);
    private Range ReadMethodsRange(UInt32 type_index);
    private Range ReadListRange(UInt32 current_index, Table current, Table target);
    public Row`2<short, int> ReadTypeLayout(TypeDefinition type);
    private void InitializeTypeLayouts();
    public TypeReference GetTypeDefOrRef(MetadataToken token);
    public TypeDefinition GetTypeDefinition(UInt32 rid);
    private TypeDefinition ReadTypeDefinition(UInt32 rid);
    private void InitializeTypeReferences();
    public TypeReference GetTypeReference(string scope, string full_name);
    private TypeReference GetTypeReference(UInt32 rid);
    private TypeReference ReadTypeReference(UInt32 rid);
    private IMetadataScope GetTypeReferenceScope(MetadataToken scope);
    public IEnumerable`1<TypeReference> GetTypeReferences();
    private TypeReference GetTypeSpecification(UInt32 rid);
    private SignatureReader ReadSignature(UInt32 signature);
    public bool HasInterfaces(TypeDefinition type);
    public Collection`1<TypeReference> ReadInterfaces(TypeDefinition type);
    private void InitializeInterfaces();
    private void AddInterfaceMapping(UInt32 type, MetadataToken interface);
    public Collection`1<FieldDefinition> ReadFields(TypeDefinition type);
    private void ReadField(UInt32 field_rid, Collection`1<FieldDefinition> fields);
    private void InitializeFields();
    private TypeReference ReadFieldType(UInt32 signature);
    public int ReadFieldRVA(FieldDefinition field);
    private Byte[] GetFieldInitializeValue(int size, UInt32 rva);
    private static int GetFieldTypeSize(TypeReference type);
    private void InitializeFieldRVAs();
    public int ReadFieldLayout(FieldDefinition field);
    private void InitializeFieldLayouts();
    public bool HasEvents(TypeDefinition type);
    public Collection`1<EventDefinition> ReadEvents(TypeDefinition type);
    private void ReadEvent(UInt32 event_rid, Collection`1<EventDefinition> events);
    private void InitializeEvents();
    private Range ReadEventsRange(UInt32 rid);
    public bool HasProperties(TypeDefinition type);
    public Collection`1<PropertyDefinition> ReadProperties(TypeDefinition type);
    private void ReadProperty(UInt32 property_rid, Collection`1<PropertyDefinition> properties);
    private void InitializeProperties();
    private Range ReadPropertiesRange(UInt32 rid);
    private MethodSemanticsAttributes ReadMethodSemantics(MethodDefinition method);
    private static EventDefinition GetEvent(TypeDefinition type, MetadataToken token);
    private static PropertyDefinition GetProperty(TypeDefinition type, MetadataToken token);
    private static TMember GetMember(Collection`1<TMember> members, MetadataToken token);
    private void InitializeMethodSemantics();
    public PropertyDefinition ReadMethods(PropertyDefinition property);
    public EventDefinition ReadMethods(EventDefinition event);
    public MethodSemanticsAttributes ReadAllSemantics(MethodDefinition method);
    private void ReadAllSemantics(TypeDefinition type);
    private Range ReadParametersRange(UInt32 method_rid);
    public Collection`1<MethodDefinition> ReadMethods(TypeDefinition type);
    private void ReadPointers(Table ptr, Table table, Range range, Collection`1<TMember> members, Action`2<UInt32, Collection`1<TMember>> reader);
    private static bool IsDeleted(IMemberDefinition member);
    private void InitializeMethods();
    private void ReadMethod(UInt32 method_rid, Collection`1<MethodDefinition> methods);
    private void ReadParameters(MethodDefinition method, Range param_range);
    private void ReadParameterPointers(MethodDefinition method, Range range);
    private void ReadParameter(UInt32 param_rid, MethodDefinition method);
    private void ReadMethodSignature(UInt32 signature, IMethodSignature method);
    public PInvokeInfo ReadPInvokeInfo(MethodDefinition method);
    private void InitializePInvokes();
    public bool HasGenericParameters(IGenericParameterProvider provider);
    public Collection`1<GenericParameter> ReadGenericParameters(IGenericParameterProvider provider);
    private void ReadGenericParametersRange(Range range, IGenericParameterProvider provider, GenericParameterCollection generic_parameters);
    private void InitializeGenericParameters();
    private Dictionary`2<MetadataToken, Range[]> InitializeRanges(Table table, Func`1<MetadataToken> get_next);
    private static void AddRange(Dictionary`2<MetadataToken, Range[]> ranges, MetadataToken owner, Range range);
    public bool HasGenericConstraints(GenericParameter generic_parameter);
    public Collection`1<TypeReference> ReadGenericConstraints(GenericParameter generic_parameter);
    private void InitializeGenericConstraints();
    private void AddGenericConstraintMapping(UInt32 generic_parameter, MetadataToken constraint);
    public bool HasOverrides(MethodDefinition method);
    public Collection`1<MethodReference> ReadOverrides(MethodDefinition method);
    private void InitializeOverrides();
    private void AddOverrideMapping(UInt32 method_rid, MetadataToken override);
    public MethodBody ReadMethodBody(MethodDefinition method);
    public CallSite ReadCallSite(MetadataToken token);
    public VariableDefinitionCollection ReadVariables(MetadataToken local_var_token);
    public IMetadataTokenProvider LookupToken(MetadataToken token);
    public FieldDefinition GetFieldDefinition(UInt32 rid);
    private FieldDefinition LookupField(UInt32 rid);
    public MethodDefinition GetMethodDefinition(UInt32 rid);
    private MethodDefinition LookupMethod(UInt32 rid);
    private MethodSpecification GetMethodSpecification(UInt32 rid);
    private MethodSpecification ReadMethodSpecSignature(UInt32 signature, MethodReference method);
    private MemberReference GetMemberReference(UInt32 rid);
    private MemberReference ReadMemberReference(UInt32 rid);
    private MemberReference ReadTypeMemberReference(MetadataToken type, string name, UInt32 signature);
    private MemberReference ReadMemberReferenceSignature(UInt32 signature, TypeReference declaring_type);
    private MemberReference ReadMethodMemberReference(MetadataToken token, string name, UInt32 signature);
    private void InitializeMemberReferences();
    public IEnumerable`1<MemberReference> GetMemberReferences();
    private void InitializeConstants();
    public object ReadConstant(IConstantProvider owner);
    private static string ReadConstantString(Byte[] blob);
    private object ReadConstantPrimitive(ElementType type, UInt32 signature);
    private void InitializeCustomAttributes();
    public bool HasCustomAttributes(ICustomAttributeProvider owner);
    public Collection`1<CustomAttribute> ReadCustomAttributes(ICustomAttributeProvider owner);
    private void ReadCustomAttributeRange(Range range, Collection`1<CustomAttribute> custom_attributes);
    private static int RangesSize(Range[] ranges);
    public Byte[] ReadCustomAttributeBlob(UInt32 signature);
    public void ReadCustomAttributeSignature(CustomAttribute attribute);
    private void InitializeMarshalInfos();
    public bool HasMarshalInfo(IMarshalInfoProvider owner);
    public MarshalInfo ReadMarshalInfo(IMarshalInfoProvider owner);
    private void InitializeSecurityDeclarations();
    public bool HasSecurityDeclarations(ISecurityDeclarationProvider owner);
    public Collection`1<SecurityDeclaration> ReadSecurityDeclarations(ISecurityDeclarationProvider owner);
    private void ReadSecurityDeclarationRange(Range range, Collection`1<SecurityDeclaration> security_declarations);
    public Byte[] ReadSecurityDeclarationBlob(UInt32 signature);
    public void ReadSecurityDeclarationSignature(SecurityDeclaration declaration);
    private void ReadXmlSecurityDeclaration(UInt32 signature, SecurityDeclaration declaration);
    public Collection`1<ExportedType> ReadExportedTypes();
    private IMetadataScope GetExportedTypeScope(MetadataToken token);
    private ModuleReference GetModuleReferenceFromFile(MetadataToken token);
    private static void InitializeCollection(object o);
    [CompilerGeneratedAttribute]
private MetadataToken <InitializeGenericParameters>b__110_0();
    [CompilerGeneratedAttribute]
private MetadataToken <InitializeCustomAttributes>b__142_0();
    [CompilerGeneratedAttribute]
private MetadataToken <InitializeSecurityDeclarations>b__152_0();
}
public class Mono.Cecil.MetadataResolver : object {
    private IAssemblyResolver assembly_resolver;
    public IAssemblyResolver AssemblyResolver { get; }
    public MetadataResolver(IAssemblyResolver assemblyResolver);
    public IAssemblyResolver get_AssemblyResolver();
    public virtual TypeDefinition Resolve(TypeReference type);
    private static TypeDefinition GetType(ModuleDefinition module, TypeReference reference);
    private static TypeDefinition GetTypeDefinition(ModuleDefinition module, TypeReference type);
    public virtual FieldDefinition Resolve(FieldReference field);
    private FieldDefinition GetField(TypeDefinition type, FieldReference reference);
    private static FieldDefinition GetField(Collection`1<FieldDefinition> fields, FieldReference reference);
    public virtual MethodDefinition Resolve(MethodReference method);
    private MethodDefinition GetMethod(TypeDefinition type, MethodReference reference);
    public static MethodDefinition GetMethod(Collection`1<MethodDefinition> methods, MethodReference reference);
    private static bool AreSame(Collection`1<ParameterDefinition> a, Collection`1<ParameterDefinition> b);
    private static bool AreSame(TypeSpecification a, TypeSpecification b);
    private static bool AreSame(ArrayType a, ArrayType b);
    private static bool AreSame(IModifierType a, IModifierType b);
    private static bool AreSame(GenericInstanceType a, GenericInstanceType b);
    private static bool AreSame(GenericParameter a, GenericParameter b);
    private static bool AreSame(TypeReference a, TypeReference b);
}
public enum Mono.Cecil.MetadataScopeType : Enum {
    public int value__;
    public static MetadataScopeType AssemblyNameReference;
    public static MetadataScopeType ModuleReference;
    public static MetadataScopeType ModuleDefinition;
}
internal class Mono.Cecil.MetadataSystem : object {
    internal AssemblyNameReference[] AssemblyReferences;
    internal ModuleReference[] ModuleReferences;
    internal TypeDefinition[] Types;
    internal TypeReference[] TypeReferences;
    internal FieldDefinition[] Fields;
    internal MethodDefinition[] Methods;
    internal MemberReference[] MemberReferences;
    internal Dictionary`2<UInt32, UInt32[]> NestedTypes;
    internal Dictionary`2<UInt32, UInt32> ReverseNestedTypes;
    internal Dictionary`2<UInt32, MetadataToken[]> Interfaces;
    internal Dictionary`2<UInt32, Row`2<ushort, UInt32>> ClassLayouts;
    internal Dictionary`2<UInt32, UInt32> FieldLayouts;
    internal Dictionary`2<UInt32, UInt32> FieldRVAs;
    internal Dictionary`2<MetadataToken, UInt32> FieldMarshals;
    internal Dictionary`2<MetadataToken, Row`2<ElementType, UInt32>> Constants;
    internal Dictionary`2<UInt32, MetadataToken[]> Overrides;
    internal Dictionary`2<MetadataToken, Range[]> CustomAttributes;
    internal Dictionary`2<MetadataToken, Range[]> SecurityDeclarations;
    internal Dictionary`2<UInt32, Range> Events;
    internal Dictionary`2<UInt32, Range> Properties;
    internal Dictionary`2<UInt32, Row`2<MethodSemanticsAttributes, MetadataToken>> Semantics;
    internal Dictionary`2<UInt32, Row`3<PInvokeAttributes, UInt32, UInt32>> PInvokes;
    internal Dictionary`2<MetadataToken, Range[]> GenericParameters;
    internal Dictionary`2<UInt32, MetadataToken[]> GenericConstraints;
    private static Dictionary`2<string, Row`2<ElementType, bool>> primitive_value_types;
    private static void InitializePrimitives();
    public static void TryProcessPrimitiveTypeReference(TypeReference type);
    public static bool TryGetPrimitiveElementType(TypeDefinition type, ElementType& etype);
    private static bool TryGetPrimitiveData(TypeReference type, Row`2& primitive_data);
    public void Clear();
    public TypeDefinition GetTypeDefinition(UInt32 rid);
    public void AddTypeDefinition(TypeDefinition type);
    public TypeReference GetTypeReference(UInt32 rid);
    public void AddTypeReference(TypeReference type);
    public FieldDefinition GetFieldDefinition(UInt32 rid);
    public void AddFieldDefinition(FieldDefinition field);
    public MethodDefinition GetMethodDefinition(UInt32 rid);
    public void AddMethodDefinition(MethodDefinition method);
    public MemberReference GetMemberReference(UInt32 rid);
    public void AddMemberReference(MemberReference member);
    public bool TryGetNestedTypeMapping(TypeDefinition type, UInt32[]& mapping);
    public void SetNestedTypeMapping(UInt32 type_rid, UInt32[] mapping);
    public void RemoveNestedTypeMapping(TypeDefinition type);
    public bool TryGetReverseNestedTypeMapping(TypeDefinition type, UInt32& declaring);
    public void SetReverseNestedTypeMapping(UInt32 nested, UInt32 declaring);
    public void RemoveReverseNestedTypeMapping(TypeDefinition type);
    public bool TryGetInterfaceMapping(TypeDefinition type, MetadataToken[]& mapping);
    public void SetInterfaceMapping(UInt32 type_rid, MetadataToken[] mapping);
    public void RemoveInterfaceMapping(TypeDefinition type);
    public void AddPropertiesRange(UInt32 type_rid, Range range);
    public bool TryGetPropertiesRange(TypeDefinition type, Range& range);
    public void RemovePropertiesRange(TypeDefinition type);
    public void AddEventsRange(UInt32 type_rid, Range range);
    public bool TryGetEventsRange(TypeDefinition type, Range& range);
    public void RemoveEventsRange(TypeDefinition type);
    public bool TryGetGenericParameterRanges(IGenericParameterProvider owner, Range[]& ranges);
    public void RemoveGenericParameterRange(IGenericParameterProvider owner);
    public bool TryGetCustomAttributeRanges(ICustomAttributeProvider owner, Range[]& ranges);
    public void RemoveCustomAttributeRange(ICustomAttributeProvider owner);
    public bool TryGetSecurityDeclarationRanges(ISecurityDeclarationProvider owner, Range[]& ranges);
    public void RemoveSecurityDeclarationRange(ISecurityDeclarationProvider owner);
    public bool TryGetGenericConstraintMapping(GenericParameter generic_parameter, MetadataToken[]& mapping);
    public void SetGenericConstraintMapping(UInt32 gp_rid, MetadataToken[] mapping);
    public void RemoveGenericConstraintMapping(GenericParameter generic_parameter);
    public bool TryGetOverrideMapping(MethodDefinition method, MetadataToken[]& mapping);
    public void SetOverrideMapping(UInt32 rid, MetadataToken[] mapping);
    public void RemoveOverrideMapping(MethodDefinition method);
    public TypeDefinition GetFieldDeclaringType(UInt32 field_rid);
    public TypeDefinition GetMethodDeclaringType(UInt32 method_rid);
    private static TypeDefinition BinaryRangeSearch(TypeDefinition[] types, UInt32 rid, bool field);
}
internal abstract class Mono.Cecil.MetadataTable : object {
    public int Length { get; }
    public bool IsLarge { get; }
    public abstract virtual int get_Length();
    public bool get_IsLarge();
    public abstract virtual void Write(TableHeapBuffer buffer);
    public abstract virtual void Sort();
}
internal abstract class Mono.Cecil.MetadataTable`1 : MetadataTable {
    internal TRow[] rows;
    internal int length;
    public int Length { get; }
    public sealed virtual int get_Length();
    public int AddRow(TRow row);
    private void Grow();
    public virtual void Sort();
}
public class Mono.Cecil.MetadataToken : ValueType {
    private UInt32 token;
    public static MetadataToken Zero;
    public UInt32 RID { get; }
    public TokenType TokenType { get; }
    public MetadataToken(UInt32 token);
    public MetadataToken(TokenType type);
    public MetadataToken(TokenType type, UInt32 rid);
    public MetadataToken(TokenType type, int rid);
    private static MetadataToken();
    public UInt32 get_RID();
    public TokenType get_TokenType();
    public int ToInt32();
    public UInt32 ToUInt32();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public static bool op_Equality(MetadataToken one, MetadataToken other);
    public static bool op_Inequality(MetadataToken one, MetadataToken other);
    public virtual string ToString();
}
public enum Mono.Cecil.MetadataType : Enum {
    public byte value__;
    public static MetadataType Void;
    public static MetadataType Boolean;
    public static MetadataType Char;
    public static MetadataType SByte;
    public static MetadataType Byte;
    public static MetadataType Int16;
    public static MetadataType UInt16;
    public static MetadataType Int32;
    public static MetadataType UInt32;
    public static MetadataType Int64;
    public static MetadataType UInt64;
    public static MetadataType Single;
    public static MetadataType Double;
    public static MetadataType String;
    public static MetadataType Pointer;
    public static MetadataType ByReference;
    public static MetadataType ValueType;
    public static MetadataType Class;
    public static MetadataType Var;
    public static MetadataType Array;
    public static MetadataType GenericInstance;
    public static MetadataType TypedByReference;
    public static MetadataType IntPtr;
    public static MetadataType UIntPtr;
    public static MetadataType FunctionPointer;
    public static MetadataType Object;
    public static MetadataType MVar;
    public static MetadataType RequiredModifier;
    public static MetadataType OptionalModifier;
    public static MetadataType Sentinel;
    public static MetadataType Pinned;
}
[FlagsAttribute]
public enum Mono.Cecil.MethodAttributes : Enum {
    public ushort value__;
    public static MethodAttributes MemberAccessMask;
    public static MethodAttributes CompilerControlled;
    public static MethodAttributes Private;
    public static MethodAttributes FamANDAssem;
    public static MethodAttributes Assembly;
    public static MethodAttributes Family;
    public static MethodAttributes FamORAssem;
    public static MethodAttributes Public;
    public static MethodAttributes Static;
    public static MethodAttributes Final;
    public static MethodAttributes Virtual;
    public static MethodAttributes HideBySig;
    public static MethodAttributes VtableLayoutMask;
    public static MethodAttributes ReuseSlot;
    public static MethodAttributes NewSlot;
    public static MethodAttributes CheckAccessOnOverride;
    public static MethodAttributes Abstract;
    public static MethodAttributes SpecialName;
    public static MethodAttributes PInvokeImpl;
    public static MethodAttributes UnmanagedExport;
    public static MethodAttributes RTSpecialName;
    public static MethodAttributes HasSecurity;
    public static MethodAttributes RequireSecObject;
}
public enum Mono.Cecil.MethodCallingConvention : Enum {
    public byte value__;
    public static MethodCallingConvention Default;
    public static MethodCallingConvention C;
    public static MethodCallingConvention StdCall;
    public static MethodCallingConvention ThisCall;
    public static MethodCallingConvention FastCall;
    public static MethodCallingConvention VarArg;
    public static MethodCallingConvention Generic;
}
public class Mono.Cecil.MethodDefinition : MethodReference {
    private ushort attributes;
    private ushort impl_attributes;
    internal Boolean modreq(System.Runtime.CompilerServices.IsVolatile) sem_attrs_ready;
    internal MethodSemanticsAttributes sem_attrs;
    private Collection`1<CustomAttribute> custom_attributes;
    private Collection`1<SecurityDeclaration> security_declarations;
    internal UInt32 rva;
    internal PInvokeInfo pinvoke;
    private Collection`1<MethodReference> overrides;
    internal MethodBody body;
    public MethodAttributes Attributes { get; public set; }
    public MethodImplAttributes ImplAttributes { get; public set; }
    public MethodSemanticsAttributes SemanticsAttributes { get; public set; }
    public bool HasSecurityDeclarations { get; }
    public Collection`1<SecurityDeclaration> SecurityDeclarations { get; }
    public bool HasCustomAttributes { get; }
    public Collection`1<CustomAttribute> CustomAttributes { get; }
    public int RVA { get; }
    public bool HasBody { get; }
    public MethodBody Body { get; public set; }
    public bool HasPInvokeInfo { get; }
    public PInvokeInfo PInvokeInfo { get; public set; }
    public bool HasOverrides { get; }
    public Collection`1<MethodReference> Overrides { get; }
    public bool HasGenericParameters { get; }
    public Collection`1<GenericParameter> GenericParameters { get; }
    public bool IsCompilerControlled { get; public set; }
    public bool IsPrivate { get; public set; }
    public bool IsFamilyAndAssembly { get; public set; }
    public bool IsAssembly { get; public set; }
    public bool IsFamily { get; public set; }
    public bool IsFamilyOrAssembly { get; public set; }
    public bool IsPublic { get; public set; }
    public bool IsStatic { get; public set; }
    public bool IsFinal { get; public set; }
    public bool IsVirtual { get; public set; }
    public bool IsHideBySig { get; public set; }
    public bool IsReuseSlot { get; public set; }
    public bool IsNewSlot { get; public set; }
    public bool IsCheckAccessOnOverride { get; public set; }
    public bool IsAbstract { get; public set; }
    public bool IsSpecialName { get; public set; }
    public bool IsPInvokeImpl { get; public set; }
    public bool IsUnmanagedExport { get; public set; }
    public bool IsRuntimeSpecialName { get; public set; }
    public bool HasSecurity { get; public set; }
    public bool IsIL { get; public set; }
    public bool IsNative { get; public set; }
    public bool IsRuntime { get; public set; }
    public bool IsUnmanaged { get; public set; }
    public bool IsManaged { get; public set; }
    public bool IsForwardRef { get; public set; }
    public bool IsPreserveSig { get; public set; }
    public bool IsInternalCall { get; public set; }
    public bool IsSynchronized { get; public set; }
    public bool NoInlining { get; public set; }
    public bool NoOptimization { get; public set; }
    public bool IsSetter { get; public set; }
    public bool IsGetter { get; public set; }
    public bool IsOther { get; public set; }
    public bool IsAddOn { get; public set; }
    public bool IsRemoveOn { get; public set; }
    public bool IsFire { get; public set; }
    public TypeDefinition DeclaringType { get; public set; }
    public bool IsConstructor { get; }
    public bool IsDefinition { get; }
    public MethodDefinition(string name, MethodAttributes attributes, TypeReference returnType);
    public MethodAttributes get_Attributes();
    public void set_Attributes(MethodAttributes value);
    public MethodImplAttributes get_ImplAttributes();
    public void set_ImplAttributes(MethodImplAttributes value);
    public MethodSemanticsAttributes get_SemanticsAttributes();
    public void set_SemanticsAttributes(MethodSemanticsAttributes value);
    internal void ReadSemantics();
    public sealed virtual bool get_HasSecurityDeclarations();
    public sealed virtual Collection`1<SecurityDeclaration> get_SecurityDeclarations();
    public sealed virtual bool get_HasCustomAttributes();
    public sealed virtual Collection`1<CustomAttribute> get_CustomAttributes();
    public int get_RVA();
    public bool get_HasBody();
    public MethodBody get_Body();
    public void set_Body(MethodBody value);
    public bool get_HasPInvokeInfo();
    public PInvokeInfo get_PInvokeInfo();
    public void set_PInvokeInfo(PInvokeInfo value);
    public bool get_HasOverrides();
    public Collection`1<MethodReference> get_Overrides();
    public virtual bool get_HasGenericParameters();
    public virtual Collection`1<GenericParameter> get_GenericParameters();
    public bool get_IsCompilerControlled();
    public void set_IsCompilerControlled(bool value);
    public bool get_IsPrivate();
    public void set_IsPrivate(bool value);
    public bool get_IsFamilyAndAssembly();
    public void set_IsFamilyAndAssembly(bool value);
    public bool get_IsAssembly();
    public void set_IsAssembly(bool value);
    public bool get_IsFamily();
    public void set_IsFamily(bool value);
    public bool get_IsFamilyOrAssembly();
    public void set_IsFamilyOrAssembly(bool value);
    public bool get_IsPublic();
    public void set_IsPublic(bool value);
    public bool get_IsStatic();
    public void set_IsStatic(bool value);
    public bool get_IsFinal();
    public void set_IsFinal(bool value);
    public bool get_IsVirtual();
    public void set_IsVirtual(bool value);
    public bool get_IsHideBySig();
    public void set_IsHideBySig(bool value);
    public bool get_IsReuseSlot();
    public void set_IsReuseSlot(bool value);
    public bool get_IsNewSlot();
    public void set_IsNewSlot(bool value);
    public bool get_IsCheckAccessOnOverride();
    public void set_IsCheckAccessOnOverride(bool value);
    public bool get_IsAbstract();
    public void set_IsAbstract(bool value);
    public sealed virtual bool get_IsSpecialName();
    public sealed virtual void set_IsSpecialName(bool value);
    public bool get_IsPInvokeImpl();
    public void set_IsPInvokeImpl(bool value);
    public bool get_IsUnmanagedExport();
    public void set_IsUnmanagedExport(bool value);
    public sealed virtual bool get_IsRuntimeSpecialName();
    public sealed virtual void set_IsRuntimeSpecialName(bool value);
    public bool get_HasSecurity();
    public void set_HasSecurity(bool value);
    public bool get_IsIL();
    public void set_IsIL(bool value);
    public bool get_IsNative();
    public void set_IsNative(bool value);
    public bool get_IsRuntime();
    public void set_IsRuntime(bool value);
    public bool get_IsUnmanaged();
    public void set_IsUnmanaged(bool value);
    public bool get_IsManaged();
    public void set_IsManaged(bool value);
    public bool get_IsForwardRef();
    public void set_IsForwardRef(bool value);
    public bool get_IsPreserveSig();
    public void set_IsPreserveSig(bool value);
    public bool get_IsInternalCall();
    public void set_IsInternalCall(bool value);
    public bool get_IsSynchronized();
    public void set_IsSynchronized(bool value);
    public bool get_NoInlining();
    public void set_NoInlining(bool value);
    public bool get_NoOptimization();
    public void set_NoOptimization(bool value);
    public bool get_IsSetter();
    public void set_IsSetter(bool value);
    public bool get_IsGetter();
    public void set_IsGetter(bool value);
    public bool get_IsOther();
    public void set_IsOther(bool value);
    public bool get_IsAddOn();
    public void set_IsAddOn(bool value);
    public bool get_IsRemoveOn();
    public void set_IsRemoveOn(bool value);
    public bool get_IsFire();
    public void set_IsFire(bool value);
    public sealed virtual TypeDefinition get_DeclaringType();
    public sealed virtual void set_DeclaringType(TypeDefinition value);
    public bool get_IsConstructor();
    public virtual bool get_IsDefinition();
    public virtual MethodDefinition Resolve();
}
[FlagsAttribute]
public enum Mono.Cecil.MethodImplAttributes : Enum {
    public ushort value__;
    public static MethodImplAttributes CodeTypeMask;
    public static MethodImplAttributes IL;
    public static MethodImplAttributes Native;
    public static MethodImplAttributes OPTIL;
    public static MethodImplAttributes Runtime;
    public static MethodImplAttributes ManagedMask;
    public static MethodImplAttributes Unmanaged;
    public static MethodImplAttributes Managed;
    public static MethodImplAttributes ForwardRef;
    public static MethodImplAttributes PreserveSig;
    public static MethodImplAttributes InternalCall;
    public static MethodImplAttributes Synchronized;
    public static MethodImplAttributes NoOptimization;
    public static MethodImplAttributes NoInlining;
}
internal class Mono.Cecil.MethodImplTable : MetadataTable`1<Row`3<UInt32, UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
}
public class Mono.Cecil.MethodReference : MemberReference {
    internal ParameterDefinitionCollection parameters;
    private MethodReturnType return_type;
    private bool has_this;
    private bool explicit_this;
    private MethodCallingConvention calling_convention;
    internal Collection`1<GenericParameter> generic_parameters;
    public bool HasThis { get; public set; }
    public bool ExplicitThis { get; public set; }
    public MethodCallingConvention CallingConvention { get; public set; }
    public bool HasParameters { get; }
    public Collection`1<ParameterDefinition> Parameters { get; }
    private IGenericParameterProvider Mono.Cecil.IGenericContext.Type { get; }
    private IGenericParameterProvider Mono.Cecil.IGenericContext.Method { get; }
    private GenericParameterType Mono.Cecil.IGenericParameterProvider.GenericParameterType { get; }
    public bool HasGenericParameters { get; }
    public Collection`1<GenericParameter> GenericParameters { get; }
    public TypeReference ReturnType { get; public set; }
    public MethodReturnType MethodReturnType { get; public set; }
    public string FullName { get; }
    public bool IsGenericInstance { get; }
    public bool ContainsGenericParameter { get; }
    public MethodReference(string name, TypeReference returnType);
    public MethodReference(string name, TypeReference returnType, TypeReference declaringType);
    public virtual bool get_HasThis();
    public virtual void set_HasThis(bool value);
    public virtual bool get_ExplicitThis();
    public virtual void set_ExplicitThis(bool value);
    public virtual MethodCallingConvention get_CallingConvention();
    public virtual void set_CallingConvention(MethodCallingConvention value);
    public virtual bool get_HasParameters();
    public virtual Collection`1<ParameterDefinition> get_Parameters();
    private sealed virtual override IGenericParameterProvider Mono.Cecil.IGenericContext.get_Type();
    private sealed virtual override IGenericParameterProvider Mono.Cecil.IGenericContext.get_Method();
    private sealed virtual override GenericParameterType Mono.Cecil.IGenericParameterProvider.get_GenericParameterType();
    public virtual bool get_HasGenericParameters();
    public virtual Collection`1<GenericParameter> get_GenericParameters();
    public sealed virtual TypeReference get_ReturnType();
    public sealed virtual void set_ReturnType(TypeReference value);
    public virtual MethodReturnType get_MethodReturnType();
    public virtual void set_MethodReturnType(MethodReturnType value);
    public virtual string get_FullName();
    public virtual bool get_IsGenericInstance();
    public virtual bool get_ContainsGenericParameter();
    public virtual MethodReference GetElementMethod();
    public virtual MethodDefinition Resolve();
}
public class Mono.Cecil.MethodReturnType : object {
    internal IMethodSignature method;
    internal ParameterDefinition parameter;
    private TypeReference return_type;
    public IMethodSignature Method { get; }
    public TypeReference ReturnType { get; public set; }
    internal ParameterDefinition Parameter { get; }
    public MetadataToken MetadataToken { get; public set; }
    public ParameterAttributes Attributes { get; public set; }
    public bool HasCustomAttributes { get; }
    public Collection`1<CustomAttribute> CustomAttributes { get; }
    public bool HasDefault { get; public set; }
    public bool HasConstant { get; public set; }
    public object Constant { get; public set; }
    public bool HasFieldMarshal { get; public set; }
    public bool HasMarshalInfo { get; }
    public MarshalInfo MarshalInfo { get; public set; }
    public MethodReturnType(IMethodSignature method);
    public IMethodSignature get_Method();
    public TypeReference get_ReturnType();
    public void set_ReturnType(TypeReference value);
    internal ParameterDefinition get_Parameter();
    public sealed virtual MetadataToken get_MetadataToken();
    public sealed virtual void set_MetadataToken(MetadataToken value);
    public ParameterAttributes get_Attributes();
    public void set_Attributes(ParameterAttributes value);
    public sealed virtual bool get_HasCustomAttributes();
    public sealed virtual Collection`1<CustomAttribute> get_CustomAttributes();
    public bool get_HasDefault();
    public void set_HasDefault(bool value);
    public sealed virtual bool get_HasConstant();
    public sealed virtual void set_HasConstant(bool value);
    public sealed virtual object get_Constant();
    public sealed virtual void set_Constant(object value);
    public bool get_HasFieldMarshal();
    public void set_HasFieldMarshal(bool value);
    public sealed virtual bool get_HasMarshalInfo();
    public sealed virtual MarshalInfo get_MarshalInfo();
    public sealed virtual void set_MarshalInfo(MarshalInfo value);
}
[FlagsAttribute]
public enum Mono.Cecil.MethodSemanticsAttributes : Enum {
    public ushort value__;
    public static MethodSemanticsAttributes None;
    public static MethodSemanticsAttributes Setter;
    public static MethodSemanticsAttributes Getter;
    public static MethodSemanticsAttributes Other;
    public static MethodSemanticsAttributes AddOn;
    public static MethodSemanticsAttributes RemoveOn;
    public static MethodSemanticsAttributes Fire;
}
internal class Mono.Cecil.MethodSemanticsTable : SortedTable`1<Row`3<MethodSemanticsAttributes, UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
    public virtual int Compare(Row`3<MethodSemanticsAttributes, UInt32, UInt32> x, Row`3<MethodSemanticsAttributes, UInt32, UInt32> y);
}
public abstract class Mono.Cecil.MethodSpecification : MethodReference {
    private MethodReference method;
    public MethodReference ElementMethod { get; }
    public string Name { get; public set; }
    public MethodCallingConvention CallingConvention { get; public set; }
    public bool HasThis { get; public set; }
    public bool ExplicitThis { get; public set; }
    public MethodReturnType MethodReturnType { get; public set; }
    public TypeReference DeclaringType { get; public set; }
    public ModuleDefinition Module { get; }
    public bool HasParameters { get; }
    public Collection`1<ParameterDefinition> Parameters { get; }
    public bool ContainsGenericParameter { get; }
    internal MethodSpecification(MethodReference method);
    public MethodReference get_ElementMethod();
    public virtual string get_Name();
    public virtual void set_Name(string value);
    public virtual MethodCallingConvention get_CallingConvention();
    public virtual void set_CallingConvention(MethodCallingConvention value);
    public virtual bool get_HasThis();
    public virtual void set_HasThis(bool value);
    public virtual bool get_ExplicitThis();
    public virtual void set_ExplicitThis(bool value);
    public virtual MethodReturnType get_MethodReturnType();
    public virtual void set_MethodReturnType(MethodReturnType value);
    public virtual TypeReference get_DeclaringType();
    public virtual void set_DeclaringType(TypeReference value);
    public virtual ModuleDefinition get_Module();
    public virtual bool get_HasParameters();
    public virtual Collection`1<ParameterDefinition> get_Parameters();
    public virtual bool get_ContainsGenericParameter();
    public sealed virtual MethodReference GetElementMethod();
}
internal class Mono.Cecil.MethodSpecTable : MetadataTable`1<Row`2<UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
}
internal class Mono.Cecil.MethodTable : MetadataTable`1<Row`6<UInt32, MethodImplAttributes, MethodAttributes, UInt32, UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
}
[ExtensionAttribute]
internal static class Mono.Cecil.Mixin : object {
    internal static object NoValue;
    internal static object NotResolved;
    public static int NotResolvedMarker;
    public static int NoDataMarker;
    private static Mixin();
    [ExtensionAttribute]
public static UInt32 ReadCompressedUInt32(Byte[] data, Int32& position);
    [ExtensionAttribute]
public static MetadataToken GetMetadataToken(CodedIndex self, UInt32 data);
    [ExtensionAttribute]
public static UInt32 CompressMetadataToken(CodedIndex self, MetadataToken token);
    [ExtensionAttribute]
public static int GetSize(CodedIndex self, Func`2<Table, int> counter);
    [ExtensionAttribute]
public static bool GetHasSecurityDeclarations(ISecurityDeclarationProvider self, ModuleDefinition module);
    [ExtensionAttribute]
public static Collection`1<SecurityDeclaration> GetSecurityDeclarations(ISecurityDeclarationProvider self, Collection`1& variable, ModuleDefinition module);
    public static void CheckName(string name);
    [ExtensionAttribute]
public static void ResolveConstant(IConstantProvider self, Object& constant, ModuleDefinition module);
    [ExtensionAttribute]
public static bool GetHasCustomAttributes(ICustomAttributeProvider self, ModuleDefinition module);
    [ExtensionAttribute]
public static Collection`1<CustomAttribute> GetCustomAttributes(ICustomAttributeProvider self, Collection`1& variable, ModuleDefinition module);
    [ExtensionAttribute]
public static bool ContainsGenericParameter(IGenericInstance self);
    [ExtensionAttribute]
public static void GenericInstanceFullName(IGenericInstance self, StringBuilder builder);
    [ExtensionAttribute]
public static bool GetHasGenericParameters(IGenericParameterProvider self, ModuleDefinition module);
    [ExtensionAttribute]
public static Collection`1<GenericParameter> GetGenericParameters(IGenericParameterProvider self, Collection`1& collection, ModuleDefinition module);
    [ExtensionAttribute]
public static bool GetHasMarshalInfo(IMarshalInfoProvider self, ModuleDefinition module);
    [ExtensionAttribute]
public static MarshalInfo GetMarshalInfo(IMarshalInfoProvider self, MarshalInfo& variable, ModuleDefinition module);
    public static void CheckModifier(TypeReference modifierType, TypeReference type);
    [ExtensionAttribute]
public static bool HasImplicitThis(IMethodSignature self);
    [ExtensionAttribute]
public static void MethodSignatureFullName(IMethodSignature self, StringBuilder builder);
    [ExtensionAttribute]
public static bool GetAttributes(UInt32 self, UInt32 attributes);
    [ExtensionAttribute]
public static UInt32 SetAttributes(UInt32 self, UInt32 attributes, bool value);
    [ExtensionAttribute]
public static bool GetMaskedAttributes(UInt32 self, UInt32 mask, UInt32 attributes);
    [ExtensionAttribute]
public static UInt32 SetMaskedAttributes(UInt32 self, UInt32 mask, UInt32 attributes, bool value);
    [ExtensionAttribute]
public static bool GetAttributes(ushort self, ushort attributes);
    [ExtensionAttribute]
public static ushort SetAttributes(ushort self, ushort attributes, bool value);
    [ExtensionAttribute]
public static bool GetMaskedAttributes(ushort self, ushort mask, UInt32 attributes);
    [ExtensionAttribute]
public static ushort SetMaskedAttributes(ushort self, ushort mask, UInt32 attributes, bool value);
    [ExtensionAttribute]
public static ParameterDefinition GetParameter(MethodBody self, int index);
    [ExtensionAttribute]
public static VariableDefinition GetVariable(MethodBody self, int index);
    [ExtensionAttribute]
public static bool GetSemantics(MethodDefinition self, MethodSemanticsAttributes semantics);
    [ExtensionAttribute]
public static void SetSemantics(MethodDefinition self, MethodSemanticsAttributes semantics, bool value);
    [ExtensionAttribute]
public static bool IsVarArg(IMethodSignature self);
    [ExtensionAttribute]
public static int GetSentinelPosition(IMethodSignature self);
    public static void CheckParameters(object parameters);
    [ExtensionAttribute]
public static bool HasImage(ModuleDefinition self);
    [ExtensionAttribute]
public static bool IsCorlib(ModuleDefinition module);
    [ExtensionAttribute]
public static string GetFullyQualifiedName(Stream self);
    [ExtensionAttribute]
public static TargetRuntime ParseRuntime(string self);
    [ExtensionAttribute]
public static string RuntimeVersionString(TargetRuntime runtime);
    [ExtensionAttribute]
public static TypeReference GetEnumUnderlyingType(TypeDefinition self);
    [ExtensionAttribute]
public static TypeDefinition GetNestedType(TypeDefinition self, string fullname);
    [ExtensionAttribute]
public static bool IsPrimitive(ElementType self);
    [ExtensionAttribute]
public static string TypeFullName(TypeReference self);
    [ExtensionAttribute]
public static bool IsTypeOf(TypeReference self, string namespace, string name);
    [ExtensionAttribute]
public static bool IsTypeSpecification(TypeReference type);
    [ExtensionAttribute]
public static TypeDefinition CheckedResolve(TypeReference self);
    public static void CheckType(TypeReference type);
    [ExtensionAttribute]
public static RSA CreateRSA(StrongNameKeyPair key_pair);
    private static bool TryGetKeyContainer(ISerializable key_pair, Byte[]& key, String& key_container);
    [ExtensionAttribute]
public static bool IsNullOrEmpty(T[] self);
    [ExtensionAttribute]
public static bool IsNullOrEmpty(Collection`1<T> self);
    [ExtensionAttribute]
public static T[] Resize(T[] self, int length);
}
[FlagsAttribute]
public enum Mono.Cecil.ModuleAttributes : Enum {
    public int value__;
    public static ModuleAttributes ILOnly;
    public static ModuleAttributes Required32Bit;
    public static ModuleAttributes StrongNameSigned;
    public static ModuleAttributes Preferred32Bit;
}
[FlagsAttribute]
public enum Mono.Cecil.ModuleCharacteristics : Enum {
    public int value__;
    public static ModuleCharacteristics HighEntropyVA;
    public static ModuleCharacteristics DynamicBase;
    public static ModuleCharacteristics NoSEH;
    public static ModuleCharacteristics NXCompat;
    public static ModuleCharacteristics AppContainer;
    public static ModuleCharacteristics TerminalServerAware;
}
public class Mono.Cecil.ModuleDefinition : ModuleReference {
    internal Image Image;
    internal MetadataSystem MetadataSystem;
    internal ReadingMode ReadingMode;
    internal ISymbolReaderProvider SymbolReaderProvider;
    internal ISymbolReader symbol_reader;
    internal IAssemblyResolver assembly_resolver;
    internal IMetadataResolver metadata_resolver;
    internal TypeSystem type_system;
    private MetadataReader reader;
    private string fq_name;
    internal string runtime_version;
    internal ModuleKind kind;
    private TargetRuntime runtime;
    private TargetArchitecture architecture;
    private ModuleAttributes attributes;
    private ModuleCharacteristics characteristics;
    private Guid mvid;
    internal AssemblyDefinition assembly;
    private MethodDefinition entry_point;
    private MetadataImporter importer;
    private Collection`1<CustomAttribute> custom_attributes;
    private Collection`1<AssemblyNameReference> references;
    private Collection`1<ModuleReference> modules;
    private Collection`1<Resource> resources;
    private Collection`1<ExportedType> exported_types;
    private TypeDefinitionCollection types;
    private object module_lock;
    public bool IsMain { get; }
    public ModuleKind Kind { get; public set; }
    public TargetRuntime Runtime { get; public set; }
    public string RuntimeVersion { get; public set; }
    public TargetArchitecture Architecture { get; public set; }
    public ModuleAttributes Attributes { get; public set; }
    public ModuleCharacteristics Characteristics { get; public set; }
    public string FullyQualifiedName { get; }
    public Guid Mvid { get; public set; }
    internal bool HasImage { get; }
    public bool HasSymbols { get; }
    public ISymbolReader SymbolReader { get; }
    public MetadataScopeType MetadataScopeType { get; }
    public AssemblyDefinition Assembly { get; }
    internal MetadataImporter MetadataImporter { get; }
    public IAssemblyResolver AssemblyResolver { get; }
    public IMetadataResolver MetadataResolver { get; }
    public TypeSystem TypeSystem { get; }
    public bool HasAssemblyReferences { get; }
    public Collection`1<AssemblyNameReference> AssemblyReferences { get; }
    public bool HasModuleReferences { get; }
    public Collection`1<ModuleReference> ModuleReferences { get; }
    public bool HasResources { get; }
    public Collection`1<Resource> Resources { get; }
    public bool HasCustomAttributes { get; }
    public Collection`1<CustomAttribute> CustomAttributes { get; }
    public bool HasTypes { get; }
    public Collection`1<TypeDefinition> Types { get; }
    public bool HasExportedTypes { get; }
    public Collection`1<ExportedType> ExportedTypes { get; }
    public MethodDefinition EntryPoint { get; public set; }
    internal object SyncRoot { get; }
    public bool HasDebugHeader { get; }
    internal ModuleDefinition(Image image);
    public bool get_IsMain();
    public ModuleKind get_Kind();
    public void set_Kind(ModuleKind value);
    public TargetRuntime get_Runtime();
    public void set_Runtime(TargetRuntime value);
    public string get_RuntimeVersion();
    public void set_RuntimeVersion(string value);
    public TargetArchitecture get_Architecture();
    public void set_Architecture(TargetArchitecture value);
    public ModuleAttributes get_Attributes();
    public void set_Attributes(ModuleAttributes value);
    public ModuleCharacteristics get_Characteristics();
    public void set_Characteristics(ModuleCharacteristics value);
    public string get_FullyQualifiedName();
    public Guid get_Mvid();
    public void set_Mvid(Guid value);
    internal bool get_HasImage();
    public bool get_HasSymbols();
    public ISymbolReader get_SymbolReader();
    public virtual MetadataScopeType get_MetadataScopeType();
    public AssemblyDefinition get_Assembly();
    internal MetadataImporter get_MetadataImporter();
    public IAssemblyResolver get_AssemblyResolver();
    public IMetadataResolver get_MetadataResolver();
    public TypeSystem get_TypeSystem();
    public bool get_HasAssemblyReferences();
    public Collection`1<AssemblyNameReference> get_AssemblyReferences();
    public bool get_HasModuleReferences();
    public Collection`1<ModuleReference> get_ModuleReferences();
    public bool get_HasResources();
    public Collection`1<Resource> get_Resources();
    public sealed virtual bool get_HasCustomAttributes();
    public sealed virtual Collection`1<CustomAttribute> get_CustomAttributes();
    public bool get_HasTypes();
    public Collection`1<TypeDefinition> get_Types();
    public bool get_HasExportedTypes();
    public Collection`1<ExportedType> get_ExportedTypes();
    public MethodDefinition get_EntryPoint();
    public void set_EntryPoint(MethodDefinition value);
    public bool HasTypeReference(string fullName);
    public bool HasTypeReference(string scope, string fullName);
    public bool TryGetTypeReference(string fullName, TypeReference& type);
    public bool TryGetTypeReference(string scope, string fullName, TypeReference& type);
    private TypeReference GetTypeReference(string scope, string fullname);
    public IEnumerable`1<TypeReference> GetTypeReferences();
    public IEnumerable`1<MemberReference> GetMemberReferences();
    public TypeReference GetType(string fullName, bool runtimeName);
    public TypeDefinition GetType(string fullName);
    public TypeDefinition GetType(string namespace, string name);
    public IEnumerable`1<TypeDefinition> GetTypes();
    private static IEnumerable`1<TypeDefinition> GetTypes(Collection`1<TypeDefinition> types);
    private static void CheckFullName(string fullName);
    private TypeDefinition GetNestedType(string fullname);
    internal FieldDefinition Resolve(FieldReference field);
    internal MethodDefinition Resolve(MethodReference method);
    internal TypeDefinition Resolve(TypeReference type);
    private static void CheckType(object type);
    private static void CheckField(object field);
    private static void CheckMethod(object method);
    private static void CheckContext(IGenericParameterProvider context, ModuleDefinition module);
    private static ImportGenericContext GenericContextFor(IGenericParameterProvider context);
    public TypeReference Import(Type type);
    public TypeReference Import(Type type, IGenericParameterProvider context);
    public FieldReference Import(FieldInfo field);
    public FieldReference Import(FieldInfo field, IGenericParameterProvider context);
    public MethodReference Import(MethodBase method);
    public MethodReference Import(MethodBase method, IGenericParameterProvider context);
    public TypeReference Import(TypeReference type);
    public TypeReference Import(TypeReference type, IGenericParameterProvider context);
    public FieldReference Import(FieldReference field);
    public FieldReference Import(FieldReference field, IGenericParameterProvider context);
    public MethodReference Import(MethodReference method);
    public MethodReference Import(MethodReference method, IGenericParameterProvider context);
    public IMetadataTokenProvider LookupToken(int token);
    public IMetadataTokenProvider LookupToken(MetadataToken token);
    internal object get_SyncRoot();
    internal TRet Read(TItem item, Func`3<TItem, MetadataReader, TRet> read);
    internal TRet Read(TRet& variable, TItem item, Func`3<TItem, MetadataReader, TRet> read);
    public bool get_HasDebugHeader();
    public ImageDebugDirectory GetDebugHeader(Byte[]& header);
    private void ProcessDebugHeader();
    public static ModuleDefinition CreateModule(string name, ModuleKind kind);
    public static ModuleDefinition CreateModule(string name, ModuleParameters parameters);
    private static AssemblyNameDefinition CreateAssemblyName(string name);
    public void ReadSymbols();
    public void ReadSymbols(ISymbolReader reader);
    public static ModuleDefinition ReadModule(string fileName);
    public static ModuleDefinition ReadModule(Stream stream);
    public static ModuleDefinition ReadModule(string fileName, ReaderParameters parameters);
    private static void CheckStream(object stream);
    public static ModuleDefinition ReadModule(Stream stream, ReaderParameters parameters);
    private static Stream GetFileStream(string fileName, FileMode mode, FileAccess access, FileShare share);
    public void Write(string fileName);
    public void Write(Stream stream);
    public void Write(string fileName, WriterParameters parameters);
    public void Write(Stream stream, WriterParameters parameters);
}
public enum Mono.Cecil.ModuleKind : Enum {
    public int value__;
    public static ModuleKind Dll;
    public static ModuleKind Console;
    public static ModuleKind Windows;
    public static ModuleKind NetModule;
}
public class Mono.Cecil.ModuleParameters : object {
    private ModuleKind kind;
    private TargetRuntime runtime;
    private TargetArchitecture architecture;
    private IAssemblyResolver assembly_resolver;
    private IMetadataResolver metadata_resolver;
    public ModuleKind Kind { get; public set; }
    public TargetRuntime Runtime { get; public set; }
    public TargetArchitecture Architecture { get; public set; }
    public IAssemblyResolver AssemblyResolver { get; public set; }
    public IMetadataResolver MetadataResolver { get; public set; }
    public ModuleKind get_Kind();
    public void set_Kind(ModuleKind value);
    public TargetRuntime get_Runtime();
    public void set_Runtime(TargetRuntime value);
    public TargetArchitecture get_Architecture();
    public void set_Architecture(TargetArchitecture value);
    public IAssemblyResolver get_AssemblyResolver();
    public void set_AssemblyResolver(IAssemblyResolver value);
    public IMetadataResolver get_MetadataResolver();
    public void set_MetadataResolver(IMetadataResolver value);
    private static TargetRuntime GetCurrentRuntime();
}
internal abstract class Mono.Cecil.ModuleReader : object {
    protected Image image;
    protected ModuleDefinition module;
    protected ModuleReader(Image image, ReadingMode mode);
    protected abstract virtual void ReadModule();
    protected void ReadModuleManifest(MetadataReader reader);
    private void ReadAssembly(MetadataReader reader);
    public static ModuleDefinition CreateModuleFrom(Image image, ReaderParameters parameters);
    private static void ReadSymbols(ModuleDefinition module, ReaderParameters parameters);
    private static ModuleReader CreateModuleReader(Image image, ReadingMode mode);
}
public class Mono.Cecil.ModuleReference : object {
    private string name;
    internal MetadataToken token;
    public string Name { get; public set; }
    public MetadataScopeType MetadataScopeType { get; }
    public MetadataToken MetadataToken { get; public set; }
    public ModuleReference(string name);
    public sealed virtual string get_Name();
    public sealed virtual void set_Name(string value);
    public virtual MetadataScopeType get_MetadataScopeType();
    public sealed virtual MetadataToken get_MetadataToken();
    public sealed virtual void set_MetadataToken(MetadataToken value);
    public virtual string ToString();
}
internal class Mono.Cecil.ModuleRefTable : MetadataTable`1<UInt32> {
    public virtual void Write(TableHeapBuffer buffer);
}
internal class Mono.Cecil.ModuleTable : OneRowTable`1<UInt32> {
    public virtual void Write(TableHeapBuffer buffer);
}
internal static class Mono.Cecil.ModuleWriter : object {
    public static void WriteModuleTo(ModuleDefinition module, Stream stream, WriterParameters parameters);
    private static void BuildMetadata(ModuleDefinition module, MetadataBuilder metadata);
    private static ISymbolWriter GetSymbolWriter(ModuleDefinition module, string fq_name, ISymbolWriterProvider symbol_writer_provider);
}
public enum Mono.Cecil.NativeType : Enum {
    public int value__;
    public static NativeType None;
    public static NativeType Boolean;
    public static NativeType I1;
    public static NativeType U1;
    public static NativeType I2;
    public static NativeType U2;
    public static NativeType I4;
    public static NativeType U4;
    public static NativeType I8;
    public static NativeType U8;
    public static NativeType R4;
    public static NativeType R8;
    public static NativeType LPStr;
    public static NativeType Int;
    public static NativeType UInt;
    public static NativeType Func;
    public static NativeType Array;
    public static NativeType Currency;
    public static NativeType BStr;
    public static NativeType LPWStr;
    public static NativeType LPTStr;
    public static NativeType FixedSysString;
    public static NativeType IUnknown;
    public static NativeType IDispatch;
    public static NativeType Struct;
    public static NativeType IntF;
    public static NativeType SafeArray;
    public static NativeType FixedArray;
    public static NativeType ByValStr;
    public static NativeType ANSIBStr;
    public static NativeType TBStr;
    public static NativeType VariantBool;
    public static NativeType ASAny;
    public static NativeType LPStruct;
    public static NativeType CustomMarshaler;
    public static NativeType Error;
    public static NativeType Max;
}
internal class Mono.Cecil.NestedClassTable : SortedTable`1<Row`2<UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
    public virtual int Compare(Row`2<UInt32, UInt32> x, Row`2<UInt32, UInt32> y);
}
internal abstract class Mono.Cecil.OneRowTable`1 : MetadataTable {
    internal TRow row;
    public int Length { get; }
    public sealed virtual int get_Length();
    public sealed virtual void Sort();
}
public class Mono.Cecil.OptionalModifierType : TypeSpecification {
    private TypeReference modifier_type;
    public TypeReference ModifierType { get; public set; }
    public string Name { get; }
    public string FullName { get; }
    private string Suffix { get; }
    public bool IsValueType { get; public set; }
    public bool IsOptionalModifier { get; }
    public bool ContainsGenericParameter { get; }
    public OptionalModifierType(TypeReference modifierType, TypeReference type);
    public sealed virtual TypeReference get_ModifierType();
    public void set_ModifierType(TypeReference value);
    public virtual string get_Name();
    public virtual string get_FullName();
    private string get_Suffix();
    public virtual bool get_IsValueType();
    public virtual void set_IsValueType(bool value);
    public virtual bool get_IsOptionalModifier();
    public virtual bool get_ContainsGenericParameter();
}
[FlagsAttribute]
public enum Mono.Cecil.ParameterAttributes : Enum {
    public ushort value__;
    public static ParameterAttributes None;
    public static ParameterAttributes In;
    public static ParameterAttributes Out;
    public static ParameterAttributes Lcid;
    public static ParameterAttributes Retval;
    public static ParameterAttributes Optional;
    public static ParameterAttributes HasDefault;
    public static ParameterAttributes HasFieldMarshal;
    public static ParameterAttributes Unused;
}
public class Mono.Cecil.ParameterDefinition : ParameterReference {
    private ushort attributes;
    internal IMethodSignature method;
    private object constant;
    private Collection`1<CustomAttribute> custom_attributes;
    private MarshalInfo marshal_info;
    public ParameterAttributes Attributes { get; public set; }
    public IMethodSignature Method { get; }
    public int Sequence { get; }
    public bool HasConstant { get; public set; }
    public object Constant { get; public set; }
    public bool HasCustomAttributes { get; }
    public Collection`1<CustomAttribute> CustomAttributes { get; }
    public bool HasMarshalInfo { get; }
    public MarshalInfo MarshalInfo { get; public set; }
    public bool IsIn { get; public set; }
    public bool IsOut { get; public set; }
    public bool IsLcid { get; public set; }
    public bool IsReturnValue { get; public set; }
    public bool IsOptional { get; public set; }
    public bool HasDefault { get; public set; }
    public bool HasFieldMarshal { get; public set; }
    internal ParameterDefinition(TypeReference parameterType, IMethodSignature method);
    public ParameterDefinition(TypeReference parameterType);
    public ParameterDefinition(string name, ParameterAttributes attributes, TypeReference parameterType);
    public ParameterAttributes get_Attributes();
    public void set_Attributes(ParameterAttributes value);
    public IMethodSignature get_Method();
    public int get_Sequence();
    public sealed virtual bool get_HasConstant();
    public sealed virtual void set_HasConstant(bool value);
    public sealed virtual object get_Constant();
    public sealed virtual void set_Constant(object value);
    public sealed virtual bool get_HasCustomAttributes();
    public sealed virtual Collection`1<CustomAttribute> get_CustomAttributes();
    public sealed virtual bool get_HasMarshalInfo();
    public sealed virtual MarshalInfo get_MarshalInfo();
    public sealed virtual void set_MarshalInfo(MarshalInfo value);
    public bool get_IsIn();
    public void set_IsIn(bool value);
    public bool get_IsOut();
    public void set_IsOut(bool value);
    public bool get_IsLcid();
    public void set_IsLcid(bool value);
    public bool get_IsReturnValue();
    public void set_IsReturnValue(bool value);
    public bool get_IsOptional();
    public void set_IsOptional(bool value);
    public bool get_HasDefault();
    public void set_HasDefault(bool value);
    public bool get_HasFieldMarshal();
    public void set_HasFieldMarshal(bool value);
    public virtual ParameterDefinition Resolve();
}
internal class Mono.Cecil.ParameterDefinitionCollection : Collection`1<ParameterDefinition> {
    private IMethodSignature method;
    internal ParameterDefinitionCollection(IMethodSignature method);
    internal ParameterDefinitionCollection(IMethodSignature method, int capacity);
    protected virtual void OnAdd(ParameterDefinition item, int index);
    protected virtual void OnInsert(ParameterDefinition item, int index);
    protected virtual void OnSet(ParameterDefinition item, int index);
    protected virtual void OnRemove(ParameterDefinition item, int index);
}
public abstract class Mono.Cecil.ParameterReference : object {
    private string name;
    internal int index;
    protected TypeReference parameter_type;
    internal MetadataToken token;
    public string Name { get; public set; }
    public int Index { get; }
    public TypeReference ParameterType { get; public set; }
    public MetadataToken MetadataToken { get; public set; }
    internal ParameterReference(string name, TypeReference parameterType);
    public string get_Name();
    public void set_Name(string value);
    public int get_Index();
    public TypeReference get_ParameterType();
    public void set_ParameterType(TypeReference value);
    public sealed virtual MetadataToken get_MetadataToken();
    public sealed virtual void set_MetadataToken(MetadataToken value);
    public virtual string ToString();
    public abstract virtual ParameterDefinition Resolve();
}
internal class Mono.Cecil.ParamTable : MetadataTable`1<Row`3<ParameterAttributes, ushort, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
}
internal class Mono.Cecil.PE.BinaryStreamReader : BinaryReader {
    public BinaryStreamReader(Stream stream);
    protected void Advance(int bytes);
    protected DataDirectory ReadDataDirectory();
}
internal class Mono.Cecil.PE.BinaryStreamWriter : BinaryWriter {
    public BinaryStreamWriter(Stream stream);
    public void WriteByte(byte value);
    public void WriteUInt16(ushort value);
    public void WriteInt16(short value);
    public void WriteUInt32(UInt32 value);
    public void WriteInt32(int value);
    public void WriteUInt64(ulong value);
    public void WriteBytes(Byte[] bytes);
    public void WriteDataDirectory(DataDirectory directory);
    public void WriteBuffer(ByteBuffer buffer);
    protected void Advance(int bytes);
}
internal class Mono.Cecil.PE.ByteBuffer : object {
    internal Byte[] buffer;
    internal int length;
    internal int position;
    public ByteBuffer(int length);
    public ByteBuffer(Byte[] buffer);
    public void Reset(Byte[] buffer);
    public void Advance(int length);
    public byte ReadByte();
    public sbyte ReadSByte();
    public Byte[] ReadBytes(int length);
    public ushort ReadUInt16();
    public short ReadInt16();
    public UInt32 ReadUInt32();
    public int ReadInt32();
    public ulong ReadUInt64();
    public long ReadInt64();
    public UInt32 ReadCompressedUInt32();
    public int ReadCompressedInt32();
    public float ReadSingle();
    public double ReadDouble();
    public void WriteByte(byte value);
    public void WriteSByte(sbyte value);
    public void WriteUInt16(ushort value);
    public void WriteInt16(short value);
    public void WriteUInt32(UInt32 value);
    public void WriteInt32(int value);
    public void WriteUInt64(ulong value);
    public void WriteInt64(long value);
    public void WriteCompressedUInt32(UInt32 value);
    public void WriteCompressedInt32(int value);
    public void WriteBytes(Byte[] bytes);
    public void WriteBytes(int length);
    public void WriteBytes(ByteBuffer buffer);
    public void WriteSingle(float value);
    public void WriteDouble(double value);
    private void Grow(int desired);
}
internal class Mono.Cecil.PE.ByteBufferEqualityComparer : object {
    public sealed virtual bool Equals(ByteBuffer x, ByteBuffer y);
    public sealed virtual int GetHashCode(ByteBuffer buffer);
}
internal class Mono.Cecil.PE.DataDirectory : ValueType {
    public UInt32 VirtualAddress;
    public UInt32 Size;
    public bool IsZero { get; }
    public DataDirectory(UInt32 rva, UInt32 size);
    public bool get_IsZero();
}
internal class Mono.Cecil.PE.Image : object {
    public ModuleKind Kind;
    public string RuntimeVersion;
    public TargetArchitecture Architecture;
    public ModuleCharacteristics Characteristics;
    public string FileName;
    public Section[] Sections;
    public Section MetadataSection;
    public UInt32 EntryPointToken;
    public ModuleAttributes Attributes;
    public DataDirectory Debug;
    public DataDirectory Resources;
    public DataDirectory StrongName;
    public StringHeap StringHeap;
    public BlobHeap BlobHeap;
    public UserStringHeap UserStringHeap;
    public GuidHeap GuidHeap;
    public TableHeap TableHeap;
    private Int32[] coded_index_sizes;
    private Func`2<Table, int> counter;
    public bool HasTable(Table table);
    public int GetTableLength(Table table);
    public int GetTableIndexSize(Table table);
    public int GetCodedIndexSize(CodedIndex coded_index);
    public UInt32 ResolveVirtualAddress(UInt32 rva);
    public UInt32 ResolveVirtualAddressInSection(UInt32 rva, Section section);
    public Section GetSection(string name);
    public Section GetSectionAtVirtualAddress(UInt32 rva);
    public ImageDebugDirectory GetDebugHeader(Byte[]& header);
}
internal class Mono.Cecil.PE.ImageReader : BinaryStreamReader {
    private Image image;
    private DataDirectory cli;
    private DataDirectory metadata;
    public ImageReader(Stream stream);
    private void MoveTo(DataDirectory directory);
    private void MoveTo(UInt32 position);
    private void ReadImage();
    private TargetArchitecture ReadArchitecture();
    private static ModuleKind GetModuleKind(ushort characteristics, ushort subsystem);
    private void ReadOptionalHeaders(UInt16& subsystem, UInt16& dll_characteristics);
    private string ReadAlignedString(int length);
    private string ReadZeroTerminatedString(int length);
    private void ReadSections(ushort count);
    private void ReadSectionData(Section section);
    private void ReadCLIHeader();
    private void ReadMetadata();
    private void ReadMetadataStream(Section section);
    private void ReadTableHeap();
    private static void SetIndexSize(Heap heap, UInt32 sizes, byte flag);
    private int GetTableIndexSize(Table table);
    private int GetCodedIndexSize(CodedIndex index);
    private void ComputeTableInformations();
    public static Image ReadImageFrom(Stream stream);
}
internal class Mono.Cecil.PE.ImageWriter : BinaryStreamWriter {
    private ModuleDefinition module;
    private MetadataBuilder metadata;
    private TextMap text_map;
    private ImageDebugDirectory debug_directory;
    private Byte[] debug_data;
    private ByteBuffer win32_resources;
    private static UInt32 pe_header_size;
    private static UInt32 section_header_size;
    private static UInt32 file_alignment;
    private static UInt32 section_alignment;
    private static ulong image_base;
    internal static UInt32 text_rva;
    private bool pe64;
    private bool has_reloc;
    private UInt32 time_stamp;
    internal Section text;
    internal Section rsrc;
    internal Section reloc;
    private ushort sections;
    private ImageWriter(ModuleDefinition module, MetadataBuilder metadata, Stream stream);
    private void GetDebugHeader();
    private void GetWin32Resources();
    private Section GetImageResourceSection();
    public static ImageWriter CreateWriter(ModuleDefinition module, MetadataBuilder metadata, Stream stream);
    private void BuildSections();
    private Section CreateSection(string name, UInt32 size, Section previous);
    private static UInt32 Align(UInt32 value, UInt32 align);
    private void WriteDOSHeader();
    private ushort SizeOfOptionalHeader();
    private void WritePEFileHeader();
    private ushort GetMachine();
    private Section LastSection();
    private void WriteOptionalHeaders();
    private void WriteZeroDataDirectory();
    private ushort GetSubSystem();
    private void WriteSectionHeaders();
    private void WriteSection(Section section, UInt32 characteristics);
    private void MoveTo(UInt32 pointer);
    private void MoveToRVA(Section section, UInt32 rva);
    private void MoveToRVA(TextSegment segment);
    private void WriteRVA(UInt32 rva);
    private void PrepareSection(Section section);
    private void WriteText();
    private UInt32 GetMetadataLength();
    private void WriteMetadataHeader();
    private ushort GetStreamCount();
    private void WriteStreamHeader(UInt32& offset, TextSegment heap, string name);
    private static Byte[] GetZeroTerminatedString(string string);
    private static Byte[] GetSimpleString(string string);
    private static Byte[] GetString(string string, int length);
    private void WriteMetadata();
    private void WriteHeap(TextSegment heap, HeapBuffer buffer);
    private void WriteGuidHeap();
    private void WriteDebugDirectory();
    private void WriteImportDirectory();
    private Byte[] GetRuntimeMain();
    private void WriteStartupStub();
    private void WriteRsrc();
    private void WriteReloc();
    public void WriteImage();
    private TextMap BuildTextMap();
    private UInt32 GetStartupStubLength();
    private int GetMetadataHeaderLength();
    private int GetStrongNameLength();
    public DataDirectory GetStrongNameSignatureDirectory();
    public UInt32 GetHeaderSize();
    private void PatchWin32Resources(ByteBuffer resources);
    private void PatchResourceDirectoryTable(ByteBuffer resources);
    private void PatchResourceDirectoryEntry(ByteBuffer resources);
    private void PatchResourceDataEntry(ByteBuffer resources);
}
internal class Mono.Cecil.PE.Section : object {
    public string Name;
    public UInt32 VirtualAddress;
    public UInt32 VirtualSize;
    public UInt32 SizeOfRawData;
    public UInt32 PointerToRawData;
    public Byte[] Data;
}
internal class Mono.Cecil.PE.TextMap : object {
    private Range[] map;
    public void AddMap(TextSegment segment, int length);
    public void AddMap(TextSegment segment, int length, int align);
    public void AddMap(TextSegment segment, Range range);
    public Range GetRange(TextSegment segment);
    public DataDirectory GetDataDirectory(TextSegment segment);
    public UInt32 GetRVA(TextSegment segment);
    public UInt32 GetNextRVA(TextSegment segment);
    public int GetLength(TextSegment segment);
    private UInt32 GetStart(TextSegment segment);
    private UInt32 ComputeStart(int index);
    public UInt32 GetLength();
}
internal enum Mono.Cecil.PE.TextSegment : Enum {
    public int value__;
    public static TextSegment ImportAddressTable;
    public static TextSegment CLIHeader;
    public static TextSegment Code;
    public static TextSegment Resources;
    public static TextSegment Data;
    public static TextSegment StrongNameSignature;
    public static TextSegment MetadataHeader;
    public static TextSegment TableHeap;
    public static TextSegment StringHeap;
    public static TextSegment UserStringHeap;
    public static TextSegment GuidHeap;
    public static TextSegment BlobHeap;
    public static TextSegment DebugDirectory;
    public static TextSegment ImportDirectory;
    public static TextSegment ImportHintNameTable;
    public static TextSegment StartupStub;
}
public class Mono.Cecil.PinnedType : TypeSpecification {
    public bool IsValueType { get; public set; }
    public bool IsPinned { get; }
    public PinnedType(TypeReference type);
    public virtual bool get_IsValueType();
    public virtual void set_IsValueType(bool value);
    public virtual bool get_IsPinned();
}
[FlagsAttribute]
public enum Mono.Cecil.PInvokeAttributes : Enum {
    public ushort value__;
    public static PInvokeAttributes NoMangle;
    public static PInvokeAttributes CharSetMask;
    public static PInvokeAttributes CharSetNotSpec;
    public static PInvokeAttributes CharSetAnsi;
    public static PInvokeAttributes CharSetUnicode;
    public static PInvokeAttributes CharSetAuto;
    public static PInvokeAttributes SupportsLastError;
    public static PInvokeAttributes CallConvMask;
    public static PInvokeAttributes CallConvWinapi;
    public static PInvokeAttributes CallConvCdecl;
    public static PInvokeAttributes CallConvStdCall;
    public static PInvokeAttributes CallConvThiscall;
    public static PInvokeAttributes CallConvFastcall;
    public static PInvokeAttributes BestFitMask;
    public static PInvokeAttributes BestFitEnabled;
    public static PInvokeAttributes BestFitDisabled;
    public static PInvokeAttributes ThrowOnUnmappableCharMask;
    public static PInvokeAttributes ThrowOnUnmappableCharEnabled;
    public static PInvokeAttributes ThrowOnUnmappableCharDisabled;
}
public class Mono.Cecil.PInvokeInfo : object {
    private ushort attributes;
    private string entry_point;
    private ModuleReference module;
    public PInvokeAttributes Attributes { get; public set; }
    public string EntryPoint { get; public set; }
    public ModuleReference Module { get; public set; }
    public bool IsNoMangle { get; public set; }
    public bool IsCharSetNotSpec { get; public set; }
    public bool IsCharSetAnsi { get; public set; }
    public bool IsCharSetUnicode { get; public set; }
    public bool IsCharSetAuto { get; public set; }
    public bool SupportsLastError { get; public set; }
    public bool IsCallConvWinapi { get; public set; }
    public bool IsCallConvCdecl { get; public set; }
    public bool IsCallConvStdCall { get; public set; }
    public bool IsCallConvThiscall { get; public set; }
    public bool IsCallConvFastcall { get; public set; }
    public bool IsBestFitEnabled { get; public set; }
    public bool IsBestFitDisabled { get; public set; }
    public bool IsThrowOnUnmappableCharEnabled { get; public set; }
    public bool IsThrowOnUnmappableCharDisabled { get; public set; }
    public PInvokeInfo(PInvokeAttributes attributes, string entryPoint, ModuleReference module);
    public PInvokeAttributes get_Attributes();
    public void set_Attributes(PInvokeAttributes value);
    public string get_EntryPoint();
    public void set_EntryPoint(string value);
    public ModuleReference get_Module();
    public void set_Module(ModuleReference value);
    public bool get_IsNoMangle();
    public void set_IsNoMangle(bool value);
    public bool get_IsCharSetNotSpec();
    public void set_IsCharSetNotSpec(bool value);
    public bool get_IsCharSetAnsi();
    public void set_IsCharSetAnsi(bool value);
    public bool get_IsCharSetUnicode();
    public void set_IsCharSetUnicode(bool value);
    public bool get_IsCharSetAuto();
    public void set_IsCharSetAuto(bool value);
    public bool get_SupportsLastError();
    public void set_SupportsLastError(bool value);
    public bool get_IsCallConvWinapi();
    public void set_IsCallConvWinapi(bool value);
    public bool get_IsCallConvCdecl();
    public void set_IsCallConvCdecl(bool value);
    public bool get_IsCallConvStdCall();
    public void set_IsCallConvStdCall(bool value);
    public bool get_IsCallConvThiscall();
    public void set_IsCallConvThiscall(bool value);
    public bool get_IsCallConvFastcall();
    public void set_IsCallConvFastcall(bool value);
    public bool get_IsBestFitEnabled();
    public void set_IsBestFitEnabled(bool value);
    public bool get_IsBestFitDisabled();
    public void set_IsBestFitDisabled(bool value);
    public bool get_IsThrowOnUnmappableCharEnabled();
    public void set_IsThrowOnUnmappableCharEnabled(bool value);
    public bool get_IsThrowOnUnmappableCharDisabled();
    public void set_IsThrowOnUnmappableCharDisabled(bool value);
}
public class Mono.Cecil.PointerType : TypeSpecification {
    public string Name { get; }
    public string FullName { get; }
    public bool IsValueType { get; public set; }
    public bool IsPointer { get; }
    public PointerType(TypeReference type);
    public virtual string get_Name();
    public virtual string get_FullName();
    public virtual bool get_IsValueType();
    public virtual void set_IsValueType(bool value);
    public virtual bool get_IsPointer();
}
[FlagsAttribute]
public enum Mono.Cecil.PropertyAttributes : Enum {
    public ushort value__;
    public static PropertyAttributes None;
    public static PropertyAttributes SpecialName;
    public static PropertyAttributes RTSpecialName;
    public static PropertyAttributes HasDefault;
    public static PropertyAttributes Unused;
}
public class Mono.Cecil.PropertyDefinition : PropertyReference {
    private Nullable`1<bool> has_this;
    private ushort attributes;
    private Collection`1<CustomAttribute> custom_attributes;
    internal MethodDefinition get_method;
    internal MethodDefinition set_method;
    internal Collection`1<MethodDefinition> other_methods;
    private object constant;
    public PropertyAttributes Attributes { get; public set; }
    public bool HasThis { get; public set; }
    public bool HasCustomAttributes { get; }
    public Collection`1<CustomAttribute> CustomAttributes { get; }
    public MethodDefinition GetMethod { get; public set; }
    public MethodDefinition SetMethod { get; public set; }
    public bool HasOtherMethods { get; }
    public Collection`1<MethodDefinition> OtherMethods { get; }
    public bool HasParameters { get; }
    public Collection`1<ParameterDefinition> Parameters { get; }
    public bool HasConstant { get; public set; }
    public object Constant { get; public set; }
    public bool IsSpecialName { get; public set; }
    public bool IsRuntimeSpecialName { get; public set; }
    public bool HasDefault { get; public set; }
    public TypeDefinition DeclaringType { get; public set; }
    public bool IsDefinition { get; }
    public string FullName { get; }
    public PropertyDefinition(string name, PropertyAttributes attributes, TypeReference propertyType);
    public PropertyAttributes get_Attributes();
    public void set_Attributes(PropertyAttributes value);
    public bool get_HasThis();
    public void set_HasThis(bool value);
    public sealed virtual bool get_HasCustomAttributes();
    public sealed virtual Collection`1<CustomAttribute> get_CustomAttributes();
    public MethodDefinition get_GetMethod();
    public void set_GetMethod(MethodDefinition value);
    public MethodDefinition get_SetMethod();
    public void set_SetMethod(MethodDefinition value);
    public bool get_HasOtherMethods();
    public Collection`1<MethodDefinition> get_OtherMethods();
    public bool get_HasParameters();
    public virtual Collection`1<ParameterDefinition> get_Parameters();
    private static Collection`1<ParameterDefinition> MirrorParameters(MethodDefinition method, int bound);
    public sealed virtual bool get_HasConstant();
    public sealed virtual void set_HasConstant(bool value);
    public sealed virtual object get_Constant();
    public sealed virtual void set_Constant(object value);
    public sealed virtual bool get_IsSpecialName();
    public sealed virtual void set_IsSpecialName(bool value);
    public sealed virtual bool get_IsRuntimeSpecialName();
    public sealed virtual void set_IsRuntimeSpecialName(bool value);
    public bool get_HasDefault();
    public void set_HasDefault(bool value);
    public sealed virtual TypeDefinition get_DeclaringType();
    public sealed virtual void set_DeclaringType(TypeDefinition value);
    public virtual bool get_IsDefinition();
    public virtual string get_FullName();
    private void InitializeMethods();
    public virtual PropertyDefinition Resolve();
}
internal class Mono.Cecil.PropertyMapTable : MetadataTable`1<Row`2<UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
}
public abstract class Mono.Cecil.PropertyReference : MemberReference {
    private TypeReference property_type;
    public TypeReference PropertyType { get; public set; }
    public Collection`1<ParameterDefinition> Parameters { get; }
    internal PropertyReference(string name, TypeReference propertyType);
    public TypeReference get_PropertyType();
    public void set_PropertyType(TypeReference value);
    public abstract virtual Collection`1<ParameterDefinition> get_Parameters();
    public abstract virtual PropertyDefinition Resolve();
}
internal class Mono.Cecil.PropertyTable : MetadataTable`1<Row`3<PropertyAttributes, UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
}
internal class Mono.Cecil.Range : ValueType {
    public UInt32 Start;
    public UInt32 Length;
    public Range(UInt32 index, UInt32 length);
}
public class Mono.Cecil.ReaderParameters : object {
    private ReadingMode reading_mode;
    private IAssemblyResolver assembly_resolver;
    private IMetadataResolver metadata_resolver;
    private Stream symbol_stream;
    private ISymbolReaderProvider symbol_reader_provider;
    private bool read_symbols;
    public ReadingMode ReadingMode { get; public set; }
    public IAssemblyResolver AssemblyResolver { get; public set; }
    public IMetadataResolver MetadataResolver { get; public set; }
    public Stream SymbolStream { get; public set; }
    public ISymbolReaderProvider SymbolReaderProvider { get; public set; }
    public bool ReadSymbols { get; public set; }
    public ReaderParameters(ReadingMode readingMode);
    public ReadingMode get_ReadingMode();
    public void set_ReadingMode(ReadingMode value);
    public IAssemblyResolver get_AssemblyResolver();
    public void set_AssemblyResolver(IAssemblyResolver value);
    public IMetadataResolver get_MetadataResolver();
    public void set_MetadataResolver(IMetadataResolver value);
    public Stream get_SymbolStream();
    public void set_SymbolStream(Stream value);
    public ISymbolReaderProvider get_SymbolReaderProvider();
    public void set_SymbolReaderProvider(ISymbolReaderProvider value);
    public bool get_ReadSymbols();
    public void set_ReadSymbols(bool value);
}
public enum Mono.Cecil.ReadingMode : Enum {
    public int value__;
    public static ReadingMode Immediate;
    public static ReadingMode Deferred;
}
public class Mono.Cecil.RequiredModifierType : TypeSpecification {
    private TypeReference modifier_type;
    public TypeReference ModifierType { get; public set; }
    public string Name { get; }
    public string FullName { get; }
    private string Suffix { get; }
    public bool IsValueType { get; public set; }
    public bool IsRequiredModifier { get; }
    public bool ContainsGenericParameter { get; }
    public RequiredModifierType(TypeReference modifierType, TypeReference type);
    public sealed virtual TypeReference get_ModifierType();
    public void set_ModifierType(TypeReference value);
    public virtual string get_Name();
    public virtual string get_FullName();
    private string get_Suffix();
    public virtual bool get_IsValueType();
    public virtual void set_IsValueType(bool value);
    public virtual bool get_IsRequiredModifier();
    public virtual bool get_ContainsGenericParameter();
}
public class Mono.Cecil.ResolutionException : Exception {
    private MemberReference member;
    public MemberReference Member { get; }
    public IMetadataScope Scope { get; }
    public ResolutionException(MemberReference member);
    protected ResolutionException(SerializationInfo info, StreamingContext context);
    public MemberReference get_Member();
    public IMetadataScope get_Scope();
}
public abstract class Mono.Cecil.Resource : object {
    private string name;
    private UInt32 attributes;
    public string Name { get; public set; }
    public ManifestResourceAttributes Attributes { get; public set; }
    public ResourceType ResourceType { get; }
    public bool IsPublic { get; public set; }
    public bool IsPrivate { get; public set; }
    internal Resource(string name, ManifestResourceAttributes attributes);
    public string get_Name();
    public void set_Name(string value);
    public ManifestResourceAttributes get_Attributes();
    public void set_Attributes(ManifestResourceAttributes value);
    public abstract virtual ResourceType get_ResourceType();
    public bool get_IsPublic();
    public void set_IsPublic(bool value);
    public bool get_IsPrivate();
    public void set_IsPrivate(bool value);
}
public enum Mono.Cecil.ResourceType : Enum {
    public int value__;
    public static ResourceType Linked;
    public static ResourceType Embedded;
    public static ResourceType AssemblyLinked;
}
[ExtensionAttribute]
internal static class Mono.Cecil.Rocks.Functional : object {
    public static Func`2<A, R> Y(Func`2<Func`2<A, R>, Func`2<A, R>> f);
    [ExtensionAttribute]
public static IEnumerable`1<TSource> Prepend(IEnumerable`1<TSource> source, TSource element);
    private static IEnumerable`1<TSource> PrependIterator(IEnumerable`1<TSource> source, TSource element);
}
public interface Mono.Cecil.Rocks.IILVisitor {
    public abstract virtual void OnInlineNone(OpCode opcode);
    public abstract virtual void OnInlineSByte(OpCode opcode, sbyte value);
    public abstract virtual void OnInlineByte(OpCode opcode, byte value);
    public abstract virtual void OnInlineInt32(OpCode opcode, int value);
    public abstract virtual void OnInlineInt64(OpCode opcode, long value);
    public abstract virtual void OnInlineSingle(OpCode opcode, float value);
    public abstract virtual void OnInlineDouble(OpCode opcode, double value);
    public abstract virtual void OnInlineString(OpCode opcode, string value);
    public abstract virtual void OnInlineBranch(OpCode opcode, int offset);
    public abstract virtual void OnInlineSwitch(OpCode opcode, Int32[] offsets);
    public abstract virtual void OnInlineVariable(OpCode opcode, VariableDefinition variable);
    public abstract virtual void OnInlineArgument(OpCode opcode, ParameterDefinition parameter);
    public abstract virtual void OnInlineSignature(OpCode opcode, CallSite callSite);
    public abstract virtual void OnInlineType(OpCode opcode, TypeReference type);
    public abstract virtual void OnInlineField(OpCode opcode, FieldReference field);
    public abstract virtual void OnInlineMethod(OpCode opcode, MethodReference method);
}
public static class Mono.Cecil.Rocks.ILParser : object {
    public static void Parse(MethodDefinition method, IILVisitor visitor);
    private static ParseContext CreateContext(MethodDefinition method, IILVisitor visitor);
    private static void ParseFatMethod(ParseContext context);
    private static void ParseCode(int code_size, ParseContext context);
    private static VariableDefinition GetVariable(ParseContext context, int index);
}
[ExtensionAttribute]
public static class Mono.Cecil.Rocks.MethodBodyRocks : object {
    [ExtensionAttribute]
public static void SimplifyMacros(MethodBody self);
    private static void ExpandMacro(Instruction instruction, OpCode opcode, object operand);
    private static void MakeMacro(Instruction instruction, OpCode opcode);
    [ExtensionAttribute]
public static void OptimizeMacros(MethodBody self);
    private static void OptimizeBranches(MethodBody body);
    private static bool OptimizeBranch(Instruction instruction);
    private static void ComputeOffsets(MethodBody body);
}
[ExtensionAttribute]
public static class Mono.Cecil.Rocks.MethodDefinitionRocks : object {
    [ExtensionAttribute]
public static MethodDefinition GetBaseMethod(MethodDefinition self);
    [ExtensionAttribute]
public static MethodDefinition GetOriginalBaseMethod(MethodDefinition self);
    private static TypeDefinition ResolveBaseType(TypeDefinition type);
    private static MethodDefinition GetMatchingMethod(TypeDefinition type, MethodDefinition method);
}
[ExtensionAttribute]
public static class Mono.Cecil.Rocks.ModuleDefinitionRocks : object {
    [ExtensionAttribute]
public static IEnumerable`1<TypeDefinition> GetAllTypes(ModuleDefinition self);
}
[ExtensionAttribute]
public static class Mono.Cecil.Rocks.SecurityDeclarationRocks : object {
    [ExtensionAttribute]
public static PermissionSet ToPermissionSet(SecurityDeclaration self);
    private static bool TryProcessPermissionSetAttribute(SecurityDeclaration declaration, PermissionSet& set);
    private static PermissionSet CreatePermissionSet(SecurityDeclaration declaration);
    private static IPermission CreatePermission(SecurityDeclaration declaration, SecurityAttribute attribute);
    private static void CompleteSecurityAttribute(SecurityAttribute security_attribute, SecurityAttribute attribute);
    private static void CompleteSecurityAttributeFields(SecurityAttribute security_attribute, SecurityAttribute attribute);
    private static void CompleteSecurityAttributeProperties(SecurityAttribute security_attribute, SecurityAttribute attribute);
    private static SecurityAttribute CreateSecurityAttribute(Type attribute_type, SecurityDeclaration declaration);
    [ExtensionAttribute]
public static SecurityDeclaration ToSecurityDeclaration(PermissionSet self, SecurityAction action, ModuleDefinition module);
}
[ExtensionAttribute]
public static class Mono.Cecil.Rocks.TypeDefinitionRocks : object {
    [ExtensionAttribute]
public static IEnumerable`1<MethodDefinition> GetConstructors(TypeDefinition self);
    [ExtensionAttribute]
public static MethodDefinition GetStaticConstructor(TypeDefinition self);
    [ExtensionAttribute]
public static IEnumerable`1<MethodDefinition> GetMethods(TypeDefinition self);
    [ExtensionAttribute]
public static TypeReference GetEnumUnderlyingType(TypeDefinition self);
}
[ExtensionAttribute]
public static class Mono.Cecil.Rocks.TypeReferenceRocks : object {
    [ExtensionAttribute]
public static ArrayType MakeArrayType(TypeReference self);
    [ExtensionAttribute]
public static ArrayType MakeArrayType(TypeReference self, int rank);
    [ExtensionAttribute]
public static PointerType MakePointerType(TypeReference self);
    [ExtensionAttribute]
public static ByReferenceType MakeByReferenceType(TypeReference self);
    [ExtensionAttribute]
public static OptionalModifierType MakeOptionalModifierType(TypeReference self, TypeReference modifierType);
    [ExtensionAttribute]
public static RequiredModifierType MakeRequiredModifierType(TypeReference self, TypeReference modifierType);
    [ExtensionAttribute]
public static GenericInstanceType MakeGenericInstanceType(TypeReference self, TypeReference[] arguments);
    [ExtensionAttribute]
public static PinnedType MakePinnedType(TypeReference self);
    [ExtensionAttribute]
public static SentinelType MakeSentinelType(TypeReference self);
}
public class Mono.Cecil.SafeArrayMarshalInfo : MarshalInfo {
    internal VariantType element_type;
    public VariantType ElementType { get; public set; }
    public VariantType get_ElementType();
    public void set_ElementType(VariantType value);
}
public enum Mono.Cecil.SecurityAction : Enum {
    public ushort value__;
    public static SecurityAction Request;
    public static SecurityAction Demand;
    public static SecurityAction Assert;
    public static SecurityAction Deny;
    public static SecurityAction PermitOnly;
    public static SecurityAction LinkDemand;
    public static SecurityAction InheritDemand;
    public static SecurityAction RequestMinimum;
    public static SecurityAction RequestOptional;
    public static SecurityAction RequestRefuse;
    public static SecurityAction PreJitGrant;
    public static SecurityAction PreJitDeny;
    public static SecurityAction NonCasDemand;
    public static SecurityAction NonCasLinkDemand;
    public static SecurityAction NonCasInheritance;
}
public class Mono.Cecil.SecurityAttribute : object {
    private TypeReference attribute_type;
    internal Collection`1<CustomAttributeNamedArgument> fields;
    internal Collection`1<CustomAttributeNamedArgument> properties;
    public TypeReference AttributeType { get; public set; }
    public bool HasFields { get; }
    public Collection`1<CustomAttributeNamedArgument> Fields { get; }
    public bool HasProperties { get; }
    public Collection`1<CustomAttributeNamedArgument> Properties { get; }
    public SecurityAttribute(TypeReference attributeType);
    public sealed virtual TypeReference get_AttributeType();
    public void set_AttributeType(TypeReference value);
    public sealed virtual bool get_HasFields();
    public sealed virtual Collection`1<CustomAttributeNamedArgument> get_Fields();
    public sealed virtual bool get_HasProperties();
    public sealed virtual Collection`1<CustomAttributeNamedArgument> get_Properties();
}
public class Mono.Cecil.SecurityDeclaration : object {
    internal UInt32 signature;
    private Byte[] blob;
    private ModuleDefinition module;
    internal bool resolved;
    private SecurityAction action;
    internal Collection`1<SecurityAttribute> security_attributes;
    public SecurityAction Action { get; public set; }
    public bool HasSecurityAttributes { get; }
    public Collection`1<SecurityAttribute> SecurityAttributes { get; }
    internal bool HasImage { get; }
    internal SecurityDeclaration(SecurityAction action, UInt32 signature, ModuleDefinition module);
    public SecurityDeclaration(SecurityAction action);
    public SecurityDeclaration(SecurityAction action, Byte[] blob);
    public SecurityAction get_Action();
    public void set_Action(SecurityAction value);
    public bool get_HasSecurityAttributes();
    public Collection`1<SecurityAttribute> get_SecurityAttributes();
    internal bool get_HasImage();
    public Byte[] GetBlob();
    private void Resolve();
    [CompilerGeneratedAttribute]
private SecurityDeclaration <Resolve>b__19_0(SecurityDeclaration declaration, MetadataReader reader);
}
public class Mono.Cecil.SentinelType : TypeSpecification {
    public bool IsValueType { get; public set; }
    public bool IsSentinel { get; }
    public SentinelType(TypeReference type);
    public virtual bool get_IsValueType();
    public virtual void set_IsValueType(bool value);
    public virtual bool get_IsSentinel();
}
internal class Mono.Cecil.SignatureReader : ByteBuffer {
    private MetadataReader reader;
    private UInt32 start;
    private UInt32 sig_length;
    private TypeSystem TypeSystem { get; }
    public SignatureReader(UInt32 blob, MetadataReader reader);
    private TypeSystem get_TypeSystem();
    private void MoveToBlob(UInt32 blob);
    private MetadataToken ReadTypeTokenSignature();
    private GenericParameter GetGenericParameter(GenericParameterType type, UInt32 var);
    private GenericParameter GetUnboundGenericParameter(GenericParameterType type, int index);
    private static void CheckGenericContext(IGenericParameterProvider owner, int index);
    public void ReadGenericInstanceSignature(IGenericParameterProvider provider, IGenericInstance instance);
    private ArrayType ReadArrayTypeSignature();
    private TypeReference GetTypeDefOrRef(MetadataToken token);
    public TypeReference ReadTypeSignature();
    private TypeReference ReadTypeSignature(ElementType etype);
    public void ReadMethodSignature(IMethodSignature method);
    public object ReadConstantSignature(ElementType type);
    public void ReadCustomAttributeConstructorArguments(CustomAttribute attribute, Collection`1<ParameterDefinition> parameters);
    private CustomAttributeArgument ReadCustomAttributeFixedArgument(TypeReference type);
    public void ReadCustomAttributeNamedArguments(ushort count, Collection`1& fields, Collection`1& properties);
    private void ReadCustomAttributeNamedArgument(Collection`1& fields, Collection`1& properties);
    private static Collection`1<CustomAttributeNamedArgument> GetCustomAttributeNamedArgumentCollection(Collection`1& collection);
    private CustomAttributeArgument ReadCustomAttributeFixedArrayArgument(ArrayType type);
    private CustomAttributeArgument ReadCustomAttributeElement(TypeReference type);
    private object ReadCustomAttributeElementValue(TypeReference type);
    private object ReadPrimitiveValue(ElementType type);
    private TypeReference GetPrimitiveType(ElementType etype);
    private TypeReference ReadCustomAttributeFieldOrPropType();
    public TypeReference ReadTypeReference();
    private object ReadCustomAttributeEnum(TypeReference enum_type);
    public SecurityAttribute ReadSecurityAttribute();
    public MarshalInfo ReadMarshalInfo();
    private NativeType ReadNativeType();
    private VariantType ReadVariantType();
    private string ReadUTF8String();
    public bool CanReadMore();
}
internal class Mono.Cecil.SignatureWriter : ByteBuffer {
    private MetadataBuilder metadata;
    public SignatureWriter(MetadataBuilder metadata);
    public void WriteElementType(ElementType element_type);
    public void WriteUTF8String(string string);
    public void WriteMethodSignature(IMethodSignature method);
    private UInt32 MakeTypeDefOrRefCodedRID(TypeReference type);
    public void WriteTypeSignature(TypeReference type);
    private void WriteArrayTypeSignature(ArrayType array);
    public void WriteGenericInstanceSignature(IGenericInstance instance);
    private void WriteModifierSignature(ElementType element_type, IModifierType type);
    private bool TryWriteElementType(TypeReference type);
    public void WriteConstantString(string value);
    public void WriteConstantPrimitive(object value);
    public void WriteCustomAttributeConstructorArguments(CustomAttribute attribute);
    private void WriteCustomAttributeFixedArgument(TypeReference type, CustomAttributeArgument argument);
    private void WriteCustomAttributeFixedArrayArgument(ArrayType type, CustomAttributeArgument argument);
    private void WriteCustomAttributeElement(TypeReference type, CustomAttributeArgument argument);
    private void WriteCustomAttributeValue(TypeReference type, object value);
    private void WritePrimitiveValue(object value);
    private void WriteCustomAttributeEnumValue(TypeReference enum_type, object value);
    private void WriteCustomAttributeFieldOrPropType(TypeReference type);
    public void WriteCustomAttributeNamedArguments(CustomAttribute attribute);
    private static int GetNamedArgumentCount(ICustomAttribute attribute);
    private void WriteICustomAttributeNamedArguments(ICustomAttribute attribute);
    private void WriteCustomAttributeNamedArguments(byte kind, Collection`1<CustomAttributeNamedArgument> named_arguments);
    private void WriteCustomAttributeNamedArgument(byte kind, CustomAttributeNamedArgument named_argument);
    private void WriteSecurityAttribute(SecurityAttribute attribute);
    public void WriteSecurityDeclaration(SecurityDeclaration declaration);
    public void WriteXmlSecurityDeclaration(SecurityDeclaration declaration);
    private static string GetXmlSecurityDeclaration(SecurityDeclaration declaration);
    private void WriteTypeReference(TypeReference type);
    public void WriteMarshalInfo(MarshalInfo marshal_info);
    private void WriteNativeType(NativeType native);
    private void WriteVariantType(VariantType variant);
}
internal abstract class Mono.Cecil.SortedTable`1 : MetadataTable`1<TRow> {
    public sealed virtual void Sort();
    protected int Compare(UInt32 x, UInt32 y);
    public abstract virtual int Compare(TRow x, TRow y);
}
internal class Mono.Cecil.StandAloneSigTable : MetadataTable`1<UInt32> {
    public virtual void Write(TableHeapBuffer buffer);
}
public enum Mono.Cecil.TargetArchitecture : Enum {
    public int value__;
    public static TargetArchitecture I386;
    public static TargetArchitecture AMD64;
    public static TargetArchitecture IA64;
    public static TargetArchitecture ARMv7;
}
public enum Mono.Cecil.TargetRuntime : Enum {
    public int value__;
    public static TargetRuntime Net_1_0;
    public static TargetRuntime Net_1_1;
    public static TargetRuntime Net_2_0;
    public static TargetRuntime Net_4_0;
}
public enum Mono.Cecil.TokenType : Enum {
    public UInt32 value__;
    public static TokenType Module;
    public static TokenType TypeRef;
    public static TokenType TypeDef;
    public static TokenType Field;
    public static TokenType Method;
    public static TokenType Param;
    public static TokenType InterfaceImpl;
    public static TokenType MemberRef;
    public static TokenType CustomAttribute;
    public static TokenType Permission;
    public static TokenType Signature;
    public static TokenType Event;
    public static TokenType Property;
    public static TokenType ModuleRef;
    public static TokenType TypeSpec;
    public static TokenType Assembly;
    public static TokenType AssemblyRef;
    public static TokenType File;
    public static TokenType ExportedType;
    public static TokenType ManifestResource;
    public static TokenType GenericParam;
    public static TokenType MethodSpec;
    public static TokenType String;
}
[FlagsAttribute]
public enum Mono.Cecil.TypeAttributes : Enum {
    public UInt32 value__;
    public static TypeAttributes VisibilityMask;
    public static TypeAttributes NotPublic;
    public static TypeAttributes Public;
    public static TypeAttributes NestedPublic;
    public static TypeAttributes NestedPrivate;
    public static TypeAttributes NestedFamily;
    public static TypeAttributes NestedAssembly;
    public static TypeAttributes NestedFamANDAssem;
    public static TypeAttributes NestedFamORAssem;
    public static TypeAttributes LayoutMask;
    public static TypeAttributes AutoLayout;
    public static TypeAttributes SequentialLayout;
    public static TypeAttributes ExplicitLayout;
    public static TypeAttributes ClassSemanticMask;
    public static TypeAttributes Class;
    public static TypeAttributes Interface;
    public static TypeAttributes Abstract;
    public static TypeAttributes Sealed;
    public static TypeAttributes SpecialName;
    public static TypeAttributes Import;
    public static TypeAttributes Serializable;
    public static TypeAttributes WindowsRuntime;
    public static TypeAttributes StringFormatMask;
    public static TypeAttributes AnsiClass;
    public static TypeAttributes UnicodeClass;
    public static TypeAttributes AutoClass;
    public static TypeAttributes BeforeFieldInit;
    public static TypeAttributes RTSpecialName;
    public static TypeAttributes HasSecurity;
    public static TypeAttributes Forwarder;
}
public class Mono.Cecil.TypeDefinition : TypeReference {
    private UInt32 attributes;
    private TypeReference base_type;
    internal Range fields_range;
    internal Range methods_range;
    private short packing_size;
    private int class_size;
    private Collection`1<TypeReference> interfaces;
    private Collection`1<TypeDefinition> nested_types;
    private Collection`1<MethodDefinition> methods;
    private Collection`1<FieldDefinition> fields;
    private Collection`1<EventDefinition> events;
    private Collection`1<PropertyDefinition> properties;
    private Collection`1<CustomAttribute> custom_attributes;
    private Collection`1<SecurityDeclaration> security_declarations;
    public TypeAttributes Attributes { get; public set; }
    public TypeReference BaseType { get; public set; }
    public bool HasLayoutInfo { get; }
    public short PackingSize { get; public set; }
    public int ClassSize { get; public set; }
    public bool HasInterfaces { get; }
    public Collection`1<TypeReference> Interfaces { get; }
    public bool HasNestedTypes { get; }
    public Collection`1<TypeDefinition> NestedTypes { get; }
    public bool HasMethods { get; }
    public Collection`1<MethodDefinition> Methods { get; }
    public bool HasFields { get; }
    public Collection`1<FieldDefinition> Fields { get; }
    public bool HasEvents { get; }
    public Collection`1<EventDefinition> Events { get; }
    public bool HasProperties { get; }
    public Collection`1<PropertyDefinition> Properties { get; }
    public bool HasSecurityDeclarations { get; }
    public Collection`1<SecurityDeclaration> SecurityDeclarations { get; }
    public bool HasCustomAttributes { get; }
    public Collection`1<CustomAttribute> CustomAttributes { get; }
    public bool HasGenericParameters { get; }
    public Collection`1<GenericParameter> GenericParameters { get; }
    public bool IsNotPublic { get; public set; }
    public bool IsPublic { get; public set; }
    public bool IsNestedPublic { get; public set; }
    public bool IsNestedPrivate { get; public set; }
    public bool IsNestedFamily { get; public set; }
    public bool IsNestedAssembly { get; public set; }
    public bool IsNestedFamilyAndAssembly { get; public set; }
    public bool IsNestedFamilyOrAssembly { get; public set; }
    public bool IsAutoLayout { get; public set; }
    public bool IsSequentialLayout { get; public set; }
    public bool IsExplicitLayout { get; public set; }
    public bool IsClass { get; public set; }
    public bool IsInterface { get; public set; }
    public bool IsAbstract { get; public set; }
    public bool IsSealed { get; public set; }
    public bool IsSpecialName { get; public set; }
    public bool IsImport { get; public set; }
    public bool IsSerializable { get; public set; }
    public bool IsWindowsRuntime { get; public set; }
    public bool IsAnsiClass { get; public set; }
    public bool IsUnicodeClass { get; public set; }
    public bool IsAutoClass { get; public set; }
    public bool IsBeforeFieldInit { get; public set; }
    public bool IsRuntimeSpecialName { get; public set; }
    public bool HasSecurity { get; public set; }
    public bool IsEnum { get; }
    public bool IsValueType { get; }
    public bool IsPrimitive { get; }
    public MetadataType MetadataType { get; }
    public bool IsDefinition { get; }
    public TypeDefinition DeclaringType { get; public set; }
    public TypeDefinition(string namespace, string name, TypeAttributes attributes);
    public TypeDefinition(string namespace, string name, TypeAttributes attributes, TypeReference baseType);
    public TypeAttributes get_Attributes();
    public void set_Attributes(TypeAttributes value);
    public TypeReference get_BaseType();
    public void set_BaseType(TypeReference value);
    private void ResolveLayout();
    public bool get_HasLayoutInfo();
    public short get_PackingSize();
    public void set_PackingSize(short value);
    public int get_ClassSize();
    public void set_ClassSize(int value);
    public bool get_HasInterfaces();
    public Collection`1<TypeReference> get_Interfaces();
    public bool get_HasNestedTypes();
    public Collection`1<TypeDefinition> get_NestedTypes();
    public bool get_HasMethods();
    public Collection`1<MethodDefinition> get_Methods();
    public bool get_HasFields();
    public Collection`1<FieldDefinition> get_Fields();
    public bool get_HasEvents();
    public Collection`1<EventDefinition> get_Events();
    public bool get_HasProperties();
    public Collection`1<PropertyDefinition> get_Properties();
    public sealed virtual bool get_HasSecurityDeclarations();
    public sealed virtual Collection`1<SecurityDeclaration> get_SecurityDeclarations();
    public sealed virtual bool get_HasCustomAttributes();
    public sealed virtual Collection`1<CustomAttribute> get_CustomAttributes();
    public virtual bool get_HasGenericParameters();
    public virtual Collection`1<GenericParameter> get_GenericParameters();
    public bool get_IsNotPublic();
    public void set_IsNotPublic(bool value);
    public bool get_IsPublic();
    public void set_IsPublic(bool value);
    public bool get_IsNestedPublic();
    public void set_IsNestedPublic(bool value);
    public bool get_IsNestedPrivate();
    public void set_IsNestedPrivate(bool value);
    public bool get_IsNestedFamily();
    public void set_IsNestedFamily(bool value);
    public bool get_IsNestedAssembly();
    public void set_IsNestedAssembly(bool value);
    public bool get_IsNestedFamilyAndAssembly();
    public void set_IsNestedFamilyAndAssembly(bool value);
    public bool get_IsNestedFamilyOrAssembly();
    public void set_IsNestedFamilyOrAssembly(bool value);
    public bool get_IsAutoLayout();
    public void set_IsAutoLayout(bool value);
    public bool get_IsSequentialLayout();
    public void set_IsSequentialLayout(bool value);
    public bool get_IsExplicitLayout();
    public void set_IsExplicitLayout(bool value);
    public bool get_IsClass();
    public void set_IsClass(bool value);
    public bool get_IsInterface();
    public void set_IsInterface(bool value);
    public bool get_IsAbstract();
    public void set_IsAbstract(bool value);
    public bool get_IsSealed();
    public void set_IsSealed(bool value);
    public sealed virtual bool get_IsSpecialName();
    public sealed virtual void set_IsSpecialName(bool value);
    public bool get_IsImport();
    public void set_IsImport(bool value);
    public bool get_IsSerializable();
    public void set_IsSerializable(bool value);
    public bool get_IsWindowsRuntime();
    public void set_IsWindowsRuntime(bool value);
    public bool get_IsAnsiClass();
    public void set_IsAnsiClass(bool value);
    public bool get_IsUnicodeClass();
    public void set_IsUnicodeClass(bool value);
    public bool get_IsAutoClass();
    public void set_IsAutoClass(bool value);
    public bool get_IsBeforeFieldInit();
    public void set_IsBeforeFieldInit(bool value);
    public sealed virtual bool get_IsRuntimeSpecialName();
    public sealed virtual void set_IsRuntimeSpecialName(bool value);
    public bool get_HasSecurity();
    public void set_HasSecurity(bool value);
    public bool get_IsEnum();
    public virtual bool get_IsValueType();
    public virtual bool get_IsPrimitive();
    public virtual MetadataType get_MetadataType();
    public virtual bool get_IsDefinition();
    public sealed virtual TypeDefinition get_DeclaringType();
    public sealed virtual void set_DeclaringType(TypeDefinition value);
    public virtual TypeDefinition Resolve();
}
internal class Mono.Cecil.TypeDefinitionCollection : Collection`1<TypeDefinition> {
    private ModuleDefinition container;
    private Dictionary`2<Row`2<string, string>, TypeDefinition> name_cache;
    internal TypeDefinitionCollection(ModuleDefinition container);
    internal TypeDefinitionCollection(ModuleDefinition container, int capacity);
    protected virtual void OnAdd(TypeDefinition item, int index);
    protected virtual void OnSet(TypeDefinition item, int index);
    protected virtual void OnInsert(TypeDefinition item, int index);
    protected virtual void OnRemove(TypeDefinition item, int index);
    protected virtual void OnClear();
    private void Attach(TypeDefinition type);
    private void Detach(TypeDefinition type);
    public TypeDefinition GetType(string fullname);
    public TypeDefinition GetType(string namespace, string name);
}
internal class Mono.Cecil.TypeDefTable : MetadataTable`1<Row`6<TypeAttributes, UInt32, UInt32, UInt32, UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
}
internal class Mono.Cecil.TypeParser : object {
    private string fullname;
    private int length;
    private int position;
    private TypeParser(string fullname);
    private Type ParseType(bool fq_name);
    private static bool TryGetArity(Type type);
    private static bool TryGetArity(string name, Int32& arity);
    private static bool ParseInt32(string value, Int32& result);
    private static void TryAddArity(string name, Int32& arity);
    private string ParsePart();
    private static bool IsDelimiter(char chr);
    private void TryParseWhiteSpace();
    private String[] ParseNestedNames();
    private bool TryParse(char chr);
    private static void Add(T[]& array, T item);
    private Int32[] ParseSpecs();
    private Type[] ParseGenericArguments(int arity);
    private string ParseAssemblyName();
    public static TypeReference ParseType(ModuleDefinition module, string fullname);
    private static TypeReference GetTypeReference(ModuleDefinition module, Type type_info);
    private static TypeReference CreateSpecs(TypeReference type, Type type_info);
    private static TypeReference TryCreateGenericInstanceType(TypeReference type, Type type_info);
    public static void SplitFullName(string fullname, String& namespace, String& name);
    private static TypeReference CreateReference(Type type_info, ModuleDefinition module, IMetadataScope scope);
    private static void AdjustGenericParameters(TypeReference type);
    private static IMetadataScope GetMetadataScope(ModuleDefinition module, Type type_info);
    private static AssemblyNameReference MatchReference(ModuleDefinition module, AssemblyNameReference pattern);
    private static bool TryGetDefinition(ModuleDefinition module, Type type_info, TypeReference& type);
    private static bool TryCurrentModule(ModuleDefinition module, Type type_info);
    public static string ToParseable(TypeReference type);
    private static void AppendNamePart(string part, StringBuilder name);
    private static void AppendType(TypeReference type, StringBuilder name, bool fq_name, bool top_level);
    private static string GetScopeFullName(TypeReference type);
    private static void AppendTypeSpecification(TypeSpecification type, StringBuilder name);
    private static bool RequiresFullyQualifiedName(TypeReference type, bool top_level);
}
public class Mono.Cecil.TypeReference : MemberReference {
    private string namespace;
    private bool value_type;
    internal IMetadataScope scope;
    internal ModuleDefinition module;
    internal ElementType etype;
    private string fullname;
    protected Collection`1<GenericParameter> generic_parameters;
    public string Name { get; public set; }
    public string Namespace { get; public set; }
    public bool IsValueType { get; public set; }
    public ModuleDefinition Module { get; }
    private IGenericParameterProvider Mono.Cecil.IGenericContext.Type { get; }
    private IGenericParameterProvider Mono.Cecil.IGenericContext.Method { get; }
    private GenericParameterType Mono.Cecil.IGenericParameterProvider.GenericParameterType { get; }
    public bool HasGenericParameters { get; }
    public Collection`1<GenericParameter> GenericParameters { get; }
    public IMetadataScope Scope { get; public set; }
    public bool IsNested { get; }
    public TypeReference DeclaringType { get; public set; }
    public string FullName { get; }
    public bool IsByReference { get; }
    public bool IsPointer { get; }
    public bool IsSentinel { get; }
    public bool IsArray { get; }
    public bool IsGenericParameter { get; }
    public bool IsGenericInstance { get; }
    public bool IsRequiredModifier { get; }
    public bool IsOptionalModifier { get; }
    public bool IsPinned { get; }
    public bool IsFunctionPointer { get; }
    public bool IsPrimitive { get; }
    public MetadataType MetadataType { get; }
    protected TypeReference(string namespace, string name);
    public TypeReference(string namespace, string name, ModuleDefinition module, IMetadataScope scope);
    public TypeReference(string namespace, string name, ModuleDefinition module, IMetadataScope scope, bool valueType);
    public virtual string get_Name();
    public virtual void set_Name(string value);
    public virtual string get_Namespace();
    public virtual void set_Namespace(string value);
    public virtual bool get_IsValueType();
    public virtual void set_IsValueType(bool value);
    public virtual ModuleDefinition get_Module();
    private sealed virtual override IGenericParameterProvider Mono.Cecil.IGenericContext.get_Type();
    private sealed virtual override IGenericParameterProvider Mono.Cecil.IGenericContext.get_Method();
    private sealed virtual override GenericParameterType Mono.Cecil.IGenericParameterProvider.get_GenericParameterType();
    public virtual bool get_HasGenericParameters();
    public virtual Collection`1<GenericParameter> get_GenericParameters();
    public virtual IMetadataScope get_Scope();
    public virtual void set_Scope(IMetadataScope value);
    public bool get_IsNested();
    public virtual TypeReference get_DeclaringType();
    public virtual void set_DeclaringType(TypeReference value);
    public virtual string get_FullName();
    public virtual bool get_IsByReference();
    public virtual bool get_IsPointer();
    public virtual bool get_IsSentinel();
    public virtual bool get_IsArray();
    public virtual bool get_IsGenericParameter();
    public virtual bool get_IsGenericInstance();
    public virtual bool get_IsRequiredModifier();
    public virtual bool get_IsOptionalModifier();
    public virtual bool get_IsPinned();
    public virtual bool get_IsFunctionPointer();
    public virtual bool get_IsPrimitive();
    public virtual MetadataType get_MetadataType();
    public virtual TypeReference GetElementType();
    public virtual TypeDefinition Resolve();
}
internal class Mono.Cecil.TypeRefTable : MetadataTable`1<Row`3<UInt32, UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
}
public abstract class Mono.Cecil.TypeSpecification : TypeReference {
    private TypeReference element_type;
    public TypeReference ElementType { get; }
    public string Name { get; public set; }
    public string Namespace { get; public set; }
    public IMetadataScope Scope { get; public set; }
    public ModuleDefinition Module { get; }
    public string FullName { get; }
    public bool ContainsGenericParameter { get; }
    public MetadataType MetadataType { get; }
    internal TypeSpecification(TypeReference type);
    public sealed virtual TypeReference get_ElementType();
    public virtual string get_Name();
    public virtual void set_Name(string value);
    public virtual string get_Namespace();
    public virtual void set_Namespace(string value);
    public virtual IMetadataScope get_Scope();
    public virtual void set_Scope(IMetadataScope value);
    public virtual ModuleDefinition get_Module();
    public virtual string get_FullName();
    public virtual bool get_ContainsGenericParameter();
    public virtual MetadataType get_MetadataType();
    public virtual TypeReference GetElementType();
}
internal class Mono.Cecil.TypeSpecTable : MetadataTable`1<UInt32> {
    public virtual void Write(TableHeapBuffer buffer);
}
public abstract class Mono.Cecil.TypeSystem : object {
    private ModuleDefinition module;
    private TypeReference type_object;
    private TypeReference type_void;
    private TypeReference type_bool;
    private TypeReference type_char;
    private TypeReference type_sbyte;
    private TypeReference type_byte;
    private TypeReference type_int16;
    private TypeReference type_uint16;
    private TypeReference type_int32;
    private TypeReference type_uint32;
    private TypeReference type_int64;
    private TypeReference type_uint64;
    private TypeReference type_single;
    private TypeReference type_double;
    private TypeReference type_intptr;
    private TypeReference type_uintptr;
    private TypeReference type_string;
    private TypeReference type_typedref;
    public IMetadataScope Corlib { get; }
    public TypeReference Object { get; }
    public TypeReference Void { get; }
    public TypeReference Boolean { get; }
    public TypeReference Char { get; }
    public TypeReference SByte { get; }
    public TypeReference Byte { get; }
    public TypeReference Int16 { get; }
    public TypeReference UInt16 { get; }
    public TypeReference Int32 { get; }
    public TypeReference UInt32 { get; }
    public TypeReference Int64 { get; }
    public TypeReference UInt64 { get; }
    public TypeReference Single { get; }
    public TypeReference Double { get; }
    public TypeReference IntPtr { get; }
    public TypeReference UIntPtr { get; }
    public TypeReference String { get; }
    public TypeReference TypedReference { get; }
    private TypeSystem(ModuleDefinition module);
    internal static TypeSystem CreateTypeSystem(ModuleDefinition module);
    internal abstract virtual TypeReference LookupType(string namespace, string name);
    private TypeReference LookupSystemType(TypeReference& reference, string name, ElementType element_type);
    private TypeReference LookupSystemValueType(TypeReference& typeRef, string name, ElementType element_type);
    public IMetadataScope get_Corlib();
    public TypeReference get_Object();
    public TypeReference get_Void();
    public TypeReference get_Boolean();
    public TypeReference get_Char();
    public TypeReference get_SByte();
    public TypeReference get_Byte();
    public TypeReference get_Int16();
    public TypeReference get_UInt16();
    public TypeReference get_Int32();
    public TypeReference get_UInt32();
    public TypeReference get_Int64();
    public TypeReference get_UInt64();
    public TypeReference get_Single();
    public TypeReference get_Double();
    public TypeReference get_IntPtr();
    public TypeReference get_UIntPtr();
    public TypeReference get_String();
    public TypeReference get_TypedReference();
}
public enum Mono.Cecil.VariantType : Enum {
    public int value__;
    public static VariantType None;
    public static VariantType I2;
    public static VariantType I4;
    public static VariantType R4;
    public static VariantType R8;
    public static VariantType CY;
    public static VariantType Date;
    public static VariantType BStr;
    public static VariantType Dispatch;
    public static VariantType Error;
    public static VariantType Bool;
    public static VariantType Variant;
    public static VariantType Unknown;
    public static VariantType Decimal;
    public static VariantType I1;
    public static VariantType UI1;
    public static VariantType UI2;
    public static VariantType UI4;
    public static VariantType Int;
    public static VariantType UInt;
}
public class Mono.Cecil.WriterParameters : object {
    private Stream symbol_stream;
    private ISymbolWriterProvider symbol_writer_provider;
    private bool write_symbols;
    private StrongNameKeyPair key_pair;
    public Stream SymbolStream { get; public set; }
    public ISymbolWriterProvider SymbolWriterProvider { get; public set; }
    public bool WriteSymbols { get; public set; }
    public StrongNameKeyPair StrongNameKeyPair { get; public set; }
    public Stream get_SymbolStream();
    public void set_SymbolStream(Stream value);
    public ISymbolWriterProvider get_SymbolWriterProvider();
    public void set_SymbolWriterProvider(ISymbolWriterProvider value);
    public bool get_WriteSymbols();
    public void set_WriteSymbols(bool value);
    public StrongNameKeyPair get_StrongNameKeyPair();
    public void set_StrongNameKeyPair(StrongNameKeyPair value);
}
[DefaultMemberAttribute("Item")]
public class Mono.Collections.Generic.Collection`1 : object {
    internal T[] items;
    internal int size;
    private int version;
    public int Count { get; }
    public T Item { get; public set; }
    public int Capacity { get; public set; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    private int System.Collections.ICollection.Count { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public Collection`1(int capacity);
    public Collection`1(ICollection`1<T> items);
    public sealed virtual int get_Count();
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
    public int get_Capacity();
    public void set_Capacity(int value);
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override int System.Collections.ICollection.get_Count();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    public sealed virtual void Add(T item);
    public sealed virtual bool Contains(T item);
    public sealed virtual int IndexOf(T item);
    public sealed virtual void Insert(int index, T item);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual bool Remove(T item);
    public sealed virtual void Clear();
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public T[] ToArray();
    private void CheckIndex(int index);
    private void Shift(int start, int delta);
    protected virtual void OnAdd(T item, int index);
    protected virtual void OnInsert(T item, int index);
    protected virtual void OnSet(T item, int index);
    protected virtual void OnRemove(T item, int index);
    protected virtual void OnClear();
    internal virtual void Grow(int desired);
    protected void Resize(int new_size);
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override void System.Collections.IList.Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.IList.RemoveAt(int index);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public Enumerator<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
}
public class Mono.Collections.Generic.ReadOnlyCollection`1 : Collection`1<T> {
    private static ReadOnlyCollection`1<T> empty;
    public static ReadOnlyCollection`1<T> Empty { get; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    public ReadOnlyCollection`1(T[] array);
    public ReadOnlyCollection`1(Collection`1<T> collection);
    public static ReadOnlyCollection`1<T> get_Empty();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private void Initialize(T[] items, int size);
    internal virtual void Grow(int desired);
    protected virtual void OnAdd(T item, int index);
    protected virtual void OnClear();
    protected virtual void OnInsert(T item, int index);
    protected virtual void OnRemove(T item, int index);
    protected virtual void OnSet(T item, int index);
}
internal static class Mono.Empty`1 : object {
    public static T[] Array;
    private static Empty`1();
}
[FlagsAttribute]
[CLSCompliantAttribute("False")]
[ObsoleteAttribute("Use Mono.Unix.Native.AccessModes")]
public enum Mono.Posix.AccessMode : Enum {
    public int value__;
    public static AccessMode R_OK;
    public static AccessMode W_OK;
    public static AccessMode X_OK;
    public static AccessMode F_OK;
}
[ObsoleteAttribute("Use Mono.Unix.Catalog")]
public class Mono.Posix.Catalog : object {
    private static IntPtr bindtextdomain(IntPtr domainname, IntPtr dirname);
    private static IntPtr bind_textdomain_codeset(IntPtr domainname, IntPtr codeset);
    private static IntPtr textdomain(IntPtr domainname);
    public static void Init(string package, string localedir);
    private static IntPtr gettext(IntPtr instring);
    public static string GetString(string s);
    private static IntPtr ngettext(IntPtr singular, IntPtr plural, int n);
    public static string GetPluralString(string s, string p, int n);
}
[ObsoleteAttribute("Use Mono.Unix.Native.FilePermissions")]
[FlagsAttribute]
[CLSCompliantAttribute("False")]
public enum Mono.Posix.FileMode : Enum {
    public int value__;
    public static FileMode S_ISUID;
    public static FileMode S_ISGID;
    public static FileMode S_ISVTX;
    public static FileMode S_IRUSR;
    public static FileMode S_IWUSR;
    public static FileMode S_IXUSR;
    public static FileMode S_IRGRP;
    public static FileMode S_IWGRP;
    public static FileMode S_IXGRP;
    public static FileMode S_IROTH;
    public static FileMode S_IWOTH;
    public static FileMode S_IXOTH;
}
[ObsoleteAttribute("Use Mono.Unix.Native.OpenFlags")]
[CLSCompliantAttribute("False")]
[FlagsAttribute]
public enum Mono.Posix.OpenFlags : Enum {
    public int value__;
    public static OpenFlags O_RDONLY;
    public static OpenFlags O_WRONLY;
    public static OpenFlags O_RDWR;
    public static OpenFlags O_CREAT;
    public static OpenFlags O_EXCL;
    public static OpenFlags O_NOCTTY;
    public static OpenFlags O_TRUNC;
    public static OpenFlags O_APPEND;
    public static OpenFlags O_NONBLOCK;
    public static OpenFlags O_SYNC;
}
[ObsoleteAttribute("Use Mono.Unix.PeerCred")]
public class Mono.Posix.PeerCred : object {
    private static int so_peercred;
    private PeerCredData data;
    public int ProcessID { get; }
    public int UserID { get; }
    public int GroupID { get; }
    public PeerCred(Socket sock);
    public int get_ProcessID();
    public int get_UserID();
    public int get_GroupID();
}
internal class Mono.Posix.PeerCredData : ValueType {
    public int pid;
    public int uid;
    public int gid;
}
[ObsoleteAttribute("Use Mono.Unix.Native.Signum")]
[CLSCompliantAttribute("False")]
public enum Mono.Posix.Signals : Enum {
    public int value__;
    public static Signals SIGHUP;
    public static Signals SIGINT;
    public static Signals SIGQUIT;
    public static Signals SIGILL;
    public static Signals SIGTRAP;
    public static Signals SIGABRT;
    public static Signals SIGBUS;
    public static Signals SIGFPE;
    public static Signals SIGKILL;
    public static Signals SIGUSR1;
    public static Signals SIGSEGV;
    public static Signals SIGUSR2;
    public static Signals SIGPIPE;
    public static Signals SIGALRM;
    public static Signals SIGTERM;
    public static Signals SIGCHLD;
    public static Signals SIGCONT;
    public static Signals SIGSTOP;
    public static Signals SIGTSTP;
    public static Signals SIGTTIN;
    public static Signals SIGTTOU;
    public static Signals SIGURG;
    public static Signals SIGXCPU;
    public static Signals SIGXFSZ;
    public static Signals SIGVTALRM;
    public static Signals SIGPROF;
    public static Signals SIGWINCH;
    public static Signals SIGIO;
    public static Signals SIGSYS;
}
[ObsoleteAttribute("Use Mono.Unix.Native.Stat")]
public class Mono.Posix.Stat : ValueType {
    [ObsoleteAttribute("Use Mono.Unix.Native.Stat.st_dev")]
public int Device;
    [ObsoleteAttribute("Use Mono.Unix.Native.Stat.st_ino")]
public int INode;
    [ObsoleteAttribute("Use Mono.Unix.Native.Stat.st_mode")]
public StatMode Mode;
    [ObsoleteAttribute("Use Mono.Unix.Native.Stat.st_nlink")]
public int NLinks;
    [ObsoleteAttribute("Use Mono.Unix.Native.Stat.st_uid")]
public int Uid;
    [ObsoleteAttribute("Use Mono.Unix.Native.Stat.st_gid")]
public int Gid;
    [ObsoleteAttribute("Use Mono.Unix.Native.Stat.st_rdev")]
public long DeviceType;
    [ObsoleteAttribute("Use Mono.Unix.Native.Stat.st_size")]
public long Size;
    [ObsoleteAttribute("Use Mono.Unix.Native.Stat.st_blksize")]
public long BlockSize;
    [ObsoleteAttribute("Use Mono.Unix.Native.Stat.st_blocks")]
public long Blocks;
    [ObsoleteAttribute("Use Mono.Unix.Native.Stat.st_atime")]
public DateTime ATime;
    [ObsoleteAttribute("Use Mono.Unix.Native.Stat.st_mtime")]
public DateTime MTime;
    [ObsoleteAttribute("Use Mono.Unix.Native.Stat.st_ctime")]
public DateTime CTime;
    [ObsoleteAttribute("Use Mono.Unix.Native.NativeConvert.LocalUnixEpoch")]
public static DateTime UnixEpoch;
    internal Stat(int device, int inode, int mode, int nlinks, int uid, int gid, int rdev, long size, long blksize, long blocks, long atime, long mtime, long ctime);
    private static Stat();
    [ObsoleteAttribute("Use Mono.Unix.Native.NativeConvert.ToDateTime")]
public static DateTime UnixToDateTime(long unix);
}
[FlagsAttribute]
[ObsoleteAttribute("Use Mono.Unix.Native.FilePermissions")]
public enum Mono.Posix.StatMode : Enum {
    public int value__;
    [ObsoleteAttribute("Use Mono.Unix.Native.FilePermissions.S_IFSOCK")]
public static StatMode Socket;
    [ObsoleteAttribute("Use Mono.Unix.Native.FilePermissions.S_IFLNK")]
public static StatMode SymLink;
    [ObsoleteAttribute("Use Mono.Unix.Native.FilePermissions.S_IFREG")]
public static StatMode Regular;
    [ObsoleteAttribute("Use Mono.Unix.Native.FilePermissions.S_IFBLK")]
public static StatMode BlockDevice;
    [ObsoleteAttribute("Use Mono.Unix.Native.FilePermissions.S_IFDIR")]
public static StatMode Directory;
    [ObsoleteAttribute("Use Mono.Unix.Native.FilePermissions.S_IFCHR")]
public static StatMode CharDevice;
    [ObsoleteAttribute("Use Mono.Unix.Native.FilePermissions.S_IFIFO")]
public static StatMode FIFO;
    [ObsoleteAttribute("Use Mono.Unix.Native.FilePermissions.S_ISUID")]
public static StatMode SUid;
    [ObsoleteAttribute("Use Mono.Unix.Native.FilePermissions.S_ISGID")]
public static StatMode SGid;
    [ObsoleteAttribute("Use Mono.Unix.Native.FilePermissions.S_ISVTX")]
public static StatMode Sticky;
    [ObsoleteAttribute("Use Mono.Unix.Native.FilePermissions.S_IRUSR")]
public static StatMode OwnerRead;
    [ObsoleteAttribute("Use Mono.Unix.Native.FilePermissions.S_IWUSR")]
public static StatMode OwnerWrite;
    [ObsoleteAttribute("Use Mono.Unix.Native.FilePermissions.S_IXUSR")]
public static StatMode OwnerExecute;
    [ObsoleteAttribute("Use Mono.Unix.Native.FilePermissions.S_IRGRP")]
public static StatMode GroupRead;
    [ObsoleteAttribute("Use Mono.Unix.Native.FilePermissions.S_IWGRP")]
public static StatMode GroupWrite;
    [ObsoleteAttribute("Use Mono.Unix.Native.FilePermissions.S_IXGRP")]
public static StatMode GroupExecute;
    [ObsoleteAttribute("Use Mono.Unix.Native.FilePermissions.S_IROTH")]
public static StatMode OthersRead;
    [ObsoleteAttribute("Use Mono.Unix.Native.FilePermissions.S_IWOTH")]
public static StatMode OthersWrite;
    [ObsoleteAttribute("Use Mono.Unix.Native.FilePermissions.S_IXOTH")]
public static StatMode OthersExecute;
}
[ObsoleteAttribute("Use Mono.Unix.Native.FilePermissions")]
public enum Mono.Posix.StatModeMasks : Enum {
    public int value__;
    [ObsoleteAttribute("Use Mono.Unix.Native.FilePermissions.S_IFMT")]
public static StatModeMasks TypeMask;
    [ObsoleteAttribute("Use Mono.Unix.Native.FilePermissions.S_RWXU")]
public static StatModeMasks OwnerMask;
    [ObsoleteAttribute("Use Mono.Unix.Native.FilePermissions.S_RWXG")]
public static StatModeMasks GroupMask;
    [ObsoleteAttribute("Use Mono.Unix.Native.FilePermissions.S_RWXO")]
public static StatModeMasks OthersMask;
}
[CLSCompliantAttribute("False")]
[ObsoleteAttribute("Use Mono.Unix.Native.Syscall.")]
public class Mono.Posix.Syscall : object {
    public static int exit(int status);
    public static int fork();
    public static IntPtr read(int fileDescriptor, Void* buf, IntPtr count);
    public static IntPtr write(int fileDescriptor, Void* buf, IntPtr count);
    internal static int syscall_open(string pathname, int flags, int mode);
    internal static int map_Mono_Posix_OpenFlags(OpenFlags flags);
    internal static int map_Mono_Posix_FileMode(FileMode mode);
    public static int open(string pathname, OpenFlags flags);
    public static int open(string pathname, OpenFlags flags, FileMode mode);
    public static int close(int fileDescriptor);
    internal static int syscall_waitpid(int pid, Int32* status, int options);
    internal static int map_Mono_Posix_WaitOptions(WaitOptions wait_options);
    public static int waitpid(int pid, Int32& status, WaitOptions options);
    public static int waitpid(int pid, WaitOptions options);
    public static int WIFEXITED(int status);
    public static int WEXITSTATUS(int status);
    public static int WIFSIGNALED(int status);
    public static int WTERMSIG(int status);
    public static int WIFSTOPPED(int status);
    public static int WSTOPSIG(int status);
    internal static int syscall_creat(string pathname, int flags);
    public static int creat(string pathname, FileMode flags);
    public static int link(string oldPath, string newPath);
    public static int unlink(string path);
    public static int symlink(string oldpath, string newpath);
    public static int chdir(string path);
    internal static int syscall_chmod(string path, int mode);
    public static int chmod(string path, FileMode mode);
    public static int chown(string path, int owner, int group);
    public static int lchown(string path, int owner, int group);
    public static int lseek(int fileDescriptor, int offset, int whence);
    public static int getpid();
    public static int setuid(int uid);
    public static int getuid();
    public static UInt32 alarm(UInt32 seconds);
    public static int pause();
    internal static int syscall_access(string pathname, int mode);
    internal static int map_Mono_Posix_AccessMode(AccessMode mode);
    public static int access(string pathname, AccessMode mode);
    public static int nice(int increment);
    public static void sync();
    public static void kill(int pid, int sig);
    public static int rename(string oldPath, string newPath);
    internal static int syscall_mkdir(string pathname, int mode);
    public static int mkdir(string pathname, FileMode mode);
    public static int rmdir(string path);
    public static int dup(int fileDescriptor);
    public static int setgid(int gid);
    public static int getgid();
    public static int signal(int signum, sighandler_t handler);
    public static int geteuid();
    public static int getegid();
    public static int setpgid(int pid, int pgid);
    public static int umask(int umask);
    public static int chroot(string path);
    public static int dup2(int oldFileDescriptor, int newFileDescriptor);
    public static int getppid();
    public static int getpgrp();
    public static int setsid();
    public static int setreuid(int ruid, int euid);
    public static int setregid(int rgid, int egid);
    private static string helper_Mono_Posix_GetUserName(int uid);
    private static string helper_Mono_Posix_GetGroupName(int gid);
    public static string getusername(int uid);
    public static string getgroupname(int gid);
    private static int syscall_gethostname(Byte[] p, int len);
    public static string GetHostName();
    [CLSCompliantAttribute("False")]
public static string gethostname();
    private static int syscall_isatty(int desc);
    public static bool isatty(int desc);
    internal static int helper_Mono_Posix_Stat(string filename, bool dereference, Int32& device, Int32& inode, Int32& mode, Int32& nlinks, Int32& uid, Int32& gid, Int32& rdev, Int64& size, Int64& blksize, Int64& blocks, Int64& atime, Int64& mtime, Int64& ctime);
    private static int stat2(string filename, bool dereference, Stat& stat);
    public static int stat(string filename, Stat& stat);
    public static int lstat(string filename, Stat& stat);
    private static int readlink(string path, Byte[] buffer, int buflen);
    public static string readlink(string path);
    private static IntPtr _strerror(int errnum);
    public static string strerror(int errnum);
    public static IntPtr opendir(string path);
    public static int closedir(IntPtr dir);
    public static string readdir(IntPtr dir);
}
[ObsoleteAttribute("Use Mono.Unix.UnixEndPoint")]
public class Mono.Posix.UnixEndPoint : EndPoint {
    private string filename;
    public string Filename { get; public set; }
    public AddressFamily AddressFamily { get; }
    public UnixEndPoint(string filename);
    public string get_Filename();
    public void set_Filename(string value);
    public virtual AddressFamily get_AddressFamily();
    public virtual EndPoint Create(SocketAddress socketAddress);
    public virtual SocketAddress Serialize();
    public virtual string ToString();
    public virtual int GetHashCode();
    public virtual bool Equals(object o);
}
[FlagsAttribute]
[ObsoleteAttribute("Use Mono.Unix.Native.WaitOptions")]
[CLSCompliantAttribute("False")]
public enum Mono.Posix.WaitOptions : Enum {
    public int value__;
    public static WaitOptions WNOHANG;
    public static WaitOptions WUNTRACED;
}
internal class Mono.Remoting.Channels.Unix.ClientConnection : object {
    private Socket _client;
    private UnixServerTransportSink _sink;
    private Stream _stream;
    private UnixServerChannel _serverChannel;
    private Byte[] _buffer;
    public Socket Client { get; }
    public Byte[] Buffer { get; }
    public bool IsLocal { get; }
    public ClientConnection(UnixServerChannel serverChannel, Socket client, UnixServerTransportSink sink);
    public Socket get_Client();
    public Byte[] get_Buffer();
    public void ProcessMessages();
    public bool get_IsLocal();
}
internal class Mono.Remoting.Channels.Unix.HostConnectionPool : object {
    private ArrayList _pool;
    private int _activeConnections;
    private string _path;
    public HostConnectionPool(string path);
    public UnixConnection GetConnection();
    private UnixConnection CreateConnection();
    public void ReleaseConnection(UnixConnection entry);
    private void CancelConnection(UnixConnection entry);
    public void PurgeConnections();
}
internal enum Mono.Remoting.Channels.Unix.MessageStatus : Enum {
    public int value__;
    public static MessageStatus MethodMessage;
    public static MessageStatus CancelSignal;
    public static MessageStatus Unknown;
}
internal class Mono.Remoting.Channels.Unix.MethodCallHeaderHandler : object {
    private string _uri;
    public MethodCallHeaderHandler(string uri);
    public object HandleHeaders(Header[] headers);
}
internal class Mono.Remoting.Channels.Unix.ReusableUnixClient : UnixClient {
    public bool IsAlive { get; }
    public ReusableUnixClient(string path);
    public bool get_IsAlive();
}
internal class Mono.Remoting.Channels.Unix.SimpleBinder : SerializationBinder {
    public static SimpleBinder Instance;
    private static SimpleBinder();
    public virtual Type BindToType(string assemblyName, string typeName);
}
internal class Mono.Remoting.Channels.Unix.UnixBinaryClientFormatterSink : object {
    private UnixBinaryCore _binaryCore;
    private IClientChannelSink _nextInChain;
    internal UnixBinaryCore BinaryCore { get; internal set; }
    public IClientChannelSink NextChannelSink { get; }
    public IMessageSink NextSink { get; }
    public IDictionary Properties { get; }
    public UnixBinaryClientFormatterSink(IClientChannelSink nextSink);
    internal UnixBinaryCore get_BinaryCore();
    internal void set_BinaryCore(UnixBinaryCore value);
    public sealed virtual IClientChannelSink get_NextChannelSink();
    public sealed virtual IMessageSink get_NextSink();
    public sealed virtual IDictionary get_Properties();
    public sealed virtual void AsyncProcessRequest(IClientChannelSinkStack sinkStack, IMessage msg, ITransportHeaders headers, Stream stream);
    public sealed virtual void AsyncProcessResponse(IClientResponseChannelSinkStack sinkStack, object state, ITransportHeaders headers, Stream stream);
    public sealed virtual Stream GetRequestStream(IMessage msg, ITransportHeaders headers);
    public sealed virtual void ProcessMessage(IMessage msg, ITransportHeaders requestHeaders, Stream requestStream, ITransportHeaders& responseHeaders, Stream& responseStream);
    public sealed virtual IMessageCtrl AsyncProcessMessage(IMessage msg, IMessageSink replySink);
    public sealed virtual IMessage SyncProcessMessage(IMessage msg);
}
internal class Mono.Remoting.Channels.Unix.UnixBinaryClientFormatterSinkProvider : object {
    private IClientChannelSinkProvider next;
    private UnixBinaryCore _binaryCore;
    private static String[] allowedProperties;
    public IClientChannelSinkProvider Next { get; public set; }
    public UnixBinaryClientFormatterSinkProvider(IDictionary properties, ICollection providerData);
    private static UnixBinaryClientFormatterSinkProvider();
    public sealed virtual IClientChannelSinkProvider get_Next();
    public sealed virtual void set_Next(IClientChannelSinkProvider value);
    public sealed virtual IClientChannelSink CreateSink(IChannelSender channel, string url, object remoteChannelData);
}
internal class Mono.Remoting.Channels.Unix.UnixBinaryCore : object {
    private BinaryFormatter _serializationFormatter;
    private BinaryFormatter _deserializationFormatter;
    private bool _includeVersions;
    private bool _strictBinding;
    private IDictionary _properties;
    public static UnixBinaryCore DefaultInstance;
    [CompilerGeneratedAttribute]
private static Dictionary`2<string, int> <>f__switch$map0;
    public BinaryFormatter Serializer { get; }
    public BinaryFormatter Deserializer { get; }
    public IDictionary Properties { get; }
    public UnixBinaryCore(object owner, IDictionary properties, String[] allowedProperties);
    private static UnixBinaryCore();
    public void Init();
    public BinaryFormatter get_Serializer();
    public BinaryFormatter get_Deserializer();
    public IDictionary get_Properties();
}
internal class Mono.Remoting.Channels.Unix.UnixBinaryServerFormatterSink : object {
    private UnixBinaryCore _binaryCore;
    private IServerChannelSink next_sink;
    private IChannelReceiver receiver;
    internal UnixBinaryCore BinaryCore { get; internal set; }
    public IServerChannelSink NextChannelSink { get; }
    public IDictionary Properties { get; }
    public UnixBinaryServerFormatterSink(IServerChannelSink nextSink, IChannelReceiver receiver);
    internal UnixBinaryCore get_BinaryCore();
    internal void set_BinaryCore(UnixBinaryCore value);
    public sealed virtual IServerChannelSink get_NextChannelSink();
    public sealed virtual IDictionary get_Properties();
    public sealed virtual void AsyncProcessResponse(IServerResponseChannelSinkStack sinkStack, object state, IMessage message, ITransportHeaders headers, Stream stream);
    public sealed virtual Stream GetResponseStream(IServerResponseChannelSinkStack sinkStack, object state, IMessage msg, ITransportHeaders headers);
    public sealed virtual ServerProcessing ProcessMessage(IServerChannelSinkStack sinkStack, IMessage requestMsg, ITransportHeaders requestHeaders, Stream requestStream, IMessage& responseMsg, ITransportHeaders& responseHeaders, Stream& responseStream);
}
internal class Mono.Remoting.Channels.Unix.UnixBinaryServerFormatterSinkProvider : object {
    private IServerChannelSinkProvider next;
    private UnixBinaryCore _binaryCore;
    internal static String[] AllowedProperties;
    public IServerChannelSinkProvider Next { get; public set; }
    public UnixBinaryServerFormatterSinkProvider(IDictionary properties, ICollection providerData);
    private static UnixBinaryServerFormatterSinkProvider();
    public sealed virtual IServerChannelSinkProvider get_Next();
    public sealed virtual void set_Next(IServerChannelSinkProvider value);
    public sealed virtual IServerChannelSink CreateSink(IChannelReceiver channel);
    public sealed virtual void GetChannelData(IChannelDataStore channelData);
}
public class Mono.Remoting.Channels.Unix.UnixChannel : object {
    private UnixClientChannel _clientChannel;
    private UnixServerChannel _serverChannel;
    private string _name;
    private int _priority;
    public string ChannelName { get; }
    public int ChannelPriority { get; }
    public object ChannelData { get; }
    public UnixChannel(string path);
    public UnixChannel(IDictionary properties, IClientChannelSinkProvider clientSinkProvider, IServerChannelSinkProvider serverSinkProvider);
    private void Init(IDictionary properties, IClientChannelSinkProvider clientSink, IServerChannelSinkProvider serverSink);
    public sealed virtual IMessageSink CreateMessageSink(string url, object remoteChannelData, String& objectURI);
    public sealed virtual string get_ChannelName();
    public sealed virtual int get_ChannelPriority();
    public sealed virtual void StartListening(object data);
    public sealed virtual void StopListening(object data);
    public sealed virtual String[] GetUrlsForUri(string uri);
    public sealed virtual object get_ChannelData();
    public sealed virtual string Parse(string url, String& objectURI);
    internal static string ParseUnixURL(string url, String& objectURI);
}
public class Mono.Remoting.Channels.Unix.UnixClientChannel : object {
    private int priority;
    private string name;
    private IClientChannelSinkProvider _sinkProvider;
    public string ChannelName { get; }
    public int ChannelPriority { get; }
    public UnixClientChannel(IDictionary properties, IClientChannelSinkProvider sinkProvider);
    public UnixClientChannel(string name, IClientChannelSinkProvider sinkProvider);
    public sealed virtual string get_ChannelName();
    public sealed virtual int get_ChannelPriority();
    public sealed virtual IMessageSink CreateMessageSink(string url, object remoteChannelData, String& objectURI);
    public sealed virtual string Parse(string url, String& objectURI);
}
internal class Mono.Remoting.Channels.Unix.UnixClientTransportSink : object {
    private string _path;
    public IDictionary Properties { get; }
    public IClientChannelSink NextChannelSink { get; }
    public UnixClientTransportSink(string url);
    public sealed virtual IDictionary get_Properties();
    public sealed virtual IClientChannelSink get_NextChannelSink();
    public sealed virtual void AsyncProcessRequest(IClientChannelSinkStack sinkStack, IMessage msg, ITransportHeaders headers, Stream requestStream);
    private void ReadAsyncUnixMessage(object data);
    public sealed virtual void AsyncProcessResponse(IClientResponseChannelSinkStack sinkStack, object state, ITransportHeaders headers, Stream stream);
    public sealed virtual Stream GetRequestStream(IMessage msg, ITransportHeaders headers);
    public sealed virtual void ProcessMessage(IMessage msg, ITransportHeaders requestHeaders, Stream requestStream, ITransportHeaders& responseHeaders, Stream& responseStream);
}
internal class Mono.Remoting.Channels.Unix.UnixClientTransportSinkProvider : object {
    public IClientChannelSinkProvider Next { get; public set; }
    public sealed virtual IClientChannelSinkProvider get_Next();
    public sealed virtual void set_Next(IClientChannelSinkProvider value);
    public sealed virtual IClientChannelSink CreateSink(IChannelSender channel, string url, object remoteChannelData);
}
internal class Mono.Remoting.Channels.Unix.UnixConnection : object {
    private DateTime _controlTime;
    private Stream _stream;
    private ReusableUnixClient _client;
    private HostConnectionPool _pool;
    private Byte[] _buffer;
    public Stream Stream { get; }
    public DateTime ControlTime { get; public set; }
    public bool IsAlive { get; }
    public Byte[] Buffer { get; }
    public UnixConnection(HostConnectionPool pool, ReusableUnixClient client);
    public Stream get_Stream();
    public DateTime get_ControlTime();
    public void set_ControlTime(DateTime value);
    public bool get_IsAlive();
    public Byte[] get_Buffer();
    public void Release();
    public void Close();
}
internal class Mono.Remoting.Channels.Unix.UnixConnectionPool : object {
    private static Hashtable _pools;
    private static int _maxOpenConnections;
    private static int _keepAliveSeconds;
    private static Thread _poolThread;
    public static int MaxOpenConnections { get; public set; }
    public static int KeepAliveSeconds { get; public set; }
    private static UnixConnectionPool();
    public static void Shutdown();
    public static int get_MaxOpenConnections();
    public static void set_MaxOpenConnections(int value);
    public static int get_KeepAliveSeconds();
    public static void set_KeepAliveSeconds(int value);
    public static UnixConnection GetConnection(string path);
    private static void ConnectionCollector();
}
internal class Mono.Remoting.Channels.Unix.UnixMessageIO : object {
    private static Byte[][] _msgHeaders;
    public static int DefaultStreamBufferSize;
    private static Byte[] msgUriTransportKey;
    private static Byte[] msgContentTypeTransportKey;
    private static Byte[] msgDefaultTransportKey;
    private static Byte[] msgHeaderTerminator;
    [CompilerGeneratedAttribute]
private static Dictionary`2<string, int> <>f__switch$map1;
    private static UnixMessageIO();
    public static MessageStatus ReceiveMessageStatus(Stream networkStream, Byte[] buffer);
    private static bool StreamRead(Stream networkStream, Byte[] buffer, int count);
    public static void SendMessageStream(Stream networkStream, Stream data, ITransportHeaders requestHeaders, Byte[] buffer);
    private static void SendHeaders(Stream networkStream, ITransportHeaders requestHeaders, Byte[] buffer);
    public static ITransportHeaders ReceiveHeaders(Stream networkStream, Byte[] buffer);
    public static Stream ReceiveMessageStream(Stream networkStream, ITransportHeaders& headers, Byte[] buffer);
    private static void SendString(Stream networkStream, string str, Byte[] buffer);
    private static string ReceiveString(Stream networkStream, Byte[] buffer);
}
public class Mono.Remoting.Channels.Unix.UnixServerChannel : object {
    private string path;
    private string name;
    private int priority;
    private bool supressChannelData;
    private Thread server_thread;
    private UnixListener listener;
    private UnixServerTransportSink sink;
    private ChannelDataStore channel_data;
    private int _maxConcurrentConnections;
    private ArrayList _activeConnections;
    [CompilerGeneratedAttribute]
private static Dictionary`2<string, int> <>f__switch$map2;
    public object ChannelData { get; }
    public string ChannelName { get; }
    public int ChannelPriority { get; }
    public UnixServerChannel(string path);
    public UnixServerChannel(IDictionary properties, IServerChannelSinkProvider serverSinkProvider);
    public UnixServerChannel(string name, string path, IServerChannelSinkProvider serverSinkProvider);
    public UnixServerChannel(string name, string path);
    private void Init(IServerChannelSinkProvider serverSinkProvider);
    public sealed virtual object get_ChannelData();
    public sealed virtual string get_ChannelName();
    public sealed virtual int get_ChannelPriority();
    public string GetChannelUri();
    public sealed virtual String[] GetUrlsForUri(string uri);
    public sealed virtual string Parse(string url, String& objectURI);
    private void WaitForConnections();
    internal void CreateListenerConnection(Socket client);
    internal void ReleaseConnection(Thread thread);
    public sealed virtual void StartListening(object data);
    public sealed virtual void StopListening(object data);
}
internal class Mono.Remoting.Channels.Unix.UnixServerTransportSink : object {
    private IServerChannelSink next_sink;
    public IServerChannelSink NextChannelSink { get; }
    public IDictionary Properties { get; }
    public UnixServerTransportSink(IServerChannelSink next);
    public sealed virtual IServerChannelSink get_NextChannelSink();
    public sealed virtual IDictionary get_Properties();
    public sealed virtual void AsyncProcessResponse(IServerResponseChannelSinkStack sinkStack, object state, IMessage msg, ITransportHeaders headers, Stream responseStream);
    public sealed virtual Stream GetResponseStream(IServerResponseChannelSinkStack sinkStack, object state, IMessage msg, ITransportHeaders headers);
    public sealed virtual ServerProcessing ProcessMessage(IServerChannelSinkStack sinkStack, IMessage requestMsg, ITransportHeaders requestHeaders, Stream requestStream, IMessage& responseMsg, ITransportHeaders& responseHeaders, Stream& responseStream);
    internal void InternalProcessMessage(ClientConnection connection, Stream stream);
}
internal static class Mono.Security.Cryptography.CryptoConvert : object {
    private static int ToInt32LE(Byte[] bytes, int offset);
    private static UInt32 ToUInt32LE(Byte[] bytes, int offset);
    private static Byte[] Trim(Byte[] array);
    private static RSA FromCapiPrivateKeyBlob(Byte[] blob, int offset);
    private static RSA FromCapiPublicKeyBlob(Byte[] blob, int offset);
    public static RSA FromCapiKeyBlob(Byte[] blob);
    public static RSA FromCapiKeyBlob(Byte[] blob, int offset);
}
public class Mono.Unix.AbstractUnixEndPoint : EndPoint {
    private string path;
    public string Path { get; public set; }
    public AddressFamily AddressFamily { get; }
    public AbstractUnixEndPoint(string path);
    public string get_Path();
    public void set_Path(string value);
    public virtual AddressFamily get_AddressFamily();
    public virtual EndPoint Create(SocketAddress socketAddress);
    public virtual SocketAddress Serialize();
    public virtual string ToString();
    public virtual int GetHashCode();
    public virtual bool Equals(object o);
}
public class Mono.Unix.Catalog : object {
    private static IntPtr bindtextdomain(IntPtr domainname, IntPtr dirname);
    private static IntPtr bind_textdomain_codeset(IntPtr domainname, IntPtr codeset);
    private static IntPtr textdomain(IntPtr domainname);
    public static void Init(string package, string localedir);
    private static void MarshalStrings(string s1, IntPtr& p1, string s2, IntPtr& p2, string s3, IntPtr& p3);
    private static IntPtr gettext(IntPtr instring);
    public static string GetString(string s);
    private static IntPtr ngettext(IntPtr singular, IntPtr plural, int n);
    public static string GetPluralString(string s, string p, int n);
}
internal class Mono.Unix.ErrorMarshal : object {
    internal static ErrorTranslator Translate;
    private static ErrorMarshal();
    private static string strerror(Errno errno);
    private static string strerror_r(Errno errno);
}
public enum Mono.Unix.FileAccessPattern : Enum {
    public int value__;
    public static FileAccessPattern Normal;
    public static FileAccessPattern Sequential;
    public static FileAccessPattern Random;
    public static FileAccessPattern NoReuse;
    public static FileAccessPattern PreLoad;
    public static FileAccessPattern FlushCache;
}
[FlagsAttribute]
public enum Mono.Unix.FileAccessPermissions : Enum {
    public int value__;
    public static FileAccessPermissions UserReadWriteExecute;
    public static FileAccessPermissions UserRead;
    public static FileAccessPermissions UserWrite;
    public static FileAccessPermissions UserExecute;
    public static FileAccessPermissions GroupReadWriteExecute;
    public static FileAccessPermissions GroupRead;
    public static FileAccessPermissions GroupWrite;
    public static FileAccessPermissions GroupExecute;
    public static FileAccessPermissions OtherReadWriteExecute;
    public static FileAccessPermissions OtherRead;
    public static FileAccessPermissions OtherWrite;
    public static FileAccessPermissions OtherExecute;
    public static FileAccessPermissions DefaultPermissions;
    public static FileAccessPermissions AllPermissions;
}
public class Mono.Unix.FileHandleOperations : object {
    public static void AdviseFileAccessPattern(int fd, FileAccessPattern pattern, long offset, long len);
    public static void AdviseFileAccessPattern(int fd, FileAccessPattern pattern);
    public static void AdviseFileAccessPattern(FileStream file, FileAccessPattern pattern, long offset, long len);
    public static void AdviseFileAccessPattern(FileStream file, FileAccessPattern pattern);
    public static void AdviseFileAccessPattern(UnixStream stream, FileAccessPattern pattern, long offset, long len);
    public static void AdviseFileAccessPattern(UnixStream stream, FileAccessPattern pattern);
}
[FlagsAttribute]
public enum Mono.Unix.FileSpecialAttributes : Enum {
    public int value__;
    public static FileSpecialAttributes SetUserId;
    public static FileSpecialAttributes SetGroupId;
    public static FileSpecialAttributes Sticky;
}
public enum Mono.Unix.FileTypes : Enum {
    public int value__;
    public static FileTypes Directory;
    public static FileTypes CharacterDevice;
    public static FileTypes BlockDevice;
    public static FileTypes RegularFile;
    public static FileTypes Fifo;
    public static FileTypes SymbolicLink;
    public static FileTypes Socket;
}
[CLSCompliantAttribute("False")]
[MapAttribute]
[FlagsAttribute]
public enum Mono.Unix.Native.AccessModes : Enum {
    public int value__;
    public static AccessModes R_OK;
    public static AccessModes W_OK;
    public static AccessModes X_OK;
    public static AccessModes F_OK;
}
[AttributeUsageAttribute("256")]
internal class Mono.Unix.Native.blkcnt_tAttribute : MapAttribute {
}
[AttributeUsageAttribute("256")]
internal class Mono.Unix.Native.blksize_tAttribute : MapAttribute {
}
public class Mono.Unix.Native.CdeclFunction : object {
    private string library;
    private string method;
    private Type returnType;
    private AssemblyName assemblyName;
    private AssemblyBuilder assemblyBuilder;
    private ModuleBuilder moduleBuilder;
    private Hashtable overloads;
    public CdeclFunction(string library, string method);
    public CdeclFunction(string library, string method, Type returnType);
    public object Invoke(Object[] parameters);
    private MethodInfo CreateMethod(Type[] parameterTypes);
    private TypeBuilder CreateType(string typeName);
    private static Type GetMarshalType(Type t);
    private string GetTypeName(Type[] parameterTypes);
    private static Type[] GetParameterTypes(Object[] parameters);
}
[MapAttribute]
[CLSCompliantAttribute("False")]
public enum Mono.Unix.Native.ConfstrName : Enum {
    public int value__;
    public static ConfstrName _CS_PATH;
    public static ConfstrName _CS_V6_WIDTH_RESTRICTED_ENVS;
    public static ConfstrName _CS_GNU_LIBC_VERSION;
    public static ConfstrName _CS_GNU_LIBPTHREAD_VERSION;
    public static ConfstrName _CS_LFS_CFLAGS;
    public static ConfstrName _CS_LFS_LDFLAGS;
    public static ConfstrName _CS_LFS_LIBS;
    public static ConfstrName _CS_LFS_LINTFLAGS;
    public static ConfstrName _CS_LFS64_CFLAGS;
    public static ConfstrName _CS_LFS64_LDFLAGS;
    public static ConfstrName _CS_LFS64_LIBS;
    public static ConfstrName _CS_LFS64_LINTFLAGS;
    public static ConfstrName _CS_XBS5_ILP32_OFF32_CFLAGS;
    public static ConfstrName _CS_XBS5_ILP32_OFF32_LDFLAGS;
    public static ConfstrName _CS_XBS5_ILP32_OFF32_LIBS;
    public static ConfstrName _CS_XBS5_ILP32_OFF32_LINTFLAGS;
    public static ConfstrName _CS_XBS5_ILP32_OFFBIG_CFLAGS;
    public static ConfstrName _CS_XBS5_ILP32_OFFBIG_LDFLAGS;
    public static ConfstrName _CS_XBS5_ILP32_OFFBIG_LIBS;
    public static ConfstrName _CS_XBS5_ILP32_OFFBIG_LINTFLAGS;
    public static ConfstrName _CS_XBS5_LP64_OFF64_CFLAGS;
    public static ConfstrName _CS_XBS5_LP64_OFF64_LDFLAGS;
    public static ConfstrName _CS_XBS5_LP64_OFF64_LIBS;
    public static ConfstrName _CS_XBS5_LP64_OFF64_LINTFLAGS;
    public static ConfstrName _CS_XBS5_LPBIG_OFFBIG_CFLAGS;
    public static ConfstrName _CS_XBS5_LPBIG_OFFBIG_LDFLAGS;
    public static ConfstrName _CS_XBS5_LPBIG_OFFBIG_LIBS;
    public static ConfstrName _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS;
    public static ConfstrName _CS_POSIX_V6_ILP32_OFF32_CFLAGS;
    public static ConfstrName _CS_POSIX_V6_ILP32_OFF32_LDFLAGS;
    public static ConfstrName _CS_POSIX_V6_ILP32_OFF32_LIBS;
    public static ConfstrName _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS;
    public static ConfstrName _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS;
    public static ConfstrName _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS;
    public static ConfstrName _CS_POSIX_V6_ILP32_OFFBIG_LIBS;
    public static ConfstrName _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS;
    public static ConfstrName _CS_POSIX_V6_LP64_OFF64_CFLAGS;
    public static ConfstrName _CS_POSIX_V6_LP64_OFF64_LDFLAGS;
    public static ConfstrName _CS_POSIX_V6_LP64_OFF64_LIBS;
    public static ConfstrName _CS_POSIX_V6_LP64_OFF64_LINTFLAGS;
    public static ConfstrName _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS;
    public static ConfstrName _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS;
    public static ConfstrName _CS_POSIX_V6_LPBIG_OFFBIG_LIBS;
    public static ConfstrName _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS;
}
[AttributeUsageAttribute("256")]
internal class Mono.Unix.Native.dev_tAttribute : MapAttribute {
}
[CLSCompliantAttribute("False")]
[FlagsAttribute]
[MapAttribute]
public enum Mono.Unix.Native.DirectoryNotifyFlags : Enum {
    public int value__;
    public static DirectoryNotifyFlags DN_ACCESS;
    public static DirectoryNotifyFlags DN_MODIFY;
    public static DirectoryNotifyFlags DN_CREATE;
    public static DirectoryNotifyFlags DN_DELETE;
    public static DirectoryNotifyFlags DN_RENAME;
    public static DirectoryNotifyFlags DN_ATTRIB;
    public static DirectoryNotifyFlags DN_MULTISHOT;
}
public class Mono.Unix.Native.Dirent : object {
    [CLSCompliantAttribute("False")]
public ulong d_ino;
    public long d_off;
    [CLSCompliantAttribute("False")]
public ushort d_reclen;
    public byte d_type;
    public string d_name;
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Dirent value);
    public virtual string ToString();
    public static bool op_Equality(Dirent lhs, Dirent rhs);
    public static bool op_Inequality(Dirent lhs, Dirent rhs);
}
[MapAttribute]
public enum Mono.Unix.Native.Errno : Enum {
    public int value__;
    public static Errno EPERM;
    public static Errno ENOENT;
    public static Errno ESRCH;
    public static Errno EINTR;
    public static Errno EIO;
    public static Errno ENXIO;
    public static Errno E2BIG;
    public static Errno ENOEXEC;
    public static Errno EBADF;
    public static Errno ECHILD;
    public static Errno EAGAIN;
    public static Errno ENOMEM;
    public static Errno EACCES;
    public static Errno EFAULT;
    public static Errno ENOTBLK;
    public static Errno EBUSY;
    public static Errno EEXIST;
    public static Errno EXDEV;
    public static Errno ENODEV;
    public static Errno ENOTDIR;
    public static Errno EISDIR;
    public static Errno EINVAL;
    public static Errno ENFILE;
    public static Errno EMFILE;
    public static Errno ENOTTY;
    public static Errno ETXTBSY;
    public static Errno EFBIG;
    public static Errno ENOSPC;
    public static Errno ESPIPE;
    public static Errno EROFS;
    public static Errno EMLINK;
    public static Errno EPIPE;
    public static Errno EDOM;
    public static Errno ERANGE;
    public static Errno EDEADLK;
    public static Errno ENAMETOOLONG;
    public static Errno ENOLCK;
    public static Errno ENOSYS;
    public static Errno ENOTEMPTY;
    public static Errno ELOOP;
    public static Errno EWOULDBLOCK;
    public static Errno ENOMSG;
    public static Errno EIDRM;
    public static Errno ECHRNG;
    public static Errno EL2NSYNC;
    public static Errno EL3HLT;
    public static Errno EL3RST;
    public static Errno ELNRNG;
    public static Errno EUNATCH;
    public static Errno ENOCSI;
    public static Errno EL2HLT;
    public static Errno EBADE;
    public static Errno EBADR;
    public static Errno EXFULL;
    public static Errno ENOANO;
    public static Errno EBADRQC;
    public static Errno EBADSLT;
    public static Errno EDEADLOCK;
    public static Errno EBFONT;
    public static Errno ENOSTR;
    public static Errno ENODATA;
    public static Errno ETIME;
    public static Errno ENOSR;
    public static Errno ENONET;
    public static Errno ENOPKG;
    public static Errno EREMOTE;
    public static Errno ENOLINK;
    public static Errno EADV;
    public static Errno ESRMNT;
    public static Errno ECOMM;
    public static Errno EPROTO;
    public static Errno EMULTIHOP;
    public static Errno EDOTDOT;
    public static Errno EBADMSG;
    public static Errno EOVERFLOW;
    public static Errno ENOTUNIQ;
    public static Errno EBADFD;
    public static Errno EREMCHG;
    public static Errno ELIBACC;
    public static Errno ELIBBAD;
    public static Errno ELIBSCN;
    public static Errno ELIBMAX;
    public static Errno ELIBEXEC;
    public static Errno EILSEQ;
    public static Errno ERESTART;
    public static Errno ESTRPIPE;
    public static Errno EUSERS;
    public static Errno ENOTSOCK;
    public static Errno EDESTADDRREQ;
    public static Errno EMSGSIZE;
    public static Errno EPROTOTYPE;
    public static Errno ENOPROTOOPT;
    public static Errno EPROTONOSUPPORT;
    public static Errno ESOCKTNOSUPPORT;
    public static Errno EOPNOTSUPP;
    public static Errno EPFNOSUPPORT;
    public static Errno EAFNOSUPPORT;
    public static Errno EADDRINUSE;
    public static Errno EADDRNOTAVAIL;
    public static Errno ENETDOWN;
    public static Errno ENETUNREACH;
    public static Errno ENETRESET;
    public static Errno ECONNABORTED;
    public static Errno ECONNRESET;
    public static Errno ENOBUFS;
    public static Errno EISCONN;
    public static Errno ENOTCONN;
    public static Errno ESHUTDOWN;
    public static Errno ETOOMANYREFS;
    public static Errno ETIMEDOUT;
    public static Errno ECONNREFUSED;
    public static Errno EHOSTDOWN;
    public static Errno EHOSTUNREACH;
    public static Errno EALREADY;
    public static Errno EINPROGRESS;
    public static Errno ESTALE;
    public static Errno EUCLEAN;
    public static Errno ENOTNAM;
    public static Errno ENAVAIL;
    public static Errno EISNAM;
    public static Errno EREMOTEIO;
    public static Errno EDQUOT;
    public static Errno ENOMEDIUM;
    public static Errno EMEDIUMTYPE;
}
[CLSCompliantAttribute("False")]
[MapAttribute]
public enum Mono.Unix.Native.FcntlCommand : Enum {
    public int value__;
    public static FcntlCommand F_DUPFD;
    public static FcntlCommand F_GETFD;
    public static FcntlCommand F_SETFD;
    public static FcntlCommand F_GETFL;
    public static FcntlCommand F_SETFL;
    public static FcntlCommand F_GETLK;
    public static FcntlCommand F_SETLK;
    public static FcntlCommand F_SETLKW;
    public static FcntlCommand F_SETOWN;
    public static FcntlCommand F_GETOWN;
    public static FcntlCommand F_SETSIG;
    public static FcntlCommand F_GETSIG;
    public static FcntlCommand F_SETLEASE;
    public static FcntlCommand F_GETLEASE;
    public static FcntlCommand F_NOTIFY;
}
internal class Mono.Unix.Native.FileNameMarshaler : object {
    private static FileNameMarshaler Instance;
    private static FileNameMarshaler();
    public static ICustomMarshaler GetInstance(string s);
    public sealed virtual void CleanUpManagedData(object o);
    public sealed virtual void CleanUpNativeData(IntPtr pNativeData);
    public sealed virtual int GetNativeDataSize();
    public sealed virtual IntPtr MarshalManagedToNative(object obj);
    public sealed virtual object MarshalNativeToManaged(IntPtr pNativeData);
}
[CLSCompliantAttribute("False")]
[FlagsAttribute]
[MapAttribute]
public enum Mono.Unix.Native.FilePermissions : Enum {
    public UInt32 value__;
    public static FilePermissions S_ISUID;
    public static FilePermissions S_ISGID;
    public static FilePermissions S_ISVTX;
    public static FilePermissions S_IRUSR;
    public static FilePermissions S_IWUSR;
    public static FilePermissions S_IXUSR;
    public static FilePermissions S_IRGRP;
    public static FilePermissions S_IWGRP;
    public static FilePermissions S_IXGRP;
    public static FilePermissions S_IROTH;
    public static FilePermissions S_IWOTH;
    public static FilePermissions S_IXOTH;
    public static FilePermissions S_IRWXG;
    public static FilePermissions S_IRWXU;
    public static FilePermissions S_IRWXO;
    public static FilePermissions ACCESSPERMS;
    public static FilePermissions ALLPERMS;
    public static FilePermissions DEFFILEMODE;
    public static FilePermissions S_IFMT;
    [MapAttribute]
public static FilePermissions S_IFDIR;
    [MapAttribute]
public static FilePermissions S_IFCHR;
    [MapAttribute]
public static FilePermissions S_IFBLK;
    [MapAttribute]
public static FilePermissions S_IFREG;
    [MapAttribute]
public static FilePermissions S_IFIFO;
    [MapAttribute]
public static FilePermissions S_IFLNK;
    [MapAttribute]
public static FilePermissions S_IFSOCK;
}
public class Mono.Unix.Native.FilePosition : MarshalByRefObject {
    private static int FilePositionDumpSize;
    private HandleRef pos;
    internal HandleRef Handle { get; }
    private static FilePosition();
    internal HandleRef get_Handle();
    public sealed virtual void Dispose();
    private void Cleanup();
    public virtual string ToString();
    private string GetDump();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(FilePosition value);
    public virtual int GetHashCode();
    protected virtual void Finalize();
    public static bool op_Equality(FilePosition lhs, FilePosition rhs);
    public static bool op_Inequality(FilePosition lhs, FilePosition rhs);
}
[MapAttribute("struct flock")]
public class Mono.Unix.Native.Flock : ValueType {
    [CLSCompliantAttribute("False")]
public LockType l_type;
    [CLSCompliantAttribute("False")]
public SeekFlags l_whence;
    [off_tAttribute]
public long l_start;
    [off_tAttribute]
public long l_len;
    [pid_tAttribute]
public int l_pid;
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Flock value);
    public static bool op_Equality(Flock lhs, Flock rhs);
    public static bool op_Inequality(Flock lhs, Flock rhs);
}
[AttributeUsageAttribute("256")]
internal class Mono.Unix.Native.fsblkcnt_tAttribute : MapAttribute {
}
[AttributeUsageAttribute("256")]
internal class Mono.Unix.Native.fsfilcnt_tAttribute : MapAttribute {
}
public class Mono.Unix.Native.Fstab : object {
    public string fs_spec;
    public string fs_file;
    public string fs_vfstype;
    public string fs_mntops;
    public string fs_type;
    public int fs_freq;
    public int fs_passno;
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Fstab value);
    public virtual string ToString();
    public static bool op_Equality(Fstab lhs, Fstab rhs);
    public static bool op_Inequality(Fstab lhs, Fstab rhs);
}
[AttributeUsageAttribute("256")]
internal class Mono.Unix.Native.gid_tAttribute : MapAttribute {
}
public class Mono.Unix.Native.Group : object {
    public string gr_name;
    public string gr_passwd;
    [CLSCompliantAttribute("False")]
public UInt32 gr_gid;
    public String[] gr_mem;
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Group value);
    public virtual string ToString();
    private static void GetMembers(StringBuilder sb, String[] members);
    public static bool op_Equality(Group lhs, Group rhs);
    public static bool op_Inequality(Group lhs, Group rhs);
}
[AttributeUsageAttribute("256")]
internal class Mono.Unix.Native.ino_tAttribute : MapAttribute {
}
[CLSCompliantAttribute("False")]
[MapAttribute]
public enum Mono.Unix.Native.LockfCommand : Enum {
    public int value__;
    public static LockfCommand F_ULOCK;
    public static LockfCommand F_LOCK;
    public static LockfCommand F_TLOCK;
    public static LockfCommand F_TEST;
}
[MapAttribute]
[CLSCompliantAttribute("False")]
public enum Mono.Unix.Native.LockType : Enum {
    public short value__;
    public static LockType F_RDLCK;
    public static LockType F_WRLCK;
    public static LockType F_UNLCK;
}
[CLSCompliantAttribute("False")]
[FlagsAttribute]
[MapAttribute]
public enum Mono.Unix.Native.MlockallFlags : Enum {
    public int value__;
    public static MlockallFlags MCL_CURRENT;
    public static MlockallFlags MCL_FUTURE;
}
[MapAttribute]
[FlagsAttribute]
[CLSCompliantAttribute("False")]
public enum Mono.Unix.Native.MmapFlags : Enum {
    public int value__;
    public static MmapFlags MAP_SHARED;
    public static MmapFlags MAP_PRIVATE;
    public static MmapFlags MAP_TYPE;
    public static MmapFlags MAP_FIXED;
    public static MmapFlags MAP_FILE;
    public static MmapFlags MAP_ANONYMOUS;
    public static MmapFlags MAP_ANON;
    public static MmapFlags MAP_GROWSDOWN;
    public static MmapFlags MAP_DENYWRITE;
    public static MmapFlags MAP_EXECUTABLE;
    public static MmapFlags MAP_LOCKED;
    public static MmapFlags MAP_NORESERVE;
    public static MmapFlags MAP_POPULATE;
    public static MmapFlags MAP_NONBLOCK;
}
[CLSCompliantAttribute("False")]
[MapAttribute]
[FlagsAttribute]
public enum Mono.Unix.Native.MmapProts : Enum {
    public int value__;
    public static MmapProts PROT_READ;
    public static MmapProts PROT_WRITE;
    public static MmapProts PROT_EXEC;
    public static MmapProts PROT_NONE;
    public static MmapProts PROT_GROWSDOWN;
    public static MmapProts PROT_GROWSUP;
}
[MapAttribute]
[FlagsAttribute]
[CLSCompliantAttribute("False")]
public enum Mono.Unix.Native.MountFlags : Enum {
    public ulong value__;
    public static MountFlags ST_RDONLY;
    public static MountFlags ST_NOSUID;
    public static MountFlags ST_NODEV;
    public static MountFlags ST_NOEXEC;
    public static MountFlags ST_SYNCHRONOUS;
    public static MountFlags ST_REMOUNT;
    public static MountFlags ST_MANDLOCK;
    public static MountFlags ST_WRITE;
    public static MountFlags ST_APPEND;
    public static MountFlags ST_IMMUTABLE;
    public static MountFlags ST_NOATIME;
    public static MountFlags ST_NODIRATIME;
    public static MountFlags ST_BIND;
}
[CLSCompliantAttribute("False")]
[MapAttribute]
[FlagsAttribute]
public enum Mono.Unix.Native.MremapFlags : Enum {
    public ulong value__;
    public static MremapFlags MREMAP_MAYMOVE;
}
[FlagsAttribute]
[CLSCompliantAttribute("False")]
[MapAttribute]
public enum Mono.Unix.Native.MsyncFlags : Enum {
    public int value__;
    public static MsyncFlags MS_ASYNC;
    public static MsyncFlags MS_SYNC;
    public static MsyncFlags MS_INVALIDATE;
}
[CLSCompliantAttribute("False")]
public class Mono.Unix.Native.NativeConvert : object {
    private static string LIB;
    public static DateTime LocalUnixEpoch;
    public static TimeSpan LocalUtcOffset;
    private static String[][] fopen_modes;
    private static NativeConvert();
    private static int FromRealTimeSignum(int offset, Int32& rval);
    public static int FromRealTimeSignum(RealTimeSignum sig);
    public static RealTimeSignum ToRealTimeSignum(int offset);
    public static FilePermissions FromOctalPermissionString(string value);
    public static string ToOctalPermissionString(FilePermissions value);
    public static FilePermissions FromUnixPermissionString(string value);
    private static FilePermissions GetUnixPermissionDevice(char value);
    private static FilePermissions GetUnixPermissionGroup(char read, FilePermissions readb, char write, FilePermissions writeb, char exec, FilePermissions execb, char xboth, char xbitonly, FilePermissions xbit);
    public static string ToUnixPermissionString(FilePermissions value);
    private static void SetUnixPermissionGroup(FilePermissions value, Char[] access, int index, FilePermissions read, FilePermissions write, FilePermissions exec, char both, char setonly, FilePermissions setxbit);
    private static char GetSymbolicMode(FilePermissions value, FilePermissions xbit, char both, char setonly, FilePermissions setxbit);
    public static DateTime ToDateTime(long time);
    public static long FromDateTime(DateTime time);
    public static DateTime FromTimeT(long time);
    public static long ToTimeT(DateTime time);
    public static OpenFlags ToOpenFlags(FileMode mode, FileAccess access);
    public static string ToFopenMode(FileAccess access);
    public static string ToFopenMode(FileMode mode);
    public static string ToFopenMode(FileMode mode, FileAccess access);
    private static int FromStatvfs(Statvfs& source, IntPtr destination);
    public static bool TryCopy(Statvfs& source, IntPtr destination);
    private static int ToStatvfs(IntPtr source, Statvfs& destination);
    public static bool TryCopy(IntPtr source, Statvfs& destination);
    private static void ThrowArgumentException(object value);
    private static int FromAccessModes(AccessModes value, Int32& rval);
    public static bool TryFromAccessModes(AccessModes value, Int32& rval);
    public static int FromAccessModes(AccessModes value);
    private static int ToAccessModes(int value, AccessModes& rval);
    public static bool TryToAccessModes(int value, AccessModes& rval);
    public static AccessModes ToAccessModes(int value);
    private static int FromConfstrName(ConfstrName value, Int32& rval);
    public static bool TryFromConfstrName(ConfstrName value, Int32& rval);
    public static int FromConfstrName(ConfstrName value);
    private static int ToConfstrName(int value, ConfstrName& rval);
    public static bool TryToConfstrName(int value, ConfstrName& rval);
    public static ConfstrName ToConfstrName(int value);
    private static int FromDirectoryNotifyFlags(DirectoryNotifyFlags value, Int32& rval);
    public static bool TryFromDirectoryNotifyFlags(DirectoryNotifyFlags value, Int32& rval);
    public static int FromDirectoryNotifyFlags(DirectoryNotifyFlags value);
    private static int ToDirectoryNotifyFlags(int value, DirectoryNotifyFlags& rval);
    public static bool TryToDirectoryNotifyFlags(int value, DirectoryNotifyFlags& rval);
    public static DirectoryNotifyFlags ToDirectoryNotifyFlags(int value);
    private static int FromErrno(Errno value, Int32& rval);
    public static bool TryFromErrno(Errno value, Int32& rval);
    public static int FromErrno(Errno value);
    private static int ToErrno(int value, Errno& rval);
    public static bool TryToErrno(int value, Errno& rval);
    public static Errno ToErrno(int value);
    private static int FromFcntlCommand(FcntlCommand value, Int32& rval);
    public static bool TryFromFcntlCommand(FcntlCommand value, Int32& rval);
    public static int FromFcntlCommand(FcntlCommand value);
    private static int ToFcntlCommand(int value, FcntlCommand& rval);
    public static bool TryToFcntlCommand(int value, FcntlCommand& rval);
    public static FcntlCommand ToFcntlCommand(int value);
    private static int FromFilePermissions(FilePermissions value, UInt32& rval);
    public static bool TryFromFilePermissions(FilePermissions value, UInt32& rval);
    public static UInt32 FromFilePermissions(FilePermissions value);
    private static int ToFilePermissions(UInt32 value, FilePermissions& rval);
    public static bool TryToFilePermissions(UInt32 value, FilePermissions& rval);
    public static FilePermissions ToFilePermissions(UInt32 value);
    private static int FromFlock(Flock& source, IntPtr destination);
    public static bool TryCopy(Flock& source, IntPtr destination);
    private static int ToFlock(IntPtr source, Flock& destination);
    public static bool TryCopy(IntPtr source, Flock& destination);
    private static int FromLockType(LockType value, Int16& rval);
    public static bool TryFromLockType(LockType value, Int16& rval);
    public static short FromLockType(LockType value);
    private static int ToLockType(short value, LockType& rval);
    public static bool TryToLockType(short value, LockType& rval);
    public static LockType ToLockType(short value);
    private static int FromLockfCommand(LockfCommand value, Int32& rval);
    public static bool TryFromLockfCommand(LockfCommand value, Int32& rval);
    public static int FromLockfCommand(LockfCommand value);
    private static int ToLockfCommand(int value, LockfCommand& rval);
    public static bool TryToLockfCommand(int value, LockfCommand& rval);
    public static LockfCommand ToLockfCommand(int value);
    private static int FromMlockallFlags(MlockallFlags value, Int32& rval);
    public static bool TryFromMlockallFlags(MlockallFlags value, Int32& rval);
    public static int FromMlockallFlags(MlockallFlags value);
    private static int ToMlockallFlags(int value, MlockallFlags& rval);
    public static bool TryToMlockallFlags(int value, MlockallFlags& rval);
    public static MlockallFlags ToMlockallFlags(int value);
    private static int FromMmapFlags(MmapFlags value, Int32& rval);
    public static bool TryFromMmapFlags(MmapFlags value, Int32& rval);
    public static int FromMmapFlags(MmapFlags value);
    private static int ToMmapFlags(int value, MmapFlags& rval);
    public static bool TryToMmapFlags(int value, MmapFlags& rval);
    public static MmapFlags ToMmapFlags(int value);
    private static int FromMmapProts(MmapProts value, Int32& rval);
    public static bool TryFromMmapProts(MmapProts value, Int32& rval);
    public static int FromMmapProts(MmapProts value);
    private static int ToMmapProts(int value, MmapProts& rval);
    public static bool TryToMmapProts(int value, MmapProts& rval);
    public static MmapProts ToMmapProts(int value);
    private static int FromMountFlags(MountFlags value, UInt64& rval);
    public static bool TryFromMountFlags(MountFlags value, UInt64& rval);
    public static ulong FromMountFlags(MountFlags value);
    private static int ToMountFlags(ulong value, MountFlags& rval);
    public static bool TryToMountFlags(ulong value, MountFlags& rval);
    public static MountFlags ToMountFlags(ulong value);
    private static int FromMremapFlags(MremapFlags value, UInt64& rval);
    public static bool TryFromMremapFlags(MremapFlags value, UInt64& rval);
    public static ulong FromMremapFlags(MremapFlags value);
    private static int ToMremapFlags(ulong value, MremapFlags& rval);
    public static bool TryToMremapFlags(ulong value, MremapFlags& rval);
    public static MremapFlags ToMremapFlags(ulong value);
    private static int FromMsyncFlags(MsyncFlags value, Int32& rval);
    public static bool TryFromMsyncFlags(MsyncFlags value, Int32& rval);
    public static int FromMsyncFlags(MsyncFlags value);
    private static int ToMsyncFlags(int value, MsyncFlags& rval);
    public static bool TryToMsyncFlags(int value, MsyncFlags& rval);
    public static MsyncFlags ToMsyncFlags(int value);
    private static int FromOpenFlags(OpenFlags value, Int32& rval);
    public static bool TryFromOpenFlags(OpenFlags value, Int32& rval);
    public static int FromOpenFlags(OpenFlags value);
    private static int ToOpenFlags(int value, OpenFlags& rval);
    public static bool TryToOpenFlags(int value, OpenFlags& rval);
    public static OpenFlags ToOpenFlags(int value);
    private static int FromPathconfName(PathconfName value, Int32& rval);
    public static bool TryFromPathconfName(PathconfName value, Int32& rval);
    public static int FromPathconfName(PathconfName value);
    private static int ToPathconfName(int value, PathconfName& rval);
    public static bool TryToPathconfName(int value, PathconfName& rval);
    public static PathconfName ToPathconfName(int value);
    private static int FromPollEvents(PollEvents value, Int16& rval);
    public static bool TryFromPollEvents(PollEvents value, Int16& rval);
    public static short FromPollEvents(PollEvents value);
    private static int ToPollEvents(short value, PollEvents& rval);
    public static bool TryToPollEvents(short value, PollEvents& rval);
    public static PollEvents ToPollEvents(short value);
    private static int FromPollfd(Pollfd& source, IntPtr destination);
    public static bool TryCopy(Pollfd& source, IntPtr destination);
    private static int ToPollfd(IntPtr source, Pollfd& destination);
    public static bool TryCopy(IntPtr source, Pollfd& destination);
    private static int FromPosixFadviseAdvice(PosixFadviseAdvice value, Int32& rval);
    public static bool TryFromPosixFadviseAdvice(PosixFadviseAdvice value, Int32& rval);
    public static int FromPosixFadviseAdvice(PosixFadviseAdvice value);
    private static int ToPosixFadviseAdvice(int value, PosixFadviseAdvice& rval);
    public static bool TryToPosixFadviseAdvice(int value, PosixFadviseAdvice& rval);
    public static PosixFadviseAdvice ToPosixFadviseAdvice(int value);
    private static int FromPosixMadviseAdvice(PosixMadviseAdvice value, Int32& rval);
    public static bool TryFromPosixMadviseAdvice(PosixMadviseAdvice value, Int32& rval);
    public static int FromPosixMadviseAdvice(PosixMadviseAdvice value);
    private static int ToPosixMadviseAdvice(int value, PosixMadviseAdvice& rval);
    public static bool TryToPosixMadviseAdvice(int value, PosixMadviseAdvice& rval);
    public static PosixMadviseAdvice ToPosixMadviseAdvice(int value);
    private static int FromSeekFlags(SeekFlags value, Int16& rval);
    public static bool TryFromSeekFlags(SeekFlags value, Int16& rval);
    public static short FromSeekFlags(SeekFlags value);
    private static int ToSeekFlags(short value, SeekFlags& rval);
    public static bool TryToSeekFlags(short value, SeekFlags& rval);
    public static SeekFlags ToSeekFlags(short value);
    private static int FromSignum(Signum value, Int32& rval);
    public static bool TryFromSignum(Signum value, Int32& rval);
    public static int FromSignum(Signum value);
    private static int ToSignum(int value, Signum& rval);
    public static bool TryToSignum(int value, Signum& rval);
    public static Signum ToSignum(int value);
    private static int FromStat(Stat& source, IntPtr destination);
    public static bool TryCopy(Stat& source, IntPtr destination);
    private static int ToStat(IntPtr source, Stat& destination);
    public static bool TryCopy(IntPtr source, Stat& destination);
    private static int FromSysconfName(SysconfName value, Int32& rval);
    public static bool TryFromSysconfName(SysconfName value, Int32& rval);
    public static int FromSysconfName(SysconfName value);
    private static int ToSysconfName(int value, SysconfName& rval);
    public static bool TryToSysconfName(int value, SysconfName& rval);
    public static SysconfName ToSysconfName(int value);
    private static int FromSyslogFacility(SyslogFacility value, Int32& rval);
    public static bool TryFromSyslogFacility(SyslogFacility value, Int32& rval);
    public static int FromSyslogFacility(SyslogFacility value);
    private static int ToSyslogFacility(int value, SyslogFacility& rval);
    public static bool TryToSyslogFacility(int value, SyslogFacility& rval);
    public static SyslogFacility ToSyslogFacility(int value);
    private static int FromSyslogLevel(SyslogLevel value, Int32& rval);
    public static bool TryFromSyslogLevel(SyslogLevel value, Int32& rval);
    public static int FromSyslogLevel(SyslogLevel value);
    private static int ToSyslogLevel(int value, SyslogLevel& rval);
    public static bool TryToSyslogLevel(int value, SyslogLevel& rval);
    public static SyslogLevel ToSyslogLevel(int value);
    private static int FromSyslogOptions(SyslogOptions value, Int32& rval);
    public static bool TryFromSyslogOptions(SyslogOptions value, Int32& rval);
    public static int FromSyslogOptions(SyslogOptions value);
    private static int ToSyslogOptions(int value, SyslogOptions& rval);
    public static bool TryToSyslogOptions(int value, SyslogOptions& rval);
    public static SyslogOptions ToSyslogOptions(int value);
    private static int FromTimespec(Timespec& source, IntPtr destination);
    public static bool TryCopy(Timespec& source, IntPtr destination);
    private static int ToTimespec(IntPtr source, Timespec& destination);
    public static bool TryCopy(IntPtr source, Timespec& destination);
    private static int FromTimeval(Timeval& source, IntPtr destination);
    public static bool TryCopy(Timeval& source, IntPtr destination);
    private static int ToTimeval(IntPtr source, Timeval& destination);
    public static bool TryCopy(IntPtr source, Timeval& destination);
    private static int FromTimezone(Timezone& source, IntPtr destination);
    public static bool TryCopy(Timezone& source, IntPtr destination);
    private static int ToTimezone(IntPtr source, Timezone& destination);
    public static bool TryCopy(IntPtr source, Timezone& destination);
    private static int FromUtimbuf(Utimbuf& source, IntPtr destination);
    public static bool TryCopy(Utimbuf& source, IntPtr destination);
    private static int ToUtimbuf(IntPtr source, Utimbuf& destination);
    public static bool TryCopy(IntPtr source, Utimbuf& destination);
    private static int FromWaitOptions(WaitOptions value, Int32& rval);
    public static bool TryFromWaitOptions(WaitOptions value, Int32& rval);
    public static int FromWaitOptions(WaitOptions value);
    private static int ToWaitOptions(int value, WaitOptions& rval);
    public static bool TryToWaitOptions(int value, WaitOptions& rval);
    public static WaitOptions ToWaitOptions(int value);
    private static int FromXattrFlags(XattrFlags value, Int32& rval);
    public static bool TryFromXattrFlags(XattrFlags value, Int32& rval);
    public static int FromXattrFlags(XattrFlags value);
    private static int ToXattrFlags(int value, XattrFlags& rval);
    public static bool TryToXattrFlags(int value, XattrFlags& rval);
    public static XattrFlags ToXattrFlags(int value);
}
[AttributeUsageAttribute("256")]
internal class Mono.Unix.Native.nlink_tAttribute : MapAttribute {
}
[AttributeUsageAttribute("256")]
internal class Mono.Unix.Native.off_tAttribute : MapAttribute {
}
[MapAttribute]
[CLSCompliantAttribute("False")]
[FlagsAttribute]
public enum Mono.Unix.Native.OpenFlags : Enum {
    public int value__;
    public static OpenFlags O_RDONLY;
    public static OpenFlags O_WRONLY;
    public static OpenFlags O_RDWR;
    public static OpenFlags O_CREAT;
    public static OpenFlags O_EXCL;
    public static OpenFlags O_NOCTTY;
    public static OpenFlags O_TRUNC;
    public static OpenFlags O_APPEND;
    public static OpenFlags O_NONBLOCK;
    public static OpenFlags O_SYNC;
    public static OpenFlags O_NOFOLLOW;
    public static OpenFlags O_DIRECTORY;
    public static OpenFlags O_DIRECT;
    public static OpenFlags O_ASYNC;
    public static OpenFlags O_LARGEFILE;
}
public class Mono.Unix.Native.Passwd : object {
    public string pw_name;
    public string pw_passwd;
    [CLSCompliantAttribute("False")]
public UInt32 pw_uid;
    [CLSCompliantAttribute("False")]
public UInt32 pw_gid;
    public string pw_gecos;
    public string pw_dir;
    public string pw_shell;
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Passwd value);
    public virtual string ToString();
    public static bool op_Equality(Passwd lhs, Passwd rhs);
    public static bool op_Inequality(Passwd lhs, Passwd rhs);
}
[MapAttribute]
[CLSCompliantAttribute("False")]
public enum Mono.Unix.Native.PathconfName : Enum {
    public int value__;
    public static PathconfName _PC_LINK_MAX;
    public static PathconfName _PC_MAX_CANON;
    public static PathconfName _PC_MAX_INPUT;
    public static PathconfName _PC_NAME_MAX;
    public static PathconfName _PC_PATH_MAX;
    public static PathconfName _PC_PIPE_BUF;
    public static PathconfName _PC_CHOWN_RESTRICTED;
    public static PathconfName _PC_NO_TRUNC;
    public static PathconfName _PC_VDISABLE;
    public static PathconfName _PC_SYNC_IO;
    public static PathconfName _PC_ASYNC_IO;
    public static PathconfName _PC_PRIO_IO;
    public static PathconfName _PC_SOCK_MAXBUF;
    public static PathconfName _PC_FILESIZEBITS;
    public static PathconfName _PC_REC_INCR_XFER_SIZE;
    public static PathconfName _PC_REC_MAX_XFER_SIZE;
    public static PathconfName _PC_REC_MIN_XFER_SIZE;
    public static PathconfName _PC_REC_XFER_ALIGN;
    public static PathconfName _PC_ALLOC_SIZE_MIN;
    public static PathconfName _PC_SYMLINK_MAX;
    public static PathconfName _PC_2_SYMLINKS;
}
[AttributeUsageAttribute("256")]
internal class Mono.Unix.Native.pid_tAttribute : MapAttribute {
}
[MapAttribute]
[FlagsAttribute]
public enum Mono.Unix.Native.PollEvents : Enum {
    public short value__;
    public static PollEvents POLLIN;
    public static PollEvents POLLPRI;
    public static PollEvents POLLOUT;
    public static PollEvents POLLERR;
    public static PollEvents POLLHUP;
    public static PollEvents POLLNVAL;
    public static PollEvents POLLRDNORM;
    public static PollEvents POLLRDBAND;
    public static PollEvents POLLWRNORM;
    public static PollEvents POLLWRBAND;
}
[MapAttribute("struct pollfd")]
public class Mono.Unix.Native.Pollfd : ValueType {
    public int fd;
    [CLSCompliantAttribute("False")]
public PollEvents events;
    [CLSCompliantAttribute("False")]
public PollEvents revents;
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Pollfd value);
    public static bool op_Equality(Pollfd lhs, Pollfd rhs);
    public static bool op_Inequality(Pollfd lhs, Pollfd rhs);
}
[MapAttribute]
[CLSCompliantAttribute("False")]
public enum Mono.Unix.Native.PosixFadviseAdvice : Enum {
    public int value__;
    public static PosixFadviseAdvice POSIX_FADV_NORMAL;
    public static PosixFadviseAdvice POSIX_FADV_RANDOM;
    public static PosixFadviseAdvice POSIX_FADV_SEQUENTIAL;
    public static PosixFadviseAdvice POSIX_FADV_WILLNEED;
    public static PosixFadviseAdvice POSIX_FADV_DONTNEED;
    public static PosixFadviseAdvice POSIX_FADV_NOREUSE;
}
[CLSCompliantAttribute("False")]
[MapAttribute]
public enum Mono.Unix.Native.PosixMadviseAdvice : Enum {
    public int value__;
    public static PosixMadviseAdvice POSIX_MADV_NORMAL;
    public static PosixMadviseAdvice POSIX_MADV_RANDOM;
    public static PosixMadviseAdvice POSIX_MADV_SEQUENTIAL;
    public static PosixMadviseAdvice POSIX_MADV_WILLNEED;
    public static PosixMadviseAdvice POSIX_MADV_DONTNEED;
}
public class Mono.Unix.Native.RealTimeSignum : ValueType {
    private int rt_offset;
    private static int MaxOffset;
    public static RealTimeSignum MinValue;
    public static RealTimeSignum MaxValue;
    public int Offset { get; }
    public RealTimeSignum(int offset);
    private static RealTimeSignum();
    public int get_Offset();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(RealTimeSignum value);
    public static bool op_Equality(RealTimeSignum lhs, RealTimeSignum rhs);
    public static bool op_Inequality(RealTimeSignum lhs, RealTimeSignum rhs);
}
[CLSCompliantAttribute("False")]
[MapAttribute]
public enum Mono.Unix.Native.SeekFlags : Enum {
    public short value__;
    public static SeekFlags SEEK_SET;
    public static SeekFlags SEEK_CUR;
    public static SeekFlags SEEK_END;
    public static SeekFlags L_SET;
    public static SeekFlags L_INCR;
    public static SeekFlags L_XTND;
}
public enum Mono.Unix.Native.SignalAction : Enum {
    public int value__;
    public static SignalAction Default;
    public static SignalAction Ignore;
    public static SignalAction Error;
}
public class Mono.Unix.Native.SignalHandler : MulticastDelegate {
    public SignalHandler(object object, IntPtr method);
    public virtual void Invoke(int signal);
    public virtual IAsyncResult BeginInvoke(int signal, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[MapAttribute]
public enum Mono.Unix.Native.Signum : Enum {
    public int value__;
    public static Signum SIGHUP;
    public static Signum SIGINT;
    public static Signum SIGQUIT;
    public static Signum SIGILL;
    public static Signum SIGTRAP;
    public static Signum SIGABRT;
    public static Signum SIGIOT;
    public static Signum SIGBUS;
    public static Signum SIGFPE;
    public static Signum SIGKILL;
    public static Signum SIGUSR1;
    public static Signum SIGSEGV;
    public static Signum SIGUSR2;
    public static Signum SIGPIPE;
    public static Signum SIGALRM;
    public static Signum SIGTERM;
    public static Signum SIGSTKFLT;
    public static Signum SIGCLD;
    public static Signum SIGCHLD;
    public static Signum SIGCONT;
    public static Signum SIGSTOP;
    public static Signum SIGTSTP;
    public static Signum SIGTTIN;
    public static Signum SIGTTOU;
    public static Signum SIGURG;
    public static Signum SIGXCPU;
    public static Signum SIGXFSZ;
    public static Signum SIGVTALRM;
    public static Signum SIGPROF;
    public static Signum SIGWINCH;
    public static Signum SIGPOLL;
    public static Signum SIGIO;
    public static Signum SIGPWR;
    public static Signum SIGSYS;
    public static Signum SIGUNUSED;
}
[MapAttribute("struct stat")]
public class Mono.Unix.Native.Stat : ValueType {
    [dev_tAttribute]
[CLSCompliantAttribute("False")]
public ulong st_dev;
    [ino_tAttribute]
[CLSCompliantAttribute("False")]
public ulong st_ino;
    [CLSCompliantAttribute("False")]
public FilePermissions st_mode;
    private UInt32 _padding_;
    [nlink_tAttribute]
[CLSCompliantAttribute("False")]
public ulong st_nlink;
    [CLSCompliantAttribute("False")]
[uid_tAttribute]
public UInt32 st_uid;
    [gid_tAttribute]
[CLSCompliantAttribute("False")]
public UInt32 st_gid;
    [CLSCompliantAttribute("False")]
[dev_tAttribute]
public ulong st_rdev;
    [off_tAttribute]
public long st_size;
    [blksize_tAttribute]
public long st_blksize;
    [blkcnt_tAttribute]
public long st_blocks;
    [time_tAttribute]
public long st_atime;
    [time_tAttribute]
public long st_mtime;
    [time_tAttribute]
public long st_ctime;
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Stat value);
    public static bool op_Equality(Stat lhs, Stat rhs);
    public static bool op_Inequality(Stat lhs, Stat rhs);
}
[CLSCompliantAttribute("False")]
[MapAttribute]
public class Mono.Unix.Native.Statvfs : ValueType {
    public ulong f_bsize;
    public ulong f_frsize;
    [fsblkcnt_tAttribute]
public ulong f_blocks;
    [fsblkcnt_tAttribute]
public ulong f_bfree;
    [fsblkcnt_tAttribute]
public ulong f_bavail;
    [fsfilcnt_tAttribute]
public ulong f_files;
    [fsfilcnt_tAttribute]
public ulong f_ffree;
    [fsfilcnt_tAttribute]
public ulong f_favail;
    public ulong f_fsid;
    public MountFlags f_flag;
    public ulong f_namemax;
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Statvfs value);
    public static bool op_Equality(Statvfs lhs, Statvfs rhs);
    public static bool op_Inequality(Statvfs lhs, Statvfs rhs);
}
public class Mono.Unix.Native.Stdlib : object {
    internal static string LIBC;
    internal static string MPH;
    private static IntPtr _SIG_DFL;
    private static IntPtr _SIG_ERR;
    private static IntPtr _SIG_IGN;
    [CLSCompliantAttribute("False")]
public static SignalHandler SIG_DFL;
    [CLSCompliantAttribute("False")]
public static SignalHandler SIG_ERR;
    [CLSCompliantAttribute("False")]
public static SignalHandler SIG_IGN;
    private static SignalHandler[] registered_signals;
    [CLSCompliantAttribute("False")]
public static int _IOFBF;
    [CLSCompliantAttribute("False")]
public static int _IOLBF;
    [CLSCompliantAttribute("False")]
public static int _IONBF;
    [CLSCompliantAttribute("False")]
public static int BUFSIZ;
    [CLSCompliantAttribute("False")]
public static int EOF;
    [CLSCompliantAttribute("False")]
public static int FOPEN_MAX;
    [CLSCompliantAttribute("False")]
public static int FILENAME_MAX;
    [CLSCompliantAttribute("False")]
public static int L_tmpnam;
    public static IntPtr stderr;
    public static IntPtr stdin;
    public static IntPtr stdout;
    [CLSCompliantAttribute("False")]
public static int TMP_MAX;
    private static object tmpnam_lock;
    [CLSCompliantAttribute("False")]
public static int EXIT_FAILURE;
    [CLSCompliantAttribute("False")]
public static int EXIT_SUCCESS;
    [CLSCompliantAttribute("False")]
public static int MB_CUR_MAX;
    [CLSCompliantAttribute("False")]
public static int RAND_MAX;
    private static object strerror_lock;
    private static Stdlib();
    public static Errno GetLastError();
    private static void SetLastError(int error);
    protected static void SetLastError(Errno error);
    internal static void InvokeSignalHandler(int signum, IntPtr handler);
    private static IntPtr GetDefaultSignal();
    private static IntPtr GetErrorSignal();
    private static IntPtr GetIgnoreSignal();
    private static void _ErrorHandler(int signum);
    private static void _DefaultHandler(int signum);
    private static void _IgnoreHandler(int signum);
    private static IntPtr sys_signal(int signum, SignalHandler handler);
    private static IntPtr sys_signal(int signum, IntPtr handler);
    [ObsoleteAttribute("This is not safe; use Mono.Unix.UnixSignal for signal delivery or SetSignalAction()")]
[CLSCompliantAttribute("False")]
public static SignalHandler signal(Signum signum, SignalHandler handler);
    private static SignalHandler TranslateHandler(IntPtr handler);
    public static int SetSignalAction(Signum signal, SignalAction action);
    public static int SetSignalAction(RealTimeSignum rts, SignalAction action);
    private static int SetSignalAction(int signum, SignalAction action);
    private static int sys_raise(int sig);
    [CLSCompliantAttribute("False")]
public static int raise(Signum sig);
    public static int raise(RealTimeSignum rts);
    private static int GetFullyBuffered();
    private static int GetLineBuffered();
    private static int GetNonBuffered();
    private static int GetBufferSize();
    internal static IntPtr CreateFilePosition();
    internal static int DumpFilePosition(StringBuilder buf, HandleRef handle, int len);
    private static int GetEOF();
    private static int GetFilenameMax();
    private static int GetFopenMax();
    private static int GetTmpnamLength();
    private static IntPtr GetStandardInput();
    private static IntPtr GetStandardOutput();
    private static IntPtr GetStandardError();
    private static int GetTmpMax();
    public static int remove(string filename);
    public static int rename(string oldpath, string newpath);
    public static IntPtr tmpfile();
    private static IntPtr sys_tmpnam(StringBuilder s);
    [ObsoleteAttribute("Syscall.mkstemp() should be preferred.")]
public static string tmpnam(StringBuilder s);
    [ObsoleteAttribute("Syscall.mkstemp() should be preferred.")]
public static string tmpnam();
    public static int fclose(IntPtr stream);
    public static int fflush(IntPtr stream);
    public static IntPtr fopen(string path, string mode);
    public static IntPtr freopen(string path, string mode, IntPtr stream);
    public static int setbuf(IntPtr stream, IntPtr buf);
    [CLSCompliantAttribute("False")]
public static int setbuf(IntPtr stream, Byte* buf);
    [CLSCompliantAttribute("False")]
public static int setvbuf(IntPtr stream, IntPtr buf, int mode, ulong size);
    [CLSCompliantAttribute("False")]
public static int setvbuf(IntPtr stream, Byte* buf, int mode, ulong size);
    private static int sys_fprintf(IntPtr stream, string format, string message);
    public static int fprintf(IntPtr stream, string message);
    [ObsoleteAttribute("Not necessarily portable due to cdecl restrictions.
Use fprintf (IntPtr, string) instead.")]
public static int fprintf(IntPtr stream, string format, Object[] parameters);
    private static int sys_printf(string format, string message);
    public static int printf(string message);
    [ObsoleteAttribute("Not necessarily portable due to cdecl restrictions.
Use printf (string) instead.")]
public static int printf(string format, Object[] parameters);
    private static int sys_snprintf(StringBuilder s, ulong n, string format, string message);
    [CLSCompliantAttribute("False")]
public static int snprintf(StringBuilder s, ulong n, string message);
    public static int snprintf(StringBuilder s, string message);
    [ObsoleteAttribute("Not necessarily portable due to cdecl restrictions.
Use snprintf (StringBuilder, string) instead.")]
[CLSCompliantAttribute("False")]
public static int snprintf(StringBuilder s, ulong n, string format, Object[] parameters);
    [CLSCompliantAttribute("False")]
[ObsoleteAttribute("Not necessarily portable due to cdecl restrictions.
Use snprintf (StringBuilder, string) instead.")]
public static int snprintf(StringBuilder s, string format, Object[] parameters);
    public static int fgetc(IntPtr stream);
    private static IntPtr sys_fgets(StringBuilder sb, int size, IntPtr stream);
    public static StringBuilder fgets(StringBuilder sb, int size, IntPtr stream);
    public static StringBuilder fgets(StringBuilder sb, IntPtr stream);
    public static int fputc(int c, IntPtr stream);
    public static int fputs(string s, IntPtr stream);
    public static int getc(IntPtr stream);
    public static int getchar();
    public static int putc(int c, IntPtr stream);
    public static int putchar(int c);
    public static int puts(string s);
    public static int ungetc(int c, IntPtr stream);
    [CLSCompliantAttribute("False")]
public static ulong fread(IntPtr ptr, ulong size, ulong nmemb, IntPtr stream);
    [CLSCompliantAttribute("False")]
public static ulong fread(Void* ptr, ulong size, ulong nmemb, IntPtr stream);
    private static ulong sys_fread(Byte[] ptr, ulong size, ulong nmemb, IntPtr stream);
    [CLSCompliantAttribute("False")]
public static ulong fread(Byte[] ptr, ulong size, ulong nmemb, IntPtr stream);
    [CLSCompliantAttribute("False")]
public static ulong fread(Byte[] ptr, IntPtr stream);
    [CLSCompliantAttribute("False")]
public static ulong fwrite(IntPtr ptr, ulong size, ulong nmemb, IntPtr stream);
    [CLSCompliantAttribute("False")]
public static ulong fwrite(Void* ptr, ulong size, ulong nmemb, IntPtr stream);
    private static ulong sys_fwrite(Byte[] ptr, ulong size, ulong nmemb, IntPtr stream);
    [CLSCompliantAttribute("False")]
public static ulong fwrite(Byte[] ptr, ulong size, ulong nmemb, IntPtr stream);
    [CLSCompliantAttribute("False")]
public static ulong fwrite(Byte[] ptr, IntPtr stream);
    private static int sys_fgetpos(IntPtr stream, HandleRef pos);
    public static int fgetpos(IntPtr stream, FilePosition pos);
    private static int sys_fseek(IntPtr stream, long offset, int origin);
    [CLSCompliantAttribute("False")]
public static int fseek(IntPtr stream, long offset, SeekFlags origin);
    private static int sys_fsetpos(IntPtr stream, HandleRef pos);
    public static int fsetpos(IntPtr stream, FilePosition pos);
    public static long ftell(IntPtr stream);
    public static int rewind(IntPtr stream);
    public static int clearerr(IntPtr stream);
    public static int feof(IntPtr stream);
    public static int ferror(IntPtr stream);
    private static int perror(string s, int err);
    public static int perror(string s);
    private static int GetExitFailure();
    private static int GetExitSuccess();
    private static int GetMbCurMax();
    private static int GetRandMax();
    public static int rand();
    [CLSCompliantAttribute("False")]
public static void srand(UInt32 seed);
    [CLSCompliantAttribute("False")]
public static IntPtr calloc(ulong nmemb, ulong size);
    public static void free(IntPtr ptr);
    [CLSCompliantAttribute("False")]
public static IntPtr malloc(ulong size);
    [CLSCompliantAttribute("False")]
public static IntPtr realloc(IntPtr ptr, ulong size);
    public static void abort();
    public static void exit(int status);
    [CLSCompliantAttribute("False")]
public static void _Exit(int status);
    private static IntPtr sys_getenv(string name);
    public static string getenv(string name);
    [CLSCompliantAttribute("False")]
public static int system(string string);
    private static IntPtr sys_strerror(int errnum);
    [CLSCompliantAttribute("False")]
public static string strerror(Errno errnum);
    [CLSCompliantAttribute("False")]
public static ulong strlen(IntPtr s);
}
[AttributeUsageAttribute("256")]
internal class Mono.Unix.Native.suseconds_tAttribute : MapAttribute {
}
[CLSCompliantAttribute("False")]
public class Mono.Unix.Native.Syscall : Stdlib {
    internal static string LIBC;
    internal static object readdir_lock;
    internal static object fstab_lock;
    internal static object grp_lock;
    internal static object pwd_lock;
    private static object signal_lock;
    public static int L_ctermid;
    public static int L_cuserid;
    internal static object getlogin_lock;
    public static IntPtr MAP_FAILED;
    private static object tty_lock;
    internal static object usershell_lock;
    private static Syscall();
    public static int setxattr(string path, string name, Byte[] value, ulong size, XattrFlags flags);
    public static int setxattr(string path, string name, Byte[] value, ulong size);
    public static int setxattr(string path, string name, Byte[] value, XattrFlags flags);
    public static int setxattr(string path, string name, Byte[] value);
    public static int lsetxattr(string path, string name, Byte[] value, ulong size, XattrFlags flags);
    public static int lsetxattr(string path, string name, Byte[] value, ulong size);
    public static int lsetxattr(string path, string name, Byte[] value, XattrFlags flags);
    public static int lsetxattr(string path, string name, Byte[] value);
    public static int fsetxattr(int fd, string name, Byte[] value, ulong size, XattrFlags flags);
    public static int fsetxattr(int fd, string name, Byte[] value, ulong size);
    public static int fsetxattr(int fd, string name, Byte[] value, XattrFlags flags);
    public static int fsetxattr(int fd, string name, Byte[] value);
    public static long getxattr(string path, string name, Byte[] value, ulong size);
    public static long getxattr(string path, string name, Byte[] value);
    public static long getxattr(string path, string name, Byte[]& value);
    public static long lgetxattr(string path, string name, Byte[] value, ulong size);
    public static long lgetxattr(string path, string name, Byte[] value);
    public static long lgetxattr(string path, string name, Byte[]& value);
    public static long fgetxattr(int fd, string name, Byte[] value, ulong size);
    public static long fgetxattr(int fd, string name, Byte[] value);
    public static long fgetxattr(int fd, string name, Byte[]& value);
    public static long listxattr(string path, Byte[] list, ulong size);
    public static long listxattr(string path, Encoding encoding, String[]& values);
    public static long listxattr(string path, String[]& values);
    private static void GetValues(Byte[] list, Encoding encoding, String[]& values);
    public static long llistxattr(string path, Byte[] list, ulong size);
    public static long llistxattr(string path, Encoding encoding, String[]& values);
    public static long llistxattr(string path, String[]& values);
    public static long flistxattr(int fd, Byte[] list, ulong size);
    public static long flistxattr(int fd, Encoding encoding, String[]& values);
    public static long flistxattr(int fd, String[]& values);
    public static int removexattr(string path, string name);
    public static int lremovexattr(string path, string name);
    public static int fremovexattr(int fd, string name);
    public static IntPtr opendir(string name);
    public static int closedir(IntPtr dir);
    public static int seekdir(IntPtr dir, long offset);
    public static long telldir(IntPtr dir);
    public static int rewinddir(IntPtr dir);
    private static void CopyDirent(Dirent to, _Dirent& from);
    private static int sys_readdir(IntPtr dir, _Dirent& dentry);
    public static Dirent readdir(IntPtr dir);
    private static int sys_readdir_r(IntPtr dirp, _Dirent& entry, IntPtr& result);
    public static int readdir_r(IntPtr dirp, Dirent entry, IntPtr& result);
    public static int dirfd(IntPtr dir);
    public static int fcntl(int fd, FcntlCommand cmd);
    public static int fcntl(int fd, FcntlCommand cmd, long arg);
    public static int fcntl(int fd, FcntlCommand cmd, DirectoryNotifyFlags arg);
    public static int fcntl(int fd, FcntlCommand cmd, Flock& lock);
    public static int open(string pathname, OpenFlags flags);
    public static int open(string pathname, OpenFlags flags, FilePermissions mode);
    public static int creat(string pathname, FilePermissions mode);
    public static int posix_fadvise(int fd, long offset, long len, PosixFadviseAdvice advice);
    public static int posix_fallocate(int fd, long offset, ulong len);
    private static void CopyFstab(Fstab to, _Fstab& from);
    private static int sys_endfsent();
    public static int endfsent();
    private static int sys_getfsent(_Fstab& fs);
    public static Fstab getfsent();
    private static int sys_getfsfile(string mount_point, _Fstab& fs);
    public static Fstab getfsfile(string mount_point);
    private static int sys_getfsspec(string special_file, _Fstab& fs);
    public static Fstab getfsspec(string special_file);
    private static int sys_setfsent();
    public static int setfsent();
    public static int setgroups(ulong size, UInt32[] list);
    public static int setgroups(UInt32[] list);
    private static void CopyGroup(Group to, _Group& from);
    private static int sys_getgrnam(string name, _Group& group);
    public static Group getgrnam(string name);
    private static int sys_getgrgid(UInt32 uid, _Group& group);
    public static Group getgrgid(UInt32 uid);
    private static int sys_getgrnam_r(string name, _Group& grbuf, IntPtr& grbufp);
    public static int getgrnam_r(string name, Group grbuf, Group& grbufp);
    private static int sys_getgrgid_r(UInt32 uid, _Group& grbuf, IntPtr& grbufp);
    public static int getgrgid_r(UInt32 uid, Group grbuf, Group& grbufp);
    private static int sys_getgrent(_Group& grbuf);
    public static Group getgrent();
    private static int sys_setgrent();
    public static int setgrent();
    private static int sys_endgrent();
    public static int endgrent();
    private static int sys_fgetgrent(IntPtr stream, _Group& grbuf);
    public static Group fgetgrent(IntPtr stream);
    private static void CopyPasswd(Passwd to, _Passwd& from);
    private static int sys_getpwnam(string name, _Passwd& passwd);
    public static Passwd getpwnam(string name);
    private static int sys_getpwuid(UInt32 uid, _Passwd& passwd);
    public static Passwd getpwuid(UInt32 uid);
    private static int sys_getpwnam_r(string name, _Passwd& pwbuf, IntPtr& pwbufp);
    public static int getpwnam_r(string name, Passwd pwbuf, Passwd& pwbufp);
    private static int sys_getpwuid_r(UInt32 uid, _Passwd& pwbuf, IntPtr& pwbufp);
    public static int getpwuid_r(UInt32 uid, Passwd pwbuf, Passwd& pwbufp);
    private static int sys_getpwent(_Passwd& pwbuf);
    public static Passwd getpwent();
    private static int sys_setpwent();
    public static int setpwent();
    private static int sys_endpwent();
    public static int endpwent();
    private static int sys_fgetpwent(IntPtr stream, _Passwd& pwbuf);
    public static Passwd fgetpwent(IntPtr stream);
    private static int psignal(int sig, string s);
    public static int psignal(Signum sig, string s);
    private static int sys_kill(int pid, int sig);
    public static int kill(int pid, Signum sig);
    private static IntPtr sys_strsignal(int sig);
    public static string strsignal(Signum sig);
    private static int _L_ctermid();
    private static int _L_cuserid();
    private static IntPtr sys_cuserid(StringBuilder string);
    [ObsoleteAttribute(""Nobody knows precisely what cuserid() does... DO NOT USE cuserid().
`string' must hold L_cuserid characters.  Use getlogin_r instead.")]
public static string cuserid(StringBuilder string);
    public static int mkstemp(StringBuilder template);
    public static int ttyslot();
    [ObsoleteAttribute("This is insecure and should not be used", "True")]
public static int setkey(string key);
    private static int sys_strerror_r(int errnum, StringBuilder buf, ulong n);
    public static int strerror_r(Errno errnum, StringBuilder buf, ulong n);
    public static int strerror_r(Errno errnum, StringBuilder buf);
    public static int posix_madvise(IntPtr addr, ulong len, PosixMadviseAdvice advice);
    public static IntPtr mmap(IntPtr start, ulong length, MmapProts prot, MmapFlags flags, int fd, long offset);
    public static int munmap(IntPtr start, ulong length);
    public static int mprotect(IntPtr start, ulong len, MmapProts prot);
    public static int msync(IntPtr start, ulong len, MsyncFlags flags);
    public static int mlock(IntPtr start, ulong len);
    public static int munlock(IntPtr start, ulong len);
    private static int sys_mlockall(int flags);
    public static int mlockall(MlockallFlags flags);
    public static int munlockall();
    public static IntPtr mremap(IntPtr old_address, ulong old_size, ulong new_size, MremapFlags flags);
    public static int mincore(IntPtr start, ulong length, Byte[] vec);
    public static int remap_file_pages(IntPtr start, ulong size, MmapProts prot, long pgoff, MmapFlags flags);
    private static int sys_poll(_pollfd[] ufds, UInt32 nfds, int timeout);
    public static int poll(Pollfd[] fds, UInt32 nfds, int timeout);
    public static int poll(Pollfd[] fds, int timeout);
    public static long sendfile(int out_fd, int in_fd, Int64& offset, ulong count);
    public static int stat(string file_name, Stat& buf);
    public static int fstat(int filedes, Stat& buf);
    public static int lstat(string file_name, Stat& buf);
    private static int sys_chmod(string path, UInt32 mode);
    public static int chmod(string path, FilePermissions mode);
    private static int sys_fchmod(int filedes, UInt32 mode);
    public static int fchmod(int filedes, FilePermissions mode);
    private static UInt32 sys_umask(UInt32 mask);
    public static FilePermissions umask(FilePermissions mask);
    private static int sys_mkdir(string oldpath, UInt32 mode);
    public static int mkdir(string oldpath, FilePermissions mode);
    public static int mknod(string pathname, FilePermissions mode, ulong dev);
    private static int sys_mkfifo(string pathname, UInt32 mode);
    public static int mkfifo(string pathname, FilePermissions mode);
    public static int statvfs(string path, Statvfs& buf);
    public static int fstatvfs(int fd, Statvfs& buf);
    public static int gettimeofday(Timeval& tv, Timezone& tz);
    private static int gettimeofday(Timeval& tv, IntPtr ignore);
    public static int gettimeofday(Timeval& tv);
    private static int gettimeofday(IntPtr ignore, Timezone& tz);
    public static int gettimeofday(Timezone& tz);
    public static int settimeofday(Timeval& tv, Timezone& tz);
    private static int settimeofday(Timeval& tv, IntPtr ignore);
    public static int settimeofday(Timeval& tv);
    private static int sys_utimes(string filename, Timeval[] tvp);
    public static int utimes(string filename, Timeval[] tvp);
    private static int sys_lutimes(string filename, Timeval[] tvp);
    public static int lutimes(string filename, Timeval[] tvp);
    private static int sys_futimes(int fd, Timeval[] tvp);
    public static int futimes(int fd, Timeval[] tvp);
    private static void CopyUtsname(Utsname& to, _Utsname& from);
    private static int sys_uname(_Utsname& buf);
    public static int uname(Utsname& buf);
    public static int wait(Int32& status);
    private static int waitpid(int pid, Int32& status, int options);
    public static int waitpid(int pid, Int32& status, WaitOptions options);
    private static int _WIFEXITED(int status);
    public static bool WIFEXITED(int status);
    public static int WEXITSTATUS(int status);
    private static int _WIFSIGNALED(int status);
    public static bool WIFSIGNALED(int status);
    private static int _WTERMSIG(int status);
    public static Signum WTERMSIG(int status);
    private static int _WIFSTOPPED(int status);
    public static bool WIFSTOPPED(int status);
    private static int _WSTOPSIG(int status);
    public static Signum WSTOPSIG(int status);
    private static int sys_openlog(IntPtr ident, int option, int facility);
    public static int openlog(IntPtr ident, SyslogOptions option, SyslogFacility defaultFacility);
    private static int sys_syslog(int priority, string message);
    public static int syslog(SyslogFacility facility, SyslogLevel level, string message);
    public static int syslog(SyslogLevel level, string message);
    private static string GetSyslogMessage(string message);
    [ObsoleteAttribute("Not necessarily portable due to cdecl restrictions.
Use syslog(SyslogFacility, SyslogLevel, string) instead.")]
public static int syslog(SyslogFacility facility, SyslogLevel level, string format, Object[] parameters);
    [ObsoleteAttribute("Not necessarily portable due to cdecl restrictions.
Use syslog(SyslogLevel, string) instead.")]
public static int syslog(SyslogLevel level, string format, Object[] parameters);
    public static int closelog();
    private static int sys_setlogmask(int mask);
    public static int setlogmask(SyslogLevel mask);
    public static int nanosleep(Timespec& req, Timespec& rem);
    public static int stime(Int64& t);
    public static long time(Int64& t);
    private static int sys_access(string pathname, int mode);
    public static int access(string pathname, AccessModes mode);
    private static long sys_lseek(int fd, long offset, int whence);
    public static long lseek(int fd, long offset, SeekFlags whence);
    public static int close(int fd);
    public static long read(int fd, IntPtr buf, ulong count);
    public static long read(int fd, Void* buf, ulong count);
    public static long write(int fd, IntPtr buf, ulong count);
    public static long write(int fd, Void* buf, ulong count);
    public static long pread(int fd, IntPtr buf, ulong count, long offset);
    public static long pread(int fd, Void* buf, ulong count, long offset);
    public static long pwrite(int fd, IntPtr buf, ulong count, long offset);
    public static long pwrite(int fd, Void* buf, ulong count, long offset);
    public static int pipe(Int32& reading, Int32& writing);
    public static int pipe(Int32[] filedes);
    public static UInt32 alarm(UInt32 seconds);
    public static UInt32 sleep(UInt32 seconds);
    public static UInt32 ualarm(UInt32 usecs, UInt32 interval);
    public static int pause();
    public static int chown(string path, UInt32 owner, UInt32 group);
    public static int fchown(int fd, UInt32 owner, UInt32 group);
    public static int lchown(string path, UInt32 owner, UInt32 group);
    public static int chdir(string path);
    public static int fchdir(int fd);
    public static IntPtr getcwd(StringBuilder buf, ulong size);
    public static StringBuilder getcwd(StringBuilder buf);
    public static int dup(int fd);
    public static int dup2(int fd, int fd2);
    public static int execve(string path, String[] argv, String[] envp);
    public static int fexecve(int fd, String[] argv, String[] envp);
    public static int execv(string path, String[] argv);
    public static int execvp(string path, String[] argv);
    public static int nice(int inc);
    [CLSCompliantAttribute("False")]
public static int _exit(int status);
    public static long fpathconf(int filedes, PathconfName name, Errno defaultError);
    public static long fpathconf(int filedes, PathconfName name);
    public static long pathconf(string path, PathconfName name, Errno defaultError);
    public static long pathconf(string path, PathconfName name);
    public static long sysconf(SysconfName name, Errno defaultError);
    public static long sysconf(SysconfName name);
    public static ulong confstr(ConfstrName name, StringBuilder buf, ulong len);
    public static int getpid();
    public static int getppid();
    public static int setpgid(int pid, int pgid);
    public static int getpgid(int pid);
    public static int setpgrp();
    public static int getpgrp();
    public static int setsid();
    public static int getsid(int pid);
    public static UInt32 getuid();
    public static UInt32 geteuid();
    public static UInt32 getgid();
    public static UInt32 getegid();
    public static int getgroups(int size, UInt32[] list);
    public static int getgroups(UInt32[] list);
    public static int setuid(UInt32 uid);
    public static int setreuid(UInt32 ruid, UInt32 euid);
    public static int setregid(UInt32 rgid, UInt32 egid);
    public static int seteuid(UInt32 euid);
    public static int setegid(UInt32 uid);
    public static int setgid(UInt32 gid);
    public static int getresuid(UInt32& ruid, UInt32& euid, UInt32& suid);
    public static int getresgid(UInt32& rgid, UInt32& egid, UInt32& sgid);
    public static int setresuid(UInt32 ruid, UInt32 euid, UInt32 suid);
    public static int setresgid(UInt32 rgid, UInt32 egid, UInt32 sgid);
    private static IntPtr sys_ttyname(int fd);
    public static string ttyname(int fd);
    public static int ttyname_r(int fd, StringBuilder buf, ulong buflen);
    public static int ttyname_r(int fd, StringBuilder buf);
    private static int sys_isatty(int fd);
    public static bool isatty(int fd);
    public static int link(string oldpath, string newpath);
    public static int symlink(string oldpath, string newpath);
    public static int readlink(string path, StringBuilder buf, ulong bufsiz);
    public static int readlink(string path, StringBuilder buf);
    public static int unlink(string pathname);
    public static int rmdir(string pathname);
    public static int tcgetpgrp(int fd);
    public static int tcsetpgrp(int fd, int pgrp);
    private static IntPtr sys_getlogin();
    public static string getlogin();
    public static int getlogin_r(StringBuilder name, ulong bufsize);
    public static int getlogin_r(StringBuilder name);
    public static int setlogin(string name);
    public static int gethostname(StringBuilder name, ulong len);
    public static int gethostname(StringBuilder name);
    public static int sethostname(string name, ulong len);
    public static int sethostname(string name);
    public static long gethostid();
    public static int sethostid(long hostid);
    public static int getdomainname(StringBuilder name, ulong len);
    public static int getdomainname(StringBuilder name);
    public static int setdomainname(string name, ulong len);
    public static int setdomainname(string name);
    public static int vhangup();
    public static int revoke(string file);
    public static int acct(string filename);
    private static IntPtr sys_getusershell();
    public static string getusershell();
    private static int sys_setusershell();
    public static int setusershell();
    private static int sys_endusershell();
    public static int endusershell();
    public static int chroot(string path);
    public static int fsync(int fd);
    public static int fdatasync(int fd);
    public static int sync();
    [ObsoleteAttribute("Dropped in POSIX 1003.1-2001.  Use Syscall.sysconf (SysconfName._SC_PAGESIZE).")]
public static int getpagesize();
    public static int truncate(string path, long length);
    public static int ftruncate(int fd, long length);
    public static int getdtablesize();
    public static int brk(IntPtr end_data_segment);
    public static IntPtr sbrk(IntPtr increment);
    public static int lockf(int fd, LockfCommand cmd, long len);
    [ObsoleteAttribute("This is insecure and should not be used", "True")]
public static string crypt(string key, string salt);
    [ObsoleteAttribute("This is insecure and should not be used", "True")]
public static int encrypt(Byte[] block, bool decode);
    public static int swab(IntPtr from, IntPtr to, long n);
    public static void swab(Void* from, Void* to, long n);
    private static int sys_utime(string filename, Utimbuf& buf, int use_buf);
    public static int utime(string filename, Utimbuf& buf);
    public static int utime(string filename);
}
[MapAttribute]
[CLSCompliantAttribute("False")]
public enum Mono.Unix.Native.SysconfName : Enum {
    public int value__;
    public static SysconfName _SC_ARG_MAX;
    public static SysconfName _SC_CHILD_MAX;
    public static SysconfName _SC_CLK_TCK;
    public static SysconfName _SC_NGROUPS_MAX;
    public static SysconfName _SC_OPEN_MAX;
    public static SysconfName _SC_STREAM_MAX;
    public static SysconfName _SC_TZNAME_MAX;
    public static SysconfName _SC_JOB_CONTROL;
    public static SysconfName _SC_SAVED_IDS;
    public static SysconfName _SC_REALTIME_SIGNALS;
    public static SysconfName _SC_PRIORITY_SCHEDULING;
    public static SysconfName _SC_TIMERS;
    public static SysconfName _SC_ASYNCHRONOUS_IO;
    public static SysconfName _SC_PRIORITIZED_IO;
    public static SysconfName _SC_SYNCHRONIZED_IO;
    public static SysconfName _SC_FSYNC;
    public static SysconfName _SC_MAPPED_FILES;
    public static SysconfName _SC_MEMLOCK;
    public static SysconfName _SC_MEMLOCK_RANGE;
    public static SysconfName _SC_MEMORY_PROTECTION;
    public static SysconfName _SC_MESSAGE_PASSING;
    public static SysconfName _SC_SEMAPHORES;
    public static SysconfName _SC_SHARED_MEMORY_OBJECTS;
    public static SysconfName _SC_AIO_LISTIO_MAX;
    public static SysconfName _SC_AIO_MAX;
    public static SysconfName _SC_AIO_PRIO_DELTA_MAX;
    public static SysconfName _SC_DELAYTIMER_MAX;
    public static SysconfName _SC_MQ_OPEN_MAX;
    public static SysconfName _SC_MQ_PRIO_MAX;
    public static SysconfName _SC_VERSION;
    public static SysconfName _SC_PAGESIZE;
    public static SysconfName _SC_RTSIG_MAX;
    public static SysconfName _SC_SEM_NSEMS_MAX;
    public static SysconfName _SC_SEM_VALUE_MAX;
    public static SysconfName _SC_SIGQUEUE_MAX;
    public static SysconfName _SC_TIMER_MAX;
    public static SysconfName _SC_BC_BASE_MAX;
    public static SysconfName _SC_BC_DIM_MAX;
    public static SysconfName _SC_BC_SCALE_MAX;
    public static SysconfName _SC_BC_STRING_MAX;
    public static SysconfName _SC_COLL_WEIGHTS_MAX;
    public static SysconfName _SC_EQUIV_CLASS_MAX;
    public static SysconfName _SC_EXPR_NEST_MAX;
    public static SysconfName _SC_LINE_MAX;
    public static SysconfName _SC_RE_DUP_MAX;
    public static SysconfName _SC_CHARCLASS_NAME_MAX;
    public static SysconfName _SC_2_VERSION;
    public static SysconfName _SC_2_C_BIND;
    public static SysconfName _SC_2_C_DEV;
    public static SysconfName _SC_2_FORT_DEV;
    public static SysconfName _SC_2_FORT_RUN;
    public static SysconfName _SC_2_SW_DEV;
    public static SysconfName _SC_2_LOCALEDEF;
    public static SysconfName _SC_PII;
    public static SysconfName _SC_PII_XTI;
    public static SysconfName _SC_PII_SOCKET;
    public static SysconfName _SC_PII_INTERNET;
    public static SysconfName _SC_PII_OSI;
    public static SysconfName _SC_POLL;
    public static SysconfName _SC_SELECT;
    public static SysconfName _SC_UIO_MAXIOV;
    public static SysconfName _SC_IOV_MAX;
    public static SysconfName _SC_PII_INTERNET_STREAM;
    public static SysconfName _SC_PII_INTERNET_DGRAM;
    public static SysconfName _SC_PII_OSI_COTS;
    public static SysconfName _SC_PII_OSI_CLTS;
    public static SysconfName _SC_PII_OSI_M;
    public static SysconfName _SC_T_IOV_MAX;
    public static SysconfName _SC_THREADS;
    public static SysconfName _SC_THREAD_SAFE_FUNCTIONS;
    public static SysconfName _SC_GETGR_R_SIZE_MAX;
    public static SysconfName _SC_GETPW_R_SIZE_MAX;
    public static SysconfName _SC_LOGIN_NAME_MAX;
    public static SysconfName _SC_TTY_NAME_MAX;
    public static SysconfName _SC_THREAD_DESTRUCTOR_ITERATIONS;
    public static SysconfName _SC_THREAD_KEYS_MAX;
    public static SysconfName _SC_THREAD_STACK_MIN;
    public static SysconfName _SC_THREAD_THREADS_MAX;
    public static SysconfName _SC_THREAD_ATTR_STACKADDR;
    public static SysconfName _SC_THREAD_ATTR_STACKSIZE;
    public static SysconfName _SC_THREAD_PRIORITY_SCHEDULING;
    public static SysconfName _SC_THREAD_PRIO_INHERIT;
    public static SysconfName _SC_THREAD_PRIO_PROTECT;
    public static SysconfName _SC_THREAD_PROCESS_SHARED;
    public static SysconfName _SC_NPROCESSORS_CONF;
    public static SysconfName _SC_NPROCESSORS_ONLN;
    public static SysconfName _SC_PHYS_PAGES;
    public static SysconfName _SC_AVPHYS_PAGES;
    public static SysconfName _SC_ATEXIT_MAX;
    public static SysconfName _SC_PASS_MAX;
    public static SysconfName _SC_XOPEN_VERSION;
    public static SysconfName _SC_XOPEN_XCU_VERSION;
    public static SysconfName _SC_XOPEN_UNIX;
    public static SysconfName _SC_XOPEN_CRYPT;
    public static SysconfName _SC_XOPEN_ENH_I18N;
    public static SysconfName _SC_XOPEN_SHM;
    public static SysconfName _SC_2_CHAR_TERM;
    public static SysconfName _SC_2_C_VERSION;
    public static SysconfName _SC_2_UPE;
    public static SysconfName _SC_XOPEN_XPG2;
    public static SysconfName _SC_XOPEN_XPG3;
    public static SysconfName _SC_XOPEN_XPG4;
    public static SysconfName _SC_CHAR_BIT;
    public static SysconfName _SC_CHAR_MAX;
    public static SysconfName _SC_CHAR_MIN;
    public static SysconfName _SC_INT_MAX;
    public static SysconfName _SC_INT_MIN;
    public static SysconfName _SC_LONG_BIT;
    public static SysconfName _SC_WORD_BIT;
    public static SysconfName _SC_MB_LEN_MAX;
    public static SysconfName _SC_NZERO;
    public static SysconfName _SC_SSIZE_MAX;
    public static SysconfName _SC_SCHAR_MAX;
    public static SysconfName _SC_SCHAR_MIN;
    public static SysconfName _SC_SHRT_MAX;
    public static SysconfName _SC_SHRT_MIN;
    public static SysconfName _SC_UCHAR_MAX;
    public static SysconfName _SC_UINT_MAX;
    public static SysconfName _SC_ULONG_MAX;
    public static SysconfName _SC_USHRT_MAX;
    public static SysconfName _SC_NL_ARGMAX;
    public static SysconfName _SC_NL_LANGMAX;
    public static SysconfName _SC_NL_MSGMAX;
    public static SysconfName _SC_NL_NMAX;
    public static SysconfName _SC_NL_SETMAX;
    public static SysconfName _SC_NL_TEXTMAX;
    public static SysconfName _SC_XBS5_ILP32_OFF32;
    public static SysconfName _SC_XBS5_ILP32_OFFBIG;
    public static SysconfName _SC_XBS5_LP64_OFF64;
    public static SysconfName _SC_XBS5_LPBIG_OFFBIG;
    public static SysconfName _SC_XOPEN_LEGACY;
    public static SysconfName _SC_XOPEN_REALTIME;
    public static SysconfName _SC_XOPEN_REALTIME_THREADS;
    public static SysconfName _SC_ADVISORY_INFO;
    public static SysconfName _SC_BARRIERS;
    public static SysconfName _SC_BASE;
    public static SysconfName _SC_C_LANG_SUPPORT;
    public static SysconfName _SC_C_LANG_SUPPORT_R;
    public static SysconfName _SC_CLOCK_SELECTION;
    public static SysconfName _SC_CPUTIME;
    public static SysconfName _SC_THREAD_CPUTIME;
    public static SysconfName _SC_DEVICE_IO;
    public static SysconfName _SC_DEVICE_SPECIFIC;
    public static SysconfName _SC_DEVICE_SPECIFIC_R;
    public static SysconfName _SC_FD_MGMT;
    public static SysconfName _SC_FIFO;
    public static SysconfName _SC_PIPE;
    public static SysconfName _SC_FILE_ATTRIBUTES;
    public static SysconfName _SC_FILE_LOCKING;
    public static SysconfName _SC_FILE_SYSTEM;
    public static SysconfName _SC_MONOTONIC_CLOCK;
    public static SysconfName _SC_MULTI_PROCESS;
    public static SysconfName _SC_SINGLE_PROCESS;
    public static SysconfName _SC_NETWORKING;
    public static SysconfName _SC_READER_WRITER_LOCKS;
    public static SysconfName _SC_SPIN_LOCKS;
    public static SysconfName _SC_REGEXP;
    public static SysconfName _SC_REGEX_VERSION;
    public static SysconfName _SC_SHELL;
    public static SysconfName _SC_SIGNALS;
    public static SysconfName _SC_SPAWN;
    public static SysconfName _SC_SPORADIC_SERVER;
    public static SysconfName _SC_THREAD_SPORADIC_SERVER;
    public static SysconfName _SC_SYSTEM_DATABASE;
    public static SysconfName _SC_SYSTEM_DATABASE_R;
    public static SysconfName _SC_TIMEOUTS;
    public static SysconfName _SC_TYPED_MEMORY_OBJECTS;
    public static SysconfName _SC_USER_GROUPS;
    public static SysconfName _SC_USER_GROUPS_R;
    public static SysconfName _SC_2_PBS;
    public static SysconfName _SC_2_PBS_ACCOUNTING;
    public static SysconfName _SC_2_PBS_LOCATE;
    public static SysconfName _SC_2_PBS_MESSAGE;
    public static SysconfName _SC_2_PBS_TRACK;
    public static SysconfName _SC_SYMLOOP_MAX;
    public static SysconfName _SC_STREAMS;
    public static SysconfName _SC_2_PBS_CHECKPOINT;
    public static SysconfName _SC_V6_ILP32_OFF32;
    public static SysconfName _SC_V6_ILP32_OFFBIG;
    public static SysconfName _SC_V6_LP64_OFF64;
    public static SysconfName _SC_V6_LPBIG_OFFBIG;
    public static SysconfName _SC_HOST_NAME_MAX;
    public static SysconfName _SC_TRACE;
    public static SysconfName _SC_TRACE_EVENT_FILTER;
    public static SysconfName _SC_TRACE_INHERIT;
    public static SysconfName _SC_TRACE_LOG;
    public static SysconfName _SC_LEVEL1_ICACHE_SIZE;
    public static SysconfName _SC_LEVEL1_ICACHE_ASSOC;
    public static SysconfName _SC_LEVEL1_ICACHE_LINESIZE;
    public static SysconfName _SC_LEVEL1_DCACHE_SIZE;
    public static SysconfName _SC_LEVEL1_DCACHE_ASSOC;
    public static SysconfName _SC_LEVEL1_DCACHE_LINESIZE;
    public static SysconfName _SC_LEVEL2_CACHE_SIZE;
    public static SysconfName _SC_LEVEL2_CACHE_ASSOC;
    public static SysconfName _SC_LEVEL2_CACHE_LINESIZE;
    public static SysconfName _SC_LEVEL3_CACHE_SIZE;
    public static SysconfName _SC_LEVEL3_CACHE_ASSOC;
    public static SysconfName _SC_LEVEL3_CACHE_LINESIZE;
    public static SysconfName _SC_LEVEL4_CACHE_SIZE;
    public static SysconfName _SC_LEVEL4_CACHE_ASSOC;
    public static SysconfName _SC_LEVEL4_CACHE_LINESIZE;
}
[CLSCompliantAttribute("False")]
[MapAttribute]
public enum Mono.Unix.Native.SyslogFacility : Enum {
    public int value__;
    public static SyslogFacility LOG_KERN;
    public static SyslogFacility LOG_USER;
    public static SyslogFacility LOG_MAIL;
    public static SyslogFacility LOG_DAEMON;
    public static SyslogFacility LOG_AUTH;
    public static SyslogFacility LOG_SYSLOG;
    public static SyslogFacility LOG_LPR;
    public static SyslogFacility LOG_NEWS;
    public static SyslogFacility LOG_UUCP;
    public static SyslogFacility LOG_CRON;
    public static SyslogFacility LOG_AUTHPRIV;
    public static SyslogFacility LOG_FTP;
    public static SyslogFacility LOG_LOCAL0;
    public static SyslogFacility LOG_LOCAL1;
    public static SyslogFacility LOG_LOCAL2;
    public static SyslogFacility LOG_LOCAL3;
    public static SyslogFacility LOG_LOCAL4;
    public static SyslogFacility LOG_LOCAL5;
    public static SyslogFacility LOG_LOCAL6;
    public static SyslogFacility LOG_LOCAL7;
}
[MapAttribute]
[CLSCompliantAttribute("False")]
public enum Mono.Unix.Native.SyslogLevel : Enum {
    public int value__;
    public static SyslogLevel LOG_EMERG;
    public static SyslogLevel LOG_ALERT;
    public static SyslogLevel LOG_CRIT;
    public static SyslogLevel LOG_ERR;
    public static SyslogLevel LOG_WARNING;
    public static SyslogLevel LOG_NOTICE;
    public static SyslogLevel LOG_INFO;
    public static SyslogLevel LOG_DEBUG;
}
[MapAttribute]
[CLSCompliantAttribute("False")]
[FlagsAttribute]
public enum Mono.Unix.Native.SyslogOptions : Enum {
    public int value__;
    public static SyslogOptions LOG_PID;
    public static SyslogOptions LOG_CONS;
    public static SyslogOptions LOG_ODELAY;
    public static SyslogOptions LOG_NDELAY;
    public static SyslogOptions LOG_NOWAIT;
    public static SyslogOptions LOG_PERROR;
}
[AttributeUsageAttribute("256")]
internal class Mono.Unix.Native.time_tAttribute : MapAttribute {
}
[MapAttribute("struct timespec")]
public class Mono.Unix.Native.Timespec : ValueType {
    [time_tAttribute]
public long tv_sec;
    public long tv_nsec;
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Timespec value);
    public static bool op_Equality(Timespec lhs, Timespec rhs);
    public static bool op_Inequality(Timespec lhs, Timespec rhs);
}
[MapAttribute("struct timeval")]
public class Mono.Unix.Native.Timeval : ValueType {
    [time_tAttribute]
public long tv_sec;
    [suseconds_tAttribute]
public long tv_usec;
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Timeval value);
    public static bool op_Equality(Timeval lhs, Timeval rhs);
    public static bool op_Inequality(Timeval lhs, Timeval rhs);
}
[MapAttribute("struct timezone")]
public class Mono.Unix.Native.Timezone : ValueType {
    public int tz_minuteswest;
    private int tz_dsttime;
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Timezone value);
    public static bool op_Equality(Timezone lhs, Timezone rhs);
    public static bool op_Inequality(Timezone lhs, Timezone rhs);
}
[AttributeUsageAttribute("256")]
internal class Mono.Unix.Native.uid_tAttribute : MapAttribute {
}
[MapAttribute("struct utimbuf")]
public class Mono.Unix.Native.Utimbuf : ValueType {
    [time_tAttribute]
public long actime;
    [time_tAttribute]
public long modtime;
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Utimbuf value);
    public static bool op_Equality(Utimbuf lhs, Utimbuf rhs);
    public static bool op_Inequality(Utimbuf lhs, Utimbuf rhs);
}
public class Mono.Unix.Native.Utsname : object {
    public string sysname;
    public string nodename;
    public string release;
    public string version;
    public string machine;
    public string domainname;
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Utsname value);
    public virtual string ToString();
    public static bool op_Equality(Utsname lhs, Utsname rhs);
    public static bool op_Inequality(Utsname lhs, Utsname rhs);
}
[FlagsAttribute]
[MapAttribute]
public enum Mono.Unix.Native.WaitOptions : Enum {
    public int value__;
    public static WaitOptions WNOHANG;
    public static WaitOptions WUNTRACED;
}
[CLSCompliantAttribute("False")]
[FlagsAttribute]
[MapAttribute]
public enum Mono.Unix.Native.XattrFlags : Enum {
    public int value__;
    public static XattrFlags XATTR_AUTO;
    public static XattrFlags XATTR_CREATE;
    public static XattrFlags XATTR_REPLACE;
}
internal class Mono.Unix.Native.XPrintfFunctions : object {
    internal static XPrintf printf;
    internal static XPrintf fprintf;
    internal static XPrintf snprintf;
    internal static XPrintf syslog;
    private static XPrintfFunctions();
}
public class Mono.Unix.PeerCred : object {
    private static int so_peercred;
    private PeerCredData data;
    public int ProcessID { get; }
    public int UserID { get; }
    public int GroupID { get; }
    public PeerCred(Socket sock);
    public int get_ProcessID();
    public int get_UserID();
    public int get_GroupID();
}
public class Mono.Unix.StdioFileStream : Stream {
    public static IntPtr InvalidFileStream;
    public static IntPtr StandardInput;
    public static IntPtr StandardOutput;
    public static IntPtr StandardError;
    private bool canSeek;
    private bool canRead;
    private bool canWrite;
    private bool owner;
    private IntPtr file;
    public IntPtr Handle { get; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public StdioFileStream(IntPtr fileStream);
    public StdioFileStream(IntPtr fileStream, bool ownsHandle);
    public StdioFileStream(IntPtr fileStream, FileAccess access);
    public StdioFileStream(IntPtr fileStream, FileAccess access, bool ownsHandle);
    public StdioFileStream(string path);
    public StdioFileStream(string path, string mode);
    public StdioFileStream(string path, FileMode mode);
    public StdioFileStream(string path, FileAccess access);
    public StdioFileStream(string path, FileMode mode, FileAccess access);
    private static StdioFileStream();
    private static IntPtr Fopen(string path, string mode);
    private void InitStream(IntPtr fileStream, bool ownsHandle);
    private void InitCanReadWrite(FileAccess access);
    private static string ToFopenMode(string file, FileMode mode);
    private static string ToFopenMode(string file, FileAccess access);
    private static string ToFopenMode(string file, FileMode mode, FileAccess access);
    private static bool AssertFileMode(string file, FileMode mode);
    private static bool FileExists(string file);
    private void AssertNotDisposed();
    public IntPtr get_Handle();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public void SaveFilePosition(FilePosition pos);
    public void RestoreFilePosition(FilePosition pos);
    public virtual void Flush();
    public virtual int Read(Byte[] buffer, int offset, int count);
    private void AssertValidBuffer(Byte[] buffer, int offset, int count);
    public void Rewind();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    protected virtual void Finalize();
    public virtual void Close();
}
public class Mono.Unix.UnixClient : MarshalByRefObject {
    private NetworkStream stream;
    private Socket client;
    private bool disposed;
    public Socket Client { get; public set; }
    public PeerCred PeerCredential { get; }
    public LingerOption LingerState { get; public set; }
    public int ReceiveBufferSize { get; public set; }
    public int ReceiveTimeout { get; public set; }
    public int SendBufferSize { get; public set; }
    public int SendTimeout { get; public set; }
    public UnixClient(string path);
    public UnixClient(UnixEndPoint ep);
    internal UnixClient(Socket sock);
    public Socket get_Client();
    public void set_Client(Socket value);
    public PeerCred get_PeerCredential();
    public LingerOption get_LingerState();
    public void set_LingerState(LingerOption value);
    public int get_ReceiveBufferSize();
    public void set_ReceiveBufferSize(int value);
    public int get_ReceiveTimeout();
    public void set_ReceiveTimeout(int value);
    public int get_SendBufferSize();
    public void set_SendBufferSize(int value);
    public int get_SendTimeout();
    public void set_SendTimeout(int value);
    public void Close();
    public void Connect(UnixEndPoint remoteEndPoint);
    public void Connect(string path);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public NetworkStream GetStream();
    private void CheckDisposed();
    protected virtual void Finalize();
}
public class Mono.Unix.UnixDirectoryInfo : UnixFileSystemInfo {
    public string Name { get; }
    public UnixDirectoryInfo Parent { get; }
    public UnixDirectoryInfo Root { get; }
    public UnixDirectoryInfo(string path);
    internal UnixDirectoryInfo(string path, Stat stat);
    public virtual string get_Name();
    public UnixDirectoryInfo get_Parent();
    public UnixDirectoryInfo get_Root();
    [CLSCompliantAttribute("False")]
public void Create(FilePermissions mode);
    public void Create(FileAccessPermissions mode);
    public void Create();
    public virtual void Delete();
    public void Delete(bool recursive);
    public Dirent[] GetEntries();
    private static Dirent[] GetEntries(IntPtr dirp);
    public Dirent[] GetEntries(Regex regex);
    private static Dirent[] GetEntries(IntPtr dirp, Regex regex);
    public Dirent[] GetEntries(string regex);
    public UnixFileSystemInfo[] GetFileSystemEntries();
    private UnixFileSystemInfo[] GetFileSystemEntries(Dirent[] dentries);
    public UnixFileSystemInfo[] GetFileSystemEntries(Regex regex);
    public UnixFileSystemInfo[] GetFileSystemEntries(string regex);
    public static string GetCurrentDirectory();
    public static void SetCurrentDirectory(string path);
}
public class Mono.Unix.UnixDriveInfo : object {
    private Statvfs stat;
    private string fstype;
    private string mount_point;
    private string block_device;
    public long AvailableFreeSpace { get; }
    public string DriveFormat { get; }
    public UnixDriveType DriveType { get; }
    public bool IsReady { get; }
    public string Name { get; }
    public UnixDirectoryInfo RootDirectory { get; }
    public long TotalFreeSpace { get; }
    public long TotalSize { get; }
    public string VolumeLabel { get; }
    public long MaximumFilenameLength { get; }
    public UnixDriveInfo(string mountPoint);
    private UnixDriveInfo(Fstab fstab);
    private void FromFstab(Fstab fstab);
    public static UnixDriveInfo GetForSpecialFile(string specialFile);
    public long get_AvailableFreeSpace();
    public string get_DriveFormat();
    public UnixDriveType get_DriveType();
    public bool get_IsReady();
    public string get_Name();
    public UnixDirectoryInfo get_RootDirectory();
    public long get_TotalFreeSpace();
    public long get_TotalSize();
    public string get_VolumeLabel();
    public long get_MaximumFilenameLength();
    public static UnixDriveInfo[] GetDrives();
    public virtual string ToString();
    private void Refresh();
    private bool Refresh(bool throwException);
}
public enum Mono.Unix.UnixDriveType : Enum {
    public int value__;
    public static UnixDriveType Unknown;
    public static UnixDriveType NoRootDirectory;
    public static UnixDriveType Removable;
    public static UnixDriveType Fixed;
    public static UnixDriveType Network;
    public static UnixDriveType CDRom;
    public static UnixDriveType Ram;
}
public class Mono.Unix.UnixEncoding : Encoding {
    public static Encoding Instance;
    public static char EscapeByte;
    private static UnixEncoding();
    private static int InternalGetByteCount(Char[] chars, int index, int count, UInt32 leftOver, bool flush);
    public virtual int GetByteCount(Char[] chars, int index, int count);
    public virtual int GetByteCount(string s);
    private static int InternalGetBytes(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex, UInt32& leftOver, bool flush);
    public virtual int GetBytes(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    public virtual int GetBytes(string s, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    private static int InternalGetCharCount(Byte[] bytes, int index, int count, UInt32 leftOverBits, UInt32 leftOverCount, bool throwOnInvalid, bool flush);
    public virtual int GetCharCount(Byte[] bytes, int index, int count);
    private static int InternalGetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex, UInt32& leftOverBits, UInt32& leftOverCount, bool throwOnInvalid, bool flush);
    private static void CopyRaw(Byte[] raw, Int32& next_raw, Char[] chars, Int32& posn, int length);
    public virtual int GetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex);
    public virtual int GetMaxByteCount(int charCount);
    public virtual int GetMaxCharCount(int byteCount);
    public virtual Decoder GetDecoder();
    public virtual Encoder GetEncoder();
    public virtual Byte[] GetPreamble();
    public virtual bool Equals(object value);
    public virtual int GetHashCode();
    public virtual Byte[] GetBytes(string s);
    private static string _(string arg);
}
public class Mono.Unix.UnixEndPoint : EndPoint {
    private string filename;
    public string Filename { get; public set; }
    public AddressFamily AddressFamily { get; }
    public UnixEndPoint(string filename);
    public string get_Filename();
    public void set_Filename(string value);
    public virtual AddressFamily get_AddressFamily();
    public virtual EndPoint Create(SocketAddress socketAddress);
    public virtual SocketAddress Serialize();
    public virtual string ToString();
    public virtual int GetHashCode();
    public virtual bool Equals(object o);
}
public class Mono.Unix.UnixEnvironment : object {
    public static string CurrentDirectory { get; public set; }
    public static string MachineName { get; public set; }
    public static string UserName { get; }
    public static UnixGroupInfo RealGroup { get; }
    public static long RealGroupId { get; }
    public static UnixUserInfo RealUser { get; }
    public static long RealUserId { get; }
    public static UnixGroupInfo EffectiveGroup { get; public set; }
    public static long EffectiveGroupId { get; public set; }
    public static UnixUserInfo EffectiveUser { get; public set; }
    public static long EffectiveUserId { get; public set; }
    public static string Login { get; }
    public static string get_CurrentDirectory();
    public static void set_CurrentDirectory(string value);
    public static string get_MachineName();
    public static void set_MachineName(string value);
    public static string get_UserName();
    public static UnixGroupInfo get_RealGroup();
    public static long get_RealGroupId();
    public static UnixUserInfo get_RealUser();
    public static long get_RealUserId();
    public static UnixGroupInfo get_EffectiveGroup();
    public static void set_EffectiveGroup(UnixGroupInfo value);
    public static long get_EffectiveGroupId();
    public static void set_EffectiveGroupId(long value);
    public static UnixUserInfo get_EffectiveUser();
    public static void set_EffectiveUser(UnixUserInfo value);
    public static long get_EffectiveUserId();
    public static void set_EffectiveUserId(long value);
    public static string get_Login();
    [CLSCompliantAttribute("False")]
public static long GetConfigurationValue(SysconfName name);
    [CLSCompliantAttribute("False")]
public static string GetConfigurationString(ConfstrName name);
    public static void SetNiceValue(int inc);
    public static int CreateSession();
    public static void SetProcessGroup();
    public static int GetProcessGroup();
    public static UnixGroupInfo[] GetSupplementaryGroups();
    private static UInt32[] _GetSupplementaryGroupIds();
    public static void SetSupplementaryGroups(UnixGroupInfo[] groups);
    public static Int64[] GetSupplementaryGroupIds();
    public static void SetSupplementaryGroupIds(Int64[] list);
    public static int GetParentProcessId();
    public static UnixProcess GetParentProcess();
    public static String[] GetUserShells();
}
public class Mono.Unix.UnixFileInfo : UnixFileSystemInfo {
    public string Name { get; }
    public string DirectoryName { get; }
    public UnixDirectoryInfo Directory { get; }
    public UnixFileInfo(string path);
    internal UnixFileInfo(string path, Stat stat);
    public virtual string get_Name();
    public string get_DirectoryName();
    public UnixDirectoryInfo get_Directory();
    public virtual void Delete();
    public UnixStream Create();
    [CLSCompliantAttribute("False")]
public UnixStream Create(FilePermissions mode);
    public UnixStream Create(FileAccessPermissions mode);
    [CLSCompliantAttribute("False")]
public UnixStream Open(OpenFlags flags);
    [CLSCompliantAttribute("False")]
public UnixStream Open(OpenFlags flags, FilePermissions mode);
    public UnixStream Open(FileMode mode);
    public UnixStream Open(FileMode mode, FileAccess access);
    [CLSCompliantAttribute("False")]
public UnixStream Open(FileMode mode, FileAccess access, FilePermissions perms);
    public UnixStream OpenRead();
    public UnixStream OpenWrite();
}
public abstract class Mono.Unix.UnixFileSystemInfo : object {
    internal static FileSpecialAttributes AllSpecialAttributes;
    internal static FileTypes AllFileTypes;
    private Stat stat;
    private string fullPath;
    private string originalPath;
    private bool valid;
    protected string FullPath { get; protected set; }
    protected string OriginalPath { get; protected set; }
    public string FullName { get; }
    public string Name { get; }
    public bool Exists { get; }
    public long Device { get; }
    public long Inode { get; }
    [CLSCompliantAttribute("False")]
public FilePermissions Protection { get; public set; }
    public FileTypes FileType { get; }
    public FileAccessPermissions FileAccessPermissions { get; public set; }
    public FileSpecialAttributes FileSpecialAttributes { get; public set; }
    public long LinkCount { get; }
    public UnixUserInfo OwnerUser { get; }
    public long OwnerUserId { get; }
    public UnixGroupInfo OwnerGroup { get; }
    public long OwnerGroupId { get; }
    public long DeviceType { get; }
    public long Length { get; }
    public long BlockSize { get; }
    public long BlocksAllocated { get; }
    public DateTime LastAccessTime { get; }
    public DateTime LastAccessTimeUtc { get; }
    public DateTime LastWriteTime { get; }
    public DateTime LastWriteTimeUtc { get; }
    public DateTime LastStatusChangeTime { get; }
    public DateTime LastStatusChangeTimeUtc { get; }
    public bool IsDirectory { get; }
    public bool IsCharacterDevice { get; }
    public bool IsBlockDevice { get; }
    public bool IsRegularFile { get; }
    public bool IsFifo { get; }
    public bool IsSymbolicLink { get; }
    public bool IsSocket { get; }
    public bool IsSetUser { get; }
    public bool IsSetGroup { get; }
    public bool IsSticky { get; }
    protected UnixFileSystemInfo(string path);
    internal UnixFileSystemInfo(string path, Stat stat);
    protected string get_FullPath();
    protected void set_FullPath(string value);
    protected string get_OriginalPath();
    protected void set_OriginalPath(string value);
    private void AssertValid();
    public virtual string get_FullName();
    public abstract virtual string get_Name();
    public bool get_Exists();
    public long get_Device();
    public long get_Inode();
    public FilePermissions get_Protection();
    public void set_Protection(FilePermissions value);
    public FileTypes get_FileType();
    public FileAccessPermissions get_FileAccessPermissions();
    public void set_FileAccessPermissions(FileAccessPermissions value);
    public FileSpecialAttributes get_FileSpecialAttributes();
    public void set_FileSpecialAttributes(FileSpecialAttributes value);
    public long get_LinkCount();
    public UnixUserInfo get_OwnerUser();
    public long get_OwnerUserId();
    public UnixGroupInfo get_OwnerGroup();
    public long get_OwnerGroupId();
    public long get_DeviceType();
    public long get_Length();
    public long get_BlockSize();
    public long get_BlocksAllocated();
    public DateTime get_LastAccessTime();
    public DateTime get_LastAccessTimeUtc();
    public DateTime get_LastWriteTime();
    public DateTime get_LastWriteTimeUtc();
    public DateTime get_LastStatusChangeTime();
    public DateTime get_LastStatusChangeTimeUtc();
    public bool get_IsDirectory();
    public bool get_IsCharacterDevice();
    public bool get_IsBlockDevice();
    public bool get_IsRegularFile();
    public bool get_IsFifo();
    public bool get_IsSymbolicLink();
    public bool get_IsSocket();
    public bool get_IsSetUser();
    public bool get_IsSetGroup();
    public bool get_IsSticky();
    internal static bool IsFileType(FilePermissions mode, FilePermissions type);
    internal static bool IsSet(FilePermissions mode, FilePermissions type);
    [CLSCompliantAttribute("False")]
public bool CanAccess(AccessModes mode);
    public UnixFileSystemInfo CreateLink(string path);
    public UnixSymbolicLinkInfo CreateSymbolicLink(string path);
    public abstract virtual void Delete();
    [CLSCompliantAttribute("False")]
public long GetConfigurationValue(PathconfName name);
    public void Refresh();
    internal void Refresh(bool force);
    protected virtual bool GetFileStatus(string path, Stat& stat);
    public void SetLength(long length);
    public virtual void SetOwner(long owner, long group);
    public void SetOwner(string owner);
    public void SetOwner(string owner, string group);
    public void SetOwner(UnixUserInfo owner);
    public void SetOwner(UnixUserInfo owner, UnixGroupInfo group);
    public virtual string ToString();
    public Stat ToStat();
    public static UnixFileSystemInfo GetFileSystemEntry(string path);
}
public class Mono.Unix.UnixGroupInfo : object {
    private Group group;
    public string GroupName { get; }
    public string Password { get; }
    public long GroupId { get; }
    public UnixGroupInfo(string group);
    public UnixGroupInfo(long group);
    public UnixGroupInfo(Group group);
    private static Group CopyGroup(Group group);
    public string get_GroupName();
    public string get_Password();
    public long get_GroupId();
    public UnixUserInfo[] GetMembers();
    public String[] GetMemberNames();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public virtual string ToString();
    public Group ToGroup();
    public static UnixGroupInfo[] GetLocalGroups();
}
public class Mono.Unix.UnixIOException : IOException {
    private int errno;
    public int NativeErrorCode { get; }
    public Errno ErrorCode { get; }
    public UnixIOException(int errno);
    public UnixIOException(int errno, Exception inner);
    public UnixIOException(Errno errno);
    public UnixIOException(Errno errno, Exception inner);
    public UnixIOException(string message);
    public UnixIOException(string message, Exception inner);
    protected UnixIOException(SerializationInfo info, StreamingContext context);
    public int get_NativeErrorCode();
    public Errno get_ErrorCode();
    private static string GetMessage(Errno errno);
}
public class Mono.Unix.UnixListener : MarshalByRefObject {
    private bool disposed;
    private bool listening;
    private Socket server;
    private EndPoint savedEP;
    public EndPoint LocalEndpoint { get; }
    protected Socket Server { get; }
    public UnixListener(string path);
    public UnixListener(UnixEndPoint localEndPoint);
    private void Init(UnixEndPoint ep);
    public EndPoint get_LocalEndpoint();
    protected Socket get_Server();
    public Socket AcceptSocket();
    public UnixClient AcceptUnixClient();
    protected virtual void Finalize();
    public bool Pending();
    public void Start();
    public void Start(int backlog);
    public void Stop();
    public sealed virtual void Dispose();
    protected void Dispose(bool disposing);
    private void CheckDisposed();
}
public class Mono.Unix.UnixMarshal : object {
    [CLSCompliantAttribute("False")]
public static string GetErrorDescription(Errno errno);
    public static IntPtr AllocHeap(long size);
    public static IntPtr ReAllocHeap(IntPtr ptr, long size);
    public static void FreeHeap(IntPtr ptr);
    public static string PtrToStringUnix(IntPtr p);
    public static string PtrToString(IntPtr p);
    public static string PtrToString(IntPtr p, Encoding encoding);
    private static int GetStringByteLength(IntPtr p, Encoding encoding);
    private static int GetInt16BufferLength(IntPtr p);
    private static int GetInt32BufferLength(IntPtr p);
    private static int GetRandomBufferLength(IntPtr p, int nullLength);
    public static String[] PtrToStringArray(IntPtr stringArray);
    public static String[] PtrToStringArray(IntPtr stringArray, Encoding encoding);
    private static int CountStrings(IntPtr stringArray);
    public static String[] PtrToStringArray(int count, IntPtr stringArray);
    public static String[] PtrToStringArray(int count, IntPtr stringArray, Encoding encoding);
    public static IntPtr StringToHeap(string s);
    public static IntPtr StringToHeap(string s, Encoding encoding);
    public static IntPtr StringToHeap(string s, int index, int count);
    public static IntPtr StringToHeap(string s, int index, int count, Encoding encoding);
    public static bool ShouldRetrySyscall(int r);
    [CLSCompliantAttribute("False")]
public static bool ShouldRetrySyscall(int r, Errno& errno);
    internal static string EscapeFormatString(string message, Char[] permitted);
    private static bool IsCharPresent(Char[] array, char c);
    internal static Exception CreateExceptionForError(Errno errno);
    internal static Exception CreateExceptionForLastError();
    [CLSCompliantAttribute("False")]
public static void ThrowExceptionForError(Errno errno);
    public static void ThrowExceptionForLastError();
    [CLSCompliantAttribute("False")]
public static void ThrowExceptionForErrorIf(int retval, Errno errno);
    public static void ThrowExceptionForLastErrorIf(int retval);
}
public class Mono.Unix.UnixPath : object {
    public static char DirectorySeparatorChar;
    public static char AltDirectorySeparatorChar;
    public static char PathSeparator;
    public static char VolumeSeparatorChar;
    private static Char[] _InvalidPathChars;
    private static UnixPath();
    public static Char[] GetInvalidPathChars();
    public static string Combine(string path1, String[] paths);
    private static void Combine(StringBuilder path, string part);
    public static string GetDirectoryName(string path);
    public static string GetFileName(string path);
    public static string GetFullPath(string path);
    private static string _GetFullPath(string path);
    public static string GetCanonicalPath(string path);
    private static void GetPathComponents(string path, String[]& components, Int32& lastIndex);
    public static string GetPathRoot(string path);
    public static string GetCompleteRealPath(string path);
    public static string GetRealPath(string path);
    internal static string ReadSymbolicLink(string path);
    private static string ReadSymbolicLink(string path, Errno& errno);
    public static string TryReadLink(string path);
    public static string ReadLink(string path);
    public static bool IsPathRooted(string path);
    internal static void CheckPath(string path);
}
public class Mono.Unix.UnixPipes : ValueType {
    public UnixStream Reading;
    public UnixStream Writing;
    public UnixPipes(UnixStream reading, UnixStream writing);
    public static UnixPipes CreatePipes();
    public virtual bool Equals(object value);
    public sealed virtual bool Equals(UnixPipes value);
    public virtual int GetHashCode();
    public static bool op_Equality(UnixPipes lhs, UnixPipes rhs);
    public static bool op_Inequality(UnixPipes lhs, UnixPipes rhs);
}
public class Mono.Unix.UnixProcess : object {
    private int pid;
    public int Id { get; }
    public bool HasExited { get; }
    public int ExitCode { get; }
    public bool HasSignaled { get; }
    public Signum TerminationSignal { get; }
    public bool HasStopped { get; }
    public Signum StopSignal { get; }
    public int ProcessGroupId { get; public set; }
    public int SessionId { get; }
    internal UnixProcess(int pid);
    public int get_Id();
    public bool get_HasExited();
    private int GetProcessStatus();
    public int get_ExitCode();
    public bool get_HasSignaled();
    public Signum get_TerminationSignal();
    public bool get_HasStopped();
    public Signum get_StopSignal();
    public int get_ProcessGroupId();
    public void set_ProcessGroupId(int value);
    public int get_SessionId();
    public static UnixProcess GetCurrentProcess();
    public static int GetCurrentProcessId();
    public void Kill();
    [CLSCompliantAttribute("False")]
public void Signal(Signum signal);
    public void WaitForExit();
}
public class Mono.Unix.UnixSignal : WaitHandle {
    private int signum;
    private IntPtr signal_info;
    [CompilerGeneratedAttribute]
private static Mono_Posix_RuntimeIsShuttingDown <>f__am$cache2;
    public Signum Signum { get; }
    public RealTimeSignum RealTimeSignum { get; }
    public bool IsRealTimeSignal { get; }
    private SignalInfo* Info { get; }
    public bool IsSet { get; }
    public int Count { get; public set; }
    public UnixSignal(Signum signum);
    public UnixSignal(RealTimeSignum rtsig);
    public Signum get_Signum();
    public RealTimeSignum get_RealTimeSignum();
    public bool get_IsRealTimeSignal();
    private static IntPtr install(int signum);
    private static int uninstall(IntPtr info);
    private static int WaitAny(IntPtr[] infos, int count, int timeout, Mono_Posix_RuntimeIsShuttingDown shutting_down);
    internal static int GetSIGRTMIN();
    internal static int GetSIGRTMAX();
    private void AssertValid();
    private SignalInfo* get_Info();
    public bool get_IsSet();
    public bool Reset();
    public int get_Count();
    public void set_Count(int value);
    protected virtual void Dispose(bool disposing);
    public virtual bool WaitOne();
    public virtual bool WaitOne(TimeSpan timeout, bool exitContext);
    public virtual bool WaitOne(int millisecondsTimeout, bool exitContext);
    public static int WaitAny(UnixSignal[] signals);
    public static int WaitAny(UnixSignal[] signals, TimeSpan timeout);
    public static int WaitAny(UnixSignal[] signals, int millisecondsTimeout);
    [CompilerGeneratedAttribute]
private static int <WaitAny>m__0();
}
public class Mono.Unix.UnixStream : Stream {
    public static int InvalidFileDescriptor;
    public static int StandardInputFileDescriptor;
    public static int StandardOutputFileDescriptor;
    public static int StandardErrorFileDescriptor;
    private bool canSeek;
    private bool canRead;
    private bool canWrite;
    private bool owner;
    private int fileDescriptor;
    private Stat stat;
    public int Handle { get; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    [CLSCompliantAttribute("False")]
public FilePermissions Protection { get; public set; }
    public FileTypes FileType { get; }
    public FileAccessPermissions FileAccessPermissions { get; public set; }
    public FileSpecialAttributes FileSpecialAttributes { get; public set; }
    public UnixUserInfo OwnerUser { get; }
    public long OwnerUserId { get; }
    public UnixGroupInfo OwnerGroup { get; }
    public long OwnerGroupId { get; }
    public UnixStream(int fileDescriptor);
    public UnixStream(int fileDescriptor, bool ownsHandle);
    private sealed virtual override void System.IDisposable.Dispose();
    private void AssertNotDisposed();
    public int get_Handle();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public FilePermissions get_Protection();
    public void set_Protection(FilePermissions value);
    public FileTypes get_FileType();
    public FileAccessPermissions get_FileAccessPermissions();
    public void set_FileAccessPermissions(FileAccessPermissions value);
    public FileSpecialAttributes get_FileSpecialAttributes();
    public void set_FileSpecialAttributes(FileSpecialAttributes value);
    public UnixUserInfo get_OwnerUser();
    public long get_OwnerUserId();
    public UnixGroupInfo get_OwnerGroup();
    public long get_OwnerGroupId();
    private void RefreshStat();
    public void AdviseFileAccessPattern(FileAccessPattern pattern, long offset, long len);
    public void AdviseFileAccessPattern(FileAccessPattern pattern);
    public virtual void Flush();
    public virtual int Read(Byte[] buffer, int offset, int count);
    private void AssertValidBuffer(Byte[] buffer, int offset, int count);
    public int ReadAtOffset(Byte[] buffer, int offset, int count, long fileOffset);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public void WriteAtOffset(Byte[] buffer, int offset, int count, long fileOffset);
    public void SendTo(UnixStream output);
    [CLSCompliantAttribute("False")]
public void SendTo(UnixStream output, ulong count);
    [CLSCompliantAttribute("False")]
public void SendTo(int out_fd, ulong count);
    public void SetOwner(long user, long group);
    public void SetOwner(string user, string group);
    public void SetOwner(string user);
    [CLSCompliantAttribute("False")]
public long GetConfigurationValue(PathconfName name);
    protected virtual void Finalize();
    public virtual void Close();
}
public class Mono.Unix.UnixSymbolicLinkInfo : UnixFileSystemInfo {
    public string Name { get; }
    [ObsoleteAttribute("Use GetContents()")]
public UnixFileSystemInfo Contents { get; }
    public string ContentsPath { get; }
    public bool HasContents { get; }
    public UnixSymbolicLinkInfo(string path);
    internal UnixSymbolicLinkInfo(string path, Stat stat);
    public virtual string get_Name();
    public UnixFileSystemInfo get_Contents();
    public string get_ContentsPath();
    public bool get_HasContents();
    public UnixFileSystemInfo GetContents();
    public void CreateSymbolicLinkTo(string path);
    public void CreateSymbolicLinkTo(UnixFileSystemInfo path);
    public virtual void Delete();
    public virtual void SetOwner(long owner, long group);
    protected virtual bool GetFileStatus(string path, Stat& stat);
    private string ReadLink();
    private string TryReadLink();
}
public class Mono.Unix.UnixUserInfo : object {
    private Passwd passwd;
    public string UserName { get; }
    public string Password { get; }
    public long UserId { get; }
    public UnixGroupInfo Group { get; }
    public long GroupId { get; }
    public string GroupName { get; }
    public string RealName { get; }
    public string HomeDirectory { get; }
    public string ShellProgram { get; }
    public UnixUserInfo(string user);
    [CLSCompliantAttribute("False")]
public UnixUserInfo(UInt32 user);
    public UnixUserInfo(long user);
    public UnixUserInfo(Passwd passwd);
    private static Passwd CopyPasswd(Passwd pw);
    public string get_UserName();
    public string get_Password();
    public long get_UserId();
    public UnixGroupInfo get_Group();
    public long get_GroupId();
    public string get_GroupName();
    public string get_RealName();
    public string get_HomeDirectory();
    public string get_ShellProgram();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public virtual string ToString();
    public static UnixUserInfo GetRealUser();
    public static long GetRealUserId();
    public static string GetLoginName();
    public Passwd ToPasswd();
    public static UnixUserInfo[] GetLocalUsers();
}
[PreserveAttribute]
internal class Newtonsoft.Json.Bson.BsonArray : BsonToken {
    private List`1<BsonToken> _children;
    public BsonType Type { get; }
    public void Add(BsonToken token);
    public virtual BsonType get_Type();
    public sealed virtual IEnumerator`1<BsonToken> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[PreserveAttribute]
internal class Newtonsoft.Json.Bson.BsonBinary : BsonValue {
    [CompilerGeneratedAttribute]
private BsonBinaryType <BinaryType>k__BackingField;
    public BsonBinaryType BinaryType { get; public set; }
    public BsonBinary(Byte[] value, BsonBinaryType binaryType);
    [CompilerGeneratedAttribute]
public BsonBinaryType get_BinaryType();
    [CompilerGeneratedAttribute]
public void set_BinaryType(BsonBinaryType value);
}
[PreserveAttribute]
internal enum Newtonsoft.Json.Bson.BsonBinaryType : Enum {
    public byte value__;
    public static BsonBinaryType Binary;
    public static BsonBinaryType Function;
    [ObsoleteAttribute("This type has been deprecated in the BSON specification. Use Binary instead.")]
public static BsonBinaryType BinaryOld;
    [ObsoleteAttribute("This type has been deprecated in the BSON specification. Use Uuid instead.")]
public static BsonBinaryType UuidOld;
    public static BsonBinaryType Uuid;
    public static BsonBinaryType Md5;
    public static BsonBinaryType UserDefined;
}
[PreserveAttribute]
internal class Newtonsoft.Json.Bson.BsonBinaryWriter : object {
    private static Encoding Encoding;
    private BinaryWriter _writer;
    private Byte[] _largeByteBuffer;
    [CompilerGeneratedAttribute]
private DateTimeKind <DateTimeKindHandling>k__BackingField;
    public DateTimeKind DateTimeKindHandling { get; public set; }
    public BsonBinaryWriter(BinaryWriter writer);
    private static BsonBinaryWriter();
    [CompilerGeneratedAttribute]
public DateTimeKind get_DateTimeKindHandling();
    [CompilerGeneratedAttribute]
public void set_DateTimeKindHandling(DateTimeKind value);
    public void Flush();
    public void Close();
    public void WriteToken(BsonToken t);
    private void WriteTokenInternal(BsonToken t);
    private void WriteString(string s, int byteCount, Nullable`1<int> calculatedlengthPrefix);
    public void WriteUtf8Bytes(string s, int byteCount);
    private int CalculateSize(int stringByteCount);
    private int CalculateSizeWithLength(int stringByteCount, bool includeSize);
    private int CalculateSize(BsonToken t);
}
[PreserveAttribute]
internal class Newtonsoft.Json.Bson.BsonObject : BsonToken {
    private List`1<BsonProperty> _children;
    public BsonType Type { get; }
    public void Add(string name, BsonToken token);
    public virtual BsonType get_Type();
    public sealed virtual IEnumerator`1<BsonProperty> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[PreserveAttribute]
public class Newtonsoft.Json.Bson.BsonObjectId : object {
    [CompilerGeneratedAttribute]
private Byte[] <Value>k__BackingField;
    public Byte[] Value { get; private set; }
    public BsonObjectId(Byte[] value);
    [CompilerGeneratedAttribute]
public Byte[] get_Value();
    [CompilerGeneratedAttribute]
private void set_Value(Byte[] value);
}
[PreserveAttribute]
internal class Newtonsoft.Json.Bson.BsonProperty : object {
    [CompilerGeneratedAttribute]
private BsonString <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private BsonToken <Value>k__BackingField;
    public BsonString Name { get; public set; }
    public BsonToken Value { get; public set; }
    [CompilerGeneratedAttribute]
public BsonString get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(BsonString value);
    [CompilerGeneratedAttribute]
public BsonToken get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(BsonToken value);
}
[PreserveAttribute]
public class Newtonsoft.Json.Bson.BsonReader : JsonReader {
    private static int MaxCharBytesSize;
    private static Byte[] SeqRange1;
    private static Byte[] SeqRange2;
    private static Byte[] SeqRange3;
    private static Byte[] SeqRange4;
    private BinaryReader _reader;
    private List`1<ContainerContext> _stack;
    private Byte[] _byteBuffer;
    private Char[] _charBuffer;
    private BsonType _currentElementType;
    private BsonReaderState _bsonReaderState;
    private ContainerContext _currentContext;
    private bool _readRootValueAsArray;
    private bool _jsonNet35BinaryCompatibility;
    private DateTimeKind _dateTimeKindHandling;
    [ObsoleteAttribute("JsonNet35BinaryCompatibility will be removed in a future version of Json.NET.")]
public bool JsonNet35BinaryCompatibility { get; public set; }
    public bool ReadRootValueAsArray { get; public set; }
    public DateTimeKind DateTimeKindHandling { get; public set; }
    public BsonReader(Stream stream);
    public BsonReader(BinaryReader reader);
    public BsonReader(Stream stream, bool readRootValueAsArray, DateTimeKind dateTimeKindHandling);
    public BsonReader(BinaryReader reader, bool readRootValueAsArray, DateTimeKind dateTimeKindHandling);
    private static BsonReader();
    public bool get_JsonNet35BinaryCompatibility();
    public void set_JsonNet35BinaryCompatibility(bool value);
    public bool get_ReadRootValueAsArray();
    public void set_ReadRootValueAsArray(bool value);
    public DateTimeKind get_DateTimeKindHandling();
    public void set_DateTimeKindHandling(DateTimeKind value);
    private string ReadElement();
    public virtual bool Read();
    public virtual void Close();
    private bool ReadCodeWScope();
    private bool ReadReference();
    private bool ReadNormal();
    private void PopContext();
    private void PushContext(ContainerContext newContext);
    private byte ReadByte();
    private void ReadType(BsonType type);
    private Byte[] ReadBinary(BsonBinaryType& binaryType);
    private string ReadString();
    private string ReadLengthString();
    private string GetString(int length);
    private int GetLastFullCharStop(int start);
    private int BytesInSequence(byte b);
    private void EnsureBuffers();
    private double ReadDouble();
    private int ReadInt32();
    private long ReadInt64();
    private BsonType ReadType();
    private void MovePosition(int count);
    private Byte[] ReadBytes(int count);
}
[PreserveAttribute]
internal class Newtonsoft.Json.Bson.BsonRegex : BsonToken {
    [CompilerGeneratedAttribute]
private BsonString <Pattern>k__BackingField;
    [CompilerGeneratedAttribute]
private BsonString <Options>k__BackingField;
    public BsonString Pattern { get; public set; }
    public BsonString Options { get; public set; }
    public BsonType Type { get; }
    public BsonRegex(string pattern, string options);
    [CompilerGeneratedAttribute]
public BsonString get_Pattern();
    [CompilerGeneratedAttribute]
public void set_Pattern(BsonString value);
    [CompilerGeneratedAttribute]
public BsonString get_Options();
    [CompilerGeneratedAttribute]
public void set_Options(BsonString value);
    public virtual BsonType get_Type();
}
[PreserveAttribute]
internal class Newtonsoft.Json.Bson.BsonString : BsonValue {
    [CompilerGeneratedAttribute]
private int <ByteCount>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeLength>k__BackingField;
    public int ByteCount { get; public set; }
    public bool IncludeLength { get; public set; }
    public BsonString(object value, bool includeLength);
    [CompilerGeneratedAttribute]
public int get_ByteCount();
    [CompilerGeneratedAttribute]
public void set_ByteCount(int value);
    [CompilerGeneratedAttribute]
public bool get_IncludeLength();
    [CompilerGeneratedAttribute]
public void set_IncludeLength(bool value);
}
[PreserveAttribute]
internal abstract class Newtonsoft.Json.Bson.BsonToken : object {
    [CompilerGeneratedAttribute]
private BsonToken <Parent>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CalculatedSize>k__BackingField;
    public BsonType Type { get; }
    public BsonToken Parent { get; public set; }
    public int CalculatedSize { get; public set; }
    public abstract virtual BsonType get_Type();
    [CompilerGeneratedAttribute]
public BsonToken get_Parent();
    [CompilerGeneratedAttribute]
public void set_Parent(BsonToken value);
    [CompilerGeneratedAttribute]
public int get_CalculatedSize();
    [CompilerGeneratedAttribute]
public void set_CalculatedSize(int value);
}
[PreserveAttribute]
internal enum Newtonsoft.Json.Bson.BsonType : Enum {
    public sbyte value__;
    public static BsonType Number;
    public static BsonType String;
    public static BsonType Object;
    public static BsonType Array;
    public static BsonType Binary;
    public static BsonType Undefined;
    public static BsonType Oid;
    public static BsonType Boolean;
    public static BsonType Date;
    public static BsonType Null;
    public static BsonType Regex;
    public static BsonType Reference;
    public static BsonType Code;
    public static BsonType Symbol;
    public static BsonType CodeWScope;
    public static BsonType Integer;
    public static BsonType TimeStamp;
    public static BsonType Long;
    public static BsonType MinKey;
    public static BsonType MaxKey;
}
[PreserveAttribute]
internal class Newtonsoft.Json.Bson.BsonValue : BsonToken {
    private object _value;
    private BsonType _type;
    public object Value { get; }
    public BsonType Type { get; }
    public BsonValue(object value, BsonType type);
    public object get_Value();
    public virtual BsonType get_Type();
}
[PreserveAttribute]
public class Newtonsoft.Json.Bson.BsonWriter : JsonWriter {
    private BsonBinaryWriter _writer;
    private BsonToken _root;
    private BsonToken _parent;
    private string _propertyName;
    public DateTimeKind DateTimeKindHandling { get; public set; }
    public BsonWriter(Stream stream);
    public BsonWriter(BinaryWriter writer);
    public DateTimeKind get_DateTimeKindHandling();
    public void set_DateTimeKindHandling(DateTimeKind value);
    public virtual void Flush();
    protected virtual void WriteEnd(JsonToken token);
    public virtual void WriteComment(string text);
    public virtual void WriteStartConstructor(string name);
    public virtual void WriteRaw(string json);
    public virtual void WriteRawValue(string json);
    public virtual void WriteStartArray();
    public virtual void WriteStartObject();
    public virtual void WritePropertyName(string name);
    public virtual void Close();
    private void AddParent(BsonToken container);
    private void RemoveParent();
    private void AddValue(object value, BsonType type);
    internal void AddToken(BsonToken token);
    public virtual void WriteValue(object value);
    public virtual void WriteNull();
    public virtual void WriteUndefined();
    public virtual void WriteValue(string value);
    public virtual void WriteValue(int value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(UInt32 value);
    public virtual void WriteValue(long value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(ulong value);
    public virtual void WriteValue(float value);
    public virtual void WriteValue(double value);
    public virtual void WriteValue(bool value);
    public virtual void WriteValue(short value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(ushort value);
    public virtual void WriteValue(char value);
    public virtual void WriteValue(byte value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(sbyte value);
    public virtual void WriteValue(decimal value);
    public virtual void WriteValue(DateTime value);
    public virtual void WriteValue(DateTimeOffset value);
    public virtual void WriteValue(Byte[] value);
    public virtual void WriteValue(Guid value);
    public virtual void WriteValue(TimeSpan value);
    public virtual void WriteValue(Uri value);
    public void WriteObjectId(Byte[] value);
    public void WriteRegex(string pattern, string options);
}
[PreserveAttribute]
public enum Newtonsoft.Json.ConstructorHandling : Enum {
    public int value__;
    public static ConstructorHandling Default;
    public static ConstructorHandling AllowNonPublicDefaultConstructor;
}
[PreserveAttribute]
public class Newtonsoft.Json.Converters.BinaryConverter : JsonConverter {
    private static string BinaryTypeName;
    private static string BinaryToArrayName;
    private ReflectionObject _reflectionObject;
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    private Byte[] GetByteArray(object value);
    private void EnsureReflectionObject(Type t);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    private Byte[] ReadByteArray(JsonReader reader);
    public virtual bool CanConvert(Type objectType);
}
[PreserveAttribute]
public class Newtonsoft.Json.Converters.BsonObjectIdConverter : JsonConverter {
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual bool CanConvert(Type objectType);
}
public class Newtonsoft.Json.Converters.ColorConverter : JsonConverter {
    public bool CanRead { get; }
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public virtual bool CanConvert(Type objectType);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual bool get_CanRead();
}
[PreserveAttribute]
public abstract class Newtonsoft.Json.Converters.CustomCreationConverter`1 : JsonConverter {
    public bool CanWrite { get; }
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public abstract virtual T Create(Type objectType);
    public virtual bool CanConvert(Type objectType);
    public virtual bool get_CanWrite();
}
[PreserveAttribute]
public abstract class Newtonsoft.Json.Converters.DateTimeConverterBase : JsonConverter {
    public virtual bool CanConvert(Type objectType);
}
public class Newtonsoft.Json.Converters.EnumerableVectorConverter`1 : JsonConverter {
    private static VectorConverter VectorConverter;
    public bool CanRead { get; }
    private static EnumerableVectorConverter`1();
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public virtual bool CanConvert(Type objectType);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual bool get_CanRead();
}
public class Newtonsoft.Json.Converters.HashSetConverter : JsonConverter {
    public bool CanWrite { get; }
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual bool CanConvert(Type objectType);
    public virtual bool get_CanWrite();
}
[PreserveAttribute]
public class Newtonsoft.Json.Converters.IsoDateTimeConverter : DateTimeConverterBase {
    private static string DefaultDateTimeFormat;
    private DateTimeStyles _dateTimeStyles;
    private string _dateTimeFormat;
    private CultureInfo _culture;
    public DateTimeStyles DateTimeStyles { get; public set; }
    public string DateTimeFormat { get; public set; }
    public CultureInfo Culture { get; public set; }
    public DateTimeStyles get_DateTimeStyles();
    public void set_DateTimeStyles(DateTimeStyles value);
    public string get_DateTimeFormat();
    public void set_DateTimeFormat(string value);
    public CultureInfo get_Culture();
    public void set_Culture(CultureInfo value);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
}
internal interface Newtonsoft.Json.Converters.IXmlDeclaration {
    public string Version { get; }
    public string Encoding { get; public set; }
    public string Standalone { get; public set; }
    public abstract virtual string get_Version();
    public abstract virtual string get_Encoding();
    public abstract virtual void set_Encoding(string value);
    public abstract virtual string get_Standalone();
    public abstract virtual void set_Standalone(string value);
}
internal interface Newtonsoft.Json.Converters.IXmlDocument {
    public IXmlElement DocumentElement { get; }
    public abstract virtual IXmlNode CreateComment(string text);
    public abstract virtual IXmlNode CreateTextNode(string text);
    public abstract virtual IXmlNode CreateCDataSection(string data);
    public abstract virtual IXmlNode CreateWhitespace(string text);
    public abstract virtual IXmlNode CreateSignificantWhitespace(string text);
    public abstract virtual IXmlNode CreateXmlDeclaration(string version, string encoding, string standalone);
    public abstract virtual IXmlNode CreateXmlDocumentType(string name, string publicId, string systemId, string internalSubset);
    public abstract virtual IXmlNode CreateProcessingInstruction(string target, string data);
    public abstract virtual IXmlElement CreateElement(string elementName);
    public abstract virtual IXmlElement CreateElement(string qualifiedName, string namespaceUri);
    public abstract virtual IXmlNode CreateAttribute(string name, string value);
    public abstract virtual IXmlNode CreateAttribute(string qualifiedName, string namespaceUri, string value);
    public abstract virtual IXmlElement get_DocumentElement();
}
internal interface Newtonsoft.Json.Converters.IXmlDocumentType {
    public string Name { get; }
    public string System { get; }
    public string Public { get; }
    public string InternalSubset { get; }
    public abstract virtual string get_Name();
    public abstract virtual string get_System();
    public abstract virtual string get_Public();
    public abstract virtual string get_InternalSubset();
}
internal interface Newtonsoft.Json.Converters.IXmlElement {
    public bool IsEmpty { get; }
    public abstract virtual void SetAttributeNode(IXmlNode attribute);
    public abstract virtual string GetPrefixOfNamespace(string namespaceUri);
    public abstract virtual bool get_IsEmpty();
}
internal interface Newtonsoft.Json.Converters.IXmlNode {
    public XmlNodeType NodeType { get; }
    public string LocalName { get; }
    public List`1<IXmlNode> ChildNodes { get; }
    public List`1<IXmlNode> Attributes { get; }
    public IXmlNode ParentNode { get; }
    public string Value { get; public set; }
    public string NamespaceUri { get; }
    public object WrappedNode { get; }
    public abstract virtual XmlNodeType get_NodeType();
    public abstract virtual string get_LocalName();
    public abstract virtual List`1<IXmlNode> get_ChildNodes();
    public abstract virtual List`1<IXmlNode> get_Attributes();
    public abstract virtual IXmlNode get_ParentNode();
    public abstract virtual string get_Value();
    public abstract virtual void set_Value(string value);
    public abstract virtual IXmlNode AppendChild(IXmlNode newChild);
    public abstract virtual string get_NamespaceUri();
    public abstract virtual object get_WrappedNode();
}
[PreserveAttribute]
public class Newtonsoft.Json.Converters.JavaScriptDateTimeConverter : DateTimeConverterBase {
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
}
[PreserveAttribute]
public class Newtonsoft.Json.Converters.KeyValuePairConverter : JsonConverter {
    private static string KeyName;
    private static string ValueName;
    private static ThreadSafeStore`2<Type, ReflectionObject> ReflectionObjectPerType;
    private static KeyValuePairConverter();
    private static ReflectionObject InitializeReflectionObject(Type t);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual bool CanConvert(Type objectType);
}
public class Newtonsoft.Json.Converters.Matrix4x4Converter : JsonConverter {
    public bool CanRead { get; }
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual bool get_CanRead();
    public virtual bool CanConvert(Type objectType);
}
public class Newtonsoft.Json.Converters.QuaternionConverter : JsonConverter {
    public bool CanRead { get; }
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public virtual bool CanConvert(Type objectType);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual bool get_CanRead();
}
[PreserveAttribute]
public class Newtonsoft.Json.Converters.RegexConverter : JsonConverter {
    private static string PatternName;
    private static string OptionsName;
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    private bool HasFlag(RegexOptions options, RegexOptions flag);
    private void WriteBson(BsonWriter writer, Regex regex);
    private void WriteJson(JsonWriter writer, Regex regex, JsonSerializer serializer);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    private object ReadRegexString(JsonReader reader);
    private Regex ReadRegexObject(JsonReader reader, JsonSerializer serializer);
    public virtual bool CanConvert(Type objectType);
}
public class Newtonsoft.Json.Converters.ResolutionConverter : JsonConverter {
    public bool CanRead { get; }
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public virtual bool CanConvert(Type objectType);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual bool get_CanRead();
}
[PreserveAttribute]
public class Newtonsoft.Json.Converters.StringEnumConverter : JsonConverter {
    [CompilerGeneratedAttribute]
private bool <CamelCaseText>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowIntegerValues>k__BackingField;
    public bool CamelCaseText { get; public set; }
    public bool AllowIntegerValues { get; public set; }
    public StringEnumConverter(bool camelCaseText);
    [CompilerGeneratedAttribute]
public bool get_CamelCaseText();
    [CompilerGeneratedAttribute]
public void set_CamelCaseText(bool value);
    [CompilerGeneratedAttribute]
public bool get_AllowIntegerValues();
    [CompilerGeneratedAttribute]
public void set_AllowIntegerValues(bool value);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual bool CanConvert(Type objectType);
}
public class Newtonsoft.Json.Converters.UriConverter : JsonConverter {
    public virtual bool CanConvert(Type objectType);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
}
[PreserveAttribute]
public class Newtonsoft.Json.Converters.VectorConverter : JsonConverter {
    private static Type V2;
    private static Type V3;
    private static Type V4;
    [CompilerGeneratedAttribute]
private bool <EnableVector2>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EnableVector3>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EnableVector4>k__BackingField;
    public bool EnableVector2 { get; public set; }
    public bool EnableVector3 { get; public set; }
    public bool EnableVector4 { get; public set; }
    public VectorConverter(bool enableVector2, bool enableVector3, bool enableVector4);
    private static VectorConverter();
    [CompilerGeneratedAttribute]
public bool get_EnableVector2();
    [CompilerGeneratedAttribute]
public void set_EnableVector2(bool value);
    [CompilerGeneratedAttribute]
public bool get_EnableVector3();
    [CompilerGeneratedAttribute]
public void set_EnableVector3(bool value);
    [CompilerGeneratedAttribute]
public bool get_EnableVector4();
    [CompilerGeneratedAttribute]
public void set_EnableVector4(bool value);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    private static void WriteVector(JsonWriter writer, float x, float y, Nullable`1<float> z, Nullable`1<float> w);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual bool CanConvert(Type objectType);
    private static Vector2 PopulateVector2(JsonReader reader);
    private static Vector3 PopulateVector3(JsonReader reader);
    private static Vector4 PopulateVector4(JsonReader reader);
}
[PreserveAttribute]
public class Newtonsoft.Json.Converters.VersionConverter : JsonConverter {
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual bool CanConvert(Type objectType);
}
internal class Newtonsoft.Json.Converters.XAttributeWrapper : XObjectWrapper {
    private XAttribute Attribute { get; }
    public string Value { get; public set; }
    public string LocalName { get; }
    public string NamespaceUri { get; }
    public IXmlNode ParentNode { get; }
    public XAttributeWrapper(XAttribute attribute);
    private XAttribute get_Attribute();
    public virtual string get_Value();
    public virtual void set_Value(string value);
    public virtual string get_LocalName();
    public virtual string get_NamespaceUri();
    public virtual IXmlNode get_ParentNode();
}
internal class Newtonsoft.Json.Converters.XCommentWrapper : XObjectWrapper {
    private XComment Text { get; }
    public string Value { get; public set; }
    public IXmlNode ParentNode { get; }
    public XCommentWrapper(XComment text);
    private XComment get_Text();
    public virtual string get_Value();
    public virtual void set_Value(string value);
    public virtual IXmlNode get_ParentNode();
}
internal class Newtonsoft.Json.Converters.XContainerWrapper : XObjectWrapper {
    private List`1<IXmlNode> _childNodes;
    private XContainer Container { get; }
    public List`1<IXmlNode> ChildNodes { get; }
    public IXmlNode ParentNode { get; }
    public XContainerWrapper(XContainer container);
    private XContainer get_Container();
    public virtual List`1<IXmlNode> get_ChildNodes();
    public virtual IXmlNode get_ParentNode();
    internal static IXmlNode WrapNode(XObject node);
    public virtual IXmlNode AppendChild(IXmlNode newChild);
}
internal class Newtonsoft.Json.Converters.XDeclarationWrapper : XObjectWrapper {
    [CompilerGeneratedAttribute]
private XDeclaration <Declaration>k__BackingField;
    internal XDeclaration Declaration { get; private set; }
    public XmlNodeType NodeType { get; }
    public string Version { get; }
    public string Encoding { get; public set; }
    public string Standalone { get; public set; }
    public XDeclarationWrapper(XDeclaration declaration);
    [CompilerGeneratedAttribute]
internal XDeclaration get_Declaration();
    [CompilerGeneratedAttribute]
private void set_Declaration(XDeclaration value);
    public virtual XmlNodeType get_NodeType();
    public sealed virtual string get_Version();
    public sealed virtual string get_Encoding();
    public sealed virtual void set_Encoding(string value);
    public sealed virtual string get_Standalone();
    public sealed virtual void set_Standalone(string value);
}
internal class Newtonsoft.Json.Converters.XDocumentTypeWrapper : XObjectWrapper {
    private XDocumentType _documentType;
    public string Name { get; }
    public string System { get; }
    public string Public { get; }
    public string InternalSubset { get; }
    public string LocalName { get; }
    public XDocumentTypeWrapper(XDocumentType documentType);
    public sealed virtual string get_Name();
    public sealed virtual string get_System();
    public sealed virtual string get_Public();
    public sealed virtual string get_InternalSubset();
    public virtual string get_LocalName();
}
internal class Newtonsoft.Json.Converters.XDocumentWrapper : XContainerWrapper {
    private XDocument Document { get; }
    public List`1<IXmlNode> ChildNodes { get; }
    public IXmlElement DocumentElement { get; }
    public XDocumentWrapper(XDocument document);
    private XDocument get_Document();
    public virtual List`1<IXmlNode> get_ChildNodes();
    public sealed virtual IXmlNode CreateComment(string text);
    public sealed virtual IXmlNode CreateTextNode(string text);
    public sealed virtual IXmlNode CreateCDataSection(string data);
    public sealed virtual IXmlNode CreateWhitespace(string text);
    public sealed virtual IXmlNode CreateSignificantWhitespace(string text);
    public sealed virtual IXmlNode CreateXmlDeclaration(string version, string encoding, string standalone);
    public sealed virtual IXmlNode CreateXmlDocumentType(string name, string publicId, string systemId, string internalSubset);
    public sealed virtual IXmlNode CreateProcessingInstruction(string target, string data);
    public sealed virtual IXmlElement CreateElement(string elementName);
    public sealed virtual IXmlElement CreateElement(string qualifiedName, string namespaceUri);
    public sealed virtual IXmlNode CreateAttribute(string name, string value);
    public sealed virtual IXmlNode CreateAttribute(string qualifiedName, string namespaceUri, string value);
    public sealed virtual IXmlElement get_DocumentElement();
    public virtual IXmlNode AppendChild(IXmlNode newChild);
}
internal class Newtonsoft.Json.Converters.XElementWrapper : XContainerWrapper {
    private List`1<IXmlNode> _attributes;
    private XElement Element { get; }
    public List`1<IXmlNode> Attributes { get; }
    public string Value { get; public set; }
    public string LocalName { get; }
    public string NamespaceUri { get; }
    public bool IsEmpty { get; }
    public XElementWrapper(XElement element);
    private XElement get_Element();
    public sealed virtual void SetAttributeNode(IXmlNode attribute);
    public virtual List`1<IXmlNode> get_Attributes();
    public virtual IXmlNode AppendChild(IXmlNode newChild);
    public virtual string get_Value();
    public virtual void set_Value(string value);
    public virtual string get_LocalName();
    public virtual string get_NamespaceUri();
    public sealed virtual string GetPrefixOfNamespace(string namespaceUri);
    public sealed virtual bool get_IsEmpty();
}
internal class Newtonsoft.Json.Converters.XmlDeclarationWrapper : XmlNodeWrapper {
    private XmlDeclaration _declaration;
    public string Version { get; }
    public string Encoding { get; public set; }
    public string Standalone { get; public set; }
    public XmlDeclarationWrapper(XmlDeclaration declaration);
    public sealed virtual string get_Version();
    public sealed virtual string get_Encoding();
    public sealed virtual void set_Encoding(string value);
    public sealed virtual string get_Standalone();
    public sealed virtual void set_Standalone(string value);
}
internal class Newtonsoft.Json.Converters.XmlDocumentTypeWrapper : XmlNodeWrapper {
    private XmlDocumentType _documentType;
    public string Name { get; }
    public string System { get; }
    public string Public { get; }
    public string InternalSubset { get; }
    public string LocalName { get; }
    public XmlDocumentTypeWrapper(XmlDocumentType documentType);
    public sealed virtual string get_Name();
    public sealed virtual string get_System();
    public sealed virtual string get_Public();
    public sealed virtual string get_InternalSubset();
    public virtual string get_LocalName();
}
internal class Newtonsoft.Json.Converters.XmlDocumentWrapper : XmlNodeWrapper {
    private XmlDocument _document;
    public IXmlElement DocumentElement { get; }
    public XmlDocumentWrapper(XmlDocument document);
    public sealed virtual IXmlNode CreateComment(string data);
    public sealed virtual IXmlNode CreateTextNode(string text);
    public sealed virtual IXmlNode CreateCDataSection(string data);
    public sealed virtual IXmlNode CreateWhitespace(string text);
    public sealed virtual IXmlNode CreateSignificantWhitespace(string text);
    public sealed virtual IXmlNode CreateXmlDeclaration(string version, string encoding, string standalone);
    public sealed virtual IXmlNode CreateXmlDocumentType(string name, string publicId, string systemId, string internalSubset);
    public sealed virtual IXmlNode CreateProcessingInstruction(string target, string data);
    public sealed virtual IXmlElement CreateElement(string elementName);
    public sealed virtual IXmlElement CreateElement(string qualifiedName, string namespaceUri);
    public sealed virtual IXmlNode CreateAttribute(string name, string value);
    public sealed virtual IXmlNode CreateAttribute(string qualifiedName, string namespaceUri, string value);
    public sealed virtual IXmlElement get_DocumentElement();
}
internal class Newtonsoft.Json.Converters.XmlElementWrapper : XmlNodeWrapper {
    private XmlElement _element;
    public bool IsEmpty { get; }
    public XmlElementWrapper(XmlElement element);
    public sealed virtual void SetAttributeNode(IXmlNode attribute);
    public sealed virtual string GetPrefixOfNamespace(string namespaceUri);
    public sealed virtual bool get_IsEmpty();
}
[PreserveAttribute]
public class Newtonsoft.Json.Converters.XmlNodeConverter : JsonConverter {
    private static string TextName;
    private static string CommentName;
    private static string CDataName;
    private static string WhitespaceName;
    private static string SignificantWhitespaceName;
    private static string DeclarationName;
    private static string JsonNamespaceUri;
    [CompilerGeneratedAttribute]
private string <DeserializeRootElementName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <WriteArrayAttribute>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <OmitRootObject>k__BackingField;
    public string DeserializeRootElementName { get; public set; }
    public bool WriteArrayAttribute { get; public set; }
    public bool OmitRootObject { get; public set; }
    [CompilerGeneratedAttribute]
public string get_DeserializeRootElementName();
    [CompilerGeneratedAttribute]
public void set_DeserializeRootElementName(string value);
    [CompilerGeneratedAttribute]
public bool get_WriteArrayAttribute();
    [CompilerGeneratedAttribute]
public void set_WriteArrayAttribute(bool value);
    [CompilerGeneratedAttribute]
public bool get_OmitRootObject();
    [CompilerGeneratedAttribute]
public void set_OmitRootObject(bool value);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    private IXmlNode WrapXml(object value);
    private void PushParentNamespaces(IXmlNode node, XmlNamespaceManager manager);
    private string ResolveFullName(IXmlNode node, XmlNamespaceManager manager);
    private string GetPropertyName(IXmlNode node, XmlNamespaceManager manager);
    private bool IsArray(IXmlNode node);
    private void SerializeGroupedNodes(JsonWriter writer, IXmlNode node, XmlNamespaceManager manager, bool writePropertyName);
    private void SerializeNode(JsonWriter writer, IXmlNode node, XmlNamespaceManager manager, bool writePropertyName);
    private static bool AllSameName(IXmlNode node);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    private void DeserializeValue(JsonReader reader, IXmlDocument document, XmlNamespaceManager manager, string propertyName, IXmlNode currentNode);
    private void ReadElement(JsonReader reader, IXmlDocument document, IXmlNode currentNode, string propertyName, XmlNamespaceManager manager);
    private void CreateElement(JsonReader reader, IXmlDocument document, IXmlNode currentNode, string elementName, XmlNamespaceManager manager, string elementPrefix, Dictionary`2<string, string> attributeNameValues);
    private static void AddAttribute(JsonReader reader, IXmlDocument document, IXmlNode currentNode, string attributeName, XmlNamespaceManager manager, string attributePrefix);
    private string ConvertTokenToXmlValue(JsonReader reader);
    private void ReadArrayElements(JsonReader reader, IXmlDocument document, string propertyName, IXmlNode currentNode, XmlNamespaceManager manager);
    private void AddJsonArrayAttribute(IXmlElement element, IXmlDocument document);
    private Dictionary`2<string, string> ReadAttributeElements(JsonReader reader, XmlNamespaceManager manager);
    private void CreateInstruction(JsonReader reader, IXmlDocument document, IXmlNode currentNode, string propertyName);
    private void CreateDocumentType(JsonReader reader, IXmlDocument document, IXmlNode currentNode);
    private IXmlElement CreateElement(string elementName, IXmlDocument document, string elementPrefix, XmlNamespaceManager manager);
    private void DeserializeNode(JsonReader reader, IXmlDocument document, XmlNamespaceManager manager, IXmlNode currentNode);
    private bool IsNamespaceAttribute(string attributeName, String& prefix);
    private bool ValueAttributes(List`1<IXmlNode> c);
    public virtual bool CanConvert(Type valueType);
}
internal class Newtonsoft.Json.Converters.XmlNodeWrapper : object {
    private XmlNode _node;
    private List`1<IXmlNode> _childNodes;
    private List`1<IXmlNode> _attributes;
    public object WrappedNode { get; }
    public XmlNodeType NodeType { get; }
    public string LocalName { get; }
    public List`1<IXmlNode> ChildNodes { get; }
    public List`1<IXmlNode> Attributes { get; }
    public IXmlNode ParentNode { get; }
    public string Value { get; public set; }
    public string NamespaceUri { get; }
    public XmlNodeWrapper(XmlNode node);
    public sealed virtual object get_WrappedNode();
    public sealed virtual XmlNodeType get_NodeType();
    public virtual string get_LocalName();
    public sealed virtual List`1<IXmlNode> get_ChildNodes();
    internal static IXmlNode WrapNode(XmlNode node);
    public sealed virtual List`1<IXmlNode> get_Attributes();
    public sealed virtual IXmlNode get_ParentNode();
    public sealed virtual string get_Value();
    public sealed virtual void set_Value(string value);
    public sealed virtual IXmlNode AppendChild(IXmlNode newChild);
    public sealed virtual string get_NamespaceUri();
}
internal class Newtonsoft.Json.Converters.XObjectWrapper : object {
    private static List`1<IXmlNode> EmptyChildNodes;
    private XObject _xmlObject;
    public object WrappedNode { get; }
    public XmlNodeType NodeType { get; }
    public string LocalName { get; }
    public List`1<IXmlNode> ChildNodes { get; }
    public List`1<IXmlNode> Attributes { get; }
    public IXmlNode ParentNode { get; }
    public string Value { get; public set; }
    public string NamespaceUri { get; }
    public XObjectWrapper(XObject xmlObject);
    private static XObjectWrapper();
    public sealed virtual object get_WrappedNode();
    public virtual XmlNodeType get_NodeType();
    public virtual string get_LocalName();
    public virtual List`1<IXmlNode> get_ChildNodes();
    public virtual List`1<IXmlNode> get_Attributes();
    public virtual IXmlNode get_ParentNode();
    public virtual string get_Value();
    public virtual void set_Value(string value);
    public virtual IXmlNode AppendChild(IXmlNode newChild);
    public virtual string get_NamespaceUri();
}
internal class Newtonsoft.Json.Converters.XProcessingInstructionWrapper : XObjectWrapper {
    private XProcessingInstruction ProcessingInstruction { get; }
    public string LocalName { get; }
    public string Value { get; public set; }
    public XProcessingInstructionWrapper(XProcessingInstruction processingInstruction);
    private XProcessingInstruction get_ProcessingInstruction();
    public virtual string get_LocalName();
    public virtual string get_Value();
    public virtual void set_Value(string value);
}
internal class Newtonsoft.Json.Converters.XTextWrapper : XObjectWrapper {
    private XText Text { get; }
    public string Value { get; public set; }
    public IXmlNode ParentNode { get; }
    public XTextWrapper(XText text);
    private XText get_Text();
    public virtual string get_Value();
    public virtual void set_Value(string value);
    public virtual IXmlNode get_ParentNode();
}
[PreserveAttribute]
public enum Newtonsoft.Json.DateFormatHandling : Enum {
    public int value__;
    public static DateFormatHandling IsoDateFormat;
    public static DateFormatHandling MicrosoftDateFormat;
}
[PreserveAttribute]
public enum Newtonsoft.Json.DateParseHandling : Enum {
    public int value__;
    public static DateParseHandling None;
    public static DateParseHandling DateTime;
    public static DateParseHandling DateTimeOffset;
}
[PreserveAttribute]
public enum Newtonsoft.Json.DateTimeZoneHandling : Enum {
    public int value__;
    public static DateTimeZoneHandling Local;
    public static DateTimeZoneHandling Utc;
    public static DateTimeZoneHandling Unspecified;
    public static DateTimeZoneHandling RoundtripKind;
}
[PreserveAttribute]
[FlagsAttribute]
public enum Newtonsoft.Json.DefaultValueHandling : Enum {
    public int value__;
    public static DefaultValueHandling Include;
    public static DefaultValueHandling Ignore;
    public static DefaultValueHandling Populate;
    public static DefaultValueHandling IgnoreAndPopulate;
}
[PreserveAttribute]
public enum Newtonsoft.Json.FloatFormatHandling : Enum {
    public int value__;
    public static FloatFormatHandling String;
    public static FloatFormatHandling Symbol;
    public static FloatFormatHandling DefaultValue;
}
[PreserveAttribute]
public enum Newtonsoft.Json.FloatParseHandling : Enum {
    public int value__;
    public static FloatParseHandling Double;
    public static FloatParseHandling Decimal;
}
[PreserveAttribute]
public enum Newtonsoft.Json.Formatting : Enum {
    public int value__;
    public static Formatting None;
    public static Formatting Indented;
}
[PreserveAttribute]
public interface Newtonsoft.Json.IArrayPool`1 {
    public abstract virtual T[] Rent(int minimumLength);
    public abstract virtual void Return(T[] array);
}
[PreserveAttribute]
public interface Newtonsoft.Json.IJsonLineInfo {
    public int LineNumber { get; }
    public int LinePosition { get; }
    public abstract virtual bool HasLineInfo();
    public abstract virtual int get_LineNumber();
    public abstract virtual int get_LinePosition();
}
[PreserveAttribute]
[AttributeUsageAttribute("1028")]
public class Newtonsoft.Json.JsonArrayAttribute : JsonContainerAttribute {
    private bool _allowNullItems;
    public bool AllowNullItems { get; public set; }
    public JsonArrayAttribute(bool allowNullItems);
    public JsonArrayAttribute(string id);
    public bool get_AllowNullItems();
    public void set_AllowNullItems(bool value);
}
[PreserveAttribute]
[AttributeUsageAttribute("32")]
public class Newtonsoft.Json.JsonConstructorAttribute : Attribute {
}
[AttributeUsageAttribute("1028")]
[PreserveAttribute]
public abstract class Newtonsoft.Json.JsonContainerAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Title>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ItemConverterType>k__BackingField;
    [CompilerGeneratedAttribute]
private Object[] <ItemConverterParameters>k__BackingField;
    internal Nullable`1<bool> _isReference;
    internal Nullable`1<bool> _itemIsReference;
    internal Nullable`1<ReferenceLoopHandling> _itemReferenceLoopHandling;
    internal Nullable`1<TypeNameHandling> _itemTypeNameHandling;
    public string Id { get; public set; }
    public string Title { get; public set; }
    public string Description { get; public set; }
    public Type ItemConverterType { get; public set; }
    public Object[] ItemConverterParameters { get; public set; }
    public bool IsReference { get; public set; }
    public bool ItemIsReference { get; public set; }
    public ReferenceLoopHandling ItemReferenceLoopHandling { get; public set; }
    public TypeNameHandling ItemTypeNameHandling { get; public set; }
    protected JsonContainerAttribute(string id);
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(string value);
    [CompilerGeneratedAttribute]
public string get_Title();
    [CompilerGeneratedAttribute]
public void set_Title(string value);
    [CompilerGeneratedAttribute]
public string get_Description();
    [CompilerGeneratedAttribute]
public void set_Description(string value);
    [CompilerGeneratedAttribute]
public Type get_ItemConverterType();
    [CompilerGeneratedAttribute]
public void set_ItemConverterType(Type value);
    [CompilerGeneratedAttribute]
public Object[] get_ItemConverterParameters();
    [CompilerGeneratedAttribute]
public void set_ItemConverterParameters(Object[] value);
    public bool get_IsReference();
    public void set_IsReference(bool value);
    public bool get_ItemIsReference();
    public void set_ItemIsReference(bool value);
    public ReferenceLoopHandling get_ItemReferenceLoopHandling();
    public void set_ItemReferenceLoopHandling(ReferenceLoopHandling value);
    public TypeNameHandling get_ItemTypeNameHandling();
    public void set_ItemTypeNameHandling(TypeNameHandling value);
}
[PreserveAttribute]
internal enum Newtonsoft.Json.JsonContainerType : Enum {
    public int value__;
    public static JsonContainerType None;
    public static JsonContainerType Object;
    public static JsonContainerType Array;
    public static JsonContainerType Constructor;
}
[PreserveAttribute]
public static class Newtonsoft.Json.JsonConvert : object {
    [CompilerGeneratedAttribute]
private static Func`1<JsonSerializerSettings> <DefaultSettings>k__BackingField;
    public static string True;
    public static string False;
    public static string Null;
    public static string Undefined;
    public static string PositiveInfinity;
    public static string NegativeInfinity;
    public static string NaN;
    private static JsonSerializerSettings InitialSerializerSettings;
    public static Func`1<JsonSerializerSettings> DefaultSettings { get; public set; }
    private static JsonConvert();
    [CompilerGeneratedAttribute]
public static Func`1<JsonSerializerSettings> get_DefaultSettings();
    [CompilerGeneratedAttribute]
public static void set_DefaultSettings(Func`1<JsonSerializerSettings> value);
    internal static JsonSerializerSettings GetDefaultSettings();
    public static string ToString(DateTime value);
    public static string ToString(DateTime value, DateFormatHandling format, DateTimeZoneHandling timeZoneHandling);
    public static string ToString(DateTimeOffset value);
    public static string ToString(DateTimeOffset value, DateFormatHandling format);
    public static string ToString(bool value);
    public static string ToString(char value);
    public static string ToString(Enum value);
    public static string ToString(int value);
    public static string ToString(short value);
    [CLSCompliantAttribute("False")]
public static string ToString(ushort value);
    [CLSCompliantAttribute("False")]
public static string ToString(UInt32 value);
    public static string ToString(long value);
    [CLSCompliantAttribute("False")]
public static string ToString(ulong value);
    public static string ToString(float value);
    internal static string ToString(float value, FloatFormatHandling floatFormatHandling, char quoteChar, bool nullable);
    private static string EnsureFloatFormat(double value, string text, FloatFormatHandling floatFormatHandling, char quoteChar, bool nullable);
    public static string ToString(double value);
    internal static string ToString(double value, FloatFormatHandling floatFormatHandling, char quoteChar, bool nullable);
    private static string EnsureDecimalPlace(double value, string text);
    private static string EnsureDecimalPlace(string text);
    public static string ToString(byte value);
    [CLSCompliantAttribute("False")]
public static string ToString(sbyte value);
    public static string ToString(decimal value);
    public static string ToString(Guid value);
    internal static string ToString(Guid value, char quoteChar);
    public static string ToString(TimeSpan value);
    internal static string ToString(TimeSpan value, char quoteChar);
    public static string ToString(Uri value);
    internal static string ToString(Uri value, char quoteChar);
    public static string ToString(string value);
    public static string ToString(string value, char delimiter);
    public static string ToString(string value, char delimiter, StringEscapeHandling stringEscapeHandling);
    public static string ToString(object value);
    public static string SerializeObject(object value);
    public static string SerializeObject(object value, Formatting formatting);
    public static string SerializeObject(object value, JsonConverter[] converters);
    public static string SerializeObject(object value, Formatting formatting, JsonConverter[] converters);
    public static string SerializeObject(object value, JsonSerializerSettings settings);
    public static string SerializeObject(object value, Type type, JsonSerializerSettings settings);
    public static string SerializeObject(object value, Formatting formatting, JsonSerializerSettings settings);
    public static string SerializeObject(object value, Type type, Formatting formatting, JsonSerializerSettings settings);
    private static string SerializeObjectInternal(object value, Type type, JsonSerializer jsonSerializer);
    public static object DeserializeObject(string value);
    public static object DeserializeObject(string value, JsonSerializerSettings settings);
    public static object DeserializeObject(string value, Type type);
    public static T DeserializeObject(string value);
    public static T DeserializeAnonymousType(string value, T anonymousTypeObject);
    public static T DeserializeAnonymousType(string value, T anonymousTypeObject, JsonSerializerSettings settings);
    public static T DeserializeObject(string value, JsonConverter[] converters);
    public static T DeserializeObject(string value, JsonSerializerSettings settings);
    public static object DeserializeObject(string value, Type type, JsonConverter[] converters);
    public static object DeserializeObject(string value, Type type, JsonSerializerSettings settings);
    public static void PopulateObject(string value, object target);
    public static void PopulateObject(string value, object target, JsonSerializerSettings settings);
    public static string SerializeXmlNode(XmlNode node);
    public static string SerializeXmlNode(XmlNode node, Formatting formatting);
    public static string SerializeXmlNode(XmlNode node, Formatting formatting, bool omitRootObject);
    public static XmlDocument DeserializeXmlNode(string value);
    public static XmlDocument DeserializeXmlNode(string value, string deserializeRootElementName);
    public static XmlDocument DeserializeXmlNode(string value, string deserializeRootElementName, bool writeArrayAttribute);
    public static string SerializeXNode(XObject node);
    public static string SerializeXNode(XObject node, Formatting formatting);
    public static string SerializeXNode(XObject node, Formatting formatting, bool omitRootObject);
    public static XDocument DeserializeXNode(string value);
    public static XDocument DeserializeXNode(string value, string deserializeRootElementName);
    public static XDocument DeserializeXNode(string value, string deserializeRootElementName, bool writeArrayAttribute);
}
[PreserveAttribute]
public abstract class Newtonsoft.Json.JsonConverter : object {
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public abstract virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public abstract virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public abstract virtual bool CanConvert(Type objectType);
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
}
[PreserveAttribute]
[AttributeUsageAttribute("3484")]
public class Newtonsoft.Json.JsonConverterAttribute : Attribute {
    private Type _converterType;
    [CompilerGeneratedAttribute]
private Object[] <ConverterParameters>k__BackingField;
    public Type ConverterType { get; }
    public Object[] ConverterParameters { get; private set; }
    public JsonConverterAttribute(Type converterType);
    public JsonConverterAttribute(Type converterType, Object[] converterParameters);
    public Type get_ConverterType();
    [CompilerGeneratedAttribute]
public Object[] get_ConverterParameters();
    [CompilerGeneratedAttribute]
private void set_ConverterParameters(Object[] value);
}
[PreserveAttribute]
public class Newtonsoft.Json.JsonConverterCollection : Collection`1<JsonConverter> {
}
[AttributeUsageAttribute("1028")]
[PreserveAttribute]
public class Newtonsoft.Json.JsonDictionaryAttribute : JsonContainerAttribute {
    public JsonDictionaryAttribute(string id);
}
[PreserveAttribute]
public class Newtonsoft.Json.JsonException : Exception {
    public JsonException(string message);
    public JsonException(string message, Exception innerException);
    public JsonException(SerializationInfo info, StreamingContext context);
    internal static JsonException Create(IJsonLineInfo lineInfo, string path, string message);
}
[AttributeUsageAttribute("384")]
[PreserveAttribute]
public class Newtonsoft.Json.JsonExtensionDataAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <WriteData>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ReadData>k__BackingField;
    public bool WriteData { get; public set; }
    public bool ReadData { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_WriteData();
    [CompilerGeneratedAttribute]
public void set_WriteData(bool value);
    [CompilerGeneratedAttribute]
public bool get_ReadData();
    [CompilerGeneratedAttribute]
public void set_ReadData(bool value);
}
[AttributeUsageAttribute("384")]
[PreserveAttribute]
public class Newtonsoft.Json.JsonIgnoreAttribute : Attribute {
}
[PreserveAttribute]
[AttributeUsageAttribute("1036")]
public class Newtonsoft.Json.JsonObjectAttribute : JsonContainerAttribute {
    private MemberSerialization _memberSerialization;
    internal Nullable`1<Required> _itemRequired;
    public MemberSerialization MemberSerialization { get; public set; }
    public Required ItemRequired { get; public set; }
    public JsonObjectAttribute(MemberSerialization memberSerialization);
    public JsonObjectAttribute(string id);
    public MemberSerialization get_MemberSerialization();
    public void set_MemberSerialization(MemberSerialization value);
    public Required get_ItemRequired();
    public void set_ItemRequired(Required value);
}
[PreserveAttribute]
internal class Newtonsoft.Json.JsonPosition : ValueType {
    private static Char[] SpecialCharacters;
    internal JsonContainerType Type;
    internal int Position;
    internal string PropertyName;
    internal bool HasIndex;
    public JsonPosition(JsonContainerType type);
    private static JsonPosition();
    internal int CalculateLength();
    internal void WriteTo(StringBuilder sb);
    internal static bool TypeHasIndex(JsonContainerType type);
    internal static string BuildPath(List`1<JsonPosition> positions, Nullable`1<JsonPosition> currentPosition);
    internal static string FormatMessage(IJsonLineInfo lineInfo, string path, string message);
}
[PreserveAttribute]
[AttributeUsageAttribute("2432")]
public class Newtonsoft.Json.JsonPropertyAttribute : Attribute {
    internal Nullable`1<NullValueHandling> _nullValueHandling;
    internal Nullable`1<DefaultValueHandling> _defaultValueHandling;
    internal Nullable`1<ReferenceLoopHandling> _referenceLoopHandling;
    internal Nullable`1<ObjectCreationHandling> _objectCreationHandling;
    internal Nullable`1<TypeNameHandling> _typeNameHandling;
    internal Nullable`1<bool> _isReference;
    internal Nullable`1<int> _order;
    internal Nullable`1<Required> _required;
    internal Nullable`1<bool> _itemIsReference;
    internal Nullable`1<ReferenceLoopHandling> _itemReferenceLoopHandling;
    internal Nullable`1<TypeNameHandling> _itemTypeNameHandling;
    [CompilerGeneratedAttribute]
private Type <ItemConverterType>k__BackingField;
    [CompilerGeneratedAttribute]
private Object[] <ItemConverterParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PropertyName>k__BackingField;
    public Type ItemConverterType { get; public set; }
    public Object[] ItemConverterParameters { get; public set; }
    public NullValueHandling NullValueHandling { get; public set; }
    public DefaultValueHandling DefaultValueHandling { get; public set; }
    public ReferenceLoopHandling ReferenceLoopHandling { get; public set; }
    public ObjectCreationHandling ObjectCreationHandling { get; public set; }
    public TypeNameHandling TypeNameHandling { get; public set; }
    public bool IsReference { get; public set; }
    public int Order { get; public set; }
    public Required Required { get; public set; }
    public string PropertyName { get; public set; }
    public ReferenceLoopHandling ItemReferenceLoopHandling { get; public set; }
    public TypeNameHandling ItemTypeNameHandling { get; public set; }
    public bool ItemIsReference { get; public set; }
    public JsonPropertyAttribute(string propertyName);
    [CompilerGeneratedAttribute]
public Type get_ItemConverterType();
    [CompilerGeneratedAttribute]
public void set_ItemConverterType(Type value);
    [CompilerGeneratedAttribute]
public Object[] get_ItemConverterParameters();
    [CompilerGeneratedAttribute]
public void set_ItemConverterParameters(Object[] value);
    public NullValueHandling get_NullValueHandling();
    public void set_NullValueHandling(NullValueHandling value);
    public DefaultValueHandling get_DefaultValueHandling();
    public void set_DefaultValueHandling(DefaultValueHandling value);
    public ReferenceLoopHandling get_ReferenceLoopHandling();
    public void set_ReferenceLoopHandling(ReferenceLoopHandling value);
    public ObjectCreationHandling get_ObjectCreationHandling();
    public void set_ObjectCreationHandling(ObjectCreationHandling value);
    public TypeNameHandling get_TypeNameHandling();
    public void set_TypeNameHandling(TypeNameHandling value);
    public bool get_IsReference();
    public void set_IsReference(bool value);
    public int get_Order();
    public void set_Order(int value);
    public Required get_Required();
    public void set_Required(Required value);
    [CompilerGeneratedAttribute]
public string get_PropertyName();
    [CompilerGeneratedAttribute]
public void set_PropertyName(string value);
    public ReferenceLoopHandling get_ItemReferenceLoopHandling();
    public void set_ItemReferenceLoopHandling(ReferenceLoopHandling value);
    public TypeNameHandling get_ItemTypeNameHandling();
    public void set_ItemTypeNameHandling(TypeNameHandling value);
    public bool get_ItemIsReference();
    public void set_ItemIsReference(bool value);
}
[PreserveAttribute]
public abstract class Newtonsoft.Json.JsonReader : object {
    private JsonToken _tokenType;
    private object _value;
    internal char _quoteChar;
    internal State _currentState;
    private JsonPosition _currentPosition;
    private CultureInfo _culture;
    private DateTimeZoneHandling _dateTimeZoneHandling;
    private Nullable`1<int> _maxDepth;
    private bool _hasExceededMaxDepth;
    internal DateParseHandling _dateParseHandling;
    internal FloatParseHandling _floatParseHandling;
    private string _dateFormatString;
    private List`1<JsonPosition> _stack;
    [CompilerGeneratedAttribute]
private bool <CloseInput>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SupportMultipleContent>k__BackingField;
    protected State CurrentState { get; }
    public bool CloseInput { get; public set; }
    public bool SupportMultipleContent { get; public set; }
    public char QuoteChar { get; protected internal set; }
    public DateTimeZoneHandling DateTimeZoneHandling { get; public set; }
    public DateParseHandling DateParseHandling { get; public set; }
    public FloatParseHandling FloatParseHandling { get; public set; }
    public string DateFormatString { get; public set; }
    public Nullable`1<int> MaxDepth { get; public set; }
    public JsonToken TokenType { get; }
    public object Value { get; }
    public Type ValueType { get; }
    public int Depth { get; }
    public string Path { get; }
    public CultureInfo Culture { get; public set; }
    protected State get_CurrentState();
    [CompilerGeneratedAttribute]
public bool get_CloseInput();
    [CompilerGeneratedAttribute]
public void set_CloseInput(bool value);
    [CompilerGeneratedAttribute]
public bool get_SupportMultipleContent();
    [CompilerGeneratedAttribute]
public void set_SupportMultipleContent(bool value);
    public virtual char get_QuoteChar();
    protected internal virtual void set_QuoteChar(char value);
    public DateTimeZoneHandling get_DateTimeZoneHandling();
    public void set_DateTimeZoneHandling(DateTimeZoneHandling value);
    public DateParseHandling get_DateParseHandling();
    public void set_DateParseHandling(DateParseHandling value);
    public FloatParseHandling get_FloatParseHandling();
    public void set_FloatParseHandling(FloatParseHandling value);
    public string get_DateFormatString();
    public void set_DateFormatString(string value);
    public Nullable`1<int> get_MaxDepth();
    public void set_MaxDepth(Nullable`1<int> value);
    public virtual JsonToken get_TokenType();
    public virtual object get_Value();
    public virtual Type get_ValueType();
    public virtual int get_Depth();
    public virtual string get_Path();
    public CultureInfo get_Culture();
    public void set_Culture(CultureInfo value);
    internal JsonPosition GetPosition(int depth);
    private void Push(JsonContainerType value);
    private JsonContainerType Pop();
    private JsonContainerType Peek();
    public abstract virtual bool Read();
    public virtual Nullable`1<int> ReadAsInt32();
    internal Nullable`1<int> ReadInt32String(string s);
    public virtual string ReadAsString();
    public virtual Byte[] ReadAsBytes();
    internal Byte[] ReadArrayIntoByteArray();
    public virtual Nullable`1<double> ReadAsDouble();
    internal Nullable`1<double> ReadDoubleString(string s);
    public virtual Nullable`1<bool> ReadAsBoolean();
    internal Nullable`1<bool> ReadBooleanString(string s);
    public virtual Nullable`1<decimal> ReadAsDecimal();
    internal Nullable`1<decimal> ReadDecimalString(string s);
    public virtual Nullable`1<DateTime> ReadAsDateTime();
    internal Nullable`1<DateTime> ReadDateTimeString(string s);
    public virtual Nullable`1<DateTimeOffset> ReadAsDateTimeOffset();
    internal Nullable`1<DateTimeOffset> ReadDateTimeOffsetString(string s);
    internal void ReaderReadAndAssert();
    internal JsonReaderException CreateUnexpectedEndException();
    internal void ReadIntoWrappedTypeObject();
    public void Skip();
    protected void SetToken(JsonToken newToken);
    protected void SetToken(JsonToken newToken, object value);
    internal void SetToken(JsonToken newToken, object value, bool updateIndex);
    internal void SetPostValueState(bool updateIndex);
    private void UpdateScopeWithFinishedValue();
    private void ValidateEnd(JsonToken endToken);
    protected void SetStateBasedOnCurrent();
    private void SetFinished();
    private JsonContainerType GetTypeForCloseToken(JsonToken token);
    private sealed virtual override void System.IDisposable.Dispose();
    protected virtual void Dispose(bool disposing);
    public virtual void Close();
    internal void ReadAndAssert();
    internal bool ReadAndMoveToContent();
    internal bool MoveToContent();
    private JsonToken GetContentToken();
}
[PreserveAttribute]
public class Newtonsoft.Json.JsonReaderException : JsonException {
    [CompilerGeneratedAttribute]
private int <LineNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LinePosition>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    public int LineNumber { get; private set; }
    public int LinePosition { get; private set; }
    public string Path { get; private set; }
    public JsonReaderException(string message);
    public JsonReaderException(string message, Exception innerException);
    public JsonReaderException(SerializationInfo info, StreamingContext context);
    internal JsonReaderException(string message, Exception innerException, string path, int lineNumber, int linePosition);
    [CompilerGeneratedAttribute]
public int get_LineNumber();
    [CompilerGeneratedAttribute]
private void set_LineNumber(int value);
    [CompilerGeneratedAttribute]
public int get_LinePosition();
    [CompilerGeneratedAttribute]
private void set_LinePosition(int value);
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
private void set_Path(string value);
    internal static JsonReaderException Create(JsonReader reader, string message);
    internal static JsonReaderException Create(JsonReader reader, string message, Exception ex);
    internal static JsonReaderException Create(IJsonLineInfo lineInfo, string path, string message, Exception ex);
}
[PreserveAttribute]
[AttributeUsageAttribute("384")]
public class Newtonsoft.Json.JsonRequiredAttribute : Attribute {
}
[PreserveAttribute]
public class Newtonsoft.Json.JsonSerializationException : JsonException {
    public JsonSerializationException(string message);
    public JsonSerializationException(string message, Exception innerException);
    public JsonSerializationException(SerializationInfo info, StreamingContext context);
    internal static JsonSerializationException Create(JsonReader reader, string message);
    internal static JsonSerializationException Create(JsonReader reader, string message, Exception ex);
    internal static JsonSerializationException Create(IJsonLineInfo lineInfo, string path, string message, Exception ex);
}
[PreserveAttribute]
public class Newtonsoft.Json.JsonSerializer : object {
    internal TypeNameHandling _typeNameHandling;
    internal FormatterAssemblyStyle _typeNameAssemblyFormat;
    internal PreserveReferencesHandling _preserveReferencesHandling;
    internal ReferenceLoopHandling _referenceLoopHandling;
    internal MissingMemberHandling _missingMemberHandling;
    internal ObjectCreationHandling _objectCreationHandling;
    internal NullValueHandling _nullValueHandling;
    internal DefaultValueHandling _defaultValueHandling;
    internal ConstructorHandling _constructorHandling;
    internal MetadataPropertyHandling _metadataPropertyHandling;
    internal JsonConverterCollection _converters;
    internal IContractResolver _contractResolver;
    internal ITraceWriter _traceWriter;
    internal IEqualityComparer _equalityComparer;
    internal SerializationBinder _binder;
    internal StreamingContext _context;
    private IReferenceResolver _referenceResolver;
    private Nullable`1<Formatting> _formatting;
    private Nullable`1<DateFormatHandling> _dateFormatHandling;
    private Nullable`1<DateTimeZoneHandling> _dateTimeZoneHandling;
    private Nullable`1<DateParseHandling> _dateParseHandling;
    private Nullable`1<FloatFormatHandling> _floatFormatHandling;
    private Nullable`1<FloatParseHandling> _floatParseHandling;
    private Nullable`1<StringEscapeHandling> _stringEscapeHandling;
    private CultureInfo _culture;
    private Nullable`1<int> _maxDepth;
    private bool _maxDepthSet;
    private Nullable`1<bool> _checkAdditionalContent;
    private string _dateFormatString;
    private bool _dateFormatStringSet;
    [CompilerGeneratedAttribute]
private EventHandler`1<ErrorEventArgs> Error;
    public IReferenceResolver ReferenceResolver { get; public set; }
    public SerializationBinder Binder { get; public set; }
    public ITraceWriter TraceWriter { get; public set; }
    public IEqualityComparer EqualityComparer { get; public set; }
    public TypeNameHandling TypeNameHandling { get; public set; }
    public FormatterAssemblyStyle TypeNameAssemblyFormat { get; public set; }
    public PreserveReferencesHandling PreserveReferencesHandling { get; public set; }
    public ReferenceLoopHandling ReferenceLoopHandling { get; public set; }
    public MissingMemberHandling MissingMemberHandling { get; public set; }
    public NullValueHandling NullValueHandling { get; public set; }
    public DefaultValueHandling DefaultValueHandling { get; public set; }
    public ObjectCreationHandling ObjectCreationHandling { get; public set; }
    public ConstructorHandling ConstructorHandling { get; public set; }
    public MetadataPropertyHandling MetadataPropertyHandling { get; public set; }
    public JsonConverterCollection Converters { get; }
    public IContractResolver ContractResolver { get; public set; }
    public StreamingContext Context { get; public set; }
    public Formatting Formatting { get; public set; }
    public DateFormatHandling DateFormatHandling { get; public set; }
    public DateTimeZoneHandling DateTimeZoneHandling { get; public set; }
    public DateParseHandling DateParseHandling { get; public set; }
    public FloatParseHandling FloatParseHandling { get; public set; }
    public FloatFormatHandling FloatFormatHandling { get; public set; }
    public StringEscapeHandling StringEscapeHandling { get; public set; }
    public string DateFormatString { get; public set; }
    public CultureInfo Culture { get; public set; }
    public Nullable`1<int> MaxDepth { get; public set; }
    public bool CheckAdditionalContent { get; public set; }
    [CompilerGeneratedAttribute]
public virtual void add_Error(EventHandler`1<ErrorEventArgs> value);
    [CompilerGeneratedAttribute]
public virtual void remove_Error(EventHandler`1<ErrorEventArgs> value);
    public virtual IReferenceResolver get_ReferenceResolver();
    public virtual void set_ReferenceResolver(IReferenceResolver value);
    public virtual SerializationBinder get_Binder();
    public virtual void set_Binder(SerializationBinder value);
    public virtual ITraceWriter get_TraceWriter();
    public virtual void set_TraceWriter(ITraceWriter value);
    public virtual IEqualityComparer get_EqualityComparer();
    public virtual void set_EqualityComparer(IEqualityComparer value);
    public virtual TypeNameHandling get_TypeNameHandling();
    public virtual void set_TypeNameHandling(TypeNameHandling value);
    public virtual FormatterAssemblyStyle get_TypeNameAssemblyFormat();
    public virtual void set_TypeNameAssemblyFormat(FormatterAssemblyStyle value);
    public virtual PreserveReferencesHandling get_PreserveReferencesHandling();
    public virtual void set_PreserveReferencesHandling(PreserveReferencesHandling value);
    public virtual ReferenceLoopHandling get_ReferenceLoopHandling();
    public virtual void set_ReferenceLoopHandling(ReferenceLoopHandling value);
    public virtual MissingMemberHandling get_MissingMemberHandling();
    public virtual void set_MissingMemberHandling(MissingMemberHandling value);
    public virtual NullValueHandling get_NullValueHandling();
    public virtual void set_NullValueHandling(NullValueHandling value);
    public virtual DefaultValueHandling get_DefaultValueHandling();
    public virtual void set_DefaultValueHandling(DefaultValueHandling value);
    public virtual ObjectCreationHandling get_ObjectCreationHandling();
    public virtual void set_ObjectCreationHandling(ObjectCreationHandling value);
    public virtual ConstructorHandling get_ConstructorHandling();
    public virtual void set_ConstructorHandling(ConstructorHandling value);
    public virtual MetadataPropertyHandling get_MetadataPropertyHandling();
    public virtual void set_MetadataPropertyHandling(MetadataPropertyHandling value);
    public virtual JsonConverterCollection get_Converters();
    public virtual IContractResolver get_ContractResolver();
    public virtual void set_ContractResolver(IContractResolver value);
    public virtual StreamingContext get_Context();
    public virtual void set_Context(StreamingContext value);
    public virtual Formatting get_Formatting();
    public virtual void set_Formatting(Formatting value);
    public virtual DateFormatHandling get_DateFormatHandling();
    public virtual void set_DateFormatHandling(DateFormatHandling value);
    public virtual DateTimeZoneHandling get_DateTimeZoneHandling();
    public virtual void set_DateTimeZoneHandling(DateTimeZoneHandling value);
    public virtual DateParseHandling get_DateParseHandling();
    public virtual void set_DateParseHandling(DateParseHandling value);
    public virtual FloatParseHandling get_FloatParseHandling();
    public virtual void set_FloatParseHandling(FloatParseHandling value);
    public virtual FloatFormatHandling get_FloatFormatHandling();
    public virtual void set_FloatFormatHandling(FloatFormatHandling value);
    public virtual StringEscapeHandling get_StringEscapeHandling();
    public virtual void set_StringEscapeHandling(StringEscapeHandling value);
    public virtual string get_DateFormatString();
    public virtual void set_DateFormatString(string value);
    public virtual CultureInfo get_Culture();
    public virtual void set_Culture(CultureInfo value);
    public virtual Nullable`1<int> get_MaxDepth();
    public virtual void set_MaxDepth(Nullable`1<int> value);
    public virtual bool get_CheckAdditionalContent();
    public virtual void set_CheckAdditionalContent(bool value);
    internal bool IsCheckAdditionalContentSet();
    public static JsonSerializer Create();
    public static JsonSerializer Create(JsonSerializerSettings settings);
    public static JsonSerializer CreateDefault();
    public static JsonSerializer CreateDefault(JsonSerializerSettings settings);
    private static void ApplySerializerSettings(JsonSerializer serializer, JsonSerializerSettings settings);
    public void Populate(TextReader reader, object target);
    public void Populate(JsonReader reader, object target);
    internal virtual void PopulateInternal(JsonReader reader, object target);
    public object Deserialize(JsonReader reader);
    public object Deserialize(TextReader reader, Type objectType);
    public T Deserialize(JsonReader reader);
    public object Deserialize(JsonReader reader, Type objectType);
    internal virtual object DeserializeInternal(JsonReader reader, Type objectType);
    private void SetupReader(JsonReader reader, CultureInfo& previousCulture, Nullable`1& previousDateTimeZoneHandling, Nullable`1& previousDateParseHandling, Nullable`1& previousFloatParseHandling, Nullable`1& previousMaxDepth, String& previousDateFormatString);
    private void ResetReader(JsonReader reader, CultureInfo previousCulture, Nullable`1<DateTimeZoneHandling> previousDateTimeZoneHandling, Nullable`1<DateParseHandling> previousDateParseHandling, Nullable`1<FloatParseHandling> previousFloatParseHandling, Nullable`1<int> previousMaxDepth, string previousDateFormatString);
    public void Serialize(TextWriter textWriter, object value);
    public void Serialize(JsonWriter jsonWriter, object value, Type objectType);
    public void Serialize(TextWriter textWriter, object value, Type objectType);
    public void Serialize(JsonWriter jsonWriter, object value);
    internal virtual void SerializeInternal(JsonWriter jsonWriter, object value, Type objectType);
    internal IReferenceResolver GetReferenceResolver();
    internal JsonConverter GetMatchingConverter(Type type);
    internal static JsonConverter GetMatchingConverter(IList`1<JsonConverter> converters, Type objectType);
    internal void OnError(ErrorEventArgs e);
}
[PreserveAttribute]
public class Newtonsoft.Json.JsonSerializerSettings : object {
    internal static ReferenceLoopHandling DefaultReferenceLoopHandling;
    internal static MissingMemberHandling DefaultMissingMemberHandling;
    internal static NullValueHandling DefaultNullValueHandling;
    internal static DefaultValueHandling DefaultDefaultValueHandling;
    internal static ObjectCreationHandling DefaultObjectCreationHandling;
    internal static PreserveReferencesHandling DefaultPreserveReferencesHandling;
    internal static ConstructorHandling DefaultConstructorHandling;
    internal static TypeNameHandling DefaultTypeNameHandling;
    internal static MetadataPropertyHandling DefaultMetadataPropertyHandling;
    internal static FormatterAssemblyStyle DefaultTypeNameAssemblyFormat;
    internal static StreamingContext DefaultContext;
    internal static Formatting DefaultFormatting;
    internal static DateFormatHandling DefaultDateFormatHandling;
    internal static DateTimeZoneHandling DefaultDateTimeZoneHandling;
    internal static DateParseHandling DefaultDateParseHandling;
    internal static FloatParseHandling DefaultFloatParseHandling;
    internal static FloatFormatHandling DefaultFloatFormatHandling;
    internal static StringEscapeHandling DefaultStringEscapeHandling;
    internal static FormatterAssemblyStyle DefaultFormatterAssemblyStyle;
    internal static CultureInfo DefaultCulture;
    internal static bool DefaultCheckAdditionalContent;
    internal static string DefaultDateFormatString;
    internal Nullable`1<Formatting> _formatting;
    internal Nullable`1<DateFormatHandling> _dateFormatHandling;
    internal Nullable`1<DateTimeZoneHandling> _dateTimeZoneHandling;
    internal Nullable`1<DateParseHandling> _dateParseHandling;
    internal Nullable`1<FloatFormatHandling> _floatFormatHandling;
    internal Nullable`1<FloatParseHandling> _floatParseHandling;
    internal Nullable`1<StringEscapeHandling> _stringEscapeHandling;
    internal CultureInfo _culture;
    internal Nullable`1<bool> _checkAdditionalContent;
    internal Nullable`1<int> _maxDepth;
    internal bool _maxDepthSet;
    internal string _dateFormatString;
    internal bool _dateFormatStringSet;
    internal Nullable`1<FormatterAssemblyStyle> _typeNameAssemblyFormat;
    internal Nullable`1<DefaultValueHandling> _defaultValueHandling;
    internal Nullable`1<PreserveReferencesHandling> _preserveReferencesHandling;
    internal Nullable`1<NullValueHandling> _nullValueHandling;
    internal Nullable`1<ObjectCreationHandling> _objectCreationHandling;
    internal Nullable`1<MissingMemberHandling> _missingMemberHandling;
    internal Nullable`1<ReferenceLoopHandling> _referenceLoopHandling;
    internal Nullable`1<StreamingContext> _context;
    internal Nullable`1<ConstructorHandling> _constructorHandling;
    internal Nullable`1<TypeNameHandling> _typeNameHandling;
    internal Nullable`1<MetadataPropertyHandling> _metadataPropertyHandling;
    [CompilerGeneratedAttribute]
private IList`1<JsonConverter> <Converters>k__BackingField;
    [CompilerGeneratedAttribute]
private IContractResolver <ContractResolver>k__BackingField;
    [CompilerGeneratedAttribute]
private IEqualityComparer <EqualityComparer>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`1<IReferenceResolver> <ReferenceResolverProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private ITraceWriter <TraceWriter>k__BackingField;
    [CompilerGeneratedAttribute]
private SerializationBinder <Binder>k__BackingField;
    [CompilerGeneratedAttribute]
private EventHandler`1<ErrorEventArgs> <Error>k__BackingField;
    public ReferenceLoopHandling ReferenceLoopHandling { get; public set; }
    public MissingMemberHandling MissingMemberHandling { get; public set; }
    public ObjectCreationHandling ObjectCreationHandling { get; public set; }
    public NullValueHandling NullValueHandling { get; public set; }
    public DefaultValueHandling DefaultValueHandling { get; public set; }
    public IList`1<JsonConverter> Converters { get; public set; }
    public PreserveReferencesHandling PreserveReferencesHandling { get; public set; }
    public TypeNameHandling TypeNameHandling { get; public set; }
    public MetadataPropertyHandling MetadataPropertyHandling { get; public set; }
    public FormatterAssemblyStyle TypeNameAssemblyFormat { get; public set; }
    public ConstructorHandling ConstructorHandling { get; public set; }
    public IContractResolver ContractResolver { get; public set; }
    public IEqualityComparer EqualityComparer { get; public set; }
    [ObsoleteAttribute("ReferenceResolver property is obsolete. Use the ReferenceResolverProvider property to set the IReferenceResolver: settings.ReferenceResolverProvider = () => resolver")]
public IReferenceResolver ReferenceResolver { get; public set; }
    public Func`1<IReferenceResolver> ReferenceResolverProvider { get; public set; }
    public ITraceWriter TraceWriter { get; public set; }
    public SerializationBinder Binder { get; public set; }
    public EventHandler`1<ErrorEventArgs> Error { get; public set; }
    public StreamingContext Context { get; public set; }
    public string DateFormatString { get; public set; }
    public Nullable`1<int> MaxDepth { get; public set; }
    public Formatting Formatting { get; public set; }
    public DateFormatHandling DateFormatHandling { get; public set; }
    public DateTimeZoneHandling DateTimeZoneHandling { get; public set; }
    public DateParseHandling DateParseHandling { get; public set; }
    public FloatFormatHandling FloatFormatHandling { get; public set; }
    public FloatParseHandling FloatParseHandling { get; public set; }
    public StringEscapeHandling StringEscapeHandling { get; public set; }
    public CultureInfo Culture { get; public set; }
    public bool CheckAdditionalContent { get; public set; }
    private static JsonSerializerSettings();
    public ReferenceLoopHandling get_ReferenceLoopHandling();
    public void set_ReferenceLoopHandling(ReferenceLoopHandling value);
    public MissingMemberHandling get_MissingMemberHandling();
    public void set_MissingMemberHandling(MissingMemberHandling value);
    public ObjectCreationHandling get_ObjectCreationHandling();
    public void set_ObjectCreationHandling(ObjectCreationHandling value);
    public NullValueHandling get_NullValueHandling();
    public void set_NullValueHandling(NullValueHandling value);
    public DefaultValueHandling get_DefaultValueHandling();
    public void set_DefaultValueHandling(DefaultValueHandling value);
    [CompilerGeneratedAttribute]
public IList`1<JsonConverter> get_Converters();
    [CompilerGeneratedAttribute]
public void set_Converters(IList`1<JsonConverter> value);
    public PreserveReferencesHandling get_PreserveReferencesHandling();
    public void set_PreserveReferencesHandling(PreserveReferencesHandling value);
    public TypeNameHandling get_TypeNameHandling();
    public void set_TypeNameHandling(TypeNameHandling value);
    public MetadataPropertyHandling get_MetadataPropertyHandling();
    public void set_MetadataPropertyHandling(MetadataPropertyHandling value);
    public FormatterAssemblyStyle get_TypeNameAssemblyFormat();
    public void set_TypeNameAssemblyFormat(FormatterAssemblyStyle value);
    public ConstructorHandling get_ConstructorHandling();
    public void set_ConstructorHandling(ConstructorHandling value);
    [CompilerGeneratedAttribute]
public IContractResolver get_ContractResolver();
    [CompilerGeneratedAttribute]
public void set_ContractResolver(IContractResolver value);
    [CompilerGeneratedAttribute]
public IEqualityComparer get_EqualityComparer();
    [CompilerGeneratedAttribute]
public void set_EqualityComparer(IEqualityComparer value);
    public IReferenceResolver get_ReferenceResolver();
    public void set_ReferenceResolver(IReferenceResolver value);
    [CompilerGeneratedAttribute]
public Func`1<IReferenceResolver> get_ReferenceResolverProvider();
    [CompilerGeneratedAttribute]
public void set_ReferenceResolverProvider(Func`1<IReferenceResolver> value);
    [CompilerGeneratedAttribute]
public ITraceWriter get_TraceWriter();
    [CompilerGeneratedAttribute]
public void set_TraceWriter(ITraceWriter value);
    [CompilerGeneratedAttribute]
public SerializationBinder get_Binder();
    [CompilerGeneratedAttribute]
public void set_Binder(SerializationBinder value);
    [CompilerGeneratedAttribute]
public EventHandler`1<ErrorEventArgs> get_Error();
    [CompilerGeneratedAttribute]
public void set_Error(EventHandler`1<ErrorEventArgs> value);
    public StreamingContext get_Context();
    public void set_Context(StreamingContext value);
    public string get_DateFormatString();
    public void set_DateFormatString(string value);
    public Nullable`1<int> get_MaxDepth();
    public void set_MaxDepth(Nullable`1<int> value);
    public Formatting get_Formatting();
    public void set_Formatting(Formatting value);
    public DateFormatHandling get_DateFormatHandling();
    public void set_DateFormatHandling(DateFormatHandling value);
    public DateTimeZoneHandling get_DateTimeZoneHandling();
    public void set_DateTimeZoneHandling(DateTimeZoneHandling value);
    public DateParseHandling get_DateParseHandling();
    public void set_DateParseHandling(DateParseHandling value);
    public FloatFormatHandling get_FloatFormatHandling();
    public void set_FloatFormatHandling(FloatFormatHandling value);
    public FloatParseHandling get_FloatParseHandling();
    public void set_FloatParseHandling(FloatParseHandling value);
    public StringEscapeHandling get_StringEscapeHandling();
    public void set_StringEscapeHandling(StringEscapeHandling value);
    public CultureInfo get_Culture();
    public void set_Culture(CultureInfo value);
    public bool get_CheckAdditionalContent();
    public void set_CheckAdditionalContent(bool value);
}
[PreserveAttribute]
public class Newtonsoft.Json.JsonTextReader : JsonReader {
    private static char UnicodeReplacementChar;
    private static int MaximumJavascriptIntegerCharacterLength;
    private TextReader _reader;
    private Char[] _chars;
    private int _charsUsed;
    private int _charPos;
    private int _lineStartPos;
    private int _lineNumber;
    private bool _isEndOfFile;
    private StringBuffer _stringBuffer;
    private StringReference _stringReference;
    private IArrayPool`1<char> _arrayPool;
    internal PropertyNameTable NameTable;
    public IArrayPool`1<char> ArrayPool { get; public set; }
    public int LineNumber { get; }
    public int LinePosition { get; }
    public JsonTextReader(TextReader reader);
    public IArrayPool`1<char> get_ArrayPool();
    public void set_ArrayPool(IArrayPool`1<char> value);
    private void EnsureBufferNotEmpty();
    private void OnNewLine(int pos);
    private void ParseString(char quote, ReadType readType);
    private static void BlockCopyChars(Char[] src, int srcOffset, Char[] dst, int dstOffset, int count);
    private void ShiftBufferIfNeeded();
    private int ReadData(bool append);
    private int ReadData(bool append, int charsRequired);
    private bool EnsureChars(int relativePosition, bool append);
    private bool ReadChars(int relativePosition, bool append);
    public virtual bool Read();
    public virtual Nullable`1<int> ReadAsInt32();
    public virtual Nullable`1<DateTime> ReadAsDateTime();
    public virtual string ReadAsString();
    public virtual Byte[] ReadAsBytes();
    private object ReadStringValue(ReadType readType);
    private JsonReaderException CreateUnexpectedCharacterException(char c);
    public virtual Nullable`1<bool> ReadAsBoolean();
    private void ProcessValueComma();
    private object ReadNumberValue(ReadType readType);
    public virtual Nullable`1<DateTimeOffset> ReadAsDateTimeOffset();
    public virtual Nullable`1<decimal> ReadAsDecimal();
    public virtual Nullable`1<double> ReadAsDouble();
    private void HandleNull();
    private void ReadFinished();
    private bool ReadNullChar();
    private void EnsureBuffer();
    private void ReadStringIntoBuffer(char quote);
    private void WriteCharToBuffer(char writeChar, int lastWritePosition, int writeToPosition);
    private char ParseUnicode();
    private void ReadNumberIntoBuffer();
    private void ClearRecentString();
    private bool ParsePostValue();
    private bool ParseObject();
    private bool ParseProperty();
    private bool ValidIdentifierChar(char value);
    private void ParseUnquotedProperty();
    private bool ParseValue();
    private void ProcessLineFeed();
    private void ProcessCarriageReturn(bool append);
    private bool EatWhitespace(bool oneOrMore);
    private void ParseConstructor();
    private void ParseNumber(ReadType readType);
    private void ParseComment(bool setToken);
    private void EndComment(bool setToken, int initialPosition, int endPosition);
    private bool MatchValue(string value);
    private bool MatchValueWithTrailingSeparator(string value);
    private bool IsSeparator(char c);
    private void ParseTrue();
    private void ParseNull();
    private void ParseUndefined();
    private void ParseFalse();
    private object ParseNumberNegativeInfinity(ReadType readType);
    private object ParseNumberPositiveInfinity(ReadType readType);
    private object ParseNumberNaN(ReadType readType);
    public virtual void Close();
    public sealed virtual bool HasLineInfo();
    public sealed virtual int get_LineNumber();
    public sealed virtual int get_LinePosition();
}
[PreserveAttribute]
public class Newtonsoft.Json.JsonTextWriter : JsonWriter {
    private TextWriter _writer;
    private Base64Encoder _base64Encoder;
    private char _indentChar;
    private int _indentation;
    private char _quoteChar;
    private bool _quoteName;
    private Boolean[] _charEscapeFlags;
    private Char[] _writeBuffer;
    private IArrayPool`1<char> _arrayPool;
    private Char[] _indentChars;
    private Base64Encoder Base64Encoder { get; }
    public IArrayPool`1<char> ArrayPool { get; public set; }
    public int Indentation { get; public set; }
    public char QuoteChar { get; public set; }
    public char IndentChar { get; public set; }
    public bool QuoteName { get; public set; }
    public JsonTextWriter(TextWriter textWriter);
    private Base64Encoder get_Base64Encoder();
    public IArrayPool`1<char> get_ArrayPool();
    public void set_ArrayPool(IArrayPool`1<char> value);
    public int get_Indentation();
    public void set_Indentation(int value);
    public char get_QuoteChar();
    public void set_QuoteChar(char value);
    public char get_IndentChar();
    public void set_IndentChar(char value);
    public bool get_QuoteName();
    public void set_QuoteName(bool value);
    public virtual void Flush();
    public virtual void Close();
    public virtual void WriteStartObject();
    public virtual void WriteStartArray();
    public virtual void WriteStartConstructor(string name);
    protected virtual void WriteEnd(JsonToken token);
    public virtual void WritePropertyName(string name);
    public virtual void WritePropertyName(string name, bool escape);
    internal virtual void OnStringEscapeHandlingChanged();
    private void UpdateCharEscapeFlags();
    protected virtual void WriteIndent();
    protected virtual void WriteValueDelimiter();
    protected virtual void WriteIndentSpace();
    private void WriteValueInternal(string value, JsonToken token);
    public virtual void WriteValue(object value);
    public virtual void WriteNull();
    public virtual void WriteUndefined();
    public virtual void WriteRaw(string json);
    public virtual void WriteValue(string value);
    private void WriteEscapedString(string value, bool quote);
    public virtual void WriteValue(int value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(UInt32 value);
    public virtual void WriteValue(long value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(ulong value);
    public virtual void WriteValue(float value);
    public virtual void WriteValue(Nullable`1<float> value);
    public virtual void WriteValue(double value);
    public virtual void WriteValue(Nullable`1<double> value);
    public virtual void WriteValue(bool value);
    public virtual void WriteValue(short value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(ushort value);
    public virtual void WriteValue(char value);
    public virtual void WriteValue(byte value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(sbyte value);
    public virtual void WriteValue(decimal value);
    public virtual void WriteValue(DateTime value);
    public virtual void WriteValue(Byte[] value);
    public virtual void WriteValue(DateTimeOffset value);
    public virtual void WriteValue(Guid value);
    public virtual void WriteValue(TimeSpan value);
    public virtual void WriteValue(Uri value);
    public virtual void WriteComment(string text);
    public virtual void WriteWhitespace(string ws);
    private void EnsureWriteBuffer();
    private void WriteIntegerValue(long value);
    private void WriteIntegerValue(ulong uvalue);
}
[PreserveAttribute]
public enum Newtonsoft.Json.JsonToken : Enum {
    public int value__;
    public static JsonToken None;
    public static JsonToken StartObject;
    public static JsonToken StartArray;
    public static JsonToken StartConstructor;
    public static JsonToken PropertyName;
    public static JsonToken Comment;
    public static JsonToken Raw;
    public static JsonToken Integer;
    public static JsonToken Float;
    public static JsonToken String;
    public static JsonToken Boolean;
    public static JsonToken Null;
    public static JsonToken Undefined;
    public static JsonToken EndObject;
    public static JsonToken EndArray;
    public static JsonToken EndConstructor;
    public static JsonToken Date;
    public static JsonToken Bytes;
}
[PreserveAttribute]
public abstract class Newtonsoft.Json.JsonWriter : object {
    private static State[][] StateArray;
    internal static State[][] StateArrayTempate;
    private List`1<JsonPosition> _stack;
    private JsonPosition _currentPosition;
    private State _currentState;
    private Formatting _formatting;
    [CompilerGeneratedAttribute]
private bool <CloseOutput>k__BackingField;
    private DateFormatHandling _dateFormatHandling;
    private DateTimeZoneHandling _dateTimeZoneHandling;
    private StringEscapeHandling _stringEscapeHandling;
    private FloatFormatHandling _floatFormatHandling;
    private string _dateFormatString;
    private CultureInfo _culture;
    public bool CloseOutput { get; public set; }
    protected internal int Top { get; }
    public WriteState WriteState { get; }
    internal string ContainerPath { get; }
    public string Path { get; }
    public Formatting Formatting { get; public set; }
    public DateFormatHandling DateFormatHandling { get; public set; }
    public DateTimeZoneHandling DateTimeZoneHandling { get; public set; }
    public StringEscapeHandling StringEscapeHandling { get; public set; }
    public FloatFormatHandling FloatFormatHandling { get; public set; }
    public string DateFormatString { get; public set; }
    public CultureInfo Culture { get; public set; }
    private static JsonWriter();
    internal static State[][] BuildStateArray();
    [CompilerGeneratedAttribute]
public bool get_CloseOutput();
    [CompilerGeneratedAttribute]
public void set_CloseOutput(bool value);
    protected internal int get_Top();
    public WriteState get_WriteState();
    internal string get_ContainerPath();
    public string get_Path();
    public Formatting get_Formatting();
    public void set_Formatting(Formatting value);
    public DateFormatHandling get_DateFormatHandling();
    public void set_DateFormatHandling(DateFormatHandling value);
    public DateTimeZoneHandling get_DateTimeZoneHandling();
    public void set_DateTimeZoneHandling(DateTimeZoneHandling value);
    public StringEscapeHandling get_StringEscapeHandling();
    public void set_StringEscapeHandling(StringEscapeHandling value);
    internal virtual void OnStringEscapeHandlingChanged();
    public FloatFormatHandling get_FloatFormatHandling();
    public void set_FloatFormatHandling(FloatFormatHandling value);
    public string get_DateFormatString();
    public void set_DateFormatString(string value);
    public CultureInfo get_Culture();
    public void set_Culture(CultureInfo value);
    internal void UpdateScopeWithFinishedValue();
    private void Push(JsonContainerType value);
    private JsonContainerType Pop();
    private JsonContainerType Peek();
    public abstract virtual void Flush();
    public virtual void Close();
    public virtual void WriteStartObject();
    public virtual void WriteEndObject();
    public virtual void WriteStartArray();
    public virtual void WriteEndArray();
    public virtual void WriteStartConstructor(string name);
    public virtual void WriteEndConstructor();
    public virtual void WritePropertyName(string name);
    public virtual void WritePropertyName(string name, bool escape);
    public virtual void WriteEnd();
    public void WriteToken(JsonReader reader);
    public void WriteToken(JsonReader reader, bool writeChildren);
    public void WriteToken(JsonToken token, object value);
    public void WriteToken(JsonToken token);
    internal virtual void WriteToken(JsonReader reader, bool writeChildren, bool writeDateConstructorAsDate, bool writeComments);
    private void WriteConstructorDate(JsonReader reader);
    private void WriteEnd(JsonContainerType type);
    private void AutoCompleteAll();
    private JsonToken GetCloseTokenForType(JsonContainerType type);
    private void AutoCompleteClose(JsonContainerType type);
    protected virtual void WriteEnd(JsonToken token);
    protected virtual void WriteIndent();
    protected virtual void WriteValueDelimiter();
    protected virtual void WriteIndentSpace();
    internal void AutoComplete(JsonToken tokenBeingWritten);
    public virtual void WriteNull();
    public virtual void WriteUndefined();
    public virtual void WriteRaw(string json);
    public virtual void WriteRawValue(string json);
    public virtual void WriteValue(string value);
    public virtual void WriteValue(int value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(UInt32 value);
    public virtual void WriteValue(long value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(ulong value);
    public virtual void WriteValue(float value);
    public virtual void WriteValue(double value);
    public virtual void WriteValue(bool value);
    public virtual void WriteValue(short value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(ushort value);
    public virtual void WriteValue(char value);
    public virtual void WriteValue(byte value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(sbyte value);
    public virtual void WriteValue(decimal value);
    public virtual void WriteValue(DateTime value);
    public virtual void WriteValue(DateTimeOffset value);
    public virtual void WriteValue(Guid value);
    public virtual void WriteValue(TimeSpan value);
    public virtual void WriteValue(Nullable`1<int> value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(Nullable`1<UInt32> value);
    public virtual void WriteValue(Nullable`1<long> value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(Nullable`1<ulong> value);
    public virtual void WriteValue(Nullable`1<float> value);
    public virtual void WriteValue(Nullable`1<double> value);
    public virtual void WriteValue(Nullable`1<bool> value);
    public virtual void WriteValue(Nullable`1<short> value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(Nullable`1<ushort> value);
    public virtual void WriteValue(Nullable`1<char> value);
    public virtual void WriteValue(Nullable`1<byte> value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(Nullable`1<sbyte> value);
    public virtual void WriteValue(Nullable`1<decimal> value);
    public virtual void WriteValue(Nullable`1<DateTime> value);
    public virtual void WriteValue(Nullable`1<DateTimeOffset> value);
    public virtual void WriteValue(Nullable`1<Guid> value);
    public virtual void WriteValue(Nullable`1<TimeSpan> value);
    public virtual void WriteValue(Byte[] value);
    public virtual void WriteValue(Uri value);
    public virtual void WriteValue(object value);
    public virtual void WriteComment(string text);
    public virtual void WriteWhitespace(string ws);
    private sealed virtual override void System.IDisposable.Dispose();
    protected virtual void Dispose(bool disposing);
    internal static void WriteValue(JsonWriter writer, PrimitiveTypeCode typeCode, object value);
    private static JsonWriterException CreateUnsupportedTypeException(JsonWriter writer, object value);
    protected void SetWriteState(JsonToken token, object value);
    internal void InternalWriteEnd(JsonContainerType container);
    internal void InternalWritePropertyName(string name);
    internal void InternalWriteRaw();
    internal void InternalWriteStart(JsonToken token, JsonContainerType container);
    internal void InternalWriteValue(JsonToken token);
    internal void InternalWriteWhitespace(string ws);
    internal void InternalWriteComment();
}
[PreserveAttribute]
public class Newtonsoft.Json.JsonWriterException : JsonException {
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    public string Path { get; private set; }
    public JsonWriterException(string message);
    public JsonWriterException(string message, Exception innerException);
    public JsonWriterException(SerializationInfo info, StreamingContext context);
    internal JsonWriterException(string message, Exception innerException, string path);
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
private void set_Path(string value);
    internal static JsonWriterException Create(JsonWriter writer, string message, Exception ex);
    internal static JsonWriterException Create(string path, string message, Exception ex);
}
[PreserveAttribute]
public enum Newtonsoft.Json.Linq.CommentHandling : Enum {
    public int value__;
    public static CommentHandling Ignore;
    public static CommentHandling Load;
}
[ExtensionAttribute]
[PreserveAttribute]
public static class Newtonsoft.Json.Linq.Extensions : object {
    [ExtensionAttribute]
public static IJEnumerable`1<JToken> Ancestors(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static IJEnumerable`1<JToken> AncestorsAndSelf(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static IJEnumerable`1<JToken> Descendants(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static IJEnumerable`1<JToken> DescendantsAndSelf(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static IJEnumerable`1<JProperty> Properties(IEnumerable`1<JObject> source);
    [ExtensionAttribute]
public static IJEnumerable`1<JToken> Values(IEnumerable`1<JToken> source, object key);
    [ExtensionAttribute]
public static IJEnumerable`1<JToken> Values(IEnumerable`1<JToken> source);
    [ExtensionAttribute]
public static IEnumerable`1<U> Values(IEnumerable`1<JToken> source, object key);
    [ExtensionAttribute]
public static IEnumerable`1<U> Values(IEnumerable`1<JToken> source);
    [ExtensionAttribute]
public static U Value(IEnumerable`1<JToken> value);
    [ExtensionAttribute]
public static U Value(IEnumerable`1<T> value);
    [ExtensionAttribute]
internal static IEnumerable`1<U> Values(IEnumerable`1<T> source, object key);
    [ExtensionAttribute]
public static IJEnumerable`1<JToken> Children(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static IEnumerable`1<U> Children(IEnumerable`1<T> source);
    [ExtensionAttribute]
internal static IEnumerable`1<U> Convert(IEnumerable`1<T> source);
    [ExtensionAttribute]
internal static U Convert(T token);
    [ExtensionAttribute]
public static IJEnumerable`1<JToken> AsJEnumerable(IEnumerable`1<JToken> source);
    [ExtensionAttribute]
public static IJEnumerable`1<T> AsJEnumerable(IEnumerable`1<T> source);
}
[DefaultMemberAttribute("Item")]
[PreserveAttribute]
public interface Newtonsoft.Json.Linq.IJEnumerable`1 {
    public IJEnumerable`1<JToken> Item { get; }
    public abstract virtual IJEnumerable`1<JToken> get_Item(object key);
}
[PreserveAttribute]
[DefaultMemberAttribute("Item")]
public class Newtonsoft.Json.Linq.JArray : JContainer {
    private List`1<JToken> _values;
    protected IList`1<JToken> ChildrenTokens { get; }
    public JTokenType Type { get; }
    public JToken Item { get; public set; }
    public JToken Item { get; public set; }
    public bool IsReadOnly { get; }
    public JArray(JArray other);
    public JArray(Object[] content);
    public JArray(object content);
    protected virtual IList`1<JToken> get_ChildrenTokens();
    public virtual JTokenType get_Type();
    internal virtual bool DeepEquals(JToken node);
    internal virtual JToken CloneToken();
    public static JArray Load(JsonReader reader);
    public static JArray Load(JsonReader reader, JsonLoadSettings settings);
    public static JArray Parse(string json);
    public static JArray Parse(string json, JsonLoadSettings settings);
    public static JArray FromObject(object o);
    public static JArray FromObject(object o, JsonSerializer jsonSerializer);
    public virtual void WriteTo(JsonWriter writer, JsonConverter[] converters);
    public virtual JToken get_Item(object key);
    public virtual void set_Item(object key, JToken value);
    public sealed virtual JToken get_Item(int index);
    public sealed virtual void set_Item(int index, JToken value);
    internal virtual int IndexOfItem(JToken item);
    internal virtual void MergeItem(object content, JsonMergeSettings settings);
    public sealed virtual int IndexOf(JToken item);
    public sealed virtual void Insert(int index, JToken item);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual IEnumerator`1<JToken> GetEnumerator();
    public sealed virtual void Add(JToken item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(JToken item);
    public sealed virtual void CopyTo(JToken[] array, int arrayIndex);
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool Remove(JToken item);
    internal virtual int GetDeepHashCode();
}
[DefaultMemberAttribute("Item")]
[PreserveAttribute]
public class Newtonsoft.Json.Linq.JConstructor : JContainer {
    private string _name;
    private List`1<JToken> _values;
    protected IList`1<JToken> ChildrenTokens { get; }
    public string Name { get; public set; }
    public JTokenType Type { get; }
    public JToken Item { get; public set; }
    public JConstructor(JConstructor other);
    public JConstructor(string name, Object[] content);
    public JConstructor(string name, object content);
    public JConstructor(string name);
    protected virtual IList`1<JToken> get_ChildrenTokens();
    internal virtual int IndexOfItem(JToken item);
    internal virtual void MergeItem(object content, JsonMergeSettings settings);
    public string get_Name();
    public void set_Name(string value);
    public virtual JTokenType get_Type();
    internal virtual bool DeepEquals(JToken node);
    internal virtual JToken CloneToken();
    public virtual void WriteTo(JsonWriter writer, JsonConverter[] converters);
    public virtual JToken get_Item(object key);
    public virtual void set_Item(object key, JToken value);
    internal virtual int GetDeepHashCode();
    public static JConstructor Load(JsonReader reader);
    public static JConstructor Load(JsonReader reader, JsonLoadSettings settings);
}
[PreserveAttribute]
public abstract class Newtonsoft.Json.Linq.JContainer : JToken {
    internal ListChangedEventHandler _listChanged;
    internal AddingNewEventHandler _addingNew;
    private object _syncRoot;
    private bool _busy;
    protected IList`1<JToken> ChildrenTokens { get; }
    public bool HasValues { get; }
    public JToken First { get; }
    public JToken Last { get; }
    private JToken System.Collections.Generic.IList<Newtonsoft.Json.Linq.JToken>.Item { get; private set; }
    private bool System.Collections.Generic.ICollection<Newtonsoft.Json.Linq.JToken>.IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    public int Count { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool System.ComponentModel.IBindingList.AllowEdit { get; }
    private bool System.ComponentModel.IBindingList.AllowNew { get; }
    private bool System.ComponentModel.IBindingList.AllowRemove { get; }
    private bool System.ComponentModel.IBindingList.IsSorted { get; }
    private ListSortDirection System.ComponentModel.IBindingList.SortDirection { get; }
    private PropertyDescriptor System.ComponentModel.IBindingList.SortProperty { get; }
    private bool System.ComponentModel.IBindingList.SupportsChangeNotification { get; }
    private bool System.ComponentModel.IBindingList.SupportsSearching { get; }
    private bool System.ComponentModel.IBindingList.SupportsSorting { get; }
    internal JContainer(JContainer other);
    public sealed virtual void add_ListChanged(ListChangedEventHandler value);
    public sealed virtual void remove_ListChanged(ListChangedEventHandler value);
    public void add_AddingNew(AddingNewEventHandler value);
    public void remove_AddingNew(AddingNewEventHandler value);
    protected abstract virtual IList`1<JToken> get_ChildrenTokens();
    internal void CheckReentrancy();
    internal virtual IList`1<JToken> CreateChildrenCollection();
    protected virtual void OnAddingNew(AddingNewEventArgs e);
    protected virtual void OnListChanged(ListChangedEventArgs e);
    public virtual bool get_HasValues();
    internal bool ContentsEqual(JContainer container);
    public virtual JToken get_First();
    public virtual JToken get_Last();
    public virtual JEnumerable`1<JToken> Children();
    public virtual IEnumerable`1<T> Values();
    public IEnumerable`1<JToken> Descendants();
    public IEnumerable`1<JToken> DescendantsAndSelf();
    internal IEnumerable`1<JToken> GetDescendants(bool self);
    internal bool IsMultiContent(object content);
    internal JToken EnsureParentToken(JToken item, bool skipParentCheck);
    internal abstract virtual int IndexOfItem(JToken item);
    internal virtual void InsertItem(int index, JToken item, bool skipParentCheck);
    internal virtual void RemoveItemAt(int index);
    internal virtual bool RemoveItem(JToken item);
    internal virtual JToken GetItem(int index);
    internal virtual void SetItem(int index, JToken item);
    internal virtual void ClearItems();
    internal virtual void ReplaceItem(JToken existing, JToken replacement);
    internal virtual bool ContainsItem(JToken item);
    internal virtual void CopyItemsTo(Array array, int arrayIndex);
    internal static bool IsTokenUnchanged(JToken currentValue, JToken newValue);
    internal virtual void ValidateToken(JToken o, JToken existing);
    public virtual void Add(object content);
    internal void AddAndSkipParentCheck(JToken token);
    public void AddFirst(object content);
    internal void AddInternal(int index, object content, bool skipParentCheck);
    internal static JToken CreateFromContent(object content);
    public JsonWriter CreateWriter();
    public void ReplaceAll(object content);
    public void RemoveAll();
    internal abstract virtual void MergeItem(object content, JsonMergeSettings settings);
    public void Merge(object content);
    public void Merge(object content, JsonMergeSettings settings);
    internal void ReadTokenFrom(JsonReader reader, JsonLoadSettings options);
    internal void ReadContentFrom(JsonReader r, JsonLoadSettings settings);
    internal int ContentsHashCode();
    private sealed virtual override string System.ComponentModel.ITypedList.GetListName(PropertyDescriptor[] listAccessors);
    private sealed virtual override PropertyDescriptorCollection System.ComponentModel.ITypedList.GetItemProperties(PropertyDescriptor[] listAccessors);
    private sealed virtual override int System.Collections.Generic.IList<Newtonsoft.Json.Linq.JToken>.IndexOf(JToken item);
    private sealed virtual override void System.Collections.Generic.IList<Newtonsoft.Json.Linq.JToken>.Insert(int index, JToken item);
    private sealed virtual override void System.Collections.Generic.IList<Newtonsoft.Json.Linq.JToken>.RemoveAt(int index);
    private sealed virtual override JToken System.Collections.Generic.IList<Newtonsoft.Json.Linq.JToken>.get_Item(int index);
    private sealed virtual override void System.Collections.Generic.IList<Newtonsoft.Json.Linq.JToken>.set_Item(int index, JToken value);
    private sealed virtual override void System.Collections.Generic.ICollection<Newtonsoft.Json.Linq.JToken>.Add(JToken item);
    private sealed virtual override void System.Collections.Generic.ICollection<Newtonsoft.Json.Linq.JToken>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<Newtonsoft.Json.Linq.JToken>.Contains(JToken item);
    private sealed virtual override void System.Collections.Generic.ICollection<Newtonsoft.Json.Linq.JToken>.CopyTo(JToken[] array, int arrayIndex);
    private sealed virtual override bool System.Collections.Generic.ICollection<Newtonsoft.Json.Linq.JToken>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.Generic.ICollection<Newtonsoft.Json.Linq.JToken>.Remove(JToken item);
    private JToken EnsureValue(object value);
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override void System.Collections.IList.Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.IList.RemoveAt(int index);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override void System.ComponentModel.IBindingList.AddIndex(PropertyDescriptor property);
    private sealed virtual override object System.ComponentModel.IBindingList.AddNew();
    private sealed virtual override bool System.ComponentModel.IBindingList.get_AllowEdit();
    private sealed virtual override bool System.ComponentModel.IBindingList.get_AllowNew();
    private sealed virtual override bool System.ComponentModel.IBindingList.get_AllowRemove();
    private sealed virtual override void System.ComponentModel.IBindingList.ApplySort(PropertyDescriptor property, ListSortDirection direction);
    private sealed virtual override int System.ComponentModel.IBindingList.Find(PropertyDescriptor property, object key);
    private sealed virtual override bool System.ComponentModel.IBindingList.get_IsSorted();
    private sealed virtual override void System.ComponentModel.IBindingList.RemoveIndex(PropertyDescriptor property);
    private sealed virtual override void System.ComponentModel.IBindingList.RemoveSort();
    private sealed virtual override ListSortDirection System.ComponentModel.IBindingList.get_SortDirection();
    private sealed virtual override PropertyDescriptor System.ComponentModel.IBindingList.get_SortProperty();
    private sealed virtual override bool System.ComponentModel.IBindingList.get_SupportsChangeNotification();
    private sealed virtual override bool System.ComponentModel.IBindingList.get_SupportsSearching();
    private sealed virtual override bool System.ComponentModel.IBindingList.get_SupportsSorting();
    internal static void MergeEnumerableContent(JContainer target, IEnumerable content, JsonMergeSettings settings);
}
[DefaultMemberAttribute("Item")]
[PreserveAttribute]
public class Newtonsoft.Json.Linq.JEnumerable`1 : ValueType {
    public static JEnumerable`1<T> Empty;
    private IEnumerable`1<T> _enumerable;
    public IJEnumerable`1<JToken> Item { get; }
    public JEnumerable`1(IEnumerable`1<T> enumerable);
    private static JEnumerable`1();
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual IJEnumerable`1<JToken> get_Item(object key);
    public bool Equals(JEnumerable`1<T> other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[DefaultMemberAttribute("Item")]
[PreserveAttribute]
public class Newtonsoft.Json.Linq.JObject : JContainer {
    private JPropertyKeyedCollection _properties;
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler PropertyChanged;
    [CompilerGeneratedAttribute]
private PropertyChangingEventHandler PropertyChanging;
    protected IList`1<JToken> ChildrenTokens { get; }
    public JTokenType Type { get; }
    public JToken Item { get; public set; }
    public JToken Item { get; public set; }
    private ICollection`1<string> System.Collections.Generic.IDictionary<System.String,Newtonsoft.Json.Linq.JToken>.Keys { get; }
    private ICollection`1<JToken> System.Collections.Generic.IDictionary<System.String,Newtonsoft.Json.Linq.JToken>.Values { get; }
    private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,Newtonsoft.Json.Linq.JToken>>.IsReadOnly { get; }
    public JObject(JObject other);
    public JObject(Object[] content);
    public JObject(object content);
    protected virtual IList`1<JToken> get_ChildrenTokens();
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanging(PropertyChangingEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanging(PropertyChangingEventHandler value);
    internal virtual bool DeepEquals(JToken node);
    internal virtual int IndexOfItem(JToken item);
    internal virtual void InsertItem(int index, JToken item, bool skipParentCheck);
    internal virtual void ValidateToken(JToken o, JToken existing);
    internal virtual void MergeItem(object content, JsonMergeSettings settings);
    internal void InternalPropertyChanged(JProperty childProperty);
    internal void InternalPropertyChanging(JProperty childProperty);
    internal virtual JToken CloneToken();
    public virtual JTokenType get_Type();
    public IEnumerable`1<JProperty> Properties();
    public JProperty Property(string name);
    public JEnumerable`1<JToken> PropertyValues();
    public virtual JToken get_Item(object key);
    public virtual void set_Item(object key, JToken value);
    public sealed virtual JToken get_Item(string propertyName);
    public sealed virtual void set_Item(string propertyName, JToken value);
    public static JObject Load(JsonReader reader);
    public static JObject Load(JsonReader reader, JsonLoadSettings settings);
    public static JObject Parse(string json);
    public static JObject Parse(string json, JsonLoadSettings settings);
    public static JObject FromObject(object o);
    public static JObject FromObject(object o, JsonSerializer jsonSerializer);
    public virtual void WriteTo(JsonWriter writer, JsonConverter[] converters);
    public JToken GetValue(string propertyName);
    public JToken GetValue(string propertyName, StringComparison comparison);
    public bool TryGetValue(string propertyName, StringComparison comparison, JToken& value);
    public sealed virtual void Add(string propertyName, JToken value);
    private sealed virtual override bool System.Collections.Generic.IDictionary<System.String,Newtonsoft.Json.Linq.JToken>.ContainsKey(string key);
    private sealed virtual override ICollection`1<string> System.Collections.Generic.IDictionary<System.String,Newtonsoft.Json.Linq.JToken>.get_Keys();
    public sealed virtual bool Remove(string propertyName);
    public sealed virtual bool TryGetValue(string propertyName, JToken& value);
    private sealed virtual override ICollection`1<JToken> System.Collections.Generic.IDictionary<System.String,Newtonsoft.Json.Linq.JToken>.get_Values();
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,Newtonsoft.Json.Linq.JToken>>.Add(KeyValuePair`2<string, JToken> item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,Newtonsoft.Json.Linq.JToken>>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,Newtonsoft.Json.Linq.JToken>>.Contains(KeyValuePair`2<string, JToken> item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,Newtonsoft.Json.Linq.JToken>>.CopyTo(KeyValuePair`2[] array, int arrayIndex);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,Newtonsoft.Json.Linq.JToken>>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,Newtonsoft.Json.Linq.JToken>>.Remove(KeyValuePair`2<string, JToken> item);
    internal virtual int GetDeepHashCode();
    public sealed virtual IEnumerator`1<KeyValuePair`2<string, JToken>> GetEnumerator();
    protected virtual void OnPropertyChanged(string propertyName);
    protected virtual void OnPropertyChanging(string propertyName);
    private sealed virtual override PropertyDescriptorCollection System.ComponentModel.ICustomTypeDescriptor.GetProperties();
    private sealed virtual override PropertyDescriptorCollection System.ComponentModel.ICustomTypeDescriptor.GetProperties(Attribute[] attributes);
    private sealed virtual override AttributeCollection System.ComponentModel.ICustomTypeDescriptor.GetAttributes();
    private sealed virtual override string System.ComponentModel.ICustomTypeDescriptor.GetClassName();
    private sealed virtual override string System.ComponentModel.ICustomTypeDescriptor.GetComponentName();
    private sealed virtual override TypeConverter System.ComponentModel.ICustomTypeDescriptor.GetConverter();
    private sealed virtual override EventDescriptor System.ComponentModel.ICustomTypeDescriptor.GetDefaultEvent();
    private sealed virtual override PropertyDescriptor System.ComponentModel.ICustomTypeDescriptor.GetDefaultProperty();
    private sealed virtual override object System.ComponentModel.ICustomTypeDescriptor.GetEditor(Type editorBaseType);
    private sealed virtual override EventDescriptorCollection System.ComponentModel.ICustomTypeDescriptor.GetEvents(Attribute[] attributes);
    private sealed virtual override EventDescriptorCollection System.ComponentModel.ICustomTypeDescriptor.GetEvents();
    private sealed virtual override object System.ComponentModel.ICustomTypeDescriptor.GetPropertyOwner(PropertyDescriptor pd);
}
[PreserveAttribute]
public class Newtonsoft.Json.Linq.JProperty : JContainer {
    private JPropertyList _content;
    private string _name;
    protected IList`1<JToken> ChildrenTokens { get; }
    public string Name { get; }
    public JToken Value { get; public set; }
    public JTokenType Type { get; }
    public JProperty(JProperty other);
    internal JProperty(string name);
    public JProperty(string name, Object[] content);
    public JProperty(string name, object content);
    protected virtual IList`1<JToken> get_ChildrenTokens();
    [DebuggerStepThroughAttribute]
public string get_Name();
    [DebuggerStepThroughAttribute]
public JToken get_Value();
    public void set_Value(JToken value);
    internal virtual JToken GetItem(int index);
    internal virtual void SetItem(int index, JToken item);
    internal virtual bool RemoveItem(JToken item);
    internal virtual void RemoveItemAt(int index);
    internal virtual int IndexOfItem(JToken item);
    internal virtual void InsertItem(int index, JToken item, bool skipParentCheck);
    internal virtual bool ContainsItem(JToken item);
    internal virtual void MergeItem(object content, JsonMergeSettings settings);
    internal virtual void ClearItems();
    internal virtual bool DeepEquals(JToken node);
    internal virtual JToken CloneToken();
    [DebuggerStepThroughAttribute]
public virtual JTokenType get_Type();
    public virtual void WriteTo(JsonWriter writer, JsonConverter[] converters);
    internal virtual int GetDeepHashCode();
    public static JProperty Load(JsonReader reader);
    public static JProperty Load(JsonReader reader, JsonLoadSettings settings);
}
[PreserveAttribute]
public class Newtonsoft.Json.Linq.JPropertyDescriptor : PropertyDescriptor {
    public Type ComponentType { get; }
    public bool IsReadOnly { get; }
    public Type PropertyType { get; }
    protected int NameHashCode { get; }
    public JPropertyDescriptor(string name);
    private static JObject CastInstance(object instance);
    public virtual bool CanResetValue(object component);
    public virtual object GetValue(object component);
    public virtual void ResetValue(object component);
    public virtual void SetValue(object component, object value);
    public virtual bool ShouldSerializeValue(object component);
    public virtual Type get_ComponentType();
    public virtual bool get_IsReadOnly();
    public virtual Type get_PropertyType();
    protected virtual int get_NameHashCode();
}
[DefaultMemberAttribute("Item")]
[PreserveAttribute]
internal class Newtonsoft.Json.Linq.JPropertyKeyedCollection : Collection`1<JToken> {
    private static IEqualityComparer`1<string> Comparer;
    private Dictionary`2<string, JToken> _dictionary;
    public JToken Item { get; }
    public ICollection`1<string> Keys { get; }
    public ICollection`1<JToken> Values { get; }
    private static JPropertyKeyedCollection();
    private void AddKey(string key, JToken item);
    protected void ChangeItemKey(JToken item, string newKey);
    protected virtual void ClearItems();
    public bool Contains(string key);
    private bool ContainsItem(JToken item);
    private void EnsureDictionary();
    private string GetKeyForItem(JToken item);
    protected virtual void InsertItem(int index, JToken item);
    public bool Remove(string key);
    protected virtual void RemoveItem(int index);
    private void RemoveKey(string key);
    protected virtual void SetItem(int index, JToken item);
    public JToken get_Item(string key);
    public bool TryGetValue(string key, JToken& value);
    public ICollection`1<string> get_Keys();
    public ICollection`1<JToken> get_Values();
    public int IndexOfReference(JToken t);
    public bool Compare(JPropertyKeyedCollection other);
}
[PreserveAttribute]
public class Newtonsoft.Json.Linq.JRaw : JValue {
    public JRaw(JRaw other);
    public JRaw(object rawJson);
    public static JRaw Create(JsonReader reader);
    internal virtual JToken CloneToken();
}
[PreserveAttribute]
public class Newtonsoft.Json.Linq.JsonLoadSettings : object {
    private CommentHandling _commentHandling;
    private LineInfoHandling _lineInfoHandling;
    public CommentHandling CommentHandling { get; public set; }
    public LineInfoHandling LineInfoHandling { get; public set; }
    public CommentHandling get_CommentHandling();
    public void set_CommentHandling(CommentHandling value);
    public LineInfoHandling get_LineInfoHandling();
    public void set_LineInfoHandling(LineInfoHandling value);
}
[PreserveAttribute]
public class Newtonsoft.Json.Linq.JsonMergeSettings : object {
    private MergeArrayHandling _mergeArrayHandling;
    private MergeNullValueHandling _mergeNullValueHandling;
    public MergeArrayHandling MergeArrayHandling { get; public set; }
    public MergeNullValueHandling MergeNullValueHandling { get; public set; }
    public MergeArrayHandling get_MergeArrayHandling();
    public void set_MergeArrayHandling(MergeArrayHandling value);
    public MergeNullValueHandling get_MergeNullValueHandling();
    public void set_MergeNullValueHandling(MergeNullValueHandling value);
}
[PreserveAttribute]
internal class Newtonsoft.Json.Linq.JsonPath.ArrayIndexFilter : PathFilter {
    [CompilerGeneratedAttribute]
private Nullable`1<int> <Index>k__BackingField;
    public Nullable`1<int> Index { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_Index();
    [CompilerGeneratedAttribute]
public void set_Index(Nullable`1<int> value);
    public virtual IEnumerable`1<JToken> ExecuteFilter(IEnumerable`1<JToken> current, bool errorWhenNoMatch);
}
[PreserveAttribute]
internal class Newtonsoft.Json.Linq.JsonPath.ArrayMultipleIndexFilter : PathFilter {
    [CompilerGeneratedAttribute]
private List`1<int> <Indexes>k__BackingField;
    public List`1<int> Indexes { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<int> get_Indexes();
    [CompilerGeneratedAttribute]
public void set_Indexes(List`1<int> value);
    public virtual IEnumerable`1<JToken> ExecuteFilter(IEnumerable`1<JToken> current, bool errorWhenNoMatch);
}
[PreserveAttribute]
internal class Newtonsoft.Json.Linq.JsonPath.ArraySliceFilter : PathFilter {
    [CompilerGeneratedAttribute]
private Nullable`1<int> <Start>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <End>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <Step>k__BackingField;
    public Nullable`1<int> Start { get; public set; }
    public Nullable`1<int> End { get; public set; }
    public Nullable`1<int> Step { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_Start();
    [CompilerGeneratedAttribute]
public void set_Start(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_End();
    [CompilerGeneratedAttribute]
public void set_End(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_Step();
    [CompilerGeneratedAttribute]
public void set_Step(Nullable`1<int> value);
    public virtual IEnumerable`1<JToken> ExecuteFilter(IEnumerable`1<JToken> current, bool errorWhenNoMatch);
    private bool IsValid(int index, int stopIndex, bool positiveStep);
}
[PreserveAttribute]
internal class Newtonsoft.Json.Linq.JsonPath.BooleanQueryExpression : QueryExpression {
    [CompilerGeneratedAttribute]
private List`1<PathFilter> <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private JValue <Value>k__BackingField;
    public List`1<PathFilter> Path { get; public set; }
    public JValue Value { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<PathFilter> get_Path();
    [CompilerGeneratedAttribute]
public void set_Path(List`1<PathFilter> value);
    [CompilerGeneratedAttribute]
public JValue get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(JValue value);
    public virtual bool IsMatch(JToken t);
    private bool EqualsWithStringCoercion(JValue value, JValue queryValue);
}
[PreserveAttribute]
internal class Newtonsoft.Json.Linq.JsonPath.CompositeExpression : QueryExpression {
    [CompilerGeneratedAttribute]
private List`1<QueryExpression> <Expressions>k__BackingField;
    public List`1<QueryExpression> Expressions { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<QueryExpression> get_Expressions();
    [CompilerGeneratedAttribute]
public void set_Expressions(List`1<QueryExpression> value);
    public virtual bool IsMatch(JToken t);
}
[PreserveAttribute]
internal class Newtonsoft.Json.Linq.JsonPath.FieldFilter : PathFilter {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string Name { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    public virtual IEnumerable`1<JToken> ExecuteFilter(IEnumerable`1<JToken> current, bool errorWhenNoMatch);
}
[PreserveAttribute]
internal class Newtonsoft.Json.Linq.JsonPath.FieldMultipleFilter : PathFilter {
    [CompilerGeneratedAttribute]
private List`1<string> <Names>k__BackingField;
    public List`1<string> Names { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<string> get_Names();
    [CompilerGeneratedAttribute]
public void set_Names(List`1<string> value);
    public virtual IEnumerable`1<JToken> ExecuteFilter(IEnumerable`1<JToken> current, bool errorWhenNoMatch);
}
[PreserveAttribute]
internal class Newtonsoft.Json.Linq.JsonPath.JPath : object {
    private string _expression;
    [CompilerGeneratedAttribute]
private List`1<PathFilter> <Filters>k__BackingField;
    private int _currentIndex;
    public List`1<PathFilter> Filters { get; private set; }
    public JPath(string expression);
    [CompilerGeneratedAttribute]
public List`1<PathFilter> get_Filters();
    [CompilerGeneratedAttribute]
private void set_Filters(List`1<PathFilter> value);
    private void ParseMain();
    private bool ParsePath(List`1<PathFilter> filters, int currentPartStartIndex, bool query);
    private PathFilter ParseIndexer(char indexerOpenChar);
    private PathFilter ParseArrayIndexer(char indexerCloseChar);
    private void EatWhitespace();
    private PathFilter ParseQuery(char indexerCloseChar);
    private QueryExpression ParseExpression();
    private object ParseValue();
    private string ReadQuotedString();
    private bool Match(string s);
    private QueryOperator ParseOperator();
    private PathFilter ParseQuotedField(char indexerCloseChar);
    private void EnsureLength(string message);
    internal IEnumerable`1<JToken> Evaluate(JToken t, bool errorWhenNoMatch);
    internal static IEnumerable`1<JToken> Evaluate(List`1<PathFilter> filters, JToken t, bool errorWhenNoMatch);
}
[PreserveAttribute]
internal abstract class Newtonsoft.Json.Linq.JsonPath.PathFilter : object {
    public abstract virtual IEnumerable`1<JToken> ExecuteFilter(IEnumerable`1<JToken> current, bool errorWhenNoMatch);
    protected static JToken GetTokenIndex(JToken t, bool errorWhenNoMatch, int index);
}
[PreserveAttribute]
internal abstract class Newtonsoft.Json.Linq.JsonPath.QueryExpression : object {
    [CompilerGeneratedAttribute]
private QueryOperator <Operator>k__BackingField;
    public QueryOperator Operator { get; public set; }
    [CompilerGeneratedAttribute]
public QueryOperator get_Operator();
    [CompilerGeneratedAttribute]
public void set_Operator(QueryOperator value);
    public abstract virtual bool IsMatch(JToken t);
}
[PreserveAttribute]
internal class Newtonsoft.Json.Linq.JsonPath.QueryFilter : PathFilter {
    [CompilerGeneratedAttribute]
private QueryExpression <Expression>k__BackingField;
    public QueryExpression Expression { get; public set; }
    [CompilerGeneratedAttribute]
public QueryExpression get_Expression();
    [CompilerGeneratedAttribute]
public void set_Expression(QueryExpression value);
    public virtual IEnumerable`1<JToken> ExecuteFilter(IEnumerable`1<JToken> current, bool errorWhenNoMatch);
}
[PreserveAttribute]
internal enum Newtonsoft.Json.Linq.JsonPath.QueryOperator : Enum {
    public int value__;
    public static QueryOperator None;
    public static QueryOperator Equals;
    public static QueryOperator NotEquals;
    public static QueryOperator Exists;
    public static QueryOperator LessThan;
    public static QueryOperator LessThanOrEquals;
    public static QueryOperator GreaterThan;
    public static QueryOperator GreaterThanOrEquals;
    public static QueryOperator And;
    public static QueryOperator Or;
}
[PreserveAttribute]
internal class Newtonsoft.Json.Linq.JsonPath.ScanFilter : PathFilter {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string Name { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    public virtual IEnumerable`1<JToken> ExecuteFilter(IEnumerable`1<JToken> current, bool errorWhenNoMatch);
}
[DefaultMemberAttribute("Item")]
[PreserveAttribute]
public abstract class Newtonsoft.Json.Linq.JToken : object {
    private static JTokenEqualityComparer _equalityComparer;
    private JContainer _parent;
    private JToken _previous;
    private JToken _next;
    private object _annotations;
    private static JTokenType[] BooleanTypes;
    private static JTokenType[] NumberTypes;
    private static JTokenType[] StringTypes;
    private static JTokenType[] GuidTypes;
    private static JTokenType[] TimeSpanTypes;
    private static JTokenType[] UriTypes;
    private static JTokenType[] CharTypes;
    private static JTokenType[] DateTimeTypes;
    private static JTokenType[] BytesTypes;
    public static JTokenEqualityComparer EqualityComparer { get; }
    public JContainer Parent { get; internal set; }
    public JToken Root { get; }
    public JTokenType Type { get; }
    public bool HasValues { get; }
    public JToken Next { get; internal set; }
    public JToken Previous { get; internal set; }
    public string Path { get; }
    public JToken Item { get; public set; }
    public JToken First { get; }
    public JToken Last { get; }
    private IJEnumerable`1<JToken> Newtonsoft.Json.Linq.IJEnumerable<Newtonsoft.Json.Linq.JToken>.Item { get; }
    private int Newtonsoft.Json.IJsonLineInfo.LineNumber { get; }
    private int Newtonsoft.Json.IJsonLineInfo.LinePosition { get; }
    private static JToken();
    public static JTokenEqualityComparer get_EqualityComparer();
    [DebuggerStepThroughAttribute]
public JContainer get_Parent();
    internal void set_Parent(JContainer value);
    public JToken get_Root();
    internal abstract virtual JToken CloneToken();
    internal abstract virtual bool DeepEquals(JToken node);
    public abstract virtual JTokenType get_Type();
    public abstract virtual bool get_HasValues();
    public static bool DeepEquals(JToken t1, JToken t2);
    public JToken get_Next();
    internal void set_Next(JToken value);
    public JToken get_Previous();
    internal void set_Previous(JToken value);
    public string get_Path();
    public void AddAfterSelf(object content);
    public void AddBeforeSelf(object content);
    public IEnumerable`1<JToken> Ancestors();
    public IEnumerable`1<JToken> AncestorsAndSelf();
    internal IEnumerable`1<JToken> GetAncestors(bool self);
    public IEnumerable`1<JToken> AfterSelf();
    public IEnumerable`1<JToken> BeforeSelf();
    public virtual JToken get_Item(object key);
    public virtual void set_Item(object key, JToken value);
    public virtual T Value(object key);
    public virtual JToken get_First();
    public virtual JToken get_Last();
    public virtual JEnumerable`1<JToken> Children();
    public JEnumerable`1<T> Children();
    public virtual IEnumerable`1<T> Values();
    public void Remove();
    public void Replace(JToken value);
    public abstract virtual void WriteTo(JsonWriter writer, JsonConverter[] converters);
    public virtual string ToString();
    public string ToString(Formatting formatting, JsonConverter[] converters);
    private static JValue EnsureValue(JToken value);
    private static string GetType(JToken token);
    private static bool ValidateToken(JToken o, JTokenType[] validTypes, bool nullable);
    public static bool op_Explicit(JToken value);
    public static DateTimeOffset op_Explicit(JToken value);
    public static Nullable`1<bool> op_Explicit(JToken value);
    public static long op_Explicit(JToken value);
    public static Nullable`1<DateTime> op_Explicit(JToken value);
    public static Nullable`1<DateTimeOffset> op_Explicit(JToken value);
    public static Nullable`1<decimal> op_Explicit(JToken value);
    public static Nullable`1<double> op_Explicit(JToken value);
    public static Nullable`1<char> op_Explicit(JToken value);
    public static int op_Explicit(JToken value);
    public static short op_Explicit(JToken value);
    [CLSCompliantAttribute("False")]
public static ushort op_Explicit(JToken value);
    [CLSCompliantAttribute("False")]
public static char op_Explicit(JToken value);
    public static byte op_Explicit(JToken value);
    [CLSCompliantAttribute("False")]
public static sbyte op_Explicit(JToken value);
    public static Nullable`1<int> op_Explicit(JToken value);
    public static Nullable`1<short> op_Explicit(JToken value);
    [CLSCompliantAttribute("False")]
public static Nullable`1<ushort> op_Explicit(JToken value);
    public static Nullable`1<byte> op_Explicit(JToken value);
    [CLSCompliantAttribute("False")]
public static Nullable`1<sbyte> op_Explicit(JToken value);
    public static DateTime op_Explicit(JToken value);
    public static Nullable`1<long> op_Explicit(JToken value);
    public static Nullable`1<float> op_Explicit(JToken value);
    public static decimal op_Explicit(JToken value);
    [CLSCompliantAttribute("False")]
public static Nullable`1<UInt32> op_Explicit(JToken value);
    [CLSCompliantAttribute("False")]
public static Nullable`1<ulong> op_Explicit(JToken value);
    public static double op_Explicit(JToken value);
    public static float op_Explicit(JToken value);
    public static string op_Explicit(JToken value);
    [CLSCompliantAttribute("False")]
public static UInt32 op_Explicit(JToken value);
    [CLSCompliantAttribute("False")]
public static ulong op_Explicit(JToken value);
    public static Byte[] op_Explicit(JToken value);
    public static Guid op_Explicit(JToken value);
    public static Nullable`1<Guid> op_Explicit(JToken value);
    public static TimeSpan op_Explicit(JToken value);
    public static Nullable`1<TimeSpan> op_Explicit(JToken value);
    public static Uri op_Explicit(JToken value);
    public static JToken op_Implicit(bool value);
    public static JToken op_Implicit(DateTimeOffset value);
    public static JToken op_Implicit(byte value);
    public static JToken op_Implicit(Nullable`1<byte> value);
    [CLSCompliantAttribute("False")]
public static JToken op_Implicit(sbyte value);
    [CLSCompliantAttribute("False")]
public static JToken op_Implicit(Nullable`1<sbyte> value);
    public static JToken op_Implicit(Nullable`1<bool> value);
    public static JToken op_Implicit(long value);
    public static JToken op_Implicit(Nullable`1<DateTime> value);
    public static JToken op_Implicit(Nullable`1<DateTimeOffset> value);
    public static JToken op_Implicit(Nullable`1<decimal> value);
    public static JToken op_Implicit(Nullable`1<double> value);
    [CLSCompliantAttribute("False")]
public static JToken op_Implicit(short value);
    [CLSCompliantAttribute("False")]
public static JToken op_Implicit(ushort value);
    public static JToken op_Implicit(int value);
    public static JToken op_Implicit(Nullable`1<int> value);
    public static JToken op_Implicit(DateTime value);
    public static JToken op_Implicit(Nullable`1<long> value);
    public static JToken op_Implicit(Nullable`1<float> value);
    public static JToken op_Implicit(decimal value);
    [CLSCompliantAttribute("False")]
public static JToken op_Implicit(Nullable`1<short> value);
    [CLSCompliantAttribute("False")]
public static JToken op_Implicit(Nullable`1<ushort> value);
    [CLSCompliantAttribute("False")]
public static JToken op_Implicit(Nullable`1<UInt32> value);
    [CLSCompliantAttribute("False")]
public static JToken op_Implicit(Nullable`1<ulong> value);
    public static JToken op_Implicit(double value);
    public static JToken op_Implicit(float value);
    public static JToken op_Implicit(string value);
    [CLSCompliantAttribute("False")]
public static JToken op_Implicit(UInt32 value);
    [CLSCompliantAttribute("False")]
public static JToken op_Implicit(ulong value);
    public static JToken op_Implicit(Byte[] value);
    public static JToken op_Implicit(Uri value);
    public static JToken op_Implicit(TimeSpan value);
    public static JToken op_Implicit(Nullable`1<TimeSpan> value);
    public static JToken op_Implicit(Guid value);
    public static JToken op_Implicit(Nullable`1<Guid> value);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override IEnumerator`1<JToken> System.Collections.Generic.IEnumerable<Newtonsoft.Json.Linq.JToken>.GetEnumerator();
    internal abstract virtual int GetDeepHashCode();
    private sealed virtual override IJEnumerable`1<JToken> Newtonsoft.Json.Linq.IJEnumerable<Newtonsoft.Json.Linq.JToken>.get_Item(object key);
    public JsonReader CreateReader();
    internal static JToken FromObjectInternal(object o, JsonSerializer jsonSerializer);
    public static JToken FromObject(object o);
    public static JToken FromObject(object o, JsonSerializer jsonSerializer);
    public T ToObject();
    public object ToObject(Type objectType);
    public T ToObject(JsonSerializer jsonSerializer);
    public object ToObject(Type objectType, JsonSerializer jsonSerializer);
    public static JToken ReadFrom(JsonReader reader);
    public static JToken ReadFrom(JsonReader reader, JsonLoadSettings settings);
    public static JToken Parse(string json);
    public static JToken Parse(string json, JsonLoadSettings settings);
    public static JToken Load(JsonReader reader, JsonLoadSettings settings);
    public static JToken Load(JsonReader reader);
    internal void SetLineInfo(IJsonLineInfo lineInfo, JsonLoadSettings settings);
    internal void SetLineInfo(int lineNumber, int linePosition);
    private sealed virtual override bool Newtonsoft.Json.IJsonLineInfo.HasLineInfo();
    private sealed virtual override int Newtonsoft.Json.IJsonLineInfo.get_LineNumber();
    private sealed virtual override int Newtonsoft.Json.IJsonLineInfo.get_LinePosition();
    public JToken SelectToken(string path);
    public JToken SelectToken(string path, bool errorWhenNoMatch);
    public IEnumerable`1<JToken> SelectTokens(string path);
    public IEnumerable`1<JToken> SelectTokens(string path, bool errorWhenNoMatch);
    private sealed virtual override object System.ICloneable.Clone();
    public JToken DeepClone();
    public void AddAnnotation(object annotation);
    public T Annotation();
    public object Annotation(Type type);
    public IEnumerable`1<T> Annotations();
    public IEnumerable`1<object> Annotations(Type type);
    public void RemoveAnnotations();
    public void RemoveAnnotations(Type type);
}
[PreserveAttribute]
public class Newtonsoft.Json.Linq.JTokenEqualityComparer : object {
    public sealed virtual bool Equals(JToken x, JToken y);
    public sealed virtual int GetHashCode(JToken obj);
}
[PreserveAttribute]
public class Newtonsoft.Json.Linq.JTokenReader : JsonReader {
    private JToken _root;
    private string _initialPath;
    private JToken _parent;
    private JToken _current;
    public JToken CurrentToken { get; }
    private int Newtonsoft.Json.IJsonLineInfo.LineNumber { get; }
    private int Newtonsoft.Json.IJsonLineInfo.LinePosition { get; }
    public string Path { get; }
    public JTokenReader(JToken token);
    internal JTokenReader(JToken token, string initialPath);
    public JToken get_CurrentToken();
    public virtual bool Read();
    private bool ReadOver(JToken t);
    private bool ReadToEnd();
    private Nullable`1<JsonToken> GetEndToken(JContainer c);
    private bool ReadInto(JContainer c);
    private bool SetEnd(JContainer c);
    private void SetToken(JToken token);
    private string SafeToString(object value);
    private sealed virtual override bool Newtonsoft.Json.IJsonLineInfo.HasLineInfo();
    private sealed virtual override int Newtonsoft.Json.IJsonLineInfo.get_LineNumber();
    private sealed virtual override int Newtonsoft.Json.IJsonLineInfo.get_LinePosition();
    public virtual string get_Path();
}
[PreserveAttribute]
public enum Newtonsoft.Json.Linq.JTokenType : Enum {
    public int value__;
    public static JTokenType None;
    public static JTokenType Object;
    public static JTokenType Array;
    public static JTokenType Constructor;
    public static JTokenType Property;
    public static JTokenType Comment;
    public static JTokenType Integer;
    public static JTokenType Float;
    public static JTokenType String;
    public static JTokenType Boolean;
    public static JTokenType Null;
    public static JTokenType Undefined;
    public static JTokenType Date;
    public static JTokenType Raw;
    public static JTokenType Bytes;
    public static JTokenType Guid;
    public static JTokenType Uri;
    public static JTokenType TimeSpan;
}
[PreserveAttribute]
public class Newtonsoft.Json.Linq.JTokenWriter : JsonWriter {
    private JContainer _token;
    private JContainer _parent;
    private JValue _value;
    private JToken _current;
    public JToken CurrentToken { get; }
    public JToken Token { get; }
    public JTokenWriter(JContainer container);
    public JToken get_CurrentToken();
    public JToken get_Token();
    public virtual void Flush();
    public virtual void Close();
    public virtual void WriteStartObject();
    private void AddParent(JContainer container);
    private void RemoveParent();
    public virtual void WriteStartArray();
    public virtual void WriteStartConstructor(string name);
    protected virtual void WriteEnd(JsonToken token);
    public virtual void WritePropertyName(string name);
    private void AddValue(object value, JsonToken token);
    internal void AddValue(JValue value, JsonToken token);
    public virtual void WriteValue(object value);
    public virtual void WriteNull();
    public virtual void WriteUndefined();
    public virtual void WriteRaw(string json);
    public virtual void WriteComment(string text);
    public virtual void WriteValue(string value);
    public virtual void WriteValue(int value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(UInt32 value);
    public virtual void WriteValue(long value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(ulong value);
    public virtual void WriteValue(float value);
    public virtual void WriteValue(double value);
    public virtual void WriteValue(bool value);
    public virtual void WriteValue(short value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(ushort value);
    public virtual void WriteValue(char value);
    public virtual void WriteValue(byte value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(sbyte value);
    public virtual void WriteValue(decimal value);
    public virtual void WriteValue(DateTime value);
    public virtual void WriteValue(DateTimeOffset value);
    public virtual void WriteValue(Byte[] value);
    public virtual void WriteValue(TimeSpan value);
    public virtual void WriteValue(Guid value);
    public virtual void WriteValue(Uri value);
    internal virtual void WriteToken(JsonReader reader, bool writeChildren, bool writeDateConstructorAsDate, bool writeComments);
}
[PreserveAttribute]
public class Newtonsoft.Json.Linq.JValue : JToken {
    private JTokenType _valueType;
    private object _value;
    public bool HasValues { get; }
    public JTokenType Type { get; }
    public object Value { get; public set; }
    internal JValue(object value, JTokenType type);
    public JValue(JValue other);
    public JValue(long value);
    public JValue(decimal value);
    public JValue(char value);
    [CLSCompliantAttribute("False")]
public JValue(ulong value);
    public JValue(double value);
    public JValue(float value);
    public JValue(DateTime value);
    public JValue(DateTimeOffset value);
    public JValue(bool value);
    public JValue(string value);
    public JValue(Guid value);
    public JValue(Uri value);
    public JValue(TimeSpan value);
    public JValue(object value);
    internal virtual bool DeepEquals(JToken node);
    public virtual bool get_HasValues();
    internal static int Compare(JTokenType valueType, object objA, object objB);
    private static int CompareFloat(object objA, object objB);
    internal virtual JToken CloneToken();
    public static JValue CreateComment(string value);
    public static JValue CreateString(string value);
    public static JValue CreateNull();
    public static JValue CreateUndefined();
    private static JTokenType GetValueType(Nullable`1<JTokenType> current, object value);
    private static JTokenType GetStringValueType(Nullable`1<JTokenType> current);
    public virtual JTokenType get_Type();
    public object get_Value();
    public void set_Value(object value);
    public virtual void WriteTo(JsonWriter writer, JsonConverter[] converters);
    internal virtual int GetDeepHashCode();
    private static bool ValuesEquals(JValue v1, JValue v2);
    public bool Equals(JValue other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public string ToString(string format);
    public sealed virtual string ToString(IFormatProvider formatProvider);
    public sealed virtual string ToString(string format, IFormatProvider formatProvider);
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    public int CompareTo(JValue obj);
    private sealed virtual override TypeCode System.IConvertible.GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type conversionType, IFormatProvider provider);
}
[PreserveAttribute]
public enum Newtonsoft.Json.Linq.LineInfoHandling : Enum {
    public int value__;
    public static LineInfoHandling Ignore;
    public static LineInfoHandling Load;
}
[PreserveAttribute]
public enum Newtonsoft.Json.Linq.MergeArrayHandling : Enum {
    public int value__;
    public static MergeArrayHandling Concat;
    public static MergeArrayHandling Union;
    public static MergeArrayHandling Replace;
    public static MergeArrayHandling Merge;
}
[FlagsAttribute]
[PreserveAttribute]
public enum Newtonsoft.Json.Linq.MergeNullValueHandling : Enum {
    public int value__;
    public static MergeNullValueHandling Ignore;
    public static MergeNullValueHandling Merge;
}
[PreserveAttribute]
public enum Newtonsoft.Json.MemberSerialization : Enum {
    public int value__;
    public static MemberSerialization OptOut;
    public static MemberSerialization OptIn;
    public static MemberSerialization Fields;
}
[PreserveAttribute]
public enum Newtonsoft.Json.MetadataPropertyHandling : Enum {
    public int value__;
    public static MetadataPropertyHandling Default;
    public static MetadataPropertyHandling ReadAhead;
    public static MetadataPropertyHandling Ignore;
}
[PreserveAttribute]
public enum Newtonsoft.Json.MissingMemberHandling : Enum {
    public int value__;
    public static MissingMemberHandling Ignore;
    public static MissingMemberHandling Error;
}
[PreserveAttribute]
public enum Newtonsoft.Json.NullValueHandling : Enum {
    public int value__;
    public static NullValueHandling Include;
    public static NullValueHandling Ignore;
}
[PreserveAttribute]
public enum Newtonsoft.Json.ObjectCreationHandling : Enum {
    public int value__;
    public static ObjectCreationHandling Auto;
    public static ObjectCreationHandling Reuse;
    public static ObjectCreationHandling Replace;
}
[PreserveAttribute]
[FlagsAttribute]
public enum Newtonsoft.Json.PreserveReferencesHandling : Enum {
    public int value__;
    public static PreserveReferencesHandling None;
    public static PreserveReferencesHandling Objects;
    public static PreserveReferencesHandling Arrays;
    public static PreserveReferencesHandling All;
}
[PreserveAttribute]
internal enum Newtonsoft.Json.ReadType : Enum {
    public int value__;
    public static ReadType Read;
    public static ReadType ReadAsInt32;
    public static ReadType ReadAsBytes;
    public static ReadType ReadAsString;
    public static ReadType ReadAsDecimal;
    public static ReadType ReadAsDateTime;
    public static ReadType ReadAsDateTimeOffset;
    public static ReadType ReadAsDouble;
    public static ReadType ReadAsBoolean;
}
[PreserveAttribute]
public enum Newtonsoft.Json.ReferenceLoopHandling : Enum {
    public int value__;
    public static ReferenceLoopHandling Error;
    public static ReferenceLoopHandling Ignore;
    public static ReferenceLoopHandling Serialize;
}
[PreserveAttribute]
public enum Newtonsoft.Json.Required : Enum {
    public int value__;
    public static Required Default;
    public static Required AllowNull;
    public static Required Always;
    public static Required DisallowNull;
}
[PreserveAttribute]
internal static class Newtonsoft.Json.Serialization.CachedAttributeGetter`1 : object {
    private static ThreadSafeStore`2<object, T> TypeAttributeCache;
    private static CachedAttributeGetter`1();
    public static T GetAttribute(object type);
}
[PreserveAttribute]
public class Newtonsoft.Json.Serialization.CamelCasePropertyNamesContractResolver : DefaultContractResolver {
    protected virtual string ResolvePropertyName(string propertyName);
}
[PreserveAttribute]
public class Newtonsoft.Json.Serialization.DefaultContractResolver : object {
    private static IContractResolver _instance;
    private static JsonConverter[] BuiltInConverters;
    private static object TypeContractCacheLock;
    private static DefaultContractResolverState _sharedState;
    private DefaultContractResolverState _instanceState;
    private bool _sharedCache;
    [CompilerGeneratedAttribute]
private BindingFlags <DefaultMembersSearchFlags>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SerializeCompilerGeneratedMembers>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreSerializableInterface>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreSerializableAttribute>k__BackingField;
    internal static IContractResolver Instance { get; }
    public bool DynamicCodeGeneration { get; }
    [ObsoleteAttribute("DefaultMembersSearchFlags is obsolete. To modify the members serialized inherit from DefaultContractResolver and override the GetSerializableMembers method instead.")]
public BindingFlags DefaultMembersSearchFlags { get; public set; }
    public bool SerializeCompilerGeneratedMembers { get; public set; }
    public bool IgnoreSerializableInterface { get; public set; }
    public bool IgnoreSerializableAttribute { get; public set; }
    [ObsoleteAttribute("DefaultContractResolver(bool) is obsolete. Use the parameterless constructor and cache instances of the contract resolver within your application for optimal performance.")]
public DefaultContractResolver(bool shareCache);
    private static DefaultContractResolver();
    internal static IContractResolver get_Instance();
    public bool get_DynamicCodeGeneration();
    [CompilerGeneratedAttribute]
public BindingFlags get_DefaultMembersSearchFlags();
    [CompilerGeneratedAttribute]
public void set_DefaultMembersSearchFlags(BindingFlags value);
    [CompilerGeneratedAttribute]
public bool get_SerializeCompilerGeneratedMembers();
    [CompilerGeneratedAttribute]
public void set_SerializeCompilerGeneratedMembers(bool value);
    [CompilerGeneratedAttribute]
public bool get_IgnoreSerializableInterface();
    [CompilerGeneratedAttribute]
public void set_IgnoreSerializableInterface(bool value);
    [CompilerGeneratedAttribute]
public bool get_IgnoreSerializableAttribute();
    [CompilerGeneratedAttribute]
public void set_IgnoreSerializableAttribute(bool value);
    internal DefaultContractResolverState GetState();
    public virtual JsonContract ResolveContract(Type type);
    protected virtual List`1<MemberInfo> GetSerializableMembers(Type objectType);
    private bool ShouldSerializeEntityMember(MemberInfo memberInfo);
    protected virtual JsonObjectContract CreateObjectContract(Type objectType);
    private MemberInfo GetExtensionDataMemberForType(Type type);
    private static void SetExtensionDataDelegates(JsonObjectContract contract, MemberInfo member);
    private ConstructorInfo GetAttributeConstructor(Type objectType);
    private ConstructorInfo GetParameterizedConstructor(Type objectType);
    protected virtual IList`1<JsonProperty> CreateConstructorParameters(ConstructorInfo constructor, JsonPropertyCollection memberProperties);
    protected virtual JsonProperty CreatePropertyFromConstructorParameter(JsonProperty matchingMemberProperty, ParameterInfo parameterInfo);
    protected virtual JsonConverter ResolveContractConverter(Type objectType);
    private Func`1<object> GetDefaultCreator(Type createdType);
    private void InitializeContract(JsonContract contract);
    private void ResolveCallbackMethods(JsonContract contract, Type t);
    private void GetCallbackMethodsForType(Type type, List`1& onSerializing, List`1& onSerialized, List`1& onDeserializing, List`1& onDeserialized, List`1& onError);
    private static bool ShouldSkipDeserialized(Type t);
    private static bool ShouldSkipSerializing(Type t);
    private List`1<Type> GetClassHierarchyForType(Type type);
    protected virtual JsonDictionaryContract CreateDictionaryContract(Type objectType);
    protected virtual JsonArrayContract CreateArrayContract(Type objectType);
    protected virtual JsonPrimitiveContract CreatePrimitiveContract(Type objectType);
    protected virtual JsonLinqContract CreateLinqContract(Type objectType);
    protected virtual JsonISerializableContract CreateISerializableContract(Type objectType);
    protected virtual JsonStringContract CreateStringContract(Type objectType);
    protected virtual JsonContract CreateContract(Type objectType);
    internal static bool IsJsonPrimitiveType(Type t);
    internal static bool IsIConvertible(Type t);
    internal static bool CanConvertToString(Type type);
    private static bool IsValidCallback(MethodInfo method, ParameterInfo[] parameters, Type attributeType, MethodInfo currentCallback, Type& prevAttributeType);
    internal static string GetClrTypeFullName(Type type);
    protected virtual IList`1<JsonProperty> CreateProperties(Type type, MemberSerialization memberSerialization);
    protected virtual IValueProvider CreateMemberValueProvider(MemberInfo member);
    protected virtual JsonProperty CreateProperty(MemberInfo member, MemberSerialization memberSerialization);
    private void SetPropertySettingsFromAttributes(JsonProperty property, object attributeProvider, string name, Type declaringType, MemberSerialization memberSerialization, Boolean& allowNonPublicAccess);
    private Predicate`1<object> CreateShouldSerializeTest(MemberInfo member);
    private void SetIsSpecifiedActions(JsonProperty property, MemberInfo member, bool allowNonPublicAccess);
    protected virtual string ResolvePropertyName(string propertyName);
    protected virtual string ResolveDictionaryKey(string dictionaryKey);
    public string GetResolvedPropertyName(string propertyName);
}
[PreserveAttribute]
internal class Newtonsoft.Json.Serialization.DefaultContractResolverState : object {
    public Dictionary`2<ResolverContractKey, JsonContract> ContractCache;
    public PropertyNameTable NameTable;
}
[PreserveAttribute]
internal class Newtonsoft.Json.Serialization.DefaultReferenceResolver : object {
    private int _referenceCount;
    private BidirectionalDictionary`2<string, object> GetMappings(object context);
    public sealed virtual object ResolveReference(object context, string reference);
    public sealed virtual string GetReference(object context, object value);
    public sealed virtual void AddReference(object context, string reference, object value);
    public sealed virtual bool IsReferenced(object context, object value);
}
[PreserveAttribute]
public class Newtonsoft.Json.Serialization.DefaultSerializationBinder : SerializationBinder {
    internal static DefaultSerializationBinder Instance;
    private ThreadSafeStore`2<TypeNameKey, Type> _typeCache;
    private static DefaultSerializationBinder();
    private static Type GetTypeFromTypeNameKey(TypeNameKey typeNameKey);
    public virtual Type BindToType(string assemblyName, string typeName);
}
[PreserveAttribute]
public class Newtonsoft.Json.Serialization.DiagnosticsTraceWriter : object {
    [CompilerGeneratedAttribute]
private TraceLevel <LevelFilter>k__BackingField;
    public TraceLevel LevelFilter { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual TraceLevel get_LevelFilter();
    [CompilerGeneratedAttribute]
public void set_LevelFilter(TraceLevel value);
    private TraceEventType GetTraceEventType(TraceLevel level);
    public sealed virtual void Trace(TraceLevel level, string message, Exception ex);
}
[PreserveAttribute]
public class Newtonsoft.Json.Serialization.ErrorContext : object {
    [CompilerGeneratedAttribute]
private bool <Traced>k__BackingField;
    [CompilerGeneratedAttribute]
private Exception <Error>k__BackingField;
    [CompilerGeneratedAttribute]
private object <OriginalObject>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Member>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Handled>k__BackingField;
    internal bool Traced { get; internal set; }
    public Exception Error { get; private set; }
    public object OriginalObject { get; private set; }
    public object Member { get; private set; }
    public string Path { get; private set; }
    public bool Handled { get; public set; }
    internal ErrorContext(object originalObject, object member, string path, Exception error);
    [CompilerGeneratedAttribute]
internal bool get_Traced();
    [CompilerGeneratedAttribute]
internal void set_Traced(bool value);
    [CompilerGeneratedAttribute]
public Exception get_Error();
    [CompilerGeneratedAttribute]
private void set_Error(Exception value);
    [CompilerGeneratedAttribute]
public object get_OriginalObject();
    [CompilerGeneratedAttribute]
private void set_OriginalObject(object value);
    [CompilerGeneratedAttribute]
public object get_Member();
    [CompilerGeneratedAttribute]
private void set_Member(object value);
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
private void set_Path(string value);
    [CompilerGeneratedAttribute]
public bool get_Handled();
    [CompilerGeneratedAttribute]
public void set_Handled(bool value);
}
[PreserveAttribute]
public class Newtonsoft.Json.Serialization.ErrorEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private object <CurrentObject>k__BackingField;
    [CompilerGeneratedAttribute]
private ErrorContext <ErrorContext>k__BackingField;
    public object CurrentObject { get; private set; }
    public ErrorContext ErrorContext { get; private set; }
    public ErrorEventArgs(object currentObject, ErrorContext errorContext);
    [CompilerGeneratedAttribute]
public object get_CurrentObject();
    [CompilerGeneratedAttribute]
private void set_CurrentObject(object value);
    [CompilerGeneratedAttribute]
public ErrorContext get_ErrorContext();
    [CompilerGeneratedAttribute]
private void set_ErrorContext(ErrorContext value);
}
[PreserveAttribute]
public class Newtonsoft.Json.Serialization.ExtensionDataGetter : MulticastDelegate {
    public ExtensionDataGetter(object object, IntPtr method);
    public virtual IEnumerable`1<KeyValuePair`2<object, object>> Invoke(object o);
    public virtual IAsyncResult BeginInvoke(object o, AsyncCallback callback, object object);
    public virtual IEnumerable`1<KeyValuePair`2<object, object>> EndInvoke(IAsyncResult result);
}
[PreserveAttribute]
public class Newtonsoft.Json.Serialization.ExtensionDataSetter : MulticastDelegate {
    public ExtensionDataSetter(object object, IntPtr method);
    public virtual void Invoke(object o, string key, object value);
    public virtual IAsyncResult BeginInvoke(object o, string key, object value, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[PreserveAttribute]
public interface Newtonsoft.Json.Serialization.IAttributeProvider {
    public abstract virtual IList`1<Attribute> GetAttributes(bool inherit);
    public abstract virtual IList`1<Attribute> GetAttributes(Type attributeType, bool inherit);
}
[PreserveAttribute]
public interface Newtonsoft.Json.Serialization.IContractResolver {
    public abstract virtual JsonContract ResolveContract(Type type);
}
[PreserveAttribute]
public interface Newtonsoft.Json.Serialization.IReferenceResolver {
    public abstract virtual object ResolveReference(object context, string reference);
    public abstract virtual string GetReference(object context, object value);
    public abstract virtual bool IsReferenced(object context, object value);
    public abstract virtual void AddReference(object context, string reference, object value);
}
[PreserveAttribute]
public interface Newtonsoft.Json.Serialization.ITraceWriter {
    public TraceLevel LevelFilter { get; }
    public abstract virtual TraceLevel get_LevelFilter();
    public abstract virtual void Trace(TraceLevel level, string message, Exception ex);
}
[PreserveAttribute]
public interface Newtonsoft.Json.Serialization.IValueProvider {
    public abstract virtual void SetValue(object target, object value);
    public abstract virtual object GetValue(object target);
}
[PreserveAttribute]
public class Newtonsoft.Json.Serialization.JsonArrayContract : JsonContainerContract {
    [CompilerGeneratedAttribute]
private Type <CollectionItemType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsMultidimensionalArray>k__BackingField;
    private Type _genericCollectionDefinitionType;
    private Type _genericWrapperType;
    private ObjectConstructor`1<object> _genericWrapperCreator;
    private Func`1<object> _genericTemporaryCollectionCreator;
    [CompilerGeneratedAttribute]
private bool <IsArray>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ShouldCreateWrapper>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CanDeserialize>k__BackingField;
    private ConstructorInfo _parameterizedConstructor;
    private ObjectConstructor`1<object> _parameterizedCreator;
    private ObjectConstructor`1<object> _overrideCreator;
    [CompilerGeneratedAttribute]
private bool <HasParameterizedCreator>k__BackingField;
    public Type CollectionItemType { get; private set; }
    public bool IsMultidimensionalArray { get; private set; }
    internal bool IsArray { get; private set; }
    internal bool ShouldCreateWrapper { get; private set; }
    internal bool CanDeserialize { get; private set; }
    internal ObjectConstructor`1<object> ParameterizedCreator { get; }
    public ObjectConstructor`1<object> OverrideCreator { get; public set; }
    public bool HasParameterizedCreator { get; public set; }
    internal bool HasParameterizedCreatorInternal { get; }
    public JsonArrayContract(Type underlyingType);
    [CompilerGeneratedAttribute]
public Type get_CollectionItemType();
    [CompilerGeneratedAttribute]
private void set_CollectionItemType(Type value);
    [CompilerGeneratedAttribute]
public bool get_IsMultidimensionalArray();
    [CompilerGeneratedAttribute]
private void set_IsMultidimensionalArray(bool value);
    [CompilerGeneratedAttribute]
internal bool get_IsArray();
    [CompilerGeneratedAttribute]
private void set_IsArray(bool value);
    [CompilerGeneratedAttribute]
internal bool get_ShouldCreateWrapper();
    [CompilerGeneratedAttribute]
private void set_ShouldCreateWrapper(bool value);
    [CompilerGeneratedAttribute]
internal bool get_CanDeserialize();
    [CompilerGeneratedAttribute]
private void set_CanDeserialize(bool value);
    internal ObjectConstructor`1<object> get_ParameterizedCreator();
    public ObjectConstructor`1<object> get_OverrideCreator();
    public void set_OverrideCreator(ObjectConstructor`1<object> value);
    [CompilerGeneratedAttribute]
public bool get_HasParameterizedCreator();
    [CompilerGeneratedAttribute]
public void set_HasParameterizedCreator(bool value);
    internal bool get_HasParameterizedCreatorInternal();
    internal IWrappedCollection CreateWrapper(object list);
    internal IList CreateTemporaryCollection();
}
[PreserveAttribute]
public class Newtonsoft.Json.Serialization.JsonContainerContract : JsonContract {
    private JsonContract _itemContract;
    private JsonContract _finalItemContract;
    [CompilerGeneratedAttribute]
private JsonConverter <ItemConverter>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <ItemIsReference>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ReferenceLoopHandling> <ItemReferenceLoopHandling>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TypeNameHandling> <ItemTypeNameHandling>k__BackingField;
    internal JsonContract ItemContract { get; internal set; }
    internal JsonContract FinalItemContract { get; }
    public JsonConverter ItemConverter { get; public set; }
    public Nullable`1<bool> ItemIsReference { get; public set; }
    public Nullable`1<ReferenceLoopHandling> ItemReferenceLoopHandling { get; public set; }
    public Nullable`1<TypeNameHandling> ItemTypeNameHandling { get; public set; }
    internal JsonContainerContract(Type underlyingType);
    internal JsonContract get_ItemContract();
    internal void set_ItemContract(JsonContract value);
    internal JsonContract get_FinalItemContract();
    [CompilerGeneratedAttribute]
public JsonConverter get_ItemConverter();
    [CompilerGeneratedAttribute]
public void set_ItemConverter(JsonConverter value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_ItemIsReference();
    [CompilerGeneratedAttribute]
public void set_ItemIsReference(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<ReferenceLoopHandling> get_ItemReferenceLoopHandling();
    [CompilerGeneratedAttribute]
public void set_ItemReferenceLoopHandling(Nullable`1<ReferenceLoopHandling> value);
    [CompilerGeneratedAttribute]
public Nullable`1<TypeNameHandling> get_ItemTypeNameHandling();
    [CompilerGeneratedAttribute]
public void set_ItemTypeNameHandling(Nullable`1<TypeNameHandling> value);
}
[PreserveAttribute]
public abstract class Newtonsoft.Json.Serialization.JsonContract : object {
    internal bool IsNullable;
    internal bool IsConvertable;
    internal bool IsEnum;
    internal Type NonNullableUnderlyingType;
    internal ReadType InternalReadType;
    internal JsonContractType ContractType;
    internal bool IsReadOnlyOrFixedSize;
    internal bool IsSealed;
    internal bool IsInstantiable;
    private List`1<SerializationCallback> _onDeserializedCallbacks;
    private IList`1<SerializationCallback> _onDeserializingCallbacks;
    private IList`1<SerializationCallback> _onSerializedCallbacks;
    private IList`1<SerializationCallback> _onSerializingCallbacks;
    private IList`1<SerializationErrorCallback> _onErrorCallbacks;
    private Type _createdType;
    [CompilerGeneratedAttribute]
private Type <UnderlyingType>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <IsReference>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonConverter <Converter>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonConverter <InternalConverter>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`1<object> <DefaultCreator>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DefaultCreatorNonPublic>k__BackingField;
    public Type UnderlyingType { get; private set; }
    public Type CreatedType { get; public set; }
    public Nullable`1<bool> IsReference { get; public set; }
    public JsonConverter Converter { get; public set; }
    internal JsonConverter InternalConverter { get; internal set; }
    public IList`1<SerializationCallback> OnDeserializedCallbacks { get; }
    public IList`1<SerializationCallback> OnDeserializingCallbacks { get; }
    public IList`1<SerializationCallback> OnSerializedCallbacks { get; }
    public IList`1<SerializationCallback> OnSerializingCallbacks { get; }
    public IList`1<SerializationErrorCallback> OnErrorCallbacks { get; }
    [ObsoleteAttribute("This property is obsolete and has been replaced by the OnDeserializedCallbacks collection.")]
public MethodInfo OnDeserialized { get; public set; }
    [ObsoleteAttribute("This property is obsolete and has been replaced by the OnDeserializingCallbacks collection.")]
public MethodInfo OnDeserializing { get; public set; }
    [ObsoleteAttribute("This property is obsolete and has been replaced by the OnSerializedCallbacks collection.")]
public MethodInfo OnSerialized { get; public set; }
    [ObsoleteAttribute("This property is obsolete and has been replaced by the OnSerializingCallbacks collection.")]
public MethodInfo OnSerializing { get; public set; }
    [ObsoleteAttribute("This property is obsolete and has been replaced by the OnErrorCallbacks collection.")]
public MethodInfo OnError { get; public set; }
    public Func`1<object> DefaultCreator { get; public set; }
    public bool DefaultCreatorNonPublic { get; public set; }
    internal JsonContract(Type underlyingType);
    [CompilerGeneratedAttribute]
public Type get_UnderlyingType();
    [CompilerGeneratedAttribute]
private void set_UnderlyingType(Type value);
    public Type get_CreatedType();
    public void set_CreatedType(Type value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_IsReference();
    [CompilerGeneratedAttribute]
public void set_IsReference(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public JsonConverter get_Converter();
    [CompilerGeneratedAttribute]
public void set_Converter(JsonConverter value);
    [CompilerGeneratedAttribute]
internal JsonConverter get_InternalConverter();
    [CompilerGeneratedAttribute]
internal void set_InternalConverter(JsonConverter value);
    public IList`1<SerializationCallback> get_OnDeserializedCallbacks();
    public IList`1<SerializationCallback> get_OnDeserializingCallbacks();
    public IList`1<SerializationCallback> get_OnSerializedCallbacks();
    public IList`1<SerializationCallback> get_OnSerializingCallbacks();
    public IList`1<SerializationErrorCallback> get_OnErrorCallbacks();
    public MethodInfo get_OnDeserialized();
    public void set_OnDeserialized(MethodInfo value);
    public MethodInfo get_OnDeserializing();
    public void set_OnDeserializing(MethodInfo value);
    public MethodInfo get_OnSerialized();
    public void set_OnSerialized(MethodInfo value);
    public MethodInfo get_OnSerializing();
    public void set_OnSerializing(MethodInfo value);
    public MethodInfo get_OnError();
    public void set_OnError(MethodInfo value);
    [CompilerGeneratedAttribute]
public Func`1<object> get_DefaultCreator();
    [CompilerGeneratedAttribute]
public void set_DefaultCreator(Func`1<object> value);
    [CompilerGeneratedAttribute]
public bool get_DefaultCreatorNonPublic();
    [CompilerGeneratedAttribute]
public void set_DefaultCreatorNonPublic(bool value);
    internal void InvokeOnSerializing(object o, StreamingContext context);
    internal void InvokeOnSerialized(object o, StreamingContext context);
    internal void InvokeOnDeserializing(object o, StreamingContext context);
    internal void InvokeOnDeserialized(object o, StreamingContext context);
    internal void InvokeOnError(object o, StreamingContext context, ErrorContext errorContext);
    internal static SerializationCallback CreateSerializationCallback(MethodInfo callbackMethodInfo);
    internal static SerializationErrorCallback CreateSerializationErrorCallback(MethodInfo callbackMethodInfo);
}
[PreserveAttribute]
internal enum Newtonsoft.Json.Serialization.JsonContractType : Enum {
    public int value__;
    public static JsonContractType None;
    public static JsonContractType Object;
    public static JsonContractType Array;
    public static JsonContractType Primitive;
    public static JsonContractType String;
    public static JsonContractType Dictionary;
    public static JsonContractType Dynamic;
    public static JsonContractType Serializable;
    public static JsonContractType Linq;
}
[PreserveAttribute]
public class Newtonsoft.Json.Serialization.JsonDictionaryContract : JsonContainerContract {
    [CompilerGeneratedAttribute]
private Func`2<string, string> <DictionaryKeyResolver>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <DictionaryKeyType>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <DictionaryValueType>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonContract <KeyContract>k__BackingField;
    private Type _genericCollectionDefinitionType;
    private Type _genericWrapperType;
    private ObjectConstructor`1<object> _genericWrapperCreator;
    private Func`1<object> _genericTemporaryDictionaryCreator;
    [CompilerGeneratedAttribute]
private bool <ShouldCreateWrapper>k__BackingField;
    private ConstructorInfo _parameterizedConstructor;
    private ObjectConstructor`1<object> _overrideCreator;
    private ObjectConstructor`1<object> _parameterizedCreator;
    [CompilerGeneratedAttribute]
private bool <HasParameterizedCreator>k__BackingField;
    [ObsoleteAttribute("PropertyNameResolver is obsolete. Use DictionaryKeyResolver instead.")]
public Func`2<string, string> PropertyNameResolver { get; public set; }
    public Func`2<string, string> DictionaryKeyResolver { get; public set; }
    public Type DictionaryKeyType { get; private set; }
    public Type DictionaryValueType { get; private set; }
    internal JsonContract KeyContract { get; internal set; }
    internal bool ShouldCreateWrapper { get; private set; }
    internal ObjectConstructor`1<object> ParameterizedCreator { get; }
    public ObjectConstructor`1<object> OverrideCreator { get; public set; }
    public bool HasParameterizedCreator { get; public set; }
    internal bool HasParameterizedCreatorInternal { get; }
    public JsonDictionaryContract(Type underlyingType);
    public Func`2<string, string> get_PropertyNameResolver();
    public void set_PropertyNameResolver(Func`2<string, string> value);
    [CompilerGeneratedAttribute]
public Func`2<string, string> get_DictionaryKeyResolver();
    [CompilerGeneratedAttribute]
public void set_DictionaryKeyResolver(Func`2<string, string> value);
    [CompilerGeneratedAttribute]
public Type get_DictionaryKeyType();
    [CompilerGeneratedAttribute]
private void set_DictionaryKeyType(Type value);
    [CompilerGeneratedAttribute]
public Type get_DictionaryValueType();
    [CompilerGeneratedAttribute]
private void set_DictionaryValueType(Type value);
    [CompilerGeneratedAttribute]
internal JsonContract get_KeyContract();
    [CompilerGeneratedAttribute]
internal void set_KeyContract(JsonContract value);
    [CompilerGeneratedAttribute]
internal bool get_ShouldCreateWrapper();
    [CompilerGeneratedAttribute]
private void set_ShouldCreateWrapper(bool value);
    internal ObjectConstructor`1<object> get_ParameterizedCreator();
    public ObjectConstructor`1<object> get_OverrideCreator();
    public void set_OverrideCreator(ObjectConstructor`1<object> value);
    [CompilerGeneratedAttribute]
public bool get_HasParameterizedCreator();
    [CompilerGeneratedAttribute]
public void set_HasParameterizedCreator(bool value);
    internal bool get_HasParameterizedCreatorInternal();
    internal IWrappedDictionary CreateWrapper(object dictionary);
    internal IDictionary CreateTemporaryDictionary();
}
[PreserveAttribute]
internal class Newtonsoft.Json.Serialization.JsonFormatterConverter : object {
    private JsonSerializerInternalReader _reader;
    private JsonISerializableContract _contract;
    private JsonProperty _member;
    public JsonFormatterConverter(JsonSerializerInternalReader reader, JsonISerializableContract contract, JsonProperty member);
    private T GetTokenValue(object value);
    public sealed virtual object Convert(object value, Type type);
    public sealed virtual object Convert(object value, TypeCode typeCode);
    public sealed virtual bool ToBoolean(object value);
    public sealed virtual byte ToByte(object value);
    public sealed virtual char ToChar(object value);
    public sealed virtual DateTime ToDateTime(object value);
    public sealed virtual decimal ToDecimal(object value);
    public sealed virtual double ToDouble(object value);
    public sealed virtual short ToInt16(object value);
    public sealed virtual int ToInt32(object value);
    public sealed virtual long ToInt64(object value);
    public sealed virtual sbyte ToSByte(object value);
    public sealed virtual float ToSingle(object value);
    public sealed virtual string ToString(object value);
    public sealed virtual ushort ToUInt16(object value);
    public sealed virtual UInt32 ToUInt32(object value);
    public sealed virtual ulong ToUInt64(object value);
}
[PreserveAttribute]
public class Newtonsoft.Json.Serialization.JsonISerializableContract : JsonContainerContract {
    [CompilerGeneratedAttribute]
private ObjectConstructor`1<object> <ISerializableCreator>k__BackingField;
    public ObjectConstructor`1<object> ISerializableCreator { get; public set; }
    public JsonISerializableContract(Type underlyingType);
    [CompilerGeneratedAttribute]
public ObjectConstructor`1<object> get_ISerializableCreator();
    [CompilerGeneratedAttribute]
public void set_ISerializableCreator(ObjectConstructor`1<object> value);
}
[PreserveAttribute]
public class Newtonsoft.Json.Serialization.JsonLinqContract : JsonContract {
    public JsonLinqContract(Type underlyingType);
}
[PreserveAttribute]
public class Newtonsoft.Json.Serialization.JsonObjectContract : JsonContainerContract {
    [CompilerGeneratedAttribute]
private MemberSerialization <MemberSerialization>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<Required> <ItemRequired>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonPropertyCollection <Properties>k__BackingField;
    [CompilerGeneratedAttribute]
private ExtensionDataSetter <ExtensionDataSetter>k__BackingField;
    [CompilerGeneratedAttribute]
private ExtensionDataGetter <ExtensionDataGetter>k__BackingField;
    internal bool ExtensionDataIsJToken;
    private Nullable`1<bool> _hasRequiredOrDefaultValueProperties;
    private ConstructorInfo _parametrizedConstructor;
    private ConstructorInfo _overrideConstructor;
    private ObjectConstructor`1<object> _overrideCreator;
    private ObjectConstructor`1<object> _parameterizedCreator;
    private JsonPropertyCollection _creatorParameters;
    private Type _extensionDataValueType;
    public MemberSerialization MemberSerialization { get; public set; }
    public Nullable`1<Required> ItemRequired { get; public set; }
    public JsonPropertyCollection Properties { get; private set; }
    [ObsoleteAttribute("ConstructorParameters is obsolete. Use CreatorParameters instead.")]
public JsonPropertyCollection ConstructorParameters { get; }
    public JsonPropertyCollection CreatorParameters { get; }
    [ObsoleteAttribute("OverrideConstructor is obsolete. Use OverrideCreator instead.")]
public ConstructorInfo OverrideConstructor { get; public set; }
    [ObsoleteAttribute("ParametrizedConstructor is obsolete. Use OverrideCreator instead.")]
public ConstructorInfo ParametrizedConstructor { get; public set; }
    public ObjectConstructor`1<object> OverrideCreator { get; public set; }
    internal ObjectConstructor`1<object> ParameterizedCreator { get; }
    public ExtensionDataSetter ExtensionDataSetter { get; public set; }
    public ExtensionDataGetter ExtensionDataGetter { get; public set; }
    public Type ExtensionDataValueType { get; public set; }
    internal bool HasRequiredOrDefaultValueProperties { get; }
    public JsonObjectContract(Type underlyingType);
    [CompilerGeneratedAttribute]
public MemberSerialization get_MemberSerialization();
    [CompilerGeneratedAttribute]
public void set_MemberSerialization(MemberSerialization value);
    [CompilerGeneratedAttribute]
public Nullable`1<Required> get_ItemRequired();
    [CompilerGeneratedAttribute]
public void set_ItemRequired(Nullable`1<Required> value);
    [CompilerGeneratedAttribute]
public JsonPropertyCollection get_Properties();
    [CompilerGeneratedAttribute]
private void set_Properties(JsonPropertyCollection value);
    public JsonPropertyCollection get_ConstructorParameters();
    public JsonPropertyCollection get_CreatorParameters();
    public ConstructorInfo get_OverrideConstructor();
    public void set_OverrideConstructor(ConstructorInfo value);
    public ConstructorInfo get_ParametrizedConstructor();
    public void set_ParametrizedConstructor(ConstructorInfo value);
    public ObjectConstructor`1<object> get_OverrideCreator();
    public void set_OverrideCreator(ObjectConstructor`1<object> value);
    internal ObjectConstructor`1<object> get_ParameterizedCreator();
    [CompilerGeneratedAttribute]
public ExtensionDataSetter get_ExtensionDataSetter();
    [CompilerGeneratedAttribute]
public void set_ExtensionDataSetter(ExtensionDataSetter value);
    [CompilerGeneratedAttribute]
public ExtensionDataGetter get_ExtensionDataGetter();
    [CompilerGeneratedAttribute]
public void set_ExtensionDataGetter(ExtensionDataGetter value);
    public Type get_ExtensionDataValueType();
    public void set_ExtensionDataValueType(Type value);
    internal bool get_HasRequiredOrDefaultValueProperties();
    internal object GetUninitializedObject();
}
[PreserveAttribute]
public class Newtonsoft.Json.Serialization.JsonPrimitiveContract : JsonContract {
    [CompilerGeneratedAttribute]
private PrimitiveTypeCode <TypeCode>k__BackingField;
    private static Dictionary`2<Type, ReadType> ReadTypeMap;
    internal PrimitiveTypeCode TypeCode { get; internal set; }
    public JsonPrimitiveContract(Type underlyingType);
    private static JsonPrimitiveContract();
    [CompilerGeneratedAttribute]
internal PrimitiveTypeCode get_TypeCode();
    [CompilerGeneratedAttribute]
internal void set_TypeCode(PrimitiveTypeCode value);
}
[PreserveAttribute]
public class Newtonsoft.Json.Serialization.JsonProperty : object {
    internal Nullable`1<Required> _required;
    internal bool _hasExplicitDefaultValue;
    private object _defaultValue;
    private bool _hasGeneratedDefaultValue;
    private string _propertyName;
    internal bool _skipPropertyNameEscape;
    private Type _propertyType;
    [CompilerGeneratedAttribute]
private JsonContract <PropertyContract>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <DeclaringType>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <Order>k__BackingField;
    [CompilerGeneratedAttribute]
private string <UnderlyingName>k__BackingField;
    [CompilerGeneratedAttribute]
private IValueProvider <ValueProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private IAttributeProvider <AttributeProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonConverter <Converter>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonConverter <MemberConverter>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Ignored>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Readable>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Writable>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasMemberAttribute>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <IsReference>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<NullValueHandling> <NullValueHandling>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DefaultValueHandling> <DefaultValueHandling>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ReferenceLoopHandling> <ReferenceLoopHandling>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ObjectCreationHandling> <ObjectCreationHandling>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TypeNameHandling> <TypeNameHandling>k__BackingField;
    [CompilerGeneratedAttribute]
private Predicate`1<object> <ShouldSerialize>k__BackingField;
    [CompilerGeneratedAttribute]
private Predicate`1<object> <ShouldDeserialize>k__BackingField;
    [CompilerGeneratedAttribute]
private Predicate`1<object> <GetIsSpecified>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`2<object, object> <SetIsSpecified>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonConverter <ItemConverter>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <ItemIsReference>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TypeNameHandling> <ItemTypeNameHandling>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ReferenceLoopHandling> <ItemReferenceLoopHandling>k__BackingField;
    internal JsonContract PropertyContract { get; internal set; }
    public string PropertyName { get; public set; }
    public Type DeclaringType { get; public set; }
    public Nullable`1<int> Order { get; public set; }
    public string UnderlyingName { get; public set; }
    public IValueProvider ValueProvider { get; public set; }
    public IAttributeProvider AttributeProvider { get; public set; }
    public Type PropertyType { get; public set; }
    public JsonConverter Converter { get; public set; }
    public JsonConverter MemberConverter { get; public set; }
    public bool Ignored { get; public set; }
    public bool Readable { get; public set; }
    public bool Writable { get; public set; }
    public bool HasMemberAttribute { get; public set; }
    public object DefaultValue { get; public set; }
    public Required Required { get; public set; }
    public Nullable`1<bool> IsReference { get; public set; }
    public Nullable`1<NullValueHandling> NullValueHandling { get; public set; }
    public Nullable`1<DefaultValueHandling> DefaultValueHandling { get; public set; }
    public Nullable`1<ReferenceLoopHandling> ReferenceLoopHandling { get; public set; }
    public Nullable`1<ObjectCreationHandling> ObjectCreationHandling { get; public set; }
    public Nullable`1<TypeNameHandling> TypeNameHandling { get; public set; }
    public Predicate`1<object> ShouldSerialize { get; public set; }
    public Predicate`1<object> ShouldDeserialize { get; public set; }
    public Predicate`1<object> GetIsSpecified { get; public set; }
    public Action`2<object, object> SetIsSpecified { get; public set; }
    public JsonConverter ItemConverter { get; public set; }
    public Nullable`1<bool> ItemIsReference { get; public set; }
    public Nullable`1<TypeNameHandling> ItemTypeNameHandling { get; public set; }
    public Nullable`1<ReferenceLoopHandling> ItemReferenceLoopHandling { get; public set; }
    [CompilerGeneratedAttribute]
internal JsonContract get_PropertyContract();
    [CompilerGeneratedAttribute]
internal void set_PropertyContract(JsonContract value);
    public string get_PropertyName();
    public void set_PropertyName(string value);
    [CompilerGeneratedAttribute]
public Type get_DeclaringType();
    [CompilerGeneratedAttribute]
public void set_DeclaringType(Type value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_Order();
    [CompilerGeneratedAttribute]
public void set_Order(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public string get_UnderlyingName();
    [CompilerGeneratedAttribute]
public void set_UnderlyingName(string value);
    [CompilerGeneratedAttribute]
public IValueProvider get_ValueProvider();
    [CompilerGeneratedAttribute]
public void set_ValueProvider(IValueProvider value);
    [CompilerGeneratedAttribute]
public IAttributeProvider get_AttributeProvider();
    [CompilerGeneratedAttribute]
public void set_AttributeProvider(IAttributeProvider value);
    public Type get_PropertyType();
    public void set_PropertyType(Type value);
    [CompilerGeneratedAttribute]
public JsonConverter get_Converter();
    [CompilerGeneratedAttribute]
public void set_Converter(JsonConverter value);
    [CompilerGeneratedAttribute]
public JsonConverter get_MemberConverter();
    [CompilerGeneratedAttribute]
public void set_MemberConverter(JsonConverter value);
    [CompilerGeneratedAttribute]
public bool get_Ignored();
    [CompilerGeneratedAttribute]
public void set_Ignored(bool value);
    [CompilerGeneratedAttribute]
public bool get_Readable();
    [CompilerGeneratedAttribute]
public void set_Readable(bool value);
    [CompilerGeneratedAttribute]
public bool get_Writable();
    [CompilerGeneratedAttribute]
public void set_Writable(bool value);
    [CompilerGeneratedAttribute]
public bool get_HasMemberAttribute();
    [CompilerGeneratedAttribute]
public void set_HasMemberAttribute(bool value);
    public object get_DefaultValue();
    public void set_DefaultValue(object value);
    internal object GetResolvedDefaultValue();
    public Required get_Required();
    public void set_Required(Required value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_IsReference();
    [CompilerGeneratedAttribute]
public void set_IsReference(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<NullValueHandling> get_NullValueHandling();
    [CompilerGeneratedAttribute]
public void set_NullValueHandling(Nullable`1<NullValueHandling> value);
    [CompilerGeneratedAttribute]
public Nullable`1<DefaultValueHandling> get_DefaultValueHandling();
    [CompilerGeneratedAttribute]
public void set_DefaultValueHandling(Nullable`1<DefaultValueHandling> value);
    [CompilerGeneratedAttribute]
public Nullable`1<ReferenceLoopHandling> get_ReferenceLoopHandling();
    [CompilerGeneratedAttribute]
public void set_ReferenceLoopHandling(Nullable`1<ReferenceLoopHandling> value);
    [CompilerGeneratedAttribute]
public Nullable`1<ObjectCreationHandling> get_ObjectCreationHandling();
    [CompilerGeneratedAttribute]
public void set_ObjectCreationHandling(Nullable`1<ObjectCreationHandling> value);
    [CompilerGeneratedAttribute]
public Nullable`1<TypeNameHandling> get_TypeNameHandling();
    [CompilerGeneratedAttribute]
public void set_TypeNameHandling(Nullable`1<TypeNameHandling> value);
    [CompilerGeneratedAttribute]
public Predicate`1<object> get_ShouldSerialize();
    [CompilerGeneratedAttribute]
public void set_ShouldSerialize(Predicate`1<object> value);
    [CompilerGeneratedAttribute]
public Predicate`1<object> get_ShouldDeserialize();
    [CompilerGeneratedAttribute]
public void set_ShouldDeserialize(Predicate`1<object> value);
    [CompilerGeneratedAttribute]
public Predicate`1<object> get_GetIsSpecified();
    [CompilerGeneratedAttribute]
public void set_GetIsSpecified(Predicate`1<object> value);
    [CompilerGeneratedAttribute]
public Action`2<object, object> get_SetIsSpecified();
    [CompilerGeneratedAttribute]
public void set_SetIsSpecified(Action`2<object, object> value);
    public virtual string ToString();
    [CompilerGeneratedAttribute]
public JsonConverter get_ItemConverter();
    [CompilerGeneratedAttribute]
public void set_ItemConverter(JsonConverter value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_ItemIsReference();
    [CompilerGeneratedAttribute]
public void set_ItemIsReference(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<TypeNameHandling> get_ItemTypeNameHandling();
    [CompilerGeneratedAttribute]
public void set_ItemTypeNameHandling(Nullable`1<TypeNameHandling> value);
    [CompilerGeneratedAttribute]
public Nullable`1<ReferenceLoopHandling> get_ItemReferenceLoopHandling();
    [CompilerGeneratedAttribute]
public void set_ItemReferenceLoopHandling(Nullable`1<ReferenceLoopHandling> value);
    internal void WritePropertyName(JsonWriter writer);
}
[PreserveAttribute]
public class Newtonsoft.Json.Serialization.JsonPropertyCollection : KeyedCollection`2<string, JsonProperty> {
    private Type _type;
    private List`1<JsonProperty> _list;
    public JsonPropertyCollection(Type type);
    protected virtual string GetKeyForItem(JsonProperty item);
    public void AddProperty(JsonProperty property);
    public JsonProperty GetClosestMatchProperty(string propertyName);
    private bool TryGetValue(string key, JsonProperty& item);
    public JsonProperty GetProperty(string propertyName, StringComparison comparisonType);
}
[PreserveAttribute]
internal abstract class Newtonsoft.Json.Serialization.JsonSerializerInternalBase : object {
    private ErrorContext _currentErrorContext;
    private BidirectionalDictionary`2<string, object> _mappings;
    internal JsonSerializer Serializer;
    internal ITraceWriter TraceWriter;
    protected JsonSerializerProxy InternalSerializer;
    internal BidirectionalDictionary`2<string, object> DefaultReferenceMappings { get; }
    protected JsonSerializerInternalBase(JsonSerializer serializer);
    internal BidirectionalDictionary`2<string, object> get_DefaultReferenceMappings();
    private ErrorContext GetErrorContext(object currentObject, object member, string path, Exception error);
    protected void ClearErrorContext();
    protected bool IsErrorHandled(object currentObject, JsonContract contract, object keyValue, IJsonLineInfo lineInfo, string path, Exception ex);
}
[PreserveAttribute]
internal class Newtonsoft.Json.Serialization.JsonSerializerInternalReader : JsonSerializerInternalBase {
    public JsonSerializerInternalReader(JsonSerializer serializer);
    public void Populate(JsonReader reader, object target);
    private JsonContract GetContractSafe(Type type);
    public object Deserialize(JsonReader reader, Type objectType, bool checkAdditionalContent);
    private JsonSerializerProxy GetInternalSerializer();
    private JToken CreateJToken(JsonReader reader, JsonContract contract);
    private JToken CreateJObject(JsonReader reader);
    private object CreateValueInternal(JsonReader reader, Type objectType, JsonContract contract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerMember, object existingValue);
    private static bool CoerceEmptyStringToNull(Type objectType, JsonContract contract, string s);
    internal string GetExpectedDescription(JsonContract contract);
    private JsonConverter GetConverter(JsonContract contract, JsonConverter memberConverter, JsonContainerContract containerContract, JsonProperty containerProperty);
    private object CreateObject(JsonReader reader, Type objectType, JsonContract contract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerMember, object existingValue);
    private bool ReadMetadataPropertiesToken(JTokenReader reader, Type& objectType, JsonContract& contract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerMember, object existingValue, Object& newValue, String& id);
    private bool ReadMetadataProperties(JsonReader reader, Type& objectType, JsonContract& contract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerMember, object existingValue, Object& newValue, String& id);
    private void ResolveTypeName(JsonReader reader, Type& objectType, JsonContract& contract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerMember, string qualifiedTypeName);
    private JsonArrayContract EnsureArrayContract(JsonReader reader, Type objectType, JsonContract contract);
    private object CreateList(JsonReader reader, Type objectType, JsonContract contract, JsonProperty member, object existingValue, string id);
    private bool HasNoDefinedType(JsonContract contract);
    private object EnsureType(JsonReader reader, object value, CultureInfo culture, JsonContract contract, Type targetType);
    private bool SetPropertyValue(JsonProperty property, JsonConverter propertyConverter, JsonContainerContract containerContract, JsonProperty containerProperty, JsonReader reader, object target);
    private bool CalculatePropertyDetails(JsonProperty property, JsonConverter& propertyConverter, JsonContainerContract containerContract, JsonProperty containerProperty, JsonReader reader, object target, Boolean& useExistingValue, Object& currentValue, JsonContract& propertyContract, Boolean& gottenCurrentValue);
    private void AddReference(JsonReader reader, string id, object value);
    private bool HasFlag(DefaultValueHandling value, DefaultValueHandling flag);
    private bool ShouldSetPropertyValue(JsonProperty property, object value);
    private IList CreateNewList(JsonReader reader, JsonArrayContract contract, Boolean& createdFromNonDefaultCreator);
    private IDictionary CreateNewDictionary(JsonReader reader, JsonDictionaryContract contract, Boolean& createdFromNonDefaultCreator);
    private void OnDeserializing(JsonReader reader, JsonContract contract, object value);
    private void OnDeserialized(JsonReader reader, JsonContract contract, object value);
    private object PopulateDictionary(IDictionary dictionary, JsonReader reader, JsonDictionaryContract contract, JsonProperty containerProperty, string id);
    private object PopulateMultidimensionalArray(IList list, JsonReader reader, JsonArrayContract contract, JsonProperty containerProperty, string id);
    private void ThrowUnexpectedEndException(JsonReader reader, JsonContract contract, object currentObject, string message);
    private object PopulateList(IList list, JsonReader reader, JsonArrayContract contract, JsonProperty containerProperty, string id);
    private object CreateISerializable(JsonReader reader, JsonISerializableContract contract, JsonProperty member, string id);
    internal object CreateISerializableItem(JToken token, Type type, JsonISerializableContract contract, JsonProperty member);
    private object CreateObjectUsingCreatorWithParameters(JsonReader reader, JsonObjectContract contract, JsonProperty containerProperty, ObjectConstructor`1<object> creator, string id);
    private object DeserializeConvertable(JsonConverter converter, JsonReader reader, Type objectType, object existingValue);
    private List`1<CreatorPropertyContext> ResolvePropertyAndCreatorValues(JsonObjectContract contract, JsonProperty containerProperty, JsonReader reader, Type objectType);
    private bool ReadForType(JsonReader reader, JsonContract contract, bool hasConverter);
    public object CreateNewObject(JsonReader reader, JsonObjectContract objectContract, JsonProperty containerMember, JsonProperty containerProperty, string id, Boolean& createdFromNonDefaultCreator);
    private object PopulateObject(object newObject, JsonReader reader, JsonObjectContract contract, JsonProperty member, string id);
    private bool ShouldDeserialize(JsonReader reader, JsonProperty property, object target);
    private bool CheckPropertyName(JsonReader reader, string memberName);
    private void SetExtensionData(JsonObjectContract contract, JsonProperty member, JsonReader reader, string memberName, object o);
    private object ReadExtensionDataValue(JsonObjectContract contract, JsonProperty member, JsonReader reader);
    private void EndProcessProperty(object newObject, JsonReader reader, JsonObjectContract contract, int initialDepth, JsonProperty property, PropertyPresence presence, bool setDefaultValue);
    private void SetPropertyPresence(JsonReader reader, JsonProperty property, Dictionary`2<JsonProperty, PropertyPresence> requiredProperties);
    private void HandleError(JsonReader reader, bool readPastError, int initialDepth);
}
[PreserveAttribute]
internal class Newtonsoft.Json.Serialization.JsonSerializerInternalWriter : JsonSerializerInternalBase {
    private Type _rootType;
    private int _rootLevel;
    private List`1<object> _serializeStack;
    public JsonSerializerInternalWriter(JsonSerializer serializer);
    public void Serialize(JsonWriter jsonWriter, object value, Type objectType);
    private JsonSerializerProxy GetInternalSerializer();
    private JsonContract GetContractSafe(object value);
    private void SerializePrimitive(JsonWriter writer, object value, JsonPrimitiveContract contract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerProperty);
    private void SerializeValue(JsonWriter writer, object value, JsonContract valueContract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerProperty);
    private Nullable`1<bool> ResolveIsReference(JsonContract contract, JsonProperty property, JsonContainerContract collectionContract, JsonProperty containerProperty);
    private bool ShouldWriteReference(object value, JsonProperty property, JsonContract valueContract, JsonContainerContract collectionContract, JsonProperty containerProperty);
    private bool ShouldWriteProperty(object memberValue, JsonProperty property);
    private bool CheckForCircularReference(JsonWriter writer, object value, JsonProperty property, JsonContract contract, JsonContainerContract containerContract, JsonProperty containerProperty);
    private void WriteReference(JsonWriter writer, object value);
    private string GetReference(JsonWriter writer, object value);
    internal static bool TryConvertToString(object value, Type type, String& s);
    private void SerializeString(JsonWriter writer, object value, JsonStringContract contract);
    private void OnSerializing(JsonWriter writer, JsonContract contract, object value);
    private void OnSerialized(JsonWriter writer, JsonContract contract, object value);
    private void SerializeObject(JsonWriter writer, object value, JsonObjectContract contract, JsonProperty member, JsonContainerContract collectionContract, JsonProperty containerProperty);
    private bool CalculatePropertyValues(JsonWriter writer, object value, JsonContainerContract contract, JsonProperty member, JsonProperty property, JsonContract& memberContract, Object& memberValue);
    private void WriteObjectStart(JsonWriter writer, object value, JsonContract contract, JsonProperty member, JsonContainerContract collectionContract, JsonProperty containerProperty);
    private void WriteReferenceIdProperty(JsonWriter writer, Type type, object value);
    private void WriteTypeProperty(JsonWriter writer, Type type);
    private bool HasFlag(DefaultValueHandling value, DefaultValueHandling flag);
    private bool HasFlag(PreserveReferencesHandling value, PreserveReferencesHandling flag);
    private bool HasFlag(TypeNameHandling value, TypeNameHandling flag);
    private void SerializeConvertable(JsonWriter writer, JsonConverter converter, object value, JsonContract contract, JsonContainerContract collectionContract, JsonProperty containerProperty);
    private void SerializeList(JsonWriter writer, IEnumerable values, JsonArrayContract contract, JsonProperty member, JsonContainerContract collectionContract, JsonProperty containerProperty);
    private void SerializeMultidimensionalArray(JsonWriter writer, Array values, JsonArrayContract contract, JsonProperty member, JsonContainerContract collectionContract, JsonProperty containerProperty);
    private void SerializeMultidimensionalArray(JsonWriter writer, Array values, JsonArrayContract contract, JsonProperty member, int initialDepth, Int32[] indices);
    private bool WriteStartArray(JsonWriter writer, object values, JsonArrayContract contract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerProperty);
    private void SerializeISerializable(JsonWriter writer, ISerializable value, JsonISerializableContract contract, JsonProperty member, JsonContainerContract collectionContract, JsonProperty containerProperty);
    private bool ShouldWriteDynamicProperty(object memberValue);
    private bool ShouldWriteType(TypeNameHandling typeNameHandlingFlag, JsonContract contract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerProperty);
    private void SerializeDictionary(JsonWriter writer, IDictionary values, JsonDictionaryContract contract, JsonProperty member, JsonContainerContract collectionContract, JsonProperty containerProperty);
    private string GetPropertyName(JsonWriter writer, object name, JsonContract contract, Boolean& escape);
    private void HandleError(JsonWriter writer, int initialDepth);
    private bool ShouldSerialize(JsonWriter writer, JsonProperty property, object target);
    private bool IsSpecified(JsonWriter writer, JsonProperty property, object target);
}
[PreserveAttribute]
internal class Newtonsoft.Json.Serialization.JsonSerializerProxy : JsonSerializer {
    private JsonSerializerInternalReader _serializerReader;
    private JsonSerializerInternalWriter _serializerWriter;
    private JsonSerializer _serializer;
    public IReferenceResolver ReferenceResolver { get; public set; }
    public ITraceWriter TraceWriter { get; public set; }
    public IEqualityComparer EqualityComparer { get; public set; }
    public JsonConverterCollection Converters { get; }
    public DefaultValueHandling DefaultValueHandling { get; public set; }
    public IContractResolver ContractResolver { get; public set; }
    public MissingMemberHandling MissingMemberHandling { get; public set; }
    public NullValueHandling NullValueHandling { get; public set; }
    public ObjectCreationHandling ObjectCreationHandling { get; public set; }
    public ReferenceLoopHandling ReferenceLoopHandling { get; public set; }
    public PreserveReferencesHandling PreserveReferencesHandling { get; public set; }
    public TypeNameHandling TypeNameHandling { get; public set; }
    public MetadataPropertyHandling MetadataPropertyHandling { get; public set; }
    public FormatterAssemblyStyle TypeNameAssemblyFormat { get; public set; }
    public ConstructorHandling ConstructorHandling { get; public set; }
    public SerializationBinder Binder { get; public set; }
    public StreamingContext Context { get; public set; }
    public Formatting Formatting { get; public set; }
    public DateFormatHandling DateFormatHandling { get; public set; }
    public DateTimeZoneHandling DateTimeZoneHandling { get; public set; }
    public DateParseHandling DateParseHandling { get; public set; }
    public FloatFormatHandling FloatFormatHandling { get; public set; }
    public FloatParseHandling FloatParseHandling { get; public set; }
    public StringEscapeHandling StringEscapeHandling { get; public set; }
    public string DateFormatString { get; public set; }
    public CultureInfo Culture { get; public set; }
    public Nullable`1<int> MaxDepth { get; public set; }
    public bool CheckAdditionalContent { get; public set; }
    public JsonSerializerProxy(JsonSerializerInternalReader serializerReader);
    public JsonSerializerProxy(JsonSerializerInternalWriter serializerWriter);
    public virtual void add_Error(EventHandler`1<ErrorEventArgs> value);
    public virtual void remove_Error(EventHandler`1<ErrorEventArgs> value);
    public virtual IReferenceResolver get_ReferenceResolver();
    public virtual void set_ReferenceResolver(IReferenceResolver value);
    public virtual ITraceWriter get_TraceWriter();
    public virtual void set_TraceWriter(ITraceWriter value);
    public virtual IEqualityComparer get_EqualityComparer();
    public virtual void set_EqualityComparer(IEqualityComparer value);
    public virtual JsonConverterCollection get_Converters();
    public virtual DefaultValueHandling get_DefaultValueHandling();
    public virtual void set_DefaultValueHandling(DefaultValueHandling value);
    public virtual IContractResolver get_ContractResolver();
    public virtual void set_ContractResolver(IContractResolver value);
    public virtual MissingMemberHandling get_MissingMemberHandling();
    public virtual void set_MissingMemberHandling(MissingMemberHandling value);
    public virtual NullValueHandling get_NullValueHandling();
    public virtual void set_NullValueHandling(NullValueHandling value);
    public virtual ObjectCreationHandling get_ObjectCreationHandling();
    public virtual void set_ObjectCreationHandling(ObjectCreationHandling value);
    public virtual ReferenceLoopHandling get_ReferenceLoopHandling();
    public virtual void set_ReferenceLoopHandling(ReferenceLoopHandling value);
    public virtual PreserveReferencesHandling get_PreserveReferencesHandling();
    public virtual void set_PreserveReferencesHandling(PreserveReferencesHandling value);
    public virtual TypeNameHandling get_TypeNameHandling();
    public virtual void set_TypeNameHandling(TypeNameHandling value);
    public virtual MetadataPropertyHandling get_MetadataPropertyHandling();
    public virtual void set_MetadataPropertyHandling(MetadataPropertyHandling value);
    public virtual FormatterAssemblyStyle get_TypeNameAssemblyFormat();
    public virtual void set_TypeNameAssemblyFormat(FormatterAssemblyStyle value);
    public virtual ConstructorHandling get_ConstructorHandling();
    public virtual void set_ConstructorHandling(ConstructorHandling value);
    public virtual SerializationBinder get_Binder();
    public virtual void set_Binder(SerializationBinder value);
    public virtual StreamingContext get_Context();
    public virtual void set_Context(StreamingContext value);
    public virtual Formatting get_Formatting();
    public virtual void set_Formatting(Formatting value);
    public virtual DateFormatHandling get_DateFormatHandling();
    public virtual void set_DateFormatHandling(DateFormatHandling value);
    public virtual DateTimeZoneHandling get_DateTimeZoneHandling();
    public virtual void set_DateTimeZoneHandling(DateTimeZoneHandling value);
    public virtual DateParseHandling get_DateParseHandling();
    public virtual void set_DateParseHandling(DateParseHandling value);
    public virtual FloatFormatHandling get_FloatFormatHandling();
    public virtual void set_FloatFormatHandling(FloatFormatHandling value);
    public virtual FloatParseHandling get_FloatParseHandling();
    public virtual void set_FloatParseHandling(FloatParseHandling value);
    public virtual StringEscapeHandling get_StringEscapeHandling();
    public virtual void set_StringEscapeHandling(StringEscapeHandling value);
    public virtual string get_DateFormatString();
    public virtual void set_DateFormatString(string value);
    public virtual CultureInfo get_Culture();
    public virtual void set_Culture(CultureInfo value);
    public virtual Nullable`1<int> get_MaxDepth();
    public virtual void set_MaxDepth(Nullable`1<int> value);
    public virtual bool get_CheckAdditionalContent();
    public virtual void set_CheckAdditionalContent(bool value);
    internal JsonSerializerInternalBase GetInternalSerializer();
    internal virtual object DeserializeInternal(JsonReader reader, Type objectType);
    internal virtual void PopulateInternal(JsonReader reader, object target);
    internal virtual void SerializeInternal(JsonWriter jsonWriter, object value, Type rootType);
}
[PreserveAttribute]
public class Newtonsoft.Json.Serialization.JsonStringContract : JsonPrimitiveContract {
    public JsonStringContract(Type underlyingType);
}
[PreserveAttribute]
internal static class Newtonsoft.Json.Serialization.JsonTypeReflector : object {
    private static Nullable`1<bool> _dynamicCodeGeneration;
    private static Nullable`1<bool> _fullyTrusted;
    public static string IdPropertyName;
    public static string RefPropertyName;
    public static string TypePropertyName;
    public static string ValuePropertyName;
    public static string ArrayValuesPropertyName;
    public static string ShouldSerializePrefix;
    public static string SpecifiedPostfix;
    private static ThreadSafeStore`2<Type, Func`2<Object[], JsonConverter>> JsonConverterCreatorCache;
    private static ThreadSafeStore`2<Type, Type> AssociatedMetadataTypesCache;
    private static ReflectionObject _metadataTypeAttributeReflectionObject;
    public static bool DynamicCodeGeneration { get; }
    public static bool FullyTrusted { get; }
    public static ReflectionDelegateFactory ReflectionDelegateFactory { get; }
    private static JsonTypeReflector();
    public static T GetCachedAttribute(object attributeProvider);
    public static DataContractAttribute GetDataContractAttribute(Type type);
    public static DataMemberAttribute GetDataMemberAttribute(MemberInfo memberInfo);
    public static MemberSerialization GetObjectMemberSerialization(Type objectType, bool ignoreSerializableAttribute);
    public static JsonConverter GetJsonConverter(object attributeProvider);
    public static JsonConverter CreateJsonConverterInstance(Type converterType, Object[] converterArgs);
    private static Func`2<Object[], JsonConverter> GetJsonConverterCreator(Type converterType);
    public static TypeConverter GetTypeConverter(Type type);
    private static Type GetAssociatedMetadataType(Type type);
    private static Type GetAssociateMetadataTypeFromAttribute(Type type);
    private static T GetAttribute(Type type);
    private static T GetAttribute(MemberInfo memberInfo);
    public static T GetAttribute(object provider);
    public static bool get_DynamicCodeGeneration();
    public static bool get_FullyTrusted();
    public static ReflectionDelegateFactory get_ReflectionDelegateFactory();
}
[PreserveAttribute]
public class Newtonsoft.Json.Serialization.MemoryTraceWriter : object {
    private Queue`1<string> _traceMessages;
    [CompilerGeneratedAttribute]
private TraceLevel <LevelFilter>k__BackingField;
    public TraceLevel LevelFilter { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual TraceLevel get_LevelFilter();
    [CompilerGeneratedAttribute]
public void set_LevelFilter(TraceLevel value);
    public sealed virtual void Trace(TraceLevel level, string message, Exception ex);
    public IEnumerable`1<string> GetTraceMessages();
    public virtual string ToString();
}
[PreserveAttribute]
public class Newtonsoft.Json.Serialization.ObjectConstructor`1 : MulticastDelegate {
    public ObjectConstructor`1(object object, IntPtr method);
    public virtual object Invoke(Object[] args);
    public virtual IAsyncResult BeginInvoke(Object[] args, AsyncCallback callback, object object);
    public virtual object EndInvoke(IAsyncResult result);
}
[PreserveAttribute]
[AttributeUsageAttribute("64")]
public class Newtonsoft.Json.Serialization.OnErrorAttribute : Attribute {
}
[PreserveAttribute]
public class Newtonsoft.Json.Serialization.ReflectionAttributeProvider : object {
    private object _attributeProvider;
    public ReflectionAttributeProvider(object attributeProvider);
    public sealed virtual IList`1<Attribute> GetAttributes(bool inherit);
    public sealed virtual IList`1<Attribute> GetAttributes(Type attributeType, bool inherit);
}
[PreserveAttribute]
public class Newtonsoft.Json.Serialization.ReflectionValueProvider : object {
    private MemberInfo _memberInfo;
    public ReflectionValueProvider(MemberInfo memberInfo);
    public sealed virtual void SetValue(object target, object value);
    public sealed virtual object GetValue(object target);
}
[PreserveAttribute]
internal class Newtonsoft.Json.Serialization.ResolverContractKey : ValueType {
    private Type _resolverType;
    private Type _contractType;
    public ResolverContractKey(Type resolverType, Type contractType);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public bool Equals(ResolverContractKey other);
}
[PreserveAttribute]
public class Newtonsoft.Json.Serialization.SerializationCallback : MulticastDelegate {
    public SerializationCallback(object object, IntPtr method);
    public virtual void Invoke(object o, StreamingContext context);
    public virtual IAsyncResult BeginInvoke(object o, StreamingContext context, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[PreserveAttribute]
public class Newtonsoft.Json.Serialization.SerializationErrorCallback : MulticastDelegate {
    public SerializationErrorCallback(object object, IntPtr method);
    public virtual void Invoke(object o, StreamingContext context, ErrorContext errorContext);
    public virtual IAsyncResult BeginInvoke(object o, StreamingContext context, ErrorContext errorContext, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[PreserveAttribute]
internal class Newtonsoft.Json.Serialization.TraceJsonReader : JsonReader {
    private JsonReader _innerReader;
    private JsonTextWriter _textWriter;
    private StringWriter _sw;
    public int Depth { get; }
    public string Path { get; }
    public char QuoteChar { get; protected internal set; }
    public JsonToken TokenType { get; }
    public object Value { get; }
    public Type ValueType { get; }
    private int Newtonsoft.Json.IJsonLineInfo.LineNumber { get; }
    private int Newtonsoft.Json.IJsonLineInfo.LinePosition { get; }
    public TraceJsonReader(JsonReader innerReader);
    public string GetDeserializedJsonMessage();
    public virtual bool Read();
    public virtual Nullable`1<int> ReadAsInt32();
    public virtual string ReadAsString();
    public virtual Byte[] ReadAsBytes();
    public virtual Nullable`1<decimal> ReadAsDecimal();
    public virtual Nullable`1<double> ReadAsDouble();
    public virtual Nullable`1<bool> ReadAsBoolean();
    public virtual Nullable`1<DateTime> ReadAsDateTime();
    public virtual Nullable`1<DateTimeOffset> ReadAsDateTimeOffset();
    public virtual int get_Depth();
    public virtual string get_Path();
    public virtual char get_QuoteChar();
    protected internal virtual void set_QuoteChar(char value);
    public virtual JsonToken get_TokenType();
    public virtual object get_Value();
    public virtual Type get_ValueType();
    public virtual void Close();
    private sealed virtual override bool Newtonsoft.Json.IJsonLineInfo.HasLineInfo();
    private sealed virtual override int Newtonsoft.Json.IJsonLineInfo.get_LineNumber();
    private sealed virtual override int Newtonsoft.Json.IJsonLineInfo.get_LinePosition();
}
[PreserveAttribute]
internal class Newtonsoft.Json.Serialization.TraceJsonWriter : JsonWriter {
    private JsonWriter _innerWriter;
    private JsonTextWriter _textWriter;
    private StringWriter _sw;
    public TraceJsonWriter(JsonWriter innerWriter);
    public string GetSerializedJsonMessage();
    public virtual void WriteValue(decimal value);
    public virtual void WriteValue(bool value);
    public virtual void WriteValue(byte value);
    public virtual void WriteValue(Nullable`1<byte> value);
    public virtual void WriteValue(char value);
    public virtual void WriteValue(Byte[] value);
    public virtual void WriteValue(DateTime value);
    public virtual void WriteValue(DateTimeOffset value);
    public virtual void WriteValue(double value);
    public virtual void WriteUndefined();
    public virtual void WriteNull();
    public virtual void WriteValue(float value);
    public virtual void WriteValue(Guid value);
    public virtual void WriteValue(int value);
    public virtual void WriteValue(long value);
    public virtual void WriteValue(object value);
    public virtual void WriteValue(sbyte value);
    public virtual void WriteValue(short value);
    public virtual void WriteValue(string value);
    public virtual void WriteValue(TimeSpan value);
    public virtual void WriteValue(UInt32 value);
    public virtual void WriteValue(ulong value);
    public virtual void WriteValue(Uri value);
    public virtual void WriteValue(ushort value);
    public virtual void WriteWhitespace(string ws);
    public virtual void WriteComment(string text);
    public virtual void WriteStartArray();
    public virtual void WriteEndArray();
    public virtual void WriteStartConstructor(string name);
    public virtual void WriteEndConstructor();
    public virtual void WritePropertyName(string name);
    public virtual void WritePropertyName(string name, bool escape);
    public virtual void WriteStartObject();
    public virtual void WriteEndObject();
    public virtual void WriteRawValue(string json);
    public virtual void WriteRaw(string json);
    public virtual void Close();
    public virtual void Flush();
}
[PreserveAttribute]
public class Newtonsoft.Json.Shims.PreserveAttribute : Attribute {
}
[PreserveAttribute]
public enum Newtonsoft.Json.StringEscapeHandling : Enum {
    public int value__;
    public static StringEscapeHandling Default;
    public static StringEscapeHandling EscapeNonAscii;
    public static StringEscapeHandling EscapeHtml;
}
[FlagsAttribute]
[PreserveAttribute]
public enum Newtonsoft.Json.TypeNameHandling : Enum {
    public int value__;
    public static TypeNameHandling None;
    public static TypeNameHandling Objects;
    public static TypeNameHandling Arrays;
    public static TypeNameHandling All;
    public static TypeNameHandling Auto;
}
[PreserveAttribute]
internal class Newtonsoft.Json.Utilities.Base64Encoder : object {
    private static int Base64LineSize;
    private static int LineSizeInBytes;
    private Char[] _charsLine;
    private TextWriter _writer;
    private Byte[] _leftOverBytes;
    private int _leftOverBytesCount;
    public Base64Encoder(TextWriter writer);
    public void Encode(Byte[] buffer, int index, int count);
    public void Flush();
    private void WriteChars(Char[] chars, int index, int count);
}
[PreserveAttribute]
internal class Newtonsoft.Json.Utilities.BidirectionalDictionary`2 : object {
    private IDictionary`2<TFirst, TSecond> _firstToSecond;
    private IDictionary`2<TSecond, TFirst> _secondToFirst;
    private string _duplicateFirstErrorMessage;
    private string _duplicateSecondErrorMessage;
    public BidirectionalDictionary`2(IEqualityComparer`1<TFirst> firstEqualityComparer, IEqualityComparer`1<TSecond> secondEqualityComparer);
    public BidirectionalDictionary`2(IEqualityComparer`1<TFirst> firstEqualityComparer, IEqualityComparer`1<TSecond> secondEqualityComparer, string duplicateFirstErrorMessage, string duplicateSecondErrorMessage);
    public void Set(TFirst first, TSecond second);
    public bool TryGetByFirst(TFirst first, TSecond& second);
    public bool TryGetBySecond(TSecond second, TFirst& first);
}
[PreserveAttribute]
internal static class Newtonsoft.Json.Utilities.BufferUtils : object {
    public static Char[] RentBuffer(IArrayPool`1<char> bufferPool, int minSize);
    public static void ReturnBuffer(IArrayPool`1<char> bufferPool, Char[] buffer);
    public static Char[] EnsureBufferSize(IArrayPool`1<char> bufferPool, int size, Char[] buffer);
}
[PreserveAttribute]
[ExtensionAttribute]
internal static class Newtonsoft.Json.Utilities.CollectionUtils : object {
    public static bool IsNullOrEmpty(ICollection`1<T> collection);
    [ExtensionAttribute]
public static void AddRange(IList`1<T> initial, IEnumerable`1<T> collection);
    [ExtensionAttribute]
public static void AddRange(IList`1<T> initial, IEnumerable collection);
    public static bool IsDictionaryType(Type type);
    public static ConstructorInfo ResolveEnumerableCollectionConstructor(Type collectionType, Type collectionItemType);
    public static ConstructorInfo ResolveEnumerableCollectionConstructor(Type collectionType, Type collectionItemType, Type constructorArgumentType);
    [ExtensionAttribute]
public static bool AddDistinct(IList`1<T> list, T value);
    [ExtensionAttribute]
public static bool AddDistinct(IList`1<T> list, T value, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
public static bool ContainsValue(IEnumerable`1<TSource> source, TSource value, IEqualityComparer`1<TSource> comparer);
    [ExtensionAttribute]
public static bool AddRangeDistinct(IList`1<T> list, IEnumerable`1<T> values, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
public static int IndexOf(IEnumerable`1<T> collection, Func`2<T, bool> predicate);
    [ExtensionAttribute]
public static bool Contains(List`1<T> list, T value, IEqualityComparer comparer);
    [ExtensionAttribute]
public static int IndexOfReference(List`1<T> list, T item);
    private static IList`1<int> GetDimensions(IList values, int dimensionsCount);
    private static void CopyFromJaggedToMultidimensionalArray(IList values, Array multidimensionalArray, Int32[] indices);
    private static object JaggedArrayGetValue(IList values, Int32[] indices);
    public static Array ToMultidimensionalArray(IList values, Type type, int rank);
}
[PreserveAttribute]
internal class Newtonsoft.Json.Utilities.CollectionWrapper`1 : object {
    private IList _list;
    private ICollection`1<T> _genericCollection;
    private object _syncRoot;
    public int Count { get; }
    public bool IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private object System.Collections.IList.Item { get; private set; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public object UnderlyingCollection { get; }
    public CollectionWrapper`1(IList list);
    public CollectionWrapper`1(ICollection`1<T> list);
    public virtual void Add(T item);
    public virtual void Clear();
    public virtual bool Contains(T item);
    public virtual void CopyTo(T[] array, int arrayIndex);
    public virtual int get_Count();
    public virtual bool get_IsReadOnly();
    public virtual bool Remove(T item);
    public virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.RemoveAt(int index);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int arrayIndex);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private static void VerifyValueType(object value);
    private static bool IsCompatibleObject(object value);
    public sealed virtual object get_UnderlyingCollection();
}
[PreserveAttribute]
internal static class Newtonsoft.Json.Utilities.ConvertUtils : object {
    private static Dictionary`2<Type, PrimitiveTypeCode> TypeCodeMap;
    private static TypeInformation[] PrimitiveTypeCodes;
    private static ThreadSafeStore`2<TypeConvertKey, Func`2<object, object>> CastConverters;
    private static ConvertUtils();
    public static PrimitiveTypeCode GetTypeCode(Type t);
    public static PrimitiveTypeCode GetTypeCode(Type t, Boolean& isEnum);
    public static TypeInformation GetTypeInformation(IConvertible convertable);
    public static bool IsConvertible(Type t);
    public static TimeSpan ParseTimeSpan(string input);
    private static Func`2<object, object> CreateCastConverter(TypeConvertKey t);
    public static object Convert(object initialValue, CultureInfo culture, Type targetType);
    private static bool TryConvert(object initialValue, CultureInfo culture, Type targetType, Object& value);
    private static ConvertResult TryConvertInternal(object initialValue, CultureInfo culture, Type targetType, Object& value);
    public static object ConvertOrCast(object initialValue, CultureInfo culture, Type targetType);
    private static object EnsureTypeAssignable(object value, Type initialType, Type targetType);
    internal static TypeConverter GetConverter(Type t);
    public static bool VersionTryParse(string input, Version& result);
    public static bool IsInteger(object value);
    public static ParseResult Int32TryParse(Char[] chars, int start, int length, Int32& value);
    public static ParseResult Int64TryParse(Char[] chars, int start, int length, Int64& value);
    public static bool TryConvertGuid(string s, Guid& g);
    public static int HexTextToInt(Char[] text, int start, int end);
    private static int HexCharToInt(char ch);
}
[PreserveAttribute]
internal class Newtonsoft.Json.Utilities.Creator`1 : MulticastDelegate {
    public Creator`1(object object, IntPtr method);
    public virtual T Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual T EndInvoke(IAsyncResult result);
}
[PreserveAttribute]
internal class Newtonsoft.Json.Utilities.DateTimeParser : ValueType {
    public int Year;
    public int Month;
    public int Day;
    public int Hour;
    public int Minute;
    public int Second;
    public int Fraction;
    public int ZoneHour;
    public int ZoneMinute;
    public ParserTimeZone Zone;
    private Char[] _text;
    private int _end;
    private static Int32[] Power10;
    private static int Lzyyyy;
    private static int Lzyyyy_;
    private static int Lzyyyy_MM;
    private static int Lzyyyy_MM_;
    private static int Lzyyyy_MM_dd;
    private static int Lzyyyy_MM_ddT;
    private static int LzHH;
    private static int LzHH_;
    private static int LzHH_mm;
    private static int LzHH_mm_;
    private static int LzHH_mm_ss;
    private static int Lz_;
    private static int Lz_zz;
    private static short MaxFractionDigits;
    private static DateTimeParser();
    public bool Parse(Char[] text, int startIndex, int length);
    private bool ParseDate(int start);
    private bool ParseTimeAndZoneAndWhitespace(int start);
    private bool ParseTime(Int32& start);
    private bool ParseZone(int start);
    private bool Parse4Digit(int start, Int32& num);
    private bool Parse2Digit(int start, Int32& num);
    private bool ParseChar(int start, char ch);
}
[PreserveAttribute]
[ExtensionAttribute]
internal static class Newtonsoft.Json.Utilities.DateTimeUtils : object {
    internal static long InitialJavaScriptDateTicks;
    private static string IsoDateFormat;
    private static int DaysPer100Years;
    private static int DaysPer400Years;
    private static int DaysPer4Years;
    private static int DaysPerYear;
    private static long TicksPerDay;
    private static Int32[] DaysToMonth365;
    private static Int32[] DaysToMonth366;
    private static DateTimeUtils();
    [ExtensionAttribute]
public static TimeSpan GetUtcOffset(DateTime d);
    public static XmlDateTimeSerializationMode ToSerializationMode(DateTimeKind kind);
    internal static DateTime EnsureDateTime(DateTime value, DateTimeZoneHandling timeZone);
    private static DateTime SwitchToLocalTime(DateTime value);
    private static DateTime SwitchToUtcTime(DateTime value);
    private static long ToUniversalTicks(DateTime dateTime);
    private static long ToUniversalTicks(DateTime dateTime, TimeSpan offset);
    internal static long ConvertDateTimeToJavaScriptTicks(DateTime dateTime, TimeSpan offset);
    internal static long ConvertDateTimeToJavaScriptTicks(DateTime dateTime);
    internal static long ConvertDateTimeToJavaScriptTicks(DateTime dateTime, bool convertToUtc);
    private static long UniversialTicksToJavaScriptTicks(long universialTicks);
    internal static DateTime ConvertJavaScriptTicksToDateTime(long javaScriptTicks);
    internal static bool TryParseDateTimeIso(StringReference text, DateTimeZoneHandling dateTimeZoneHandling, DateTime& dt);
    internal static bool TryParseDateTimeOffsetIso(StringReference text, DateTimeOffset& dt);
    private static DateTime CreateDateTime(DateTimeParser dateTimeParser);
    internal static bool TryParseDateTime(StringReference s, DateTimeZoneHandling dateTimeZoneHandling, string dateFormatString, CultureInfo culture, DateTime& dt);
    internal static bool TryParseDateTime(string s, DateTimeZoneHandling dateTimeZoneHandling, string dateFormatString, CultureInfo culture, DateTime& dt);
    internal static bool TryParseDateTimeOffset(StringReference s, string dateFormatString, CultureInfo culture, DateTimeOffset& dt);
    internal static bool TryParseDateTimeOffset(string s, string dateFormatString, CultureInfo culture, DateTimeOffset& dt);
    private static bool TryParseMicrosoftDate(StringReference text, Int64& ticks, TimeSpan& offset, DateTimeKind& kind);
    private static bool TryParseDateTimeMicrosoft(StringReference text, DateTimeZoneHandling dateTimeZoneHandling, DateTime& dt);
    private static bool TryParseDateTimeExact(string text, DateTimeZoneHandling dateTimeZoneHandling, string dateFormatString, CultureInfo culture, DateTime& dt);
    private static bool TryParseDateTimeOffsetMicrosoft(StringReference text, DateTimeOffset& dt);
    private static bool TryParseDateTimeOffsetExact(string text, string dateFormatString, CultureInfo culture, DateTimeOffset& dt);
    private static bool TryReadOffset(StringReference offsetText, int startIndex, TimeSpan& offset);
    internal static void WriteDateTimeString(TextWriter writer, DateTime value, DateFormatHandling format, string formatString, CultureInfo culture);
    internal static int WriteDateTimeString(Char[] chars, int start, DateTime value, Nullable`1<TimeSpan> offset, DateTimeKind kind, DateFormatHandling format);
    internal static int WriteDefaultIsoDate(Char[] chars, int start, DateTime dt);
    private static void CopyIntToCharArray(Char[] chars, int start, int value, int digits);
    internal static int WriteDateTimeOffset(Char[] chars, int start, TimeSpan offset, DateFormatHandling format);
    internal static void WriteDateTimeOffsetString(TextWriter writer, DateTimeOffset value, DateFormatHandling format, string formatString, CultureInfo culture);
    private static void GetDateValues(DateTime td, Int32& year, Int32& month, Int32& day);
}
[PreserveAttribute]
[DefaultMemberAttribute("Item")]
internal class Newtonsoft.Json.Utilities.DictionaryWrapper`2 : object {
    private IDictionary _dictionary;
    private IDictionary`2<TKey, TValue> _genericDictionary;
    private object _syncRoot;
    public ICollection`1<TKey> Keys { get; }
    public ICollection`1<TValue> Values { get; }
    public TValue Item { get; public set; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    private object System.Collections.IDictionary.Item { get; private set; }
    private bool System.Collections.IDictionary.IsFixedSize { get; }
    private ICollection System.Collections.IDictionary.Keys { get; }
    private ICollection System.Collections.IDictionary.Values { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public object UnderlyingDictionary { get; }
    public DictionaryWrapper`2(IDictionary dictionary);
    public DictionaryWrapper`2(IDictionary`2<TKey, TValue> dictionary);
    public sealed virtual void Add(TKey key, TValue value);
    public sealed virtual bool ContainsKey(TKey key);
    public sealed virtual ICollection`1<TKey> get_Keys();
    public sealed virtual bool Remove(TKey key);
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    public sealed virtual ICollection`1<TValue> get_Values();
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual void set_Item(TKey key, TValue value);
    public sealed virtual void Add(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool Remove(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override void System.Collections.IDictionary.Add(object key, object value);
    private sealed virtual override object System.Collections.IDictionary.get_Item(object key);
    private sealed virtual override void System.Collections.IDictionary.set_Item(object key, object value);
    private sealed virtual override IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
    private sealed virtual override bool System.Collections.IDictionary.Contains(object key);
    private sealed virtual override bool System.Collections.IDictionary.get_IsFixedSize();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Keys();
    public sealed virtual void Remove(object key);
    private sealed virtual override ICollection System.Collections.IDictionary.get_Values();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    public sealed virtual object get_UnderlyingDictionary();
}
[PreserveAttribute]
internal static class Newtonsoft.Json.Utilities.EnumUtils : object {
    private static ThreadSafeStore`2<Type, BidirectionalDictionary`2<string, string>> EnumMemberNamesPerType;
    private static EnumUtils();
    private static BidirectionalDictionary`2<string, string> InitializeEnumType(Type type);
    public static IList`1<T> GetFlagsValues(T value);
    public static IList`1<EnumValue`1<ulong>> GetNamesAndValues();
    public static IList`1<EnumValue`1<TUnderlyingType>> GetNamesAndValues(Type enumType);
    public static IList`1<object> GetValues(Type enumType);
    public static IList`1<string> GetNames(Type enumType);
    public static object ParseEnumName(string enumText, bool isNullable, Type t);
    public static string ToEnumName(Type enumType, string enumText, bool camelCaseText);
    private static string ResolvedEnumName(BidirectionalDictionary`2<string, string> map, string enumText);
}
[PreserveAttribute]
internal class Newtonsoft.Json.Utilities.EnumValue`1 : object {
    private string _name;
    private T _value;
    public string Name { get; }
    public T Value { get; }
    public EnumValue`1(string name, T value);
    public string get_Name();
    public T get_Value();
}
[PreserveAttribute]
internal interface Newtonsoft.Json.Utilities.IWrappedCollection {
    public object UnderlyingCollection { get; }
    public abstract virtual object get_UnderlyingCollection();
}
[PreserveAttribute]
internal interface Newtonsoft.Json.Utilities.IWrappedDictionary {
    public object UnderlyingDictionary { get; }
    public abstract virtual object get_UnderlyingDictionary();
}
[PreserveAttribute]
internal static class Newtonsoft.Json.Utilities.JavaScriptUtils : object {
    internal static Boolean[] SingleQuoteCharEscapeFlags;
    internal static Boolean[] DoubleQuoteCharEscapeFlags;
    internal static Boolean[] HtmlCharEscapeFlags;
    private static int UnicodeTextLength;
    private static string EscapedUnicodeText;
    private static JavaScriptUtils();
    public static Boolean[] GetCharEscapeFlags(StringEscapeHandling stringEscapeHandling, char quoteChar);
    public static bool ShouldEscapeJavaScriptString(string s, Boolean[] charEscapeFlags);
    public static void WriteEscapedJavaScriptString(TextWriter writer, string s, char delimiter, bool appendDelimiters, Boolean[] charEscapeFlags, StringEscapeHandling stringEscapeHandling, IArrayPool`1<char> bufferPool, Char[]& writeBuffer);
    public static string ToEscapedJavaScriptString(string value, char delimiter, bool appendDelimiters, StringEscapeHandling stringEscapeHandling);
}
[PreserveAttribute]
internal static class Newtonsoft.Json.Utilities.JsonTokenUtils : object {
    internal static bool IsEndToken(JsonToken token);
    internal static bool IsStartToken(JsonToken token);
    internal static bool IsPrimitiveToken(JsonToken token);
}
[PreserveAttribute]
internal class Newtonsoft.Json.Utilities.LateBoundReflectionDelegateFactory : ReflectionDelegateFactory {
    private static LateBoundReflectionDelegateFactory _instance;
    internal static ReflectionDelegateFactory Instance { get; }
    private static LateBoundReflectionDelegateFactory();
    internal static ReflectionDelegateFactory get_Instance();
    public virtual ObjectConstructor`1<object> CreateParameterizedConstructor(MethodBase method);
    public virtual MethodCall`2<T, object> CreateMethodCall(MethodBase method);
    public virtual Func`1<T> CreateDefaultConstructor(Type type);
    public virtual Func`2<T, object> CreateGet(PropertyInfo propertyInfo);
    public virtual Func`2<T, object> CreateGet(FieldInfo fieldInfo);
    public virtual Action`2<T, object> CreateSet(FieldInfo fieldInfo);
    public virtual Action`2<T, object> CreateSet(PropertyInfo propertyInfo);
}
[PreserveAttribute]
internal static class Newtonsoft.Json.Utilities.MathUtils : object {
    public static int IntLength(ulong i);
    public static char IntToHex(int n);
    public static Nullable`1<int> Min(Nullable`1<int> val1, Nullable`1<int> val2);
    public static Nullable`1<int> Max(Nullable`1<int> val1, Nullable`1<int> val2);
    public static Nullable`1<double> Max(Nullable`1<double> val1, Nullable`1<double> val2);
    public static bool ApproxEquals(double d1, double d2);
}
[PreserveAttribute]
internal class Newtonsoft.Json.Utilities.MethodCall`2 : MulticastDelegate {
    public MethodCall`2(object object, IntPtr method);
    public virtual TResult Invoke(T target, Object[] args);
    public virtual IAsyncResult BeginInvoke(T target, Object[] args, AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
[PreserveAttribute]
internal static class Newtonsoft.Json.Utilities.MiscellaneousUtils : object {
    public static bool ValueEquals(object objA, object objB);
    public static ArgumentOutOfRangeException CreateArgumentOutOfRangeException(string paramName, object actualValue, string message);
    public static string ToString(object value);
    public static int ByteArrayCompare(Byte[] a1, Byte[] a2);
    public static string GetPrefix(string qualifiedName);
    public static string GetLocalName(string qualifiedName);
    public static void GetQualifiedNameParts(string qualifiedName, String& prefix, String& localName);
    internal static string FormatValueForPrint(object value);
}
[PreserveAttribute]
internal enum Newtonsoft.Json.Utilities.ParseResult : Enum {
    public int value__;
    public static ParseResult None;
    public static ParseResult Success;
    public static ParseResult Overflow;
    public static ParseResult Invalid;
}
[PreserveAttribute]
internal enum Newtonsoft.Json.Utilities.ParserTimeZone : Enum {
    public int value__;
    public static ParserTimeZone Unspecified;
    public static ParserTimeZone Utc;
    public static ParserTimeZone LocalWestOfUtc;
    public static ParserTimeZone LocalEastOfUtc;
}
[PreserveAttribute]
internal enum Newtonsoft.Json.Utilities.PrimitiveTypeCode : Enum {
    public int value__;
    public static PrimitiveTypeCode Empty;
    public static PrimitiveTypeCode Object;
    public static PrimitiveTypeCode Char;
    public static PrimitiveTypeCode CharNullable;
    public static PrimitiveTypeCode Boolean;
    public static PrimitiveTypeCode BooleanNullable;
    public static PrimitiveTypeCode SByte;
    public static PrimitiveTypeCode SByteNullable;
    public static PrimitiveTypeCode Int16;
    public static PrimitiveTypeCode Int16Nullable;
    public static PrimitiveTypeCode UInt16;
    public static PrimitiveTypeCode UInt16Nullable;
    public static PrimitiveTypeCode Int32;
    public static PrimitiveTypeCode Int32Nullable;
    public static PrimitiveTypeCode Byte;
    public static PrimitiveTypeCode ByteNullable;
    public static PrimitiveTypeCode UInt32;
    public static PrimitiveTypeCode UInt32Nullable;
    public static PrimitiveTypeCode Int64;
    public static PrimitiveTypeCode Int64Nullable;
    public static PrimitiveTypeCode UInt64;
    public static PrimitiveTypeCode UInt64Nullable;
    public static PrimitiveTypeCode Single;
    public static PrimitiveTypeCode SingleNullable;
    public static PrimitiveTypeCode Double;
    public static PrimitiveTypeCode DoubleNullable;
    public static PrimitiveTypeCode DateTime;
    public static PrimitiveTypeCode DateTimeNullable;
    public static PrimitiveTypeCode DateTimeOffset;
    public static PrimitiveTypeCode DateTimeOffsetNullable;
    public static PrimitiveTypeCode Decimal;
    public static PrimitiveTypeCode DecimalNullable;
    public static PrimitiveTypeCode Guid;
    public static PrimitiveTypeCode GuidNullable;
    public static PrimitiveTypeCode TimeSpan;
    public static PrimitiveTypeCode TimeSpanNullable;
    public static PrimitiveTypeCode BigInteger;
    public static PrimitiveTypeCode BigIntegerNullable;
    public static PrimitiveTypeCode Uri;
    public static PrimitiveTypeCode String;
    public static PrimitiveTypeCode Bytes;
    public static PrimitiveTypeCode DBNull;
}
[PreserveAttribute]
internal class Newtonsoft.Json.Utilities.PropertyNameTable : object {
    private static int HashCodeRandomizer;
    private int _count;
    private Entry[] _entries;
    private int _mask;
    private static PropertyNameTable();
    public string Get(Char[] key, int start, int length);
    public string Add(string key);
    private string AddEntry(string str, int hashCode);
    private void Grow();
    private static bool TextEquals(string str1, Char[] str2, int str2Start, int str2Length);
}
[PreserveAttribute]
internal abstract class Newtonsoft.Json.Utilities.ReflectionDelegateFactory : object {
    public Func`2<T, object> CreateGet(MemberInfo memberInfo);
    public Action`2<T, object> CreateSet(MemberInfo memberInfo);
    public abstract virtual MethodCall`2<T, object> CreateMethodCall(MethodBase method);
    public abstract virtual ObjectConstructor`1<object> CreateParameterizedConstructor(MethodBase method);
    public abstract virtual Func`1<T> CreateDefaultConstructor(Type type);
    public abstract virtual Func`2<T, object> CreateGet(PropertyInfo propertyInfo);
    public abstract virtual Func`2<T, object> CreateGet(FieldInfo fieldInfo);
    public abstract virtual Action`2<T, object> CreateSet(FieldInfo fieldInfo);
    public abstract virtual Action`2<T, object> CreateSet(PropertyInfo propertyInfo);
}
[PreserveAttribute]
internal class Newtonsoft.Json.Utilities.ReflectionMember : object {
    [CompilerGeneratedAttribute]
private Type <MemberType>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<object, object> <Getter>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`2<object, object> <Setter>k__BackingField;
    public Type MemberType { get; public set; }
    public Func`2<object, object> Getter { get; public set; }
    public Action`2<object, object> Setter { get; public set; }
    [CompilerGeneratedAttribute]
public Type get_MemberType();
    [CompilerGeneratedAttribute]
public void set_MemberType(Type value);
    [CompilerGeneratedAttribute]
public Func`2<object, object> get_Getter();
    [CompilerGeneratedAttribute]
public void set_Getter(Func`2<object, object> value);
    [CompilerGeneratedAttribute]
public Action`2<object, object> get_Setter();
    [CompilerGeneratedAttribute]
public void set_Setter(Action`2<object, object> value);
}
[PreserveAttribute]
internal class Newtonsoft.Json.Utilities.ReflectionObject : object {
    [CompilerGeneratedAttribute]
private ObjectConstructor`1<object> <Creator>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, ReflectionMember> <Members>k__BackingField;
    public ObjectConstructor`1<object> Creator { get; private set; }
    public IDictionary`2<string, ReflectionMember> Members { get; private set; }
    [CompilerGeneratedAttribute]
public ObjectConstructor`1<object> get_Creator();
    [CompilerGeneratedAttribute]
private void set_Creator(ObjectConstructor`1<object> value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, ReflectionMember> get_Members();
    [CompilerGeneratedAttribute]
private void set_Members(IDictionary`2<string, ReflectionMember> value);
    public object GetValue(object target, string member);
    public void SetValue(object target, string member, object value);
    public Type GetType(string member);
    public static ReflectionObject Create(Type t, String[] memberNames);
    public static ReflectionObject Create(Type t, MethodBase creator, String[] memberNames);
}
[PreserveAttribute]
[ExtensionAttribute]
internal static class Newtonsoft.Json.Utilities.ReflectionUtils : object {
    public static Type[] EmptyTypes;
    private static ReflectionUtils();
    [ExtensionAttribute]
public static bool IsVirtual(PropertyInfo propertyInfo);
    [ExtensionAttribute]
public static MethodInfo GetBaseDefinition(PropertyInfo propertyInfo);
    public static bool IsPublic(PropertyInfo property);
    public static Type GetObjectType(object v);
    public static string GetTypeName(Type t, FormatterAssemblyStyle assemblyFormat, SerializationBinder binder);
    private static string RemoveAssemblyDetails(string fullyQualifiedTypeName);
    public static bool HasDefaultConstructor(Type t, bool nonPublic);
    public static ConstructorInfo GetDefaultConstructor(Type t);
    public static ConstructorInfo GetDefaultConstructor(Type t, bool nonPublic);
    public static bool IsNullable(Type t);
    public static bool IsNullableType(Type t);
    public static Type EnsureNotNullableType(Type t);
    public static bool IsGenericDefinition(Type type, Type genericInterfaceDefinition);
    public static bool ImplementsGenericDefinition(Type type, Type genericInterfaceDefinition);
    public static bool ImplementsGenericDefinition(Type type, Type genericInterfaceDefinition, Type& implementingType);
    public static bool InheritsGenericDefinition(Type type, Type genericClassDefinition);
    public static bool InheritsGenericDefinition(Type type, Type genericClassDefinition, Type& implementingType);
    private static bool InheritsGenericDefinitionInternal(Type currentType, Type genericClassDefinition, Type& implementingType);
    public static Type GetCollectionItemType(Type type);
    public static void GetDictionaryKeyValueTypes(Type dictionaryType, Type& keyType, Type& valueType);
    public static Type GetMemberUnderlyingType(MemberInfo member);
    public static bool IsIndexedProperty(MemberInfo member);
    public static bool IsIndexedProperty(PropertyInfo property);
    public static object GetMemberValue(MemberInfo member, object target);
    public static void SetMemberValue(MemberInfo member, object target, object value);
    public static bool CanReadMemberValue(MemberInfo member, bool nonPublic);
    public static bool CanSetMemberValue(MemberInfo member, bool nonPublic, bool canSetReadOnly);
    public static List`1<MemberInfo> GetFieldsAndProperties(Type type, BindingFlags bindingAttr);
    private static bool IsOverridenGenericMember(MemberInfo memberInfo, BindingFlags bindingAttr);
    public static T GetAttribute(object attributeProvider);
    public static T GetAttribute(object attributeProvider, bool inherit);
    public static T[] GetAttributes(object attributeProvider, bool inherit);
    public static Attribute[] GetAttributes(object attributeProvider, Type attributeType, bool inherit);
    public static void SplitFullyQualifiedTypeName(string fullyQualifiedTypeName, String& typeName, String& assemblyName);
    private static Nullable`1<int> GetAssemblyDelimiterIndex(string fullyQualifiedTypeName);
    public static MemberInfo GetMemberInfoFromType(Type targetType, MemberInfo memberInfo);
    public static IEnumerable`1<FieldInfo> GetFields(Type targetType, BindingFlags bindingAttr);
    private static void GetChildPrivateFields(IList`1<MemberInfo> initialFields, Type targetType, BindingFlags bindingAttr);
    public static IEnumerable`1<PropertyInfo> GetProperties(Type targetType, BindingFlags bindingAttr);
    [ExtensionAttribute]
public static BindingFlags RemoveFlag(BindingFlags bindingAttr, BindingFlags flag);
    private static void GetChildPrivateProperties(IList`1<PropertyInfo> initialProperties, Type targetType, BindingFlags bindingAttr);
    public static bool IsMethodOverridden(Type currentType, Type methodDeclaringType, string method);
    public static object GetDefaultValue(Type type);
}
[PreserveAttribute]
internal class Newtonsoft.Json.Utilities.StringBuffer : ValueType {
    private Char[] _buffer;
    private int _position;
    public int Position { get; public set; }
    public bool IsEmpty { get; }
    public Char[] InternalBuffer { get; }
    public StringBuffer(IArrayPool`1<char> bufferPool, int initalSize);
    private StringBuffer(Char[] buffer);
    public int get_Position();
    public void set_Position(int value);
    public bool get_IsEmpty();
    public void Append(IArrayPool`1<char> bufferPool, char value);
    public void Append(IArrayPool`1<char> bufferPool, Char[] buffer, int startIndex, int count);
    public void Clear(IArrayPool`1<char> bufferPool);
    private void EnsureSize(IArrayPool`1<char> bufferPool, int appendLength);
    public virtual string ToString();
    public string ToString(int start, int length);
    public Char[] get_InternalBuffer();
}
[PreserveAttribute]
[DefaultMemberAttribute("Item")]
internal class Newtonsoft.Json.Utilities.StringReference : ValueType {
    private Char[] _chars;
    private int _startIndex;
    private int _length;
    public char Item { get; }
    public Char[] Chars { get; }
    public int StartIndex { get; }
    public int Length { get; }
    public StringReference(Char[] chars, int startIndex, int length);
    public char get_Item(int i);
    public Char[] get_Chars();
    public int get_StartIndex();
    public int get_Length();
    public virtual string ToString();
}
[ExtensionAttribute]
[PreserveAttribute]
internal static class Newtonsoft.Json.Utilities.StringReferenceExtensions : object {
    [ExtensionAttribute]
public static int IndexOf(StringReference s, char c, int startIndex, int length);
    [ExtensionAttribute]
public static bool StartsWith(StringReference s, string text);
    [ExtensionAttribute]
public static bool EndsWith(StringReference s, string text);
}
[PreserveAttribute]
[ExtensionAttribute]
internal static class Newtonsoft.Json.Utilities.StringUtils : object {
    public static string CarriageReturnLineFeed;
    public static string Empty;
    public static char CarriageReturn;
    public static char LineFeed;
    public static char Tab;
    [ExtensionAttribute]
public static string FormatWith(string format, IFormatProvider provider, object arg0);
    [ExtensionAttribute]
public static string FormatWith(string format, IFormatProvider provider, object arg0, object arg1);
    [ExtensionAttribute]
public static string FormatWith(string format, IFormatProvider provider, object arg0, object arg1, object arg2);
    [ExtensionAttribute]
public static string FormatWith(string format, IFormatProvider provider, object arg0, object arg1, object arg2, object arg3);
    [ExtensionAttribute]
private static string FormatWith(string format, IFormatProvider provider, Object[] args);
    public static bool IsWhiteSpace(string s);
    public static string NullEmptyString(string s);
    public static StringWriter CreateStringWriter(int capacity);
    public static Nullable`1<int> GetLength(string value);
    public static void ToCharAsUnicode(char c, Char[] buffer);
    [ExtensionAttribute]
public static TSource ForgivingCaseSensitiveFind(IEnumerable`1<TSource> source, Func`2<TSource, string> valueSelector, string testValue);
    public static string ToCamelCase(string s);
    public static bool IsHighSurrogate(char c);
    public static bool IsLowSurrogate(char c);
    [ExtensionAttribute]
public static bool StartsWith(string source, char value);
    [ExtensionAttribute]
public static bool EndsWith(string source, char value);
}
[PreserveAttribute]
internal class Newtonsoft.Json.Utilities.ThreadSafeStore`2 : object {
    private object _lock;
    private Dictionary`2<TKey, TValue> _store;
    private Func`2<TKey, TValue> _creator;
    [PreserveAttribute]
public ThreadSafeStore`2(Func`2<TKey, TValue> creator);
    [PreserveAttribute]
public TValue Get(TKey key);
    [PreserveAttribute]
private TValue AddValue(TKey key);
}
[PreserveAttribute]
[ExtensionAttribute]
internal static class Newtonsoft.Json.Utilities.TypeExtensions : object {
    [ExtensionAttribute]
public static MethodInfo Method(Delegate d);
    [ExtensionAttribute]
public static MemberTypes MemberType(MemberInfo memberInfo);
    [ExtensionAttribute]
public static bool ContainsGenericParameters(Type type);
    [ExtensionAttribute]
public static bool IsInterface(Type type);
    [ExtensionAttribute]
public static bool IsGenericType(Type type);
    [ExtensionAttribute]
public static bool IsGenericTypeDefinition(Type type);
    [ExtensionAttribute]
public static Type BaseType(Type type);
    [ExtensionAttribute]
public static Assembly Assembly(Type type);
    [ExtensionAttribute]
public static bool IsEnum(Type type);
    [ExtensionAttribute]
public static bool IsClass(Type type);
    [ExtensionAttribute]
public static bool IsSealed(Type type);
    [ExtensionAttribute]
public static bool IsAbstract(Type type);
    [ExtensionAttribute]
public static bool IsVisible(Type type);
    [ExtensionAttribute]
public static bool IsValueType(Type type);
    [ExtensionAttribute]
public static bool AssignableToTypeName(Type type, string fullTypeName, Type& match);
    [ExtensionAttribute]
public static bool AssignableToTypeName(Type type, string fullTypeName);
    [ExtensionAttribute]
public static bool ImplementInterface(Type type, Type interfaceType);
}
[PreserveAttribute]
internal class Newtonsoft.Json.Utilities.TypeInformation : object {
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private PrimitiveTypeCode <TypeCode>k__BackingField;
    public Type Type { get; public set; }
    public PrimitiveTypeCode TypeCode { get; public set; }
    [CompilerGeneratedAttribute]
public Type get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(Type value);
    [CompilerGeneratedAttribute]
public PrimitiveTypeCode get_TypeCode();
    [CompilerGeneratedAttribute]
public void set_TypeCode(PrimitiveTypeCode value);
}
[PreserveAttribute]
internal static class Newtonsoft.Json.Utilities.ValidationUtils : object {
    public static void ArgumentNotNull(object value, string parameterName);
}
[PreserveAttribute]
public enum Newtonsoft.Json.WriteState : Enum {
    public int value__;
    public static WriteState Error;
    public static WriteState Closed;
    public static WriteState Object;
    public static WriteState Array;
    public static WriteState Constructor;
    public static WriteState Property;
    public static WriteState Start;
}
public static class ProtoBuf.BclHelpers : object {
    private static int FieldTimeSpanValue;
    private static int FieldTimeSpanScale;
    private static int FieldDecimalLow;
    private static int FieldDecimalHigh;
    private static int FieldDecimalSignScale;
    private static int FieldGuidLow;
    private static int FieldGuidHigh;
    private static int FieldExistingObjectKey;
    private static int FieldNewObjectKey;
    private static int FieldExistingTypeKey;
    private static int FieldNewTypeKey;
    private static int FieldTypeName;
    private static int FieldObject;
    internal static DateTime EpochOrigin;
    private static BclHelpers();
    public static object GetUninitializedObject(Type type);
    public static void WriteTimeSpan(TimeSpan timeSpan, ProtoWriter dest);
    public static TimeSpan ReadTimeSpan(ProtoReader source);
    public static DateTime ReadDateTime(ProtoReader source);
    public static void WriteDateTime(DateTime value, ProtoWriter dest);
    private static long ReadTimeSpanTicks(ProtoReader source);
    public static decimal ReadDecimal(ProtoReader reader);
    public static void WriteDecimal(decimal value, ProtoWriter writer);
    public static void WriteGuid(Guid value, ProtoWriter dest);
    public static Guid ReadGuid(ProtoReader source);
    public static object ReadNetObject(object value, ProtoReader source, int key, Type type, NetObjectOptions options);
    public static void WriteNetObject(object value, ProtoWriter dest, int key, NetObjectOptions options);
}
public class ProtoBuf.BufferExtension : object {
    private Byte[] buffer;
    private sealed virtual override int ProtoBuf.IExtension.GetLength();
    private sealed virtual override Stream ProtoBuf.IExtension.BeginAppend();
    private sealed virtual override void ProtoBuf.IExtension.EndAppend(Stream stream, bool commit);
    private sealed virtual override Stream ProtoBuf.IExtension.BeginQuery();
    private sealed virtual override void ProtoBuf.IExtension.EndQuery(Stream stream);
}
internal class ProtoBuf.BufferPool : object {
    private static int PoolSize;
    internal static int BufferLength;
    private static Object[] pool;
    private static BufferPool();
    internal static void Flush();
    internal static Byte[] GetBuffer();
    internal static void ResizeAndFlushLeft(Byte[]& buffer, int toFitAtLeastBytes, int copyFromIndex, int copyBytes);
    internal static void ReleaseBufferToPool(Byte[]& buffer);
}
internal class ProtoBuf.Compiler.CodeLabel : ValueType {
    public Label Value;
    public int Index;
    public CodeLabel(Label value, int index);
}
internal class ProtoBuf.Compiler.CompilerContext : object {
    private DynamicMethod method;
    private static int next;
    private bool isStatic;
    private SerializerPair[] methodPairs;
    private bool isWriter;
    private bool nonPublic;
    private Local inputValue;
    private string assemblyName;
    private ILGenerator il;
    private MutableList locals;
    private int nextLabel;
    private BasicList knownTrustedAssemblies;
    private BasicList knownUntrustedAssemblies;
    private TypeModel model;
    private ILVersion metadataVersion;
    public TypeModel Model { get; }
    internal bool NonPublic { get; }
    public Local InputValue { get; }
    public ILVersion MetadataVersion { get; }
    internal CompilerContext(ILGenerator il, bool isStatic, bool isWriter, SerializerPair[] methodPairs, TypeModel model, ILVersion metadataVersion, string assemblyName, Type inputType);
    private CompilerContext(Type associatedType, bool isWriter, bool isStatic, TypeModel model, Type inputType);
    public TypeModel get_Model();
    internal CodeLabel DefineLabel();
    internal void MarkLabel(CodeLabel label);
    public static ProtoSerializer BuildSerializer(IProtoSerializer head, TypeModel model);
    public static ProtoDeserializer BuildDeserializer(IProtoSerializer head, TypeModel model);
    internal void Return();
    private static bool IsObject(Type type);
    internal void CastToObject(Type type);
    internal void CastFromObject(Type type);
    internal MethodBuilder GetDedicatedMethod(int metaKey, bool read);
    internal int MapMetaKeyToCompiledKey(int metaKey);
    internal bool get_NonPublic();
    public Local get_InputValue();
    private void Emit(OpCode opcode);
    public void LoadValue(string value);
    public void LoadValue(float value);
    public void LoadValue(double value);
    public void LoadValue(long value);
    public void LoadValue(int value);
    internal LocalBuilder GetFromPool(Type type);
    internal void ReleaseToPool(LocalBuilder value);
    public void LoadReaderWriter();
    public void StoreValue(Local local);
    public void LoadValue(Local local);
    public Local GetLocalWithValue(Type type, Local fromValue);
    internal void EmitBasicRead(string methodName, Type expectedType);
    internal void EmitBasicRead(Type helperType, string methodName, Type expectedType);
    internal void EmitBasicWrite(string methodName, Local fromValue);
    private MethodInfo GetWriterMethod(string methodName);
    internal void EmitWrite(Type helperType, string methodName, Local valueFrom);
    public void EmitCall(MethodInfo method);
    public void LoadNullRef();
    internal void WriteNullCheckedTail(Type type, IProtoSerializer tail, Local valueFrom);
    internal void ReadNullCheckedTail(Type type, IProtoSerializer tail, Local valueFrom);
    public void EmitCtor(Type type);
    public void EmitCtor(ConstructorInfo ctor);
    public void EmitCtor(Type type, Type[] parameterTypes);
    private bool InternalsVisible(Assembly assembly);
    internal void CheckAccessibility(MemberInfo member);
    public void LoadValue(FieldInfo field);
    public void StoreValue(FieldInfo field);
    public void LoadValue(PropertyInfo property);
    public void StoreValue(PropertyInfo property);
    internal static void LoadValue(ILGenerator il, int value);
    private bool UseShortForm(Local local);
    internal void LoadAddress(Local local, Type type);
    internal void Branch(CodeLabel label, bool short);
    internal void BranchIfFalse(CodeLabel label, bool short);
    internal void BranchIfTrue(CodeLabel label, bool short);
    internal void BranchIfEqual(CodeLabel label, bool short);
    internal void CopyValue();
    internal void BranchIfGreater(CodeLabel label, bool short);
    internal void BranchIfLess(CodeLabel label, bool short);
    internal void DiscardValue();
    public void Subtract();
    public void Switch(CodeLabel[] jumpTable);
    internal void EndFinally();
    internal void BeginFinally();
    internal void EndTry(CodeLabel label, bool short);
    internal CodeLabel BeginTry();
    internal void Constrain(Type type);
    internal void TryCast(Type type);
    internal void Cast(Type type);
    public IDisposable Using(Local local);
    internal void Add();
    internal void LoadLength(Local arr, bool zeroIfNull);
    internal void CreateArray(Type elementType, Local length);
    internal void LoadArrayValue(Local arr, Local i);
    internal void LoadValue(Type type);
    internal void ConvertToInt32(ProtoTypeCode typeCode, bool uint32Overflow);
    internal void ConvertFromInt32(ProtoTypeCode typeCode, bool uint32Overflow);
    internal void LoadValue(decimal value);
    internal void LoadValue(Guid value);
    internal void LoadSerializationContext();
    internal Type MapType(Type type);
    public ILVersion get_MetadataVersion();
    internal bool AllowInternal(PropertyInfo property);
}
internal class ProtoBuf.Compiler.Local : object {
    private LocalBuilder value;
    private CompilerContext ctx;
    private Type type;
    public Type Type { get; }
    internal LocalBuilder Value { get; }
    private Local(LocalBuilder value, Type type);
    internal Local(CompilerContext ctx, Type type);
    public Type get_Type();
    public Local AsCopy();
    internal LocalBuilder get_Value();
    public sealed virtual void Dispose();
    internal bool IsSame(Local other);
}
internal class ProtoBuf.Compiler.ProtoDeserializer : MulticastDelegate {
    public ProtoDeserializer(object object, IntPtr method);
    public virtual object Invoke(object value, ProtoReader source);
    public virtual IAsyncResult BeginInvoke(object value, ProtoReader source, AsyncCallback callback, object object);
    public virtual object EndInvoke(IAsyncResult result);
}
internal class ProtoBuf.Compiler.ProtoSerializer : MulticastDelegate {
    public ProtoSerializer(object object, IntPtr method);
    public virtual void Invoke(object value, ProtoWriter dest);
    public virtual IAsyncResult BeginInvoke(object value, ProtoWriter dest, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public enum ProtoBuf.DataFormat : Enum {
    public int value__;
    public static DataFormat Default;
    public static DataFormat ZigZag;
    public static DataFormat TwosComplement;
    public static DataFormat FixedSize;
    public static DataFormat Group;
}
public abstract class ProtoBuf.Extensible : object {
    private IExtension extensionObject;
    private sealed virtual override IExtension ProtoBuf.IExtensible.GetExtensionObject(bool createIfMissing);
    protected virtual IExtension GetExtensionObject(bool createIfMissing);
    public static IExtension GetExtensionObject(IExtension& extensionObject, bool createIfMissing);
    public static void AppendValue(IExtensible instance, int tag, TValue value);
    public static void AppendValue(IExtensible instance, int tag, DataFormat format, TValue value);
    public static TValue GetValue(IExtensible instance, int tag);
    public static TValue GetValue(IExtensible instance, int tag, DataFormat format);
    public static bool TryGetValue(IExtensible instance, int tag, TValue& value);
    public static bool TryGetValue(IExtensible instance, int tag, DataFormat format, TValue& value);
    public static bool TryGetValue(IExtensible instance, int tag, DataFormat format, bool allowDefinedTag, TValue& value);
    public static IEnumerable`1<TValue> GetValues(IExtensible instance, int tag);
    public static IEnumerable`1<TValue> GetValues(IExtensible instance, int tag, DataFormat format);
    public static bool TryGetValue(TypeModel model, Type type, IExtensible instance, int tag, DataFormat format, bool allowDefinedTag, Object& value);
    public static IEnumerable GetValues(TypeModel model, Type type, IExtensible instance, int tag, DataFormat format);
    public static void AppendValue(TypeModel model, IExtensible instance, int tag, DataFormat format, object value);
}
internal static class ProtoBuf.ExtensibleUtil : object {
    internal static IEnumerable`1<TValue> GetExtendedValues(IExtensible instance, int tag, DataFormat format, bool singleton, bool allowDefinedTag);
    internal static IEnumerable GetExtendedValues(TypeModel model, Type type, IExtensible instance, int tag, DataFormat format, bool singleton, bool allowDefinedTag);
    internal static void AppendExtendValue(TypeModel model, IExtensible instance, int tag, DataFormat format, object value);
}
internal class ProtoBuf.Helpers : object {
    public static Type[] EmptyTypes;
    private static Helpers();
    public static StringBuilder AppendLine(StringBuilder builder);
    public static bool IsNullOrEmpty(string value);
    [ConditionalAttribute("DEBUG")]
public static void DebugWriteLine(string message, object obj);
    [ConditionalAttribute("DEBUG")]
public static void DebugWriteLine(string message);
    [ConditionalAttribute("TRACE")]
public static void TraceWriteLine(string message);
    [ConditionalAttribute("DEBUG")]
public static void DebugAssert(bool condition, string message);
    [ConditionalAttribute("DEBUG")]
public static void DebugAssert(bool condition, string message, Object[] args);
    [ConditionalAttribute("DEBUG")]
public static void DebugAssert(bool condition);
    public static void Sort(Int32[] keys, Object[] values);
    public static void BlockCopy(Byte[] from, int fromIndex, Byte[] to, int toIndex, int count);
    public static bool IsInfinity(float value);
    internal static MethodInfo GetInstanceMethod(Type declaringType, string name);
    internal static MethodInfo GetStaticMethod(Type declaringType, string name);
    internal static MethodInfo GetInstanceMethod(Type declaringType, string name, Type[] types);
    internal static bool IsSubclassOf(Type type, Type baseClass);
    public static bool IsInfinity(double value);
    public static ProtoTypeCode GetTypeCode(Type type);
    internal static Type GetUnderlyingType(Type type);
    internal static bool IsValueType(Type type);
    internal static bool IsEnum(Type type);
    internal static MethodInfo GetGetMethod(PropertyInfo property, bool nonPublic, bool allowInternal);
    internal static MethodInfo GetSetMethod(PropertyInfo property, bool nonPublic, bool allowInternal);
    internal static ConstructorInfo GetConstructor(Type type, Type[] parameterTypes, bool nonPublic);
    internal static ConstructorInfo[] GetConstructors(Type type, bool nonPublic);
    internal static PropertyInfo GetProperty(Type type, string name, bool nonPublic);
    internal static object ParseEnum(Type type, string value);
    internal static MemberInfo[] GetInstanceFieldsAndProperties(Type type, bool publicOnly);
    internal static Type GetMemberType(MemberInfo member);
    internal static bool IsAssignableFrom(Type target, Type type);
}
public interface ProtoBuf.IExtensible {
    public abstract virtual IExtension GetExtensionObject(bool createIfMissing);
}
public interface ProtoBuf.IExtension {
    public abstract virtual Stream BeginAppend();
    public abstract virtual void EndAppend(Stream stream, bool commit);
    public abstract virtual Stream BeginQuery();
    public abstract virtual void EndQuery(Stream stream);
    public abstract virtual int GetLength();
}
public enum ProtoBuf.ImplicitFields : Enum {
    public int value__;
    public static ImplicitFields None;
    public static ImplicitFields AllPublic;
    public static ImplicitFields AllFields;
}
[FlagsAttribute]
public enum ProtoBuf.MemberSerializationOptions : Enum {
    public int value__;
    public static MemberSerializationOptions None;
    public static MemberSerializationOptions Packed;
    public static MemberSerializationOptions Required;
    public static MemberSerializationOptions AsReference;
    public static MemberSerializationOptions DynamicType;
    public static MemberSerializationOptions OverwriteList;
    public static MemberSerializationOptions AsReferenceHasValue;
}
internal abstract class ProtoBuf.Meta.AttributeMap : object {
    public Type AttributeType { get; }
    public object Target { get; }
    public abstract virtual bool TryGet(string key, bool publicOnly, Object& value);
    public bool TryGet(string key, Object& value);
    public abstract virtual Type get_AttributeType();
    public static AttributeMap[] Create(TypeModel model, Type type, bool inherit);
    public static AttributeMap[] Create(TypeModel model, MemberInfo member, bool inherit);
    public static AttributeMap[] Create(TypeModel model, Assembly assembly);
    public abstract virtual object get_Target();
}
[DefaultMemberAttribute("Item")]
internal class ProtoBuf.Meta.BasicList : object {
    private static Node nil;
    protected Node head;
    public object Item { get; }
    public int Count { get; }
    private static BasicList();
    public void CopyTo(Array array, int offset);
    public int Add(object value);
    public object get_Item(int index);
    public void Trim();
    public int get_Count();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public NodeEnumerator GetEnumerator();
    internal int IndexOf(MatchPredicate predicate, object ctx);
    internal int IndexOfString(string value);
    internal int IndexOfReference(object instance);
    internal bool Contains(object value);
    internal static BasicList GetContiguousGroups(Int32[] keys, Object[] values);
}
[DefaultMemberAttribute("Item")]
public class ProtoBuf.Meta.CallbackSet : object {
    private MetaType metaType;
    private MethodInfo beforeSerialize;
    private MethodInfo afterSerialize;
    private MethodInfo beforeDeserialize;
    private MethodInfo afterDeserialize;
    internal MethodInfo Item { get; }
    public MethodInfo BeforeSerialize { get; public set; }
    public MethodInfo BeforeDeserialize { get; public set; }
    public MethodInfo AfterSerialize { get; public set; }
    public MethodInfo AfterDeserialize { get; public set; }
    public bool NonTrivial { get; }
    internal CallbackSet(MetaType metaType);
    internal MethodInfo get_Item(CallbackType callbackType);
    internal static bool CheckCallbackParameters(TypeModel model, MethodInfo method);
    private MethodInfo SanityCheckCallback(TypeModel model, MethodInfo callback);
    internal static Exception CreateInvalidCallbackSignature(MethodInfo method);
    public MethodInfo get_BeforeSerialize();
    public void set_BeforeSerialize(MethodInfo value);
    public MethodInfo get_BeforeDeserialize();
    public void set_BeforeDeserialize(MethodInfo value);
    public MethodInfo get_AfterSerialize();
    public void set_AfterSerialize(MethodInfo value);
    public MethodInfo get_AfterDeserialize();
    public void set_AfterDeserialize(MethodInfo value);
    public bool get_NonTrivial();
}
public class ProtoBuf.Meta.LockContentedEventArgs : EventArgs {
    private string ownerStackTrace;
    public string OwnerStackTrace { get; }
    internal LockContentedEventArgs(string ownerStackTrace);
    public string get_OwnerStackTrace();
}
public class ProtoBuf.Meta.LockContentedEventHandler : MulticastDelegate {
    public LockContentedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, LockContentedEventArgs args);
    public virtual IAsyncResult BeginInvoke(object sender, LockContentedEventArgs args, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[DefaultMemberAttribute("Item")]
public class ProtoBuf.Meta.MetaType : object {
    private static byte OPTIONS_Pending;
    private static byte OPTIONS_EnumPassThru;
    private static byte OPTIONS_Frozen;
    private static byte OPTIONS_PrivateOnApi;
    private static byte OPTIONS_SkipConstructor;
    private static byte OPTIONS_AsReferenceDefault;
    private static byte OPTIONS_AutoTuple;
    private static byte OPTIONS_IgnoreListHandling;
    private MetaType baseType;
    private BasicList subTypes;
    internal static Type ienumerable;
    private CallbackSet callbacks;
    private string name;
    private MethodInfo factory;
    private RuntimeTypeModel model;
    private Type type;
    private IProtoTypeSerializer serializer;
    private Type constructType;
    private Type surrogate;
    private BasicList fields;
    private Byte modreq(System.Runtime.CompilerServices.IsVolatile) flags;
    private IProtoSerializer ProtoBuf.Serializers.ISerializerProxy.Serializer { get; }
    public MetaType BaseType { get; }
    internal TypeModel Model { get; }
    public bool IncludeSerializerMethod { get; public set; }
    public bool AsReferenceDefault { get; public set; }
    public bool HasCallbacks { get; }
    public bool HasSubtypes { get; }
    public CallbackSet Callbacks { get; }
    private bool IsValueType { get; }
    public string Name { get; public set; }
    public Type Type { get; }
    internal IProtoTypeSerializer Serializer { get; }
    internal bool IsList { get; }
    public bool UseConstructor { get; public set; }
    public Type ConstructType { get; public set; }
    public ValueMember Item { get; }
    public ValueMember Item { get; }
    public bool EnumPassthru { get; public set; }
    public bool IgnoreListHandling { get; public set; }
    internal bool Pending { get; internal set; }
    internal IEnumerable Fields { get; }
    internal bool IsAutoTuple { get; }
    internal MetaType(RuntimeTypeModel model, Type type, MethodInfo factory);
    private static MetaType();
    public virtual string ToString();
    private sealed virtual override IProtoSerializer ProtoBuf.Serializers.ISerializerProxy.get_Serializer();
    public MetaType get_BaseType();
    internal TypeModel get_Model();
    public bool get_IncludeSerializerMethod();
    public void set_IncludeSerializerMethod(bool value);
    public bool get_AsReferenceDefault();
    public void set_AsReferenceDefault(bool value);
    private bool IsValidSubType(Type subType);
    public MetaType AddSubType(int fieldNumber, Type derivedType);
    public MetaType AddSubType(int fieldNumber, Type derivedType, DataFormat dataFormat);
    private void SetBaseType(MetaType baseType);
    public bool get_HasCallbacks();
    public bool get_HasSubtypes();
    public CallbackSet get_Callbacks();
    private bool get_IsValueType();
    public MetaType SetCallbacks(MethodInfo beforeSerialize, MethodInfo afterSerialize, MethodInfo beforeDeserialize, MethodInfo afterDeserialize);
    public MetaType SetCallbacks(string beforeSerialize, string afterSerialize, string beforeDeserialize, string afterDeserialize);
    internal string GetSchemaTypeName();
    public string get_Name();
    public void set_Name(string value);
    public MetaType SetFactory(MethodInfo factory);
    public MetaType SetFactory(string factory);
    private MethodInfo ResolveMethod(string name, bool instance);
    internal static Exception InbuiltType(Type type);
    protected internal void ThrowIfFrozen();
    public Type get_Type();
    internal IProtoTypeSerializer get_Serializer();
    internal bool get_IsList();
    private IProtoTypeSerializer BuildSerializer();
    private static Type GetBaseType(MetaType type);
    internal static bool GetAsReferenceDefault(RuntimeTypeModel model, Type type);
    internal void ApplyDefaultBehaviour();
    private static void ApplyDefaultBehaviour_AddMembers(TypeModel model, AttributeFamily family, bool isEnum, BasicList partialMembers, int dataMemberOffset, bool inferTagByName, ImplicitFields implicitMode, BasicList members, MemberInfo member, Boolean& forced, bool isPublic, bool isField, Type& effectiveType);
    private static MethodInfo Coalesce(MethodInfo[] arr, int x, int y);
    internal static AttributeFamily GetContractFamily(RuntimeTypeModel model, Type type, AttributeMap[] attributes);
    internal static ConstructorInfo ResolveTupleConstructor(Type type, MemberInfo[]& mappedMembers);
    private static void CheckForCallback(MethodInfo method, AttributeMap[] attributes, string callbackTypeName, MethodInfo[]& callbacks, int index);
    private static bool HasFamily(AttributeFamily value, AttributeFamily required);
    private static ProtoMemberAttribute NormalizeProtoMember(TypeModel model, MemberInfo member, AttributeFamily family, bool forced, bool isEnum, BasicList partialMembers, int dataMemberOffset, bool inferByTagName);
    private ValueMember ApplyDefaultBehaviour(bool isEnum, ProtoMemberAttribute normalizedAttribute);
    private static void GetDataFormat(DataFormat& value, AttributeMap attrib, string memberName);
    private static void GetIgnore(Boolean& ignore, AttributeMap attrib, AttributeMap[] attribs, string fullName);
    private static void GetFieldBoolean(Boolean& value, AttributeMap attrib, string memberName);
    private static bool GetFieldBoolean(Boolean& value, AttributeMap attrib, string memberName, bool publicOnly);
    private static void GetFieldNumber(Int32& value, AttributeMap attrib, string memberName);
    private static void GetFieldName(String& name, AttributeMap attrib, string memberName);
    private static AttributeMap GetAttribute(AttributeMap[] attribs, string fullName);
    public MetaType Add(int fieldNumber, string memberName);
    public ValueMember AddField(int fieldNumber, string memberName);
    public bool get_UseConstructor();
    public void set_UseConstructor(bool value);
    public Type get_ConstructType();
    public void set_ConstructType(Type value);
    public MetaType Add(string memberName);
    public void SetSurrogate(Type surrogateType);
    internal MetaType GetSurrogateOrSelf();
    internal MetaType GetSurrogateOrBaseOrSelf(bool deep);
    private int GetNextFieldNumber();
    public MetaType Add(String[] memberNames);
    public MetaType Add(int fieldNumber, string memberName, object defaultValue);
    public MetaType Add(int fieldNumber, string memberName, Type itemType, Type defaultType);
    public ValueMember AddField(int fieldNumber, string memberName, Type itemType, Type defaultType);
    private ValueMember AddField(int fieldNumber, string memberName, Type itemType, Type defaultType, object defaultValue);
    internal static void ResolveListTypes(TypeModel model, Type type, Type& itemType, Type& defaultType);
    private void Add(ValueMember member);
    public ValueMember get_Item(int fieldNumber);
    public ValueMember get_Item(MemberInfo member);
    public ValueMember[] GetFields();
    public SubType[] GetSubtypes();
    public void CompileInPlace();
    internal bool IsDefined(int fieldNumber);
    internal int GetKey(bool demand, bool getBaseKey);
    internal EnumPair[] GetEnumMap();
    public bool get_EnumPassthru();
    public void set_EnumPassthru(bool value);
    public bool get_IgnoreListHandling();
    public void set_IgnoreListHandling(bool value);
    internal bool get_Pending();
    internal void set_Pending(bool value);
    private bool HasFlag(byte flag);
    private void SetFlag(byte flag, bool value, bool throwIfFrozen);
    internal static MetaType GetRootType(MetaType source);
    internal bool IsPrepared();
    internal IEnumerable get_Fields();
    internal static StringBuilder NewLine(StringBuilder builder, int indent);
    internal bool get_IsAutoTuple();
    internal void WriteSchema(StringBuilder builder, int indent, Boolean& requiresBclImport);
}
[DefaultMemberAttribute("Item")]
internal class ProtoBuf.Meta.MutableList : BasicList {
    public object Item { get; public set; }
    public object get_Item(int index);
    public void set_Item(int index, object value);
    public void RemoveLast();
    public void Clear();
}
[DefaultMemberAttribute("Item")]
public class ProtoBuf.Meta.RuntimeTypeModel : TypeModel {
    private static byte OPTIONS_InferTagFromNameDefault;
    private static byte OPTIONS_IsDefaultModel;
    private static byte OPTIONS_Frozen;
    private static byte OPTIONS_AutoAddMissingTypes;
    private static byte OPTIONS_AutoCompile;
    private static byte OPTIONS_UseImplicitZeroDefaults;
    private static byte OPTIONS_AllowParseableTypes;
    private static byte OPTIONS_AutoAddProtoContractTypesOnly;
    private static int KnownTypes_Array;
    private static int KnownTypes_Dictionary;
    private static int KnownTypes_Hashtable;
    private static int KnownTypes_ArrayCutoff;
    private byte options;
    private static MatchPredicate MetaTypeFinder;
    private static MatchPredicate BasicTypeFinder;
    private BasicList basicTypes;
    private BasicList types;
    private int metadataTimeoutMilliseconds;
    private int contentionCounter;
    private object contentionLock;
    private LockContentedEventHandler LockContended;
    private MethodInfo defaultFactory;
    public bool InferTagFromNameDefault { get; public set; }
    public bool AutoAddProtoContractTypesOnly { get; public set; }
    public bool UseImplicitZeroDefaults { get; public set; }
    public bool AllowParseableTypes { get; public set; }
    public static RuntimeTypeModel Default { get; }
    public MetaType Item { get; }
    public bool AutoCompile { get; public set; }
    public bool AutoAddMissingTypes { get; public set; }
    public int MetadataTimeoutMilliseconds { get; public set; }
    internal RuntimeTypeModel(bool isDefault);
    private static RuntimeTypeModel();
    private bool GetOption(byte option);
    private void SetOption(byte option, bool value);
    public bool get_InferTagFromNameDefault();
    public void set_InferTagFromNameDefault(bool value);
    public bool get_AutoAddProtoContractTypesOnly();
    public void set_AutoAddProtoContractTypesOnly(bool value);
    public bool get_UseImplicitZeroDefaults();
    public void set_UseImplicitZeroDefaults(bool value);
    public bool get_AllowParseableTypes();
    public void set_AllowParseableTypes(bool value);
    public static RuntimeTypeModel get_Default();
    public IEnumerable GetTypes();
    public virtual string GetSchema(Type type);
    private void CascadeDependents(BasicList list, MetaType metaType);
    public MetaType get_Item(Type type);
    internal MetaType FindWithoutAdd(Type type);
    private static bool MetaTypeFinderImpl(object value, object ctx);
    private static bool BasicTypeFinderImpl(object value, object ctx);
    private void WaitOnLock(MetaType type);
    internal IProtoSerializer TryGetBasicTypeSerializer(Type type);
    internal int FindOrAddAuto(Type type, bool demand, bool addWithContractOnly, bool addEvenIfAutoDisabled);
    private MetaType RecogniseCommonTypes(Type type);
    private MetaType Create(Type type);
    public MetaType Add(Type type, bool applyDefaultBehaviour);
    public bool get_AutoCompile();
    public void set_AutoCompile(bool value);
    public bool get_AutoAddMissingTypes();
    public void set_AutoAddMissingTypes(bool value);
    private void ThrowIfFrozen();
    public void Freeze();
    protected virtual int GetKeyImpl(Type type);
    internal int GetKey(Type type, bool demand, bool getBaseKey);
    protected internal virtual void Serialize(int key, object value, ProtoWriter dest);
    protected internal virtual object Deserialize(int key, object value, ProtoReader source);
    internal ProtoSerializer GetSerializer(IProtoSerializer serializer, bool compiled);
    public void CompileInPlace();
    private void BuildAllSerializers();
    public TypeModel Compile();
    private static ILGenerator Override(TypeBuilder type, string name);
    public TypeModel Compile(string name, string path);
    public TypeModel Compile(CompilerOptions options);
    private void WriteConstructors(TypeBuilder type, Int32& index, SerializerPair[] methodPairs, ILGenerator& il, int knownTypesCategory, FieldBuilder knownTypes, Type knownTypesLookupType, CompilerContext ctx);
    private CompilerContext WriteSerializeDeserialize(string assemblyName, TypeBuilder type, SerializerPair[] methodPairs, ILVersion ilVersion, ILGenerator& il);
    private void WriteGetKeyImpl(TypeBuilder type, bool hasInheritance, SerializerPair[] methodPairs, ILVersion ilVersion, string assemblyName, ILGenerator& il, Int32& knownTypesCategory, FieldBuilder& knownTypes, Type& knownTypesLookupType);
    private void WriteSerializers(CompilerOptions options, string assemblyName, TypeBuilder type, Int32& index, Boolean& hasInheritance, SerializerPair[]& methodPairs, ILVersion& ilVersion);
    private TypeBuilder WriteBasicTypeModel(CompilerOptions options, string typeName, ModuleBuilder module);
    private void WriteAssemblyAttributes(CompilerOptions options, string assemblyName, AssemblyBuilder asm);
    private static MethodBuilder EmitBoxedSerializer(TypeBuilder type, int i, Type valueType, SerializerPair[] methodPairs, TypeModel model, ILVersion ilVersion, string assemblyName);
    internal bool IsPrepared(Type type);
    internal EnumPair[] GetEnumMap(Type type);
    public int get_MetadataTimeoutMilliseconds();
    public void set_MetadataTimeoutMilliseconds(int value);
    internal void TakeLock(Int32& opaqueToken);
    private int GetContention();
    private void AddContention();
    internal void ReleaseLock(int opaqueToken);
    public void add_LockContended(LockContentedEventHandler value);
    public void remove_LockContended(LockContentedEventHandler value);
    internal void ResolveListTypes(Type type, Type& itemType, Type& defaultType);
    internal string GetSchemaTypeName(Type effectiveType, DataFormat dataFormat, bool asReference, bool dynamicType, Boolean& requiresBclImport);
    public void SetDefaultFactory(MethodInfo methodInfo);
    internal void VerifyFactory(MethodInfo factory, Type type);
}
public class ProtoBuf.Meta.SubType : object {
    private int fieldNumber;
    private MetaType derivedType;
    private DataFormat dataFormat;
    private IProtoSerializer serializer;
    public int FieldNumber { get; }
    public MetaType DerivedType { get; }
    internal IProtoSerializer Serializer { get; }
    public SubType(int fieldNumber, MetaType derivedType, DataFormat format);
    public int get_FieldNumber();
    public MetaType get_DerivedType();
    internal IProtoSerializer get_Serializer();
    private IProtoSerializer BuildSerializer();
}
public class ProtoBuf.Meta.TypeFormatEventArgs : EventArgs {
    private Type type;
    private string formattedName;
    private bool typeFixed;
    public Type Type { get; public set; }
    public string FormattedName { get; public set; }
    internal TypeFormatEventArgs(string formattedName);
    internal TypeFormatEventArgs(Type type);
    public Type get_Type();
    public void set_Type(Type value);
    public string get_FormattedName();
    public void set_FormattedName(string value);
}
public class ProtoBuf.Meta.TypeFormatEventHandler : MulticastDelegate {
    public TypeFormatEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, TypeFormatEventArgs args);
    public virtual IAsyncResult BeginInvoke(object sender, TypeFormatEventArgs args, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public abstract class ProtoBuf.Meta.TypeModel : object {
    private static Type ilist;
    private TypeFormatEventHandler DynamicTypeFormatting;
    private static TypeModel();
    protected internal Type MapType(Type type);
    protected internal virtual Type MapType(Type type, bool demand);
    private WireType GetWireType(ProtoTypeCode code, DataFormat format, Type& type, Int32& modelKey);
    internal bool TrySerializeAuxiliaryType(ProtoWriter writer, Type type, DataFormat format, int tag, object value, bool isInsideList);
    private void SerializeCore(ProtoWriter writer, object value);
    public void Serialize(Stream dest, object value);
    public void Serialize(Stream dest, object value, SerializationContext context);
    public void Serialize(ProtoWriter dest, object value);
    public object DeserializeWithLengthPrefix(Stream source, object value, Type type, PrefixStyle style, int fieldNumber);
    public object DeserializeWithLengthPrefix(Stream source, object value, Type type, PrefixStyle style, int expectedField, TypeResolver resolver);
    public object DeserializeWithLengthPrefix(Stream source, object value, Type type, PrefixStyle style, int expectedField, TypeResolver resolver, Int32& bytesRead);
    private object DeserializeWithLengthPrefix(Stream source, object value, Type type, PrefixStyle style, int expectedField, TypeResolver resolver, Int32& bytesRead, Boolean& haveObject, SerializationContext context);
    public IEnumerable DeserializeItems(Stream source, Type type, PrefixStyle style, int expectedField, TypeResolver resolver);
    public IEnumerable DeserializeItems(Stream source, Type type, PrefixStyle style, int expectedField, TypeResolver resolver, SerializationContext context);
    public IEnumerable`1<T> DeserializeItems(Stream source, PrefixStyle style, int expectedField);
    public IEnumerable`1<T> DeserializeItems(Stream source, PrefixStyle style, int expectedField, SerializationContext context);
    public void SerializeWithLengthPrefix(Stream dest, object value, Type type, PrefixStyle style, int fieldNumber);
    public void SerializeWithLengthPrefix(Stream dest, object value, Type type, PrefixStyle style, int fieldNumber, SerializationContext context);
    public object Deserialize(Stream source, object value, Type type);
    public object Deserialize(Stream source, object value, Type type, SerializationContext context);
    private bool PrepareDeserialize(object value, Type& type);
    public object Deserialize(Stream source, object value, Type type, int length);
    public object Deserialize(Stream source, object value, Type type, int length, SerializationContext context);
    public object Deserialize(ProtoReader source, object value, Type type);
    private object DeserializeCore(ProtoReader reader, Type type, object value, bool noAutoCreate);
    internal static MethodInfo ResolveListAdd(TypeModel model, Type listType, Type itemType, Boolean& isList);
    internal static Type GetListItemType(TypeModel model, Type listType);
    private static void TestEnumerableListPatterns(TypeModel model, BasicList candidates, Type iType);
    private static bool CheckDictionaryAccessors(TypeModel model, Type pair, Type value);
    private bool TryDeserializeList(TypeModel model, ProtoReader reader, DataFormat format, int tag, Type listType, Type itemType, Object& value);
    private static object CreateListInstance(Type listType, Type itemType);
    internal bool TryDeserializeAuxiliaryType(ProtoReader reader, DataFormat format, int tag, Type type, Object& value, bool skipOtherFields, bool asListItem, bool autoCreate, bool insideList);
    public static RuntimeTypeModel Create();
    protected internal static Type ResolveProxies(Type type);
    public bool IsDefined(Type type);
    protected internal int GetKey(Type& type);
    protected abstract virtual int GetKeyImpl(Type type);
    protected internal abstract virtual void Serialize(int key, object value, ProtoWriter dest);
    protected internal abstract virtual object Deserialize(int key, object value, ProtoReader source);
    public object DeepClone(object value);
    protected internal static void ThrowUnexpectedSubtype(Type expected, Type actual);
    protected internal static void ThrowUnexpectedType(Type type);
    internal static Exception CreateNestedListsNotSupported();
    public static void ThrowCannotCreateInstance(Type type);
    internal static string SerializeType(TypeModel model, Type type);
    internal static Type DeserializeType(TypeModel model, string value);
    public bool CanSerializeContractType(Type type);
    public bool CanSerialize(Type type);
    public bool CanSerializeBasicType(Type type);
    private bool CanSerialize(Type type, bool allowBasic, bool allowContract, bool allowLists);
    public virtual string GetSchema(Type type);
    public void add_DynamicTypeFormatting(TypeFormatEventHandler value);
    public void remove_DynamicTypeFormatting(TypeFormatEventHandler value);
    public IFormatter CreateFormatter(Type type);
    internal virtual Type GetType(string fullName, Assembly context);
    internal static Type ResolveKnownType(string name, TypeModel model, Assembly assembly);
}
public class ProtoBuf.Meta.ValueMember : object {
    private static byte OPTIONS_IsStrict;
    private static byte OPTIONS_IsPacked;
    private static byte OPTIONS_IsRequired;
    private static byte OPTIONS_OverwriteList;
    private static byte OPTIONS_SupportNull;
    private int fieldNumber;
    private MemberInfo member;
    private Type parentType;
    private Type itemType;
    private Type defaultType;
    private Type memberType;
    private object defaultValue;
    private RuntimeTypeModel model;
    private IProtoSerializer serializer;
    private DataFormat dataFormat;
    private bool asReference;
    private bool dynamicType;
    private MethodInfo getSpecified;
    private MethodInfo setSpecified;
    private string name;
    private byte flags;
    public int FieldNumber { get; }
    public MemberInfo Member { get; }
    public Type ItemType { get; }
    public Type MemberType { get; }
    public Type DefaultType { get; }
    public Type ParentType { get; }
    public object DefaultValue { get; public set; }
    internal IProtoSerializer Serializer { get; }
    public DataFormat DataFormat { get; public set; }
    public bool IsStrict { get; public set; }
    public bool IsPacked { get; public set; }
    public bool OverwriteList { get; public set; }
    public bool IsRequired { get; public set; }
    public bool AsReference { get; public set; }
    public bool DynamicType { get; public set; }
    public string Name { get; }
    public bool SupportNull { get; public set; }
    public ValueMember(RuntimeTypeModel model, Type parentType, int fieldNumber, MemberInfo member, Type memberType, Type itemType, Type defaultType, DataFormat dataFormat, object defaultValue);
    internal ValueMember(RuntimeTypeModel model, int fieldNumber, Type memberType, Type itemType, Type defaultType, DataFormat dataFormat);
    public int get_FieldNumber();
    public MemberInfo get_Member();
    public Type get_ItemType();
    public Type get_MemberType();
    public Type get_DefaultType();
    public Type get_ParentType();
    public object get_DefaultValue();
    public void set_DefaultValue(object value);
    internal object GetRawEnumValue();
    private static object ParseDefaultValue(Type type, object value);
    internal IProtoSerializer get_Serializer();
    public DataFormat get_DataFormat();
    public void set_DataFormat(DataFormat value);
    public bool get_IsStrict();
    public void set_IsStrict(bool value);
    public bool get_IsPacked();
    public void set_IsPacked(bool value);
    public bool get_OverwriteList();
    public void set_OverwriteList(bool value);
    public bool get_IsRequired();
    public void set_IsRequired(bool value);
    public bool get_AsReference();
    public void set_AsReference(bool value);
    public bool get_DynamicType();
    public void set_DynamicType(bool value);
    public void SetSpecified(MethodInfo getSpecified, MethodInfo setSpecified);
    private void ThrowIfFrozen();
    private IProtoSerializer BuildSerializer();
    private static WireType GetIntWireType(DataFormat format, int width);
    private static WireType GetDateTimeWireType(DataFormat format);
    internal static IProtoSerializer TryGetCoreSerializer(RuntimeTypeModel model, DataFormat dataFormat, Type type, WireType& defaultWireType, bool asReference, bool dynamicType, bool overwriteList, bool allowComplexTypes);
    internal void SetName(string name);
    public string get_Name();
    private bool HasFlag(byte flag);
    private void SetFlag(byte flag, bool value, bool throwIfFrozen);
    public bool get_SupportNull();
    public void set_SupportNull(bool value);
    internal string GetSchemaTypeName(bool applyNetObjectProxy, Boolean& requiresBclImport);
}
internal class ProtoBuf.NetObjectCache : object {
    internal static int Root;
    private MutableList underlyingList;
    private object rootObject;
    private int trapStartIndex;
    private Dictionary`2<string, int> stringKeys;
    private Dictionary`2<object, int> objectKeys;
    private MutableList List { get; }
    private MutableList get_List();
    internal object GetKeyedObject(int key);
    internal void SetKeyedObject(int key, object value);
    internal int AddObjectKey(object value, Boolean& existing);
    internal void RegisterTrappedObject(object value);
    internal void Clear();
}
public enum ProtoBuf.PrefixStyle : Enum {
    public int value__;
    public static PrefixStyle None;
    public static PrefixStyle Base128;
    public static PrefixStyle Fixed32;
    public static PrefixStyle Fixed32BigEndian;
}
[AttributeUsageAttribute("64")]
[ImmutableObjectAttribute("True")]
public class ProtoBuf.ProtoAfterDeserializationAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
[ImmutableObjectAttribute("True")]
public class ProtoBuf.ProtoAfterSerializationAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
[ImmutableObjectAttribute("True")]
public class ProtoBuf.ProtoBeforeDeserializationAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
[ImmutableObjectAttribute("True")]
public class ProtoBuf.ProtoBeforeSerializationAttribute : Attribute {
}
[AttributeUsageAttribute("1052")]
public class ProtoBuf.ProtoContractAttribute : Attribute {
    private static byte OPTIONS_InferTagFromName;
    private static byte OPTIONS_InferTagFromNameHasValue;
    private static byte OPTIONS_UseProtoMembersOnly;
    private static byte OPTIONS_SkipConstructor;
    private static byte OPTIONS_IgnoreListHandling;
    private static byte OPTIONS_AsReferenceDefault;
    private static byte OPTIONS_EnumPassthru;
    private static byte OPTIONS_EnumPassthruHasValue;
    private string name;
    private int implicitFirstTag;
    private ImplicitFields implicitFields;
    private int dataMemberOffset;
    private byte flags;
    public string Name { get; public set; }
    public int ImplicitFirstTag { get; public set; }
    public bool UseProtoMembersOnly { get; public set; }
    public bool IgnoreListHandling { get; public set; }
    public ImplicitFields ImplicitFields { get; public set; }
    public bool InferTagFromName { get; public set; }
    internal bool InferTagFromNameHasValue { get; }
    public int DataMemberOffset { get; public set; }
    public bool SkipConstructor { get; public set; }
    public bool AsReferenceDefault { get; public set; }
    public bool EnumPassthru { get; public set; }
    internal bool EnumPassthruHasValue { get; }
    public string get_Name();
    public void set_Name(string value);
    public int get_ImplicitFirstTag();
    public void set_ImplicitFirstTag(int value);
    public bool get_UseProtoMembersOnly();
    public void set_UseProtoMembersOnly(bool value);
    public bool get_IgnoreListHandling();
    public void set_IgnoreListHandling(bool value);
    public ImplicitFields get_ImplicitFields();
    public void set_ImplicitFields(ImplicitFields value);
    public bool get_InferTagFromName();
    public void set_InferTagFromName(bool value);
    internal bool get_InferTagFromNameHasValue();
    public int get_DataMemberOffset();
    public void set_DataMemberOffset(int value);
    public bool get_SkipConstructor();
    public void set_SkipConstructor(bool value);
    public bool get_AsReferenceDefault();
    public void set_AsReferenceDefault(bool value);
    private bool HasFlag(byte flag);
    private void SetFlag(byte flag, bool value);
    public bool get_EnumPassthru();
    public void set_EnumPassthru(bool value);
    internal bool get_EnumPassthruHasValue();
}
[AttributeUsageAttribute("256")]
public class ProtoBuf.ProtoEnumAttribute : Attribute {
    private bool hasValue;
    private int enumValue;
    private string name;
    public int Value { get; public set; }
    public string Name { get; public set; }
    public int get_Value();
    public void set_Value(int value);
    public bool HasValue();
    public string get_Name();
    public void set_Name(string value);
}
public class ProtoBuf.ProtoException : Exception {
    public ProtoException(string message);
    public ProtoException(string message, Exception innerException);
    protected ProtoException(SerializationInfo info, StreamingContext context);
}
[AttributeUsageAttribute("384")]
public class ProtoBuf.ProtoIgnoreAttribute : Attribute {
}
[AttributeUsageAttribute("1028")]
public class ProtoBuf.ProtoIncludeAttribute : Attribute {
    private int tag;
    private string knownTypeName;
    private DataFormat dataFormat;
    public int Tag { get; }
    public string KnownTypeName { get; }
    public Type KnownType { get; }
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public DataFormat DataFormat { get; public set; }
    public ProtoIncludeAttribute(int tag, Type knownType);
    public ProtoIncludeAttribute(int tag, string knownTypeName);
    public int get_Tag();
    public string get_KnownTypeName();
    public Type get_KnownType();
    public DataFormat get_DataFormat();
    public void set_DataFormat(DataFormat value);
}
[AttributeUsageAttribute("384")]
public class ProtoBuf.ProtoMemberAttribute : Attribute {
    internal MemberInfo Member;
    internal bool TagIsPinned;
    private string name;
    private DataFormat dataFormat;
    private int tag;
    private MemberSerializationOptions options;
    public string Name { get; public set; }
    public DataFormat DataFormat { get; public set; }
    public int Tag { get; }
    public bool IsRequired { get; public set; }
    public bool IsPacked { get; public set; }
    public bool OverwriteList { get; public set; }
    public bool AsReference { get; public set; }
    internal bool AsReferenceHasValue { get; internal set; }
    public bool DynamicType { get; public set; }
    public MemberSerializationOptions Options { get; public set; }
    public ProtoMemberAttribute(int tag);
    internal ProtoMemberAttribute(int tag, bool forced);
    public sealed virtual int CompareTo(object other);
    public sealed virtual int CompareTo(ProtoMemberAttribute other);
    public string get_Name();
    public void set_Name(string value);
    public DataFormat get_DataFormat();
    public void set_DataFormat(DataFormat value);
    public int get_Tag();
    internal void Rebase(int tag);
    public bool get_IsRequired();
    public void set_IsRequired(bool value);
    public bool get_IsPacked();
    public void set_IsPacked(bool value);
    public bool get_OverwriteList();
    public void set_OverwriteList(bool value);
    public bool get_AsReference();
    public void set_AsReference(bool value);
    internal bool get_AsReferenceHasValue();
    internal void set_AsReferenceHasValue(bool value);
    public bool get_DynamicType();
    public void set_DynamicType(bool value);
    public MemberSerializationOptions get_Options();
    public void set_Options(MemberSerializationOptions value);
}
[AttributeUsageAttribute("4")]
public class ProtoBuf.ProtoPartialIgnoreAttribute : ProtoIgnoreAttribute {
    private string memberName;
    public string MemberName { get; }
    public ProtoPartialIgnoreAttribute(string memberName);
    public string get_MemberName();
}
[AttributeUsageAttribute("4")]
public class ProtoBuf.ProtoPartialMemberAttribute : ProtoMemberAttribute {
    private string memberName;
    public string MemberName { get; }
    public ProtoPartialMemberAttribute(int tag, string memberName);
    public string get_MemberName();
}
public class ProtoBuf.ProtoReader : object {
    internal static int TO_EOF;
    private static long Int64Msb;
    private static int Int32Msb;
    private Stream source;
    private Byte[] ioBuffer;
    private TypeModel model;
    private int fieldNumber;
    private int depth;
    private int dataRemaining;
    private int ioIndex;
    private int position;
    private int available;
    private int blockEnd;
    private WireType wireType;
    private bool isFixedLength;
    private bool internStrings;
    private NetObjectCache netCache;
    private UInt32 trapCount;
    private SerializationContext context;
    private Dictionary`2<string, string> stringInterner;
    private static UTF8Encoding encoding;
    private static Byte[] EmptyBlob;
    [ThreadStaticAttribute]
private static ProtoReader lastReader;
    public int FieldNumber { get; }
    public WireType WireType { get; }
    public bool InternStrings { get; public set; }
    public SerializationContext Context { get; }
    public int Position { get; }
    public TypeModel Model { get; }
    internal NetObjectCache NetCache { get; }
    public ProtoReader(Stream source, TypeModel model, SerializationContext context);
    public ProtoReader(Stream source, TypeModel model, SerializationContext context, int length);
    private static ProtoReader();
    public int get_FieldNumber();
    public WireType get_WireType();
    public bool get_InternStrings();
    public void set_InternStrings(bool value);
    private static void Init(ProtoReader reader, Stream source, TypeModel model, SerializationContext context, int length);
    public SerializationContext get_Context();
    public sealed virtual void Dispose();
    internal int TryReadUInt32VariantWithoutMoving(bool trimNegative, UInt32& value);
    private UInt32 ReadUInt32Variant(bool trimNegative);
    private bool TryReadUInt32Variant(UInt32& value);
    public UInt32 ReadUInt32();
    public int get_Position();
    internal void Ensure(int count, bool strict);
    public short ReadInt16();
    public ushort ReadUInt16();
    public byte ReadByte();
    public sbyte ReadSByte();
    public int ReadInt32();
    private static int Zag(UInt32 ziggedValue);
    private static long Zag(ulong ziggedValue);
    public long ReadInt64();
    private int TryReadUInt64VariantWithoutMoving(UInt64& value);
    private ulong ReadUInt64Variant();
    private string Intern(string value);
    public string ReadString();
    public void ThrowEnumException(Type type, int value);
    private Exception CreateWireTypeException();
    private Exception CreateException(string message);
    public double ReadDouble();
    public static object ReadObject(object value, int key, ProtoReader reader);
    internal static object ReadTypedObject(object value, int key, ProtoReader reader, Type type);
    public static void EndSubItem(SubItemToken token, ProtoReader reader);
    public static SubItemToken StartSubItem(ProtoReader reader);
    public int ReadFieldHeader();
    public bool TryReadFieldHeader(int field);
    public TypeModel get_Model();
    public void Hint(WireType wireType);
    public void Assert(WireType wireType);
    public void SkipField();
    public ulong ReadUInt64();
    public float ReadSingle();
    public bool ReadBoolean();
    public static Byte[] AppendBytes(Byte[] value, ProtoReader reader);
    private static int ReadByteOrThrow(Stream source);
    public static int ReadLengthPrefix(Stream source, bool expectHeader, PrefixStyle style, Int32& fieldNumber);
    public static int DirectReadLittleEndianInt32(Stream source);
    public static int DirectReadBigEndianInt32(Stream source);
    public static int DirectReadVarintInt32(Stream source);
    public static void DirectReadBytes(Stream source, Byte[] buffer, int offset, int count);
    public static Byte[] DirectReadBytes(Stream source, int count);
    public static string DirectReadString(Stream source, int length);
    public static int ReadLengthPrefix(Stream source, bool expectHeader, PrefixStyle style, Int32& fieldNumber, Int32& bytesRead);
    private static int TryReadUInt32Variant(Stream source, UInt32& value);
    internal static void Seek(Stream source, int count, Byte[] buffer);
    internal static Exception AddErrorData(Exception exception, ProtoReader source);
    private static Exception EoF(ProtoReader source);
    public void AppendExtensionData(IExtensible instance);
    private void AppendExtensionField(ProtoWriter writer);
    public static bool HasSubValue(WireType wireType, ProtoReader source);
    internal int GetTypeKey(Type& type);
    internal NetObjectCache get_NetCache();
    internal Type DeserializeType(string value);
    internal void SetRootObject(object value);
    public static void NoteObject(object value, ProtoReader reader);
    public Type ReadType();
    internal void TrapNextObject(int newObjectKey);
    internal void CheckFullyConsumed();
    public static object Merge(ProtoReader parent, object from, object to);
    internal static ProtoReader Create(Stream source, TypeModel model, SerializationContext context, int len);
    private static ProtoReader GetRecycled();
    internal static void Recycle(ProtoReader reader);
}
internal enum ProtoBuf.ProtoTypeCode : Enum {
    public int value__;
    public static ProtoTypeCode Empty;
    public static ProtoTypeCode Unknown;
    public static ProtoTypeCode Boolean;
    public static ProtoTypeCode Char;
    public static ProtoTypeCode SByte;
    public static ProtoTypeCode Byte;
    public static ProtoTypeCode Int16;
    public static ProtoTypeCode UInt16;
    public static ProtoTypeCode Int32;
    public static ProtoTypeCode UInt32;
    public static ProtoTypeCode Int64;
    public static ProtoTypeCode UInt64;
    public static ProtoTypeCode Single;
    public static ProtoTypeCode Double;
    public static ProtoTypeCode Decimal;
    public static ProtoTypeCode DateTime;
    public static ProtoTypeCode String;
    public static ProtoTypeCode TimeSpan;
    public static ProtoTypeCode ByteArray;
    public static ProtoTypeCode Guid;
    public static ProtoTypeCode Uri;
    public static ProtoTypeCode Type;
}
public class ProtoBuf.ProtoWriter : object {
    private static int RecursionCheckDepth;
    private Stream dest;
    private TypeModel model;
    private NetObjectCache netCache;
    private int fieldNumber;
    private int flushLock;
    private WireType wireType;
    private int depth;
    private MutableList recursionStack;
    private SerializationContext context;
    private Byte[] ioBuffer;
    private int ioIndex;
    private int position;
    private static UTF8Encoding encoding;
    private int packedFieldNumber;
    internal NetObjectCache NetCache { get; }
    internal WireType WireType { get; }
    public SerializationContext Context { get; }
    public TypeModel Model { get; }
    public ProtoWriter(Stream dest, TypeModel model, SerializationContext context);
    private static ProtoWriter();
    public static void WriteObject(object value, int key, ProtoWriter writer);
    public static void WriteRecursionSafeObject(object value, int key, ProtoWriter writer);
    internal static void WriteObject(object value, int key, ProtoWriter writer, PrefixStyle style, int fieldNumber);
    internal int GetTypeKey(Type& type);
    internal NetObjectCache get_NetCache();
    internal WireType get_WireType();
    public static void WriteFieldHeader(int fieldNumber, WireType wireType, ProtoWriter writer);
    internal static void WriteHeaderCore(int fieldNumber, WireType wireType, ProtoWriter writer);
    public static void WriteBytes(Byte[] data, ProtoWriter writer);
    public static void WriteBytes(Byte[] data, int offset, int length, ProtoWriter writer);
    private static void CopyRawFromStream(Stream source, ProtoWriter writer);
    private static void IncrementedAndReset(int length, ProtoWriter writer);
    public static SubItemToken StartSubItem(object instance, ProtoWriter writer);
    private void CheckRecursionStackAndPush(object instance);
    private void PopRecursionStack();
    private static SubItemToken StartSubItem(object instance, ProtoWriter writer, bool allowFixed);
    public static void EndSubItem(SubItemToken token, ProtoWriter writer);
    private static void EndSubItem(SubItemToken token, ProtoWriter writer, PrefixStyle style);
    public SerializationContext get_Context();
    private sealed virtual override void System.IDisposable.Dispose();
    private void Dispose();
    internal static int GetPosition(ProtoWriter writer);
    private static void DemandSpace(int required, ProtoWriter writer);
    public void Close();
    internal void CheckDepthFlushlock();
    public TypeModel get_Model();
    internal static void Flush(ProtoWriter writer);
    private static void WriteUInt32Variant(UInt32 value, ProtoWriter writer);
    internal static UInt32 Zig(int value);
    internal static ulong Zig(long value);
    private static void WriteUInt64Variant(ulong value, ProtoWriter writer);
    public static void WriteString(string value, ProtoWriter writer);
    public static void WriteUInt64(ulong value, ProtoWriter writer);
    public static void WriteInt64(long value, ProtoWriter writer);
    public static void WriteUInt32(UInt32 value, ProtoWriter writer);
    public static void WriteInt16(short value, ProtoWriter writer);
    public static void WriteUInt16(ushort value, ProtoWriter writer);
    public static void WriteByte(byte value, ProtoWriter writer);
    public static void WriteSByte(sbyte value, ProtoWriter writer);
    private static void WriteInt32ToBuffer(int value, Byte[] buffer, int index);
    public static void WriteInt32(int value, ProtoWriter writer);
    public static void WriteDouble(double value, ProtoWriter writer);
    public static void WriteSingle(float value, ProtoWriter writer);
    public static void ThrowEnumException(ProtoWriter writer, object enumValue);
    internal static Exception CreateException(ProtoWriter writer);
    public static void WriteBoolean(bool value, ProtoWriter writer);
    public static void AppendExtensionData(IExtensible instance, ProtoWriter writer);
    public static void SetPackedField(int fieldNumber, ProtoWriter writer);
    internal string SerializeType(Type type);
    public void SetRootObject(object value);
    public static void WriteType(Type value, ProtoWriter writer);
}
public class ProtoBuf.SerializationContext : object {
    private bool frozen;
    private object context;
    private static SerializationContext default;
    private StreamingContextStates state;
    public object Context { get; public set; }
    internal static SerializationContext Default { get; }
    public StreamingContextStates State { get; public set; }
    private static SerializationContext();
    internal void Freeze();
    private void ThrowIfFrozen();
    public object get_Context();
    public void set_Context(object value);
    internal static SerializationContext get_Default();
    public StreamingContextStates get_State();
    public void set_State(StreamingContextStates value);
    public static StreamingContext op_Implicit(SerializationContext ctx);
    public static SerializationContext op_Implicit(StreamingContext ctx);
}
public static class ProtoBuf.Serializer : object {
    private static string ProtoBinaryField;
    public static int ListItemTag;
    public static string GetProto();
    public static T DeepClone(T instance);
    public static T Merge(Stream source, T instance);
    public static T Deserialize(Stream source);
    public static void Serialize(Stream destination, T instance);
    public static TTo ChangeType(TFrom instance);
    public static void Serialize(SerializationInfo info, T instance);
    public static void Serialize(SerializationInfo info, StreamingContext context, T instance);
    public static void Serialize(XmlWriter writer, T instance);
    public static void Merge(XmlReader reader, T instance);
    public static void Merge(SerializationInfo info, T instance);
    public static void Merge(SerializationInfo info, StreamingContext context, T instance);
    public static void PrepareSerializer();
    public static IFormatter CreateFormatter();
    public static IEnumerable`1<T> DeserializeItems(Stream source, PrefixStyle style, int fieldNumber);
    public static T DeserializeWithLengthPrefix(Stream source, PrefixStyle style);
    public static T DeserializeWithLengthPrefix(Stream source, PrefixStyle style, int fieldNumber);
    public static T MergeWithLengthPrefix(Stream source, T instance, PrefixStyle style);
    public static void SerializeWithLengthPrefix(Stream destination, T instance, PrefixStyle style);
    public static void SerializeWithLengthPrefix(Stream destination, T instance, PrefixStyle style, int fieldNumber);
    public static bool TryReadLengthPrefix(Stream source, PrefixStyle style, Int32& length);
    public static bool TryReadLengthPrefix(Byte[] buffer, int index, int count, PrefixStyle style, Int32& length);
    public static void FlushPool();
}
internal class ProtoBuf.Serializers.ArrayDecorator : ProtoDecoratorBase {
    private static byte OPTIONS_WritePacked;
    private static byte OPTIONS_OverwriteList;
    private static byte OPTIONS_SupportNull;
    private int fieldNumber;
    private byte options;
    private WireType packedWireType;
    private Type arrayType;
    private Type itemType;
    public Type ExpectedType { get; }
    public bool RequiresOldValue { get; }
    public bool ReturnsValue { get; }
    private bool AppendToCollection { get; }
    private bool SupportNull { get; }
    public ArrayDecorator(TypeModel model, IProtoSerializer tail, int fieldNumber, bool writePacked, WireType packedWireType, Type arrayType, bool overwriteList, bool supportNull);
    public virtual Type get_ExpectedType();
    public virtual bool get_RequiresOldValue();
    public virtual bool get_ReturnsValue();
    protected virtual void EmitWrite(CompilerContext ctx, Local valueFrom);
    private void EmitWriteArrayLoop(CompilerContext ctx, Local i, Local arr);
    private bool get_AppendToCollection();
    private bool get_SupportNull();
    public virtual void Write(object value, ProtoWriter dest);
    public virtual object Read(object value, ProtoReader source);
    protected virtual void EmitRead(CompilerContext ctx, Local valueFrom);
}
internal class ProtoBuf.Serializers.BlobSerializer : object {
    private static Type expectedType;
    private bool overwriteList;
    public Type ExpectedType { get; }
    private bool ProtoBuf.Serializers.IProtoSerializer.RequiresOldValue { get; }
    private bool ProtoBuf.Serializers.IProtoSerializer.ReturnsValue { get; }
    public BlobSerializer(TypeModel model, bool overwriteList);
    private static BlobSerializer();
    public sealed virtual Type get_ExpectedType();
    public sealed virtual object Read(object value, ProtoReader source);
    public sealed virtual void Write(object value, ProtoWriter dest);
    private sealed virtual override bool ProtoBuf.Serializers.IProtoSerializer.get_RequiresOldValue();
    private sealed virtual override bool ProtoBuf.Serializers.IProtoSerializer.get_ReturnsValue();
    private sealed virtual override void ProtoBuf.Serializers.IProtoSerializer.EmitWrite(CompilerContext ctx, Local valueFrom);
    private sealed virtual override void ProtoBuf.Serializers.IProtoSerializer.EmitRead(CompilerContext ctx, Local valueFrom);
}
internal class ProtoBuf.Serializers.BooleanSerializer : object {
    private static Type expectedType;
    public Type ExpectedType { get; }
    private bool ProtoBuf.Serializers.IProtoSerializer.RequiresOldValue { get; }
    private bool ProtoBuf.Serializers.IProtoSerializer.ReturnsValue { get; }
    public BooleanSerializer(TypeModel model);
    private static BooleanSerializer();
    public sealed virtual Type get_ExpectedType();
    public sealed virtual void Write(object value, ProtoWriter dest);
    public sealed virtual object Read(object value, ProtoReader source);
    private sealed virtual override bool ProtoBuf.Serializers.IProtoSerializer.get_RequiresOldValue();
    private sealed virtual override bool ProtoBuf.Serializers.IProtoSerializer.get_ReturnsValue();
    private sealed virtual override void ProtoBuf.Serializers.IProtoSerializer.EmitWrite(CompilerContext ctx, Local valueFrom);
    private sealed virtual override void ProtoBuf.Serializers.IProtoSerializer.EmitRead(CompilerContext ctx, Local valueFrom);
}
internal class ProtoBuf.Serializers.ByteSerializer : object {
    private static Type expectedType;
    public Type ExpectedType { get; }
    private bool ProtoBuf.Serializers.IProtoSerializer.RequiresOldValue { get; }
    private bool ProtoBuf.Serializers.IProtoSerializer.ReturnsValue { get; }
    public ByteSerializer(TypeModel model);
    private static ByteSerializer();
    public sealed virtual Type get_ExpectedType();
    private sealed virtual override bool ProtoBuf.Serializers.IProtoSerializer.get_RequiresOldValue();
    private sealed virtual override bool ProtoBuf.Serializers.IProtoSerializer.get_ReturnsValue();
    public sealed virtual void Write(object value, ProtoWriter dest);
    public sealed virtual object Read(object value, ProtoReader source);
    private sealed virtual override void ProtoBuf.Serializers.IProtoSerializer.EmitWrite(CompilerContext ctx, Local valueFrom);
    private sealed virtual override void ProtoBuf.Serializers.IProtoSerializer.EmitRead(CompilerContext ctx, Local valueFrom);
}
internal class ProtoBuf.Serializers.CharSerializer : UInt16Serializer {
    private static Type expectedType;
    public Type ExpectedType { get; }
    public CharSerializer(TypeModel model);
    private static CharSerializer();
    public virtual Type get_ExpectedType();
    public virtual void Write(object value, ProtoWriter dest);
    public virtual object Read(object value, ProtoReader source);
}
internal class ProtoBuf.Serializers.CompiledSerializer : object {
    private IProtoTypeSerializer head;
    private ProtoSerializer serializer;
    private ProtoDeserializer deserializer;
    private bool ProtoBuf.Serializers.IProtoSerializer.RequiresOldValue { get; }
    private bool ProtoBuf.Serializers.IProtoSerializer.ReturnsValue { get; }
    private Type ProtoBuf.Serializers.IProtoSerializer.ExpectedType { get; }
    private CompiledSerializer(IProtoTypeSerializer head, TypeModel model);
    private sealed virtual override bool ProtoBuf.Serializers.IProtoTypeSerializer.HasCallbacks(CallbackType callbackType);
    private sealed virtual override bool ProtoBuf.Serializers.IProtoTypeSerializer.CanCreateInstance();
    private sealed virtual override object ProtoBuf.Serializers.IProtoTypeSerializer.CreateInstance(ProtoReader source);
    public sealed virtual void Callback(object value, CallbackType callbackType, SerializationContext context);
    public static CompiledSerializer Wrap(IProtoTypeSerializer head, TypeModel model);
    private sealed virtual override bool ProtoBuf.Serializers.IProtoSerializer.get_RequiresOldValue();
    private sealed virtual override bool ProtoBuf.Serializers.IProtoSerializer.get_ReturnsValue();
    private sealed virtual override Type ProtoBuf.Serializers.IProtoSerializer.get_ExpectedType();
    private sealed virtual override void ProtoBuf.Serializers.IProtoSerializer.Write(object value, ProtoWriter dest);
    private sealed virtual override object ProtoBuf.Serializers.IProtoSerializer.Read(object value, ProtoReader source);
    private sealed virtual override void ProtoBuf.Serializers.IProtoSerializer.EmitWrite(CompilerContext ctx, Local valueFrom);
    private sealed virtual override void ProtoBuf.Serializers.IProtoSerializer.EmitRead(CompilerContext ctx, Local valueFrom);
    private sealed virtual override void ProtoBuf.Serializers.IProtoTypeSerializer.EmitCallback(CompilerContext ctx, Local valueFrom, CallbackType callbackType);
    private sealed virtual override void ProtoBuf.Serializers.IProtoTypeSerializer.EmitCreateInstance(CompilerContext ctx);
}
internal class ProtoBuf.Serializers.DateTimeSerializer : object {
    private static Type expectedType;
    public Type ExpectedType { get; }
    private bool ProtoBuf.Serializers.IProtoSerializer.RequiresOldValue { get; }
    private bool ProtoBuf.Serializers.IProtoSerializer.ReturnsValue { get; }
    public DateTimeSerializer(TypeModel model);
    private static DateTimeSerializer();
    public sealed virtual Type get_ExpectedType();
    private sealed virtual override bool ProtoBuf.Serializers.IProtoSerializer.get_RequiresOldValue();
    private sealed virtual override bool ProtoBuf.Serializers.IProtoSerializer.get_ReturnsValue();
    public sealed virtual object Read(object value, ProtoReader source);
    public sealed virtual void Write(object value, ProtoWriter dest);
    private sealed virtual override void ProtoBuf.Serializers.IProtoSerializer.EmitWrite(CompilerContext ctx, Local valueFrom);
    private sealed virtual override void ProtoBuf.Serializers.IProtoSerializer.EmitRead(CompilerContext ctx, Local valueFrom);
}
internal class ProtoBuf.Serializers.DecimalSerializer : object {
    private static Type expectedType;
    public Type ExpectedType { get; }
    private bool ProtoBuf.Serializers.IProtoSerializer.RequiresOldValue { get; }
    private bool ProtoBuf.Serializers.IProtoSerializer.ReturnsValue { get; }
    public DecimalSerializer(TypeModel model);
    private static DecimalSerializer();
    public sealed virtual Type get_ExpectedType();
    private sealed virtual override bool ProtoBuf.Serializers.IProtoSerializer.get_RequiresOldValue();
    private sealed virtual override bool ProtoBuf.Serializers.IProtoSerializer.get_ReturnsValue();
    public sealed virtual object Read(object value, ProtoReader source);
    public sealed virtual void Write(object value, ProtoWriter dest);
    private sealed virtual override void ProtoBuf.Serializers.IProtoSerializer.EmitWrite(CompilerContext ctx, Local valueFrom);
    private sealed virtual override void ProtoBuf.Serializers.IProtoSerializer.EmitRead(CompilerContext ctx, Local valueFrom);
}
internal class ProtoBuf.Serializers.DefaultValueDecorator : ProtoDecoratorBase {
    private object defaultValue;
    public Type ExpectedType { get; }
    public bool RequiresOldValue { get; }
    public bool ReturnsValue { get; }
    public DefaultValueDecorator(TypeModel model, object defaultValue, IProtoSerializer tail);
    public virtual Type get_ExpectedType();
    public virtual bool get_RequiresOldValue();
    public virtual bool get_ReturnsValue();
    public virtual void Write(object value, ProtoWriter dest);
    public virtual object Read(object value, ProtoReader source);
    protected virtual void EmitWrite(CompilerContext ctx, Local valueFrom);
    private void EmitBeq(CompilerContext ctx, CodeLabel label, Type type);
    private void EmitBranchIfDefaultValue(CompilerContext ctx, CodeLabel label);
    protected virtual void EmitRead(CompilerContext ctx, Local valueFrom);
}
internal class ProtoBuf.Serializers.DoubleSerializer : object {
    private static Type expectedType;
    public Type ExpectedType { get; }
    private bool ProtoBuf.Serializers.IProtoSerializer.RequiresOldValue { get; }
    private bool ProtoBuf.Serializers.IProtoSerializer.ReturnsValue { get; }
    public DoubleSerializer(TypeModel model);
    private static DoubleSerializer();
    public sealed virtual Type get_ExpectedType();
    private sealed virtual override bool ProtoBuf.Serializers.IProtoSerializer.get_RequiresOldValue();
    private sealed virtual override bool ProtoBuf.Serializers.IProtoSerializer.get_ReturnsValue();
    public sealed virtual object Read(object value, ProtoReader source);
    public sealed virtual void Write(object value, ProtoWriter dest);
    private sealed virtual override void ProtoBuf.Serializers.IProtoSerializer.EmitWrite(CompilerContext ctx, Local valueFrom);
    private sealed virtual override void ProtoBuf.Serializers.IProtoSerializer.EmitRead(CompilerContext ctx, Local valueFrom);
}
internal class ProtoBuf.Serializers.EnumSerializer : object {
    private Type enumType;
    private EnumPair[] map;
    public Type ExpectedType { get; }
    private bool ProtoBuf.Serializers.IProtoSerializer.RequiresOldValue { get; }
    private bool ProtoBuf.Serializers.IProtoSerializer.ReturnsValue { get; }
    public EnumSerializer(Type enumType, EnumPair[] map);
    private ProtoTypeCode GetTypeCode();
    public sealed virtual Type get_ExpectedType();
    private sealed virtual override bool ProtoBuf.Serializers.IProtoSerializer.get_RequiresOldValue();
    private sealed virtual override bool ProtoBuf.Serializers.IProtoSerializer.get_ReturnsValue();
    private int EnumToWire(object value);
    private object WireToEnum(int value);
    public sealed virtual object Read(object value, ProtoReader source);
    public sealed virtual void Write(object value, ProtoWriter dest);
    private sealed virtual override void ProtoBuf.Serializers.IProtoSerializer.EmitWrite(CompilerContext ctx, Local valueFrom);
    private sealed virtual override void ProtoBuf.Serializers.IProtoSerializer.EmitRead(CompilerContext ctx, Local valueFrom);
    private static void WriteEnumValue(CompilerContext ctx, ProtoTypeCode typeCode, object value);
    private static void WriteEnumValue(CompilerContext ctx, ProtoTypeCode typeCode, CodeLabel handler, CodeLabel continue, object value, Local local);
}
internal class ProtoBuf.Serializers.FieldDecorator : ProtoDecoratorBase {
    private FieldInfo field;
    private Type forType;
    public Type ExpectedType { get; }
    public bool RequiresOldValue { get; }
    public bool ReturnsValue { get; }
    public FieldDecorator(Type forType, FieldInfo field, IProtoSerializer tail);
    public virtual Type get_ExpectedType();
    public virtual bool get_RequiresOldValue();
    public virtual bool get_ReturnsValue();
    public virtual void Write(object value, ProtoWriter dest);
    public virtual object Read(object value, ProtoReader source);
    protected virtual void EmitWrite(CompilerContext ctx, Local valueFrom);
    protected virtual void EmitRead(CompilerContext ctx, Local valueFrom);
}
internal class ProtoBuf.Serializers.GuidSerializer : object {
    private static Type expectedType;
    public Type ExpectedType { get; }
    private bool ProtoBuf.Serializers.IProtoSerializer.RequiresOldValue { get; }
    private bool ProtoBuf.Serializers.IProtoSerializer.ReturnsValue { get; }
    public GuidSerializer(TypeModel model);
    private static GuidSerializer();
    public sealed virtual Type get_ExpectedType();
    private sealed virtual override bool ProtoBuf.Serializers.IProtoSerializer.get_RequiresOldValue();
    private sealed virtual override bool ProtoBuf.Serializers.IProtoSerializer.get_ReturnsValue();
    public sealed virtual void Write(object value, ProtoWriter dest);
    public sealed virtual object Read(object value, ProtoReader source);
    private sealed virtual override void ProtoBuf.Serializers.IProtoSerializer.EmitWrite(CompilerContext ctx, Local valueFrom);
    private sealed virtual override void ProtoBuf.Serializers.IProtoSerializer.EmitRead(CompilerContext ctx, Local valueFrom);
}
internal class ProtoBuf.Serializers.ImmutableCollectionDecorator : ListDecorator {
    private MethodInfo builderFactory;
    private MethodInfo add;
    private MethodInfo addRange;
    private MethodInfo finish;
    protected bool RequireAdd { get; }
    internal ImmutableCollectionDecorator(TypeModel model, Type declaredType, Type concreteType, IProtoSerializer tail, int fieldNumber, bool writePacked, WireType packedWireType, bool returnList, bool overwriteList, bool supportNull, MethodInfo builderFactory, MethodInfo add, MethodInfo addRange, MethodInfo finish);
    protected virtual bool get_RequireAdd();
    private static Type ResolveIReadOnlyCollection(Type declaredType, Type t);
    internal static bool IdentifyImmutable(TypeModel model, Type declaredType, MethodInfo& builderFactory, MethodInfo& add, MethodInfo& addRange, MethodInfo& finish);
    public virtual object Read(object value, ProtoReader source);
    protected virtual void EmitRead(CompilerContext ctx, Local valueFrom);
}
internal class ProtoBuf.Serializers.Int16Serializer : object {
    private static Type expectedType;
    public Type ExpectedType { get; }
    private bool ProtoBuf.Serializers.IProtoSerializer.RequiresOldValue { get; }
    private bool ProtoBuf.Serializers.IProtoSerializer.ReturnsValue { get; }
    public Int16Serializer(TypeModel model);
    private static Int16Serializer();
    public sealed virtual Type get_ExpectedType();
    private sealed virtual override bool ProtoBuf.Serializers.IProtoSerializer.get_RequiresOldValue();
    private sealed virtual override bool ProtoBuf.Serializers.IProtoSerializer.get_ReturnsValue();
    public sealed virtual object Read(object value, ProtoReader source);
    public sealed virtual void Write(object value, ProtoWriter dest);
    private sealed virtual override void ProtoBuf.Serializers.IProtoSerializer.EmitWrite(CompilerContext ctx, Local valueFrom);
    private sealed virtual override void ProtoBuf.Serializers.IProtoSerializer.EmitRead(CompilerContext ctx, Local valueFrom);
}
internal class ProtoBuf.Serializers.Int32Serializer : object {
    private static Type expectedType;
    public Type ExpectedType { get; }
    private bool ProtoBuf.Serializers.IProtoSerializer.RequiresOldValue { get; }
    private bool ProtoBuf.Serializers.IProtoSerializer.ReturnsValue { get; }
    public Int32Serializer(TypeModel model);
    private static Int32Serializer();
    public sealed virtual Type get_ExpectedType();
    private sealed virtual override bool ProtoBuf.Serializers.IProtoSerializer.get_RequiresOldValue();
    private sealed virtual override bool ProtoBuf.Serializers.IProtoSerializer.get_ReturnsValue();
    public sealed virtual object Read(object value, ProtoReader source);
    public sealed virtual void Write(object value, ProtoWriter dest);
    private sealed virtual override void ProtoBuf.Serializers.IProtoSerializer.EmitWrite(CompilerContext ctx, Local valueFrom);
    private sealed virtual override void ProtoBuf.Serializers.IProtoSerializer.EmitRead(CompilerContext ctx, Local valueFrom);
}
internal class ProtoBuf.Serializers.Int64Serializer : object {
    private static Type expectedType;
    public Type ExpectedType { get; }
    private bool ProtoBuf.Serializers.IProtoSerializer.RequiresOldValue { get; }
    private bool ProtoBuf.Serializers.IProtoSerializer.ReturnsValue { get; }
    public Int64Serializer(TypeModel model);
    private static Int64Serializer();
    public sealed virtual Type get_ExpectedType();
    private sealed virtual override bool ProtoBuf.Serializers.IProtoSerializer.get_RequiresOldValue();
    private sealed virtual override bool ProtoBuf.Serializers.IProtoSerializer.get_ReturnsValue();
    public sealed virtual object Read(object value, ProtoReader source);
    public sealed virtual void Write(object value, ProtoWriter dest);
    private sealed virtual override void ProtoBuf.Serializers.IProtoSerializer.EmitWrite(CompilerContext ctx, Local valueFrom);
    private sealed virtual override void ProtoBuf.Serializers.IProtoSerializer.EmitRead(CompilerContext ctx, Local valueFrom);
}
internal interface ProtoBuf.Serializers.IProtoSerializer {
    public Type ExpectedType { get; }
    public bool RequiresOldValue { get; }
    public bool ReturnsValue { get; }
    public abstract virtual Type get_ExpectedType();
    public abstract virtual void Write(object value, ProtoWriter dest);
    public abstract virtual object Read(object value, ProtoReader source);
    public abstract virtual bool get_RequiresOldValue();
    public abstract virtual bool get_ReturnsValue();
    public abstract virtual void EmitWrite(CompilerContext ctx, Local valueFrom);
    public abstract virtual void EmitRead(CompilerContext ctx, Local entity);
}
internal interface ProtoBuf.Serializers.IProtoTypeSerializer {
    public abstract virtual bool HasCallbacks(CallbackType callbackType);
    public abstract virtual bool CanCreateInstance();
    public abstract virtual object CreateInstance(ProtoReader source);
    public abstract virtual void Callback(object value, CallbackType callbackType, SerializationContext context);
    public abstract virtual void EmitCallback(CompilerContext ctx, Local valueFrom, CallbackType callbackType);
    public abstract virtual void EmitCreateInstance(CompilerContext ctx);
}
internal interface ProtoBuf.Serializers.ISerializerProxy {
    public IProtoSerializer Serializer { get; }
    public abstract virtual IProtoSerializer get_Serializer();
}
internal class ProtoBuf.Serializers.ListDecorator : ProtoDecoratorBase {
    private static byte OPTIONS_IsList;
    private static byte OPTIONS_SuppressIList;
    private static byte OPTIONS_WritePacked;
    private static byte OPTIONS_ReturnList;
    private static byte OPTIONS_OverwriteList;
    private static byte OPTIONS_SupportNull;
    private byte options;
    private Type declaredType;
    private Type concreteType;
    private MethodInfo add;
    private int fieldNumber;
    protected WireType packedWireType;
    private static Type ienumeratorType;
    private static Type ienumerableType;
    private bool IsList { get; }
    private bool SuppressIList { get; }
    private bool WritePacked { get; }
    private bool SupportNull { get; }
    private bool ReturnList { get; }
    protected bool RequireAdd { get; }
    public Type ExpectedType { get; }
    public bool RequiresOldValue { get; }
    public bool ReturnsValue { get; }
    protected bool AppendToCollection { get; }
    protected ListDecorator(TypeModel model, Type declaredType, Type concreteType, IProtoSerializer tail, int fieldNumber, bool writePacked, WireType packedWireType, bool returnList, bool overwriteList, bool supportNull);
    private static ListDecorator();
    internal static bool CanPack(WireType wireType);
    private bool get_IsList();
    private bool get_SuppressIList();
    private bool get_WritePacked();
    private bool get_SupportNull();
    private bool get_ReturnList();
    internal static ListDecorator Create(TypeModel model, Type declaredType, Type concreteType, IProtoSerializer tail, int fieldNumber, bool writePacked, WireType packedWireType, bool returnList, bool overwriteList, bool supportNull);
    protected virtual bool get_RequireAdd();
    public virtual Type get_ExpectedType();
    public virtual bool get_RequiresOldValue();
    public virtual bool get_ReturnsValue();
    protected bool get_AppendToCollection();
    protected virtual void EmitRead(CompilerContext ctx, Local valueFrom);
    internal static void EmitReadList(CompilerContext ctx, Local list, IProtoSerializer tail, MethodInfo add, WireType packedWireType, bool castListForAdd);
    private static void EmitReadAndAddItem(CompilerContext ctx, Local list, IProtoSerializer tail, MethodInfo add, bool castListForAdd);
    protected MethodInfo GetEnumeratorInfo(TypeModel model, MethodInfo& moveNext, MethodInfo& current);
    protected virtual void EmitWrite(CompilerContext ctx, Local valueFrom);
    public virtual void Write(object value, ProtoWriter dest);
    public virtual object Read(object value, ProtoReader source);
}
internal class ProtoBuf.Serializers.MemberSpecifiedDecorator : ProtoDecoratorBase {
    private MethodInfo getSpecified;
    private MethodInfo setSpecified;
    public Type ExpectedType { get; }
    public bool RequiresOldValue { get; }
    public bool ReturnsValue { get; }
    public MemberSpecifiedDecorator(MethodInfo getSpecified, MethodInfo setSpecified, IProtoSerializer tail);
    public virtual Type get_ExpectedType();
    public virtual bool get_RequiresOldValue();
    public virtual bool get_ReturnsValue();
    public virtual void Write(object value, ProtoWriter dest);
    public virtual object Read(object value, ProtoReader source);
    protected virtual void EmitWrite(CompilerContext ctx, Local valueFrom);
    protected virtual void EmitRead(CompilerContext ctx, Local valueFrom);
}
internal class ProtoBuf.Serializers.NetObjectSerializer : object {
    private int key;
    private Type type;
    private NetObjectOptions options;
    public Type ExpectedType { get; }
    public bool ReturnsValue { get; }
    public bool RequiresOldValue { get; }
    public NetObjectSerializer(TypeModel model, Type type, int key, NetObjectOptions options);
    public sealed virtual Type get_ExpectedType();
    public sealed virtual bool get_ReturnsValue();
    public sealed virtual bool get_RequiresOldValue();
    public sealed virtual object Read(object value, ProtoReader source);
    public sealed virtual void Write(object value, ProtoWriter dest);
    public sealed virtual void EmitRead(CompilerContext ctx, Local valueFrom);
    public sealed virtual void EmitWrite(CompilerContext ctx, Local valueFrom);
}
internal class ProtoBuf.Serializers.NullDecorator : ProtoDecoratorBase {
    public static int Tag;
    private Type expectedType;
    public Type ExpectedType { get; }
    public bool ReturnsValue { get; }
    public bool RequiresOldValue { get; }
    public NullDecorator(TypeModel model, IProtoSerializer tail);
    public virtual Type get_ExpectedType();
    public virtual bool get_ReturnsValue();
    public virtual bool get_RequiresOldValue();
    protected virtual void EmitRead(CompilerContext ctx, Local valueFrom);
    protected virtual void EmitWrite(CompilerContext ctx, Local valueFrom);
    public virtual object Read(object value, ProtoReader source);
    public virtual void Write(object value, ProtoWriter dest);
}
internal class ProtoBuf.Serializers.ParseableSerializer : object {
    private MethodInfo parse;
    public Type ExpectedType { get; }
    private bool ProtoBuf.Serializers.IProtoSerializer.RequiresOldValue { get; }
    private bool ProtoBuf.Serializers.IProtoSerializer.ReturnsValue { get; }
    private ParseableSerializer(MethodInfo parse);
    public static ParseableSerializer TryCreate(Type type, TypeModel model);
    private static MethodInfo GetCustomToString(Type type);
    public sealed virtual Type get_ExpectedType();
    private sealed virtual override bool ProtoBuf.Serializers.IProtoSerializer.get_RequiresOldValue();
    private sealed virtual override bool ProtoBuf.Serializers.IProtoSerializer.get_ReturnsValue();
    public sealed virtual object Read(object value, ProtoReader source);
    public sealed virtual void Write(object value, ProtoWriter dest);
    private sealed virtual override void ProtoBuf.Serializers.IProtoSerializer.EmitWrite(CompilerContext ctx, Local valueFrom);
    private sealed virtual override void ProtoBuf.Serializers.IProtoSerializer.EmitRead(CompilerContext ctx, Local valueFrom);
}
internal class ProtoBuf.Serializers.PropertyDecorator : ProtoDecoratorBase {
    private PropertyInfo property;
    private Type forType;
    private bool readOptionsWriteValue;
    private MethodInfo shadowSetter;
    public Type ExpectedType { get; }
    public bool RequiresOldValue { get; }
    public bool ReturnsValue { get; }
    public PropertyDecorator(TypeModel model, Type forType, PropertyInfo property, IProtoSerializer tail);
    public virtual Type get_ExpectedType();
    public virtual bool get_RequiresOldValue();
    public virtual bool get_ReturnsValue();
    private static void SanityCheck(TypeModel model, PropertyInfo property, IProtoSerializer tail, Boolean& writeValue, bool nonPublic, bool allowInternal);
    private static MethodInfo GetShadowSetter(TypeModel model, PropertyInfo property);
    public virtual void Write(object value, ProtoWriter dest);
    public virtual object Read(object value, ProtoReader source);
    protected virtual void EmitWrite(CompilerContext ctx, Local valueFrom);
    protected virtual void EmitRead(CompilerContext ctx, Local valueFrom);
    internal static bool CanWrite(TypeModel model, MemberInfo member);
}
internal abstract class ProtoBuf.Serializers.ProtoDecoratorBase : object {
    protected IProtoSerializer Tail;
    public Type ExpectedType { get; }
    public bool ReturnsValue { get; }
    public bool RequiresOldValue { get; }
    protected ProtoDecoratorBase(IProtoSerializer tail);
    public abstract virtual Type get_ExpectedType();
    public abstract virtual bool get_ReturnsValue();
    public abstract virtual bool get_RequiresOldValue();
    public abstract virtual void Write(object value, ProtoWriter dest);
    public abstract virtual object Read(object value, ProtoReader source);
    private sealed virtual override void ProtoBuf.Serializers.IProtoSerializer.EmitWrite(CompilerContext ctx, Local valueFrom);
    protected abstract virtual void EmitWrite(CompilerContext ctx, Local valueFrom);
    private sealed virtual override void ProtoBuf.Serializers.IProtoSerializer.EmitRead(CompilerContext ctx, Local valueFrom);
    protected abstract virtual void EmitRead(CompilerContext ctx, Local valueFrom);
}
internal class ProtoBuf.Serializers.SByteSerializer : object {
    private static Type expectedType;
    public Type ExpectedType { get; }
    private bool ProtoBuf.Serializers.IProtoSerializer.RequiresOldValue { get; }
    private bool ProtoBuf.Serializers.IProtoSerializer.ReturnsValue { get; }
    public SByteSerializer(TypeModel model);
    private static SByteSerializer();
    public sealed virtual Type get_ExpectedType();
    private sealed virtual override bool ProtoBuf.Serializers.IProtoSerializer.get_RequiresOldValue();
    private sealed virtual override bool ProtoBuf.Serializers.IProtoSerializer.get_ReturnsValue();
    public sealed virtual object Read(object value, ProtoReader source);
    public sealed virtual void Write(object value, ProtoWriter dest);
    private sealed virtual override void ProtoBuf.Serializers.IProtoSerializer.EmitWrite(CompilerContext ctx, Local valueFrom);
    private sealed virtual override void ProtoBuf.Serializers.IProtoSerializer.EmitRead(CompilerContext ctx, Local valueFrom);
}
internal class ProtoBuf.Serializers.SingleSerializer : object {
    private static Type expectedType;
    public Type ExpectedType { get; }
    private bool ProtoBuf.Serializers.IProtoSerializer.RequiresOldValue { get; }
    private bool ProtoBuf.Serializers.IProtoSerializer.ReturnsValue { get; }
    public SingleSerializer(TypeModel model);
    private static SingleSerializer();
    public sealed virtual Type get_ExpectedType();
    private sealed virtual override bool ProtoBuf.Serializers.IProtoSerializer.get_RequiresOldValue();
    private sealed virtual override bool ProtoBuf.Serializers.IProtoSerializer.get_ReturnsValue();
    public sealed virtual object Read(object value, ProtoReader source);
    public sealed virtual void Write(object value, ProtoWriter dest);
    private sealed virtual override void ProtoBuf.Serializers.IProtoSerializer.EmitWrite(CompilerContext ctx, Local valueFrom);
    private sealed virtual override void ProtoBuf.Serializers.IProtoSerializer.EmitRead(CompilerContext ctx, Local valueFrom);
}
internal class ProtoBuf.Serializers.StringSerializer : object {
    private static Type expectedType;
    public Type ExpectedType { get; }
    private bool ProtoBuf.Serializers.IProtoSerializer.RequiresOldValue { get; }
    private bool ProtoBuf.Serializers.IProtoSerializer.ReturnsValue { get; }
    public StringSerializer(TypeModel model);
    private static StringSerializer();
    public sealed virtual Type get_ExpectedType();
    public sealed virtual void Write(object value, ProtoWriter dest);
    private sealed virtual override bool ProtoBuf.Serializers.IProtoSerializer.get_RequiresOldValue();
    private sealed virtual override bool ProtoBuf.Serializers.IProtoSerializer.get_ReturnsValue();
    public sealed virtual object Read(object value, ProtoReader source);
    private sealed virtual override void ProtoBuf.Serializers.IProtoSerializer.EmitWrite(CompilerContext ctx, Local valueFrom);
    private sealed virtual override void ProtoBuf.Serializers.IProtoSerializer.EmitRead(CompilerContext ctx, Local valueFrom);
}
internal class ProtoBuf.Serializers.SubItemSerializer : object {
    private int key;
    private Type type;
    private ISerializerProxy proxy;
    private bool recursionCheck;
    private Type ProtoBuf.Serializers.IProtoSerializer.ExpectedType { get; }
    private bool ProtoBuf.Serializers.IProtoSerializer.RequiresOldValue { get; }
    private bool ProtoBuf.Serializers.IProtoSerializer.ReturnsValue { get; }
    public SubItemSerializer(Type type, int key, ISerializerProxy proxy, bool recursionCheck);
    private sealed virtual override bool ProtoBuf.Serializers.IProtoTypeSerializer.HasCallbacks(CallbackType callbackType);
    private sealed virtual override bool ProtoBuf.Serializers.IProtoTypeSerializer.CanCreateInstance();
    private sealed virtual override void ProtoBuf.Serializers.IProtoTypeSerializer.EmitCallback(CompilerContext ctx, Local valueFrom, CallbackType callbackType);
    private sealed virtual override void ProtoBuf.Serializers.IProtoTypeSerializer.EmitCreateInstance(CompilerContext ctx);
    private sealed virtual override void ProtoBuf.Serializers.IProtoTypeSerializer.Callback(object value, CallbackType callbackType, SerializationContext context);
    private sealed virtual override object ProtoBuf.Serializers.IProtoTypeSerializer.CreateInstance(ProtoReader source);
    private sealed virtual override Type ProtoBuf.Serializers.IProtoSerializer.get_ExpectedType();
    private sealed virtual override bool ProtoBuf.Serializers.IProtoSerializer.get_RequiresOldValue();
    private sealed virtual override bool ProtoBuf.Serializers.IProtoSerializer.get_ReturnsValue();
    private sealed virtual override void ProtoBuf.Serializers.IProtoSerializer.Write(object value, ProtoWriter dest);
    private sealed virtual override object ProtoBuf.Serializers.IProtoSerializer.Read(object value, ProtoReader source);
    private bool EmitDedicatedMethod(CompilerContext ctx, Local valueFrom, bool read);
    private sealed virtual override void ProtoBuf.Serializers.IProtoSerializer.EmitWrite(CompilerContext ctx, Local valueFrom);
    private sealed virtual override void ProtoBuf.Serializers.IProtoSerializer.EmitRead(CompilerContext ctx, Local valueFrom);
}
internal class ProtoBuf.Serializers.SurrogateSerializer : object {
    private Type forType;
    private Type declaredType;
    private MethodInfo toTail;
    private MethodInfo fromTail;
    private IProtoTypeSerializer rootTail;
    public bool ReturnsValue { get; }
    public bool RequiresOldValue { get; }
    public Type ExpectedType { get; }
    public SurrogateSerializer(Type forType, Type declaredType, IProtoTypeSerializer rootTail);
    private sealed virtual override bool ProtoBuf.Serializers.IProtoTypeSerializer.HasCallbacks(CallbackType callbackType);
    private sealed virtual override void ProtoBuf.Serializers.IProtoTypeSerializer.EmitCallback(CompilerContext ctx, Local valueFrom, CallbackType callbackType);
    private sealed virtual override void ProtoBuf.Serializers.IProtoTypeSerializer.EmitCreateInstance(CompilerContext ctx);
    private sealed virtual override bool ProtoBuf.Serializers.IProtoTypeSerializer.CanCreateInstance();
    private sealed virtual override object ProtoBuf.Serializers.IProtoTypeSerializer.CreateInstance(ProtoReader source);
    private sealed virtual override void ProtoBuf.Serializers.IProtoTypeSerializer.Callback(object value, CallbackType callbackType, SerializationContext context);
    public sealed virtual bool get_ReturnsValue();
    public sealed virtual bool get_RequiresOldValue();
    public sealed virtual Type get_ExpectedType();
    private static bool HasCast(Type type, Type from, Type to, MethodInfo& op);
    public MethodInfo GetConversion(bool toTail);
    public sealed virtual void Write(object value, ProtoWriter writer);
    public sealed virtual object Read(object value, ProtoReader source);
    private sealed virtual override void ProtoBuf.Serializers.IProtoSerializer.EmitRead(CompilerContext ctx, Local valueFrom);
    private sealed virtual override void ProtoBuf.Serializers.IProtoSerializer.EmitWrite(CompilerContext ctx, Local valueFrom);
}
internal class ProtoBuf.Serializers.SystemTypeSerializer : object {
    private static Type expectedType;
    public Type ExpectedType { get; }
    private bool ProtoBuf.Serializers.IProtoSerializer.RequiresOldValue { get; }
    private bool ProtoBuf.Serializers.IProtoSerializer.ReturnsValue { get; }
    public SystemTypeSerializer(TypeModel model);
    private static SystemTypeSerializer();
    public sealed virtual Type get_ExpectedType();
    private sealed virtual override void ProtoBuf.Serializers.IProtoSerializer.Write(object value, ProtoWriter dest);
    private sealed virtual override object ProtoBuf.Serializers.IProtoSerializer.Read(object value, ProtoReader source);
    private sealed virtual override bool ProtoBuf.Serializers.IProtoSerializer.get_RequiresOldValue();
    private sealed virtual override bool ProtoBuf.Serializers.IProtoSerializer.get_ReturnsValue();
    private sealed virtual override void ProtoBuf.Serializers.IProtoSerializer.EmitWrite(CompilerContext ctx, Local valueFrom);
    private sealed virtual override void ProtoBuf.Serializers.IProtoSerializer.EmitRead(CompilerContext ctx, Local valueFrom);
}
internal class ProtoBuf.Serializers.TagDecorator : ProtoDecoratorBase {
    private bool strict;
    private int fieldNumber;
    private WireType wireType;
    public Type ExpectedType { get; }
    public bool RequiresOldValue { get; }
    public bool ReturnsValue { get; }
    private bool NeedsHint { get; }
    public TagDecorator(int fieldNumber, WireType wireType, bool strict, IProtoSerializer tail);
    public sealed virtual bool HasCallbacks(CallbackType callbackType);
    public sealed virtual bool CanCreateInstance();
    public sealed virtual object CreateInstance(ProtoReader source);
    public sealed virtual void Callback(object value, CallbackType callbackType, SerializationContext context);
    public sealed virtual void EmitCallback(CompilerContext ctx, Local valueFrom, CallbackType callbackType);
    public sealed virtual void EmitCreateInstance(CompilerContext ctx);
    public virtual Type get_ExpectedType();
    public virtual bool get_RequiresOldValue();
    public virtual bool get_ReturnsValue();
    private bool get_NeedsHint();
    public virtual object Read(object value, ProtoReader source);
    public virtual void Write(object value, ProtoWriter dest);
    protected virtual void EmitWrite(CompilerContext ctx, Local valueFrom);
    protected virtual void EmitRead(CompilerContext ctx, Local valueFrom);
}
internal class ProtoBuf.Serializers.TimeSpanSerializer : object {
    private static Type expectedType;
    public Type ExpectedType { get; }
    private bool ProtoBuf.Serializers.IProtoSerializer.RequiresOldValue { get; }
    private bool ProtoBuf.Serializers.IProtoSerializer.ReturnsValue { get; }
    public TimeSpanSerializer(TypeModel model);
    private static TimeSpanSerializer();
    public sealed virtual Type get_ExpectedType();
    private sealed virtual override bool ProtoBuf.Serializers.IProtoSerializer.get_RequiresOldValue();
    private sealed virtual override bool ProtoBuf.Serializers.IProtoSerializer.get_ReturnsValue();
    public sealed virtual object Read(object value, ProtoReader source);
    public sealed virtual void Write(object value, ProtoWriter dest);
    private sealed virtual override void ProtoBuf.Serializers.IProtoSerializer.EmitWrite(CompilerContext ctx, Local valueFrom);
    private sealed virtual override void ProtoBuf.Serializers.IProtoSerializer.EmitRead(CompilerContext ctx, Local valueFrom);
}
internal class ProtoBuf.Serializers.TupleSerializer : object {
    private MemberInfo[] members;
    private ConstructorInfo ctor;
    private IProtoSerializer[] tails;
    public Type ExpectedType { get; }
    public bool RequiresOldValue { get; }
    public bool ReturnsValue { get; }
    public TupleSerializer(RuntimeTypeModel model, ConstructorInfo ctor, MemberInfo[] members);
    public sealed virtual bool HasCallbacks(CallbackType callbackType);
    public sealed virtual void EmitCallback(CompilerContext ctx, Local valueFrom, CallbackType callbackType);
    public sealed virtual Type get_ExpectedType();
    private sealed virtual override void ProtoBuf.Serializers.IProtoTypeSerializer.Callback(object value, CallbackType callbackType, SerializationContext context);
    private sealed virtual override object ProtoBuf.Serializers.IProtoTypeSerializer.CreateInstance(ProtoReader source);
    private object GetValue(object obj, int index);
    public sealed virtual object Read(object value, ProtoReader source);
    public sealed virtual void Write(object value, ProtoWriter dest);
    public sealed virtual bool get_RequiresOldValue();
    public sealed virtual bool get_ReturnsValue();
    private Type GetMemberType(int index);
    private sealed virtual override bool ProtoBuf.Serializers.IProtoTypeSerializer.CanCreateInstance();
    public sealed virtual void EmitWrite(CompilerContext ctx, Local valueFrom);
    private sealed virtual override void ProtoBuf.Serializers.IProtoTypeSerializer.EmitCreateInstance(CompilerContext ctx);
    public sealed virtual void EmitRead(CompilerContext ctx, Local incoming);
}
internal class ProtoBuf.Serializers.TypeSerializer : object {
    private Type forType;
    private Type constructType;
    private IProtoSerializer[] serializers;
    private Int32[] fieldNumbers;
    private bool isRootType;
    private bool useConstructor;
    private bool isExtensible;
    private bool hasConstructor;
    private CallbackSet callbacks;
    private MethodInfo[] baseCtorCallbacks;
    private MethodInfo factory;
    private static Type iextensible;
    public Type ExpectedType { get; }
    private bool CanHaveInheritance { get; }
    private bool ProtoBuf.Serializers.IProtoSerializer.RequiresOldValue { get; }
    private bool ProtoBuf.Serializers.IProtoSerializer.ReturnsValue { get; }
    public TypeSerializer(TypeModel model, Type forType, Int32[] fieldNumbers, IProtoSerializer[] serializers, MethodInfo[] baseCtorCallbacks, bool isRootType, bool useConstructor, CallbackSet callbacks, Type constructType, MethodInfo factory);
    private static TypeSerializer();
    public sealed virtual bool HasCallbacks(CallbackType callbackType);
    public sealed virtual Type get_ExpectedType();
    private bool get_CanHaveInheritance();
    private sealed virtual override bool ProtoBuf.Serializers.IProtoTypeSerializer.CanCreateInstance();
    private sealed virtual override object ProtoBuf.Serializers.IProtoTypeSerializer.CreateInstance(ProtoReader source);
    public sealed virtual void Callback(object value, CallbackType callbackType, SerializationContext context);
    private IProtoSerializer GetMoreSpecificSerializer(object value);
    public sealed virtual void Write(object value, ProtoWriter dest);
    public sealed virtual object Read(object value, ProtoReader source);
    private object InvokeCallback(MethodInfo method, object obj, SerializationContext context);
    private object CreateInstance(ProtoReader source, bool includeLocalCallback);
    private sealed virtual override bool ProtoBuf.Serializers.IProtoSerializer.get_RequiresOldValue();
    private sealed virtual override bool ProtoBuf.Serializers.IProtoSerializer.get_ReturnsValue();
    private sealed virtual override void ProtoBuf.Serializers.IProtoSerializer.EmitWrite(CompilerContext ctx, Local valueFrom);
    private static void EmitInvokeCallback(CompilerContext ctx, MethodInfo method, bool copyValue, Type constructType, Type type);
    private void EmitCallbackIfNeeded(CompilerContext ctx, Local valueFrom, CallbackType callbackType);
    private sealed virtual override void ProtoBuf.Serializers.IProtoTypeSerializer.EmitCallback(CompilerContext ctx, Local valueFrom, CallbackType callbackType);
    private sealed virtual override void ProtoBuf.Serializers.IProtoSerializer.EmitRead(CompilerContext ctx, Local valueFrom);
    private void WriteFieldHandler(CompilerContext ctx, Type expected, Local loc, CodeLabel handler, CodeLabel continue, IProtoSerializer serializer);
    private sealed virtual override void ProtoBuf.Serializers.IProtoTypeSerializer.EmitCreateInstance(CompilerContext ctx);
    private void EmitCreateIfNull(CompilerContext ctx, Local storage);
}
internal class ProtoBuf.Serializers.UInt16Serializer : object {
    private static Type expectedType;
    public Type ExpectedType { get; }
    private bool ProtoBuf.Serializers.IProtoSerializer.RequiresOldValue { get; }
    private bool ProtoBuf.Serializers.IProtoSerializer.ReturnsValue { get; }
    public UInt16Serializer(TypeModel model);
    private static UInt16Serializer();
    public virtual Type get_ExpectedType();
    private sealed virtual override bool ProtoBuf.Serializers.IProtoSerializer.get_RequiresOldValue();
    private sealed virtual override bool ProtoBuf.Serializers.IProtoSerializer.get_ReturnsValue();
    public virtual object Read(object value, ProtoReader source);
    public virtual void Write(object value, ProtoWriter dest);
    private sealed virtual override void ProtoBuf.Serializers.IProtoSerializer.EmitWrite(CompilerContext ctx, Local valueFrom);
    private sealed virtual override void ProtoBuf.Serializers.IProtoSerializer.EmitRead(CompilerContext ctx, Local valueFrom);
}
internal class ProtoBuf.Serializers.UInt32Serializer : object {
    private static Type expectedType;
    public Type ExpectedType { get; }
    private bool ProtoBuf.Serializers.IProtoSerializer.RequiresOldValue { get; }
    private bool ProtoBuf.Serializers.IProtoSerializer.ReturnsValue { get; }
    public UInt32Serializer(TypeModel model);
    private static UInt32Serializer();
    public sealed virtual Type get_ExpectedType();
    private sealed virtual override bool ProtoBuf.Serializers.IProtoSerializer.get_RequiresOldValue();
    private sealed virtual override bool ProtoBuf.Serializers.IProtoSerializer.get_ReturnsValue();
    public sealed virtual object Read(object value, ProtoReader source);
    public sealed virtual void Write(object value, ProtoWriter dest);
    private sealed virtual override void ProtoBuf.Serializers.IProtoSerializer.EmitWrite(CompilerContext ctx, Local valueFrom);
    private sealed virtual override void ProtoBuf.Serializers.IProtoSerializer.EmitRead(CompilerContext ctx, Local valueFrom);
}
internal class ProtoBuf.Serializers.UInt64Serializer : object {
    private static Type expectedType;
    public Type ExpectedType { get; }
    private bool ProtoBuf.Serializers.IProtoSerializer.RequiresOldValue { get; }
    private bool ProtoBuf.Serializers.IProtoSerializer.ReturnsValue { get; }
    public UInt64Serializer(TypeModel model);
    private static UInt64Serializer();
    public sealed virtual Type get_ExpectedType();
    private sealed virtual override bool ProtoBuf.Serializers.IProtoSerializer.get_RequiresOldValue();
    private sealed virtual override bool ProtoBuf.Serializers.IProtoSerializer.get_ReturnsValue();
    public sealed virtual object Read(object value, ProtoReader source);
    public sealed virtual void Write(object value, ProtoWriter dest);
    private sealed virtual override void ProtoBuf.Serializers.IProtoSerializer.EmitWrite(CompilerContext ctx, Local valueFrom);
    private sealed virtual override void ProtoBuf.Serializers.IProtoSerializer.EmitRead(CompilerContext ctx, Local valueFrom);
}
internal class ProtoBuf.Serializers.UriDecorator : ProtoDecoratorBase {
    private static Type expectedType;
    public Type ExpectedType { get; }
    public bool RequiresOldValue { get; }
    public bool ReturnsValue { get; }
    public UriDecorator(TypeModel model, IProtoSerializer tail);
    private static UriDecorator();
    public virtual Type get_ExpectedType();
    public virtual bool get_RequiresOldValue();
    public virtual bool get_ReturnsValue();
    public virtual void Write(object value, ProtoWriter dest);
    public virtual object Read(object value, ProtoReader source);
    protected virtual void EmitWrite(CompilerContext ctx, Local valueFrom);
    protected virtual void EmitRead(CompilerContext ctx, Local valueFrom);
}
public class ProtoBuf.SubItemToken : ValueType {
    internal int value;
    internal SubItemToken(int value);
}
internal enum ProtoBuf.TimeSpanScale : Enum {
    public int value__;
    public static TimeSpanScale Days;
    public static TimeSpanScale Hours;
    public static TimeSpanScale Minutes;
    public static TimeSpanScale Seconds;
    public static TimeSpanScale Milliseconds;
    public static TimeSpanScale Ticks;
    public static TimeSpanScale MinMax;
}
public enum ProtoBuf.WireType : Enum {
    public int value__;
    public static WireType None;
    public static WireType Variant;
    public static WireType Fixed64;
    public static WireType String;
    public static WireType StartGroup;
    public static WireType EndGroup;
    public static WireType Fixed32;
    public static WireType SignedVariant;
}
[PreserveAttribute]
public class System.ComponentModel.AddingNewEventArgs : object {
    [CompilerGeneratedAttribute]
private object <NewObject>k__BackingField;
    public object NewObject { get; public set; }
    public AddingNewEventArgs(object newObject);
    [CompilerGeneratedAttribute]
public object get_NewObject();
    [CompilerGeneratedAttribute]
public void set_NewObject(object value);
}
[PreserveAttribute]
public class System.ComponentModel.AddingNewEventHandler : MulticastDelegate {
    public AddingNewEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, AddingNewEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, AddingNewEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[PreserveAttribute]
public interface System.ComponentModel.INotifyCollectionChanged {
    [CompilerGeneratedAttribute]
public abstract virtual void add_CollectionChanged(NotifyCollectionChangedEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_CollectionChanged(NotifyCollectionChangedEventHandler value);
}
[PreserveAttribute]
public interface System.ComponentModel.INotifyPropertyChanging {
    [CompilerGeneratedAttribute]
public abstract virtual void add_PropertyChanging(PropertyChangingEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_PropertyChanging(PropertyChangingEventHandler value);
}
[PreserveAttribute]
public enum System.ComponentModel.NotifyCollectionChangedAction : Enum {
    public int value__;
    public static NotifyCollectionChangedAction Add;
    public static NotifyCollectionChangedAction Remove;
    public static NotifyCollectionChangedAction Replace;
    public static NotifyCollectionChangedAction Move;
    public static NotifyCollectionChangedAction Reset;
}
[PreserveAttribute]
public class System.ComponentModel.NotifyCollectionChangedEventArgs : object {
    [CompilerGeneratedAttribute]
private NotifyCollectionChangedAction <Action>k__BackingField;
    [CompilerGeneratedAttribute]
private IList <NewItems>k__BackingField;
    [CompilerGeneratedAttribute]
private int <NewStartingIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private IList <OldItems>k__BackingField;
    [CompilerGeneratedAttribute]
private int <OldStartingIndex>k__BackingField;
    internal NotifyCollectionChangedAction Action { get; internal set; }
    internal IList NewItems { get; internal set; }
    internal int NewStartingIndex { get; internal set; }
    internal IList OldItems { get; internal set; }
    internal int OldStartingIndex { get; internal set; }
    internal NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction action);
    internal NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction action, IList changedItems);
    internal NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction action, object changedItem);
    internal NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction action, IList newItems, IList oldItems);
    internal NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction action, IList changedItems, int startingIndex);
    internal NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction action, object changedItem, int index);
    internal NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction action, object newItem, object oldItem);
    internal NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction action, IList newItems, IList oldItems, int startingIndex);
    internal NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction action, IList changedItems, int index, int oldIndex);
    internal NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction action, object changedItem, int index, int oldIndex);
    internal NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction action, object newItem, object oldItem, int index);
    [CompilerGeneratedAttribute]
internal NotifyCollectionChangedAction get_Action();
    [CompilerGeneratedAttribute]
internal void set_Action(NotifyCollectionChangedAction value);
    [CompilerGeneratedAttribute]
internal IList get_NewItems();
    [CompilerGeneratedAttribute]
internal void set_NewItems(IList value);
    [CompilerGeneratedAttribute]
internal int get_NewStartingIndex();
    [CompilerGeneratedAttribute]
internal void set_NewStartingIndex(int value);
    [CompilerGeneratedAttribute]
internal IList get_OldItems();
    [CompilerGeneratedAttribute]
internal void set_OldItems(IList value);
    [CompilerGeneratedAttribute]
internal int get_OldStartingIndex();
    [CompilerGeneratedAttribute]
internal void set_OldStartingIndex(int value);
}
[PreserveAttribute]
public class System.ComponentModel.NotifyCollectionChangedEventHandler : MulticastDelegate {
    public NotifyCollectionChangedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, NotifyCollectionChangedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, NotifyCollectionChangedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[PreserveAttribute]
public class System.ComponentModel.PropertyChangingEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private string <PropertyName>k__BackingField;
    public string PropertyName { get; public set; }
    public PropertyChangingEventArgs(string propertyName);
    [CompilerGeneratedAttribute]
public virtual string get_PropertyName();
    [CompilerGeneratedAttribute]
public virtual void set_PropertyName(string value);
}
[PreserveAttribute]
public class System.ComponentModel.PropertyChangingEventHandler : MulticastDelegate {
    public PropertyChangingEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, PropertyChangingEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, PropertyChangingEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public enum WebSocketSharp.ByteOrder : Enum {
    public int value__;
    public static ByteOrder Little;
    public static ByteOrder Big;
}
public class WebSocketSharp.CloseEventArgs : EventArgs {
    private bool _clean;
    private PayloadData _payloadData;
    internal PayloadData PayloadData { get; }
    public ushort Code { get; }
    public string Reason { get; }
    public bool WasClean { get; internal set; }
    internal CloseEventArgs(ushort code);
    internal CloseEventArgs(CloseStatusCode code);
    internal CloseEventArgs(PayloadData payloadData);
    internal CloseEventArgs(ushort code, string reason);
    internal CloseEventArgs(CloseStatusCode code, string reason);
    internal PayloadData get_PayloadData();
    public ushort get_Code();
    public string get_Reason();
    public bool get_WasClean();
    internal void set_WasClean(bool value);
}
public enum WebSocketSharp.CloseStatusCode : Enum {
    public ushort value__;
    public static CloseStatusCode Normal;
    public static CloseStatusCode Away;
    public static CloseStatusCode ProtocolError;
    public static CloseStatusCode UnsupportedData;
    public static CloseStatusCode Undefined;
    public static CloseStatusCode NoStatus;
    public static CloseStatusCode Abnormal;
    public static CloseStatusCode InvalidData;
    public static CloseStatusCode PolicyViolation;
    public static CloseStatusCode TooBig;
    public static CloseStatusCode MandatoryExtension;
    public static CloseStatusCode ServerError;
    public static CloseStatusCode TlsHandshakeFailure;
}
public enum WebSocketSharp.CompressionMethod : Enum {
    public byte value__;
    public static CompressionMethod None;
    public static CompressionMethod Deflate;
}
public class WebSocketSharp.ErrorEventArgs : EventArgs {
    private Exception _exception;
    private string _message;
    public Exception Exception { get; }
    public string Message { get; }
    internal ErrorEventArgs(string message);
    internal ErrorEventArgs(string message, Exception exception);
    public Exception get_Exception();
    public string get_Message();
}
[ExtensionAttribute]
public static class WebSocketSharp.Ext : object {
    private static Byte[] _last;
    private static int _retry;
    private static string _tspecials;
    private static Ext();
    [ExtensionAttribute]
private static Byte[] compress(Byte[] data);
    [ExtensionAttribute]
private static MemoryStream compress(Stream stream);
    [ExtensionAttribute]
private static Byte[] compressToArray(Stream stream);
    [ExtensionAttribute]
private static Byte[] decompress(Byte[] data);
    [ExtensionAttribute]
private static MemoryStream decompress(Stream stream);
    [ExtensionAttribute]
private static Byte[] decompressToArray(Stream stream);
    [ExtensionAttribute]
private static void times(ulong n, Action action);
    [ExtensionAttribute]
internal static Byte[] Append(ushort code, string reason);
    [ExtensionAttribute]
internal static string CheckIfAvailable(ServerState state, bool ready, bool start, bool shutting);
    [ExtensionAttribute]
internal static string CheckIfAvailable(WebSocketState state, bool connecting, bool open, bool closing, bool closed);
    [ExtensionAttribute]
internal static string CheckIfValidProtocols(String[] protocols);
    [ExtensionAttribute]
internal static string CheckIfValidServicePath(string path);
    [ExtensionAttribute]
internal static string CheckIfValidSessionID(string id);
    [ExtensionAttribute]
internal static string CheckIfValidWaitTime(TimeSpan time);
    [ExtensionAttribute]
internal static bool CheckWaitTime(TimeSpan time, String& message);
    [ExtensionAttribute]
internal static void Close(HttpListenerResponse response, HttpStatusCode code);
    [ExtensionAttribute]
internal static void CloseWithAuthChallenge(HttpListenerResponse response, string challenge);
    [ExtensionAttribute]
internal static Byte[] Compress(Byte[] data, CompressionMethod method);
    [ExtensionAttribute]
internal static Stream Compress(Stream stream, CompressionMethod method);
    [ExtensionAttribute]
internal static Byte[] CompressToArray(Stream stream, CompressionMethod method);
    [ExtensionAttribute]
internal static bool Contains(IEnumerable`1<T> source, Func`2<T, bool> condition);
    [ExtensionAttribute]
internal static bool ContainsTwice(String[] values);
    [ExtensionAttribute]
internal static T[] Copy(T[] source, long length);
    [ExtensionAttribute]
internal static void CopyTo(Stream source, Stream destination, int bufferLength);
    [ExtensionAttribute]
internal static void CopyToAsync(Stream source, Stream destination, int bufferLength, Action completed, Action`1<Exception> error);
    [ExtensionAttribute]
internal static Byte[] Decompress(Byte[] data, CompressionMethod method);
    [ExtensionAttribute]
internal static Stream Decompress(Stream stream, CompressionMethod method);
    [ExtensionAttribute]
internal static Byte[] DecompressToArray(Stream stream, CompressionMethod method);
    [ExtensionAttribute]
internal static bool EqualsWith(int value, char c, Action`1<int> action);
    [ExtensionAttribute]
internal static string GetAbsolutePath(Uri uri);
    [ExtensionAttribute]
internal static string GetMessage(CloseStatusCode code);
    [ExtensionAttribute]
internal static string GetName(string nameAndValue, char separator);
    [ExtensionAttribute]
internal static string GetValue(string nameAndValue, char separator);
    [ExtensionAttribute]
internal static string GetValue(string nameAndValue, char separator, bool unquote);
    [ExtensionAttribute]
internal static TcpListenerWebSocketContext GetWebSocketContext(TcpClient tcpClient, string protocol, bool secure, ServerSslConfiguration sslConfig, Logger logger);
    [ExtensionAttribute]
internal static Byte[] InternalToByteArray(ushort value, ByteOrder order);
    [ExtensionAttribute]
internal static Byte[] InternalToByteArray(ulong value, ByteOrder order);
    [ExtensionAttribute]
internal static bool IsCompressionExtension(string value, CompressionMethod method);
    [ExtensionAttribute]
internal static bool IsControl(byte opcode);
    [ExtensionAttribute]
internal static bool IsControl(Opcode opcode);
    [ExtensionAttribute]
internal static bool IsData(byte opcode);
    [ExtensionAttribute]
internal static bool IsData(Opcode opcode);
    [ExtensionAttribute]
internal static bool IsPortNumber(int value);
    [ExtensionAttribute]
internal static bool IsReserved(ushort code);
    [ExtensionAttribute]
internal static bool IsReserved(CloseStatusCode code);
    [ExtensionAttribute]
internal static bool IsSupported(byte opcode);
    [ExtensionAttribute]
internal static bool IsText(string value);
    [ExtensionAttribute]
internal static bool IsToken(string value);
    [ExtensionAttribute]
internal static string Quote(string value);
    [ExtensionAttribute]
internal static Byte[] ReadBytes(Stream stream, int length);
    [ExtensionAttribute]
internal static Byte[] ReadBytes(Stream stream, long length, int bufferLength);
    [ExtensionAttribute]
internal static void ReadBytesAsync(Stream stream, int length, Action`1<Byte[]> completed, Action`1<Exception> error);
    [ExtensionAttribute]
internal static void ReadBytesAsync(Stream stream, long length, int bufferLength, Action`1<Byte[]> completed, Action`1<Exception> error);
    [ExtensionAttribute]
internal static string RemovePrefix(string value, String[] prefixes);
    [ExtensionAttribute]
internal static T[] Reverse(T[] array);
    [ExtensionAttribute]
internal static IEnumerable`1<string> SplitHeaderValue(string value, Char[] separators);
    [ExtensionAttribute]
internal static Byte[] ToByteArray(Stream stream);
    [ExtensionAttribute]
internal static CompressionMethod ToCompressionMethod(string value);
    [ExtensionAttribute]
internal static string ToExtensionString(CompressionMethod method, String[] parameters);
    [ExtensionAttribute]
internal static IPAddress ToIPAddress(string hostnameOrAddress);
    [ExtensionAttribute]
internal static List`1<TSource> ToList(IEnumerable`1<TSource> source);
    [ExtensionAttribute]
internal static ushort ToUInt16(Byte[] source, ByteOrder sourceOrder);
    [ExtensionAttribute]
internal static ulong ToUInt64(Byte[] source, ByteOrder sourceOrder);
    [ExtensionAttribute]
internal static string TrimEndSlash(string value);
    [ExtensionAttribute]
internal static bool TryCreateWebSocketUri(string uriString, Uri& result, String& message);
    [ExtensionAttribute]
internal static string Unquote(string value);
    [ExtensionAttribute]
internal static string UTF8Decode(Byte[] bytes);
    [ExtensionAttribute]
internal static Byte[] UTF8Encode(string s);
    [ExtensionAttribute]
internal static void WriteBytes(Stream stream, Byte[] bytes, int bufferLength);
    [ExtensionAttribute]
internal static void WriteBytesAsync(Stream stream, Byte[] bytes, int bufferLength, Action completed, Action`1<Exception> error);
    [ExtensionAttribute]
public static bool Contains(string value, Char[] chars);
    [ExtensionAttribute]
public static bool Contains(NameValueCollection collection, string name);
    [ExtensionAttribute]
public static bool Contains(NameValueCollection collection, string name, string value);
    [ExtensionAttribute]
public static void Emit(EventHandler eventHandler, object sender, EventArgs e);
    [ExtensionAttribute]
public static void Emit(EventHandler`1<TEventArgs> eventHandler, object sender, TEventArgs e);
    [ExtensionAttribute]
public static CookieCollection GetCookies(NameValueCollection headers, bool response);
    [ExtensionAttribute]
public static string GetDescription(HttpStatusCode code);
    [ExtensionAttribute]
public static string GetStatusDescription(int code);
    [ExtensionAttribute]
public static bool IsCloseStatusCode(ushort value);
    [ExtensionAttribute]
public static bool IsEnclosedIn(string value, char c);
    [ExtensionAttribute]
public static bool IsHostOrder(ByteOrder order);
    [ExtensionAttribute]
public static bool IsLocal(IPAddress address);
    [ExtensionAttribute]
public static bool IsNullOrEmpty(string value);
    [ExtensionAttribute]
public static bool IsPredefinedScheme(string value);
    [ExtensionAttribute]
public static bool IsUpgradeTo(HttpListenerRequest request, string protocol);
    [ExtensionAttribute]
public static bool MaybeUri(string value);
    [ExtensionAttribute]
public static T[] SubArray(T[] array, int startIndex, int length);
    [ExtensionAttribute]
public static T[] SubArray(T[] array, long startIndex, long length);
    [ExtensionAttribute]
public static void Times(int n, Action action);
    [ExtensionAttribute]
public static void Times(long n, Action action);
    [ExtensionAttribute]
public static void Times(UInt32 n, Action action);
    [ExtensionAttribute]
public static void Times(ulong n, Action action);
    [ExtensionAttribute]
public static void Times(int n, Action`1<int> action);
    [ExtensionAttribute]
public static void Times(long n, Action`1<long> action);
    [ExtensionAttribute]
public static void Times(UInt32 n, Action`1<UInt32> action);
    [ExtensionAttribute]
public static void Times(ulong n, Action`1<ulong> action);
    [ExtensionAttribute]
public static T To(Byte[] source, ByteOrder sourceOrder);
    [ExtensionAttribute]
public static Byte[] ToByteArray(T value, ByteOrder order);
    [ExtensionAttribute]
public static Byte[] ToHostOrder(Byte[] source, ByteOrder sourceOrder);
    [ExtensionAttribute]
public static string ToString(T[] array, string separator);
    [ExtensionAttribute]
public static Uri ToUri(string uriString);
    [ExtensionAttribute]
public static string UrlDecode(string value);
    [ExtensionAttribute]
public static string UrlEncode(string value);
    [ExtensionAttribute]
public static void WriteContent(HttpListenerResponse response, Byte[] content);
}
internal enum WebSocketSharp.Fin : Enum {
    public byte value__;
    public static Fin More;
    public static Fin Final;
}
internal abstract class WebSocketSharp.HttpBase : object {
    private NameValueCollection _headers;
    private static int _headersMaxLength;
    private Version _version;
    internal Byte[] EntityBodyData;
    protected static string CrLf;
    public string EntityBody { get; }
    public NameValueCollection Headers { get; }
    public Version ProtocolVersion { get; }
    protected HttpBase(Version version, NameValueCollection headers);
    public string get_EntityBody();
    public NameValueCollection get_Headers();
    public Version get_ProtocolVersion();
    private static Byte[] readEntityBody(Stream stream, string length);
    private static String[] readHeaders(Stream stream, int maxLength);
    protected static T Read(Stream stream, Func`2<String[], T> parser, int millisecondsTimeout);
    public Byte[] ToByteArray();
}
internal class WebSocketSharp.HttpRequest : HttpBase {
    private string _method;
    private string _uri;
    private bool _websocketRequest;
    private bool _websocketRequestSet;
    public AuthenticationResponse AuthenticationResponse { get; }
    public CookieCollection Cookies { get; }
    public string HttpMethod { get; }
    public bool IsWebSocketRequest { get; }
    public string RequestUri { get; }
    private HttpRequest(string method, string uri, Version version, NameValueCollection headers);
    internal HttpRequest(string method, string uri);
    public AuthenticationResponse get_AuthenticationResponse();
    public CookieCollection get_Cookies();
    public string get_HttpMethod();
    public bool get_IsWebSocketRequest();
    public string get_RequestUri();
    internal static HttpRequest CreateConnectRequest(Uri uri);
    internal static HttpRequest CreateWebSocketRequest(Uri uri);
    internal HttpResponse GetResponse(Stream stream, int millisecondsTimeout);
    internal static HttpRequest Parse(String[] headerParts);
    internal static HttpRequest Read(Stream stream, int millisecondsTimeout);
    public void SetCookies(CookieCollection cookies);
    public virtual string ToString();
}
internal class WebSocketSharp.HttpResponse : HttpBase {
    private string _code;
    private string _reason;
    public CookieCollection Cookies { get; }
    public bool HasConnectionClose { get; }
    public bool IsProxyAuthenticationRequired { get; }
    public bool IsRedirect { get; }
    public bool IsUnauthorized { get; }
    public bool IsWebSocketResponse { get; }
    public string Reason { get; }
    public string StatusCode { get; }
    private HttpResponse(string code, string reason, Version version, NameValueCollection headers);
    internal HttpResponse(HttpStatusCode code);
    internal HttpResponse(HttpStatusCode code, string reason);
    public CookieCollection get_Cookies();
    public bool get_HasConnectionClose();
    public bool get_IsProxyAuthenticationRequired();
    public bool get_IsRedirect();
    public bool get_IsUnauthorized();
    public bool get_IsWebSocketResponse();
    public string get_Reason();
    public string get_StatusCode();
    internal static HttpResponse CreateCloseResponse(HttpStatusCode code);
    internal static HttpResponse CreateUnauthorizedResponse(string challenge);
    internal static HttpResponse CreateWebSocketResponse();
    internal static HttpResponse Parse(String[] headerParts);
    internal static HttpResponse Read(Stream stream, int millisecondsTimeout);
    public void SetCookies(CookieCollection cookies);
    public virtual string ToString();
}
public class WebSocketSharp.LogData : object {
    private StackFrame _caller;
    private DateTime _date;
    private LogLevel _level;
    private string _message;
    public StackFrame Caller { get; }
    public DateTime Date { get; }
    public LogLevel Level { get; }
    public string Message { get; }
    internal LogData(LogLevel level, StackFrame caller, string message);
    public StackFrame get_Caller();
    public DateTime get_Date();
    public LogLevel get_Level();
    public string get_Message();
    public virtual string ToString();
}
public class WebSocketSharp.Logger : object {
    private String modreq(System.Runtime.CompilerServices.IsVolatile) _file;
    private LogLevel modreq(System.Runtime.CompilerServices.IsVolatile) _level;
    private Action`2<LogData, string> _output;
    private object _sync;
    public string File { get; public set; }
    public LogLevel Level { get; public set; }
    public Action`2<LogData, string> Output { get; public set; }
    public Logger(LogLevel level);
    public Logger(LogLevel level, string file, Action`2<LogData, string> output);
    public string get_File();
    public void set_File(string value);
    public LogLevel get_Level();
    public void set_Level(LogLevel value);
    public Action`2<LogData, string> get_Output();
    public void set_Output(Action`2<LogData, string> value);
    private static void defaultOutput(LogData data, string path);
    private void output(string message, LogLevel level);
    private static void writeToFile(string value, string path);
    public void Debug(string message);
    public void Error(string message);
    public void Fatal(string message);
    public void Info(string message);
    public void Trace(string message);
    public void Warn(string message);
}
public enum WebSocketSharp.LogLevel : Enum {
    public int value__;
    public static LogLevel Trace;
    public static LogLevel Debug;
    public static LogLevel Info;
    public static LogLevel Warn;
    public static LogLevel Error;
    public static LogLevel Fatal;
}
internal enum WebSocketSharp.Mask : Enum {
    public byte value__;
    public static Mask Off;
    public static Mask On;
}
public class WebSocketSharp.MessageEventArgs : EventArgs {
    private string _data;
    private bool _dataSet;
    private Opcode _opcode;
    private Byte[] _rawData;
    internal Opcode Opcode { get; }
    public string Data { get; }
    public bool IsBinary { get; }
    public bool IsPing { get; }
    public bool IsText { get; }
    public bool IsClose { get; }
    public Byte[] RawData { get; }
    internal MessageEventArgs(WebSocketFrame frame);
    internal MessageEventArgs(Opcode opcode, Byte[] rawData);
    internal Opcode get_Opcode();
    public string get_Data();
    public bool get_IsBinary();
    public bool get_IsPing();
    public bool get_IsText();
    public bool get_IsClose();
    public Byte[] get_RawData();
}
internal abstract class WebSocketSharp.Net.AuthenticationBase : object {
    private AuthenticationSchemes _scheme;
    internal NameValueCollection Parameters;
    public string Algorithm { get; }
    public string Nonce { get; }
    public string Opaque { get; }
    public string Qop { get; }
    public string Realm { get; }
    public AuthenticationSchemes Scheme { get; }
    protected AuthenticationBase(AuthenticationSchemes scheme, NameValueCollection parameters);
    public string get_Algorithm();
    public string get_Nonce();
    public string get_Opaque();
    public string get_Qop();
    public string get_Realm();
    public AuthenticationSchemes get_Scheme();
    internal static string CreateNonceValue();
    internal static NameValueCollection ParseParameters(string value);
    internal abstract virtual string ToBasicString();
    internal abstract virtual string ToDigestString();
    public virtual string ToString();
}
internal class WebSocketSharp.Net.AuthenticationChallenge : AuthenticationBase {
    public string Domain { get; }
    public string Stale { get; }
    private AuthenticationChallenge(AuthenticationSchemes scheme, NameValueCollection parameters);
    internal AuthenticationChallenge(AuthenticationSchemes scheme, string realm);
    public string get_Domain();
    public string get_Stale();
    internal static AuthenticationChallenge CreateBasicChallenge(string realm);
    internal static AuthenticationChallenge CreateDigestChallenge(string realm);
    internal static AuthenticationChallenge Parse(string value);
    internal virtual string ToBasicString();
    internal virtual string ToDigestString();
}
internal class WebSocketSharp.Net.AuthenticationResponse : AuthenticationBase {
    private UInt32 _nonceCount;
    internal UInt32 NonceCount { get; }
    public string Cnonce { get; }
    public string Nc { get; }
    public string Password { get; }
    public string Response { get; }
    public string Uri { get; }
    public string UserName { get; }
    private AuthenticationResponse(AuthenticationSchemes scheme, NameValueCollection parameters);
    internal AuthenticationResponse(NetworkCredential credentials);
    internal AuthenticationResponse(AuthenticationChallenge challenge, NetworkCredential credentials, UInt32 nonceCount);
    internal AuthenticationResponse(AuthenticationSchemes scheme, NameValueCollection parameters, NetworkCredential credentials, UInt32 nonceCount);
    internal UInt32 get_NonceCount();
    public string get_Cnonce();
    public string get_Nc();
    public string get_Password();
    public string get_Response();
    public string get_Uri();
    public string get_UserName();
    private static string createA1(string username, string password, string realm);
    private static string createA1(string username, string password, string realm, string nonce, string cnonce);
    private static string createA2(string method, string uri);
    private static string createA2(string method, string uri, string entity);
    private static string hash(string value);
    private void initAsDigest();
    internal static string CreateRequestDigest(NameValueCollection parameters);
    internal static AuthenticationResponse Parse(string value);
    internal static NameValueCollection ParseBasicCredentials(string value);
    internal virtual string ToBasicString();
    internal virtual string ToDigestString();
    public IIdentity ToIdentity();
}
public enum WebSocketSharp.Net.AuthenticationSchemes : Enum {
    public int value__;
    public static AuthenticationSchemes None;
    public static AuthenticationSchemes Digest;
    public static AuthenticationSchemes Basic;
    public static AuthenticationSchemes Anonymous;
}
internal class WebSocketSharp.Net.Chunk : object {
    private Byte[] _data;
    private int _offset;
    public int ReadLeft { get; }
    public Chunk(Byte[] data);
    public int get_ReadLeft();
    public int Read(Byte[] buffer, int offset, int count);
}
internal class WebSocketSharp.Net.ChunkedRequestStream : RequestStream {
    private static int _bufferLength;
    private HttpListenerContext _context;
    private ChunkStream _decoder;
    private bool _disposed;
    private bool _noMoreData;
    internal ChunkStream Decoder { get; internal set; }
    internal ChunkedRequestStream(Stream stream, Byte[] buffer, int offset, int count, HttpListenerContext context);
    internal ChunkStream get_Decoder();
    internal void set_Decoder(ChunkStream value);
    private void onRead(IAsyncResult asyncResult);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual void Close();
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual int Read(Byte[] buffer, int offset, int count);
}
internal class WebSocketSharp.Net.ChunkStream : object {
    private int _chunkRead;
    private int _chunkSize;
    private List`1<Chunk> _chunks;
    private bool _gotIt;
    private WebHeaderCollection _headers;
    private StringBuilder _saved;
    private bool _sawCr;
    private InputChunkState _state;
    private int _trailerState;
    internal WebHeaderCollection Headers { get; }
    public int ChunkLeft { get; }
    public bool WantMore { get; }
    public ChunkStream(WebHeaderCollection headers);
    public ChunkStream(Byte[] buffer, int offset, int count, WebHeaderCollection headers);
    internal WebHeaderCollection get_Headers();
    public int get_ChunkLeft();
    public bool get_WantMore();
    private int read(Byte[] buffer, int offset, int count);
    private static string removeChunkExtension(string value);
    private InputChunkState seekCrLf(Byte[] buffer, Int32& offset, int length);
    private InputChunkState setChunkSize(Byte[] buffer, Int32& offset, int length);
    private InputChunkState setTrailer(Byte[] buffer, Int32& offset, int length);
    private static void throwProtocolViolation(string message);
    private void write(Byte[] buffer, Int32& offset, int length);
    private InputChunkState writeData(Byte[] buffer, Int32& offset, int length);
    internal void ResetBuffer();
    internal int WriteAndReadBack(Byte[] buffer, int offset, int writeCount, int readCount);
    public int Read(Byte[] buffer, int offset, int count);
    public void Write(Byte[] buffer, int offset, int count);
}
public class WebSocketSharp.Net.ClientSslConfiguration : SslConfiguration {
    private X509CertificateCollection _certs;
    private string _host;
    public X509CertificateCollection ClientCertificates { get; public set; }
    public LocalCertificateSelectionCallback ClientCertificateSelectionCallback { get; public set; }
    public RemoteCertificateValidationCallback ServerCertificateValidationCallback { get; public set; }
    public string TargetHost { get; public set; }
    public ClientSslConfiguration(string targetHost);
    public ClientSslConfiguration(string targetHost, X509CertificateCollection clientCertificates, SslProtocols enabledSslProtocols, bool checkCertificateRevocation);
    public X509CertificateCollection get_ClientCertificates();
    public void set_ClientCertificates(X509CertificateCollection value);
    public LocalCertificateSelectionCallback get_ClientCertificateSelectionCallback();
    public void set_ClientCertificateSelectionCallback(LocalCertificateSelectionCallback value);
    public RemoteCertificateValidationCallback get_ServerCertificateValidationCallback();
    public void set_ServerCertificateValidationCallback(RemoteCertificateValidationCallback value);
    public string get_TargetHost();
    public void set_TargetHost(string value);
}
public class WebSocketSharp.Net.Cookie : object {
    private string _comment;
    private Uri _commentUri;
    private bool _discard;
    private string _domain;
    private DateTime _expires;
    private bool _httpOnly;
    private string _name;
    private string _path;
    private string _port;
    private Int32[] _ports;
    private static Char[] _reservedCharsForName;
    private static Char[] _reservedCharsForValue;
    private bool _secure;
    private DateTime _timestamp;
    private string _value;
    private int _version;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
private bool <ExactDomain>k__BackingField;
    internal bool ExactDomain { get; internal set; }
    internal int MaxAge { get; }
    internal Int32[] Ports { get; }
    public string Comment { get; public set; }
    public Uri CommentUri { get; public set; }
    public bool Discard { get; public set; }
    public string Domain { get; public set; }
    public bool Expired { get; public set; }
    public DateTime Expires { get; public set; }
    public bool HttpOnly { get; public set; }
    public string Name { get; public set; }
    public string Path { get; public set; }
    public string Port { get; public set; }
    public bool Secure { get; public set; }
    public DateTime TimeStamp { get; }
    public string Value { get; public set; }
    public int Version { get; public set; }
    private static Cookie();
    public Cookie(string name, string value);
    public Cookie(string name, string value, string path);
    public Cookie(string name, string value, string path, string domain);
    [CompilerGeneratedAttribute]
internal bool get_ExactDomain();
    [CompilerGeneratedAttribute]
internal void set_ExactDomain(bool value);
    internal int get_MaxAge();
    internal Int32[] get_Ports();
    public string get_Comment();
    public void set_Comment(string value);
    public Uri get_CommentUri();
    public void set_CommentUri(Uri value);
    public bool get_Discard();
    public void set_Discard(bool value);
    public string get_Domain();
    public void set_Domain(string value);
    public bool get_Expired();
    public void set_Expired(bool value);
    public DateTime get_Expires();
    public void set_Expires(DateTime value);
    public bool get_HttpOnly();
    public void set_HttpOnly(bool value);
    public string get_Name();
    public void set_Name(string value);
    public string get_Path();
    public void set_Path(string value);
    public string get_Port();
    public void set_Port(string value);
    public bool get_Secure();
    public void set_Secure(bool value);
    public DateTime get_TimeStamp();
    public string get_Value();
    public void set_Value(string value);
    public int get_Version();
    public void set_Version(int value);
    private static bool canSetName(string name, String& message);
    private static bool canSetValue(string value, String& message);
    private static int hash(int i, int j, int k, int l, int m);
    private string toResponseStringVersion0();
    private string toResponseStringVersion1();
    private static bool tryCreatePorts(string value, Int32[]& result, String& parseError);
    internal string ToRequestString(Uri uri);
    internal string ToResponseString();
    public virtual bool Equals(object comparand);
    public virtual int GetHashCode();
    public virtual string ToString();
}
[DefaultMemberAttribute("Item")]
public class WebSocketSharp.Net.CookieCollection : object {
    private List`1<Cookie> _list;
    private object _sync;
    internal IList`1<Cookie> List { get; }
    internal IEnumerable`1<Cookie> Sorted { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public bool IsSynchronized { get; }
    public Cookie Item { get; }
    public Cookie Item { get; }
    public object SyncRoot { get; }
    internal IList`1<Cookie> get_List();
    internal IEnumerable`1<Cookie> get_Sorted();
    public sealed virtual int get_Count();
    public bool get_IsReadOnly();
    public sealed virtual bool get_IsSynchronized();
    public Cookie get_Item(int index);
    public Cookie get_Item(string name);
    public sealed virtual object get_SyncRoot();
    private static int compareCookieWithinSort(Cookie x, Cookie y);
    private static int compareCookieWithinSorted(Cookie x, Cookie y);
    private static CookieCollection parseRequest(string value);
    private static CookieCollection parseResponse(string value);
    private int searchCookie(Cookie cookie);
    private static String[] splitCookieHeaderValue(string value);
    internal static CookieCollection Parse(string value, bool response);
    internal void SetOrRemove(Cookie cookie);
    internal void SetOrRemove(CookieCollection cookies);
    internal void Sort();
    public void Add(Cookie cookie);
    public void Add(CookieCollection cookies);
    public sealed virtual void CopyTo(Array array, int index);
    public void CopyTo(Cookie[] array, int index);
    public sealed virtual IEnumerator GetEnumerator();
}
public class WebSocketSharp.Net.CookieException : FormatException {
    internal CookieException(string message);
    internal CookieException(string message, Exception innerException);
    protected CookieException(SerializationInfo serializationInfo, StreamingContext streamingContext);
    public virtual void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
}
internal class WebSocketSharp.Net.EndPointListener : object {
    private List`1<HttpListenerPrefix> _all;
    private static string _defaultCertFolderPath;
    private IPEndPoint _endpoint;
    private Dictionary`2<HttpListenerPrefix, HttpListener> _prefixes;
    private bool _secure;
    private Socket _socket;
    private ServerSslConfiguration _sslConfig;
    private List`1<HttpListenerPrefix> _unhandled;
    private Dictionary`2<HttpConnection, HttpConnection> _unregistered;
    private object _unregisteredSync;
    public IPAddress Address { get; }
    public bool IsSecure { get; }
    public int Port { get; }
    public ServerSslConfiguration SslConfiguration { get; }
    private static EndPointListener();
    internal EndPointListener(IPEndPoint endpoint, bool secure, string certificateFolderPath, ServerSslConfiguration sslConfig, bool reuseAddress);
    public IPAddress get_Address();
    public bool get_IsSecure();
    public int get_Port();
    public ServerSslConfiguration get_SslConfiguration();
    private static void addSpecial(List`1<HttpListenerPrefix> prefixes, HttpListenerPrefix prefix);
    private static RSACryptoServiceProvider createRSAFromFile(string filename);
    private static X509Certificate2 getCertificate(int port, string folderPath, X509Certificate2 defaultCertificate);
    private void leaveIfNoPrefix();
    private static void onAccept(IAsyncResult asyncResult);
    private static void processAccepted(Socket socket, EndPointListener listener);
    private static bool removeSpecial(List`1<HttpListenerPrefix> prefixes, HttpListenerPrefix prefix);
    private static HttpListener searchHttpListenerFromSpecial(string path, List`1<HttpListenerPrefix> prefixes);
    internal static bool CertificateExists(int port, string folderPath);
    internal void RemoveConnection(HttpConnection connection);
    internal bool TrySearchHttpListener(Uri uri, HttpListener& listener);
    public void AddPrefix(HttpListenerPrefix prefix, HttpListener listener);
    public void Close();
    public void RemovePrefix(HttpListenerPrefix prefix, HttpListener listener);
}
internal class WebSocketSharp.Net.EndPointManager : object {
    private static Dictionary`2<IPEndPoint, EndPointListener> _endpoints;
    private static EndPointManager();
    private static void addPrefix(string uriPrefix, HttpListener listener);
    private static IPAddress convertToIPAddress(string hostname);
    private static void removePrefix(string uriPrefix, HttpListener listener);
    internal static bool RemoveEndPoint(IPEndPoint endpoint);
    public static void AddListener(HttpListener listener);
    public static void AddPrefix(string uriPrefix, HttpListener listener);
    public static void RemoveListener(HttpListener listener);
    public static void RemovePrefix(string uriPrefix, HttpListener listener);
}
public class WebSocketSharp.Net.HttpBasicIdentity : GenericIdentity {
    private string _password;
    public string Password { get; }
    internal HttpBasicIdentity(string username, string password);
    public virtual string get_Password();
}
internal class WebSocketSharp.Net.HttpConnection : object {
    private Byte[] _buffer;
    private static int _bufferLength;
    private HttpListenerContext _context;
    private bool _contextRegistered;
    private StringBuilder _currentLine;
    private InputState _inputState;
    private RequestStream _inputStream;
    private HttpListener _lastListener;
    private LineState _lineState;
    private EndPointListener _listener;
    private ResponseStream _outputStream;
    private int _position;
    private MemoryStream _requestBuffer;
    private int _reuses;
    private bool _secure;
    private Socket _socket;
    private Stream _stream;
    private object _sync;
    private int _timeout;
    private Dictionary`2<int, bool> _timeoutCanceled;
    private Timer _timer;
    public bool IsClosed { get; }
    public bool IsSecure { get; }
    public IPEndPoint LocalEndPoint { get; }
    public IPEndPoint RemoteEndPoint { get; }
    public int Reuses { get; }
    public Stream Stream { get; }
    internal HttpConnection(Socket socket, EndPointListener listener);
    public bool get_IsClosed();
    public bool get_IsSecure();
    public IPEndPoint get_LocalEndPoint();
    public IPEndPoint get_RemoteEndPoint();
    public int get_Reuses();
    public Stream get_Stream();
    private void close();
    private void closeSocket();
    private void disposeRequestBuffer();
    private void disposeStream();
    private void disposeTimer();
    private void init();
    private static void onRead(IAsyncResult asyncResult);
    private static void onTimeout(object state);
    private bool processInput(Byte[] data, int length);
    private string readLineFrom(Byte[] buffer, int offset, int length, Int32& read);
    private void removeConnection();
    private void unregisterContext();
    internal void Close(bool force);
    public void BeginReadRequest();
    public void Close();
    public RequestStream GetRequestStream(long contentLength, bool chunked);
    public ResponseStream GetResponseStream();
    public void SendError();
    public void SendError(string message, int status);
}
public class WebSocketSharp.Net.HttpDigestIdentity : GenericIdentity {
    private NameValueCollection _parameters;
    public string Algorithm { get; }
    public string Cnonce { get; }
    public string Nc { get; }
    public string Nonce { get; }
    public string Opaque { get; }
    public string Qop { get; }
    public string Realm { get; }
    public string Response { get; }
    public string Uri { get; }
    internal HttpDigestIdentity(NameValueCollection parameters);
    public string get_Algorithm();
    public string get_Cnonce();
    public string get_Nc();
    public string get_Nonce();
    public string get_Opaque();
    public string get_Qop();
    public string get_Realm();
    public string get_Response();
    public string get_Uri();
    internal bool IsValid(string password, string realm, string method, string entity);
}
internal class WebSocketSharp.Net.HttpHeaderInfo : object {
    private string _name;
    private HttpHeaderType _type;
    internal bool IsMultiValueInRequest { get; }
    internal bool IsMultiValueInResponse { get; }
    public bool IsRequest { get; }
    public bool IsResponse { get; }
    public string Name { get; }
    public HttpHeaderType Type { get; }
    internal HttpHeaderInfo(string name, HttpHeaderType type);
    internal bool get_IsMultiValueInRequest();
    internal bool get_IsMultiValueInResponse();
    public bool get_IsRequest();
    public bool get_IsResponse();
    public string get_Name();
    public HttpHeaderType get_Type();
    public bool IsMultiValue(bool response);
    public bool IsRestricted(bool response);
}
[FlagsAttribute]
internal enum WebSocketSharp.Net.HttpHeaderType : Enum {
    public int value__;
    public static HttpHeaderType Unspecified;
    public static HttpHeaderType Request;
    public static HttpHeaderType Response;
    public static HttpHeaderType Restricted;
    public static HttpHeaderType MultiValue;
    public static HttpHeaderType MultiValueInRequest;
    public static HttpHeaderType MultiValueInResponse;
}
public class WebSocketSharp.Net.HttpListener : object {
    private AuthenticationSchemes _authSchemes;
    private Func`2<HttpListenerRequest, AuthenticationSchemes> _authSchemeSelector;
    private string _certFolderPath;
    private Dictionary`2<HttpConnection, HttpConnection> _connections;
    private object _connectionsSync;
    private List`1<HttpListenerContext> _ctxQueue;
    private object _ctxQueueSync;
    private Dictionary`2<HttpListenerContext, HttpListenerContext> _ctxRegistry;
    private object _ctxRegistrySync;
    private static string _defaultRealm;
    private bool _disposed;
    private bool _ignoreWriteExceptions;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _listening;
    private Logger _logger;
    private HttpListenerPrefixCollection _prefixes;
    private string _realm;
    private bool _reuseAddress;
    private ServerSslConfiguration _sslConfig;
    private Func`2<IIdentity, NetworkCredential> _userCredFinder;
    private List`1<HttpListenerAsyncResult> _waitQueue;
    private object _waitQueueSync;
    internal bool IsDisposed { get; }
    internal bool ReuseAddress { get; internal set; }
    public AuthenticationSchemes AuthenticationSchemes { get; public set; }
    public Func`2<HttpListenerRequest, AuthenticationSchemes> AuthenticationSchemeSelector { get; public set; }
    public string CertificateFolderPath { get; public set; }
    public bool IgnoreWriteExceptions { get; public set; }
    public bool IsListening { get; }
    public static bool IsSupported { get; }
    public Logger Log { get; }
    public HttpListenerPrefixCollection Prefixes { get; }
    public string Realm { get; public set; }
    public ServerSslConfiguration SslConfiguration { get; public set; }
    public bool UnsafeConnectionNtlmAuthentication { get; public set; }
    public Func`2<IIdentity, NetworkCredential> UserCredentialsFinder { get; public set; }
    private static HttpListener();
    internal bool get_IsDisposed();
    internal bool get_ReuseAddress();
    internal void set_ReuseAddress(bool value);
    public AuthenticationSchemes get_AuthenticationSchemes();
    public void set_AuthenticationSchemes(AuthenticationSchemes value);
    public Func`2<HttpListenerRequest, AuthenticationSchemes> get_AuthenticationSchemeSelector();
    public void set_AuthenticationSchemeSelector(Func`2<HttpListenerRequest, AuthenticationSchemes> value);
    public string get_CertificateFolderPath();
    public void set_CertificateFolderPath(string value);
    public bool get_IgnoreWriteExceptions();
    public void set_IgnoreWriteExceptions(bool value);
    public bool get_IsListening();
    public static bool get_IsSupported();
    public Logger get_Log();
    public HttpListenerPrefixCollection get_Prefixes();
    public string get_Realm();
    public void set_Realm(string value);
    public ServerSslConfiguration get_SslConfiguration();
    public void set_SslConfiguration(ServerSslConfiguration value);
    public bool get_UnsafeConnectionNtlmAuthentication();
    public void set_UnsafeConnectionNtlmAuthentication(bool value);
    public Func`2<IIdentity, NetworkCredential> get_UserCredentialsFinder();
    public void set_UserCredentialsFinder(Func`2<IIdentity, NetworkCredential> value);
    private void cleanupConnections();
    private void cleanupContextQueue(bool sendServiceUnavailable);
    private void cleanupContextRegistry();
    private void cleanupWaitQueue(Exception exception);
    private void close(bool force);
    private HttpListenerAsyncResult getAsyncResultFromQueue();
    private HttpListenerContext getContextFromQueue();
    internal bool AddConnection(HttpConnection connection);
    internal HttpListenerAsyncResult BeginGetContext(HttpListenerAsyncResult asyncResult);
    internal void CheckDisposed();
    internal string GetRealm();
    internal Func`2<IIdentity, NetworkCredential> GetUserCredentialsFinder();
    internal bool RegisterContext(HttpListenerContext context);
    internal void RemoveConnection(HttpConnection connection);
    internal AuthenticationSchemes SelectAuthenticationScheme(HttpListenerRequest request);
    internal void UnregisterContext(HttpListenerContext context);
    public void Abort();
    public IAsyncResult BeginGetContext(AsyncCallback callback, object state);
    public void Close();
    public HttpListenerContext EndGetContext(IAsyncResult asyncResult);
    public HttpListenerContext GetContext();
    public void Start();
    public void Stop();
    private sealed virtual override void System.IDisposable.Dispose();
}
internal class WebSocketSharp.Net.HttpListenerAsyncResult : object {
    private AsyncCallback _callback;
    private bool _completed;
    private HttpListenerContext _context;
    private bool _endCalled;
    private Exception _exception;
    private bool _inGet;
    private object _state;
    private object _sync;
    private bool _syncCompleted;
    private ManualResetEvent _waitHandle;
    internal bool EndCalled { get; internal set; }
    internal bool InGet { get; internal set; }
    public object AsyncState { get; }
    public WaitHandle AsyncWaitHandle { get; }
    public bool CompletedSynchronously { get; }
    public bool IsCompleted { get; }
    internal HttpListenerAsyncResult(AsyncCallback callback, object state);
    internal bool get_EndCalled();
    internal void set_EndCalled(bool value);
    internal bool get_InGet();
    internal void set_InGet(bool value);
    public sealed virtual object get_AsyncState();
    public sealed virtual WaitHandle get_AsyncWaitHandle();
    public sealed virtual bool get_CompletedSynchronously();
    public sealed virtual bool get_IsCompleted();
    private static void complete(HttpListenerAsyncResult asyncResult);
    internal void Complete(Exception exception);
    internal void Complete(HttpListenerContext context);
    internal void Complete(HttpListenerContext context, bool syncCompleted);
    internal HttpListenerContext GetContext();
}
public class WebSocketSharp.Net.HttpListenerContext : object {
    private HttpConnection _connection;
    private string _error;
    private int _errorStatus;
    private HttpListener _listener;
    private HttpListenerRequest _request;
    private HttpListenerResponse _response;
    private IPrincipal _user;
    private HttpListenerWebSocketContext _websocketContext;
    internal HttpConnection Connection { get; }
    internal string ErrorMessage { get; internal set; }
    internal int ErrorStatus { get; internal set; }
    internal bool HasError { get; }
    internal HttpListener Listener { get; internal set; }
    public HttpListenerRequest Request { get; }
    public HttpListenerResponse Response { get; }
    public IPrincipal User { get; }
    internal HttpListenerContext(HttpConnection connection);
    internal HttpConnection get_Connection();
    internal string get_ErrorMessage();
    internal void set_ErrorMessage(string value);
    internal int get_ErrorStatus();
    internal void set_ErrorStatus(int value);
    internal bool get_HasError();
    internal HttpListener get_Listener();
    internal void set_Listener(HttpListener value);
    public HttpListenerRequest get_Request();
    public HttpListenerResponse get_Response();
    public IPrincipal get_User();
    internal bool Authenticate();
    internal bool Register();
    internal void Unregister();
    public HttpListenerWebSocketContext AcceptWebSocket(string protocol);
}
public class WebSocketSharp.Net.HttpListenerException : Win32Exception {
    public int ErrorCode { get; }
    protected HttpListenerException(SerializationInfo serializationInfo, StreamingContext streamingContext);
    public HttpListenerException(int errorCode);
    public HttpListenerException(int errorCode, string message);
    public virtual int get_ErrorCode();
}
internal class WebSocketSharp.Net.HttpListenerPrefix : object {
    private string _host;
    private HttpListener _listener;
    private string _original;
    private string _path;
    private string _port;
    private string _prefix;
    private bool _secure;
    public string Host { get; }
    public bool IsSecure { get; }
    public HttpListener Listener { get; public set; }
    public string Original { get; }
    public string Path { get; }
    public string Port { get; }
    internal HttpListenerPrefix(string uriPrefix);
    public string get_Host();
    public bool get_IsSecure();
    public HttpListener get_Listener();
    public void set_Listener(HttpListener value);
    public string get_Original();
    public string get_Path();
    public string get_Port();
    private void parse(string uriPrefix);
    public static void CheckPrefix(string uriPrefix);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class WebSocketSharp.Net.HttpListenerPrefixCollection : object {
    private HttpListener _listener;
    private List`1<string> _prefixes;
    public int Count { get; }
    public bool IsReadOnly { get; }
    public bool IsSynchronized { get; }
    internal HttpListenerPrefixCollection(HttpListener listener);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public bool get_IsSynchronized();
    public sealed virtual void Add(string uriPrefix);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(string uriPrefix);
    public void CopyTo(Array array, int offset);
    public sealed virtual void CopyTo(String[] array, int offset);
    public sealed virtual IEnumerator`1<string> GetEnumerator();
    public sealed virtual bool Remove(string uriPrefix);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class WebSocketSharp.Net.HttpListenerRequest : object {
    private static Byte[] _100continue;
    private String[] _acceptTypes;
    private bool _chunked;
    private Encoding _contentEncoding;
    private long _contentLength;
    private bool _contentLengthSet;
    private HttpListenerContext _context;
    private CookieCollection _cookies;
    private WebHeaderCollection _headers;
    private Guid _identifier;
    private Stream _inputStream;
    private bool _keepAlive;
    private bool _keepAliveSet;
    private string _method;
    private NameValueCollection _queryString;
    private Uri _referer;
    private string _uri;
    private Uri _url;
    private String[] _userLanguages;
    private Version _version;
    private bool _websocketRequest;
    private bool _websocketRequestSet;
    public String[] AcceptTypes { get; }
    public int ClientCertificateError { get; }
    public Encoding ContentEncoding { get; }
    public long ContentLength64 { get; }
    public string ContentType { get; }
    public CookieCollection Cookies { get; }
    public bool HasEntityBody { get; }
    public NameValueCollection Headers { get; }
    public string HttpMethod { get; }
    public Stream InputStream { get; }
    public bool IsAuthenticated { get; }
    public bool IsLocal { get; }
    public bool IsSecureConnection { get; }
    public bool IsWebSocketRequest { get; }
    public bool KeepAlive { get; }
    public IPEndPoint LocalEndPoint { get; }
    public Version ProtocolVersion { get; }
    public NameValueCollection QueryString { get; }
    public string RawUrl { get; }
    public IPEndPoint RemoteEndPoint { get; }
    public Guid RequestTraceIdentifier { get; }
    public Uri Url { get; }
    public Uri UrlReferrer { get; }
    public string UserAgent { get; }
    public string UserHostAddress { get; }
    public string UserHostName { get; }
    public String[] UserLanguages { get; }
    private static HttpListenerRequest();
    internal HttpListenerRequest(HttpListenerContext context);
    public String[] get_AcceptTypes();
    public int get_ClientCertificateError();
    public Encoding get_ContentEncoding();
    public long get_ContentLength64();
    public string get_ContentType();
    public CookieCollection get_Cookies();
    public bool get_HasEntityBody();
    public NameValueCollection get_Headers();
    public string get_HttpMethod();
    public Stream get_InputStream();
    public bool get_IsAuthenticated();
    public bool get_IsLocal();
    public bool get_IsSecureConnection();
    public bool get_IsWebSocketRequest();
    public bool get_KeepAlive();
    public IPEndPoint get_LocalEndPoint();
    public Version get_ProtocolVersion();
    public NameValueCollection get_QueryString();
    public string get_RawUrl();
    public IPEndPoint get_RemoteEndPoint();
    public Guid get_RequestTraceIdentifier();
    public Uri get_Url();
    public Uri get_UrlReferrer();
    public string get_UserAgent();
    public string get_UserHostAddress();
    public string get_UserHostName();
    public String[] get_UserLanguages();
    private static bool tryCreateVersion(string version, Version& result);
    internal void AddHeader(string header);
    internal void FinishInitialization();
    internal bool FlushInput();
    internal void SetRequestLine(string requestLine);
    public IAsyncResult BeginGetClientCertificate(AsyncCallback requestCallback, object state);
    public X509Certificate2 EndGetClientCertificate(IAsyncResult asyncResult);
    public X509Certificate2 GetClientCertificate();
    public virtual string ToString();
}
public class WebSocketSharp.Net.HttpListenerResponse : object {
    private bool _closeConnection;
    private Encoding _contentEncoding;
    private long _contentLength;
    private string _contentType;
    private HttpListenerContext _context;
    private CookieCollection _cookies;
    private bool _disposed;
    private WebHeaderCollection _headers;
    private bool _headersSent;
    private bool _keepAlive;
    private string _location;
    private ResponseStream _outputStream;
    private bool _sendChunked;
    private int _statusCode;
    private string _statusDescription;
    private Version _version;
    internal bool CloseConnection { get; internal set; }
    internal bool HeadersSent { get; internal set; }
    public Encoding ContentEncoding { get; public set; }
    public long ContentLength64 { get; public set; }
    public string ContentType { get; public set; }
    public CookieCollection Cookies { get; public set; }
    public WebHeaderCollection Headers { get; public set; }
    public bool KeepAlive { get; public set; }
    public Stream OutputStream { get; }
    public Version ProtocolVersion { get; public set; }
    public string RedirectLocation { get; public set; }
    public bool SendChunked { get; public set; }
    public int StatusCode { get; public set; }
    public string StatusDescription { get; public set; }
    internal HttpListenerResponse(HttpListenerContext context);
    internal bool get_CloseConnection();
    internal void set_CloseConnection(bool value);
    internal bool get_HeadersSent();
    internal void set_HeadersSent(bool value);
    public Encoding get_ContentEncoding();
    public void set_ContentEncoding(Encoding value);
    public long get_ContentLength64();
    public void set_ContentLength64(long value);
    public string get_ContentType();
    public void set_ContentType(string value);
    public CookieCollection get_Cookies();
    public void set_Cookies(CookieCollection value);
    public WebHeaderCollection get_Headers();
    public void set_Headers(WebHeaderCollection value);
    public bool get_KeepAlive();
    public void set_KeepAlive(bool value);
    public Stream get_OutputStream();
    public Version get_ProtocolVersion();
    public void set_ProtocolVersion(Version value);
    public string get_RedirectLocation();
    public void set_RedirectLocation(string value);
    public bool get_SendChunked();
    public void set_SendChunked(bool value);
    public int get_StatusCode();
    public void set_StatusCode(int value);
    public string get_StatusDescription();
    public void set_StatusDescription(string value);
    private bool canAddOrUpdate(Cookie cookie);
    private void checkDisposed();
    private void checkDisposedOrHeadersSent();
    private void close(bool force);
    private IEnumerable`1<Cookie> findCookie(Cookie cookie);
    internal WebHeaderCollection WriteHeadersTo(MemoryStream destination);
    public void Abort();
    public void AddHeader(string name, string value);
    public void AppendCookie(Cookie cookie);
    public void AppendHeader(string name, string value);
    public void Close();
    public void Close(Byte[] responseEntity, bool willBlock);
    public void CopyFrom(HttpListenerResponse templateResponse);
    public void Redirect(string url);
    public void SetCookie(Cookie cookie);
    private sealed virtual override void System.IDisposable.Dispose();
}
public enum WebSocketSharp.Net.HttpRequestHeader : Enum {
    public int value__;
    public static HttpRequestHeader CacheControl;
    public static HttpRequestHeader Connection;
    public static HttpRequestHeader Date;
    public static HttpRequestHeader KeepAlive;
    public static HttpRequestHeader Pragma;
    public static HttpRequestHeader Trailer;
    public static HttpRequestHeader TransferEncoding;
    public static HttpRequestHeader Upgrade;
    public static HttpRequestHeader Via;
    public static HttpRequestHeader Warning;
    public static HttpRequestHeader Allow;
    public static HttpRequestHeader ContentLength;
    public static HttpRequestHeader ContentType;
    public static HttpRequestHeader ContentEncoding;
    public static HttpRequestHeader ContentLanguage;
    public static HttpRequestHeader ContentLocation;
    public static HttpRequestHeader ContentMd5;
    public static HttpRequestHeader ContentRange;
    public static HttpRequestHeader Expires;
    public static HttpRequestHeader LastModified;
    public static HttpRequestHeader Accept;
    public static HttpRequestHeader AcceptCharset;
    public static HttpRequestHeader AcceptEncoding;
    public static HttpRequestHeader AcceptLanguage;
    public static HttpRequestHeader Authorization;
    public static HttpRequestHeader Cookie;
    public static HttpRequestHeader Expect;
    public static HttpRequestHeader From;
    public static HttpRequestHeader Host;
    public static HttpRequestHeader IfMatch;
    public static HttpRequestHeader IfModifiedSince;
    public static HttpRequestHeader IfNoneMatch;
    public static HttpRequestHeader IfRange;
    public static HttpRequestHeader IfUnmodifiedSince;
    public static HttpRequestHeader MaxForwards;
    public static HttpRequestHeader ProxyAuthorization;
    public static HttpRequestHeader Referer;
    public static HttpRequestHeader Range;
    public static HttpRequestHeader Te;
    public static HttpRequestHeader Translate;
    public static HttpRequestHeader UserAgent;
    public static HttpRequestHeader SecWebSocketKey;
    public static HttpRequestHeader SecWebSocketExtensions;
    public static HttpRequestHeader SecWebSocketProtocol;
    public static HttpRequestHeader SecWebSocketVersion;
}
public enum WebSocketSharp.Net.HttpResponseHeader : Enum {
    public int value__;
    public static HttpResponseHeader CacheControl;
    public static HttpResponseHeader Connection;
    public static HttpResponseHeader Date;
    public static HttpResponseHeader KeepAlive;
    public static HttpResponseHeader Pragma;
    public static HttpResponseHeader Trailer;
    public static HttpResponseHeader TransferEncoding;
    public static HttpResponseHeader Upgrade;
    public static HttpResponseHeader Via;
    public static HttpResponseHeader Warning;
    public static HttpResponseHeader Allow;
    public static HttpResponseHeader ContentLength;
    public static HttpResponseHeader ContentType;
    public static HttpResponseHeader ContentEncoding;
    public static HttpResponseHeader ContentLanguage;
    public static HttpResponseHeader ContentLocation;
    public static HttpResponseHeader ContentMd5;
    public static HttpResponseHeader ContentRange;
    public static HttpResponseHeader Expires;
    public static HttpResponseHeader LastModified;
    public static HttpResponseHeader AcceptRanges;
    public static HttpResponseHeader Age;
    public static HttpResponseHeader ETag;
    public static HttpResponseHeader Location;
    public static HttpResponseHeader ProxyAuthenticate;
    public static HttpResponseHeader RetryAfter;
    public static HttpResponseHeader Server;
    public static HttpResponseHeader SetCookie;
    public static HttpResponseHeader Vary;
    public static HttpResponseHeader WwwAuthenticate;
    public static HttpResponseHeader SecWebSocketExtensions;
    public static HttpResponseHeader SecWebSocketAccept;
    public static HttpResponseHeader SecWebSocketProtocol;
    public static HttpResponseHeader SecWebSocketVersion;
}
public enum WebSocketSharp.Net.HttpStatusCode : Enum {
    public int value__;
    public static HttpStatusCode Continue;
    public static HttpStatusCode SwitchingProtocols;
    public static HttpStatusCode OK;
    public static HttpStatusCode Created;
    public static HttpStatusCode Accepted;
    public static HttpStatusCode NonAuthoritativeInformation;
    public static HttpStatusCode NoContent;
    public static HttpStatusCode ResetContent;
    public static HttpStatusCode PartialContent;
    public static HttpStatusCode MultipleChoices;
    public static HttpStatusCode Ambiguous;
    public static HttpStatusCode MovedPermanently;
    public static HttpStatusCode Moved;
    public static HttpStatusCode Found;
    public static HttpStatusCode Redirect;
    public static HttpStatusCode SeeOther;
    public static HttpStatusCode RedirectMethod;
    public static HttpStatusCode NotModified;
    public static HttpStatusCode UseProxy;
    public static HttpStatusCode Unused;
    public static HttpStatusCode TemporaryRedirect;
    public static HttpStatusCode RedirectKeepVerb;
    public static HttpStatusCode BadRequest;
    public static HttpStatusCode Unauthorized;
    public static HttpStatusCode PaymentRequired;
    public static HttpStatusCode Forbidden;
    public static HttpStatusCode NotFound;
    public static HttpStatusCode MethodNotAllowed;
    public static HttpStatusCode NotAcceptable;
    public static HttpStatusCode ProxyAuthenticationRequired;
    public static HttpStatusCode RequestTimeout;
    public static HttpStatusCode Conflict;
    public static HttpStatusCode Gone;
    public static HttpStatusCode LengthRequired;
    public static HttpStatusCode PreconditionFailed;
    public static HttpStatusCode RequestEntityTooLarge;
    public static HttpStatusCode RequestUriTooLong;
    public static HttpStatusCode UnsupportedMediaType;
    public static HttpStatusCode RequestedRangeNotSatisfiable;
    public static HttpStatusCode ExpectationFailed;
    public static HttpStatusCode InternalServerError;
    public static HttpStatusCode NotImplemented;
    public static HttpStatusCode BadGateway;
    public static HttpStatusCode ServiceUnavailable;
    public static HttpStatusCode GatewayTimeout;
    public static HttpStatusCode HttpVersionNotSupported;
}
internal class WebSocketSharp.Net.HttpStreamAsyncResult : object {
    private Byte[] _buffer;
    private AsyncCallback _callback;
    private bool _completed;
    private int _count;
    private Exception _exception;
    private int _offset;
    private object _state;
    private object _sync;
    private int _syncRead;
    private ManualResetEvent _waitHandle;
    internal Byte[] Buffer { get; internal set; }
    internal int Count { get; internal set; }
    internal Exception Exception { get; }
    internal bool HasException { get; }
    internal int Offset { get; internal set; }
    internal int SyncRead { get; internal set; }
    public object AsyncState { get; }
    public WaitHandle AsyncWaitHandle { get; }
    public bool CompletedSynchronously { get; }
    public bool IsCompleted { get; }
    internal HttpStreamAsyncResult(AsyncCallback callback, object state);
    internal Byte[] get_Buffer();
    internal void set_Buffer(Byte[] value);
    internal int get_Count();
    internal void set_Count(int value);
    internal Exception get_Exception();
    internal bool get_HasException();
    internal int get_Offset();
    internal void set_Offset(int value);
    internal int get_SyncRead();
    internal void set_SyncRead(int value);
    public sealed virtual object get_AsyncState();
    public sealed virtual WaitHandle get_AsyncWaitHandle();
    public sealed virtual bool get_CompletedSynchronously();
    public sealed virtual bool get_IsCompleted();
    internal void Complete();
    internal void Complete(Exception exception);
    [CompilerGeneratedAttribute]
private void <Complete>b__35_0(IAsyncResult ar);
}
internal class WebSocketSharp.Net.HttpUtility : object {
    private static Dictionary`2<string, char> _entities;
    private static Char[] _hexChars;
    private static object _sync;
    private static HttpUtility();
    private static int getChar(Byte[] bytes, int offset, int length);
    private static int getChar(string s, int offset, int length);
    private static Char[] getChars(MemoryStream buffer, Encoding encoding);
    private static Dictionary`2<string, char> getEntities();
    private static int getInt(byte b);
    private static void initEntities();
    private static bool notEncoded(char c);
    private static void urlEncode(char c, Stream result, bool unicode);
    private static void urlPathEncode(char c, Stream result);
    private static void writeCharBytes(char c, IList buffer, Encoding encoding);
    internal static Uri CreateRequestUrl(string requestUri, string host, bool websocketRequest, bool secure);
    internal static IPrincipal CreateUser(string response, AuthenticationSchemes scheme, string realm, string method, Func`2<IIdentity, NetworkCredential> credentialsFinder);
    internal static Encoding GetEncoding(string contentType);
    internal static NameValueCollection InternalParseQueryString(string query, Encoding encoding);
    internal static string InternalUrlDecode(Byte[] bytes, int offset, int count, Encoding encoding);
    internal static Byte[] InternalUrlDecodeToBytes(Byte[] bytes, int offset, int count);
    internal static Byte[] InternalUrlEncodeToBytes(Byte[] bytes, int offset, int count);
    internal static Byte[] InternalUrlEncodeUnicodeToBytes(string s);
    public static string HtmlAttributeEncode(string s);
    public static void HtmlAttributeEncode(string s, TextWriter output);
    public static string HtmlDecode(string s);
    public static void HtmlDecode(string s, TextWriter output);
    public static string HtmlEncode(string s);
    public static void HtmlEncode(string s, TextWriter output);
    public static NameValueCollection ParseQueryString(string query);
    public static NameValueCollection ParseQueryString(string query, Encoding encoding);
    public static string UrlDecode(string s);
    public static string UrlDecode(string s, Encoding encoding);
    public static string UrlDecode(Byte[] bytes, Encoding encoding);
    public static string UrlDecode(Byte[] bytes, int offset, int count, Encoding encoding);
    public static Byte[] UrlDecodeToBytes(Byte[] bytes);
    public static Byte[] UrlDecodeToBytes(string s);
    public static Byte[] UrlDecodeToBytes(string s, Encoding encoding);
    public static Byte[] UrlDecodeToBytes(Byte[] bytes, int offset, int count);
    public static string UrlEncode(Byte[] bytes);
    public static string UrlEncode(string s);
    public static string UrlEncode(string s, Encoding encoding);
    public static string UrlEncode(Byte[] bytes, int offset, int count);
    public static Byte[] UrlEncodeToBytes(Byte[] bytes);
    public static Byte[] UrlEncodeToBytes(string s);
    public static Byte[] UrlEncodeToBytes(string s, Encoding encoding);
    public static Byte[] UrlEncodeToBytes(Byte[] bytes, int offset, int count);
    public static string UrlEncodeUnicode(string s);
    public static Byte[] UrlEncodeUnicodeToBytes(string s);
    public static string UrlPathEncode(string s);
}
public class WebSocketSharp.Net.HttpVersion : object {
    public static Version Version10;
    public static Version Version11;
    private static HttpVersion();
}
internal enum WebSocketSharp.Net.InputChunkState : Enum {
    public int value__;
    public static InputChunkState None;
    public static InputChunkState Data;
    public static InputChunkState DataEnded;
    public static InputChunkState Trailer;
    public static InputChunkState End;
}
internal enum WebSocketSharp.Net.InputState : Enum {
    public int value__;
    public static InputState RequestLine;
    public static InputState Headers;
}
internal enum WebSocketSharp.Net.LineState : Enum {
    public int value__;
    public static LineState None;
    public static LineState Cr;
    public static LineState Lf;
}
public class WebSocketSharp.Net.NetworkCredential : object {
    private string _domain;
    private string _password;
    private String[] _roles;
    private string _userName;
    public string Domain { get; internal set; }
    public string Password { get; internal set; }
    public String[] Roles { get; internal set; }
    public string UserName { get; internal set; }
    public NetworkCredential(string userName, string password);
    public NetworkCredential(string userName, string password, string domain, String[] roles);
    public string get_Domain();
    internal void set_Domain(string value);
    public string get_Password();
    internal void set_Password(string value);
    public String[] get_Roles();
    internal void set_Roles(String[] value);
    public string get_UserName();
    internal void set_UserName(string value);
}
internal class WebSocketSharp.Net.QueryStringCollection : NameValueCollection {
    public virtual string ToString();
}
internal class WebSocketSharp.Net.ReadBufferState : object {
    private HttpStreamAsyncResult _asyncResult;
    private Byte[] _buffer;
    private int _count;
    private int _initialCount;
    private int _offset;
    public HttpStreamAsyncResult AsyncResult { get; public set; }
    public Byte[] Buffer { get; public set; }
    public int Count { get; public set; }
    public int InitialCount { get; public set; }
    public int Offset { get; public set; }
    public ReadBufferState(Byte[] buffer, int offset, int count, HttpStreamAsyncResult asyncResult);
    public HttpStreamAsyncResult get_AsyncResult();
    public void set_AsyncResult(HttpStreamAsyncResult value);
    public Byte[] get_Buffer();
    public void set_Buffer(Byte[] value);
    public int get_Count();
    public void set_Count(int value);
    public int get_InitialCount();
    public void set_InitialCount(int value);
    public int get_Offset();
    public void set_Offset(int value);
}
internal class WebSocketSharp.Net.RequestStream : Stream {
    private long _bodyLeft;
    private Byte[] _buffer;
    private int _count;
    private bool _disposed;
    private int _offset;
    private Stream _stream;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    internal RequestStream(Stream stream, Byte[] buffer, int offset, int count);
    internal RequestStream(Stream stream, Byte[] buffer, int offset, int count, long contentLength);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    private int fillFromBuffer(Byte[] buffer, int offset, int count);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual void Close();
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual void EndWrite(IAsyncResult asyncResult);
    public virtual void Flush();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
}
internal class WebSocketSharp.Net.ResponseStream : Stream {
    private MemoryStream _body;
    private static Byte[] _crlf;
    private bool _disposed;
    private HttpListenerResponse _response;
    private bool _sendChunked;
    private Stream _stream;
    private Action`3<Byte[], int, int> _write;
    private Action`3<Byte[], int, int> _writeBody;
    private Action`3<Byte[], int, int> _writeChunked;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    internal ResponseStream(Stream stream, HttpListenerResponse response, bool ignoreWriteExceptions);
    private static ResponseStream();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    private bool flush(bool closing);
    private void flushBody(bool closing);
    private bool flushHeaders(bool closing);
    private static Byte[] getChunkSizeBytes(int size, bool final);
    private void writeChunked(Byte[] buffer, int offset, int count);
    private void writeChunkedWithoutThrowingException(Byte[] buffer, int offset, int count);
    private void writeWithoutThrowingException(Byte[] buffer, int offset, int count);
    internal void Close(bool force);
    internal void InternalWrite(Byte[] buffer, int offset, int count);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual void Close();
    protected virtual void Dispose(bool disposing);
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual void EndWrite(IAsyncResult asyncResult);
    public virtual void Flush();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
}
public class WebSocketSharp.Net.ServerSslConfiguration : SslConfiguration {
    private X509Certificate2 _cert;
    private bool _clientCertRequired;
    public bool ClientCertificateRequired { get; public set; }
    public RemoteCertificateValidationCallback ClientCertificateValidationCallback { get; public set; }
    public X509Certificate2 ServerCertificate { get; public set; }
    public ServerSslConfiguration(X509Certificate2 serverCertificate);
    public ServerSslConfiguration(X509Certificate2 serverCertificate, bool clientCertificateRequired, SslProtocols enabledSslProtocols, bool checkCertificateRevocation);
    public bool get_ClientCertificateRequired();
    public void set_ClientCertificateRequired(bool value);
    public RemoteCertificateValidationCallback get_ClientCertificateValidationCallback();
    public void set_ClientCertificateValidationCallback(RemoteCertificateValidationCallback value);
    public X509Certificate2 get_ServerCertificate();
    public void set_ServerCertificate(X509Certificate2 value);
}
public abstract class WebSocketSharp.Net.SslConfiguration : object {
    private LocalCertificateSelectionCallback _certSelectionCallback;
    private RemoteCertificateValidationCallback _certValidationCallback;
    private bool _checkCertRevocation;
    private SslProtocols _enabledProtocols;
    protected LocalCertificateSelectionCallback CertificateSelectionCallback { get; protected set; }
    protected RemoteCertificateValidationCallback CertificateValidationCallback { get; protected set; }
    public bool CheckCertificateRevocation { get; public set; }
    public SslProtocols EnabledSslProtocols { get; public set; }
    protected SslConfiguration(SslProtocols enabledSslProtocols, bool checkCertificateRevocation);
    protected LocalCertificateSelectionCallback get_CertificateSelectionCallback();
    protected void set_CertificateSelectionCallback(LocalCertificateSelectionCallback value);
    protected RemoteCertificateValidationCallback get_CertificateValidationCallback();
    protected void set_CertificateValidationCallback(RemoteCertificateValidationCallback value);
    public bool get_CheckCertificateRevocation();
    public void set_CheckCertificateRevocation(bool value);
    public SslProtocols get_EnabledSslProtocols();
    public void set_EnabledSslProtocols(SslProtocols value);
}
[ComVisibleAttribute("True")]
[DefaultMemberAttribute("Item")]
public class WebSocketSharp.Net.WebHeaderCollection : NameValueCollection {
    private static Dictionary`2<string, HttpHeaderInfo> _headers;
    private bool _internallyUsed;
    private HttpHeaderType _state;
    internal HttpHeaderType State { get; }
    public String[] AllKeys { get; }
    public int Count { get; }
    public string Item { get; public set; }
    public string Item { get; public set; }
    public KeysCollection Keys { get; }
    private static WebHeaderCollection();
    internal WebHeaderCollection(HttpHeaderType state, bool internallyUsed);
    protected WebHeaderCollection(SerializationInfo serializationInfo, StreamingContext streamingContext);
    internal HttpHeaderType get_State();
    public virtual String[] get_AllKeys();
    public virtual int get_Count();
    public string get_Item(HttpRequestHeader header);
    public void set_Item(HttpRequestHeader header, string value);
    public string get_Item(HttpResponseHeader header);
    public void set_Item(HttpResponseHeader header, string value);
    public virtual KeysCollection get_Keys();
    private void add(string name, string value, bool ignoreRestricted);
    private void addWithoutCheckingName(string name, string value);
    private void addWithoutCheckingNameAndRestricted(string name, string value);
    private static int checkColonSeparated(string header);
    private static HttpHeaderType checkHeaderType(string name);
    private static string checkName(string name);
    private void checkRestricted(string name);
    private void checkState(bool response);
    private static string checkValue(string value);
    private static string convert(string key);
    private void doWithCheckingState(Action`2<string, string> action, string name, string value, bool setState);
    private void doWithCheckingState(Action`2<string, string> action, string name, string value, bool response, bool setState);
    private void doWithoutCheckingName(Action`2<string, string> action, string name, string value);
    private static HttpHeaderInfo getHeaderInfo(string name);
    private static bool isRestricted(string name, bool response);
    private void removeWithoutCheckingName(string name, string unuse);
    private void setWithoutCheckingName(string name, string value);
    internal static string Convert(HttpRequestHeader header);
    internal static string Convert(HttpResponseHeader header);
    internal void InternalRemove(string name);
    internal void InternalSet(string header, bool response);
    internal void InternalSet(string name, string value, bool response);
    internal static bool IsHeaderName(string name);
    internal static bool IsHeaderValue(string value);
    internal static bool IsMultiValue(string headerName, bool response);
    internal string ToStringMultiValue(bool response);
    protected void AddWithoutValidate(string headerName, string headerValue);
    public void Add(string header);
    public void Add(HttpRequestHeader header, string value);
    public void Add(HttpResponseHeader header, string value);
    public virtual void Add(string name, string value);
    public virtual void Clear();
    public virtual string Get(int index);
    public virtual string Get(string name);
    public virtual IEnumerator GetEnumerator();
    public virtual string GetKey(int index);
    public virtual String[] GetValues(int index);
    public virtual String[] GetValues(string header);
    public virtual void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
    public static bool IsRestricted(string headerName);
    public static bool IsRestricted(string headerName, bool response);
    public virtual void OnDeserialization(object sender);
    public void Remove(HttpRequestHeader header);
    public void Remove(HttpResponseHeader header);
    public virtual void Remove(string name);
    public void Set(HttpRequestHeader header, string value);
    public void Set(HttpResponseHeader header, string value);
    public virtual void Set(string name, string value);
    public Byte[] ToByteArray();
    public virtual string ToString();
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
}
public class WebSocketSharp.Net.WebSockets.HttpListenerWebSocketContext : WebSocketContext {
    private HttpListenerContext _context;
    private WebSocket _websocket;
    internal Logger Log { get; }
    internal Stream Stream { get; }
    public CookieCollection CookieCollection { get; }
    public NameValueCollection Headers { get; }
    public string Host { get; }
    public bool IsAuthenticated { get; }
    public bool IsLocal { get; }
    public bool IsSecureConnection { get; }
    public bool IsWebSocketRequest { get; }
    public string Origin { get; }
    public NameValueCollection QueryString { get; }
    public Uri RequestUri { get; }
    public string SecWebSocketKey { get; }
    public IEnumerable`1<string> SecWebSocketProtocols { get; }
    public string SecWebSocketVersion { get; }
    public IPEndPoint ServerEndPoint { get; }
    public IPrincipal User { get; }
    public IPEndPoint UserEndPoint { get; }
    public WebSocket WebSocket { get; }
    internal HttpListenerWebSocketContext(HttpListenerContext context, string protocol);
    internal Logger get_Log();
    internal Stream get_Stream();
    public virtual CookieCollection get_CookieCollection();
    public virtual NameValueCollection get_Headers();
    public virtual string get_Host();
    public virtual bool get_IsAuthenticated();
    public virtual bool get_IsLocal();
    public virtual bool get_IsSecureConnection();
    public virtual bool get_IsWebSocketRequest();
    public virtual string get_Origin();
    public virtual NameValueCollection get_QueryString();
    public virtual Uri get_RequestUri();
    public virtual string get_SecWebSocketKey();
    public virtual IEnumerable`1<string> get_SecWebSocketProtocols();
    public virtual string get_SecWebSocketVersion();
    public virtual IPEndPoint get_ServerEndPoint();
    public virtual IPrincipal get_User();
    public virtual IPEndPoint get_UserEndPoint();
    public virtual WebSocket get_WebSocket();
    internal void Close();
    internal void Close(HttpStatusCode code);
    public virtual string ToString();
}
internal class WebSocketSharp.Net.WebSockets.TcpListenerWebSocketContext : WebSocketContext {
    private CookieCollection _cookies;
    private Logger _logger;
    private NameValueCollection _queryString;
    private HttpRequest _request;
    private bool _secure;
    private Stream _stream;
    private TcpClient _tcpClient;
    private Uri _uri;
    private IPrincipal _user;
    private WebSocket _websocket;
    internal Logger Log { get; }
    internal Stream Stream { get; }
    public CookieCollection CookieCollection { get; }
    public NameValueCollection Headers { get; }
    public string Host { get; }
    public bool IsAuthenticated { get; }
    public bool IsLocal { get; }
    public bool IsSecureConnection { get; }
    public bool IsWebSocketRequest { get; }
    public string Origin { get; }
    public NameValueCollection QueryString { get; }
    public Uri RequestUri { get; }
    public string SecWebSocketKey { get; }
    public IEnumerable`1<string> SecWebSocketProtocols { get; }
    public string SecWebSocketVersion { get; }
    public IPEndPoint ServerEndPoint { get; }
    public IPrincipal User { get; }
    public IPEndPoint UserEndPoint { get; }
    public WebSocket WebSocket { get; }
    internal TcpListenerWebSocketContext(TcpClient tcpClient, string protocol, bool secure, ServerSslConfiguration sslConfig, Logger logger);
    internal Logger get_Log();
    internal Stream get_Stream();
    public virtual CookieCollection get_CookieCollection();
    public virtual NameValueCollection get_Headers();
    public virtual string get_Host();
    public virtual bool get_IsAuthenticated();
    public virtual bool get_IsLocal();
    public virtual bool get_IsSecureConnection();
    public virtual bool get_IsWebSocketRequest();
    public virtual string get_Origin();
    public virtual NameValueCollection get_QueryString();
    public virtual Uri get_RequestUri();
    public virtual string get_SecWebSocketKey();
    public virtual IEnumerable`1<string> get_SecWebSocketProtocols();
    public virtual string get_SecWebSocketVersion();
    public virtual IPEndPoint get_ServerEndPoint();
    public virtual IPrincipal get_User();
    public virtual IPEndPoint get_UserEndPoint();
    public virtual WebSocket get_WebSocket();
    internal bool Authenticate(AuthenticationSchemes scheme, string realm, Func`2<IIdentity, NetworkCredential> credentialsFinder);
    internal void Close();
    internal void Close(HttpStatusCode code);
    internal void SendAuthenticationChallenge(string challenge);
    public virtual string ToString();
}
public abstract class WebSocketSharp.Net.WebSockets.WebSocketContext : object {
    public CookieCollection CookieCollection { get; }
    public NameValueCollection Headers { get; }
    public string Host { get; }
    public bool IsAuthenticated { get; }
    public bool IsLocal { get; }
    public bool IsSecureConnection { get; }
    public bool IsWebSocketRequest { get; }
    public string Origin { get; }
    public NameValueCollection QueryString { get; }
    public Uri RequestUri { get; }
    public string SecWebSocketKey { get; }
    public IEnumerable`1<string> SecWebSocketProtocols { get; }
    public string SecWebSocketVersion { get; }
    public IPEndPoint ServerEndPoint { get; }
    public IPrincipal User { get; }
    public IPEndPoint UserEndPoint { get; }
    public WebSocket WebSocket { get; }
    public abstract virtual CookieCollection get_CookieCollection();
    public abstract virtual NameValueCollection get_Headers();
    public abstract virtual string get_Host();
    public abstract virtual bool get_IsAuthenticated();
    public abstract virtual bool get_IsLocal();
    public abstract virtual bool get_IsSecureConnection();
    public abstract virtual bool get_IsWebSocketRequest();
    public abstract virtual string get_Origin();
    public abstract virtual NameValueCollection get_QueryString();
    public abstract virtual Uri get_RequestUri();
    public abstract virtual string get_SecWebSocketKey();
    public abstract virtual IEnumerable`1<string> get_SecWebSocketProtocols();
    public abstract virtual string get_SecWebSocketVersion();
    public abstract virtual IPEndPoint get_ServerEndPoint();
    public abstract virtual IPrincipal get_User();
    public abstract virtual IPEndPoint get_UserEndPoint();
    public abstract virtual WebSocket get_WebSocket();
}
public enum WebSocketSharp.Opcode : Enum {
    public byte value__;
    public static Opcode Cont;
    public static Opcode Text;
    public static Opcode Binary;
    public static Opcode Close;
    public static Opcode Ping;
    public static Opcode Pong;
}
internal class WebSocketSharp.PayloadData : object {
    private ushort _code;
    private bool _codeSet;
    private Byte[] _data;
    private long _extDataLength;
    private long _length;
    private string _reason;
    private bool _reasonSet;
    public static PayloadData Empty;
    public static ulong MaxLength;
    internal ushort Code { get; }
    internal long ExtensionDataLength { get; internal set; }
    internal bool HasReservedCode { get; }
    internal string Reason { get; }
    public Byte[] ApplicationData { get; }
    public Byte[] ExtensionData { get; }
    public ulong Length { get; }
    private static PayloadData();
    internal PayloadData(Byte[] data);
    internal PayloadData(Byte[] data, long length);
    internal PayloadData(ushort code, string reason);
    internal ushort get_Code();
    internal long get_ExtensionDataLength();
    internal void set_ExtensionDataLength(long value);
    internal bool get_HasReservedCode();
    internal string get_Reason();
    public Byte[] get_ApplicationData();
    public Byte[] get_ExtensionData();
    public ulong get_Length();
    internal void Mask(Byte[] key);
    public sealed virtual IEnumerator`1<byte> GetEnumerator();
    public Byte[] ToArray();
    public virtual string ToString();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal enum WebSocketSharp.Rsv : Enum {
    public byte value__;
    public static Rsv Off;
    public static Rsv On;
}
public class WebSocketSharp.Server.HttpRequestEventArgs : EventArgs {
    private HttpListenerRequest _request;
    private HttpListenerResponse _response;
    public HttpListenerRequest Request { get; }
    public HttpListenerResponse Response { get; }
    internal HttpRequestEventArgs(HttpListenerContext context);
    public HttpListenerRequest get_Request();
    public HttpListenerResponse get_Response();
}
public class WebSocketSharp.Server.HttpServer : object {
    private IPAddress _address;
    private string _hostname;
    private HttpListener _listener;
    private Logger _logger;
    private int _port;
    private Thread _receiveThread;
    private string _rootPath;
    private bool _secure;
    private WebSocketServiceManager _services;
    private ServerState modreq(System.Runtime.CompilerServices.IsVolatile) _state;
    private object _sync;
    private bool _windows;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
private EventHandler`1<HttpRequestEventArgs> OnConnect;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
private EventHandler`1<HttpRequestEventArgs> OnDelete;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private EventHandler`1<HttpRequestEventArgs> OnGet;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private EventHandler`1<HttpRequestEventArgs> OnHead;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private EventHandler`1<HttpRequestEventArgs> OnOptions;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private EventHandler`1<HttpRequestEventArgs> OnPatch;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private EventHandler`1<HttpRequestEventArgs> OnPost;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
private EventHandler`1<HttpRequestEventArgs> OnPut;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private EventHandler`1<HttpRequestEventArgs> OnTrace;
    public IPAddress Address { get; }
    public AuthenticationSchemes AuthenticationSchemes { get; public set; }
    public bool IsListening { get; }
    public bool IsSecure { get; }
    public bool KeepClean { get; public set; }
    public Logger Log { get; }
    public int Port { get; }
    public string Realm { get; public set; }
    public bool ReuseAddress { get; public set; }
    public string RootPath { get; public set; }
    public ServerSslConfiguration SslConfiguration { get; public set; }
    public Func`2<IIdentity, NetworkCredential> UserCredentialsFinder { get; public set; }
    public TimeSpan WaitTime { get; public set; }
    public WebSocketServiceManager WebSocketServices { get; }
    public HttpServer(int port);
    public HttpServer(string url);
    public HttpServer(int port, bool secure);
    public HttpServer(IPAddress address, int port);
    public HttpServer(IPAddress address, int port, bool secure);
    public IPAddress get_Address();
    public AuthenticationSchemes get_AuthenticationSchemes();
    public void set_AuthenticationSchemes(AuthenticationSchemes value);
    public bool get_IsListening();
    public bool get_IsSecure();
    public bool get_KeepClean();
    public void set_KeepClean(bool value);
    public Logger get_Log();
    public int get_Port();
    public string get_Realm();
    public void set_Realm(string value);
    public bool get_ReuseAddress();
    public void set_ReuseAddress(bool value);
    public string get_RootPath();
    public void set_RootPath(string value);
    public ServerSslConfiguration get_SslConfiguration();
    public void set_SslConfiguration(ServerSslConfiguration value);
    public Func`2<IIdentity, NetworkCredential> get_UserCredentialsFinder();
    public void set_UserCredentialsFinder(Func`2<IIdentity, NetworkCredential> value);
    public TimeSpan get_WaitTime();
    public void set_WaitTime(TimeSpan value);
    public WebSocketServiceManager get_WebSocketServices();
    [CompilerGeneratedAttribute]
public void add_OnConnect(EventHandler`1<HttpRequestEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_OnConnect(EventHandler`1<HttpRequestEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_OnDelete(EventHandler`1<HttpRequestEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_OnDelete(EventHandler`1<HttpRequestEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_OnGet(EventHandler`1<HttpRequestEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_OnGet(EventHandler`1<HttpRequestEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_OnHead(EventHandler`1<HttpRequestEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_OnHead(EventHandler`1<HttpRequestEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_OnOptions(EventHandler`1<HttpRequestEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_OnOptions(EventHandler`1<HttpRequestEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_OnPatch(EventHandler`1<HttpRequestEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_OnPatch(EventHandler`1<HttpRequestEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_OnPost(EventHandler`1<HttpRequestEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_OnPost(EventHandler`1<HttpRequestEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_OnPut(EventHandler`1<HttpRequestEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_OnPut(EventHandler`1<HttpRequestEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_OnTrace(EventHandler`1<HttpRequestEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_OnTrace(EventHandler`1<HttpRequestEventArgs> value);
    private void abort();
    private bool checkIfAvailable(bool ready, bool start, bool shutting, bool stop, String& message);
    private string checkIfCertificateExists();
    private static string convertToString(IPAddress address);
    private static string getHost(Uri uri);
    private void init(string hostname, IPAddress address, int port, bool secure);
    private void processRequest(HttpListenerContext context);
    private void processRequest(HttpListenerWebSocketContext context);
    private void receiveRequest();
    private void startReceiving();
    private void stopReceiving(int millisecondsTimeout);
    private static bool tryCreateUri(string uriString, Uri& result, String& message);
    public void AddWebSocketService(string path, Func`1<TBehavior> initializer);
    public void AddWebSocketService(string path);
    public Byte[] GetFile(string path);
    public bool RemoveWebSocketService(string path);
    public void Start();
    public void Stop();
    public void Stop(ushort code, string reason);
    public void Stop(CloseStatusCode code, string reason);
}
public interface WebSocketSharp.Server.IWebSocketSession {
    public WebSocketContext Context { get; }
    public string ID { get; }
    public string Protocol { get; }
    public DateTime StartTime { get; }
    public WebSocketState State { get; }
    public abstract virtual WebSocketContext get_Context();
    public abstract virtual string get_ID();
    public abstract virtual string get_Protocol();
    public abstract virtual DateTime get_StartTime();
    public abstract virtual WebSocketState get_State();
}
internal enum WebSocketSharp.Server.ServerState : Enum {
    public int value__;
    public static ServerState Ready;
    public static ServerState Start;
    public static ServerState ShuttingDown;
    public static ServerState Stop;
}
public abstract class WebSocketSharp.Server.WebSocketBehavior : object {
    private WebSocketContext _context;
    private Func`3<CookieCollection, CookieCollection, bool> _cookiesValidator;
    private bool _emitOnPing;
    private string _id;
    private bool _ignoreExtensions;
    private Func`2<string, bool> _originValidator;
    private string _protocol;
    private WebSocketSessionManager _sessions;
    private DateTime _startTime;
    private WebSocket _websocket;
    protected Logger Log { get; }
    protected WebSocketSessionManager Sessions { get; }
    public WebSocketContext Context { get; }
    public Func`3<CookieCollection, CookieCollection, bool> CookiesValidator { get; public set; }
    public bool EmitOnPing { get; public set; }
    public string ID { get; }
    public bool IgnoreExtensions { get; public set; }
    public Func`2<string, bool> OriginValidator { get; public set; }
    public string Protocol { get; public set; }
    public DateTime StartTime { get; }
    public WebSocketState State { get; }
    protected Logger get_Log();
    protected WebSocketSessionManager get_Sessions();
    public sealed virtual WebSocketContext get_Context();
    public Func`3<CookieCollection, CookieCollection, bool> get_CookiesValidator();
    public void set_CookiesValidator(Func`3<CookieCollection, CookieCollection, bool> value);
    public bool get_EmitOnPing();
    public void set_EmitOnPing(bool value);
    public sealed virtual string get_ID();
    public bool get_IgnoreExtensions();
    public void set_IgnoreExtensions(bool value);
    public Func`2<string, bool> get_OriginValidator();
    public void set_OriginValidator(Func`2<string, bool> value);
    public sealed virtual string get_Protocol();
    public void set_Protocol(string value);
    public sealed virtual DateTime get_StartTime();
    public sealed virtual WebSocketState get_State();
    private string checkHandshakeRequest(WebSocketContext context);
    private void onClose(object sender, CloseEventArgs e);
    private void onError(object sender, ErrorEventArgs e);
    private void onMessage(object sender, MessageEventArgs e);
    private void onOpen(object sender, EventArgs e);
    internal void Start(WebSocketContext context, WebSocketSessionManager sessions);
    protected void Error(string message, Exception exception);
    protected virtual void OnClose(CloseEventArgs e);
    protected virtual void OnError(ErrorEventArgs e);
    protected virtual void OnMessage(MessageEventArgs e);
    protected virtual void OnOpen();
    protected void Send(Byte[] data);
    protected void Send(FileInfo file);
    protected void Send(string data);
    protected void SendAsync(Byte[] data, Action`1<bool> completed);
    protected void SendAsync(FileInfo file, Action`1<bool> completed);
    protected void SendAsync(string data, Action`1<bool> completed);
    protected void SendAsync(Stream stream, int length, Action`1<bool> completed);
}
public class WebSocketSharp.Server.WebSocketServer : object {
    private IPAddress _address;
    private AuthenticationSchemes _authSchemes;
    private static string _defaultRealm;
    private bool _dnsStyle;
    private string _hostname;
    private TcpListener _listener;
    private Logger _logger;
    private int _port;
    private string _realm;
    private Thread _receiveThread;
    private bool _reuseAddress;
    private bool _secure;
    private WebSocketServiceManager _services;
    private ServerSslConfiguration _sslConfig;
    private ServerState modreq(System.Runtime.CompilerServices.IsVolatile) _state;
    private object _sync;
    private Func`2<IIdentity, NetworkCredential> _userCredFinder;
    public IPAddress Address { get; }
    public AuthenticationSchemes AuthenticationSchemes { get; public set; }
    public bool IsListening { get; }
    public bool IsSecure { get; }
    public bool KeepClean { get; public set; }
    public Logger Log { get; }
    public int Port { get; }
    public string Realm { get; public set; }
    public bool ReuseAddress { get; public set; }
    public ServerSslConfiguration SslConfiguration { get; public set; }
    public Func`2<IIdentity, NetworkCredential> UserCredentialsFinder { get; public set; }
    public TimeSpan WaitTime { get; public set; }
    public WebSocketServiceManager WebSocketServices { get; }
    private static WebSocketServer();
    public WebSocketServer(int port);
    public WebSocketServer(string url);
    public WebSocketServer(int port, bool secure);
    public WebSocketServer(IPAddress address, int port);
    public WebSocketServer(IPAddress address, int port, bool secure);
    public IPAddress get_Address();
    public AuthenticationSchemes get_AuthenticationSchemes();
    public void set_AuthenticationSchemes(AuthenticationSchemes value);
    public bool get_IsListening();
    public bool get_IsSecure();
    public bool get_KeepClean();
    public void set_KeepClean(bool value);
    public Logger get_Log();
    public int get_Port();
    public string get_Realm();
    public void set_Realm(string value);
    public bool get_ReuseAddress();
    public void set_ReuseAddress(bool value);
    public ServerSslConfiguration get_SslConfiguration();
    public void set_SslConfiguration(ServerSslConfiguration value);
    public Func`2<IIdentity, NetworkCredential> get_UserCredentialsFinder();
    public void set_UserCredentialsFinder(Func`2<IIdentity, NetworkCredential> value);
    public TimeSpan get_WaitTime();
    public void set_WaitTime(TimeSpan value);
    public WebSocketServiceManager get_WebSocketServices();
    private void abort();
    private bool checkIfAvailable(bool ready, bool start, bool shutting, bool stop, String& message);
    private string checkIfCertificateExists();
    private string getRealm();
    private void init(string hostname, IPAddress address, int port, bool secure);
    private void processRequest(TcpListenerWebSocketContext context);
    private void receiveRequest();
    private void startReceiving();
    private void stopReceiving(int millisecondsTimeout);
    private static bool tryCreateUri(string uriString, Uri& result, String& message);
    public void AddWebSocketService(string path, Func`1<TBehavior> initializer);
    public void AddWebSocketService(string path);
    public bool RemoveWebSocketService(string path);
    public void Start();
    public void Stop();
    public void Stop(ushort code, string reason);
    public void Stop(CloseStatusCode code, string reason);
}
public abstract class WebSocketSharp.Server.WebSocketServiceHost : object {
    internal ServerState State { get; }
    public bool KeepClean { get; public set; }
    public string Path { get; }
    public WebSocketSessionManager Sessions { get; }
    public Type Type { get; }
    public TimeSpan WaitTime { get; public set; }
    internal ServerState get_State();
    public abstract virtual bool get_KeepClean();
    public abstract virtual void set_KeepClean(bool value);
    public abstract virtual string get_Path();
    public abstract virtual WebSocketSessionManager get_Sessions();
    public abstract virtual Type get_Type();
    public abstract virtual TimeSpan get_WaitTime();
    public abstract virtual void set_WaitTime(TimeSpan value);
    internal void Start();
    internal void StartSession(WebSocketContext context);
    internal void Stop(ushort code, string reason);
    protected abstract virtual WebSocketBehavior CreateSession();
}
internal class WebSocketSharp.Server.WebSocketServiceHost`1 : WebSocketServiceHost {
    private Func`1<TBehavior> _initializer;
    private Logger _logger;
    private string _path;
    private WebSocketSessionManager _sessions;
    public bool KeepClean { get; public set; }
    public string Path { get; }
    public WebSocketSessionManager Sessions { get; }
    public Type Type { get; }
    public TimeSpan WaitTime { get; public set; }
    internal WebSocketServiceHost`1(string path, Func`1<TBehavior> initializer, Logger logger);
    public virtual bool get_KeepClean();
    public virtual void set_KeepClean(bool value);
    public virtual string get_Path();
    public virtual WebSocketSessionManager get_Sessions();
    public virtual Type get_Type();
    public virtual TimeSpan get_WaitTime();
    public virtual void set_WaitTime(TimeSpan value);
    protected virtual WebSocketBehavior CreateSession();
}
[DefaultMemberAttribute("Item")]
public class WebSocketSharp.Server.WebSocketServiceManager : object {
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _clean;
    private Dictionary`2<string, WebSocketServiceHost> _hosts;
    private Logger _logger;
    private ServerState modreq(System.Runtime.CompilerServices.IsVolatile) _state;
    private object _sync;
    private TimeSpan _waitTime;
    public int Count { get; }
    public IEnumerable`1<WebSocketServiceHost> Hosts { get; }
    public WebSocketServiceHost Item { get; }
    public bool KeepClean { get; internal set; }
    public IEnumerable`1<string> Paths { get; }
    public int SessionCount { get; }
    public TimeSpan WaitTime { get; internal set; }
    internal WebSocketServiceManager(Logger logger);
    public int get_Count();
    public IEnumerable`1<WebSocketServiceHost> get_Hosts();
    public WebSocketServiceHost get_Item(string path);
    public bool get_KeepClean();
    internal void set_KeepClean(bool value);
    public IEnumerable`1<string> get_Paths();
    public int get_SessionCount();
    public TimeSpan get_WaitTime();
    internal void set_WaitTime(TimeSpan value);
    private void broadcast(Opcode opcode, Byte[] data, Action completed);
    private void broadcast(Opcode opcode, Stream stream, Action completed);
    private void broadcastAsync(Opcode opcode, Byte[] data, Action completed);
    private void broadcastAsync(Opcode opcode, Stream stream, Action completed);
    private Dictionary`2<string, Dictionary`2<string, bool>> broadping(Byte[] frameAsBytes, TimeSpan timeout);
    internal void Add(string path, Func`1<TBehavior> initializer);
    internal bool InternalTryGetServiceHost(string path, WebSocketServiceHost& host);
    internal bool Remove(string path);
    internal void Start();
    internal void Stop(CloseEventArgs e, bool send, bool receive);
    public void Broadcast(Byte[] data);
    public void Broadcast(string data);
    public void BroadcastAsync(Byte[] data, Action completed);
    public void BroadcastAsync(string data, Action completed);
    public void BroadcastAsync(Stream stream, int length, Action completed);
    public Dictionary`2<string, Dictionary`2<string, bool>> Broadping();
    public Dictionary`2<string, Dictionary`2<string, bool>> Broadping(string message);
    public bool TryGetServiceHost(string path, WebSocketServiceHost& host);
    [CompilerGeneratedAttribute]
private void <BroadcastAsync>b__38_1(Exception ex);
}
[DefaultMemberAttribute("Item")]
public class WebSocketSharp.Server.WebSocketSessionManager : object {
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _clean;
    private object _forSweep;
    private Logger _logger;
    private Dictionary`2<string, IWebSocketSession> _sessions;
    private ServerState modreq(System.Runtime.CompilerServices.IsVolatile) _state;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _sweeping;
    private Timer _sweepTimer;
    private object _sync;
    private TimeSpan _waitTime;
    internal ServerState State { get; }
    public IEnumerable`1<string> ActiveIDs { get; }
    public int Count { get; }
    public IEnumerable`1<string> IDs { get; }
    public IEnumerable`1<string> InactiveIDs { get; }
    public IWebSocketSession Item { get; }
    public bool KeepClean { get; internal set; }
    public IEnumerable`1<IWebSocketSession> Sessions { get; }
    public TimeSpan WaitTime { get; internal set; }
    internal WebSocketSessionManager(Logger logger);
    internal ServerState get_State();
    public IEnumerable`1<string> get_ActiveIDs();
    public int get_Count();
    public IEnumerable`1<string> get_IDs();
    public IEnumerable`1<string> get_InactiveIDs();
    public IWebSocketSession get_Item(string id);
    public bool get_KeepClean();
    internal void set_KeepClean(bool value);
    public IEnumerable`1<IWebSocketSession> get_Sessions();
    public TimeSpan get_WaitTime();
    internal void set_WaitTime(TimeSpan value);
    private void broadcast(Opcode opcode, Byte[] data, Action completed);
    private void broadcast(Opcode opcode, Stream stream, Action completed);
    private void broadcastAsync(Opcode opcode, Byte[] data, Action completed);
    private void broadcastAsync(Opcode opcode, Stream stream, Action completed);
    private static string createID();
    private void setSweepTimer(double interval);
    private bool tryGetSession(string id, IWebSocketSession& session);
    internal string Add(IWebSocketSession session);
    internal void Broadcast(Opcode opcode, Byte[] data, Dictionary`2<CompressionMethod, Byte[]> cache);
    internal void Broadcast(Opcode opcode, Stream stream, Dictionary`2<CompressionMethod, Stream> cache);
    internal Dictionary`2<string, bool> Broadping(Byte[] frameAsBytes, TimeSpan timeout);
    internal bool Remove(string id);
    internal void Start();
    internal void Stop(CloseEventArgs e, Byte[] frameAsBytes, bool receive);
    public void Broadcast(Byte[] data);
    public void Broadcast(string data);
    public void BroadcastAsync(Byte[] data, Action completed);
    public void BroadcastAsync(string data, Action completed);
    public void BroadcastAsync(Stream stream, int length, Action completed);
    public Dictionary`2<string, bool> Broadping();
    public Dictionary`2<string, bool> Broadping(string message);
    public void CloseSession(string id);
    public void CloseSession(string id, ushort code, string reason);
    public void CloseSession(string id, CloseStatusCode code, string reason);
    public bool PingTo(string id);
    public bool PingTo(string message, string id);
    public void SendTo(Byte[] data, string id);
    public void SendTo(string data, string id);
    public void SendToAsync(Byte[] data, string id, Action`1<bool> completed);
    public void SendToAsync(string data, string id, Action`1<bool> completed);
    public void SendToAsync(Stream stream, int length, string id, Action`1<bool> completed);
    public void Sweep();
    public bool TryGetSession(string id, IWebSocketSession& session);
    [CompilerGeneratedAttribute]
private void <setSweepTimer>b__36_0(object sender, ElapsedEventArgs e);
    [CompilerGeneratedAttribute]
private void <BroadcastAsync>b__49_1(Exception ex);
}
public class WebSocketSharp.WebSocket : object {
    private AuthenticationChallenge _authChallenge;
    private string _base64Key;
    private bool _client;
    private Action _closeContext;
    private CompressionMethod _compression;
    private WebSocketContext _context;
    private CookieCollection _cookies;
    private NetworkCredential _credentials;
    private bool _emitOnPing;
    private bool _enableRedirection;
    private AutoResetEvent _exitReceiving;
    private string _extensions;
    private bool _extensionsRequested;
    private object _forMessageEventQueue;
    private object _forSend;
    private object _forState;
    private MemoryStream _fragmentsBuffer;
    private bool _fragmentsCompressed;
    private Opcode _fragmentsOpcode;
    private static string _guid;
    private Func`2<WebSocketContext, string> _handshakeRequestChecker;
    private bool _ignoreExtensions;
    private bool _inContinuation;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _inMessage;
    private Logger modreq(System.Runtime.CompilerServices.IsVolatile) _logger;
    private Action`1<MessageEventArgs> _message;
    private Queue`1<MessageEventArgs> _messageEventQueue;
    private UInt32 _nonceCount;
    private string _origin;
    private bool _preAuth;
    private string _protocol;
    private String[] _protocols;
    private bool _protocolsRequested;
    private NetworkCredential _proxyCredentials;
    private Uri _proxyUri;
    private WebSocketState modreq(System.Runtime.CompilerServices.IsVolatile) _readyState;
    private AutoResetEvent _receivePong;
    private bool _secure;
    private ClientSslConfiguration _sslConfig;
    private Stream _stream;
    private TcpClient _tcpClient;
    private Uri _uri;
    private static string _version;
    private TimeSpan _waitTime;
    internal static Byte[] EmptyBytes;
    internal static int FragmentLength;
    internal static RandomNumberGenerator RandomNumber;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
private EventHandler`1<CloseEventArgs> OnClose;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
private EventHandler`1<ErrorEventArgs> OnError;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
private EventHandler`1<MessageEventArgs> OnMessage;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private EventHandler OnOpen;
    internal CookieCollection CookieCollection { get; }
    internal Func`2<WebSocketContext, string> CustomHandshakeRequestChecker { get; internal set; }
    internal bool HasMessage { get; }
    internal bool IgnoreExtensions { get; internal set; }
    internal bool IsConnected { get; }
    public CompressionMethod Compression { get; public set; }
    public IEnumerable`1<Cookie> Cookies { get; }
    public NetworkCredential Credentials { get; }
    public bool EmitOnPing { get; public set; }
    public bool EnableRedirection { get; public set; }
    public string Extensions { get; }
    public bool IsAlive { get; }
    public bool IsSecure { get; }
    public Logger Log { get; internal set; }
    public string Origin { get; public set; }
    public string Protocol { get; internal set; }
    public WebSocketState ReadyState { get; }
    public ClientSslConfiguration SslConfiguration { get; public set; }
    public Uri Url { get; }
    public TimeSpan WaitTime { get; public set; }
    private static WebSocket();
    internal WebSocket(HttpListenerWebSocketContext context, string protocol);
    internal WebSocket(TcpListenerWebSocketContext context, string protocol);
    public WebSocket(string url, String[] protocols);
    internal CookieCollection get_CookieCollection();
    internal Func`2<WebSocketContext, string> get_CustomHandshakeRequestChecker();
    internal void set_CustomHandshakeRequestChecker(Func`2<WebSocketContext, string> value);
    internal bool get_HasMessage();
    internal bool get_IgnoreExtensions();
    internal void set_IgnoreExtensions(bool value);
    internal bool get_IsConnected();
    public CompressionMethod get_Compression();
    public void set_Compression(CompressionMethod value);
    public IEnumerable`1<Cookie> get_Cookies();
    public NetworkCredential get_Credentials();
    public bool get_EmitOnPing();
    public void set_EmitOnPing(bool value);
    public bool get_EnableRedirection();
    public void set_EnableRedirection(bool value);
    public string get_Extensions();
    public bool get_IsAlive();
    public bool get_IsSecure();
    public Logger get_Log();
    internal void set_Log(Logger value);
    public string get_Origin();
    public void set_Origin(string value);
    public string get_Protocol();
    internal void set_Protocol(string value);
    public WebSocketState get_ReadyState();
    public ClientSslConfiguration get_SslConfiguration();
    public void set_SslConfiguration(ClientSslConfiguration value);
    public Uri get_Url();
    public TimeSpan get_WaitTime();
    public void set_WaitTime(TimeSpan value);
    [CompilerGeneratedAttribute]
public void add_OnClose(EventHandler`1<CloseEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_OnClose(EventHandler`1<CloseEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_OnError(EventHandler`1<ErrorEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_OnError(EventHandler`1<ErrorEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_OnMessage(EventHandler`1<MessageEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_OnMessage(EventHandler`1<MessageEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_OnOpen(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_OnOpen(EventHandler value);
    private bool accept();
    private bool acceptHandshake();
    private bool checkHandshakeRequest(WebSocketContext context, String& message);
    private bool checkHandshakeResponse(HttpResponse response, String& message);
    private bool checkIfAvailable(bool connecting, bool open, bool closing, bool closed, String& message);
    private bool checkIfAvailable(bool client, bool server, bool connecting, bool open, bool closing, bool closed, String& message);
    private static bool checkParametersForSetCredentials(string username, string password, String& message);
    private static bool checkParametersForSetProxy(string url, string username, string password, String& message);
    private bool checkReceivedFrame(WebSocketFrame frame, String& message);
    private void close(ushort code, string reason);
    private void close(CloseEventArgs e, bool send, bool receive, bool received);
    private void closeAsync(ushort code, string reason);
    private void closeAsync(CloseEventArgs e, bool send, bool receive, bool received);
    private bool closeHandshake(Byte[] frameAsBytes, bool receive, bool received);
    private bool connect();
    private string createExtensions();
    private HttpResponse createHandshakeFailureResponse(HttpStatusCode code);
    private HttpRequest createHandshakeRequest();
    private HttpResponse createHandshakeResponse();
    private bool customCheckHandshakeRequest(WebSocketContext context, String& message);
    private MessageEventArgs dequeueFromMessageEventQueue();
    private bool doHandshake();
    private void enqueueToMessageEventQueue(MessageEventArgs e);
    private void error(string message, Exception exception);
    private void fatal(string message, Exception exception);
    private void fatal(string message, CloseStatusCode code);
    private void init();
    private void message();
    private void messagec(MessageEventArgs e);
    private void messages(MessageEventArgs e);
    private void open();
    private bool processCloseFrame(WebSocketFrame frame);
    private void processCookies(CookieCollection cookies);
    private bool processDataFrame(WebSocketFrame frame);
    private bool processFragmentFrame(WebSocketFrame frame);
    private bool processPingFrame(WebSocketFrame frame);
    private bool processPongFrame(WebSocketFrame frame);
    private bool processReceivedFrame(WebSocketFrame frame);
    private void processSecWebSocketExtensionsClientHeader(string value);
    private void processSecWebSocketExtensionsServerHeader(string value);
    private void processSecWebSocketProtocolHeader(IEnumerable`1<string> values);
    private bool processUnsupportedFrame(WebSocketFrame frame);
    private void releaseClientResources();
    private void releaseCommonResources();
    private void releaseResources();
    private void releaseServerResources();
    private bool send(Byte[] frameAsBytes);
    private bool send(Opcode opcode, Stream stream);
    private bool send(Opcode opcode, Stream stream, bool compressed);
    private bool send(Fin fin, Opcode opcode, Byte[] data, bool compressed);
    private void sendAsync(Opcode opcode, Stream stream, Action`1<bool> completed);
    private bool sendBytes(Byte[] bytes);
    private HttpResponse sendHandshakeRequest();
    private HttpResponse sendHttpRequest(HttpRequest request, int millisecondsTimeout);
    private bool sendHttpResponse(HttpResponse response);
    private void sendProxyConnectRequest();
    private void setClientStream();
    private void startReceiving();
    private bool validateSecWebSocketAcceptHeader(string value);
    private bool validateSecWebSocketExtensionsClientHeader(string value);
    private bool validateSecWebSocketExtensionsServerHeader(string value);
    private bool validateSecWebSocketKeyHeader(string value);
    private bool validateSecWebSocketProtocolClientHeader(string value);
    private bool validateSecWebSocketProtocolServerHeader(string value);
    private bool validateSecWebSocketVersionClientHeader(string value);
    private bool validateSecWebSocketVersionServerHeader(string value);
    internal static bool CheckParametersForClose(ushort code, string reason, bool client, String& message);
    internal static bool CheckParametersForClose(CloseStatusCode code, string reason, bool client, String& message);
    internal static string CheckPingParameter(string message, Byte[]& bytes);
    internal static string CheckSendParameter(Byte[] data);
    internal static string CheckSendParameter(FileInfo file);
    internal static string CheckSendParameter(string data);
    internal static string CheckSendParameters(Stream stream, int length);
    internal void Close(HttpResponse response);
    internal void Close(HttpStatusCode code);
    internal void Close(CloseEventArgs e, Byte[] frameAsBytes, bool receive);
    internal static string CreateBase64Key();
    internal static string CreateResponseKey(string base64Key);
    internal void InternalAccept();
    internal bool Ping(Byte[] frameAsBytes, TimeSpan timeout);
    internal void Send(Opcode opcode, Byte[] data, Dictionary`2<CompressionMethod, Byte[]> cache);
    internal void Send(Opcode opcode, Stream stream, Dictionary`2<CompressionMethod, Stream> cache);
    public void Accept();
    public void AcceptAsync();
    public void Close();
    public void Close(ushort code);
    public void Close(CloseStatusCode code);
    public void Close(ushort code, string reason);
    public void Close(CloseStatusCode code, string reason);
    public void CloseAsync();
    public void CloseAsync(ushort code);
    public void CloseAsync(CloseStatusCode code);
    public void CloseAsync(ushort code, string reason);
    public void CloseAsync(CloseStatusCode code, string reason);
    public void Connect();
    public void ConnectAsync();
    public bool Ping();
    public bool Ping(string message);
    public void Send(Byte[] data);
    public void Send(FileInfo file);
    public void Send(string data);
    public void SendAsync(Byte[] data, Action`1<bool> completed);
    public void SendAsync(FileInfo file, Action`1<bool> completed);
    public void SendAsync(string data, Action`1<bool> completed);
    public void SendAsync(Stream stream, int length, Action`1<bool> completed);
    public void SetCookie(Cookie cookie);
    public void SetCredentials(string username, string password, bool preAuth);
    public void SetProxy(string url, string username, string password);
    private sealed virtual override void System.IDisposable.Dispose();
    [CompilerGeneratedAttribute]
private void <open>b__143_0(IAsyncResult ar);
    [CompilerGeneratedAttribute]
private bool <processSecWebSocketProtocolHeader>b__153_0(string p);
    [CompilerGeneratedAttribute]
private void <startReceiving>b__170_2(Exception ex);
    [CompilerGeneratedAttribute]
private void <SendAsync>b__217_1(Exception ex);
}
public class WebSocketSharp.WebSocketException : Exception {
    private CloseStatusCode _code;
    public CloseStatusCode Code { get; }
    internal WebSocketException(Exception innerException);
    internal WebSocketException(string message);
    internal WebSocketException(CloseStatusCode code);
    internal WebSocketException(string message, Exception innerException);
    internal WebSocketException(CloseStatusCode code, Exception innerException);
    internal WebSocketException(CloseStatusCode code, string message);
    internal WebSocketException(CloseStatusCode code, string message, Exception innerException);
    public CloseStatusCode get_Code();
}
internal class WebSocketSharp.WebSocketFrame : object {
    private Byte[] _extPayloadLength;
    private Fin _fin;
    private Mask _mask;
    private Byte[] _maskingKey;
    private Opcode _opcode;
    private PayloadData _payloadData;
    private byte _payloadLength;
    private Rsv _rsv1;
    private Rsv _rsv2;
    private Rsv _rsv3;
    internal static Byte[] EmptyPingBytes;
    internal int ExtendedPayloadLengthCount { get; }
    internal ulong FullPayloadLength { get; }
    public Byte[] ExtendedPayloadLength { get; }
    public Fin Fin { get; }
    public bool IsBinary { get; }
    public bool IsClose { get; }
    public bool IsCompressed { get; }
    public bool IsContinuation { get; }
    public bool IsControl { get; }
    public bool IsData { get; }
    public bool IsFinal { get; }
    public bool IsFragment { get; }
    public bool IsMasked { get; }
    public bool IsPing { get; }
    public bool IsPong { get; }
    public bool IsText { get; }
    public ulong Length { get; }
    public Mask Mask { get; }
    public Byte[] MaskingKey { get; }
    public Opcode Opcode { get; }
    public PayloadData PayloadData { get; }
    public byte PayloadLength { get; }
    public Rsv Rsv1 { get; }
    public Rsv Rsv2 { get; }
    public Rsv Rsv3 { get; }
    private static WebSocketFrame();
    internal WebSocketFrame(Opcode opcode, PayloadData payloadData, bool mask);
    internal WebSocketFrame(Fin fin, Opcode opcode, Byte[] data, bool compressed, bool mask);
    internal WebSocketFrame(Fin fin, Opcode opcode, PayloadData payloadData, bool compressed, bool mask);
    internal int get_ExtendedPayloadLengthCount();
    internal ulong get_FullPayloadLength();
    public Byte[] get_ExtendedPayloadLength();
    public Fin get_Fin();
    public bool get_IsBinary();
    public bool get_IsClose();
    public bool get_IsCompressed();
    public bool get_IsContinuation();
    public bool get_IsControl();
    public bool get_IsData();
    public bool get_IsFinal();
    public bool get_IsFragment();
    public bool get_IsMasked();
    public bool get_IsPing();
    public bool get_IsPong();
    public bool get_IsText();
    public ulong get_Length();
    public Mask get_Mask();
    public Byte[] get_MaskingKey();
    public Opcode get_Opcode();
    public PayloadData get_PayloadData();
    public byte get_PayloadLength();
    public Rsv get_Rsv1();
    public Rsv get_Rsv2();
    public Rsv get_Rsv3();
    private static Byte[] createMaskingKey();
    private static string dump(WebSocketFrame frame);
    private static string print(WebSocketFrame frame);
    private static WebSocketFrame processHeader(Byte[] header);
    private static WebSocketFrame readExtendedPayloadLength(Stream stream, WebSocketFrame frame);
    private static void readExtendedPayloadLengthAsync(Stream stream, WebSocketFrame frame, Action`1<WebSocketFrame> completed, Action`1<Exception> error);
    private static WebSocketFrame readHeader(Stream stream);
    private static void readHeaderAsync(Stream stream, Action`1<WebSocketFrame> completed, Action`1<Exception> error);
    private static WebSocketFrame readMaskingKey(Stream stream, WebSocketFrame frame);
    private static void readMaskingKeyAsync(Stream stream, WebSocketFrame frame, Action`1<WebSocketFrame> completed, Action`1<Exception> error);
    private static WebSocketFrame readPayloadData(Stream stream, WebSocketFrame frame);
    private static void readPayloadDataAsync(Stream stream, WebSocketFrame frame, Action`1<WebSocketFrame> completed, Action`1<Exception> error);
    internal static WebSocketFrame CreateCloseFrame(PayloadData payloadData, bool mask);
    internal static WebSocketFrame CreatePingFrame(bool mask);
    internal static WebSocketFrame CreatePingFrame(Byte[] data, bool mask);
    internal static WebSocketFrame ReadFrame(Stream stream, bool unmask);
    internal static void ReadFrameAsync(Stream stream, bool unmask, Action`1<WebSocketFrame> completed, Action`1<Exception> error);
    internal void Unmask();
    public sealed virtual IEnumerator`1<byte> GetEnumerator();
    public void Print(bool dumped);
    public string PrintToString(bool dumped);
    public Byte[] ToArray();
    public virtual string ToString();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public enum WebSocketSharp.WebSocketState : Enum {
    public ushort value__;
    public static WebSocketState Connecting;
    public static WebSocketState Open;
    public static WebSocketState Closing;
    public static WebSocketState Closed;
}
