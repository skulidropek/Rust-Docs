internal SR : object {
internal string GetString(string name, Object[] args)
internal string GetString(CultureInfo culture, string name, Object[] args)
internal string GetString(string name)
internal string GetString(CultureInfo culture, string name)
internal string Format(string resourceFormat, Object[] args)
internal string Format(string resourceFormat, object p1)
internal string Format(string resourceFormat, object p1, object p2)
internal string Format(string resourceFormat, object p1, object p2, object p3)
}
public SRCore : object {
public string AsyncTransactionException
public string BindLockRequiresCommandFlag
public string BindReclaimedLockException
public string BindReclaimSucceeded
public string CannotAcquireLockDefault
public string CannotCompleteWithKeys
public string CannotCreateContextWithNullId
public string CannotInvokeBindingFromNonBinding
public string CannotInvokeTransactionalFromNonTransactional
public string CannotReplaceTransaction
public string CommandExecutionCannotOverlap
public string CompletedMustNotHaveAssociatedKeys
public string ContextAlreadyBoundToInstance
public string ContextAlreadyBoundToLock
public string ContextAlreadyBoundToOwner
public string ContextMustBeBoundToInstance
public string ContextMustBeBoundToOwner
public string ContextNotFromThisStore
public string DoNotCompleteTryCommandWithPendingReclaim
public string ExecuteMustBeNested
public string GenericInstanceCommandNull
public string GuidCannotBeEmpty
public string HandleFreed
public string HandleFreedBeforeInitialized
public string InstanceCollisionDefault
public string InstanceCompleteDefault
public string InstanceHandleConflictDefault
public string InstanceKeyRequiresValidGuid
public string InstanceLockLostDefault
public string InstanceNotReadyDefault
public string InstanceOperationRequiresInstance
public string InstanceOperationRequiresLock
public string InstanceOperationRequiresNotCompleted
public string InstanceOperationRequiresNotUninitialized
public string InstanceOperationRequiresOwner
public string InstanceOwnerDefault
public string InstanceStoreBoundSameVersionTwice
public string InvalidInstanceState
public string InvalidKeyArgument
public string InvalidLockToken
public string KeyAlreadyAssociated
public string KeyAlreadyCompleted
public string KeyAlreadyUnassociated
public string KeyCollisionDefault
public string KeyCompleteDefault
public string KeyNotAssociated
public string KeyNotCompleted
public string KeyNotReadyDefault
public string LoadedWriteOnlyValue
public string MayBindLockCommandShouldValidateOwner
public string MetadataCannotContainNullKey
public string MustSetTransactionOnFirstCall
public string OnCancelRequestedThrew
public string OnFreeInstanceHandleThrew
public string OwnerBelongsToWrongStore
public string StoreReportedConflictingLockTokens
public string TimedOutWaitingForLockResolution
public string TransactionInDoubtNonHost
public string TransactionRolledBackNonHost
public string TryCommandCannotExecuteSubCommandsAndReduce
public string UninitializedCannotHaveData
public string WaitAlreadyInProgress
public string CannotAcquireLockSpecific(object arg1)
public string CannotAcquireLockSpecificWithOwner(object arg1, object arg2)
public string GenericInstanceCommand(object arg1)
public string InitialMetadataCannotBeDeleted(object arg1)
public string InstanceCollisionSpecific(Guid arg1)
public string InstanceCompleteSpecific(Guid arg1)
public string InstanceHandleConflictSpecific(Guid arg1)
public string InstanceLockLostSpecific(Guid arg1)
public string InstanceNotReadySpecific(Guid arg1)
public string InstanceOwnerSpecific(Guid arg1)
public string KeyCollisionSpecific(object arg1)
public string KeyCollisionSpecific(object arg1, object arg2, object arg3)
public string KeyCollisionSpecificKeyOnly(object arg1)
public string KeyCompleteSpecific(object arg1)
public string KeyNotReadySpecific(object arg1)
public string MetadataCannotContainNullValue(object arg1)
public string NameCollisionOnCollect(XName arg1, object arg2)
public string NameCollisionOnMap(XName arg1, object arg2)
public string OutsideInstanceExecutionScope(object arg1)
public string OutsideTransactionalCommand(object arg1)
public string PersistencePipelineAbortThrew(object arg1)
public string ProviderDoesNotSupportCommand(object arg1)
public string WaitForEventsTimedOut(TimeSpan arg1)
}
internal System.Runtime.DurableInstancing.DisassociateInstanceKeysExtension : object {
private bool automaticDisassociationEnabled
internal bool AutomaticDisassociationEnabled
internal bool get_AutomaticDisassociationEnabled()
internal void set_AutomaticDisassociationEnabled(bool value)
}
internal System.Runtime.DurableInstancing.IDurableInstancingOptions {
public void SetScopeName(XName scopeName)
}
public System.Runtime.DurableInstancing.InstanceCollisionException : InstancePersistenceCommandException {
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
public void .ctor(XName commandName, Guid instanceId)
public void .ctor(XName commandName, Guid instanceId, Exception innerException)
public void .ctor(XName commandName, Guid instanceId, string message, Exception innerException)
protected void .ctor(SerializationInfo info, StreamingContext context)
private string ToMessage(Guid instanceId)
}
public System.Runtime.DurableInstancing.InstanceCompleteException : InstancePersistenceCommandException {
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
public void .ctor(XName commandName, Guid instanceId)
public void .ctor(XName commandName, Guid instanceId, Exception innerException)
public void .ctor(XName commandName, Guid instanceId, string message, Exception innerException)
protected void .ctor(SerializationInfo info, StreamingContext context)
private string ToMessage(Guid instanceId)
}
public System.Runtime.DurableInstancing.InstanceHandle : object {
private object thisLock
private object providerObject
private bool providerObjectSet
private bool needFreedNotification
private PreparingEnlistment pendingPreparingEnlistment
private AcquireContextAsyncResult pendingRollback
private InstanceHandleReference inProgressBind
private WaitForEventsAsyncResult waitResult
private HashSet`1<XName> boundOwnerEvents
private HashSet`1<InstancePersistenceEvent> pendingOwnerEvents
private EventTraceActivity eventTraceActivity
private Guid id
private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) idIsSet
private bool <IsValid>k__BackingField
private InstanceView <View>k__BackingField
private InstanceStore <Store>k__BackingField
private InstanceOwner <Owner>k__BackingField
private long <Version>k__BackingField
private InstanceHandle <ConflictingHandle>k__BackingField
private AcquireContextAsyncResult <CurrentTransactionalAsyncResult>k__BackingField
private bool <OperationPending>k__BackingField
private bool <TooLateToEnlist>k__BackingField
private AcquireContextAsyncResult <AcquirePending>k__BackingField
private InstancePersistenceContext <CurrentExecutionContext>k__BackingField
public bool IsValid
internal InstanceView View
internal InstanceStore Store
internal InstanceOwner Owner
internal Guid Id
internal long Version
internal InstanceHandle ConflictingHandle
internal object ProviderObject
internal EventTraceActivity EventTraceActivity
private AcquireContextAsyncResult CurrentTransactionalAsyncResult
private bool OperationPending
private bool TooLateToEnlist
private AcquireContextAsyncResult AcquirePending
private InstancePersistenceContext CurrentExecutionContext
private object ThisLock
internal void .ctor(InstanceStore store, InstanceOwner owner)
internal void .ctor(InstanceStore store, InstanceOwner owner, Guid instanceId)
public bool get_IsValid()
private void set_IsValid(bool value)
internal InstanceView get_View()
private void set_View(InstanceView value)
internal InstanceStore get_Store()
private void set_Store(InstanceStore value)
internal InstanceOwner get_Owner()
private void set_Owner(InstanceOwner value)
internal Guid get_Id()
private void set_Id(Guid value)
internal long get_Version()
private void set_Version(long value)
internal InstanceHandle get_ConflictingHandle()
internal void set_ConflictingHandle(InstanceHandle value)
internal object get_ProviderObject()
internal void set_ProviderObject(object value)
internal EventTraceActivity get_EventTraceActivity()
private AcquireContextAsyncResult get_CurrentTransactionalAsyncResult()
private void set_CurrentTransactionalAsyncResult(AcquireContextAsyncResult value)
private bool get_OperationPending()
private void set_OperationPending(bool value)
private bool get_TooLateToEnlist()
private void set_TooLateToEnlist(bool value)
private AcquireContextAsyncResult get_AcquirePending()
private void set_AcquirePending(AcquireContextAsyncResult value)
private InstancePersistenceContext get_CurrentExecutionContext()
private void set_CurrentExecutionContext(InstancePersistenceContext value)
private object get_ThisLock()
public void Free()
internal void BindOwnerEvent(InstancePersistenceEvent persistenceEvent)
internal void StartPotentialBind()
internal void BindOwner(InstanceOwner owner)
internal void BindInstance(Guid instanceId)
internal void Bind(long instanceVersion)
internal AsyncWaitHandle StartReclaim(long instanceVersion)
internal void CancelReclaim(Exception reason)
internal bool FinishReclaim(Int64& instanceVersion)
internal InstancePersistenceContext AcquireExecutionContext(Transaction hostTransaction, TimeSpan timeout)
internal IAsyncResult BeginAcquireExecutionContext(Transaction hostTransaction, TimeSpan timeout, AsyncCallback callback, object state)
internal InstancePersistenceContext EndAcquireExecutionContext(IAsyncResult result)
internal void ReleaseExecutionContext()
internal InstanceView Commit(InstanceView newState)
private void OnPrepare(PreparingEnlistment preparingEnlistment)
private void OnRollBack(AcquireContextAsyncResult rollingBack)
private void FinishOperation()
private List`1<InstancePersistenceEvent> StartWaiting(WaitForEventsAsyncResult result, IOThreadTimer timeoutTimer, TimeSpan timeout)
private bool CancelWaiting(WaitForEventsAsyncResult result)
internal void EventReady(InstancePersistenceEvent persistenceEvent)
internal IAsyncResult BeginWaitForEvents(InstanceHandle handle, TimeSpan timeout, AsyncCallback callback, object state)
internal List`1<InstancePersistenceEvent> EndWaitForEvents(IAsyncResult result)
}
public System.Runtime.DurableInstancing.InstanceHandleConflictException : InstancePersistenceCommandException {
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
public void .ctor(XName commandName, Guid instanceId)
public void .ctor(XName commandName, Guid instanceId, Exception innerException)
public void .ctor(XName commandName, Guid instanceId, string message, Exception innerException)
protected void .ctor(SerializationInfo info, StreamingContext context)
private string ToMessage(Guid instanceId)
}
internal System.Runtime.DurableInstancing.InstanceHandleReference : object {
private InstanceHandle <InstanceHandle>k__BackingField
internal InstanceHandle InstanceHandle
internal void .ctor(InstanceHandle instanceHandle)
internal InstanceHandle get_InstanceHandle()
private void set_InstanceHandle(InstanceHandle value)
internal void Cancel()
}
public System.Runtime.DurableInstancing.InstanceKey : object {
private IDictionary`2<XName, InstanceValue> emptyMetadata
private InstanceKey invalidKey
private bool invalid
private IDictionary`2<XName, InstanceValue> metadata
private Guid <Value>k__BackingField
public bool IsValid
public Guid Value
public IDictionary`2<XName, InstanceValue> Metadata
public InstanceKey InvalidKey
internal Guid SerializedValue
internal IDictionary`2<XName, InstanceValue> SerializedMetadata
public void .ctor(Guid value)
public void .ctor(Guid value, IDictionary`2<XName, InstanceValue> metadata)
public bool get_IsValid()
public Guid get_Value()
private void set_Value(Guid value)
public IDictionary`2<XName, InstanceValue> get_Metadata()
private void set_Metadata(IDictionary`2<XName, InstanceValue> value)
public InstanceKey get_InvalidKey()
public bool Equals(object obj)
public int GetHashCode()
internal Guid get_SerializedValue()
internal void set_SerializedValue(Guid value)
internal IDictionary`2<XName, InstanceValue> get_SerializedMetadata()
internal void set_SerializedMetadata(IDictionary`2<XName, InstanceValue> value)
}
public System.Runtime.DurableInstancing.InstanceKeyCollisionException : InstancePersistenceCommandException {
private string ConflictingInstanceIdName
private string InstanceKeyName
private Guid <ConflictingInstanceId>k__BackingField
private InstanceKey <InstanceKey>k__BackingField
public Guid ConflictingInstanceId
public InstanceKey InstanceKey
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
public void .ctor(XName commandName, Guid instanceId, InstanceKey instanceKey, Guid conflictingInstanceId)
public void .ctor(XName commandName, Guid instanceId, InstanceKey instanceKey, Guid conflictingInstanceId, Exception innerException)
public void .ctor(XName commandName, Guid instanceId, InstanceKey instanceKey, Guid conflictingInstanceId, string message, Exception innerException)
protected void .ctor(SerializationInfo info, StreamingContext context)
public Guid get_ConflictingInstanceId()
private void set_ConflictingInstanceId(Guid value)
public InstanceKey get_InstanceKey()
private void set_InstanceKey(InstanceKey value)
public void GetObjectData(SerializationInfo info, StreamingContext context)
private string ToMessage(Guid instanceId, InstanceKey instanceKey, Guid conflictingInstanceId)
}
public System.Runtime.DurableInstancing.InstanceKeyCompleteException : InstancePersistenceCommandException {
private string InstanceKeyName
private InstanceKey <InstanceKey>k__BackingField
public InstanceKey InstanceKey
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
public void .ctor(XName commandName, InstanceKey instanceKey)
public void .ctor(XName commandName, InstanceKey instanceKey, Exception innerException)
public void .ctor(XName commandName, Guid instanceId, InstanceKey instanceKey, string message, Exception innerException)
protected void .ctor(SerializationInfo info, StreamingContext context)
public InstanceKey get_InstanceKey()
private void set_InstanceKey(InstanceKey value)
public void GetObjectData(SerializationInfo info, StreamingContext context)
private string ToMessage(InstanceKey instanceKey)
}
public System.Runtime.DurableInstancing.InstanceKeyNotReadyException : InstancePersistenceCommandException {
private string InstanceKeyName
private InstanceKey <InstanceKey>k__BackingField
public InstanceKey InstanceKey
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
public void .ctor(XName commandName, InstanceKey instanceKey)
public void .ctor(XName commandName, InstanceKey instanceKey, Exception innerException)
public void .ctor(XName commandName, Guid instanceId, InstanceKey instanceKey, string message, Exception innerException)
protected void .ctor(SerializationInfo info, StreamingContext context)
public InstanceKey get_InstanceKey()
private void set_InstanceKey(InstanceKey value)
public void GetObjectData(SerializationInfo info, StreamingContext context)
private string ToMessage(InstanceKey instanceKey)
}
public System.Runtime.DurableInstancing.InstanceKeyState : Enum {
public int value__
public InstanceKeyState Unknown
public InstanceKeyState Associated
public InstanceKeyState Completed
}
public System.Runtime.DurableInstancing.InstanceKeyView : object {
private ReadOnlyDictionaryInternal`2<XName, InstanceValue> emptyProperties
private IDictionary`2<XName, InstanceValue> metadata
private Dictionary`2<XName, InstanceValue> accumulatedMetadataWrites
private Guid <InstanceKey>k__BackingField
private InstanceKeyState <InstanceKeyState>k__BackingField
private InstanceValueConsistency <InstanceKeyMetadataConsistency>k__BackingField
public Guid InstanceKey
public InstanceKeyState InstanceKeyState
public InstanceValueConsistency InstanceKeyMetadataConsistency
public IDictionary`2<XName, InstanceValue> InstanceKeyMetadata
internal Dictionary`2<XName, InstanceValue> AccumulatedMetadataWrites
internal void .ctor(Guid key)
private void .ctor(InstanceKeyView source)
public Guid get_InstanceKey()
private void set_InstanceKey(Guid value)
public InstanceKeyState get_InstanceKeyState()
internal void set_InstanceKeyState(InstanceKeyState value)
public InstanceValueConsistency get_InstanceKeyMetadataConsistency()
internal void set_InstanceKeyMetadataConsistency(InstanceValueConsistency value)
public IDictionary`2<XName, InstanceValue> get_InstanceKeyMetadata()
internal void set_InstanceKeyMetadata(IDictionary`2<XName, InstanceValue> value)
internal Dictionary`2<XName, InstanceValue> get_AccumulatedMetadataWrites()
internal InstanceKeyView Clone()
}
public System.Runtime.DurableInstancing.InstanceLockedException : InstancePersistenceCommandException {
private string InstanceOwnerIdName
private string SerializableInstanceOwnerMetadataName
private Guid <InstanceOwnerId>k__BackingField
private IDictionary`2<XName, object> <SerializableInstanceOwnerMetadata>k__BackingField
public Guid InstanceOwnerId
public IDictionary`2<XName, object> SerializableInstanceOwnerMetadata
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
public void .ctor(XName commandName, Guid instanceId)
public void .ctor(XName commandName, Guid instanceId, Exception innerException)
public void .ctor(XName commandName, Guid instanceId, string message, Exception innerException)
public void .ctor(XName commandName, Guid instanceId, Guid instanceOwnerId, IDictionary`2<XName, object> serializableInstanceOwnerMetadata)
public void .ctor(XName commandName, Guid instanceId, Guid instanceOwnerId, IDictionary`2<XName, object> serializableInstanceOwnerMetadata, Exception innerException)
public void .ctor(XName commandName, Guid instanceId, Guid instanceOwnerId, IDictionary`2<XName, object> serializableInstanceOwnerMetadata, string message, Exception innerException)
protected void .ctor(SerializationInfo info, StreamingContext context)
public Guid get_InstanceOwnerId()
private void set_InstanceOwnerId(Guid value)
public IDictionary`2<XName, object> get_SerializableInstanceOwnerMetadata()
private void set_SerializableInstanceOwnerMetadata(IDictionary`2<XName, object> value)
public void GetObjectData(SerializationInfo info, StreamingContext context)
private string ToMessage(Guid instanceId)
private string ToMessage(Guid instanceId, Guid instanceOwnerId)
}
public System.Runtime.DurableInstancing.InstanceLockLostException : InstancePersistenceCommandException {
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
public void .ctor(XName commandName, Guid instanceId)
public void .ctor(XName commandName, Guid instanceId, Exception innerException)
public void .ctor(XName commandName, Guid instanceId, string message, Exception innerException)
protected void .ctor(SerializationInfo info, StreamingContext context)
private string ToMessage(Guid instanceId)
}
public System.Runtime.DurableInstancing.InstanceLockQueryResult : InstanceStoreQueryResult {
private ReadOnlyDictionaryInternal`2<Guid, Guid> EmptyQueryResult
private IDictionary`2<Guid, Guid> <InstanceOwnerIds>k__BackingField
public IDictionary`2<Guid, Guid> InstanceOwnerIds
public void .ctor(Guid instanceId, Guid instanceOwnerId)
public void .ctor(IDictionary`2<Guid, Guid> instanceOwnerIds)
public IDictionary`2<Guid, Guid> get_InstanceOwnerIds()
private void set_InstanceOwnerIds(IDictionary`2<Guid, Guid> value)
}
internal System.Runtime.DurableInstancing.InstanceNormalEvent : InstancePersistenceEvent {
private HashSet`1<InstanceHandle> boundHandles
private HashSet`1<InstanceHandle> pendingHandles
private bool <IsSignaled>k__BackingField
internal bool IsSignaled
internal HashSet`1<InstanceHandle> BoundHandles
internal HashSet`1<InstanceHandle> PendingHandles
internal void .ctor(InstancePersistenceEvent persistenceEvent)
internal bool get_IsSignaled()
internal void set_IsSignaled(bool value)
internal HashSet`1<InstanceHandle> get_BoundHandles()
internal HashSet`1<InstanceHandle> get_PendingHandles()
}
public System.Runtime.DurableInstancing.InstanceNotReadyException : InstancePersistenceCommandException {
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
public void .ctor(XName commandName, Guid instanceId)
public void .ctor(XName commandName, Guid instanceId, Exception innerException)
public void .ctor(XName commandName, Guid instanceId, string message, Exception innerException)
protected void .ctor(SerializationInfo info, StreamingContext context)
private string ToMessage(Guid instanceId)
}
public System.Runtime.DurableInstancing.InstanceOwner : object {
private Dictionary`2<Guid, InstanceHandle> boundHandles
private Queue`1<InstanceHandleReference> inProgressHandles
private Dictionary`2<Guid, Queue`1<InstanceHandleReference>> inProgressHandlesPerInstance
private Dictionary`2<XName, InstanceNormalEvent> events
private Guid <InstanceOwnerId>k__BackingField
private Guid <OwnerToken>k__BackingField
public Guid InstanceOwnerId
internal Guid OwnerToken
internal Dictionary`2<XName, InstanceNormalEvent> Events
private object HandlesLock
private Dictionary`2<Guid, InstanceHandle> BoundHandles
private Queue`1<InstanceHandleReference> InProgressHandles
private Dictionary`2<Guid, Queue`1<InstanceHandleReference>> InProgressHandlesPerInstance
internal void .ctor(Guid ownerId, Guid lockToken)
public Guid get_InstanceOwnerId()
private void set_InstanceOwnerId(Guid value)
internal Guid get_OwnerToken()
private void set_OwnerToken(Guid value)
internal Dictionary`2<XName, InstanceNormalEvent> get_Events()
private object get_HandlesLock()
private Dictionary`2<Guid, InstanceHandle> get_BoundHandles()
private Queue`1<InstanceHandleReference> get_InProgressHandles()
private Dictionary`2<Guid, Queue`1<InstanceHandleReference>> get_InProgressHandlesPerInstance()
internal void Unbind(InstanceHandle handle)
internal void StartBind(InstanceHandle handle, InstanceHandleReference& reference)
internal bool TryCompleteBind(InstanceHandleReference& reference, List`1& handlesPendingResolution, InstanceHandle& handleToFree)
internal AsyncWaitHandle InitiateLockResolution(long instanceVersion, InstanceHandleReference& reference, List`1& handlesPendingResolution)
internal void InstanceBound(InstanceHandleReference& reference, List`1& handlesPendingResolution)
internal void CancelBind(InstanceHandleReference& reference, List`1& handlesPendingResolution)
internal void FaultBind(InstanceHandleReference& reference, List`1& handlesPendingResolution, Exception reason)
internal bool FinishBind(InstanceHandleReference& reference, Int64& instanceVersion, List`1& handlesPendingResolution)
private void CancelReference(InstanceHandleReference& reference, List`1& handlesPendingResolution)
private void ProcessInProgressHandles(List`1& handlesPendingResolution)
private void EnqueueReference(InstanceHandleReference handleRef)
private bool CheckOldestReference(InstanceHandleReference handleRef, List`1& handlesPendingResolution)
internal void ResolveHandles(List`1<InstanceHandleReference> handlesPendingResolution)
}
public System.Runtime.DurableInstancing.InstanceOwnerException : InstancePersistenceException {
private string InstanceOwnerIdName
private Guid <InstanceOwnerId>k__BackingField
public Guid InstanceOwnerId
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
public void .ctor(XName commandName, Guid instanceOwnerId)
public void .ctor(XName commandName, Guid instanceOwnerId, Exception innerException)
public void .ctor(XName commandName, Guid instanceOwnerId, string message, Exception innerException)
protected void .ctor(SerializationInfo info, StreamingContext context)
public Guid get_InstanceOwnerId()
private void set_InstanceOwnerId(Guid value)
public void GetObjectData(SerializationInfo info, StreamingContext context)
private string ToMessage(Guid instanceOwnerId)
}
public System.Runtime.DurableInstancing.InstanceOwnerQueryResult : InstanceStoreQueryResult {
private ReadOnlyDictionaryInternal`2<Guid, IDictionary`2<XName, InstanceValue>> EmptyQueryResult
private ReadOnlyDictionaryInternal`2<XName, InstanceValue> EmptyMetadata
private IDictionary`2<Guid, IDictionary`2<XName, InstanceValue>> <InstanceOwners>k__BackingField
public IDictionary`2<Guid, IDictionary`2<XName, InstanceValue>> InstanceOwners
public void .ctor(Guid instanceOwnerId, IDictionary`2<XName, InstanceValue> metadata)
public void .ctor(IDictionary`2<Guid, IDictionary`2<XName, InstanceValue>> instanceOwners)
public IDictionary`2<Guid, IDictionary`2<XName, InstanceValue>> get_InstanceOwners()
private void set_InstanceOwners(IDictionary`2<Guid, IDictionary`2<XName, InstanceValue>> value)
}
internal System.Runtime.DurableInstancing.InstancePersistence : object {
private XNamespace activitiesCommandNamespace
private XNamespace activitiesEventNamespace
internal XNamespace ActivitiesCommandNamespace
internal XNamespace ActivitiesEventNamespace
internal XNamespace get_ActivitiesCommandNamespace()
internal XNamespace get_ActivitiesEventNamespace()
public void ValidatePropertyBag(IDictionary`2<XName, InstanceValue> bag)
public void ValidatePropertyBag(IDictionary`2<XName, InstanceValue> bag, bool allowDelete)
public void ValidateProperty(KeyValuePair`2<XName, InstanceValue> property)
public void ValidateProperty(KeyValuePair`2<XName, InstanceValue> property, bool allowDelete)
public bool IsOptional(InstanceValue value)
public bool IsWriteOnly(InstanceValue value)
public ReadOnlyDictionaryInternal`2<XName, InstanceValue> ReadOnlyCopy(IDictionary`2<XName, InstanceValue> bag, bool allowWriteOnly)
public ReadOnlyDictionaryInternal`2<XName, InstanceValue> ReadOnlyMergeInto(IDictionary`2<XName, InstanceValue> bag, IDictionary`2<XName, InstanceValue> existing, bool allowWriteOnly)
}
public System.Runtime.DurableInstancing.InstancePersistenceCommand : object {
private XName <Name>k__BackingField
public XName Name
protected internal bool IsTransactionEnlistmentOptional
protected internal bool AutomaticallyAcquiringLock
protected void .ctor(XName name)
public XName get_Name()
private void set_Name(XName value)
protected internal bool get_IsTransactionEnlistmentOptional()
protected internal bool get_AutomaticallyAcquiringLock()
protected internal void Validate(InstanceView view)
internal IEnumerable`1<InstancePersistenceCommand> Reduce(InstanceView view)
}
public System.Runtime.DurableInstancing.InstancePersistenceCommandException : InstancePersistenceException {
private string InstanceIdName
private Guid <InstanceId>k__BackingField
public Guid InstanceId
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
public void .ctor(XName commandName)
public void .ctor(XName commandName, Guid instanceId)
public void .ctor(XName commandName, Exception innerException)
public void .ctor(XName commandName, string message, Exception innerException)
public void .ctor(XName commandName, Guid instanceId, Exception innerException)
public void .ctor(XName commandName, Guid instanceId, string message, Exception innerException)
protected void .ctor(SerializationInfo info, StreamingContext context)
public Guid get_InstanceId()
private void set_InstanceId(Guid value)
public void GetObjectData(SerializationInfo info, StreamingContext context)
}
public System.Runtime.DurableInstancing.InstancePersistenceContext : object {
private TimeSpan timeout
private Transaction transaction
private bool freezeTransaction
private CommittableTransaction myTransaction
private int cancellationHandlerCalled
private EventTraceActivity eventTraceActivity
private InstanceHandle <InstanceHandle>k__BackingField
private InstanceView <InstanceView>k__BackingField
private bool <CancelRequested>k__BackingField
private ExecuteAsyncResult <RootAsyncResult>k__BackingField
private ExecuteAsyncResult <LastAsyncResult>k__BackingField
private bool <IsHostTransaction>k__BackingField
private bool <IsHandleDoomedByRollback>k__BackingField
public InstanceHandle InstanceHandle
public InstanceView InstanceView
public long InstanceVersion
internal EventTraceActivity EventTraceActivity
public Guid LockToken
public object UserContext
private bool CancelRequested
private ExecuteAsyncResult RootAsyncResult
private ExecuteAsyncResult LastAsyncResult
private bool IsHostTransaction
private bool Active
internal Transaction Transaction
internal bool IsHandleDoomedByRollback
internal void .ctor(InstanceHandle handle, Transaction transaction)
internal void .ctor(InstanceHandle handle, TimeSpan timeout)
private void .ctor(InstanceHandle handle)
public InstanceHandle get_InstanceHandle()
private void set_InstanceHandle(InstanceHandle value)
public InstanceView get_InstanceView()
private void set_InstanceView(InstanceView value)
public long get_InstanceVersion()
internal EventTraceActivity get_EventTraceActivity()
public Guid get_LockToken()
public object get_UserContext()
private bool get_CancelRequested()
private void set_CancelRequested(bool value)
private ExecuteAsyncResult get_RootAsyncResult()
private void set_RootAsyncResult(ExecuteAsyncResult value)
private ExecuteAsyncResult get_LastAsyncResult()
private void set_LastAsyncResult(ExecuteAsyncResult value)
private bool get_IsHostTransaction()
private void set_IsHostTransaction(bool value)
private bool get_Active()
public void SetCancellationHandler(Action`1<InstancePersistenceContext> cancellationHandler)
public void BindInstanceOwner(Guid instanceOwnerId, Guid lockToken)
public void BindInstance(Guid instanceId)
public void BindEvent(InstancePersistenceEvent persistenceEvent)
public void BindAcquiredLock(long instanceVersion)
public void BindReclaimedLock(long instanceVersion, TimeSpan timeout)
public IAsyncResult BeginBindReclaimedLock(long instanceVersion, TimeSpan timeout, AsyncCallback callback, object state)
public void EndBindReclaimedLock(IAsyncResult result)
public Exception CreateBindReclaimedLockException(long instanceVersion)
private AsyncWaitHandle InitiateBindReclaimedLockHelper(string methodName, long instanceVersion, TimeSpan timeout)
private void ConcludeBindReclaimedLockHelper()
public void PersistedInstance(IDictionary`2<XName, InstanceValue> data)
public void LoadedInstance(InstanceState state, IDictionary`2<XName, InstanceValue> instanceData, IDictionary`2<XName, InstanceValue> instanceMetadata, IDictionary`2<Guid, IDictionary`2<XName, InstanceValue>> associatedInstanceKeyMetadata, IDictionary`2<Guid, IDictionary`2<XName, InstanceValue>> completedInstanceKeyMetadata)
public void CompletedInstance()
public void ReadInstanceMetadata(IDictionary`2<XName, InstanceValue> metadata, bool complete)
public void WroteInstanceMetadataValue(XName name, InstanceValue value)
public void AssociatedInstanceKey(Guid key)
public void CompletedInstanceKey(Guid key)
public void UnassociatedInstanceKey(Guid key)
public void ReadInstanceKeyMetadata(Guid key, IDictionary`2<XName, InstanceValue> metadata, bool complete)
public void WroteInstanceKeyMetadataValue(Guid key, XName name, InstanceValue value)
public void ReadInstanceOwnerMetadata(IDictionary`2<XName, InstanceValue> metadata, bool complete)
public void WroteInstanceOwnerMetadataValue(XName name, InstanceValue value)
public void QueriedInstanceStore(InstanceStoreQueryResult queryResult)
public void Execute(InstancePersistenceCommand command, TimeSpan timeout)
public IAsyncResult BeginExecute(InstancePersistenceCommand command, TimeSpan timeout, AsyncCallback callback, object state)
public void EndExecute(IAsyncResult result)
internal Transaction get_Transaction()
internal bool get_IsHandleDoomedByRollback()
private void set_IsHandleDoomedByRollback(bool value)
internal void RequireTransaction()
internal void PrepareForReuse()
internal void NotifyHandleFree()
internal InstanceView OuterExecute(InstanceHandle initialInstanceHandle, InstancePersistenceCommand command, Transaction transaction, TimeSpan timeout)
internal IAsyncResult BeginOuterExecute(InstanceHandle initialInstanceHandle, InstancePersistenceCommand command, Transaction transaction, TimeSpan timeout, AsyncCallback callback, object state)
internal InstanceView EndOuterExecute(IAsyncResult result)
private void ThrowIfNotLocked()
private void ThrowIfNoInstance()
private void ThrowIfNoOwner()
private void ThrowIfCompleted()
private void ThrowIfUninitialized()
private void ThrowIfNotActive(string methodName)
private void ThrowIfNotTransactional(string methodName)
private void ReconcileTransaction()
}
public System.Runtime.DurableInstancing.InstancePersistenceEvent : object {
private XName <Name>k__BackingField
public XName Name
internal void .ctor(XName name)
public XName get_Name()
private void set_Name(XName value)
public bool Equals(InstancePersistenceEvent persistenceEvent)
public bool Equals(object obj)
public int GetHashCode()
public bool op_Equality(InstancePersistenceEvent left, InstancePersistenceEvent right)
public bool op_Inequality(InstancePersistenceEvent left, InstancePersistenceEvent right)
}
public System.Runtime.DurableInstancing.InstancePersistenceEvent`1 : InstancePersistenceEvent {
private T instance
public T Value
protected void .ctor(XName name)
public T get_Value()
}
public System.Runtime.DurableInstancing.InstancePersistenceException : Exception {
private string CommandNameName
private XName <CommandName>k__BackingField
public XName CommandName
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
public void .ctor(XName commandName)
public void .ctor(XName commandName, Exception innerException)
public void .ctor(XName commandName, string message)
public void .ctor(XName commandName, string message, Exception innerException)
protected void .ctor(SerializationInfo info, StreamingContext context)
public XName get_CommandName()
private void set_CommandName(XName value)
public void GetObjectData(SerializationInfo info, StreamingContext context)
private string ToMessage(XName commandName)
}
public System.Runtime.DurableInstancing.InstanceState : Enum {
public int value__
public InstanceState Unknown
public InstanceState Uninitialized
public InstanceState Initialized
public InstanceState Completed
}
public System.Runtime.DurableInstancing.InstanceStore : object {
private Dictionary`2<Guid, WeakReference> owners
private Guid[] ownerKeysToScan
private int ownerKeysIndexToScan
private InstanceOwner <DefaultInstanceOwner>k__BackingField
private object ThisLock
public InstanceOwner DefaultInstanceOwner
private object get_ThisLock()
public InstanceOwner get_DefaultInstanceOwner()
public void set_DefaultInstanceOwner(InstanceOwner value)
public InstanceHandle CreateInstanceHandle()
public InstanceHandle CreateInstanceHandle(InstanceOwner owner)
public InstanceHandle CreateInstanceHandle(Guid instanceId)
public InstanceHandle CreateInstanceHandle(InstanceOwner owner, Guid instanceId)
public InstanceView Execute(InstanceHandle handle, InstancePersistenceCommand command, TimeSpan timeout)
public IAsyncResult BeginExecute(InstanceHandle handle, InstancePersistenceCommand command, TimeSpan timeout, AsyncCallback callback, object state)
public InstanceView EndExecute(IAsyncResult result)
public List`1<InstancePersistenceEvent> WaitForEvents(InstanceHandle handle, TimeSpan timeout)
public IAsyncResult BeginWaitForEvents(InstanceHandle handle, TimeSpan timeout, AsyncCallback callback, object state)
public List`1<InstancePersistenceEvent> EndWaitForEvents(IAsyncResult result)
protected void SignalEvent(InstancePersistenceEvent persistenceEvent, InstanceOwner owner)
protected void ResetEvent(InstancePersistenceEvent persistenceEvent, InstanceOwner owner)
protected object OnNewInstanceHandle(InstanceHandle instanceHandle)
protected void OnFreeInstanceHandle(InstanceHandle instanceHandle, object userContext)
protected internal bool TryCommand(InstancePersistenceContext context, InstancePersistenceCommand command, TimeSpan timeout)
protected internal IAsyncResult BeginTryCommand(InstancePersistenceContext context, InstancePersistenceCommand command, TimeSpan timeout, AsyncCallback callback, object state)
protected internal bool EndTryCommand(IAsyncResult result)
protected InstanceOwner[] GetInstanceOwners()
protected InstancePersistenceEvent[] GetEvents(InstanceOwner owner)
internal InstanceOwner GetOrCreateOwner(Guid instanceOwnerId, Guid lockToken)
internal void PendHandleToEvent(InstanceHandle handle, InstancePersistenceEvent persistenceEvent, InstanceOwner owner)
internal InstancePersistenceEvent AddHandleToEvent(InstanceHandle handle, InstancePersistenceEvent persistenceEvent, InstanceOwner owner)
internal List`1<InstancePersistenceEvent> SelectSignaledEvents(IEnumerable`1<XName> eventNames, InstanceOwner owner)
internal void RemoveHandleFromEvents(InstanceHandle handle, IEnumerable`1<XName> eventNames, InstanceOwner owner)
private InstanceNormalEvent GetOwnerEventHelper(InstancePersistenceEvent persistenceEvent, InstanceOwner owner)
internal void FreeInstanceHandle(InstanceHandle handle, object providerObject)
private InstanceHandle PrepareInstanceHandle(InstanceHandle handle)
}
public System.Runtime.DurableInstancing.InstanceValue : object {
private InstanceValue deletedValue
private object <Value>k__BackingField
private InstanceValueOptions <Options>k__BackingField
public object Value
public InstanceValueOptions Options
public bool IsDeletedValue
public InstanceValue DeletedValue
internal object SerializedValue
internal InstanceValueOptions SerializedOptions
public void .ctor(object value)
public void .ctor(object value, InstanceValueOptions options)
public object get_Value()
private void set_Value(object value)
public InstanceValueOptions get_Options()
private void set_Options(InstanceValueOptions value)
public bool get_IsDeletedValue()
public InstanceValue get_DeletedValue()
internal object get_SerializedValue()
internal void set_SerializedValue(object value)
internal InstanceValueOptions get_SerializedOptions()
internal void set_SerializedOptions(InstanceValueOptions value)
}
public System.Runtime.DurableInstancing.InstanceValueConsistency : Enum {
public int value__
public InstanceValueConsistency None
public InstanceValueConsistency InDoubt
public InstanceValueConsistency Partial
}
public System.Runtime.DurableInstancing.InstanceValueOptions : Enum {
public int value__
public InstanceValueOptions None
public InstanceValueOptions Optional
public InstanceValueOptions WriteOnly
}
public System.Runtime.DurableInstancing.InstanceView : object {
private ReadOnlyDictionaryInternal`2<XName, InstanceValue> emptyProperties
private ReadOnlyDictionaryInternal`2<Guid, InstanceKeyView> emptyKeys
private IDictionary`2<XName, InstanceValue> data
private IDictionary`2<XName, InstanceValue> metadata
private IDictionary`2<XName, InstanceValue> ownerMetadata
private IDictionary`2<Guid, InstanceKeyView> keys
private ReadOnlyCollection`1<InstanceStoreQueryResult> queryResults
private Dictionary`2<XName, InstanceValue> accumulatedMetadataWrites
private Dictionary`2<XName, InstanceValue> accumulatedOwnerMetadataWrites
private Collection`1<InstanceStoreQueryResult> queryResultsBackingCollection
private long instanceVersion
private Guid <InstanceId>k__BackingField
private bool <IsBoundToInstance>k__BackingField
private InstanceOwner <InstanceOwner>k__BackingField
private InstanceState <InstanceState>k__BackingField
private InstanceValueConsistency <InstanceDataConsistency>k__BackingField
private InstanceValueConsistency <InstanceMetadataConsistency>k__BackingField
private InstanceValueConsistency <InstanceOwnerMetadataConsistency>k__BackingField
private InstanceValueConsistency <InstanceKeysConsistency>k__BackingField
private bool <IsViewFrozen>k__BackingField
public Guid InstanceId
public bool IsBoundToInstance
public InstanceOwner InstanceOwner
public bool IsBoundToInstanceOwner
public bool IsBoundToLock
public InstanceState InstanceState
public InstanceValueConsistency InstanceDataConsistency
public IDictionary`2<XName, InstanceValue> InstanceData
public InstanceValueConsistency InstanceMetadataConsistency
public IDictionary`2<XName, InstanceValue> InstanceMetadata
internal Dictionary`2<XName, InstanceValue> AccumulatedMetadataWrites
public InstanceValueConsistency InstanceOwnerMetadataConsistency
public IDictionary`2<XName, InstanceValue> InstanceOwnerMetadata
internal Dictionary`2<XName, InstanceValue> AccumulatedOwnerMetadataWrites
public InstanceValueConsistency InstanceKeysConsistency
public IDictionary`2<Guid, InstanceKeyView> InstanceKeys
public ReadOnlyCollection`1<InstanceStoreQueryResult> InstanceStoreQueryResults
internal Collection`1<InstanceStoreQueryResult> QueryResultsBacking
private bool IsViewFrozen
internal void .ctor(InstanceOwner owner)
internal void .ctor(InstanceOwner owner, Guid instanceId)
private void .ctor(InstanceView source)
public Guid get_InstanceId()
private void set_InstanceId(Guid value)
public bool get_IsBoundToInstance()
private void set_IsBoundToInstance(bool value)
public InstanceOwner get_InstanceOwner()
private void set_InstanceOwner(InstanceOwner value)
public bool get_IsBoundToInstanceOwner()
public bool get_IsBoundToLock()
public InstanceState get_InstanceState()
internal void set_InstanceState(InstanceState value)
public InstanceValueConsistency get_InstanceDataConsistency()
internal void set_InstanceDataConsistency(InstanceValueConsistency value)
public IDictionary`2<XName, InstanceValue> get_InstanceData()
internal void set_InstanceData(IDictionary`2<XName, InstanceValue> value)
public InstanceValueConsistency get_InstanceMetadataConsistency()
internal void set_InstanceMetadataConsistency(InstanceValueConsistency value)
public IDictionary`2<XName, InstanceValue> get_InstanceMetadata()
internal void set_InstanceMetadata(IDictionary`2<XName, InstanceValue> value)
internal Dictionary`2<XName, InstanceValue> get_AccumulatedMetadataWrites()
public InstanceValueConsistency get_InstanceOwnerMetadataConsistency()
internal void set_InstanceOwnerMetadataConsistency(InstanceValueConsistency value)
public IDictionary`2<XName, InstanceValue> get_InstanceOwnerMetadata()
internal void set_InstanceOwnerMetadata(IDictionary`2<XName, InstanceValue> value)
internal Dictionary`2<XName, InstanceValue> get_AccumulatedOwnerMetadataWrites()
public InstanceValueConsistency get_InstanceKeysConsistency()
internal void set_InstanceKeysConsistency(InstanceValueConsistency value)
public IDictionary`2<Guid, InstanceKeyView> get_InstanceKeys()
internal void set_InstanceKeys(IDictionary`2<Guid, InstanceKeyView> value)
public ReadOnlyCollection`1<InstanceStoreQueryResult> get_InstanceStoreQueryResults()
internal void set_InstanceStoreQueryResults(ReadOnlyCollection`1<InstanceStoreQueryResult> value)
internal Collection`1<InstanceStoreQueryResult> get_QueryResultsBacking()
internal void BindOwner(InstanceOwner owner)
internal void BindInstance(Guid instanceId)
internal void BindLock(long instanceVersion)
internal void StartBindLock(long instanceVersion)
internal void FinishBindLock(long instanceVersion)
internal void MakeReadOnly()
internal InstanceView Clone()
private bool get_IsViewFrozen()
private void set_IsViewFrozen(bool value)
}
internal System.Runtime.ICancelable {
public void Cancel()
}
internal System.Runtime.IPersistencePipelineModule {
public bool IsIOParticipant
public bool IsSaveTransactionRequired
public bool IsLoadTransactionRequired
public bool get_IsIOParticipant()
public bool get_IsSaveTransactionRequired()
public bool get_IsLoadTransactionRequired()
public void CollectValues(IDictionary`2& readWriteValues, IDictionary`2& writeOnlyValues)
public IDictionary`2<XName, object> MapValues(IDictionary`2<XName, object> readWriteValues, IDictionary`2<XName, object> writeOnlyValues)
public void PublishValues(IDictionary`2<XName, object> readWriteValues)
public IAsyncResult BeginOnSave(IDictionary`2<XName, object> readWriteValues, IDictionary`2<XName, object> writeOnlyValues, TimeSpan timeout, AsyncCallback callback, object state)
public void EndOnSave(IAsyncResult result)
public IAsyncResult BeginOnLoad(IDictionary`2<XName, object> readWriteValues, TimeSpan timeout, AsyncCallback callback, object state)
public void EndOnLoad(IAsyncResult result)
public void Abort()
}
internal System.Runtime.PersistenceMetadataNamespace : object {
private string baseNamespace
private XNamespace persistenceMetadataNamespace
private XName instanceType
private XName activationType
public XName InstanceType
public XName ActivationType
public XName get_InstanceType()
public XName get_ActivationType()
}
internal System.Runtime.PersistencePipeline : object {
private IEnumerable`1<IPersistencePipelineModule> modules
private Stage expectedStage
private IDictionary`2<XName, InstanceValue> values
private ReadOnlyDictionaryInternal`2<XName, InstanceValue> readOnlyView
private ValueDictionaryView readWriteView
private ValueDictionaryView writeOnlyView
public ReadOnlyDictionaryInternal`2<XName, InstanceValue> Values
public bool IsSaveTransactionRequired
public bool IsLoadTransactionRequired
public void .ctor(IEnumerable`1<IPersistencePipelineModule> modules, Dictionary`2<XName, InstanceValue> initialValues)
public void .ctor(IEnumerable`1<IPersistencePipelineModule> modules)
public ReadOnlyDictionaryInternal`2<XName, InstanceValue> get_Values()
public bool get_IsSaveTransactionRequired()
public bool get_IsLoadTransactionRequired()
public void Collect()
public void Map()
public IAsyncResult BeginSave(TimeSpan timeout, AsyncCallback callback, object state)
public void EndSave(IAsyncResult result)
public void SetLoadedValues(IDictionary`2<XName, InstanceValue> values)
public IAsyncResult BeginLoad(TimeSpan timeout, AsyncCallback callback, object state)
public void EndLoad(IAsyncResult result)
public void Publish()
public void Abort()
}
internal System.Runtime.TransactedAsyncResult : AsyncResult {
private IAsyncResult deferredTransactionalResult
private TransactionSignalScope transactionContext
protected void .ctor(AsyncCallback callback, object state)
protected bool OnContinueAsyncCompletion(IAsyncResult result)
private bool CheckSyncValidation(IAsyncResult result)
private void BeforePrepareAsyncCompletion()
protected IDisposable PrepareTransactionalCall(Transaction transaction)
}
internal System.Runtime.TransactionHelper : object {
public void ThrowIfTransactionAbortedOrInDoubt(Transaction transaction)
public TransactionScope CreateTransactionScope(Transaction transaction)
public void CompleteTransactionScope(TransactionScope& scope)
}
internal System.Runtime.Workflow45Namespace : object {
private string baseNamespace
private XNamespace workflow45Namespace
private XName definitionIdentity
private XName definitionIdentities
private XName definitionIdentityFilter
private XName workflowApplication
public XName DefinitionIdentity
public XName DefinitionIdentities
public XName DefinitionIdentityFilter
public XName WorkflowApplication
public XName get_DefinitionIdentity()
public XName get_DefinitionIdentities()
public XName get_DefinitionIdentityFilter()
public XName get_WorkflowApplication()
}
internal System.Runtime.WorkflowNamespace : object {
private string baseNamespace
private XNamespace workflowNamespace
private XNamespace variablesNamespace
private XNamespace outputNamespace
private XName workflowHostType
private XName status
private XName bookmarks
private XName lastUpdate
private XName exception
private XName workflow
private XName keyProvider
public XNamespace VariablesPath
public XNamespace OutputPath
public XName WorkflowHostType
public XName Status
public XName Bookmarks
public XName LastUpdate
public XName Exception
public XName Workflow
public XName KeyProvider
public XNamespace get_VariablesPath()
public XNamespace get_OutputPath()
public XName get_WorkflowHostType()
public XName get_Status()
public XName get_Bookmarks()
public XName get_LastUpdate()
public XName get_Exception()
public XName get_Workflow()
public XName get_KeyProvider()
}
internal System.Runtime.WorkflowServiceNamespace : object {
private string baseNamespace
private XNamespace workflowServiceNamespace
private XNamespace endpointsNamespace
private XName controlEndpoint
private XName suspendException
private XName suspendReason
private XName siteName
private XName relativeApplicationPath
private XName relativeServicePath
private XName creationContext
private XName service
private XName requestReplyCorrelation
private XName messageVersionForReplies
public XNamespace EndpointsPath
public XName ControlEndpoint
public XName MessageVersionForReplies
public XName RequestReplyCorrelation
public XName SuspendReason
public XName SiteName
public XName SuspendException
public XName RelativeApplicationPath
public XName RelativeServicePath
public XName CreationContext
public XName Service
public XNamespace get_EndpointsPath()
public XName get_ControlEndpoint()
public XName get_MessageVersionForReplies()
public XName get_RequestReplyCorrelation()
public XName get_SuspendReason()
public XName get_SiteName()
public XName get_SuspendException()
public XName get_RelativeApplicationPath()
public XName get_RelativeServicePath()
public XName get_CreationContext()
public XName get_Service()
}
