internal UnityEngine.IInterval {
public long intervalStart
public long intervalEnd
public int intervalBit
public long get_intervalStart()
public long get_intervalEnd()
public int get_intervalBit()
public void set_intervalBit(int value)
}
internal UnityEngine.IntervalNode`1 : object {
private long m_Center
private List`1<T> m_Children
private IntervalNode`1<T> m_LeftNode
private IntervalNode`1<T> m_RightNode
public void .ctor(ICollection`1<T> items)
public void Query(long time, int bitflag, List`1& results)
}
internal UnityEngine.IntervalTree`1 : object {
private List`1<T> m_Nodes
private bool m_Dirty
private IntervalNode`1<T> m_Root
public void Add(T item)
public void IntersectsWith(long value, int bitFlag, List`1& results)
}
public UnityEngine.Timeline.ActivationControlPlayable : PlayableBehaviour {
public GameObject gameObject
public PostPlaybackState postPlayback
private InitialState m_InitialState
public ScriptPlayable`1<ActivationControlPlayable> Create(PlayableGraph graph, GameObject gameObject, PostPlaybackState postPlaybackState)
public void OnBehaviourPlay(Playable playable, FrameData info)
public void OnBehaviourPause(Playable playable, FrameData info)
public void ProcessFrame(Playable playable, FrameData info, object userData)
public void OnGraphStart(Playable playable)
public void OnPlayableDestroy(Playable playable)
}
internal UnityEngine.Timeline.ActivationMixerPlayable : PlayableBehaviour {
private PostPlaybackState m_PostPlaybackState
private bool m_BoundGameObjectInitialStateIsActive
private GameObject m_BoundGameObject
public GameObject boundGameObject
public PostPlaybackState postPlaybackState
public GameObject get_boundGameObject()
public void set_boundGameObject(GameObject value)
public ScriptPlayable`1<ActivationMixerPlayable> Create(PlayableGraph graph, int inputCount)
public PostPlaybackState get_postPlaybackState()
public void set_postPlaybackState(PostPlaybackState value)
public void OnPlayableDestroy(Playable playable)
public void ProcessFrame(Playable playable, FrameData info, object playerData)
}
internal UnityEngine.Timeline.ActivationPlayableAsset : PlayableAsset {
public ClipCaps clipCaps
public ClipCaps get_clipCaps()
public Playable CreatePlayable(PlayableGraph graph, GameObject go)
}
public UnityEngine.Timeline.ActivationTrack : TrackAsset {
private PostPlaybackState m_PostPlaybackState
private ActivationMixerPlayable m_ActivationMixer
internal bool compilable
public PostPlaybackState postPlaybackState
internal bool get_compilable()
public PostPlaybackState get_postPlaybackState()
public void set_postPlaybackState(PostPlaybackState value)
public Playable CreateTrackMixer(PlayableGraph graph, GameObject go, int inputCount)
private void UpdateBoundGameObject(PlayableDirector director)
internal void UpdateTrackMode()
public void GatherProperties(PlayableDirector director, IPropertyCollector driver)
}
internal UnityEngine.Timeline.AnimationOutputWeightProcessor : object {
private AnimationPlayableOutput m_Output
private AnimationLayerMixerPlayable m_LayerMixer
private List`1<WeightInfo> m_Mixers
public void .ctor(AnimationPlayableOutput output)
private void FindMixers()
private void FindMixers(Playable parent, int port, Playable node)
public void Evaluate()
}
public UnityEngine.Timeline.AnimationPlayableAsset : PlayableAsset {
private AnimationClip m_Clip
private Vector3 m_Position
private Quaternion m_Rotation
private bool m_UseTrackMatchFields
private MatchTargetFields m_MatchTargetFields
private bool m_RemoveStartOffset
private AnimationClipPlayable m_AnimationClipPlayable
public Vector3 position
public Quaternion rotation
public bool useTrackMatchFields
public MatchTargetFields matchTargetFields
internal bool removeStartOffset
public AnimationClip clip
public double duration
public IEnumerable`1<PlayableBinding> outputs
private bool applyRootMotion
public ClipCaps clipCaps
public Vector3 get_position()
public void set_position(Vector3 value)
public Quaternion get_rotation()
public void set_rotation(Quaternion value)
public bool get_useTrackMatchFields()
public void set_useTrackMatchFields(bool value)
public MatchTargetFields get_matchTargetFields()
public void set_matchTargetFields(MatchTargetFields value)
internal bool get_removeStartOffset()
internal void set_removeStartOffset(bool value)
public AnimationClip get_clip()
public void set_clip(AnimationClip value)
public double get_duration()
public IEnumerable`1<PlayableBinding> get_outputs()
public Playable CreatePlayable(PlayableGraph graph, GameObject go)
private bool get_applyRootMotion()
public void LiveLink()
public ClipCaps get_clipCaps()
public void ResetOffsets()
public void GatherProperties(PlayableDirector director, IPropertyCollector driver)
}
public UnityEngine.Timeline.AnimationTrack : TrackAsset {
protected AnimationPlayableAsset m_AnimationPlayableAsset
protected TimelineClip m_FakeAnimClip
private ClipExtrapolation m_OpenClipPreExtrapolation
private ClipExtrapolation m_OpenClipPostExtrapolation
private Vector3 m_OpenClipOffsetPosition
private Quaternion m_OpenClipOffsetRotation
private double m_OpenClipTimeOffset
private MatchTargetFields m_MatchTargetFields
private Vector3 m_Position
private Quaternion m_Rotation
private bool m_ApplyOffsets
public Vector3 position
public Quaternion rotation
public bool applyOffsets
public MatchTargetFields matchTargetFields
private bool compilableIsolated
internal bool compilable
public IEnumerable`1<PlayableBinding> outputs
public bool inClipMode
public Vector3 openClipOffsetPosition
public Quaternion openClipOffsetRotation
internal double openClipTimeOffset
public ClipExtrapolation openClipPreExtrapolation
public ClipExtrapolation openClipPostExtrapolation
public Vector3 get_position()
public void set_position(Vector3 value)
public Quaternion get_rotation()
public void set_rotation(Quaternion value)
public bool get_applyOffsets()
public void set_applyOffsets(bool value)
public MatchTargetFields get_matchTargetFields()
public void set_matchTargetFields(MatchTargetFields value)
private bool get_compilableIsolated()
internal bool get_compilable()
public IEnumerable`1<PlayableBinding> get_outputs()
public bool get_inClipMode()
public Vector3 get_openClipOffsetPosition()
public void set_openClipOffsetPosition(Vector3 value)
public Quaternion get_openClipOffsetRotation()
public void set_openClipOffsetRotation(Quaternion value)
internal double get_openClipTimeOffset()
internal void set_openClipTimeOffset(double value)
public ClipExtrapolation get_openClipPreExtrapolation()
public void set_openClipPreExtrapolation(ClipExtrapolation value)
public ClipExtrapolation get_openClipPostExtrapolation()
public void set_openClipPostExtrapolation(ClipExtrapolation value)
private void ResetOffsets()
public TimelineClip CreateClip(AnimationClip clip)
internal void UpdateClipOffsets()
internal void OnCreateClipFromAsset(Object asset, TimelineClip clip)
internal Playable CompileTrackPlayable(PlayableGraph graph, TrackAsset track, GameObject go, IntervalTree`1<RuntimeClipBase> tree)
internal Playable OnCreatePlayableGraph(PlayableGraph graph, GameObject go, IntervalTree`1<RuntimeClipBase> tree)
private Playable CreateGroupMixer(PlayableGraph graph, GameObject go, int inputCount)
private Playable CreateInfiniteTrackPlayable(PlayableGraph graph, GameObject go, IntervalTree`1<RuntimeClipBase> tree)
private Playable ApplyTrackOffset(PlayableGraph graph, Playable root)
internal void GetEvaluationTime(Double& outStart, Double& outDuration)
internal void GetSequenceTime(Double& outStart, Double& outDuration)
private void AssignAnimationClip(TimelineClip clip, AnimationClip animClip)
public void GatherProperties(PlayableDirector director, IPropertyCollector driver)
}
public UnityEngine.Timeline.AudioPlayableAsset : PlayableAsset {
private AudioClip m_Clip
private bool m_Loop
private float m_bufferingTime
internal float bufferingTime
public AudioClip clip
public double duration
public IEnumerable`1<PlayableBinding> outputs
public ClipCaps clipCaps
internal float get_bufferingTime()
internal void set_bufferingTime(float value)
public AudioClip get_clip()
public void set_clip(AudioClip value)
public double get_duration()
public IEnumerable`1<PlayableBinding> get_outputs()
public Playable CreatePlayable(PlayableGraph graph, GameObject go)
public ClipCaps get_clipCaps()
}
public UnityEngine.Timeline.AudioTrack : TrackAsset {
public IEnumerable`1<PlayableBinding> outputs
public TimelineClip CreateClip(AudioClip clip)
internal Playable OnCreatePlayableGraph(PlayableGraph graph, GameObject go, IntervalTree`1<RuntimeClipBase> tree)
internal void OnCreateClipFromAsset(Object asset, TimelineClip newClip)
public IEnumerable`1<PlayableBinding> get_outputs()
}
public UnityEngine.Timeline.BasicPlayableBehaviour : ScriptableObject {
public double duration
public IEnumerable`1<PlayableBinding> outputs
public double get_duration()
public IEnumerable`1<PlayableBinding> get_outputs()
public void OnGraphStart(Playable playable)
public void OnGraphStop(Playable playable)
public void OnPlayableCreate(Playable playable)
public void OnPlayableDestroy(Playable playable)
public void OnBehaviourPlay(Playable playable, FrameData info)
public void OnBehaviourPause(Playable playable, FrameData info)
public void PrepareFrame(Playable playable, FrameData info)
public void ProcessFrame(Playable playable, FrameData info, object playerData)
public Playable CreatePlayable(PlayableGraph graph, GameObject owner)
}
public UnityEngine.Timeline.ClipCaps : Enum {
public int value__
public ClipCaps None
public ClipCaps Looping
public ClipCaps Extrapolation
public ClipCaps ClipIn
public ClipCaps SpeedMultiplier
public ClipCaps Blending
public ClipCaps All
}
public UnityEngine.Timeline.ControlPlayableAsset : PlayableAsset {
private int k_MaxRandInt
public ExposedReference`1<GameObject> sourceGameObject
public GameObject prefabGameObject
public bool updateParticle
public UInt32 particleRandomSeed
public bool updateDirector
public bool updateITimeControl
public bool searchHierarchy
public bool active
public PostPlaybackState postPlayback
private PlayableAsset m_ControlDirectorAsset
private double m_Duration
private bool m_SupportLoop
public double duration
public ClipCaps clipCaps
public void OnEnable()
public double get_duration()
public ClipCaps get_clipCaps()
public Playable CreatePlayable(PlayableGraph graph, GameObject go)
private Playable ConnectPlayablesToMixer(PlayableGraph graph, List`1<Playable> playables)
private void CreateActivationPlayable(GameObject root, PlayableGraph graph, List`1<Playable> outplayables)
private void SearchHiearchyAndConnectParticleSystem(IEnumerable`1<ParticleSystem> particleSystems, PlayableGraph graph, List`1<Playable> outplayables)
private void SearchHierarchyAndConnectDirector(IEnumerable`1<PlayableDirector> directors, PlayableGraph graph, List`1<Playable> outplayables)
private void SearchHierarchyAndConnectControlableScripts(IEnumerable`1<MonoBehaviour> controlableScripts, PlayableGraph graph, List`1<Playable> outplayables)
private void ConnectMixerAndPlayable(PlayableGraph graph, Playable mixer, Playable playable, int portIndex)
private IList`1<ParticleSystem> GetParticleSystems(GameObject gameObject)
private IList`1<PlayableDirector> GetDirectors(GameObject gameObject)
private IEnumerable`1<MonoBehaviour> GetControlableScripts(GameObject root)
private void UpdateDurationAndLoopFlag(IList`1<PlayableDirector> directors, IList`1<ParticleSystem> particleSystems)
public void GatherProperties(PlayableDirector director, IPropertyCollector driver)
}
public UnityEngine.Timeline.DirectorControlPlayable : PlayableBehaviour {
public PlayableDirector director
public ScriptPlayable`1<DirectorControlPlayable> Create(PlayableGraph graph, PlayableDirector director)
public void PrepareFrame(Playable playable, FrameData info)
public void OnBehaviourPlay(Playable playable, FrameData info)
public void OnBehaviourPause(Playable playable, FrameData info)
private void UpdateTime(Playable playable)
}
internal UnityEngine.Timeline.DiscreteTime : ValueType {
private double k_Tick
public DiscreteTime MaxTime
private long m_DiscreteTime
public double tickValue
public void .ctor(DiscreteTime time)
private void .ctor(long time)
public void .ctor(double time)
public void .ctor(float time)
public void .ctor(int time)
public void .ctor(int frame, double fps)
public double get_tickValue()
public DiscreteTime OneTickBefore()
public DiscreteTime OneTickAfter()
public long GetTick()
public int CompareTo(object obj)
public bool Equals(DiscreteTime other)
public bool Equals(object obj)
private long DoubleToDiscreteTime(double time)
private long FloatToDiscreteTime(float time)
private long IntToDiscreteTime(int time)
private double ToDouble(long time)
private float ToFloat(long time)
public double op_Explicit(DiscreteTime b)
public float op_Explicit(DiscreteTime b)
public long op_Explicit(DiscreteTime b)
public DiscreteTime op_Explicit(double time)
public DiscreteTime op_Explicit(float time)
public DiscreteTime op_Implicit(int time)
public bool op_Equality(DiscreteTime lhs, DiscreteTime rhs)
public bool op_Inequality(DiscreteTime lhs, DiscreteTime rhs)
public bool op_GreaterThan(DiscreteTime lhs, DiscreteTime rhs)
public bool op_LessThan(DiscreteTime lhs, DiscreteTime rhs)
public bool op_LessThanOrEqual(DiscreteTime lhs, DiscreteTime rhs)
public bool op_GreaterThanOrEqual(DiscreteTime lhs, DiscreteTime rhs)
public DiscreteTime op_Addition(DiscreteTime lhs, DiscreteTime rhs)
public DiscreteTime op_Subtraction(DiscreteTime lhs, DiscreteTime rhs)
public string ToString()
public int GetHashCode()
public DiscreteTime Min(DiscreteTime lhs, DiscreteTime rhs)
public DiscreteTime Max(DiscreteTime lhs, DiscreteTime rhs)
public double SnapToNearestTick(double time)
public float SnapToNearestTick(float time)
public long GetNearestTick(double time)
}
public UnityEngine.Timeline.Extrapolation : object {
public double kMinExtrapolationTime
private Comparison`1<TimelineClip> <>f__am$cache0
internal void CalculateExtrapolationTimes(TrackAsset asset)
private TimelineClip[] SortClipsByStartTime(TimelineClip[] clips)
private int <SortClipsByStartTime>m__0(TimelineClip clip1, TimelineClip clip2)
}
public UnityEngine.Timeline.GroupTrack : TrackAsset {
internal bool compilable
public IEnumerable`1<PlayableBinding> outputs
internal bool get_compilable()
public IEnumerable`1<PlayableBinding> get_outputs()
}
internal UnityEngine.Timeline.HashUtility : object {
public int CombineHash(int h1, int h2)
public int CombineHash(int h1, int h2, int h3)
public int CombineHash(int h1, int h2, int h3, int h4)
public int CombineHash(int h1, int h2, int h3, int h4, int h5)
public int CombineHash(int h1, int h2, int h3, int h4, int h5, int h6)
public int CombineHash(int h1, int h2, int h3, int h4, int h5, int h6, int h7)
public int CombineHash(Int32[] hashes)
}
public UnityEngine.Timeline.IPropertyCollector {
public void PushActiveGameObject(GameObject gameObject)
public void PopActiveGameObject()
public void AddFromClip(AnimationClip clip)
public void AddFromName(string name)
public void AddFromName(string name)
public void AddFromClip(GameObject obj, AnimationClip clip)
public void AddFromName(GameObject obj, string name)
public void AddFromName(GameObject obj, string name)
public void AddFromComponent(GameObject obj, Component component)
public void AddObjectProperties(Object obj, AnimationClip clip)
}
public UnityEngine.Timeline.IPropertyPreview {
public void GatherProperties(PlayableDirector director, IPropertyCollector driver)
}
public UnityEngine.Timeline.ITimeControl {
public void SetTime(double time)
public void OnControlTimeStart()
public void OnControlTimeStop()
}
public UnityEngine.Timeline.ITimelineClipAsset {
public ClipCaps clipCaps
public ClipCaps get_clipCaps()
}
public UnityEngine.Timeline.ITimelineClipLink {
public void LiveLink()
}
internal UnityEngine.Timeline.ITimelineEvaluateCallback {
public void Evaluate()
}
internal UnityEngine.Timeline.MatchTargetFieldConstants : object {
public MatchTargetFields All
public MatchTargetFields None
public MatchTargetFields Position
public MatchTargetFields Rotation
public bool HasAny(MatchTargetFields me, MatchTargetFields fields)
public MatchTargetFields Toggle(MatchTargetFields me, MatchTargetFields flag)
}
public UnityEngine.Timeline.MatchTargetFields : Enum {
public int value__
public MatchTargetFields PositionX
public MatchTargetFields PositionY
public MatchTargetFields PositionZ
public MatchTargetFields RotationX
public MatchTargetFields RotationY
public MatchTargetFields RotationZ
}
public UnityEngine.Timeline.ParticleControlPlayable : PlayableBehaviour {
private float kUnsetTime
private float m_LastTime
private float m_LastPsTime
private UInt32 m_RandomSeed
private ParticleSystem m_ParticleSystem
public ParticleSystem particleSystem
public ScriptPlayable`1<ParticleControlPlayable> Create(PlayableGraph graph, ParticleSystem component, UInt32 randomSeed)
public ParticleSystem get_particleSystem()
public void Initialize(ParticleSystem particleSystem, UInt32 randomSeed)
public void PrepareFrame(Playable playable, FrameData data)
public void OnBehaviourPlay(Playable playable, FrameData info)
public void OnBehaviourPause(Playable playable, FrameData info)
}
public UnityEngine.Timeline.PlayableTrack : TrackAsset {
public TimelineClip CreateClip()
internal void OnCreateClipFromAsset(Object asset, TimelineClip newClip)
}
public UnityEngine.Timeline.PrefabControlPlayable : PlayableBehaviour {
private GameObject m_Instance
public GameObject prefabInstance
public ScriptPlayable`1<PrefabControlPlayable> Create(PlayableGraph graph, GameObject prefabGameObject, Transform parentTransform)
public GameObject get_prefabInstance()
public GameObject Initialize(GameObject prefabGameObject, Transform parentTransform)
public void OnPlayableDestroy(Playable playable)
public void OnBehaviourPlay(Playable playable, FrameData info)
public void OnBehaviourPause(Playable playable, FrameData info)
private void SetHideFlagsRecursive(GameObject gameObject)
}
internal UnityEngine.Timeline.RuntimeClip : RuntimeClipBase {
private TimelineClip m_Clip
private Playable m_Playable
private Playable m_ParentMixer
public double start
public double duration
public TimelineClip clip
public Playable mixer
public Playable playable
public bool enable
public void .ctor(TimelineClip clip, Playable clipPlayable, Playable parentMixer)
public double get_start()
public double get_duration()
private void Create(TimelineClip clip, Playable clipPlayable, Playable parentMixer)
public TimelineClip get_clip()
public Playable get_mixer()
public Playable get_playable()
public void set_enable(bool value)
public void SetTime(double time)
public void SetDuration(double duration)
public void EvaluateAt(double localTime, FrameData frameData)
}
internal UnityEngine.Timeline.RuntimeClipBase : object {
private int <intervalBit>k__BackingField
public double start
public double duration
public int intervalBit
public bool enable
public long intervalStart
public long intervalEnd
public double get_start()
public double get_duration()
public int get_intervalBit()
public void set_intervalBit(int value)
public void set_enable(bool value)
public void EvaluateAt(double localTime, FrameData frameData)
public long get_intervalStart()
public long get_intervalEnd()
}
internal UnityEngine.Timeline.ScheduleRuntimeClip : RuntimeClipBase {
private TimelineClip m_Clip
private Playable m_Playable
private AudioClipPlayable m_AudioClipPlayable
private Playable m_ParentMixer
private double m_StartDelay
private double m_FinishTail
private bool m_Started
public double start
public double duration
public TimelineClip clip
public Playable mixer
public Playable playable
public bool enable
public void .ctor(TimelineClip clip, Playable clipPlayable, Playable parentMixer, double startDelay, double finishTail)
public double get_start()
public double get_duration()
public void SetTime(double time)
public TimelineClip get_clip()
public Playable get_mixer()
public Playable get_playable()
private void Create(TimelineClip clip, Playable clipPlayable, Playable parentMixer, double startDelay, double finishTail)
public void set_enable(bool value)
public void EvaluateAt(double localTime, FrameData frameData)
}
internal UnityEngine.Timeline.SupportsChildTracksAttribute : Attribute {
public Type childType
public int levels
public void .ctor(Type childType, int levels)
}
public UnityEngine.Timeline.TimeControlPlayable : PlayableBehaviour {
private ITimeControl m_timeControl
private bool m_started
public ScriptPlayable`1<TimeControlPlayable> Create(PlayableGraph graph, ITimeControl timeControl)
public void Initialize(ITimeControl timeControl)
public void PrepareFrame(Playable playable, FrameData info)
public void OnBehaviourPlay(Playable playable, FrameData info)
public void OnBehaviourPause(Playable playable, FrameData info)
}
public UnityEngine.Timeline.TimelineAsset : PlayableAsset {
private int m_Id
private int m_NextId
private List`1<TrackAsset> m_Tracks
private double m_FixedDuration
private TrackAsset[] m_CacheOutputTracks
private List`1<TrackAsset> m_CacheFlattenedTracks
private EditorSettings m_EditorSettings
public SequenceUpdateMode m_UpdateMode
public string m_ParameterName
public DurationMode m_DurationMode
private Predicate`1<TrackAsset> <>f__am$cache0
public EditorSettings editorSettings
public double duration
public double fixedDuration
public DurationMode durationMode
public IEnumerable`1<PlayableBinding> outputs
public ClipCaps clipCaps
public int outputTrackCount
public int rootTrackCount
internal int id
internal IEnumerable`1<TrackAsset> flattenedTracks
internal List`1<TrackAsset> tracks
public EditorSettings get_editorSettings()
public double get_duration()
public double get_fixedDuration()
public void set_fixedDuration(double value)
public DurationMode get_durationMode()
public void set_durationMode(DurationMode value)
public IEnumerable`1<PlayableBinding> get_outputs()
public ClipCaps get_clipCaps()
public int get_outputTrackCount()
public int get_rootTrackCount()
public TrackAsset GetRootTrack(int index)
public IEnumerable`1<TrackAsset> GetRootTracks()
public TrackAsset GetOutputTrack(int index)
public IEnumerable`1<TrackAsset> GetOutputTracks()
private void UpdateOutputTrackCache()
public void OnEnable()
internal int get_id()
internal void set_id(int value)
internal IEnumerable`1<TrackAsset> get_flattenedTracks()
internal List`1<TrackAsset> get_tracks()
internal void AddTrackInternal(TrackAsset track)
internal void AddTrackBefore(TrackAsset track, TrackAsset before)
internal void AddTrackAfter(TrackAsset track, TrackAsset after)
internal void MoveTracks(List`1<TrackAsset> tracks, TrackAsset insertAfterAsset, bool up)
internal void RemoveTrack(TrackAsset track)
internal int GenerateNewId()
public Playable CreatePlayable(PlayableGraph graph, GameObject go)
private void UnityEngine.ISerializationCallbackReceiver.OnAfterDeserialize()
private void UnityEngine.ISerializationCallbackReceiver.OnBeforeSerialize()
public void GatherProperties(PlayableDirector director, IPropertyCollector driver)
internal void Invalidate()
private double CalculateDuration()
private void AddSubTracksRecursive(TrackAsset track, List`1& allTracks)
public TrackAsset CreateTrack(Type type, TrackAsset parent, string name)
public T CreateTrack(TrackAsset parent, string name)
public bool DeleteClip(TimelineClip clip)
public bool DeleteTrack(TrackAsset track)
internal TrackAsset AllocateTrack(TrackAsset parent, string name, Type trackType)
private void DeleteRecordingClip(TrackAsset track)
private void DeleteRecordedAnimation(TimelineClip clip)
private bool <OnEnable>m__0(TrackAsset t)
}
public UnityEngine.Timeline.TimelineClip : object {
public ClipCaps kDefaultClipCaps
public float kDefaultClipDurationInSeconds
public double kTimeScaleMin
public double kTimeScaleMax
internal double kMinDuration
internal double kMaxTimeValue
private double m_Start
private double m_ClipIn
private Object m_Asset
private Object m_UnderlyingAsset
private double m_Duration
private int m_ParentID
private double m_TimeScale
private AnimationCurve m_BlendCurve
private TrackAsset m_ParentTrack
private double m_EaseInDuration
private double m_EaseOutDuration
private double m_BlendInDuration
private double m_BlendOutDuration
private AnimationCurve m_MixInCurve
private AnimationCurve m_MixOutCurve
private BlendCurveMode m_BlendInCurveMode
private BlendCurveMode m_BlendOutCurveMode
private List`1<string> m_ExposedParameterNames
private AnimationClip m_AnimationCurves
private bool m_Recordable
private ClipExtrapolation m_PostExtrapolationMode
private ClipExtrapolation m_PreExtrapolationMode
private double m_PostExtrapolationTime
private double m_PreExtrapolationTime
private string m_DisplayName
private int <dirtyHash>k__BackingField
private bool <recordingSelected>k__BackingField
internal int dirtyHash
public bool hasPreExtrapolation
public bool hasPostExtrapolation
public double timeScale
public double start
public double duration
public double end
public double clipIn
public string displayName
public double clipAssetDuration
public AnimationClip curves
public Object asset
public Object underlyingAsset
internal TrackAsset parentTrack
public double easeInDuration
public double easeOutDuration
public double eastOutTime
public double blendInDuration
public double blendOutDuration
public BlendCurveMode blendInCurveMode
public BlendCurveMode blendOutCurveMode
public bool hasBlendIn
public bool hasBlendOut
public AnimationCurve mixInCurve
public float mixInPercentage
public double mixInDuration
public AnimationCurve mixOutCurve
public double mixOutTime
public double mixOutDuration
public float mixOutPercentage
public bool recordable
public bool locked
public bool recordingSelected
public List`1<string> exposedParameters
public ClipCaps clipCaps
public AnimationClip animationClip
public ClipExtrapolation postExtrapolationMode
public ClipExtrapolation preExtrapolationMode
public double extrapolatedStart
public double extrapolatedDuration
internal void .ctor(TrackAsset parent)
internal int get_dirtyHash()
internal void set_dirtyHash(int value)
public bool get_hasPreExtrapolation()
public bool get_hasPostExtrapolation()
public double get_timeScale()
public void set_timeScale(double value)
public double get_start()
public void set_start(double value)
public double get_duration()
public void set_duration(double value)
public double get_end()
public double get_clipIn()
public void set_clipIn(double value)
public string get_displayName()
public void set_displayName(string value)
public double get_clipAssetDuration()
public AnimationClip get_curves()
public Object get_asset()
public void set_asset(Object value)
public Object get_underlyingAsset()
public void set_underlyingAsset(Object value)
internal TrackAsset get_parentTrack()
internal void set_parentTrack(TrackAsset value)
public double get_easeInDuration()
public void set_easeInDuration(double value)
public double get_easeOutDuration()
public void set_easeOutDuration(double value)
public double get_eastOutTime()
public double get_blendInDuration()
public void set_blendInDuration(double value)
public double get_blendOutDuration()
public void set_blendOutDuration(double value)
public BlendCurveMode get_blendInCurveMode()
public void set_blendInCurveMode(BlendCurveMode value)
public BlendCurveMode get_blendOutCurveMode()
public void set_blendOutCurveMode(BlendCurveMode value)
public bool get_hasBlendIn()
public bool get_hasBlendOut()
public AnimationCurve get_mixInCurve()
public void set_mixInCurve(AnimationCurve value)
public float get_mixInPercentage()
public double get_mixInDuration()
public AnimationCurve get_mixOutCurve()
public void set_mixOutCurve(AnimationCurve value)
public double get_mixOutTime()
public double get_mixOutDuration()
public float get_mixOutPercentage()
public bool get_recordable()
internal void set_recordable(bool value)
public bool get_locked()
public bool get_recordingSelected()
public void set_recordingSelected(bool value)
public List`1<string> get_exposedParameters()
public ClipCaps get_clipCaps()
internal int Hash()
public float EvaluateMixOut(double localTime)
public float EvaluateMixIn(double localTime)
private AnimationCurve GetDefaultMixInCurve()
private AnimationCurve GetDefaultMixOutCurve()
public double ToLocalTime(double time)
public double ToLocalTimeUnbound(double time)
internal double FromLocalTimeUnbound(double time)
public AnimationClip get_animationClip()
private double SanitizeTimeValue(double value, double defaultValue)
public ClipExtrapolation get_postExtrapolationMode()
internal void set_postExtrapolationMode(ClipExtrapolation value)
public ClipExtrapolation get_preExtrapolationMode()
internal void set_preExtrapolationMode(ClipExtrapolation value)
internal void SetPostExtrapolationTime(double time)
internal void SetPreExtrapolationTime(double time)
public bool IsExtrapolatedTime(double sequenceTime)
public bool IsPreExtrapolatedTime(double sequenceTime)
public bool IsPostExtrapolatedTime(double sequenceTime)
public double get_extrapolatedStart()
public double get_extrapolatedDuration()
private double GetExtrapolatedTime(double time, ClipExtrapolation mode, double duration)
internal void AllocateAnimatedParameterCurves()
internal void ClearAnimatedParameterCurves()
}
internal UnityEngine.Timeline.TimelineClipCapsExtensions : object {
public bool SupportsLooping(TimelineClip clip)
public bool SupportsExtrapolation(TimelineClip clip)
public bool SupportsClipIn(TimelineClip clip)
public bool SupportsSpeedMultiplier(TimelineClip clip)
public bool SupportsBlending(TimelineClip clip)
public bool HasAll(ClipCaps caps, ClipCaps flags)
public bool HasAny(ClipCaps caps, ClipCaps flags)
}
internal UnityEngine.Timeline.TimelineCreateUtilities : object {
public string GenerateUniqueActorName(TimelineAsset timeline, string prefix)
public void SaveAssetIntoObject(Object childAsset, Object masterAsset)
internal bool ValidateParentTrack(TrackAsset parent, Type childType)
}
public UnityEngine.Timeline.TimelinePlayable : PlayableBehaviour {
private IntervalTree`1<RuntimeClipBase> m_IntervalTree
private List`1<RuntimeClipBase> m_ActiveClips
private List`1<RuntimeClipBase> m_CurrentListOfActiveClips
private int m_ActiveBit
private List`1<ITimelineEvaluateCallback> m_EvaluateCallbacks
private Dictionary`2<TrackAsset, ConnectionCache> m_PlayableCache
public ScriptPlayable`1<TimelinePlayable> Create(PlayableGraph graph, IEnumerable`1<TrackAsset> tracks, GameObject go, bool autoRebalance, bool createOutputs)
public void Compile(PlayableGraph graph, Playable timelinePlayable, IEnumerable`1<TrackAsset> tracks, GameObject go, bool autoRebalance, bool createOutputs)
private void AllocateDefaultTracks(PlayableGraph graph, Playable timelinePlayable, IList`1<TrackAsset> tracks, GameObject go)
private void CompileTrackList(PlayableGraph graph, Playable timelinePlayable, IEnumerable`1<TrackAsset> tracks, GameObject go, bool createOutputs)
private void CreateTrackOutput(PlayableGraph graph, TrackAsset track, Playable playable, int port)
private Playable CreatePlayableGraph(PlayableGraph graph, TrackAsset asset, GameObject go, IntervalTree`1<RuntimeClipBase> tree)
private Playable CreateTrackPlayable(PlayableGraph graph, Playable timelinePlayable, TrackAsset track, GameObject go, bool createOutputs)
public void PrepareFrame(Playable playable, FrameData info)
private void Evaluate(Playable playable, FrameData frameData)
private void CacheTrack(TrackAsset track, Playable playable, int port, Playable parent)
}
internal UnityEngine.Timeline.TimelineUndo : object {
public void PushDestroyUndo(TimelineAsset timeline, Object thingToDirty, Object objectToDestroy, string operation)
public void PushUndo(Object thingToDirty, string operation)
}
internal UnityEngine.Timeline.TimeUtility : object {
public double kTimeEpsilon
private Func`2<char, bool> <>f__am$cache0
private Func`2<char, bool> <>f__am$cache1
private void ValidateFrameRate(double frameRate)
public int ToFrames(double time, double frameRate)
public double ToExactFrames(double time, double frameRate)
public double FromFrames(int frames, double frameRate)
public double FromFrames(double frames, double frameRate)
public bool OnFrameBoundary(double time, double frameRate)
public bool OnFrameBoundary(double time, double frameRate, double epsilon)
public string TimeAsFrames(double timeValue, double frameRate, string format)
public string TimeAsTimeCode(double timeValue, double frameRate, string format)
public double ParseTimeCode(string timeCode, double frameRate, double defaultValue)
private string RemoveChar(string str, Func`2<char, bool> charToRemoveFunc)
private bool <ParseTimeCode>m__0(char c)
private bool <ParseTimeCode>m__1(char c)
}
public UnityEngine.Timeline.TrackAsset : PlayableAsset {
private bool m_Locked
private bool m_Muted
private bool m_Soloed
private float m_Height
private string m_CustomPlayableFullTypename
private AnimationClip m_AnimClip
private PlayableAsset m_Parent
private List`1<TrackAsset> m_Children
private int m_ClipsHash
private TimelineClip[] m_ClipsCache
private DiscreteTime m_Start
private DiscreteTime m_End
private MediaType m_MediaType
private Dictionary`2<Type, TrackBindingTypeAttribute> s_TrackBindingTypeAttributeCache
protected internal List`1<TimelineClip> m_Clips
private int <intervalBit>k__BackingField
private Comparison`1<TimelineClip> <>f__am$cache0
public int intervalBit
public double start
public double end
public double duration
public bool muted
public TimelineAsset timelineAsset
public PlayableAsset parent
internal TimelineClip[] clips
public bool isEmpty
public bool isSubTrack
public IEnumerable`1<PlayableBinding> outputs
internal string customPlayableTypename
internal AnimationClip animClip
internal bool soloed
internal float height
internal List`1<TrackAsset> subTracks
internal bool locked
internal MediaType mediaType
internal bool compilable
public int get_intervalBit()
public void set_intervalBit(int value)
public double get_start()
public double get_end()
public double get_duration()
public bool get_muted()
public void set_muted(bool value)
public TimelineAsset get_timelineAsset()
public PlayableAsset get_parent()
internal void set_parent(PlayableAsset value)
public IEnumerable`1<TimelineClip> GetClips()
internal TimelineClip[] get_clips()
public bool get_isEmpty()
public bool get_isSubTrack()
public IEnumerable`1<PlayableBinding> get_outputs()
public IEnumerable`1<TrackAsset> GetChildTracks()
internal string get_customPlayableTypename()
internal void set_customPlayableTypename(string value)
internal AnimationClip get_animClip()
internal void set_animClip(AnimationClip value)
internal bool get_soloed()
internal void set_soloed(bool value)
internal float get_height()
internal void set_height(float value)
internal List`1<TrackAsset> get_subTracks()
internal void set_subTracks(List`1<TrackAsset> value)
internal bool get_locked()
internal void set_locked(bool value)
internal MediaType get_mediaType()
internal bool get_compilable()
public void OnBeforeSerialize()
public void OnAfterDeserialize()
public void OnEnable()
public Playable CreateTrackMixer(PlayableGraph graph, GameObject go, int inputCount)
public Playable CreatePlayable(PlayableGraph graph, GameObject go)
public TimelineClip CreateDefaultClip()
internal TimelineClip CreateClipOfType(Type type)
internal void AddClip(TimelineClip newClip)
internal Playable CreatePlayableGraph(PlayableGraph graph, GameObject go, IntervalTree`1<RuntimeClipBase> tree)
internal Playable OnCreatePlayableGraph(PlayableGraph graph, GameObject go, IntervalTree`1<RuntimeClipBase> tree)
internal bool IsCompatibleWithClip(TimelineClip clip)
internal void SortClips()
internal void SetClips(List`1<TimelineClip> timelineClips)
internal TimelineClip CreateClipFromAsset(Object asset)
internal void OnCreateClipFromAsset(Object asset, TimelineClip clip)
internal TimelineClip CreateNewClipContainerInternal()
internal void AddChild(TrackAsset child)
internal bool AddChildAfter(TrackAsset child, TrackAsset other)
internal bool RemoveSubTrack(TrackAsset child)
internal void RemoveClip(TimelineClip clip)
internal void GetEvaluationTime(Double& outStart, Double& outDuration)
internal void GetSequenceTime(Double& outStart, Double& outDuration)
public void GatherProperties(PlayableDirector director, IPropertyCollector driver)
internal GameObject GetGameObjectBinding(PlayableDirector director)
private bool ValidateClipType(Type clipType)
private TimelineClip NestPlayableAsset(PlayableAsset asset)
private void UpdateDuration()
protected internal Playable CreatePlayable(PlayableGraph graph, GameObject go, TimelineClip clip)
private void InvalidateTimelineCaches()
private MediaType GetMediaType(Type t)
private int <SortClips>m__0(TimelineClip clip1, TimelineClip clip2)
}
public UnityEngine.Timeline.TrackAssetExtensions : object {
public GroupTrack GetGroup(TrackAsset asset)
public void SetGroup(TrackAsset asset, GroupTrack group)
}
public UnityEngine.Timeline.TrackBindingTypeAttribute : Attribute {
public Type type
public void .ctor(Type type)
}
public UnityEngine.Timeline.TrackClipTypeAttribute : Attribute {
public Type inspectedType
public void .ctor(Type clipClass)
}
public UnityEngine.Timeline.TrackColorAttribute : Attribute {
private Color m_Color
public Color color
public void .ctor(float r, float g, float b)
public Color get_color()
}
public UnityEngine.Timeline.TrackMediaType : Attribute {
public MediaType m_MediaType
public void .ctor(MediaType mt)
}
internal UnityEngine.Timeline.WeightUtility : object {
public float NormalizeMixer(Playable mixer)
}
