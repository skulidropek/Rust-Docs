public System.Net.Http.ByteArrayContent : HttpContent {
private Byte[] content
private int offset
private int count
public void .ctor(Byte[] content)
public void .ctor(Byte[] content, int offset, int count)
protected Task`1<Stream> CreateContentReadStreamAsync()
protected Task SerializeToStreamAsync(Stream stream, TransportContext context)
protected internal bool TryComputeLength(Int64& length)
}
internal System.Net.Http.CancellationHelper : object {
private string s_cancellationMessage
internal bool ShouldWrapInOperationCanceledException(Exception exception, CancellationToken cancellationToken)
internal Exception CreateOperationCanceledException(Exception innerException, CancellationToken cancellationToken)
private void ThrowOperationCanceledException(Exception innerException, CancellationToken cancellationToken)
internal void ThrowIfCancellationRequested(CancellationToken cancellationToken)
}
public System.Net.Http.ClientCertificateOption : Enum {
public int value__
public ClientCertificateOption Manual
public ClientCertificateOption Automatic
}
internal System.Net.Http.ConnectHelper : object {
private Segment<ConnectEventArgs> s_connectEventArgs
public ValueTask`1<ValueTuple`2<Socket, Stream>> ConnectAsync(string host, int port, CancellationToken cancellationToken)
public ValueTask`1<SslStream> EstablishSslConnectionAsync(SslClientAuthenticationOptions sslOptions, HttpRequestMessage request, Stream stream, CancellationToken cancellationToken)
private ValueTask`1<SslStream> EstablishSslConnectionAsyncCore(Stream stream, SslClientAuthenticationOptions sslOptions, CancellationToken cancellationToken)
}
public System.Net.Http.DelegatingHandler : HttpMessageHandler {
private bool disposed
private HttpMessageHandler handler
public HttpMessageHandler InnerHandler
protected void .ctor(HttpMessageHandler innerHandler)
public HttpMessageHandler get_InnerHandler()
public void set_InnerHandler(HttpMessageHandler value)
protected void Dispose(bool disposing)
protected internal Task`1<HttpResponseMessage> SendAsync(HttpRequestMessage request, CancellationToken cancellationToken)
}
public System.Net.Http.FormUrlEncodedContent : ByteArrayContent {
public void .ctor(IEnumerable`1<KeyValuePair`2<string, string>> nameValueCollection)
private Byte[] EncodeContent(IEnumerable`1<KeyValuePair`2<string, string>> nameValueCollection)
private Byte[] SerializeValue(string value)
}
public System.Net.Http.Headers.AuthenticationHeaderValue : object {
private string <Parameter>k__BackingField
private string <Scheme>k__BackingField
public string Parameter
public string Scheme
public void .ctor(string scheme)
public void .ctor(string scheme, string parameter)
public string get_Parameter()
private void set_Parameter(string value)
public string get_Scheme()
private void set_Scheme(string value)
private object System.ICloneable.Clone()
public bool Equals(object obj)
public int GetHashCode()
public AuthenticationHeaderValue Parse(string input)
public bool TryParse(string input, AuthenticationHeaderValue& parsedValue)
internal bool TryParse(string input, int minimalCount, List`1& result)
private bool TryParseElement(Lexer lexer, AuthenticationHeaderValue& parsedValue, Token& t)
public string ToString()
}
public System.Net.Http.Headers.CacheControlHeaderValue : object {
private List`1<NameValueHeaderValue> extensions
private List`1<string> no_cache_headers
private List`1<string> private_headers
private Nullable`1<TimeSpan> <MaxAge>k__BackingField
private bool <MaxStale>k__BackingField
private Nullable`1<TimeSpan> <MaxStaleLimit>k__BackingField
private Nullable`1<TimeSpan> <MinFresh>k__BackingField
private bool <MustRevalidate>k__BackingField
private bool <NoCache>k__BackingField
private bool <NoStore>k__BackingField
private bool <NoTransform>k__BackingField
private bool <OnlyIfCached>k__BackingField
private bool <Private>k__BackingField
private bool <ProxyRevalidate>k__BackingField
private bool <Public>k__BackingField
private Nullable`1<TimeSpan> <SharedMaxAge>k__BackingField
public ICollection`1<NameValueHeaderValue> Extensions
public Nullable`1<TimeSpan> MaxAge
public bool MaxStale
public Nullable`1<TimeSpan> MaxStaleLimit
public Nullable`1<TimeSpan> MinFresh
public bool MustRevalidate
public bool NoCache
public ICollection`1<string> NoCacheHeaders
public bool NoStore
public bool NoTransform
public bool OnlyIfCached
public bool Private
public ICollection`1<string> PrivateHeaders
public bool ProxyRevalidate
public bool Public
public Nullable`1<TimeSpan> SharedMaxAge
public ICollection`1<NameValueHeaderValue> get_Extensions()
public Nullable`1<TimeSpan> get_MaxAge()
public void set_MaxAge(Nullable`1<TimeSpan> value)
public bool get_MaxStale()
public void set_MaxStale(bool value)
public Nullable`1<TimeSpan> get_MaxStaleLimit()
public void set_MaxStaleLimit(Nullable`1<TimeSpan> value)
public Nullable`1<TimeSpan> get_MinFresh()
public void set_MinFresh(Nullable`1<TimeSpan> value)
public bool get_MustRevalidate()
public void set_MustRevalidate(bool value)
public bool get_NoCache()
public void set_NoCache(bool value)
public ICollection`1<string> get_NoCacheHeaders()
public bool get_NoStore()
public void set_NoStore(bool value)
public bool get_NoTransform()
public void set_NoTransform(bool value)
public bool get_OnlyIfCached()
public void set_OnlyIfCached(bool value)
public bool get_Private()
public void set_Private(bool value)
public ICollection`1<string> get_PrivateHeaders()
public bool get_ProxyRevalidate()
public void set_ProxyRevalidate(bool value)
public bool get_Public()
public void set_Public(bool value)
public Nullable`1<TimeSpan> get_SharedMaxAge()
public void set_SharedMaxAge(Nullable`1<TimeSpan> value)
private object System.ICloneable.Clone()
public bool Equals(object obj)
public int GetHashCode()
public CacheControlHeaderValue Parse(string input)
public bool TryParse(string input, CacheControlHeaderValue& parsedValue)
public string ToString()
}
internal System.Net.Http.Headers.CollectionExtensions : object {
public bool SequenceEqual(List`1<TSource> first, List`1<TSource> second)
public void SetValue(List`1<NameValueHeaderValue> parameters, string key, string value)
public string ToString(List`1<T> list)
public void ToStringBuilder(List`1<T> list, StringBuilder sb)
}
internal System.Net.Http.Headers.CollectionParser : object {
public bool TryParse(string input, int minimalCount, ElementTryParser`1<T> parser, List`1& result)
public bool TryParse(string input, int minimalCount, List`1& result)
public bool TryParseRepetition(string input, int minimalCount, List`1& result)
private bool TryParseStringElement(Lexer lexer, String& parsedValue, Token& t)
public bool TryParseRepetition(string input, int minimalCount, ElementTryParser`1<T> parser, List`1& result)
}
public System.Net.Http.Headers.ContentDispositionHeaderValue : object {
private string dispositionType
private List`1<NameValueHeaderValue> parameters
public Nullable`1<DateTimeOffset> CreationDate
public string DispositionType
public string FileName
public string FileNameStar
public Nullable`1<DateTimeOffset> ModificationDate
public string Name
public ICollection`1<NameValueHeaderValue> Parameters
public Nullable`1<DateTimeOffset> ReadDate
public Nullable`1<long> Size
public void .ctor(string dispositionType)
protected void .ctor(ContentDispositionHeaderValue source)
public Nullable`1<DateTimeOffset> get_CreationDate()
public void set_CreationDate(Nullable`1<DateTimeOffset> value)
public string get_DispositionType()
public void set_DispositionType(string value)
public string get_FileName()
public void set_FileName(string value)
public string get_FileNameStar()
public void set_FileNameStar(string value)
public Nullable`1<DateTimeOffset> get_ModificationDate()
public void set_ModificationDate(Nullable`1<DateTimeOffset> value)
public string get_Name()
public void set_Name(string value)
public ICollection`1<NameValueHeaderValue> get_Parameters()
public Nullable`1<DateTimeOffset> get_ReadDate()
public void set_ReadDate(Nullable`1<DateTimeOffset> value)
public Nullable`1<long> get_Size()
public void set_Size(Nullable`1<long> value)
private object System.ICloneable.Clone()
public bool Equals(object obj)
private string FindParameter(string name)
private Nullable`1<DateTimeOffset> GetDateValue(string name)
private string EncodeBase64Value(string value)
private string EncodeRFC5987(string value)
private string DecodeValue(string value, bool extendedNotation)
public int GetHashCode()
public ContentDispositionHeaderValue Parse(string input)
private void SetDateValue(string key, Nullable`1<DateTimeOffset> value)
private void SetValue(string key, string value)
public string ToString()
public bool TryParse(string input, ContentDispositionHeaderValue& parsedValue)
}
public System.Net.Http.Headers.ContentRangeHeaderValue : object {
private string unit
private Nullable`1<long> <From>k__BackingField
private Nullable`1<long> <Length>k__BackingField
private Nullable`1<long> <To>k__BackingField
public Nullable`1<long> From
public bool HasLength
public bool HasRange
public Nullable`1<long> Length
public Nullable`1<long> To
public string Unit
public void .ctor(long length)
public void .ctor(long from, long to)
public void .ctor(long from, long to, long length)
public Nullable`1<long> get_From()
private void set_From(Nullable`1<long> value)
public bool get_HasLength()
public bool get_HasRange()
public Nullable`1<long> get_Length()
private void set_Length(Nullable`1<long> value)
public Nullable`1<long> get_To()
private void set_To(Nullable`1<long> value)
public string get_Unit()
public void set_Unit(string value)
private object System.ICloneable.Clone()
public bool Equals(object obj)
public int GetHashCode()
public ContentRangeHeaderValue Parse(string input)
public bool TryParse(string input, ContentRangeHeaderValue& parsedValue)
public string ToString()
}
internal System.Net.Http.Headers.ElementTryParser`1 : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public bool Invoke(Lexer lexer, T& parsedValue, Token& token)
public IAsyncResult BeginInvoke(Lexer lexer, T& parsedValue, Token& token, AsyncCallback callback, object object)
public bool EndInvoke(T& parsedValue, Token& token, IAsyncResult result)
}
public System.Net.Http.Headers.EntityTagHeaderValue : object {
private EntityTagHeaderValue any
private bool <IsWeak>k__BackingField
private string <Tag>k__BackingField
public EntityTagHeaderValue Any
public bool IsWeak
public string Tag
public void .ctor(string tag)
public void .ctor(string tag, bool isWeak)
public EntityTagHeaderValue get_Any()
public bool get_IsWeak()
internal void set_IsWeak(bool value)
public string get_Tag()
internal void set_Tag(string value)
private object System.ICloneable.Clone()
public bool Equals(object obj)
public int GetHashCode()
public EntityTagHeaderValue Parse(string input)
public bool TryParse(string input, EntityTagHeaderValue& parsedValue)
private bool TryParseElement(Lexer lexer, EntityTagHeaderValue& parsedValue, Token& t)
internal bool TryParse(string input, int minimalCount, List`1& result)
public string ToString()
}
internal System.Net.Http.Headers.HashCodeCalculator : object {
public int Calculate(ICollection`1<T> list)
}
internal System.Net.Http.Headers.HeaderInfo : object {
public bool AllowsMany
public HttpHeaderKind HeaderKind
public string Name
private Func`2<object, string> <CustomToString>k__BackingField
public Func`2<object, string> CustomToString
public string Separator
protected void .ctor(string name, HttpHeaderKind headerKind)
public HeaderInfo CreateSingle(string name, TryParseDelegate`1<T> parser, HttpHeaderKind headerKind, Func`2<object, string> toString)
public HeaderInfo CreateMulti(string name, TryParseListDelegate`1<T> elementParser, HttpHeaderKind headerKind, int minimalCount, string separator)
public object CreateCollection(HttpHeaders headers)
public Func`2<object, string> get_CustomToString()
private void set_CustomToString(Func`2<object, string> value)
public string get_Separator()
public void AddToCollection(object collection, object value)
protected object CreateCollection(HttpHeaders headers, HeaderInfo headerInfo)
public List`1<string> ToStringCollection(object collection)
public bool TryParse(string value, Object& result)
}
public System.Net.Http.Headers.HttpContentHeaders : HttpHeaders {
private HttpContent content
public ICollection`1<string> Allow
public ICollection`1<string> ContentEncoding
public ContentDispositionHeaderValue ContentDisposition
public ICollection`1<string> ContentLanguage
public Nullable`1<long> ContentLength
public Uri ContentLocation
public Byte[] ContentMD5
public ContentRangeHeaderValue ContentRange
public MediaTypeHeaderValue ContentType
public Nullable`1<DateTimeOffset> Expires
public Nullable`1<DateTimeOffset> LastModified
internal void .ctor(HttpContent content)
public ICollection`1<string> get_Allow()
public ICollection`1<string> get_ContentEncoding()
public ContentDispositionHeaderValue get_ContentDisposition()
public void set_ContentDisposition(ContentDispositionHeaderValue value)
public ICollection`1<string> get_ContentLanguage()
public Nullable`1<long> get_ContentLength()
public void set_ContentLength(Nullable`1<long> value)
public Uri get_ContentLocation()
public void set_ContentLocation(Uri value)
public Byte[] get_ContentMD5()
public void set_ContentMD5(Byte[] value)
public ContentRangeHeaderValue get_ContentRange()
public void set_ContentRange(ContentRangeHeaderValue value)
public MediaTypeHeaderValue get_ContentType()
public void set_ContentType(MediaTypeHeaderValue value)
public Nullable`1<DateTimeOffset> get_Expires()
public void set_Expires(Nullable`1<DateTimeOffset> value)
public Nullable`1<DateTimeOffset> get_LastModified()
public void set_LastModified(Nullable`1<DateTimeOffset> value)
}
internal System.Net.Http.Headers.HttpHeaderKind : Enum {
public int value__
public HttpHeaderKind None
public HttpHeaderKind Request
public HttpHeaderKind Response
public HttpHeaderKind Content
}
public System.Net.Http.Headers.HttpHeaders : object {
private Dictionary`2<string, HeaderInfo> known_headers
private Dictionary`2<string, HeaderBucket> headers
private HttpHeaderKind HeaderKind
internal Nullable`1<bool> connectionclose
internal Nullable`1<bool> transferEncodingChunked
internal void .ctor(HttpHeaderKind headerKind)
public void Add(string name, string value)
public void Add(string name, IEnumerable`1<string> values)
internal bool AddValue(string value, HeaderInfo headerInfo, bool ignoreInvalid)
private bool AddInternal(string name, IEnumerable`1<string> values, HeaderInfo headerInfo, bool ignoreInvalid)
public bool TryAddWithoutValidation(string name, string value)
public bool TryAddWithoutValidation(string name, IEnumerable`1<string> values)
private HeaderInfo CheckName(string name)
private bool TryCheckName(string name, HeaderInfo& headerInfo)
public void Clear()
public bool Contains(string name)
public IEnumerator`1<KeyValuePair`2<string, IEnumerable`1<string>>> GetEnumerator()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
public IEnumerable`1<string> GetValues(string name)
public bool Remove(string name)
public bool TryGetValues(string name, IEnumerable`1& values)
internal string GetSingleHeaderString(string key, IEnumerable`1<string> values)
public string ToString()
internal void AddOrRemove(string name, string value)
internal void AddOrRemove(string name, T value, Func`2<object, string> converter)
internal void AddOrRemove(string name, Nullable`1<T> value)
internal void AddOrRemove(string name, Nullable`1<T> value, Func`2<object, string> converter)
private List`1<string> GetAllHeaderValues(HeaderBucket bucket, HeaderInfo headerInfo)
internal HttpHeaderKind GetKnownHeaderKind(string name)
internal T GetValue(string name)
internal HttpHeaderValueCollection`1<T> GetValues(string name)
internal void SetValue(string name, T value, Func`2<object, string> toStringConverter)
}
public System.Net.Http.Headers.HttpHeaderValueCollection`1 : object {
private List`1<T> list
private HttpHeaders headers
private HeaderInfo headerInfo
private List`1<string> invalidValues
public int Count
internal List`1<string> InvalidValues
public bool IsReadOnly
internal void .ctor(HttpHeaders headers, HeaderInfo headerInfo)
public int get_Count()
internal List`1<string> get_InvalidValues()
public bool get_IsReadOnly()
public void Add(T item)
internal void AddRange(List`1<T> values)
internal void AddInvalidValue(string invalidValue)
public void Clear()
public bool Contains(T item)
public void CopyTo(T[] array, int arrayIndex)
public void ParseAdd(string input)
public bool Remove(T item)
public string ToString()
public bool TryParseAdd(string input)
public IEnumerator`1<T> GetEnumerator()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
internal T Find(Predicate`1<T> predicate)
internal void Remove(Predicate`1<T> predicate)
}
public System.Net.Http.Headers.HttpRequestHeaders : HttpHeaders {
private Nullable`1<bool> expectContinue
public HttpHeaderValueCollection`1<MediaTypeWithQualityHeaderValue> Accept
public HttpHeaderValueCollection`1<StringWithQualityHeaderValue> AcceptCharset
public HttpHeaderValueCollection`1<StringWithQualityHeaderValue> AcceptEncoding
public HttpHeaderValueCollection`1<StringWithQualityHeaderValue> AcceptLanguage
public AuthenticationHeaderValue Authorization
public CacheControlHeaderValue CacheControl
public HttpHeaderValueCollection`1<string> Connection
public Nullable`1<bool> ConnectionClose
internal bool ConnectionKeepAlive
public Nullable`1<DateTimeOffset> Date
public HttpHeaderValueCollection`1<NameValueWithParametersHeaderValue> Expect
public Nullable`1<bool> ExpectContinue
public string From
public string Host
public HttpHeaderValueCollection`1<EntityTagHeaderValue> IfMatch
public Nullable`1<DateTimeOffset> IfModifiedSince
public HttpHeaderValueCollection`1<EntityTagHeaderValue> IfNoneMatch
public RangeConditionHeaderValue IfRange
public Nullable`1<DateTimeOffset> IfUnmodifiedSince
public Nullable`1<int> MaxForwards
public HttpHeaderValueCollection`1<NameValueHeaderValue> Pragma
public AuthenticationHeaderValue ProxyAuthorization
public RangeHeaderValue Range
public Uri Referrer
public HttpHeaderValueCollection`1<TransferCodingWithQualityHeaderValue> TE
public HttpHeaderValueCollection`1<string> Trailer
public HttpHeaderValueCollection`1<TransferCodingHeaderValue> TransferEncoding
public Nullable`1<bool> TransferEncodingChunked
public HttpHeaderValueCollection`1<ProductHeaderValue> Upgrade
public HttpHeaderValueCollection`1<ProductInfoHeaderValue> UserAgent
public HttpHeaderValueCollection`1<ViaHeaderValue> Via
public HttpHeaderValueCollection`1<WarningHeaderValue> Warning
public HttpHeaderValueCollection`1<MediaTypeWithQualityHeaderValue> get_Accept()
public HttpHeaderValueCollection`1<StringWithQualityHeaderValue> get_AcceptCharset()
public HttpHeaderValueCollection`1<StringWithQualityHeaderValue> get_AcceptEncoding()
public HttpHeaderValueCollection`1<StringWithQualityHeaderValue> get_AcceptLanguage()
public AuthenticationHeaderValue get_Authorization()
public void set_Authorization(AuthenticationHeaderValue value)
public CacheControlHeaderValue get_CacheControl()
public void set_CacheControl(CacheControlHeaderValue value)
public HttpHeaderValueCollection`1<string> get_Connection()
public Nullable`1<bool> get_ConnectionClose()
public void set_ConnectionClose(Nullable`1<bool> value)
internal bool get_ConnectionKeepAlive()
public Nullable`1<DateTimeOffset> get_Date()
public void set_Date(Nullable`1<DateTimeOffset> value)
public HttpHeaderValueCollection`1<NameValueWithParametersHeaderValue> get_Expect()
public Nullable`1<bool> get_ExpectContinue()
public void set_ExpectContinue(Nullable`1<bool> value)
public string get_From()
public void set_From(string value)
public string get_Host()
public void set_Host(string value)
public HttpHeaderValueCollection`1<EntityTagHeaderValue> get_IfMatch()
public Nullable`1<DateTimeOffset> get_IfModifiedSince()
public void set_IfModifiedSince(Nullable`1<DateTimeOffset> value)
public HttpHeaderValueCollection`1<EntityTagHeaderValue> get_IfNoneMatch()
public RangeConditionHeaderValue get_IfRange()
public void set_IfRange(RangeConditionHeaderValue value)
public Nullable`1<DateTimeOffset> get_IfUnmodifiedSince()
public void set_IfUnmodifiedSince(Nullable`1<DateTimeOffset> value)
public Nullable`1<int> get_MaxForwards()
public void set_MaxForwards(Nullable`1<int> value)
public HttpHeaderValueCollection`1<NameValueHeaderValue> get_Pragma()
public AuthenticationHeaderValue get_ProxyAuthorization()
public void set_ProxyAuthorization(AuthenticationHeaderValue value)
public RangeHeaderValue get_Range()
public void set_Range(RangeHeaderValue value)
public Uri get_Referrer()
public void set_Referrer(Uri value)
public HttpHeaderValueCollection`1<TransferCodingWithQualityHeaderValue> get_TE()
public HttpHeaderValueCollection`1<string> get_Trailer()
public HttpHeaderValueCollection`1<TransferCodingHeaderValue> get_TransferEncoding()
public Nullable`1<bool> get_TransferEncodingChunked()
public void set_TransferEncodingChunked(Nullable`1<bool> value)
public HttpHeaderValueCollection`1<ProductHeaderValue> get_Upgrade()
public HttpHeaderValueCollection`1<ProductInfoHeaderValue> get_UserAgent()
public HttpHeaderValueCollection`1<ViaHeaderValue> get_Via()
public HttpHeaderValueCollection`1<WarningHeaderValue> get_Warning()
internal void AddHeaders(HttpRequestHeaders headers)
}
public System.Net.Http.Headers.HttpResponseHeaders : HttpHeaders {
public HttpHeaderValueCollection`1<string> AcceptRanges
public Nullable`1<TimeSpan> Age
public CacheControlHeaderValue CacheControl
public HttpHeaderValueCollection`1<string> Connection
public Nullable`1<bool> ConnectionClose
public Nullable`1<DateTimeOffset> Date
public EntityTagHeaderValue ETag
public Uri Location
public HttpHeaderValueCollection`1<NameValueHeaderValue> Pragma
public HttpHeaderValueCollection`1<AuthenticationHeaderValue> ProxyAuthenticate
public RetryConditionHeaderValue RetryAfter
public HttpHeaderValueCollection`1<ProductInfoHeaderValue> Server
public HttpHeaderValueCollection`1<string> Trailer
public HttpHeaderValueCollection`1<TransferCodingHeaderValue> TransferEncoding
public Nullable`1<bool> TransferEncodingChunked
public HttpHeaderValueCollection`1<ProductHeaderValue> Upgrade
public HttpHeaderValueCollection`1<string> Vary
public HttpHeaderValueCollection`1<ViaHeaderValue> Via
public HttpHeaderValueCollection`1<WarningHeaderValue> Warning
public HttpHeaderValueCollection`1<AuthenticationHeaderValue> WwwAuthenticate
public HttpHeaderValueCollection`1<string> get_AcceptRanges()
public Nullable`1<TimeSpan> get_Age()
public void set_Age(Nullable`1<TimeSpan> value)
public CacheControlHeaderValue get_CacheControl()
public void set_CacheControl(CacheControlHeaderValue value)
public HttpHeaderValueCollection`1<string> get_Connection()
public Nullable`1<bool> get_ConnectionClose()
public void set_ConnectionClose(Nullable`1<bool> value)
public Nullable`1<DateTimeOffset> get_Date()
public void set_Date(Nullable`1<DateTimeOffset> value)
public EntityTagHeaderValue get_ETag()
public void set_ETag(EntityTagHeaderValue value)
public Uri get_Location()
public void set_Location(Uri value)
public HttpHeaderValueCollection`1<NameValueHeaderValue> get_Pragma()
public HttpHeaderValueCollection`1<AuthenticationHeaderValue> get_ProxyAuthenticate()
public RetryConditionHeaderValue get_RetryAfter()
public void set_RetryAfter(RetryConditionHeaderValue value)
public HttpHeaderValueCollection`1<ProductInfoHeaderValue> get_Server()
public HttpHeaderValueCollection`1<string> get_Trailer()
public HttpHeaderValueCollection`1<TransferCodingHeaderValue> get_TransferEncoding()
public Nullable`1<bool> get_TransferEncodingChunked()
public void set_TransferEncodingChunked(Nullable`1<bool> value)
public HttpHeaderValueCollection`1<ProductHeaderValue> get_Upgrade()
public HttpHeaderValueCollection`1<string> get_Vary()
public HttpHeaderValueCollection`1<ViaHeaderValue> get_Via()
public HttpHeaderValueCollection`1<WarningHeaderValue> get_Warning()
public HttpHeaderValueCollection`1<AuthenticationHeaderValue> get_WwwAuthenticate()
}
internal System.Net.Http.Headers.Lexer : object {
private Boolean[] token_chars
private int last_token_char
private String[] dt_formats
private string s
private int pos
public int Position
public void .ctor(string stream)
public int get_Position()
public void set_Position(int value)
public string GetStringValue(Token token)
public string GetStringValue(Token start, Token end)
public string GetQuotedStringValue(Token start)
public string GetRemainingStringValue(int position)
public bool IsStarStringValue(Token token)
public bool TryGetNumericValue(Token token, Int32& value)
public bool TryGetNumericValue(Token token, Int64& value)
public Nullable`1<TimeSpan> TryGetTimeSpanValue(Token token)
public bool TryGetDateValue(Token token, DateTimeOffset& value)
public bool TryGetDateValue(string text, DateTimeOffset& value)
public bool TryGetDoubleValue(Token token, Double& value)
public bool IsValidToken(string input)
public bool IsValidCharacter(char input)
public void EatChar()
public int PeekChar()
public bool ScanCommentOptional(String& value)
public bool ScanCommentOptional(String& value, Token& readToken)
public Token Scan(bool recognizeDash)
}
public System.Net.Http.Headers.MediaTypeHeaderValue : object {
internal List`1<NameValueHeaderValue> parameters
internal string media_type
public string CharSet
public string MediaType
public ICollection`1<NameValueHeaderValue> Parameters
public void .ctor(string mediaType)
protected void .ctor(MediaTypeHeaderValue source)
public string get_CharSet()
public void set_CharSet(string value)
public string get_MediaType()
public void set_MediaType(string value)
public ICollection`1<NameValueHeaderValue> get_Parameters()
private object System.ICloneable.Clone()
public bool Equals(object obj)
public int GetHashCode()
public MediaTypeHeaderValue Parse(string input)
public string ToString()
public bool TryParse(string input, MediaTypeHeaderValue& parsedValue)
internal Nullable`1<Token> TryParseMediaType(Lexer lexer, String& media)
}
public System.Net.Http.Headers.MediaTypeWithQualityHeaderValue : MediaTypeHeaderValue {
public Nullable`1<double> Quality
public void .ctor(string mediaType)
public void .ctor(string mediaType, double quality)
public Nullable`1<double> get_Quality()
public void set_Quality(Nullable`1<double> value)
public MediaTypeWithQualityHeaderValue Parse(string input)
public bool TryParse(string input, MediaTypeWithQualityHeaderValue& parsedValue)
private bool TryParseElement(Lexer lexer, MediaTypeWithQualityHeaderValue& parsedValue, Token& t)
internal bool TryParse(string input, int minimalCount, List`1& result)
}
public System.Net.Http.Headers.NameValueHeaderValue : object {
internal string value
private string <Name>k__BackingField
public string Name
public string Value
public void .ctor(string name)
public void .ctor(string name, string value)
protected internal void .ctor(NameValueHeaderValue source)
public string get_Name()
internal void set_Name(string value)
public string get_Value()
public void set_Value(string value)
internal NameValueHeaderValue Create(string name, string value)
private object System.ICloneable.Clone()
public int GetHashCode()
public bool Equals(object obj)
public NameValueHeaderValue Parse(string input)
internal bool TryParsePragma(string input, int minimalCount, List`1& result)
internal bool TryParseParameters(Lexer lexer, List`1& result, Token& t)
public string ToString()
public bool TryParse(string input, NameValueHeaderValue& parsedValue)
private bool TryParseElement(Lexer lexer, NameValueHeaderValue& parsedValue, Token& t)
}
public System.Net.Http.Headers.NameValueWithParametersHeaderValue : NameValueHeaderValue {
private List`1<NameValueHeaderValue> parameters
public ICollection`1<NameValueHeaderValue> Parameters
public void .ctor(string name)
public void .ctor(string name, string value)
protected void .ctor(NameValueWithParametersHeaderValue source)
public ICollection`1<NameValueHeaderValue> get_Parameters()
private object System.ICloneable.Clone()
public bool Equals(object obj)
public int GetHashCode()
public NameValueWithParametersHeaderValue Parse(string input)
public string ToString()
public bool TryParse(string input, NameValueWithParametersHeaderValue& parsedValue)
internal bool TryParse(string input, int minimalCount, List`1& result)
private bool TryParseElement(Lexer lexer, NameValueWithParametersHeaderValue& parsedValue, Token& t)
}
public System.Net.Http.Headers.ProductHeaderValue : object {
private string <Name>k__BackingField
private string <Version>k__BackingField
public string Name
public string Version
public void .ctor(string name)
public void .ctor(string name, string version)
public string get_Name()
internal void set_Name(string value)
public string get_Version()
internal void set_Version(string value)
private object System.ICloneable.Clone()
public bool Equals(object obj)
public int GetHashCode()
public ProductHeaderValue Parse(string input)
public bool TryParse(string input, ProductHeaderValue& parsedValue)
internal bool TryParse(string input, int minimalCount, List`1& result)
private bool TryParseElement(Lexer lexer, ProductHeaderValue& parsedValue, Token& t)
public string ToString()
}
public System.Net.Http.Headers.ProductInfoHeaderValue : object {
private string <Comment>k__BackingField
private ProductHeaderValue <Product>k__BackingField
public string Comment
public ProductHeaderValue Product
public void .ctor(ProductHeaderValue product)
public void .ctor(string comment)
public void .ctor(string productName, string productVersion)
public string get_Comment()
private void set_Comment(string value)
public ProductHeaderValue get_Product()
private void set_Product(ProductHeaderValue value)
private object System.ICloneable.Clone()
public bool Equals(object obj)
public int GetHashCode()
public ProductInfoHeaderValue Parse(string input)
public bool TryParse(string input, ProductInfoHeaderValue& parsedValue)
internal bool TryParse(string input, int minimalCount, List`1& result)
private bool TryParseElement(Lexer lexer, ProductInfoHeaderValue& parsedValue)
public string ToString()
}
internal System.Net.Http.Headers.QualityValue : object {
public Nullable`1<double> GetValue(List`1<NameValueHeaderValue> parameters)
public void SetValue(List`1& parameters, Nullable`1<double> value)
}
public System.Net.Http.Headers.RangeConditionHeaderValue : object {
private Nullable`1<DateTimeOffset> <Date>k__BackingField
private EntityTagHeaderValue <EntityTag>k__BackingField
public Nullable`1<DateTimeOffset> Date
public EntityTagHeaderValue EntityTag
public void .ctor(DateTimeOffset date)
public void .ctor(EntityTagHeaderValue entityTag)
public void .ctor(string entityTag)
public Nullable`1<DateTimeOffset> get_Date()
private void set_Date(Nullable`1<DateTimeOffset> value)
public EntityTagHeaderValue get_EntityTag()
private void set_EntityTag(EntityTagHeaderValue value)
private object System.ICloneable.Clone()
public bool Equals(object obj)
public int GetHashCode()
public RangeConditionHeaderValue Parse(string input)
public bool TryParse(string input, RangeConditionHeaderValue& parsedValue)
public string ToString()
}
public System.Net.Http.Headers.RangeHeaderValue : object {
private List`1<RangeItemHeaderValue> ranges
private string unit
public ICollection`1<RangeItemHeaderValue> Ranges
public string Unit
public void .ctor(Nullable`1<long> from, Nullable`1<long> to)
private void .ctor(RangeHeaderValue source)
public ICollection`1<RangeItemHeaderValue> get_Ranges()
public string get_Unit()
public void set_Unit(string value)
private object System.ICloneable.Clone()
public bool Equals(object obj)
public int GetHashCode()
public RangeHeaderValue Parse(string input)
public bool TryParse(string input, RangeHeaderValue& parsedValue)
public string ToString()
}
public System.Net.Http.Headers.RangeItemHeaderValue : object {
private Nullable`1<long> <From>k__BackingField
private Nullable`1<long> <To>k__BackingField
public Nullable`1<long> From
public Nullable`1<long> To
public void .ctor(Nullable`1<long> from, Nullable`1<long> to)
public Nullable`1<long> get_From()
private void set_From(Nullable`1<long> value)
public Nullable`1<long> get_To()
private void set_To(Nullable`1<long> value)
private object System.ICloneable.Clone()
public bool Equals(object obj)
public int GetHashCode()
public string ToString()
}
public System.Net.Http.Headers.RetryConditionHeaderValue : object {
private Nullable`1<DateTimeOffset> <Date>k__BackingField
private Nullable`1<TimeSpan> <Delta>k__BackingField
public Nullable`1<DateTimeOffset> Date
public Nullable`1<TimeSpan> Delta
public void .ctor(DateTimeOffset date)
public void .ctor(TimeSpan delta)
public Nullable`1<DateTimeOffset> get_Date()
private void set_Date(Nullable`1<DateTimeOffset> value)
public Nullable`1<TimeSpan> get_Delta()
private void set_Delta(Nullable`1<TimeSpan> value)
private object System.ICloneable.Clone()
public bool Equals(object obj)
public int GetHashCode()
public RetryConditionHeaderValue Parse(string input)
public bool TryParse(string input, RetryConditionHeaderValue& parsedValue)
public string ToString()
}
public System.Net.Http.Headers.StringWithQualityHeaderValue : object {
private Nullable`1<double> <Quality>k__BackingField
private string <Value>k__BackingField
public Nullable`1<double> Quality
public string Value
public void .ctor(string value)
public void .ctor(string value, double quality)
public Nullable`1<double> get_Quality()
private void set_Quality(Nullable`1<double> value)
public string get_Value()
private void set_Value(string value)
private object System.ICloneable.Clone()
public bool Equals(object obj)
public int GetHashCode()
public StringWithQualityHeaderValue Parse(string input)
public bool TryParse(string input, StringWithQualityHeaderValue& parsedValue)
internal bool TryParse(string input, int minimalCount, List`1& result)
private bool TryParseElement(Lexer lexer, StringWithQualityHeaderValue& parsedValue, Token& t)
public string ToString()
}
internal System.Net.Http.Headers.Token : ValueType {
public Token Empty
private Type type
private int <StartPosition>k__BackingField
private int <EndPosition>k__BackingField
public int StartPosition
public int EndPosition
public Type Kind
public void .ctor(Type type, int startPosition, int endPosition)
public int get_StartPosition()
private void set_StartPosition(int value)
public int get_EndPosition()
private void set_EndPosition(int value)
public Type get_Kind()
public Type op_Implicit(Token token)
public string ToString()
}
public System.Net.Http.Headers.TransferCodingHeaderValue : object {
internal string value
internal List`1<NameValueHeaderValue> parameters
public ICollection`1<NameValueHeaderValue> Parameters
public string Value
public void .ctor(string value)
protected void .ctor(TransferCodingHeaderValue source)
public ICollection`1<NameValueHeaderValue> get_Parameters()
public string get_Value()
private object System.ICloneable.Clone()
public bool Equals(object obj)
public int GetHashCode()
public TransferCodingHeaderValue Parse(string input)
public string ToString()
public bool TryParse(string input, TransferCodingHeaderValue& parsedValue)
internal bool TryParse(string input, int minimalCount, List`1& result)
private bool TryParseElement(Lexer lexer, TransferCodingHeaderValue& parsedValue, Token& t)
}
public System.Net.Http.Headers.TransferCodingWithQualityHeaderValue : TransferCodingHeaderValue {
public Nullable`1<double> Quality
public void .ctor(string value)
public void .ctor(string value, double quality)
public Nullable`1<double> get_Quality()
public void set_Quality(Nullable`1<double> value)
public TransferCodingWithQualityHeaderValue Parse(string input)
public bool TryParse(string input, TransferCodingWithQualityHeaderValue& parsedValue)
internal bool TryParse(string input, int minimalCount, List`1& result)
private bool TryParseElement(Lexer lexer, TransferCodingWithQualityHeaderValue& parsedValue, Token& t)
}
internal System.Net.Http.Headers.TryParseDelegate`1 : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public bool Invoke(string value, T& result)
public IAsyncResult BeginInvoke(string value, T& result, AsyncCallback callback, object object)
public bool EndInvoke(T& result, IAsyncResult __result)
}
internal System.Net.Http.Headers.TryParseListDelegate`1 : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public bool Invoke(string value, int minimalCount, List`1& result)
public IAsyncResult BeginInvoke(string value, int minimalCount, List`1& result, AsyncCallback callback, object object)
public bool EndInvoke(List`1& result, IAsyncResult __result)
}
public System.Net.Http.Headers.ViaHeaderValue : object {
private string <Comment>k__BackingField
private string <ProtocolName>k__BackingField
private string <ProtocolVersion>k__BackingField
private string <ReceivedBy>k__BackingField
public string Comment
public string ProtocolName
public string ProtocolVersion
public string ReceivedBy
public void .ctor(string protocolVersion, string receivedBy)
public void .ctor(string protocolVersion, string receivedBy, string protocolName)
public void .ctor(string protocolVersion, string receivedBy, string protocolName, string comment)
public string get_Comment()
private void set_Comment(string value)
public string get_ProtocolName()
private void set_ProtocolName(string value)
public string get_ProtocolVersion()
private void set_ProtocolVersion(string value)
public string get_ReceivedBy()
private void set_ReceivedBy(string value)
private object System.ICloneable.Clone()
public bool Equals(object obj)
public int GetHashCode()
public ViaHeaderValue Parse(string input)
public bool TryParse(string input, ViaHeaderValue& parsedValue)
internal bool TryParse(string input, int minimalCount, List`1& result)
private bool TryParseElement(Lexer lexer, ViaHeaderValue& parsedValue, Token& t)
public string ToString()
}
public System.Net.Http.Headers.WarningHeaderValue : object {
private string <Agent>k__BackingField
private int <Code>k__BackingField
private Nullable`1<DateTimeOffset> <Date>k__BackingField
private string <Text>k__BackingField
public string Agent
public int Code
public Nullable`1<DateTimeOffset> Date
public string Text
public void .ctor(int code, string agent, string text)
public void .ctor(int code, string agent, string text, DateTimeOffset date)
public string get_Agent()
private void set_Agent(string value)
public int get_Code()
private void set_Code(int value)
public Nullable`1<DateTimeOffset> get_Date()
private void set_Date(Nullable`1<DateTimeOffset> value)
public string get_Text()
private void set_Text(string value)
private bool IsCodeValid(int code)
private object System.ICloneable.Clone()
public bool Equals(object obj)
public int GetHashCode()
public WarningHeaderValue Parse(string input)
public bool TryParse(string input, WarningHeaderValue& parsedValue)
internal bool TryParse(string input, int minimalCount, List`1& result)
private bool TryParseElement(Lexer lexer, WarningHeaderValue& parsedValue, Token& t)
public string ToString()
}
public System.Net.Http.HttpClient : HttpMessageInvoker {
private TimeSpan TimeoutDefault
private Uri base_address
private CancellationTokenSource cts
private bool disposed
private HttpRequestHeaders headers
private long buffer_size
private TimeSpan timeout
public Uri BaseAddress
public HttpRequestHeaders DefaultRequestHeaders
public long MaxResponseContentBufferSize
public TimeSpan Timeout
public void .ctor(HttpMessageHandler handler)
public void .ctor(HttpMessageHandler handler, bool disposeHandler)
public Uri get_BaseAddress()
public void set_BaseAddress(Uri value)
public HttpRequestHeaders get_DefaultRequestHeaders()
public long get_MaxResponseContentBufferSize()
public void set_MaxResponseContentBufferSize(long value)
public TimeSpan get_Timeout()
public void set_Timeout(TimeSpan value)
public void CancelPendingRequests()
protected void Dispose(bool disposing)
public Task`1<HttpResponseMessage> DeleteAsync(string requestUri)
public Task`1<HttpResponseMessage> DeleteAsync(string requestUri, CancellationToken cancellationToken)
public Task`1<HttpResponseMessage> DeleteAsync(Uri requestUri)
public Task`1<HttpResponseMessage> DeleteAsync(Uri requestUri, CancellationToken cancellationToken)
public Task`1<HttpResponseMessage> GetAsync(string requestUri)
public Task`1<HttpResponseMessage> GetAsync(string requestUri, CancellationToken cancellationToken)
public Task`1<HttpResponseMessage> GetAsync(string requestUri, HttpCompletionOption completionOption)
public Task`1<HttpResponseMessage> GetAsync(string requestUri, HttpCompletionOption completionOption, CancellationToken cancellationToken)
public Task`1<HttpResponseMessage> GetAsync(Uri requestUri)
public Task`1<HttpResponseMessage> GetAsync(Uri requestUri, CancellationToken cancellationToken)
public Task`1<HttpResponseMessage> GetAsync(Uri requestUri, HttpCompletionOption completionOption)
public Task`1<HttpResponseMessage> GetAsync(Uri requestUri, HttpCompletionOption completionOption, CancellationToken cancellationToken)
public Task`1<HttpResponseMessage> PostAsync(string requestUri, HttpContent content)
public Task`1<HttpResponseMessage> PostAsync(string requestUri, HttpContent content, CancellationToken cancellationToken)
public Task`1<HttpResponseMessage> PostAsync(Uri requestUri, HttpContent content)
public Task`1<HttpResponseMessage> PostAsync(Uri requestUri, HttpContent content, CancellationToken cancellationToken)
public Task`1<HttpResponseMessage> PutAsync(Uri requestUri, HttpContent content)
public Task`1<HttpResponseMessage> PutAsync(Uri requestUri, HttpContent content, CancellationToken cancellationToken)
public Task`1<HttpResponseMessage> PutAsync(string requestUri, HttpContent content)
public Task`1<HttpResponseMessage> PutAsync(string requestUri, HttpContent content, CancellationToken cancellationToken)
public Task`1<HttpResponseMessage> SendAsync(HttpRequestMessage request)
public Task`1<HttpResponseMessage> SendAsync(HttpRequestMessage request, HttpCompletionOption completionOption)
public Task`1<HttpResponseMessage> SendAsync(HttpRequestMessage request, CancellationToken cancellationToken)
public Task`1<HttpResponseMessage> SendAsync(HttpRequestMessage request, HttpCompletionOption completionOption, CancellationToken cancellationToken)
private Task`1<HttpResponseMessage> SendAsyncWorker(HttpRequestMessage request, HttpCompletionOption completionOption, CancellationToken cancellationToken)
public Task`1<Byte[]> GetByteArrayAsync(string requestUri)
public Task`1<Byte[]> GetByteArrayAsync(Uri requestUri)
public Task`1<Stream> GetStreamAsync(string requestUri)
public Task`1<Stream> GetStreamAsync(Uri requestUri)
public Task`1<string> GetStringAsync(string requestUri)
public Task`1<string> GetStringAsync(Uri requestUri)
public Task`1<HttpResponseMessage> PatchAsync(string requestUri, HttpContent content)
public Task`1<HttpResponseMessage> PatchAsync(string requestUri, HttpContent content, CancellationToken cancellationToken)
public Task`1<HttpResponseMessage> PatchAsync(Uri requestUri, HttpContent content)
public Task`1<HttpResponseMessage> PatchAsync(Uri requestUri, HttpContent content, CancellationToken cancellationToken)
private Task`1<HttpResponseMessage> <>n__0(HttpRequestMessage request, CancellationToken cancellationToken)
}
public System.Net.Http.HttpClientHandler : HttpMessageHandler {
private IMonoHttpClientHandler _delegatingHandler
private ClientCertificateOption _clientCertificateOptions
public Func`5<HttpRequestMessage, X509Certificate2, X509Chain, SslPolicyErrors, bool> DangerousAcceptAnyServerCertificateValidator
public bool SupportsAutomaticDecompression
public bool SupportsProxy
public bool SupportsRedirectConfiguration
public bool UseCookies
public CookieContainer CookieContainer
public ClientCertificateOption ClientCertificateOptions
public X509CertificateCollection ClientCertificates
public Func`5<HttpRequestMessage, X509Certificate2, X509Chain, SslPolicyErrors, bool> ServerCertificateCustomValidationCallback
public bool CheckCertificateRevocationList
public SslProtocols SslProtocols
public DecompressionMethods AutomaticDecompression
public bool UseProxy
public IWebProxy Proxy
public ICredentials DefaultProxyCredentials
public bool PreAuthenticate
public bool UseDefaultCredentials
public ICredentials Credentials
public bool AllowAutoRedirect
public int MaxAutomaticRedirections
public int MaxConnectionsPerServer
public int MaxResponseHeadersLength
public long MaxRequestContentBufferSize
public IDictionary`2<string, object> Properties
private IMonoHttpClientHandler CreateDefaultHandler()
public Func`5<HttpRequestMessage, X509Certificate2, X509Chain, SslPolicyErrors, bool> get_DangerousAcceptAnyServerCertificateValidator()
internal void .ctor(IMonoHttpClientHandler handler)
protected void Dispose(bool disposing)
public bool get_SupportsAutomaticDecompression()
public bool get_SupportsProxy()
public bool get_SupportsRedirectConfiguration()
public bool get_UseCookies()
public void set_UseCookies(bool value)
public CookieContainer get_CookieContainer()
public void set_CookieContainer(CookieContainer value)
private void ThrowForModifiedManagedSslOptionsIfStarted()
public ClientCertificateOption get_ClientCertificateOptions()
public void set_ClientCertificateOptions(ClientCertificateOption value)
public X509CertificateCollection get_ClientCertificates()
public Func`5<HttpRequestMessage, X509Certificate2, X509Chain, SslPolicyErrors, bool> get_ServerCertificateCustomValidationCallback()
public void set_ServerCertificateCustomValidationCallback(Func`5<HttpRequestMessage, X509Certificate2, X509Chain, SslPolicyErrors, bool> value)
public bool get_CheckCertificateRevocationList()
public void set_CheckCertificateRevocationList(bool value)
public SslProtocols get_SslProtocols()
public void set_SslProtocols(SslProtocols value)
public DecompressionMethods get_AutomaticDecompression()
public void set_AutomaticDecompression(DecompressionMethods value)
public bool get_UseProxy()
public void set_UseProxy(bool value)
public IWebProxy get_Proxy()
public void set_Proxy(IWebProxy value)
public ICredentials get_DefaultProxyCredentials()
public void set_DefaultProxyCredentials(ICredentials value)
public bool get_PreAuthenticate()
public void set_PreAuthenticate(bool value)
public bool get_UseDefaultCredentials()
public void set_UseDefaultCredentials(bool value)
public ICredentials get_Credentials()
public void set_Credentials(ICredentials value)
public bool get_AllowAutoRedirect()
public void set_AllowAutoRedirect(bool value)
public int get_MaxAutomaticRedirections()
public void set_MaxAutomaticRedirections(int value)
public int get_MaxConnectionsPerServer()
public void set_MaxConnectionsPerServer(int value)
public int get_MaxResponseHeadersLength()
public void set_MaxResponseHeadersLength(int value)
public long get_MaxRequestContentBufferSize()
public void set_MaxRequestContentBufferSize(long value)
public IDictionary`2<string, object> get_Properties()
internal void SetWebRequestTimeout(TimeSpan timeout)
protected internal Task`1<HttpResponseMessage> SendAsync(HttpRequestMessage request, CancellationToken cancellationToken)
private X509Certificate <set_ClientCertificateOptions>b__23_0(object sender, string targetHost, X509CertificateCollection localCertificates, X509Certificate remoteCertificate, String[] acceptableIssuers)
}
public System.Net.Http.HttpCompletionOption : Enum {
public int value__
public HttpCompletionOption ResponseContentRead
public HttpCompletionOption ResponseHeadersRead
}
public System.Net.Http.HttpContent : object {
private FixedMemoryStream buffer
private Stream stream
private bool disposed
private HttpContentHeaders headers
public HttpContentHeaders Headers
internal Nullable`1<long> LoadedBufferLength
public HttpContentHeaders get_Headers()
internal Nullable`1<long> get_LoadedBufferLength()
internal void CopyTo(Stream stream)
public Task CopyToAsync(Stream stream)
public Task CopyToAsync(Stream stream, TransportContext context)
protected Task`1<Stream> CreateContentReadStreamAsync()
private FixedMemoryStream CreateFixedMemoryStream(long maxBufferSize)
public void Dispose()
protected void Dispose(bool disposing)
public Task LoadIntoBufferAsync()
public Task LoadIntoBufferAsync(long maxBufferSize)
public Task`1<Stream> ReadAsStreamAsync()
public Task`1<Byte[]> ReadAsByteArrayAsync()
public Task`1<string> ReadAsStringAsync()
private Encoding GetEncodingFromBuffer(Byte[] buffer, int length, Int32& preambleLength)
private int StartsWith(Byte[] array, int length, Byte[] value)
internal Task SerializeToStreamAsync_internal(Stream stream, TransportContext context)
protected Task SerializeToStreamAsync(Stream stream, TransportContext context)
protected internal bool TryComputeLength(Int64& length)
}
public System.Net.Http.HttpMessageHandler : object {
public void Dispose()
protected void Dispose(bool disposing)
protected internal Task`1<HttpResponseMessage> SendAsync(HttpRequestMessage request, CancellationToken cancellationToken)
}
public System.Net.Http.HttpMessageInvoker : object {
private protected HttpMessageHandler handler
private bool disposeHandler
public void .ctor(HttpMessageHandler handler)
public void .ctor(HttpMessageHandler handler, bool disposeHandler)
public void Dispose()
protected void Dispose(bool disposing)
public Task`1<HttpResponseMessage> SendAsync(HttpRequestMessage request, CancellationToken cancellationToken)
}
public System.Net.Http.HttpMethod : object {
private HttpMethod delete_method
private HttpMethod get_method
private HttpMethod head_method
private HttpMethod options_method
private HttpMethod post_method
private HttpMethod put_method
private HttpMethod trace_method
private string method
public HttpMethod Delete
public HttpMethod Get
public HttpMethod Head
public string Method
public HttpMethod Options
public HttpMethod Post
public HttpMethod Put
public HttpMethod Trace
public HttpMethod Patch
public void .ctor(string method)
public HttpMethod get_Delete()
public HttpMethod get_Get()
public HttpMethod get_Head()
public string get_Method()
public HttpMethod get_Options()
public HttpMethod get_Post()
public HttpMethod get_Put()
public HttpMethod get_Trace()
public bool op_Equality(HttpMethod left, HttpMethod right)
public bool op_Inequality(HttpMethod left, HttpMethod right)
public bool Equals(HttpMethod other)
public bool Equals(object obj)
public int GetHashCode()
public string ToString()
public HttpMethod get_Patch()
}
public System.Net.Http.HttpRequestException : Exception {
public void .ctor(string message)
public void .ctor(string message, Exception inner)
}
public System.Net.Http.HttpRequestMessage : object {
private HttpRequestHeaders headers
private HttpMethod method
private Version version
private Dictionary`2<string, object> properties
private Uri uri
private bool is_used
private bool disposed
private HttpContent <Content>k__BackingField
public HttpContent Content
public HttpRequestHeaders Headers
public HttpMethod Method
public IDictionary`2<string, object> Properties
public Uri RequestUri
public Version Version
public void .ctor(HttpMethod method, string requestUri)
public void .ctor(HttpMethod method, Uri requestUri)
public HttpContent get_Content()
public void set_Content(HttpContent value)
public HttpRequestHeaders get_Headers()
public HttpMethod get_Method()
public void set_Method(HttpMethod value)
public IDictionary`2<string, object> get_Properties()
public Uri get_RequestUri()
public void set_RequestUri(Uri value)
private bool IsAllowedAbsoluteUri(Uri uri)
public Version get_Version()
public void set_Version(Version value)
public void Dispose()
protected void Dispose(bool disposing)
internal bool SetIsUsed()
public string ToString()
}
public System.Net.Http.HttpResponseMessage : object {
private HttpResponseHeaders headers
private HttpResponseHeaders trailingHeaders
private string reasonPhrase
private HttpStatusCode statusCode
private Version version
private bool disposed
private HttpContent <Content>k__BackingField
private HttpRequestMessage <RequestMessage>k__BackingField
public HttpContent Content
public HttpResponseHeaders Headers
public bool IsSuccessStatusCode
public string ReasonPhrase
public HttpRequestMessage RequestMessage
public HttpStatusCode StatusCode
public Version Version
public HttpResponseHeaders TrailingHeaders
public void .ctor(HttpStatusCode statusCode)
public HttpContent get_Content()
public void set_Content(HttpContent value)
public HttpResponseHeaders get_Headers()
public bool get_IsSuccessStatusCode()
public string get_ReasonPhrase()
public void set_ReasonPhrase(string value)
public HttpRequestMessage get_RequestMessage()
public void set_RequestMessage(HttpRequestMessage value)
public HttpStatusCode get_StatusCode()
public void set_StatusCode(HttpStatusCode value)
public Version get_Version()
public void set_Version(Version value)
public void Dispose()
protected void Dispose(bool disposing)
public HttpResponseMessage EnsureSuccessStatusCode()
public string ToString()
public HttpResponseHeaders get_TrailingHeaders()
}
internal System.Net.Http.IMonoHttpClientHandler {
public bool SupportsAutomaticDecompression
public bool UseCookies
public CookieContainer CookieContainer
public SslClientAuthenticationOptions SslOptions
public DecompressionMethods AutomaticDecompression
public bool UseProxy
public IWebProxy Proxy
public ICredentials DefaultProxyCredentials
public bool PreAuthenticate
public ICredentials Credentials
public bool AllowAutoRedirect
public int MaxAutomaticRedirections
public int MaxConnectionsPerServer
public int MaxResponseHeadersLength
public long MaxRequestContentBufferSize
public IDictionary`2<string, object> Properties
public bool get_SupportsAutomaticDecompression()
public bool get_UseCookies()
public void set_UseCookies(bool value)
public CookieContainer get_CookieContainer()
public void set_CookieContainer(CookieContainer value)
public SslClientAuthenticationOptions get_SslOptions()
public void set_SslOptions(SslClientAuthenticationOptions value)
public DecompressionMethods get_AutomaticDecompression()
public void set_AutomaticDecompression(DecompressionMethods value)
public bool get_UseProxy()
public void set_UseProxy(bool value)
public IWebProxy get_Proxy()
public void set_Proxy(IWebProxy value)
public ICredentials get_DefaultProxyCredentials()
public void set_DefaultProxyCredentials(ICredentials value)
public bool get_PreAuthenticate()
public void set_PreAuthenticate(bool value)
public ICredentials get_Credentials()
public void set_Credentials(ICredentials value)
public bool get_AllowAutoRedirect()
public void set_AllowAutoRedirect(bool value)
public int get_MaxAutomaticRedirections()
public void set_MaxAutomaticRedirections(int value)
public int get_MaxConnectionsPerServer()
public void set_MaxConnectionsPerServer(int value)
public int get_MaxResponseHeadersLength()
public void set_MaxResponseHeadersLength(int value)
public long get_MaxRequestContentBufferSize()
public void set_MaxRequestContentBufferSize(long value)
public IDictionary`2<string, object> get_Properties()
public Task`1<HttpResponseMessage> SendAsync(HttpRequestMessage request, CancellationToken cancellationToken)
public void SetWebRequestTimeout(TimeSpan timeout)
}
public System.Net.Http.MessageProcessingHandler : DelegatingHandler {
protected void .ctor(HttpMessageHandler innerHandler)
protected HttpRequestMessage ProcessRequest(HttpRequestMessage request, CancellationToken cancellationToken)
protected HttpResponseMessage ProcessResponse(HttpResponseMessage response, CancellationToken cancellationToken)
protected internal Task`1<HttpResponseMessage> SendAsync(HttpRequestMessage request, CancellationToken cancellationToken)
private Task`1<HttpResponseMessage> <>n__0(HttpRequestMessage request, CancellationToken cancellationToken)
}
internal System.Net.Http.MonoWebRequestHandler : object {
private long groupCounter
private bool allowAutoRedirect
private DecompressionMethods automaticDecompression
private CookieContainer cookieContainer
private ICredentials credentials
private int maxAutomaticRedirections
private long maxRequestContentBufferSize
private bool preAuthenticate
private IWebProxy proxy
private bool useCookies
private bool useProxy
private SslClientAuthenticationOptions sslOptions
private bool allowPipelining
private RequestCachePolicy cachePolicy
private AuthenticationLevel authenticationLevel
private TimeSpan continueTimeout
private TokenImpersonationLevel impersonationLevel
private int maxResponseHeadersLength
private int readWriteTimeout
private RemoteCertificateValidationCallback serverCertificateValidationCallback
private bool unsafeAuthenticatedConnectionSharing
private bool sentRequest
private string connectionGroupName
private Nullable`1<TimeSpan> timeout
private bool disposed
public bool AllowAutoRedirect
public DecompressionMethods AutomaticDecompression
public CookieContainer CookieContainer
public ICredentials Credentials
public int MaxAutomaticRedirections
public long MaxRequestContentBufferSize
public bool PreAuthenticate
public IWebProxy Proxy
public bool SupportsAutomaticDecompression
public bool SupportsProxy
public bool SupportsRedirectConfiguration
public bool UseCookies
public bool UseProxy
public bool AllowPipelining
public RequestCachePolicy CachePolicy
public AuthenticationLevel AuthenticationLevel
public TimeSpan ContinueTimeout
public TokenImpersonationLevel ImpersonationLevel
public int MaxResponseHeadersLength
public int ReadWriteTimeout
public RemoteCertificateValidationCallback ServerCertificateValidationCallback
public bool UnsafeAuthenticatedConnectionSharing
public SslClientAuthenticationOptions SslOptions
public ICredentials DefaultProxyCredentials
public int MaxConnectionsPerServer
public IDictionary`2<string, object> Properties
internal void EnsureModifiability()
public bool get_AllowAutoRedirect()
public void set_AllowAutoRedirect(bool value)
public DecompressionMethods get_AutomaticDecompression()
public void set_AutomaticDecompression(DecompressionMethods value)
public CookieContainer get_CookieContainer()
public void set_CookieContainer(CookieContainer value)
public ICredentials get_Credentials()
public void set_Credentials(ICredentials value)
public int get_MaxAutomaticRedirections()
public void set_MaxAutomaticRedirections(int value)
public long get_MaxRequestContentBufferSize()
public void set_MaxRequestContentBufferSize(long value)
public bool get_PreAuthenticate()
public void set_PreAuthenticate(bool value)
public IWebProxy get_Proxy()
public void set_Proxy(IWebProxy value)
public bool get_SupportsAutomaticDecompression()
public bool get_SupportsProxy()
public bool get_SupportsRedirectConfiguration()
public bool get_UseCookies()
public void set_UseCookies(bool value)
public bool get_UseProxy()
public void set_UseProxy(bool value)
public bool get_AllowPipelining()
public void set_AllowPipelining(bool value)
public RequestCachePolicy get_CachePolicy()
public void set_CachePolicy(RequestCachePolicy value)
public AuthenticationLevel get_AuthenticationLevel()
public void set_AuthenticationLevel(AuthenticationLevel value)
public TimeSpan get_ContinueTimeout()
public void set_ContinueTimeout(TimeSpan value)
public TokenImpersonationLevel get_ImpersonationLevel()
public void set_ImpersonationLevel(TokenImpersonationLevel value)
public int get_MaxResponseHeadersLength()
public void set_MaxResponseHeadersLength(int value)
public int get_ReadWriteTimeout()
public void set_ReadWriteTimeout(int value)
public RemoteCertificateValidationCallback get_ServerCertificateValidationCallback()
public void set_ServerCertificateValidationCallback(RemoteCertificateValidationCallback value)
public bool get_UnsafeAuthenticatedConnectionSharing()
public void set_UnsafeAuthenticatedConnectionSharing(bool value)
public SslClientAuthenticationOptions get_SslOptions()
public void set_SslOptions(SslClientAuthenticationOptions value)
public void Dispose()
protected void Dispose(bool disposing)
private bool GetConnectionKeepAlive(HttpRequestHeaders headers)
internal HttpWebRequest CreateWebRequest(HttpRequestMessage request)
private HttpResponseMessage CreateResponseMessage(HttpWebResponse wr, HttpRequestMessage requestMessage, CancellationToken cancellationToken)
private bool MethodHasBody(HttpMethod method)
public Task`1<HttpResponseMessage> SendAsync(HttpRequestMessage request, CancellationToken cancellationToken)
public ICredentials get_DefaultProxyCredentials()
public void set_DefaultProxyCredentials(ICredentials value)
public int get_MaxConnectionsPerServer()
public void set_MaxConnectionsPerServer(int value)
public IDictionary`2<string, object> get_Properties()
private void System.Net.Http.IMonoHttpClientHandler.SetWebRequestTimeout(TimeSpan timeout)
}
public System.Net.Http.MultipartContent : HttpContent {
private List`1<HttpContent> nested_content
private string boundary
public void .ctor(string subtype)
public void .ctor(string subtype, string boundary)
private bool IsValidRFC2049(string s)
public void Add(HttpContent content)
protected void Dispose(bool disposing)
protected Task SerializeToStreamAsync(Stream stream, TransportContext context)
protected internal bool TryComputeLength(Int64& length)
public IEnumerator`1<HttpContent> GetEnumerator()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
}
public System.Net.Http.MultipartFormDataContent : MultipartContent {
public void .ctor(string boundary)
public void Add(HttpContent content)
public void Add(HttpContent content, string name)
public void Add(HttpContent content, string name, string fileName)
private void AddContentDisposition(HttpContent content, string name, string fileName)
}
internal System.Net.Http.PlatformHelper : object {
internal bool IsContentHeader(string name)
internal string GetSingleHeaderString(string name, IEnumerable`1<string> values)
internal StreamContent CreateStreamContent(Stream stream, CancellationToken cancellationToken)
}
public System.Net.Http.ReadOnlyMemoryContent : HttpContent {
public void .ctor(ReadOnlyMemory`1<byte> content)
protected Task SerializeToStreamAsync(Stream stream, TransportContext context)
protected internal bool TryComputeLength(Int64& length)
}
public System.Net.Http.StreamContent : HttpContent {
private Stream content
private int bufferSize
private CancellationToken cancellationToken
private long startPosition
private bool contentCopied
public void .ctor(Stream content)
public void .ctor(Stream content, int bufferSize)
internal void .ctor(Stream content, CancellationToken cancellationToken)
protected Task`1<Stream> CreateContentReadStreamAsync()
protected void Dispose(bool disposing)
protected Task SerializeToStreamAsync(Stream stream, TransportContext context)
protected internal bool TryComputeLength(Int64& length)
}
public System.Net.Http.StringContent : ByteArrayContent {
public void .ctor(string content)
public void .ctor(string content, Encoding encoding)
public void .ctor(string content, Encoding encoding, string mediaType)
private Byte[] GetByteArray(string content, Encoding encoding)
}
internal Unity.ThrowStub : ObjectDisposedException {
public void ThrowNotSupportedException()
}
