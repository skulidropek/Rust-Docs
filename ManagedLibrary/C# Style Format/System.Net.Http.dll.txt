public class System.Net.Http.ByteArrayContent : HttpContent {
    
private Byte[] content;
    
private int offset;
    
private int count;
    public ByteArrayContent(Byte[] content);
    public ByteArrayContent(Byte[] content, int offset, int count);
    protected virtual Task`1<Stream> CreateContentReadStreamAsync();
    protected virtual Task SerializeToStreamAsync(Stream stream, TransportContext context);
    protected internal virtual bool TryComputeLength(Int64& length);
}
internal static class System.Net.Http.CancellationHelper : object {
    
private static string s_cancellationMessage;
    private static CancellationHelper();
    internal static bool ShouldWrapInOperationCanceledException(Exception exception, CancellationToken cancellationToken);
    internal static Exception CreateOperationCanceledException(Exception innerException, CancellationToken cancellationToken);
    private static void ThrowOperationCanceledException(Exception innerException, CancellationToken cancellationToken);
    internal static void ThrowIfCancellationRequested(CancellationToken cancellationToken);
}
public enum System.Net.Http.ClientCertificateOption : Enum {
    
public int value__;
    
public static ClientCertificateOption Manual;
    
public static ClientCertificateOption Automatic;
}
internal static class System.Net.Http.ConnectHelper : object {
    
private static Segment<ConnectEventArgs> s_connectEventArgs;
    private static ConnectHelper();
    [AsyncStateMachineAttribute("System.Net.Http.ConnectHelper/<ConnectAsync>d__2")]
public static ValueTask`1<ValueTuple`2<Socket, Stream>> ConnectAsync(string host, int port, CancellationToken cancellationToken);
    public static ValueTask`1<SslStream> EstablishSslConnectionAsync(SslClientAuthenticationOptions sslOptions, HttpRequestMessage request, Stream stream, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.Net.Http.ConnectHelper/<EstablishSslConnectionAsyncCore>d__5")]
private static ValueTask`1<SslStream> EstablishSslConnectionAsyncCore(Stream stream, SslClientAuthenticationOptions sslOptions, CancellationToken cancellationToken);
}
public abstract class System.Net.Http.DelegatingHandler : HttpMessageHandler {
    
private bool disposed;
    
private HttpMessageHandler handler;
    
public HttpMessageHandler InnerHandler { get; public set; }
    protected DelegatingHandler(HttpMessageHandler innerHandler);
    public HttpMessageHandler get_InnerHandler();
    public void set_InnerHandler(HttpMessageHandler value);
    protected virtual void Dispose(bool disposing);
    protected internal virtual Task`1<HttpResponseMessage> SendAsync(HttpRequestMessage request, CancellationToken cancellationToken);
}
public class System.Net.Http.FormUrlEncodedContent : ByteArrayContent {
    public FormUrlEncodedContent(IEnumerable`1<KeyValuePair`2<string, string>> nameValueCollection);
    private static Byte[] EncodeContent(IEnumerable`1<KeyValuePair`2<string, string>> nameValueCollection);
    private static Byte[] SerializeValue(string value);
}
public class System.Net.Http.Headers.AuthenticationHeaderValue : object {
    [CompilerGeneratedAttribute]

private string <Parameter>k__BackingField;
    [CompilerGeneratedAttribute]

private string <Scheme>k__BackingField;
    
public string Parameter { get; private set; }
    
public string Scheme { get; private set; }
    public AuthenticationHeaderValue(string scheme);
    public AuthenticationHeaderValue(string scheme, string parameter);
    [CompilerGeneratedAttribute]
public string get_Parameter();
    [CompilerGeneratedAttribute]
private void set_Parameter(string value);
    [CompilerGeneratedAttribute]
public string get_Scheme();
    [CompilerGeneratedAttribute]
private void set_Scheme(string value);
    private sealed virtual override object System.ICloneable.Clone();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static AuthenticationHeaderValue Parse(string input);
    public static bool TryParse(string input, AuthenticationHeaderValue& parsedValue);
    internal static bool TryParse(string input, int minimalCount, List`1& result);
    private static bool TryParseElement(Lexer lexer, AuthenticationHeaderValue& parsedValue, Token& t);
    public virtual string ToString();
}
public class System.Net.Http.Headers.CacheControlHeaderValue : object {
    
private List`1<NameValueHeaderValue> extensions;
    
private List`1<string> no_cache_headers;
    
private List`1<string> private_headers;
    [CompilerGeneratedAttribute]

private Nullable`1<TimeSpan> <MaxAge>k__BackingField;
    [CompilerGeneratedAttribute]

private bool <MaxStale>k__BackingField;
    [CompilerGeneratedAttribute]

private Nullable`1<TimeSpan> <MaxStaleLimit>k__BackingField;
    [CompilerGeneratedAttribute]

private Nullable`1<TimeSpan> <MinFresh>k__BackingField;
    [CompilerGeneratedAttribute]

private bool <MustRevalidate>k__BackingField;
    [CompilerGeneratedAttribute]

private bool <NoCache>k__BackingField;
    [CompilerGeneratedAttribute]

private bool <NoStore>k__BackingField;
    [CompilerGeneratedAttribute]

private bool <NoTransform>k__BackingField;
    [CompilerGeneratedAttribute]

private bool <OnlyIfCached>k__BackingField;
    [CompilerGeneratedAttribute]

private bool <Private>k__BackingField;
    [CompilerGeneratedAttribute]

private bool <ProxyRevalidate>k__BackingField;
    [CompilerGeneratedAttribute]

private bool <Public>k__BackingField;
    [CompilerGeneratedAttribute]

private Nullable`1<TimeSpan> <SharedMaxAge>k__BackingField;
    
public ICollection`1<NameValueHeaderValue> Extensions { get; }
    
public Nullable`1<TimeSpan> MaxAge { get; public set; }
    
public bool MaxStale { get; public set; }
    
public Nullable`1<TimeSpan> MaxStaleLimit { get; public set; }
    
public Nullable`1<TimeSpan> MinFresh { get; public set; }
    
public bool MustRevalidate { get; public set; }
    
public bool NoCache { get; public set; }
    
public ICollection`1<string> NoCacheHeaders { get; }
    
public bool NoStore { get; public set; }
    
public bool NoTransform { get; public set; }
    
public bool OnlyIfCached { get; public set; }
    
public bool Private { get; public set; }
    
public ICollection`1<string> PrivateHeaders { get; }
    
public bool ProxyRevalidate { get; public set; }
    
public bool Public { get; public set; }
    
public Nullable`1<TimeSpan> SharedMaxAge { get; public set; }
    public ICollection`1<NameValueHeaderValue> get_Extensions();
    [CompilerGeneratedAttribute]
public Nullable`1<TimeSpan> get_MaxAge();
    [CompilerGeneratedAttribute]
public void set_MaxAge(Nullable`1<TimeSpan> value);
    [CompilerGeneratedAttribute]
public bool get_MaxStale();
    [CompilerGeneratedAttribute]
public void set_MaxStale(bool value);
    [CompilerGeneratedAttribute]
public Nullable`1<TimeSpan> get_MaxStaleLimit();
    [CompilerGeneratedAttribute]
public void set_MaxStaleLimit(Nullable`1<TimeSpan> value);
    [CompilerGeneratedAttribute]
public Nullable`1<TimeSpan> get_MinFresh();
    [CompilerGeneratedAttribute]
public void set_MinFresh(Nullable`1<TimeSpan> value);
    [CompilerGeneratedAttribute]
public bool get_MustRevalidate();
    [CompilerGeneratedAttribute]
public void set_MustRevalidate(bool value);
    [CompilerGeneratedAttribute]
public bool get_NoCache();
    [CompilerGeneratedAttribute]
public void set_NoCache(bool value);
    public ICollection`1<string> get_NoCacheHeaders();
    [CompilerGeneratedAttribute]
public bool get_NoStore();
    [CompilerGeneratedAttribute]
public void set_NoStore(bool value);
    [CompilerGeneratedAttribute]
public bool get_NoTransform();
    [CompilerGeneratedAttribute]
public void set_NoTransform(bool value);
    [CompilerGeneratedAttribute]
public bool get_OnlyIfCached();
    [CompilerGeneratedAttribute]
public void set_OnlyIfCached(bool value);
    [CompilerGeneratedAttribute]
public bool get_Private();
    [CompilerGeneratedAttribute]
public void set_Private(bool value);
    public ICollection`1<string> get_PrivateHeaders();
    [CompilerGeneratedAttribute]
public bool get_ProxyRevalidate();
    [CompilerGeneratedAttribute]
public void set_ProxyRevalidate(bool value);
    [CompilerGeneratedAttribute]
public bool get_Public();
    [CompilerGeneratedAttribute]
public void set_Public(bool value);
    [CompilerGeneratedAttribute]
public Nullable`1<TimeSpan> get_SharedMaxAge();
    [CompilerGeneratedAttribute]
public void set_SharedMaxAge(Nullable`1<TimeSpan> value);
    private sealed virtual override object System.ICloneable.Clone();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static CacheControlHeaderValue Parse(string input);
    public static bool TryParse(string input, CacheControlHeaderValue& parsedValue);
    public virtual string ToString();
}
[ExtensionAttribute]
internal static class System.Net.Http.Headers.CollectionExtensions : object {
    [ExtensionAttribute]
public static bool SequenceEqual(List`1<TSource> first, List`1<TSource> second);
    [ExtensionAttribute]
public static void SetValue(List`1<NameValueHeaderValue> parameters, string key, string value);
    [ExtensionAttribute]
public static string ToString(List`1<T> list);
    [ExtensionAttribute]
public static void ToStringBuilder(List`1<T> list, StringBuilder sb);
}
internal static class System.Net.Http.Headers.CollectionParser : object {
    public static bool TryParse(string input, int minimalCount, ElementTryParser`1<T> parser, List`1& result);
    public static bool TryParse(string input, int minimalCount, List`1& result);
    public static bool TryParseRepetition(string input, int minimalCount, List`1& result);
    private static bool TryParseStringElement(Lexer lexer, String& parsedValue, Token& t);
    public static bool TryParseRepetition(string input, int minimalCount, ElementTryParser`1<T> parser, List`1& result);
}
public class System.Net.Http.Headers.ContentDispositionHeaderValue : object {
    
private string dispositionType;
    
private List`1<NameValueHeaderValue> parameters;
    
public Nullable`1<DateTimeOffset> CreationDate { get; public set; }
    
public string DispositionType { get; public set; }
    
public string FileName { get; public set; }
    
public string FileNameStar { get; public set; }
    
public Nullable`1<DateTimeOffset> ModificationDate { get; public set; }
    
public string Name { get; public set; }
    
public ICollection`1<NameValueHeaderValue> Parameters { get; }
    
public Nullable`1<DateTimeOffset> ReadDate { get; public set; }
    
public Nullable`1<long> Size { get; public set; }
    public ContentDispositionHeaderValue(string dispositionType);
    protected ContentDispositionHeaderValue(ContentDispositionHeaderValue source);
    public Nullable`1<DateTimeOffset> get_CreationDate();
    public void set_CreationDate(Nullable`1<DateTimeOffset> value);
    public string get_DispositionType();
    public void set_DispositionType(string value);
    public string get_FileName();
    public void set_FileName(string value);
    public string get_FileNameStar();
    public void set_FileNameStar(string value);
    public Nullable`1<DateTimeOffset> get_ModificationDate();
    public void set_ModificationDate(Nullable`1<DateTimeOffset> value);
    public string get_Name();
    public void set_Name(string value);
    public ICollection`1<NameValueHeaderValue> get_Parameters();
    public Nullable`1<DateTimeOffset> get_ReadDate();
    public void set_ReadDate(Nullable`1<DateTimeOffset> value);
    public Nullable`1<long> get_Size();
    public void set_Size(Nullable`1<long> value);
    private sealed virtual override object System.ICloneable.Clone();
    public virtual bool Equals(object obj);
    private string FindParameter(string name);
    private Nullable`1<DateTimeOffset> GetDateValue(string name);
    private static string EncodeBase64Value(string value);
    private static string EncodeRFC5987(string value);
    private static string DecodeValue(string value, bool extendedNotation);
    public virtual int GetHashCode();
    public static ContentDispositionHeaderValue Parse(string input);
    private void SetDateValue(string key, Nullable`1<DateTimeOffset> value);
    private void SetValue(string key, string value);
    public virtual string ToString();
    public static bool TryParse(string input, ContentDispositionHeaderValue& parsedValue);
}
public class System.Net.Http.Headers.ContentRangeHeaderValue : object {
    
private string unit;
    [CompilerGeneratedAttribute]

private Nullable`1<long> <From>k__BackingField;
    [CompilerGeneratedAttribute]

private Nullable`1<long> <Length>k__BackingField;
    [CompilerGeneratedAttribute]

private Nullable`1<long> <To>k__BackingField;
    
public Nullable`1<long> From { get; private set; }
    
public bool HasLength { get; }
    
public bool HasRange { get; }
    
public Nullable`1<long> Length { get; private set; }
    
public Nullable`1<long> To { get; private set; }
    
public string Unit { get; public set; }
    public ContentRangeHeaderValue(long length);
    public ContentRangeHeaderValue(long from, long to);
    public ContentRangeHeaderValue(long from, long to, long length);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_From();
    [CompilerGeneratedAttribute]
private void set_From(Nullable`1<long> value);
    public bool get_HasLength();
    public bool get_HasRange();
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_Length();
    [CompilerGeneratedAttribute]
private void set_Length(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_To();
    [CompilerGeneratedAttribute]
private void set_To(Nullable`1<long> value);
    public string get_Unit();
    public void set_Unit(string value);
    private sealed virtual override object System.ICloneable.Clone();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static ContentRangeHeaderValue Parse(string input);
    public static bool TryParse(string input, ContentRangeHeaderValue& parsedValue);
    public virtual string ToString();
}
internal class System.Net.Http.Headers.ElementTryParser`1 : MulticastDelegate {
    public ElementTryParser`1(object object, IntPtr method);
    public virtual bool Invoke(Lexer lexer, T& parsedValue, Token& token);
    public virtual IAsyncResult BeginInvoke(Lexer lexer, T& parsedValue, Token& token, AsyncCallback callback, object object);
    public virtual bool EndInvoke(T& parsedValue, Token& token, IAsyncResult result);
}
public class System.Net.Http.Headers.EntityTagHeaderValue : object {
    
private static EntityTagHeaderValue any;
    [CompilerGeneratedAttribute]

private bool <IsWeak>k__BackingField;
    [CompilerGeneratedAttribute]

private string <Tag>k__BackingField;
    
public static EntityTagHeaderValue Any { get; }
    
public bool IsWeak { get; internal set; }
    
public string Tag { get; internal set; }
    public EntityTagHeaderValue(string tag);
    public EntityTagHeaderValue(string tag, bool isWeak);
    private static EntityTagHeaderValue();
    public static EntityTagHeaderValue get_Any();
    [CompilerGeneratedAttribute]
public bool get_IsWeak();
    [CompilerGeneratedAttribute]
internal void set_IsWeak(bool value);
    [CompilerGeneratedAttribute]
public string get_Tag();
    [CompilerGeneratedAttribute]
internal void set_Tag(string value);
    private sealed virtual override object System.ICloneable.Clone();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static EntityTagHeaderValue Parse(string input);
    public static bool TryParse(string input, EntityTagHeaderValue& parsedValue);
    private static bool TryParseElement(Lexer lexer, EntityTagHeaderValue& parsedValue, Token& t);
    internal static bool TryParse(string input, int minimalCount, List`1& result);
    public virtual string ToString();
}
internal static class System.Net.Http.Headers.HashCodeCalculator : object {
    public static int Calculate(ICollection`1<T> list);
}
internal abstract class System.Net.Http.Headers.HeaderInfo : object {
    
public bool AllowsMany;
    
public HttpHeaderKind HeaderKind;
    
public string Name;
    [CompilerGeneratedAttribute]

private Func`2<object, string> <CustomToString>k__BackingField;
    
public Func`2<object, string> CustomToString { get; private set; }
    
public string Separator { get; }
    protected HeaderInfo(string name, HttpHeaderKind headerKind);
    public static HeaderInfo CreateSingle(string name, TryParseDelegate`1<T> parser, HttpHeaderKind headerKind, Func`2<object, string> toString);
    public static HeaderInfo CreateMulti(string name, TryParseListDelegate`1<T> elementParser, HttpHeaderKind headerKind, int minimalCount, string separator);
    public object CreateCollection(HttpHeaders headers);
    [CompilerGeneratedAttribute]
public Func`2<object, string> get_CustomToString();
    [CompilerGeneratedAttribute]
private void set_CustomToString(Func`2<object, string> value);
    public virtual string get_Separator();
    public abstract virtual void AddToCollection(object collection, object value);
    protected abstract virtual object CreateCollection(HttpHeaders headers, HeaderInfo headerInfo);
    public abstract virtual List`1<string> ToStringCollection(object collection);
    public abstract virtual bool TryParse(string value, Object& result);
}
public class System.Net.Http.Headers.HttpContentHeaders : HttpHeaders {
    
private HttpContent content;
    
public ICollection`1<string> Allow { get; }
    
public ICollection`1<string> ContentEncoding { get; }
    
public ContentDispositionHeaderValue ContentDisposition { get; public set; }
    
public ICollection`1<string> ContentLanguage { get; }
    
public Nullable`1<long> ContentLength { get; public set; }
    
public Uri ContentLocation { get; public set; }
    
public Byte[] ContentMD5 { get; public set; }
    
public ContentRangeHeaderValue ContentRange { get; public set; }
    
public MediaTypeHeaderValue ContentType { get; public set; }
    
public Nullable`1<DateTimeOffset> Expires { get; public set; }
    
public Nullable`1<DateTimeOffset> LastModified { get; public set; }
    internal HttpContentHeaders(HttpContent content);
    public ICollection`1<string> get_Allow();
    public ICollection`1<string> get_ContentEncoding();
    public ContentDispositionHeaderValue get_ContentDisposition();
    public void set_ContentDisposition(ContentDispositionHeaderValue value);
    public ICollection`1<string> get_ContentLanguage();
    public Nullable`1<long> get_ContentLength();
    public void set_ContentLength(Nullable`1<long> value);
    public Uri get_ContentLocation();
    public void set_ContentLocation(Uri value);
    public Byte[] get_ContentMD5();
    public void set_ContentMD5(Byte[] value);
    public ContentRangeHeaderValue get_ContentRange();
    public void set_ContentRange(ContentRangeHeaderValue value);
    public MediaTypeHeaderValue get_ContentType();
    public void set_ContentType(MediaTypeHeaderValue value);
    public Nullable`1<DateTimeOffset> get_Expires();
    public void set_Expires(Nullable`1<DateTimeOffset> value);
    public Nullable`1<DateTimeOffset> get_LastModified();
    public void set_LastModified(Nullable`1<DateTimeOffset> value);
}
[FlagsAttribute]
internal enum System.Net.Http.Headers.HttpHeaderKind : Enum {
    
public int value__;
    
public static HttpHeaderKind None;
    
public static HttpHeaderKind Request;
    
public static HttpHeaderKind Response;
    
public static HttpHeaderKind Content;
}
public abstract class System.Net.Http.Headers.HttpHeaders : object {
    
private static Dictionary`2<string, HeaderInfo> known_headers;
    
private Dictionary`2<string, HeaderBucket> headers;
    
private HttpHeaderKind HeaderKind;
    
internal Nullable`1<bool> connectionclose;
    
internal Nullable`1<bool> transferEncodingChunked;
    private static HttpHeaders();
    internal HttpHeaders(HttpHeaderKind headerKind);
    public void Add(string name, string value);
    public void Add(string name, IEnumerable`1<string> values);
    internal bool AddValue(string value, HeaderInfo headerInfo, bool ignoreInvalid);
    private bool AddInternal(string name, IEnumerable`1<string> values, HeaderInfo headerInfo, bool ignoreInvalid);
    public bool TryAddWithoutValidation(string name, string value);
    public bool TryAddWithoutValidation(string name, IEnumerable`1<string> values);
    private HeaderInfo CheckName(string name);
    private bool TryCheckName(string name, HeaderInfo& headerInfo);
    public void Clear();
    public bool Contains(string name);
    [IteratorStateMachineAttribute("System.Net.Http.Headers.HttpHeaders/<GetEnumerator>d__19")]
public sealed virtual IEnumerator`1<KeyValuePair`2<string, IEnumerable`1<string>>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public IEnumerable`1<string> GetValues(string name);
    public bool Remove(string name);
    public bool TryGetValues(string name, IEnumerable`1& values);
    internal static string GetSingleHeaderString(string key, IEnumerable`1<string> values);
    public virtual string ToString();
    internal void AddOrRemove(string name, string value);
    internal void AddOrRemove(string name, T value, Func`2<object, string> converter);
    internal void AddOrRemove(string name, Nullable`1<T> value);
    internal void AddOrRemove(string name, Nullable`1<T> value, Func`2<object, string> converter);
    private List`1<string> GetAllHeaderValues(HeaderBucket bucket, HeaderInfo headerInfo);
    internal static HttpHeaderKind GetKnownHeaderKind(string name);
    internal T GetValue(string name);
    internal HttpHeaderValueCollection`1<T> GetValues(string name);
    internal void SetValue(string name, T value, Func`2<object, string> toStringConverter);
}
public class System.Net.Http.Headers.HttpHeaderValueCollection`1 : object {
    
private List`1<T> list;
    
private HttpHeaders headers;
    
private HeaderInfo headerInfo;
    
private List`1<string> invalidValues;
    
public int Count { get; }
    
internal List`1<string> InvalidValues { get; }
    
public bool IsReadOnly { get; }
    internal HttpHeaderValueCollection`1(HttpHeaders headers, HeaderInfo headerInfo);
    public sealed virtual int get_Count();
    internal List`1<string> get_InvalidValues();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual void Add(T item);
    internal void AddRange(List`1<T> values);
    internal void AddInvalidValue(string invalidValue);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public void ParseAdd(string input);
    public sealed virtual bool Remove(T item);
    public virtual string ToString();
    public bool TryParseAdd(string input);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    internal T Find(Predicate`1<T> predicate);
    internal void Remove(Predicate`1<T> predicate);
}
public class System.Net.Http.Headers.HttpRequestHeaders : HttpHeaders {
    
private Nullable`1<bool> expectContinue;
    
public HttpHeaderValueCollection`1<MediaTypeWithQualityHeaderValue> Accept { get; }
    
public HttpHeaderValueCollection`1<StringWithQualityHeaderValue> AcceptCharset { get; }
    
public HttpHeaderValueCollection`1<StringWithQualityHeaderValue> AcceptEncoding { get; }
    
public HttpHeaderValueCollection`1<StringWithQualityHeaderValue> AcceptLanguage { get; }
    
public AuthenticationHeaderValue Authorization { get; public set; }
    
public CacheControlHeaderValue CacheControl { get; public set; }
    
public HttpHeaderValueCollection`1<string> Connection { get; }
    
public Nullable`1<bool> ConnectionClose { get; public set; }
    
internal bool ConnectionKeepAlive { get; }
    
public Nullable`1<DateTimeOffset> Date { get; public set; }
    
public HttpHeaderValueCollection`1<NameValueWithParametersHeaderValue> Expect { get; }
    
public Nullable`1<bool> ExpectContinue { get; public set; }
    
public string From { get; public set; }
    
public string Host { get; public set; }
    
public HttpHeaderValueCollection`1<EntityTagHeaderValue> IfMatch { get; }
    
public Nullable`1<DateTimeOffset> IfModifiedSince { get; public set; }
    
public HttpHeaderValueCollection`1<EntityTagHeaderValue> IfNoneMatch { get; }
    
public RangeConditionHeaderValue IfRange { get; public set; }
    
public Nullable`1<DateTimeOffset> IfUnmodifiedSince { get; public set; }
    
public Nullable`1<int> MaxForwards { get; public set; }
    
public HttpHeaderValueCollection`1<NameValueHeaderValue> Pragma { get; }
    
public AuthenticationHeaderValue ProxyAuthorization { get; public set; }
    
public RangeHeaderValue Range { get; public set; }
    
public Uri Referrer { get; public set; }
    
public HttpHeaderValueCollection`1<TransferCodingWithQualityHeaderValue> TE { get; }
    
public HttpHeaderValueCollection`1<string> Trailer { get; }
    
public HttpHeaderValueCollection`1<TransferCodingHeaderValue> TransferEncoding { get; }
    
public Nullable`1<bool> TransferEncodingChunked { get; public set; }
    
public HttpHeaderValueCollection`1<ProductHeaderValue> Upgrade { get; }
    
public HttpHeaderValueCollection`1<ProductInfoHeaderValue> UserAgent { get; }
    
public HttpHeaderValueCollection`1<ViaHeaderValue> Via { get; }
    
public HttpHeaderValueCollection`1<WarningHeaderValue> Warning { get; }
    public HttpHeaderValueCollection`1<MediaTypeWithQualityHeaderValue> get_Accept();
    public HttpHeaderValueCollection`1<StringWithQualityHeaderValue> get_AcceptCharset();
    public HttpHeaderValueCollection`1<StringWithQualityHeaderValue> get_AcceptEncoding();
    public HttpHeaderValueCollection`1<StringWithQualityHeaderValue> get_AcceptLanguage();
    public AuthenticationHeaderValue get_Authorization();
    public void set_Authorization(AuthenticationHeaderValue value);
    public CacheControlHeaderValue get_CacheControl();
    public void set_CacheControl(CacheControlHeaderValue value);
    public HttpHeaderValueCollection`1<string> get_Connection();
    public Nullable`1<bool> get_ConnectionClose();
    public void set_ConnectionClose(Nullable`1<bool> value);
    internal bool get_ConnectionKeepAlive();
    public Nullable`1<DateTimeOffset> get_Date();
    public void set_Date(Nullable`1<DateTimeOffset> value);
    public HttpHeaderValueCollection`1<NameValueWithParametersHeaderValue> get_Expect();
    public Nullable`1<bool> get_ExpectContinue();
    public void set_ExpectContinue(Nullable`1<bool> value);
    public string get_From();
    public void set_From(string value);
    public string get_Host();
    public void set_Host(string value);
    public HttpHeaderValueCollection`1<EntityTagHeaderValue> get_IfMatch();
    public Nullable`1<DateTimeOffset> get_IfModifiedSince();
    public void set_IfModifiedSince(Nullable`1<DateTimeOffset> value);
    public HttpHeaderValueCollection`1<EntityTagHeaderValue> get_IfNoneMatch();
    public RangeConditionHeaderValue get_IfRange();
    public void set_IfRange(RangeConditionHeaderValue value);
    public Nullable`1<DateTimeOffset> get_IfUnmodifiedSince();
    public void set_IfUnmodifiedSince(Nullable`1<DateTimeOffset> value);
    public Nullable`1<int> get_MaxForwards();
    public void set_MaxForwards(Nullable`1<int> value);
    public HttpHeaderValueCollection`1<NameValueHeaderValue> get_Pragma();
    public AuthenticationHeaderValue get_ProxyAuthorization();
    public void set_ProxyAuthorization(AuthenticationHeaderValue value);
    public RangeHeaderValue get_Range();
    public void set_Range(RangeHeaderValue value);
    public Uri get_Referrer();
    public void set_Referrer(Uri value);
    public HttpHeaderValueCollection`1<TransferCodingWithQualityHeaderValue> get_TE();
    public HttpHeaderValueCollection`1<string> get_Trailer();
    public HttpHeaderValueCollection`1<TransferCodingHeaderValue> get_TransferEncoding();
    public Nullable`1<bool> get_TransferEncodingChunked();
    public void set_TransferEncodingChunked(Nullable`1<bool> value);
    public HttpHeaderValueCollection`1<ProductHeaderValue> get_Upgrade();
    public HttpHeaderValueCollection`1<ProductInfoHeaderValue> get_UserAgent();
    public HttpHeaderValueCollection`1<ViaHeaderValue> get_Via();
    public HttpHeaderValueCollection`1<WarningHeaderValue> get_Warning();
    internal void AddHeaders(HttpRequestHeaders headers);
}
public class System.Net.Http.Headers.HttpResponseHeaders : HttpHeaders {
    
public HttpHeaderValueCollection`1<string> AcceptRanges { get; }
    
public Nullable`1<TimeSpan> Age { get; public set; }
    
public CacheControlHeaderValue CacheControl { get; public set; }
    
public HttpHeaderValueCollection`1<string> Connection { get; }
    
public Nullable`1<bool> ConnectionClose { get; public set; }
    
public Nullable`1<DateTimeOffset> Date { get; public set; }
    
public EntityTagHeaderValue ETag { get; public set; }
    
public Uri Location { get; public set; }
    
public HttpHeaderValueCollection`1<NameValueHeaderValue> Pragma { get; }
    
public HttpHeaderValueCollection`1<AuthenticationHeaderValue> ProxyAuthenticate { get; }
    
public RetryConditionHeaderValue RetryAfter { get; public set; }
    
public HttpHeaderValueCollection`1<ProductInfoHeaderValue> Server { get; }
    
public HttpHeaderValueCollection`1<string> Trailer { get; }
    
public HttpHeaderValueCollection`1<TransferCodingHeaderValue> TransferEncoding { get; }
    
public Nullable`1<bool> TransferEncodingChunked { get; public set; }
    
public HttpHeaderValueCollection`1<ProductHeaderValue> Upgrade { get; }
    
public HttpHeaderValueCollection`1<string> Vary { get; }
    
public HttpHeaderValueCollection`1<ViaHeaderValue> Via { get; }
    
public HttpHeaderValueCollection`1<WarningHeaderValue> Warning { get; }
    
public HttpHeaderValueCollection`1<AuthenticationHeaderValue> WwwAuthenticate { get; }
    public HttpHeaderValueCollection`1<string> get_AcceptRanges();
    public Nullable`1<TimeSpan> get_Age();
    public void set_Age(Nullable`1<TimeSpan> value);
    public CacheControlHeaderValue get_CacheControl();
    public void set_CacheControl(CacheControlHeaderValue value);
    public HttpHeaderValueCollection`1<string> get_Connection();
    public Nullable`1<bool> get_ConnectionClose();
    public void set_ConnectionClose(Nullable`1<bool> value);
    public Nullable`1<DateTimeOffset> get_Date();
    public void set_Date(Nullable`1<DateTimeOffset> value);
    public EntityTagHeaderValue get_ETag();
    public void set_ETag(EntityTagHeaderValue value);
    public Uri get_Location();
    public void set_Location(Uri value);
    public HttpHeaderValueCollection`1<NameValueHeaderValue> get_Pragma();
    public HttpHeaderValueCollection`1<AuthenticationHeaderValue> get_ProxyAuthenticate();
    public RetryConditionHeaderValue get_RetryAfter();
    public void set_RetryAfter(RetryConditionHeaderValue value);
    public HttpHeaderValueCollection`1<ProductInfoHeaderValue> get_Server();
    public HttpHeaderValueCollection`1<string> get_Trailer();
    public HttpHeaderValueCollection`1<TransferCodingHeaderValue> get_TransferEncoding();
    public Nullable`1<bool> get_TransferEncodingChunked();
    public void set_TransferEncodingChunked(Nullable`1<bool> value);
    public HttpHeaderValueCollection`1<ProductHeaderValue> get_Upgrade();
    public HttpHeaderValueCollection`1<string> get_Vary();
    public HttpHeaderValueCollection`1<ViaHeaderValue> get_Via();
    public HttpHeaderValueCollection`1<WarningHeaderValue> get_Warning();
    public HttpHeaderValueCollection`1<AuthenticationHeaderValue> get_WwwAuthenticate();
}
internal class System.Net.Http.Headers.Lexer : object {
    
private static Boolean[] token_chars;
    
private static int last_token_char;
    
private static String[] dt_formats;
    
private string s;
    
private int pos;
    
public int Position { get; public set; }
    public Lexer(string stream);
    private static Lexer();
    public int get_Position();
    public void set_Position(int value);
    public string GetStringValue(Token token);
    public string GetStringValue(Token start, Token end);
    public string GetQuotedStringValue(Token start);
    public string GetRemainingStringValue(int position);
    public bool IsStarStringValue(Token token);
    public bool TryGetNumericValue(Token token, Int32& value);
    public bool TryGetNumericValue(Token token, Int64& value);
    public Nullable`1<TimeSpan> TryGetTimeSpanValue(Token token);
    public bool TryGetDateValue(Token token, DateTimeOffset& value);
    public static bool TryGetDateValue(string text, DateTimeOffset& value);
    public bool TryGetDoubleValue(Token token, Double& value);
    public static bool IsValidToken(string input);
    public static bool IsValidCharacter(char input);
    public void EatChar();
    public int PeekChar();
    public bool ScanCommentOptional(String& value);
    public bool ScanCommentOptional(String& value, Token& readToken);
    public Token Scan(bool recognizeDash);
}
public class System.Net.Http.Headers.MediaTypeHeaderValue : object {
    
internal List`1<NameValueHeaderValue> parameters;
    
internal string media_type;
    
public string CharSet { get; public set; }
    
public string MediaType { get; public set; }
    
public ICollection`1<NameValueHeaderValue> Parameters { get; }
    public MediaTypeHeaderValue(string mediaType);
    protected MediaTypeHeaderValue(MediaTypeHeaderValue source);
    public string get_CharSet();
    public void set_CharSet(string value);
    public string get_MediaType();
    public void set_MediaType(string value);
    public ICollection`1<NameValueHeaderValue> get_Parameters();
    private sealed virtual override object System.ICloneable.Clone();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static MediaTypeHeaderValue Parse(string input);
    public virtual string ToString();
    public static bool TryParse(string input, MediaTypeHeaderValue& parsedValue);
    internal static Nullable`1<Token> TryParseMediaType(Lexer lexer, String& media);
}
public class System.Net.Http.Headers.MediaTypeWithQualityHeaderValue : MediaTypeHeaderValue {
    
public Nullable`1<double> Quality { get; public set; }
    public MediaTypeWithQualityHeaderValue(string mediaType);
    public MediaTypeWithQualityHeaderValue(string mediaType, double quality);
    public Nullable`1<double> get_Quality();
    public void set_Quality(Nullable`1<double> value);
    public static MediaTypeWithQualityHeaderValue Parse(string input);
    public static bool TryParse(string input, MediaTypeWithQualityHeaderValue& parsedValue);
    private static bool TryParseElement(Lexer lexer, MediaTypeWithQualityHeaderValue& parsedValue, Token& t);
    internal static bool TryParse(string input, int minimalCount, List`1& result);
}
public class System.Net.Http.Headers.NameValueHeaderValue : object {
    
internal string value;
    [CompilerGeneratedAttribute]

private string <Name>k__BackingField;
    
public string Name { get; internal set; }
    
public string Value { get; public set; }
    public NameValueHeaderValue(string name);
    public NameValueHeaderValue(string name, string value);
    protected internal NameValueHeaderValue(NameValueHeaderValue source);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
internal void set_Name(string value);
    public string get_Value();
    public void set_Value(string value);
    internal static NameValueHeaderValue Create(string name, string value);
    private sealed virtual override object System.ICloneable.Clone();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public static NameValueHeaderValue Parse(string input);
    internal static bool TryParsePragma(string input, int minimalCount, List`1& result);
    internal static bool TryParseParameters(Lexer lexer, List`1& result, Token& t);
    public virtual string ToString();
    public static bool TryParse(string input, NameValueHeaderValue& parsedValue);
    private static bool TryParseElement(Lexer lexer, NameValueHeaderValue& parsedValue, Token& t);
}
public class System.Net.Http.Headers.NameValueWithParametersHeaderValue : NameValueHeaderValue {
    
private List`1<NameValueHeaderValue> parameters;
    
public ICollection`1<NameValueHeaderValue> Parameters { get; }
    public NameValueWithParametersHeaderValue(string name);
    public NameValueWithParametersHeaderValue(string name, string value);
    protected NameValueWithParametersHeaderValue(NameValueWithParametersHeaderValue source);
    public ICollection`1<NameValueHeaderValue> get_Parameters();
    private sealed virtual override object System.ICloneable.Clone();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static NameValueWithParametersHeaderValue Parse(string input);
    public virtual string ToString();
    public static bool TryParse(string input, NameValueWithParametersHeaderValue& parsedValue);
    internal static bool TryParse(string input, int minimalCount, List`1& result);
    private static bool TryParseElement(Lexer lexer, NameValueWithParametersHeaderValue& parsedValue, Token& t);
}
internal static class System.Net.Http.Headers.Parser : object {
}
public class System.Net.Http.Headers.ProductHeaderValue : object {
    [CompilerGeneratedAttribute]

private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]

private string <Version>k__BackingField;
    
public string Name { get; internal set; }
    
public string Version { get; internal set; }
    public ProductHeaderValue(string name);
    public ProductHeaderValue(string name, string version);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
internal void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Version();
    [CompilerGeneratedAttribute]
internal void set_Version(string value);
    private sealed virtual override object System.ICloneable.Clone();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static ProductHeaderValue Parse(string input);
    public static bool TryParse(string input, ProductHeaderValue& parsedValue);
    internal static bool TryParse(string input, int minimalCount, List`1& result);
    private static bool TryParseElement(Lexer lexer, ProductHeaderValue& parsedValue, Token& t);
    public virtual string ToString();
}
public class System.Net.Http.Headers.ProductInfoHeaderValue : object {
    [CompilerGeneratedAttribute]

private string <Comment>k__BackingField;
    [CompilerGeneratedAttribute]

private ProductHeaderValue <Product>k__BackingField;
    
public string Comment { get; private set; }
    
public ProductHeaderValue Product { get; private set; }
    public ProductInfoHeaderValue(ProductHeaderValue product);
    public ProductInfoHeaderValue(string comment);
    public ProductInfoHeaderValue(string productName, string productVersion);
    [CompilerGeneratedAttribute]
public string get_Comment();
    [CompilerGeneratedAttribute]
private void set_Comment(string value);
    [CompilerGeneratedAttribute]
public ProductHeaderValue get_Product();
    [CompilerGeneratedAttribute]
private void set_Product(ProductHeaderValue value);
    private sealed virtual override object System.ICloneable.Clone();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static ProductInfoHeaderValue Parse(string input);
    public static bool TryParse(string input, ProductInfoHeaderValue& parsedValue);
    internal static bool TryParse(string input, int minimalCount, List`1& result);
    private static bool TryParseElement(Lexer lexer, ProductInfoHeaderValue& parsedValue);
    public virtual string ToString();
}
internal static class System.Net.Http.Headers.QualityValue : object {
    public static Nullable`1<double> GetValue(List`1<NameValueHeaderValue> parameters);
    public static void SetValue(List`1& parameters, Nullable`1<double> value);
}
public class System.Net.Http.Headers.RangeConditionHeaderValue : object {
    [CompilerGeneratedAttribute]

private Nullable`1<DateTimeOffset> <Date>k__BackingField;
    [CompilerGeneratedAttribute]

private EntityTagHeaderValue <EntityTag>k__BackingField;
    
public Nullable`1<DateTimeOffset> Date { get; private set; }
    
public EntityTagHeaderValue EntityTag { get; private set; }
    public RangeConditionHeaderValue(DateTimeOffset date);
    public RangeConditionHeaderValue(EntityTagHeaderValue entityTag);
    public RangeConditionHeaderValue(string entityTag);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTimeOffset> get_Date();
    [CompilerGeneratedAttribute]
private void set_Date(Nullable`1<DateTimeOffset> value);
    [CompilerGeneratedAttribute]
public EntityTagHeaderValue get_EntityTag();
    [CompilerGeneratedAttribute]
private void set_EntityTag(EntityTagHeaderValue value);
    private sealed virtual override object System.ICloneable.Clone();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static RangeConditionHeaderValue Parse(string input);
    public static bool TryParse(string input, RangeConditionHeaderValue& parsedValue);
    public virtual string ToString();
}
public class System.Net.Http.Headers.RangeHeaderValue : object {
    
private List`1<RangeItemHeaderValue> ranges;
    
private string unit;
    
public ICollection`1<RangeItemHeaderValue> Ranges { get; }
    
public string Unit { get; public set; }
    public RangeHeaderValue(Nullable`1<long> from, Nullable`1<long> to);
    private RangeHeaderValue(RangeHeaderValue source);
    public ICollection`1<RangeItemHeaderValue> get_Ranges();
    public string get_Unit();
    public void set_Unit(string value);
    private sealed virtual override object System.ICloneable.Clone();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static RangeHeaderValue Parse(string input);
    public static bool TryParse(string input, RangeHeaderValue& parsedValue);
    public virtual string ToString();
}
public class System.Net.Http.Headers.RangeItemHeaderValue : object {
    [CompilerGeneratedAttribute]

private Nullable`1<long> <From>k__BackingField;
    [CompilerGeneratedAttribute]

private Nullable`1<long> <To>k__BackingField;
    
public Nullable`1<long> From { get; private set; }
    
public Nullable`1<long> To { get; private set; }
    public RangeItemHeaderValue(Nullable`1<long> from, Nullable`1<long> to);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_From();
    [CompilerGeneratedAttribute]
private void set_From(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_To();
    [CompilerGeneratedAttribute]
private void set_To(Nullable`1<long> value);
    private sealed virtual override object System.ICloneable.Clone();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class System.Net.Http.Headers.RetryConditionHeaderValue : object {
    [CompilerGeneratedAttribute]

private Nullable`1<DateTimeOffset> <Date>k__BackingField;
    [CompilerGeneratedAttribute]

private Nullable`1<TimeSpan> <Delta>k__BackingField;
    
public Nullable`1<DateTimeOffset> Date { get; private set; }
    
public Nullable`1<TimeSpan> Delta { get; private set; }
    public RetryConditionHeaderValue(DateTimeOffset date);
    public RetryConditionHeaderValue(TimeSpan delta);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTimeOffset> get_Date();
    [CompilerGeneratedAttribute]
private void set_Date(Nullable`1<DateTimeOffset> value);
    [CompilerGeneratedAttribute]
public Nullable`1<TimeSpan> get_Delta();
    [CompilerGeneratedAttribute]
private void set_Delta(Nullable`1<TimeSpan> value);
    private sealed virtual override object System.ICloneable.Clone();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static RetryConditionHeaderValue Parse(string input);
    public static bool TryParse(string input, RetryConditionHeaderValue& parsedValue);
    public virtual string ToString();
}
public class System.Net.Http.Headers.StringWithQualityHeaderValue : object {
    [CompilerGeneratedAttribute]

private Nullable`1<double> <Quality>k__BackingField;
    [CompilerGeneratedAttribute]

private string <Value>k__BackingField;
    
public Nullable`1<double> Quality { get; private set; }
    
public string Value { get; private set; }
    public StringWithQualityHeaderValue(string value);
    public StringWithQualityHeaderValue(string value, double quality);
    [CompilerGeneratedAttribute]
public Nullable`1<double> get_Quality();
    [CompilerGeneratedAttribute]
private void set_Quality(Nullable`1<double> value);
    [CompilerGeneratedAttribute]
public string get_Value();
    [CompilerGeneratedAttribute]
private void set_Value(string value);
    private sealed virtual override object System.ICloneable.Clone();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static StringWithQualityHeaderValue Parse(string input);
    public static bool TryParse(string input, StringWithQualityHeaderValue& parsedValue);
    internal static bool TryParse(string input, int minimalCount, List`1& result);
    private static bool TryParseElement(Lexer lexer, StringWithQualityHeaderValue& parsedValue, Token& t);
    public virtual string ToString();
}
internal class System.Net.Http.Headers.Token : ValueType {
    
public static Token Empty;
    
private Type type;
    [CompilerGeneratedAttribute]

private int <StartPosition>k__BackingField;
    [CompilerGeneratedAttribute]

private int <EndPosition>k__BackingField;
    
public int StartPosition { get; private set; }
    
public int EndPosition { get; private set; }
    
public Type Kind { get; }
    public Token(Type type, int startPosition, int endPosition);
    private static Token();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_StartPosition();
    [CompilerGeneratedAttribute]
private void set_StartPosition(int value);
    [CompilerGeneratedAttribute]
[IsReadOnlyAttribute]
public int get_EndPosition();
    [CompilerGeneratedAttribute]
private void set_EndPosition(int value);
    public Type get_Kind();
    public static Type op_Implicit(Token token);
    public virtual string ToString();
}
public class System.Net.Http.Headers.TransferCodingHeaderValue : object {
    
internal string value;
    
internal List`1<NameValueHeaderValue> parameters;
    
public ICollection`1<NameValueHeaderValue> Parameters { get; }
    
public string Value { get; }
    public TransferCodingHeaderValue(string value);
    protected TransferCodingHeaderValue(TransferCodingHeaderValue source);
    public ICollection`1<NameValueHeaderValue> get_Parameters();
    public string get_Value();
    private sealed virtual override object System.ICloneable.Clone();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static TransferCodingHeaderValue Parse(string input);
    public virtual string ToString();
    public static bool TryParse(string input, TransferCodingHeaderValue& parsedValue);
    internal static bool TryParse(string input, int minimalCount, List`1& result);
    private static bool TryParseElement(Lexer lexer, TransferCodingHeaderValue& parsedValue, Token& t);
}
public class System.Net.Http.Headers.TransferCodingWithQualityHeaderValue : TransferCodingHeaderValue {
    
public Nullable`1<double> Quality { get; public set; }
    public TransferCodingWithQualityHeaderValue(string value);
    public TransferCodingWithQualityHeaderValue(string value, double quality);
    public Nullable`1<double> get_Quality();
    public void set_Quality(Nullable`1<double> value);
    public static TransferCodingWithQualityHeaderValue Parse(string input);
    public static bool TryParse(string input, TransferCodingWithQualityHeaderValue& parsedValue);
    internal static bool TryParse(string input, int minimalCount, List`1& result);
    private static bool TryParseElement(Lexer lexer, TransferCodingWithQualityHeaderValue& parsedValue, Token& t);
}
internal class System.Net.Http.Headers.TryParseDelegate`1 : MulticastDelegate {
    public TryParseDelegate`1(object object, IntPtr method);
    public virtual bool Invoke(string value, T& result);
    public virtual IAsyncResult BeginInvoke(string value, T& result, AsyncCallback callback, object object);
    public virtual bool EndInvoke(T& result, IAsyncResult __result);
}
internal class System.Net.Http.Headers.TryParseListDelegate`1 : MulticastDelegate {
    public TryParseListDelegate`1(object object, IntPtr method);
    public virtual bool Invoke(string value, int minimalCount, List`1& result);
    public virtual IAsyncResult BeginInvoke(string value, int minimalCount, List`1& result, AsyncCallback callback, object object);
    public virtual bool EndInvoke(List`1& result, IAsyncResult __result);
}
public class System.Net.Http.Headers.ViaHeaderValue : object {
    [CompilerGeneratedAttribute]

private string <Comment>k__BackingField;
    [CompilerGeneratedAttribute]

private string <ProtocolName>k__BackingField;
    [CompilerGeneratedAttribute]

private string <ProtocolVersion>k__BackingField;
    [CompilerGeneratedAttribute]

private string <ReceivedBy>k__BackingField;
    
public string Comment { get; private set; }
    
public string ProtocolName { get; private set; }
    
public string ProtocolVersion { get; private set; }
    
public string ReceivedBy { get; private set; }
    public ViaHeaderValue(string protocolVersion, string receivedBy);
    public ViaHeaderValue(string protocolVersion, string receivedBy, string protocolName);
    public ViaHeaderValue(string protocolVersion, string receivedBy, string protocolName, string comment);
    [CompilerGeneratedAttribute]
public string get_Comment();
    [CompilerGeneratedAttribute]
private void set_Comment(string value);
    [CompilerGeneratedAttribute]
public string get_ProtocolName();
    [CompilerGeneratedAttribute]
private void set_ProtocolName(string value);
    [CompilerGeneratedAttribute]
public string get_ProtocolVersion();
    [CompilerGeneratedAttribute]
private void set_ProtocolVersion(string value);
    [CompilerGeneratedAttribute]
public string get_ReceivedBy();
    [CompilerGeneratedAttribute]
private void set_ReceivedBy(string value);
    private sealed virtual override object System.ICloneable.Clone();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static ViaHeaderValue Parse(string input);
    public static bool TryParse(string input, ViaHeaderValue& parsedValue);
    internal static bool TryParse(string input, int minimalCount, List`1& result);
    private static bool TryParseElement(Lexer lexer, ViaHeaderValue& parsedValue, Token& t);
    public virtual string ToString();
}
public class System.Net.Http.Headers.WarningHeaderValue : object {
    [CompilerGeneratedAttribute]

private string <Agent>k__BackingField;
    [CompilerGeneratedAttribute]

private int <Code>k__BackingField;
    [CompilerGeneratedAttribute]

private Nullable`1<DateTimeOffset> <Date>k__BackingField;
    [CompilerGeneratedAttribute]

private string <Text>k__BackingField;
    
public string Agent { get; private set; }
    
public int Code { get; private set; }
    
public Nullable`1<DateTimeOffset> Date { get; private set; }
    
public string Text { get; private set; }
    public WarningHeaderValue(int code, string agent, string text);
    public WarningHeaderValue(int code, string agent, string text, DateTimeOffset date);
    [CompilerGeneratedAttribute]
public string get_Agent();
    [CompilerGeneratedAttribute]
private void set_Agent(string value);
    [CompilerGeneratedAttribute]
public int get_Code();
    [CompilerGeneratedAttribute]
private void set_Code(int value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTimeOffset> get_Date();
    [CompilerGeneratedAttribute]
private void set_Date(Nullable`1<DateTimeOffset> value);
    [CompilerGeneratedAttribute]
public string get_Text();
    [CompilerGeneratedAttribute]
private void set_Text(string value);
    private static bool IsCodeValid(int code);
    private sealed virtual override object System.ICloneable.Clone();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static WarningHeaderValue Parse(string input);
    public static bool TryParse(string input, WarningHeaderValue& parsedValue);
    internal static bool TryParse(string input, int minimalCount, List`1& result);
    private static bool TryParseElement(Lexer lexer, WarningHeaderValue& parsedValue, Token& t);
    public virtual string ToString();
}
public class System.Net.Http.HttpClient : HttpMessageInvoker {
    
private static TimeSpan TimeoutDefault;
    
private Uri base_address;
    
private CancellationTokenSource cts;
    
private bool disposed;
    
private HttpRequestHeaders headers;
    
private long buffer_size;
    
private TimeSpan timeout;
    
public Uri BaseAddress { get; public set; }
    
public HttpRequestHeaders DefaultRequestHeaders { get; }
    
public long MaxResponseContentBufferSize { get; public set; }
    
public TimeSpan Timeout { get; public set; }
    public HttpClient(HttpMessageHandler handler);
    public HttpClient(HttpMessageHandler handler, bool disposeHandler);
    private static HttpClient();
    public Uri get_BaseAddress();
    public void set_BaseAddress(Uri value);
    public HttpRequestHeaders get_DefaultRequestHeaders();
    public long get_MaxResponseContentBufferSize();
    public void set_MaxResponseContentBufferSize(long value);
    public TimeSpan get_Timeout();
    public void set_Timeout(TimeSpan value);
    public void CancelPendingRequests();
    protected virtual void Dispose(bool disposing);
    public Task`1<HttpResponseMessage> DeleteAsync(string requestUri);
    public Task`1<HttpResponseMessage> DeleteAsync(string requestUri, CancellationToken cancellationToken);
    public Task`1<HttpResponseMessage> DeleteAsync(Uri requestUri);
    public Task`1<HttpResponseMessage> DeleteAsync(Uri requestUri, CancellationToken cancellationToken);
    public Task`1<HttpResponseMessage> GetAsync(string requestUri);
    public Task`1<HttpResponseMessage> GetAsync(string requestUri, CancellationToken cancellationToken);
    public Task`1<HttpResponseMessage> GetAsync(string requestUri, HttpCompletionOption completionOption);
    public Task`1<HttpResponseMessage> GetAsync(string requestUri, HttpCompletionOption completionOption, CancellationToken cancellationToken);
    public Task`1<HttpResponseMessage> GetAsync(Uri requestUri);
    public Task`1<HttpResponseMessage> GetAsync(Uri requestUri, CancellationToken cancellationToken);
    public Task`1<HttpResponseMessage> GetAsync(Uri requestUri, HttpCompletionOption completionOption);
    public Task`1<HttpResponseMessage> GetAsync(Uri requestUri, HttpCompletionOption completionOption, CancellationToken cancellationToken);
    public Task`1<HttpResponseMessage> PostAsync(string requestUri, HttpContent content);
    public Task`1<HttpResponseMessage> PostAsync(string requestUri, HttpContent content, CancellationToken cancellationToken);
    public Task`1<HttpResponseMessage> PostAsync(Uri requestUri, HttpContent content);
    public Task`1<HttpResponseMessage> PostAsync(Uri requestUri, HttpContent content, CancellationToken cancellationToken);
    public Task`1<HttpResponseMessage> PutAsync(Uri requestUri, HttpContent content);
    public Task`1<HttpResponseMessage> PutAsync(Uri requestUri, HttpContent content, CancellationToken cancellationToken);
    public Task`1<HttpResponseMessage> PutAsync(string requestUri, HttpContent content);
    public Task`1<HttpResponseMessage> PutAsync(string requestUri, HttpContent content, CancellationToken cancellationToken);
    public Task`1<HttpResponseMessage> SendAsync(HttpRequestMessage request);
    public Task`1<HttpResponseMessage> SendAsync(HttpRequestMessage request, HttpCompletionOption completionOption);
    public virtual Task`1<HttpResponseMessage> SendAsync(HttpRequestMessage request, CancellationToken cancellationToken);
    public Task`1<HttpResponseMessage> SendAsync(HttpRequestMessage request, HttpCompletionOption completionOption, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.Net.Http.HttpClient/<SendAsyncWorker>d__47")]
private Task`1<HttpResponseMessage> SendAsyncWorker(HttpRequestMessage request, HttpCompletionOption completionOption, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.Net.Http.HttpClient/<GetByteArrayAsync>d__48")]
public Task`1<Byte[]> GetByteArrayAsync(string requestUri);
    [AsyncStateMachineAttribute("System.Net.Http.HttpClient/<GetByteArrayAsync>d__49")]
public Task`1<Byte[]> GetByteArrayAsync(Uri requestUri);
    [AsyncStateMachineAttribute("System.Net.Http.HttpClient/<GetStreamAsync>d__50")]
public Task`1<Stream> GetStreamAsync(string requestUri);
    [AsyncStateMachineAttribute("System.Net.Http.HttpClient/<GetStreamAsync>d__51")]
public Task`1<Stream> GetStreamAsync(Uri requestUri);
    [AsyncStateMachineAttribute("System.Net.Http.HttpClient/<GetStringAsync>d__52")]
public Task`1<string> GetStringAsync(string requestUri);
    [AsyncStateMachineAttribute("System.Net.Http.HttpClient/<GetStringAsync>d__53")]
public Task`1<string> GetStringAsync(Uri requestUri);
    public Task`1<HttpResponseMessage> PatchAsync(string requestUri, HttpContent content);
    public Task`1<HttpResponseMessage> PatchAsync(string requestUri, HttpContent content, CancellationToken cancellationToken);
    public Task`1<HttpResponseMessage> PatchAsync(Uri requestUri, HttpContent content);
    public Task`1<HttpResponseMessage> PatchAsync(Uri requestUri, HttpContent content, CancellationToken cancellationToken);
    [DebuggerHiddenAttribute]
[CompilerGeneratedAttribute]
private Task`1<HttpResponseMessage> <>n__0(HttpRequestMessage request, CancellationToken cancellationToken);
}
public class System.Net.Http.HttpClientHandler : HttpMessageHandler {
    
private IMonoHttpClientHandler _delegatingHandler;
    
private ClientCertificateOption _clientCertificateOptions;
    
public static Func`5<HttpRequestMessage, X509Certificate2, X509Chain, SslPolicyErrors, bool> DangerousAcceptAnyServerCertificateValidator { get; }
    
public bool SupportsAutomaticDecompression { get; }
    
public bool SupportsProxy { get; }
    
public bool SupportsRedirectConfiguration { get; }
    
public bool UseCookies { get; public set; }
    
public CookieContainer CookieContainer { get; public set; }
    
public ClientCertificateOption ClientCertificateOptions { get; public set; }
    
public X509CertificateCollection ClientCertificates { get; }
    
public Func`5<HttpRequestMessage, X509Certificate2, X509Chain, SslPolicyErrors, bool> ServerCertificateCustomValidationCallback { get; public set; }
    
public bool CheckCertificateRevocationList { get; public set; }
    
public SslProtocols SslProtocols { get; public set; }
    
public DecompressionMethods AutomaticDecompression { get; public set; }
    
public bool UseProxy { get; public set; }
    
public IWebProxy Proxy { get; public set; }
    
public ICredentials DefaultProxyCredentials { get; public set; }
    
public bool PreAuthenticate { get; public set; }
    
public bool UseDefaultCredentials { get; public set; }
    
public ICredentials Credentials { get; public set; }
    
public bool AllowAutoRedirect { get; public set; }
    
public int MaxAutomaticRedirections { get; public set; }
    
public int MaxConnectionsPerServer { get; public set; }
    
public int MaxResponseHeadersLength { get; public set; }
    
public long MaxRequestContentBufferSize { get; public set; }
    
public IDictionary`2<string, object> Properties { get; }
    internal HttpClientHandler(IMonoHttpClientHandler handler);
    private static IMonoHttpClientHandler CreateDefaultHandler();
    public static Func`5<HttpRequestMessage, X509Certificate2, X509Chain, SslPolicyErrors, bool> get_DangerousAcceptAnyServerCertificateValidator();
    protected virtual void Dispose(bool disposing);
    public virtual bool get_SupportsAutomaticDecompression();
    public virtual bool get_SupportsProxy();
    public virtual bool get_SupportsRedirectConfiguration();
    public bool get_UseCookies();
    public void set_UseCookies(bool value);
    public CookieContainer get_CookieContainer();
    public void set_CookieContainer(CookieContainer value);
    private void ThrowForModifiedManagedSslOptionsIfStarted();
    public ClientCertificateOption get_ClientCertificateOptions();
    public void set_ClientCertificateOptions(ClientCertificateOption value);
    public X509CertificateCollection get_ClientCertificates();
    public Func`5<HttpRequestMessage, X509Certificate2, X509Chain, SslPolicyErrors, bool> get_ServerCertificateCustomValidationCallback();
    public void set_ServerCertificateCustomValidationCallback(Func`5<HttpRequestMessage, X509Certificate2, X509Chain, SslPolicyErrors, bool> value);
    public bool get_CheckCertificateRevocationList();
    public void set_CheckCertificateRevocationList(bool value);
    public SslProtocols get_SslProtocols();
    public void set_SslProtocols(SslProtocols value);
    public DecompressionMethods get_AutomaticDecompression();
    public void set_AutomaticDecompression(DecompressionMethods value);
    public bool get_UseProxy();
    public void set_UseProxy(bool value);
    public IWebProxy get_Proxy();
    public void set_Proxy(IWebProxy value);
    public ICredentials get_DefaultProxyCredentials();
    public void set_DefaultProxyCredentials(ICredentials value);
    public bool get_PreAuthenticate();
    public void set_PreAuthenticate(bool value);
    public bool get_UseDefaultCredentials();
    public void set_UseDefaultCredentials(bool value);
    public ICredentials get_Credentials();
    public void set_Credentials(ICredentials value);
    public bool get_AllowAutoRedirect();
    public void set_AllowAutoRedirect(bool value);
    public int get_MaxAutomaticRedirections();
    public void set_MaxAutomaticRedirections(int value);
    public int get_MaxConnectionsPerServer();
    public void set_MaxConnectionsPerServer(int value);
    public int get_MaxResponseHeadersLength();
    public void set_MaxResponseHeadersLength(int value);
    public long get_MaxRequestContentBufferSize();
    public void set_MaxRequestContentBufferSize(long value);
    public IDictionary`2<string, object> get_Properties();
    internal void SetWebRequestTimeout(TimeSpan timeout);
    protected internal virtual Task`1<HttpResponseMessage> SendAsync(HttpRequestMessage request, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
private X509Certificate <set_ClientCertificateOptions>b__23_0(object sender, string targetHost, X509CertificateCollection localCertificates, X509Certificate remoteCertificate, String[] acceptableIssuers);
}
public enum System.Net.Http.HttpCompletionOption : Enum {
    
public int value__;
    
public static HttpCompletionOption ResponseContentRead;
    
public static HttpCompletionOption ResponseHeadersRead;
}
public abstract class System.Net.Http.HttpContent : object {
    
private FixedMemoryStream buffer;
    
private Stream stream;
    
private bool disposed;
    
private HttpContentHeaders headers;
    
public HttpContentHeaders Headers { get; }
    
internal Nullable`1<long> LoadedBufferLength { get; }
    public HttpContentHeaders get_Headers();
    internal Nullable`1<long> get_LoadedBufferLength();
    internal void CopyTo(Stream stream);
    public Task CopyToAsync(Stream stream);
    public Task CopyToAsync(Stream stream, TransportContext context);
    [AsyncStateMachineAttribute("System.Net.Http.HttpContent/<CreateContentReadStreamAsync>d__12")]
protected virtual Task`1<Stream> CreateContentReadStreamAsync();
    private static FixedMemoryStream CreateFixedMemoryStream(long maxBufferSize);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public Task LoadIntoBufferAsync();
    [AsyncStateMachineAttribute("System.Net.Http.HttpContent/<LoadIntoBufferAsync>d__17")]
public Task LoadIntoBufferAsync(long maxBufferSize);
    [AsyncStateMachineAttribute("System.Net.Http.HttpContent/<ReadAsStreamAsync>d__18")]
public Task`1<Stream> ReadAsStreamAsync();
    [AsyncStateMachineAttribute("System.Net.Http.HttpContent/<ReadAsByteArrayAsync>d__19")]
public Task`1<Byte[]> ReadAsByteArrayAsync();
    [AsyncStateMachineAttribute("System.Net.Http.HttpContent/<ReadAsStringAsync>d__20")]
public Task`1<string> ReadAsStringAsync();
    private static Encoding GetEncodingFromBuffer(Byte[] buffer, int length, Int32& preambleLength);
    private static int StartsWith(Byte[] array, int length, Byte[] value);
    internal Task SerializeToStreamAsync_internal(Stream stream, TransportContext context);
    protected abstract virtual Task SerializeToStreamAsync(Stream stream, TransportContext context);
    protected internal abstract virtual bool TryComputeLength(Int64& length);
}
public abstract class System.Net.Http.HttpMessageHandler : object {
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    protected internal abstract virtual Task`1<HttpResponseMessage> SendAsync(HttpRequestMessage request, CancellationToken cancellationToken);
}
public class System.Net.Http.HttpMessageInvoker : object {
    
private protected HttpMessageHandler handler;
    
private bool disposeHandler;
    public HttpMessageInvoker(HttpMessageHandler handler);
    public HttpMessageInvoker(HttpMessageHandler handler, bool disposeHandler);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public virtual Task`1<HttpResponseMessage> SendAsync(HttpRequestMessage request, CancellationToken cancellationToken);
}
public class System.Net.Http.HttpMethod : object {
    
private static HttpMethod delete_method;
    
private static HttpMethod get_method;
    
private static HttpMethod head_method;
    
private static HttpMethod options_method;
    
private static HttpMethod post_method;
    
private static HttpMethod put_method;
    
private static HttpMethod trace_method;
    
private string method;
    
public static HttpMethod Delete { get; }
    
public static HttpMethod Get { get; }
    
public static HttpMethod Head { get; }
    
public string Method { get; }
    
public static HttpMethod Options { get; }
    
public static HttpMethod Post { get; }
    
public static HttpMethod Put { get; }
    
public static HttpMethod Trace { get; }
    
public static HttpMethod Patch { get; }
    public HttpMethod(string method);
    private static HttpMethod();
    public static HttpMethod get_Delete();
    public static HttpMethod get_Get();
    public static HttpMethod get_Head();
    public string get_Method();
    public static HttpMethod get_Options();
    public static HttpMethod get_Post();
    public static HttpMethod get_Put();
    public static HttpMethod get_Trace();
    public static bool op_Equality(HttpMethod left, HttpMethod right);
    public static bool op_Inequality(HttpMethod left, HttpMethod right);
    public sealed virtual bool Equals(HttpMethod other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static HttpMethod get_Patch();
}
public class System.Net.Http.HttpRequestException : Exception {
    public HttpRequestException(string message);
    public HttpRequestException(string message, Exception inner);
}
public class System.Net.Http.HttpRequestMessage : object {
    
private HttpRequestHeaders headers;
    
private HttpMethod method;
    
private Version version;
    
private Dictionary`2<string, object> properties;
    
private Uri uri;
    
private bool is_used;
    
private bool disposed;
    [CompilerGeneratedAttribute]

private HttpContent <Content>k__BackingField;
    
public HttpContent Content { get; public set; }
    
public HttpRequestHeaders Headers { get; }
    
public HttpMethod Method { get; public set; }
    
public IDictionary`2<string, object> Properties { get; }
    
public Uri RequestUri { get; public set; }
    
public Version Version { get; public set; }
    public HttpRequestMessage(HttpMethod method, string requestUri);
    public HttpRequestMessage(HttpMethod method, Uri requestUri);
    [CompilerGeneratedAttribute]
public HttpContent get_Content();
    [CompilerGeneratedAttribute]
public void set_Content(HttpContent value);
    public HttpRequestHeaders get_Headers();
    public HttpMethod get_Method();
    public void set_Method(HttpMethod value);
    public IDictionary`2<string, object> get_Properties();
    public Uri get_RequestUri();
    public void set_RequestUri(Uri value);
    private static bool IsAllowedAbsoluteUri(Uri uri);
    public Version get_Version();
    public void set_Version(Version value);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    internal bool SetIsUsed();
    public virtual string ToString();
}
public class System.Net.Http.HttpResponseMessage : object {
    
private HttpResponseHeaders headers;
    
private HttpResponseHeaders trailingHeaders;
    
private string reasonPhrase;
    
private HttpStatusCode statusCode;
    
private Version version;
    
private bool disposed;
    [CompilerGeneratedAttribute]

private HttpContent <Content>k__BackingField;
    [CompilerGeneratedAttribute]

private HttpRequestMessage <RequestMessage>k__BackingField;
    
public HttpContent Content { get; public set; }
    
public HttpResponseHeaders Headers { get; }
    
public bool IsSuccessStatusCode { get; }
    
public string ReasonPhrase { get; public set; }
    
public HttpRequestMessage RequestMessage { get; public set; }
    
public HttpStatusCode StatusCode { get; public set; }
    
public Version Version { get; public set; }
    
public HttpResponseHeaders TrailingHeaders { get; }
    public HttpResponseMessage(HttpStatusCode statusCode);
    [CompilerGeneratedAttribute]
public HttpContent get_Content();
    [CompilerGeneratedAttribute]
public void set_Content(HttpContent value);
    public HttpResponseHeaders get_Headers();
    public bool get_IsSuccessStatusCode();
    public string get_ReasonPhrase();
    public void set_ReasonPhrase(string value);
    [CompilerGeneratedAttribute]
public HttpRequestMessage get_RequestMessage();
    [CompilerGeneratedAttribute]
public void set_RequestMessage(HttpRequestMessage value);
    public HttpStatusCode get_StatusCode();
    public void set_StatusCode(HttpStatusCode value);
    public Version get_Version();
    public void set_Version(Version value);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public HttpResponseMessage EnsureSuccessStatusCode();
    public virtual string ToString();
    public HttpResponseHeaders get_TrailingHeaders();
}
[ExtensionAttribute]
internal static class System.Net.Http.HttpUtilities : object {
    
internal static Version DefaultRequestVersion { get; }
    
internal static Version DefaultResponseVersion { get; }
    internal static Version get_DefaultRequestVersion();
    internal static Version get_DefaultResponseVersion();
    internal static bool IsHttpUri(Uri uri);
    internal static bool IsSupportedScheme(string scheme);
    internal static bool IsSupportedNonSecureScheme(string scheme);
    internal static bool IsSupportedSecureScheme(string scheme);
    internal static bool IsNonSecureWebSocketScheme(string scheme);
    internal static bool IsSecureWebSocketScheme(string scheme);
    [ExtensionAttribute]
internal static Task ContinueWithStandard(Task`1<T> task, object state, Action`2<Task`1<T>, object> continuation);
}
internal interface System.Net.Http.IMonoHttpClientHandler {
    
public bool SupportsAutomaticDecompression { get; }
    
public bool UseCookies { get; public set; }
    
public CookieContainer CookieContainer { get; public set; }
    
public SslClientAuthenticationOptions SslOptions { get; public set; }
    
public DecompressionMethods AutomaticDecompression { get; public set; }
    
public bool UseProxy { get; public set; }
    
public IWebProxy Proxy { get; public set; }
    
public ICredentials DefaultProxyCredentials { get; public set; }
    
public bool PreAuthenticate { get; public set; }
    
public ICredentials Credentials { get; public set; }
    
public bool AllowAutoRedirect { get; public set; }
    
public int MaxAutomaticRedirections { get; public set; }
    
public int MaxConnectionsPerServer { get; public set; }
    
public int MaxResponseHeadersLength { get; public set; }
    
public long MaxRequestContentBufferSize { get; public set; }
    
public IDictionary`2<string, object> Properties { get; }
    public abstract virtual bool get_SupportsAutomaticDecompression();
    public abstract virtual bool get_UseCookies();
    public abstract virtual void set_UseCookies(bool value);
    public abstract virtual CookieContainer get_CookieContainer();
    public abstract virtual void set_CookieContainer(CookieContainer value);
    public abstract virtual SslClientAuthenticationOptions get_SslOptions();
    public abstract virtual void set_SslOptions(SslClientAuthenticationOptions value);
    public abstract virtual DecompressionMethods get_AutomaticDecompression();
    public abstract virtual void set_AutomaticDecompression(DecompressionMethods value);
    public abstract virtual bool get_UseProxy();
    public abstract virtual void set_UseProxy(bool value);
    public abstract virtual IWebProxy get_Proxy();
    public abstract virtual void set_Proxy(IWebProxy value);
    public abstract virtual ICredentials get_DefaultProxyCredentials();
    public abstract virtual void set_DefaultProxyCredentials(ICredentials value);
    public abstract virtual bool get_PreAuthenticate();
    public abstract virtual void set_PreAuthenticate(bool value);
    public abstract virtual ICredentials get_Credentials();
    public abstract virtual void set_Credentials(ICredentials value);
    public abstract virtual bool get_AllowAutoRedirect();
    public abstract virtual void set_AllowAutoRedirect(bool value);
    public abstract virtual int get_MaxAutomaticRedirections();
    public abstract virtual void set_MaxAutomaticRedirections(int value);
    public abstract virtual int get_MaxConnectionsPerServer();
    public abstract virtual void set_MaxConnectionsPerServer(int value);
    public abstract virtual int get_MaxResponseHeadersLength();
    public abstract virtual void set_MaxResponseHeadersLength(int value);
    public abstract virtual long get_MaxRequestContentBufferSize();
    public abstract virtual void set_MaxRequestContentBufferSize(long value);
    public abstract virtual IDictionary`2<string, object> get_Properties();
    public abstract virtual Task`1<HttpResponseMessage> SendAsync(HttpRequestMessage request, CancellationToken cancellationToken);
    public abstract virtual void SetWebRequestTimeout(TimeSpan timeout);
}
public abstract class System.Net.Http.MessageProcessingHandler : DelegatingHandler {
    protected MessageProcessingHandler(HttpMessageHandler innerHandler);
    protected abstract virtual HttpRequestMessage ProcessRequest(HttpRequestMessage request, CancellationToken cancellationToken);
    protected abstract virtual HttpResponseMessage ProcessResponse(HttpResponseMessage response, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.Net.Http.MessageProcessingHandler/<SendAsync>d__4")]
protected internal sealed virtual Task`1<HttpResponseMessage> SendAsync(HttpRequestMessage request, CancellationToken cancellationToken);
    [DebuggerHiddenAttribute]
[CompilerGeneratedAttribute]
private Task`1<HttpResponseMessage> <>n__0(HttpRequestMessage request, CancellationToken cancellationToken);
}
internal class System.Net.Http.MonoWebRequestHandler : object {
    
private static long groupCounter;
    
private bool allowAutoRedirect;
    
private DecompressionMethods automaticDecompression;
    
private CookieContainer cookieContainer;
    
private ICredentials credentials;
    
private int maxAutomaticRedirections;
    
private long maxRequestContentBufferSize;
    
private bool preAuthenticate;
    
private IWebProxy proxy;
    
private bool useCookies;
    
private bool useProxy;
    
private SslClientAuthenticationOptions sslOptions;
    
private bool allowPipelining;
    
private RequestCachePolicy cachePolicy;
    
private AuthenticationLevel authenticationLevel;
    
private TimeSpan continueTimeout;
    
private TokenImpersonationLevel impersonationLevel;
    
private int maxResponseHeadersLength;
    
private int readWriteTimeout;
    
private RemoteCertificateValidationCallback serverCertificateValidationCallback;
    
private bool unsafeAuthenticatedConnectionSharing;
    
private bool sentRequest;
    
private string connectionGroupName;
    
private Nullable`1<TimeSpan> timeout;
    
private bool disposed;
    
public bool AllowAutoRedirect { get; public set; }
    
public DecompressionMethods AutomaticDecompression { get; public set; }
    
public CookieContainer CookieContainer { get; public set; }
    
public ICredentials Credentials { get; public set; }
    
public int MaxAutomaticRedirections { get; public set; }
    
public long MaxRequestContentBufferSize { get; public set; }
    
public bool PreAuthenticate { get; public set; }
    
public IWebProxy Proxy { get; public set; }
    
public bool SupportsAutomaticDecompression { get; }
    
public bool SupportsProxy { get; }
    
public bool SupportsRedirectConfiguration { get; }
    
public bool UseCookies { get; public set; }
    
public bool UseProxy { get; public set; }
    
public bool AllowPipelining { get; public set; }
    
public RequestCachePolicy CachePolicy { get; public set; }
    
public AuthenticationLevel AuthenticationLevel { get; public set; }
    [MonoTODOAttribute]

public TimeSpan ContinueTimeout { get; public set; }
    
public TokenImpersonationLevel ImpersonationLevel { get; public set; }
    
public int MaxResponseHeadersLength { get; public set; }
    
public int ReadWriteTimeout { get; public set; }
    
public RemoteCertificateValidationCallback ServerCertificateValidationCallback { get; public set; }
    
public bool UnsafeAuthenticatedConnectionSharing { get; public set; }
    
public SslClientAuthenticationOptions SslOptions { get; public set; }
    
public ICredentials DefaultProxyCredentials { get; public set; }
    
public int MaxConnectionsPerServer { get; public set; }
    
public IDictionary`2<string, object> Properties { get; }
    internal void EnsureModifiability();
    public sealed virtual bool get_AllowAutoRedirect();
    public sealed virtual void set_AllowAutoRedirect(bool value);
    public sealed virtual DecompressionMethods get_AutomaticDecompression();
    public sealed virtual void set_AutomaticDecompression(DecompressionMethods value);
    public sealed virtual CookieContainer get_CookieContainer();
    public sealed virtual void set_CookieContainer(CookieContainer value);
    public sealed virtual ICredentials get_Credentials();
    public sealed virtual void set_Credentials(ICredentials value);
    public sealed virtual int get_MaxAutomaticRedirections();
    public sealed virtual void set_MaxAutomaticRedirections(int value);
    public sealed virtual long get_MaxRequestContentBufferSize();
    public sealed virtual void set_MaxRequestContentBufferSize(long value);
    public sealed virtual bool get_PreAuthenticate();
    public sealed virtual void set_PreAuthenticate(bool value);
    public sealed virtual IWebProxy get_Proxy();
    public sealed virtual void set_Proxy(IWebProxy value);
    public virtual bool get_SupportsAutomaticDecompression();
    public virtual bool get_SupportsProxy();
    public virtual bool get_SupportsRedirectConfiguration();
    public sealed virtual bool get_UseCookies();
    public sealed virtual void set_UseCookies(bool value);
    public sealed virtual bool get_UseProxy();
    public sealed virtual void set_UseProxy(bool value);
    public bool get_AllowPipelining();
    public void set_AllowPipelining(bool value);
    public RequestCachePolicy get_CachePolicy();
    public void set_CachePolicy(RequestCachePolicy value);
    public AuthenticationLevel get_AuthenticationLevel();
    public void set_AuthenticationLevel(AuthenticationLevel value);
    public TimeSpan get_ContinueTimeout();
    public void set_ContinueTimeout(TimeSpan value);
    public TokenImpersonationLevel get_ImpersonationLevel();
    public void set_ImpersonationLevel(TokenImpersonationLevel value);
    public sealed virtual int get_MaxResponseHeadersLength();
    public sealed virtual void set_MaxResponseHeadersLength(int value);
    public int get_ReadWriteTimeout();
    public void set_ReadWriteTimeout(int value);
    public RemoteCertificateValidationCallback get_ServerCertificateValidationCallback();
    public void set_ServerCertificateValidationCallback(RemoteCertificateValidationCallback value);
    public bool get_UnsafeAuthenticatedConnectionSharing();
    public void set_UnsafeAuthenticatedConnectionSharing(bool value);
    public sealed virtual SslClientAuthenticationOptions get_SslOptions();
    public sealed virtual void set_SslOptions(SslClientAuthenticationOptions value);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    private bool GetConnectionKeepAlive(HttpRequestHeaders headers);
    internal virtual HttpWebRequest CreateWebRequest(HttpRequestMessage request);
    private HttpResponseMessage CreateResponseMessage(HttpWebResponse wr, HttpRequestMessage requestMessage, CancellationToken cancellationToken);
    private static bool MethodHasBody(HttpMethod method);
    [AsyncStateMachineAttribute("System.Net.Http.MonoWebRequestHandler/<SendAsync>d__99")]
public sealed virtual Task`1<HttpResponseMessage> SendAsync(HttpRequestMessage request, CancellationToken cancellationToken);
    public sealed virtual ICredentials get_DefaultProxyCredentials();
    public sealed virtual void set_DefaultProxyCredentials(ICredentials value);
    public sealed virtual int get_MaxConnectionsPerServer();
    public sealed virtual void set_MaxConnectionsPerServer(int value);
    public sealed virtual IDictionary`2<string, object> get_Properties();
    private sealed virtual override void System.Net.Http.IMonoHttpClientHandler.SetWebRequestTimeout(TimeSpan timeout);
    [CompilerGeneratedAttribute]
private X509Certificate <CreateWebRequest>b__96_0(string t, X509CertificateCollection lc, X509Certificate rc, String[] ai);
}
public class System.Net.Http.MultipartContent : HttpContent {
    
private List`1<HttpContent> nested_content;
    
private string boundary;
    public MultipartContent(string subtype);
    public MultipartContent(string subtype, string boundary);
    private static bool IsValidRFC2049(string s);
    public virtual void Add(HttpContent content);
    protected virtual void Dispose(bool disposing);
    [AsyncStateMachineAttribute("System.Net.Http.MultipartContent/<SerializeToStreamAsync>d__8")]
protected virtual Task SerializeToStreamAsync(Stream stream, TransportContext context);
    protected internal virtual bool TryComputeLength(Int64& length);
    public sealed virtual IEnumerator`1<HttpContent> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class System.Net.Http.MultipartFormDataContent : MultipartContent {
    public MultipartFormDataContent(string boundary);
    public virtual void Add(HttpContent content);
    public void Add(HttpContent content, string name);
    public void Add(HttpContent content, string name, string fileName);
    private void AddContentDisposition(HttpContent content, string name, string fileName);
}
internal static class System.Net.Http.PlatformHelper : object {
    internal static bool IsContentHeader(string name);
    internal static string GetSingleHeaderString(string name, IEnumerable`1<string> values);
    internal static StreamContent CreateStreamContent(Stream stream, CancellationToken cancellationToken);
}
public class System.Net.Http.ReadOnlyMemoryContent : HttpContent {
    public ReadOnlyMemoryContent(ReadOnlyMemory`1<byte> content);
    protected virtual Task SerializeToStreamAsync(Stream stream, TransportContext context);
    protected internal virtual bool TryComputeLength(Int64& length);
}
public class System.Net.Http.StreamContent : HttpContent {
    
private Stream content;
    
private int bufferSize;
    
private CancellationToken cancellationToken;
    
private long startPosition;
    
private bool contentCopied;
    public StreamContent(Stream content);
    public StreamContent(Stream content, int bufferSize);
    internal StreamContent(Stream content, CancellationToken cancellationToken);
    protected virtual Task`1<Stream> CreateContentReadStreamAsync();
    protected virtual void Dispose(bool disposing);
    protected virtual Task SerializeToStreamAsync(Stream stream, TransportContext context);
    protected internal virtual bool TryComputeLength(Int64& length);
}
public class System.Net.Http.StringContent : ByteArrayContent {
    public StringContent(string content);
    public StringContent(string content, Encoding encoding);
    public StringContent(string content, Encoding encoding, string mediaType);
    private static Byte[] GetByteArray(string content, Encoding encoding);
}
internal class Unity.ThrowStub : ObjectDisposedException {
    public static void ThrowNotSupportedException();
}
