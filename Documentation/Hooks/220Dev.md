# Hook Definitions

## OnDieselEngineToggled(DieselEngine)

```csharp
```csharp
/// <summary>
/// Called when the diesel engine is toggled on or off.
/// </summary>
/// <param name="engine">The diesel engine that was toggled.</param>
/// <returns>No return behavior.</returns>
void OnDieselEngineToggled(DieselEngine engine)
{
    Puts($"Diesel engine {engine.GetId()} has been {(GetFlag(Flags.On) ? "turned off" : "turned on")}.");
}
```
```

### Source Code from the Library

```csharp

	public void EngineOff()
	{
		SetFlag(Flags.On, b: false);
		BroadcastEntityMessage("DieselEngineOff");
		Interface.CallHook("OnDieselEngineToggled", this);
	}

```

## OnHelicopterDropCrate(CH47HelicopterAIController)

```csharp
```csharp
/// <summary>
/// Called when a helicopter drops a crate.
/// </summary>
/// <param name="helicopter">The helicopter that dropped the crate.</param>
/// <returns>No return behavior.</returns>
void OnHelicopterDropCrate(CH47HelicopterAIController helicopter)
{
    Puts($"Helicopter {helicopter.GetReference().GetEntityID()} has dropped a crate.");
}
```
```

### Source Code from the Library

```csharp

	public void DropCrate()
	{
		if (numCrates > 0)
		{
			Vector3 pos = base.transform.position + Vector3.down * 5f;
			Quaternion rot = Quaternion.Euler(0f, UnityEngine.Random.Range(0f, 360f), 0f);
			BaseEntity baseEntity = GameManager.server.CreateEntity(lockedCratePrefab.resourcePath, pos, rot);
			if ((bool)baseEntity)
			{
				Interface.CallHook("OnHelicopterDropCrate", this);
				baseEntity.SendMessage("SetWasDropped");
				baseEntity.Spawn();
			}
			numCrates--;
		}
	}

```

## OnNpcRadioChatter(ScientistNPC)

```csharp
```csharp
/// <summary>
/// Called when an NPC's radio chatter is played.
/// </summary>
/// <param name="npc">The ScientistNPC instance.</param>
/// <returns>
/// Returns `null` to allow the radio chatter to play, or any non-null value to prevent it from playing.
/// </returns>
object OnNpcRadioChatter(ScientistNPC npc)
{
    Puts($"Scientist NPC {npc.name} is playing radio chatter.");
    if (npc.isInjured)
    {
        Puts($"Scientist NPC {npc.name} is injured and cannot play radio chatter.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void PlayRadioChatter()
	{
		if (RadioChatterEffects.Length != 0)
		{
			if (base.IsDestroyed || base.transform == null)
			{
				CancelInvoke(PlayRadioChatter);
			}
			else if (Interface.CallHook("OnNpcRadioChatter", this) == null)
			{
				Effect.server.Run(RadioChatterEffects[UnityEngine.Random.Range(0, RadioChatterEffects.Length)].resourcePath, this, StringPool.Get("head"), Vector3.zero, Vector3.zero);
				QueueRadioChatter();
			}
		}
	}

```

## OnShopCompleteTrade(ShopFront)

```csharp
```csharp
/// <summary>
/// Called when a trade is completed in the shop.
/// </summary>
/// <param name="shopFront">The shop front where the trade was completed.</param>
/// <returns>
/// Returns `null` to allow the trade completion, or any non-null value to prevent it.
/// If a string is returned, an error message will be displayed to the players involved in the trade.
/// </returns>
object OnShopCompleteTrade(ShopFront shopFront)
{
    Puts($"Trade completed at shop front {shopFront.name}.");
    if (shopFront.itemsBeingTraded.Count == 0)
    {
        Puts($"No items were being traded at shop front {shopFront.name}, so the trade completion was cancelled.");
        return "Error: No items to trade.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void CompleteTrade()
	{
		if (vendorPlayer != null && customerPlayer != null && HasFlag(Flags.Reserved1) && HasFlag(Flags.Reserved2))
		{
			if (Interface.CallHook("OnShopCompleteTrade", this) != null)
			{
				return;
			}
			for (int num = vendorInventory.capacity - 1; num >= 0; num--)
			{
				Item slot = vendorInventory.GetSlot(num);
				Item slot2 = customerInventory.GetSlot(num);
				if ((bool)customerPlayer && slot != null)
				{
					customerPlayer.GiveItem(slot);
				}
				if ((bool)vendorPlayer && slot2 != null)
				{
					vendorPlayer.GiveItem(slot2);
				}
			}
			Effect.server.Run(transactionCompleteEffect.resourcePath, this, 0u, new Vector3(0f, 1f, 0f), Vector3.zero);
		}
		ResetTrade();
		SendNetworkUpdate();
	}

```

## OnCargoShipEgress(CargoShip)

```csharp
```csharp
/// <summary>
/// Called when a cargo ship starts egressing.
/// </summary>
/// <param name="ship">The cargo ship starting to egress.</param>
/// <returns>
/// Returns `null` to allow the ship to start egressing, or any non-null value to prevent it from egressing.
/// </returns>
object OnCargoShipEgress(CargoShip ship)
{
    Puts($"Cargo ship {ship.Name} has started egressing.");
    if (ship.IsDamaged())
    {
        Puts($"Cargo ship {ship.Name} is damaged and cannot egress.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void StartEgress()
	{
		if (!egressing && Interface.CallHook("OnCargoShipEgress", this) == null)
		{
			egressing = true;
			CancelInvoke(PlayHorn);
			radiation.SetActive(value: true);
			SetFlag(Flags.Reserved8, b: true);
			InvokeRepeating(UpdateRadiation, 10f, 1f);
			Invoke(DelayedDestroy, 60f * egress_duration_minutes);
		}
	}

```

## OnCrateDropped(HackableLockedCrate)

```csharp
```csharp
/// <summary>
/// Called when a crate is dropped.
/// </summary>
/// <param name="crate">The crate that was dropped.</param>
/// <returns>No return behavior.</returns>
void OnCrateDropped(HackableLockedCrate crate)
{
    Puts($"Crate {crate.CrateID} has been dropped.");
}
```
```

### Source Code from the Library

```csharp

	public void SetWasDropped()
	{
		wasDropped = true;
		Interface.CallHook("OnCrateDropped", this);
	}

```

## OnBuildingPrivilege(BaseEntity,OBB)

```csharp
```csharp
/// <summary>
/// Called when a building privilege is being determined.
/// </summary>
/// <param name="entity">The entity whose building privilege is being determined.</param>
/// <param name="obb">The OBB (oriented bounding box) of the building.</param>
/// <returns>
/// Returns a non-null value to override the default building privilege behavior. 
/// If `null` is returned, the building privilege will be determined based on other factors.
/// </returns>
object OnBuildingPrivilege(BaseEntity entity, OBB obb)
{
    Puts($"Determining building privilege for {entity.UserIDString} at position {obb.position}");
    if (obb.extents.magnitude > 10f)
    {
        Puts($"Building privilege denied due to large size.");
        return "Denied: Building is too large.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public BuildingPrivlidge GetBuildingPrivilege(OBB obb)
	{
		object obj = Interface.CallHook("OnBuildingPrivilege", this, obb);
		if (obj is BuildingPrivlidge)
		{
			return (BuildingPrivlidge)obj;
		}
		BuildingBlock other = null;
		BuildingPrivlidge result = null;
		List<BuildingBlock> obj2 = Facepunch.Pool.GetList<BuildingBlock>();
		Vis.Entities(obb.position, 16f + obb.extents.magnitude, obj2, 2097152);
		for (int i = 0; i < obj2.Count; i++)
		{
			BuildingBlock buildingBlock = obj2[i];
			if (buildingBlock.isServer != base.isServer || !buildingBlock.IsOlderThan(other) || obb.Distance(buildingBlock.WorldSpaceBounds()) > 16f)
			{
				continue;
			}
			BuildingManager.Building building = buildingBlock.GetBuilding();
			if (building != null)
			{
				BuildingPrivlidge dominatingBuildingPrivilege = building.GetDominatingBuildingPrivilege();
				if (!(dominatingBuildingPrivilege == null))
				{
					other = buildingBlock;
					result = dominatingBuildingPrivilege;
				}
			}
		}
		Facepunch.Pool.FreeList(ref obj2);
		return result;
	}

```

## OnItemDropped(Item,BaseEntity)

```csharp
```csharp
/// <summary>
/// Called when an item is dropped.
/// </summary>
/// <param name="item">The item being dropped.</param>
/// <param name="baseEntity">The BaseEntity representing the dropped item, or null if the item cannot be dropped.</param>
/// <returns>No return behavior.</returns>
void OnItemDropped(Item item, BaseEntity baseEntity)
{
    Puts($"Item {item.info.name} has been dropped.");
    if (baseEntity != null && baseEntity is BasePlayer)
    {
        Puts($"The item was dropped by player {((BasePlayer)baseEntity).displayName}");
    }
}
```
```

### Source Code from the Library

```csharp

	public BaseEntity Drop(Vector3 vPos, Vector3 vVelocity, Quaternion rotation = default(Quaternion))
	{
		RemoveFromWorld();
		BaseEntity baseEntity = null;
		if (vPos != Vector3.zero && !info.HasFlag(ItemDefinition.Flag.NoDropping))
		{
			baseEntity = CreateWorldObject(vPos, rotation);
			if ((bool)baseEntity)
			{
				baseEntity.SetVelocity(vVelocity);
			}
		}
		else
		{
			Remove();
		}
		Interface.CallHook("OnItemDropped", this, baseEntity);
		RemoveFromContainer();
		return baseEntity;
	}

```

## OnNetworkGroupLeft(BaseNetworkable,Network.Visibility.Group)

```csharp
```csharp
/// <summary>
/// Called when a network group is left.
/// </summary>
/// <param name="networkable">The network object that left the group.</param>
/// <param name="group">The group that was left.</param>
/// <returns>No return behavior.</returns>
void OnNetworkGroupLeft(BaseNetworkable networkable, Network.Visibility.Group group)
{
    Puts($"Network group {group} has been left by {networkable.UserIDString}");
}
```
```

### Source Code from the Library

```csharp

	public virtual void OnNetworkGroupLeave(Group group)
	{
		Interface.CallHook("OnNetworkGroupLeft", this, group);
	}

```

## OnItemRemovedFromContainer(ItemContainer,Item)

```csharp
```csharp
/// <summary>
/// Called when an item is removed from a container.
/// </summary>
/// <param name="container">The container from which the item was removed.</param>
/// <param name="item">The item that was removed.</param>
/// <returns>No return behavior.</returns>
void OnItemRemovedFromContainer(ItemContainer container, Item item)
{
    Puts($"Item {item.name} has been removed from container {container.name}");
}
```
```

### Source Code from the Library

```csharp

	public bool Remove(Item item)
	{
		if (!itemList.Contains(item))
		{
			return false;
		}
		if (onPreItemRemove != null)
		{
			onPreItemRemove(item);
		}
		itemList.Remove(item);
		item.parent = null;
		MarkDirty();
		if (onItemAddedRemoved != null)
		{
			onItemAddedRemoved(item, arg2: false);
		}
		Interface.CallHook("OnItemRemovedFromContainer", this, item);
		return true;
	}

```

## CanSetBedPublic(BasePlayer,SleepingBag)

```csharp
```csharp
/// <summary>
/// Called when a player tries to set their bed public or private.
/// </summary>
/// <param name="player">The player trying to set the bed's visibility.</param>
/// <param name="bed">The sleeping bag being modified.</param>
/// <returns>
/// Returns `null` if the player is allowed to change the bed's visibility, or any non-null value to prevent them from doing so.
/// </returns>
object CanSetBedPublic(BasePlayer player, SleepingBag bed)
{
    Puts($"Player {player.UserIDString} tried to set their bed public or private.");
    if (bed.IsDeployedByAdmin())
    {
        Puts($"Player {player.displayName} is not allowed to change the visibility of an admin-deployed bed.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	public void RPC_MakePublic(RPCMessage msg)
	{
		if (!canBePublic || !msg.player.CanInteract() || (deployerUserID != msg.player.userID && !msg.player.CanBuild()))
		{
			return;
		}
		bool flag = msg.read.Bit();
		if (flag != IsPublic() && Interface.CallHook("CanSetBedPublic", msg.player, this) == null)
		{
			SetPublic(flag);
			if (!IsPublic())
			{
				deployerUserID = msg.player.userID;
			}
			SendNetworkUpdate();
		}
	}

```

## OnTurretRotate(AutoTurret,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a turret rotates its aim.
/// </summary>
/// <param name="turret">The AutoTurret instance that rotated.</param>
/// <param name="target">The player the turret is aiming at.</param>
/// <returns>No return behavior.</returns>
void OnTurretRotate(AutoTurret turret, BasePlayer target)
{
    Puts($"Turret {turret.name} has rotated its aim towards player {target.displayName}");
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	private void FlipAim(RPCMessage rpc)
	{
		if (!IsOnline() && IsAuthed(rpc.player) && !booting && Interface.CallHook("OnTurretRotate", this, rpc.player) == null)
		{
			base.transform.rotation = Quaternion.LookRotation(-base.transform.forward, base.transform.up);
			SendNetworkUpdate();
		}
	}

```

## OnStructureDemolish(BuildingBlock,BasePlayer,bool)

```csharp
```csharp
/// <summary>
/// Called when a structure is demolished.
/// </summary>
/// <param name="structure">The structure being demolished.</param>
/// <param name="player">The player demolishing the structure.</param>
/// <param name="isForced">Whether the demolition was forced or not.</param>
/// <returns>
/// Returns `null` to allow the structure to be demolished, or any non-null value to prevent it from being demolished.
/// </returns>
object OnStructureDemolish(BuildingBlock structure, BasePlayer player, bool isForced)
{
    Puts($"Structure {structure.name} has been demolished by player {player.UserIDString}.");
    if (isForced && structure.isImportant)
    {
        Puts($"Demolition of important structure {structure.name} was forced.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	private void DoDemolish(RPCMessage msg)
	{
		if (msg.player.CanInteract() && CanDemolish(msg.player) && Interface.CallHook("OnStructureDemolish", this, msg.player, false) == null)
		{
			Kill(DestroyMode.Gib);
		}
	}

```

## CanBeTargeted(BasePlayer,GunTrap)

```csharp
```csharp
/// <summary>
/// Called to check if a player can be targeted by the gun trap.
/// </summary>
/// <param name="player">The player being checked.</param>
/// <param name="gunTrap">The gun trap doing the checking.</param>
/// <returns>
/// Returns `true` if the player can be targeted, and `false` otherwise.
/// If a non-bool value is returned, it will override the default behavior.
/// </returns>
object CanBeTargeted(BasePlayer player, GunTrap gunTrap)
{
    Puts($"Checking if player {player.UserIDString} can be targeted by gun trap {gunTrap.NetID()}");
    // Custom logic to determine if the player can be targeted
    // For example:
    if (player.IsAdmin())
    {
        return false;
    }
    else if (player.HasFlag("VIP"))
    {
        return true;
    }
    else
    {
        return null; // Default behavior
    }
}
```
```

### Source Code from the Library

```csharp

	public bool CheckTrigger()
	{
		List<RaycastHit> obj = Pool.GetList<RaycastHit>();
		HashSet<BaseEntity> entityContents = trigger.entityContents;
		bool flag = false;
		if (entityContents != null)
		{
			foreach (BaseEntity item in entityContents)
			{
				BasePlayer component = item.GetComponent<BasePlayer>();
				if (component.IsSleeping() || !component.IsAlive() || component.IsBuildingAuthed())
				{
					continue;
				}
				object obj2 = Interface.CallHook("CanBeTargeted", component, this);
				if (obj2 is bool)
				{
					Pool.FreeList(ref obj);
					return (bool)obj2;
				}
				obj.Clear();
				GamePhysics.TraceAll(new Ray(component.eyes.position, (GetEyePosition() - component.eyes.position).normalized), 0f, obj, 9f, 1218519297);
				for (int i = 0; i < obj.Count; i++)
				{
					BaseEntity entity = RaycastHitEx.GetEntity(obj[i]);
					if (entity != null && (entity == this || entity.EqualNetID(this)))
					{
						flag = true;
						break;
					}
					if (!(entity != null) || entity.ShouldBlockProjectiles())
					{
						break;
					}
				}
				if (flag)
				{
					break;
				}
			}
		}
		Pool.FreeList(ref obj);
		return flag;
	}

```

## OnCollectiblePickup(Item,BasePlayer,CollectibleEntity)

```csharp
```csharp
/// <summary>
/// Called when a player picks up a collectible item.
/// </summary>
/// <param name="item">The item being picked up.</param>
/// <param name="player">The player picking up the item.</param>
/// <param name="entity">The entity associated with the collectible item.</param>
/// <returns>
/// Returns `null` to allow the default pickup behavior, or any non-null value to override it.
/// If a string is returned, the player will be notified of the reason for not picking up the item.
/// </returns>
object OnCollectiblePickup(Item item, BasePlayer player, CollectibleEntity entity)
{
    Puts($"Player {player.UserIDString} picked up collectible item: {item.info.name}");
    if (entity.isLocked)
    {
        Puts($"Player {player.displayName} is not allowed to pick up the locked collectible item.");
        return "Item is locked.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void DoPickup(BasePlayer reciever)
	{
		if (itemList == null)
		{
			return;
		}
		ItemAmount[] array = itemList;
		foreach (ItemAmount itemAmount in array)
		{
			Item item = ItemManager.Create(itemAmount.itemDef, (int)itemAmount.amount, 0uL);
			if (item == null)
			{
				continue;
			}
			if ((bool)reciever)
			{
				if (Interface.CallHook("OnCollectiblePickup", item, reciever, this) != null)
				{
					return;
				}
				reciever.GiveItem(item, GiveItemReason.ResourceHarvested);
			}
			else
			{
				item.Drop(base.transform.position + Vector3.up * 0.5f, Vector3.up);
			}
		}
		itemList = null;
		if (pickupEffect.isValid)
		{
			Effect.server.Run(pickupEffect.resourcePath, base.transform.position, base.transform.up);
		}
		Kill();
	}

```

## OnEventTrigger(TriggeredEventPrefab)

```csharp
```csharp
/// <summary>
/// Called when an event is triggered.
/// </summary>
/// <param name="eventPrefab">The prefab of the event that was triggered.</param>
/// <returns>
/// Returns `null` to allow the event to trigger normally, or any non-null value to prevent the event from triggering.
/// </returns>
object OnEventTrigger(TriggeredEventPrefab eventPrefab)
{
    Puts($"Event {eventPrefab.resourcePath} has been triggered.");
    if (eventPrefab.name == "Test Event")
    {
        Puts($"Event {eventPrefab.name} is a test event and will not trigger any further actions.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	private void RunEvent()
	{
		if (Interface.CallHook("OnEventTrigger", this) == null)
		{
			Debug.Log("[event] " + targetPrefab.resourcePath);
			BaseEntity baseEntity = GameManager.server.CreateEntity(targetPrefab.resourcePath);
			if ((bool)baseEntity)
			{
				baseEntity.SendMessage("TriggeredEventSpawn", SendMessageOptions.DontRequireReceiver);
				baseEntity.Spawn();
			}
		}
	}

```

## CanHelicopterDropCrate(CH47HelicopterAIController)

```csharp
```csharp
/// <summary>
/// Called to determine if a helicopter can drop a crate.
/// </summary>
/// <param name="helicopter">The helicopter attempting to drop the crate.</param>
/// <returns>
/// Returns `true` if the helicopter is allowed to drop the crate, and `false` otherwise.
/// If any other type of object is returned, it will be treated as a custom reason for not dropping the crate.
/// </returns>
object CanHelicopterDropCrate(CH47HelicopterAIController helicopter)
{
    Puts($"Helicopter {helicopter.GetReference().GetEntityId()} attempting to drop crate.");
    if (helicopter.IsLowOnFuel())
    {
        Puts($"Helicopter {helicopter.GetReference().GetEntityId()} is low on fuel and cannot drop crate.");
        return "Not enough fuel.";
    }
    return true;
}
```
```

### Source Code from the Library

```csharp

	public bool CanDropCrate()
	{
		object obj = Interface.CallHook("CanHelicopterDropCrate", this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return numCrates > 0;
	}

```

## OnLootEntity(BasePlayer,BaseEntity)

```csharp
```csharp
/// <summary>
/// Called when a player starts looting an entity.
/// </summary>
/// <param name="looter">The player doing the looting.</param>
/// <param name="entity">The entity being looted.</param>
/// <returns>No return behavior.</returns>
void OnLootEntity(BasePlayer looter, BaseEntity entity)
{
    Puts($"Player {looter.UserIDString} started looting entity {entity.baseEntityID}");
    if (entity is BaseCorpse)
    {
        Puts($"Player {looter.UserIDString} is looting a corpse.");
    }
    else
    {
        Puts($"Player {looter.UserIDString} is looting an unknown entity type.");
    }
}
```
```

### Source Code from the Library

```csharp

	public bool StartLootingEntity(BaseEntity targetEntity, bool doPositionChecks = true)
	{
		Clear();
		if (!targetEntity)
		{
			return false;
		}
		if (!targetEntity.OnStartBeingLooted(base.baseEntity))
		{
			return false;
		}
		Assert.IsTrue(targetEntity.isServer, "Assure is server");
		PositionChecks = doPositionChecks;
		entitySource = targetEntity;
		itemSource = null;
		Interface.CallHook("OnLootEntity", GetComponent<BasePlayer>(), targetEntity);
		MarkDirty();
		return true;
	}

```

## OnShopAcceptClick(ShopFront,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player clicks the "Accept" button in the shop.
/// </summary>
/// <param name="shopFront">The shop front where the click occurred.</param>
/// <param name="player">The player who clicked the button.</param>
/// <returns>
/// Returns `null` to allow the trade to proceed, or any non-null value to cancel the trade.
/// </returns>
object OnShopAcceptClick(ShopFront shopFront, BasePlayer player)
{
    Puts($"Player {player.UserIDString} has accepted the trade at shop front {shopFront.name}");
    if (player.HasPermission("can_cancel_trade"))
    {
        Puts($"Player {player.displayName} is trying to cancel the trade.");
        return "Trade cancelled by player.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	public void AcceptClicked(RPCMessage msg)
	{
		if (IsTradingPlayer(msg.player) && !(vendorPlayer == null) && !(customerPlayer == null) && Interface.CallHook("OnShopAcceptClick", this, msg.player) == null)
		{
			if (IsPlayerVendor(msg.player))
			{
				SetFlag(Flags.Reserved1, b: true);
				vendorInventory.SetLocked(isLocked: true);
			}
			else if (IsPlayerCustomer(msg.player))
			{
				SetFlag(Flags.Reserved2, b: true);
				customerInventory.SetLocked(isLocked: true);
			}
			if (HasFlag(Flags.Reserved1) && HasFlag(Flags.Reserved2))
			{
				SetFlag(Flags.Reserved3, b: true);
				Invoke(CompleteTrade, 2f);
			}
		}
	}

```

## OnToggleVendingBroadcast(VendingMachine,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when the vending broadcast toggle is changed.
/// </summary>
/// <param name="vendingMachine">The vending machine that was toggled.</param>
/// <param name="player">The player who performed the action.</param>
/// <returns>No return behavior.</returns>
void OnToggleVendingBroadcast(VendingMachine vendingMachine, BasePlayer player)
{
    Puts($"Vending broadcast toggle changed by {player.displayName} for vending machine {vendingMachine.name}");
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void RPC_Broadcast(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		bool b = msg.read.Bit();
		if (CanPlayerAdmin(player))
		{
			SetFlag(Flags.Reserved4, b);
			Interface.CallHook("OnToggleVendingBroadcast", this, player);
			UpdateMapMarker();
		}
	}

```

## OnEntityLeave(TriggerComfort,BaseEntity)

```csharp
```csharp
/// <summary>
/// Called when an entity leaves the trigger comfort.
/// </summary>
/// <param name="trigger">The trigger that was left.</param>
/// <param name="entity">The entity that left the trigger.</param>
/// <returns>No return behavior.</returns>
void OnEntityLeave(TriggerComfort trigger, BaseEntity entity)
{
    Puts($"Entity {entity.UserIDString} has left the comfort zone of trigger {trigger.name}");
}
```
```

### Source Code from the Library

```csharp

	public override void OnEntityLeave(BaseEntity ent)
	{
		BasePlayer basePlayer = ent as BasePlayer;
		if ((bool)basePlayer && Interface.CallHook("OnEntityLeave", this, ent) == null)
		{
			_players.Remove(basePlayer);
		}
	}

```

## OnLootItem(BasePlayer,Item)

```csharp
```csharp
/// <summary>
/// Called when a player starts looting an item.
/// </summary>
/// <param name="player">The player starting to loot the item.</param>
/// <param name="item">The item being looted.</param>
/// <returns>No return behavior.</returns>
void OnLootItem(BasePlayer player, Item item)
{
    Puts($"Player {player.UserIDString} started looting item: {item.name}");
}
```
```

### Source Code from the Library

```csharp

	public void StartLootingItem(Item item)
	{
		Clear();
		if (item != null && item.contents != null)
		{
			PositionChecks = true;
			containers.Add(item.contents);
			item.contents.onDirty += MarkDirty;
			itemSource = item;
			entitySource = item.GetWorldEntity();
			Interface.CallHook("OnLootItem", GetComponent<BasePlayer>(), item);
			MarkDirty();
		}
	}

```

## OnHelicopterTarget(HelicopterTurret,BaseCombatEntity)

```csharp
```csharp
/// <summary>
/// Called when a helicopter turret sets its target.
/// </summary>
/// <param name="turret">The helicopter turret setting the target.</param>
/// <param name="target">The entity being targeted by the helicopter turret.</param>
/// <returns>
/// Returns `null` to allow the helicopter turret to set its target, or any non-null value to prevent it from setting its target.
/// </returns>
object OnHelicopterTarget(HelicopterTurret turret, BaseCombatEntity target)
{
    Puts($"Helicopter Turret {turret.GetReference()} is targeting entity {target.UserIDString}.");
    if (target is Player player && player.IsAdmin)
    {
        Puts($"Helicopter Turret {turret.GetReference()} has been prevented from targeting admin player {player.UserIDString}.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void SetTarget(BaseCombatEntity newTarget)
	{
		if (Interface.CallHook("OnHelicopterTarget", this, newTarget) == null)
		{
			_target = newTarget;
			UpdateTargetVisibility();
		}
	}

```

## CanDeployItem(BasePlayer,Deployer,uint)

```csharp
```csharp
/// <summary>
/// Called to check if an item can be deployed.
/// </summary>
/// <param name="player">The player attempting to deploy the item.</param>
/// <param name="deployer">The deployable item being deployed.</param>
/// <param name="num">The number of items to deploy.</param>
/// <returns>
/// Returns `null` if the deployment is allowed, or any non-null value to prevent the deployment.
/// </returns>
object CanDeployItem(BasePlayer player, Deployer deployer, uint num)
{
    Puts($"Player {player.UserIDString} attempted to deploy {num} items.");
    if (deployer.isLocked)
    {
        Puts($"Deployment of {deployer.name} is locked by another player.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsActiveItem]
	private void DoDeploy(RPCMessage msg)
	{
		if (!msg.player.CanInteract())
		{
			return;
		}
		Deployable deployable = GetDeployable();
		if (deployable == null)
		{
			return;
		}
		Ray ray = msg.read.Ray();
		uint num = msg.read.UInt32();
		if (Interface.CallHook("CanDeployItem", msg.player, this, num) == null)
		{
			if (deployable.toSlot)
			{
				DoDeploy_Slot(deployable, ray, num);
			}
			else
			{
				DoDeploy_Regular(deployable, ray);
			}
		}
	}

```

## OnNpcStopMoving(NPCPlayerApex)

```csharp
```csharp
/// <summary>
/// Called when an NPC stops moving.
/// </summary>
/// <param name="npc">The NPC that stopped moving.</param>
/// <returns>No return behavior.</returns>
void OnNpcStopMoving(NPCPlayerApex npc)
{
    Puts($"NPC {npc.name} has stopped moving.");
}
```
```

### Source Code from the Library

```csharp

	public void StopMoving()
	{
		if (Interface.CallHook("OnNpcStopMoving", this) == null)
		{
			IsStopped = true;
			finalDestination = GetPosition();
		}
	}

```

## OnNpcAlert(ScientistNPC)

```csharp
```csharp
/// <summary>
/// Called when an NPC alerts.
/// </summary>
/// <param name="npc">The NPC that alerted.</param>
/// <returns>
/// Returns `null` to allow the NPC to alert, or any non-null value to prevent them from alerting.
/// </returns>
object OnNpcAlert(ScientistNPC npc)
{
    Puts($"NPC {npc.Name} has alerted.");
    if (npc.IsInDanger())
    {
        Puts($"NPC {npc.Name} is in danger and will not alert again for 5 minutes.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void Alert()
	{
		if (Interface.CallHook("OnNpcAlert", this) == null)
		{
			lastAlertedTime = Time.time;
			SetChatterType(RadioChatterType.Alert);
		}
	}

```

## CanUnlock(BasePlayer,KeyLock)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can unlock the object.
/// </summary>
/// <param name="player">The player attempting to unlock.</param>
/// <param name="lock">The lock being unlocked.</param>
/// <returns>
/// Returns `null` to allow the player to unlock, or any non-null value to prevent them from unlocking.
/// </returns>
object CanUnlock(BasePlayer player, KeyLock lock)
{
    Puts($"Player {player.UserIDString} is attempting to unlock {lock.name}");
    if (player.IsAdmin)
    {
        return null;
    }
    else
    {
        return "Access denied: Only admins can unlock";
    }
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	private void RPC_Unlock(RPCMessage rpc)
	{
		if (rpc.player.CanInteract() && IsLocked() && Interface.CallHook("CanUnlock", rpc.player, this) == null && HasLockPermission(rpc.player))
		{
			SetFlag(Flags.Locked, b: false);
			SendNetworkUpdate();
		}
	}

```

## OnItemUse(Item,int)

```csharp
```csharp
/// <summary>
/// Called when an item is used.
/// </summary>
/// <param name="item">The item being used.</param>
/// <param name="amountToConsume">The amount of the item to consume. Defaults to 1.</param>
/// <returns>
/// Returns a non-null value to override the default behavior. If an integer is returned, it will be used as the new amount to consume.
/// </returns>
object OnItemUse(Item item, int amountToConsume)
{
    Puts($"Item {item.Name} has been used.");
    if (amountToConsume > 0)
    {
        // Perform any necessary actions when the item is used
        return null;
    }
    else
    {
        // Handle invalid or zero consumption amounts
        return "Error: Invalid amount to consume.";
    }
}
```
```

### Source Code from the Library

```csharp

	public void UseItem(int amountToConsume = 1)
	{
		if (amountToConsume > 0)
		{
			object obj = Interface.CallHook("OnItemUse", this, amountToConsume);
			if (obj is int)
			{
				amountToConsume = (int)obj;
			}
			amount -= amountToConsume;
			if (amount <= 0)
			{
				amount = 0;
				Remove();
			}
			else
			{
				MarkDirty();
			}
		}
	}

```

## OnCrateLanded(HackableLockedCrate)

```csharp
```csharp
/// <summary>
/// Called when a hackable locked crate lands.
/// </summary>
/// <param name="crate">The landed crate.</param>
/// <returns>No return behavior.</returns>
void OnCrateLanded(HackableLockedCrate crate)
{
    Puts($"Hackable locked crate landed at position {crate.transform.position}.");
}
```
```

### Source Code from the Library

```csharp

	public void LandCheck()
	{
		RaycastHit hitInfo;
		if (hasLanded)
		{
			Interface.CallHook("OnCrateLanded", this);
		}
		else if (UnityEngine.Physics.Raycast(new Ray(base.transform.position + Vector3.up * 0.5f, Vector3.down), out hitInfo, 1f, 1218511105))
		{
			Effect.server.Run(landEffect.resourcePath, hitInfo.point, Vector3.up);
			hasLanded = true;
			CancelInvoke(LandCheck);
		}
	}

```

## OnNpcAttack(BaseNpc,BaseEntity)

```csharp
```csharp
/// <summary>
/// Called when an NPC attacks a target.
/// </summary>
/// <param name="npc">The NPC performing the attack.</param>
/// <param name="target">The entity being attacked.</param>
/// <returns>
/// Returns `null` to allow the attack to proceed, or any non-null value to prevent the attack from occurring.
/// </returns>
object OnNpcAttack(BaseNpc npc, BaseEntity target)
{
    Puts($"NPC {npc.name} is attacking {target.UserIDString}.");
    if (target == null || target.IsDead)
    {
        Puts($"Target {target.UserIDString} is already dead or does not exist.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual void StartAttack()
	{
		if ((bool)AttackTarget && AttackReady() && Interface.CallHook("OnNpcAttack", this, AttackTarget) == null && !((AttackTarget.ServerPosition - ServerPosition).magnitude > AttackRange))
		{
			nextAttackTime = UnityEngine.Time.realtimeSinceStartup + AttackRate;
			BaseCombatEntity combatTarget = CombatTarget;
			if ((bool)combatTarget)
			{
				combatTarget.Hurt(AttackDamage, AttackDamageType, this);
				Stamina.Use(AttackCost);
				BusyTimer.Activate(0.5f);
				SignalBroadcast(Signal.Attack);
				ClientRPC(null, "Attack", AttackTarget.ServerPosition);
			}
		}
	}

```

## OnNetworkGroupEntered(BaseNetworkable,Network.Visibility.Group)

```csharp
```csharp
/// <summary>
/// Called when a network object enters a network group.
/// </summary>
/// <param name="networkObject">The network object that entered the group.</param>
/// <param name="group">The network group that was entered.</param>
/// <returns>No return behavior.</returns>
void OnNetworkGroupEntered(BaseNetworkable networkObject, Network.Visibility.Group group)
{
    Puts($"Network object {networkObject} has entered network group {group}");
}
```
```

### Source Code from the Library

```csharp

	public virtual void OnNetworkGroupEnter(Group group)
	{
		Interface.CallHook("OnNetworkGroupEntered", this, group);
	}

```

## OnSensorDetect(HBHFSensor,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a sensor detects a player.
/// </summary>
/// <param name="sensor">The HBHFSensor that detected the player.</param>
/// <param name="player">The BasePlayer that was detected.</param>
/// <returns>
/// Returns `null` to allow the default behavior, or any non-null value to override it. 
/// If a boolean is returned, it will be used as a flag to determine whether the player should be included in the detection count.
/// </returns>
object OnSensorDetect(HBHFSensor sensor, BasePlayer player)
{
    Puts($"Sensor {sensor.name} detected player {player.UserIDString}");
    if (player.isSuperAdmin)
    {
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void UpdatePassthroughAmount()
	{
		if (base.isClient)
		{
			return;
		}
		int num = detectedPlayers;
		detectedPlayers = 0;
		if (myTrigger.entityContents != null)
		{
			foreach (BaseEntity entityContent in myTrigger.entityContents)
			{
				if (entityContent == null || !entityContent.IsVisible(base.transform.position + base.transform.forward * 0.1f, 10f))
				{
					continue;
				}
				BasePlayer component = entityContent.GetComponent<BasePlayer>();
				if (Interface.CallHook("OnSensorDetect", this, component) == null)
				{
					bool flag = component.CanBuild();
					if ((!flag || ShouldIncludeAuthorized()) && (flag || ShouldIncludeOthers()) && component != null && component.IsAlive() && !component.IsSleeping() && component.isServer)
					{
						detectedPlayers++;
					}
				}
			}
		}
		if (num != detectedPlayers && IsPowered())
		{
			MarkDirty();
			if (detectedPlayers > num)
			{
				Effect.server.Run(detectUp.resourcePath, base.transform.position, Vector3.up);
			}
			else if (detectedPlayers < num)
			{
				Effect.server.Run(detectDown.resourcePath, base.transform.position, Vector3.up);
			}
		}
	}

```

## CanLootEntity(BasePlayer,DroppedItemContainer)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can loot an entity.
/// </summary>
/// <param name="player">The player attempting to loot the entity.</param>
/// <param name="entity">The entity being looted.</param>
/// <returns>
/// Returns `null` to allow the player to loot the entity, or any non-null value to prevent them from looting.
/// </returns>
object CanLootEntity(BasePlayer player, DroppedItemContainer entity)
{
    Puts($"Player {player.UserIDString} is attempting to loot entity {entity.GetDisplayName()}");
    if (player.IsAdmin)
    {
        return null;
    }
    else
    {
        return "Not allowed: Only admins can loot this entity.";
    }
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	private void RPC_OpenLoot(RPCMessage rpc)
	{
		if (inventory != null)
		{
			BasePlayer player = rpc.player;
			if ((bool)player && player.CanInteract() && Interface.CallHook("CanLootEntity", player, this) == null && player.inventory.loot.StartLootingEntity(this))
			{
				SetFlag(Flags.Open, b: true);
				player.inventory.loot.AddContainer(inventory);
				player.inventory.loot.SendImmediate();
				player.ClientRPCPlayer(null, player, "RPC_OpenLootPanel", lootPanelName);
				SendNetworkUpdate();
			}
		}
	}

```

## OnEntityDeath(ResourceEntity,HitInfo)

```csharp
```csharp
/// <summary>
/// Called when an entity dies.
/// </summary>
/// <param name="entity">The entity that died.</param>
/// <param name="hitInfo">Information about the hit that killed the entity.</param>
/// <returns>No return behavior.</returns>
void OnEntityDeath(ResourceEntity entity, HitInfo hitInfo)
{
    Puts($"Entity {entity.name} has died at position {hitInfo.position}");
}
```
```

### Source Code from the Library

```csharp

	public virtual void OnKilled(HitInfo info)
	{
		isKilled = true;
		Interface.CallHook("OnEntityDeath", this, info);
		Kill();
	}

```

## CanCreateWorldProjectile(HitInfo,ItemDefinition)

```csharp
```csharp
/// <summary>
/// Called to determine if a world projectile can be created.
/// </summary>
/// <param name="hitInfo">Information about the hit.</param>
/// <param name="itemDef">The definition of the item being used to create the projectile.</param>
/// <returns>
/// Returns `null` if the projectile can be created as normal. 
/// If a non-null value is returned, it will override the default behavior and prevent the projectile from being created.
/// </returns>
object CanCreateWorldProjectile(HitInfo hitInfo, ItemDefinition itemDef)
{
    Puts($"Checking if world projectile can be created with hit info {hitInfo} and item def {itemDef}.");
    // Add custom logic here to determine if the projectile can be created
    return null;
}
```
```

### Source Code from the Library

```csharp

	protected virtual void CreateWorldProjectile(HitInfo info, ItemDefinition itemDef, ItemModProjectile itemMod, Projectile projectilePrefab, Item recycleItem)
	{
		if (Interface.CallHook("CanCreateWorldProjectile", info, itemDef) != null)
		{
			return;
		}
		UnityEngine.Vector3 projectileVelocity = info.ProjectileVelocity;
		Item item = ((recycleItem != null) ? recycleItem : ItemManager.Create(itemDef, 1, 0uL));
		if (Interface.CallHook("OnCreateWorldProjectile", info, item) != null)
		{
			return;
		}
		BaseEntity baseEntity = null;
		if (!info.DidHit)
		{
			baseEntity = item.CreateWorldObject(info.HitPositionWorld, UnityEngine.Quaternion.LookRotation(projectileVelocity.normalized));
			baseEntity.Kill(DestroyMode.Gib);
			return;
		}
		if (projectilePrefab.breakProbability > 0f && UnityEngine.Random.value <= projectilePrefab.breakProbability)
		{
			baseEntity = item.CreateWorldObject(info.HitPositionWorld, UnityEngine.Quaternion.LookRotation(projectileVelocity.normalized));
			baseEntity.Kill(DestroyMode.Gib);
			return;
		}
		if (projectilePrefab.conditionLoss > 0f)
		{
			item.LoseCondition(projectilePrefab.conditionLoss * 100f);
			if (item.isBroken)
			{
				baseEntity = item.CreateWorldObject(info.HitPositionWorld, UnityEngine.Quaternion.LookRotation(projectileVelocity.normalized));
				baseEntity.Kill(DestroyMode.Gib);
				return;
			}
		}
		if (projectilePrefab.stickProbability > 0f && UnityEngine.Random.value <= projectilePrefab.stickProbability)
		{
			baseEntity = ((info.HitEntity == null) ? item.CreateWorldObject(info.HitPositionWorld, UnityEngine.Quaternion.LookRotation(projectileVelocity.normalized)) : ((info.HitBone != 0) ? item.CreateWorldObject(info.HitPositionLocal, UnityEngine.Quaternion.LookRotation(info.HitNormalLocal * -1f), info.HitEntity, info.HitBone) : item.CreateWorldObject(info.HitPositionLocal, UnityEngine.Quaternion.LookRotation(info.HitEntity.transform.InverseTransformDirection(projectileVelocity.normalized)), info.HitEntity)));
			baseEntity.GetComponent<Rigidbody>().isKinematic = true;
			return;
		}
		baseEntity = item.CreateWorldObject(info.HitPositionWorld, UnityEngine.Quaternion.LookRotation(projectileVelocity.normalized));
		Rigidbody component = baseEntity.GetComponent<Rigidbody>();
		component.AddForce(projectileVelocity.normalized * 200f);
		component.WakeUp();
	}

```

## CanNetworkTo(BaseEntity,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called to determine if a network connection should be established with the specified player.
/// </summary>
/// <param name="entity">The entity attempting to establish a network connection.</param>
/// <param name="player">The player being targeted by the network connection attempt.</param>
/// <returns>
/// Returns `true` to allow the network connection, or `false` to prevent it. If any other non-null value is returned, it will override the default behavior.
/// </returns>
object CanNetworkTo(BaseEntity entity, BasePlayer player)
{
    Puts($"Entity {entity.name} is attempting to establish a network connection with player {player.UserIDString}");
    if (player == null || player.IsDead)
    {
        Puts($"Player {player.UserIDString} is dead or does not exist");
        return false;
    }
    if (entity == player)
    {
        Puts($"Entity {entity.name} is the same as player {player.UserIDString}")
        return true;
    }
    // Additional logic to determine if network connection should be allowed
    return null;
}
```
```

### Source Code from the Library

```csharp

	public override bool ShouldNetworkTo(BasePlayer player)
	{
		if (player == this)
		{
			return true;
		}
		BaseEntity baseEntity = GetParentEntity();
		if (base.limitNetworking)
		{
			if (baseEntity == null)
			{
				return false;
			}
			if (baseEntity != player)
			{
				return false;
			}
		}
		if (baseEntity != null)
		{
			object obj = Interface.CallHook("CanNetworkTo", this, player);
			if (obj is bool)
			{
				return (bool)obj;
			}
			return baseEntity.ShouldNetworkTo(player);
		}
		return base.ShouldNetworkTo(player);
	}

```

## OnEntityTakeDamage(ResourceEntity,HitInfo)

```csharp
```csharp
/// <summary>
/// Called when an entity takes damage.
/// </summary>
/// <param name="entity">The entity that took the damage.</param>
/// <param name="info">Information about the hit, including the damage type and amount.</param>
/// <returns>
/// Returns `null` to allow the entity to take the damage normally. 
/// If a non-null value is returned, it will override the default behavior.
/// </returns>
object OnEntityTakeDamage(ResourceEntity entity, HitInfo info)
{
    Puts($"Entity {entity.Name} took {info.damageTypes.Total()} damage from hit info: {info}");
    if (info.damageTypes.Contains(DamageType.Fire))
    {
        Puts($"Entity {entity.Name} is on fire!");
        return "Fire";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public override void OnAttacked(HitInfo info)
	{
		if (!base.isServer || isKilled || Interface.CallHook("OnEntityTakeDamage", this, info) != null)
		{
			return;
		}
		if (resourceDispenser != null)
		{
			resourceDispenser.OnAttacked(info);
		}
		if (!info.DidGather)
		{
			if ((bool)baseProtection)
			{
				baseProtection.Scale(info.damageTypes);
			}
			float num = info.damageTypes.Total();
			health -= num;
			if (health <= 0f)
			{
				OnKilled(info);
			}
			else
			{
				OnHealthChanged();
			}
		}
	}

```

## CanUseLockedEntity(BasePlayer,CodeLock)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can use a locked entity.
/// </summary>
/// <param name="player">The player attempting to use the locked entity.</param>
/// <param name="lockedEntity">The locked entity being accessed.</param>
/// <returns>
/// Returns `true` if the player is allowed to use the locked entity, or `false` otherwise.
/// If a non-bool value is returned, it will be treated as `false`.
/// </returns>
object CanUseLockedEntity(BasePlayer player, CodeLock lockedEntity)
{
    Puts($"Player {player.UserIDString} attempted to access locked entity {lockedEntity.EntityID}");
    if (player.IsAdmin())
    {
        Puts($"Player {player.UserIDString} has admin privileges and is allowed to use the locked entity.");
        return true;
    }
    else if (player.HasAccessToEntity(lockedEntity))
    {
        Puts($"Player {player.UserIDString} has access to the locked entity and is allowed to use it.");
        return true;
    }
    else
    {
        Puts($"Player {player.UserIDString} does not have access to the locked entity and is denied access.");
        return false;
    }
}
```
```

### Source Code from the Library

```csharp

	public override bool OnTryToOpen(BasePlayer player)
	{
		object obj = Interface.CallHook("CanUseLockedEntity", player, this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (!IsLocked())
		{
			return true;
		}
		if (whitelistPlayers.Contains(player.userID) || guestPlayers.Contains(player.userID))
		{
			DoEffect(effectUnlocked.resourcePath);
			return true;
		}
		DoEffect(effectDenied.resourcePath);
		return false;
	}

```

## OnItemRemove(Item)

```csharp
```csharp
/// <summary>
/// Called when an item is removed from the game.
/// </summary>
/// <param name="item">The item being removed.</param>
/// <returns>No return behavior.</returns>
void OnItemRemove(Item item)
{
    Puts($"Item {item.info.name} has been removed.");
    if (item.info.category == "Forbidden")
    {
        Puts($"Item {item.info.name} is a forbidden item and cannot be removed.");
        // Add any additional logic to handle the removal of forbidden items
    }
}
```
```

### Source Code from the Library

```csharp

	public void Remove(float fTime = 0f)
	{
		if (removeTime > 0f || Interface.CallHook("OnItemRemove", this) != null)
		{
			return;
		}
		if (isServer)
		{
			ItemMod[] itemMods = info.itemMods;
			for (int i = 0; i < itemMods.Length; i++)
			{
				itemMods[i].OnRemove(this);
			}
		}
		this.onCycle = null;
		removeTime = UnityEngine.Time.time + fTime;
		this.OnDirty = null;
		position = -1;
		if (isServer)
		{
			ItemManager.RemoveItem(this, fTime);
		}
	}

```

## OnHorseUnhitch(RidableHorse,HitchTrough.HitchSpot)

```csharp
```csharp
/// <summary>
/// Called when a horse is unhitched from its hitch spot.
/// </summary>
/// <param name="horse">The horse being unhitched.</param>
/// <param name="hitchSpot">The hitch spot where the horse was previously hitched.</param>
/// <returns>
/// Returns `null` to allow the horse to be unhitched, or any non-null value to prevent the horse from being unhitched.
/// </returns>
object OnHorseUnhitch(RidableHorse horse, HitchSpot hitchSpot)
{
    Puts($"Horse {horse.GetDisplayName()} has been unhitched from hitch spot {hitchSpot.GetDisplayName()}");
    if (hitchSpot == HitchSpot.TownSquare)
    {
        Puts($"Horse {horse.GetDisplayName()} cannot be unhitched from town square.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void Unhitch(RidableHorse horse)
	{
		HitchSpot[] array = hitchSpots;
		foreach (HitchSpot hitchSpot in array)
		{
			if (hitchSpot.GetHorse(base.isServer) == horse)
			{
				if (Interface.CallHook("OnHorseUnhitch", horse, hitchSpot) != null)
				{
					break;
				}
				hitchSpot.SetOccupiedBy(null);
				horse.SetHitch(null);
			}
		}
	}

```

## CanLootEntity(BasePlayer,LootableCorpse)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can loot an entity.
/// </summary>
/// <param name="player">The player attempting to loot the entity.</param>
/// <param name="entity">The entity being looted, which could be a corpse or other lootable object.</param>
/// <returns>
/// Returns `null` to allow the player to loot the entity, or any non-null value to prevent them from looting.
/// </returns>
object CanLootEntity(BasePlayer player, LootableCorpse entity)
{
    Puts($"Player {player.UserIDString} is attempting to loot entity {entity.EntityID}");
    if (entity.IsLocked)
    {
        Puts($"Entity {entity.EntityID} is locked and cannot be looted.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	private void RPC_LootCorpse(RPCMessage rpc)
	{
		BasePlayer player = rpc.player;
		if ((bool)player && player.CanInteract() && CanLoot() && containers != null && Interface.CallHook("CanLootEntity", player, this) == null && player.inventory.loot.StartLootingEntity(this))
		{
			SetFlag(Flags.Open, b: true);
			ItemContainer[] array = containers;
			foreach (ItemContainer container in array)
			{
				player.inventory.loot.AddContainer(container);
			}
			player.inventory.loot.SendImmediate();
			ClientRPCPlayer(null, player, "RPC_ClientLootCorpse");
			SendNetworkUpdate();
		}
	}

```

## OnDeleteVendingOffer(VendingMachine,int)

```csharp
```csharp
/// <summary>
/// Called when a vending offer is deleted.
/// </summary>
/// <param name="vendingMachine">The vending machine that the offer was on.</param>
/// <param name="offerIndex">The index of the offer being deleted.</param>
/// <returns>No return behavior.</returns>
void OnDeleteVendingOffer(VendingMachine vendingMachine, int offerIndex)
{
    Puts($"Deleted vending offer {offerIndex} from vending machine {vendingMachine.name}");
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void RPC_DeleteSellOrder(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (CanPlayerAdmin(player))
		{
			int num = msg.read.Int32();
			Interface.CallHook("OnDeleteVendingOffer", this, num);
			if (num >= 0 && num < sellOrders.sellOrders.Count)
			{
				sellOrders.sellOrders.RemoveAt(num);
			}
			RefreshSellOrderStockLevel();
			UpdateMapMarker();
			SendSellOrders(player);
		}
	}

```

## OnSwitchAmmo(BasePlayer,BaseProjectile)

```csharp
```csharp
/// <summary>
/// Called when a player switches ammo.
/// </summary>
/// <param name="player">The player switching ammo.</param>
/// <param name="projectile">The projectile being switched to.</param>
/// <returns>
/// Returns a non-null value to override the default ammo switch behavior. 
/// If `null` is returned, the ammo switch will proceed as normal.
/// </returns>
object OnSwitchAmmo(BasePlayer player, BaseProjectile projectile)
{
    Puts($"Player {player.UserIDString} switched ammo to {projectile.definition.ammoTypes[0].name}");
    if (projectile.definition.ammoTypes[0].itemid == 123)
    {
        Puts($"Player {player.UserIDString} cannot switch to this ammo.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsActiveItem]
	private void SwitchAmmoTo(RPCMessage msg)
	{
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if (!ownerPlayer)
		{
			return;
		}
		int num = msg.read.Int32();
		if (num == primaryMagazine.ammoType.itemid)
		{
			return;
		}
		ItemDefinition itemDefinition = ItemManager.FindItemDefinition(num);
		if (itemDefinition == null)
		{
			return;
		}
		ItemModProjectile component = itemDefinition.GetComponent<ItemModProjectile>();
		if ((bool)component && component.IsAmmo(primaryMagazine.definition.ammoTypes) && Interface.CallHook("OnSwitchAmmo", ownerPlayer, this) == null)
		{
			if (primaryMagazine.contents > 0)
			{
				ownerPlayer.GiveItem(ItemManager.CreateByItemID(primaryMagazine.ammoType.itemid, primaryMagazine.contents, 0uL));
				primaryMagazine.contents = 0;
			}
			primaryMagazine.ammoType = itemDefinition;
			SendNetworkUpdateImmediate();
			ItemManager.DoRemoves();
			ownerPlayer.inventory.ServerUpdate(0f);
		}
	}

```

## OnPlayerWantsDismount(BasePlayer,BaseMountable)

```csharp
```csharp
/// <summary>
/// Called when a player wants to dismount from a mountable object.
/// </summary>
/// <param name="player">The player attempting to dismount.</param>
/// <param name="mountable">The mountable object the player is currently on.</param>
/// <returns>
/// Returns `null` to allow the player to dismount, or any non-null value to prevent them from dismounting.
/// </returns>
object OnPlayerWantsDismount(BasePlayer player, BaseMountable mountable)
{
    Puts($"Player {player.UserIDString} wants to dismount from {mountable.ShortPrefabName}");
    if (player.IsAdmin)
    {
        Puts($"Player {player.displayName} is an admin and cannot be prevented from dismounting");
        return null;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	public void RPC_WantsDismount(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (HasValidDismountPosition(player) && Interface.CallHook("OnPlayerWantsDismount", player, this) == null)
		{
			AttemptDismount(player);
		}
	}

```

## CanBeTargeted(BaseCombatEntity,HelicopterTurret)

```csharp
```csharp
/// <summary>
/// Called to determine if a target can be targeted by the helicopter turret.
/// </summary>
/// <param name="potentialTarget">The potential target entity.</param>
/// <param name="turret">The helicopter turret instance.</param>
/// <returns>
/// Returns `true` if the target can be targeted, and `false` otherwise.
/// If a non-bool value is returned, it will be treated as `true`.
/// </returns>
object CanBeTargeted(BaseCombatEntity potentialTarget, HelicopterTurret turret)
{
    Puts($"Checking if {potentialTarget.displayName} can be targeted by the helicopter turret.");
    // Minimal code to demonstrate functionality
    return true;
}
```
```

### Source Code from the Library

```csharp

	public bool InFiringArc(BaseCombatEntity potentialtarget)
	{
		object obj = Interface.CallHook("CanBeTargeted", potentialtarget, this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return AngleToTarget(potentialtarget) < 80f;
	}

```

## OnSleepingBagDestroy(SleepingBag,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a sleeping bag is destroyed.
/// </summary>
/// <param name="sleepingBag">The destroyed sleeping bag.</param>
/// <param name="player">The player who destroyed the sleeping bag.</param>
/// <returns>
/// Returns `null` to allow the sleeping bag to be destroyed, or any non-null value to prevent it from being destroyed.
/// </returns>
object OnSleepingBagDestroy(SleepingBag sleepingBag, BasePlayer player)
{
    Puts($"Player {player.UserIDString} destroyed a sleeping bag.");
    if (sleepingBag.ownerID == 123456)
    {
        Puts($"Player {player.displayName} is not allowed to destroy the sleeping bag of owner ID {sleepingBag.ownerID}.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public static bool DestroyBag(BasePlayer player, uint sleepingBag)
	{
		SleepingBag sleepingBag2 = FindForPlayer(player.userID, sleepingBag, ignoreTimers: false);
		if (sleepingBag2 == null)
		{
			return false;
		}
		if (Interface.CallHook("OnSleepingBagDestroy", sleepingBag2, player) != null)
		{
			return false;
		}
		if (sleepingBag2.canBePublic)
		{
			sleepingBag2.SetPublic(isPublic: true);
			sleepingBag2.deployerUserID = 0uL;
		}
		else
		{
			sleepingBag2.Kill();
		}
		player.SendRespawnOptions();
		Interface.CallHook("OnSleepingBagDestroyed", sleepingBag2, player);
		return true;
	}

```

## CanEntityBeHostile(BaseCombatEntity)

```csharp
```csharp
/// <summary>
/// Determines whether an entity can be hostile.
/// </summary>
/// <param name="entity">The entity to check.</param>
/// <returns>
/// Returns `true` if the entity can be hostile, and `false` otherwise.
/// If a non-bool value is returned by the hook, it will be treated as `true`.
/// </returns>
bool CanEntityBeHostile(BaseCombatEntity entity)
{
    object obj = Interface.CallHook("CanEntityBeHostile", entity);
    if (obj is bool)
    {
        return (bool)obj;
    }
    Puts($"Entity {entity.UserIDString} can be hostile because {obj}");
    return true;
}
```
```

### Source Code from the Library

```csharp

	public bool IsHostile()
	{
		object obj = Interface.CallHook("CanEntityBeHostile", this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return unHostileTime > UnityEngine.Time.realtimeSinceStartup;
	}

```

## OnCargoShipSpawnCrate(CargoShip)

```csharp
```csharp
/// <summary>
/// Called when a cargo ship spawns a crate.
/// </summary>
/// <param name="cargoShip">The cargo ship that spawned the crate.</param>
/// <returns>
/// Returns `null` to allow the cargo ship to spawn crates as normal, or any non-null value to override this behavior.
/// If a string is returned, it will be used as a message to display in the console when the cargo ship spawns a crate.
/// </returns>
string OnCargoShipSpawnCrate(CargoShip cargoShip)
{
    Puts($"Cargo ship {cargoShip.name} spawned a crate.");
    if (cargoShip.isElite)
    {
        Puts($"Cargo ship {cargoShip.name} is an elite cargo ship and will spawn only elite crates.");
        return "Only elite crates are being spawned.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void RespawnLoot()
	{
		if (Interface.CallHook("OnCargoShipSpawnCrate", this) == null)
		{
			InvokeRepeating(PlayHorn, 0f, 8f);
			SpawnCrate(lockedCratePrefab.resourcePath);
			SpawnCrate(eliteCratePrefab.resourcePath);
			for (int i = 0; i < 4; i++)
			{
				SpawnCrate(militaryCratePrefab.resourcePath);
			}
			for (int j = 0; j < 4; j++)
			{
				SpawnCrate(junkCratePrefab.resourcePath);
			}
			lootRoundsPassed++;
			if (lootRoundsPassed >= loot_rounds)
			{
				CancelInvoke(RespawnLoot);
			}
		}
	}

```

## OnNpcEquipWeapon(NPCPlayer,Item)

```csharp
```csharp
/// <summary>
/// Called when an NPC equips a weapon.
/// </summary>
/// <param name="npc">The NPC equipping the weapon.</param>
/// <param name="item">The item being equipped as a weapon.</param>
/// <returns>
/// Returns `null` to allow the NPC to equip the weapon, or any non-null value to prevent them from equipping it.
/// </returns>
object OnNpcEquipWeapon(NPCPlayer npc, Item item)
{
    Puts($"NPC {npc.name} is equipping {item.displayName} as a weapon.");
    if (item.isMelee)
    {
        Puts($"NPC {npc.name} is equipping {item.displayName}, which is a melee weapon.");
        return null;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual void EquipWeapon()
	{
		Item slot = inventory.containerBelt.GetSlot(0);
		if (slot == null || Interface.CallHook("OnNpcEquipWeapon", this, slot) != null)
		{
			return;
		}
		UpdateActiveItem(inventory.containerBelt.GetSlot(0).uid);
		BaseEntity heldEntity = slot.GetHeldEntity();
		if (heldEntity != null)
		{
			AttackEntity component = heldEntity.GetComponent<AttackEntity>();
			if (component != null)
			{
				component.TopUpAmmo();
			}
		}
	}

```

## OnTerrainInitialized()

```csharp
```csharp
/// <summary>
/// Called after the terrain has been initialized.
/// </summary>
void OnTerrainInitialized()
{
    Puts("Terrain initialization complete.");
    
    // Minimal code to demonstrate functionality
    // You can add any necessary setup or initialization here
}
```
```

### Source Code from the Library

```csharp

	public void PostSetupComponents()
	{
		TerrainExtension[] components = GetComponents<TerrainExtension>();
		for (int i = 0; i < components.Length; i++)
		{
			components[i].PostSetup();
		}
		Interface.CallHook("OnTerrainInitialized");
	}

```

## OnSupplyDropDropped(BaseEntity,CargoPlane)

```csharp
```csharp
/// <summary>
/// Called when a supply drop is dropped.
/// </summary>
/// <param name="drop">The BaseEntity representing the dropped supply.</param>
/// <param name="plane">The CargoPlane that dropped the supply.</param>
/// <returns>No return behavior.</returns>
void OnSupplyDropDropped(BaseEntity drop, CargoPlane plane)
{
    Puts($"Supply drop {drop.UserIDString} has been dropped by cargo plane {plane.UserIDString}");
}
```
```

### Source Code from the Library

```csharp

	private void Update()
	{
		if (!base.isServer)
		{
			return;
		}
		secondsTaken += Time.deltaTime;
		float num = Mathf.InverseLerp(0f, secondsToTake, secondsTaken);
		if (!dropped && num >= 0.5f)
		{
			dropped = true;
			BaseEntity baseEntity = GameManager.server.CreateEntity(prefabDrop.resourcePath, base.transform.position);
			if ((bool)baseEntity)
			{
				baseEntity.globalBroadcast = true;
				baseEntity.Spawn();
				Interface.CallHook("OnSupplyDropDropped", baseEntity, this);
			}
		}
		base.transform.position = Vector3.Lerp(startPos, endPos, num);
		base.transform.hasChanged = true;
		if (num >= 1f)
		{
			Kill();
		}
	}

```

## CanBypassQueue(Network.Connection)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can bypass the queue.
/// </summary>
/// <param name="connection">The player's connection.</param>
/// <returns>
/// Returns `true` if the player can bypass the queue, or `false` otherwise.
/// If this method returns `null`, it will be treated as returning `false`.
/// </returns>
bool CanBypassQueue(Network.Connection connection)
{
    Puts($"Checking if {connection.UserIDString} can bypass queue...");
    bool result = (bool)Interface.CallHook("CanBypassQueue", connection);
    if (result)
    {
        return true;
    }
    if (DeveloperList.Contains(connection.userid))
    {
        return true;
    }
    ServerUsers.User user = ServerUsers.Get(connection.userid);
    if (user != null && user.group == ServerUsers.UserGroup.Moderator)
    {
        return true;
    }
    if (user != null && user.group == ServerUsers.UserGroup.Owner)
    {
        return true;
    }
    return false;
}
```
```

### Source Code from the Library

```csharp

	private bool CanJumpQueue(Connection connection)
	{
		object obj = Interface.CallHook("CanBypassQueue", connection);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (DeveloperList.Contains(connection.userid))
		{
			return true;
		}
		ServerUsers.User user = ServerUsers.Get(connection.userid);
		if (user != null && user.group == ServerUsers.UserGroup.Moderator)
		{
			return true;
		}
		if (user != null && user.group == ServerUsers.UserGroup.Owner)
		{
			return true;
		}
		return false;
	}

```

## OnCargoPlaneSignaled(BaseEntity,SupplySignal)

```csharp
```csharp
/// <summary>
/// Called when a cargo plane signals.
/// </summary>
/// <param name="plane">The cargo plane that signaled.</param>
/// <param name="signal">The signal type (e.g. SupplySignal).</param>
/// <returns>No return behavior.</returns>
void OnCargoPlaneSignaled(BaseEntity plane, SupplySignal signal)
{
    Puts($"Cargo plane {plane.UserIDString} has signaled with supply signal {signal}.");
    if (signal == SupplySignal.Ammo)
    {
        Puts($"Ammo supply signal detected. Sending ammo to nearby players.");
        // Send ammo to nearby players
    }
}
```
```

### Source Code from the Library

```csharp

	public override void Explode()
	{
		BaseEntity baseEntity = GameManager.server.CreateEntity(EntityToCreate.resourcePath);
		if ((bool)baseEntity)
		{
			Vector3 vector = new Vector3(UnityEngine.Random.Range(-20f, 20f), 0f, UnityEngine.Random.Range(-20f, 20f));
			baseEntity.SendMessage("InitDropPosition", base.transform.position + vector, SendMessageOptions.DontRequireReceiver);
			baseEntity.Spawn();
			Interface.CallHook("OnCargoPlaneSignaled", baseEntity, this);
		}
		Invoke(FinishUp, 210f);
		SetFlag(Flags.On, b: true);
		SendNetworkUpdateImmediate();
	}

```

## OnBradleyApcInitialize(BradleyAPC)

```csharp
```csharp
/// <summary>
/// Called when the Bradley APC is initialized.
/// </summary>
/// <param name="apc">The Bradley APC instance.</param>
/// <returns>
/// Returns `null` to allow the APC to initialize normally, or any non-null value to override the default initialization behavior.
/// </returns>
object OnBradleyApcInitialize(BradleyAPC apc)
{
    Puts($"Bradley APC initialized at position: {apc.transform.position}");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void Initialize()
	{
		if (Interface.CallHook("OnBradleyApcInitialize", this) == null)
		{
			myRigidBody.centerOfMass = centerOfMass.localPosition;
			destination = base.transform.position;
			finalDestination = base.transform.position;
		}
	}

```

## OnNpcTarget(HumanNPC,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when an NPC targets a player.
/// </summary>
/// <param name="npc">The NPC that is targeting the player.</param>
/// <param name="player">The player being targeted by the NPC.</param>
/// <returns>
/// Returns `null` to allow the default behavior of setting the current target and LOS. 
/// If a non-null value is returned, it will override the default behavior.
/// </returns>
object OnNpcTarget(HumanNPC npc, BasePlayer player)
{
    Puts($"NPC {npc.name} has targeted player {player.UserIDString}.");
    // You can add custom logic here to handle the NPC targeting the player
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void UpdateTargets(float delta)
	{
		UpdateMemory();
		int num = -1;
		float num2 = -1f;
		Vector3 position = base.transform.position;
		for (int i = 0; i < myMemory.All.Count; i++)
		{
			SimpleAIMemory.SeenInfo seenInfo = myMemory.All[i];
			if (seenInfo.Entity == null)
			{
				continue;
			}
			float num3 = 0f;
			float value = Vector3.Distance(seenInfo.Entity.transform.position, position);
			if (!seenInfo.Entity.IsNpc && !(seenInfo.Entity.Health() <= 0f))
			{
				num3 += 1f - Mathf.InverseLerp(10f, sightRange, value);
				float value2 = Vector3.Dot((seenInfo.Entity.transform.position - eyes.position).normalized, eyes.BodyForward());
				num3 += Mathf.InverseLerp(visionCone, 1f, value2);
				float value3 = seenInfo.Timestamp - UnityEngine.Time.realtimeSinceStartup;
				num3 += 1f - Mathf.InverseLerp(0f, 3f, value3);
				if (num3 > num2)
				{
					num = i;
					num2 = num3;
				}
			}
		}
		if (num != -1)
		{
			SimpleAIMemory.SeenInfo seenInfo2 = myMemory.All[num];
			if (seenInfo2.Entity != null && seenInfo2.Entity is BasePlayer)
			{
				BasePlayer component = seenInfo2.Entity.GetComponent<BasePlayer>();
				if (Interface.CallHook("OnNpcTarget", this, component) == null)
				{
					currentTarget = component;
					currentTargetLOS = IsVisibleToUs(component);
				}
			}
		}
		else
		{
			currentTarget = null;
			currentTargetLOS = false;
		}
	}

```

## OnTurretModeToggle(AutoTurret)

```csharp
```csharp
/// <summary>
/// Called when the turret mode is toggled.
/// </summary>
/// <param name="turret">The AutoTurret instance whose mode was toggled.</param>
/// <returns>No return behavior.</returns>
void OnTurretModeToggle(AutoTurret turret)
{
    Puts($"Turret {turret.entityID} mode toggled to {(turret.GetFlag(Flags.Reserved1) ? "Peacekeeper" : "Default")}.");
}
```
```

### Source Code from the Library

```csharp

	public void SetPeacekeepermode(bool isOn)
	{
		if (PeacekeeperMode() != isOn)
		{
			SetFlag(Flags.Reserved1, isOn);
			Effect.server.Run(peacekeeperToggleSound.resourcePath, this, 0u, Vector3.zero, Vector3.zero);
			Interface.CallHook("OnTurretModeToggle", this);
		}
	}

```

## IOnNpcTarget(Rust.Ai.HTN.IHTNAgent,BasePlayer,int)

```csharp
```csharp
/// <summary>
/// Called when an NPC targets a player.
/// </summary>
/// <param name="npc">The NPC performing the targeting.</param>
/// <param name="player">The targeted player.</param>
/// <param name="index">The index of the player in the list of players within range.</param>
/// <returns>
/// Returns `null` to allow the NPC to target the player, or any non-null value to override the default targeting behavior.
/// </returns>
object IOnNpcTarget(IHTNAgent npc, BasePlayer player, int index)
{
    Puts($"NPC {npc} has targeted player {player} at index {index}.");
    if (player == null || player.IsDead() || player.IsWounded())
    {
        return "Cannot target dead or wounded player.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void Tick(IHTNAgent npc, float deltaTime, float time)
	{
		if (ConVar.AI.ignoreplayers || npc == null || npc.transform == null || npc.IsDestroyed || npc.AiDefinition == null)
		{
			return;
		}
		PlayerQueryResultCount = BaseEntity.Query.Server.GetPlayersInSphere(npc.transform.position, npc.AiDefinition.Sensory.VisionRange, PlayerQueryResults, delegate(BasePlayer player)
		{
			if (player == null || !player.isServer || player.IsDestroyed || player.transform == null || player.IsDead() || player.IsWounded())
			{
				return false;
			}
			return (!player.IsSleeping() || !(player.secondsSleeping < NPCAutoTurret.sleeperhostiledelay)) ? true : false;
		});
		List<NpcPlayerInfo> playersInRange = npc.AiDomain.NpcContext.PlayersInRange;
		if (PlayerQueryResultCount > 0)
		{
			for (int i = 0; i < PlayerQueryResultCount; i++)
			{
				BasePlayer basePlayer = PlayerQueryResults[i];
				HTNPlayer hTNPlayer = npc as HTNPlayer;
				if ((hTNPlayer != null && basePlayer == hTNPlayer) || (basePlayer.transform.position - npc.transform.position).sqrMagnitude > npc.AiDefinition.Sensory.SqrVisionRange)
				{
					continue;
				}
				bool flag = false;
				for (int j = 0; j < playersInRange.Count; j++)
				{
					NpcPlayerInfo value = playersInRange[j];
					if (value.Player == basePlayer)
					{
						value.Time = time;
						playersInRange[j] = value;
						flag = true;
						break;
					}
				}
				if (!flag)
				{
					playersInRange.Add(new NpcPlayerInfo
					{
						Player = basePlayer,
						Time = time
					});
				}
			}
		}
		for (int k = 0; k < playersInRange.Count; k++)
		{
			NpcPlayerInfo player2 = playersInRange[k];
			if (Interface.CallHook("IOnNpcTarget", npc, player2.Player, k) != null)
			{
				break;
			}
			if (time - player2.Time > npc.AiDefinition.Memory.ForgetInRangeTime && npc.AiDomain.NpcContext.BaseMemory.ShouldRemoveOnPlayerForgetTimeout(time, player2))
			{
				playersInRange.RemoveAt(k);
				k--;
			}
		}
	}

```

## CanAssignBed(BasePlayer,SleepingBag,ulong)

```csharp
```csharp
/// <summary>
/// Called to check if a bed can be assigned to a player.
/// </summary>
/// <param name="player">The player attempting to assign the bed.</param>
/// <param name="sleepingBag">The sleeping bag being assigned.</param>
/// <param name="bedId">The ID of the bed being assigned.</param>
/// <returns>
/// Returns `null` if the bed can be assigned, or any non-null value to prevent assignment.
/// </returns>
object CanAssignBed(BasePlayer player, SleepingBag sleepingBag, ulong bedId)
{
    Puts($"Player {player.UserIDString} is trying to assign bed {bedId} with sleeping bag {sleepingBag.name}");
    if (bedId == 1234567890L)
    {
        Puts($"Bed {bedId} is reserved for VIP players only.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	public void AssignToFriend(RPCMessage msg)
	{
		if (msg.player.CanInteract() && deployerUserID == msg.player.userID)
		{
			ulong num = msg.read.UInt64();
			if (num != 0L && Interface.CallHook("CanAssignBed", msg.player, this, num) == null)
			{
				deployerUserID = num;
				SendNetworkUpdate();
			}
		}
	}

```

## OnPlayerSpectate(BasePlayer,string)

```csharp
```csharp
/// <summary>
/// Called when a player starts spectating.
/// </summary>
/// <param name="player">The player starting to spectate.</param>
/// <param name="filter">The filter used for spectating, which could be a player name or other identifier.</param>
/// <returns>
/// Returns `null` to allow the player to start spectating, or any non-null value to prevent them from spectating.
/// </returns>
object OnPlayerSpectate(BasePlayer player, string filter)
{
    Puts($"Player {player.UserIDString} started spectating with filter: {filter}");
    if (filter == "restricted")
    {
        Puts($"Player {player.displayName} is not allowed to spectate with filter: {filter}");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void StartSpectating()
	{
		if (!IsSpectating() && Interface.CallHook("OnPlayerSpectate", this, spectateFilter) == null)
		{
			SetPlayerFlag(PlayerFlags.Spectating, b: true);
			UnityEngine.TransformEx.SetLayerRecursive(base.gameObject, 10);
			CancelInvoke(InventoryUpdate);
			ChatMessage("Becoming Spectator");
			UpdateSpectateTarget(spectateFilter);
		}
	}

```

## OnResourceDepositCreated(ResourceDepositManager.ResourceDeposit)

```csharp
```csharp
/// <summary>
/// Called when a new resource deposit is created.
/// </summary>
/// <param name="resourceDeposit">The newly created resource deposit.</param>
void OnResourceDepositCreated(ResourceDeposit resourceDeposit)
{
    Puts($"New resource deposit created at position {resourceDeposit.origin}.");
    if (resourceDeposit.Contains(ItemManager.FindItemDefinition("hq.metal.ore")))
    {
        Puts($"This resource deposit contains HQ metal ore, which is a rare and valuable resource.");
    }
    else
    {
        Puts($"This resource deposit does not contain any HQ metal ore.");
    }
    Interface.CallHook("OnResourceDepositCreated", resourceDeposit);
}
```
```

### Source Code from the Library

```csharp

	public ResourceDeposit CreateFromPosition(Vector3 pos)
	{
		Vector2i indexFrom = GetIndexFrom(pos);
		UnityEngine.Random.State state = UnityEngine.Random.state;
		UnityEngine.Random.InitState((int)new Vector2(indexFrom.x, indexFrom.y).Seed(World.Seed + World.Salt));
		ResourceDeposit resourceDeposit = new ResourceDeposit
		{
			origin = new Vector3(indexFrom.x * 20, 0f, indexFrom.y * 20)
		};
		if (UnityEngine.Random.Range(0f, 1f) < 0.5f)
		{
			resourceDeposit.Add(ItemManager.FindItemDefinition("stones"), 1f, 100, 1f, ResourceDeposit.surveySpawnType.ITEM);
		}
		else if (0 == 0)
		{
			resourceDeposit.Add(ItemManager.FindItemDefinition("stones"), 1f, UnityEngine.Random.Range(30000, 100000), UnityEngine.Random.Range(0.3f, 0.5f), ResourceDeposit.surveySpawnType.ITEM);
			float num = 0f;
			num = ((!World.Procedural) ? 0.1f : (((TerrainMeta.BiomeMap.GetBiome(pos, 2) > 0.5f) ? 1f : 0f) * 0.25f));
			if (UnityEngine.Random.Range(0f, 1f) >= 1f - num)
			{
				resourceDeposit.Add(ItemManager.FindItemDefinition("metal.ore"), 1f, UnityEngine.Random.Range(10000, 100000), UnityEngine.Random.Range(2f, 4f), ResourceDeposit.surveySpawnType.ITEM);
			}
			float num2 = 0f;
			num2 = ((!World.Procedural) ? 0.1f : (((TerrainMeta.BiomeMap.GetBiome(pos, 1) > 0.5f) ? 1f : 0f) * (0.25f + 0.25f * (TerrainMeta.TopologyMap.GetTopology(pos, 8) ? 1f : 0f) + 0.25f * (TerrainMeta.TopologyMap.GetTopology(pos, 1) ? 1f : 0f))));
			if (UnityEngine.Random.Range(0f, 1f) >= 1f - num2)
			{
				resourceDeposit.Add(ItemManager.FindItemDefinition("sulfur.ore"), 1f, UnityEngine.Random.Range(10000, 100000), UnityEngine.Random.Range(4f, 4f), ResourceDeposit.surveySpawnType.ITEM);
			}
			float num3 = 0f;
			if (World.Procedural)
			{
				if (TerrainMeta.BiomeMap.GetBiome(pos, 8) > 0.5f || TerrainMeta.BiomeMap.GetBiome(pos, 4) > 0.5f)
				{
					num3 += 0.25f;
				}
			}
			else
			{
				num3 += 0.15f;
			}
			if (UnityEngine.Random.Range(0f, 1f) >= 1f - num3)
			{
				resourceDeposit.Add(ItemManager.FindItemDefinition("hq.metal.ore"), 1f, UnityEngine.Random.Range(5000, 10000), UnityEngine.Random.Range(30f, 50f), ResourceDeposit.surveySpawnType.ITEM);
			}
		}
		_deposits.Add(indexFrom, resourceDeposit);
		Interface.CallHook("OnResourceDepositCreated", resourceDeposit);
		UnityEngine.Random.state = state;
		return resourceDeposit;
	}

```

## OnTeamRejectInvite(BasePlayer,RelationshipManager.PlayerTeam)

```csharp
```csharp
/// <summary>
/// Called when a team rejects an invite from another player.
/// </summary>
/// <param name="inviter">The player who sent the invitation.</param>
/// <param name="team">The team that rejected the invitation.</param>
/// <returns>
/// Returns `null` to allow the team to reject the invitation, or any non-null value to prevent them from rejecting it.
/// </returns>
object OnTeamRejectInvite(BasePlayer inviter, PlayerTeam team)
{
    Puts($"Team {team.Name} has rejected an invite from player {inviter.displayName}");
    if (inviter == null || team == null)
    {
        Puts("Error: Inviter or Team is null");
        return true;
    }
    // Additional logic can be added here to handle the rejection
    return null;
}
```
```

### Source Code from the Library

```csharp

	[ServerUserVar]
	public static void rejectinvite(ConsoleSystem.Arg arg)
	{
		BasePlayer basePlayer = ArgEx.Player(arg);
		if (!(basePlayer == null) && basePlayer.currentTeam == 0L)
		{
			ulong uLong = arg.GetULong(0, 0uL);
			PlayerTeam playerTeam = Instance.FindTeam(uLong);
			if (playerTeam == null)
			{
				basePlayer.ClearPendingInvite();
			}
			else if (Interface.CallHook("OnTeamRejectInvite", basePlayer, playerTeam) == null)
			{
				playerTeam.RejectInvite(basePlayer);
			}
		}
	}

```

## OnEntityEnter(TriggerComfort,BaseEntity)

```csharp
```csharp
/// <summary>
/// Called when an entity enters the trigger comfort zone.
/// </summary>
/// <param name="trigger">The trigger that was entered.</param>
/// <param name="entity">The entity that entered the trigger.</param>
/// <returns>
/// Returns `null` to allow the entity to enter the trigger, or any non-null value to prevent them from entering.
/// </returns>
object OnEntityEnter(TriggerComfort trigger, BaseEntity entity)
{
    Puts($"Entity {entity.UserIDString} has entered the comfort zone of trigger {trigger.name}");
    if (entity is BasePlayer player && player.IsAdmin)
    {
        Puts($"Admin {player.displayName} has entered the comfort zone");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public override void OnEntityEnter(BaseEntity ent)
	{
		BasePlayer basePlayer = ent as BasePlayer;
		if ((bool)basePlayer && Interface.CallHook("OnEntityEnter", this, ent) == null)
		{
			_players.Add(basePlayer);
		}
	}

```

## OnEntityKill(BaseNetworkable)

```csharp
```csharp
/// <summary>
/// Called when an entity is killed.
/// </summary>
/// <param name="entity">The entity being killed.</param>
/// <returns>
/// Returns `null` to allow the entity to be destroyed, or any non-null value to prevent it from being destroyed.
/// </returns>
object OnEntityKill(BaseNetworkable entity)
{
    Puts($"Entity {entity.ShortName} has been killed.");
    if (entity is Player && ((Player)entity).IsAdmin)
    {
        Puts($"Entity {entity.ShortName} was an admin player and cannot be killed.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void Kill(DestroyMode mode = DestroyMode.None)
	{
		if (IsDestroyed)
		{
			Debug.LogWarning("Calling kill - but already IsDestroyed!? " + this);
		}
		else if (Interface.CallHook("OnEntityKill", this) == null)
		{
			OnParentDestroyingEx.BroadcastOnParentDestroying(base.gameObject);
			DoEntityDestroy();
			TerminateOnClient(mode);
			TerminateOnServer();
			EntityDestroy();
		}
	}

```

## OnBradleyApcPatrol(BradleyAPC)

```csharp
```csharp
/// <summary>
/// Called when the Bradley APC is patrolling.
/// </summary>
/// <param name="apc">The Bradley APC performing the patrol.</param>
/// <returns>
/// Returns `null` to allow the APC to continue patrolling, or any non-null value to override the default patrol behavior.
/// If a string is returned, it will be used as a message to display in the console.
/// </returns>
object OnBradleyApcPatrol(BradleyAPC apc)
{
    Puts($"Bradley APC {apc.GetId()} is patrolling.");
    if (apc.GetPosition() == Vector3.zero)
    {
        Puts("Bradley APC has reached its final destination.");
        return "Bradley APC has reached its final destination.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void UpdateMovement_Patrol()
	{
		if (patrolPath == null || UnityEngine.Time.time < nextPatrolTime)
		{
			return;
		}
		nextPatrolTime = UnityEngine.Time.time + 20f;
		if ((HasPath() && !IsAtFinalDestination()) || Interface.CallHook("OnBradleyApcPatrol", this) != null)
		{
			return;
		}
		PathInterestNode randomInterestNodeAwayFrom = patrolPath.GetRandomInterestNodeAwayFrom(base.transform.position);
		BasePathNode closestToPoint = patrolPath.GetClosestToPoint(randomInterestNodeAwayFrom.transform.position);
		BasePathNode basePathNode = null;
		bool flag = false;
		List<BasePathNode> nodes = Facepunch.Pool.GetList<BasePathNode>();
		if (GetEngagementPath(ref nodes))
		{
			flag = true;
			basePathNode = nodes[nodes.Count - 1];
		}
		else
		{
			basePathNode = patrolPath.GetClosestToPoint(base.transform.position);
		}
		if (!(Vector3.Distance(finalDestination, closestToPoint.transform.position) > 2f))
		{
			return;
		}
		if (closestToPoint == basePathNode)
		{
			currentPath.Clear();
			currentPath.Add(closestToPoint.transform.position);
			currentPathIndex = -1;
			pathLooping = false;
			finalDestination = closestToPoint.transform.position;
		}
		else
		{
			if (!AStarPath.FindPath(basePathNode, closestToPoint, out var path, out var _))
			{
				return;
			}
			currentPath.Clear();
			if (flag)
			{
				for (int i = 0; i < nodes.Count - 1; i++)
				{
					currentPath.Add(nodes[i].transform.position);
				}
			}
			foreach (BasePathNode item in path)
			{
				currentPath.Add(item.transform.position);
			}
			currentPathIndex = -1;
			pathLooping = false;
			finalDestination = closestToPoint.transform.position;
		}
	}

```

## CanHelicopterUseNapalm(PatrolHelicopterAI)

```csharp
```csharp
/// <summary>
/// Called to determine if a helicopter can use napalm.
/// </summary>
/// <param name="helicopter">The helicopter in question.</param>
/// <returns>
/// Returns `true` if the helicopter is allowed to use napalm, and `false` otherwise.
/// If no return value is specified, returns whether 30 seconds have passed since the last time napalm was used.
/// </returns>
bool CanHelicopterUseNapalm(PatrolHelicopterAI helicopter)
{
    Puts($"Checking if helicopter can use napalm...");
    if (helicopter.IsOnFire())
    {
        Puts("Helicopter is on fire, cannot use napalm.");
        return false;
    }
    object obj = Interface.CallHook("CanHelicopterUseNapalm", helicopter);
    if (obj is bool)
    {
        return (bool)obj;
    }
    return UnityEngine.Time.realtimeSinceStartup - lastNapalmTime >= 30f;
}
```
```

### Source Code from the Library

```csharp

	public bool CanUseNapalm()
	{
		object obj = Interface.CallHook("CanHelicopterUseNapalm", this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return UnityEngine.Time.realtimeSinceStartup - lastNapalmTime >= 30f;
	}

```

## OnHorseHitch(RidableHorse,HitchTrough.HitchSpot)

```csharp
```csharp
/// <summary>
/// Called when a horse is hitched to a hitch trough.
/// </summary>
/// <param name="horse">The RidableHorse being hitched.</param>
/// <param name="hitchSpot">The HitchTrough.HitchSpot where the horse is being hitched.</param>
/// <returns>
/// Returns `true` if the horse was successfully hitched, or `false` if not.
/// If a non-null value other than `bool` is returned, it will override the default behavior.
/// </returns>
object OnHorseHitch(RidableHorse horse, HitchSpot hitchSpot)
{
    Puts($"Horse {horse.name} has been hitched to {hitchSpot.name}.");
    if (hitchSpot.isOccupied)
    {
        Puts($"Cannot hitch horse to occupied spot: {hitchSpot.name}");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public bool AttemptToHitch(RidableHorse horse, HitchSpot hitch = null)
	{
		if (horse == null)
		{
			return false;
		}
		if (hitch == null)
		{
			hitch = GetClosest(horse.transform.position);
		}
		if (hitch != null)
		{
			object obj = Interface.CallHook("OnHorseHitch", horse, hitch);
			if (obj is bool)
			{
				return (bool)obj;
			}
			hitch.SetOccupiedBy(horse);
			horse.SetHitch(this);
			horse.transform.rotation = hitch.spot.transform.rotation;
			horse.transform.position = hitch.spot.transform.position;
			horse.DismountAllPlayers();
			return true;
		}
		return false;
	}

```

## CanAffordUpgrade(BasePlayer,BuildingBlock,BuildingGrade.Enum)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can afford an upgrade.
/// </summary>
/// <param name="player">The player attempting the upgrade.</param>
/// <param name="buildingBlock">The building block being upgraded.</param>
/// <param name="grade">The grade of the upgrade.</param>
/// <returns>
/// Returns `true` if the player can afford the upgrade, or `false` otherwise.
/// If a non-null value is returned, it will override the default behavior and be used as the return value.
/// </returns>
bool CanAffordUpgrade(BasePlayer player, BuildingBlock buildingBlock, BuildingGrade.Enum grade)
{
    Puts($"Checking if {player.UserIDString} can afford upgrade to {grade} for {buildingBlock.name}");
    object obj = Interface.CallHook("CanAffordUpgrade", player, buildingBlock, grade);
    if (obj is bool)
    {
        return (bool)obj;
    }
    // Default behavior: check if the player has enough resources
    foreach (ItemAmount item in GetGrade(grade).costToBuild)
    {
        if ((float)player.inventory.GetAmount(item.itemid) < item.amount)
        {
            Puts($"Player {player.UserIDString} does not have enough resources to afford upgrade to {grade} for {buildingBlock.name}");
            return false;
        }
    }
    return true;
}
```
```

### Source Code from the Library

```csharp

	public bool CanAffordUpgrade(BuildingGrade.Enum iGrade, BasePlayer player)
	{
		object obj = Interface.CallHook("CanAffordUpgrade", player, this, iGrade);
		if (obj is bool)
		{
			return (bool)obj;
		}
		foreach (ItemAmount item in GetGrade(iGrade).costToBuild)
		{
			if ((float)player.inventory.GetAmount(item.itemid) < item.amount)
			{
				return false;
			}
		}
		return true;
	}

```

## OnLootPlayer(BasePlayer,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player is looted.
/// </summary>
/// <param name="looter">The player doing the looting.</param>
/// <param name="target">The player being looted.</param>
/// <returns>No return behavior.</returns>
void OnLootPlayer(BasePlayer looter, BasePlayer target)
{
    Puts($"Player {looter.UserIDString} is looting player {target.UserIDString}");
    if (looter.UserID == 123456) // Example: Only allow admin to loot
    {
        Puts($"Player {looter.UserIDString} does not have permission to loot.");
        return;
    }
    // Additional logic can be added here
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void RPC_LootPlayer(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if ((bool)player && player.CanInteract() && CanBeLooted(player) && player.inventory.loot.StartLootingEntity(this))
		{
			player.inventory.loot.AddContainer(inventory.containerMain);
			player.inventory.loot.AddContainer(inventory.containerWear);
			player.inventory.loot.AddContainer(inventory.containerBelt);
			Interface.CallHook("OnLootPlayer", this, player);
			player.inventory.loot.SendImmediate();
			player.ClientRPCPlayer(null, player, "RPC_OpenLootPanel", "player_corpse");
		}
	}

```

## CanDemolish(BasePlayer,BuildingBlock)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can demolish the current object.
/// </summary>
/// <param name="player">The player attempting to demolish.</param>
/// <param name="objectBeingDemolished">The object being demolished, which could be a building or other structure.</param>
/// <returns>
/// Returns `true` if the player can demolish the object, and `false` otherwise.
/// If `null` is returned, the default behavior will be to allow demolition if the object is demolishable and the player has the necessary privilege.
/// </returns>
object CanDemolish(BasePlayer player, BuildingBlock objectBeingDemolished)
{
    Puts($"Player {player.UserIDString} is attempting to demolish {objectBeingDemolished.GetType().Name}.");
    if (player.IsAdmin())
    {
        return true;
    }
    else if (IsDemolishable() && HasDemolishPrivilege(player))
    {
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public bool CanDemolish(BasePlayer player)
	{
		object obj = Interface.CallHook("CanDemolish", player, this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (IsDemolishable())
		{
			return HasDemolishPrivilege(player);
		}
		return false;
	}

```

## OnAirdrop(CargoPlane,UnityEngine.Vector3)

```csharp
```csharp
/// <summary>
/// Called when an airdrop is performed.
/// </summary>
/// <param name="cargoPlane">The cargo plane performing the airdrop.</param>
/// <param name="dropPosition">The position where the airdrop will be dropped.</param>
/// <returns>No return behavior.</returns>
void OnAirdrop(CargoPlane cargoPlane, Vector3 dropPosition)
{
    Puts($"Airdrop performed by {cargoPlane.name} at position: {dropPosition}");
    if (Vector3.Distance(dropPosition, new Vector3(0f, 100f, 0f)) < 10f)
    {
        Puts($"Airdrop dropped too close to the base.");
        // Handle airdrop being dropped too close to the base
    }
}
```
```

### Source Code from the Library

```csharp

	public void UpdateDropPosition(Vector3 newDropPosition)
	{
		float x = TerrainMeta.Size.x;
		float y = TerrainMeta.HighestPoint.y + 250f;
		startPos = Vector3Ex.Range(-1f, 1f);
		startPos.y = 0f;
		startPos.Normalize();
		startPos *= x * 2f;
		startPos.y = y;
		endPos = startPos * -1f;
		endPos.y = startPos.y;
		startPos += newDropPosition;
		endPos += newDropPosition;
		secondsToTake = Vector3.Distance(startPos, endPos) / 50f;
		secondsToTake *= UnityEngine.Random.Range(0.95f, 1.05f);
		base.transform.position = startPos;
		base.transform.rotation = Quaternion.LookRotation(endPos - startPos);
		dropPosition = newDropPosition;
		Interface.CallHook("OnAirdrop", this, newDropPosition);
	}

```

## OnTeamKick(RelationshipManager.PlayerTeam,BasePlayer,ulong)

```csharp
```csharp
/// <summary>
/// Called when a team member is kicked.
/// </summary>
/// <param name="team">The team from which the player was kicked.</param>
/// <param name="kickedPlayer">The player who was kicked.</param>
/// <param name="newTeamID">The ID of the new team to which the player will be moved.</param>
/// <returns>
/// Returns `null` to allow the kick to proceed, or any non-null value to prevent the kick.
/// </returns>
object OnTeamKick(PlayerTeam team, BasePlayer kickedPlayer, ulong newTeamID)
{
    Puts($"Player {kickedPlayer.UserIDString} was kicked from team {team.Name} and moved to team with ID {newTeamID}");
    if (newTeamID == 1234567890)
    {
        Puts($"Player {kickedPlayer.UserIDString} cannot be moved to team with ID {newTeamID}");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[ServerUserVar]
	public static void kickmember(ConsoleSystem.Arg arg)
	{
		BasePlayer basePlayer = ArgEx.Player(arg);
		if (basePlayer == null)
		{
			return;
		}
		PlayerTeam playerTeam = Instance.FindTeam(basePlayer.currentTeam);
		if (playerTeam != null && !(playerTeam.GetLeader() != basePlayer))
		{
			ulong uLong = arg.GetULong(0, 0uL);
			if (basePlayer.userID != uLong && Interface.CallHook("OnTeamKick", playerTeam, basePlayer, uLong) == null)
			{
				playerTeam.RemovePlayer(uLong);
			}
		}
	}

```

## OnLootNetworkUpdate(PlayerLoot)

```csharp
```csharp
/// <summary>
/// Called when the loot network is updated.
/// </summary>
/// <param name="loot">The updated loot data.</param>
/// <returns>No return behavior.</returns>
void OnLootNetworkUpdate(PlayerLoot loot)
{
    Puts($"Loot network updated with entity ID {loot.entityID} and item ID {loot.itemID}");
    if (loot.containers != null && loot.containers.Count > 0)
    {
        Puts($"Containers updated: {string.Join(", ", loot.containers.Select(c => c.containerType))}");
    }
}
```
```

### Source Code from the Library

```csharp

	private void SendUpdate()
	{
		isInvokingSendUpdate = false;
		if (!base.baseEntity.IsValid() || Interface.CallHook("OnLootNetworkUpdate", this) != null)
		{
			return;
		}
		using PlayerUpdateLoot playerUpdateLoot = Pool.Get<PlayerUpdateLoot>();
		if ((bool)entitySource && entitySource.net != null)
		{
			playerUpdateLoot.entityID = entitySource.net.ID;
		}
		if (itemSource != null)
		{
			playerUpdateLoot.itemID = itemSource.uid;
		}
		if (containers.Count > 0)
		{
			playerUpdateLoot.containers = Pool.Get<List<ProtoBuf.ItemContainer>>();
			foreach (ItemContainer container in containers)
			{
				playerUpdateLoot.containers.Add(container.Save());
			}
		}
		base.baseEntity.ClientRPCPlayer(null, base.baseEntity, "UpdateLoot", playerUpdateLoot);
	}

```

## OnExplosiveDud(DudTimedExplosive)

```csharp
```csharp
/// <summary>
/// Called when an explosive device becomes a dud.
/// </summary>
/// <param name="explosive">The explosive device that became a dud.</param>
/// <returns>No return behavior.</returns>
void OnExplosiveDud(DudTimedExplosive explosive)
{
    Puts($"Explosive device {explosive.GetId()} has become a dud.");
    // Minimal code to demonstrate functionality
}
```
```

### Source Code from the Library

```csharp

	public override void Explode()
	{
		if (creatorEntity != null && creatorEntity.IsNpc)
		{
			base.Explode();
		}
		else if (UnityEngine.Random.Range(0f, 1f) < dudChance && Interface.CallHook("OnExplosiveDud", this) == null)
		{
			BecomeDud();
		}
		else
		{
			base.Explode();
		}
	}

```

## OnTurretStartup(AutoTurret)

```csharp
```csharp
/// <summary>
/// Called when a turret starts up.
/// </summary>
/// <param name="turret">The AutoTurret instance starting up.</param>
/// <returns>
/// Returns `null` to allow the turret to start up normally, or any non-null value to prevent it from starting up.
/// </returns>
object OnTurretStartup(AutoTurret turret)
{
    Puts($"Turret {turret.name} has started up.");
    if (turret.isMalfunctioning)
    {
        Puts($"Turret {turret.name} is malfunctioning and will not start up.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void InitiateStartup()
	{
		if (!IsOnline() && !booting && Interface.CallHook("OnTurretStartup", this) == null)
		{
			Effect.server.Run(onlineSound.resourcePath, this, 0u, Vector3.zero, Vector3.zero);
			Invoke(SetOnline, 2f);
			booting = true;
		}
	}

```

## OnTeamUpdate(ulong,ulong,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player's team is updated.
/// </summary>
/// <param name="oldTeam">The player's old team.</param>
/// <param name="newTeam">The player's new team.</param>
/// <param name="player">The player whose team was updated.</param>
/// <returns>
/// Returns `null` to allow the team update, or any non-null value to prevent the team from being updated.
/// </returns>
object OnTeamUpdate(ulong oldTeam, ulong newTeam, BasePlayer player)
{
    Puts($"Player {player.UserIDString} changed teams from {oldTeam} to {newTeam}");
    if (newTeam == 1234567890)
    {
        Puts($"Player {player.displayName} is not allowed to join team {newTeam}");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void UpdateTeam(ulong newTeam)
	{
		if (Interface.CallHook("OnTeamUpdate", currentTeam, newTeam, this) == null)
		{
			currentTeam = newTeam;
			SendNetworkUpdate();
			if (RelationshipManager.Instance.FindTeam(newTeam) == null)
			{
				ClearTeam();
			}
			else
			{
				TeamUpdate();
			}
		}
	}

```

## OnGiveSoldItem(VendingMachine,Item,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player buys an item from a vending machine.
/// </summary>
/// <param name="vendingMachine">The vending machine that sold the item.</param>
/// <param name="soldItem">The item that was sold to the buyer.</param>
/// <param name="buyer">The player who bought the item.</param>
/// <returns>
/// Returns `null` to allow the player to receive the item, or any non-null value to prevent them from receiving it.
/// </returns>
object OnGiveSoldItem(VendingMachine vendingMachine, Item soldItem, BasePlayer buyer)
{
    Puts($"Player {buyer.UserIDString} bought {soldItem.info.name} from vending machine {vendingMachine.name}");
    if (soldItem.info.category == "rare")
    {
        Puts($"Player {buyer.displayName} is not allowed to buy rare items.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual void GiveSoldItem(Item soldItem, BasePlayer buyer)
	{
		if (Interface.CallHook("OnGiveSoldItem", this, soldItem, buyer) == null)
		{
			buyer.GiveItem(soldItem, GiveItemReason.PickedUp);
		}
	}

```

## OnSleepingBagDestroyed(SleepingBag,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a sleeping bag is destroyed.
/// </summary>
/// <param name="sleepingBag">The destroyed sleeping bag.</param>
/// <param name="player">The player who destroyed the sleeping bag.</param>
/// <returns>
/// Returns `null` to allow the sleeping bag to be destroyed, or any non-null value to prevent it from being destroyed.
/// </returns>
object OnSleepingBagDestroyed(SleepingBag sleepingBag, BasePlayer player)
{
    Puts($"Sleeping bag {sleepingBag.uniqueID} has been destroyed by player {player.UserIDString}");
    if (player.userID == 123456)
    {
        Puts($"Player {player.UserIDString} is not allowed to destroy sleeping bags.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public static bool DestroyBag(BasePlayer player, uint sleepingBag)
	{
		SleepingBag sleepingBag2 = FindForPlayer(player.userID, sleepingBag, ignoreTimers: false);
		if (sleepingBag2 == null)
		{
			return false;
		}
		if (Interface.CallHook("OnSleepingBagDestroy", sleepingBag2, player) != null)
		{
			return false;
		}
		if (sleepingBag2.canBePublic)
		{
			sleepingBag2.SetPublic(isPublic: true);
			sleepingBag2.deployerUserID = 0uL;
		}
		else
		{
			sleepingBag2.Kill();
		}
		player.SendRespawnOptions();
		Interface.CallHook("OnSleepingBagDestroyed", sleepingBag2, player);
		return true;
	}

```

## CanNpcEat(BaseNpc,BaseEntity)

```csharp
```csharp
/// <summary>
/// Called to determine if an NPC wants to eat a given entity.
/// </summary>
/// <param name="npc">The NPC in question.</param>
/// <param name="entity">The entity the NPC is considering eating.</param>
/// <returns>
/// Returns `true` if the NPC wants to eat the entity, and `false` otherwise.
/// If a non-null value other than `bool` is returned, it will be used as the return value instead of this default behavior.
/// </returns>
object CanNpcEat(BaseNpc npc, BaseEntity entity)
{
    Puts($"NPC {npc.name} wants to eat {entity.name}");
    if (entity.HasTrait(TraitFlag.Poisoned))
    {
        Puts($"NPC {npc.name} does not want to eat {entity.name} because it is poisoned.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual bool WantsToEat(BaseEntity best)
	{
		object obj = Interface.CallHook("CanNpcEat", this, best);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (!best.HasTrait(TraitFlag.Food))
		{
			return false;
		}
		if (best.HasTrait(TraitFlag.Alive))
		{
			return false;
		}
		return true;
	}

```

## OnPayForUpgrade(BasePlayer,BuildingBlock,ConstructionGrade)

```csharp
```csharp
/// <summary>
/// Called when a player pays for an upgrade.
/// </summary>
/// <param name="player">The player paying for the upgrade.</param>
/// <param name="block">The building block being upgraded.</param>
/// <param name="grade">The construction grade of the upgrade.</param>
/// <returns>
/// Returns `null` to allow the player to pay for the upgrade, or any non-null value to prevent them from paying.
/// </returns>
object OnPayForUpgrade(BasePlayer player, BuildingBlock block, ConstructionGrade grade)
{
    Puts($"Player {player.UserIDString} is paying for an upgrade of {block.name} to grade {grade.name}.");
    if (grade == ConstructionGrade.Premium && !player.HasPremiumStatus())
    {
        Puts($"Player {player.displayName} does not have premium status and cannot pay for a premium upgrade.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void PayForUpgrade(ConstructionGrade g, BasePlayer player)
	{
		if (Interface.CallHook("OnPayForUpgrade", player, this, g) != null)
		{
			return;
		}
		List<Item> list = new List<Item>();
		foreach (ItemAmount item in g.costToBuild)
		{
			player.inventory.Take(list, item.itemid, (int)item.amount);
			player.Command("note.inv " + item.itemid + " " + item.amount * -1f);
		}
		foreach (Item item2 in list)
		{
			item2.Remove();
		}
	}

```

## IOnNpcTarget(NPCPlayerApex,BaseEntity)

```csharp
```csharp
/// <summary>
/// Called when an NPC targets a base entity.
/// </summary>
/// <param name="npc">The NPC that is targeting the entity.</param>
/// <param name="entity">The base entity being targeted.</param>
/// <returns>
/// Returns `true` to allow the NPC to target the entity, or `false` to prevent it.
/// If a float value is returned, it represents the strength of the target desire (0-1).
/// </returns>
bool IOnNpcTarget(NPCPlayerApex npc, BaseEntity entity)
{
    Puts($"NPC {npc.UserIDString} has targeted entity {entity.UserIDString}");
    if (entity == null || !entity.IsValid())
    {
        return false;
    }
    if (entity.HasAnyTrait(TraitFlag.Animal | TraitFlag.Human))
    {
        return true;
    }
    return false;
}
```
```

### Source Code from the Library

```csharp

	public float GetWantsToAttack(BaseEntity target)
	{
		if (target == null)
		{
			return 0f;
		}
		object obj = Interface.CallHook("IOnNpcTarget", this, target);
		if (obj is float)
		{
			return (float)obj;
		}
		if (!target.HasAnyTrait(TraitFlag.Animal | TraitFlag.Human))
		{
			return 0f;
		}
		if (target.GetType() == GetType())
		{
			return 0f;
		}
		if (target.Health() <= 0f)
		{
			return 0f;
		}
		return 1f;
	}

```

## OnPayForPlacement(BasePlayer,Planner,Construction)

```csharp
```csharp
/// <summary>
/// Called when a player pays for the placement of an item.
/// </summary>
/// <param name="player">The player paying for the placement.</param>
/// <param name="planner">The planner used to deploy the item.</param>
/// <param name="component">The component being deployed.</param>
/// <returns>
/// Returns a non-null value to override the default payment behavior. 
/// If `null` is returned, the player pays for the placement as normal.
/// </returns>
object OnPayForPlacement(BasePlayer player, Planner planner, Construction component)
{
    Puts($"Player {player.UserIDString} has paid for the placement of {component.name}.");
    if (component.cost > 1000)
    {
        Puts($"Player {player.UserIDString} does not have enough funds to pay for the placement of {component.name}.");
        return "Insufficient funds.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void PayForPlacement(BasePlayer player, Construction component)
	{
		if (Interface.CallHook("OnPayForPlacement", player, this, component) != null)
		{
			return;
		}
		if (isTypeDeployable)
		{
			GetItem().UseItem();
			return;
		}
		List<Item> list = new List<Item>();
		foreach (ItemAmount item in component.defaultGrade.costToBuild)
		{
			player.inventory.Take(list, item.itemDef.itemid, (int)item.amount);
			player.Command("note.inv", item.itemDef.itemid, item.amount * -1f);
		}
		foreach (Item item2 in list)
		{
			item2.Remove();
		}
	}

```

## CanAcceptItem(ItemContainer,Item,int)

```csharp
```csharp
/// <summary>
/// Called when an item is being accepted into the container.
/// </summary>
/// <param name="item">The item being accepted.</param>
/// <param name="targetPos">The position in the container where the item will be placed.</param>
/// <returns>
/// Returns a non-null value to override the default acceptance behavior. 
/// If `CanAcceptResult.CannotAccept` is returned, the item cannot be accepted into the container.
/// If `CanAcceptResult.CannotAcceptRightNow` is returned, the item can be accepted into the container, but there are not enough available slots to accommodate it.
/// </returns>
object CanAcceptItem(ItemContainer container, Item item, int targetPos)
{
    Puts($"Item {item.info.name} is being accepted into container {container.info.name} at position {targetPos}.");
    if (item.info.itemType == ItemType.Key && !container.info.hasLock)
    {
        Puts($"Item {item.info.name} cannot be accepted into container {container.info.name} because it does not have a lock.");
        return CanAcceptResult.CannotAccept;
    }
    object obj = Interface.CallHook("CanAcceptItem", container, item, targetPos);
    if (obj is CanAcceptResult)
    {
        return obj;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public CanAcceptResult CanAcceptItem(Item item, int targetPos)
	{
		if (canAcceptItem != null && !canAcceptItem(item, targetPos))
		{
			return CanAcceptResult.CannotAccept;
		}
		if ((allowedContents & item.info.itemType) != item.info.itemType)
		{
			return CanAcceptResult.CannotAccept;
		}
		if (onlyAllowedItem != null && onlyAllowedItem != item.info)
		{
			return CanAcceptResult.CannotAccept;
		}
		if (availableSlots != null && availableSlots.Count > 0)
		{
			if (item.info.occupySlots == (ItemSlot)0 || item.info.occupySlots == ItemSlot.None)
			{
				return CanAcceptResult.CannotAccept;
			}
			int[] array = new int[32];
			foreach (ItemSlot availableSlot in availableSlots)
			{
				array[(int)Mathf.Log((float)availableSlot, 2f)]++;
			}
			foreach (Item item2 in itemList)
			{
				for (int i = 0; i < 32; i++)
				{
					if (((uint)item2.info.occupySlots & (uint)(1 << i)) != 0)
					{
						array[i]--;
					}
				}
			}
			for (int j = 0; j < 32; j++)
			{
				if (((uint)item.info.occupySlots & (uint)(1 << j)) != 0 && array[j] <= 0)
				{
					return CanAcceptResult.CannotAcceptRightNow;
				}
			}
		}
		object obj = Interface.CallHook("CanAcceptItem", this, item, targetPos);
		if (obj is CanAcceptResult)
		{
			return (CanAcceptResult)obj;
		}
		return CanAcceptResult.CanAccept;
	}

```

## CanLootEntity(BasePlayer,ResourceContainer)

```csharp
```csharp
/// <summary>
/// Called when a player attempts to loot an entity.
/// </summary>
/// <param name="player">The player attempting to loot the entity.</param>
/// <param name="entity">The entity being looted.</param>
/// <returns>
/// Returns `null` to allow the player to loot the entity, or any non-null value to prevent them from looting.
/// </returns>
object CanLootEntity(BasePlayer player, BaseEntity entity)
{
    Puts($"Player {player.UserIDString} is attempting to loot entity {entity.EntityID}.");
    if (entity.IsLocked)
    {
        Puts($"Entity {entity.EntityID} is locked and cannot be looted.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[BaseEntity.RPC_Server]
	[BaseEntity.RPC_Server.IsVisible(3f)]
	private void StartLootingContainer(BaseEntity.RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if ((bool)player && player.CanInteract() && lootable && Interface.CallHook("CanLootEntity", player, this) == null && player.inventory.loot.StartLootingEntity(base.baseEntity))
		{
			lastAccessTime = UnityEngine.Time.realtimeSinceStartup;
			player.inventory.loot.AddContainer(container);
		}
	}

```

## OnContainerDropItems(ItemContainer)

```csharp
```csharp
/// <summary>
/// Called when items are dropped from a container.
/// </summary>
/// <param name="container">The container from which the items were dropped.</param>
/// <returns>
/// Returns `true` to override the default drop behavior, or `false` to allow the items to be dropped normally.
/// If `null` is returned, the default drop behavior will be used.
/// </returns>
bool OnContainerDropItems(ItemContainer container)
{
    Puts($"Dropping items from container {container.GetDisplayName()}");
    if (container.GetItemCount() == 0)
    {
        Puts($"No items to drop from container {container.GetDisplayName()}");
        return true;
    }
    // Add custom logic here to override the default drop behavior
    return false;
}
```
```

### Source Code from the Library

```csharp
	public static void DropItems(ItemContainer container, Vector3 position, float chance = 1f)
	{
		if (!Server.dropitems || container == null || container.itemList == null || Interface.CallHook("OnContainerDropItems", container) != null)
		{
			return;
		}
		float num = 0.25f;
		Item[] array = container.itemList.ToArray();
		foreach (Item item in array)
		{
			if (!(UnityEngine.Random.Range(0f, 1f) > chance))
			{
				float num2 = UnityEngine.Random.Range(0f, 2f);
				item.RemoveFromContainer();
				BaseEntity baseEntity = item.CreateWorldObject(position + new Vector3(UnityEngine.Random.Range(0f - num, num), 1f, UnityEngine.Random.Range(0f - num, num)));
				if (baseEntity == null)
				{
					item.Remove();
				}
				else if (num2 > 0f)
				{
					baseEntity.SetVelocity(new Vector3(UnityEngine.Random.Range(-1f, 1f), UnityEngine.Random.Range(0f, 1f), UnityEngine.Random.Range(-1f, 1f)) * num2);
					baseEntity.SetAngularVelocity(new Vector3(UnityEngine.Random.Range(-10f, 10f), UnityEngine.Random.Range(-10f, 10f), UnityEngine.Random.Range(-10f, 10f)) * num2);
				}
			}
		}
	}

```

## OnTeamLeave(RelationshipManager.PlayerTeam,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player leaves their team.
/// </summary>
/// <param name="team">The team the player is leaving.</param>
/// <param name="player">The player leaving the team.</param>
/// <returns>
/// Returns `null` to allow the player to leave the team, or any non-null value to prevent them from leaving.
/// </returns>
object OnTeamLeave(PlayerTeam team, BasePlayer player)
{
    Puts($"Player {player.UserIDString} has left team {team.Name}");
    if (team.Name == "Admins")
    {
        Puts($"Player {player.displayName} is not allowed to leave the Admin team");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[ServerUserVar]
	public static void leaveteam(ConsoleSystem.Arg arg)
	{
		BasePlayer basePlayer = ArgEx.Player(arg);
		if (!(basePlayer == null) && basePlayer.currentTeam != 0L)
		{
			PlayerTeam playerTeam = Instance.FindTeam(basePlayer.currentTeam);
			if (playerTeam != null && Interface.CallHook("OnTeamLeave", playerTeam, basePlayer) == null)
			{
				playerTeam.RemovePlayer(basePlayer.userID);
				basePlayer.ClearTeam();
			}
		}
	}

```

## CanAdministerVending(BasePlayer,NPCVendingMachine)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can administer the vending machine.
/// </summary>
/// <param name="player">The player attempting to administer the vending machine.</param>
/// <param name="vendingMachine">The vending machine being administered.</param>
/// <returns>
/// Returns `true` if the player can administer the vending machine, and `false` otherwise.
/// If a non-bool value is returned, it will be ignored and the default behavior will apply.
/// </returns>
bool CanAdministerVending(BasePlayer player, NPCVendingMachine vendingMachine)
{
    Puts($"Player {player.UserIDString} is attempting to administer vending machine {vendingMachine.name}");
    if (player.IsSuperAdmin)
    {
        Puts($"Player {player.displayName} has been granted super admin privileges.");
        return true;
    }
    return false;
}
```
```

### Source Code from the Library

```csharp

	public override bool CanPlayerAdmin(BasePlayer player)
	{
		object obj = Interface.CallHook("CanAdministerVending", player, this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return false;
	}

```

## OnHelicopterRetire(PatrolHelicopterAI)

```csharp
```csharp
/// <summary>
/// Called when a helicopter is retiring.
/// </summary>
/// <param name="helicopter">The helicopter that is retiring.</param>
/// <returns>
/// Returns `null` to allow the helicopter to retire normally, or any non-null value to prevent it from retiring.
/// </returns>
object OnHelicopterRetire(PatrolHelicopterAI helicopter)
{
    Puts($"Helicopter {helicopter.GetID()} is retiring.");
    if (helicopter.GetFuelLevel() < 10f)
    {
        Puts($"Helicopter {helicopter.GetID()} has low fuel and will not retire.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void Retire()
	{
		if (!isRetiring && Interface.CallHook("OnHelicopterRetire", this) == null)
		{
			isRetiring = true;
			Invoke(DestroyMe, 240f);
			float x = TerrainMeta.Size.x;
			float y = 200f;
			Vector3 newPos = Vector3Ex.Range(-1f, 1f);
			newPos.y = 0f;
			newPos.Normalize();
			newPos *= x * 20f;
			newPos.y = y;
			ExitCurrentState();
			State_Move_Enter(newPos);
		}
	}

```

## OnNpcTarget(NPCPlayerApex,BaseEntity)

```csharp
```csharp
/// <summary>
/// Called when an NPC targets a player or entity.
/// </summary>
/// <param name="npc">The NPC that is targeting.</param>
/// <param name="target">The target of the NPC's attack.</param>
/// <returns>
/// Returns `null` to allow the NPC to target normally, or any non-null value to override the default behavior and prevent the NPC from targeting.
/// </returns>
object OnNpcTarget(NPCPlayerApex npc, BaseEntity target)
{
    Puts($"NPC {npc.UserIDString} is targeting {target.displayName}.");
    if (target == "infected")
    {
        Puts($"NPC {npc.UserIDString} cannot target the infected.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public Memory.SeenInfo UpdateTargetMemory(BaseEntity target, float dmg, Vector3 lastKnownPosition, out Memory.ExtendedInfo extendedInfo)
	{
		if (target == null || Interface.CallHook("OnNpcTarget", this, target) != null)
		{
			extendedInfo = default(Memory.ExtendedInfo);
			return default(Memory.SeenInfo);
		}
		Vector3 dir;
		float dot;
		if (base.isMounted)
		{
			BestMountedPlayerDirection.Evaluate(this, lastKnownPosition, out dir, out dot);
		}
		else
		{
			BestPlayerDirection.Evaluate(this, lastKnownPosition, out dir, out dot);
		}
		BestPlayerDistance.Evaluate(this, lastKnownPosition, out var distanceSqr, out var _);
		BasePlayer basePlayer = target.ToPlayer();
		int standing;
		int crouched;
		byte b = (byte)((!basePlayer) ? 1 : ((!base.isMounted) ? BestLineOfSight.Evaluate(this, basePlayer, out standing, out crouched) : BestMountedLineOfSight.Evaluate(this, basePlayer)));
		SetFact(Facts.HasLineOfSight, b);
		return AiContext.Memory.Update(target, lastKnownPosition, dmg, dir, dot, distanceSqr, b, lastAttacker == target, lastAttackedTime, out extendedInfo);
	}

```

## CanHelicopterStrafe(PatrolHelicopterAI)

```csharp
```csharp
/// <summary>
/// Called to determine if the helicopter can strafe.
/// </summary>
/// <param name="ai">The PatrolHelicopterAI instance.</param>
/// <returns>
/// Returns `true` if the helicopter can strafe, and `false` otherwise.
/// If a non-bool value is returned, it will be treated as `false`.
/// </returns>
bool CanHelicopterStrafe(PatrolHelicopterAI ai)
{
    Puts("Helicopter attempting to strafe.");
    // Minimal code to demonstrate functionality
    return true;
}
```
```

### Source Code from the Library

```csharp

	public bool CanStrafe()
	{
		object obj = Interface.CallHook("CanHelicopterStrafe", this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (UnityEngine.Time.realtimeSinceStartup - lastStrafeTime >= 20f)
		{
			return CanInterruptState();
		}
		return false;
	}

```

## CanDropActiveItem(BasePlayer)

```csharp
```csharp
/// <summary>
/// Called to determine if the player's active item should be dropped.
/// </summary>
/// <param name="player">The player whose active item is being considered for drop.</param>
/// <returns>
/// Returns `true` to allow the player's active item to be dropped, or `false` to prevent it from being dropped.
/// If a non-bool value is returned, the default behavior will be used (i.e., the item will be dropped).
/// </returns>
bool CanDropActiveItem(BasePlayer player)
{
    Puts($"Checking if {player.UserIDString}'s active item should be dropped.");
    // For example, let's say we want to prevent players from dropping their active items in a specific area
    if (player.transform.position.x < -1000 && player.transform.position.z < -1000)
    {
        return false;
    }
    return true;
}
```
```

### Source Code from the Library

```csharp

	public virtual bool ShouldDropActiveItem()
	{
		object obj = Interface.CallHook("CanDropActiveItem", this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return true;
	}

```

## OnConstructionPlace(BaseEntity,Construction,Construction.Target,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a construction is placed.
/// </summary>
/// <param name="baseEntity">The entity being constructed.</param>
/// <param name="construction">The construction component.</param>
/// <param name="placement">The placement target.</param>
/// <param name="ownerPlayer">The player who placed the construction.</param>
/// <returns>
/// Returns `null` to allow the construction to be placed normally, or any non-null value to override the default behavior.
/// If a string is returned, it will be used as a message for the construction's kill message.
/// </returns>
object OnConstructionPlace(BaseEntity baseEntity, Construction construction, Construction.Target placement, BasePlayer ownerPlayer)
{
    Puts($"Construction {baseEntity} has been placed by player {ownerPlayer} at target {placement}.");
    if (baseEntity is BuildingBlock buildingBlock && buildingBlock.blockDefinition == null)
    {
        Puts($"Warning: Building block {buildingBlock} has no block definition.");
        return "No block definition";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public GameObject DoPlacement(Construction.Target placement, Construction component)
	{
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if (!ownerPlayer)
		{
			return null;
		}
		BaseEntity baseEntity = component.CreateConstruction(placement, bNeedsValidPlacement: true);
		if (!baseEntity)
		{
			return null;
		}
		float num = 1f;
		float num2 = 0f;
		Item ownerItem = GetOwnerItem();
		if (ownerItem != null)
		{
			baseEntity.skinID = ownerItem.skin;
			if (ownerItem.hasCondition)
			{
				num = ownerItem.conditionNormalized;
			}
		}
		PoolableEx.AwakeFromInstantiate(baseEntity.gameObject);
		BuildingBlock buildingBlock = baseEntity as BuildingBlock;
		if ((bool)buildingBlock)
		{
			buildingBlock.blockDefinition = PrefabAttribute.server.Find<Construction>(buildingBlock.prefabID);
			if (!buildingBlock.blockDefinition)
			{
				Debug.LogError("Placing a building block that has no block definition!");
				return null;
			}
			buildingBlock.SetGrade(buildingBlock.blockDefinition.defaultGrade.gradeBase.type);
			num2 = buildingBlock.currentGrade.maxHealth;
		}
		BaseCombatEntity baseCombatEntity = baseEntity as BaseCombatEntity;
		if ((bool)baseCombatEntity)
		{
			num2 = ((buildingBlock != null) ? buildingBlock.currentGrade.maxHealth : baseCombatEntity.startHealth);
			baseCombatEntity.ResetLifeStateOnSpawn = false;
			baseCombatEntity.InitializeHealth(num2 * num, num2);
		}
		if (Interface.CallHook("OnConstructionPlace", baseEntity, component, placement, ownerPlayer) != null)
		{
			if (baseEntity.IsValid())
			{
				baseEntity.KillMessage();
			}
			else
			{
				GameManager.Destroy(baseEntity);
			}
			return null;
		}
		baseEntity.gameObject.SendMessage("SetDeployedBy", ownerPlayer, SendMessageOptions.DontRequireReceiver);
		baseEntity.OwnerID = ownerPlayer.userID;
		baseEntity.Spawn();
		if ((bool)buildingBlock)
		{
			Effect.server.Run("assets/bundled/prefabs/fx/build/frame_place.prefab", baseEntity, 0u, Vector3.zero, Vector3.zero);
		}
		StabilityEntity stabilityEntity = baseEntity as StabilityEntity;
		if ((bool)stabilityEntity)
		{
			stabilityEntity.UpdateSurroundingEntities();
		}
		return baseEntity.gameObject;
	}

```

## CanHackCrate(BasePlayer,HackableLockedCrate)

```csharp
```csharp
/// <summary>
/// Called to determine if a crate can be hacked.
/// </summary>
/// <param name="player">The player attempting to hack the crate.</param>
/// <param name="crate">The crate being attempted to be hacked.</param>
/// <returns>
/// Returns `null` to allow the crate to be hacked, or any non-null value to prevent it from being hacked.
/// </returns>
object CanHackCrate(BasePlayer player, HackableLockedCrate crate)
{
    Puts($"Player {player.UserIDString} is attempting to hack crate {crate.CrateID}");
    if (player.IsAdmin)
    {
        Puts($"Player {player.displayName} has admin privileges and can hack the crate.");
        return null;
    }
    else
    {
        Puts($"Player {player.displayName} does not have admin privileges and cannot hack the crate.");
        return "Access denied: Not an administrator.";
    }
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	public void RPC_Hack(RPCMessage msg)
	{
		if (!IsBeingHacked() && Interface.CallHook("CanHackCrate", msg.player, this) == null)
		{
			StartHacking();
		}
	}

```

## OnResearchCostDetermine(Item,ResearchTable)

```csharp
```csharp
/// <summary>
/// Called to determine the cost of research for a given item.
/// </summary>
/// <param name="item">The item being researched.</param>
/// <param name="researchTable">The table used for determining research costs.</param>
/// <returns>
/// Returns an integer representing the cost of research, or `null` if no custom cost is specified.
/// If a non-integer value is returned, it will be ignored and the default cost based on item rarity will be used.
/// </returns>
object OnResearchCostDetermine(Item item, ResearchTable researchTable)
{
    Puts($"Determining research cost for {item.info.name}...");
    if (researchTable.GetCustomCost(item) != null)
    {
        return researchTable.GetCustomCost(item);
    }
    int result = 0;
    switch (item.info.rarity)
    {
        case Rarity.Common:
            result = 20;
            break;
        case Rarity.Uncommon:
            result = 75;
            break;
        case Rarity.Rare:
            result = 125;
            break;
        case Rarity.VeryRare:
        case Rarity.None:
            result = 500;
            break;
    }
    return result;
}
```
```

### Source Code from the Library

```csharp

	public int ScrapForResearch(Item item)
	{
		object obj = Interface.CallHook("OnResearchCostDetermine", item, this);
		if (obj is int)
		{
			return (int)obj;
		}
		int result = 0;
		if (item.info.rarity == Rarity.Common)
		{
			result = 20;
		}
		if (item.info.rarity == Rarity.Uncommon)
		{
			result = 75;
		}
		if (item.info.rarity == Rarity.Rare)
		{
			result = 125;
		}
		if (item.info.rarity == Rarity.VeryRare || item.info.rarity == Rarity.None)
		{
			result = 500;
		}
		return result;
	}

```

## OnEntityMarkHostile(BaseCombatEntity,float)

```csharp
```csharp
/// <summary>
/// Called when an entity is marked as hostile.
/// </summary>
/// <param name="entity">The entity being marked as hostile.</param>
/// <param name="duration">The duration for which the entity should be considered hostile, in seconds. Defaults to 60 seconds.</param>
/// <returns>
/// Returns `null` to allow the entity to be marked as hostile, or any non-null value to prevent it from being marked.
/// </returns>
object OnEntityMarkHostile(BaseCombatEntity entity, float duration)
{
    Puts($"Entity {entity.UserIDString} has been marked as hostile for {duration} seconds.");
    if (entity is Player player && player.IsAdmin)
    {
        Puts($"Player {player.displayName} has been exempted from being marked as hostile.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual void MarkHostileFor(float duration = 60f)
	{
		if (Interface.CallHook("OnEntityMarkHostile", this, duration) == null)
		{
			float b = UnityEngine.Time.realtimeSinceStartup + duration;
			unHostileTime = Mathf.Max(unHostileTime, b);
		}
	}

```

## OnCreateWorldProjectile(HitInfo,Item)

```csharp
```csharp
/// <summary>
/// Called when a world projectile is created.
/// </summary>
/// <param name="hitInfo">The hit info of the projectile.</param>
/// <param name="item">The item that was used to create the projectile.</param>
/// <returns>
/// Returns `null` if the projectile should be created normally. 
/// If a non-null value is returned, it will override the default behavior and either prevent the projectile from being created or modify its properties.
/// </returns>
object OnCreateWorldProjectile(HitInfo hitInfo, Item item)
{
    Puts($"A world projectile was created at position {hitInfo.HitPositionWorld} with velocity {hitInfo.ProjectileVelocity}.");
    if (hitInfo.DidHit && hitInfo.HitEntity != null && hitInfo.HitBone != 0)
    {
        // Prevent the projectile from being stuck to an entity
        return "Prevented sticking.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	protected virtual void CreateWorldProjectile(HitInfo info, ItemDefinition itemDef, ItemModProjectile itemMod, Projectile projectilePrefab, Item recycleItem)
	{
		if (Interface.CallHook("CanCreateWorldProjectile", info, itemDef) != null)
		{
			return;
		}
		UnityEngine.Vector3 projectileVelocity = info.ProjectileVelocity;
		Item item = ((recycleItem != null) ? recycleItem : ItemManager.Create(itemDef, 1, 0uL));
		if (Interface.CallHook("OnCreateWorldProjectile", info, item) != null)
		{
			return;
		}
		BaseEntity baseEntity = null;
		if (!info.DidHit)
		{
			baseEntity = item.CreateWorldObject(info.HitPositionWorld, UnityEngine.Quaternion.LookRotation(projectileVelocity.normalized));
			baseEntity.Kill(DestroyMode.Gib);
			return;
		}
		if (projectilePrefab.breakProbability > 0f && UnityEngine.Random.value <= projectilePrefab.breakProbability)
		{
			baseEntity = item.CreateWorldObject(info.HitPositionWorld, UnityEngine.Quaternion.LookRotation(projectileVelocity.normalized));
			baseEntity.Kill(DestroyMode.Gib);
			return;
		}
		if (projectilePrefab.conditionLoss > 0f)
		{
			item.LoseCondition(projectilePrefab.conditionLoss * 100f);
			if (item.isBroken)
			{
				baseEntity = item.CreateWorldObject(info.HitPositionWorld, UnityEngine.Quaternion.LookRotation(projectileVelocity.normalized));
				baseEntity.Kill(DestroyMode.Gib);
				return;
			}
		}
		if (projectilePrefab.stickProbability > 0f && UnityEngine.Random.value <= projectilePrefab.stickProbability)
		{
			baseEntity = ((info.HitEntity == null) ? item.CreateWorldObject(info.HitPositionWorld, UnityEngine.Quaternion.LookRotation(projectileVelocity.normalized)) : ((info.HitBone != 0) ? item.CreateWorldObject(info.HitPositionLocal, UnityEngine.Quaternion.LookRotation(info.HitNormalLocal * -1f), info.HitEntity, info.HitBone) : item.CreateWorldObject(info.HitPositionLocal, UnityEngine.Quaternion.LookRotation(info.HitEntity.transform.InverseTransformDirection(projectileVelocity.normalized)), info.HitEntity)));
			baseEntity.GetComponent<Rigidbody>().isKinematic = true;
			return;
		}
		baseEntity = item.CreateWorldObject(info.HitPositionWorld, UnityEngine.Quaternion.LookRotation(projectileVelocity.normalized));
		Rigidbody component = baseEntity.GetComponent<Rigidbody>();
		component.AddForce(projectileVelocity.normalized * 200f);
		component.WakeUp();
	}

```

## OnNpcDuck(HumanNPC)

```csharp
```csharp
/// <summary>
/// Called when an NPC ducks.
/// </summary>
/// <param name="npc">The HumanNPC instance that is ducking.</param>
/// <returns>
/// Returns `null` to allow the NPC to duck, or any non-null value to prevent them from ducking.
/// </returns>
object OnNpcDuck(HumanNPC npc)
{
    Puts($"NPC {npc.name} has ducked.");
    if (npc.isPlayerControlled)
    {
        Puts($"NPC {npc.name} is a player-controlled NPC and cannot be prevented from ducking.");
        return null;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void SetDucked(bool wantsDucked)
	{
		if (Interface.CallHook("OnNpcDuck", this) == null)
		{
			pendingDucked = wantsDucked;
			ApplyPendingDucked();
		}
	}

```

## CanUseVending(BasePlayer,VendingMachine)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can use the vending machine.
/// </summary>
/// <param name="player">The player attempting to use the vending machine.</param>
/// <param name="vendingMachine">The vending machine being used.</param>
/// <returns>
/// Returns `true` if the player is allowed to use the vending machine, or `false` otherwise.
/// If a non-bool value is returned, it will be treated as `false`.
/// </returns>
object CanUseVending(BasePlayer player, VendingMachine vendingMachine)
{
    Puts($"Player {player.UserIDString} is trying to use vending machine {vendingMachine.name}");
    if (player.IsAdmin())
    {
        return true;
    }
    // Check if the player has a valid ticket
    if (player.HasValidTicket(vendingMachine))
    {
        return true;
    }
    return false;
}
```
```

### Source Code from the Library

```csharp

	public override bool CanOpenLootPanel(BasePlayer player, string panelName = "")
	{
		object obj = Interface.CallHook("CanUseVending", player, this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (panelName == customerPanel)
		{
			return true;
		}
		if (base.CanOpenLootPanel(player, panelName))
		{
			return CanPlayerAdmin(player);
		}
		return false;
	}

```

## CanChangeGrade(BasePlayer,BuildingBlock,BuildingGrade.Enum)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can change the grade of a building block.
/// </summary>
/// <param name="player">The player attempting to change the grade.</param>
/// <param name="block">The building block being modified.</param>
/// <param name="grade">The new grade to be applied.</param>
/// <returns>
/// Returns `true` if the player can change the grade, or `false` otherwise.
/// If a non-null value is returned, it will override the default behavior and determine whether the player can change the grade.
/// </returns>
bool CanChangeGrade(BasePlayer player, BuildingBlock block, BuildingGrade.Enum grade)
{
    Puts($"Player {player.UserIDString} attempted to change the grade of {block.BlockName} to {grade}");
    object obj = Interface.CallHook("CanChangeGrade", player, block, grade);
    if (obj is bool)
    {
        return (bool)obj;
    }
    // If no hook returns a value, check if the player has upgrade privilege and if upgrades are not blocked
    return HasUpgradePrivilege(grade, player) && !IsUpgradeBlocked();
}
```
```

### Source Code from the Library

```csharp

	public bool CanChangeToGrade(BuildingGrade.Enum iGrade, BasePlayer player)
	{
		object obj = Interface.CallHook("CanChangeGrade", player, this, iGrade);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (HasUpgradePrivilege(iGrade, player))
		{
			return !IsUpgradeBlocked();
		}
		return false;
	}

```

## IOnNpcTarget(BaseNpc,BaseEntity)

```csharp
```csharp
/// <summary>
/// Called when an NPC targets another entity.
/// </summary>
/// <param name="npc">The NPC that targeted the entity.</param>
/// <param name="target">The entity that was targeted by the NPC.</param>
/// <returns>
/// Returns a float value indicating how much the NPC wants to attack the target, on a scale of 0 to 1.
/// If `null` is returned, the default behavior will be used.
/// </returns>
float IOnNpcTarget(BaseNpc npc, BaseEntity target)
{
    Puts($"NPC {npc.name} targeted entity {target.UserIDString}");
    if (target is Player player && player.IsSpectating)
    {
        Puts($"NPC {npc.name} does not want to attack spectating player {player.UserIDString}");
        return 0;
    }
    return WantsToAttack(target);
}
```
```

### Source Code from the Library

```csharp

	public float GetWantsToAttack(BaseEntity target)
	{
		object obj = Interface.CallHook("IOnNpcTarget", this, target);
		if (obj is float)
		{
			return (float)obj;
		}
		return WantsToAttack(target);
	}

```

## OnPlayerSetInfo(Network.Connection,string,string)

```csharp
```csharp
/// <summary>
/// Called when a player's information is updated.
/// </summary>
/// <param name="connection">The network connection of the player.</param>
/// <param name="key">The key of the information being updated (e.g. "name", "email", etc.).</param>
/// <param name="value">The new value for the specified key.</param>
/// <returns>No return behavior.</returns>
void OnPlayerSetInfo(Network.Connection connection, string key, string value)
{
    Puts($"Player's {key} has been updated to: {value}");
}
```
```

### Source Code from the Library

```csharp

	public virtual void SetInfo(string key, string val)
	{
		if (IsConnected)
		{
			Interface.CallHook("OnPlayerSetInfo", net.connection, key, val);
			net.connection.info.Set(key, val);
		}
	}

```

## OnEntitySpawned(BaseNetworkable)

```csharp
```csharp
/// <summary>
/// Called when an entity is spawned.
/// </summary>
/// <param name="entity">The entity that was spawned.</param>
/// <returns>No return behavior.</returns>
void OnEntitySpawned(BaseNetworkable entity)
{
    Puts($"Entity {entity.EntityID} has been spawned.");
}
```
```

### Source Code from the Library

```csharp

	public virtual void Spawn()
	{
		SpawnShared();
		if (net == null)
		{
			net = Network.Net.sv.CreateNetworkable();
		}
		creationFrame = UnityEngine.Time.frameCount;
		PreInitShared();
		InitShared();
		ServerInit();
		PostInitShared();
		UpdateNetworkGroup();
		isSpawned = true;
		Interface.CallHook("OnEntitySpawned", this);
		SendNetworkUpdateImmediate(justCreated: true);
		if (Rust.Application.isLoading && !Rust.Application.isLoadingSave)
		{
			base.gameObject.SendOnSendNetworkUpdate(this as BaseEntity);
		}
	}

```

## CanHelicopterTarget(PatrolHelicopterAI,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called to determine if a helicopter can target a player.
/// </summary>
/// <param name="helicopter">The helicopter attempting to target the player.</param>
/// <param name="player">The player being targeted.</param>
/// <returns>
/// Returns `true` if the helicopter can target the player, and `false` otherwise.
/// If this method is not implemented or returns a non-boolean value, the default behavior will be used.
/// </returns>
bool CanHelicopterTarget(PatrolHelicopterAI helicopter, BasePlayer player)
{
    Puts($"Helicopter {helicopter.GetReference()} attempting to target player {player.UserIDString}.");
    if (player.IsDead || player.IsInvisible)
    {
        return false;
    }
    // Additional logic can be added here to determine if the helicopter can target the player
    return true;
}
```
```

### Source Code from the Library

```csharp

	public bool PlayerVisible(BasePlayer ply)
	{
		object obj = Interface.CallHook("CanHelicopterTarget", this, ply);
		if (obj is bool)
		{
			return (bool)obj;
		}
		Vector3 position = ply.eyes.position;
		if (TOD_Sky.Instance.IsNight && Vector3.Distance(position, interestZoneOrigin) > 40f)
		{
			return false;
		}
		Vector3 vector = base.transform.position - Vector3.up * 6f;
		float num = Vector3.Distance(position, vector);
		Vector3 normalized = (position - vector).normalized;
		if (GamePhysics.Trace(new Ray(vector + normalized * 5f, normalized), 0f, out var hitInfo, num * 1.1f, 1218652417) && GameObjectEx.ToBaseEntity(hitInfo.collider.gameObject) == ply)
		{
			return true;
		}
		return false;
	}

```

## OnEntityStabilityCheck(StabilityEntity)

```csharp
```csharp
/// <summary>
/// Called when an entity's stability is checked.
/// </summary>
/// <param name="entity">The entity being checked.</param>
/// <returns>
/// Returns a non-null value to override the default stability check behavior. 
/// If `null` is returned, the entity's stability will be checked as normal.
/// </returns>
object OnEntityStabilityCheck(StabilityEntity entity)
{
    Puts($"Checking stability of entity {entity.EntityID}.");
    if (entity.EntityID == 12345) // Replace with actual ID
    {
        Puts($"Entity {entity.EntityID} has been flagged for instability.");
        return "Instability detected.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void StabilityCheck()
	{
		if (base.IsDestroyed || Interface.CallHook("OnEntityStabilityCheck", this) != null)
		{
			return;
		}
		if (supports == null)
		{
			InitializeSupports();
		}
		bool flag = false;
		int num = DistanceFromGround();
		if (num != cachedDistanceFromGround)
		{
			cachedDistanceFromGround = num;
			flag = true;
		}
		float num2 = SupportValue();
		if (Mathf.Abs(cachedStability - num2) > Stability.accuracy)
		{
			cachedStability = num2;
			flag = true;
		}
		if (flag)
		{
			dirty = true;
			UpdateConnectedEntities();
			UpdateStability();
		}
		else if (dirty)
		{
			dirty = false;
			SendNetworkUpdate();
		}
		if (num2 < Stability.collapse)
		{
			if (stabilityStrikes < Stability.strikes)
			{
				UpdateStability();
				stabilityStrikes++;
			}
			else
			{
				Kill(DestroyMode.Gib);
			}
		}
		else
		{
			stabilityStrikes = 0;
		}
	}

```

## OnLootEntityEnd(BasePlayer,StorageContainer)

```csharp
```csharp
/// <summary>
/// Called when a player stops looting an entity.
/// </summary>
/// <param name="player">The player who stopped looting.</param>
/// <param name="container">The storage container being used for looting.</param>
/// <returns>No return behavior.</returns>
void OnLootEntityEnd(BasePlayer player, StorageContainer container)
{
    Puts($"Player {player.UserIDString} has stopped looting the entity.");
    if (container.GetContents().Count > 0)
    {
        Puts($"The storage container still contains {container.GetContents().Count} items.");
    }
}
```
```

### Source Code from the Library

```csharp

	public virtual void PlayerStoppedLooting(BasePlayer player)
	{
		Interface.CallHook("OnLootEntityEnd", player, this);
		SetFlag(Flags.Open, b: false);
		SendNetworkUpdate();
	}

```

## OnEntityGroundMissing(BaseEntity)

```csharp
```csharp
/// <summary>
/// Called when an entity is missing its ground.
/// </summary>
/// <param name="entity">The BaseEntity that is missing its ground.</param>
/// <returns>
/// Returns `null` to allow the entity to be destroyed, or any non-null value to prevent it from being destroyed.
/// </returns>
object OnEntityGroundMissing(BaseEntity entity)
{
    Puts($"Entity {entity.UserIDString} has lost contact with the ground.");
    if (entity is BasePlayer player && !player.IsSpectating())
    {
        Puts($"Player {player.displayName} will be killed due to being disconnected from the ground.");
        return null;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp
	private void OnGroundMissing()
	{
		BaseEntity baseEntity = GameObjectEx.ToBaseEntity(base.gameObject);
		if (baseEntity != null && Interface.CallHook("OnEntityGroundMissing", baseEntity) == null)
		{
			BaseCombatEntity baseCombatEntity = baseEntity as BaseCombatEntity;
			if (baseCombatEntity != null)
			{
				baseCombatEntity.Die();
			}
			else
			{
				baseEntity.Kill(BaseNetworkable.DestroyMode.Gib);
			}
		}
	}

```

## OnNpcDestinationSet(NPCPlayerApex,UnityEngine.Vector3)

```csharp
```csharp
/// <summary>
/// Called when an NPC's destination is set.
/// </summary>
/// <param name="npc">The NPC whose destination is being set.</param>
/// <param name="newDestination">The new destination for the NPC.</param>
/// <returns>
/// Returns `null` to allow the NPC's destination to be set, or any non-null value to prevent it from being set.
/// </returns>
object OnNpcDestinationSet(NPCPlayerApex npc, Vector3 newDestination)
{
    Puts($"NPC {npc.name} is being moved to destination: {newDestination}");
    if (newDestination == Vector3.zero)
    {
        Puts($"NPC {npc.name} cannot be moved to the origin.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public override void SetDestination(Vector3 newDestination)
	{
		if (Interface.CallHook("OnNpcDestinationSet", this, newDestination) == null)
		{
			base.SetDestination(newDestination);
			Destination = newDestination;
		}
	}

```

## CanHelicopterStrafeTarget(PatrolHelicopterAI,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can be targeted for helicopter strafing.
/// </summary>
/// <param name="ai">The PatrolHelicopterAI instance.</param>
/// <param name="target">The potential target player.</param>
/// <returns>
/// Returns `true` if the player can be targeted, and `false` otherwise.
/// If a non-bool value is returned, it will be treated as `true`.
/// </returns>
object CanHelicopterStrafeTarget(PatrolHelicopterAI ai, BasePlayer target)
{
    Puts($"Checking if {target.displayName} can be targeted for helicopter strafing.");
    if (target.IsAdmin())
    {
        Puts($"Cannot target admin {target.displayName} for helicopter strafing.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public bool ValidStrafeTarget(BasePlayer ply)
	{
		object obj = Interface.CallHook("CanHelicopterStrafeTarget", this, ply);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return !ply.IsNearEnemyBase();
	}

```

## InitLogging()

```csharp
```csharp
/// <summary>
/// Called to initialize logging.
/// </summary>
void InitLogging()
{
    Puts("Initializing logging...");
    // Minimal code to demonstrate functionality
}
```
```

### Source Code from the Library

```csharp

	private void StartupShared()
	{
		Interface.CallHook("InitLogging");
		ItemManager.Initialize();
	}

```

## OnSignLocked(Signage,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a sign is locked by a player.
/// </summary>
/// <param name="sign">The sign that was locked.</param>
/// <param name="player">The player who locked the sign.</param>
/// <returns>No return behavior.</returns>
void OnSignLocked(Signage sign, BasePlayer player)
{
    Puts($"Sign {sign.EntityID} has been locked by player {player.UserIDString}");
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	public void LockSign(RPCMessage msg)
	{
		if (msg.player.CanInteract() && CanUpdateSign(msg.player))
		{
			SetFlag(Flags.Locked, b: true);
			SendNetworkUpdate();
			base.OwnerID = msg.player.userID;
			Interface.CallHook("OnSignLocked", this, msg.player);
		}
	}

```

## OnHelicopterDropDoorOpen(CH47HelicopterAIController)

```csharp
```csharp
/// <summary>
/// Called when the helicopter's drop door is opened or closed.
/// </summary>
/// <param name="controller">The AI controller of the CH-47 helicopter.</param>
/// <returns>No return behavior.</returns>
void OnHelicopterDropDoorOpen(CH47HelicopterAIController controller)
{
    Puts($"Drop door on {controller.GetDisplayName()} is {(GetFlag(Flags.Reserved8)) ? "open" : "closed"}}");
}
```
```

### Source Code from the Library

```csharp

	public void SetDropDoorOpen(bool open)
	{
		if (Interface.CallHook("OnHelicopterDropDoorOpen", this) == null)
		{
			SetFlag(Flags.Reserved8, open);
		}
	}

```

## OnPlayerLootEnd(PlayerLoot)

```csharp
```csharp
/// <summary>
/// Called when a player's looting session ends.
/// </summary>
/// <param name="playerLoot">The PlayerLoot object associated with the ended looting session.</param>
/// <returns>No return behavior.</returns>
void OnPlayerLootEnd(PlayerLoot playerLoot)
{
    Puts($"Player {playerLoot.Player.UserIDString} has finished looting.");
    // Additional logic can be added here if needed
}
```
```

### Source Code from the Library

```csharp

	public void Clear()
	{
		if (!IsLooting())
		{
			return;
		}
		Interface.CallHook("OnPlayerLootEnd", this);
		MarkDirty();
		if ((bool)entitySource)
		{
			entitySource.SendMessage("PlayerStoppedLooting", base.baseEntity, SendMessageOptions.DontRequireReceiver);
		}
		foreach (ItemContainer container in containers)
		{
			if (container != null)
			{
				container.onDirty -= MarkDirty;
			}
		}
		containers.Clear();
		entitySource = null;
		itemSource = null;
	}

```

## CanUpdateSign(BasePlayer,Signage)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can update a sign.
/// </summary>
/// <param name="player">The player attempting to update the sign.</param>
/// <param name="signage">The signage being updated (not used in this implementation).</param>
/// <returns>
/// Returns `true` if the player is allowed to update the sign, or `false` otherwise.
/// If a non-null value other than `bool` is returned, it will be treated as `false`.
/// </returns>
object CanUpdateSign(BasePlayer player, Signage signage)
{
    Puts($"Checking if {player.UserIDString} can update the sign.");
    if (signage.IsLocked && player.userID != signage.OwnerID)
    {
        return false;
    }
    if (!player.CanBuild())
    {
        return false;
    }
    if (player.IsAdmin || player.IsDeveloper)
    {
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual bool CanUpdateSign(BasePlayer player)
	{
		object obj = Interface.CallHook("CanUpdateSign", player, this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (player.IsAdmin || player.IsDeveloper)
		{
			return true;
		}
		if (!player.CanBuild())
		{
			return false;
		}
		if (IsLocked())
		{
			return player.userID == base.OwnerID;
		}
		return true;
	}

```

## CanUseMailbox(BasePlayer,Mailbox)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can use the mailbox.
/// </summary>
/// <param name="player">The player attempting to use the mailbox.</param>
/// <param name="mailbox">The mailbox being accessed.</param>
/// <returns>
/// Returns `true` if the player is allowed to use the mailbox, or `false` otherwise.
/// If a non-bool value is returned, it will be treated as `false`.
/// </returns>
object CanUseMailbox(BasePlayer player, Mailbox mailbox)
{
    Puts($"Player {player.UserIDString} attempting to access mailbox {mailbox.name}");
    if (player.IsAdmin())
    {
        return true;
    }
    else
    {
        return false;
    }
}
```
```

### Source Code from the Library

```csharp

	public virtual bool PlayerIsOwner(BasePlayer player)
	{
		object obj = Interface.CallHook("CanUseMailbox", player, this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return player.CanBuild();
	}

```

## OnEntityLeave(TriggerBase,BaseEntity)

```csharp
```csharp
/// <summary>
/// Called when an entity leaves the trigger.
/// </summary>
/// <param name="trigger">The trigger that the entity left.</param>
/// <param name="entity">The entity that left the trigger.</param>
/// <returns>No return behavior.</returns>
void OnEntityLeave(TriggerBase trigger, BaseEntity entity)
{
    Puts($"Entity {entity.ClassName} has left trigger {trigger.EntityId}");
}
```
```

### Source Code from the Library

```csharp

	public virtual void OnEntityLeave(BaseEntity ent)
	{
		if (entityContents != null && Interface.CallHook("OnEntityLeave", this, ent) == null)
		{
			entityContents.Remove(ent);
		}
	}

```

## CanUseLockedEntity(BasePlayer,KeyLock)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can use a locked entity.
/// </summary>
/// <param name="player">The player attempting to use the locked entity.</param>
/// <param name="lock">The lock on the entity, which could be a key or other type of lock.</param>
/// <returns>
/// Returns `true` if the player can use the locked entity, and `false` otherwise.
/// If `null` is returned, the default behavior will be used (i.e., the player cannot use the locked entity unless they have permission).
/// </returns>
bool CanUseLockedEntity(BasePlayer player, KeyLock lock)
{
    Puts($"Player {player.UserIDString} attempted to use locked entity with key {lock.KeyID}");
    if (lock.IsMasterKey())
    {
        return true;
    }
    // Check if the player has permission to use the locked entity
    if (HasPermission(player, Permission.UseLockedEntity))
    {
        return true;
    }
    return false;
}
```
```

### Source Code from the Library

```csharp

	public override bool OnTryToOpen(BasePlayer player)
	{
		object obj = Interface.CallHook("CanUseLockedEntity", player, this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (HasLockPermission(player))
		{
			return true;
		}
		return !IsLocked();
	}

```

## OnItemAddedToContainer(ItemContainer,Item)

```csharp
```csharp
/// <summary>
/// Called when an item is added to a container.
/// </summary>
/// <param name="container">The container that the item was added to.</param>
/// <param name="item">The item that was added to the container.</param>
/// <returns>No return behavior.</returns>
void OnItemAddedToContainer(ItemContainer container, Item item)
{
    Puts($"Item {item.Name} has been added to container {container.Name}");
}
```
```

### Source Code from the Library

```csharp

	public bool Insert(Item item)
	{
		if (itemList.Contains(item))
		{
			return false;
		}
		if (IsFull())
		{
			return false;
		}
		itemList.Add(item);
		item.parent = this;
		if (!FindPosition(item))
		{
			return false;
		}
		MarkDirty();
		if (onItemAddedRemoved != null)
		{
			onItemAddedRemoved(item, arg2: true);
		}
		Interface.CallHook("OnItemAddedToContainer", this, item);
		return true;
	}

```

## CanAffordToPlace(BasePlayer,Planner,Construction)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can afford to place a construction.
/// </summary>
/// <param name="player">The player attempting to place the construction.</param>
/// <param name="component">The construction being placed.</param>
/// <returns>
/// Returns `true` if the player can afford to place the construction, or `false` otherwise.
/// If a non-bool value is returned, it will be used as the result of this method.
/// </returns>
object CanAffordToPlace(BasePlayer player, Planner planner, Construction component)
{
    Puts($"Checking if {player.UserIDString} can afford to place {component.name}");
    // Check if the player has enough funds
    if (player.inventory.GetAmount(component.defaultGrade.costToBuild.itemDef) < component.defaultGrade.costToBuild.amount)
    {
        return false;
    }
    
    // If no custom hook is provided, default to checking the player's inventory
    foreach (ItemAmount item in component.defaultGrade.costToBuild)
    {
        if ((float)player.inventory.GetAmount(item.itemDef.itemid) < item.amount)
        {
            return false;
        }
    }
    
    return true;
}
```
```

### Source Code from the Library

```csharp

	public bool CanAffordToPlace(Construction component)
	{
		if (isTypeDeployable)
		{
			return true;
		}
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if (!ownerPlayer)
		{
			return false;
		}
		object obj = Interface.CallHook("CanAffordToPlace", ownerPlayer, this, component);
		if (obj is bool)
		{
			return (bool)obj;
		}
		foreach (ItemAmount item in component.defaultGrade.costToBuild)
		{
			if ((float)ownerPlayer.inventory.GetAmount(item.itemDef.itemid) < item.amount)
			{
				return false;
			}
		}
		return true;
	}

```

## OnDieselEngineToggle(BasePlayer,DieselEngine)

```csharp
```csharp
/// <summary>
/// Called when the diesel engine is toggled on or off.
/// </summary>
/// <param name="player">The player who toggled the engine.</param>
/// <param name="engine">The diesel engine being toggled.</param>
/// <returns>
/// Returns `null` to allow the engine to be toggled, or any non-null value to prevent it from being toggled.
/// </returns>
object OnDieselEngineToggle(BasePlayer player, DieselEngine engine)
{
    Puts($"Player {player.UserIDString} toggled diesel engine {engine.EngineName}");
    if (engine.IsBroken())
    {
        Puts($"Player {player.displayName} cannot toggle broken engine {engine.EngineName}");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	public void EngineSwitch(RPCMessage msg)
	{
		if (Interface.CallHook("OnDieselEngineToggle", msg.player, this) != null)
		{
			return;
		}
		if (msg.read.Bit())
		{
			if (GetFuelAmount() > 0)
			{
				EngineOn();
			}
		}
		else
		{
			EngineOff();
		}
	}

```

## OnFireBallSpread(FireBall,BaseEntity)

```csharp
```csharp
/// <summary>
/// Called when a fireball spreads.
/// </summary>
/// <param name="fireBall">The fireball entity.</param>
/// <param name="newFireBall">The new fireball entity that was spawned.</param>
/// <returns>No return behavior.</returns>
void OnFireBallSpread(FireBall fireBall, BaseEntity newFireBall)
{
    Puts($"Fireball {fireBall.EntityID} has spread to create a new fireball at position: {newFireBall.transform.position}");
    if (newFireBall.EntityID == 12345)
    {
        Puts($"New fireball {newFireBall.EntityID} has been blocked from spreading.");
        return;
    }
    // Additional logic can be added here
}
```
```

### Source Code from the Library

```csharp

	public void TryToSpread()
	{
		float num = 0.9f - generation * 0.1f;
		if (UnityEngine.Random.Range(0f, 1f) < num && spreadSubEntity.isValid)
		{
			BaseEntity baseEntity = GameManager.server.CreateEntity(spreadSubEntity.resourcePath);
			if ((bool)baseEntity)
			{
				baseEntity.transform.position = base.transform.position + Vector3.up * 0.25f;
				baseEntity.Spawn();
				Vector3 modifiedAimConeDirection = AimConeUtil.GetModifiedAimConeDirection(45f, Vector3.up);
				baseEntity.creatorEntity = ((creatorEntity == null) ? baseEntity : creatorEntity);
				Interface.CallHook("OnFireBallSpread", this, baseEntity);
				baseEntity.SetVelocity(modifiedAimConeDirection * UnityEngine.Random.Range(5f, 8f));
				baseEntity.SendMessage("SetGeneration", generation + 1f);
			}
		}
	}

```

## CanLock(BasePlayer,CodeLock)

```csharp
```csharp
/// <summary>
/// Called when a player tries to lock the code lock.
/// </summary>
/// <param name="player">The player trying to lock the code lock.</param>
/// <param name="codeLock">The code lock being locked.</param>
/// <returns>
/// Returns `null` to allow the player to lock the code lock, or any non-null value to prevent them from locking it.
/// </returns>
object CanLock(BasePlayer player, CodeLock codeLock)
{
    Puts($"Player {player.UserIDString} tried to lock the code lock.");
    if (codeLock.IsLocked())
    {
        Puts($"Code lock is already locked by another player.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	private void TryLock(RPCMessage rpc)
	{
		if (rpc.player.CanInteract() && !IsLocked() && code.Length == 4 && Interface.CallHook("CanLock", rpc.player, this) == null && whitelistPlayers.Contains(rpc.player.userID))
		{
			DoEffect(effectLocked.resourcePath);
			SetFlag(Flags.Locked, b: true);
			SendNetworkUpdate();
		}
	}

```

## OnMaxStackable(Item)

```csharp
```csharp
/// <summary>
/// Called to determine the maximum stackable quantity of an item.
/// </summary>
/// <param name="item">The item being checked.</param>
/// <returns>
/// Returns a non-negative integer representing the maximum stackable quantity. 
/// If `null` is returned, the default maximum stackable quantity will be used.
/// </returns>
object OnMaxStackable(Item item)
{
    Puts($"Checking max stackable for item {item.name}...");
    if (item.category == "Rare")
    {
        Puts($"Item {item.name} has a custom max stackable of 10.");
        return 10;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public int MaxStackable()
	{
		int num = info.stackable;
		if (parent != null && parent.maxStackSize > 0)
		{
			num = Mathf.Min(parent.maxStackSize, num);
		}
		object obj = Interface.CallHook("OnMaxStackable", this);
		if (obj is int)
		{
			return (int)obj;
		}
		return num;
	}

```

## OnNpcTarget(Rust.Ai.HTN.BaseNpcMemory,BaseNpc)

```csharp
```csharp
/// <summary>
/// Called when an NPC targets a specific entity.
/// </summary>
/// <param name="npcMemory">The memory of the NPC that is targeting.</param>
/// <param name="baseNpc">The base NPC instance that is doing the targeting.</param>
/// <returns>
/// Returns `null` to allow the NPC to target the entity, or any non-null value to prevent them from targeting it.
/// </returns>
object OnNpcTarget(Rust.Ai.HTN.BaseNpcMemory npcMemory, BaseNpc baseNpc)
{
    Puts($"NPC {baseNpc.Name} is targeting an entity.");
    if (npcMemory.GetEntity().IsPlayer && baseNpc.IsHostileToPlayers)
    {
        Puts($"NPC {baseNpc.Name} is hostile to players and will attack the target.");
        return null;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void RememberPrimaryAnimal(BaseNpc animal)
	{
		if (Interface.CallHook("OnNpcTarget", this, animal) != null)
		{
			return;
		}
		for (int i = 0; i < NpcContext.AnimalsInRange.Count; i++)
		{
			AnimalInfo primaryKnownAnimal = NpcContext.AnimalsInRange[i];
			if (primaryKnownAnimal.Animal == animal)
			{
				PrimaryKnownAnimal = primaryKnownAnimal;
				break;
			}
		}
	}

```

## OnLootEntityEnd(BasePlayer,DroppedItemContainer)

```csharp
```csharp
/// <summary>
/// Called when a player stops looting an entity.
/// </summary>
/// <param name="player">The player who stopped looting.</param>
/// <param name="container">The container that was being looted.</param>
/// <returns>No return behavior.</returns>
void OnLootEntityEnd(BasePlayer player, DroppedItemContainer container)
{
    Puts($"Player {player.UserIDString} has finished looting the entity.");
    if (container.itemList.Count > 0 && container.itemList[0].item.name == "GoldenApple")
    {
        Puts($"Player {player.displayName} found a Golden Apple!");
    }
}
```
```

### Source Code from the Library

```csharp

	public void PlayerStoppedLooting(BasePlayer player)
	{
		Interface.CallHook("OnLootEntityEnd", player, this);
		if (inventory == null || inventory.itemList == null || inventory.itemList.Count == 0)
		{
			Kill();
			return;
		}
		ResetRemovalTime();
		SetFlag(Flags.Open, b: false);
		SendNetworkUpdate();
	}

```

## CanNetworkTo(BasePlayer,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called to determine if the server should network with a given player.
/// </summary>
/// <param name="player">The player in question.</param>
/// <returns>
/// Returns `true` if the server should network with the player, and `false` otherwise.
/// If this method returns `null`, the default behavior will be used.
/// </returns>
bool CanNetworkTo(BasePlayer player)
{
    Puts($"Checking if server should network with player {player.UserIDString}");
    if (player.IsModerator())
    {
        return true;
    }
    object obj = Interface.CallHook("CanNetworkTo", this, player);
    if (obj is bool)
    {
        return (bool)obj;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public override bool ShouldNetworkTo(BasePlayer player)
	{
		object obj = Interface.CallHook("CanNetworkTo", this, player);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (IsSpectating() && player != this && !player.net.connection.info.GetBool("global.specnet"))
		{
			return false;
		}
		return base.ShouldNetworkTo(player);
	}

```

## OnEntityEnter(TriggerBase,BaseEntity)

```csharp
```csharp
/// <summary>
/// Called when an entity enters the trigger.
/// </summary>
/// <param name="trigger">The trigger that was entered.</param>
/// <param name="entity">The entity that entered the trigger.</param>
/// <returns>
/// Returns `null` to allow the entity to enter the trigger, or any non-null value to prevent them from entering.
/// </returns>
object OnEntityEnter(TriggerBase trigger, BaseEntity entity)
{
    Puts($"Entity {entity.UserIDString} has entered trigger {trigger.name}");
    if (entity is Player player && player.IsSpectating())
    {
        Puts($"Player {player.displayName} is spectating and cannot enter trigger {trigger.name}");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual void OnEntityEnter(BaseEntity ent)
	{
		if (!(ent == null))
		{
			if (entityContents == null)
			{
				entityContents = new HashSet<BaseEntity>();
			}
			if (Interface.CallHook("OnEntityEnter", this, ent) == null)
			{
				entityContents.Add(ent);
			}
		}
	}

```

## OnTeamAcceptInvite(RelationshipManager.PlayerTeam,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a team accepts an invite from a player.
/// </summary>
/// <param name="team">The team accepting the invite.</param>
/// <param name="player">The player sending the invite.</param>
/// <returns>
/// Returns `null` to allow the team to accept the invite, or any non-null value to prevent them from accepting the invite.
/// </returns>
object OnTeamAcceptInvite(PlayerTeam team, BasePlayer player)
{
    Puts($"Team {team.Name} has accepted an invite from player {player.UserIDString}");
    if (team.Members.Count >= 5)
    {
        Puts($"Team {team.Name} is full and cannot accept any more invites.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[ServerUserVar]
	public static void acceptinvite(ConsoleSystem.Arg arg)
	{
		BasePlayer basePlayer = ArgEx.Player(arg);
		if (!(basePlayer == null) && basePlayer.currentTeam == 0L)
		{
			ulong uLong = arg.GetULong(0, 0uL);
			PlayerTeam playerTeam = Instance.FindTeam(uLong);
			if (playerTeam == null)
			{
				basePlayer.ClearPendingInvite();
			}
			else if (Interface.CallHook("OnTeamAcceptInvite", playerTeam, basePlayer) == null)
			{
				playerTeam.AcceptInvite(basePlayer);
			}
		}
	}

```

## OnAddVendingOffer(VendingMachine,ProtoBuf.VendingMachine.SellOrder)

```csharp
```csharp
/// <summary>
/// Called when a new vending offer is added.
/// </summary>
/// <param name="vendingMachine">The vending machine that the offer was added to.</param>
/// <param name="sellOrder">The details of the sell order being added.</param>
object OnAddVendingOffer(VendingMachine vendingMachine, ProtoBuf.VendingMachine.SellOrder sellOrder)
{
    Puts($"Sell order added to vending machine {vendingMachine.name} for item ID {sellOrder.itemToSellID} and currency ID {sellOrder.currencyID}");
    if (sellOrder.itemToSellID == 123 && sellOrder.currencyID == 456)
    {
        Puts($"Sell order for item ID {sellOrder.itemToSellID} and currency ID {sellOrder.currencyID} has been blocked.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void AddSellOrder(int itemToSellID, int itemToSellAmount, int currencyToUseID, int currencyAmount, byte bpState)
	{
		ItemDefinition itemDefinition = ItemManager.FindItemDefinition(itemToSellID);
		ItemDefinition itemDefinition2 = ItemManager.FindItemDefinition(currencyToUseID);
		if (!(itemDefinition == null) && !(itemDefinition2 == null))
		{
			currencyAmount = Mathf.Clamp(currencyAmount, 1, 10000);
			itemToSellAmount = Mathf.Clamp(itemToSellAmount, 1, itemDefinition.stackable);
			ProtoBuf.VendingMachine.SellOrder sellOrder = new ProtoBuf.VendingMachine.SellOrder();
			sellOrder.ShouldPool = false;
			sellOrder.itemToSellID = itemToSellID;
			sellOrder.itemToSellAmount = itemToSellAmount;
			sellOrder.currencyID = currencyToUseID;
			sellOrder.currencyAmountPerItem = currencyAmount;
			sellOrder.currencyIsBP = bpState == 3 || bpState == 2;
			sellOrder.itemToSellIsBP = bpState == 3 || bpState == 1;
			Interface.CallHook("OnAddVendingOffer", this, sellOrder);
			sellOrders.sellOrders.Add(sellOrder);
			RefreshSellOrderStockLevel(itemDefinition);
			UpdateMapMarker();
			SendNetworkUpdate();
		}
	}

```

## OnItemRefill(Item,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when an item is refilled.
/// </summary>
/// <param name="item">The item being refilled.</param>
/// <param name="player">The player who initiated the refill.</param>
/// <returns>
/// Returns `null` to allow the item to be refilled, or any non-null value to prevent the item from being refilled.
/// </returns>
object OnItemRefill(Item item, BasePlayer player)
{
    Puts($"Item {item.info.name} has been refilled for player {player.displayName}");
    if (item.info.category == "explosive")
    {
        Puts($"Item {item.info.name} is an explosive and cannot be refilled.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public override void ServerCommand(Item item, string command, BasePlayer player)
	{
		if (command == "refill" && !player.IsSwimming() && HasCraftLevel(player) && !(item.conditionNormalized >= 1f) && Interface.CallHook("OnItemRefill", item, player) == null)
		{
			item.DoRepair(conditionLost);
			if (successEffect.isValid)
			{
				Effect.server.Run(successEffect.resourcePath, player.eyes.position);
			}
		}
	}

```

## OnNpcResume(NPCPlayerApex)

```csharp
```csharp
/// <summary>
/// Called when an NPC resumes its activities.
/// </summary>
/// <param name="npc">The NPC resuming its activities.</param>
/// <returns>
/// Returns `null` to allow the NPC to resume as normal, or any non-null value to override the default behavior.
/// If a string is returned, it will be used as a message for the NPC's radio chatter.
/// </returns>
object OnNpcResume(NPCPlayerApex npc)
{
    Puts($"NPC {npc.EntityId} has resumed its activities.");
    if (npc.GetNavAgent.isOnNavMesh)
    {
        // Do nothing, NPC is already on nav mesh
        return null;
    }
    else if (Interface.CallHook("OnNpcResume", npc) != null)
    {
        // Hook returned a non-null value, use it as the radio chatter message
        return Interface.CallHook("OnNpcResume", npc);
    }
    else
    {
        // Try to force the NPC onto the nav mesh
        StartCoroutine(npc.TryForceToNavmesh());
        return null;
    }
}
```
```

### Source Code from the Library

```csharp

	public override void Resume()
	{
		if (base.isMounted)
		{
			if (utilityAiComponent == null)
			{
				utilityAiComponent = Entity.GetComponent<UtilityAIComponent>();
			}
			if (utilityAiComponent != null)
			{
				utilityAiComponent.enabled = true;
				utilityAiComponent.Resume();
			}
			SendNetworkUpdateImmediate();
			return;
		}
		if (!GetNavAgent.isOnNavMesh)
		{
			if (Interface.CallHook("OnNpcResume", this) == null)
			{
				StartCoroutine(TryForceToNavmesh());
			}
			return;
		}
		GetNavAgent.enabled = true;
		StoppingDistance = 1f;
		if (utilityAiComponent == null)
		{
			utilityAiComponent = Entity.GetComponent<UtilityAIComponent>();
		}
		if (utilityAiComponent != null)
		{
			utilityAiComponent.enabled = true;
			utilityAiComponent.Resume();
		}
		InvokeRandomized(RadioChatter, RadioEffectRepeatRange.x, RadioEffectRepeatRange.x, RadioEffectRepeatRange.y - RadioEffectRepeatRange.x);
	}

```

## OnPlayerSpectateEnd(BasePlayer,string)

```csharp
```csharp
/// <summary>
/// Called when a player ends spectating.
/// </summary>
/// <param name="player">The player ending spectation.</param>
/// <param name="filter">The filter used for spectating, which could be a player name or other identifier.</param>
/// <returns>
/// Returns `null` to allow the player to end spectating normally. 
/// If any non-null value is returned, it will override the default behavior and prevent the player from ending spectation.
/// </returns>
object OnPlayerSpectateEnd(BasePlayer player, string filter)
{
    Puts($"Player {player.UserIDString} ended spectating with filter: {filter}");
    if (filter == "restricted")
    {
        Puts($"Player {player.displayName} is not allowed to end spectation with filter: {filter}");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void StopSpectating()
	{
		if (IsSpectating() && Interface.CallHook("OnPlayerSpectateEnd", this, spectateFilter) == null)
		{
			SetParent(null);
			SetPlayerFlag(PlayerFlags.Spectating, b: false);
			UnityEngine.TransformEx.SetLayerRecursive(base.gameObject, 17);
		}
	}

```

## CanUnlock(BasePlayer,CodeLock)

```csharp
```csharp
/// <summary>
/// Called when a player tries to unlock the object.
/// </summary>
/// <param name="player">The player trying to unlock.</param>
/// <param name="lock">The lock being unlocked.</param>
/// <returns>
/// Returns `null` to allow the player to unlock, or any non-null value to prevent them from unlocking.
/// If a string is returned, the player will be notified with the provided message as the reason.
/// </returns>
object CanUnlock(BasePlayer player, CodeLock lock)
{
    Puts($"Player {player.UserIDString} tried to unlock {lock.name}");
    if (player.userID == 1234567890)
    {
        Puts($"Player {player.displayName} is not allowed to unlock");
        return "Access denied: Unauthorized user";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	private void TryUnlock(RPCMessage rpc)
	{
		if (rpc.player.CanInteract() && IsLocked() && Interface.CallHook("CanUnlock", rpc.player, this) == null)
		{
			if (whitelistPlayers.Contains(rpc.player.userID))
			{
				DoEffect(effectUnlocked.resourcePath);
				SetFlag(Flags.Locked, b: false);
				SendNetworkUpdate();
			}
			else
			{
				ClientRPCPlayer(null, rpc.player, "EnterUnlockCode");
			}
		}
	}

```

## OnTrapArm(BearTrap,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a bear trap is armed.
/// </summary>
/// <param name="trap">The bear trap being armed.</param>
/// <param name="player">The player who triggered the trap.</param>
/// <returns>
/// Returns `null` to allow the trap to be armed, or any non-null value to prevent it from arming.
/// </returns>
object OnTrapArm(BearTrap trap, BasePlayer player)
{
    Puts($"Bear trap {trap.name} has been armed by player {player.displayName}");
    if (player.IsAdmin())
    {
        Puts($"Player {player.displayName} is an admin and cannot trigger traps.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	private void RPC_Arm(RPCMessage rpc)
	{
		if (!Armed() && Interface.CallHook("OnTrapArm", this, rpc.player) == null)
		{
			Arm();
		}
	}

```

## CanAdministerVending(BasePlayer,VendingMachine)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can administer a vending machine.
/// </summary>
/// <param name="player">The player attempting to administer the vending machine.</param>
/// <param name="vendingMachine">The vending machine being administered.</param>
/// <returns>
/// Returns `true` if the player can administer the vending machine, and `false` otherwise.
/// If a non-bool value is returned, it will be treated as `false`.
/// </returns>
object CanAdministerVending(BasePlayer player, VendingMachine vendingMachine)
{
    Puts($"Player {player.UserIDString} attempting to administer vending machine {vendingMachine.name}");
    if (player.IsAdmin())
    {
        return true;
    }
    else if (player.HasPermission("can_admin_vending"))
    {
        return true;
    }
    else
    {
        return false;
    }
}
```
```

### Source Code from the Library

```csharp

	public virtual bool CanPlayerAdmin(BasePlayer player)
	{
		object obj = Interface.CallHook("CanAdministerVending", player, this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (PlayerBehind(player))
		{
			return OccupiedCheck(player);
		}
		return false;
	}

```

## IOnLoseCondition(Item,float)

```csharp
```csharp
/// <summary>
/// Called when a item loses condition.
/// </summary>
/// <param name="item">The item losing condition.</param>
/// <param name="amount">The amount of condition lost.</param>
/// <returns>
/// Returns `null` to allow the item to lose condition, or any non-null value to prevent it from losing condition.
/// If a string is returned, the item will be destroyed with the provided message as the reason.
/// </returns>
object IOnLoseCondition(Item item, float amount)
{
    Puts($"Item {item.info.shortname} lost {amount} condition.");
    if (amount > 0.5f)
    {
        Puts($"Item {item.info.shortname} has been severely damaged.");
        return "Destroyed: Severe damage.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void LoseCondition(float amount)
	{
		if (hasCondition && !Debugging.disablecondition && Interface.CallHook("IOnLoseCondition", this, amount) == null)
		{
			float num = condition;
			condition -= amount;
			if (ConVar.Global.developer > 0)
			{
				Debug.Log(info.shortname + " was damaged by: " + amount + "cond is: " + condition + "/" + maxCondition);
			}
			if (condition <= 0f && condition < num)
			{
				OnBroken();
			}
		}
	}

```

## OnTrapDisarm(Landmine,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player attempts to disarm a trap.
/// </summary>
/// <param name="landmine">The landmine being disarmed.</param>
/// <param name="player">The player attempting to disarm the landmine.</param>
/// <returns>
/// Returns `null` to allow the player to disarm the landmine, or any non-null value to prevent them from disarming it.
/// </returns>
object OnTrapDisarm(Landmine landmine, BasePlayer player)
{
    Puts($"Player {player.UserIDString} attempted to disarm landmine at position {landmine.transform.position}");
    if (player.HasFlag(Flags.Admin))
    {
        Puts($"Player {player.displayName} is an admin and cannot be prevented from disarming the landmine.");
        return null;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	private void RPC_Disarm(RPCMessage rpc)
	{
		if (rpc.player.net.ID != triggerPlayerID && Armed() && Interface.CallHook("OnTrapDisarm", this, rpc.player) == null)
		{
			SetFlag(Flags.On, b: false);
			if (UnityEngine.Random.Range(0, 100) < 15)
			{
				Invoke(TryExplode, 0.05f);
				return;
			}
			rpc.player.GiveItem(ItemManager.CreateByName("trap.landmine", 1, 0uL), GiveItemReason.PickedUp);
			Kill();
		}
	}

```

## OnNpcTarget(BaseEntity,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when an NPC targets a player.
/// </summary>
/// <param name="npc">The NPC that is targeting the player.</param>
/// <param name="player">The player being targeted by the NPC.</param>
/// <returns>
/// Returns `true` to override the default behavior and prevent the NPC from remembering the player as an enemy. 
/// If `null` or `false` is returned, the NPC will remember the player as an enemy.
/// </returns>
bool OnNpcTarget(BaseEntity npc, BasePlayer player)
{
    Puts($"NPC {npc} has targeted player {player}");
    // Add custom logic here to determine whether the NPC should remember the player
    return true; // or false, depending on your implementation
}
```
```

### Source Code from the Library

```csharp

	public void RememberEnemyPlayer(IHTNAgent npc, ref NpcPlayerInfo info, float time, float uncertainty = 0f, string debugStr = "ENEMY!")
	{
		if (info.Player == null || info.Player.transform == null || info.Player.IsDestroyed || info.Player.IsDead() || info.Player.IsWounded() || Interface.CallHook("OnNpcTarget", npc.Body, info.Player) != null)
		{
			return;
		}
		if (Mathf.Approximately(info.SqrDistance, 0f))
		{
			info.SqrDistance = (npc.BodyPosition - info.Player.transform.position).sqrMagnitude;
		}
		for (int i = 0; i < KnownEnemyPlayers.Count; i++)
		{
			EnemyPlayerInfo enemyPlayerInfo = KnownEnemyPlayers[i];
			if (enemyPlayerInfo.PlayerInfo.Player == info.Player)
			{
				enemyPlayerInfo.PlayerInfo = info;
				if (uncertainty < 0.05f)
				{
					enemyPlayerInfo.LastKnownLocalPosition = info.Player.transform.localPosition;
					enemyPlayerInfo.LastKnownLocalHeading = info.Player.GetLocalVelocity().normalized;
					enemyPlayerInfo.OurLastLocalPositionWhenLastSeen = npc.transform.localPosition;
					enemyPlayerInfo.BodyVisibleWhenLastNoticed = info.BodyVisible;
					enemyPlayerInfo.HeadVisibleWhenLastNoticed = info.HeadVisible;
				}
				else
				{
					Vector2 vector = UnityEngine.Random.insideUnitCircle * uncertainty;
					enemyPlayerInfo.LastKnownLocalPosition = info.Player.transform.localPosition + new Vector3(vector.x, 0f, vector.y);
					enemyPlayerInfo.LastKnownLocalHeading = (enemyPlayerInfo.LastKnownPosition - NpcContext.BodyPosition).normalized;
					enemyPlayerInfo.BodyVisibleWhenLastNoticed = info.BodyVisible;
					enemyPlayerInfo.HeadVisibleWhenLastNoticed = info.HeadVisible;
				}
				enemyPlayerInfo.Time = time;
				KnownEnemyPlayers[i] = enemyPlayerInfo;
				if (PrimaryKnownEnemyPlayer.PlayerInfo.Player == info.Player)
				{
					PrimaryKnownEnemyPlayer = enemyPlayerInfo;
				}
				return;
			}
		}
		KnownEnemyPlayers.Add(new EnemyPlayerInfo
		{
			PlayerInfo = info,
			LastKnownLocalPosition = info.Player.transform.localPosition,
			Time = time
		});
	}

```

## OnCrateHackEnd(HackableLockedCrate)

```csharp
```csharp
/// <summary>
/// Called when a crate hack has ended.
/// </summary>
/// <param name="crate">The hacked crate.</param>
/// <returns>No return behavior.</returns>
void OnCrateHackEnd(HackableLockedCrate crate)
{
    Puts($"Crate hack on {crate.crateName} has ended.");
    if (crate.isLootable)
    {
        Puts($"Crate {crate.crateName} is now lootable.");
    }
    else
    {
        Puts($"Crate {crate.crateName} is not lootable.");
    }
}
```
```

### Source Code from the Library

```csharp

	public void HackProgress()
	{
		hackSeconds += 1f;
		if (hackSeconds > requiredHackSeconds)
		{
			Interface.CallHook("OnCrateHackEnd", this);
			RefreshDecay();
			SetFlag(Flags.Reserved2, b: true);
			isLootable = true;
			CancelInvoke(HackProgress);
		}
		ClientRPC(null, "UpdateHackProgress", (int)hackSeconds, (int)requiredHackSeconds);
	}

```

## OnShopCancelClick(ShopFront,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when the cancel button is clicked on a shop front.
/// </summary>
/// <param name="shopFront">The shop front where the cancel button was clicked.</param>
/// <param name="player">The player who clicked the cancel button.</param>
/// <returns>
/// Returns `null` to allow the trade to be cancelled, or any non-null value to prevent the trade from being cancelled.
/// </returns>
object OnShopCancelClick(ShopFront shopFront, BasePlayer player)
{
    Puts($"Player {player.UserIDString} clicked cancel on shop front {shopFront.name}");
    if (player.HasTag("admin"))
    {
        Puts($"Admin player {player.UserIDString} cannot be cancelled from trade.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	public void CancelClicked(RPCMessage msg)
	{
		if (IsTradingPlayer(msg.player) && Interface.CallHook("OnShopCancelClick", this, msg.player) == null)
		{
			_ = (bool)vendorPlayer;
			_ = (bool)customerPlayer;
			ResetTrade();
		}
	}

```

## OnLootEntityEnd(BasePlayer,LootableCorpse)

```csharp
```csharp
/// <summary>
/// Called when a player stops looting an entity.
/// </summary>
/// <param name="player">The player who stopped looting.</param>
/// <param name="lootableCorpse">The lootable corpse that was being looted.</param>
/// <returns>No return behavior.</returns>
void OnLootEntityEnd(BasePlayer player, LootableCorpse lootableCorpse)
{
    Puts($"Player {player.UserIDString} stopped looting {lootableCorpse.DisplayName}");
}
```
```

### Source Code from the Library

```csharp

	public void PlayerStoppedLooting(BasePlayer player)
	{
		Interface.CallHook("OnLootEntityEnd", player, this);
		ResetRemovalTime();
		SetFlag(Flags.Open, b: false);
		SendNetworkUpdate();
	}

```

## OnTeamInvite(BasePlayer,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player invites another player to join their team.
/// </summary>
/// <param name="inviter">The player inviting the other player.</param>
/// <param name="invitee">The player being invited.</param>
/// <returns>
/// Returns `null` to allow the invitation, or any non-null value to prevent the invitation.
/// </returns>
object OnTeamInvite(BasePlayer inviter, BasePlayer invitee)
{
    Puts($"Player {inviter.UserIDString} has invited player {invitee.UserIDString} to join their team.");
    if (invitee.currentTeam != 0L)
    {
        Puts($"Player {invitee.UserIDString} is already on a team and cannot be invited.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[ServerUserVar]
	public static void sendinvite(ConsoleSystem.Arg arg)
	{
		BasePlayer basePlayer = ArgEx.Player(arg);
		PlayerTeam playerTeam = Instance.FindTeam(basePlayer.currentTeam);
		if (playerTeam == null || playerTeam.GetLeader() == null || playerTeam.GetLeader() != basePlayer || !Physics.Raycast(basePlayer.eyes.position, basePlayer.eyes.HeadForward(), out var hitInfo, 5f, 1218652417, QueryTriggerInteraction.Ignore))
		{
			return;
		}
		BaseEntity entity = RaycastHitEx.GetEntity(hitInfo);
		if ((bool)entity)
		{
			BasePlayer component = entity.GetComponent<BasePlayer>();
			if ((bool)component && component != basePlayer && !component.IsNpc && component.currentTeam == 0L && Interface.CallHook("OnTeamInvite", basePlayer, component) == null)
			{
				playerTeam.SendInvite(component);
			}
		}
	}

```

## OnHelicopterOutOfCrates(CH47HelicopterAIController)

```csharp
```csharp
/// <summary>
/// Called when a helicopter runs out of crates.
/// </summary>
/// <param name="controller">The AI controller for the helicopter.</param>
/// <returns>
/// Returns `true` if the helicopter has run out of crates, and `false` otherwise.
/// If this method returns `null`, it will be assumed that the helicopter has run out of crates.
/// </returns>
bool OnHelicopterOutOfCrates(CH47HelicopterAIController controller)
{
    Puts("Helicopter is running low on crates!");
    if (controller.numCrates <= 0)
    {
        return true;
    }
    return false;
}
```
```

### Source Code from the Library

```csharp

	public bool OutOfCrates()
	{
		object obj = Interface.CallHook("OnHelicopterOutOfCrates", this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return numCrates <= 0;
	}

```

## CanSamSiteShoot(SamSite)

```csharp
```csharp
/// <summary>
/// Called to determine if the Sam Site can shoot.
/// </summary>
/// <param name="samSite">The Sam Site instance.</param>
/// <returns>
/// Returns `null` to allow the Sam Site to shoot, or any non-null value to prevent it from shooting.
/// </returns>
object CanSamSiteShoot(SamSite samSite)
{
    Puts($"Checking if Sam Site can shoot...");
    // Add custom logic here to determine if the Sam Site can shoot
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void WeaponTick()
	{
		if (IsDead() || Time.time < lockOnTime || Time.time < nextBurstTime)
		{
			return;
		}
		if (!IsPowered())
		{
			firedCount = 0;
			return;
		}
		if (firedCount >= 6)
		{
			nextBurstTime = Time.time + 5f;
			firedCount = 0;
			return;
		}
		EnsureReloaded();
		if (HasAmmo() && Interface.CallHook("CanSamSiteShoot", this) == null)
		{
			if (!staticRespawn && ammoItem != null)
			{
				ammoItem.UseItem();
			}
			firedCount++;
			FireProjectile(tubes[currentTubeIndex].position, currentAimDir, currentTarget);
			Effect.server.Run(muzzleFlashTest.resourcePath, this, StringPool.Get("Tube " + (currentTubeIndex + 1)), Vector3.zero, Vector3.up);
			currentTubeIndex++;
			if (currentTubeIndex >= tubes.Length)
			{
				currentTubeIndex = 0;
			}
		}
	}

```

## OnCrateHack(HackableLockedCrate)

```csharp
```csharp
/// <summary>
/// Called when a player attempts to hack a locked crate.
/// </summary>
/// <param name="crate">The hacked crate.</param>
/// <returns>
/// Returns `null` to allow the hacking process to proceed, or any non-null value to prevent the hacking attempt.
/// </returns>
object OnCrateHack(HackableLockedCrate crate)
{
    Puts($"Player attempted to hack crate {crate.crateName} with hack time: {crate.hackTime} seconds");
    if (crate.hackTime < 10f)
    {
        Puts($"Player's hacking attempt on crate {crate.crateName} was blocked due to insufficient hack time.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void StartHacking()
	{
		Interface.CallHook("OnCrateHack", this);
		BroadcastEntityMessage("HackingStarted", 20f, 256);
		SetFlag(Flags.Reserved1, b: true);
		InvokeRepeating(HackProgress, 1f, 1f);
		ClientRPC(null, "UpdateHackProgress", 0, (int)requiredHackSeconds);
		RefreshDecay();
	}

```

## OnTrapTrigger(BearTrap,UnityEngine.GameObject)

```csharp
```csharp
/// <summary>
/// Called when a trap is triggered.
/// </summary>
/// <param name="trap">The trap that was triggered.</param>
/// <param name="target">The object that entered the trap's trigger area.</param>
/// <returns>
/// Returns `null` to allow the trap to trigger normally, or any non-null value to prevent the trap from triggering.
/// </returns>
object OnTrapTrigger(BearTrap trap, GameObject target)
{
    Puts($"Trap triggered by {target.name} at position: {target.transform.position}");
    if (target.CompareTag("Player"))
    {
        Puts($"Player detected in trap area. Preventing trap trigger.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public override void ObjectEntered(GameObject obj)
	{
		if (Armed() && Interface.CallHook("OnTrapTrigger", this, obj) == null)
		{
			hurtTarget = obj;
			Invoke(DelayedFire, 0.05f);
		}
	}

```

## OnPlayerKeepAlive(BasePlayer,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player keeps another player alive.
/// </summary>
/// <param name="player">The player keeping the other player alive.</param>
/// <param name="targetPlayer">The player being kept alive.</param>
/// <returns>
/// Returns `null` to allow the keep-alive behavior, or any non-null value to prevent it.
/// </returns>
object OnPlayerKeepAlive(BasePlayer player, BasePlayer targetPlayer)
{
    Puts($"Player {player.UserIDString} is keeping {targetPlayer.UserIDString} alive.");
    if (targetPlayer.IsWounded())
    {
        ProlongWounding(targetPlayer, 10f);
        return null;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	public void RPC_KeepAlive(RPCMessage msg)
	{
		if (msg.player.CanInteract() && !(msg.player == this) && IsWounded() && Interface.CallHook("OnPlayerKeepAlive", this, msg.player) == null)
		{
			ProlongWounding(10f);
		}
	}

```

## OnItemCraftFinished(ItemCraftTask,Item)

```csharp
```csharp
/// <summary>
/// Called when an item crafting task is finished.
/// </summary>
/// <param name="task">The ItemCraftTask that was completed.</param>
/// <param name="item">The crafted item.</param>
object OnItemCraftFinished(ItemCraftTask task, Item item)
{
    Puts($"Item crafting task {task.taskUID} has been completed.");
    if (task.blueprint.targetItem.shortname == "crafting_test")
    {
        Puts($"Item crafting test has been completed with result {item.info.itemid}.");
        return item;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void FinishCrafting(ItemCraftTask task)
	{
		task.amount--;
		task.numCrafted++;
		ulong skin = ItemDefinition.FindSkin(task.blueprint.targetItem.itemid, task.skinID);
		Item item = ItemManager.CreateByItemID(task.blueprint.targetItem.itemid, 1, skin);
		item.amount = task.blueprint.amountToCreate;
		if (item.hasCondition && task.conditionScale != 1f)
		{
			item.maxCondition *= task.conditionScale;
			item.condition = item.maxCondition;
		}
		item.OnVirginSpawn();
		foreach (ItemAmount ingredient in task.blueprint.ingredients)
		{
			int num = (int)ingredient.amount;
			if (task.takenItems == null)
			{
				continue;
			}
			foreach (Item takenItem in task.takenItems)
			{
				if (takenItem.info == ingredient.itemDef)
				{
					int num2 = Mathf.Min(takenItem.amount, num);
					takenItem.UseItem(num);
					num -= num2;
				}
				_ = 0;
			}
		}
		Facepunch.Rust.Analytics.Crafting(task.blueprint.targetItem.shortname, task.skinID);
		task.owner.Command("note.craft_done", task.taskUID, 1, task.amount);
		Interface.CallHook("OnItemCraftFinished", task, item);
		if (task.instanceData != null)
		{
			item.instanceData = task.instanceData;
		}
		if (!string.IsNullOrEmpty(task.blueprint.UnlockAchievment))
		{
			task.owner.GiveAchievement(task.blueprint.UnlockAchievment);
		}
		if (task.owner.inventory.GiveItem(item))
		{
			task.owner.Command("note.inv", item.info.itemid, item.amount);
			return;
		}
		ItemContainer itemContainer = containers.First();
		task.owner.Command("note.inv", item.info.itemid, item.amount);
		task.owner.Command("note.inv", item.info.itemid, -item.amount);
		item.Drop(itemContainer.dropPosition, itemContainer.dropVelocity);
	}

```

## OnBoatPathGenerate()

```csharp
```csharp
/// <summary>
/// Called when the boat path is generated.
/// </summary>
/// <returns>
/// Returns a non-null value to override the default path generation behavior. 
/// If a List<Vector3> is returned, it will be used as the new path instead of the one generated by this method.
/// </returns>
List<Vector3> OnBoatPathGenerate()
{
    Puts("Generating boat path...");
    // Default implementation
    return GenerateOceanPatrolPath();
}
```
```

### Source Code from the Library

```csharp

	public static List<Vector3> GenerateOceanPatrolPath(float minDistanceFromShore = 50f, float minWaterDepth = 8f)
	{
		object obj = Interface.CallHook("OnBoatPathGenerate");
		if (obj is List<Vector3>)
		{
			return (List<Vector3>)obj;
		}
		float x = TerrainMeta.Size.x;
		float num = x * 2f * (float)Math.PI;
		float num2 = 30f;
		int num3 = Mathf.CeilToInt(num / num2);
		List<Vector3> list = new List<Vector3>();
		float num4 = x;
		float y = 0f;
		for (int i = 0; i < num3; i++)
		{
			float num5 = (float)i / (float)num3 * 360f;
			list.Add(new Vector3(Mathf.Sin(num5 * ((float)Math.PI / 180f)) * num4, y, Mathf.Cos(num5 * ((float)Math.PI / 180f)) * num4));
		}
		float num6 = 4f;
		float num7 = 200f;
		bool flag = true;
		for (int j = 0; j < AI.ocean_patrol_path_iterations && flag; j++)
		{
			flag = false;
			for (int k = 0; k < num3; k++)
			{
				Vector3 vector = list[k];
				int index = ((k == 0) ? (num3 - 1) : (k - 1));
				int index2 = ((k != num3 - 1) ? (k + 1) : 0);
				Vector3 b = list[index2];
				Vector3 b2 = list[index];
				Vector3 origin = vector;
				Vector3 normalized = (Vector3.zero - vector).normalized;
				Vector3 vector2 = vector + normalized * num6;
				if (Vector3.Distance(vector2, b) > num7 || Vector3.Distance(vector2, b2) > num7)
				{
					continue;
				}
				bool flag2 = true;
				int num8 = 16;
				for (int l = 0; l < num8; l++)
				{
					float num9 = (float)l / (float)num8 * 360f;
					Vector3 normalized2 = new Vector3(Mathf.Sin(num9 * ((float)Math.PI / 180f)), y, Mathf.Cos(num9 * ((float)Math.PI / 180f))).normalized;
					Vector3 vector3 = vector2 + normalized2 * 1f;
					GetWaterDepth(vector3);
					Vector3 direction = normalized;
					if (vector3 != Vector3.zero)
					{
						direction = (vector3 - vector2).normalized;
					}
					if (UnityEngine.Physics.SphereCast(origin, 3f, direction, out var _, minDistanceFromShore, 1218511105))
					{
						flag2 = false;
						break;
					}
				}
				if (flag2)
				{
					flag = true;
					list[k] = vector2;
				}
			}
		}
		if (flag)
		{
			Debug.LogWarning("Failed to generate ocean patrol path");
			return null;
		}
		List<int> list2 = new List<int>();
		LineUtility.Simplify(list, 5f, list2);
		List<Vector3> list3 = list;
		list = new List<Vector3>();
		foreach (int item in list2)
		{
			list.Add(list3[item]);
		}
		Debug.Log("Generated ocean patrol path with node count: " + list.Count);
		return list;
	}

```

## OnHelicopterStrafeEnter(PatrolHelicopterAI,UnityEngine.Vector3)

```csharp
```csharp
/// <summary>
/// Called when a helicopter enters the strafe state.
/// </summary>
/// <param name="patrolHelicopterAI">The PatrolHelicopterAI instance.</param>
/// <param name="strafePos">The position where the helicopter will start strafing.</param>
/// <returns>
/// Returns a non-null value to override the default behavior. If `null` is returned, the helicopter will enter the strafe state as normal.
/// </returns>
object OnHelicopterStrafeEnter(PatrolHelicopterAI patrolHelicopterAI, Vector3 strafePos)
{
    Puts($"Helicopter entering strafe state at position {strafePos}.");
    if (patrolHelicopterAI.GetFuelLevel() < 0.5f)
    {
        Puts($"Helicopter is low on fuel and cannot enter strafe state.");
        return "Low Fuel";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void State_Strafe_Enter(Vector3 strafePos, bool shouldUseNapalm = false)
	{
		if (Interface.CallHook("OnHelicopterStrafeEnter", this, strafePos) == null)
		{
			if (CanUseNapalm() && shouldUseNapalm)
			{
				useNapalm = shouldUseNapalm;
				lastNapalmTime = UnityEngine.Time.realtimeSinceStartup;
			}
			lastStrafeTime = UnityEngine.Time.realtimeSinceStartup;
			_currentState = aiState.STRAFE;
			int mask = LayerMask.GetMask("Terrain", "World", "Construction", "Water");
			if (TransformUtil.GetGroundInfo(strafePos, out var pos, out var _, 100f, mask, base.transform))
			{
				strafe_target_position = pos;
			}
			else
			{
				strafe_target_position = strafePos;
			}
			numRocketsLeft = 12;
			lastRocketTime = 0f;
			movementLockingAiming = true;
			Vector3 randomOffset = GetRandomOffset(strafePos, 175f, 192.5f);
			SetTargetDestination(randomOffset, 10f);
			SetIdealRotation(GetYawRotationTo(randomOffset));
			puttingDistance = true;
		}
	}

```

## OnTrapTrigger(Landmine,UnityEngine.GameObject)

```csharp
```csharp
/// <summary>
/// Called when a trap is triggered.
/// </summary>
/// <param name="landmine">The landmine that was triggered.</param>
/// <param name="victim">The player who triggered the landmine.</param>
/// <returns>
/// Returns `null` to allow the trap to trigger normally, or any non-null value to prevent the trap from triggering.
/// </returns>
object OnTrapTrigger(Landmine landmine, BasePlayer victim)
{
    Puts($"Landmine {landmine.name} triggered by player {victim.displayName}");
    if (victim.isSuperAdmin)
    {
        Puts($"Player {victim.displayName} is a super admin and cannot trigger the landmine.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public override void ObjectEntered(GameObject obj)
	{
		if (!base.isClient)
		{
			if (!Armed())
			{
				CancelInvoke(Arm);
				blocked = true;
			}
			else if (Interface.CallHook("OnTrapTrigger", this, obj) == null)
			{
				BasePlayer ply = GameObjectEx.ToBaseEntity(obj) as BasePlayer;
				Trigger(ply);
			}
		}
	}

```

## CanLootPlayer(BasePlayer,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can loot another player.
/// </summary>
/// <param name="looter">The player attempting to loot.</param>
/// <param name="target">The player being looted.</param>
/// <returns>
/// Returns `true` if the looter can loot the target, and `false` otherwise.
/// If a non-bool value is returned, it will be treated as `true`.
/// </returns>
object CanLootPlayer(BasePlayer looter, BasePlayer target)
{
    Puts($"Player {looter.UserIDString} is attempting to loot player {target.UserIDString}");
    if (looter == target)
    {
        Puts("Cannot loot self");
        return false;
    }
    if (!target.IsWounded())
    {
        Puts("Target is not wounded, cannot loot");
        return true;
    }
    object obj = Interface.CallHook("CanLootPlayer", looter, target);
    if (obj is bool)
    {
        return (bool)obj;
    }
    return true;
}
```
```

### Source Code from the Library

```csharp

	public override bool CanBeLooted(BasePlayer player)
	{
		object obj = Interface.CallHook("CanLootPlayer", this, player);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (player == this)
		{
			return false;
		}
		if (!IsWounded())
		{
			return IsSleeping();
		}
		return true;
	}

```

## IOnEntitySaved(BaseNetworkable,BaseNetworkable.SaveInfo)

```csharp
```csharp
/// <summary>
/// Called when an entity is saved.
/// </summary>
/// <param name="entity">The entity being saved.</param>
/// <param name="saveInfo">Information about the save operation.</param>
/// <returns>No return behavior.</returns>
void IOnEntitySaved(BaseNetworkable entity, SaveInfo saveInfo)
{
    Puts($"Entity {entity} has been saved with info: {saveInfo}");
}
```
```

### Source Code from the Library

```csharp

	public void ToStream(Stream stream, SaveInfo saveInfo)
	{
		using (saveInfo.msg = Facepunch.Pool.Get<ProtoBuf.Entity>())
		{
			Save(saveInfo);
			if (saveInfo.msg.baseEntity == null)
			{
				Debug.LogError(string.Concat(this, ": ToStream - no BaseEntity!?"));
			}
			if (saveInfo.msg.baseNetworkable == null)
			{
				Debug.LogError(string.Concat(this, ": ToStream - no baseNetworkable!?"));
			}
			Interface.CallHook("IOnEntitySaved", this, saveInfo);
			saveInfo.msg.ToProto(stream);
			PostSave(saveInfo);
		}
	}

```

## OnEntityDestroy(CH47HelicopterAIController)

```csharp
```csharp
/// <summary>
/// Called when an entity is destroyed.
/// </summary>
/// <param name="entity">The entity being destroyed.</param>
/// <returns>
/// Returns `null` to allow the entity to be destroyed, or any non-null value to prevent it from being destroyed.
/// </returns>
object OnEntityDestroy(CH47HelicopterAIController entity)
{
    Puts($"Entity {entity.GetType().Name} has been destroyed.");
    if (entity is CH47HelicopterAIController && ((CH47HelicopterAIController)entity).IsCritical)
    {
        Puts($"Entity {entity.GetType().Name} was critical and could not be destroyed.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public override void OnKilled(HitInfo info)
	{
		if (Interface.CallHook("OnEntityDestroy", this) == null)
		{
			if (!OutOfCrates())
			{
				DropCrate();
			}
			base.OnKilled(info);
		}
	}

```

## IOnRunCommandLine()

```csharp
```csharp
/// <summary>
/// Called when the command line is run.
/// </summary>
/// <returns>No return behavior.</returns>
void IOnRunCommandLine()
{
    Puts("Command line has been executed.");
    // Minimal code to demonstrate functionality
}
```
```

### Source Code from the Library

```csharp

	public static void UpdateValuesFromCommandLine()
	{
		if (Interface.CallHook("IOnRunCommandLine") != null)
		{
			return;
		}
		foreach (KeyValuePair<string, string> @switch in Facepunch.CommandLine.GetSwitches())
		{
			string text = @switch.Value;
			if (text == "")
			{
				text = "1";
			}
			string strCommand = @switch.Key.Substring(1);
			Run(Option.Unrestricted, strCommand, text);
		}
	}

```

## OnClientDisconnect(Network.Connection,string)

```csharp
```csharp
/// <summary>
/// Called when a client disconnects from the server.
/// </summary>
/// <param name="connection">The connection that was disconnected.</param>
/// <param name="reason">The reason for the disconnection, if any.</param>
/// <returns>No return behavior.</returns>
void OnClientDisconnect(Connection connection, string reason)
{
    Puts($"Client {connection.UserIDString} disconnected with reason: {reason}");
}
```
```

### Source Code from the Library

```csharp

	protected void OnDisconnected(string strReason, Connection cn)
	{
		if (cn != null)
		{
			cn.connected = false;
			cn.active = false;
			if (callbackHandler != null)
			{
				callbackHandler.OnDisconnected(strReason, cn);
			}
			Interface.CallHook("OnClientDisconnect", cn, strReason);
			RemoveConnection(cn);
		}
	}

```

## OnGroupCreated(string,string,int)

```csharp
```csharp
/// <summary>
/// Called when a new group is created.
/// </summary>
/// <param name="groupName">The name of the newly created group.</param>
/// <param name="groupTitle">The title of the newly created group.</param>
/// <param name="groupRank">The rank of the newly created group.</param>
/// <returns>No return behavior.</returns>
void OnGroupCreated(string groupName, string groupTitle, int groupRank)
{
    Puts($"Group {groupName} with title {groupTitle} and rank {groupRank} has been created.");
}
```
```

### Source Code from the Library

```csharp

	[LibraryFunction("CreateGroup")]
	public bool CreateGroup(string groupName, string groupTitle, int groupRank)
	{
		if (GroupExists(groupName) || string.IsNullOrEmpty(groupName))
		{
			return false;
		}
		GroupData value = new GroupData
		{
			Title = groupTitle,
			Rank = groupRank
		};
		groupsData.Add(groupName, value);
		Interface.CallHook("OnGroupCreated", groupName, groupTitle, groupRank);
		return true;
	}

```

## OnUserNameUpdated(string,string,string)

```csharp
```csharp
/// <summary>
/// Called when a player's saved nickname is updated.
/// </summary>
/// <param name="id">The player's ID.</param>
/// <param name="oldName">The player's old nickname.</param>
/// <param name="newName">The player's new nickname.</param>
/// <returns>No return behavior.</returns>
void OnUserNameUpdated(string id, string oldName, string newName)
{
    Puts($"Player's name changed from {oldName} to {newName} for ID {id}");
}
```
```

### Source Code from the Library

```csharp

	[LibraryFunction("UpdateNickname")]
	public void UpdateNickname(string playerId, string playerName)
	{
		if (UserExists(playerId))
		{
			UserData userData = GetUserData(playerId);
			string lastSeenNickname = userData.LastSeenNickname;
			string obj = playerName.Sanitize();
			userData.LastSeenNickname = playerName.Sanitize();
			Interface.CallHook("OnUserNameUpdated", playerId, lastSeenNickname, obj);
		}
	}

```

## OnGroupRankSet(string,int)

```csharp
```csharp
/// <summary>
/// Called when a group's rank is set.
/// </summary>
/// <param name="groupName">The name of the group whose rank is being changed.</param>
/// <param name="newRank">The new rank for the group.</param>
/// <returns>No return behavior.</returns>
void OnGroupRankSet(string groupName, int newRank)
{
    Puts($"Group {groupName} has been set to rank {newRank}");
}
```
```

### Source Code from the Library

```csharp

	[LibraryFunction("SetGroupRank")]
	public bool SetGroupRank(string groupName, int groupRank)
	{
		if (!GroupExists(groupName))
		{
			return false;
		}
		if (!groupsData.TryGetValue(groupName, out var value))
		{
			return false;
		}
		if (value.Rank == groupRank)
		{
			return true;
		}
		value.Rank = groupRank;
		Interface.CallHook("OnGroupRankSet", groupName, groupRank);
		return true;
	}

```

## OnGroupTitleSet(string,string)

```csharp
```csharp
/// <summary>
/// Called when a group's title is set.
/// </summary>
/// <param name="groupName">The name of the group whose title is being changed.</param>
/// <param name="newTitle">The new title for the group.</param>
/// <returns>No return behavior.</returns>
void OnGroupTitleSet(string groupName, string newTitle)
{
    Puts($"Group {groupName} has been renamed to {newTitle}");
}
```
```

### Source Code from the Library

```csharp

	[LibraryFunction("SetGroupTitle")]
	public bool SetGroupTitle(string groupName, string groupTitle)
	{
		if (!GroupExists(groupName))
		{
			return false;
		}
		if (!groupsData.TryGetValue(groupName, out var value))
		{
			return false;
		}
		if (value.Title == groupTitle)
		{
			return true;
		}
		value.Title = groupTitle;
		Interface.CallHook("OnGroupTitleSet", groupName, groupTitle);
		return true;
	}

```

## OnPermissionRegistered(string,Oxide.Core.Plugins.Plugin)

```csharp
```csharp
/// <summary>
/// Called when a new permission is registered.
/// </summary>
/// <param name="permission">The newly registered permission.</param>
/// <param name="owner">The plugin that registered the permission.</param>
/// <returns>No return behavior.</returns>
void OnPermissionRegistered(string permission, Plugin owner)
{
    Puts($"Permission '{permission}' has been registered by plugin {owner.Title}");
    if (permission == "admin-only")
    {
        Puts($"Warning: Permission '{permission}' is reserved for core plugins only");
    }
}
```
```

### Source Code from the Library

```csharp

	[LibraryFunction("RegisterPermission")]
	public void RegisterPermission(string permission, Plugin owner)
	{
		if (string.IsNullOrEmpty(permission))
		{
			return;
		}
		if (PermissionExists(permission))
		{
			Interface.Oxide.LogWarning("Duplicate permission registered '{0}' (by plugin '{1}')", permission, owner.Title);
			return;
		}
		if (!registeredPermissions.TryGetValue(owner, out var value))
		{
			value = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
			registeredPermissions.Add(owner, value);
			owner.OnRemovedFromManager.Add(owner_OnRemovedFromManager);
		}
		value.Add(permission);
		Interface.CallHook("OnPermissionRegistered", permission, owner);
		if (!permission.StartsWith(owner.Name + ".", StringComparison.OrdinalIgnoreCase) && !owner.IsCorePlugin)
		{
			Interface.Oxide.LogWarning("Missing plugin name prefix '{0}' for permission '{1}' (by plugin '{2}')", owner.Name.ToLower(), permission, owner.Title);
		}
	}

```

## OnGroupParentSet(string,string)

```csharp
```csharp
/// <summary>
/// Called when a group's parent is set.
/// </summary>
/// <param name="groupName">The name of the group whose parent is being set.</param>
/// <param name="parentGroupName">The name of the new parent group.</param>
/// <returns>No return behavior.</returns>
void OnGroupParentSet(string groupName, string parentGroupName)
{
    Puts($"Group {groupName} has been assigned a new parent: {parentGroupName}");
}
```
```

### Source Code from the Library

```csharp

	[LibraryFunction("SetGroupParent")]
	public bool SetGroupParent(string groupName, string parentGroupName)
	{
		if (!GroupExists(groupName))
		{
			return false;
		}
		if (!groupsData.TryGetValue(groupName, out var value))
		{
			return false;
		}
		if (string.IsNullOrEmpty(parentGroupName))
		{
			value.ParentGroup = null;
			return true;
		}
		if (!GroupExists(parentGroupName) || groupName.Equals(parentGroupName))
		{
			return false;
		}
		if (!string.IsNullOrEmpty(value.ParentGroup) && value.ParentGroup.Equals(parentGroupName))
		{
			return true;
		}
		if (HasCircularParent(groupName, parentGroupName))
		{
			return false;
		}
		value.ParentGroup = parentGroupName;
		Interface.CallHook("OnGroupParentSet", groupName, parentGroupName);
		return true;
	}

```

## OnGroupDeleted(string)

```csharp
```csharp
/// <summary>
/// Called when a group is deleted.
/// </summary>
/// <param name="groupName">The name of the deleted group.</param>
/// <returns>No return behavior.</returns>
void OnGroupDeleted(string groupName)
{
    Puts($"Group {groupName} has been deleted.");
    // Additional logic can be added here if needed
}
```
```

### Source Code from the Library

```csharp

	[LibraryFunction("RemoveGroup")]
	public bool RemoveGroup(string groupName)
	{
		if (!GroupExists(groupName))
		{
			return false;
		}
		bool flag = groupsData.Remove(groupName);
		if (flag)
		{
			foreach (GroupData item in groupsData.Values.Where((GroupData g) => g.ParentGroup == groupName))
			{
				item.ParentGroup = string.Empty;
			}
		}
		if (usersData.Values.Aggregate(seed: false, (bool current, UserData userData) => current | userData.Groups.Remove(groupName)))
		{
			SaveUsers();
		}
		if (flag)
		{
			Interface.CallHook("OnGroupDeleted", groupName);
		}
		return true;
	}

```

## OnPlayerChat(BasePlayer,string)

```csharp
```csharp
/// <summary>
/// Called when a player sends a chat message.
/// </summary>
/// <param name="player">The player sending the chat message.</param>
/// <param name="message">The text of the chat message.</param>
/// <returns>
/// Returns `null` to allow the message to be sent as normal, or any non-null value to prevent the message from being sent.
/// </returns>
object OnPlayerChat(BasePlayer player, string message)
{
    Puts($"Player {player.UserIDString} said: {message}");
    if (message.ToLower() == "test")
    {
        Puts("Player's message was blocked.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnPlayerChat")]
	private object IOnPlayerChat(ulong playerId, string playerName, string message, BasePlayer basePlayer)
	{
		if (string.IsNullOrEmpty(message) || message.Equals("text"))
		{
			return true;
		}
		if (basePlayer == null || !basePlayer.IsConnected)
		{
			return Interface.CallHook("OnPlayerOfflineChat", playerId, playerName, message);
		}
		object obj = Interface.CallHook("OnPlayerChat", basePlayer, message);
		object result = Interface.CallHook("OnUserChat", basePlayer.IPlayer, message);
		if (obj != null)
		{
			return obj;
		}
		return result;
	}

```

## OnPlayerOfflineChat(ulong,string,string)

```csharp
```csharp
/// <summary>
/// Called when a player sends an offline chat message.
/// </summary>
/// <param name="playerId">The ID of the player sending the chat message.</param>
/// <param name="playerName">The name of the player sending the chat message.</param>
/// <param name="message">The text of the chat message.</param>
/// <returns>
/// Returns a non-null value to override the default behavior. If `null` is returned, the message will be displayed as normal.
/// </returns>
object OnPlayerOfflineChat(ulong playerId, string playerName, string message)
{
    Puts($"Player {playerName} with ID {playerId} sent an offline chat message: {message}");
    if (message.Contains("sensitive information"))
    {
        Puts($"Player {playerName}'s message contains sensitive information.");
        return "Message censored due to sensitive content.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnPlayerChat")]
	private object IOnPlayerChat(ulong playerId, string playerName, string message, BasePlayer basePlayer)
	{
		if (string.IsNullOrEmpty(message) || message.Equals("text"))
		{
			return true;
		}
		if (basePlayer == null || !basePlayer.IsConnected)
		{
			return Interface.CallHook("OnPlayerOfflineChat", playerId, playerName, message);
		}
		object obj = Interface.CallHook("OnPlayerChat", basePlayer, message);
		object result = Interface.CallHook("OnUserChat", basePlayer.IPlayer, message);
		if (obj != null)
		{
			return obj;
		}
		return result;
	}

```

## OnDestroyUI(BasePlayer,string)

```csharp
```csharp
/// <summary>
/// Called when a UI element is destroyed.
/// </summary>
/// <param name="player">The player whose UI was destroyed.</param>
/// <param name="elem">The ID of the destroyed UI element.</param>
/// <returns>No return behavior.</returns>
void OnDestroyUI(BasePlayer player, string elem)
{
    Puts($"UI for player {player.UserIDString} with ID {elem} has been destroyed.");
}
```
```

### Source Code from the Library

```csharp

	public static bool DestroyUi(BasePlayer player, string elem)
	{
		if (player?.net != null)
		{
			Interface.CallHook("OnDestroyUI", player, elem);
			CommunityEntity.ServerInstance.ClientRPCEx(new SendInfo
			{
				connection = player.net.connection
			}, null, "DestroyUI", elem);
			return true;
		}
		return false;
	}

```

## OnUserCommand(Oxide.Core.Libraries.Covalence.IPlayer,string,string[])

```csharp
```csharp
/// <summary>
/// Called when a user issues a command.
/// </summary>
/// <param name="player">The player who issued the command.</param>
/// <param name="commandName">The name of the command that was issued.</param>
/// <param name="args">Any arguments that were provided with the command.</param>
/// <returns>
/// Returns a non-null value to override the default command handling behavior. 
/// If `null` is returned, the command will be handled as normal.
/// </returns>
object OnUserCommand(IPlayer player, string commandName, string[] args)
{
    Puts($"Player {player.Id} issued command: /{commandName} {string.Join(" ", args)}");
    if (commandName == "adminonly")
    {
        Puts($"Player {player.Id} does not have permission to use the '{commandName}' command.");
        return "You do not have permission to use this command.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnPlayerCommand")]
	private void IOnPlayerCommand(BasePlayer basePlayer, string message)
	{
		if (basePlayer == null || !basePlayer.IsConnected)
		{
			return;
		}
		string text = message.Replace("\n", "").Replace("\r", "").Trim();
		if (string.IsNullOrEmpty(text) || text[0] != '/' || text.Length <= 1)
		{
			return;
		}
		ParseCommand(text.TrimStart('/'), out var command, out var args);
		if (command != null)
		{
			object obj = Interface.CallHook("OnPlayerCommand", basePlayer, command, args);
			object obj2 = Interface.CallHook("OnUserCommand", basePlayer.IPlayer, command, args);
			if (((obj == null) ? obj2 : obj) == null && !Covalence.CommandSystem.HandleChatMessage(basePlayer.IPlayer, text) && !cmdlib.HandleChatCommand(basePlayer, command, args) && Interface.Oxide.Config.Options.Modded)
			{
				basePlayer.IPlayer.Reply(string.Format(lang.GetMessage("UnknownCommand", this, basePlayer.IPlayer.Id), command));
			}
		}
	}

```

## OnPlayerLanguageChanged(Oxide.Core.Libraries.Covalence.IPlayer,string)

```csharp
```csharp
/// <summary>
/// Called when a player's language is changed.
/// </summary>
/// <param name="player">The player whose language has been changed.</param>
/// <param name="languageCode">The new language code of the player.</param>
/// <returns>No return behavior.</returns>
void OnPlayerLanguageChanged(IPlayer player, string languageCode)
{
    Puts($"Player's language changed to {languageCode}");
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("OnPlayerSetInfo")]
	private void OnPlayerSetInfo(Connection connection, string key, string val)
	{
		if (!(key == "global.language"))
		{
			return;
		}
		lang.SetLanguage(val, connection.userid.ToString());
		BasePlayer basePlayer = connection.player as BasePlayer;
		if (basePlayer != null)
		{
			Interface.CallHook("OnPlayerLanguageChanged", basePlayer, val);
			if (basePlayer.IPlayer != null)
			{
				Interface.CallHook("OnPlayerLanguageChanged", basePlayer.IPlayer, val);
			}
		}
	}

```

## OnPlayerLanguageChanged(BasePlayer,string)

```csharp
```csharp
/// <summary>
/// Called when a player's language is changed.
/// </summary>
/// <param name="player">The player whose language has been changed.</param>
/// <param name="languageCode">The new language code of the player.</param>
/// <returns>No return behavior.</returns>
void OnPlayerLanguageChanged(BasePlayer player, string languageCode)
{
    Puts($"Player's language changed to {languageCode} for ID {player.UserIDString}");
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("OnPlayerSetInfo")]
	private void OnPlayerSetInfo(Connection connection, string key, string val)
	{
		if (!(key == "global.language"))
		{
			return;
		}
		lang.SetLanguage(val, connection.userid.ToString());
		BasePlayer basePlayer = connection.player as BasePlayer;
		if (basePlayer != null)
		{
			Interface.CallHook("OnPlayerLanguageChanged", basePlayer, val);
			if (basePlayer.IPlayer != null)
			{
				Interface.CallHook("OnPlayerLanguageChanged", basePlayer.IPlayer, val);
			}
		}
	}

```

## OnUserRespawn(Oxide.Core.Libraries.Covalence.IPlayer)

```csharp
```csharp
/// <summary>
/// Called when a user respawns.
/// </summary>
/// <param name="player">The player who respawned.</param>
/// <returns>
/// Returns `null` to allow the player to respawn normally, or any non-null value to override the default respawn behavior.
/// If a string is returned, it will be used as a message to display to the player when they respawn.
/// </returns>
object OnUserRespawn(IPlayer player)
{
    Puts($"Player {player.Name} has respawned.");
    if (player.Name == "Admin")
    {
        Puts($"Player {player.Name} is an admin and will not be notified of their respawn.");
        return null;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("OnPlayerRespawn")]
	private object OnPlayerRespawn(BasePlayer basePlayer)
	{
		IPlayer iPlayer = basePlayer.IPlayer;
		if (iPlayer == null)
		{
			return null;
		}
		return Interface.CallHook("OnUserRespawn", iPlayer);
	}

```

## OnRconCommand(System.Net.IPAddress,string,string[])

```csharp
```csharp
/// <summary>
/// Called when an RCON command is executed.
/// </summary>
/// <param name="ipAddress">The IP address of the client that sent the RCON command.</param>
/// <param name="commandName">The name of the RCON command being executed.</param>
/// <param name="parameters">An array of parameters passed to the RCON command.</param>
/// <returns>
/// Returns `true` if the RCON command should be blocked, or any non-null value to override the default behavior.
/// If `null` is returned, the RCON command will be executed as normal.
/// </returns>
object OnRconCommand(IPAddress ipAddress, string commandName, string[] parameters)
{
    Puts($"RCON command '{commandName}' received from {ipAddress} with parameters: [{string.Join(", ", parameters)}]");
    if (parameters.Contains("invalid"))
    {
        Puts($"RCON command '{commandName}' blocked due to invalid parameter.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnRconCommand")]
	private object IOnRconCommand(IPAddress ipAddress, string command)
	{
		if (ipAddress != null && !string.IsNullOrEmpty(command))
		{
			RemoteMessage message = RemoteMessage.GetMessage(command);
			if (string.IsNullOrEmpty(message?.Message))
			{
				return null;
			}
			string[] array = Oxide.Core.CommandLine.Split(message.Message);
			if (array.Length >= 1)
			{
				string obj = array[0].ToLower();
				string[] obj2 = array.Skip(1).ToArray();
				if (Interface.CallHook("OnRconCommand", ipAddress, obj, obj2) != null)
				{
					return true;
				}
			}
		}
		return null;
	}

```

## OnEntityTakeDamage(BaseCombatEntity,HitInfo)

```csharp
```csharp
/// <summary>
/// Called when an entity takes damage.
/// </summary>
/// <param name="entity">The entity that took the damage.</param>
/// <param name="hitInfo">Information about the hit, including the attacker and damage dealt.</param>
/// <returns>No return behavior.</returns>
void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo hitInfo)
{
    Puts($"Entity {entity.EntityID} took {hitInfo.Damage} damage from {hitInfo.Attacker.EntityID}");
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnBaseCombatEntityHurt")]
	private object IOnBaseCombatEntityHurt(BaseCombatEntity entity, HitInfo hitInfo)
	{
		if (!(entity is BasePlayer))
		{
			return Interface.CallHook("OnEntityTakeDamage", entity, hitInfo);
		}
		return null;
	}

```

## OnUserRespawned(Oxide.Core.Libraries.Covalence.IPlayer)

```csharp
```csharp
/// <summary>
/// Called when a user respawns.
/// </summary>
/// <param name="player">The player who respawned.</param>
/// <returns>No return behavior.</returns>
void OnUserRespawned(IPlayer player)
{
    Puts($"Player {player.Name} has respawned.");
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("OnPlayerRespawned")]
	private void OnPlayerRespawned(BasePlayer basePlayer)
	{
		IPlayer iPlayer = basePlayer.IPlayer;
		if (iPlayer != null)
		{
			Interface.CallHook("OnUserRespawned", iPlayer);
		}
	}

```

## OnUserDisconnected(Oxide.Core.Libraries.Covalence.IPlayer,string)

```csharp
```csharp
/// <summary>
/// Called when a user disconnects from the server.
/// </summary>
/// <param name="iPlayer">The IPlayer instance representing the disconnected user.</param>
/// <param name="reason">The reason for the disconnection, if any.</param>
/// <returns>No return behavior.</returns>
void OnUserDisconnected(IPlayer iPlayer, string reason)
{
    Puts($"User {iPlayer.Name} has disconnected from the server: {reason}");
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("OnPlayerDisconnected")]
	private void OnPlayerDisconnected(BasePlayer basePlayer, string reason)
	{
		IPlayer iPlayer = basePlayer.IPlayer;
		if (iPlayer != null)
		{
			Interface.CallHook("OnUserDisconnected", iPlayer, reason);
		}
		Covalence.PlayerManager.PlayerDisconnected(basePlayer);
	}

```

## OnServerInitialized(bool)

```csharp
```csharp
/// <summary>
/// Called when the server is initialized.
/// </summary>
/// <param name="initialized">Whether the server has been successfully initialized.</param>
/// <returns>No return behavior.</returns>
void OnServerInitialized(bool initialized)
{
    Puts($"Server initialization complete: {initialized}");
    if (!initialized)
    {
        Puts("Error initializing server. Server will not start.");
    }
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnServerInitialized")]
	private void IOnServerInitialized()
	{
		if (!serverInitialized)
		{
			Analytics.Collect();
			if (!Interface.Oxide.Config.Options.Modded)
			{
				Interface.Oxide.LogWarning("The server is currently listed under Community. Please be aware that Facepunch only allows admin tools (that do not affect gameplay) under the Community section");
			}
			serverInitialized = true;
			Interface.CallHook("OnServerInitialized", serverInitialized);
		}
	}

```

## CanUserLogin(string,string,string)

```csharp
```csharp
/// <summary>
/// Called when a user attempts to login.
/// </summary>
/// <param name="username">The username of the user attempting to login.</param>
/// <param name="steamId">The Steam ID of the user attempting to login.</param>
/// <param name="ipAddress">The IP address of the user attempting to login.</param>
/// <returns>
/// Returns a non-null value to override the default login behavior. 
/// If `true` is returned, the user is allowed to login.
/// If `false` or a string is returned, the user will be kicked with the provided message as the reason.
/// </returns>
object CanUserLogin(string username, ulong steamId, string ipAddress)
{
    Puts($"User {username} with SteamID {steamId} and IP {ipAddress} is attempting to login.");
    if (ipAddress == "192.168.1.1")
    {
        Puts($"User {username} with IP {ipAddress} has been blocked from logging in.");
        return false;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnUserApprove")]
	private object IOnUserApprove(Connection connection)
	{
		string username = connection.username;
		string text = connection.userid.ToString();
		string obj = Regex.Replace(connection.ipaddress, ipPattern, "");
		uint authLevel = connection.authLevel;
		if (permission.IsLoaded)
		{
			permission.UpdateNickname(text, username);
			OxideConfig.DefaultGroups defaultGroups = Interface.Oxide.Config.Options.DefaultGroups;
			if (!permission.UserHasGroup(text, defaultGroups.Players))
			{
				permission.AddUserGroup(text, defaultGroups.Players);
			}
			if (authLevel == 2 && !permission.UserHasGroup(text, defaultGroups.Administrators))
			{
				permission.AddUserGroup(text, defaultGroups.Administrators);
			}
		}
		Covalence.PlayerManager.PlayerJoin(connection.userid, username);
		object obj2 = Interface.CallHook("CanClientLogin", connection);
		object obj3 = Interface.CallHook("CanUserLogin", username, text, obj);
		object obj4 = ((obj2 == null) ? obj3 : obj2);
		if (obj4 is string || (obj4 is bool && !(bool)obj4))
		{
			ConnectionAuth.Reject(connection, (obj4 is string) ? obj4.ToString() : lang.GetMessage("ConnectionRejected", this, text));
			return true;
		}
		object obj5 = Interface.CallHook("OnUserApprove", connection);
		object result = Interface.CallHook("OnUserApproved", username, text, obj);
		if (obj5 != null)
		{
			return obj5;
		}
		return result;
	}

```

## OnUserUnbanned(string,string,string)

```csharp
```csharp
/// <summary>
/// Called when a user is unbanned from the server.
/// </summary>
/// <param name="username">The username of the unbanned user.</param>
/// <param name="steamId">The Steam ID of the unbanned user.</param>
/// <param name="ipAddress">The IP address of the unbanned user.</param>
/// <returns>No return behavior.</returns>
void OnUserUnbanned(string username, ulong steamId, string ipAddress)
{
    Puts($"User {username} with SteamID {steamId} and IP {ipAddress} has been unbanned from the server.");
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnServerUsersRemove")]
	private void IOnServerUsersRemove(ulong steamId)
	{
		if (serverInitialized && ServerUsers.users.ContainsKey(steamId) && ServerUsers.users[steamId].group == ServerUsers.UserGroup.Banned)
		{
			string text = steamId.ToString();
			IPlayer player = Covalence.PlayerManager.FindPlayerById(text);
			Interface.CallHook("OnPlayerUnbanned", player?.Name ?? "Unnamed", steamId, player?.Address ?? "0");
			Interface.CallHook("OnUserUnbanned", player?.Name ?? "Unnamed", text, player?.Address ?? "0");
		}
	}

```

## CanClientLogin(Network.Connection)

```csharp
```csharp
/// <summary>
/// Called when a client attempts to login.
/// </summary>
/// <param name="connection">The connection object representing the client.</param>
/// <returns>
/// Returns `true` if the client should be allowed to login, or any non-null value to prevent them from logging in. 
/// If `null` is returned, the default login behavior will occur.
/// </returns>
object CanClientLogin(Connection connection)
{
    Puts($"Client {connection.username} with IP {connection.ipaddress} has attempted to login.");
    if (connection.ipaddress == "192.168.1.1")
    {
        Puts($"Client {connection.username} with IP {connection.ipaddress} has been blocked from logging in.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnUserApprove")]
	private object IOnUserApprove(Connection connection)
	{
		string username = connection.username;
		string text = connection.userid.ToString();
		string obj = Regex.Replace(connection.ipaddress, ipPattern, "");
		uint authLevel = connection.authLevel;
		if (permission.IsLoaded)
		{
			permission.UpdateNickname(text, username);
			OxideConfig.DefaultGroups defaultGroups = Interface.Oxide.Config.Options.DefaultGroups;
			if (!permission.UserHasGroup(text, defaultGroups.Players))
			{
				permission.AddUserGroup(text, defaultGroups.Players);
			}
			if (authLevel == 2 && !permission.UserHasGroup(text, defaultGroups.Administrators))
			{
				permission.AddUserGroup(text, defaultGroups.Administrators);
			}
		}
		Covalence.PlayerManager.PlayerJoin(connection.userid, username);
		object obj2 = Interface.CallHook("CanClientLogin", connection);
		object obj3 = Interface.CallHook("CanUserLogin", username, text, obj);
		object obj4 = ((obj2 == null) ? obj3 : obj2);
		if (obj4 is string || (obj4 is bool && !(bool)obj4))
		{
			ConnectionAuth.Reject(connection, (obj4 is string) ? obj4.ToString() : lang.GetMessage("ConnectionRejected", this, text));
			return true;
		}
		object obj5 = Interface.CallHook("OnUserApprove", connection);
		object result = Interface.CallHook("OnUserApproved", username, text, obj);
		if (obj5 != null)
		{
			return obj5;
		}
		return result;
	}

```

## OnPlayerBanned(string,ulong,string,string,long)

```csharp
```csharp
/// <summary>
/// Called when a player is banned from the server.
/// </summary>
/// <param name="playerName">The name of the banned player.</param>
/// <param name="steamId">The Steam ID of the banned player.</param>
/// <param name="ipAddress">The IP address of the banned player.</param>
/// <param name="reason">The reason for the ban.</param>
/// <param name="expiry">The time until the ban expires, in seconds.</param>
/// <returns>No return behavior.</returns>
void OnPlayerBanned(string playerName, ulong steamId, string ipAddress, string reason, long expiry)
{
    Puts($"Player {playerName} with SteamID {steamId}, IP {ipAddress} has been banned for {expiry} seconds. Reason: {reason}");
    if (expiry == 0)
    {
        Puts($"Player {playerName} has been permanently banned.");
    }
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnServerUsersSet")]
	private void IOnServerUsersSet(ulong steamId, ServerUsers.UserGroup group, string playerName, string reason, long expiry)
	{
		if (serverInitialized && group == ServerUsers.UserGroup.Banned)
		{
			string text = steamId.ToString();
			IPlayer player = Covalence.PlayerManager.FindPlayerById(text);
			Interface.CallHook("OnPlayerBanned", playerName, steamId, player?.Address ?? "0", reason, expiry);
			Interface.CallHook("OnUserBanned", playerName, text, player?.Address ?? "0", reason, expiry);
		}
	}

```

## OnNpcTarget(BaseNpc,BaseEntity)

```csharp
```csharp
/// <summary>
/// Called when an NPC targets a player or entity.
/// </summary>
/// <param name="npc">The NPC that is targeting.</param>
/// <param name="target">The target of the NPC's attack.</param>
/// <returns>
/// Returns `null` to allow the NPC to target normally, or any non-null value to override the default behavior. 
/// If a float is returned, it will be used as the new range for the NPC's enemy detection.
/// </returns>
float OnNpcTarget(BaseNpc npc, BaseEntity target)
{
    Puts($"NPC {npc.name} has targeted {target.displayName}");
    if (target is Player player && player.GetScore() < 50f)
    {
        Puts($"NPC {npc.name} has been ordered to attack a weak player");
        return 10f;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnNpcTarget")]
	private object IOnNpcTarget(BaseNpc npc, BaseEntity target)
	{
		if (Interface.CallHook("OnNpcTarget", npc, target) != null)
		{
			npc.SetFact(BaseNpc.Facts.HasEnemy, 0);
			npc.SetFact(BaseNpc.Facts.EnemyRange, 3);
			npc.SetFact(BaseNpc.Facts.AfraidRange, 1);
			npc.AiContext.EnemyPlayer = null;
			npc.AiContext.LastEnemyPlayerScore = 0f;
			npc.playerTargetDecisionStartTime = 0f;
			return 0f;
		}
		return null;
	}

```

## OnPlayerBanned(Network.Connection,string)

```csharp
```csharp
/// <summary>
/// Called when a player is banned.
/// </summary>
/// <param name="connection">The network connection of the banned player.</param>
/// <param name="status">The ban status, which can be used to determine the reason for the ban.</param>
void OnPlayerBanned(Network.Connection connection, string status)
{
    Puts($"Player {connection.UserIDString} has been banned with status: {status}");
    if (status == "Permanent Ban")
    {
        Puts($"Player {connection.UserIDString} has been permanently banned.");
        // Additional actions can be taken here, such as removing the player's data or notifying administrators.
    }
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnPlayerBanned")]
	private void IOnPlayerBanned(Connection connection, AuthResponse status)
	{
		Interface.CallHook("OnPlayerBanned", connection, status.ToString());
	}

```

## OnUserKicked(Oxide.Core.Libraries.Covalence.IPlayer,string)

```csharp
```csharp
/// <summary>
/// Called when a user is kicked from the server.
/// </summary>
/// <param name="player">The player being kicked.</param>
/// <param name="reason">The reason for kicking the player.</param>
/// <returns>No return behavior.</returns>
void OnUserKicked(IPlayer player, string reason)
{
    Puts($"Player {player.Name} was kicked with reason: {reason}");
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("OnPlayerKicked")]
	private void OnPlayerKicked(BasePlayer basePlayer, string reason)
	{
		if (basePlayer.IPlayer != null)
		{
			Interface.CallHook("OnUserKicked", basePlayer.IPlayer, reason);
		}
	}

```

## OnUserConnected(Oxide.Core.Libraries.Covalence.IPlayer)

```csharp
```csharp
/// <summary>
/// Called when a user connects to the server.
/// </summary>
/// <param name="player">The connected player.</param>
/// <returns>No return behavior.</returns>
void OnUserConnected(IPlayer player)
{
    Puts($"Player {player.Name} has connected to the server.");
    if (player.IsAdmin())
    {
        Puts($"Player {player.Name} is an administrator.");
        // Grant admin privileges
    }
    else
    {
        Puts($"Player {player.Name} is a regular player.");
        // Do nothing
    }
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnPlayerConnected")]
	private void IOnPlayerConnected(BasePlayer basePlayer)
	{
		lang.SetLanguage(basePlayer.net.connection.info.GetString("global.language", "en"), basePlayer.UserIDString);
		basePlayer.SendEntitySnapshot(CommunityEntity.ServerInstance);
		Covalence.PlayerManager.PlayerConnected(basePlayer);
		IPlayer player = Covalence.PlayerManager.FindPlayerById(basePlayer.UserIDString);
		if (player != null)
		{
			basePlayer.IPlayer = player;
			Interface.CallHook("OnUserConnected", player);
		}
		Interface.Oxide.CallHook("OnPlayerConnected", basePlayer);
	}

```

## OnServerCommand(string,string[])

```csharp
```csharp
/// <summary>
/// Called when a server command is executed.
/// </summary>
/// <param name="commandName">The name of the command being executed.</param>
/// <param name="args">The arguments passed to the command.</param>
/// <returns>
/// Returns `true` to allow the command to execute, or any non-null value to prevent it from executing.
/// </returns>
object OnServerCommand(string commandName, string[] args)
{
    Puts($"Server command {commandName} with arguments {string.Join(", ", args)} has been executed.");
    if (commandName == "adminonly" && !RustPermissions.UserHasGroup(RustPermissions.GetSteamId(), RustPermissions.DefaultGroups.Administrators))
    {
        Puts("User does not have admin permissions to execute this command.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnServerCommand")]
	private object IOnServerCommand(ConsoleSystem.Arg arg)
	{
		if (arg == null || (arg.Connection != null && arg.Player() == null))
		{
			return true;
		}
		if (arg.cmd.FullName == "chat.say" || arg.cmd.FullName == "chat.teamsay")
		{
			return null;
		}
		object obj = Interface.CallHook("OnServerCommand", arg);
		object obj2 = Interface.CallHook("OnServerCommand", arg.cmd.FullName, RustCommandSystem.ExtractArgs(arg));
		if (((obj == null) ? obj2 : obj) != null)
		{
			return true;
		}
		return null;
	}

```

## OnLoseCondition(object[])

```csharp
```csharp
/// <summary>
/// Called when an item loses a certain amount of condition.
/// </summary>
/// <param name="item">The item losing condition.</param>
/// <param name="amount">The amount of condition lost.</param>
/// <returns>No return behavior.</returns>
void OnLoseCondition(object[] args)
{
    Item item = (Item)args[0];
    float amount = (float)args[1];
    Puts($"Item {item.name} has lost {amount} condition.");
    if (item.condition <= 0f && item.condition < ((Item)item).condition)
    {
        Puts($"Item {item.name} is now broken.");
        item.OnBroken();
    }
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnLoseCondition")]
	private object IOnLoseCondition(Item item, float amount)
	{
		object[] array = new object[2] { item, amount };
		Interface.CallHook("OnLoseCondition", array);
		amount = (float)array[1];
		float condition = item.condition;
		item.condition -= amount;
		if (item.condition <= 0f && item.condition < condition)
		{
			item.OnBroken();
		}
		return true;
	}

```

## OnServerCommand(ConsoleSystem.Arg)

```csharp
```csharp
/// <summary>
/// Called when a server command is executed.
/// </summary>
/// <param name="arg">The argument containing the command and its parameters.</param>
/// <returns>
/// Returns `true` to allow the command to execute, or any non-null value to prevent it from executing.
/// If `null` is returned, the default behavior will be used.
/// </returns>
object OnServerCommand(ConsoleSystem.Arg arg)
{
    Puts($"Server command {arg.cmd.FullName} executed by player {arg.Player().displayName}");
    if (arg.cmd.FullName == "admin.kick")
    {
        Puts($"Player {arg.Player().displayName} is not allowed to use the admin.kick command.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnServerCommand")]
	private object IOnServerCommand(ConsoleSystem.Arg arg)
	{
		if (arg == null || (arg.Connection != null && arg.Player() == null))
		{
			return true;
		}
		if (arg.cmd.FullName == "chat.say" || arg.cmd.FullName == "chat.teamsay")
		{
			return null;
		}
		object obj = Interface.CallHook("OnServerCommand", arg);
		object obj2 = Interface.CallHook("OnServerCommand", arg.cmd.FullName, RustCommandSystem.ExtractArgs(arg));
		if (((obj == null) ? obj2 : obj) != null)
		{
			return true;
		}
		return null;
	}

```

## OnServerShutdown()

```csharp
```csharp
/// <summary>
/// Called when the server is shutting down.
/// </summary>
void OnServerShutdown()
{
    Puts("Server shutdown initiated.");
    // Perform any necessary cleanup or shutdown tasks here...
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnServerShutdown")]
	private void IOnServerShutdown()
	{
		Interface.Oxide.CallHook("OnServerShutdown");
		Interface.Oxide.OnShutdown();
		Covalence.PlayerManager.SavePlayerData();
	}

```

## OnUserBanned(string,string,string,string,long)

```csharp
```csharp
/// <summary>
/// Called when a user is banned from the server.
/// </summary>
/// <param name="username">The username of the banned user.</param>
/// <param name="steamId">The Steam ID of the banned user.</param>
/// <param name="ipAddress">The IP address of the banned user.</param>
/// <param name="reason">The reason for the ban.</param>
/// <param name="expiry">The time in seconds until the ban expires.</param>
/// <returns>No return behavior.</returns>
void OnUserBanned(string username, string steamId, string ipAddress, string reason, long expiry)
{
    Puts($"User {username} with SteamID {steamId}, IP {ipAddress} has been banned for {expiry} seconds. Reason: {reason}");
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnServerUsersSet")]
	private void IOnServerUsersSet(ulong steamId, ServerUsers.UserGroup group, string playerName, string reason, long expiry)
	{
		if (serverInitialized && group == ServerUsers.UserGroup.Banned)
		{
			string text = steamId.ToString();
			IPlayer player = Covalence.PlayerManager.FindPlayerById(text);
			Interface.CallHook("OnPlayerBanned", playerName, steamId, player?.Address ?? "0", reason, expiry);
			Interface.CallHook("OnUserBanned", playerName, text, player?.Address ?? "0", reason, expiry);
		}
	}

```

## OnEntityTakeDamage(BasePlayer,HitInfo)

```csharp
```csharp
/// <summary>
/// Called when an entity (in this case, a player) takes damage.
/// </summary>
/// <param name="entity">The entity taking the damage.</param>
/// <param name="hitInfo">Information about the hit that caused the damage.</param>
/// <returns>
/// Returns `true` to allow the entity to take the damage, or any non-null value to prevent them from taking the damage.
/// If a string is returned, it will be used as a message to display to the player.
/// </returns>
object OnEntityTakeDamage(BasePlayer entity, HitInfo hitInfo)
{
    Puts($"Entity {entity.UserIDString} took {hitInfo.damageType} damage from {hitInfo.attacker.UserIDString}.");
    if (hitInfo.damageType == "explosive")
    {
        Puts($"Entity {entity.UserIDString} was damaged by an explosive attack.");
        return "You were hit with an explosive attack!";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnBasePlayerAttacked")]
	private object IOnBasePlayerAttacked(BasePlayer basePlayer, HitInfo hitInfo)
	{
		if (!serverInitialized || basePlayer == null || hitInfo == null || basePlayer.IsDead() || isPlayerTakingDamage || basePlayer is NPCPlayer)
		{
			return null;
		}
		if (Interface.CallHook("OnEntityTakeDamage", basePlayer, hitInfo) != null)
		{
			return true;
		}
		isPlayerTakingDamage = true;
		try
		{
			basePlayer.OnAttacked(hitInfo);
		}
		finally
		{
			isPlayerTakingDamage = false;
		}
		return true;
	}

```

## OnUserApproved(string,string,string)

```csharp
```csharp
/// <summary>
/// Called when a user is approved to join the server.
/// </summary>
/// <param name="username">The username of the approved user.</param>
/// <param name="steamId">The Steam ID of the approved user.</param>
/// <param name="ipAddress">The IP address of the approved user.</param>
/// <returns>
/// Returns a non-null value to override the default approval behavior. 
/// If a string is returned, the user will be kicked with the provided message as the reason. 
/// If `null` is returned, the user is approved as normal.
/// </returns>
object OnUserApproved(string username, ulong steamId, string ipAddress)
{
    Puts($"User {username} with SteamID {steamId} and IP {ipAddress} has been approved to join the server.");
    if (ipAddress == "192.168.1.1")
    {
        Puts($"User {username} with IP {ipAddress} has been blocked from joining.");
        return "Blocked: Unauthorized IP address.";
    }
    // Add custom logic here
    return null;
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnUserApprove")]
	private object IOnUserApprove(Connection connection)
	{
		string username = connection.username;
		string text = connection.userid.ToString();
		string obj = Regex.Replace(connection.ipaddress, ipPattern, "");
		uint authLevel = connection.authLevel;
		if (permission.IsLoaded)
		{
			permission.UpdateNickname(text, username);
			OxideConfig.DefaultGroups defaultGroups = Interface.Oxide.Config.Options.DefaultGroups;
			if (!permission.UserHasGroup(text, defaultGroups.Players))
			{
				permission.AddUserGroup(text, defaultGroups.Players);
			}
			if (authLevel == 2 && !permission.UserHasGroup(text, defaultGroups.Administrators))
			{
				permission.AddUserGroup(text, defaultGroups.Administrators);
			}
		}
		Covalence.PlayerManager.PlayerJoin(connection.userid, username);
		object obj2 = Interface.CallHook("CanClientLogin", connection);
		object obj3 = Interface.CallHook("CanUserLogin", username, text, obj);
		object obj4 = ((obj2 == null) ? obj3 : obj2);
		if (obj4 is string || (obj4 is bool && !(bool)obj4))
		{
			ConnectionAuth.Reject(connection, (obj4 is string) ? obj4.ToString() : lang.GetMessage("ConnectionRejected", this, text));
			return true;
		}
		object obj5 = Interface.CallHook("OnUserApprove", connection);
		object result = Interface.CallHook("OnUserApproved", username, text, obj);
		if (obj5 != null)
		{
			return obj5;
		}
		return result;
	}

```

## OnUserChat(Oxide.Core.Libraries.Covalence.IPlayer,string)

```csharp
```csharp
/// <summary>
/// Called when a user sends a chat message.
/// </summary>
/// <param name="player">The player who sent the chat message.</param>
/// <param name="message">The text of the chat message.</param>
/// <returns>
/// Returns `null` to allow the message to be sent as normal, or any non-null value to override the default behavior.
/// If a string is returned, it will be used as the reason for blocking the message.
/// </returns>
object OnUserChat(IPlayer player, string message)
{
    Puts($"Player {player.Name} sent chat message: {message}");
    if (message.ToLower() == "badword")
    {
        Puts($"Player {player.Name} tried to send a bad word in chat.");
        return "Message blocked: Bad language.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnPlayerChat")]
	private object IOnPlayerChat(ulong playerId, string playerName, string message, BasePlayer basePlayer)
	{
		if (string.IsNullOrEmpty(message) || message.Equals("text"))
		{
			return true;
		}
		if (basePlayer == null || !basePlayer.IsConnected)
		{
			return Interface.CallHook("OnPlayerOfflineChat", playerId, playerName, message);
		}
		object obj = Interface.CallHook("OnPlayerChat", basePlayer, message);
		object result = Interface.CallHook("OnUserChat", basePlayer.IPlayer, message);
		if (obj != null)
		{
			return obj;
		}
		return result;
	}

```

## OnPlayerConnected(BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player connects to the server.
/// </summary>
/// <param name="player">The connected player.</param>
/// <returns>No return behavior.</returns>
void OnPlayerConnected(BasePlayer player)
{
    Puts($"Player {player.UserIDString} has connected to the server.");
    if (player.UserIDString == "admin")
    {
        Puts($"Admin {player.UserIDString} has connected to the server.");
        // Grant admin privileges
    }
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnPlayerConnected")]
	private void IOnPlayerConnected(BasePlayer basePlayer)
	{
		lang.SetLanguage(basePlayer.net.connection.info.GetString("global.language", "en"), basePlayer.UserIDString);
		basePlayer.SendEntitySnapshot(CommunityEntity.ServerInstance);
		Covalence.PlayerManager.PlayerConnected(basePlayer);
		IPlayer player = Covalence.PlayerManager.FindPlayerById(basePlayer.UserIDString);
		if (player != null)
		{
			basePlayer.IPlayer = player;
			Interface.CallHook("OnUserConnected", player);
		}
		Interface.Oxide.CallHook("OnPlayerConnected", basePlayer);
	}

```

## OnEntitySaved(BaseNetworkable,BaseNetworkable.SaveInfo)

```csharp
```csharp
/// <summary>
/// Called when an entity is saved.
/// </summary>
/// <param name="entity">The entity being saved.</param>
/// <param name="saveInfo">Information about the save operation.</param>
/// <returns>No return behavior.</returns>
void OnEntitySaved(BaseNetworkable entity, BaseNetworkable.SaveInfo saveInfo)
{
    Puts($"Entity {entity.EntityID} has been saved.");
    
    // If the entity is a specific type (e.g. a player), perform additional actions
    if (entity is Player player && player.IsOnline)
    {
        Puts($"Player {player.UserIDString} has been saved.");
        
        // Perform any necessary actions for this specific entity type
        // For example, update the player's last seen timestamp
        player.LastSeenTimestamp = DateTime.Now;
    }
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnEntitySaved")]
	private void IOnEntitySaved(BaseNetworkable baseNetworkable, BaseNetworkable.SaveInfo saveInfo)
	{
		if (serverInitialized && saveInfo.forConnection != null)
		{
			Interface.CallHook("OnEntitySaved", baseNetworkable, saveInfo);
		}
	}

```

## OnNpcTarget(NPCPlayerApex,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when an NPC targets a player.
/// </summary>
/// <param name="npc">The NPC doing the targeting.</param>
/// <param name="target">The player being targeted.</param>
/// <returns>
/// Returns `true` to override the default behavior and prevent the target from being sensed by the NPC. 
/// If `null` is returned, the target will be sensed as normal.
/// </returns>
object OnNpcTarget(NPCPlayerApex npc, BasePlayer target)
{
    Puts($"NPC {npc.UserIDString} has targeted player {target.UserIDString}.");
    if (target.IsAdmin())
    {
        Puts($"NPC {npc.UserIDString} is not allowed to target admin player {target.UserIDString}.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	private int GetPlayersSensed(NPCPlayerApex npc, Vector3 position, float distance, BaseEntity[] targetList)
	{
		return BaseEntity.Query.Server.GetInSphere(position, distance, targetList, delegate(BaseEntity entity)
		{
			BasePlayer basePlayer = entity as BasePlayer;
			object obj = ((basePlayer != null && npc != null && basePlayer != npc) ? Interface.CallHook("OnNpcTarget", npc, basePlayer) : null);
			if (obj != null)
			{
				foreach (Memory.SeenInfo item in npc.AiContext.Memory.All)
				{
					if (item.Entity == basePlayer)
					{
						npc.AiContext.Memory.All.Remove(item);
						break;
					}
				}
				foreach (Memory.ExtendedInfo item2 in npc.AiContext.Memory.AllExtended)
				{
					if (item2.Entity == basePlayer)
					{
						npc.AiContext.Memory.AllExtended.Remove(item2);
						break;
					}
				}
			}
			return basePlayer != null && obj == null && basePlayer.isServer && !basePlayer.IsSleeping() && !basePlayer.IsDead() && basePlayer.Family != npc.Family;
		});
	}

```

## OnPlayerCommand(BasePlayer,string,string[])

```csharp
```csharp
/// <summary>
/// Called when a player issues a command.
/// </summary>
/// <param name="player">The player issuing the command.</param>
/// <param name="commandName">The name of the command being issued.</param>
/// <param name="args">The arguments passed to the command.</param>
/// <returns>
/// Returns `true` if the command should be handled by this hook, or `false` otherwise.
/// If a non-null value is returned, it will override the default behavior and be used as the response to the player.
/// </returns>
object OnPlayerCommand(BasePlayer player, string commandName, string[] args)
{
    Puts($"Player {player.UserIDString} issued command: /{commandName} {string.Join(" ", args)}");
    if (commandName == "admin-only")
    {
        Puts($"Player {player.displayName} does not have admin privileges.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnPlayerCommand")]
	private void IOnPlayerCommand(BasePlayer basePlayer, string message)
	{
		if (basePlayer == null || !basePlayer.IsConnected)
		{
			return;
		}
		string text = message.Replace("\n", "").Replace("\r", "").Trim();
		if (string.IsNullOrEmpty(text) || text[0] != '/' || text.Length <= 1)
		{
			return;
		}
		ParseCommand(text.TrimStart('/'), out var command, out var args);
		if (command != null)
		{
			object obj = Interface.CallHook("OnPlayerCommand", basePlayer, command, args);
			object obj2 = Interface.CallHook("OnUserCommand", basePlayer.IPlayer, command, args);
			if (((obj == null) ? obj2 : obj) == null && !Covalence.CommandSystem.HandleChatMessage(basePlayer.IPlayer, text) && !cmdlib.HandleChatCommand(basePlayer, command, args) && Interface.Oxide.Config.Options.Modded)
			{
				basePlayer.IPlayer.Reply(string.Format(lang.GetMessage("UnknownCommand", this, basePlayer.IPlayer.Id), command));
			}
		}
	}

```

## CanUseUI(BasePlayer,string)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can use the UI.
/// </summary>
/// <param name="player">The player attempting to use the UI.</param>
/// <param name="json">The JSON data related to the UI.</param>
/// <returns>
/// Returns `null` to allow the player to use the UI, or any non-null value to prevent them from using it.
/// </returns>
object CanUseUI(BasePlayer player, string json)
{
    Puts($"Player {player.UserIDString} is attempting to use the UI with JSON: {json}");
    if (json == "restricted")
    {
        Puts($"Player {player.displayName} does not have permission to use the restricted UI.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public static bool AddUi(BasePlayer player, string json)
	{
		if (player?.net != null && Interface.CallHook("CanUseUI", player, json) == null)
		{
			CommunityEntity.ServerInstance.ClientRPCEx(new SendInfo
			{
				connection = player.net.connection
			}, null, "AddUI", json);
			return true;
		}
		return false;
	}

```

## OnPlayerUnbanned(string,ulong,string)

```csharp
```csharp
/// <summary>
/// Called when a player is unbanned from the server.
/// </summary>
/// <param name="username">The username of the unbanned player.</param>
/// <param name="steamId">The Steam ID of the unbanned player.</param>
/// <param name="ipAddress">The IP address of the unbanned player.</param>
/// <returns>No return behavior.</returns>
void OnPlayerUnbanned(string username, ulong steamId, string ipAddress)
{
    Puts($"Player {username} with SteamID {steamId} and IP {ipAddress} has been unbanned from the server.");
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnServerUsersRemove")]
	private void IOnServerUsersRemove(ulong steamId)
	{
		if (serverInitialized && ServerUsers.users.ContainsKey(steamId) && ServerUsers.users[steamId].group == ServerUsers.UserGroup.Banned)
		{
			string text = steamId.ToString();
			IPlayer player = Covalence.PlayerManager.FindPlayerById(text);
			Interface.CallHook("OnPlayerUnbanned", player?.Name ?? "Unnamed", steamId, player?.Address ?? "0");
			Interface.CallHook("OnUserUnbanned", player?.Name ?? "Unnamed", text, player?.Address ?? "0");
		}
	}

```

## OnUserApprove(Network.Connection)

```csharp
```csharp
/// <summary>
/// Called when a user is approved to join the server.
/// </summary>
/// <param name="connection">The connection object for the user being approved.</param>
/// <returns>
/// Returns `null` to allow the user to be approved, or any non-null value to override the default approval behavior. 
/// If a string is returned, the user will be kicked with the provided message as the reason.
/// </returns>
object OnUserApprove(Connection connection)
{
    Puts($"User {connection.username} has been approved to join the server.");
    if (connection.ipaddress == "192.168.1.1")
    {
        Puts($"User {connection.username} with IP {connection.ipaddress} has been blocked from joining.");
        return "Blocked: Unauthorized IP address.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnUserApprove")]
	private object IOnUserApprove(Connection connection)
	{
		string username = connection.username;
		string text = connection.userid.ToString();
		string obj = Regex.Replace(connection.ipaddress, ipPattern, "");
		uint authLevel = connection.authLevel;
		if (permission.IsLoaded)
		{
			permission.UpdateNickname(text, username);
			OxideConfig.DefaultGroups defaultGroups = Interface.Oxide.Config.Options.DefaultGroups;
			if (!permission.UserHasGroup(text, defaultGroups.Players))
			{
				permission.AddUserGroup(text, defaultGroups.Players);
			}
			if (authLevel == 2 && !permission.UserHasGroup(text, defaultGroups.Administrators))
			{
				permission.AddUserGroup(text, defaultGroups.Administrators);
			}
		}
		Covalence.PlayerManager.PlayerJoin(connection.userid, username);
		object obj2 = Interface.CallHook("CanClientLogin", connection);
		object obj3 = Interface.CallHook("CanUserLogin", username, text, obj);
		object obj4 = ((obj2 == null) ? obj3 : obj2);
		if (obj4 is string || (obj4 is bool && !(bool)obj4))
		{
			ConnectionAuth.Reject(connection, (obj4 is string) ? obj4.ToString() : lang.GetMessage("ConnectionRejected", this, text));
			return true;
		}
		object obj5 = Interface.CallHook("OnUserApprove", connection);
		object result = Interface.CallHook("OnUserApproved", username, text, obj);
		if (obj5 != null)
		{
			return obj5;
		}
		return result;
	}

```

## CanPickupEntity(BasePlayer,DoorCloser)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can pickup an entity.
/// </summary>
/// <param name="player">The player attempting to pick up the entity.</param>
/// <param name="entity">The entity being picked up.</param>
/// <returns>
/// Returns `true` if the player can pick up the entity, or `false` otherwise.
/// If a non-bool value is returned, it will be treated as `false`.
/// </returns>
object CanPickupEntity(BasePlayer player, DoorCloser entity)
{
    Puts($"Player {player.UserIDString} attempting to pick up {entity.GetType().Name} at position {entity.transform.position}");
    if (entity.IsLocked)
    {
        Puts($"Player {player.displayName} cannot pick up locked {entity.GetType().Name}.");
        return false;
    }
    return true;
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("ICanPickupEntity")]
	private object ICanPickupEntity(BasePlayer basePlayer, DoorCloser entity)
	{
		object obj = Interface.CallHook("CanPickupEntity", basePlayer, entity);
		if (!(obj is bool) || (bool)obj)
		{
			return null;
		}
		return true;
	}

```

